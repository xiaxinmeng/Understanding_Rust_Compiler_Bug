{"sha": "0a387eca30eaf0766b8de644dd61bf9cadbbf21d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGEzODdlY2EzMGVhZjA3NjZiOGRlNjQ0ZGQ2MWJmOWNhZGJiZjIxZA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2013-10-14T12:57:11Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2013-10-14T12:57:11Z"}, "message": "lto.c (gimple_types, [...]): Remove old merging code and statistics.\n\n2013-10-14  Richard Biener  <rguenther@suse.de>\n\n\tlto/\n\t* lto.c (gimple_types, type_hash_cache, struct type_pair_d,\n\ttype_pair_cache, lookup_type_pair, struct sccs, next_dfs_num,\n\tgtc_next_dfs_num, compare_type_names_p, gtc_visit,\n\tgimple_types_compatible_p_1, gimple_types_compatible_p,\n\tvisit, iterative_hash_name, struct type_hash_pair,\n\ttype_hash_pair_compare, iterative_hash_gimple_type, gimple_type_hash,\n\tgimple_type_eq, gimple_register_type, num_not_merged_types,\n\tnum_not_merged_types_in_same_scc, num_not_merged_types_trees,\n\tnum_not_merged_types_in_same_scc_trees): Remove old merging code\n\tand statistics.\n\t(lto_read_decls): Do not run old merging code in parallel.\n\t(read_cgraph_and_symbols): Do not init/free old merging\n\tdata structures.\n\t(print_lto_report_1): Do not report differences of old vs. new\n\tmerging code.\n\nFrom-SVN: r203533", "tree": {"sha": "d015e96919c82a5177c24d12355e967bd12c39ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d015e96919c82a5177c24d12355e967bd12c39ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0a387eca30eaf0766b8de644dd61bf9cadbbf21d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a387eca30eaf0766b8de644dd61bf9cadbbf21d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a387eca30eaf0766b8de644dd61bf9cadbbf21d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a387eca30eaf0766b8de644dd61bf9cadbbf21d/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "055416a8d14d5d741fcbf42b1f1396241737e4e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/055416a8d14d5d741fcbf42b1f1396241737e4e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/055416a8d14d5d741fcbf42b1f1396241737e4e6"}], "stats": {"total": 1104, "additions": 18, "deletions": 1086}, "files": [{"sha": "3186decee62e8154b51d3ebfd2362809207a46b7", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a387eca30eaf0766b8de644dd61bf9cadbbf21d/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a387eca30eaf0766b8de644dd61bf9cadbbf21d/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=0a387eca30eaf0766b8de644dd61bf9cadbbf21d", "patch": "@@ -1,3 +1,21 @@\n+2013-10-14  Richard Biener  <rguenther@suse.de>\n+\n+\t* lto.c (gimple_types, type_hash_cache, struct type_pair_d,\n+\ttype_pair_cache, lookup_type_pair, struct sccs, next_dfs_num,\n+\tgtc_next_dfs_num, compare_type_names_p, gtc_visit,\n+\tgimple_types_compatible_p_1, gimple_types_compatible_p,\n+\tvisit, iterative_hash_name, struct type_hash_pair,\n+\ttype_hash_pair_compare, iterative_hash_gimple_type, gimple_type_hash,\n+\tgimple_type_eq, gimple_register_type, num_not_merged_types,\n+\tnum_not_merged_types_in_same_scc, num_not_merged_types_trees,\n+\tnum_not_merged_types_in_same_scc_trees): Remove old merging code\n+\tand statistics.\n+\t(lto_read_decls): Do not run old merging code in parallel.\n+\t(read_cgraph_and_symbols): Do not init/free old merging\n+\tdata structures.\n+\t(print_lto_report_1): Do not report differences of old vs. new\n+\tmerging code.\n+\n 2013-10-14  Richard Biener  <rguenther@suse.de>\n \n \t* lto-lang.c (lto_init): Do not re-init canonical types here."}, {"sha": "4d386111e8779192acbefd5a787573f551c2e371", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 0, "deletions": 1086, "changes": 1086, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a387eca30eaf0766b8de644dd61bf9cadbbf21d/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a387eca30eaf0766b8de644dd61bf9cadbbf21d/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=0a387eca30eaf0766b8de644dd61bf9cadbbf21d", "patch": "@@ -676,1037 +676,6 @@ lto_register_canonical_types (tree node)\n }\n \n \n-/* ???  Old hashing and merging code follows, we keep it for statistics\n-   purposes for now.  */\n-\n-/* Global type table.  FIXME, it should be possible to re-use some\n-   of the type hashing routines in tree.c (type_hash_canon, type_hash_lookup,\n-   etc), but those assume that types were built with the various\n-   build_*_type routines which is not the case with the streamer.  */\n-static GTY((if_marked (\"ggc_marked_p\"), param_is (union tree_node)))\n-  htab_t gimple_types;\n-static GTY((if_marked (\"tree_int_map_marked_p\"), param_is (struct tree_int_map)))\n-  htab_t type_hash_cache;\n-\n-static hashval_t gimple_type_hash (const void *);\n-\n-/* Structure used to maintain a cache of some type pairs compared by\n-   gimple_types_compatible_p when comparing aggregate types.  There are\n-   three possible values for SAME_P:\n-\n-   \t-2: The pair (T1, T2) has just been inserted in the table.\n-\t 0: T1 and T2 are different types.\n-\t 1: T1 and T2 are the same type.  */\n-\n-struct type_pair_d\n-{\n-  unsigned int uid1;\n-  unsigned int uid2;\n-  signed char same_p;\n-};\n-typedef struct type_pair_d *type_pair_t;\n-\n-#define GIMPLE_TYPE_PAIR_SIZE 16381\n-struct type_pair_d *type_pair_cache;\n-\n-\n-/* Lookup the pair of types T1 and T2 in *VISITED_P.  Insert a new\n-   entry if none existed.  */\n-\n-static inline type_pair_t\n-lookup_type_pair (tree t1, tree t2)\n-{\n-  unsigned int index;\n-  unsigned int uid1, uid2;\n-\n-  if (TYPE_UID (t1) < TYPE_UID (t2))\n-    {\n-      uid1 = TYPE_UID (t1);\n-      uid2 = TYPE_UID (t2);\n-    }\n-  else\n-    {\n-      uid1 = TYPE_UID (t2);\n-      uid2 = TYPE_UID (t1);\n-    }\n-  gcc_checking_assert (uid1 != uid2);\n-\n-  /* iterative_hash_hashval_t imply an function calls.\n-     We know that UIDS are in limited range.  */\n-  index = ((((unsigned HOST_WIDE_INT)uid1 << HOST_BITS_PER_WIDE_INT / 2) + uid2)\n-\t   % GIMPLE_TYPE_PAIR_SIZE);\n-  if (type_pair_cache [index].uid1 == uid1\n-      && type_pair_cache [index].uid2 == uid2)\n-    return &type_pair_cache[index];\n-\n-  type_pair_cache [index].uid1 = uid1;\n-  type_pair_cache [index].uid2 = uid2;\n-  type_pair_cache [index].same_p = -2;\n-\n-  return &type_pair_cache[index];\n-}\n-\n-/* Per pointer state for the SCC finding.  The on_sccstack flag\n-   is not strictly required, it is true when there is no hash value\n-   recorded for the type and false otherwise.  But querying that\n-   is slower.  */\n-\n-struct sccs\n-{\n-  unsigned int dfsnum;\n-  unsigned int low;\n-  bool on_sccstack;\n-  union {\n-    hashval_t hash;\n-    signed char same_p;\n-  } u;\n-};\n-\n-static unsigned int next_dfs_num;\n-static unsigned int gtc_next_dfs_num;\n-\n-/* Return true if T1 and T2 have the same name.  If FOR_COMPLETION_P is\n-   true then if any type has no name return false, otherwise return\n-   true if both types have no names.  */\n-\n-static bool\n-compare_type_names_p (tree t1, tree t2)\n-{\n-  tree name1 = TYPE_NAME (t1);\n-  tree name2 = TYPE_NAME (t2);\n-\n-  if ((name1 != NULL_TREE) != (name2 != NULL_TREE))\n-    return false;\n-\n-  if (name1 == NULL_TREE)\n-    return true;\n-\n-  /* Either both should be a TYPE_DECL or both an IDENTIFIER_NODE.  */\n-  if (TREE_CODE (name1) != TREE_CODE (name2))\n-    return false;\n-\n-  if (TREE_CODE (name1) == TYPE_DECL)\n-    name1 = DECL_NAME (name1);\n-  gcc_checking_assert (!name1 || TREE_CODE (name1) == IDENTIFIER_NODE);\n-\n-  if (TREE_CODE (name2) == TYPE_DECL)\n-    name2 = DECL_NAME (name2);\n-  gcc_checking_assert (!name2 || TREE_CODE (name2) == IDENTIFIER_NODE);\n-\n-  /* Identifiers can be compared with pointer equality rather\n-     than a string comparison.  */\n-  if (name1 == name2)\n-    return true;\n-\n-  return false;\n-}\n-\n-static bool\n-gimple_types_compatible_p_1 (tree, tree, type_pair_t,\n-\t\t\t     vec<type_pair_t> *,\n-\t\t\t     struct pointer_map_t *, struct obstack *);\n-\n-/* DFS visit the edge from the callers type pair with state *STATE to\n-   the pair T1, T2 while operating in FOR_MERGING_P mode.\n-   Update the merging status if it is not part of the SCC containing the\n-   callers pair and return it.\n-   SCCSTACK, SCCSTATE and SCCSTATE_OBSTACK are state for the DFS walk done.  */\n-\n-static bool\n-gtc_visit (tree t1, tree t2,\n-\t   struct sccs *state,\n-\t   vec<type_pair_t> *sccstack,\n-\t   struct pointer_map_t *sccstate,\n-\t   struct obstack *sccstate_obstack)\n-{\n-  struct sccs *cstate = NULL;\n-  type_pair_t p;\n-  void **slot;\n-\n-  /* Check first for the obvious case of pointer identity.  */\n-  if (t1 == t2)\n-    return true;\n-\n-  /* Check that we have two types to compare.  */\n-  if (t1 == NULL_TREE || t2 == NULL_TREE)\n-    return false;\n-\n-  /* Can't be the same type if the types don't have the same code.  */\n-  if (TREE_CODE (t1) != TREE_CODE (t2))\n-    return false;\n-\n-  /* Can't be the same type if they have different CV qualifiers.  */\n-  if (TYPE_QUALS (t1) != TYPE_QUALS (t2))\n-    return false;\n-\n-  if (TREE_ADDRESSABLE (t1) != TREE_ADDRESSABLE (t2))\n-    return false;\n-\n-  /* Void types and nullptr types are always the same.  */\n-  if (TREE_CODE (t1) == VOID_TYPE\n-      || TREE_CODE (t1) == NULLPTR_TYPE)\n-    return true;\n-\n-  /* Can't be the same type if they have different alignment or mode.  */\n-  if (TYPE_ALIGN (t1) != TYPE_ALIGN (t2)\n-      || TYPE_MODE (t1) != TYPE_MODE (t2))\n-    return false;\n-\n-  /* Do some simple checks before doing three hashtable queries.  */\n-  if (INTEGRAL_TYPE_P (t1)\n-      || SCALAR_FLOAT_TYPE_P (t1)\n-      || FIXED_POINT_TYPE_P (t1)\n-      || TREE_CODE (t1) == VECTOR_TYPE\n-      || TREE_CODE (t1) == COMPLEX_TYPE\n-      || TREE_CODE (t1) == OFFSET_TYPE\n-      || POINTER_TYPE_P (t1))\n-    {\n-      /* Can't be the same type if they have different sign or precision.  */\n-      if (TYPE_PRECISION (t1) != TYPE_PRECISION (t2)\n-\t  || TYPE_UNSIGNED (t1) != TYPE_UNSIGNED (t2))\n-\treturn false;\n-\n-      if (TREE_CODE (t1) == INTEGER_TYPE\n-\t  && TYPE_STRING_FLAG (t1) != TYPE_STRING_FLAG (t2))\n-\treturn false;\n-\n-      /* That's all we need to check for float and fixed-point types.  */\n-      if (SCALAR_FLOAT_TYPE_P (t1)\n-\t  || FIXED_POINT_TYPE_P (t1))\n-\treturn true;\n-\n-      /* For other types fall through to more complex checks.  */\n-    }\n-\n-  /* If the hash values of t1 and t2 are different the types can't\n-     possibly be the same.  This helps keeping the type-pair hashtable\n-     small, only tracking comparisons for hash collisions.  */\n-  if (gimple_type_hash (t1) != gimple_type_hash (t2))\n-    return false;\n-\n-  /* Allocate a new cache entry for this comparison.  */\n-  p = lookup_type_pair (t1, t2);\n-  if (p->same_p == 0 || p->same_p == 1)\n-    {\n-      /* We have already decided whether T1 and T2 are the\n-\t same, return the cached result.  */\n-      return p->same_p == 1;\n-    }\n-\n-  if ((slot = pointer_map_contains (sccstate, p)) != NULL)\n-    cstate = (struct sccs *)*slot;\n-  /* Not yet visited.  DFS recurse.  */\n-  if (!cstate)\n-    {\n-      gimple_types_compatible_p_1 (t1, t2, p,\n-\t\t\t\t   sccstack, sccstate, sccstate_obstack);\n-      cstate = (struct sccs *)* pointer_map_contains (sccstate, p);\n-      state->low = MIN (state->low, cstate->low);\n-    }\n-  /* If the type is still on the SCC stack adjust the parents low.  */\n-  if (cstate->dfsnum < state->dfsnum\n-      && cstate->on_sccstack)\n-    state->low = MIN (cstate->dfsnum, state->low);\n-\n-  /* Return the current lattice value.  We start with an equality\n-     assumption so types part of a SCC will be optimistically\n-     treated equal unless proven otherwise.  */\n-  return cstate->u.same_p;\n-}\n-\n-/* Worker for gimple_types_compatible.\n-   SCCSTACK, SCCSTATE and SCCSTATE_OBSTACK are state for the DFS walk done.  */\n-\n-static bool\n-gimple_types_compatible_p_1 (tree t1, tree t2, type_pair_t p,\n-\t\t\t     vec<type_pair_t> *sccstack,\n-\t\t\t     struct pointer_map_t *sccstate,\n-\t\t\t     struct obstack *sccstate_obstack)\n-{\n-  struct sccs *state;\n-\n-  gcc_assert (p->same_p == -2);\n-\n-  state = XOBNEW (sccstate_obstack, struct sccs);\n-  *pointer_map_insert (sccstate, p) = state;\n-\n-  sccstack->safe_push (p);\n-  state->dfsnum = gtc_next_dfs_num++;\n-  state->low = state->dfsnum;\n-  state->on_sccstack = true;\n-  /* Start with an equality assumption.  As we DFS recurse into child\n-     SCCs this assumption may get revisited.  */\n-  state->u.same_p = 1;\n-\n-  /* The struct tags shall compare equal.  */\n-  if (!compare_type_names_p (t1, t2))\n-    goto different_types;\n-\n-  /* The main variant of both types should compare equal.  */\n-  if (TYPE_MAIN_VARIANT (t1) != t1\n-      || TYPE_MAIN_VARIANT (t2) != t2)\n-    {\n-      if (!gtc_visit (TYPE_MAIN_VARIANT (t1), TYPE_MAIN_VARIANT (t2),\n-\t\t      state, sccstack, sccstate, sccstate_obstack))\n-\tgoto different_types;\n-    }\n-\n-  /* We may not merge typedef types to the same type in different\n-     contexts.  */\n-  if (TYPE_NAME (t1)\n-      && TREE_CODE (TYPE_NAME (t1)) == TYPE_DECL\n-      && DECL_CONTEXT (TYPE_NAME (t1))\n-      && TYPE_P (DECL_CONTEXT (TYPE_NAME (t1))))\n-    {\n-      if (!gtc_visit (DECL_CONTEXT (TYPE_NAME (t1)),\n-\t\t      DECL_CONTEXT (TYPE_NAME (t2)),\n-\t\t      state, sccstack, sccstate, sccstate_obstack))\n-\tgoto different_types;\n-    }\n-\n-  /* If their attributes are not the same they can't be the same type.  */\n-  if (!attribute_list_equal (TYPE_ATTRIBUTES (t1), TYPE_ATTRIBUTES (t2)))\n-    goto different_types;\n-\n-  /* Do type-specific comparisons.  */\n-  switch (TREE_CODE (t1))\n-    {\n-    case VECTOR_TYPE:\n-    case COMPLEX_TYPE:\n-      if (!gtc_visit (TREE_TYPE (t1), TREE_TYPE (t2),\n-\t\t      state, sccstack, sccstate, sccstate_obstack))\n-\tgoto different_types;\n-      goto same_types;\n-\n-    case ARRAY_TYPE:\n-      /* Array types are the same if the element types are the same and\n-\t the number of elements are the same.  */\n-      if (!gtc_visit (TREE_TYPE (t1), TREE_TYPE (t2),\n-\t\t      state, sccstack, sccstate, sccstate_obstack)\n-\t  || TYPE_STRING_FLAG (t1) != TYPE_STRING_FLAG (t2)\n-\t  || TYPE_NONALIASED_COMPONENT (t1) != TYPE_NONALIASED_COMPONENT (t2))\n-\tgoto different_types;\n-      else\n-\t{\n-\t  tree i1 = TYPE_DOMAIN (t1);\n-\t  tree i2 = TYPE_DOMAIN (t2);\n-\n-\t  /* For an incomplete external array, the type domain can be\n- \t     NULL_TREE.  Check this condition also.  */\n-\t  if (i1 == NULL_TREE && i2 == NULL_TREE)\n-\t    goto same_types;\n-\t  else if (i1 == NULL_TREE || i2 == NULL_TREE)\n-\t    goto different_types;\n-\t  else\n-\t    {\n-\t      tree min1 = TYPE_MIN_VALUE (i1);\n-\t      tree min2 = TYPE_MIN_VALUE (i2);\n-\t      tree max1 = TYPE_MAX_VALUE (i1);\n-\t      tree max2 = TYPE_MAX_VALUE (i2);\n-\n-\t      /* The minimum/maximum values have to be the same.  */\n-\t      if ((min1 == min2\n-\t\t   || (min1 && min2\n-\t\t       && ((TREE_CODE (min1) == PLACEHOLDER_EXPR\n-\t\t\t    && TREE_CODE (min2) == PLACEHOLDER_EXPR)\n-\t\t           || operand_equal_p (min1, min2, 0))))\n-\t\t  && (max1 == max2\n-\t\t      || (max1 && max2\n-\t\t\t  && ((TREE_CODE (max1) == PLACEHOLDER_EXPR\n-\t\t\t       && TREE_CODE (max2) == PLACEHOLDER_EXPR)\n-\t\t\t      || operand_equal_p (max1, max2, 0)))))\n-\t\tgoto same_types;\n-\t      else\n-\t\tgoto different_types;\n-\t    }\n-\t}\n-\n-    case METHOD_TYPE:\n-      /* Method types should belong to the same class.  */\n-      if (!gtc_visit (TYPE_METHOD_BASETYPE (t1), TYPE_METHOD_BASETYPE (t2),\n-\t\t      state, sccstack, sccstate, sccstate_obstack))\n-\tgoto different_types;\n-\n-      /* Fallthru  */\n-\n-    case FUNCTION_TYPE:\n-      /* Function types are the same if the return type and arguments types\n-\t are the same.  */\n-      if (!gtc_visit (TREE_TYPE (t1), TREE_TYPE (t2),\n-\t\t      state, sccstack, sccstate, sccstate_obstack))\n-\tgoto different_types;\n-\n-      if (!comp_type_attributes (t1, t2))\n-\tgoto different_types;\n-\n-      if (TYPE_ARG_TYPES (t1) == TYPE_ARG_TYPES (t2))\n-\tgoto same_types;\n-      else\n-\t{\n-\t  tree parms1, parms2;\n-\n-\t  for (parms1 = TYPE_ARG_TYPES (t1), parms2 = TYPE_ARG_TYPES (t2);\n-\t       parms1 && parms2;\n-\t       parms1 = TREE_CHAIN (parms1), parms2 = TREE_CHAIN (parms2))\n-\t    {\n-\t      if (!gtc_visit (TREE_VALUE (parms1), TREE_VALUE (parms2),\n-\t\t\t      state, sccstack, sccstate, sccstate_obstack))\n-\t\tgoto different_types;\n-\t    }\n-\n-\t  if (parms1 || parms2)\n-\t    goto different_types;\n-\n-\t  goto same_types;\n-\t}\n-\n-    case OFFSET_TYPE:\n-      {\n-\tif (!gtc_visit (TREE_TYPE (t1), TREE_TYPE (t2),\n-\t\t\tstate, sccstack, sccstate, sccstate_obstack)\n-\t    || !gtc_visit (TYPE_OFFSET_BASETYPE (t1),\n-\t\t\t   TYPE_OFFSET_BASETYPE (t2),\n-\t\t\t   state, sccstack, sccstate, sccstate_obstack))\n-\t  goto different_types;\n-\n-\tgoto same_types;\n-      }\n-\n-    case POINTER_TYPE:\n-    case REFERENCE_TYPE:\n-      {\n-\t/* If the two pointers have different ref-all attributes,\n-\t   they can't be the same type.  */\n-\tif (TYPE_REF_CAN_ALIAS_ALL (t1) != TYPE_REF_CAN_ALIAS_ALL (t2))\n-\t  goto different_types;\n-\n-\t/* Otherwise, pointer and reference types are the same if the\n-\t   pointed-to types are the same.  */\n-\tif (gtc_visit (TREE_TYPE (t1), TREE_TYPE (t2),\n-\t\t       state, sccstack, sccstate, sccstate_obstack))\n-\t  goto same_types;\n-\n-\tgoto different_types;\n-      }\n-\n-    case INTEGER_TYPE:\n-    case BOOLEAN_TYPE:\n-      {\n-\ttree min1 = TYPE_MIN_VALUE (t1);\n-\ttree max1 = TYPE_MAX_VALUE (t1);\n-\ttree min2 = TYPE_MIN_VALUE (t2);\n-\ttree max2 = TYPE_MAX_VALUE (t2);\n-\tbool min_equal_p = false;\n-\tbool max_equal_p = false;\n-\n-\t/* If either type has a minimum value, the other type must\n-\t   have the same.  */\n-\tif (min1 == NULL_TREE && min2 == NULL_TREE)\n-\t  min_equal_p = true;\n-\telse if (min1 && min2 && operand_equal_p (min1, min2, 0))\n-\t  min_equal_p = true;\n-\n-\t/* Likewise, if either type has a maximum value, the other\n-\t   type must have the same.  */\n-\tif (max1 == NULL_TREE && max2 == NULL_TREE)\n-\t  max_equal_p = true;\n-\telse if (max1 && max2 && operand_equal_p (max1, max2, 0))\n-\t  max_equal_p = true;\n-\n-\tif (!min_equal_p || !max_equal_p)\n-\t  goto different_types;\n-\n-\tgoto same_types;\n-      }\n-\n-    case ENUMERAL_TYPE:\n-      {\n-\t/* FIXME lto, we cannot check bounds on enumeral types because\n-\t   different front ends will produce different values.\n-\t   In C, enumeral types are integers, while in C++ each element\n-\t   will have its own symbolic value.  We should decide how enums\n-\t   are to be represented in GIMPLE and have each front end lower\n-\t   to that.  */\n-\ttree v1, v2;\n-\n-\t/* For enumeral types, all the values must be the same.  */\n-\tif (TYPE_VALUES (t1) == TYPE_VALUES (t2))\n-\t  goto same_types;\n-\n-\tfor (v1 = TYPE_VALUES (t1), v2 = TYPE_VALUES (t2);\n-\t     v1 && v2;\n-\t     v1 = TREE_CHAIN (v1), v2 = TREE_CHAIN (v2))\n-\t  {\n-\t    tree c1 = TREE_VALUE (v1);\n-\t    tree c2 = TREE_VALUE (v2);\n-\n-\t    if (TREE_CODE (c1) == CONST_DECL)\n-\t      c1 = DECL_INITIAL (c1);\n-\n-\t    if (TREE_CODE (c2) == CONST_DECL)\n-\t      c2 = DECL_INITIAL (c2);\n-\n-\t    if (tree_int_cst_equal (c1, c2) != 1)\n-\t      goto different_types;\n-\n-\t    if (TREE_PURPOSE (v1) != TREE_PURPOSE (v2))\n-\t      goto different_types;\n-\t  }\n-\n-\t/* If one enumeration has more values than the other, they\n-\t   are not the same.  */\n-\tif (v1 || v2)\n-\t  goto different_types;\n-\n-\tgoto same_types;\n-      }\n-\n-    case RECORD_TYPE:\n-    case UNION_TYPE:\n-    case QUAL_UNION_TYPE:\n-      {\n-\ttree f1, f2;\n-\n-\t/* For aggregate types, all the fields must be the same.  */\n-\tfor (f1 = TYPE_FIELDS (t1), f2 = TYPE_FIELDS (t2);\n-\t     f1 && f2;\n-\t     f1 = TREE_CHAIN (f1), f2 = TREE_CHAIN (f2))\n-\t  {\n-\t    /* Different field kinds are not compatible.  */\n-\t    if (TREE_CODE (f1) != TREE_CODE (f2))\n-\t      goto different_types;\n-\t    /* Field decls must have the same name and offset.  */\n-\t    if (TREE_CODE (f1) == FIELD_DECL\n-\t\t&& (DECL_NONADDRESSABLE_P (f1) != DECL_NONADDRESSABLE_P (f2)\n-\t\t    || !gimple_compare_field_offset (f1, f2)))\n-\t      goto different_types;\n-\t    /* All entities should have the same name and type.  */\n-\t    if (DECL_NAME (f1) != DECL_NAME (f2)\n-\t\t|| !gtc_visit (TREE_TYPE (f1), TREE_TYPE (f2),\n-\t\t\t       state, sccstack, sccstate, sccstate_obstack))\n-\t      goto different_types;\n-\t  }\n-\n-\t/* If one aggregate has more fields than the other, they\n-\t   are not the same.  */\n-\tif (f1 || f2)\n-\t  goto different_types;\n-\n-\tgoto same_types;\n-      }\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  /* Common exit path for types that are not compatible.  */\n-different_types:\n-  state->u.same_p = 0;\n-  goto pop;\n-\n-  /* Common exit path for types that are compatible.  */\n-same_types:\n-  gcc_assert (state->u.same_p == 1);\n-\n-pop:\n-  if (state->low == state->dfsnum)\n-    {\n-      type_pair_t x;\n-\n-      /* Pop off the SCC and set its cache values to the final\n-         comparison result.  */\n-      do\n-\t{\n-\t  struct sccs *cstate;\n-\t  x = sccstack->pop ();\n-\t  cstate = (struct sccs *)*pointer_map_contains (sccstate, x);\n-\t  cstate->on_sccstack = false;\n-\t  x->same_p = state->u.same_p;\n-\t}\n-      while (x != p);\n-    }\n-\n-  return state->u.same_p;\n-}\n-\n-/* Return true iff T1 and T2 are structurally identical.  When\n-   FOR_MERGING_P is true the an incomplete type and a complete type\n-   are considered different, otherwise they are considered compatible.  */\n-\n-static bool\n-gimple_types_compatible_p (tree t1, tree t2)\n-{\n-  vec<type_pair_t> sccstack = vNULL;\n-  struct pointer_map_t *sccstate;\n-  struct obstack sccstate_obstack;\n-  type_pair_t p = NULL;\n-  bool res;\n-\n-  /* Before starting to set up the SCC machinery handle simple cases.  */\n-\n-  /* Check first for the obvious case of pointer identity.  */\n-  if (t1 == t2)\n-    return true;\n-\n-  /* Check that we have two types to compare.  */\n-  if (t1 == NULL_TREE || t2 == NULL_TREE)\n-    return false;\n-\n-  /* Can't be the same type if the types don't have the same code.  */\n-  if (TREE_CODE (t1) != TREE_CODE (t2))\n-    return false;\n-\n-  /* Can't be the same type if they have different CV qualifiers.  */\n-  if (TYPE_QUALS (t1) != TYPE_QUALS (t2))\n-    return false;\n-\n-  if (TREE_ADDRESSABLE (t1) != TREE_ADDRESSABLE (t2))\n-    return false;\n-\n-  /* Void types and nullptr types are always the same.  */\n-  if (TREE_CODE (t1) == VOID_TYPE\n-      || TREE_CODE (t1) == NULLPTR_TYPE)\n-    return true;\n-\n-  /* Can't be the same type if they have different alignment or mode.  */\n-  if (TYPE_ALIGN (t1) != TYPE_ALIGN (t2)\n-      || TYPE_MODE (t1) != TYPE_MODE (t2))\n-    return false;\n-\n-  /* Do some simple checks before doing three hashtable queries.  */\n-  if (INTEGRAL_TYPE_P (t1)\n-      || SCALAR_FLOAT_TYPE_P (t1)\n-      || FIXED_POINT_TYPE_P (t1)\n-      || TREE_CODE (t1) == VECTOR_TYPE\n-      || TREE_CODE (t1) == COMPLEX_TYPE\n-      || TREE_CODE (t1) == OFFSET_TYPE\n-      || POINTER_TYPE_P (t1))\n-    {\n-      /* Can't be the same type if they have different sign or precision.  */\n-      if (TYPE_PRECISION (t1) != TYPE_PRECISION (t2)\n-\t  || TYPE_UNSIGNED (t1) != TYPE_UNSIGNED (t2))\n-\treturn false;\n-\n-      if (TREE_CODE (t1) == INTEGER_TYPE\n-\t  && TYPE_STRING_FLAG (t1) != TYPE_STRING_FLAG (t2))\n-\treturn false;\n-\n-      /* That's all we need to check for float and fixed-point types.  */\n-      if (SCALAR_FLOAT_TYPE_P (t1)\n-\t  || FIXED_POINT_TYPE_P (t1))\n-\treturn true;\n-\n-      /* For other types fall through to more complex checks.  */\n-    }\n-\n-  /* If the hash values of t1 and t2 are different the types can't\n-     possibly be the same.  This helps keeping the type-pair hashtable\n-     small, only tracking comparisons for hash collisions.  */\n-  if (gimple_type_hash (t1) != gimple_type_hash (t2))\n-    return false;\n-\n-  /* If we've visited this type pair before (in the case of aggregates\n-     with self-referential types), and we made a decision, return it.  */\n-  p = lookup_type_pair (t1, t2);\n-  if (p->same_p == 0 || p->same_p == 1)\n-    {\n-      /* We have already decided whether T1 and T2 are the\n-\t same, return the cached result.  */\n-      return p->same_p == 1;\n-    }\n-\n-  /* Now set up the SCC machinery for the comparison.  */\n-  gtc_next_dfs_num = 1;\n-  sccstate = pointer_map_create ();\n-  gcc_obstack_init (&sccstate_obstack);\n-  res = gimple_types_compatible_p_1 (t1, t2, p,\n-\t\t\t\t     &sccstack, sccstate, &sccstate_obstack);\n-  sccstack.release ();\n-  pointer_map_destroy (sccstate);\n-  obstack_free (&sccstate_obstack, NULL);\n-\n-  return res;\n-}\n-\n-static hashval_t\n-iterative_hash_gimple_type (tree, hashval_t, vec<tree> *,\n-\t\t\t    struct pointer_map_t *, struct obstack *);\n-\n-/* DFS visit the edge from the callers type with state *STATE to T.\n-   Update the callers type hash V with the hash for T if it is not part\n-   of the SCC containing the callers type and return it.\n-   SCCSTACK, SCCSTATE and SCCSTATE_OBSTACK are state for the DFS walk done.  */\n-\n-static hashval_t\n-visit (tree t, struct sccs *state, hashval_t v,\n-       vec<tree> *sccstack,\n-       struct pointer_map_t *sccstate,\n-       struct obstack *sccstate_obstack)\n-{\n-  struct sccs *cstate = NULL;\n-  struct tree_int_map m;\n-  void **slot;\n-\n-  /* If there is a hash value recorded for this type then it can't\n-     possibly be part of our parent SCC.  Simply mix in its hash.  */\n-  m.base.from = t;\n-  if ((slot = htab_find_slot (type_hash_cache, &m, NO_INSERT))\n-      && *slot)\n-    return iterative_hash_hashval_t (((struct tree_int_map *) *slot)->to, v);\n-\n-  if ((slot = pointer_map_contains (sccstate, t)) != NULL)\n-    cstate = (struct sccs *)*slot;\n-  if (!cstate)\n-    {\n-      hashval_t tem;\n-      /* Not yet visited.  DFS recurse.  */\n-      tem = iterative_hash_gimple_type (t, v,\n-\t\t\t\t\tsccstack, sccstate, sccstate_obstack);\n-      if (!cstate)\n-\tcstate = (struct sccs *)* pointer_map_contains (sccstate, t);\n-      state->low = MIN (state->low, cstate->low);\n-      /* If the type is no longer on the SCC stack and thus is not part\n-         of the parents SCC mix in its hash value.  Otherwise we will\n-\t ignore the type for hashing purposes and return the unaltered\n-\t hash value.  */\n-      if (!cstate->on_sccstack)\n-\treturn tem;\n-    }\n-  if (cstate->dfsnum < state->dfsnum\n-      && cstate->on_sccstack)\n-    state->low = MIN (cstate->dfsnum, state->low);\n-\n-  /* We are part of our parents SCC, skip this type during hashing\n-     and return the unaltered hash value.  */\n-  return v;\n-}\n-\n-/* Hash NAME with the previous hash value V and return it.  */\n-\n-static hashval_t\n-iterative_hash_name (tree name, hashval_t v)\n-{\n-  if (!name)\n-    return v;\n-  v = iterative_hash_hashval_t (TREE_CODE (name), v);\n-  if (TREE_CODE (name) == TYPE_DECL)\n-    name = DECL_NAME (name);\n-  if (!name)\n-    return v;\n-  gcc_assert (TREE_CODE (name) == IDENTIFIER_NODE);\n-  return iterative_hash_object (IDENTIFIER_HASH_VALUE (name), v);\n-}\n-\n-/* A type, hashvalue pair for sorting SCC members.  */\n-\n-struct type_hash_pair {\n-  tree type;\n-  hashval_t hash;\n-};\n-\n-/* Compare two type, hashvalue pairs.  */\n-\n-static int\n-type_hash_pair_compare (const void *p1_, const void *p2_)\n-{\n-  const struct type_hash_pair *p1 = (const struct type_hash_pair *) p1_;\n-  const struct type_hash_pair *p2 = (const struct type_hash_pair *) p2_;\n-  if (p1->hash < p2->hash)\n-    return -1;\n-  else if (p1->hash > p2->hash)\n-    return 1;\n-  return 0;\n-}\n-\n-/* Returning a hash value for gimple type TYPE combined with VAL.\n-   SCCSTACK, SCCSTATE and SCCSTATE_OBSTACK are state for the DFS walk done.\n-\n-   To hash a type we end up hashing in types that are reachable.\n-   Through pointers we can end up with cycles which messes up the\n-   required property that we need to compute the same hash value\n-   for structurally equivalent types.  To avoid this we have to\n-   hash all types in a cycle (the SCC) in a commutative way.  The\n-   easiest way is to not mix in the hashes of the SCC members at\n-   all.  To make this work we have to delay setting the hash\n-   values of the SCC until it is complete.  */\n-\n-static hashval_t\n-iterative_hash_gimple_type (tree type, hashval_t val,\n-\t\t\t    vec<tree> *sccstack,\n-\t\t\t    struct pointer_map_t *sccstate,\n-\t\t\t    struct obstack *sccstate_obstack)\n-{\n-  hashval_t v;\n-  void **slot;\n-  struct sccs *state;\n-\n-  /* Not visited during this DFS walk.  */\n-  gcc_checking_assert (!pointer_map_contains (sccstate, type));\n-  state = XOBNEW (sccstate_obstack, struct sccs);\n-  *pointer_map_insert (sccstate, type) = state;\n-\n-  sccstack->safe_push (type);\n-  state->dfsnum = next_dfs_num++;\n-  state->low = state->dfsnum;\n-  state->on_sccstack = true;\n-\n-  /* Combine a few common features of types so that types are grouped into\n-     smaller sets; when searching for existing matching types to merge,\n-     only existing types having the same features as the new type will be\n-     checked.  */\n-  v = iterative_hash_name (TYPE_NAME (type), 0);\n-  if (TYPE_NAME (type)\n-      && TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n-      && DECL_CONTEXT (TYPE_NAME (type))\n-      && TYPE_P (DECL_CONTEXT (TYPE_NAME (type))))\n-    v = visit (DECL_CONTEXT (TYPE_NAME (type)), state, v,\n-\t       sccstack, sccstate, sccstate_obstack);\n-\n-  /* Factor in the variant structure.  */\n-  if (TYPE_MAIN_VARIANT (type) != type)\n-    v = visit (TYPE_MAIN_VARIANT (type), state, v,\n-\t       sccstack, sccstate, sccstate_obstack);\n-\n-  v = iterative_hash_hashval_t (TREE_CODE (type), v);\n-  v = iterative_hash_hashval_t (TYPE_QUALS (type), v);\n-  v = iterative_hash_hashval_t (TREE_ADDRESSABLE (type), v);\n-\n-  /* Do not hash the types size as this will cause differences in\n-     hash values for the complete vs. the incomplete type variant.  */\n-\n-  /* Incorporate common features of numerical types.  */\n-  if (INTEGRAL_TYPE_P (type)\n-      || SCALAR_FLOAT_TYPE_P (type)\n-      || FIXED_POINT_TYPE_P (type))\n-    {\n-      v = iterative_hash_hashval_t (TYPE_PRECISION (type), v);\n-      v = iterative_hash_hashval_t (TYPE_MODE (type), v);\n-      v = iterative_hash_hashval_t (TYPE_UNSIGNED (type), v);\n-    }\n-\n-  /* For pointer and reference types, fold in information about the type\n-     pointed to.  */\n-  if (POINTER_TYPE_P (type))\n-    v = visit (TREE_TYPE (type), state, v,\n-\t       sccstack, sccstate, sccstate_obstack);\n-\n-  /* For integer types hash the types min/max values and the string flag.  */\n-  if (TREE_CODE (type) == INTEGER_TYPE)\n-    {\n-      /* OMP lowering can introduce error_mark_node in place of\n-\t random local decls in types.  */\n-      if (TYPE_MIN_VALUE (type) != error_mark_node)\n-\tv = iterative_hash_expr (TYPE_MIN_VALUE (type), v);\n-      if (TYPE_MAX_VALUE (type) != error_mark_node)\n-\tv = iterative_hash_expr (TYPE_MAX_VALUE (type), v);\n-      v = iterative_hash_hashval_t (TYPE_STRING_FLAG (type), v);\n-    }\n-\n-  /* For array types hash the domain and the string flag.  */\n-  if (TREE_CODE (type) == ARRAY_TYPE && TYPE_DOMAIN (type))\n-    {\n-      v = iterative_hash_hashval_t (TYPE_STRING_FLAG (type), v);\n-      v = visit (TYPE_DOMAIN (type), state, v,\n-\t\t sccstack, sccstate, sccstate_obstack);\n-    }\n-\n-  /* Recurse for aggregates with a single element type.  */\n-  if (TREE_CODE (type) == ARRAY_TYPE\n-      || TREE_CODE (type) == COMPLEX_TYPE\n-      || TREE_CODE (type) == VECTOR_TYPE)\n-    v = visit (TREE_TYPE (type), state, v,\n-\t       sccstack, sccstate, sccstate_obstack);\n-\n-  /* Incorporate function return and argument types.  */\n-  if (TREE_CODE (type) == FUNCTION_TYPE || TREE_CODE (type) == METHOD_TYPE)\n-    {\n-      unsigned na;\n-      tree p;\n-\n-      /* For method types also incorporate their parent class.  */\n-      if (TREE_CODE (type) == METHOD_TYPE)\n-\tv = visit (TYPE_METHOD_BASETYPE (type), state, v,\n-\t\t   sccstack, sccstate, sccstate_obstack);\n-\n-      /* Check result and argument types.  */\n-      v = visit (TREE_TYPE (type), state, v,\n-\t\t sccstack, sccstate, sccstate_obstack);\n-      for (p = TYPE_ARG_TYPES (type), na = 0; p; p = TREE_CHAIN (p))\n-\t{\n-\t  v = visit (TREE_VALUE (p), state, v,\n-\t\t     sccstack, sccstate, sccstate_obstack);\n-\t  na++;\n-\t}\n-\n-      v = iterative_hash_hashval_t (na, v);\n-    }\n-\n-  if (RECORD_OR_UNION_TYPE_P (type))\n-    {\n-      unsigned nf;\n-      tree f;\n-\n-      for (f = TYPE_FIELDS (type), nf = 0; f; f = TREE_CHAIN (f))\n-\t{\n-\t  v = iterative_hash_name (DECL_NAME (f), v);\n-\t  v = visit (TREE_TYPE (f), state, v,\n-\t\t     sccstack, sccstate, sccstate_obstack);\n-\t  nf++;\n-\t}\n-\n-      v = iterative_hash_hashval_t (nf, v);\n-    }\n-\n-  /* Record hash for us.  */\n-  state->u.hash = v;\n-\n-  /* See if we found an SCC.  */\n-  if (state->low == state->dfsnum)\n-    {\n-      tree x;\n-      struct tree_int_map *m;\n-\n-      /* Pop off the SCC and set its hash values.  */\n-      x = sccstack->pop ();\n-      /* Optimize SCC size one.  */\n-      if (x == type)\n-\t{\n-\t  state->on_sccstack = false;\n-\t  m = ggc_alloc_cleared_tree_int_map ();\n-\t  m->base.from = x;\n-\t  m->to = v;\n-\t  slot = htab_find_slot (type_hash_cache, m, INSERT);\n-\t  gcc_assert (!*slot);\n-\t  *slot = (void *) m;\n-\t}\n-      else\n-\t{\n-\t  struct sccs *cstate;\n-\t  unsigned first, i, size, j;\n-\t  struct type_hash_pair *pairs;\n-\t  /* Pop off the SCC and build an array of type, hash pairs.  */\n-\t  first = sccstack->length () - 1;\n-\t  while ((*sccstack)[first] != type)\n-\t    --first;\n-\t  size = sccstack->length () - first + 1;\n-\t  pairs = XALLOCAVEC (struct type_hash_pair, size);\n-\t  i = 0;\n-\t  cstate = (struct sccs *)*pointer_map_contains (sccstate, x);\n-\t  cstate->on_sccstack = false;\n-\t  pairs[i].type = x;\n-\t  pairs[i].hash = cstate->u.hash;\n-\t  do\n-\t    {\n-\t      x = sccstack->pop ();\n-\t      cstate = (struct sccs *)*pointer_map_contains (sccstate, x);\n-\t      cstate->on_sccstack = false;\n-\t      ++i;\n-\t      pairs[i].type = x;\n-\t      pairs[i].hash = cstate->u.hash;\n-\t    }\n-\t  while (x != type);\n-\t  gcc_assert (i + 1 == size);\n-\t  /* Sort the arrays of type, hash pairs so that when we mix in\n-\t     all members of the SCC the hash value becomes independent on\n-\t     the order we visited the SCC.  Disregard hashes equal to\n-\t     the hash of the type we mix into because we cannot guarantee\n-\t     a stable sort for those across different TUs.  */\n-\t  qsort (pairs, size, sizeof (struct type_hash_pair),\n-\t\t type_hash_pair_compare);\n-\t  for (i = 0; i < size; ++i)\n-\t    {\n-\t      hashval_t hash;\n-\t      m = ggc_alloc_cleared_tree_int_map ();\n-\t      m->base.from = pairs[i].type;\n-\t      hash = pairs[i].hash;\n-\t      /* Skip same hashes.  */\n-\t      for (j = i + 1; j < size && pairs[j].hash == pairs[i].hash; ++j)\n-\t\t;\n-\t      for (; j < size; ++j)\n-\t\thash = iterative_hash_hashval_t (pairs[j].hash, hash);\n-\t      for (j = 0; pairs[j].hash != pairs[i].hash; ++j)\n-\t\thash = iterative_hash_hashval_t (pairs[j].hash, hash);\n-\t      m->to = hash;\n-\t      if (pairs[i].type == type)\n-\t\tv = hash;\n-\t      slot = htab_find_slot (type_hash_cache, m, INSERT);\n-\t      gcc_assert (!*slot);\n-\t      *slot = (void *) m;\n-\t    }\n-\t}\n-    }\n-\n-  return iterative_hash_hashval_t (v, val);\n-}\n-\n-/* Returns a hash value for P (assumed to be a type).  The hash value\n-   is computed using some distinguishing features of the type.  Note\n-   that we cannot use pointer hashing here as we may be dealing with\n-   two distinct instances of the same type.\n-\n-   This function should produce the same hash value for two compatible\n-   types according to gimple_types_compatible_p.  */\n-\n-static hashval_t\n-gimple_type_hash (const void *p)\n-{\n-  const_tree t = (const_tree) p;\n-  vec<tree> sccstack = vNULL;\n-  struct pointer_map_t *sccstate;\n-  struct obstack sccstate_obstack;\n-  hashval_t val;\n-  void **slot;\n-  struct tree_int_map m;\n-\n-  m.base.from = CONST_CAST_TREE (t);\n-  if ((slot = htab_find_slot (type_hash_cache, &m, NO_INSERT))\n-      && *slot)\n-    return iterative_hash_hashval_t (((struct tree_int_map *) *slot)->to, 0);\n-\n-  /* Perform a DFS walk and pre-hash all reachable types.  */\n-  next_dfs_num = 1;\n-  sccstate = pointer_map_create ();\n-  gcc_obstack_init (&sccstate_obstack);\n-  val = iterative_hash_gimple_type (CONST_CAST_TREE (t), 0,\n-\t\t\t\t    &sccstack, sccstate, &sccstate_obstack);\n-  sccstack.release ();\n-  pointer_map_destroy (sccstate);\n-  obstack_free (&sccstate_obstack, NULL);\n-\n-  return val;\n-}\n-\n-/* Returns nonzero if P1 and P2 are equal.  */\n-\n-static int\n-gimple_type_eq (const void *p1, const void *p2)\n-{\n-  const_tree t1 = (const_tree) p1;\n-  const_tree t2 = (const_tree) p2;\n-  return gimple_types_compatible_p (CONST_CAST_TREE (t1),\n-\t\t\t\t    CONST_CAST_TREE (t2));\n-}\n-\n-/* Register type T in the global type table gimple_types.  */\n-\n-static tree\n-gimple_register_type (tree t)\n-{\n-  void **slot;\n-\n-  /* See if we already have an equivalent type registered.  */\n-  slot = htab_find_slot (gimple_types, t, INSERT);\n-  if (*slot\n-      && *(tree *)slot != t)\n-    return (tree) *((tree *) slot);\n-\n-  /* If not, insert it to the cache and the hash.  */\n-  *slot = (void *) t;\n-  return t;\n-}\n-\n-/* End of old merging code.  */\n-\n /* Remember trees that contains references to declarations.  */\n static GTY(()) vec <tree, va_gc> *tree_with_vars;\n \n@@ -2145,10 +1114,6 @@ static struct obstack tree_scc_hash_obstack;\n \n static unsigned long num_merged_types;\n static unsigned long num_prevailing_types;\n-static unsigned long num_not_merged_types;\n-static unsigned long num_not_merged_types_in_same_scc;\n-static unsigned long num_not_merged_types_trees;\n-static unsigned long num_not_merged_types_in_same_scc_trees;\n static unsigned long num_type_scc_trees;\n static unsigned long total_scc_size;\n static unsigned long num_sccs_read;\n@@ -2870,38 +1835,10 @@ lto_read_decls (struct lto_file_decl_data *decl_data, const void *data,\n \n \t  /* Do remaining fixup tasks for prevailing nodes.  */\n \t  bool seen_type = false;\n-\t  bool not_merged_type_same_scc = false;\n-\t  bool not_merged_type_not_same_scc = false;\n \t  for (unsigned i = 0; i < len; ++i)\n \t    {\n \t      tree t = streamer_tree_cache_get_tree (data_in->reader_cache,\n \t\t\t\t\t\t     from + i);\n-\t      /* For statistics, see if the old code would have merged\n-\t\t the type.  */\n-\t      if (TYPE_P (t)\n-\t\t  && (flag_lto_report || (flag_wpa && flag_lto_report_wpa)))\n-\t\t{\n-\t\t  tree newt = gimple_register_type (t);\n-\t\t  if (newt != t)\n-\t\t    {\n-\t\t      num_not_merged_types++;\n-\t\t      unsigned j;\n-\t\t      /* Check if we can never merge the types because\n-\t\t\t they are in the same SCC and thus the old\n-\t\t\t code was broken.  */\n-\t\t      for (j = 0; j < len; ++j)\n-\t\t\tif (i != j\n-\t\t\t    && streamer_tree_cache_get_tree\n-\t\t\t         (data_in->reader_cache, from + j) == newt)\n-\t\t\t  {\n-\t\t\t    num_not_merged_types_in_same_scc++;\n-\t\t\t    not_merged_type_same_scc = true;\n-\t\t\t    break;\n-\t\t\t  }\n-\t\t      if (j == len)\n-\t\t\tnot_merged_type_not_same_scc = true;\n-\t\t    }\n-\t\t}\n \t      /* Reconstruct the type variant and pointer-to/reference-to\n \t\t chains.  */\n \t      if (TYPE_P (t))\n@@ -2938,13 +1875,6 @@ lto_read_decls (struct lto_file_decl_data *decl_data, const void *data,\n \t\t    vec_safe_push (tree_with_vars, t);\n \t\t}\n \t    }\n-\t  if (not_merged_type_same_scc)\n-\t    {\n-\t      num_not_merged_types_in_same_scc_trees += len;\n-\t      num_not_merged_types_trees += len;\n-\t    }\n-\t  else if (not_merged_type_not_same_scc)\n-\t    num_not_merged_types_trees += len;\n \t  if (seen_type)\n \t    num_type_scc_trees += len;\n \t}\n@@ -3823,10 +2753,6 @@ read_cgraph_and_symbols (unsigned nfiles, const char **fnames)\n \t\t\t\t\t       tree_int_map_eq, NULL);\n   gimple_canonical_types = htab_create_ggc (16381, gimple_canonical_type_hash,\n \t\t\t\t\t    gimple_canonical_type_eq, 0);\n-  type_hash_cache = htab_create_ggc (512, tree_int_map_hash,\n-\t\t\t\t     tree_int_map_eq, NULL);\n-  type_pair_cache = XCNEWVEC (struct type_pair_d, GIMPLE_TYPE_PAIR_SIZE);\n-  gimple_types = htab_create_ggc (16381, gimple_type_hash, gimple_type_eq, 0);\n   gcc_obstack_init (&tree_scc_hash_obstack);\n   tree_scc_hash.create (4096);\n \n@@ -3887,12 +2813,6 @@ read_cgraph_and_symbols (unsigned nfiles, const char **fnames)\n     print_lto_report_1 ();\n \n   /* Free gimple type merging datastructures.  */\n-  htab_delete (gimple_types);\n-  gimple_types = NULL;\n-  htab_delete (type_hash_cache);\n-  type_hash_cache = NULL;\n-  free (type_pair_cache);\n-  type_pair_cache = NULL;\n   tree_scc_hash.dispose ();\n   obstack_free (&tree_scc_hash_obstack, NULL);\n   htab_delete (gimple_canonical_types);\n@@ -4096,12 +3016,6 @@ print_lto_report_1 (void)\n       fprintf (stderr, \"[%s] Merged %lu types\\n\", pfx, num_merged_types);\n       fprintf (stderr, \"[%s] %lu types prevailed (%lu associated trees)\\n\",\n \t       pfx, num_prevailing_types, num_type_scc_trees);\n-      fprintf (stderr, \"[%s] Old merging code merges an additional %lu types\"\n-\t       \" of which %lu are in the same SCC with their \"\n-\t       \"prevailing variant (%lu and %lu associated trees)\\n\",\n-\t       pfx, num_not_merged_types, num_not_merged_types_in_same_scc,\n-\t       num_not_merged_types_trees,\n-\t       num_not_merged_types_in_same_scc_trees);\n       fprintf (stderr, \"[%s] GIMPLE canonical type table: size %ld, \"\n \t       \"%ld elements, %ld searches, %ld collisions (ratio: %f)\\n\", pfx,\n \t       (long) htab_size (gimple_canonical_types),"}]}