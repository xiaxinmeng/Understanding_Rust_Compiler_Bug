{"sha": "ee189a7327565cfcc2441aa308333ad3b6525e6e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWUxODlhNzMyNzU2NWNmY2MyNDQxYWEzMDgzMzNhZDNiNjUyNWU2ZQ==", "commit": {"author": {"name": "Hans-Peter Nilsson", "email": "hp@bitrange.com", "date": "2021-07-18T01:40:11Z"}, "committer": {"name": "Hans-Peter Nilsson", "email": "hp@bitrange.com", "date": "2021-07-30T21:34:54Z"}, "message": "doc: correct documentation of \"call\" (et al) operand 2.\n\nAn old itch being scratched: the documentation lies; it's not \"the\nnumber of registers used as operands\", unless the target makes a\nspecial arrangement to that effect, and there's nothing in the guts of\ngcc setting up or assuming those semantics.\n\nInstead, see calls.c:expand_call, variable next_arg_reg.  Or just\nconsider the variable name.  The text is somewhat transcribed from the\nhead comment of emit_call_1 for parameter next_arg_reg.  Most\nimportant is to document the relation to function_arg_info::end_marker()\nand the TARGET_FUNCTION_ARG hook.\n\nThe \"normally\" in the head comment, in \"normally it is the first\narg-register beyond those used for args in this call, or 0 if all the\narg-registers are used in this call\" means \"by default\", unless the\ntarget tests end_marker_p and does something special, but the port is\nfree to return whatever it likes when it sees the end-marker.\n\nAnd, I do mean \"whatever it likes\" because if the port doesn't\nactually mention that operand in the RTX emitted for its \"call\" or\n\"call_value\" patterns (\"usually\" define_expands), it can be any\nmumbo-jumbo, such as a VOIDmode register, which seems like it happens\nfor some targets, or NULL, that happens for others.  Returning a\nVOIDmode register until recently included MMIX, where it made it into\nthe emitted RTL, confusing later passes, recently exposed as an ICE.\n\nTested by inspecting the info and generated pdf for sanity.\n\ngcc:\n\t* doc/md.texi (call): Correct information about operand 2.\n\t* config/mmix/mmix.md (\"call\", \"call_value\"): Remove fixed FIXMEs.", "tree": {"sha": "e0090476f87450a0ab70b41bce9f525076c4d704", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e0090476f87450a0ab70b41bce9f525076c4d704"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ee189a7327565cfcc2441aa308333ad3b6525e6e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee189a7327565cfcc2441aa308333ad3b6525e6e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee189a7327565cfcc2441aa308333ad3b6525e6e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee189a7327565cfcc2441aa308333ad3b6525e6e/comments", "author": null, "committer": null, "parents": [{"sha": "145bc41dae7c7bfa093d61e77346f98e6a595a0e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/145bc41dae7c7bfa093d61e77346f98e6a595a0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/145bc41dae7c7bfa093d61e77346f98e6a595a0e"}], "stats": {"total": 20, "additions": 9, "deletions": 11}, "files": [{"sha": "33e9c60982d615b3609ae32dccd9bc42f5cf0222", "filename": "gcc/config/mmix/mmix.md", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee189a7327565cfcc2441aa308333ad3b6525e6e/gcc%2Fconfig%2Fmmix%2Fmmix.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee189a7327565cfcc2441aa308333ad3b6525e6e/gcc%2Fconfig%2Fmmix%2Fmmix.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.md?ref=ee189a7327565cfcc2441aa308333ad3b6525e6e", "patch": "@@ -999,10 +999,8 @@ DIVU %1,%1,%2\\;GET %0,:rR\\;NEGU %2,0,%0\\;CSNN %0,$255,%2\")\n     = mmix_get_hard_reg_initial_val (Pmode,\n \t\t\t\t     MMIX_INCOMING_RETURN_ADDRESS_REGNUM);\n \n-  /* FIXME: There's a bug in gcc which causes NULL to be passed as\n-     operand[2] when we get out of registers, which later confuses gcc.\n-     Work around it by replacing it with const_int 0.  Possibly documentation\n-     error too.  */\n+  /* NULL gets passed as operand[2] when we get out of registers,\n+     which later confuses gcc.  Replace it with const_int 0.  */\n   if (operands[2] == NULL_RTX)\n     operands[2] = const0_rtx;\n \n@@ -1036,14 +1034,10 @@ DIVU %1,%1,%2\\;GET %0,:rR\\;NEGU %2,0,%0\\;CSNN %0,$255,%2\")\n     = mmix_get_hard_reg_initial_val (Pmode,\n \t\t\t\t     MMIX_INCOMING_RETURN_ADDRESS_REGNUM);\n \n-  /* FIXME: See 'call'.  */\n+  /* See 'call'.  */\n   if (operands[3] == NULL_RTX)\n     operands[3] = const0_rtx;\n \n-  /* FIXME: Documentation bug: operands[3] (operands[2] for 'call') is the\n-     *next* argument register, not the number of arguments in registers.\n-     (There used to be code here where that mattered.)  */\n-\n   operands[5] = gen_rtx_REG (DImode, MMIX_INCOMING_RETURN_ADDRESS_REGNUM);\n }\")\n "}, {"sha": "f6d1bc1ad0f763543ecbbecbec4aec33d9292338", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee189a7327565cfcc2441aa308333ad3b6525e6e/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee189a7327565cfcc2441aa308333ad3b6525e6e/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=ee189a7327565cfcc2441aa308333ad3b6525e6e", "patch": "@@ -7048,8 +7048,12 @@ machines.\n @item @samp{call}\n Subroutine call instruction returning no value.  Operand 0 is the\n function to call; operand 1 is the number of bytes of arguments pushed\n-as a @code{const_int}; operand 2 is the number of registers used as\n-operands.\n+as a @code{const_int}.  Operand 2 is the result of calling the target\n+hook @code{TARGET_FUNCTION_ARG} with the second argument @code{arg}\n+yielding true for @code{arg.end_marker_p ()}, in a call after all\n+parameters have been passed to that hook.  By default this is the first\n+register beyond those used for arguments in the call, or @code{NULL} if\n+all the argument-registers are used in the call.\n \n On most machines, operand 2 is not actually stored into the RTL\n pattern.  It is supplied for the sake of some RISC machines which need"}]}