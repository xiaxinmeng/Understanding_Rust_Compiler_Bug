{"sha": "43ab1dc24abd6fded8d5bf6547f0de6851beb200", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDNhYjFkYzI0YWJkNmZkZWQ4ZDViZjY1NDdmMGRlNjg1MWJlYjIwMA==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-04-08T09:50:57Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-04-08T10:56:59Z"}, "message": "libstdc++: Make std::is_scoped_enum work with incomplete types\n\nTim Song pointed out that using __underlying_type is ill-formed for\nincomplete enumeration types, and is_scoped_enum doesn't require a\ncomplete type. This changes the trait to check for conversion to int\ninstead of to the underlying type.\n\nIn order to give the correct result when the trait is used in the\nenumerator-list of an incomplete type the partial specialization for\nenums has an additional check that fails for incomplete types. This\nassumes that an incompelte enumeration type must be an unscoped\nenumeration, and so the primary template (with a std::false_type base\ncharacteristic) can be used. This isn't necessarily true, but it is not\ncurrently possible to refer to a scoped enumeration type before its type\nis complete (PR c++/89025).\n\nIt should be possible to use requires(remove_cv_t<_Tp> __t) in the\npartial specialization's assignablility check, but that currently gives\nan ICE (PR c++/99968) so there is an extra partial specialization of\nis_scoped_enum<const _Tp> to handle const types.\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/std/type_traits (is_scoped_enum<T>): Constrain partial\n\tspecialization to not match incomplete enum types. Use a\n\trequires-expression instead of instantiating is_convertible.\n\t(is_scoped_enum<const T>): Add as workaround for PR c++/99968.\n\t* testsuite/20_util/is_scoped_enum/value.cc: Check with\n\tincomplete types and opaque-enum-declarations.", "tree": {"sha": "df06577c5809a61e0856bdb62d3613bb1c27a19d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/df06577c5809a61e0856bdb62d3613bb1c27a19d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/43ab1dc24abd6fded8d5bf6547f0de6851beb200", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43ab1dc24abd6fded8d5bf6547f0de6851beb200", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43ab1dc24abd6fded8d5bf6547f0de6851beb200", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43ab1dc24abd6fded8d5bf6547f0de6851beb200/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "67d56b272021363eb58c319ca3b73beba3a60817", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67d56b272021363eb58c319ca3b73beba3a60817", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67d56b272021363eb58c319ca3b73beba3a60817"}], "stats": {"total": 53, "additions": 51, "deletions": 2}, "files": [{"sha": "1f8b57b04a0d51756787e8a11ed46510b89ca595", "filename": "libstdc++-v3/include/std/type_traits", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43ab1dc24abd6fded8d5bf6547f0de6851beb200/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43ab1dc24abd6fded8d5bf6547f0de6851beb200/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits?ref=43ab1dc24abd6fded8d5bf6547f0de6851beb200", "patch": "@@ -3287,9 +3287,20 @@ template <typename _From, typename _To>\n     : false_type\n     { };\n \n-  template<typename _Tp> requires __is_enum(_Tp)\n+  template<typename _Tp>\n+    requires __is_enum(_Tp)\n+    && requires(_Tp __t) { __t = __t; } // fails if incomplete\n     struct is_scoped_enum<_Tp>\n-    : __not_<is_convertible<_Tp, __underlying_type(_Tp)>>::type\n+    : bool_constant<!requires(_Tp __t, void(*__f)(int)) { __f(__t); }>\n+    { };\n+\n+  // FIXME remove this partial specialization and use remove_cv_t<_Tp> above\n+  // when PR c++/99968 is fixed.\n+  template<typename _Tp>\n+    requires __is_enum(_Tp)\n+    && requires(_Tp __t) { __t = __t; } // fails if incomplete\n+    struct is_scoped_enum<const _Tp>\n+    : bool_constant<!requires(_Tp __t, void(*__f)(int)) { __f(__t); }>\n     { };\n \n   template<typename _Tp>"}, {"sha": "2cef857a042eb7282157cd72141d316e50ed0331", "filename": "libstdc++-v3/testsuite/20_util/is_scoped_enum/value.cc", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43ab1dc24abd6fded8d5bf6547f0de6851beb200/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_scoped_enum%2Fvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43ab1dc24abd6fded8d5bf6547f0de6851beb200/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_scoped_enum%2Fvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_scoped_enum%2Fvalue.cc?ref=43ab1dc24abd6fded8d5bf6547f0de6851beb200", "patch": "@@ -32,6 +32,8 @@ template<typename T>\n   concept Is_scoped_enum\n     = __gnu_test::test_category<std::is_scoped_enum, T>(true);\n \n+struct Incomplete_struct;\n+\n void\n test01()\n {\n@@ -45,6 +47,9 @@ test01()\n   static_assert( ! Is_scoped_enum<U> );\n   enum F : int { f1, f2 };\n   static_assert( ! Is_scoped_enum<F> );\n+  static_assert( ! Is_scoped_enum<Incomplete_struct> );\n+  struct S;\n+  static_assert( ! Is_scoped_enum<S> );\n   struct S { };\n   static_assert( ! Is_scoped_enum<S> );\n \n@@ -60,3 +65,36 @@ test01()\n   static_assert( ! Is_scoped_enum<int(*)()> );\n   static_assert( ! Is_scoped_enum<int(&)()> );\n }\n+\n+enum opaque_unscoped : short;\n+enum class opaque_scoped;\n+enum class opaque_scoped_with_base : long;\n+\n+static_assert( ! Is_scoped_enum<opaque_unscoped> );\n+static_assert( Is_scoped_enum<opaque_scoped> );\n+static_assert( Is_scoped_enum<opaque_scoped_with_base> );\n+\n+void\n+test02()\n+{\n+  enum unscoped {\n+    u_is_enum = std::is_enum_v<unscoped>,\n+    u_is_scoped = std::is_scoped_enum_v<unscoped>,\n+  };\n+  static_assert( unscoped::u_is_enum );\n+  static_assert( ! unscoped::u_is_scoped );\n+\n+  enum unscoped_fixed : char {\n+    uf_is_enum = std::is_enum_v<unscoped_fixed>,\n+    uf_is_scoped = std::is_scoped_enum_v<unscoped_fixed>,\n+  };\n+  static_assert( unscoped_fixed::uf_is_enum);\n+  static_assert( ! unscoped_fixed::uf_is_scoped );\n+\n+  enum class scoped {\n+    is_enum = std::is_enum_v<scoped>,\n+    is_scoped = std::is_scoped_enum_v<scoped>,\n+  };\n+  static_assert( (bool) scoped::is_enum );\n+  static_assert( (bool) scoped::is_scoped );\n+}"}]}