{"sha": "93b338c3964e0d4f7b267a37077c8b8fecb7749e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTNiMzM4YzM5NjRlMGQ0ZjdiMjY3YTM3MDc3YzhiOGZlY2I3NzQ5ZQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2010-05-05T22:46:38Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2010-05-05T22:46:38Z"}, "message": "arm.h (MAX_LDM_STM_OPS): New macro.\n\n\t* config/arm/arm.h (MAX_LDM_STM_OPS): New macro.\n\t* config/arm/arm.c (multiple_operation_profitable_p,\n\tcompute_offset_order): New static functions.\n\t(load_multiple_sequence, store_multiple_sequence): Use them.\n\tReplace constant 4 with MAX_LDM_STM_OPS.  Compute order[0] from\n\tmemory offsets, not register numbers.\n\t(emit_ldm_seq, emit_stm_seq): Replace constant 4 with MAX_LDM_STM_OPS.\n\nFrom-SVN: r159089", "tree": {"sha": "7116c81f4884032702f3d08bb2c3d8dbdec83922", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7116c81f4884032702f3d08bb2c3d8dbdec83922"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/93b338c3964e0d4f7b267a37077c8b8fecb7749e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93b338c3964e0d4f7b267a37077c8b8fecb7749e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93b338c3964e0d4f7b267a37077c8b8fecb7749e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93b338c3964e0d4f7b267a37077c8b8fecb7749e/comments", "author": null, "committer": null, "parents": [{"sha": "5e7b92b9ff393c7cc64a7ff7d3400ab86d5f587a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e7b92b9ff393c7cc64a7ff7d3400ab86d5f587a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e7b92b9ff393c7cc64a7ff7d3400ab86d5f587a"}], "stats": {"total": 321, "additions": 169, "deletions": 152}, "files": [{"sha": "403a39f85be255cd4146d269c67849fba731dd87", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93b338c3964e0d4f7b267a37077c8b8fecb7749e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93b338c3964e0d4f7b267a37077c8b8fecb7749e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=93b338c3964e0d4f7b267a37077c8b8fecb7749e", "patch": "@@ -1,3 +1,13 @@\n+2010-05-06  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+\t* config/arm/arm.h (MAX_LDM_STM_OPS): New macro.\n+\t* config/arm/arm.c (multiple_operation_profitable_p,\n+\tcompute_offset_order): New static functions.\n+\t(load_multiple_sequence, store_multiple_sequence): Use them.\n+\tReplace constant 4 with MAX_LDM_STM_OPS.  Compute order[0] from\n+\tmemory offsets, not register numbers.\n+\t(emit_ldm_seq, emit_stm_seq): Replace constant 4 with MAX_LDM_STM_OPS.\n+\n 2010-05-05  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* stor-layout.c (pending_sizes): Change the type to"}, {"sha": "bfeabda4df5b2d7d4412279f1e6f9c42987d3ee6", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 155, "deletions": 152, "changes": 307, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93b338c3964e0d4f7b267a37077c8b8fecb7749e/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93b338c3964e0d4f7b267a37077c8b8fecb7749e/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=93b338c3964e0d4f7b267a37077c8b8fecb7749e", "patch": "@@ -9073,21 +9073,105 @@ adjacent_mem_locations (rtx a, rtx b)\n   return 0;\n }\n \n+/* Return true iff it would be profitable to turn a sequence of NOPS loads\n+   or stores (depending on IS_STORE) into a load-multiple or store-multiple\n+   instruction.  ADD_OFFSET is nonzero if the base address register needs\n+   to be modified with an add instruction before we can use it.  */\n+\n+static bool\n+multiple_operation_profitable_p (bool is_store ATTRIBUTE_UNUSED,\n+\t\t\t\t int nops, HOST_WIDE_INT add_offset)\n+ {\n+  /* For ARM8,9 & StrongARM, 2 ldr instructions are faster than an ldm\n+     if the offset isn't small enough.  The reason 2 ldrs are faster\n+     is because these ARMs are able to do more than one cache access\n+     in a single cycle.  The ARM9 and StrongARM have Harvard caches,\n+     whilst the ARM8 has a double bandwidth cache.  This means that\n+     these cores can do both an instruction fetch and a data fetch in\n+     a single cycle, so the trick of calculating the address into a\n+     scratch register (one of the result regs) and then doing a load\n+     multiple actually becomes slower (and no smaller in code size).\n+     That is the transformation\n+\n+ \tldr\trd1, [rbase + offset]\n+ \tldr\trd2, [rbase + offset + 4]\n+\n+     to\n+\n+ \tadd\trd1, rbase, offset\n+ \tldmia\trd1, {rd1, rd2}\n+\n+     produces worse code -- '3 cycles + any stalls on rd2' instead of\n+     '2 cycles + any stalls on rd2'.  On ARMs with only one cache\n+     access per cycle, the first sequence could never complete in less\n+     than 6 cycles, whereas the ldm sequence would only take 5 and\n+     would make better use of sequential accesses if not hitting the\n+     cache.\n+\n+     We cheat here and test 'arm_ld_sched' which we currently know to\n+     only be true for the ARM8, ARM9 and StrongARM.  If this ever\n+     changes, then the test below needs to be reworked.  */\n+  if (nops == 2 && arm_ld_sched && add_offset != 0)\n+    return false;\n+\n+  return true;\n+}\n+\n+/* Subroutine of load_multiple_sequence and store_multiple_sequence.\n+   Given an array of UNSORTED_OFFSETS, of which there are NOPS, compute\n+   an array ORDER which describes the sequence to use when accessing the\n+   offsets that produces an ascending order.  In this sequence, each\n+   offset must be larger by exactly 4 than the previous one.  ORDER[0]\n+   must have been filled in with the lowest offset by the caller.\n+   If UNSORTED_REGS is nonnull, it is an array of register numbers that\n+   we use to verify that ORDER produces an ascending order of registers.\n+   Return true if it was possible to construct such an order, false if\n+   not.  */\n+\n+static bool\n+compute_offset_order (int nops, HOST_WIDE_INT *unsorted_offsets, int *order,\n+\t\t      int *unsorted_regs)\n+{\n+  int i;\n+  for (i = 1; i < nops; i++)\n+    {\n+      int j;\n+\n+      order[i] = order[i - 1];\n+      for (j = 0; j < nops; j++)\n+\tif (unsorted_offsets[j] == unsorted_offsets[order[i - 1]] + 4)\n+\t  {\n+\t    /* We must find exactly one offset that is higher than the\n+\t       previous one by 4.  */\n+\t    if (order[i] != order[i - 1])\n+\t      return false;\n+\t    order[i] = j;\n+\t  }\n+      if (order[i] == order[i - 1])\n+\treturn false;\n+      /* The register numbers must be ascending.  */\n+      if (unsorted_regs != NULL\n+\t  && unsorted_regs[order[i]] <= unsorted_regs[order[i - 1]])\n+\treturn false;\n+    }\n+  return true;\n+}\n+\n int\n load_multiple_sequence (rtx *operands, int nops, int *regs, int *base,\n \t\t\tHOST_WIDE_INT *load_offset)\n {\n-  int unsorted_regs[4];\n-  HOST_WIDE_INT unsorted_offsets[4];\n-  int order[4];\n+  int unsorted_regs[MAX_LDM_STM_OPS];\n+  HOST_WIDE_INT unsorted_offsets[MAX_LDM_STM_OPS];\n+  int order[MAX_LDM_STM_OPS];\n   int base_reg = -1;\n-  int i;\n+  int i, ldm_case;\n \n-  /* Can only handle 2, 3, or 4 insns at present,\n-     though could be easily extended if required.  */\n-  gcc_assert (nops >= 2 && nops <= 4);\n+  /* Can only handle up to MAX_LDM_STM_OPS insns at present, though could be\n+     easily extended if required.  */\n+  gcc_assert (nops >= 2 && nops <= MAX_LDM_STM_OPS);\n \n-  memset (order, 0, 4 * sizeof (int));\n+  memset (order, 0, MAX_LDM_STM_OPS * sizeof (int));\n \n   /* Loop over the operands and check that the memory references are\n      suitable (i.e. immediate offsets from the same base register).  At\n@@ -9123,25 +9207,16 @@ load_multiple_sequence (rtx *operands, int nops, int *regs, int *base,\n \t\t  == CONST_INT)))\n \t{\n \t  if (i == 0)\n-\t    {\n-\t      base_reg = REGNO (reg);\n-\t      unsorted_regs[0] = (GET_CODE (operands[i]) == REG\n-\t\t\t\t  ? REGNO (operands[i])\n-\t\t\t\t  : REGNO (SUBREG_REG (operands[i])));\n-\t      order[0] = 0;\n-\t    }\n+\t    base_reg = REGNO (reg);\n \t  else\n \t    {\n \t      if (base_reg != (int) REGNO (reg))\n \t\t/* Not addressed from the same base register.  */\n \t\treturn 0;\n-\n-\t      unsorted_regs[i] = (GET_CODE (operands[i]) == REG\n-\t\t\t\t  ? REGNO (operands[i])\n-\t\t\t\t  : REGNO (SUBREG_REG (operands[i])));\n-\t      if (unsorted_regs[i] < unsorted_regs[order[0]])\n-\t\torder[0] = i;\n \t    }\n+\t  unsorted_regs[i] = (GET_CODE (operands[i]) == REG\n+\t\t\t      ? REGNO (operands[i])\n+\t\t\t      : REGNO (SUBREG_REG (operands[i])));\n \n \t  /* If it isn't an integer register, or if it overwrites the\n \t     base register but isn't the last insn in the list, then\n@@ -9151,6 +9226,8 @@ load_multiple_sequence (rtx *operands, int nops, int *regs, int *base,\n \t    return 0;\n \n \t  unsorted_offsets[i] = INTVAL (offset);\n+\t  if (i == 0 || unsorted_offsets[i] < unsorted_offsets[order[0]])\n+\t    order[0] = i;\n \t}\n       else\n \t/* Not a suitable memory address.  */\n@@ -9159,30 +9236,11 @@ load_multiple_sequence (rtx *operands, int nops, int *regs, int *base,\n \n   /* All the useful information has now been extracted from the\n      operands into unsorted_regs and unsorted_offsets; additionally,\n-     order[0] has been set to the lowest numbered register in the\n-     list.  Sort the registers into order, and check that the memory\n-     offsets are ascending and adjacent.  */\n-\n-  for (i = 1; i < nops; i++)\n-    {\n-      int j;\n-\n-      order[i] = order[i - 1];\n-      for (j = 0; j < nops; j++)\n-\tif (unsorted_regs[j] > unsorted_regs[order[i - 1]]\n-\t    && (order[i] == order[i - 1]\n-\t\t|| unsorted_regs[j] < unsorted_regs[order[i]]))\n-\t  order[i] = j;\n-\n-      /* Have we found a suitable register? if not, one must be used more\n-\t than once.  */\n-      if (order[i] == order[i - 1])\n-\treturn 0;\n-\n-      /* Is the memory address adjacent and ascending? */\n-      if (unsorted_offsets[order[i]] != unsorted_offsets[order[i - 1]] + 4)\n-\treturn 0;\n-    }\n+     order[0] has been set to the lowest offset in the list.  Sort\n+     the offsets into order, verifying that they are adjacent, and\n+     check that the register numbers are ascending.  */\n+  if (!compute_offset_order (nops, unsorted_offsets, order, unsorted_regs))\n+    return 0;\n \n   if (base)\n     {\n@@ -9195,59 +9253,31 @@ load_multiple_sequence (rtx *operands, int nops, int *regs, int *base,\n     }\n \n   if (unsorted_offsets[order[0]] == 0)\n-    return 1; /* ldmia */\n-\n-  if (TARGET_ARM && unsorted_offsets[order[0]] == 4)\n-    return 2; /* ldmib */\n-\n-  if (TARGET_ARM && unsorted_offsets[order[nops - 1]] == 0)\n-    return 3; /* ldmda */\n-\n-  if (unsorted_offsets[order[nops - 1]] == -4)\n-    return 4; /* ldmdb */\n-\n-  /* For ARM8,9 & StrongARM, 2 ldr instructions are faster than an ldm\n-     if the offset isn't small enough.  The reason 2 ldrs are faster\n-     is because these ARMs are able to do more than one cache access\n-     in a single cycle.  The ARM9 and StrongARM have Harvard caches,\n-     whilst the ARM8 has a double bandwidth cache.  This means that\n-     these cores can do both an instruction fetch and a data fetch in\n-     a single cycle, so the trick of calculating the address into a\n-     scratch register (one of the result regs) and then doing a load\n-     multiple actually becomes slower (and no smaller in code size).\n-     That is the transformation\n-\n- \tldr\trd1, [rbase + offset]\n- \tldr\trd2, [rbase + offset + 4]\n-\n-     to\n-\n- \tadd\trd1, rbase, offset\n- \tldmia\trd1, {rd1, rd2}\n-\n-     produces worse code -- '3 cycles + any stalls on rd2' instead of\n-     '2 cycles + any stalls on rd2'.  On ARMs with only one cache\n-     access per cycle, the first sequence could never complete in less\n-     than 6 cycles, whereas the ldm sequence would only take 5 and\n-     would make better use of sequential accesses if not hitting the\n-     cache.\n+    ldm_case = 1; /* ldmia */\n+  else if (TARGET_ARM && unsorted_offsets[order[0]] == 4)\n+    ldm_case = 2; /* ldmib */\n+  else if (TARGET_ARM && unsorted_offsets[order[nops - 1]] == 0)\n+    ldm_case = 3; /* ldmda */\n+  else if (unsorted_offsets[order[nops - 1]] == -4)\n+    ldm_case = 4; /* ldmdb */\n+  else if (const_ok_for_arm (unsorted_offsets[order[0]])\n+\t   || const_ok_for_arm (-unsorted_offsets[order[0]]))\n+    ldm_case = 5;\n+  else\n+    return 0;\n \n-     We cheat here and test 'arm_ld_sched' which we currently know to\n-     only be true for the ARM8, ARM9 and StrongARM.  If this ever\n-     changes, then the test below needs to be reworked.  */\n-  if (nops == 2 && arm_ld_sched)\n+  if (!multiple_operation_profitable_p (false, nops,\n+\t\t\t\t\tldm_case == 5\n+\t\t\t\t\t? unsorted_offsets[order[0]] : 0))\n     return 0;\n \n-  /* Can't do it without setting up the offset, only do this if it takes\n-     no more than one insn.  */\n-  return (const_ok_for_arm (unsorted_offsets[order[0]])\n-\t  || const_ok_for_arm (-unsorted_offsets[order[0]])) ? 5 : 0;\n+  return ldm_case;\n }\n \n const char *\n emit_ldm_seq (rtx *operands, int nops)\n {\n-  int regs[4];\n+  int regs[MAX_LDM_STM_OPS];\n   int base_reg;\n   HOST_WIDE_INT offset;\n   char buf[100];\n@@ -9306,17 +9336,17 @@ int\n store_multiple_sequence (rtx *operands, int nops, int *regs, int *base,\n \t\t\t HOST_WIDE_INT * load_offset)\n {\n-  int unsorted_regs[4];\n-  HOST_WIDE_INT unsorted_offsets[4];\n-  int order[4];\n+  int unsorted_regs[MAX_LDM_STM_OPS];\n+  HOST_WIDE_INT unsorted_offsets[MAX_LDM_STM_OPS];\n+  int order[MAX_LDM_STM_OPS];\n   int base_reg = -1;\n-  int i;\n+  int i, stm_case;\n \n-  /* Can only handle 2, 3, or 4 insns at present, though could be easily\n-     extended if required.  */\n-  gcc_assert (nops >= 2 && nops <= 4);\n+  /* Can only handle up to MAX_LDM_STM_OPS insns at present, though could be\n+     easily extended if required.  */\n+  gcc_assert (nops >= 2 && nops <= MAX_LDM_STM_OPS);\n \n-  memset (order, 0, 4 * sizeof (int));\n+  memset (order, 0, MAX_LDM_STM_OPS * sizeof (int));\n \n   /* Loop over the operands and check that the memory references are\n      suitable (i.e. immediate offsets from the same base register).  At\n@@ -9351,32 +9381,22 @@ store_multiple_sequence (rtx *operands, int nops, int *regs, int *base,\n \t      && (GET_CODE (offset = XEXP (XEXP (operands[nops + i], 0), 1))\n \t\t  == CONST_INT)))\n \t{\n+\t  unsorted_regs[i] = (GET_CODE (operands[i]) == REG\n+\t\t\t      ? REGNO (operands[i])\n+\t\t\t      : REGNO (SUBREG_REG (operands[i])));\n \t  if (i == 0)\n-\t    {\n-\t      base_reg = REGNO (reg);\n-\t      unsorted_regs[0] = (GET_CODE (operands[i]) == REG\n-\t\t\t\t  ? REGNO (operands[i])\n-\t\t\t\t  : REGNO (SUBREG_REG (operands[i])));\n-\t      order[0] = 0;\n-\t    }\n-\t  else\n-\t    {\n-\t      if (base_reg != (int) REGNO (reg))\n-\t\t/* Not addressed from the same base register.  */\n-\t\treturn 0;\n-\n-\t      unsorted_regs[i] = (GET_CODE (operands[i]) == REG\n-\t\t\t\t  ? REGNO (operands[i])\n-\t\t\t\t  : REGNO (SUBREG_REG (operands[i])));\n-\t      if (unsorted_regs[i] < unsorted_regs[order[0]])\n-\t\torder[0] = i;\n-\t    }\n+\t    base_reg = REGNO (reg);\n+\t  else if (base_reg != (int) REGNO (reg))\n+\t    /* Not addressed from the same base register.  */\n+\t    return 0;\n \n \t  /* If it isn't an integer register, then we can't do this.  */\n \t  if (unsorted_regs[i] < 0 || unsorted_regs[i] > 14)\n \t    return 0;\n \n \t  unsorted_offsets[i] = INTVAL (offset);\n+\t  if (i == 0 || unsorted_offsets[i] < unsorted_offsets[order[0]])\n+\t    order[0] = i;\n \t}\n       else\n \t/* Not a suitable memory address.  */\n@@ -9385,30 +9405,11 @@ store_multiple_sequence (rtx *operands, int nops, int *regs, int *base,\n \n   /* All the useful information has now been extracted from the\n      operands into unsorted_regs and unsorted_offsets; additionally,\n-     order[0] has been set to the lowest numbered register in the\n-     list.  Sort the registers into order, and check that the memory\n-     offsets are ascending and adjacent.  */\n-\n-  for (i = 1; i < nops; i++)\n-    {\n-      int j;\n-\n-      order[i] = order[i - 1];\n-      for (j = 0; j < nops; j++)\n-\tif (unsorted_regs[j] > unsorted_regs[order[i - 1]]\n-\t    && (order[i] == order[i - 1]\n-\t\t|| unsorted_regs[j] < unsorted_regs[order[i]]))\n-\t  order[i] = j;\n-\n-      /* Have we found a suitable register? if not, one must be used more\n-\t than once.  */\n-      if (order[i] == order[i - 1])\n-\treturn 0;\n-\n-      /* Is the memory address adjacent and ascending? */\n-      if (unsorted_offsets[order[i]] != unsorted_offsets[order[i - 1]] + 4)\n-\treturn 0;\n-    }\n+     order[0] has been set to the lowest offset in the list.  Sort\n+     the offsets into order, verifying that they are adjacent, and\n+     check that the register numbers are ascending.  */\n+  if (!compute_offset_order (nops, unsorted_offsets, order, unsorted_regs))\n+    return 0;\n \n   if (base)\n     {\n@@ -9421,24 +9422,26 @@ store_multiple_sequence (rtx *operands, int nops, int *regs, int *base,\n     }\n \n   if (unsorted_offsets[order[0]] == 0)\n-    return 1; /* stmia */\n-\n-  if (unsorted_offsets[order[0]] == 4)\n-    return 2; /* stmib */\n-\n-  if (unsorted_offsets[order[nops - 1]] == 0)\n-    return 3; /* stmda */\n+    stm_case = 1; /* stmia */\n+  else if (TARGET_ARM && unsorted_offsets[order[0]] == 4)\n+    stm_case = 2; /* stmib */\n+  else if (TARGET_ARM && unsorted_offsets[order[nops - 1]] == 0)\n+    stm_case = 3; /* stmda */\n+  else if (unsorted_offsets[order[nops - 1]] == -4)\n+    stm_case = 4; /* stmdb */\n+  else\n+    return 0;\n \n-  if (unsorted_offsets[order[nops - 1]] == -4)\n-    return 4; /* stmdb */\n+  if (!multiple_operation_profitable_p (false, nops, 0))\n+    return 0;\n \n-  return 0;\n+  return stm_case;\n }\n \n const char *\n emit_stm_seq (rtx *operands, int nops)\n {\n-  int regs[4];\n+  int regs[MAX_LDM_STM_OPS];\n   int base_reg;\n   HOST_WIDE_INT offset;\n   char buf[100];"}, {"sha": "dc0a9f31ef4bf354fb873951e3e9819e09567204", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93b338c3964e0d4f7b267a37077c8b8fecb7749e/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93b338c3964e0d4f7b267a37077c8b8fecb7749e/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=93b338c3964e0d4f7b267a37077c8b8fecb7749e", "patch": "@@ -2769,4 +2769,8 @@ enum arm_builtins\n #define NEED_INDICATE_EXEC_STACK\t0\n #endif\n \n+/* The maximum number of parallel loads or stores we support in an ldm/stm\n+   instruction.  */\n+#define MAX_LDM_STM_OPS 4\n+\n #endif /* ! GCC_ARM_H */"}]}