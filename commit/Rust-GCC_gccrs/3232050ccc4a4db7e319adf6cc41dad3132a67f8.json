{"sha": "3232050ccc4a4db7e319adf6cc41dad3132a67f8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzIzMjA1MGNjYzRhNGRiN2UzMTlhZGY2Y2M0MWRhZDMxMzJhNjdmOA==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1995-05-12T08:13:44Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1995-05-12T08:13:44Z"}, "message": "Fix reporting of unterminated strings.\n\nFrom-SVN: r9637", "tree": {"sha": "bf28d7ce61b29b578484461490948b5dec91469f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bf28d7ce61b29b578484461490948b5dec91469f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3232050ccc4a4db7e319adf6cc41dad3132a67f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3232050ccc4a4db7e319adf6cc41dad3132a67f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3232050ccc4a4db7e319adf6cc41dad3132a67f8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3232050ccc4a4db7e319adf6cc41dad3132a67f8/comments", "author": null, "committer": null, "parents": [{"sha": "9dcdcbeb114cd09eb0a0b91189e4f9734e9727b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9dcdcbeb114cd09eb0a0b91189e4f9734e9727b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9dcdcbeb114cd09eb0a0b91189e4f9734e9727b6"}], "stats": {"total": 167, "additions": 40, "deletions": 127}, "files": [{"sha": "db60a65cb8fabf830b95e7511091fceca291f8d6", "filename": "gcc/cpplib.c", "status": "modified", "additions": 37, "deletions": 123, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3232050ccc4a4db7e319adf6cc41dad3132a67f8/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3232050ccc4a4db7e319adf6cc41dad3132a67f8/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=3232050ccc4a4db7e319adf6cc41dad3132a67f8", "patch": "@@ -284,7 +284,6 @@ static int compare_defs ();\n static int compare_token_lists ();\n static HOST_WIDE_INT eval_if_expression ();\n static int change_newlines ();\n-static int line_for_error ();\n extern int hashf ();\n static int file_size_and_mode ();\n static struct arglist *read_token_list ();\n@@ -491,66 +490,6 @@ initialize_char_syntax (opts)\n   is_space['\\r'] = 1;\n }\n \n-/*\n- * Skip over a quoted string.  BP points to the opening quote.\n- * Returns a pointer after the closing quote.  Don't go past LIMIT.\n- * START_LINE is the line number of the starting point (but it need\n- * not be valid if the starting point is inside a macro expansion).\n- *\n- * The input stack state is not changed.\n- */\n-static U_CHAR *\n-skip_quoted_string (pfile, first, start_line)\n-     cpp_reader *pfile;\n-     int first;\n-     int start_line;\n-{\n-  int c;\n-\n-  while (1)\n-    {\n-      c = GETC ();\n-      if (c == EOF)\n-\t{\n-\t  cpp_error_with_line (pfile, line_for_error (pfile, start_line),\n-\t\t\t       \"unterminated string or character constant\");\n-#if 0\n-\t  cpp_error_with_line (pfile, multiline_string_line,\n-\t\t\t       \"possible real start of unterminated constant\");\n-\t  multiline_string_line = 0;\n-#endif\n-\t  break;\n-\t}\n-      if (c == '\\\\')\n-\t{\n-\t  c = GETC ();\n-\t  NEWLINE_FIX1(c);\n-\t}\n-      else if (c == '\\n')\n-\t{\n-\t  if (CPP_TRADITIONAL (pfile))\n-\t    {\n-\t      /* Unterminated strings and character constants are 'legal'.  */\n-\t      FORWARD(-1);\t/* Don't consume the newline. */\n-\t      break;\n-\t    }\n-\t  if (CPP_PEDANTIC (pfile) || first == '\\'')\n-\t    {\n-\t      cpp_error_with_line (pfile, line_for_error (pfile, start_line),\n-\t\t\t\t   \"unterminated string or character constant\");\n-\t      FORWARD(-1);\n-\t      break;\n-\t    }\n-\t  /* If not traditional, then allow newlines inside strings.  */\n-#if 0\n-\t  if (multiline_string_line == 0)\n-\t    multiline_string_line = start_line;\n-#endif\n-      }\n-      else if (c == first)\n-\tbreak;\n-    }\n-}\n \n /* Place into PFILE a quoted string representing the string SRC.\n    Caller must reserve enough space in pfile->token_buffer. */\n@@ -2707,7 +2646,7 @@ macroexpand (pfile, hp)\n   int nargs;\n   DEFINITION *defn = hp->value.defn;\n   register U_CHAR *xbuf;\n-  long start_line, start_col;\n+  long start_line, start_column;\n   int xbuf_len;\n   struct argdata *args;\n   long old_written = CPP_WRITTEN (pfile);\n@@ -2729,7 +2668,7 @@ macroexpand (pfile, hp)\n #endif\n \n   pfile->output_escapes++;\n-  cpp_buf_line_and_col (CPP_BUFFER (pfile), &start_line, &start_col);\n+  cpp_buf_line_and_col (cpp_file_buffer (pfile), &start_line, &start_column);\n \n   nargs = defn->nargs;\n \n@@ -2773,7 +2712,7 @@ macroexpand (pfile, hp)\n \t    token = macarg (pfile, 0);\n \t  if (token == CPP_EOF || token == CPP_POP)\n \t    {\n-\t      cpp_error_with_line (pfile, line_for_error (pfile, start_line),\n+\t      cpp_error_with_line (pfile, start_line, start_column,\n \t\t\t\t   \"unterminated macro call\");\n \t      return;\n \t    }\n@@ -4476,6 +4415,7 @@ skip_if_group (pfile, any)\n   for (;;) {\n     switch (c)\n       {\n+\tlong old;\n       case EOF:\n \tgoto done;\n       case '/':\t\t\t/* possible comment */\n@@ -4485,7 +4425,10 @@ skip_if_group (pfile, any)\n \tbreak;\n       case '\\\"':\n       case '\\'':\n-\tskip_quoted_string (pfile, c, 0 /* FIXME */);\n+\tFORWARD(-1);\n+\told = CPP_WRITTEN (pfile);\n+\tcpp_get_token (pfile);\n+\tCPP_SET_WRITTEN (pfile, old);\n \tbreak;\n       case '\\\\':\n \t/* Char after backslash loses its special meaning.  */\n@@ -4656,6 +4599,7 @@ cpp_get_token (pfile)\n {\n   register int c, c2, c3;\n   long old_written;\n+  long start_line, start_column;\n   enum cpp_token token;\n   struct cpp_options *opts = CPP_OPTIONS (pfile);\n   CPP_BUFFER (pfile)->prev = CPP_BUFFER (pfile)->cur;\n@@ -4702,15 +4646,16 @@ cpp_get_token (pfile)\n \t  if (opts->put_out_comments)\n \t    parse_set_mark (&start_mark, pfile);\n \t  newlines = 0;\n+\t  cpp_buf_line_and_col (cpp_file_buffer (pfile),\n+\t\t\t\t&start_line, &start_column);\n \t  c = skip_comment (pfile, &newlines);\n \t  if (opts->put_out_comments && (c == '/' || c == EOF))\n \t    parse_clear_mark (&start_mark);\n \t  if (c == '/')\n \t    goto randomchar;\n \t  if (c == EOF)\n \t    {\n-\t      cpp_error_with_line (pfile,\n-\t\t\t\t   line_for_error (pfile, pfile->start_line),\n+\t      cpp_error_with_line (pfile, start_line, start_column,\n \t\t\t\t   \"unterminated comment\");\n \t      goto handle_eof;\n \t    }\n@@ -4814,9 +4759,8 @@ cpp_get_token (pfile)\n \tcase '\\'':\n \t  /* A single quoted string is treated like a double -- some\n \t     programs (e.g., troff) are perverse this way */\n-#if 0\n-\t  start_line = pfile->lineno;\n-#endif\n+\t  cpp_buf_line_and_col (cpp_file_buffer (pfile),\n+\t\t\t\t&start_line, &start_column);\n \t  old_written = CPP_WRITTEN (pfile);\n \tstring:\n \t  CPP_PUTC (pfile, c);\n@@ -4838,17 +4782,17 @@ cpp_get_token (pfile)\n \t\t\tCPP_BUFFER (pfile) = next_buf;\n \t\t\tcontinue;\n \t\t    }\n-#if 0\n \t\t  if (!CPP_TRADITIONAL (pfile))\n \t\t    {\n-\t\t      cpp_error_with_line (pfile,\n-\t\t\t\t\t   line_for_error (pfile, start_line),\n+\t\t      cpp_error_with_line (pfile, start_line, start_column,\n \t\t\t      \"unterminated string or character constant\");\n-\t\t      cpp_error_with_line (pfile, multiline_string_line,\n-\t\t\t\t \"possible real start of unterminated constant\");\n-\t\t      multiline_string_line = 0;\n+\t\t      if (pfile->multiline_string_line != start_line\n+\t\t\t  && pfile->multiline_string_line != 0)\n+\t\t\tcpp_error_with_line (pfile,\n+\t\t\t\t\t     pfile->multiline_string_line, -1,\n+\t\t\t       \"possible real start of unterminated constant\");\n+\t\t      pfile->multiline_string_line = 0;\n \t\t    }\n-#endif\n \t\t  break;\n \t\t}\n \t      CPP_PUTC (pfile, cc);\n@@ -4859,23 +4803,20 @@ cpp_get_token (pfile)\n \t\t no error.  So exit the loop and record the new line.  */\n \t\t  if (CPP_TRADITIONAL (pfile))\n \t\t    goto while2end;\n-#if 0\n \t\t  if (c == '\\'')\n \t\t    {\n-\t\t      cpp_error_with_line (pfile,\n-\t\t\t\t\t   line_for_error (pfile, start_line),\n+\t\t      cpp_error_with_line (pfile, start_line, start_column,\n \t\t\t\t\t   \"unterminated character constant\");\n \t\t      goto while2end;\n \t\t    }\n-\t\t  if (CPP_PEDANTIC (pfile) && multiline_string_line == 0)\n+\t\t  if (CPP_PEDANTIC (pfile)\n+\t\t      && pfile->multiline_string_line == 0)\n \t\t    {\n-\t\t      cpp_pedwarn_with_line (pfile,\n-\t\t\t\t\t     line_for_error (pfile, start_line),\n+\t\t      cpp_pedwarn_with_line (pfile, start_line, start_column,\n \t\t\t       \"string constant runs past end of line\");\n \t\t    }\n-\t\t  if (multiline_string_line == 0)\n-\t\t    multiline_string_line = ip->lineno - 1;\n-#endif\n+\t\t  if (pfile->multiline_string_line == 0)\n+\t\t    pfile->multiline_string_line = start_line;\n \t\t  break;\n \t\t\n \t\tcase '\\\\':\n@@ -7268,31 +7209,6 @@ savestring (input)\n   return output;\n }\n \f\n-/* Return the line at which an error occurred.\n-   The error is not necessarily associated with the current spot\n-   in the input stack, so LINE says where.  LINE will have been\n-   copied from ip->lineno for the current input level.\n-   If the current level is for a file, we return LINE.\n-   But if the current level is not for a file, LINE is meaningless.\n-   In that case, we return the lineno of the innermost file.  */\n-\n-static int\n-line_for_error (pfile, line)\n-     cpp_reader *pfile;\n-     int line;\n-{\n-  long line1 = line, col;\n-  cpp_buffer *ip = CPP_BUFFER (pfile);\n-\n-  while (ip != CPP_NULL_BUFFER (pfile))\n-    {\n-      if (ip->fname != NULL)\n-\treturn line1;\n-      ip = CPP_PREV_BUFFER (ip);\n-      cpp_buf_line_and_col (ip, &line1, &col);\n-    }\n-}\n-\f\n /* Initialize PMARK to remember the current position of PFILE. */\n void\n parse_set_mark (pmark, pfile)\n@@ -7435,9 +7351,9 @@ cpp_pedwarn (pfile, msg, arg1, arg2, arg3)\n }\n \n void\n-cpp_error_with_line (pfile, line, msg, arg1, arg2, arg3)\n+cpp_error_with_line (pfile, line, column, msg, arg1, arg2, arg3)\n      cpp_reader *pfile;\n-     int line;\n+     int line, column;\n      char *msg;\n      char *arg1, *arg2, *arg3;\n {\n@@ -7447,15 +7363,15 @@ cpp_error_with_line (pfile, line, msg, arg1, arg2, arg3)\n   cpp_print_containing_files (pfile);\n \n   if (ip != NULL)\n-    cpp_file_line_for_message (pfile, ip->nominal_fname, line, -1);\n+    cpp_file_line_for_message (pfile, ip->nominal_fname, line, column);\n \n   cpp_message (pfile, 1, msg, arg1, arg2, arg3);\n }\n \n-void\n-cpp_warning_with_line (pfile, line, msg, arg1, arg2, arg3)\n+static void\n+cpp_warning_with_line (pfile, line, column, msg, arg1, arg2, arg3)\n      cpp_reader *pfile;\n-     int line;\n+     int line, column;\n      char *msg;\n      char *arg1, *arg2, *arg3;\n {\n@@ -7473,22 +7389,22 @@ cpp_warning_with_line (pfile, line, msg, arg1, arg2, arg3)\n   ip = cpp_file_buffer (pfile);\n \n   if (ip != NULL)\n-    cpp_file_line_for_message (pfile, ip->nominal_fname, line, -1);\n+    cpp_file_line_for_message (pfile, ip->nominal_fname, line, column);\n \n   cpp_message (pfile, 0, msg, arg1, arg2, arg3);\n }\n \n void\n-cpp_pedwarn_with_line (pfile, line, msg, arg1, arg2, arg3)\n+cpp_pedwarn_with_line (pfile, line, column, msg, arg1, arg2, arg3)\n      cpp_reader *pfile;\n      int line;\n      char *msg;\n      char *arg1, *arg2, *arg3;\n {\n   if (CPP_OPTIONS (pfile)->pedantic_errors)\n-    cpp_error_with_line (pfile, line, msg, arg1, arg2, arg3);\n+    cpp_error_with_line (pfile, column, line, msg, arg1, arg2, arg3);\n   else\n-    cpp_warning_with_line (pfile, line, msg, arg1, arg2, arg3);\n+    cpp_warning_with_line (pfile, line, column, msg, arg1, arg2, arg3);\n }\n \n /* Report a warning (or an error if pedantic_errors)\n@@ -7596,8 +7512,6 @@ cpp_perror_with_name (pfile, name)\n  *\n  * Possibly different enum token codes for each C/C++ token.\n  *\n- * Better error messages for non-terminated strings and comments.\n- *\n  * Should clean up remaining directives to that do_XXX functions\n  *   only take two arguments and all have command_reads_line.\n  *"}, {"sha": "861f7757ce95ad1d9c69526468a705ad49eb2e0c", "filename": "gcc/cpplib.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3232050ccc4a4db7e319adf6cc41dad3132a67f8/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3232050ccc4a4db7e319adf6cc41dad3132a67f8/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=3232050ccc4a4db7e319adf6cc41dad3132a67f8", "patch": "@@ -187,14 +187,14 @@ struct cpp_reader {\n #endif\n \n   int errors;\t\t\t/* Error counter for exit code */\n-  /* While scanning a comment or a string constant,\n-     this records the line it started on, for error messages.  */\n-  int start_line;\n   void *data;\n \n   U_CHAR *token_buffer;\n   int token_buffer_size;\n \n+  /* Line where a newline was first seen in a string constant.  */\n+  int multiline_string_line;\n+\n   /* Current depth in #include directives that use <...>.  */\n   int system_include_depth;\n \n@@ -638,7 +638,6 @@ extern void cpp_error ();\n extern void cpp_warning ();\n extern void cpp_pedwarn ();\n extern void cpp_error_with_line ();\n-extern void cpp_warning_with_line ();\n extern void cpp_pedwarn_with_line ();\n extern void cpp_pedwarn_with_file_and_line ();\n extern void fatal ();"}]}