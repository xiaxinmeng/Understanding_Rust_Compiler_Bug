{"sha": "db30731aa44d6975021de8b9838297d2e9603cf3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGIzMDczMWFhNDRkNjk3NTAyMWRlOGI5ODM4Mjk3ZDJlOTYwM2NmMw==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2005-04-26T17:37:33Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2005-04-26T17:37:33Z"}, "message": "tree-flow-inline.h (op_iter_next_must_and_may_def): New.\n\n\n\t* tree-flow-inline.h (op_iter_next_must_and_may_def): New.\n\t(op_iter_init_must_and_may_def): Likewise.\n\t(unmodifiable_var_p): Move to a later point in the file.\n\t* tree-ssa-operands.h (FOR_EACH_SSA_MUST_AND_MAY_DEF_OPERAND): New.\n\t* tree-ssa-dse.c (need_imm_uses_for): Remove, no longer needed.\n\t(dse_record_phis): Directly check for virtual operands rather than\n\tusing need_imm_uses_for.\n\t(dse_optimize_stmt): Handle V_MUST_DEF operands.  Handle case where\n\tstore has multiple V_{MAY,MUST}_DEF operands.\n\nFrom-SVN: r98780", "tree": {"sha": "0d7eb68bfe51ab28e40b7b4005702e4ca1a156ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0d7eb68bfe51ab28e40b7b4005702e4ca1a156ff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/db30731aa44d6975021de8b9838297d2e9603cf3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db30731aa44d6975021de8b9838297d2e9603cf3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db30731aa44d6975021de8b9838297d2e9603cf3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db30731aa44d6975021de8b9838297d2e9603cf3/comments", "author": null, "committer": null, "parents": [{"sha": "5635785a6477d146de01022cc4ef7da97a49a894", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5635785a6477d146de01022cc4ef7da97a49a894", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5635785a6477d146de01022cc4ef7da97a49a894"}], "stats": {"total": 148, "additions": 110, "deletions": 38}, "files": [{"sha": "7e9b9341ae986de0937832a9ea8ac09eecd8f672", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db30731aa44d6975021de8b9838297d2e9603cf3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db30731aa44d6975021de8b9838297d2e9603cf3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=db30731aa44d6975021de8b9838297d2e9603cf3", "patch": "@@ -1,3 +1,15 @@\n+2005-04-26  Jeff Law  <law@redhat.com>\n+\n+\t* tree-flow-inline.h (op_iter_next_must_and_may_def): New.\n+\t(op_iter_init_must_and_may_def): Likewise.\n+\t(unmodifiable_var_p): Move to a later point in the file.\n+\t* tree-ssa-operands.h (FOR_EACH_SSA_MUST_AND_MAY_DEF_OPERAND): New.\n+\t* tree-ssa-dse.c (need_imm_uses_for): Remove, no longer needed.\n+\t(dse_record_phis): Directly check for virtual operands rather than\n+\tusing need_imm_uses_for.\n+\t(dse_optimize_stmt): Handle V_MUST_DEF operands.  Handle case where\n+\tstore has multiple V_{MAY,MUST}_DEF operands.\n+\n 2005-04-26  Andrew MacLeod  <amacleod@redhat.com>\n \n \t* tree-cfg.c (bsi_replace): Delink immediate uses for the original stmt."}, {"sha": "87a243daa3c09f93dbd4d01437635d523d451a55", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 49, "deletions": 10, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db30731aa44d6975021de8b9838297d2e9603cf3/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db30731aa44d6975021de8b9838297d2e9603cf3/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=db30731aa44d6975021de8b9838297d2e9603cf3", "patch": "@@ -1121,6 +1121,7 @@ op_iter_next_mustdef (use_operand_p *kill, def_operand_p *def, ssa_op_iter *ptr)\n   ptr->done = true;\n   return;\n }\n+\n /* Get the next iterator maydef value for PTR, returning the maydef values in\n    USE and DEF.  */\n static inline void\n@@ -1141,6 +1142,34 @@ op_iter_next_maydef (use_operand_p *use, def_operand_p *def, ssa_op_iter *ptr)\n   return;\n }\n \n+/* Get the next iterator mustdef or maydef value for PTR, returning the\n+   mustdef or maydef values in KILL and DEF.  */\n+static inline void\n+op_iter_next_must_and_may_def (use_operand_p *kill,\n+\t\t\t       def_operand_p *def,\n+\t\t\t       ssa_op_iter *ptr)\n+{\n+  if (ptr->v_mustu_i < ptr->num_v_mustu)\n+    {\n+      *def = V_MUST_DEF_RESULT_PTR (ptr->ops->v_must_def_ops, ptr->v_mustu_i);\n+      *kill = V_MUST_DEF_KILL_PTR (ptr->ops->v_must_def_ops, (ptr->v_mustu_i)++);\n+      return;\n+    }\n+  else if (ptr->v_mayu_i < ptr->num_v_mayu)\n+    {\n+      *def = V_MAY_DEF_RESULT_PTR (ptr->ops->v_may_def_ops, ptr->v_mayu_i);\n+      *kill = V_MAY_DEF_OP_PTR (ptr->ops->v_may_def_ops, (ptr->v_mayu_i)++);\n+      return;\n+    }\n+  else\n+    {\n+      *def = NULL_DEF_OPERAND_P;\n+      *kill = NULL_USE_OPERAND_P;\n+    }\n+  ptr->done = true;\n+  return;\n+}\n+\n /* Initialize iterator PTR to the operands in STMT.  Return the first operands\n    in USE and DEF.  */\n static inline void\n@@ -1151,16 +1180,6 @@ op_iter_init_maydef (ssa_op_iter *ptr, tree stmt, use_operand_p *use,\n   op_iter_next_maydef (use, def, ptr);\n }\n \n-/* Return true if VAR cannot be modified by the program.  */\n-\n-static inline bool\n-unmodifiable_var_p (tree var)\n-{\n-  if (TREE_CODE (var) == SSA_NAME)\n-    var = SSA_NAME_VAR (var);\n-  return TREE_READONLY (var) && (TREE_STATIC (var) || DECL_EXTERNAL (var));\n-}\n-\n \n /* Initialize iterator PTR to the operands in STMT.  Return the first operands\n    in KILL and DEF.  */\n@@ -1172,6 +1191,26 @@ op_iter_init_mustdef (ssa_op_iter *ptr, tree stmt, use_operand_p *kill,\n   op_iter_next_mustdef (kill, def, ptr);\n }\n \n+/* Initialize iterator PTR to the operands in STMT.  Return the first operands\n+   in KILL and DEF.  */\n+static inline void\n+op_iter_init_must_and_may_def (ssa_op_iter *ptr, tree stmt,\n+\t\t\t       use_operand_p *kill, def_operand_p *def)\n+{\n+  op_iter_init (ptr, stmt, SSA_OP_VMUSTDEFKILL | SSA_OP_VMAYUSE);\n+  op_iter_next_must_and_may_def (kill, def, ptr);\n+}\n+\n+/* Return true if VAR cannot be modified by the program.  */\n+\n+static inline bool\n+unmodifiable_var_p (tree var)\n+{\n+  if (TREE_CODE (var) == SSA_NAME)\n+    var = SSA_NAME_VAR (var);\n+  return TREE_READONLY (var) && (TREE_STATIC (var) || DECL_EXTERNAL (var));\n+}\n+\n /* Return true if REF, a COMPONENT_REF, has an ARRAY_REF somewhere in it.  */\n \n static inline bool"}, {"sha": "42b61553832d358b868a50d03feafe92c99602b6", "filename": "gcc/tree-ssa-dse.c", "status": "modified", "additions": 42, "deletions": 28, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db30731aa44d6975021de8b9838297d2e9603cf3/gcc%2Ftree-ssa-dse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db30731aa44d6975021de8b9838297d2e9603cf3/gcc%2Ftree-ssa-dse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dse.c?ref=db30731aa44d6975021de8b9838297d2e9603cf3", "patch": "@@ -111,18 +111,8 @@ get_stmt_uid (tree stmt)\n   return stmt_ann (stmt)->uid;\n }\n \n-/* Function indicating whether we ought to include information for 'var'\n-   when calculating immediate uses.  For this pass we only want use\n-   information for virtual variables.  */\n-\n-static bool\n-need_imm_uses_for (tree var)\n-{\n-  return !is_gimple_reg (var);\n-}\n-\n-\n /* Set bit UID in bitmaps GLOBAL and *LOCAL, creating *LOCAL as needed.  */\n+\n static void\n record_voperand_set (bitmap global, bitmap *local, unsigned int uid)\n {\n@@ -136,6 +126,7 @@ record_voperand_set (bitmap global, bitmap *local, unsigned int uid)\n   bitmap_set_bit (*local, uid);\n   bitmap_set_bit (global, uid);\n }\n+\n /* Initialize block local data structures.  */\n \n static void\n@@ -177,12 +168,15 @@ dse_optimize_stmt (struct dom_walk_data *walk_data,\n   tree stmt = bsi_stmt (bsi);\n   stmt_ann_t ann = stmt_ann (stmt);\n   v_may_def_optype v_may_defs;\n+  v_must_def_optype v_must_defs;\n \n   v_may_defs = V_MAY_DEF_OPS (ann);\n+  v_must_defs = V_MUST_DEF_OPS (ann);\n \n   /* If this statement has no virtual defs, then there is nothing\n      to do.  */\n-  if (NUM_V_MAY_DEFS (v_may_defs) == 0)\n+  if (NUM_V_MAY_DEFS (v_may_defs) == 0\n+      && NUM_V_MUST_DEFS (v_must_defs) == 0)\n     return;\n \n   /* We know we have virtual definitions.  If this is a MODIFY_EXPR that's\n@@ -195,33 +189,53 @@ dse_optimize_stmt (struct dom_walk_data *walk_data,\n \n   if (TREE_CODE (stmt) == MODIFY_EXPR)\n     {\n-      unsigned int num_uses = 0, count = 0;\n       use_operand_p first_use_p = NULL_USE_OPERAND_P;\n-      use_operand_p use_p;\n-      tree use, use_stmt;\n+      use_operand_p use_p = NULL;\n+      tree use, use_stmt, temp;\n       tree defvar = NULL_TREE, usevar = NULL_TREE;\n+      bool fail = false;\n       use_operand_p var2;\n       def_operand_p var1;\n       ssa_op_iter op_iter;\n \n-      FOR_EACH_SSA_MAYDEF_OPERAND (var1, var2, stmt, op_iter)\n-        {\n+      /* We want to verify that each virtual definition in STMT has\n+\t precisely one use and that all the virtual definitions are\n+\t used by the same single statement.  When complete, we\n+\t want USE_STMT to refer to the one statment which uses\n+\t all of the virtual definitions from STMT.  */\n+      use_stmt = NULL;\n+      FOR_EACH_SSA_MUST_AND_MAY_DEF_OPERAND (var1, var2, stmt, op_iter)\n+\t{\n \t  defvar = DEF_FROM_PTR (var1);\n \t  usevar = USE_FROM_PTR (var2);\n-\t  num_uses += num_imm_uses (defvar);\n-\t  count++;\n-\t  if (num_uses > 1 || count > 1)\n-\t    break;\n-\t}\n \n-      if (count == 1 && num_uses == 1)\n-        {\n-\t  single_imm_use (defvar, &use_p, &use_stmt);\n+\t  /* If this virtual def does not have precisely one use, then\n+\t     we will not be able to eliminate STMT.  */\n+\t  if (num_imm_uses (defvar) != 1)\n+\t    {\n+\t      fail = true;\n+\t      break;\n+\t    }\n+\n+\t  /* Get the one and only immediate use of DEFVAR.  */\n+\t  single_imm_use (defvar, &use_p, &temp);\n \t  gcc_assert (use_p != NULL_USE_OPERAND_P);\n \t  first_use_p = use_p;\n \t  use = USE_FROM_PTR (use_p);\n+\n+\t  /* If the immediate use of DEF_VAR is not the same as the\n+\t     previously find immediate uses, then we will not be able\n+\t     to eliminate STMT.  */\n+\t  if (use_stmt == NULL)\n+\t    use_stmt = temp;\n+\t  else if (temp != use_stmt)\n+\t    {\n+\t      fail = true;\n+\t      break;\n+\t    }\n \t}\n-      else\n+\n+      if (fail)\n \t{\n \t  record_voperand_set (dse_gd->stores, &bd->stores, ann->uid);\n \t  return;\n@@ -231,7 +245,7 @@ dse_optimize_stmt (struct dom_walk_data *walk_data,\n \t represents the only use of this store.\n \n \t Note this does not handle the case where the store has\n-\t multiple V_MAY_DEFs which all reach a set of PHI nodes in the\n+\t multiple V_{MAY,MUST}_DEFs which all reach a set of PHI nodes in the\n \t same block.  */\n       while (use_p != NULL_USE_OPERAND_P\n \t     && TREE_CODE (use_stmt) == PHI_NODE\n@@ -295,7 +309,7 @@ dse_record_phis (struct dom_walk_data *walk_data, basic_block bb)\n   tree phi;\n \n   for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n-    if (need_imm_uses_for (PHI_RESULT (phi)))\n+    if (!is_gimple_reg (PHI_RESULT (phi)))\n       record_voperand_set (dse_gd->stores,\n \t\t\t   &bd->stores,\n \t\t\t   get_stmt_uid (phi));"}, {"sha": "2d531c8b64cad3142da5849a07bcb279b56d3cc4", "filename": "gcc/tree-ssa-operands.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db30731aa44d6975021de8b9838297d2e9603cf3/gcc%2Ftree-ssa-operands.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db30731aa44d6975021de8b9838297d2e9603cf3/gcc%2Ftree-ssa-operands.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.h?ref=db30731aa44d6975021de8b9838297d2e9603cf3", "patch": "@@ -291,4 +291,11 @@ typedef struct ssa_operand_iterator_d\n        !op_iter_done (&(ITER));\t\t\t\t\t\\\n        op_iter_next_mustdef (&(KILLVAR), &(DEFVAR), &(ITER)))\n \n+/* This macro executes a loop over the V_{MUST,MAY}_DEF of STMT.  The def\n+   and kill for each V_{MUST,MAY}_DEF is returned in DEFVAR and KILLVAR. \n+   ITER is an ssa_op_iter structure used to control the loop.  */\n+#define FOR_EACH_SSA_MUST_AND_MAY_DEF_OPERAND(DEFVAR, KILLVAR, STMT, ITER)\\\n+  for (op_iter_init_must_and_may_def (&(ITER), STMT, &(KILLVAR), &(DEFVAR));\\\n+       !op_iter_done (&(ITER));\t\t\t\t\t\\\n+       op_iter_next_must_and_may_def (&(KILLVAR), &(DEFVAR), &(ITER)))\n #endif  /* GCC_TREE_SSA_OPERANDS_H  */"}]}