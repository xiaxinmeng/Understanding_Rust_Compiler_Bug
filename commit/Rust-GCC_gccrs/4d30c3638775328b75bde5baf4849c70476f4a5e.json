{"sha": "4d30c3638775328b75bde5baf4849c70476f4a5e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGQzMGMzNjM4Nzc1MzI4Yjc1YmRlNWJhZjQ4NDljNzA0NzZmNGE1ZQ==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1995-02-01T21:44:49Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1995-02-01T21:44:49Z"}, "message": "Add preliminary V.4 and eABI support.\n\nFrom-SVN: r8850", "tree": {"sha": "44170eb6c580a1c29dcd1e09b42ce49f16a1c117", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/44170eb6c580a1c29dcd1e09b42ce49f16a1c117"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4d30c3638775328b75bde5baf4849c70476f4a5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d30c3638775328b75bde5baf4849c70476f4a5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d30c3638775328b75bde5baf4849c70476f4a5e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d30c3638775328b75bde5baf4849c70476f4a5e/comments", "author": null, "committer": null, "parents": [{"sha": "1038f4f99a5911c3e21740685e648442f7b28117", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1038f4f99a5911c3e21740685e648442f7b28117", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1038f4f99a5911c3e21740685e648442f7b28117"}], "stats": {"total": 135, "additions": 121, "deletions": 14}, "files": [{"sha": "6eb40f3cd2621f94ca748b7e9f548179faa335c6", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 91, "deletions": 9, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d30c3638775328b75bde5baf4849c70476f4a5e/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d30c3638775328b75bde5baf4849c70476f4a5e/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=4d30c3638775328b75bde5baf4849c70476f4a5e", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines used for code generation on IBM RS/6000.\n-   Copyright (C) 1991, 1993, 1994 Free Software Foundation, Inc.\n+   Copyright (C) 1991, 1993, 1994, 1995 Free Software Foundation, Inc.\n    Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu)\n \n This file is part of GNU CC.\n@@ -1321,11 +1321,15 @@ print_operand (file, x, code)\n     case 'z':\n       /* X is a SYMBOL_REF.  Write out the name preceded by a\n \t period and without any trailing data in brackets.  Used for function\n-\t names.  */\n+\t names.  If we are configured for System V (or the embedded ABI) on\n+\t the PowerPC, do not emit the period, since those systems do not use\n+\t TOCs and the like.  */\n       if (GET_CODE (x) != SYMBOL_REF)\n \tabort ();\n \n+#ifndef USING_SVR4_H\n       putc ('.', file);\n+#endif\n       RS6000_OUTPUT_BASENAME (file, XSTR (x, 0));\n       return;\n \n@@ -1503,6 +1507,74 @@ rs6000_pushes_stack ()\n \t  || rs6000_makes_calls ());\n }\n \n+#ifdef USING_SVR4_H\n+/* Write out a System V.4 style traceback table before the prologue\n+\n+   At present, only emit the basic tag table (ie, do not emit tag_types other\n+   than 0, which might use more than 1 tag word).\n+\n+   The first tag word looks like:\n+\n+    0\t\t\t1\t\t    2\t\t\t3\n+    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n+   |         0 |ver| tag |e|s| alloca  | # fprs  | # gprs  |s|l|c|f|\n+   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n+\n+*/\n+\n+void\n+svr4_traceback (file, name, decl)\n+     FILE *file;\n+     tree name, decl;\n+{\n+\n+  int first_reg\t\t= first_reg_to_save ();\n+  int first_fp_reg\t= first_fp_reg_to_save ();\n+  int pushes_stack\t= rs6000_pushes_stack ();\n+  long tag;\n+  long version\t\t= 0;\t\t\t/* version number */\n+  long tag_type\t\t= 0;\t\t\t/* function type */\n+  long extended_tag\t= 0;\t\t\t/* additional tag words needed */\n+  long spare\t\t= 0;\t\t\t/* reserved for future use */\n+  long alloca_reg;\t\t\t\t/* stack/frame register */\n+  long fpr_max\t\t= 64 - first_fp_reg;\t/* # of floating point registers saved */\n+  long gpr_max\t\t= 32 - first_reg;\t/* # of general purpose registers saved */\n+  long sp_max;\t\t\t\t\t/* 1 if the function aquires a stack frame */\n+  long lr_max;\t\t\t\t\t/* 1 if the function stores the link register */\n+  long cr_max;\t\t\t\t\t/* 1 if the function has a CR save word */\n+  long fpscr_max\t= 0;\t\t\t/* 1 if the function has a FPSCR save word */\n+\n+  if (frame_pointer_needed)\n+    alloca_reg = 31;\n+\n+  else if (pushes_stack != 0)\n+    alloca_reg = 1;\n+\n+  else\n+    alloca_reg = 0;\n+\n+  lr_max = (regs_ever_live[65] || first_fp_reg < 62 || profile_flag);\n+  cr_max = (must_save_cr () != 0);\n+  sp_max = (pushes_stack != 0);\n+\n+  tag = (((version & 3) << 24)\n+\t | ((tag_type & 7) << 21)\n+\t | ((extended_tag & 1) << 20)\n+\t | ((spare & 1) << 19)\n+\t | ((alloca_reg & 0x1f) << 14)\n+\t | ((fpr_max & 0x1f) << 9)\n+\t | ((gpr_max & 0x1f) << 4)\n+\t | ((sp_max & 1) << 3)\n+\t | ((lr_max & 1) << 2)\n+\t | ((cr_max & 1) << 1)\n+\t | ((fpscr_max & 1) << 0));\n+\t   \n+  fprintf (file, \"\\t.long 0x%lx\\n\", tag);\n+}\n+\n+#endif /* USING_SVR4_H */\n+\n /* Write function prologue.  */\n \n void\n@@ -1522,8 +1594,9 @@ output_prolog (file, size)\n   /* Write .extern for any function we will call to save and restore fp\n      values.  */\n   if (first_fp_reg < 62)\n-    fprintf (file, \"\\t.extern ._savef%d\\n\\t.extern ._restf%d\\n\",\n-\t     first_fp_reg - 32, first_fp_reg - 32);\n+    fprintf (file, \"\\t.extern %s%d%s\\n\\t.extern %s%d%s\\n\",\n+\t     SAVE_FP_PREFIX, first_fp_reg - 32, SAVE_FP_SUFFIX,\n+\t     RESTORE_FP_PREFIX, first_fp_reg - 32, RESTORE_FP_SUFFIX);\n \n   /* Write .extern for truncation routines, if needed.  */\n   if (rs6000_trunc_used && ! trunc_defined)\n@@ -1565,10 +1638,10 @@ output_prolog (file, size)\n   else if (first_fp_reg == 63)\n     asm_fprintf (file, \"\\tstfd 31,-8(1)\\n\");\n   else if (first_fp_reg != 64)\n-    asm_fprintf (file, \"\\tbl ._savef%d\\n\", first_fp_reg - 32);\n+    asm_fprintf (file, \"\\tbl %s%d%s\\n\", SAVE_FP_PREFIX, first_fp_reg - 32, SAVE_FP_SUFFIX);\n \n   /* Now save gpr's.  */\n-  if (! TARGET_POWER || first_reg == 31)\n+  if (! TARGET_MULTIPLE || first_reg == 31)\n     {\n       int regno, loc;\n \n@@ -1670,7 +1743,7 @@ output_epilog (file, size)\n \tasm_fprintf (file, \"\\tmtlr 0\\n\");\n \n       /* Restore gpr's.  */\n-      if (! TARGET_POWER || first_reg == 31)\n+      if (! TARGET_MULTIPLE || first_reg == 31)\n \t{\n \t  int regno, loc;\n \n@@ -1702,7 +1775,7 @@ output_epilog (file, size)\n       /* If we have to restore more than two FP registers, branch to the\n \t restore function.  It will return to our caller.  */\n       if (first_fp_reg < 62)\n-\tasm_fprintf (file, \"\\tb ._restf%d\\n\", first_fp_reg - 32);\n+\tasm_fprintf (file, \"\\tb %s%d%s\\n\", RESTORE_FP_PREFIX, first_fp_reg - 32, RESTORE_FP_SUFFIX);\n       else\n \tasm_fprintf (file, \"\\t{br|blr}\\n\");\n     }\n@@ -1717,7 +1790,11 @@ output_epilog (file, size)\n      middle, and the two halves are placed at locations far apart in\n      memory.''  The traceback table has this property, since it\n      includes the offset from the start of the function to the\n-     traceback table itself.  */\n+     traceback table itself.\n+\n+     System V.4 Powerpc's (and the embedded ABI derived from it) use a\n+     different traceback table located before the prologue.  */\n+#ifndef USING_SVR4_H\n   if (! flag_inhibit_size_directive)\n     {\n       char *fname = XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0);\n@@ -1895,6 +1972,7 @@ output_epilog (file, size)\n       if (frame_pointer_needed)\n \tfprintf (file, \"\\t.byte 31\\n\");\n     }\n+#endif /* !USING_SVR4_H */\n }\n \f\n /* Output a TOC entry.  We derive the entry name from what is\n@@ -2111,6 +2189,9 @@ output_function_profiler (file, labelno)\n   FILE *file;\n   int labelno;\n {\n+#ifdef USING_SVR4_H\n+  abort ();\n+#else\n   /* The last used parameter register.  */\n   int last_parm_reg;\n   int i, j;\n@@ -2162,6 +2243,7 @@ output_function_profiler (file, labelno)\n \n   for (i = 3, j = 30; i <= last_parm_reg; i++, j--)\n     fprintf (file, \"\\tai %d,%d,0\\n\", i, j);\n+#endif\n }\n \n /* Adjust the cost of a scheduling dependency.  Return the new cost of"}, {"sha": "d848450bb0fe2f9b75eff65bb55359bc9251bbb9", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d30c3638775328b75bde5baf4849c70476f4a5e/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d30c3638775328b75bde5baf4849c70476f4a5e/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=4d30c3638775328b75bde5baf4849c70476f4a5e", "patch": "@@ -145,6 +145,9 @@ extern int target_flags;\n /* Disable use of FPRs.  */\n #define MASK_NO_FPR\t\t0x800\n \n+/* Enable load/store multiple, even on powerpc */\n+#define\tMASK_MULTIPLE\t\t0x1000\n+\n #define TARGET_POWER\t\t\t(target_flags & MASK_POWER)\n #define TARGET_POWER2\t\t\t(target_flags & MASK_POWER2)\n #define TARGET_POWERPC\t\t\t(target_flags & MASK_POWERPC)\n@@ -157,6 +160,7 @@ extern int target_flags;\n #define TARGET_MINIMAL_TOC\t\t(target_flags & MASK_MINIMAL_TOC)\n #define TARGET_64BIT\t\t\t(target_flags & MASK_64BIT)\n #define TARGET_NO_FPR\t\t\t(target_flags & MASK_NO_FPR)\n+#define\tTARGET_MULTIPLE\t\t\t(target_flags & MASK_MULTIPLE)\n \n /* Run-time compilation parameters selecting different hardware subsets.\n \n@@ -166,6 +170,11 @@ extern int target_flags;\n    where VALUE is the bits to set or minus the bits to clear.\n    An empty string NAME is used to identify the default VALUE.  */\n \n+/* This is meant to be redefined in the host dependent files */\n+#ifndef SUBTARGET_SWITCHES\n+#define SUBTARGET_SWITCHES\n+#endif\n+\n #define TARGET_SWITCHES\t\t\t\t\t\t\\\n  {{\"power\",\t\tMASK_POWER},\t\t\t\t\\\n   {\"power2\",\t\tMASK_POWER | MASK_POWER2},\t\t\\\n@@ -191,9 +200,12 @@ extern int target_flags;\n   {\"no-minimal-toc\",\t- MASK_MINIMAL_TOC},\t\t\t\\\n   {\"fp-regs\",\t\t- MASK_NO_FPR},\t\t\t\t\\\n   {\"no-fp-regs\",\tMASK_NO_FPR},\t\t\t\t\\\n+  {\"multiple\",\t\tMASK_MULTIPLE},\t\t\t\t\\\n+  {\"no-multiple\",\t- MASK_MULTIPLE},\t\t\t\\\n+  SUBTARGET_SWITCHES\t\t\t\t\t\t\\\n   {\"\",\t\t\tTARGET_DEFAULT}}\n \n-#define TARGET_DEFAULT MASK_POWER\n+#define TARGET_DEFAULT (MASK_POWER | MASK_MULTIPLE)\n \n /* Processor type.  */\n enum processor_type\n@@ -1630,6 +1642,19 @@ extern int rs6000_trunc_used;\n \n #define RS6000_ITRUNC \"itrunc\"\n #define RS6000_UITRUNC \"uitrunc\"\n+\n+/* Prefix and suffix to use to saving floating point */\n+#ifndef SAVE_FP_PREFIX\n+#define\tSAVE_FP_PREFIX \"._savef\"\n+#define SAVE_FP_SUFFIX \"\"\n+#endif\n+\n+/* Prefix and suffix to use to restoring floating point */\n+#ifndef RESTORE_FP_PREFIX\n+#define\tRESTORE_FP_PREFIX \"._restf\"\n+#define RESTORE_FP_SUFFIX \"\"\n+#endif\n+\n \f\n /* Control the assembler format that we output.  */\n "}, {"sha": "4c901cb59b3aee53b9ec3f30d31d2c644ae151c6", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d30c3638775328b75bde5baf4849c70476f4a5e/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d30c3638775328b75bde5baf4849c70476f4a5e/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=4d30c3638775328b75bde5baf4849c70476f4a5e", "patch": "@@ -1,5 +1,5 @@\n ;; Machine description for IBM RISC System 6000 (POWER) for GNU C compiler\n-;; Copyright (C) 1990, 1991, 1992, 1993, 1994 Free Software Foundation, Inc.\n+;; Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995 Free Software Foundation, Inc.\n ;; Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu)\n \n ;; This file is part of GNU CC.\n@@ -4137,7 +4137,7 @@\n   [(match_par_dup 3 [(set (match_operand:SI 0 \"\" \"\")\n \t\t\t  (match_operand:SI 1 \"\" \"\"))\n \t\t     (use (match_operand:SI 2 \"\" \"\"))])]\n-  \"TARGET_POWER\"\n+  \"TARGET_MULTIPLE\"\n   \"\n {\n   int regno;\n@@ -4172,7 +4172,7 @@\n   [(match_parallel 0 \"load_multiple_operation\"\n \t\t   [(set (match_operand:SI 1 \"gpc_reg_operand\" \"=r\")\n \t\t\t (match_operand:SI 2 \"indirect_operand\" \"Q\"))])]\n-  \"TARGET_POWER\"\n+  \"TARGET_MULTIPLE\"\n   \"*\n {\n   /* We have to handle the case where the pseudo used to contain the address\n@@ -4206,7 +4206,7 @@\n \t\t\t  (match_operand:SI 1 \"\" \"\"))\n \t\t     (clobber (scratch:SI))\n \t\t     (use (match_operand:SI 2 \"\" \"\"))])]\n-  \"TARGET_POWER\"\n+  \"TARGET_MULTIPLE\"\n   \"\n {\n   int regno;"}]}