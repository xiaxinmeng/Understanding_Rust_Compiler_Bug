{"sha": "6276b63014a37a17a67724f1e6bbd8b0b0b31fff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjI3NmI2MzAxNGEzN2ExN2E2NzcyNGYxZTZiYmQ4YjBiMGIzMWZmZg==", "commit": {"author": {"name": "James Greenhalgh", "email": "james.greenhalgh@arm.com", "date": "2014-11-18T10:00:29Z"}, "committer": {"name": "James Greenhalgh", "email": "jgreenhalgh@gcc.gnu.org", "date": "2014-11-18T10:00:29Z"}, "message": "[Patch ARM Refactor Builtins 7/8] Use qualifiers arrays when initialising builtins and fix type mangling\n\ngcc/\n\n\t* config/arm/arm-builtins.c (arm_scalar_builtin_types): New.\n\t(enum arm_simd_type): Likewise.\n\t(struct arm_simd_type_info): Likewise\n\t(arm_mangle_builtin_scalar_type): Likewise.\n\t(arm_mangle_builtin_vector_type): Likewise.\n\t(arm_mangle_builtin_type): Likewise.\n\t(arm_simd_builtin_std_type): Likewise.\n\t(arm_lookup_simd_builtin_type): Likewise.\n\t(arm_simd_builtin_type): Likewise.\n\t(arm_init_simd_builtin_types): Likewise.\n\t(arm_init_simd_builtin_scalar_types): Likewise.\n\t(arm_init_neon_builtins): Rewrite using qualifiers.\n\t* config/arm/arm-protos.h (arm_mangle_builtin_type): New.\n\t* config/arm/arm-simd-builtin-types.def: New file.\n\t* config/arm/t-arm (arm-builtins.o): Depend on it.\n\t* config/arm/arm.c (arm_mangle_type): Call arm_mangle_builtin_type.\n\t* config/arm/arm_neon.h (int8x8_t): Use new internal type.\n\t(int16x4_t): Likewise.\n\t(int32x2_t): Likewise.\n\t(float16x4_t): Likewise.\n\t(float32x2_t): Likewise.\n\t(poly8x8_t): Likewise.\n\t(poly16x4_t): Likewise.\n\t(uint8x8_t): Likewise.\n\t(uint16x4_t): Likewise.\n\t(uint32x2_t): Likewise.\n\t(int8x16_t): Likewise.\n\t(int16x8_t): Likewise.\n\t(int32x4_t): Likewise.\n\t(int64x2_t): Likewise.\n\t(float32x4_t): Likewise.\n\t(poly8x16_t): Likewise.\n\t(poly16x8_t): Likewise.\n\t(uint8x16_t): Likewise.\n\t(uint16x8_t): Likewise.\n\t(uint32x4_t): Likewise.\n\t(uint64x2_t): Likewise.\n\nFrom-SVN: r217699", "tree": {"sha": "7b878eb0dde13d7a71f43064ee3131e7120be2a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7b878eb0dde13d7a71f43064ee3131e7120be2a1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6276b63014a37a17a67724f1e6bbd8b0b0b31fff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6276b63014a37a17a67724f1e6bbd8b0b0b31fff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6276b63014a37a17a67724f1e6bbd8b0b0b31fff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6276b63014a37a17a67724f1e6bbd8b0b0b31fff/comments", "author": {"login": "jgreenhalgh-arm", "id": 6104025, "node_id": "MDQ6VXNlcjYxMDQwMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6104025?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jgreenhalgh-arm", "html_url": "https://github.com/jgreenhalgh-arm", "followers_url": "https://api.github.com/users/jgreenhalgh-arm/followers", "following_url": "https://api.github.com/users/jgreenhalgh-arm/following{/other_user}", "gists_url": "https://api.github.com/users/jgreenhalgh-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jgreenhalgh-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jgreenhalgh-arm/subscriptions", "organizations_url": "https://api.github.com/users/jgreenhalgh-arm/orgs", "repos_url": "https://api.github.com/users/jgreenhalgh-arm/repos", "events_url": "https://api.github.com/users/jgreenhalgh-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/jgreenhalgh-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "acb94767e6c2667277ba12ae80e626f1edd4e717", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acb94767e6c2667277ba12ae80e626f1edd4e717", "html_url": "https://github.com/Rust-GCC/gccrs/commit/acb94767e6c2667277ba12ae80e626f1edd4e717"}], "stats": {"total": 1268, "additions": 631, "deletions": 637}, "files": [{"sha": "138b156ab2d09908150b06a0da4c970a9eaba9d8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6276b63014a37a17a67724f1e6bbd8b0b0b31fff/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6276b63014a37a17a67724f1e6bbd8b0b0b31fff/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6276b63014a37a17a67724f1e6bbd8b0b0b31fff", "patch": "@@ -1,3 +1,43 @@\n+2014-11-18  James Greenhalgh  <james.greenhalgh@arm.com>\n+\n+\t* config/arm/arm-builtins.c (arm_scalar_builtin_types): New.\n+\t(enum arm_simd_type): Likewise.\n+\t(struct arm_simd_type_info): Likewise\n+\t(arm_mangle_builtin_scalar_type): Likewise.\n+\t(arm_mangle_builtin_vector_type): Likewise.\n+\t(arm_mangle_builtin_type): Likewise.\n+\t(arm_simd_builtin_std_type): Likewise.\n+\t(arm_lookup_simd_builtin_type): Likewise.\n+\t(arm_simd_builtin_type): Likewise.\n+\t(arm_init_simd_builtin_types): Likewise.\n+\t(arm_init_simd_builtin_scalar_types): Likewise.\n+\t(arm_init_neon_builtins): Rewrite using qualifiers.\n+\t* config/arm/arm-protos.h (arm_mangle_builtin_type): New.\n+\t* config/arm/arm-simd-builtin-types.def: New file.\n+\t* config/arm/t-arm (arm-builtins.o): Depend on it.\n+\t* config/arm/arm.c (arm_mangle_type): Call arm_mangle_builtin_type.\n+\t* config/arm/arm_neon.h (int8x8_t): Use new internal type.\n+\t(int16x4_t): Likewise.\n+\t(int32x2_t): Likewise.\n+\t(float16x4_t): Likewise.\n+\t(float32x2_t): Likewise.\n+\t(poly8x8_t): Likewise.\n+\t(poly16x4_t): Likewise.\n+\t(uint8x8_t): Likewise.\n+\t(uint16x4_t): Likewise.\n+\t(uint32x2_t): Likewise.\n+\t(int8x16_t): Likewise.\n+\t(int16x8_t): Likewise.\n+\t(int32x4_t): Likewise.\n+\t(int64x2_t): Likewise.\n+\t(float32x4_t): Likewise.\n+\t(poly8x16_t): Likewise.\n+\t(poly16x8_t): Likewise.\n+\t(uint8x16_t): Likewise.\n+\t(uint16x8_t): Likewise.\n+\t(uint32x4_t): Likewise.\n+\t(uint64x2_t): Likewise.\n+\n 2014-11-18  James Greenhalgh  <james.greenhalgh@arm.com>\n \n \t* gcc/config/arm/arm-builtins.c\t(arm_type_qualifiers): New."}, {"sha": "6f3183ed1b7cfc411ba4554756a9236e89e58537", "filename": "gcc/config/arm/arm-builtins.c", "status": "modified", "additions": 508, "deletions": 554, "changes": 1062, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6276b63014a37a17a67724f1e6bbd8b0b0b31fff/gcc%2Fconfig%2Farm%2Farm-builtins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6276b63014a37a17a67724f1e6bbd8b0b0b31fff/gcc%2Fconfig%2Farm%2Farm-builtins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-builtins.c?ref=6276b63014a37a17a67724f1e6bbd8b0b0b31fff", "patch": "@@ -625,598 +625,552 @@ static GTY(()) tree arm_builtin_decls[ARM_BUILTIN_MAX];\n #define NUM_DREG_TYPES 5\n #define NUM_QREG_TYPES 6\n \n+/* Internal scalar builtin types.  These types are used to support\n+   neon intrinsic builtins.  They are _not_ user-visible types.  Therefore\n+   the mangling for these types are implementation defined.  */\n+const char *arm_scalar_builtin_types[] = {\n+  \"__builtin_neon_qi\",\n+  \"__builtin_neon_hi\",\n+  \"__builtin_neon_si\",\n+  \"__builtin_neon_sf\",\n+  \"__builtin_neon_di\",\n+  \"__builtin_neon_df\",\n+  \"__builtin_neon_ti\",\n+  \"__builtin_neon_uqi\",\n+  \"__builtin_neon_uhi\",\n+  \"__builtin_neon_usi\",\n+  \"__builtin_neon_udi\",\n+  \"__builtin_neon_ei\",\n+  \"__builtin_neon_oi\",\n+  \"__builtin_neon_ci\",\n+  \"__builtin_neon_xi\",\n+  NULL\n+};\n+\n+#define ENTRY(E, M, Q, S, T, G) E,\n+enum arm_simd_type\n+{\n+#include \"arm-simd-builtin-types.def\"\n+  __TYPE_FINAL\n+};\n+#undef ENTRY\n+\n+struct arm_simd_type_info\n+{\n+  enum arm_simd_type type;\n+\n+  /* Internal type name.  */\n+  const char *name;\n+\n+  /* Internal type name(mangled).  The mangled names conform to the\n+     AAPCS (see \"Procedure Call Standard for the ARM Architecture\",\n+     Appendix A).  To qualify for emission with the mangled names defined in\n+     that document, a vector type must not only be of the correct mode but also\n+     be of the correct internal Neon vector type (e.g. __simd64_int8_t);\n+     these types are registered by arm_init_simd_builtin_types ().  In other\n+     words, vector types defined in other ways e.g. via vector_size attribute\n+     will get default mangled names.  */\n+  const char *mangle;\n+\n+  /* Internal type.  */\n+  tree itype;\n+\n+  /* Element type.  */\n+  tree eltype;\n+\n+  /* Machine mode the internal type maps to.  */\n+  machine_mode mode;\n+\n+  /* Qualifiers.  */\n+  enum arm_type_qualifiers q;\n+};\n+\n+#define ENTRY(E, M, Q, S, T, G)\t\t\\\n+  {E,\t\t\t\t\t\\\n+   \"__simd\" #S \"_\" #T \"_t\",\t\t\\\n+   #G \"__simd\" #S \"_\" #T \"_t\",\t\t\\\n+   NULL_TREE, NULL_TREE, M##mode, qualifier_##Q},\n+static struct arm_simd_type_info arm_simd_types [] = {\n+#include \"arm-simd-builtin-types.def\"\n+};\n+#undef ENTRY\n+\n+static tree arm_simd_floatHF_type_node = NULL_TREE;\n+static tree arm_simd_intOI_type_node = NULL_TREE;\n+static tree arm_simd_intEI_type_node = NULL_TREE;\n+static tree arm_simd_intCI_type_node = NULL_TREE;\n+static tree arm_simd_intXI_type_node = NULL_TREE;\n+static tree arm_simd_polyQI_type_node = NULL_TREE;\n+static tree arm_simd_polyHI_type_node = NULL_TREE;\n+static tree arm_simd_polyDI_type_node = NULL_TREE;\n+static tree arm_simd_polyTI_type_node = NULL_TREE;\n+\n+static const char *\n+arm_mangle_builtin_scalar_type (const_tree type)\n+{\n+  int i = 0;\n+\n+  while (arm_scalar_builtin_types[i] != NULL)\n+    {\n+      const char *name = arm_scalar_builtin_types[i];\n+\n+      if (TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n+\t  && DECL_NAME (TYPE_NAME (type))\n+\t  && !strcmp (IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type))), name))\n+\treturn arm_scalar_builtin_types[i];\n+      i++;\n+    }\n+  return NULL;\n+}\n+\n+static const char *\n+arm_mangle_builtin_vector_type (const_tree type)\n+{\n+  int i;\n+  int nelts = sizeof (arm_simd_types) / sizeof (arm_simd_types[0]);\n+\n+  for (i = 0; i < nelts; i++)\n+    if (arm_simd_types[i].mode ==  TYPE_MODE (type)\n+\t&& TYPE_NAME (type)\n+\t&& TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n+\t&& DECL_NAME (TYPE_NAME (type))\n+\t&& !strcmp\n+\t     (IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type))),\n+\t      arm_simd_types[i].name))\n+      return arm_simd_types[i].mangle;\n+\n+  return NULL;\n+}\n+\n+const char *\n+arm_mangle_builtin_type (const_tree type)\n+{\n+  const char *mangle;\n+  /* Walk through all the AArch64 builtins types tables to filter out the\n+     incoming type.  */\n+  if ((mangle = arm_mangle_builtin_vector_type (type))\n+      || (mangle = arm_mangle_builtin_scalar_type (type)))\n+    return mangle;\n+\n+  return NULL;\n+}\n+\n+static tree\n+arm_simd_builtin_std_type (enum machine_mode mode,\n+\t\t\t   enum arm_type_qualifiers q)\n+{\n+#define QUAL_TYPE(M)  \\\n+  ((q == qualifier_none) ? int##M##_type_node : unsigned_int##M##_type_node);\n+  switch (mode)\n+    {\n+    case QImode:\n+      return QUAL_TYPE (QI);\n+    case HImode:\n+      return QUAL_TYPE (HI);\n+    case SImode:\n+      return QUAL_TYPE (SI);\n+    case DImode:\n+      return QUAL_TYPE (DI);\n+    case TImode:\n+      return QUAL_TYPE (TI);\n+    case OImode:\n+      return arm_simd_intOI_type_node;\n+    case EImode:\n+      return arm_simd_intEI_type_node;\n+    case CImode:\n+      return arm_simd_intCI_type_node;\n+    case XImode:\n+      return arm_simd_intXI_type_node;\n+    case HFmode:\n+      return arm_simd_floatHF_type_node;\n+    case SFmode:\n+      return float_type_node;\n+    case DFmode:\n+      return double_type_node;\n+    default:\n+      gcc_unreachable ();\n+    }\n+#undef QUAL_TYPE\n+}\n+\n+static tree\n+arm_lookup_simd_builtin_type (enum machine_mode mode,\n+\t\t\t      enum arm_type_qualifiers q)\n+{\n+  int i;\n+  int nelts = sizeof (arm_simd_types) / sizeof (arm_simd_types[0]);\n+\n+  /* Non-poly scalar modes map to standard types not in the table.  */\n+  if (q != qualifier_poly && !VECTOR_MODE_P (mode))\n+    return arm_simd_builtin_std_type (mode, q);\n+\n+  for (i = 0; i < nelts; i++)\n+    if (arm_simd_types[i].mode == mode\n+\t&& arm_simd_types[i].q == q)\n+      return arm_simd_types[i].itype;\n+\n+  /* Note that we won't have caught the underlying type for poly64x2_t\n+     in the above table.  This gets default mangling.  */\n+\n+  return NULL_TREE;\n+}\n+\n+static tree\n+arm_simd_builtin_type (enum machine_mode mode,\n+\t\t\t   bool unsigned_p, bool poly_p)\n+{\n+  if (poly_p)\n+    return arm_lookup_simd_builtin_type (mode, qualifier_poly);\n+  else if (unsigned_p)\n+    return arm_lookup_simd_builtin_type (mode, qualifier_unsigned);\n+  else\n+    return arm_lookup_simd_builtin_type (mode, qualifier_none);\n+}\n+\n static void\n-arm_init_neon_builtins (void)\n+arm_init_simd_builtin_types (void)\n {\n-  unsigned int i, fcode;\n-  tree decl;\n-\n-  tree neon_intQI_type_node;\n-  tree neon_intHI_type_node;\n-  tree neon_floatHF_type_node;\n-  tree neon_polyQI_type_node;\n-  tree neon_polyHI_type_node;\n-  tree neon_intSI_type_node;\n-  tree neon_intDI_type_node;\n-  tree neon_intUTI_type_node;\n-  tree neon_float_type_node;\n-\n-  tree intQI_pointer_node;\n-  tree intHI_pointer_node;\n-  tree intSI_pointer_node;\n-  tree intDI_pointer_node;\n-  tree float_pointer_node;\n-\n-  tree const_intQI_node;\n-  tree const_intHI_node;\n-  tree const_intSI_node;\n-  tree const_intDI_node;\n-  tree const_float_node;\n-\n-  tree const_intQI_pointer_node;\n-  tree const_intHI_pointer_node;\n-  tree const_intSI_pointer_node;\n-  tree const_intDI_pointer_node;\n-  tree const_float_pointer_node;\n-\n-  tree V8QI_type_node;\n-  tree V4HI_type_node;\n-  tree V4UHI_type_node;\n-  tree V4HF_type_node;\n-  tree V2SI_type_node;\n-  tree V2USI_type_node;\n-  tree V2SF_type_node;\n-  tree V16QI_type_node;\n-  tree V8HI_type_node;\n-  tree V8UHI_type_node;\n-  tree V4SI_type_node;\n-  tree V4USI_type_node;\n-  tree V4SF_type_node;\n-  tree V2DI_type_node;\n-  tree V2UDI_type_node;\n-\n-  tree intUQI_type_node;\n-  tree intUHI_type_node;\n-  tree intUSI_type_node;\n-  tree intUDI_type_node;\n-\n-  tree intEI_type_node;\n-  tree intOI_type_node;\n-  tree intCI_type_node;\n-  tree intXI_type_node;\n-\n-  tree reinterp_ftype_dreg[NUM_DREG_TYPES][NUM_DREG_TYPES];\n-  tree reinterp_ftype_qreg[NUM_QREG_TYPES][NUM_QREG_TYPES];\n-  tree dreg_types[NUM_DREG_TYPES], qreg_types[NUM_QREG_TYPES];\n-\n-  /* Create distinguished type nodes for NEON vector element types,\n-     and pointers to values of such types, so we can detect them later.  */\n-  neon_intQI_type_node = make_signed_type (GET_MODE_PRECISION (QImode));\n-  neon_intHI_type_node = make_signed_type (GET_MODE_PRECISION (HImode));\n-  neon_polyQI_type_node = make_signed_type (GET_MODE_PRECISION (QImode));\n-  neon_polyHI_type_node = make_signed_type (GET_MODE_PRECISION (HImode));\n-  neon_intSI_type_node = make_signed_type (GET_MODE_PRECISION (SImode));\n-  neon_intDI_type_node = make_signed_type (GET_MODE_PRECISION (DImode));\n-  neon_float_type_node = make_node (REAL_TYPE);\n-  TYPE_PRECISION (neon_float_type_node) = FLOAT_TYPE_SIZE;\n-  layout_type (neon_float_type_node);\n-  neon_floatHF_type_node = make_node (REAL_TYPE);\n-  TYPE_PRECISION (neon_floatHF_type_node) = GET_MODE_PRECISION (HFmode);\n-  layout_type (neon_floatHF_type_node);\n-\n-  /* Define typedefs which exactly correspond to the modes we are basing vector\n-     types on.  If you change these names you'll need to change\n-     the table used by arm_mangle_type too.  */\n-  (*lang_hooks.types.register_builtin_type) (neon_intQI_type_node,\n+  int i;\n+  int nelts = sizeof (arm_simd_types) / sizeof (arm_simd_types[0]);\n+  tree tdecl;\n+\n+  /* Initialize the HFmode scalar type.  */\n+  arm_simd_floatHF_type_node = make_node (REAL_TYPE);\n+  TYPE_PRECISION (arm_simd_floatHF_type_node) = GET_MODE_PRECISION (HFmode);\n+  layout_type (arm_simd_floatHF_type_node);\n+  (*lang_hooks.types.register_builtin_type) (arm_simd_floatHF_type_node,\n+\t\t\t\t\t     \"__builtin_neon_hf\");\n+\n+  /* Poly types are a world of their own.  In order to maintain legacy\n+     ABI, they get initialized using the old interface, and don't get\n+     an entry in our mangling table, consequently, they get default\n+     mangling.  As a further gotcha, poly8_t and poly16_t are signed\n+     types, poly64_t and poly128_t are unsigned types.  */\n+  arm_simd_polyQI_type_node\n+    = build_distinct_type_copy (intQI_type_node);\n+  (*lang_hooks.types.register_builtin_type) (arm_simd_polyQI_type_node,\n+\t\t\t\t\t     \"__builtin_neon_poly8\");\n+  arm_simd_polyHI_type_node\n+    = build_distinct_type_copy (intHI_type_node);\n+  (*lang_hooks.types.register_builtin_type) (arm_simd_polyHI_type_node,\n+\t\t\t\t\t     \"__builtin_neon_poly16\");\n+  arm_simd_polyDI_type_node\n+    = build_distinct_type_copy (unsigned_intDI_type_node);\n+  (*lang_hooks.types.register_builtin_type) (arm_simd_polyDI_type_node,\n+\t\t\t\t\t     \"__builtin_neon_poly64\");\n+  arm_simd_polyTI_type_node\n+    = build_distinct_type_copy (unsigned_intTI_type_node);\n+  (*lang_hooks.types.register_builtin_type) (arm_simd_polyTI_type_node,\n+\t\t\t\t\t     \"__builtin_neon_poly128\");\n+\n+  /* Init all the element types built by the front-end.  */\n+  arm_simd_types[Int8x8_t].eltype = intQI_type_node;\n+  arm_simd_types[Int8x16_t].eltype = intQI_type_node;\n+  arm_simd_types[Int16x4_t].eltype = intHI_type_node;\n+  arm_simd_types[Int16x8_t].eltype = intHI_type_node;\n+  arm_simd_types[Int32x2_t].eltype = intSI_type_node;\n+  arm_simd_types[Int32x4_t].eltype = intSI_type_node;\n+  arm_simd_types[Int64x2_t].eltype = intDI_type_node;\n+  arm_simd_types[Uint8x8_t].eltype = unsigned_intQI_type_node;\n+  arm_simd_types[Uint8x16_t].eltype = unsigned_intQI_type_node;\n+  arm_simd_types[Uint16x4_t].eltype = unsigned_intHI_type_node;\n+  arm_simd_types[Uint16x8_t].eltype = unsigned_intHI_type_node;\n+  arm_simd_types[Uint32x2_t].eltype = unsigned_intSI_type_node;\n+  arm_simd_types[Uint32x4_t].eltype = unsigned_intSI_type_node;\n+  arm_simd_types[Uint64x2_t].eltype = unsigned_intDI_type_node;\n+\n+  /* Init poly vector element types with scalar poly types.  */\n+  arm_simd_types[Poly8x8_t].eltype = arm_simd_polyQI_type_node;\n+  arm_simd_types[Poly8x16_t].eltype = arm_simd_polyQI_type_node;\n+  arm_simd_types[Poly16x4_t].eltype = arm_simd_polyHI_type_node;\n+  arm_simd_types[Poly16x8_t].eltype = arm_simd_polyHI_type_node;\n+  /* Note: poly64x2_t is defined in arm_neon.h, to ensure it gets default\n+     mangling.  */\n+\n+  /* Continue with standard types.  */\n+  arm_simd_types[Float16x4_t].eltype = arm_simd_floatHF_type_node;\n+  arm_simd_types[Float32x2_t].eltype = float_type_node;\n+  arm_simd_types[Float32x4_t].eltype = float_type_node;\n+\n+  for (i = 0; i < nelts; i++)\n+    {\n+      tree eltype = arm_simd_types[i].eltype;\n+      enum machine_mode mode = arm_simd_types[i].mode;\n+\n+      if (arm_simd_types[i].itype == NULL)\n+\tarm_simd_types[i].itype =\n+\t  build_distinct_type_copy\n+\t    (build_vector_type (eltype, GET_MODE_NUNITS (mode)));\n+\n+      tdecl = add_builtin_type (arm_simd_types[i].name,\n+\t\t\t\tarm_simd_types[i].itype);\n+      TYPE_NAME (arm_simd_types[i].itype) = tdecl;\n+      SET_TYPE_STRUCTURAL_EQUALITY (arm_simd_types[i].itype);\n+    }\n+\n+#define AARCH_BUILD_SIGNED_TYPE(mode)  \\\n+  make_signed_type (GET_MODE_PRECISION (mode));\n+  arm_simd_intOI_type_node = AARCH_BUILD_SIGNED_TYPE (OImode);\n+  arm_simd_intEI_type_node = AARCH_BUILD_SIGNED_TYPE (EImode);\n+  arm_simd_intCI_type_node = AARCH_BUILD_SIGNED_TYPE (CImode);\n+  arm_simd_intXI_type_node = AARCH_BUILD_SIGNED_TYPE (XImode);\n+#undef AARCH_BUILD_SIGNED_TYPE\n+\n+  tdecl = add_builtin_type\n+\t    (\"__builtin_neon_ei\" , arm_simd_intEI_type_node);\n+  TYPE_NAME (arm_simd_intEI_type_node) = tdecl;\n+  tdecl = add_builtin_type\n+\t    (\"__builtin_neon_oi\" , arm_simd_intOI_type_node);\n+  TYPE_NAME (arm_simd_intOI_type_node) = tdecl;\n+  tdecl = add_builtin_type\n+\t    (\"__builtin_neon_ci\" , arm_simd_intCI_type_node);\n+  TYPE_NAME (arm_simd_intCI_type_node) = tdecl;\n+  tdecl = add_builtin_type\n+\t    (\"__builtin_neon_xi\" , arm_simd_intXI_type_node);\n+  TYPE_NAME (arm_simd_intXI_type_node) = tdecl;\n+}\n+\n+static void\n+arm_init_simd_builtin_scalar_types (void)\n+{\n+  /* Define typedefs for all the standard scalar types.  */\n+  (*lang_hooks.types.register_builtin_type) (intQI_type_node,\n \t\t\t\t\t     \"__builtin_neon_qi\");\n-  (*lang_hooks.types.register_builtin_type) (neon_intHI_type_node,\n+  (*lang_hooks.types.register_builtin_type) (intHI_type_node,\n \t\t\t\t\t     \"__builtin_neon_hi\");\n-  (*lang_hooks.types.register_builtin_type) (neon_floatHF_type_node,\n-\t\t\t\t\t     \"__builtin_neon_hf\");\n-  (*lang_hooks.types.register_builtin_type) (neon_intSI_type_node,\n+  (*lang_hooks.types.register_builtin_type) (intSI_type_node,\n \t\t\t\t\t     \"__builtin_neon_si\");\n-  (*lang_hooks.types.register_builtin_type) (neon_float_type_node,\n+  (*lang_hooks.types.register_builtin_type) (float_type_node,\n \t\t\t\t\t     \"__builtin_neon_sf\");\n-  (*lang_hooks.types.register_builtin_type) (neon_intDI_type_node,\n+  (*lang_hooks.types.register_builtin_type) (intDI_type_node,\n \t\t\t\t\t     \"__builtin_neon_di\");\n-  (*lang_hooks.types.register_builtin_type) (neon_polyQI_type_node,\n-\t\t\t\t\t     \"__builtin_neon_poly8\");\n-  (*lang_hooks.types.register_builtin_type) (neon_polyHI_type_node,\n-\t\t\t\t\t     \"__builtin_neon_poly16\");\n-\n-  intQI_pointer_node = build_pointer_type (neon_intQI_type_node);\n-  intHI_pointer_node = build_pointer_type (neon_intHI_type_node);\n-  intSI_pointer_node = build_pointer_type (neon_intSI_type_node);\n-  intDI_pointer_node = build_pointer_type (neon_intDI_type_node);\n-  float_pointer_node = build_pointer_type (neon_float_type_node);\n-\n-  /* Next create constant-qualified versions of the above types.  */\n-  const_intQI_node = build_qualified_type (neon_intQI_type_node,\n-\t\t\t\t\t   TYPE_QUAL_CONST);\n-  const_intHI_node = build_qualified_type (neon_intHI_type_node,\n-\t\t\t\t\t   TYPE_QUAL_CONST);\n-  const_intSI_node = build_qualified_type (neon_intSI_type_node,\n-\t\t\t\t\t   TYPE_QUAL_CONST);\n-  const_intDI_node = build_qualified_type (neon_intDI_type_node,\n-\t\t\t\t\t   TYPE_QUAL_CONST);\n-  const_float_node = build_qualified_type (neon_float_type_node,\n-\t\t\t\t\t   TYPE_QUAL_CONST);\n-\n-  const_intQI_pointer_node = build_pointer_type (const_intQI_node);\n-  const_intHI_pointer_node = build_pointer_type (const_intHI_node);\n-  const_intSI_pointer_node = build_pointer_type (const_intSI_node);\n-  const_intDI_pointer_node = build_pointer_type (const_intDI_node);\n-  const_float_pointer_node = build_pointer_type (const_float_node);\n+  (*lang_hooks.types.register_builtin_type) (double_type_node,\n+\t\t\t\t\t     \"__builtin_neon_df\");\n+  (*lang_hooks.types.register_builtin_type) (intTI_type_node,\n+\t\t\t\t\t     \"__builtin_neon_ti\");\n \n   /* Unsigned integer types for various mode sizes.  */\n-  intUQI_type_node = make_unsigned_type (GET_MODE_PRECISION (QImode));\n-  intUHI_type_node = make_unsigned_type (GET_MODE_PRECISION (HImode));\n-  intUSI_type_node = make_unsigned_type (GET_MODE_PRECISION (SImode));\n-  intUDI_type_node = make_unsigned_type (GET_MODE_PRECISION (DImode));\n-  neon_intUTI_type_node = make_unsigned_type (GET_MODE_PRECISION (TImode));\n-  /* Now create vector types based on our NEON element types.  */\n-  /* 64-bit vectors.  */\n-  V8QI_type_node =\n-    build_vector_type_for_mode (neon_intQI_type_node, V8QImode);\n-  V4HI_type_node =\n-    build_vector_type_for_mode (neon_intHI_type_node, V4HImode);\n-  V4UHI_type_node =\n-    build_vector_type_for_mode (intUHI_type_node, V4HImode);\n-  V4HF_type_node =\n-    build_vector_type_for_mode (neon_floatHF_type_node, V4HFmode);\n-  V2SI_type_node =\n-    build_vector_type_for_mode (neon_intSI_type_node, V2SImode);\n-  V2USI_type_node =\n-    build_vector_type_for_mode (intUSI_type_node, V2SImode);\n-  V2SF_type_node =\n-    build_vector_type_for_mode (neon_float_type_node, V2SFmode);\n-  /* 128-bit vectors.  */\n-  V16QI_type_node =\n-    build_vector_type_for_mode (neon_intQI_type_node, V16QImode);\n-  V8HI_type_node =\n-    build_vector_type_for_mode (neon_intHI_type_node, V8HImode);\n-  V8UHI_type_node =\n-    build_vector_type_for_mode (intUHI_type_node, V8HImode);\n-  V4SI_type_node =\n-    build_vector_type_for_mode (neon_intSI_type_node, V4SImode);\n-  V4USI_type_node =\n-    build_vector_type_for_mode (intUSI_type_node, V4SImode);\n-  V4SF_type_node =\n-    build_vector_type_for_mode (neon_float_type_node, V4SFmode);\n-  V2DI_type_node =\n-    build_vector_type_for_mode (neon_intDI_type_node, V2DImode);\n-  V2UDI_type_node =\n-    build_vector_type_for_mode (intUDI_type_node, V2DImode);\n-\n-\n-  (*lang_hooks.types.register_builtin_type) (intUQI_type_node,\n+  (*lang_hooks.types.register_builtin_type) (unsigned_intQI_type_node,\n \t\t\t\t\t     \"__builtin_neon_uqi\");\n-  (*lang_hooks.types.register_builtin_type) (intUHI_type_node,\n+  (*lang_hooks.types.register_builtin_type) (unsigned_intHI_type_node,\n \t\t\t\t\t     \"__builtin_neon_uhi\");\n-  (*lang_hooks.types.register_builtin_type) (intUSI_type_node,\n+  (*lang_hooks.types.register_builtin_type) (unsigned_intSI_type_node,\n \t\t\t\t\t     \"__builtin_neon_usi\");\n-  (*lang_hooks.types.register_builtin_type) (intUDI_type_node,\n+  (*lang_hooks.types.register_builtin_type) (unsigned_intDI_type_node,\n \t\t\t\t\t     \"__builtin_neon_udi\");\n-  (*lang_hooks.types.register_builtin_type) (intUDI_type_node,\n-\t\t\t\t\t     \"__builtin_neon_poly64\");\n-  (*lang_hooks.types.register_builtin_type) (neon_intUTI_type_node,\n-\t\t\t\t\t     \"__builtin_neon_poly128\");\n-\n-  /* Opaque integer types for structures of vectors.  */\n-  intEI_type_node = make_signed_type (GET_MODE_PRECISION (EImode));\n-  intOI_type_node = make_signed_type (GET_MODE_PRECISION (OImode));\n-  intCI_type_node = make_signed_type (GET_MODE_PRECISION (CImode));\n-  intXI_type_node = make_signed_type (GET_MODE_PRECISION (XImode));\n+  (*lang_hooks.types.register_builtin_type) (unsigned_intTI_type_node,\n+\t\t\t\t\t     \"__builtin_neon_uti\");\n+}\n \n-  (*lang_hooks.types.register_builtin_type) (intTI_type_node,\n-\t\t\t\t\t     \"__builtin_neon_ti\");\n-  (*lang_hooks.types.register_builtin_type) (intEI_type_node,\n-\t\t\t\t\t     \"__builtin_neon_ei\");\n-  (*lang_hooks.types.register_builtin_type) (intOI_type_node,\n-\t\t\t\t\t     \"__builtin_neon_oi\");\n-  (*lang_hooks.types.register_builtin_type) (intCI_type_node,\n-\t\t\t\t\t     \"__builtin_neon_ci\");\n-  (*lang_hooks.types.register_builtin_type) (intXI_type_node,\n-\t\t\t\t\t     \"__builtin_neon_xi\");\n+static void\n+arm_init_neon_builtins (void)\n+{\n+  unsigned int i, fcode = ARM_BUILTIN_NEON_BASE;\n \n-  if (TARGET_CRYPTO && TARGET_HARD_FLOAT)\n-  {\n-\n-    tree V16UQI_type_node =\n-      build_vector_type_for_mode (intUQI_type_node, V16QImode);\n-\n-    tree v16uqi_ftype_v16uqi\n-      = build_function_type_list (V16UQI_type_node, V16UQI_type_node, NULL_TREE);\n-\n-    tree v16uqi_ftype_v16uqi_v16uqi\n-      = build_function_type_list (V16UQI_type_node, V16UQI_type_node,\n-                                  V16UQI_type_node, NULL_TREE);\n-\n-    tree v4usi_ftype_v4usi\n-      = build_function_type_list (V4USI_type_node, V4USI_type_node, NULL_TREE);\n-\n-    tree v4usi_ftype_v4usi_v4usi\n-      = build_function_type_list (V4USI_type_node, V4USI_type_node,\n-                                  V4USI_type_node, NULL_TREE);\n-\n-    tree v4usi_ftype_v4usi_v4usi_v4usi\n-      = build_function_type_list (V4USI_type_node, V4USI_type_node,\n-                                  V4USI_type_node, V4USI_type_node, NULL_TREE);\n-\n-    tree uti_ftype_udi_udi\n-      = build_function_type_list (neon_intUTI_type_node, intUDI_type_node,\n-                                  intUDI_type_node, NULL_TREE);\n-\n-    #undef CRYPTO1\n-    #undef CRYPTO2\n-    #undef CRYPTO3\n-    #undef C\n-    #undef N\n-    #undef CF\n-    #undef FT1\n-    #undef FT2\n-    #undef FT3\n-\n-    #define C(U) \\\n-      ARM_BUILTIN_CRYPTO_##U\n-    #define N(L) \\\n-      \"__builtin_arm_crypto_\"#L\n-    #define FT1(R, A) \\\n-      R##_ftype_##A\n-    #define FT2(R, A1, A2) \\\n-      R##_ftype_##A1##_##A2\n-    #define FT3(R, A1, A2, A3) \\\n-      R##_ftype_##A1##_##A2##_##A3\n-    #define CRYPTO1(L, U, R, A) \\\n-      arm_builtin_decls[C (U)] = add_builtin_function (N (L), FT1 (R, A), \\\n-                                                       C (U), BUILT_IN_MD, \\\n-                                                       NULL, NULL_TREE);\n-    #define CRYPTO2(L, U, R, A1, A2) \\\n-      arm_builtin_decls[C (U)] = add_builtin_function (N (L), FT2 (R, A1, A2), \\\n-                                                       C (U), BUILT_IN_MD, \\\n-                                                       NULL, NULL_TREE);\n-\n-    #define CRYPTO3(L, U, R, A1, A2, A3) \\\n-      arm_builtin_decls[C (U)] = add_builtin_function (N (L), FT3 (R, A1, A2, A3), \\\n-                                                       C (U), BUILT_IN_MD, \\\n-                                                       NULL, NULL_TREE);\n-    #include \"crypto.def\"\n-\n-    #undef CRYPTO1\n-    #undef CRYPTO2\n-    #undef CRYPTO3\n-    #undef C\n-    #undef N\n-    #undef FT1\n-    #undef FT2\n-    #undef FT3\n-  }\n-  dreg_types[0] = V8QI_type_node;\n-  dreg_types[1] = V4HI_type_node;\n-  dreg_types[2] = V2SI_type_node;\n-  dreg_types[3] = V2SF_type_node;\n-  dreg_types[4] = neon_intDI_type_node;\n-\n-  qreg_types[0] = V16QI_type_node;\n-  qreg_types[1] = V8HI_type_node;\n-  qreg_types[2] = V4SI_type_node;\n-  qreg_types[3] = V4SF_type_node;\n-  qreg_types[4] = V2DI_type_node;\n-  qreg_types[5] = neon_intUTI_type_node;\n-\n-  for (i = 0; i < NUM_QREG_TYPES; i++)\n-    {\n-      int j;\n-      for (j = 0; j < NUM_QREG_TYPES; j++)\n-        {\n-          if (i < NUM_DREG_TYPES && j < NUM_DREG_TYPES)\n-            reinterp_ftype_dreg[i][j]\n-              = build_function_type_list (dreg_types[i], dreg_types[j], NULL);\n+  arm_init_simd_builtin_types ();\n \n-          reinterp_ftype_qreg[i][j]\n-            = build_function_type_list (qreg_types[i], qreg_types[j], NULL);\n-        }\n-    }\n+  /* Strong-typing hasn't been implemented for all AdvSIMD builtin intrinsics.\n+     Therefore we need to preserve the old __builtin scalar types.  It can be\n+     removed once all the intrinsics become strongly typed using the qualifier\n+     system.  */\n+  arm_init_simd_builtin_scalar_types ();\n \n-  for (i = 0, fcode = ARM_BUILTIN_NEON_BASE;\n-       i < ARRAY_SIZE (neon_builtin_data);\n-       i++, fcode++)\n+  for (i = 0; i < ARRAY_SIZE (neon_builtin_data); i++, fcode++)\n     {\n+      bool print_type_signature_p = false;\n+      char type_signature[SIMD_MAX_BUILTIN_ARGS] = { 0 };\n       neon_builtin_datum *d = &neon_builtin_data[i];\n+      const char *const modenames[] =\n+\t{\n+\t  \"v8qi\", \"v4hi\", \"v4hf\", \"v2si\", \"v2sf\", \"di\",\n+\t  \"v16qi\", \"v8hi\", \"v4si\", \"v4sf\", \"v2di\",\n+\t  \"ti\", \"ei\", \"oi\"\n+\t};\n+      const enum machine_mode modes[] =\n+\t{\n+\t  V8QImode, V4HImode, V4HFmode, V2SImode, V2SFmode, DImode,\n+\t  V16QImode, V8HImode, V4SImode, V4SFmode, V2DImode,\n+\t  TImode, EImode, OImode\n+\t};\n \n-      const char* const modenames[] = {\n-\t\"v8qi\", \"v4hi\", \"v4hf\", \"v2si\", \"v2sf\", \"di\",\n-\t\"v16qi\", \"v8hi\", \"v4si\", \"v4sf\", \"v2di\",\n-\t\"ti\", \"ei\", \"oi\"\n-      };\n       char namebuf[60];\n       tree ftype = NULL;\n-      int is_load = 0, is_store = 0;\n+      tree fndecl = NULL;\n \n       gcc_assert (ARRAY_SIZE (modenames) == T_MAX);\n \n       d->fcode = fcode;\n \n-      switch (d->itype)\n+      /* We must track two variables here.  op_num is\n+\t the operand number as in the RTL pattern.  This is\n+\t required to access the mode (e.g. V4SF mode) of the\n+\t argument, from which the base type can be derived.\n+\t arg_num is an index in to the qualifiers data, which\n+\t gives qualifiers to the type (e.g. const unsigned).\n+\t The reason these two variables may differ by one is the\n+\t void return type.  While all return types take the 0th entry\n+\t in the qualifiers array, there is no operand for them in the\n+\t RTL pattern.  */\n+      int op_num = insn_data[d->code].n_operands - 1;\n+      int arg_num = d->qualifiers[0] & qualifier_void\n+\t\t      ? op_num + 1\n+\t\t      : op_num;\n+      tree return_type = void_type_node, args = void_list_node;\n+      tree eltype;\n+\n+      /* Build a function type directly from the insn_data for this\n+\t builtin.  The build_function_type () function takes care of\n+\t removing duplicates for us.  */\n+      for (; op_num >= 0; arg_num--, op_num--)\n \t{\n-\tcase NEON_LOAD1:\n-\tcase NEON_LOAD1LANE:\n-\tcase NEON_LOADSTRUCT:\n-\tcase NEON_LOADSTRUCTLANE:\n-\t  is_load = 1;\n-\t  /* Fall through.  */\n-\tcase NEON_STORE1:\n-\tcase NEON_STORE1LANE:\n-\tcase NEON_STORESTRUCT:\n-\tcase NEON_STORESTRUCTLANE:\n-\t  if (!is_load)\n-\t    is_store = 1;\n-\t  /* Fall through.  */\n-\tcase NEON_UNOP:\n-\tcase NEON_RINT:\n-\tcase NEON_BINOP:\n-\tcase NEON_LOGICBINOP:\n-\tcase NEON_SHIFTINSERT:\n-\tcase NEON_TERNOP:\n-\tcase NEON_GETLANE:\n-\tcase NEON_SETLANE:\n-\tcase NEON_CREATE:\n-\tcase NEON_DUP:\n-\tcase NEON_DUPLANE:\n-\tcase NEON_SHIFTIMM:\n-\tcase NEON_SHIFTACC:\n-\tcase NEON_COMBINE:\n-\tcase NEON_SPLIT:\n-\tcase NEON_CONVERT:\n-\tcase NEON_FIXCONV:\n-\tcase NEON_LANEMUL:\n-\tcase NEON_LANEMULL:\n-\tcase NEON_LANEMULH:\n-\tcase NEON_LANEMAC:\n-\tcase NEON_SCALARMUL:\n-\tcase NEON_SCALARMULL:\n-\tcase NEON_SCALARMULH:\n-\tcase NEON_SCALARMAC:\n-\tcase NEON_SELECT:\n-\tcase NEON_VTBL:\n-\tcase NEON_VTBX:\n-\t  {\n-\t    int k;\n-\t    tree return_type = void_type_node, args = void_list_node;\n-\n-\t    /* Build a function type directly from the insn_data for\n-\t       this builtin.  The build_function_type() function takes\n-\t       care of removing duplicates for us.  */\n-\t    for (k = insn_data[d->code].n_generator_args - 1; k >= 0; k--)\n-\t      {\n-\t\ttree eltype;\n-\n-\t\tif (is_load && k == 1)\n-\t\t  {\n-\t\t    /* Neon load patterns always have the memory\n-\t\t       operand in the operand 1 position.  */\n-\t\t    gcc_assert (insn_data[d->code].operand[k].predicate\n-\t\t\t\t== neon_struct_operand);\n-\n-\t\t    switch (d->mode)\n-\t\t      {\n-\t\t      case T_V8QI:\n-\t\t      case T_V16QI:\n-\t\t\teltype = const_intQI_pointer_node;\n-\t\t\tbreak;\n-\n-\t\t      case T_V4HI:\n-\t\t      case T_V8HI:\n-\t\t\teltype = const_intHI_pointer_node;\n-\t\t\tbreak;\n-\n-\t\t      case T_V2SI:\n-\t\t      case T_V4SI:\n-\t\t\teltype = const_intSI_pointer_node;\n-\t\t\tbreak;\n-\n-\t\t      case T_V2SF:\n-\t\t      case T_V4SF:\n-\t\t\teltype = const_float_pointer_node;\n-\t\t\tbreak;\n-\n-\t\t      case T_DI:\n-\t\t      case T_V2DI:\n-\t\t\teltype = const_intDI_pointer_node;\n-\t\t\tbreak;\n-\n-\t\t      default: gcc_unreachable ();\n-\t\t      }\n-\t\t  }\n-\t\telse if (is_store && k == 0)\n-\t\t  {\n-\t\t    /* Similarly, Neon store patterns use operand 0 as\n-\t\t       the memory location to store to.  */\n-\t\t    gcc_assert (insn_data[d->code].operand[k].predicate\n-\t\t\t\t== neon_struct_operand);\n-\n-\t\t    switch (d->mode)\n-\t\t      {\n-\t\t      case T_V8QI:\n-\t\t      case T_V16QI:\n-\t\t\teltype = intQI_pointer_node;\n-\t\t\tbreak;\n-\n-\t\t      case T_V4HI:\n-\t\t      case T_V8HI:\n-\t\t\teltype = intHI_pointer_node;\n-\t\t\tbreak;\n-\n-\t\t      case T_V2SI:\n-\t\t      case T_V4SI:\n-\t\t\teltype = intSI_pointer_node;\n-\t\t\tbreak;\n-\n-\t\t      case T_V2SF:\n-\t\t      case T_V4SF:\n-\t\t\teltype = float_pointer_node;\n-\t\t\tbreak;\n-\n-\t\t      case T_DI:\n-\t\t      case T_V2DI:\n-\t\t\teltype = intDI_pointer_node;\n-\t\t\tbreak;\n-\n-\t\t      default: gcc_unreachable ();\n-\t\t      }\n-\t\t  }\n-\t\telse\n-\t\t  {\n-\t\t    switch (insn_data[d->code].operand[k].mode)\n-\t\t      {\n-\t\t      case VOIDmode: eltype = void_type_node; break;\n-\t\t\t/* Scalars.  */\n-\t\t      case QImode: eltype = neon_intQI_type_node; break;\n-\t\t      case HImode: eltype = neon_intHI_type_node; break;\n-\t\t      case SImode: eltype = neon_intSI_type_node; break;\n-\t\t      case SFmode: eltype = neon_float_type_node; break;\n-\t\t      case DImode: eltype = neon_intDI_type_node; break;\n-\t\t      case TImode: eltype = intTI_type_node; break;\n-\t\t      case EImode: eltype = intEI_type_node; break;\n-\t\t      case OImode: eltype = intOI_type_node; break;\n-\t\t      case CImode: eltype = intCI_type_node; break;\n-\t\t      case XImode: eltype = intXI_type_node; break;\n-\t\t\t/* 64-bit vectors.  */\n-\t\t      case V8QImode: eltype = V8QI_type_node; break;\n-\t\t      case V4HImode: eltype = V4HI_type_node; break;\n-\t\t      case V2SImode: eltype = V2SI_type_node; break;\n-\t\t      case V2SFmode: eltype = V2SF_type_node; break;\n-\t\t\t/* 128-bit vectors.  */\n-\t\t      case V16QImode: eltype = V16QI_type_node; break;\n-\t\t      case V8HImode: eltype = V8HI_type_node; break;\n-\t\t      case V4SImode: eltype = V4SI_type_node; break;\n-\t\t      case V4SFmode: eltype = V4SF_type_node; break;\n-\t\t      case V2DImode: eltype = V2DI_type_node; break;\n-\t\t      default: gcc_unreachable ();\n-\t\t      }\n-\t\t  }\n-\n-\t\tif (k == 0 && !is_store)\n-\t\t  return_type = eltype;\n-\t\telse\n-\t\t  args = tree_cons (NULL_TREE, eltype, args);\n-\t      }\n-\n-\t    ftype = build_function_type (return_type, args);\n-\t  }\n-\t  break;\n-\n-\tcase NEON_REINTERP:\n-\t  {\n-\t    /* We iterate over NUM_DREG_TYPES doubleword types,\n-\t       then NUM_QREG_TYPES quadword  types.\n-\t       V4HF is not a type used in reinterpret, so we translate\n-\t       d->mode to the correct index in reinterp_ftype_dreg.  */\n-\t    bool qreg_p\n-\t      = GET_MODE_SIZE (insn_data[d->code].operand[0].mode) > 8;\n-\t    int rhs = (d->mode - ((!qreg_p && (d->mode > T_V4HF)) ? 1 : 0))\n-\t              % NUM_QREG_TYPES;\n-\t    switch (insn_data[d->code].operand[0].mode)\n-\t      {\n-\t      case V8QImode: ftype = reinterp_ftype_dreg[0][rhs]; break;\n-\t      case V4HImode: ftype = reinterp_ftype_dreg[1][rhs]; break;\n-\t      case V2SImode: ftype = reinterp_ftype_dreg[2][rhs]; break;\n-\t      case V2SFmode: ftype = reinterp_ftype_dreg[3][rhs]; break;\n-\t      case DImode: ftype = reinterp_ftype_dreg[4][rhs]; break;\n-\t      case V16QImode: ftype = reinterp_ftype_qreg[0][rhs]; break;\n-\t      case V8HImode: ftype = reinterp_ftype_qreg[1][rhs]; break;\n-\t      case V4SImode: ftype = reinterp_ftype_qreg[2][rhs]; break;\n-\t      case V4SFmode: ftype = reinterp_ftype_qreg[3][rhs]; break;\n-\t      case V2DImode: ftype = reinterp_ftype_qreg[4][rhs]; break;\n-\t      case TImode: ftype = reinterp_ftype_qreg[5][rhs]; break;\n-\t      default: gcc_unreachable ();\n-\t      }\n-\t  }\n-\t  break;\n-\tcase NEON_FLOAT_WIDEN:\n-\t  {\n-\t    tree eltype = NULL_TREE;\n-\t    tree return_type = NULL_TREE;\n+\t  machine_mode op_mode = insn_data[d->code].operand[op_num].mode;\n+\t  enum arm_type_qualifiers qualifiers = d->qualifiers[arg_num];\n \n-\t    switch (insn_data[d->code].operand[1].mode)\n+\t  if (qualifiers & qualifier_unsigned)\n \t    {\n-\t      case V4HFmode:\n-\t        eltype = V4HF_type_node;\n-\t        return_type = V4SF_type_node;\n-\t        break;\n-\t      default: gcc_unreachable ();\n+\t      type_signature[arg_num] = 'u';\n+\t      print_type_signature_p = true;\n \t    }\n-\t    ftype = build_function_type_list (return_type, eltype, NULL);\n-\t    break;\n-\t  }\n-\tcase NEON_FLOAT_NARROW:\n-\t  {\n-\t    tree eltype = NULL_TREE;\n-\t    tree return_type = NULL_TREE;\n-\n-\t    switch (insn_data[d->code].operand[1].mode)\n+\t  else if (qualifiers & qualifier_poly)\n \t    {\n-\t      case V4SFmode:\n-\t        eltype = V4SF_type_node;\n-\t        return_type = V4HF_type_node;\n-\t        break;\n-\t      default: gcc_unreachable ();\n+\t      type_signature[arg_num] = 'p';\n+\t      print_type_signature_p = true;\n \t    }\n-\t    ftype = build_function_type_list (return_type, eltype, NULL);\n-\t    break;\n-\t  }\n-\tcase NEON_BSWAP:\n-\t{\n-\t    tree eltype = NULL_TREE;\n-\t    switch (insn_data[d->code].operand[1].mode)\n-\t    {\n-\t      case V4HImode:\n-\t        eltype = V4UHI_type_node;\n-\t        break;\n-\t      case V8HImode:\n-\t        eltype = V8UHI_type_node;\n-\t        break;\n-\t      case V2SImode:\n-\t        eltype = V2USI_type_node;\n-\t        break;\n-\t      case V4SImode:\n-\t        eltype = V4USI_type_node;\n-\t        break;\n-\t      case V2DImode:\n-\t        eltype = V2UDI_type_node;\n-\t        break;\n-\t      default: gcc_unreachable ();\n-\t    }\n-\t    ftype = build_function_type_list (eltype, eltype, NULL);\n-\t    break;\n-\t}\n-\tcase NEON_COPYSIGNF:\n-\t  {\n-\t    tree eltype = NULL_TREE;\n-\t    switch (insn_data[d->code].operand[1].mode)\n-\t      {\n-\t      case V2SFmode:\n-\t\teltype = V2SF_type_node;\n-\t\tbreak;\n-\t      case V4SFmode:\n-\t\teltype = V4SF_type_node;\n-\t\tbreak;\n-\t      default: gcc_unreachable ();\n-\t      }\n-\t    ftype = build_function_type_list (eltype, eltype, NULL);\n-\t    break;\n-\t  }\n-\tdefault:\n-\t  gcc_unreachable ();\n+\t  else\n+\t    type_signature[arg_num] = 's';\n+\n+\t  /* Skip an internal operand for vget_{low, high}.  */\n+\t  if (qualifiers & qualifier_internal)\n+\t    continue;\n+\n+\t  /* Some builtins have different user-facing types\n+\t     for certain arguments, encoded in d->mode.  */\n+\t  if (qualifiers & qualifier_map_mode)\n+\t      op_mode = modes[d->mode];\n+\n+\t  /* For pointers, we want a pointer to the basic type\n+\t     of the vector.  */\n+\t  if (qualifiers & qualifier_pointer && VECTOR_MODE_P (op_mode))\n+\t    op_mode = GET_MODE_INNER (op_mode);\n+\n+\t  eltype = arm_simd_builtin_type\n+\t\t     (op_mode,\n+\t\t      (qualifiers & qualifier_unsigned) != 0,\n+\t\t      (qualifiers & qualifier_poly) != 0);\n+\t  gcc_assert (eltype != NULL);\n+\n+\t  /* Add qualifiers.  */\n+\t  if (qualifiers & qualifier_const)\n+\t    eltype = build_qualified_type (eltype, TYPE_QUAL_CONST);\n+\n+\t  if (qualifiers & qualifier_pointer)\n+\t      eltype = build_pointer_type (eltype);\n+\n+\t  /* If we have reached arg_num == 0, we are at a non-void\n+\t     return type.  Otherwise, we are still processing\n+\t     arguments.  */\n+\t  if (arg_num == 0)\n+\t    return_type = eltype;\n+\t  else\n+\t    args = tree_cons (NULL_TREE, eltype, args);\n \t}\n \n+      ftype = build_function_type (return_type, args);\n+\n       gcc_assert (ftype != NULL);\n \n-      sprintf (namebuf, \"__builtin_neon_%s%s\", d->name, modenames[d->mode]);\n+      if (print_type_signature_p)\n+\tsnprintf (namebuf, sizeof (namebuf), \"__builtin_neon_%s%s_%s\",\n+\t\t  d->name, modenames[d->mode], type_signature);\n+      else\n+\tsnprintf (namebuf, sizeof (namebuf), \"__builtin_neon_%s%s\",\n+\t\t  d->name, modenames[d->mode]);\n+\n+      fndecl = add_builtin_function (namebuf, ftype, fcode, BUILT_IN_MD,\n+\t\t\t\t     NULL, NULL_TREE);\n+      arm_builtin_decls[fcode] = fndecl;\n+    }\n \n-      decl = add_builtin_function (namebuf, ftype, fcode, BUILT_IN_MD, NULL,\n-\t\t\t\t   NULL_TREE);\n-      arm_builtin_decls[fcode] = decl;\n+  if (TARGET_CRYPTO && TARGET_HARD_FLOAT)\n+    {\n+      tree V16UQI_type_node = arm_simd_builtin_type (V16QImode,\n+\t\t\t\t\t\t       true,\n+\t\t\t\t\t\t       false);\n+\n+      tree V4USI_type_node = arm_simd_builtin_type (V4SImode,\n+\t\t\t\t\t\t      true,\n+\t\t\t\t\t\t      false);\n+\n+      tree v16uqi_ftype_v16uqi\n+\t= build_function_type_list (V16UQI_type_node, V16UQI_type_node,\n+\t\t\t\t    NULL_TREE);\n+\n+      tree v16uqi_ftype_v16uqi_v16uqi\n+\t= build_function_type_list (V16UQI_type_node, V16UQI_type_node,\n+\t\t\t\t    V16UQI_type_node, NULL_TREE);\n+\n+      tree v4usi_ftype_v4usi\n+\t= build_function_type_list (V4USI_type_node, V4USI_type_node,\n+\t\t\t\t    NULL_TREE);\n+\n+      tree v4usi_ftype_v4usi_v4usi\n+\t= build_function_type_list (V4USI_type_node, V4USI_type_node,\n+\t\t\t\t    V4USI_type_node, NULL_TREE);\n+\n+      tree v4usi_ftype_v4usi_v4usi_v4usi\n+\t= build_function_type_list (V4USI_type_node, V4USI_type_node,\n+\t\t\t\t    V4USI_type_node, V4USI_type_node,\n+\t\t\t\t    NULL_TREE);\n+\n+      tree uti_ftype_udi_udi\n+\t= build_function_type_list (unsigned_intTI_type_node,\n+\t\t\t\t    unsigned_intDI_type_node,\n+\t\t\t\t    unsigned_intDI_type_node,\n+\t\t\t\t    NULL_TREE);\n+\n+      #undef CRYPTO1\n+      #undef CRYPTO2\n+      #undef CRYPTO3\n+      #undef C\n+      #undef N\n+      #undef CF\n+      #undef FT1\n+      #undef FT2\n+      #undef FT3\n+\n+      #define C(U) \\\n+\tARM_BUILTIN_CRYPTO_##U\n+      #define N(L) \\\n+\t\"__builtin_arm_crypto_\"#L\n+      #define FT1(R, A) \\\n+\tR##_ftype_##A\n+      #define FT2(R, A1, A2) \\\n+\tR##_ftype_##A1##_##A2\n+      #define FT3(R, A1, A2, A3) \\\n+        R##_ftype_##A1##_##A2##_##A3\n+      #define CRYPTO1(L, U, R, A) \\\n+\tarm_builtin_decls[C (U)] \\\n+\t  = add_builtin_function (N (L), FT1 (R, A), \\\n+\t\t\t\t  C (U), BUILT_IN_MD, NULL, NULL_TREE);\n+      #define CRYPTO2(L, U, R, A1, A2)  \\\n+\tarm_builtin_decls[C (U)]\t\\\n+\t  = add_builtin_function (N (L), FT2 (R, A1, A2), \\\n+\t\t\t\t  C (U), BUILT_IN_MD, NULL, NULL_TREE);\n+\n+      #define CRYPTO3(L, U, R, A1, A2, A3) \\\n+\tarm_builtin_decls[C (U)]\t   \\\n+\t  = add_builtin_function (N (L), FT3 (R, A1, A2, A3), \\\n+\t\t\t\t  C (U), BUILT_IN_MD, NULL, NULL_TREE);\n+      #include \"crypto.def\"\n+\n+      #undef CRYPTO1\n+      #undef CRYPTO2\n+      #undef CRYPTO3\n+      #undef C\n+      #undef N\n+      #undef FT1\n+      #undef FT2\n+      #undef FT3\n     }\n }\n "}, {"sha": "20cfa9f715e8695fc2bfb4371bb3019fc20d32fb", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6276b63014a37a17a67724f1e6bbd8b0b0b31fff/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6276b63014a37a17a67724f1e6bbd8b0b0b31fff/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=6276b63014a37a17a67724f1e6bbd8b0b0b31fff", "patch": "@@ -225,6 +225,7 @@ extern void arm_pr_long_calls_off (struct cpp_reader *);\n extern void arm_lang_object_attributes_init(void);\n \n extern const char *arm_mangle_type (const_tree);\n+extern const char *arm_mangle_builtin_type (const_tree);\n \n extern void arm_order_regs_for_local_alloc (void);\n "}, {"sha": "7360e268bf8507f975b3cff7c6078a046cde3954", "filename": "gcc/config/arm/arm-simd-builtin-types.def", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6276b63014a37a17a67724f1e6bbd8b0b0b31fff/gcc%2Fconfig%2Farm%2Farm-simd-builtin-types.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6276b63014a37a17a67724f1e6bbd8b0b0b31fff/gcc%2Fconfig%2Farm%2Farm-simd-builtin-types.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-simd-builtin-types.def?ref=6276b63014a37a17a67724f1e6bbd8b0b0b31fff", "patch": "@@ -0,0 +1,48 @@\n+/* Builtin AdvSIMD types.\n+   Copyright (C) 2014 Free Software Foundation, Inc.\n+   Contributed by ARM Ltd.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+  ENTRY (Int8x8_t, V8QI, none, 64, int8, 15)\n+  ENTRY (Int16x4_t, V4HI, none, 64, int16, 16)\n+  ENTRY (Int32x2_t, V2SI, none, 64, int32, 16)\n+\n+  ENTRY (Int8x16_t, V16QI, none, 128, int8, 16)\n+  ENTRY (Int16x8_t, V8HI, none, 128, int16, 17)\n+  ENTRY (Int32x4_t, V4SI, none, 128, int32, 17)\n+  ENTRY (Int64x2_t, V2DI, none, 128, int64, 17)\n+\n+  ENTRY (Uint8x8_t, V8QI, unsigned, 64, uint8, 16)\n+  ENTRY (Uint16x4_t, V4HI, unsigned, 64, uint16, 17)\n+  ENTRY (Uint32x2_t, V2SI, unsigned, 64, uint32, 17)\n+\n+  ENTRY (Uint8x16_t, V16QI, unsigned, 128, uint8, 17)\n+  ENTRY (Uint16x8_t, V8HI, unsigned, 128, uint16, 18)\n+  ENTRY (Uint32x4_t, V4SI, unsigned, 128, uint32, 18)\n+  ENTRY (Uint64x2_t, V2DI, unsigned, 128, uint64, 18)\n+\n+  ENTRY (Poly8x8_t, V8QI, poly, 64, poly8, 16)\n+  ENTRY (Poly16x4_t, V4HI, poly, 64, poly16, 17)\n+\n+  ENTRY (Poly8x16_t, V16QI, poly, 128, poly8, 17)\n+  ENTRY (Poly16x8_t, V8HI, poly, 128, poly16, 18)\n+\n+  ENTRY (Float16x4_t, V4HF, none, 64, float16, 18)\n+  ENTRY (Float32x2_t, V2SF, none, 64, float32, 18)\n+  ENTRY (Float32x4_t, V4SF, none, 128, float32, 19)\n+"}, {"sha": "e37465e98ca1a05430c89361d9d10ef22b1556ae", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 5, "deletions": 60, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6276b63014a37a17a67724f1e6bbd8b0b0b31fff/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6276b63014a37a17a67724f1e6bbd8b0b0b31fff/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=6276b63014a37a17a67724f1e6bbd8b0b0b31fff", "patch": "@@ -27080,50 +27080,9 @@ arm_issue_rate (void)\n     }\n }\n \n-/* A table and a function to perform ARM-specific name mangling for\n-   NEON vector types in order to conform to the AAPCS (see \"Procedure\n-   Call Standard for the ARM Architecture\", Appendix A).  To qualify\n-   for emission with the mangled names defined in that document, a\n-   vector type must not only be of the correct mode but also be\n-   composed of NEON vector element types (e.g. __builtin_neon_qi).  */\n-typedef struct\n-{\n-  machine_mode mode;\n-  const char *element_type_name;\n-  const char *aapcs_name;\n-} arm_mangle_map_entry;\n-\n-static arm_mangle_map_entry arm_mangle_map[] = {\n-  /* 64-bit containerized types.  */\n-  { V8QImode,  \"__builtin_neon_qi\",     \"15__simd64_int8_t\" },\n-  { V8QImode,  \"__builtin_neon_uqi\",    \"16__simd64_uint8_t\" },\n-  { V4HImode,  \"__builtin_neon_hi\",     \"16__simd64_int16_t\" },\n-  { V4HImode,  \"__builtin_neon_uhi\",    \"17__simd64_uint16_t\" },\n-  { V4HFmode,  \"__builtin_neon_hf\",     \"18__simd64_float16_t\" },\n-  { V2SImode,  \"__builtin_neon_si\",     \"16__simd64_int32_t\" },\n-  { V2SImode,  \"__builtin_neon_usi\",    \"17__simd64_uint32_t\" },\n-  { V2SFmode,  \"__builtin_neon_sf\",     \"18__simd64_float32_t\" },\n-  { V8QImode,  \"__builtin_neon_poly8\",  \"16__simd64_poly8_t\" },\n-  { V4HImode,  \"__builtin_neon_poly16\", \"17__simd64_poly16_t\" },\n-\n-  /* 128-bit containerized types.  */\n-  { V16QImode, \"__builtin_neon_qi\",     \"16__simd128_int8_t\" },\n-  { V16QImode, \"__builtin_neon_uqi\",    \"17__simd128_uint8_t\" },\n-  { V8HImode,  \"__builtin_neon_hi\",     \"17__simd128_int16_t\" },\n-  { V8HImode,  \"__builtin_neon_uhi\",    \"18__simd128_uint16_t\" },\n-  { V4SImode,  \"__builtin_neon_si\",     \"17__simd128_int32_t\" },\n-  { V4SImode,  \"__builtin_neon_usi\",    \"18__simd128_uint32_t\" },\n-  { V4SFmode,  \"__builtin_neon_sf\",     \"19__simd128_float32_t\" },\n-  { V16QImode, \"__builtin_neon_poly8\",  \"17__simd128_poly8_t\" },\n-  { V8HImode,  \"__builtin_neon_poly16\", \"18__simd128_poly16_t\" },\n-  { VOIDmode, NULL, NULL }\n-};\n-\n const char *\n arm_mangle_type (const_tree type)\n {\n-  arm_mangle_map_entry *pos = arm_mangle_map;\n-\n   /* The ARM ABI documents (10th October 2008) say that \"__va_list\"\n      has to be managled as if it is in the \"std\" namespace.  */\n   if (TARGET_AAPCS_BASED\n@@ -27134,26 +27093,12 @@ arm_mangle_type (const_tree type)\n   if (TREE_CODE (type) == REAL_TYPE && TYPE_PRECISION (type) == 16)\n     return \"Dh\";\n \n-  if (TREE_CODE (type) != VECTOR_TYPE)\n-    return NULL;\n-\n-  /* Check the mode of the vector type, and the name of the vector\n-     element type, against the table.  */\n-  while (pos->mode != VOIDmode)\n-    {\n-      tree elt_type = TREE_TYPE (type);\n-\n-      if (pos->mode == TYPE_MODE (type)\n-\t  && TREE_CODE (TYPE_NAME (elt_type)) == TYPE_DECL\n-\t  && !strcmp (IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (elt_type))),\n-\t\t      pos->element_type_name))\n-        return pos->aapcs_name;\n-\n-      pos++;\n-    }\n+  /* Try mangling as a Neon type, TYPE_NAME is non-NULL if this is a\n+     builtin type.  */\n+  if (TYPE_NAME (type) != NULL)\n+    return arm_mangle_builtin_type (type);\n \n-  /* Use the default mangling for unrecognized (possibly user-defined)\n-     vector types.  */\n+  /* Use the default mangling.  */\n   return NULL;\n }\n "}, {"sha": "e58b772ee29f910a344d2d3a5be5a7818a79af64", "filename": "gcc/config/arm/arm_neon.h", "status": "modified", "additions": 27, "deletions": 22, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6276b63014a37a17a67724f1e6bbd8b0b0b31fff/gcc%2Fconfig%2Farm%2Farm_neon.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6276b63014a37a17a67724f1e6bbd8b0b0b31fff/gcc%2Fconfig%2Farm%2Farm_neon.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm_neon.h?ref=6276b63014a37a17a67724f1e6bbd8b0b0b31fff", "patch": "@@ -37,37 +37,42 @@ extern \"C\" {\n \n #include <stdint.h>\n \n-typedef __builtin_neon_qi int8x8_t\t__attribute__ ((__vector_size__ (8)));\n-typedef __builtin_neon_hi int16x4_t\t__attribute__ ((__vector_size__ (8)));\n-typedef __builtin_neon_si int32x2_t\t__attribute__ ((__vector_size__ (8)));\n+typedef __simd64_int8_t int8x8_t;\n+typedef __simd64_int16_t int16x4_t;\n+typedef __simd64_int32_t int32x2_t;\n typedef __builtin_neon_di int64x1_t;\n-typedef __builtin_neon_hf float16x4_t\t__attribute__ ((__vector_size__ (8)));\n-typedef __builtin_neon_sf float32x2_t\t__attribute__ ((__vector_size__ (8)));\n-typedef __builtin_neon_poly8 poly8x8_t\t__attribute__ ((__vector_size__ (8)));\n-typedef __builtin_neon_poly16 poly16x4_t\t__attribute__ ((__vector_size__ (8)));\n+typedef __simd64_float16_t float16x4_t;\n+typedef __simd64_float32_t float32x2_t;\n+typedef __simd64_poly8_t poly8x8_t;\n+typedef __simd64_poly16_t poly16x4_t;\n #ifdef __ARM_FEATURE_CRYPTO\n typedef __builtin_neon_poly64 poly64x1_t;\n #endif\n-typedef __builtin_neon_uqi uint8x8_t\t__attribute__ ((__vector_size__ (8)));\n-typedef __builtin_neon_uhi uint16x4_t\t__attribute__ ((__vector_size__ (8)));\n-typedef __builtin_neon_usi uint32x2_t\t__attribute__ ((__vector_size__ (8)));\n+typedef __simd64_uint8_t uint8x8_t;\n+typedef __simd64_uint16_t uint16x4_t;\n+typedef __simd64_uint32_t uint32x2_t;\n typedef __builtin_neon_udi uint64x1_t;\n-typedef __builtin_neon_qi int8x16_t\t__attribute__ ((__vector_size__ (16)));\n-typedef __builtin_neon_hi int16x8_t\t__attribute__ ((__vector_size__ (16)));\n-typedef __builtin_neon_si int32x4_t\t__attribute__ ((__vector_size__ (16)));\n-typedef __builtin_neon_di int64x2_t\t__attribute__ ((__vector_size__ (16)));\n-typedef __builtin_neon_sf float32x4_t\t__attribute__ ((__vector_size__ (16)));\n-typedef __builtin_neon_poly8 poly8x16_t\t__attribute__ ((__vector_size__ (16)));\n-typedef __builtin_neon_poly16 poly16x8_t\t__attribute__ ((__vector_size__ (16)));\n+\n+typedef __simd128_int8_t int8x16_t;\n+typedef __simd128_int16_t int16x8_t;\n+typedef __simd128_int32_t int32x4_t;\n+typedef __simd128_int64_t int64x2_t;\n+typedef __simd128_float32_t float32x4_t;\n+typedef __simd128_poly8_t poly8x16_t;\n+typedef __simd128_poly16_t poly16x8_t;\n #ifdef __ARM_FEATURE_CRYPTO\n-typedef __builtin_neon_poly64 poly64x2_t\t__attribute__ ((__vector_size__ (16)));\n+typedef __builtin_neon_poly64 poly64x2_t __attribute__ ((__vector_size__ (16)));\n #endif\n-typedef __builtin_neon_uqi uint8x16_t\t__attribute__ ((__vector_size__ (16)));\n-typedef __builtin_neon_uhi uint16x8_t\t__attribute__ ((__vector_size__ (16)));\n-typedef __builtin_neon_usi uint32x4_t\t__attribute__ ((__vector_size__ (16)));\n-typedef __builtin_neon_udi uint64x2_t\t__attribute__ ((__vector_size__ (16)));\n+\n+typedef __simd128_uint8_t uint8x16_t;\n+typedef __simd128_uint16_t uint16x8_t;\n+typedef __simd128_uint32_t uint32x4_t;\n+typedef __simd128_uint64_t uint64x2_t;\n \n typedef float float32_t;\n+\n+/* The Poly types are user visible and live in their own world,\n+   keep them that way.  */\n typedef __builtin_neon_poly8 poly8_t;\n typedef __builtin_neon_poly16 poly16_t;\n #ifdef __ARM_FEATURE_CRYPTO"}, {"sha": "d82a123c7b5fe2b070e0a55928a7061a7f3bb80d", "filename": "gcc/config/arm/t-arm", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6276b63014a37a17a67724f1e6bbd8b0b0b31fff/gcc%2Fconfig%2Farm%2Ft-arm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6276b63014a37a17a67724f1e6bbd8b0b0b31fff/gcc%2Fconfig%2Farm%2Ft-arm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ft-arm?ref=6276b63014a37a17a67724f1e6bbd8b0b0b31fff", "patch": "@@ -100,7 +100,8 @@ arm-builtins.o: $(srcdir)/config/arm/arm-builtins.c $(CONFIG_H) \\\n   $(RTL_H) $(TREE_H) expr.h $(TM_P_H) $(RECOG_H) langhooks.h \\\n   $(DIAGNOSTIC_CORE_H) $(OPTABS_H) \\\n   $(srcdir)/config/arm/arm-protos.h \\\n-  $(srcdir)/config/arm/arm_neon_builtins.def\n+  $(srcdir)/config/arm/arm_neon_builtins.def \\\n+  $(srcdir)/config/arm/arm-simd-builtin-types.def\n \t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n \t\t$(srcdir)/config/arm/arm-builtins.c\n "}]}