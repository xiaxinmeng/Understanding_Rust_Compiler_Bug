{"sha": "a7cadd18606c9c3ce2776b6f876ca98849b24b84", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTdjYWRkMTg2MDZjOWMzY2UyNzc2YjZmODc2Y2E5ODg0OWIyNGI4NA==", "commit": {"author": {"name": "Bob Duff", "email": "duff@adacore.com", "date": "2021-02-25T15:38:55Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-06-15T10:19:16Z"}, "message": "[Ada] Variable-sized node types -- cleanup\n\ngcc/ada/\n\n\t* atree.ads, einfo-utils.ads, einfo-utils.adb, fe.h, gen_il.adb,\n\tgen_il.ads, gen_il-gen-gen_entities.adb,\n\tgen_il-gen-gen_nodes.adb, sem_ch12.adb, sem_ch3.adb,\n\tsem_util.adb, sinfo-utils.ads, treepr.adb, types.ads: Clean up\n\t??? comments and other comments.\n\t* atree.adb: Clean up ??? comments and other comments.\n\t(Validate_Node): Fix bug: \"Off_0 (N) < Off_L (N)\"\n\tshould be \"Off_0 (N) <= Off_L (N)\".\n\t* gen_il-gen.adb, gen_il-gen.ads: Clean up ???\n\tcomments and other comments.  Add support for getter-specific\n\tand setter-specific preconditions.  Detect the error of putting\n\ta field in the wrong subrange.  Misc cleanup.\n\t(Node_Field vs. Entity_Field): Clean up Nmake.  Improve\n\tcomments.\n\t* gen_il-utils.ads: Misc cleanup. Move...\n\t* gen_il-internals.ads: ... here.\n\t* gen_il-utils.adb: Misc cleanup. Move...\n\t* gen_il-internals.adb: ... here.\n\t* gen_il-fields.ads: Move Was_Default_Init_Box_Association,\n\twhich was in the wrong subrange.  Add comments.  Misc cleanup.\n\t* gen_il-types.ads: Add Named_Access_Kind.\n\t* sinfo-cn.adb: Clean up ??? comments and other comments.\n\tRemove redundant assertions.\n\t* einfo.ads, sinfo.ads: Clean up ??? comments and other\n\tcomments.  Remove all the comments indicating field offsets.\n\tThese are obsolete now that Gen_IL computes the offsets\n\tautomatically.", "tree": {"sha": "73551a1fc7c4fa7738d96349db729d5d2e805f3f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/73551a1fc7c4fa7738d96349db729d5d2e805f3f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a7cadd18606c9c3ce2776b6f876ca98849b24b84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7cadd18606c9c3ce2776b6f876ca98849b24b84", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7cadd18606c9c3ce2776b6f876ca98849b24b84", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7cadd18606c9c3ce2776b6f876ca98849b24b84/comments", "author": {"login": "bobduff", "id": 29099567, "node_id": "MDQ6VXNlcjI5MDk5NTY3", "avatar_url": "https://avatars.githubusercontent.com/u/29099567?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobduff", "html_url": "https://github.com/bobduff", "followers_url": "https://api.github.com/users/bobduff/followers", "following_url": "https://api.github.com/users/bobduff/following{/other_user}", "gists_url": "https://api.github.com/users/bobduff/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobduff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobduff/subscriptions", "organizations_url": "https://api.github.com/users/bobduff/orgs", "repos_url": "https://api.github.com/users/bobduff/repos", "events_url": "https://api.github.com/users/bobduff/events{/privacy}", "received_events_url": "https://api.github.com/users/bobduff/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "81e68a1954366f6b1730d75c932814121d743aa3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81e68a1954366f6b1730d75c932814121d743aa3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81e68a1954366f6b1730d75c932814121d743aa3"}], "stats": {"total": 9026, "additions": 4576, "deletions": 4450}, "files": [{"sha": "8df2d7fc988521a4534575a39204ed4b51504d70", "filename": "gcc/ada/atree.adb", "status": "modified", "additions": 178, "deletions": 145, "changes": 323, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7cadd18606c9c3ce2776b6f876ca98849b24b84/gcc%2Fada%2Fatree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7cadd18606c9c3ce2776b6f876ca98849b24b84/gcc%2Fada%2Fatree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.adb?ref=a7cadd18606c9c3ce2776b6f876ca98849b24b84", "patch": "@@ -156,12 +156,12 @@ package body Atree is\n    pragma Inline (Report);\n    --  Invoke the reporting procedure if available\n \n-   function Size_In_Slots (N : Node_Or_Entity_Id) return Field_Offset;\n+   function Size_In_Slots (N : Node_Or_Entity_Id) return Slot_Count;\n    --  Number of slots belonging to N. This can be less than\n    --  Size_In_Slots_To_Alloc for entities.\n \n-   function Size_In_Slots_To_Alloc (N : Node_Or_Entity_Id) return Field_Offset;\n-   function Size_In_Slots_To_Alloc (Kind : Node_Kind) return Field_Offset;\n+   function Size_In_Slots_To_Alloc (N : Node_Or_Entity_Id) return Slot_Count;\n+   function Size_In_Slots_To_Alloc (Kind : Node_Kind) return Slot_Count;\n    --  Number of slots to allocate for a node or entity. For entities, we have\n    --  to allocate the max, because we don't know the Ekind when this is\n    --  called.\n@@ -172,37 +172,42 @@ package body Atree is\n    function Off_L (N : Node_Id) return Node_Offset;\n    --  Offset of the last slot of N in Slots.Table\n \n-   procedure Zero_Slots (F, L : Node_Offset) with Inline;\n+   procedure Zero_Slots (First, Last : Node_Offset) with Inline;\n    --  Set slots in the range F..L to zero\n \n    procedure Zero_Slots (N : Node_Or_Entity_Id) with Inline;\n    --  Zero the slots belonging to N\n \n-   procedure Copy_Slots (From, To, Num_Slots : Node_Offset) with Inline;\n-   --  Copy Num_Slots slots from From to To\n+   procedure Copy_Slots (From, To : Node_Offset; Num_Slots : Slot_Count)\n+     with Inline;\n+   --  Copy Num_Slots slots from From to To. Caller is responsible for ensuring\n+   --  that the Num_Slots at To are a reasonable place to copy to.\n \n    procedure Copy_Slots (Source, Destination : Node_Id) with Inline;\n-   --  Copies the slots of Source to Destination\n+   --  Copies the slots of Source to Destination; uses the node kind to\n+   --  determine the Num_Slots.\n \n    function Get_Field_Value\n-     (N : Node_Id; Field : Node_Field) return Field_32_Bit;\n-   --  Get any field value as a Field_32_Bit. If the field is smaller than 32\n-   --  bits, convert it to Field_32_Bit.\n+     (N : Node_Id; Field : Node_Field) return Field_Size_32_Bit;\n+   --  Get any field value as a Field_Size_32_Bit. If the field is smaller than\n+   --  32 bits, convert it to Field_Size_32_Bit. The Field must be present in\n+   --  the Nkind of N.\n \n    procedure Set_Field_Value\n-     (N : Node_Id; Field : Node_Field; Val : Field_32_Bit);\n-   --  Set any field value as a Field_32_Bit. If the field is smaller than 32\n-   --  bits, convert it from Field_32_Bit, and Val had better be small enough.\n+     (N : Node_Id; Field : Node_Field; Val : Field_Size_32_Bit);\n+   --  Set any field value as a Field_Size_32_Bit. If the field is smaller than\n+   --  32 bits, convert it from Field_Size_32_Bit, and Val had better be small\n+   --  enough. The Field must be present in the Nkind of N.\n \n    procedure Check_Vanishing_Fields\n      (Old_N : Node_Id; New_Kind : Node_Kind);\n    --  Called whenever Nkind is modified. Raises an exception if not all\n    --  vanishing fields are in their initial zero state.\n \n    function Get_Field_Value\n-     (N : Entity_Id; Field : Entity_Field) return Field_32_Bit;\n+     (N : Entity_Id; Field : Entity_Field) return Field_Size_32_Bit;\n    procedure Set_Field_Value\n-     (N : Entity_Id; Field : Entity_Field; Val : Field_32_Bit);\n+     (N : Entity_Id; Field : Entity_Field; Val : Field_Size_32_Bit);\n    procedure Check_Vanishing_Fields\n      (Old_N : Entity_Id; New_Kind : Entity_Kind);\n    --  Above are the same as the ones for nodes, but for entities\n@@ -213,17 +218,22 @@ package body Atree is\n    --  Mutate_Nkind.\n \n    procedure Mutate_Nkind\n-     (N : Node_Id; Val : Node_Kind; Old_Size : Field_Offset);\n+     (N : Node_Id; Val : Node_Kind; Old_Size : Slot_Count);\n    --  Called by the other Mutate_Nkind to do all the work. This is needed\n    --  because the call in Change_Node, which calls this one directly, happens\n    --  after zeroing N's slots, which destroys its Nkind, which prevents us\n    --  from properly computing Old_Size.\n \n    package Field_Checking is\n+      --  Functions for checking field access, used only in assertions\n+\n       function Field_Present\n         (Kind : Node_Kind; Field : Node_Field) return Boolean;\n       function Field_Present\n         (Kind : Entity_Kind; Field : Entity_Field) return Boolean;\n+      --  True if a node/entity of the given Kind has the given Field.\n+      --  Always True if assertions are disabled.\n+\n    end Field_Checking;\n \n    package body Field_Checking is\n@@ -240,47 +250,62 @@ package body Atree is\n \n       procedure Init_Tables;\n \n-      function Fields_Present (Kind : Node_Kind) return Node_Field_Set;\n-      function Fields_Present (Kind : Entity_Kind) return Entity_Field_Set;\n+      function Create_Node_Fields_Present\n+        (Kind : Node_Kind) return Node_Field_Set;\n+      function Create_Entity_Fields_Present\n+        (Kind : Entity_Kind) return Entity_Field_Set;\n       --  Computes the set of fields present in each Node/Entity Kind. Used to\n       --  initialize the above tables.\n \n-      --------------------\n-      -- Fields_Present --\n-      --------------------\n+      --------------------------------\n+      -- Create_Node_Fields_Present --\n+      --------------------------------\n \n-      function Fields_Present (Kind : Node_Kind) return Node_Field_Set is\n+      function Create_Node_Fields_Present\n+        (Kind : Node_Kind) return Node_Field_Set\n+      is\n          Result : Node_Field_Set := (others => False);\n       begin\n          for J in Node_Field_Table (Kind)'Range loop\n             Result (Node_Field_Table (Kind) (J)) := True;\n          end loop;\n \n          return Result;\n-      end Fields_Present;\n+      end Create_Node_Fields_Present;\n+\n+      --------------------------------\n+      -- Create_Entity_Fields_Present --\n+      --------------------------------\n \n-      function Fields_Present (Kind : Entity_Kind) return Entity_Field_Set is\n+      function Create_Entity_Fields_Present\n+        (Kind : Entity_Kind) return Entity_Field_Set\n+      is\n          Result : Entity_Field_Set := (others => False);\n       begin\n          for J in Entity_Field_Table (Kind)'Range loop\n             Result (Entity_Field_Table (Kind) (J)) := True;\n          end loop;\n \n          return Result;\n-      end Fields_Present;\n+      end Create_Entity_Fields_Present;\n+\n+      -----------------\n+      -- Init_Tables --\n+      -----------------\n \n       procedure Init_Tables is\n       begin\n          Node_Fields_Present := new Node_Field_Sets;\n \n          for Kind in Node_Kind loop\n-            Node_Fields_Present (Kind) := Fields_Present (Kind);\n+            Node_Fields_Present (Kind) := Create_Node_Fields_Present (Kind);\n          end loop;\n \n          Entity_Fields_Present := new Entity_Field_Sets;\n \n          for Kind in Entity_Kind loop\n-            Entity_Fields_Present (Kind) := Fields_Present (Kind);\n+            Entity_Fields_Present (Kind) :=\n+              Create_Entity_Fields_Present (Kind);\n          end loop;\n       end Init_Tables;\n \n@@ -347,7 +372,8 @@ package body Atree is\n       --  Asserts N is OK, and the Offset in slots is within N. Note that this\n       --  does not guarantee that the offset is valid, just that it's not past\n       --  the last slot. It could be pointing at unused bits within the node,\n-      --  or unused padding at the end.\n+      --  or unused padding at the end. The \"_Write\" version is used when we're\n+      --  about to modify the node.\n \n       procedure Validate_Node_And_Offset\n         (N : Node_Or_Entity_Id; Offset : Field_Offset) is\n@@ -384,7 +410,7 @@ package body Atree is\n \n             pragma Assert (N'Valid);\n             pragma Assert (N <= Node_Offsets.Last);\n-            pragma Assert (Off_0 (N) < Off_L (N));\n+            pragma Assert (Off_0 (N) <= Off_L (N));\n             pragma Assert (Off_L (N) <= Slots.Last);\n             pragma Assert (Nkind (N)'Valid);\n             pragma Assert (Nkind (N) /= N_Unused_At_End);\n@@ -393,15 +419,16 @@ package body Atree is\n                pragma Assert (Ekind (N)'Valid);\n             end if;\n \n-            if Nkind (N) in N_Attribute_Definition_Clause\n-                          | N_Has_Entity\n-                          | N_Aggregate\n-                          | N_Extension_Aggregate\n-                          | N_Selected_Component\n-                          | N_Use_Package_Clause\n-                          | N_Aspect_Specification\n-                          | N_Freeze_Entity\n-                          | N_Freeze_Generic_Entity\n+            if Nkind (N) in\n+                N_Aggregate\n+              | N_Attribute_Definition_Clause\n+              | N_Aspect_Specification\n+              | N_Extension_Aggregate\n+              | N_Freeze_Entity\n+              | N_Freeze_Generic_Entity\n+              | N_Has_Entity\n+              | N_Selected_Component\n+              | N_Use_Package_Clause\n             then\n                pragma Assert (Entity_Or_Associated_Node (N)'Valid);\n             end if;\n@@ -433,7 +460,7 @@ package body Atree is\n          return Node_Offsets.Last;\n       end Alloc_Node_Id;\n \n-      function Alloc_Slots (Num_Slots : Field_Offset) return Node_Offset is\n+      function Alloc_Slots (Num_Slots : Slot_Count) return Node_Offset is\n       begin\n          return Result : constant Node_Offset := Slots.Last + 1 do\n             Slots.Set_Last (Slots.Last + Num_Slots);\n@@ -445,7 +472,8 @@ package body Atree is\n       is\n          pragma Assert (Field_Type'Size = 1);\n \n-         function Cast is new Unchecked_Conversion (Field_1_Bit, Field_Type);\n+         function Cast is new\n+           Unchecked_Conversion (Field_Size_1_Bit, Field_Type);\n       begin\n          return Cast (Get_1_Bit_Val (N, Offset));\n       end Get_1_Bit_Field;\n@@ -455,7 +483,8 @@ package body Atree is\n       is\n          pragma Assert (Field_Type'Size = 2);\n \n-         function Cast is new Unchecked_Conversion (Field_2_Bit, Field_Type);\n+         function Cast is new\n+           Unchecked_Conversion (Field_Size_2_Bit, Field_Type);\n       begin\n          return Cast (Get_2_Bit_Val (N, Offset));\n       end Get_2_Bit_Field;\n@@ -465,7 +494,8 @@ package body Atree is\n       is\n          pragma Assert (Field_Type'Size = 4);\n \n-         function Cast is new Unchecked_Conversion (Field_4_Bit, Field_Type);\n+         function Cast is new\n+           Unchecked_Conversion (Field_Size_4_Bit, Field_Type);\n       begin\n          return Cast (Get_4_Bit_Val (N, Offset));\n       end Get_4_Bit_Field;\n@@ -475,7 +505,8 @@ package body Atree is\n       is\n          pragma Assert (Field_Type'Size = 8);\n \n-         function Cast is new Unchecked_Conversion (Field_8_Bit, Field_Type);\n+         function Cast is new\n+           Unchecked_Conversion (Field_Size_8_Bit, Field_Type);\n       begin\n          return Cast (Get_8_Bit_Val (N, Offset));\n       end Get_8_Bit_Field;\n@@ -485,7 +516,8 @@ package body Atree is\n       is\n          pragma Assert (Field_Type'Size = 32);\n \n-         function Cast is new Unchecked_Conversion (Field_32_Bit, Field_Type);\n+         function Cast is new\n+           Unchecked_Conversion (Field_Size_32_Bit, Field_Type);\n       begin\n          return Cast (Get_32_Bit_Val (N, Offset));\n       end Get_32_Bit_Field;\n@@ -496,7 +528,8 @@ package body Atree is\n          function Get_Field is new Get_32_Bit_Field (Field_Type) with Inline;\n       begin\n          --  If the field has not yet been set, it will be equal to zero.\n-         --  That is of the \"wrong\" type, so we fetch it as a Field_32_Bit.\n+         --  That is of the \"wrong\" type, so we fetch it as a\n+         --  Field_Size_32_Bit.\n \n          if Get_32_Bit_Val (N, Offset) = 0 then\n             return Default_Val;\n@@ -511,7 +544,8 @@ package body Atree is\n       is\n          pragma Assert (Field_Type'Size = 1);\n \n-         function Cast is new Unchecked_Conversion (Field_Type, Field_1_Bit);\n+         function Cast is new\n+           Unchecked_Conversion (Field_Type, Field_Size_1_Bit);\n       begin\n          Set_1_Bit_Val (N, Offset, Cast (Val));\n       end Set_1_Bit_Field;\n@@ -521,7 +555,8 @@ package body Atree is\n       is\n          pragma Assert (Field_Type'Size = 2);\n \n-         function Cast is new Unchecked_Conversion (Field_Type, Field_2_Bit);\n+         function Cast is new\n+           Unchecked_Conversion (Field_Type, Field_Size_2_Bit);\n       begin\n          Set_2_Bit_Val (N, Offset, Cast (Val));\n       end Set_2_Bit_Field;\n@@ -531,7 +566,8 @@ package body Atree is\n       is\n          pragma Assert (Field_Type'Size = 4);\n \n-         function Cast is new Unchecked_Conversion (Field_Type, Field_4_Bit);\n+         function Cast is new\n+           Unchecked_Conversion (Field_Type, Field_Size_4_Bit);\n       begin\n          Set_4_Bit_Val (N, Offset, Cast (Val));\n       end Set_4_Bit_Field;\n@@ -541,7 +577,8 @@ package body Atree is\n       is\n          pragma Assert (Field_Type'Size = 8);\n \n-         function Cast is new Unchecked_Conversion (Field_Type, Field_8_Bit);\n+         function Cast is new\n+           Unchecked_Conversion (Field_Type, Field_Size_8_Bit);\n       begin\n          Set_8_Bit_Val (N, Offset, Cast (Val));\n       end Set_8_Bit_Field;\n@@ -551,13 +588,14 @@ package body Atree is\n       is\n          pragma Assert (Field_Type'Size = 32);\n \n-         function Cast is new Unchecked_Conversion (Field_Type, Field_32_Bit);\n+         function Cast is new\n+           Unchecked_Conversion (Field_Type, Field_Size_32_Bit);\n       begin\n          Set_32_Bit_Val (N, Offset, Cast (Val));\n       end Set_32_Bit_Field;\n \n       function Get_1_Bit_Val\n-        (N : Node_Or_Entity_Id; Offset : Field_Offset) return Field_1_Bit\n+        (N : Node_Or_Entity_Id; Offset : Field_Offset) return Field_Size_1_Bit\n       is\n          --  We wish we were using packed arrays, but instead we're simulating\n          --  them with modular integers. L here (and elsewhere) is the 'Length\n@@ -569,11 +607,11 @@ package body Atree is\n          S : Slot renames Slots.Table (Node_Offsets.Table (N) + Offset / L);\n          V : constant Natural := Natural ((Offset mod L) * (Slot_Size / L));\n       begin\n-         return Field_1_Bit (Shift_Right (S, V) and 1);\n+         return Field_Size_1_Bit (Shift_Right (S, V) and 1);\n       end Get_1_Bit_Val;\n \n       function Get_2_Bit_Val\n-        (N : Node_Or_Entity_Id; Offset : Field_Offset) return Field_2_Bit\n+        (N : Node_Or_Entity_Id; Offset : Field_Offset) return Field_Size_2_Bit\n       is\n          L : constant Field_Offset := Slot_Size / 2;\n \n@@ -582,11 +620,11 @@ package body Atree is\n          S : Slot renames Slots.Table (Node_Offsets.Table (N) + Offset / L);\n          V : constant Natural := Natural ((Offset mod L) * (Slot_Size / L));\n       begin\n-         return Field_2_Bit (Shift_Right (S, V) and 3);\n+         return Field_Size_2_Bit (Shift_Right (S, V) and 3);\n       end Get_2_Bit_Val;\n \n       function Get_4_Bit_Val\n-        (N : Node_Or_Entity_Id; Offset : Field_Offset) return Field_4_Bit\n+        (N : Node_Or_Entity_Id; Offset : Field_Offset) return Field_Size_4_Bit\n       is\n          L : constant Field_Offset := Slot_Size / 4;\n \n@@ -595,11 +633,11 @@ package body Atree is\n          S : Slot renames Slots.Table (Node_Offsets.Table (N) + Offset / L);\n          V : constant Natural := Natural ((Offset mod L) * (Slot_Size / L));\n       begin\n-         return Field_4_Bit (Shift_Right (S, V) and 15);\n+         return Field_Size_4_Bit (Shift_Right (S, V) and 15);\n       end Get_4_Bit_Val;\n \n       function Get_8_Bit_Val\n-        (N : Node_Or_Entity_Id; Offset : Field_Offset) return Field_8_Bit\n+        (N : Node_Or_Entity_Id; Offset : Field_Offset) return Field_Size_8_Bit\n       is\n          L : constant Field_Offset := Slot_Size / 8;\n \n@@ -608,21 +646,21 @@ package body Atree is\n          S : Slot renames Slots.Table (Node_Offsets.Table (N) + Offset / L);\n          V : constant Natural := Natural ((Offset mod L) * (Slot_Size / L));\n       begin\n-         return Field_8_Bit (Shift_Right (S, V) and 255);\n+         return Field_Size_8_Bit (Shift_Right (S, V) and 255);\n       end Get_8_Bit_Val;\n \n       function Get_32_Bit_Val\n-        (N : Node_Or_Entity_Id; Offset : Field_Offset) return Field_32_Bit\n+        (N : Node_Or_Entity_Id; Offset : Field_Offset) return Field_Size_32_Bit\n       is\n          pragma Debug (Validate_Node_And_Offset (N, Offset));\n \n          S : Slot renames Slots.Table (Node_Offsets.Table (N) + Offset);\n       begin\n-         return Field_32_Bit (S);\n+         return Field_Size_32_Bit (S);\n       end Get_32_Bit_Val;\n \n       procedure Set_1_Bit_Val\n-        (N : Node_Or_Entity_Id; Offset : Field_Offset; Val : Field_1_Bit)\n+        (N : Node_Or_Entity_Id; Offset : Field_Offset; Val : Field_Size_1_Bit)\n       is\n          L : constant Field_Offset := Slot_Size / 1;\n \n@@ -635,7 +673,7 @@ package body Atree is\n       end Set_1_Bit_Val;\n \n       procedure Set_2_Bit_Val\n-        (N : Node_Or_Entity_Id; Offset : Field_Offset; Val : Field_2_Bit)\n+        (N : Node_Or_Entity_Id; Offset : Field_Offset; Val : Field_Size_2_Bit)\n       is\n          L : constant Field_Offset := Slot_Size / 2;\n \n@@ -648,7 +686,7 @@ package body Atree is\n       end Set_2_Bit_Val;\n \n       procedure Set_4_Bit_Val\n-        (N : Node_Or_Entity_Id; Offset : Field_Offset; Val : Field_4_Bit)\n+        (N : Node_Or_Entity_Id; Offset : Field_Offset; Val : Field_Size_4_Bit)\n       is\n          L : constant Field_Offset := Slot_Size / 4;\n \n@@ -661,7 +699,7 @@ package body Atree is\n       end Set_4_Bit_Val;\n \n       procedure Set_8_Bit_Val\n-        (N : Node_Or_Entity_Id; Offset : Field_Offset; Val : Field_8_Bit)\n+        (N : Node_Or_Entity_Id; Offset : Field_Offset; Val : Field_Size_8_Bit)\n       is\n          L : constant Field_Offset := Slot_Size / 8;\n \n@@ -674,7 +712,7 @@ package body Atree is\n       end Set_8_Bit_Val;\n \n       procedure Set_32_Bit_Val\n-        (N : Node_Or_Entity_Id; Offset : Field_Offset; Val : Field_32_Bit)\n+        (N : Node_Or_Entity_Id; Offset : Field_Offset; Val : Field_Size_32_Bit)\n       is\n          pragma Debug (Validate_Node_And_Offset_Write (N, Offset));\n \n@@ -695,33 +733,33 @@ package body Atree is\n    --  etc.\n \n    function Get_Field_Value\n-     (N : Node_Id; Field : Node_Field) return Field_32_Bit\n+     (N : Node_Id; Field : Node_Field) return Field_Size_32_Bit\n    is\n       pragma Assert (Field_Checking.Field_Present (Nkind (N), Field));\n       Desc : Field_Descriptor renames Node_Field_Descriptors (Field);\n \n    begin\n       case Field_Size (Desc.Kind) is\n-         when 1 => return Field_32_Bit (Get_1_Bit_Val (N, Desc.Offset));\n-         when 2 => return Field_32_Bit (Get_2_Bit_Val (N, Desc.Offset));\n-         when 4 => return Field_32_Bit (Get_4_Bit_Val (N, Desc.Offset));\n-         when 8 => return Field_32_Bit (Get_8_Bit_Val (N, Desc.Offset));\n+         when 1 => return Field_Size_32_Bit (Get_1_Bit_Val (N, Desc.Offset));\n+         when 2 => return Field_Size_32_Bit (Get_2_Bit_Val (N, Desc.Offset));\n+         when 4 => return Field_Size_32_Bit (Get_4_Bit_Val (N, Desc.Offset));\n+         when 8 => return Field_Size_32_Bit (Get_8_Bit_Val (N, Desc.Offset));\n          when others => return Get_32_Bit_Val (N, Desc.Offset);  -- 32\n       end case;\n    end Get_Field_Value;\n \n    procedure Set_Field_Value\n-     (N : Node_Id; Field : Node_Field; Val : Field_32_Bit)\n+     (N : Node_Id; Field : Node_Field; Val : Field_Size_32_Bit)\n    is\n       pragma Assert (Field_Checking.Field_Present (Nkind (N), Field));\n       Desc : Field_Descriptor renames Node_Field_Descriptors (Field);\n \n    begin\n       case Field_Size (Desc.Kind) is\n-         when 1 => Set_1_Bit_Val (N, Desc.Offset, Field_1_Bit (Val));\n-         when 2 => Set_2_Bit_Val (N, Desc.Offset, Field_2_Bit (Val));\n-         when 4 => Set_4_Bit_Val (N, Desc.Offset, Field_4_Bit (Val));\n-         when 8 => Set_8_Bit_Val (N, Desc.Offset, Field_8_Bit (Val));\n+         when 1 => Set_1_Bit_Val (N, Desc.Offset, Field_Size_1_Bit (Val));\n+         when 2 => Set_2_Bit_Val (N, Desc.Offset, Field_Size_2_Bit (Val));\n+         when 4 => Set_4_Bit_Val (N, Desc.Offset, Field_Size_4_Bit (Val));\n+         when 8 => Set_8_Bit_Val (N, Desc.Offset, Field_Size_8_Bit (Val));\n          when others => Set_32_Bit_Val (N, Desc.Offset, Val);  -- 32\n       end case;\n    end Set_Field_Value;\n@@ -784,31 +822,31 @@ package body Atree is\n    end Check_Vanishing_Fields;\n \n    function Get_Field_Value\n-     (N : Entity_Id; Field : Entity_Field) return Field_32_Bit\n+     (N : Entity_Id; Field : Entity_Field) return Field_Size_32_Bit\n    is\n       pragma Assert (Field_Checking.Field_Present (Ekind (N), Field));\n       Desc : Field_Descriptor renames Entity_Field_Descriptors (Field);\n    begin\n       case Field_Size (Desc.Kind) is\n-         when 1 => return Field_32_Bit (Get_1_Bit_Val (N, Desc.Offset));\n-         when 2 => return Field_32_Bit (Get_2_Bit_Val (N, Desc.Offset));\n-         when 4 => return Field_32_Bit (Get_4_Bit_Val (N, Desc.Offset));\n-         when 8 => return Field_32_Bit (Get_8_Bit_Val (N, Desc.Offset));\n+         when 1 => return Field_Size_32_Bit (Get_1_Bit_Val (N, Desc.Offset));\n+         when 2 => return Field_Size_32_Bit (Get_2_Bit_Val (N, Desc.Offset));\n+         when 4 => return Field_Size_32_Bit (Get_4_Bit_Val (N, Desc.Offset));\n+         when 8 => return Field_Size_32_Bit (Get_8_Bit_Val (N, Desc.Offset));\n          when others => return Get_32_Bit_Val (N, Desc.Offset);  -- 32\n       end case;\n    end Get_Field_Value;\n \n    procedure Set_Field_Value\n-     (N : Entity_Id; Field : Entity_Field; Val : Field_32_Bit)\n+     (N : Entity_Id; Field : Entity_Field; Val : Field_Size_32_Bit)\n    is\n       pragma Assert (Field_Checking.Field_Present (Ekind (N), Field));\n       Desc : Field_Descriptor renames Entity_Field_Descriptors (Field);\n    begin\n       case Field_Size (Desc.Kind) is\n-         when 1 => Set_1_Bit_Val (N, Desc.Offset, Field_1_Bit (Val));\n-         when 2 => Set_2_Bit_Val (N, Desc.Offset, Field_2_Bit (Val));\n-         when 4 => Set_4_Bit_Val (N, Desc.Offset, Field_4_Bit (Val));\n-         when 8 => Set_8_Bit_Val (N, Desc.Offset, Field_8_Bit (Val));\n+         when 1 => Set_1_Bit_Val (N, Desc.Offset, Field_Size_1_Bit (Val));\n+         when 2 => Set_2_Bit_Val (N, Desc.Offset, Field_Size_2_Bit (Val));\n+         when 4 => Set_4_Bit_Val (N, Desc.Offset, Field_Size_4_Bit (Val));\n+         when 8 => Set_8_Bit_Val (N, Desc.Offset, Field_Size_8_Bit (Val));\n          when others => Set_32_Bit_Val (N, Desc.Offset, Val);  -- 32\n       end case;\n    end Set_Field_Value;\n@@ -864,18 +902,18 @@ package body Atree is\n    Nkind_Offset : constant Field_Offset :=\n      Node_Field_Descriptors (Nkind).Offset;\n \n-   procedure Set_Nkind_Type is new Set_8_Bit_Field (Node_Kind) with Inline;\n+   procedure Set_Node_Kind_Type is new Set_8_Bit_Field (Node_Kind) with Inline;\n \n    procedure Init_Nkind (N : Node_Id; Val : Node_Kind) is\n       pragma Assert (Field_Is_Initial_Zero (N, Nkind));\n    begin\n-      Set_Nkind_Type (N, Nkind_Offset, Val);\n+      Set_Node_Kind_Type (N, Nkind_Offset, Val);\n    end Init_Nkind;\n \n    procedure Mutate_Nkind\n-     (N : Node_Id; Val : Node_Kind; Old_Size : Field_Offset)\n+     (N : Node_Id; Val : Node_Kind; Old_Size : Slot_Count)\n    is\n-      New_Size : constant Field_Offset := Size_In_Slots_To_Alloc (Val);\n+      New_Size : constant Slot_Count := Size_In_Slots_To_Alloc (Val);\n \n       All_Node_Offsets : Node_Offsets.Table_Type renames\n         Node_Offsets.Table (Node_Offsets.First .. Node_Offsets.Last);\n@@ -905,7 +943,7 @@ package body Atree is\n          Zero_Slots (Off_0 (N) + Old_Size, Slots.Last);\n       end if;\n \n-      Set_Nkind_Type (N, Nkind_Offset, Val);\n+      Set_Node_Kind_Type (N, Nkind_Offset, Val);\n       pragma Debug (Validate_Node_Write (N));\n    end Mutate_Nkind;\n \n@@ -917,7 +955,8 @@ package body Atree is\n    Ekind_Offset : constant Field_Offset :=\n      Entity_Field_Descriptors (Ekind).Offset;\n \n-   procedure Set_Ekind_Type is new Set_8_Bit_Field (Entity_Kind) with Inline;\n+   procedure Set_Entity_Kind_Type is new Set_8_Bit_Field (Entity_Kind)\n+     with Inline;\n \n    procedure Mutate_Ekind\n      (N : Entity_Id; Val : Entity_Kind)\n@@ -934,7 +973,7 @@ package body Atree is\n       --  For now, we are allocating all entities with the same size, so we\n       --  don't need to reallocate slots here.\n \n-      Set_Ekind_Type (N, Ekind_Offset, Val);\n+      Set_Entity_Kind_Type (N, Ekind_Offset, Val);\n       pragma Debug (Validate_Node_Write (N));\n    end Mutate_Ekind;\n \n@@ -946,7 +985,7 @@ package body Atree is\n    begin\n       return Result : constant Node_Id := Alloc_Node_Id do\n          declare\n-            Sz : constant Field_Offset := Size_In_Slots_To_Alloc (Kind);\n+            Sz : constant Slot_Count := Size_In_Slots_To_Alloc (Kind);\n             Sl : constant Node_Offset := Alloc_Slots (Sz);\n          begin\n             Node_Offsets.Table (Result) := Sl;\n@@ -988,15 +1027,15 @@ package body Atree is\n       pragma Assert (Nkind (N) not in N_Entity);\n       pragma Assert (New_Kind not in N_Entity);\n \n-      Old_Size : constant Field_Offset := Size_In_Slots (N);\n-      New_Size : constant Field_Offset := Size_In_Slots_To_Alloc (New_Kind);\n+      Old_Size : constant Slot_Count := Size_In_Slots (N);\n+      New_Size : constant Slot_Count := Size_In_Slots_To_Alloc (New_Kind);\n \n       Save_Sloc    : constant Source_Ptr := Sloc (N);\n       Save_In_List : constant Boolean    := In_List (N);\n       Save_CFS     : constant Boolean    := Comes_From_Source (N);\n       Save_Posted  : constant Boolean    := Error_Posted (N);\n-      Save_CA     : constant Boolean := Check_Actuals (N);\n-      Save_Is_IGN : constant Boolean := Is_Ignored_Ghost_Node (N);\n+      Save_CA      : constant Boolean    := Check_Actuals (N);\n+      Save_Is_IGN  : constant Boolean    := Is_Ignored_Ghost_Node (N);\n       Save_Link    : constant Union_Id   := Link (N);\n \n       Par_Count : Nat := 0;\n@@ -1034,11 +1073,11 @@ package body Atree is\n       end if;\n    end Change_Node;\n \n-   ---------------\n-   -- Copy_Node --\n-   ---------------\n+   ----------------\n+   -- Copy_Slots --\n+   ----------------\n \n-   procedure Copy_Slots (From, To, Num_Slots : Node_Offset) is\n+   procedure Copy_Slots (From, To : Node_Offset; Num_Slots : Slot_Count) is\n       pragma Assert (From /= To);\n \n       All_Slots : Slots.Table_Type renames\n@@ -1059,7 +1098,7 @@ package body Atree is\n       pragma Debug (Validate_Node_Write (Destination));\n       pragma Assert (Source /= Destination);\n \n-      S_Size : constant Field_Offset := Size_In_Slots (Source);\n+      S_Size : constant Slot_Count := Size_In_Slots (Source);\n \n       All_Node_Offsets : Node_Offsets.Table_Type renames\n         Node_Offsets.Table (Node_Offsets.First .. Node_Offsets.Last);\n@@ -1079,8 +1118,8 @@ package body Atree is\n       Save_In_List : constant Boolean  := In_List (Destination);\n       Save_Link    : constant Union_Id := Link (Destination);\n \n-      S_Size : constant Field_Offset := Size_In_Slots_To_Alloc (Source);\n-      D_Size : constant Field_Offset := Size_In_Slots_To_Alloc (Destination);\n+      S_Size : constant Slot_Count := Size_In_Slots_To_Alloc (Source);\n+      D_Size : constant Slot_Count := Size_In_Slots_To_Alloc (Destination);\n \n    begin\n       New_Node_Debugging_Output (Source);\n@@ -1350,7 +1389,7 @@ package body Atree is\n            when N_Character_Literal => N_Defining_Character_Literal,\n            when N_Identifier => N_Defining_Identifier,\n            when N_Operator_Symbol => N_Defining_Operator_Symbol,\n-           when others => N_Abort_Statement); -- can't happen\n+           when others => N_Unused_At_Start); -- can't happen\n       --  The new NKind, which is the appropriate value of N_Entity based on\n       --  the old Nkind. N_xxx is mapped to N_Defining_xxx.\n       pragma Assert (New_Kind in N_Entity);\n@@ -1554,54 +1593,51 @@ package body Atree is\n \n    function New_Copy (Source : Node_Id) return Node_Id is\n       pragma Debug (Validate_Node (Source));\n-\n-      New_Id : Node_Id;\n-      S_Size : constant Field_Offset := Size_In_Slots_To_Alloc (Source);\n+      S_Size : constant Slot_Count := Size_In_Slots_To_Alloc (Source);\n    begin\n       if Source <= Empty_Or_Error then\n          return Source;\n       end if;\n \n-      New_Id := Alloc_Node_Id;\n-      Node_Offsets.Table (New_Id) := Alloc_Slots (S_Size);\n-      Orig_Nodes.Append (New_Id);\n-      Copy_Slots (Source, New_Id);\n+      return New_Id : constant Node_Id := Alloc_Node_Id do\n+         Node_Offsets.Table (New_Id) := Alloc_Slots (S_Size);\n+         Orig_Nodes.Append (New_Id);\n+         Copy_Slots (Source, New_Id);\n \n-      Set_Check_Actuals (New_Id, False);\n-      Set_Paren_Count_Of_Copy (Target => New_Id, Source => Source);\n-      pragma Assert (Original_Node (Node_Offsets.Last) = Node_Offsets.Last);\n+         Set_Check_Actuals (New_Id, False);\n+         Set_Paren_Count_Of_Copy (Target => New_Id, Source => Source);\n \n-      Allocate_List_Tables (New_Id);\n-      Report (Target => New_Id, Source => Source);\n+         Allocate_List_Tables (New_Id);\n+         Report (Target => New_Id, Source => Source);\n \n-      Set_In_List (New_Id, False);\n-      Set_Link (New_Id, Empty_List_Or_Node);\n+         Set_In_List (New_Id, False);\n+         Set_Link (New_Id, Empty_List_Or_Node);\n \n-      --  If the original is marked as a rewrite insertion, then unmark the\n-      --  copy, since we inserted the original, not the copy.\n+         --  If the original is marked as a rewrite insertion, then unmark the\n+         --  copy, since we inserted the original, not the copy.\n \n-      Set_Rewrite_Ins (New_Id, False);\n+         Set_Rewrite_Ins (New_Id, False);\n \n-      --  Clear Is_Overloaded since we cannot have semantic interpretations\n-      --  of this new node.\n+         --  Clear Is_Overloaded since we cannot have semantic interpretations\n+         --  of this new node.\n \n-      if Nkind (Source) in N_Subexpr then\n-         Set_Is_Overloaded (New_Id, False);\n-      end if;\n+         if Nkind (Source) in N_Subexpr then\n+            Set_Is_Overloaded (New_Id, False);\n+         end if;\n \n-      --  Always clear Has_Aspects, the caller must take care of copying\n-      --  aspects if this is required for the particular situation.\n+         --  Always clear Has_Aspects, the caller must take care of copying\n+         --  aspects if this is required for the particular situation.\n \n-      Set_Has_Aspects (New_Id, False);\n+         Set_Has_Aspects (New_Id, False);\n \n-      --  Mark the copy as Ghost depending on the current Ghost region\n+         --  Mark the copy as Ghost depending on the current Ghost region\n \n-      Mark_New_Ghost_Node (New_Id);\n+         Mark_New_Ghost_Node (New_Id);\n \n-      New_Node_Debugging_Output (New_Id);\n+         New_Node_Debugging_Output (New_Id);\n \n-      pragma Assert (New_Id /= Source);\n-      return New_Id;\n+         pragma Assert (New_Id /= Source);\n+      end return;\n    end New_Copy;\n \n    ----------------\n@@ -1684,10 +1720,9 @@ package body Atree is\n       return Node_Offsets.Table (First_Node_Id)'Address;\n    end Node_Offsets_Address;\n \n-   Slot_Byte_Size : constant := 4;\n-   pragma Assert (Slot_Byte_Size * 8 = Slot'Size);\n-\n    function Slots_Address return System.Address is\n+      Slot_Byte_Size : constant := 4;\n+      pragma Assert (Slot_Byte_Size * 8 = Slot'Size);\n       Extra : constant := Slots_Low_Bound * Slot_Byte_Size;\n       --  Slots does not start at 0, so we need to subtract off the extra\n       --  amount. We are returning Slots.Table (0)'Address, except that\n@@ -2123,7 +2158,7 @@ package body Atree is\n       Rewriting_Proc := Proc;\n    end Set_Rewriting_Proc;\n \n-   function Size_In_Slots_To_Alloc (Kind : Node_Kind) return Field_Offset is\n+   function Size_In_Slots_To_Alloc (Kind : Node_Kind) return Slot_Count is\n    begin\n       return\n         (if Kind in N_Entity then Einfo.Entities.Max_Entity_Size\n@@ -2133,12 +2168,12 @@ package body Atree is\n    end Size_In_Slots_To_Alloc;\n \n    function Size_In_Slots_To_Alloc\n-     (N : Node_Or_Entity_Id) return Field_Offset is\n+     (N : Node_Or_Entity_Id) return Slot_Count is\n    begin\n       return Size_In_Slots_To_Alloc (Nkind (N));\n    end Size_In_Slots_To_Alloc;\n \n-   function Size_In_Slots (N : Node_Or_Entity_Id) return Field_Offset is\n+   function Size_In_Slots (N : Node_Or_Entity_Id) return Slot_Count is\n    begin\n       pragma Assert (Nkind (N) /= N_Unused_At_Start);\n       return\n@@ -2313,11 +2348,9 @@ package body Atree is\n    -- Zero_Slots --\n    ----------------\n \n-   Zero : constant Slot := 0;\n-\n-   procedure Zero_Slots (F, L : Node_Offset) is\n+   procedure Zero_Slots (First, Last : Node_Offset) is\n    begin\n-      Slots.Table (F .. L) := (others => Zero);\n+      Slots.Table (First .. Last) := (others => 0);\n    end Zero_Slots;\n \n    procedure Zero_Slots (N : Node_Or_Entity_Id) is"}, {"sha": "352275315a5c87c9a716fed4525c007d19a700ba", "filename": "gcc/ada/atree.ads", "status": "modified", "additions": 57, "deletions": 25, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7cadd18606c9c3ce2776b6f876ca98849b24b84/gcc%2Fada%2Fatree.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7cadd18606c9c3ce2776b6f876ca98849b24b84/gcc%2Fada%2Fatree.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.ads?ref=a7cadd18606c9c3ce2776b6f876ca98849b24b84", "patch": "@@ -549,6 +549,18 @@ package Atree is\n    --  a manner that can be reversed later). One possible approach is to use\n    --  Rewrite to substitute a null statement for the node to be deleted.\n \n+   ----------------------\n+   -- Vanishing Fields --\n+   ----------------------\n+\n+   --  The Nkind and Ekind fields are like Ada discriminants governing a\n+   --  variant part. They determine which fields are present. If the Nkind\n+   --  or Ekind fields are changed, then this can change which fields are\n+   --  present. If a field is present for the old kind, but not for the\n+   --  new kind, the field vanishes. This requires some care when changing\n+   --  kinds, as described below. Note that Ada doesn't even allow direct\n+   --  modification of a discriminant.\n+\n    type Node_Field_Set is array (Node_Field) of Boolean with Pack;\n \n    type Entity_Field_Set is array (Entity_Field) of Boolean with Pack;\n@@ -594,9 +606,9 @@ package Atree is\n    --  Mutate_Nkind). However, there are a few cases where we set the Ekind\n    --  from its initial E_Void value to something else, then set it back to\n    --  E_Void, then back to the something else, and we expect the \"something\n-   --  else\" fields to retain their value. Two two \"something else\"s are not\n+   --  else\" fields to retain their value. The two \"something else\"s are not\n    --  always the same; for example we change from E_Void, to E_Variable, to\n-   --  E_Void, to E_Constant. ????This needs to be fixed.\n+   --  E_Void, to E_Constant.\n \n    procedure Print_Atree_Info (N : Node_Or_Entity_Id);\n    --  Called from Treepr to print out information about N that is private to\n@@ -648,6 +660,13 @@ package Atree is\n          Table_Increment      => Alloc.Node_Offsets_Increment,\n          Table_Name           => \"Node_Offsets\");\n \n+      Noff : Node_Offsets.Table_Ptr renames Node_Offsets.Table with\n+        Unreferenced;\n+      function Nlast return Node_Id'Base renames Node_Offsets.Last with\n+        Unreferenced;\n+      --  Short names for use in gdb, not used in real code. Note that gdb\n+      --  can't find Node_Offsets.Table without a full expanded name.\n+\n       --  We define the type Slot as a 32-bit modular integer. It is logically\n       --  split into the appropriate numbers of components of appropriate size,\n       --  but this splitting is not explicit because packed arrays cannot be\n@@ -663,11 +682,15 @@ package Atree is\n       function Shift_Right (S : Slot; V : Natural) return Slot;\n       pragma Import (Intrinsic, Shift_Right);\n \n-      type Field_1_Bit  is mod 2**1;\n-      type Field_2_Bit  is mod 2**2;\n-      type Field_4_Bit  is mod 2**4;\n-      type Field_8_Bit  is mod 2**8;\n-      type Field_32_Bit is mod 2**32;\n+      --  Low-level types for fields of the various supported sizes.\n+      --  All fields are a power of 2 number of bits, and are aligned\n+      --  to that number of bits:\n+\n+      type Field_Size_1_Bit  is mod 2**1;\n+      type Field_Size_2_Bit  is mod 2**2;\n+      type Field_Size_4_Bit  is mod 2**4;\n+      type Field_Size_8_Bit  is mod 2**8;\n+      type Field_Size_32_Bit is mod 2**32;\n \n       Slots_Low_Bound : constant Field_Offset := Field_Offset'First + 1;\n \n@@ -681,22 +704,25 @@ package Atree is\n       --  Note that Table_Low_Bound is set such that if we try to access\n       --  Slots.Table (0), we will get Constraint_Error.\n \n-      Noff : Node_Offsets.Table_Ptr renames Node_Offsets.Table;\n-      function Nlast return Node_Id'Base renames Node_Offsets.Last;\n-      Lots : Slots.Table_Ptr renames Slots.Table;\n-      function Slast return Node_Offset'Base renames Slots.Last;\n-      --  Work around limitations of gdb; it can't find Node_Offsets.Table,\n-      --  etc, without a full expanded name.\n+      Slts : Slots.Table_Ptr renames Slots.Table with\n+        Unreferenced;\n+      function Slast return Node_Offset'Base renames Slots.Last with\n+        Unreferenced;\n+      --  Short names for use in gdb, not used in real code. Note that gdb\n+      --  can't find Slots.Table without a full expanded name.\n \n       function Alloc_Node_Id return Node_Id with Inline;\n \n-      function Alloc_Slots (Num_Slots : Field_Offset) return Node_Offset\n+      function Alloc_Slots (Num_Slots : Slot_Count) return Node_Offset\n         with Inline;\n+      --  Allocate the slots for a node in the Slots table\n \n       --  Each of the following Get_N_Bit_Field functions fetches the field of\n       --  the given Field_Type at the given offset. Field_Type'Size must be N.\n       --  The offset is measured in units of Field_Type'Size. Likewise for the\n-      --  Set_N_Bit_Field procedures.\n+      --  Set_N_Bit_Field procedures. These are instantiated in Sinfo.Nodes and\n+      --  Einfo.Entities for the various possible Field_Types (Flag, Node_Id,\n+      --  Uint, etc).\n \n       generic\n          type Field_Type is private;\n@@ -771,49 +797,55 @@ package Atree is\n       --  overloaded, we would use the same names.\n \n       function Get_1_Bit_Val\n-        (N : Node_Or_Entity_Id; Offset : Field_Offset) return Field_1_Bit\n+        (N : Node_Or_Entity_Id; Offset : Field_Offset) return Field_Size_1_Bit\n          with Inline;\n \n       function Get_2_Bit_Val\n-        (N : Node_Or_Entity_Id; Offset : Field_Offset) return Field_2_Bit\n+        (N : Node_Or_Entity_Id; Offset : Field_Offset) return Field_Size_2_Bit\n          with Inline;\n \n       function Get_4_Bit_Val\n-        (N : Node_Or_Entity_Id; Offset : Field_Offset) return Field_4_Bit\n+        (N : Node_Or_Entity_Id; Offset : Field_Offset) return Field_Size_4_Bit\n          with Inline;\n \n       function Get_8_Bit_Val\n-        (N : Node_Or_Entity_Id; Offset : Field_Offset) return Field_8_Bit\n+        (N : Node_Or_Entity_Id; Offset : Field_Offset) return Field_Size_8_Bit\n          with Inline;\n \n       function Get_32_Bit_Val\n-        (N : Node_Or_Entity_Id; Offset : Field_Offset) return Field_32_Bit\n+        (N : Node_Or_Entity_Id; Offset : Field_Offset) return Field_Size_32_Bit\n          with Inline;\n \n       procedure Set_1_Bit_Val\n-        (N : Node_Or_Entity_Id; Offset : Field_Offset; Val : Field_1_Bit)\n+        (N : Node_Or_Entity_Id; Offset : Field_Offset; Val : Field_Size_1_Bit)\n          with Inline;\n \n       procedure Set_2_Bit_Val\n-        (N : Node_Or_Entity_Id; Offset : Field_Offset; Val : Field_2_Bit)\n+        (N : Node_Or_Entity_Id; Offset : Field_Offset; Val : Field_Size_2_Bit)\n          with Inline;\n \n       procedure Set_4_Bit_Val\n-        (N : Node_Or_Entity_Id; Offset : Field_Offset; Val : Field_4_Bit)\n+        (N : Node_Or_Entity_Id; Offset : Field_Offset; Val : Field_Size_4_Bit)\n          with Inline;\n \n       procedure Set_8_Bit_Val\n-        (N : Node_Or_Entity_Id; Offset : Field_Offset; Val : Field_8_Bit)\n+        (N : Node_Or_Entity_Id; Offset : Field_Offset; Val : Field_Size_8_Bit)\n          with Inline;\n \n       procedure Set_32_Bit_Val\n-        (N : Node_Or_Entity_Id; Offset : Field_Offset; Val : Field_32_Bit)\n+        (N : Node_Or_Entity_Id; Offset : Field_Offset; Val : Field_Size_32_Bit)\n          with Inline;\n \n+      --  The following are used in \"asserts on\" mode to validate nodes; an\n+      --  exception is raised if invalid node content is detected.\n+\n       procedure Validate_Node (N : Node_Or_Entity_Id);\n+      --  Validate for reading\n       procedure Validate_Node_Write (N : Node_Or_Entity_Id);\n+      --  Validate for writing\n \n       function Is_Valid_Node (U : Union_Id) return Boolean;\n+      --  True if U is within the range of Node_Offsets\n \n    end Atree_Private_Part;\n "}, {"sha": "0ed7c74f59e4af39f60f47dc593f2136137a8ce2", "filename": "gcc/ada/einfo-utils.adb", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7cadd18606c9c3ce2776b6f876ca98849b24b84/gcc%2Fada%2Feinfo-utils.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7cadd18606c9c3ce2776b6f876ca98849b24b84/gcc%2Fada%2Feinfo-utils.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo-utils.adb?ref=a7cadd18606c9c3ce2776b6f876ca98849b24b84", "patch": "@@ -43,6 +43,24 @@ package body Einfo.Utils is\n    --  Determine whether abstract state State_Id has particular option denoted\n    --  by the name Option_Nam.\n \n+   -----------------------------------\n+   -- Renamings of Renamed_Or_Alias --\n+   -----------------------------------\n+\n+   function Alias (N : Entity_Id) return Node_Id is\n+   begin\n+      pragma Assert\n+        (Is_Overloadable (N) or else Ekind (N) = E_Subprogram_Type);\n+      return Renamed_Or_Alias (N);\n+   end Alias;\n+\n+   procedure Set_Alias (N : Entity_Id; Val : Node_Id) is\n+   begin\n+      pragma Assert\n+        (Is_Overloadable (N) or else Ekind (N) = E_Subprogram_Type);\n+      Set_Renamed_Or_Alias (N, Val);\n+   end Set_Alias;\n+\n    ----------------\n    -- Has_Option --\n    ----------------\n@@ -253,8 +271,7 @@ package body Einfo.Utils is\n \n    function Is_Named_Access_Type                (Id : E) return B is\n    begin\n-      return Ekind (Id) in E_Access_Type .. -- ????\n-                             E_Access_Protected_Subprogram_Type;\n+      return Ekind (Id) in Named_Access_Kind;\n    end Is_Named_Access_Type;\n \n    function Is_Named_Number                     (Id : E) return B is\n@@ -1425,8 +1442,6 @@ package body Einfo.Utils is\n \n    function Is_Base_Type (Id : E) return Boolean is\n    begin\n---  ????      pragma Assert (Is_Type (Id));\n---  Apparently, Is_Base_Type is called on non-types, and returns True!\n       return Entity_Is_Base_Type (Ekind (Id));\n    end Is_Base_Type;\n \n@@ -3123,17 +3138,6 @@ package body Einfo.Utils is\n \n    function Is_Volatile (Id : E) return B is\n    begin\n-      --  ????The old version has a comment that says:\n-      --       The flag is not set reliably on private subtypes,\n-      --       and is always retrieved from the base type (but this is not a\n-      --       base-type-only attribute because it applies to other entities).\n-      --  Perhaps it should be set reliably, and perhaps it should be\n-      --  Base_Type_Only, but that doesn't work because it is currently\n-      --  set on subtypes, so we have to explicitly fetch the Base_Type below.\n-      --\n-      --  It might be cleaner if the call sites called Is_Volatile_Type\n-      --  or Is_Volatile_Object directly; surely they know which it is.\n-\n       pragma Assert (Nkind (Id) in N_Entity);\n \n       if Is_Type (Id) then"}, {"sha": "f305235fb6e64f06c793312c7b356f4ba04881b7", "filename": "gcc/ada/einfo-utils.ads", "status": "modified", "additions": 16, "deletions": 21, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7cadd18606c9c3ce2776b6f876ca98849b24b84/gcc%2Fada%2Feinfo-utils.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7cadd18606c9c3ce2776b6f876ca98849b24b84/gcc%2Fada%2Feinfo-utils.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo-utils.ads?ref=a7cadd18606c9c3ce2776b6f876ca98849b24b84", "patch": "@@ -34,12 +34,10 @@ package Einfo.Utils is\n    --  See the comment in einfo.ads, \"Renaming and Aliasing\", which is somewhat\n    --  incorrect. In fact, the compiler uses Alias, Renamed_Entity, and\n    --  Renamed_Object more-or-less interchangeably, so we rename them here.\n-   --  ????Should add preconditions.\n+   --  Alias isn't really renamed, because we want an assertion in the body.\n \n-   function Alias\n-     (N : Entity_Id) return Node_Id renames Renamed_Or_Alias;\n-   procedure Set_Alias\n-     (N : Entity_Id; Val : Node_Id) renames Set_Renamed_Or_Alias;\n+   function Alias (N : Entity_Id) return Node_Id;\n+   procedure Set_Alias (N : Entity_Id; Val : Node_Id);\n    function Renamed_Entity\n      (N : Entity_Id) return Node_Id renames Renamed_Or_Alias;\n    procedure Set_Renamed_Entity\n@@ -49,26 +47,19 @@ package Einfo.Utils is\n    procedure Set_Renamed_Object\n      (N : Entity_Id; Val : Node_Id) renames Set_Renamed_Or_Alias;\n \n-   --------------------------\n-   -- Subtype Declarations --\n-   --------------------------\n-\n-   --  ????\n-   --  The above entities are arranged so that they can be conveniently grouped\n-   --  into subtype ranges. Note that for each of the xxx_Kind ranges defined\n-   --  below, there is a corresponding Is_xxx (or for types, Is_xxx_Type)\n-   --  predicate which is to be used in preference to direct range tests using\n-   --  the subtype name. However, the subtype names are available for direct\n-   --  use, e.g. as choices in case statements.\n+   pragma Inline (Alias);\n+   pragma Inline (Set_Alias);\n+   pragma Inline (Renamed_Entity);\n+   pragma Inline (Set_Renamed_Entity);\n+   pragma Inline (Renamed_Object);\n+   pragma Inline (Set_Renamed_Object);\n \n    -------------------\n    -- Type Synonyms --\n    -------------------\n \n    --  The following type synonyms are used to tidy up the function and\n-   --  procedure declarations that follow, and also to make it possible to meet\n-   --  the requirement for the XEINFO utility that all function specs must fit\n-   --  on a single source line.????\n+   --  procedure declarations that follow.\n \n    subtype B is Boolean;\n    subtype C is Component_Alignment_Kind;\n@@ -91,7 +82,6 @@ package Einfo.Utils is\n    --  In some cases, the test is of an entity attribute (e.g. in the case of\n    --  Is_Generic_Type where the Ekind does not provide the needed\n    --  information).\n-   --  ????Could automatically generate some of these?\n \n    function Is_Access_Object_Type               (Id : E) return B;\n    function Is_Access_Type                      (Id : E) return B;\n@@ -220,6 +210,7 @@ package Einfo.Utils is\n    function Has_Null_Visible_Refinement         (Id : E) return B;\n    function Implementation_Base_Type            (Id : E) return E;\n    function Is_Base_Type                        (Id : E) return B;\n+   --  Note that Is_Base_Type returns True for nontypes\n    function Is_Boolean_Type                     (Id : E) return B;\n    function Is_Constant_Object                  (Id : E) return B;\n    function Is_Controlled                       (Id : E) return B;\n@@ -402,7 +393,11 @@ package Einfo.Utils is\n    -- Access to Subprograms in Subprograms_For_Type --\n    ---------------------------------------------------\n \n-   function Is_Partial_DIC_Procedure            (Id : E) return B;\n+   --  Now that we have variable-sized nodes, it might be possible to replace\n+   --  the following with regular fields, and get rid of the flags used to mark\n+   --  these kinds of subprograms.\n+\n+   function Is_Partial_DIC_Procedure             (Id : E) return B;\n \n    function DIC_Procedure                        (Id : E) return E;\n    function Partial_DIC_Procedure                (Id : E) return E;"}, {"sha": "fe9bf72898af172570a2d748607cab11847aa2b4", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 1669, "deletions": 1682, "changes": 3351, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7cadd18606c9c3ce2776b6f876ca98849b24b84/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7cadd18606c9c3ce2776b6f876ca98849b24b84/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=a7cadd18606c9c3ce2776b6f876ca98849b24b84"}, {"sha": "631773738cf8050b516babc11a6590eaddd104d4", "filename": "gcc/ada/fe.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7cadd18606c9c3ce2776b6f876ca98849b24b84/gcc%2Fada%2Ffe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7cadd18606c9c3ce2776b6f876ca98849b24b84/gcc%2Fada%2Ffe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffe.h?ref=a7cadd18606c9c3ce2776b6f876ca98849b24b84", "patch": "@@ -658,10 +658,6 @@ B Unknown_Normalized_Position_Max       (Entity_Id E);\n #define Unknown_RM_Size einfo__utils__unknown_rm_size\n B Unknown_RM_Size                       (Entity_Id E);\n \n-// The following were automatically generated as INLINE functions in the old\n-// einfo.h by the spitbol program.\n-// Is it important that they be inlined????\n-\n #define Is_Discrete_Or_Fixed_Point_Type einfo__utils__is_discrete_or_fixed_point_type\n B Is_Discrete_Or_Fixed_Point_Type     (E Id);\n "}, {"sha": "9c3bf349621a6fb36d3221fc0de6525dcafdf577", "filename": "gcc/ada/gen_il-fields.ads", "status": "modified", "additions": 28, "deletions": 7, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7cadd18606c9c3ce2776b6f876ca98849b24b84/gcc%2Fada%2Fgen_il-fields.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7cadd18606c9c3ce2776b6f876ca98849b24b84/gcc%2Fada%2Fgen_il-fields.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgen_il-fields.ads?ref=a7cadd18606c9c3ce2776b6f876ca98849b24b84", "patch": "@@ -23,11 +23,21 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Gen_IL.Types;\n+\n package Gen_IL.Fields is\n \n    --  The following is \"optional field enumeration\" -- i.e. it is Field_Enum\n-   --  (declared in Gen_IL.Utils) plus the special null value No_Field.\n-   --  See the spec of Gen_IL.Gen for how to modify this.\n+   --  (declared below) plus the special null value No_Field. See the spec of\n+   --  Gen_IL.Gen for how to modify this. (Of course, in Ada we have to define\n+   --  this backwards from the above conceptual description.)\n+\n+   --  Note that there are various subranges of this type declared below,\n+   --  which might need to be kept in sync when modifying this.\n+\n+   --  Be sure to put new fields in the appropriate subrange (Field_Enum,\n+   --  Node_Header_Field, Node_Field, Entity_Field -- search for comments\n+   --  below).\n \n    type Opt_Field_Enum is\n      (No_Field,\n@@ -411,6 +421,7 @@ package Gen_IL.Fields is\n       Uninitialized_Variable,\n       Used_Operations,\n       Was_Attribute_Reference,\n+      Was_Default_Init_Box_Association,\n       Was_Expression_Function,\n       Was_Originally_Stub,\n \n@@ -430,7 +441,6 @@ package Gen_IL.Fields is\n       Activation_Record_Component,\n       Actual_Subtype,\n       Address_Taken,\n---  ??      Alias,\n       Alignment,\n       Anonymous_Designated_Type,\n       Anonymous_Masters,\n@@ -852,10 +862,8 @@ package Gen_IL.Fields is\n       Related_Instance,\n       Related_Type,\n       Relative_Deadline_Variable,\n---  ???      Renamed_Entity,\n       Renamed_In_Spec,\n---  ???      Renamed_Object,\n-      Renamed_Or_Alias, -- ???Replaces Alias, Renamed_Entity, Renamed_Object\n+      Renamed_Or_Alias, -- Shared among Alias, Renamed_Entity, Renamed_Object\n       Renaming_Map,\n       Requires_Overriding,\n       Return_Applies_To,\n@@ -913,11 +921,24 @@ package Gen_IL.Fields is\n       Warnings_Off_Used,\n       Warnings_Off_Used_Unmodified,\n       Warnings_Off_Used_Unreferenced,\n-      Was_Default_Init_Box_Association,\n       Was_Hidden,\n       Wrapped_Entity\n \n       --  End of entity fields.\n      ); -- Opt_Field_Enum\n \n+   subtype Field_Enum is Opt_Field_Enum\n+     range Opt_Field_Enum'Succ (No_Field) .. Opt_Field_Enum'Last;\n+   --  Enumeration of fields -- Opt_Field_Enum without the special null value\n+   --  No_Field.\n+\n+   subtype Node_Header_Field is Field_Enum with Predicate =>\n+     Node_Header_Field in Nkind .. Link | Ekind;\n+\n+   use Gen_IL.Types;\n+\n+   subtype Node_Header_Type is Type_Enum range\n+     Node_Kind_Type .. Union_Id;\n+   --  Types of node header fields\n+\n end Gen_IL.Fields;"}, {"sha": "2c486dc21e78cec0aa5fd6951ba580d739933866", "filename": "gcc/ada/gen_il-gen-gen_entities.adb", "status": "modified", "additions": 213, "deletions": 40, "changes": 253, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7cadd18606c9c3ce2776b6f876ca98849b24b84/gcc%2Fada%2Fgen_il-gen-gen_entities.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7cadd18606c9c3ce2776b6f876ca98849b24b84/gcc%2Fada%2Fgen_il-gen-gen_entities.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgen_il-gen-gen_entities.adb?ref=a7cadd18606c9c3ce2776b6f876ca98849b24b84", "patch": "@@ -25,29 +25,30 @@\n \n procedure Gen_IL.Gen.Gen_Entities is\n \n-   procedure Ab\n+   procedure Ab -- Short for \"Abstract\"\n      (T : Abstract_Entity; Parent : Abstract_Type;\n       Fields : Field_Sequence := No_Fields)\n       renames Create_Abstract_Entity_Type;\n-   procedure Cc\n+   procedure Cc -- Short for \"ConCrete\"\n      (T : Concrete_Entity; Parent : Abstract_Type;\n       Fields : Field_Sequence := No_Fields)\n       renames Create_Concrete_Entity_Type;\n \n-   function Sm\n+   --  No Sy (Syntactic) fields in entities\n+   function Sm -- Short for \"Semantic\"\n      (Field : Field_Enum; Field_Type : Type_Enum;\n       Type_Only  : Type_Only_Enum := No_Type_Only;\n-      Pre : String := \"\") return Field_Desc\n+      Pre, Pre_Get, Pre_Set : String := \"\") return Field_Desc\n       renames Create_Semantic_Field;\n \n    procedure Union (T : Abstract_Entity; Children : Type_Array)\n-     renames Create_Entity_Union;\n+     renames Create_Entity_Union_Type;\n \n begin -- Gen_IL.Gen.Gen_Entities\n    pragma Style_Checks (\"M200\");\n \n    Create_Root_Entity_Type (Entity_Kind,\n-       (Sm (Ekind, Ekind_Type),\n+       (Sm (Ekind, Entity_Kind_Type),\n         Sm (Basic_Convention, Convention_Id),\n         Sm (Address_Taken, Flag),\n         Sm (Associated_Entity, Node_Id),\n@@ -199,7 +200,7 @@ begin -- Gen_IL.Gen.Gen_Entities\n         Sm (Is_Uplevel_Referenced_Entity, Flag),\n         Sm (Is_Visible_Formal, Flag),\n         Sm (Is_Visible_Lib_Unit, Flag),\n-        Sm (Is_Volatile_Type, Flag), -- Should be Base_Type_Only?????\n+        Sm (Is_Volatile_Type, Flag),\n         Sm (Is_Volatile_Object, Flag),\n         Sm (Is_Volatile_Full_Access, Flag),\n         Sm (Kill_Elaboration_Checks, Flag),\n@@ -237,6 +238,11 @@ begin -- Gen_IL.Gen.Gen_Entities\n         Sm (Was_Hidden, Flag)));\n \n    Cc (E_Void, Entity_Kind,\n+       --  The initial Ekind value for a newly created entity. Also used as the\n+       --  Ekind for Standard_Void_Type, a type entity in Standard used as a\n+       --  dummy type for the return type of a procedure (the reason we create\n+       --  this type is to share the circuits for performing overload resolution\n+       --  on calls).\n        (Sm (Alignment, Uint),\n         Sm (Contract, Node_Id),\n         Sm (Is_Elaboration_Warnings_OK_Id, Flag),\n@@ -251,8 +257,8 @@ begin -- Gen_IL.Gen.Gen_Entities\n         Sm (Package_Instantiation, Node_Id), -- setter only\n         Sm (Related_Expression, Node_Id), -- setter only\n \n-        --  ????The following are not documented in the old einfo.ads as being\n-        --  fields of E_Void.\n+        --  If we set the Ekind field properly before setting the following\n+        --  fields, then these would not be needed in E_Void.\n         Sm (Accept_Address, Elist_Id),\n         Sm (Associated_Formal_Package, Node_Id),\n         Sm (Associated_Node_For_Itype, Node_Id),\n@@ -264,7 +270,7 @@ begin -- Gen_IL.Gen.Gen_Entities\n         Sm (Discriminant_Number, Uint),\n         Sm (Enclosing_Scope, Node_Id),\n         Sm (Entry_Bodies_Array, Node_Id,\n-            Pre => \"Has_Entries (N)\"), -- This can't be right????\n+            Pre => \"Has_Entries (N)\"),\n         Sm (Entry_Cancel_Parameter, Node_Id),\n         Sm (Entry_Component, Node_Id),\n         Sm (Entry_Formal, Node_Id),\n@@ -277,7 +283,6 @@ begin -- Gen_IL.Gen.Gen_Entities\n         Sm (Generic_Homonym, Node_Id),\n         Sm (Generic_Renamings, Elist_Id),\n         Sm (Handler_Records, List_Id),\n---  ????         Sm (Has_Protected, Flag),\n         Sm (Has_Static_Discriminants, Flag),\n         Sm (Inner_Instances, Elist_Id),\n         Sm (Interface_Name, Node_Id),\n@@ -289,25 +294,17 @@ begin -- Gen_IL.Gen.Gen_Entities\n         Sm (Scalar_Range, Node_Id),\n         Sm (Scale_Value, Uint),\n         Sm (Unset_Reference, Node_Id)));\n-   --  In the previous version, the above \"setter only\" fields were allowed for\n-   --  E_Void only on the setters, not getters.\n-\n-   --  ????This comment in the old version of einfo.adb:\n-\n-   --  Note: in many of these set procedures an \"obvious\" assertion is missing.\n-   --  The reason for this is that in many cases, a field is set before the\n-   --  Ekind field is set, so that the field is set when Ekind = E_Void. It\n-   --  it is possible to add assertions that specifically include the E_Void\n-   --  possibility, but in some cases, we just omit the assertions.\n-\n-   --  causes a lot of headaches. Plus some places used the low-level setters\n-   --  (e.g. Set_Node1), which bypasses any assertions.\n+   --  For the above \"setter only\" fields, the setters are called for E_Void,\n+   --  but not getters; the Ekind is modified before any such getters are\n+   --  called.\n \n    Ab (Object_Kind, Entity_Kind,\n        (Sm (Current_Value, Node_Id),\n         Sm (Renamed_Or_Alias, Node_Id)));\n \n    Cc (E_Component, Object_Kind,\n+       --  Components of a record declaration, private declarations of\n+       --  protected objects.\n        (Sm (Component_Bit_Offset, Uint),\n         Sm (Component_Clause, Node_Id),\n         Sm (Corresponding_Record_Component, Node_Id),\n@@ -329,6 +326,7 @@ begin -- Gen_IL.Gen.Gen_Entities\n         Sm (Related_Type, Node_Id)));\n \n    Cc (E_Constant, Object_Kind,\n+       --  Constants created by an object declaration with a constant keyword\n        (Sm (Activation_Record_Component, Node_Id),\n         Sm (Actual_Subtype, Node_Id),\n         Sm (Alignment, Uint),\n@@ -358,6 +356,8 @@ begin -- Gen_IL.Gen.Gen_Entities\n         Sm (Status_Flag_Or_Transient_Decl, Node_Id)));\n \n    Cc (E_Discriminant, Object_Kind,\n+       --  A discriminant, created by the use of a discriminant in a type\n+       --  declaration.\n        (Sm (Component_Bit_Offset, Uint),\n         Sm (Component_Clause, Node_Id),\n         Sm (Corresponding_Discriminant, Node_Id),\n@@ -377,6 +377,7 @@ begin -- Gen_IL.Gen.Gen_Entities\n         Sm (Original_Record_Component, Node_Id)));\n \n    Cc (E_Loop_Parameter, Object_Kind,\n+       --  A loop parameter created by a for loop\n        (Sm (Activation_Record_Component, Node_Id),\n         Sm (Alignment, Uint),\n         Sm (Esize, Uint),\n@@ -387,6 +388,7 @@ begin -- Gen_IL.Gen.Gen_Entities\n         Sm (Status_Flag_Or_Transient_Decl, Node_Id)));\n \n    Cc (E_Variable, Object_Kind,\n+       --  Variables created by an object declaration with no constant keyword\n        (Sm (Activation_Record_Component, Node_Id),\n         Sm (Actual_Subtype, Node_Id),\n         Sm (Alignment, Uint),\n@@ -428,6 +430,7 @@ begin -- Gen_IL.Gen.Gen_Entities\n         Sm (Validated_Object, Node_Id)));\n \n    Ab (Formal_Kind, Object_Kind,\n+       --  Formal parameters are also objects\n        (Sm (Activation_Record_Component, Node_Id),\n         Sm (Actual_Subtype, Node_Id),\n         Sm (Alignment, Uint),\n@@ -449,31 +452,41 @@ begin -- Gen_IL.Gen.Gen_Entities\n         Sm (Unset_Reference, Node_Id)));\n \n    Cc (E_Out_Parameter, Formal_Kind,\n+       --  An out parameter of a subprogram or entry\n        (Sm (Last_Assignment, Node_Id)));\n \n    Cc (E_In_Out_Parameter, Formal_Kind,\n+       --  An in-out parameter of a subprogram or entry\n        (Sm (Last_Assignment, Node_Id)));\n \n    Cc (E_In_Parameter, Formal_Kind,\n+       --  An in parameter of a subprogram or entry\n        (Sm (Discriminal_Link, Node_Id),\n         Sm (Discriminant_Default_Value, Node_Id),\n         Sm (Is_Activation_Record, Flag)));\n \n    Ab (Formal_Object_Kind, Object_Kind,\n+       --  Generic formal objects are also objects\n        (Sm (Entry_Component, Node_Id),\n         Sm (Esize, Uint)));\n \n    Cc (E_Generic_In_Out_Parameter, Formal_Object_Kind,\n+       --  A generic in out parameter, created by the use of a generic in out\n+       --  parameter in a generic declaration.\n        (Sm (Actual_Subtype, Node_Id)));\n \n    Cc (E_Generic_In_Parameter, Formal_Object_Kind);\n+       --  A generic in parameter, created by the use of a generic in\n+       --  parameter in a generic declaration.\n \n    Ab (Named_Kind, Entity_Kind,\n        (Sm (Renamed_Or_Alias, Node_Id)));\n \n    Cc (E_Named_Integer, Named_Kind);\n+   --  Named numbers created by a number declaration with an integer value\n \n    Cc (E_Named_Real, Named_Kind);\n+   --  Named numbers created by a number declaration with a real value\n \n    Ab (Type_Kind, Entity_Kind,\n        (Sm (Alignment, Uint),\n@@ -567,10 +580,13 @@ begin -- Gen_IL.Gen.Gen_Entities\n         Sm (Lit_Hash, Node_Id, Root_Type_Only)));\n \n    Cc (E_Enumeration_Type, Enumeration_Kind,\n+       --  Enumeration types, created by an enumeration type declaration\n        (Sm (Enum_Pos_To_Rep, Node_Id),\n         Sm (First_Entity, Node_Id)));\n \n    Cc (E_Enumeration_Subtype, Enumeration_Kind);\n+       --  Enumeration subtypes, created by an explicit or implicit subtype\n+       --  declaration applied to an enumeration type or subtype.\n \n    Ab (Integer_Kind, Discrete_Kind,\n        (Sm (Has_Shift_Operator, Flag, Base_Type_Only)));\n@@ -579,18 +595,28 @@ begin -- Gen_IL.Gen.Gen_Entities\n        (Sm (First_Entity, Node_Id)));\n \n    Cc (E_Signed_Integer_Type, Signed_Integer_Kind,\n+       --  Signed integer type, used for the anonymous base type of the\n+       --  integer subtype created by an integer type declaration.\n        (Sm (Direct_Primitive_Operations, Elist_Id,\n             Pre => \"Is_Tagged_Type (N)\")));\n \n    Cc (E_Signed_Integer_Subtype, Signed_Integer_Kind);\n+       --  Signed integer subtype, created by either an integer subtype or\n+       --  integer type declaration (in the latter case an integer type is\n+       --  created for the base type, and this is the first named subtype).\n \n    Ab (Modular_Integer_Kind, Integer_Kind,\n        (Sm (Modulus, Uint, Base_Type_Only),\n         Sm (Original_Array_Type, Node_Id)));\n \n    Cc (E_Modular_Integer_Type, Modular_Integer_Kind);\n+       --  Modular integer type, used for the anonymous base type of the\n+       --  integer subtype created by a modular integer type declaration.\n \n    Cc (E_Modular_Integer_Subtype, Modular_Integer_Kind);\n+       --  Modular integer subtype, created by either an modular subtype\n+       --  or modular type declaration (in the latter case a modular type\n+       --  is created for the base type, and this is the first named subtype).\n \n    Ab (Real_Kind, Scalar_Kind,\n        (Sm (Static_Real_Or_String_Predicate, Node_Id)));\n@@ -603,8 +629,14 @@ begin -- Gen_IL.Gen.Gen_Entities\n        (Sm (Has_Small_Clause, Flag)));\n \n    Cc (E_Ordinary_Fixed_Point_Type, Ordinary_Fixed_Point_Kind);\n+       --  Ordinary fixed type, used for the anonymous base type of the fixed\n+       --  subtype created by an ordinary fixed point type declaration.\n \n    Cc (E_Ordinary_Fixed_Point_Subtype, Ordinary_Fixed_Point_Kind);\n+       --  Ordinary fixed point subtype, created by either an ordinary fixed\n+       --  point subtype or ordinary fixed point type declaration (in the\n+       --  latter case a fixed point type is created for the base type, and\n+       --  this is the first named subtype).\n \n    Ab (Decimal_Fixed_Point_Kind, Fixed_Point_Kind,\n        (Sm (Digits_Value, Uint),\n@@ -613,16 +645,28 @@ begin -- Gen_IL.Gen.Gen_Entities\n         Sm (Scale_Value, Uint)));\n \n    Cc (E_Decimal_Fixed_Point_Type, Decimal_Fixed_Point_Kind);\n+       --  Decimal fixed type, used for the anonymous base type of the decimal\n+       --  fixed subtype created by an ordinary fixed point type declaration.\n \n    Cc (E_Decimal_Fixed_Point_Subtype, Decimal_Fixed_Point_Kind);\n+       --  Decimal fixed point subtype, created by either a decimal fixed point\n+       --  subtype or decimal fixed point type declaration (in the latter case\n+       --  a fixed point type is created for the base type, and this is the\n+       --  first named subtype).\n \n    Ab (Float_Kind, Real_Kind,\n        (Sm (Digits_Value, Uint),\n         Sm (Float_Rep, Float_Rep_Kind, Base_Type_Only)));\n \n    Cc (E_Floating_Point_Type, Float_Kind);\n+       --  Floating point type, used for the anonymous base type of the\n+       --  floating point subtype created by a floating point type declaration.\n \n    Cc (E_Floating_Point_Subtype, Float_Kind);\n+       --  Floating point subtype, created by either a floating point subtype\n+       --  or floating point type declaration (in the latter case a floating\n+       --  point type is created for the base type, and this is the first\n+       --  named subtype).\n \n    Ab (Access_Kind, Elementary_Kind,\n        (Sm (Associated_Storage_Pool, Node_Id, Root_Type_Only),\n@@ -640,41 +684,68 @@ begin -- Gen_IL.Gen.Gen_Entities\n         Sm (Storage_Size_Variable, Node_Id, Impl_Base_Type_Only)));\n \n    Cc (E_Access_Type, Access_Kind,\n+       --  An access type created by an access type declaration with no all\n+       --  keyword present. Note that the predefined type Any_Access, which\n+       --  has E_Access_Type Ekind, is used to label NULL in the upwards pass\n+       --  of type analysis, to be replaced by the true access type in the\n+       --  downwards resolution pass.\n        (Sm (Direct_Primitive_Operations, Elist_Id,\n             Pre => \"Is_Tagged_Type (N)\")));\n \n    Cc (E_Access_Subtype, Access_Kind);\n+       --  An access subtype created by a subtype declaration for any access\n+       --  type (whether or not it is a general access type).\n \n    Cc (E_Access_Attribute_Type, Access_Kind);\n+       --  An access type created for an access attribute (one of 'Access,\n+       --  'Unrestricted_Access, or Unchecked_Access).\n \n    Cc (E_Allocator_Type, Access_Kind);\n+       --  A special internal type used to label allocators and references to\n+       --  objects using 'Reference. This is needed because special resolution\n+       --  rules apply to these constructs. On the resolution pass, this type\n+       --  is almost always replaced by the actual access type, but if the\n+       --  context does not provide one, the backend will see Allocator_Type\n+       --  itself (which will already have been frozen).\n \n    Cc (E_General_Access_Type, Access_Kind,\n+       --  An access type created by an access type declaration with the all\n+       --  keyword present.\n        (Sm (First_Entity, Node_Id)));\n \n    Ab (Access_Subprogram_Kind, Access_Kind);\n \n    Cc (E_Access_Subprogram_Type, Access_Subprogram_Kind,\n+       --  An access-to-subprogram type, created by an access-to-subprogram\n+       --  declaration.\n        (Sm (Equivalent_Type, Node_Id),\n         Sm (Original_Access_Type, Node_Id)));\n \n    Ab (Access_Protected_Kind, Access_Subprogram_Kind,\n        (Sm (Equivalent_Type, Node_Id)));\n \n    Cc (E_Access_Protected_Subprogram_Type, Access_Protected_Kind);\n+       --  An access to a protected subprogram, created by the corresponding\n+       --  declaration. Values of such a type denote both a protected object\n+       --  and a protected operation within, and have different compile-time\n+       --  and run-time properties than other access-to-subprogram values.\n \n    Cc (E_Anonymous_Access_Protected_Subprogram_Type, Access_Protected_Kind);\n+       --  An anonymous access-to-protected-subprogram type, created by an\n+       --  access-to-subprogram declaration.\n \n    Cc (E_Anonymous_Access_Subprogram_Type, Access_Subprogram_Kind);\n+       --  An anonymous access-to-subprogram type, created by an access-to-\n+       --  subprogram declaration, or generated for a current instance of\n+       --  a type name appearing within a component definition that has an\n+       --  anonymous access-to-subprogram type.\n \n    Cc (E_Anonymous_Access_Type, Access_Kind);\n+   --  An anonymous access-to-object type\n \n    Ab (Composite_Kind, Type_Kind,\n---  ????This fails for the same reason as DT_Position of E_Function;\n---  see comment there.\n---       (Sm (Discriminant_Constraint, Elist_Id,\n---            Pre => \"Has_Discriminants (N) or else Is_Constrained (N)\")));\n-       (Sm (Discriminant_Constraint, Elist_Id)));\n+       (Sm (Discriminant_Constraint, Elist_Id,\n+            Pre_Get => \"Has_Discriminants (N) or else Is_Constrained (N)\")));\n \n    Ab (Aggregate_Kind, Composite_Kind,\n        (Sm (Component_Alignment, Component_Alignment_Kind, Base_Type_Only),\n@@ -694,17 +765,23 @@ begin -- Gen_IL.Gen.Gen_Entities\n         Sm (Related_Array_Object, Node_Id)));\n \n    Cc (E_Array_Type, Array_Kind,\n+       --  An array type created by an array type declaration. Includes all\n+       --  cases of arrays, except for string types.\n        (Sm (First_Entity, Node_Id),\n         Sm (Static_Real_Or_String_Predicate, Node_Id)));\n \n    Cc (E_Array_Subtype, Array_Kind,\n+       --  An array subtype, created by an explicit array subtype declaration,\n+       --  or the use of an anonymous array subtype.\n        (Sm (Predicated_Parent, Node_Id),\n         Sm (Direct_Primitive_Operations, Elist_Id,\n             Pre => \"Is_Tagged_Type (N)\"),\n         Sm (First_Entity, Node_Id),\n         Sm (Static_Real_Or_String_Predicate, Node_Id)));\n \n    Cc (E_String_Literal_Subtype, Array_Kind,\n+       --  A special string subtype, used only to describe the type of a string\n+       --  literal (will always be one dimensional, with literal bounds).\n        (Sm (String_Literal_Length, Uint),\n         Sm (String_Literal_Low_Bound, Node_Id)));\n \n@@ -725,13 +802,19 @@ begin -- Gen_IL.Gen.Gen_Entities\n         Sm (Stored_Constraint, Elist_Id)));\n \n    Cc (E_Class_Wide_Type, Class_Wide_Kind,\n+       --  A class wide type, created by any tagged type declaration (i.e. if\n+       --  a tagged type is declared, the corresponding class type is always\n+       --  created, using this Ekind value).\n        (Sm (Corresponding_Remote_Type, Node_Id),\n         Sm (Scalar_Range, Node_Id)));\n \n    Cc (E_Class_Wide_Subtype, Class_Wide_Kind,\n+       --  A subtype of a class wide type, created by a subtype declaration\n+       --  used to declare a subtype of a class type.\n        (Sm (Cloned_Subtype, Node_Id)));\n \n    Cc (E_Record_Type, Aggregate_Kind,\n+       --  A record type, created by a record type declaration\n        (Sm (Access_Disp_Table, Elist_Id, Impl_Base_Type_Only),\n         Sm (Access_Disp_Table_Elab_Flag, Node_Id, Impl_Base_Type_Only),\n         Sm (C_Pass_By_Copy, Flag, Impl_Base_Type_Only),\n@@ -752,6 +835,7 @@ begin -- Gen_IL.Gen.Gen_Entities\n         Sm (Underlying_Record_View, Node_Id)));\n \n    Cc (E_Record_Subtype, Aggregate_Kind,\n+       --  A record subtype, created by a record subtype declaration\n        (Sm (Access_Disp_Table, Elist_Id, Impl_Base_Type_Only),\n         Sm (Access_Disp_Table_Elab_Flag, Node_Id, Impl_Base_Type_Only),\n         Sm (C_Pass_By_Copy, Flag, Impl_Base_Type_Only),\n@@ -782,6 +866,11 @@ begin -- Gen_IL.Gen.Gen_Entities\n        (Sm (Underlying_Full_View, Node_Id)));\n \n    Cc (E_Record_Type_With_Private, Private_Kind,\n+       --  Used for types defined by a private extension declaration,\n+       --  and for tagged private types. Includes the fields for both\n+       --  private types and for record types (with the sole exception of\n+       --  Corresponding_Concurrent_Type which is obviously not needed). This\n+       --  entity is considered to be both a record type and a private type.\n        (Sm (Access_Disp_Table, Elist_Id, Impl_Base_Type_Only),\n         Sm (Access_Disp_Table_Elab_Flag, Node_Id, Impl_Base_Type_Only),\n         Sm (C_Pass_By_Copy, Flag, Impl_Base_Type_Only),\n@@ -802,6 +891,7 @@ begin -- Gen_IL.Gen.Gen_Entities\n         Sm (Underlying_Record_View, Node_Id)));\n \n    Cc (E_Record_Subtype_With_Private, Private_Kind,\n+       --  A subtype of a type defined by a private extension declaration\n        (Sm (C_Pass_By_Copy, Flag, Impl_Base_Type_Only),\n         Sm (Component_Alignment, Component_Alignment_Kind, Base_Type_Only),\n         Sm (Corresponding_Remote_Type, Node_Id),\n@@ -820,21 +910,29 @@ begin -- Gen_IL.Gen.Gen_Entities\n         Sm (SSO_Set_Low_By_Default, Flag, Base_Type_Only)));\n \n    Cc (E_Private_Type, Private_Kind,\n+       --  A private type, created by a private type declaration that has\n+       --  neither the keyword limited nor the keyword tagged.\n        (Sm (Direct_Primitive_Operations, Elist_Id,\n             Pre => \"Is_Tagged_Type (N)\"),\n         Sm (Scalar_Range, Node_Id),\n         Sm (Scope_Depth_Value, Uint)));\n \n    Cc (E_Private_Subtype, Private_Kind,\n+       --  A subtype of a private type, created by a subtype declaration used\n+       --  to declare a subtype of a private type.\n        (Sm (Direct_Primitive_Operations, Elist_Id,\n             Pre => \"Is_Tagged_Type (N)\"),\n         Sm (Scope_Depth_Value, Uint)));\n \n    Cc (E_Limited_Private_Type, Private_Kind,\n+       --  A limited private type, created by a private type declaration that\n+       --  has the keyword limited, but not the keyword tagged.\n        (Sm (Scalar_Range, Node_Id),\n         Sm (Scope_Depth_Value, Uint)));\n \n    Cc (E_Limited_Private_Subtype, Private_Kind,\n+       --  A subtype of a limited private type, created by a subtype declaration\n+       --  used to declare a subtype of a limited private type.\n        (Sm (Scope_Depth_Value, Uint)));\n \n    Ab (Incomplete_Kind, Incomplete_Or_Private_Kind,\n@@ -843,9 +941,12 @@ begin -- Gen_IL.Gen.Gen_Entities\n         Sm (Non_Limited_View, Node_Id)));\n \n    Cc (E_Incomplete_Type, Incomplete_Kind,\n+       --  An incomplete type, created by an incomplete type declaration\n        (Sm (Scalar_Range, Node_Id)));\n \n    Cc (E_Incomplete_Subtype, Incomplete_Kind);\n+       --  An incomplete subtype, created by a subtype declaration where the\n+       --  subtype mark denotes an incomplete type.\n \n    Ab (Concurrent_Kind, Composite_Kind,\n        (Sm (Corresponding_Record_Type, Node_Id),\n@@ -866,31 +967,46 @@ begin -- Gen_IL.Gen.Gen_Entities\n         Sm (Task_Body_Procedure, Node_Id)));\n \n    Cc (E_Task_Type, Task_Kind,\n+       --  A task type, created by a task type declaration. An entity with this\n+       --  Ekind is also created to describe the anonymous type of a task that\n+       --  is created by a single task declaration.\n        (Sm (Anonymous_Object, Node_Id),\n         Sm (Ignore_SPARK_Mode_Pragmas, Flag),\n         Sm (SPARK_Aux_Pragma, Node_Id),\n         Sm (SPARK_Aux_Pragma_Inherited, Flag)));\n \n    Cc (E_Task_Subtype, Task_Kind);\n+       --  A subtype of a task type, created by a subtype declaration used to\n+       --  declare a subtype of a task type.\n \n    Ab (Protected_Kind, Concurrent_Kind,\n        (Sm (Entry_Bodies_Array, Node_Id,\n             Pre => \"Has_Entries (N)\"),\n         Sm (Uses_Lock_Free, Flag)));\n \n    Cc (E_Protected_Type, Protected_Kind,\n+       --  A protected type, created by a protected type declaration. An entity\n+       --  with this Ekind is also created to describe the anonymous type of\n+       --  a protected object created by a single protected declaration.\n        (Sm (Anonymous_Object, Node_Id),\n         Sm (Entry_Max_Queue_Lengths_Array, Node_Id),\n         Sm (Ignore_SPARK_Mode_Pragmas, Flag),\n         Sm (SPARK_Aux_Pragma, Node_Id),\n         Sm (SPARK_Aux_Pragma_Inherited, Flag)));\n \n    Cc (E_Protected_Subtype, Protected_Kind);\n+       --  A subtype of a protected type, created by a subtype declaration used\n+       --  to declare a subtype of a protected type.\n \n    Cc (E_Exception_Type, Type_Kind,\n+       --  The type of an exception created by an exception declaration\n        (Sm (Equivalent_Type, Node_Id)));\n \n    Cc (E_Subprogram_Type, Type_Kind,\n+       --  This is the designated type of an Access_To_Subprogram. Has type and\n+       --  signature like a subprogram entity, so can appear in calls, which\n+       --  are resolved like regular calls, except that such an entity is not\n+       --  overloadable.\n        (Sm (Access_Subprogram_Wrapper, Node_Id),\n         Sm (Extra_Accessibility_Of_Result, Node_Id),\n         Sm (Extra_Formals, Node_Id),\n@@ -907,6 +1023,8 @@ begin -- Gen_IL.Gen.Gen_Entities\n         Sm (Requires_Overriding, Flag)));\n \n    Cc (E_Enumeration_Literal, Overloadable_Kind,\n+       --  An enumeration literal, created by the use of the literal in an\n+       --  enumeration type definition.\n        (Sm (Enumeration_Pos, Uint),\n         Sm (Enumeration_Rep, Uint),\n         Sm (Enumeration_Rep_Expr, Node_Id),\n@@ -942,17 +1060,14 @@ begin -- Gen_IL.Gen.Gen_Entities\n         Sm (Subps_Index, Uint)));\n \n    Cc (E_Function, Subprogram_Kind,\n+       --  A function, created by a function declaration or a function body\n+       --  that acts as its own declaration.\n        (Sm (Anonymous_Masters, Elist_Id),\n         Sm (Corresponding_Equality, Node_Id,\n             Pre => \"not Comes_From_Source (N) and then Chars (N) = Name_Op_Ne\"),\n         Sm (Corresponding_Procedure, Node_Id),\n---  ????In the old version, we had the following assertion in the getter, but\n---  not the setter, and in fact we sometimes violate it in the setter, for\n---  example, sem_disp.adb:1635 says \"Set_DT_Position_Value (Subp, No_Uint);\".\n---        Sm (DT_Position, Uint,\n---            Pre => \"Present (DTC_Entity (N))\"),\n---  Perhaps we should have \"getter-only preconditions\".\n-        Sm (DT_Position, Uint),\n+        Sm (DT_Position, Uint,\n+            Pre_Get => \"Present (DTC_Entity (N))\"),\n         Sm (DTC_Entity, Node_Id),\n         Sm (Extra_Accessibility_Of_Result, Node_Id),\n         Sm (Generic_Renamings, Elist_Id),\n@@ -986,16 +1101,20 @@ begin -- Gen_IL.Gen.Gen_Entities\n             Pre => \"Is_Primitive_Wrapper (N)\")));\n \n    Cc (E_Operator, Subprogram_Kind,\n+       --  A predefined operator, appearing in Standard, or an implicitly\n+       --  defined concatenation operator created whenever an array is declared.\n+       --  We do not make normal derived operators explicit in the tree, but the\n+       --  concatenation operators are made explicit.\n        (Sm (Extra_Accessibility_Of_Result, Node_Id)));\n \n    Cc (E_Procedure, Subprogram_Kind,\n+       --  A procedure, created by a procedure declaration or a procedure\n+       --  body that acts as its own declaration.\n        (Sm (Anonymous_Masters, Elist_Id),\n         Sm (Associated_Node_For_Itype, Node_Id),\n         Sm (Corresponding_Function, Node_Id),\n---  ????See comment in E_Function.\n---        Sm (DT_Position, Uint,\n---            Pre => \"Present (DTC_Entity (N))\"),\n-        Sm (DT_Position, Uint),\n+        Sm (DT_Position, Uint,\n+            Pre_Get => \"Present (DTC_Entity (N))\"),\n         Sm (DTC_Entity, Node_Id),\n         Sm (Entry_Parameters_Type, Node_Id),\n         Sm (Generic_Renamings, Elist_Id),\n@@ -1031,6 +1150,9 @@ begin -- Gen_IL.Gen.Gen_Entities\n             Pre => \"Is_Primitive_Wrapper (N)\")));\n \n    Cc (E_Abstract_State, Overloadable_Kind,\n+       --  A state abstraction. Used to designate entities introduced by aspect\n+       --  or pragma Abstract_State. The entity carries the various properties\n+       --  of the state.\n        (Sm (Body_References, Elist_Id),\n         Sm (Encapsulating_State, Node_Id),\n         Sm (First_Entity, Node_Id),\n@@ -1043,6 +1165,8 @@ begin -- Gen_IL.Gen.Gen_Entities\n         Sm (SPARK_Pragma_Inherited, Flag)));\n \n    Cc (E_Entry, Overloadable_Kind,\n+       --  An entry, created by an entry declaration in a task or protected\n+       --  object.\n        (Sm (Accept_Address, Elist_Id),\n         Sm (Barrier_Function, Node_Id),\n         Sm (Contract, Node_Id),\n@@ -1065,6 +1189,8 @@ begin -- Gen_IL.Gen.Gen_Entities\n         Sm (SPARK_Pragma_Inherited, Flag)));\n \n    Cc (E_Entry_Family, Entity_Kind,\n+       --  An entry family, created by an entry family declaration in a\n+       --  task or protected type definition.\n        (Sm (Accept_Address, Elist_Id),\n         Sm (Barrier_Function, Node_Id),\n         Sm (Contract, Node_Id),\n@@ -1090,6 +1216,8 @@ begin -- Gen_IL.Gen.Gen_Entities\n         Sm (SPARK_Pragma_Inherited, Flag)));\n \n    Cc (E_Block, Entity_Kind,\n+       --  A block identifier, created by an explicit or implicit label on\n+       --  a block or declare statement.\n        (Sm (Block_Node, Node_Id),\n         Sm (Entry_Cancel_Parameter, Node_Id),\n         Sm (First_Entity, Node_Id),\n@@ -1100,9 +1228,14 @@ begin -- Gen_IL.Gen.Gen_Entities\n         Sm (Scope_Depth_Value, Uint)));\n \n    Cc (E_Entry_Index_Parameter, Entity_Kind,\n+       --  An entry index parameter created by an entry index specification\n+       --  for the body of a protected entry family.\n        (Sm (Entry_Index_Constant, Node_Id)));\n \n    Cc (E_Exception, Entity_Kind,\n+       --  An exception created by an exception declaration. The exception\n+       --  itself uses E_Exception for the Ekind, the implicit type that is\n+       --  created to represent its type uses the Ekind E_Exception_Type.\n        (Sm (Alignment, Uint),\n         Sm (Esize, Uint),\n         Sm (Interface_Name, Node_Id),\n@@ -1135,11 +1268,17 @@ begin -- Gen_IL.Gen.Gen_Entities\n         Sm (Overridden_Operation, Node_Id)));\n \n    Cc (E_Generic_Function, Generic_Subprogram_Kind,\n+       --  A generic function. This is the entity for a generic function\n+       --  created by a generic subprogram declaration.\n        (Sm (Has_Missing_Return, Flag)));\n \n    Cc (E_Generic_Procedure, Generic_Subprogram_Kind);\n+       --  A generic function. This is the entity for a generic procedure\n+       --  created by a generic subprogram declaration.\n \n    Cc (E_Generic_Package, Generic_Unit_Kind,\n+       --  A generic package, this is the entity for a generic package created\n+       --  by a generic package declaration.\n        (Sm (Abstract_States, Elist_Id),\n         Sm (Body_Entity, Node_Id),\n         Sm (First_Private_Entity, Node_Id),\n@@ -1149,10 +1288,15 @@ begin -- Gen_IL.Gen.Gen_Entities\n         Sm (SPARK_Aux_Pragma_Inherited, Flag)));\n \n    Cc (E_Label, Entity_Kind,\n+       --  The defining entity for a label. Note that this is created by the\n+       --  implicit label declaration, not the occurrence of the label itself,\n+       --  which is simply a direct name referring to the label.\n        (Sm (Enclosing_Scope, Node_Id),\n         Sm (Renamed_Or_Alias, Node_Id)));\n \n    Cc (E_Loop, Entity_Kind,\n+       --  A loop identifier, created by an explicit or implicit label on a\n+       --  loop statement.\n        (Sm (First_Entity, Node_Id),\n         Sm (First_Exit_Statement, Node_Id),\n         Sm (Has_Loop_Entry_Attributes, Flag),\n@@ -1161,12 +1305,19 @@ begin -- Gen_IL.Gen.Gen_Entities\n         Sm (Scope_Depth_Value, Uint)));\n \n    Cc (E_Return_Statement, Entity_Kind,\n+       --  A dummy entity created for each return statement. Used to hold\n+       --  information about the return statement (what it applies to) and in\n+       --  rules checking. For example, a simple_return_statement that applies\n+       --  to an extended_return_statement cannot have an expression; this\n+       --  requires putting the E_Return_Statement entity for the\n+       --  extended_return_statement on the scope stack.\n        (Sm (First_Entity, Node_Id),\n         Sm (Last_Entity, Node_Id),\n         Sm (Return_Applies_To, Node_Id),\n         Sm (Scope_Depth_Value, Uint)));\n \n    Cc (E_Package, Entity_Kind,\n+       --  A package, created by a package declaration\n        (Sm (Abstract_States, Elist_Id),\n         Sm (Anonymous_Masters, Elist_Id),\n         Sm (Associated_Formal_Package, Node_Id),\n@@ -1209,6 +1360,10 @@ begin -- Gen_IL.Gen.Gen_Entities\n         Sm (Static_Elaboration_Desired, Flag)));\n \n    Cc (E_Package_Body, Entity_Kind,\n+       --  A package body. This entity serves only limited functions, since\n+       --  most semantic analysis uses the package entity (E_Package). However\n+       --  there are some attributes that are significant for the body entity.\n+       --  For example, collection of exception handlers.\n        (Sm (Contract, Node_Id),\n         Sm (Finalizer, Node_Id),\n         Sm (First_Entity, Node_Id),\n@@ -1230,12 +1385,20 @@ begin -- Gen_IL.Gen.Gen_Entities\n         Sm (SPARK_Pragma_Inherited, Flag)));\n \n    Cc (E_Protected_Body, Concurrent_Body_Kind);\n+       --  A protected body. This entity serves almost no function, since all\n+       --  semantic analysis uses the protected entity (E_Protected_Type).\n \n    Cc (E_Task_Body, Concurrent_Body_Kind,\n+       --  A task body. This entity serves almost no function, since all\n+       --  semantic analysis uses the protected entity (E_Task_Type).\n        (Sm (Contract, Node_Id),\n         Sm (First_Entity, Node_Id)));\n \n    Cc (E_Subprogram_Body, Entity_Kind,\n+       --  A subprogram body. Used when a subprogram has a separate declaration\n+       --  to represent the entity for the body. This entity serves almost no\n+       --  function, since all semantic analysis uses the subprogram entity\n+       --  for the declaration (E_Function or E_Procedure).\n        (Sm (Anonymous_Masters, Elist_Id),\n         Sm (Contract, Node_Id),\n         Sm (Extra_Formals, Node_Id),\n@@ -1278,6 +1441,16 @@ begin -- Gen_IL.Gen.Gen_Entities\n             (E_Entry,\n              E_Entry_Family));\n \n+   Union (Named_Access_Kind,\n+          Children =>\n+            (E_Access_Type,\n+             E_Access_Subtype,\n+             E_Access_Attribute_Type,\n+             E_Allocator_Type,\n+             E_General_Access_Type,\n+             E_Access_Subprogram_Type,\n+             E_Access_Protected_Subprogram_Type));\n+\n    Union (Numeric_Kind,\n           Children =>\n             (Integer_Kind,"}, {"sha": "2405fd75bb812afc28345f5e83a72aa02413c966", "filename": "gcc/ada/gen_il-gen-gen_nodes.adb", "status": "modified", "additions": 36, "deletions": 17, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7cadd18606c9c3ce2776b6f876ca98849b24b84/gcc%2Fada%2Fgen_il-gen-gen_nodes.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7cadd18606c9c3ce2776b6f876ca98849b24b84/gcc%2Fada%2Fgen_il-gen-gen_nodes.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgen_il-gen-gen_nodes.adb?ref=a7cadd18606c9c3ce2776b6f876ca98849b24b84", "patch": "@@ -37,35 +37,22 @@ procedure Gen_IL.Gen.Gen_Nodes is\n    function Sy -- Short for \"Syntactic\"\n      (Field : Node_Field; Field_Type : Type_Enum;\n       Default_Value : Field_Default_Value := No_Default;\n-      Pre : String := \"\") return Field_Desc\n+      Pre, Pre_Get, Pre_Set : String := \"\") return Field_Desc\n       renames Create_Syntactic_Field;\n    function Sm -- Short for \"Semantic\"\n      (Field : Field_Enum; Field_Type : Type_Enum;\n       Type_Only  : Type_Only_Enum := No_Type_Only;\n-      Pre : String := \"\") return Field_Desc\n+      Pre, Pre_Get, Pre_Set : String := \"\") return Field_Desc\n       renames Create_Semantic_Field;\n \n    procedure Union (T : Abstract_Node; Children : Type_Array)\n-     renames Create_Node_Union;\n+     renames Create_Node_Union_Type;\n \n begin -- Gen_IL.Gen.Gen_Nodes\n    pragma Style_Checks (\"M200\");\n \n-   --  N_Empty should not inherit all of these fields????\n-   --  But the following getters and setters are called on Empty:\n-   --\n-   --  Set_Comes_From_Source\n-   --  Set_Sloc\n-   --\n-   --  Comes_From_Source\n-   --  Error_Posted\n-   --  In_List\n-   --  Link\n-   --  Rewrite_Ins\n-   --  Sloc\n-   --  Small_Paren_Count\n    Create_Root_Node_Type (Node_Kind,\n-       (Sm (Nkind, Nkind_Type),\n+       (Sm (Nkind, Node_Kind_Type),\n         Sm (Sloc, Source_Ptr),\n         Sm (In_List, Flag),\n         Sm (Rewrite_Ins, Flag),\n@@ -121,6 +108,19 @@ begin -- Gen_IL.Gen.Gen_Nodes\n \n    Cc (N_Empty, Node_Kind,\n        (Sy (Chars, Name_Id, Default_No_Name)));\n+   --  The following getters and setters are called on Empty,\n+   --  and are currently inherited from Node_Kind:\n+   --\n+   --  Set_Comes_From_Source\n+   --  Set_Sloc\n+   --\n+   --  Comes_From_Source\n+   --  Error_Posted\n+   --  In_List\n+   --  Link\n+   --  Rewrite_Ins\n+   --  Sloc\n+   --  Small_Paren_Count\n \n    Cc (N_Pragma_Argument_Association, Node_Kind,\n        (Sy (Chars, Name_Id, Default_No_Name),\n@@ -147,6 +147,7 @@ begin -- Gen_IL.Gen.Gen_Nodes\n        (Sy (Chars, Name_Id, Default_No_Name)));\n \n    Ab (N_Subexpr, N_Has_Etype,\n+   --  Nodes with expression fields\n        (Sm (Assignment_OK, Flag),\n         Sm (Do_Range_Check, Flag),\n         Sm (Has_Dynamic_Length_Check, Flag),\n@@ -157,6 +158,9 @@ begin -- Gen_IL.Gen.Gen_Nodes\n         Sm (Raises_Constraint_Error, Flag)));\n \n    Ab (N_Has_Entity, N_Subexpr,\n+   --  Nodes that have Entity fields\n+   --  Warning: DOES NOT INCLUDE N_Freeze_Entity, N_Freeze_Generic_Entity,\n+   --  N_Aspect_Specification, or N_Attribute_Definition_Clause.\n        (Sm (Entity_Or_Associated_Node, Node_Id))); -- both\n \n    Cc (N_Expanded_Name, N_Has_Entity,\n@@ -247,6 +251,8 @@ begin -- Gen_IL.Gen.Gen_Nodes\n         Sm (Do_Division_Check, Flag)));\n \n    Ab (N_Op_Boolean, N_Binary_Op);\n+   --  Binary operators that take operands of a boolean type, and yield a\n+   --  result of a boolean type.\n \n    Cc (N_Op_And, N_Op_Boolean,\n        (Sm (Chars, Name_Id),\n@@ -566,6 +572,8 @@ begin -- Gen_IL.Gen.Gen_Nodes\n         Sm (Must_Not_Freeze, Flag)));\n \n    Ab (N_Declaration, Node_Kind);\n+   --  Note: this includes all constructs normally thought of as declarations\n+   --  except those which are separately grouped as later declarations.\n \n    Cc (N_Component_Declaration, N_Declaration,\n        (Sy (Defining_Identifier, Node_Id),\n@@ -717,6 +725,13 @@ begin -- Gen_IL.Gen.Gen_Nodes\n         Sy (Parameter_Specifications, List_Id, Default_No_List)));\n \n    Ab (N_Later_Decl_Item, Node_Kind);\n+   --  Note: this is Ada 83 relevant only (see Ada 83 RM 3.9 (2)) and includes\n+   --  only those items which can appear as later declarative items. This also\n+   --  includes N_Implicit_Label_Declaration which is not specifically in the\n+   --  grammar but may appear as a valid later declarative items. It does NOT\n+   --  include N_Pragma which can also appear among later declarative items.\n+   --  It does however include N_Protected_Body, which is a bit peculiar, but\n+   --  harmless since this cannot appear in Ada 83 mode anyway.\n \n    Cc (N_Task_Type_Declaration, N_Later_Decl_Item,\n        (Sy (Defining_Identifier, Node_Id),\n@@ -911,6 +926,10 @@ begin -- Gen_IL.Gen.Gen_Nodes\n         Sy (Name, Node_Id, Default_Empty)));\n \n    Ab (N_Statement_Other_Than_Procedure_Call, Node_Kind);\n+   --  Note that this includes all statement types except for the cases of the\n+   --  N_Procedure_Call_Statement which is considered to be a subexpression\n+   --  (since overloading is possible, so it needs to go through the normal\n+   --  overloading resolution for expressions).\n \n    Cc (N_Abort_Statement, N_Statement_Other_Than_Procedure_Call,\n        (Sy (Names, List_Id)));"}, {"sha": "6349841139bfd0407bc6306dc762c8a133028922", "filename": "gcc/ada/gen_il-gen.adb", "status": "modified", "additions": 504, "deletions": 229, "changes": 733, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7cadd18606c9c3ce2776b6f876ca98849b24b84/gcc%2Fada%2Fgen_il-gen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7cadd18606c9c3ce2776b6f876ca98849b24b84/gcc%2Fada%2Fgen_il-gen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgen_il-gen.adb?ref=a7cadd18606c9c3ce2776b6f876ca98849b24b84", "patch": "@@ -39,36 +39,41 @@ package body Gen_IL.Gen is\n    Inline : constant String := \"Inline\";\n    --  For experimenting with Inline_Always\n \n-   Is_Syntactic : Fields_Per_Node_Type :=\n+   Syntactic : Fields_Per_Node_Type :=\n      (others => (others => False));\n \n    Nodes_And_Entities : constant Type_Vector := Node_Kind & Entity_Kind;\n    All_Entities : constant Type_Vector := To_Vector (Entity_Kind, Length => 1);\n \n    procedure Create_Type\n-     (T : Node_Or_Entity_Type; Parent : Opt_Abstract_Type;\n+     (T      : Node_Or_Entity_Type;\n+      Parent : Opt_Abstract_Type;\n       Fields : Field_Sequence);\n    --  Called by the Create_..._Type procedures exported by this package to\n    --  create an entry in the Types_Table.\n \n    procedure Create_Union_Type\n      (Root : Root_Type; T : Abstract_Type; Children : Type_Array);\n-   --  Called by Create_Node_Union and Create_Entity_Union to create a union\n-   --  type.\n+   --  Called by Create_Node_Union_Type and Create_Entity_Union_Type to create\n+   --  a union type.\n \n    function Create_Field\n-     (Field      : Field_Enum;\n-      Field_Type : Type_Enum;\n-      Default_Value : Field_Default_Value;\n-      Type_Only  : Type_Only_Enum;\n-      Pre        : String;\n-      Is_Syntactic : Boolean) return Field_Desc;\n+     (Field                 : Field_Enum;\n+      Field_Type            : Type_Enum;\n+      Default_Value         : Field_Default_Value;\n+      Type_Only             : Type_Only_Enum;\n+      Pre, Pre_Get, Pre_Set : String;\n+      Is_Syntactic          : Boolean) return Field_Desc;\n    --  Called by the Create_..._Field functions exported by this package to\n    --  create an entry in the Field_Table. See Create_Syntactic_Field and\n    --  Create_Semantic_Field for additional doc.\n \n    procedure Check_Type (T : Node_Or_Entity_Type);\n-   --  Check some \"legality\" rules\n+   --  Check some \"legality\" rules for types in the Gen_IL little language\n+\n+   ----------------\n+   -- Check_Type --\n+   ----------------\n \n    procedure Check_Type (T : Node_Or_Entity_Type) is\n       Im : constant String := Node_Or_Entity_Type'Image (T);\n@@ -96,8 +101,13 @@ package body Gen_IL.Gen is\n       end if;\n    end Check_Type;\n \n+   -----------------\n+   -- Create_Type --\n+   -----------------\n+\n    procedure Create_Type\n-     (T : Node_Or_Entity_Type; Parent : Opt_Abstract_Type;\n+     (T      : Node_Or_Entity_Type;\n+      Parent : Opt_Abstract_Type;\n       Fields : Field_Sequence)\n    is\n    begin\n@@ -121,16 +131,15 @@ package body Gen_IL.Gen is\n         new Type_Info'\n           (Is_Union => False, Parent => Parent,\n            Children | Concrete_Descendants => Type_Vectors.Empty_Vector,\n-           First | Last | Fields => <>,\n-           Allow_Overlap => False);\n+           First | Last | Fields => <>); -- filled in later\n \n       if Parent /= No_Type then\n          Append (Type_Table (Parent).Children, T);\n       end if;\n \n       --  Check that syntactic fields precede semantic fields. Note that this\n       --  check is happening before we compute inherited fields.\n-      --  ????Exempt Chars and Actions from this rule, for now.\n+      --  Exempt Chars and Actions from this rule, for now.\n \n       declare\n          Semantic_Seen : Boolean := False;\n@@ -150,6 +159,35 @@ package body Gen_IL.Gen is\n          end loop;\n       end;\n \n+      --  Check that node fields are in nodes, and entity fields are in\n+      --  entities.\n+\n+      for J in Fields'Range loop\n+         declare\n+            Field : constant Field_Enum := Fields (J).F;\n+            Error_Prefix : constant String :=\n+              \"Field \" & Image (T) & \".\" & Image (Field) & \" not in \";\n+         begin\n+            case T is\n+               when Node_Type =>\n+                  if Field not in Node_Field then\n+                     raise Illegal with Error_Prefix & \"Node_Field\";\n+                  end if;\n+\n+               when Entity_Type =>\n+                  if Field not in Entity_Field then\n+                     raise Illegal with Error_Prefix & \"Entity_Field\";\n+                  end if;\n+\n+               when Type_Boundaries =>\n+                  raise Program_Error; -- dummy types shouldn't have fields\n+            end case;\n+         end;\n+      end loop;\n+\n+      --  Compute the Have_This_Field component of fields, the Fields component\n+      --  of the current type, and Syntactic table.\n+\n       for J in Fields'Range loop\n          declare\n             Field : constant Field_Enum := Fields (J).F;\n@@ -159,77 +197,119 @@ package body Gen_IL.Gen is\n             Append (Field_Table (Field).Have_This_Field, T);\n             Append (Type_Table (T).Fields, Field);\n \n-            pragma Assert (not Gen.Is_Syntactic (T) (Field));\n-            Gen.Is_Syntactic (T) (Field) := Is_Syntactic;\n+            pragma Assert (not Syntactic (T) (Field));\n+            Syntactic (T) (Field) := Is_Syntactic;\n          end;\n       end loop;\n    end Create_Type;\n \n    --  Other than constraint checks on T at the call site, and the lack of a\n    --  parent for root types, the following six all do the same thing.\n \n+   ---------------------------\n+   -- Create_Root_Node_Type --\n+   ---------------------------\n+\n    procedure Create_Root_Node_Type\n-     (T : Abstract_Node;\n+     (T      : Abstract_Node;\n       Fields : Field_Sequence := No_Fields) is\n    begin\n       Create_Type (T, Parent => No_Type, Fields => Fields);\n    end Create_Root_Node_Type;\n \n+   -------------------------------\n+   -- Create_Abstract_Node_Type --\n+   -------------------------------\n+\n    procedure Create_Abstract_Node_Type\n-     (T : Abstract_Node; Parent : Abstract_Type;\n+     (T      : Abstract_Node; Parent : Abstract_Type;\n       Fields : Field_Sequence := No_Fields)\n    is\n    begin\n       Create_Type (T, Parent, Fields);\n    end Create_Abstract_Node_Type;\n \n+   -------------------------------\n+   -- Create_Concrete_Node_Type --\n+   -------------------------------\n+\n    procedure Create_Concrete_Node_Type\n-     (T : Concrete_Node; Parent : Abstract_Type;\n+     (T      : Concrete_Node; Parent : Abstract_Type;\n       Fields : Field_Sequence := No_Fields)\n    is\n    begin\n       Create_Type (T, Parent, Fields);\n    end Create_Concrete_Node_Type;\n \n+   -----------------------------\n+   -- Create_Root_Entity_Type --\n+   -----------------------------\n+\n    procedure Create_Root_Entity_Type\n-     (T : Abstract_Entity;\n+     (T      : Abstract_Entity;\n       Fields : Field_Sequence := No_Fields) is\n    begin\n       Create_Type (T, Parent => No_Type, Fields => Fields);\n    end Create_Root_Entity_Type;\n \n+   ---------------------------------\n+   -- Create_Abstract_Entity_Type --\n+   ---------------------------------\n+\n    procedure Create_Abstract_Entity_Type\n-     (T : Abstract_Entity; Parent : Abstract_Type;\n+     (T      : Abstract_Entity; Parent : Abstract_Type;\n       Fields : Field_Sequence := No_Fields)\n    is\n    begin\n       Create_Type (T, Parent, Fields);\n    end Create_Abstract_Entity_Type;\n \n+   ---------------------------------\n+   -- Create_Concrete_Entity_Type --\n+   ---------------------------------\n+\n    procedure Create_Concrete_Entity_Type\n-     (T : Concrete_Entity; Parent : Abstract_Type;\n+     (T      : Concrete_Entity; Parent : Abstract_Type;\n       Fields : Field_Sequence := No_Fields)\n    is\n    begin\n       Create_Type (T, Parent, Fields);\n    end Create_Concrete_Entity_Type;\n \n+   ------------------\n+   -- Create_Field --\n+   ------------------\n+\n    function Create_Field\n-     (Field      : Field_Enum;\n-      Field_Type : Type_Enum;\n-      Default_Value : Field_Default_Value;\n-      Type_Only  : Type_Only_Enum;\n-      Pre        : String;\n-      Is_Syntactic : Boolean) return Field_Desc\n+     (Field                 : Field_Enum;\n+      Field_Type            : Type_Enum;\n+      Default_Value         : Field_Default_Value;\n+      Type_Only             : Type_Only_Enum;\n+      Pre, Pre_Get, Pre_Set : String;\n+      Is_Syntactic          : Boolean) return Field_Desc\n    is\n    begin\n+      --  Note that this function has the side effect of update the\n+      --  Field_Table.\n+\n       pragma Assert (if Default_Value /= No_Default then Is_Syntactic);\n       pragma Assert (if Type_Only /= No_Type_Only then not Is_Syntactic);\n \n+      --  First time this field has been seen; create an entry in the\n+      --  Field_Table.\n+\n       if Field_Table (Field) = null then\n          Field_Table (Field) := new Field_Info'\n            (Type_Vectors.Empty_Vector, Field_Type, Default_Value, Type_Only,\n-            Pre => new String'(Pre), Offset => <>);\n+            Pre => new String'(Pre),\n+            Pre_Get => new String'(Pre_Get),\n+            Pre_Set => new String'(Pre_Set),\n+            Offset => <>); -- filled in later\n+\n+      --  The Field_Table entry has already been created by the 'then' part\n+      --  above. Now we're seeing the same field being \"created\" again in a\n+      --  different type. Here we check consistency of this new Create_Field\n+      --  call with the old one.\n \n       else\n          if Field_Type /= Field_Table (Field).Field_Type then\n@@ -241,6 +321,9 @@ package body Gen_IL.Gen is\n          --  could be stricter; it currently allows a field to have No_Default\n          --  in one type, but something else in another type. In that case, we\n          --  use the \"something else\" for all types.\n+         --\n+         --  Note that the order of calls does not matter; a default value\n+         --  always overrides a No_Default value.\n \n          if Is_Syntactic then\n             if Default_Value /= Field_Table (Field).Default_Value then\n@@ -261,34 +344,61 @@ package body Gen_IL.Gen is\n             raise Illegal with\n               \"mismatched extra preconditions for \" & Image (Field);\n          end if;\n+\n+         if Pre_Get /= Field_Table (Field).Pre_Get.all then\n+            raise Illegal with\n+              \"mismatched extra getter-only preconditions for \" &\n+              Image (Field);\n+         end if;\n+\n+         if Pre /= Field_Table (Field).Pre.all then\n+            raise Illegal with\n+              \"mismatched extra setter-only preconditions for \" &\n+              Image (Field);\n+         end if;\n       end if;\n \n       return (Field, Is_Syntactic);\n    end Create_Field;\n \n+   ----------------------------\n+   -- Create_Syntactic_Field --\n+   ----------------------------\n+\n    function Create_Syntactic_Field\n      (Field      : Node_Field;\n       Field_Type : Type_Enum;\n       Default_Value : Field_Default_Value := No_Default;\n-      Pre        : String := \"\") return Field_Desc\n+      Pre, Pre_Get, Pre_Set : String := \"\") return Field_Desc\n    is\n    begin\n       return Create_Field\n-        (Field, Field_Type, Default_Value, No_Type_Only, Pre,\n+        (Field, Field_Type, Default_Value, No_Type_Only,\n+         Pre, Pre_Get, Pre_Set,\n          Is_Syntactic => True);\n    end Create_Syntactic_Field;\n \n+   ---------------------------\n+   -- Create_Semantic_Field --\n+   ---------------------------\n+\n    function Create_Semantic_Field\n      (Field      : Field_Enum;\n       Field_Type : Type_Enum;\n       Type_Only  : Type_Only_Enum := No_Type_Only;\n-      Pre        : String := \"\") return Field_Desc\n+      Pre, Pre_Get, Pre_Set : String := \"\") return Field_Desc\n    is\n    begin\n       return Create_Field\n-        (Field, Field_Type, No_Default, Type_Only, Pre, Is_Syntactic => False);\n+        (Field, Field_Type, No_Default, Type_Only,\n+         Pre, Pre_Get, Pre_Set,\n+         Is_Syntactic => False);\n    end Create_Semantic_Field;\n \n+   -----------------------\n+   -- Create_Union_Type --\n+   -----------------------\n+\n    procedure Create_Union_Type\n      (Root : Root_Type; T : Abstract_Type; Children : Type_Array)\n    is\n@@ -326,16 +436,29 @@ package body Gen_IL.Gen is\n       end loop;\n    end Create_Union_Type;\n \n-   procedure Create_Node_Union (T : Abstract_Node; Children : Type_Array) is\n+   ----------------------------\n+   -- Create_Node_Union_Type --\n+   ----------------------------\n+\n+   procedure Create_Node_Union_Type\n+     (T : Abstract_Node; Children : Type_Array) is\n    begin\n       Create_Union_Type (Node_Kind, T, Children);\n-   end Create_Node_Union;\n+   end Create_Node_Union_Type;\n \n-   procedure Create_Entity_Union\n+   ------------------------------\n+   -- Create_Entity_Union_Type --\n+   ------------------------------\n+\n+   procedure Create_Entity_Union_Type\n      (T : Abstract_Entity; Children : Type_Array) is\n    begin\n       Create_Union_Type (Entity_Kind, T, Children);\n-   end Create_Entity_Union;\n+   end Create_Entity_Union_Type;\n+\n+   -------------\n+   -- Compile --\n+   -------------\n \n    procedure Compile is\n       Fields_Per_Node : Fields_Per_Node_Type := (others => (others => False));\n@@ -369,26 +492,29 @@ package body Gen_IL.Gen is\n \n       procedure Compute_Ranges (Root : Root_Type);\n       --  Compute the range of Node_Kind/Entity_Kind values for all the types\n-      --  rooted at Root.\n+      --  rooted at Root. The result is stored in the First and Last components\n+      --  in the Type_Table.\n \n       procedure Compute_Fields_Per_Node;\n       --  Compute which fields are in which nodes. Implements inheritance of\n       --  fields. Set the Fields component of each Type_Info to include\n-      --  inherited ones. Set the Is_Syntactic component to the set of fields\n-      --  that are syntactic in that node kind. Set the Fields_Per_Node table.\n+      --  inherited ones. Set the Is_Syntactic component in the Type_Table to\n+      --  the set of fields that are syntactic in that node kind. Set the\n+      --  Fields_Per_Node table.\n \n       procedure Compute_Field_Offsets;\n-      --  Compute the offsets of each field.\n+      --  Compute the offsets of each field. The results are stored in the\n+      --  Offset components in the Field_Table.\n \n       procedure Compute_Type_Sizes;\n       --  Compute the size of each node and entity type, which is one more than\n       --  the maximum bit offset of all fields of the type. Results are\n       --  returned in the above Type_Bit_Size and Min_.../Max_... variables.\n \n-      procedure Check_For_Syntactic_Mismatch;\n+      procedure Check_For_Syntactic_Field_Mismatch;\n       --  Check that fields are either all syntactic or all semantic in all\n-      --  nodes in which they exist, except for some fields that are\n-      --  grandfathered in.\n+      --  nodes in which they exist, except for some fields that already\n+      --  violate this rule.\n       --\n       --  Also sets Setter_Needs_Parent.\n \n@@ -422,12 +548,10 @@ package body Gen_IL.Gen is\n       --  bodies in Sinfo.Nodes and Einfo.Entities.\n \n       function Node_To_Fetch_From (F : Field_Enum) return String;\n-      --  Node from which a getter should fetch the value.\n+      --  Name of the Node from which a getter should fetch the value.\n       --  Normally, we fetch from the node or entity passed in (i.e. formal\n       --  parameter N). But if Type_Only was specified, we need to fetch the\n       --  corresponding base (etc) type.\n-      --  ????We should not allocate space in the node for subtypes (etc), but\n-      --  that's not necessary for it to work.\n \n       procedure Put_Getter_Spec (S : in out Sink'Class; F : Field_Enum);\n       procedure Put_Setter_Spec (S : in out Sink'Class; F : Field_Enum);\n@@ -443,7 +567,7 @@ package body Gen_IL.Gen is\n       --  Print out the precondition, if any, for a getter or setter for the\n       --  given field.\n \n-      procedure Instantiate_Low_Level_Accessors\n+      procedure Put_Low_Level_Accessor_Instantiations\n         (S : in out Sink'Class; T : Type_Enum);\n       --  Print out the low-level getter and setter for a given type\n \n@@ -505,10 +629,14 @@ package body Gen_IL.Gen is\n       --  Used by Put_Sinfo_Dot_H and Put_Einfo_Dot_H to print out functions to\n       --  test membership in a union type.\n \n+      ------------------------\n+      -- Check_Completeness --\n+      ------------------------\n+\n       procedure Check_Completeness is\n       begin\n          for T in Node_Or_Entity_Type loop\n-            if Type_Table (T) = null and then T not in Boundaries then\n+            if Type_Table (T) = null and then T not in Type_Boundaries then\n                raise Illegal with \"Missing type declaration for \" & Image (T);\n             end if;\n          end loop;\n@@ -522,27 +650,31 @@ package body Gen_IL.Gen is\n          end loop;\n       end Check_Completeness;\n \n+      --------------------\n+      -- Compute_Ranges --\n+      --------------------\n+\n       procedure Compute_Ranges (Root : Root_Type) is\n \n          procedure Do_One_Type (T : Node_Or_Entity_Type);\n          --  Compute the range for one type. Passed to Iterate_Types to process\n          --  all of them.\n \n-         procedure Add_Concrete_Descendant\n+         procedure Add_Concrete_Descendant_To_Ancestors\n            (Ancestor : Abstract_Type; Descendant : Concrete_Type);\n          --  Add Descendant to the Concrete_Descendants of each of its\n          --  ancestors.\n \n-         procedure Add_Concrete_Descendant\n+         procedure Add_Concrete_Descendant_To_Ancestors\n            (Ancestor : Abstract_Type; Descendant : Concrete_Type) is\n          begin\n             if Ancestor not in Root_Type then\n-               Add_Concrete_Descendant\n+               Add_Concrete_Descendant_To_Ancestors\n                  (Type_Table (Ancestor).Parent, Descendant);\n             end if;\n \n             Append (Type_Table (Ancestor).Concrete_Descendants, Descendant);\n-         end Add_Concrete_Descendant;\n+         end Add_Concrete_Descendant_To_Ancestors;\n \n          procedure Do_One_Type (T : Node_Or_Entity_Type) is\n          begin\n@@ -551,7 +683,8 @@ package body Gen_IL.Gen is\n                   pragma Annotate (Codepeer, Modified, Type_Table);\n                   Type_Table (T).First := T;\n                   Type_Table (T).Last  := T;\n-                  Add_Concrete_Descendant (Type_Table (T).Parent, T);\n+                  Add_Concrete_Descendant_To_Ancestors\n+                    (Type_Table (T).Parent, T);\n \n                when Abstract_Type =>\n                   declare\n@@ -584,6 +717,10 @@ package body Gen_IL.Gen is\n          Iterate_Types (Root, Post => Do_One_Type'Access);\n       end Compute_Ranges;\n \n+      -----------------------------\n+      -- Compute_Fields_Per_Node --\n+      -----------------------------\n+\n       procedure Compute_Fields_Per_Node is\n \n          Duplicate_Fields_Found : Boolean := False;\n@@ -592,12 +729,14 @@ package body Gen_IL.Gen is\n          --  Compute the fields of a given type. This is the fields inherited\n          --  from ancestors, plus the fields declared for the type itself.\n \n-         function Get_Is_Syntactic (T : Node_Or_Entity_Type) return Field_Set;\n+         function Get_Syntactic_Fields\n+           (T : Node_Or_Entity_Type) return Field_Set;\n          --  Compute the set of fields that are syntactic for a given type.\n          --  Note that a field can be syntactic in some node types, but\n          --  semantic in others.\n \n          procedure Do_Concrete_Type (CT : Concrete_Type);\n+         --  Do the Compute_Fields_Per_Node work for a concrete type\n \n          function Get_Fields (T : Node_Or_Entity_Type) return Field_Vector is\n             Parent_Fields : constant Field_Vector :=\n@@ -607,19 +746,20 @@ package body Gen_IL.Gen is\n             return Parent_Fields & Type_Table (T).Fields;\n          end Get_Fields;\n \n-         function Get_Is_Syntactic (T : Node_Or_Entity_Type) return Field_Set\n+         function Get_Syntactic_Fields\n+           (T : Node_Or_Entity_Type) return Field_Set\n          is\n             Parent_Is_Syntactic : constant Field_Set :=\n               (if T in Root_Type then (Field_Enum => False)\n-               else Get_Is_Syntactic (Type_Table (T).Parent));\n+               else Get_Syntactic_Fields (Type_Table (T).Parent));\n          begin\n-            return Parent_Is_Syntactic or Is_Syntactic (T);\n-         end Get_Is_Syntactic;\n+            return Parent_Is_Syntactic or Syntactic (T);\n+         end Get_Syntactic_Fields;\n \n          procedure Do_Concrete_Type (CT : Concrete_Type) is\n          begin\n             Type_Table (CT).Fields := Get_Fields (CT);\n-            Is_Syntactic (CT) := Get_Is_Syntactic (CT);\n+            Syntactic (CT) := Get_Syntactic_Fields (CT);\n \n             for F of Type_Table (CT).Fields loop\n                if Fields_Per_Node (CT) (F) then\n@@ -691,11 +831,23 @@ package body Gen_IL.Gen is\n       function Field_Size (T : Type_Enum) return Bit_Offset is\n         (case T is\n           when Flag | Float_Rep_Kind => 1,\n+\n           when Small_Paren_Count_Type | Component_Alignment_Kind => 2,\n-          when Nkind_Type | Ekind_Type | Convention_Id => 8,\n-          when Mechanism_Type | List_Id | Elist_Id | Name_Id | String_Id | Uint\n-           | Ureal | Source_Ptr | Union_Id | Node_Id\n-           | Node_Or_Entity_Type => 32,\n+\n+          when Node_Kind_Type | Entity_Kind_Type | Convention_Id => 8,\n+\n+           when Mechanism_Type\n+              | List_Id\n+              | Elist_Id\n+              | Name_Id\n+              | String_Id\n+              | Uint\n+              | Ureal\n+              | Source_Ptr\n+              | Union_Id\n+              | Node_Id\n+              | Node_Or_Entity_Type => 32,\n+\n          when Between_Special_And_Abstract_Node_Types => -- can't happen\n            Bit_Offset'Last);\n          --  Note that this is not the same as Type_Bit_Size of the field's\n@@ -728,6 +880,10 @@ package body Gen_IL.Gen is\n       function Type_Bit_Size_Aligned (T : Concrete_Type) return Bit_Offset is\n         (Bit_Offset (Type_Size_In_Slots (T)) * 32); -- multiple of slot size\n \n+      ---------------------------\n+      -- Compute_Field_Offsets --\n+      ---------------------------\n+\n       procedure Compute_Field_Offsets is\n          type Offset_Set_Unconstrained is array (Bit_Offset range <>)\n            of Boolean with Pack;\n@@ -752,7 +908,7 @@ package body Gen_IL.Gen is\n          --  False, then \"any type that has the field\" --> \"any type, whether\n          --  or not it has the field\".\n \n-         procedure Set_Offset_Set\n+         procedure Set_Offset_In_Use\n            (F : Field_Enum; Offset : Field_Offset);\n          --  Mark the offset as \"in use\"\n \n@@ -780,7 +936,7 @@ package body Gen_IL.Gen is\n             return True;\n          end Offset_OK;\n \n-         procedure Set_Offset_Set\n+         procedure Set_Offset_In_Use\n            (F : Field_Enum; Offset : Field_Offset) is\n          begin\n             for T in Concrete_Type loop\n@@ -795,14 +951,14 @@ package body Gen_IL.Gen is\n                   end;\n                end if;\n             end loop;\n-         end Set_Offset_Set;\n+         end Set_Offset_In_Use;\n \n          function Choose_Offset\n            (F : Field_Enum) return Field_Offset is\n          begin\n             for Offset in Field_Offset loop\n                if Offset_OK (F, Offset) then\n-                  Set_Offset_Set (F, Offset);\n+                  Set_Offset_In_Use (F, Offset);\n \n                   return Offset;\n                end if;\n@@ -865,9 +1021,16 @@ package body Gen_IL.Gen is\n \n       end Compute_Field_Offsets;\n \n+      ------------------------\n+      -- Compute_Type_Sizes --\n+      ------------------------\n+\n       procedure Compute_Type_Sizes is\n          --  Node_Counts is the number of nodes of each kind created during\n-         --  compilation of a large example.\n+         --  compilation of a large example. This is used purely to compute an\n+         --  estimate of the average node size. New node types can default to\n+         --  \"others => 0\". At some point we can instrument Atree to print out\n+         --  accurate size statistics, and remove this code.\n \n          Node_Counts : constant array (Concrete_Node) of Natural :=\n            (N_Identifier => 429298,\n@@ -1129,7 +1292,11 @@ package body Gen_IL.Gen is\n          Average_Node_Size_In_Slots := Average_Type_Size_In_Slots;\n       end Compute_Type_Sizes;\n \n-      procedure Check_For_Syntactic_Mismatch is\n+      ----------------------------------------\n+      -- Check_For_Syntactic_Field_Mismatch --\n+      ----------------------------------------\n+\n+      procedure Check_For_Syntactic_Field_Mismatch is\n       begin\n          for F in Field_Enum loop\n             if F /= Between_Node_And_Entity_Fields then\n@@ -1140,7 +1307,7 @@ package body Gen_IL.Gen is\n \n                begin\n                   for J in 1 .. Last_Index (Have_Field) loop\n-                     if Is_Syntactic (Have_Field (J)) (F) then\n+                     if Syntactic (Have_Field (J)) (F) then\n                         Syntactic_Seen := True;\n                      else\n                         Semantic_Seen := True;\n@@ -1162,7 +1329,7 @@ package body Gen_IL.Gen is\n                           \"syntactic/semantic mismatch for \" & Image (F);\n                      end if;\n \n-                     if Field_Table (F).Field_Type in Traversal_Type\n+                     if Field_Table (F).Field_Type in Traversed_Field_Type\n                        and then Syntactic_Seen\n                      then\n                         Setter_Needs_Parent (F) := True;\n@@ -1171,7 +1338,11 @@ package body Gen_IL.Gen is\n                end;\n             end if;\n          end loop;\n-      end Check_For_Syntactic_Mismatch;\n+      end Check_For_Syntactic_Field_Mismatch;\n+\n+      ----------------------\n+      -- Field_Types_Used --\n+      ----------------------\n \n       function Field_Types_Used (First, Last : Field_Enum) return Type_Set is\n          Result : Type_Set := (others => False);\n@@ -1191,6 +1362,10 @@ package body Gen_IL.Gen is\n       --  Lines of the form Put (S, \"...\"); are more readable if we relax the\n       --  line length. We really just want the \"...\" to be short enough.\n \n+      ---------------------------\n+      -- Put_Type_And_Subtypes --\n+      ---------------------------\n+\n       procedure Put_Type_And_Subtypes\n         (S : in out Sink'Class; Root : Root_Type)\n       is\n@@ -1254,7 +1429,7 @@ package body Gen_IL.Gen is\n                        Image (Root));\n                   Indent (S, 2);\n                   Put (S, \"\\1 in\\n\", Image (T));\n-                  Put_Images (S, Type_Table (T).Children);\n+                  Put_Types_With_Bars (S, Type_Table (T).Children);\n                   Outdent (S, 2);\n                   Put (S, \";\\n\");\n                   Outdent (S, 2);\n@@ -1283,9 +1458,6 @@ package body Gen_IL.Gen is\n \n          procedure Put_Id_Subtype (T : Node_Or_Entity_Type) is\n          begin\n-            --  ????We have names like Overloadable_Kind_Id.\n-            --  Perhaps that should be Overloadable_Id.\n-\n             if Type_Table (T).Parent /= No_Type then\n                Put (S, \"subtype \\1 is\\n\", Id_Image (T));\n                Indent (S, 2);\n@@ -1357,15 +1529,19 @@ package body Gen_IL.Gen is\n          Put (S, \"subtype Flag is Boolean;\\n\\n\");\n       end Put_Type_And_Subtypes;\n \n-      function Low_Level_Getter (T : Type_Enum) return String is\n+      function Low_Level_Getter_Name (T : Type_Enum) return String is\n         (\"Get_\" & Image (T));\n-      function Low_Level_Setter (T : Type_Enum) return String is\n+      function Low_Level_Setter_Name (T : Type_Enum) return String is\n         (\"Set_\" & Image (T));\n-      function Low_Level_Setter (F : Field_Enum) return String is\n-        (Low_Level_Setter (Field_Table (F).Field_Type) &\n+      function Low_Level_Setter_Name (F : Field_Enum) return String is\n+        (Low_Level_Setter_Name (Field_Table (F).Field_Type) &\n            (if Setter_Needs_Parent (F) then \"_With_Parent\" else \"\"));\n \n-      procedure Instantiate_Low_Level_Accessors\n+      -------------------------------------------\n+      -- Put_Low_Level_Accessor_Instantiations --\n+      -------------------------------------------\n+\n+      procedure Put_Low_Level_Accessor_Instantiations\n         (S : in out Sink'Class; T : Type_Enum)\n       is\n       begin\n@@ -1381,7 +1557,7 @@ package body Gen_IL.Gen is\n \n             begin\n                Put (S, \"\\nfunction \\1 is new Get_32_Bit_Field_With_Default (\\2, \\3) with \\4;\\n\",\n-                    Low_Level_Getter (T),\n+                    Low_Level_Getter_Name (T),\n                     Get_Set_Id_Image (T),\n                     Default_Val,\n                     Inline);\n@@ -1392,29 +1568,33 @@ package body Gen_IL.Gen is\n \n          else\n             Put (S, \"\\nfunction \\1 is new Get_\\2_Bit_Field (\\3) with \\4;\\n\",\n-                 Low_Level_Getter (T),\n+                 Low_Level_Getter_Name (T),\n                  Image (Field_Size (T)),\n                  Get_Set_Id_Image (T),\n                  Inline);\n          end if;\n \n          --  No special case for the setter\n \n-         if T in Nkind_Type | Ekind_Type then\n+         if T in Node_Kind_Type | Entity_Kind_Type then\n             Put (S, \"pragma Warnings (Off);\\n\");\n-            --  Set_Nkind_Type and Set_Ekind_Type might not be called\n+            --  Set_Node_Kind_Type and Set_Entity_Kind_Type might not be called\n          end if;\n \n          Put (S, \"procedure \\1 is new Set_\\2_Bit_Field (\\3) with \\4;\\n\",\n-              Low_Level_Setter (T),\n+              Low_Level_Setter_Name (T),\n               Image (Field_Size (T)),\n               Get_Set_Id_Image (T),\n               Inline);\n \n-         if T in Nkind_Type | Ekind_Type then\n+         if T in Node_Kind_Type | Entity_Kind_Type then\n             Put (S, \"pragma Warnings (On);\\n\");\n          end if;\n-      end Instantiate_Low_Level_Accessors;\n+      end Put_Low_Level_Accessor_Instantiations;\n+\n+      ----------------------\n+      -- Put_Precondition --\n+      ----------------------\n \n       procedure Put_Precondition\n         (S : in out Sink'Class; F : Field_Enum)\n@@ -1452,7 +1632,7 @@ package body Gen_IL.Gen is\n                Put (S, \", Pre =>\\n\");\n                Indent (S, 1);\n                Put (S, \"N in \");\n-               Put_Id_Images (S, Field_Table (F).Have_This_Field);\n+               Put_Type_Ids_With_Bars (S, Field_Table (F).Have_This_Field);\n \n                pragma Assert (Is_Entity = \"\");\n \n@@ -1477,6 +1657,10 @@ package body Gen_IL.Gen is\n       --  Node_Id or Entity_Id, and the getter and setter will have\n       --  preconditions.\n \n+      ------------------------\n+      -- Node_To_Fetch_From --\n+      ------------------------\n+\n       function Node_To_Fetch_From (F : Field_Enum) return String is\n       begin\n          return\n@@ -1487,6 +1671,10 @@ package body Gen_IL.Gen is\n               when Root_Type_Only => \"Root_Type (N)\");\n       end Node_To_Fetch_From;\n \n+      ---------------------\n+      -- Put_Getter_Spec --\n+      ---------------------\n+\n       procedure Put_Getter_Spec (S : in out Sink'Class; F : Field_Enum) is\n       begin\n          Put (S, \"function \\1\\n\", Image (F));\n@@ -1496,6 +1684,10 @@ package body Gen_IL.Gen is\n          Outdent (S, 2);\n       end Put_Getter_Spec;\n \n+      ---------------------\n+      -- Put_Getter_Decl --\n+      ---------------------\n+\n       procedure Put_Getter_Decl (S : in out Sink'Class; F : Field_Enum) is\n       begin\n          Put_Getter_Spec (S, F);\n@@ -1507,6 +1699,10 @@ package body Gen_IL.Gen is\n          Put (S, \";\\n\");\n       end Put_Getter_Decl;\n \n+      ---------------------\n+      -- Put_Getter_Body --\n+      ---------------------\n+\n       procedure Put_Getter_Body (S : in out Sink'Class; F : Field_Enum) is\n          Rec : Field_Info renames Field_Table (F).all;\n       begin\n@@ -1521,7 +1717,7 @@ package body Gen_IL.Gen is\n          Indent (S, 3);\n          Put (S, \"Val : constant \\1 := \\2 (\\3, \\4);\\n\",\n               Get_Set_Id_Image (Rec.Field_Type),\n-              Low_Level_Getter (Rec.Field_Type),\n+              Low_Level_Getter_Name (Rec.Field_Type),\n               Node_To_Fetch_From (F),\n               Image (Rec.Offset));\n          Outdent (S, 3);\n@@ -1532,11 +1728,19 @@ package body Gen_IL.Gen is\n             Put (S, \"pragma Assert (\\1);\\n\", Rec.Pre.all);\n          end if;\n \n+         if Rec.Pre_Get.all /= \"\" then\n+            Put (S, \"pragma Assert (\\1);\\n\", Rec.Pre_Get.all);\n+         end if;\n+\n          Put (S, \"return Val;\\n\");\n          Outdent (S, 3);\n          Put (S, \"end \\1;\\n\\n\", Image (F));\n       end Put_Getter_Body;\n \n+      ---------------------\n+      -- Put_Setter_Spec --\n+      ---------------------\n+\n       procedure Put_Setter_Spec (S : in out Sink'Class; F : Field_Enum) is\n          Rec    : Field_Info renames Field_Table (F).all;\n          Default : constant String :=\n@@ -1550,6 +1754,10 @@ package body Gen_IL.Gen is\n          Outdent (S, 2);\n       end Put_Setter_Spec;\n \n+      ---------------------\n+      -- Put_Setter_Decl --\n+      ---------------------\n+\n       procedure Put_Setter_Decl (S : in out Sink'Class; F : Field_Enum) is\n       begin\n          Put_Setter_Spec (S, F);\n@@ -1560,23 +1768,22 @@ package body Gen_IL.Gen is\n          Put (S, \";\\n\");\n       end Put_Setter_Decl;\n \n+      ---------------------\n+      -- Put_Setter_Body --\n+      ---------------------\n+\n       procedure Put_Setter_Body (S : in out Sink'Class; F : Field_Enum) is\n          Rec : Field_Info renames Field_Table (F).all;\n \n          --  If Type_Only was specified in the call to Create_Semantic_Field,\n-         --  then we assert that the node is a base (etc) type.\n+         --  then we assert that the node is a base type. We cannot assert that\n+         --  it is an implementation base type or a root type.\n \n          Type_Only_Assertion : constant String :=\n            (case Rec.Type_Only is\n               when No_Type_Only => \"\",\n-              when Base_Type_Only => \"Is_Base_Type (N)\",\n---  ????It seems like we should call Is_Implementation_Base_Type or\n---  Is_Root_Type (which don't currently exist), but the old version always\n---  calls Base_Type.\n---              when Impl_Base_Type_Only => \"Is_Implementation_Base_Type (N)\",\n---              when Root_Type_Only => \"Is_Root_Type (N)\");\n-              when Impl_Base_Type_Only => \"Is_Base_Type (N)\",\n-              when Root_Type_Only => \"Is_Base_Type (N)\");\n+              when Base_Type_Only | Impl_Base_Type_Only | Root_Type_Only =>\n+                \"Is_Base_Type (N)\");\n       begin\n          Put_Setter_Spec (S, F);\n          Put (S, \" is\\n\");\n@@ -1587,17 +1794,25 @@ package body Gen_IL.Gen is\n             Put (S, \"pragma Assert (\\1);\\n\", Rec.Pre.all);\n          end if;\n \n+         if Rec.Pre_Set.all /= \"\" then\n+            Put (S, \"pragma Assert (\\1);\\n\", Rec.Pre_Set.all);\n+         end if;\n+\n          if Type_Only_Assertion /= \"\" then\n             Put (S, \"pragma Assert (\\1);\\n\", Type_Only_Assertion);\n          end if;\n \n          Put (S, \"\\1 (N, \\2, Val);\\n\",\n-              Low_Level_Setter (F),\n+              Low_Level_Setter_Name (F),\n               Image (Rec.Offset));\n          Outdent (S, 3);\n          Put (S, \"end Set_\\1;\\n\\n\", Image (F));\n       end Put_Setter_Body;\n \n+      --------------------\n+      -- Put_Subp_Decls --\n+      --------------------\n+\n       procedure Put_Subp_Decls (S : in out Sink'Class; Root : Root_Type) is\n          --  Note that there are several fields that are defined for both nodes\n          --  and entities, such as Nkind. These are allocated slots in both,\n@@ -1626,6 +1841,10 @@ package body Gen_IL.Gen is\n          end loop;\n       end Put_Subp_Decls;\n \n+      ---------------------\n+      -- Put_Subp_Bodies --\n+      ---------------------\n+\n       procedure Put_Subp_Bodies (S : in out Sink'Class; Root : Root_Type) is\n       begin\n          Put (S, \"\\n--  Getters and setters for fields\\n\\n\");\n@@ -1639,6 +1858,10 @@ package body Gen_IL.Gen is\n          end loop;\n       end Put_Subp_Bodies;\n \n+      --------------------------\n+      -- Put_Traversed_Fields --\n+      --------------------------\n+\n       procedure Put_Traversed_Fields (S : in out Sink'Class) is\n \n          function Is_Traversed_Field\n@@ -1651,19 +1874,19 @@ package body Gen_IL.Gen is\n          --  Compute the maximum number of syntactic fields that are of type\n          --  Node_Id or List_Id over all node types.\n \n-         procedure Put_Agg (T : Node_Or_Entity_Type);\n+         procedure Put_Aggregate (T : Node_Or_Entity_Type);\n          --  Print out the subaggregate for one type\n \n          function Is_Traversed_Field\n            (T : Concrete_Node; F : Field_Enum) return Boolean is\n          begin\n-            return Is_Syntactic (T) (F)\n-              and then Field_Table (F).Field_Type in Traversal_Type;\n+            return Syntactic (T) (F)\n+              and then Field_Table (F).Field_Type in Traversed_Field_Type;\n          end Is_Traversed_Field;\n \n          First_Time : Boolean := True;\n \n-         procedure Put_Agg (T : Node_Or_Entity_Type) is\n+         procedure Put_Aggregate (T : Node_Or_Entity_Type) is\n             Left_Opnd_Skipped : Boolean := False;\n          begin\n             if T in Concrete_Node then\n@@ -1706,7 +1929,7 @@ package body Gen_IL.Gen is\n                Outdent (S, 2);\n                Put (S, \")\");\n             end if;\n-         end Put_Agg;\n+         end Put_Aggregate;\n \n          function Init_Max_Traversed_Fields return Field_Offset is\n             Result : Field_Offset := 0;\n@@ -1752,12 +1975,16 @@ package body Gen_IL.Gen is\n          Indent (S, 2);\n          Put (S, \"(\");\n          Indent (S, 1);\n-         Iterate_Types (Node_Kind, Pre => Put_Agg'Access);\n+         Iterate_Types (Node_Kind, Pre => Put_Aggregate'Access);\n          Outdent (S, 1);\n          Put (S, \");\\n\\n\");\n          Outdent (S, 2);\n       end Put_Traversed_Fields;\n \n+      ----------------\n+      -- Put_Tables --\n+      ----------------\n+\n       procedure Put_Tables (S : in out Sink'Class; Root : Root_Type) is\n \n          First_Time : Boolean := True;\n@@ -1942,6 +2169,10 @@ package body Gen_IL.Gen is\n \n       end Put_Tables;\n \n+      ----------------\n+      -- Put_Seinfo --\n+      ----------------\n+\n       procedure Put_Seinfo is\n          S : Sink'Class := Create_File (\"seinfo.ads\");\n       begin\n@@ -2010,6 +2241,10 @@ package body Gen_IL.Gen is\n          Put (S, \"\\nend Seinfo;\\n\");\n       end Put_Seinfo;\n \n+      ---------------\n+      -- Put_Nodes --\n+      ---------------\n+\n       procedure Put_Nodes is\n          S : Sink'Class := Create_File (\"sinfo-nodes.ads\");\n          B : Sink'Class := Create_File (\"sinfo-nodes.adb\");\n@@ -2091,7 +2326,7 @@ package body Gen_IL.Gen is\n          Put (B, \"pragma Style_Checks (\"\"M200\"\");\\n\");\n          for T in Special_Type loop\n             if Node_Field_Types_Used (T) then\n-               Instantiate_Low_Level_Accessors (B, T);\n+               Put_Low_Level_Accessor_Instantiations (B, T);\n             end if;\n          end loop;\n \n@@ -2105,15 +2340,16 @@ package body Gen_IL.Gen is\n \n       end Put_Nodes;\n \n+      ------------------\n+      -- Put_Entities --\n+      ------------------\n+\n       procedure Put_Entities is\n          S : Sink'Class := Create_File (\"einfo-entities.ads\");\n          B : Sink'Class := Create_File (\"einfo-entities.adb\");\n       begin\n          Put (S, \"with Seinfo; use Seinfo;\\n\");\n-         Put (S, \"pragma Warnings (Off); -- ????\\n\");\n-         Put (S, \"with Output; use Output;\\n\");\n          Put (S, \"with Sinfo.Nodes; use Sinfo.Nodes;\\n\");\n-         Put (S, \"pragma Warnings (On); -- ????\\n\");\n \n          Put (S, \"\\npackage Einfo.Entities is\\n\\n\");\n          Indent (S, 3);\n@@ -2146,7 +2382,7 @@ package body Gen_IL.Gen is\n          Put (B, \"pragma Style_Checks (\"\"M200\"\");\\n\");\n          for T in Special_Type loop\n             if Entity_Field_Types_Used (T) then\n-               Instantiate_Low_Level_Accessors (B, T);\n+               Put_Low_Level_Accessor_Instantiations (B, T);\n             end if;\n          end loop;\n \n@@ -2157,17 +2393,23 @@ package body Gen_IL.Gen is\n \n       end Put_Entities;\n \n+      -------------------\n+      -- Put_Make_Spec --\n+      -------------------\n+\n       procedure Put_Make_Spec\n         (S : in out Sink'Class; Root : Root_Type; T : Concrete_Type)\n       is\n       begin\n-         Put (S, \"function Make_\\1 (Sloc : Source_Ptr\", Image_Sans_N (T));\n-         Indent (S, 3);\n+         Put (S, \"function Make_\\1\\n\", Image_Sans_N (T));\n+         Indent (S, 2);\n+         Put (S, \"(Sloc : Source_Ptr\");\n+         Indent (S, 1);\n \n          for F of Type_Table (T).Fields loop\n             pragma Assert (Fields_Per_Node (T) (F));\n \n-            if Is_Syntactic (T) (F) then\n+            if Syntactic (T) (F) then\n                declare\n                   Typ : constant String :=\n                     (if Field_Table (F).Field_Type = Flag then \"Boolean\"\n@@ -2181,141 +2423,136 @@ package body Gen_IL.Gen is\n                      (if Field_Table (F).Field_Type = Flag then \" := False\" else \"\")\n                      else \" := \" & Value_Image (Field_Table (F).Default_Value));\n \n-                  Suppress_Default : constant Boolean := False;\n-                  --  ????For testing. Strip out the defaults from the old\n-                  --  nmake.ads. Set this to True, and generate the new\n-                  --  nmake.ads. Then diff the two. Same for nmake.adb.\n-                  --  They should be identical, except for minor diffs like\n-                  --  comments.\n-\n                begin\n                   Put (S, \";\\n\");\n-\n                   Put (S, \"\\1\", Image (F));\n-                  Tab_To_Column (S, 36);\n-                  Put (S, \" : \\1\\2\",\n-                       Typ,\n-                       (if Suppress_Default then \"\" else Default));\n+                  Put (S, \" : \\1\\2\", Typ, Default);\n                end;\n             end if;\n          end loop;\n \n          Put (S, \")\\nreturn \\1_Id\", Node_Or_Entity (Root));\n-         Outdent (S, 3);\n+         Outdent (S, 2);\n+         Outdent (S, 1);\n       end Put_Make_Spec;\n \n+      --------------------\n+      -- Put_Make_Decls --\n+      --------------------\n+\n       procedure Put_Make_Decls (S : in out Sink'Class; Root : Root_Type) is\n       begin\n-         --  The order of the functions doesn't matter, but we're using\n-         --  Sinfo_Node_Order here so we can diff the nmake code against the\n-         --  old version. That means this code won't work for entities.\n-         --  There was no Emake for entities, but it might be nice to\n-         --  have someday. If we want that, we should say:\n-         --\n-         --    for T in First_Concrete (Root) .. Last_Concrete (Root) loop\n-         --\n-         --  We would need to decide which fields to include as parameters,\n-         --  because there are no syntactic fields of entities.\n-\n-         for T of Sinfo_Node_Order loop\n-            Put_Make_Spec (S, Root, T);\n-            Put (S, \";\\npragma \\1 (Make_\\2);\\n\\n\", Inline, Image_Sans_N (T));\n+         for T in First_Concrete (Root) .. Last_Concrete (Root) loop\n+            if T not in N_Unused_At_Start | N_Unused_At_End then\n+               Put_Make_Spec (S, Root, T);\n+               Put (S, \";\\npragma \\1 (Make_\\2);\\n\\n\", Inline, Image_Sans_N (T));\n+            end if;\n          end loop;\n       end Put_Make_Decls;\n \n+      ---------------------\n+      -- Put_Make_Bodies --\n+      ---------------------\n+\n       procedure Put_Make_Bodies (S : in out Sink'Class; Root : Root_Type) is\n       begin\n-         for T of Sinfo_Node_Order loop\n-            Put_Make_Spec (S, Root, T);\n-            Put (S, \"\\nis\\n\");\n+         for T in First_Concrete (Root) .. Last_Concrete (Root) loop\n+            if T not in N_Unused_At_Start | N_Unused_At_End then\n+               Put_Make_Spec (S, Root, T);\n+               Put (S, \"\\nis\\n\");\n \n-            Indent (S, 3);\n-            Put (S, \"N : constant Node_Id :=\\n\");\n+               Indent (S, 3);\n+               Put (S, \"N : constant Node_Id :=\\n\");\n \n-            if T in Entity_Node then\n-               Put (S, \"      New_Entity (\\1, Sloc);\\n\", Image (T));\n+               if T in Entity_Node then\n+                  Put (S, \"      New_Entity (\\1, Sloc);\\n\", Image (T));\n \n-            else\n-               Put (S, \"      New_Node (\\1, Sloc);\\n\", Image (T));\n-            end if;\n+               else\n+                  Put (S, \"      New_Node (\\1, Sloc);\\n\", Image (T));\n+               end if;\n \n-            Outdent (S, 3);\n+               Outdent (S, 3);\n \n-            Put (S, \"begin\\n\");\n+               Put (S, \"begin\\n\");\n \n-            Indent (S, 3);\n-            for F of Type_Table (T).Fields loop\n-               pragma Assert (Fields_Per_Node (T) (F));\n+               Indent (S, 3);\n+               for F of Type_Table (T).Fields loop\n+                  pragma Assert (Fields_Per_Node (T) (F));\n \n-               if Is_Syntactic (T) (F) then\n-                  declare\n-                     NWidth : constant := 28;\n-                     --  This constant comes from the old Xnmake, which wraps\n-                     --  the Set_... call if the field name is that long or\n-                     --  longer.\n+                  if Syntactic (T) (F) then\n+                     declare\n+                        NWidth : constant := 28;\n+                        --  This constant comes from the old Xnmake, which wraps\n+                        --  the Set_... call if the field name is that long or\n+                        --  longer.\n \n-                     F_Name : constant String := Image (F);\n+                        F_Name : constant String := Image (F);\n \n-                  begin\n-                     if F_Name'Length < NWidth then\n-                        Put (S, \"Set_\\1 (N, \\1);\\n\", F_Name);\n+                     begin\n+                        if F_Name'Length < NWidth then\n+                           Put (S, \"Set_\\1 (N, \\1);\\n\", F_Name);\n \n-                     --  Wrap the line\n+                        --  Wrap the line\n \n-                     else\n-                        Put (S, \"Set_\\1\\n\", F_Name);\n-                        Indent (S, 2);\n-                        Put (S, \"(N, \\1);\\n\", F_Name);\n-                        Outdent (S, 2);\n-                     end if;\n-                  end;\n-               end if;\n-            end loop;\n+                        else\n+                           Put (S, \"Set_\\1\\n\", F_Name);\n+                           Indent (S, 2);\n+                           Put (S, \"(N, \\1);\\n\", F_Name);\n+                           Outdent (S, 2);\n+                        end if;\n+                     end;\n+                  end if;\n+               end loop;\n \n-            if Is_Descendant (N_Op, T) then\n-               --  Special cases for N_Op nodes: fill in the Chars and Entity\n-               --  fields even though they were not passed in.\n+               if Is_Descendant (N_Op, T) then\n+                  --  Special cases for N_Op nodes: fill in the Chars and Entity\n+                  --  fields even though they were not passed in.\n \n-               declare\n-                  Op : constant String := Image_Sans_N (T);\n-                  --  This will be something like \"Op_And\" or \"Op_Add\"\n-\n-                  Op_Name_With_Op : constant String :=\n-                    (if T = N_Op_Plus then \"Op_Add\"\n-                     elsif T = N_Op_Minus then \"Op_Subtract\"\n-                     else Op);\n-                  --  Special cases for unary operators that have the same name\n-                  --  as a binary operator; we use the binary operator name in\n-                  --  that case.\n-\n-                  Slid : constant String (1 .. Op_Name_With_Op'Length) :=\n-                    Op_Name_With_Op;\n-                  pragma Assert (Slid (1 .. 3) = \"Op_\");\n-\n-                  Op_Name : constant String :=\n-                    (if T in N_Op_Rotate_Left |\n-                       N_Op_Rotate_Right |\n-                       N_Op_Shift_Left |\n-                       N_Op_Shift_Right |\n-                       N_Op_Shift_Right_Arithmetic\n-                     then Slid (4 .. Slid'Last)\n-                     else Slid);\n-                  --  Special cases for shifts and rotates; the node kind has\n-                  --  \"Op_\", but the Name_Id constant does not.\n+                  declare\n+                     Op : constant String := Image_Sans_N (T);\n+                     --  This will be something like \"Op_And\" or \"Op_Add\"\n+\n+                     Op_Name_With_Op : constant String :=\n+                       (if T = N_Op_Plus then \"Op_Add\"\n+                        elsif T = N_Op_Minus then \"Op_Subtract\"\n+                        else Op);\n+                     --  Special cases for unary operators that have the same name\n+                     --  as a binary operator; we use the binary operator name in\n+                     --  that case.\n+\n+                     Slid : constant String (1 .. Op_Name_With_Op'Length) :=\n+                       Op_Name_With_Op;\n+                     pragma Assert (Slid (1 .. 3) = \"Op_\");\n+\n+                     Op_Name : constant String :=\n+                       (if T in N_Op_Rotate_Left |\n+                          N_Op_Rotate_Right |\n+                          N_Op_Shift_Left |\n+                          N_Op_Shift_Right |\n+                          N_Op_Shift_Right_Arithmetic\n+                        then Slid (4 .. Slid'Last)\n+                        else Slid);\n+                     --  Special cases for shifts and rotates; the node kind has\n+                     --  \"Op_\", but the Name_Id constant does not.\n \n-               begin\n-                  Put (S, \"Set_Chars (N, Name_\\1);\\n\", Op_Name);\n-                  Put (S, \"Set_Entity (N, Standard_\\1);\\n\", Op);\n-               end;\n-            end if;\n+                  begin\n+                     Put (S, \"Set_Chars (N, Name_\\1);\\n\", Op_Name);\n+                     Put (S, \"Set_Entity (N, Standard_\\1);\\n\", Op);\n+                  end;\n+               end if;\n \n-            Put (S, \"return N;\\n\");\n-            Outdent (S, 3);\n+               Put (S, \"return N;\\n\");\n+               Outdent (S, 3);\n \n-            Put (S, \"end Make_\\1;\\n\\n\", Image_Sans_N (T));\n+               Put (S, \"end Make_\\1;\\n\\n\", Image_Sans_N (T));\n+            end if;\n          end loop;\n       end Put_Make_Bodies;\n \n+      ---------------\n+      -- Put_Nmake --\n+      ---------------\n+\n       --  Documentation for the Nmake package, generated by Put_Nmake below.\n \n       --  The Nmake package contains a set of routines used to construct tree\n@@ -2353,8 +2590,6 @@ package body Gen_IL.Gen is\n \n          Put (S, \"--  This package is automatically generated.\\n\\n\");\n          Put (S, \"--  See Put_Nmake in gen_il-gen.adb for documentation.\\n\\n\");\n---         Put (S, \"pragma Style_Checks (\"\"M200\"\");\\n\");\n-         --  ????Work around bug in a-stouut.adb.\n \n          Put_Make_Decls (S, Node_Kind);\n \n@@ -2371,20 +2606,22 @@ package body Gen_IL.Gen is\n          Indent (B, 3);\n \n          Put (B, \"--  This package is automatically generated.\\n\\n\");\n---         Put (B, \"pragma Style_Checks (\"\"M200\"\");\\n\");\n-         --  ????Work around bug in a-stouut.adb.\n \n          Put_Make_Bodies (B, Node_Kind);\n \n          Outdent (B, 3);\n          Put (B, \"end Nmake;\\n\");\n       end Put_Nmake;\n \n+      -----------------------\n+      -- Put_Seinfo_Tables --\n+      -----------------------\n+\n       procedure Put_Seinfo_Tables is\n          S : Sink'Class := Create_File (\"seinfo_tables.ads\");\n          B : Sink'Class := Create_File (\"seinfo_tables.adb\");\n \n-         Type_Layout : Type_Layout_Array;\n+         Type_Layout : Concrete_Type_Layout_Array;\n \n          function Get_Last_Bit\n            (T : Concrete_Type; F : Opt_Field_Enum; First_Bit : Bit_Offset)\n@@ -2514,7 +2751,7 @@ package body Gen_IL.Gen is\n \n          Put (B, \"with Gen_IL.Types;  use Gen_IL.Types;\\n\");\n          Put (B, \"with Gen_IL.Fields; use Gen_IL.Fields;\\n\");\n-         Put (B, \"with Gen_IL.Utils;  use Gen_IL.Utils;\\n\");\n+         Put (B, \"with Gen_IL.Internals;  use Gen_IL.Internals;\\n\");\n \n          Put (B, \"\\npackage body Seinfo_Tables is\\n\\n\");\n          Indent (B, 3);\n@@ -2537,7 +2774,7 @@ package body Gen_IL.Gen is\n          Put (B, \"\\n--  Type_Layout is \\1 bytes.\\n\", Image (Type_Layout_Size / 8));\n \n          Put (B, \"\\npragma Style_Checks (Off);\\n\");\n-         Put (B, \"Type_Layout : constant Type_Layout_Array := \\n\");\n+         Put (B, \"Type_Layout : constant Concrete_Type_Layout_Array := \\n\");\n          Indent (B, 2);\n          Put (B, \"--  Concrete node types:\\n\");\n          Put (B, \"(\");\n@@ -2665,6 +2902,10 @@ package body Gen_IL.Gen is\n \n       end Put_Seinfo_Tables;\n \n+      -----------------------------\n+      -- Put_C_Type_And_Subtypes --\n+      -----------------------------\n+\n       procedure Put_C_Type_And_Subtypes\n         (S : in out Sink'Class; Root : Root_Type) is\n \n@@ -2714,6 +2955,10 @@ package body Gen_IL.Gen is\n          Put_Union_Membership (S, Root);\n       end Put_C_Type_And_Subtypes;\n \n+      ----------------------------\n+      -- Put_Low_Level_C_Getter --\n+      ----------------------------\n+\n       procedure Put_Low_Level_C_Getter\n         (S : in out Sink'Class; T : Type_Enum)\n       is\n@@ -2727,7 +2972,7 @@ package body Gen_IL.Gen is\n \n          Indent (S, 3);\n \n-         --  Same special case as in Instantiate_Low_Level_Accessors\n+         --  Same special case as in Put_Low_Level_Accessor_Instantiations\n \n          if T in Elist_Id | Uint then\n             pragma Assert (Field_Size (T) = 32);\n@@ -2749,6 +2994,10 @@ package body Gen_IL.Gen is\n          Outdent (S, 3);\n       end Put_Low_Level_C_Getter;\n \n+      -----------------------------\n+      -- Put_High_Level_C_Getter --\n+      -----------------------------\n+\n       procedure Put_High_Level_C_Getter\n         (S : in out Sink'Class; F : Field_Enum)\n       is\n@@ -2759,12 +3008,16 @@ package body Gen_IL.Gen is\n \n          Indent (S, 3);\n          Put (S, \"{ return \\1(\\2, \\3); }\\n\\n\",\n-              Low_Level_Getter (Field_Table (F).Field_Type),\n+              Low_Level_Getter_Name (Field_Table (F).Field_Type),\n               Node_To_Fetch_From (F),\n               Image (Field_Table (F).Offset));\n          Outdent (S, 3);\n       end Put_High_Level_C_Getter;\n \n+      ------------------------------\n+      -- Put_High_Level_C_Getters --\n+      ------------------------------\n+\n       procedure Put_High_Level_C_Getters\n         (S : in out Sink'Class; Root : Root_Type)\n       is\n@@ -2776,6 +3029,10 @@ package body Gen_IL.Gen is\n          end loop;\n       end Put_High_Level_C_Getters;\n \n+      --------------------------\n+      -- Put_Union_Membership --\n+      --------------------------\n+\n       procedure Put_Union_Membership\n         (S : in out Sink'Class; Root : Root_Type) is\n \n@@ -2835,6 +3092,10 @@ package body Gen_IL.Gen is\n          end loop;\n       end Put_Union_Membership;\n \n+      ---------------------\n+      -- Put_Sinfo_Dot_H --\n+      ---------------------\n+\n       procedure Put_Sinfo_Dot_H is\n          S : Sink'Class := Create_File (\"sinfo.h\");\n \n@@ -2861,6 +3122,10 @@ package body Gen_IL.Gen is\n          Put (S, \"#endif\\n\");\n       end Put_Sinfo_Dot_H;\n \n+      ---------------------\n+      -- Put_Einfo_Dot_H --\n+      ---------------------\n+\n       procedure Put_Einfo_Dot_H is\n          S : Sink'Class := Create_File (\"einfo.h\");\n \n@@ -2946,7 +3211,7 @@ package body Gen_IL.Gen is\n       Compute_Fields_Per_Node;\n       Compute_Field_Offsets;\n       Compute_Type_Sizes;\n-      Check_For_Syntactic_Mismatch;\n+      Check_For_Syntactic_Field_Mismatch;\n \n       Verify_Type_Table;\n \n@@ -2970,23 +3235,33 @@ package body Gen_IL.Gen is\n \n    end Compile;\n \n+   --------\n+   -- Sy --\n+   --------\n+\n    function Sy\n      (Field      : Node_Field;\n       Field_Type : Type_Enum;\n       Default_Value : Field_Default_Value := No_Default;\n-      Pre        : String := \"\") return Field_Sequence is\n+      Pre, Pre_Get, Pre_Set : String := \"\") return Field_Sequence is\n    begin\n       return\n-        (1 => Create_Syntactic_Field (Field, Field_Type, Default_Value, Pre));\n+        (1 => Create_Syntactic_Field\n+           (Field, Field_Type, Default_Value, Pre, Pre_Get, Pre_Set));\n    end Sy;\n \n+   --------\n+   -- Sm --\n+   --------\n+\n    function Sm\n      (Field      : Field_Enum;\n       Field_Type : Type_Enum;\n       Type_Only  : Type_Only_Enum := No_Type_Only;\n-      Pre        : String := \"\") return Field_Sequence is\n+      Pre, Pre_Get, Pre_Set : String := \"\") return Field_Sequence is\n    begin\n-      return (1 => Create_Semantic_Field (Field, Field_Type, Type_Only, Pre));\n+      return (1 => Create_Semantic_Field\n+                (Field, Field_Type, Type_Only, Pre, Pre_Get, Pre_Set));\n    end Sm;\n \n end Gen_IL.Gen;"}, {"sha": "34ce2d6081e82fecc5422484be84cda26ae667ea", "filename": "gcc/ada/gen_il-gen.ads", "status": "modified", "additions": 93, "deletions": 71, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7cadd18606c9c3ce2776b6f876ca98849b24b84/gcc%2Fada%2Fgen_il-gen.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7cadd18606c9c3ce2776b6f876ca98849b24b84/gcc%2Fada%2Fgen_il-gen.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgen_il-gen.ads?ref=a7cadd18606c9c3ce2776b6f876ca98849b24b84", "patch": "@@ -23,104 +23,121 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+--  \"Language design is library design and library design is language design\".\n+--    -- Bjarne Stroustrup\n+\n+--  This package provides a \"little language\" for defining type hierarchies,\n+--  which we call \"Gen_IL.Gen\". In particular, it is used to describe the type\n+--  hierarchies rooted at Node_Id and Entity_Id in the intermediate language\n+--  used by GNAT.\n+\n+--  The type hierarchy is a strict hierarchy (treeish, no multiple\n+--  inheritance). We have \"abstract\" and \"concrete\" types. Each type has a\n+--  \"parent\", except for the root type (Node_Id or Entity_Id). All leaf types\n+--  in the hierarchy are concrete; all nonleaf types (including the two root\n+--  types) are abstract. One can create instances of concrete, but not\n+--  abstract, types.\n+--\n+--  Descendants of Node_Id/Node_Kind are node types, and descendants of\n+--  Entity_Id/Entity_Kind are entity types.\n+--\n+--  Types have \"fields\". Each type inherits all the fields from its parent, and\n+--  may add new ones. A node field can be marked \"syntactic\"; entity fields are\n+--  never syntactic. A nonsyntactic field is \"semantic\".\n+--\n+--  If a field is syntactic, then the constructors in Nmake take a parameter to\n+--  initialize that field. In addition, the tree-traversal routines in Atree\n+--  (Traverse_Func and Traverse_Proc) traverse syntactic fields that are of\n+--  type Node_Id (or subtypes of Node_Id) or List_Id. Finally, (with some\n+--  exceptions documented in the body) the setter for a syntactic node or list\n+--  field \"Set_F (N, Val)\" will set the Parent of Val to N, unless Val is Empty\n+--  or Error[_List].\n+--\n+--  Note that the same field can be syntactic in some node types but semantic\n+--  in other node types. This is an added complexity that we might want to\n+--  eliminate someday. We shouldn't add any new such cases.\n+--\n+--  A \"program\" written in the Gen_IL.Gen language consists of calls to the\n+--  \"Create_...\" routines below, followed by a call to Compile, also below. In\n+--  order to understand what's going on, you need to look not only at the\n+--  Gen_IL.Gen \"code\", but at the output of the compiler -- at least, look at\n+--  the specs of Sinfo.Nodes and Einfo.Entities, because GNAT invokes those\n+--  directly. It's not like a normal language where you don't usually have to\n+--  look at the generated machine code.\n+--\n+--  Thus, the Gen_IL.Gen code is really Ada code, and when you run it as an Ada\n+--  program, it generates the above-mentioned files. The program is somewhat\n+--  unusual in that it has no input. Everything it needs to generate code is\n+--  embodied in it.\n+\n+--  Why don't we just use a variant record, instead of inventing a wheel?\n+--  Or a hierarchy of tagged types?\n+--\n+--  The key feature that Ada's variant records and tagged types lack, and that\n+--  this little language has, is that if two types have a field with the same\n+--  name, then those are the same field, even though they weren't inherited\n+--  from a common ancestor. Such fields are required to have the same type, the\n+--  same default value, and the same extra precondition.\n+\n with Gen_IL.Types;  use Gen_IL.Types;\n pragma Warnings (Off);\n with Gen_IL.Fields; use Gen_IL.Fields; -- for children\n pragma Warnings (On);\n-with Gen_IL.Utils;  use Gen_IL.Utils;\n-use Gen_IL.Utils.Type_Vectors;\n-use Gen_IL.Utils.Field_Vectors;\n+with Gen_IL.Internals;  use Gen_IL.Internals;\n+use Gen_IL.Internals.Type_Vectors;\n+use Gen_IL.Internals.Field_Vectors;\n \n package Gen_IL.Gen is\n \n-   --  \"Language design is library design and library design is language\n-   --  design\".\n-   --    -- Bjarne Stroustrup\n-\n-   --  This package provides a \"little language\" for defining type hierarchies,\n-   --  which we call \"Gen_IL.Gen\". In particular, it is used to describe the\n-   --  type hierarchies rooted at Node_Id and Entity_Id in the intermediate\n-   --  language used by GNAT.\n-\n-   --  The type hierarchy is a strict hierarchy (treeish, no multiple\n-   --  inheritance). We have \"abstract\" and \"concrete\" types. Each type has a\n-   --  \"parent\", except for the root type (Node_Id or Entity_Id). All leaf\n-   --  types in the hierarchy are concrete; all nonleaf types (including the\n-   --  two root types) are abstract. One can create instances of concrete, but\n-   --  not abstract, types.\n-   --\n-   --  Descendants of Node_Id/Node_Kind are node types, and descendants of\n-   --  Entity_Id/Entity_Kind are entity types.\n-   --\n-   --  Types have \"fields\". Each type inherits all the fields from its parent,\n-   --  and may add new ones. A node field can be marked \"syntactic\"; entity\n-   --  fields are never syntactic. A nonsyntactic field is \"semantic\".\n-   --\n-   --  If a field is syntactic, then the constructors in Nmake take a parameter\n-   --  to initialize that field. In addition, the tree-traversal routines in\n-   --  Atree (Traverse_Func and Traverse_Proc) traverse syntactic fields that\n-   --  are of type Node_Id (or subtypes of Node_Id) or List_Id. Finally, (with\n-   --  some exceptions documented in the body) the setter for a syntactic node\n-   --  or list field \"Set_F (N, Val)\" will set the Parent of Val to N, unless\n-   --  Val is Empty or Error[_List].\n-   --\n-   --  Note that the same field can be syntactic in some node types but\n-   --  semantic in other node types. This is an added complexity that we might\n-   --  want to eliminate someday. We shouldn't add any new such cases.\n-   --\n-   --  A \"program\" written in the Gen_IL.Gen language consists of calls to the\n-   --  \"Create_...\" routines below, followed by a call to Compile, also below.\n-   --  In order to understand what's going on, you need to look not only at the\n-   --  Gen_IL.Gen \"code\", but at the output of the compiler -- at least, look\n-   --  at the specs of Sinfo.Nodes and Einfo.Entities, because GNAT invokes\n-   --  those directly. It's not like a normal language where you don't usually\n-   --  have to look at the generated machine code.\n-   --\n-   --  Thus, the Gen_IL.Gen code is really Ada code, and when you run it as an\n-   --  Ada program, it generates the above-mentioned files. The program is\n-   --  somewhat unusual in that it has no input. Everything it needs to\n-   --  generate code is embodied in it.\n-\n-   --  Why don't we just use a variant record, instead of inventing a wheel?\n-   --  Or a hierarchy of tagged types?\n-   --\n-   --  The key feature that Ada's variant records and tagged types lack, and\n-   --  that this little language has, is that if two types have a field with\n-   --  the same name, then those are the same field, even though they weren't\n-   --  inherited from a common ancestor. Such fields are required to have the\n-   --  same type, the same default value, and the same extra precondition.\n-\n    procedure Create_Root_Node_Type\n      (T : Abstract_Node;\n       Fields : Field_Sequence := No_Fields)\n       with Pre => T = Node_Kind;\n+   --  Create the root node type (Node_Kind), which is an abstract type\n+\n    procedure Create_Abstract_Node_Type\n      (T : Abstract_Node; Parent : Abstract_Type;\n       Fields : Field_Sequence := No_Fields);\n+   --  Create an abstract node type (other than the root node type)\n+\n    procedure Create_Concrete_Node_Type\n      (T : Concrete_Node; Parent : Abstract_Type;\n       Fields : Field_Sequence := No_Fields);\n+   --  Create a concrete node type. Every node is an instance of a concrete\n+   --  node type.\n+\n    procedure Create_Root_Entity_Type\n      (T : Abstract_Entity;\n       Fields : Field_Sequence := No_Fields)\n       with Pre => T = Entity_Kind;\n+   --  Create the root entity type (Entity_Kind), which is an abstract type\n+\n    procedure Create_Abstract_Entity_Type\n      (T : Abstract_Entity; Parent : Abstract_Type;\n       Fields : Field_Sequence := No_Fields);\n+   --  Create an abstract entity type (other than the root entity type)\n+\n    procedure Create_Concrete_Entity_Type\n      (T : Concrete_Entity; Parent : Abstract_Type;\n       Fields : Field_Sequence := No_Fields);\n+   --  Create a concrete entity type. Every entity is an instance of a concrete\n+   --  entity type.\n \n    function Create_Syntactic_Field\n      (Field      : Node_Field;\n       Field_Type : Type_Enum;\n       Default_Value : Field_Default_Value := No_Default;\n-      Pre        : String := \"\") return Field_Desc;\n+      Pre, Pre_Get, Pre_Set : String := \"\") return Field_Desc;\n+   --  Create a syntactic field of a node type. Entities do not have syntactic\n+   --  fields.\n+\n    function Create_Semantic_Field\n      (Field      : Field_Enum;\n       Field_Type : Type_Enum;\n       Type_Only  : Type_Only_Enum := No_Type_Only;\n-      Pre        : String := \"\") return Field_Desc;\n+      Pre, Pre_Get, Pre_Set : String := \"\") return Field_Desc;\n+   --  Create a semantic field of a node or entity type\n+\n    --  Create_Syntactic_Field is used for syntactic fields of nodes. The order\n    --  of calls to Create_Syntactic_Field determines the order of the formal\n    --  parameters of the Make_... functions in Nmake.\n@@ -134,7 +151,9 @@ package Gen_IL.Gen is\n    --  only for syntactic fields. Flag fields of syntactic nodes always have a\n    --  default value, which is False unless specified as Default_True. Pre is\n    --  an additional precondition for the field getter and setter, in addition\n-   --  to the precondition that asserts that the type has that field.\n+   --  to the precondition that asserts that the type has that field. Pre_Get\n+   --  and Pre_Set are similar to Pre, but for the getter or setter only,\n+   --  respectively.\n    --\n    --  If multiple calls to these occur for the same Field but different types,\n    --  the Field_Type and Pre must match. Default_Value should match for\n@@ -160,7 +179,7 @@ package Gen_IL.Gen is\n    --\n    --  If a type or field name does not follow the usual Mixed_Case convention,\n    --  such as \"SPARK_Pragma\", then you have to add a special case to one of\n-   --  the Image functions in Gen_IL.Utils.\n+   --  the Image functions in Gen_IL.Internals and in Treepr.\n \n    --  Forward references are not allowed. So if you say:\n    --\n@@ -176,17 +195,19 @@ package Gen_IL.Gen is\n    --  (if it's a node or entity type) to create Field_Type.\n    --\n    --  To delete a node or entity type, delete it from Gen_IL.Types, update the\n-   --  subranges in Gen_IL.Utils if necessary, and delete all occurrences from\n-   --  Gen_IL.Gen.Gen_Entities. To delete a field, delete it from\n+   --  subranges in Gen_IL.Internals if necessary, and delete all occurrences\n+   --  from Gen_IL.Gen.Gen_Entities. To delete a field, delete it from\n    --  Gen_IL.Fields, and delete all occurrences from Gen_IL.Gen.Gen_Entities.\n \n    --  If a field is not set, it is initialized by default to whatever value is\n    --  represented by all-zero bits, with two exceptions: Elist fields default\n    --  to No_Elist, and Uint fields default to Uint_0. In retrospect, it would\n    --  have been better to use No_Uint instead of Uint_0.\n \n-   procedure Create_Node_Union (T : Abstract_Node; Children : Type_Array);\n-   procedure Create_Entity_Union (T : Abstract_Entity; Children : Type_Array);\n+   procedure Create_Node_Union_Type\n+     (T : Abstract_Node; Children : Type_Array);\n+   procedure Create_Entity_Union_Type\n+     (T : Abstract_Entity; Children : Type_Array);\n    --  Create a \"union\" type that is the union of the Children. This is used\n    --  for nonhierachical types. This is the opposite of the normal \"object\n    --  oriented\" routines above, which create child types based on existing\n@@ -211,12 +232,12 @@ private\n      (Field      : Node_Field;\n       Field_Type : Type_Enum;\n       Default_Value : Field_Default_Value := No_Default;\n-      Pre        : String := \"\") return Field_Sequence;\n+      Pre, Pre_Get, Pre_Set : String := \"\") return Field_Sequence;\n    function Sm\n      (Field      : Field_Enum;\n       Field_Type : Type_Enum;\n       Type_Only  : Type_Only_Enum := No_Type_Only;\n-      Pre        : String := \"\") return Field_Sequence;\n+      Pre, Pre_Get, Pre_Set : String := \"\") return Field_Sequence;\n    --  The above functions return Field_Sequence. This is a trick to get around\n    --  the fact that Ada doesn't allow singleton positional aggregates. It\n    --  allows us to write things like:\n@@ -225,6 +246,7 @@ private\n    --         (Sy (Chars, Name_Id, Default_No_Name)));\n    --\n    --  where that thing pretending to be an aggregate is really a parenthesized\n-   --  expression.\n+   --  expression. See Gen_Nodes for documentation of the functions these are\n+   --  standing in for.\n \n end Gen_IL.Gen;"}, {"sha": "ca6c217c16389076e8a955fbfc5a65efc577eaaa", "filename": "gcc/ada/gen_il-internals.adb", "status": "renamed", "additions": 82, "deletions": 22, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7cadd18606c9c3ce2776b6f876ca98849b24b84/gcc%2Fada%2Fgen_il-internals.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7cadd18606c9c3ce2776b6f876ca98849b24b84/gcc%2Fada%2Fgen_il-internals.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgen_il-internals.adb?ref=a7cadd18606c9c3ce2776b6f876ca98849b24b84", "patch": "@@ -23,13 +23,21 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-package body Gen_IL.Utils is\n+package body Gen_IL.Internals is\n+\n+   ---------\n+   -- Nil --\n+   ---------\n \n    procedure Nil (T : Node_Or_Entity_Type) is\n    begin\n       null;\n    end Nil;\n \n+   --------------------\n+   -- Node_Or_Entity --\n+   --------------------\n+\n    function Node_Or_Entity (Root : Root_Type) return String is\n    begin\n       if Root = Node_Kind then\n@@ -39,6 +47,10 @@ package body Gen_IL.Utils is\n       end if;\n    end Node_Or_Entity;\n \n+   ------------------------------\n+   -- Num_Concrete_Descendants --\n+   ------------------------------\n+\n    function Num_Concrete_Descendants\n      (T : Node_Or_Entity_Type) return Natural is\n    begin\n@@ -72,7 +84,10 @@ package body Gen_IL.Utils is\n      (case Root is\n         when Node_Kind => Node_Field'Last,\n         when others => Entity_Field'Last);  -- Entity_Kind\n-   --  First and Last node or entity fields\n+\n+   -----------------------\n+   -- Verify_Type_Table --\n+   -----------------------\n \n    procedure Verify_Type_Table is\n    begin\n@@ -88,14 +103,18 @@ package body Gen_IL.Utils is\n                      pragma Assert\n                        (Type_Table (T).First < Type_Table (T).Last);\n \n-                  when Boundaries =>\n+                  when Type_Boundaries =>\n                      null;\n                end case;\n             end if;\n          end if;\n       end loop;\n    end Verify_Type_Table;\n \n+   --------------\n+   -- Id_Image --\n+   --------------\n+\n    function Id_Image (T : Type_Enum) return String is\n    begin\n       case T is\n@@ -105,31 +124,39 @@ package body Gen_IL.Utils is\n             return \"Node_Id\";\n          when Entity_Kind =>\n             return \"Entity_Id\";\n-         when Nkind_Type =>\n+         when Node_Kind_Type =>\n             return \"Node_Kind\";\n-         when Ekind_Type =>\n+         when Entity_Kind_Type =>\n             return \"Entity_Kind\";\n          when others =>\n             return Image (T) & \"_Id\";\n       end case;\n    end Id_Image;\n \n+   ----------------------\n+   -- Get_Set_Id_Image --\n+   ----------------------\n+\n    function Get_Set_Id_Image (T : Type_Enum) return String is\n    begin\n       case T is\n          when Node_Kind =>\n             return \"Node_Id\";\n          when Entity_Kind =>\n             return \"Entity_Id\";\n-         when Nkind_Type =>\n+         when Node_Kind_Type =>\n             return \"Node_Kind\";\n-         when Ekind_Type =>\n+         when Entity_Kind_Type =>\n             return \"Entity_Kind\";\n          when others =>\n             return Image (T);\n       end case;\n    end Get_Set_Id_Image;\n \n+   -----------\n+   -- Image --\n+   -----------\n+\n    function Image (T : Opt_Type_Enum) return String is\n    begin\n       case T is\n@@ -165,14 +192,22 @@ package body Gen_IL.Utils is\n       end case;\n    end Image;\n \n+   ------------------\n+   -- Image_Sans_N --\n+   ------------------\n+\n    function Image_Sans_N (T : Opt_Type_Enum) return String is\n       Im : constant String := Image (T);\n       pragma Assert (Im (1 .. 2) = \"N_\");\n    begin\n       return Im (3 .. Im'Last);\n    end Image_Sans_N;\n \n-   procedure Put_Images (S : in out Sink'Class; U : Type_Vector) is\n+   -------------------------\n+   -- Put_Types_With_Bars --\n+   -------------------------\n+\n+   procedure Put_Types_With_Bars (S : in out Sink'Class; U : Type_Vector) is\n       First_Time : Boolean := True;\n    begin\n       Indent (S, 3);\n@@ -188,9 +223,13 @@ package body Gen_IL.Utils is\n       end loop;\n \n       Outdent (S, 3);\n-   end Put_Images;\n+   end Put_Types_With_Bars;\n+\n+   ----------------------------\n+   -- Put_Type_Ids_With_Bars --\n+   ----------------------------\n \n-   procedure Put_Id_Images (S : in out Sink'Class; U : Type_Vector) is\n+   procedure Put_Type_Ids_With_Bars (S : in out Sink'Class; U : Type_Vector) is\n       First_Time : Boolean := True;\n    begin\n       Indent (S, 3);\n@@ -206,7 +245,11 @@ package body Gen_IL.Utils is\n       end loop;\n \n       Outdent (S, 3);\n-   end Put_Id_Images;\n+   end Put_Type_Ids_With_Bars;\n+\n+   -----------\n+   -- Image --\n+   -----------\n \n    function Image (F : Opt_Field_Enum) return String is\n    begin\n@@ -315,6 +358,10 @@ package body Gen_IL.Utils is\n    function Image (Default : Field_Default_Value) return String is\n      (Capitalize (Default'Img));\n \n+   -----------------\n+   -- Value_Image --\n+   -----------------\n+\n    function Value_Image (Default : Field_Default_Value) return String is\n    begin\n       if Default = No_Default then\n@@ -333,6 +380,10 @@ package body Gen_IL.Utils is\n       end if;\n    end Value_Image;\n \n+   -------------------\n+   -- Iterate_Types --\n+   -------------------\n+\n    procedure Iterate_Types\n      (Root  : Node_Or_Entity_Type;\n       Pre, Post : not null access procedure (T : Node_Or_Entity_Type) :=\n@@ -356,6 +407,10 @@ package body Gen_IL.Utils is\n       Recursive (Root);\n    end Iterate_Types;\n \n+   -------------------\n+   -- Is_Descendant --\n+   -------------------\n+\n    function Is_Descendant (Ancestor, Descendant : Node_Or_Entity_Type)\n      return Boolean is\n    begin\n@@ -370,6 +425,10 @@ package body Gen_IL.Utils is\n       end if;\n    end Is_Descendant;\n \n+   ------------------------\n+   -- Put_Type_Hierarchy --\n+   ------------------------\n+\n    procedure Put_Type_Hierarchy (S : in out Sink'Class; Root : Root_Type) is\n       Level : Natural := 0;\n \n@@ -383,24 +442,19 @@ package body Gen_IL.Utils is\n \n       procedure Pre (T : Node_Or_Entity_Type) is\n       begin\n-         if not Type_Table (T).Allow_Overlap then\n-            Put (S, \"--  \\1\\2\\n\", Indentation, Image (T));\n-         end if;\n-\n+         Put (S, \"--  \\1\\2\\n\", Indentation, Image (T));\n          Level := Level + 1;\n       end Pre;\n \n       procedure Post (T : Node_Or_Entity_Type) is\n       begin\n          Level := Level - 1;\n \n-         if not Type_Table (T).Allow_Overlap then\n-            --  Put out an \"end\" line only if there are many descendants, for\n-            --  an arbitrary definition of \"many\".\n+         --  Put out an \"end\" line only if there are many descendants, for\n+         --  an arbitrary definition of \"many\".\n \n-            if Num_Concrete_Descendants (T) > 10 then\n-               Put (S, \"--  \\1end \\2\\n\", Indentation, Image (T));\n-            end if;\n+         if Num_Concrete_Descendants (T) > 10 then\n+            Put (S, \"--  \\1end \\2\\n\", Indentation, Image (T));\n          end if;\n       end Post;\n \n@@ -409,6 +463,8 @@ package body Gen_IL.Utils is\n            when Node_Kind => \"nodes\",\n            when others => \"entities\");  -- Entity_Kind\n \n+   --  Start of processing for Put_Type_Hierarchy\n+\n    begin\n       Put (S, \"--  Type hierarchy for \\1\\n\", N_Or_E);\n       Put (S, \"--\\n\");\n@@ -419,6 +475,10 @@ package body Gen_IL.Utils is\n       Put (S, \"--  End type hierarchy for \\1\\n\\n\", N_Or_E);\n    end Put_Type_Hierarchy;\n \n+   ---------\n+   -- Pos --\n+   ---------\n+\n    function Pos (T : Concrete_Type) return Root_Nat is\n       First : constant Concrete_Type :=\n         (if T in Concrete_Node then Concrete_Node'First\n@@ -450,4 +510,4 @@ package body Gen_IL.Utils is\n    end Pfields;\n    pragma Warnings (On);\n \n-end Gen_IL.Utils;\n+end Gen_IL.Internals;", "previous_filename": "gcc/ada/gen_il-utils.adb"}, {"sha": "93acdb47e68da9ad4bc23ce7b1fa189158d231d6", "filename": "gcc/ada/gen_il-internals.ads", "status": "added", "additions": 255, "deletions": 0, "changes": 255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7cadd18606c9c3ce2776b6f876ca98849b24b84/gcc%2Fada%2Fgen_il-internals.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7cadd18606c9c3ce2776b6f876ca98849b24b84/gcc%2Fada%2Fgen_il-internals.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgen_il-internals.ads?ref=a7cadd18606c9c3ce2776b6f876ca98849b24b84", "patch": "@@ -0,0 +1,255 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                          G E N _ I L . U T I L S                         --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 2020-2021, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Containers.Vectors; use Ada.Containers;\n+\n+with GNAT.Strings; use GNAT.Strings;\n+\n+with Gen_IL.Types;  use Gen_IL.Types;\n+with Gen_IL.Fields; use Gen_IL.Fields;\n+\n+package Gen_IL.Internals is\n+\n+   function Image (T : Opt_Type_Enum) return String;\n+\n+   function Image_Sans_N (T : Opt_Type_Enum) return String;\n+   --  Returns the image without the leading \"N_\"\n+\n+   ----------------\n+\n+   type Type_Set is array (Type_Enum) of Boolean;\n+\n+   type Type_Index is new Positive;\n+   subtype Type_Count is Type_Index'Base range 0 .. Type_Index'Last;\n+   package Type_Vectors is new Vectors (Type_Index, Type_Enum);\n+   use Type_Vectors;\n+   subtype Type_Vector is Type_Vectors.Vector;\n+\n+   procedure Ptypes (V : Type_Vector); -- for debugging\n+\n+   type Type_Array is array (Type_Index range <>) of Type_Enum;\n+\n+   ----------------\n+\n+   procedure Put_Types_With_Bars (S : in out Sink'Class; U : Type_Vector);\n+   procedure Put_Type_Ids_With_Bars (S : in out Sink'Class; U : Type_Vector);\n+   --  Put the types with vertical bars in between, as in\n+   --     N_This | N_That | N_Other\n+   --  or\n+   --     N_This_Id | N_That_Id | N_Other_Id\n+\n+   function Id_Image (T : Type_Enum) return String;\n+   --  Image of the type for use with _Id types\n+\n+   function Get_Set_Id_Image (T : Type_Enum) return String;\n+   --  Image of the type for use with getters and setters\n+\n+   ----------------\n+\n+   type Fields_Present_Array is array (Field_Enum) of Type_Set;\n+\n+   type Field_Set is array (Field_Enum) of Boolean;\n+   type Fields_Per_Node_Type is array (Node_Or_Entity_Type) of Field_Set;\n+\n+   type Field_Index is new Positive;\n+   package Field_Vectors is new Vectors (Field_Index, Field_Enum);\n+   subtype Field_Vector is Field_Vectors.Vector;\n+   procedure Pfields (V : Field_Vector); -- for debugging\n+\n+   type Bit_Offset is new Root_Nat range 0 .. 32_000 - 1;\n+   --  Offset in bits. The number 32_000 is chosen because there are fewer than\n+   --  1000 fields, but offsets are in size units (1 bit for flags, 32 bits for\n+   --  most others, also 2, 4, and 8).\n+\n+   type Field_Offset is new Bit_Offset;\n+\n+   type Type_Info (Is_Union : Boolean) is record\n+      Parent : Opt_Abstract_Type;\n+      --  Parent of this type (single inheritance). No_Type for a root\n+      --  type (Node_Kind or Entity_Kind). For union types, this is\n+      --  a root type.\n+\n+      Children : Type_Vector;\n+      --  Inverse of Parent\n+\n+      Concrete_Descendants : Type_Vector;\n+\n+      case Is_Union is\n+         when True =>\n+            null;\n+\n+         when False =>\n+            First, Last : Concrete_Type;\n+            --  This type includes concrete types in the range First..Last. For\n+            --  a concrete type, First=Last. For an abstract type, First..Last\n+            --  includes two or more types.\n+\n+            Fields : Field_Vector;\n+      end case;\n+   end record;\n+\n+   type Type_Info_Ptr is access all Type_Info;\n+\n+   Type_Table : array (Node_Or_Entity_Type) of Type_Info_Ptr;\n+   --  Table mapping from enumeration literals representing types to\n+   --  information about the type.\n+\n+   procedure Verify_Type_Table;\n+   --  Check Type_Table for consistency\n+\n+   function Num_Concrete_Descendants\n+     (T : Node_Or_Entity_Type) return Natural;\n+   --  Number of concrete descendants of T, including (if T is concrete)\n+   --  itself.\n+\n+   type Field_Default_Value is\n+     (No_Default,\n+      Default_Empty, -- Node_Id\n+      Default_No_List, Default_Empty_List, -- List_Id\n+      Default_False, Default_True, -- Flag\n+      Default_No_Elist, -- Elist_Id\n+      Default_No_Name, -- Name_Id\n+      Default_Uint_0); -- Uint\n+   --  Default value for a field in the Nmake functions. No_Default if the\n+   --  field parameter has no default value. Otherwise this indicates the\n+   --  default value used, which must matcht the type of the field.\n+\n+   function Image (Default : Field_Default_Value) return String;\n+   --  This will be something like \"Default_Empty\".\n+   function Value_Image (Default : Field_Default_Value) return String;\n+   --  This will be something like \"Empty\".\n+\n+   type Type_Only_Enum is\n+     (No_Type_Only, Base_Type_Only, Impl_Base_Type_Only, Root_Type_Only);\n+   --  These correspond to the \"[base type only]\", \"[implementation base type\n+   --  only]\", and \"[root type only]\" annotations documented in einfo.ads.\n+   --  The default is No_Type_Only, indicating the field is not one of\n+   --  these special \"[... only]\" ones.\n+\n+   type Field_Info is record\n+      Have_This_Field : Type_Vector;\n+      --  Types that have this field\n+\n+      Field_Type      : Type_Enum;\n+      --  Type of the field. Currently, we use Node_Id for all node-valued\n+      --  fields, but we could narrow down to children of that. Similar for\n+      --  Entity_Id.\n+\n+      Default_Value   : Field_Default_Value;\n+      Type_Only       : Type_Only_Enum;\n+      Pre, Pre_Get, Pre_Set : String_Access;\n+      --  Above record the information in the calls to Create_...Field.\n+      --  See Gen_IL.Gen for details.\n+\n+      Offset          : Field_Offset;\n+      --  Offset of the field from the start of the node, in units of the field\n+      --  size. So if a field is 4 bits in size, it starts at bit number\n+      --  Offset*4 from the start of the node.\n+   end record;\n+\n+   type Field_Info_Ptr is access all Field_Info;\n+\n+   Field_Table : array (Field_Enum) of Field_Info_Ptr;\n+   --  Table mapping from enumeration literals representing fields to\n+   --  information about the field.\n+\n+   ----------------\n+\n+   subtype Node_Field is\n+     Field_Enum range\n+       Field_Enum'First ..\n+         Field_Enum'Pred (Between_Node_And_Entity_Fields);\n+\n+   subtype Entity_Field is\n+     Field_Enum range\n+       Field_Enum'Succ (Between_Node_And_Entity_Fields) ..\n+         Field_Enum'Last;\n+\n+   function Image (F : Opt_Field_Enum) return String;\n+\n+   procedure Nil (T : Node_Or_Entity_Type);\n+   --  Null procedure\n+\n+   procedure Iterate_Types\n+     (Root  : Node_Or_Entity_Type;\n+      Pre, Post : not null access procedure (T : Node_Or_Entity_Type) :=\n+        Nil'Access);\n+   --  Iterate top-down on the type hierarchy. Call Pre and Post before and\n+   --  after walking child types. Note that this ignores union types, because\n+   --  they are nonhierarchical.\n+\n+   function Is_Descendant (Ancestor, Descendant : Node_Or_Entity_Type)\n+     return Boolean;\n+   --  True if Descendant is a descendant of Ancestor; that is,\n+   --  True if Ancestor is an ancestor of Descendant. True for\n+   --  a type itself.\n+\n+   procedure Put_Type_Hierarchy (S : in out Sink'Class; Root : Root_Type);\n+\n+   function Pos (T : Concrete_Type) return Root_Nat;\n+   --  Return Node_Kind'Pos (T) or Entity_Kind'Pos (T)\n+\n+   ----------------\n+\n+   type Field_Desc is record\n+      F : Field_Enum;\n+      Is_Syntactic : Boolean;\n+      --  The same field can be syntactic in some nodes but semantic in others\n+   end record;\n+\n+   type Field_Sequence_Index is new Positive;\n+   type Field_Sequence is array (Field_Sequence_Index range <>) of Field_Desc;\n+   No_Fields : constant Field_Sequence := (1 .. 0 => <>);\n+\n+   type Field_Array is array (Bit_Offset range <>) of Opt_Field_Enum;\n+   type Field_Array_Ptr is access all Field_Array;\n+\n+   type Concrete_Type_Layout_Array is array (Concrete_Type) of Field_Array_Ptr;\n+   --  Mapping from types to mappings from offsets to fields. Each bit offset\n+   --  is mapped to the corresponding field for the given type. An n-bit field\n+   --  will have n bit offsets mapped to the same field.\n+\n+   type Offset_To_Fields_Mapping is\n+     array (Bit_Offset range <>) of Field_Array_Ptr;\n+   --  Mapping from bit offsets to fields using that offset\n+\n+   function First_Abstract (Root : Root_Type) return Abstract_Type;\n+   function Last_Abstract (Root : Root_Type) return Abstract_Type;\n+   --  First and Last abstract types descended from the Root. So for example if\n+   --  Root = Node_Kind, then First_Abstract = Abstract_Node'First.\n+\n+   function First_Concrete (Root : Root_Type) return Concrete_Type;\n+   function Last_Concrete (Root : Root_Type) return Concrete_Type;\n+   --  First and Last concrete types descended from the Root\n+\n+   function First_Field (Root : Root_Type) return Field_Enum;\n+   function Last_Field (Root : Root_Type) return Field_Enum;\n+   --  First and Last node or entity fields\n+\n+   function Node_Or_Entity (Root : Root_Type) return String;\n+   --  Return \"Node\" or \"Entity\" depending on whether Root = Node_Kind or\n+   --  Entity_Kind.\n+\n+end Gen_IL.Internals;"}, {"sha": "6d0af217e8579724764056b46c148a59972629fb", "filename": "gcc/ada/gen_il-types.ads", "status": "modified", "additions": 83, "deletions": 11, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7cadd18606c9c3ce2776b6f876ca98849b24b84/gcc%2Fada%2Fgen_il-types.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7cadd18606c9c3ce2776b6f876ca98849b24b84/gcc%2Fada%2Fgen_il-types.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgen_il-types.ads?ref=a7cadd18606c9c3ce2776b6f876ca98849b24b84", "patch": "@@ -27,17 +27,20 @@ package Gen_IL.Types is\n \n    --  Enumeration of all the types that are \"of interest\". We have an\n    --  enumeration literal here for every node kind, every entity kind,\n-   --  andevery type that can be the type of a field.\n-\n-   --  The \"Between_...\" literals below are simply for making subranges.\n-   --  When adding literals to this enumeration type, be sure to put them\n-   --  in the right place so they end up in the appropriate subranges in\n-   --  Gen_IL.Utils (Abstract_Node, Abstract_Entity, Concrete_Node,\n-   --  Concrete_Entity).\n+   --  and every type that can be the type of a field.\n \n    --  The following is \"optional type enumeration\" -- i.e. it is Type_Enum\n-   --  (declared in Gen_IL.Utils) plus the special null value No_Type.\n-   --  See the spec of Gen_IL.Gen for how to modify this.\n+   --  (declared below) plus the special null value No_Type.  See the spec of\n+   --  Gen_IL.Gen for how to modify this. (Of course, in Ada we have to define\n+   --  this backwards from the above conceptual description.)\n+\n+   --  Note that there are various subranges of this type declared below,\n+   --  which might need to be kept in sync when modifying this.\n+\n+   --  The \"Between_...\" literals below are simply for making the subranges.\n+   --  When adding literals to this enumeration type, be sure to put them in\n+   --  the right place so they end up in the appropriate subranges\n+   --  (Abstract_Node, Abstract_Entity, Concrete_Node, Concrete_Entity).\n \n    type Opt_Type_Enum is\n      (No_Type,\n@@ -54,8 +57,8 @@ package Gen_IL.Types is\n       Uint,\n       Ureal,\n \n-      Nkind_Type, -- Type of result of Nkind function, i.e. Node_Kind\n-      Ekind_Type, -- Type of result of Ekind function, i.e. Entity_Kind\n+      Node_Kind_Type, -- Type of result of Nkind function, i.e. Node_Kind\n+      Entity_Kind_Type, -- Type of result of Ekind function, i.e. Entity_Kind\n       Source_Ptr,\n       Small_Paren_Count_Type,\n       Union_Id,\n@@ -146,6 +149,7 @@ package Gen_IL.Types is\n       Incomplete_Or_Private_Kind,\n       Integer_Kind,\n       Modular_Integer_Kind,\n+      Named_Access_Kind,\n       Named_Kind,\n       Numeric_Kind,\n       Object_Kind,\n@@ -493,4 +497,72 @@ package Gen_IL.Types is\n \n      ); -- Type_Enum\n \n+   subtype Type_Enum is Opt_Type_Enum\n+     range Opt_Type_Enum'Succ (No_Type) .. Opt_Type_Enum'Last;\n+   --  Enumeration of types -- Opt_Type_Enum without the special null value\n+   --  No_Type.\n+\n+   subtype Node_Or_Entity_Type is\n+     Type_Enum range\n+       Type_Enum'Succ (Between_Special_And_Abstract_Node_Types) ..\n+         Type_Enum'Last;\n+\n+   subtype Abstract_Type is\n+     Type_Enum range\n+       Type_Enum'Succ (Between_Special_And_Abstract_Node_Types) ..\n+         Type_Enum'Pred (Between_Abstract_Entity_And_Concrete_Node_Types);\n+   subtype Abstract_Node is\n+     Abstract_Type range\n+       Type_Enum'Succ (Between_Special_And_Abstract_Node_Types) ..\n+         Type_Enum'Pred (Between_Abstract_Node_And_Abstract_Entity_Types);\n+   subtype Abstract_Entity is\n+     Abstract_Type range\n+       Type_Enum'Succ (Between_Abstract_Node_And_Abstract_Entity_Types) ..\n+         Type_Enum'Pred (Between_Abstract_Entity_And_Concrete_Node_Types);\n+\n+   subtype Concrete_Type is\n+     Type_Enum range\n+       Type_Enum'Succ (Between_Abstract_Entity_And_Concrete_Node_Types) ..\n+         Type_Enum'Last;\n+   subtype Concrete_Node is\n+     Concrete_Type range\n+       Type_Enum'Succ (Between_Abstract_Entity_And_Concrete_Node_Types) ..\n+         Type_Enum'Pred (Between_Concrete_Node_And_Concrete_Entity_Types);\n+   subtype Concrete_Entity is\n+     Concrete_Type range\n+       Type_Enum'Succ (Between_Concrete_Node_And_Concrete_Entity_Types) ..\n+         Type_Enum'Last;\n+\n+   subtype Root_Type is Abstract_Type with\n+        Predicate => Root_Type in Node_Kind | Entity_Kind;\n+\n+   subtype Node_Type is Node_Or_Entity_Type with\n+        Predicate => Node_Type in Abstract_Node | Concrete_Node;\n+   subtype Entity_Type is Node_Or_Entity_Type with\n+        Predicate => Entity_Type in Abstract_Entity | Concrete_Entity;\n+\n+   subtype Special_Type is Type_Enum range\n+     Flag .. Type_Enum'Pred (Between_Special_And_Abstract_Node_Types);\n+\n+   subtype Traversed_Field_Type is Type_Enum with Predicate =>\n+     Traversed_Field_Type in Node_Id | List_Id | Node_Type;\n+   --  These are the types of fields traversed by Traverse_Func\n+\n+   subtype Entity_Node is Node_Type with\n+     Predicate => Entity_Node in\n+        N_Defining_Character_Literal\n+      | N_Defining_Identifier\n+      | N_Defining_Operator_Symbol;\n+\n+   subtype Opt_Abstract_Type is Opt_Type_Enum with\n+        Predicate => Opt_Abstract_Type = No_Type or\n+        Opt_Abstract_Type in Abstract_Type;\n+\n+   subtype Type_Boundaries is Type_Enum with\n+        Predicate => Type_Boundaries in\n+          Between_Abstract_Node_And_Abstract_Entity_Types |\n+          Between_Abstract_Entity_And_Concrete_Node_Types |\n+          Between_Concrete_Node_And_Concrete_Entity_Types;\n+   --  These are not used, other than to separate the various subranges.\n+\n end Gen_IL.Types;"}, {"sha": "f264a5f5650a8ee776b1156197efab11ea6c6813", "filename": "gcc/ada/gen_il-utils.ads", "status": "removed", "additions": 0, "deletions": 558, "changes": 558, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81e68a1954366f6b1730d75c932814121d743aa3/gcc%2Fada%2Fgen_il-utils.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81e68a1954366f6b1730d75c932814121d743aa3/gcc%2Fada%2Fgen_il-utils.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgen_il-utils.ads?ref=81e68a1954366f6b1730d75c932814121d743aa3", "patch": "@@ -1,558 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                          G E N _ I L . U T I L S                         --\n---                                                                          --\n---                                 S p e c                                  --\n---                                                                          --\n---          Copyright (C) 2020-2021, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n-with Ada.Containers.Vectors; use Ada.Containers;\n-\n-with Gen_IL.Types;  use Gen_IL.Types;\n-with Gen_IL.Fields; use Gen_IL.Fields;\n-\n-package Gen_IL.Utils is\n-\n-   subtype Type_Enum is Opt_Type_Enum\n-     range Opt_Type_Enum'Succ (No_Type) .. Opt_Type_Enum'Last;\n-   --  Enumeration of types -- Opt_Type_Enum without the special null value\n-   --  No_Type.\n-\n-   subtype Node_Or_Entity_Type is\n-     Type_Enum range\n-       Type_Enum'Succ (Between_Special_And_Abstract_Node_Types) ..\n-         Type_Enum'Last;\n-\n-   subtype Abstract_Type is\n-     Type_Enum range\n-       Type_Enum'Succ (Between_Special_And_Abstract_Node_Types) ..\n-         Type_Enum'Pred (Between_Abstract_Entity_And_Concrete_Node_Types);\n-   subtype Abstract_Node is\n-     Abstract_Type range\n-       Type_Enum'Succ (Between_Special_And_Abstract_Node_Types) ..\n-         Type_Enum'Pred (Between_Abstract_Node_And_Abstract_Entity_Types);\n-   subtype Abstract_Entity is\n-     Abstract_Type range\n-       Type_Enum'Succ (Between_Abstract_Node_And_Abstract_Entity_Types) ..\n-         Type_Enum'Pred (Between_Abstract_Entity_And_Concrete_Node_Types);\n-\n-   subtype Concrete_Type is\n-     Type_Enum range\n-       Type_Enum'Succ (Between_Abstract_Entity_And_Concrete_Node_Types) ..\n-         Type_Enum'Last;\n-   subtype Concrete_Node is\n-     Concrete_Type range\n-       Type_Enum'Succ (Between_Abstract_Entity_And_Concrete_Node_Types) ..\n-         Type_Enum'Pred (Between_Concrete_Node_And_Concrete_Entity_Types);\n-   subtype Concrete_Entity is\n-     Concrete_Type range\n-       Type_Enum'Succ (Between_Concrete_Node_And_Concrete_Entity_Types) ..\n-         Type_Enum'Last;\n-\n-   subtype Root_Type is Abstract_Type with\n-        Predicate => Root_Type in Node_Kind | Entity_Kind;\n-\n-   subtype Node_Type is Node_Or_Entity_Type with\n-        Predicate => Node_Type in Abstract_Node | Concrete_Node;\n-   subtype Entity_Type is Node_Or_Entity_Type with\n-        Predicate => Entity_Type in Abstract_Entity | Concrete_Entity;\n-\n-   subtype Special_Type is Type_Enum range\n-     Flag .. Type_Enum'Pred (Between_Special_And_Abstract_Node_Types);\n-\n-   subtype Traversal_Type is Type_Enum with Predicate =>\n-     Traversal_Type in Node_Id | List_Id | Node_Type;\n-   --  These are the types of fields traversed by Traverse_Func\n-\n-   subtype Entity_Node is Node_Type with\n-     Predicate => Entity_Node in\n-        N_Defining_Character_Literal\n-      | N_Defining_Identifier\n-      | N_Defining_Operator_Symbol;\n-\n-   function Image (T : Opt_Type_Enum) return String;\n-\n-   function Image_Sans_N (T : Opt_Type_Enum) return String;\n-   --  Returns the image without the leading \"N_\"\n-\n-   subtype Boundaries is Type_Enum with\n-        Predicate => Boundaries in\n-          Between_Abstract_Node_And_Abstract_Entity_Types |\n-          Between_Abstract_Entity_And_Concrete_Node_Types |\n-          Between_Concrete_Node_And_Concrete_Entity_Types;\n-\n-   ----------------\n-\n-   type Type_Set is array (Type_Enum) of Boolean;\n-\n-   type Type_Index is new Positive;\n-   subtype Type_Count is Type_Index'Base range 0 .. Type_Index'Last;\n-   package Type_Vectors is new Vectors (Type_Index, Type_Enum);\n-   use Type_Vectors;\n-   subtype Type_Vector is Type_Vectors.Vector;\n-\n-   procedure Ptypes (V : Type_Vector); -- for debugging\n-\n-   type Type_Array is array (Type_Index range <>) of Type_Enum;\n-\n-   subtype Field_Enum is Opt_Field_Enum\n-     range Opt_Field_Enum'Succ (No_Field) .. Opt_Field_Enum'Last;\n-   --  Enumeration of fields -- Opt_Field_Enum without the special null value\n-   --  No_Field.\n-\n-   subtype Node_Header_Type is Type_Enum range\n-     Nkind_Type .. Union_Id;\n-   subtype Node_Header_Field is Field_Enum with Predicate =>\n-     Node_Header_Field in Nkind .. Link | Ekind;\n-\n-   type Fields_Present_Array is array (Field_Enum) of Type_Set;\n-\n-   type Field_Set is array (Field_Enum) of Boolean;\n-   type Fields_Per_Node_Type is array (Node_Or_Entity_Type) of Field_Set;\n-\n-   type Field_Index is new Positive;\n-   subtype Field_Count is Field_Index'Base range 0 .. Field_Index'Last;\n-   package Field_Vectors is new Vectors (Field_Index, Field_Enum);\n-   subtype Field_Vector is Field_Vectors.Vector;\n-   procedure Pfields (V : Field_Vector); -- for debugging\n-\n-   subtype Opt_Abstract_Type is Opt_Type_Enum with\n-        Predicate => Opt_Abstract_Type = No_Type or\n-        Opt_Abstract_Type in Abstract_Type;\n-\n-   procedure Put_Images (S : in out Sink'Class; U : Type_Vector);\n-   procedure Put_Id_Images (S : in out Sink'Class; U : Type_Vector);\n-   --  Put the types with vertical bars in between, as in\n-   --     N_This | N_That | N_Other\n-   --  or\n-   --     N_This_Id | N_That_Id | N_Other_Id\n-\n-   function Id_Image (T : Type_Enum) return String;\n-   function Get_Set_Id_Image (T : Type_Enum) return String;\n-\n-   type Bit_Offset is new Root_Nat range 0 .. 32_000 - 1;\n-   --  There are fewer than 1000 fields. But offsets are in size units (1 bit\n-   --  for flags, 32 bits for most others, also 2, 4, and 8).\n-\n-   type Field_Offset is new Bit_Offset;\n-\n-   type Type_Info (Is_Union : Boolean) is record\n-      Parent : Opt_Abstract_Type;\n-      --  Parent of this type (single inheritance). No_Type for a root\n-      --  type (Node_Kind or Entity_Kind). For union types, this is\n-      --  a root type.\n-\n-      Children : Type_Vector;\n-      --  Inverse of Parent\n-\n-      Concrete_Descendants : Type_Vector;\n-\n-      case Is_Union is\n-         when True =>\n-            null;\n-\n-         when False =>\n-            First, Last : Concrete_Type;\n-            --  This type includes concrete types in the range First..Last. For\n-            --  a concrete type, First=Last. For an abstract type, First..Last\n-            --  includes two or more types.\n-\n-            Fields : Field_Vector;\n-\n-            Allow_Overlap : Boolean;\n-            --  True to allow overlapping subranges\n-      end case;\n-   end record;\n-\n-   type Type_Info_Ptr is access all Type_Info;\n-\n-   Type_Table : array (Node_Or_Entity_Type) of Type_Info_Ptr;\n-   --  Table mapping from enumeration literals representing types to\n-   --  information about the type.\n-\n-   function Num_Concrete_Descendants\n-     (T : Node_Or_Entity_Type) return Natural;\n-   --  Number of concrete descendants of T, including (if T is concrete)\n-   --  itself.\n-\n-   type Field_Default_Value is\n-     (No_Default,\n-      Default_Empty, -- Node_Id\n-      Default_No_List, Default_Empty_List, -- List_Id\n-      Default_False, Default_True, -- Flag\n-      Default_No_Elist, -- Elist_Id\n-      Default_No_Name, -- Name_Id\n-      Default_Uint_0); -- Uint\n-   --  Default value for a field in the Nmake functions. No_Default if the\n-   --  field parameter has no default value. Otherwise this indicates the\n-   --  default value used, which must matcht the type of the field.\n-\n-   type Type_Only_Enum is\n-     (No_Type_Only, Base_Type_Only, Impl_Base_Type_Only, Root_Type_Only);\n-   --  ????These correspond to the \"[base type only]\", \"[implementation base\n-   --  type only]\", and \"[root type only]\" annotations in the old einfo.ads.\n-   --  Move the relevant comments here. There is no comment explaining\n-   --  [root type only] in the old einfo.ads.\n-\n-   function Image (Default : Field_Default_Value) return String;\n-   function Value_Image (Default : Field_Default_Value) return String;\n-\n-   type Field_Info is record\n-      Have_This_Field : Type_Vector;\n-\n-      Field_Type      : Type_Enum;\n-      --  Type of the field. Currently, we use Node_Id for all node-valued\n-      --  fields, but we could narrow down to children of that. Similar for\n-      --  Entity_Id.\n-\n-      Default_Value   : Field_Default_Value;\n-      Type_Only       : Type_Only_Enum;\n-      Pre             : String_Ptr;\n-\n-      Offset          : Field_Offset;\n-      --  Offset of the field, in units of the field size. So if a field is 4\n-      --  bits, it starts at bit number Offset*4 from the start of the node.\n-   end record;\n-\n-   type Field_Info_Ptr is access all Field_Info;\n-\n-   Field_Table : array (Field_Enum) of Field_Info_Ptr;\n-   --  Table mapping from enumeration literals representing fields to\n-   --  information about the field.\n-\n-   procedure Verify_Type_Table;\n-\n-   ----------------\n-\n-   subtype Node_Field is\n-     Field_Enum range\n-       Field_Enum'First ..\n-         Field_Enum'Pred (Between_Node_And_Entity_Fields);\n-\n-   subtype Entity_Field is\n-     Field_Enum range\n-       Field_Enum'Succ (Between_Node_And_Entity_Fields) ..\n-         Field_Enum'Last;\n-\n-   function Image (F : Opt_Field_Enum) return String;\n-\n-   procedure Nil (T : Node_Or_Entity_Type);\n-   --  Null procedure\n-\n-   procedure Iterate_Types\n-     (Root  : Node_Or_Entity_Type;\n-      Pre, Post : not null access procedure (T : Node_Or_Entity_Type) :=\n-        Nil'Access);\n-   --  Iterate top-down on the type hierarchy. Call Pre and Post before and\n-   --  after walking child types. Note that this ignores union types, because\n-   --  they are nonhierarchical.\n-\n-   function Is_Descendant (Ancestor, Descendant : Node_Or_Entity_Type)\n-     return Boolean;\n-   --  True if Descendant is a descendant of Ancestor; that is,\n-   --  True if Ancestor is an ancestor of Descendant. True for\n-   --  a type itself.\n-\n-   procedure Put_Type_Hierarchy (S : in out Sink'Class; Root : Root_Type);\n-\n-   function Pos (T : Concrete_Type) return Root_Nat;\n-   --  Return Node_Kind'Pos (T) or Entity_Kind'Pos (T)\n-\n-   ----------------\n-\n-   --  The same field can be syntactic in some nodes but semantic in others:\n-\n-   type Field_Desc is record\n-      F : Field_Enum;\n-      Is_Syntactic : Boolean;\n-   end record;\n-\n-   type Field_Sequence_Index is new Positive;\n-   type Field_Sequence is array (Field_Sequence_Index range <>) of Field_Desc;\n-   No_Fields : constant Field_Sequence := (1 .. 0 => <>);\n-\n-   type Field_Array is array (Bit_Offset range <>) of Opt_Field_Enum;\n-   type Field_Array_Ptr is access all Field_Array;\n-\n-   type Type_Layout_Array is array (Concrete_Type) of Field_Array_Ptr;\n-   --  Mapping from types to mappings from offsets to fields\n-\n-   type Offset_To_Fields_Mapping is\n-     array (Bit_Offset range <>) of Field_Array_Ptr;\n-   --  Mapping from bit offsets to fields using that offset\n-\n-   function First_Abstract (Root : Root_Type) return Abstract_Type;\n-   function Last_Abstract (Root : Root_Type) return Abstract_Type;\n-   --  First and Last abstract types descended from the Root\n-\n-   function First_Concrete (Root : Root_Type) return Concrete_Type;\n-   function Last_Concrete (Root : Root_Type) return Concrete_Type;\n-   --  First and Last concrete types descended from the Root\n-\n-   function First_Field (Root : Root_Type) return Field_Enum;\n-   function Last_Field (Root : Root_Type) return Field_Enum;\n-   --  First and Last node or entity fields\n-\n-   function Node_Or_Entity (Root : Root_Type) return String;\n-   --  Return \"Node\" or \"Entity\" depending on whether Root = Node_Kind\n-\n-   type Sinfo_Node_Order_Index is new Positive;\n-   Sinfo_Node_Order :\n-     constant array (Sinfo_Node_Order_Index range <>) of Node_Type :=\n-     --  The order in which the documentation of node kinds appears in the old\n-     --  sinfo.ads. This is the same order of the functions in Nmake.\n-     --  Sinfo_Node_Order was constructed  by massaging nmake.ads.\n-     (N_Unused_At_Start,\n-      N_Unused_At_End,\n-      N_Identifier,\n-      N_Integer_Literal,\n-      N_Real_Literal,\n-      N_Character_Literal,\n-      N_String_Literal,\n-      N_Pragma,\n-      N_Pragma_Argument_Association,\n-      N_Defining_Identifier,\n-      N_Full_Type_Declaration,\n-      N_Subtype_Declaration,\n-      N_Subtype_Indication,\n-      N_Object_Declaration,\n-      N_Number_Declaration,\n-      N_Derived_Type_Definition,\n-      N_Range_Constraint,\n-      N_Range,\n-      N_Enumeration_Type_Definition,\n-      N_Defining_Character_Literal,\n-      N_Signed_Integer_Type_Definition,\n-      N_Modular_Type_Definition,\n-      N_Floating_Point_Definition,\n-      N_Real_Range_Specification,\n-      N_Ordinary_Fixed_Point_Definition,\n-      N_Decimal_Fixed_Point_Definition,\n-      N_Digits_Constraint,\n-      N_Unconstrained_Array_Definition,\n-      N_Constrained_Array_Definition,\n-      N_Component_Definition,\n-      N_Discriminant_Specification,\n-      N_Index_Or_Discriminant_Constraint,\n-      N_Discriminant_Association,\n-      N_Record_Definition,\n-      N_Component_List,\n-      N_Component_Declaration,\n-      N_Variant_Part,\n-      N_Variant,\n-      N_Others_Choice,\n-      N_Access_To_Object_Definition,\n-      N_Access_Function_Definition,\n-      N_Access_Procedure_Definition,\n-      N_Access_Definition,\n-      N_Incomplete_Type_Declaration,\n-      N_Explicit_Dereference,\n-      N_Indexed_Component,\n-      N_Slice,\n-      N_Selected_Component,\n-      N_Attribute_Reference,\n-      N_Aggregate,\n-      N_Component_Association,\n-      N_Extension_Aggregate,\n-      N_Iterated_Component_Association,\n-      N_Delta_Aggregate,\n-      N_Iterated_Element_Association,\n-      N_Null,\n-      N_And_Then,\n-      N_Or_Else,\n-      N_In,\n-      N_Not_In,\n-      N_Op_And,\n-      N_Op_Or,\n-      N_Op_Xor,\n-      N_Op_Eq,\n-      N_Op_Ne,\n-      N_Op_Lt,\n-      N_Op_Le,\n-      N_Op_Gt,\n-      N_Op_Ge,\n-      N_Op_Add,\n-      N_Op_Subtract,\n-      N_Op_Concat,\n-      N_Op_Multiply,\n-      N_Op_Divide,\n-      N_Op_Mod,\n-      N_Op_Rem,\n-      N_Op_Expon,\n-      N_Op_Plus,\n-      N_Op_Minus,\n-      N_Op_Abs,\n-      N_Op_Not,\n-      N_If_Expression,\n-      N_Case_Expression,\n-      N_Case_Expression_Alternative,\n-      N_Quantified_Expression,\n-      N_Type_Conversion,\n-      N_Qualified_Expression,\n-      N_Allocator,\n-      N_Null_Statement,\n-      N_Label,\n-      N_Assignment_Statement,\n-      N_Target_Name,\n-      N_If_Statement,\n-      N_Elsif_Part,\n-      N_Case_Statement,\n-      N_Case_Statement_Alternative,\n-      N_Loop_Statement,\n-      N_Iteration_Scheme,\n-      N_Loop_Parameter_Specification,\n-      N_Iterator_Specification,\n-      N_Block_Statement,\n-      N_Exit_Statement,\n-      N_Goto_Statement,\n-      N_Subprogram_Declaration,\n-      N_Abstract_Subprogram_Declaration,\n-      N_Function_Specification,\n-      N_Procedure_Specification,\n-      N_Designator,\n-      N_Defining_Program_Unit_Name,\n-      N_Operator_Symbol,\n-      N_Defining_Operator_Symbol,\n-      N_Parameter_Specification,\n-      N_Subprogram_Body,\n-      N_Procedure_Call_Statement,\n-      N_Function_Call,\n-      N_Parameter_Association,\n-      N_Simple_Return_Statement,\n-      N_Extended_Return_Statement,\n-      N_Expression_Function,\n-      N_Package_Declaration,\n-      N_Package_Specification,\n-      N_Package_Body,\n-      N_Private_Type_Declaration,\n-      N_Private_Extension_Declaration,\n-      N_Use_Package_Clause,\n-      N_Use_Type_Clause,\n-      N_Object_Renaming_Declaration,\n-      N_Exception_Renaming_Declaration,\n-      N_Package_Renaming_Declaration,\n-      N_Subprogram_Renaming_Declaration,\n-      N_Generic_Package_Renaming_Declaration,\n-      N_Generic_Procedure_Renaming_Declaration,\n-      N_Generic_Function_Renaming_Declaration,\n-      N_Task_Type_Declaration,\n-      N_Single_Task_Declaration,\n-      N_Task_Definition,\n-      N_Task_Body,\n-      N_Protected_Type_Declaration,\n-      N_Single_Protected_Declaration,\n-      N_Protected_Definition,\n-      N_Protected_Body,\n-      N_Entry_Declaration,\n-      N_Accept_Statement,\n-      N_Entry_Body,\n-      N_Entry_Body_Formal_Part,\n-      N_Entry_Index_Specification,\n-      N_Entry_Call_Statement,\n-      N_Requeue_Statement,\n-      N_Delay_Until_Statement,\n-      N_Delay_Relative_Statement,\n-      N_Selective_Accept,\n-      N_Accept_Alternative,\n-      N_Delay_Alternative,\n-      N_Terminate_Alternative,\n-      N_Timed_Entry_Call,\n-      N_Entry_Call_Alternative,\n-      N_Conditional_Entry_Call,\n-      N_Asynchronous_Select,\n-      N_Triggering_Alternative,\n-      N_Abortable_Part,\n-      N_Abort_Statement,\n-      N_Compilation_Unit,\n-      N_Compilation_Unit_Aux,\n-      N_With_Clause,\n-      N_Subprogram_Body_Stub,\n-      N_Package_Body_Stub,\n-      N_Task_Body_Stub,\n-      N_Protected_Body_Stub,\n-      N_Subunit,\n-      N_Exception_Declaration,\n-      N_Handled_Sequence_Of_Statements,\n-      N_Exception_Handler,\n-      N_Raise_Statement,\n-      N_Raise_Expression,\n-      N_Generic_Subprogram_Declaration,\n-      N_Generic_Package_Declaration,\n-      N_Package_Instantiation,\n-      N_Procedure_Instantiation,\n-      N_Function_Instantiation,\n-      N_Generic_Association,\n-      N_Formal_Object_Declaration,\n-      N_Formal_Type_Declaration,\n-      N_Formal_Private_Type_Definition,\n-      N_Formal_Derived_Type_Definition,\n-      N_Formal_Incomplete_Type_Definition,\n-      N_Formal_Discrete_Type_Definition,\n-      N_Formal_Signed_Integer_Type_Definition,\n-      N_Formal_Modular_Type_Definition,\n-      N_Formal_Floating_Point_Definition,\n-      N_Formal_Ordinary_Fixed_Point_Definition,\n-      N_Formal_Decimal_Fixed_Point_Definition,\n-      N_Formal_Concrete_Subprogram_Declaration,\n-      N_Formal_Abstract_Subprogram_Declaration,\n-      N_Formal_Package_Declaration,\n-      N_Attribute_Definition_Clause,\n-      N_Aspect_Specification,\n-      N_Enumeration_Representation_Clause,\n-      N_Record_Representation_Clause,\n-      N_Component_Clause,\n-      N_Code_Statement,\n-      N_Op_Rotate_Left,\n-      N_Op_Rotate_Right,\n-      N_Op_Shift_Left,\n-      N_Op_Shift_Right_Arithmetic,\n-      N_Op_Shift_Right,\n-      N_Delta_Constraint,\n-      N_At_Clause,\n-      N_Mod_Clause,\n-      N_Call_Marker,\n-      N_Compound_Statement,\n-      N_Contract,\n-      N_Expanded_Name,\n-      N_Expression_With_Actions,\n-      N_Free_Statement,\n-      N_Freeze_Entity,\n-      N_Freeze_Generic_Entity,\n-      N_Implicit_Label_Declaration,\n-      N_Itype_Reference,\n-      N_Raise_Constraint_Error,\n-      N_Raise_Program_Error,\n-      N_Raise_Storage_Error,\n-      N_Push_Constraint_Error_Label,\n-      N_Push_Program_Error_Label,\n-      N_Push_Storage_Error_Label,\n-      N_Pop_Constraint_Error_Label,\n-      N_Pop_Program_Error_Label,\n-      N_Pop_Storage_Error_Label,\n-      N_Reference,\n-      N_SCIL_Dispatch_Table_Tag_Init,\n-      N_SCIL_Dispatching_Call,\n-      N_SCIL_Membership_Test,\n-      N_Unchecked_Expression,\n-      N_Unchecked_Type_Conversion,\n-      N_Validate_Unchecked_Conversion,\n-      N_Variable_Reference_Marker);\n-\n-end Gen_IL.Utils;"}, {"sha": "7114c7c6c2e68b0b53403be51ae5b1886eacbc91", "filename": "gcc/ada/gen_il.adb", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7cadd18606c9c3ce2776b6f876ca98849b24b84/gcc%2Fada%2Fgen_il.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7cadd18606c9c3ce2776b6f876ca98849b24b84/gcc%2Fada%2Fgen_il.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgen_il.adb?ref=a7cadd18606c9c3ce2776b6f876ca98849b24b84", "patch": "@@ -25,6 +25,10 @@\n \n package body Gen_IL is\n \n+   -----------\n+   -- Image --\n+   -----------\n+\n    function Image (X : Root_Int) return String is\n       Result : constant String := X'Img;\n    begin\n@@ -35,6 +39,10 @@ package body Gen_IL is\n       end if;\n    end Image;\n \n+   ----------------\n+   -- Capitalize --\n+   ----------------\n+\n    procedure Capitalize (S : in out String) is\n       Cap : Boolean := True;\n    begin\n@@ -53,6 +61,10 @@ package body Gen_IL is\n       end loop;\n    end Capitalize;\n \n+   ----------------\n+   -- Capitalize --\n+   ----------------\n+\n    function Capitalize (S : String) return String is\n    begin\n       return Result : String (S'Range) := S do"}, {"sha": "6a86ed6d610586299acab0dc4fcde2e323dd58d4", "filename": "gcc/ada/gen_il.ads", "status": "modified", "additions": 25, "deletions": 255, "changes": 280, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7cadd18606c9c3ce2776b6f876ca98849b24b84/gcc%2Fada%2Fgen_il.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7cadd18606c9c3ce2776b6f876ca98849b24b84/gcc%2Fada%2Fgen_il.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgen_il.ads?ref=a7cadd18606c9c3ce2776b6f876ca98849b24b84", "patch": "@@ -34,260 +34,32 @@ pragma Warnings (On);\n package Gen_IL is -- generate intermediate language\n \n    --  This package and children generates the main intermediate language used\n-   --  by the compiler, which is a decorated syntax tree.\n+   --  by the GNAT compiler, which is a decorated syntax tree.\n \n-   --  Here's what the hand-written and generated code looks like. The make\n-   --  files run the gen_il-main.adb program to generate the generated files\n-   --  listed below, before building the compiler proper.\n-   --\n-   --  atree.ads, atree.adb: Rewrite according to low-level\n-   --  design notes. Remove package Unchecked_Access.\n-   --  Low-level getters and setters go in Atree_Private_Part.\n-   --  These are called by the high-level automatically-generated\n-   --  getters and setters in Sinfo.Nodes and Einfo.Entities.\n-   --  Also used by Atree.Traverse_Func, and by Treepr.\n-   --\n-   --  sinfo.ads, einfo.ads: Remove getters and setters.\n-   --  Remove Write_... routines used by old Treepr.\n-   --  Keep commments describing the semantics of all the nodes,\n-   --  entities, and fields. These comments are wrong, but only\n-   --  a little, and I'm not going to try to fix them. At some\n-   --  point, we could remove the comments giving field offsets\n-   --  (e.g. \"(Flag5-Sem)\"), but for now, just note that that's\n-   --  obsolete info.\n-   --\n-   --  einfo.adb, sinfo.adb: Delete.\n-   --\n-   --  gen_il.ads, gen_il.adb: Mostly empty root package for the\n-   --  \"generate intermediate language\" program, which generates\n-   --  all the files mentioned here.\n-   --  The main program is gen_il-main.adb.\n-   --\n-   --  sinfo-utils.ads, sinfo-utils.adb, einfo-utils.ads, einfo-utils.adb:\n-   --  Move all handwritten code currently in sinfo&einfo to here,\n-   --  if it refers to stuff in sinfo-nodes.ads, einfo-entities.ads\n-   --  This includes the \"synthesized attributes\".\n-   --\n-   --  gen_il-types.ads: Enumeration type containing one literal for\n-   --  each type of interest. That includes all the Node_Kinds and\n-   --  Entity_Kinds, plus the subtypes that include multiple\n-   --  Node_Kinds and Entity_Kinds (all from the old sinfo/einfo),\n-   --  plus all field types (Uint, Ureal, Name_Id, etc).\n-   --\n-   --  gen_il-fields.ads: Enumeration of all the fields of all node\n-   --  and entity types.\n-   --\n-   --  gen_il-gen.ads, gen_il-gen.adb: Implementation of the \"compiler\"\n-   --  for the \"little language\".\n-   --\n-   --  gen_il-gen-gen_nodes.adb: Procedure to generate Sinfo.Nodes\n-   --  (by calling procedures in Gen_IL).\n-   --  This defines what abstract and concrete node types exist,\n-   --  and what fields they have. This and the next one are the\n-   --  hard part. I'm planning to generate this semi-automatically.\n-   --  But once it's working, we will maintain it by hand.\n-   --\n-   --  gen_il-gen-gen_entities.adb: Procedure to generate einfo-entities.*.\n-   --  This defines what abstract and concrete entity types exist,\n-   --  and what fields they have.\n-   --\n-   --  seinfo.ads: Generated by gen_il-main.adb. Contains declarations shared\n-   --  by Sinfo.Nodes and Einfo.Entities.\n-   --\n-   --  sinfo-nodes.ads, sinfo-nodes.adb: Generated by gen_il-main.adb\n-   --  (really by Gen_Nodes). Contains:\n-   --\n-   --      - Information in comments, such as what fields exist in what\n-   --        node kinds, which might be hard to compute by hand for\n-   --        inherited fields.\n-   --\n-   --      - Type Node_Kind. Same as the old Sinfo, but now generated.\n-   --        One enumeral for each concrete node type in Gen_Nodes.\n-   --\n-   --      - One subtype of Node_Kind for each abstract type in Gen_Nodes.\n-   --        Same as the old Sinfo, but now generated. E.g.:\n-   --\n-   --        subtype N_Representation_Clause is Node_Kind range\n-   --          N_At_Clause .. N_Attribute_Definition_Clause;\n-   --\n-   --      - One subtype of Node_Id for each abstract and concrete type,\n-   --        with a predicate requiring the right Nkind. E.g.:\n-   --\n-   --        subtype N_Representation_Clause_Id is\n-   --          Node_Id with Predicate =>\n-   --            Nkind (N_Representation_Clause_Id) in N_Representation_Clause;\n-   --\n-   --      - Getters and setters for every node field. If the field is defined\n-   --        for all node kinds in one of the above Node_Id subtypes and no\n-   --        others, then we use that as the parameter subtype:\n-   --\n-   --        function Abortable_Part\n-   --          (N : N_Asynchronous_Select_Id) return Node_Id with Inline;\n-   --\n-   --        Otherwise, we use a precondition:\n-   --\n-   --        function Abstract_Present\n-   --          (N : Node_Id) return Flag with Inline, Pre =>\n-   --          N in N_Private_Extension_Declaration_Id\n-   --             | N_Private_Type_Declaration_Id\n-   --             | N_Derived_Type_Definition_Id\n-   --             ...\n-   --\n-   --      - Type Node_Field: Enumeration of all node fields. Used by Treepr,\n-   --        and in tables below.\n-   --\n-   --      - Table of syntactic fields. For each node kind, we have a sequence\n-   --        of fields. A field is included if it exists in that node kind,\n-   --        and it is syntactic, and it is of type Node_Id or List_Id.\n-   --        Used by Traverse_Func.\n-   --\n-   --      - Table of node sizes, indexed by Node_Kind. Used by Atree when\n-   --        allocating and copying nodes.\n-   --\n-   --      - Table mapping Node_Kinds to the sequence of fields that exist in\n-   --        that Node_Kind. Used by Treepr.\n-   --\n-   --      - Node_Field_Descriptors: Table mapping fields to type and offset.\n-   --        Used by Treepr to know where to find each field, and what its\n-   --        type is, for printing.\n-   --\n-   --      - The body contains instantiations of the low-level getters and\n-   --        setters declared in Atree, e.g.:\n-   --\n-   --        function Get_List_Id is new Get_32_Bit_Field (List_Id)\n-   --           with Inline;\n-   --        procedure Set_List_Id is new Set_32_Bit_Field (List_Id)\n-   --           with Inline;\n-   --\n-   --        and bodies of the high-level getters and setters, e.g.:\n-   --\n-   --        function Actions\n-   --          (N : Node_Id) return List_Id is\n-   --        begin\n-   --           return Get_List_Id (N, 4);\n-   --        end Actions;\n-   --\n-   --  einfo-entities.ads, einfo-entities.adb: Generated by gen_il-main.adb\n-   --  (really by Gen_Entities). Contains the same sort of stuff as\n-   --  Sinfo.Nodes, except no table of syntactic fields.\n-   --\n-   --  nmake.ads, nmake.adb: Same contents as the old version, but generated by\n-   --  Gen_IL instead of xnmake.\n-   --\n-   --  treepr.adb: Rewrite to use the tables in Nodes and Entities.\n-   --\n-   --  treeprs.ads: Delete. (Was automatically generated.)\n-   --  Treepr no longer needs this; it can use 'Image on the\n-   --  enumeration types in Nodes and Entities.\n-   --\n-   --  csinfo.adb, ceinfo.adb, xsinfo.adb, xeinfo.adb, xnmake.adb,\n-   --  xtreeprs.adb, nmake.adt, treeprs.adt: Delete.\n-\n-   --  C++ code:\n-   --\n-   --  atree.h (hand-written code):\n-   --\n-   --  This code should be entirely deleted, and replaced with low-level\n-   --  getters analogous to the generic getters in Atree.  One getter for each\n-   --  field size (currently 1, 2, 4, 8, and 32 bits. No need for setters.\n-   --\n-   --  ----------------\n-   --\n-   --  fe.h (hand-written code):\n-   --\n-   --  There are comments in various places that say that gigi\n-   --  does not modify the tree. However, I discovered some stuff\n-   --  in fe.h that modifies the tree:\n-   --\n-   --  #define End_Location                     sinfo__end_location\n-   --  #define Set_Has_No_Elaboration_Code sinfo__set_has_no_elaboration_code\n-   --  #define Set_Present_Expr         sinfo__set_present_expr\n-   --\n-   --  #define Set_Alignment                    einfo__set_alignment\n-   --  #define Set_Component_Bit_Offset einfo__set_component_bit_offset\n-   --  #define Set_Component_Size               einfo__set_component_size\n-   --  #define Set_Esize                        einfo__set_esize\n-   --  #define Set_Mechanism                    einfo__set_mechanism\n-   --  #define Set_Normalized_First_Bit einfo__set_normalized_first_bit\n-   --  #define Set_Normalized_Position          einfo__set_normalized_position\n-   --  #define Set_RM_Size                      einfo__set_rm_size\n-   --\n-   --  #define Is_Entity_Name           einfo__utils__is_entity_name\n-   --  #define Get_Attribute_Definition_Clause  \\\n-   --    einfo__utils__get_attribute_definition_clause\n-   --\n-   --  These setters and some getters need to be changed because the\n-   --  setters and getters are moving from Sinfo to Sinfo.Nodes,\n-   --  and from Einfo to Einfo.Entities. The last two will be in Einfo.Utils.\n-   --\n-   --  ----------------\n-   --\n-   --  sinfo.h (tool-generated code):\n-   --\n-   --  A bunch of #defines for the node kinds. These can remain the same.\n-   --\n-   --  A bunch of calls to SUBTYPE (macro defined in gcc-interface/ada.h).\n-   --  These can remain the same.\n-   --\n-   --  A bunch of getters (no setters), like:\n-   --\n-   --     INLINE Boolean   Abort_Present                  (Node_Id N)\n-   --        { return Flag15 (N); }\n-   --\n-   --  Change this to call the new low-level getters.\n-   --  Something like:\n-   --\n-   --     INLINE Boolean   Abort_Present                  (Node_Id N)\n-   --        { return Get_Flag (N, 15); }\n-   --\n-   --  Generate the low-level getters in the same file, before the above\n-   --  high-level getters, one for each field type:\n-   --\n-   --        Flag\n-   --        Node_Id\n-   --        List_Id\n-   --        Elist_Id\n-   --        Name_Id\n-   --        String_Id\n-   --        Uint\n-   --        Ureal\n-   --        Node_Kind\n-   --        Entity_Kind\n-   --        Source_Ptr\n-   --        Small_Paren_Count_Type\n-   --        Union_Id\n-   --        Convention_Id\n-   --        Component_Alignment_Kind\n-   --        Float_Rep_Kind\n-   --        Mechanism_Type\n-   --\n-   --  These are in types.h.\n-   --\n-   --  ----------------\n-   --\n-   --  einfo.h (tool-generated code):\n-   --\n-   --  Can mostly remain the same, except:\n-   --\n-   --      Call low-level getters, as for sinfo.h.\n-   --\n-   --      The getters that are NOT inlined will be moved from\n-   --      Einfo to Einfo.Entities.\n-   --      I don't understand why some are not inlined (e.g Float_Rep?).\n-   --      Most are not inlined because they are synthesized.\n-   --      Maybe that should be hand written, and moved to a different file.\n-   --      Or maybe Gen_IL should know about these fields.\n-   --\n-   --      We have code like:\n-   --         INLINE B Is_Subprogram_Or_Generic_Subprogram (E Id)\n-   --            { return IN (Ekind (Id), Subprogram_Kind) || IN (Ekind (Id),\n-   --              Generic_Subprogram_Kind); }\n-   --      That should be hand written, and moved to atree.h or fe.h.\n-   --      Is_Record_Type requires special treatment, because Record_Kind is\n-   --      a nonhierarchical type.\n-   --\n-   --  Looks like the getters are in alphabetical order.\n-   --  Except for the Is_..._Type ones.\n+   --  The generated Ada packages are:\n+   --\n+   --    Seinfo\n+   --    Sinfo.Nodes\n+   --    Einfo.Entities\n+   --    Nmake\n+   --    Seinfo_Tables\n+   --\n+   --  We also generate C code:\n+   --\n+   --    einfo.h\n+   --    sinfo.h\n+   --    snames.h\n+   --\n+   --  It is necessary to look at this generated code in order to understand\n+   --  the compiler. In addition, it is necessary to look at comments in the\n+   --  spec and body of Gen_IL.\n+   --\n+   --  Note that the Gen_IL \"compiler\" and the GNAT Ada compiler are separate\n+   --  programs, with no dependencies between them in either direction. That\n+   --  is, Gen_IL does not say \"with\" of GNAT units, and GNAT does not say\n+   --  \"with Gen_IL\". There are many things declared in Gen_IL and GNAT with\n+   --  the same name; these are typically related, but they are not the same\n+   --  thing.\n \n    --  Misc declarations used throughout:\n \n@@ -304,6 +76,4 @@ package Gen_IL is -- generate intermediate language\n    procedure Capitalize (S : in out String);\n    --  Turns an identifier into Mixed_Case\n \n-   type String_Ptr is access all String;\n-\n end Gen_IL;"}, {"sha": "f76d3702ffe163040fb3071c91e0f9bb3b6b86cc", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7cadd18606c9c3ce2776b6f876ca98849b24b84/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7cadd18606c9c3ce2776b6f876ca98849b24b84/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=a7cadd18606c9c3ce2776b6f876ca98849b24b84", "patch": "@@ -8479,7 +8479,6 @@ package body Sem_Ch12 is\n \n          --  Do not copy the associated node, which points to the generic copy\n          --  of the aggregate.\n-         --  ????We ought to be able to get rid of all the Union_Id conversions\n \n          if Nkind (N) = N_Aggregate then\n             Set_Aggregate_Bounds\n@@ -15624,7 +15623,7 @@ package body Sem_Ch12 is\n \n          --  E should be an entity, but it is not always\n \n-         elsif Nkind (E) not in N_Entity then -- ????\n+         elsif Nkind (E) not in N_Entity then\n             return False;\n \n          elsif Is_Child_Unit (E)"}, {"sha": "11c6fdbed6b8c81c5caa8d8b1ae5901e71efea3b", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7cadd18606c9c3ce2776b6f876ca98849b24b84/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7cadd18606c9c3ce2776b6f876ca98849b24b84/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=a7cadd18606c9c3ce2776b6f876ca98849b24b84", "patch": "@@ -20435,7 +20435,7 @@ package body Sem_Ch3 is\n       while Present (Discr) loop\n          Id := Defining_Identifier (Discr);\n \n-         if Ekind (Id) = E_In_Parameter then -- ????Above says E_Void\n+         if Ekind (Id) = E_In_Parameter then\n             Reinit_Field_To_Zero (Id, Discriminal_Link);\n          end if;\n "}, {"sha": "12b54293dbb893d3413080ad0b27a630dbae30f7", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7cadd18606c9c3ce2776b6f876ca98849b24b84/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7cadd18606c9c3ce2776b6f876ca98849b24b84/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=a7cadd18606c9c3ce2776b6f876ca98849b24b84", "patch": "@@ -23066,7 +23066,6 @@ package body Sem_Util is\n       --  valid syntactic fields. Par_Nod is the expected parent of the\n       --  syntactic field. Flag Semantic should be set when the input is a\n       --  semantic field.\n-      --  ????So it's visiting sem fields twice?\n \n       procedure Visit_Itype (Itype : Entity_Id);\n       --  Visit itype Itype. This action may create a new entity for Itype and"}, {"sha": "b4473c157e232d92b863d858ad28e7bd1e7d36fd", "filename": "gcc/ada/sinfo-cn.adb", "status": "modified", "additions": 0, "deletions": 55, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7cadd18606c9c3ce2776b6f876ca98849b24b84/gcc%2Fada%2Fsinfo-cn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7cadd18606c9c3ce2776b6f876ca98849b24b84/gcc%2Fada%2Fsinfo-cn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo-cn.adb?ref=a7cadd18606c9c3ce2776b6f876ca98849b24b84", "patch": "@@ -37,31 +37,6 @@ with Sinfo.Utils;    use Sinfo.Utils;\n \n package body Sinfo.CN is\n \n-   procedure Assert_Expression_Fields_Zero (N : Node_Id);\n-   --  Asserts that all fields documented in Sinfo as \"plus fields for\n-   --  expression\" have their initial zero value. Note that N_Operator_Symbol\n-   --  is not documented as having \"plus fields for expression\", but it is in\n-   --  N_Subexpr, so it does.\n-   --  ????This is redundant with Check_Vanishing_Fields in Atree.\n-\n-   -----------------------------------\n-   -- Assert_Expression_Fields_Zero --\n-   -----------------------------------\n-\n-   procedure Assert_Expression_Fields_Zero (N : Node_Id) is\n-   begin\n-      pragma Assert (Paren_Count (N) = 0);\n-      pragma Assert (No (Etype (N)));\n-      pragma Assert (not Is_Overloaded (N));\n-      pragma Assert (not Is_Static_Expression (N));\n-      pragma Assert (not Raises_Constraint_Error (N));\n-      pragma Assert (not Must_Not_Freeze (N));\n-      pragma Assert (not Do_Range_Check (N));\n-      pragma Assert (not Has_Dynamic_Length_Check (N));\n-      pragma Assert (not Assignment_OK (N));\n-      pragma Assert (not Is_Controlling_Actual (N));\n-   end Assert_Expression_Fields_Zero;\n-\n    ------------------------------------------------------------\n    -- Change_Character_Literal_To_Defining_Character_Literal --\n    ------------------------------------------------------------\n@@ -71,12 +46,6 @@ package body Sinfo.CN is\n    is\n    begin\n       Reinit_Field_To_Zero (N, Char_Literal_Value);\n---  ????pragma Assert (No (Node2 (N))); -- Char_Literal_Value is Uint2 out of r\n-      pragma Assert (No (Entity (N)));\n-      pragma Assert (No (Associated_Node (N)));\n-      pragma Assert (not Has_Private_View (N));\n-      Assert_Expression_Fields_Zero (N);\n-\n       Extend_Node (N);\n    end Change_Character_Literal_To_Defining_Character_Literal;\n \n@@ -98,17 +67,6 @@ package body Sinfo.CN is\n \n    procedure Change_Identifier_To_Defining_Identifier (N : Node_Id) is\n    begin\n-      pragma Assert (No (Entity (N)));\n-      pragma Assert (No (Associated_Node (N)));\n-      pragma Assert (No (Original_Discriminant (N)));\n-      pragma Assert (not Is_Elaboration_Checks_OK_Node (N));\n-      pragma Assert (not Is_SPARK_Mode_On_Node (N));\n-      pragma Assert (not Is_Elaboration_Warnings_OK_Node (N));\n-      pragma Assert (not Has_Private_View (N));\n-      pragma Assert (not Redundant_Use (N));\n-      pragma Assert (not Atomic_Sync_Required (N));\n-      Assert_Expression_Fields_Zero (N);\n-\n       Extend_Node (N);\n    end Change_Identifier_To_Defining_Identifier;\n \n@@ -173,13 +131,6 @@ package body Sinfo.CN is\n    is\n    begin\n       Reinit_Field_To_Zero (N, Strval);\n---  ????pragma Assert (No (Node3 (N))); -- Strval is Str3, 0 is out of range\n-      pragma Assert (No (Entity (N)));\n-      pragma Assert (No (Associated_Node (N)));\n-      pragma Assert (No (Etype (N)));\n-      pragma Assert (not Has_Private_View (N));\n-      Assert_Expression_Fields_Zero (N);\n-\n       Extend_Node (N);\n    end Change_Operator_Symbol_To_Defining_Operator_Symbol;\n \n@@ -191,12 +142,6 @@ package body Sinfo.CN is\n    begin\n       Reinit_Field_To_Zero (N, Chars);\n       Set_Entity (N, Empty);\n---  ????pragma Assert (No (Node1 (N))); -- Chars is Name1 out of range\n-      pragma Assert (No (Entity (N)));\n-      pragma Assert (No (Associated_Node (N)));\n-      pragma Assert (No (Etype (N)));\n-      pragma Assert (not Has_Private_View (N));\n-\n       Mutate_Nkind (N, N_String_Literal);\n    end Change_Operator_Symbol_To_String_Literal;\n "}, {"sha": "27b19a6aea0e89a67025b8ec5acc7584b8b4d0a9", "filename": "gcc/ada/sinfo-utils.ads", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7cadd18606c9c3ce2776b6f876ca98849b24b84/gcc%2Fada%2Fsinfo-utils.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7cadd18606c9c3ce2776b6f876ca98849b24b84/gcc%2Fada%2Fsinfo-utils.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo-utils.ads?ref=a7cadd18606c9c3ce2776b6f876ca98849b24b84", "patch": "@@ -88,8 +88,7 @@ package Sinfo.Utils is\n    procedure Walk_Sinfo_Fields (N : Node_Id);\n    --  Walk the Sinfo fields of N, for all field types that Union_Id includes,\n    --  and call Action on each one. However, skip the Link field, which is the\n-   --  Parent, and would cause us to wander off into the weeds. ????It's not\n-   --  clear why this should walk semantic fields.\n+   --  Parent, and would cause us to wander off into the weeds.\n \n    generic\n       with function Transform (U : Union_Id) return Union_Id;\n@@ -105,10 +104,11 @@ package Sinfo.Utils is\n    --  Historically, the Entity, Associated_Node, and Entity_Or_Associated_Node\n    --  fields shared the same slot. A further complication is that there is an\n    --  N_Has_Entity that does not include all node types that have the Entity\n+   --  field. N_Inclusive_Has_Entity are the node types that have the Entity\n    --  field.\n \n-   subtype N_Really_Has_Entity is Node_Id with Predicate =>\n-     N_Really_Has_Entity in\n+   subtype N_Inclusive_Has_Entity is Node_Id with Predicate =>\n+     N_Inclusive_Has_Entity in\n        N_Has_Entity_Id\n        | N_Attribute_Definition_Clause_Id\n        | N_Aspect_Specification_Id\n@@ -128,15 +128,15 @@ package Sinfo.Utils is\n       renames Entity_Or_Associated_Node;\n \n    function Entity\n-     (N : N_Really_Has_Entity) return Node_Id\n+     (N : N_Inclusive_Has_Entity) return Node_Id\n       renames Entity_Or_Associated_Node;\n \n    procedure Set_Associated_Node\n      (N : N_Has_Associated_Node; Val : Node_Id)\n       renames Set_Entity_Or_Associated_Node;\n \n    procedure Set_Entity\n-     (N : N_Really_Has_Entity; Val : Node_Id)\n+     (N : N_Inclusive_Has_Entity; Val : Node_Id)\n       renames Set_Entity_Or_Associated_Node;\n \n    function Associated_Node return Node_Field renames"}, {"sha": "f62d2d141e8d308aa25bc2dd2596acbb3c35d560", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 1184, "deletions": 1197, "changes": 2381, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7cadd18606c9c3ce2776b6f876ca98849b24b84/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7cadd18606c9c3ce2776b6f876ca98849b24b84/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=a7cadd18606c9c3ce2776b6f876ca98849b24b84"}, {"sha": "98ccd9a2b1d96bbed773bf04f4f2abe75ddbda0a", "filename": "gcc/ada/treepr.adb", "status": "modified", "additions": 110, "deletions": 86, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7cadd18606c9c3ce2776b6f876ca98849b24b84/gcc%2Fada%2Ftreepr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7cadd18606c9c3ce2776b6f876ca98849b24b84/gcc%2Fada%2Ftreepr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftreepr.adb?ref=a7cadd18606c9c3ce2776b6f876ca98849b24b84", "patch": "@@ -76,7 +76,7 @@ package body Treepr is\n    -- Global Variables --\n    ----------------------\n \n-   Include_Low_Level : Boolean := False with Warnings => Off;\n+   Print_Low_Level_Info : Boolean := False with Warnings => Off;\n    --  Set True to print low-level information useful for debugging Atree and\n    --  the like.\n \n@@ -126,8 +126,6 @@ package body Treepr is\n    function From_Union is new Unchecked_Conversion (Union_Id, Uint);\n    function From_Union is new Unchecked_Conversion (Union_Id, Ureal);\n \n-   --  Print_End_Span is gone. Should be restored????\n-\n    function Capitalize (S : String) return String;\n    procedure Capitalize (S : in out String);\n    --  Turns an identifier into Mixed_Case\n@@ -139,6 +137,10 @@ package body Treepr is\n    procedure Print_Init;\n    --  Initialize for printing of tree with descendants\n \n+   procedure Print_End_Span (N : Node_Id);\n+   --  Print contents of End_Span field of node N. The format includes the\n+   --  implicit source location as well as the value of the field.\n+\n    procedure Print_Term;\n    --  Clean up after printing of tree with descendants\n \n@@ -185,27 +187,26 @@ package body Treepr is\n    procedure Print_Field (Val : Union_Id; Format : UI_Format := Auto);\n    procedure Print_Field\n      (Prefix : String;\n-      Field : String;\n-      N : Node_Or_Entity_Id;\n-      FD : Field_Descriptor;\n+      Field  : String;\n+      N      : Node_Or_Entity_Id;\n+      FD     : Field_Descriptor;\n       Format : UI_Format);\n    --  Print representation of Field value (name, tree, string, uint, charcode)\n    --  The format parameter controls the format of printing in the case of an\n-   --  integer value (see UI_Write for details).????\n-   --  Do we really need two of these???\n+   --  integer value (see UI_Write for details).\n \n    procedure Print_Node_Field\n      (Prefix : String;\n-      Field : Node_Field;\n-      N : Node_Id;\n-      FD : Field_Descriptor;\n+      Field  : Node_Field;\n+      N      : Node_Id;\n+      FD     : Field_Descriptor;\n       Format : UI_Format := Auto);\n \n    procedure Print_Entity_Field\n      (Prefix : String;\n-      Field : Entity_Field;\n-      N : Entity_Id;\n-      FD : Field_Descriptor;\n+      Field  : Entity_Field;\n+      N      : Entity_Id;\n+      FD     : Field_Descriptor;\n       Format : UI_Format := Auto);\n \n    procedure Print_Flag (F : Boolean);\n@@ -590,6 +591,24 @@ package body Treepr is\n       Print_Term;\n    end Print_Elist_Subtree;\n \n+   --------------------\n+   -- Print_End_Span --\n+   --------------------\n+\n+   procedure Print_End_Span (N : Node_Id) is\n+      Val : constant Uint := End_Span (N);\n+\n+   begin\n+      UI_Write (Val);\n+      Write_Str (\" (Uint = \");\n+      Write_Str (UI_Image (Val));\n+      Write_Str (\")  \");\n+\n+      if Val /= No_Uint then\n+         Write_Location (End_Location (N));\n+      end if;\n+   end Print_End_Span;\n+\n    -----------------------\n    -- Print_Entity_Info --\n    -----------------------\n@@ -622,26 +641,28 @@ package body Treepr is\n       end if;\n \n       declare\n-         A : Entity_Field_Array renames Entity_Field_Table (Ekind (Ent)).all;\n-         Already_Printed_Above : constant Entity_Field_Set :=\n+         Fields : Entity_Field_Array renames\n+           Entity_Field_Table (Ekind (Ent)).all;\n+         Should_Print : constant Entity_Field_Set :=\n+           --  Set of fields that should be printed. False for fields that were\n+           --  already printed above.\n            (Ekind\n-              | Basic_Convention => True, -- Convention was printed\n-            others => False);\n+            | Basic_Convention => False, -- Convention was printed\n+            others => True);\n       begin\n          --  Outer loop makes flags come out last\n \n          for Print_Flags in Boolean loop\n-            for Field_Index in A'Range loop\n+            for Field_Index in Fields'Range loop\n                declare\n                   FD : Field_Descriptor renames\n-                    Entity_Field_Descriptors (A (Field_Index));\n+                    Entity_Field_Descriptors (Fields (Field_Index));\n                begin\n-                  if Already_Printed_Above (A (Field_Index))  then\n-                     null; -- Skip the ones already printed\n-\n-                  elsif (FD.Kind = Flag_Field) = Print_Flags then\n+                  if Should_Print (Fields (Field_Index))\n+                    and then (FD.Kind = Flag_Field) = Print_Flags\n+                  then\n                      Print_Entity_Field\n-                       (Prefix, A (Field_Index), Ent, FD);\n+                       (Prefix, Fields (Field_Index), Ent, FD);\n                   end if;\n                end;\n             end loop;\n@@ -693,10 +714,10 @@ package body Treepr is\n    function Get_Ureal is new Get_32_Bit_Field\n      (Ureal) with Inline;\n \n-   function Get_Nkind_Type is new Get_8_Bit_Field\n+   function Get_Node_Kind_Type is new Get_8_Bit_Field\n      (Node_Kind) with Inline;\n \n-   function Get_Ekind_Type is new Get_8_Bit_Field\n+   function Get_Entity_Kind_Type is new Get_8_Bit_Field\n      (Entity_Kind) with Inline;\n \n    function Get_Source_Ptr is new Get_32_Bit_Field\n@@ -761,11 +782,11 @@ package body Treepr is\n \n    procedure Print_Field\n      (Prefix : String;\n-      Field : String;\n-      N : Node_Or_Entity_Id;\n-      FD : Field_Descriptor;\n-      Format : UI_Format) is\n-\n+      Field  : String;\n+      N      : Node_Or_Entity_Id;\n+      FD     : Field_Descriptor;\n+      Format : UI_Format)\n+   is\n       Printed : Boolean := False;\n \n       procedure Print_Initial;\n@@ -777,7 +798,7 @@ package body Treepr is\n          Print_Str (Prefix);\n          Print_Str (Field);\n \n-         if Include_Low_Level then\n+         if Print_Low_Level_Info then\n             Write_Str (\" at \");\n             Write_Int (Int (FD.Offset));\n          end if;\n@@ -885,24 +906,23 @@ package body Treepr is\n                end if;\n             end;\n \n-         when Nkind_Type_Field =>\n+         when Node_Kind_Type_Field =>\n             declare\n-               Val : constant Node_Kind := Get_Nkind_Type (N, FD.Offset);\n+               Val : constant Node_Kind := Get_Node_Kind_Type (N, FD.Offset);\n             begin\n                Print_Initial;\n                Print_Str_Mixed_Case (Node_Kind'Image (Val));\n             end;\n \n-         when Ekind_Type_Field =>\n+         when Entity_Kind_Type_Field =>\n             declare\n-               Val : constant Entity_Kind := Get_Ekind_Type (N, FD.Offset);\n+               Val : constant Entity_Kind :=\n+                 Get_Entity_Kind_Type (N, FD.Offset);\n             begin\n                Print_Initial;\n                Print_Str_Mixed_Case (Entity_Kind'Image (Val));\n             end;\n \n-            pragma Style_Checks (\"M200\");\n-\n          when Union_Id_Field =>\n             declare\n                Val : constant Union_Id := Get_Union_Id (N, FD.Offset);\n@@ -917,25 +937,29 @@ package body Treepr is\n                      Print_List_Ref (List_Id (Val));\n \n                   else\n-                     Print_Str (\"????union id out of range\");\n+                     Print_Str (\"<invalid union id>\");\n                   end if;\n                end if;\n             end;\n-            pragma Style_Checks (\"M79\");\n \n          when others =>\n             Print_Initial;\n-            Print_Str (\"????\");\n+            Print_Str (\"<unknown \");\n+            Print_Str (Field_Kind'Image (FD.Kind));\n+            Print_Str (\">\");\n       end case;\n \n       if Printed then\n          Print_Eol;\n       end if;\n \n+   --  If an exception is raised while printing, we try to print some low-level\n+   --  information that is useful for debugging.\n+\n    exception\n       when others =>\n          declare\n-            function Cast is new Unchecked_Conversion (Field_32_Bit, Int);\n+            function Cast is new Unchecked_Conversion (Field_Size_32_Bit, Int);\n          begin\n             Write_Eol;\n             Print_Initial;\n@@ -965,24 +989,34 @@ package body Treepr is\n          end;\n    end Print_Field;\n \n+   ----------------------\n+   -- Print_Node_Field --\n+   ----------------------\n+\n    procedure Print_Node_Field\n      (Prefix : String;\n-      Field : Node_Field;\n-      N : Node_Id;\n-      FD : Field_Descriptor;\n-      Format : UI_Format := Auto) is\n+      Field  : Node_Field;\n+      N      : Node_Id;\n+      FD     : Field_Descriptor;\n+      Format : UI_Format := Auto)\n+   is\n    begin\n       if not Field_Is_Initial_Zero (N, Field) then\n          Print_Field (Prefix, Image (Field), N, FD, Format);\n       end if;\n    end Print_Node_Field;\n \n+   ------------------------\n+   -- Print_Entity_Field --\n+   ------------------------\n+\n    procedure Print_Entity_Field\n      (Prefix : String;\n-      Field : Entity_Field;\n-      N : Entity_Id;\n-      FD : Field_Descriptor;\n-      Format : UI_Format := Auto) is\n+      Field  : Entity_Field;\n+      N      : Entity_Id;\n+      FD     : Field_Descriptor;\n+      Format : UI_Format := Auto)\n+   is\n    begin\n       if not Field_Is_Initial_Zero (N, Field) then\n          Print_Field (Prefix, Image (Field), N, FD, Format);\n@@ -1108,7 +1142,7 @@ package body Treepr is\n             Print_Char ('\"');\n \n          else\n-            Print_Str (\"<invalid name ???>\");\n+            Print_Str (\"<invalid name>\");\n          end if;\n       end if;\n    end Print_Name;\n@@ -1154,7 +1188,7 @@ package body Treepr is\n          Print_Eol;\n       end if;\n \n-      if Include_Low_Level then\n+      if Print_Low_Level_Info then\n          Print_Atree_Info (N);\n       end if;\n \n@@ -1325,8 +1359,6 @@ package body Treepr is\n             Print_Eol;\n          end if;\n       end if;\n-      --  ????Can some of the above be handled by the\n-      --  loop below, or by calling Print_Field directly?\n \n       if Nkind (N) = N_Integer_Literal and then Print_In_Hex (N) then\n          Fmt := Hex;\n@@ -1335,8 +1367,11 @@ package body Treepr is\n       end if;\n \n       declare\n-         A : Node_Field_Array renames Node_Field_Table (Nkind (N)).all;\n-         Already_Printed_Above : constant Node_Field_Set :=\n+         Fields : Node_Field_Array renames Node_Field_Table (Nkind (N)).all;\n+         Should_Print : constant Node_Field_Set :=\n+           --  Set of fields that should be printed. False for fields that were\n+           --  already printed above, and for In_List, which we don't bother\n+           --  printing.\n            (Nkind\n             | Chars\n             | Comes_From_Source\n@@ -1361,25 +1396,32 @@ package body Treepr is\n             | Raises_Constraint_Error\n             | Do_Overflow_Check\n             | Etype\n-            | In_List -- ????wasn't printed by old version\n-              => True,\n+            | In_List\n+              => False,\n \n-            others => False);\n+            others => True);\n       begin\n          --  Outer loop makes flags come out last\n \n          for Print_Flags in Boolean loop\n-            for Field_Index in A'Range loop --  Use Walk_Sinfo_Fields????\n+            for Field_Index in Fields'Range loop\n                declare\n                   FD : Field_Descriptor renames\n-                    Node_Field_Descriptors (A (Field_Index));\n+                    Node_Field_Descriptors (Fields (Field_Index));\n                begin\n-                  if Already_Printed_Above (A (Field_Index))  then\n-                     null; -- Skip the ones already printed\n+                  if Should_Print (Fields (Field_Index))\n+                    and then (FD.Kind = Flag_Field) = Print_Flags\n+                  then\n+                     --  Special case for End_Span, which also prints the\n+                     --  End_Location.\n+\n+                     if Fields (Field_Index) = End_Span then\n+                        Print_End_Span (N);\n \n-                  elsif (FD.Kind = Flag_Field) = Print_Flags then\n-                     Print_Node_Field\n-                       (Prefix, A (Field_Index), N, FD, Fmt);\n+                     else\n+                        Print_Node_Field\n+                          (Prefix, Fields (Field_Index), N, FD, Fmt);\n+                     end if;\n                   end if;\n                end;\n             end loop;\n@@ -1495,27 +1537,9 @@ package body Treepr is\n    ---------------------\n \n    procedure Print_Node_Kind (N : Node_Id) is\n-      Ucase : Boolean;\n-      S     : constant String := Node_Kind'Image (Nkind (N));\n-\n    begin\n       if Phase = Printing then\n-         Ucase := True;\n-\n-         --  Note: the call to Fold_Upper in this loop is to get past the GNAT\n-         --  bug of 'Image returning lower case instead of upper case.\n-         --  ????I'm sure that bug has long been fixed. This code was written\n-         --  in 2001. It should call Print_Str_Mixed_Case?\n-\n-         for J in S'Range loop\n-            if Ucase then\n-               Write_Char (Fold_Upper (S (J)));\n-            else\n-               Write_Char (Fold_Lower (S (J)));\n-            end if;\n-\n-            Ucase := (S (J) = '_');\n-         end loop;\n+         Print_Str_Mixed_Case (Node_Kind'Image (Nkind (N)));\n       end if;\n    end Print_Node_Kind;\n "}, {"sha": "27c50efed1c6e0c509b4699b9b72ebeb902e1ee2", "filename": "gcc/ada/types.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7cadd18606c9c3ce2776b6f876ca98849b24b84/gcc%2Fada%2Ftypes.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7cadd18606c9c3ce2776b6f876ca98849b24b84/gcc%2Fada%2Ftypes.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftypes.ads?ref=a7cadd18606c9c3ce2776b6f876ca98849b24b84", "patch": "@@ -988,6 +988,10 @@ package Types is\n    --  Offset of a node field, in units of the size of the field, which is\n    --  always a power of 2.\n \n+   subtype Slot_Count is Field_Offset;\n+   --  Count of number of slots. Same type as Field_Offset to avoid\n+   --  proliferation of type conversions.\n+\n    subtype Field_Size_In_Bits is Field_Offset with Predicate =>\n      Field_Size_In_Bits in 1 | 2 | 4 | 8 | 32;\n "}]}