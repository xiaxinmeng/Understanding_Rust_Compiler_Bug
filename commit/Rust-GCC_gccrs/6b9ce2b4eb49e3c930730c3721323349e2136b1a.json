{"sha": "6b9ce2b4eb49e3c930730c3721323349e2136b1a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmI5Y2UyYjRlYjQ5ZTNjOTMwNzMwYzM3MjEzMjMzNDllMjEzNmIxYQ==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2020-03-03T16:02:24Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2020-03-03T16:02:24Z"}, "message": "libgcc: arm: convert thumb1 code to unified syntax\n\nUnified syntax has been the official syntax for thumb1 assembly for\nover 10 years now.  It's time we made preparations for that becoming\nthe default in the assembler.  But before we can start doing that we\nreally need to clean up some laggards from the olden days.  Libgcc\nsupport for thumb1 is one such example.\n\nThis patch converts all of the legacy (disjoint) syntax that I could\nfind over to unified code.  The identification was done by using a\ntrick version of gas that defaulted to unified mode which then faults\nif legacy syntax is encountered.  The code produced was then compared\nagainst the old code to check for differences.  One such difference\ndoes exist, but that is because in unified syntax 'movs rd, rn' is\nencoded as 'lsls rd, rn, #0', rather than 'adds rd, rn, #0'; but that\nis a deliberate change that was introduced because the lsls encoding\nmore closely reflects the behaviour of 'movs' in arm state (where only\nsome of the condition flags are modified).\n\n\t* config/arm/bpabi-v6m.S (aeabi_lcmp): Convert thumb1 code to unified\n\tsyntax.\n\t(aeabi_ulcmp, aeabi_ldivmod, aeabi_uldivmod): Likewise.\n\t(aeabi_frsub, aeabi_cfcmpeq, aeabi_fcmpeq): Likewise.\n\t(aeabi_fcmp, aeabi_drsub, aeabi_cdrcmple): Likewise.\n\t(aeabi_cdcmpeq, aeabi_dcmpeq, aeabi_dcmp): Likewise.\n\t* config/arm/lib1funcs.S (Lend_fde): Convert thumb1 code to unified\n\tsyntax.\n\t(divsi3, modsi3): Likewise.\n\t(clzdi2, ctzsi2): Likewise.\n\t* config/arm/libunwind.S (restore_core_regs): Convert thumb1 code to\n\tunified syntax.\n\t(UNWIND_WRAPPER): Likewise.", "tree": {"sha": "afa66b0142ad3c4d5fc63256eb466d5a0a51a58c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/afa66b0142ad3c4d5fc63256eb466d5a0a51a58c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6b9ce2b4eb49e3c930730c3721323349e2136b1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b9ce2b4eb49e3c930730c3721323349e2136b1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b9ce2b4eb49e3c930730c3721323349e2136b1a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b9ce2b4eb49e3c930730c3721323349e2136b1a/comments", "author": null, "committer": null, "parents": [{"sha": "8e6d0dba166324f4b257329bd4b4ddc2b4522359", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e6d0dba166324f4b257329bd4b4ddc2b4522359", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e6d0dba166324f4b257329bd4b4ddc2b4522359"}], "stats": {"total": 589, "additions": 312, "deletions": 277}, "files": [{"sha": "c113897150b2e86d271f641849be58d3c339a783", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b9ce2b4eb49e3c930730c3721323349e2136b1a/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b9ce2b4eb49e3c930730c3721323349e2136b1a/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=6b9ce2b4eb49e3c930730c3721323349e2136b1a", "patch": "@@ -1,3 +1,19 @@\n+2020-03-03  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* config/arm/bpabi-v6m.S (aeabi_lcmp): Convert thumb1 code to unified\n+\tsyntax.\n+\t(aeabi_ulcmp, aeabi_ldivmod, aeabi_uldivmod): Likewise.\n+\t(aeabi_frsub, aeabi_cfcmpeq, aeabi_fcmpeq): Likewise.\n+\t(aeabi_fcmp, aeabi_drsub, aeabi_cdrcmple): Likewise.\n+\t(aeabi_cdcmpeq, aeabi_dcmpeq, aeabi_dcmp): Likewise.\n+\t* config/arm/lib1funcs.S (Lend_fde): Convert thumb1 code to unified\n+\tsyntax.\n+\t(divsi3, modsi3): Likewise.\n+\t(clzdi2, ctzsi2): Likewise.\n+\t* config/arm/libunwind.S (restore_core_regs): Convert thumb1 code to\n+\tunified syntax.\n+\t(UNWIND_WRAPPER): Likewise.\n+\n 2020-03-02  Martin Liska  <mliska@suse.cz>\n \n \t* libgcov-interface.c: Remove duplicate"}, {"sha": "1a403efc8727ee70c67b069a8f46acb8c3cbbc89", "filename": "libgcc/config/arm/bpabi-v6m.S", "status": "modified", "additions": 60, "deletions": 60, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b9ce2b4eb49e3c930730c3721323349e2136b1a/libgcc%2Fconfig%2Farm%2Fbpabi-v6m.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b9ce2b4eb49e3c930730c3721323349e2136b1a/libgcc%2Fconfig%2Farm%2Fbpabi-v6m.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Farm%2Fbpabi-v6m.S?ref=6b9ce2b4eb49e3c930730c3721323349e2136b1a", "patch": "@@ -39,21 +39,21 @@ FUNC_START aeabi_lcmp\n \tcmp\txxh, yyh\n \tbeq\t1f\n \tbgt\t2f\n-\tmov\tr0, #1\n-\tneg\tr0, r0\n+\tmovs\tr0, #1\n+\tnegs\tr0, r0\n \tRET\n 2:\n-\tmov\tr0, #1\n+\tmovs\tr0, #1\n \tRET\n 1:\n-\tsub\tr0, xxl, yyl\n+\tsubs\tr0, xxl, yyl\n \tbeq\t1f\n \tbhi\t2f\n-\tmov\tr0, #1\n-\tneg\tr0, r0\n+\tmovs\tr0, #1\n+\tnegs\tr0, r0\n \tRET\n 2:\n-\tmov\tr0, #1\n+\tmovs\tr0, #1\n 1:\n \tRET\n \tFUNC_END aeabi_lcmp\n@@ -65,15 +65,15 @@ FUNC_START aeabi_lcmp\n FUNC_START aeabi_ulcmp\n \tcmp\txxh, yyh\n \tbne\t1f\n-\tsub\tr0, xxl, yyl\n+\tsubs\tr0, xxl, yyl\n \tbeq\t2f\n 1:\n \tbcs\t1f\n-\tmov\tr0, #1\n-\tneg\tr0, r0\n+\tmovs\tr0, #1\n+\tnegs\tr0, r0\n \tRET\n 1:\n-\tmov\tr0, #1\n+\tmovs\tr0, #1\n 2:\n \tRET\n \tFUNC_END aeabi_ulcmp\n@@ -91,29 +91,29 @@ FUNC_START aeabi_ulcmp\n \tcmp\txxl, #0\n 2:\n \tbeq\t3f\n-\tmov\txxh, #0\n-\tmvn\txxh, xxh\t\t@ 0xffffffff\n-\tmov\txxl, xxh\n+\tmovs\txxh, #0\n+\tmvns\txxh, xxh\t\t@ 0xffffffff\n+\tmovs\txxl, xxh\n 3:\n \t.else\n \tblt\t6f\n \tbgt\t4f\n \tcmp\txxl, #0\n \tbeq\t5f\n-4:\tmov\txxl, #0\n-\tmvn\txxl, xxl\t\t@ 0xffffffff\n-\tlsr\txxh, xxl, #1\t\t@ 0x7fffffff\n+4:\tmovs\txxl, #0\n+\tmvns\txxl, xxl\t\t@ 0xffffffff\n+\tlsrs\txxh, xxl, #1\t\t@ 0x7fffffff\n \tb\t5f\n-6:\tmov\txxh, #0x80\n-\tlsl\txxh, xxh, #24\t\t@ 0x80000000\n-\tmov\txxl, #0\n+6:\tmovs\txxh, #0x80\n+\tlsls\txxh, xxh, #24\t\t@ 0x80000000\n+\tmovs\txxl, #0\n 5:\n \t.endif\n \t@ tailcalls are tricky on v6-m.\n \tpush\t{r0, r1, r2}\n \tldr\tr0, 1f\n \tadr\tr1, 1f\n-\tadd\tr0, r1\n+\tadds\tr0, r1\n \tstr\tr0, [sp, #8]\n \t@ We know we are not on armv4t, so pop pc is safe.\n \tpop\t{r0, r1, pc}\n@@ -128,15 +128,15 @@ FUNC_START aeabi_ulcmp\n FUNC_START aeabi_ldivmod\n \ttest_div_by_zero signed\n \n-\tpush {r0, r1}\n-\tmov r0, sp\n-\tpush {r0, lr}\n-\tldr r0, [sp, #8]\n-\tbl SYM(__gnu_ldivmod_helper)\n-\tldr r3, [sp, #4]\n-\tmov lr, r3\n-\tadd sp, sp, #8\n-\tpop {r2, r3}\n+\tpush\t{r0, r1}\n+\tmov\tr0, sp\n+\tpush\t{r0, lr}\n+\tldr\tr0, [sp, #8]\n+\tbl\tSYM(__gnu_ldivmod_helper)\n+\tldr\tr3, [sp, #4]\n+\tmov\tlr, r3\n+\tadd\tsp, sp, #8\n+\tpop\t{r2, r3}\n \tRET\n \tFUNC_END aeabi_ldivmod\n \n@@ -147,15 +147,15 @@ FUNC_START aeabi_ldivmod\n FUNC_START aeabi_uldivmod\n \ttest_div_by_zero unsigned\n \n-\tpush {r0, r1}\n-\tmov r0, sp\n-\tpush {r0, lr}\n-\tldr r0, [sp, #8]\n-\tbl SYM(__udivmoddi4)\n-\tldr r3, [sp, #4]\n-\tmov lr, r3\n-\tadd sp, sp, #8\n-\tpop {r2, r3}\n+\tpush\t{r0, r1}\n+\tmov\tr0, sp\n+\tpush\t{r0, lr}\n+\tldr\tr0, [sp, #8]\n+\tbl\tSYM(__udivmoddi4)\n+\tldr\tr3, [sp, #4]\n+\tmov\tlr, r3\n+\tadd\tsp, sp, #8\n+\tpop\t{r2, r3}\n \tRET\n \tFUNC_END aeabi_uldivmod\n \t\n@@ -166,9 +166,9 @@ FUNC_START aeabi_uldivmod\n FUNC_START aeabi_frsub\n \n       push\t{r4, lr}\n-      mov\tr4, #1\n-      lsl\tr4, #31\n-      eor\tr0, r0, r4\n+      movs\tr4, #1\n+      lsls\tr4, #31\n+      eors\tr0, r0, r4\n       bl\t__aeabi_fadd\n       pop\t{r4, pc}\n \n@@ -181,7 +181,7 @@ FUNC_START aeabi_frsub\n FUNC_START aeabi_cfrcmple\n \n \tmov\tip, r0\n-\tmov\tr0, r1\n+\tmovs\tr0, r1\n \tmov\tr1, ip\n \tb\t6f\n \n@@ -196,8 +196,8 @@ FUNC_ALIAS aeabi_cfcmple aeabi_cfcmpeq\n \tcmp\tr0, #0\n \t@ Clear the C flag if the return value was -1, indicating\n \t@ that the first operand was smaller than the second.\n-\tbmi 1f\n-\tmov\tr1, #0\n+\tbmi\t1f\n+\tmovs\tr1, #0\n \tcmn\tr0, r1\n 1:\n \tpop\t{r0, r1, r2, r3, r4, pc}\n@@ -210,8 +210,8 @@ FUNC_START\taeabi_fcmpeq\n \n \tpush\t{r4, lr}\n \tbl\t__eqsf2\n-\tneg\tr0, r0\n-\tadd\tr0, r0, #1\n+\tnegs\tr0, r0\n+\tadds\tr0, r0, #1\n \tpop\t{r4, pc}\n \n \tFUNC_END aeabi_fcmpeq\n@@ -223,10 +223,10 @@ FUNC_START\taeabi_fcmp\\cond\n \tbl\t__\\helper\\mode\n \tcmp\tr0, #0\n \tb\\cond\t1f\n-\tmov\tr0, #0\n+\tmovs\tr0, #0\n \tpop\t{r4, pc}\n 1:\n-\tmov\tr0, #1\n+\tmovs\tr0, #1\n \tpop\t{r4, pc}\n \n \tFUNC_END aeabi_fcmp\\cond\n@@ -244,9 +244,9 @@ COMPARISON ge, ge\n FUNC_START aeabi_drsub\n \n       push\t{r4, lr}\n-      mov\tr4, #1\n-      lsl\tr4, #31\n-      eor\txxh, xxh, r4\n+      movs\tr4, #1\n+      lsls\tr4, #31\n+      eors\txxh, xxh, r4\n       bl\t__aeabi_dadd\n       pop\t{r4, pc}\n \n@@ -259,10 +259,10 @@ FUNC_START aeabi_drsub\n FUNC_START aeabi_cdrcmple\n \n \tmov\tip, r0\n-\tmov\tr0, r2\n+\tmovs\tr0, r2\n \tmov\tr2, ip\n \tmov\tip, r1\n-\tmov\tr1, r3\n+\tmovs\tr1, r3\n \tmov\tr3, ip\n \tb\t6f\n \n@@ -277,8 +277,8 @@ FUNC_ALIAS aeabi_cdcmple aeabi_cdcmpeq\n \tcmp\tr0, #0\n \t@ Clear the C flag if the return value was -1, indicating\n \t@ that the first operand was smaller than the second.\n-\tbmi 1f\n-\tmov\tr1, #0\n+\tbmi\t1f\n+\tmovs\tr1, #0\n \tcmn\tr0, r1\n 1:\n \tpop\t{r0, r1, r2, r3, r4, pc}\n@@ -291,8 +291,8 @@ FUNC_START\taeabi_dcmpeq\n \n \tpush\t{r4, lr}\n \tbl\t__eqdf2\n-\tneg\tr0, r0\n-\tadd\tr0, r0, #1\n+\tnegs\tr0, r0\n+\tadds\tr0, r0, #1\n \tpop\t{r4, pc}\n \n \tFUNC_END aeabi_dcmpeq\n@@ -304,10 +304,10 @@ FUNC_START\taeabi_dcmp\\cond\n \tbl\t__\\helper\\mode\n \tcmp\tr0, #0\n \tb\\cond\t1f\n-\tmov\tr0, #0\n+\tmovs\tr0, #0\n \tpop\t{r4, pc}\n 1:\n-\tmov\tr0, #1\n+\tmovs\tr0, #1\n \tpop\t{r4, pc}\n \n \tFUNC_END aeabi_dcmp\\cond"}, {"sha": "e8d2158f8d6d25dabee90bee6acd56f8320d0e59", "filename": "libgcc/config/arm/lib1funcs.S", "status": "modified", "additions": 192, "deletions": 173, "changes": 365, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b9ce2b4eb49e3c930730c3721323349e2136b1a/libgcc%2Fconfig%2Farm%2Flib1funcs.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b9ce2b4eb49e3c930730c3721323349e2136b1a/libgcc%2Fconfig%2Farm%2Flib1funcs.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Farm%2Flib1funcs.S?ref=6b9ce2b4eb49e3c930730c3721323349e2136b1a", "patch": "@@ -22,6 +22,10 @@ a copy of the GCC Runtime Library Exception along with this program;\n see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n+/* Everything in this file should now use unified syntax.  */\n+\n+\t.syntax unified\n+\n /* An executable stack is *not* required for these functions.  */\n #if defined(__ELF__) && defined(__linux__)\n .section .note.GNU-stack,\"\",%progbits\n@@ -270,7 +274,7 @@ LSYM(Lend_fde):\n #ifdef NOT_ISA_TARGET_32BIT\n \n \tpush\t{r0, lr}\n-\tmov\tr0, #0\n+\tmovs\tr0, #0\n \tbl\tSYM(__aeabi_idiv0)\n \t@ We know we are not on armv4t, so pop pc is safe.\n \tpop\t{r1, pc}\n@@ -310,7 +314,7 @@ LSYM(Lend_fde):\n \tpush\t{ r1, lr }\n 98:\tcfi_push 98b - __\\name, 0xe, -0x4, 0x8\n \tbl\tSYM (__div0)\n-\tmov\tr0, #0\t\t\t@ About as wrong as it could be.\n+\tmovs\tr0, #0\t\t\t@ About as wrong as it could be.\n #if defined (__INTERWORKING__)\n \tpop\t{ r1, r2 }\n \tbx\tr2\n@@ -349,7 +353,7 @@ SYM (\\name):\n #define THUMB_FUNC .thumb_func\n #define THUMB_CODE .force_thumb\n # if defined(__thumb2__)\n-#define THUMB_SYNTAX .syntax divided\n+#define THUMB_SYNTAX\n # else\n #define THUMB_SYNTAX\n # endif\n@@ -725,8 +729,8 @@ pc\t\t.req\tr15\n /* ------------------------------------------------------------------------ */\n .macro THUMB_DIV_MOD_BODY modulo\n \t@ Load the constant 0x10000000 into our work register.\n-\tmov\twork, #1\n-\tlsl\twork, #28\n+\tmovs\twork, #1\n+\tlsls\twork, #28\n LSYM(Loop1):\n \t@ Unless the divisor is very big, shift it up in multiples of\n \t@ four bits, since this is the amount of unwinding in the main\n@@ -736,61 +740,61 @@ LSYM(Loop1):\n \tbhs\tLSYM(Lbignum)\n \tcmp\tdivisor, dividend\n \tbhs\tLSYM(Lbignum)\n-\tlsl\tdivisor, #4\n-\tlsl\tcurbit,  #4\n+\tlsls\tdivisor, #4\n+\tlsls\tcurbit,  #4\n \tb\tLSYM(Loop1)\n LSYM(Lbignum):\n \t@ Set work to 0x80000000\n-\tlsl\twork, #3\n+\tlsls\twork, #3\n LSYM(Loop2):\n \t@ For very big divisors, we must shift it a bit at a time, or\n \t@ we will be in danger of overflowing.\n \tcmp\tdivisor, work\n \tbhs\tLSYM(Loop3)\n \tcmp\tdivisor, dividend\n \tbhs\tLSYM(Loop3)\n-\tlsl\tdivisor, #1\n-\tlsl\tcurbit,  #1\n+\tlsls\tdivisor, #1\n+\tlsls\tcurbit,  #1\n \tb\tLSYM(Loop2)\n LSYM(Loop3):\n \t@ Test for possible subtractions ...\n   .if \\modulo\n \t@ ... On the final pass, this may subtract too much from the dividend, \n \t@ so keep track of which subtractions are done, we can fix them up \n \t@ afterwards.\n-\tmov\toverdone, #0\n+\tmovs\toverdone, #0\n \tcmp\tdividend, divisor\n \tblo\tLSYM(Lover1)\n-\tsub\tdividend, dividend, divisor\n+\tsubs\tdividend, dividend, divisor\n LSYM(Lover1):\n-\tlsr\twork, divisor, #1\n+\tlsrs\twork, divisor, #1\n \tcmp\tdividend, work\n \tblo\tLSYM(Lover2)\n-\tsub\tdividend, dividend, work\n+\tsubs\tdividend, dividend, work\n \tmov\tip, curbit\n-\tmov\twork, #1\n-\tror\tcurbit, work\n-\torr\toverdone, curbit\n+\tmovs\twork, #1\n+\trors\tcurbit, work\n+\torrs\toverdone, curbit\n \tmov\tcurbit, ip\n LSYM(Lover2):\n-\tlsr\twork, divisor, #2\n+\tlsrs\twork, divisor, #2\n \tcmp\tdividend, work\n \tblo\tLSYM(Lover3)\n-\tsub\tdividend, dividend, work\n+\tsubs\tdividend, dividend, work\n \tmov\tip, curbit\n-\tmov\twork, #2\n-\tror\tcurbit, work\n-\torr\toverdone, curbit\n+\tmovs\twork, #2\n+\trors\tcurbit, work\n+\torrs\toverdone, curbit\n \tmov\tcurbit, ip\n LSYM(Lover3):\n-\tlsr\twork, divisor, #3\n+\tlsrs\twork, divisor, #3\n \tcmp\tdividend, work\n \tblo\tLSYM(Lover4)\n-\tsub\tdividend, dividend, work\n+\tsubs\tdividend, dividend, work\n \tmov\tip, curbit\n-\tmov\twork, #3\n-\tror\tcurbit, work\n-\torr\toverdone, curbit\n+\tmovs\twork, #3\n+\trors\tcurbit, work\n+\torrs\toverdone, curbit\n \tmov\tcurbit, ip\n LSYM(Lover4):\n \tmov\tip, curbit\n@@ -800,46 +804,46 @@ LSYM(Lover4):\n \t@ since the \"bit\" will have been shifted out at the bottom.\n \tcmp\tdividend, divisor\n \tblo\tLSYM(Lover1)\n-\tsub\tdividend, dividend, divisor\n-\torr\tresult, result, curbit\n+\tsubs\tdividend, dividend, divisor\n+\torrs\tresult, result, curbit\n LSYM(Lover1):\n-\tlsr\twork, divisor, #1\n+\tlsrs\twork, divisor, #1\n \tcmp\tdividend, work\n \tblo\tLSYM(Lover2)\n-\tsub\tdividend, dividend, work\n-\tlsr\twork, curbit, #1\n-\torr\tresult, work\n+\tsubs\tdividend, dividend, work\n+\tlsrs\twork, curbit, #1\n+\torrs\tresult, work\n LSYM(Lover2):\n-\tlsr\twork, divisor, #2\n+\tlsrs\twork, divisor, #2\n \tcmp\tdividend, work\n \tblo\tLSYM(Lover3)\n-\tsub\tdividend, dividend, work\n-\tlsr\twork, curbit, #2\n-\torr\tresult, work\n+\tsubs\tdividend, dividend, work\n+\tlsrs\twork, curbit, #2\n+\torrs\tresult, work\n LSYM(Lover3):\n-\tlsr\twork, divisor, #3\n+\tlsrs\twork, divisor, #3\n \tcmp\tdividend, work\n \tblo\tLSYM(Lover4)\n-\tsub\tdividend, dividend, work\n-\tlsr\twork, curbit, #3\n-\torr\tresult, work\n+\tsubs\tdividend, dividend, work\n+\tlsrs\twork, curbit, #3\n+\torrs\tresult, work\n LSYM(Lover4):\n   .endif\n \t\n \tcmp\tdividend, #0\t\t\t@ Early termination?\n \tbeq\tLSYM(Lover5)\n-\tlsr\tcurbit,  #4\t\t\t@ No, any more bits to do?\n+\tlsrs\tcurbit,  #4\t\t\t@ No, any more bits to do?\n \tbeq\tLSYM(Lover5)\n-\tlsr\tdivisor, #4\n+\tlsrs\tdivisor, #4\n \tb\tLSYM(Loop3)\n LSYM(Lover5):\n   .if \\modulo\n \t@ Any subtractions that we should not have done will be recorded in\n \t@ the top three bits of \"overdone\".  Exactly which were not needed\n \t@ are governed by the position of the bit, stored in ip.\n-\tmov\twork, #0xe\n-\tlsl\twork, #28\n-\tand\toverdone, work\n+\tmovs\twork, #0xe\n+\tlsls\twork, #28\n+\tands\toverdone, work\n \tbeq\tLSYM(Lgot_result)\n \t\n \t@ If we terminated early, because dividend became zero, then the \n@@ -849,33 +853,33 @@ LSYM(Lover5):\n \t@ the bit in ip could be in the top two bits which might then match\n \t@ with one of the smaller RORs.\n \tmov\tcurbit, ip\n-\tmov\twork, #0x7\n+\tmovs\twork, #0x7\n \ttst\tcurbit, work\n \tbeq\tLSYM(Lgot_result)\n \t\n \tmov\tcurbit, ip\n-\tmov\twork, #3\n-\tror\tcurbit, work\n+\tmovs\twork, #3\n+\trors\tcurbit, work\n \ttst\toverdone, curbit\n \tbeq\tLSYM(Lover6)\n-\tlsr\twork, divisor, #3\n-\tadd\tdividend, work\n+\tlsrs\twork, divisor, #3\n+\tadds\tdividend, work\n LSYM(Lover6):\n \tmov\tcurbit, ip\n-\tmov\twork, #2\n-\tror\tcurbit, work\n+\tmovs\twork, #2\n+\trors\tcurbit, work\n \ttst\toverdone, curbit\n \tbeq\tLSYM(Lover7)\n-\tlsr\twork, divisor, #2\n-\tadd\tdividend, work\n+\tlsrs\twork, divisor, #2\n+\tadds\tdividend, work\n LSYM(Lover7):\n \tmov\tcurbit, ip\n-\tmov\twork, #1\n-\tror\tcurbit, work\n+\tmovs\twork, #1\n+\trors\tcurbit, work\n \ttst\toverdone, curbit\n \tbeq\tLSYM(Lgot_result)\n-\tlsr\twork, divisor, #1\n-\tadd\tdividend, work\n+\tlsrs\twork, divisor, #1\n+\tadds\tdividend, work\n   .endif\n LSYM(Lgot_result):\n .endm\n@@ -885,51 +889,51 @@ LSYM(Lgot_result):\n \n /* Branch to div(n), and jump to label if curbit is lo than divisior.  */\n .macro BranchToDiv n, label\n-\tlsr\tcurbit, dividend, \\n\n+\tlsrs\tcurbit, dividend, \\n\n \tcmp\tcurbit, divisor\n \tblo\t\\label\n .endm\n \n /* Body of div(n).  Shift the divisor in n bits and compare the divisor\n    and dividend.  Update the dividend as the substruction result.  */\n .macro DoDiv n\n-\tlsr\tcurbit, dividend, \\n\n+\tlsrs\tcurbit, dividend, \\n\n \tcmp\tcurbit, divisor\n \tbcc\t1f\n-\tlsl\tcurbit, divisor, \\n\n-\tsub\tdividend, dividend, curbit\n+\tlsls\tcurbit, divisor, \\n\n+\tsubs\tdividend, dividend, curbit\n \n-1:\tadc\tresult, result\n+1:\tadcs\tresult, result\n .endm\n \n /* The body of division with positive divisor.  Unless the divisor is very\n    big, shift it up in multiples of four bits, since this is the amount of\n    unwinding in the main division loop.  Continue shifting until the divisor\n    is larger than the dividend.  */\n .macro THUMB1_Div_Positive\n-\tmov\tresult, #0\n+\tmovs\tresult, #0\n \tBranchToDiv #1, LSYM(Lthumb1_div1)\n \tBranchToDiv #4, LSYM(Lthumb1_div4)\n \tBranchToDiv #8, LSYM(Lthumb1_div8)\n \tBranchToDiv #12, LSYM(Lthumb1_div12)\n \tBranchToDiv #16, LSYM(Lthumb1_div16)\n LSYM(Lthumb1_div_large_positive):\n-\tmov\tresult, #0xff\n-\tlsl\tdivisor, divisor, #8\n+\tmovs\tresult, #0xff\n+\tlsls\tdivisor, divisor, #8\n \trev\tresult, result\n-\tlsr\tcurbit, dividend, #16\n+\tlsrs\tcurbit, dividend, #16\n \tcmp\tcurbit, divisor\n \tblo\t1f\n-\tasr\tresult, #8\n-\tlsl\tdivisor, divisor, #8\n+\tasrs\tresult, #8\n+\tlsls\tdivisor, divisor, #8\n \tbeq\tLSYM(Ldivbyzero_waypoint)\n \n-1:\tlsr\tcurbit, dividend, #12\n+1:\tlsrs\tcurbit, dividend, #12\n \tcmp\tcurbit, divisor\n \tblo\tLSYM(Lthumb1_div12)\n \tb\tLSYM(Lthumb1_div16)\n LSYM(Lthumb1_div_loop):\n-\tlsr\tdivisor, divisor, #8\n+\tlsrs\tdivisor, divisor, #8\n LSYM(Lthumb1_div16):\n \tDodiv\t#15\n \tDodiv\t#14\n@@ -954,11 +958,11 @@ LSYM(Lthumb1_div3):\n LSYM(Lthumb1_div2):\n \tDodiv\t#1\n LSYM(Lthumb1_div1):\n-\tsub\tdivisor, dividend, divisor\n+\tsubs\tdivisor, dividend, divisor\n \tbcs\t1f\n \tcpy\tdivisor, dividend\n \n-1:\tadc\tresult, result\n+1:\tadcs\tresult, result\n \tcpy\tdividend, result\n \tRET\n \n@@ -970,43 +974,43 @@ LSYM(Ldivbyzero_waypoint):\n    THUMB1_Div_Positive except that the shift steps are in multiples\n    of six bits.  */\n .macro THUMB1_Div_Negative\n-\tlsr\tresult, divisor, #31\n+\tlsrs\tresult, divisor, #31\n \tbeq\t1f\n-\tneg\tdivisor, divisor\n+\tnegs\tdivisor, divisor\n \n-1:\tasr\tcurbit, dividend, #32\n+1:\tasrs\tcurbit, dividend, #32\n \tbcc\t2f\n-\tneg\tdividend, dividend\n+\tnegs\tdividend, dividend\n \n-2:\teor\tcurbit, result\n-\tmov\tresult, #0\n+2:\teors\tcurbit, result\n+\tmovs\tresult, #0\n \tcpy\tip, curbit\n \tBranchToDiv #4, LSYM(Lthumb1_div_negative4)\n \tBranchToDiv #8, LSYM(Lthumb1_div_negative8)\n LSYM(Lthumb1_div_large):\n-\tmov\tresult, #0xfc\n-\tlsl\tdivisor, divisor, #6\n+\tmovs\tresult, #0xfc\n+\tlsls\tdivisor, divisor, #6\n \trev\tresult, result\n-\tlsr\tcurbit, dividend, #8\n+\tlsrs\tcurbit, dividend, #8\n \tcmp\tcurbit, divisor\n \tblo\tLSYM(Lthumb1_div_negative8)\n \n-\tlsl\tdivisor, divisor, #6\n-\tasr\tresult, result, #6\n+\tlsls\tdivisor, divisor, #6\n+\tasrs\tresult, result, #6\n \tcmp\tcurbit, divisor\n \tblo\tLSYM(Lthumb1_div_negative8)\n \n-\tlsl\tdivisor, divisor, #6\n-\tasr\tresult, result, #6\n+\tlsls\tdivisor, divisor, #6\n+\tasrs\tresult, result, #6\n \tcmp\tcurbit, divisor\n \tblo\tLSYM(Lthumb1_div_negative8)\n \n-\tlsl\tdivisor, divisor, #6\n+\tlsls\tdivisor, divisor, #6\n \tbeq\tLSYM(Ldivbyzero_negative)\n-\tasr\tresult, result, #6\n+\tasrs\tresult, result, #6\n \tb\tLSYM(Lthumb1_div_negative8)\n LSYM(Lthumb1_div_negative_loop):\n-\tlsr\tdivisor, divisor, #6\n+\tlsrs\tdivisor, divisor, #6\n LSYM(Lthumb1_div_negative8):\n \tDoDiv\t#7\n \tDoDiv\t#6\n@@ -1017,28 +1021,28 @@ LSYM(Lthumb1_div_negative4):\n \tDoDiv\t#2\n \tbcs\tLSYM(Lthumb1_div_negative_loop)\n \tDoDiv\t#1\n-\tsub\tdivisor, dividend, divisor\n+\tsubs\tdivisor, dividend, divisor\n \tbcs\t1f\n \tcpy\tdivisor, dividend\n \n 1:\tcpy\tcurbit, ip\n-\tadc\tresult, result\n-\tasr\tcurbit, curbit, #1\n+\tadcs\tresult, result\n+\tasrs\tcurbit, curbit, #1\n \tcpy\tdividend, result\n \tbcc\t2f\n-\tneg\tdividend, dividend\n+\tnegs\tdividend, dividend\n \tcmp\tcurbit, #0\n \n 2:\tbpl\t3f\n-\tneg\tdivisor, divisor\n+\tnegs\tdivisor, divisor\n \n 3:\tRET\n \n LSYM(Ldivbyzero_negative):\n \tcpy\tcurbit, ip\n-\tasr\tcurbit, curbit, #1\n+\tasrs\tcurbit, curbit, #1\n \tbcc\tLSYM(Ldiv0)\n-\tneg\tdividend, dividend\n+\tnegs\tdividend, dividend\n .endm\n #endif /* ARM Thumb version.  */\n \n@@ -1056,16 +1060,16 @@ LSYM(Ldivbyzero_negative):\n \tcmp\tdivisor, #0\n \tbeq\tLSYM(Ldiv0)\n LSYM(udivsi3_skip_div0_test):\n-\tmov\tcurbit, #1\n-\tmov\tresult, #0\n+\tmovs\tcurbit, #1\n+\tmovs\tresult, #0\n \t\n \tpush\t{ work }\n \tcmp\tdividend, divisor\n \tblo\tLSYM(Lgot_result)\n \n \tTHUMB_DIV_MOD_BODY 0\n \t\n-\tmov\tr0, result\n+\tmovs\tr0, result\n \tpop\t{ work }\n \tRET\n \n@@ -1184,7 +1188,7 @@ ARM_FUNC_START aeabi_uidivmod\n \n \tcmp\tdivisor, #0\n \tbeq\tLSYM(Ldiv0)\n-\tmov\tcurbit, #1\n+\tmovs\tcurbit, #1\n \tcmp\tdividend, divisor\n \tbhs\tLSYM(Lover10)\n \tRET\t\n@@ -1263,7 +1267,7 @@ LSYM(Lover12):\n #else\n LSYM(divsi3_skip_div0_test):\n \tcpy\tcurbit, dividend\n-\torr\tcurbit, divisor\n+\torrs\tcurbit, divisor\n \tbmi\tLSYM(Lthumb1_div_negative)\n \n LSYM(Lthumb1_div_positive):\n@@ -1395,11 +1399,11 @@ ARM_FUNC_START aeabi_idivmod\n \n \tFUNC_START modsi3\n \n-\tmov\tcurbit, #1\n+\tmovs\tcurbit, #1\n \tcmp\tdivisor, #0\n \tbeq\tLSYM(Ldiv0)\n \tbpl\tLSYM(Lover10)\n-\tneg\tdivisor, divisor\t\t@ Loops below use unsigned.\n+\tnegs\tdivisor, divisor\t\t@ Loops below use unsigned.\n LSYM(Lover10):\n \tpush\t{ work }\n \t@ Need to save the sign of the dividend, unfortunately, we need\n@@ -1408,7 +1412,7 @@ LSYM(Lover10):\n \tpush\t{ dividend }\n \tcmp\tdividend, #0\n \tbpl\tLSYM(Lover11)\n-\tneg\tdividend, dividend\n+\tnegs\tdividend, dividend\n LSYM(Lover11):\n \tcmp\tdividend, divisor\n \tblo\tLSYM(Lgot_result)\n@@ -1418,7 +1422,7 @@ LSYM(Lover11):\n \tpop\t{ work }\n \tcmp\twork, #0\n \tbpl\tLSYM(Lover12)\n-\tneg\tdividend, dividend\n+\tnegs\tdividend, dividend\n LSYM(Lover12):\n \tpop\t{ work }\n \tRET\t\n@@ -1540,12 +1544,12 @@ LSYM(Lover12):\n \t   address, so just clear pc..pc+1.  */\n #if defined __thumb__ && !defined __thumb2__\n \tpush\t{r7}\n-\tmov\tr7, #0xf\n-\tlsl\tr7, #16\n-\tadd\tr7, #2\n+\tmovs\tr7, #0xf\n+\tlsls\tr7, #16\n+\tadds\tr7, #2\n \tadr\tr0, . + 4\n-\tadd\tr1, r0, #1\n-\tmov\tr2, #0\n+\tadds\tr1, r0, #1\n+\tmovs\tr2, #0\n \tsvc\t0\n \tpop\t{r7}\n #else\n@@ -1595,17 +1599,17 @@ LSYM(Lover12):\n \tFUNC_ALIAS aeabi_llsr lshrdi3\n \t\n #ifdef __thumb__\n-\tlsr\tal, r2\n-\tmov\tr3, ah\n-\tlsr\tah, r2\n+\tlsrs\tal, r2\n+\tmovs\tr3, ah\n+\tlsrs\tah, r2\n \tmov\tip, r3\n-\tsub\tr2, #32\n-\tlsr\tr3, r2\n-\torr\tal, r3\n-\tneg\tr2, r2\n+\tsubs\tr2, #32\n+\tlsrs\tr3, r2\n+\torrs\tal, r3\n+\tnegs\tr2, r2\n \tmov\tr3, ip\n-\tlsl\tr3, r2\n-\torr\tal, r3\n+\tlsls\tr3, r2\n+\torrs\tal, r3\n \tRET\n #else\n \tsubs\tr3, r2, #32\n@@ -1627,21 +1631,21 @@ LSYM(Lover12):\n \tFUNC_ALIAS aeabi_lasr ashrdi3\n \t\n #ifdef __thumb__\n-\tlsr\tal, r2\n-\tmov\tr3, ah\n-\tasr\tah, r2\n-\tsub\tr2, #32\n+\tlsrs\tal, r2\n+\tmovs\tr3, ah\n+\tasrs\tah, r2\n+\tsubs\tr2, #32\n \t@ If r2 is negative at this point the following step would OR\n \t@ the sign bit into all of AL.  That's not what we want...\n \tbmi\t1f\n \tmov\tip, r3\n-\tasr\tr3, r2\n-\torr\tal, r3\n+\tasrs\tr3, r2\n+\torrs\tal, r3\n \tmov\tr3, ip\n 1:\n-\tneg\tr2, r2\n-\tlsl\tr3, r2\n-\torr\tal, r3\n+\tnegs\tr2, r2\n+\tlsls\tr3, r2\n+\torrs\tal, r3\n \tRET\n #else\n \tsubs\tr3, r2, #32\n@@ -1664,17 +1668,17 @@ LSYM(Lover12):\n \tFUNC_ALIAS aeabi_llsl ashldi3\n \t\n #ifdef __thumb__\n-\tlsl\tah, r2\n-\tmov\tr3, al\n-\tlsl\tal, r2\n+\tlsls\tah, r2\n+\tmovs\tr3, al\n+\tlsls\tal, r2\n \tmov\tip, r3\n-\tsub\tr2, #32\n-\tlsl\tr3, r2\n-\torr\tah, r3\n-\tneg\tr2, r2\n+\tsubs\tr2, #32\n+\tlsls\tr3, r2\n+\torrs\tah, r3\n+\tnegs\tr2, r2\n \tmov\tr3, ip\n-\tlsr\tr3, r2\n-\torr\tah, r3\n+\tlsrs\tr3, r2\n+\torrs\tah, r3\n \tRET\n #else\n \tsubs\tr3, r2, #32\n@@ -1695,26 +1699,26 @@ LSYM(Lover12):\n #ifdef L_clzsi2\n #ifdef NOT_ISA_TARGET_32BIT\n FUNC_START clzsi2\n-\tmov\tr1, #28\n-\tmov\tr3, #1\n-\tlsl\tr3, r3, #16\n+\tmovs\tr1, #28\n+\tmovs\tr3, #1\n+\tlsls\tr3, r3, #16\n \tcmp\tr0, r3 /* 0x10000 */\n \tbcc\t2f\n-\tlsr\tr0, r0, #16\n-\tsub\tr1, r1, #16\n-2:\tlsr\tr3, r3, #8\n+\tlsrs\tr0, r0, #16\n+\tsubs\tr1, r1, #16\n+2:\tlsrs\tr3, r3, #8\n \tcmp\tr0, r3 /* #0x100 */\n \tbcc\t2f\n-\tlsr\tr0, r0, #8\n-\tsub\tr1, r1, #8\n-2:\tlsr\tr3, r3, #4\n+\tlsrs\tr0, r0, #8\n+\tsubs\tr1, r1, #8\n+2:\tlsrs\tr3, r3, #4\n \tcmp\tr0, r3 /* #0x10 */\n \tbcc\t2f\n-\tlsr\tr0, r0, #4\n-\tsub\tr1, r1, #4\n+\tlsrs\tr0, r0, #4\n+\tsubs\tr1, r1, #4\n 2:\tadr\tr2, 1f\n \tldrb\tr0, [r2, r0]\n-\tadd\tr0, r0, r1\n+\tadds\tr0, r0, r1\n \tbx lr\n .align 2\n 1:\n@@ -1757,34 +1761,49 @@ ARM_FUNC_START clzsi2\n # ifdef NOT_ISA_TARGET_32BIT\n FUNC_START clzdi2\n \tpush\t{r4, lr}\n-# else\n+\tcmp\txxh, #0\n+\tbne\t1f\n+#  ifdef __ARMEB__\n+\tmovs\tr0, xxl\n+\tbl\t__clzsi2\n+\tadds\tr0, r0, #32\n+\tb 2f\n+1:\n+\tbl\t__clzsi2\n+#  else\n+\tbl\t__clzsi2\n+\tadds\tr0, r0, #32\n+\tb 2f\n+1:\n+\tmovs\tr0, xxh\n+\tbl\t__clzsi2\n+#  endif\n+2:\n+\tpop\t{r4, pc}\n+# else /* NOT_ISA_TARGET_32BIT */\n ARM_FUNC_START clzdi2\n \tdo_push\t{r4, lr}\n-# endif\n \tcmp\txxh, #0\n \tbne\t1f\n-# ifdef __ARMEB__\n+#  ifdef __ARMEB__\n \tmov\tr0, xxl\n \tbl\t__clzsi2\n \tadd\tr0, r0, #32\n \tb 2f\n 1:\n \tbl\t__clzsi2\n-# else\n+#  else\n \tbl\t__clzsi2\n \tadd\tr0, r0, #32\n \tb 2f\n 1:\n \tmov\tr0, xxh\n \tbl\t__clzsi2\n-# endif\n+#  endif\n 2:\n-# ifdef NOT_ISA_TARGET_32BIT\n-\tpop\t{r4, pc}\n-# else\n \tRETLDM\tr4\n-# endif\n \tFUNC_END clzdi2\n+# endif /* NOT_ISA_TARGET_32BIT */\n \n #else /* defined (__ARM_FEATURE_CLZ) */\n \n@@ -1803,28 +1822,28 @@ ARM_FUNC_START clzdi2\n #ifdef L_ctzsi2\n #ifdef NOT_ISA_TARGET_32BIT\n FUNC_START ctzsi2\n-\tneg\tr1, r0\n-\tand\tr0, r0, r1\n-\tmov\tr1, #28\n-\tmov\tr3, #1\n-\tlsl\tr3, r3, #16\n+\tnegs\tr1, r0\n+\tands\tr0, r0, r1\n+\tmovs\tr1, #28\n+\tmovs\tr3, #1\n+\tlsls\tr3, r3, #16\n \tcmp\tr0, r3 /* 0x10000 */\n \tbcc\t2f\n-\tlsr\tr0, r0, #16\n-\tsub\tr1, r1, #16\n-2:\tlsr\tr3, r3, #8\n+\tlsrs\tr0, r0, #16\n+\tsubs\tr1, r1, #16\n+2:\tlsrs\tr3, r3, #8\n \tcmp\tr0, r3 /* #0x100 */\n \tbcc\t2f\n-\tlsr\tr0, r0, #8\n-\tsub\tr1, r1, #8\n-2:\tlsr\tr3, r3, #4\n+\tlsrs\tr0, r0, #8\n+\tsubs\tr1, r1, #8\n+2:\tlsrs\tr3, r3, #4\n \tcmp\tr0, r3 /* #0x10 */\n \tbcc\t2f\n-\tlsr\tr0, r0, #4\n-\tsub\tr1, r1, #4\n+\tlsrs\tr0, r0, #4\n+\tsubs\tr1, r1, #4\n 2:\tadr\tr2, 1f\n \tldrb\tr0, [r2, r0]\n-\tsub\tr0, r0, r1\n+\tsubs\tr0, r0, r1\n \tbx lr\n .align 2\n 1:"}, {"sha": "08e0fcc0c58348a5ec86e7005f8fa97bef678715", "filename": "libgcc/config/arm/libunwind.S", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b9ce2b4eb49e3c930730c3721323349e2136b1a/libgcc%2Fconfig%2Farm%2Flibunwind.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b9ce2b4eb49e3c930730c3721323349e2136b1a/libgcc%2Fconfig%2Farm%2Flibunwind.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Farm%2Flibunwind.S?ref=6b9ce2b4eb49e3c930730c3721323349e2136b1a", "patch": "@@ -63,28 +63,28 @@\n /* r0 points to a 16-word block.  Upload these values to the actual core\n    state.  */\n FUNC_START restore_core_regs\n-\tmov r1, r0\n-\tadd r1, r1, #52\n-\tldmia r1!, {r3, r4, r5}\n-\tsub r3, r3, #4\n-\tmov ip, r3\n-\tstr r5, [r3]\n-\tmov lr, r4\n+\tmovs\tr1, r0\n+\tadds\tr1, r1, #52\n+\tldmia\tr1!, {r3, r4, r5}\n+\tsubs\tr3, r3, #4\n+\tmov\tip, r3\n+\tstr\tr5, [r3]\n+\tmov\tlr, r4\n \t/* Restore r8-r11.  */\n-\tmov r1, r0\n-\tadd r1, r1, #32\n-\tldmia r1!, {r2, r3, r4, r5}\n-\tmov r8, r2\n-\tmov r9, r3\n-\tmov sl, r4\n-\tmov fp, r5\n-\tmov r1, r0\n-\tadd r1, r1, #8\n-\tldmia r1!, {r2, r3, r4, r5, r6, r7}\n-\tldr r1, [r0, #4]\n-\tldr r0, [r0]\n-\tmov sp, ip\n-\tpop {pc}\n+\tmovs\tr1, r0\n+\tadds\tr1, r1, #32\n+\tldmia\tr1!, {r2, r3, r4, r5}\n+\tmov\tr8, r2\n+\tmov\tr9, r3\n+\tmov\tsl, r4\n+\tmov\tfp, r5\n+\tmovs\tr1, r0\n+\tadds\tr1, r1, #8\n+\tldmia\tr1!, {r2, r3, r4, r5, r6, r7}\n+\tldr\tr1, [r0, #4]\n+\tldr\tr0, [r0]\n+\tmov\tsp, ip\n+\tpop\t{pc}\n \tFUNC_END restore_core_regs\n \tUNPREFIX restore_core_regs\n \n@@ -132,38 +132,38 @@ FUNC_START gnu_Unwind_Save_WMMXC\n \tFUNC_START \\name\n \t/* Create a phase2_vrs structure.  */\n \t/* Save r0 in the PC slot so we can use it as a scratch register.  */\n-\tpush {r0}\n-\tadd r0, sp, #4\n-\tpush {r0, lr} /* Push original SP and LR.  */\n+\tpush\t{r0}\n+\tadd\tr0, sp, #4\n+\tpush\t{r0, lr} /* Push original SP and LR.  */\n \t/* Make space for r8-r12.  */\n-\tsub sp, sp, #20\n+\tsub\tsp, sp, #20\n \t/* Save low registers.  */\n-\tpush {r0, r1, r2, r3, r4, r5, r6, r7}\n+\tpush\t{r0, r1, r2, r3, r4, r5, r6, r7}\n \t/* Save high registers.  */\n-\tadd r0, sp, #32\n-\tmov r1, r8\n-\tmov r2, r9\n-\tmov r3, sl\n-\tmov r4, fp\n-\tmov r5, ip\n-\tstmia r0!, {r1, r2, r3, r4, r5}\n+\tadd\tr0, sp, #32\n+\tmov\tr1, r8\n+\tmov\tr2, r9\n+\tmov\tr3, sl\n+\tmov\tr4, fp\n+\tmov\tr5, ip\n+\tstmia\tr0!, {r1, r2, r3, r4, r5}\n \t/* Restore original low register values.  */\n-\tadd r0, sp, #4\n-\tldmia r0!, {r1, r2, r3, r4, r5}\n+\tadd\tr0, sp, #4\n+\tldmia\tr0!, {r1, r2, r3, r4, r5}\n \t/* Restore orginial r0.  */\n-\tldr r0, [sp, #60]\n-\tstr r0, [sp]\n+\tldr\tr0, [sp, #60]\n+\tstr\tr0, [sp]\n \t/* Demand-save flags, plus an extra word for alignment.  */\n-\tmov r3, #0\n-\tpush {r2, r3}\n+\tmovs\tr3, #0\n+\tpush\t{r2, r3}\n \t/* Point r1 at the block.  Pass r[0..nargs) unchanged.  */\n-\tadd r\\nargs, sp, #4\n+\tadd\tr\\nargs, sp, #4\n \n-\tbl SYM (__gnu\\name)\n+\tbl\tSYM (__gnu\\name)\n \n-\tldr r3, [sp, #64]\n-\tadd sp, sp, #72\n-\tbx r3\n+\tldr\tr3, [sp, #64]\n+\tadd\tsp, sp, #72\n+\tbx\tr3\n \n \tFUNC_END \\name\n \tUNPREFIX \\name"}]}