{"sha": "c77556a5d1e225024a4f9dafe5a1a6c316a86b83", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzc3NTU2YTVkMWUyMjUwMjRhNGY5ZGFmZTVhMWE2YzMxNmE4NmI4Mw==", "commit": {"author": {"name": "Rong Xu", "email": "xur@google.com", "date": "2014-07-11T05:48:07Z"}, "committer": {"name": "Rong Xu", "email": "xur@gcc.gnu.org", "date": "2014-07-11T05:48:07Z"}, "message": "Add gcov-tool: an offline gcda profile processing tool Support.\n\n2014-07-10  Rong Xu  <xur@google.com>\n\n\tAdd gcov-tool: an offline gcda profile processing tool\n\tSupport.\n\t* gcc/gcov-io.c (gcov_position): Make avaialble to gcov-tool.\n\t(gcov_is_error): Ditto.\n\t(gcov_read_string): Ditto.\n\t(gcov_read_sync): Ditto.\n\t* gcc/gcov-io.h: Move counter defines to gcov-counter.def.\n\t* gcc/gcov-dump.c (tag_counters): Use gcov-counter.def.\n\t* gcc/coverage.c: Ditto.\n\t* gcc/gcov-tool.c: Offline gcda profile processing tool.\n        (unlink_gcda_file): Remove one gcda file.\n\t(unlink_profile_dir): Remove gcda files from the profile path.\n\t(gcov_output_files): Output gcda files to an output dir.\n\t(profile_merge): Merge two profiles in directory.\n\t(print_merge_usage_message): Print merge usage.\n\t(merge_usage): Print merge usage and exit.\n\t(do_merge): Driver for profile merge sub-command.\n\t(profile_rewrite): Rewrite profile.\n\t(print_rewrite_usage_message): Print rewrite usage.\n\t(rewrite_usage): Print rewrite usage and exit.\n\t(do_rewrite): Driver for profile rewrite sub-command.\n\t(print_usage): Print gcov-info usage and exit.\n\t(print_version): Print gcov-info version.\n\t(process_args): Process arguments.\n\t(main): Main routine for gcov-tool.\n\t* gcc/Makefile.in: Build and install gcov-tool.\n\t* gcc/gcov-counter.def: New file split from gcov-io.h.\n\t* libgcc/libgcov-driver.c (gcov_max_filename): Make available\n        to gcov-tool.\n\t* libgcc/libgcov-merge.c (__gcov_merge_add): Replace\n        gcov_read_counter() with a Macro.\n\t(__gcov_merge_ior): Ditto.\n\t(__gcov_merge_time_profile): Ditto.\n\t(__gcov_merge_single): Ditto.\n\t(__gcov_merge_delta): Ditto.\n\t* libgcc/libgcov-util.c (void gcov_set_verbose): Set the verbose flag\n        in the utility functions.\n\t(set_fn_ctrs): Utility function for reading gcda files to in-memory\n        gcov_list object link lists.\n\t(tag_function): Ditto.\n\t(tag_blocks): Ditto.\n\t(tag_arcs): Ditto.\n\t(tag_lines): Ditto.\n\t(tag_counters): Ditto.\n\t(tag_summary): Ditto.\n\t(read_gcda_finalize): Ditto.\n\t(read_gcda_file): Ditto.\n\t(ftw_read_file): Ditto.\n\t(read_profile_dir_init): Ditto.\n\t(gcov_read_profile_dir): Ditto.\n\t(gcov_read_counter_mem): Ditto.\n\t(gcov_get_merge_weight): Ditto.\n\t(merge_wrapper): A wrapper function that calls merging handler.\n\t(gcov_merge): Merge two gcov_info objects with weights.\n\t(find_match_gcov_info): Find the matched gcov_info in the list.\n\t(gcov_profile_merge): Merge two gcov_info object lists.\n\t(__gcov_add_counter_op): Process edge profile counter values.\n\t(__gcov_ior_counter_op): Process IOR profile counter values.\n\t(__gcov_delta_counter_op): Process delta profile counter values.\n\t(__gcov_single_counter_op): Process single  profile counter values.\n\t(fp_scale): Callback function for float-point scaling.\n\t(int_scale): Callback function for integer fraction scaling. \n\t(gcov_profile_scale): Scaling profile counters.\n\t(gcov_profile_normalize): Normalize profile counters.\n\t* libgcc/libgcov.h: Add headers and functions for gcov-tool use.\n        (gcov_get_counter): New.\n        (gcov_get_counter_target): Ditto.\n        (struct gcov_info): Make the functions field mutable in gcov-tool\n        compilation.\n\t* gcc/doc/gcc.texi: Include gcov-tool.texi.\n\t* gcc/doc/gcov-tool.texi: Document for gcov-tool.\n\nFrom-SVN: r212448", "tree": {"sha": "99edf70eadd9518774cdee53c167eb9d38580232", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/99edf70eadd9518774cdee53c167eb9d38580232"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c77556a5d1e225024a4f9dafe5a1a6c316a86b83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c77556a5d1e225024a4f9dafe5a1a6c316a86b83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c77556a5d1e225024a4f9dafe5a1a6c316a86b83", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c77556a5d1e225024a4f9dafe5a1a6c316a86b83/comments", "author": {"login": "xur-llvm", "id": 59886942, "node_id": "MDQ6VXNlcjU5ODg2OTQy", "avatar_url": "https://avatars.githubusercontent.com/u/59886942?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xur-llvm", "html_url": "https://github.com/xur-llvm", "followers_url": "https://api.github.com/users/xur-llvm/followers", "following_url": "https://api.github.com/users/xur-llvm/following{/other_user}", "gists_url": "https://api.github.com/users/xur-llvm/gists{/gist_id}", "starred_url": "https://api.github.com/users/xur-llvm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xur-llvm/subscriptions", "organizations_url": "https://api.github.com/users/xur-llvm/orgs", "repos_url": "https://api.github.com/users/xur-llvm/repos", "events_url": "https://api.github.com/users/xur-llvm/events{/privacy}", "received_events_url": "https://api.github.com/users/xur-llvm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c14e64d4cac8f0b384e55aeff5e7074ce1bcc76d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c14e64d4cac8f0b384e55aeff5e7074ce1bcc76d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c14e64d4cac8f0b384e55aeff5e7074ce1bcc76d"}], "stats": {"total": 1931, "additions": 1868, "deletions": 63}, "files": [{"sha": "771a88728e7ca7ed545ca8ee46f6e2d31d70a257", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c77556a5d1e225024a4f9dafe5a1a6c316a86b83/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c77556a5d1e225024a4f9dafe5a1a6c316a86b83/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c77556a5d1e225024a4f9dafe5a1a6c316a86b83", "patch": "@@ -1,3 +1,35 @@\n+2014-07-10  Rong Xu  <xur@google.com>\n+\n+\tAdd gcov-tool: an offline gcda profile processing tool\n+\tSupport.\n+\t* gcov-io.c (gcov_position): Make avaialble to gcov-tool.\n+\t(gcov_is_error): Ditto.\n+\t(gcov_read_string): Ditto.\n+\t(gcov_read_sync): Ditto.\n+\t* gcov-io.h: Move counter defines to gcov-counter.def.\n+\t* gcov-dump.c (tag_counters): Use gcov-counter.def.\n+\t* coverage.c: Ditto.\n+\t* gcov-tool.c: Offline gcda profile processing tool.\n+\t(unlink_gcda_file): Remove one gcda file.\n+\t(unlink_profile_dir): Remove gcda files from the profile path.\n+\t(gcov_output_files): Output gcda files to an output dir.\n+\t(profile_merge): Merge two profiles in directory.\n+\t(print_merge_usage_message): Print merge usage.\n+\t(merge_usage): Print merge usage and exit.\n+\t(do_merge): Driver for profile merge sub-command.\n+\t(profile_rewrite): Rewrite profile.\n+\t(print_rewrite_usage_message): Print rewrite usage.\n+\t(rewrite_usage): Print rewrite usage and exit.\n+\t(do_rewrite): Driver for profile rewrite sub-command.\n+\t(print_usage): Print gcov-info usage and exit.\n+\t(print_version): Print gcov-info version.\n+\t(process_args): Process arguments.\n+\t(main): Main routine for gcov-tool.\n+\t* Makefile.in: Build and install gcov-tool.\n+\t* gcov-counter.def: New file split from gcov-io.h.\n+\t* doc/gcc.texi: Include gcov-tool.texi.\n+\t* doc/gcov-tool.texi: Document for gcov-tool.\n+\n 2014-07-10  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/61757"}, {"sha": "187e6b662029a97f3a30a8e500fd2acc9baa3cb3", "filename": "gcc/Makefile.in", "status": "modified", "additions": 41, "deletions": 5, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c77556a5d1e225024a4f9dafe5a1a6c316a86b83/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c77556a5d1e225024a4f9dafe5a1a6c316a86b83/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=c77556a5d1e225024a4f9dafe5a1a6c316a86b83", "patch": "@@ -123,7 +123,8 @@ SUBDIRS =@subdirs@ build\n \n # Selection of languages to be made.\n CONFIG_LANGUAGES = @all_selected_languages@\n-LANGUAGES = c gcov$(exeext) gcov-dump$(exeext) $(CONFIG_LANGUAGES)\n+LANGUAGES = c gcov$(exeext) gcov-dump$(exeext) gcov-tool$(exeext) \\\n+            $(CONFIG_LANGUAGES)\n \n # Default values for variables overridden in Makefile fragments.\n # CFLAGS is for the user to override to, e.g., do a cross build with -O2.\n@@ -196,6 +197,9 @@ GCC_WARN_CXXFLAGS = $(LOOSE_WARN) $($(@D)-warn) $(NOCOMMON_FLAG) $($@-warn)\n # flex output may yield harmless \"no previous prototype\" warnings\n build/gengtype-lex.o-warn = -Wno-error\n gengtype-lex.o-warn = -Wno-error\n+libgcov-util.o-warn = -Wno-error\n+libgcov-driver-tool.o-warn = -Wno-error\n+libgcov-merge-tool.o-warn = -Wno-error\n \n # All warnings have to be shut off in stage1 if the compiler used then\n # isn't gcc; configure determines that.  WARN_CFLAGS will be either\n@@ -769,6 +773,7 @@ GCC_INSTALL_NAME := $(shell echo gcc|sed '$(program_transform_name)')\n GCC_TARGET_INSTALL_NAME := $(target_noncanonical)-$(shell echo gcc|sed '$(program_transform_name)')\n CPP_INSTALL_NAME := $(shell echo cpp|sed '$(program_transform_name)')\n GCOV_INSTALL_NAME := $(shell echo gcov|sed '$(program_transform_name)')\n+GCOV_TOOL_INSTALL_NAME := $(shell echo gcov-tool|sed '$(program_transform_name)')\n \n # Setup the testing framework, if you have one\n EXPECT = `if [ -f $${rootme}/../expect/expect ] ; then \\\n@@ -890,7 +895,7 @@ BASIC_BLOCK_H = basic-block.h $(PREDICT_H) $(VEC_H) $(FUNCTION_H) \\\n GIMPLE_H = gimple.h gimple.def gsstruct.def pointer-set.h $(VEC_H) \\\n \t$(GGC_H) $(BASIC_BLOCK_H) $(TREE_H) tree-ssa-operands.h \\\n \ttree-ssa-alias.h $(INTERNAL_FN_H) $(HASH_TABLE_H) is-a.h\n-GCOV_IO_H = gcov-io.h gcov-iov.h auto-host.h\n+GCOV_IO_H = gcov-io.h gcov-iov.h auto-host.h gcov-counter.def\n RECOG_H = recog.h\n EMIT_RTL_H = emit-rtl.h\n FLAGS_H = flags.h flag-types.h $(OPTIONS_H)\n@@ -1492,7 +1497,7 @@ ALL_HOST_FRONTEND_OBJS = $(foreach v,$(CONFIG_LANGUAGES),$($(v)_OBJS))\n ALL_HOST_BACKEND_OBJS = $(GCC_OBJS) $(OBJS) $(OBJS-libcommon) \\\n   $(OBJS-libcommon-target) @TREEBROWSER@ main.o c-family/cppspec.o \\\n   $(COLLECT2_OBJS) $(EXTRA_GCC_OBJS) $(GCOV_OBJS) $(GCOV_DUMP_OBJS) \\\n-  lto-wrapper.o collect-utils.o\n+  $(GCOV_TOOL_OBJS) lto-wrapper.o collect-utils.o\n \n # This lists all host object files, whether they are included in this\n # compilation or not.\n@@ -1517,6 +1522,7 @@ MOSTLYCLEANFILES = insn-flags.h insn-config.h insn-codes.h \\\n  $(SPECS) collect2$(exeext) gcc-ar$(exeext) gcc-nm$(exeext) \\\n  gcc-ranlib$(exeext) \\\n  gcov-iov$(build_exeext) gcov$(exeext) gcov-dump$(exeext) \\\n+ gcov-tool$(exeect) \\\n  gengtype$(exeext) *.[0-9][0-9].* *.[si] *-checksum.c libbackend.a \\\n  libcommon-target.a libcommon.a libgcc.mk\n \n@@ -2576,6 +2582,22 @@ GCOV_DUMP_OBJS = gcov-dump.o\n gcov-dump$(exeext): $(GCOV_DUMP_OBJS) $(LIBDEPS)\n \t+$(LINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) $(GCOV_DUMP_OBJS) \\\n \t\t$(LIBS) -o $@\n+\n+GCOV_TOOL_DEP_FILES = $(srcdir)/../libgcc/libgcov-util.c gcov-io.c $(GCOV_IO_H) \\\n+  $(srcdir)/../libgcc/libgcov-driver.c $(srcdir)/../libgcc/libgcov-driver-system.c \\\n+  $(srcdir)/../libgcc/libgcov-merge.c \\\n+  $(SYSTEM_H) coretypes.h $(TM_H) $(CONFIG_H) version.h intl.h $(DIAGNOSTIC_H)\n+libgcov-util.o: $(srcdir)/../libgcc/libgcov-util.c $(GCOV_TOOL_DEP_FILES)\n+\t+$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) -o $@ $<\n+libgcov-driver-tool.o: $(srcdir)/../libgcc/libgcov-driver.c $(GCOV_TOOL_DEP_FILES)\n+\t+$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n+\t  -DIN_GCOV_TOOL=1 -o $@ $<\n+libgcov-merge-tool.o: $(srcdir)/../libgcc/libgcov-merge.c $(GCOV_TOOL_DEP_FILES)\n+\t+$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n+\t  -DIN_GCOV_TOOL=1 -o $@ $<\n+GCOV_TOOL_OBJS = gcov-tool.o libgcov-util.o libgcov-driver-tool.o libgcov-merge-tool.o\n+gcov-tool$(exeext): $(GCOV_TOOL_OBJS) $(LIBDEPS)\n+\t+$(LINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) $(GCOV_TOOL_OBJS) $(LIBS) -o $@\n #\f\n # Build the include directories.  The stamp files are stmp-* rather than\n # s-* so that mostlyclean does not force the include directory to\n@@ -2804,7 +2826,8 @@ TEXI_GCC_FILES = gcc.texi gcc-common.texi gcc-vers.texi frontends.texi\t\\\n \t contribute.texi compat.texi funding.texi gnu.texi gpl_v3.texi\t\\\n \t fdl.texi contrib.texi cppenv.texi cppopts.texi avr-mmcu.texi\t\\\n \t implement-c.texi implement-cxx.texi arm-neon-intrinsics.texi\t\\\n-\t arm-acle-intrinsics.texi aarch64-acle-intrinsics.texi\n+\t arm-acle-intrinsics.texi aarch64-acle-intrinsics.texi          \\\n+\t gcov-tool.texi\n \n # we explicitly use $(srcdir)/doc/tm.texi here to avoid confusion with\n # the generated tm.texi; the latter might have a more recent timestamp,\n@@ -2925,7 +2948,8 @@ $(build_htmldir)/gccinstall/index.html: $(TEXI_GCCINSTALL_FILES)\n \tDESTDIR=$(@D) \\\n \t$(SHELL) $(srcdir)/doc/install.texi2html\n \n-MANFILES = doc/gcov.1 doc/cpp.1 doc/gcc.1 doc/gfdl.7 doc/gpl.7 doc/fsf-funding.7\n+MANFILES = doc/gcov.1 doc/cpp.1 doc/gcc.1 doc/gfdl.7 doc/gpl.7 \\\n+           doc/fsf-funding.7 doc/gcov-tool.1\n \n generated-manpages: man\n \n@@ -3212,6 +3236,13 @@ install-common: native lang.install-common installdirs\n \t    rm -f $(DESTDIR)$(bindir)/$(GCOV_INSTALL_NAME)$(exeext); \\\n \t    $(INSTALL_PROGRAM) gcov$(exeext) $(DESTDIR)$(bindir)/$(GCOV_INSTALL_NAME)$(exeext); \\\n \tfi\n+# Install gcov-tool if it was compiled.\n+\t-if [ -f gcov-tool$(exeext) ]; \\\n+\tthen \\\n+\t    rm -f $(DESTDIR)$(bindir)/$(GCOV_TOOL_INSTALL_NAME)$(exeext); \\\n+\t    $(INSTALL_PROGRAM) \\\n+\t    gcov-tool$(exeext) $(DESTDIR)$(bindir)/$(GCOV_TOOL_INSTALL_NAME)$(exeext); \\\n+\tfi\n \n # Install the driver program as $(target_noncanonical)-gcc,\n # $(target_noncanonical)-gcc-$(version), and also as gcc if native.\n@@ -3317,6 +3348,11 @@ $(DESTDIR)$(man1dir)/$(GCOV_INSTALL_NAME)$(man1ext): doc/gcov.1 installdirs\n \t-$(INSTALL_DATA) $< $@\n \t-chmod a-x $@\n \n+$(DESTDIR)$(man1dir)/$(GCOV_TOOL_INSTALL_NAME)$(man1ext): doc/gcov-tool.1 installdirs\n+\t-rm -f $@\n+\t-$(INSTALL_DATA) $< $@\n+\t-chmod a-x $@\n+\n # Install all the header files built in the include subdirectory.\n install-headers: $(INSTALL_HEADERS_DIR)\n # Fix symlinks to absolute paths in the installed include directory to"}, {"sha": "1e47dd88cd98c89c4c0841ea2e910c4cea683d56", "filename": "gcc/coverage.c", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c77556a5d1e225024a4f9dafe5a1a6c316a86b83/gcc%2Fcoverage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c77556a5d1e225024a4f9dafe5a1a6c316a86b83/gcc%2Fcoverage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.c?ref=c77556a5d1e225024a4f9dafe5a1a6c316a86b83", "patch": "@@ -120,8 +120,19 @@ static unsigned bbg_file_stamp;\n static char *da_file_name;\n \n /* The names of merge functions for counters.  */\n-static const char *const ctr_merge_functions[GCOV_COUNTERS] = GCOV_MERGE_FUNCTIONS;\n-static const char *const ctr_names[GCOV_COUNTERS] = GCOV_COUNTER_NAMES;\n+#define STR(str) #str\n+#define DEF_GCOV_COUNTER(COUNTER, NAME, FN_TYPE) STR(__gcov_merge ## FN_TYPE),\n+static const char *const ctr_merge_functions[GCOV_COUNTERS] = {\n+#include \"gcov-counter.def\"\n+};\n+#undef DEF_GCOV_COUNTER\n+#undef STR\n+\n+#define DEF_GCOV_COUNTER(COUNTER, NAME, FN_TYPE) NAME,\n+static const char *const ctr_names[GCOV_COUNTERS] = {\n+#include \"gcov-counter.def\"\n+};\n+#undef DEF_GCOV_COUNTER\n \n /* Forward declarations.  */\n static void read_counts_file (void);"}, {"sha": "7ae2e75c4774a9dcd0570490f44eaf942b0b8860", "filename": "gcc/doc/gcc.texi", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c77556a5d1e225024a4f9dafe5a1a6c316a86b83/gcc%2Fdoc%2Fgcc.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c77556a5d1e225024a4f9dafe5a1a6c316a86b83/gcc%2Fdoc%2Fgcc.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgcc.texi?ref=c77556a5d1e225024a4f9dafe5a1a6c316a86b83", "patch": "@@ -66,6 +66,7 @@ Texts being (a) (see below), and with the Back-Cover Texts being (b)\n * gcc: (gcc).                  The GNU Compiler Collection.\n * g++: (gcc).                  The GNU C++ compiler.\n * gcov: (gcc) Gcov.            @command{gcov}---a test coverage program.\n+* gcov-tool: (gcc) Gcov-tool.  @command{gcov-tool}---an offline gcda profile processing program.\n @end direntry\n This file documents the use of the GNU compilers.\n @sp 1\n@@ -138,6 +139,7 @@ Introduction, gccint, GNU Compiler Collection (GCC) Internals}.\n * Objective-C::     GNU Objective-C runtime features.\n * Compatibility::   Binary Compatibility\n * Gcov::            @command{gcov}---a test coverage program.\n+* Gcov-tool::       @command{gcov-tool}---an offline gcda profile processing program.\n * Trouble::         If you have trouble using GCC.\n * Bugs::            How, why and where to report bugs.\n * Service::         How To Get Help with GCC\n@@ -164,6 +166,7 @@ Introduction, gccint, GNU Compiler Collection (GCC) Internals}.\n @include objc.texi\n @include compat.texi\n @include gcov.texi\n+@include gcov-tool.texi\n @include trouble.texi\n @include bugreport.texi\n @include service.texi"}, {"sha": "ff8b9e22f4f4d19e4c2074f1091be676c367e612", "filename": "gcc/doc/gcov-tool.texi", "status": "added", "additions": 189, "deletions": 0, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c77556a5d1e225024a4f9dafe5a1a6c316a86b83/gcc%2Fdoc%2Fgcov-tool.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c77556a5d1e225024a4f9dafe5a1a6c316a86b83/gcc%2Fdoc%2Fgcov-tool.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgcov-tool.texi?ref=c77556a5d1e225024a4f9dafe5a1a6c316a86b83", "patch": "@@ -0,0 +1,189 @@\n+@c Copyright (C) 2014 Free Software Foundation, Inc.\n+@c This is part of the GCC manual.\n+@c For copying conditions, see the file gcc.texi.\n+\n+@ignore\n+@c man begin COPYRIGHT\n+Copyright @copyright{} 2014 Free Software Foundation, Inc.\n+\n+Permission is granted to copy, distribute and/or modify this document\n+under the terms of the GNU Free Documentation License, Version 1.3 or\n+any later version published by the Free Software Foundation; with the\n+Invariant Sections being ``GNU General Public License'' and ``Funding\n+Free Software'', the Front-Cover texts being (a) (see below), and with\n+the Back-Cover Texts being (b) (see below).  A copy of the license is\n+included in the gfdl(7) man page.\n+\n+(a) The FSF's Front-Cover Text is:\n+\n+     A GNU Manual\n+\n+(b) The FSF's Back-Cover Text is:\n+\n+     You have freedom to copy and modify this GNU Manual, like GNU\n+     software.  Copies published by the Free Software Foundation raise\n+     funds for GNU development.\n+@c man end\n+@c Set file name and title for the man page.\n+@setfilename gcov-tool\n+@settitle offline gcda profile processing tool\n+@end ignore\n+\n+@node Gcov-tool\n+@chapter @command{gcov-tool}---an Offline Gcda Profile Processing Tool\n+\n+@command{gcov-tool} is a tool you can use in conjunction with GCC to\n+manipulate or process gcda profile files offline.\n+\n+@menu\n+* Gcov-tool Intro::             Introduction to gcov-tool.\n+* Invoking Gcov-tool::          How to use gcov-tool.\n+@end menu\n+\n+@node Gcov-tool Intro\n+@section Introduction to @command{gcov-tool}\n+@c man begin DESCRIPTION\n+\n+@command{gcov-tool} is an offline tool to process gcc's gcda profile files.\n+\n+Current gcov-tool supports the following functionalities:\n+\n+@itemize @bullet\n+@item\n+merge two sets of profiles with weights.\n+\n+@item\n+read one set of profile and rewrite profile contents. One can scale or\n+normalize the count values.\n+@end itemize\n+\n+Examples of the use cases for this tool are:\n+@itemize @bullet\n+@item\n+Collect the profiles for different set of inputs, and use this tool to merge\n+them. One can specify the weight to factor in the relative importance of\n+each input.\n+\n+@item\n+Rewrite the profile after removing a subset of the gcda files, while maintaining\n+the consistency of the summary and the histogram.\n+\n+@item\n+It can also be used to debug or libgcov code as the tools shares the majority\n+code as the runtime library.\n+@end itemize\n+\n+Note that for the merging operation, this profile generated offline may\n+contain slight different values from the online merged profile. Here are\n+a list of typical differences:\n+\n+@itemize @bullet\n+@item\n+histogram difference: This offline tool recomputes the histogram after merging\n+the counters. The resulting histogram, therefore, is precise. The online\n+merging does not have this capability -- the histogram is merged from two\n+histograms and the result is an approximation.\n+\n+@item\n+summary checksum difference: Summary checksum uses a CRC32 operation. The value\n+depends on the link list order of gcov-info objects. This order is different in\n+gcov-tool from that in the online merge. It's expected to have different\n+summary checksums. It does not really matter as the compiler does not use this\n+checksum anywhere.\n+\n+@item\n+value profile counter values difference: Some counter values for value profile\n+are runtime dependent, like heap addresses. It's normal to see some difference\n+in these kind of counters.\n+@end itemize\n+\n+@c man end\n+\n+@node Invoking Gcov-tool\n+@section Invoking @command{gcov-tool}\n+\n+@smallexample\n+gcov-tool @r{[}@var{global-options}@r{]} SUB_COMMAND\n+@r{[}@var{sub_command-options}@r{]} @var{profile_dir}\n+@end smallexample\n+\n+@command{gcov-tool} accepts the following options:\n+\n+@ignore\n+@c man begin SYNOPSIS\n+gcov-tool [@option{-v}|@option{--version}] [@option{-h}|@option{--help}]\n+\n+gcov-tool merge [merge-options] @var{directory1} @var{directory2}\n+     [@option{-v}|@option{--verbose}]\n+     [@option{-o}|@option{ --output} @var{directory}]\n+     [@option{-w}|@option{--weight} @var{w1,w2}]\n+\n+gcov-tool rewrite [rewrite-options] @var{directory}\n+     [@option{-v}|@option{--verbose}]\n+     [@option{-o}|@option{--output} @var{directory}]\n+     [@option{-s}|@option{--scale} @var{float_or_simple-frac_value}]\n+     [@option{-n}|@option{--normalize} @var{long_long_value}]\n+@c man end\n+@c man begin SEEALSO\n+gpl(7), gfdl(7), fsf-funding(7), gcc(1), gcov(1) and the Info entry for\n+@file{gcc}.\n+@c man end\n+@end ignore\n+\n+@c man begin OPTIONS\n+@table @gcctabopt\n+@item -h\n+@itemx --help\n+Display help about using @command{gcov-tool} (on the standard output), and\n+exit without doing any further processing.\n+\n+@item -v\n+@itemx --version\n+Display the @command{gcov-tool} version number (on the standard output),\n+and exit without doing any further processing.\n+\n+@item merge\n+Merge two profile directories.\n+\n+@table @gcctabopt\n+@item -v\n+@itemx --verbose\n+Set the verbose mode.\n+\n+@item -o @var{directory}\n+@itemx --output @var{directory}\n+Set the output profile directory. Default output directory name is\n+@var{merged_profile}.\n+\n+@item -w @var{w1},@var{w2}\n+@itemx --weight @var{w1},@var{w2}\n+Set the merge weights of the @var{directory1} and @var{directory2},\n+respectively. The default weights are 1 for both.\n+@end table\n+\n+@item rewrite\n+Read the specified profile directory and rewrite to a new directory.\n+\n+@table @gcctabopt\n+@item -v\n+@itemx --verbose\n+Set the verbose mode.\n+\n+@item -o @var{directory}\n+@itemx --output @var{directory}\n+Set the output profile directory. Default output name is @var{rewrite_profile}.\n+\n+@item -s @var{float_or_simple-frac_value}\n+@itemx --scale @var{float_or_simple-frac_value}\n+Scale the profile counters. The specified value can be in floating point value,\n+or simple fraction value form, such 1, 2, 2/3, and 5/3.\n+\n+@item -n @var{long_long_value}\n+@itemx --normalize <long_long_value>\n+Normalize the profile. The specified value is the max counter value\n+in the new profile.\n+\n+@end table\n+@end table\n+\n+@c man end"}, {"sha": "77affd44c27a4eafd7a36d15303501916bfd7dea", "filename": "gcc/gcov-counter.def", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c77556a5d1e225024a4f9dafe5a1a6c316a86b83/gcc%2Fgcov-counter.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c77556a5d1e225024a4f9dafe5a1a6c316a86b83/gcc%2Fgcov-counter.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-counter.def?ref=c77556a5d1e225024a4f9dafe5a1a6c316a86b83", "patch": "@@ -0,0 +1,54 @@\n+/* Definitions for the gcov counters in the GNU compiler.\n+   Copyright (C) 2001-2014 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* Before including this file, define a macro:\n+\n+     DEF_GCOV_COUNTER(COUNTER, NAME, FN_TYPE)\n+\n+   This macro will be expanded to all supported gcov counters, their\n+   names, or the type of handler functions.  FN_TYPE will be\n+   expanded to a handler function, like in gcov_merge, it is\n+   expanded to __gcov_merge ## FN_TYPE.  */\n+\n+/* Arc transitions.  */\n+DEF_GCOV_COUNTER(GCOV_COUNTER_ARCS, \"arcs\", _add)\n+\n+/* Histogram of value inside an interval.  */\n+DEF_GCOV_COUNTER(GCOV_COUNTER_V_INTERVAL, \"interval\", _add)\n+\n+/* Histogram of exact power2 logarithm of a value.  */\n+DEF_GCOV_COUNTER(GCOV_COUNTER_V_POW2, \"pow2\", _add)\n+\n+/* The most common value of expression.  */\n+DEF_GCOV_COUNTER(GCOV_COUNTER_V_SINGLE, \"single\", _single)\n+\n+/* The most common difference between consecutive values of expression.  */\n+DEF_GCOV_COUNTER(GCOV_COUNTER_V_DELTA, \"delta\", _delta)\n+\n+/* The most common indirect address.  */\n+DEF_GCOV_COUNTER(GCOV_COUNTER_V_INDIR, \"indirect_call\", _single)\n+\n+/* Compute average value passed to the counter.  */\n+DEF_GCOV_COUNTER(GCOV_COUNTER_AVERAGE, \"average\", _add)\n+\n+/* IOR of the all values passed to counter.  */\n+DEF_GCOV_COUNTER(GCOV_COUNTER_IOR, \"ior\", _ior)\n+\n+/* Time profile collecting first run of a function */\n+DEF_GCOV_COUNTER(GCOV_TIME_PROFILER, \"time_profiler\", _time_profile)"}, {"sha": "25e30cd88521a2ca16be11254bce9ae478299559", "filename": "gcc/gcov-dump.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c77556a5d1e225024a4f9dafe5a1a6c316a86b83/gcc%2Fgcov-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c77556a5d1e225024a4f9dafe5a1a6c316a86b83/gcc%2Fgcov-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-dump.c?ref=c77556a5d1e225024a4f9dafe5a1a6c316a86b83", "patch": "@@ -422,7 +422,11 @@ static void\n tag_counters (const char *filename ATTRIBUTE_UNUSED,\n \t      unsigned tag ATTRIBUTE_UNUSED, unsigned length ATTRIBUTE_UNUSED)\n {\n-  static const char *const counter_names[] = GCOV_COUNTER_NAMES;\n+#define DEF_GCOV_COUNTER(COUNTER, NAME, MERGE_FN) NAME,\n+  static const char *const counter_names[] = {\n+#include \"gcov-counter.def\"\n+};\n+#undef DEF_GCOV_COUNTER\n   unsigned n_counts = GCOV_TAG_COUNTER_NUM (length);\n \n   printf (\" %s %u counts\","}, {"sha": "c2cd170522c5e41b8dec8dbed65ba518f5521d95", "filename": "gcc/gcov-io.c", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c77556a5d1e225024a4f9dafe5a1a6c316a86b83/gcc%2Fgcov-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c77556a5d1e225024a4f9dafe5a1a6c316a86b83/gcc%2Fgcov-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.c?ref=c77556a5d1e225024a4f9dafe5a1a6c316a86b83", "patch": "@@ -64,15 +64,23 @@ GCOV_LINKAGE struct gcov_var\n } gcov_var;\n \n /* Save the current position in the gcov file.  */\n-static inline gcov_position_t\n+/* We need to expose this function when compiling for gcov-tool.  */\n+#ifndef IN_GCOV_TOOL\n+static inline\n+#endif\n+gcov_position_t\n gcov_position (void)\n {\n   gcov_nonruntime_assert (gcov_var.mode > 0); \n   return gcov_var.start + gcov_var.offset;\n }\n \n /* Return nonzero if the error flag is set.  */\n-static inline int \n+/* We need to expose this function when compiling for gcov-tool.  */\n+#ifndef IN_GCOV_TOOL\n+static inline\n+#endif\n+int\n gcov_is_error (void)\n {\n   return gcov_var.file ? gcov_var.error : 1;\n@@ -557,11 +565,13 @@ gcov_read_counter (void)\n   return value;\n }\n \n+/* We need to expose the below function when compiling for gcov-tool.  */\n+\n+#if !IN_LIBGCOV || defined (IN_GCOV_TOOL)\n /* Read string from coverage file. Returns a pointer to a static\n    buffer, or NULL on empty string. You must copy the string before\n    calling another gcov function.  */\n \n-#if !IN_LIBGCOV\n GCOV_LINKAGE const char *\n gcov_read_string (void)\n {\n@@ -642,7 +652,9 @@ gcov_read_summary (struct gcov_summary *summary)\n     }\n }\n \n-#if !IN_LIBGCOV\n+/* We need to expose the below function when compiling for gcov-tool.  */\n+\n+#if !IN_LIBGCOV || defined (IN_GCOV_TOOL)\n /* Reset to a known position.  BASE should have been obtained from\n    gcov_position, LENGTH should be a record length.  */\n "}, {"sha": "16e6c71ad79bae20ac5860a15bb3b786040b1a9a", "filename": "gcc/gcov-io.h", "status": "modified", "additions": 18, "deletions": 39, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c77556a5d1e225024a4f9dafe5a1a6c316a86b83/gcc%2Fgcov-io.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c77556a5d1e225024a4f9dafe5a1a6c316a86b83/gcc%2Fgcov-io.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.h?ref=c77556a5d1e225024a4f9dafe5a1a6c316a86b83", "patch": "@@ -247,50 +247,29 @@ typedef uint64_t gcov_type_unsigned;\n \n \n /* Counters that are collected.  */\n-#define GCOV_COUNTER_ARCS \t0  /* Arc transitions.  */\n-#define GCOV_COUNTERS_SUMMABLE\t1  /* Counters which can be\n-\t\t\t\t      summaried.  */\n-#define GCOV_FIRST_VALUE_COUNTER 1 /* The first of counters used for value\n-\t\t\t\t      profiling.  They must form a consecutive\n-\t\t\t\t      interval and their order must match\n-\t\t\t\t      the order of HIST_TYPEs in\n-\t\t\t\t      value-prof.h.  */\n-#define GCOV_COUNTER_V_INTERVAL\t1  /* Histogram of value inside an interval.  */\n-#define GCOV_COUNTER_V_POW2\t2  /* Histogram of exact power2 logarithm\n-\t\t\t\t      of a value.  */\n-#define GCOV_COUNTER_V_SINGLE\t3  /* The most common value of expression.  */\n-#define GCOV_COUNTER_V_DELTA\t4  /* The most common difference between\n-\t\t\t\t      consecutive values of expression.  */\n-\n-#define GCOV_COUNTER_V_INDIR\t5  /* The most common indirect address */\n-#define GCOV_COUNTER_AVERAGE\t6  /* Compute average value passed to the\n-\t\t\t\t      counter.  */\n-#define GCOV_COUNTER_IOR\t7  /* IOR of the all values passed to\n-\t\t\t\t      counter.  */\n-#define GCOV_TIME_PROFILER  8 /* Time profile collecting first run of a function */\n-#define GCOV_LAST_VALUE_COUNTER 8  /* The last of counters used for value\n-\t\t\t\t      profiling.  */\n-#define GCOV_COUNTERS\t\t9\n+\n+#define DEF_GCOV_COUNTER(COUNTER, NAME, MERGE_FN) COUNTER,\n+enum {\n+#include \"gcov-counter.def\"\n+GCOV_COUNTERS\n+};\n+#undef DEF_GCOV_COUNTER\n+\n+/* Counters which can be summaried.  */\n+#define GCOV_COUNTERS_SUMMABLE\t(GCOV_COUNTER_ARCS + 1)\n+\n+/* The first of counters used for value profiling.  They must form a\n+   consecutive interval and their order must match the order of\n+   HIST_TYPEs in value-prof.h.  */\n+#define GCOV_FIRST_VALUE_COUNTER GCOV_COUNTERS_SUMMABLE\n+\n+/* The last of counters used for value profiling.  */\n+#define GCOV_LAST_VALUE_COUNTER (GCOV_COUNTERS - 1)\n \n /* Number of counters used for value profiling.  */\n #define GCOV_N_VALUE_COUNTERS \\\n   (GCOV_LAST_VALUE_COUNTER - GCOV_FIRST_VALUE_COUNTER + 1)\n \n-  /* A list of human readable names of the counters */\n-#define GCOV_COUNTER_NAMES\t{\"arcs\", \"interval\", \"pow2\", \"single\", \\\n-              \"delta\", \"indirect_call\", \"average\", \"ior\", \"time_profiler\"}\n-\n-  /* Names of merge functions for counters.  */\n-#define GCOV_MERGE_FUNCTIONS\t{\"__gcov_merge_add\",\t\\\n-\t\t\t\t \"__gcov_merge_add\",\t\\\n-\t\t\t\t \"__gcov_merge_add\",\t\\\n-\t\t\t\t \"__gcov_merge_single\",\t\\\n-\t\t\t\t \"__gcov_merge_delta\",  \\\n-\t\t\t\t \"__gcov_merge_single\", \\\n-\t\t\t\t \"__gcov_merge_add\",\t\\\n-\t\t\t\t \"__gcov_merge_ior\",  \\\n-         \"__gcov_merge_time_profile\" }\n-\n /* Convert a counter index to a tag.  */\n #define GCOV_TAG_FOR_COUNTER(COUNT)\t\t\t\t\\\n \t(GCOV_TAG_COUNTER_BASE + ((gcov_unsigned_t)(COUNT) << 17))"}, {"sha": "a83b797ee099e83e9e2ed11be44bda5ad66561af", "filename": "gcc/gcov-tool.c", "status": "added", "additions": 478, "deletions": 0, "changes": 478, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c77556a5d1e225024a4f9dafe5a1a6c316a86b83/gcc%2Fgcov-tool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c77556a5d1e225024a4f9dafe5a1a6c316a86b83/gcc%2Fgcov-tool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-tool.c?ref=c77556a5d1e225024a4f9dafe5a1a6c316a86b83", "patch": "@@ -0,0 +1,478 @@\n+/* Gcc offline profile processing tool support. */\n+/* Copyright (C) 2014 Free Software Foundation, Inc.\n+   Contributed by Rong Xu <xur@google.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"intl.h\"\n+#include \"diagnostic.h\"\n+#include \"version.h\"\n+#include \"gcov-io.h\"\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <sys/stat.h>\n+#include <unistd.h>\n+#include <ftw.h>\n+#include <getopt.h>\n+\n+extern int gcov_profile_merge (struct gcov_info*, struct gcov_info*, int, int);\n+extern int gcov_profile_normalize (struct gcov_info*, gcov_type);\n+extern int gcov_profile_scale (struct gcov_info*, float, int, int);\n+extern struct gcov_info* gcov_read_profile_dir (const char*, int);\n+extern void gcov_exit (void);\n+extern void set_gcov_list (struct gcov_info *);\n+extern void gcov_set_verbose (void);\n+\n+/* Set to verbose output mode.  */\n+static bool verbose;\n+\n+/* Remove file NAME if it has a gcda suffix. */\n+\n+static int\n+unlink_gcda_file (const char *name,\n+                  const struct stat *status ATTRIBUTE_UNUSED,\n+                  int type ATTRIBUTE_UNUSED,\n+                  struct FTW *ftwbuf ATTRIBUTE_UNUSED)\n+{\n+  int ret = 0;\n+  int len = strlen (name);\n+  int len1 = strlen (GCOV_DATA_SUFFIX);\n+\n+  if (len > len1 && !strncmp (len -len1 + name, GCOV_DATA_SUFFIX, len1))\n+    ret = remove (name);\n+\n+  if (ret)\n+    fatal_error (\"error in removing %s\\n\", name);\n+\n+  return ret;\n+}\n+\n+/* Remove the gcda files in PATH recursively.  */\n+\n+static int\n+unlink_profile_dir (const char *path)\n+{\n+    return nftw(path, unlink_gcda_file, 64, FTW_DEPTH | FTW_PHYS);\n+}\n+\n+/* Output GCOV_INFO lists PROFILE to directory OUT. Note that\n+   we will remove all the gcda files in OUT.  */\n+\n+static void\n+gcov_output_files (const char *out, struct gcov_info *profile)\n+{\n+  char *pwd;\n+  int ret;\n+\n+  /* Try to make directory if it doesn't already exist.  */\n+  if (access (out, F_OK) == -1)\n+    {\n+#ifdef TARGET_POSIX_IO\n+      if (mkdir (out, 0755) == -1 && errno != EEXIST)\n+#else\n+      if (mkdir (out) == -1 && errno != EEXIST)\n+#endif\n+        fatal_error (\"Cannot make directory %s\", out);\n+    } else\n+      unlink_profile_dir (out);\n+\n+  /* Output new profile.  */\n+  pwd = getcwd (NULL, 0);\n+\n+  if (pwd == NULL)\n+    fatal_error (\"Cannot get current directory name\");\n+\n+  ret = chdir (out);\n+  if (ret)\n+    fatal_error (\"Cannot change directory to %s\", out);\n+\n+  set_gcov_list (profile);\n+  gcov_exit ();\n+\n+  ret = chdir (pwd);\n+  if (ret)\n+    fatal_error (\"Cannot change directory to %s\", pwd);\n+\n+  free (pwd);\n+}\n+\n+/* Merging profile D1 and D2 with weight as W1 and W2, respectively.\n+   The result profile is written to directory OUT.\n+   Return 0 on success.  */\n+\n+static int\n+profile_merge (const char *d1, const char *d2, const char *out, int w1, int w2)\n+{\n+  struct gcov_info *d1_profile;\n+  struct gcov_info *d2_profile;\n+  int ret;\n+\n+  d1_profile = gcov_read_profile_dir (d1, 0);\n+  if (!d1_profile)\n+    return 1;\n+\n+  if (d2)\n+    {\n+      d2_profile = gcov_read_profile_dir (d2, 0);\n+      if (!d2_profile)\n+        return 1;\n+\n+      /* The actual merge: we overwrite to d1_profile.  */\n+      ret = gcov_profile_merge (d1_profile, d2_profile, w1, w2);\n+\n+      if (ret)\n+        return ret;\n+    }\n+\n+  gcov_output_files (out, d1_profile);\n+\n+  return 0;\n+}\n+\n+/* Usage message for profile merge.  */\n+\n+static void\n+print_merge_usage_message (int error_p)\n+{\n+  FILE *file = error_p ? stderr : stdout;\n+\n+  fnotice (file, \"  merge [options] <dir1> <dir2>         Merge coverage file contents\\n\");\n+  fnotice (file, \"    -v, --verbose                       Verbose mode\\n\");\n+  fnotice (file, \"    -o, --output <dir>                  Output directory\\n\");\n+  fnotice (file, \"    -w, --weight <w1,w2>                Set weights (float point values)\\n\");\n+}\n+\n+static const struct option merge_options[] =\n+{\n+  { \"verbose\",                no_argument,       NULL, 'v' },\n+  { \"output\",                 required_argument, NULL, 'o' },\n+  { \"weight\",                 required_argument, NULL, 'w' },\n+  { 0, 0, 0, 0 }\n+};\n+\n+/* Print merge usage and exit.  */\n+\n+static void\n+merge_usage (void)\n+{\n+  fnotice (stderr, \"Merge subcomand usage:\");\n+  print_merge_usage_message (true);\n+  exit (FATAL_EXIT_CODE);\n+}\n+\n+/* Driver for profile merge sub-command.  */\n+\n+static int\n+do_merge (int argc, char **argv)\n+{\n+  int opt;\n+  int ret;\n+  const char *output_dir = 0;\n+  int w1 = 1, w2 = 1;\n+\n+  optind = 0;\n+  while ((opt = getopt_long (argc, argv, \"vo:w:\", merge_options, NULL)) != -1)\n+    {\n+      switch (opt)\n+        {\n+        case 'v':\n+          verbose = true;\n+          gcov_set_verbose ();\n+          break;\n+        case 'o':\n+          output_dir = optarg;\n+          break;\n+        case 'w':\n+          sscanf (optarg, \"%d,%d\", &w1, &w2);\n+          if (w1 < 0 || w2 < 0)\n+            fatal_error (\"weights need to be non-negative\\n\");\n+          break;\n+        default:\n+          merge_usage ();\n+        }\n+    }\n+\n+  if (output_dir == NULL)\n+    output_dir = \"merged_profile\";\n+\n+  if (argc - optind == 2)\n+    ret = profile_merge (argv[optind], argv[optind+1], output_dir, w1, w2);\n+  else\n+    merge_usage ();\n+\n+  return ret;\n+}\n+\n+/* If N_VAL is no-zero, normalize the profile by setting the largest counter\n+   counter value to N_VAL and scale others counters proportionally.\n+   Otherwise, multiply the all counters by SCALE.  */\n+\n+static int\n+profile_rewrite (const char *d1, const char *out, long long n_val,\n+                 float scale, int n, int d)\n+{\n+  struct gcov_info * d1_profile;\n+\n+  d1_profile = gcov_read_profile_dir (d1, 0);\n+  if (!d1_profile)\n+    return 1;\n+\n+  if (n_val)\n+    gcov_profile_normalize (d1_profile, (gcov_type) n_val);\n+  else\n+    gcov_profile_scale (d1_profile, scale, n, d);\n+\n+  gcov_output_files (out, d1_profile);\n+  return 0;\n+}\n+\n+/* Usage function for profile rewrite.  */\n+\n+static void\n+print_rewrite_usage_message (int error_p)\n+{\n+  FILE *file = error_p ? stderr : stdout;\n+\n+  fnotice (file, \"  rewrite [options] <dir>               Rewrite coverage file contents\\n\");\n+  fnotice (file, \"    -v, --verbose                       Verbose mode\\n\");\n+  fnotice (file, \"    -o, --output <dir>                  Output directory\\n\");\n+  fnotice (file, \"    -s, --scale <float or simple-frac>  Scale the profile counters\\n\");\n+  fnotice (file, \"    -n, --normalize <long long>         Normalize the profile\\n\");\n+}\n+\n+static const struct option rewrite_options[] =\n+{\n+  { \"verbose\",                no_argument,       NULL, 'v' },\n+  { \"output\",                 required_argument, NULL, 'o' },\n+  { \"scale\",                  required_argument, NULL, 's' },\n+  { \"normalize\",              required_argument, NULL, 'n' },\n+  { 0, 0, 0, 0 }\n+};\n+\n+/* Print profile rewrite usage and exit.  */\n+\n+static void\n+rewrite_usage (void)\n+{\n+  fnotice (stderr, \"Rewrite subcommand usage:\");\n+  print_rewrite_usage_message (true);\n+  exit (FATAL_EXIT_CODE);\n+}\n+\n+/* Driver for profile rewrite sub-command. */\n+\n+static int\n+do_rewrite (int argc, char **argv)\n+{\n+  int opt;\n+  int ret;\n+  const char *output_dir = 0;\n+  long long normalize_val = 0;\n+  float scale = 0.0;\n+  int numerator = 1;\n+  int denominator = 1;\n+  int do_scaling = 0;\n+\n+  optind = 0;\n+  while ((opt = getopt_long (argc, argv, \"vo:s:n:\", rewrite_options, NULL)) != -1)\n+    {\n+      switch (opt)\n+        {\n+        case 'v':\n+          verbose = true;\n+          gcov_set_verbose ();\n+          break;\n+        case 'o':\n+          output_dir = optarg;\n+          break;\n+        case 'n':\n+          if (!do_scaling)\n+            normalize_val = atoll (optarg);\n+          else\n+            fnotice (stderr, \"scaling cannot co-exist with normalization,\"\n+                \" skipping\\n\");\n+          break;\n+        case 's':\n+          ret = 0;\n+          do_scaling = 1;\n+          if (strstr (optarg, \"/\"))\n+            {\n+              ret = sscanf (optarg, \"%d/%d\", &numerator, &denominator);\n+              if (ret == 2)\n+                {\n+                  if (numerator < 0 || denominator <= 0)\n+                    {\n+                      fnotice (stderr, \"incorrect format in scaling, using 1/1\\n\");\n+                      denominator = 1;\n+                      numerator = 1;\n+                    }\n+                }\n+            }\n+          if (ret != 2)\n+            {\n+              ret = sscanf (optarg, \"%f\", &scale);\n+              if (ret != 1)\n+                fnotice (stderr, \"incorrect format in scaling, using 1/1\\n\");\n+              else\n+                denominator = 0;\n+            }\n+\n+          if (scale < 0.0)\n+            fatal_error (\"scale needs to be non-negative\\n\");\n+\n+          if (normalize_val != 0)\n+            {\n+              fnotice (stderr, \"normalization cannot co-exist with scaling\\n\");\n+              normalize_val = 0;\n+            }\n+          break;\n+        default:\n+          rewrite_usage ();\n+        }\n+    }\n+\n+  if (output_dir == NULL)\n+    output_dir = \"rewrite_profile\";\n+\n+  if (argc - optind == 1)\n+    {\n+      if (denominator > 0)\n+        ret = profile_rewrite (argv[optind],  output_dir, 0, 0.0, numerator, denominator);\n+      else\n+        ret = profile_rewrite (argv[optind],  output_dir, normalize_val, scale, 0, 0);\n+    }\n+  else\n+    rewrite_usage ();\n+\n+  return ret;\n+}\n+\n+/* Print a usage message and exit.  If ERROR_P is nonzero, this is an error,\n+   otherwise the output of --help.  */\n+\n+static void\n+print_usage (int error_p)\n+{\n+  FILE *file = error_p ? stderr : stdout;\n+  int status = error_p ? FATAL_EXIT_CODE : SUCCESS_EXIT_CODE;\n+\n+  fnotice (file, \"Usage: %s [OPTION]... SUB_COMMAND [OPTION]...\\n\\n\", progname);\n+  fnotice (file, \"Offline tool to handle gcda counts\\n\\n\");\n+  fnotice (file, \"  -h, --help                            Print this help, then exit\\n\");\n+  fnotice (file, \"  -v, --version                         Print version number, then exit\\n\");\n+  print_merge_usage_message (error_p);\n+  print_rewrite_usage_message (error_p);\n+  fnotice (file, \"\\nFor bug reporting instructions, please see:\\n%s.\\n\",\n+           bug_report_url);\n+  exit (status);\n+}\n+\n+/* Print version information and exit.  */\n+\n+static void\n+print_version (void)\n+{\n+  fnotice (stdout, \"%s %s%s\\n\", progname, pkgversion_string, version_string);\n+  fnotice (stdout, \"Copyright %s 2014 Free Software Foundation, Inc.\\n\",\n+           _(\"(C)\"));\n+  fnotice (stdout,\n+           _(\"This is free software; see the source for copying conditions.\\n\"\n+             \"There is NO warranty; not even for MERCHANTABILITY or \\n\"\n+             \"FITNESS FOR A PARTICULAR PURPOSE.\\n\\n\"));\n+  exit (SUCCESS_EXIT_CODE);\n+}\n+\n+static const struct option options[] =\n+{\n+  { \"help\",                 no_argument,       NULL, 'h' },\n+  { \"version\",              no_argument,       NULL, 'v' },\n+  { 0, 0, 0, 0 }\n+};\n+\n+/* Process args, return index to first non-arg.  */\n+\n+static int\n+process_args (int argc, char **argv)\n+{\n+  int opt;\n+\n+  while ((opt = getopt_long (argc, argv, \"+hv\", options, NULL)) != -1)\n+    {\n+      switch (opt)\n+        {\n+        case 'h':\n+          print_usage (false);\n+          /* Print_usage will exit.  */\n+        case 'v':\n+          print_version ();\n+          /* Print_version will exit.  */\n+        default:\n+          print_usage (true);\n+          /* Print_usage will exit.  */\n+        }\n+    }\n+\n+  return optind;\n+}\n+\n+/* Main function for gcov-tool.  */\n+\n+int\n+main (int argc, char **argv)\n+{\n+  const char *p;\n+  const char *sub_command;\n+\n+  p = argv[0] + strlen (argv[0]);\n+  while (p != argv[0] && !IS_DIR_SEPARATOR (p[-1]))\n+    --p;\n+  progname = p;\n+\n+  xmalloc_set_program_name (progname);\n+\n+  /* Unlock the stdio streams.  */\n+  unlock_std_streams ();\n+\n+  gcc_init_libintl ();\n+\n+  diagnostic_initialize (global_dc, 0);\n+\n+  /* Handle response files.  */\n+  expandargv (&argc, &argv);\n+\n+  process_args (argc, argv);\n+  if (optind >= argc)\n+    print_usage (true);\n+\n+  sub_command = argv[optind];\n+\n+  if (!strcmp (sub_command, \"merge\"))\n+    return do_merge (argc - optind, argv + optind);\n+  else if (!strcmp (sub_command, \"rewrite\"))\n+    return do_rewrite (argc - optind, argv + optind);\n+\n+  print_usage (true);\n+}"}, {"sha": "759cd820b2b42e4f43d128853e2e06a841ce86d9", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c77556a5d1e225024a4f9dafe5a1a6c316a86b83/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c77556a5d1e225024a4f9dafe5a1a6c316a86b83/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=c77556a5d1e225024a4f9dafe5a1a6c316a86b83", "patch": "@@ -1,3 +1,50 @@\n+2014-07-10  Rong Xu  <xur@google.com>\n+\n+\tAdd gcov-tool: an offline gcda profile processing tool\n+\tSupport.\n+\t* libgcov-driver.c (gcov_max_filename): Make available\n+\tto gcov-tool.\n+\t* libgcov-merge.c (__gcov_merge_add): Replace\n+\tgcov_read_counter() with a Macro.\n+\t(__gcov_merge_ior): Ditto.\n+\t(__gcov_merge_time_profile): Ditto.\n+\t(__gcov_merge_single): Ditto.\n+\t(__gcov_merge_delta): Ditto.\n+\t* libgcov-util.c (void gcov_set_verbose): Set the verbose flag\n+\tin the utility functions.\n+\t(set_fn_ctrs): Utility function for reading gcda files to in-memory\n+\tgcov_list object link lists.\n+\t(tag_function): Ditto.\n+\t(tag_blocks): Ditto.\n+\t(tag_arcs): Ditto.\n+\t(tag_lines): Ditto.\n+\t(tag_counters): Ditto.\n+\t(tag_summary): Ditto.\n+\t(read_gcda_finalize): Ditto.\n+\t(read_gcda_file): Ditto.\n+\t(ftw_read_file): Ditto.\n+\t(read_profile_dir_init): Ditto.\n+\t(gcov_read_profile_dir): Ditto.\n+\t(gcov_read_counter_mem): Ditto.\n+\t(gcov_get_merge_weight): Ditto.\n+\t(merge_wrapper): A wrapper function that calls merging handler.\n+\t(gcov_merge): Merge two gcov_info objects with weights.\n+\t(find_match_gcov_info): Find the matched gcov_info in the list.\n+\t(gcov_profile_merge): Merge two gcov_info object lists.\n+\t(__gcov_add_counter_op): Process edge profile counter values.\n+\t(__gcov_ior_counter_op): Process IOR profile counter values.\n+\t(__gcov_delta_counter_op): Process delta profile counter values.\n+\t(__gcov_single_counter_op): Process single  profile counter values.\n+\t(fp_scale): Callback function for float-point scaling.\n+\t(int_scale): Callback function for integer fraction scaling. \n+\t(gcov_profile_scale): Scaling profile counters.\n+\t(gcov_profile_normalize): Normalize profile counters.\n+\t* libgcov.h: Add headers and functions for gcov-tool use.\n+\t(gcov_get_counter): New.\n+\t(gcov_get_counter_target): Ditto.\n+\t(struct gcov_info): Make the functions field mutable in gcov-tool\n+\tcompilation.\n+\n 2014-06-23  Kai Tietz  <ktietz@redhat.com>\n \n \tPR libgcc/61585"}, {"sha": "529f4de83bd01e5c41ff923aa4809e07c426f988", "filename": "libgcc/libgcov-driver.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c77556a5d1e225024a4f9dafe5a1a6c316a86b83/libgcc%2Flibgcov-driver.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c77556a5d1e225024a4f9dafe5a1a6c316a86b83/libgcc%2Flibgcov-driver.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Flibgcov-driver.c?ref=c77556a5d1e225024a4f9dafe5a1a6c316a86b83", "patch": "@@ -81,7 +81,11 @@ set_gcov_list (struct gcov_info *head)\n }\n \n /* Size of the longest file name. */\n-static size_t gcov_max_filename = 0;\n+/* We need to expose this static variable when compiling for gcov-tool.  */\n+#ifndef IN_GCOV_TOOL\n+static\n+#endif\n+size_t gcov_max_filename = 0;\n \n /* Flag when the profile has already been dumped via __gcov_dump().  */\n static int gcov_dump_complete;"}, {"sha": "f6eacd1f507cf220631ad4531c0ad490a8fa9e47", "filename": "libgcc/libgcov-merge.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c77556a5d1e225024a4f9dafe5a1a6c316a86b83/libgcc%2Flibgcov-merge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c77556a5d1e225024a4f9dafe5a1a6c316a86b83/libgcc%2Flibgcov-merge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Flibgcov-merge.c?ref=c77556a5d1e225024a4f9dafe5a1a6c316a86b83", "patch": "@@ -53,7 +53,7 @@ void\n __gcov_merge_add (gcov_type *counters, unsigned n_counters)\n {\n   for (; n_counters; counters++, n_counters--)\n-    *counters += gcov_read_counter ();\n+    *counters += gcov_get_counter ();\n }\n #endif /* L_gcov_merge_add */\n \n@@ -65,7 +65,7 @@ void\n __gcov_merge_ior (gcov_type *counters, unsigned n_counters)\n {\n   for (; n_counters; counters++, n_counters--)\n-    *counters |= gcov_read_counter ();\n+    *counters |= gcov_get_counter_target ();\n }\n #endif\n \n@@ -81,7 +81,7 @@ __gcov_merge_time_profile (gcov_type *counters, unsigned n_counters)\n \n   for (i = 0; i < n_counters; i++)\n     {\n-      value = gcov_read_counter ();\n+      value = gcov_get_counter_target ();\n \n       if (value && (!counters[i] || value < counters[i]))\n         counters[i] = value;\n@@ -109,9 +109,9 @@ __gcov_merge_single (gcov_type *counters, unsigned n_counters)\n   n_measures = n_counters / 3;\n   for (i = 0; i < n_measures; i++, counters += 3)\n     {\n-      value = gcov_read_counter ();\n-      counter = gcov_read_counter ();\n-      all = gcov_read_counter ();\n+      value = gcov_get_counter_target ();\n+      counter = gcov_get_counter ();\n+      all = gcov_get_counter ();\n \n       if (counters[0] == value)\n         counters[1] += counter;\n@@ -148,10 +148,10 @@ __gcov_merge_delta (gcov_type *counters, unsigned n_counters)\n   n_measures = n_counters / 4;\n   for (i = 0; i < n_measures; i++, counters += 4)\n     {\n-      /* last = */ gcov_read_counter ();\n-      value = gcov_read_counter ();\n-      counter = gcov_read_counter ();\n-      all = gcov_read_counter ();\n+      /* last = */ gcov_get_counter ();\n+      value = gcov_get_counter_target ();\n+      counter = gcov_get_counter ();\n+      all = gcov_get_counter ();\n \n       if (counters[1] == value)\n         counters[2] += counter;"}, {"sha": "6dddec59490b4022291600c01e53589262d81d67", "filename": "libgcc/libgcov-util.c", "status": "added", "additions": 870, "deletions": 0, "changes": 870, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c77556a5d1e225024a4f9dafe5a1a6c316a86b83/libgcc%2Flibgcov-util.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c77556a5d1e225024a4f9dafe5a1a6c316a86b83/libgcc%2Flibgcov-util.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Flibgcov-util.c?ref=c77556a5d1e225024a4f9dafe5a1a6c316a86b83", "patch": "@@ -0,0 +1,870 @@\n+/* Utility functions for reading gcda files into in-memory\n+   gcov_info structures and offline profile processing. */\n+/* Copyright (C) 2014 Free Software Foundation, Inc.\n+   Contributed by Rong Xu <xur@google.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+\n+#define IN_GCOV_TOOL 1\n+\n+#include \"libgcov.h\"\n+#include \"intl.h\"\n+#include \"diagnostic.h\"\n+#include \"version.h\"\n+#include \"demangle.h\"\n+\n+/* Borrowed from basic-block.h.  */\n+#define RDIV(X,Y) (((X) + (Y) / 2) / (Y))\n+\n+extern gcov_position_t gcov_position();\n+extern int gcov_is_error();\n+extern gcov_unsigned_t gcov_max_filename;\n+\n+/* Verbose mode for debug.  */\n+static int verbose;\n+\n+/* Set verbose flag.  */\n+void gcov_set_verbose (void)\n+{\n+  verbose = 1;\n+}\n+\n+/* The following part is to read Gcda and reconstruct GCOV_INFO.  */\n+\n+#include \"obstack.h\"\n+#include <unistd.h>\n+#include <ftw.h>\n+\n+static void tag_function (unsigned, unsigned);\n+static void tag_blocks (unsigned, unsigned);\n+static void tag_arcs (unsigned, unsigned);\n+static void tag_lines (unsigned, unsigned);\n+static void tag_counters (unsigned, unsigned);\n+static void tag_summary (unsigned, unsigned);\n+\n+/* The gcov_info for the first module.  */\n+static struct gcov_info *curr_gcov_info;\n+/* The gcov_info being processed.  */\n+static struct gcov_info *gcov_info_head;\n+/* This variable contains all the functions in current module.  */\n+static struct obstack fn_info;\n+/* The function being processed.  */\n+static struct gcov_fn_info *curr_fn_info;\n+/* The number of functions seen so far.  */\n+static unsigned num_fn_info;\n+/* This variable contains all the counters for current module.  */\n+static int k_ctrs_mask[GCOV_COUNTERS];\n+/* The kind of counters that have been seen.  */\n+static struct gcov_ctr_info k_ctrs[GCOV_COUNTERS];\n+/* Number of kind of counters that have been seen.  */\n+static int k_ctrs_types;\n+/* The longest length of all the filenames.  */\n+static int max_filename_len;\n+\n+/* Merge functions for counters.  */\n+#define DEF_GCOV_COUNTER(COUNTER, NAME, FN_TYPE) __gcov_merge ## FN_TYPE,\n+static gcov_merge_fn ctr_merge_functions[GCOV_COUNTERS] = {\n+#include \"gcov-counter.def\"\n+};\n+#undef DEF_GCOV_COUNTER\n+\n+/* Set the ctrs field in gcov_fn_info object FN_INFO.  */\n+\n+static void\n+set_fn_ctrs (struct gcov_fn_info *fn_info)\n+{\n+  int j = 0, i;\n+\n+  for (i = 0; i < GCOV_COUNTERS; i++)\n+    {\n+      if (k_ctrs_mask[i] == 0)\n+        continue;\n+      fn_info->ctrs[j].num = k_ctrs[i].num;\n+      fn_info->ctrs[j].values = k_ctrs[i].values;\n+      j++;\n+    }\n+  if (k_ctrs_types == 0)\n+    k_ctrs_types = j;\n+  else\n+    gcc_assert (j == k_ctrs_types);\n+}\n+\n+/* For each tag in gcda file, we have an entry here.\n+   TAG is the tag value; NAME is the tag name; and\n+   PROC is the handler function.  */\n+\n+typedef struct tag_format\n+{\n+    unsigned tag;\n+    char const *name;\n+    void (*proc) (unsigned, unsigned);\n+} tag_format_t;\n+\n+/* Handler table for various Tags.  */\n+\n+static const tag_format_t tag_table[] =\n+{\n+  {0, \"NOP\", NULL},\n+  {0, \"UNKNOWN\", NULL},\n+  {0, \"COUNTERS\", tag_counters},\n+  {GCOV_TAG_FUNCTION, \"FUNCTION\", tag_function},\n+  {GCOV_TAG_BLOCKS, \"BLOCKS\", tag_blocks},\n+  {GCOV_TAG_ARCS, \"ARCS\", tag_arcs},\n+  {GCOV_TAG_LINES, \"LINES\", tag_lines},\n+  {GCOV_TAG_OBJECT_SUMMARY, \"OBJECT_SUMMARY\", tag_summary},\n+  {GCOV_TAG_PROGRAM_SUMMARY, \"PROGRAM_SUMMARY\", tag_summary},\n+  {0, NULL, NULL}\n+};\n+\n+/* Handler for reading function tag.  */\n+\n+static void\n+tag_function (unsigned tag ATTRIBUTE_UNUSED, unsigned length ATTRIBUTE_UNUSED)\n+{\n+  int i;\n+\n+  /* write out previous fn_info.  */\n+  if (num_fn_info)\n+    {\n+      set_fn_ctrs (curr_fn_info);\n+      obstack_ptr_grow (&fn_info, curr_fn_info);\n+    }\n+\n+  /* Here we over allocate a bit, using GCOV_COUNTERS instead of the actual active\n+     counter types.  */\n+  curr_fn_info = (struct gcov_fn_info *) xcalloc (sizeof (struct gcov_fn_info)\n+                   + GCOV_COUNTERS * sizeof (struct gcov_ctr_info), 1);\n+\n+  for (i = 0; i < GCOV_COUNTERS; i++)\n+     k_ctrs[i].num = 0;\n+  k_ctrs_types = 0;\n+\n+  curr_fn_info->key = curr_gcov_info;\n+  curr_fn_info->ident = gcov_read_unsigned ();\n+  curr_fn_info->lineno_checksum = gcov_read_unsigned ();\n+  curr_fn_info->cfg_checksum = gcov_read_unsigned ();\n+  num_fn_info++;\n+\n+  if (verbose)\n+    fnotice (stdout, \"tag one function id=%d\\n\", curr_fn_info->ident);\n+}\n+\n+/* Handler for reading block tag.  */\n+\n+static void\n+tag_blocks (unsigned tag ATTRIBUTE_UNUSED, unsigned length ATTRIBUTE_UNUSED)\n+{\n+  /* TBD: gcov-tool currently does not handle gcno files. Assert here.  */\n+  gcc_unreachable ();\n+}\n+\n+/* Handler for reading flow arc tag.  */\n+\n+static void\n+tag_arcs (unsigned tag ATTRIBUTE_UNUSED, unsigned length ATTRIBUTE_UNUSED)\n+{\n+  /* TBD: gcov-tool currently does not handle gcno files. Assert here.  */\n+  gcc_unreachable ();\n+}\n+\n+/* Handler for reading line tag.  */\n+\n+static void\n+tag_lines (unsigned tag ATTRIBUTE_UNUSED, unsigned length ATTRIBUTE_UNUSED)\n+{\n+  /* TBD: gcov-tool currently does not handle gcno files. Assert here.  */\n+  gcc_unreachable ();\n+}\n+\n+/* Handler for reading counters array tag with value as TAG and length of LENGTH.  */\n+\n+static void\n+tag_counters (unsigned tag, unsigned length)\n+{\n+  unsigned n_counts = GCOV_TAG_COUNTER_NUM (length);\n+  gcov_type *values;\n+  unsigned ix;\n+  unsigned tag_ix;\n+\n+  tag_ix = GCOV_COUNTER_FOR_TAG (tag);\n+  gcc_assert (tag_ix < GCOV_COUNTERS);\n+  k_ctrs_mask [tag_ix] = 1;\n+  gcc_assert (k_ctrs[tag_ix].num == 0);\n+  k_ctrs[tag_ix].num = n_counts;\n+\n+  k_ctrs[tag_ix].values = values = (gcov_type *) xmalloc (n_counts * sizeof (gcov_type));\n+  gcc_assert (values);\n+\n+  for (ix = 0; ix != n_counts; ix++)\n+    values[ix] = gcov_read_counter ();\n+}\n+\n+/* Handler for reading summary tag.  */\n+\n+static void\n+tag_summary (unsigned tag ATTRIBUTE_UNUSED, unsigned length ATTRIBUTE_UNUSED)\n+{\n+  struct gcov_summary summary;\n+\n+  gcov_read_summary (&summary);\n+}\n+\n+/* This function is called at the end of reading a gcda file.\n+   It flushes the contents in curr_fn_info to gcov_info object OBJ_INFO.  */\n+\n+static void\n+read_gcda_finalize (struct gcov_info *obj_info)\n+{\n+  int i;\n+\n+  set_fn_ctrs (curr_fn_info);\n+  obstack_ptr_grow (&fn_info, curr_fn_info);\n+\n+  /* We set the following fields: merge, n_functions, and functions.  */\n+  obj_info->n_functions = num_fn_info;\n+  obj_info->functions = (const struct gcov_fn_info**) obstack_finish (&fn_info);\n+\n+  /* wrap all the counter array.  */\n+  for (i=0; i< GCOV_COUNTERS; i++)\n+    {\n+      if (k_ctrs_mask[i])\n+        obj_info->merge[i] = ctr_merge_functions[i];\n+    }\n+}\n+\n+/* Read the content of a gcda file FILENAME, and return a gcov_info data structure.\n+   Program level summary CURRENT_SUMMARY will also be updated.  */\n+\n+static struct gcov_info *\n+read_gcda_file (const char *filename)\n+{\n+  unsigned tags[4];\n+  unsigned depth = 0;\n+  unsigned magic, version;\n+  struct gcov_info *obj_info;\n+  int i;\n+\n+  for (i=0; i< GCOV_COUNTERS; i++)\n+    k_ctrs_mask[i] = 0;\n+  k_ctrs_types = 0;\n+\n+  if (!gcov_open (filename))\n+    {\n+      fnotice (stderr, \"%s:cannot open\\n\", filename);\n+      return NULL;\n+    }\n+\n+  /* Read magic.  */\n+  magic = gcov_read_unsigned ();\n+  if (magic != GCOV_DATA_MAGIC)\n+    {\n+      fnotice (stderr, \"%s:not a gcov data file\\n\", filename);\n+      gcov_close ();\n+      return NULL;\n+    }\n+\n+  /* Read version.  */\n+  version = gcov_read_unsigned ();\n+  if (version != GCOV_VERSION)\n+    {\n+      fnotice (stderr, \"%s:incorrect gcov version %d vs %d \\n\", filename, version, GCOV_VERSION);\n+      gcov_close ();\n+      return NULL;\n+    }\n+\n+  /* Instantiate a gcov_info object.  */\n+  curr_gcov_info = obj_info = (struct gcov_info *) xcalloc (sizeof (struct gcov_info) +\n+             sizeof (struct gcov_ctr_info) * GCOV_COUNTERS, 1);\n+\n+  obj_info->version = version;\n+  obstack_init (&fn_info);\n+  num_fn_info = 0;\n+  curr_fn_info = 0;\n+  {\n+    char *str_dup = (char*) xmalloc (strlen (filename) + 1);\n+    int len;\n+\n+    strcpy (str_dup, filename);\n+    obj_info->filename = str_dup;\n+    if ((len = strlen (filename)) > max_filename_len)\n+      max_filename_len = len;\n+  }\n+\n+  /* Read stamp.  */\n+  obj_info->stamp = gcov_read_unsigned ();\n+\n+  while (1)\n+    {\n+      gcov_position_t base;\n+      unsigned tag, length;\n+      tag_format_t const *format;\n+      unsigned tag_depth;\n+      int error;\n+      unsigned mask;\n+\n+      tag = gcov_read_unsigned ();\n+      if (!tag)\n+\tbreak;\n+      length = gcov_read_unsigned ();\n+      base = gcov_position ();\n+      mask = GCOV_TAG_MASK (tag) >> 1;\n+      for (tag_depth = 4; mask; mask >>= 8)\n+\t{\n+\t  if (((mask & 0xff) != 0xff))\n+\t    {\n+\t      warning (0, \"%s:tag `%x' is invalid\\n\", filename, tag);\n+\t      break;\n+\t    }\n+\t  tag_depth--;\n+\t}\n+      for (format = tag_table; format->name; format++)\n+\tif (format->tag == tag)\n+\t  goto found;\n+      format = &tag_table[GCOV_TAG_IS_COUNTER (tag) ? 2 : 1];\n+    found:;\n+      if (tag)\n+\t{\n+\t  if (depth && depth < tag_depth)\n+\t    {\n+\t      if (!GCOV_TAG_IS_SUBTAG (tags[depth - 1], tag))\n+\t\twarning (0, \"%s:tag `%x' is incorrectly nested\\n\",\n+\t\t\tfilename, tag);\n+\t    }\n+\t  depth = tag_depth;\n+\t  tags[depth - 1] = tag;\n+\t}\n+\n+      if (format->proc)\n+        {\n+\t  unsigned long actual_length;\n+\n+\t  (*format->proc) (tag, length);\n+\n+\t  actual_length = gcov_position () - base;\n+\t  if (actual_length > length)\n+\t    warning (0, \"%s:record size mismatch %lu bytes overread\\n\",\n+\t\t    filename, actual_length - length);\n+\t  else if (length > actual_length)\n+\t    warning (0, \"%s:record size mismatch %lu bytes unread\\n\",\n+\t\t    filename, length - actual_length);\n+\t}\n+\n+      gcov_sync (base, length);\n+      if ((error = gcov_is_error ()))\n+\t{\n+\t  warning (0, error < 0 ? \"%s:counter overflow at %lu\\n\" :\n+\t\t                  \"%s:read error at %lu\\n\", filename,\n+\t\t  (long unsigned) gcov_position ());\n+\t  break;\n+\t}\n+    }\n+\n+  read_gcda_finalize (obj_info);\n+  gcov_close ();\n+\n+  return obj_info;\n+}\n+\n+/* This will be called by ftw(). It opens and read a gcda file FILENAME.\n+   Return a non-zero value to stop the tree walk.  */\n+\n+static int\n+ftw_read_file (const char *filename,\n+               const struct stat *status ATTRIBUTE_UNUSED,\n+               int type)\n+{\n+  int filename_len;\n+  int suffix_len;\n+  struct gcov_info *obj_info;\n+\n+  /* Only read regular files.  */\n+  if (type != FTW_F)\n+    return 0;\n+\n+  filename_len = strlen (filename);\n+  suffix_len = strlen (GCOV_DATA_SUFFIX);\n+\n+  if (filename_len <= suffix_len)\n+    return 0;\n+\n+  if (strcmp(filename + filename_len - suffix_len, GCOV_DATA_SUFFIX))\n+    return 0;\n+\n+  if (verbose)\n+    fnotice (stderr, \"reading file: %s\\n\", filename);\n+\n+  obj_info = read_gcda_file (filename);\n+  if (!obj_info)\n+    return 0;\n+\n+  obj_info->next = gcov_info_head;\n+  gcov_info_head = obj_info;\n+\n+  return 0;\n+}\n+\n+/* Initializer for reading a profile dir.  */\n+\n+static inline void\n+read_profile_dir_init (void)\n+{\n+  gcov_info_head = 0;\n+}\n+\n+/* Driver for read a profile directory and convert into gcov_info list in memory.\n+   Return NULL on error,\n+   Return the head of gcov_info list on success.\n+   Note the file static variable GCOV_MAX_FILENAME is also set.  */\n+\n+struct gcov_info *\n+gcov_read_profile_dir (const char* dir_name, int recompute_summary ATTRIBUTE_UNUSED)\n+{\n+  char *pwd;\n+  int ret;\n+\n+  read_profile_dir_init ();\n+\n+  if (access (dir_name, R_OK) != 0)\n+    {\n+      fnotice (stderr, \"cannot access directory %s\\n\", dir_name);\n+      return NULL;\n+    }\n+  pwd = getcwd (NULL, 0);\n+  gcc_assert (pwd);\n+  ret = chdir (dir_name);\n+  if (ret !=0)\n+    {\n+      fnotice (stderr, \"%s is not a directory\\n\", dir_name);\n+      return NULL;\n+    }\n+  ftw (\".\", ftw_read_file, 50);\n+  ret = chdir (pwd);\n+  free (pwd);\n+\n+\n+  /* gcov_max_filename is defined in libgcov.c that records the\n+     max filename len. We need to set it here to allocate the\n+     array for dumping.  */\n+  gcov_max_filename = max_filename_len;\n+\n+  return gcov_info_head;;\n+}\n+\n+/* This part of the code is to merge profile counters. These\n+   variables are set in merge_wrapper and to be used by\n+   global function gcov_read_counter_mem() and gcov_get_merge_weight.  */\n+\n+/* We save the counter value address to this variable.  */\n+static gcov_type *gcov_value_buf;\n+\n+/* The number of counter values to be read by current merging.  */\n+static gcov_unsigned_t gcov_value_buf_size;\n+\n+/* The index of counter values being read.  */\n+static gcov_unsigned_t gcov_value_buf_pos;\n+\n+/* The weight of current merging.  */\n+static unsigned gcov_merge_weight;\n+\n+/* Read a counter value from gcov_value_buf array.  */\n+\n+gcov_type\n+gcov_read_counter_mem (void)\n+{\n+  gcov_type ret;\n+  gcc_assert (gcov_value_buf_pos < gcov_value_buf_size);\n+  ret = *(gcov_value_buf + gcov_value_buf_pos);\n+  ++gcov_value_buf_pos;\n+  return ret;\n+}\n+\n+/* Return the recorded merge weight.  */\n+\n+unsigned\n+gcov_get_merge_weight (void)\n+{\n+  return gcov_merge_weight;\n+}\n+\n+/* A wrapper function for merge functions. It sets up the\n+   value buffer and weights and then calls the merge function.  */\n+\n+static void\n+merge_wrapper (gcov_merge_fn f, gcov_type *v1, gcov_unsigned_t n,\n+               gcov_type *v2, unsigned w)\n+{\n+  gcov_value_buf = v2;\n+  gcov_value_buf_pos = 0;\n+  gcov_value_buf_size = n;\n+  gcov_merge_weight = w;\n+  (*f) (v1, n);\n+}\n+\n+/* Offline tool to manipulate profile data.\n+   This tool targets on matched profiles. But it has some tolerance on\n+   unmatched profiles.\n+   When merging p1 to p2 (p2 is the dst),\n+   * m.gcda in p1 but not in p2: append m.gcda to p2 with specified weight;\n+     emit warning\n+   * m.gcda in p2 but not in p1: keep m.gcda in p2 and multiply by\n+     specified weight; emit warning.\n+   * m.gcda in both p1 and p2:\n+   ** p1->m.gcda->f checksum matches p2->m.gcda->f: simple merge.\n+   ** p1->m.gcda->f checksum does not matches p2->m.gcda->f: keep\n+      p2->m.gcda->f and\n+      drop p1->m.gcda->f. A warning is emitted.  */\n+\n+/* Add INFO2's counter to INFO1, multiplying by weight W.  */\n+\n+static int\n+gcov_merge (struct gcov_info *info1, struct gcov_info *info2, int w)\n+{\n+  unsigned f_ix;\n+  unsigned n_functions = info1->n_functions;\n+  int has_mismatch = 0;\n+\n+  gcc_assert (info2->n_functions == n_functions);\n+  for (f_ix = 0; f_ix < n_functions; f_ix++)\n+    {\n+      unsigned t_ix;\n+      const struct gcov_fn_info *gfi_ptr1 = info1->functions[f_ix];\n+      const struct gcov_fn_info *gfi_ptr2 = info2->functions[f_ix];\n+      const struct gcov_ctr_info *ci_ptr1, *ci_ptr2;\n+\n+      if (!gfi_ptr1 || gfi_ptr1->key != info1)\n+        continue;\n+      if (!gfi_ptr2 || gfi_ptr2->key != info2)\n+        continue;\n+\n+      if (gfi_ptr1->cfg_checksum != gfi_ptr2->cfg_checksum)\n+        {\n+          fnotice (stderr, \"in %s, cfg_checksum mismatch, skipping\\n\",\n+                  info1->filename);\n+          has_mismatch = 1;\n+          continue;\n+        }\n+      ci_ptr1 = gfi_ptr1->ctrs;\n+      ci_ptr2 = gfi_ptr2->ctrs;\n+      for (t_ix = 0; t_ix != GCOV_COUNTERS; t_ix++)\n+        {\n+          gcov_merge_fn merge1 = info1->merge[t_ix];\n+          gcov_merge_fn merge2 = info2->merge[t_ix];\n+\n+          gcc_assert (merge1 == merge2);\n+          if (!merge1)\n+            continue;\n+          gcc_assert (ci_ptr1->num == ci_ptr2->num);\n+          merge_wrapper (merge1, ci_ptr1->values, ci_ptr1->num, ci_ptr2->values, w);\n+          ci_ptr1++;\n+          ci_ptr2++;\n+        }\n+    }\n+\n+  return has_mismatch;\n+}\n+\n+/* Find and return the match gcov_info object for INFO from ARRAY.\n+   SIZE is the length of ARRAY.\n+   Return NULL if there is no match.  */\n+\n+static struct gcov_info *\n+find_match_gcov_info (struct gcov_info **array, int size, struct gcov_info *info)\n+{\n+  struct gcov_info *gi_ptr;\n+  struct gcov_info *ret = NULL;\n+  int i;\n+\n+  for (i = 0; i < size; i++)\n+    {\n+      gi_ptr = array[i];\n+      if (gi_ptr == 0)\n+        continue;\n+      if (!strcmp (gi_ptr->filename, info->filename))\n+        {\n+          ret = gi_ptr;\n+          array[i] = 0;\n+          break;\n+        }\n+    }\n+\n+  if (ret && ret->n_functions != info->n_functions)\n+    {\n+      fnotice (stderr, \"mismatched profiles in %s (%d functions\"\n+                       \" vs %d functions)\\n\",\n+                       ret->filename,\n+                       ret->n_functions,\n+                       info->n_functions);\n+      ret = NULL;\n+    }\n+  return ret;\n+}\n+\n+/* Merge the list of gcov_info objects from SRC_PROFILE to TGT_PROFILE.\n+   Return 0 on success: without mismatch.\n+   Reutrn 1 on error.  */\n+\n+int\n+gcov_profile_merge (struct gcov_info *tgt_profile, struct gcov_info *src_profile,\n+                    int w1, int w2)\n+{\n+  struct gcov_info *gi_ptr;\n+  struct gcov_info **tgt_infos;\n+  struct gcov_info *tgt_tail;\n+  struct gcov_info **in_src_not_tgt;\n+  unsigned tgt_cnt = 0, src_cnt = 0;\n+  unsigned unmatch_info_cnt = 0;\n+  unsigned int i;\n+\n+  for (gi_ptr = tgt_profile; gi_ptr; gi_ptr = gi_ptr->next)\n+    tgt_cnt++;\n+  for (gi_ptr = src_profile; gi_ptr; gi_ptr = gi_ptr->next)\n+    src_cnt++;\n+  tgt_infos = (struct gcov_info **) xmalloc (sizeof (struct gcov_info *)\n+                 * tgt_cnt);\n+  gcc_assert (tgt_infos);\n+  in_src_not_tgt = (struct gcov_info **) xmalloc (sizeof (struct gcov_info *)\n+                     * src_cnt);\n+  gcc_assert (in_src_not_tgt);\n+\n+  for (gi_ptr = tgt_profile, i = 0; gi_ptr; gi_ptr = gi_ptr->next, i++)\n+    tgt_infos[i] = gi_ptr;\n+\n+  tgt_tail = tgt_infos[tgt_cnt - 1];\n+\n+  /* First pass on tgt_profile, we multiply w1 to all counters.  */\n+  if (w1 > 1)\n+    {\n+       for (i = 0; i < tgt_cnt; i++)\n+         gcov_merge (tgt_infos[i], tgt_infos[i], w1-1);\n+    }\n+\n+  /* Second pass, add src_profile to the tgt_profile.  */\n+  for (gi_ptr = src_profile; gi_ptr; gi_ptr = gi_ptr->next)\n+    {\n+      struct gcov_info *gi_ptr1;\n+\n+      gi_ptr1 = find_match_gcov_info (tgt_infos, tgt_cnt, gi_ptr);\n+      if (gi_ptr1 == NULL)\n+        {\n+          in_src_not_tgt[unmatch_info_cnt++] = gi_ptr;\n+          continue;\n+        }\n+      gcov_merge (gi_ptr1, gi_ptr, w2);\n+    }\n+\n+  /* For modules in src but not in tgt. We adjust the counter and append.  */\n+  for (i = 0; i < unmatch_info_cnt; i++)\n+    {\n+      gi_ptr = in_src_not_tgt[i];\n+      gcov_merge (gi_ptr, gi_ptr, w2 - 1);\n+      tgt_tail->next = gi_ptr;\n+      tgt_tail = gi_ptr;\n+    }\n+\n+  return 0;\n+}\n+\n+typedef gcov_type (*counter_op_fn) (gcov_type, void*, void*);\n+\n+/* Performing FN upon arc counters.  */\n+\n+static void\n+__gcov_add_counter_op (gcov_type *counters, unsigned n_counters,\n+                       counter_op_fn fn, void *data1, void *data2)\n+{\n+  for (; n_counters; counters++, n_counters--)\n+    {\n+      gcov_type val = *counters;\n+      *counters = fn(val, data1, data2);\n+    }\n+}\n+\n+/* Performing FN upon ior counters.  */\n+\n+static void\n+__gcov_ior_counter_op (gcov_type *counters ATTRIBUTE_UNUSED,\n+                       unsigned n_counters ATTRIBUTE_UNUSED,\n+                       counter_op_fn fn ATTRIBUTE_UNUSED,\n+                       void *data1 ATTRIBUTE_UNUSED,\n+                       void *data2 ATTRIBUTE_UNUSED)\n+{\n+  /* Do nothing.  */\n+}\n+\n+/* Performing FN upon time-profile counters.  */\n+\n+static void\n+__gcov_time_profile_counter_op (gcov_type *counters ATTRIBUTE_UNUSED,\n+                                unsigned n_counters ATTRIBUTE_UNUSED,\n+                                counter_op_fn fn ATTRIBUTE_UNUSED,\n+                                void *data1 ATTRIBUTE_UNUSED,\n+                                void *data2 ATTRIBUTE_UNUSED)\n+{\n+  /* Do nothing.  */\n+}\n+\n+/* Performaing FN upon delta counters.  */\n+\n+static void\n+__gcov_delta_counter_op (gcov_type *counters, unsigned n_counters,\n+                         counter_op_fn fn, void *data1, void *data2)\n+{\n+  unsigned i, n_measures;\n+\n+  gcc_assert (!(n_counters % 4));\n+  n_measures = n_counters / 4;\n+  for (i = 0; i < n_measures; i++, counters += 4)\n+    {\n+      counters[2] = fn (counters[2], data1, data2);\n+      counters[3] = fn (counters[3], data1, data2);\n+    }\n+}\n+\n+/* Performing FN upon single counters.  */\n+\n+static void\n+__gcov_single_counter_op (gcov_type *counters, unsigned n_counters,\n+                          counter_op_fn fn, void *data1, void *data2)\n+{\n+  unsigned i, n_measures;\n+\n+  gcc_assert (!(n_counters % 3));\n+  n_measures = n_counters / 3;\n+  for (i = 0; i < n_measures; i++, counters += 3)\n+    {\n+      counters[1] = fn (counters[1], data1, data2);\n+      counters[2] = fn (counters[2], data1, data2);\n+    }\n+}\n+\n+/* Scaling the counter value V by multiplying *(float*) DATA1.  */\n+\n+static gcov_type\n+fp_scale (gcov_type v, void *data1, void *data2 ATTRIBUTE_UNUSED)\n+{\n+  float f = *(float *) data1;\n+  return (gcov_type) (v * f);\n+}\n+\n+/* Scaling the counter value V by multiplying DATA2/DATA1.  */\n+\n+static gcov_type\n+int_scale (gcov_type v, void *data1, void *data2)\n+{\n+  int n = *(int *) data1;\n+  int d = *(int *) data2;\n+  return (gcov_type) ( RDIV (v,d) * n);\n+}\n+\n+/* Type of function used to process counters.  */\n+typedef void (*gcov_counter_fn) (gcov_type *, gcov_unsigned_t,\n+                          counter_op_fn, void *, void *);\n+\n+/* Function array to process profile counters.  */\n+#define DEF_GCOV_COUNTER(COUNTER, NAME, FN_TYPE) \\\n+  __gcov ## FN_TYPE ## _counter_op,\n+static gcov_counter_fn ctr_functions[GCOV_COUNTERS] = {\n+#include \"gcov-counter.def\"\n+};\n+#undef DEF_GCOV_COUNTER\n+\n+/* Driver for scaling profile counters.  */\n+\n+int\n+gcov_profile_scale (struct gcov_info *profile, float scale_factor, int n, int d)\n+{\n+  struct gcov_info *gi_ptr;\n+  unsigned f_ix;\n+\n+  if (verbose)\n+    fnotice (stdout, \"scale_factor is %f or %d/%d\\n\", scale_factor, n, d);\n+\n+  /* Scaling the counters.  */\n+  for (gi_ptr = profile; gi_ptr; gi_ptr = gi_ptr->next)\n+    for (f_ix = 0; f_ix < gi_ptr->n_functions; f_ix++)\n+      {\n+        unsigned t_ix;\n+        const struct gcov_fn_info *gfi_ptr = gi_ptr->functions[f_ix];\n+        const struct gcov_ctr_info *ci_ptr;\n+\n+        if (!gfi_ptr || gfi_ptr->key != gi_ptr)\n+          continue;\n+\n+        ci_ptr = gfi_ptr->ctrs;\n+        for (t_ix = 0; t_ix != GCOV_COUNTERS; t_ix++)\n+          {\n+            gcov_merge_fn merge = gi_ptr->merge[t_ix];\n+\n+            if (!merge)\n+              continue;\n+            if (d == 0)\n+              (*ctr_functions[t_ix]) (ci_ptr->values, ci_ptr->num,\n+                                      fp_scale, &scale_factor, NULL);\n+            else\n+              (*ctr_functions[t_ix]) (ci_ptr->values, ci_ptr->num,\n+                                      int_scale, &n, &d);\n+            ci_ptr++;\n+          }\n+      }\n+\n+  return 0;\n+}\n+\n+/* Driver to normalize profile counters.  */\n+\n+int\n+gcov_profile_normalize (struct gcov_info *profile, gcov_type max_val)\n+{\n+  struct gcov_info *gi_ptr;\n+  gcov_type curr_max_val = 0;\n+  unsigned f_ix;\n+  unsigned int i;\n+  float scale_factor;\n+\n+  /* Find the largest count value.  */\n+  for (gi_ptr = profile; gi_ptr; gi_ptr = gi_ptr->next)\n+    for (f_ix = 0; f_ix < gi_ptr->n_functions; f_ix++)\n+      {\n+        unsigned t_ix;\n+        const struct gcov_fn_info *gfi_ptr = gi_ptr->functions[f_ix];\n+        const struct gcov_ctr_info *ci_ptr;\n+\n+        if (!gfi_ptr || gfi_ptr->key != gi_ptr)\n+          continue;\n+\n+        ci_ptr = gfi_ptr->ctrs;\n+        for (t_ix = 0; t_ix < 1; t_ix++)\n+          {\n+            for (i = 0; i < ci_ptr->num; i++)\n+              if (ci_ptr->values[i] > curr_max_val)\n+                curr_max_val = ci_ptr->values[i];\n+            ci_ptr++;\n+          }\n+      }\n+\n+  scale_factor = (float)max_val / curr_max_val;\n+  if (verbose)\n+    fnotice (stdout, \"max_val is %lld\\n\", (long long) curr_max_val);\n+\n+  return gcov_profile_scale (profile, scale_factor, 0, 0);\n+}"}, {"sha": "d9a3af73a4d88cfde03a342b8c84484e54433d22", "filename": "libgcc/libgcov.h", "status": "modified", "additions": 87, "deletions": 1, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c77556a5d1e225024a4f9dafe5a1a6c316a86b83/libgcc%2Flibgcov.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c77556a5d1e225024a4f9dafe5a1a6c316a86b83/libgcc%2Flibgcov.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Flibgcov.h?ref=c77556a5d1e225024a4f9dafe5a1a6c316a86b83", "patch": "@@ -33,6 +33,10 @@\n #define xcalloc calloc\n #endif\n \n+#ifndef IN_GCOV_TOOL\n+/* About the target.  */\n+/* This path will be used by libgcov runtime.  */\n+\n #include \"tconfig.h\"\n #include \"tsystem.h\"\n #include \"coretypes.h\"\n@@ -79,6 +83,43 @@ typedef unsigned gcov_type_unsigned __attribute__ ((mode (QI)));\n #define GCOV_LOCKED 0\n #endif\n \n+#else /* IN_GCOV_TOOL */\n+/* About the host.  */\n+/* This path will be compiled for the host and linked into\n+   gcov-tool binary.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+\n+typedef unsigned gcov_unsigned_t;\n+typedef unsigned gcov_position_t;\n+/* gcov_type is typedef'd elsewhere for the compiler */\n+#if defined (HOST_HAS_F_SETLKW)\n+#define GCOV_LOCKED 1\n+#else\n+#define GCOV_LOCKED 0\n+#endif\n+\n+/* Some Macros specific to gcov-tool.  */\n+\n+#define L_gcov 1\n+#define L_gcov_merge_add 1\n+#define L_gcov_merge_single 1\n+#define L_gcov_merge_delta 1\n+#define L_gcov_merge_ior 1\n+#define L_gcov_merge_time_profile 1\n+\n+/* Make certian internal functions/variables in libgcov available for\n+   gcov-tool access.  */\n+#define GCOV_TOOL_LINKAGE \n+\n+extern gcov_type gcov_read_counter_mem ();\n+extern unsigned gcov_get_merge_weight ();\n+\n+#endif /* !IN_GCOV_TOOL */\n+\n #if defined(inhibit_libc)\n #define IN_LIBGCOV (-1)\n #else\n@@ -159,8 +200,13 @@ struct gcov_info\n \t\t\t\t\t  unused) */\n   \n   unsigned n_functions;\t\t/* number of functions */\n+\n+#ifndef IN_GCOV_TOOL\n   const struct gcov_fn_info *const *functions; /* pointer to pointers\n-\t\t\t\t\t          to function information  */\n+                                                  to function information  */\n+#else\n+  const struct gcov_fn_info **functions;\n+#endif /* !IN_GCOV_TOOL */\n };\n \n /* Register a new object file module.  */\n@@ -224,6 +270,46 @@ GCOV_LINKAGE void gcov_write_summary (gcov_unsigned_t /*tag*/,\n GCOV_LINKAGE void gcov_seek (gcov_position_t /*position*/) ATTRIBUTE_HIDDEN;\n GCOV_LINKAGE inline void gcov_rewrite (void);\n \n+/* \"Counts\" stored in gcda files can be a real counter value, or\n+   an target address. When differentiate these two types because\n+   when manipulating counts, we should only change real counter values,\n+   rather target addresses.  */\n+\n+static inline gcov_type\n+gcov_get_counter (void)\n+{\n+#ifndef IN_GCOV_TOOL\n+  /* This version is for reading count values in libgcov runtime:\n+     we read from gcda files.  */\n+\n+  return gcov_read_counter ();\n+#else\n+  /* This version is for gcov-tool. We read the value from memory and\n+     multiply it by the merge weight.  */\n+\n+  return gcov_read_counter_mem () * gcov_get_merge_weight ();\n+#endif\n+}\n+\n+/* Similar function as gcov_get_counter(), but handles target address\n+   counters.  */\n+\n+static inline gcov_type\n+gcov_get_counter_target (void)\n+{\n+#ifndef IN_GCOV_TOOL\n+  /* This version is for reading count target values in libgcov runtime:\n+     we read from gcda files.  */\n+\n+  return gcov_read_counter ();\n+#else\n+  /* This version is for gcov-tool.  We read the value from memory and we do NOT\n+     multiply it by the merge weight.  */\n+\n+  return gcov_read_counter_mem ();\n+#endif\n+}\n+\n #endif /* !inhibit_libc */\n \n #endif /* GCC_LIBGCOV_H */"}]}