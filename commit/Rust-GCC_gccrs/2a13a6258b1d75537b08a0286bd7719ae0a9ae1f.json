{"sha": "2a13a6258b1d75537b08a0286bd7719ae0a9ae1f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmExM2E2MjU4YjFkNzU1MzdiMDhhMDI4NmJkNzcxOWFlMGE5YWUxZg==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@integrable-solutions.net", "date": "2004-10-05T13:28:07Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2004-10-05T13:28:07Z"}, "message": "Convert diagnostics to use quoting flag q 4/n\n\n        Convert diagnostics to use quoting flag q 4/n\n        * parser.c (cp_parser_name_lookup_error,\n        cp_parser_diagnose_invalid_type_name,\n        cp_parser_primary_expression, cp_parser_unqualified_id,\n        cp_parser_nested_name_specifier_opt,\n        cp_parser_labeled_statement,\n        cp_parser_jump_statement, cp_parser_simple_declaration,\n        cp_parser_decl_specifier_seq, cp_parser_mem_initializer_id,\n        cp_parser_type_parameter, cp_parser_template_id,\n        cp_parser_template_name, cp_parser_direct_declarator,\n        cp_parser_parameter_declaration_list, cp_parser_class_head,\n        cp_parser_base_specifier, cp_parser_lookup_name,\n        cp_parser_late_parsing_default_args,\n        cp_parser_optional_template_keyword\n        cp_parser_elaborated_type_specifier,\n        cp_parser_check_class_key,\n        cp_parser_check_access_in_redeclaration): Use quoting marks.\n\n        * name-lookup.c (supplement_binding, pushdecl,\n        check_for_out_of_scope_variable,\n        validate_nonmember_using_decl,\n        do_nonmember_using_decl, lookup_tag, set_decl_namespace,\n        push_namespace, do_namespace_alias, do_using_directive,\n        ambiguous_decl, lookup_namespace_name, add_function):\n        Likewise.\n\n        * method.c (use_thunk): Likewise.\n\n        * lex.c (unqualified_name_lookup_error,\n        unqualified_fn_lookup_error): Likewise.\n\ntestsuite/\nmerlin[1:17]% cd build\n~\nmerlin[1:17]% ls\n~/build\n3  4  4.0.0  c++0x  r  tree\nmerlin[1:17]% cd 4.0.0\n~/build\nmerlin[1:17]% cd gcc\n~/build/4.0.0\nmerlin[1:17]% make check-g++\n~/build/4.0.0/gcc\n(rootme=`${PWDCMD-pwd}`; export rootme; \\\nsrcdir=`cd /home/gdr/redhat/egcs/gcc; ${PWDCMD-pwd}` ; export srcdir ;\n\\\ncd testsuite; \\\nEXPECT=`if [ -f ${rootme}/../expect/expect ] ; then echo\n${rootme}/../expect/expect ; else echo expect ; fi` ; export EXPECT ;\n\\\nif [ -f ${rootme}/../expect/expect ] ; then  \\\n   TCL_LIBRARY=`cd .. ; cd /home/gdr/redhat/egcs/gcc/../tcl/library ;\n   ${PWDCMD-pwd}` ; \\\n    export TCL_LIBRARY ; fi ; \\\n`if [ -f ${srcdir}/../dejagnu/runtest ] ; then echo\n${srcdir}/../dejagnu/runtest ; else echo runtest; fi` --tool g++ )\nTest Run By gdr on Tue Oct  5 01:18:04 2004\nNative configuration is i686-pc-linux-gnu\n\n                === g++ tests ===\n\nSchedule of variations:\n    unix\n\nRunning target unix\nUsing /usr/share/dejagnu/baseboards/unix.exp as board description file\nfor target.\nUsing /usr/share/dejagnu/config/unix.exp as generic interface file for\ntarget.\nUsing /home/gdr/redhat/egcs/gcc/testsuite/config/default.exp as\ntool-and-target-specific interface file.\nRunning /home/gdr/redhat/egcs/gcc/testsuite/g++.dg/bprob/bprob.exp ...\nRunning /home/gdr/redhat/egcs/gcc/testsuite/g++.dg/charset/charset.exp\n...Running /home/gdr/redhat/egcs/gcc/testsuite/g++.dg/compat/compat.exp\n...Running /home/gdr/redhat/egcs/gcc/testsuite/g++.dg/debug/debug.exp ...\nRunning /home/gdr/redhat/egcs/gcc/testsuite/g++.dg/dg.exp ...\nFAIL: g++.dg/other/classkey1.C  (test for errors, line 9)\nFAIL: g++.dg/other/classkey1.C  (test for errors, line 11)\nFAIL: g++.dg/other/classkey1.C  (test for errors, line 14)\nFAIL: g++.dg/other/classkey1.C  (test for errors, line 17)\nFAIL: g++.dg/other/classkey1.C (test for excess errors)\nFAIL: g++.dg/parse/error15.C  (test for errors, line 13)\nFAIL: g++.dg/parse/error15.C  (test for errors, line 14)\nFAIL: g++.dg/parse/error15.C  (test for errors, line 15)\nFAIL: g++.dg/parse/error15.C  (test for errors, line 21)\nFAIL: g++.dg/parse/error15.C  (test for errors, line 22)\nFAIL: g++.dg/parse/error15.C  (test for errors, line 23)\nFAIL: g++.dg/parse/error15.C  (test for errors, line 31)\nFAIL: g++.dg/parse/error15.C  (test for errors, line 32)\nFAIL: g++.dg/parse/error15.C  (test for errors, line 33)\nFAIL: g++.dg/parse/error15.C (test for excess errors)\nXPASS: g++.dg/rtti/tinfo1.C scan-assembler _ZTIP9CTemplateIhE:\nXPASS: g++.dg/rtti/tinfo1.C scan-assembler-not .globl[\n\\t]+_ZTIP9CTemplateIhE\nXPASS: g++.dg/rtti/tinfo1.C scan-assembler-not\n.section[^\\n\\r]*_ZTIP9CTemplateIhE[^\\n\\r]*FAIL: g++.dg/template/meminit2.C  (test for errors, line 10)\nFAIL: g++.dg/template/meminit2.C  (test for errors, line 11)\nFAIL: g++.dg/template/meminit2.C (test for excess errors)\nRunning /home/gdr/redhat/egcs/gcc/testsuite/g++.dg/gcov/gcov.exp ...\nFAIL: 102:is -:should be 1\nFAIL: g++.dg/gcov/gcov-1.C gcov: 1 failures in line counts, 0 in\nbranch percentamerlin[1:27]% make check-g++\n~/build/4.0.0/gcc\n(rootme=`${PWDCMD-pwd}`; export rootme; \\\nsrcdir=`cd /home/gdr/redhat/egcs/gcc; ${PWDCMD-pwd}` ; export srcdir ;\n\\\ncd testsuite; \\\nEXPECT=`if [ -f ${rootme}/../expect/expect ] ; then echo\n${rootme}/../expect/expect ; else echo expect ; fi` ; export EXPECT ;\n\\\nif [ -f ${rootme}/../expect/expect ] ; then  \\\n   TCL_LIBRARY=`cd .. ; cd /home/gdr/redhat/egcs/gcc/../tcl/library ;\n   ${PWDCMD-pwd}` ; \\\n    export TCL_LIBRARY ; fi ; \\\n`if [ -f ${srcdir}/../dejagnu/runtest ] ; then echo\n${srcdir}/../dejagnu/runtest ; else echo runtest; fi` --tool g++ )\nTest Run By gdr on Tue Oct  5 01:27:39 2004\nNative configuration is i686-pc-linux-gnu\n\n                === g++ tests ===\n\nSchedule of variations:\n    unix\n\nRunning target unix\nUsing /usr/share/dejagnu/baseboards/unix.exp as board description file\nfor target.\nUsing /usr/share/dejagnu/config/unix.exp as generic interface file for\ntar       method.c\ncfns.gperf           cxx-pretty-print.c  method.c.~1.315.~\ncfns.h               cxx-pretty-print.h  name-lookup.c\nChangeLog            decl2.c             name-lookup.c.~1.85.~\nChangeLog.1          decl.c              name-lookup.h\nChangeLog.~1.4404.~  decl.h              NEWS\nChangeLog.2          dump.c              operators.def\nChangeLog.3          error.c             optimize.c\nChangeLog.egcs       except.c            parser.c\nChangeLog.tree-ssa   expr.c              parser.c.~1.258.~\nclass.c              friend.c            pt.c\nconfig-lang.in       g++spec.c           ptree.c\ncp-gimplify.c        init.c              repo.c\ncp-lang.c            init.c.~1.396.~     rtti.c\ncp-objcp-common.c    lang-specs.h        search.c\ncp-objcp-common.h    lex.c               semantics.c\ncp-tree.def          lex.c.~1.349.~      tree.c\ncp-tree.h            Make-lang.in        typeck2.c\nCVS                  mangle.c            typeck.c\nmerlin[7:37]% cvs -z9 diff -p > ~/d-5.patch\n~/redhat/egcs/gcc/cp\nEnter passphrase for RSA key '/home/gdr/.ssh/identity': cvs [diff\naborted]: received interrupt signal\n\nmerlin[7:37]% cvs -z9 diff -p > ~/d-5.patch\n~/redhat/egcs/gcc/cp\nWarning: Remote host denied X11 forwarding.\nWarning: Remote host denied authentication agent forwarding.\ncvs diff: Diffing .\nmerlin[7:38]% l ~/d-5.patch\n~/redhat/egcs/gcc/cp\nmerlin[7:39]% cvs -z9 diff -p > ~/d-5.patch\n~/redhat/egcs/gcc/cp\nWarning: Remote host denied X11 forwarding.\nWarning: Remote host denied authentication agent forwarding.\ncvs diff: Diffing .\nmerlin[7:40]% l ~/d-5.patch\n~/redhat/egcs/gcc/cp\nYou have new mail.\nmerlin[8:21]% cvs -z9 commit\n~/redhat/egcs/gcc/cp\nmerlin[8:21]% cd .\n~/redhat/egcs/gcc/cp\nmerlin[8:21]% cvs -z9 commit cp testsuite\n~/redhat/egcs/gcc/cp\ncvs commit: nothing known about `cp'\ncvs commit: nothing known about `testsuite'\ncvs [commit aborted]: correct above errors first!\nmerlin[8:21]% cd ..\n~/redhat/egcs/gcc/cp\nmerlin[8:21]% cvs -z9 commit cp testsuite\n~/redhat/egcs/gcc\ncvs commit: Examining cp\ncvs commit: Examining testsuite\ncvs commit: Examining testsuite/ada\ncvs commit: Examining testsuite/ada/acats\ncvs commit: Examining testsuite/ada/acats/support\ncvs commit: Examining testsuite/ada/acats/tests\ncvs commit: Examining testsuite/ada/acats/tests/a\ncvs commit: Examining testsuite/ada/acats/tests/c2\ncvs commit: Examining testsuite/ada/acats/tests/c3\ncvs commit: Examining testsuite/ada/acats/tests/c4\ncvs commit: Examining testsuite/ada/acats/tests/c5\ncvs commit: Examining testsuite/ada/acats/tests/c6\ncvs commit: Examining testsuite/ada/acats/tests/c7\ncvs commit: Examining testsuite/ada/acats/tests/c8\ncvs commit: Examining testsuite/ada/acats/tests/c9\ncvs commit: Examining testsuite/ada/acats/tests/ca\ncvs commit: Examining testsuite/ada/acats/tests/cb\ncvs commit: Examining testsuite/ada/acats/tests/cc\ncvs commit: Examining testsuite/ada/acats/tests/cd\ncvs commit: Examining testsuite/ada/acats/tests/ce\ncvs commit: Examining testsuite/ada/acats/tests/cxa\ncvs commit: Examining testsuite/ada/acats/tests/cxb\ncvs commit: Examining testsuite/ada/acats/tests/cxf\ncvs commit: Examining testsuite/ada/acats/tests/cxg\ncvs commit: Examining testsuite/ada/acats/tests/cxh\ncvs commit: Examining testsuite/ada/acats/tests/cz\ncvs commit: Examining testsuite/ada/acats/tests/d\ncvs commit: Examining testsuite/ada/acats/tests/e\ncvs commit: Examining testsuite/ada/acats/tests/gcc\ncvs commit: Examining testsuite/ada/acats/tests/l\ncvs commit: Examining testsuite/config\ncvs commit: Examining testsuite/consistency.vlad\ncvs commit: Examining testsuite/consistency.vlad/layout\ncvs commit: Examining\ntestsuite/consistency.vlad/layout/i960-97r2-results\ncvs commit: Examining testsuite/g++.dg\ncvs commit: Examining testsuite/g++.dg/abi\ncvs commit: Examining testsuite/g++.dg/bprob\ncvs commit: Examining testsuite/g++.dg/charset\ncvs commit: Examining testsuite/g++.dg/compat\ncvs commit: Examining testsuite/g++.dg/compat/abi\ncvs commit: Examinin\n\nFrom-SVN: r88552", "tree": {"sha": "1d5a02a0305c6e15310c3848fd5e80ee697de971", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d5a02a0305c6e15310c3848fd5e80ee697de971"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2a13a6258b1d75537b08a0286bd7719ae0a9ae1f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a13a6258b1d75537b08a0286bd7719ae0a9ae1f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a13a6258b1d75537b08a0286bd7719ae0a9ae1f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a13a6258b1d75537b08a0286bd7719ae0a9ae1f/comments", "author": {"login": "cxx-undef", "id": 5528103, "node_id": "MDQ6VXNlcjU1MjgxMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/5528103?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cxx-undef", "html_url": "https://github.com/cxx-undef", "followers_url": "https://api.github.com/users/cxx-undef/followers", "following_url": "https://api.github.com/users/cxx-undef/following{/other_user}", "gists_url": "https://api.github.com/users/cxx-undef/gists{/gist_id}", "starred_url": "https://api.github.com/users/cxx-undef/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cxx-undef/subscriptions", "organizations_url": "https://api.github.com/users/cxx-undef/orgs", "repos_url": "https://api.github.com/users/cxx-undef/repos", "events_url": "https://api.github.com/users/cxx-undef/events{/privacy}", "received_events_url": "https://api.github.com/users/cxx-undef/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c4ad648e16b7bec945bf959a14ad4259a7aec81c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4ad648e16b7bec945bf959a14ad4259a7aec81c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4ad648e16b7bec945bf959a14ad4259a7aec81c"}], "stats": {"total": 312, "additions": 174, "deletions": 138}, "files": [{"sha": "dc21cf718a457076d2d07be577bea0c02ee744c4", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a13a6258b1d75537b08a0286bd7719ae0a9ae1f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a13a6258b1d75537b08a0286bd7719ae0a9ae1f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=2a13a6258b1d75537b08a0286bd7719ae0a9ae1f", "patch": "@@ -1,3 +1,32 @@\n+2004-10-04  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n+\n+\tConvert diagnostics to use quoting flag q 4/n\n+\t* parser.c (cp_parser_name_lookup_error, \n+\tcp_parser_diagnose_invalid_type_name, \n+\tcp_parser_primary_expression, cp_parser_unqualified_id, \n+\tcp_parser_nested_name_specifier_opt, cp_parser_labeled_statement, \n+\tcp_parser_jump_statement, cp_parser_simple_declaration, \n+\tcp_parser_decl_specifier_seq, cp_parser_mem_initializer_id, \n+\tcp_parser_type_parameter, cp_parser_template_id, \n+\tcp_parser_template_name, cp_parser_direct_declarator, \n+\tcp_parser_parameter_declaration_list, cp_parser_class_head, \n+\tcp_parser_base_specifier, cp_parser_lookup_name, \n+\tcp_parser_late_parsing_default_args, \n+\tcp_parser_optional_template_keyword \n+\tcp_parser_elaborated_type_specifier, cp_parser_check_class_key, \n+\tcp_parser_check_access_in_redeclaration): Use quoting marks.\n+\n+\t* name-lookup.c (supplement_binding, pushdecl, \n+\tcheck_for_out_of_scope_variable, validate_nonmember_using_decl, \n+\tdo_nonmember_using_decl, lookup_tag, set_decl_namespace, \n+\tpush_namespace, do_namespace_alias, do_using_directive, \n+\tambiguous_decl, lookup_namespace_name, add_function): Likewise.\n+\n+\t* method.c (use_thunk): Likewise.\n+\n+\t* lex.c (unqualified_name_lookup_error, \n+\tunqualified_fn_lookup_error): Likewise.\n+\n 2004-10-04  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n \n \tConvert diagnostics to use quoting flag q 4/n"}, {"sha": "c0b7968569419b1c86b0950fb680487dbd5632c0", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a13a6258b1d75537b08a0286bd7719ae0a9ae1f/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a13a6258b1d75537b08a0286bd7719ae0a9ae1f/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=2a13a6258b1d75537b08a0286bd7719ae0a9ae1f", "patch": "@@ -566,11 +566,11 @@ unqualified_name_lookup_error (tree name)\n   if (IDENTIFIER_OPNAME_P (name))\n     {\n       if (name != ansi_opname (ERROR_MARK))\n-\terror (\"`%D' not defined\", name);\n+\terror (\"%qD not defined\", name);\n     }\n   else\n     {\n-      error (\"`%D' was not declared in this scope\", name);\n+      error (\"%qD was not declared in this scope\", name);\n       /* Prevent repeated error messages by creating a VAR_DECL with\n \t this NAME in the innermost block scope.  */\n       if (current_function_decl)\n@@ -607,8 +607,8 @@ unqualified_fn_lookup_error (tree name)\n \t Note that we have the exact wording of the following message in\n \t the manual (trouble.texi, node \"Name lookup\"), so they need to\n \t be kept in synch.  */\n-      pedwarn (\"there are no arguments to `%D' that depend on a template \"\n-\t       \"parameter, so a declaration of `%D' must be available\", \n+      pedwarn (\"there are no arguments to %qD that depend on a template \"\n+\t       \"parameter, so a declaration of %qD must be available\", \n \t       name, name);\n       \n       if (!flag_permissive)"}, {"sha": "da7ace71ada8d9ee41f2a5f36c9ceb34e325fc0a", "filename": "gcc/cp/method.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a13a6258b1d75537b08a0286bd7719ae0a9ae1f/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a13a6258b1d75537b08a0286bd7719ae0a9ae1f/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=2a13a6258b1d75537b08a0286bd7719ae0a9ae1f", "patch": "@@ -440,7 +440,7 @@ use_thunk (tree thunk_fndecl, bool emit_p)\n \t doesn't work for varargs.  */\n \n       if (varargs_function_p (function))\n-\terror (\"generic thunk code fails for method `%#D' which uses `...'\",\n+\terror (\"generic thunk code fails for method %q#D which uses %<...%>\",\n \t       function);\n \n       DECL_RESULT (thunk_fndecl) = NULL_TREE;\n@@ -649,12 +649,14 @@ do_build_assign_ref (tree fndecl)\n \n \t  if (CP_TYPE_CONST_P (TREE_TYPE (field)))\n \t    {\n-              error (\"non-static const member `%#D', can't use default assignment operator\", field);\n+              error (\"non-static const member %q#D, can't use default \"\n+                     \"assignment operator\", field);\n \t      continue;\n \t    }\n \t  else if (TREE_CODE (TREE_TYPE (field)) == REFERENCE_TYPE)\n \t    {\n-\t      error (\"non-static reference member `%#D', can't use default assignment operator\", field);\n+\t      error (\"non-static reference member %q#D, can't use \"\n+                     \"default assignment operator\", field);\n \t      continue;\n \t    }\n "}, {"sha": "b7e29aa55d3c01194a1b4f2371a51fc602da2dbd", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 58, "deletions": 60, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a13a6258b1d75537b08a0286bd7719ae0a9ae1f/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a13a6258b1d75537b08a0286bd7719ae0a9ae1f/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=2a13a6258b1d75537b08a0286bd7719ae0a9ae1f", "patch": "@@ -574,8 +574,8 @@ supplement_binding (cxx_binding *binding, tree decl)\n     ok = false;\n   else\n     {\n-      error (\"declaration of `%#D'\", decl);\n-      cp_error_at (\"conflicts with previous declaration `%#D'\", bval);\n+      error (\"declaration of %q#D\", decl);\n+      cp_error_at (\"conflicts with previous declaration %q#D\", bval);\n       ok = false;\n     }\n \n@@ -759,8 +759,8 @@ pushdecl (tree x)\n \t  else if (t == wchar_decl_node)\n \t    {\n \t      if (pedantic && ! DECL_IN_SYSTEM_HEADER (x))\n-\t\tpedwarn (\"redeclaration of `wchar_t' as `%T'\",\n-\t\t\t    TREE_TYPE (x));\n+\t\tpedwarn (\"redeclaration of %<wchar_t%> as %qT\",\n+                         TREE_TYPE (x));\n \n \t      /* Throw away the redeclaration.  */\n \t      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, t);\n@@ -791,8 +791,8 @@ pushdecl (tree x)\n \t\t     [basic.start.main]\n \t\t     \n \t\t     This function shall not be overloaded.  */\n-\t\t  cp_error_at (\"invalid redeclaration of `%D'\", t);\n-\t\t  error (\"as `%D'\", x);\n+\t\t  cp_error_at (\"invalid redeclaration of %qD\", t);\n+\t\t  error (\"as %qD\", x);\n \t\t  /* We don't try to push this declaration since that\n \t\t     causes a crash.  */\n \t\t  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, x);\n@@ -880,8 +880,8 @@ pushdecl (tree x)\n \t      && TREE_CODE (decl) == TREE_CODE (x)\n \t      && !same_type_p (TREE_TYPE (x), TREE_TYPE (decl)))\n \t    {\n-\t      pedwarn (\"type mismatch with previous external decl of `%#D'\", x);\n-\t      cp_pedwarn_at (\"previous external decl of `%#D'\", decl);\n+\t      pedwarn (\"type mismatch with previous external decl of %q#D\", x);\n+\t      cp_pedwarn_at (\"previous external decl of %q#D\", decl);\n \t    }\n \t}\n \n@@ -963,8 +963,8 @@ pushdecl (tree x)\n \t\t/* OK */;\n \t      else\n \t\t{\n-\t\t  warning (\"extern declaration of `%#D' doesn't match\", x);\n-\t\t  cp_warning_at (\"global declaration `%#D'\", oldglobal);\n+\t\t  warning (\"extern declaration of %q#D doesn't match\", x);\n+\t\t  cp_warning_at (\"global declaration %q#D\", oldglobal);\n \t\t}\n \t    }\n \t  /* If we have a local external declaration,\n@@ -1000,14 +1000,14 @@ pushdecl (tree x)\n \t\t  /* ARM $8.3 */\n \t\t  if (b->kind == sk_function_parms)\n \t\t    {\n-\t\t      error (\"declaration of '%#D' shadows a parameter\", x);\n+\t\t      error (\"declaration of %q#D shadows a parameter\", x);\n \t\t      err = true;\n \t\t    }\n \t\t}\n \n \t      if (warn_shadow && !err)\n \t\t{\n-\t\t  warning (\"declaration of '%#D' shadows a parameter\", x);\n+\t\t  warning (\"declaration of %q#D shadows a parameter\", x);\n \t\t  warning (\"%Jshadowed declaration is here\", oldlocal);\n \t\t}\n \t    }\n@@ -1032,20 +1032,20 @@ pushdecl (tree x)\n \t      if (member && !TREE_STATIC (member))\n \t\t{\n \t\t  /* Location of previous decl is not useful in this case.  */\n-\t\t  warning (\"declaration of '%D' shadows a member of 'this'\",\n+\t\t  warning (\"declaration of %qD shadows a member of 'this'\",\n \t\t\t   x);\n \t\t}\n \t      else if (oldlocal != NULL_TREE\n \t\t       && TREE_CODE (oldlocal) == VAR_DECL)\n \t\t{\n-\t\t  warning (\"declaration of '%D' shadows a previous local\", x);\n+\t\t  warning (\"declaration of %qD shadows a previous local\", x);\n \t\t  warning (\"%Jshadowed declaration is here\", oldlocal);\n \t\t}\n \t      else if (oldglobal != NULL_TREE\n \t\t       && TREE_CODE (oldglobal) == VAR_DECL)\n \t\t/* XXX shadow warnings in outer-more namespaces */\n \t\t{\n-\t\t  warning (\"declaration of '%D' shadows a global declaration\",\n+\t\t  warning (\"declaration of %qD shadows a global declaration\",\n \t\t\t   x);\n \t\t  warning (\"%Jshadowed declaration is here\", oldglobal);\n \t\t}\n@@ -1161,11 +1161,10 @@ check_for_out_of_scope_variable (tree decl)\n     {\n       if (!DECL_ERROR_REPORTED (decl))\n \t{\n-\t  warning (\"name lookup of `%D' changed\",\n-\t\t      DECL_NAME (decl));\n-\t  cp_warning_at (\"  matches this `%D' under ISO standard rules\",\n+\t  warning (\"name lookup of %qD changed\", DECL_NAME (decl));\n+\t  cp_warning_at (\"  matches this %qD under ISO standard rules\",\n \t\t\t shadowed);\n-\t  cp_warning_at (\"  matches this `%D' under old rules\", decl);\n+\t  cp_warning_at (\"  matches this %qD under old rules\", decl);\n \t  DECL_ERROR_REPORTED (decl) = 1;\n \t}\n       return shadowed;\n@@ -1183,16 +1182,17 @@ check_for_out_of_scope_variable (tree decl)\n \n   if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (TREE_TYPE (decl)))\n     {\n-      error (\"name lookup of `%D' changed for new ISO `for' scoping\",\n+      error (\"name lookup of %qD changed for new ISO %<for%> scoping\",\n \t     DECL_NAME (decl));\n-      cp_error_at (\"  cannot use obsolete binding at `%D' because it has a destructor\", decl);\n+      cp_error_at (\"  cannot use obsolete binding at %qD because \"\n+                   \"it has a destructor\", decl);\n       return error_mark_node;\n     }\n   else\n     {\n-      pedwarn (\"name lookup of `%D' changed for new ISO `for' scoping\",\n+      pedwarn (\"name lookup of %qD changed for new ISO %<for%> scoping\",\n \t       DECL_NAME (decl));\n-      cp_pedwarn_at (\"  using obsolete binding at `%D'\", decl);\n+      cp_pedwarn_at (\"  using obsolete binding at %qD\", decl);\n     }\n \n   return decl;\n@@ -2023,8 +2023,8 @@ push_overloaded_decl (tree decl, int flags)\n \t\t  && !(flags & PUSH_USING)\n \t\t  && compparms (TYPE_ARG_TYPES (TREE_TYPE (fn)),\n \t\t\t\tTYPE_ARG_TYPES (TREE_TYPE (decl))))\n-\t\terror (\"`%#D' conflicts with previous using declaration `%#D'\",\n-\t\t\t  decl, fn);\n+\t\terror (\"%q#D conflicts with previous using declaration %q#D\",\n+                       decl, fn);\n \n \t      if (duplicate_decls (decl, fn) == fn)\n \t\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, fn);\n@@ -2035,8 +2035,8 @@ push_overloaded_decl (tree decl, int flags)\n \told = NULL_TREE;\n       else\n \t{\n-\t  cp_error_at (\"previous non-function declaration `%#D'\", old);\n-\t  error (\"conflicts with function declaration `%#D'\", decl);\n+\t  cp_error_at (\"previous non-function declaration %q#D\", old);\n+\t  error (\"conflicts with function declaration %q#D\", decl);\n \t  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, decl);\n \t}\n     }\n@@ -2114,7 +2114,7 @@ validate_nonmember_using_decl (tree decl, tree scope, tree name)\n        member-declaration.  */\n   if (TYPE_P (scope))\n     {\n-      error (\"`%T' is not a namespace\", scope);\n+      error (\"%qT is not a namespace\", scope);\n       return NULL_TREE;\n     }\n   else if (scope == error_mark_node)\n@@ -2124,21 +2124,22 @@ validate_nonmember_using_decl (tree decl, tree scope, tree name)\n     {\n       /* 7.3.3/5\n \t   A using-declaration shall not name a template-id.  */\n-      error (\"a using-declaration cannot specify a template-id.  Try `using %D'\", name);\n+      error (\"a using-declaration cannot specify a template-id.  \"\n+             \"Try %<using %D%>\", name);\n       return NULL_TREE;\n     }\n \n   if (TREE_CODE (decl) == NAMESPACE_DECL)\n     {\n-      error (\"namespace `%D' not allowed in using-declaration\", decl);\n+      error (\"namespace %qD not allowed in using-declaration\", decl);\n       return NULL_TREE;\n     }\n \n   if (TREE_CODE (decl) == SCOPE_REF)\n     {\n       /* It's a nested name with template parameter dependent scope.\n \t This can only be using-declaration for class member.  */\n-      error (\"`%T' is not a namespace\", TREE_OPERAND (decl, 0));\n+      error (\"%qT is not a namespace\", TREE_OPERAND (decl, 0));\n       return NULL_TREE;\n     }\n \n@@ -2166,7 +2167,7 @@ do_nonmember_using_decl (tree scope, tree name, tree oldval, tree oldtype,\n \n   if (!decls.value && !decls.type)\n     {\n-      error (\"`%D' not declared\", name);\n+      error (\"%qD not declared\", name);\n       return;\n     }\n \n@@ -2178,7 +2179,7 @@ do_nonmember_using_decl (tree scope, tree name, tree oldval, tree oldtype,\n       if (oldval && !is_overloaded_fn (oldval))\n \t{\n \t  if (!DECL_IMPLICIT_TYPEDEF_P (oldval))\n-\t    error (\"`%D' is already declared in this scope\", name);\n+\t    error (\"%qD is already declared in this scope\", name);\n \t  oldval = NULL_TREE;\n \t}\n \n@@ -2220,7 +2221,7 @@ do_nonmember_using_decl (tree scope, tree name, tree oldval, tree oldtype,\n \t\t    {\n \t\t      /* If the OLD_FN was really declared, the\n \t\t\t declarations don't match.  */\n-\t\t      error (\"`%D' is already declared in this scope\", name);\n+\t\t      error (\"%qD is already declared in this scope\", name);\n \t\t      break;\n \t\t    }\n \n@@ -2257,14 +2258,14 @@ do_nonmember_using_decl (tree scope, tree name, tree oldval, tree oldtype,\n     {\n       *newval = decls.value;\n       if (oldval && !decls_match (*newval, oldval))\n-\terror (\"`%D' is already declared in this scope\", name);\n+\terror (\"%qD is already declared in this scope\", name);\n     }\n \n   *newtype = decls.type;\n   if (oldtype && *newtype && !same_type_p (oldtype, *newtype))\n     {\n-      error (\"using declaration `%D' introduced ambiguous type `%T'\",\n-\t\tname, oldtype);\n+      error (\"using declaration %qD introduced ambiguous type %qT\",\n+             name, oldtype);\n       return;\n     }\n }\n@@ -2431,7 +2432,7 @@ lookup_tag (enum tree_code form, tree name,\n \t\t    && (form == ENUMERAL_TYPE\n \t\t\t|| TREE_CODE (old) == ENUMERAL_TYPE))\n \t\t  {\n-\t\t    error (\"`%#D' redeclared as %C\", old, form);\n+\t\t    error (\"%q#D redeclared as %C\", old, form);\n \t\t    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n \t\t  }\n \t\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, old);\n@@ -2450,7 +2451,7 @@ lookup_tag (enum tree_code form, tree name,\n                   && (form == ENUMERAL_TYPE || code == ENUMERAL_TYPE))\n                 {\n                   /* Definition isn't the kind we were looking for.  */\n-                  error (\"`%#D' redeclared as %C\", entry->type, form);\n+                  error (\"%q#D redeclared as %C\", entry->type, form);\n                   POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n                 }\n               POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, entry->type);\n@@ -2818,7 +2819,7 @@ push_class_level_binding (tree name, tree x)\n       tree scope = context_for_name_lookup (x);\n       if (TYPE_P (scope) && same_type_p (scope, current_class_type))\n \t{\n-\t  error (\"`%D' has the same name as the class in which it is \"\n+\t  error (\"%qD has the same name as the class in which it is \"\n \t\t \"declared\",\n \t\t x);\n \t  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, false);\n@@ -3039,8 +3040,7 @@ set_decl_namespace (tree decl, tree scope, bool friendp)\n   else\n     return;\n  complain:\n-  error (\"`%D' should have been declared inside `%D'\",\n-\t    decl, scope);\n+  error (\"%qD should have been declared inside %qD\", decl, scope);\n } \n \n /* Return the namespace where the current declaration is declared.  */\n@@ -3102,8 +3102,8 @@ push_namespace (tree name)\n           need_new = 0;\n           if (DECL_NAMESPACE_ALIAS (d))\n             {\n-              error (\"namespace alias `%D' not allowed here, assuming `%D'\",\n-                        d, DECL_NAMESPACE_ALIAS (d));\n+              error (\"namespace alias %qD not allowed here, assuming %qD\",\n+                     d, DECL_NAMESPACE_ALIAS (d));\n               d = DECL_NAMESPACE_ALIAS (d);\n             }\n         }\n@@ -3217,7 +3217,7 @@ do_namespace_alias (tree alias, tree namespace)\n   if (TREE_CODE (namespace) != NAMESPACE_DECL)\n     {\n       /* The parser did not find it, so it's not there.  */\n-      error (\"unknown namespace `%D'\", namespace);\n+      error (\"unknown namespace %qD\", namespace);\n       return;\n     }\n \n@@ -3377,13 +3377,13 @@ do_using_directive (tree namespace)\n     {\n       /* Lookup in lexer did not find a namespace.  */\n       if (!processing_template_decl)\n-\terror (\"namespace `%T' undeclared\", namespace);\n+\terror (\"namespace %qT undeclared\", namespace);\n       return;\n     }\n   if (TREE_CODE (namespace) != NAMESPACE_DECL)\n     {\n       if (!processing_template_decl)\n-\terror (\"`%T' is not a namespace\", namespace);\n+\terror (\"%qT is not a namespace\", namespace);\n       return;\n     }\n   namespace = ORIGINAL_NAMESPACE (namespace);\n@@ -3428,7 +3428,7 @@ parse_using_directive (tree namespace, tree attribs)\n \t\t\t   DECL_NAMESPACE_ASSOCIATIONS (namespace));\n \t}\n       else\n-\twarning (\"`%D' attribute directive ignored\", name);\n+\twarning (\"%qD attribute directive ignored\", name);\n     }\n }\n \n@@ -3562,11 +3562,10 @@ ambiguous_decl (tree name, struct scope_binding *old, cxx_binding *new,\n \t\t repeat ourselves.  */\n \t      if (old->value != error_mark_node)\n \t\t{\n-\t\t  error (\"use of `%D' is ambiguous\", name);\n-\t\t  cp_error_at (\"  first declared as `%#D' here\",\n-\t\t\t       old->value);\n+\t\t  error (\"use of %qD is ambiguous\", name);\n+\t\t  cp_error_at (\"  first declared as %q#D here\", old->value);\n \t\t}\n-              cp_error_at (\"  also declared as `%#D' here\", val);\n+              cp_error_at (\"  also declared as %q#D here\", val);\n             }\n \t  old->value = error_mark_node;\n \t}\n@@ -3581,7 +3580,7 @@ ambiguous_decl (tree name, struct scope_binding *old, cxx_binding *new,\n     {\n       if (flags & LOOKUP_COMPLAIN)\n         {\n-          error (\"`%D' denotes an ambiguous type\",name);\n+          error (\"%qD denotes an ambiguous type\",name);\n           error (\"%J  first type here\", TYPE_MAIN_DECL (old->type));\n           error (\"%J  other type here\", TYPE_MAIN_DECL (type));\n         }\n@@ -3647,7 +3646,7 @@ lookup_namespace_name (tree namespace, tree name)\n     {\n       /* This happens for A::B where B is a template, and there are no\n \t template arguments.  */\n-      error (\"invalid use of `%D'\", name);\n+      error (\"invalid use of %qD\", name);\n       POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n     }\n \n@@ -3687,8 +3686,7 @@ lookup_namespace_name (tree namespace, tree name)\n \t\t\t\t\t    TREE_OPERAND (template_id, 1));\n \t  else\n \t    {\n-\t      error (\"`%D::%D' is not a template\",\n-\t\t\tnamespace, name);\n+\t      error (\"%<%D::%D%> is not a template\", namespace, name);\n \t      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n \t    }\n \t}\n@@ -3704,7 +3702,7 @@ lookup_namespace_name (tree namespace, tree name)\n         POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, val);\n     }\n \n-  error (\"`%D' undeclared in namespace `%D'\", name, namespace);\n+  error (\"%qD undeclared in namespace %qD\", name, namespace);\n   POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n }\n \n@@ -4241,9 +4239,9 @@ add_function (struct arg_lookup *k, tree fn)\n \t{\n \t  fn = f1; f1 = f2; f2 = fn;\n \t}\n-      cp_error_at (\"`%D' is not a function,\", f1);\n-      cp_error_at (\"  conflict with `%D'\", f2);\n-      error (\"  in call to `%D'\", k->name);\n+      cp_error_at (\"%qD is not a function,\", f1);\n+      cp_error_at (\"  conflict with %qD\", f2);\n+      error (\"  in call to %qD\", k->name);\n       return true;\n     }\n "}, {"sha": "ed65334852a4b082358ec89d18fe66852fc8ed93", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 57, "deletions": 56, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a13a6258b1d75537b08a0286bd7719ae0a9ae1f/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a13a6258b1d75537b08a0286bd7719ae0a9ae1f/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=2a13a6258b1d75537b08a0286bd7719ae0a9ae1f", "patch": "@@ -1872,26 +1872,26 @@ cp_parser_name_lookup_error (cp_parser* parser,\n   if (decl == error_mark_node)\n     {\n       if (parser->scope && parser->scope != global_namespace)\n-\terror (\"`%D::%D' has not been declared\",\n+\terror (\"%<%D::%D%> has not been declared\",\n \t       parser->scope, name);\n       else if (parser->scope == global_namespace)\n-\terror (\"`::%D' has not been declared\", name);\n+\terror (\"%<::%D%> has not been declared\", name);\n       else if (parser->object_scope \n \t       && !CLASS_TYPE_P (parser->object_scope))\n-\terror (\"request for member `%D' in non-class type `%T'\",\n+\terror (\"request for member %qD in non-class type %qT\",\n \t       name, parser->object_scope);\n       else if (parser->object_scope)\n-\terror (\"`%T::%D' has not been declared\", \n+\terror (\"%<%T::%D%> has not been declared\", \n \t       parser->object_scope, name);\n       else\n \terror (\"`%D' has not been declared\", name);\n     }\n   else if (parser->scope && parser->scope != global_namespace)\n-    error (\"`%D::%D' %s\", parser->scope, name, desired);\n+    error (\"%<%D::%D%> %s\", parser->scope, name, desired);\n   else if (parser->scope == global_namespace)\n-    error (\"`::%D' %s\", name, desired);\n+    error (\"%<::%D%> %s\", name, desired);\n   else\n-    error (\"`%D' %s\", name, desired);\n+    error (\"%qD %s\", name, desired);\n }\n \n /* If we are parsing tentatively, remember that an error has occurred\n@@ -1962,9 +1962,9 @@ cp_parser_check_for_invalid_template_id (cp_parser* parser,\n   if (cp_lexer_next_token_is (parser->lexer, CPP_LESS))\n     {\n       if (TYPE_P (type))\n-\terror (\"`%T' is not a template\", type);\n+\terror (\"%qT is not a template\", type);\n       else if (TREE_CODE (type) == IDENTIFIER_NODE)\n-\terror (\"`%E' is not a template\", type);\n+\terror (\"%qE is not a template\", type);\n       else\n \terror (\"invalid template-id\");\n       /* Remember the location of the invalid \"<\".  */\n@@ -2031,12 +2031,12 @@ cp_parser_diagnose_invalid_type_name (cp_parser *parser, tree scope, tree id)\n   /* If the lookup found a template-name, it means that the user forgot\n   to specify an argument list. Emit an useful error message.  */\n   if (TREE_CODE (decl) == TEMPLATE_DECL)\n-    error (\"invalid use of template-name `%E' without an argument list\",\n+    error (\"invalid use of template-name %qE without an argument list\",\n       decl);\n   else if (!parser->scope)\n     {\n       /* Issue an error message.  */\n-      error (\"`%E' does not name a type\", id);\n+      error (\"%qE does not name a type\", id);\n       /* If we're in a template class, it's possible that the user was\n \t referring to a type from a base class.  For example:\n \n@@ -2082,11 +2082,10 @@ cp_parser_diagnose_invalid_type_name (cp_parser *parser, tree scope, tree id)\n   else\n     {\n       if (TREE_CODE (parser->scope) == NAMESPACE_DECL)\n-\terror (\"`%E' in namespace `%E' does not name a type\",\n+\terror (\"%qE in namespace %qE does not name a type\",\n \t       id, parser->scope);\n       else if (TYPE_P (parser->scope))\n-\terror (\"`%E' in class `%T' does not name a type\",\n-\t       id, parser->scope);\n+\terror (\"q%E in class %qT does not name a type\", id, parser->scope);\n       else\n \tgcc_unreachable ();\n     }\n@@ -2816,7 +2815,7 @@ cp_parser_primary_expression (cp_parser *parser,\n \t  cp_lexer_consume_token (parser->lexer);\n \t  if (parser->local_variables_forbidden_p)\n \t    {\n-\t      error (\"`this' may not be used in this context\");\n+\t      error (\"%<this%> may not be used in this context\");\n \t      return error_mark_node;\n \t    }\n \t  /* Pointers cannot appear in constant-expressions.  */\n@@ -2951,7 +2950,7 @@ cp_parser_primary_expression (cp_parser *parser,\n \t\tdecl = check_for_out_of_scope_variable (decl);\n \t\tif (local_variable_p (decl))\n \t\t  {\n-\t\t    error (\"local variable `%D' may not appear in this context\",\n+\t\t    error (\"local variable %qD may not appear in this context\",\n \t\t\t   decl);\n \t\t    return error_mark_node;\n \t\t  }\n@@ -3316,7 +3315,7 @@ cp_parser_unqualified_id (cp_parser* parser,\n \tif (declarator_p\n \t    && !DECL_IMPLICIT_TYPEDEF_P (type_decl)\n \t    && !DECL_SELF_REFERENCE_P (type_decl))\n-\t  error (\"typedef-name `%D' used as destructor declarator\",\n+\t  error (\"typedef-name %qD used as destructor declarator\",\n \t\t type_decl);\n \n \treturn build_nt (BIT_NOT_EXPR, TREE_TYPE (type_decl));\n@@ -3522,8 +3521,7 @@ cp_parser_nested_name_specifier_opt (cp_parser *parser,\n \n \t\t  decl = cp_parser_lookup_name_simple (parser, token->value);\n \t\t  if (TREE_CODE (decl) == TEMPLATE_DECL)\n-\t\t    error (\"`%D' used without template parameters\",\n-\t\t\t   decl);\n+\t\t    error (\"%qD used without template parameters\", decl);\n \t\t  else\n \t\t    cp_parser_name_lookup_error\n \t\t      (parser, token->value, decl,\n@@ -5051,7 +5049,8 @@ cp_parser_direct_new_declarator (cp_parser* parser)\n \t\t\t\t\t      /*complain=*/true);\n \t      if (!expression)\n \t\t{\n-\t\t  error (\"expression in new-declarator must have integral or enumeration type\");\n+\t\t  error (\"expression in new-declarator must have integral \"\n+                         \"or enumeration type\");\n \t\t  expression = error_mark_node;\n \t\t}\n \t    }\n@@ -5987,7 +5986,7 @@ cp_parser_labeled_statement (cp_parser* parser, tree in_statement_expr)\n \t  expr_hi = NULL_TREE;\n \n \tif (!parser->in_switch_statement_p)\n-\t  error (\"case label `%E' not within a switch statement\", expr);\n+\t  error (\"case label %qE not within a switch statement\", expr);\n \telse\n \t  statement = finish_case_label (expr, expr_hi);\n       }\n@@ -6493,7 +6492,7 @@ cp_parser_jump_statement (cp_parser* parser)\n \t}\n       else\n \tstatement = finish_break_stmt ();\n-      cp_parser_require (parser, CPP_SEMICOLON, \"`;'\");\n+      cp_parser_require (parser, CPP_SEMICOLON, \"%<;%>\");\n       break;\n \n     case RID_CONTINUE:\n@@ -6504,7 +6503,7 @@ cp_parser_jump_statement (cp_parser* parser)\n \t}\n       else\n \tstatement = finish_continue_stmt ();\n-      cp_parser_require (parser, CPP_SEMICOLON, \"`;'\");\n+      cp_parser_require (parser, CPP_SEMICOLON, \"%<;%>\");\n       break;\n \n     case RID_RETURN:\n@@ -6520,7 +6519,7 @@ cp_parser_jump_statement (cp_parser* parser)\n \t/* Build the return-statement.  */\n \tstatement = finish_return_stmt (expr);\n \t/* Look for the final `;'.  */\n-\tcp_parser_require (parser, CPP_SEMICOLON, \"`;'\");\n+\tcp_parser_require (parser, CPP_SEMICOLON, \"%<;%>\");\n       }\n       break;\n \n@@ -6539,7 +6538,7 @@ cp_parser_jump_statement (cp_parser* parser)\n       else\n \tfinish_goto_stmt (cp_parser_identifier (parser));\n       /* Look for the final `;'.  */\n-      cp_parser_require (parser, CPP_SEMICOLON, \"`;'\");\n+      cp_parser_require (parser, CPP_SEMICOLON, \"%<;%>\");\n       break;\n \n     default:\n@@ -6997,7 +6996,7 @@ cp_parser_simple_declaration (cp_parser* parser,\n \t  if (decl != error_mark_node\n \t      || (cp_parser_parsing_tentatively (parser)\n \t\t  && !cp_parser_committed_to_tentative_parse (parser)))\n-\t    cp_parser_error (parser, \"expected `,' or `;'\");\n+\t    cp_parser_error (parser, \"expected %<,%> or %<;%>\");\n \t  /* Skip tokens until we reach the end of the statement.  */\n \t  cp_parser_skip_to_end_of_statement (parser);\n \t  /* If the next token is now a `;', consume it.  */\n@@ -7105,7 +7104,7 @@ cp_parser_decl_specifier_seq (cp_parser* parser,\n \t       friend  */\n \tcase RID_FRIEND:\n \t  if (decl_specs->specs[(int) ds_friend]++)\n-\t    error (\"duplicate `friend'\");\n+\t    error (\"duplicate %<friend%>\");\n \t  /* Consume the token.  */\n \t  cp_lexer_consume_token (parser->lexer);\n \t  break;\n@@ -7679,7 +7678,7 @@ cp_parser_mem_initializer_id (cp_parser* parser)\n   /* `typename' is not allowed in this context ([temp.res]).  */\n   if (cp_lexer_next_token_is_keyword (parser->lexer, RID_TYPENAME))\n     {\n-      error (\"keyword `typename' not allowed in this context (a qualified \"\n+      error (\"keyword %<typename%> not allowed in this context (a qualified \"\n \t     \"member initializer is implicitly a type)\");\n       cp_lexer_consume_token (parser->lexer);\n     }\n@@ -8041,7 +8040,7 @@ cp_parser_template_declaration (cp_parser* parser, bool member_p)\n       /* Consume the `export' token.  */\n       cp_lexer_consume_token (parser->lexer);\n       /* Warn that we do not support `export'.  */\n-      warning (\"keyword `export' not implemented, and will be ignored\");\n+      warning (\"keyword %<export%> not implemented, and will be ignored\");\n     }\n \n   cp_parser_template_declaration_after_export (parser, member_p);\n@@ -8294,7 +8293,7 @@ cp_parser_type_parameter (cp_parser* parser)\n     default:\n       /* Anything else is an error.  */\n       cp_parser_error (parser,\n-\t\t       \"expected `class', `typename', or `template'\");\n+\t\t       \"expected %<class%>, %<typename%>, or %<template%>\");\n       parameter = error_mark_node;\n     }\n \n@@ -8408,21 +8407,21 @@ cp_parser_template_id (cp_parser *parser,\n \t     and return simply an error. Maybe this is not a template-id\n \t     after all.  */\n \t  next_token_2->type = CPP_COLON;\n-\t  cp_parser_error (parser, \"expected `<'\");\n+\t  cp_parser_error (parser, \"expected %<<%>\");\n \t  pop_deferring_access_checks ();\n \t  return error_mark_node;\n \t}\n       /* Otherwise, emit an error about the invalid digraph, but continue\n          parsing because we got our argument list.  */\n-      pedwarn (\"`<::' cannot begin a template-argument list\");\n-      inform (\"`<:' is an alternate spelling for `['. Insert whitespace \"\n-\t      \"between `<' and `::'\");\n+      pedwarn (\"%<<::%> cannot begin a template-argument list\");\n+      inform (\"%<<:%> is an alternate spelling for %<[%>. Insert whitespace \"\n+\t      \"between %<<%> and %<::%>\");\n       if (!flag_permissive)\n \t{\n \t  static bool hint;\n \t  if (!hint)\n \t    {\n-\t      inform (\"(if you use `-fpermissive' G++ will accept your code)\");\n+\t      inform (\"(if you use -fpermissive G++ will accept your code)\");\n \t      hint = true;\n \t    }\n \t}\n@@ -8597,8 +8596,8 @@ cp_parser_template_name (cp_parser* parser,\n \t  ptrdiff_t start;\n \t  cp_token* token;\n \t  /* Explain what went wrong.  */\n-\t  error (\"non-template `%D' used as template\", identifier);\n-\t  inform (\"use `%T::template %D' to indicate that it is a template\",\n+\t  error (\"non-template %qD used as template\", identifier);\n+\t  inform (\"use %<%T::template %D%> to indicate that it is a template\",\n \t\t  parser->scope, identifier);\n \t  /* If parsing tentatively, find the location of the \"<\"\n \t     token.  */\n@@ -9625,7 +9624,7 @@ cp_parser_elaborated_type_specifier (cp_parser* parser,\n       tag_type = typename_type;\n       /* The `typename' keyword is only allowed in templates.  */\n       if (!processing_template_decl)\n-\tpedwarn (\"using `typename' outside of template\");\n+\tpedwarn (\"using %<typename%> outside of template\");\n     }\n   /* Otherwise it must be a class-key.  */\n   else\n@@ -11068,7 +11067,7 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t\t\t\t\t\t /*only_current_p=*/false);\n \t\t  /* If that failed, the declarator is invalid.  */\n \t\t  if (type == error_mark_node)\n-\t\t    error (\"`%T::%D' is not a type\",\n+\t\t    error (\"%<%T::%D%> is not a type\",\n \t\t\t   TYPE_CONTEXT (scope),\n \t\t\t   TYPE_IDENTIFIER (scope));\n \t\t  /* Build a new DECLARATOR.  */\n@@ -11114,8 +11113,9 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t\t      && CLASSTYPE_USE_TEMPLATE (TREE_TYPE (unqualified_name)))\n \t\t    {\n \t\t      error (\"invalid use of constructor as a template\");\n-\t\t      inform (\"use `%T::%D' instead of `%T::%T' to name the \"\n-\t\t\t      \"constructor in a qualified name\", class_type,\n+\t\t      inform (\"use %<%T::%D%> instead of %<%T::%T%> to name \"\n+                              \"the constructor in a qualified name\",\n+                              class_type,\n \t\t\t      DECL_NAME (TYPE_TI_TEMPLATE (class_type)),\n \t\t\t      class_type, class_type);\n \t\t    }\n@@ -11626,7 +11626,7 @@ cp_parser_parameter_declaration_list (cp_parser* parser, bool *is_error)\n \t}\n       else\n \t{\n-\t  cp_parser_error (parser, \"expected `,' or `...'\");\n+\t  cp_parser_error (parser, \"expected %<,%> or %<...%>\");\n \t  if (!cp_parser_parsing_tentatively (parser)\n \t      || cp_parser_committed_to_tentative_parse (parser))\n \t    cp_parser_skip_to_closing_parenthesis (parser,\n@@ -12595,7 +12595,7 @@ cp_parser_class_head (cp_parser* parser,\n      xref_tag, since that has irreversible side-effects.  */\n   if (!cp_parser_next_token_starts_class_definition_p (parser))\n     {\n-      cp_parser_error (parser, \"expected `{' or `:'\");\n+      cp_parser_error (parser, \"expected %<{%> or %<:%>\");\n       return error_mark_node;\n     }\n \n@@ -12620,8 +12620,8 @@ cp_parser_class_head (cp_parser* parser,\n \t class was originally declared, the program is invalid.  */\n       if (scope && !is_ancestor (scope, nested_name_specifier))\n \t{\n-\t  error (\"declaration of `%D' in `%D' which does not \"\n-\t\t \"enclose `%D'\", type, scope, nested_name_specifier);\n+\t  error (\"declaration of %qD in %qD which does not enclose %qD\",\n+                 type, scope, nested_name_specifier);\n \t  type = NULL_TREE;\n \t  goto done;\n \t}\n@@ -12644,7 +12644,7 @@ cp_parser_class_head (cp_parser* parser,\n       && parser->num_template_parameter_lists == 0\n       && template_id_p)\n     {\n-      error (\"an explicit specialization must be preceded by 'template <>'\");\n+      error (\"an explicit specialization must be preceded by %<template <>%>\");\n       invalid_explicit_specialization_p = true;\n       /* Take the same action that would have been taken by\n \t cp_parser_explicit_specialization.  */\n@@ -13179,7 +13179,7 @@ cp_parser_member_declaration (cp_parser* parser)\n \t  else if (cp_lexer_next_token_is_not (parser->lexer,\n \t\t\t\t\t       CPP_SEMICOLON))\n \t    {\n-\t      cp_parser_error (parser, \"expected `;'\");\n+\t      cp_parser_error (parser, \"expected %<;%>\");\n \t      /* Skip tokens until we find a `;'.  */\n \t      cp_parser_skip_to_end_of_statement (parser);\n \n@@ -13364,7 +13364,7 @@ cp_parser_base_specifier (cp_parser* parser)\n \t  if (virtual_p && !duplicate_virtual_error_issued_p)\n \t    {\n \t      cp_parser_error (parser,\n-\t\t\t       \"`virtual' specified more than once in base-specified\");\n+\t\t\t       \"%<virtual%> specified more than once in base-specified\");\n \t      duplicate_virtual_error_issued_p = true;\n \t    }\n \n@@ -13406,9 +13406,9 @@ cp_parser_base_specifier (cp_parser* parser)\n   if (cp_lexer_next_token_is_keyword (parser->lexer, RID_TYPENAME))\n     {\n       if (!processing_template_decl)\n-\terror (\"keyword `typename' not allowed outside of templates\");\n+\terror (\"keyword %<typename%> not allowed outside of templates\");\n       else\n-\terror (\"keyword `typename' not allowed in this context \"\n+\terror (\"keyword %<typename%> not allowed in this context \"\n \t       \"(the base class is implicitly a type)\");\n       cp_lexer_consume_token (parser->lexer);\n     }\n@@ -14243,7 +14243,7 @@ cp_parser_lookup_name (cp_parser *parser, tree name,\n \t cp_parser_error, so we incorporate its actions directly.  */\n       if (!cp_parser_simulate_error (parser))\n \t{\n-\t  error (\"reference to `%D' is ambiguous\", name);\n+\t  error (\"reference to %qD is ambiguous\", name);\n \t  print_candidates (decl);\n \t}\n       return error_mark_node;\n@@ -15203,7 +15203,7 @@ cp_parser_late_parsing_default_args (cp_parser *parser, tree fn)\n \t there was extra junk after the end of the default\n \t argument.  */\n       if (!cp_lexer_next_token_is (parser->lexer, CPP_EOF))\n-\tcp_parser_error (parser, \"expected `,'\");\n+\tcp_parser_error (parser, \"expected %<,%>\");\n \n       /* Revert to the main lexer.  */\n       cp_parser_pop_lexer (parser);\n@@ -15572,7 +15572,7 @@ static void\n cp_parser_check_class_key (enum tag_types class_key, tree type)\n {\n   if ((TREE_CODE (type) == UNION_TYPE) != (class_key == union_type))\n-    pedwarn (\"`%s' tag used in naming `%#T'\",\n+    pedwarn (\"%qs tag used in naming %q#T\",\n \t    class_key == union_type ? \"union\"\n \t     : class_key == record_type ? \"struct\" : \"class\",\n \t     type);\n@@ -15583,7 +15583,8 @@ cp_parser_check_class_key (enum tag_types class_key, tree type)\n    This applies to nested classes and nested class templates.\n    [class.mem/1].  */\n \n-static void cp_parser_check_access_in_redeclaration (tree decl)\n+static void\n+cp_parser_check_access_in_redeclaration (tree decl)\n {\n   if (!CLASS_TYPE_P (TREE_TYPE (decl)))\n     return;\n@@ -15592,7 +15593,7 @@ static void cp_parser_check_access_in_redeclaration (tree decl)\n        != (current_access_specifier == access_private_node))\n       || (TREE_PROTECTED (decl)\n \t  != (current_access_specifier == access_protected_node)))\n-    error (\"%D redeclared with different access\", decl);\n+    error (\"%qD redeclared with different access\", decl);\n }\n \n /* Look for the `template' keyword, as a syntactic disambiguator.\n@@ -15609,7 +15610,7 @@ cp_parser_optional_template_keyword (cp_parser *parser)\n \t template and what is not.  */\n       if (!processing_template_decl)\n \t{\n-\t  error (\"`template' (as a disambiguator) is only allowed \"\n+\t  error (\"%<template%> (as a disambiguator) is only allowed \"\n \t\t \"within templates\");\n \t  /* If this part of the token stream is rescanned, the same\n \t     error message would be generated.  So, we purge the token"}, {"sha": "2d1277b402992fb2d44738ddea5f081665f65854", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a13a6258b1d75537b08a0286bd7719ae0a9ae1f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a13a6258b1d75537b08a0286bd7719ae0a9ae1f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2a13a6258b1d75537b08a0286bd7719ae0a9ae1f", "patch": "@@ -1,3 +1,9 @@\n+2004-10-05  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n+\n+\t* g++.dg/other/classkey1.C: Adjust quoting marks.\n+\t* g++.dg/parse/error15.C: Likewise.\n+\t* g++.dg/template/meminit2.C (int>): Likewise.\n+\n 2004-10-04  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n \n \tPR fortran/17283"}, {"sha": "80ab6756c7f4c5f7005678ca6188f56b6bc3e352", "filename": "gcc/testsuite/g++.dg/other/classkey1.C", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a13a6258b1d75537b08a0286bd7719ae0a9ae1f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fclasskey1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a13a6258b1d75537b08a0286bd7719ae0a9ae1f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fclasskey1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fclasskey1.C?ref=2a13a6258b1d75537b08a0286bd7719ae0a9ae1f", "patch": "@@ -6,12 +6,12 @@\n // PR 775. Some mismatches which were broken.\n \n template <class T> struct A {};\n-union A<int> a; // { dg-error \"`union' tag\" \"\" }\n+union A<int> a; // { dg-error \"'union' tag\" \"\" }\n \n-template <> union A<float> {}; // { dg-error \"`union' tag\" \"\" }\n+template <> union A<float> {}; // { dg-error \"'union' tag\" \"\" }\n \n struct B {};\n-union B b;\t// { dg-error \"`union' tag\" \"\" }\n+union B b;\t// { dg-error \"'union' tag\" \"\" }\n \n union C {};\n-class C c;\t// { dg-error \"`class' tag\" \"\" }\n+class C c;\t// { dg-error \"'class' tag\" \"\" }"}, {"sha": "b343970336f8d0033d5038245ca66a757249aefa", "filename": "gcc/testsuite/g++.dg/parse/error15.C", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a13a6258b1d75537b08a0286bd7719ae0a9ae1f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror15.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a13a6258b1d75537b08a0286bd7719ae0a9ae1f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror15.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror15.C?ref=2a13a6258b1d75537b08a0286bd7719ae0a9ae1f", "patch": "@@ -10,27 +10,27 @@ namespace N\n }\n \n N::A f2;              // { dg-error \"without an argument list\" }\n-N::INVALID f3;        // { dg-error \"in namespace `N' does not name a type\" }\n-N::C::INVALID f4;     // { dg-error \"in class `N::C' does not name a type\" }\n-N::K f6;              // { dg-error \"in namespace `N' does not name a type\" }\n+N::INVALID f3;        // { dg-error \"in namespace 'N' does not name a type\" }\n+N::C::INVALID f4;     // { dg-error \"in class 'N::C' does not name a type\" }\n+N::K f6;              // { dg-error \"in namespace 'N' does not name a type\" }\n typename N::A f7;     // { dg-error \"without an argument list|outside of template\" }\n \n struct B\n {\n   N::A f2;            // { dg-error \"without an argument list\" }\n-  N::INVALID f3;      // { dg-error \"in namespace `N' does not name a type\" }\n-  N::C::INVALID f4;   // { dg-error \"in class `N::C' does not name a type\" }\n-  N::K f6;            // { dg-error \"in namespace `N' does not name a type\" }\n+  N::INVALID f3;      // { dg-error \"in namespace 'N' does not name a type\" }\n+  N::C::INVALID f4;   // { dg-error \"in class 'N::C' does not name a type\" }\n+  N::K f6;            // { dg-error \"in namespace 'N' does not name a type\" }\n   typename N::A f7;   // { dg-error \"without an argument list|outside of template\" }\n };\n \n template <int>\n struct C\n {\n   N::A f2;            // { dg-error \"without an argument list\" }\n-  N::INVALID f3;      // { dg-error \"in namespace `N' does not name a type\" }\n-  N::C::INVALID f4;   // { dg-error \"in class `N::C' does not name a type\" }\n-  N::K f6;            // { dg-error \"in namespace `N' does not name a type\" }\n+  N::INVALID f3;      // { dg-error \"in namespace 'N' does not name a type\" }\n+  N::C::INVALID f4;   // { dg-error \"in class 'N::C' does not name a type\" }\n+  N::K f6;            // { dg-error \"in namespace 'N' does not name a type\" }\n   typename N::A f7;   // { dg-error \"without an argument list\" }\n };\n "}, {"sha": "b3cacbfacb51808ec8a707b662e70071fbc05c63", "filename": "gcc/testsuite/g++.dg/template/meminit2.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a13a6258b1d75537b08a0286bd7719ae0a9ae1f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fmeminit2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a13a6258b1d75537b08a0286bd7719ae0a9ae1f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fmeminit2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fmeminit2.C?ref=2a13a6258b1d75537b08a0286bd7719ae0a9ae1f", "patch": "@@ -7,8 +7,8 @@ template <typename K1> struct O {\n }; \n \n template <typename T> \n-struct A : typename O<T>::template I<int> {   // { dg-error \"keyword `typename' not allowed\" }\n-  A() :    typename O<T>::template I<int>()   // { dg-error \"keyword `typename' not allowed\" }\n+struct A : typename O<T>::template I<int> {   // { dg-error \"keyword 'typename' not allowed\" }\n+  A() :    typename O<T>::template I<int>()   // { dg-error \"keyword 'typename' not allowed\" }\n   {};\n };\n "}]}