{"sha": "57ece2583335d663e2787df4f6fe3804ec921ea9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTdlY2UyNTgzMzM1ZDY2M2UyNzg3ZGY0ZjZmZTM4MDRlYzkyMWVhOQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2010-07-14T17:00:51Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2010-07-14T17:00:51Z"}, "message": "Implement C++0x unrestricted unions (N2544)\n\n\tImplement C++0x unrestricted unions (N2544)\n\t* class.c (check_field_decl): Loosen union handling in C++0x.\n\t* method.c (walk_field_subobs): Split out from...\n\t(synthesized_method_walk): ...here.  Set msg before loops.\n\t(process_subob_fn): Check for triviality in union members.\n\t* init.c (sort_mem_initializers): Splice out uninitialized\n\tanonymous unions and union members.\n\t(push_base_cleanups): Don't automatically destroy anonymous unions\n\tand union members.\n\nFrom-SVN: r162187", "tree": {"sha": "152c38c98a68f7f49ca34046d6b08f92764dea84", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/152c38c98a68f7f49ca34046d6b08f92764dea84"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/57ece2583335d663e2787df4f6fe3804ec921ea9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57ece2583335d663e2787df4f6fe3804ec921ea9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57ece2583335d663e2787df4f6fe3804ec921ea9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57ece2583335d663e2787df4f6fe3804ec921ea9/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a9c5db803f4921a59f8a97307df66bd0f546ff42", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9c5db803f4921a59f8a97307df66bd0f546ff42", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9c5db803f4921a59f8a97307df66bd0f546ff42"}], "stats": {"total": 486, "additions": 360, "deletions": 126}, "files": [{"sha": "05a4dfa1dd35e38bc06f77c3c60aa57b185df0e8", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57ece2583335d663e2787df4f6fe3804ec921ea9/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57ece2583335d663e2787df4f6fe3804ec921ea9/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=57ece2583335d663e2787df4f6fe3804ec921ea9", "patch": "@@ -1,3 +1,15 @@\n+2010-07-14  Jason Merrill  <jason@redhat.com>\n+\n+\tImplement C++0x unrestricted unions (N2544)\n+\t* class.c (check_field_decl): Loosen union handling in C++0x.\n+\t* method.c (walk_field_subobs): Split out from...\n+\t(synthesized_method_walk): ...here.  Set msg before loops.\n+\t(process_subob_fn): Check for triviality in union members.\n+\t* init.c (sort_mem_initializers): Splice out uninitialized\n+\tanonymous unions and union members.\n+\t(push_base_cleanups): Don't automatically destroy anonymous unions\n+\tand union members.\n+\n 2010-07-13  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/44909"}, {"sha": "a572af83f637c3d4dfec909b03e7187f1b07af18", "filename": "gcc/cp/class.c", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57ece2583335d663e2787df4f6fe3804ec921ea9/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57ece2583335d663e2787df4f6fe3804ec921ea9/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=57ece2583335d663e2787df4f6fe3804ec921ea9", "patch": "@@ -2864,9 +2864,9 @@ check_field_decl (tree field,\n {\n   tree type = strip_array_types (TREE_TYPE (field));\n \n-  /* An anonymous union cannot contain any fields which would change\n+  /* In C++98 an anonymous union cannot contain any fields which would change\n      the settings of CANT_HAVE_CONST_CTOR and friends.  */\n-  if (ANON_UNION_TYPE_P (type))\n+  if (ANON_UNION_TYPE_P (type) && cxx_dialect < cxx0x)\n     ;\n   /* And, we don't set TYPE_HAS_CONST_COPY_CTOR, etc., for anonymous\n      structs.  So, we recurse through their fields here.  */\n@@ -2888,8 +2888,10 @@ check_field_decl (tree field,\n \t make it through without complaint.  */\n       abstract_virtuals_error (field, type);\n \n-      if (TREE_CODE (t) == UNION_TYPE)\n+      if (TREE_CODE (t) == UNION_TYPE && cxx_dialect < cxx0x)\n \t{\n+\t  static bool warned;\n+\t  int oldcount = errorcount;\n \t  if (TYPE_NEEDS_CONSTRUCTING (type))\n \t    error (\"member %q+#D with constructor not allowed in union\",\n \t\t   field);\n@@ -2898,8 +2900,12 @@ check_field_decl (tree field,\n \t  if (TYPE_HAS_COMPLEX_COPY_ASSIGN (type))\n \t    error (\"member %q+#D with copy assignment operator not allowed in union\",\n \t\t   field);\n-\t  /* Don't bother diagnosing move assop now; C++0x has more\n-\t     flexible unions.  */\n+\t  if (!warned && errorcount > oldcount)\n+\t    {\n+\t      inform (DECL_SOURCE_LOCATION (field), \"unrestricted unions \"\n+\t\t      \"only available with -std=c++0x or -std=gnu++0x\");\n+\t      warned = true;\n+\t    }\n \t}\n       else\n \t{"}, {"sha": "4e7cab382aafca1fd8310ceba9cdfa07787e3349", "filename": "gcc/cp/init.c", "status": "modified", "additions": 41, "deletions": 12, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57ece2583335d663e2787df4f6fe3804ec921ea9/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57ece2583335d663e2787df4f6fe3804ec921ea9/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=57ece2583335d663e2787df4f6fe3804ec921ea9", "patch": "@@ -708,38 +708,54 @@ sort_mem_initializers (tree t, tree mem_inits)\n \n      If a ctor-initializer specifies more than one mem-initializer for\n      multiple members of the same union (including members of\n-     anonymous unions), the ctor-initializer is ill-formed.  */\n+     anonymous unions), the ctor-initializer is ill-formed.\n+\n+     Here we also splice out uninitialized union members.  */\n   if (uses_unions_p)\n     {\n       tree last_field = NULL_TREE;\n-      for (init = sorted_inits; init; init = TREE_CHAIN (init))\n+      tree *p;\n+      for (p = &sorted_inits; *p; )\n \t{\n \t  tree field;\n \t  tree field_type;\n \t  int done;\n \n-\t  /* Skip uninitialized members and base classes.  */\n-\t  if (!TREE_VALUE (init)\n-\t      || TREE_CODE (TREE_PURPOSE (init)) != FIELD_DECL)\n-\t    continue;\n+\t  init = *p;\n+\n+\t  field = TREE_PURPOSE (init);\n+\n+\t  /* Skip base classes.  */\n+\t  if (TREE_CODE (field) != FIELD_DECL)\n+\t    goto next;\n+\n+\t  /* If this is an anonymous union with no explicit initializer,\n+\t     splice it out.  */\n+\t  if (!TREE_VALUE (init) && ANON_UNION_TYPE_P (TREE_TYPE (field)))\n+\t    goto splice;\n+\n \t  /* See if this field is a member of a union, or a member of a\n \t     structure contained in a union, etc.  */\n-\t  field = TREE_PURPOSE (init);\n \t  for (field_type = DECL_CONTEXT (field);\n \t       !same_type_p (field_type, t);\n \t       field_type = TYPE_CONTEXT (field_type))\n \t    if (TREE_CODE (field_type) == UNION_TYPE)\n \t      break;\n \t  /* If this field is not a member of a union, skip it.  */\n \t  if (TREE_CODE (field_type) != UNION_TYPE)\n-\t    continue;\n+\t    goto next;\n+\n+\t  /* If this union member has no explicit initializer, splice\n+\t     it out.  */\n+\t  if (!TREE_VALUE (init))\n+\t    goto splice;\n \n \t  /* It's only an error if we have two initializers for the same\n \t     union type.  */\n \t  if (!last_field)\n \t    {\n \t      last_field = field;\n-\t      continue;\n+\t      goto next;\n \t    }\n \n \t  /* See if LAST_FIELD and the field initialized by INIT are\n@@ -785,6 +801,13 @@ sort_mem_initializers (tree t, tree mem_inits)\n \t  while (!done);\n \n \t  last_field = field;\n+\n+\tnext:\n+\t  p = &TREE_CHAIN (*p);\n+\t  continue;\n+\tsplice:\n+\t  *p = TREE_CHAIN (*p);\n+\t  continue;\n \t}\n     }\n \n@@ -3353,21 +3376,27 @@ push_base_cleanups (void)\n       finish_decl_cleanup (NULL_TREE, expr);\n     }\n \n+  /* Don't automatically destroy union members.  */\n+  if (TREE_CODE (current_class_type) == UNION_TYPE)\n+    return;\n+\n   for (member = TYPE_FIELDS (current_class_type); member;\n        member = TREE_CHAIN (member))\n     {\n-      if (TREE_TYPE (member) == error_mark_node\n+      tree this_type = TREE_TYPE (member);\n+      if (this_type == error_mark_node\n \t  || TREE_CODE (member) != FIELD_DECL\n \t  || DECL_ARTIFICIAL (member))\n \tcontinue;\n-      if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (TREE_TYPE (member)))\n+      if (ANON_UNION_TYPE_P (this_type))\n+\tcontinue;\n+      if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (this_type))\n \t{\n \t  tree this_member = (build_class_member_access_expr\n \t\t\t      (current_class_ref, member,\n \t\t\t       /*access_path=*/NULL_TREE,\n \t\t\t       /*preserve_reference=*/false,\n \t\t\t       tf_warning_or_error));\n-\t  tree this_type = TREE_TYPE (member);\n \t  expr = build_delete (this_type, this_member,\n \t\t\t       sfk_complete_destructor,\n \t\t\t       LOOKUP_NONVIRTUAL|LOOKUP_DESTRUCTOR|LOOKUP_NORMAL,"}, {"sha": "9876af2c6cb99241131dc5c2f7de00230d1a3217", "filename": "gcc/cp/method.c", "status": "modified", "additions": 140, "deletions": 108, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57ece2583335d663e2787df4f6fe3804ec921ea9/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57ece2583335d663e2787df4f6fe3804ec921ea9/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=57ece2583335d663e2787df4f6fe3804ec921ea9", "patch": "@@ -545,7 +545,8 @@ do_build_copy_constructor (tree fndecl)\n \t    }\n \t  else if (ANON_AGGR_TYPE_P (expr_type) && TYPE_FIELDS (expr_type))\n \t    /* Just use the field; anonymous types can't have\n-\t       nontrivial copy ctors or assignment ops.  */;\n+\t       nontrivial copy ctors or assignment ops or this\n+\t       function would be deleted.  */;\n \t  else\n \t    continue;\n \n@@ -663,7 +664,8 @@ do_build_copy_assign (tree fndecl)\n \t  else if (ANON_AGGR_TYPE_P (expr_type)\n \t\t   && TYPE_FIELDS (expr_type) != NULL_TREE)\n \t    /* Just use the field; anonymous types can't have\n-\t       nontrivial copy ctors or assignment ops.  */;\n+\t       nontrivial copy ctors or assignment ops or this\n+\t       function would be deleted.  */;\n \t  else\n \t    continue;\n \n@@ -912,8 +914,19 @@ process_subob_fn (tree fn, bool move_p, tree *spec_p, bool *trivial_p,\n       *spec_p = merge_exception_specifiers (*spec_p, raises);\n     }\n \n-  if (trivial_p && !trivial_fn_p (fn))\n-    *trivial_p = false;\n+  if (!trivial_fn_p (fn))\n+    {\n+      if (trivial_p)\n+\t*trivial_p = false;\n+      if (TREE_CODE (arg) == FIELD_DECL\n+\t  && TREE_CODE (DECL_CONTEXT (arg)) == UNION_TYPE)\n+\t{\n+\t  if (deleted_p)\n+\t    *deleted_p = true;\n+\t  if (msg)\n+\t    error (\"union member %q+D with non-trivial %qD\", arg, fn);\n+\t}\n+    }\n \n   if (move_p && !move_fn_p (fn) && !trivial_fn_p (fn))\n     {\n@@ -929,6 +942,99 @@ process_subob_fn (tree fn, bool move_p, tree *spec_p, bool *trivial_p,\n     *deleted_p = true;\n }\n \n+/* Subroutine of synthesized_method_walk to allow recursion into anonymous\n+   aggregates.  */\n+\n+static void\n+walk_field_subobs (tree fields, tree fnname, special_function_kind sfk,\n+\t\t   int quals, bool copy_arg_p, bool move_p,\n+\t\t   bool assign_p, tree *spec_p, bool *trivial_p,\n+\t\t   bool *deleted_p, const char *msg,\n+\t\t   int flags, tsubst_flags_t complain)\n+{\n+  tree field;\n+  for (field = fields; field; field = TREE_CHAIN (field))\n+    {\n+      tree mem_type, argtype, rval;\n+\n+      if (TREE_CODE (field) != FIELD_DECL\n+\t  || DECL_ARTIFICIAL (field))\n+\tcontinue;\n+\n+      mem_type = strip_array_types (TREE_TYPE (field));\n+      if (assign_p)\n+\t{\n+\t  bool bad = true;\n+\t  if (CP_TYPE_CONST_P (mem_type) && !CLASS_TYPE_P (mem_type))\n+\t    {\n+\t      if (msg)\n+\t\terror (\"non-static const member %q#D, can't use default \"\n+\t\t       \"assignment operator\", field);\n+\t    }\n+\t  else if (TREE_CODE (mem_type) == REFERENCE_TYPE)\n+\t    {\n+\t      if (msg)\n+\t\terror (\"non-static reference member %q#D, can't use \"\n+\t\t       \"default assignment operator\", field);\n+\t    }\n+\t  else\n+\t    bad = false;\n+\n+\t  if (bad && deleted_p)\n+\t    *deleted_p = true;\n+\t}\n+      else if (sfk == sfk_constructor)\n+\t{\n+\t  bool bad = true;\n+\t  if (CP_TYPE_CONST_P (mem_type)\n+\t      && (!CLASS_TYPE_P (mem_type)\n+\t\t  || !type_has_user_provided_default_constructor (mem_type)))\n+\t    {\n+\t      if (msg)\n+\t\terror (\"uninitialized non-static const member %q#D\",\n+\t\t       field);\n+\t    }\n+\t  else if (TREE_CODE (mem_type) == REFERENCE_TYPE)\n+\t    {\n+\t      if (msg)\n+\t\terror (\"uninitialized non-static reference member %q#D\",\n+\t\t       field);\n+\t    }\n+\t  else\n+\t    bad = false;\n+\n+\t  if (bad && deleted_p)\n+\t    *deleted_p = true;\n+\t}\n+\n+      if (!CLASS_TYPE_P (mem_type))\n+\tcontinue;\n+\n+      if (ANON_AGGR_TYPE_P (mem_type))\n+\t{\n+\t  walk_field_subobs (TYPE_FIELDS (mem_type), fnname, sfk, quals,\n+\t\t\t     copy_arg_p, move_p, assign_p, spec_p, trivial_p,\n+\t\t\t     deleted_p, msg, flags, complain);\n+\t  continue;\n+\t}\n+\n+      if (copy_arg_p)\n+\t{\n+\t  int mem_quals = cp_type_quals (mem_type) | quals;\n+\t  if (DECL_MUTABLE_P (field))\n+\t    mem_quals &= ~TYPE_QUAL_CONST;\n+\t  argtype = build_stub_type (mem_type, mem_quals, move_p);\n+\t}\n+      else\n+\targtype = NULL_TREE;\n+\n+      rval = locate_fn_flags (mem_type, fnname, argtype, flags, complain);\n+\n+      process_subob_fn (rval, move_p, spec_p, trivial_p, deleted_p,\n+\t\t\tmsg, field);\n+    }\n+}\n+\n /* The caller wants to generate an implicit declaration of SFK for CTYPE\n    which is const if relevant and CONST_P is set.  If spec_p, trivial_p and\n    deleted_p are non-null, set their referent appropriately.  If diag is\n@@ -940,7 +1046,7 @@ synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,\n \t\t\t tree *spec_p, bool *trivial_p, bool *deleted_p,\n \t\t\t bool diag)\n {\n-  tree binfo, base_binfo, field, scope, fnname, rval, argtype;\n+  tree binfo, base_binfo, scope, fnname, rval, argtype;\n   bool move_p, copy_arg_p, assign_p, expected_trivial, check_vdtor;\n   VEC(tree,gc) *vbases;\n   int i, quals, flags;\n@@ -1052,6 +1158,15 @@ synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,\n     quals = TYPE_UNQUALIFIED;\n   argtype = NULL_TREE;\n \n+  if (!diag)\n+    msg = NULL;\n+  else if (assign_p)\n+    msg = (\"base %qT does not have a move assignment operator or trivial \"\n+\t   \"copy assignment operator\");\n+  else\n+    msg = (\"base %qT does not have a move constructor or trivial \"\n+\t   \"copy constructor\");\n+\n   for (binfo = TYPE_BINFO (ctype), i = 0;\n        BINFO_BASE_ITERATE (binfo, i, base_binfo); ++i)\n     {\n@@ -1060,15 +1175,6 @@ synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,\n \targtype = build_stub_type (basetype, quals, move_p);\n       rval = locate_fn_flags (base_binfo, fnname, argtype, flags, complain);\n \n-      if (!diag)\n-\tmsg = NULL;\n-      else if (assign_p)\n-\tmsg = (\"base %qT does not have a move assignment operator or trivial \"\n-\t       \"copy assignment operator\");\n-      else\n-\tmsg = (\"base %qT does not have a move constructor or trivial \"\n-\t       \"copy constructor\");\n-\n       process_subob_fn (rval, move_p, spec_p, trivial_p, deleted_p,\n \t\t\tmsg, BINFO_TYPE (base_binfo));\n \n@@ -1094,105 +1200,31 @@ synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,\n \t*deleted_p = true;\n     }\n   else if (!assign_p)\n-    for (i = 0; VEC_iterate (tree, vbases, i, base_binfo); ++i)\n-      {\n-\tif (copy_arg_p)\n-\t  argtype = build_stub_type (BINFO_TYPE (base_binfo), quals, move_p);\n-\trval = locate_fn_flags (base_binfo, fnname, argtype, flags, complain);\n-\n-\tif (!diag)\n-\t  msg = NULL;\n-\telse if (assign_p)\n-\t  msg = (\"virtual base %qT does not have a move assignment \"\n-\t\t \"operator or trivial copy assignment operator\");\n-\telse\n-\t  msg = (\"virtual base %qT does not have a move constructor \"\n-\t\t \"or trivial copy constructor\");\n-\n-\tprocess_subob_fn (rval, move_p, spec_p, trivial_p, deleted_p,\n-\t\t\t  msg, BINFO_TYPE (base_binfo));\n-      }\n-\n-  for (field = TYPE_FIELDS (ctype); field; field = TREE_CHAIN (field))\n     {\n-      tree mem_type;\n-\n-      if (TREE_CODE (field) != FIELD_DECL\n-\t  || DECL_ARTIFICIAL (field))\n-\tcontinue;\n-\n-      mem_type = strip_array_types (TREE_TYPE (field));\n-      if (assign_p)\n+      if (diag)\n+\tmsg = (\"virtual base %qT does not have a move constructor \"\n+\t       \"or trivial copy constructor\");\n+      for (i = 0; VEC_iterate (tree, vbases, i, base_binfo); ++i)\n \t{\n-\t  bool bad = true;\n-\t  if (CP_TYPE_CONST_P (mem_type) && !CLASS_TYPE_P (mem_type))\n-\t    {\n-\t      if (diag)\n-\t\terror (\"non-static const member %q#D, can't use default \"\n-\t\t       \"assignment operator\", field);\n-\t    }\n-\t  else if (TREE_CODE (mem_type) == REFERENCE_TYPE)\n-\t    {\n-\t      if (diag)\n-\t\terror (\"non-static reference member %q#D, can't use \"\n-\t\t       \"default assignment operator\", field);\n-\t    }\n-\t  else\n-\t    bad = false;\n+\t  if (copy_arg_p)\n+\t    argtype = build_stub_type (BINFO_TYPE (base_binfo), quals, move_p);\n+\t  rval = locate_fn_flags (base_binfo, fnname, argtype, flags, complain);\n \n-\t  if (bad && deleted_p)\n-\t    *deleted_p = true;\n+\t  process_subob_fn (rval, move_p, spec_p, trivial_p, deleted_p,\n+\t\t\t    msg, BINFO_TYPE (base_binfo));\n \t}\n-      else if (sfk == sfk_constructor)\n-\t{\n-\t  bool bad = true;\n-\t  if (CP_TYPE_CONST_P (mem_type)\n-\t      && (!CLASS_TYPE_P (mem_type)\n-\t\t  || !type_has_user_provided_default_constructor (mem_type)))\n-\t    {\n-\t      if (diag)\n-\t\terror (\"uninitialized non-static const member %q#D\",\n-\t\t       field);\n-\t    }\n-\t  else if (TREE_CODE (mem_type) == REFERENCE_TYPE)\n-\t    {\n-\t      if (diag)\n-\t\terror (\"uninitialized non-static reference member %q#D\",\n-\t\t       field);\n-\t    }\n-\t  else\n-\t    bad = false;\n-\n-\t  if (bad && deleted_p)\n-\t    *deleted_p = true;\n-\t}\n-\n-      if (!CLASS_TYPE_P (mem_type)\n-\t  || ANON_AGGR_TYPE_P (mem_type))\n-\tcontinue;\n-\n-      if (copy_arg_p)\n-\t{\n-\t  int mem_quals = cp_type_quals (mem_type) | quals;\n-\t  if (DECL_MUTABLE_P (field))\n-\t    mem_quals &= ~TYPE_QUAL_CONST;\n-\t  argtype = build_stub_type (mem_type, mem_quals, move_p);\n-\t}\n-\n-      rval = locate_fn_flags (mem_type, fnname, argtype, flags, complain);\n-\n-      if (!diag)\n-\tmsg = NULL;\n-      else if (assign_p)\n-\tmsg = (\"non-static data member %qD does not have a move \"\n-\t       \"assignment operator or trivial copy assignment operator\");\n-      else\n-\tmsg = (\"non-static data member %qD does not have a move \"\n-\t       \"constructor or trivial copy constructor\");\n-\n-      process_subob_fn (rval, move_p, spec_p, trivial_p, deleted_p,\n-\t\t\tmsg, field);\n     }\n+  if (!diag)\n+    /* Leave msg null. */;\n+  else if (assign_p)\n+    msg = (\"non-static data member %qD does not have a move \"\n+\t   \"assignment operator or trivial copy assignment operator\");\n+  else\n+    msg = (\"non-static data member %qD does not have a move \"\n+\t   \"constructor or trivial copy constructor\");\n+  walk_field_subobs (TYPE_FIELDS (ctype), fnname, sfk, quals,\n+\t\t     copy_arg_p, move_p, assign_p, spec_p, trivial_p,\n+\t\t     deleted_p, msg, flags, complain);\n \n   pop_scope (scope);\n "}, {"sha": "6b878c5f31943d4f453077b207ffe3417cf04283", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57ece2583335d663e2787df4f6fe3804ec921ea9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57ece2583335d663e2787df4f6fe3804ec921ea9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=57ece2583335d663e2787df4f6fe3804ec921ea9", "patch": "@@ -1,3 +1,14 @@\n+2010-07-14  Jason Merrill  <jason@redhat.com>\n+\n+\tImplement C++0x unrestricted unions (N2544)\n+\t* g++.dg/cpp0x/union1.C: New.\n+\t* g++.dg/cpp0x/union2.C: New.\n+\t* g++.dg/cpp0x/union3.C: New.\n+\t* g++.dg/cpp0x/defaulted2.C: Adjust.\n+\t* g++.old-deja/g++.bugs/900121_02.C: Adjust.\n+\t* g++.old-deja/g++.ext/anon2.C: Adjust.\n+\t* g++.old-deja/g++.mike/misc6.C: Adjust.\n+\n 2010-07-14  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/44925"}, {"sha": "1f400f4fad0abd605681917e1a97402789564df3", "filename": "gcc/testsuite/g++.dg/cpp0x/defaulted2.C", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57ece2583335d663e2787df4f6fe3804ec921ea9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdefaulted2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57ece2583335d663e2787df4f6fe3804ec921ea9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdefaulted2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdefaulted2.C?ref=57ece2583335d663e2787df4f6fe3804ec921ea9", "patch": "@@ -54,13 +54,15 @@ G::G() = default;\n \n union U\n {\n-  G g;\t\t\t\t// { dg-error \"constructor\" }\n+  G g;\t\t\t\t// { dg-error \"union member.*non-trivial\" }\n };\n \n int main()\n {\n   F f;\n   F f2(f);\t\t\t// { dg-error \"use\" }\n   B* b = new const B;\t\t// { dg-error \"uninitialized const\" }\n+  U u;\t\t\t\t// { dg-error \"deleted\" }\n }\n \n+// { dg-prune-output \"implicitly deleted because\" }"}, {"sha": "291853d5aaeb6c86385480711f3ed397ad9707aa", "filename": "gcc/testsuite/g++.dg/cpp0x/union1.C", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57ece2583335d663e2787df4f6fe3804ec921ea9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Funion1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57ece2583335d663e2787df4f6fe3804ec921ea9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Funion1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Funion1.C?ref=57ece2583335d663e2787df4f6fe3804ec921ea9", "patch": "@@ -0,0 +1,34 @@\n+// Negative test for C++0x unrestricted unions\n+// { dg-options -std=c++0x }\n+// { dg-prune-output \"implicitly deleted because\" }\n+\n+struct A\n+{\n+  A();\n+  A(const A&);\n+  ~A();\n+};\n+\n+union B\n+{\n+  A a;\t\t\t\t// { dg-error \"union member\" }\n+};\n+\n+B b;\t\t\t\t// { dg-error \"B::B\\\\(\\\\)\" }\n+B b2(b);\t\t\t// { dg-error \"B::B\\\\(const B&\\\\)\" }\n+\n+struct C\n+{\n+  union\n+  {\n+    A a;\t\t\t// { dg-error \"union member\" }\n+  };\n+};\n+\n+C c;\t\t\t\t// { dg-error \"C::C\\\\(\\\\)\" }\n+C c2(c);\t\t\t// { dg-error \"C::C\\\\(const C&\\\\)\" }\n+\n+// { dg-error \"B::~B\" \"\" { target *-*-* } 17 }\n+// { dg-error \"B::~B\" \"\" { target *-*-* } 18 }\n+// { dg-error \"C::~C\" \"\" { target *-*-* } 28 }\n+// { dg-error \"C::~C\" \"\" { target *-*-* } 29 }"}, {"sha": "4f193e281c8aefa1a17a71d4b71184180a24cf08", "filename": "gcc/testsuite/g++.dg/cpp0x/union2.C", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57ece2583335d663e2787df4f6fe3804ec921ea9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Funion2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57ece2583335d663e2787df4f6fe3804ec921ea9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Funion2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Funion2.C?ref=57ece2583335d663e2787df4f6fe3804ec921ea9", "patch": "@@ -0,0 +1,34 @@\n+// Positive test for C++0x unrestricted unions\n+// { dg-options -std=c++0x }\n+\n+struct A\n+{\n+  A();\n+  A(const A&);\n+  ~A();\n+};\n+\n+union B\n+{\n+  A a;\n+  B();\n+  B(const B&);\n+  ~B();\n+};\n+\n+B b;\n+B b2(b);\n+\n+struct C\n+{\n+  union\n+  {\n+    A a;\n+  };\n+  C();\n+  C(const C&);\n+  ~C();\n+};\n+\n+C c;\n+C c2(c);"}, {"sha": "f1e8ddb610930c5b6c8b8e6b4ea6b18c8be88b34", "filename": "gcc/testsuite/g++.dg/cpp0x/union3.C", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57ece2583335d663e2787df4f6fe3804ec921ea9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Funion3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57ece2583335d663e2787df4f6fe3804ec921ea9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Funion3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Funion3.C?ref=57ece2583335d663e2787df4f6fe3804ec921ea9", "patch": "@@ -0,0 +1,69 @@\n+// Runtime test for C++0x unrestricted unions\n+// { dg-options -std=c++0x }\n+// { dg-do run }\n+\n+int c, d;\n+struct A\n+{\n+  int i;\n+  A(): i(1) { ++c; }\n+  A(const A&): i(2) { ++c; }\n+  ~A() { ++d; }\n+};\n+\n+union B\n+{\n+  A a;\n+  B() { }\n+  B(const B& b) { }\n+  ~B() { }\n+};\n+\n+struct C\n+{\n+  union { A a; };\n+  C() { }\n+  C(const C&) { }\n+  ~C() { }\n+};\n+\n+union D\n+{\n+  A a;\n+  D(): a() { }\n+  D(const D& d): a(d.a) { }\n+  ~D() { a.~A(); }\n+};\n+\n+struct E\n+{\n+  union { A a; };\n+  E(): a() { }\n+  E(const E& e): a (e.a) { }\n+  ~E() { a.~A(); }\n+};\n+\n+int main()\n+{\n+  {\n+    B b1;\n+    B b2(b1);\n+\n+    C c1;\n+    C c2(c1);\n+  }\n+\n+  if (c != 0 || d != 0)\n+    return c+d*10;\n+\n+  {\n+    D d1;\n+    D d2(d1);\n+\n+    E e1;\n+    E e2(e1);\n+  }\n+\n+  if (c != 4 || d != 4)\n+    return c*100+d*1000;\n+}"}, {"sha": "1a96e8e3b0675af9d35326db16bfba9094639faf", "filename": "gcc/testsuite/g++.old-deja/g++.bugs/900121_02.C", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57ece2583335d663e2787df4f6fe3804ec921ea9/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.bugs%2F900121_02.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57ece2583335d663e2787df4f6fe3804ec921ea9/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.bugs%2F900121_02.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.bugs%2F900121_02.C?ref=57ece2583335d663e2787df4f6fe3804ec921ea9", "patch": "@@ -1,4 +1,6 @@\n // { dg-do assemble  }\n+// { dg-prune-output \"note\" }\n+\n // g++ 1.36.1 bug 900121_02\n \n // Assignment of structs is defined as memberwise assignment,"}, {"sha": "5bde08db9523de532f7a215195384f817878c021", "filename": "gcc/testsuite/g++.old-deja/g++.ext/anon2.C", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57ece2583335d663e2787df4f6fe3804ec921ea9/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.ext%2Fanon2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57ece2583335d663e2787df4f6fe3804ec921ea9/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.ext%2Fanon2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.ext%2Fanon2.C?ref=57ece2583335d663e2787df4f6fe3804ec921ea9", "patch": "@@ -1,5 +1,6 @@\n // { dg-do assemble  }\n // { dg-options \"\" }\n+// { dg-prune-output \"note\" }\n \n struct S \n {"}, {"sha": "1a07c12b34afb1bfa4f81ce0224235f1f33822c3", "filename": "gcc/testsuite/g++.old-deja/g++.mike/misc6.C", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57ece2583335d663e2787df4f6fe3804ec921ea9/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.mike%2Fmisc6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57ece2583335d663e2787df4f6fe3804ec921ea9/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.mike%2Fmisc6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.mike%2Fmisc6.C?ref=57ece2583335d663e2787df4f6fe3804ec921ea9", "patch": "@@ -1,4 +1,6 @@\n // { dg-do assemble  }\n+// { dg-prune-output \"note\" }\n+\n // GROUPS uncaught\n // Cfront bug A.4 (See Language System Release Notes for the\n // SPARCompiler C++ version 3.0)"}]}