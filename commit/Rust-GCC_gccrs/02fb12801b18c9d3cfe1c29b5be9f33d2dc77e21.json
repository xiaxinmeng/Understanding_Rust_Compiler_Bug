{"sha": "02fb12801b18c9d3cfe1c29b5be9f33d2dc77e21", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDJmYjEyODAxYjE4YzlkM2NmZTFjMjliNWJlOWYzM2QyZGM3N2UyMQ==", "commit": {"author": {"name": "Piotr Trojanek", "email": "trojanek@adacore.com", "date": "2020-09-24T20:25:18Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-11-24T10:15:59Z"}, "message": "[Ada] Remove SPARK-specific expansion of array aggregates\n\ngcc/ada/\n\n\t* exp_spark.adb (Expand_SPARK_Array_Aggregate,\n\tExpand_SPARK_N_Aggregate): Remove, no longer needed.\n\t* sem_aggr.adb (Resolve_Iterated_Component_Association): Only\n\tremove references in the analyzed expression when generating\n\tcode and the expression needs to be analyzed anew after being\n\trewritten into a loop.", "tree": {"sha": "f7279e63c49caf15cc4739f0446f7244b6875d82", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f7279e63c49caf15cc4739f0446f7244b6875d82"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/02fb12801b18c9d3cfe1c29b5be9f33d2dc77e21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02fb12801b18c9d3cfe1c29b5be9f33d2dc77e21", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02fb12801b18c9d3cfe1c29b5be9f33d2dc77e21", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02fb12801b18c9d3cfe1c29b5be9f33d2dc77e21/comments", "author": {"login": "ptroja", "id": 161602, "node_id": "MDQ6VXNlcjE2MTYwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/161602?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ptroja", "html_url": "https://github.com/ptroja", "followers_url": "https://api.github.com/users/ptroja/followers", "following_url": "https://api.github.com/users/ptroja/following{/other_user}", "gists_url": "https://api.github.com/users/ptroja/gists{/gist_id}", "starred_url": "https://api.github.com/users/ptroja/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ptroja/subscriptions", "organizations_url": "https://api.github.com/users/ptroja/orgs", "repos_url": "https://api.github.com/users/ptroja/repos", "events_url": "https://api.github.com/users/ptroja/events{/privacy}", "received_events_url": "https://api.github.com/users/ptroja/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2307a1aeb8ecaf0bac055a13d65eef884cbf22b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2307a1aeb8ecaf0bac055a13d65eef884cbf22b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2307a1aeb8ecaf0bac055a13d65eef884cbf22b3"}], "stats": {"total": 141, "additions": 9, "deletions": 132}, "files": [{"sha": "883a819ec7997b7f6da6af0ecffc2d3700c1410a", "filename": "gcc/ada/exp_spark.adb", "status": "modified", "additions": 0, "deletions": 126, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02fb12801b18c9d3cfe1c29b5be9f33d2dc77e21/gcc%2Fada%2Fexp_spark.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02fb12801b18c9d3cfe1c29b5be9f33d2dc77e21/gcc%2Fada%2Fexp_spark.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_spark.adb?ref=02fb12801b18c9d3cfe1c29b5be9f33d2dc77e21", "patch": "@@ -52,16 +52,6 @@ package body Exp_SPARK is\n    -- Local Subprograms --\n    -----------------------\n \n-   procedure Expand_SPARK_Array_Aggregate (N : Node_Id; Index : Node_Id);\n-   --  Perform array-aggregate-specific expansion of an array sub-aggregate N\n-   --  corresponding to the Index of the outer-most aggregate. This routine\n-   --  mimics Resolve_Array_Aggregate which only checks the aggregate for being\n-   --  well-formed, but doesn't analyze nor apply range checks to\n-   --  iterated_component_associations.\n-\n-   procedure Expand_SPARK_N_Aggregate (N : Node_Id);\n-   --  Perform aggregate-specific expansion\n-\n    procedure Expand_SPARK_N_Attribute_Reference (N : Node_Id);\n    --  Perform attribute-reference-specific expansion\n \n@@ -112,9 +102,6 @@ package body Exp_SPARK is\n          =>\n             Qualify_Entity_Names (N);\n \n-         when N_Aggregate =>\n-            Expand_SPARK_N_Aggregate (N);\n-\n          --  Replace occurrences of System'To_Address by calls to\n          --  System.Storage_Elements.To_Address.\n \n@@ -160,107 +147,6 @@ package body Exp_SPARK is\n       end case;\n    end Expand_SPARK;\n \n-   ----------------------------------\n-   -- Expand_SPARK_Array_Aggregate --\n-   ----------------------------------\n-\n-   procedure Expand_SPARK_Array_Aggregate (N : Node_Id; Index : Node_Id) is\n-\n-      procedure Expand_Aggr_Expr (Expr : Node_Id);\n-      --  If Expr is a subaggregate, then process it recursively; otherwise it\n-      --  is an expression for the array components which might not have been\n-      --  analyzed and where scalar range checks could be missing.\n-\n-      ----------------------\n-      -- Expand_Aggr_Expr --\n-      ----------------------\n-\n-      procedure Expand_Aggr_Expr (Expr : Node_Id) is\n-         Nxt_Ind : constant Node_Id := Next_Index (Index);\n-      begin\n-         if Present (Nxt_Ind) then\n-            Expand_SPARK_Array_Aggregate (Expr, Index => Nxt_Ind);\n-         else\n-            declare\n-               Comp_Type : constant Entity_Id := Component_Type (Etype (N));\n-            begin\n-               Analyze_And_Resolve (Expr, Comp_Type);\n-\n-               if Is_Scalar_Type (Comp_Type) then\n-                  Apply_Scalar_Range_Check (Expr, Comp_Type);\n-               end if;\n-            end;\n-         end if;\n-      end Expand_Aggr_Expr;\n-\n-      --  Local variables\n-\n-      Assoc : Node_Id := First (Component_Associations (N));\n-\n-   --  Start of processing for Expand_SPARK_Array_Aggregate\n-\n-   begin\n-      while Present (Assoc) loop\n-         --  For iterated_component_association we must apply range check to\n-         --  discrete choices and re-analyze the expression, because frontend\n-         --  only checks its legality and then analyzes the expanded loop code.\n-\n-         if Nkind (Assoc) = N_Iterated_Component_Association then\n-            declare\n-               Choice : Node_Id;\n-            begin\n-               --  Analyze discrete choices\n-\n-               Choice := First (Discrete_Choices (Assoc));\n-\n-               while Present (Choice) loop\n-\n-                  --  The index denotes a range of elements where range checks\n-                  --  have been already applied.\n-\n-                  if Nkind (Choice) in N_Others_Choice\n-                                     | N_Range\n-                                     | N_Subtype_Indication\n-                  then\n-                     null;\n-\n-                  --  Otherwise the index denotes a single element (or a\n-                  --  subtype name which doesn't require range checks).\n-\n-                  else pragma Assert (Nkind (Choice) in N_Subexpr);\n-                     Apply_Scalar_Range_Check (Choice, Etype (Index));\n-                  end if;\n-\n-                  Next (Choice);\n-               end loop;\n-\n-               --  Keep processing the expression with index parameter in scope\n-\n-               Push_Scope (Scope (Defining_Identifier (Assoc)));\n-               Enter_Name (Defining_Identifier (Assoc));\n-               Expand_Aggr_Expr (Expression (Assoc));\n-               End_Scope;\n-            end;\n-\n-         --  For ordinary component associations we recurse into subaggregates,\n-         --  because there could be nested iterated_component_association (and\n-         --  it is harmless to analyze and apply checks if there is none).\n-\n-         else pragma Assert (Nkind (Assoc) = N_Component_Association);\n-            declare\n-               Expr : constant Node_Id := Expression (Assoc);\n-               pragma Assert (Present (Expr) xor Box_Present (Assoc));\n-            begin\n-               if Present (Expr) then\n-                  Expand_Aggr_Expr (Expr);\n-               end if;\n-            end;\n-         end if;\n-\n-         Next (Assoc);\n-      end loop;\n-   end Expand_SPARK_Array_Aggregate;\n-\n    ----------------------------------\n    -- Expand_SPARK_Delta_Or_Update --\n    ----------------------------------\n@@ -475,18 +361,6 @@ package body Exp_SPARK is\n       end if;\n    end Expand_SPARK_N_Freeze_Type;\n \n-   ------------------------------\n-   -- Expand_SPARK_N_Aggregate --\n-   ------------------------------\n-\n-   procedure Expand_SPARK_N_Aggregate (N : Node_Id) is\n-      Aggr_Typ : constant Entity_Id := Etype (N);\n-   begin\n-      if Is_Array_Type (Aggr_Typ) then\n-         Expand_SPARK_Array_Aggregate (N, Index => First_Index (Aggr_Typ));\n-      end if;\n-   end Expand_SPARK_N_Aggregate;\n-\n    ----------------------------------------\n    -- Expand_SPARK_N_Attribute_Reference --\n    ----------------------------------------"}, {"sha": "3f96139e3225d2789101f3b73426301309ab8102", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02fb12801b18c9d3cfe1c29b5be9f33d2dc77e21/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02fb12801b18c9d3cfe1c29b5be9f33d2dc77e21/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=02fb12801b18c9d3cfe1c29b5be9f33d2dc77e21", "patch": "@@ -1680,18 +1680,21 @@ package body Sem_Aggr is\n          Set_Ekind (Id, E_Variable);\n          Set_Scope (Id, Ent);\n \n-         --  Analyze the expression without expansion, to verify legality.\n-         --  After analysis we remove references to the index variable because\n-         --  the expression will be analyzed anew when the enclosing aggregate\n-         --  is expanded, and the construct is rewritten as a loop with a new\n-         --  index variable.\n+         --  Analyze  expression without expansion, to verify legality.\n+         --  When generating code, we then remove references to the index\n+         --  variable, because the expression will be analyzed anew after\n+         --  rewritting as a loop with a new index variable; when not\n+         --  generating code we leave the analyzed expression as it is.\n \n          Expr := Expression (N);\n \n          Expander_Mode_Save_And_Set (False);\n          Dummy := Resolve_Aggr_Expr (Expr, Single_Elmt => False);\n          Expander_Mode_Restore;\n-         Remove_References (Expr);\n+\n+         if Operating_Mode /= Check_Semantics then\n+            Remove_References (Expr);\n+         end if;\n \n          --  An iterated_component_association may appear in a nested\n          --  aggregate for a multidimensional structure: preserve the bounds"}]}