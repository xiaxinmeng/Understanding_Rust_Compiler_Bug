{"sha": "6399c0abb3e562d7dc9cbf2f85998965dac1a1cb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjM5OWMwYWJiM2U1NjJkN2RjOWNiZjJmODU5OTg5NjVkYWMxYTFjYg==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-05-29T15:36:18Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-05-29T15:36:18Z"}, "message": "integrate.c: Remove.\n\n\t* integrate.c: Remove.\n\t* integrate.h: Remove.\n\t* Makefile.in: Remove make rules for integrate.c and INTEGRATE_H.\n\t* config/arm/t-arm: Remove INTEGRATE_H dependency for target files.\n\t* config/rs6000/t-rs6000: Likewise\n\t* config/spu/t-spu-elf: Likewise.\n\t* function.h (get_hard_reg_initial_val, has_hard_reg_initial_val,\n\tget_hard_reg_initial_reg, emit_initial_value_sets): Move prototypes\n\tfrom integrate.h to here.\n\t(initial_value_entry): New prototype.\n\t* reload.h (allocate_initial_values): Remove prototype.\n\t* tree.h (set_decl_abstract_flags, set_decl_origin_self): Likewise.\n\t* cse.c (fixed_base_plus_p): Don't handle virtual registers for\n\tintegrate.c.\n\t* dwarf2out.c (set_decl_origin_self, set_block_origin_self,\n\tset_decl_abstract_flags, set_block_abstract_flags): Move from\n\tintegrate.c to here, the only user.\n\t* expmed.c (extract_fixed_bit_field): Remove outdated comment\n\tabout integrate.c.\n\t* function.c: Don't include integrate.h.\n\t(struct initial_value_pair, struct initial_value_struct,\n\tget_hard_reg_initial_val, has_hard_reg_initial_val,\n\tget_hard_reg_initial_reg, emit_initial_value_sets): Move from\n\tintegrate.c to here.\n\t(initial_value_entry): New function.\n\t* genemit.c (main): Don't print integrate.h include line.\n\t* ira.c: Don't include integrate.h.\n\t(allocate_initial_values): Move from integrate.c to here.\n\t(ira): Update allocate_initial_values call.\n\t* tree-inline.c: Don't include integrate.h.\n\t(function_attribute_inlinable_p): Moved from integrate.c to here.\n\t* cfgexpand.c: Don't include integrate.h.\n\t* except.c: Likewise.\n\t* langhooks.c: Likewise.\n\t* passes.c: Likewise.\n\t* toplev.c: Likewise.\n\t* config/frv/frv.c: Likewise.\n\t* config/pa/pa.c: Likewise.\n\t* config/spu/spu.c: Likewise.\n\t* config/epiphany/epiphany.c: Likewise.\n\t* config/mep/mep.c: Likewise.\n\t* config/score/score.c: Likewise.\n\t* config/picochip/picochip.c: Likewise.\n\t* config/sh/sh.c: Likewise.\n\t* config/alpha/alpha.c: Likewise.\n\t* config/microblaze/microblaze.c: Likewise.\n\t* config/mips/mips.c: Likewise.\n\t* config/v850/v850.c: Likewise.\n\t* config/mmix/mmix.c: Likewise.\n\t* config/bfin/bfin.c: Likewise.\n\t* config/arm/arm.c: Likewise.\n\t* config/s390/s390.c: Likewise.\n\t* config/m32r/m32r.c: Likewise.\n\t* config/rs6000/rs6000.c: Likewise.\n\t* config/c6x/c6x.c: Include function.h instead of integrate.h.\n\t* config/tilegx/tilegx.c: Likewise.\n\t* config/tilepro/tilepro.c: Likewise.\n\nFrom-SVN: r187969", "tree": {"sha": "7e6eb315a8fd801513f14a09fb9035a39128e409", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7e6eb315a8fd801513f14a09fb9035a39128e409"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/comments", "author": null, "committer": null, "parents": [{"sha": "030a9eb6d827dc3a2363cb220bb4ea6dce083981", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/030a9eb6d827dc3a2363cb220bb4ea6dce083981", "html_url": "https://github.com/Rust-GCC/gccrs/commit/030a9eb6d827dc3a2363cb220bb4ea6dce083981"}], "stats": {"total": 889, "additions": 424, "deletions": 465}, "files": [{"sha": "07a610f48e3000edc496a74915ff98cf3843d013", "filename": "gcc/ChangeLog", "status": "modified", "additions": 62, "deletions": 1, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6399c0abb3e562d7dc9cbf2f85998965dac1a1cb", "patch": "@@ -1,3 +1,63 @@\n+2012-05-29  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* integrate.c: Remove.\n+\t* integrate.h: Remove.\n+\t* Makefile.in: Remove make rules for integrate.c and INTEGRATE_H.\n+\t* config/arm/t-arm: Remove INTEGRATE_H dependency for target files.\n+\t* config/rs6000/t-rs6000: Likewise\n+\t* config/spu/t-spu-elf: Likewise.\n+\t* function.h (get_hard_reg_initial_val, has_hard_reg_initial_val,\n+\tget_hard_reg_initial_reg, emit_initial_value_sets): Move prototypes\n+\tfrom integrate.h to here.\n+\t(initial_value_entry): New prototype.\n+\t* reload.h (allocate_initial_values): Remove prototype.\n+\t* tree.h (set_decl_abstract_flags, set_decl_origin_self): Likewise.\n+\t* cse.c (fixed_base_plus_p): Don't handle virtual registers for\n+\tintegrate.c.\n+\t* dwarf2out.c (set_decl_origin_self, set_block_origin_self,\n+\tset_decl_abstract_flags, set_block_abstract_flags): Move from\n+\tintegrate.c to here, the only user.\n+\t* expmed.c (extract_fixed_bit_field): Remove outdated comment\n+\tabout integrate.c.\n+\t* function.c: Don't include integrate.h.\n+\t(struct initial_value_pair, struct initial_value_struct,\n+\tget_hard_reg_initial_val, has_hard_reg_initial_val,\n+\tget_hard_reg_initial_reg, emit_initial_value_sets): Move from\n+\tintegrate.c to here.\n+\t(initial_value_entry): New function.\n+\t* genemit.c (main): Don't print integrate.h include line.\n+\t* ira.c: Don't include integrate.h.\n+\t(allocate_initial_values): Move from integrate.c to here.\n+\t(ira): Update allocate_initial_values call.\n+\t* tree-inline.c: Don't include integrate.h.\n+\t(function_attribute_inlinable_p): Moved from integrate.c to here.\n+\t* cfgexpand.c: Don't include integrate.h.\n+\t* except.c: Likewise.\n+\t* langhooks.c: Likewise.\n+\t* passes.c: Likewise.\n+\t* toplev.c: Likewise.\n+\t* config/frv/frv.c: Likewise.\n+\t* config/pa/pa.c: Likewise.\n+\t* config/spu/spu.c: Likewise.\n+\t* config/epiphany/epiphany.c: Likewise.\n+\t* config/mep/mep.c: Likewise.\n+\t* config/score/score.c: Likewise.\n+\t* config/picochip/picochip.c: Likewise.\n+\t* config/sh/sh.c: Likewise.\n+\t* config/alpha/alpha.c: Likewise.\n+\t* config/microblaze/microblaze.c: Likewise.\n+\t* config/mips/mips.c: Likewise.\n+\t* config/v850/v850.c: Likewise.\n+\t* config/mmix/mmix.c: Likewise.\n+\t* config/bfin/bfin.c: Likewise.\n+\t* config/arm/arm.c: Likewise.\n+\t* config/s390/s390.c: Likewise.\n+\t* config/m32r/m32r.c: Likewise.\n+\t* config/rs6000/rs6000.c: Likewise.\n+\t* config/c6x/c6x.c: Include function.h instead of integrate.h.\n+\t* config/tilegx/tilegx.c: Likewise.\n+\t* config/tilepro/tilepro.c: Likewise.\n+\n 2012-05-29  Georg-Johann Lay  <avr@gjlay.de>\n \n \t* config/avr/t-avr (s-avr-mmcu-texi): Call \n@@ -1448,7 +1508,8 @@\n \t* doc/options.texi (EnabledBy): Document\n \t* opts.c: Include opts.h and options.h before tm.h.\n \t(finish_options): Do not handle some sub-options here...\n-\t(common_handle_option): ... instead call common_handle_option_auto here.\n+\t(common_handle_option): ... instead call common_handle_option_auto\n+\there.\n \t* optc-gen.awk: Handle EnabledBy.\n \t* opth-gen.awk: Declare common_handle_option_auto.\n \t* common.opt (Wuninitialized): Use EnabledBy. Delete Init."}, {"sha": "6cdd8ee367194453c5e6744e0210ae2247b91ffa", "filename": "gcc/Makefile.in", "status": "modified", "additions": 10, "deletions": 17, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=6399c0abb3e562d7dc9cbf2f85998965dac1a1cb", "patch": "@@ -884,7 +884,6 @@ SCHED_INT_H = sched-int.h $(INSN_ATTR_H) $(BASIC_BLOCK_H) $(RTL_H) $(DF_H) \\\n SEL_SCHED_IR_H = sel-sched-ir.h $(INSN_ATTR_H) $(BASIC_BLOCK_H) $(RTL_H) \\\n \t$(GGC_H) $(BITMAP_H) vecprim.h $(SCHED_INT_H) $(CFGLOOP_H) $(REGSET_H)\n SEL_SCHED_DUMP_H = sel-sched-dump.h $(SEL_SCHED_IR_H)\n-INTEGRATE_H = integrate.h\n CFGLAYOUT_H = cfglayout.h $(BASIC_BLOCK_H)\n CFGLOOP_H = cfgloop.h $(BASIC_BLOCK_H) $(RTL_H) vecprim.h double-int.h \\\n \t$(BITMAP_H) sbitmap.h\n@@ -1253,7 +1252,6 @@ OBJS = \\\n \tree.o \\\n \tincpath.o \\\n \tinit-regs.o \\\n-\tintegrate.o \\\n \tinternal-fn.o \\\n \tipa-cp.o \\\n \tipa-split.o \\\n@@ -2259,7 +2257,7 @@ lto-streamer.o: lto-streamer.c $(CONFIG_H) $(SYSTEM_H) coretypes.h   \\\n    $(TREE_FLOW_H) $(DIAGNOSTIC_CORE_H) $(LTO_SYMTAB_H) toplev.h \\\n    $(DIAGNOSTIC_CORE_H) $(STREAMER_HOOKS_H)\n langhooks.o : langhooks.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n-   $(TREE_H) toplev.h $(DIAGNOSTIC_CORE_H) $(TREE_INLINE_H) $(RTL_H) insn-config.h $(INTEGRATE_H) \\\n+   $(TREE_H) toplev.h $(DIAGNOSTIC_CORE_H) $(TREE_INLINE_H) $(RTL_H) insn-config.h \\\n    langhooks.h $(TARGET_H) $(LANGHOOKS_DEF_H) $(FLAGS_H) $(GGC_H) $(DIAGNOSTIC_H) \\\n    intl.h $(GIMPLE_H) $(CGRAPH_H) output.h tree-diagnostic.h\n tree.o: tree.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n@@ -2278,7 +2276,7 @@ tree-inline.o : tree-inline.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(HASHTAB_H) langhooks.h $(TREE_INLINE_H) $(CGRAPH_H) \\\n    intl.h $(FUNCTION_H) $(GIMPLE_H) \\\n    debug.h $(DIAGNOSTIC_H) $(EXCEPT_H) $(TREE_FLOW_H) tree-iterator.h tree-mudflap.h \\\n-   $(IPA_PROP_H) value-prof.h $(TREE_PASS_H) $(TARGET_H) $(INTEGRATE_H) \\\n+   $(IPA_PROP_H) value-prof.h $(TREE_PASS_H) $(TARGET_H) \\\n    tree-pretty-print.h\n print-tree.o : print-tree.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    $(GGC_H) langhooks.h tree-iterator.h \\\n@@ -2751,7 +2749,7 @@ toplev.o : toplev.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    hard-reg-set.h $(BASIC_BLOCK_H) graph.h $(EXCEPT_H) $(REGS_H) $(TIMEVAR_H) \\\n    value-prof.h $(PARAMS_H) $(TM_P_H) reload.h ira.h dwarf2asm.h $(TARGET_H) \\\n    langhooks.h insn-flags.h $(CFGLAYOUT_H) $(CFGLOOP_H) hosthooks.h \\\n-   $(CGRAPH_H) $(COVERAGE_H) alloc-pool.h $(GGC_H) $(INTEGRATE_H) \\\n+   $(CGRAPH_H) $(COVERAGE_H) alloc-pool.h $(GGC_H) \\\n    $(OPTS_H) params.def tree-mudflap.h $(TREE_PASS_H) $(GIMPLE_H) \\\n    tree-ssa-alias.h $(PLUGIN_H) realmpfr.h tree-diagnostic.h \\\n    tree-pretty-print.h opts-diagnostic.h $(COMMON_TARGET_H)\n@@ -2766,7 +2764,7 @@ passes.o : passes.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    $(PARAMS_H) $(TM_P_H) reload.h dwarf2asm.h $(TARGET_H) \\\n    langhooks.h insn-flags.h $(CFGLAYOUT_H) $(CFGLOOP_H) \\\n    hosthooks.h $(CGRAPH_H) $(COVERAGE_H) $(TREE_PASS_H) $(TREE_DUMP_H) \\\n-   $(GGC_H) $(INTEGRATE_H) $(CPPLIB_H) $(OPTS_H) $(TREE_FLOW_H) $(TREE_INLINE_H) \\\n+   $(GGC_H) $(CPPLIB_H) $(OPTS_H) $(TREE_FLOW_H) $(TREE_INLINE_H) \\\n    gt-passes.h $(DF_H) $(PREDICT_H) $(LTO_HEADER_H) $(LTO_SECTION_OUT_H) \\\n    $(PLUGIN_H) $(IPA_UTILS_H)\n \n@@ -2804,7 +2802,7 @@ function.o : function.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_ERROR_\n    $(TREE_H) $(CFGLAYOUT_H) $(GIMPLE_H) $(FLAGS_H) $(FUNCTION_H) $(EXPR_H) \\\n    $(OPTABS_H) $(LIBFUNCS_H) $(REGS_H) hard-reg-set.h insn-config.h $(RECOG_H) \\\n    output.h  $(EXCEPT_H) $(HASHTAB_H) $(GGC_H) $(TM_P_H) langhooks.h \\\n-   gt-function.h $(TARGET_H) $(BASIC_BLOCK_H) $(INTEGRATE_H) $(PREDICT_H) \\\n+   gt-function.h $(TARGET_H) $(BASIC_BLOCK_H) $(PREDICT_H) \\\n    $(TREE_PASS_H) $(DF_H) $(TIMEVAR_H) vecprim.h $(PARAMS_H) bb-reorder.h \\\n    $(COMMON_TARGET_H)\n statistics.o : statistics.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n@@ -2819,7 +2817,7 @@ except.o : except.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TREE_H) $(FLAGS_H) $(EXCEPT_H) $(FUNCTION_H) $(EXPR_H) $(LIBFUNCS_H) \\\n    langhooks.h insn-config.h hard-reg-set.h $(BASIC_BLOCK_H) output.h \\\n    dwarf2asm.h dwarf2out.h toplev.h $(DIAGNOSTIC_CORE_H) $(HASHTAB_H) intl.h $(GGC_H) \\\n-   gt-except.h $(CGRAPH_H) $(INTEGRATE_H) $(DIAGNOSTIC_H) $(DWARF2_H) \\\n+   gt-except.h $(CGRAPH_H) $(DIAGNOSTIC_H) $(DWARF2_H) \\\n    $(TARGET_H) $(TM_P_H) $(TREE_PASS_H) $(TIMEVAR_H) $(TREE_FLOW_H) \\\n    tree-pretty-print.h sbitmap.h $(COMMON_TARGET_H) $(CFGLOOP_H)\n expr.o : expr.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n@@ -2900,11 +2898,6 @@ dfp.o : dfp.c dfp.h $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H)\t$(TREE_H) \\\n    $(DIAGNOSTIC_CORE_H) $(TM_P_H) $(REAL_H) $(DECNUM_H)\n fixed-value.o: fixed-value.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) $(REAL_H) $(DIAGNOSTIC_CORE_H)\n-integrate.o : integrate.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n-   $(RTL_H) $(TREE_H) $(FLAGS_H) debug.h $(INTEGRATE_H) insn-config.h \\\n-   $(EXPR_H) $(REGS_H) intl.h $(FUNCTION_H) output.h $(RECOG_H) \\\n-   $(EXCEPT_H) $(DIAGNOSTIC_CORE_H) $(PARAMS_H) $(TM_P_H) $(TARGET_H) langhooks.h \\\n-   gt-integrate.h $(GGC_H) $(TREE_PASS_H) $(DF_H)\n jump.o : jump.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(FLAGS_H) hard-reg-set.h $(REGS_H) insn-config.h $(RECOG_H) $(EXPR_H) \\\n    $(EXCEPT_H) $(FUNCTION_H) $(BASIC_BLOCK_H) $(TREE_PASS_H) \\\n@@ -3167,7 +3160,7 @@ cfgexpand.o : cfgexpand.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(DIAGNOSTIC_H) toplev.h $(DIAGNOSTIC_CORE_H) $(BASIC_BLOCK_H) $(FLAGS_H) debug.h $(PARAMS_H) \\\n    value-prof.h $(TREE_INLINE_H) $(TARGET_H) $(SSAEXPAND_H) $(REGS_H) \\\n    tree-pretty-print.h gimple-pretty-print.h $(BITMAP_H) sbitmap.h \\\n-   $(INSN_ATTR_H) $(INTEGRATE_H) $(CFGLOOP_H)\n+   $(INSN_ATTR_H) $(CFGLOOP_H)\n cfgrtl.o : cfgrtl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_ERROR_H) \\\n    $(FLAGS_H) insn-config.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h \\\n    output.h  $(FUNCTION_H) $(EXCEPT_H) $(TM_P_H) $(INSN_ATTR_H) \\\n@@ -3310,7 +3303,7 @@ ira.o: ira.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) $(REGS_H) $(RTL_H) $(TM_P_H) $(TARGET_H) $(FLAGS_H) $(OBSTACK_H) \\\n    $(BITMAP_H) hard-reg-set.h $(BASIC_BLOCK_H) $(DBGCNT_H) \\\n    $(EXPR_H) $(RECOG_H) $(PARAMS_H) $(TIMEVAR_H) $(TREE_PASS_H) output.h \\\n-   $(EXCEPT_H) reload.h toplev.h $(DIAGNOSTIC_CORE_H) $(INTEGRATE_H) $(DF_H) $(GGC_H) $(IRA_INT_H)\n+   $(EXCEPT_H) reload.h toplev.h $(DIAGNOSTIC_CORE_H) $(DF_H) $(GGC_H) $(IRA_INT_H)\n regmove.o : regmove.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    insn-config.h $(TIMEVAR_H) $(TREE_PASS_H) $(DF_H) \\\n    $(RECOG_H) output.h $(REGS_H) hard-reg-set.h $(FLAGS_H) $(FUNCTION_H) \\\n@@ -3501,7 +3494,7 @@ insn-emit.o : insn-emit.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H)\t\\\n   $(RTL_H) $(TM_P_H) $(FUNCTION_H) $(EXPR_H) $(OPTABS_H) \t\t\\\n   dfp.h $(FLAGS_H) output.h insn-config.h hard-reg-set.h $(RECOG_H)\t\\\n   $(RESOURCE_H) reload.h $(DIAGNOSTIC_CORE_H) $(REGS_H) tm-constrs.h\t\\\n-  $(GGC_H) $(BASIC_BLOCK_H) $(INTEGRATE_H) $(TARGET_H)\n+  $(GGC_H) $(BASIC_BLOCK_H) $(TARGET_H)\n insn-enums.o : insn-enums.c $(CONFIG_H) $(SYSTEM_H) insn-constants.h\n insn-extract.o : insn-extract.c $(CONFIG_H) $(SYSTEM_H) coretypes.h\t\\\n   $(TM_H) $(RTL_H) $(DIAGNOSTIC_CORE_H) insn-config.h $(RECOG_H)\n@@ -3737,7 +3730,7 @@ GTFILES = $(CPP_ID_DATA_H) $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/expr.h \\\n   $(srcdir)/function.c $(srcdir)/except.c \\\n   $(srcdir)/gcse.c $(srcdir)/godump.c \\\n-  $(srcdir)/integrate.c $(srcdir)/lists.c $(srcdir)/optabs.c \\\n+  $(srcdir)/lists.c $(srcdir)/optabs.c \\\n   $(srcdir)/profile.c $(srcdir)/mcf.c \\\n   $(srcdir)/reg-stack.c $(srcdir)/cfglayout.c $(srcdir)/cfglayout.h \\\n   $(srcdir)/sdbout.c $(srcdir)/stor-layout.c \\"}, {"sha": "8a31a9f5835c23c5cc2cc64dce3d499aa531512b", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=6399c0abb3e562d7dc9cbf2f85998965dac1a1cb", "patch": "@@ -49,7 +49,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"sbitmap.h\"\n #include \"cfgloop.h\"\n #include \"regs.h\" /* For reg_renumber.  */\n-#include \"integrate.h\" /* For emit_initial_value_sets.  */\n #include \"insn-attr.h\" /* For INSN_SCHEDULING.  */\n \n /* This variable holds information helping the rewriting of SSA trees"}, {"sha": "6d15bf70cffe143f4b75ea6fc34a1ebe052db46b", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=6399c0abb3e562d7dc9cbf2f85998965dac1a1cb", "patch": "@@ -43,7 +43,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"function.h\"\n #include \"diagnostic-core.h\"\n #include \"ggc.h\"\n-#include \"integrate.h\"\n #include \"tm_p.h\"\n #include \"target.h\"\n #include \"target-def.h\""}, {"sha": "c6d466055ab2595ac28e4dcf8a7362454c067461", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=6399c0abb3e562d7dc9cbf2f85998965dac1a1cb", "patch": "@@ -46,7 +46,6 @@\n #include \"ggc.h\"\n #include \"except.h\"\n #include \"c-family/c-pragma.h\"\t/* ??? */\n-#include \"integrate.h\"\n #include \"tm_p.h\"\n #include \"target.h\"\n #include \"target-def.h\""}, {"sha": "2bc97a65dacce0c9875d13281f4178e5418e7cf4", "filename": "gcc/config/arm/t-arm", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Fconfig%2Farm%2Ft-arm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Fconfig%2Farm%2Ft-arm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ft-arm?ref=6399c0abb3e562d7dc9cbf2f85998965dac1a1cb", "patch": "@@ -78,7 +78,7 @@ arm.o: $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n   insn-config.h conditions.h output.h \\\n   $(INSN_ATTR_H) $(FLAGS_H) reload.h $(FUNCTION_H) \\\n   $(EXPR_H) $(OPTABS_H) $(RECOG_H) $(CGRAPH_H) \\\n-  $(GGC_H) except.h $(C_PRAGMA_H) $(INTEGRATE_H) $(TM_P_H) \\\n+  $(GGC_H) except.h $(C_PRAGMA_H) $(TM_P_H) \\\n   $(TARGET_H) $(TARGET_DEF_H) debug.h langhooks.h $(DF_H) \\\n   intl.h libfuncs.h $(PARAMS_H) $(OPTS_H) $(srcdir)/config/arm/arm-cores.def \\\n   $(srcdir)/config/arm/arm-arches.def $(srcdir)/config/arm/arm-fpus.def"}, {"sha": "3cef847c952dfe60a377273db52f230570ec59e8", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=6399c0abb3e562d7dc9cbf2f85998965dac1a1cb", "patch": "@@ -44,7 +44,6 @@\n #include \"recog.h\"\n #include \"optabs.h\"\n #include \"ggc.h\"\n-#include \"integrate.h\"\n #include \"cgraph.h\"\n #include \"langhooks.h\"\n #include \"bfin-protos.h\""}, {"sha": "978d0cba82b3caebd972c0e9c875a3b9e06036e6", "filename": "gcc/config/c6x/c6x.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Fconfig%2Fc6x%2Fc6x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Fconfig%2Fc6x%2Fc6x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc6x%2Fc6x.c?ref=6399c0abb3e562d7dc9cbf2f85998965dac1a1cb", "patch": "@@ -40,7 +40,7 @@\n #include \"tm-preds.h\"\n #include \"tm-constrs.h\"\n #include \"df.h\"\n-#include \"integrate.h\"\n+#include \"function.h\"\n #include \"diagnostic-core.h\"\n #include \"cgraph.h\"\n #include \"cfglayout.h\""}, {"sha": "aca296f0152fc62a12c67bb6be29a9714ed56961", "filename": "gcc/config/epiphany/epiphany.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Fconfig%2Fepiphany%2Fepiphany.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Fconfig%2Fepiphany%2Fepiphany.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fepiphany%2Fepiphany.c?ref=6399c0abb3e562d7dc9cbf2f85998965dac1a1cb", "patch": "@@ -46,7 +46,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ggc.h\"\n #include \"tm-constrs.h\"\n #include \"tree-pass.h\"\n-#include \"integrate.h\"\n \n /* Which cpu we're compiling for.  */\n int epiphany_cpu_type;"}, {"sha": "d7a111acbbbbe85773ade8f9e1fda0357600d9bc", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=6399c0abb3e562d7dc9cbf2f85998965dac1a1cb", "patch": "@@ -46,7 +46,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"target.h\"\n #include \"target-def.h\"\n #include \"targhooks.h\"\n-#include \"integrate.h\"\n #include \"langhooks.h\"\n #include \"df.h\"\n "}, {"sha": "a2ae35ae75e8d014af0bb1f0a9ce1137a7ccc533", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=6399c0abb3e562d7dc9cbf2f85998965dac1a1cb", "patch": "@@ -36,7 +36,6 @@\n #include \"recog.h\"\n #include \"diagnostic-core.h\"\n #include \"ggc.h\"\n-#include \"integrate.h\"\n #include \"df.h\"\n #include \"tm_p.h\"\n #include \"target.h\""}, {"sha": "8e6cc4d1a8cbe45be3e912b233ad52816cee9415", "filename": "gcc/config/mep/mep.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Fconfig%2Fmep%2Fmep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Fconfig%2Fmep%2Fmep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmep%2Fmep.c?ref=6399c0abb3e562d7dc9cbf2f85998965dac1a1cb", "patch": "@@ -45,7 +45,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tm_p.h\"\n #include \"ggc.h\"\n #include \"diagnostic-core.h\"\n-#include \"integrate.h\"\n #include \"target.h\"\n #include \"target-def.h\"\n #include \"langhooks.h\""}, {"sha": "8d08bc282ffbc10b2a4a05324d344d3fbd3386eb", "filename": "gcc/config/microblaze/microblaze.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c?ref=6399c0abb3e562d7dc9cbf2f85998965dac1a1cb", "patch": "@@ -31,7 +31,6 @@\n #include \"conditions.h\"\n #include \"insn-flags.h\"\n #include \"insn-attr.h\"\n-#include \"integrate.h\"\n #include \"recog.h\"\n #include \"tree.h\"\n #include \"function.h\""}, {"sha": "122bc98efa0017fd0163a326c76e7b9d6fedccae", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=6399c0abb3e562d7dc9cbf2f85998965dac1a1cb", "patch": "@@ -50,7 +50,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"debug.h\"\n #include \"target.h\"\n #include \"target-def.h\"\n-#include \"integrate.h\"\n #include \"langhooks.h\"\n #include \"cfglayout.h\"\n #include \"sched-int.h\""}, {"sha": "3a99cb626af6be6cf96b9628a0c2ff03c4aea32c", "filename": "gcc/config/mmix/mmix.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Fconfig%2Fmmix%2Fmmix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Fconfig%2Fmmix%2Fmmix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.c?ref=6399c0abb3e562d7dc9cbf2f85998965dac1a1cb", "patch": "@@ -41,7 +41,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"dwarf2.h\"\n #include \"debug.h\"\n #include \"tm_p.h\"\n-#include \"integrate.h\"\n #include \"target.h\"\n #include \"target-def.h\"\n #include \"df.h\""}, {"sha": "95f2262db3f1c1718199eea23362b6d322747531", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=6399c0abb3e562d7dc9cbf2f85998965dac1a1cb", "patch": "@@ -37,7 +37,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"expr.h\"\n #include \"optabs.h\"\n #include \"reload.h\"\n-#include \"integrate.h\"\n #include \"function.h\"\n #include \"diagnostic-core.h\"\n #include \"ggc.h\""}, {"sha": "2beddce8cc98efbbef4bf3c60cb8139f18eebc99", "filename": "gcc/config/picochip/picochip.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Fconfig%2Fpicochip%2Fpicochip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Fconfig%2Fpicochip%2Fpicochip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpicochip%2Fpicochip.c?ref=6399c0abb3e562d7dc9cbf2f85998965dac1a1cb", "patch": "@@ -40,7 +40,6 @@ along with GCC; see the file COPYING3.  If not, see\n #include \"function.h\"\n #include \"output.h\"\n #include \"basic-block.h\"\n-#include \"integrate.h\"\n #include \"diagnostic-core.h\"\n #include \"ggc.h\"\n #include \"hashtab.h\""}, {"sha": "f6cef090f1e45f1cb98888f06dc635bdde9aca5b", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=6399c0abb3e562d7dc9cbf2f85998965dac1a1cb", "patch": "@@ -41,7 +41,6 @@\n #include \"function.h\"\n #include \"output.h\"\n #include \"basic-block.h\"\n-#include \"integrate.h\"\n #include \"diagnostic-core.h\"\n #include \"toplev.h\"\n #include \"ggc.h\""}, {"sha": "3ca2732fabca3b78b44bb57010010f3059eaffa0", "filename": "gcc/config/rs6000/t-rs6000", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Fconfig%2Frs6000%2Ft-rs6000", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Fconfig%2Frs6000%2Ft-rs6000", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Ft-rs6000?ref=6399c0abb3e562d7dc9cbf2f85998965dac1a1cb", "patch": "@@ -25,7 +25,7 @@ rs6000.o: $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n   $(RTL_H) $(REGS_H) hard-reg-set.h \\\n   real.h insn-config.h conditions.h insn-attr.h flags.h $(RECOG_H) \\\n   $(OBSTACK_H) $(TREE_H) $(EXPR_H) $(OPTABS_H) except.h function.h \\\n-  output.h $(BASIC_BLOCK_H) $(INTEGRATE_H) toplev.h $(GGC_H) $(HASHTAB_H) \\\n+  output.h $(BASIC_BLOCK_H) toplev.h $(GGC_H) $(HASHTAB_H) \\\n   $(TM_P_H) $(TARGET_H) $(TARGET_DEF_H) langhooks.h reload.h gt-rs6000.h \\\n   cfglayout.h cfgloop.h $(OPTS_H) $(COMMON_TARGET_H)\n "}, {"sha": "bc0bf8a991a8a452ff8673133ef4b82fd57f7136", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=6399c0abb3e562d7dc9cbf2f85998965dac1a1cb", "patch": "@@ -42,7 +42,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"reload.h\"\n #include \"diagnostic-core.h\"\n #include \"basic-block.h\"\n-#include \"integrate.h\"\n #include \"ggc.h\"\n #include \"target.h\"\n #include \"target-def.h\""}, {"sha": "9c68e19ed30287a1c44830caacb50a3c51f6a04f", "filename": "gcc/config/score/score.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Fconfig%2Fscore%2Fscore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Fconfig%2Fscore%2Fscore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore.c?ref=6399c0abb3e562d7dc9cbf2f85998965dac1a1cb", "patch": "@@ -45,7 +45,6 @@\n #include \"debug.h\"\n #include \"target.h\"\n #include \"target-def.h\"\n-#include \"integrate.h\"\n #include \"langhooks.h\"\n #include \"cfglayout.h\"\n #include \"df.h\""}, {"sha": "4a2e8f43d8968c189ec4b4fbeb9b590844872dc3", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=6399c0abb3e562d7dc9cbf2f85998965dac1a1cb", "patch": "@@ -39,7 +39,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"insn-attr.h\"\n #include \"diagnostic-core.h\"\n #include \"recog.h\"\n-#include \"integrate.h\"\n #include \"dwarf2.h\"\n #include \"tm_p.h\"\n #include \"target.h\""}, {"sha": "b81bf5e8f2d075a825b9f732c21cc49ef01f0db5", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=6399c0abb3e562d7dc9cbf2f85998965dac1a1cb", "patch": "@@ -35,7 +35,6 @@\n #include \"function.h\"\n #include \"output.h\"\n #include \"basic-block.h\"\n-#include \"integrate.h\"\n #include \"diagnostic-core.h\"\n #include \"ggc.h\"\n #include \"hashtab.h\""}, {"sha": "84fbbb28ad2bbe64574997008a53ffc325ec48e5", "filename": "gcc/config/spu/t-spu-elf", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Fconfig%2Fspu%2Ft-spu-elf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Fconfig%2Fspu%2Ft-spu-elf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Ft-spu-elf?ref=6399c0abb3e562d7dc9cbf2f85998965dac1a1cb", "patch": "@@ -22,7 +22,7 @@ spu.o: $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n   $(RTL_H) $(REGS_H) hard-reg-set.h \\\n   real.h insn-config.h conditions.h insn-attr.h flags.h $(RECOG_H) \\\n   $(OBSTACK_H) $(TREE_H) $(EXPR_H) $(OPTABS_H) except.h function.h \\\n-  output.h $(BASIC_BLOCK_H) $(INTEGRATE_H) $(GGC_H) $(HASHTAB_H) \\\n+  output.h $(BASIC_BLOCK_H) $(GGC_H) $(HASHTAB_H) \\\n   $(TM_P_H) $(TARGET_H) $(TARGET_DEF_H) langhooks.h reload.h cfglayout.h \\\n   $(srcdir)/config/spu/spu-protos.h \\\n   $(srcdir)/config/spu/spu-builtins.def "}, {"sha": "7ca4eb68be4dd464854418c8ad63646560d0cab3", "filename": "gcc/config/tilegx/tilegx.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Fconfig%2Ftilegx%2Ftilegx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Fconfig%2Ftilegx%2Ftilegx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilegx%2Ftilegx.c?ref=6399c0abb3e562d7dc9cbf2f85998965dac1a1cb", "patch": "@@ -37,7 +37,7 @@\n #include \"tm-constrs.h\"\n #include \"target.h\"\n #include \"target-def.h\"\n-#include \"integrate.h\"\n+#include \"function.h\"\n #include \"dwarf2.h\"\n #include \"timevar.h\"\n #include \"gimple.h\""}, {"sha": "ce28d9e822104b1bcdf2ddfe09dae95c40543a27", "filename": "gcc/config/tilepro/tilepro.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Fconfig%2Ftilepro%2Ftilepro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Fconfig%2Ftilepro%2Ftilepro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftilepro%2Ftilepro.c?ref=6399c0abb3e562d7dc9cbf2f85998965dac1a1cb", "patch": "@@ -38,7 +38,7 @@\n #include \"tm-constrs.h\"\n #include \"target.h\"\n #include \"target-def.h\"\n-#include \"integrate.h\"\n+#include \"function.h\"\n #include \"dwarf2.h\"\n #include \"timevar.h\"\n #include \"gimple.h\""}, {"sha": "186327da7ac94c07be2f7ab347be9f223a1d4f81", "filename": "gcc/config/v850/v850.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Fconfig%2Fv850%2Fv850.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Fconfig%2Fv850%2Fv850.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.c?ref=6399c0abb3e562d7dc9cbf2f85998965dac1a1cb", "patch": "@@ -37,7 +37,6 @@\n #include \"function.h\"\n #include \"diagnostic-core.h\"\n #include \"ggc.h\"\n-#include \"integrate.h\"\n #include \"tm_p.h\"\n #include \"target.h\"\n #include \"target-def.h\""}, {"sha": "c36ed74d6e62b3a6a1f69267e48c456408578179", "filename": "gcc/cse.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=6399c0abb3e562d7dc9cbf2f85998965dac1a1cb", "patch": "@@ -622,9 +622,7 @@ static enum machine_mode cse_cc_succs (basic_block, basic_block, rtx, rtx,\n \n static const struct rtl_hooks cse_rtl_hooks = RTL_HOOKS_INITIALIZER;\n \f\n-/* Nonzero if X has the form (PLUS frame-pointer integer).  We check for\n-   virtual regs here because the simplify_*_operation routines are called\n-   by integrate.c, which is called before virtual register instantiation.  */\n+/* Nonzero if X has the form (PLUS frame-pointer integer).  */\n \n static bool\n fixed_base_plus_p (rtx x)\n@@ -636,9 +634,6 @@ fixed_base_plus_p (rtx x)\n \treturn true;\n       if (x == arg_pointer_rtx && fixed_regs[ARG_POINTER_REGNUM])\n \treturn true;\n-      if (REGNO (x) >= FIRST_VIRTUAL_REGISTER\n-\t  && REGNO (x) <= LAST_VIRTUAL_REGISTER)\n-\treturn true;\n       return false;\n \n     case PLUS:"}, {"sha": "b233d30ce460715772f0f1586d663728d6fd57f7", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=6399c0abb3e562d7dc9cbf2f85998965dac1a1cb", "patch": "@@ -16409,6 +16409,135 @@ gen_type_die_for_member (tree type, tree member, dw_die_ref context_die)\n       pop_decl_scope ();\n     }\n }\n+\f\n+/* Forward declare these functions, because they are mutually recursive\n+  with their set_block_* pairing functions.  */\n+static void set_decl_origin_self (tree);\n+static void set_decl_abstract_flags (tree, int);\n+\n+/* Given a pointer to some BLOCK node, if the BLOCK_ABSTRACT_ORIGIN for the\n+   given BLOCK node is NULL, set the BLOCK_ABSTRACT_ORIGIN for the node so\n+   that it points to the node itself, thus indicating that the node is its\n+   own (abstract) origin.  Additionally, if the BLOCK_ABSTRACT_ORIGIN for\n+   the given node is NULL, recursively descend the decl/block tree which\n+   it is the root of, and for each other ..._DECL or BLOCK node contained\n+   therein whose DECL_ABSTRACT_ORIGINs or BLOCK_ABSTRACT_ORIGINs are also\n+   still NULL, set *their* DECL_ABSTRACT_ORIGIN or BLOCK_ABSTRACT_ORIGIN\n+   values to point to themselves.  */\n+\n+static void\n+set_block_origin_self (tree stmt)\n+{\n+  if (BLOCK_ABSTRACT_ORIGIN (stmt) == NULL_TREE)\n+    {\n+      BLOCK_ABSTRACT_ORIGIN (stmt) = stmt;\n+\n+      {\n+\ttree local_decl;\n+\n+\tfor (local_decl = BLOCK_VARS (stmt);\n+\t     local_decl != NULL_TREE;\n+\t     local_decl = DECL_CHAIN (local_decl))\n+\t  if (! DECL_EXTERNAL (local_decl))\n+\t    set_decl_origin_self (local_decl);\t/* Potential recursion.  */\n+      }\n+\n+      {\n+\ttree subblock;\n+\n+\tfor (subblock = BLOCK_SUBBLOCKS (stmt);\n+\t     subblock != NULL_TREE;\n+\t     subblock = BLOCK_CHAIN (subblock))\n+\t  set_block_origin_self (subblock);\t/* Recurse.  */\n+      }\n+    }\n+}\n+\n+/* Given a pointer to some ..._DECL node, if the DECL_ABSTRACT_ORIGIN for\n+   the given ..._DECL node is NULL, set the DECL_ABSTRACT_ORIGIN for the\n+   node to so that it points to the node itself, thus indicating that the\n+   node represents its own (abstract) origin.  Additionally, if the\n+   DECL_ABSTRACT_ORIGIN for the given node is NULL, recursively descend\n+   the decl/block tree of which the given node is the root of, and for\n+   each other ..._DECL or BLOCK node contained therein whose\n+   DECL_ABSTRACT_ORIGINs or BLOCK_ABSTRACT_ORIGINs are also still NULL,\n+   set *their* DECL_ABSTRACT_ORIGIN or BLOCK_ABSTRACT_ORIGIN values to\n+   point to themselves.  */\n+\n+static void\n+set_decl_origin_self (tree decl)\n+{\n+  if (DECL_ABSTRACT_ORIGIN (decl) == NULL_TREE)\n+    {\n+      DECL_ABSTRACT_ORIGIN (decl) = decl;\n+      if (TREE_CODE (decl) == FUNCTION_DECL)\n+\t{\n+\t  tree arg;\n+\n+\t  for (arg = DECL_ARGUMENTS (decl); arg; arg = DECL_CHAIN (arg))\n+\t    DECL_ABSTRACT_ORIGIN (arg) = arg;\n+\t  if (DECL_INITIAL (decl) != NULL_TREE\n+\t      && DECL_INITIAL (decl) != error_mark_node)\n+\t    set_block_origin_self (DECL_INITIAL (decl));\n+\t}\n+    }\n+}\n+\f\n+/* Given a pointer to some BLOCK node, and a boolean value to set the\n+   \"abstract\" flags to, set that value into the BLOCK_ABSTRACT flag for\n+   the given block, and for all local decls and all local sub-blocks\n+   (recursively) which are contained therein.  */\n+\n+static void\n+set_block_abstract_flags (tree stmt, int setting)\n+{\n+  tree local_decl;\n+  tree subblock;\n+  unsigned int i;\n+\n+  BLOCK_ABSTRACT (stmt) = setting;\n+\n+  for (local_decl = BLOCK_VARS (stmt);\n+       local_decl != NULL_TREE;\n+       local_decl = DECL_CHAIN (local_decl))\n+    if (! DECL_EXTERNAL (local_decl))\n+      set_decl_abstract_flags (local_decl, setting);\n+\n+  for (i = 0; i < BLOCK_NUM_NONLOCALIZED_VARS (stmt); i++)\n+    {\n+      local_decl = BLOCK_NONLOCALIZED_VAR (stmt, i);\n+      if ((TREE_CODE (local_decl) == VAR_DECL && !TREE_STATIC (local_decl))\n+\t  || TREE_CODE (local_decl) == PARM_DECL)\n+\tset_decl_abstract_flags (local_decl, setting);\n+    }\n+\n+  for (subblock = BLOCK_SUBBLOCKS (stmt);\n+       subblock != NULL_TREE;\n+       subblock = BLOCK_CHAIN (subblock))\n+    set_block_abstract_flags (subblock, setting);\n+}\n+\n+/* Given a pointer to some ..._DECL node, and a boolean value to set the\n+   \"abstract\" flags to, set that value into the DECL_ABSTRACT flag for the\n+   given decl, and (in the case where the decl is a FUNCTION_DECL) also\n+   set the abstract flags for all of the parameters, local vars, local\n+   blocks and sub-blocks (recursively) to the same setting.  */\n+\n+static void\n+set_decl_abstract_flags (tree decl, int setting)\n+{\n+  DECL_ABSTRACT (decl) = setting;\n+  if (TREE_CODE (decl) == FUNCTION_DECL)\n+    {\n+      tree arg;\n+\n+      for (arg = DECL_ARGUMENTS (decl); arg; arg = DECL_CHAIN (arg))\n+\tDECL_ABSTRACT (arg) = setting;\n+      if (DECL_INITIAL (decl) != NULL_TREE\n+\t  && DECL_INITIAL (decl) != error_mark_node)\n+\tset_block_abstract_flags (DECL_INITIAL (decl), setting);\n+    }\n+}\n \n /* Generate the DWARF2 info for the \"abstract\" instance of a function which we\n    may later generate inlined and/or out-of-line instances of.  */"}, {"sha": "aae8aa0e09126719dab67367f029d0d55302f988", "filename": "gcc/except.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=6399c0abb3e562d7dc9cbf2f85998965dac1a1cb", "patch": "@@ -123,7 +123,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"libfuncs.h\"\n #include \"insn-config.h\"\n #include \"except.h\"\n-#include \"integrate.h\"\n #include \"hard-reg-set.h\"\n #include \"basic-block.h\"\n #include \"output.h\""}, {"sha": "96056b4e8624614c4a75b956496cecdcc258e10e", "filename": "gcc/expmed.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=6399c0abb3e562d7dc9cbf2f85998965dac1a1cb", "patch": "@@ -1865,9 +1865,9 @@ extract_fixed_bit_field (enum machine_mode tmode, rtx op0,\n \t  /* If the field does not already start at the lsb,\n \t     shift it so it does.  */\n \t  /* Maybe propagate the target for the shift.  */\n-\t  /* But not if we will return it--could confuse integrate.c.  */\n \t  rtx subtarget = (target != 0 && REG_P (target) ? target : 0);\n-\t  if (tmode != mode) subtarget = 0;\n+\t  if (tmode != mode)\n+\t    subtarget = 0;\n \t  op0 = expand_shift (RSHIFT_EXPR, mode, op0, bitpos, subtarget, 1);\n \t}\n       /* Convert the value to the desired mode.  */"}, {"sha": "274d42191cb43b412883172f9d393bdc8925d1df", "filename": "gcc/function.c", "status": "modified", "additions": 127, "deletions": 1, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=6399c0abb3e562d7dc9cbf2f85998965dac1a1cb", "patch": "@@ -54,7 +54,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"hashtab.h\"\n #include \"ggc.h\"\n #include \"tm_p.h\"\n-#include \"integrate.h\"\n #include \"langhooks.h\"\n #include \"target.h\"\n #include \"common/common-target.h\"\n@@ -1224,6 +1223,133 @@ init_temp_slots (void)\n     htab_empty (temp_slot_address_table);\n }\n \f\n+/* Functions and data structures to keep track of the values hard regs\n+   had at the start of the function.  */\n+\n+/* Private type used by get_hard_reg_initial_reg, get_hard_reg_initial_val,\n+   and has_hard_reg_initial_val..  */\n+typedef struct GTY(()) initial_value_pair {\n+  rtx hard_reg;\n+  rtx pseudo;\n+} initial_value_pair;\n+/* ???  This could be a VEC but there is currently no way to define an\n+   opaque VEC type.  This could be worked around by defining struct\n+   initial_value_pair in function.h.  */\n+typedef struct GTY(()) initial_value_struct {\n+  int num_entries;\n+  int max_entries;\n+  initial_value_pair * GTY ((length (\"%h.num_entries\"))) entries;\n+} initial_value_struct;\n+\n+/* If a pseudo represents an initial hard reg (or expression), return\n+   it, else return NULL_RTX.  */\n+\n+rtx\n+get_hard_reg_initial_reg (rtx reg)\n+{\n+  struct initial_value_struct *ivs = crtl->hard_reg_initial_vals;\n+  int i;\n+\n+  if (ivs == 0)\n+    return NULL_RTX;\n+\n+  for (i = 0; i < ivs->num_entries; i++)\n+    if (rtx_equal_p (ivs->entries[i].pseudo, reg))\n+      return ivs->entries[i].hard_reg;\n+\n+  return NULL_RTX;\n+}\n+\n+/* Make sure that there's a pseudo register of mode MODE that stores the\n+   initial value of hard register REGNO.  Return an rtx for such a pseudo.  */\n+\n+rtx\n+get_hard_reg_initial_val (enum machine_mode mode, unsigned int regno)\n+{\n+  struct initial_value_struct *ivs;\n+  rtx rv;\n+\n+  rv = has_hard_reg_initial_val (mode, regno);\n+  if (rv)\n+    return rv;\n+\n+  ivs = crtl->hard_reg_initial_vals;\n+  if (ivs == 0)\n+    {\n+      ivs = ggc_alloc_initial_value_struct ();\n+      ivs->num_entries = 0;\n+      ivs->max_entries = 5;\n+      ivs->entries = ggc_alloc_vec_initial_value_pair (5);\n+      crtl->hard_reg_initial_vals = ivs;\n+    }\n+\n+  if (ivs->num_entries >= ivs->max_entries)\n+    {\n+      ivs->max_entries += 5;\n+      ivs->entries = GGC_RESIZEVEC (initial_value_pair, ivs->entries,\n+\t\t\t\t    ivs->max_entries);\n+    }\n+\n+  ivs->entries[ivs->num_entries].hard_reg = gen_rtx_REG (mode, regno);\n+  ivs->entries[ivs->num_entries].pseudo = gen_reg_rtx (mode);\n+\n+  return ivs->entries[ivs->num_entries++].pseudo;\n+}\n+\n+/* See if get_hard_reg_initial_val has been used to create a pseudo\n+   for the initial value of hard register REGNO in mode MODE.  Return\n+   the associated pseudo if so, otherwise return NULL.  */\n+\n+rtx\n+has_hard_reg_initial_val (enum machine_mode mode, unsigned int regno)\n+{\n+  struct initial_value_struct *ivs;\n+  int i;\n+\n+  ivs = crtl->hard_reg_initial_vals;\n+  if (ivs != 0)\n+    for (i = 0; i < ivs->num_entries; i++)\n+      if (GET_MODE (ivs->entries[i].hard_reg) == mode\n+\t  && REGNO (ivs->entries[i].hard_reg) == regno)\n+\treturn ivs->entries[i].pseudo;\n+\n+  return NULL_RTX;\n+}\n+\n+unsigned int\n+emit_initial_value_sets (void)\n+{\n+  struct initial_value_struct *ivs = crtl->hard_reg_initial_vals;\n+  int i;\n+  rtx seq;\n+\n+  if (ivs == 0)\n+    return 0;\n+\n+  start_sequence ();\n+  for (i = 0; i < ivs->num_entries; i++)\n+    emit_move_insn (ivs->entries[i].pseudo, ivs->entries[i].hard_reg);\n+  seq = get_insns ();\n+  end_sequence ();\n+\n+  emit_insn_at_entry (seq);\n+  return 0;\n+}\n+\n+/* Return the hardreg-pseudoreg initial values pair entry I and\n+   TRUE if I is a valid entry, or FALSE if I is not a valid entry.  */\n+bool\n+initial_value_entry (int i, rtx *hreg, rtx *preg)\n+{\n+  struct initial_value_struct *ivs = crtl->hard_reg_initial_vals;\n+  if (!ivs || i >= ivs->num_entries)\n+    return false;\n+\n+  *hreg = ivs->entries[i].hard_reg;\n+  *preg = ivs->entries[i].pseudo;\n+  return true;\n+}\n+\f\n /* These routines are responsible for converting virtual register references\n    to the actual hard register references once RTL generation is complete.\n "}, {"sha": "c8357bf5ee0fa6c159896fc4e076f609200da34c", "filename": "gcc/function.h", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=6399c0abb3e562d7dc9cbf2f85998965dac1a1cb", "patch": "@@ -264,8 +264,11 @@ struct GTY(()) rtl_data {\n      the hard register containing the result.  */\n   rtx return_rtx;\n \n-  /* Opaque pointer used by get_hard_reg_initial_val and\n-     has_hard_reg_initial_val (see integrate.[hc]).  */\n+  /* Vector of initial-value pairs.  Each pair consists of a pseudo\n+     register of approprite mode that stores the initial value a hard\n+     register REGNO, and that hard register itself.  */\n+  /* ??? This could be a VEC but there is currently no way to define an\n+\t opaque VEC type.  */\n   struct initial_value_struct *hard_reg_initial_vals;\n \n   /* A variable living at the top of the frame that holds a known value.\n@@ -688,7 +691,6 @@ void types_used_by_var_decl_insert (tree type, tree var_decl);\n    referenced by the global variable.  */\n extern GTY(()) VEC(tree,gc) *types_used_by_cur_var_decl;\n \n-\n /* cfun shouldn't be set directly; use one of these functions instead.  */\n extern void set_cfun (struct function *new_cfun);\n extern void push_cfun (struct function *new_cfun);\n@@ -760,6 +762,14 @@ extern int get_last_funcdef_no (void);\n extern bool requires_stack_frame_p (rtx, HARD_REG_SET, HARD_REG_SET);\n #endif                        \n \n+extern rtx get_hard_reg_initial_val (enum machine_mode, unsigned int);\n+extern rtx has_hard_reg_initial_val (enum machine_mode, unsigned int);\n+extern rtx get_hard_reg_initial_reg (rtx);\n+extern bool initial_value_entry (int i, rtx *, rtx *);\n+\n+/* Called from gimple_expand_cfg.  */\n+extern unsigned int emit_initial_value_sets (void);\n+\n /* In predict.c */\n extern bool optimize_function_for_size_p (struct function *);\n extern bool optimize_function_for_speed_p (struct function *);"}, {"sha": "eefe4978d43e1090def03a677639674a95dd04b3", "filename": "gcc/genemit.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Fgenemit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Fgenemit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenemit.c?ref=6399c0abb3e562d7dc9cbf2f85998965dac1a1cb", "patch": "@@ -809,7 +809,6 @@ from the machine description file `md'.  */\\n\\n\");\n   printf (\"#include \\\"tm-constrs.h\\\"\\n\");\n   printf (\"#include \\\"ggc.h\\\"\\n\");\n   printf (\"#include \\\"basic-block.h\\\"\\n\");\n-  printf (\"#include \\\"integrate.h\\\"\\n\");\n   printf (\"#include \\\"target.h\\\"\\n\\n\");\n   printf (\"#define FAIL return (end_sequence (), _val)\\n\");\n   printf (\"#define DONE return (_val = get_insns (), end_sequence (), _val)\\n\\n\");"}, {"sha": "52dde0bc97e288a704f6a59a5ec45fcf58eb25ef", "filename": "gcc/input.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Finput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Finput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finput.c?ref=6399c0abb3e562d7dc9cbf2f85998965dac1a1cb", "patch": "@@ -117,7 +117,7 @@ read_line (FILE *file)\n    the null character.  */\n \n const char *\n-location_get_source_line(expanded_location xloc)\n+location_get_source_line (expanded_location xloc)\n {\n   const char *buffer;\n   int lines = 1;"}, {"sha": "53c5d78cf6e297d58c20710f6dd442f4b89c9d2f", "filename": "gcc/integrate.c", "status": "removed", "additions": 0, "deletions": 360, "changes": 360, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/030a9eb6d827dc3a2363cb220bb4ea6dce083981/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/030a9eb6d827dc3a2363cb220bb4ea6dce083981/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=030a9eb6d827dc3a2363cb220bb4ea6dce083981", "patch": "@@ -1,360 +0,0 @@\n-/* Procedure integration for GCC.\n-   Copyright (C) 1988, 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999,\n-   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011\n-   Free Software Foundation, Inc.\n-   Contributed by Michael Tiemann (tiemann@cygnus.com)\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-\n-#include \"rtl.h\"\n-#include \"tree.h\"\n-#include \"tm_p.h\"\n-#include \"regs.h\"\n-#include \"flags.h\"\n-#include \"debug.h\"\n-#include \"insn-config.h\"\n-#include \"expr.h\"\n-#include \"output.h\"\n-#include \"recog.h\"\n-/* For reg_equivs.  */\n-#include \"reload.h\"\n-#include \"integrate.h\"\n-#include \"except.h\"\n-#include \"function.h\"\n-#include \"diagnostic-core.h\"\n-#include \"intl.h\"\n-#include \"params.h\"\n-#include \"ggc.h\"\n-#include \"target.h\"\n-#include \"langhooks.h\"\n-#include \"tree-pass.h\"\n-#include \"df.h\"\n-\n-/* Round to the next highest integer that meets the alignment.  */\n-#define CEIL_ROUND(VALUE,ALIGN)\t(((VALUE) + (ALIGN) - 1) & ~((ALIGN)- 1))\n-\f\n-\n-/* Private type used by {get/has}_hard_reg_initial_val.  */\n-typedef struct GTY(()) initial_value_pair {\n-  rtx hard_reg;\n-  rtx pseudo;\n-} initial_value_pair;\n-typedef struct GTY(()) initial_value_struct {\n-  int num_entries;\n-  int max_entries;\n-  initial_value_pair * GTY ((length (\"%h.num_entries\"))) entries;\n-} initial_value_struct;\n-\n-static void set_block_origin_self (tree);\n-static void set_block_abstract_flags (tree, int);\n-\f\n-\n-/* Return false if the function FNDECL cannot be inlined on account of its\n-   attributes, true otherwise.  */\n-bool\n-function_attribute_inlinable_p (const_tree fndecl)\n-{\n-  if (targetm.attribute_table)\n-    {\n-      const_tree a;\n-\n-      for (a = DECL_ATTRIBUTES (fndecl); a; a = TREE_CHAIN (a))\n-\t{\n-\t  const_tree name = TREE_PURPOSE (a);\n-\t  int i;\n-\n-\t  for (i = 0; targetm.attribute_table[i].name != NULL; i++)\n-\t    if (is_attribute_p (targetm.attribute_table[i].name, name))\n-\t      return targetm.function_attribute_inlinable_p (fndecl);\n-\t}\n-    }\n-\n-  return true;\n-}\n-\f\n-/* Given a pointer to some BLOCK node, if the BLOCK_ABSTRACT_ORIGIN for the\n-   given BLOCK node is NULL, set the BLOCK_ABSTRACT_ORIGIN for the node so\n-   that it points to the node itself, thus indicating that the node is its\n-   own (abstract) origin.  Additionally, if the BLOCK_ABSTRACT_ORIGIN for\n-   the given node is NULL, recursively descend the decl/block tree which\n-   it is the root of, and for each other ..._DECL or BLOCK node contained\n-   therein whose DECL_ABSTRACT_ORIGINs or BLOCK_ABSTRACT_ORIGINs are also\n-   still NULL, set *their* DECL_ABSTRACT_ORIGIN or BLOCK_ABSTRACT_ORIGIN\n-   values to point to themselves.  */\n-\n-static void\n-set_block_origin_self (tree stmt)\n-{\n-  if (BLOCK_ABSTRACT_ORIGIN (stmt) == NULL_TREE)\n-    {\n-      BLOCK_ABSTRACT_ORIGIN (stmt) = stmt;\n-\n-      {\n-\ttree local_decl;\n-\n-\tfor (local_decl = BLOCK_VARS (stmt);\n-\t     local_decl != NULL_TREE;\n-\t     local_decl = DECL_CHAIN (local_decl))\n-\t  if (! DECL_EXTERNAL (local_decl))\n-\t    set_decl_origin_self (local_decl);\t/* Potential recursion.  */\n-      }\n-\n-      {\n-\ttree subblock;\n-\n-\tfor (subblock = BLOCK_SUBBLOCKS (stmt);\n-\t     subblock != NULL_TREE;\n-\t     subblock = BLOCK_CHAIN (subblock))\n-\t  set_block_origin_self (subblock);\t/* Recurse.  */\n-      }\n-    }\n-}\n-\n-/* Given a pointer to some ..._DECL node, if the DECL_ABSTRACT_ORIGIN for\n-   the given ..._DECL node is NULL, set the DECL_ABSTRACT_ORIGIN for the\n-   node to so that it points to the node itself, thus indicating that the\n-   node represents its own (abstract) origin.  Additionally, if the\n-   DECL_ABSTRACT_ORIGIN for the given node is NULL, recursively descend\n-   the decl/block tree of which the given node is the root of, and for\n-   each other ..._DECL or BLOCK node contained therein whose\n-   DECL_ABSTRACT_ORIGINs or BLOCK_ABSTRACT_ORIGINs are also still NULL,\n-   set *their* DECL_ABSTRACT_ORIGIN or BLOCK_ABSTRACT_ORIGIN values to\n-   point to themselves.  */\n-\n-void\n-set_decl_origin_self (tree decl)\n-{\n-  if (DECL_ABSTRACT_ORIGIN (decl) == NULL_TREE)\n-    {\n-      DECL_ABSTRACT_ORIGIN (decl) = decl;\n-      if (TREE_CODE (decl) == FUNCTION_DECL)\n-\t{\n-\t  tree arg;\n-\n-\t  for (arg = DECL_ARGUMENTS (decl); arg; arg = DECL_CHAIN (arg))\n-\t    DECL_ABSTRACT_ORIGIN (arg) = arg;\n-\t  if (DECL_INITIAL (decl) != NULL_TREE\n-\t      && DECL_INITIAL (decl) != error_mark_node)\n-\t    set_block_origin_self (DECL_INITIAL (decl));\n-\t}\n-    }\n-}\n-\f\n-/* Given a pointer to some BLOCK node, and a boolean value to set the\n-   \"abstract\" flags to, set that value into the BLOCK_ABSTRACT flag for\n-   the given block, and for all local decls and all local sub-blocks\n-   (recursively) which are contained therein.  */\n-\n-static void\n-set_block_abstract_flags (tree stmt, int setting)\n-{\n-  tree local_decl;\n-  tree subblock;\n-  unsigned int i;\n-\n-  BLOCK_ABSTRACT (stmt) = setting;\n-\n-  for (local_decl = BLOCK_VARS (stmt);\n-       local_decl != NULL_TREE;\n-       local_decl = DECL_CHAIN (local_decl))\n-    if (! DECL_EXTERNAL (local_decl))\n-      set_decl_abstract_flags (local_decl, setting);\n-\n-  for (i = 0; i < BLOCK_NUM_NONLOCALIZED_VARS (stmt); i++)\n-    {\n-      local_decl = BLOCK_NONLOCALIZED_VAR (stmt, i);\n-      if ((TREE_CODE (local_decl) == VAR_DECL && !TREE_STATIC (local_decl))\n-\t  || TREE_CODE (local_decl) == PARM_DECL)\n-\tset_decl_abstract_flags (local_decl, setting);\n-    }\n-\n-  for (subblock = BLOCK_SUBBLOCKS (stmt);\n-       subblock != NULL_TREE;\n-       subblock = BLOCK_CHAIN (subblock))\n-    set_block_abstract_flags (subblock, setting);\n-}\n-\n-/* Given a pointer to some ..._DECL node, and a boolean value to set the\n-   \"abstract\" flags to, set that value into the DECL_ABSTRACT flag for the\n-   given decl, and (in the case where the decl is a FUNCTION_DECL) also\n-   set the abstract flags for all of the parameters, local vars, local\n-   blocks and sub-blocks (recursively) to the same setting.  */\n-\n-void\n-set_decl_abstract_flags (tree decl, int setting)\n-{\n-  DECL_ABSTRACT (decl) = setting;\n-  if (TREE_CODE (decl) == FUNCTION_DECL)\n-    {\n-      tree arg;\n-\n-      for (arg = DECL_ARGUMENTS (decl); arg; arg = DECL_CHAIN (arg))\n-\tDECL_ABSTRACT (arg) = setting;\n-      if (DECL_INITIAL (decl) != NULL_TREE\n-\t  && DECL_INITIAL (decl) != error_mark_node)\n-\tset_block_abstract_flags (DECL_INITIAL (decl), setting);\n-    }\n-}\n-\f\n-/* Functions to keep track of the values hard regs had at the start of\n-   the function.  */\n-\n-rtx\n-get_hard_reg_initial_reg (rtx reg)\n-{\n-  struct initial_value_struct *ivs = crtl->hard_reg_initial_vals;\n-  int i;\n-\n-  if (ivs == 0)\n-    return NULL_RTX;\n-\n-  for (i = 0; i < ivs->num_entries; i++)\n-    if (rtx_equal_p (ivs->entries[i].pseudo, reg))\n-      return ivs->entries[i].hard_reg;\n-\n-  return NULL_RTX;\n-}\n-\n-/* Make sure that there's a pseudo register of mode MODE that stores the\n-   initial value of hard register REGNO.  Return an rtx for such a pseudo.  */\n-\n-rtx\n-get_hard_reg_initial_val (enum machine_mode mode, unsigned int regno)\n-{\n-  struct initial_value_struct *ivs;\n-  rtx rv;\n-\n-  rv = has_hard_reg_initial_val (mode, regno);\n-  if (rv)\n-    return rv;\n-\n-  ivs = crtl->hard_reg_initial_vals;\n-  if (ivs == 0)\n-    {\n-      ivs = ggc_alloc_initial_value_struct ();\n-      ivs->num_entries = 0;\n-      ivs->max_entries = 5;\n-      ivs->entries = ggc_alloc_vec_initial_value_pair (5);\n-      crtl->hard_reg_initial_vals = ivs;\n-    }\n-\n-  if (ivs->num_entries >= ivs->max_entries)\n-    {\n-      ivs->max_entries += 5;\n-      ivs->entries = GGC_RESIZEVEC (initial_value_pair, ivs->entries,\n-\t\t\t\t    ivs->max_entries);\n-    }\n-\n-  ivs->entries[ivs->num_entries].hard_reg = gen_rtx_REG (mode, regno);\n-  ivs->entries[ivs->num_entries].pseudo = gen_reg_rtx (mode);\n-\n-  return ivs->entries[ivs->num_entries++].pseudo;\n-}\n-\n-/* See if get_hard_reg_initial_val has been used to create a pseudo\n-   for the initial value of hard register REGNO in mode MODE.  Return\n-   the associated pseudo if so, otherwise return NULL.  */\n-\n-rtx\n-has_hard_reg_initial_val (enum machine_mode mode, unsigned int regno)\n-{\n-  struct initial_value_struct *ivs;\n-  int i;\n-\n-  ivs = crtl->hard_reg_initial_vals;\n-  if (ivs != 0)\n-    for (i = 0; i < ivs->num_entries; i++)\n-      if (GET_MODE (ivs->entries[i].hard_reg) == mode\n-\t  && REGNO (ivs->entries[i].hard_reg) == regno)\n-\treturn ivs->entries[i].pseudo;\n-\n-  return NULL_RTX;\n-}\n-\n-unsigned int\n-emit_initial_value_sets (void)\n-{\n-  struct initial_value_struct *ivs = crtl->hard_reg_initial_vals;\n-  int i;\n-  rtx seq;\n-\n-  if (ivs == 0)\n-    return 0;\n-\n-  start_sequence ();\n-  for (i = 0; i < ivs->num_entries; i++)\n-    emit_move_insn (ivs->entries[i].pseudo, ivs->entries[i].hard_reg);\n-  seq = get_insns ();\n-  end_sequence ();\n-\n-  emit_insn_at_entry (seq);\n-  return 0;\n-}\n-\n-/* If the backend knows where to allocate pseudos for hard\n-   register initial values, register these allocations now.  */\n-void\n-allocate_initial_values (VEC (reg_equivs_t, gc) *reg_equivs)\n-{\n-  if (targetm.allocate_initial_value)\n-    {\n-      struct initial_value_struct *ivs = crtl->hard_reg_initial_vals;\n-      int i;\n-\n-      if (ivs == 0)\n-\treturn;\n-\n-      for (i = 0; i < ivs->num_entries; i++)\n-\t{\n-\t  int regno = REGNO (ivs->entries[i].pseudo);\n-\t  rtx x = targetm.allocate_initial_value (ivs->entries[i].hard_reg);\n-\n-\t  if (x && REG_N_SETS (REGNO (ivs->entries[i].pseudo)) <= 1)\n-\t    {\n-\t      if (MEM_P (x))\n-\t\treg_equiv_memory_loc (regno) = x;\n-\t      else\n-\t\t{\n-\t\t  basic_block bb;\n-\t\t  int new_regno;\n-\n-\t\t  gcc_assert (REG_P (x));\n-\t\t  new_regno = REGNO (x);\n-\t\t  reg_renumber[regno] = new_regno;\n-\t\t  /* Poke the regno right into regno_reg_rtx so that even\n-\t\t     fixed regs are accepted.  */\n-\t\t  SET_REGNO (ivs->entries[i].pseudo, new_regno);\n-\t\t  /* Update global register liveness information.  */\n-\t\t  FOR_EACH_BB (bb)\n-\t\t    {\n-\t\t      if (REGNO_REG_SET_P(df_get_live_in (bb), regno))\n-\t\t\tSET_REGNO_REG_SET (df_get_live_in (bb), new_regno);\n-\t\t      if (REGNO_REG_SET_P(df_get_live_out (bb), regno))\n-\t\t\tSET_REGNO_REG_SET (df_get_live_out (bb), new_regno);\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n-    }\n-}\n-\n-#include \"gt-integrate.h\""}, {"sha": "e32a92abff33b30d65be3a247e983e72a9af20ec", "filename": "gcc/integrate.h", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/030a9eb6d827dc3a2363cb220bb4ea6dce083981/gcc%2Fintegrate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/030a9eb6d827dc3a2363cb220bb4ea6dce083981/gcc%2Fintegrate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.h?ref=030a9eb6d827dc3a2363cb220bb4ea6dce083981", "patch": "@@ -1,33 +0,0 @@\n-/* Function integration definitions for GCC\n-   Copyright (C) 1990, 1995, 1998, 1999, 2000, 2001, 2003, 2004, 2005,\n-   2007, 2008, 2010  Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-extern rtx get_hard_reg_initial_val (enum machine_mode, unsigned int);\n-extern rtx has_hard_reg_initial_val (enum machine_mode, unsigned int);\n-/* If a pseudo represents an initial hard reg (or expression), return\n-   it, else return NULL_RTX.  */\n-extern rtx get_hard_reg_initial_reg (rtx);\n-/* Called from rest_of_compilation.  */\n-extern unsigned int emit_initial_value_sets (void);\n-\n-/* Check whether there's any attribute in a function declaration that\n-   makes the function uninlinable.  Returns false if it finds any,\n-   true otherwise.  */\n-extern bool function_attribute_inlinable_p (const_tree);\n-"}, {"sha": "f01c6e1022b0d9e837d5a9ac11b96e1ae4eceab5", "filename": "gcc/ira.c", "status": "modified", "additions": 50, "deletions": 2, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=6399c0abb3e562d7dc9cbf2f85998965dac1a1cb", "patch": "@@ -380,7 +380,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"except.h\"\n #include \"reload.h\"\n #include \"diagnostic-core.h\"\n-#include \"integrate.h\"\n+#include \"function.h\"\n #include \"ggc.h\"\n #include \"ira-int.h\"\n #include \"dce.h\"\n@@ -4034,7 +4034,55 @@ move_unallocated_pseudos (void)\n       }\n }\n \f\n+/* If the backend knows where to allocate pseudos for hard\n+   register initial values, register these allocations now.  */\n+void\n+allocate_initial_values (void)\n+{\n+  if (targetm.allocate_initial_value)\n+    {\n+      rtx hreg, preg, x;\n+      int i, regno;\n+\n+      for (i = 0; HARD_REGISTER_NUM_P (i); i++)\n+\t{\n+\t  if (! initial_value_entry (i, &hreg, &preg))\n+\t    break;\n+\n+\t  x = targetm.allocate_initial_value (hreg);\n+\t  regno = REGNO (preg);\n+\t  if (x && REG_N_SETS (regno) <= 1)\n+\t    {\n+\t      if (MEM_P (x))\n+\t\treg_equiv_memory_loc (regno) = x;\n+\t      else\n+\t\t{\n+\t\t  basic_block bb;\n+\t\t  int new_regno;\n+\n+\t\t  gcc_assert (REG_P (x));\n+\t\t  new_regno = REGNO (x);\n+\t\t  reg_renumber[regno] = new_regno;\n+\t\t  /* Poke the regno right into regno_reg_rtx so that even\n+\t\t     fixed regs are accepted.  */\n+\t\t  SET_REGNO (preg, new_regno);\n+\t\t  /* Update global register liveness information.  */\n+\t\t  FOR_EACH_BB (bb)\n+\t\t    {\n+\t\t      if (REGNO_REG_SET_P(df_get_live_in (bb), regno))\n+\t\t\tSET_REGNO_REG_SET (df_get_live_in (bb), new_regno);\n+\t\t      if (REGNO_REG_SET_P(df_get_live_out (bb), regno))\n+\t\t\tSET_REGNO_REG_SET (df_get_live_out (bb), new_regno);\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n \n+      gcc_checking_assert (! initial_value_entry (FIRST_PSEUDO_REGISTER,\n+\t\t\t\t\t\t  &hreg, &preg));\n+    }\n+}\n+\f\n /* All natural loops.  */\n struct loops ira_loops;\n \n@@ -4239,7 +4287,7 @@ ira (FILE *f)\n       memset (ira_spilled_reg_stack_slots, 0,\n \t      max_regno * sizeof (struct ira_spilled_reg_stack_slot));\n     }\n-  allocate_initial_values (reg_equivs);\n+  allocate_initial_values ();\n \n   /* See comment for find_moveable_pseudos call.  */\n   if (ira_conflicts_p)"}, {"sha": "46c19c33a69c50c0b5407116d90864c0f5cf3bee", "filename": "gcc/langhooks.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Flanghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Flanghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.c?ref=6399c0abb3e562d7dc9cbf2f85998965dac1a1cb", "patch": "@@ -30,7 +30,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple.h\"\n #include \"rtl.h\"\n #include \"insn-config.h\"\n-#include \"integrate.h\"\n #include \"flags.h\"\n #include \"langhooks.h\"\n #include \"target.h\""}, {"sha": "54bf029a6037eb4fed3f84e84486df17423570d0", "filename": "gcc/passes.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=6399c0abb3e562d7dc9cbf2f85998965dac1a1cb", "patch": "@@ -54,7 +54,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"params.h\"\n #include \"reload.h\"\n #include \"dwarf2asm.h\"\n-#include \"integrate.h\"\n #include \"debug.h\"\n #include \"target.h\"\n #include \"langhooks.h\""}, {"sha": "29d15ea75aea7c3d3b4f89c3001fce4cc1acca00", "filename": "gcc/reload.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Freload.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Freload.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.h?ref=6399c0abb3e562d7dc9cbf2f85998965dac1a1cb", "patch": "@@ -460,9 +460,5 @@ extern void debug_reload (void);\n    reloading to/from a register that is wider than a word.  */\n extern rtx reload_adjust_reg_for_mode (rtx, enum machine_mode);\n \n-/* Ideally this function would be in ira.c or reload, but due to dependencies\n-   on integrate.h, it's part of integrate.c.  */\n-extern void allocate_initial_values (VEC (reg_equivs_t, gc) *);\n-\n /* Allocate or grow the reg_equiv tables, initializing new entries to 0.  */\n extern void grow_reg_equivs (void);"}, {"sha": "0bdb21872a7e1c96665ef3900c92c253909e6284", "filename": "gcc/toplev.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=6399c0abb3e562d7dc9cbf2f85998965dac1a1cb", "patch": "@@ -59,7 +59,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"reload.h\"\n #include \"ira.h\"\n #include \"dwarf2asm.h\"\n-#include \"integrate.h\"\n #include \"debug.h\"\n #include \"target.h\"\n #include \"common/common-target.h\""}, {"sha": "ccda8c9a7f54a873303b80ec27fa49da3d38b7d0", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=6399c0abb3e562d7dc9cbf2f85998965dac1a1cb", "patch": "@@ -48,7 +48,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"value-prof.h\"\n #include \"tree-pass.h\"\n #include \"target.h\"\n-#include \"integrate.h\"\n \n #include \"rtl.h\"\t/* FIXME: For asm_str_count.  */\n \n@@ -3236,6 +3235,29 @@ inline_forbidden_p (tree fndecl)\n   pointer_set_destroy (visited_nodes);\n   return forbidden_p;\n }\n+\f\n+/* Return false if the function FNDECL cannot be inlined on account of its\n+   attributes, true otherwise.  */\n+static bool\n+function_attribute_inlinable_p (const_tree fndecl)\n+{\n+  if (targetm.attribute_table)\n+    {\n+      const_tree a;\n+\n+      for (a = DECL_ATTRIBUTES (fndecl); a; a = TREE_CHAIN (a))\n+\t{\n+\t  const_tree name = TREE_PURPOSE (a);\n+\t  int i;\n+\n+\t  for (i = 0; targetm.attribute_table[i].name != NULL; i++)\n+\t    if (is_attribute_p (targetm.attribute_table[i].name, name))\n+\t      return targetm.function_attribute_inlinable_p (fndecl);\n+\t}\n+    }\n+\n+  return true;\n+}\n \n /* Returns nonzero if FN is a function that does not have any\n    fundamental inline blocking properties.  */"}, {"sha": "398d621802ffc52fc84a5c4820dfaf921cfce900", "filename": "gcc/tree.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6399c0abb3e562d7dc9cbf2f85998965dac1a1cb/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=6399c0abb3e562d7dc9cbf2f85998965dac1a1cb", "patch": "@@ -5658,10 +5658,6 @@ extern tree decl_attributes (tree *, tree, int);\n \n extern void apply_tm_attr (tree, tree);\n \n-/* In integrate.c */\n-extern void set_decl_abstract_flags (tree, int);\n-extern void set_decl_origin_self (tree);\n-\n /* In stor-layout.c */\n extern void set_min_and_max_values_for_integral_type (tree, int, bool);\n extern void fixup_signed_type (tree);"}]}