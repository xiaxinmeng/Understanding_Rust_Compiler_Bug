{"sha": "8e42ace183a257767b2af6cce4a412f4c14e9f68", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGU0MmFjZTE4M2EyNTc3NjdiMmFmNmNjZTRhNDEyZjRjMTRlOWY2OA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@hxi.com", "date": "2002-01-03T06:36:42Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2002-01-03T06:36:42Z"}, "message": "* gcse.c: Fix formatting.\n\nFrom-SVN: r48502", "tree": {"sha": "4ec81b9ccd52103bf696edecc89644aa35db0739", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4ec81b9ccd52103bf696edecc89644aa35db0739"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8e42ace183a257767b2af6cce4a412f4c14e9f68", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e42ace183a257767b2af6cce4a412f4c14e9f68", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e42ace183a257767b2af6cce4a412f4c14e9f68", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e42ace183a257767b2af6cce4a412f4c14e9f68/comments", "author": null, "committer": null, "parents": [{"sha": "22e85ed4634e0299f5282fe9dd5ecea1a6841953", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22e85ed4634e0299f5282fe9dd5ecea1a6841953", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22e85ed4634e0299f5282fe9dd5ecea1a6841953"}], "stats": {"total": 89, "additions": 47, "deletions": 42}, "files": [{"sha": "6ebaa260fe6dab54397e10cbe22c3b1c85082814", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e42ace183a257767b2af6cce4a412f4c14e9f68/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e42ace183a257767b2af6cce4a412f4c14e9f68/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8e42ace183a257767b2af6cce4a412f4c14e9f68", "patch": "@@ -1,3 +1,7 @@\n+2002-01-03  Kazu Hirata  <kazu@hxi.com>\n+\n+\t* gcse.c: Fix formatting.\n+\n 2002-01-03  Graham Stott  <grahams@redhat.com>\n \n \t* mkconfig.sh: Output to config.h, hconfig.h and tconfig.h"}, {"sha": "e91b61a484574dedb33c544575adec4098adc0ea", "filename": "gcc/gcse.c", "status": "modified", "additions": 43, "deletions": 42, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e42ace183a257767b2af6cce4a412f4c14e9f68/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e42ace183a257767b2af6cce4a412f4c14e9f68/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=8e42ace183a257767b2af6cce4a412f4c14e9f68", "patch": "@@ -1,6 +1,7 @@\n /* Global common subexpression elimination/Partial redundancy elimination\n    and global constant/copy propagation for GNU compiler.\n-   Copyright (C) 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n+   Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002\n+   Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -753,8 +754,8 @@ gcse_main (f, file)\n   if (n_basic_blocks > 1000 && n_edges / n_basic_blocks >= 20)\n     {\n       if (warn_disabled_optimization)\n-      warning (\"GCSE disabled: %d > 1000 basic blocks and %d >= 20 edges/basic block\",\n-               n_basic_blocks, n_edges / n_basic_blocks);\n+\twarning (\"GCSE disabled: %d > 1000 basic blocks and %d >= 20 edges/basic block\",\n+\t\t n_basic_blocks, n_edges / n_basic_blocks);\n       return 0;\n     }\n \n@@ -917,7 +918,7 @@ compute_can_copy ()\n {\n   int i;\n #ifndef AVOID_CCMODE_COPIES\n-  rtx reg,insn;\n+  rtx reg, insn;\n #endif\n   memset (can_copy_p, 0, NUM_MACHINE_MODES);\n \n@@ -982,7 +983,7 @@ static void\n alloc_gcse_mem (f)\n      rtx f;\n {\n-  int i,n;\n+  int i, n;\n   rtx insn;\n \n   /* Find the largest UID and create a mapping from UIDs to CUIDs.\n@@ -1237,7 +1238,7 @@ record_one_set (regno, insn)\n \t= (struct reg_set **) grealloc ((char *) reg_set_table,\n \t\t\t\t\tnew_size * sizeof (struct reg_set *));\n       memset ((char *) (reg_set_table + reg_set_table_size), 0,\n-\t     (new_size - reg_set_table_size) * sizeof (struct reg_set *));\n+\t      (new_size - reg_set_table_size) * sizeof (struct reg_set *));\n       reg_set_table_size = new_size;\n     }\n \n@@ -1580,7 +1581,7 @@ hash_string_1 (ps)\n      const char *ps;\n {\n   unsigned hash = 0;\n-  const unsigned char *p = (const unsigned char *)ps;\n+  const unsigned char *p = (const unsigned char *) ps;\n   \n   if (p)\n     while (*p)\n@@ -1913,7 +1914,7 @@ expr_equiv_p (x, y)\n \tdefault:\n \t  abort ();\n \t}\n-      }\n+    }\n \n   return 1;\n }\n@@ -2414,7 +2415,7 @@ record_last_mem_set_info (insn)\n       bitmap_set_bit (canon_modify_mem_list_set, BLOCK_NUM (insn));\n     }\n   else\n-    note_stores (PATTERN (insn), canon_list_insert, (void*)insn );\n+    note_stores (PATTERN (insn), canon_list_insert, (void*) insn );\n }\n \n /* Called from compute_hash_table via note_stores to handle one\n@@ -2529,7 +2530,7 @@ compute_hash_table (set_p)\n             hash_scan_insn (insn, set_p, in_libcall_block);\n             if (!set_p && find_reg_note (insn, REG_RETVAL, NULL_RTX))\n               in_libcall_block = 0;\n-\t}\n+\t  }\n     }\n \n   free (reg_avail_info);\n@@ -2574,7 +2575,7 @@ compute_set_hash_table ()\n   /* Initialize count of number of entries in hash table.  */\n   n_sets = 0;\n   memset ((char *) set_hash_table, 0,\n-\t set_hash_table_size * sizeof (struct expr *));\n+\t  set_hash_table_size * sizeof (struct expr *));\n \n   compute_hash_table (1);\n }\n@@ -2618,7 +2619,7 @@ compute_expr_hash_table ()\n   /* Initialize count of number of entries in hash table.  */\n   n_exprs = 0;\n   memset ((char *) expr_hash_table, 0,\n-\t expr_hash_table_size * sizeof (struct expr *));\n+\t  expr_hash_table_size * sizeof (struct expr *));\n \n   compute_hash_table (0);\n }\n@@ -3436,10 +3437,10 @@ handle_avail_expr (insn, expr)\n \t  || (((this_reg = reg_set_table[regnum_for_replacing]),\n \t       this_reg->next == NULL)\n \t      || can_disregard_other_sets (&this_reg, insn, 0)))\n-       {\n-\t use_src = 1;\n-\t found_setting = 1;\n-       }\n+\t{\n+\t  use_src = 1;\n+\t  found_setting = 1;\n+\t}\n     }\n \n   if (!found_setting)\n@@ -3968,7 +3969,7 @@ find_avail_set (regno, insn)\n      This can not happen since the set of (reg Y) would have killed the\n      set of (reg X) making it unavailable at the start of this block.  */\n   while (1)\n-     {\n+    {\n       rtx src;\n       struct expr *set = lookup_set (regno, NULL_RTX);\n \n@@ -4009,7 +4010,7 @@ find_avail_set (regno, insn)\n       /* Follow the copy chain, ie start another iteration of the loop\n \t and see if we have an available copy into SRC.  */\n       regno = REGNO (src);\n-     }\n+    }\n \n   /* SET1 holds the last set that was available and anticipatable at\n      INSN.  */\n@@ -4103,7 +4104,7 @@ cprop_cc0_jump (bb, insn, reg_used, src)\n   delete_insn (insn);\n \n   return 1;\n- }\n+}\n #endif\n  \n /* Perform constant and copy propagation on INSN.\n@@ -4271,7 +4272,7 @@ cprop (alter_jumps)\n \t       call mark_oprs_set if we turned the insn into a NOTE.  */\n \t    if (GET_CODE (insn) != NOTE)\n \t      mark_oprs_set (insn);\n-\t}\n+\t  }\n     }\n \n   if (gcse_file != NULL)\n@@ -4536,7 +4537,7 @@ pre_expr_reaches_here_p (occr_bb, expr, bb)\n   int rval;\n   char *visited = (char *) xcalloc (n_basic_blocks, 1);\n \n-  rval = pre_expr_reaches_here_p_work(occr_bb, expr, bb, visited);\n+  rval = pre_expr_reaches_here_p_work (occr_bb, expr, bb, visited);\n \n   free (visited);\n   return rval;\n@@ -5584,8 +5585,8 @@ hoist_expr_reaches_here_p (expr_bb, expr_index, bb, visited)\n \n   if (visited == NULL)\n     {\n-       visited_allocated_locally = 1;\n-       visited = xcalloc (n_basic_blocks, 1);\n+      visited_allocated_locally = 1;\n+      visited = xcalloc (n_basic_blocks, 1);\n     }\n \n   for (pred = bb->pred; pred != NULL; pred = pred->pred_next)\n@@ -5786,7 +5787,7 @@ hoist_code ()\n \t}\n     }\n \n-    free (index_map);\n+  free (index_map);\n }\n \n /* Top level routine to perform one code hoisting (aka unification) pass\n@@ -6023,7 +6024,7 @@ invalidate_any_buried_refs (x)\n      rtx x;\n {\n   const char * fmt;\n-  int i,j;\n+  int i, j;\n   struct ls_expr * ptr;\n \n   /* Invalidate it in the list.  */\n@@ -6457,7 +6458,7 @@ find_loads (x, store_pattern)\n      rtx x, store_pattern;\n {\n   const char * fmt;\n-  int i,j;\n+  int i, j;\n   int ret = 0;\n \n   if (!x)\n@@ -6539,10 +6540,10 @@ store_killed_after (x, insn, bb)\n      rtx x, insn;\n      basic_block bb;\n {\n-   rtx last = bb->end;\n+  rtx last = bb->end;\n    \n-   if (insn == last)\n-     return 0;\n+  if (insn == last)\n+    return 0;\n \n   /* Check if the register operands of the store are OK in this block.\n      Note that if registers are changed ANYWHERE in the block, we'll \n@@ -6552,9 +6553,9 @@ store_killed_after (x, insn, bb)\n   if (!store_ops_ok (XEXP (x, 0), bb))\n     return 1;\n \n-   for ( ; insn && insn != NEXT_INSN (last); insn = NEXT_INSN (insn))\n-     if (store_killed_in_insn (x, insn))\n-       return 1;\n+  for ( ; insn && insn != NEXT_INSN (last); insn = NEXT_INSN (insn))\n+    if (store_killed_in_insn (x, insn))\n+      return 1;\n    \n   return 0;\n }\n@@ -6566,10 +6567,10 @@ store_killed_before (x, insn, bb)\n      rtx x, insn;\n      basic_block bb;\n {\n-   rtx first = bb->head;\n+  rtx first = bb->head;\n \n-   if (insn == first)\n-     return store_killed_in_insn (x, insn);\n+  if (insn == first)\n+    return store_killed_in_insn (x, insn);\n    \n   /* Check if the register operands of the store are OK in this block.\n      Note that if registers are changed ANYWHERE in the block, we'll \n@@ -6579,11 +6580,11 @@ store_killed_before (x, insn, bb)\n   if (!store_ops_ok (XEXP (x, 0), bb))\n     return 1;\n \n-   for ( ; insn && insn != PREV_INSN (first); insn = PREV_INSN (insn))\n-     if (store_killed_in_insn (x, insn))\n-       return 1;\n+  for ( ; insn && insn != PREV_INSN (first); insn = PREV_INSN (insn))\n+    if (store_killed_in_insn (x, insn))\n+      return 1;\n    \n-   return 0;\n+  return 0;\n }\n \n #define ANTIC_STORE_LIST(x)\t((x)->loads)\n@@ -6638,7 +6639,7 @@ build_store_vectors ()\n \t\t    {\n \t\t      rtx r = gen_reg_rtx (GET_MODE (ptr->pattern));\n \t\t      if (gcse_file)\n-\t\t\tfprintf(gcse_file, \"Removing redundant store:\\n\");\n+\t\t\tfprintf (gcse_file, \"Removing redundant store:\\n\");\n \t\t      replace_store_insn (r, XEXP (st, 0), bb);\n \t\t      XEXP (st, 0) = insn;\n \t\t      continue;\n@@ -6828,9 +6829,9 @@ replace_store_insn (reg, del, bb)\n       fprintf (gcse_file, \n \t       \"STORE_MOTION  delete insn in BB %d:\\n      \", bb->index);\n       print_inline_rtx (gcse_file, del, 6);\n-      fprintf(gcse_file, \"\\nSTORE MOTION  replaced with insn:\\n      \");\n+      fprintf (gcse_file, \"\\nSTORE MOTION  replaced with insn:\\n      \");\n       print_inline_rtx (gcse_file, insn, 6);\n-      fprintf(gcse_file, \"\\n\");\n+      fprintf (gcse_file, \"\\n\");\n     }\n   \n   delete_insn (del);"}]}