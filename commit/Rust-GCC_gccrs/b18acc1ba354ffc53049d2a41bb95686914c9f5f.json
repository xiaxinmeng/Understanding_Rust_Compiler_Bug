{"sha": "b18acc1ba354ffc53049d2a41bb95686914c9f5f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjE4YWNjMWJhMzU0ZmZjNTMwNDlkMmE0MWJiOTU2ODY5MTRjOWY1Zg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-04-08T07:16:54Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-04-08T07:16:54Z"}, "message": "New file.\n\nFrom-SVN: r134081", "tree": {"sha": "251239fe0e2d15ff2b48eb850e1d97aff37bbbf0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/251239fe0e2d15ff2b48eb850e1d97aff37bbbf0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b18acc1ba354ffc53049d2a41bb95686914c9f5f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b18acc1ba354ffc53049d2a41bb95686914c9f5f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b18acc1ba354ffc53049d2a41bb95686914c9f5f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b18acc1ba354ffc53049d2a41bb95686914c9f5f/comments", "author": null, "committer": null, "parents": [{"sha": "c4b8d145ecf89ba6527c1daf6880586f80177b9c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4b8d145ecf89ba6527c1daf6880586f80177b9c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4b8d145ecf89ba6527c1daf6880586f80177b9c"}], "stats": {"total": 698, "additions": 698, "deletions": 0}, "files": [{"sha": "8d181087e971b13dbfdfeb7405b91d61f59cf6a1", "filename": "gcc/ada/s-ststop.adb", "status": "added", "additions": 581, "deletions": 0, "changes": 581, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b18acc1ba354ffc53049d2a41bb95686914c9f5f/gcc%2Fada%2Fs-ststop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b18acc1ba354ffc53049d2a41bb95686914c9f5f/gcc%2Fada%2Fs-ststop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-ststop.adb?ref=b18acc1ba354ffc53049d2a41bb95686914c9f5f", "patch": "@@ -0,0 +1,581 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n+--                                                                          --\n+--              S Y S T E M . S T R I N G S . S T R E A M _ O P S           --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--             Copyright (C) 2008, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+pragma Warnings (Off);\n+pragma Compiler_Unit;\n+pragma Warnings (On);\n+\n+with Ada.Streams;              use Ada.Streams;\n+with Ada.Streams.Stream_IO;    use Ada.Streams.Stream_IO;\n+with Ada.Unchecked_Conversion;\n+\n+with System.Stream_Attributes; use System;\n+\n+package body System.Strings.Stream_Ops is\n+\n+   --  The following package provides an IO framework for strings. Depending\n+   --  on the version of System.Stream_Attributes as well as the size of\n+   --  formal parameter Character_Type, the package will either utilize block\n+   --  IO or character-by-character IO.\n+\n+   generic\n+      type Character_Type is private;\n+      type String_Type is array (Positive range <>) of Character_Type;\n+\n+   package Stream_Ops_Internal is\n+      procedure Read\n+        (Strm : access Root_Stream_Type'Class;\n+         Item : out String_Type);\n+\n+      procedure Write\n+        (Strm : access Root_Stream_Type'Class;\n+         Item : String_Type);\n+   end Stream_Ops_Internal;\n+\n+   -------------------------\n+   -- Stream_Ops_Internal --\n+   -------------------------\n+\n+   package body Stream_Ops_Internal is\n+\n+      --  The following value represents the number of BITS allocated for the\n+      --  default block used in string IO. The sizes of all other types are\n+      --  calculated relative to this value.\n+\n+      Default_Block_Size : constant := 512 * 8;\n+\n+      --  Shorthand notation for stream element and character sizes\n+\n+      C_Size  : constant Integer := Character_Type'Size;\n+      SE_Size : constant Integer := Stream_Element'Size;\n+\n+      --  The following constants describe the number of stream elements or\n+      --  characters that can fit into a default block.\n+\n+      C_In_Default_Block  : constant Integer := Default_Block_Size / C_Size;\n+      SE_In_Default_Block : constant Integer := Default_Block_Size / SE_Size;\n+\n+      --  Buffer types\n+\n+      subtype Default_Block is Stream_Element_Array\n+        (1 .. Stream_Element_Offset (SE_In_Default_Block));\n+\n+      subtype String_Block is String_Type (1 .. C_In_Default_Block);\n+\n+      --  Block IO is used in the following two scenarios:\n+\n+      --    1) When the size of the character type equals that of the stream\n+      --    element type, regardless of endianness.\n+\n+      --    2) When using the standard stream IO routines for elementary\n+      --    types which guarantees the same endianness over partitions.\n+\n+      Use_Block_IO : constant Boolean :=\n+                       C_Size = SE_Size\n+                         or else Stream_Attributes.Block_IO_OK;\n+\n+      --  Conversions to and from Default_Block\n+\n+      function To_Default_Block is\n+        new Ada.Unchecked_Conversion (String_Block, Default_Block);\n+\n+      function To_String_Block is\n+        new Ada.Unchecked_Conversion (Default_Block, String_Block);\n+\n+      ----------\n+      -- Read --\n+      ----------\n+\n+      procedure Read\n+        (Strm : access Root_Stream_Type'Class;\n+         Item : out String_Type)\n+      is\n+      begin\n+         if Strm = null then\n+            raise Constraint_Error;\n+         end if;\n+\n+         --  Nothing to do if the desired string is empty\n+\n+         if Item'Length = 0 then\n+            return;\n+         end if;\n+\n+         if Use_Block_IO then\n+            declare\n+               --  Determine the size in BITS of the block necessary to contain\n+               --  the whole string.\n+\n+               Block_Size : constant Natural :=\n+                              (Item'Last - Item'First + 1) * C_Size;\n+\n+               --  Item can be larger than what the default block can store,\n+               --  determine the number of whole reads necessary to read the\n+               --  string.\n+\n+               Blocks : constant Natural := Block_Size / Default_Block_Size;\n+\n+               --  The size of Item may not be a multiple of the default block\n+               --  size, determine the size of the remaining chunk in BITS.\n+\n+               Rem_Size : constant Natural :=\n+                            Block_Size mod Default_Block_Size;\n+\n+               --  String indices\n+\n+               Low  : Positive := Item'First;\n+               High : Positive := Low + C_In_Default_Block - 1;\n+\n+               --  End of stream error detection\n+\n+               Last : Stream_Element_Offset := 0;\n+               Sum  : Stream_Element_Offset := 0;\n+\n+            begin\n+               --  Step 1: If the string is too large, read in individual\n+               --  chunks the size of the default block.\n+\n+               if Blocks > 0 then\n+                  declare\n+                     Block : Default_Block;\n+\n+                  begin\n+                     for Counter in 1 .. Blocks loop\n+                        Read (Strm.all, Block, Last);\n+                        Item (Low .. High) := To_String_Block (Block);\n+\n+                        Low  := High + 1;\n+                        High := Low + C_In_Default_Block - 1;\n+                        Sum  := Sum + Last;\n+                        Last := 0;\n+                     end loop;\n+                  end;\n+               end if;\n+\n+               --  Step 2: Read in any remaining elements\n+\n+               if Rem_Size > 0 then\n+                  declare\n+                     subtype Rem_Block is Stream_Element_Array\n+                       (1 .. Stream_Element_Offset (Rem_Size / SE_Size));\n+\n+                     subtype Rem_String_Block is\n+                       String_Type (1 .. Rem_Size / C_Size);\n+\n+                     function To_Rem_String_Block is new\n+                       Ada.Unchecked_Conversion (Rem_Block, Rem_String_Block);\n+\n+                     Block : Rem_Block;\n+\n+                  begin\n+                     Read (Strm.all, Block, Last);\n+                     Item (Low .. Item'Last) := To_Rem_String_Block (Block);\n+\n+                     Sum := Sum + Last;\n+                  end;\n+               end if;\n+\n+               --  Step 3: Potential error detection. The sum of all the\n+               --  chunks is less than we initially wanted to read. In other\n+               --  words, the stream does not contain enough elements to fully\n+               --  populate Item.\n+\n+               if (Integer (Sum) * SE_Size) / C_Size < Item'Length then\n+                  raise End_Error;\n+               end if;\n+            end;\n+\n+         --  Character-by-character IO\n+\n+         else\n+            declare\n+               C : Character_Type;\n+\n+            begin\n+               for Index in Item'First .. Item'Last loop\n+                  Character_Type'Read (Strm, C);\n+                  Item (Index) := C;\n+               end loop;\n+            end;\n+         end if;\n+      end Read;\n+\n+      -----------\n+      -- Write --\n+      -----------\n+\n+      procedure Write\n+        (Strm : access Root_Stream_Type'Class;\n+         Item : String_Type)\n+      is\n+      begin\n+         if Strm = null then\n+            raise Constraint_Error;\n+         end if;\n+\n+         --  Nothing to do if the input string is empty\n+\n+         if Item'Length = 0 then\n+            return;\n+         end if;\n+\n+         if Use_Block_IO then\n+            declare\n+               --  Determine the size in BITS of the block necessary to contain\n+               --  the whole string.\n+\n+               Block_Size : constant Natural := Item'Length * C_Size;\n+\n+               --  Item can be larger than what the default block can store,\n+               --  determine the number of whole writes necessary to output the\n+               --  string.\n+\n+               Blocks : constant Natural := Block_Size / Default_Block_Size;\n+\n+               --  The size of Item may not be a multiple of the default block\n+               --  size, determine the size of the remaining chunk.\n+\n+               Rem_Size : constant Natural :=\n+                            Block_Size mod Default_Block_Size;\n+\n+               --  String indices\n+\n+               Low  : Positive := Item'First;\n+               High : Positive := Low + C_In_Default_Block - 1;\n+\n+            begin\n+               --  Step 1: If the string is too large, write out individual\n+               --  chunks the size of the default block.\n+\n+               for Counter in 1 .. Blocks loop\n+                  Write (Strm.all, To_Default_Block (Item (Low .. High)));\n+\n+                  Low  := High + 1;\n+                  High := Low + C_In_Default_Block - 1;\n+               end loop;\n+\n+               --  Step 2: Write out any remaining elements\n+\n+               if Rem_Size > 0 then\n+                  declare\n+                     subtype Rem_Block is Stream_Element_Array\n+                       (1 .. Stream_Element_Offset (Rem_Size / SE_Size));\n+\n+                     subtype Rem_String_Block is\n+                       String_Type (1 .. Rem_Size / C_Size);\n+\n+                     function To_Rem_Block is new\n+                       Ada.Unchecked_Conversion (Rem_String_Block, Rem_Block);\n+\n+                  begin\n+                     Write (Strm.all, To_Rem_Block (Item (Low .. Item'Last)));\n+                  end;\n+               end if;\n+            end;\n+\n+         --  Character-by-character IO\n+\n+         else\n+            for Index in Item'First .. Item'Last loop\n+               Character_Type'Write (Strm, Item (Index));\n+            end loop;\n+         end if;\n+      end Write;\n+   end Stream_Ops_Internal;\n+\n+   --  Specific instantiations for different string types\n+\n+   package String_Ops is\n+     new Stream_Ops_Internal\n+       (Character_Type => Character,\n+        String_Type    => String);\n+\n+   package Wide_String_Ops is\n+     new Stream_Ops_Internal\n+       (Character_Type => Wide_Character,\n+        String_Type    => Wide_String);\n+\n+   package Wide_Wide_String_Ops is\n+     new Stream_Ops_Internal\n+       (Character_Type => Wide_Wide_Character,\n+        String_Type    => Wide_Wide_String);\n+\n+   ------------------\n+   -- String_Input --\n+   ------------------\n+\n+   function String_Input\n+     (Strm : access Ada.Streams.Root_Stream_Type'Class) return String\n+   is\n+   begin\n+      if Strm = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      declare\n+         Low  : Positive;\n+         High : Positive;\n+\n+      begin\n+         --  Read the bounds of the string\n+\n+         Positive'Read (Strm, Low);\n+         Positive'Read (Strm, High);\n+\n+         declare\n+            Item : String (Low .. High);\n+\n+         begin\n+            --  Read the character content of the string\n+\n+            String_Read (Strm, Item);\n+\n+            return Item;\n+         end;\n+      end;\n+   end String_Input;\n+\n+   -------------------\n+   -- String_Output --\n+   -------------------\n+\n+   procedure String_Output\n+     (Strm : access Ada.Streams.Root_Stream_Type'Class;\n+      Item : String)\n+   is\n+   begin\n+      if Strm = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      --  Write the bounds of the string\n+\n+      Positive'Write (Strm, Item'First);\n+      Positive'Write (Strm, Item'Last);\n+\n+      --  Write the character content of the string\n+\n+      String_Write (Strm, Item);\n+   end String_Output;\n+\n+   -----------------\n+   -- String_Read --\n+   -----------------\n+\n+   procedure String_Read\n+     (Strm : access Ada.Streams.Root_Stream_Type'Class;\n+      Item : out String)\n+   is\n+   begin\n+      String_Ops.Read (Strm, Item);\n+   end String_Read;\n+\n+   ------------------\n+   -- String_Write --\n+   ------------------\n+\n+   procedure String_Write\n+     (Strm : access Ada.Streams.Root_Stream_Type'Class;\n+      Item : String)\n+   is\n+   begin\n+      String_Ops.Write (Strm, Item);\n+   end String_Write;\n+\n+   -----------------------\n+   -- Wide_String_Input --\n+   -----------------------\n+\n+   function Wide_String_Input\n+     (Strm : access Ada.Streams.Root_Stream_Type'Class)\n+      return Wide_String\n+   is\n+   begin\n+      if Strm = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      declare\n+         Low  : Positive;\n+         High : Positive;\n+\n+      begin\n+         --  Read the bounds of the string\n+\n+         Positive'Read (Strm, Low);\n+         Positive'Read (Strm, High);\n+\n+         declare\n+            Item : Wide_String (Low .. High);\n+\n+         begin\n+            --  Read the character content of the string\n+\n+            Wide_String_Read (Strm, Item);\n+\n+            return Item;\n+         end;\n+      end;\n+   end Wide_String_Input;\n+\n+   ------------------------\n+   -- Wide_String_Output --\n+   ------------------------\n+\n+   procedure Wide_String_Output\n+     (Strm : access Ada.Streams.Root_Stream_Type'Class;\n+      Item : Wide_String)\n+   is\n+   begin\n+      if Strm = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      --  Write the bounds of the string\n+\n+      Positive'Write (Strm, Item'First);\n+      Positive'Write (Strm, Item'Last);\n+\n+      --  Write the character content of the string\n+\n+      Wide_String_Write (Strm, Item);\n+   end Wide_String_Output;\n+\n+   ----------------------\n+   -- Wide_String_Read --\n+   ----------------------\n+\n+   procedure Wide_String_Read\n+     (Strm : access Ada.Streams.Root_Stream_Type'Class;\n+      Item : out Wide_String)\n+   is\n+   begin\n+      Wide_String_Ops.Read (Strm, Item);\n+   end Wide_String_Read;\n+\n+   -----------------------\n+   -- Wide_String_Write --\n+   -----------------------\n+\n+   procedure Wide_String_Write\n+     (Strm : access Ada.Streams.Root_Stream_Type'Class;\n+      Item : Wide_String)\n+   is\n+   begin\n+      Wide_String_Ops.Write (Strm, Item);\n+   end Wide_String_Write;\n+\n+   ----------------------------\n+   -- Wide_Wide_String_Input --\n+   ----------------------------\n+\n+   function Wide_Wide_String_Input\n+     (Strm : access Ada.Streams.Root_Stream_Type'Class)\n+      return Wide_Wide_String\n+   is\n+   begin\n+      if Strm = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      declare\n+         Low  : Positive;\n+         High : Positive;\n+\n+      begin\n+         --  Read the bounds of the string\n+\n+         Positive'Read (Strm, Low);\n+         Positive'Read (Strm, High);\n+\n+         declare\n+            Item : Wide_Wide_String (Low .. High);\n+\n+         begin\n+            --  Read the character content of the string\n+\n+            Wide_Wide_String_Read (Strm, Item);\n+\n+            return Item;\n+         end;\n+      end;\n+   end Wide_Wide_String_Input;\n+\n+   -----------------------------\n+   -- Wide_Wide_String_Output --\n+   -----------------------------\n+\n+   procedure Wide_Wide_String_Output\n+     (Strm : access Ada.Streams.Root_Stream_Type'Class;\n+      Item : Wide_Wide_String)\n+   is\n+   begin\n+      if Strm = null then\n+         raise Constraint_Error;\n+      end if;\n+\n+      --  Write the bounds of the string\n+\n+      Positive'Write (Strm, Item'First);\n+      Positive'Write (Strm, Item'Last);\n+\n+      --  Write the character content of the string\n+\n+      Wide_Wide_String_Write (Strm, Item);\n+   end Wide_Wide_String_Output;\n+\n+   ---------------------------\n+   -- Wide_Wide_String_Read --\n+   ---------------------------\n+\n+   procedure Wide_Wide_String_Read\n+     (Strm : access Ada.Streams.Root_Stream_Type'Class;\n+      Item : out Wide_Wide_String)\n+   is\n+   begin\n+      Wide_Wide_String_Ops.Read (Strm, Item);\n+   end Wide_Wide_String_Read;\n+\n+   ----------------------------\n+   -- Wide_Wide_String_Write --\n+   ----------------------------\n+\n+   procedure Wide_Wide_String_Write\n+     (Strm : access Ada.Streams.Root_Stream_Type'Class;\n+      Item : Wide_Wide_String)\n+   is\n+   begin\n+      Wide_Wide_String_Ops.Write (Strm, Item);\n+   end Wide_Wide_String_Write;\n+\n+end System.Strings.Stream_Ops;"}, {"sha": "f954bccfc7b000a6dffa557c48cd867ae7ef1daa", "filename": "gcc/ada/s-ststop.ads", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b18acc1ba354ffc53049d2a41bb95686914c9f5f/gcc%2Fada%2Fs-ststop.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b18acc1ba354ffc53049d2a41bb95686914c9f5f/gcc%2Fada%2Fs-ststop.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-ststop.ads?ref=b18acc1ba354ffc53049d2a41bb95686914c9f5f", "patch": "@@ -0,0 +1,117 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n+--                                                                          --\n+--              S Y S T E M . S T R I N G S . S T R E A M _ O P S           --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--             Copyright (C) 2008, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package provides subprogram implementations of stream attributes for\n+--  the following types:\n+--     Ada.String\n+--     Ada.Wide_String\n+--     Ada.Wide_Wide_String\n+--\n+--  The compiler will generate references to the subprograms in this package\n+--  when expanding stream attributes for the above mentioned types. Example:\n+--\n+--     String'Output (Some_Stream, Some_String);\n+--\n+--  will be expanded into:\n+--\n+--     String_Output (Some_Stream, Some_String);\n+\n+pragma Warnings (Off);\n+pragma Compiler_Unit;\n+pragma Warnings (On);\n+\n+with Ada.Streams;\n+\n+package System.Strings.Stream_Ops is\n+\n+   ------------------------------\n+   -- String stream operations --\n+   ------------------------------\n+\n+   function String_Input\n+     (Strm : access Ada.Streams.Root_Stream_Type'Class)\n+      return String;\n+\n+   procedure String_Output\n+     (Strm : access Ada.Streams.Root_Stream_Type'Class;\n+      Item : String);\n+\n+   procedure String_Read\n+     (Strm : access Ada.Streams.Root_Stream_Type'Class;\n+      Item : out String);\n+\n+   procedure String_Write\n+     (Strm : access Ada.Streams.Root_Stream_Type'Class;\n+      Item : String);\n+\n+   -----------------------------------\n+   -- Wide_String stream operations --\n+   -----------------------------------\n+\n+   function Wide_String_Input\n+     (Strm : access Ada.Streams.Root_Stream_Type'Class)\n+      return Wide_String;\n+\n+   procedure Wide_String_Output\n+     (Strm : access Ada.Streams.Root_Stream_Type'Class;\n+      Item : Wide_String);\n+\n+   procedure Wide_String_Read\n+     (Strm : access Ada.Streams.Root_Stream_Type'Class;\n+      Item : out Wide_String);\n+\n+   procedure Wide_String_Write\n+     (Strm : access Ada.Streams.Root_Stream_Type'Class;\n+      Item : Wide_String);\n+\n+   ----------------------------------------\n+   -- Wide_Wide_String stream operations --\n+   ----------------------------------------\n+\n+   function Wide_Wide_String_Input\n+     (Strm : access Ada.Streams.Root_Stream_Type'Class)\n+      return Wide_Wide_String;\n+\n+   procedure Wide_Wide_String_Output\n+     (Strm : access Ada.Streams.Root_Stream_Type'Class;\n+      Item : Wide_Wide_String);\n+\n+   procedure Wide_Wide_String_Read\n+     (Strm : access Ada.Streams.Root_Stream_Type'Class;\n+      Item : out Wide_Wide_String);\n+\n+   procedure Wide_Wide_String_Write\n+     (Strm : access Ada.Streams.Root_Stream_Type'Class;\n+      Item : Wide_Wide_String);\n+\n+end System.Strings.Stream_Ops;"}]}