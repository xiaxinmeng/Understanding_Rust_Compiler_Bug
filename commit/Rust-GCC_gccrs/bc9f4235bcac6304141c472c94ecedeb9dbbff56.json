{"sha": "bc9f4235bcac6304141c472c94ecedeb9dbbff56", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmM5ZjQyMzViY2FjNjMwNDE0MWM0NzJjOTRlY2VkZWI5ZGJiZmY1Ng==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-07-03T07:26:21Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-07-03T07:26:21Z"}, "message": "Tweak BB analysis for dr_analyze_innermost\n\ndr_analyze_innermost had a \"struct loop *nest\" parameter that acted\nlike a boolean.  This was added in r179161, with the idea that a\nnull nest selected BB-level analysis rather than loop analysis.\n\nThe handling seemed strange though.  If the DR was part of a loop,\nwe still tried to express the base and offset values as IVs, potentially\ngiving a nonzero step.  If that failed for any reason, we'd revert to\nusing the original base and offset, just as we would if we hadn't asked\nfor an IV in the first place.\n\nIt seems more natural to use the !in_loop handling whenever nest is null\nand always set the step to zero.  This actually enables one more SLP\nopportunity in bb-slp-pr65935.c.\n\nI checked out r179161 and tried the patch there.  The test case added\nin that revision still passes, so I don't think there was any particular\nneed to check simple_iv.\n\n2017-06-28  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* tree-data-ref.c (dr_analyze_innermost): Replace the \"nest\"\n\tparameter with a \"loop\" parameter and use it instead of the\n\tloop containing DR_STMT.  Don't check simple_iv when doing\n\tBB analysis.  Describe the two analysis modes in the comment.\n\ngcc/testsuite/\n\t* gcc.dg/vect/bb-slp-pr65935.c: Expect SLP to be used in main\n\tas well.\n\nFrom-SVN: r249896", "tree": {"sha": "19ef8dff4a03330cb84a3a52d8b86063fe8f40a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/19ef8dff4a03330cb84a3a52d8b86063fe8f40a1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bc9f4235bcac6304141c472c94ecedeb9dbbff56", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc9f4235bcac6304141c472c94ecedeb9dbbff56", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc9f4235bcac6304141c472c94ecedeb9dbbff56", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc9f4235bcac6304141c472c94ecedeb9dbbff56/comments", "author": null, "committer": null, "parents": [{"sha": "be086ff50c79270411f14eec2d8f02c2b5bdb322", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be086ff50c79270411f14eec2d8f02c2b5bdb322", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be086ff50c79270411f14eec2d8f02c2b5bdb322"}], "stats": {"total": 82, "additions": 44, "deletions": 38}, "files": [{"sha": "08657e0accf0f31343b4eb282e530fc43b97f640", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc9f4235bcac6304141c472c94ecedeb9dbbff56/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc9f4235bcac6304141c472c94ecedeb9dbbff56/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bc9f4235bcac6304141c472c94ecedeb9dbbff56", "patch": "@@ -1,3 +1,10 @@\n+2017-07-03  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* tree-data-ref.c (dr_analyze_innermost): Replace the \"nest\"\n+\tparameter with a \"loop\" parameter and use it instead of the\n+\tloop containing DR_STMT.  Don't check simple_iv when doing\n+\tBB analysis.  Describe the two analysis modes in the comment.\n+\n 2017-07-03  Tom de Vries  <tom@codesourcery.com>\n \n \tPR tree-optimization/69468"}, {"sha": "f5d2f8be78973bb60770cc8b69aa3ace42429bcc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc9f4235bcac6304141c472c94ecedeb9dbbff56/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc9f4235bcac6304141c472c94ecedeb9dbbff56/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bc9f4235bcac6304141c472c94ecedeb9dbbff56", "patch": "@@ -1,3 +1,8 @@\n+2017-07-03  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* gcc.dg/vect/bb-slp-pr65935.c: Expect SLP to be used in main\n+\tas well.\n+\n 2017-07-03  Tom de Vries  <tom@codesourcery.com>\n \n \tPR tree-optimization/69468"}, {"sha": "0e4f1a71b6b55d8570b26acac6685600332f45d6", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-pr65935.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc9f4235bcac6304141c472c94ecedeb9dbbff56/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr65935.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc9f4235bcac6304141c472c94ecedeb9dbbff56/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr65935.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr65935.c?ref=bc9f4235bcac6304141c472c94ecedeb9dbbff56", "patch": "@@ -57,4 +57,6 @@ int main()\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"basic block vectorized\" 1 \"slp1\" } } */\n+/* We should also be able to use 2-lane SLP to initialize the real and\n+   imaginary components in the first loop of main.  */\n+/* { dg-final { scan-tree-dump-times \"basic block vectorized\" 2 \"slp1\" } } */"}, {"sha": "0fcefdc43b1d0b3907540f245ccb6de756fcafe6", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 29, "deletions": 37, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc9f4235bcac6304141c472c94ecedeb9dbbff56/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc9f4235bcac6304141c472c94ecedeb9dbbff56/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=bc9f4235bcac6304141c472c94ecedeb9dbbff56", "patch": "@@ -749,15 +749,29 @@ canonicalize_base_object_address (tree addr)\n   return build_fold_addr_expr (TREE_OPERAND (addr, 0));\n }\n \n-/* Analyzes the behavior of the memory reference DR in the innermost loop or\n-   basic block that contains it.  Returns true if analysis succeed or false\n-   otherwise.  */\n+/* Analyze the behavior of memory reference DR.  There are two modes:\n+\n+   - BB analysis.  In this case we simply split the address into base,\n+     init and offset components, without reference to any containing loop.\n+     The resulting base and offset are general expressions and they can\n+     vary arbitrarily from one iteration of the containing loop to the next.\n+     The step is always zero.\n+\n+   - loop analysis.  In this case we analyze the reference both wrt LOOP\n+     and on the basis that the reference occurs (is \"used\") in LOOP;\n+     see the comment above analyze_scalar_evolution_in_loop for more\n+     information about this distinction.  The base, init, offset and\n+     step fields are all invariant in LOOP.\n+\n+   Perform BB analysis if LOOP is null, or if LOOP is the function's\n+   dummy outermost loop.  In other cases perform loop analysis.\n+\n+   Return true if the analysis succeeded and store the results in DR if so.\n+   BB analysis can only fail for bitfield or reversed-storage accesses.  */\n \n bool\n-dr_analyze_innermost (struct data_reference *dr, struct loop *nest)\n+dr_analyze_innermost (struct data_reference *dr, struct loop *loop)\n {\n-  gimple *stmt = DR_STMT (dr);\n-  struct loop *loop = loop_containing_stmt (stmt);\n   tree ref = DR_REF (dr);\n   HOST_WIDE_INT pbitsize, pbitpos;\n   tree base, poffset;\n@@ -806,22 +820,11 @@ dr_analyze_innermost (struct data_reference *dr, struct loop *nest)\n \n   if (in_loop)\n     {\n-      if (!simple_iv (loop, loop_containing_stmt (stmt), base, &base_iv,\n-                      nest ? true : false))\n+      if (!simple_iv (loop, loop, base, &base_iv, true))\n         {\n-          if (nest)\n-            {\n-              if (dump_file && (dump_flags & TDF_DETAILS))\n-                fprintf (dump_file, \"failed: evolution of base is not\"\n-                                    \" affine.\\n\");\n-              return false;\n-            }\n-          else\n-            {\n-              base_iv.base = base;\n-              base_iv.step = ssize_int (0);\n-              base_iv.no_overflow = true;\n-            }\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \"failed: evolution of base is not affine.\\n\");\n+\t  return false;\n         }\n     }\n   else\n@@ -843,22 +846,11 @@ dr_analyze_innermost (struct data_reference *dr, struct loop *nest)\n           offset_iv.base = poffset;\n           offset_iv.step = ssize_int (0);\n         }\n-      else if (!simple_iv (loop, loop_containing_stmt (stmt),\n-                           poffset, &offset_iv,\n-\t\t\t   nest ? true : false))\n+      else if (!simple_iv (loop, loop, poffset, &offset_iv, true))\n         {\n-          if (nest)\n-            {\n-              if (dump_file && (dump_flags & TDF_DETAILS))\n-                fprintf (dump_file, \"failed: evolution of offset is not\"\n-                                    \" affine.\\n\");\n-              return false;\n-            }\n-          else\n-            {\n-              offset_iv.base = poffset;\n-              offset_iv.step = ssize_int (0);\n-            }\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \"failed: evolution of offset is not affine.\\n\");\n+\t  return false;\n         }\n     }\n \n@@ -1077,7 +1069,7 @@ create_data_ref (loop_p nest, loop_p loop, tree memref, gimple *stmt,\n   DR_REF (dr) = memref;\n   DR_IS_READ (dr) = is_read;\n \n-  dr_analyze_innermost (dr, nest);\n+  dr_analyze_innermost (dr, nest != NULL ? loop : NULL);\n   dr_analyze_indices (dr, nest, loop);\n   dr_analyze_alias (dr);\n "}]}