{"sha": "7ec02c04f7b98ebdeec75e8e428e3b0e14fe2e32", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2VjMDJjMDRmN2I5OGViZGVlYzc1ZThlNDI4ZTNiMGUxNGZlMmUzMg==", "commit": {"author": {"name": "Frank Ch. Eigler", "email": "fche@redhat.com", "date": "2004-10-28T21:24:33Z"}, "committer": {"name": "Frank Ch. Eigler", "email": "fche@gcc.gnu.org", "date": "2004-10-28T21:24:33Z"}, "message": "tree-mudflap.c (mudflap_init): Mark cache-lookup decls to prevent their later unnecessary registration.\n\n2004-10-28  Frank Ch. Eigler  <fche@redhat.com>\n\n\t* tree-mudflap.c (mudflap_init): Mark cache-lookup decls to\n\tprevent their later unnecessary registration.\n\t(mf_build_check_statement_for): Remove \"addr\" argument, and\n\trelated \"__mf_value\" generated code.  Update callers.\n\t(mf_decl_eligible_p): New function, factored from mx_register_decls.\n\t(mx_register_decls): Call it.\n\t(mf_xform_derefs_1): Rewrite COMPONENT_REF and ARRAY_REF cases\n\tto restore support for complex nested expressions.\n\t(mudflap_enqueue_decl): Simplify.  Move registration call emission\n\tout ...\n\t(mudflap_finish_file): ... to here.\n\t(mudflap_enqueue_constant): Remove dump code.\n\nFrom-SVN: r89784", "tree": {"sha": "2116152a892bf767b218e4211d3d78f3c66c354e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2116152a892bf767b218e4211d3d78f3c66c354e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7ec02c04f7b98ebdeec75e8e428e3b0e14fe2e32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ec02c04f7b98ebdeec75e8e428e3b0e14fe2e32", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ec02c04f7b98ebdeec75e8e428e3b0e14fe2e32", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ec02c04f7b98ebdeec75e8e428e3b0e14fe2e32/comments", "author": {"login": "fche", "id": 588885, "node_id": "MDQ6VXNlcjU4ODg4NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/588885?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fche", "html_url": "https://github.com/fche", "followers_url": "https://api.github.com/users/fche/followers", "following_url": "https://api.github.com/users/fche/following{/other_user}", "gists_url": "https://api.github.com/users/fche/gists{/gist_id}", "starred_url": "https://api.github.com/users/fche/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fche/subscriptions", "organizations_url": "https://api.github.com/users/fche/orgs", "repos_url": "https://api.github.com/users/fche/repos", "events_url": "https://api.github.com/users/fche/events{/privacy}", "received_events_url": "https://api.github.com/users/fche/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "306ae32b68b216a739941505e45656524cec5347", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/306ae32b68b216a739941505e45656524cec5347", "html_url": "https://github.com/Rust-GCC/gccrs/commit/306ae32b68b216a739941505e45656524cec5347"}], "stats": {"total": 339, "additions": 170, "deletions": 169}, "files": [{"sha": "a0b97c722686bdf36a6ff1cbe3f0c8614ce7a50f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ec02c04f7b98ebdeec75e8e428e3b0e14fe2e32/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ec02c04f7b98ebdeec75e8e428e3b0e14fe2e32/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7ec02c04f7b98ebdeec75e8e428e3b0e14fe2e32", "patch": "@@ -1,3 +1,18 @@\n+2004-10-28  Frank Ch. Eigler  <fche@redhat.com>\n+\n+\t* tree-mudflap.c (mudflap_init): Mark cache-lookup decls to\n+\tprevent their later unnecessary registration.\n+\t(mf_build_check_statement_for): Remove \"addr\" argument, and\n+\trelated \"__mf_value\" generated code.  Update callers.\n+\t(mf_decl_eligible_p): New function, factored from mx_register_decls.\n+\t(mx_register_decls): Call it.\n+\t(mf_xform_derefs_1): Rewrite COMPONENT_REF and ARRAY_REF cases\n+\tto restore support for complex nested expressions.\n+\t(mudflap_enqueue_decl): Simplify.  Move registration call emission\n+\tout ...\n+\t(mudflap_finish_file): ... to here.\n+\t(mudflap_enqueue_constant): Remove dump code.\n+\n 2004-10-28  Zack Weinberg  <zack@codesourcery.com>\n \n \tPR 18199"}, {"sha": "3ff50b61dd23befa8e625ca1b3347ba604a5aff8", "filename": "gcc/tree-mudflap.c", "status": "modified", "additions": 155, "deletions": 169, "changes": 324, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ec02c04f7b98ebdeec75e8e428e3b0e14fe2e32/gcc%2Ftree-mudflap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ec02c04f7b98ebdeec75e8e428e3b0e14fe2e32/gcc%2Ftree-mudflap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-mudflap.c?ref=7ec02c04f7b98ebdeec75e8e428e3b0e14fe2e32", "patch": "@@ -378,6 +378,11 @@ mudflap_init (void)\n                                          unsigned_char_type_node);\n   mf_cache_mask_decl = mf_make_builtin (VAR_DECL, \"__mf_lc_mask\",\n                                         mf_uintptr_type);\n+  /* Don't process these in mudflap_enqueue_decl, should they come by\n+     there for some reason. */\n+  mf_mark (mf_cache_array_decl);\n+  mf_mark (mf_cache_shift_decl);\n+  mf_mark (mf_cache_mask_decl);\n   mf_check_fndecl = mf_make_builtin (FUNCTION_DECL, \"__mf_check\",\n                                      mf_check_register_fntype);\n   mf_register_fndecl = mf_make_builtin (FUNCTION_DECL, \"__mf_register\",\n@@ -484,17 +489,15 @@ mf_decl_clear_locals (void)\n }\n \n static void\n-mf_build_check_statement_for (tree base, tree addr, tree limit,\n+mf_build_check_statement_for (tree base, tree limit,\n                               block_stmt_iterator *instr_bsi,\n                               location_t *locus, tree dirflag)\n {\n   tree_stmt_iterator head, tsi;\n-  tree ptrtype = TREE_TYPE (addr);\n   block_stmt_iterator bsi;\n   basic_block cond_bb, then_bb, join_bb;\n   edge e;\n   tree cond, t, u, v, l1, l2;\n-  tree mf_value;\n   tree mf_base;\n   tree mf_elem;\n   tree mf_limit;\n@@ -558,24 +561,17 @@ mf_build_check_statement_for (tree base, tree addr, tree limit,\n     }\n \n   /* Build our local variables.  */\n-  mf_value = create_tmp_var (ptrtype, \"__mf_value\");\n   mf_elem = create_tmp_var (mf_cache_structptr_type, \"__mf_elem\");\n   mf_base = create_tmp_var (mf_uintptr_type, \"__mf_base\");\n   mf_limit = create_tmp_var (mf_uintptr_type, \"__mf_limit\");\n \n-  /* Build: __mf_value = <address expression>.  */\n-  t = build (MODIFY_EXPR, void_type_node, mf_value, unshare_expr (addr));\n-  SET_EXPR_LOCUS (t, locus);\n-  gimplify_to_stmt_list (&t);\n-  head = tsi_start (t);\n-  tsi = tsi_last (t);\n-\n   /* Build: __mf_base = (uintptr_t) <base address expression>.  */\n   t = build (MODIFY_EXPR, void_type_node, mf_base,\n              convert (mf_uintptr_type, unshare_expr (base)));\n   SET_EXPR_LOCUS (t, locus);\n   gimplify_to_stmt_list (&t);\n-  tsi_link_after (&tsi, t, TSI_CONTINUE_LINKING);\n+  head = tsi_start (t);\n+  tsi = tsi_last (t);\n \n   /* Build: __mf_limit = (uintptr_t) <limit address expression>.  */\n   t = build (MODIFY_EXPR, void_type_node, mf_limit,\n@@ -679,8 +675,7 @@ mf_build_check_statement_for (tree base, tree addr, tree limit,\n                                              : *locus),\n                  NULL_TREE);\n   u = tree_cons (NULL_TREE, dirflag, u);\n-  /* NB: we pass the overall [base..limit] range to mf_check,\n-     not the [mf_value..mf_value+size-1] range.  */\n+  /* NB: we pass the overall [base..limit] range to mf_check.  */\n   u = tree_cons (NULL_TREE, \n                  fold (build (PLUS_EXPR, integer_type_node,\n                               fold (build (MINUS_EXPR, mf_uintptr_type, mf_limit, mf_base)),\n@@ -712,11 +707,33 @@ mf_build_check_statement_for (tree base, tree addr, tree limit,\n   bsi_next (instr_bsi);\n }\n \n+\n+/* Check whether the given decl, generally a VAR_DECL or PARM_DECL, is\n+   eligible for instrumentation.  For the mudflap1 pass, this implies\n+   that it should be registered with the libmudflap runtime.  For the\n+   mudflap2 pass this means instrumenting an indirection operation with\n+   respect to the object.\n+*/\n+static int\n+mf_decl_eligible_p (tree decl)\n+{\n+  return ((TREE_CODE (decl) == VAR_DECL || TREE_CODE (decl) == PARM_DECL)\n+          /* The decl must have its address taken.  In the case of\n+             arrays, this flag is also set if the indexes are not\n+             compile-time known valid constants.  */\n+          && TREE_ADDRESSABLE (decl)\n+          /* The type of the variable must be complete.  */\n+          && COMPLETE_OR_VOID_TYPE_P (TREE_TYPE (decl))\n+\t  /* The decl hasn't been decomposed somehow.  */\n+\t  && DECL_VALUE_EXPR (decl) == NULL);\n+}\n+\n+\n static void\n mf_xform_derefs_1 (block_stmt_iterator *iter, tree *tp,\n                    location_t *locus, tree dirflag)\n {\n-  tree type, ptr_type, addr, base, size, limit, t;\n+  tree type, ptr_type, base, limit, addr, size, t;\n \n   /* Don't instrument read operations.  */\n   if (dirflag == integer_zero_node && flag_mudflap_ignore_reads)\n@@ -733,47 +750,90 @@ mf_xform_derefs_1 (block_stmt_iterator *iter, tree *tp,\n   switch (TREE_CODE (t))\n     {\n     case ARRAY_REF:\n+    case COMPONENT_REF:\n       {\n-        /* Omit checking if we can statically determine that the access is\n-           valid.  For non-addressable local arrays this is not optional,\n-           since we won't have called __mf_register for the object.  */\n-        tree op0, op1;\n-\n-        op0 = TREE_OPERAND (t, 0);\n-        op1 = TREE_OPERAND (t, 1);\n-        while (TREE_CODE (op1) == INTEGER_CST)\n+        /* This is trickier than it may first appear.  The reason is\n+           that we are looking at expressions from the \"inside out\" at\n+           this point.  We may have a complex nested aggregate/array\n+           expression (e.g. \"a.b[i].c\"), maybe with an indirection as\n+           the leftmost operator (\"p->a.b.d\"), where instrumentation\n+           is necessary.  Or we may have an innocent \"a.b.c\"\n+           expression that must not be instrumented.  We need to\n+           recurse all the way down the nesting structure to figure it\n+           out: looking just at the outer node is not enough.  */          \n+        tree var;\n+        int component_ref_only = TREE_CODE (t) == COMPONENT_REF;\n+\n+        /* Iterate to the top of the ARRAY_REF/COMPONENT_REF\n+           containment hierarchy to find the outermost VAR_DECL.  */\n+        var = TREE_OPERAND (t, 0);\n+        while (1)\n           {\n-            tree dom = TYPE_DOMAIN (TREE_TYPE (op0));\n-\n-            /* Test for index in range.  Break if not.  */\n-            if (!dom\n-                || (! TYPE_MIN_VALUE (dom)\n-                    || ! really_constant_p (TYPE_MIN_VALUE (dom)))\n-                || (! TYPE_MAX_VALUE (dom)\n-                    || ! really_constant_p (TYPE_MAX_VALUE (dom)))\n-                || (tree_int_cst_lt (op1, TYPE_MIN_VALUE (dom))\n-                    || tree_int_cst_lt (TYPE_MAX_VALUE (dom), op1)))\n-              break;\n+            if (TREE_CODE (var) == ARRAY_REF)\n+              {\n+                component_ref_only = 0;\n+                var = TREE_OPERAND (var, 0);\n+              }\n+            else if (TREE_CODE (var) == COMPONENT_REF)\n+              var = TREE_OPERAND (var, 0);\n+            else if (INDIRECT_REF_P (var))\n+              {\n+                component_ref_only = 0;\n+                break;\n+              }\n+            else \n+              {\n+                gcc_assert (TREE_CODE (var) == VAR_DECL \n+                            || TREE_CODE (var) == PARM_DECL);\n+                /* Don't instrument this access if the underlying\n+                   variable is not \"eligible\".  This test matches\n+                   those arrays that have only known-valid indexes,\n+                   and thus are not labeled TREE_ADDRESSABLE. */\n+                if (! mf_decl_eligible_p (var))\n+                  return;\n+                else\n+                  break;\n+              }\n+          }\n \n-            /* If we're looking at a non-external VAR_DECL, then the \n-               access must be ok.  */\n-            if (TREE_CODE (op0) == VAR_DECL && !DECL_EXTERNAL (op0))\n-              return;\n+        /* Handle the case of ordinary non-indirection structure\n+           accesses.  These have only nested COMPONENT_REF nodes (no\n+           INDIRECT_REF), but pass through the above filter loop.\n+           Note that it's possible for such a struct variable to match\n+           the eligible_p test because someone else might take its\n+           address sometime.  */\n+        if (component_ref_only)\n+          return;\n \n-            /* Only continue if we're still looking at an array.  */\n-            if (TREE_CODE (op0) != ARRAY_REF)\n-              break;\n+        ptr_type = build_pointer_type (type);\n \n-            op1 = TREE_OPERAND (op0, 1);\n-            op0 = TREE_OPERAND (op0, 0);\n+        /* We need special processing for bitfield components, because\n+           their addresses cannot be taken.  */\n+        if (TREE_CODE (t) == COMPONENT_REF\n+            && DECL_BIT_FIELD_TYPE (TREE_OPERAND (t, 1)))\n+          {\n+            tree field = TREE_OPERAND (t, 1);\n+\n+            if (TREE_CODE (DECL_SIZE_UNIT (field)) == INTEGER_CST)\n+              size = DECL_SIZE_UNIT (field);\n+            \n+            addr = TREE_OPERAND (TREE_OPERAND (t, 0), 0);\n+            addr = fold_convert (ptr_type_node, addr);\n+            addr = fold (build (PLUS_EXPR, ptr_type_node,\n+                                addr, fold_convert (ptr_type_node,\n+                                                    byte_position (field))));           \n           }\n-      \n-        /* If we got here, we couldn't statically the check.  */\n-        ptr_type = build_pointer_type (type);\n-        addr = build1 (ADDR_EXPR, ptr_type, t);\n-        base = build1 (ADDR_EXPR, ptr_type, op0);\n+        else\n+          addr = build1 (ADDR_EXPR, build_pointer_type (type), t);\n+\n+        if (INDIRECT_REF_P (var))\n+          base = TREE_OPERAND (var, 0);\n+        else\n+          base = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (var)), var);\n         limit = fold (build (MINUS_EXPR, mf_uintptr_type,\n-                             fold (build2 (PLUS_EXPR, mf_uintptr_type, addr, size)),\n+                             fold (build2 (PLUS_EXPR, mf_uintptr_type, \n+                                           convert (mf_uintptr_type, addr), \n+                                           size)),\n                              integer_one_node));\n       }\n       break;\n@@ -791,46 +851,8 @@ mf_xform_derefs_1 (block_stmt_iterator *iter, tree *tp,\n       warning (\"mudflap checking not yet implemented for ARRAY_RANGE_REF\");\n       return;\n \n-    case COMPONENT_REF:\n-      {\n-        tree field;\n-\n-        /* If we're not dereferencing something, then the access\n-           must be ok.  */\n-        if (TREE_CODE (TREE_OPERAND (t, 0)) != INDIRECT_REF)\n-          return;\n-\n-        field = TREE_OPERAND (t, 1);\n-\n-        /* If we're looking at a bit field, then we can't take its address\n-           with ADDR_EXPR -- lang_hooks.mark_addressable will error.  Do\n-           things the hard way with PLUS.  */\n-        if (DECL_BIT_FIELD_TYPE (field))\n-          {\n-            if (TREE_CODE (DECL_SIZE_UNIT (field)) == INTEGER_CST)\n-              size = DECL_SIZE_UNIT (field);\n-\n-            addr = TREE_OPERAND (TREE_OPERAND (t, 0), 0);\n-            addr = fold_convert (ptr_type_node, addr);\n-            addr = fold (build (PLUS_EXPR, ptr_type_node,\n-                                addr, fold_convert (ptr_type_node,\n-                                                    byte_position (field))));\n-          }\n-        else\n-          {\n-            ptr_type = build_pointer_type (type);\n-            addr = build1 (ADDR_EXPR, ptr_type, t);\n-          }\n-\n-        /* XXXXXX */\n-        base = addr;\n-        limit = fold (build (MINUS_EXPR, ptr_type_node,\n-                             fold (build (PLUS_EXPR, ptr_type_node, base, size)),\n-                             integer_one_node));\n-      }\n-      break;\n-\n     case BIT_FIELD_REF:\n+      /* ??? merge with COMPONENT_REF code above? */\n       {\n         tree ofs, rem, bpu;\n \n@@ -864,7 +886,7 @@ mf_xform_derefs_1 (block_stmt_iterator *iter, tree *tp,\n       return;\n     }\n \n-  mf_build_check_statement_for (base, addr, limit, iter, locus, dirflag);\n+  mf_build_check_statement_for (base, limit, iter, locus, dirflag);\n }\n \n static void\n@@ -959,19 +981,12 @@ mx_register_decls (tree decl, tree *stmt_list)\n \n   while (decl != NULL_TREE)\n     {\n-      /* Eligible decl?  */\n-      if ((TREE_CODE (decl) == VAR_DECL || TREE_CODE (decl) == PARM_DECL)\n-          /* It must be a non-external, automatic variable.  */\n+      if (mf_decl_eligible_p (decl) \n+          /* Not already processed.  */\n+          && ! mf_marked_p (decl)\n+          /* Automatic variable.  */\n           && ! DECL_EXTERNAL (decl)\n-          && ! TREE_STATIC (decl)\n-          /* The decl must have its address taken.  */\n-          && TREE_ADDRESSABLE (decl)\n-          /* The type of the variable must be complete.  */\n-          && COMPLETE_OR_VOID_TYPE_P (TREE_TYPE (decl))\n-\t  /* The decl hasn't been decomposed somehow.  */\n-\t  && DECL_VALUE_EXPR (decl) == NULL\n-          /* Don't process the same decl twice.  */\n-          && ! mf_marked_p (decl))\n+          && ! TREE_STATIC (decl))\n         {\n           tree size = NULL_TREE, variable_name;\n           tree unregister_fncall, unregister_fncall_params;\n@@ -1180,50 +1195,13 @@ mudflap_enqueue_decl (tree obj)\n   if (DECL_P (obj) && DECL_EXTERNAL (obj) && DECL_ARTIFICIAL (obj))\n     return;\n \n-  if (COMPLETE_TYPE_P (TREE_TYPE (obj)))\n-    {\n-      tree object_size;\n-\n-      mf_mark (obj);\n-\n-      object_size = size_in_bytes (TREE_TYPE (obj));\n-\n-      if (dump_file)\n-        {\n-          fprintf (dump_file, \"enqueue_decl obj=`\");\n-          print_generic_expr (dump_file, obj, dump_flags);\n-          fprintf (dump_file, \"' size=\");\n-          print_generic_expr (dump_file, object_size, dump_flags);\n-          fprintf (dump_file, \"\\n\");\n-        }\n-\n-      /* NB: the above condition doesn't require TREE_USED or\n-         TREE_ADDRESSABLE.  That's because this object may be a global\n-         only used from other compilation units.  XXX: Maybe static\n-         objects could require those attributes being set.  */\n+  if (! deferred_static_decls)\n+    VARRAY_TREE_INIT (deferred_static_decls, 10, \"deferred static list\");\n \n-      mudflap_register_call (obj, object_size, mf_varname_tree (obj));\n-    }\n-  else\n-    {\n-      size_t i;\n-\n-      if (! deferred_static_decls)\n-        VARRAY_TREE_INIT (deferred_static_decls, 10, \"deferred static list\");\n-\n-      /* Ugh, linear search... */\n-      for (i = 0; i < VARRAY_ACTIVE_SIZE (deferred_static_decls); i++)\n-        if (VARRAY_TREE (deferred_static_decls, i) == obj)\n-          {\n-            warning (\"mudflap cannot track unknown size extern %qs\",\n-                     IDENTIFIER_POINTER (DECL_NAME (obj)));\n-            return;\n-          }\n-\n-      VARRAY_PUSH_TREE (deferred_static_decls, obj);\n-    }\n+  VARRAY_PUSH_TREE (deferred_static_decls, obj);\n }\n \n+\n void\n mudflap_enqueue_constant (tree obj)\n {\n@@ -1237,15 +1215,6 @@ mudflap_enqueue_constant (tree obj)\n   else\n     object_size = size_in_bytes (TREE_TYPE (obj));\n \n-  if (dump_file)\n-    {\n-      fprintf (dump_file, \"enqueue_constant obj=`\");\n-      print_generic_expr (dump_file, obj, dump_flags);\n-      fprintf (dump_file, \"' size=\");\n-      print_generic_expr (dump_file, object_size, dump_flags);\n-      fprintf (dump_file, \"\\n\");\n-    }\n-\n   if (TREE_CODE (obj) == STRING_CST)\n     varname = mf_build_string (\"string literal\");\n   else\n@@ -1261,24 +1230,6 @@ mudflap_finish_file (void)\n {\n   tree ctor_statements = NULL_TREE;\n \n-  /* Try to give the deferred objects one final try.  */\n-  if (deferred_static_decls)\n-    {\n-      size_t i;\n-\n-      for (i = 0; i < VARRAY_ACTIVE_SIZE (deferred_static_decls); i++)\n-        {\n-          tree obj = VARRAY_TREE (deferred_static_decls, i);\n-\n-          /* Call enqueue_decl again on the same object it has previously\n-             put into the table.  (It won't modify the table this time, so\n-             infinite iteration is not a problem.)  */\n-          mudflap_enqueue_decl (obj);\n-        }\n-\n-      VARRAY_CLEAR (deferred_static_decls);\n-    }\n-\n   /* Insert a call to __mf_init.  */\n   {\n     tree call2_stmt = build_function_call_expr (mf_init_fndecl, NULL_TREE);\n@@ -1294,6 +1245,41 @@ mudflap_finish_file (void)\n       append_to_statement_list (call_stmt, &ctor_statements);\n     }\n \n+  /* Process all enqueued object decls.  */\n+  if (deferred_static_decls)\n+    {\n+      size_t i;\n+      for (i = 0; i < VARRAY_ACTIVE_SIZE (deferred_static_decls); i++)\n+        {\n+          tree obj = VARRAY_TREE (deferred_static_decls, i);\n+\n+          gcc_assert (DECL_P (obj));\n+\n+          if (mf_marked_p (obj))\n+            continue;\n+\n+          /* Omit registration for static unaddressed objects.  NB:\n+             Perform registration for non-static objects regardless of\n+             TREE_USED or TREE_ADDRESSABLE, because they may be used\n+             from other compilation units.  */\n+          if (TREE_STATIC (obj) && ! TREE_ADDRESSABLE (obj))\n+            continue;\n+\n+          if (! COMPLETE_TYPE_P (TREE_TYPE (obj)))\n+            {\n+              warning (\"mudflap cannot track unknown size extern %qs\",\n+                       IDENTIFIER_POINTER (DECL_NAME (obj)));\n+              continue;\n+            }\n+          \n+          mudflap_register_call (obj, \n+                                 size_in_bytes (TREE_TYPE (obj)),\n+                                 mf_varname_tree (obj));\n+        }\n+\n+      VARRAY_CLEAR (deferred_static_decls);\n+    }\n+\n   /* Append all the enqueued registration calls.  */\n   if (enqueued_call_stmt_chain)\n     {"}]}