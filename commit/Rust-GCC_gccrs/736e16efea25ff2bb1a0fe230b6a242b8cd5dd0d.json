{"sha": "736e16efea25ff2bb1a0fe230b6a242b8cd5dd0d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzM2ZTE2ZWZlYTI1ZmYyYmIxYTBmZTIzMGI2YTI0MmI4Y2Q1ZGQwZA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2018-05-24T13:07:00Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2018-05-24T13:07:00Z"}, "message": "[Ada] Minor clean-ups in gigi\n\n2018-05-24  Eric Botcazou  <ebotcazou@adacore.com>\n\ngcc/ada/\n\n\t* gcc-interface/trans.c (Handled_Sequence_Of_Statements_to_gnu):\n\tConstify and rename variables.  Fix formatting.\n\t(gnat_to_gnu) <N_Exception_Handler>: Minor tweak.\n\t<N_Raise_Statement>: Likewise.\n\nFrom-SVN: r260668", "tree": {"sha": "d8c0e03f3b0882d1b55ef7a0646dbc7eae41acb1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d8c0e03f3b0882d1b55ef7a0646dbc7eae41acb1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/736e16efea25ff2bb1a0fe230b6a242b8cd5dd0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/736e16efea25ff2bb1a0fe230b6a242b8cd5dd0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/736e16efea25ff2bb1a0fe230b6a242b8cd5dd0d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/736e16efea25ff2bb1a0fe230b6a242b8cd5dd0d/comments", "author": null, "committer": null, "parents": [{"sha": "01243764c0ea83d0086d7e49a8752a8f13bfd802", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01243764c0ea83d0086d7e49a8752a8f13bfd802", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01243764c0ea83d0086d7e49a8752a8f13bfd802"}], "stats": {"total": 57, "additions": 33, "deletions": 24}, "files": [{"sha": "0ea491e1ffcaebe49b679ececdaa961e559097b7", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/736e16efea25ff2bb1a0fe230b6a242b8cd5dd0d/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/736e16efea25ff2bb1a0fe230b6a242b8cd5dd0d/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=736e16efea25ff2bb1a0fe230b6a242b8cd5dd0d", "patch": "@@ -1,3 +1,10 @@\n+2018-05-24  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/trans.c (Handled_Sequence_Of_Statements_to_gnu):\n+\tConstify and rename variables.  Fix formatting.\n+\t(gnat_to_gnu) <N_Exception_Handler>: Minor tweak.\n+\t<N_Raise_Statement>: Likewise.\n+\n 2018-05-24  Javier Miranda  <miranda@adacore.com>\n \n \t* exp_ch8.adb (Build_Body_For_Renaming): Adding support to build the"}, {"sha": "f5304eb8a0f095c1fbe28d8bdbb80cc820f62a7f", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 26, "deletions": 24, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/736e16efea25ff2bb1a0fe230b6a242b8cd5dd0d/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/736e16efea25ff2bb1a0fe230b6a242b8cd5dd0d/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=736e16efea25ff2bb1a0fe230b6a242b8cd5dd0d", "patch": "@@ -4989,46 +4989,48 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n static tree\n Handled_Sequence_Of_Statements_to_gnu (Node_Id gnat_node)\n {\n-  tree gnu_jmpsave_decl = NULL_TREE;\n-  tree gnu_jmpbuf_decl = NULL_TREE;\n   /* If just annotating, ignore all EH and cleanups.  */\n-  bool gcc_eh = (!type_annotate_only\n-                 && Present (Exception_Handlers (gnat_node))\n-                 && Back_End_Exceptions ());\n-  bool fe_sjlj\n-    = (!type_annotate_only && Present (Exception_Handlers (gnat_node))\n+  const bool gcc_eh\n+    = (!type_annotate_only\n+       && Present (Exception_Handlers (gnat_node))\n+       && Back_End_Exceptions ());\n+  const bool fe_sjlj_eh\n+    = (!type_annotate_only\n+       && Present (Exception_Handlers (gnat_node))\n        && Exception_Mechanism == Front_End_SJLJ);\n-  bool at_end = !type_annotate_only && Present (At_End_Proc (gnat_node));\n-  bool binding_for_block = (at_end || gcc_eh || fe_sjlj);\n+  const bool at_end = !type_annotate_only && Present (At_End_Proc (gnat_node));\n+  const bool binding_for_block = (at_end || gcc_eh || fe_sjlj_eh);\n+  tree gnu_jmpsave_decl = NULL_TREE;\n+  tree gnu_jmpbuf_decl = NULL_TREE;\n   tree gnu_inner_block; /* The statement(s) for the block itself.  */\n   tree gnu_result;\n   tree gnu_expr;\n   Node_Id gnat_temp;\n \n   /* The GCC exception handling mechanism can handle both ZCX and SJLJ schemes\n-     and we have our own SJLJ mechanism.  To call the GCC mechanism, we call\n-     add_cleanup, and when we leave the binding, end_stmt_group will create\n-     the TRY_FINALLY_EXPR.\n+     and the front-end has its own SJLJ mechanism.  To call the GCC mechanism,\n+     we call add_cleanup, and when we leave the binding, end_stmt_group will\n+     create the TRY_FINALLY_EXPR construct.\n \n      ??? The region level calls down there have been specifically put in place\n      for a ZCX context and currently the order in which things are emitted\n-     (region/handlers) is different from the SJLJ case. Instead of putting\n+     (region/handlers) is different from the SJLJ case.  Instead of putting\n      other calls with different conditions at other places for the SJLJ case,\n      it seems cleaner to reorder things for the SJLJ case and generalize the\n      condition to make it not ZCX specific.\n \n      If there are any exceptions or cleanup processing involved, we need an\n-     outer statement group (for Fe_Sjlj) and binding level.  */\n+     outer statement group (for front-end SJLJ) and binding level.  */\n   if (binding_for_block)\n     {\n       start_stmt_group ();\n       gnat_pushlevel ();\n     }\n \n-  /* If using fe_sjlj, make the variables for the setjmp buffer and save\n+  /* If using fe_sjlj_eh, make the variables for the setjmp buffer and save\n      area for address of previous buffer.  Do this first since we need to have\n      the setjmp buf known for any decls in this block.  */\n-  if (fe_sjlj)\n+  if (fe_sjlj_eh)\n     {\n       gnu_jmpsave_decl\n \t= create_var_decl (get_identifier (\"JMPBUF_SAVE\"), NULL_TREE,\n@@ -5038,7 +5040,7 @@ Handled_Sequence_Of_Statements_to_gnu (Node_Id gnat_node)\n \t\t\t   NULL, gnat_node);\n \n       /* The __builtin_setjmp receivers will immediately reinstall it.  Now\n-\t because of the unstructured form of EH used by fe_sjlj, there\n+\t because of the unstructured form of EH used by fe_sjlj_eh, there\n \t might be forward edges going to __builtin_setjmp receivers on which\n \t it is uninitialized, although they will never be actually taken.  */\n       TREE_NO_WARNING (gnu_jmpsave_decl) = 1;\n@@ -5081,7 +5083,7 @@ Handled_Sequence_Of_Statements_to_gnu (Node_Id gnat_node)\n      If this is SJLJ, set our jmp_buf as the current buffer.  */\n   start_stmt_group ();\n \n-  if (fe_sjlj)\n+  if (fe_sjlj_eh)\n     {\n       gnu_expr = build_call_n_expr (set_jmpbuf_decl, 1,\n \t\t\t\t    build_unary_op (ADDR_EXPR, NULL_TREE,\n@@ -5100,11 +5102,12 @@ Handled_Sequence_Of_Statements_to_gnu (Node_Id gnat_node)\n \t\t    : First (Statements (gnat_node)));\n        Present (gnat_temp); gnat_temp = Next (gnat_temp))\n     add_stmt (gnat_to_gnu (gnat_temp));\n+\n   gnu_inner_block = end_stmt_group ();\n \n   /* Now generate code for the two exception models, if either is relevant for\n      this block.  */\n-  if (fe_sjlj)\n+  if (fe_sjlj_eh)\n     {\n       tree *gnu_else_ptr = 0;\n       tree gnu_handler;\n@@ -7472,18 +7475,17 @@ gnat_to_gnu (Node_Id gnat_node)\n       break;\n \n     case N_Exception_Handler:\n-      if (Exception_Mechanism == Front_End_SJLJ)\n-\tgnu_result = Exception_Handler_to_gnu_fe_sjlj (gnat_node);\n-      else if (Back_End_Exceptions ())\n+      if (Back_End_Exceptions ())\n \tgnu_result = Exception_Handler_to_gnu_gcc (gnat_node);\n+      else if (Exception_Mechanism == Front_End_SJLJ)\n+\tgnu_result = Exception_Handler_to_gnu_fe_sjlj (gnat_node);\n       else\n \tgcc_unreachable ();\n       break;\n \n     case N_Raise_Statement:\n       /* Only for reraise in back-end exceptions mode.  */\n-      gcc_assert (No (Name (gnat_node))\n-                  && Back_End_Exceptions ());\n+      gcc_assert (No (Name (gnat_node)) && Back_End_Exceptions ());\n \n       start_stmt_group ();\n       gnat_pushlevel ();"}]}