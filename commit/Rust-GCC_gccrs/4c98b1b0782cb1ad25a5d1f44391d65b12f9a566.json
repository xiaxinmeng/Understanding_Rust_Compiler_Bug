{"sha": "4c98b1b0782cb1ad25a5d1f44391d65b12f9a566", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGM5OGIxYjA3ODJjYjFhZDI1YTVkMWY0NDM5MWQ2NWIxMmY5YTU2Ng==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2003-01-24T19:58:21Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2003-01-24T19:58:21Z"}, "message": "defineclass.cc (handleMethodsEnd): Precompute code for static method.\n\n\t* defineclass.cc (handleMethodsEnd): Precompute code for static\n\tmethod.\n\t(handleCodeAttribute): Likewise.\n\t* resolve.cc (ncode): Use run_class for unsynchronized static\n\tmethods.\n\t* include/java-interp.h (class _Jv_InterpMethod): Declare\n\trun_class.\n\t* interpret.cc (run_synch_class): Initialize class.\n\t(run) [insn_invokestatic]: Don't initialize class.\n\t[insn_anewarray]: Likewise.\n\t[insn_multianewarray]: Likewise.\n\t(run_class): New function.\n\nFrom-SVN: r61727", "tree": {"sha": "f37c4a601e54ff85516e178f32e45db587bf62ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f37c4a601e54ff85516e178f32e45db587bf62ce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4c98b1b0782cb1ad25a5d1f44391d65b12f9a566", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c98b1b0782cb1ad25a5d1f44391d65b12f9a566", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c98b1b0782cb1ad25a5d1f44391d65b12f9a566", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c98b1b0782cb1ad25a5d1f44391d65b12f9a566/comments", "author": null, "committer": null, "parents": [{"sha": "d291503a6733535c462bf71c03347c2452a523ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d291503a6733535c462bf71c03347c2452a523ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d291503a6733535c462bf71c03347c2452a523ee"}], "stats": {"total": 94, "additions": 73, "deletions": 21}, "files": [{"sha": "1b9a81ce5e28586bd3a09aaf0e2d2e2bd30521c0", "filename": "libjava/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c98b1b0782cb1ad25a5d1f44391d65b12f9a566/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c98b1b0782cb1ad25a5d1f44391d65b12f9a566/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=4c98b1b0782cb1ad25a5d1f44391d65b12f9a566", "patch": "@@ -1,3 +1,18 @@\n+2003-01-24  Tom Tromey  <tromey@redhat.com>\n+\n+\t* defineclass.cc (handleMethodsEnd): Precompute code for static\n+\tmethod.\n+\t(handleCodeAttribute): Likewise.\n+\t* resolve.cc (ncode): Use run_class for unsynchronized static\n+\tmethods.\n+\t* include/java-interp.h (class _Jv_InterpMethod): Declare\n+\trun_class.\n+\t* interpret.cc (run_synch_class): Initialize class.\n+\t(run) [insn_invokestatic]: Don't initialize class.\n+\t[insn_anewarray]: Likewise.\n+\t[insn_multianewarray]: Likewise.\n+\t(run_class): New function.\n+\n 2003-01-24  Tom Tromey  <tromey@redhat.com>\n \n \t* java/lang/ClassLoader.java (findLoadedClass): Removed erroneous"}, {"sha": "001fa0131f025ac7879c7939d10c34cfeb29096b", "filename": "libjava/defineclass.cc", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c98b1b0782cb1ad25a5d1f44391d65b12f9a566/libjava%2Fdefineclass.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c98b1b0782cb1ad25a5d1f44391d65b12f9a566/libjava%2Fdefineclass.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fdefineclass.cc?ref=4c98b1b0782cb1ad25a5d1f44391d65b12f9a566", "patch": "@@ -1,6 +1,6 @@\n // defineclass.cc - defining a class from .class format.\n \n-/* Copyright (C) 1999, 2000, 2001, 2002  Free Software Foundation\n+/* Copyright (C) 1999, 2000, 2001, 2002, 2003  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -1267,6 +1267,15 @@ void _Jv_ClassReader::handleCodeAttribute\n \t  code_length);\n \n   def->interpreted_methods[method_index] = method;\n+\n+  if ((method->self->accflags & java::lang::reflect::Modifier::STATIC))\n+    {\n+      // Precompute the ncode field for a static method.  This lets us\n+      // call a static method of an interpreted class from precompiled\n+      // code without first resolving the class (that will happen\n+      // during class initialization instead).\n+      method->self->ncode = method->ncode ();\n+    }\n }\n \n void _Jv_ClassReader::handleExceptionTableEntry\n@@ -1302,6 +1311,16 @@ void _Jv_ClassReader::handleMethodsEnd ()\n \t      m->self = method;\n \t      m->function = NULL;\n \t      def->interpreted_methods[i] = m;\n+\n+\t      if ((method->accflags & Modifier::STATIC))\n+\t\t{\n+\t\t  // Precompute the ncode field for a static method.\n+\t\t  // This lets us call a static method of an\n+\t\t  // interpreted class from precompiled code without\n+\t\t  // first resolving the class (that will happen\n+\t\t  // during class initialization instead).\n+\t\t  method->ncode = m->ncode ();\n+\t\t}\n \t    }\n \t}\n       else if ((method->accflags & Modifier::ABSTRACT) != 0)"}, {"sha": "c801274f4cbf69fa053f33c257319199c5d0a478", "filename": "libjava/include/java-interp.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c98b1b0782cb1ad25a5d1f44391d65b12f9a566/libjava%2Finclude%2Fjava-interp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c98b1b0782cb1ad25a5d1f44391d65b12f9a566/libjava%2Finclude%2Fjava-interp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjava-interp.h?ref=4c98b1b0782cb1ad25a5d1f44391d65b12f9a566", "patch": "@@ -1,6 +1,6 @@\n // java-interp.h - Header file for the bytecode interpreter.  -*- c++ -*-\n \n-/* Copyright (C) 1999, 2000, 2001, 2002  Free Software Foundation\n+/* Copyright (C) 1999, 2000, 2001, 2002, 2003  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -132,6 +132,7 @@ class _Jv_InterpMethod : public _Jv_MethodBase\n \n   static void run_normal (ffi_cif*, void*, ffi_raw*, void*);\n   static void run_synch_object (ffi_cif*, void*, ffi_raw*, void*);\n+  static void run_class (ffi_cif*, void*, ffi_raw*, void*);\n   static void run_synch_class (ffi_cif*, void*, ffi_raw*, void*);\n \n   void run (void*, ffi_raw *);"}, {"sha": "43d627921fb808eb7a9c05e179b446a024bbd5ec", "filename": "libjava/interpret.cc", "status": "modified", "additions": 31, "deletions": 16, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c98b1b0782cb1ad25a5d1f44391d65b12f9a566/libjava%2Finterpret.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c98b1b0782cb1ad25a5d1f44391d65b12f9a566/libjava%2Finterpret.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finterpret.cc?ref=4c98b1b0782cb1ad25a5d1f44391d65b12f9a566", "patch": "@@ -1,6 +1,6 @@\n // interpret.cc - Code for the interpreter\n \n-/* Copyright (C) 1999, 2000, 2001, 2002 Free Software Foundation\n+/* Copyright (C) 1999, 2000, 2001, 2002, 2003 Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -240,19 +240,21 @@ static jint get4(unsigned char* loc) {\n     }\t\t\t\t\t\t\t\t\t      \\\n   while (0)\n \n-void _Jv_InterpMethod::run_normal (ffi_cif *,\n-\t\t\t\t   void* ret,\n-\t\t\t\t   ffi_raw * args,\n-\t\t\t\t   void* __this)\n+void\n+_Jv_InterpMethod::run_normal (ffi_cif *,\n+\t\t\t      void* ret,\n+\t\t\t      ffi_raw * args,\n+\t\t\t      void* __this)\n {\n   _Jv_InterpMethod *_this = (_Jv_InterpMethod *) __this;\n   _this->run (ret, args);\n }\n \n-void _Jv_InterpMethod::run_synch_object (ffi_cif *,\n-\t\t\t\t\t void* ret,\n-\t\t\t\t\t ffi_raw * args,\n-\t\t\t\t\t void* __this)\n+void\n+_Jv_InterpMethod::run_synch_object (ffi_cif *,\n+\t\t\t\t    void* ret,\n+\t\t\t\t    ffi_raw * args,\n+\t\t\t\t    void* __this)\n {\n   _Jv_InterpMethod *_this = (_Jv_InterpMethod *) __this;\n \n@@ -262,14 +264,27 @@ void _Jv_InterpMethod::run_synch_object (ffi_cif *,\n   _this->run (ret, args);\n }\n \n-void _Jv_InterpMethod::run_synch_class (ffi_cif *,\n-\t\t\t\t\tvoid* ret,\n-\t\t\t\t\tffi_raw * args,\n-\t\t\t\t\tvoid* __this)\n+void\n+_Jv_InterpMethod::run_class (ffi_cif *,\n+\t\t\t     void* ret,\n+\t\t\t     ffi_raw * args,\n+\t\t\t     void* __this)\n+{\n+  _Jv_InterpMethod *_this = (_Jv_InterpMethod *) __this;\n+  _Jv_InitClass (_this->defining_class);\n+  _this->run (ret, args);\n+}\n+\n+void\n+_Jv_InterpMethod::run_synch_class (ffi_cif *,\n+\t\t\t\t   void* ret,\n+\t\t\t\t   ffi_raw * args,\n+\t\t\t\t   void* __this)\n {\n   _Jv_InterpMethod *_this = (_Jv_InterpMethod *) __this;\n \n   jclass sync = _this->defining_class;\n+  _Jv_InitClass (sync);\n   JvSynchronize mutex (sync);\n \n   _this->run (ret, args);\n@@ -2833,7 +2848,6 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args)\n \n \tsp -= rmeth->stack_item_count;\n \n-\t_Jv_InitClass (rmeth->klass);\n \tfun = (void (*)()) rmeth->method->ncode;\n \n #ifdef DIRECT_THREADED\n@@ -2903,6 +2917,9 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args)\n       {\n \tint index = GET2U ();\n \tjclass klass = (_Jv_ResolvePoolEntry (defining_class, index)).clazz;\n+\t// We initialize here because otherwise `size_in_bytes' may\n+\t// not be set correctly, leading us to pass `0' as the size.\n+\t// FIXME: fix in the allocator?  There is a PR for this.\n \t_Jv_InitClass (klass);\n \tjobject res = _Jv_AllocObject (klass, klass->size_in_bytes);\n \tPUSHA (res);\n@@ -2938,7 +2955,6 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args)\n \tint index = GET2U ();\n \tjclass klass = (_Jv_ResolvePoolEntry (defining_class, index)).clazz;\n \tint size  = POPI();\n-\t_Jv_InitClass (klass);\n \tjobject result = _Jv_NewObjectArray (size, klass, 0);\n \tPUSHA (result);\n \n@@ -3072,7 +3088,6 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args)\n \n \tjclass type    \n \t  = (_Jv_ResolvePoolEntry (defining_class, kind_index)).clazz;\n-\t_Jv_InitClass (type);\n \tjint *sizes    = (jint*) __builtin_alloca (sizeof (jint)*dim);\n \n \tfor (int i = dim - 1; i >= 0; i--)"}, {"sha": "e69341e385f1ad663716ef5768606779d8539a6a", "filename": "libjava/resolve.cc", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c98b1b0782cb1ad25a5d1f44391d65b12f9a566/libjava%2Fresolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c98b1b0782cb1ad25a5d1f44391d65b12f9a566/libjava%2Fresolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fresolve.cc?ref=4c98b1b0782cb1ad25a5d1f44391d65b12f9a566", "patch": "@@ -1,6 +1,6 @@\n // resolve.cc - Code for linking and resolving classes and pool entries.\n \n-/* Copyright (C) 1999, 2000, 2001 , 2002 Free Software Foundation\n+/* Copyright (C) 1999, 2000, 2001, 2002, 2003 Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -947,7 +947,10 @@ _Jv_InterpMethod::ncode ()\n     }\n   else\n     {\n-      fun = (ffi_closure_fun)&_Jv_InterpMethod::run_normal;\n+      if (staticp)\n+\tfun = (ffi_closure_fun)&_Jv_InterpMethod::run_class;\n+      else\n+\tfun = (ffi_closure_fun)&_Jv_InterpMethod::run_normal;\n     }\n \n   FFI_PREP_RAW_CLOSURE (&closure->closure,\n@@ -959,7 +962,6 @@ _Jv_InterpMethod::ncode ()\n   return self->ncode;\n }\n \n-\n void *\n _Jv_JNIMethod::ncode ()\n {"}]}