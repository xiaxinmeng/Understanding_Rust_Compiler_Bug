{"sha": "6239dd05127f1dc05f13f504805d36e8ebe1c2c5", "node_id": "C_kwDOANBUbNoAKDYyMzlkZDA1MTI3ZjFkYzA1ZjEzZjUwNDgwNWQzNmU4ZWJlMWMyYzU", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-11-04T12:31:17Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-11-04T12:31:17Z"}, "message": "vect: Convert cost hooks to classes\n\nThe current vector cost interface has a quite a bit of redundancy\nbuilt in.  Each target that defines its own hooks has to replicate\nthe basic unsigned[3] management.  Currently each target also\nduplicates the cost adjustment for inner loops.\n\nThis patch instead defines a vector_costs class for holding\nthe scalar or vector cost and allows targets to subclass it.\nThere is then only one costing hook: to create a new costs\nstructure of the appropriate type.  Everything else can be\nvirtual functions, with common concepts implemented in the\nbase class rather than in each target's derivation.\n\nThis might seem like excess C++-ification, but it shaves\n~100 LOC.  I've also got some follow-on changes that become\nsignificantly easier with this patch.  Maybe it could help\nwith things like weighting blocks based on frequency too.\n\nThis will clash with Andre's unrolling patches.  His patches\nhave priority so this patch should queue behind them.\n\nThe x86 and rs6000 parts fully convert to a self-contained class.\nThe equivalent aarch64 changes are more complex, so this patch\njust does the bare minimum.  A later patch will rework the\naarch64 bits.\n\ngcc/\n\t* target.def (targetm.vectorize.init_cost): Replace with...\n\t(targetm.vectorize.create_costs): ...this.\n\t(targetm.vectorize.add_stmt_cost): Delete.\n\t(targetm.vectorize.finish_cost): Likewise.\n\t(targetm.vectorize.destroy_cost_data): Likewise.\n\t* doc/tm.texi.in (TARGET_VECTORIZE_INIT_COST): Replace with...\n\t(TARGET_VECTORIZE_CREATE_COSTS): ...this.\n\t(TARGET_VECTORIZE_ADD_STMT_COST): Delete.\n\t(TARGET_VECTORIZE_FINISH_COST): Likewise.\n\t(TARGET_VECTORIZE_DESTROY_COST_DATA): Likewise.\n\t* doc/tm.texi: Regenerate.\n\t* tree-vectorizer.h (vec_info::vec_info): Remove target_cost_data\n\tparameter.\n\t(vec_info::target_cost_data): Change from a void * to a vector_costs *.\n\t(vector_costs): New class.\n\t(init_cost): Take a vec_info and return a vector_costs.\n\t(dump_stmt_cost): Remove data parameter.\n\t(add_stmt_cost): Replace vinfo and data parameters with a vector_costs.\n\t(add_stmt_costs): Likewise.\n\t(finish_cost): Replace data parameter with a vector_costs.\n\t(destroy_cost_data): Delete.\n\t* tree-vectorizer.c (dump_stmt_cost): Remove data argument and\n\tdon't print it.\n\t(vec_info::vec_info): Remove the target_cost_data parameter and\n\tinitialize the member variable to null instead.\n\t(vec_info::~vec_info): Delete target_cost_data instead of calling\n\tdestroy_cost_data.\n\t(vector_costs::add_stmt_cost): New function.\n\t(vector_costs::finish_cost): Likewise.\n\t(vector_costs::record_stmt_cost): Likewise.\n\t(vector_costs::adjust_cost_for_freq): Likewise.\n\t* tree-vect-loop.c (_loop_vec_info::_loop_vec_info): Update\n\tcall to vec_info::vec_info.\n\t(vect_compute_single_scalar_iteration_cost): Update after above\n\tchanges to costing interface.\n\t(vect_analyze_loop_operations): Likewise.\n\t(vect_estimate_min_profitable_iters): Likewise.\n\t(vect_analyze_loop_2): Initialize LOOP_VINFO_TARGET_COST_DATA\n\tat the start_over point, where it needs to be recreated after\n\ttrying without slp.  Update retry code accordingly.\n\t* tree-vect-slp.c (_bb_vec_info::_bb_vec_info): Update call\n\tto vec_info::vec_info.\n\t(vect_slp_analyze_operation): Update after above changes to costing\n\tinterface.\n\t(vect_bb_vectorization_profitable_p): Likewise.\n\t* targhooks.h (default_init_cost): Replace with...\n\t(default_vectorize_create_costs): ...this.\n\t(default_add_stmt_cost): Delete.\n\t(default_finish_cost, default_destroy_cost_data): Likewise.\n\t* targhooks.c (default_init_cost): Replace with...\n\t(default_vectorize_create_costs): ...this.\n\t(default_add_stmt_cost): Delete, moving logic to vector_costs instead.\n\t(default_finish_cost, default_destroy_cost_data): Delete.\n\t* config/aarch64/aarch64.c (aarch64_vector_costs): Inherit from\n\tvector_costs.  Add a constructor.\n\t(aarch64_init_cost): Replace with...\n\t(aarch64_vectorize_create_costs): ...this.\n\t(aarch64_add_stmt_cost): Replace with...\n\t(aarch64_vector_costs::add_stmt_cost): ...this.  Use record_stmt_cost\n\tto adjust the cost for inner loops.\n\t(aarch64_finish_cost): Replace with...\n\t(aarch64_vector_costs::finish_cost): ...this.\n\t(aarch64_destroy_cost_data): Delete.\n\t(TARGET_VECTORIZE_INIT_COST): Replace with...\n\t(TARGET_VECTORIZE_CREATE_COSTS): ...this.\n\t(TARGET_VECTORIZE_ADD_STMT_COST): Delete.\n\t(TARGET_VECTORIZE_FINISH_COST): Likewise.\n\t(TARGET_VECTORIZE_DESTROY_COST_DATA): Likewise.\n\t* config/i386/i386.c (ix86_vector_costs): New structure.\n\t(ix86_init_cost): Replace with...\n\t(ix86_vectorize_create_costs): ...this.\n\t(ix86_add_stmt_cost): Replace with...\n\t(ix86_vector_costs::add_stmt_cost): ...this.  Use adjust_cost_for_freq\n\tto adjust the cost for inner loops.\n\t(ix86_finish_cost, ix86_destroy_cost_data): Delete.\n\t(TARGET_VECTORIZE_INIT_COST): Replace with...\n\t(TARGET_VECTORIZE_CREATE_COSTS): ...this.\n\t(TARGET_VECTORIZE_ADD_STMT_COST): Delete.\n\t(TARGET_VECTORIZE_FINISH_COST): Likewise.\n\t(TARGET_VECTORIZE_DESTROY_COST_DATA): Likewise.\n\t* config/rs6000/rs6000.c (TARGET_VECTORIZE_INIT_COST): Replace with...\n\t(TARGET_VECTORIZE_CREATE_COSTS): ...this.\n\t(TARGET_VECTORIZE_ADD_STMT_COST): Delete.\n\t(TARGET_VECTORIZE_FINISH_COST): Likewise.\n\t(TARGET_VECTORIZE_DESTROY_COST_DATA): Likewise.\n\t(rs6000_cost_data): Inherit from vector_costs.\n\tAdd a constructor.  Drop loop_info, cost and costing_for_scalar\n\tin favor of the corresponding vector_costs member variables.\n\tAdd \"m_\" to the names of the remaining member variables and\n\tinitialize them.\n\t(rs6000_density_test): Replace with...\n\t(rs6000_cost_data::density_test): ...this.\n\t(rs6000_init_cost): Replace with...\n\t(rs6000_vectorize_create_costs): ...this.\n\t(rs6000_update_target_cost_per_stmt): Replace with...\n\t(rs6000_cost_data::update_target_cost_per_stmt): ...this.\n\t(rs6000_add_stmt_cost): Replace with...\n\t(rs6000_cost_data::add_stmt_cost): ...this.  Use adjust_cost_for_freq\n\tto adjust the cost for inner loops.\n\t(rs6000_adjust_vect_cost_per_loop): Replace with...\n\t(rs6000_cost_data::adjust_vect_cost_per_loop): ...this.\n\t(rs6000_finish_cost): Replace with...\n\t(rs6000_cost_data::finish_cost): ...this.  Group loop code\n\tinto a single if statement and pass the loop_vinfo down to\n\tsubroutines.\n\t(rs6000_destroy_cost_data): Delete.", "tree": {"sha": "27c1a57b8c23d47801a5c3d62e95e17c15ddbfa4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/27c1a57b8c23d47801a5c3d62e95e17c15ddbfa4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6239dd05127f1dc05f13f504805d36e8ebe1c2c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6239dd05127f1dc05f13f504805d36e8ebe1c2c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6239dd05127f1dc05f13f504805d36e8ebe1c2c5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6239dd05127f1dc05f13f504805d36e8ebe1c2c5/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "af976d90fa15b379b766647fea34e6b2c37d5c16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af976d90fa15b379b766647fea34e6b2c37d5c16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af976d90fa15b379b766647fea34e6b2c37d5c16"}], "stats": {"total": 837, "additions": 374, "deletions": 463}, "files": [{"sha": "771517dd4c4896b725992cd19f88dda463ec2b7f", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 52, "deletions": 85, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6239dd05127f1dc05f13f504805d36e8ebe1c2c5/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6239dd05127f1dc05f13f504805d36e8ebe1c2c5/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=6239dd05127f1dc05f13f504805d36e8ebe1c2c5", "patch": "@@ -14589,11 +14589,15 @@ struct aarch64_sve_op_count : aarch64_vec_op_count\n };\n \n /* Information about vector code that we're in the process of costing.  */\n-struct aarch64_vector_costs\n+struct aarch64_vector_costs : public vector_costs\n {\n-  /* The normal latency-based costs for each region (prologue, body and\n-     epilogue), indexed by vect_cost_model_location.  */\n-  unsigned int region[3] = {};\n+  using vector_costs::vector_costs;\n+\n+  unsigned int add_stmt_cost (int count, vect_cost_for_stmt kind,\n+\t\t\t      stmt_vec_info stmt_info, tree vectype,\n+\t\t\t      int misalign,\n+\t\t\t      vect_cost_model_location where) override;\n+  void finish_cost () override;\n \n   /* True if we have performed one-time initialization based on the vec_info.\n \n@@ -14659,11 +14663,11 @@ struct aarch64_vector_costs\n   hash_map<nofree_ptr_hash<_stmt_vec_info>, unsigned int> seen_loads;\n };\n \n-/* Implement TARGET_VECTORIZE_INIT_COST.  */\n-void *\n-aarch64_init_cost (class loop *, bool)\n+/* Implement TARGET_VECTORIZE_CREATE_COSTS.  */\n+vector_costs *\n+aarch64_vectorize_create_costs (vec_info *vinfo, bool costing_for_scalar)\n {\n-  return new aarch64_vector_costs;\n+  return new aarch64_vector_costs (vinfo, costing_for_scalar);\n }\n \n /* Return true if the current CPU should use the new costs defined\n@@ -15349,7 +15353,7 @@ aarch64_adjust_stmt_cost (vect_cost_for_stmt kind, stmt_vec_info stmt_info,\n }\n \n /* VINFO, COSTS, COUNT, KIND, STMT_INFO and VECTYPE are the same as for\n-   TARGET_VECTORIZE_ADD_STMT_COST and they describe an operation in the\n+   vector_costs::add_stmt_cost and they describe an operation in the\n    body of a vector loop.  Record issue information relating to the vector\n    operation in OPS, where OPS is one of COSTS->scalar_ops, COSTS->advsimd_ops\n    or COSTS->sve_ops; see the comments above those variables for details.\n@@ -15545,40 +15549,37 @@ aarch64_count_ops (class vec_info *vinfo, aarch64_vector_costs *costs,\n     }\n }\n \n-/* Implement targetm.vectorize.add_stmt_cost.  */\n-static unsigned\n-aarch64_add_stmt_cost (class vec_info *vinfo, void *data, int count,\n-\t\t       enum vect_cost_for_stmt kind,\n-\t\t       struct _stmt_vec_info *stmt_info, tree vectype,\n-\t\t       int misalign, enum vect_cost_model_location where)\n+unsigned\n+aarch64_vector_costs::add_stmt_cost (int count, vect_cost_for_stmt kind,\n+\t\t\t\t     stmt_vec_info stmt_info, tree vectype,\n+\t\t\t\t     int misalign,\n+\t\t\t\t     vect_cost_model_location where)\n {\n-  auto *costs = static_cast<aarch64_vector_costs *> (data);\n-\n   fractional_cost stmt_cost\n     = aarch64_builtin_vectorization_cost (kind, vectype, misalign);\n \n   bool in_inner_loop_p = (where == vect_body\n \t\t\t  && stmt_info\n-\t\t\t  && stmt_in_inner_loop_p (vinfo, stmt_info));\n+\t\t\t  && stmt_in_inner_loop_p (m_vinfo, stmt_info));\n \n   /* Do one-time initialization based on the vinfo.  */\n-  loop_vec_info loop_vinfo = dyn_cast<loop_vec_info> (vinfo);\n-  bb_vec_info bb_vinfo = dyn_cast<bb_vec_info> (vinfo);\n-  if (!costs->analyzed_vinfo && aarch64_use_new_vector_costs_p ())\n+  loop_vec_info loop_vinfo = dyn_cast<loop_vec_info> (m_vinfo);\n+  bb_vec_info bb_vinfo = dyn_cast<bb_vec_info> (m_vinfo);\n+  if (!analyzed_vinfo && aarch64_use_new_vector_costs_p ())\n     {\n       if (loop_vinfo)\n-\taarch64_analyze_loop_vinfo (loop_vinfo, costs);\n+\taarch64_analyze_loop_vinfo (loop_vinfo, this);\n       else\n-\taarch64_analyze_bb_vinfo (bb_vinfo, costs);\n-      costs->analyzed_vinfo = true;\n+\taarch64_analyze_bb_vinfo (bb_vinfo, this);\n+      this->analyzed_vinfo = true;\n     }\n \n   /* Try to get a more accurate cost by looking at STMT_INFO instead\n      of just looking at KIND.  */\n   if (stmt_info && aarch64_use_new_vector_costs_p ())\n     {\n       if (vectype && aarch64_sve_only_stmt_p (stmt_info, vectype))\n-\tcosts->saw_sve_only_op = true;\n+\tthis->saw_sve_only_op = true;\n \n       /* If we scalarize a strided store, the vectorizer costs one\n \t vec_to_scalar for each element.  However, we can store the first\n@@ -15587,17 +15588,17 @@ aarch64_add_stmt_cost (class vec_info *vinfo, void *data, int count,\n \tcount -= 1;\n \n       stmt_cost = aarch64_detect_scalar_stmt_subtype\n-\t(vinfo, kind, stmt_info, stmt_cost);\n+\t(m_vinfo, kind, stmt_info, stmt_cost);\n \n-      if (vectype && costs->vec_flags)\n-\tstmt_cost = aarch64_detect_vector_stmt_subtype (vinfo, kind,\n+      if (vectype && this->vec_flags)\n+\tstmt_cost = aarch64_detect_vector_stmt_subtype (m_vinfo, kind,\n \t\t\t\t\t\t\tstmt_info, vectype,\n \t\t\t\t\t\t\twhere, stmt_cost);\n     }\n \n   /* Do any SVE-specific adjustments to the cost.  */\n   if (stmt_info && vectype && aarch64_sve_mode_p (TYPE_MODE (vectype)))\n-    stmt_cost = aarch64_sve_adjust_stmt_cost (vinfo, kind, stmt_info,\n+    stmt_cost = aarch64_sve_adjust_stmt_cost (m_vinfo, kind, stmt_info,\n \t\t\t\t\t      vectype, stmt_cost);\n \n   if (stmt_info && aarch64_use_new_vector_costs_p ())\n@@ -15613,36 +15614,36 @@ aarch64_add_stmt_cost (class vec_info *vinfo, void *data, int count,\n       auto *issue_info = aarch64_tune_params.vec_costs->issue_info;\n       if (loop_vinfo\n \t  && issue_info\n-\t  && costs->vec_flags\n+\t  && this->vec_flags\n \t  && where == vect_body\n \t  && (!LOOP_VINFO_LOOP (loop_vinfo)->inner || in_inner_loop_p)\n \t  && vectype\n \t  && stmt_cost != 0)\n \t{\n \t  /* Record estimates for the scalar code.  */\n-\t  aarch64_count_ops (vinfo, costs, count, kind, stmt_info, vectype,\n-\t\t\t     0, &costs->scalar_ops, issue_info->scalar,\n+\t  aarch64_count_ops (m_vinfo, this, count, kind, stmt_info, vectype,\n+\t\t\t     0, &this->scalar_ops, issue_info->scalar,\n \t\t\t     vect_nunits_for_cost (vectype));\n \n-\t  if (aarch64_sve_mode_p (vinfo->vector_mode) && issue_info->sve)\n+\t  if (aarch64_sve_mode_p (m_vinfo->vector_mode) && issue_info->sve)\n \t    {\n \t      /* Record estimates for a possible Advanced SIMD version\n \t\t of the SVE code.  */\n-\t      aarch64_count_ops (vinfo, costs, count, kind, stmt_info,\n-\t\t\t\t vectype, VEC_ADVSIMD, &costs->advsimd_ops,\n+\t      aarch64_count_ops (m_vinfo, this, count, kind, stmt_info,\n+\t\t\t\t vectype, VEC_ADVSIMD, &this->advsimd_ops,\n \t\t\t\t issue_info->advsimd,\n \t\t\t\t aarch64_estimated_sve_vq ());\n \n \t      /* Record estimates for the SVE code itself.  */\n-\t      aarch64_count_ops (vinfo, costs, count, kind, stmt_info,\n-\t\t\t\t vectype, VEC_ANY_SVE, &costs->sve_ops,\n+\t      aarch64_count_ops (m_vinfo, this, count, kind, stmt_info,\n+\t\t\t\t vectype, VEC_ANY_SVE, &this->sve_ops,\n \t\t\t\t issue_info->sve, 1);\n \t    }\n \t  else\n \t    /* Record estimates for the Advanced SIMD code.  Treat SVE like\n \t       Advanced SIMD if the CPU has no specific SVE costs.  */\n-\t    aarch64_count_ops (vinfo, costs, count, kind, stmt_info,\n-\t\t\t       vectype, VEC_ADVSIMD, &costs->advsimd_ops,\n+\t    aarch64_count_ops (m_vinfo, this, count, kind, stmt_info,\n+\t\t\t       vectype, VEC_ADVSIMD, &this->advsimd_ops,\n \t\t\t       issue_info->advsimd, 1);\n \t}\n \n@@ -15651,24 +15652,11 @@ aarch64_add_stmt_cost (class vec_info *vinfo, void *data, int count,\n \t loop.  For simplicitly, we assume that one iteration of the\n \t Advanced SIMD loop would need the same number of statements\n \t as one iteration of the SVE loop.  */\n-      if (where == vect_body && costs->unrolled_advsimd_niters)\n-\tcosts->unrolled_advsimd_stmts\n-\t  += count * costs->unrolled_advsimd_niters;\n+      if (where == vect_body && this->unrolled_advsimd_niters)\n+\tthis->unrolled_advsimd_stmts\n+\t  += count * this->unrolled_advsimd_niters;\n     }\n-\n-  /* Statements in an inner loop relative to the loop being\n-     vectorized are weighted more heavily.  The value here is\n-     arbitrary and could potentially be improved with analysis.  */\n-  if (in_inner_loop_p)\n-    {\n-      gcc_assert (loop_vinfo);\n-      count *= LOOP_VINFO_INNER_LOOP_COST_FACTOR (loop_vinfo); /*  FIXME  */\n-    }\n-\n-  unsigned retval = (count * stmt_cost).ceil ();\n-  costs->region[where] += retval;\n-\n-  return retval;\n+  return record_stmt_cost (stmt_info, where, (count * stmt_cost).ceil ());\n }\n \n /* Dump information about the structure.  */\n@@ -16032,27 +16020,15 @@ aarch64_adjust_body_cost (aarch64_vector_costs *costs, unsigned int body_cost)\n   return body_cost;\n }\n \n-/* Implement TARGET_VECTORIZE_FINISH_COST.  */\n-static void\n-aarch64_finish_cost (void *data, unsigned *prologue_cost,\n-\t\t     unsigned *body_cost, unsigned *epilogue_cost)\n+void\n+aarch64_vector_costs::finish_cost ()\n {\n-  auto *costs = static_cast<aarch64_vector_costs *> (data);\n-  *prologue_cost = costs->region[vect_prologue];\n-  *body_cost     = costs->region[vect_body];\n-  *epilogue_cost = costs->region[vect_epilogue];\n-\n-  if (costs->is_loop\n-      && costs->vec_flags\n+  if (this->is_loop\n+      && this->vec_flags\n       && aarch64_use_new_vector_costs_p ())\n-    *body_cost = aarch64_adjust_body_cost (costs, *body_cost);\n-}\n+    m_costs[vect_body] = aarch64_adjust_body_cost (this, m_costs[vect_body]);\n \n-/* Implement TARGET_VECTORIZE_DESTROY_COST_DATA.  */\n-static void\n-aarch64_destroy_cost_data (void *data)\n-{\n-  delete static_cast<aarch64_vector_costs *> (data);\n+  vector_costs::finish_cost ();\n }\n \n static void initialize_aarch64_code_model (struct gcc_options *);\n@@ -26356,17 +26332,8 @@ aarch64_libgcc_floating_mode_supported_p\n #undef TARGET_ARRAY_MODE_SUPPORTED_P\n #define TARGET_ARRAY_MODE_SUPPORTED_P aarch64_array_mode_supported_p\n \n-#undef TARGET_VECTORIZE_INIT_COST\n-#define TARGET_VECTORIZE_INIT_COST aarch64_init_cost\n-\n-#undef TARGET_VECTORIZE_ADD_STMT_COST\n-#define TARGET_VECTORIZE_ADD_STMT_COST aarch64_add_stmt_cost\n-\n-#undef TARGET_VECTORIZE_FINISH_COST\n-#define TARGET_VECTORIZE_FINISH_COST aarch64_finish_cost\n-\n-#undef TARGET_VECTORIZE_DESTROY_COST_DATA\n-#define TARGET_VECTORIZE_DESTROY_COST_DATA aarch64_destroy_cost_data\n+#undef TARGET_VECTORIZE_CREATE_COSTS\n+#define TARGET_VECTORIZE_CREATE_COSTS aarch64_vectorize_create_costs\n \n #undef TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST\n #define TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST \\"}, {"sha": "96635d6858fa9213987c49d35c3132c524ff0e3f", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 23, "deletions": 53, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6239dd05127f1dc05f13f504805d36e8ebe1c2c5/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6239dd05127f1dc05f13f504805d36e8ebe1c2c5/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=6239dd05127f1dc05f13f504805d36e8ebe1c2c5", "patch": "@@ -22868,26 +22868,30 @@ ix86_noce_conversion_profitable_p (rtx_insn *seq, struct noce_if_info *if_info)\n   return default_noce_conversion_profitable_p (seq, if_info);\n }\n \n-/* Implement targetm.vectorize.init_cost.  */\n+/* x86-specific vector costs.  */\n+class ix86_vector_costs : public vector_costs\n+{\n+  using vector_costs::vector_costs;\n+\n+  unsigned int add_stmt_cost (int count, vect_cost_for_stmt kind,\n+\t\t\t      stmt_vec_info stmt_info, tree vectype,\n+\t\t\t      int misalign,\n+\t\t\t      vect_cost_model_location where) override;\n+};\n \n-static void *\n-ix86_init_cost (class loop *, bool)\n+/* Implement targetm.vectorize.create_costs.  */\n+\n+static vector_costs *\n+ix86_vectorize_create_costs (vec_info *vinfo, bool costing_for_scalar)\n {\n-  unsigned *cost = XNEWVEC (unsigned, 3);\n-  cost[vect_prologue] = cost[vect_body] = cost[vect_epilogue] = 0;\n-  return cost;\n+  return new ix86_vector_costs (vinfo, costing_for_scalar);\n }\n \n-/* Implement targetm.vectorize.add_stmt_cost.  */\n-\n-static unsigned\n-ix86_add_stmt_cost (class vec_info *vinfo, void *data, int count,\n-\t\t    enum vect_cost_for_stmt kind,\n-\t\t    class _stmt_vec_info *stmt_info, tree vectype,\n-\t\t    int misalign,\n-\t\t    enum vect_cost_model_location where)\n+unsigned\n+ix86_vector_costs::add_stmt_cost (int count, vect_cost_for_stmt kind,\n+\t\t\t\t  stmt_vec_info stmt_info, tree vectype,\n+\t\t\t\t  int misalign, vect_cost_model_location where)\n {\n-  unsigned *cost = (unsigned *) data;\n   unsigned retval = 0;\n   bool scalar_p\n     = (kind == scalar_stmt || kind == scalar_load || kind == scalar_store);\n@@ -23058,15 +23062,7 @@ ix86_add_stmt_cost (class vec_info *vinfo, void *data, int count,\n   /* Statements in an inner loop relative to the loop being\n      vectorized are weighted more heavily.  The value here is\n      arbitrary and could potentially be improved with analysis.  */\n-  if (where == vect_body && stmt_info\n-      && stmt_in_inner_loop_p (vinfo, stmt_info))\n-    {\n-      loop_vec_info loop_vinfo = dyn_cast<loop_vec_info> (vinfo);\n-      gcc_assert (loop_vinfo);\n-      count *= LOOP_VINFO_INNER_LOOP_COST_FACTOR (loop_vinfo); /* FIXME.  */\n-    }\n-\n-  retval = (unsigned) (count * stmt_cost);\n+  retval = adjust_cost_for_freq (stmt_info, where, count * stmt_cost);\n \n   /* We need to multiply all vector stmt cost by 1.7 (estimated cost)\n      for Silvermont as it has out of order integer pipeline and can execute\n@@ -23081,31 +23077,11 @@ ix86_add_stmt_cost (class vec_info *vinfo, void *data, int count,\n \tretval = (retval * 17) / 10;\n     }\n \n-  cost[where] += retval;\n+  m_costs[where] += retval;\n \n   return retval;\n }\n \n-/* Implement targetm.vectorize.finish_cost.  */\n-\n-static void\n-ix86_finish_cost (void *data, unsigned *prologue_cost,\n-\t\t  unsigned *body_cost, unsigned *epilogue_cost)\n-{\n-  unsigned *cost = (unsigned *) data;\n-  *prologue_cost = cost[vect_prologue];\n-  *body_cost     = cost[vect_body];\n-  *epilogue_cost = cost[vect_epilogue];\n-}\n-\n-/* Implement targetm.vectorize.destroy_cost_data.  */\n-\n-static void\n-ix86_destroy_cost_data (void *data)\n-{\n-  free (data);\n-}\n-\n /* Validate target specific memory model bits in VAL. */\n \n static unsigned HOST_WIDE_INT\n@@ -24387,14 +24363,8 @@ ix86_libgcc_floating_mode_supported_p\n   ix86_autovectorize_vector_modes\n #undef TARGET_VECTORIZE_GET_MASK_MODE\n #define TARGET_VECTORIZE_GET_MASK_MODE ix86_get_mask_mode\n-#undef TARGET_VECTORIZE_INIT_COST\n-#define TARGET_VECTORIZE_INIT_COST ix86_init_cost\n-#undef TARGET_VECTORIZE_ADD_STMT_COST\n-#define TARGET_VECTORIZE_ADD_STMT_COST ix86_add_stmt_cost\n-#undef TARGET_VECTORIZE_FINISH_COST\n-#define TARGET_VECTORIZE_FINISH_COST ix86_finish_cost\n-#undef TARGET_VECTORIZE_DESTROY_COST_DATA\n-#define TARGET_VECTORIZE_DESTROY_COST_DATA ix86_destroy_cost_data\n+#undef TARGET_VECTORIZE_CREATE_COSTS\n+#define TARGET_VECTORIZE_CREATE_COSTS ix86_vectorize_create_costs\n \n #undef TARGET_SET_CURRENT_FUNCTION\n #define TARGET_SET_CURRENT_FUNCTION ix86_set_current_function"}, {"sha": "ec0548004915151d110d691142f3a09fa0b410df", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 78, "deletions": 118, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6239dd05127f1dc05f13f504805d36e8ebe1c2c5/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6239dd05127f1dc05f13f504805d36e8ebe1c2c5/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=6239dd05127f1dc05f13f504805d36e8ebe1c2c5", "patch": "@@ -1452,14 +1452,8 @@ static const struct attribute_spec rs6000_attribute_table[] =\n #undef TARGET_VECTORIZE_PREFERRED_SIMD_MODE\n #define TARGET_VECTORIZE_PREFERRED_SIMD_MODE \\\n   rs6000_preferred_simd_mode\n-#undef TARGET_VECTORIZE_INIT_COST\n-#define TARGET_VECTORIZE_INIT_COST rs6000_init_cost\n-#undef TARGET_VECTORIZE_ADD_STMT_COST\n-#define TARGET_VECTORIZE_ADD_STMT_COST rs6000_add_stmt_cost\n-#undef TARGET_VECTORIZE_FINISH_COST\n-#define TARGET_VECTORIZE_FINISH_COST rs6000_finish_cost\n-#undef TARGET_VECTORIZE_DESTROY_COST_DATA\n-#define TARGET_VECTORIZE_DESTROY_COST_DATA rs6000_destroy_cost_data\n+#undef TARGET_VECTORIZE_CREATE_COSTS\n+#define TARGET_VECTORIZE_CREATE_COSTS rs6000_vectorize_create_costs\n \n #undef TARGET_LOOP_UNROLL_ADJUST\n #define TARGET_LOOP_UNROLL_ADJUST rs6000_loop_unroll_adjust\n@@ -5265,21 +5259,33 @@ rs6000_preferred_simd_mode (scalar_mode mode)\n   return word_mode;\n }\n \n-struct rs6000_cost_data\n+class rs6000_cost_data : public vector_costs\n {\n-  struct loop *loop_info;\n-  unsigned cost[3];\n+public:\n+  using vector_costs::vector_costs;\n+\n+  unsigned int add_stmt_cost (int count, vect_cost_for_stmt kind,\n+\t\t\t      stmt_vec_info stmt_info, tree vectype,\n+\t\t\t      int misalign,\n+\t\t\t      vect_cost_model_location where) override;\n+  void finish_cost () override;\n+\n+protected:\n+  void update_target_cost_per_stmt (vect_cost_for_stmt, stmt_vec_info,\n+\t\t\t\t    vect_cost_model_location, int,\n+\t\t\t\t    unsigned int);\n+  void density_test (loop_vec_info);\n+  void adjust_vect_cost_per_loop (loop_vec_info);\n+\n   /* Total number of vectorized stmts (loop only).  */\n-  unsigned nstmts;\n+  unsigned m_nstmts = 0;\n   /* Total number of loads (loop only).  */\n-  unsigned nloads;\n+  unsigned m_nloads = 0;\n   /* Possible extra penalized cost on vector construction (loop only).  */\n-  unsigned extra_ctor_cost;\n+  unsigned m_extra_ctor_cost = 0;\n   /* For each vectorized loop, this var holds TRUE iff a non-memory vector\n      instruction is needed by the vectorization.  */\n-  bool vect_nonmem;\n-  /* Indicates this is costing for the scalar version of a loop or block.  */\n-  bool costing_for_scalar;\n+  bool m_vect_nonmem = false;\n };\n \n /* Test for likely overcommitment of vector hardware resources.  If a\n@@ -5288,20 +5294,19 @@ struct rs6000_cost_data\n    adequately reflect delays from unavailable vector resources.\n    Penalize the loop body cost for this case.  */\n \n-static void\n-rs6000_density_test (rs6000_cost_data *data)\n+void\n+rs6000_cost_data::density_test (loop_vec_info loop_vinfo)\n {\n   /* This density test only cares about the cost of vector version of the\n      loop, so immediately return if we are passed costing for the scalar\n      version (namely computing single scalar iteration cost).  */\n-  if (data->costing_for_scalar)\n+  if (m_costing_for_scalar)\n     return;\n \n-  struct loop *loop = data->loop_info;\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   basic_block *bbs = get_loop_body (loop);\n   int nbbs = loop->num_nodes;\n-  loop_vec_info loop_vinfo = loop_vec_info_for_loop (data->loop_info);\n-  int vec_cost = data->cost[vect_body], not_vec_cost = 0;\n+  int vec_cost = m_costs[vect_body], not_vec_cost = 0;\n \n   for (int i = 0; i < nbbs; i++)\n     {\n@@ -5328,7 +5333,7 @@ rs6000_density_test (rs6000_cost_data *data)\n   if (density_pct > rs6000_density_pct_threshold\n       && vec_cost + not_vec_cost > rs6000_density_size_threshold)\n     {\n-      data->cost[vect_body] = vec_cost * (100 + rs6000_density_penalty) / 100;\n+      m_costs[vect_body] = vec_cost * (100 + rs6000_density_penalty) / 100;\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t \"density %d%%, cost %d exceeds threshold, penalizing \"\n@@ -5338,10 +5343,10 @@ rs6000_density_test (rs6000_cost_data *data)\n \n   /* Check whether we need to penalize the body cost to account\n      for excess strided or elementwise loads.  */\n-  if (data->extra_ctor_cost > 0)\n+  if (m_extra_ctor_cost > 0)\n     {\n-      gcc_assert (data->nloads <= data->nstmts);\n-      unsigned int load_pct = (data->nloads * 100) / data->nstmts;\n+      gcc_assert (m_nloads <= m_nstmts);\n+      unsigned int load_pct = (m_nloads * 100) / m_nstmts;\n \n       /* It's likely to be bounded by latency and execution resources\n \t from many scalar loads which are strided or elementwise loads\n@@ -5353,10 +5358,10 @@ rs6000_density_test (rs6000_cost_data *data)\n \t      the loads.\n \t One typical case is the innermost loop of the hotspot of SPEC2017\n \t 503.bwaves_r without loop interchange.  */\n-      if (data->nloads > (unsigned int) rs6000_density_load_num_threshold\n+      if (m_nloads > (unsigned int) rs6000_density_load_num_threshold\n \t  && load_pct > (unsigned int) rs6000_density_load_pct_threshold)\n \t{\n-\t  data->cost[vect_body] += data->extra_ctor_cost;\n+\t  m_costs[vect_body] += m_extra_ctor_cost;\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t     \"Found %u loads and \"\n@@ -5365,28 +5370,18 @@ rs6000_density_test (rs6000_cost_data *data)\n \t\t\t     \"penalizing loop body \"\n \t\t\t     \"cost by extra cost %u \"\n \t\t\t     \"for ctor.\\n\",\n-\t\t\t     data->nloads, load_pct,\n-\t\t\t     data->extra_ctor_cost);\n+\t\t\t     m_nloads, load_pct,\n+\t\t\t     m_extra_ctor_cost);\n \t}\n     }\n }\n \n-/* Implement targetm.vectorize.init_cost.  */\n+/* Implement targetm.vectorize.create_costs.  */\n \n-static void *\n-rs6000_init_cost (struct loop *loop_info, bool costing_for_scalar)\n+static vector_costs *\n+rs6000_vectorize_create_costs (vec_info *vinfo, bool costing_for_scalar)\n {\n-  rs6000_cost_data *data = XNEW (rs6000_cost_data);\n-  data->loop_info = loop_info;\n-  data->cost[vect_prologue] = 0;\n-  data->cost[vect_body]     = 0;\n-  data->cost[vect_epilogue] = 0;\n-  data->vect_nonmem = false;\n-  data->nstmts = 0;\n-  data->nloads = 0;\n-  data->extra_ctor_cost = 0;\n-  data->costing_for_scalar = costing_for_scalar;\n-  return data;\n+  return new rs6000_cost_data (vinfo, costing_for_scalar);\n }\n \n /* Adjust vectorization cost after calling rs6000_builtin_vectorization_cost.\n@@ -5415,13 +5410,12 @@ rs6000_adjust_vect_cost_per_stmt (enum vect_cost_for_stmt kind,\n /* Helper function for add_stmt_cost.  Check each statement cost\n    entry, gather information and update the target_cost fields\n    accordingly.  */\n-static void\n-rs6000_update_target_cost_per_stmt (rs6000_cost_data *data,\n-\t\t\t\t    enum vect_cost_for_stmt kind,\n-\t\t\t\t    struct _stmt_vec_info *stmt_info,\n-\t\t\t\t    enum vect_cost_model_location where,\n-\t\t\t\t    int stmt_cost,\n-\t\t\t\t    unsigned int orig_count)\n+void\n+rs6000_cost_data::update_target_cost_per_stmt (vect_cost_for_stmt kind,\n+\t\t\t\t\t       stmt_vec_info stmt_info,\n+\t\t\t\t\t       vect_cost_model_location where,\n+\t\t\t\t\t       int stmt_cost,\n+\t\t\t\t\t       unsigned int orig_count)\n {\n \n   /* Check whether we're doing something other than just a copy loop.\n@@ -5433,17 +5427,19 @@ rs6000_update_target_cost_per_stmt (rs6000_cost_data *data,\n       || kind == vec_construct\n       || kind == scalar_to_vec\n       || (where == vect_body && kind == vector_stmt))\n-    data->vect_nonmem = true;\n+    m_vect_nonmem = true;\n \n   /* Gather some information when we are costing the vectorized instruction\n      for the statements located in a loop body.  */\n-  if (!data->costing_for_scalar && data->loop_info && where == vect_body)\n+  if (!m_costing_for_scalar\n+      && is_a<loop_vec_info> (m_vinfo)\n+      && where == vect_body)\n     {\n-      data->nstmts += orig_count;\n+      m_nstmts += orig_count;\n \n       if (kind == scalar_load || kind == vector_load\n \t  || kind == unaligned_load || kind == vector_gather_load)\n-\tdata->nloads += orig_count;\n+\tm_nloads += orig_count;\n \n       /* Power processors do not currently have instructions for strided\n \t and elementwise loads, and instead we must generate multiple\n@@ -5471,20 +5467,16 @@ rs6000_update_target_cost_per_stmt (rs6000_cost_data *data,\n \t  const unsigned int MAX_PENALIZED_COST_FOR_CTOR = 12;\n \t  if (extra_cost > MAX_PENALIZED_COST_FOR_CTOR)\n \t    extra_cost = MAX_PENALIZED_COST_FOR_CTOR;\n-\t  data->extra_ctor_cost += extra_cost;\n+\t  m_extra_ctor_cost += extra_cost;\n \t}\n     }\n }\n \n-/* Implement targetm.vectorize.add_stmt_cost.  */\n-\n-static unsigned\n-rs6000_add_stmt_cost (class vec_info *vinfo, void *data, int count,\n-\t\t      enum vect_cost_for_stmt kind,\n-\t\t      struct _stmt_vec_info *stmt_info, tree vectype,\n-\t\t      int misalign, enum vect_cost_model_location where)\n+unsigned\n+rs6000_cost_data::add_stmt_cost (int count, vect_cost_for_stmt kind,\n+\t\t\t\t stmt_vec_info stmt_info, tree vectype,\n+\t\t\t\t int misalign, vect_cost_model_location where)\n {\n-  rs6000_cost_data *cost_data = (rs6000_cost_data*) data;\n   unsigned retval = 0;\n \n   if (flag_vect_cost_model)\n@@ -5496,19 +5488,11 @@ rs6000_add_stmt_cost (class vec_info *vinfo, void *data, int count,\n \t vectorized are weighted more heavily.  The value here is\n \t arbitrary and could potentially be improved with analysis.  */\n       unsigned int orig_count = count;\n-      if (where == vect_body && stmt_info\n-\t  && stmt_in_inner_loop_p (vinfo, stmt_info))\n-\t{\n-\t  loop_vec_info loop_vinfo = dyn_cast<loop_vec_info> (vinfo);\n-\t  gcc_assert (loop_vinfo);\n-\t  count *= LOOP_VINFO_INNER_LOOP_COST_FACTOR (loop_vinfo); /* FIXME.  */\n-\t}\n-\n-      retval = (unsigned) (count * stmt_cost);\n-      cost_data->cost[where] += retval;\n+      retval = adjust_cost_for_freq (stmt_info, where, count * stmt_cost);\n+      m_costs[where] += retval;\n \n-      rs6000_update_target_cost_per_stmt (cost_data, kind, stmt_info, where,\n-\t\t\t\t\t  stmt_cost, orig_count);\n+      update_target_cost_per_stmt (kind, stmt_info, where,\n+\t\t\t\t   stmt_cost, orig_count);\n     }\n \n   return retval;\n@@ -5520,13 +5504,9 @@ rs6000_add_stmt_cost (class vec_info *vinfo, void *data, int count,\n    vector with length by counting number of required lengths under condition\n    LOOP_VINFO_FULLY_WITH_LENGTH_P.  */\n \n-static void\n-rs6000_adjust_vect_cost_per_loop (rs6000_cost_data *data)\n+void\n+rs6000_cost_data::adjust_vect_cost_per_loop (loop_vec_info loop_vinfo)\n {\n-  struct loop *loop = data->loop_info;\n-  gcc_assert (loop);\n-  loop_vec_info loop_vinfo = loop_vec_info_for_loop (loop);\n-\n   if (LOOP_VINFO_FULLY_WITH_LENGTH_P (loop_vinfo))\n     {\n       rgroup_controls *rgc;\n@@ -5537,49 +5517,29 @@ rs6000_adjust_vect_cost_per_loop (rs6000_cost_data *data)\n \t  /* Each length needs one shift to fill into bits 0-7.  */\n \t  shift_cnt += num_vectors_m1 + 1;\n \n-      rs6000_add_stmt_cost (loop_vinfo, (void *) data, shift_cnt, scalar_stmt,\n-\t\t\t    NULL, NULL_TREE, 0, vect_body);\n+      add_stmt_cost (shift_cnt, scalar_stmt, NULL, NULL_TREE, 0, vect_body);\n     }\n }\n \n-/* Implement targetm.vectorize.finish_cost.  */\n-\n-static void\n-rs6000_finish_cost (void *data, unsigned *prologue_cost,\n-\t\t    unsigned *body_cost, unsigned *epilogue_cost)\n+void\n+rs6000_cost_data::finish_cost ()\n {\n-  rs6000_cost_data *cost_data = (rs6000_cost_data*) data;\n-\n-  if (cost_data->loop_info)\n+  if (loop_vec_info loop_vinfo = dyn_cast<loop_vec_info> (m_vinfo))\n     {\n-      rs6000_adjust_vect_cost_per_loop (cost_data);\n-      rs6000_density_test (cost_data);\n-    }\n+      adjust_vect_cost_per_loop (loop_vinfo);\n+      density_test (loop_vinfo);\n \n-  /* Don't vectorize minimum-vectorization-factor, simple copy loops\n-     that require versioning for any reason.  The vectorization is at\n-     best a wash inside the loop, and the versioning checks make\n-     profitability highly unlikely and potentially quite harmful.  */\n-  if (cost_data->loop_info)\n-    {\n-      loop_vec_info vec_info = loop_vec_info_for_loop (cost_data->loop_info);\n-      if (!cost_data->vect_nonmem\n-\t  && LOOP_VINFO_VECT_FACTOR (vec_info) == 2\n-\t  && LOOP_REQUIRES_VERSIONING (vec_info))\n-\tcost_data->cost[vect_body] += 10000;\n+      /* Don't vectorize minimum-vectorization-factor, simple copy loops\n+\t that require versioning for any reason.  The vectorization is at\n+\t best a wash inside the loop, and the versioning checks make\n+\t profitability highly unlikely and potentially quite harmful.  */\n+      if (!m_vect_nonmem\n+\t  && LOOP_VINFO_VECT_FACTOR (loop_vinfo) == 2\n+\t  && LOOP_REQUIRES_VERSIONING (loop_vinfo))\n+\tm_costs[vect_body] += 10000;\n     }\n \n-  *prologue_cost = cost_data->cost[vect_prologue];\n-  *body_cost     = cost_data->cost[vect_body];\n-  *epilogue_cost = cost_data->cost[vect_epilogue];\n-}\n-\n-/* Implement targetm.vectorize.destroy_cost_data.  */\n-\n-static void\n-rs6000_destroy_cost_data (void *data)\n-{\n-  free (data);\n+  vector_costs::finish_cost ();\n }\n \n /* Implement targetm.loop_unroll_adjust.  */"}, {"sha": "78a1af1ad4da1483957ef1133b3e745318e947e8", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 1, "deletions": 24, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6239dd05127f1dc05f13f504805d36e8ebe1c2c5/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6239dd05127f1dc05f13f504805d36e8ebe1c2c5/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=6239dd05127f1dc05f13f504805d36e8ebe1c2c5", "patch": "@@ -6218,7 +6218,7 @@ type @code{internal_fn}) should be considered expensive when the mask is\n all zeros.  GCC can then try to branch around the instruction instead.\n @end deftypefn\n \n-@deftypefn {Target Hook} {void *} TARGET_VECTORIZE_INIT_COST (class loop *@var{loop_info}, bool @var{costing_for_scalar})\n+@deftypefn {Target Hook} {class vector_costs *} TARGET_VECTORIZE_CREATE_COSTS (vec_info *@var{vinfo}, bool @var{costing_for_scalar})\n This hook should initialize target-specific data structures in preparation\n for modeling the costs of vectorizing a loop or basic block.  The default\n allocates three unsigned integers for accumulating costs for the prologue,\n@@ -6229,29 +6229,6 @@ current cost model is for the scalar version of a loop or block; otherwise\n it is for the vector version.\n @end deftypefn\n \n-@deftypefn {Target Hook} unsigned TARGET_VECTORIZE_ADD_STMT_COST (class vec_info *@var{}, void *@var{data}, int @var{count}, enum vect_cost_for_stmt @var{kind}, class _stmt_vec_info *@var{stmt_info}, tree @var{vectype}, int @var{misalign}, enum vect_cost_model_location @var{where})\n-This hook should update the target-specific @var{data} in response to\n-adding @var{count} copies of the given @var{kind} of statement to a\n-loop or basic block.  The default adds the builtin vectorizer cost for\n-the copies of the statement to the accumulator specified by @var{where},\n-(the prologue, body, or epilogue) and returns the amount added.  The\n-return value should be viewed as a tentative cost that may later be\n-revised.\n-@end deftypefn\n-\n-@deftypefn {Target Hook} void TARGET_VECTORIZE_FINISH_COST (void *@var{data}, unsigned *@var{prologue_cost}, unsigned *@var{body_cost}, unsigned *@var{epilogue_cost})\n-This hook should complete calculations of the cost of vectorizing a loop\n-or basic block based on @var{data}, and return the prologue, body, and\n-epilogue costs as unsigned integers.  The default returns the value of\n-the three accumulators.\n-@end deftypefn\n-\n-@deftypefn {Target Hook} void TARGET_VECTORIZE_DESTROY_COST_DATA (void *@var{data})\n-This hook should release @var{data} and any related data structures\n-allocated by TARGET_VECTORIZE_INIT_COST.  The default releases the\n-accumulator.\n-@end deftypefn\n-\n @deftypefn {Target Hook} tree TARGET_VECTORIZE_BUILTIN_GATHER (const_tree @var{mem_vectype}, const_tree @var{index_type}, int @var{scale})\n Target builtin that implements vector gather operation.  @var{mem_vectype}\n is the vector type of the load and @var{index_type} is scalar type of"}, {"sha": "4401550989e80f31e1dbc95f31c289b064a5b836", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6239dd05127f1dc05f13f504805d36e8ebe1c2c5/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6239dd05127f1dc05f13f504805d36e8ebe1c2c5/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=6239dd05127f1dc05f13f504805d36e8ebe1c2c5", "patch": "@@ -4182,13 +4182,7 @@ address;  but often a machine-dependent strategy can generate better code.\n \n @hook TARGET_VECTORIZE_EMPTY_MASK_IS_EXPENSIVE\n \n-@hook TARGET_VECTORIZE_INIT_COST\n-\n-@hook TARGET_VECTORIZE_ADD_STMT_COST\n-\n-@hook TARGET_VECTORIZE_FINISH_COST\n-\n-@hook TARGET_VECTORIZE_DESTROY_COST_DATA\n+@hook TARGET_VECTORIZE_CREATE_COSTS\n \n @hook TARGET_VECTORIZE_BUILTIN_GATHER\n "}, {"sha": "51ea167172b465c95009656cf9c8660c95f2c179", "filename": "gcc/target.def", "status": "modified", "additions": 4, "deletions": 45, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6239dd05127f1dc05f13f504805d36e8ebe1c2c5/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6239dd05127f1dc05f13f504805d36e8ebe1c2c5/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=6239dd05127f1dc05f13f504805d36e8ebe1c2c5", "patch": "@@ -2051,7 +2051,7 @@ stores.\",\n \n /* Target function to initialize the cost model for a loop or block.  */\n DEFHOOK\n-(init_cost,\n+(create_costs,\n  \"This hook should initialize target-specific data structures in preparation\\n\\\n for modeling the costs of vectorizing a loop or basic block.  The default\\n\\\n allocates three unsigned integers for accumulating costs for the prologue,\\n\\\n@@ -2060,50 +2060,9 @@ non-NULL, it identifies the loop being vectorized; otherwise a single block\\n\\\n is being vectorized.  If @var{costing_for_scalar} is true, it indicates the\\n\\\n current cost model is for the scalar version of a loop or block; otherwise\\n\\\n it is for the vector version.\",\n- void *,\n- (class loop *loop_info, bool costing_for_scalar),\n- default_init_cost)\n-\n-/* Target function to record N statements of the given kind using the\n-   given vector type within the cost model data for the current loop or\n-    block.  */\n-DEFHOOK\n-(add_stmt_cost,\n- \"This hook should update the target-specific @var{data} in response to\\n\\\n-adding @var{count} copies of the given @var{kind} of statement to a\\n\\\n-loop or basic block.  The default adds the builtin vectorizer cost for\\n\\\n-the copies of the statement to the accumulator specified by @var{where},\\n\\\n-(the prologue, body, or epilogue) and returns the amount added.  The\\n\\\n-return value should be viewed as a tentative cost that may later be\\n\\\n-revised.\",\n- unsigned,\n- (class vec_info *, void *data, int count, enum vect_cost_for_stmt kind,\n-  class _stmt_vec_info *stmt_info, tree vectype, int misalign,\n-  enum vect_cost_model_location where),\n- default_add_stmt_cost)\n-\n-/* Target function to calculate the total cost of the current vectorized\n-   loop or block.  */\n-DEFHOOK\n-(finish_cost,\n- \"This hook should complete calculations of the cost of vectorizing a loop\\n\\\n-or basic block based on @var{data}, and return the prologue, body, and\\n\\\n-epilogue costs as unsigned integers.  The default returns the value of\\n\\\n-the three accumulators.\",\n- void,\n- (void *data, unsigned *prologue_cost, unsigned *body_cost,\n-  unsigned *epilogue_cost),\n- default_finish_cost)\n-\n-/* Function to delete target-specific cost modeling data.  */\n-DEFHOOK\n-(destroy_cost_data,\n- \"This hook should release @var{data} and any related data structures\\n\\\n-allocated by TARGET_VECTORIZE_INIT_COST.  The default releases the\\n\\\n-accumulator.\",\n- void,\n- (void *data),\n- default_destroy_cost_data)\n+ class vector_costs *,\n+ (vec_info *vinfo, bool costing_for_scalar),\n+ default_vectorize_create_costs)\n \n HOOK_VECTOR_END (vectorize)\n "}, {"sha": "6f071f80231c71dbcb44e39ce338533fd2f19cf6", "filename": "gcc/targhooks.c", "status": "modified", "additions": 3, "deletions": 58, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6239dd05127f1dc05f13f504805d36e8ebe1c2c5/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6239dd05127f1dc05f13f504805d36e8ebe1c2c5/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=6239dd05127f1dc05f13f504805d36e8ebe1c2c5", "patch": "@@ -1474,65 +1474,10 @@ default_empty_mask_is_expensive (unsigned ifn)\n    loop body, and epilogue) for a vectorized loop or block.  So allocate an\n    array of three unsigned ints, set it to zero, and return its address.  */\n \n-void *\n-default_init_cost (class loop *loop_info ATTRIBUTE_UNUSED,\n-\t\t   bool costing_for_scalar ATTRIBUTE_UNUSED)\n-{\n-  unsigned *cost = XNEWVEC (unsigned, 3);\n-  cost[vect_prologue] = cost[vect_body] = cost[vect_epilogue] = 0;\n-  return cost;\n-}\n-\n-/* By default, the cost model looks up the cost of the given statement\n-   kind and mode, multiplies it by the occurrence count, accumulates\n-   it into the cost specified by WHERE, and returns the cost added.  */\n-\n-unsigned\n-default_add_stmt_cost (class vec_info *vinfo, void *data, int count,\n-\t\t       enum vect_cost_for_stmt kind,\n-\t\t       class _stmt_vec_info *stmt_info, tree vectype,\n-\t\t       int misalign,\n-\t\t       enum vect_cost_model_location where)\n-{\n-  unsigned *cost = (unsigned *) data;\n-  unsigned retval = 0;\n-  int stmt_cost = targetm.vectorize.builtin_vectorization_cost (kind, vectype,\n-\t\t\t\t\t\t\t\tmisalign);\n-   /* Statements in an inner loop relative to the loop being\n-      vectorized are weighted more heavily.  The value here is\n-      arbitrary and could potentially be improved with analysis.  */\n-  if (where == vect_body && stmt_info\n-      && stmt_in_inner_loop_p (vinfo, stmt_info))\n-    {\n-      loop_vec_info loop_vinfo = dyn_cast<loop_vec_info> (vinfo);\n-      gcc_assert (loop_vinfo);\n-      count *= LOOP_VINFO_INNER_LOOP_COST_FACTOR (loop_vinfo);\n-    }\n-\n-  retval = (unsigned) (count * stmt_cost);\n-  cost[where] += retval;\n-\n-  return retval;\n-}\n-\n-/* By default, the cost model just returns the accumulated costs.  */\n-\n-void\n-default_finish_cost (void *data, unsigned *prologue_cost,\n-\t\t     unsigned *body_cost, unsigned *epilogue_cost)\n-{\n-  unsigned *cost = (unsigned *) data;\n-  *prologue_cost = cost[vect_prologue];\n-  *body_cost     = cost[vect_body];\n-  *epilogue_cost = cost[vect_epilogue];\n-}\n-\n-/* Free the cost data.  */\n-\n-void\n-default_destroy_cost_data (void *data)\n+vector_costs *\n+default_vectorize_create_costs (vec_info *vinfo, bool costing_for_scalar)\n {\n-  free (data);\n+  return new vector_costs (vinfo, costing_for_scalar);\n }\n \n /* Determine whether or not a pointer mode is valid. Assume defaults"}, {"sha": "11e9d7dd1a839dd9484d630f2070727c9f9f7c7e", "filename": "gcc/targhooks.h", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6239dd05127f1dc05f13f504805d36e8ebe1c2c5/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6239dd05127f1dc05f13f504805d36e8ebe1c2c5/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=6239dd05127f1dc05f13f504805d36e8ebe1c2c5", "patch": "@@ -118,13 +118,7 @@ extern opt_machine_mode default_vectorize_related_mode (machine_mode,\n \t\t\t\t\t\t\tpoly_uint64);\n extern opt_machine_mode default_get_mask_mode (machine_mode);\n extern bool default_empty_mask_is_expensive (unsigned);\n-extern void *default_init_cost (class loop *, bool);\n-extern unsigned default_add_stmt_cost (class vec_info *, void *, int,\n-\t\t\t\t       enum vect_cost_for_stmt,\n-\t\t\t\t       class _stmt_vec_info *, tree, int,\n-\t\t\t\t       enum vect_cost_model_location);\n-extern void default_finish_cost (void *, unsigned *, unsigned *, unsigned *);\n-extern void default_destroy_cost_data (void *);\n+extern vector_costs *default_vectorize_create_costs (vec_info *, bool);\n \n /* OpenACC hooks.  */\n extern bool default_goacc_validate_dims (tree, int [], int, unsigned);"}, {"sha": "201000af425541ef2d1d7a40ac9ae75801ad183a", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 26, "deletions": 25, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6239dd05127f1dc05f13f504805d36e8ebe1c2c5/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6239dd05127f1dc05f13f504805d36e8ebe1c2c5/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=6239dd05127f1dc05f13f504805d36e8ebe1c2c5", "patch": "@@ -814,7 +814,7 @@ bb_in_loop_p (const_basic_block bb, const void *data)\n    stmt_vec_info structs for all the stmts in LOOP_IN.  */\n \n _loop_vec_info::_loop_vec_info (class loop *loop_in, vec_info_shared *shared)\n-  : vec_info (vec_info::loop, init_cost (loop_in, false), shared),\n+  : vec_info (vec_info::loop, shared),\n     loop (loop_in),\n     bbs (XCNEWVEC (basic_block, loop->num_nodes)),\n     num_itersm1 (NULL_TREE),\n@@ -1292,18 +1292,18 @@ vect_compute_single_scalar_iteration_cost (loop_vec_info loop_vinfo)\n     }\n \n   /* Now accumulate cost.  */\n-  void *target_cost_data = init_cost (loop, true);\n+  vector_costs *target_cost_data = init_cost (loop_vinfo, true);\n   stmt_info_for_cost *si;\n   int j;\n   FOR_EACH_VEC_ELT (LOOP_VINFO_SCALAR_ITERATION_COST (loop_vinfo),\n \t\t    j, si)\n-    (void) add_stmt_cost (loop_vinfo, target_cost_data, si->count,\n+    (void) add_stmt_cost (target_cost_data, si->count,\n \t\t\t  si->kind, si->stmt_info, si->vectype,\n \t\t\t  si->misalign, si->where);\n   unsigned prologue_cost = 0, body_cost = 0, epilogue_cost = 0;\n   finish_cost (target_cost_data, &prologue_cost, &body_cost,\n \t       &epilogue_cost);\n-  destroy_cost_data (target_cost_data);\n+  delete target_cost_data;\n   LOOP_VINFO_SINGLE_SCALAR_ITERATION_COST (loop_vinfo)\n     = prologue_cost + body_cost + epilogue_cost;\n }\n@@ -1783,7 +1783,7 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo)\n         }\n     } /* bbs */\n \n-  add_stmt_costs (loop_vinfo, loop_vinfo->target_cost_data, &cost_vec);\n+  add_stmt_costs (loop_vinfo->target_cost_data, &cost_vec);\n \n   /* All operations in the loop are either irrelevant (deal with loop\n      control, or dead), or only used outside the loop and can be moved\n@@ -2393,6 +2393,8 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal, unsigned *n_stmts)\n \t\t   LOOP_VINFO_INT_NITERS (loop_vinfo));\n     }\n \n+  LOOP_VINFO_TARGET_COST_DATA (loop_vinfo) = init_cost (loop_vinfo, false);\n+\n   /* Analyze the alignment of the data-refs in the loop.\n      Fail if a data reference is found that cannot be vectorized.  */\n \n@@ -2757,9 +2759,8 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal, unsigned *n_stmts)\n   LOOP_VINFO_COMP_ALIAS_DDRS (loop_vinfo).release ();\n   LOOP_VINFO_CHECK_UNEQUAL_ADDRS (loop_vinfo).release ();\n   /* Reset target cost data.  */\n-  destroy_cost_data (LOOP_VINFO_TARGET_COST_DATA (loop_vinfo));\n-  LOOP_VINFO_TARGET_COST_DATA (loop_vinfo)\n-    = init_cost (LOOP_VINFO_LOOP (loop_vinfo), false);\n+  delete LOOP_VINFO_TARGET_COST_DATA (loop_vinfo);\n+  LOOP_VINFO_TARGET_COST_DATA (loop_vinfo) = nullptr;\n   /* Reset accumulated rgroup information.  */\n   release_vec_loop_controls (&LOOP_VINFO_MASKS (loop_vinfo));\n   release_vec_loop_controls (&LOOP_VINFO_LENS (loop_vinfo));\n@@ -3895,7 +3896,7 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n   int scalar_outside_cost = 0;\n   int assumed_vf = vect_vf_for_cost (loop_vinfo);\n   int npeel = LOOP_VINFO_PEELING_FOR_ALIGNMENT (loop_vinfo);\n-  void *target_cost_data = LOOP_VINFO_TARGET_COST_DATA (loop_vinfo);\n+  vector_costs *target_cost_data = LOOP_VINFO_TARGET_COST_DATA (loop_vinfo);\n \n   /* Cost model disabled.  */\n   if (unlimited_cost_model (LOOP_VINFO_LOOP (loop_vinfo)))\n@@ -3912,7 +3913,7 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n     {\n       /*  FIXME: Make cost depend on complexity of individual check.  */\n       unsigned len = LOOP_VINFO_MAY_MISALIGN_STMTS (loop_vinfo).length ();\n-      (void) add_stmt_cost (loop_vinfo, target_cost_data, len, vector_stmt,\n+      (void) add_stmt_cost (target_cost_data, len, vector_stmt,\n \t\t\t    NULL, NULL_TREE, 0, vect_prologue);\n       if (dump_enabled_p ())\n \tdump_printf (MSG_NOTE,\n@@ -3925,12 +3926,12 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n     {\n       /*  FIXME: Make cost depend on complexity of individual check.  */\n       unsigned len = LOOP_VINFO_COMP_ALIAS_DDRS (loop_vinfo).length ();\n-      (void) add_stmt_cost (loop_vinfo, target_cost_data, len, vector_stmt,\n+      (void) add_stmt_cost (target_cost_data, len, vector_stmt,\n \t\t\t    NULL, NULL_TREE, 0, vect_prologue);\n       len = LOOP_VINFO_CHECK_UNEQUAL_ADDRS (loop_vinfo).length ();\n       if (len)\n \t/* Count LEN - 1 ANDs and LEN comparisons.  */\n-\t(void) add_stmt_cost (loop_vinfo, target_cost_data, len * 2 - 1,\n+\t(void) add_stmt_cost (target_cost_data, len * 2 - 1,\n \t\t\t      scalar_stmt, NULL, NULL_TREE, 0, vect_prologue);\n       len = LOOP_VINFO_LOWER_BOUNDS (loop_vinfo).length ();\n       if (len)\n@@ -3941,7 +3942,7 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n \t  for (unsigned int i = 0; i < len; ++i)\n \t    if (!LOOP_VINFO_LOWER_BOUNDS (loop_vinfo)[i].unsigned_p)\n \t      nstmts += 1;\n-\t  (void) add_stmt_cost (loop_vinfo, target_cost_data, nstmts,\n+\t  (void) add_stmt_cost (target_cost_data, nstmts,\n \t\t\t\tscalar_stmt, NULL, NULL_TREE, 0, vect_prologue);\n \t}\n       if (dump_enabled_p ())\n@@ -3954,7 +3955,7 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n   if (LOOP_REQUIRES_VERSIONING_FOR_NITERS (loop_vinfo))\n     {\n       /*  FIXME: Make cost depend on complexity of individual check.  */\n-      (void) add_stmt_cost (loop_vinfo, target_cost_data, 1, vector_stmt,\n+      (void) add_stmt_cost (target_cost_data, 1, vector_stmt,\n \t\t\t    NULL, NULL_TREE, 0, vect_prologue);\n       if (dump_enabled_p ())\n \tdump_printf (MSG_NOTE,\n@@ -3963,7 +3964,7 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n     }\n \n   if (LOOP_REQUIRES_VERSIONING (loop_vinfo))\n-    (void) add_stmt_cost (loop_vinfo, target_cost_data, 1, cond_branch_taken,\n+    (void) add_stmt_cost (target_cost_data, 1, cond_branch_taken,\n \t\t\t  NULL, NULL_TREE, 0, vect_prologue);\n \n   /* Count statements in scalar loop.  Using this as scalar cost for a single\n@@ -4051,7 +4052,7 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n   if (peel_iters_prologue)\n     FOR_EACH_VEC_ELT (LOOP_VINFO_SCALAR_ITERATION_COST (loop_vinfo), j, si)\n       {\n-\t(void) add_stmt_cost (loop_vinfo, target_cost_data,\n+\t(void) add_stmt_cost (target_cost_data,\n \t\t\t      si->count * peel_iters_prologue, si->kind,\n \t\t\t      si->stmt_info, si->vectype, si->misalign,\n \t\t\t      vect_prologue);\n@@ -4061,7 +4062,7 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n   if (peel_iters_epilogue)\n     FOR_EACH_VEC_ELT (LOOP_VINFO_SCALAR_ITERATION_COST (loop_vinfo), j, si)\n       {\n-\t(void) add_stmt_cost (loop_vinfo, target_cost_data,\n+\t(void) add_stmt_cost (target_cost_data,\n \t\t\t      si->count * peel_iters_epilogue, si->kind,\n \t\t\t      si->stmt_info, si->vectype, si->misalign,\n \t\t\t      vect_epilogue);\n@@ -4070,20 +4071,20 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n   /* Add possible cond_branch_taken/cond_branch_not_taken cost.  */\n \n   if (prologue_need_br_taken_cost)\n-    (void) add_stmt_cost (loop_vinfo, target_cost_data, 1, cond_branch_taken,\n+    (void) add_stmt_cost (target_cost_data, 1, cond_branch_taken,\n \t\t\t  NULL, NULL_TREE, 0, vect_prologue);\n \n   if (prologue_need_br_not_taken_cost)\n-    (void) add_stmt_cost (loop_vinfo, target_cost_data, 1,\n+    (void) add_stmt_cost (target_cost_data, 1,\n \t\t\t  cond_branch_not_taken, NULL, NULL_TREE, 0,\n \t\t\t  vect_prologue);\n \n   if (epilogue_need_br_taken_cost)\n-    (void) add_stmt_cost (loop_vinfo, target_cost_data, 1, cond_branch_taken,\n+    (void) add_stmt_cost (target_cost_data, 1, cond_branch_taken,\n \t\t\t  NULL, NULL_TREE, 0, vect_epilogue);\n \n   if (epilogue_need_br_not_taken_cost)\n-    (void) add_stmt_cost (loop_vinfo, target_cost_data, 1,\n+    (void) add_stmt_cost (target_cost_data, 1,\n \t\t\t  cond_branch_not_taken, NULL, NULL_TREE, 0,\n \t\t\t  vect_epilogue);\n \n@@ -4111,9 +4112,9 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n \t simpler and safer to use the worst-case cost; if this ends up\n \t being the tie-breaker between vectorizing or not, then it's\n \t probably better not to vectorize.  */\n-      (void) add_stmt_cost (loop_vinfo, target_cost_data, num_masks,\n+      (void) add_stmt_cost (target_cost_data, num_masks,\n \t\t\t    vector_stmt, NULL, NULL_TREE, 0, vect_prologue);\n-      (void) add_stmt_cost (loop_vinfo, target_cost_data, num_masks - 1,\n+      (void) add_stmt_cost (target_cost_data, num_masks - 1,\n \t\t\t    vector_stmt, NULL, NULL_TREE, 0, vect_body);\n     }\n   else if (LOOP_VINFO_FULLY_WITH_LENGTH_P (loop_vinfo))\n@@ -4163,9 +4164,9 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n \t      body_stmts += 3 * num_vectors;\n \t  }\n \n-      (void) add_stmt_cost (loop_vinfo, target_cost_data, prologue_stmts,\n+      (void) add_stmt_cost (target_cost_data, prologue_stmts,\n \t\t\t    scalar_stmt, NULL, NULL_TREE, 0, vect_prologue);\n-      (void) add_stmt_cost (loop_vinfo, target_cost_data, body_stmts,\n+      (void) add_stmt_cost (target_cost_data, body_stmts,\n \t\t\t    scalar_stmt, NULL, NULL_TREE, 0, vect_body);\n     }\n "}, {"sha": "7e1061c8c4e6ebc7b6dfe80e2c65d21b904c506b", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6239dd05127f1dc05f13f504805d36e8ebe1c2c5/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6239dd05127f1dc05f13f504805d36e8ebe1c2c5/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=6239dd05127f1dc05f13f504805d36e8ebe1c2c5", "patch": "@@ -4354,7 +4354,7 @@ vect_detect_hybrid_slp (loop_vec_info loop_vinfo)\n /* Initialize a bb_vec_info struct for the statements in BBS basic blocks.  */\n \n _bb_vec_info::_bb_vec_info (vec<basic_block> _bbs, vec_info_shared *shared)\n-  : vec_info (vec_info::bb, init_cost (NULL, false), shared),\n+  : vec_info (vec_info::bb, shared),\n     bbs (_bbs),\n     roots (vNULL)\n {\n@@ -4896,7 +4896,7 @@ vect_slp_analyze_operations (vec_info *vinfo)\n \t    instance->cost_vec = cost_vec;\n \t  else\n \t    {\n-\t      add_stmt_costs (vinfo, vinfo->target_cost_data, &cost_vec);\n+\t      add_stmt_costs (vinfo->target_cost_data, &cost_vec);\n \t      cost_vec.release ();\n \t    }\n \t}\n@@ -5336,32 +5336,30 @@ vect_bb_vectorization_profitable_p (bb_vec_info bb_vinfo,\n \t  continue;\n \t}\n \n-      void *scalar_target_cost_data = init_cost (NULL, true);\n+      class vector_costs *scalar_target_cost_data = init_cost (bb_vinfo, true);\n       do\n \t{\n-\t  add_stmt_cost (bb_vinfo, scalar_target_cost_data,\n-\t\t\t li_scalar_costs[si].second);\n+\t  add_stmt_cost (scalar_target_cost_data, li_scalar_costs[si].second);\n \t  si++;\n \t}\n       while (si < li_scalar_costs.length ()\n \t     && li_scalar_costs[si].first == sl);\n       unsigned dummy;\n       finish_cost (scalar_target_cost_data, &dummy, &scalar_cost, &dummy);\n-      destroy_cost_data (scalar_target_cost_data);\n+      delete scalar_target_cost_data;\n \n       /* Complete the target-specific vector cost calculation.  */\n-      void *vect_target_cost_data = init_cost (NULL, false);\n+      class vector_costs *vect_target_cost_data = init_cost (bb_vinfo, false);\n       do\n \t{\n-\t  add_stmt_cost (bb_vinfo, vect_target_cost_data,\n-\t\t\t li_vector_costs[vi].second);\n+\t  add_stmt_cost (vect_target_cost_data, li_vector_costs[vi].second);\n \t  vi++;\n \t}\n       while (vi < li_vector_costs.length ()\n \t     && li_vector_costs[vi].first == vl);\n       finish_cost (vect_target_cost_data, &vec_prologue_cost,\n \t\t   &vec_inside_cost, &vec_epilogue_cost);\n-      destroy_cost_data (vect_target_cost_data);\n+      delete vect_target_cost_data;\n \n       vec_outside_cost = vec_prologue_cost + vec_epilogue_cost;\n "}, {"sha": "4c9ab8124b58fc55a28375c8ba8142db352669f0", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 61, "deletions": 6, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6239dd05127f1dc05f13f504805d36e8ebe1c2c5/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6239dd05127f1dc05f13f504805d36e8ebe1c2c5/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=6239dd05127f1dc05f13f504805d36e8ebe1c2c5", "patch": "@@ -98,11 +98,10 @@ auto_purge_vect_location::~auto_purge_vect_location ()\n /* Dump a cost entry according to args to F.  */\n \n void\n-dump_stmt_cost (FILE *f, void *data, int count, enum vect_cost_for_stmt kind,\n+dump_stmt_cost (FILE *f, int count, enum vect_cost_for_stmt kind,\n \t\tstmt_vec_info stmt_info, tree, int misalign, unsigned cost,\n \t\tenum vect_cost_model_location where)\n {\n-  fprintf (f, \"%p \", data);\n   if (stmt_info)\n     {\n       print_gimple_expr (f, STMT_VINFO_STMT (stmt_info), 0, TDF_SLIM);\n@@ -457,12 +456,11 @@ shrink_simd_arrays\n /* Initialize the vec_info with kind KIND_IN and target cost data\n    TARGET_COST_DATA_IN.  */\n \n-vec_info::vec_info (vec_info::vec_kind kind_in, void *target_cost_data_in,\n-\t\t    vec_info_shared *shared_)\n+vec_info::vec_info (vec_info::vec_kind kind_in, vec_info_shared *shared_)\n   : kind (kind_in),\n     shared (shared_),\n     stmt_vec_info_ro (false),\n-    target_cost_data (target_cost_data_in)\n+    target_cost_data (nullptr)\n {\n   stmt_vec_infos.create (50);\n }\n@@ -472,7 +470,7 @@ vec_info::~vec_info ()\n   for (slp_instance &instance : slp_instances)\n     vect_free_slp_instance (instance);\n \n-  destroy_cost_data (target_cost_data);\n+  delete target_cost_data;\n   free_stmt_vec_infos ();\n }\n \n@@ -1690,3 +1688,60 @@ scalar_cond_masked_key::get_cond_ops_from_tree (tree t)\n   this->op0 = t;\n   this->op1 = build_zero_cst (TREE_TYPE (t));\n }\n+\n+/* See the comment above the declaration for details.  */\n+\n+unsigned int\n+vector_costs::add_stmt_cost (int count, vect_cost_for_stmt kind,\n+\t\t\t     stmt_vec_info stmt_info, tree vectype,\n+\t\t\t     int misalign, vect_cost_model_location where)\n+{\n+  unsigned int cost\n+    = builtin_vectorization_cost (kind, vectype, misalign) * count;\n+  return record_stmt_cost (stmt_info, where, cost);\n+}\n+\n+/* See the comment above the declaration for details.  */\n+\n+void\n+vector_costs::finish_cost ()\n+{\n+  gcc_assert (!m_finished);\n+  m_finished = true;\n+}\n+\n+/* Record a base cost of COST units against WHERE.  If STMT_INFO is\n+   nonnull, use it to adjust the cost based on execution frequency\n+   (where appropriate).  */\n+\n+unsigned int\n+vector_costs::record_stmt_cost (stmt_vec_info stmt_info,\n+\t\t\t\tvect_cost_model_location where,\n+\t\t\t\tunsigned int cost)\n+{\n+  cost = adjust_cost_for_freq (stmt_info, where, cost);\n+  m_costs[where] += cost;\n+  return cost;\n+}\n+\n+/* COST is the base cost we have calculated for an operation in location WHERE.\n+   If STMT_INFO is nonnull, use it to adjust the cost based on execution\n+   frequency (where appropriate).  Return the adjusted cost.  */\n+\n+unsigned int\n+vector_costs::adjust_cost_for_freq (stmt_vec_info stmt_info,\n+\t\t\t\t    vect_cost_model_location where,\n+\t\t\t\t    unsigned int cost)\n+{\n+  /* Statements in an inner loop relative to the loop being\n+     vectorized are weighted more heavily.  The value here is\n+     arbitrary and could potentially be improved with analysis.  */\n+  if (where == vect_body\n+      && stmt_info\n+      && stmt_in_inner_loop_p (m_vinfo, stmt_info))\n+    {\n+      loop_vec_info loop_vinfo = as_a<loop_vec_info> (m_vinfo);\n+      cost *= LOOP_VINFO_INNER_LOOP_COST_FACTOR (loop_vinfo);\n+    }\n+  return cost;\n+}"}, {"sha": "76e22ee36bc76f0788c81b5a80fe67490050a5ff", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 116, "deletions": 25, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6239dd05127f1dc05f13f504805d36e8ebe1c2c5/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6239dd05127f1dc05f13f504805d36e8ebe1c2c5/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=6239dd05127f1dc05f13f504805d36e8ebe1c2c5", "patch": "@@ -368,7 +368,7 @@ class vec_info {\n   typedef hash_set<int_hash<machine_mode, E_VOIDmode, E_BLKmode> > mode_set;\n   enum vec_kind { bb, loop };\n \n-  vec_info (vec_kind, void *, vec_info_shared *);\n+  vec_info (vec_kind, vec_info_shared *);\n   ~vec_info ();\n \n   stmt_vec_info add_stmt (gimple *);\n@@ -406,7 +406,7 @@ class vec_info {\n   auto_vec<stmt_vec_info> grouped_stores;\n \n   /* Cost data used by the target cost model.  */\n-  void *target_cost_data;\n+  class vector_costs *target_cost_data;\n \n   /* The set of vector modes used in the vectorized region.  */\n   mode_set used_vector_modes;\n@@ -1395,6 +1395,103 @@ struct gather_scatter_info {\n #define PURE_SLP_STMT(S)                  ((S)->slp_type == pure_slp)\n #define STMT_SLP_TYPE(S)                   (S)->slp_type\n \n+/* Contains the scalar or vector costs for a vec_info.  */\n+class vector_costs\n+{\n+public:\n+  vector_costs (vec_info *, bool);\n+  virtual ~vector_costs () {}\n+\n+  /* Update the costs in response to adding COUNT copies of a statement.\n+\n+     - WHERE specifies whether the cost occurs in the loop prologue,\n+       the loop body, or the loop epilogue.\n+     - KIND is the kind of statement, which is always meaningful.\n+     - STMT_INFO, if nonnull, describes the statement that will be\n+       vectorized.\n+     - VECTYPE, if nonnull, is the vector type that the vectorized\n+       statement will operate on.  Note that this should be used in\n+       preference to STMT_VINFO_VECTYPE (STMT_INFO) since the latter\n+       is not correct for SLP.\n+     - for unaligned_load and unaligned_store statements, MISALIGN is\n+       the byte misalignment of the load or store relative to the target's\n+       preferred alignment for VECTYPE, or DR_MISALIGNMENT_UNKNOWN\n+       if the misalignment is not known.\n+\n+     Return the calculated cost as well as recording it.  The return\n+     value is used for dumping purposes.  */\n+  virtual unsigned int add_stmt_cost (int count, vect_cost_for_stmt kind,\n+\t\t\t\t      stmt_vec_info stmt_info, tree vectype,\n+\t\t\t\t      int misalign,\n+\t\t\t\t      vect_cost_model_location where);\n+\n+  /* Finish calculating the cost of the code.  The results can be\n+     read back using the functions below.  */\n+  virtual void finish_cost ();\n+\n+  unsigned int prologue_cost () const;\n+  unsigned int body_cost () const;\n+  unsigned int epilogue_cost () const;\n+\n+protected:\n+  unsigned int record_stmt_cost (stmt_vec_info, vect_cost_model_location,\n+\t\t\t\t unsigned int);\n+  unsigned int adjust_cost_for_freq (stmt_vec_info, vect_cost_model_location,\n+\t\t\t\t     unsigned int);\n+\n+  /* The region of code that we're considering vectorizing.  */\n+  vec_info *m_vinfo;\n+\n+  /* True if we're costing the scalar code, false if we're costing\n+     the vector code.  */\n+  bool m_costing_for_scalar;\n+\n+  /* The costs of the three regions, indexed by vect_cost_model_location.  */\n+  unsigned int m_costs[3];\n+\n+  /* True if finish_cost has been called.  */\n+  bool m_finished;\n+};\n+\n+/* Create costs for VINFO.  COSTING_FOR_SCALAR is true if the costs\n+   are for scalar code, false if they are for vector code.  */\n+\n+inline\n+vector_costs::vector_costs (vec_info *vinfo, bool costing_for_scalar)\n+  : m_vinfo (vinfo),\n+    m_costing_for_scalar (costing_for_scalar),\n+    m_costs (),\n+    m_finished (false)\n+{\n+}\n+\n+/* Return the cost of the prologue code (in abstract units).  */\n+\n+inline unsigned int\n+vector_costs::prologue_cost () const\n+{\n+  gcc_checking_assert (m_finished);\n+  return m_costs[vect_prologue];\n+}\n+\n+/* Return the cost of the body code (in abstract units).  */\n+\n+inline unsigned int\n+vector_costs::body_cost () const\n+{\n+  gcc_checking_assert (m_finished);\n+  return m_costs[vect_body];\n+}\n+\n+/* Return the cost of the epilogue code (in abstract units).  */\n+\n+inline unsigned int\n+vector_costs::epilogue_cost () const\n+{\n+  gcc_checking_assert (m_finished);\n+  return m_costs[vect_epilogue];\n+}\n+\n #define VECT_MAX_COST 1000\n \n /* The maximum number of intermediate steps required in multi-step type\n@@ -1531,66 +1628,60 @@ int vect_get_stmt_cost (enum vect_cost_for_stmt type_of_cost)\n \n /* Alias targetm.vectorize.init_cost.  */\n \n-static inline void *\n-init_cost (class loop *loop_info, bool costing_for_scalar)\n+static inline vector_costs *\n+init_cost (vec_info *vinfo, bool costing_for_scalar)\n {\n-  return targetm.vectorize.init_cost (loop_info, costing_for_scalar);\n+  return targetm.vectorize.create_costs (vinfo, costing_for_scalar);\n }\n \n-extern void dump_stmt_cost (FILE *, void *, int, enum vect_cost_for_stmt,\n+extern void dump_stmt_cost (FILE *, int, enum vect_cost_for_stmt,\n \t\t\t    stmt_vec_info, tree, int, unsigned,\n \t\t\t    enum vect_cost_model_location);\n \n /* Alias targetm.vectorize.add_stmt_cost.  */\n \n static inline unsigned\n-add_stmt_cost (vec_info *vinfo, void *data, int count,\n+add_stmt_cost (vector_costs *costs, int count,\n \t       enum vect_cost_for_stmt kind,\n \t       stmt_vec_info stmt_info, tree vectype, int misalign,\n \t       enum vect_cost_model_location where)\n {\n-  unsigned cost = targetm.vectorize.add_stmt_cost (vinfo, data, count, kind,\n-\t\t\t\t\t\t   stmt_info, vectype,\n-\t\t\t\t\t\t   misalign, where);\n+  unsigned cost = costs->add_stmt_cost (count, kind, stmt_info, vectype,\n+\t\t\t\t\tmisalign, where);\n   if (dump_file && (dump_flags & TDF_DETAILS))\n-    dump_stmt_cost (dump_file, data, count, kind, stmt_info, vectype, misalign,\n+    dump_stmt_cost (dump_file, count, kind, stmt_info, vectype, misalign,\n \t\t    cost, where);\n   return cost;\n }\n \n /* Alias targetm.vectorize.add_stmt_cost.  */\n \n static inline unsigned\n-add_stmt_cost (vec_info *vinfo, void *data, stmt_info_for_cost *i)\n+add_stmt_cost (vector_costs *costs, stmt_info_for_cost *i)\n {\n-  return add_stmt_cost (vinfo, data, i->count, i->kind, i->stmt_info,\n+  return add_stmt_cost (costs, i->count, i->kind, i->stmt_info,\n \t\t\ti->vectype, i->misalign, i->where);\n }\n \n /* Alias targetm.vectorize.finish_cost.  */\n \n static inline void\n-finish_cost (void *data, unsigned *prologue_cost,\n+finish_cost (vector_costs *costs, unsigned *prologue_cost,\n \t     unsigned *body_cost, unsigned *epilogue_cost)\n {\n-  targetm.vectorize.finish_cost (data, prologue_cost, body_cost, epilogue_cost);\n-}\n-\n-/* Alias targetm.vectorize.destroy_cost_data.  */\n-\n-static inline void\n-destroy_cost_data (void *data)\n-{\n-  targetm.vectorize.destroy_cost_data (data);\n+  costs->finish_cost ();\n+  *prologue_cost = costs->prologue_cost ();\n+  *body_cost = costs->body_cost ();\n+  *epilogue_cost = costs->epilogue_cost ();\n }\n \n inline void\n-add_stmt_costs (vec_info *vinfo, void *data, stmt_vector_for_cost *cost_vec)\n+add_stmt_costs (vector_costs *costs, stmt_vector_for_cost *cost_vec)\n {\n   stmt_info_for_cost *cost;\n   unsigned i;\n   FOR_EACH_VEC_ELT (*cost_vec, i, cost)\n-    add_stmt_cost (vinfo, data, cost->count, cost->kind, cost->stmt_info,\n+    add_stmt_cost (costs, cost->count, cost->kind, cost->stmt_info,\n \t\t   cost->vectype, cost->misalign, cost->where);\n }\n "}]}