{"sha": "271e6f02a18b2d480c55b7bdee57bc4de7edc02a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjcxZTZmMDJhMThiMmQ0ODBjNTViN2JkZWU1N2JjNGRlN2VkYzAyYQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2001-12-09T16:33:44Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2001-12-09T16:33:44Z"}, "message": "re PR c++/87 (member template assignment operator)\n\ncp:\n\tPR g++/87\n\t* cp-tree.h (DECL_COPY_CONSTRUCTOR_P): Use copy_fn_p.\n\t(copy_args_p): Rename to ...\n\t(copy_fn_p): ... here.\n\t(grok_special_member_properties): New function.\n\t(grok_op_properties): Lose VIRTUALP parameter.\n\t(copy_assignment_arg_p): Remove.\n\t* call.c (build_over_call): Use copy_fn_p.\n\t* decl.c (grokfndecl): Reformat. Adjust call to\n\tgrok_op_properties.\n\t(copy_args_p): Rename to ...\n\t(copy_fn_p): ... here. Reject template functions. Check for pass\n\tby value.\n\t(grok_special_member_properties): Remember special functions.\n\t(grok_ctor_properties): Don't remember them here, just check.\n\t(grok_op_properties): Likewise.\n\t(start_method): Call grok_special_member_properties.\n\t* decl2.c (grokfield): Likewise.\n\t(copy_assignment_arg_p): Remove.\n\t(grok_function_init): Don't remember abstract assignment here.\n\t* pt.c (instantiate_class_template): Call\n\tgrok_special_member_properties.\n\t(tsubst_decl): Adjust grok_op_properties call.\ntestsuite:\n\t* g++.dg/other/copy1.C: New test.\n\nFrom-SVN: r47813", "tree": {"sha": "47497fa5c9fd195f980d2e24398c007ac46ceca9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/47497fa5c9fd195f980d2e24398c007ac46ceca9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/271e6f02a18b2d480c55b7bdee57bc4de7edc02a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/271e6f02a18b2d480c55b7bdee57bc4de7edc02a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/271e6f02a18b2d480c55b7bdee57bc4de7edc02a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/271e6f02a18b2d480c55b7bdee57bc4de7edc02a/comments", "author": null, "committer": null, "parents": [{"sha": "b3656137984c755671e79da32c66379c0a4d2425", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3656137984c755671e79da32c66379c0a4d2425", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3656137984c755671e79da32c66379c0a4d2425"}], "stats": {"total": 406, "additions": 256, "deletions": 150}, "files": [{"sha": "ea344c45e7615e16166d0fb8e6595972f7bee1cd", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/271e6f02a18b2d480c55b7bdee57bc4de7edc02a/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/271e6f02a18b2d480c55b7bdee57bc4de7edc02a/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=271e6f02a18b2d480c55b7bdee57bc4de7edc02a", "patch": "@@ -1,3 +1,29 @@\n+2001-12-04  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR g++/87\n+\t* cp-tree.h (DECL_COPY_CONSTRUCTOR_P): Use copy_fn_p.\n+\t(copy_args_p): Rename to ...\n+\t(copy_fn_p): ... here.\n+\t(grok_special_member_properties): New function.\n+\t(grok_op_properties): Lose VIRTUALP parameter.\n+\t(copy_assignment_arg_p): Remove.\n+\t* call.c (build_over_call): Use copy_fn_p.\n+\t* decl.c (grokfndecl): Reformat. Adjust call to\n+\tgrok_op_properties.\n+\t(copy_args_p): Rename to ...\n+\t(copy_fn_p): ... here. Reject template functions. Check for pass\n+\tby value.\n+\t(grok_special_member_properties): Remember special functions.\n+\t(grok_ctor_properties): Don't remember them here, just check.\n+\t(grok_op_properties): Likewise.\n+\t(start_method): Call grok_special_member_properties.\n+\t* decl2.c (grokfield): Likewise.\n+\t(copy_assignment_arg_p): Remove.\n+\t(grok_function_init): Don't remember abstract assignment here.\n+\t* pt.c (instantiate_class_template): Call\n+\tgrok_special_member_properties.\n+\t(tsubst_decl): Adjust grok_op_properties call.\n+\n 2001-12-08  Aldy Hernandez  <aldyh@redhat.com>\n \n         * lex.c (rid_to_yy): Add RID_CHOOSE_EXPR and"}, {"sha": "21049b8b3ef3c14bb12e0fefc18ac1005809d2b9", "filename": "gcc/cp/call.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/271e6f02a18b2d480c55b7bdee57bc4de7edc02a/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/271e6f02a18b2d480c55b7bdee57bc4de7edc02a/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=271e6f02a18b2d480c55b7bdee57bc4de7edc02a", "patch": "@@ -4280,7 +4280,7 @@ build_over_call (cand, args, flags)\n \t}\n     }\n   else if (DECL_OVERLOADED_OPERATOR_P (fn) == NOP_EXPR\n-\t   && copy_args_p (fn)\n+\t   && copy_fn_p (fn)\n \t   && TYPE_HAS_TRIVIAL_ASSIGN_REF (DECL_CONTEXT (fn)))\n     {\n       tree to = stabilize_reference"}, {"sha": "6172adf261770193a3b8e537a6c1781190d12e30", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/271e6f02a18b2d480c55b7bdee57bc4de7edc02a/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/271e6f02a18b2d480c55b7bdee57bc4de7edc02a/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=271e6f02a18b2d480c55b7bdee57bc4de7edc02a", "patch": "@@ -1841,7 +1841,7 @@ struct lang_decl\n \n /* Nonzero if NODE (a FUNCTION_DECL) is a copy constructor.  */\n #define DECL_COPY_CONSTRUCTOR_P(NODE) \\\n-  (DECL_CONSTRUCTOR_P (NODE) && copy_args_p (NODE))\n+  (DECL_CONSTRUCTOR_P (NODE) && copy_fn_p (NODE) > 0)\n \n /* Nonzero if NODE is a destructor.  */\n #define DECL_DESTRUCTOR_P(NODE)\t\t\t\t\\\n@@ -3690,9 +3690,10 @@ extern int complete_array_type\t\t\tPARAMS ((tree, tree, int));\n extern tree build_ptrmemfunc_type\t\tPARAMS ((tree));\n /* the grokdeclarator prototype is in decl.h */\n extern int parmlist_is_exprlist\t\t\tPARAMS ((tree));\n-extern int copy_args_p\t\t\t\tPARAMS ((tree));\n+extern int copy_fn_p\t\t\t\tPARAMS ((tree));\n+extern void grok_special_member_properties\tPARAMS ((tree));\n extern int grok_ctor_properties\t\t\tPARAMS ((tree, tree));\n-extern void grok_op_properties\t\t\tPARAMS ((tree, int, int));\n+extern void grok_op_properties\t\t\tPARAMS ((tree, int));\n extern tree xref_tag\t\t\t\tPARAMS ((tree, tree, int));\n extern tree xref_tag_from_type\t\t\tPARAMS ((tree, tree, int));\n extern void xref_basetypes\t\t\tPARAMS ((tree, tree, tree, tree));\n@@ -3757,7 +3758,6 @@ extern tree grokfield\t\t\t\tPARAMS ((tree, tree, tree, tree, tree));\n extern tree grokbitfield\t\t\tPARAMS ((tree, tree, tree));\n extern tree groktypefield\t\t\tPARAMS ((tree, tree));\n extern tree grokoptypename\t\t\tPARAMS ((tree, tree));\n-extern int copy_assignment_arg_p\t\tPARAMS ((tree, int));\n extern void cplus_decl_attributes\t\tPARAMS ((tree *, tree, int));\n extern tree constructor_name_full\t\tPARAMS ((tree));\n extern tree constructor_name\t\t\tPARAMS ((tree));"}, {"sha": "26d3a2499edf132c082bdf22790b53cab1b6cb05", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 131, "deletions": 110, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/271e6f02a18b2d480c55b7bdee57bc4de7edc02a/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/271e6f02a18b2d480c55b7bdee57bc4de7edc02a/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=271e6f02a18b2d480c55b7bdee57bc4de7edc02a", "patch": "@@ -8789,9 +8789,7 @@ grokfndecl (ctype, type, declarator, orig_declarator, virtualp, flags, quals,\n   tree t;\n \n   if (raises)\n-    {\n-      type = build_exception_variant (type, raises);\n-    }\n+    type = build_exception_variant (type, raises);\n \n   decl = build_lang_decl (FUNCTION_DECL, declarator, type);\n   /* Propagate volatile out from type to decl. */\n@@ -8902,7 +8900,7 @@ grokfndecl (ctype, type, declarator, orig_declarator, virtualp, flags, quals,\n     }\n \n   if (IDENTIFIER_OPNAME_P (DECL_NAME (decl)))\n-    grok_op_properties (decl, virtualp, check < 0);\n+    grok_op_properties (decl, friendp);\n \n   if (ctype && decl_function_context (decl))\n     DECL_NO_STATIC_CHAIN (decl) = 1;\n@@ -12053,90 +12051,150 @@ grokparms (first_parm)\n }\n \n \f\n-/* D is a constructor or overloaded `operator='.  Returns non-zero if\n-   D's arguments allow it to be a copy constructor, or copy assignment\n+/* D is a constructor or overloaded `operator='.\n+\n+   Let T be the class in which D is declared. Then, this function\n+   returns:\n+\n+   -1 if D's is an ill-formed constructor or copy assignment operator\n+      whose first parameter is of type `T'.\n+   0  if D is not a copy constructor or copy assignment\n+      operator.\n+   1  if D is a copy constructor or copy assignment operator whose\n+      first parameter is a reference to const qualified T.\n+   2  if D is a copy constructor or copy assignment operator whose\n+      first parameter is a reference to non-const qualified T.\n+\n+   This function can be used as a predicate. Positive values indicate\n+   a copy constructor and non-zero values indicate a copy assignment\n    operator.  */\n \n int\n-copy_args_p (d)\n+copy_fn_p (d)\n      tree d;\n {\n-  tree t;\n+  tree args;\n+  tree arg_type;\n+  int result = 1;\n+  \n+  my_friendly_assert (DECL_FUNCTION_MEMBER_P (d), 20011208);\n \n-  if (!DECL_FUNCTION_MEMBER_P (d))\n+  if (DECL_TEMPLATE_INFO (d) && is_member_template (DECL_TI_TEMPLATE (d)))\n+    /* Instantiations of template member functions are never copy\n+       functions.  Note that member functions of templated classes are\n+       represented as template functions internally, and we must\n+       accept those as copy functions.  */\n+    return 0;\n+    \n+  args = FUNCTION_FIRST_USER_PARMTYPE (d);\n+  if (!args)\n     return 0;\n \n-  t = FUNCTION_FIRST_USER_PARMTYPE (d);\n-  if (t && TREE_CODE (TREE_VALUE (t)) == REFERENCE_TYPE\n-      && (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_VALUE (t)))\n-\t  == DECL_CONTEXT (d))\n-      && (TREE_CHAIN (t) == NULL_TREE\n-\t  || TREE_CHAIN (t) == void_list_node\n-\t  || TREE_PURPOSE (TREE_CHAIN (t))))\n-    return 1;\n-  return 0;\n+  arg_type = TREE_VALUE (args);\n+\n+  if (TYPE_MAIN_VARIANT (arg_type) == DECL_CONTEXT (d))\n+    {\n+      /* Pass by value copy assignment operator.  */\n+      result = -1;\n+    }\n+  else if (TREE_CODE (arg_type) == REFERENCE_TYPE\n+\t   && TYPE_MAIN_VARIANT (TREE_TYPE (arg_type)) == DECL_CONTEXT (d))\n+    {\n+      if (CP_TYPE_CONST_P (TREE_TYPE (arg_type)))\n+\tresult = 2;\n+    }\n+  else\n+    return 0;\n+  \n+  args = TREE_CHAIN (args);\n+\n+  if (args && args != void_list_node && !TREE_PURPOSE (args))\n+    /* There are more non-optional args.  */\n+    return 0;\n+\n+  return result;\n }\n \n-/* These memoizing functions keep track of special properties which\n-   a class may have.  `grok_ctor_properties' notices whether a class\n-   has a constructor of the form X(X&), and also complains\n-   if the class has a constructor of the form X(X).\n-   `grok_op_properties' takes notice of the various forms of\n-   operator= which are defined, as well as what sorts of type conversion\n-   may apply.  Both functions take a FUNCTION_DECL as an argument.  */\n+/* Remember any special properties of member function DECL.  */\n+\n+void grok_special_member_properties (decl)\n+     tree decl;\n+{\n+  if (!DECL_NONSTATIC_MEMBER_FUNCTION_P(decl))\n+    ; /* Not special.  */\n+  else if (DECL_CONSTRUCTOR_P (decl))\n+    {\n+      int ctor = copy_fn_p (decl);\n+      \n+      if (ctor > 0)\n+\t{\n+\t  /* [class.copy]\n+\t      \n+     \t     A non-template constructor for class X is a copy\n+     \t     constructor if its first parameter is of type X&, const\n+     \t     X&, volatile X& or const volatile X&, and either there\n+     \t     are no other parameters or else all other parameters have\n+     \t     default arguments.  */\n+\t  TYPE_HAS_INIT_REF (DECL_CONTEXT (decl)) = 1;\n+\t  if (ctor > 1)\n+\t    TYPE_HAS_CONST_INIT_REF (DECL_CONTEXT (decl)) = 1;\n+\t}\n+      else if (sufficient_parms_p (FUNCTION_FIRST_USER_PARMTYPE (decl)))\n+\tTYPE_HAS_DEFAULT_CONSTRUCTOR (DECL_CONTEXT (decl)) = 1;\n+    }\n+  else if (DECL_OVERLOADED_OPERATOR_P (decl) == NOP_EXPR)\n+    {\n+      /* [class.copy]\n+\t  \n+     \t A non-template assignment operator for class X is a copy\n+     \t assignment operator if its parameter is of type X, X&, const\n+     \t X&, volatile X& or const volatile X&.  */\n+      \n+      int assop = copy_fn_p (decl);\n+      \n+      if (assop)\n+\t{\n+\t  TYPE_HAS_ASSIGN_REF (DECL_CONTEXT (decl)) = 1;\n+\t  if (assop != 1)\n+\t    TYPE_HAS_CONST_ASSIGN_REF (DECL_CONTEXT (decl)) = 1;\n+\t  if (DECL_PURE_VIRTUAL_P (decl))\n+\t    TYPE_HAS_ABSTRACT_ASSIGN_REF (DECL_CONTEXT (decl)) = 1;\n+\t}\n+    }\n+}\n+\n+/* Check a constructor DECL has the correct form.  Complains\n+   if the class has a constructor of the form X(X).  */\n \n int\n grok_ctor_properties (ctype, decl)\n      tree ctype, decl;\n {\n-  tree parmtypes = FUNCTION_FIRST_USER_PARMTYPE (decl);\n-  tree parmtype = parmtypes ? TREE_VALUE (parmtypes) : void_type_node;\n-\n-  /* [class.copy]\n-\n-     A non-template constructor for class X is a copy constructor if\n-     its first parameter is of type X&, const X&, volatile X& or const\n-     volatile X&, and either there are no other parameters or else all\n-     other parameters have default arguments.  */\n-  if (TREE_CODE (parmtype) == REFERENCE_TYPE\n-      && TYPE_MAIN_VARIANT (TREE_TYPE (parmtype)) == ctype\n-      && sufficient_parms_p (TREE_CHAIN (parmtypes))\n-      && !(DECL_TEMPLATE_INSTANTIATION (decl)\n-\t   && is_member_template (DECL_TI_TEMPLATE (decl))))\n-    {\n-      TYPE_HAS_INIT_REF (ctype) = 1;\n-      if (CP_TYPE_CONST_P (TREE_TYPE (parmtype)))\n-\tTYPE_HAS_CONST_INIT_REF (ctype) = 1;\n-    }\n-  /* [class.copy]\n-\n-     A declaration of a constructor for a class X is ill-formed if its\n-     first parameter is of type (optionally cv-qualified) X and either\n-     there are no other parameters or else all other parameters have\n-     default arguments.\n-\n-     We *don't* complain about member template instantiations that\n-     have this form, though; they can occur as we try to decide what\n-     constructor to use during overload resolution.  Since overload\n-     resolution will never prefer such a constructor to the\n-     non-template copy constructor (which is either explicitly or\n-     implicitly defined), there's no need to worry about their\n-     existence.  Theoretically, they should never even be\n-     instantiated, but that's hard to forestall.  */\n-  else if (TYPE_MAIN_VARIANT (parmtype) == ctype\n-\t   && sufficient_parms_p (TREE_CHAIN (parmtypes))\n-\t   && !(DECL_TEMPLATE_INSTANTIATION (decl)\n-\t\t&& is_member_template (DECL_TI_TEMPLATE (decl))))\n-    {\n+  int ctor_parm = copy_fn_p (decl);\n+\n+  if (ctor_parm < 0)\n+    {\n+      /* [class.copy]\n+\t  \n+     \t A declaration of a constructor for a class X is ill-formed if\n+     \t its first parameter is of type (optionally cv-qualified) X\n+     \t and either there are no other parameters or else all other\n+     \t parameters have default arguments.\n+\t  \n+     \t We *don't* complain about member template instantiations that\n+     \t have this form, though; they can occur as we try to decide\n+     \t what constructor to use during overload resolution.  Since\n+     \t overload resolution will never prefer such a constructor to\n+     \t the non-template copy constructor (which is either explicitly\n+     \t or implicitly defined), there's no need to worry about their\n+     \t existence.  Theoretically, they should never even be\n+     \t instantiated, but that's hard to forestall.  */\n       cp_error (\"invalid constructor; you probably meant `%T (const %T&)'\",\n \t\tctype, ctype);\n       SET_IDENTIFIER_ERROR_LOCUS (DECL_NAME (decl), ctype);\n       return 0;\n     }\n-  else if (TREE_CODE (parmtype) == VOID_TYPE\n-\t   || TREE_PURPOSE (parmtypes) != NULL_TREE)\n-    TYPE_HAS_DEFAULT_CONSTRUCTOR (ctype) = 1;\n-\n+  \n   return 1;\n }\n \n@@ -12169,9 +12227,9 @@ unary_op_p (code)\n /* Do a little sanity-checking on how they declared their operator.  */\n \n void\n-grok_op_properties (decl, virtualp, friendp)\n+grok_op_properties (decl, friendp)\n      tree decl;\n-     int virtualp, friendp;\n+     int friendp;\n {\n   tree argtypes = TYPE_ARG_TYPES (TREE_TYPE (decl));\n   tree argtype;\n@@ -12341,37 +12399,7 @@ grok_op_properties (decl, virtualp, friendp)\n \t\t\t ref ? \"a reference to \" : \"\", what);\n \t    }\n \t}\n-\n-      if (DECL_ASSIGNMENT_OPERATOR_P (decl)\n-\t  && operator_code == NOP_EXPR)\n-\t{\n-\t  tree parmtype;\n-\n-\t  if (arity != 2 && methodp)\n-\t    {\n-\t      cp_error (\"`%D' must take exactly one argument\", decl);\n-\t      return;\n-\t    }\n-\t  parmtype = TREE_VALUE (TREE_CHAIN (argtypes));\n-\n-\t  /* [class.copy]\n-\n-\t     A user-declared copy assignment operator X::operator= is\n-\t     a non-static non-template member function of class X with\n-\t     exactly one parameter of type X, X&, const X&, volatile\n-\t     X& or const volatile X&.  */\n-\t  if (copy_assignment_arg_p (parmtype, virtualp)\n-\t      && !(DECL_TEMPLATE_INSTANTIATION (decl)\n-\t\t   && is_member_template (DECL_TI_TEMPLATE (decl)))\n-\t      && ! friendp)\n-\t    {\n-\t      TYPE_HAS_ASSIGN_REF (current_class_type) = 1;\n-\t      if (TREE_CODE (parmtype) != REFERENCE_TYPE\n-\t\t  || CP_TYPE_CONST_P (TREE_TYPE (parmtype)))\n-\t\tTYPE_HAS_CONST_ASSIGN_REF (current_class_type) = 1;\n-\t    }\n-\t}\n-      else if (operator_code == COND_EXPR)\n+      if (operator_code == COND_EXPR)\n \t{\n \t  /* 13.4.0.3 */\n \t  cp_error (\"ISO C++ prohibits overloading operator ?:\");\n@@ -12507,7 +12535,7 @@ grok_op_properties (decl, virtualp, friendp)\n \t  && TREE_CODE (TREE_TYPE (TREE_TYPE (decl))) == REFERENCE_TYPE)\n \tcp_warning (\"`%D' should return by value\", decl);\n \n-      /* 13.4.0.8 */\n+      /* [over.oper]/8 */\n       for (; argtypes && argtypes != void_list_node;\n           argtypes = TREE_CHAIN (argtypes))\n         if (TREE_PURPOSE (argtypes))\n@@ -14244,14 +14272,7 @@ start_method (declspecs, declarator, attrlist)\n \t  fndecl = copy_node (fndecl);\n \t  TREE_CHAIN (fndecl) = NULL_TREE;\n \t}\n-\n-      if (DECL_CONSTRUCTOR_P (fndecl))\n-\t{\n-\t  if (! grok_ctor_properties (current_class_type, fndecl))\n-\t    return void_type_node;\n-\t}\n-      else if (IDENTIFIER_OPNAME_P (DECL_NAME (fndecl)))\n-\tgrok_op_properties (fndecl, DECL_VIRTUAL_P (fndecl), 0);\n+      grok_special_member_properties (fndecl);\n     }\n \n   cp_finish_decl (fndecl, NULL_TREE, NULL_TREE, 0);"}, {"sha": "e625d963651896182836856811d9f17e38bc589f", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 4, "deletions": 33, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/271e6f02a18b2d480c55b7bdee57bc4de7edc02a/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/271e6f02a18b2d480c55b7bdee57bc4de7edc02a/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=271e6f02a18b2d480c55b7bdee57bc4de7edc02a", "patch": "@@ -1645,6 +1645,9 @@ grokfield (declarator, declspecs, init, asmspec_tree, attrlist)\n \t  SET_DECL_RTL (value, NULL_RTX);\n \t  SET_DECL_ASSEMBLER_NAME (value, get_identifier (asmspec));\n \t}\n+      if (!DECL_FRIEND_P (value))\n+\tgrok_special_member_properties (value);\n+      \n       cp_finish_decl (value, init, asmspec_tree, flags);\n \n       /* Pass friends back this way.  */\n@@ -1762,28 +1765,6 @@ grokoptypename (declspecs, declarator)\n \n */\n \n-int\n-copy_assignment_arg_p (parmtype, virtualp)\n-     tree parmtype;\n-     int virtualp ATTRIBUTE_UNUSED;\n-{\n-  if (current_class_type == NULL_TREE)\n-    return 0;\n-\n-  if (TREE_CODE (parmtype) == REFERENCE_TYPE)\n-    parmtype = TREE_TYPE (parmtype);\n-\n-  if ((TYPE_MAIN_VARIANT (parmtype) == current_class_type)\n-#if 0\n-      /* Non-standard hack to support old Booch components.  */\n-      || (! virtualp && DERIVED_FROM_P (parmtype, current_class_type))\n-#endif\n-      )\n-    return 1;\n-\n-  return 0;\n-}\n-\n static void\n grok_function_init (decl, init)\n      tree decl;\n@@ -1796,17 +1777,7 @@ grok_function_init (decl, init)\n   if (TREE_CODE (type) == FUNCTION_TYPE)\n     cp_error (\"initializer specified for non-member function `%D'\", decl);\n   else if (integer_zerop (init))\n-    {\n-      DECL_PURE_VIRTUAL_P (decl) = 1;\n-      if (DECL_OVERLOADED_OPERATOR_P (decl) == NOP_EXPR)\n-\t{\n-\t  tree parmtype\n-\t    = TREE_VALUE (TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (decl))));\n-\n-\t  if (copy_assignment_arg_p (parmtype, 1))\n-\t    TYPE_HAS_ABSTRACT_ASSIGN_REF (current_class_type) = 1;\n-\t}\n-    }\n+    DECL_PURE_VIRTUAL_P (decl) = 1;\n   else\n     cp_error (\"invalid initializer for virtual method `%D'\", decl);\n }"}, {"sha": "48f39518ab4976dad9c3d7acce63af38e5392e52", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/271e6f02a18b2d480c55b7bdee57bc4de7edc02a/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/271e6f02a18b2d480c55b7bdee57bc4de7edc02a/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=271e6f02a18b2d480c55b7bdee57bc4de7edc02a", "patch": "@@ -5186,6 +5186,7 @@ instantiate_class_template (type)\n     {\n       tree r = tsubst (t, args, /*complain=*/1, NULL_TREE);\n       set_current_access_from_decl (r);\n+      grok_special_member_properties (r);\n       finish_member_declaration (r);\n     }\n \n@@ -5895,10 +5896,10 @@ tsubst_decl (t, args, type)\n \t       If it isn't, that'll be handled by\n \t       clone_constructors_and_destructors.  */\n \t    if (PRIMARY_TEMPLATE_P (gen_tmpl))\n-\t      clone_function_decl(r, /*update_method_vec_p=*/0);\n+\t      clone_function_decl (r, /*update_method_vec_p=*/0);\n \t  }\n \telse if (IDENTIFIER_OPNAME_P (DECL_NAME (r)))\n-\t  grok_op_properties (r, DECL_VIRTUAL_P (r), DECL_FRIEND_P (r));\n+\t  grok_op_properties (r, DECL_FRIEND_P (r));\n       }\n       break;\n "}, {"sha": "9c774301cb92360eeb3ba7eff20278fc20b765ea", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/271e6f02a18b2d480c55b7bdee57bc4de7edc02a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/271e6f02a18b2d480c55b7bdee57bc4de7edc02a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=271e6f02a18b2d480c55b7bdee57bc4de7edc02a", "patch": "@@ -1,3 +1,7 @@\n+2001-12-09  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* g++.dg/other/copy1.C: New test.\n+\n 2001-10-08  Aldy Hernandez  <aldyh@redhat.com>\n \n         * gcc.c-torture/execute/builtin-types-compatible-p.c: New."}, {"sha": "d02b08fce092888ed45a18a68b44ff728b0afb2c", "filename": "gcc/testsuite/g++.dg/other/copy1.C", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/271e6f02a18b2d480c55b7bdee57bc4de7edc02a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fcopy1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/271e6f02a18b2d480c55b7bdee57bc4de7edc02a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fcopy1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fcopy1.C?ref=271e6f02a18b2d480c55b7bdee57bc4de7edc02a", "patch": "@@ -0,0 +1,83 @@\n+// { dg-do run }\n+\n+// Copyright (C) 2000 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 30 Nov 2001 <nathan@nathan@codesourcery.com>\n+\n+// PR 87\n+\n+int assign = 0;\n+int ctor = 0;\n+int assignC = 0;\n+\n+struct A {\n+  int i;\n+\n+  template<class T>\n+  void operator=(const T&) const\n+  { \n+    assign = 1;\n+  }\n+\n+  A () : i (0) {}\n+  \n+  template <typename T> A (const T &)\n+  {\n+    ctor = 1;\n+  }\n+};\n+\n+struct B : A \n+{\n+};\n+\n+struct C \n+{\n+  int i;\n+\n+  C (int i_) :i (i_) {}\n+  \n+  template <int I>\n+  void operator= (const C &)\n+  {\n+    assignC = 1;\n+  }\n+};\n+\n+\n+int main()\n+{\n+  const A a;\n+  A b;\n+  B c;\n+\n+  b = a;\n+  if (assign)\n+    return 5;\n+  \n+  b.i = 100;\n+  c.i = 200;\n+  \n+  a = b; \n+\n+  if (!assign)\n+    return 1;\n+  if (a.i)\n+    return 2;\n+\n+  A e (b);\n+  if (ctor)\n+    return 3;\n+  \n+  A d (c);\n+  if (!ctor)\n+    return 4;\n+\n+  C c0 (0);\n+  C c1 (1);\n+\n+  c0 = c1;\n+  if (assignC)\n+    return 5;\n+  \n+  return 0;\n+}"}]}