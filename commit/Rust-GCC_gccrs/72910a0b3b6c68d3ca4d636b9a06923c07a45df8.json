{"sha": "72910a0b3b6c68d3ca4d636b9a06923c07a45df8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzI5MTBhMGIzYjZjNjhkM2NhNGQ2MzZiOWEwNjkyM2MwN2E0NWRmOA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2005-01-20T03:59:00Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-01-20T03:59:00Z"}, "message": "re PR target/19518 ([alpha] unrecognizable insn (set (reg:V4HI) (const_vector:V4HI)) with builtins)\n\n        PR target/19518\n        * config/alpha/alpha.c (alpha_rtx_costs): Handle HIGH.\n        (alpha_preferred_reload_class): Handle CONST_VECTOR.\n        (alpha_emit_set_const_1): Add no_output parameter; don't emit\n        rtl if true.\n        (alpha_emit_set_const): Likewise.  Make static.\n        (alpha_emit_set_long_const): Make static.\n        (alpha_extract_integer): Split out from alpha_expand_mov.\n        (alpha_split_const_mov): Likewise.\n        (alpha_expand_mov): Use them.  Handle CONST_VECTOR.\n        (alpha_legitimate_constant_p): New.\n        * config/alpha/alpha-protos.h: Update.\n        * config/alpha/alpha.h (REGISTER_MOVE_COST): Correct fp<->gp cost.\n        (LEGITIMATE_CONSTANT_P): Re-implement with a function.\n        * config/alpha/alpha.md (movsi): Add n alternative.\n        (movsi_nt_vms, movdi_er_nofix, movdi_er_fix, movdi_fix): Likewise.\n        (mov<VEC>_fix, mov<VEC>_nofix): Add i alternative.\n        (splitters for all of the above): Use alpha_split_const_mov.\n        * config/alpha/predicates.md (non_add_const_operand): New.\n        (non_zero_const_operand): New.\n        (input_operand): Use alpha_legitimate_constant_p after reload.\n\nFrom-SVN: r93943", "tree": {"sha": "cda4b7c4fa5fd8c63fdd336bd609206fd5423cd2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cda4b7c4fa5fd8c63fdd336bd609206fd5423cd2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/72910a0b3b6c68d3ca4d636b9a06923c07a45df8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72910a0b3b6c68d3ca4d636b9a06923c07a45df8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72910a0b3b6c68d3ca4d636b9a06923c07a45df8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72910a0b3b6c68d3ca4d636b9a06923c07a45df8/comments", "author": null, "committer": null, "parents": [{"sha": "ae7271294d9e2aeba1b08f7e3871c1ce7fa36dd8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae7271294d9e2aeba1b08f7e3871c1ce7fa36dd8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae7271294d9e2aeba1b08f7e3871c1ce7fa36dd8"}], "stats": {"total": 603, "additions": 460, "deletions": 143}, "files": [{"sha": "540ad52fe0612742996b3ebe13594e04bed25a4b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72910a0b3b6c68d3ca4d636b9a06923c07a45df8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72910a0b3b6c68d3ca4d636b9a06923c07a45df8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=72910a0b3b6c68d3ca4d636b9a06923c07a45df8", "patch": "@@ -1,3 +1,27 @@\n+2005-01-19  Richard Henderson  <rth@redhat.com>\n+\n+\tPR target/19518\n+\t* config/alpha/alpha.c (alpha_rtx_costs): Handle HIGH.\n+\t(alpha_preferred_reload_class): Handle CONST_VECTOR.\n+\t(alpha_emit_set_const_1): Add no_output parameter; don't emit\n+\trtl if true.\n+\t(alpha_emit_set_const): Likewise.  Make static.\n+\t(alpha_emit_set_long_const): Make static.\n+\t(alpha_extract_integer): Split out from alpha_expand_mov.\n+\t(alpha_split_const_mov): Likewise.\n+\t(alpha_expand_mov): Use them.  Handle CONST_VECTOR.\n+\t(alpha_legitimate_constant_p): New.\n+\t* config/alpha/alpha-protos.h: Update.\n+\t* config/alpha/alpha.h (REGISTER_MOVE_COST): Correct fp<->gp cost.\n+\t(LEGITIMATE_CONSTANT_P): Re-implement with a function.\n+\t* config/alpha/alpha.md (movsi): Add n alternative.\n+\t(movsi_nt_vms, movdi_er_nofix, movdi_er_fix, movdi_fix): Likewise.\n+\t(mov<VEC>_fix, mov<VEC>_nofix): Add i alternative.\n+\t(splitters for all of the above): Use alpha_split_const_mov.\n+\t* config/alpha/predicates.md (non_add_const_operand): New.\n+\t(non_zero_const_operand): New.\n+\t(input_operand): Use alpha_legitimate_constant_p after reload.\n+\n 2005-01-19  Zdenek Dvorak  <dvorakz@suse.cz>\n \n \tPR tree-optimization/19038"}, {"sha": "d1ffada3dcfa3fc5518816c6a567604710fafbbe", "filename": "gcc/config/alpha/alpha-protos.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72910a0b3b6c68d3ca4d636b9a06923c07a45df8/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72910a0b3b6c68d3ca4d636b9a06923c07a45df8/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha-protos.h?ref=72910a0b3b6c68d3ca4d636b9a06923c07a45df8", "patch": "@@ -42,6 +42,7 @@ extern bool alpha_extra_constraint (rtx, int);\n extern rtx alpha_tablejump_addr_vec (rtx);\n extern rtx alpha_tablejump_best_label (rtx);\n \n+extern bool alpha_legitimate_constant_p (rtx);\n extern bool alpha_legitimate_address_p (enum machine_mode, rtx, int);\n extern rtx alpha_legitimize_address (rtx, rtx, enum machine_mode);\n extern rtx alpha_legitimize_reload_address (rtx, enum machine_mode,\n@@ -56,8 +57,7 @@ extern enum reg_class secondary_reload_class (enum reg_class,\n \t\t\t\t\t      enum machine_mode, rtx, int);\n \n extern void alpha_set_memflags (rtx, rtx);\n-extern rtx alpha_emit_set_const (rtx, enum machine_mode, HOST_WIDE_INT, int);\n-extern rtx alpha_emit_set_long_const (rtx, HOST_WIDE_INT, HOST_WIDE_INT);\n+extern bool alpha_split_const_mov (enum machine_mode, rtx *);\n extern bool alpha_expand_mov (enum machine_mode, rtx *);\n extern bool alpha_expand_mov_nobwx (enum machine_mode, rtx *);\n extern void alpha_expand_movmisalign (enum machine_mode, rtx *);"}, {"sha": "037dc4ad33e70bcd3912f0f505bf37b7c3bab976", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 252, "deletions": 90, "changes": 342, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72910a0b3b6c68d3ca4d636b9a06923c07a45df8/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72910a0b3b6c68d3ca4d636b9a06923c07a45df8/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=72910a0b3b6c68d3ca4d636b9a06923c07a45df8", "patch": "@@ -1384,6 +1384,11 @@ alpha_rtx_costs (rtx x, int code, int outer_code, int *total)\n \t*total = COSTS_N_INSNS (optimize_size ? 1 : alpha_memory_latency);\n       return true;\n \n+    case HIGH:\n+      /* This is effectively an add_operand.  */\n+      *total = 2;\n+      return true;\n+\n     case PLUS:\n     case MINUS:\n       if (float_mode_p)\n@@ -1557,7 +1562,9 @@ alpha_preferred_reload_class(rtx x, enum reg_class class)\n     return class;\n \n   /* These sorts of constants we can easily drop to memory.  */\n-  if (GET_CODE (x) == CONST_INT || GET_CODE (x) == CONST_DOUBLE)\n+  if (GET_CODE (x) == CONST_INT\n+      || GET_CODE (x) == CONST_DOUBLE\n+      || GET_CODE (x) == CONST_VECTOR)\n     {\n       if (class == FLOAT_REGS)\n \treturn NO_REGS;\n@@ -1679,11 +1686,16 @@ alpha_set_memflags (rtx insn, rtx ref)\n   for_each_rtx (base_ptr, alpha_set_memflags_1, (void *) ref);\n }\n \f\n-/* Internal routine for alpha_emit_set_const to check for N or below insns.  */\n+static rtx alpha_emit_set_const (rtx, enum machine_mode, HOST_WIDE_INT,\n+\t\t\t\t int, bool);\n+\n+/* Internal routine for alpha_emit_set_const to check for N or below insns.\n+   If NO_OUTPUT is true, then we only check to see if N insns are possible,\n+   and return pc_rtx if successful.  */\n \n static rtx\n alpha_emit_set_const_1 (rtx target, enum machine_mode mode,\n-\t\t\tHOST_WIDE_INT c, int n)\n+\t\t\tHOST_WIDE_INT c, int n, bool no_output)\n {\n   HOST_WIDE_INT new;\n   int i, bits;\n@@ -1722,13 +1734,17 @@ alpha_emit_set_const_1 (rtx target, enum machine_mode mode,\n \t     emit_move_insn to gen_movdi.  So instead, since we know exactly\n \t     what we want, create it explicitly.  */\n \n+\t  if (no_output)\n+\t    return pc_rtx;\n \t  if (target == NULL)\n \t    target = gen_reg_rtx (mode);\n \t  emit_insn (gen_rtx_SET (VOIDmode, target, GEN_INT (c)));\n \t  return target;\n \t}\n       else if (n >= 2 + (extra != 0))\n \t{\n+\t  if (no_output)\n+\t    return pc_rtx;\n \t  if (no_new_pseudos)\n \t    {\n \t      emit_insn (gen_rtx_SET (VOIDmode, target, GEN_INT (high << 16)));\n@@ -1781,14 +1797,26 @@ alpha_emit_set_const_1 (rtx target, enum machine_mode mode,\n \t high bits.  */\n \n       new = ((c & 0xffff) ^ 0x8000) - 0x8000;\n-      if (new != 0\n-          && (temp = alpha_emit_set_const (subtarget, mode, c - new, i)) != 0)\n-\treturn expand_binop (mode, add_optab, temp, GEN_INT (new),\n-\t\t\t     target, 0, OPTAB_WIDEN);\n+      if (new != 0)\n+\t{\n+          temp = alpha_emit_set_const (subtarget, mode, c - new, i, no_output);\n+\t  if (temp)\n+\t    {\n+\t      if (no_output)\n+\t\treturn temp;\n+\t      return expand_binop (mode, add_optab, temp, GEN_INT (new),\n+\t\t\t\t   target, 0, OPTAB_WIDEN);\n+\t    }\n+\t}\n \n       /* Next try complementing.  */\n-      if ((temp = alpha_emit_set_const (subtarget, mode, ~ c, i)) != 0)\n-\treturn expand_unop (mode, one_cmpl_optab, temp, target, 0);\n+      temp = alpha_emit_set_const (subtarget, mode, ~c, i, no_output);\n+      if (temp)\n+\t{\n+\t  if (no_output)\n+\t    return temp;\n+\t  return expand_unop (mode, one_cmpl_optab, temp, target, 0);\n+\t}\n \n       /* Next try to form a constant and do a left shift.  We can do this\n \t if some low-order bits are zero; the exact_log2 call below tells\n@@ -1799,52 +1827,80 @@ alpha_emit_set_const_1 (rtx target, enum machine_mode mode,\n \t bits to shift, but try all possibilities in case a ZAPNOT will\n \t be useful.  */\n \n-      if ((bits = exact_log2 (c & - c)) > 0)\n+      bits = exact_log2 (c & -c);\n+      if (bits > 0)\n \tfor (; bits > 0; bits--)\n-\t  if ((temp = (alpha_emit_set_const\n-\t\t       (subtarget, mode, c >> bits, i))) != 0\n-\t      || ((temp = (alpha_emit_set_const\n-\t\t\t  (subtarget, mode,\n-\t\t\t   ((unsigned HOST_WIDE_INT) c) >> bits, i)))\n-\t\t  != 0))\n-\t    return expand_binop (mode, ashl_optab, temp, GEN_INT (bits),\n-\t\t\t\t target, 0, OPTAB_WIDEN);\n+\t  {\n+\t    new = c >> bits;\n+\t    temp = alpha_emit_set_const (subtarget, mode, new, i, no_output);\n+\t    if (!temp && c < 0)\n+\t      {\n+\t\tnew = (unsigned HOST_WIDE_INT)c >> bits;\n+\t\ttemp = alpha_emit_set_const (subtarget, mode, new,\n+\t\t\t\t\t     i, no_output);\n+\t      }\n+\t    if (temp)\n+\t      {\n+\t\tif (no_output)\n+\t\t  return temp;\n+\t        return expand_binop (mode, ashl_optab, temp, GEN_INT (bits),\n+\t\t\t\t     target, 0, OPTAB_WIDEN);\n+\t      }\n+\t  }\n \n       /* Now try high-order zero bits.  Here we try the shifted-in bits as\n \t all zero and all ones.  Be careful to avoid shifting outside the\n \t mode and to avoid shifting outside the host wide int size.  */\n       /* On narrow hosts, don't shift a 1 into the high bit, since we'll\n \t confuse the recursive call and set all of the high 32 bits.  */\n \n-      if ((bits = (MIN (HOST_BITS_PER_WIDE_INT, GET_MODE_SIZE (mode) * 8)\n-\t\t   - floor_log2 (c) - 1 - (HOST_BITS_PER_WIDE_INT < 64))) > 0)\n+      bits = (MIN (HOST_BITS_PER_WIDE_INT, GET_MODE_SIZE (mode) * 8)\n+\t      - floor_log2 (c) - 1 - (HOST_BITS_PER_WIDE_INT < 64));\n+      if (bits > 0)\n \tfor (; bits > 0; bits--)\n-\t  if ((temp = alpha_emit_set_const (subtarget, mode,\n-\t\t\t\t\t    c << bits, i)) != 0\n-\t      || ((temp = (alpha_emit_set_const\n-\t\t\t   (subtarget, mode,\n-\t\t\t    ((c << bits) | (((HOST_WIDE_INT) 1 << bits) - 1)),\n-\t\t\t    i)))\n-\t\t  != 0))\n-\t    return expand_binop (mode, lshr_optab, temp, GEN_INT (bits),\n-\t\t\t\t target, 1, OPTAB_WIDEN);\n+\t  {\n+\t    new = c << bits;\n+\t    temp = alpha_emit_set_const (subtarget, mode, new, i, no_output);\n+\t    if (!temp)\n+\t      {\n+\t\tnew = (c << bits) | (((HOST_WIDE_INT) 1 << bits) - 1);\n+\t        temp = alpha_emit_set_const (subtarget, mode, new,\n+\t\t\t\t\t     i, no_output);\n+\t      }\n+\t    if (temp)\n+\t      {\n+\t\tif (no_output)\n+\t\t  return temp;\n+\t\treturn expand_binop (mode, lshr_optab, temp, GEN_INT (bits),\n+\t\t\t\t     target, 1, OPTAB_WIDEN);\n+\t      }\n+\t  }\n \n       /* Now try high-order 1 bits.  We get that with a sign-extension.\n \t But one bit isn't enough here.  Be careful to avoid shifting outside\n \t the mode and to avoid shifting outside the host wide int size.  */\n \n-      if ((bits = (MIN (HOST_BITS_PER_WIDE_INT, GET_MODE_SIZE (mode) * 8)\n-\t\t   - floor_log2 (~ c) - 2)) > 0)\n+      bits = (MIN (HOST_BITS_PER_WIDE_INT, GET_MODE_SIZE (mode) * 8)\n+\t      - floor_log2 (~ c) - 2);\n+      if (bits > 0)\n \tfor (; bits > 0; bits--)\n-\t  if ((temp = alpha_emit_set_const (subtarget, mode,\n-\t\t\t\t\t    c << bits, i)) != 0\n-\t      || ((temp = (alpha_emit_set_const\n-\t\t\t   (subtarget, mode,\n-\t\t\t    ((c << bits) | (((HOST_WIDE_INT) 1 << bits) - 1)),\n-\t\t\t    i)))\n-\t\t  != 0))\n-\t    return expand_binop (mode, ashr_optab, temp, GEN_INT (bits),\n-\t\t\t\t target, 0, OPTAB_WIDEN);\n+\t  {\n+\t    new = c << bits;\n+\t    temp = alpha_emit_set_const (subtarget, mode, new, i, no_output);\n+\t    if (!temp)\n+\t      {\n+\t\tnew = (c << bits) | (((HOST_WIDE_INT) 1 << bits) - 1);\n+\t        temp = alpha_emit_set_const (subtarget, mode, new,\n+\t\t\t\t\t     i, no_output);\n+\t      }\n+\t    if (temp)\n+\t      {\n+\t\tif (no_output)\n+\t\t  return temp;\n+\t\treturn expand_binop (mode, ashr_optab, temp, GEN_INT (bits),\n+\t\t\t\t     target, 0, OPTAB_WIDEN);\n+\t      }\n+\t  }\n     }\n \n #if HOST_BITS_PER_WIDE_INT == 64\n@@ -1863,10 +1919,17 @@ alpha_emit_set_const_1 (rtx target, enum machine_mode mode,\n   if (mode == SImode)\n     new = ((new & 0xffffffff) ^ 0x80000000) - 0x80000000;\n \n-  if (new != c && new != -1\n-      && (temp = alpha_emit_set_const (subtarget, mode, new, n - 1)) != 0)\n-    return expand_binop (mode, and_optab, temp, GEN_INT (c | ~ new),\n-\t\t\t target, 0, OPTAB_WIDEN);\n+  if (new != c)\n+    {\n+      temp = alpha_emit_set_const (subtarget, mode, new, n - 1, no_output);\n+      if (temp)\n+\t{\n+\t  if (no_output)\n+\t    return temp;\n+\t  return expand_binop (mode, and_optab, temp, GEN_INT (c | ~ new),\n+\t\t\t       target, 0, OPTAB_WIDEN);\n+\t}\n+    }\n #endif\n \n   return 0;\n@@ -1878,41 +1941,60 @@ alpha_emit_set_const_1 (rtx target, enum machine_mode mode,\n    emitted.  If it would take more than N insns, zero is returned and no\n    insns and emitted.  */\n \n-rtx\n+static rtx\n alpha_emit_set_const (rtx target, enum machine_mode mode,\n-\t\t      HOST_WIDE_INT c, int n)\n+\t\t      HOST_WIDE_INT c, int n, bool no_output)\n {\n-  rtx result = 0;\n+  enum machine_mode orig_mode = mode;\n   rtx orig_target = target;\n+  rtx result = 0;\n   int i;\n \n   /* If we can't make any pseudos, TARGET is an SImode hard register, we\n      can't load this constant in one insn, do this in DImode.  */\n   if (no_new_pseudos && mode == SImode\n-      && GET_CODE (target) == REG && REGNO (target) < FIRST_PSEUDO_REGISTER\n-      && (result = alpha_emit_set_const_1 (target, mode, c, 1)) == 0)\n+      && GET_CODE (target) == REG && REGNO (target) < FIRST_PSEUDO_REGISTER)\n+    {\n+      result = alpha_emit_set_const_1 (target, mode, c, 1, no_output);\n+      if (result)\n+\treturn result;\n+\n+      target = no_output ? NULL : gen_lowpart (DImode, target);\n+      mode = DImode;\n+    }\n+  else if (mode == V8QImode || mode == V4HImode || mode == V2SImode)\n     {\n-      target = gen_lowpart (DImode, target);\n+      target = no_output ? NULL : gen_lowpart (DImode, target);\n       mode = DImode;\n     }\n \n   /* Try 1 insn, then 2, then up to N.  */\n   for (i = 1; i <= n; i++)\n     {\n-      result = alpha_emit_set_const_1 (target, mode, c, i);\n+      result = alpha_emit_set_const_1 (target, mode, c, i, no_output);\n       if (result)\n \t{\n-\t  rtx insn = get_last_insn ();\n-\t  rtx set = single_set (insn);\n+\t  rtx insn, set;\n+\n+\t  if (no_output)\n+\t    return result;\n+\n+\t  insn = get_last_insn ();\n+\t  set = single_set (insn);\n \t  if (! CONSTANT_P (SET_SRC (set)))\n \t    set_unique_reg_note (get_last_insn (), REG_EQUAL, GEN_INT (c));\n \t  break;\n \t}\n     }\n \n   /* Allow for the case where we changed the mode of TARGET.  */\n-  if (result == target)\n-    result = orig_target;\n+  if (result)\n+    {\n+      if (result == target)\n+\tresult = orig_target;\n+      else if (mode != orig_mode)\n+\tresult = gen_lowpart (orig_mode, result);\n+    }\n \n   return result;\n }\n@@ -1922,7 +2004,7 @@ alpha_emit_set_const (rtx target, enum machine_mode mode,\n    exponential run times encountered when looking for longer sequences\n    with alpha_emit_set_const.  */\n \n-rtx\n+static rtx\n alpha_emit_set_long_const (rtx target, HOST_WIDE_INT c1, HOST_WIDE_INT c2)\n {\n   HOST_WIDE_INT d1, d2, d3, d4;\n@@ -1976,6 +2058,114 @@ alpha_emit_set_long_const (rtx target, HOST_WIDE_INT c1, HOST_WIDE_INT c2)\n   return target;\n }\n \n+/* Given an integral CONST_INT, CONST_DOUBLE, or CONST_VECTOR, return \n+   the low 64 bits.  */\n+\n+static void\n+alpha_extract_integer (rtx x, HOST_WIDE_INT *p0, HOST_WIDE_INT *p1)\n+{\n+  HOST_WIDE_INT i0, i1;\n+\n+  if (GET_CODE (x) == CONST_VECTOR)\n+    x = simplify_subreg (DImode, x, GET_MODE (x), 0);\n+\n+\n+  if (GET_CODE (x) == CONST_INT)\n+    {\n+      i0 = INTVAL (x);\n+      i1 = -(i0 < 0);\n+    }\n+  else if (HOST_BITS_PER_WIDE_INT >= 64)\n+    {\n+      i0 = CONST_DOUBLE_LOW (x);\n+      i1 = -(i0 < 0);\n+    }\n+  else\n+    {\n+      i0 = CONST_DOUBLE_LOW (x);\n+      i1 = CONST_DOUBLE_HIGH (x);\n+    }\n+\n+  *p0 = i0;\n+  *p1 = i1;\n+}\n+\n+/* Implement LEGITIMATE_CONSTANT_P.  This is all constants for which we\n+   are willing to load the value into a register via a move pattern.\n+   Normally this is all symbolic constants, integral constants that\n+   take three or fewer instructions, and floating-point zero.  */\n+\n+bool\n+alpha_legitimate_constant_p (rtx x)\n+{\n+  enum machine_mode mode = GET_MODE (x);\n+  HOST_WIDE_INT i0, i1;\n+\n+  switch (GET_CODE (x))\n+    {\n+    case CONST:\n+    case LABEL_REF:\n+    case SYMBOL_REF:\n+    case HIGH:\n+      return true;\n+\n+    case CONST_DOUBLE:\n+      if (x == CONST0_RTX (mode))\n+\treturn true;\n+      if (FLOAT_MODE_P (mode))\n+\treturn false;\n+      goto do_integer;\n+\n+    case CONST_VECTOR:\n+      if (x == CONST0_RTX (mode))\n+\treturn true;\n+      if (GET_MODE_CLASS (mode) != MODE_VECTOR_INT)\n+\treturn false;\n+      if (GET_MODE_SIZE (mode) != 8)\n+\treturn false;\n+      goto do_integer;\n+\n+    case CONST_INT:\n+    do_integer:\n+      if (TARGET_BUILD_CONSTANTS)\n+\treturn true;\n+      alpha_extract_integer (x, &i0, &i1);\n+      if (HOST_BITS_PER_WIDE_INT >= 64 || i1 == (-i0 < 0))\n+        return alpha_emit_set_const_1 (x, mode, i0, 3, true) != NULL;\n+      return false;\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n+/* Operand 1 is known to be a constant, and should require more than one\n+   instruction to load.  Emit that multi-part load.  */\n+\n+bool\n+alpha_split_const_mov (enum machine_mode mode, rtx *operands)\n+{\n+  HOST_WIDE_INT i0, i1;\n+  rtx temp = NULL_RTX;\n+\n+  alpha_extract_integer (operands[1], &i0, &i1);\n+\n+  if (HOST_BITS_PER_WIDE_INT >= 64 || i1 == -(i0 < 0))\n+    temp = alpha_emit_set_const (operands[0], mode, i0, 3, false);\n+\n+  if (!temp && TARGET_BUILD_CONSTANTS)\n+    temp = alpha_emit_set_long_const (operands[0], i0, i1);\n+\n+  if (temp)\n+    {\n+      if (!rtx_equal_p (operands[0], temp))\n+\temit_move_insn (operands[0], temp);\n+      return true;\n+    }\n+\n+  return false;\n+}\n+\n /* Expand a move instruction; return true if all work is done.\n    We don't handle non-bwx subword loads here.  */\n \n@@ -2008,40 +2198,11 @@ alpha_expand_mov (enum machine_mode mode, rtx *operands)\n \n   /* Split large integers.  */\n   if (GET_CODE (operands[1]) == CONST_INT\n-      || GET_CODE (operands[1]) == CONST_DOUBLE)\n+      || GET_CODE (operands[1]) == CONST_DOUBLE\n+      || GET_CODE (operands[1]) == CONST_VECTOR)\n     {\n-      HOST_WIDE_INT i0, i1;\n-      rtx temp = NULL_RTX;\n-\n-      if (GET_CODE (operands[1]) == CONST_INT)\n-\t{\n-\t  i0 = INTVAL (operands[1]);\n-\t  i1 = -(i0 < 0);\n-\t}\n-      else if (HOST_BITS_PER_WIDE_INT >= 64)\n-\t{\n-\t  i0 = CONST_DOUBLE_LOW (operands[1]);\n-\t  i1 = -(i0 < 0);\n-\t}\n-      else\n-\t{\n-\t  i0 = CONST_DOUBLE_LOW (operands[1]);\n-\t  i1 = CONST_DOUBLE_HIGH (operands[1]);\n-\t}\n-\n-      if (HOST_BITS_PER_WIDE_INT >= 64 || i1 == -(i0 < 0))\n-\ttemp = alpha_emit_set_const (operands[0], mode, i0, 3);\n-\n-      if (!temp && TARGET_BUILD_CONSTANTS)\n-\ttemp = alpha_emit_set_long_const (operands[0], i0, i1);\n-\n-      if (temp)\n-\t{\n-\t  if (rtx_equal_p (operands[0], temp))\n-\t    return true;\n-\t  operands[1] = temp;\n-\t  return false;\n-\t}\n+      if (alpha_split_const_mov (mode, operands))\n+\treturn true;\n     }\n \n   /* Otherwise we've nothing left but to drop the thing to memory.  */\n@@ -7029,7 +7190,8 @@ alpha_expand_epilogue (void)\n       else\n \t{\n \t  rtx tmp = gen_rtx_REG (DImode, 23);\n-\t  FRP (sp_adj2 = alpha_emit_set_const (tmp, DImode, frame_size, 3));\n+\t  FRP (sp_adj2 = alpha_emit_set_const (tmp, DImode, frame_size,\n+\t\t\t\t\t       3, false));\n \t  if (!sp_adj2)\n \t    {\n \t      /* We can't drop new things to memory this late, afaik,"}, {"sha": "21a634c39ec834c0f272e6a663a4c16e53e6306c", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72910a0b3b6c68d3ca4d636b9a06923c07a45df8/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72910a0b3b6c68d3ca4d636b9a06923c07a45df8/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=72910a0b3b6c68d3ca4d636b9a06923c07a45df8", "patch": "@@ -884,10 +884,10 @@ enum reg_class {\n    reduce the impact of not being able to allocate a pseudo to a\n    hard register.  */\n \n-#define REGISTER_MOVE_COST(MODE, CLASS1, CLASS2)\t\\\n-  (((CLASS1) == FLOAT_REGS) == ((CLASS2) == FLOAT_REGS)\t\\\n-   ? 2\t\t\t\t\t\t\t\\\n-   : TARGET_FIX ? 3 : 4+2*alpha_memory_latency)\n+#define REGISTER_MOVE_COST(MODE, CLASS1, CLASS2)\t\t\\\n+  (((CLASS1) == FLOAT_REGS) == ((CLASS2) == FLOAT_REGS)\t? 2\t\\\n+   : TARGET_FIX ? ((CLASS1) == FLOAT_REGS ? 6 : 8)\t\t\\\n+   : 4+2*alpha_memory_latency)\n \n /* A C expressions returning the cost of moving data of MODE from a register to\n    or from memory.\n@@ -1213,9 +1213,7 @@ do {\t\t\t\t\t\t\\\n /* Include all constant integers and constant doubles, but not\n    floating-point, except for floating-point zero.  */\n \n-#define LEGITIMATE_CONSTANT_P(X)  \t\t\\\n-  (GET_MODE_CLASS (GET_MODE (X)) != MODE_FLOAT\t\\\n-   || (X) == CONST0_RTX (GET_MODE (X)))\n+#define LEGITIMATE_CONSTANT_P  alpha_legitimate_constant_p\n \n /* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n    and check its validity for a certain class."}, {"sha": "0f68d36b93bdaf58bc76f0ef5896886ea4d1e5f5", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 56, "deletions": 43, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72910a0b3b6c68d3ca4d636b9a06923c07a45df8/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72910a0b3b6c68d3ca4d636b9a06923c07a45df8/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=72910a0b3b6c68d3ca4d636b9a06923c07a45df8", "patch": "@@ -5128,22 +5128,23 @@\n })\n \n (define_insn \"*movsi\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,r,r,m\")\n-\t(match_operand:SI 1 \"input_operand\" \"rJ,K,L,m,rJ\"))]\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,r,r,r,m\")\n+\t(match_operand:SI 1 \"input_operand\" \"rJ,K,L,n,m,rJ\"))]\n   \"(TARGET_ABI_OSF || TARGET_ABI_UNICOSMK)\n    && (register_operand (operands[0], SImode)\n        || reg_or_0_operand (operands[1], SImode))\"\n   \"@\n    bis $31,%r1,%0\n    lda %0,%1($31)\n    ldah %0,%h1($31)\n+   #\n    ldl %0,%1\n    stl %r1,%0\"\n-  [(set_attr \"type\" \"ilog,iadd,iadd,ild,ist\")])\n+  [(set_attr \"type\" \"ilog,iadd,iadd,multi,ild,ist\")])\n \n (define_insn \"*movsi_nt_vms\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,r,r,r,m\")\n-\t(match_operand:SI 1 \"input_operand\" \"rJ,K,L,s,m,rJ\"))]\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,r,r,r,r,m\")\n+\t(match_operand:SI 1 \"input_operand\" \"rJ,K,L,s,n,m,rJ\"))]\n   \"(TARGET_ABI_WINDOWS_NT || TARGET_ABI_OPEN_VMS)\n     && (register_operand (operands[0], SImode)\n         || reg_or_0_operand (operands[1], SImode))\"\n@@ -5152,9 +5153,10 @@\n    lda %0,%1\n    ldah %0,%h1\n    lda %0,%1\n+   #\n    ldl %0,%1\n    stl %r1,%0\"\n-  [(set_attr \"type\" \"ilog,iadd,iadd,ldsym,ild,ist\")])\n+  [(set_attr \"type\" \"ilog,iadd,iadd,ldsym,multi,ild,ist\")])\n \n (define_insn \"*movhi_nobwx\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n@@ -5221,15 +5223,11 @@\n \n (define_split\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(match_operand:SI 1 \"const_int_operand\" \"\"))]\n-  \"! add_operand (operands[1], SImode)\"\n-  [(set (match_dup 0) (match_dup 2))\n-   (set (match_dup 0) (plus:SI (match_dup 0) (match_dup 3)))]\n+\t(match_operand:SI 1 \"non_add_const_operand\" \"\"))]\n+  \"\"\n+  [(const_int 0)]\n {\n-  rtx tem\n-    = alpha_emit_set_const (operands[0], SImode, INTVAL (operands[1]), 2);\n-\n-  if (tem == operands[0])\n+  if (alpha_split_const_mov (SImode, operands))\n     DONE;\n   else\n     FAIL;\n@@ -5452,8 +5450,8 @@\n })\n \n (define_insn \"*movdi_er_nofix\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,r,r,r,r,m,*f,*f,Q\")\n-\t(match_operand:DI 1 \"input_operand\" \"rJ,K,L,T,s,m,rJ,*fJ,Q,*f\"))]\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,r,r,r,r,r,m,*f,*f,Q\")\n+\t(match_operand:DI 1 \"input_operand\" \"rJ,K,L,T,s,n,m,rJ,*fJ,Q,*f\"))]\n   \"TARGET_EXPLICIT_RELOCS && ! TARGET_FIX\n    && (register_operand (operands[0], DImode)\n        || reg_or_0_operand (operands[1], DImode))\"\n@@ -5463,21 +5461,22 @@\n    ldah %0,%h1($31)\n    #\n    #\n+   #\n    ldq%A1 %0,%1\n    stq%A0 %r1,%0\n    fmov %R1,%0\n    ldt %0,%1\n    stt %R1,%0\"\n-  [(set_attr \"type\" \"ilog,iadd,iadd,iadd,ldsym,ild,ist,fcpys,fld,fst\")\n-   (set_attr \"usegp\" \"*,*,*,yes,*,*,*,*,*,*\")])\n+  [(set_attr \"type\" \"ilog,iadd,iadd,iadd,ldsym,multi,ild,ist,fcpys,fld,fst\")\n+   (set_attr \"usegp\" \"*,*,*,yes,*,*,*,*,*,*,*\")])\n \n ;; The 'U' constraint matches symbolic operands on Unicos/Mk. Those should\n ;; have been split up by the rules above but we shouldn't reject the\n ;; possibility of them getting through.\n \n (define_insn \"*movdi_nofix\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,r,r,r,r,m,*f,*f,Q\")\n-\t(match_operand:DI 1 \"input_operand\" \"rJ,K,L,U,s,m,rJ,*fJ,Q,*f\"))]\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,r,r,r,r,r,m,*f,*f,Q\")\n+\t(match_operand:DI 1 \"input_operand\" \"rJ,K,L,U,s,n,m,rJ,*fJ,Q,*f\"))]\n   \"! TARGET_FIX\n    && (register_operand (operands[0], DImode)\n        || reg_or_0_operand (operands[1], DImode))\"\n@@ -5487,19 +5486,20 @@\n    ldah %0,%h1($31)\n    laum %0,%t1($31)\\;sll %0,32,%0\\;lalm %0,%t1(%0)\\;lal %0,%t1(%0)\n    lda %0,%1\n+   #\n    ldq%A1 %0,%1\n    stq%A0 %r1,%0\n    cpys %R1,%R1,%0\n    ldt %0,%1\n    stt %R1,%0\"\n-  [(set_attr \"type\" \"ilog,iadd,iadd,ldsym,ldsym,ild,ist,fcpys,fld,fst\")\n-   (set_attr \"length\" \"*,*,*,16,*,*,*,*,*,*\")])\n+  [(set_attr \"type\" \"ilog,iadd,iadd,ldsym,ldsym,multi,ild,ist,fcpys,fld,fst\")\n+   (set_attr \"length\" \"*,*,*,16,*,*,*,*,*,*,*\")])\n \n (define_insn \"*movdi_er_fix\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\"\n-\t\t\t\t\"=r,r,r,r,r,r, m, *f,*f, Q, r,*f\")\n+\t\t\t\t\"=r,r,r,r,r,r,r, m, *f,*f, Q, r,*f\")\n \t(match_operand:DI 1 \"input_operand\"\n-\t\t\t\t\"rJ,K,L,T,s,m,rJ,*fJ, Q,*f,*f, r\"))]\n+\t\t\t\t\"rJ,K,L,T,s,n,m,rJ,*fJ, Q,*f,*f, r\"))]\n   \"TARGET_EXPLICIT_RELOCS && TARGET_FIX\n    && (register_operand (operands[0], DImode)\n        || reg_or_0_operand (operands[1], DImode))\"\n@@ -5509,19 +5509,20 @@\n    ldah %0,%h1($31)\n    #\n    #\n+   #\n    ldq%A1 %0,%1\n    stq%A0 %r1,%0\n    fmov %R1,%0\n    ldt %0,%1\n    stt %R1,%0\n    ftoit %1,%0\n    itoft %1,%0\"\n-  [(set_attr \"type\" \"ilog,iadd,iadd,iadd,ldsym,ild,ist,fcpys,fld,fst,ftoi,itof\")\n-   (set_attr \"usegp\" \"*,*,*,yes,*,*,*,*,*,*,*,*\")])\n+  [(set_attr \"type\" \"ilog,iadd,iadd,iadd,ldsym,multi,ild,ist,fcpys,fld,fst,ftoi,itof\")\n+   (set_attr \"usegp\" \"*,*,*,yes,*,*,*,*,*,*,*,*,*\")])\n \n (define_insn \"*movdi_fix\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,r,r,r,m,*f,*f,Q,r,*f\")\n-\t(match_operand:DI 1 \"input_operand\" \"rJ,K,L,s,m,rJ,*fJ,Q,*f,*f,r\"))]\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,r,r,r,r,m,*f,*f,Q,r,*f\")\n+\t(match_operand:DI 1 \"input_operand\" \"rJ,K,L,s,n,m,rJ,*fJ,Q,*f,*f,r\"))]\n   \"! TARGET_EXPLICIT_RELOCS && TARGET_FIX\n    && (register_operand (operands[0], DImode)\n        || reg_or_0_operand (operands[1], DImode))\"\n@@ -5530,14 +5531,15 @@\n    lda %0,%1($31)\n    ldah %0,%h1($31)\n    lda %0,%1\n+   #\n    ldq%A1 %0,%1\n    stq%A0 %r1,%0\n    cpys %R1,%R1,%0\n    ldt %0,%1\n    stt %R1,%0\n    ftoit %1,%0\n    itoft %1,%0\"\n-  [(set_attr \"type\" \"ilog,iadd,iadd,ldsym,ild,ist,fcpys,fld,fst,ftoi,itof\")])\n+  [(set_attr \"type\" \"ilog,iadd,iadd,ldsym,multi,ild,ist,fcpys,fld,fst,ftoi,itof\")])\n \n ;; VMS needs to set up \"vms_base_regno\" for unwinding.  This move\n ;; often appears dead to the life analysis code, at which point we\n@@ -5568,15 +5570,11 @@\n \n (define_split\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(match_operand:DI 1 \"const_int_operand\" \"\"))]\n-  \"! add_operand (operands[1], DImode)\"\n-  [(set (match_dup 0) (match_dup 2))\n-   (set (match_dup 0) (plus:DI (match_dup 0) (match_dup 3)))]\n+\t(match_operand:DI 1 \"non_add_const_operand\" \"\"))]\n+  \"\"\n+  [(const_int 0)]\n {\n-  rtx tem\n-    = alpha_emit_set_const (operands[0], DImode, INTVAL (operands[1]), 2);\n-\n-  if (tem == operands[0])\n+  if (alpha_split_const_mov (DImode, operands))\n     DONE;\n   else\n     FAIL;\n@@ -6103,6 +6101,19 @@\n     DONE;\n })\n \n+(define_split\n+  [(set (match_operand:VEC 0 \"register_operand\" \"\")\n+\t(match_operand:VEC 1 \"non_zero_const_operand\" \"\"))]\n+  \"\"\n+  [(const_int 0)]\n+{\n+  if (alpha_split_const_mov (<MODE>mode, operands))\n+    DONE;\n+  else\n+    FAIL;\n+})\n+\n+\n (define_expand \"movmisalign<mode>\"\n   [(set (match_operand:VEC 0 \"nonimmediate_operand\" \"\")\n         (match_operand:VEC 1 \"general_operand\" \"\"))]\n@@ -6113,36 +6124,38 @@\n })\n \n (define_insn \"*mov<mode>_fix\"\n-  [(set (match_operand:VEC 0 \"nonimmediate_operand\" \"=r,r,m,*f,*f,m,r,*f\")\n-\t(match_operand:VEC 1 \"input_operand\" \"rW,m,rW,*fW,m,*f,*f,r\"))]\n+  [(set (match_operand:VEC 0 \"nonimmediate_operand\" \"=r,r,r,m,*f,*f,m,r,*f\")\n+\t(match_operand:VEC 1 \"input_operand\" \"rW,i,m,rW,*fW,m,*f,*f,r\"))]\n   \"TARGET_FIX\n    && (register_operand (operands[0], <MODE>mode)\n        || reg_or_0_operand (operands[1], <MODE>mode))\"\n   \"@\n    bis $31,%r1,%0\n+   #\n    ldq %0,%1\n    stq %r1,%0\n    cpys %R1,%R1,%0\n    ldt %0,%1\n    stt %R1,%0\n    ftoit %1,%0\n    itoft %1,%0\"\n-  [(set_attr \"type\" \"ilog,ild,ist,fcpys,fld,fst,ftoi,itof\")])\n+  [(set_attr \"type\" \"ilog,multi,ild,ist,fcpys,fld,fst,ftoi,itof\")])\n \n (define_insn \"*mov<mode>_nofix\"\n-  [(set (match_operand:VEC 0 \"nonimmediate_operand\" \"=r,r,m,*f,*f,m\")\n-\t(match_operand:VEC 1 \"input_operand\" \"rW,m,rW,*fW,m,*f\"))]\n+  [(set (match_operand:VEC 0 \"nonimmediate_operand\" \"=r,r,r,m,*f,*f,m\")\n+\t(match_operand:VEC 1 \"input_operand\" \"rW,i,m,rW,*fW,m,*f\"))]\n   \"! TARGET_FIX\n    && (register_operand (operands[0], <MODE>mode)\n        || reg_or_0_operand (operands[1], <MODE>mode))\"\n   \"@\n    bis $31,%r1,%0\n+   #\n    ldq %0,%1\n    stq %r1,%0\n    cpys %R1,%R1,%0\n    ldt %0,%1\n    stt %R1,%0\"\n-  [(set_attr \"type\" \"ilog,ild,ist,fcpys,fld,fst\")])\n+  [(set_attr \"type\" \"ilog,multi,ild,ist,fcpys,fld,fst\")])\n \n (define_insn \"uminv8qi3\"\n   [(set (match_operand:V8QI 0 \"register_operand\" \"=r\")"}, {"sha": "6a58ed679054fd1b131dd5e4a2b7f879e077561b", "filename": "gcc/config/alpha/predicates.md", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72910a0b3b6c68d3ca4d636b9a06923c07a45df8/gcc%2Fconfig%2Falpha%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72910a0b3b6c68d3ca4d636b9a06923c07a45df8/gcc%2Fconfig%2Falpha%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fpredicates.md?ref=72910a0b3b6c68d3ca4d636b9a06923c07a45df8", "patch": "@@ -66,6 +66,17 @@\n \t\t || CONST_OK_FOR_LETTER_P (INTVAL (op), 'O')\")\n     (match_operand 0 \"register_operand\")))\n \n+;; Return 1 if the operand is a non-symbolic constant operand that\n+;; does not satisfy add_operand.\n+(define_predicate \"non_add_const_operand\"\n+  (and (match_code \"const_int,const_double,const_vector\")\n+       (not (match_operand 0 \"add_operand\"))))\n+\n+;; Return 1 if the operand is a non-symbolic, non-zero constant operand.\n+(define_predicate \"non_zero_const_operand\"\n+  (and (match_code \"const_int,const_double,const_vector\")\n+       (match_test \"op != CONST0_RTX (mode)\")))\n+\n ;; Return 1 if OP is the constant 4 or 8.\n (define_predicate \"const48_operand\"\n   (and (match_code \"const_int\")\n@@ -205,11 +216,19 @@\n \t      && general_operand (op, mode));\n \n     case CONST_DOUBLE:\n+      return op == CONST0_RTX (mode);\n+\n     case CONST_VECTOR:\n+      if (reload_in_progress || reload_completed)\n+\treturn alpha_legitimate_constant_p (op);\n       return op == CONST0_RTX (mode);\n \n     case CONST_INT:\n-      return mode == QImode || mode == HImode || add_operand (op, mode);\n+      if (mode == QImode || mode == HImode)\n+\treturn true;\n+      if (reload_in_progress || reload_completed)\n+\treturn alpha_legitimate_constant_p (op);\n+      return add_operand (op, mode);\n \n     default:\n       abort ();"}, {"sha": "47ad3e17b4e7966ce7c8e1ec79e14c29b42cf15b", "filename": "gcc/testsuite/gcc.target/alpha/alpha.exp", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72910a0b3b6c68d3ca4d636b9a06923c07a45df8/gcc%2Ftestsuite%2Fgcc.target%2Falpha%2Falpha.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72910a0b3b6c68d3ca4d636b9a06923c07a45df8/gcc%2Ftestsuite%2Fgcc.target%2Falpha%2Falpha.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Falpha%2Falpha.exp?ref=72910a0b3b6c68d3ca4d636b9a06923c07a45df8", "patch": "@@ -0,0 +1,41 @@\n+#   Copyright (C) 2005 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 2 of the License, or\n+# (at your option) any later version.\n+# \n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with this program; if not, write to the Free Software\n+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  \n+\n+# GCC testsuite that uses the `dg.exp' driver.\n+\n+# Exit immediately if this isn't an Alpha target.\n+if ![istarget alpha*-*-*] then {\n+  return\n+}\n+\n+# Load support procs.\n+load_lib gcc-dg.exp\n+\n+# If a testcase doesn't have special options, use these.\n+global DEFAULT_CFLAGS\n+if ![info exists DEFAULT_CFLAGS] then {\n+    set DEFAULT_CFLAGS \" -ansi -pedantic-errors\"\n+}\n+\n+# Initialize `dg'.\n+dg-init\n+\n+# Main loop.\n+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.\\[cS\\]]] \\\n+\t\"\" $DEFAULT_CFLAGS\n+\n+# All done.\n+dg-finish"}, {"sha": "42c58b5a5bbe5a94a266e2ca21853f81ed4dd07c", "filename": "gcc/testsuite/gcc.target/alpha/pr19518.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72910a0b3b6c68d3ca4d636b9a06923c07a45df8/gcc%2Ftestsuite%2Fgcc.target%2Falpha%2Fpr19518.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72910a0b3b6c68d3ca4d636b9a06923c07a45df8/gcc%2Ftestsuite%2Fgcc.target%2Falpha%2Fpr19518.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Falpha%2Fpr19518.c?ref=72910a0b3b6c68d3ca4d636b9a06923c07a45df8", "patch": "@@ -0,0 +1,60 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mcpu=ev67\" } */\n+\n+typedef short INT16;\n+typedef unsigned int CARD32;\n+typedef unsigned short CARD16;\n+typedef unsigned char CARD8;\n+typedef struct _Picture *PicturePtr;\n+typedef int FbStride;\n+typedef unsigned long __m64;\n+extern __m64 load8888 (__m64);\n+static __inline __m64 _mm_adds_pu8(__m64 __m1, __m64 __m2)\n+{\n+    return __m1 + __builtin_alpha_minsb8(__m2, ~__m1);\n+}\n+static __inline __m64 _mm_packs_pu16(__m64 __m1, __m64 __m2)\n+{\n+    __m1 = __builtin_alpha_minuw4(__m1, 0x00ff00ff00ff00ff);\n+    __m2 = __builtin_alpha_minuw4(__m2, 0x00ff00ff00ff00ff);\n+    return __m1 | (__m2 << 32);\n+}\n+typedef unsigned long long ullong;\n+static __inline__ __m64 pix_multiply(__m64 a)\n+{\n+    if (a)\n+\treturn a;\n+}\n+static __inline__ __m64 over(__m64 src, __m64 srca, __m64 dest)\n+{\n+    return _mm_adds_pu8(src, pix_multiply(dest));\n+}\n+\n+void fbCompositeSolid_nx8888mmx(CARD8 op, PicturePtr pSrc, PicturePtr pMask,\n+\t\t\t\tINT16 yDst, CARD16 width, CARD16 height)\n+{\n+    CARD32 src;\n+    CARD32 *dstLine, *dst;\n+    CARD16 w;\n+    FbStride dstStride;\n+    __m64 vsrc, vsrca;\n+    vsrc = load8888(src);\n+    while (height--) {\n+\tdst = dstLine;\n+\tdstLine += dstStride;\n+\twhile (w && (unsigned long) dst & 7) {\n+\t    *dst = _mm_packs_pu16(_mm_adds_pu8(vsrc, load8888(*dst)),\n+\t\t\t\t  _mm_setzero_si64());\n+\t    dst++;\n+\t}\n+\twhile (w >= 2) {\n+\t    __m64 dest0, dest1;\n+\t    *(__m64 *) dst = _mm_packs_pu16(dest0, dest1);\n+\t    w -= 2;\n+\t}\n+\twhile (w) {\n+\t    *dst = _mm_packs_pu16(_mm_adds_pu8(vsrc, pix_multiply(0)), 0);\n+\t    w--;\n+\t}\n+    }\n+}"}]}