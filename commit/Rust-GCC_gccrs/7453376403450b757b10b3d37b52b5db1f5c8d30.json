{"sha": "7453376403450b757b10b3d37b52b5db1f5c8d30", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzQ1MzM3NjQwMzQ1MGI3NTdiMTBiM2QzN2I1MmI1ZGIxZjVjOGQzMA==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2019-11-16T21:47:28Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2019-11-16T21:47:28Z"}, "message": "libstdc++: Optimize std::jthread construction\n\nThis change avoids storing a copy of a stop_token object that isn't\nneeded and won't be passed to the callable object. This slightly reduces\nmemory usage when the callable doesn't use a stop_token. It also removes\nindirection in the invocation of the callable in the new thread, as\nthere is no lambda and no additional calls to std::invoke.\n\nIt also adds some missing [[nodiscard]] attributes, and the non-member\nswap overload for std::jthread.\n\n\t* include/std/thread (jthread::jthread()): Use nostopstate constant.\n\t(jthread::jthread(Callable&&, Args&&...)): Use helper function to\n\tcreate std::thread instead of indirection through a lambda. Use\n\tremove_cvref_t instead of decay_t.\n\t(jthread::joinable(), jthread::get_id(), jthread::native_handle())\n\t(jthread::hardware_concurrency()): Add nodiscard attribute.\n\t(swap(jthread&. jthread&)): Define hidden friend.\n\t(jthread::_S_create): New helper function for constructor.\n\nFrom-SVN: r278364", "tree": {"sha": "2282726fd3424c934787eba1232b9fed2279900a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2282726fd3424c934787eba1232b9fed2279900a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7453376403450b757b10b3d37b52b5db1f5c8d30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7453376403450b757b10b3d37b52b5db1f5c8d30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7453376403450b757b10b3d37b52b5db1f5c8d30", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7453376403450b757b10b3d37b52b5db1f5c8d30/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "970a9bfaadcca4489613ca76a1800a32d1a93e14", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/970a9bfaadcca4489613ca76a1800a32d1a93e14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/970a9bfaadcca4489613ca76a1800a32d1a93e14"}], "stats": {"total": 66, "additions": 40, "deletions": 26}, "files": [{"sha": "bd1afdfd0a598ca64e17e07c34921a951859e21e", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7453376403450b757b10b3d37b52b5db1f5c8d30/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7453376403450b757b10b3d37b52b5db1f5c8d30/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=7453376403450b757b10b3d37b52b5db1f5c8d30", "patch": "@@ -1,3 +1,14 @@\n+2019-11-16  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\t* include/std/thread (jthread::jthread()): Use nostopstate constant.\n+\t(jthread::jthread(Callable&&, Args&&...)): Use helper function to\n+\tcreate std::thread instead of indirection through a lambda. Use\n+\tremove_cvref_t instead of decay_t.\n+\t(jthread::joinable(), jthread::get_id(), jthread::native_handle())\n+\t(jthread::hardware_concurrency()): Add nodiscard attribute.\n+\t(swap(jthread&. jthread&)): Define hidden friend.\n+\t(jthread::_S_create): New helper function for constructor.\n+\n 2019-11-15  Edward Smith-Rowland  <3dw4rd@verizon.net>\n \n \tImplement the <tuple> part of C++20 p1032 Misc constexpr bits."}, {"sha": "010921b2160f180c348388bf049341bec522376b", "filename": "libstdc++-v3/include/std/thread", "status": "modified", "additions": 29, "deletions": 26, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7453376403450b757b10b3d37b52b5db1f5c8d30/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fthread", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7453376403450b757b10b3d37b52b5db1f5c8d30/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fthread", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fthread?ref=7453376403450b757b10b3d37b52b5db1f5c8d30", "patch": "@@ -425,31 +425,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     using native_handle_type = std::thread::native_handle_type;\n \n     jthread() noexcept\n-    : _M_stop_source{ nostopstate_t{ } }\n+    : _M_stop_source{nostopstate}\n     { }\n \n     template<typename _Callable, typename... _Args,\n-             typename = std::enable_if_t<!std::is_same_v<std::decay_t<_Callable>, jthread>>>\n-    explicit\n-    jthread(_Callable&& __f, _Args&&... __args)\n-      : _M_thread{[](stop_token __token, auto&& __cb, auto&&... __args)\n-                  {\n-                    if constexpr(std::is_invocable_v<_Callable, stop_token, _Args...>)\n-                      {\n-                        std::invoke(std::forward<decltype(__cb)>(__cb),\n-                                    std::move(__token),\n-                                    std::forward<decltype(__args)>(__args)...);\n-                      }\n-                    else\n-                      {\n-                        std::invoke(std::forward<decltype(__cb)>(__cb),\n-                                    std::forward<decltype(__args)>(__args)...);\n-                      }\n-                  },\n-                  _M_stop_source.get_token(),\n-                  std::forward<_Callable>(__f),\n-                  std::forward<_Args>(__args)...}\n-    { }\n+\t     typename = enable_if_t<!is_same_v<remove_cvref_t<_Callable>,\n+\t\t\t\t\t       jthread>>>\n+      explicit\n+      jthread(_Callable&& __f, _Args&&... __args)\n+      : _M_thread{_S_create(_M_stop_source, std::forward<_Callable>(__f),\n+\t\t\t    std::forward<_Args>(__args)...)}\n+      { }\n \n     jthread(const jthread&) = delete;\n     jthread(jthread&&) noexcept = default;\n@@ -476,7 +462,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       std::swap(_M_thread, __other._M_thread);\n     }\n \n-    bool\n+    [[nodiscard]] bool\n     joinable() const noexcept\n     {\n       return _M_thread.joinable();\n@@ -494,19 +480,19 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _M_thread.detach();\n     }\n \n-    id\n+    [[nodiscard]] id\n     get_id() const noexcept\n     {\n       _M_thread.get_id();\n     }\n \n-    native_handle_type\n+    [[nodiscard]] native_handle_type\n     native_handle()\n     {\n       return _M_thread.native_handle();\n     }\n \n-    static unsigned\n+    [[nodiscard]] static unsigned\n     hardware_concurrency() noexcept\n     {\n       return std::thread::hardware_concurrency();\n@@ -529,7 +515,24 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       return get_stop_source().request_stop();\n     }\n \n+    friend void swap(jthread& __lhs, jthread& __rhs) noexcept\n+    {\n+      __lhs.swap(__rhs);\n+    }\n+\n   private:\n+    template<typename _Callable, typename... _Args>\n+      static thread\n+      _S_create(stop_source& __ssrc, _Callable&& __f, _Args&&... __args)\n+      {\n+\tif constexpr(is_invocable_v<_Callable, stop_token, _Args...>)\n+\t  return thread{std::forward<_Callable>(__f), __ssrc.get_token(),\n+\t\t\tstd::forward<_Args>(__args)...};\n+\telse\n+\t  return thread{std::forward<_Callable>(__f),\n+\t\t\tstd::forward<_Args>(__args)...};\n+      }\n+\n     stop_source _M_stop_source;\n     std::thread _M_thread;\n   };"}]}