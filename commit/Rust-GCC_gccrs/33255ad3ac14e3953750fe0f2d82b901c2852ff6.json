{"sha": "33255ad3ac14e3953750fe0f2d82b901c2852ff6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzMyNTVhZDNhYzE0ZTM5NTM3NTBmZTBmMmQ4MmI5MDFjMjg1MmZmNg==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2021-07-15T19:07:07Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2021-07-15T19:07:07Z"}, "message": "analyzer: reimplement -Wanalyzer-use-of-uninitialized-value [PR95006 et al]\n\nThe initial gcc 10 era commit of the analyzer (in\n757bf1dff5e8cee34c0a75d06140ca972bfecfa7) had an implementation of\n-Wanalyzer-use-of-uninitialized-value, but was sufficiently buggy\nthat I removed it in 78b9783774bfd3540f38f5b1e3c7fc9f719653d7 before\nthe release of gcc 10.1\n\nThis patch reintroduces the warning, heavily rewritten, with (I hope)\na less buggy implementation this time, for GCC 12.\n\ngcc/analyzer/ChangeLog:\n\tPR analyzer/95006\n\tPR analyzer/94713\n\tPR analyzer/94714\n\t* analyzer.cc (maybe_reconstruct_from_def_stmt): Split out\n\tGIMPLE_ASSIGN case into...\n\t(get_diagnostic_tree_for_gassign_1): New.\n\t(get_diagnostic_tree_for_gassign): New.\n\t* analyzer.h (get_diagnostic_tree_for_gassign): New decl.\n\t* analyzer.opt (Wanalyzer-write-to-string-literal): New.\n\t* constraint-manager.cc (class svalue_purger): New.\n\t(constraint_manager::purge_state_involving): New.\n\t* constraint-manager.h\n\t(constraint_manager::purge_state_involving): New.\n\t* diagnostic-manager.cc (saved_diagnostic::supercedes_p): New.\n\t(dedupe_winners::handle_interactions): New.\n\t(diagnostic_manager::emit_saved_diagnostics): Call it.\n\t* diagnostic-manager.h (saved_diagnostic::supercedes_p): New decl.\n\t* engine.cc (impl_region_model_context::warn): Convert return type\n\tto bool.  Return false if the diagnostic isn't saved.\n\t(impl_region_model_context::purge_state_involving): New.\n\t(impl_sm_context::get_state): Use NULL ctxt when querying old\n\trvalue.\n\t(impl_sm_context::set_next_state): Use new sval when querying old\n\tstate.\n\t(class dump_path_diagnostic): Move to region-model.cc\n\t(exploded_node::on_stmt): Move to on_stmt_pre and on_stmt_post.\n\tRemove call to purge_state_involving.\n\t(exploded_node::on_stmt_pre): New, based on the above.  Move most\n\tof it to region_model::on_stmt_pre.\n\t(exploded_node::on_stmt_post): Likewise, moving to\n\tregion_model::on_stmt_post.\n\t(class stale_jmp_buf): Fix parent class to use curiously recurring\n\ttemplate pattern.\n\t(feasibility_state::maybe_update_for_edge): Call on_call_pre and\n\ton_call_post on gcalls.\n\t* exploded-graph.h (impl_region_model_context::warn): Return bool.\n\t(impl_region_model_context::purge_state_involving): New decl.\n\t(exploded_node::on_stmt_pre): New decl.\n\t(exploded_node::on_stmt_post): New decl.\n\t* pending-diagnostic.h (pending_diagnostic::use_of_uninit_p): New.\n\t(pending_diagnostic::supercedes_p): New.\n\t* program-state.cc (sm_state_map::get_state): Inherit state for\n\tconjured_svalue as well as initial_svalue.\n\t(sm_state_map::purge_state_involving): Also support SK_CONJURED.\n\t* region-model-impl-calls.cc (call_details::get_uncertainty):\n\tHandle m_ctxt being NULL.\n\t(call_details::get_or_create_conjured_svalue): New.\n\t(region_model::impl_call_fgets): New.\n\t(region_model::impl_call_fread): New.\n\t* region-model-manager.cc\n\t(region_model_manager::get_or_create_initial_value): Return an\n\tuninitialized poisoned value for regions that can't have initial\n\tvalues.\n\t* region-model-reachability.cc\n\t(reachable_regions::mark_escaped_clusters): Handle ctxt being\n\tNULL.\n\t* region-model.cc (region_to_value_map::purge_state_involving): New.\n\t(poisoned_value_diagnostic::use_of_uninit_p): New.\n\t(poisoned_value_diagnostic::emit): Handle POISON_KIND_UNINIT.\n\t(poisoned_value_diagnostic::describe_final_event): Likewise.\n\t(region_model::check_for_poison): New.\n\t(region_model::on_assignment): Call it.\n\t(class dump_path_diagnostic): Move here from engine.cc.\n\t(region_model::on_stmt_pre): New, based on exploded_node::on_stmt.\n\t(region_model::on_call_pre): Move the setting of the LHS to a\n\tconjured svalue to before the checks for specific functions.\n\tHandle \"fgets\", \"fgets_unlocked\", and \"fread\".\n\t(region_model::purge_state_involving): New.\n\t(region_model::handle_unrecognized_call): Handle ctxt being NULL.\n\t(region_model::get_rvalue): Call check_for_poison.\n\t(selftest::test_stack_frames): Use NULL for context when getting\n\tuninitialized rvalue.\n\t(selftest::test_alloca): Likewise.\n\t* region-model.h (region_to_value_map::purge_state_involving): New\n\tdecl.\n\t(call_details::get_or_create_conjured_svalue): New decl.\n\t(region_model::on_stmt_pre): New decl.\n\t(region_model::purge_state_involving): New decl.\n\t(region_model::impl_call_fgets): New decl.\n\t(region_model::impl_call_fread): New decl.\n\t(region_model::check_for_poison): New decl.\n\t(region_model_context::warn): Return bool.\n\t(region_model_context::purge_state_involving): New.\n\t(noop_region_model_context::warn): Return bool.\n\t(noop_region_model_context::purge_state_involving): New.\n\t(test_region_model_context:: warn): Return bool.\n\t* region.cc (region::get_memory_space): New.\n\t(region::can_have_initial_svalue_p): New.\n\t(region::involves_p): New.\n\t* region.h (enum memory_space): New.\n\t(region::get_memory_space): New decl.\n\t(region::can_have_initial_svalue_p): New decl.\n\t(region::involves_p): New decl.\n\t* sm-malloc.cc (use_after_free::supercedes_p): New.\n\t* store.cc (binding_cluster::purge_state_involving): New.\n\t(store::purge_state_involving): New.\n\t* store.h (class symbolic_binding): New forward decl.\n\t(binding_key::dyn_cast_symbolic_binding): New.\n\t(symbolic_binding::dyn_cast_symbolic_binding): New.\n\t(binding_cluster::purge_state_involving): New.\n\t(store::purge_state_involving): New.\n\t* svalue.cc (svalue::can_merge_p): Reject attempts to merge\n\tpoisoned svalues with other svalues, so that we identify\n\tpaths in which a variable is conditionally uninitialized.\n\t(involvement_visitor::visit_conjured_svalue): New.\n\t(svalue::involves_p): Also handle SK_CONJURED.\n\t(poison_kind_to_str): Handle POISON_KIND_UNINIT.\n\t(poisoned_svalue::maybe_fold_bits_within): New.\n\t* svalue.h (enum poison_kind): Add POISON_KIND_UNINIT.\n\t(poisoned_svalue::maybe_fold_bits_within): New decl.\n\ngcc/ChangeLog:\n\tPR analyzer/95006\n\tPR analyzer/94713\n\tPR analyzer/94714\n\t* doc/invoke.texi: Add -Wanalyzer-use-of-uninitialized-value.\n\ngcc/testsuite/ChangeLog:\n\tPR analyzer/95006\n\tPR analyzer/94713\n\tPR analyzer/94714\n\t* g++.dg/analyzer/pr93212.C: Update location of warning.\n\t* g++.dg/analyzer/pr94011.C: Add\n\t-Wno-analyzer-use-of-uninitialized-value.\n\t* g++.dg/analyzer/pr94503.C: Likewise.\n\t* gcc.dg/analyzer/clobbers-1.c: Convert \"f\" from a local to a\n\tparam to avoid uninitialized warning.\n\t* gcc.dg/analyzer/data-model-1.c (test_12): Add test for\n\tuninitialized value on result of alloca.\n\t(test_12a): Add expected warning.\n\t(test_12c): Likewise.\n\t(test_19): Likewise.\n\t(test_29b): Likewise.\n\t(test_29c): Likewise.\n\t(test_37): Remove xfail.\n\t(test_37a): Likewise.\n\t* gcc.dg/analyzer/data-model-20.c: Add warning about leak.\n\t* gcc.dg/analyzer/explode-2.c: Remove params; add\n\t-Wno-analyzer-too-complex, -Wno-analyzer-malloc-leak, and xfails.\n\tInitialize the locals.\n\t* gcc.dg/analyzer/explode-2a.c: Initialize the locals.  Add\n\texpected leak.\n\t* gcc.dg/analyzer/fgets-1.c: New test.\n\t* gcc.dg/analyzer/fread-1.c: New test.\n\t* gcc.dg/analyzer/malloc-1.c (test_16): Add expected warning.\n\t(test_40): Likewise.\n\t* gcc.dg/analyzer/memset-CVE-2017-18549-1.c: Check for\n\tuninitialized padding.\n\t* gcc.dg/analyzer/pr93355-localealias-feasibility.c (fread): New\n\tdecl.\n\t(read_alias_file): Call it.\n\t* gcc.dg/analyzer/pr94047.c: Add expected warnings.\n\t* gcc.dg/analyzer/pr94851-2.c: Likewise.\n\t* gcc.dg/analyzer/pr96841.c: Convert local to a param.\n\t* gcc.dg/analyzer/pr98628.c: Likewise.\n\t* gcc.dg/analyzer/pr99042.c: Updated expected location of leak\n\tdiagnostics.\n\t* gcc.dg/analyzer/symbolic-1.c: Add expected warnings.\n\t* gcc.dg/analyzer/symbolic-7.c: Likewise.\n\t* gcc.dg/analyzer/torture/pr93649.c: Add expected warning.  Skip\n\twith -fno-fat-lto-objects.\n\t* gcc.dg/analyzer/uninit-1.c: New test.\n\t* gcc.dg/analyzer/uninit-2.c: New test.\n\t* gcc.dg/analyzer/uninit-3.c: New test.\n\t* gcc.dg/analyzer/uninit-4.c: New test.\n\t* gcc.dg/analyzer/uninit-pr94713.c: New test.\n\t* gcc.dg/analyzer/uninit-pr94714.c: New test.\n\t* gcc.dg/analyzer/use-after-free-2.c: New test.\n\t* gcc.dg/analyzer/use-after-free-3.c: New test.\n\t* gcc.dg/analyzer/zlib-3.c: Add expected warning.\n\t* gcc.dg/analyzer/zlib-6.c: Convert locals to params to avoid\n\tuninitialized warnings.  Remove xfail.\n\t* gcc.dg/analyzer/zlib-6a.c: New test, based on the old version\n\tof the above.\n\t* gfortran.dg/analyzer/pr97668.f: Add\n\t-Wno-analyzer-use-of-uninitialized-value and\n\t-Wno-analyzer-too-complex.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "24cff3eaf638921b62d7c0586b180af1633b7c3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/24cff3eaf638921b62d7c0586b180af1633b7c3e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/33255ad3ac14e3953750fe0f2d82b901c2852ff6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33255ad3ac14e3953750fe0f2d82b901c2852ff6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33255ad3ac14e3953750fe0f2d82b901c2852ff6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33255ad3ac14e3953750fe0f2d82b901c2852ff6/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "98cd4d123aa14598b1f0d54c22663c8200a96d9c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98cd4d123aa14598b1f0d54c22663c8200a96d9c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98cd4d123aa14598b1f0d54c22663c8200a96d9c"}], "stats": {"total": 1528, "additions": 1232, "deletions": 296}, "files": [{"sha": "ddace9a0c321849ce6c6910aa12210ebf95b5201", "filename": "gcc/analyzer/analyzer.cc", "status": "modified", "additions": 56, "deletions": 39, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Fanalyzer%2Fanalyzer.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Fanalyzer%2Fanalyzer.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer.cc?ref=33255ad3ac14e3953750fe0f2d82b901c2852ff6", "patch": "@@ -63,6 +63,51 @@ get_stmt_location (const gimple *stmt, function *fun)\n static tree\n fixup_tree_for_diagnostic_1 (tree expr, hash_set<tree> *visited);\n \n+/* Attemp to generate a tree for the LHS of ASSIGN_STMT.\n+   VISITED must be non-NULL; it is used to ensure termination.  */\n+\n+static tree\n+get_diagnostic_tree_for_gassign_1 (const gassign *assign_stmt,\n+\t\t\t\t   hash_set<tree> *visited)\n+{\n+  enum tree_code code = gimple_assign_rhs_code (assign_stmt);\n+\n+  /* Reverse the effect of extract_ops_from_tree during\n+     gimplification.  */\n+  switch (get_gimple_rhs_class (code))\n+    {\n+    default:\n+    case GIMPLE_INVALID_RHS:\n+      gcc_unreachable ();\n+    case GIMPLE_TERNARY_RHS:\n+    case GIMPLE_BINARY_RHS:\n+    case GIMPLE_UNARY_RHS:\n+      {\n+\ttree t = make_node (code);\n+\tTREE_TYPE (t) = TREE_TYPE (gimple_assign_lhs (assign_stmt));\n+\tunsigned num_rhs_args = gimple_num_ops (assign_stmt) - 1;\n+\tfor (unsigned i = 0; i < num_rhs_args; i++)\n+\t  {\n+\t    tree op = gimple_op (assign_stmt, i + 1);\n+\t    if (op)\n+\t      {\n+\t\top = fixup_tree_for_diagnostic_1 (op, visited);\n+\t\tif (op == NULL_TREE)\n+\t\t  return NULL_TREE;\n+\t      }\n+\t    TREE_OPERAND (t, i) = op;\n+\t  }\n+\treturn t;\n+      }\n+    case GIMPLE_SINGLE_RHS:\n+      {\n+\ttree op = gimple_op (assign_stmt, 1);\n+\top = fixup_tree_for_diagnostic_1 (op, visited);\n+\treturn op;\n+      }\n+    }\n+}\n+\n /*  Subroutine of fixup_tree_for_diagnostic_1, called on SSA names.\n     Attempt to reconstruct a a tree expression for SSA_NAME\n     based on its def-stmt.\n@@ -91,45 +136,8 @@ maybe_reconstruct_from_def_stmt (tree ssa_name,\n       /* Can't handle these.  */\n       return NULL_TREE;\n     case GIMPLE_ASSIGN:\n-      {\n-\tenum tree_code code = gimple_assign_rhs_code (def_stmt);\n-\n-\t/* Reverse the effect of extract_ops_from_tree during\n-\t   gimplification.  */\n-\tswitch (get_gimple_rhs_class (code))\n-\t  {\n-\t  default:\n-\t  case GIMPLE_INVALID_RHS:\n-\t    gcc_unreachable ();\n-\t  case GIMPLE_TERNARY_RHS:\n-\t  case GIMPLE_BINARY_RHS:\n-\t  case GIMPLE_UNARY_RHS:\n-\t    {\n-\t      tree t = make_node (code);\n-\t      TREE_TYPE (t) = TREE_TYPE (ssa_name);\n-\t      unsigned num_rhs_args = gimple_num_ops (def_stmt) - 1;\n-\t      for (unsigned i = 0; i < num_rhs_args; i++)\n-\t\t{\n-\t\t  tree op = gimple_op (def_stmt, i + 1);\n-\t\t  if (op)\n-\t\t    {\n-\t\t      op = fixup_tree_for_diagnostic_1 (op, visited);\n-\t\t      if (op == NULL_TREE)\n-\t\t\treturn NULL_TREE;\n-\t\t    }\n-\t\t  TREE_OPERAND (t, i) = op;\n-\t\t}\n-\t      return t;\n-\t    }\n-\t  case GIMPLE_SINGLE_RHS:\n-\t    {\n-\t      tree op = gimple_op (def_stmt, 1);\n-\t      op = fixup_tree_for_diagnostic_1 (op, visited);\n-\t      return op;\n-\t    }\n-\t  }\n-      }\n-      break;\n+      return get_diagnostic_tree_for_gassign_1\n+\t(as_a <const gassign *> (def_stmt), visited);\n     case GIMPLE_CALL:\n       {\n \tgcall *call_stmt = as_a <gcall *> (def_stmt);\n@@ -193,6 +201,15 @@ fixup_tree_for_diagnostic (tree expr)\n   return fixup_tree_for_diagnostic_1 (expr, &visited);\n }\n \n+/* Attempt to generate a tree for the LHS of ASSIGN_STMT.  */\n+\n+tree\n+get_diagnostic_tree_for_gassign (const gassign *assign_stmt)\n+{\n+  hash_set<tree> visited;\n+  return get_diagnostic_tree_for_gassign_1 (assign_stmt, &visited);\n+}\n+\n } // namespace ana\n \n /* Helper function for checkers.  Is the CALL to the given function name,"}, {"sha": "d42bee7eb0d0627c8860bd9a54855fcca6da9152", "filename": "gcc/analyzer/analyzer.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Fanalyzer%2Fanalyzer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Fanalyzer%2Fanalyzer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer.h?ref=33255ad3ac14e3953750fe0f2d82b901c2852ff6", "patch": "@@ -112,6 +112,7 @@ extern void print_quoted_type (pretty_printer *pp, tree t);\n extern int readability_comparator (const void *p1, const void *p2);\n extern int tree_cmp (const void *p1, const void *p2);\n extern tree fixup_tree_for_diagnostic (tree);\n+extern tree get_diagnostic_tree_for_gassign (const gassign *);\n \n /* A tree, extended with stack frame information for locals, so that\n    we can distinguish between different values of locals within a potentially"}, {"sha": "6ddb6e3abb351649f63db94f41b85f4b730f79a0", "filename": "gcc/analyzer/analyzer.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Fanalyzer%2Fanalyzer.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Fanalyzer%2Fanalyzer.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer.opt?ref=33255ad3ac14e3953750fe0f2d82b901c2852ff6", "patch": "@@ -134,6 +134,10 @@ Wanalyzer-write-to-string-literal\n Common Var(warn_analyzer_write_to_string_literal) Init(1) Warning\n Warn about code paths which attempt to write to a string literal.\n \n+Wanalyzer-use-of-uninitialized-value\n+Common Var(warn_analyzer_use_of_uninitialized_value) Init(1) Warning\n+Warn about code paths in which an uninitialized value is used.\n+\n Wanalyzer-too-complex\n Common Var(warn_analyzer_too_complex) Init(0) Warning\n Warn if the code is too complicated for the analyzer to fully explore."}, {"sha": "5b5a9dec0a98a66f4a8c1de665fbab3499362195", "filename": "gcc/analyzer/constraint-manager.cc", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Fanalyzer%2Fconstraint-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Fanalyzer%2Fconstraint-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fconstraint-manager.cc?ref=33255ad3ac14e3953750fe0f2d82b901c2852ff6", "patch": "@@ -1653,6 +1653,29 @@ on_liveness_change (const svalue_set &live_svalues,\n   purge (p, NULL);\n }\n \n+class svalue_purger\n+{\n+public:\n+  svalue_purger (const svalue *sval) : m_sval (sval) {}\n+\n+  bool should_purge_p (const svalue *sval) const\n+  {\n+    return sval->involves_p (m_sval);\n+  }\n+\n+private:\n+  const svalue *m_sval;\n+};\n+\n+/* Purge any state involving SVAL.  */\n+\n+void\n+constraint_manager::purge_state_involving (const svalue *sval)\n+{\n+  svalue_purger p (sval);\n+  purge (p, NULL);\n+}\n+\n /* Comparator for use by constraint_manager::canonicalize.\n    Sort a pair of equiv_class instances, using the representative\n    svalue as a sort key.  */"}, {"sha": "2bb3215e6309d7e84ea464ebcc4b6636c1b3847e", "filename": "gcc/analyzer/constraint-manager.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Fanalyzer%2Fconstraint-manager.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Fanalyzer%2Fconstraint-manager.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fconstraint-manager.h?ref=33255ad3ac14e3953750fe0f2d82b901c2852ff6", "patch": "@@ -269,6 +269,7 @@ class constraint_manager\n \n   void on_liveness_change (const svalue_set &live_svalues,\n \t\t\t   const region_model *model);\n+  void purge_state_involving (const svalue *sval);\n \n   void canonicalize ();\n "}, {"sha": "631fef6ad782f37bfd3b0e1e952af32f74a61447", "filename": "gcc/analyzer/diagnostic-manager.cc", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fdiagnostic-manager.cc?ref=33255ad3ac14e3953750fe0f2d82b901c2852ff6", "patch": "@@ -722,6 +722,18 @@ saved_diagnostic::add_duplicate (saved_diagnostic *other)\n   m_duplicates.safe_push (other);\n }\n \n+/* Return true if this diagnostic supercedes OTHER, and that OTHER should\n+   therefore not be emitted.  */\n+\n+bool\n+saved_diagnostic::supercedes_p (const saved_diagnostic &other) const\n+{\n+  /* They should be at the same stmt.  */\n+  if (m_stmt != other.m_stmt)\n+    return false;\n+  return m_d->supercedes_p (*other.m_d);\n+}\n+\n /* State for building a checker_path from a particular exploded_path.\n    In particular, this precomputes reachability information: the set of\n    source enodes for which a path be found to the diagnostic enode.  */\n@@ -1021,6 +1033,38 @@ class dedupe_winners\n       }\n   }\n \n+  /* Handle interactions between the dedupe winners, so that some\n+     diagnostics can supercede others (of different kinds).\n+\n+     We want use-after-free to supercede use-of-unitialized-value,\n+     so that if we have these at the same stmt, we don't emit\n+     a use-of-uninitialized, just the use-after-free.  */\n+\n+  void handle_interactions (diagnostic_manager *dm)\n+  {\n+    LOG_SCOPE (dm->get_logger ());\n+    auto_vec<const dedupe_key *> superceded;\n+    for (auto outer : m_map)\n+      {\n+\tconst saved_diagnostic *outer_sd = outer.second;\n+\tfor (auto inner : m_map)\n+\t  {\n+\t    const saved_diagnostic *inner_sd = inner.second;\n+\t    if (inner_sd->supercedes_p (*outer_sd))\n+\t      {\n+\t\tsuperceded.safe_push (outer.first);\n+\t\tif (dm->get_logger ())\n+\t\t  dm->log (\"sd[%i] \\\"%s\\\" superceded by sd[%i] \\\"%s\\\"\",\n+\t\t\t   outer_sd->get_index (), outer_sd->m_d->get_kind (),\n+\t\t\t   inner_sd->get_index (), inner_sd->m_d->get_kind ());\n+\t\tbreak;\n+\t      }\n+\t  }\n+      }\n+    for (auto iter : superceded)\n+      m_map.remove (iter);\n+  }\n+\n  /* Emit the simplest diagnostic within each set.  */\n \n   void emit_best (diagnostic_manager *dm,\n@@ -1095,6 +1139,8 @@ diagnostic_manager::emit_saved_diagnostics (const exploded_graph &eg)\n   FOR_EACH_VEC_ELT (m_saved_diagnostics, i, sd)\n     best_candidates.add (get_logger (), &pf, sd);\n \n+  best_candidates.handle_interactions (this);\n+\n   /* For each dedupe-key, call emit_saved_diagnostic on the \"best\"\n      saved_diagnostic.  */\n   best_candidates.emit_best (this, eg);"}, {"sha": "ad2eb4dfe659fb80a9caf39298c277af0ff16226", "filename": "gcc/analyzer/diagnostic-manager.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Fanalyzer%2Fdiagnostic-manager.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Fanalyzer%2Fdiagnostic-manager.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fdiagnostic-manager.h?ref=33255ad3ac14e3953750fe0f2d82b901c2852ff6", "patch": "@@ -58,6 +58,8 @@ class saved_diagnostic\n \n   unsigned get_index () const { return m_idx; }\n \n+  bool supercedes_p (const saved_diagnostic &other) const;\n+\n   //private:\n   const state_machine *m_sm;\n   const exploded_node *m_enode;"}, {"sha": "7662a7f7bab4203e90b1bbd862bf924c1f391420", "filename": "gcc/analyzer/engine.cc", "status": "modified", "additions": 104, "deletions": 146, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Fanalyzer%2Fengine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Fanalyzer%2Fengine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fengine.cc?ref=33255ad3ac14e3953750fe0f2d82b901c2852ff6", "patch": "@@ -108,14 +108,29 @@ impl_region_model_context (program_state *state,\n {\n }\n \n-void\n+bool\n impl_region_model_context::warn (pending_diagnostic *d)\n {\n   LOG_FUNC (get_logger ());\n+  if (m_stmt == NULL && m_stmt_finder == NULL)\n+    {\n+      if (get_logger ())\n+\tget_logger ()->log (\"rejecting diagnostic: no stmt\");\n+      delete d;\n+      return false;\n+    }\n   if (m_eg)\n-    m_eg->get_diagnostic_manager ().add_diagnostic\n-      (m_enode_for_diag, m_enode_for_diag->get_supernode (),\n-       m_stmt, m_stmt_finder, d);\n+    {\n+      m_eg->get_diagnostic_manager ().add_diagnostic\n+\t(m_enode_for_diag, m_enode_for_diag->get_supernode (),\n+\t m_stmt, m_stmt_finder, d);\n+      return true;\n+    }\n+  else\n+    {\n+      delete d;\n+      return false;\n+    }\n }\n \n void\n@@ -155,6 +170,19 @@ impl_region_model_context::get_uncertainty ()\n   return m_uncertainty;\n }\n \n+/* Purge state involving SVAL.  The region_model has already been purged,\n+   so we only need to purge other state in the program_state:\n+   the sm-state.  */\n+\n+void\n+impl_region_model_context::purge_state_involving (const svalue *sval)\n+{\n+  int i;\n+  sm_state_map *smap;\n+  FOR_EACH_VEC_ELT (m_new_state->m_checker_states, i, smap)\n+    smap->purge_state_involving (sval, m_ext_state);\n+}\n+\n /* struct setjmp_record.  */\n \n int\n@@ -230,16 +258,15 @@ class impl_sm_context : public sm_context\n     return model->get_fndecl_for_call (call, &old_ctxt);\n   }\n \n-  state_machine::state_t get_state (const gimple *stmt,\n+  state_machine::state_t get_state (const gimple *stmt ATTRIBUTE_UNUSED,\n \t\t\t\t    tree var)\n   {\n     logger * const logger = get_logger ();\n     LOG_FUNC (logger);\n-    impl_region_model_context old_ctxt\n-      (m_eg, m_enode_for_diag, NULL, NULL/*m_enode->get_state ()*/,\n-       NULL, stmt);\n+    /* Use NULL ctxt on this get_rvalue call to avoid triggering\n+       uninitialized value warnings.  */\n     const svalue *var_old_sval\n-      = m_old_state->m_region_model->get_rvalue (var, &old_ctxt);\n+      = m_old_state->m_region_model->get_rvalue (var, NULL);\n \n     state_machine::state_t current\n       = m_old_smap->get_state (var_old_sval, m_eg.get_ext_state ());\n@@ -263,12 +290,6 @@ class impl_sm_context : public sm_context\n   {\n     logger * const logger = get_logger ();\n     LOG_FUNC (logger);\n-    impl_region_model_context old_ctxt\n-      (m_eg, m_enode_for_diag, NULL, NULL/*m_enode->get_state ()*/,\n-       NULL, stmt);\n-    const svalue *var_old_sval\n-      = m_old_state->m_region_model->get_rvalue (var, &old_ctxt);\n-\n     impl_region_model_context new_ctxt (m_eg, m_enode_for_diag,\n \t\t\t\t\tm_old_state, m_new_state,\n \t\t\t\t\tNULL,\n@@ -278,8 +299,9 @@ class impl_sm_context : public sm_context\n     const svalue *origin_new_sval\n       = m_new_state->m_region_model->get_rvalue (origin, &new_ctxt);\n \n+    /* We use the new sval here to avoid issues with uninitialized values.  */\n     state_machine::state_t current\n-      = m_old_smap->get_state (var_old_sval, m_eg.get_ext_state ());\n+      = m_old_smap->get_state (var_new_sval, m_eg.get_ext_state ());\n     if (logger)\n       logger->log (\"%s: state transition of %qE: %s -> %s\",\n \t\t   m_sm.get_name (),\n@@ -1160,26 +1182,6 @@ fndecl_has_gimple_body_p (tree fndecl)\n \n namespace ana {\n \n-/* A pending_diagnostic subclass for implementing \"__analyzer_dump_path\".  */\n-\n-class dump_path_diagnostic\n-  : public pending_diagnostic_subclass<dump_path_diagnostic>\n-{\n-public:\n-  bool emit (rich_location *richloc) FINAL OVERRIDE\n-  {\n-    inform (richloc, \"path\");\n-    return true;\n-  }\n-\n-  const char *get_kind () const FINAL OVERRIDE { return \"dump_path_diagnostic\"; }\n-\n-  bool operator== (const dump_path_diagnostic &) const\n-  {\n-    return true;\n-  }\n-};\n-\n /* Modify STATE in place, applying the effects of the stmt at this node's\n    point.  */\n \n@@ -1218,89 +1220,8 @@ exploded_node::on_stmt (exploded_graph &eg,\n   bool unknown_side_effects = false;\n   bool terminate_path = false;\n \n-  switch (gimple_code (stmt))\n-    {\n-    default:\n-      /* No-op for now.  */\n-      break;\n-\n-    case GIMPLE_ASSIGN:\n-      {\n-\tconst gassign *assign = as_a <const gassign *> (stmt);\n-\tstate->m_region_model->on_assignment (assign, &ctxt);\n-      }\n-      break;\n-\n-    case GIMPLE_ASM:\n-      /* No-op for now.  */\n-      break;\n-\n-    case GIMPLE_CALL:\n-      {\n-\t/* Track whether we have a gcall to a function that's not recognized by\n-\t   anything, for which we don't have a function body, or for which we\n-\t   don't know the fndecl.  */\n-\tconst gcall *call = as_a <const gcall *> (stmt);\n-\n-\t/* Debugging/test support.  */\n-\tif (is_special_named_call_p (call, \"__analyzer_describe\", 2))\n-\t  state->m_region_model->impl_call_analyzer_describe (call, &ctxt);\n-\telse if (is_special_named_call_p (call, \"__analyzer_dump\", 0))\n-\t  {\n-\t    /* Handle the builtin \"__analyzer_dump\" by dumping state\n-\t       to stderr.  */\n-\t    state->dump (eg.get_ext_state (), true);\n-\t  }\n-\telse if (is_special_named_call_p (call, \"__analyzer_dump_capacity\", 1))\n-\t  state->m_region_model->impl_call_analyzer_dump_capacity (call, &ctxt);\n-\telse if (is_special_named_call_p (call, \"__analyzer_dump_path\", 0))\n-\t  {\n-\t    /* Handle the builtin \"__analyzer_dump_path\" by queuing a\n-\t       diagnostic at this exploded_node.  */\n-\t    ctxt.warn (new dump_path_diagnostic ());\n-\t  }\n-\telse if (is_special_named_call_p (call, \"__analyzer_dump_region_model\",\n-\t\t\t\t\t  0))\n-\t  {\n-\t    /* Handle the builtin \"__analyzer_dump_region_model\" by dumping\n-\t       the region model's state to stderr.  */\n-\t    state->m_region_model->dump (false);\n-\t  }\n-\telse if (is_special_named_call_p (call, \"__analyzer_eval\", 1))\n-\t  state->m_region_model->impl_call_analyzer_eval (call, &ctxt);\n-\telse if (is_special_named_call_p (call, \"__analyzer_break\", 0))\n-\t  {\n-\t    /* Handle the builtin \"__analyzer_break\" by triggering a\n-\t       breakpoint.  */\n-\t    /* TODO: is there a good cross-platform way to do this?  */\n-\t    raise (SIGINT);\n-\t  }\n-\telse if (is_special_named_call_p (call,\n-\t\t\t\t\t  \"__analyzer_dump_exploded_nodes\",\n-\t\t\t\t\t  1))\n-\t  {\n-\t    /* This is handled elsewhere.  */\n-\t  }\n-\telse if (is_setjmp_call_p (call))\n-\t  state->m_region_model->on_setjmp (call, this, &ctxt);\n-\telse if (is_longjmp_call_p (call))\n-\t  {\n-\t    on_longjmp (eg, call, state, &ctxt);\n-\t    return on_stmt_flags::terminate_path ();\n-\t  }\n-\telse\n-\t  unknown_side_effects\n-\t    = state->m_region_model->on_call_pre (call, &ctxt, &terminate_path);\n-      }\n-      break;\n-\n-    case GIMPLE_RETURN:\n-      {\n-\tconst greturn *return_ = as_a <const greturn *> (stmt);\n-\tstate->m_region_model->on_return (return_, &ctxt);\n-      }\n-      break;\n-    }\n+  on_stmt_pre (eg, stmt, state, &terminate_path,\n+\t       &unknown_side_effects, &ctxt);\n \n   if (terminate_path)\n     return on_stmt_flags::terminate_path ();\n@@ -1316,41 +1237,71 @@ exploded_node::on_stmt (exploded_graph &eg,\n       impl_sm_context sm_ctxt (eg, sm_idx, sm, this, &old_state, state,\n \t\t\t       old_smap, new_smap);\n \n-      /* If we're at the def-stmt of an SSA name, then potentially purge\n-\t any sm-state for svalues that involve that SSA name.  This avoids\n-\t false positives in loops, since a symbolic value referring to the\n-\t SSA name will be referring to the previous value of that SSA name.\n-\t For example, in:\n-\t   while ((e = hashmap_iter_next(&iter))) {\n-\t     struct oid2strbuf *e_strbuf = (struct oid2strbuf *)e;\n-\t     free (e_strbuf->value);\n-\t   }\n-\t at the def-stmt of e_8:\n-\t   e_8 = hashmap_iter_next (&iter);\n-\t we should purge the \"freed\" state of:\n-\t   INIT_VAL(CAST_REG(\u2018struct oid2strbuf\u2019, (*INIT_VAL(e_8))).value)\n-\t which is the \"e_strbuf->value\" value from the previous iteration,\n-\t or we will erroneously report a double-free - the \"e_8\" within it\n-\t refers to the previous value.  */\n-      if (tree lhs = gimple_get_lhs (stmt))\n-\tif (TREE_CODE (lhs) == SSA_NAME)\n-\t  {\n-\t    const svalue *sval\n-\t      = old_state.m_region_model->get_rvalue (lhs, &ctxt);\n-\t    new_smap->purge_state_involving (sval, eg.get_ext_state ());\n-\t  }\n-\n       /* Allow the state_machine to handle the stmt.  */\n       if (sm.on_stmt (&sm_ctxt, snode, stmt))\n \tunknown_side_effects = false;\n     }\n \n-  if (const gcall *call = dyn_cast <const gcall *> (stmt))\n-    state->m_region_model->on_call_post (call, unknown_side_effects, &ctxt);\n+  on_stmt_post (stmt, state, unknown_side_effects, &ctxt);\n \n   return on_stmt_flags ();\n }\n \n+/* Handle the pre-sm-state part of STMT, modifying STATE in-place.\n+   Write true to *OUT_TERMINATE_PATH if the path should be terminated.\n+   Write true to *OUT_UNKNOWN_SIDE_EFFECTS if the stmt has unknown\n+   side effects.  */\n+\n+void\n+exploded_node::on_stmt_pre (exploded_graph &eg,\n+\t\t\t    const gimple *stmt,\n+\t\t\t    program_state *state,\n+\t\t\t    bool *out_terminate_path,\n+\t\t\t    bool *out_unknown_side_effects,\n+\t\t\t    region_model_context *ctxt)\n+{\n+  /* Handle special-case calls that require the full program_state.  */\n+  if (const gcall *call = dyn_cast <const gcall *> (stmt))\n+    {\n+      if (is_special_named_call_p (call, \"__analyzer_dump\", 0))\n+\t{\n+\t  /* Handle the builtin \"__analyzer_dump\" by dumping state\n+\t     to stderr.  */\n+\t  state->dump (eg.get_ext_state (), true);\n+\t  return;\n+\t}\n+      else if (is_setjmp_call_p (call))\n+\t{\n+\t  state->m_region_model->on_setjmp (call, this, ctxt);\n+\t  return;\n+\t}\n+      else if (is_longjmp_call_p (call))\n+\t{\n+\t  on_longjmp (eg, call, state, ctxt);\n+\t  *out_terminate_path = true;\n+\t  return;\n+\t}\n+    }\n+\n+  /* Otherwise, defer to m_region_model.  */\n+  state->m_region_model->on_stmt_pre (stmt,\n+\t\t\t\t      out_terminate_path,\n+\t\t\t\t      out_unknown_side_effects,\n+\t\t\t\t      ctxt);\n+}\n+\n+/* Handle the post-sm-state part of STMT, modifying STATE in-place.  */\n+\n+void\n+exploded_node::on_stmt_post (const gimple *stmt,\n+\t\t\t     program_state *state,\n+\t\t\t     bool unknown_side_effects,\n+\t\t\t     region_model_context *ctxt)\n+{\n+  if (const gcall *call = dyn_cast <const gcall *> (stmt))\n+    state->m_region_model->on_call_post (call, unknown_side_effects, ctxt);\n+}\n+\n /* Consider the effect of following superedge SUCC from this node.\n \n    Return true if it's feasible to follow the edge, or false\n@@ -1415,7 +1366,7 @@ valid_longjmp_stack_p (const program_point &longjmp_point,\n    where the enclosing function of the \"setjmp\" has returned (and thus\n    the stack frame no longer exists).  */\n \n-class stale_jmp_buf : public pending_diagnostic_subclass<dump_path_diagnostic>\n+class stale_jmp_buf : public pending_diagnostic_subclass<stale_jmp_buf>\n {\n public:\n   stale_jmp_buf (const gcall *setjmp_call, const gcall *longjmp_call,\n@@ -3763,6 +3714,13 @@ feasibility_state::maybe_update_for_edge (logger *logger,\n \n       if (const gassign *assign = dyn_cast <const gassign *> (stmt))\n \tm_model.on_assignment (assign, NULL);\n+      else if (const gcall *call = dyn_cast <const gcall *> (stmt))\n+\t{\n+\t  bool terminate_path;\n+\t  bool unknown_side_effects\n+\t    = m_model.on_call_pre (call, NULL, &terminate_path);\n+\t  m_model.on_call_post (call, unknown_side_effects, NULL);\n+\t}\n       else if (const greturn *return_ = dyn_cast <const greturn *> (stmt))\n \tm_model.on_return (return_, NULL);\n     }"}, {"sha": "8f48d8a286c5391344785c8db664f399e3c54d2b", "filename": "gcc/analyzer/exploded-graph.h", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Fanalyzer%2Fexploded-graph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Fanalyzer%2Fexploded-graph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fexploded-graph.h?ref=33255ad3ac14e3953750fe0f2d82b901c2852ff6", "patch": "@@ -46,7 +46,7 @@ class impl_region_model_context : public region_model_context\n \t\t\t     uncertainty_t *uncertainty,\n \t\t\t     logger *logger = NULL);\n \n-  void warn (pending_diagnostic *d) FINAL OVERRIDE;\n+  bool warn (pending_diagnostic *d) FINAL OVERRIDE;\n   void on_svalue_leak (const svalue *) OVERRIDE;\n   void on_liveness_change (const svalue_set &live_svalues,\n \t\t\t   const region_model *model) FINAL OVERRIDE;\n@@ -74,6 +74,8 @@ class impl_region_model_context : public region_model_context\n \n   uncertainty_t *get_uncertainty () FINAL OVERRIDE;\n \n+  void purge_state_involving (const svalue *sval) FINAL OVERRIDE;\n+\n   exploded_graph *m_eg;\n   log_user m_logger;\n   exploded_node *m_enode_for_diag;\n@@ -223,6 +225,17 @@ class exploded_node : public dnode<eg_traits>\n \t\t\t const gimple *stmt,\n \t\t\t program_state *state,\n \t\t\t uncertainty_t *uncertainty);\n+  void on_stmt_pre (exploded_graph &eg,\n+\t\t    const gimple *stmt,\n+\t\t    program_state *state,\n+\t\t    bool *out_terminate_path,\n+\t\t    bool *out_unknown_side_effects,\n+\t\t    region_model_context *ctxt);\n+  void on_stmt_post (const gimple *stmt,\n+\t\t     program_state *state,\n+\t\t     bool unknown_side_effects,\n+\t\t     region_model_context *ctxt);\n+\n   bool on_edge (exploded_graph &eg,\n \t\tconst superedge *succ,\n \t\tprogram_point *next_point,"}, {"sha": "48e2b3ec1718b6189af45f6bf0538a1cfe022f99", "filename": "gcc/analyzer/pending-diagnostic.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Fanalyzer%2Fpending-diagnostic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Fanalyzer%2Fpending-diagnostic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fpending-diagnostic.h?ref=33255ad3ac14e3953750fe0f2d82b901c2852ff6", "patch": "@@ -154,6 +154,9 @@ class pending_diagnostic\n   /* Hand-coded RTTI: get an ID for the subclass.  */\n   virtual const char *get_kind () const = 0;\n \n+  /* A vfunc for identifying \"use of uninitialized value\".  */\n+  virtual bool use_of_uninit_p () const { return false; }\n+\n   /* Compare for equality with OTHER, which might be of a different\n      subclass.  */\n \n@@ -269,6 +272,16 @@ class pending_diagnostic\n   {\n     return false;\n   }\n+\n+  /* Vfunc for determining that this pending_diagnostic supercedes OTHER,\n+     and that OTHER should therefore not be emitted.\n+     They have already been tested for being at the same stmt.  */\n+\n+  virtual bool\n+  supercedes_p (const pending_diagnostic &other ATTRIBUTE_UNUSED) const\n+  {\n+    return false;\n+  }\n };\n \n /* A template to make it easier to make subclasses of pending_diagnostic."}, {"sha": "23cfcb032c6ec38cc07dc132849b7648d0164039", "filename": "gcc/analyzer/program-state.cc", "status": "modified", "additions": 27, "deletions": 16, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Fanalyzer%2Fprogram-state.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Fanalyzer%2Fprogram-state.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fprogram-state.cc?ref=33255ad3ac14e3953750fe0f2d82b901c2852ff6", "patch": "@@ -372,21 +372,31 @@ sm_state_map::get_state (const svalue *sval,\n      INIT_VAL(foo).  */\n   if (m_sm.inherited_state_p ())\n     if (region_model_manager *mgr = ext_state.get_model_manager ())\n-      if (const initial_svalue *init_sval = sval->dyn_cast_initial_svalue ())\n-\t{\n-\t  const region *reg = init_sval->get_region ();\n-\t  /* Try recursing upwards (up to the base region for the cluster).  */\n-\t  if (!reg->base_region_p ())\n-\t    if (const region *parent_reg = reg->get_parent_region ())\n-\t      {\n-\t\tconst svalue *parent_init_sval\n-\t\t  = mgr->get_or_create_initial_value (parent_reg);\n-\t\tstate_machine::state_t parent_state\n-\t\t  = get_state (parent_init_sval, ext_state);\n-\t\tif (parent_state)\n-\t\t  return parent_state;\n-\t      }\n-\t}\n+      {\n+\tif (const initial_svalue *init_sval = sval->dyn_cast_initial_svalue ())\n+\t  {\n+\t    const region *reg = init_sval->get_region ();\n+\t    /* Try recursing upwards (up to the base region for the\n+\t       cluster).  */\n+\t    if (!reg->base_region_p ())\n+\t      if (const region *parent_reg = reg->get_parent_region ())\n+\t\t{\n+\t\t  const svalue *parent_init_sval\n+\t\t    = mgr->get_or_create_initial_value (parent_reg);\n+\t\t  state_machine::state_t parent_state\n+\t\t    = get_state (parent_init_sval, ext_state);\n+\t\t  if (parent_state)\n+\t\t    return parent_state;\n+\t\t}\n+\t  }\n+\telse if (const sub_svalue *sub_sval = sval->dyn_cast_sub_svalue ())\n+\t  {\n+\t    const svalue *parent_sval = sub_sval->get_parent ();\n+\t    if (state_machine::state_t parent_state\n+\t\t  = get_state (parent_sval, ext_state))\n+\t      return parent_state;\n+\t  }\n+      }\n \n   return m_sm.get_default_state (sval);\n }\n@@ -596,7 +606,8 @@ sm_state_map::purge_state_involving (const svalue *sval,\n \t\t\t\t     const extrinsic_state &ext_state)\n {\n   /* Currently svalue::involves_p requires this.  */\n-  if (sval->get_kind () != SK_INITIAL)\n+  if (!(sval->get_kind () == SK_INITIAL\n+\t|| sval->get_kind () == SK_CONJURED))\n     return;\n \n   svalue_set svals_to_unset;"}, {"sha": "4be6550f07f30b038c9814880ebd441e3837836d", "filename": "gcc/analyzer/region-model-impl-calls.cc", "status": "modified", "additions": 49, "deletions": 1, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc?ref=33255ad3ac14e3953750fe0f2d82b901c2852ff6", "patch": "@@ -84,7 +84,10 @@ call_details::call_details (const gcall *call, region_model *model,\n uncertainty_t *\n call_details::get_uncertainty () const\n {\n-  return m_ctxt->get_uncertainty ();\n+  if (m_ctxt)\n+    return m_ctxt->get_uncertainty ();\n+  else\n+    return NULL;\n }\n \n /* If the callsite has a left-hand-side region, set it to RESULT\n@@ -173,6 +176,15 @@ call_details::dump (bool simple) const\n   pp_flush (&pp);\n }\n \n+/* Get a conjured_svalue for this call for REG.  */\n+\n+const svalue *\n+call_details::get_or_create_conjured_svalue (const region *reg) const\n+{\n+  region_model_manager *mgr = m_model->get_manager ();\n+  return mgr->get_or_create_conjured_svalue (reg->get_type (), m_call, reg);\n+}\n+\n /* Implementations of specific functions.  */\n \n /* Handle the on_call_pre part of \"alloca\".  */\n@@ -305,6 +317,42 @@ region_model::impl_call_error (const call_details &cd, unsigned min_args,\n   return true;\n }\n \n+/* Handle the on_call_pre part of \"fgets\" and \"fgets_unlocked\".  */\n+\n+void\n+region_model::impl_call_fgets (const call_details &cd)\n+{\n+  /* Ideally we would bifurcate state here between the\n+     error vs no error cases.  */\n+  const svalue *ptr_sval = cd.get_arg_svalue (0);\n+  if (const region_svalue *ptr_to_region_sval\n+      = ptr_sval->dyn_cast_region_svalue ())\n+    {\n+      const region *reg = ptr_to_region_sval->get_pointee ();\n+      const region *base_reg = reg->get_base_region ();\n+      const svalue *new_sval = cd.get_or_create_conjured_svalue (base_reg);\n+      purge_state_involving (new_sval, cd.get_ctxt ());\n+      set_value (base_reg, new_sval, cd.get_ctxt ());\n+    }\n+}\n+\n+/* Handle the on_call_pre part of \"fread\".  */\n+\n+void\n+region_model::impl_call_fread (const call_details &cd)\n+{\n+  const svalue *ptr_sval = cd.get_arg_svalue (0);\n+  if (const region_svalue *ptr_to_region_sval\n+      = ptr_sval->dyn_cast_region_svalue ())\n+    {\n+      const region *reg = ptr_to_region_sval->get_pointee ();\n+      const region *base_reg = reg->get_base_region ();\n+      const svalue *new_sval = cd.get_or_create_conjured_svalue (base_reg);\n+      purge_state_involving (new_sval, cd.get_ctxt ());\n+      set_value (base_reg, new_sval, cd.get_ctxt ());\n+    }\n+}\n+\n /* Handle the on_call_post part of \"free\", after sm-handling.\n \n    If the ptr points to an underlying heap region, delete the region,"}, {"sha": "7a52a64bbb3245fb3af2d1ff7166189b67041c54", "filename": "gcc/analyzer/region-model-manager.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Fanalyzer%2Fregion-model-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Fanalyzer%2Fregion-model-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-manager.cc?ref=33255ad3ac14e3953750fe0f2d82b901c2852ff6", "patch": "@@ -252,6 +252,10 @@ region_model_manager::get_or_create_unknown_svalue (tree type)\n const svalue *\n region_model_manager::get_or_create_initial_value (const region *reg)\n {\n+  if (!reg->can_have_initial_svalue_p ())\n+    return get_or_create_poisoned_svalue (POISON_KIND_UNINIT,\n+\t\t\t\t\t  reg->get_type ());\n+\n   /* The initial value of a cast is a cast of the initial value.  */\n   if (const cast_region *cast_reg = reg->dyn_cast_cast_region ())\n     {"}, {"sha": "1f65307e3946da2c8083698845eff4a7e8597de7", "filename": "gcc/analyzer/region-model-reachability.cc", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Fanalyzer%2Fregion-model-reachability.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Fanalyzer%2Fregion-model-reachability.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-reachability.cc?ref=33255ad3ac14e3953750fe0f2d82b901c2852ff6", "patch": "@@ -267,7 +267,6 @@ reachable_regions::handle_parm (const svalue *sval, tree param_type)\n void\n reachable_regions::mark_escaped_clusters (region_model_context *ctxt)\n {\n-  gcc_assert (ctxt);\n   auto_vec<const function_region *> escaped_fn_regs\n     (m_mutable_base_regs.elements ());\n   for (hash_set<const region *>::iterator iter = m_mutable_base_regs.begin ();\n@@ -281,12 +280,15 @@ reachable_regions::mark_escaped_clusters (region_model_context *ctxt)\n       if (const function_region *fn_reg = base_reg->dyn_cast_function_region ())\n \tescaped_fn_regs.quick_push (fn_reg);\n     }\n-  /* Sort to ensure deterministic results.  */\n-  escaped_fn_regs.qsort (region::cmp_ptr_ptr);\n-  unsigned i;\n-  const function_region *fn_reg;\n-  FOR_EACH_VEC_ELT (escaped_fn_regs, i, fn_reg)\n-    ctxt->on_escaped_function (fn_reg->get_fndecl ());\n+  if (ctxt)\n+    {\n+      /* Sort to ensure deterministic results.  */\n+      escaped_fn_regs.qsort (region::cmp_ptr_ptr);\n+      unsigned i;\n+      const function_region *fn_reg;\n+      FOR_EACH_VEC_ELT (escaped_fn_regs, i, fn_reg)\n+\tctxt->on_escaped_function (fn_reg->get_fndecl ());\n+    }\n }\n \n /* Dump SET to PP, sorting it to avoid churn when comparing dumps.  */"}, {"sha": "3fe2cce229bf1f1c7715847493f933b693d32de8", "filename": "gcc/analyzer/region-model.cc", "status": "modified", "additions": 243, "deletions": 18, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Fanalyzer%2Fregion-model.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Fanalyzer%2Fregion-model.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.cc?ref=33255ad3ac14e3953750fe0f2d82b901c2852ff6", "patch": "@@ -221,6 +221,23 @@ region_to_value_map::can_merge_with_p (const region_to_value_map &other,\n   return true;\n }\n \n+/* Purge any state involving SVAL.  */\n+\n+void\n+region_to_value_map::purge_state_involving (const svalue *sval)\n+{\n+  auto_vec<const region *> to_purge;\n+  for (auto iter : *this)\n+    {\n+      const region *iter_reg = iter.first;\n+      const svalue *iter_sval = iter.second;\n+      if (iter_reg->involves_p (sval) || iter_sval->involves_p (sval))\n+\tto_purge.safe_push (iter_reg);\n+    }\n+  for (auto iter : to_purge)\n+    m_hash_map.remove (iter);\n+}\n+\n /* class region_model.  */\n \n /* Ctor for region_model: construct an \"empty\" model.  */\n@@ -442,6 +459,11 @@ class poisoned_value_diagnostic\n \n   const char *get_kind () const FINAL OVERRIDE { return \"poisoned_value_diagnostic\"; }\n \n+  bool use_of_uninit_p () const FINAL OVERRIDE\n+  {\n+    return m_pkind == POISON_KIND_UNINIT;\n+  }\n+\n   bool operator== (const poisoned_value_diagnostic &other) const\n   {\n     return m_expr == other.m_expr;\n@@ -453,6 +475,16 @@ class poisoned_value_diagnostic\n       {\n       default:\n \tgcc_unreachable ();\n+      case POISON_KIND_UNINIT:\n+\t{\n+\t  diagnostic_metadata m;\n+\t  m.add_cwe (457); /* \"CWE-457: Use of Uninitialized Variable\".  */\n+\t  return warning_meta (rich_loc, m,\n+\t\t\t       OPT_Wanalyzer_use_of_uninitialized_value,\n+\t\t\t       \"use of uninitialized value %qE\",\n+\t\t\t       m_expr);\n+\t}\n+\tbreak;\n       case POISON_KIND_FREED:\n \t{\n \t  diagnostic_metadata m;\n@@ -482,6 +514,9 @@ class poisoned_value_diagnostic\n       {\n       default:\n \tgcc_unreachable ();\n+      case POISON_KIND_UNINIT:\n+\treturn ev.formatted_print (\"use of uninitialized value %qE here\",\n+\t\t\t\t   m_expr);\n       case POISON_KIND_FREED:\n \treturn ev.formatted_print (\"use after %<free%> of %qE here\",\n \t\t\t\t   m_expr);\n@@ -782,6 +817,41 @@ region_model::get_gassign_result (const gassign *assign,\n     }\n }\n \n+/* Check for SVAL being poisoned, adding a warning to CTXT.\n+   Return SVAL, or, if a warning is added, another value, to avoid\n+   repeatedly complaining about the same poisoned value in followup code.  */\n+\n+const svalue *\n+region_model::check_for_poison (const svalue *sval,\n+\t\t\t\ttree expr,\n+\t\t\t\tregion_model_context *ctxt) const\n+{\n+  if (!ctxt)\n+    return sval;\n+\n+  if (const poisoned_svalue *poisoned_sval = sval->dyn_cast_poisoned_svalue ())\n+    {\n+      /* If we have an SSA name for a temporary, we don't want to print\n+\t '<unknown>'.\n+\t Poisoned values are shared by type, and so we can't reconstruct\n+\t the tree other than via the def stmts, using\n+\t fixup_tree_for_diagnostic.  */\n+      tree diag_arg = fixup_tree_for_diagnostic (expr);\n+      enum poison_kind pkind = poisoned_sval->get_poison_kind ();\n+      if (ctxt->warn (new poisoned_value_diagnostic (diag_arg, pkind)))\n+\t{\n+\t  /* We only want to report use of a poisoned value at the first\n+\t     place it gets used; return an unknown value to avoid generating\n+\t     a chain of followup warnings.  */\n+\t  sval = m_mgr->get_or_create_unknown_svalue (sval->get_type ());\n+\t}\n+\n+      return sval;\n+    }\n+\n+  return sval;\n+}\n+\n /* Update this model for the ASSIGN stmt, using CTXT to report any\n    diagnostics.  */\n \n@@ -798,6 +868,8 @@ region_model::on_assignment (const gassign *assign, region_model_context *ctxt)\n      for some SVALUE.  */\n   if (const svalue *sval = get_gassign_result (assign, ctxt))\n     {\n+      tree expr = get_diagnostic_tree_for_gassign (assign);\n+      check_for_poison (sval, expr, ctxt);\n       set_value (lhs_reg, sval, ctxt);\n       return;\n     }\n@@ -863,6 +935,109 @@ region_model::on_assignment (const gassign *assign, region_model_context *ctxt)\n     }\n }\n \n+/* A pending_diagnostic subclass for implementing \"__analyzer_dump_path\".  */\n+\n+class dump_path_diagnostic\n+  : public pending_diagnostic_subclass<dump_path_diagnostic>\n+{\n+public:\n+  bool emit (rich_location *richloc) FINAL OVERRIDE\n+  {\n+    inform (richloc, \"path\");\n+    return true;\n+  }\n+\n+  const char *get_kind () const FINAL OVERRIDE { return \"dump_path_diagnostic\"; }\n+\n+  bool operator== (const dump_path_diagnostic &) const\n+  {\n+    return true;\n+  }\n+};\n+\n+/* Handle the pre-sm-state part of STMT, modifying this object in-place.\n+   Write true to *OUT_TERMINATE_PATH if the path should be terminated.\n+   Write true to *OUT_UNKNOWN_SIDE_EFFECTS if the stmt has unknown\n+   side effects.  */\n+\n+void\n+region_model::on_stmt_pre (const gimple *stmt,\n+\t\t\t   bool *out_terminate_path,\n+\t\t\t   bool *out_unknown_side_effects,\n+\t\t\t   region_model_context *ctxt)\n+{\n+  switch (gimple_code (stmt))\n+    {\n+    default:\n+      /* No-op for now.  */\n+      break;\n+\n+    case GIMPLE_ASSIGN:\n+      {\n+\tconst gassign *assign = as_a <const gassign *> (stmt);\n+\ton_assignment (assign, ctxt);\n+      }\n+      break;\n+\n+    case GIMPLE_ASM:\n+      /* No-op for now.  */\n+      break;\n+\n+    case GIMPLE_CALL:\n+      {\n+\t/* Track whether we have a gcall to a function that's not recognized by\n+\t   anything, for which we don't have a function body, or for which we\n+\t   don't know the fndecl.  */\n+\tconst gcall *call = as_a <const gcall *> (stmt);\n+\n+\t/* Debugging/test support.  */\n+\tif (is_special_named_call_p (call, \"__analyzer_describe\", 2))\n+\t  impl_call_analyzer_describe (call, ctxt);\n+\telse if (is_special_named_call_p (call, \"__analyzer_dump_capacity\", 1))\n+\t  impl_call_analyzer_dump_capacity (call, ctxt);\n+\telse if (is_special_named_call_p (call, \"__analyzer_dump_path\", 0))\n+\t  {\n+\t    /* Handle the builtin \"__analyzer_dump_path\" by queuing a\n+\t       diagnostic at this exploded_node.  */\n+\t    ctxt->warn (new dump_path_diagnostic ());\n+\t  }\n+\telse if (is_special_named_call_p (call, \"__analyzer_dump_region_model\",\n+\t\t\t\t\t  0))\n+\t  {\n+\t    /* Handle the builtin \"__analyzer_dump_region_model\" by dumping\n+\t       the region model's state to stderr.  */\n+\t    dump (false);\n+\t  }\n+\telse if (is_special_named_call_p (call, \"__analyzer_eval\", 1))\n+\t  impl_call_analyzer_eval (call, ctxt);\n+\telse if (is_special_named_call_p (call, \"__analyzer_break\", 0))\n+\t  {\n+\t    /* Handle the builtin \"__analyzer_break\" by triggering a\n+\t       breakpoint.  */\n+\t    /* TODO: is there a good cross-platform way to do this?  */\n+\t    raise (SIGINT);\n+\t  }\n+\telse if (is_special_named_call_p (call,\n+\t\t\t\t\t  \"__analyzer_dump_exploded_nodes\",\n+\t\t\t\t\t  1))\n+\t  {\n+\t    /* This is handled elsewhere.  */\n+\t  }\n+\telse\n+\t  *out_unknown_side_effects = on_call_pre (call, ctxt,\n+\t\t\t\t\t\t   out_terminate_path);\n+      }\n+      break;\n+\n+    case GIMPLE_RETURN:\n+      {\n+\tconst greturn *return_ = as_a <const greturn *> (stmt);\n+\ton_return (return_, ctxt);\n+      }\n+      break;\n+    }\n+}\n+\n /* Update this model for the CALL stmt, using CTXT to report any\n    diagnostics - the first half.\n \n@@ -885,6 +1060,22 @@ region_model::on_call_pre (const gcall *call, region_model_context *ctxt,\n \n   bool unknown_side_effects = false;\n \n+  /* Some of the cases below update the lhs of the call based on the\n+     return value, but not all.  Provide a default value, which may\n+     get overwritten below.  */\n+  if (tree lhs = gimple_call_lhs (call))\n+    {\n+      const region *lhs_region = get_lvalue (lhs, ctxt);\n+      if (TREE_CODE (lhs) == SSA_NAME)\n+\t{\n+\t  const svalue *sval\n+\t    = m_mgr->get_or_create_conjured_svalue (TREE_TYPE (lhs), call,\n+\t\t\t\t\t\t    lhs_region);\n+\t  purge_state_involving (sval, ctxt);\n+\t  set_value (lhs_region, sval, ctxt);\n+\t}\n+    }\n+\n   if (gimple_call_internal_p (call))\n     {\n       switch (gimple_call_internal_fn (call))\n@@ -994,6 +1185,17 @@ region_model::on_call_pre (const gcall *call, region_model_context *ctxt,\n \t  else\n \t    unknown_side_effects = true;\n \t}\n+      else if (is_named_call_p (callee_fndecl, \"fgets\", call, 3)\n+\t       || is_named_call_p (callee_fndecl, \"fgets_unlocked\", call, 3))\n+\t{\n+\t  impl_call_fgets (cd);\n+\t  return false;\n+\t}\n+      else if (is_named_call_p (callee_fndecl, \"fread\", call, 4))\n+\t{\n+\t  impl_call_fread (cd);\n+\t  return false;\n+\t}\n       else if (is_named_call_p (callee_fndecl, \"getchar\", call, 0))\n \t{\n \t  /* No side-effects (tracking stream state is out-of-scope\n@@ -1029,19 +1231,6 @@ region_model::on_call_pre (const gcall *call, region_model_context *ctxt,\n   else\n     unknown_side_effects = true;\n \n-  /* Some of the above cases update the lhs of the call based on the\n-     return value.  If we get here, it hasn't been done yet, so do that\n-     now.  */\n-  if (tree lhs = gimple_call_lhs (call))\n-    {\n-      const region *lhs_region = get_lvalue (lhs, ctxt);\n-      if (TREE_CODE (lhs) == SSA_NAME)\n-\t{\n-\t  const svalue *sval = m_mgr->get_or_create_initial_value (lhs_region);\n-\t  set_value (lhs_region, sval, ctxt);\n-\t}\n-    }\n-\n   return unknown_side_effects;\n }\n \n@@ -1090,6 +1279,38 @@ region_model::on_call_post (const gcall *call,\n     handle_unrecognized_call (call, ctxt);\n }\n \n+/* Purge state involving SVAL from this region_model, using CTXT\n+   (if non-NULL) to purge other state in a program_state.\n+\n+   For example, if we're at the def-stmt of an SSA name, then we need to\n+   purge any state for svalues that involve that SSA name.  This avoids\n+   false positives in loops, since a symbolic value referring to the\n+   SSA name will be referring to the previous value of that SSA name.\n+\n+   For example, in:\n+     while ((e = hashmap_iter_next(&iter))) {\n+       struct oid2strbuf *e_strbuf = (struct oid2strbuf *)e;\n+       free (e_strbuf->value);\n+     }\n+   at the def-stmt of e_8:\n+     e_8 = hashmap_iter_next (&iter);\n+   we should purge the \"freed\" state of:\n+     INIT_VAL(CAST_REG(\u2018struct oid2strbuf\u2019, (*INIT_VAL(e_8))).value)\n+   which is the \"e_strbuf->value\" value from the previous iteration,\n+   or we will erroneously report a double-free - the \"e_8\" within it\n+   refers to the previous value.  */\n+\n+void\n+region_model::purge_state_involving (const svalue *sval,\n+\t\t\t\t     region_model_context *ctxt)\n+{\n+  m_store.purge_state_involving (sval, m_mgr);\n+  m_constraints->purge_state_involving (sval);\n+  m_dynamic_extents.purge_state_involving (sval);\n+  if (ctxt)\n+    ctxt->purge_state_involving (sval);\n+}\n+\n /* Handle a call CALL to a function with unknown behavior.\n \n    Traverse the regions in this model, determining what regions are\n@@ -1135,7 +1356,7 @@ region_model::handle_unrecognized_call (const gcall *call,\n       }\n   }\n \n-  uncertainty_t *uncertainty = ctxt->get_uncertainty ();\n+  uncertainty_t *uncertainty = ctxt ? ctxt->get_uncertainty () : NULL;\n \n   /* Purge sm-state for the svalues that were reachable,\n      both in non-mutable and mutable form.  */\n@@ -1144,14 +1365,16 @@ region_model::handle_unrecognized_call (const gcall *call,\n        iter != reachable_regs.end_reachable_svals (); ++iter)\n     {\n       const svalue *sval = (*iter);\n-      ctxt->on_unknown_change (sval, false);\n+      if (ctxt)\n+\tctxt->on_unknown_change (sval, false);\n     }\n   for (svalue_set::iterator iter\n \t = reachable_regs.begin_mutable_svals ();\n        iter != reachable_regs.end_mutable_svals (); ++iter)\n     {\n       const svalue *sval = (*iter);\n-      ctxt->on_unknown_change (sval, true);\n+      if (ctxt)\n+\tctxt->on_unknown_change (sval, true);\n       if (uncertainty)\n \tuncertainty->on_mutable_sval_at_unknown_call (sval);\n     }\n@@ -1603,6 +1826,8 @@ region_model::get_rvalue (path_var pv, region_model_context *ctxt) const\n \n   assert_compat_types (result_sval->get_type (), TREE_TYPE (pv.m_tree));\n \n+  result_sval = check_for_poison (result_sval, pv.m_tree, ctxt);\n+\n   return result_sval;\n }\n \n@@ -4307,7 +4532,7 @@ test_stack_frames ()\n \n   /* Verify that p (which was pointing at the local \"x\" in the popped\n      frame) has been poisoned.  */\n-  const svalue *new_p_sval = model.get_rvalue (p, &ctxt);\n+  const svalue *new_p_sval = model.get_rvalue (p, NULL);\n   ASSERT_EQ (new_p_sval->get_kind (), SK_POISONED);\n   ASSERT_EQ (new_p_sval->dyn_cast_poisoned_svalue ()->get_poison_kind (),\n \t     POISON_KIND_POPPED_STACK);\n@@ -5397,7 +5622,7 @@ test_alloca ()\n   /* Verify that the pointers to the alloca region are replaced by\n      poisoned values when the frame is popped.  */\n   model.pop_frame (NULL, NULL, &ctxt);\n-  ASSERT_EQ (model.get_rvalue (p, &ctxt)->get_kind (), SK_POISONED);\n+  ASSERT_EQ (model.get_rvalue (p, NULL)->get_kind (), SK_POISONED);\n }\n \n /* Verify that svalue::involves_p works.  */"}, {"sha": "71f6b3ee11ef4b82a68f14ea436a5dd0f04b344e", "filename": "gcc/analyzer/region-model.h", "status": "modified", "additions": 29, "deletions": 3, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Fanalyzer%2Fregion-model.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Fanalyzer%2Fregion-model.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.h?ref=33255ad3ac14e3953750fe0f2d82b901c2852ff6", "patch": "@@ -171,6 +171,8 @@ class region_to_value_map\n   bool can_merge_with_p (const region_to_value_map &other,\n \t\t\t region_to_value_map *out) const;\n \n+  void purge_state_involving (const svalue *sval);\n+\n private:\n   hash_map_t m_hash_map;\n };\n@@ -470,6 +472,8 @@ class call_details\n   void dump_to_pp (pretty_printer *pp, bool simple) const;\n   void dump (bool simple) const;\n \n+  const svalue *get_or_create_conjured_svalue (const region *) const;\n+\n private:\n   const gcall *m_call;\n   region_model *m_model;\n@@ -518,6 +522,12 @@ class region_model\n   void canonicalize ();\n   bool canonicalized_p () const;\n \n+  void\n+  on_stmt_pre (const gimple *stmt,\n+\t       bool *out_terminate_path,\n+\t       bool *out_unknown_side_effects,\n+\t       region_model_context *ctxt);\n+\n   void on_assignment (const gassign *stmt, region_model_context *ctxt);\n   const svalue *get_gassign_result (const gassign *assign,\n \t\t\t\t    region_model_context *ctxt);\n@@ -527,6 +537,8 @@ class region_model\n \t\t     bool unknown_side_effects,\n \t\t     region_model_context *ctxt);\n \n+  void purge_state_involving (const svalue *sval, region_model_context *ctxt);\n+\n   /* Specific handling for on_call_pre.  */\n   bool impl_call_alloca (const call_details &cd);\n   void impl_call_analyzer_describe (const gcall *call,\n@@ -539,6 +551,8 @@ class region_model\n   bool impl_call_calloc (const call_details &cd);\n   bool impl_call_error (const call_details &cd, unsigned min_args,\n \t\t\tbool *out_terminate_path);\n+  void impl_call_fgets (const call_details &cd);\n+  void impl_call_fread (const call_details &cd);\n   void impl_call_free (const call_details &cd);\n   bool impl_call_malloc (const call_details &cd);\n   void impl_call_memcpy (const call_details &cd);\n@@ -727,6 +741,10 @@ class region_model\n   bool called_from_main_p () const;\n   const svalue *get_initial_value_for_global (const region *reg) const;\n \n+  const svalue *check_for_poison (const svalue *sval,\n+\t\t\t\t  tree expr,\n+\t\t\t\t  region_model_context *ctxt) const;\n+\n   void check_for_writable_region (const region* dest_reg,\n \t\t\t\t  region_model_context *ctxt) const;\n \n@@ -757,7 +775,9 @@ class region_model\n class region_model_context\n {\n  public:\n-  virtual void warn (pending_diagnostic *d) = 0;\n+  /* Hook for clients to store pending diagnostics.\n+     Return true if the diagnostic was stored, or false if it was deleted.  */\n+  virtual bool warn (pending_diagnostic *d) = 0;\n \n   /* Hook for clients to be notified when an SVAL that was reachable\n      in a previous state is no longer live, so that clients can emit warnings\n@@ -799,14 +819,17 @@ class region_model_context\n   virtual void on_escaped_function (tree fndecl) = 0;\n \n   virtual uncertainty_t *get_uncertainty () = 0;\n+\n+  /* Hook for clients to purge state involving SVAL.  */\n+  virtual void purge_state_involving (const svalue *sval) = 0;\n };\n \n /* A \"do nothing\" subclass of region_model_context.  */\n \n class noop_region_model_context : public region_model_context\n {\n public:\n-  void warn (pending_diagnostic *) OVERRIDE {}\n+  bool warn (pending_diagnostic *) OVERRIDE { return false; }\n   void on_svalue_leak (const svalue *) OVERRIDE {}\n   void on_liveness_change (const svalue_set &,\n \t\t\t   const region_model *) OVERRIDE {}\n@@ -829,6 +852,8 @@ class noop_region_model_context : public region_model_context\n   void on_escaped_function (tree) OVERRIDE {}\n \n   uncertainty_t *get_uncertainty () OVERRIDE { return NULL; }\n+\n+  void purge_state_involving (const svalue *sval ATTRIBUTE_UNUSED) OVERRIDE {}\n };\n \n /* A subclass of region_model_context for determining if operations fail\n@@ -931,9 +956,10 @@ using namespace ::selftest;\n class test_region_model_context : public noop_region_model_context\n {\n public:\n-  void warn (pending_diagnostic *d) FINAL OVERRIDE\n+  bool warn (pending_diagnostic *d) FINAL OVERRIDE\n   {\n     m_diagnostics.safe_push (d);\n+    return true;\n   }\n \n   unsigned get_num_diagnostics () const { return m_diagnostics.length (); }"}, {"sha": "6cccb0f48f21a9cf3dfea8d7709ecd3ff136345e", "filename": "gcc/analyzer/region.cc", "status": "modified", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Fanalyzer%2Fregion.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Fanalyzer%2Fregion.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion.cc?ref=33255ad3ac14e3953750fe0f2d82b901c2852ff6", "patch": "@@ -168,6 +168,109 @@ region::maybe_get_frame_region () const\n   return NULL;\n }\n \n+/* Get the memory space of this region.  */\n+\n+enum memory_space\n+region::get_memory_space () const\n+{\n+  const region *iter = this;\n+  while (iter)\n+    {\n+      switch (iter->get_kind ())\n+\t{\n+\tdefault:\n+\t  break;\n+\tcase RK_GLOBALS:\n+\t  return MEMSPACE_GLOBALS;\n+\tcase RK_CODE:\n+\tcase RK_FUNCTION:\n+\tcase RK_LABEL:\n+\t  return MEMSPACE_CODE;\n+\tcase RK_FRAME:\n+\tcase RK_STACK:\n+\tcase RK_ALLOCA:\n+\t  return MEMSPACE_STACK;\n+\tcase RK_HEAP:\n+\tcase RK_HEAP_ALLOCATED:\n+\t  return MEMSPACE_HEAP;\n+\tcase RK_STRING:\n+\t  return MEMSPACE_READONLY_DATA;\n+\t}\n+      if (iter->get_kind () == RK_CAST)\n+\titer = iter->dyn_cast_cast_region ()->get_original_region ();\n+      else\n+\titer = iter->get_parent_region ();\n+    }\n+  return MEMSPACE_UNKNOWN;\n+}\n+\n+/* Subroutine for use by region_model_manager::get_or_create_initial_value.\n+   Return true if this region has an initial_svalue.\n+   Return false if attempting to use INIT_VAL(this_region) should give\n+   the \"UNINITIALIZED\" poison value.  */\n+\n+bool\n+region::can_have_initial_svalue_p () const\n+{\n+  const region *base_reg = get_base_region ();\n+\n+  /* Check for memory spaces that are uninitialized by default.  */\n+  enum memory_space mem_space = base_reg->get_memory_space ();\n+  switch (mem_space)\n+    {\n+    default:\n+      gcc_unreachable ();\n+    case MEMSPACE_UNKNOWN:\n+    case MEMSPACE_CODE:\n+    case MEMSPACE_GLOBALS:\n+    case MEMSPACE_READONLY_DATA:\n+      /* Such regions have initial_svalues.  */\n+      return true;\n+\n+    case MEMSPACE_HEAP:\n+      /* Heap allocations are uninitialized by default.  */\n+      return false;\n+\n+    case MEMSPACE_STACK:\n+      if (tree decl = base_reg->maybe_get_decl ())\n+\t{\n+\t  /* See the assertion in frame_region::get_region_for_local for the\n+\t     tree codes we need to handle here.  */\n+\t  switch (TREE_CODE (decl))\n+\t    {\n+\t    default:\n+\t      gcc_unreachable ();\n+\n+\t    case PARM_DECL:\n+\t      /* Parameters have initial values.  */\n+\t      return true;\n+\n+\t    case VAR_DECL:\n+\t    case RESULT_DECL:\n+\t      /* Function locals don't have initial values.  */\n+\t      return false;\n+\n+\t    case SSA_NAME:\n+\t      {\n+\t\ttree ssa_name = decl;\n+\t\t/* SSA names that are the default defn of a PARM_DECL\n+\t\t   have initial_svalues; other SSA names don't.  */\n+\t\tif (SSA_NAME_IS_DEFAULT_DEF (ssa_name)\n+\t\t    && SSA_NAME_VAR (ssa_name)\n+\t\t    && TREE_CODE (SSA_NAME_VAR (ssa_name)) == PARM_DECL)\n+\t\t  return true;\n+\t\telse\n+\t\t  return false;\n+\t      }\n+\t    }\n+\t}\n+\n+      /* If we have an on-stack region that isn't associated with a decl\n+\t or SSA name, then we have VLA/alloca, which is uninitialized.  */\n+      return false;\n+    }\n+}\n+\n /* If this region is a decl_region, return the decl.\n    Otherwise return NULL.  */\n \n@@ -584,6 +687,20 @@ region::non_null_p () const\n     }\n }\n \n+/* Return true iff this region is defined in terms of SVAL.  */\n+\n+bool\n+region::involves_p (const svalue *sval) const\n+{\n+  if (const symbolic_region *symbolic_reg = dyn_cast_symbolic_region ())\n+    {\n+      if (symbolic_reg->get_pointer ()->involves_p (sval))\n+\treturn true;\n+    }\n+\n+  return false;\n+}\n+\n /* Comparator for trees to impose a deterministic ordering on\n    T1 and T2.  */\n "}, {"sha": "a17e73c30c9d7f3a8fc41c7c02199f6420a03dfc", "filename": "gcc/analyzer/region.h", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Fanalyzer%2Fregion.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Fanalyzer%2Fregion.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion.h?ref=33255ad3ac14e3953750fe0f2d82b901c2852ff6", "patch": "@@ -25,6 +25,18 @@ along with GCC; see the file COPYING3.  If not see\n \n namespace ana {\n \n+/* An enum for identifying different spaces within memory.  */\n+\n+enum memory_space\n+{\n+  MEMSPACE_UNKNOWN,\n+  MEMSPACE_CODE,\n+  MEMSPACE_GLOBALS,\n+  MEMSPACE_STACK,\n+  MEMSPACE_HEAP,\n+  MEMSPACE_READONLY_DATA\n+};\n+\n /* An enum for discriminating between the different concrete subclasses\n    of region.  */\n \n@@ -123,6 +135,8 @@ class region\n   bool base_region_p () const;\n   bool descendent_of_p (const region *elder) const;\n   const frame_region *maybe_get_frame_region () const;\n+  enum memory_space get_memory_space () const;\n+  bool can_have_initial_svalue_p () const;\n \n   tree maybe_get_decl () const;\n \n@@ -141,6 +155,8 @@ class region\n \n   static int cmp_ptr_ptr (const void *, const void *);\n \n+  bool involves_p (const svalue *sval) const;\n+\n   region_offset get_offset () const;\n \n   /* Attempt to get the size of this region as a concrete number of bytes."}, {"sha": "9707a6863ce40161e8abc588697270499dc28d1f", "filename": "gcc/analyzer/sm-malloc.cc", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Fanalyzer%2Fsm-malloc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Fanalyzer%2Fsm-malloc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-malloc.cc?ref=33255ad3ac14e3953750fe0f2d82b901c2852ff6", "patch": "@@ -1198,6 +1198,25 @@ class use_after_free : public malloc_diagnostic\n \t\t\t\t funcname, ev.m_expr);\n   }\n \n+  /* Implementation of pending_diagnostic::supercedes_p for\n+     use_after_free.\n+\n+     We want use-after-free to supercede use-of-unitialized-value,\n+     so that if we have these at the same stmt, we don't emit\n+     a use-of-uninitialized, just the use-after-free.\n+     (this is because we fully purge information about freed\n+     buffers when we free them to avoid state explosions, so\n+     that if they are accessed after the free, it looks like\n+     they are uninitialized).  */\n+\n+  bool supercedes_p (const pending_diagnostic &other) const FINAL OVERRIDE\n+  {\n+    if (other.use_of_uninit_p ())\n+      return true;\n+\n+    return false;\n+  }\n+\n private:\n   diagnostic_event_id_t m_free_event;\n   const deallocator *m_deallocator;"}, {"sha": "0042a207ba681f633fbb741c74ee9a098cdf9051", "filename": "gcc/analyzer/store.cc", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Fanalyzer%2Fstore.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Fanalyzer%2Fstore.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fstore.cc?ref=33255ad3ac14e3953750fe0f2d82b901c2852ff6", "patch": "@@ -1316,6 +1316,38 @@ binding_cluster::mark_region_as_unknown (store_manager *mgr,\n   bind (mgr, reg, sval);\n }\n \n+/* Purge state involving SVAL.  */\n+\n+void\n+binding_cluster::purge_state_involving (const svalue *sval,\n+\t\t\t\t\tregion_model_manager *sval_mgr)\n+{\n+  auto_vec<const binding_key *> to_remove;\n+  for (auto iter : m_map)\n+    {\n+      const binding_key *iter_key = iter.first;\n+      if (const symbolic_binding *symbolic_key\n+\t    = iter_key->dyn_cast_symbolic_binding ())\n+\t{\n+\t  const region *reg = symbolic_key->get_region ();\n+\t  if (reg->involves_p (sval))\n+\t    to_remove.safe_push (iter_key);\n+\t}\n+      const svalue *iter_sval = iter.second;\n+      if (iter_sval->involves_p (sval))\n+\t{\n+\t  const svalue *new_sval\n+\t    = sval_mgr->get_or_create_unknown_svalue (iter_sval->get_type ());\n+\t  m_map.put (iter_key, new_sval);\n+\t}\n+    }\n+  for (auto iter : to_remove)\n+    {\n+      m_map.remove (iter);\n+      m_touched = true;\n+    }\n+}\n+\n /* Get any SVAL bound to REG within this cluster via kind KIND,\n    without checking parent regions of REG.  */\n \n@@ -2447,6 +2479,29 @@ store::mark_region_as_unknown (store_manager *mgr, const region *reg,\n   cluster->mark_region_as_unknown (mgr, reg, uncertainty);\n }\n \n+/* Purge state involving SVAL.  */\n+\n+void\n+store::purge_state_involving (const svalue *sval,\n+\t\t\t      region_model_manager *sval_mgr)\n+{\n+  auto_vec <const region *> base_regs_to_purge;\n+  for (auto iter : m_cluster_map)\n+    {\n+      const region *base_reg = iter.first;\n+      if (base_reg->involves_p (sval))\n+\tbase_regs_to_purge.safe_push (base_reg);\n+      else\n+\t{\n+\t  binding_cluster *cluster = iter.second;\n+\t  cluster->purge_state_involving (sval, sval_mgr);\n+\t}\n+    }\n+\n+  for (auto iter : base_regs_to_purge)\n+    purge_cluster (iter);\n+}\n+\n /* Get the cluster for BASE_REG, or NULL (const version).  */\n \n const binding_cluster *"}, {"sha": "bc58694717427196f277b6943a36844bd9585f7d", "filename": "gcc/analyzer/store.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Fanalyzer%2Fstore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Fanalyzer%2Fstore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fstore.h?ref=33255ad3ac14e3953750fe0f2d82b901c2852ff6", "patch": "@@ -198,6 +198,7 @@ class uncertainty_t\n \n class byte_range;\n class concrete_binding;\n+class symbolic_binding;\n \n /* Abstract base class for describing ranges of bits within a binding_map\n    that can have svalues bound to them.  */\n@@ -220,6 +221,8 @@ class binding_key\n \n   virtual const concrete_binding *dyn_cast_concrete_binding () const\n   { return NULL; }\n+  virtual const symbolic_binding *dyn_cast_symbolic_binding () const\n+  { return NULL; }\n };\n \n /* A concrete range of bits.  */\n@@ -420,6 +423,9 @@ class symbolic_binding : public binding_key\n \n   void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n \n+  const symbolic_binding *dyn_cast_symbolic_binding () const FINAL OVERRIDE\n+  { return this; }\n+\n   const region *get_region () const { return m_region; }\n \n   static int cmp_ptr_ptr (const void *, const void *);\n@@ -563,6 +569,8 @@ class binding_cluster\n   void zero_fill_region (store_manager *mgr, const region *reg);\n   void mark_region_as_unknown (store_manager *mgr, const region *reg,\n \t\t\t       uncertainty_t *uncertainty);\n+  void purge_state_involving (const svalue *sval,\n+\t\t\t      region_model_manager *sval_mgr);\n \n   const svalue *get_binding (store_manager *mgr, const region *reg) const;\n   const svalue *get_binding_recursive (store_manager *mgr,\n@@ -697,6 +705,8 @@ class store\n   void zero_fill_region (store_manager *mgr, const region *reg);\n   void mark_region_as_unknown (store_manager *mgr, const region *reg,\n \t\t\t       uncertainty_t *uncertainty);\n+  void purge_state_involving (const svalue *sval,\n+\t\t\t      region_model_manager *sval_mgr);\n \n   const binding_cluster *get_cluster (const region *base_reg) const;\n   binding_cluster *get_cluster (const region *base_reg);"}, {"sha": "22da769f0959fc2ae59b90e02c6b783810458a26", "filename": "gcc/analyzer/svalue.cc", "status": "modified", "additions": 30, "deletions": 2, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Fanalyzer%2Fsvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Fanalyzer%2Fsvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsvalue.cc?ref=33255ad3ac14e3953750fe0f2d82b901c2852ff6", "patch": "@@ -158,6 +158,13 @@ svalue::can_merge_p (const svalue *other,\n       || (other->get_kind () == SK_UNMERGEABLE))\n     return NULL;\n \n+  /* Reject attempts to merge poisoned svalues with other svalues\n+     (either non-poisoned, or other kinds of poison), so that e.g.\n+     we identify paths in which a variable is conditionally uninitialized.  */\n+  if (get_kind () == SK_POISONED\n+      || other->get_kind () == SK_POISONED)\n+    return NULL;\n+\n   /* Reject attempts to merge NULL pointers with not-NULL-pointers.  */\n   if (POINTER_TYPE_P (get_type ()))\n     {\n@@ -516,6 +523,12 @@ class involvement_visitor : public visitor\n       m_found = true;\n   }\n \n+  void visit_conjured_svalue (const conjured_svalue *candidate)\n+  {\n+    if (candidate == m_needle)\n+      m_found = true;\n+  }\n+\n   bool found_p () const { return m_found; }\n \n private:\n@@ -528,8 +541,9 @@ class involvement_visitor : public visitor\n bool\n svalue::involves_p (const svalue *other) const\n {\n-  /* Currently only implemented for initial_svalue.  */\n-  gcc_assert (other->get_kind () == SK_INITIAL);\n+  /* Currently only implemented for these kinds.  */\n+  gcc_assert (other->get_kind () == SK_INITIAL\n+\t      || other->get_kind () == SK_CONJURED);\n \n   involvement_visitor v (other);\n   accept (&v);\n@@ -811,6 +825,8 @@ poison_kind_to_str (enum poison_kind kind)\n     {\n     default:\n       gcc_unreachable ();\n+    case POISON_KIND_UNINIT:\n+      return \"uninit\";\n     case POISON_KIND_FREED:\n       return \"freed\";\n     case POISON_KIND_POPPED_STACK:\n@@ -847,6 +863,18 @@ poisoned_svalue::accept (visitor *v) const\n   v->visit_poisoned_svalue (this);\n }\n \n+/* Implementation of svalue::maybe_fold_bits_within vfunc\n+   for poisoned_svalue.  */\n+\n+const svalue *\n+poisoned_svalue::maybe_fold_bits_within (tree type,\n+\t\t\t\t\t const bit_range &,\n+\t\t\t\t\t region_model_manager *mgr) const\n+{\n+  /* Bits within a poisoned value are also poisoned.  */\n+  return mgr->get_or_create_poisoned_svalue (m_kind, type);\n+}\n+\n /* class setjmp_svalue's implementation is in engine.cc, so that it can use\n    the declaration of exploded_node.  */\n "}, {"sha": "54b97f8617f286d6cb1abb63f00d5efe56b3f2b6", "filename": "gcc/analyzer/svalue.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Fanalyzer%2Fsvalue.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Fanalyzer%2Fsvalue.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsvalue.h?ref=33255ad3ac14e3953750fe0f2d82b901c2852ff6", "patch": "@@ -324,6 +324,9 @@ class unknown_svalue : public svalue\n \n enum poison_kind\n {\n+  /* For use to describe uninitialized memory.  */\n+  POISON_KIND_UNINIT,\n+\n   /* For use to describe freed memory.  */\n   POISON_KIND_FREED,\n \n@@ -378,6 +381,11 @@ class poisoned_svalue : public svalue\n   void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n   void accept (visitor *v) const FINAL OVERRIDE;\n \n+  const svalue *\n+  maybe_fold_bits_within (tree type,\n+\t\t\t  const bit_range &subrange,\n+\t\t\t  region_model_manager *mgr) const FINAL OVERRIDE;\n+\n   enum poison_kind get_poison_kind () const { return m_kind; }\n \n  private:"}, {"sha": "b16176ea5600202ef5279ca4d6a3363bea19c89d", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=33255ad3ac14e3953750fe0f2d82b901c2852ff6", "patch": "@@ -9234,6 +9234,7 @@ Enabling this option effectively enables the following warnings:\n -Wanalyzer-tainted-array-index @gol\n -Wanalyzer-unsafe-call-within-signal-handler @gol\n -Wanalyzer-use-after-free @gol\n+-Wanalyzer-use-of-uninitialized-value @gol\n -Wanalyzer-use-of-pointer-in-stale-stack-frame @gol\n -Wanalyzer-write-to-const @gol\n -Wanalyzer-write-to-string-literal @gol\n@@ -9478,6 +9479,15 @@ detects an attempt to write through a pointer to a string literal.\n However, the analyzer does not prioritize detection of such paths, so\n false negatives are more likely relative to other warnings.\n \n+@item -Wno-analyzer-use-of-uninitialized-value\n+@opindex Wanalyzer-use-of-uninitialized-value\n+@opindex Wno-analyzer-use-of-uninitialized-value\n+This warning requires @option{-fanalyzer}, which enables it; use\n+@option{-Wno-analyzer-use-of-uninitialized-value} to disable it.\n+\n+This diagnostic warns for paths through the code in which an uninitialized\n+value is used.\n+\n @end table\n \n Pertinent parameters for controlling the exploration are:"}, {"sha": "41507e2b8378e5a36da6429a87f45e2fbb6d167b", "filename": "gcc/testsuite/g++.dg/analyzer/pr93212.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fanalyzer%2Fpr93212.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fanalyzer%2Fpr93212.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fanalyzer%2Fpr93212.C?ref=33255ad3ac14e3953750fe0f2d82b901c2852ff6", "patch": "@@ -4,8 +4,8 @@\n auto lol()\n {\n     int aha = 3;\n-    return [&aha] {\n-        return aha; // { dg-warning \"dereferencing pointer '.*' to within stale stack frame\" }\n+    return [&aha] { // { dg-warning \"dereferencing pointer '.*' to within stale stack frame\" }\n+        return aha;\n     };\n     /* TODO: may be worth special-casing the reporting of dangling\n        references from lambdas, to highlight the declaration, and maybe fix"}, {"sha": "81c0acd39543a06b46ac7d295f7a3775a0765fe3", "filename": "gcc/testsuite/g++.dg/analyzer/pr94011.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fanalyzer%2Fpr94011.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fanalyzer%2Fpr94011.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fanalyzer%2Fpr94011.C?ref=33255ad3ac14e3953750fe0f2d82b901c2852ff6", "patch": "@@ -1,5 +1,5 @@\n // { dg-do compile { target c++11 } }\n-// { dg-additional-options \"-O1\" }\n+// { dg-additional-options \"-O1 -Wno-analyzer-use-of-uninitialized-value\" }\n \n template <typename DV> DV\n vu (DV j4)"}, {"sha": "ecf7121367d60a40d46236cab17f25009bd224c9", "filename": "gcc/testsuite/g++.dg/analyzer/pr94503.C", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fanalyzer%2Fpr94503.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fanalyzer%2Fpr94503.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fanalyzer%2Fpr94503.C?ref=33255ad3ac14e3953750fe0f2d82b901c2852ff6", "patch": "@@ -1,3 +1,5 @@\n+// { dg-additional-options \"-Wno-analyzer-use-of-uninitialized-value\" }\n+\n template <typename> class allocator {\n public:\n   allocator(const allocator &);"}, {"sha": "6400f845f9eb3924991ef9734e620a287c1705b8", "filename": "gcc/testsuite/gcc.dg/analyzer/clobbers-1.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fclobbers-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fclobbers-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fclobbers-1.c?ref=33255ad3ac14e3953750fe0f2d82b901c2852ff6", "patch": "@@ -25,9 +25,8 @@ void test_1 (void)\n   __analyzer_dump_exploded_nodes (0); /* { dg-warning \"1 processed enode\" } */\n }\n \n-void test_2 (void)\n+void test_2 (struct foo f)\n {\n-  struct foo f;\n   f.i = 42;\n   if (f.j)\n     __analyzer_eval (f.j); /* { dg-warning \"TRUE\" } */"}, {"sha": "908d99981a62b99cc4d1fe76d65b6c85b315842f", "filename": "gcc/testsuite/gcc.dg/analyzer/data-model-1.c", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-1.c?ref=33255ad3ac14e3953750fe0f2d82b901c2852ff6", "patch": "@@ -137,22 +137,22 @@ void test_11 (void)\n \n /* alloca.  */\n \n-void test_12 (void)\n+int test_12 (void)\n {\n   void *p = __builtin_alloca (256);\n   void *q = __builtin_alloca (256);\n \n   /* alloca results should be unique.  */\n   __analyzer_eval (p == q); /* { dg-warning \"FALSE\" } */\n \n-  // FIXME: complain about uses of poisoned values\n+  return *(int *)p; /* { dg-warning \"use of uninitialized value '\\\\*\\\\(int \\\\*\\\\)p\" } */\n }\n \n /* Use of uninit value.  */\n int test_12a (void)\n {\n   int i;\n-  return i; // FIXME: do we see the return stmt?\n+  return i; /* { dg-warning \"use of uninitialized value 'i'\" } */\n }\n \n void test_12b (void *p, void *q)\n@@ -165,9 +165,11 @@ int test_12c (void)\n   int i;\n   int j;\n \n-  j = i; // FIXME: should complain about this\n+  j = i; /* { dg-warning \"use of uninitialized value 'i'\" } */\n \n-  return j;\n+  /* We should not emit followup warnings after the first warning about\n+     an uninitialized value.  */\n+  return j; /* { dg-bogus \"use of uninitialized value\" } */\n }\n \n struct coord\n@@ -348,7 +350,9 @@ void test_19 (void)\n {\n   int i, j;\n   /* Compare two uninitialized locals.  */\n-    __analyzer_eval (i == j); /* { dg-warning \"UNKNOWN\" } */\n+    __analyzer_eval (i == j); /* { dg-warning \"UNKNOWN\" \"unknown \" } */\n+    /* { dg-warning \"use of uninitialized value 'i'\" \"uninit i\" { target *-*-* } .-1 } */\n+    /* { dg-warning \"use of uninitialized value 'j'\" \"uninit j\" { target *-*-* } .-2 } */\n }\n \n void test_20 (int i, int j)\n@@ -649,8 +653,10 @@ void test_29b (void)\n   __analyzer_eval (p[9].x == 109024); /* { dg-warning \"TRUE\" } */\n   __analyzer_eval (p[9].y == 109025); /* { dg-warning \"TRUE\" } */\n \n-  __analyzer_eval (p[10].x == 0); /* { dg-warning \"UNKNOWN\" } */\n-  __analyzer_eval (p[10].y == 0); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (p[10].x == 0); /* { dg-warning \"UNKNOWN\" \"unknown\" } */\n+  /* { dg-warning \"use of uninitialized value 'p\\\\\\[10\\\\\\].x'\" \"uninit\" { target *-*-* } .-1 } */\n+  __analyzer_eval (p[10].y == 0); /* { dg-warning \"UNKNOWN\" \"unknown\" } */\n+  /* { dg-warning \"use of uninitialized value 'p\\\\\\[10\\\\\\].y'\" \"uninit\" { target *-*-* } .-1 } */\n \n   q = &p[7];\n \n@@ -698,8 +704,10 @@ void test_29c (int len)\n   __analyzer_eval (p[9].x == 109024); /* { dg-warning \"TRUE\" } */\n   __analyzer_eval (p[9].y == 109025); /* { dg-warning \"TRUE\" } */\n \n-  __analyzer_eval (p[10].x == 0); /* { dg-warning \"UNKNOWN\" } */\n-  __analyzer_eval (p[10].y == 0); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (p[10].x == 0); /* { dg-warning \"UNKNOWN\" \"unknown\" } */\n+  /* { dg-warning \"use of uninitialized value '\\\\*p\\\\\\[10\\\\\\].x'\" \"uninit\" { target *-*-* } .-1 } */\n+  __analyzer_eval (p[10].y == 0); /* { dg-warning \"UNKNOWN\" \"unknown\" } */\n+  /* { dg-warning \"use of uninitialized value '\\\\*p\\\\\\[10\\\\\\].y'\" \"uninit\" { target *-*-* } .-1 } */\n \n   q = &p[7];\n \n@@ -811,15 +819,15 @@ void test_36 (int i)\n int test_37 (void)\n {\n   int *ptr;\n-  return *ptr; /* { dg-warning \"use of uninitialized value 'ptr'\" \"uninit-warning-removed\" { xfail *-*-* } } */\n+  return *ptr; /* { dg-warning \"use of uninitialized value 'ptr'\" } */\n }\n \n /* Write through uninitialized pointer.  */\n \n void test_37a (int i)\n {\n   int *ptr;\n-  *ptr = i; /* { dg-warning \"use of uninitialized value 'ptr'\" \"uninit-warning-removed\" { xfail *-*-* } } */\n+  *ptr = i; /* { dg-warning \"use of uninitialized value 'ptr'\" } */\n }\n \n // TODO: the various other ptr deref poisonings"}, {"sha": "ff65883dac10989aec8a47127cd403a5f53583e5", "filename": "gcc/testsuite/gcc.dg/analyzer/data-model-20.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-20.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-20.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-20.c?ref=33255ad3ac14e3953750fe0f2d82b901c2852ff6", "patch": "@@ -17,7 +17,7 @@ test (int n) {\n       for (; i >= 0; i++) {\n \tfree(arr[i]); /* { dg-bogus \"double-'free'\" } */\n       }\n-      free(arr);\n+      free(arr); /* { dg-warning \"leak\" } */\n       return NULL;\n     }\n   }"}, {"sha": "3b987e10a4afb728d48af5e09cd7cc8bd9f70832", "filename": "gcc/testsuite/gcc.dg/analyzer/explode-2.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fexplode-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fexplode-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fexplode-2.c?ref=33255ad3ac14e3953750fe0f2d82b901c2852ff6", "patch": "@@ -2,45 +2,47 @@\n    independently, so the total combined number of states\n    at any program point within the loop is NUM_VARS * NUM_STATES.\n \n-   Set the limits high enough that we can fully explore this.  */ \n+   However, due to the way the analyzer represents heap-allocated regions\n+   this never terminates, eventually hitting the complexity limit\n+   (PR analyzer/93695).  */\n \n-/* { dg-additional-options \"--param analyzer-max-enodes-per-program-point=200 --param analyzer-bb-explosion-factor=50\" } */\n+/* { dg-additional-options \"-Wno-analyzer-too-complex -Wno-analyzer-malloc-leak\" } */\n \n #include <stdlib.h>\n \n extern int get (void);\n \n void test (void)\n {\n-  void *p0, *p1, *p2, *p3;\n+  void *p0 = NULL, *p1 = NULL, *p2 = NULL, *p3 = NULL;\n   while (get ())\n     {\n       switch (get ())\n \t{\n \tdefault:\n \tcase 0:\n-\t  p0 = malloc (16); /* { dg-warning \"leak\" } */\n+\t  p0 = malloc (16); /* { dg-warning \"leak\" \"\" { xfail *-*-* } } */\n \t  break;\n \tcase 1:\n \t  free (p0); /* { dg-warning \"double-'free' of 'p0'\" \"\" { xfail *-*-* } } */\n \t  break;\n \n \tcase 2:\n-\t  p1 = malloc (16); /* { dg-warning \"leak\" } */\n+\t  p1 = malloc (16); /* { dg-warning \"leak\" \"\" { xfail *-*-* } } */\n \t  break;\n \tcase 3:\n \t  free (p1); /* { dg-warning \"double-'free' of 'p1'\" \"\" { xfail *-*-* } } */\n \t  break;\n \n \tcase 4:\n-\t  p2 = malloc (16); /* { dg-warning \"leak\" } */\n+\t  p2 = malloc (16); /* { dg-warning \"leak\" \"\" { xfail *-*-* } } */\n \t  break;\n \tcase 5:\n \t  free (p2); /* { dg-warning \"double-'free' of 'p2'\" \"\" { xfail *-*-* } } */\n \t  break;\n \n \tcase 6:\n-\t  p3 = malloc (16); /* { dg-warning \"leak\" } */\n+\t  p3 = malloc (16); /* { dg-warning \"leak\" \"\" { xfail *-*-* } } */\n \t  break;\n \tcase 7:\n \t  free (p3); /* { dg-warning \"double-'free' of 'p3'\" \"\" { xfail *-*-* } } */"}, {"sha": "f60354cae1bb008d7aa20d9378329fe852c0f6e9", "filename": "gcc/testsuite/gcc.dg/analyzer/explode-2a.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fexplode-2a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fexplode-2a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fexplode-2a.c?ref=33255ad3ac14e3953750fe0f2d82b901c2852ff6", "patch": "@@ -8,13 +8,13 @@ extern int get (void);\n \n void test (void)\n {\n-  void *p0, *p1, *p2, *p3;\n+  void *p0 = NULL, *p1 = NULL, *p2 = NULL, *p3 = NULL;\n   /* Due to not purging constraints on SSA names within loops\n      (PR analyzer/101068), the analyzer effectively treats the original\n      explode-2.c as this code.  */\n   int a = get ();\n   int b = get ();\n-  while (a)\n+  while (a) /* { dg-warning \"leak\" } */\n     {\n       switch (b)\n \t{"}, {"sha": "e93d24c9de805217a44e87ac24eed92e5d5213e4", "filename": "gcc/testsuite/gcc.dg/analyzer/fgets-1.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffgets-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffgets-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffgets-1.c?ref=33255ad3ac14e3953750fe0f2d82b901c2852ff6", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do \"compile\" } */\n+\n+#define NULL ((void *) 0)\n+typedef struct _IO_FILE FILE;\n+\n+extern char *fgets(char *__restrict __s, int __n,\n+\t\t   FILE *__restrict __stream);\n+extern char *fgets_unlocked(char *__restrict __s, int __n,\n+\t\t\t    FILE *__restrict __stream);\n+\n+char\n+test_1 (FILE *fp)\n+{\n+  char buf[400];\n+\n+  if (fgets (buf, sizeof buf, fp) == NULL)\n+    return 0;\n+\n+  return buf[0];\n+}\n+\n+char\n+test_2 (FILE *fp)\n+{\n+  char buf[400];\n+\n+  if (fgets_unlocked (buf, sizeof buf, fp) == NULL)\n+    return 0;\n+\n+  return buf[0];\n+}"}, {"sha": "593cb7f4aa0330ee04ea8bcdafa38bd082572ffc", "filename": "gcc/testsuite/gcc.dg/analyzer/fread-1.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffread-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffread-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ffread-1.c?ref=33255ad3ac14e3953750fe0f2d82b901c2852ff6", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-additional-options \"-fanalyzer-checker=taint\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+extern size_t fread (void *, size_t, size_t, void *);\n+\n+int\n+test_1 (void *fp)\n+{\n+  int i;\n+  fread (&i, sizeof (i), 1, fp);\n+  return i;  \n+}"}, {"sha": "df2fc9ce243f39506874b6eeac9aa75117ec33bf", "filename": "gcc/testsuite/gcc.dg/analyzer/malloc-1.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-1.c?ref=33255ad3ac14e3953750fe0f2d82b901c2852ff6", "patch": "@@ -204,8 +204,7 @@ void test_16 (void)\n   bar ();\n \n  fail:\n-  free (q); /* { dg-warning \"free of uninitialized 'q'\" \"\" { xfail *-*-* } } */ \n-  /* TODO(xfail): implement uninitialized detection.  */\n+  free (q); /* { dg-warning \"use of uninitialized value 'q'\" } */\n   free (p);\n }\n \n@@ -459,8 +458,8 @@ int *\n test_40 (int i)\n {\n   int *p = (int*)malloc(sizeof(int*));\n-  i = *p; /* { dg-warning \"dereference of possibly-NULL 'p' \\\\\\[CWE-690\\\\\\]\" } */\n-  /* TODO: (it's also uninitialized) */\n+  i = *p; /* { dg-warning \"dereference of possibly-NULL 'p' \\\\\\[CWE-690\\\\\\]\" \"possibly-null\" } */\n+  /* { dg-warning \"use of uninitialized value '\\\\*p'\" \"uninit\" { target *-*-*} .-1 } */\n   return p;\n }\n "}, {"sha": "de9b5e3a1d03730639cd9bcf8b3e31a6da80bbd5", "filename": "gcc/testsuite/gcc.dg/analyzer/memset-CVE-2017-18549-1.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmemset-CVE-2017-18549-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmemset-CVE-2017-18549-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmemset-CVE-2017-18549-1.c?ref=33255ad3ac14e3953750fe0f2d82b901c2852ff6", "patch": "@@ -37,6 +37,8 @@ struct aac_srb_reply\n #define\t\tST_OK\t\t0\n #define SRB_STATUS_SUCCESS                  0x01\n \n+extern void check_uninit (u8 v);\n+\n /* Adapted from drivers/scsi/aacraid/commctrl.c  */\n \n static int aac_send_raw_srb(/* [...snip...] */)\n@@ -66,10 +68,8 @@ static int aac_send_raw_srb(/* [...snip...] */)\n \t__analyzer_eval (reply.sense_data_size == 0); /* { dg-warning \"TRUE\" } */\n \t__analyzer_eval (reply.sense_data[0] == 0); /* { dg-warning \"TRUE\" } */\n \t__analyzer_eval (reply.sense_data[AAC_SENSE_BUFFERSIZE - 1] == 0); /* { dg-warning \"TRUE\" } */\n-\t/* TODO: the following should be detected as uninitialized, when\n-\t   that diagnostic is reimplemented.  */\n-\t__analyzer_eval (reply.padding[0] == 0); /* { dg-warning \"UNKNOWN\" } */\n-\t__analyzer_eval (reply.padding[1] == 0); /* { dg-warning \"UNKNOWN\" } */\n+\tcheck_uninit (reply.padding[0]); /* { dg-warning \"uninitialized value\" } */\n+\tcheck_uninit (reply.padding[1]); /* { dg-warning \"uninitialized value\" } */\n }\n \n static int aac_send_raw_srb_fixed(/* [...snip...] */)"}, {"sha": "c7b49d28cbe170ae90a2ce1a867cfb4eb81b4039", "filename": "gcc/testsuite/gcc.dg/analyzer/pr93355-localealias-feasibility.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr93355-localealias-feasibility.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr93355-localealias-feasibility.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr93355-localealias-feasibility.c?ref=33255ad3ac14e3953750fe0f2d82b901c2852ff6", "patch": "@@ -30,6 +30,7 @@ typedef __SIZE_TYPE__ size_t;\n typedef struct _IO_FILE FILE;\n extern FILE *fopen (const char *__restrict __filename,\n \t\t    const char *__restrict __modes);\n+extern size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);\n extern int fclose (FILE *__stream);\n \n extern int isspace (int) __attribute__((__nothrow__, __leaf__));\n@@ -50,6 +51,12 @@ read_alias_file (const char *fname, int fname_len)\n   if (fp == NULL)\n     return 0;\n \n+  if (fread (buf, sizeof buf, 1, fp) != 1)\n+    {\n+      fclose (fp);\n+      return 0;\n+    }\n+\n   cp = buf;\n \n   /* Ignore leading white space.  */"}, {"sha": "d13da3eb04487b9d0987d01765ece14b243d8747", "filename": "gcc/testsuite/gcc.dg/analyzer/pr94047.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr94047.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr94047.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr94047.c?ref=33255ad3ac14e3953750fe0f2d82b901c2852ff6", "patch": "@@ -13,7 +13,7 @@ void\n foo (void)\n {\n   struct list l;\n-  tlist t = l;\n+  tlist t = l; /* { dg-warning \"use of uninitialized value 'l'\" } */\n   for (;;)\n     bar (&t);\n }"}, {"sha": "b837451b27af1247328194d3cbd2258c70ea2ea2", "filename": "gcc/testsuite/gcc.dg/analyzer/pr94851-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr94851-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr94851-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr94851-2.c?ref=33255ad3ac14e3953750fe0f2d82b901c2852ff6", "patch": "@@ -45,7 +45,7 @@ int pamark(void) {\n     if (curbp->b_amark == (AMARK *)NULL)\n       curbp->b_amark = p;\n     else\n-      last->m_next = p;\n+      last->m_next = p; /* { dg-warning \"dereference of NULL 'last'\" } */\n   }\n \n   p->m_name = (char)c; /* { dg-bogus \"leak of 'p'\" \"bogus leak\" } */"}, {"sha": "c76658288b711b326c4160963b232a7e8d1541a4", "filename": "gcc/testsuite/gcc.dg/analyzer/pr96841.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr96841.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr96841.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr96841.c?ref=33255ad3ac14e3953750fe0f2d82b901c2852ff6", "patch": "@@ -10,10 +10,8 @@ void\n th (int *);\n \n void\n-bv (__SIZE_TYPE__ ny)\n+bv (__SIZE_TYPE__ ny, int ***mf)\n {\n-  int ***mf;\n-\n   while (l8 ())\n     {\n       *mf = 0;"}, {"sha": "fa0ca961c465c2362c0c77829b2aae454749d35f", "filename": "gcc/testsuite/gcc.dg/analyzer/pr98628.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr98628.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr98628.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr98628.c?ref=33255ad3ac14e3953750fe0f2d82b901c2852ff6", "patch": "@@ -7,8 +7,7 @@ struct chanset_t {\n   struct chanset_t *next;\n   char dname[];\n };\n-void help_subst() {\n-  char *writeidx;\n+void help_subst(char *writeidx) {\n   for (;; help_subst_chan = *help_subst_chan_0_0) {\n     foo(help_subst_chan.next->dname);\n     if (help_subst_chan_0_0) {"}, {"sha": "f28a9deba34ecabc6a12159526bf8b7844f44ec8", "filename": "gcc/testsuite/gcc.dg/analyzer/pr99042.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr99042.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr99042.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr99042.c?ref=33255ad3ac14e3953750fe0f2d82b901c2852ff6", "patch": "@@ -29,17 +29,17 @@ int test_3 (void)\n   if ((p->file = fopen(\"test.txt\", \"w\")) == NULL)\n     return 1;\n   unknown_fn ();\n-  return 0; /* { dg-warning \"leak\" } */\n-}\n+  return 0;\n+} /* { dg-warning \"leak\" } */\n \n int test_4 (void)\n {\n   struct foo f;\n   struct foo *p = &f;\n   if ((p->file = fopen(\"test.txt\", \"w\")) == NULL)\n     return 1;\n-  return 0; /* { dg-warning \"leak\" } */\n-}\n+  return 0;\n+} /* { dg-warning \"leak\" } */\n \n int test_5 (void)\n {"}, {"sha": "0eba646bdbd1e18653d8d2e4a1cc8409a9ecb13b", "filename": "gcc/testsuite/gcc.dg/analyzer/symbolic-1.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsymbolic-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsymbolic-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsymbolic-1.c?ref=33255ad3ac14e3953750fe0f2d82b901c2852ff6", "patch": "@@ -11,14 +11,16 @@ void test_1 (char a, char b, char c, char d, char e, char f,\n \n   __analyzer_eval (arr[2] == a); /* { dg-warning \"TRUE\" } */\n   __analyzer_eval (arr[3] == b); /* { dg-warning \"TRUE\" } */\n-  __analyzer_eval (arr[4]); /* { dg-warning \"UNKNOWN\" } */ // TODO: report uninit\n+  __analyzer_eval (arr[4]); /* { dg-warning \"UNKNOWN\" \"unknown\" } */\n+  /* { dg-warning \"use of uninitialized value 'arr\\\\\\[4\\\\\\]'\" \"uninit\" { target *-*-* } .-1 } */\n \n   /* Replace one concrete binding's value with a different value.  */\n   arr[3] = c;  /* (3) */\n   __analyzer_eval (arr[2] == a); /* { dg-warning \"TRUE\" } */\n   __analyzer_eval (arr[3] == c); /* { dg-warning \"TRUE\" } */\n   __analyzer_eval (arr[3] == b); /* { dg-warning \"UNKNOWN\" } */\n-  __analyzer_eval (arr[4]); /* { dg-warning \"UNKNOWN\" } */ // TODO: report uninit\n+  __analyzer_eval (arr[4]); /* { dg-warning \"UNKNOWN\" \"unknown\" } */\n+  /* { dg-warning \"use of uninitialized value 'arr\\\\\\[4\\\\\\]'\" \"uninit\" { target *-*-* } .-1 } */\n \n   /* Symbolic binding.  */\n   arr[i] = d;  /* (4) */"}, {"sha": "665e0b645d393effef5a8f4eca5c1c15bcef213b", "filename": "gcc/testsuite/gcc.dg/analyzer/symbolic-7.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsymbolic-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsymbolic-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsymbolic-7.c?ref=33255ad3ac14e3953750fe0f2d82b901c2852ff6", "patch": "@@ -37,8 +37,10 @@ void test_3 (int i)\n   int arr[2];\n   \n   /* Concrete reads.  */\n-  __analyzer_eval (arr[0] == 42); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (arr[0] == 42); /* { dg-warning \"UNKNOWN\" \"unknown\" } */\n+  /* { dg-warning \"use of uninitialized value 'arr\\\\\\[0\\\\\\]'\" \"uninit\" { target *-*-* } .-1 } */\n \n   /* Symbolic read.  */\n-  __analyzer_eval (arr[i] == 42); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (arr[i] == 42); /* { dg-warning \"UNKNOWN\" \"unknown\" } */\n+  /* { dg-warning \"use of uninitialized value 'arr\\\\\\[i\\\\\\]'\" \"uninit\" { target *-*-* } .-1 } */\n }"}, {"sha": "314c8f3521b3559dad34da353f9214d7ea6ceed3", "filename": "gcc/testsuite/gcc.dg/analyzer/torture/pr93649.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Fpr93649.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Fpr93649.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Fpr93649.c?ref=33255ad3ac14e3953750fe0f2d82b901c2852ff6", "patch": "@@ -1,3 +1,4 @@\n+/* { dg-skip-if \"\" { *-*-* } { \"-fno-fat-lto-objects\" } { \"\" } } */\n /* { dg-additional-options \"-Wno-incompatible-pointer-types -Wno-analyzer-too-complex\" } */\n /* TODO: ideally we shouldn't have -Wno-analyzer-too-complex above; it\n    appears to be needed due to the recursion.  */\n@@ -57,7 +58,7 @@ ts (struct dz *cx)\n {\n   struct dz nt;\n \n-  if (nt.r5)\n+  if (nt.r5) /* { dg-warning \"use of uninitialized value 'nt.r5'\" } */\n     {\n       m6 (cx);\n       h5 (cx);"}, {"sha": "8fcdcd6ad43717db540e87050e0d5b3c465808ba", "filename": "gcc/testsuite/gcc.dg/analyzer/uninit-1.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Funinit-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Funinit-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Funinit-1.c?ref=33255ad3ac14e3953750fe0f2d82b901c2852ff6", "patch": "@@ -0,0 +1,44 @@\n+#include \"analyzer-decls.h\"\n+\n+int test_1 (void)\n+{\n+  int i;\n+  return i; /* { dg-warning \"use of uninitialized value 'i'\" } */\n+}\n+\n+int test_2 (void)\n+{\n+  int i;\n+  return i * 2; /* { dg-warning \"use of uninitialized value 'i'\" } */\n+}\n+\n+int test_3 (void)\n+{\n+  static int i;\n+  return i;\n+}\n+\n+int test_4 (void)\n+{\n+  int *p;\n+  return *p; /* { dg-warning \"use of uninitialized value 'p'\" } */\n+}\n+\n+int test_5 (int flag, int *q)\n+{\n+  int *p;\n+  if (flag) /* { dg-message \"following 'false' branch\" } */\n+    p = q;\n+\n+  /* There should be two enodes here,\n+     i.e. not merging the init vs non-init states.  */\n+  __analyzer_dump_exploded_nodes (0); /* { dg-warning \"2 processed enodes\" } */\n+  \n+  return *p; /* { dg-warning \"use of uninitialized value 'p'\" } */\n+}\n+\n+int test_6 (int i)\n+{\n+  int arr[10];\n+  return arr[i]; /* { dg-warning \"use of uninitialized value 'arr\\\\\\[i\\\\\\]'\" } */\n+}"}, {"sha": "0b0b8b60abdceacc6360a8ac7a5d0fd8e2c88fd1", "filename": "gcc/testsuite/gcc.dg/analyzer/uninit-2.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Funinit-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Funinit-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Funinit-2.c?ref=33255ad3ac14e3953750fe0f2d82b901c2852ff6", "patch": "@@ -0,0 +1,14 @@\n+typedef __SIZE_TYPE__ size_t;\n+\n+extern size_t strlen (const char *__s)\n+  __attribute__ ((__nothrow__ , __leaf__))\n+  __attribute__ ((__pure__))\n+  __attribute__ ((__nonnull__ (1)));\n+\n+extern char *read_file (const char *file);\n+\n+size_t test_1 (const char *file)\n+{\n+  char *str = read_file (file);\n+  return strlen (str);\n+}"}, {"sha": "fa33e0aa136ae977b8ecd6a6a959d217912fa2df", "filename": "gcc/testsuite/gcc.dg/analyzer/uninit-3.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Funinit-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Funinit-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Funinit-3.c?ref=33255ad3ac14e3953750fe0f2d82b901c2852ff6", "patch": "@@ -0,0 +1,36 @@\n+/* Reduced from linux 5.3.11: drivers/net/wireless/ath/ath10k/usb.c  */\n+\n+/* The original file has this licence header.  */\n+\n+// SPDX-License-Identifier: ISC\n+/*\n+ * Copyright (c) 2007-2011 Atheros Communications Inc.\n+ * Copyright (c) 2011-2012,2017 Qualcomm Atheros, Inc.\n+ * Copyright (c) 2016-2017 Erik Stromdahl <erik.stromdahl@gmail.com>\n+ */\n+\n+/* Adapted from include/linux/compiler_attributes.h.  */\n+#define __printf(a, b)                  __attribute__((__format__(printf, a, b)))\n+\n+/* From drivers/net/wireless/ath/ath10k/core.h.  */\n+\n+struct ath10k;\n+\n+/* From drivers/net/wireless/ath/ath10k/debug.h.  */\n+\n+enum ath10k_debug_mask {\n+\t/* [...other values removed...]  */\n+\tATH10K_DBG_USB_BULK\t= 0x00080000,\n+};\n+\n+extern unsigned int ath10k_debug_mask;\n+\n+__printf(3, 4) void __ath10k_dbg(struct ath10k *ar,\n+\t\t\t\t enum ath10k_debug_mask mask,\n+\t\t\t\t const char *fmt, ...);\n+\n+static void ath10k_usb_hif_tx_sg(struct ath10k *ar)\n+{\n+  if (ath10k_debug_mask & ATH10K_DBG_USB_BULK)\n+    __ath10k_dbg(ar, ATH10K_DBG_USB_BULK, \"usb bulk transmit failed: %d\\n\", 42);\n+}"}, {"sha": "791b11106c9afec02b99a9c8d48ed518feb5c3ab", "filename": "gcc/testsuite/gcc.dg/analyzer/uninit-4.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Funinit-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Funinit-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Funinit-4.c?ref=33255ad3ac14e3953750fe0f2d82b901c2852ff6", "patch": "@@ -0,0 +1,39 @@\n+/* Example of interprocedural detection of an uninitialized field\n+   in a heap-allocated struct.  */\n+\n+#include <stdlib.h>\n+#include \"analyzer-decls.h\"\n+\n+struct foo\n+{\n+  int i;\n+  int j;\n+  int k;\n+};\n+\n+struct foo *__attribute__((noinline))\n+alloc_foo (int a, int b)\n+{\n+  struct foo *p = malloc (sizeof (struct foo));\n+  if (!p)\n+    return NULL;\n+  p->i = a;\n+  p->k = b;\n+  return p;\n+}\n+\n+void test (int x, int y, int z)\n+{\n+  struct foo *p = alloc_foo (x, z);\n+  if (!p)\n+    return;\n+\n+  __analyzer_eval (p->i == x); /* { dg-warning \"TRUE\" } */\n+\n+  __analyzer_eval (p->j == y); /* { dg-warning \"UNKNOWN\" \"unknown\" } */\n+  /* { dg-warning \"use of uninitialized value '\\\\*p\\\\.j'\" \"uninit\" { target *-*-* } .-1 } */\n+\n+  __analyzer_eval (p->k == z); /* { dg-warning \"TRUE\" } */\n+  \n+  free (p);\n+}"}, {"sha": "cc337dcb9b0f4279d2480cafae60133fd2e7078e", "filename": "gcc/testsuite/gcc.dg/analyzer/uninit-pr94713.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Funinit-pr94713.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Funinit-pr94713.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Funinit-pr94713.c?ref=33255ad3ac14e3953750fe0f2d82b901c2852ff6", "patch": "@@ -0,0 +1,11 @@\n+void f1 (int *);\n+void f2 (int);\n+\n+int foo (void)\n+{\n+  int *p;\n+\n+  f1 (p); /* { dg-warning \"use of uninitialized value 'p'\" } */\n+  f2 (p[0]); /* { dg-warning \"use of uninitialized value 'p'\" } */\n+  return 0;\n+}"}, {"sha": "df07f986a5e57ac3f78350d883dea66335cdef4c", "filename": "gcc/testsuite/gcc.dg/analyzer/uninit-pr94714.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Funinit-pr94714.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Funinit-pr94714.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Funinit-pr94714.c?ref=33255ad3ac14e3953750fe0f2d82b901c2852ff6", "patch": "@@ -0,0 +1,12 @@\n+#include <stdio.h>\n+\n+int main (void)\n+{\n+  int *p;\n+  int i;\n+\n+  p = &i; /* { dg-bogus \"uninitialized\" } */\n+  printf (\"%d\\n\", p[0]);  /* { dg-warning \"use of uninitialized value '\\\\*p'\" } */\n+\n+  return 0;\n+}"}, {"sha": "fc138ee8215780958d0afd55b7c80540c3b37bf0", "filename": "gcc/testsuite/gcc.dg/analyzer/use-after-free-2.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fuse-after-free-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fuse-after-free-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fuse-after-free-2.c?ref=33255ad3ac14e3953750fe0f2d82b901c2852ff6", "patch": "@@ -0,0 +1,8 @@\n+int test (void)\n+{\n+  int *ptr = (int *)__builtin_malloc (sizeof (int));\n+  *ptr = 42; /* { dg-warning \"dereference of possibly-NULL 'ptr'\" } */\n+  __builtin_free (ptr);\n+\n+  return *ptr; /* { dg-warning \"use after 'free' of 'ptr'\" \"use-after-free\" } */\n+}"}, {"sha": "b19fd3de49f412875749f10cb1231d09e7b89e9e", "filename": "gcc/testsuite/gcc.dg/analyzer/use-after-free-3.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fuse-after-free-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fuse-after-free-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fuse-after-free-3.c?ref=33255ad3ac14e3953750fe0f2d82b901c2852ff6", "patch": "@@ -0,0 +1,12 @@\n+#include <stdlib.h>\n+\n+void test_1 (int x, int y, int *out)\n+{\n+  int *ptr = (int *)malloc (sizeof (int));\n+  if (!ptr)\n+    return;\n+  *ptr = 19;\n+\n+  free (ptr);\n+  *out = *ptr; /* { dg-warning \"use after 'free' of 'ptr'\" } */\n+}"}, {"sha": "57f5dcd8bfedbf355bc7005fb3b6814980637c3c", "filename": "gcc/testsuite/gcc.dg/analyzer/zlib-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fzlib-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fzlib-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fzlib-3.c?ref=33255ad3ac14e3953750fe0f2d82b901c2852ff6", "patch": "@@ -179,7 +179,7 @@ static int huft_build(uInt *b, uInt n, uInt s, const uInt *d, const uInt *e,\n \n       f = 1 << (k - w);\n       for (j = i >> w; j < z; j += f)\n-        q[j] = r;\n+        q[j] = r; /* { dg-warning \"use of uninitialized value 'r.base'\" } */\n \n       mask = (1 << w) - 1;\n       while ((i & mask) != x[h]) {"}, {"sha": "c8e06c61313e169c3d9b8c720767b8c6437e93cd", "filename": "gcc/testsuite/gcc.dg/analyzer/zlib-6.c", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fzlib-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fzlib-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fzlib-6.c?ref=33255ad3ac14e3953750fe0f2d82b901c2852ff6", "patch": "@@ -16,15 +16,8 @@ typedef struct inflate_blocks_state {\n \n extern int inflate_flush(inflate_blocks_statef *, z_stream *, int);\n \n-int inflate_blocks(inflate_blocks_statef *s, z_stream *z, int r) {\n-  uInt t;\n-  uLong b;\n-  uInt k;\n-  Byte *p;\n-  uInt n;\n-  Byte *q;\n-  uInt m;\n-\n+int inflate_blocks(inflate_blocks_statef *s, z_stream *z, int r,\n+\t\t   uLong b, uInt k, Byte *p, uInt n, Byte *q, uInt m) {\n   while (k < (3)) {\n     {\n       if (n)\n@@ -41,7 +34,7 @@ int inflate_blocks(inflate_blocks_statef *s, z_stream *z, int r) {\n         return inflate_flush(s, z, r);\n       }\n     };\n-    b |= ((uLong)(n--, *p++)) << k; /* { dg-warning \"use of uninitialized value\" \"uninit-warning-removed\" { xfail *-*-* } } */\n+    b |= ((uLong)(n--, *p++)) << k;\n     k += 8;\n   }\n }"}, {"sha": "9676e0b384575ce63e60e8de606ac71d4609f5a7", "filename": "gcc/testsuite/gcc.dg/analyzer/zlib-6a.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fzlib-6a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fzlib-6a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fzlib-6a.c?ref=33255ad3ac14e3953750fe0f2d82b901c2852ff6", "patch": "@@ -0,0 +1,47 @@\n+typedef unsigned char Byte;\n+typedef unsigned int uInt;\n+typedef unsigned long uLong;\n+\n+typedef struct z_stream_s {\n+  Byte *next_in;\n+  uInt avail_in;\n+  uLong total_in;\n+} z_stream;\n+\n+typedef struct inflate_blocks_state {\n+  uInt bitk;\n+  uLong bitb;\n+  Byte *write;\n+} inflate_blocks_statef;\n+\n+extern int inflate_flush(inflate_blocks_statef *, z_stream *, int);\n+\n+int inflate_blocks(inflate_blocks_statef *s, z_stream *z, int r) {\n+  uInt t;\n+  uLong b;\n+  uInt k;\n+  Byte *p;\n+  uInt n;\n+  Byte *q;\n+  uInt m;\n+\n+  while (k < (3)) { /* { dg-warning \"use of uninitialized value 'k'\" } */\n+    {\n+      if (n) /* { dg-warning \"use of uninitialized value 'n'\" } */\n+        r = 0;\n+      else {\n+        {\n+\t  s->bitb = b; /* { dg-warning \"use of uninitialized value 'b'\" } */\n+\t  s->bitk = k; /* { dg-warning \"use of uninitialized value 'k'\" } */\n+\t  z->avail_in = n; /* { dg-warning \"use of uninitialized value 'n'\" } */\n+\t  z->total_in += p - z->next_in; /* { dg-warning \"use of uninitialized value 'p'\" } */\n+\t  z->next_in = p; /* { dg-warning \"use of uninitialized value 'p'\" } */\n+          s->write = q; /* { dg-warning \"use of uninitialized value 'q'\" } */\n+        }\n+        return inflate_flush(s, z, r);\n+      }\n+    };\n+    b |= ((uLong)(n--, *p++)) << k; /* { dg-warning \"use of uninitialized value\" } */\n+    k += 8; /* { dg-warning \"use of uninitialized value 'k'\" } */\n+  }\n+}"}, {"sha": "abb6bb212cce16be8f119c6ae8704d8a6b841e52", "filename": "gcc/testsuite/gfortran.dg/analyzer/pr97668.f", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Ftestsuite%2Fgfortran.dg%2Fanalyzer%2Fpr97668.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33255ad3ac14e3953750fe0f2d82b901c2852ff6/gcc%2Ftestsuite%2Fgfortran.dg%2Fanalyzer%2Fpr97668.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fanalyzer%2Fpr97668.f?ref=33255ad3ac14e3953750fe0f2d82b901c2852ff6", "patch": "@@ -1,4 +1,4 @@\n-c { dg-additional-options \"-std=legacy\" }\n+c { dg-additional-options \"-std=legacy -Wno-analyzer-use-of-uninitialized-value -Wno-analyzer-too-complex\" }\n \n       SUBROUTINE PPADD (A, C, BH)\n "}]}