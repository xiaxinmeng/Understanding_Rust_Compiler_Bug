{"sha": "7a56c3bc6225aee179323067e2df21d122cac00c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2E1NmMzYmM2MjI1YWVlMTc5MzIzMDY3ZTJkZjIxZDEyMmNhYzAwYw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2007-04-06T09:29:06Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-04-06T09:29:06Z"}, "message": "s-stchop-vxworks.adb:\n\n2007-04-06  Eric Botcazou <botcazou@adacore.com>\n\n\t* s-stchop-vxworks.adb: \n\t(Stack_Check): Raise Storage_Error if the argument has wrapped around.\n\nFrom-SVN: r123605", "tree": {"sha": "dc8e052f811b58dd9af7317de6b40dc21af2ed8c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dc8e052f811b58dd9af7317de6b40dc21af2ed8c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7a56c3bc6225aee179323067e2df21d122cac00c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a56c3bc6225aee179323067e2df21d122cac00c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a56c3bc6225aee179323067e2df21d122cac00c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a56c3bc6225aee179323067e2df21d122cac00c/comments", "author": null, "committer": null, "parents": [{"sha": "fc879b8f3fe2442e8a7c73b84c3c5d96f8d5ef96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc879b8f3fe2442e8a7c73b84c3c5d96f8d5ef96", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc879b8f3fe2442e8a7c73b84c3c5d96f8d5ef96"}], "stats": {"total": 102, "additions": 57, "deletions": 45}, "files": [{"sha": "bc045ca0397d8fa3a4fcd7c82a5811b35eecf6da", "filename": "gcc/ada/s-stchop-vxworks.adb", "status": "modified", "additions": 57, "deletions": 45, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a56c3bc6225aee179323067e2df21d122cac00c/gcc%2Fada%2Fs-stchop-vxworks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a56c3bc6225aee179323067e2df21d122cac00c/gcc%2Fada%2Fs-stchop-vxworks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-stchop-vxworks.adb?ref=7a56c3bc6225aee179323067e2df21d122cac00c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---          Copyright (C) 1999-2006 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1999-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -49,38 +49,40 @@ with System.OS_Interface;\n \n package body System.Stack_Checking.Operations is\n \n-   --  In order to have stack checking working appropriately on\n-   --  VxWorks we need to extract the stack size information from the\n-   --  VxWorks kernel itself. It means that the library for showing\n-   --  task-related information needs to be linked into the VxWorks\n-   --  system, when using stack checking. The TaskShow library can be\n-   --  linked into the VxWorks system by either:\n+   --  In order to have stack checking working appropriately on VxWorks we need\n+   --  to extract the stack size information from the VxWorks kernel itself. It\n+   --  means that the library for showing task-related information needs to be\n+   --  linked into the VxWorks system, when using stack checking. The TaskShow\n+   --  library can be linked into the VxWorks system by either:\n+\n    --    * defining INCLUDE_SHOW_ROUTINES in config.h when using\n    --      configuration header files, or\n+\n    --    * selecting INCLUDE_TASK_SHOW when using the Tornado project\n    --      facility.\n \n-   function Set_Stack_Info (Stack : access Stack_Access) return Stack_Access;\n+   function Set_Stack_Info\n+     (Stack : not null access Stack_Access) return Stack_Access;\n \n-   --  The function Set_Stack_Info is the actual function that updates\n-   --  the cache containing a pointer to the Stack_Info. It may also\n-   --  be used for detecting asynchronous abort in combination with\n-   --  Invalidate_Self_Cache.\n+   --  The function Set_Stack_Info is the actual function that updates the\n+   --  cache containing a pointer to the Stack_Info. It may also be used for\n+   --  detecting asynchronous abort in combination with Invalidate_Self_Cache.\n \n    --  Set_Stack_Info should do the following things in order:\n    --     1) Get the Stack_Access value for the current task\n    --     2) Set Stack.all to the value obtained in 1)\n    --     3) Optionally Poll to check for asynchronous abort\n \n-   --  This order is important because if at any time a write to\n-   --  the stack cache is pending, that write should be followed\n-   --  by a Poll to prevent loosing signals.\n+   --  This order is important because if at any time a write to the stack\n+   --  cache is pending, that write should be followed by a Poll to prevent\n+   --  loosing signals.\n \n    --  Note: This function must be compiled with Polling turned off\n \n    --  Note: on systems like VxWorks and OS/2 with real thread-local storage,\n    --        Set_Stack_Info should return an access value for such local\n    --        storage. In those cases the cache will always be up-to-date.\n+   --        Fix examples??? Linux???\n \n    --  The following constants should be imported from some system-specific\n    --  constants package. The constants must be static for performance reasons.\n@@ -100,9 +102,8 @@ package body System.Stack_Checking.Operations is\n    --------------------\n \n    function Set_Stack_Info\n-     (Stack : access Stack_Access) return Stack_Access\n+     (Stack : not null access Stack_Access) return Stack_Access\n    is\n-\n       --  Task descriptor that is handled internally by the VxWorks kernel\n \n       type Td_Events_Storage is array (1 .. 4) of Interfaces.C.int;\n@@ -131,8 +132,9 @@ package body System.Stack_Checking.Operations is\n \n       --  This VxWorks procedure fills in a specified task descriptor\n       --  for a specified task.\n-      procedure TaskInfoGet (T_Id : System.OS_Interface.t_id;\n-                             Task_Desc : access Task_Descriptor);\n+      procedure TaskInfoGet\n+        (T_Id      : System.OS_Interface.t_id;\n+         Task_Desc : not null access Task_Descriptor);\n       pragma Import (C, TaskInfoGet, \"taskInfoGet\");\n \n       My_Stack  : Stack_Access;\n@@ -147,12 +149,12 @@ package body System.Stack_Checking.Operations is\n \n       if My_Stack.Base = Null_Address then\n \n-         --  First invocation. Ask the VxWorks kernel about stack\n-         --  values.\n+         --  First invocation. Ask the VxWorks kernel about stack values\n+\n          TaskInfoGet (System.OS_Interface.taskIdSelf, Task_Desc'Access);\n \n-         My_Stack.Size := System.Storage_Elements.Storage_Offset\n-           (Task_Desc.Td_StackSize);\n+         My_Stack.Size :=\n+           System.Storage_Elements.Storage_Offset (Task_Desc.Td_StackSize);\n          My_Stack.Base := Task_Desc.Td_PStackBase;\n          My_Stack.Limit := Task_Desc.Td_PStackLimit;\n \n@@ -168,7 +170,9 @@ package body System.Stack_Checking.Operations is\n          raise Standard'Abort_Signal;\n       end if;\n \n-      return My_Stack; -- Never trust the cached value, but return local copy!\n+      --  Never trust the cached value, return local copy!\n+\n+      return My_Stack;\n    end Set_Stack_Info;\n \n    -----------------\n@@ -179,42 +183,50 @@ package body System.Stack_Checking.Operations is\n      (Stack_Address : System.Address) return Stack_Access\n    is\n       type Frame_Marker is null record;\n+\n       Marker        : Frame_Marker;\n       Cached_Stack  : constant Stack_Access := Cache;\n       Frame_Address : constant System.Address := Marker'Address;\n \n    begin\n-      --  This function first does a \"cheap\" check which is correct\n-      --  if it succeeds. In case of failure, the full check is done.\n-      --  Ideally the cheap check should be done in an optimized manner,\n-      --  or be inlined.\n-\n-      if (Stack_Grows_Down and then\n-            (Frame_Address <= Cached_Stack.Base\n-               and\n-             Stack_Address > Cached_Stack.Limit))\n-        or else\n-         (not Stack_Grows_Down and then\n-            (Frame_Address >= Cached_Stack.Base\n-               and\n-             Stack_Address < Cached_Stack.Limit))\n+      --  The parameter may have wrapped around in System.Address arithmetics.\n+      --  In that case, we have no other choices than raising the exception.\n+\n+      if (Stack_Grows_Down and then Stack_Address > Frame_Address)\n+        or else (not Stack_Grows_Down and then Stack_Address < Frame_Address)\n+      then\n+         Ada.Exceptions.Raise_Exception\n+           (E       => Storage_Error'Identity,\n+            Message => \"stack overflow detected\");\n+      end if;\n+\n+      --  This function first does a \"cheap\" check which is correct if it\n+      --  succeeds. In case of failure, the full check is done. Ideally the\n+      --  cheap check should be done in an optimized manner, or be inlined.\n+\n+      if (Stack_Grows_Down\n+          and then Frame_Address <= Cached_Stack.Base\n+          and then Stack_Address > Cached_Stack.Limit)\n+        or else (not Stack_Grows_Down\n+                   and then Frame_Address >= Cached_Stack.Base\n+                   and then Stack_Address < Cached_Stack.Limit)\n       then\n          --  Cached_Stack is valid as it passed the stack check\n+\n          return Cached_Stack;\n       end if;\n \n       Full_Check :\n       declare\n          My_Stack : constant Stack_Access := Set_Stack_Info (Cache'Access);\n-         --  At this point Stack.all might already be invalid, so\n-         --  it is essential to use our local copy of Stack!\n+         --  At this point Stack.all might already be invalid, so it is\n+         --  essential to use our local copy of Stack!\n \n       begin\n-         if (Stack_Grows_Down and then\n-                  Stack_Address < My_Stack.Limit)\n-           or else\n-            (not Stack_Grows_Down and then\n-                  Stack_Address > My_Stack.Limit)\n+         if (Stack_Grows_Down\n+               and then Stack_Address < My_Stack.Limit)\n+           or else (not Stack_Grows_Down\n+                      and then Stack_Address > My_Stack.Limit)\n          then\n             Ada.Exceptions.Raise_Exception\n               (E       => Storage_Error'Identity,"}]}