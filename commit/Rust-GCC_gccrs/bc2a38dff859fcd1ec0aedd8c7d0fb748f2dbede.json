{"sha": "bc2a38dff859fcd1ec0aedd8c7d0fb748f2dbede", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmMyYTM4ZGZmODU5ZmNkMWVjMGFlZGQ4YzdkMGZiNzQ4ZjJkYmVkZQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2016-12-21T21:58:23Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2016-12-21T21:58:23Z"}, "message": "re PR c++/77830 (internal compiler error: in output_constructor_regular_field, at varasm.c:4968, when using constexpr (with testcase))\n\n\tPR c++/77830\n\t* constexpr.c (cxx_eval_array_reference): Perform out of bounds\n\tverification even if lval is true, just allow one past the last\n\telement in that case.\n\t(cxx_eval_store_expression): Detect stores to out of bound\n\tARRAY_REF.\n\n\t* g++.dg/cpp1y/pr77830.C: New test.\n\t* g++.dg/cpp0x/pr65398.C: Adjust expected diagnostics.\n\nFrom-SVN: r243873", "tree": {"sha": "f329df2339ddea40f6053ce6ac5b7a32624c58b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f329df2339ddea40f6053ce6ac5b7a32624c58b6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bc2a38dff859fcd1ec0aedd8c7d0fb748f2dbede", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc2a38dff859fcd1ec0aedd8c7d0fb748f2dbede", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc2a38dff859fcd1ec0aedd8c7d0fb748f2dbede", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc2a38dff859fcd1ec0aedd8c7d0fb748f2dbede/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "31bfc9b9dd65ecddff3afa690906d94ef7b773da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31bfc9b9dd65ecddff3afa690906d94ef7b773da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31bfc9b9dd65ecddff3afa690906d94ef7b773da"}], "stats": {"total": 178, "additions": 137, "deletions": 41}, "files": [{"sha": "180a0fbbd71c77a790057cce101fa2c4c9bf0f5b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc2a38dff859fcd1ec0aedd8c7d0fb748f2dbede/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc2a38dff859fcd1ec0aedd8c7d0fb748f2dbede/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=bc2a38dff859fcd1ec0aedd8c7d0fb748f2dbede", "patch": "@@ -1,3 +1,12 @@\n+2016-12-21  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/77830\n+\t* constexpr.c (cxx_eval_array_reference): Perform out of bounds\n+\tverification even if lval is true, just allow one past the last\n+\telement in that case.\n+\t(cxx_eval_store_expression): Detect stores to out of bound\n+\tARRAY_REF.\n+\n 2016-12-21  Jason Merrill  <jason@redhat.com>\n \n \tImplement P0522R0, matching of template template arguments."}, {"sha": "ca259cba155e3f526b753e8fe8c21e14b497a6ba", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 82, "deletions": 35, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc2a38dff859fcd1ec0aedd8c7d0fb748f2dbede/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc2a38dff859fcd1ec0aedd8c7d0fb748f2dbede/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=bc2a38dff859fcd1ec0aedd8c7d0fb748f2dbede", "patch": "@@ -2183,49 +2183,48 @@ cxx_eval_array_reference (const constexpr_ctx *ctx, tree t,\n \t\t\t\t\t   lval,\n \t\t\t\t\t   non_constant_p, overflow_p);\n   tree index, oldidx;\n-  HOST_WIDE_INT i;\n-  tree elem_type;\n-  unsigned len, elem_nchars = 1;\n+  HOST_WIDE_INT i = 0;\n+  tree elem_type = NULL_TREE;\n+  unsigned len = 0, elem_nchars = 1;\n   if (*non_constant_p)\n     return t;\n   oldidx = TREE_OPERAND (t, 1);\n   index = cxx_eval_constant_expression (ctx, oldidx,\n \t\t\t\t\tfalse,\n \t\t\t\t\tnon_constant_p, overflow_p);\n   VERIFY_CONSTANT (index);\n-  if (lval && ary == oldary && index == oldidx)\n-    return t;\n-  else if (lval)\n-    return build4 (ARRAY_REF, TREE_TYPE (t), ary, index, NULL, NULL);\n-  elem_type = TREE_TYPE (TREE_TYPE (ary));\n-  if (TREE_CODE (ary) == VIEW_CONVERT_EXPR\n-      && VECTOR_TYPE_P (TREE_TYPE (TREE_OPERAND (ary, 0)))\n-      && TREE_TYPE (t) == TREE_TYPE (TREE_TYPE (TREE_OPERAND (ary, 0))))\n-    ary = TREE_OPERAND (ary, 0);\n-  if (TREE_CODE (ary) == CONSTRUCTOR)\n-    len = CONSTRUCTOR_NELTS (ary);\n-  else if (TREE_CODE (ary) == STRING_CST)\n+  if (!lval)\n     {\n-      elem_nchars = (TYPE_PRECISION (elem_type)\n-\t\t     / TYPE_PRECISION (char_type_node));\n-      len = (unsigned) TREE_STRING_LENGTH (ary) / elem_nchars;\n-    }\n-  else if (TREE_CODE (ary) == VECTOR_CST)\n-    len = VECTOR_CST_NELTS (ary);\n-  else\n-    {\n-      /* We can't do anything with other tree codes, so use\n-\t VERIFY_CONSTANT to complain and fail.  */\n-      VERIFY_CONSTANT (ary);\n-      gcc_unreachable ();\n-    }\n+      elem_type = TREE_TYPE (TREE_TYPE (ary));\n+      if (TREE_CODE (ary) == VIEW_CONVERT_EXPR\n+\t  && VECTOR_TYPE_P (TREE_TYPE (TREE_OPERAND (ary, 0)))\n+\t  && TREE_TYPE (t) == TREE_TYPE (TREE_TYPE (TREE_OPERAND (ary, 0))))\n+\tary = TREE_OPERAND (ary, 0);\n+      if (TREE_CODE (ary) == CONSTRUCTOR)\n+\tlen = CONSTRUCTOR_NELTS (ary);\n+      else if (TREE_CODE (ary) == STRING_CST)\n+\t{\n+\t  elem_nchars = (TYPE_PRECISION (elem_type)\n+\t\t\t / TYPE_PRECISION (char_type_node));\n+\t  len = (unsigned) TREE_STRING_LENGTH (ary) / elem_nchars;\n+\t}\n+      else if (TREE_CODE (ary) == VECTOR_CST)\n+\tlen = VECTOR_CST_NELTS (ary);\n+      else\n+\t{\n+\t  /* We can't do anything with other tree codes, so use\n+\t     VERIFY_CONSTANT to complain and fail.  */\n+\t  VERIFY_CONSTANT (ary);\n+\t  gcc_unreachable ();\n+\t}\n \n-  if (!tree_fits_shwi_p (index)\n-      || (i = tree_to_shwi (index)) < 0)\n-    {\n-      diag_array_subscript (ctx, ary, index);\n-      *non_constant_p = true;\n-      return t;\n+      if (!tree_fits_shwi_p (index)\n+\t  || (i = tree_to_shwi (index)) < 0)\n+\t{\n+\t  diag_array_subscript (ctx, ary, index);\n+\t  *non_constant_p = true;\n+\t  return t;\n+\t}\n     }\n \n   tree nelts;\n@@ -2240,13 +2239,20 @@ cxx_eval_array_reference (const constexpr_ctx *ctx, tree t,\n   nelts = cxx_eval_constant_expression (ctx, nelts, false, non_constant_p,\n \t\t\t\t\toverflow_p);\n   VERIFY_CONSTANT (nelts);\n-  if (!tree_int_cst_lt (index, nelts))\n+  if (lval\n+      ? !tree_int_cst_le (index, nelts)\n+      : !tree_int_cst_lt (index, nelts))\n     {\n       diag_array_subscript (ctx, ary, index);\n       *non_constant_p = true;\n       return t;\n     }\n \n+  if (lval && ary == oldary && index == oldidx)\n+    return t;\n+  else if (lval)\n+    return build4 (ARRAY_REF, TREE_TYPE (t), ary, index, NULL, NULL);\n+\n   bool found;\n   if (TREE_CODE (ary) == CONSTRUCTOR)\n     {\n@@ -3281,6 +3287,47 @@ cxx_eval_store_expression (const constexpr_ctx *ctx, tree t,\n   if (*non_constant_p)\n     return t;\n \n+  /* cxx_eval_array_reference for lval = true allows references one past\n+     end of array, because it does not know if it is just taking address\n+     (which is valid), or actual dereference.  Here we know it is\n+     a dereference, so diagnose it here.  */\n+  for (tree probe = target; probe; )\n+    {\n+      switch (TREE_CODE (probe))\n+\t{\n+\tcase ARRAY_REF:\n+\t  tree nelts, ary;\n+\t  ary = TREE_OPERAND (probe, 0);\n+\t  if (TREE_CODE (TREE_TYPE (ary)) == ARRAY_TYPE)\n+\t    nelts = array_type_nelts_top (TREE_TYPE (ary));\n+\t  else if (VECTOR_TYPE_P (TREE_TYPE (ary)))\n+\t    nelts = size_int (TYPE_VECTOR_SUBPARTS (TREE_TYPE (ary)));\n+\t  else\n+\t    gcc_unreachable ();\n+\t  nelts = cxx_eval_constant_expression (ctx, nelts, false,\n+\t\t\t\t\t\tnon_constant_p, overflow_p);\n+\t  VERIFY_CONSTANT (nelts);\n+\t  gcc_assert (TREE_CODE (nelts) == INTEGER_CST\n+\t\t      && TREE_CODE (TREE_OPERAND (probe, 1)) == INTEGER_CST);\n+\t  if (wi::eq_p (TREE_OPERAND (probe, 1), nelts))\n+\t    {\n+\t      diag_array_subscript (ctx, ary, TREE_OPERAND (probe, 1));\n+\t      *non_constant_p = true;\n+\t      return t;\n+\t    }\n+\t  /* FALLTHRU */\n+\n+\tcase BIT_FIELD_REF:\n+\tcase COMPONENT_REF:\n+\t  probe = TREE_OPERAND (probe, 0);\n+\t  continue;\n+\n+\tdefault:\n+\t  probe = NULL_TREE;\n+\t  continue;\n+\t}\n+    }\n+\n   if (!same_type_ignoring_top_level_qualifiers_p (TREE_TYPE (target), type))\n     {\n       /* For initialization of an empty base, the original target will be"}, {"sha": "2da0d44dfb7addfe3583c96f0d4f1f9173768ff8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc2a38dff859fcd1ec0aedd8c7d0fb748f2dbede/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc2a38dff859fcd1ec0aedd8c7d0fb748f2dbede/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bc2a38dff859fcd1ec0aedd8c7d0fb748f2dbede", "patch": "@@ -1,3 +1,9 @@\n+2016-12-21  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/77830\n+\t* g++.dg/cpp1y/pr77830.C: New test.\n+\t* g++.dg/cpp0x/pr65398.C: Adjust expected diagnostics.\n+\n 2016-12-21  Bernd Schmidt  <bschmidt@redhat.com>\n \n \tPR target/71321"}, {"sha": "bab875c788ce386f86554c2eedda7727e3c49f77", "filename": "gcc/testsuite/g++.dg/cpp0x/pr65398.C", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc2a38dff859fcd1ec0aedd8c7d0fb748f2dbede/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr65398.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc2a38dff859fcd1ec0aedd8c7d0fb748f2dbede/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr65398.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr65398.C?ref=bc2a38dff859fcd1ec0aedd8c7d0fb748f2dbede", "patch": "@@ -20,9 +20,9 @@ constexpr char d5 = *(&s[4] - 4);\n constexpr char d6 = *(&s[4] - 5);  // { dg-error \"array subscript\" }\n \n /* Don't accept invalid stuff.  */\n-constexpr char e1 = *(&s[5] - 1); // { dg-error \"is not a constant expression\" }\n-constexpr char e2 = *(&s[5] - 2); // { dg-error \"is not a constant expression\" }\n-constexpr char e3 = *(&s[5] - 3); // { dg-error \"is not a constant expression\" }\n+constexpr char e1 = *(&s[5] - 1); // { dg-error \"array subscript\" }\n+constexpr char e2 = *(&s[5] - 2); // { dg-error \"array subscript\" }\n+constexpr char e3 = *(&s[5] - 3); // { dg-error \"array subscript\" }\n \n SA (c1 == 'a');\n SA (c2 == 'b');\n@@ -53,9 +53,9 @@ constexpr char j5 = *(&l[4] - 4);\n constexpr char j6 = *(&l[4] - 5);  // { dg-error \"array subscript\" }\n \n /* Don't accept invalid stuff.  */\n-constexpr char k1 = *(&l[5] - 1); // { dg-error \"is not a constant expression\" }\n-constexpr char k2 = *(&l[5] - 2); // { dg-error \"is not a constant expression\" }\n-constexpr char k3 = *(&l[5] - 3); // { dg-error \"is not a constant expression\" }\n+constexpr char k1 = *(&l[5] - 1); // { dg-error \"array subscript\" }\n+constexpr char k2 = *(&l[5] - 2); // { dg-error \"array subscript\" }\n+constexpr char k3 = *(&l[5] - 3); // { dg-error \"array subscript\" }\n \n SA (i1 == 'c');\n SA (i2 == 'd');"}, {"sha": "9235b405225c3915c3837940fe516a0a8d04548c", "filename": "gcc/testsuite/g++.dg/cpp1y/pr77830.C", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc2a38dff859fcd1ec0aedd8c7d0fb748f2dbede/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fpr77830.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc2a38dff859fcd1ec0aedd8c7d0fb748f2dbede/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fpr77830.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fpr77830.C?ref=bc2a38dff859fcd1ec0aedd8c7d0fb748f2dbede", "patch": "@@ -0,0 +1,34 @@\n+// PR c++/77830\n+// { dg-do compile { target c++14 } }\n+\n+template <int N>\n+struct P\n+{\n+  char arr[N][1];\n+  constexpr void foo (const char *, int);\n+};\n+\n+template <int N>\n+constexpr void\n+P<N>::foo (const char *, int i)\n+{\n+  for (auto j = 0; j < 2; ++j)\n+    arr[i][j] = true;\n+}\n+\n+template <typename... T>\n+constexpr auto\n+bar (T... a)\n+{\n+  const char *s[]{a...};\n+  P<sizeof...(a)> p{};\n+  for (auto i = 0; i < sizeof...(a); ++i)\n+    p.foo (s[i], i);\n+  return p;\n+}\n+\n+int\n+main ()\n+{\n+  constexpr auto a = bar (\"\", \"\");\t// { dg-error \"outside the bounds of array type\" }\n+}"}]}