{"sha": "5a9335ef017c45e09d9493b982a25a8e58b51d40", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWE5MzM1ZWYwMTdjNDVlMDlkOTQ5M2I5ODJhMjVhOGU1OGI1MWQ0MA==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@redhat.com", "date": "2003-06-18T16:36:13Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2003-06-18T16:36:13Z"}, "message": "config.gcc: Add an extra_header for ARM targets.\n\n\t* config.gcc: Add an extra_header for ARM targets.\n        Support configuring with --with-cpu=iwmmxt.\n\t* doc/invoke.texi: Document new value for -mcpu= ARM switch.\n        * config/arm/aof.h (REGISTER_NAMES): Add iwmmxt register\n\tnames.  Fix formatting.\n        * config/arm/aout.h (REGISTER_NAMES): Add iwmmxt register\n\tnames.\n        * config/arm/arm-protos.h (arm_emit_vector_const): New\n\tprototype.\n\t(arm_output_load_gr): New prototype.\n\t* config/arm/arm.c (extra_reg_names1): Delete.\n        (TARGET_INIT_BUILTINS, TARGET_EXPAND_BUILTIN, FL_IWMMXT,\n\t* arch_is_iwmmxt): Define.\n\t(all_cores, all_architecture): Add entry for iwmmxt.\n\t(arm_override_options): Add support for iwmmxt.\n\t(use_return_insn, arm_function_arg, arm_legitimate_index_p,\n\tarm_print_value, arm_rtx_costs_1, output_move_double,\n\tarm_compute_save_reg_mask, arm_output_epilogue,\n\tarm_get_frame_size, arm_expand_prologue, arm_print_operand,\n\tarm_assemble_integer, arm_hard_regno_ok, arm_regno_class):\n\tLikewise.\n\t(arm_init_cumulative_args): Count iwmmxt registers.\n\t(arm_function_ok_for_sibcall): Return false of sibcall_blocked\n\thas been set.\n\t(struct minipool_node): Add fix_size field.\n\t(add_minipool_forward_ref): Add support for 8-byte aligning of\n\tthe pool.\n\t(add_minipool_backward_ref, add_minipool_offsets,\n\tdump_minipool, push_minipool_fix): Likewise.\n\t(struct builtin_description): New struct.\n        (builtin_description): New array of iwmmxt builtin functions.\n        (arm_init_iwmmxt_builtins): New function.\n        (arm_init_builtins): New function.\n        (safe_vector_operand): New function.\n        (arm_expand_binop_builtin): New function.\n        (arm_expand_unop_builtin): New function.\n        (arm_expand_builtin): New function.\n        (arm_emit_vector_const): New function.\n        (arm_output_load_gr): New function.\n        * config/arm/arm.h (TARGET_CPU_iwmmxt, TARGET_IWMMXT,\n\tTARGET_REALLY_IWMMXT, arm_arch_iwmmxt, IWMMXT_ALIGNMENT,\n\tTYPE_NEEDS_IWMMXT_ALIGNMENT, ADJUST_FIELD_ALIGN,\n\tDATA_ALIGNMENT, LOCAL_ALIGNMENT, VECTOR_MODE_SUPPORTED_P): Define.\n        (BIGGEST_ALIGNMENT): Set to 64 if ATPCS support is enabled.\n        (CPP_CPU_ARCH_SPEC): Add entries for iwmmxt.\n        (FIXED_REGISTERS, CALL_USED_REGISTERS, REG_ALLOC_ORDER,\n\treg_class, REG_CLASS_NAMES, REG_CLASS_CONTENTS,\n\tREG_CLASS_FOR_LETTER): Add iwmmxt registers.\n        (SUBTARGET_CONDITIONAL_REGISTER_USAGE): Disable iwmmxt\n\tregisters unless the iwmmxt target is selected.\n        (FIRST_IWMMXT_GR_REGNUM, LAST_IWMMXT_GR_REGNUM,\n\tFIRST_IWMMXT_REGNUM, LAST_IWMMXT_REGNUM, IS_IWMMXT_REGNUM,\n\tIS_IWMMXT_GR_REGNUM): Define.\n        (FIRST_PSEUDO_REGISTER): Bump to 63.\n        (struct machine_function): Add sibcall_blocked field.\n        (Struct CUMULATIVE_ARGS): Add iwmmxt_nregs, named_count and\n\tnargs fields.\n        (enum arm_builtins): New enum list.\n        * config/arm/arm.md (UNSPEC_WSHUFH, UNSPEC_WACC,\n\tUNSPEC_TMOVMSK, UNSPEC_WSAD, UNSPEC_WSADZ, UNSPEC_WMACS,\n\tUNSPEC_WMACU, UNSPEC_WMACSZ, UNSPEC_WMACUZ, UNSPEC_CLRDI,\n\tUNSPEC_WMADDS, UNSPEC_WMADDU): New unspecs.\n\t(VUNSPEC_TMRC, VUNSPEC_TMCR, VUNSPEC_ALIGN8, VUNSPEC_WCMP_EQ,\n\tVUNSPEC_WCMP_GTU, VUNSPEC_WCMP_GT): New vunspecs.\n        (movv2si, movv4hi, movv8qi): New expands for vector moves.\n        Include iwmmxt.md.\n\t* config/arm/t-xscale-elf (MULTILIB_OPITONS): Add iwmmxt\n\tmultilib.\n        (MULTILIB_DIRNAMES, MULTILIB_REDUNDANT_DIRS): Likewise.\n        * config/arm/mmintrin.h: New ARM specific header file.\n        * config/arm/iwmmx.md: New iWMMXt specific machine patterns.\n\nFrom-SVN: r68157", "tree": {"sha": "d43f1d9c2d7a342f6366c0c862be1f1935c5654e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d43f1d9c2d7a342f6366c0c862be1f1935c5654e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5a9335ef017c45e09d9493b982a25a8e58b51d40", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a9335ef017c45e09d9493b982a25a8e58b51d40", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a9335ef017c45e09d9493b982a25a8e58b51d40", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a9335ef017c45e09d9493b982a25a8e58b51d40/comments", "author": {"login": "nickclifton", "id": 31441682, "node_id": "MDQ6VXNlcjMxNDQxNjgy", "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nickclifton", "html_url": "https://github.com/nickclifton", "followers_url": "https://api.github.com/users/nickclifton/followers", "following_url": "https://api.github.com/users/nickclifton/following{/other_user}", "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}", "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions", "organizations_url": "https://api.github.com/users/nickclifton/orgs", "repos_url": "https://api.github.com/users/nickclifton/repos", "events_url": "https://api.github.com/users/nickclifton/events{/privacy}", "received_events_url": "https://api.github.com/users/nickclifton/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7d8b7202f8b3f7b7494713b9e5ee62ca3c798c08", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d8b7202f8b3f7b7494713b9e5ee62ca3c798c08", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d8b7202f8b3f7b7494713b9e5ee62ca3c798c08"}], "stats": {"total": 4846, "additions": 4662, "deletions": 184}, "files": [{"sha": "e1a63b4441e712a5822d5ef6be1940c924f90d62", "filename": "gcc/ChangeLog", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a9335ef017c45e09d9493b982a25a8e58b51d40/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a9335ef017c45e09d9493b982a25a8e58b51d40/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5a9335ef017c45e09d9493b982a25a8e58b51d40", "patch": "@@ -1,3 +1,77 @@\n+2003-06-18  Nick Clifton  <nickc@redhat.com>\n+\n+\t* config.gcc: Add an extra_header for ARM targets.\n+        Support configuring with --with-cpu=iwmmxt.\n+\t* doc/invoke.texi: Document new value for -mcpu= ARM switch.\n+        * config/arm/aof.h (REGISTER_NAMES): Add iwmmxt register\n+\tnames.  Fix formatting.        \n+        * config/arm/aout.h (REGISTER_NAMES): Add iwmmxt register\n+\tnames.\n+        * config/arm/arm-protos.h (arm_emit_vector_const): New\n+\tprototype.\n+\t(arm_output_load_gr): New prototype.\n+\t* config/arm/arm.c (extra_reg_names1): Delete.\n+        (TARGET_INIT_BUILTINS, TARGET_EXPAND_BUILTIN, FL_IWMMXT,\n+\t* arch_is_iwmmxt): Define.\n+\t(all_cores, all_architecture): Add entry for iwmmxt.\n+\t(arm_override_options): Add support for iwmmxt.\n+\t(use_return_insn, arm_function_arg, arm_legitimate_index_p,\n+\tarm_print_value, arm_rtx_costs_1, output_move_double,\n+\tarm_compute_save_reg_mask, arm_output_epilogue,\n+\tarm_get_frame_size, arm_expand_prologue, arm_print_operand,\n+\tarm_assemble_integer, arm_hard_regno_ok, arm_regno_class):\n+\tLikewise.\n+\t(arm_init_cumulative_args): Count iwmmxt registers.\n+\t(arm_function_ok_for_sibcall): Return false of sibcall_blocked\n+\thas been set.\n+\t(struct minipool_node): Add fix_size field.\n+\t(add_minipool_forward_ref): Add support for 8-byte aligning of\n+\tthe pool.\n+\t(add_minipool_backward_ref, add_minipool_offsets,\n+\tdump_minipool, push_minipool_fix): Likewise.\n+\t(struct builtin_description): New struct.\n+        (builtin_description): New array of iwmmxt builtin functions.\n+        (arm_init_iwmmxt_builtins): New function.\n+        (arm_init_builtins): New function.\n+        (safe_vector_operand): New function.\n+        (arm_expand_binop_builtin): New function.\n+        (arm_expand_unop_builtin): New function.\n+        (arm_expand_builtin): New function.\n+        (arm_emit_vector_const): New function.\n+        (arm_output_load_gr): New function.\n+        * config/arm/arm.h (TARGET_CPU_iwmmxt, TARGET_IWMMXT,\n+\tTARGET_REALLY_IWMMXT, arm_arch_iwmmxt, IWMMXT_ALIGNMENT,\n+\tTYPE_NEEDS_IWMMXT_ALIGNMENT, ADJUST_FIELD_ALIGN,\n+\tDATA_ALIGNMENT, LOCAL_ALIGNMENT, VECTOR_MODE_SUPPORTED_P): Define.\n+        (BIGGEST_ALIGNMENT): Set to 64 if ATPCS support is enabled.\n+        (CPP_CPU_ARCH_SPEC): Add entries for iwmmxt.\n+        (FIXED_REGISTERS, CALL_USED_REGISTERS, REG_ALLOC_ORDER,\n+\treg_class, REG_CLASS_NAMES, REG_CLASS_CONTENTS,\n+\tREG_CLASS_FOR_LETTER): Add iwmmxt registers.\n+        (SUBTARGET_CONDITIONAL_REGISTER_USAGE): Disable iwmmxt\n+\tregisters unless the iwmmxt target is selected.\n+        (FIRST_IWMMXT_GR_REGNUM, LAST_IWMMXT_GR_REGNUM,\n+\tFIRST_IWMMXT_REGNUM, LAST_IWMMXT_REGNUM, IS_IWMMXT_REGNUM,\n+\tIS_IWMMXT_GR_REGNUM): Define.\n+        (FIRST_PSEUDO_REGISTER): Bump to 63.\n+        (struct machine_function): Add sibcall_blocked field.\n+        (Struct CUMULATIVE_ARGS): Add iwmmxt_nregs, named_count and\n+\tnargs fields.\n+        (enum arm_builtins): New enum list.\n+        * config/arm/arm.md (UNSPEC_WSHUFH, UNSPEC_WACC,\n+\tUNSPEC_TMOVMSK, UNSPEC_WSAD, UNSPEC_WSADZ, UNSPEC_WMACS,\n+\tUNSPEC_WMACU, UNSPEC_WMACSZ, UNSPEC_WMACUZ, UNSPEC_CLRDI,\n+\tUNSPEC_WMADDS, UNSPEC_WMADDU): New unspecs.\n+\t(VUNSPEC_TMRC, VUNSPEC_TMCR, VUNSPEC_ALIGN8, VUNSPEC_WCMP_EQ,\n+\tVUNSPEC_WCMP_GTU, VUNSPEC_WCMP_GT): New vunspecs.\n+        (movv2si, movv4hi, movv8qi): New expands for vector moves.\n+        Include iwmmxt.md.\n+\t* config/arm/t-xscale-elf (MULTILIB_OPITONS): Add iwmmxt\n+\tmultilib.\n+        (MULTILIB_DIRNAMES, MULTILIB_REDUNDANT_DIRS): Likewise.\n+        * config/arm/mmintrin.h: New ARM specific header file.\n+        * config/arm/iwmmx.md: New iWMMXt specific machine patterns.\n+\n 2003-06-18  J\"orn Rennecke <joern.rennecke@superh.com>\n \n \t* toplev.c (Remaining -d letters summary): Update."}, {"sha": "d517d1e560bb75d85e3b1c651d54412726aa11e9", "filename": "gcc/config.gcc", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a9335ef017c45e09d9493b982a25a8e58b51d40/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a9335ef017c45e09d9493b982a25a8e58b51d40/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=5a9335ef017c45e09d9493b982a25a8e58b51d40", "patch": "@@ -281,12 +281,14 @@ strongarm*-*-*)\n \t;;\n arm*-*-*)\n \tcpu_type=arm\n+\textra_headers=\"mmintrin.h\"\n \t;;\n ep9312*-*-*)\n \tcpu_type=arm\n \t;;\n xscale-*-*)\n \tcpu_type=arm\n+\textra_headers=\"mmintrin.h\"\n \t;;\n i[34567]86-*-*)\n \tcpu_type=i386\n@@ -2303,7 +2305,7 @@ then\n \t\t\t| xarm920t | xarm940t | xarm9e | xarm10tdmi \\\n \t\t\t| xarm7100 | xarm7500 | xarm7500fe | xarm810 \\\n \t\t\t| xarm1020t \\\n-\t\t\t| xxscale \\\n+\t\t\t| xxscale | xiwmmxt \\\n \t\t\t| xep9312 \\\n \t\t\t| xstrongarm | xstrongarm110 | xstrongarm11[01]0)\n \t\t\t\t# OK"}, {"sha": "39f2cc3857e6932781264f4ea67e7fec823c24ba", "filename": "gcc/config/arm/aof.h", "status": "modified", "additions": 111, "deletions": 96, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a9335ef017c45e09d9493b982a25a8e58b51d40/gcc%2Fconfig%2Farm%2Faof.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a9335ef017c45e09d9493b982a25a8e58b51d40/gcc%2Fconfig%2Farm%2Faof.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Faof.h?ref=5a9335ef017c45e09d9493b982a25a8e58b51d40", "patch": "@@ -1,6 +1,6 @@\n /* Definitions of target machine for GNU compiler, for Advanced RISC Machines\n    ARM compilation, AOF Assembler.\n-   Copyright (C) 1995, 1996, 1997, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1995, 1996, 1997, 2000, 2003 Free Software Foundation, Inc.\n    Contributed by Richard Earnshaw (rearnsha@armltd.co.uk)\n \n    This file is part of GCC.\n@@ -59,64 +59,70 @@\n #define EXTRA_SECTIONS in_zero_init, in_common\n \n #define EXTRA_SECTION_FUNCTIONS\t\\\n-ZERO_INIT_SECTION\t\t\\\n-COMMON_SECTION\n+  ZERO_INIT_SECTION\t\t\\\n+  COMMON_SECTION\n \n #define ZERO_INIT_SECTION\t\t\t\t\t\\\n-void\t\t\t\t\t\t\t\t\\\n-zero_init_section ()\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-  static int zero_init_count = 1;\t\t\t\t\\\n-  if (in_section != in_zero_init)\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      fprintf (asm_out_file, \"\\tAREA |C$$zidata%d|,NOINIT\\n\",\t\\\n-\t       zero_init_count++);\t\t\t\t\\\n-      in_section = in_zero_init;\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-}\n+  void\t\t\t\t\t\t\t\t\\\n+  zero_init_section ()\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    static int zero_init_count = 1;\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+    if (in_section != in_zero_init)\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+        fprintf (asm_out_file, \"\\tAREA |C$$zidata%d|,NOINIT\\n\",\t\\\n+\t         zero_init_count++);\t\t\t\t\\\n+        in_section = in_zero_init;\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+  }\n \n /* Used by ASM_OUTPUT_COMMON (below) to tell varasm.c that we've\n    changed areas.  */\n #define COMMON_SECTION\t\t\t\t\t\t\\\n-void\t\t\t\t\t\t\t\t\\\n-common_section ()\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-  if (in_section != in_common)\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n+  void\t\t\t\t\t\t\t\t\\\n+  common_section ()\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    if (in_section != in_common)\t\t\t\t\\\n       in_section = in_common;\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-}\n-#define CTOR_LIST_BEGIN\t\t\t\t\t\\\n-asm (CTORS_SECTION_ASM_OP);\t\t\t\t\\\n-extern func_ptr __CTOR_END__[1];\t\t\t\\\n-func_ptr __CTOR_LIST__[1] = {__CTOR_END__};\n+  }\n \n-#define CTOR_LIST_END\t\t\t\t\t\\\n-asm (CTORS_SECTION_ASM_OP);\t\t\t\t\\\n-func_ptr __CTOR_END__[1] = { (func_ptr) 0 };\n+#define CTOR_LIST_BEGIN\t\t\t\t\\\n+  asm (CTORS_SECTION_ASM_OP);\t\t\t\\\n+  extern func_ptr __CTOR_END__[1];\t\t\\\n+  func_ptr __CTOR_LIST__[1] = {__CTOR_END__};\n \n-#define DO_GLOBAL_CTORS_BODY\t\t\\\n-do {\t\t\t\t\t\\\n-  func_ptr *ptr = __CTOR_LIST__ + 1;\t\\\n-  while (*ptr)\t\t\t\t\\\n-    (*ptr++) ();\t\t\t\\\n-} while (0)\n+#define CTOR_LIST_END\t\t\t\t\\\n+  asm (CTORS_SECTION_ASM_OP);\t\t\t\\\n+  func_ptr __CTOR_END__[1] = { (func_ptr) 0 };\n \n-#define DTOR_LIST_BEGIN\t\t\t\t\t\\\n-asm (DTORS_SECTION_ASM_OP);\t\t\t\t\\\n-extern func_ptr __DTOR_END__[1];\t\t\t\\\n-func_ptr __DTOR_LIST__[1] = {__DTOR_END__};\n+#define DO_GLOBAL_CTORS_BODY\t\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      func_ptr *ptr = __CTOR_LIST__ + 1;\t\\\n+\t\t\t\t\t\t\\\n+      while (*ptr)\t\t\t\t\\\n+        (*ptr++) ();\t\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n \n-#define DTOR_LIST_END\t\t\t\t\t\\\n-asm (DTORS_SECTION_ASM_OP);\t\t\t\t\\\n-func_ptr __DTOR_END__[1] = { (func_ptr) 0 };\n+#define DTOR_LIST_BEGIN\t\t\t\t\\\n+  asm (DTORS_SECTION_ASM_OP);\t\t\t\\\n+  extern func_ptr __DTOR_END__[1];\t\t\\\n+  func_ptr __DTOR_LIST__[1] = {__DTOR_END__};\n \n-#define DO_GLOBAL_DTORS_BODY\t\t\\\n-do {\t\t\t\t\t\\\n-  func_ptr *ptr = __DTOR_LIST__ + 1;\t\\\n-  while (*ptr)\t\t\t\t\\\n-    (*ptr++) ();\t\t\t\\\n-} while (0)\n+#define DTOR_LIST_END\t\t\t\t\\\n+  asm (DTORS_SECTION_ASM_OP);\t\t\t\\\n+  func_ptr __DTOR_END__[1] = { (func_ptr) 0 };\n+\n+#define DO_GLOBAL_DTORS_BODY\t\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      func_ptr *ptr = __DTOR_LIST__ + 1;\t\\\n+\t\t\t\t\t\t\\\n+      while (*ptr)\t\t\t\t\\\n+        (*ptr++) ();\t\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n \n /* We really want to put Thumb tables in a read-only data section, but\n    switching to another section during function output is not\n@@ -171,44 +177,41 @@ do {\t\t\t\t\t\\\n #define SYMBOL__MAIN __gccmain\n \n #define ASM_COMMENT_START \";\"\n+#define ASM_APP_ON        \"\"\n+#define ASM_APP_OFF       \"\"\n \n-#define ASM_APP_ON \"\"\n-\n-#define ASM_APP_OFF \"\"\n-\n-#define ASM_OUTPUT_ASCII(STREAM,PTR,LEN)\t\t\\\n+#define ASM_OUTPUT_ASCII(STREAM, PTR, LEN)\t\t\\\n {\t\t\t\t\t\t\t\\\n   int i;\t\t\t\t\t\t\\\n   const char *ptr = (PTR);\t\t\t\t\\\n   fprintf ((STREAM), \"\\tDCB\");\t\t\t\t\\\n   for (i = 0; i < (long)(LEN); i++)\t\t\t\\\n     fprintf ((STREAM), \" &%02x%s\", \t\t\t\\\n \t     (unsigned ) *(ptr++),\t\t\t\\\n-\t     (i + 1 < (long)(LEN)\t\t\t\t\\\n+\t     (i + 1 < (long)(LEN)\t\t\t\\\n \t      ? ((i & 3) == 3 ? \"\\n\\tDCB\" : \",\")\t\\\n \t      : \"\\n\"));\t\t\t\t\t\\\n }\n \n #define IS_ASM_LOGICAL_LINE_SEPARATOR(C) ((C) == '\\n')\n \n-/* Output of Uninitialized Variables */\n+/* Output of Uninitialized Variables.  */\n \n-#define ASM_OUTPUT_COMMON(STREAM,NAME,SIZE,ROUNDED)\t\t\\\n+#define ASM_OUTPUT_COMMON(STREAM, NAME, SIZE, ROUNDED)\t\t\\\n   (common_section (),\t\t\t\t\t\t\\\n    fprintf ((STREAM), \"\\tAREA \"),\t\t\t\t\\\n    assemble_name ((STREAM), (NAME)),\t\t\t\t\\\n    fprintf ((STREAM), \", DATA, COMMON\\n\\t%% %d\\t%s size=%d\\n\",\t\\\n \t    (int)(ROUNDED), ASM_COMMENT_START, (int)(SIZE)))\n \n-#define ASM_OUTPUT_LOCAL(STREAM,NAME,SIZE,ROUNDED)\t\\\n+#define ASM_OUTPUT_LOCAL(STREAM, NAME, SIZE, ROUNDED)\t\\\n    (zero_init_section (),\t\t\t\t\\\n     assemble_name ((STREAM), (NAME)),\t\t\t\\\n     fprintf ((STREAM), \"\\n\"),\t\t\t\t\\\n     fprintf ((STREAM), \"\\t%% %d\\t%s size=%d\\n\",\t\t\\\n \t     (int)(ROUNDED), ASM_COMMENT_START, (int)(SIZE)))\n \n /* Output and Generation of Labels */\n-\n extern int arm_main_function;\n \n /* Globalizing directive for a label.  */\n@@ -258,22 +261,31 @@ do {\t\t\t\t\t\\\n #define ASM_GENERATE_INTERNAL_LABEL(STRING,PREFIX,NUM)\t\\\n   sprintf ((STRING), \"*|%s..%ld|\", (PREFIX), (long)(NUM))\n \n-/* How initialization functions are handled */\n+/* How initialization functions are handled.  */\n \n #define CTORS_SECTION_ASM_OP \"\\tAREA\\t|C$$gnu_ctorsvec|, DATA, READONLY\"\n #define DTORS_SECTION_ASM_OP \"\\tAREA\\t|C$$gnu_dtorsvec|, DATA, READONLY\"\n \n-/* Output of Assembler Instructions */\n-\n-#define REGISTER_NAMES\t\t\t\\\n-{\t\t\t\t\t\\\n-  \"a1\", \"a2\", \"a3\", \"a4\",\t\\\n-  \"v1\", \"v2\", \"v3\", \"v4\",\t\\\n-  \"v5\", \"v6\", \"sl\", \"fp\",\t\\\n-  \"ip\", \"sp\", \"lr\", \"pc\",\t\\\n-  \"f0\", \"f1\", \"f2\", \"f3\",\t\\\n-  \"f4\", \"f5\", \"f6\", \"f7\",\t\\\n-  \"cc\", \"sfp\", \"afp\"\t\t\\\n+/* Output of Assembler Instructions.  */\n+\n+#define REGISTER_NAMES\t\t\t\t\\\n+{\t\t\t\t\t\t\\\n+  \"a1\", \"a2\", \"a3\", \"a4\",\t\t\t\\\n+  \"v1\", \"v2\", \"v3\", \"v4\",\t\t\t\\\n+  \"v5\", \"v6\", \"sl\", \"fp\",\t\t\t\\\n+  \"ip\", \"sp\", \"lr\", \"pc\",\t\t\t\\\n+  \"f0\", \"f1\", \"f2\", \"f3\",\t\t\t\\\n+  \"f4\", \"f5\", \"f6\", \"f7\",\t\t\t\\\n+  \"cc\", \"sfp\", \"afp\",\t\t\t\t\\\n+  \"mv0\",   \"mv1\",   \"mv2\",   \"mv3\",\t\t\\\n+  \"mv4\",   \"mv5\",   \"mv6\",   \"mv7\",\t\t\\\n+  \"mv8\",   \"mv9\",   \"mv10\",  \"mv11\",\t\t\\\n+  \"mv12\",  \"mv13\",  \"mv14\",  \"mv15\",\t\t\\\n+  \"wcgr0\", \"wcgr1\", \"wcgr2\", \"wcgr3\",\t\t\\\n+  \"wr0\",   \"wr1\",   \"wr2\",   \"wr3\",\t\t\\\n+  \"wr4\",   \"wr5\",   \"wr6\",   \"wr7\",\t\t\\\n+  \"wr8\",   \"wr9\",   \"wr10\",  \"wr11\",\t\t\\\n+  \"wr12\",  \"wr13\",  \"wr14\",  \"wr15\"\n }\n \n #define ADDITIONAL_REGISTER_NAMES\t\t\\\n@@ -303,37 +315,40 @@ do {\t\t\t\t\t\\\n /* AOF does not prefix user function names with an underscore.  */\n #define ARM_MCOUNT_NAME \"_mcount\"\n \n-/* Output of Dispatch Tables */\n-\n-#define ASM_OUTPUT_ADDR_DIFF_ELT(STREAM,BODY,VALUE,REL)\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    if (TARGET_ARM)\t\t\t\t\t\t\t\\\n-      fprintf ((STREAM), \"\\tb\\t|L..%d|\\n\", (VALUE));\t\t\t\\\n-    else\t\t\t\t\t\t\t\t\\\n-      fprintf ((STREAM), \"\\tDCD\\t|L..%d| - |L..%d|\\n\", (VALUE), (REL));\t\\\n-  } while (0)\n-\n-#define ASM_OUTPUT_ADDR_VEC_ELT(STREAM,VALUE)\t\\\n+/* Output of Dispatch Tables.  */\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(STREAM, BODY, VALUE, REL)\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\t\\\n+      if (TARGET_ARM)\t\t\t\t\t\t\t\t\\\n+        fprintf ((STREAM), \"\\tb\\t|L..%d|\\n\", (VALUE));\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\t\\\n+        fprintf ((STREAM), \"\\tDCD\\t|L..%d| - |L..%d|\\n\", (VALUE), (REL));\t\\\n+    }\t\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define ASM_OUTPUT_ADDR_VEC_ELT(STREAM, VALUE)\t\\\n   fprintf ((STREAM), \"\\tDCD\\t|L..%d|\\n\", (VALUE))\n \n /* A label marking the start of a jump table is a data label. */\n-#define ASM_OUTPUT_CASE_LABEL(STREAM,PREFIX,NUM,TABLE)\t\\\n+#define ASM_OUTPUT_CASE_LABEL(STREAM, PREFIX, NUM, TABLE)\t\\\n   fprintf ((STREAM), \"\\tALIGN\\n|%s..%d|\\n\", (PREFIX), (NUM))\n \n-/* Assembler Commands for Alignment */\n-\n-#define ASM_OUTPUT_SKIP(STREAM,NBYTES)\t\t\\\n- fprintf ((STREAM), \"\\t%%\\t%d\\n\", (int)(NBYTES))\n-\n-#define ASM_OUTPUT_ALIGN(STREAM,POWER)\t\t\t\\\n-do {\t\t\t\t\t\t\t\\\n-  register int amount = 1 << (POWER);\t\t\t\\\n-  if (amount == 2)\t\t\t\t\t\\\n-    fprintf ((STREAM), \"\\tALIGN 2\\n\");\t\t\t\\\n-  else if (amount == 4)\t\t\t\t\t\\\n-    fprintf ((STREAM), \"\\tALIGN\\n\");\t\t\t\\\n-  else\t\t\t\t\t\t\t\\\n-    fprintf ((STREAM), \"\\tALIGN %d\\n\", amount);\t\t\\\n-} while (0)\n+/* Assembler Commands for Alignment.  */\n+#define ASM_OUTPUT_SKIP(STREAM, NBYTES)\t\t\\\n+ fprintf ((STREAM), \"\\t%%\\t%d\\n\", (int) (NBYTES))\n+\n+#define ASM_OUTPUT_ALIGN(STREAM, POWER)\t\t\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      int amount = 1 << (POWER);\t\t\t\\\n+\t\t\t\t\t\t\t\\\n+      if (amount == 2)\t\t\t\t\t\\\n+        fprintf ((STREAM), \"\\tALIGN 2\\n\");\t\t\\\n+      else if (amount == 4)\t\t\t\t\\\n+        fprintf ((STREAM), \"\\tALIGN\\n\");\t\t\\\n+      else\t\t\t\t\t\t\\\n+        fprintf ((STREAM), \"\\tALIGN %d\\n\", amount);\t\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0)\n \n #undef DBX_DEBUGGING_INFO"}, {"sha": "23679ebdb1d26e1b3e246091d964a6d0b33b94b2", "filename": "gcc/config/arm/aout.h", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a9335ef017c45e09d9493b982a25a8e58b51d40/gcc%2Fconfig%2Farm%2Faout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a9335ef017c45e09d9493b982a25a8e58b51d40/gcc%2Fconfig%2Farm%2Faout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Faout.h?ref=5a9335ef017c45e09d9493b982a25a8e58b51d40", "patch": "@@ -65,7 +65,6 @@\n #define LOCAL_LABEL_PREFIX \t\"\"\n #endif\n \n-\n /* The assembler's names for the registers.  */\n #ifndef REGISTER_NAMES\n #define REGISTER_NAMES  \t\t\t   \\\n@@ -74,9 +73,15 @@\n   \"r8\", \"r9\", \"sl\", \"fp\", \"ip\", \"sp\", \"lr\", \"pc\",  \\\n   \"f0\", \"f1\", \"f2\", \"f3\", \"f4\", \"f5\", \"f6\", \"f7\",  \\\n   \"cc\", \"sfp\", \"afp\",\t\t   \t\t   \\\n-  \"mv0\",  \"mv1\",   \"mv2\",  \"mv3\",  \"mv4\",   \"mv5\", \\\n-  \"mv6\",  \"mv7\",   \"mv8\",  \"mv9\",  \"mv10\",  \"mv11\",\\\n-  \"mv12\", \"mv13\",  \"mv14\", \"mv15\"\t\t   \\\n+  \"mv0\",   \"mv1\",   \"mv2\",   \"mv3\",\t\t   \\\n+  \"mv4\",   \"mv5\",   \"mv6\",   \"mv7\",\t\t   \\\n+  \"mv8\",   \"mv9\",   \"mv10\",  \"mv11\",\t\t   \\\n+  \"mv12\",  \"mv13\",  \"mv14\",  \"mv15\",\t\t   \\\n+  \"wcgr0\", \"wcgr1\", \"wcgr2\", \"wcgr3\",\t\t   \\\n+  \"wr0\",   \"wr1\",   \"wr2\",   \"wr3\",\t\t   \\\n+  \"wr4\",   \"wr5\",   \"wr6\",   \"wr7\",\t\t   \\\n+  \"wr8\",   \"wr9\",   \"wr10\",  \"wr11\",\t\t   \\\n+  \"wr12\",  \"wr13\",  \"wr14\",  \"wr15\"\t\t   \\\n }\n #endif\n \n@@ -235,12 +240,12 @@\n \n #undef  ASM_OUTPUT_ASCII\n #define ASM_OUTPUT_ASCII(STREAM, PTR, LEN)  \\\n-  output_ascii_pseudo_op (STREAM, (const unsigned char *)(PTR), LEN)\n+  output_ascii_pseudo_op (STREAM, (const unsigned char *) (PTR), LEN)\n \n /* Output a gap.  In fact we fill it with nulls.  */\n #undef  ASM_OUTPUT_SKIP\n #define ASM_OUTPUT_SKIP(STREAM, NBYTES) \t\\\n-  fprintf (STREAM, \"\\t.space\\t%d\\n\", (int)(NBYTES))\n+  fprintf (STREAM, \"\\t.space\\t%d\\n\", (int) (NBYTES))\n \n /* Align output to a power of two.  Horrible /bin/as.  */\n #ifndef ASM_OUTPUT_ALIGN  "}, {"sha": "fe424d7c22e6435df270569a466daa5d9aa4dcb3", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a9335ef017c45e09d9493b982a25a8e58b51d40/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a9335ef017c45e09d9493b982a25a8e58b51d40/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=5a9335ef017c45e09d9493b982a25a8e58b51d40", "patch": "@@ -135,6 +135,8 @@ extern void arm_final_prescan_insn (rtx);\n extern int arm_go_if_legitimate_address (enum machine_mode, rtx);\n extern int arm_debugger_arg_offset (int, rtx);\n extern int arm_is_longcall_p (rtx, int, int);\n+extern int    arm_emit_vector_const (FILE *, rtx);\n+extern const char * arm_output_load_gr (rtx *);\n \n #if defined TREE_CODE\n extern rtx arm_function_arg (CUMULATIVE_ARGS *, enum machine_mode, tree, int);"}, {"sha": "e5b1324c54660e711b9d4a68a70bc95ff73a15b2", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 1305, "deletions": 46, "changes": 1351, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a9335ef017c45e09d9493b982a25a8e58b51d40/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a9335ef017c45e09d9493b982a25a8e58b51d40/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=5a9335ef017c45e09d9493b982a25a8e58b51d40", "patch": "@@ -55,12 +55,6 @@\n typedef struct minipool_node    Mnode;\n typedef struct minipool_fixup   Mfix;\n \n-const char extra_reg_names1[][16] =\n-{ \"mv0\", \"mv1\", \"mv2\",  \"mv3\",  \"mv4\",  \"mv5\",  \"mv6\",  \"mv7\",\n-  \"mv8\", \"mv9\", \"mv10\", \"mv11\", \"mv12\", \"mv13\", \"mv14\", \"mv15\"\n-};\n-#define extra_reg_names1 bogus1_regnames\n-\n const struct attribute_spec arm_attribute_table[];\n \n /* Forward function declarations.  */\n@@ -135,6 +129,14 @@ static int arm_address_cost (rtx);\n static bool arm_memory_load_p (rtx);\n static bool arm_cirrus_insn_p (rtx);\n static void cirrus_reorg (rtx);\n+static void arm_init_builtins (void);\n+static rtx arm_expand_builtin (tree, rtx, rtx, enum machine_mode, int);\n+static void arm_init_iwmmxt_builtins (void);\n+static rtx safe_vector_operand (rtx, enum machine_mode);\n+static rtx arm_expand_binop_builtin (enum insn_code, tree, rtx);\n+static rtx arm_expand_unop_builtin (enum insn_code, tree, rtx, int);\n+static rtx arm_expand_builtin (tree, rtx, rtx, enum machine_mode, int);\n+\n #ifdef OBJECT_FORMAT_ELF\n static void arm_elf_asm_named_section (const char *, unsigned int);\n #endif\n@@ -201,28 +203,33 @@ static void aof_file_end (void);\n #define TARGET_ENCODE_SECTION_INFO  arm_encode_section_info\n #endif\n \n-#undef TARGET_STRIP_NAME_ENCODING\n+#undef  TARGET_STRIP_NAME_ENCODING\n #define TARGET_STRIP_NAME_ENCODING arm_strip_name_encoding\n \n-#undef TARGET_ASM_INTERNAL_LABEL\n+#undef  TARGET_ASM_INTERNAL_LABEL\n #define TARGET_ASM_INTERNAL_LABEL arm_internal_label\n \n-#undef TARGET_FUNCTION_OK_FOR_SIBCALL\n+#undef  TARGET_FUNCTION_OK_FOR_SIBCALL\n #define TARGET_FUNCTION_OK_FOR_SIBCALL arm_function_ok_for_sibcall\n \n-#undef TARGET_ASM_OUTPUT_MI_THUNK\n+#undef  TARGET_ASM_OUTPUT_MI_THUNK\n #define TARGET_ASM_OUTPUT_MI_THUNK arm_output_mi_thunk\n-#undef TARGET_ASM_CAN_OUTPUT_MI_THUNK\n+#undef  TARGET_ASM_CAN_OUTPUT_MI_THUNK\n #define TARGET_ASM_CAN_OUTPUT_MI_THUNK default_can_output_mi_thunk_no_vcall\n \n-#undef TARGET_RTX_COSTS\n+#undef  TARGET_RTX_COSTS\n #define TARGET_RTX_COSTS arm_rtx_costs\n-#undef TARGET_ADDRESS_COST\n+#undef  TARGET_ADDRESS_COST\n #define TARGET_ADDRESS_COST arm_address_cost\n \n-#undef TARGET_MACHINE_DEPENDENT_REORG\n+#undef  TARGET_MACHINE_DEPENDENT_REORG\n #define TARGET_MACHINE_DEPENDENT_REORG arm_reorg\n \n+#undef  TARGET_INIT_BUILTINS\n+#define TARGET_INIT_BUILTINS  arm_init_builtins\n+#undef  TARGET_EXPAND_BUILTIN\n+#define TARGET_EXPAND_BUILTIN arm_expand_builtin\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Obstack for minipool constant handling.  */\n@@ -271,6 +278,7 @@ int    arm_structure_size_boundary = DEFAULT_STRUCTURE_SIZE_BOUNDARY;\n #define FL_ARCH5E     (1 << 9)        /* DSP extensions to v5 */\n #define FL_XSCALE     (1 << 10)\t      /* XScale */\n #define FL_CIRRUS     (1 << 11)\t      /* Cirrus/DSP.  */\n+#define FL_IWMMXT     (1 << 29)\t      /* XScale v2 or \"Intel Wireless MMX technology\".  */\n \n /* The bits in this mask specify which\n    instructions we are allowed to generate.  */\n@@ -303,6 +311,9 @@ int arm_ld_sched = 0;\n /* Nonzero if this chip is a StrongARM.  */\n int arm_is_strong = 0;\n \n+/* Nonzero if this chip supports Intel Wireless MMX technology.  */\n+int arm_arch_iwmmxt = 0;\n+\n /* Nonzero if this chip is an XScale.  */\n int arm_arch_xscale = 0;\n \n@@ -413,6 +424,7 @@ static const struct processors all_cores[] =\n   {\"arm10tdmi\",\t                         FL_MODE32 | FL_FAST_MULT | FL_ARCH4 | FL_THUMB | FL_LDSCHED             | FL_ARCH5 },\n   {\"arm1020t\",\t                         FL_MODE32 | FL_FAST_MULT | FL_ARCH4 | FL_THUMB | FL_LDSCHED             | FL_ARCH5 },\n   {\"xscale\",                             FL_MODE32 | FL_FAST_MULT | FL_ARCH4 | FL_THUMB | FL_LDSCHED | FL_STRONG | FL_ARCH5 | FL_ARCH5E | FL_XSCALE },\n+  {\"iwmmxt\",                             FL_MODE32 | FL_FAST_MULT | FL_ARCH4 | FL_THUMB | FL_LDSCHED | FL_STRONG | FL_ARCH5 | FL_ARCH5E | FL_XSCALE | FL_IWMMXT },\n \n   {NULL, 0}\n };\n@@ -433,6 +445,7 @@ static const struct processors all_architectures[] =\n   { \"armv5t\",    FL_CO_PROC |             FL_MODE32 | FL_FAST_MULT | FL_ARCH4 | FL_THUMB | FL_ARCH5 },\n   { \"armv5te\",   FL_CO_PROC |             FL_MODE32 | FL_FAST_MULT | FL_ARCH4 | FL_THUMB | FL_ARCH5 | FL_ARCH5E },\n   { \"ep9312\",\t\t\t\t  FL_MODE32 | FL_FAST_MULT | FL_ARCH4 | FL_LDSCHED | FL_CIRRUS },\n+  {\"iwmmxt\",                             FL_MODE32 | FL_FAST_MULT | FL_ARCH4 | FL_THUMB | FL_LDSCHED | FL_STRONG | FL_ARCH5 | FL_ARCH5E | FL_XSCALE | FL_IWMMXT },\n   { NULL, 0 }\n };\n \n@@ -530,6 +543,7 @@ arm_override_options (void)\n \t{ TARGET_CPU_strongarm, \"strongarm\" },\n \t{ TARGET_CPU_xscale,    \"xscale\" },\n \t{ TARGET_CPU_ep9312,    \"ep9312\" },\n+\t{ TARGET_CPU_iwmmxt,    \"iwmmxt\" },\n \t{ TARGET_CPU_generic,   \"arm\" },\n \t{ 0, 0 }\n       };\n@@ -730,6 +744,10 @@ arm_override_options (void)\n \t\t       && !(tune_flags & FL_ARCH4))) != 0;\n   arm_tune_xscale       = (tune_flags & FL_XSCALE) != 0;\n   arm_is_cirrus\t    = (tune_flags & FL_CIRRUS) != 0;\n+  arm_arch_iwmmxt   = (insn_flags & FL_IWMMXT) != 0;\n+\n+  if (TARGET_IWMMXT && (! TARGET_ATPCS))\n+    target_flags |= ARM_FLAG_ATPCS;    \n \n   if (arm_is_cirrus)\n     {\n@@ -888,7 +906,7 @@ arm_isr_value (tree argument)\n   arg = TREE_STRING_POINTER (TREE_VALUE (argument));\n \n   /* Check it against the list of known arguments.  */\n-  for (ptr = isr_attribute_args; ptr->arg != NULL; ptr ++)\n+  for (ptr = isr_attribute_args; ptr->arg != NULL; ptr++)\n     if (streq (arg, ptr->arg))\n       return ptr->return_value;\n \n@@ -1020,6 +1038,11 @@ use_return_insn (int iscond)\n       if (regs_ever_live[regno] && !call_used_regs[regno])\n \treturn 0;\n \n+  if (TARGET_REALLY_IWMMXT)\n+    for (regno = FIRST_IWMMXT_REGNUM; regno <= LAST_IWMMXT_REGNUM; regno++)\n+      if (regs_ever_live[regno] && ! call_used_regs [regno])\n+\treturn 0;\n+\n   return 1;\n }\n \n@@ -1943,6 +1966,7 @@ arm_init_cumulative_args (CUMULATIVE_ARGS *pcum, tree fntype,\n {\n   /* On the ARM, the offset starts at 0.  */\n   pcum->nregs = ((fntype && aggregate_value_p (TREE_TYPE (fntype))) ? 1 : 0);\n+  pcum->iwmmxt_nregs = 0;\n   \n   pcum->call_cookie = CALL_NORMAL;\n \n@@ -1958,6 +1982,24 @@ arm_init_cumulative_args (CUMULATIVE_ARGS *pcum, tree fntype,\n       else if (lookup_attribute (\"long_call\", TYPE_ATTRIBUTES (fntype)))\n \tpcum->call_cookie = CALL_LONG;\n     }\n+\n+  /* Varargs vectors are treated the same as long long.\n+     named_count avoids having to change the way arm handles 'named' */\n+  pcum->named_count = 0;\n+  pcum->nargs = 0;\n+\n+  if (TARGET_REALLY_IWMMXT && fntype)\n+    {\n+      tree fn_arg;\n+\n+      for (fn_arg = TYPE_ARG_TYPES (fntype);\n+\t   fn_arg;\n+\t   fn_arg = TREE_CHAIN (fn_arg))\n+\tpcum->named_count += 1;\n+\n+      if (! pcum->named_count)\n+\tpcum->named_count = INT_MAX;\n+    }\n }\n \n /* Determine where to put an argument to a function.\n@@ -1977,6 +2019,30 @@ rtx\n arm_function_arg (CUMULATIVE_ARGS *pcum, enum machine_mode mode,\n \t\t  tree type ATTRIBUTE_UNUSED, int named)\n {\n+  if (TARGET_REALLY_IWMMXT)\n+    {\n+      if (VECTOR_MODE_SUPPORTED_P (mode))\n+\t{\n+\t  /* varargs vectors are treated the same as long long.\n+\t     named_count avoids having to change the way arm handles 'named' */\n+\t  if (pcum->named_count <= pcum->nargs + 1)\n+\t    {\n+\t      if (pcum->nregs == 1)\n+\t\tpcum->nregs += 1;\n+\t      if (pcum->nregs <= 2)\n+\t\treturn gen_rtx_REG (mode, pcum->nregs);\n+\t      else\n+\t\treturn NULL_RTX;\n+\t    }\n+\t  else if (pcum->iwmmxt_nregs <= 9)\n+\t    return gen_rtx_REG (mode, pcum->iwmmxt_nregs + FIRST_IWMMXT_REGNUM);\n+\t  else\n+\t    return NULL_RTX;\n+\t}\n+      else if ((mode == DImode || mode == DFmode) && pcum->nregs & 1)\n+\tpcum->nregs += 1;\n+    }\n+\n   if (mode == VOIDmode)\n     /* Compute operand 2 of the call insn.  */\n     return GEN_INT (pcum->call_cookie);\n@@ -2010,6 +2076,26 @@ arm_va_arg (tree valist, tree type)\n       return gen_rtx_MEM (ptr_mode, force_reg (Pmode, addr));\n     }\n \n+  if (FUNCTION_ARG_BOUNDARY (TYPE_MODE (type), NULL) == IWMMXT_ALIGNMENT)\n+    {\n+      tree minus_eight;\n+      tree t;\n+\n+      /* Maintain 64-bit alignment of the valist pointer by\n+\t contructing:   valist = ((valist + (8 - 1)) & -8).  */\n+      minus_eight = build_int_2 (- (IWMMXT_ALIGNMENT / BITS_PER_UNIT), -1);\n+      t = build_int_2 ((IWMMXT_ALIGNMENT / BITS_PER_UNIT) - 1, 0);\n+      t = build (PLUS_EXPR,    TREE_TYPE (valist), valist, t);\n+      t = build (BIT_AND_EXPR, TREE_TYPE (t), t, minus_eight);\n+      t = build (MODIFY_EXPR,  TREE_TYPE (valist), valist, t);\n+      TREE_SIDE_EFFECTS (t) = 1;\n+      expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\n+      /* This is to stop the combine pass optimising\n+\t away the alignment adjustment.  */\n+      mark_reg_pointer (arg_pointer_rtx, PARM_BOUNDARY);\n+    }\n+\n   return std_expand_builtin_va_arg (valist, type);\n }\n \f\n@@ -2316,6 +2402,9 @@ arm_function_ok_for_sibcall (tree decl, tree exp ATTRIBUTE_UNUSED)\n {\n   int call_type = TARGET_LONG_CALLS ? CALL_LONG : CALL_NORMAL;\n \n+  if (cfun->machine->sibcall_blocked)\n+    return false;\n+\n   /* Never tailcall something for which we have no decl, or if we\n      are in Thumb mode.  */\n   if (decl == NULL || TARGET_THUMB)\n@@ -2661,6 +2750,11 @@ arm_legitimate_index_p (enum machine_mode mode, rtx index, int strict_p)\n       && GET_MODE_SIZE (mode) <= 4)\n     return 1;\n \n+  if (TARGET_REALLY_IWMMXT && VALID_IWMMXT_REG_MODE (mode))\n+    return (code == CONST_INT\n+\t    && INTVAL (index) < 256\n+\t    && INTVAL (index) > -256);\n+\n   /* XXX What about ldrsb?  */\n   if (GET_MODE_SIZE (mode) <= 4  && code == MULT\n       && (!arm_arch4 || (mode) != HImode))\n@@ -3298,6 +3392,13 @@ arm_rtx_costs_1 (rtx x, enum rtx_code code, enum rtx_code outer)\n \tcase SImode:\n \t  return (1 + (GET_CODE (XEXP (x, 0)) == MEM ? 10 : 0));\n \n+\tcase V8QImode:\n+\tcase V4HImode:\n+\tcase V2SImode:\n+\tcase V4QImode:\n+\tcase V2HImode:\n+\t    return 1;\n+\n \tdefault:\n \t  break;\n \t}\n@@ -5820,6 +5921,21 @@ arm_print_value (FILE *f, rtx x)\n       fprintf (f, \"<0x%lx,0x%lx>\", (long)XWINT (x, 2), (long)XWINT (x, 3));\n       return;\n \n+    case CONST_VECTOR:\n+      {\n+\tint i;\n+\n+\tfprintf (f, \"<\");\n+\tfor (i = 0; i < CONST_VECTOR_NUNITS (x); i++)\n+\t  {\n+\t    fprintf (f, HOST_WIDE_INT_PRINT_HEX, INTVAL (CONST_VECTOR_ELT (x, i)));\n+\t    if (i < (CONST_VECTOR_NUNITS (x) - 1))\n+\t      fputc (',', f);\n+\t  }\n+\tfprintf (f, \">\");\n+      }\n+      return;\n+\n     case CONST_STRING:\n       fprintf (f, \"\\\"%s\\\"\", XSTR (x, 0));\n       return;\n@@ -5940,6 +6056,8 @@ struct minipool_node\n   rtx value;\n   /* The mode of value.  */\n   enum machine_mode mode;\n+  /* The size of the value.  With iWMMXt enabled\n+     sizes > 4 also imply an alignment of 8-bytes.  */\n   int fix_size;\n };\n \n@@ -6115,6 +6233,19 @@ add_minipool_forward_ref (Mfix *fix)\n       if (max_mp == NULL\n \t  && mp->max_address > max_address)\n \tmax_mp = mp;\n+\n+      /* If we are inserting an 8-bytes aligned quantity and\n+\t we have not already found an insertion point, then\n+\t make sure that all such 8-byte aligned quantities are\n+\t placed at the start of the pool.  */\n+      if (TARGET_REALLY_IWMMXT\n+\t  && max_mp == NULL\n+\t  && fix->fix_size == 8\n+\t  && mp->fix_size != 8)\n+\t{\n+\t  max_mp = mp;\n+\t  max_address = mp->max_address;\n+\t}\n     }\n \n   /* The value is not currently in the minipool, so we need to create\n@@ -6288,7 +6419,14 @@ add_minipool_backward_ref (Mfix *fix)\n \t{\n \t  /* Note the insertion point if necessary.  */\n \t  if (mp->min_address < min_address)\n-\t    min_mp = mp;\n+\t    {\n+\t      /* For now, we do not allow the insertion of 8-byte alignment\n+\t\t requiring nodes anywhere but at the start of the pool.  */\n+\t      if (TARGET_REALLY_IWMMXT && fix->fix_size == 8 && mp->fix_size != 8)\n+\t\treturn NULL;\n+\t      else\n+\t\tmin_mp = mp;\n+\t    }\n \t  else if (mp->max_address\n \t\t   < minipool_barrier->address + mp->offset + fix->fix_size)\n \t    {\n@@ -6299,6 +6437,18 @@ add_minipool_backward_ref (Mfix *fix)\n \t      min_mp = mp;\n \t      min_address = mp->min_address + fix->fix_size;\n \t    }\n+\t  /* If we are inserting an 8-bytes aligned quantity and\n+\t     we have not already found an insertion point, then\n+\t     make sure that all such 8-byte aligned quantities are\n+\t     placed at the start of the pool.  */\n+\t  else if (TARGET_REALLY_IWMMXT\n+\t\t   && min_mp == NULL\n+\t\t   && fix->fix_size == 8\n+\t\t   && mp->fix_size < 8)\n+\t    {\n+\t      min_mp = mp;\n+\t      min_address = mp->min_address + fix->fix_size;\n+\t    }\n \t}\n     }\n \n@@ -6385,16 +6535,25 @@ assign_minipool_offsets (Mfix *barrier)\n static void\n dump_minipool (rtx scan)\n {\n-  Mnode *mp;\n-  Mnode *nmp;\n+  Mnode * mp;\n+  Mnode * nmp;\n+  int align64 = 0;\n+\n+  if (TARGET_REALLY_IWMMXT)\n+    for (mp = minipool_vector_head; mp != NULL; mp = mp->next)\n+      if (mp->refcount > 0 && mp->fix_size == 8)\n+\t{\n+\t  align64 = 1;\n+\t  break;\n+\t}\n \n   if (rtl_dump_file)\n     fprintf (rtl_dump_file,\n-\t     \";; Emitting minipool after insn %u; address %ld\\n\",\n-\t     INSN_UID (scan), (unsigned long) minipool_barrier->address);\n+\t     \";; Emitting minipool after insn %u; address %ld; align %d (bytes)\\n\",\n+\t     INSN_UID (scan), (unsigned long) minipool_barrier->address, align64 ? 8 : 4);\n \n   scan = emit_label_after (gen_label_rtx (), scan);\n-  scan = emit_insn_after (gen_align_4 (), scan);\n+  scan = emit_insn_after (align64 ? gen_align_8 () : gen_align_4 (), scan);\n   scan = emit_label_after (minipool_vector_label, scan);\n \n   for (mp = minipool_vector_head; mp != NULL; mp = nmp)\n@@ -6622,6 +6781,13 @@ push_minipool_fix (rtx insn, HOST_WIDE_INT address, rtx *loc,\n   if (fix->forwards == 0 && fix->backwards == 0)\n     abort ();\n \n+  /* With iWMMXt enabled, the pool is aligned to an 8-byte boundary.\n+     So there might be an empty word before the start of the pool.\n+     Hence we reduce the forward range by 4 to allow for this\n+     possibility.  */\n+  if (TARGET_REALLY_IWMMXT && fix->fix_size == 8)\n+    fix->forwards -= 4;\n+\n   if (rtl_dump_file)\n     {\n       fprintf (rtl_dump_file,\n@@ -7137,6 +7303,105 @@ output_move_double (rtx *operands)\n \t  else\n \t    output_asm_insn (\"mov%?\\t%R0, %R1\\n\\tmov%?\\t%Q0, %Q1\", operands);\n \t}\n+      else if (code1 == CONST_VECTOR)\n+\t{\n+\t  HOST_WIDE_INT hint = 0;\n+\n+\t  switch (GET_MODE (operands[1]))\n+\t    {\n+\t    case V2SImode:\n+\t      otherops[1] = GEN_INT (INTVAL (CONST_VECTOR_ELT (operands[1], 1)));\n+\t      operands[1] = GEN_INT (INTVAL (CONST_VECTOR_ELT (operands[1], 0)));\n+\t      break;\n+\n+\t    case V4HImode:\n+\t      if (BYTES_BIG_ENDIAN)\n+\t\t{\n+\t\t  hint = INTVAL (CONST_VECTOR_ELT (operands[1], 2));\n+\t\t  hint <<= 16;\n+\t\t  hint |= INTVAL (CONST_VECTOR_ELT (operands[1], 3));\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  hint = INTVAL (CONST_VECTOR_ELT (operands[1], 3));\n+\t\t  hint <<= 16;\n+\t\t  hint |= INTVAL (CONST_VECTOR_ELT (operands[1], 2));\n+\t\t}\n+\n+\t      otherops[1] = GEN_INT (hint);\n+\t      hint = 0;\n+\n+\t      if (BYTES_BIG_ENDIAN)\n+\t\t{\n+\t\t  hint |= INTVAL (CONST_VECTOR_ELT (operands[1], 0));\n+\t\t  hint <<= 16;\n+\t\t  hint |= INTVAL (CONST_VECTOR_ELT (operands[1], 1));\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  hint |= INTVAL (CONST_VECTOR_ELT (operands[1], 1));\n+\t\t  hint <<= 16;\n+\t\t  hint |= INTVAL (CONST_VECTOR_ELT (operands[1], 0));\n+\t\t}\n+\n+\t      operands[1] = GEN_INT (hint);\n+\t      break;\n+\n+\t    case V8QImode:\n+\t      if (BYTES_BIG_ENDIAN)\n+\t\t{\n+\t\t  hint |= INTVAL (CONST_VECTOR_ELT (operands[1], 4));\n+\t\t  hint <<= 8;\n+\t\t  hint |= INTVAL (CONST_VECTOR_ELT (operands[1], 5));\n+\t\t  hint <<= 8;\n+\t\t  hint |= INTVAL (CONST_VECTOR_ELT (operands[1], 6));\n+\t\t  hint <<= 8;\n+\t\t  hint |= INTVAL (CONST_VECTOR_ELT (operands[1], 7));\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  hint |= INTVAL (CONST_VECTOR_ELT (operands[1], 7));\n+\t\t  hint <<= 8;\n+\t\t  hint |= INTVAL (CONST_VECTOR_ELT (operands[1], 6));\n+\t\t  hint <<= 8;\n+\t\t  hint |= INTVAL (CONST_VECTOR_ELT (operands[1], 5));\n+\t\t  hint <<= 8;\n+\t\t  hint |= INTVAL (CONST_VECTOR_ELT (operands[1], 4));\n+\t\t}\n+\n+\t      otherops[1] = GEN_INT (hint);\n+\t      hint = 0;\n+\n+\t      if (BYTES_BIG_ENDIAN)\n+\t\t{\n+\t\t  hint |= INTVAL (CONST_VECTOR_ELT (operands[1], 0));\n+\t\t  hint <<= 8;\n+\t\t  hint |= INTVAL (CONST_VECTOR_ELT (operands[1], 1));\n+\t\t  hint <<= 8;\n+\t\t  hint |= INTVAL (CONST_VECTOR_ELT (operands[1], 2));\n+\t\t  hint <<= 8;\n+\t\t  hint |= INTVAL (CONST_VECTOR_ELT (operands[1], 3));\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  hint |= INTVAL (CONST_VECTOR_ELT (operands[1], 3));\n+\t\t  hint <<= 8;\n+\t\t  hint |= INTVAL (CONST_VECTOR_ELT (operands[1], 2));\n+\t\t  hint <<= 8;\n+\t\t  hint |= INTVAL (CONST_VECTOR_ELT (operands[1], 1));\n+\t\t  hint <<= 8;\n+\t\t  hint |= INTVAL (CONST_VECTOR_ELT (operands[1], 0));\n+\t\t}\n+\n+\t      operands[1] = GEN_INT (hint);\n+\t      break;\n+\t      \n+\t    default:\n+\t      abort ();\n+\t    }\n+\t  output_mov_immediate (operands);\n+\t  output_mov_immediate (otherops);\n+\t}\n       else if (code1 == CONST_DOUBLE)\n \t{\n \t  if (GET_MODE (operands[1]) == DFmode)\n@@ -7367,9 +7632,9 @@ output_mov_immediate (rtx *operands)\n       int i;\n \n       /* If all else fails, make it out of ORRs or BICs as appropriate.  */\n-      for (i = 0; i < 32; i ++)\n+      for (i = 0; i < 32; i++)\n \tif (n & 1 << i)\n-\t  n_ones ++;\n+\t  n_ones++;\n \n       if (n_ones > 16)  /* Shorter to use MVN with BIC in this case.  */\n \toutput_multi_immediate (operands, \"mvn%?\\t%0, %1\", \"bic%?\\t%0, %0, %1\", 1, ~ n);\n@@ -7751,6 +8016,34 @@ arm_compute_save_reg_mask (void)\n   if (cfun->machine->lr_save_eliminated)\n     save_reg_mask &= ~ (1 << LR_REGNUM);\n \n+  if (TARGET_REALLY_IWMMXT\n+      && ((bit_count (save_reg_mask)\n+\t   + ARM_NUM_INTS (current_function_pretend_args_size)) % 2) != 0)\n+    {\n+      unsigned int reg;\n+\n+      /* The total number of registers that are going to be pushed\n+\t onto the stack is odd.  We need to ensure that the stack\n+\t is 64-bit aligned before we start to save iWMMXt registers,\n+\t and also before we start to create locals.  (A local variable\n+\t might be a double or long long which we will load/store using\n+\t an iWMMXt instruction).  Therefore we need to push another\n+\t ARM register, so that the stack will be 64-bit aligned.  We\n+\t try to avoid using the arg registers (r0 -r3) as they might be\n+\t used to pass values in a tail call.  */\n+      for (reg = 4; reg <= 12; reg++)\n+\tif ((save_reg_mask & (1 << reg)) == 0)\n+\t  break;\n+\n+      if (reg <= 12)\n+\tsave_reg_mask |= (1 << reg);\n+      else\n+\t{\n+\t  cfun->machine->sibcall_blocked = 1;\n+\t  save_reg_mask |= (1 << 3);\n+\t}\n+    }\n+\n   return save_reg_mask;\n }\n \n@@ -8068,6 +8361,7 @@ arm_output_epilogue (int really_return)\n   int frame_size = arm_get_frame_size ();\n   FILE * f = asm_out_file;\n   rtx eh_ofs = cfun->machine->eh_epilogue_sp_ofs;\n+  unsigned int lrm_count = 0;\n \n   /* If we have already generated the return instruction\n      then it is futile to generate anything else.  */\n@@ -8099,12 +8393,15 @@ arm_output_epilogue (int really_return)\n     abort ();\n   \n   saved_regs_mask = arm_compute_save_reg_mask ();\n-  \n+\n+  if (TARGET_IWMMXT)\n+    lrm_count = bit_count (saved_regs_mask);\n+\n   /* XXX We should adjust floats_offset for any anonymous args, and then\n      re-adjust vfp_offset below to compensate.  */\n \n   /* Compute how far away the floats will be.  */\n-  for (reg = 0; reg <= LAST_ARM_REGNUM; reg ++)\n+  for (reg = 0; reg <= LAST_ARM_REGNUM; reg++)\n     if (saved_regs_mask & (1 << reg))\n       floats_offset += 4;\n   \n@@ -8157,6 +8454,26 @@ arm_output_epilogue (int really_return)\n \t\t\t FP_REGNUM, floats_offset - vfp_offset);\n \t}\n \n+      if (TARGET_IWMMXT)\n+\t{\n+\t  /* The frame pointer is guaranteed to be non-double-word aligned.\n+\t     This is because it is set to (old_stack_pointer - 4) and the\n+\t     old_stack_pointer was double word aligned.  Thus the offset to\n+\t     the iWMMXt registers to be loaded must also be non-double-word\n+\t     sized, so that the resultant address *is* double-word aligned.\n+\t     We can ignore floats_offset since that was already included in\n+\t     the live_regs_mask.  */\n+\t  lrm_count += (lrm_count % 2 ? 2 : 1);\n+\t      \n+\t  for (reg = FIRST_IWMMXT_REGNUM; reg <= LAST_IWMMXT_REGNUM; reg++)\n+\t    if (regs_ever_live[reg] && !call_used_regs[reg])\n+\t      {\n+\t\tasm_fprintf (f, \"\\twldrd\\t%r, [%r, #-%d]\\n\", \n+\t\t\t     reg, FP_REGNUM, lrm_count * 4);\n+\t\tlrm_count += 2; \n+\t      }\n+\t}\n+\n       /* saved_regs_mask should contain the IP, which at the time of stack\n \t frame generation actually contains the old stack pointer.  So a\n \t quick way to unwind the stack is just pop the IP register directly\n@@ -8234,6 +8551,11 @@ arm_output_epilogue (int really_return)\n \t\t\t start_reg, reg - start_reg, SP_REGNUM);\n \t}\n \n+      if (TARGET_IWMMXT)\n+\tfor (reg = FIRST_IWMMXT_REGNUM; reg <= LAST_IWMMXT_REGNUM; reg++)\n+\t  if (regs_ever_live[reg] && !call_used_regs[reg])\n+\t    asm_fprintf (f, \"\\twldrd\\t%r, [%r, #+8]!\\n\", reg, SP_REGNUM);\n+\n       /* If we can, restore the LR into the PC.  */\n       if (ARM_FUNC_TYPE (func_type) == ARM_FT_NORMAL\n \t  && really_return\n@@ -8602,34 +8924,32 @@ arm_compute_initial_elimination_offset (unsigned int from, unsigned int to)\n \n       /* Make sure that we compute which registers will be saved\n \t on the stack using the same algorithm that is used by\n-\t arm_compute_save_reg_mask().  */\n-      reg_mask = arm_compute_save_reg0_reg12_mask ();\n+\t the prologue creation code.  */\n+      reg_mask = arm_compute_save_reg_mask ();\n \n       /* Now count the number of bits set in save_reg_mask.\n-\t For each set bit we need 4 bytes of stack space.  */\n-      while (reg_mask)\n-\t{\n-\t  call_saved_registers += 4;\n-\t  reg_mask = reg_mask & ~ (reg_mask & - reg_mask);\n-\t}\n-\n-      if ((regs_ever_live[LR_REGNUM]\n-\t   /* If optimizing for size, then we save the link register if\n-\t      any other integer register is saved.  This gives a smaller\n-\t      return sequence.  */\n-\t   || (optimize_size && call_saved_registers > 0))\n-\t  /* But if a stack frame is going to be created, the LR will\n-\t     be saved as part of that, so we do not need to allow for\n-\t     it here.  */\n-\t  && ! frame_pointer_needed)\n-\tcall_saved_registers += 4;\n+\t If we have already counted the registers in the stack\n+\t frame, do not count them again.  Non call-saved registers\n+\t might be saved in the call-save area of the stack, if\n+\t doing so will preserve the stack's alignment.  Hence we\n+\t must count them here.  For each set bit we need 4 bytes\n+\t of stack space.  */\n+      if (frame_pointer_needed)\n+\treg_mask &= 0x07ff;\n+      call_saved_registers += 4 * bit_count (reg_mask);\n \n       /* If the hard floating point registers are going to be\n \t used then they must be saved on the stack as well.\n          Each register occupies 12 bytes of stack space.  */\n-      for (reg = FIRST_ARM_FP_REGNUM; reg <= LAST_ARM_FP_REGNUM; reg ++)\n+      for (reg = FIRST_ARM_FP_REGNUM; reg <= LAST_ARM_FP_REGNUM; reg++)\n \tif (regs_ever_live[reg] && ! call_used_regs[reg])\n \t  call_saved_registers += 12;\n+\n+      if (TARGET_REALLY_IWMMXT)\n+\t/* Check for the call-saved iWMMXt registers.  */\n+\tfor (reg = FIRST_IWMMXT_REGNUM; reg <= LAST_IWMMXT_REGNUM; reg++)\n+\t  if (regs_ever_live[reg] && ! call_used_regs [reg])\n+\t    call_saved_registers += 8;\n     }\n \n   /* The stack frame contains 4 registers - the old frame pointer,\n@@ -8771,6 +9091,14 @@ arm_get_frame_size (void)\n \tentry_size += 12;\n     }\n \n+  if (TARGET_REALLY_IWMMXT)\n+    {\n+      /* Check for the call-saved iWMMXt registers.  */\n+      for (regno = FIRST_IWMMXT_REGNUM; regno <= LAST_IWMMXT_REGNUM; regno++)\n+\tif (regs_ever_live [regno] && ! call_used_regs [regno])\n+\t  entry_size += 8;\n+    }\n+\n   if ((entry_size + base_size + current_function_outgoing_args_size) & 7)\n     base_size += 4;\n   if ((entry_size + base_size + current_function_outgoing_args_size) & 7)\n@@ -8942,6 +9270,17 @@ arm_expand_prologue (void)\n       RTX_FRAME_RELATED_P (insn) = 1;\n     }\n \n+  if (TARGET_IWMMXT)\n+    for (reg = FIRST_IWMMXT_REGNUM; reg <= LAST_IWMMXT_REGNUM; reg++)\n+      if (regs_ever_live[reg] && ! call_used_regs [reg])\n+\t{\n+\t  insn = gen_rtx_PRE_DEC (V2SImode, stack_pointer_rtx);\n+\t  insn = gen_rtx_MEM (V2SImode, insn);\n+\t  insn = emit_insn (gen_rtx_SET (VOIDmode, insn,\n+\t\t\t\t\t gen_rtx_REG (V2SImode, reg)));\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t}\n+\n   if (! IS_VOLATILE (func_type))\n     {\n       /* Save any floating point call-saved registers used by this\n@@ -9248,7 +9587,6 @@ arm_print_operand (FILE *stream, rtx x, int code)\n \tfputs (thumb_condition_code (x, 1), stream);\n       return;\n \n-\n     /* Cirrus registers can be accessed in a variety of ways:\n          single floating point (f)\n \t double floating point (d)\n@@ -9285,6 +9623,37 @@ arm_print_operand (FILE *stream, rtx x, int code)\n \treturn;\n       }\n \n+    case 'U':\n+      if (GET_CODE (x) != REG\n+\t  || REGNO (x) < FIRST_IWMMXT_GR_REGNUM\n+\t  || REGNO (x) > LAST_IWMMXT_GR_REGNUM)\n+\t/* Bad value for wCG register number.  */\n+\tabort ();\n+      else\n+\tfprintf (stream, \"%d\", REGNO (x) - FIRST_IWMMXT_GR_REGNUM);\n+      return;\n+\n+      /* Print an iWMMXt control register name.  */\n+    case 'w':\n+      if (GET_CODE (x) != CONST_INT\n+\t  || INTVAL (x) < 0\n+\t  || INTVAL (x) >= 16)\n+\t/* Bad value for wC register number.  */\n+\tabort ();\n+      else\n+\t{\n+\t  static const char * wc_reg_names [16] =\n+\t    {\n+\t      \"wCID\",  \"wCon\",  \"wCSSF\", \"wCASF\",\n+\t      \"wC4\",   \"wC5\",   \"wC6\",   \"wC7\",\n+\t      \"wCGR0\", \"wCGR1\", \"wCGR2\", \"wCGR3\",\n+\t      \"wC12\",  \"wC13\",  \"wC14\",  \"wC15\"\n+\t    };\n+\t  \n+\t  fprintf (stream, wc_reg_names [INTVAL (x)]);\n+\t}\n+      return;\n+\n     default:\n       if (x == 0)\n \tabort ();\n@@ -9337,6 +9706,36 @@ arm_assemble_integer (rtx x, unsigned int size, int aligned_p)\n       return true;\n     }\n \n+  if (VECTOR_MODE_SUPPORTED_P (GET_MODE (x)))\n+    {\n+      int i, units;\n+\n+      if (GET_CODE (x) != CONST_VECTOR)\n+\tabort ();\n+\n+      units = CONST_VECTOR_NUNITS (x);\n+\n+      switch (GET_MODE (x))\n+\t{\n+\tcase V2SImode: size = 4; break;\n+\tcase V4HImode: size = 2; break;\n+\tcase V8QImode: size = 1; break;\n+\tdefault:\n+\t  abort ();\n+\t}\n+\n+      for (i = 0; i < units; i++)\n+\t{\n+\t  rtx elt;\n+\n+\t  elt = CONST_VECTOR_ELT (x, i);\n+\t  assemble_integer\n+\t    (elt, size, i == 0 ? BIGGEST_ALIGNMENT : size * BITS_PER_UNIT, 1);\n+\t}\n+\n+      return true;\n+    }\n+\n   return default_assemble_integer (x, size, aligned_p);\n }\n #endif\n@@ -9869,6 +10268,12 @@ arm_hard_regno_mode_ok (unsigned int regno, enum machine_mode mode)\n        get sign extended to 64bits-- aldyh.  */\n     return (GET_MODE_CLASS (mode) == MODE_FLOAT) || (mode == DImode);\n \n+  if (IS_IWMMXT_GR_REGNUM (regno))\n+    return mode == SImode;\n+\n+  if (IS_IWMMXT_REGNUM (regno))\n+    return VALID_IWMMXT_REG_MODE (mode);\n+\n   if (regno <= LAST_ARM_REGNUM)\n     /* We allow any value to be stored in the general regisetrs.  */\n     return 1;\n@@ -9910,6 +10315,9 @@ arm_regno_class (int regno)\n   if (IS_CIRRUS_REGNUM (regno))\n     return CIRRUS_REGS;\n \n+  if (IS_IWMMXT_REGNUM (regno))\n+    return IWMMXT_REGS;\n+\n   return FPA_REGS;\n }\n \n@@ -9996,6 +10404,796 @@ arm_debugger_arg_offset (int value, rtx addr)\n   return value;\n }\n \f\n+#define def_mbuiltin(MASK, NAME, TYPE, CODE)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if ((MASK) & insn_flags)\t\t\t\t\t\t\\\n+        builtin_function ((NAME), (TYPE), (CODE), BUILT_IN_MD, NULL, NULL_TREE);\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+struct builtin_description\n+{\n+  const unsigned int       mask;\n+  const enum insn_code     icode;\n+  const char * const       name;\n+  const enum arm_builtins  code;\n+  const enum rtx_code      comparison;\n+  const unsigned int       flag;\n+};\n+\n+static const struct builtin_description bdesc_2arg[] =\n+{\n+#define IWMMXT_BUILTIN(code, string, builtin) \\\n+  { FL_IWMMXT, CODE_FOR_##code, \"__builtin_arm_\" string, \\\n+    ARM_BUILTIN_##builtin, 0, 0 },\n+\n+  IWMMXT_BUILTIN (addv8qi3, \"waddb\", WADDB)\n+  IWMMXT_BUILTIN (addv4hi3, \"waddh\", WADDH)\n+  IWMMXT_BUILTIN (addv2si3, \"waddw\", WADDW)\n+  IWMMXT_BUILTIN (subv8qi3, \"wsubb\", WSUBB)\n+  IWMMXT_BUILTIN (subv4hi3, \"wsubh\", WSUBH)\n+  IWMMXT_BUILTIN (subv2si3, \"wsubw\", WSUBW)\n+  IWMMXT_BUILTIN (ssaddv8qi3, \"waddbss\", WADDSSB)\n+  IWMMXT_BUILTIN (ssaddv4hi3, \"waddhss\", WADDSSH)\n+  IWMMXT_BUILTIN (ssaddv2si3, \"waddwss\", WADDSSW)\n+  IWMMXT_BUILTIN (sssubv8qi3, \"wsubbss\", WSUBSSB)\n+  IWMMXT_BUILTIN (sssubv4hi3, \"wsubhss\", WSUBSSH)\n+  IWMMXT_BUILTIN (sssubv2si3, \"wsubwss\", WSUBSSW)\n+  IWMMXT_BUILTIN (usaddv8qi3, \"waddbus\", WADDUSB)\n+  IWMMXT_BUILTIN (usaddv4hi3, \"waddhus\", WADDUSH)\n+  IWMMXT_BUILTIN (usaddv2si3, \"waddwus\", WADDUSW)\n+  IWMMXT_BUILTIN (ussubv8qi3, \"wsubbus\", WSUBUSB)\n+  IWMMXT_BUILTIN (ussubv4hi3, \"wsubhus\", WSUBUSH)\n+  IWMMXT_BUILTIN (ussubv2si3, \"wsubwus\", WSUBUSW)\n+  IWMMXT_BUILTIN (mulv4hi3, \"wmulul\", WMULUL)\n+  IWMMXT_BUILTIN (smulv4hi3_highpart, \"wmulsh\", WMULSH)\n+  IWMMXT_BUILTIN (umulv4hi3_highpart, \"wmuluh\", WMULUH)\n+  IWMMXT_BUILTIN (eqv8qi3, \"wcmpeqb\", WCMPEQB)\n+  IWMMXT_BUILTIN (eqv4hi3, \"wcmpeqh\", WCMPEQH)\n+  IWMMXT_BUILTIN (eqv2si3, \"wcmpeqw\", WCMPEQW)\n+  IWMMXT_BUILTIN (gtuv8qi3, \"wcmpgtub\", WCMPGTUB)\n+  IWMMXT_BUILTIN (gtuv4hi3, \"wcmpgtuh\", WCMPGTUH)\n+  IWMMXT_BUILTIN (gtuv2si3, \"wcmpgtuw\", WCMPGTUW)\n+  IWMMXT_BUILTIN (gtv8qi3, \"wcmpgtsb\", WCMPGTSB)\n+  IWMMXT_BUILTIN (gtv4hi3, \"wcmpgtsh\", WCMPGTSH)\n+  IWMMXT_BUILTIN (gtv2si3, \"wcmpgtsw\", WCMPGTSW)\n+  IWMMXT_BUILTIN (umaxv8qi3, \"wmaxub\", WMAXUB)\n+  IWMMXT_BUILTIN (smaxv8qi3, \"wmaxsb\", WMAXSB)\n+  IWMMXT_BUILTIN (umaxv4hi3, \"wmaxuh\", WMAXUH)\n+  IWMMXT_BUILTIN (smaxv4hi3, \"wmaxsh\", WMAXSH)\n+  IWMMXT_BUILTIN (umaxv2si3, \"wmaxuw\", WMAXUW)\n+  IWMMXT_BUILTIN (smaxv2si3, \"wmaxsw\", WMAXSW)\n+  IWMMXT_BUILTIN (uminv8qi3, \"wminub\", WMINUB)\n+  IWMMXT_BUILTIN (sminv8qi3, \"wminsb\", WMINSB)\n+  IWMMXT_BUILTIN (uminv4hi3, \"wminuh\", WMINUH)\n+  IWMMXT_BUILTIN (sminv4hi3, \"wminsh\", WMINSH)\n+  IWMMXT_BUILTIN (uminv2si3, \"wminuw\", WMINUW)\n+  IWMMXT_BUILTIN (sminv2si3, \"wminsw\", WMINSW)\n+  IWMMXT_BUILTIN (iwmmxt_anddi3, \"wand\", WAND)\n+  IWMMXT_BUILTIN (iwmmxt_nanddi3, \"wandn\", WANDN)\n+  IWMMXT_BUILTIN (iwmmxt_iordi3, \"wor\", WOR)\n+  IWMMXT_BUILTIN (iwmmxt_xordi3, \"wxor\", WXOR)\n+  IWMMXT_BUILTIN (iwmmxt_uavgv8qi3, \"wavg2b\", WAVG2B)\n+  IWMMXT_BUILTIN (iwmmxt_uavgv4hi3, \"wavg2h\", WAVG2H)\n+  IWMMXT_BUILTIN (iwmmxt_uavgrndv8qi3, \"wavg2br\", WAVG2BR)\n+  IWMMXT_BUILTIN (iwmmxt_uavgrndv4hi3, \"wavg2hr\", WAVG2HR)\n+  IWMMXT_BUILTIN (iwmmxt_wunpckilb, \"wunpckilb\", WUNPCKILB)\n+  IWMMXT_BUILTIN (iwmmxt_wunpckilh, \"wunpckilh\", WUNPCKILH)\n+  IWMMXT_BUILTIN (iwmmxt_wunpckilw, \"wunpckilw\", WUNPCKILW)\n+  IWMMXT_BUILTIN (iwmmxt_wunpckihb, \"wunpckihb\", WUNPCKIHB)\n+  IWMMXT_BUILTIN (iwmmxt_wunpckihh, \"wunpckihh\", WUNPCKIHH)\n+  IWMMXT_BUILTIN (iwmmxt_wunpckihw, \"wunpckihw\", WUNPCKIHW)\n+  IWMMXT_BUILTIN (iwmmxt_wmadds, \"wmadds\", WMADDS)\n+  IWMMXT_BUILTIN (iwmmxt_wmaddu, \"wmaddu\", WMADDU)\n+\n+#define IWMMXT_BUILTIN2(code, builtin) \\\n+  { FL_IWMMXT, CODE_FOR_##code, NULL, ARM_BUILTIN_##builtin, 0, 0 },\n+  \n+  IWMMXT_BUILTIN2 (iwmmxt_wpackhss, WPACKHSS)\n+  IWMMXT_BUILTIN2 (iwmmxt_wpackwss, WPACKWSS)\n+  IWMMXT_BUILTIN2 (iwmmxt_wpackdss, WPACKDSS)\n+  IWMMXT_BUILTIN2 (iwmmxt_wpackhus, WPACKHUS)\n+  IWMMXT_BUILTIN2 (iwmmxt_wpackwus, WPACKWUS)\n+  IWMMXT_BUILTIN2 (iwmmxt_wpackdus, WPACKDUS)\n+  IWMMXT_BUILTIN2 (ashlv4hi3_di,    WSLLH)\n+  IWMMXT_BUILTIN2 (ashlv4hi3,       WSLLHI)\n+  IWMMXT_BUILTIN2 (ashlv2si3_di,    WSLLW)\n+  IWMMXT_BUILTIN2 (ashlv2si3,       WSLLWI)\n+  IWMMXT_BUILTIN2 (ashldi3_di,      WSLLD)\n+  IWMMXT_BUILTIN2 (ashldi3_iwmmxt,  WSLLDI)\n+  IWMMXT_BUILTIN2 (lshrv4hi3_di,    WSRLH)\n+  IWMMXT_BUILTIN2 (lshrv4hi3,       WSRLHI)\n+  IWMMXT_BUILTIN2 (lshrv2si3_di,    WSRLW)\n+  IWMMXT_BUILTIN2 (lshrv2si3,       WSRLWI)\n+  IWMMXT_BUILTIN2 (lshrdi3_di,      WSRLD)\n+  IWMMXT_BUILTIN2 (lshrdi3,         WSRLDI)\n+  IWMMXT_BUILTIN2 (ashrv4hi3_di,    WSRAH)\n+  IWMMXT_BUILTIN2 (ashrv4hi3,       WSRAHI)\n+  IWMMXT_BUILTIN2 (ashrv2si3_di,    WSRAW)\n+  IWMMXT_BUILTIN2 (ashrv2si3,       WSRAWI)\n+  IWMMXT_BUILTIN2 (ashrdi3_di,      WSRAD)\n+  IWMMXT_BUILTIN2 (ashrdi3,         WSRADI)\n+  IWMMXT_BUILTIN2 (rorv4hi3_di,     WRORH)\n+  IWMMXT_BUILTIN2 (rorv4hi3,        WRORHI)\n+  IWMMXT_BUILTIN2 (rorv2si3_di,     WRORW)\n+  IWMMXT_BUILTIN2 (rorv2si3,        WRORWI)\n+  IWMMXT_BUILTIN2 (rordi3_di,       WRORD)\n+  IWMMXT_BUILTIN2 (rordi3,          WRORDI)\n+  IWMMXT_BUILTIN2 (iwmmxt_wmacuz,   WMACUZ)\n+  IWMMXT_BUILTIN2 (iwmmxt_wmacsz,   WMACSZ)\n+};\n+\n+static const struct builtin_description bdesc_1arg[] =\n+{\n+  IWMMXT_BUILTIN (iwmmxt_tmovmskb, \"tmovmskb\", TMOVMSKB)\n+  IWMMXT_BUILTIN (iwmmxt_tmovmskh, \"tmovmskh\", TMOVMSKH)\n+  IWMMXT_BUILTIN (iwmmxt_tmovmskw, \"tmovmskw\", TMOVMSKW)\n+  IWMMXT_BUILTIN (iwmmxt_waccb, \"waccb\", WACCB)\n+  IWMMXT_BUILTIN (iwmmxt_wacch, \"wacch\", WACCH)\n+  IWMMXT_BUILTIN (iwmmxt_waccw, \"waccw\", WACCW)\n+  IWMMXT_BUILTIN (iwmmxt_wunpckehub, \"wunpckehub\", WUNPCKEHUB)\n+  IWMMXT_BUILTIN (iwmmxt_wunpckehuh, \"wunpckehuh\", WUNPCKEHUH)\n+  IWMMXT_BUILTIN (iwmmxt_wunpckehuw, \"wunpckehuw\", WUNPCKEHUW)\n+  IWMMXT_BUILTIN (iwmmxt_wunpckehsb, \"wunpckehsb\", WUNPCKEHSB)\n+  IWMMXT_BUILTIN (iwmmxt_wunpckehsh, \"wunpckehsh\", WUNPCKEHSH)\n+  IWMMXT_BUILTIN (iwmmxt_wunpckehsw, \"wunpckehsw\", WUNPCKEHSW)\n+  IWMMXT_BUILTIN (iwmmxt_wunpckelub, \"wunpckelub\", WUNPCKELUB)\n+  IWMMXT_BUILTIN (iwmmxt_wunpckeluh, \"wunpckeluh\", WUNPCKELUH)\n+  IWMMXT_BUILTIN (iwmmxt_wunpckeluw, \"wunpckeluw\", WUNPCKELUW)\n+  IWMMXT_BUILTIN (iwmmxt_wunpckelsb, \"wunpckelsb\", WUNPCKELSB)\n+  IWMMXT_BUILTIN (iwmmxt_wunpckelsh, \"wunpckelsh\", WUNPCKELSH)\n+  IWMMXT_BUILTIN (iwmmxt_wunpckelsw, \"wunpckelsw\", WUNPCKELSW)\n+};\n+\n+/* Set up all the iWMMXt builtins.  This is\n+   not called if TARGET_IWMMXT is zero.  */\n+\n+static void\n+arm_init_iwmmxt_builtins (void)\n+{\n+  const struct builtin_description * d;\n+  size_t i;\n+  tree endlink = void_list_node;\n+\n+  tree int_ftype_int\n+    = build_function_type (integer_type_node,\n+\t\t\t   tree_cons (NULL_TREE, integer_type_node, endlink));\n+  tree v8qi_ftype_v8qi_v8qi_int\n+    = build_function_type (V8QI_type_node,\n+\t\t\t   tree_cons (NULL_TREE, V8QI_type_node,\n+\t\t\t\t      tree_cons (NULL_TREE, V8QI_type_node,\n+\t\t\t\t\t\t tree_cons (NULL_TREE,\n+\t\t\t\t\t\t\t    integer_type_node,\n+\t\t\t\t\t\t\t    endlink))));\n+  tree v4hi_ftype_v4hi_int\n+    = build_function_type (V4HI_type_node,\n+\t\t\t   tree_cons (NULL_TREE, V4HI_type_node,\n+\t\t\t\t      tree_cons (NULL_TREE, integer_type_node,\n+\t\t\t\t\t\t endlink)));\n+  tree v2si_ftype_v2si_int\n+    = build_function_type (V2SI_type_node,\n+\t\t\t   tree_cons (NULL_TREE, V2SI_type_node,\n+\t\t\t\t      tree_cons (NULL_TREE, integer_type_node,\n+\t\t\t\t\t\t endlink)));\n+  tree v2si_ftype_di_di\n+    = build_function_type (V2SI_type_node,\n+\t\t\t   tree_cons (NULL_TREE, long_long_integer_type_node,\n+\t\t\t\t      tree_cons (NULL_TREE, long_long_integer_type_node,\n+\t\t\t\t\t\t endlink)));\n+  tree di_ftype_di_int\n+    = build_function_type (long_long_integer_type_node,\n+\t\t\t   tree_cons (NULL_TREE, long_long_integer_type_node,\n+\t\t\t\t      tree_cons (NULL_TREE, integer_type_node,\n+\t\t\t\t\t\t endlink)));\n+  tree di_ftype_di_int_int\n+    = build_function_type (long_long_integer_type_node,\n+\t\t\t   tree_cons (NULL_TREE, long_long_integer_type_node,\n+\t\t\t\t      tree_cons (NULL_TREE, integer_type_node,\n+\t\t\t\t\t\t tree_cons (NULL_TREE,\n+\t\t\t\t\t\t\t    integer_type_node,\n+\t\t\t\t\t\t\t    endlink))));\n+  tree int_ftype_v8qi\n+    = build_function_type (integer_type_node,\n+\t\t\t   tree_cons (NULL_TREE, V8QI_type_node,\n+\t\t\t\t      endlink));\n+  tree int_ftype_v4hi\n+    = build_function_type (integer_type_node,\n+\t\t\t   tree_cons (NULL_TREE, V4HI_type_node,\n+\t\t\t\t      endlink));\n+  tree int_ftype_v2si\n+    = build_function_type (integer_type_node,\n+\t\t\t   tree_cons (NULL_TREE, V2SI_type_node,\n+\t\t\t\t      endlink));\n+  tree int_ftype_v8qi_int\n+    = build_function_type (integer_type_node,\n+\t\t\t   tree_cons (NULL_TREE, V8QI_type_node,\n+\t\t\t\t      tree_cons (NULL_TREE, integer_type_node,\n+\t\t\t\t\t\t endlink)));\n+  tree int_ftype_v4hi_int\n+    = build_function_type (integer_type_node,\n+\t\t\t   tree_cons (NULL_TREE, V4HI_type_node,\n+\t\t\t\t      tree_cons (NULL_TREE, integer_type_node,\n+\t\t\t\t\t\t endlink)));\n+  tree int_ftype_v2si_int\n+    = build_function_type (integer_type_node,\n+\t\t\t   tree_cons (NULL_TREE, V2SI_type_node,\n+\t\t\t\t      tree_cons (NULL_TREE, integer_type_node,\n+\t\t\t\t\t\t endlink)));\n+  tree v8qi_ftype_v8qi_int_int\n+    = build_function_type (V8QI_type_node,\n+\t\t\t   tree_cons (NULL_TREE, V8QI_type_node,\n+\t\t\t\t      tree_cons (NULL_TREE, integer_type_node,\n+\t\t\t\t\t\t tree_cons (NULL_TREE,\n+\t\t\t\t\t\t\t    integer_type_node,\n+\t\t\t\t\t\t\t    endlink))));\n+  tree v4hi_ftype_v4hi_int_int\n+    = build_function_type (V4HI_type_node,\n+\t\t\t   tree_cons (NULL_TREE, V4HI_type_node,\n+\t\t\t\t      tree_cons (NULL_TREE, integer_type_node,\n+\t\t\t\t\t\t tree_cons (NULL_TREE,\n+\t\t\t\t\t\t\t    integer_type_node,\n+\t\t\t\t\t\t\t    endlink))));\n+  tree v2si_ftype_v2si_int_int\n+    = build_function_type (V2SI_type_node,\n+\t\t\t   tree_cons (NULL_TREE, V2SI_type_node,\n+\t\t\t\t      tree_cons (NULL_TREE, integer_type_node,\n+\t\t\t\t\t\t tree_cons (NULL_TREE,\n+\t\t\t\t\t\t\t    integer_type_node,\n+\t\t\t\t\t\t\t    endlink))));\n+  /* Miscellaneous.  */\n+  tree v8qi_ftype_v4hi_v4hi\n+    = build_function_type (V8QI_type_node,\n+\t\t\t   tree_cons (NULL_TREE, V4HI_type_node,\n+\t\t\t\t      tree_cons (NULL_TREE, V4HI_type_node,\n+\t\t\t\t\t\t endlink)));\n+  tree v4hi_ftype_v2si_v2si\n+    = build_function_type (V4HI_type_node,\n+\t\t\t   tree_cons (NULL_TREE, V2SI_type_node,\n+\t\t\t\t      tree_cons (NULL_TREE, V2SI_type_node,\n+\t\t\t\t\t\t endlink)));\n+  tree v2si_ftype_v4hi_v4hi\n+    = build_function_type (V2SI_type_node,\n+\t\t\t   tree_cons (NULL_TREE, V4HI_type_node,\n+\t\t\t\t      tree_cons (NULL_TREE, V4HI_type_node,\n+\t\t\t\t\t\t endlink)));\n+  tree v2si_ftype_v8qi_v8qi\n+    = build_function_type (V2SI_type_node,\n+\t\t\t   tree_cons (NULL_TREE, V8QI_type_node,\n+\t\t\t\t      tree_cons (NULL_TREE, V8QI_type_node,\n+\t\t\t\t\t\t endlink)));\n+  tree v4hi_ftype_v4hi_di\n+    = build_function_type (V4HI_type_node,\n+\t\t\t   tree_cons (NULL_TREE, V4HI_type_node,\n+\t\t\t\t      tree_cons (NULL_TREE,\n+\t\t\t\t\t\t long_long_integer_type_node,\n+\t\t\t\t\t\t endlink)));\n+  tree v2si_ftype_v2si_di\n+    = build_function_type (V2SI_type_node,\n+\t\t\t   tree_cons (NULL_TREE, V2SI_type_node,\n+\t\t\t\t      tree_cons (NULL_TREE,\n+\t\t\t\t\t\t long_long_integer_type_node,\n+\t\t\t\t\t\t endlink)));\n+  tree void_ftype_int_int\n+    = build_function_type (void_type_node,\n+\t\t\t   tree_cons (NULL_TREE, integer_type_node,\n+\t\t\t\t      tree_cons (NULL_TREE, integer_type_node,\n+\t\t\t\t\t\t endlink)));\n+  tree di_ftype_void\n+    = build_function_type (long_long_unsigned_type_node, endlink);\n+  tree di_ftype_v8qi\n+    = build_function_type (long_long_integer_type_node,\n+\t\t\t   tree_cons (NULL_TREE, V8QI_type_node,\n+\t\t\t\t      endlink));\n+  tree di_ftype_v4hi\n+    = build_function_type (long_long_integer_type_node,\n+\t\t\t   tree_cons (NULL_TREE, V4HI_type_node,\n+\t\t\t\t      endlink));\n+  tree di_ftype_v2si\n+    = build_function_type (long_long_integer_type_node,\n+\t\t\t   tree_cons (NULL_TREE, V2SI_type_node,\n+\t\t\t\t      endlink));\n+  tree v2si_ftype_v4hi\n+    = build_function_type (V2SI_type_node,\n+\t\t\t   tree_cons (NULL_TREE, V4HI_type_node,\n+\t\t\t\t      endlink));\n+  tree v4hi_ftype_v8qi\n+    = build_function_type (V4HI_type_node,\n+\t\t\t   tree_cons (NULL_TREE, V8QI_type_node,\n+\t\t\t\t      endlink));\n+\n+  tree di_ftype_di_v4hi_v4hi\n+    = build_function_type (long_long_unsigned_type_node,\n+\t\t\t   tree_cons (NULL_TREE,\n+\t\t\t\t      long_long_unsigned_type_node,\n+\t\t\t\t      tree_cons (NULL_TREE, V4HI_type_node,\n+\t\t\t\t\t\t tree_cons (NULL_TREE,\n+\t\t\t\t\t\t\t    V4HI_type_node,\n+\t\t\t\t\t\t\t    endlink))));\n+\n+  tree di_ftype_v4hi_v4hi\n+    = build_function_type (long_long_unsigned_type_node,\n+\t\t\t   tree_cons (NULL_TREE, V4HI_type_node,\n+\t\t\t\t      tree_cons (NULL_TREE, V4HI_type_node,\n+\t\t\t\t\t\t endlink)));\n+\n+  /* Normal vector binops.  */\n+  tree v8qi_ftype_v8qi_v8qi\n+    = build_function_type (V8QI_type_node,\n+\t\t\t   tree_cons (NULL_TREE, V8QI_type_node,\n+\t\t\t\t      tree_cons (NULL_TREE, V8QI_type_node,\n+\t\t\t\t\t\t endlink)));\n+  tree v4hi_ftype_v4hi_v4hi\n+    = build_function_type (V4HI_type_node,\n+\t\t\t   tree_cons (NULL_TREE, V4HI_type_node,\n+\t\t\t\t      tree_cons (NULL_TREE, V4HI_type_node,\n+\t\t\t\t\t\t endlink)));\n+  tree v2si_ftype_v2si_v2si\n+    = build_function_type (V2SI_type_node,\n+\t\t\t   tree_cons (NULL_TREE, V2SI_type_node,\n+\t\t\t\t      tree_cons (NULL_TREE, V2SI_type_node,\n+\t\t\t\t\t\t endlink)));\n+  tree di_ftype_di_di\n+    = build_function_type (long_long_unsigned_type_node,\n+\t\t\t   tree_cons (NULL_TREE, long_long_unsigned_type_node,\n+\t\t\t\t      tree_cons (NULL_TREE,\n+\t\t\t\t\t\t long_long_unsigned_type_node,\n+\t\t\t\t\t\t endlink)));\n+\n+  /* Add all builtins that are more or less simple operations on two\n+     operands.  */\n+  for (i = 0, d = bdesc_2arg; i < sizeof (bdesc_2arg) / sizeof *d; i++, d++)\n+    {\n+      /* Use one of the operands; the target can have a different mode for\n+\t mask-generating compares.  */\n+      enum machine_mode mode;\n+      tree type;\n+\n+      if (d->name == 0)\n+\tcontinue;\n+\n+      mode = insn_data[d->icode].operand[1].mode;\n+\n+      switch (mode)\n+\t{\n+\tcase V8QImode:\n+\t  type = v8qi_ftype_v8qi_v8qi;\n+\t  break;\n+\tcase V4HImode:\n+\t  type = v4hi_ftype_v4hi_v4hi;\n+\t  break;\n+\tcase V2SImode:\n+\t  type = v2si_ftype_v2si_v2si;\n+\t  break;\n+\tcase DImode:\n+\t  type = di_ftype_di_di;\n+\t  break;\n+\n+\tdefault:\n+\t  abort ();\n+\t}\n+\n+      def_mbuiltin (d->mask, d->name, type, d->code);\n+    }\n+\n+  /* Add the remaining MMX insns with somewhat more complicated types.  */\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_wzero\", di_ftype_void, ARM_BUILTIN_WZERO);\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_setwcx\", void_ftype_int_int, ARM_BUILTIN_SETWCX);\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_getwcx\", int_ftype_int, ARM_BUILTIN_GETWCX);\n+\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_wsllh\", v4hi_ftype_v4hi_di, ARM_BUILTIN_WSLLH);\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_wsllw\", v2si_ftype_v2si_di, ARM_BUILTIN_WSLLW);\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_wslld\", di_ftype_di_di, ARM_BUILTIN_WSLLD);\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_wsllhi\", v4hi_ftype_v4hi_int, ARM_BUILTIN_WSLLHI);\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_wsllwi\", v2si_ftype_v2si_int, ARM_BUILTIN_WSLLWI);\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_wslldi\", di_ftype_di_int, ARM_BUILTIN_WSLLDI);\n+\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_wsrlh\", v4hi_ftype_v4hi_di, ARM_BUILTIN_WSRLH);\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_wsrlw\", v2si_ftype_v2si_di, ARM_BUILTIN_WSRLW);\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_wsrld\", di_ftype_di_di, ARM_BUILTIN_WSRLD);\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_wsrlhi\", v4hi_ftype_v4hi_int, ARM_BUILTIN_WSRLHI);\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_wsrlwi\", v2si_ftype_v2si_int, ARM_BUILTIN_WSRLWI);\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_wsrldi\", di_ftype_di_int, ARM_BUILTIN_WSRLDI);\n+\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_wsrah\", v4hi_ftype_v4hi_di, ARM_BUILTIN_WSRAH);\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_wsraw\", v2si_ftype_v2si_di, ARM_BUILTIN_WSRAW);\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_wsrad\", di_ftype_di_di, ARM_BUILTIN_WSRAD);\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_wsrahi\", v4hi_ftype_v4hi_int, ARM_BUILTIN_WSRAHI);\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_wsrawi\", v2si_ftype_v2si_int, ARM_BUILTIN_WSRAWI);\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_wsradi\", di_ftype_di_int, ARM_BUILTIN_WSRADI);\n+\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_wrorh\", v4hi_ftype_v4hi_di, ARM_BUILTIN_WRORH);\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_wrorw\", v2si_ftype_v2si_di, ARM_BUILTIN_WRORW);\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_wrord\", di_ftype_di_di, ARM_BUILTIN_WRORD);\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_wrorhi\", v4hi_ftype_v4hi_int, ARM_BUILTIN_WRORHI);\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_wrorwi\", v2si_ftype_v2si_int, ARM_BUILTIN_WRORWI);\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_wrordi\", di_ftype_di_int, ARM_BUILTIN_WRORDI);\n+\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_wshufh\", v4hi_ftype_v4hi_int, ARM_BUILTIN_WSHUFH);\n+\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_wsadb\", v2si_ftype_v8qi_v8qi, ARM_BUILTIN_WSADB);\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_wsadh\", v2si_ftype_v4hi_v4hi, ARM_BUILTIN_WSADH);\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_wsadbz\", v2si_ftype_v8qi_v8qi, ARM_BUILTIN_WSADBZ);\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_wsadhz\", v2si_ftype_v4hi_v4hi, ARM_BUILTIN_WSADHZ);\n+\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_textrmsb\", int_ftype_v8qi_int, ARM_BUILTIN_TEXTRMSB);\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_textrmsh\", int_ftype_v4hi_int, ARM_BUILTIN_TEXTRMSH);\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_textrmsw\", int_ftype_v2si_int, ARM_BUILTIN_TEXTRMSW);\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_textrmub\", int_ftype_v8qi_int, ARM_BUILTIN_TEXTRMUB);\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_textrmuh\", int_ftype_v4hi_int, ARM_BUILTIN_TEXTRMUH);\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_textrmuw\", int_ftype_v2si_int, ARM_BUILTIN_TEXTRMUW);\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_tinsrb\", v8qi_ftype_v8qi_int_int, ARM_BUILTIN_TINSRB);\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_tinsrh\", v4hi_ftype_v4hi_int_int, ARM_BUILTIN_TINSRH);\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_tinsrw\", v2si_ftype_v2si_int_int, ARM_BUILTIN_TINSRW);\n+\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_waccb\", di_ftype_v8qi, ARM_BUILTIN_WACCB);\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_wacch\", di_ftype_v4hi, ARM_BUILTIN_WACCH);\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_waccw\", di_ftype_v2si, ARM_BUILTIN_WACCW);\n+\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_tmovmskb\", int_ftype_v8qi, ARM_BUILTIN_TMOVMSKB);\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_tmovmskh\", int_ftype_v4hi, ARM_BUILTIN_TMOVMSKH);\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_tmovmskw\", int_ftype_v2si, ARM_BUILTIN_TMOVMSKW);\n+\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_wpackhss\", v8qi_ftype_v4hi_v4hi, ARM_BUILTIN_WPACKHSS);\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_wpackhus\", v8qi_ftype_v4hi_v4hi, ARM_BUILTIN_WPACKHUS);\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_wpackwus\", v4hi_ftype_v2si_v2si, ARM_BUILTIN_WPACKWUS);\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_wpackwss\", v4hi_ftype_v2si_v2si, ARM_BUILTIN_WPACKWSS);\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_wpackdus\", v2si_ftype_di_di, ARM_BUILTIN_WPACKDUS);\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_wpackdss\", v2si_ftype_di_di, ARM_BUILTIN_WPACKDSS);\n+\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_wunpckehub\", v4hi_ftype_v8qi, ARM_BUILTIN_WUNPCKEHUB);\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_wunpckehuh\", v2si_ftype_v4hi, ARM_BUILTIN_WUNPCKEHUH);\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_wunpckehuw\", di_ftype_v2si, ARM_BUILTIN_WUNPCKEHUW);\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_wunpckehsb\", v4hi_ftype_v8qi, ARM_BUILTIN_WUNPCKEHSB);\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_wunpckehsh\", v2si_ftype_v4hi, ARM_BUILTIN_WUNPCKEHSH);\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_wunpckehsw\", di_ftype_v2si, ARM_BUILTIN_WUNPCKEHSW);\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_wunpckelub\", v4hi_ftype_v8qi, ARM_BUILTIN_WUNPCKELUB);\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_wunpckeluh\", v2si_ftype_v4hi, ARM_BUILTIN_WUNPCKELUH);\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_wunpckeluw\", di_ftype_v2si, ARM_BUILTIN_WUNPCKELUW);\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_wunpckelsb\", v4hi_ftype_v8qi, ARM_BUILTIN_WUNPCKELSB);\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_wunpckelsh\", v2si_ftype_v4hi, ARM_BUILTIN_WUNPCKELSH);\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_wunpckelsw\", di_ftype_v2si, ARM_BUILTIN_WUNPCKELSW);\n+\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_wmacs\", di_ftype_di_v4hi_v4hi, ARM_BUILTIN_WMACS);\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_wmacsz\", di_ftype_v4hi_v4hi, ARM_BUILTIN_WMACSZ);\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_wmacu\", di_ftype_di_v4hi_v4hi, ARM_BUILTIN_WMACU);\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_wmacuz\", di_ftype_v4hi_v4hi, ARM_BUILTIN_WMACUZ);\n+\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_walign\", v8qi_ftype_v8qi_v8qi_int, ARM_BUILTIN_WALIGN);\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_tmia\", di_ftype_di_int_int, ARM_BUILTIN_TMIA);\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_tmiaph\", di_ftype_di_int_int, ARM_BUILTIN_TMIAPH);\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_tmiabb\", di_ftype_di_int_int, ARM_BUILTIN_TMIABB);\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_tmiabt\", di_ftype_di_int_int, ARM_BUILTIN_TMIABT);\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_tmiatb\", di_ftype_di_int_int, ARM_BUILTIN_TMIATB);\n+  def_mbuiltin (FL_IWMMXT, \"__builtin_arm_tmiatt\", di_ftype_di_int_int, ARM_BUILTIN_TMIATT);\n+}\n+\n+static void\n+arm_init_builtins (void)\n+{\n+  if (TARGET_REALLY_IWMMXT)\n+    arm_init_iwmmxt_builtins ();\n+}\n+\n+/* Errors in the source file can cause expand_expr to return const0_rtx\n+   where we expect a vector.  To avoid crashing, use one of the vector\n+   clear instructions.  */\n+\n+static rtx\n+safe_vector_operand (rtx x, enum machine_mode mode)\n+{\n+  if (x != const0_rtx)\n+    return x;\n+  x = gen_reg_rtx (mode);\n+\n+  emit_insn (gen_iwmmxt_clrdi (mode == DImode ? x\n+\t\t\t       : gen_rtx_SUBREG (DImode, x, 0)));\n+  return x;\n+}\n+\n+/* Subroutine of arm_expand_builtin to take care of binop insns.  */\n+\n+static rtx\n+arm_expand_binop_builtin (enum insn_code icode,\n+\t\t\t  tree arglist, rtx target)\n+{\n+  rtx pat;\n+  tree arg0 = TREE_VALUE (arglist);\n+  tree arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n+  rtx op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n+  rtx op1 = expand_expr (arg1, NULL_RTX, VOIDmode, 0);\n+  enum machine_mode tmode = insn_data[icode].operand[0].mode;\n+  enum machine_mode mode0 = insn_data[icode].operand[1].mode;\n+  enum machine_mode mode1 = insn_data[icode].operand[2].mode;\n+\n+  if (VECTOR_MODE_P (mode0))\n+    op0 = safe_vector_operand (op0, mode0);\n+  if (VECTOR_MODE_P (mode1))\n+    op1 = safe_vector_operand (op1, mode1);\n+\n+  if (! target\n+      || GET_MODE (target) != tmode\n+      || ! (*insn_data[icode].operand[0].predicate) (target, tmode))\n+    target = gen_reg_rtx (tmode);\n+\n+  /* In case the insn wants input operands in modes different from\n+     the result, abort.  */\n+  if (GET_MODE (op0) != mode0 || GET_MODE (op1) != mode1)\n+    abort ();\n+\n+  if (! (*insn_data[icode].operand[1].predicate) (op0, mode0))\n+    op0 = copy_to_mode_reg (mode0, op0);\n+  if (! (*insn_data[icode].operand[2].predicate) (op1, mode1))\n+    op1 = copy_to_mode_reg (mode1, op1);\n+\n+  pat = GEN_FCN (icode) (target, op0, op1);\n+  if (! pat)\n+    return 0;\n+  emit_insn (pat);\n+  return target;\n+}\n+\n+/* Subroutine of arm_expand_builtin to take care of unop insns.  */\n+\n+static rtx\n+arm_expand_unop_builtin (enum insn_code icode,\n+\t\t\t tree arglist, rtx target, int do_load)\n+{\n+  rtx pat;\n+  tree arg0 = TREE_VALUE (arglist);\n+  rtx op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n+  enum machine_mode tmode = insn_data[icode].operand[0].mode;\n+  enum machine_mode mode0 = insn_data[icode].operand[1].mode;\n+\n+  if (! target\n+      || GET_MODE (target) != tmode\n+      || ! (*insn_data[icode].operand[0].predicate) (target, tmode))\n+    target = gen_reg_rtx (tmode);\n+  if (do_load)\n+    op0 = gen_rtx_MEM (mode0, copy_to_mode_reg (Pmode, op0));\n+  else\n+    {\n+      if (VECTOR_MODE_P (mode0))\n+\top0 = safe_vector_operand (op0, mode0);\n+\n+      if (! (*insn_data[icode].operand[1].predicate) (op0, mode0))\n+\top0 = copy_to_mode_reg (mode0, op0);\n+    }\n+\n+  pat = GEN_FCN (icode) (target, op0);\n+  if (! pat)\n+    return 0;\n+  emit_insn (pat);\n+  return target;\n+}\n+\n+/* Expand an expression EXP that calls a built-in function,\n+   with result going to TARGET if that's convenient\n+   (and in mode MODE if that's convenient).\n+   SUBTARGET may be used as the target for computing one of EXP's operands.\n+   IGNORE is nonzero if the value is to be ignored.  */\n+\n+static rtx\n+arm_expand_builtin (tree exp,\n+\t\t    rtx target,\n+\t\t    rtx subtarget ATTRIBUTE_UNUSED,\n+\t\t    enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t    int ignore ATTRIBUTE_UNUSED)\n+{\n+  const struct builtin_description * d;\n+  enum insn_code    icode;\n+  tree              fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n+  tree              arglist = TREE_OPERAND (exp, 1);\n+  tree              arg0;\n+  tree              arg1;\n+  tree              arg2;\n+  rtx               op0;\n+  rtx               op1;\n+  rtx               op2;\n+  rtx               pat;\n+  int               fcode = DECL_FUNCTION_CODE (fndecl);\n+  size_t            i;\n+  enum machine_mode tmode;\n+  enum machine_mode mode0;\n+  enum machine_mode mode1;\n+  enum machine_mode mode2;\n+\n+  switch (fcode)\n+    {\n+    case ARM_BUILTIN_TEXTRMSB:\n+    case ARM_BUILTIN_TEXTRMUB:\n+    case ARM_BUILTIN_TEXTRMSH:\n+    case ARM_BUILTIN_TEXTRMUH:\n+    case ARM_BUILTIN_TEXTRMSW:\n+    case ARM_BUILTIN_TEXTRMUW:\n+      icode = (fcode == ARM_BUILTIN_TEXTRMSB ? CODE_FOR_iwmmxt_textrmsb\n+\t       : fcode == ARM_BUILTIN_TEXTRMUB ? CODE_FOR_iwmmxt_textrmub\n+\t       : fcode == ARM_BUILTIN_TEXTRMSH ? CODE_FOR_iwmmxt_textrmsh\n+\t       : fcode == ARM_BUILTIN_TEXTRMUH ? CODE_FOR_iwmmxt_textrmuh\n+\t       : CODE_FOR_iwmmxt_textrmw);\n+\n+      arg0 = TREE_VALUE (arglist);\n+      arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n+      op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n+      op1 = expand_expr (arg1, NULL_RTX, VOIDmode, 0);\n+      tmode = insn_data[icode].operand[0].mode;\n+      mode0 = insn_data[icode].operand[1].mode;\n+      mode1 = insn_data[icode].operand[2].mode;\n+\n+      if (! (*insn_data[icode].operand[1].predicate) (op0, mode0))\n+\top0 = copy_to_mode_reg (mode0, op0);\n+      if (! (*insn_data[icode].operand[2].predicate) (op1, mode1))\n+\t{\n+\t  /* @@@ better error message */\n+\t  error (\"selector must be an immediate\");\n+\t  return gen_reg_rtx (tmode);\n+\t}\n+      if (target == 0\n+\t  || GET_MODE (target) != tmode\n+\t  || ! (*insn_data[icode].operand[0].predicate) (target, tmode))\n+\ttarget = gen_reg_rtx (tmode);\n+      pat = GEN_FCN (icode) (target, op0, op1);\n+      if (! pat)\n+\treturn 0;\n+      emit_insn (pat);\n+      return target;\n+\n+    case ARM_BUILTIN_TINSRB:\n+    case ARM_BUILTIN_TINSRH:\n+    case ARM_BUILTIN_TINSRW:\n+      icode = (fcode == ARM_BUILTIN_TINSRB ? CODE_FOR_iwmmxt_tinsrb\n+\t       : fcode == ARM_BUILTIN_TINSRH ? CODE_FOR_iwmmxt_tinsrh\n+\t       : CODE_FOR_iwmmxt_tinsrw);\n+      arg0 = TREE_VALUE (arglist);\n+      arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n+      arg2 = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n+      op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n+      op1 = expand_expr (arg1, NULL_RTX, VOIDmode, 0);\n+      op2 = expand_expr (arg2, NULL_RTX, VOIDmode, 0);\n+      tmode = insn_data[icode].operand[0].mode;\n+      mode0 = insn_data[icode].operand[1].mode;\n+      mode1 = insn_data[icode].operand[2].mode;\n+      mode2 = insn_data[icode].operand[3].mode;\n+\n+      if (! (*insn_data[icode].operand[1].predicate) (op0, mode0))\n+\top0 = copy_to_mode_reg (mode0, op0);\n+      if (! (*insn_data[icode].operand[2].predicate) (op1, mode1))\n+\top1 = copy_to_mode_reg (mode1, op1);\n+      if (! (*insn_data[icode].operand[3].predicate) (op2, mode2))\n+\t{\n+\t  /* @@@ better error message */\n+\t  error (\"selector must be an immediate\");\n+\t  return const0_rtx;\n+\t}\n+      if (target == 0\n+\t  || GET_MODE (target) != tmode\n+\t  || ! (*insn_data[icode].operand[0].predicate) (target, tmode))\n+\ttarget = gen_reg_rtx (tmode);\n+      pat = GEN_FCN (icode) (target, op0, op1, op2);\n+      if (! pat)\n+\treturn 0;\n+      emit_insn (pat);\n+      return target;\n+\n+    case ARM_BUILTIN_SETWCX:\n+      arg0 = TREE_VALUE (arglist);\n+      arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n+      op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n+      op1 = expand_expr (arg1, NULL_RTX, VOIDmode, 0);\n+      emit_insn (gen_iwmmxt_tmcr (op0, op1));\n+      return 0;\n+\n+    case ARM_BUILTIN_GETWCX:\n+      arg0 = TREE_VALUE (arglist);\n+      op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n+      target = gen_reg_rtx (SImode);\n+      emit_insn (gen_iwmmxt_tmrc (target, op0));\n+      return target;\n+\n+    case ARM_BUILTIN_WSHUFH:\n+      icode = CODE_FOR_iwmmxt_wshufh;\n+      arg0 = TREE_VALUE (arglist);\n+      arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n+      op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n+      op1 = expand_expr (arg1, NULL_RTX, VOIDmode, 0);\n+      tmode = insn_data[icode].operand[0].mode;\n+      mode1 = insn_data[icode].operand[1].mode;\n+      mode2 = insn_data[icode].operand[2].mode;\n+\n+      if (! (*insn_data[icode].operand[1].predicate) (op0, mode1))\n+\top0 = copy_to_mode_reg (mode1, op0);\n+      if (! (*insn_data[icode].operand[2].predicate) (op1, mode2))\n+\t{\n+\t  /* @@@ better error message */\n+\t  error (\"mask must be an immediate\");\n+\t  return const0_rtx;\n+\t}\n+      if (target == 0\n+\t  || GET_MODE (target) != tmode\n+\t  || ! (*insn_data[icode].operand[0].predicate) (target, tmode))\n+\ttarget = gen_reg_rtx (tmode);\n+      pat = GEN_FCN (icode) (target, op0, op1);\n+      if (! pat)\n+\treturn 0;\n+      emit_insn (pat);\n+      return target;\n+\n+    case ARM_BUILTIN_WSADB:\n+      return arm_expand_binop_builtin (CODE_FOR_iwmmxt_wsadb, arglist, target);\n+    case ARM_BUILTIN_WSADH:\n+      return arm_expand_binop_builtin (CODE_FOR_iwmmxt_wsadh, arglist, target);\n+    case ARM_BUILTIN_WSADBZ:\n+      return arm_expand_binop_builtin (CODE_FOR_iwmmxt_wsadbz, arglist, target);\n+    case ARM_BUILTIN_WSADHZ:\n+      return arm_expand_binop_builtin (CODE_FOR_iwmmxt_wsadhz, arglist, target);\n+\n+      /* Several three-argument builtins.  */\n+    case ARM_BUILTIN_WMACS:\n+    case ARM_BUILTIN_WMACU:\n+    case ARM_BUILTIN_WALIGN:\n+    case ARM_BUILTIN_TMIA:\n+    case ARM_BUILTIN_TMIAPH:\n+    case ARM_BUILTIN_TMIATT:\n+    case ARM_BUILTIN_TMIATB:\n+    case ARM_BUILTIN_TMIABT:\n+    case ARM_BUILTIN_TMIABB:\n+      icode = (fcode == ARM_BUILTIN_WMACS ? CODE_FOR_iwmmxt_wmacs\n+\t       : fcode == ARM_BUILTIN_WMACU ? CODE_FOR_iwmmxt_wmacu\n+\t       : fcode == ARM_BUILTIN_TMIA ? CODE_FOR_iwmmxt_tmia\n+\t       : fcode == ARM_BUILTIN_TMIAPH ? CODE_FOR_iwmmxt_tmiaph\n+\t       : fcode == ARM_BUILTIN_TMIABB ? CODE_FOR_iwmmxt_tmiabb\n+\t       : fcode == ARM_BUILTIN_TMIABT ? CODE_FOR_iwmmxt_tmiabt\n+\t       : fcode == ARM_BUILTIN_TMIATB ? CODE_FOR_iwmmxt_tmiatb\n+\t       : fcode == ARM_BUILTIN_TMIATT ? CODE_FOR_iwmmxt_tmiatt\n+\t       : CODE_FOR_iwmmxt_walign);\n+      arg0 = TREE_VALUE (arglist);\n+      arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n+      arg2 = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n+      op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n+      op1 = expand_expr (arg1, NULL_RTX, VOIDmode, 0);\n+      op2 = expand_expr (arg2, NULL_RTX, VOIDmode, 0);\n+      tmode = insn_data[icode].operand[0].mode;\n+      mode0 = insn_data[icode].operand[1].mode;\n+      mode1 = insn_data[icode].operand[2].mode;\n+      mode2 = insn_data[icode].operand[3].mode;\n+\n+      if (! (*insn_data[icode].operand[1].predicate) (op0, mode0))\n+\top0 = copy_to_mode_reg (mode0, op0);\n+      if (! (*insn_data[icode].operand[2].predicate) (op1, mode1))\n+\top1 = copy_to_mode_reg (mode1, op1);\n+      if (! (*insn_data[icode].operand[3].predicate) (op2, mode2))\n+\top2 = copy_to_mode_reg (mode2, op2);\n+      if (target == 0\n+\t  || GET_MODE (target) != tmode\n+\t  || ! (*insn_data[icode].operand[0].predicate) (target, tmode))\n+\ttarget = gen_reg_rtx (tmode);\n+      pat = GEN_FCN (icode) (target, op0, op1, op2);\n+      if (! pat)\n+\treturn 0;\n+      emit_insn (pat);\n+      return target;\n+      \n+    case ARM_BUILTIN_WZERO:\n+      target = gen_reg_rtx (DImode);\n+      emit_insn (gen_iwmmxt_clrdi (target));\n+      return target;\n+\n+    default:\n+      break;\n+    }\n+\n+  for (i = 0, d = bdesc_2arg; i < sizeof (bdesc_2arg) / sizeof *d; i++, d++)\n+    if (d->code == (const enum arm_builtins) fcode)\n+      return arm_expand_binop_builtin (d->icode, arglist, target);\n+\n+  for (i = 0, d = bdesc_1arg; i < sizeof (bdesc_1arg) / sizeof *d; i++, d++)\n+    if (d->code == (const enum arm_builtins) fcode)\n+      return arm_expand_unop_builtin (d->icode, arglist, target, 0);\n+\n+  /* @@@ Should really do something sensible here.  */\n+  return NULL_RTX;\n+}\n+\f\n /* Recursively search through all of the blocks in a function\n    checking to see if any of the variables created in that\n    function match the RTX called 'orig'.  If they do then\n@@ -11783,3 +12981,64 @@ arm_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n     fputs (\"(PLT)\", file);\n   fputc ('\\n', file);\n }\n+\n+int\n+arm_emit_vector_const (file, x)\n+     FILE * file;\n+     rtx    x;\n+{\n+  int i;\n+  const char * pattern;\n+\n+  if (GET_CODE (x) != CONST_VECTOR)\n+    abort ();\n+\n+  switch (GET_MODE (x))\n+    {\n+    case V2SImode: pattern = \"%08x\"; break;\n+    case V4HImode: pattern = \"%04x\"; break;\n+    case V8QImode: pattern = \"%02x\"; break;\n+    default:       abort ();\n+    }\n+\n+  fprintf (file, \"0x\");\n+  for (i = CONST_VECTOR_NUNITS (x); i--;)\n+    {\n+      rtx element;\n+\n+      element = CONST_VECTOR_ELT (x, i);\n+      fprintf (file, pattern, INTVAL (element));\n+    }\n+\n+  return 1;\n+}\n+\n+const char *\n+arm_output_load_gr (operands)\n+     rtx * operands;\n+{\n+  rtx reg;\n+  rtx offset;\n+  rtx wcgr;\n+  rtx sum;\n+  \n+  if (GET_CODE (operands [1]) != MEM\n+      || GET_CODE (sum = XEXP (operands [1], 0)) != PLUS\n+      || GET_CODE (reg = XEXP (sum, 0)) != REG\n+      || GET_CODE (offset = XEXP (sum, 1)) != CONST_INT\n+      || ((INTVAL (offset) < 1024) && (INTVAL (offset) > -1024)))\n+    return \"wldrw%?\\t%0, %1\";\n+  \n+  /* Fix up an out-of-range load of a GR register.  */  \n+  output_asm_insn (\"str%?\\t%0, [sp, #-4]!\\t@ Start of GR load expansion\", & reg);\n+  wcgr = operands[0];\n+  operands[0] = reg;\n+  output_asm_insn (\"ldr%?\\t%0, %1\", operands);\n+\n+  operands[0] = wcgr;\n+  operands[1] = reg;\n+  output_asm_insn (\"tmcr%?\\t%0, %1\", operands);\n+  output_asm_insn (\"ldr%?\\t%0, [sp], #4\\t@ End of GR load expansion\", & reg);\n+\n+  return \"\";\n+}"}, {"sha": "0a3dcda693b9973f49c087055afd636d8f57a565", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 311, "deletions": 12, "changes": 323, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a9335ef017c45e09d9493b982a25a8e58b51d40/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a9335ef017c45e09d9493b982a25a8e58b51d40/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=5a9335ef017c45e09d9493b982a25a8e58b51d40", "patch": "@@ -97,6 +97,7 @@\n #define TARGET_CPU_arm9tdmi\t0x0080\n #define TARGET_CPU_xscale       0x0100\n #define TARGET_CPU_ep9312\t0x0200\n+#define TARGET_CPU_iwmmxt\t0x0400\n /* Configure didn't specify.  */\n #define TARGET_CPU_generic\t0x8000\n \n@@ -265,6 +266,9 @@ Unrecognized value in TARGET_CPU_DEFAULT.\n  %{mcpu=xscale:-D__XSCALE__} \\\n  %{mcpu=ep9312:-D__ARM_ARCH_4T__} \\\n  %{mcpu=ep9312:-D__MAVERICK__} \\\n+ %{mcpu=iwmmxt:-D__ARM_ARCH_5TE__} \\\n+ %{mcpu=iwmmxt:-D__XSCALE__} \\\n+ %{mcpu=iwmmxt:-D__IWMMXT__} \\\n  %{!mcpu*:%(cpp_cpu_arch_default)}} \\\n \"\n \n@@ -406,6 +410,8 @@ Unrecognized value in TARGET_CPU_DEFAULT.\n #define TARGET_HARD_FLOAT\t\t(! TARGET_SOFT_FLOAT)\n #define TARGET_CIRRUS\t\t\t(arm_is_cirrus)\n #define TARGET_ANY_HARD_FLOAT\t\t(TARGET_HARD_FLOAT || TARGET_CIRRUS)\n+#define TARGET_IWMMXT\t\t\t(arm_arch_iwmmxt)\n+#define TARGET_REALLY_IWMMXT\t\t(TARGET_IWMMXT && TARGET_ARM)\n #define TARGET_VFP\t\t\t(target_flags & ARM_FLAG_VFP)\n #define TARGET_BIG_END\t\t\t(target_flags & ARM_FLAG_BIG_END)\n #define TARGET_INTERWORK\t\t(target_flags & ARM_FLAG_INTERWORK)\n@@ -623,6 +629,9 @@ extern int arm_is_strong;\n /* Nonzero if this chip is a Cirrus variant.  */\n extern int arm_is_cirrus;\n \n+/* Nonzero if this chip supports Intel XScale with Wireless MMX technology.  */\n+extern int arm_arch_iwmmxt;\n+\n /* Nonzero if this chip is an XScale.  */\n extern int arm_arch_xscale;\n \n@@ -729,6 +738,8 @@ extern int arm_is_6_or_7;\n \n #define PARM_BOUNDARY  \t32\n \n+#define IWMMXT_ALIGNMENT   64\n+\n #define STACK_BOUNDARY  32\n \n #define PREFERRED_STACK_BOUNDARY (TARGET_ATPCS ? 64 : 32)\n@@ -742,13 +753,46 @@ extern int arm_is_6_or_7;\n \n #define EMPTY_FIELD_BOUNDARY  32\n \n-#define BIGGEST_ALIGNMENT  32\n+#define BIGGEST_ALIGNMENT  (TARGET_ATPCS ? 64 : 32)\n+\n+#define TYPE_NEEDS_IWMMXT_ALIGNMENT(TYPE)\t\\\n+ (TARGET_REALLY_IWMMXT\t\t\t\t\\\n+   && ((TREE_CODE (TYPE) == VECTOR_TYPE) || (TYPE_MODE (TYPE) == DImode) || (TYPE_MODE (TYPE) == DFmode)))\n+\n+/* An expression for the alignment of a structure field FIELD if the\n+   alignment computed in the usual way is COMPUTED.  GCC uses this\n+   value instead of the value in `BIGGEST_ALIGNMENT' or\n+   `BIGGEST_FIELD_ALIGNMENT', if defined, for structure fields only.  */\n+#define ADJUST_FIELD_ALIGN(FIELD, COMPUTED)\t\t\\\n+  (TYPE_NEEDS_IWMMXT_ALIGNMENT (TREE_TYPE (FIELD))\t\\\n+   ? IWMMXT_ALIGNMENT\t\t\t\t\t\\\n+   : (COMPUTED))\n+\n+/* If defined, a C expression to compute the alignment for a static variable.\n+   TYPE is the data type, and ALIGN is the alignment that the object\n+   would ordinarily have.  The value of this macro is used instead of that\n+   alignment to align the object.\n+\n+   If this macro is not defined, then ALIGN is used.  */\n+#define DATA_ALIGNMENT(TYPE, ALIGN) \\\n+  (TYPE_NEEDS_IWMMXT_ALIGNMENT (TYPE) ? IWMMXT_ALIGNMENT : ALIGN)\n+\n+/* If defined, a C expression to compute the alignment for a\n+   variables in the local store.  TYPE is the data type, and\n+   BASIC-ALIGN is the alignment that the object would ordinarily\n+   have.  The value of this macro is used instead of that alignment\n+   to align the object.\n+\n+   If this macro is not defined, then BASIC-ALIGN is used.  */\n+#define LOCAL_ALIGNMENT(TYPE, ALIGN) \\\n+  (TYPE_NEEDS_IWMMXT_ALIGNMENT (TYPE) ? IWMMXT_ALIGNMENT : ALIGN)\n \n /* Make strings word-aligned so strcpy from constants will be faster.  */\n #define CONSTANT_ALIGNMENT_FACTOR (TARGET_THUMB || ! arm_arch_xscale ? 1 : 2)\n     \n #define CONSTANT_ALIGNMENT(EXP, ALIGN)\t\t\t\t\\\n-  ((TREE_CODE (EXP) == STRING_CST\t\t\t\t\\\n+  ((TARGET_REALLY_IWMMXT && TREE_CODE (EXP) == VECTOR_TYPE) ? IWMMXT_ALIGNMENT : \\\n+   (TREE_CODE (EXP) == STRING_CST\t\t\t\t\\\n     && (ALIGN) < BITS_PER_WORD * CONSTANT_ALIGNMENT_FACTOR)\t\\\n    ? BITS_PER_WORD * CONSTANT_ALIGNMENT_FACTOR : (ALIGN))\n \n@@ -848,7 +892,10 @@ extern const char * structure_size_string;\n   0,0,0,0,0,0,0,0,\t \\\n   1,1,1,\t\t\\\n   1,1,1,1,1,1,1,1,\t\\\n-  1,1,1,1,1,1,1,1\t\\\n+  1,1,1,1,1,1,1,1,\t \\\n+  1,1,1,1,1,1,1,1,\t \\\n+  1,1,1,1,1,1,1,1,\t \\\n+  1,1,1,1\t\t \\\n }\n \n /* 1 for registers not available across function calls.\n@@ -866,7 +913,10 @@ extern const char * structure_size_string;\n   1,1,1,1,0,0,0,0,\t     \\\n   1,1,1,\t\t     \\\n   1,1,1,1,1,1,1,1,\t     \\\n-  1,1,1,1,1,1,1,1\t     \\\n+  1,1,1,1,1,1,1,1,\t     \\\n+  1,1,1,1,1,1,1,1,\t     \\\n+  1,1,1,1,1,1,1,1,\t     \\\n+  1,1,1,1\t\t     \\\n }\n \n #ifndef SUBTARGET_CONDITIONAL_REGISTER_USAGE\n@@ -897,6 +947,26 @@ extern const char * structure_size_string;\n \t}\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\\\n+  if (TARGET_REALLY_IWMMXT)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      regno = FIRST_IWMMXT_GR_REGNUM;\t\t\t\t\\\n+      /* The 2002/10/09 revision of the XScale ABI has wCG0     \\\n+         and wCG1 as call-preserved registers.  The 2002/11/21  \\\n+         revision changed this so that all wCG registers are    \\\n+         scratch registers.  */\t\t\t\t\t\\\n+      for (regno = FIRST_IWMMXT_GR_REGNUM;\t\t\t\\\n+\t   regno <= LAST_IWMMXT_GR_REGNUM; ++ regno)\t\t\\\n+\tfixed_regs[regno] = call_used_regs[regno] = 0;\t\t\\\n+      /* The XScale ABI has wR0 - wR9 as scratch registers,     \\\n+\t the rest as call-preserved registers.  */\t\t\\\n+      for (regno = FIRST_IWMMXT_REGNUM;\t\t\t\t\\\n+\t   regno <= LAST_IWMMXT_REGNUM; ++ regno)\t\t\\\n+\t{\t\t\t\t\t\t\t\\\n+\t  fixed_regs[regno] = 0;\t\t\t\t\\\n+\t  call_used_regs[regno] = regno < FIRST_IWMMXT_REGNUM + 10; \\\n+\t}\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n   if ((unsigned) PIC_OFFSET_TABLE_REGNUM != INVALID_REGNUM)\t\\\n     {\t\t\t\t\t\t\t\t\\\n       fixed_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\t\t\\\n@@ -1014,6 +1084,15 @@ extern const char * structure_size_string;\n #define FIRST_ARM_FP_REGNUM \t16\n #define LAST_ARM_FP_REGNUM  \t23\n \n+#define FIRST_IWMMXT_GR_REGNUM\t43\n+#define LAST_IWMMXT_GR_REGNUM\t46\n+#define FIRST_IWMMXT_REGNUM\t47\n+#define LAST_IWMMXT_REGNUM\t62\n+#define IS_IWMMXT_REGNUM(REGNUM) \\\n+  (((REGNUM) >= FIRST_IWMMXT_REGNUM) && ((REGNUM) <= LAST_IWMMXT_REGNUM))\n+#define IS_IWMMXT_GR_REGNUM(REGNUM) \\\n+  (((REGNUM) >= FIRST_IWMMXT_GR_REGNUM) && ((REGNUM) <= LAST_IWMMXT_GR_REGNUM))\n+\n /* Base register for access to local variables of the function.  */\n #define FRAME_POINTER_REGNUM\t25\n \n@@ -1027,7 +1106,8 @@ extern const char * structure_size_string;\n \n /* The number of hard registers is 16 ARM + 8 FPA + 1 CC + 1 SFP + 1 AFP.  */\n /* + 16 Cirrus registers take us up to 43.  */\n-#define FIRST_PSEUDO_REGISTER\t43\n+/* Intel Wireless MMX Technology registers add 16 + 4 more.  */\n+#define FIRST_PSEUDO_REGISTER   63\n \n /* Value should be nonzero if functions must have frame pointers.\n    Zero means the frame pointer need not be set up (and parms may be accessed\n@@ -1064,6 +1144,12 @@ extern const char * structure_size_string;\n #define MODES_TIEABLE_P(MODE1, MODE2)  \\\n   (GET_MODE_CLASS (MODE1) == GET_MODE_CLASS (MODE2))\n \n+#define VECTOR_MODE_SUPPORTED_P(MODE) \\\n+ ((MODE) == V2SImode || (MODE) == V4HImode || (MODE) == V8QImode)\n+\n+#define VALID_IWMMXT_REG_MODE(MODE) \\\n+ (VECTOR_MODE_SUPPORTED_P (MODE) || (MODE) == DImode)\n+\n /* The order in which register should be allocated.  It is good to use ip\n    since no saving is required (though calls clobber it) and it never contains\n    function parameters.  It is quite good to use lr since other calls may\n@@ -1077,6 +1163,9 @@ extern const char * structure_size_string;\n     16, 17, 18, 19, 20, 21, 22, 23, \\\n     27, 28, 29, 30, 31, 32, 33, 34, \\\n     35, 36, 37, 38, 39, 40, 41, 42, \\\n+    43, 44, 45, 46, 47, 48, 49, 50, \\\n+    51, 52, 53, 54, 55, 56, 57, 58, \\\n+    59, 60, 61, 62,\t\t    \\\n     24, 25, 26\t\t\t    \\\n }\n \n@@ -1096,6 +1185,8 @@ enum reg_class\n   NO_REGS,\n   FPA_REGS,\n   CIRRUS_REGS,\n+  IWMMXT_GR_REGS,\n+  IWMMXT_REGS,\n   LO_REGS,\n   STACK_REG,\n   BASE_REGS,\n@@ -1114,6 +1205,8 @@ enum reg_class\n   \"NO_REGS\",\t\t\\\n   \"FPA_REGS\",\t\t\\\n   \"CIRRUS_REGS\",\t\\\n+  \"IWMMXT_GR_REGS\",\t\\\n+  \"IWMMXT_REGS\",\t\\\n   \"LO_REGS\",\t\t\\\n   \"STACK_REG\",\t\t\\\n   \"BASE_REGS\",\t\t\\\n@@ -1131,13 +1224,15 @@ enum reg_class\n   { 0x00000000, 0x0 },        /* NO_REGS  */\t\\\n   { 0x00FF0000, 0x0 },        /* FPA_REGS */\t\\\n   { 0xF8000000, 0x000007FF }, /* CIRRUS_REGS */\t\\\n+  { 0x00000000, 0x00007800 }, /* IWMMXT_GR_REGS */\\\n+  { 0x00000000, 0x7FFF8000 }, /* IWMMXT_REGS */\t\\\n   { 0x000000FF, 0x0 },        /* LO_REGS */\t\\\n   { 0x00002000, 0x0 },        /* STACK_REG */\t\\\n   { 0x000020FF, 0x0 },        /* BASE_REGS */\t\\\n   { 0x0000FF00, 0x0 },        /* HI_REGS */\t\\\n   { 0x01000000, 0x0 },        /* CC_REG */\t\\\n   { 0x0200FFFF, 0x0 },        /* GENERAL_REGS */\\\n-  { 0xFAFFFFFF, 0x000007FF }  /* ALL_REGS */\t\\\n+  { 0xFAFFFFFF, 0x7FFFFFFF }  /* ALL_REGS */\t\\\n }\n \n /* The same information, inverted:\n@@ -1177,6 +1272,8 @@ enum reg_class\n #define REG_CLASS_FROM_LETTER(C)  \t\\\n   (  (C) == 'f' ? FPA_REGS\t\t\\\n    : (C) == 'v' ? CIRRUS_REGS\t\t\\\n+   : (C) == 'y' ? IWMMXT_REGS\t\t\\\n+   : (C) == 'z' ? IWMMXT_GR_REGS\t\\\n    : (C) == 'l' ? (TARGET_ARM ? GENERAL_REGS : LO_REGS)\t\\\n    : TARGET_ARM ? NO_REGS\t\t\\\n    : (C) == 'h' ? HI_REGS\t\t\\\n@@ -1292,6 +1389,9 @@ enum reg_class\n      && (CONSTANT_P (X) || GET_CODE (X) == SYMBOL_REF))\t\t\\\n     ? GENERAL_REGS :\t\t\t\t\t\t\\\n   (TARGET_ARM ?\t\t\t\t\t\t\t\\\n+   (((CLASS) == IWMMXT_REGS || (CLASS) == IWMMXT_GR_REGS)\t\\\n+      && CONSTANT_P (X))\t\t\t\t\t\\\n+   ? GENERAL_REGS :\t\t\t\t\t\t\\\n    (((MODE) == HImode && ! arm_arch4 && TARGET_MMU_TRAPS\t\\\n      && (GET_CODE (X) == MEM\t\t\t\t\t\\\n \t || ((GET_CODE (X) == REG || GET_CODE (X) == SUBREG)\t\\\n@@ -1405,6 +1505,9 @@ enum reg_class\n   (TARGET_ARM ?\t\t\t\t\t\t\\\n    ((FROM) == FPA_REGS && (TO) != FPA_REGS ? 20 :\t\\\n     (FROM) != FPA_REGS && (TO) == FPA_REGS ? 20 :\t\\\n+    (FROM) == IWMMXT_REGS && (TO) != IWMMXT_REGS ? 4 :  \\\n+    (FROM) != IWMMXT_REGS && (TO) == IWMMXT_REGS ? 4 :  \\\n+    (FROM) == IWMMXT_GR_REGS || (TO) == IWMMXT_GR_REGS ? 20 :  \\\n     (FROM) == CIRRUS_REGS && (TO) != CIRRUS_REGS ? 20 :\t\\\n     (FROM) != CIRRUS_REGS && (TO) == CIRRUS_REGS ? 20 :\t\\\n    2)\t\t\t\t\t\t\t\\\n@@ -1461,6 +1564,8 @@ enum reg_class\n    ? gen_rtx_REG (MODE, FIRST_ARM_FP_REGNUM) \\\n    : TARGET_ARM && TARGET_CIRRUS && GET_MODE_CLASS (MODE) == MODE_FLOAT \\\n    ? gen_rtx_REG (MODE, FIRST_CIRRUS_FP_REGNUM) \t\t\t\\\n+   : TARGET_REALLY_IWMMXT && VECTOR_MODE_SUPPORTED_P (MODE)\t\t\\\n+   ? gen_rtx_REG (MODE, FIRST_IWMMXT_REGNUM) \t\t\t\t\\\n    : gen_rtx_REG (MODE, ARG_REGISTER (1)))\n \n /* Define how to find the value returned by a function.\n@@ -1476,6 +1581,7 @@ enum reg_class\n #define FUNCTION_VALUE_REGNO_P(REGNO)  \\\n   ((REGNO) == ARG_REGISTER (1) \\\n    || (TARGET_ARM && ((REGNO) == FIRST_CIRRUS_FP_REGNUM) && TARGET_CIRRUS) \\\n+   || (TARGET_ARM && ((REGNO) == FIRST_IWMMXT_REGNUM) && TARGET_IWMMXT) \\\n    || (TARGET_ARM && ((REGNO) == FIRST_ARM_FP_REGNUM) && TARGET_HARD_FLOAT))\n \n /* How large values are returned */\n@@ -1546,6 +1652,9 @@ typedef struct machine_function GTY(())\n   unsigned long func_type;\n   /* Record if the function has a variable argument list.  */\n   int uses_anonymous_args;\n+  /* Records if sibcalls are blocked because an argument\n+     register is needed to preserve stack alignment.  */\n+  int sibcall_blocked;\n }\n machine_function;\n \n@@ -1556,6 +1665,10 @@ typedef struct\n {\n   /* This is the number of registers of arguments scanned so far.  */\n   int nregs;\n+  /* This is the number of iWMMXt register arguments scanned so far.  */\n+  int iwmmxt_nregs;\n+  int named_count;\n+  int nargs;\n   /* One of CALL_NORMAL, CALL_LONG or CALL_SHORT . */\n   int call_cookie;\n } CUMULATIVE_ARGS;\n@@ -1585,7 +1698,8 @@ typedef struct\n    this is the number of registers used.\n    For args passed entirely in registers or entirely in memory, zero.  */\n #define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED)\t\\\n-  (    NUM_ARG_REGS > (CUM).nregs\t\t\t\t\\\n+  (VECTOR_MODE_SUPPORTED_P (MODE) ? 0 :\t\t\t\t\\\n+       NUM_ARG_REGS > (CUM).nregs\t\t\t\t\\\n    && (NUM_ARG_REGS < ((CUM).nregs + ARM_NUM_REGS2 (MODE, TYPE)))\t\\\n    ?   NUM_ARG_REGS - (CUM).nregs : 0)\n \n@@ -1608,11 +1722,27 @@ typedef struct\n    of mode MODE and data type TYPE.\n    (TYPE is null for libcalls where that information may not be available.)  */\n #define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n+  (CUM).nargs += 1;\t\t\t\t\t\\\n+  if (VECTOR_MODE_SUPPORTED_P (MODE))\t\t\t\\\n+     if ((CUM).named_count <= (CUM).nargs)\t\t\\\n+        (CUM).nregs += 2;\t\t\t\t\\\n+     else\t\t\t\t\t\t\\\n+        (CUM).iwmmxt_nregs += 1;\t\t\t\\\n+  else\t\t\t\t\t\t\t\\\n   (CUM).nregs += ARM_NUM_REGS2 (MODE, TYPE)\n \n+/* If defined, a C expression that gives the alignment boundary, in bits, of an\n+   argument with the specified mode and type.  If it is not defined,\n+   `PARM_BOUNDARY' is used for all arguments.  */\n+#define FUNCTION_ARG_BOUNDARY(MODE,TYPE) \\\n+  (TARGET_REALLY_IWMMXT && (VALID_IWMMXT_REG_MODE (MODE) || ((MODE) == DFmode)) \\\n+   ? IWMMXT_ALIGNMENT : PARM_BOUNDARY)\n+\n /* 1 if N is a possible register number for function argument passing.\n    On the ARM, r0-r3 are used to pass args.  */\n-#define FUNCTION_ARG_REGNO_P(REGNO)\t(IN_RANGE ((REGNO), 0, 3))\n+#define FUNCTION_ARG_REGNO_P(REGNO)\t\\\n+   (IN_RANGE ((REGNO), 0, 3)\t\t\\\n+    || (TARGET_REALLY_IWMMXT && IN_RANGE ((REGNO), FIRST_IWMMXT_REGNUM, FIRST_IWMMXT_REGNUM + 9)))\n \n /* Implement `va_arg'.  */\n #define EXPAND_BUILTIN_VA_ARG(valist, type) \\\n@@ -2333,14 +2463,14 @@ extern int making_const_table;\n /* To support -falign-* switches we need to use .p2align so\n    that alignment directives in code sections will be padded\n    with no-op instructions, rather than zeroes.  */\n-#define ASM_OUTPUT_MAX_SKIP_ALIGN(FILE,LOG,MAX_SKIP)\t\t\\\n+#define ASM_OUTPUT_MAX_SKIP_ALIGN(FILE, LOG, MAX_SKIP)\t\t\\\n   if ((LOG) != 0)\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\\\n       if ((MAX_SKIP) == 0)\t\t\t\t\t\\\n-        fprintf ((FILE), \"\\t.p2align %d\\n\", (LOG));\t\t\\\n+        fprintf ((FILE), \"\\t.p2align %d\\n\", (int) (LOG));\t\\\n       else\t\t\t\t\t\t\t\\\n         fprintf ((FILE), \"\\t.p2align %d,,%d\\n\",\t\t\t\\\n-                 (LOG), (MAX_SKIP));\t\t\t\t\\\n+                 (int) (LOG), (int) (MAX_SKIP));\t\t\\\n     }\n #endif\n \f\n@@ -2491,7 +2621,12 @@ extern int making_const_table;\n     ARM_PRINT_OPERAND_ADDRESS (STREAM, X)\t\\\n   else\t\t\t\t\t\t\\\n     THUMB_PRINT_OPERAND_ADDRESS (STREAM, X)\n-     \n+\n+#define OUTPUT_ADDR_CONST_EXTRA(FILE, X, FAIL)\t\\\n+  if (GET_CODE (X) != CONST_VECTOR\t\t\\\n+      || ! arm_emit_vector_const (FILE, X))\t\\\n+    goto FAIL;\n+\n /* A C expression whose value is RTL representing the value of the return\n    address for the frame COUNT steps up from the current frame.  */\n \n@@ -2567,4 +2702,168 @@ extern int making_const_table;\n #define SPECIAL_MODE_PREDICATES\t\t\t\\\n  \"cc_register\", \"dominant_cc_register\",\n \n+enum arm_builtins\n+{\n+  ARM_BUILTIN_GETWCX,\n+  ARM_BUILTIN_SETWCX,\n+\n+  ARM_BUILTIN_WZERO,\n+\n+  ARM_BUILTIN_WAVG2BR,\n+  ARM_BUILTIN_WAVG2HR,\n+  ARM_BUILTIN_WAVG2B,\n+  ARM_BUILTIN_WAVG2H,\n+\n+  ARM_BUILTIN_WACCB,\n+  ARM_BUILTIN_WACCH,\n+  ARM_BUILTIN_WACCW,\n+\n+  ARM_BUILTIN_WMACS,\n+  ARM_BUILTIN_WMACSZ,\n+  ARM_BUILTIN_WMACU,\n+  ARM_BUILTIN_WMACUZ,\n+\n+  ARM_BUILTIN_WSADB,\n+  ARM_BUILTIN_WSADBZ,\n+  ARM_BUILTIN_WSADH,\n+  ARM_BUILTIN_WSADHZ,\n+\n+  ARM_BUILTIN_WALIGN,\n+\n+  ARM_BUILTIN_TMIA,\n+  ARM_BUILTIN_TMIAPH,\n+  ARM_BUILTIN_TMIABB,\n+  ARM_BUILTIN_TMIABT,\n+  ARM_BUILTIN_TMIATB,\n+  ARM_BUILTIN_TMIATT,\n+\n+  ARM_BUILTIN_TMOVMSKB,\n+  ARM_BUILTIN_TMOVMSKH,\n+  ARM_BUILTIN_TMOVMSKW,\n+\n+  ARM_BUILTIN_TBCSTB,\n+  ARM_BUILTIN_TBCSTH,\n+  ARM_BUILTIN_TBCSTW,\n+\n+  ARM_BUILTIN_WMADDS,\n+  ARM_BUILTIN_WMADDU,\n+\n+  ARM_BUILTIN_WPACKHSS,\n+  ARM_BUILTIN_WPACKWSS,\n+  ARM_BUILTIN_WPACKDSS,\n+  ARM_BUILTIN_WPACKHUS,\n+  ARM_BUILTIN_WPACKWUS,\n+  ARM_BUILTIN_WPACKDUS,\n+\n+  ARM_BUILTIN_WADDB,\n+  ARM_BUILTIN_WADDH,\n+  ARM_BUILTIN_WADDW,\n+  ARM_BUILTIN_WADDSSB,\n+  ARM_BUILTIN_WADDSSH,\n+  ARM_BUILTIN_WADDSSW,\n+  ARM_BUILTIN_WADDUSB,\n+  ARM_BUILTIN_WADDUSH,\n+  ARM_BUILTIN_WADDUSW,\n+  ARM_BUILTIN_WSUBB,\n+  ARM_BUILTIN_WSUBH,\n+  ARM_BUILTIN_WSUBW,\n+  ARM_BUILTIN_WSUBSSB,\n+  ARM_BUILTIN_WSUBSSH,\n+  ARM_BUILTIN_WSUBSSW,\n+  ARM_BUILTIN_WSUBUSB,\n+  ARM_BUILTIN_WSUBUSH,\n+  ARM_BUILTIN_WSUBUSW,\n+\n+  ARM_BUILTIN_WAND,\n+  ARM_BUILTIN_WANDN,\n+  ARM_BUILTIN_WOR,\n+  ARM_BUILTIN_WXOR,\n+\n+  ARM_BUILTIN_WCMPEQB,\n+  ARM_BUILTIN_WCMPEQH,\n+  ARM_BUILTIN_WCMPEQW,\n+  ARM_BUILTIN_WCMPGTUB,\n+  ARM_BUILTIN_WCMPGTUH,\n+  ARM_BUILTIN_WCMPGTUW,\n+  ARM_BUILTIN_WCMPGTSB,\n+  ARM_BUILTIN_WCMPGTSH,\n+  ARM_BUILTIN_WCMPGTSW,\n+\n+  ARM_BUILTIN_TEXTRMSB,\n+  ARM_BUILTIN_TEXTRMSH,\n+  ARM_BUILTIN_TEXTRMSW,\n+  ARM_BUILTIN_TEXTRMUB,\n+  ARM_BUILTIN_TEXTRMUH,\n+  ARM_BUILTIN_TEXTRMUW,\n+  ARM_BUILTIN_TINSRB,\n+  ARM_BUILTIN_TINSRH,\n+  ARM_BUILTIN_TINSRW,\n+\n+  ARM_BUILTIN_WMAXSW,\n+  ARM_BUILTIN_WMAXSH,\n+  ARM_BUILTIN_WMAXSB,\n+  ARM_BUILTIN_WMAXUW,\n+  ARM_BUILTIN_WMAXUH,\n+  ARM_BUILTIN_WMAXUB,\n+  ARM_BUILTIN_WMINSW,\n+  ARM_BUILTIN_WMINSH,\n+  ARM_BUILTIN_WMINSB,\n+  ARM_BUILTIN_WMINUW,\n+  ARM_BUILTIN_WMINUH,\n+  ARM_BUILTIN_WMINUB,\n+\n+  ARM_BUILTIN_WMULUH,\n+  ARM_BUILTIN_WMULSH,\n+  ARM_BUILTIN_WMULUL,\n+\n+  ARM_BUILTIN_PSADBH,\n+  ARM_BUILTIN_WSHUFH,\n+\n+  ARM_BUILTIN_WSLLH,\n+  ARM_BUILTIN_WSLLW,\n+  ARM_BUILTIN_WSLLD,\n+  ARM_BUILTIN_WSRAH,\n+  ARM_BUILTIN_WSRAW,\n+  ARM_BUILTIN_WSRAD,\n+  ARM_BUILTIN_WSRLH,\n+  ARM_BUILTIN_WSRLW,\n+  ARM_BUILTIN_WSRLD,\n+  ARM_BUILTIN_WRORH,\n+  ARM_BUILTIN_WRORW,\n+  ARM_BUILTIN_WRORD,\n+  ARM_BUILTIN_WSLLHI,\n+  ARM_BUILTIN_WSLLWI,\n+  ARM_BUILTIN_WSLLDI,\n+  ARM_BUILTIN_WSRAHI,\n+  ARM_BUILTIN_WSRAWI,\n+  ARM_BUILTIN_WSRADI,\n+  ARM_BUILTIN_WSRLHI,\n+  ARM_BUILTIN_WSRLWI,\n+  ARM_BUILTIN_WSRLDI,\n+  ARM_BUILTIN_WRORHI,\n+  ARM_BUILTIN_WRORWI,\n+  ARM_BUILTIN_WRORDI,\n+\n+  ARM_BUILTIN_WUNPCKIHB,\n+  ARM_BUILTIN_WUNPCKIHH,\n+  ARM_BUILTIN_WUNPCKIHW,\n+  ARM_BUILTIN_WUNPCKILB,\n+  ARM_BUILTIN_WUNPCKILH,\n+  ARM_BUILTIN_WUNPCKILW,\n+\n+  ARM_BUILTIN_WUNPCKEHSB,\n+  ARM_BUILTIN_WUNPCKEHSH,\n+  ARM_BUILTIN_WUNPCKEHSW,\n+  ARM_BUILTIN_WUNPCKEHUB,\n+  ARM_BUILTIN_WUNPCKEHUH,\n+  ARM_BUILTIN_WUNPCKEHUW,\n+  ARM_BUILTIN_WUNPCKELSB,\n+  ARM_BUILTIN_WUNPCKELSH,\n+  ARM_BUILTIN_WUNPCKELSW,\n+  ARM_BUILTIN_WUNPCKELUB,\n+  ARM_BUILTIN_WUNPCKELUH,\n+  ARM_BUILTIN_WUNPCKELUW,\n+\n+  ARM_BUILTIN_MAX\n+};\n #endif /* ! GCC_ARM_H */"}, {"sha": "b3456c03031aaa2835ebc56db1869f003805fb9a", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 85, "deletions": 20, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a9335ef017c45e09d9493b982a25a8e58b51d40/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a9335ef017c45e09d9493b982a25a8e58b51d40/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=5a9335ef017c45e09d9493b982a25a8e58b51d40", "patch": "@@ -75,6 +75,18 @@\n    \t\t\t; and stack frame generation.  Operand 0 is the\n    \t\t\t; register to \"use\".\n    (UNSPEC_CHECK_ARCH 7); Set CCs to indicate 26-bit or 32-bit mode.\n+   (UNSPEC_WSHUFH    8) ; Used by the instrinsic form of the iWMMXt WSHUFH instruction.\n+   (UNSPEC_WACC      9) ; Used by the instrinsic form of the iWMMXt WACC instruction.\n+   (UNSPEC_TMOVMSK  10) ; Used by the instrinsic form of the iWMMXt TMOVMSK instruction.\n+   (UNSPEC_WSAD     11) ; Used by the instrinsic form of the iWMMXt WSAD instruction.\n+   (UNSPEC_WSADZ    12) ; Used by the instrinsic form of the iWMMXt WSADZ instruction.\n+   (UNSPEC_WMACS    13) ; Used by the instrinsic form of the iWMMXt WMACS instruction.\n+   (UNSPEC_WMACU    14) ; Used by the instrinsic form of the iWMMXt WMACU instruction.\n+   (UNSPEC_WMACSZ   15) ; Used by the instrinsic form of the iWMMXt WMACSZ instruction.\n+   (UNSPEC_WMACUZ   16) ; Used by the instrinsic form of the iWMMXt WMACUZ instruction.\n+   (UNSPEC_CLRDI    17) ; Used by the instrinsic form of the iWMMXt CLRDI instruction.\n+   (UNSPEC_WMADDS   18) ; Used by the instrinsic form of the iWMMXt WMADDS instruction.\n+   (UNSPEC_WMADDU   19) ; Used by the instrinsic form of the iWMMXt WMADDU instruction.\n   ]\n )\n \n@@ -99,6 +111,12 @@\n \t\t\t;   a 32-bit object.\n    (VUNSPEC_POOL_8   7) ; `pool-entry(8)'.  An entry in the constant pool for\n \t\t\t;   a 64-bit object.\n+   (VUNSPEC_TMRC     8) ; Used by the iWMMXt TMRC instruction.\n+   (VUNSPEC_TMCR     9) ; Used by the iWMMXt TMCR instruction.\n+   (VUNSPEC_ALIGN8   10) ; 8-byte alignment version of VUNSPEC_ALIGN\n+   (VUNSPEC_WCMP_EQ  11) ; Used by the iWMMXt WCMPEQ instructions\n+   (VUNSPEC_WCMP_GTU 12) ; Used by the iWMMXt WCMPGTU instructions\n+   (VUNSPEC_WCMP_GT  13) ; Used by the iwMMXT WCMPGT instructions\n   ]\n )\n \f\n@@ -1369,7 +1387,7 @@\n \t(match_operator:DI 6 \"logical_binary_operator\"\n \t  [(match_operand:DI 1 \"s_register_operand\" \"\")\n \t   (match_operand:DI 2 \"s_register_operand\" \"\")]))]\n-  \"TARGET_ARM && reload_completed\"\n+  \"TARGET_ARM && reload_completed && ! IS_IWMMXT_REGNUM (REGNO (operands[0]))\"\n   [(set (match_dup 0) (match_op_dup:SI 6 [(match_dup 1) (match_dup 2)]))\n    (set (match_dup 3) (match_op_dup:SI 6 [(match_dup 4) (match_dup 5)]))]\n   \"\n@@ -1446,7 +1464,7 @@\n   [(set (match_operand:DI         0 \"s_register_operand\" \"=&r,&r\")\n \t(and:DI (match_operand:DI 1 \"s_register_operand\"  \"%0,r\")\n \t\t(match_operand:DI 2 \"s_register_operand\"   \"r,r\")))]\n-  \"TARGET_ARM\"\n+  \"TARGET_ARM && ! TARGET_IWMMXT\"\n   \"#\"\n   [(set_attr \"length\" \"8\")]\n )\n@@ -1800,7 +1818,7 @@\n \t\t(match_operand:DI 2 \"s_register_operand\" \"0,r\")))]\n   \"TARGET_ARM\"\n   \"#\"\n-  \"TARGET_ARM && reload_completed\"\n+  \"TARGET_ARM && reload_completed && ! IS_IWMMXT_REGNUM (REGNO (operands[0]))\"\n   [(set (match_dup 0) (and:SI (not:SI (match_dup 1)) (match_dup 2)))\n    (set (match_dup 3) (and:SI (not:SI (match_dup 4)) (match_dup 5)))]\n   \"\n@@ -1926,7 +1944,7 @@\n   [(set (match_operand:DI         0 \"s_register_operand\" \"=&r,&r\")\n \t(ior:DI (match_operand:DI 1 \"s_register_operand\"  \"%0,r\")\n \t\t(match_operand:DI 2 \"s_register_operand\"   \"r,r\")))]\n-  \"TARGET_ARM\"\n+  \"TARGET_ARM && ! TARGET_IWMMXT\"\n   \"#\"\n   [(set_attr \"length\" \"8\")\n    (set_attr \"predicable\" \"yes\")]\n@@ -2048,7 +2066,7 @@\n   [(set (match_operand:DI         0 \"s_register_operand\" \"=&r,&r\")\n \t(xor:DI (match_operand:DI 1 \"s_register_operand\"  \"%0,r\")\n \t\t(match_operand:DI 2 \"s_register_operand\"   \"r,r\")))]\n-  \"TARGET_ARM\"\n+  \"TARGET_ARM && !TARGET_IWMMXT\"\n   \"#\"\n   [(set_attr \"length\" \"8\")\n    (set_attr \"predicable\" \"yes\")]\n@@ -2390,7 +2408,7 @@\n   [(set (match_operand:DI            0 \"s_register_operand\" \"\")\n \t(ashift:DI (match_operand:DI 1 \"general_operand\"    \"\")\n \t\t   (match_operand:SI 2 \"general_operand\"    \"\")))]\n-  \"TARGET_ARM && (TARGET_CIRRUS)\"\n+  \"TARGET_ARM && (TARGET_IWMMXT || TARGET_CIRRUS)\"\n   \"\n   if (! s_register_operand (operands[1], DImode))\n     operands[1] = copy_to_mode_reg (DImode, operands[1]);\n@@ -3588,7 +3606,7 @@\n (define_insn \"*arm_movdi\"\n   [(set (match_operand:DI 0 \"nonimmediate_di_operand\" \"=r, r, o<>\")\n \t(match_operand:DI 1 \"di_operand\"              \"rIK,mi,r\"))]\n-  \"TARGET_ARM && !TARGET_CIRRUS\"\n+  \"TARGET_ARM && !TARGET_CIRRUS && ! TARGET_IWMMXT\"\n   \"*\n   return (output_move_double (operands));\n   \"\n@@ -3687,7 +3705,7 @@\n (define_insn \"*arm_movsi_insn\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,r, m\")\n \t(match_operand:SI 1 \"general_operand\"      \"rI,K,mi,r\"))]\n-  \"TARGET_ARM\n+  \"TARGET_ARM && ! TARGET_IWMMXT\n    && (   register_operand (operands[0], SImode)\n        || register_operand (operands[1], SImode))\"\n   \"@\n@@ -4741,6 +4759,28 @@\n    (set_attr \"type\" \"*,load,store2,load,store2,*\")\n    (set_attr \"pool_range\" \"*,*,*,1020,*,*\")]\n )\n+\n+;; Vector Moves\n+(define_expand \"movv2si\"\n+  [(set (match_operand:V2SI 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand:V2SI 1 \"general_operand\" \"\"))]\n+  \"TARGET_REALLY_IWMMXT\"\n+{\n+})\n+\n+(define_expand \"movv4hi\"\n+  [(set (match_operand:V4HI 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand:V4HI 1 \"general_operand\" \"\"))]\n+  \"TARGET_REALLY_IWMMXT\"\n+{\n+})\n+\n+(define_expand \"movv8qi\"\n+  [(set (match_operand:V8QI 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand:V8QI 1 \"general_operand\" \"\"))]\n+  \"TARGET_REALLY_IWMMXT\"\n+{\n+})\n \f\n \n ;; load- and store-multiple insns\n@@ -6011,8 +6051,8 @@\n )\n \n (define_insn \"*call_value_reg\"\n-  [(set (match_operand 0 \"\" \"=r,f,v\")\n-        (call (mem:SI (match_operand:SI 1 \"s_register_operand\" \"r,r,r\"))\n+  [(set (match_operand 0 \"\" \"=ryfv\")\n+        (call (mem:SI (match_operand:SI 1 \"s_register_operand\" \"r\"))\n \t      (match_operand 2 \"\" \"\")))\n    (use (match_operand 3 \"\" \"\"))\n    (clobber (reg:SI LR_REGNUM))]\n@@ -6025,8 +6065,8 @@\n )\n \n (define_insn \"*call_value_mem\"\n-  [(set (match_operand 0 \"\" \"=r,f,v\")\n-\t(call (mem:SI (match_operand:SI 1 \"memory_operand\" \"m,m,m\"))\n+  [(set (match_operand 0 \"\" \"=ryfv\")\n+\t(call (mem:SI (match_operand:SI 1 \"memory_operand\" \"m\"))\n \t      (match_operand 2 \"\" \"\")))\n    (use (match_operand 3 \"\" \"\"))\n    (clobber (reg:SI LR_REGNUM))]\n@@ -6057,8 +6097,8 @@\n )\n \n (define_insn \"*call_value_symbol\"\n-  [(set (match_operand 0 \"s_register_operand\" \"=r,f,v\")\n-\t(call (mem:SI (match_operand:SI 1 \"\" \"X,X,X\"))\n+  [(set (match_operand 0 \"s_register_operand\" \"=ryfv\")\n+\t(call (mem:SI (match_operand:SI 1 \"\" \"X\"))\n \t(match_operand:SI 2 \"\" \"\")))\n    (use (match_operand 3 \"\" \"\"))\n    (clobber (reg:SI LR_REGNUM))]\n@@ -6140,8 +6180,8 @@\n )\n \n (define_insn \"*sibcall_value_insn\"\n- [(set (match_operand 0 \"s_register_operand\" \"=r,f,v\")\n-       (call (mem:SI (match_operand:SI 1 \"\" \"X,X,X\"))\n+ [(set (match_operand 0 \"s_register_operand\" \"=ryfv\")\n+       (call (mem:SI (match_operand:SI 1 \"\" \"X\"))\n \t     (match_operand 2 \"\" \"\")))\n   (return)\n   (use (match_operand 3 \"\" \"\"))]\n@@ -6166,6 +6206,7 @@\n     return output_return_instruction (const_true_rtx, TRUE, FALSE);\n   }\"\n   [(set_attr \"type\" \"load\")\n+   (set_attr \"length\" \"12\")\n    (set_attr \"predicable\" \"yes\")]\n )\n \n@@ -6186,6 +6227,7 @@\n     return output_return_instruction (operands[0], TRUE, FALSE);\n   }\"\n   [(set_attr \"conds\" \"use\")\n+   (set_attr \"length\" \"12\")\n    (set_attr \"type\" \"load\")]\n )\n \n@@ -8324,7 +8366,10 @@\n \t\t\t (match_dup 0)\n \t\t\t (match_operand 4 \"\" \"\")))\n    (clobber (reg:CC CC_REGNUM))]\n-  \"TARGET_ARM && reload_completed\"\n+  ;; Note we have to suppress this split for the iwmmxt because it\n+  ;; creates a conditional movsi and the iwmmxt_movsi_insn pattern\n+  ;; is not predicable.  This sucks.\n+  \"TARGET_ARM && reload_completed && ! TARGET_IWMMXT\"\n   [(set (match_dup 5) (match_dup 6))\n    (cond_exec (match_dup 7)\n \t      (set (match_dup 0) (match_dup 4)))]\n@@ -8352,7 +8397,10 @@\n \t\t\t (match_operand 4 \"\" \"\")\n \t\t\t (match_dup 0)))\n    (clobber (reg:CC CC_REGNUM))]\n-  \"TARGET_ARM && reload_completed\"\n+  ;; Note we have to suppress this split for the iwmmxt because it\n+  ;; creates a conditional movsi and the iwmmxt_movsi_insn pattern\n+  ;; is not predicable.  This sucks.\n+  \"TARGET_ARM && reload_completed && ! TARGET_IWMMXT\"\n   [(set (match_dup 5) (match_dup 6))\n    (cond_exec (match_op_dup 1 [(match_dup 5) (const_int 0)])\n \t      (set (match_dup 0) (match_dup 4)))]\n@@ -8373,7 +8421,10 @@\n \t\t\t (match_operand 4 \"\" \"\")\n \t\t\t (match_operand 5 \"\" \"\")))\n    (clobber (reg:CC CC_REGNUM))]\n-  \"TARGET_ARM && reload_completed\"\n+  ;; Note we have to suppress this split for the iwmmxt because it\n+  ;; creates a conditional movsi and the iwmmxt_movsi_insn pattern\n+  ;; is not predicable.  This sucks.\n+  \"TARGET_ARM && reload_completed && ! TARGET_IWMMXT\"\n   [(set (match_dup 6) (match_dup 7))\n    (cond_exec (match_op_dup 1 [(match_dup 6) (const_int 0)])\n \t      (set (match_dup 0) (match_dup 4)))\n@@ -8405,7 +8456,10 @@\n \t\t\t (not:SI\n \t\t\t  (match_operand:SI 5 \"s_register_operand\" \"\"))))\n    (clobber (reg:CC CC_REGNUM))]\n-  \"TARGET_ARM && reload_completed\"\n+  ;; Note we have to suppress this split for the iwmmxt because it\n+  ;; creates a conditional movsi and the iwmmxt_movsi_insn pattern\n+  ;; is not predicable.  This sucks.\n+  \"TARGET_ARM && reload_completed && ! TARGET_IWMMXT\"\n   [(set (match_dup 6) (match_dup 7))\n    (cond_exec (match_op_dup 1 [(match_dup 6) (const_int 0)])\n \t      (set (match_dup 0) (match_dup 4)))\n@@ -8559,6 +8613,15 @@\n   \"\n )\n \n+(define_insn \"align_8\"\n+  [(unspec_volatile [(const_int 0)] VUNSPEC_ALIGN8)]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"*\n+  assemble_align (64);\n+  return \\\"\\\";\n+  \"\n+)\n+\n (define_insn \"consttable_end\"\n   [(unspec_volatile [(const_int 0)] VUNSPEC_POOL_END)]\n   \"TARGET_EITHER\"\n@@ -8745,3 +8808,5 @@\n (include \"fpa.md\")\n ;; Load the Maverick co-processor patterns\n (include \"cirrus.md\")\n+;; Load the Intel Wireless Multimedia Extension patterns\n+(include \"iwmmxt.md\")"}, {"sha": "5f3fd7bf17f4400c184d3c71bad052e90ade960f", "filename": "gcc/config/arm/iwmmxt.md", "status": "added", "additions": 1495, "deletions": 0, "changes": 1495, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a9335ef017c45e09d9493b982a25a8e58b51d40/gcc%2Fconfig%2Farm%2Fiwmmxt.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a9335ef017c45e09d9493b982a25a8e58b51d40/gcc%2Fconfig%2Farm%2Fiwmmxt.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fiwmmxt.md?ref=5a9335ef017c45e09d9493b982a25a8e58b51d40", "patch": "@@ -0,0 +1,1495 @@\n+;; Patterns for the Intel Wireless MMX technology architecture.\n+;; Copyright (C) 2003 Free Software Foundation, Inc.\n+;; Contributed by Red Hat.\n+\n+;; This file is part of GCC.\n+\n+;; GCC is free software; you can redistribute it and/or modify it under\n+;; the terms of the GNU General Public License as published by the Free\n+;; Software Foundation; either version 2, or (at your option) any later\n+;; version.\n+\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT\n+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+;; License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 59 Temple Place - Suite 330,\n+;; Boston, MA 02111-1307, USA.\n+\n+(define_insn \"iwmmxt_iordi3\"\n+  [(set (match_operand:DI         0 \"register_operand\" \"=y,?&r,?&r\")\n+        (ior:DI (match_operand:DI 1 \"register_operand\" \"%y,0,r\")\n+\t\t(match_operand:DI 2 \"register_operand\"  \"y,r,r\")))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"@\n+   wor%?\\\\t%0, %1, %2\n+   #\n+   #\"\n+  [(set_attr \"predicable\" \"yes\")\n+   (set_attr \"length\" \"4,8,8\")])\n+\n+(define_insn \"iwmmxt_xordi3\"\n+  [(set (match_operand:DI         0 \"register_operand\" \"=y,?&r,?&r\")\n+        (xor:DI (match_operand:DI 1 \"register_operand\" \"%y,0,r\")\n+\t\t(match_operand:DI 2 \"register_operand\"  \"y,r,r\")))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"@\n+   wxor%?\\\\t%0, %1, %2\n+   #\n+   #\"\n+  [(set_attr \"predicable\" \"yes\")\n+   (set_attr \"length\" \"4,8,8\")])\n+\n+(define_insn \"iwmmxt_anddi3\"\n+  [(set (match_operand:DI         0 \"register_operand\" \"=y,?&r,?&r\")\n+        (and:DI (match_operand:DI 1 \"register_operand\" \"%y,0,r\")\n+\t\t(match_operand:DI 2 \"register_operand\"  \"y,r,r\")))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"@\n+   wand%?\\\\t%0, %1, %2\n+   #\n+   #\"\n+  [(set_attr \"predicable\" \"yes\")\n+   (set_attr \"length\" \"4,8,8\")])\n+\n+(define_insn \"iwmmxt_nanddi3\"\n+  [(set (match_operand:DI                 0 \"register_operand\" \"=y\")\n+        (and:DI (match_operand:DI         1 \"register_operand\"  \"y\")\n+\t\t(not:DI (match_operand:DI 2 \"register_operand\"  \"y\"))))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wandn%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"*iwmmxt_arm_movdi\"\n+  [(set (match_operand:DI 0 \"nonimmediate_di_operand\" \"=r, r, o<>,y,y,yr,y,yrm\")\n+\t(match_operand:DI 1 \"di_operand\"              \"rIK,mi,r  ,y,yr,y,yrm,y\"))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    default:\n+      return output_move_double (operands);\n+    case 3:\n+      return \\\"wmov%?\\\\t%0,%1\\\";\n+    case 4:\n+      return \\\"tmcrr%?\\\\t%0,%Q1,%R1\\\";\n+    case 5:\n+      return \\\"tmrrc%?\\\\t%Q0,%R0,%1\\\";\n+    case 6:\n+      return \\\"wldrd%?\\\\t%0,%1\\\";\n+    case 7:\n+      return \\\"wstrd%?\\\\t%1,%0\\\";\n+    }\n+}\"\n+  [(set_attr \"length\"         \"8,8,8,4,4,4,4,4\")\n+   (set_attr \"type\"           \"*,load,store2,*,*,*,*,*\")\n+   (set_attr \"pool_range\"     \"*,1020,*,*,*,*,*,*\")\n+   (set_attr \"neg_pool_range\" \"*,1012,*,*,*,*,*,*\")]\n+)\n+\n+(define_insn \"*iwmmxt_movsi_insn\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,r, m,z,r,?z,m,z\")\n+\t(match_operand:SI 1 \"general_operand\"      \"rI,K,mi,r,r,z,m,z,z\"))]\n+  \"TARGET_REALLY_IWMMXT\n+   && (   register_operand (operands[0], SImode)\n+       || register_operand (operands[1], SImode))\"\n+  \"*\n+   switch (which_alternative)\n+   {\n+   case 0: return \\\"mov\\\\t%0, %1\\\";\n+   case 1: return \\\"mvn\\\\t%0, #%B1\\\";\n+   case 2: return \\\"ldr\\\\t%0, %1\\\";\n+   case 3: return \\\"str\\\\t%1, %0\\\";\n+   case 4: return \\\"tmcr\\\\t%0, %1\\\";\n+   case 5: return \\\"tmrc\\\\t%0, %1\\\";\n+   case 6: return arm_output_load_gr (operands);\n+   case 7: return \\\"wstrw\\\\t%1, %0\\\";\n+   default:return \\\"wstrw\\\\t%1, [sp, #-4]!\\;wldrw\\\\t%0, [sp], #4\\\\t@move CG reg\\\";\n+  }\"\n+  [(set_attr \"type\"           \"*,*,load,store1,*,*,load,store1,*\")\n+   (set_attr \"length\"         \"*,*,*,        *,*,*,  16,     *,8\")\n+   (set_attr \"pool_range\"     \"*,*,4096,     *,*,*,1024,     *,*\")\n+   (set_attr \"neg_pool_range\" \"*,*,4084,     *,*,*,   *,  1012,*\")\n+   ;; Note - the \"predicable\" attribute is not allowed to have alternatives.\n+   ;; Since the wSTRw wCx instruction is not predicable, we cannot support\n+   ;; predicating any of the alternatives in this template.  This sucks.\n+   (set_attr \"predicable\"     \"no\")\n+   ;; Also - we have to pretend that these insns clobber the condition code\n+   ;; bits as otherwise arm_final_prescan_insn() will try to conditionalize\n+   ;; them.\n+   (set_attr \"conds\" \"clob\")]\n+)\n+\n+(define_insn \"movv8qi_internal\"\n+  [(set (match_operand:V8QI 0 \"nonimmediate_operand\" \"=y,m,y,?r,?y,?r\")\n+\t(match_operand:V8QI 1 \"general_operand\"       \"y,y,m,y,r,i\"))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"*\n+   switch (which_alternative)\n+   {\n+   case 0: return \\\"wmov%?\\\\t%0, %1\\\";\n+   case 1: return \\\"wstrd%?\\\\t%1, %0\\\";\n+   case 2: return \\\"wldrd%?\\\\t%0, %1\\\";\n+   case 3: return \\\"tmrrc%?\\\\t%Q0, %R0, %1\\\";\n+   case 4: return \\\"tmcrr%?\\\\t%0, %Q1, %R1\\\";\n+   default: return output_move_double (operands);\n+   }\"\n+  [(set_attr \"predicable\" \"yes\")\n+   (set_attr \"length\"         \"4,     4,   4,4,4,   8\")\n+   (set_attr \"type\"           \"*,store1,load,*,*,load\")\n+   (set_attr \"pool_range\"     \"*,     *, 256,*,*, 256\")\n+   (set_attr \"neg_pool_range\" \"*,     *, 244,*,*, 244\")])\n+\n+(define_insn \"movv4hi_internal\"\n+  [(set (match_operand:V4HI 0 \"nonimmediate_operand\" \"=y,m,y,?r,?y,?r\")\n+\t(match_operand:V4HI 1 \"general_operand\"       \"y,y,m,y,r,i\"))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"*\n+   switch (which_alternative)\n+   {\n+   case 0: return \\\"wmov%?\\\\t%0, %1\\\";\n+   case 1: return \\\"wstrd%?\\\\t%1, %0\\\";\n+   case 2: return \\\"wldrd%?\\\\t%0, %1\\\";\n+   case 3: return \\\"tmrrc%?\\\\t%Q0, %R0, %1\\\";\n+   case 4: return \\\"tmcrr%?\\\\t%0, %Q1, %R1\\\";\n+   default: return output_move_double (operands);\n+   }\"\n+  [(set_attr \"predicable\" \"yes\")\n+   (set_attr \"length\"         \"4,     4,   4,4,4,   8\")\n+   (set_attr \"type\"           \"*,store1,load,*,*,load\")\n+   (set_attr \"pool_range\"     \"*,     *, 256,*,*, 256\")\n+   (set_attr \"neg_pool_range\" \"*,     *, 244,*,*, 244\")])\n+\n+(define_insn \"movv2si_internal\"\n+  [(set (match_operand:V2SI 0 \"nonimmediate_operand\" \"=y,m,y,?r,?y,?r\")\n+\t(match_operand:V2SI 1 \"general_operand\"       \"y,y,m,y,r,i\"))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"*\n+   switch (which_alternative)\n+   {\n+   case 0: return \\\"wmov%?\\\\t%0, %1\\\";\n+   case 1: return \\\"wstrd%?\\\\t%1, %0\\\";\n+   case 2: return \\\"wldrd%?\\\\t%0, %1\\\";\n+   case 3: return \\\"tmrrc%?\\\\t%Q0, %R0, %1\\\";\n+   case 4: return \\\"tmcrr%?\\\\t%0, %Q1, %R1\\\";\n+   default: return output_move_double (operands);\n+   }\"\n+  [(set_attr \"predicable\" \"yes\")\n+   (set_attr \"length\"         \"4,     4,   4,4,4,  24\")\n+   (set_attr \"type\"           \"*,store1,load,*,*,load\")\n+   (set_attr \"pool_range\"     \"*,     *, 256,*,*, 256\")\n+   (set_attr \"neg_pool_range\" \"*,     *, 244,*,*, 244\")])\n+\n+;; This pattern should not be needed.  It is to match a\n+;; wierd case generated by GCC when no optimisations are\n+;; enabled.  (Try compiling gcc/testsuite/gcc.c-torture/\n+;; compile/simd-5.c at -O0).  The mode for operands[1] is\n+;; deliberately omitted.\n+(define_insn \"movv2si_internal_2\"\n+  [(set (match_operand:V2SI 0 \"nonimmediate_operand\" \"=?r\")\n+\t(match_operand      1 \"immediate_operand\"      \"i\"))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"* return output_move_double (operands);\"\n+  [(set_attr \"predicable\"     \"yes\")\n+   (set_attr \"length\"         \"8\")\n+   (set_attr \"type\"           \"load\")\n+   (set_attr \"pool_range\"     \"256\")\n+   (set_attr \"neg_pool_range\" \"244\")])\n+\n+;; Vector add/subtract\n+\n+(define_insn \"addv8qi3\"\n+  [(set (match_operand:V8QI            0 \"register_operand\" \"=y\")\n+        (plus:V8QI (match_operand:V8QI 1 \"register_operand\"  \"y\")\n+\t           (match_operand:V8QI 2 \"register_operand\"  \"y\")))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"waddb%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"addv4hi3\"\n+  [(set (match_operand:V4HI            0 \"register_operand\" \"=y\")\n+        (plus:V4HI (match_operand:V4HI 1 \"register_operand\"  \"y\")\n+\t           (match_operand:V4HI 2 \"register_operand\"  \"y\")))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"waddh%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"addv2si3\"\n+  [(set (match_operand:V2SI            0 \"register_operand\" \"=y\")\n+        (plus:V2SI (match_operand:V2SI 1 \"register_operand\"  \"y\")\n+\t           (match_operand:V2SI 2 \"register_operand\"  \"y\")))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"waddw%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"ssaddv8qi3\"\n+  [(set (match_operand:V8QI               0 \"register_operand\" \"=y\")\n+        (ss_plus:V8QI (match_operand:V8QI 1 \"register_operand\"  \"y\")\n+\t\t      (match_operand:V8QI 2 \"register_operand\"  \"y\")))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"waddbss%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"ssaddv4hi3\"\n+  [(set (match_operand:V4HI               0 \"register_operand\" \"=y\")\n+        (ss_plus:V4HI (match_operand:V4HI 1 \"register_operand\"  \"y\")\n+\t\t      (match_operand:V4HI 2 \"register_operand\"  \"y\")))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"waddhss%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"ssaddv2si3\"\n+  [(set (match_operand:V2SI               0 \"register_operand\" \"=y\")\n+        (ss_plus:V2SI (match_operand:V2SI 1 \"register_operand\"  \"y\")\n+\t\t      (match_operand:V2SI 2 \"register_operand\"  \"y\")))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"waddwss%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"usaddv8qi3\"\n+  [(set (match_operand:V8QI               0 \"register_operand\" \"=y\")\n+        (us_plus:V8QI (match_operand:V8QI 1 \"register_operand\"  \"y\")\n+\t\t      (match_operand:V8QI 2 \"register_operand\"  \"y\")))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"waddbus%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"usaddv4hi3\"\n+  [(set (match_operand:V4HI               0 \"register_operand\" \"=y\")\n+        (us_plus:V4HI (match_operand:V4HI 1 \"register_operand\"  \"y\")\n+\t\t      (match_operand:V4HI 2 \"register_operand\"  \"y\")))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"waddhus%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"usaddv2si3\"\n+  [(set (match_operand:V2SI               0 \"register_operand\" \"=y\")\n+        (us_plus:V2SI (match_operand:V2SI 1 \"register_operand\"  \"y\")\n+\t\t      (match_operand:V2SI 2 \"register_operand\"  \"y\")))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"waddwus%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"subv8qi3\"\n+  [(set (match_operand:V8QI             0 \"register_operand\" \"=y\")\n+        (minus:V8QI (match_operand:V8QI 1 \"register_operand\"  \"y\")\n+\t\t    (match_operand:V8QI 2 \"register_operand\"  \"y\")))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wsubb%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"subv4hi3\"\n+  [(set (match_operand:V4HI             0 \"register_operand\" \"=y\")\n+        (minus:V4HI (match_operand:V4HI 1 \"register_operand\"  \"y\")\n+\t\t    (match_operand:V4HI 2 \"register_operand\"  \"y\")))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wsubh%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"subv2si3\"\n+  [(set (match_operand:V2SI             0 \"register_operand\" \"=y\")\n+        (minus:V2SI (match_operand:V2SI 1 \"register_operand\"  \"y\")\n+\t\t    (match_operand:V2SI 2 \"register_operand\"  \"y\")))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wsubw%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"sssubv8qi3\"\n+  [(set (match_operand:V8QI                0 \"register_operand\" \"=y\")\n+        (ss_minus:V8QI (match_operand:V8QI 1 \"register_operand\"  \"y\")\n+\t\t       (match_operand:V8QI 2 \"register_operand\"  \"y\")))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wsubbss%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"sssubv4hi3\"\n+  [(set (match_operand:V4HI                0 \"register_operand\" \"=y\")\n+        (ss_minus:V4HI (match_operand:V4HI 1 \"register_operand\" \"y\")\n+\t\t       (match_operand:V4HI 2 \"register_operand\" \"y\")))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wsubhss%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"sssubv2si3\"\n+  [(set (match_operand:V2SI                0 \"register_operand\" \"=y\")\n+        (ss_minus:V2SI (match_operand:V2SI 1 \"register_operand\" \"y\")\n+\t\t       (match_operand:V2SI 2 \"register_operand\" \"y\")))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wsubwss%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"ussubv8qi3\"\n+  [(set (match_operand:V8QI                0 \"register_operand\" \"=y\")\n+        (us_minus:V8QI (match_operand:V8QI 1 \"register_operand\" \"y\")\n+\t\t       (match_operand:V8QI 2 \"register_operand\" \"y\")))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wsubbus%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"ussubv4hi3\"\n+  [(set (match_operand:V4HI                0 \"register_operand\" \"=y\")\n+        (us_minus:V4HI (match_operand:V4HI 1 \"register_operand\" \"y\")\n+\t\t       (match_operand:V4HI 2 \"register_operand\" \"y\")))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wsubhus%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"ussubv2si3\"\n+  [(set (match_operand:V2SI                0 \"register_operand\" \"=y\")\n+        (us_minus:V2SI (match_operand:V2SI 1 \"register_operand\" \"y\")\n+\t\t       (match_operand:V2SI 2 \"register_operand\" \"y\")))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wsubwus%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"mulv4hi3\"\n+  [(set (match_operand:V4HI            0 \"register_operand\" \"=y\")\n+        (mult:V4HI (match_operand:V4HI 1 \"register_operand\" \"y\")\n+\t\t   (match_operand:V4HI 2 \"register_operand\" \"y\")))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wmulul%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"smulv4hi3_highpart\"\n+  [(set (match_operand:V4HI                                0 \"register_operand\" \"=y\")\n+\t(truncate:V4HI\n+\t (lshiftrt:V4SI\n+\t  (mult:V4SI (sign_extend:V4SI (match_operand:V4HI 1 \"register_operand\" \"y\"))\n+\t\t     (sign_extend:V4SI (match_operand:V4HI 2 \"register_operand\" \"y\")))\n+\t  (const_int 16))))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wmulsm%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"umulv4hi3_highpart\"\n+  [(set (match_operand:V4HI                                0 \"register_operand\" \"=y\")\n+\t(truncate:V4HI\n+\t (lshiftrt:V4SI\n+\t  (mult:V4SI (zero_extend:V4SI (match_operand:V4HI 1 \"register_operand\" \"y\"))\n+\t\t     (zero_extend:V4SI (match_operand:V4HI 2 \"register_operand\" \"y\")))\n+\t  (const_int 16))))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wmulum%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"iwmmxt_wmacs\"\n+  [(set (match_operand:DI               0 \"register_operand\" \"=y\")\n+\t(unspec:DI [(match_operand:DI   1 \"register_operand\" \"0\")\n+\t\t    (match_operand:V4HI 2 \"register_operand\" \"y\")\n+\t\t    (match_operand:V4HI 3 \"register_operand\" \"y\")] UNSPEC_WMACS))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wmacs%?\\\\t%0, %2, %3\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"iwmmxt_wmacsz\"\n+  [(set (match_operand:DI               0 \"register_operand\" \"=y\")\n+\t(unspec:DI [(match_operand:V4HI 1 \"register_operand\" \"y\")\n+\t\t    (match_operand:V4HI 2 \"register_operand\" \"y\")] UNSPEC_WMACSZ))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wmacsz%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"iwmmxt_wmacu\"\n+  [(set (match_operand:DI               0 \"register_operand\" \"=y\")\n+\t(unspec:DI [(match_operand:DI   1 \"register_operand\" \"0\")\n+\t\t    (match_operand:V4HI 2 \"register_operand\" \"y\")\n+\t\t    (match_operand:V4HI 3 \"register_operand\" \"y\")] UNSPEC_WMACU))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wmacu%?\\\\t%0, %2, %3\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"iwmmxt_wmacuz\"\n+  [(set (match_operand:DI               0 \"register_operand\" \"=y\")\n+\t(unspec:DI [(match_operand:V4HI 1 \"register_operand\" \"y\")\n+\t\t    (match_operand:V4HI 2 \"register_operand\" \"y\")] UNSPEC_WMACUZ))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wmacuz%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+;; Same as xordi3, but don't show input operands so that we don't think\n+;; they are live.\n+(define_insn \"iwmmxt_clrdi\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=y\")\n+        (unspec:DI [(const_int 0)] UNSPEC_CLRDI))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wxor%?\\\\t%0, %0, %0\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+;; Seems like cse likes to generate these, so we have to support them.\n+\n+(define_insn \"*iwmmxt_clrv8qi\"\n+  [(set (match_operand:V8QI 0 \"register_operand\" \"=y\")\n+        (const_vector:V8QI [(const_int 0) (const_int 0)\n+\t\t\t    (const_int 0) (const_int 0)\n+\t\t\t    (const_int 0) (const_int 0)\n+\t\t\t    (const_int 0) (const_int 0)]))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wxor%?\\\\t%0, %0, %0\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"*iwmmxt_clrv4hi\"\n+  [(set (match_operand:V4HI 0 \"register_operand\" \"=y\")\n+        (const_vector:V4HI [(const_int 0) (const_int 0)\n+\t\t\t    (const_int 0) (const_int 0)]))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wxor%?\\\\t%0, %0, %0\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"*iwmmxt_clrv2si\"\n+  [(set (match_operand:V2SI 0 \"register_operand\" \"=y\")\n+        (const_vector:V2SI [(const_int 0) (const_int 0)]))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wxor%?\\\\t%0, %0, %0\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+;; Unsigned averages/sum of absolute differences\n+\n+(define_insn \"iwmmxt_uavgrndv8qi3\"\n+  [(set (match_operand:V8QI              0 \"register_operand\" \"=y\")\n+        (ashiftrt:V8QI\n+\t (plus:V8QI (plus:V8QI\n+\t\t     (match_operand:V8QI 1 \"register_operand\" \"y\")\n+\t\t     (match_operand:V8QI 2 \"register_operand\" \"y\"))\n+\t\t    (const_vector:V8QI [(const_int 1)\n+\t\t\t\t\t(const_int 1)\n+\t\t\t\t\t(const_int 1)\n+\t\t\t\t\t(const_int 1)\n+\t\t\t\t\t(const_int 1)\n+\t\t\t\t\t(const_int 1)\n+\t\t\t\t\t(const_int 1)\n+\t\t\t\t\t(const_int 1)]))\n+\t (const_int 1)))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wavg2br%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"iwmmxt_uavgrndv4hi3\"\n+  [(set (match_operand:V4HI              0 \"register_operand\" \"=y\")\n+        (ashiftrt:V4HI\n+\t (plus:V4HI (plus:V4HI\n+\t\t     (match_operand:V4HI 1 \"register_operand\" \"y\")\n+\t\t     (match_operand:V4HI 2 \"register_operand\" \"y\"))\n+\t\t    (const_vector:V4HI [(const_int 1)\n+\t\t\t\t\t(const_int 1)\n+\t\t\t\t\t(const_int 1)\n+\t\t\t\t\t(const_int 1)]))\n+\t (const_int 1)))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wavg2hr%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+\n+(define_insn \"iwmmxt_uavgv8qi3\"\n+  [(set (match_operand:V8QI                 0 \"register_operand\" \"=y\")\n+        (ashiftrt:V8QI (plus:V8QI\n+\t\t\t(match_operand:V8QI 1 \"register_operand\" \"y\")\n+\t\t\t(match_operand:V8QI 2 \"register_operand\" \"y\"))\n+\t\t       (const_int 1)))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wavg2b%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"iwmmxt_uavgv4hi3\"\n+  [(set (match_operand:V4HI                 0 \"register_operand\" \"=y\")\n+        (ashiftrt:V4HI (plus:V4HI\n+\t\t\t(match_operand:V4HI 1 \"register_operand\" \"y\")\n+\t\t\t(match_operand:V4HI 2 \"register_operand\" \"y\"))\n+\t\t       (const_int 1)))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wavg2h%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"iwmmxt_psadbw\"\n+  [(set (match_operand:V8QI                       0 \"register_operand\" \"=y\")\n+        (abs:V8QI (minus:V8QI (match_operand:V8QI 1 \"register_operand\" \"y\")\n+\t\t\t      (match_operand:V8QI 2 \"register_operand\" \"y\"))))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"psadbw%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+\n+;; Insert/extract/shuffle\n+\n+(define_insn \"iwmmxt_tinsrb\"\n+  [(set (match_operand:V8QI                             0 \"register_operand\"    \"=y\")\n+        (vec_merge:V8QI (match_operand:V8QI             1 \"register_operand\"     \"0\")\n+\t\t\t(vec_duplicate:V8QI\n+\t\t\t (truncate:QI (match_operand:SI 2 \"nonimmediate_operand\" \"r\")))\n+\t\t\t(match_operand:SI               3 \"immediate_operand\"    \"i\")))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"tinsrb%?\\\\t%0, %2, %3\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"iwmmxt_tinsrh\"\n+  [(set (match_operand:V4HI                             0 \"register_operand\"    \"=y\")\n+        (vec_merge:V4HI (match_operand:V4HI             1 \"register_operand\"     \"0\")\n+\t\t\t(vec_duplicate:V4HI\n+\t\t\t (truncate:HI (match_operand:SI 2 \"nonimmediate_operand\" \"r\")))\n+\t\t\t(match_operand:SI               3 \"immediate_operand\"    \"i\")))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"tinsrh%?\\\\t%0, %2, %3\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"iwmmxt_tinsrw\"\n+  [(set (match_operand:V2SI                 0 \"register_operand\"    \"=y\")\n+        (vec_merge:V2SI (match_operand:V2SI 1 \"register_operand\"     \"0\")\n+\t\t\t(vec_duplicate:V2SI\n+\t\t\t (match_operand:SI  2 \"nonimmediate_operand\" \"r\"))\n+\t\t\t(match_operand:SI   3 \"immediate_operand\"    \"i\")))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"tinsrw%?\\\\t%0, %2, %3\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"iwmmxt_textrmub\"\n+  [(set (match_operand:SI                                  0 \"register_operand\" \"=r\")\n+        (zero_extend:SI (vec_select:QI (match_operand:V8QI 1 \"register_operand\" \"y\")\n+\t\t\t\t       (parallel\n+\t\t\t\t\t[(match_operand:SI 2 \"immediate_operand\" \"i\")]))))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"textrmub%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"iwmmxt_textrmsb\"\n+  [(set (match_operand:SI                                  0 \"register_operand\" \"=r\")\n+        (sign_extend:SI (vec_select:QI (match_operand:V8QI 1 \"register_operand\" \"y\")\n+\t\t\t\t       (parallel\n+\t\t\t\t\t[(match_operand:SI 2 \"immediate_operand\" \"i\")]))))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"textrmsb%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"iwmmxt_textrmuh\"\n+  [(set (match_operand:SI                                  0 \"register_operand\" \"=r\")\n+        (zero_extend:SI (vec_select:HI (match_operand:V4HI 1 \"register_operand\" \"y\")\n+\t\t\t\t       (parallel\n+\t\t\t\t\t[(match_operand:SI 2 \"immediate_operand\" \"i\")]))))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"textrmuh%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"iwmmxt_textrmsh\"\n+  [(set (match_operand:SI                                  0 \"register_operand\" \"=r\")\n+        (sign_extend:SI (vec_select:HI (match_operand:V4HI 1 \"register_operand\" \"y\")\n+\t\t\t\t       (parallel\n+\t\t\t\t\t[(match_operand:SI 2 \"immediate_operand\" \"i\")]))))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"textrmsh%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+;; There are signed/unsigned variants of this instruction, but they are\n+;; pointless.\n+(define_insn \"iwmmxt_textrmw\"\n+  [(set (match_operand:SI                           0 \"register_operand\" \"=r\")\n+        (vec_select:SI (match_operand:V2SI          1 \"register_operand\" \"y\")\n+\t\t       (parallel [(match_operand:SI 2 \"immediate_operand\" \"i\")])))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"textrmsw%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"iwmmxt_wshufh\"\n+  [(set (match_operand:V4HI               0 \"register_operand\" \"=y\")\n+        (unspec:V4HI [(match_operand:V4HI 1 \"register_operand\" \"y\")\n+\t\t      (match_operand:SI   2 \"immediate_operand\" \"i\")] UNSPEC_WSHUFH))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wshufh%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+;; Mask-generating comparisons\n+;;\n+;; Note - you cannot use patterns like these here:\n+;;\n+;;   (set:<vector> (match:<vector>) (<comparator>:<vector> (match:<vector>) (match:<vector>)))\n+;;\n+;; Because GCC will assume that the truth value (1 or 0) is installed\n+;; into the entire destination vector, (with the '1' going into the least\n+;; significant element of the vector).  This is not how these instructions\n+;; behave.\n+;;\n+;; Unfortunately the current patterns are illegal.  They are SET insns\n+;; without a SET in them.  They work in most cases for ordinary code\n+;; generation, but there are circumstances where they can cause gcc to fail.\n+;; XXX - FIXME.\n+\n+(define_insn \"eqv8qi3\"\n+  [(unspec_volatile [(match_operand:V8QI 0 \"register_operand\" \"=y\")\n+\t\t     (match_operand:V8QI 1 \"register_operand\"  \"y\")\n+\t\t     (match_operand:V8QI 2 \"register_operand\"  \"y\")]\n+\t\t    VUNSPEC_WCMP_EQ)]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wcmpeqb%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"eqv4hi3\"\n+  [(unspec_volatile [(match_operand:V4HI 0 \"register_operand\" \"=y\")\n+\t\t     (match_operand:V4HI 1 \"register_operand\"  \"y\")\n+\t\t     (match_operand:V4HI 2 \"register_operand\"  \"y\")]\n+\t\t    VUNSPEC_WCMP_EQ)]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wcmpeqh%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"eqv2si3\"\n+  [(unspec_volatile:V2SI [(match_operand:V2SI 0 \"register_operand\" \"=y\")\n+\t\t\t  (match_operand:V2SI 1 \"register_operand\"  \"y\")\n+\t\t\t  (match_operand:V2SI 2 \"register_operand\"  \"y\")]\n+\t\t\t VUNSPEC_WCMP_EQ)]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wcmpeqw%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"gtuv8qi3\"\n+  [(unspec_volatile [(match_operand:V8QI 0 \"register_operand\" \"=y\")\n+\t\t     (match_operand:V8QI 1 \"register_operand\"  \"y\")\n+\t\t     (match_operand:V8QI 2 \"register_operand\"  \"y\")]\n+\t\t    VUNSPEC_WCMP_GTU)]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wcmpgtub%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"gtuv4hi3\"\n+  [(unspec_volatile [(match_operand:V4HI 0 \"register_operand\" \"=y\")\n+\t\t     (match_operand:V4HI 1 \"register_operand\"  \"y\")\n+\t\t     (match_operand:V4HI 2 \"register_operand\"  \"y\")]\n+\t\t    VUNSPEC_WCMP_GTU)]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wcmpgtuh%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"gtuv2si3\"\n+  [(unspec_volatile [(match_operand:V2SI 0 \"register_operand\" \"=y\")\n+\t\t     (match_operand:V2SI 1 \"register_operand\"  \"y\")\n+\t\t     (match_operand:V2SI 2 \"register_operand\"  \"y\")]\n+\t\t    VUNSPEC_WCMP_GTU)]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wcmpgtuw%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"gtv8qi3\"\n+  [(unspec_volatile [(match_operand:V8QI 0 \"register_operand\" \"=y\")\n+\t\t     (match_operand:V8QI 1 \"register_operand\"  \"y\")\n+\t\t     (match_operand:V8QI 2 \"register_operand\"  \"y\")]\n+\t\t    VUNSPEC_WCMP_GT)]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wcmpgtsb%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"gtv4hi3\"\n+  [(unspec_volatile [(match_operand:V4HI 0 \"register_operand\" \"=y\")\n+\t\t     (match_operand:V4HI 1 \"register_operand\"  \"y\")\n+\t\t     (match_operand:V4HI 2 \"register_operand\"  \"y\")]\n+\t\t    VUNSPEC_WCMP_GT)]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wcmpgtsh%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"gtv2si3\"\n+  [(unspec_volatile [(match_operand:V2SI 0 \"register_operand\" \"=y\")\n+\t\t     (match_operand:V2SI 1 \"register_operand\"  \"y\")\n+\t\t     (match_operand:V2SI 2 \"register_operand\"  \"y\")]\n+\t\t    VUNSPEC_WCMP_GT)]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wcmpgtsw%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+;; Max/min insns\n+\n+(define_insn \"smaxv8qi3\"\n+  [(set (match_operand:V8QI            0 \"register_operand\" \"=y\")\n+        (smax:V8QI (match_operand:V8QI 1 \"register_operand\" \"y\")\n+\t\t   (match_operand:V8QI 2 \"register_operand\" \"y\")))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wmaxsb%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"umaxv8qi3\"\n+  [(set (match_operand:V8QI            0 \"register_operand\" \"=y\")\n+        (umax:V8QI (match_operand:V8QI 1 \"register_operand\" \"y\")\n+\t\t   (match_operand:V8QI 2 \"register_operand\" \"y\")))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wmaxub%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"smaxv4hi3\"\n+  [(set (match_operand:V4HI            0 \"register_operand\" \"=y\")\n+        (smax:V4HI (match_operand:V4HI 1 \"register_operand\" \"y\")\n+\t\t   (match_operand:V4HI 2 \"register_operand\" \"y\")))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wmaxsh%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"umaxv4hi3\"\n+  [(set (match_operand:V4HI            0 \"register_operand\" \"=y\")\n+        (umax:V4HI (match_operand:V4HI 1 \"register_operand\" \"y\")\n+\t\t   (match_operand:V4HI 2 \"register_operand\" \"y\")))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wmaxuh%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"smaxv2si3\"\n+  [(set (match_operand:V2SI            0 \"register_operand\" \"=y\")\n+        (smax:V2SI (match_operand:V2SI 1 \"register_operand\" \"y\")\n+\t\t   (match_operand:V2SI 2 \"register_operand\" \"y\")))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wmaxsw%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"umaxv2si3\"\n+  [(set (match_operand:V2SI            0 \"register_operand\" \"=y\")\n+        (umax:V2SI (match_operand:V2SI 1 \"register_operand\" \"y\")\n+\t\t   (match_operand:V2SI 2 \"register_operand\" \"y\")))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wmaxuw%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"sminv8qi3\"\n+  [(set (match_operand:V8QI            0 \"register_operand\" \"=y\")\n+        (smin:V8QI (match_operand:V8QI 1 \"register_operand\" \"y\")\n+\t\t   (match_operand:V8QI 2 \"register_operand\" \"y\")))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wminsb%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"uminv8qi3\"\n+  [(set (match_operand:V8QI            0 \"register_operand\" \"=y\")\n+        (umin:V8QI (match_operand:V8QI 1 \"register_operand\" \"y\")\n+\t\t   (match_operand:V8QI 2 \"register_operand\" \"y\")))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wminub%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"sminv4hi3\"\n+  [(set (match_operand:V4HI            0 \"register_operand\" \"=y\")\n+        (smin:V4HI (match_operand:V4HI 1 \"register_operand\" \"y\")\n+\t\t   (match_operand:V4HI 2 \"register_operand\" \"y\")))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wminsh%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"uminv4hi3\"\n+  [(set (match_operand:V4HI            0 \"register_operand\" \"=y\")\n+        (umin:V4HI (match_operand:V4HI 1 \"register_operand\" \"y\")\n+\t\t   (match_operand:V4HI 2 \"register_operand\" \"y\")))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wminuh%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"sminv2si3\"\n+  [(set (match_operand:V2SI            0 \"register_operand\" \"=y\")\n+        (smin:V2SI (match_operand:V2SI 1 \"register_operand\" \"y\")\n+\t\t   (match_operand:V2SI 2 \"register_operand\" \"y\")))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wminsw%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"uminv2si3\"\n+  [(set (match_operand:V2SI            0 \"register_operand\" \"=y\")\n+        (umin:V2SI (match_operand:V2SI 1 \"register_operand\" \"y\")\n+\t\t   (match_operand:V2SI 2 \"register_operand\" \"y\")))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wminuw%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+;; Pack/unpack insns.\n+\n+(define_insn \"iwmmxt_wpackhss\"\n+  [(set (match_operand:V8QI                    0 \"register_operand\" \"=y\")\n+\t(vec_concat:V8QI\n+\t (ss_truncate:V4QI (match_operand:V4HI 1 \"register_operand\" \"y\"))\n+\t (ss_truncate:V4QI (match_operand:V4HI 2 \"register_operand\" \"y\"))))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wpackhss%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"iwmmxt_wpackwss\"\n+  [(set (match_operand:V4HI                    0 \"register_operand\" \"=y\")\n+\t(vec_concat:V4HI\n+\t (ss_truncate:V2HI (match_operand:V2SI 1 \"register_operand\" \"y\"))\n+\t (ss_truncate:V2HI (match_operand:V2SI 2 \"register_operand\" \"y\"))))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wpackwss%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"iwmmxt_wpackdss\"\n+  [(set (match_operand:V2SI                0 \"register_operand\" \"=y\")\n+\t(vec_concat:V2SI\n+\t (ss_truncate:SI (match_operand:DI 1 \"register_operand\" \"y\"))\n+\t (ss_truncate:SI (match_operand:DI 2 \"register_operand\" \"y\"))))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wpackdss%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"iwmmxt_wpackhus\"\n+  [(set (match_operand:V8QI                    0 \"register_operand\" \"=y\")\n+\t(vec_concat:V8QI\n+\t (us_truncate:V4QI (match_operand:V4HI 1 \"register_operand\" \"y\"))\n+\t (us_truncate:V4QI (match_operand:V4HI 2 \"register_operand\" \"y\"))))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wpackhus%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"iwmmxt_wpackwus\"\n+  [(set (match_operand:V4HI                    0 \"register_operand\" \"=y\")\n+\t(vec_concat:V4HI\n+\t (us_truncate:V2HI (match_operand:V2SI 1 \"register_operand\" \"y\"))\n+\t (us_truncate:V2HI (match_operand:V2SI 2 \"register_operand\" \"y\"))))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wpackwus%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"iwmmxt_wpackdus\"\n+  [(set (match_operand:V2SI                0 \"register_operand\" \"=y\")\n+\t(vec_concat:V2SI\n+\t (us_truncate:SI (match_operand:DI 1 \"register_operand\" \"y\"))\n+\t (us_truncate:SI (match_operand:DI 2 \"register_operand\" \"y\"))))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wpackdus%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+\n+(define_insn \"iwmmxt_wunpckihb\"\n+  [(set (match_operand:V8QI                   0 \"register_operand\" \"=y\")\n+\t(vec_merge:V8QI\n+\t (vec_select:V8QI (match_operand:V8QI 1 \"register_operand\" \"y\")\n+\t\t\t  (parallel [(const_int 4)\n+\t\t\t\t     (const_int 0)\n+\t\t\t\t     (const_int 5)\n+\t\t\t\t     (const_int 1)\n+\t\t\t\t     (const_int 6)\n+\t\t\t\t     (const_int 2)\n+\t\t\t\t     (const_int 7)\n+\t\t\t\t     (const_int 3)]))\n+\t (vec_select:V8QI (match_operand:V8QI 2 \"register_operand\" \"y\")\n+\t\t\t  (parallel [(const_int 0)\n+\t\t\t\t     (const_int 4)\n+\t\t\t\t     (const_int 1)\n+\t\t\t\t     (const_int 5)\n+\t\t\t\t     (const_int 2)\n+\t\t\t\t     (const_int 6)\n+\t\t\t\t     (const_int 3)\n+\t\t\t\t     (const_int 7)]))\n+\t (const_int 85)))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wunpckihb%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"iwmmxt_wunpckihh\"\n+  [(set (match_operand:V4HI                   0 \"register_operand\" \"=y\")\n+\t(vec_merge:V4HI\n+\t (vec_select:V4HI (match_operand:V4HI 1 \"register_operand\" \"y\")\n+\t\t\t  (parallel [(const_int 0)\n+\t\t\t\t     (const_int 2)\n+\t\t\t\t     (const_int 1)\n+\t\t\t\t     (const_int 3)]))\n+\t (vec_select:V4HI (match_operand:V4HI 2 \"register_operand\" \"y\")\n+\t\t\t  (parallel [(const_int 2)\n+\t\t\t\t     (const_int 0)\n+\t\t\t\t     (const_int 3)\n+\t\t\t\t     (const_int 1)]))\n+\t (const_int 5)))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wunpckihh%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"iwmmxt_wunpckihw\"\n+  [(set (match_operand:V2SI                   0 \"register_operand\" \"=y\")\n+\t(vec_merge:V2SI\n+\t (vec_select:V2SI (match_operand:V2SI 1 \"register_operand\" \"y\")\n+\t\t\t  (parallel [(const_int 0)\n+\t\t\t\t     (const_int 1)]))\n+\t (vec_select:V2SI (match_operand:V2SI 2 \"register_operand\" \"y\")\n+\t\t\t  (parallel [(const_int 1)\n+\t\t\t\t     (const_int 0)]))\n+\t (const_int 1)))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wunpckihw%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"iwmmxt_wunpckilb\"\n+  [(set (match_operand:V8QI                   0 \"register_operand\" \"=y\")\n+\t(vec_merge:V8QI\n+\t (vec_select:V8QI (match_operand:V8QI 1 \"register_operand\" \"y\")\n+\t\t\t  (parallel [(const_int 0)\n+\t\t\t\t     (const_int 4)\n+\t\t\t\t     (const_int 1)\n+\t\t\t\t     (const_int 5)\n+\t\t\t\t     (const_int 2)\n+\t\t\t\t     (const_int 6)\n+\t\t\t\t     (const_int 3)\n+\t\t\t\t     (const_int 7)]))\n+\t (vec_select:V8QI (match_operand:V8QI 2 \"register_operand\" \"y\")\n+\t\t\t  (parallel [(const_int 4)\n+\t\t\t\t     (const_int 0)\n+\t\t\t\t     (const_int 5)\n+\t\t\t\t     (const_int 1)\n+\t\t\t\t     (const_int 6)\n+\t\t\t\t     (const_int 2)\n+\t\t\t\t     (const_int 7)\n+\t\t\t\t     (const_int 3)]))\n+\t (const_int 85)))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wunpckilb%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"iwmmxt_wunpckilh\"\n+  [(set (match_operand:V4HI                   0 \"register_operand\" \"=y\")\n+\t(vec_merge:V4HI\n+\t (vec_select:V4HI (match_operand:V4HI 1 \"register_operand\" \"y\")\n+\t\t\t  (parallel [(const_int 2)\n+\t\t\t\t     (const_int 0)\n+\t\t\t\t     (const_int 3)\n+\t\t\t\t     (const_int 1)]))\n+\t (vec_select:V4HI (match_operand:V4HI 2 \"register_operand\" \"y\")\n+\t\t\t  (parallel [(const_int 0)\n+\t\t\t\t     (const_int 2)\n+\t\t\t\t     (const_int 1)\n+\t\t\t\t     (const_int 3)]))\n+\t (const_int 5)))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wunpckilh%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"iwmmxt_wunpckilw\"\n+  [(set (match_operand:V2SI                   0 \"register_operand\" \"=y\")\n+\t(vec_merge:V2SI\n+\t (vec_select:V2SI (match_operand:V2SI 1 \"register_operand\" \"y\")\n+\t\t\t   (parallel [(const_int 1)\n+\t\t\t\t      (const_int 0)]))\n+\t (vec_select:V2SI (match_operand:V2SI 2 \"register_operand\" \"y\")\n+\t\t\t  (parallel [(const_int 0)\n+\t\t\t\t     (const_int 1)]))\n+\t (const_int 1)))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wunpckilw%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"iwmmxt_wunpckehub\"\n+  [(set (match_operand:V4HI                   0 \"register_operand\" \"=y\")\n+\t(zero_extend:V4HI\n+\t (vec_select:V4QI (match_operand:V8QI 1 \"register_operand\" \"y\")\n+\t\t\t  (parallel [(const_int 4) (const_int 5)\n+\t\t\t\t     (const_int 6) (const_int 7)]))))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wunpckehub%?\\\\t%0, %1\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"iwmmxt_wunpckehuh\"\n+  [(set (match_operand:V2SI                   0 \"register_operand\" \"=y\")\n+\t(zero_extend:V2SI\n+\t (vec_select:V2HI (match_operand:V4HI 1 \"register_operand\" \"y\")\n+\t\t\t  (parallel [(const_int 2) (const_int 3)]))))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wunpckehuh%?\\\\t%0, %1\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"iwmmxt_wunpckehuw\"\n+  [(set (match_operand:DI                   0 \"register_operand\" \"=y\")\n+\t(zero_extend:DI\n+\t (vec_select:SI (match_operand:V2SI 1 \"register_operand\" \"y\")\n+\t\t\t(parallel [(const_int 1)]))))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wunpckehuw%?\\\\t%0, %1\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"iwmmxt_wunpckehsb\"\n+  [(set (match_operand:V4HI                   0 \"register_operand\" \"=y\")\n+\t(sign_extend:V4HI\n+\t (vec_select:V4QI (match_operand:V8QI 1 \"register_operand\" \"y\")\n+\t\t\t  (parallel [(const_int 4) (const_int 5)\n+\t\t\t\t     (const_int 6) (const_int 7)]))))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wunpckehsb%?\\\\t%0, %1\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"iwmmxt_wunpckehsh\"\n+  [(set (match_operand:V2SI                   0 \"register_operand\" \"=y\")\n+\t(sign_extend:V2SI\n+\t (vec_select:V2HI (match_operand:V4HI 1 \"register_operand\" \"y\")\n+\t\t\t  (parallel [(const_int 2) (const_int 3)]))))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wunpckehsh%?\\\\t%0, %1\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"iwmmxt_wunpckehsw\"\n+  [(set (match_operand:DI                   0 \"register_operand\" \"=y\")\n+\t(sign_extend:DI\n+\t (vec_select:SI (match_operand:V2SI 1 \"register_operand\" \"y\")\n+\t\t\t(parallel [(const_int 1)]))))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wunpckehsw%?\\\\t%0, %1\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"iwmmxt_wunpckelub\"\n+  [(set (match_operand:V4HI                   0 \"register_operand\" \"=y\")\n+\t(zero_extend:V4HI\n+\t (vec_select:V4QI (match_operand:V8QI 1 \"register_operand\" \"y\")\n+\t\t\t  (parallel [(const_int 0) (const_int 1)\n+\t\t\t\t     (const_int 2) (const_int 3)]))))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wunpckelub%?\\\\t%0, %1\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"iwmmxt_wunpckeluh\"\n+  [(set (match_operand:V2SI                   0 \"register_operand\" \"=y\")\n+\t(zero_extend:V2SI\n+\t (vec_select:V2HI (match_operand:V4HI 1 \"register_operand\" \"y\")\n+\t\t\t  (parallel [(const_int 0) (const_int 1)]))))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wunpckeluh%?\\\\t%0, %1\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"iwmmxt_wunpckeluw\"\n+  [(set (match_operand:DI                   0 \"register_operand\" \"=y\")\n+\t(zero_extend:DI\n+\t (vec_select:SI (match_operand:V2SI 1 \"register_operand\" \"y\")\n+\t\t\t(parallel [(const_int 0)]))))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wunpckeluw%?\\\\t%0, %1\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"iwmmxt_wunpckelsb\"\n+  [(set (match_operand:V4HI                   0 \"register_operand\" \"=y\")\n+\t(sign_extend:V4HI\n+\t (vec_select:V4QI (match_operand:V8QI 1 \"register_operand\" \"y\")\n+\t\t\t  (parallel [(const_int 0) (const_int 1)\n+\t\t\t\t     (const_int 2) (const_int 3)]))))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wunpckelsb%?\\\\t%0, %1\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"iwmmxt_wunpckelsh\"\n+  [(set (match_operand:V2SI                   0 \"register_operand\" \"=y\")\n+\t(sign_extend:V2SI\n+\t (vec_select:V2HI (match_operand:V4HI 1 \"register_operand\" \"y\")\n+\t\t\t  (parallel [(const_int 0) (const_int 1)]))))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wunpckelsh%?\\\\t%0, %1\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"iwmmxt_wunpckelsw\"\n+  [(set (match_operand:DI                   0 \"register_operand\" \"=y\")\n+\t(sign_extend:DI\n+\t (vec_select:SI (match_operand:V2SI 1 \"register_operand\" \"y\")\n+\t\t\t(parallel [(const_int 0)]))))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wunpckelsw%?\\\\t%0, %1\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+;; Shifts\n+\n+(define_insn \"rorv4hi3\"\n+  [(set (match_operand:V4HI                0 \"register_operand\" \"=y\")\n+        (rotatert:V4HI (match_operand:V4HI 1 \"register_operand\" \"y\")\n+\t\t       (match_operand:SI   2 \"register_operand\" \"z\")))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wrorhg%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"rorv2si3\"\n+  [(set (match_operand:V2SI                0 \"register_operand\" \"=y\")\n+        (rotatert:V2SI (match_operand:V2SI 1 \"register_operand\" \"y\")\n+\t\t       (match_operand:SI   2 \"register_operand\" \"z\")))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wrorwg%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"rordi3\"\n+  [(set (match_operand:DI              0 \"register_operand\" \"=y\")\n+\t(rotatert:DI (match_operand:DI 1 \"register_operand\" \"y\")\n+\t\t   (match_operand:SI   2 \"register_operand\" \"z\")))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wrordg%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"ashrv4hi3\"\n+  [(set (match_operand:V4HI                0 \"register_operand\" \"=y\")\n+        (ashiftrt:V4HI (match_operand:V4HI 1 \"register_operand\" \"y\")\n+\t\t       (match_operand:SI   2 \"register_operand\" \"z\")))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wsrahg%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"ashrv2si3\"\n+  [(set (match_operand:V2SI                0 \"register_operand\" \"=y\")\n+        (ashiftrt:V2SI (match_operand:V2SI 1 \"register_operand\" \"y\")\n+\t\t       (match_operand:SI   2 \"register_operand\" \"z\")))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wsrawg%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"ashrdi3\"\n+  [(set (match_operand:DI              0 \"register_operand\" \"=y\")\n+\t(ashiftrt:DI (match_operand:DI 1 \"register_operand\" \"y\")\n+\t\t   (match_operand:SI   2 \"register_operand\" \"z\")))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wsradg%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"lshrv4hi3\"\n+  [(set (match_operand:V4HI                0 \"register_operand\" \"=y\")\n+        (lshiftrt:V4HI (match_operand:V4HI 1 \"register_operand\" \"y\")\n+\t\t       (match_operand:SI   2 \"register_operand\" \"z\")))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wsrlhg%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"lshrv2si3\"\n+  [(set (match_operand:V2SI                0 \"register_operand\" \"=y\")\n+        (lshiftrt:V2SI (match_operand:V2SI 1 \"register_operand\" \"y\")\n+\t\t       (match_operand:SI   2 \"register_operand\" \"z\")))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wsrlwg%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"lshrdi3\"\n+  [(set (match_operand:DI              0 \"register_operand\" \"=y\")\n+\t(lshiftrt:DI (match_operand:DI 1 \"register_operand\" \"y\")\n+\t\t     (match_operand:SI 2 \"register_operand\" \"z\")))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wsrldg%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"ashlv4hi3\"\n+  [(set (match_operand:V4HI              0 \"register_operand\" \"=y\")\n+        (ashift:V4HI (match_operand:V4HI 1 \"register_operand\" \"y\")\n+\t\t     (match_operand:SI   2 \"register_operand\" \"z\")))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wsllhg%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"ashlv2si3\"\n+  [(set (match_operand:V2SI              0 \"register_operand\" \"=y\")\n+        (ashift:V2SI (match_operand:V2SI 1 \"register_operand\" \"y\")\n+\t\t       (match_operand:SI 2 \"register_operand\" \"z\")))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wsllwg%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"ashldi3_iwmmxt\"\n+  [(set (match_operand:DI            0 \"register_operand\" \"=y\")\n+\t(ashift:DI (match_operand:DI 1 \"register_operand\" \"y\")\n+\t\t   (match_operand:SI 2 \"register_operand\" \"z\")))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wslldg%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"rorv4hi3_di\"\n+  [(set (match_operand:V4HI                0 \"register_operand\" \"=y\")\n+        (rotatert:V4HI (match_operand:V4HI 1 \"register_operand\" \"y\")\n+\t\t       (match_operand:DI   2 \"register_operand\" \"y\")))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wrorh%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"rorv2si3_di\"\n+  [(set (match_operand:V2SI                0 \"register_operand\" \"=y\")\n+        (rotatert:V2SI (match_operand:V2SI 1 \"register_operand\" \"y\")\n+\t\t       (match_operand:DI   2 \"register_operand\" \"y\")))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wrorw%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"rordi3_di\"\n+  [(set (match_operand:DI              0 \"register_operand\" \"=y\")\n+\t(rotatert:DI (match_operand:DI 1 \"register_operand\" \"y\")\n+\t\t   (match_operand:DI   2 \"register_operand\" \"y\")))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wrord%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"ashrv4hi3_di\"\n+  [(set (match_operand:V4HI                0 \"register_operand\" \"=y\")\n+        (ashiftrt:V4HI (match_operand:V4HI 1 \"register_operand\" \"y\")\n+\t\t       (match_operand:DI   2 \"register_operand\" \"y\")))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wsrah%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"ashrv2si3_di\"\n+  [(set (match_operand:V2SI                0 \"register_operand\" \"=y\")\n+        (ashiftrt:V2SI (match_operand:V2SI 1 \"register_operand\" \"y\")\n+\t\t       (match_operand:DI   2 \"register_operand\" \"y\")))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wsraw%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"ashrdi3_di\"\n+  [(set (match_operand:DI              0 \"register_operand\" \"=y\")\n+\t(ashiftrt:DI (match_operand:DI 1 \"register_operand\" \"y\")\n+\t\t   (match_operand:DI   2 \"register_operand\" \"y\")))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wsrad%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"lshrv4hi3_di\"\n+  [(set (match_operand:V4HI                0 \"register_operand\" \"=y\")\n+        (lshiftrt:V4HI (match_operand:V4HI 1 \"register_operand\" \"y\")\n+\t\t       (match_operand:DI   2 \"register_operand\" \"y\")))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wsrlh%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"lshrv2si3_di\"\n+  [(set (match_operand:V2SI                0 \"register_operand\" \"=y\")\n+        (lshiftrt:V2SI (match_operand:V2SI 1 \"register_operand\" \"y\")\n+\t\t       (match_operand:DI   2 \"register_operand\" \"y\")))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wsrlw%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"lshrdi3_di\"\n+  [(set (match_operand:DI              0 \"register_operand\" \"=y\")\n+\t(lshiftrt:DI (match_operand:DI 1 \"register_operand\" \"y\")\n+\t\t     (match_operand:DI 2 \"register_operand\" \"y\")))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wsrld%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"ashlv4hi3_di\"\n+  [(set (match_operand:V4HI              0 \"register_operand\" \"=y\")\n+        (ashift:V4HI (match_operand:V4HI 1 \"register_operand\" \"y\")\n+\t\t     (match_operand:DI   2 \"register_operand\" \"y\")))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wsllh%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"ashlv2si3_di\"\n+  [(set (match_operand:V2SI              0 \"register_operand\" \"=y\")\n+        (ashift:V2SI (match_operand:V2SI 1 \"register_operand\" \"y\")\n+\t\t       (match_operand:DI 2 \"register_operand\" \"y\")))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wsllw%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"ashldi3_di\"\n+  [(set (match_operand:DI            0 \"register_operand\" \"=y\")\n+\t(ashift:DI (match_operand:DI 1 \"register_operand\" \"y\")\n+\t\t   (match_operand:DI 2 \"register_operand\" \"y\")))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wslld%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"iwmmxt_wmadds\"\n+  [(set (match_operand:V4HI               0 \"register_operand\" \"=y\")\n+        (unspec:V4HI [(match_operand:V4HI 1 \"register_operand\" \"y\")\n+\t\t      (match_operand:V4HI 2 \"register_operand\" \"y\")] UNSPEC_WMADDS))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wmadds%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"iwmmxt_wmaddu\"\n+  [(set (match_operand:V4HI               0 \"register_operand\" \"=y\")\n+        (unspec:V4HI [(match_operand:V4HI 1 \"register_operand\" \"y\")\n+\t\t      (match_operand:V4HI 2 \"register_operand\" \"y\")] UNSPEC_WMADDU))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wmaddu%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"iwmmxt_tmia\"\n+  [(set (match_operand:DI                    0 \"register_operand\" \"=y\")\n+\t(plus:DI (match_operand:DI           1 \"register_operand\" \"0\")\n+\t\t (mult:DI (sign_extend:DI\n+\t\t\t   (match_operand:SI 2 \"register_operand\" \"r\"))\n+\t\t\t  (sign_extend:DI\n+\t\t\t   (match_operand:SI 3 \"register_operand\" \"r\")))))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"tmia%?\\\\t%0, %2, %3\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"iwmmxt_tmiaph\"\n+  [(set (match_operand:DI          0 \"register_operand\" \"=y\")\n+\t(plus:DI (match_operand:DI 1 \"register_operand\" \"0\")\n+\t\t (plus:DI\n+\t\t  (mult:DI (sign_extend:DI\n+\t\t\t    (truncate:HI (match_operand:SI 2 \"register_operand\" \"r\")))\n+\t\t\t   (sign_extend:DI\n+\t\t\t    (truncate:HI (match_operand:SI 3 \"register_operand\" \"r\"))))\n+\t\t  (mult:DI (sign_extend:DI\n+\t\t\t    (truncate:HI (ashiftrt:SI (match_dup 2) (const_int 16))))\n+\t\t\t   (sign_extend:DI\n+\t\t\t    (truncate:HI (ashiftrt:SI (match_dup 3) (const_int 16))))))))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"tmiaph%?\\\\t%0, %2, %3\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"iwmmxt_tmiabb\"\n+  [(set (match_operand:DI          0 \"register_operand\" \"=y\")\n+\t(plus:DI (match_operand:DI 1 \"register_operand\" \"0\")\n+\t\t (mult:DI (sign_extend:DI\n+\t\t\t   (truncate:HI (match_operand:SI 2 \"register_operand\" \"r\")))\n+\t\t\t  (sign_extend:DI\n+\t\t\t   (truncate:HI (match_operand:SI 3 \"register_operand\" \"r\"))))))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"tmiabb%?\\\\t%0, %2, %3\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"iwmmxt_tmiatb\"\n+  [(set (match_operand:DI          0 \"register_operand\" \"=y\")\n+\t(plus:DI (match_operand:DI 1 \"register_operand\" \"0\")\n+\t\t (mult:DI (sign_extend:DI\n+\t\t\t   (truncate:HI (ashiftrt:SI\n+\t\t\t\t\t (match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t\t\t (const_int 16))))\n+\t\t\t  (sign_extend:DI\n+\t\t\t   (truncate:HI (match_operand:SI 3 \"register_operand\" \"r\"))))))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"tmiatb%?\\\\t%0, %2, %3\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"iwmmxt_tmiabt\"\n+  [(set (match_operand:DI          0 \"register_operand\" \"=y\")\n+\t(plus:DI (match_operand:DI 1 \"register_operand\" \"0\")\n+\t\t (mult:DI (sign_extend:DI\n+\t\t\t   (truncate:HI (match_operand:SI 2 \"register_operand\" \"r\")))\n+\t\t\t  (sign_extend:DI\n+\t\t\t   (truncate:HI (ashiftrt:SI\n+\t\t\t\t\t (match_operand:SI 3 \"register_operand\" \"r\")\n+\t\t\t\t\t (const_int 16)))))))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"tmiabt%?\\\\t%0, %2, %3\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"iwmmxt_tmiatt\"\n+  [(set (match_operand:DI          0 \"register_operand\" \"=y\")\n+\t(plus:DI (match_operand:DI 1 \"register_operand\" \"0\")\n+\t\t (mult:DI (sign_extend:DI\n+\t\t\t   (truncate:HI (ashiftrt:SI\n+\t\t\t\t\t (match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t\t\t (const_int 16))))\n+\t\t\t  (sign_extend:DI\n+\t\t\t   (truncate:HI (ashiftrt:SI\n+\t\t\t\t\t (match_operand:SI 3 \"register_operand\" \"r\")\n+\t\t\t\t\t (const_int 16)))))))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"tmiatt%?\\\\t%0, %2, %3\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"iwmmxt_tbcstqi\"\n+  [(set (match_operand:V8QI                   0 \"register_operand\" \"=y\")\n+\t(vec_duplicate:V8QI (match_operand:QI 1 \"register_operand\" \"r\")))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"tbcstb%?\\\\t%0, %1\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"iwmmxt_tbcsthi\"\n+  [(set (match_operand:V4HI                   0 \"register_operand\" \"=y\")\n+\t(vec_duplicate:V4HI (match_operand:HI 1 \"register_operand\" \"r\")))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"tbcsth%?\\\\t%0, %1\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"iwmmxt_tbcstsi\"\n+  [(set (match_operand:V2SI                   0 \"register_operand\" \"=y\")\n+\t(vec_duplicate:V2SI (match_operand:SI 1 \"register_operand\" \"r\")))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"tbcstw%?\\\\t%0, %1\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"iwmmxt_tmovmskb\"\n+  [(set (match_operand:SI               0 \"register_operand\" \"=r\")\n+\t(unspec:SI [(match_operand:V8QI 1 \"register_operand\" \"y\")] UNSPEC_TMOVMSK))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"tmovmskb%?\\\\t%0, %1\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"iwmmxt_tmovmskh\"\n+  [(set (match_operand:SI               0 \"register_operand\" \"=r\")\n+\t(unspec:SI [(match_operand:V4HI 1 \"register_operand\" \"y\")] UNSPEC_TMOVMSK))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"tmovmskh%?\\\\t%0, %1\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"iwmmxt_tmovmskw\"\n+  [(set (match_operand:SI               0 \"register_operand\" \"=r\")\n+\t(unspec:SI [(match_operand:V2SI 1 \"register_operand\" \"y\")] UNSPEC_TMOVMSK))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"tmovmskw%?\\\\t%0, %1\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"iwmmxt_waccb\"\n+  [(set (match_operand:DI               0 \"register_operand\" \"=y\")\n+\t(unspec:DI [(match_operand:V8QI 1 \"register_operand\" \"y\")] UNSPEC_WACC))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"waccb%?\\\\t%0, %1\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"iwmmxt_wacch\"\n+  [(set (match_operand:DI               0 \"register_operand\" \"=y\")\n+\t(unspec:DI [(match_operand:V4HI 1 \"register_operand\" \"y\")] UNSPEC_WACC))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wacch%?\\\\t%0, %1\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"iwmmxt_waccw\"\n+  [(set (match_operand:DI               0 \"register_operand\" \"=y\")\n+\t(unspec:DI [(match_operand:V2SI 1 \"register_operand\" \"y\")] UNSPEC_WACC))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"waccw%?\\\\t%0, %1\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"iwmmxt_walign\"\n+  [(set (match_operand:V8QI                           0 \"register_operand\" \"=y,y\")\n+\t(subreg:V8QI (ashiftrt:TI\n+\t\t      (subreg:TI (vec_concat:V16QI\n+\t\t\t\t  (match_operand:V8QI 1 \"register_operand\" \"y,y\")\n+\t\t\t\t  (match_operand:V8QI 2 \"register_operand\" \"y,y\")) 0)\n+\t\t      (mult:SI\n+\t\t       (match_operand:SI              3 \"nonmemory_operand\" \"i,z\")\n+\t\t       (const_int 8))) 0))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"@\n+   waligni%?\\\\t%0, %1, %2, %3\n+   walignr%U3%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"iwmmxt_tmrc\"\n+  [(set (match_operand:SI                      0 \"register_operand\" \"=r\")\n+\t(unspec_volatile:SI [(match_operand:SI 1 \"immediate_operand\" \"i\")]\n+\t\t\t    VUNSPEC_TMRC))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"tmrc%?\\\\t%0, %w1\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"iwmmxt_tmcr\"\n+  [(unspec_volatile:SI [(match_operand:SI 0 \"immediate_operand\" \"i\")\n+\t\t\t(match_operand:SI 1 \"register_operand\"  \"r\")]\n+\t\t       VUNSPEC_TMCR)]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"tmcr%?\\\\t%w0, %1\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"iwmmxt_wsadb\"\n+  [(set (match_operand:V8QI               0 \"register_operand\" \"=y\")\n+        (unspec:V8QI [(match_operand:V8QI 1 \"register_operand\" \"y\")\n+\t\t      (match_operand:V8QI 2 \"register_operand\" \"y\")] UNSPEC_WSAD))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wsadb%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"iwmmxt_wsadh\"\n+  [(set (match_operand:V4HI               0 \"register_operand\" \"=y\")\n+        (unspec:V4HI [(match_operand:V4HI 1 \"register_operand\" \"y\")\n+\t\t      (match_operand:V4HI 2 \"register_operand\" \"y\")] UNSPEC_WSAD))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wsadh%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"iwmmxt_wsadbz\"\n+  [(set (match_operand:V8QI               0 \"register_operand\" \"=y\")\n+        (unspec:V8QI [(match_operand:V8QI 1 \"register_operand\" \"y\")\n+\t\t      (match_operand:V8QI 2 \"register_operand\" \"y\")] UNSPEC_WSADZ))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wsadbz%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+\n+(define_insn \"iwmmxt_wsadhz\"\n+  [(set (match_operand:V4HI               0 \"register_operand\" \"=y\")\n+        (unspec:V4HI [(match_operand:V4HI 1 \"register_operand\" \"y\")\n+\t\t      (match_operand:V4HI 2 \"register_operand\" \"y\")] UNSPEC_WSADZ))]\n+  \"TARGET_REALLY_IWMMXT\"\n+  \"wsadhz%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")])\n+"}, {"sha": "f80af2dd60e03e9b8b4e58fa88e4def45c447994", "filename": "gcc/config/arm/lib1funcs.asm", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a9335ef017c45e09d9493b982a25a8e58b51d40/gcc%2Fconfig%2Farm%2Flib1funcs.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a9335ef017c45e09d9493b982a25a8e58b51d40/gcc%2Fconfig%2Farm%2Flib1funcs.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Flib1funcs.asm?ref=5a9335ef017c45e09d9493b982a25a8e58b51d40", "patch": "@@ -158,11 +158,12 @@ divisor\t\t.req\tr1\n overdone\t.req\tr2\n result\t\t.req\tr2\n curbit\t\t.req\tr3\n+#if 0\n ip\t\t.req\tr12\n sp\t\t.req\tr13\n lr\t\t.req\tr14\n pc\t\t.req\tr15\n-\n+#endif\n /* ------------------------------------------------------------------------ */\n /*\t\tBodies of the divsion and modulo routines.\t\t    */\n /* ------------------------------------------------------------------------ */\t"}, {"sha": "4dc1d455ce75780d0cad956bdb404f7d9ec22f62", "filename": "gcc/config/arm/mmintrin.h", "status": "added", "additions": 1257, "deletions": 0, "changes": 1257, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a9335ef017c45e09d9493b982a25a8e58b51d40/gcc%2Fconfig%2Farm%2Fmmintrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a9335ef017c45e09d9493b982a25a8e58b51d40/gcc%2Fconfig%2Farm%2Fmmintrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fmmintrin.h?ref=5a9335ef017c45e09d9493b982a25a8e58b51d40", "patch": "@@ -0,0 +1,1257 @@\n+/* Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 2, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to the Free\n+   Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+   02111-1307, USA.  */\n+\n+/* As a special exception, if you include this header file into source\n+   files compiled by GCC, this header file does not by itself cause\n+   the resulting executable to be covered by the GNU General Public\n+   License.  This exception does not however invalidate any other\n+   reasons why the executable file might be covered by the GNU General\n+   Public License.  */\n+\n+#ifndef _MMINTRIN_H_INCLUDED\n+#define _MMINTRIN_H_INCLUDED\n+\n+/* The data type intended for user use.  */\n+typedef unsigned long long __m64, __int64;\n+\n+/* Internal data types for implementing the intrinsics.  */\n+typedef int __v2si __attribute__ ((__mode__ (__V2SI__)));\n+typedef int __v4hi __attribute__ ((__mode__ (__V4HI__)));\n+typedef int __v8qi __attribute__ ((__mode__ (__V8QI__)));\n+\n+/* \"Convert\" __m64 and __int64 into each other.  */\n+static __inline __m64 \n+_mm_cvtsi64_m64 (__int64 __i)\n+{\n+  return __i;\n+}\n+\n+static __inline __int64\n+_mm_cvtm64_si64 (__m64 __i)\n+{\n+  return __i;\n+}\n+\n+static __inline int\n+_mm_cvtsi64_si32 (__int64 __i)\n+{\n+  return __i;\n+}\n+\n+static __inline __int64\n+_mm_cvtsi32_si64 (int __i)\n+{\n+  return __i;\n+}\n+\n+/* Pack the four 16-bit values from M1 into the lower four 8-bit values of\n+   the result, and the four 16-bit values from M2 into the upper four 8-bit\n+   values of the result, all with signed saturation.  */\n+static __inline __m64\n+_mm_packs_pi16 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_arm_wpackhss ((__v4hi)__m1, (__v4hi)__m2);\n+}\n+\n+/* Pack the two 32-bit values from M1 in to the lower two 16-bit values of\n+   the result, and the two 32-bit values from M2 into the upper two 16-bit\n+   values of the result, all with signed saturation.  */\n+static __inline __m64\n+_mm_packs_pi32 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_arm_wpackwss ((__v2si)__m1, (__v2si)__m2);\n+}\n+\n+/* Copy the 64-bit value from M1 into the lower 32-bits of the result, and\n+   the 64-bit value from M2 into the upper 32-bits of the result, all with\n+   signed saturation for values that do not fit exactly into 32-bits.  */\n+static __inline __m64\n+_mm_packs_pi64 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_arm_wpackdss ((long long)__m1, (long long)__m2);\n+}\n+\n+/* Pack the four 16-bit values from M1 into the lower four 8-bit values of\n+   the result, and the four 16-bit values from M2 into the upper four 8-bit\n+   values of the result, all with unsigned saturation.  */\n+static __inline __m64\n+_mm_packs_pu16 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_arm_wpackhus ((__v4hi)__m1, (__v4hi)__m2);\n+}\n+\n+/* Pack the two 32-bit values from M1 into the lower two 16-bit values of\n+   the result, and the two 32-bit values from M2 into the upper two 16-bit\n+   values of the result, all with unsigned saturation.  */\n+static __inline __m64\n+_mm_packs_pu32 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_arm_wpackwus ((__v2si)__m1, (__v2si)__m2);\n+}\n+\n+/* Copy the 64-bit value from M1 into the lower 32-bits of the result, and\n+   the 64-bit value from M2 into the upper 32-bits of the result, all with\n+   unsigned saturation for values that do not fit exactly into 32-bits.  */\n+static __inline __m64\n+_mm_packs_pu64 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_arm_wpackdus ((long long)__m1, (long long)__m2);\n+}\n+\n+/* Interleave the four 8-bit values from the high half of M1 with the four\n+   8-bit values from the high half of M2.  */\n+static __inline __m64\n+_mm_unpackhi_pi8 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_arm_wunpckihb ((__v8qi)__m1, (__v8qi)__m2);\n+}\n+\n+/* Interleave the two 16-bit values from the high half of M1 with the two\n+   16-bit values from the high half of M2.  */\n+static __inline __m64\n+_mm_unpackhi_pi16 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_arm_wunpckihh ((__v4hi)__m1, (__v4hi)__m2);\n+}\n+\n+/* Interleave the 32-bit value from the high half of M1 with the 32-bit\n+   value from the high half of M2.  */\n+static __inline __m64\n+_mm_unpackhi_pi32 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_arm_wunpckihw ((__v2si)__m1, (__v2si)__m2);\n+}\n+\n+/* Interleave the four 8-bit values from the low half of M1 with the four\n+   8-bit values from the low half of M2.  */\n+static __inline __m64\n+_mm_unpacklo_pi8 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_arm_wunpckilb ((__v8qi)__m1, (__v8qi)__m2);\n+}\n+\n+/* Interleave the two 16-bit values from the low half of M1 with the two\n+   16-bit values from the low half of M2.  */\n+static __inline __m64\n+_mm_unpacklo_pi16 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_arm_wunpckilh ((__v4hi)__m1, (__v4hi)__m2);\n+}\n+\n+/* Interleave the 32-bit value from the low half of M1 with the 32-bit\n+   value from the low half of M2.  */\n+static __inline __m64\n+_mm_unpacklo_pi32 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_arm_wunpckilw ((__v2si)__m1, (__v2si)__m2);\n+}\n+\n+/* Take the four 8-bit values from the low half of M1, sign extend them,\n+   and return the result as a vector of four 16-bit quantities.  */\n+static __inline __m64\n+_mm_unpackel_pi8 (__m64 __m1)\n+{\n+  return (__m64) __builtin_arm_wunpckelsb ((__v8qi)__m1);\n+}\n+\n+/* Take the two 16-bit values from the low half of M1, sign extend them,\n+   and return the result as a vector of two 32-bit quantities.  */\n+static __inline __m64\n+_mm_unpackel_pi16 (__m64 __m1)\n+{\n+  return (__m64) __builtin_arm_wunpckelsh ((__v4hi)__m1);\n+}\n+\n+/* Take the 32-bit value from the low half of M1, and return it sign extended\n+  to 64 bits.  */\n+static __inline __m64\n+_mm_unpackel_pi32 (__m64 __m1)\n+{\n+  return (__m64) __builtin_arm_wunpckelsw ((__v2si)__m1);\n+}\n+\n+/* Take the four 8-bit values from the high half of M1, sign extend them,\n+   and return the result as a vector of four 16-bit quantities.  */\n+static __inline __m64\n+_mm_unpackeh_pi8 (__m64 __m1)\n+{\n+  return (__m64) __builtin_arm_wunpckehsb ((__v8qi)__m1);\n+}\n+\n+/* Take the two 16-bit values from the high half of M1, sign extend them,\n+   and return the result as a vector of two 32-bit quantities.  */\n+static __inline __m64\n+_mm_unpackeh_pi16 (__m64 __m1)\n+{\n+  return (__m64) __builtin_arm_wunpckehsh ((__v4hi)__m1);\n+}\n+\n+/* Take the 32-bit value from the high half of M1, and return it sign extended\n+  to 64 bits.  */\n+static __inline __m64\n+_mm_unpackeh_pi32 (__m64 __m1)\n+{\n+  return (__m64) __builtin_arm_wunpckehsw ((__v2si)__m1);\n+}\n+\n+/* Take the four 8-bit values from the low half of M1, zero extend them,\n+   and return the result as a vector of four 16-bit quantities.  */\n+static __inline __m64\n+_mm_unpackel_pu8 (__m64 __m1)\n+{\n+  return (__m64) __builtin_arm_wunpckelub ((__v8qi)__m1);\n+}\n+\n+/* Take the two 16-bit values from the low half of M1, zero extend them,\n+   and return the result as a vector of two 32-bit quantities.  */\n+static __inline __m64\n+_mm_unpackel_pu16 (__m64 __m1)\n+{\n+  return (__m64) __builtin_arm_wunpckeluh ((__v4hi)__m1);\n+}\n+\n+/* Take the 32-bit value from the low half of M1, and return it zero extended\n+  to 64 bits.  */\n+static __inline __m64\n+_mm_unpackel_pu32 (__m64 __m1)\n+{\n+  return (__m64) __builtin_arm_wunpckeluw ((__v2si)__m1);\n+}\n+\n+/* Take the four 8-bit values from the high half of M1, zero extend them,\n+   and return the result as a vector of four 16-bit quantities.  */\n+static __inline __m64\n+_mm_unpackeh_pu8 (__m64 __m1)\n+{\n+  return (__m64) __builtin_arm_wunpckehub ((__v8qi)__m1);\n+}\n+\n+/* Take the two 16-bit values from the high half of M1, zero extend them,\n+   and return the result as a vector of two 32-bit quantities.  */\n+static __inline __m64\n+_mm_unpackeh_pu16 (__m64 __m1)\n+{\n+  return (__m64) __builtin_arm_wunpckehuh ((__v4hi)__m1);\n+}\n+\n+/* Take the 32-bit value from the high half of M1, and return it zero extended\n+  to 64 bits.  */\n+static __inline __m64\n+_mm_unpackeh_pu32 (__m64 __m1)\n+{\n+  return (__m64) __builtin_arm_wunpckehuw ((__v2si)__m1);\n+}\n+\n+/* Add the 8-bit values in M1 to the 8-bit values in M2.  */\n+static __inline __m64\n+_mm_add_pi8 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_arm_waddb ((__v8qi)__m1, (__v8qi)__m2);\n+}\n+\n+/* Add the 16-bit values in M1 to the 16-bit values in M2.  */\n+static __inline __m64\n+_mm_add_pi16 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_arm_waddh ((__v4hi)__m1, (__v4hi)__m2);\n+}\n+\n+/* Add the 32-bit values in M1 to the 32-bit values in M2.  */\n+static __inline __m64\n+_mm_add_pi32 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_arm_waddw ((__v2si)__m1, (__v2si)__m2);\n+}\n+\n+/* Add the 8-bit values in M1 to the 8-bit values in M2 using signed\n+   saturated arithmetic.  */\n+static __inline __m64\n+_mm_adds_pi8 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_arm_waddbss ((__v8qi)__m1, (__v8qi)__m2);\n+}\n+\n+/* Add the 16-bit values in M1 to the 16-bit values in M2 using signed\n+   saturated arithmetic.  */\n+static __inline __m64\n+_mm_adds_pi16 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_arm_waddhss ((__v4hi)__m1, (__v4hi)__m2);\n+}\n+\n+/* Add the 32-bit values in M1 to the 32-bit values in M2 using signed\n+   saturated arithmetic.  */\n+static __inline __m64\n+_mm_adds_pi32 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_arm_waddwss ((__v2si)__m1, (__v2si)__m2);\n+}\n+\n+/* Add the 8-bit values in M1 to the 8-bit values in M2 using unsigned\n+   saturated arithmetic.  */\n+static __inline __m64\n+_mm_adds_pu8 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_arm_waddbus ((__v8qi)__m1, (__v8qi)__m2);\n+}\n+\n+/* Add the 16-bit values in M1 to the 16-bit values in M2 using unsigned\n+   saturated arithmetic.  */\n+static __inline __m64\n+_mm_adds_pu16 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_arm_waddhus ((__v4hi)__m1, (__v4hi)__m2);\n+}\n+\n+/* Add the 32-bit values in M1 to the 32-bit values in M2 using unsigned\n+   saturated arithmetic.  */\n+static __inline __m64\n+_mm_adds_pu32 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_arm_waddwus ((__v2si)__m1, (__v2si)__m2);\n+}\n+\n+/* Subtract the 8-bit values in M2 from the 8-bit values in M1.  */\n+static __inline __m64\n+_mm_sub_pi8 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_arm_wsubb ((__v8qi)__m1, (__v8qi)__m2);\n+}\n+\n+/* Subtract the 16-bit values in M2 from the 16-bit values in M1.  */\n+static __inline __m64\n+_mm_sub_pi16 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_arm_wsubh ((__v4hi)__m1, (__v4hi)__m2);\n+}\n+\n+/* Subtract the 32-bit values in M2 from the 32-bit values in M1.  */\n+static __inline __m64\n+_mm_sub_pi32 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_arm_wsubw ((__v2si)__m1, (__v2si)__m2);\n+}\n+\n+/* Subtract the 8-bit values in M2 from the 8-bit values in M1 using signed\n+   saturating arithmetic.  */\n+static __inline __m64\n+_mm_subs_pi8 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_arm_wsubbss ((__v8qi)__m1, (__v8qi)__m2);\n+}\n+\n+/* Subtract the 16-bit values in M2 from the 16-bit values in M1 using\n+   signed saturating arithmetic.  */\n+static __inline __m64\n+_mm_subs_pi16 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_arm_wsubhss ((__v4hi)__m1, (__v4hi)__m2);\n+}\n+\n+/* Subtract the 32-bit values in M2 from the 32-bit values in M1 using\n+   signed saturating arithmetic.  */\n+static __inline __m64\n+_mm_subs_pi32 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_arm_wsubwss ((__v2si)__m1, (__v2si)__m2);\n+}\n+\n+/* Subtract the 8-bit values in M2 from the 8-bit values in M1 using\n+   unsigned saturating arithmetic.  */\n+static __inline __m64\n+_mm_subs_pu8 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_arm_wsubbus ((__v8qi)__m1, (__v8qi)__m2);\n+}\n+\n+/* Subtract the 16-bit values in M2 from the 16-bit values in M1 using\n+   unsigned saturating arithmetic.  */\n+static __inline __m64\n+_mm_subs_pu16 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_arm_wsubhus ((__v4hi)__m1, (__v4hi)__m2);\n+}\n+\n+/* Subtract the 32-bit values in M2 from the 32-bit values in M1 using\n+   unsigned saturating arithmetic.  */\n+static __inline __m64\n+_mm_subs_pu32 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_arm_wsubwus ((__v2si)__m1, (__v2si)__m2);\n+}\n+\n+/* Multiply four 16-bit values in M1 by four 16-bit values in M2 producing\n+   four 32-bit intermediate results, which are then summed by pairs to\n+   produce two 32-bit results.  */\n+static __inline __m64\n+_mm_madd_pi16 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_arm_wmadds ((__v4hi)__m1, (__v4hi)__m2);\n+}\n+\n+/* Multiply four 16-bit values in M1 by four 16-bit values in M2 producing\n+   four 32-bit intermediate results, which are then summed by pairs to\n+   produce two 32-bit results.  */\n+static __inline __m64\n+_mm_madd_pu16 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_arm_wmaddu ((__v4hi)__m1, (__v4hi)__m2);\n+}\n+\n+/* Multiply four signed 16-bit values in M1 by four signed 16-bit values in\n+   M2 and produce the high 16 bits of the 32-bit results.  */\n+static __inline __m64\n+_mm_mulhi_pi16 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_arm_wmulsh ((__v4hi)__m1, (__v4hi)__m2);\n+}\n+\n+/* Multiply four signed 16-bit values in M1 by four signed 16-bit values in\n+   M2 and produce the high 16 bits of the 32-bit results.  */\n+static __inline __m64\n+_mm_mulhi_pu16 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_arm_wmuluh ((__v4hi)__m1, (__v4hi)__m2);\n+}\n+\n+/* Multiply four 16-bit values in M1 by four 16-bit values in M2 and produce\n+   the low 16 bits of the results.  */\n+static __inline __m64\n+_mm_mullo_pi16 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_arm_wmulul ((__v4hi)__m1, (__v4hi)__m2);\n+}\n+\n+/* Shift four 16-bit values in M left by COUNT.  */\n+static __inline __m64\n+_mm_sll_pi16 (__m64 __m, __m64 __count)\n+{\n+  return (__m64) __builtin_arm_wsllh ((__v4hi)__m, __count);\n+}\n+\n+static __inline __m64\n+_mm_slli_pi16 (__m64 __m, int __count)\n+{\n+  return (__m64) __builtin_arm_wsllhi ((__v4hi)__m, __count);\n+}\n+\n+/* Shift two 32-bit values in M left by COUNT.  */\n+static __inline __m64\n+_mm_sll_pi32 (__m64 __m, __m64 __count)\n+{\n+  return (__m64) __builtin_arm_wsllw ((__v2si)__m, __count);\n+}\n+\n+static __inline __m64\n+_mm_slli_pi32 (__m64 __m, int __count)\n+{\n+  return (__m64) __builtin_arm_wsllwi ((__v2si)__m, __count);\n+}\n+\n+/* Shift the 64-bit value in M left by COUNT.  */\n+static __inline __m64\n+_mm_sll_si64 (__m64 __m, __m64 __count)\n+{\n+  return (__m64) __builtin_arm_wslld (__m, __count);\n+}\n+\n+static __inline __m64\n+_mm_slli_si64 (__m64 __m, int __count)\n+{\n+  return (__m64) __builtin_arm_wslldi (__m, __count);\n+}\n+\n+/* Shift four 16-bit values in M right by COUNT; shift in the sign bit.  */\n+static __inline __m64\n+_mm_sra_pi16 (__m64 __m, __m64 __count)\n+{\n+  return (__m64) __builtin_arm_wsrah ((__v4hi)__m, __count);\n+}\n+\n+static __inline __m64\n+_mm_srai_pi16 (__m64 __m, int __count)\n+{\n+  return (__m64) __builtin_arm_wsrahi ((__v4hi)__m, __count);\n+}\n+\n+/* Shift two 32-bit values in M right by COUNT; shift in the sign bit.  */\n+static __inline __m64\n+_mm_sra_pi32 (__m64 __m, __m64 __count)\n+{\n+  return (__m64) __builtin_arm_wsraw ((__v2si)__m, __count);\n+}\n+\n+static __inline __m64\n+_mm_srai_pi32 (__m64 __m, int __count)\n+{\n+  return (__m64) __builtin_arm_wsrawi ((__v2si)__m, __count);\n+}\n+\n+/* Shift the 64-bit value in M right by COUNT; shift in the sign bit.  */\n+static __inline __m64\n+_mm_sra_si64 (__m64 __m, __m64 __count)\n+{\n+  return (__m64) __builtin_arm_wsrad (__m, __count);\n+}\n+\n+static __inline __m64\n+_mm_srai_si64 (__m64 __m, int __count)\n+{\n+  return (__m64) __builtin_arm_wsradi (__m, __count);\n+}\n+\n+/* Shift four 16-bit values in M right by COUNT; shift in zeros.  */\n+static __inline __m64\n+_mm_srl_pi16 (__m64 __m, __m64 __count)\n+{\n+  return (__m64) __builtin_arm_wsrlh ((__v4hi)__m, __count);\n+}\n+\n+static __inline __m64\n+_mm_srli_pi16 (__m64 __m, int __count)\n+{\n+  return (__m64) __builtin_arm_wsrlhi ((__v4hi)__m, __count);\n+}\n+\n+/* Shift two 32-bit values in M right by COUNT; shift in zeros.  */\n+static __inline __m64\n+_mm_srl_pi32 (__m64 __m, __m64 __count)\n+{\n+  return (__m64) __builtin_arm_wsrlw ((__v2si)__m, __count);\n+}\n+\n+static __inline __m64\n+_mm_srli_pi32 (__m64 __m, int __count)\n+{\n+  return (__m64) __builtin_arm_wsrlwi ((__v2si)__m, __count);\n+}\n+\n+/* Shift the 64-bit value in M left by COUNT; shift in zeros.  */\n+static __inline __m64\n+_mm_srl_si64 (__m64 __m, __m64 __count)\n+{\n+  return (__m64) __builtin_arm_wsrld (__m, __count);\n+}\n+\n+static __inline __m64\n+_mm_srli_si64 (__m64 __m, int __count)\n+{\n+  return (__m64) __builtin_arm_wsrldi (__m, __count);\n+}\n+\n+/* Rotate four 16-bit values in M right by COUNT.  */\n+static __inline __m64\n+_mm_ror_pi16 (__m64 __m, __m64 __count)\n+{\n+  return (__m64) __builtin_arm_wrorh ((__v4hi)__m, __count);\n+}\n+\n+static __inline __m64\n+_mm_rori_pi16 (__m64 __m, int __count)\n+{\n+  return (__m64) __builtin_arm_wrorhi ((__v4hi)__m, __count);\n+}\n+\n+/* Rotate two 32-bit values in M right by COUNT.  */\n+static __inline __m64\n+_mm_ror_pi32 (__m64 __m, __m64 __count)\n+{\n+  return (__m64) __builtin_arm_wrorw ((__v2si)__m, __count);\n+}\n+\n+static __inline __m64\n+_mm_rori_pi32 (__m64 __m, int __count)\n+{\n+  return (__m64) __builtin_arm_wrorwi ((__v2si)__m, __count);\n+}\n+\n+/* Rotate two 64-bit values in M right by COUNT.  */\n+static __inline __m64\n+_mm_ror_si64 (__m64 __m, __m64 __count)\n+{\n+  return (__m64) __builtin_arm_wrord (__m, __count);\n+}\n+\n+static __inline __m64\n+_mm_rori_si64 (__m64 __m, int __count)\n+{\n+  return (__m64) __builtin_arm_wrordi (__m, __count);\n+}\n+\n+/* Bit-wise AND the 64-bit values in M1 and M2.  */\n+static __inline __m64\n+_mm_and_si64 (__m64 __m1, __m64 __m2)\n+{\n+  return __builtin_arm_wand (__m1, __m2);\n+}\n+\n+/* Bit-wise complement the 64-bit value in M1 and bit-wise AND it with the\n+   64-bit value in M2.  */\n+static __inline __m64\n+_mm_andnot_si64 (__m64 __m1, __m64 __m2)\n+{\n+  return __builtin_arm_wandn (__m1, __m2);\n+}\n+\n+/* Bit-wise inclusive OR the 64-bit values in M1 and M2.  */\n+static __inline __m64\n+_mm_or_si64 (__m64 __m1, __m64 __m2)\n+{\n+  return __builtin_arm_wor (__m1, __m2);\n+}\n+\n+/* Bit-wise exclusive OR the 64-bit values in M1 and M2.  */\n+static __inline __m64\n+_mm_xor_si64 (__m64 __m1, __m64 __m2)\n+{\n+  return __builtin_arm_wxor (__m1, __m2);\n+}\n+\n+/* Compare eight 8-bit values.  The result of the comparison is 0xFF if the\n+   test is true and zero if false.  */\n+static __inline __m64\n+_mm_cmpeq_pi8 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_arm_wcmpeqb ((__v8qi)__m1, (__v8qi)__m2);\n+}\n+\n+static __inline __m64\n+_mm_cmpgt_pi8 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_arm_wcmpgtsb ((__v8qi)__m1, (__v8qi)__m2);\n+}\n+\n+static __inline __m64\n+_mm_cmpgt_pu8 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_arm_wcmpgtub ((__v8qi)__m1, (__v8qi)__m2);\n+}\n+\n+/* Compare four 16-bit values.  The result of the comparison is 0xFFFF if\n+   the test is true and zero if false.  */\n+static __inline __m64\n+_mm_cmpeq_pi16 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_arm_wcmpeqh ((__v4hi)__m1, (__v4hi)__m2);\n+}\n+\n+static __inline __m64\n+_mm_cmpgt_pi16 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_arm_wcmpgtsh ((__v4hi)__m1, (__v4hi)__m2);\n+}\n+\n+static __inline __m64\n+_mm_cmpgt_pu16 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_arm_wcmpgtuh ((__v4hi)__m1, (__v4hi)__m2);\n+}\n+\n+/* Compare two 32-bit values.  The result of the comparison is 0xFFFFFFFF if\n+   the test is true and zero if false.  */\n+static __inline __m64\n+_mm_cmpeq_pi32 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_arm_wcmpeqw ((__v2si)__m1, (__v2si)__m2);\n+}\n+\n+static __inline __m64\n+_mm_cmpgt_pi32 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_arm_wcmpgtsw ((__v2si)__m1, (__v2si)__m2);\n+}\n+\n+static __inline __m64\n+_mm_cmpgt_pu32 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_arm_wcmpgtuw ((__v2si)__m1, (__v2si)__m2);\n+}\n+\n+/* Element-wise multiplication of unsigned 16-bit values __B and __C, followed\n+   by accumulate across all elements and __A.  */\n+static __inline __m64\n+_mm_mac_pu16 (__m64 __A, __m64 __B, __m64 __C)\n+{\n+  return __builtin_arm_wmacu (__A, (__v4hi)__B, (__v4hi)__C);\n+}\n+\n+/* Element-wise multiplication of signed 16-bit values __B and __C, followed\n+   by accumulate across all elements and __A.  */\n+static __inline __m64\n+_mm_mac_pi16 (__m64 __A, __m64 __B, __m64 __C)\n+{\n+  return __builtin_arm_wmacs (__A, (__v4hi)__B, (__v4hi)__C);\n+}\n+\n+/* Element-wise multiplication of unsigned 16-bit values __B and __C, followed\n+   by accumulate across all elements.  */\n+static __inline __m64\n+_mm_macz_pu16 (__m64 __A, __m64 __B)\n+{\n+  return __builtin_arm_wmacuz ((__v4hi)__A, (__v4hi)__B);\n+}\n+\n+/* Element-wise multiplication of signed 16-bit values __B and __C, followed\n+   by accumulate across all elements.  */\n+static __inline __m64\n+_mm_macz_pi16 (__m64 __A, __m64 __B)\n+{\n+  return __builtin_arm_wmacsz ((__v4hi)__A, (__v4hi)__B);\n+}\n+\n+/* Accumulate across all unsigned 8-bit values in __A.  */\n+static __inline __m64\n+_mm_acc_pu8 (__m64 __A)\n+{\n+  return __builtin_arm_waccb ((__v8qi)__A);\n+}\n+\n+/* Accumulate across all unsigned 16-bit values in __A.  */\n+static __inline __m64\n+_mm_acc_pu16 (__m64 __A)\n+{\n+  return __builtin_arm_wacch ((__v4hi)__A);\n+}\n+\n+/* Accumulate across all unsigned 32-bit values in __A.  */\n+static __inline __m64\n+_mm_acc_pu32 (__m64 __A)\n+{\n+  return __builtin_arm_waccw ((__v2si)__A);\n+}\n+\n+static __inline __m64\n+_mm_mia_si64 (__m64 __A, int __B, int __C)\n+{\n+  return __builtin_arm_tmia (__A, __B, __C);\n+}\n+\n+static __inline __m64\n+_mm_miaph_si64 (__m64 __A, int __B, int __C)\n+{\n+  return __builtin_arm_tmiaph (__A, __B, __C);\n+}\n+\n+static __inline __m64\n+_mm_miabb_si64 (__m64 __A, int __B, int __C)\n+{\n+  return __builtin_arm_tmiabb (__A, __B, __C);\n+}\n+\n+static __inline __m64\n+_mm_miabt_si64 (__m64 __A, int __B, int __C)\n+{\n+  return __builtin_arm_tmiabt (__A, __B, __C);\n+}\n+\n+static __inline __m64\n+_mm_miatb_si64 (__m64 __A, int __B, int __C)\n+{\n+  return __builtin_arm_tmiatb (__A, __B, __C);\n+}\n+\n+static __inline __m64\n+_mm_miatt_si64 (__m64 __A, int __B, int __C)\n+{\n+  return __builtin_arm_tmiatt (__A, __B, __C);\n+}\n+\n+/* Extract one of the elements of A and sign extend.  The selector N must\n+   be immediate.  */\n+#define _mm_extract_pi8(A, N) __builtin_arm_textrmsb ((__v8qi)(A), (N))\n+#define _mm_extract_pi16(A, N) __builtin_arm_textrmsh ((__v4hi)(A), (N))\n+#define _mm_extract_pi32(A, N) __builtin_arm_textrmsw ((__v2si)(A), (N))\n+\n+/* Extract one of the elements of A and zero extend.  The selector N must\n+   be immediate.  */\n+#define _mm_extract_pu8(A, N) __builtin_arm_textrmub ((__v8qi)(A), (N))\n+#define _mm_extract_pu16(A, N) __builtin_arm_textrmuh ((__v4hi)(A), (N))\n+#define _mm_extract_pu32(A, N) __builtin_arm_textrmuw ((__v2si)(A), (N))\n+\n+/* Inserts word D into one of the elements of A.  The selector N must be\n+   immediate.  */\n+#define _mm_insert_pi8(A, D, N) \\\n+  ((__m64) __builtin_arm_tinsrb ((__v8qi)(A), (D), (N)))\n+#define _mm_insert_pi16(A, D, N) \\\n+  ((__m64) __builtin_arm_tinsrh ((__v4hi)(A), (D), (N)))\n+#define _mm_insert_pi32(A, D, N) \\\n+  ((__m64) __builtin_arm_tinsrw ((__v2si)(A), (D), (N)))\n+\n+/* Compute the element-wise maximum of signed 8-bit values.  */\n+static __inline __m64\n+_mm_max_pi8 (__m64 __A, __m64 __B)\n+{\n+  return (__m64) __builtin_arm_wmaxsb ((__v8qi)__A, (__v8qi)__B);\n+}\n+\n+/* Compute the element-wise maximum of signed 16-bit values.  */\n+static __inline __m64\n+_mm_max_pi16 (__m64 __A, __m64 __B)\n+{\n+  return (__m64) __builtin_arm_wmaxsh ((__v4hi)__A, (__v4hi)__B);\n+}\n+\n+/* Compute the element-wise maximum of signed 32-bit values.  */\n+static __inline __m64\n+_mm_max_pi32 (__m64 __A, __m64 __B)\n+{\n+  return (__m64) __builtin_arm_wmaxsw ((__v2si)__A, (__v2si)__B);\n+}\n+\n+/* Compute the element-wise maximum of unsigned 8-bit values.  */\n+static __inline __m64\n+_mm_max_pu8 (__m64 __A, __m64 __B)\n+{\n+  return (__m64) __builtin_arm_wmaxub ((__v8qi)__A, (__v8qi)__B);\n+}\n+\n+/* Compute the element-wise maximum of unsigned 16-bit values.  */\n+static __inline __m64\n+_mm_max_pu16 (__m64 __A, __m64 __B)\n+{\n+  return (__m64) __builtin_arm_wmaxuh ((__v4hi)__A, (__v4hi)__B);\n+}\n+\n+/* Compute the element-wise maximum of unsigned 32-bit values.  */\n+static __inline __m64\n+_mm_max_pu32 (__m64 __A, __m64 __B)\n+{\n+  return (__m64) __builtin_arm_wmaxuw ((__v2si)__A, (__v2si)__B);\n+}\n+\n+/* Compute the element-wise minimum of signed 16-bit values.  */\n+static __inline __m64\n+_mm_min_pi8 (__m64 __A, __m64 __B)\n+{\n+  return (__m64) __builtin_arm_wminsb ((__v8qi)__A, (__v8qi)__B);\n+}\n+\n+/* Compute the element-wise minimum of signed 16-bit values.  */\n+static __inline __m64\n+_mm_min_pi16 (__m64 __A, __m64 __B)\n+{\n+  return (__m64) __builtin_arm_wminsh ((__v4hi)__A, (__v4hi)__B);\n+}\n+\n+/* Compute the element-wise minimum of signed 32-bit values.  */\n+static __inline __m64\n+_mm_min_pi32 (__m64 __A, __m64 __B)\n+{\n+  return (__m64) __builtin_arm_wminsw ((__v2si)__A, (__v2si)__B);\n+}\n+\n+/* Compute the element-wise minimum of unsigned 16-bit values.  */\n+static __inline __m64\n+_mm_min_pu8 (__m64 __A, __m64 __B)\n+{\n+  return (__m64) __builtin_arm_wminub ((__v8qi)__A, (__v8qi)__B);\n+}\n+\n+/* Compute the element-wise minimum of unsigned 16-bit values.  */\n+static __inline __m64\n+_mm_min_pu16 (__m64 __A, __m64 __B)\n+{\n+  return (__m64) __builtin_arm_wminuh ((__v4hi)__A, (__v4hi)__B);\n+}\n+\n+/* Compute the element-wise minimum of unsigned 32-bit values.  */\n+static __inline __m64\n+_mm_min_pu32 (__m64 __A, __m64 __B)\n+{\n+  return (__m64) __builtin_arm_wminuw ((__v2si)__A, (__v2si)__B);\n+}\n+\n+/* Create an 8-bit mask of the signs of 8-bit values.  */\n+static __inline int\n+_mm_movemask_pi8 (__m64 __A)\n+{\n+  return __builtin_arm_tmovmskb ((__v8qi)__A);\n+}\n+\n+/* Create an 8-bit mask of the signs of 16-bit values.  */\n+static __inline int\n+_mm_movemask_pi16 (__m64 __A)\n+{\n+  return __builtin_arm_tmovmskh ((__v4hi)__A);\n+}\n+\n+/* Create an 8-bit mask of the signs of 32-bit values.  */\n+static __inline int\n+_mm_movemask_pi32 (__m64 __A)\n+{\n+  return __builtin_arm_tmovmskw ((__v2si)__A);\n+}\n+\n+/* Return a combination of the four 16-bit values in A.  The selector\n+   must be an immediate.  */\n+#define _mm_shuffle_pi16(A, N) \\\n+  ((__m64) __builtin_arm_wshufh ((__v4hi)(A), (N)))\n+\n+\n+/* Compute the rounded averages of the unsigned 8-bit values in A and B.  */\n+static __inline __m64\n+_mm_avg_pu8 (__m64 __A, __m64 __B)\n+{\n+  return (__m64) __builtin_arm_wavg2br ((__v8qi)__A, (__v8qi)__B);\n+}\n+\n+/* Compute the rounded averages of the unsigned 16-bit values in A and B.  */\n+static __inline __m64\n+_mm_avg_pu16 (__m64 __A, __m64 __B)\n+{\n+  return (__m64) __builtin_arm_wavg2hr ((__v4hi)__A, (__v4hi)__B);\n+}\n+\n+/* Compute the averages of the unsigned 8-bit values in A and B.  */\n+static __inline __m64\n+_mm_avg2_pu8 (__m64 __A, __m64 __B)\n+{\n+  return (__m64) __builtin_arm_wavg2b ((__v8qi)__A, (__v8qi)__B);\n+}\n+\n+/* Compute the averages of the unsigned 16-bit values in A and B.  */\n+static __inline __m64\n+_mm_avg2_pu16 (__m64 __A, __m64 __B)\n+{\n+  return (__m64) __builtin_arm_wavg2h ((__v4hi)__A, (__v4hi)__B);\n+}\n+\n+/* Compute the sum of the absolute differences of the unsigned 8-bit\n+   values in A and B.  Return the value in the lower 16-bit word; the\n+   upper words are cleared.  */\n+static __inline __m64\n+_mm_sad_pu8 (__m64 __A, __m64 __B)\n+{\n+  return (__m64) __builtin_arm_wsadb ((__v8qi)__A, (__v8qi)__B);\n+}\n+\n+/* Compute the sum of the absolute differences of the unsigned 16-bit\n+   values in A and B.  Return the value in the lower 32-bit word; the\n+   upper words are cleared.  */\n+static __inline __m64\n+_mm_sad_pu16 (__m64 __A, __m64 __B)\n+{\n+  return (__m64) __builtin_arm_wsadh ((__v4hi)__A, (__v4hi)__B);\n+}\n+\n+/* Compute the sum of the absolute differences of the unsigned 8-bit\n+   values in A and B.  Return the value in the lower 16-bit word; the\n+   upper words are cleared.  */\n+static __inline __m64\n+_mm_sadz_pu8 (__m64 __A, __m64 __B)\n+{\n+  return (__m64) __builtin_arm_wsadbz ((__v8qi)__A, (__v8qi)__B);\n+}\n+\n+/* Compute the sum of the absolute differences of the unsigned 16-bit\n+   values in A and B.  Return the value in the lower 32-bit word; the\n+   upper words are cleared.  */\n+static __inline __m64\n+_mm_sadz_pu16 (__m64 __A, __m64 __B)\n+{\n+  return (__m64) __builtin_arm_wsadhz ((__v4hi)__A, (__v4hi)__B);\n+}\n+\n+static __inline __m64\n+_mm_align_si64 (__m64 __A, __m64 __B, int __C)\n+{\n+  return (__m64) __builtin_arm_walign ((__v8qi)__A, (__v8qi)__B, __C);\n+}\n+\n+/* Creates a 64-bit zero.  */\n+static __inline __m64\n+_mm_setzero_si64 (void)\n+{\n+  return __builtin_arm_wzero ();\n+}\n+\n+/* Set and Get arbitrary iWMMXt Control registers.\n+   Note only registers 0-3 and 8-11 are currently defined,\n+   the rest are reserved.  */\n+\n+static __inline void\n+_mm_setwcx (const int __regno, const int __value)\n+{\n+  switch (__regno)\n+    {\n+    case 0:  __builtin_arm_setwcx (0, __value); break;\n+    case 1:  __builtin_arm_setwcx (1, __value); break;\n+    case 2:  __builtin_arm_setwcx (2, __value); break;\n+    case 3:  __builtin_arm_setwcx (3, __value); break;\n+    case 8:  __builtin_arm_setwcx (8, __value); break;\n+    case 9:  __builtin_arm_setwcx (9, __value); break;\n+    case 10: __builtin_arm_setwcx (10, __value); break;\n+    case 11: __builtin_arm_setwcx (11, __value); break;\n+    default: break;\n+    }\n+}\n+\n+static __inline int\n+_mm_getwcx (const int __regno)\n+{\n+  switch (__regno)\n+    {\n+    case 0:  return __builtin_arm_getwcx (0);\n+    case 1:  return __builtin_arm_getwcx (1);\n+    case 2:  return __builtin_arm_getwcx (2);\n+    case 3:  return __builtin_arm_getwcx (3);\n+    case 8:  return __builtin_arm_getwcx (8);\n+    case 9:  return __builtin_arm_getwcx (9);\n+    case 10: return __builtin_arm_getwcx (10);\n+    case 11: return __builtin_arm_getwcx (11);\n+    default: return 0;\n+    }\n+}\n+\n+/* Creates a vector of two 32-bit values; I0 is least significant.  */\n+static __inline __m64\n+_mm_set_pi32 (int __i1, int __i0)\n+{\n+  union {\n+    __m64 __q;\n+    struct {\n+      unsigned int __i0;\n+      unsigned int __i1;\n+    } __s;\n+  } __u;\n+\n+  __u.__s.__i0 = __i0;\n+  __u.__s.__i1 = __i1;\n+\n+  return __u.__q;\n+}\n+\n+/* Creates a vector of four 16-bit values; W0 is least significant.  */\n+static __inline __m64\n+_mm_set_pi16 (short __w3, short __w2, short __w1, short __w0)\n+{\n+  unsigned int __i1 = (unsigned short)__w3 << 16 | (unsigned short)__w2;\n+  unsigned int __i0 = (unsigned short)__w1 << 16 | (unsigned short)__w0;\n+  return _mm_set_pi32 (__i1, __i0);\n+\t\t       \n+}\n+\n+/* Creates a vector of eight 8-bit values; B0 is least significant.  */\n+static __inline __m64\n+_mm_set_pi8 (char __b7, char __b6, char __b5, char __b4,\n+\t     char __b3, char __b2, char __b1, char __b0)\n+{\n+  unsigned int __i1, __i0;\n+\n+  __i1 = (unsigned char)__b7;\n+  __i1 = __i1 << 8 | (unsigned char)__b6;\n+  __i1 = __i1 << 8 | (unsigned char)__b5;\n+  __i1 = __i1 << 8 | (unsigned char)__b4;\n+\n+  __i0 = (unsigned char)__b3;\n+  __i0 = __i0 << 8 | (unsigned char)__b2;\n+  __i0 = __i0 << 8 | (unsigned char)__b1;\n+  __i0 = __i0 << 8 | (unsigned char)__b0;\n+\n+  return _mm_set_pi32 (__i1, __i0);\n+}\n+\n+/* Similar, but with the arguments in reverse order.  */\n+static __inline __m64\n+_mm_setr_pi32 (int __i0, int __i1)\n+{\n+  return _mm_set_pi32 (__i1, __i0);\n+}\n+\n+static __inline __m64\n+_mm_setr_pi16 (short __w0, short __w1, short __w2, short __w3)\n+{\n+  return _mm_set_pi16 (__w3, __w2, __w1, __w0);\n+}\n+\n+static __inline __m64\n+_mm_setr_pi8 (char __b0, char __b1, char __b2, char __b3,\n+\t      char __b4, char __b5, char __b6, char __b7)\n+{\n+  return _mm_set_pi8 (__b7, __b6, __b5, __b4, __b3, __b2, __b1, __b0);\n+}\n+\n+/* Creates a vector of two 32-bit values, both elements containing I.  */\n+static __inline __m64\n+_mm_set1_pi32 (int __i)\n+{\n+  return _mm_set_pi32 (__i, __i);\n+}\n+\n+/* Creates a vector of four 16-bit values, all elements containing W.  */\n+static __inline __m64\n+_mm_set1_pi16 (short __w)\n+{\n+  unsigned int __i = (unsigned short)__w << 16 | (unsigned short)__w;\n+  return _mm_set1_pi32 (__i);\n+}\n+\n+/* Creates a vector of four 16-bit values, all elements containing B.  */\n+static __inline __m64\n+_mm_set1_pi8 (char __b)\n+{\n+  unsigned int __w = (unsigned char)__b << 8 | (unsigned char)__b;\n+  unsigned int __i = __w << 16 | __w;\n+  return _mm_set1_pi32 (__i);\n+}\n+\n+/* Convert an integer to a __m64 object.  */\n+static __inline __m64\n+_m_from_int (int __a)\n+{\n+  return (__m64)__a;\n+}\n+\n+#define _m_packsswb _mm_packs_pi16\n+#define _m_packssdw _mm_packs_pi32\n+#define _m_packuswb _mm_packs_pu16\n+#define _m_packusdw _mm_packs_pu32\n+#define _m_packssqd _mm_packs_pi64\n+#define _m_packusqd _mm_packs_pu64\n+#define _mm_packs_si64 _mm_packs_pi64\n+#define _mm_packs_su64 _mm_packs_pu64\n+#define _m_punpckhbw _mm_unpackhi_pi8\n+#define _m_punpckhwd _mm_unpackhi_pi16\n+#define _m_punpckhdq _mm_unpackhi_pi32\n+#define _m_punpcklbw _mm_unpacklo_pi8\n+#define _m_punpcklwd _mm_unpacklo_pi16\n+#define _m_punpckldq _mm_unpacklo_pi32\n+#define _m_punpckehsbw _mm_unpackeh_pi8\n+#define _m_punpckehswd _mm_unpackeh_pi16\n+#define _m_punpckehsdq _mm_unpackeh_pi32\n+#define _m_punpckehubw _mm_unpackeh_pu8\n+#define _m_punpckehuwd _mm_unpackeh_pu16\n+#define _m_punpckehudq _mm_unpackeh_pu32\n+#define _m_punpckelsbw _mm_unpackel_pi8\n+#define _m_punpckelswd _mm_unpackel_pi16\n+#define _m_punpckelsdq _mm_unpackel_pi32\n+#define _m_punpckelubw _mm_unpackel_pu8\n+#define _m_punpckeluwd _mm_unpackel_pu16\n+#define _m_punpckeludq _mm_unpackel_pu32\n+#define _m_paddb _mm_add_pi8\n+#define _m_paddw _mm_add_pi16\n+#define _m_paddd _mm_add_pi32\n+#define _m_paddsb _mm_adds_pi8\n+#define _m_paddsw _mm_adds_pi16\n+#define _m_paddsd _mm_adds_pi32\n+#define _m_paddusb _mm_adds_pu8\n+#define _m_paddusw _mm_adds_pu16\n+#define _m_paddusd _mm_adds_pu32\n+#define _m_psubb _mm_sub_pi8\n+#define _m_psubw _mm_sub_pi16\n+#define _m_psubd _mm_sub_pi32\n+#define _m_psubsb _mm_subs_pi8\n+#define _m_psubsw _mm_subs_pi16\n+#define _m_psubuw _mm_subs_pi32\n+#define _m_psubusb _mm_subs_pu8\n+#define _m_psubusw _mm_subs_pu16\n+#define _m_psubusd _mm_subs_pu32\n+#define _m_pmaddwd _mm_madd_pi16\n+#define _m_pmadduwd _mm_madd_pu16\n+#define _m_pmulhw _mm_mulhi_pi16\n+#define _m_pmulhuw _mm_mulhi_pu16\n+#define _m_pmullw _mm_mullo_pi16\n+#define _m_pmacsw _mm_mac_pi16\n+#define _m_pmacuw _mm_mac_pu16\n+#define _m_pmacszw _mm_macz_pi16\n+#define _m_pmacuzw _mm_macz_pu16\n+#define _m_paccb _mm_acc_pu8\n+#define _m_paccw _mm_acc_pu16\n+#define _m_paccd _mm_acc_pu32\n+#define _m_pmia _mm_mia_si64\n+#define _m_pmiaph _mm_miaph_si64\n+#define _m_pmiabb _mm_miabb_si64\n+#define _m_pmiabt _mm_miabt_si64\n+#define _m_pmiatb _mm_miatb_si64\n+#define _m_pmiatt _mm_miatt_si64\n+#define _m_psllw _mm_sll_pi16\n+#define _m_psllwi _mm_slli_pi16\n+#define _m_pslld _mm_sll_pi32\n+#define _m_pslldi _mm_slli_pi32\n+#define _m_psllq _mm_sll_si64\n+#define _m_psllqi _mm_slli_si64\n+#define _m_psraw _mm_sra_pi16\n+#define _m_psrawi _mm_srai_pi16\n+#define _m_psrad _mm_sra_pi32\n+#define _m_psradi _mm_srai_pi32\n+#define _m_psraq _mm_sra_si64\n+#define _m_psraqi _mm_srai_si64\n+#define _m_psrlw _mm_srl_pi16\n+#define _m_psrlwi _mm_srli_pi16\n+#define _m_psrld _mm_srl_pi32\n+#define _m_psrldi _mm_srli_pi32\n+#define _m_psrlq _mm_srl_si64\n+#define _m_psrlqi _mm_srli_si64\n+#define _m_prorw _mm_ror_pi16\n+#define _m_prorwi _mm_rori_pi16\n+#define _m_prord _mm_ror_pi32\n+#define _m_prordi _mm_rori_pi32\n+#define _m_prorq _mm_ror_si64\n+#define _m_prorqi _mm_rori_si64\n+#define _m_pand _mm_and_si64\n+#define _m_pandn _mm_andnot_si64\n+#define _m_por _mm_or_si64\n+#define _m_pxor _mm_xor_si64\n+#define _m_pcmpeqb _mm_cmpeq_pi8\n+#define _m_pcmpeqw _mm_cmpeq_pi16\n+#define _m_pcmpeqd _mm_cmpeq_pi32\n+#define _m_pcmpgtb _mm_cmpgt_pi8\n+#define _m_pcmpgtub _mm_cmpgt_pu8\n+#define _m_pcmpgtw _mm_cmpgt_pi16\n+#define _m_pcmpgtuw _mm_cmpgt_pu16\n+#define _m_pcmpgtd _mm_cmpgt_pi32\n+#define _m_pcmpgtud _mm_cmpgt_pu32\n+#define _m_pextrb _mm_extract_pi8\n+#define _m_pextrw _mm_extract_pi16\n+#define _m_pextrd _mm_extract_pi32\n+#define _m_pextrub _mm_extract_pu8\n+#define _m_pextruw _mm_extract_pu16\n+#define _m_pextrud _mm_extract_pu32\n+#define _m_pinsrb _mm_insert_pi8\n+#define _m_pinsrw _mm_insert_pi16\n+#define _m_pinsrd _mm_insert_pi32\n+#define _m_pmaxsb _mm_max_pi8\n+#define _m_pmaxsw _mm_max_pi16\n+#define _m_pmaxsd _mm_max_pi32\n+#define _m_pmaxub _mm_max_pu8\n+#define _m_pmaxuw _mm_max_pu16\n+#define _m_pmaxud _mm_max_pu32\n+#define _m_pminsb _mm_min_pi8\n+#define _m_pminsw _mm_min_pi16\n+#define _m_pminsd _mm_min_pi32\n+#define _m_pminub _mm_min_pu8\n+#define _m_pminuw _mm_min_pu16\n+#define _m_pminud _mm_min_pu32\n+#define _m_pmovmskb _mm_movemask_pi8\n+#define _m_pmovmskw _mm_movemask_pi16\n+#define _m_pmovmskd _mm_movemask_pi32\n+#define _m_pshufw _mm_shuffle_pi16\n+#define _m_pavgb _mm_avg_pu8\n+#define _m_pavgw _mm_avg_pu16\n+#define _m_pavg2b _mm_avg2_pu8\n+#define _m_pavg2w _mm_avg2_pu16\n+#define _m_psadbw _mm_sad_pu8\n+#define _m_psadwd _mm_sad_pu16\n+#define _m_psadzbw _mm_sadz_pu8\n+#define _m_psadzwd _mm_sadz_pu16\n+#define _m_paligniq _mm_align_si64\n+#define _m_cvt_si2pi _mm_cvtsi64_m64\n+#define _m_cvt_pi2si _mm_cvtm64_si64\n+\n+#endif /* _MMINTRIN_H_INCLUDED */"}, {"sha": "b72c21ce9803be0c4c928fae0812f73461c751e8", "filename": "gcc/config/arm/t-xscale-elf", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a9335ef017c45e09d9493b982a25a8e58b51d40/gcc%2Fconfig%2Farm%2Ft-xscale-elf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a9335ef017c45e09d9493b982a25a8e58b51d40/gcc%2Fconfig%2Farm%2Ft-xscale-elf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ft-xscale-elf?ref=5a9335ef017c45e09d9493b982a25a8e58b51d40", "patch": "@@ -37,6 +37,10 @@ MULTILIB_EXCEPTIONS += *mhard-float/*mthumb*\n \n MULTILIB_REDUNDANT_DIRS = interwork/thumb=thumb\n \n+MULTILIB_OPTIONS    += mcpu=iwmmxt\n+MULTILIB_DIRNAMES   += iwmmxt\n+MULTILIB_REDUNDANT_DIRS += interwork/thumb/iwmmxt=thumb\n+\n EXTRA_MULTILIB_PARTS = crtbegin.o crtend.o crti.o crtn.o\n \n LIBGCC               = stmp-multilib"}, {"sha": "a8ea9a7d3cf5c2ec9ca21b90668df99586a4544e", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a9335ef017c45e09d9493b982a25a8e58b51d40/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a9335ef017c45e09d9493b982a25a8e58b51d40/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=5a9335ef017c45e09d9493b982a25a8e58b51d40", "patch": "@@ -6338,7 +6338,7 @@ assembly code.  Permissible names are: @samp{arm2}, @samp{arm250},\n @samp{strongarm}, @samp{strongarm110}, @samp{strongarm1100},\n @samp{arm8}, @samp{arm810}, @samp{arm9}, @samp{arm9e}, @samp{arm920},\n @samp{arm920t}, @samp{arm940t}, @samp{arm9tdmi}, @samp{arm10tdmi},\n-@samp{arm1020t}, @samp{xscale}, @samp{ep9312}.\n+@samp{arm1020t}, @samp{xscale}, @samp{iwmmxt}, @samp{ep9312}.\n \n @itemx -mtune=@var{name}\n @opindex mtune\n@@ -6358,7 +6358,7 @@ name to determine what kind of instructions it can emit when generating\n assembly code.  This option can be used in conjunction with or instead\n of the @option{-mcpu=} option.  Permissible names are: @samp{armv2},\n @samp{armv2a}, @samp{armv3}, @samp{armv3m}, @samp{armv4}, @samp{armv4t},\n-@samp{armv5}, @samp{armv5t}, @samp{armv5te}, @samp{ep9312}.\n+@samp{armv5}, @samp{armv5t}, @samp{armv5te}, @samp{iwmmxt}, @samp{ep9312}.\n \n @item -mfpe=@var{number}\n @itemx -mfp=@var{number}"}]}