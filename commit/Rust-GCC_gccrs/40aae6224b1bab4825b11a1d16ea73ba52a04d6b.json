{"sha": "40aae6224b1bab4825b11a1d16ea73ba52a04d6b", "node_id": "C_kwDOANBUbNoAKDQwYWFlNjIyNGIxYmFiNDgyNWIxMWExZDE2ZWE3M2JhNTJhMDRkNmI", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-12-14T11:56:12Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-12-15T22:37:10Z"}, "message": "Refactor TyTy::ResolveCompile pass to be in its own file\n\nThis name likely needs refactored, this class is used to take TyTy types\nand compile them down to GCC tree's but take into account that we may have\nalready compiled this type before so to preserve the canonical types we\n\"resolve\" the type if possible and then compile.", "tree": {"sha": "90cb8844a08a7a11d59c353fe2422b3d8456b21d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/90cb8844a08a7a11d59c353fe2422b3d8456b21d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/40aae6224b1bab4825b11a1d16ea73ba52a04d6b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40aae6224b1bab4825b11a1d16ea73ba52a04d6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40aae6224b1bab4825b11a1d16ea73ba52a04d6b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40aae6224b1bab4825b11a1d16ea73ba52a04d6b/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "310968874db1902084012cf767ad0b6e93f028c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/310968874db1902084012cf767ad0b6e93f028c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/310968874db1902084012cf767ad0b6e93f028c2"}], "stats": {"total": 796, "additions": 452, "deletions": 344}, "files": [{"sha": "3a5e7cc2724eb1c0472ec42dbe7e6bef832bcc98", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40aae6224b1bab4825b11a1d16ea73ba52a04d6b/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40aae6224b1bab4825b11a1d16ea73ba52a04d6b/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=40aae6224b1bab4825b11a1d16ea73ba52a04d6b", "patch": "@@ -93,6 +93,7 @@ GRS_OBJS = \\\n     rust/rust-compile-intrinsic.o \\\n     rust/rust-base62.o \\\n     rust/rust-compile-expr.o \\\n+    rust/rust-compile-type.o \\\n     $(END)\n # removed object files from here\n "}, {"sha": "ed6bba4dc3c4e68b10139aca3351db49ce139ecb", "filename": "gcc/rust/backend/rust-compile-base.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40aae6224b1bab4825b11a1d16ea73ba52a04d6b/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40aae6224b1bab4825b11a1d16ea73ba52a04d6b/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-base.h?ref=40aae6224b1bab4825b11a1d16ea73ba52a04d6b", "patch": "@@ -18,6 +18,7 @@\n #define RUST_COMPILE_BASE\n \n #include \"rust-compile-context.h\"\n+#include \"rust-compile-type.h\"\n #include \"rust-hir-visitor.h\"\n #include \"rust-hir-full.h\"\n "}, {"sha": "6347e766f97b45f93f3c4aa15d6b0af2d5bf9457", "filename": "gcc/rust/backend/rust-compile-context.h", "status": "modified", "additions": 0, "deletions": 344, "changes": 344, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40aae6224b1bab4825b11a1d16ea73ba52a04d6b/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40aae6224b1bab4825b11a1d16ea73ba52a04d6b/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-context.h?ref=40aae6224b1bab4825b11a1d16ea73ba52a04d6b", "patch": "@@ -334,350 +334,6 @@ class Context\n   std::vector<tree> func_decls;\n };\n \n-class TyTyResolveCompile : public TyTy::TyConstVisitor\n-{\n-public:\n-  static tree compile (Context *ctx, const TyTy::BaseType *ty,\n-\t\t       bool trait_object_mode = false)\n-  {\n-    TyTyResolveCompile compiler (ctx, trait_object_mode);\n-    ty->accept_vis (compiler);\n-    return compiler.translated;\n-  }\n-\n-  void visit (const TyTy::ErrorType &) override { gcc_unreachable (); }\n-  void visit (const TyTy::InferType &) override { gcc_unreachable (); }\n-\n-  void visit (const TyTy::ProjectionType &type) override\n-  {\n-    type.get ()->accept_vis (*this);\n-  }\n-\n-  void visit (const TyTy::PlaceholderType &type) override\n-  {\n-    type.resolve ()->accept_vis (*this);\n-  }\n-\n-  void visit (const TyTy::ParamType &param) override\n-  {\n-    recursion_count++;\n-    rust_assert (recursion_count < kDefaultRecusionLimit);\n-\n-    param.resolve ()->accept_vis (*this);\n-  }\n-\n-  void visit (const TyTy::FnType &type) override\n-  {\n-    Backend::typed_identifier receiver;\n-    std::vector<Backend::typed_identifier> parameters;\n-    std::vector<Backend::typed_identifier> results;\n-\n-    if (!type.get_return_type ()->is_unit ())\n-      {\n-\tauto hir_type = type.get_return_type ();\n-\tauto ret\n-\t  = TyTyResolveCompile::compile (ctx, hir_type, trait_object_mode);\n-\tresults.push_back (Backend::typed_identifier (\n-\t  \"_\", ret,\n-\t  ctx->get_mappings ()->lookup_location (hir_type->get_ref ())));\n-      }\n-\n-    for (auto &param_pair : type.get_params ())\n-      {\n-\tauto param_tyty = param_pair.second;\n-\tauto compiled_param_type\n-\t  = TyTyResolveCompile::compile (ctx, param_tyty, trait_object_mode);\n-\n-\tauto compiled_param = Backend::typed_identifier (\n-\t  param_pair.first->as_string (), compiled_param_type,\n-\t  ctx->get_mappings ()->lookup_location (param_tyty->get_ref ()));\n-\n-\tparameters.push_back (compiled_param);\n-      }\n-\n-    if (!type.is_varadic ())\n-      translated = ctx->get_backend ()->function_type (\n-\treceiver, parameters, results, NULL,\n-\tctx->get_mappings ()->lookup_location (type.get_ref ()));\n-    else\n-      translated = ctx->get_backend ()->function_type_varadic (\n-\treceiver, parameters, results, NULL,\n-\tctx->get_mappings ()->lookup_location (type.get_ref ()));\n-  }\n-\n-  void visit (const TyTy::FnPtr &type) override\n-  {\n-    tree result_type\n-      = TyTyResolveCompile::compile (ctx, type.get_return_type ());\n-\n-    std::vector<tree> parameters;\n-    type.iterate_params ([&] (TyTy::BaseType *p) mutable -> bool {\n-      tree pty = TyTyResolveCompile::compile (ctx, p);\n-      parameters.push_back (pty);\n-      return true;\n-    });\n-\n-    translated = ctx->get_backend ()->function_ptr_type (\n-      result_type, parameters,\n-      ctx->get_mappings ()->lookup_location (type.get_ref ()));\n-  }\n-\n-  void visit (const TyTy::ADTType &type) override\n-  {\n-    if (ctx->lookup_compiled_types (type.get_ty_ref (), &translated, &type))\n-      return;\n-\n-    // we dont support enums yet\n-    rust_assert (!type.is_enum ());\n-    rust_assert (type.number_of_variants () == 1);\n-\n-    TyTy::VariantDef &variant = *type.get_variants ().at (0);\n-    std::vector<Backend::typed_identifier> fields;\n-    for (size_t i = 0; i < variant.num_fields (); i++)\n-      {\n-\tconst TyTy::StructFieldType *field = variant.get_field_at_index (i);\n-\ttree compiled_field_ty\n-\t  = TyTyResolveCompile::compile (ctx, field->get_field_type ());\n-\n-\tBackend::typed_identifier f (field->get_name (), compiled_field_ty,\n-\t\t\t\t     ctx->get_mappings ()->lookup_location (\n-\t\t\t\t       type.get_ty_ref ()));\n-\tfields.push_back (std::move (f));\n-      }\n-\n-    tree type_record;\n-    if (type.is_union ())\n-      type_record = ctx->get_backend ()->union_type (fields);\n-    else\n-      type_record = ctx->get_backend ()->struct_type (fields);\n-    tree named_struct\n-      = ctx->get_backend ()->named_type (type.get_name (), type_record,\n-\t\t\t\t\t ctx->get_mappings ()->lookup_location (\n-\t\t\t\t\t   type.get_ty_ref ()));\n-\n-    ctx->push_type (named_struct);\n-    translated = named_struct;\n-\n-    ctx->insert_compiled_type (type.get_ty_ref (), named_struct, &type);\n-  }\n-\n-  void visit (const TyTy::TupleType &type) override\n-  {\n-    if (type.num_fields () == 0)\n-      {\n-\ttranslated = ctx->get_backend ()->unit_type ();\n-\treturn;\n-      }\n-\n-    bool ok\n-      = ctx->lookup_compiled_types (type.get_ty_ref (), &translated, &type);\n-    if (ok)\n-      return;\n-\n-    // create implicit struct\n-    std::vector<Backend::typed_identifier> fields;\n-    for (size_t i = 0; i < type.num_fields (); i++)\n-      {\n-\tTyTy::BaseType *field = type.get_field (i);\n-\ttree compiled_field_ty = TyTyResolveCompile::compile (ctx, field);\n-\n-\t// rustc uses the convention __N, where N is an integer, to\n-\t// name the fields of a tuple.  We follow this as well,\n-\t// because this is used by GDB.  One further reason to prefer\n-\t// this, rather than simply emitting the integer, is that this\n-\t// approach makes it simpler to use a C-only debugger, or\n-\t// GDB's C mode, when debugging Rust.\n-\tBackend::typed_identifier f (\"__\" + std::to_string (i),\n-\t\t\t\t     compiled_field_ty,\n-\t\t\t\t     ctx->get_mappings ()->lookup_location (\n-\t\t\t\t       type.get_ty_ref ()));\n-\tfields.push_back (std::move (f));\n-      }\n-\n-    tree struct_type_record = ctx->get_backend ()->struct_type (fields);\n-    tree named_struct\n-      = ctx->get_backend ()->named_type (type.as_string (), struct_type_record,\n-\t\t\t\t\t ctx->get_mappings ()->lookup_location (\n-\t\t\t\t\t   type.get_ty_ref ()));\n-\n-    ctx->push_type (named_struct);\n-    ctx->insert_compiled_type (type.get_ty_ref (), named_struct, &type);\n-    translated = named_struct;\n-  }\n-\n-  void visit (const TyTy::ArrayType &type) override\n-  {\n-    tree element_type\n-      = TyTyResolveCompile::compile (ctx, type.get_element_type ());\n-    translated\n-      = ctx->get_backend ()->array_type (element_type, type.get_capacity ());\n-  }\n-\n-  void visit (const TyTy::BoolType &type) override\n-  {\n-    tree compiled_type = nullptr;\n-    bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n-    rust_assert (ok);\n-    translated = compiled_type;\n-  }\n-\n-  void visit (const TyTy::IntType &type) override\n-  {\n-    tree compiled_type = nullptr;\n-    bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n-    rust_assert (ok);\n-    translated = compiled_type;\n-  }\n-\n-  void visit (const TyTy::UintType &type) override\n-  {\n-    tree compiled_type = nullptr;\n-    bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n-    rust_assert (ok);\n-    translated = compiled_type;\n-  }\n-\n-  void visit (const TyTy::FloatType &type) override\n-  {\n-    tree compiled_type = nullptr;\n-    bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n-    rust_assert (ok);\n-    translated = compiled_type;\n-  }\n-\n-  void visit (const TyTy::USizeType &type) override\n-  {\n-    tree compiled_type = nullptr;\n-    bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n-    rust_assert (ok);\n-    translated = compiled_type;\n-  }\n-\n-  void visit (const TyTy::ISizeType &type) override\n-  {\n-    tree compiled_type = nullptr;\n-    bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n-    rust_assert (ok);\n-    translated = compiled_type;\n-  }\n-\n-  void visit (const TyTy::CharType &type) override\n-  {\n-    tree compiled_type = nullptr;\n-    bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n-    rust_assert (ok);\n-    translated = compiled_type;\n-  }\n-\n-  void visit (const TyTy::ReferenceType &type) override\n-  {\n-    tree base_compiled_type\n-      = TyTyResolveCompile::compile (ctx, type.get_base (), trait_object_mode);\n-    if (type.is_mutable ())\n-      {\n-\ttranslated = ctx->get_backend ()->reference_type (base_compiled_type);\n-      }\n-    else\n-      {\n-\tauto base = ctx->get_backend ()->immutable_type (base_compiled_type);\n-\ttranslated = ctx->get_backend ()->reference_type (base);\n-      }\n-  }\n-\n-  void visit (const TyTy::PointerType &type) override\n-  {\n-    tree base_compiled_type\n-      = TyTyResolveCompile::compile (ctx, type.get_base (), trait_object_mode);\n-    if (type.is_mutable ())\n-      {\n-\ttranslated = ctx->get_backend ()->pointer_type (base_compiled_type);\n-      }\n-    else\n-      {\n-\tauto base = ctx->get_backend ()->immutable_type (base_compiled_type);\n-\ttranslated = ctx->get_backend ()->pointer_type (base);\n-      }\n-  }\n-\n-  void visit (const TyTy::StrType &type) override\n-  {\n-    tree compiled_type = nullptr;\n-    bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n-    rust_assert (ok);\n-    translated = compiled_type;\n-  }\n-\n-  void visit (const TyTy::NeverType &) override\n-  {\n-    translated = ctx->get_backend ()->unit_type ();\n-  }\n-\n-  void visit (const TyTy::DynamicObjectType &type) override\n-  {\n-    if (trait_object_mode)\n-      {\n-\ttranslated = ctx->get_backend ()->integer_type (\n-\t  true, ctx->get_backend ()->get_pointer_size ());\n-\treturn;\n-      }\n-\n-    if (ctx->lookup_compiled_types (type.get_ty_ref (), &translated, &type))\n-      return;\n-\n-    // create implicit struct\n-    auto items = type.get_object_items ();\n-    std::vector<Backend::typed_identifier> fields;\n-\n-    tree uint = ctx->get_backend ()->integer_type (\n-      true, ctx->get_backend ()->get_pointer_size ());\n-    tree uintptr_ty = ctx->get_backend ()->pointer_type (uint);\n-\n-    Backend::typed_identifier f (\"__receiver_trait_obj_ptr\", uintptr_ty,\n-\t\t\t\t ctx->get_mappings ()->lookup_location (\n-\t\t\t\t   type.get_ty_ref ()));\n-    fields.push_back (std::move (f));\n-\n-    for (size_t i = 0; i < items.size (); i++)\n-      {\n-\t// mrustc seems to make a vtable consisting of uintptr's\n-\ttree uint = ctx->get_backend ()->integer_type (\n-\t  true, ctx->get_backend ()->get_pointer_size ());\n-\ttree uintptr_ty = ctx->get_backend ()->pointer_type (uint);\n-\n-\tBackend::typed_identifier f (\"__\" + std::to_string (i), uintptr_ty,\n-\t\t\t\t     ctx->get_mappings ()->lookup_location (\n-\t\t\t\t       type.get_ty_ref ()));\n-\tfields.push_back (std::move (f));\n-      }\n-\n-    tree type_record = ctx->get_backend ()->struct_type (fields);\n-    tree named_struct\n-      = ctx->get_backend ()->named_type (type.get_name (), type_record,\n-\t\t\t\t\t ctx->get_mappings ()->lookup_location (\n-\t\t\t\t\t   type.get_ty_ref ()));\n-\n-    ctx->push_type (named_struct);\n-    translated = named_struct;\n-\n-    ctx->insert_compiled_type (type.get_ty_ref (), named_struct, &type);\n-  }\n-\n-  void visit (const TyTy::ClosureType &) override { gcc_unreachable (); }\n-\n-private:\n-  TyTyResolveCompile (Context *ctx, bool trait_object_mode)\n-    : ctx (ctx), trait_object_mode (trait_object_mode), translated (nullptr),\n-      recursion_count (0)\n-  {}\n-\n-  Context *ctx;\n-  bool trait_object_mode;\n-  tree translated;\n-  size_t recursion_count;\n-\n-  static const size_t kDefaultRecusionLimit = 5;\n-};\n-\n } // namespace Compile\n } // namespace Rust\n "}, {"sha": "76ab4db289146000d32a5b3d93a78d3156695ccf", "filename": "gcc/rust/backend/rust-compile-type.cc", "status": "added", "additions": 371, "deletions": 0, "changes": 371, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40aae6224b1bab4825b11a1d16ea73ba52a04d6b/gcc%2Frust%2Fbackend%2Frust-compile-type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40aae6224b1bab4825b11a1d16ea73ba52a04d6b/gcc%2Frust%2Fbackend%2Frust-compile-type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-type.cc?ref=40aae6224b1bab4825b11a1d16ea73ba52a04d6b", "patch": "@@ -0,0 +1,371 @@\n+// Copyright (C) 2020-2021 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-compile-type.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+void\n+TyTyResolveCompile::visit (const TyTy::ErrorType &)\n+{\n+  gcc_unreachable ();\n+}\n+void\n+TyTyResolveCompile::visit (const TyTy::InferType &)\n+{\n+  gcc_unreachable ();\n+}\n+void\n+TyTyResolveCompile::visit (const TyTy::ClosureType &)\n+{\n+  gcc_unreachable ();\n+}\n+\n+void\n+TyTyResolveCompile::visit (const TyTy::ProjectionType &type)\n+{\n+  type.get ()->accept_vis (*this);\n+}\n+\n+void\n+TyTyResolveCompile::visit (const TyTy::PlaceholderType &type)\n+{\n+  type.resolve ()->accept_vis (*this);\n+}\n+\n+void\n+TyTyResolveCompile::visit (const TyTy::ParamType &param)\n+{\n+  recursion_count++;\n+  rust_assert (recursion_count < kDefaultRecusionLimit);\n+\n+  param.resolve ()->accept_vis (*this);\n+}\n+\n+void\n+TyTyResolveCompile::visit (const TyTy::FnType &type)\n+{\n+  Backend::typed_identifier receiver;\n+  std::vector<Backend::typed_identifier> parameters;\n+  std::vector<Backend::typed_identifier> results;\n+\n+  if (!type.get_return_type ()->is_unit ())\n+    {\n+      auto hir_type = type.get_return_type ();\n+      auto ret = TyTyResolveCompile::compile (ctx, hir_type, trait_object_mode);\n+      results.push_back (Backend::typed_identifier (\n+\t\"_\", ret,\n+\tctx->get_mappings ()->lookup_location (hir_type->get_ref ())));\n+    }\n+\n+  for (auto &param_pair : type.get_params ())\n+    {\n+      auto param_tyty = param_pair.second;\n+      auto compiled_param_type\n+\t= TyTyResolveCompile::compile (ctx, param_tyty, trait_object_mode);\n+\n+      auto compiled_param = Backend::typed_identifier (\n+\tparam_pair.first->as_string (), compiled_param_type,\n+\tctx->get_mappings ()->lookup_location (param_tyty->get_ref ()));\n+\n+      parameters.push_back (compiled_param);\n+    }\n+\n+  if (!type.is_varadic ())\n+    translated = ctx->get_backend ()->function_type (\n+      receiver, parameters, results, NULL,\n+      ctx->get_mappings ()->lookup_location (type.get_ref ()));\n+  else\n+    translated = ctx->get_backend ()->function_type_varadic (\n+      receiver, parameters, results, NULL,\n+      ctx->get_mappings ()->lookup_location (type.get_ref ()));\n+}\n+\n+void\n+TyTyResolveCompile::visit (const TyTy::FnPtr &type)\n+{\n+  tree result_type = TyTyResolveCompile::compile (ctx, type.get_return_type ());\n+\n+  std::vector<tree> parameters;\n+  type.iterate_params ([&] (TyTy::BaseType *p) mutable -> bool {\n+    tree pty = TyTyResolveCompile::compile (ctx, p);\n+    parameters.push_back (pty);\n+    return true;\n+  });\n+\n+  translated = ctx->get_backend ()->function_ptr_type (\n+    result_type, parameters,\n+    ctx->get_mappings ()->lookup_location (type.get_ref ()));\n+}\n+\n+void\n+TyTyResolveCompile::visit (const TyTy::ADTType &type)\n+{\n+  if (ctx->lookup_compiled_types (type.get_ty_ref (), &translated, &type))\n+    return;\n+\n+  // we dont support enums yet\n+  rust_assert (!type.is_enum ());\n+  rust_assert (type.number_of_variants () == 1);\n+\n+  TyTy::VariantDef &variant = *type.get_variants ().at (0);\n+  std::vector<Backend::typed_identifier> fields;\n+  for (size_t i = 0; i < variant.num_fields (); i++)\n+    {\n+      const TyTy::StructFieldType *field = variant.get_field_at_index (i);\n+      tree compiled_field_ty\n+\t= TyTyResolveCompile::compile (ctx, field->get_field_type ());\n+\n+      Backend::typed_identifier f (field->get_name (), compiled_field_ty,\n+\t\t\t\t   ctx->get_mappings ()->lookup_location (\n+\t\t\t\t     type.get_ty_ref ()));\n+      fields.push_back (std::move (f));\n+    }\n+\n+  tree type_record;\n+  if (type.is_union ())\n+    type_record = ctx->get_backend ()->union_type (fields);\n+  else\n+    type_record = ctx->get_backend ()->struct_type (fields);\n+  tree named_struct\n+    = ctx->get_backend ()->named_type (type.get_name (), type_record,\n+\t\t\t\t       ctx->get_mappings ()->lookup_location (\n+\t\t\t\t\t type.get_ty_ref ()));\n+\n+  ctx->push_type (named_struct);\n+  translated = named_struct;\n+\n+  ctx->insert_compiled_type (type.get_ty_ref (), named_struct, &type);\n+}\n+\n+void\n+TyTyResolveCompile::visit (const TyTy::TupleType &type)\n+{\n+  if (type.num_fields () == 0)\n+    {\n+      translated = ctx->get_backend ()->unit_type ();\n+      return;\n+    }\n+\n+  bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &translated, &type);\n+  if (ok)\n+    return;\n+\n+  // create implicit struct\n+  std::vector<Backend::typed_identifier> fields;\n+  for (size_t i = 0; i < type.num_fields (); i++)\n+    {\n+      TyTy::BaseType *field = type.get_field (i);\n+      tree compiled_field_ty = TyTyResolveCompile::compile (ctx, field);\n+\n+      // rustc uses the convention __N, where N is an integer, to\n+      // name the fields of a tuple.  We follow this as well,\n+      // because this is used by GDB.  One further reason to prefer\n+      // this, rather than simply emitting the integer, is that this\n+      // approach makes it simpler to use a C-only debugger, or\n+      // GDB's C mode, when debugging Rust.\n+      Backend::typed_identifier f (\"__\" + std::to_string (i), compiled_field_ty,\n+\t\t\t\t   ctx->get_mappings ()->lookup_location (\n+\t\t\t\t     type.get_ty_ref ()));\n+      fields.push_back (std::move (f));\n+    }\n+\n+  tree struct_type_record = ctx->get_backend ()->struct_type (fields);\n+  tree named_struct\n+    = ctx->get_backend ()->named_type (type.as_string (), struct_type_record,\n+\t\t\t\t       ctx->get_mappings ()->lookup_location (\n+\t\t\t\t\t type.get_ty_ref ()));\n+\n+  ctx->push_type (named_struct);\n+  ctx->insert_compiled_type (type.get_ty_ref (), named_struct, &type);\n+  translated = named_struct;\n+}\n+\n+void\n+TyTyResolveCompile::visit (const TyTy::ArrayType &type)\n+{\n+  tree element_type\n+    = TyTyResolveCompile::compile (ctx, type.get_element_type ());\n+  translated\n+    = ctx->get_backend ()->array_type (element_type, type.get_capacity ());\n+}\n+\n+void\n+TyTyResolveCompile::visit (const TyTy::BoolType &type)\n+{\n+  tree compiled_type = nullptr;\n+  bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n+  rust_assert (ok);\n+  translated = compiled_type;\n+}\n+\n+void\n+TyTyResolveCompile::visit (const TyTy::IntType &type)\n+{\n+  tree compiled_type = nullptr;\n+  bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n+  rust_assert (ok);\n+  translated = compiled_type;\n+}\n+\n+void\n+TyTyResolveCompile::visit (const TyTy::UintType &type)\n+{\n+  tree compiled_type = nullptr;\n+  bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n+  rust_assert (ok);\n+  translated = compiled_type;\n+}\n+\n+void\n+TyTyResolveCompile::visit (const TyTy::FloatType &type)\n+{\n+  tree compiled_type = nullptr;\n+  bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n+  rust_assert (ok);\n+  translated = compiled_type;\n+}\n+\n+void\n+TyTyResolveCompile::visit (const TyTy::USizeType &type)\n+{\n+  tree compiled_type = nullptr;\n+  bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n+  rust_assert (ok);\n+  translated = compiled_type;\n+}\n+\n+void\n+TyTyResolveCompile::visit (const TyTy::ISizeType &type)\n+{\n+  tree compiled_type = nullptr;\n+  bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n+  rust_assert (ok);\n+  translated = compiled_type;\n+}\n+\n+void\n+TyTyResolveCompile::visit (const TyTy::CharType &type)\n+{\n+  tree compiled_type = nullptr;\n+  bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n+  rust_assert (ok);\n+  translated = compiled_type;\n+}\n+\n+void\n+TyTyResolveCompile::visit (const TyTy::ReferenceType &type)\n+{\n+  tree base_compiled_type\n+    = TyTyResolveCompile::compile (ctx, type.get_base (), trait_object_mode);\n+  if (type.is_mutable ())\n+    {\n+      translated = ctx->get_backend ()->reference_type (base_compiled_type);\n+    }\n+  else\n+    {\n+      auto base = ctx->get_backend ()->immutable_type (base_compiled_type);\n+      translated = ctx->get_backend ()->reference_type (base);\n+    }\n+}\n+\n+void\n+TyTyResolveCompile::visit (const TyTy::PointerType &type)\n+{\n+  tree base_compiled_type\n+    = TyTyResolveCompile::compile (ctx, type.get_base (), trait_object_mode);\n+  if (type.is_mutable ())\n+    {\n+      translated = ctx->get_backend ()->pointer_type (base_compiled_type);\n+    }\n+  else\n+    {\n+      auto base = ctx->get_backend ()->immutable_type (base_compiled_type);\n+      translated = ctx->get_backend ()->pointer_type (base);\n+    }\n+}\n+\n+void\n+TyTyResolveCompile::visit (const TyTy::StrType &type)\n+{\n+  tree compiled_type = nullptr;\n+  bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n+  rust_assert (ok);\n+  translated = compiled_type;\n+}\n+\n+void\n+TyTyResolveCompile::visit (const TyTy::NeverType &)\n+{\n+  translated = ctx->get_backend ()->unit_type ();\n+}\n+\n+void\n+TyTyResolveCompile::visit (const TyTy::DynamicObjectType &type)\n+{\n+  if (trait_object_mode)\n+    {\n+      translated = ctx->get_backend ()->integer_type (\n+\ttrue, ctx->get_backend ()->get_pointer_size ());\n+      return;\n+    }\n+\n+  if (ctx->lookup_compiled_types (type.get_ty_ref (), &translated, &type))\n+    return;\n+\n+  // create implicit struct\n+  auto items = type.get_object_items ();\n+  std::vector<Backend::typed_identifier> fields;\n+\n+  tree uint = ctx->get_backend ()->integer_type (\n+    true, ctx->get_backend ()->get_pointer_size ());\n+  tree uintptr_ty = ctx->get_backend ()->pointer_type (uint);\n+\n+  Backend::typed_identifier f (\"__receiver_trait_obj_ptr\", uintptr_ty,\n+\t\t\t       ctx->get_mappings ()->lookup_location (\n+\t\t\t\t type.get_ty_ref ()));\n+  fields.push_back (std::move (f));\n+\n+  for (size_t i = 0; i < items.size (); i++)\n+    {\n+      // mrustc seems to make a vtable consisting of uintptr's\n+      tree uint = ctx->get_backend ()->integer_type (\n+\ttrue, ctx->get_backend ()->get_pointer_size ());\n+      tree uintptr_ty = ctx->get_backend ()->pointer_type (uint);\n+\n+      Backend::typed_identifier f (\"__\" + std::to_string (i), uintptr_ty,\n+\t\t\t\t   ctx->get_mappings ()->lookup_location (\n+\t\t\t\t     type.get_ty_ref ()));\n+      fields.push_back (std::move (f));\n+    }\n+\n+  tree type_record = ctx->get_backend ()->struct_type (fields);\n+  tree named_struct\n+    = ctx->get_backend ()->named_type (type.get_name (), type_record,\n+\t\t\t\t       ctx->get_mappings ()->lookup_location (\n+\t\t\t\t\t type.get_ty_ref ()));\n+\n+  ctx->push_type (named_struct);\n+  translated = named_struct;\n+\n+  ctx->insert_compiled_type (type.get_ty_ref (), named_struct, &type);\n+}\n+\n+} // namespace Compile\n+} // namespace Rust"}, {"sha": "f62581fbfad4fda2d60ccd5c14740658aaa775be", "filename": "gcc/rust/backend/rust-compile-type.h", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40aae6224b1bab4825b11a1d16ea73ba52a04d6b/gcc%2Frust%2Fbackend%2Frust-compile-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40aae6224b1bab4825b11a1d16ea73ba52a04d6b/gcc%2Frust%2Fbackend%2Frust-compile-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-type.h?ref=40aae6224b1bab4825b11a1d16ea73ba52a04d6b", "patch": "@@ -0,0 +1,79 @@\n+// Copyright (C) 2020-2021 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_COMPILE_TYPE\n+#define RUST_COMPILE_TYPE\n+\n+#include \"rust-compile-context.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+class TyTyResolveCompile : public TyTy::TyConstVisitor\n+{\n+public:\n+  static tree compile (Context *ctx, const TyTy::BaseType *ty,\n+\t\t       bool trait_object_mode = false)\n+  {\n+    TyTyResolveCompile compiler (ctx, trait_object_mode);\n+    ty->accept_vis (compiler);\n+    return compiler.translated;\n+  }\n+\n+  void visit (const TyTy::InferType &) override;\n+  void visit (const TyTy::ADTType &) override;\n+  void visit (const TyTy::TupleType &) override;\n+  void visit (const TyTy::FnType &) override;\n+  void visit (const TyTy::FnPtr &) override;\n+  void visit (const TyTy::ArrayType &) override;\n+  void visit (const TyTy::BoolType &) override;\n+  void visit (const TyTy::IntType &) override;\n+  void visit (const TyTy::UintType &) override;\n+  void visit (const TyTy::FloatType &) override;\n+  void visit (const TyTy::USizeType &) override;\n+  void visit (const TyTy::ISizeType &) override;\n+  void visit (const TyTy::ErrorType &) override;\n+  void visit (const TyTy::CharType &) override;\n+  void visit (const TyTy::ReferenceType &) override;\n+  void visit (const TyTy::PointerType &) override;\n+  void visit (const TyTy::ParamType &) override;\n+  void visit (const TyTy::StrType &) override;\n+  void visit (const TyTy::NeverType &) override;\n+  void visit (const TyTy::PlaceholderType &) override;\n+  void visit (const TyTy::ProjectionType &) override;\n+  void visit (const TyTy::DynamicObjectType &) override;\n+  void visit (const TyTy::ClosureType &) override;\n+\n+private:\n+  TyTyResolveCompile (Context *ctx, bool trait_object_mode)\n+    : ctx (ctx), trait_object_mode (trait_object_mode), translated (nullptr),\n+      recursion_count (0)\n+  {}\n+\n+  Context *ctx;\n+  bool trait_object_mode;\n+  tree translated;\n+  size_t recursion_count;\n+\n+  static const size_t kDefaultRecusionLimit = 5;\n+};\n+\n+} // namespace Compile\n+} // namespace Rust\n+\n+#endif // RUST_COMPILE_TYPE"}]}