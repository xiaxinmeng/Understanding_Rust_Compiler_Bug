{"sha": "1e248c55a78d8689c97897fa13368cf3a769fa16", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWUyNDhjNTVhNzhkODY4OWM5Nzg5N2ZhMTMzNjhjZjNhNzY5ZmExNg==", "commit": {"author": {"name": "Bruce Korb", "email": "bkorb@gnu.org", "date": "2000-05-16T14:23:47Z"}, "committer": {"name": "Bruce Korb", "email": "korbb@gcc.gnu.org", "date": "2000-05-16T14:23:47Z"}, "message": "corrected and rewrote char_macro_* fixes to parse the text with regexes\n\nFrom-SVN: r33931", "tree": {"sha": "c41ee9ca0fe919a0255b44baf1c515676e662088", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c41ee9ca0fe919a0255b44baf1c515676e662088"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1e248c55a78d8689c97897fa13368cf3a769fa16", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e248c55a78d8689c97897fa13368cf3a769fa16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e248c55a78d8689c97897fa13368cf3a769fa16", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e248c55a78d8689c97897fa13368cf3a769fa16/comments", "author": {"login": "brkorb", "id": 1242936, "node_id": "MDQ6VXNlcjEyNDI5MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1242936?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brkorb", "html_url": "https://github.com/brkorb", "followers_url": "https://api.github.com/users/brkorb/followers", "following_url": "https://api.github.com/users/brkorb/following{/other_user}", "gists_url": "https://api.github.com/users/brkorb/gists{/gist_id}", "starred_url": "https://api.github.com/users/brkorb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brkorb/subscriptions", "organizations_url": "https://api.github.com/users/brkorb/orgs", "repos_url": "https://api.github.com/users/brkorb/repos", "events_url": "https://api.github.com/users/brkorb/events{/privacy}", "received_events_url": "https://api.github.com/users/brkorb/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "79589c4d8bb8829579557f76b4e8974247b78895", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79589c4d8bb8829579557f76b4e8974247b78895", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79589c4d8bb8829579557f76b4e8974247b78895"}], "stats": {"total": 610, "additions": 326, "deletions": 284}, "files": [{"sha": "abd46fc1ecfd1f9ac8d91b235dcf319a6b4c3a49", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e248c55a78d8689c97897fa13368cf3a769fa16/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e248c55a78d8689c97897fa13368cf3a769fa16/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1e248c55a78d8689c97897fa13368cf3a769fa16", "patch": "@@ -1,3 +1,14 @@\n+\n+2000-05-16  Bruce Korb  <bkorb@gnu.org>\n+\n+\t* fixinc/README:  corrected return address\n+\t* fixinc/check.diff:  regenerate, now that test works\n+\t* fixinc/fixfixes.c(format_fix,format_write): reformatted\n+\t(char_macro_def_fix,char_macro_use_fix): corrected and\n+\trewrote to use regex to parse the text\n+\t* fixinc/inclhack.def: more testing\n+\t* fixinc/fixincl.x:  regenerated\n+\n 2000-05-16  Alexandre Oliva  <aoliva@cygnus.com>\n \n \t* config/mn10300/mn10300.h (ASM_OUTPUT_DWARF2_ADDR_CONST): Remove."}, {"sha": "5b65649f53525516d3ccf8334be21a37650f5155", "filename": "gcc/fixinc/README", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e248c55a78d8689c97897fa13368cf3a769fa16/gcc%2Ffixinc%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e248c55a78d8689c97897fa13368cf3a769fa16/gcc%2Ffixinc%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2FREADME?ref=1e248c55a78d8689c97897fa13368cf3a769fa16", "patch": "@@ -33,7 +33,7 @@ broken by the manufacturer, or is broken by the fixinclude process,\n then you will need to alter or add information to the include fix\n definitions file, ``inclhack.def''.  Please also send relevant\n information to gcc-bugs@gcc.gnu.org, gcc-patches@gcc.gnu.org and,\n-please, to me:  autogen@linuxbox.com.\n+please, to me:  bkorb@gnu.org.\n \n Here are the rules for making fixes in the inclhack.def file:\n \n@@ -109,6 +109,8 @@ Here are the rules for making fixes in the inclhack.def file:\n     3.  A C language subroutine method for both tests and fixes.\n         See ``fixtests.c'' for instructions on writing C-language\n         applicability tests and ``fixfixes.c'' for C-language fixing.\n+        These files also contain tables that describe the currently\n+        implemented fixes and tests.\n \n     4.  Replacement text.  If the replacement is empty, then no\n         fix is applied.  Otherwise, the replacement text is"}, {"sha": "3fa1e9128793c41c568d8156ce078693ad664822", "filename": "gcc/fixinc/check.diff", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e248c55a78d8689c97897fa13368cf3a769fa16/gcc%2Ffixinc%2Fcheck.diff", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e248c55a78d8689c97897fa13368cf3a769fa16/gcc%2Ffixinc%2Fcheck.diff", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Fcheck.diff?ref=1e248c55a78d8689c97897fa13368cf3a769fa16", "patch": "@@ -704,16 +704,6 @@\n *** 1,33 ****\n   \n   \n-  #ifndef IO_QUOTES_DEF_CHECK\n-! #define BSD43__IOWR(n, x) (('n'<<8)+x)\n-  #endif  /* IO_QUOTES_DEF_CHECK */\n-  \n-  \n-  #ifndef IO_QUOTES_USE_CHECK\n-! #define TIOCFOO BSD43__IOWR(T, 1)\n-  #endif  /* IO_QUOTES_USE_CHECK */\n-  \n-  \n   #ifndef CTRL_QUOTES_DEF_CHECK\n ! #define BSD43_CTRL(n, x) (('n'<<8)+x)\n   #endif  /* CTRL_QUOTES_DEF_CHECK */\n@@ -724,6 +714,16 @@\n   #endif  /* CTRL_QUOTES_USE_CHECK */\n   \n   \n+  #ifndef IO_QUOTES_DEF_CHECK\n+! #define BSD43__IOWR(n, x) (('n'<<8)+x)\n+  #endif  /* IO_QUOTES_DEF_CHECK */\n+  \n+  \n+  #ifndef IO_QUOTES_USE_CHECK\n+! #define TIOCFOO BSD43__IOWR(T, 1)\n+  #endif  /* IO_QUOTES_USE_CHECK */\n+  \n+  \n   #ifndef MACHINE_NAME_CHECK\n ! #ifdef i386 /* no uniform machine_name test, so\n                  this only works on i?86 machines */\n@@ -738,16 +738,6 @@\n --- 1,37 ----\n   \n   \n-  #ifndef IO_QUOTES_DEF_CHECK\n-! #define BSD43__IOWR(n, x) ((n<<8)+x)\n-  #endif  /* IO_QUOTES_DEF_CHECK */\n-  \n-  \n-  #ifndef IO_QUOTES_USE_CHECK\n-! #define TIOCFOO BSD43__IOWR('T', 1)\n-  #endif  /* IO_QUOTES_USE_CHECK */\n-  \n-  \n   #ifndef CTRL_QUOTES_DEF_CHECK\n ! #define BSD43_CTRL(n, x) ((n<<8)+x)\n   #endif  /* CTRL_QUOTES_DEF_CHECK */\n@@ -758,6 +748,16 @@\n   #endif  /* CTRL_QUOTES_USE_CHECK */\n   \n   \n+  #ifndef IO_QUOTES_DEF_CHECK\n+! #define BSD43__IOWR(n, x) ((n<<8)+x)\n+  #endif  /* IO_QUOTES_DEF_CHECK */\n+  \n+  \n+  #ifndef IO_QUOTES_USE_CHECK\n+! #define TIOCFOO BSD43__IOWR('T', 1)\n+  #endif  /* IO_QUOTES_USE_CHECK */\n+  \n+  \n   #ifndef MACHINE_NAME_CHECK\n ! #ifdef __i386__ /* no uniform machine_name test, so\n                  this only works on i?86 machines */"}, {"sha": "35dfc361e9125260e0e6c36cdeae2b66ea661f94", "filename": "gcc/fixinc/fixfixes.c", "status": "modified", "additions": 292, "deletions": 263, "changes": 555, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e248c55a78d8689c97897fa13368cf3a769fa16/gcc%2Ffixinc%2Ffixfixes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e248c55a78d8689c97897fa13368cf3a769fa16/gcc%2Ffixinc%2Ffixfixes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Ffixfixes.c?ref=1e248c55a78d8689c97897fa13368cf3a769fa16", "patch": "@@ -121,117 +121,137 @@ print_quote( q, text )\n   return text;\n }\n \n+\n+/*\n+ *  Copy the `format' string to std out, replacing `%n' expressions\n+ *  with the matched text from a regular expression evaluation.\n+ *  Doubled '%' characters will be replaced with a single copy.\n+ *  '%' characters in other contexts and all other characters are\n+ *  copied out verbatim.\n+ */\n static void\n format_write (format, text, av)\n      tCC* format;\n      tCC* text;\n      regmatch_t av[];\n {\n-    int c;\n+  int c;\n \n-    while ((c = (unsigned)*(format++)) != NUL) {\n+  while ((c = (unsigned)*(format++)) != NUL) {\n \n-        if (c != '%') {\n-            putchar(c);\n-            continue;\n-        }\n+    if (c != '%')\n+      {\n+        putchar(c);\n+        continue;\n+      }\n \n-        c = (unsigned)*(format++);\n-\n-        /*\n-         *  IF the character following a '%' is not a digit,\n-         *  THEN we will always emit a '%' and we may or may\n-         *  not emit the following character.  We will end on\n-         *  a NUL and we will emit only one of a pair of '%'.\n-         */\n-        if (! isdigit( c )) {\n-            putchar( '%' );\n-            switch (c) {\n-            case NUL:\n-                return;\n-            case '%':\n-                break;\n-            default:\n-                putchar(c);\n-            }\n+    c = (unsigned)*(format++);\n+\n+    /*\n+     *  IF the character following a '%' is not a digit,\n+     *  THEN we will always emit a '%' and we may or may\n+     *  not emit the following character.  We will end on\n+     *  a NUL and we will emit only one of a pair of '%'.\n+     */\n+    if (! isdigit( c ))\n+      {\n+        putchar( '%' );\n+        switch (c) {\n+        case NUL:\n+          return;\n+        case '%':\n+          break;\n+        default:\n+          putchar(c);\n         }\n+      }\n \n-        /*\n-         *  Emit the matched subexpression numbered 'c'.\n-         *  IF, of course, there was such a match...\n-         */\n-        else {\n-            regmatch_t*  pRM = av + (c - (unsigned)'0');\n-            size_t len;\n+    /*\n+     *  Emit the matched subexpression numbered 'c'.\n+     *  IF, of course, there was such a match...\n+     */\n+    else {\n+      regmatch_t*  pRM = av + (c - (unsigned)'0');\n+      size_t len;\n \n-            if (pRM->rm_so < 0)\n-                continue;\n+      if (pRM->rm_so < 0)\n+        continue;\n \n-            len = pRM->rm_eo - pRM->rm_so;\n-            if (len > 0)\n-                fwrite(text + pRM->rm_so, len, 1, stdout);\n-        }\n+      len = pRM->rm_eo - pRM->rm_so;\n+      if (len > 0)\n+        fwrite(text + pRM->rm_so, len, 1, stdout);\n     }\n+  }\n }\n \n \n+/*\n+ *  Search for multiple copies of a regular expression.  Each block\n+ *  of matched text is replaced with the format string, as described\n+ *  above in `format_write'.\n+ */\n FIX_PROC_HEAD( format_fix )\n {\n-    tSCC  zBad[] = \"fixincl error:  `%s' needs %s c_fix_arg\\n\";\n-    tCC*  pz_pat = p_fixd->patch_args[2];\n-    tCC*  pz_fmt = p_fixd->patch_args[1];\n-    const char *p;\n-    regex_t re;\n-    regmatch_t rm[10];\n-\n-    /*\n-     *  We must have a format\n-     */\n-    if (pz_fmt == (tCC*)NULL) {\n-        fprintf( stderr, zBad, p_fixd->fix_name, \"replacement-format\" );\n-        exit( 3 );\n+  tSCC  zBad[] = \"fixincl error:  `%s' needs %s c_fix_arg\\n\";\n+  tCC*  pz_pat = p_fixd->patch_args[2];\n+  tCC*  pz_fmt = p_fixd->patch_args[1];\n+  const char *p;\n+  regex_t re;\n+  regmatch_t rm[10];\n+\n+  /*\n+   *  We must have a format\n+   */\n+  if (pz_fmt == (tCC*)NULL)\n+    {\n+      fprintf( stderr, zBad, p_fixd->fix_name, \"replacement-format\" );\n+      exit( 3 );\n     }\n \n-    /*\n-     *  IF we don't have a search text, then go find the first\n-     *  regular expression among the tests.\n-     */\n-    if (pz_pat == (tCC*)NULL) {\n-        tTestDesc* pTD = p_fixd->p_test_desc;\n-        int        ct  = p_fixd->test_ct;\n-        for (;;) {\n-            if (ct-- <= 0) {\n-                fprintf( stderr, zBad, p_fixd->fix_name, \"search-text\" );\n-                exit( 3 );\n+  /*\n+   *  IF we don't have a search text, then go find the first\n+   *  regular expression among the tests.\n+   */\n+  if (pz_pat == (tCC*)NULL)\n+    {\n+      tTestDesc* pTD = p_fixd->p_test_desc;\n+      int        ct  = p_fixd->test_ct;\n+      for (;;)\n+        {\n+          if (ct-- <= 0)\n+            {\n+              fprintf( stderr, zBad, p_fixd->fix_name, \"search-text\" );\n+              exit( 3 );\n             }\n \n-            if (pTD->type == TT_EGREP) {\n-                pz_pat = pTD->pz_test_text;\n-                break;\n+          if (pTD->type == TT_EGREP)\n+            {\n+              pz_pat = pTD->pz_test_text;\n+              break;\n             }\n \n-            pTD++;\n+          pTD++;\n         }\n     }\n \n-    /*\n-     *  Replace every copy of the text we find\n-     */\n-    compile_re (pz_pat, &re, 1, \"format search-text\", \"format_fix\" );\n-    while (regexec (&re, text, 10, rm, 0) == 0)\n+  /*\n+   *  Replace every copy of the text we find\n+   */\n+  compile_re (pz_pat, &re, 1, \"format search-text\", \"format_fix\" );\n+  while (regexec (&re, text, 10, rm, 0) == 0)\n     {\n-        char* apz[10];\n-        int   i;\n+      char* apz[10];\n+      int   i;\n \n-        fwrite( text, rm[0].rm_so, 1, stdout );\n-       format_write( pz_fmt, text, rm );\n-        text += rm[0].rm_eo;\n+      fwrite( text, rm[0].rm_so, 1, stdout );\n+      format_write( pz_fmt, text, rm );\n+      text += rm[0].rm_eo;\n     }\n \n-    /*\n-     *  Dump out the rest of the file\n-     */\n-    fputs (text, stdout);\n+  /*\n+   *  Dump out the rest of the file\n+   */\n+  fputs (text, stdout);\n }\n \n \n@@ -245,175 +265,184 @@ FIX_PROC_HEAD( format_fix )\n \n    which is the required syntax per the C standard.  (The definition of\n    _IO also has to be tweaked - see below.)  'IO' is actually whatever you\n-   provide in the STR argument.  */\n+   provide as the `c_fix_arg' argument.  */\n \n FIX_PROC_HEAD( char_macro_use_fix )\n {\n   /* This regexp looks for a traditional-syntax #define (# in column 1)\n      of an object-like macro.  */\n-  static const char pat[] =\n-    \"^#[ \\t]*define[ \\t]+[_A-Za-z][_A-Za-z0-9]*[ \\t]+\";\n+  static const char zPatFmt[] =\n+#ifdef __STDC__\n+    /*\n+     *  Match up to the replacement text\n+     */\n+    \"^#[ \\t]*define[ \\t]+[_A-Za-z][_A-Za-z0-9]*[ \\t]+\"\n+    /*\n+     *  Match the replacement macro name and openening parenthesis\n+     */\n+    \"[_A-Z][_A-Z0-9]*%s[A-Z]*\\\\(\"\n+    /*\n+     *  Match the single character that must be single-quoted,\n+     *  plus some other non-name type character\n+     */\n+    \"([A-Za-z])[^a-zA-Z0-9_]\"\n+#else\n+    /*\n+     *  Indecipherable gobbeldygook:\n+     */\n+\n+    \"^#[ \\t]*define[ \\t]+[_A-Za-z][_A-Za-z0-9]*[ \\t]+[_A-Z][_A-Z0-9]*\\\n+%s[A-Z]*\\\\(([A-Za-z])[^a-zA-Z0-9_]\"\n+#endif\n+    ;\n+\n+  char zPat[ sizeof( zPatFmt ) + 32 ];\n+\n   static regex_t re;\n \n-  regmatch_t rm[1];\n-  const char *p, *limit;\n-  const char *str = p_fixd->patch_args[0];\n-  size_t len;\n+  regmatch_t rm[2];\n \n-  if (str == NULL)\n+  if (p_fixd->patch_args[1] == NULL)\n     {\n       fprintf (stderr, \"%s needs macro-name-string argument\",\n               p_fixd->fix_name);\n       exit(3);\n     }\n \n-  len = strlen (str);\n-  compile_re (pat, &re, 1, \"macro pattern\", \"fix_char_macro_uses\");\n-\n-  for (p = text;\n-       regexec (&re, p, 1, rm, 0) == 0;\n-       p = limit + 1)\n+  if (sprintf( zPat, zPatFmt, p_fixd->patch_args[1] ) >= sizeof( zPat ))\n     {\n-      /* p + rm[0].rm_eo is the first character of the macro replacement.\n-\t Find the end of the macro replacement, and the STR we were\n-\t sent to look for within the replacement.  */\n-      p += rm[0].rm_eo;\n-      limit = p - 1;\n-      do\n-\t{\n-\t  limit = strchr (limit + 1, '\\n');\n-\t  if (!limit)\n-\t    goto done;\n-\t}\n-      while (limit[-1] == '\\\\');\n+      fprintf( stderr, \"Oversize format:  %s\\n\", zPat );\n+      exit(3);\n+    }\n \n-      do\n-\t{\n-\t  if (*p == str[0] && !strncmp (p+1, str+1, len-1))\n-\t    goto found;\n-\t}\n-      while (++p < limit - len);\n-      /* Hit end of line.  */\n-      continue;\n-\n-    found:\n-      /* Found STR on this line.  If the macro needs fixing,\n-\t the next few chars will be whitespace or uppercase,\n-\t then an open paren, then a single letter.  */\n-      while ((isspace (*p) || isupper (*p)) && p < limit) p++;\n-      if (*p++ != '(')\n-\tcontinue;\n-      if (!isalpha (*p))\n-\tcontinue;\n-      if (isalnum (p[1]) || p[1] == '_')\n-\tcontinue;\n-\n-      /* Splat all preceding text into the output buffer,\n-\t quote the character at p, then proceed.  */\n-      fwrite (text, 1, p - text, stdout);\n-      putchar ('\\'');\n-      putchar (*p);\n-      putchar ('\\'');\n-      text = p + 1;\n+  compile_re (zPat, &re, 2, \"macro pattern\", \"char_macro_use_fix\");\n+\n+  while (regexec (&re, text, 3, rm, 0) == 0)\n+    {\n+      const char* pz = text + rm[1].rm_so;\n+\n+      /*\n+       *  Write up to, but not including, the character we must quote\n+       */\n+      fwrite( text, 1, rm[1].rm_so, stdout );\n+      fputc( '\\'', stdout );\n+      fputc( *(pz++), stdout );\n+      fputc( '\\'', stdout );\n+      text = pz;\n     }\n- done:\n+\n   fputs (text, stdout);\n }\n \n+\n /* Scan the input file for all occurrences of text like this:\n \n-   #define _IO(x, y) ('x'<<16+y)\n+   #define xxxIOxx(x, y) ('x'<<16+y)\n \n    and change them to read like this:\n \n-   #define _IO(x, y) (x<<16+y)\n+   #define xxxIOxx(x, y) (x<<16+y)\n \n    which is the required syntax per the C standard.  (The uses of _IO\n-   also have to be tweaked - see above.)  'IO' is actually whatever\n-   you provide in the STR argument.  */\n+   also has to be tweaked - see above.)  'IO' is actually whatever\n+   you provide as the `c_fix_arg' argument.  */\n FIX_PROC_HEAD( char_macro_def_fix )\n {\n-  /* This regexp looks for any traditional-syntax #define (# in col 1). */\n-  static const char pat[] =\n-    \"^#[ \\t]*define[ \\t]+\";\n+  static const char zPatFmt[] =\n+#ifdef __STDC__\n+    /*\n+     *  Find a #define name and opening parenthesis\n+     */\n+    \"^#[ \\t]*define[ \\t]+[_A-Z][A-Z0-9_]*%s[A-Z]*\\\\(\"\n+    /*\n+     *  The next character must be alphabetic without a name-type\n+     *  character following it\n+     */\n+    \"([a-zA-Z])[^a-zA-Z0-9_]\"  /* rm[1] */\n+    /*\n+     *  now match over the argument list, intervening white space\n+     *  and opening parentheses, and on through a single quote character\n+     */\n+    \"[^)]*\\\\)[ \\t]+\\\\([ \\t(]*'\"\n+    /*\n+     *  Match the character that must match the remembered char above\n+     */\n+    \"([a-zA-Z])'\"  /* rm[2] */\n+#else\n+    /*\n+     *  Indecipherable gobbeldygook:\n+     */\n+\n+    \"^#[ \\t]*define[ \\t]+[_A-Z][A-Z0-9_]*%s[A-Z]*\\\\(([a-zA-Z])[^a-zA-Z0-9_]\\\n+[^)]*\\\\)[ \\t]+\\\\([ \\t(]*'([a-zA-Z])'\"\n+#endif\n+    ;\n+\n+  char zPat[ sizeof( zPatFmt ) + 32 ];\n+\n   static regex_t re;\n \n-  regmatch_t rm[1];\n-  const char *p, *limit;\n-  const char *str = p_fixd->patch_args[0];\n-  size_t len;\n-  char arg;\n+  regmatch_t rm[3];\n+  const char *p;\n+  int  rerr;\n \n-  if (str == NULL)\n+  if (p_fixd->patch_args[1] == NULL)\n     {\n       fprintf (stderr, \"%s needs macro-name-string argument\",\n               p_fixd->fix_name);\n       exit(3);\n     }\n \n-  compile_re (pat, &re, 1, \"macro pattern\", \"fix_char_macro_defines\");\n+  if (sprintf( zPat, zPatFmt, p_fixd->patch_args[1] ) >= sizeof( zPat ))\n+    {\n+      fprintf( stderr, \"Oversize format:  %s\\n\", zPat );\n+      exit(3);\n+    }\n+\n+  compile_re (zPat, &re, 1, \"macro pattern\", \"char_macro_def_fix\");\n \n-  for (p = text;\n-       regexec (&re, p, 1, rm, 0) == 0;\n-       p = limit + 1)\n+  if ((rerr = regexec (&re, text, 3, rm, 0)) != 0)\n     {\n-      /* p + rm[0].rm_eo is the first character of the macro name.\n-\t Find the end of the macro replacement, and the STR we were\n-\t sent to look for within the name.  */\n-      p += rm[0].rm_eo;\n-      limit = p - 1;\n-      do\n-\t{\n-\t  limit = strchr (limit + 1, '\\n');\n-\t  if (!limit)\n-\t    goto done;\n-\t}\n-      while (limit[-1] == '\\\\');\n+      fprintf( stderr, \"Match error %d:\\n%s\\n\", rerr, zPat );\n+      exit(3);\n+    }\n \n-      do\n-\t{\n-\t  if (*p == str[0] && !strncmp (p+1, str+1, len-1))\n-\t    goto found;\n-\t  p++;\n-\t}\n-      while (isalpha (*p) || isalnum (*p) || *p == '_');\n-      /* Hit end of macro name without finding the string.  */\n-      continue;\n-\n-    found:\n-      /* Found STR in this macro name.  If the macro needs fixing,\n-\t there may be a few uppercase letters, then there will be an\n-\t open paren with _no_ intervening whitespace, and then a\n-\t single letter.  */\n-      while (isupper (*p) && p < limit) p++;\n-      if (*p++ != '(')\n-\tcontinue;\n-      if (!isalpha (*p))\n-\tcontinue;\n-      if (isalnum (p[1]) || p[1] == '_')\n-\tcontinue;\n-\n-      /* The character at P is the one to look for in the following\n-\t text.  */\n-      arg = *p;\n-      p += 2;\n-\n-      while (p < limit)\n-\t{\n-\t  if (p[-1] == '\\'' && p[0] == arg && p[1] == '\\'')\n-\t    {\n-\t      /* Remove the quotes from this use of ARG.  */\n-\t      p--;\n-\t      fwrite (text, 1, p - text, stdout);\n-\t      putchar (arg);\n-\t      p += 3;\n-\t      text = p;\n-\t    }\n-\t  else\n-\t    p++;\n-\t}\n+  while ((rerr = regexec (&re, text, 3, rm, 0)) == 0)\n+    {\n+      const char* pz = text + rm[2].rm_so;\n+\n+      /*\n+       *  Write up to, but not including, the opening single quote.\n+       */\n+      fwrite( text, 1, rm[2].rm_so-1, stdout );\n+\n+      /*\n+       *  The character inside the single quotes must match the\n+       *  first single-character macro argument\n+       */\n+      if (text[ rm[1].rm_so ] != *pz)\n+        {\n+          /*\n+           *  Advance text past what we have written out and continue\n+           */\n+          text = pz-1;\n+          continue;\n+        }\n+\n+      /*\n+       *  emit the now unquoted character\n+       */\n+      putchar( *pz );\n+\n+      /*\n+       *  Point text to the character after the closing single quote\n+       */\n+      text = pz+2;\n     }\n- done:\n+\n+  /*\n+   *  Emit the rest of the text\n+   */\n   fputs (text, stdout);\n }\n \n@@ -447,71 +476,71 @@ FIX_PROC_HEAD( machine_name_fix )\n     {\n       base += match[0].rm_eo;\n       /* We're looking at an #if or #ifdef.  Scan forward for the\n-\t next non-escaped newline.  */\n+         next non-escaped newline.  */\n       line = limit = base;\n       do\n-\t{\n-\t  limit++;\n-\t  limit = strchr (limit, '\\n');\n-\t  if (!limit)\n-\t    goto done;\n-\t}\n+        {\n+          limit++;\n+          limit = strchr (limit, '\\n');\n+          if (!limit)\n+            goto done;\n+        }\n       while (limit[-1] == '\\\\');\n \n       /* If the 'name_pat' matches in between base and limit, we have\n-\t a bogon.  It is not worth the hassle of excluding comments\n-\t because comments on #if/#ifdef lines are rare, and strings on\n-\t such lines are illegal.\n+         a bogon.  It is not worth the hassle of excluding comments\n+         because comments on #if/#ifdef lines are rare, and strings on\n+         such lines are illegal.\n \n-\t REG_NOTBOL means 'base' is not at the beginning of a line, which\n-\t shouldn't matter since the name_re has no ^ anchor, but let's\n-\t be accurate anyway.  */\n+         REG_NOTBOL means 'base' is not at the beginning of a line, which\n+         shouldn't matter since the name_re has no ^ anchor, but let's\n+         be accurate anyway.  */\n \n       for (;;)\n-\t{\n-\tagain:\n-\t  if (base == limit)\n-\t    break;\n-\n-\t  if (regexec (name_re, base, 1, match, REG_NOTBOL))\n-\t    goto done;  /* No remaining match in this file */\n-\n-\t  /* Match; is it on the line?  */\n-\t  if (match[0].rm_eo > limit - base)\n-\t    break;\n-\n-\t  p = base + match[0].rm_so;\n-\t  base += match[0].rm_eo;\n-\n-\t  /* One more test: if on the same line we have the same string\n-\t     with the appropriate underscores, then leave it alone.\n-\t     We want exactly two leading and trailing underscores.  */\n-\t  if (*p == '_')\n-\t    {\n-\t      len = base - p - ((*base == '_') ? 2 : 1);\n-\t      q = p + 1;\n-\t    }\n-\t  else\n-\t    {\n-\t      len = base - p - ((*base == '_') ? 1 : 0);\n-\t      q = p;\n-\t    }\n-\t  if (len + 4 > SCRATCHSZ)\n-\t    abort ();\n-\t  memcpy (&scratch[2], q, len);\n-\t  len += 2;\n-\t  scratch[len++] = '_';\n-\t  scratch[len++] = '_';\n-\n-\t  for (q = line; q <= limit - len; q++)\n-\t    if (*q == '_' && !strncmp (q, scratch, len))\n-\t      goto again;\n-\t  \n-\t  fwrite (text, 1, p - text, stdout);\n-\t  fwrite (scratch, 1, len, stdout);\n-\n-\t  text = base;\n-\t}\n+        {\n+        again:\n+          if (base == limit)\n+            break;\n+\n+          if (regexec (name_re, base, 1, match, REG_NOTBOL))\n+            goto done;  /* No remaining match in this file */\n+\n+          /* Match; is it on the line?  */\n+          if (match[0].rm_eo > limit - base)\n+            break;\n+\n+          p = base + match[0].rm_so;\n+          base += match[0].rm_eo;\n+\n+          /* One more test: if on the same line we have the same string\n+             with the appropriate underscores, then leave it alone.\n+             We want exactly two leading and trailing underscores.  */\n+          if (*p == '_')\n+            {\n+              len = base - p - ((*base == '_') ? 2 : 1);\n+              q = p + 1;\n+            }\n+          else\n+            {\n+              len = base - p - ((*base == '_') ? 1 : 0);\n+              q = p;\n+            }\n+          if (len + 4 > SCRATCHSZ)\n+            abort ();\n+          memcpy (&scratch[2], q, len);\n+          len += 2;\n+          scratch[len++] = '_';\n+          scratch[len++] = '_';\n+\n+          for (q = line; q <= limit - len; q++)\n+            if (*q == '_' && !strncmp (q, scratch, len))\n+              goto again;\n+          \n+          fwrite (text, 1, p - text, stdout);\n+          fwrite (scratch, 1, len, stdout);\n+\n+          text = base;\n+        }\n     }\n  done:\n #endif"}]}