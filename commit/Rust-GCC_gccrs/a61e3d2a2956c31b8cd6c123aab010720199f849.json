{"sha": "a61e3d2a2956c31b8cd6c123aab010720199f849", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTYxZTNkMmEyOTU2YzMxYjhjZDZjMTIzYWFiMDEwNzIwMTk5Zjg0OQ==", "commit": {"author": {"name": "Tobias Grosser", "email": "grosser@fim.uni-passau.de", "date": "2008-09-29T01:28:16Z"}, "committer": {"name": "Tobias Grosser", "email": "grosser@gcc.gnu.org", "date": "2008-09-29T01:28:16Z"}, "message": "graphite.c (dot_all_scops_1): Remove unused checks.\n\n2008-09-29  Tobias Grosser  <grosser@fim.uni-passau.de>\n\n\t* graphite.c (dot_all_scops_1): Remove unused checks. SCoPs always have\n\texit and entry.\n\t(new_scop): Take entry and exit edge to define new SCoP.\n\t(sd_region_p): New structure used during SCoP detection.\n\t(move_scops): Delete.\n\t(move_sd_regions): New.\n\t(scopdet_info): Change the definition from edges back to basic_blocks.\n\t(scopdet_edge_info):  Work on basic_blocks and rename to\n\tscopdet_basic_block_info.\n\t(split_difficult_bb): At the moment removed. We should later\n\tadd it at another place.\n\t(build_scops_1): Work on basic_blocks.\n\t(bb_in_sd_region): New.\n\t(find_single_entry_edge): New.\n\t(find_single_exit_edge): New.\n\t(create_single_entry_edge): New.\n\t(sd_region_without_exit): New.\n\t(create_single_exit_edge): New.\n\t(unmark_exit_edges): New.\n\t(mark_exit_edges): New.\n\t(create_sese_edges): New.\n\t(build_graphite_scops): New.\n\t(build_scops): Make SCoPs SESE.\n\t(limit_scops): Use the new functions.\n\nFrom-SVN: r140746", "tree": {"sha": "86e36789c50536879833790b88035111c7457c8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/86e36789c50536879833790b88035111c7457c8b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a61e3d2a2956c31b8cd6c123aab010720199f849", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a61e3d2a2956c31b8cd6c123aab010720199f849", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a61e3d2a2956c31b8cd6c123aab010720199f849", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a61e3d2a2956c31b8cd6c123aab010720199f849/comments", "author": {"login": "tobiasgrosser", "id": 521960, "node_id": "MDQ6VXNlcjUyMTk2MA==", "avatar_url": "https://avatars.githubusercontent.com/u/521960?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tobiasgrosser", "html_url": "https://github.com/tobiasgrosser", "followers_url": "https://api.github.com/users/tobiasgrosser/followers", "following_url": "https://api.github.com/users/tobiasgrosser/following{/other_user}", "gists_url": "https://api.github.com/users/tobiasgrosser/gists{/gist_id}", "starred_url": "https://api.github.com/users/tobiasgrosser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tobiasgrosser/subscriptions", "organizations_url": "https://api.github.com/users/tobiasgrosser/orgs", "repos_url": "https://api.github.com/users/tobiasgrosser/repos", "events_url": "https://api.github.com/users/tobiasgrosser/events{/privacy}", "received_events_url": "https://api.github.com/users/tobiasgrosser/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e53c26770b9a79f03b9f7aea78e851d65620db0a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e53c26770b9a79f03b9f7aea78e851d65620db0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e53c26770b9a79f03b9f7aea78e851d65620db0a"}], "stats": {"total": 621, "additions": 448, "deletions": 173}, "files": [{"sha": "45e4a6679c80f3ccdcd6242b03c8079762161ee0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a61e3d2a2956c31b8cd6c123aab010720199f849/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a61e3d2a2956c31b8cd6c123aab010720199f849/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a61e3d2a2956c31b8cd6c123aab010720199f849", "patch": "@@ -1,3 +1,30 @@\n+2008-09-29  Tobias Grosser  <grosser@fim.uni-passau.de>\n+\n+\t* graphite.c (dot_all_scops_1): Remove unused checks. SCoPs always have\n+\texit and entry.\n+\t(new_scop): Take entry and exit edge to define new SCoP.\n+\t(sd_region_p): New structure used during SCoP detection.\n+\t(move_scops): Delete.\n+\t(move_sd_regions): New.\n+\t(scopdet_info): Change the definition from edges back to basic_blocks.\n+\t(scopdet_edge_info):  Work on basic_blocks and rename to\n+\tscopdet_basic_block_info.\n+\t(split_difficult_bb): At the moment removed. We should later\n+\tadd it at another place.\n+\t(build_scops_1): Work on basic_blocks.\n+\t(bb_in_sd_region): New.\n+\t(find_single_entry_edge): New.\n+\t(find_single_exit_edge): New.\n+\t(create_single_entry_edge): New.\n+\t(sd_region_without_exit): New.\n+\t(create_single_exit_edge): New.\n+\t(unmark_exit_edges): New.\n+\t(mark_exit_edges): New.\n+\t(create_sese_edges): New.\n+\t(build_graphite_scops): New.\n+\t(build_scops): Make SCoPs SESE.\n+\t(limit_scops): Use the new functions.\n+\n 2008-09-29  Hans-Peter Nilsson  <hp@axis.com>\n \n \t* config/cris/cris.h (IRA_COVER_CLASSES): Define."}, {"sha": "4531936b154ce068ce6333b90fbc161f5126284d", "filename": "gcc/graphite.c", "status": "modified", "additions": 421, "deletions": 173, "changes": 594, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a61e3d2a2956c31b8cd6c123aab010720199f849/gcc%2Fgraphite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a61e3d2a2956c31b8cd6c123aab010720199f849/gcc%2Fgraphite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite.c?ref=a61e3d2a2956c31b8cd6c123aab010720199f849", "patch": "@@ -566,8 +566,8 @@ dot_all_scops_1 (FILE *file)\n       /* Select color for SCoP.  */\n       for (i = 0; VEC_iterate (scop_p, current_scops, i, scop); i++)\n \tif (bb_in_scop_p (bb, scop)\n-\t    || (SESE_EXIT (SCOP_REGION (scop)) && SCOP_EXIT (scop) == bb)\n-\t    || (SESE_ENTRY (SCOP_REGION (scop)) && SCOP_ENTRY (scop) == bb))\n+\t    || (SCOP_EXIT (scop) == bb)\n+\t    || (SCOP_ENTRY (scop) == bb))\n \t  {\n \t    switch (i % 17)\n \t      {\n@@ -631,16 +631,12 @@ dot_all_scops_1 (FILE *file)\n \t    if (!bb_in_scop_p (bb, scop))\n \t      fprintf (file, \" (\"); \n \n-\t    if (SESE_ENTRY (SCOP_REGION (scop))\n-\t\t&& SESE_EXIT (SCOP_REGION (scop))\n-\t\t&& bb == SCOP_ENTRY (scop)\n+\t    if (bb == SCOP_ENTRY (scop)\n \t\t&& bb == SCOP_EXIT (scop))\n \t      fprintf (file, \" %d*# \", bb->index);\n-\t    else if (SESE_ENTRY (SCOP_REGION (scop))\n-\t\t     && bb == SCOP_ENTRY (scop))\n+\t    else if (bb == SCOP_ENTRY (scop))\n \t      fprintf (file, \" %d* \", bb->index);\n-\t    else if (SESE_EXIT (SCOP_REGION (scop))\n-\t\t     && bb == SCOP_EXIT (scop))\n+\t    else if (bb == SCOP_EXIT (scop))\n \t      fprintf (file, \" %d# \", bb->index);\n \t    else\n \t      fprintf (file, \" %d \", bb->index);\n@@ -649,7 +645,6 @@ dot_all_scops_1 (FILE *file)\n \t      fprintf (file, \")\");\n \n \t    fprintf (file, \"</TD></TR>\\n\");\n-\n \t    part_of_scop  = true;\n \t  }\n \n@@ -731,7 +726,7 @@ block_before_scop (scop_p scop)\n static bool\n loop_affine_expr (basic_block scop_entry, struct loop *loop, tree expr)\n {\n-  int n = scop_entry->loop_father->num;\n+  int n = loop->num;\n   tree scev = analyze_scalar_evolution (loop, expr);\n \n   scev = instantiate_scev (scop_entry, loop, scev);\n@@ -913,13 +908,15 @@ free_graphite_bb (struct graphite_bb *gbb)\n /* Creates a new scop starting with ENTRY.  */\n \n static scop_p\n-new_scop (edge entry)\n+new_scop (edge entry, edge exit)\n {\n   scop_p scop = XNEW (struct scop);\n \n+  gcc_assert (entry && exit);\n+\n   SCOP_REGION (scop) = XNEW (struct sese);\n   SESE_ENTRY (SCOP_REGION (scop)) = entry;\n-  SESE_EXIT (SCOP_REGION (scop)) = NULL;\n+  SESE_EXIT (SCOP_REGION (scop)) = exit;\n   SCOP_BBS (scop) = VEC_alloc (graphite_bb_p, heap, 3);\n   SCOP_OLDIVS (scop) = VEC_alloc (name_tree, heap, 3);\n   SCOP_BBS_B (scop) = BITMAP_ALLOC (NULL);\n@@ -1012,39 +1009,77 @@ get_bb_type (basic_block bb, struct loop *last_loop)\n   dom = get_dominated_by (CDI_DOMINATORS, bb);\n   nb_dom = VEC_length (basic_block, dom);\n   VEC_free (basic_block, heap, dom);\n+\n   if (nb_dom == 0)\n     return GBB_LAST;\n \n   nb_suc = VEC_length (edge, bb->succs);\n+\n   if (nb_dom == 1 && nb_suc == 1)\n     return GBB_SIMPLE;\n \n   return GBB_COND_HEADER;\n }\n \n+/* A SCoP detection region, defined using bbs as borders. \n+   All control flow touching this region, comes in passing basic_block ENTRY and\n+   leaves passing basic_block EXIT.  By using bbs instead of edges for the\n+   borders we are able to represent also regions that do not have a single\n+   entry or exit edge.\n+   But as they have a single entry basic_block and a single exit basic_block, we\n+   are able to generate for every sd_region a single entry and exit edge.\n+\n+   1   2\n+    \\ /\n+     3\t<- entry\n+     |\n+     4\n+    / \\\t\t\tThis region contains: {3, 4, 5, 6, 7, 8}\n+   5   6\n+   |   |\n+   7   8\n+    \\ /\n+     9\t<- exit  */\n+\n+\n+typedef struct sd_region_p\n+{\n+  /* The entry bb dominates all bbs in the sd_region.  It is part of the\n+     region.  */\n+  basic_block entry;\n+\n+  /* The exit bb postdominates all bbs in the sd_region, but is not \n+     part of the region.  */\n+  basic_block exit;\n+} sd_region;\n+\n+DEF_VEC_O(sd_region);\n+DEF_VEC_ALLOC_O(sd_region, heap);\n+\n+\n /* Moves the scops from SOURCE to TARGET and clean up SOURCE.  */\n \n static void\n-move_scops (VEC (scop_p, heap) **source, VEC (scop_p, heap) **target)\n+move_sd_regions (VEC (sd_region, heap) **source, VEC (sd_region, heap) **target)\n {\n-  scop_p s;\n+  sd_region *s;\n   int i;\n \n-  for (i = 0; VEC_iterate (scop_p, *source, i, s); i++)\n-    VEC_safe_push (scop_p, heap, *target, s);\n+  for (i = 0; VEC_iterate (sd_region, *source, i, s); i++)\n+    VEC_safe_push (sd_region, heap, *target, s);\n   \n-  VEC_free (scop_p, heap, *source);\n+  VEC_free (sd_region, heap, *source);\n }\n \n /* Store information needed by scopdet_* functions.  */\n \n struct scopdet_info\n {\n   /* Where the last open scop would stop if the current BB is harmful.  */\n-  edge last;\n+  basic_block last;\n \n   /* Where the next scop would start if the current BB is harmful.  */\n-  edge next;\n+  basic_block next;\n \n   /* The bb or one of its children contains open loop exits.  That means\n      loop exit nodes that are not surrounded by a loop dominated by bb.  */ \n@@ -1054,75 +1089,67 @@ struct scopdet_info\n   bool difficult;\n };\n \n-static struct scopdet_info build_scops_1 (edge, VEC (scop_p, heap) **,\n+\n+static struct scopdet_info build_scops_1 (basic_block, VEC (sd_region, heap) **,\n                                           loop_p);\n \n-/* Checks, if a bb can be added to a SCoP.  */\n+/* Calculates BB infos. If bb is difficult we add valid SCoPs dominated by BB\n+   to SCOPS.  TYPE is the gbb_type of BB.  */\n \n static struct scopdet_info \n-scopdet_edge_info (edge ee,\n-\t\t   VEC (scop_p, heap) **scops, gbb_type type, gimple *stmt)\n-\t       \n+scopdet_basic_block_info (basic_block bb, VEC (sd_region, heap) **scops,\n+\t\t\t  gbb_type type)\n {\n-  basic_block bb = ee->dest;\n   struct loop *loop = bb->loop_father;\n   struct scopdet_info result;\n-  basic_block scop_entry;\n-\n-  if (VEC_length (scop_p, *scops) != 0)\n-    scop_entry = block_before_scop (VEC_last (scop_p, *scops));\n-  else if (loop->header)\n-    scop_entry = loop->header;\n-  else\n-    scop_entry = ENTRY_BLOCK_PTR;\n+  gimple stmt;\n \n-  *stmt = harmful_stmt_in_bb (scop_entry, bb);\n-  result.difficult = (*stmt != NULL);\n+  /* XXX: ENTRY_BLOCK_PTR could be optimized in later steps.  */\n+  stmt = harmful_stmt_in_bb (ENTRY_BLOCK_PTR, bb);\n+  result.difficult = (stmt != NULL);\n   result.last = NULL;\n \n   switch (type)\n     {\n     case GBB_LAST:\n       result.next = NULL;\n       result.exits = false;\n-      result.last = ee;\n+      result.last = bb;\n       break;\n \n     case GBB_SIMPLE:\n-      result.next = single_succ_edge (bb);\n+      result.next = single_succ (bb);\n       result.exits = false;\n-      result.last = ee;\n+      result.last = bb;\n       break;\n \n     case GBB_LOOP_SING_EXIT_HEADER:\n       {\n-        VEC (scop_p, heap) *tmp_scops = VEC_alloc (scop_p, heap, 3);\n+        VEC (sd_region, heap) *tmp_scops = VEC_alloc (sd_region, heap,3);\n         struct scopdet_info sinfo;\n \n-        sinfo = build_scops_1 (ee, &tmp_scops, loop);\n-\n-        result.last = single_exit (bb->loop_father);\n-\n-\tif (single_succ_p (result.last->dest)\n-\t    && get_bb_type (result.last->dest, loop) == GBB_SIMPLE)\n-\t  result.next = single_succ_edge (result.last->dest);\n-\telse\n-\t  result.next = split_block (result.last->dest, NULL);\n+        sinfo = build_scops_1 (bb, &tmp_scops, loop);\n+\t\n+        result.last = single_exit (bb->loop_father)->src;\n+        result.next = single_exit (bb->loop_father)->dest;\n \n         /* If we do not dominate result.next, remove it.  It's either\n            the EXIT_BLOCK_PTR, or another bb dominates it and will\n            call the scop detection for this bb.  */\n-        if (!dominated_by_p (CDI_DOMINATORS, result.next->dest, bb))\n-          result.next = NULL;\n+        if (!dominated_by_p (CDI_DOMINATORS, result.next, bb))\n+\t  result.next = NULL;\n+\n+\tif (result.last->loop_father != loop)\n+\t  result.next = NULL;\n \n         if (TREE_CODE (number_of_latch_executions (loop))\n             == SCEV_NOT_KNOWN)\n           result.difficult = true;\n \n         if (sinfo.difficult)\n-          move_scops (&tmp_scops, scops);\n+          move_sd_regions (&tmp_scops, scops);\n         else \n-          free_scops (tmp_scops);\n+          VEC_free (sd_region, heap, tmp_scops);\n \n         result.exits = false;\n         result.difficult |= sinfo.difficult;\n@@ -1131,37 +1158,36 @@ scopdet_edge_info (edge ee,\n \n     case GBB_LOOP_MULT_EXIT_HEADER:\n       {\n-        /* XXX: Handle loop nests with the same header.  */\n         /* XXX: For now we just do not join loops with multiple exits. If the \n            exits lead to the same bb it may be possible to join the loop.  */\n-        VEC (scop_p, heap) *tmp_scops = VEC_alloc (scop_p, heap, 3);\n+        VEC (sd_region, heap) *tmp_scops = VEC_alloc (sd_region, heap, 3);\n         VEC (edge, heap) *exits = get_loop_exit_edges (loop);\n         edge e;\n         int i;\n-        build_scops_1 (ee, &tmp_scops, loop);\n+        build_scops_1 (bb, &tmp_scops, loop);\n \n+\t/* XXX: Use 'e->src' ot better 'bb'?  */\n         for (i = 0; VEC_iterate (edge, exits, i, e); i++)\n           if (dominated_by_p (CDI_DOMINATORS, e->dest, e->src)\n-              && e->dest->loop_father == loop_outer (loop))\n-            build_scops_1 (e, &tmp_scops, e->dest->loop_father);\n+              && e->src->loop_father == loop)\n+            build_scops_1 (e->dest, &tmp_scops, e->dest->loop_father);\n \n         result.next = NULL; \n         result.last = NULL;\n         result.difficult = true;\n         result.exits = false;\n-        move_scops (&tmp_scops, scops);\n+        move_sd_regions (&tmp_scops, scops);\n         VEC_free (edge, heap, exits);\n         break;\n       }\n     case GBB_COND_HEADER:\n       {\n-\tVEC (scop_p, heap) *tmp_scops = VEC_alloc (scop_p, heap, 3);\n+\tVEC (sd_region, heap) *tmp_scops = VEC_alloc (sd_region, heap, 3);\n \tstruct scopdet_info sinfo;\n \tVEC (basic_block, heap) *dominated;\n \tint i;\n \tbasic_block dom_bb;\n \tbasic_block last_bb = NULL;\n-\tedge last_e = NULL;\n \tedge e;\n \tresult.exits = false;\n  \n@@ -1197,7 +1223,6 @@ scopdet_edge_info (edge ee,\n \t\tif (!last_bb)\n \t\t  {\n \t\t    last_bb = e->dest;\n-\t\t    last_e = e;\n \t\t  }\n \n \t\tif (e->dest != last_bb)\n@@ -1212,7 +1237,7 @@ scopdet_edge_info (edge ee,\n \t\tcontinue;\n \t      }\n \n-\t    sinfo = build_scops_1 (e, &tmp_scops, loop);\n+\t    sinfo = build_scops_1 (e->dest, &tmp_scops, loop);\n \n \t    result.exits |= sinfo.exits;\n \t    result.last = sinfo.last;\n@@ -1221,15 +1246,12 @@ scopdet_edge_info (edge ee,\n \t    /* Checks, if all branches end at the same point. \n \t       If that is true, the condition stays joinable.\n \t       Have a look at the example above.  */\n-\t    if (sinfo.last && single_succ_p (sinfo.last->dest))\n+\t    if (sinfo.last && single_succ_p (sinfo.last))\n \t      {\n-\t\tbasic_block next_tmp = single_succ (sinfo.last->dest);\n+\t\tbasic_block next_tmp = single_succ (sinfo.last);\n                   \n \t\tif (!last_bb)\n-\t\t  {\n \t\t    last_bb = next_tmp;\n-\t\t    last_e = single_succ_edge (sinfo.last->dest);\n-\t\t  }\n \n \t\tif (next_tmp != last_bb)\n \t\t  result.difficult = true;\n@@ -1244,11 +1266,11 @@ scopdet_edge_info (edge ee,\n \t    /* Only return a next pointer if we dominate this pointer.\n \t       Otherwise it will be handled by the bb dominating it.  */ \n \t    if (dominated_by_p (CDI_DOMINATORS, last_bb, bb) && last_bb != bb)\n-\t      result.next = last_e;\n+\t      result.next = last_bb;\n \t    else\n \t      result.next = NULL; \n \n-\t    move_scops (&tmp_scops, scops);\n+\t    VEC_free (sd_region, heap, tmp_scops);\n \t    break;\n \t  }\n \n@@ -1268,15 +1290,10 @@ scopdet_edge_info (edge ee,\n \t    if (single_pred_p (dom_bb) && single_pred (dom_bb) == bb)\n \t      continue;\n \n-\t    if (single_pred_p (dom_bb))\n-\t      e = single_pred_edge (dom_bb);\n-\t    else\n-\t      e = split_block (dom_bb, NULL);\n-\n \t    if (loop_depth (loop) > loop_depth (dom_bb->loop_father))\n-\t      sinfo = build_scops_1 (e, &tmp_scops, loop_outer (loop));\n+\t      sinfo = build_scops_1 (dom_bb, &tmp_scops, loop_outer (loop));\n \t    else\n-\t      sinfo = build_scops_1 (e, &tmp_scops, loop);\n+\t      sinfo = build_scops_1 (dom_bb, &tmp_scops, loop);\n                                            \n                                      \n \t    result.exits |= sinfo.exits; \n@@ -1287,7 +1304,7 @@ scopdet_edge_info (edge ee,\n \tVEC_free (basic_block, heap, dominated);\n \n \tresult.next = NULL; \n-\tmove_scops (&tmp_scops, scops);\n+\tmove_sd_regions (&tmp_scops, scops);\n \n \tbreak;\n       }\n@@ -1299,61 +1316,14 @@ scopdet_edge_info (edge ee,\n   return result;\n }\n \n-/* Split EXIT before STMT when STMT is non NULL.  */\n-\n-static edge\n-split_difficult_bb (basic_block exit, edge *last, gimple stmt)\n-{\n-  if (stmt && VEC_length (edge, exit->preds) == 1)\n-    {\n-      edge e;\n-\n-      if (stmt == gsi_stmt (gsi_after_labels (exit)))\n-\tstmt = NULL;\n-      else\n-\t{\n-\t  gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n-\t  gsi_prev (&gsi);\n-\t  stmt = gsi_stmt (gsi);\n-\t}\n-\n-      e = split_block (exit, stmt);\n-      set_immediate_dominator (CDI_DOMINATORS, e->dest, e->src);\n-      set_immediate_dominator (CDI_POST_DOMINATORS, e->src, e->dest);\n-      exit = e->dest;\n-\n-      if (last)\n-\t*last = e;\n-\n-      return e;\n-    }\n-\n-  return NULL;\n-}\n-\n-/* End SCOP with edge EXIT.  */\n-\n-static void\n-end_scop (scop_p scop, edge exit, bool split_entry)\n-{\n-  if (split_entry \n-      && !single_pred_p (SCOP_ENTRY (scop))\n-      && exit->dest->loop_father == SCOP_ENTRY (scop)->loop_father)\n-    SESE_ENTRY (SCOP_REGION (scop)) = split_block (SCOP_ENTRY (scop), NULL);\n-\n-  SESE_EXIT (SCOP_REGION (scop)) = exit;\n-}\n-\n /* Creates the SCoPs and writes entry and exit points for every SCoP.  */\n \n static struct scopdet_info \n-build_scops_1 (edge start, VEC (scop_p, heap) **scops, loop_p loop)\n+build_scops_1 (basic_block current, VEC (sd_region, heap) **scops, loop_p loop)\n {\n-  edge current = start;\n \n   bool in_scop = false;\n-  scop_p open_scop = NULL;\n-  gimple stmt;\n+  sd_region open_scop;\n   struct scopdet_info sinfo;\n \n   /* Initialize result.  */ \n@@ -1362,30 +1332,26 @@ build_scops_1 (edge start, VEC (scop_p, heap) **scops, loop_p loop)\n   result.difficult = false;\n   result.next = NULL;\n   result.last = NULL;\n+  open_scop.entry = NULL;\n \n   /* Loop over the dominance tree.  If we meet a difficult bb, close\n      the current SCoP.  Loop and condition header start a new layer,\n      and can only be added if all bbs in deeper layers are simple.  */\n   while (current != NULL)\n     {\n-      sinfo = scopdet_edge_info (current, scops,\n-\t\t\t\t get_bb_type (current->dest, loop), &stmt);\n+      sinfo = scopdet_basic_block_info (current, scops, get_bb_type (current,\n+\t\t\t\t\t\t\t\t     loop));\n \n       if (!in_scop && !(sinfo.exits || sinfo.difficult))\n         {\n-\t  open_scop = new_scop (current);\n-\n-          VEC_safe_push (scop_p, heap, *scops, open_scop); \n+\t  open_scop.entry = current;\n+\t  open_scop.exit = NULL;\n           in_scop = true;\n         }\n       else if (in_scop && (sinfo.exits || sinfo.difficult))\n         {\n-\t  edge exit = split_difficult_bb (current->dest, &sinfo.last, stmt);\n-\n-\t  if (!exit)\n-\t    exit = current;\n-\n-\t  end_scop (open_scop, exit, sinfo.difficult);\n+\t  open_scop.exit = current;\n+          VEC_safe_push (sd_region, heap, *scops, &open_scop); \n           in_scop = false;\n         }\n \n@@ -1395,47 +1361,320 @@ build_scops_1 (edge start, VEC (scop_p, heap) **scops, loop_p loop)\n       current = sinfo.next;\n     }\n \n-  /* Finish the SCOP, if it is left open.  The exit is the bb, that\n-     postdominates sinfo.last.  If no such bb exists, we use info.last\n-     or delete the scop.  */\n+  /* Try to close open_scop, if we are still in an open SCoP.  */\n   if (in_scop)\n     {\n       int i;\n       edge e;\n \n-      for (i = 0; VEC_iterate (edge, sinfo.last->dest->succs, i, e); i++)\n-        if (dominated_by_p (CDI_POST_DOMINATORS, sinfo.last->dest, e->dest))\n-          {\n-\t    edge exit = split_difficult_bb (e->dest, &sinfo.last, stmt);\n+\tfor (i = 0; VEC_iterate (edge, sinfo.last->succs, i, e); i++)\n+\t  if (dominated_by_p (CDI_POST_DOMINATORS, sinfo.last, e->dest))\n+            open_scop.exit = e->dest;\n \n-\t    if (exit)\n-\t      end_scop (open_scop, exit, sinfo.difficult);\n-\t    else\n-\t      end_scop (open_scop, e, sinfo.difficult);\n+        if (!open_scop.exit && open_scop.entry != sinfo.last)\n+\t  open_scop.exit = sinfo.last;\n+\n+\tif (open_scop.exit)\n+\t  VEC_safe_push (sd_region, heap, *scops, &open_scop);\n+      \n+    }\n+\n+  result.last = sinfo.last;\n+  return result;\n+}\n+\n+/* Checks if a bb is contained in REGION.  */\n \n-\t    goto done;\n+static bool\n+bb_in_sd_region (basic_block bb, sd_region *region)\n+{\n+  return dominated_by_p (CDI_DOMINATORS, bb, region->entry)\n+\t && !(dominated_by_p (CDI_DOMINATORS, bb, region->exit)\n+\t      && !dominated_by_p (CDI_DOMINATORS, region->entry,\n+\t\t\t\t  region->exit));\n+}\n+\n+/* Returns the single entry edge of REGION, if it does not exits NULL.  */\n+\n+static edge\n+find_single_entry_edge (sd_region *region)\n+{\n+  edge e;\n+  edge_iterator ei;\n+  edge entry = NULL;\n+\n+  FOR_EACH_EDGE (e, ei, region->entry->preds)\n+    if (!bb_in_sd_region (e->src, region))\n+      {\n+\tif (entry)\n+\t  {\n+\t    entry = NULL;\n+\t    break;\n \t  }\n \n-      if (SCOP_ENTRY (open_scop) != sinfo.last->dest)\n-\t{\n-\t  edge exit = split_difficult_bb (sinfo.last->dest, NULL, stmt);\n+\telse\n+\t  entry = e;\n+      }\n \n-\t  if (exit)\n-\t    end_scop (open_scop, exit, sinfo.difficult);\n-\t  else\n-\t    end_scop (open_scop, sinfo.last, sinfo.difficult);\n-\t}\n-      else\n-\t{\n-\t  VEC_pop (scop_p, *scops);\n-\t  free_scop (open_scop);\n-        }\n+  return entry;\n+}\n+\n+/* Returns the single exit edge of REGION, if it does not exits NULL.  */\n+\n+static edge\n+find_single_exit_edge (sd_region *region)\n+{\n+  edge e;\n+  edge_iterator ei;\n+  edge exit = NULL;\n+\n+  FOR_EACH_EDGE (e, ei, region->exit->preds)\n+    if (bb_in_sd_region (e->src, region))\n+      {\n+\tif (exit)\n+\t  {\n+\t    exit = NULL;\n+\t    break;\n+\t  }\n+\n+\telse\n+\t  exit = e;\n+      }\n+\n+  return exit;\n+}\n+\n+/* Create a single entry edge for REGION.  */\n+\n+static void\n+create_single_entry_edge (sd_region *region)\n+{\n+  if (find_single_entry_edge (region))\n+    return;\n+\n+  /* There are multiple predecessors for bb_3 \n+\n+  |  1  2\n+  |  | /\n+  |  |/\n+  |  3\t<- entry\n+  |  |\\\n+  |  | |\n+  |  4 ^\n+  |  | |\n+  |  |/\n+  |  5\n+\n+  There are two edges (1->3, 2->3), that point from outside into the region,\n+  and another one (5->3), a loop latch, lead to bb_3.\n+\n+  We split bb_3.\n+  \n+  |  1  2\n+  |  | /\n+  |  |/\n+  |3.0\n+  |  |\\     (3.0 -> 3.1) = single entry edge\n+  |3.1 |  \t<- entry\n+  |  | |\n+  |  | |\n+  |  4 ^ \n+  |  | |\n+  |  |/\n+  |  5\n+\n+  If the loop is part of the SCoP, we have to redirect the loop latches.\n+\n+  |  1  2\n+  |  | /\n+  |  |/\n+  |3.0\n+  |  |      (3.0 -> 3.1) = entry edge\n+  |3.1  \t<- entry\n+  |  |\\\n+  |  | |\n+  |  4 ^\n+  |  | |\n+  |  |/\n+  |  5  */\n+\n+  if (region->entry->loop_father->header != region->entry\n+      || dominated_by_p (CDI_DOMINATORS,\n+\t\t\t loop_latch_edge (region->entry->loop_father)->src,\n+\t\t\t region->exit))\n+    {\n+      edge forwarder = split_block_after_labels (region->entry);\n+      region->entry = forwarder->dest;\n     }\n+  else\n+    /* This case is never executed, as the loop headers seem always to have a\n+       single edge pointing from outside into the loop.  */\n+    gcc_unreachable ();\n+      \n+#ifdef ENABLE_CHECKING\n+  gcc_assert (find_single_entry_edge (region));\n+#endif\n+}\n \n- done:\n-  result.last = sinfo.last;\n+/* Check if the sd_region, mentioned in EDGE, has no exit bb.  */\n \n-  return result;\n+static bool\n+sd_region_without_exit (edge e)\n+{\n+  sd_region *r = (sd_region *) e->aux;\n+\n+  if (r)\n+    return r->exit == NULL;\n+  else\n+    return false;\n+}\n+\n+/* Create a single exit edge for REGION.  */\n+\n+static void\n+create_single_exit_edge (sd_region *region)\n+{\n+  edge e;\n+  edge_iterator ei;\n+  edge forwarder = NULL;\n+  basic_block exit;\n+  \n+  if (find_single_exit_edge (region))\n+    return;\n+\n+  /* We create a forwarder bb (5) for all edges leaving this region\n+     (3->5, 4->5).  All other edges leading to the same bb, are moved\n+     to a new bb (6).  If these edges where part of another region (2->5)\n+     we update the region->exit pointer, of this region.\n+\n+     To identify which edge belongs to which region we depend on the e->aux\n+     pointer in every edge.  It points to the region of the edge or to NULL,\n+     if the edge is not part of any region.\n+\n+     1 2 3 4   \t1->5 no region, \t\t2->5 region->exit = 5,\n+      \\| |/    \t3->5 region->exit = NULL, \t4->5 region->exit = NULL\n+        5\t<- exit\n+\n+     changes to\n+\n+     1 2 3 4   \t1->6 no region, \t\t\t2->6 region->exit = 6,\n+     | | \\/\t3->5 no region,\t\t\t\t4->5 no region, \n+     | |  5\n+      \\| /\t5->6 region->exit = 6\n+\t6 \n+\n+     Now there is only a single exit edge (5->6).  */\n+  exit = region->exit;\n+  region->exit = NULL;\n+  forwarder = make_forwarder_block (exit, &sd_region_without_exit, NULL);\n+  \n+  /* Unmark the edges, that are no longer exit edges.  */\n+  FOR_EACH_EDGE (e, ei, forwarder->src->preds)\n+    if (e->aux)\n+      e->aux = NULL;\n+\n+  /* Mark the new exit edge.  */ \n+  single_succ_edge (forwarder->src)->aux = region;\n+\n+  /* Update the exit bb of all regions, where exit edges lead to\n+     forwarder->dest.  */\n+  FOR_EACH_EDGE (e, ei, forwarder->dest->preds)\n+    if (e->aux)\n+      ((sd_region *) e->aux)->exit = forwarder->dest;\n+\n+#ifdef ENABLE_CHECKING\n+  gcc_assert (find_single_exit_edge (region));\n+#endif\n+}\n+\n+/* Unmark the exit edges of all REGIONS.  \n+   See comment in \"create_single_exit_edge\". */\n+\n+static void\n+unmark_exit_edges (VEC (sd_region, heap) *regions)\n+{\n+  int i;\n+  sd_region *s;\n+  edge e;\n+  edge_iterator ei;\n+\n+  for (i = 0; VEC_iterate (sd_region, regions, i, s); i++)\n+    FOR_EACH_EDGE (e, ei, s->exit->preds)\n+      e->aux = NULL;\n+}\n+\n+\n+/* Mark the exit edges of all REGIONS.  \n+   See comment in \"create_single_exit_edge\". */\n+\n+static void\n+mark_exit_edges (VEC (sd_region, heap) *regions)\n+{\n+  int i;\n+  sd_region *s;\n+  edge e;\n+  edge_iterator ei;\n+\n+  for (i = 0; VEC_iterate (sd_region, regions, i, s); i++)\n+    FOR_EACH_EDGE (e, ei, s->exit->preds)\n+      if (bb_in_sd_region (e->src, s))\n+\te->aux = s;\n+}\n+\n+\n+/* Create for all scop regions a single entry and a single exit edge.  */\n+\n+static void\n+create_sese_edges (VEC (sd_region, heap) *regions)\n+{\n+  int i;\n+  sd_region *s;\n+\n+\n+  for (i = 0; VEC_iterate (sd_region, regions, i, s); i++)\n+    create_single_entry_edge (s);\n+\n+  mark_exit_edges (regions);\n+\n+  for (i = 0; VEC_iterate (sd_region, regions, i, s); i++)\n+    create_single_exit_edge (s);\n+\n+  unmark_exit_edges (regions);\n+\n+#ifdef ENABLE_CHECKING\n+  verify_loop_structure ();\n+  verify_dominators (CDI_DOMINATORS);\n+  verify_ssa (false);\n+#endif\n+}\n+\n+/* Create graphite SCoPs from an array of scop detection regions.  */\n+\n+static void\n+build_graphite_scops (VEC (sd_region, heap) *scop_regions)\n+{\n+  int i;\n+  sd_region *s;\n+\n+  for (i = 0; VEC_iterate (sd_region, scop_regions, i, s); i++)\n+    {\n+      edge entry = find_single_entry_edge (s); \n+      edge exit = find_single_exit_edge (s);\n+      scop_p scop = new_scop (entry, exit);\n+      VEC_safe_push (scop_p, heap, current_scops, scop);\n+\n+      /* Are there overlapping SCoPs?  */\n+#ifdef ENABLE_CHECKING\n+\t{\n+\t  int j;\n+\t  sd_region *s2;\n+\n+\t  for (j = 0; VEC_iterate (sd_region, scop_regions, j, s2); j++)\n+\t    if (s != s2)\n+\t      gcc_assert (!bb_in_sd_region (s->entry, s2));\n+\t}\n+#endif\n+    }\n }\n \n /* Find static control parts.  */\n@@ -1444,7 +1683,11 @@ static void\n build_scops (void)\n {\n   struct loop *loop = current_loops->tree_root;\n-  build_scops_1 (single_succ_edge (ENTRY_BLOCK_PTR), &current_scops, loop);\n+  VEC (sd_region, heap) *tmp_scops = VEC_alloc (sd_region, heap, 3);\n+\n+  build_scops_1 (single_succ (ENTRY_BLOCK_PTR), &tmp_scops, loop);\n+  create_sese_edges (tmp_scops);\n+  build_graphite_scops (tmp_scops);\n }\n \n /* Gather the basic blocks belonging to the SCOP.  */\n@@ -4702,13 +4945,14 @@ graphite_apply_transformations (scop_p scop)\n    This is necessary as scalar evolution and parameter detection need a\n    outermost loop to initialize parameters correctly.  \n   \n-   TODO: FIX scalar evolution and parameter detection to allow mor flexible\n+   TODO: FIX scalar evolution and parameter detection to allow more flexible\n          SCoP frontiers.  */\n \n static void\n limit_scops (void)\n {\n-  VEC (scop_p, heap) *new_scops = VEC_alloc (scop_p, heap, 3);\n+  VEC (sd_region, heap) *tmp_scops = VEC_alloc (sd_region, heap, 3);\n+\n   int i;\n   scop_p scop;\n \n@@ -4722,14 +4966,18 @@ limit_scops (void)\n       for (j = 0; VEC_iterate (loop_p, SCOP_LOOP_NEST (scop), j, loop); j++) \n         if (!loop_in_scop_p (loop_outer (loop), scop))\n           {\n-\t    scop_p n_scop = new_scop (loop_preheader_edge (loop));\n-\t    end_scop (n_scop, single_exit (loop), false);\n-\t    VEC_safe_push (scop_p, heap, new_scops, n_scop);\n+\t    sd_region open_scop;\n+\t    open_scop.entry = loop_preheader_edge (loop)->dest;\n+\t    open_scop.exit = single_exit (loop)->dest;\n+\t    VEC_safe_push (sd_region, heap, tmp_scops, &open_scop);\n \t  }\n     }\n \n   free_scops (current_scops);\n-  current_scops = new_scops;\n+  current_scops = VEC_alloc (scop_p, heap, 3);\n+\n+  create_sese_edges (tmp_scops);\n+  build_graphite_scops (tmp_scops);\n }\n \n /* Perform a set of linear transforms on the loops of the current"}]}