{"sha": "a6de595f94a9a1956f19124195b0c852fd9fde73", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTZkZTU5NWY5NGE5YTE5NTZmMTkxMjQxOTViMGM4NTJmZDlmZGU3Mw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2012-03-03T18:21:06Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2012-03-03T18:21:06Z"}, "message": "optabs.c (expand_atomic_test_and_set): Honor atomic_test_and_set_trueval even when atomic_test_and_set optab is not in use.\n\n\t* optabs.c (expand_atomic_test_and_set): Honor\n\tatomic_test_and_set_trueval even when atomic_test_and_set\n\toptab is not in use.\n\nFrom-SVN: r184862", "tree": {"sha": "96b4628bf6a7a2b7e88c64b5788289627c0d35dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/96b4628bf6a7a2b7e88c64b5788289627c0d35dd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a6de595f94a9a1956f19124195b0c852fd9fde73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6de595f94a9a1956f19124195b0c852fd9fde73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6de595f94a9a1956f19124195b0c852fd9fde73", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6de595f94a9a1956f19124195b0c852fd9fde73/comments", "author": null, "committer": null, "parents": [{"sha": "6ecbd3a745b94e379458f0f67745379c969bc569", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ecbd3a745b94e379458f0f67745379c969bc569", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ecbd3a745b94e379458f0f67745379c969bc569"}], "stats": {"total": 67, "additions": 48, "deletions": 19}, "files": [{"sha": "a9edea9c28f2953b4e2b2edb413d958cc6474169", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6de595f94a9a1956f19124195b0c852fd9fde73/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6de595f94a9a1956f19124195b0c852fd9fde73/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a6de595f94a9a1956f19124195b0c852fd9fde73", "patch": "@@ -1,3 +1,9 @@\n+2012-03-02  Richard Henderson  <rth@redhat.com>\n+\n+\t* optabs.c (expand_atomic_test_and_set): Honor\n+\tatomic_test_and_set_trueval even when atomic_test_and_set\n+\toptab is not in use.\n+\n 2012-03-02  Kaz Kojima  <kkojima@gcc.gnu.org>\n \n \tPR target/48596"}, {"sha": "fd353d7e627c2ce4af288f5a3a3a66f1b0fcb581", "filename": "gcc/optabs.c", "status": "modified", "additions": 42, "deletions": 19, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6de595f94a9a1956f19124195b0c852fd9fde73/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6de595f94a9a1956f19124195b0c852fd9fde73/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=a6de595f94a9a1956f19124195b0c852fd9fde73", "patch": "@@ -7384,34 +7384,57 @@ rtx\n expand_atomic_test_and_set (rtx target, rtx mem, enum memmodel model)\n {\n   enum machine_mode mode = GET_MODE (mem);\n-  rtx ret;\n+  rtx ret, trueval, subtarget;\n \n   ret = maybe_emit_atomic_test_and_set (target, mem, model);\n   if (ret)\n     return ret;\n \n-  if (target == NULL_RTX)\n-    target = gen_reg_rtx (mode);\n+  /* Be binary compatible with non-default settings of trueval, and different\n+     cpu revisions.  E.g. one revision may have atomic-test-and-set, but\n+     another only has atomic-exchange.  */\n+  if (targetm.atomic_test_and_set_trueval == 1)\n+    {\n+      trueval = const1_rtx;\n+      subtarget = target ? target : gen_reg_rtx (mode);\n+    }\n+  else\n+    {\n+      trueval = gen_int_mode (targetm.atomic_test_and_set_trueval, mode);\n+      subtarget = gen_reg_rtx (mode);\n+    }\n \n-  /* If there is no test and set, try exchange, then a compare_and_swap loop,\n-     then __sync_test_and_set.  */\n-  ret = maybe_emit_atomic_exchange (target, mem, const1_rtx, model);\n-  if (ret)\n-    return ret;\n+  /* Try the atomic-exchange optab...  */\n+  ret = maybe_emit_atomic_exchange (subtarget, mem, trueval, model);\n \n-  ret = maybe_emit_compare_and_swap_exchange_loop (target, mem, const1_rtx);\n-  if (ret)\n-    return ret;\n+  /* ... then an atomic-compare-and-swap loop ... */\n+  if (!ret)\n+    ret = maybe_emit_compare_and_swap_exchange_loop (subtarget, mem, trueval);\n \n-  ret = maybe_emit_sync_lock_test_and_set (target, mem, const1_rtx, model);\n-  if (ret)\n-    return ret;\n+  /* ... before trying the vaguely defined legacy lock_test_and_set. */\n+  if (!ret)\n+    ret = maybe_emit_sync_lock_test_and_set (subtarget, mem, trueval, model);\n \n-  /* Failing all else, assume a single threaded environment and simply perform\n-     the operation.  */\n-  emit_move_insn (target, mem);\n-  emit_move_insn (mem, const1_rtx);\n-  return target;\n+  /* Recall that the legacy lock_test_and_set optab was allowed to do magic\n+     things with the value 1.  Thus we try again without trueval.  */\n+  if (!ret && targetm.atomic_test_and_set_trueval != 1)\n+    ret = maybe_emit_sync_lock_test_and_set (subtarget, mem, const1_rtx, model);\n+\n+  /* Failing all else, assume a single threaded environment and simply\n+     perform the operation.  */\n+  if (!ret)\n+    {\n+      emit_move_insn (subtarget, mem);\n+      emit_move_insn (mem, trueval);\n+      ret = subtarget;\n+    }\n+\n+  /* Recall that have to return a boolean value; rectify if trueval\n+     is not exactly one.  */\n+  if (targetm.atomic_test_and_set_trueval != 1)\n+    ret = emit_store_flag_force (target, NE, ret, const0_rtx, mode, 0, 1);\n+  \n+  return ret;\n }\n \n /* This function expands the atomic exchange operation:"}]}