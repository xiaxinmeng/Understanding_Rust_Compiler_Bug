{"sha": "80225b66a6f57598b94ad854d8214592914c6062", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODAyMjViNjZhNmY1NzU5OGI5NGFkODU0ZDgyMTQ1OTI5MTRjNjA2Mg==", "commit": {"author": {"name": "Torbjorn Granlund", "email": "tege@gnu.org", "date": "1994-06-01T00:38:18Z"}, "committer": {"name": "Torbjorn Granlund", "email": "tege@gnu.org", "date": "1994-06-01T00:38:18Z"}, "message": "(emit_move_sequence): Add missing argument to symbolic_operand.\n\n(output_block_move): Prefer addl to add.\n(print_operand): Print fp regs with L suffix when appropriate.\n(output_arg_descriptor): Rewrite to accomodate new convention for\nUSE information.\n(compute_frame_size): Update for changed register numbers.\nSimplify loops over general registers to stop at register 4.\n(hppa_expand_prologue): Likewise.\n(hppa_expand_epilogue): Likewise.\n\nFrom-SVN: r7411", "tree": {"sha": "dfccd80e14961245522394a58e4e616deca05573", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dfccd80e14961245522394a58e4e616deca05573"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/80225b66a6f57598b94ad854d8214592914c6062", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80225b66a6f57598b94ad854d8214592914c6062", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80225b66a6f57598b94ad854d8214592914c6062", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80225b66a6f57598b94ad854d8214592914c6062/comments", "author": null, "committer": null, "parents": [{"sha": "e65f61cfe434b56aa12ca24b6144cdae8bdd5e10", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e65f61cfe434b56aa12ca24b6144cdae8bdd5e10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e65f61cfe434b56aa12ca24b6144cdae8bdd5e10"}], "stats": {"total": 184, "additions": 66, "deletions": 118}, "files": [{"sha": "3d122516220e4a050de0bd72ab37ec86b9c6f020", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 66, "deletions": 118, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80225b66a6f57598b94ad854d8214592914c6062/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80225b66a6f57598b94ad854d8214592914c6062/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=80225b66a6f57598b94ad854d8214592914c6062", "patch": "@@ -837,7 +837,7 @@ emit_move_sequence (operands, mode, scratch_reg)\n \t  || (GET_CODE (operand1) == CONST_INT && INT_14_BITS (operand1))\n \t  || (operand1 == CONST0_RTX (mode))\n \t  || (GET_CODE (operand1) == HIGH\n-\t      && !symbolic_operand (XEXP (operand1, 0)))\n+\t      && !symbolic_operand (XEXP (operand1, 0), VOIDmode))\n \t  /* Only `general_operands' can come here, so MEM is ok.  */\n \t  || GET_CODE (operand1) == MEM)\n \t{\n@@ -1515,7 +1515,7 @@ output_block_move (operands, size_is_constant)\n       output_asm_insn (\"ldw 0(0,%1),%3\", operands);\n \n       /* Make %0 point at the first byte after the destination block.  */\n-      output_asm_insn (\"add %2,%0,%0\", operands);\n+      output_asm_insn (\"addl %2,%0,%0\", operands);\n       /* Store the leftmost bytes, up to, but not including, the address\n \t in %0.  */\n       output_asm_insn (\"stbys,e %3,0(0,%0)\", operands);\n@@ -1944,35 +1944,28 @@ compute_frame_size (size, fregs_live)\n      we need to add this in because of STARTING_FRAME_OFFSET. */\n   fsize = size + (size || frame_pointer_needed ? 8 : 0);\n \n-  for (i = 18; i >= 3; i--)\n+  for (i = 18; i >= 4; i--)\n     {\n-      /* fp is stored in a special place.  */\n-      if (regs_ever_live[i]\n-\t  && (i != FRAME_POINTER_REGNUM || !frame_pointer_needed))\n+      if (regs_ever_live[i])\n \tfsize += 4;\n     }\n-  fsize = (fsize + 7) & ~7;\n-\n-  if (!TARGET_SNAKE)\n-    {\n-      for (i = 43; i >= 40; i--)\n-\tif (regs_ever_live[i])\n-\t  {\n-\t    fsize += 8;\n-\t    if (fregs_live)\n-\t      *fregs_live = 1;\n-\t  }\n-    }\n-  else\n+  /* If we don't have a frame pointer, the register normally used for that\n+     purpose is saved just like other registers, not in the \"frame marker\".  */\n+  if (! frame_pointer_needed)\n     {\n-      for (i = 78; i >= 60; i -= 2)\n-\tif (regs_ever_live[i] || regs_ever_live[i + 1])\n-\t  {\n-\t    fsize += 8;\n-\t    if (fregs_live)\n-\t      *fregs_live = 1;\n-\t  }\n+      if (regs_ever_live[FRAME_POINTER_REGNUM])\n+\tfsize += 4;\n     }\n+  fsize = (fsize + 7) & ~7;\n+\n+  for (i = 66; i >= 48; i -= 2)\n+    if (regs_ever_live[i] || regs_ever_live[i + 1])\n+      {\n+\tfsize += 8;\n+\tif (fregs_live)\n+\t  *fregs_live = 1;\n+      }\n+\n   fsize += current_function_outgoing_args_size;\n   if (! leaf_function_p () || fsize)\n     fsize += 32;\n@@ -2030,14 +2023,12 @@ output_function_prologue (file, size)\n void\n hppa_expand_prologue()\n {\n-\n   extern char call_used_regs[];\n   int size = get_frame_size ();\n   int merge_sp_adjust_with_store = 0;\n   int i, offset;\n   rtx tmpreg, size_rtx;\n \n-\n   gr_saved = 0;\n   fr_saved = 0;\n   save_fregs = 0;\n@@ -2165,9 +2156,8 @@ hppa_expand_prologue()\n      was done earlier.  */\n   if (frame_pointer_needed)\n     {\n-      for (i = 18, offset = local_fsize; i >= 3; i--)\n-\tif (regs_ever_live[i] && ! call_used_regs[i]\n-\t    && i != FRAME_POINTER_REGNUM)\n+      for (i = 18, offset = local_fsize; i >= 4; i--)\n+\tif (regs_ever_live[i] && ! call_used_regs[i])\n \t  {\n \t    store_reg (i, offset, FRAME_POINTER_REGNUM);\n \t    offset += 4;\n@@ -2221,28 +2211,14 @@ hppa_expand_prologue()\n \tset_reg_plus_d (1, STACK_POINTER_REGNUM, offset);\n \n       /* Now actually save the FP registers.  */\n-      if (! TARGET_SNAKE)\n-\t{\n-\t  for (i = 43; i >= 40; i--)\n-\t    if (regs_ever_live[i])\n-\t      {\n-\t\temit_move_insn (gen_rtx (MEM, DFmode,\n-\t\t\t\t\t gen_rtx (POST_INC, DFmode, tmpreg)),\n-\t\t\t\tgen_rtx (REG, DFmode, i));\n-\t\tfr_saved++;\n-\t      }\n-\t}\n-      else\n-\t{\n-\t  for (i = 78; i >= 60; i -= 2)\n-\t    if (regs_ever_live[i] || regs_ever_live[i + 1])\n-\t      {\n-\t\temit_move_insn (gen_rtx (MEM, DFmode,\n-\t\t\t\t\t gen_rtx (POST_INC, DFmode, tmpreg)),\n-\t\t\t\tgen_rtx (REG, DFmode, i));\n-\t\tfr_saved++;\n-\t      }\n-\t}\n+      for (i = 66; i >= 48; i -= 2)\n+\tif (regs_ever_live[i] || regs_ever_live[i + 1])\n+\t  {\n+\t    emit_move_insn (gen_rtx (MEM, DFmode,\n+\t\t\t\t     gen_rtx (POST_INC, DFmode, tmpreg)),\n+\t\t\t    gen_rtx (REG, DFmode, i));\n+\t    fr_saved++;\n+\t  }\n     }\n }\n \n@@ -2306,9 +2282,8 @@ hppa_expand_epilogue ()\n   /* General register restores.  */\n   if (frame_pointer_needed)\n     {\n-      for (i = 18, offset = local_fsize; i >= 3; i--)\n-\tif (regs_ever_live[i] && ! call_used_regs[i]\n-\t    && i != FRAME_POINTER_REGNUM)\n+      for (i = 18, offset = local_fsize; i >= 4; i--)\n+\tif (regs_ever_live[i] && ! call_used_regs[i])\n \t  {\n \t    load_reg (i, offset, FRAME_POINTER_REGNUM);\n \t    offset += 4;\n@@ -2345,22 +2320,11 @@ hppa_expand_epilogue ()\n \tset_reg_plus_d (1, STACK_POINTER_REGNUM, offset);\n \n       /* Actually do the restores now.  */\n-      if (! TARGET_SNAKE)\n-\t{\n-\t  for (i = 43; i >= 40; i--)\n-\t    if (regs_ever_live[i])\n-\t      emit_move_insn (gen_rtx (REG, DFmode, i),\n-\t\t\t      gen_rtx (MEM, DFmode,\n-\t\t\t\t       gen_rtx (POST_INC, DFmode, tmpreg)));\n-\t}\n-      else\n-\t{\n-\t  for (i = 78; i >= 60; i -= 2)\n-\t    if (regs_ever_live[i] || regs_ever_live[i + 1])\n-\t      emit_move_insn (gen_rtx (REG, DFmode, i),\n-\t\t\t      gen_rtx (MEM, DFmode,\n-\t\t\t\t       gen_rtx (POST_INC, DFmode, tmpreg)));\n-\t}\n+      for (i = 66; i >= 48; i -= 2)\n+\tif (regs_ever_live[i] || regs_ever_live[i + 1])\n+\t  emit_move_insn (gen_rtx (REG, DFmode, i),\n+\t\t\t  gen_rtx (MEM, DFmode,\n+\t\t\t\t   gen_rtx (POST_INC, DFmode, tmpreg)));\n     }\n \n   /* No frame pointer, but we have a stack greater than 8k.  We restore\n@@ -2878,7 +2842,12 @@ print_operand (file, x, code)\n       abort ();\n     }\n   if (GET_CODE (x) == REG)\n-    fprintf (file, \"%s\", reg_names [REGNO (x)]);\n+    {\n+      if (FP_REG_P (x) && GET_MODE_SIZE (GET_MODE (x)) <= 4 && (REGNO (x) & 1) == 0)\n+\tfprintf (file, \"%sL\", reg_names [REGNO (x)]);\n+      else\n+\tfprintf (file, \"%s\", reg_names [REGNO (x)]);\n+    }\n   else if (GET_CODE (x) == MEM)\n     {\n       int size = GET_MODE_SIZE (GET_MODE (x));\n@@ -3164,12 +3133,12 @@ output_mod_insn (unsignedp, insn)\n }\n \n void\n-output_arg_descriptor (insn)\n-     rtx insn;\n+output_arg_descriptor (call_insn)\n+     rtx call_insn;\n {\n   char *arg_regs[4];\n   enum machine_mode arg_mode;\n-  rtx prev_insn;\n+  rtx link;\n   int i, output_flag = 0;\n   int regno;\n \n@@ -3185,64 +3154,43 @@ output_arg_descriptor (insn)\n       return;\n     }\n \n-  for (prev_insn = PREV_INSN (insn); GET_CODE (prev_insn) == INSN;\n-       prev_insn = PREV_INSN (prev_insn))\n+  if (GET_CODE (call_insn) != CALL_INSN)\n+    abort ();\n+  for (link = CALL_INSN_FUNCTION_USAGE (call_insn); link; link = XEXP (link, 1))\n     {\n-      /* Terminate search for arguments if a non-USE insn is encountered\n-\t or a USE insn which does not specify an argument, STATIC_CHAIN,\n-\t or STRUCT_VALUE register.  */\n-      if (!(GET_CODE (PATTERN (prev_insn)) == USE\n-\t    && GET_CODE (XEXP (PATTERN (prev_insn), 0)) == REG\n-\t    && (FUNCTION_ARG_REGNO_P (REGNO (XEXP (PATTERN (prev_insn), 0)))\n-\t\t|| REGNO (XEXP (PATTERN (prev_insn), 0)) == STATIC_CHAIN_REGNUM\n-\t\t|| REGNO (XEXP (PATTERN (prev_insn), 0))\n-\t\t== STRUCT_VALUE_REGNUM)))\n-\tbreak;\n+      rtx use = XEXP (link, 0);\n \n-      /* If this is a USE for the STATIC_CHAIN or STRUCT_VALUE register,\n-\t then skip it and continue the loop since those are not encoded\n-\t in the argument relocation bits.  */\n-      if (REGNO (XEXP (PATTERN (prev_insn), 0)) == STATIC_CHAIN_REGNUM\n-\t  || REGNO (XEXP (PATTERN (prev_insn), 0)) == STRUCT_VALUE_REGNUM)\n+      if (! (GET_CODE (use) == USE\n+\t     && GET_CODE (XEXP (use, 0)) == REG\n+\t     && FUNCTION_ARG_REGNO_P (REGNO (XEXP (use, 0)))))\n \tcontinue;\n \n-      arg_mode = GET_MODE (XEXP (PATTERN (prev_insn), 0));\n-      regno = REGNO (XEXP (PATTERN (prev_insn), 0));\n+      arg_mode = GET_MODE (XEXP (use, 0));\n+      regno = REGNO (XEXP (use, 0));\n       if (regno >= 23 && regno <= 26)\n \t{\n \t  arg_regs[26 - regno] = \"GR\";\n \t  if (arg_mode == DImode)\n \t    arg_regs[25 - regno] = \"GR\";\n \t}\n-      else if (!TARGET_SNAKE)\t/* fp args */\n+      else if (regno >= 32 && regno <= 39)\n \t{\n+\t  if ((regno & 1) != 0)\n+\t    abort ();\n \t  if (arg_mode == SFmode)\n-\t    arg_regs[regno - 32] = \"FR\";\n-\t  else\n+\t    arg_regs[(regno - 32) / 2] = \"FR\";\n+\t  else if (arg_mode == DFmode)\n \t    {\n #ifndef HP_FP_ARG_DESCRIPTOR_REVERSED\n-\t      arg_regs[regno - 33] = \"FR\";\n-\t      arg_regs[regno - 32] = \"FU\";\n+\t      arg_regs[(regno - 34) / 2] = \"FR\";\n+\t      arg_regs[(regno - 34) / 2 + 1] = \"FU\";\n #else\n-\t      arg_regs[regno - 33] = \"FU\";\n-\t      arg_regs[regno - 32] = \"FR\";\n+\t      arg_regs[(regno - 34) / 2] = \"FU\";\n+\t      arg_regs[(regno - 34) / 2 + 1] = \"FR\";\n #endif\n \t    }\n-\t}\n-      else\n-\t{\n-\t  if (arg_mode == SFmode)\n-\t    arg_regs[(regno - 44) / 2] = \"FR\";\n \t  else\n-\t    {\n-#ifndef HP_FP_ARG_DESCRIPTOR_REVERSED\n-\t      arg_regs[(regno - 46) / 2] = \"FR\";\n-\t      arg_regs[(regno - 46) / 2 + 1] = \"FU\";\n-#else\n-\t      arg_regs[(regno - 46) / 2] = \"FU\";\n-\t      arg_regs[(regno - 46) / 2 + 1] = \"FR\";\n-#endif\n-\t    }\n+\t    abort ();\n \t}\n     }\n   fputs (\"\\t.CALL \", asm_out_file);\n@@ -3848,7 +3796,7 @@ function_label_operand  (op, mode)\n /* Returns 1 if the 6 operands specified in OPERANDS are suitable for\n    use in fmpyadd instructions.  */\n int\n-fmpyaddoperands(operands)\n+fmpyaddoperands (operands)\n      rtx *operands;\n {\n   enum machine_mode mode = GET_MODE (operands[0]);\n@@ -3890,7 +3838,7 @@ fmpyaddoperands(operands)\n /* Returns 1 if the 6 operands specified in OPERANDS are suitable for\n    use in fmpysub instructions.  */\n int\n-fmpysuboperands(operands)\n+fmpysuboperands (operands)\n      rtx *operands;\n {\n   enum machine_mode mode = GET_MODE (operands[0]);"}]}