{"sha": "a1ad0d84d7fcbcaa7a697290387b911eb7e1bd46", "node_id": "C_kwDOANBUbNoAKGExYWQwZDg0ZDdmY2JjYWE3YTY5NzI5MDM4N2I5MTFlYjdlMWJkNDY", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2021-09-09T13:17:27Z"}, "committer": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2021-11-10T14:17:13Z"}, "message": "attribs: Implement -Wno-attributes=vendor::attr [PR101940]\n\nIt is desirable for -Wattributes to warn about e.g.\n\n[[deprecate]] void g(); // typo, should warn\n\nHowever, -Wattributes also warns about vendor-specific attributes\n(that's because lookup_scoped_attribute_spec -> find_attribute_namespace\nfinds nothing), which, with -Werror, causes grief.  We don't want the\n-Wattributes warning for\n\n[[company::attr]] void f();\n\nGCC warns because it doesn't know the \"company\" namespace; it only knows\nthe \"gnu\" and \"omp\" namespaces.  We could entirely disable warning about\nattributes in unknown scopes but then the compiler would also miss typos\nlike\n\n  [[company::attrx]] void f();\n\nor\n\n  [[gmu::warn_used_result]] int write();\n\nso that is not a viable solution.  A workaround is to use a #pragma:\n\n  #pragma GCC diagnostic push\n  #pragma GCC diagnostic ignored \"-Wattributes\"\n  [[company::attr]] void f() {}\n  #pragma GCC diagnostic pop\n\nbut that's a mouthful and awkward to use and could also hide typos.  In\nfact, any macro-based solution doesn't seem like a way forward.\n\nThis patch implements -Wno-attributes=, which takes these arguments:\n\ncompany::attr\ncompany::\n\nThis option should go well with using @file: the user could have a file\ncontaining\n-Wno-attributes=vendor::attr1,vendor::attr2\nand then invoke gcc with '@attrs' or similar.\n\nI've also added a new pragma which has the same effect:\n\nThe pragma along with the new option should help with various static\nanalysis tools.\n\n\tPR c++/101940\n\ngcc/ChangeLog:\n\n\t* attribs.c (struct scoped_attributes): Add a bool member.\n\t(lookup_scoped_attribute_spec): Forward declare.\n\t(register_scoped_attributes): New bool parameter, defaulted to\n\tfalse.  Use it.\n\t(handle_ignored_attributes_option): New function.\n\t(free_attr_data): New function.\n\t(init_attributes): Call handle_ignored_attributes_option.\n\t(attr_namespace_ignored_p): New function.\n\t(decl_attributes): Check attr_namespace_ignored_p before\n\twarning.\n\t* attribs.h (free_attr_data): Declare.\n\t(register_scoped_attributes): Adjust declaration.\n\t(handle_ignored_attributes_option): Declare.\n\t(canonicalize_attr_name): New function template.\n\t(canonicalize_attr_name): Use it.\n\t* common.opt (Wattributes=): New option with a variable.\n\t* doc/extend.texi: Document #pragma GCC diagnostic ignored_attributes.\n\t* doc/invoke.texi: Document -Wno-attributes=.\n\t* opts.c (common_handle_option) <case OPT_Wattributes_>: Handle.\n\t* plugin.h (register_scoped_attributes): Adjust declaration.\n\t* toplev.c (compile_file): Call free_attr_data.\n\ngcc/c-family/ChangeLog:\n\n\t* c-pragma.c (handle_pragma_diagnostic): Handle #pragma GCC diagnostic\n\tignored_attributes.\n\ngcc/testsuite/ChangeLog:\n\n\t* c-c++-common/Wno-attributes-1.c: New test.\n\t* c-c++-common/Wno-attributes-2.c: New test.\n\t* c-c++-common/Wno-attributes-3.c: New test.", "tree": {"sha": "c949ed2541754ece382176b093be439453662d04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c949ed2541754ece382176b093be439453662d04"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a1ad0d84d7fcbcaa7a697290387b911eb7e1bd46", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1ad0d84d7fcbcaa7a697290387b911eb7e1bd46", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1ad0d84d7fcbcaa7a697290387b911eb7e1bd46", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1ad0d84d7fcbcaa7a697290387b911eb7e1bd46/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9701f153f6dfcc365ac0d96cdcf7df69a2de81dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9701f153f6dfcc365ac0d96cdcf7df69a2de81dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9701f153f6dfcc365ac0d96cdcf7df69a2de81dc"}], "stats": {"total": 386, "additions": 374, "deletions": 12}, "files": [{"sha": "0284e5bf2fde9314358f1cb20302e342219262be", "filename": "gcc/attribs.c", "status": "modified", "additions": 123, "deletions": 4, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ad0d84d7fcbcaa7a697290387b911eb7e1bd46/gcc%2Fattribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ad0d84d7fcbcaa7a697290387b911eb7e1bd46/gcc%2Fattribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fattribs.c?ref=a1ad0d84d7fcbcaa7a697290387b911eb7e1bd46", "patch": "@@ -87,6 +87,8 @@ struct scoped_attributes\n   const char *ns;\n   vec<attribute_spec> attributes;\n   hash_table<attribute_hasher> *attribute_hash;\n+  /* True if we should not warn about unknown attributes in this NS.  */\n+  bool ignored_p;\n };\n \n /* The table of scope attributes.  */\n@@ -95,6 +97,8 @@ static vec<scoped_attributes> attributes_table;\n static scoped_attributes* find_attribute_namespace (const char*);\n static void register_scoped_attribute (const struct attribute_spec *,\n \t\t\t\t       scoped_attributes *);\n+static const struct attribute_spec *lookup_scoped_attribute_spec (const_tree,\n+\t\t\t\t\t\t\t\t  const_tree);\n \n static bool attributes_initialized = false;\n \n@@ -121,12 +125,14 @@ extract_attribute_substring (struct substring *str)\n \n /* Insert an array of attributes ATTRIBUTES into a namespace.  This\n    array must be NULL terminated.  NS is the name of attribute\n-   namespace.  The function returns the namespace into which the\n-   attributes have been registered.  */\n+   namespace.  IGNORED_P is true iff all unknown attributes in this\n+   namespace should be ignored for the purposes of -Wattributes.  The\n+   function returns the namespace into which the attributes have been\n+   registered.  */\n \n scoped_attributes *\n register_scoped_attributes (const struct attribute_spec *attributes,\n-\t\t\t    const char *ns)\n+\t\t\t    const char *ns, bool ignored_p /*=false*/)\n {\n   scoped_attributes *result = NULL;\n \n@@ -144,9 +150,12 @@ register_scoped_attributes (const struct attribute_spec *attributes,\n       memset (&sa, 0, sizeof (sa));\n       sa.ns = ns;\n       sa.attributes.create (64);\n+      sa.ignored_p = ignored_p;\n       result = attributes_table.safe_push (sa);\n       result->attribute_hash = new hash_table<attribute_hasher> (200);\n     }\n+  else\n+    result->ignored_p |= ignored_p;\n \n   /* Really add the attributes to their namespace now.  */\n   for (unsigned i = 0; attributes[i].name != NULL; ++i)\n@@ -224,6 +233,99 @@ check_attribute_tables (void)\n \t\t\t\t attribute_tables[j][l].name));\n }\n \n+/* Used to stash pointers to allocated memory so that we can free them at\n+   the end of parsing of all TUs. */\n+static vec<attribute_spec *> ignored_attributes_table;\n+\n+/* Parse arguments V of -Wno-attributes=.\n+   Currently we accept:\n+     vendor::attr\n+     vendor::\n+   This functions also registers the parsed attributes so that we don't\n+   warn that we don't recognize them.  */\n+\n+void\n+handle_ignored_attributes_option (vec<char *> *v)\n+{\n+  if (v == nullptr)\n+    return;\n+\n+  for (auto opt : v)\n+    {\n+      char *cln = strstr (opt, \"::\");\n+      /* We don't accept '::attr'.  */\n+      if (cln == nullptr || cln == opt)\n+\t{\n+\t  error (\"wrong argument to ignored attributes\");\n+\t  inform (input_location, \"valid format is %<ns::attr%> or %<ns::%>\");\n+\t  continue;\n+\t}\n+      const char *vendor_start = opt;\n+      ptrdiff_t vendor_len = cln - opt;\n+      const char *attr_start = cln + 2;\n+      /* This could really use rawmemchr :(.  */\n+      ptrdiff_t attr_len = strchr (attr_start, '\\0') - attr_start;\n+      /* Verify that they look valid.  */\n+      auto valid_p = [](const char *const s, ptrdiff_t len) {\n+\tbool ok = false;\n+\n+\tfor (int i = 0; i < len; ++i)\n+\t  if (ISALNUM (s[i]))\n+\t    ok = true;\n+\t  else if (s[i] != '_')\n+\t    return false;\n+\n+\treturn ok;\n+      };\n+      if (!valid_p (vendor_start, vendor_len))\n+\t{\n+\t  error (\"wrong argument to ignored attributes\");\n+\t  continue;\n+\t}\n+      canonicalize_attr_name (vendor_start, vendor_len);\n+      /* We perform all this hijinks so that we don't have to copy OPT.  */\n+      tree vendor_id = get_identifier_with_length (vendor_start, vendor_len);\n+      const char *attr;\n+      /* In the \"vendor::\" case, we should ignore *any* attribute coming\n+\t from this attribute namespace.  */\n+      if (attr_len > 0)\n+\t{\n+\t  if (!valid_p (attr_start, attr_len))\n+\t    {\n+\t      error (\"wrong argument to ignored attributes\");\n+\t      continue;\n+\t    }\n+\t  canonicalize_attr_name (attr_start, attr_len);\n+\t  tree attr_id = get_identifier_with_length (attr_start, attr_len);\n+\t  attr = IDENTIFIER_POINTER (attr_id);\n+\t  /* If we've already seen this vendor::attr, ignore it.  Attempting to\n+\t     register it twice would lead to a crash.  */\n+\t  if (lookup_scoped_attribute_spec (vendor_id, attr_id))\n+\t    continue;\n+\t}\n+      else\n+\tattr = nullptr;\n+      /* Create a table with extra attributes which we will register.\n+\t We can't free it here, so squirrel away the pointers.  */\n+      attribute_spec *table = new attribute_spec[2];\n+      ignored_attributes_table.safe_push (table);\n+      table[0] = { attr, 0, 0, false, false, false, false, nullptr, nullptr };\n+      table[1] = { nullptr, 0, 0, false, false, false, false, nullptr,\n+\t\t   nullptr };\n+      register_scoped_attributes (table, IDENTIFIER_POINTER (vendor_id), !attr);\n+    }\n+}\n+\n+/* Free data we might have allocated when adding extra attributes.  */\n+\n+void\n+free_attr_data ()\n+{\n+  for (auto x : ignored_attributes_table)\n+    delete[] x;\n+  ignored_attributes_table.release ();\n+}\n+\n /* Initialize attribute tables, and make some sanity checks if checking is\n    enabled.  */\n \n@@ -252,6 +354,9 @@ init_attributes (void)\n     /* Put all the GNU attributes into the \"gnu\" namespace.  */\n     register_scoped_attributes (attribute_tables[i], \"gnu\");\n \n+  vec<char *> *ignored = (vec<char *> *) flag_ignored_attributes;\n+  handle_ignored_attributes_option (ignored);\n+\n   invoke_plugin_callbacks (PLUGIN_ATTRIBUTES, NULL);\n   attributes_initialized = true;\n }\n@@ -456,6 +561,19 @@ diag_attr_exclusions (tree last_decl, tree node, tree attrname,\n   return found;\n }\n \n+/* Return true iff we should not complain about unknown attributes\n+   coming from the attribute namespace NS.  This is the case for\n+   the -Wno-attributes=ns:: command-line option.  */\n+\n+static bool\n+attr_namespace_ignored_p (tree ns)\n+{\n+  if (ns == NULL_TREE)\n+    return false;\n+  scoped_attributes *r = find_attribute_namespace (IDENTIFIER_POINTER (ns));\n+  return r && r->ignored_p;\n+}\n+\n /* Process the attributes listed in ATTRIBUTES and install them in *NODE,\n    which is either a DECL (including a TYPE_DECL) or a TYPE.  If a DECL,\n    it should be modified in place; if a TYPE, a copy should be created\n@@ -556,7 +674,8 @@ decl_attributes (tree *node, tree attributes, int flags,\n \n       if (spec == NULL)\n \t{\n-\t  if (!(flags & (int) ATTR_FLAG_BUILT_IN))\n+\t  if (!(flags & (int) ATTR_FLAG_BUILT_IN)\n+\t      && !attr_namespace_ignored_p (ns))\n \t    {\n \t      if (ns == NULL_TREE || !cxx11_attr_p)\n \t\twarning (OPT_Wattributes, \"%qE attribute directive ignored\","}, {"sha": "ba657881940c4a2c9e83398d570e3b3f52ff7228", "filename": "gcc/attribs.h", "status": "modified", "additions": 24, "deletions": 4, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ad0d84d7fcbcaa7a697290387b911eb7e1bd46/gcc%2Fattribs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ad0d84d7fcbcaa7a697290387b911eb7e1bd46/gcc%2Fattribs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fattribs.h?ref=a1ad0d84d7fcbcaa7a697290387b911eb7e1bd46", "patch": "@@ -21,6 +21,7 @@ along with GCC; see the file COPYING3.  If not see\n #define GCC_ATTRIBS_H\n \n extern const struct attribute_spec *lookup_attribute_spec (const_tree);\n+extern void free_attr_data ();\n extern void init_attributes (void);\n \n /* Process the attributes listed in ATTRIBUTES and install them in *NODE,\n@@ -40,12 +41,14 @@ extern void apply_tm_attr (tree, tree);\n extern tree make_attribute (const char *, const char *, tree);\n \n extern struct scoped_attributes* register_scoped_attributes (const struct attribute_spec *,\n-\t\t\t\t\t\t\t     const char *);\n+\t\t\t\t\t\t\t     const char *,\n+\t\t\t\t\t\t\t     bool = false);\n \n extern char *sorted_attr_string (tree);\n extern bool common_function_versions (tree, tree);\n extern tree make_dispatcher_decl (const tree);\n extern bool is_function_default_version (const tree);\n+extern void handle_ignored_attributes_option (vec<char *> *);\n \n /* Return a type like TTYPE except that its TYPE_ATTRIBUTES\n    is ATTRIBUTE.\n@@ -114,17 +117,34 @@ extern unsigned decls_mismatched_attributes (tree, tree, tree,\n \n extern void maybe_diag_alias_attributes (tree, tree);\n \n+/* For a given string S of length L, strip leading and trailing '_' characters\n+   so that we have a canonical form of attribute names.  NB: This function may\n+   change S and L.  */\n+\n+template <typename T>\n+inline bool\n+canonicalize_attr_name (const char *&s, T &l)\n+{\n+  if (l > 4 && s[0] == '_' && s[1] == '_' && s[l - 1] == '_' && s[l - 2] == '_')\n+    {\n+      s += 2;\n+      l -= 4;\n+      return true;\n+    }\n+  return false;\n+}\n+\n /* For a given IDENTIFIER_NODE, strip leading and trailing '_' characters\n    so that we have a canonical form of attribute names.  */\n \n static inline tree\n canonicalize_attr_name (tree attr_name)\n {\n-  const size_t l = IDENTIFIER_LENGTH (attr_name);\n+  size_t l = IDENTIFIER_LENGTH (attr_name);\n   const char *s = IDENTIFIER_POINTER (attr_name);\n \n-  if (l > 4 && s[0] == '_' && s[1] == '_' && s[l - 1] == '_' && s[l - 2] == '_')\n-    return get_identifier_with_length (s + 2, l - 4);\n+  if (canonicalize_attr_name (s, l))\n+    return get_identifier_with_length (s, l);\n \n   return attr_name;\n }"}, {"sha": "3663eb1cfbbe94acf4b7433b9ef333de782b1f6e", "filename": "gcc/c-family/c-pragma.c", "status": "modified", "additions": 35, "deletions": 2, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ad0d84d7fcbcaa7a697290387b911eb7e1bd46/gcc%2Fc-family%2Fc-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ad0d84d7fcbcaa7a697290387b911eb7e1bd46/gcc%2Fc-family%2Fc-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pragma.c?ref=a1ad0d84d7fcbcaa7a697290387b911eb7e1bd46", "patch": "@@ -771,7 +771,7 @@ handle_pragma_diagnostic(cpp_reader *ARG_UNUSED(dummy))\n   if (token != CPP_NAME)\n     {\n       warning_at (loc, OPT_Wpragmas,\n-\t\t  \"missing [error|warning|ignored|push|pop]\"\n+\t\t  \"missing [error|warning|ignored|push|pop|ignored_attributes]\"\n \t\t  \" after %<#pragma GCC diagnostic%>\");\n       return;\n     }\n@@ -794,10 +794,43 @@ handle_pragma_diagnostic(cpp_reader *ARG_UNUSED(dummy))\n       diagnostic_pop_diagnostics (global_dc, input_location);\n       return;\n     }\n+  else if (strcmp (kind_string, \"ignored_attributes\") == 0)\n+    {\n+      token = pragma_lex (&x, &loc);\n+      if (token != CPP_STRING)\n+\t{\n+\t  warning_at (loc, OPT_Wpragmas,\n+\t\t      \"missing attribute name after %<#pragma GCC diagnostic \"\n+\t\t      \"ignored_attributes%>\");\n+\t  return;\n+\t}\n+      char *args = xstrdup (TREE_STRING_POINTER (x));\n+      const size_t l = strlen (args);\n+      if (l == 0)\n+\t{\n+\t  warning_at (loc, OPT_Wpragmas, \"missing argument to %<#pragma GCC \"\n+\t\t      \"diagnostic ignored_attributes%>\");\n+\t  free (args);\n+\t  return;\n+\t}\n+      else if (args[l - 1] == ',')\n+\t{\n+\t  warning_at (loc, OPT_Wpragmas, \"trailing %<,%> in arguments for \"\n+\t\t      \"%<#pragma GCC diagnostic ignored_attributes%>\");\n+\t  free (args);\n+\t  return;\n+\t}\n+      auto_vec<char *> v;\n+      for (char *p = strtok (args, \",\"); p; p = strtok (NULL, \",\"))\n+\tv.safe_push (p);\n+      handle_ignored_attributes_option (&v);\n+      free (args);\n+      return;\n+    }\n   else\n     {\n       warning_at (loc, OPT_Wpragmas,\n-\t\t  \"expected [error|warning|ignored|push|pop]\"\n+\t\t  \"expected [error|warning|ignored|push|pop|ignored_attributes]\"\n \t\t  \" after %<#pragma GCC diagnostic%>\");\n       return;\n     }"}, {"sha": "de9b848eda5e0a53dc9cd7190d535d4212c41ed7", "filename": "gcc/common.opt", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ad0d84d7fcbcaa7a697290387b911eb7e1bd46/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ad0d84d7fcbcaa7a697290387b911eb7e1bd46/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=a1ad0d84d7fcbcaa7a697290387b911eb7e1bd46", "patch": "@@ -83,14 +83,17 @@ int flag_gen_aux_info = 0\n Variable\n int flag_shlib\n \n-; These two are really VEC(char_p,heap) *.\n+; These three are really VEC(char_p,heap) *.\n \n Variable\n void *flag_instrument_functions_exclude_functions\n \n Variable\n void *flag_instrument_functions_exclude_files\n \n+Variable\n+void *flag_ignored_attributes\n+\n ; Generic structs (e.g. templates not explicitly specialized)\n ; may not have a compilation unit associated with them, and so\n ; may need to be treated differently from ordinary structs.\n@@ -549,6 +552,10 @@ Wattributes\n Common Var(warn_attributes) Init(1) Warning\n Warn about inappropriate attribute usage.\n \n+Wattributes=\n+Common Joined\n+Do not warn about specified attributes.\n+\n Wattribute-alias\n Common Alias(Wattribute_alias=, 1, 0) Warning\n Warn about type safety and similar errors and mismatches in declarations with alias attributes."}, {"sha": "6e6c580e32929572df18e6e289df6f5ade9c262b", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ad0d84d7fcbcaa7a697290387b911eb7e1bd46/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ad0d84d7fcbcaa7a697290387b911eb7e1bd46/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=a1ad0d84d7fcbcaa7a697290387b911eb7e1bd46", "patch": "@@ -23767,6 +23767,25 @@ restored.\n   foo(d);                       /* depends on command-line options */\n @end smallexample\n \n+@item #pragma GCC diagnostic ignored_attributes\n+\n+Similarly to @option{-Wno-attributes=}, this pragma allows users to suppress\n+warnings about unknown scoped attributes (in C++11 and C2X).  For example,\n+@code{#pragma GCC diagnostic ignored_attributes \"vendor::attr\"} disables\n+warning about the following declaration:\n+\n+@smallexample\n+[[vendor::attr]] void f();\n+@end smallexample\n+\n+whereas @code{#pragma GCC diagnostic ignored_attributes \"vendor::\"} prevents\n+warning about both of these declarations:\n+\n+@smallexample\n+[[vendor::safe]] void f();\n+[[vendor::unsafe]] void f2();\n+@end smallexample\n+\n @end table\n \n GCC also offers a simple mechanism for printing messages during"}, {"sha": "a7c4d24a7624ff2757c71c7e47740636ae6bda08", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ad0d84d7fcbcaa7a697290387b911eb7e1bd46/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ad0d84d7fcbcaa7a697290387b911eb7e1bd46/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=a1ad0d84d7fcbcaa7a697290387b911eb7e1bd46", "patch": "@@ -8707,6 +8707,26 @@ unrecognized attributes, function attributes applied to variables,\n etc.  This does not stop errors for incorrect use of supported\n attributes.\n \n+Additionally, using @option{-Wno-attributes=}, it is possible to suppress\n+warnings about unknown scoped attributes (in C++11 and C2X).  For example,\n+@option{-Wno-attributes=vendor::attr} disables warning about the following\n+declaration:\n+\n+@smallexample\n+[[vendor::attr]] void f();\n+@end smallexample\n+\n+It is also possible to disable warning about all attributes in a namespace\n+using @option{-Wno-attributes=vendor::} which prevents warning about both\n+of these declarations:\n+\n+@smallexample\n+[[vendor::safe]] void f();\n+[[vendor::unsafe]] void f2();\n+@end smallexample\n+\n+Note that @option{-Wno-attributes=} does not imply @option{-Wno-attributes}.\n+\n @item -Wno-builtin-declaration-mismatch\n @opindex Wno-builtin-declaration-mismatch\n @opindex Wbuiltin-declaration-mismatch"}, {"sha": "175b4635bb4d0e64597e1080e4458cfeb58538e8", "filename": "gcc/opts.c", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ad0d84d7fcbcaa7a697290387b911eb7e1bd46/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ad0d84d7fcbcaa7a697290387b911eb7e1bd46/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=a1ad0d84d7fcbcaa7a697290387b911eb7e1bd46", "patch": "@@ -2611,6 +2611,26 @@ common_handle_option (struct gcc_options *opts,\n       /* Currently handled in a prescan.  */\n       break;\n \n+    case OPT_Wattributes_:\n+      if (lang_mask == CL_DRIVER)\n+\tbreak;\n+\n+      if (value)\n+\t{\n+\t  error_at (loc, \"arguments ignored for %<-Wattributes=%>; use \"\n+\t\t    \"%<-Wno-attributes=%> instead\");\n+\t  break;\n+\t}\n+      else if (arg[strlen (arg) - 1] == ',')\n+\t{\n+\t  error_at (loc, \"trailing %<,%> in arguments for \"\n+\t\t    \"%<-Wno-attributes=%>\");\n+\t  break;\n+\t}\n+\n+      add_comma_separated_to_vector (&opts->x_flag_ignored_attributes, arg);\n+      break;\n+\n     case OPT_Werror:\n       dc->warning_as_error_requested = value;\n       break;"}, {"sha": "5556763d1bfbae5a89b5fc1045ebaf2bbf9b6842", "filename": "gcc/plugin.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ad0d84d7fcbcaa7a697290387b911eb7e1bd46/gcc%2Fplugin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ad0d84d7fcbcaa7a697290387b911eb7e1bd46/gcc%2Fplugin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fplugin.h?ref=a1ad0d84d7fcbcaa7a697290387b911eb7e1bd46", "patch": "@@ -197,7 +197,9 @@ invoke_plugin_callbacks (int event ATTRIBUTE_UNUSED,\n /* In attribs.c.  */\n \n extern void register_attribute (const struct attribute_spec *attr);\n+/* The default argument for the third parameter is given in attribs.h.  */\n extern struct scoped_attributes* register_scoped_attributes (const struct attribute_spec *,\n-\t\t\t\t\t\t\t     const char *);\n+\t\t\t\t\t\t\t     const char *,\n+\t\t\t\t\t\t\t     bool);\n \n #endif /* PLUGIN_H */"}, {"sha": "aac1a69fd85d174cde9d5629c76bc4d8ffacb272", "filename": "gcc/testsuite/c-c++-common/Wno-attributes-1.c", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ad0d84d7fcbcaa7a697290387b911eb7e1bd46/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWno-attributes-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ad0d84d7fcbcaa7a697290387b911eb7e1bd46/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWno-attributes-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWno-attributes-1.c?ref=a1ad0d84d7fcbcaa7a697290387b911eb7e1bd46", "patch": "@@ -0,0 +1,55 @@\n+/* PR c++/101940 */\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-std=c++11\" { target c++ } } */\n+/* { dg-additional-options \"-Wno-attributes=company::,yoyodyne::attr\" } */\n+/* { dg-additional-options \"-Wno-attributes=c1::attr,c1::attr,c1::__attr__\" } */\n+/* { dg-additional-options \"-Wno-attributes=c2::,c2::attr\" } */\n+/* { dg-additional-options \"-Wno-attributes=c3::attr,c3::\" } */\n+/* { dg-additional-options \"-Wno-attributes=x::\" } */\n+/* { dg-additional-options \"-Wno-attributes=yoyodyne::attr_new\" } */\n+/* { dg-additional-options \"-Wno-attributes=c4::__attr__\" } */\n+/* { dg-additional-options \"-Wno-attributes=c5::attr\" } */\n+/* { dg-additional-options \"-Wno-attributes=__c6__::attr\" } */\n+\n+[[company::attr]] void f1();\n+[[company::attr2]] void f2();\n+\n+[[yoyodyne::attr]] void f3();\n+[[yoyodyne::__attr__]] void f3__();\n+[[yoyodyne::attrx]] void f4(); /* { dg-warning \"ignored\" } */\n+[[yoyodyne::__attrx__]] void f4__(); /* { dg-warning \"ignored\" } */\n+\n+[[c1::attr]] void f5();\n+\n+[[c2::attr]] void f6();\n+[[c2::attrx]] void f7();\n+[[c2::__attr__]] void f6__();\n+[[c2::__attrx__]] void f7__();\n+\n+[[c3::attr]] void f8();\n+[[c3::attrx]] void f9();\n+\n+[[x::x]] void f10();\n+\n+[[yoyodyne::attr_new]] void f11();\n+[[yoyodyne::__attr_new__]] void f11__();\n+[[yoyodyne::attr_mew]] void f12(); /* { dg-warning \"ignored\" } */\n+[[yoyodyne::__attr_mew__]] void f12__(); /* { dg-warning \"ignored\" } */\n+\n+[[c4::attr]] void f13();\n+[[c4::__attr__]] void f13__();\n+[[c4::attrx]] void f14(); /* { dg-warning \"ignored\" } */\n+\n+[[c5::attr]] void f15();\n+[[c5::__attr__]] void f15__();\n+[[__c5__::attr]] void __f15();\n+[[__c5__::__attr__]] void __f15__();\n+[[c5::attrx]] void f15x(); /* { dg-warning \"ignored\" } */\n+[[__c5__::attrx]] void f15x(); /* { dg-warning \"ignored\" } */\n+\n+[[c6::attr]] void f16();\n+[[c6::__attr__]] void f16__();\n+[[__c6__::attr]] void __f16();\n+[[__c6__::__attr__]] void __f16__();\n+[[c6::attrx]] void f16x(); /* { dg-warning \"ignored\" } */\n+[[__c6__::attrx]] void f16x(); /* { dg-warning \"ignored\" } */"}, {"sha": "4307c74b0486924fb9671b926317868a702d82e2", "filename": "gcc/testsuite/c-c++-common/Wno-attributes-2.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ad0d84d7fcbcaa7a697290387b911eb7e1bd46/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWno-attributes-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ad0d84d7fcbcaa7a697290387b911eb7e1bd46/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWno-attributes-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWno-attributes-2.c?ref=a1ad0d84d7fcbcaa7a697290387b911eb7e1bd46", "patch": "@@ -0,0 +1,56 @@\n+/* PR c++/101940 */\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-std=c++11\" { target c++ } } */\n+\n+#pragma GCC diagnostic ignored_attributes \"company::,yoyodyne::attr\"\n+#pragma GCC diagnostic ignored_attributes \"c1::attr,c1::attr,c1::__attr__\"\n+#pragma GCC diagnostic ignored_attributes \"c2::,c2::attr\"\n+#pragma GCC diagnostic ignored_attributes \"c3::attr,c3::\"\n+#pragma GCC diagnostic ignored_attributes \"x::\"\n+#pragma GCC diagnostic ignored_attributes \"yoyodyne::attr_new\"\n+#pragma GCC diagnostic ignored_attributes \"c4::__attr__\"\n+#pragma GCC diagnostic ignored_attributes \"c5::attr\"\n+#pragma GCC diagnostic ignored_attributes \"__c6__::attr\"\n+\n+[[company::attr]] void f1();\n+[[company::attr2]] void f2();\n+\n+[[yoyodyne::attr]] void f3();\n+[[yoyodyne::__attr__]] void f3__();\n+[[yoyodyne::attrx]] void f4(); /* { dg-warning \"ignored\" } */\n+[[yoyodyne::__attrx__]] void f4__(); /* { dg-warning \"ignored\" } */\n+\n+[[c1::attr]] void f5();\n+\n+[[c2::attr]] void f6();\n+[[c2::attrx]] void f7();\n+[[c2::__attr__]] void f6__();\n+[[c2::__attrx__]] void f7__();\n+\n+[[c3::attr]] void f8();\n+[[c3::attrx]] void f9();\n+\n+[[x::x]] void f10();\n+\n+[[yoyodyne::attr_new]] void f11();\n+[[yoyodyne::__attr_new__]] void f11__();\n+[[yoyodyne::attr_mew]] void f12(); /* { dg-warning \"ignored\" } */\n+[[yoyodyne::__attr_mew__]] void f12__(); /* { dg-warning \"ignored\" } */\n+\n+[[c4::attr]] void f13();\n+[[c4::__attr__]] void f13__();\n+[[c4::attrx]] void f14(); /* { dg-warning \"ignored\" } */\n+\n+[[c5::attr]] void f15();\n+[[c5::__attr__]] void f15__();\n+[[__c5__::attr]] void __f15();\n+[[__c5__::__attr__]] void __f15__();\n+[[c5::attrx]] void f15x(); /* { dg-warning \"ignored\" } */\n+[[__c5__::attrx]] void f15x(); /* { dg-warning \"ignored\" } */\n+\n+[[c6::attr]] void f16();\n+[[c6::__attr__]] void f16__();\n+[[__c6__::attr]] void __f16();\n+[[__c6__::__attr__]] void __f16__();\n+[[c6::attrx]] void f16x(); /* { dg-warning \"ignored\" } */\n+[[__c6__::attrx]] void f16x(); /* { dg-warning \"ignored\" } */"}, {"sha": "64370f2ef6f684c8db06d9dd4a140ea768f1f0fa", "filename": "gcc/testsuite/c-c++-common/Wno-attributes-3.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ad0d84d7fcbcaa7a697290387b911eb7e1bd46/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWno-attributes-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ad0d84d7fcbcaa7a697290387b911eb7e1bd46/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWno-attributes-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWno-attributes-3.c?ref=a1ad0d84d7fcbcaa7a697290387b911eb7e1bd46", "patch": "@@ -0,0 +1,9 @@\n+/* PR c++/101940 */\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-Wno-attributes=___::\" } */\n+/* { dg-additional-options \"-Wno-attributes=c::____\" } */\n+/* { dg-additional-options \"-Wno-attributes=____::____\" } */\n+/* { dg-additional-options \"-Wno-attributes=c@::attr\" } */\n+/* { dg-additional-options \"-Wno-attributes=c2::@tr\" } */\n+\n+/* { dg-error \"wrong argument to ignored attributes\" \"\" { target *-*-* } 0 } */"}, {"sha": "99276bde87daf92857d59392b21a41fb730596d5", "filename": "gcc/toplev.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ad0d84d7fcbcaa7a697290387b911eb7e1bd46/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ad0d84d7fcbcaa7a697290387b911eb7e1bd46/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=a1ad0d84d7fcbcaa7a697290387b911eb7e1bd46", "patch": "@@ -457,6 +457,8 @@ compile_file (void)\n   if (flag_dump_locations)\n     dump_location_info (stderr);\n \n+  free_attr_data ();\n+\n   /* Compilation is now finished except for writing\n      what's left of the symbol table output.  */\n "}]}