{"sha": "7405bd18066d283bff49348d81c2985b134f5a79", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzQwNWJkMTgwNjZkMjgzYmZmNDkzNDhkODFjMjk4NWIxMzRmNWE3OQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2013-11-04T09:04:22Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2013-11-04T09:04:22Z"}, "message": "avr-log.c (avr_double_int_pop_digit): Delete.\n\ngcc/\n\t* config/avr/avr-log.c (avr_double_int_pop_digit): Delete.\n\t(avr_dump_double_int_hex): Likewise.\n\t(avr_log_vadump): Remove %D and %X handling.\n\t* config/avr/avr.c (avr_double_int_push_digit): Delete.\n\t(avr_map_op_t): Change map from double_int to unsigned int.\n\t(avr_map_op): Update accordingly.\n\t(avr_map, avr_map_metric, avr_has_nibble_0xf, avr_map_decompose)\n\t(avr_move_bits, avr_out_insert_bits, avr_fold_builtin): Operate on\n\tunsigned ints rather than double_ints.\n\nFrom-SVN: r204345", "tree": {"sha": "f7c289cf58866a50061503f9f6cdc104dbc2db51", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f7c289cf58866a50061503f9f6cdc104dbc2db51"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7405bd18066d283bff49348d81c2985b134f5a79", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7405bd18066d283bff49348d81c2985b134f5a79", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7405bd18066d283bff49348d81c2985b134f5a79", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7405bd18066d283bff49348d81c2985b134f5a79/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "94159ecf929a26211ec28c455ea38063591deda7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94159ecf929a26211ec28c455ea38063591deda7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94159ecf929a26211ec28c455ea38063591deda7"}], "stats": {"total": 145, "additions": 47, "deletions": 98}, "files": [{"sha": "b02cf8af5aa87d7bd5ebc8e7cdaa228e24137898", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7405bd18066d283bff49348d81c2985b134f5a79/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7405bd18066d283bff49348d81c2985b134f5a79/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7405bd18066d283bff49348d81c2985b134f5a79", "patch": "@@ -1,3 +1,15 @@\n+2013-11-04  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* config/avr/avr-log.c (avr_double_int_pop_digit): Delete.\n+\t(avr_dump_double_int_hex): Likewise.\n+\t(avr_log_vadump): Remove %D and %X handling.\n+\t* config/avr/avr.c (avr_double_int_push_digit): Delete.\n+\t(avr_map_op_t): Change map from double_int to unsigned int.\n+\t(avr_map_op): Update accordingly.\n+\t(avr_map, avr_map_metric, avr_has_nibble_0xf, avr_map_decompose)\n+\t(avr_move_bits, avr_out_insert_bits, avr_fold_builtin): Operate on\n+\tunsigned ints rather than double_ints.\n+\n 2013-11-03  Marek Polacek  <polacek@redhat.com>\n \n \tImplement -fsanitize=vla-bound."}, {"sha": "87fa14d70064694d770c4785d6b77f7964324136", "filename": "gcc/config/avr/avr-log.c", "status": "modified", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7405bd18066d283bff49348d81c2985b134f5a79/gcc%2Fconfig%2Favr%2Favr-log.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7405bd18066d283bff49348d81c2985b134f5a79/gcc%2Fconfig%2Favr%2Favr-log.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-log.c?ref=7405bd18066d283bff49348d81c2985b134f5a79", "patch": "@@ -49,8 +49,6 @@\n   C: enum rtx_code\n   m: enum machine_mode\n   R: enum reg_class\n-  D: double_int (signed decimal)\n-  X: double_int (unsigned hex)\n   L: insn list\n   H: location_t\n \n@@ -138,45 +136,6 @@ avr_log_set_caller_f (const char *caller)\n }\n \n \n-/* Copy-paste from double-int.c:double_int_split_digit (it's static there).\n-   Splits last digit of *CST (taken as unsigned) in BASE and returns it.  */\n-\n-static unsigned\n-avr_double_int_pop_digit (double_int *cst, unsigned base)\n-{\n-  double_int drem;\n-\n-  *cst = cst->udivmod (double_int::from_uhwi (base), (int) FLOOR_DIV_EXPR,\n-                       &drem);\n-\n-  return (unsigned) drem.to_uhwi();\n-}\n-\n-\n-/* Dump VAL as hex value to FILE.  */\n-\n-static void\n-avr_dump_double_int_hex (FILE *file, double_int val)\n-{\n-  unsigned digit[4];\n-\n-  digit[0] = avr_double_int_pop_digit (&val, 1 << 16);\n-  digit[1] = avr_double_int_pop_digit (&val, 1 << 16);\n-  digit[2] = avr_double_int_pop_digit (&val, 1 << 16);\n-  digit[3] = avr_double_int_pop_digit (&val, 1 << 16);\n-\n-  fprintf (file, \"0x\");\n-\n-  if (digit[3] | digit[2])\n-    fprintf (file, \"%04x%04x\", digit[3], digit[2]);\n-\n-  if (digit[3] | digit[2] | digit[1] | digit[0])\n-    fprintf (file, \"%04x%04x\", digit[1], digit[0]);\n-  else\n-    fprintf (file, \"0\");\n-}\n-\n-\n /* Worker function implementing the %-codes and forwarding to\n    respective print/dump function.  */\n \n@@ -231,14 +190,6 @@ avr_log_vadump (FILE *file, const char *fmt, va_list ap)\n               fprintf (file, \"%d\", va_arg (ap, int));\n               break;\n \n-            case 'D':\n-              dump_double_int (file, va_arg (ap, double_int), false);\n-              break;\n-\n-            case 'X':\n-              avr_dump_double_int_hex (file, va_arg (ap, double_int));\n-              break;\n-\n             case 'x':\n               fprintf (file, \"%x\", va_arg (ap, int));\n               break;"}, {"sha": "e7e1c2f138bd1b57a23521027b62de18cf87a960", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 35, "deletions": 49, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7405bd18066d283bff49348d81c2985b134f5a79/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7405bd18066d283bff49348d81c2985b134f5a79/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=7405bd18066d283bff49348d81c2985b134f5a79", "patch": "@@ -11365,26 +11365,12 @@ avr_expand_delay_cycles (rtx operands0)\n }\n \n \n-/* Return VAL * BASE + DIGIT.  BASE = 0 is shortcut for BASE = 2^{32}   */\n-\n-static double_int\n-avr_double_int_push_digit (double_int val, int base,\n-                           unsigned HOST_WIDE_INT digit)\n-{\n-  val = 0 == base\n-    ? val.llshift (32, 64)\n-    : val * double_int::from_uhwi (base);\n-\n-  return val + double_int::from_uhwi (digit);\n-}\n-\n-\n /* Compute the image of x under f, i.e. perform   x --> f(x)    */\n \n static int\n-avr_map (double_int f, int x)\n+avr_map (unsigned int f, int x)\n {\n-  return 0xf & f.lrshift (4*x, 64).to_uhwi ();\n+  return x < 8 ? (f >> (4 * x)) & 0xf : 0;\n }\n \n \n@@ -11409,7 +11395,7 @@ enum\n   };\n \n static unsigned\n-avr_map_metric (double_int a, int mode)\n+avr_map_metric (unsigned int a, int mode)\n {\n   unsigned i, metric = 0;\n \n@@ -11442,7 +11428,8 @@ avr_map_metric (double_int a, int mode)\n bool\n avr_has_nibble_0xf (rtx ival)\n {\n-  return 0 != avr_map_metric (rtx_to_double_int (ival), MAP_MASK_PREIMAGE_F);\n+  unsigned int map = UINTVAL (ival) & GET_MODE_MASK (SImode);\n+  return 0 != avr_map_metric (map, MAP_MASK_PREIMAGE_F);\n }\n \n \n@@ -11476,29 +11463,29 @@ typedef struct\n   int cost;\n \n   /* The composition F o G^-1 (*, arg) for some function F */\n-  double_int map;\n+  unsigned int map;\n \n   /* For debug purpose only */\n   const char *str;\n } avr_map_op_t;\n \n static const avr_map_op_t avr_map_op[] =\n   {\n-    { LROTATE_EXPR, 0, 0x76543210, 0, { 0, 0 }, \"id\" },\n-    { LROTATE_EXPR, 1, 0x07654321, 2, { 0, 0 }, \"<<<\" },\n-    { LROTATE_EXPR, 2, 0x10765432, 4, { 0, 0 }, \"<<<\" },\n-    { LROTATE_EXPR, 3, 0x21076543, 4, { 0, 0 }, \"<<<\" },\n-    { LROTATE_EXPR, 4, 0x32107654, 1, { 0, 0 }, \"<<<\" },\n-    { LROTATE_EXPR, 5, 0x43210765, 3, { 0, 0 }, \"<<<\" },\n-    { LROTATE_EXPR, 6, 0x54321076, 5, { 0, 0 }, \"<<<\" },\n-    { LROTATE_EXPR, 7, 0x65432107, 3, { 0, 0 }, \"<<<\" },\n-    { RSHIFT_EXPR, 1, 0x6543210c, 1, { 0, 0 }, \">>\" },\n-    { RSHIFT_EXPR, 1, 0x7543210c, 1, { 0, 0 }, \">>\" },\n-    { RSHIFT_EXPR, 2, 0x543210cc, 2, { 0, 0 }, \">>\" },\n-    { RSHIFT_EXPR, 2, 0x643210cc, 2, { 0, 0 }, \">>\" },\n-    { RSHIFT_EXPR, 2, 0x743210cc, 2, { 0, 0 }, \">>\" },\n-    { LSHIFT_EXPR, 1, 0xc7654321, 1, { 0, 0 }, \"<<\" },\n-    { LSHIFT_EXPR, 2, 0xcc765432, 2, { 0, 0 }, \"<<\" }\n+    { LROTATE_EXPR, 0, 0x76543210, 0, 0, \"id\" },\n+    { LROTATE_EXPR, 1, 0x07654321, 2, 0, \"<<<\" },\n+    { LROTATE_EXPR, 2, 0x10765432, 4, 0, \"<<<\" },\n+    { LROTATE_EXPR, 3, 0x21076543, 4, 0, \"<<<\" },\n+    { LROTATE_EXPR, 4, 0x32107654, 1, 0, \"<<<\" },\n+    { LROTATE_EXPR, 5, 0x43210765, 3, 0, \"<<<\" },\n+    { LROTATE_EXPR, 6, 0x54321076, 5, 0, \"<<<\" },\n+    { LROTATE_EXPR, 7, 0x65432107, 3, 0, \"<<<\" },\n+    { RSHIFT_EXPR, 1, 0x6543210c, 1, 0, \">>\" },\n+    { RSHIFT_EXPR, 1, 0x7543210c, 1, 0, \">>\" },\n+    { RSHIFT_EXPR, 2, 0x543210cc, 2, 0, \">>\" },\n+    { RSHIFT_EXPR, 2, 0x643210cc, 2, 0, \">>\" },\n+    { RSHIFT_EXPR, 2, 0x743210cc, 2, 0, \">>\" },\n+    { LSHIFT_EXPR, 1, 0xc7654321, 1, 0, \"<<\" },\n+    { LSHIFT_EXPR, 2, 0xcc765432, 2, 0, \"<<\" }\n   };\n \n \n@@ -11507,12 +11494,12 @@ static const avr_map_op_t avr_map_op[] =\n    If result.cost < 0 then such a decomposition does not exist.  */\n \n static avr_map_op_t\n-avr_map_decompose (double_int f, const avr_map_op_t *g, bool val_const_p)\n+avr_map_decompose (unsigned int f, const avr_map_op_t *g, bool val_const_p)\n {\n   int i;\n   bool val_used_p = 0 != avr_map_metric (f, MAP_MASK_PREIMAGE_F);\n   avr_map_op_t f_ginv = *g;\n-  double_int ginv = double_int::from_uhwi (g->ginv);\n+  unsigned int ginv = g->ginv;\n \n   f_ginv.cost = -1;\n \n@@ -11532,7 +11519,7 @@ avr_map_decompose (double_int f, const avr_map_op_t *g, bool val_const_p)\n             return f_ginv;\n         }\n \n-      f_ginv.map = avr_double_int_push_digit (f_ginv.map, 16, x);\n+      f_ginv.map = (f_ginv.map << 4) + x;\n     }\n \n   /* Step 2:  Compute the cost of the operations.\n@@ -11557,7 +11544,7 @@ avr_map_decompose (double_int f, const avr_map_op_t *g, bool val_const_p)\n          are mapped to 0 and used operands are reloaded to xop[0].  */\n \n       xop[0] = all_regs_rtx[24];\n-      xop[1] = gen_int_mode (f_ginv.map.to_uhwi (), SImode);\n+      xop[1] = gen_int_mode (f_ginv.map, SImode);\n       xop[2] = all_regs_rtx[25];\n       xop[3] = val_used_p ? xop[0] : const0_rtx;\n \n@@ -11584,7 +11571,7 @@ avr_map_decompose (double_int f, const avr_map_op_t *g, bool val_const_p)\n    is different to its source position.  */\n \n static void\n-avr_move_bits (rtx *xop, double_int map, bool fixp_p, int *plen)\n+avr_move_bits (rtx *xop, unsigned int map, bool fixp_p, int *plen)\n {\n   int bit_dest, b;\n \n@@ -11637,7 +11624,7 @@ avr_move_bits (rtx *xop, double_int map, bool fixp_p, int *plen)\n const char*\n avr_out_insert_bits (rtx *op, int *plen)\n {\n-  double_int map = rtx_to_double_int (op[1]);\n+  unsigned int map = UINTVAL (op[1]) & GET_MODE_MASK (SImode);\n   unsigned mask_fixed;\n   bool fixp_p = true;\n   rtx xop[4];\n@@ -11651,9 +11638,7 @@ avr_out_insert_bits (rtx *op, int *plen)\n   if (plen)\n     *plen = 0;\n   else if (flag_print_asm_name)\n-    fprintf (asm_out_file,\n-             ASM_COMMENT_START \"map = 0x%08\" HOST_LONG_FORMAT \"x\\n\",\n-             map.to_uhwi () & GET_MODE_MASK (SImode));\n+    fprintf (asm_out_file, ASM_COMMENT_START \"map = 0x%08x\\n\", map);\n \n   /* If MAP has fixed points it might be better to initialize the result\n      with the bits to be inserted instead of moving all bits by hand.  */\n@@ -12228,7 +12213,7 @@ avr_fold_builtin (tree fndecl, int n_args ATTRIBUTE_UNUSED, tree *arg,\n         tree tval = arg[2];\n         tree tmap;\n         tree map_type = TREE_VALUE (TYPE_ARG_TYPES (TREE_TYPE (fndecl)));\n-        double_int map;\n+        unsigned int map;\n         bool changed = false;\n         unsigned i;\n         avr_map_op_t best_g;\n@@ -12241,8 +12226,8 @@ avr_fold_builtin (tree fndecl, int n_args ATTRIBUTE_UNUSED, tree *arg,\n             break;\n           }\n \n-        map = tree_to_double_int (arg[0]);\n-        tmap = double_int_to_tree (map_type, map);\n+        tmap = double_int_to_tree (map_type, tree_to_double_int (arg[0]));\n+        map = TREE_INT_CST_LOW (tmap);\n \n         if (TREE_CODE (tval) != INTEGER_CST\n             && 0 == avr_map_metric (map, MAP_MASK_PREIMAGE_F))\n@@ -12308,7 +12293,7 @@ avr_fold_builtin (tree fndecl, int n_args ATTRIBUTE_UNUSED, tree *arg,\n         /* Try to decomposing map to reduce overall cost.  */\n \n         if (avr_log.builtin)\n-          avr_edump (\"\\n%?: %X\\n%?: ROL cost: \", map);\n+          avr_edump (\"\\n%?: %x\\n%?: ROL cost: \", map);\n \n         best_g = avr_map_op[0];\n         best_g.cost = 1000;\n@@ -12333,7 +12318,7 @@ avr_fold_builtin (tree fndecl, int n_args ATTRIBUTE_UNUSED, tree *arg,\n         /* Apply operation G to the 2nd argument.  */\n \n         if (avr_log.builtin)\n-          avr_edump (\"%?: using OP(%s%d, %X) cost %d\\n\",\n+          avr_edump (\"%?: using OP(%s%d, %x) cost %d\\n\",\n                      best_g.str, best_g.arg, best_g.map, best_g.cost);\n \n         /* Do right-shifts arithmetically: They copy the MSB instead of\n@@ -12346,7 +12331,8 @@ avr_fold_builtin (tree fndecl, int n_args ATTRIBUTE_UNUSED, tree *arg,\n \n         /* Use map o G^-1 instead of original map to undo the effect of G.  */\n \n-        tmap = double_int_to_tree (map_type, best_g.map);\n+        tmap = double_int_to_tree (map_type,\n+\t\t\t\t   double_int::from_uhwi (best_g.map));\n \n         return build_call_expr (fndecl, 3, tmap, tbits, tval);\n       } /* AVR_BUILTIN_INSERT_BITS */"}]}