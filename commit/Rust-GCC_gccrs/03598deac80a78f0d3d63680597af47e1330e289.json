{"sha": "03598deac80a78f0d3d63680597af47e1330e289", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDM1OThkZWFjODBhNzhmMGQzZDYzNjgwNTk3YWY0N2UxMzMwZTI4OQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-07-15T12:00:34Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-07-15T12:00:34Z"}, "message": "loop.c (scan_loop): Add USEs inside PARALLELs into dependencies of the movable.\n\n\t* loop.c (scan_loop): Add USEs inside PARALLELs into dependencies\n\tof the movable.\n\n\t* toplev.c (rest_of_compilation): Allow new pseudoes for mode switching.\n\n\t* i386-protos.h (ix86_split_fp_branch): Update prototype.\n\t(ix86_fp_jump_nontrivial_p): New.\n\t* i386.md (fp_jcc_?): Update call of split_fp_branch;\n\tuse ix86_fp_jump_nontrivial_p.\n\t* i386.c (ix86_fp_jump_nontrivial_p): New.\n\t(ix86_split_fp_branch): Accept code instead of rtx.\n\t(ix86_expand_compare): Expand comparison early in case\n\tdoing so is resonably cheap.\n\nFrom-SVN: r44019", "tree": {"sha": "e55abbf2e8b497f46eb899b1f0badf21e318f2ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e55abbf2e8b497f46eb899b1f0badf21e318f2ac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/03598deac80a78f0d3d63680597af47e1330e289", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03598deac80a78f0d3d63680597af47e1330e289", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03598deac80a78f0d3d63680597af47e1330e289", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03598deac80a78f0d3d63680597af47e1330e289/comments", "author": null, "committer": null, "parents": [{"sha": "b8313db6c07dc5aaa023792a47dad7e990f07aa5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8313db6c07dc5aaa023792a47dad7e990f07aa5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8313db6c07dc5aaa023792a47dad7e990f07aa5"}], "stats": {"total": 145, "additions": 107, "deletions": 38}, "files": [{"sha": "9fdfc69d8f6b771a22d1f203f5c2afba07b9ba12", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03598deac80a78f0d3d63680597af47e1330e289/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03598deac80a78f0d3d63680597af47e1330e289/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=03598deac80a78f0d3d63680597af47e1330e289", "patch": "@@ -1,3 +1,19 @@\n+Sun Jul 15 00:53:35 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* loop.c (scan_loop): Add USEs inside PARALLELs into dependencies\n+\tof the movable.\n+\n+\t* toplev.c (rest_of_compilation): Allow new pseudoes for mode switching.\n+\n+\t* i386-protos.h (ix86_split_fp_branch): Update prototype.\n+\t(ix86_fp_jump_nontrivial_p): New.\n+\t* i386.md (fp_jcc_?): Update call of split_fp_branch;\n+\tuse ix86_fp_jump_nontrivial_p.\n+\t* i386.c (ix86_fp_jump_nontrivial_p): New.\n+\t(ix86_split_fp_branch): Accept code instead of rtx.\n+\t(ix86_expand_compare): Expand comparison early in case\n+\tdoing so is resonably cheap.\n+\n 2001-07-15  Nick Clifton  <nickc@cambridge.redhat.com>\n \n \t* config/rs6000/sysv4.h (CPP_ENDIAN_BIG_SPEC): Assert 'endian'"}, {"sha": "e204834dd21a4ca7bb2d740014131032ac0c69c6", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03598deac80a78f0d3d63680597af47e1330e289/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03598deac80a78f0d3d63680597af47e1330e289/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=03598deac80a78f0d3d63680597af47e1330e289", "patch": "@@ -142,7 +142,8 @@ extern int x86_64_zero_extended_value PARAMS ((rtx));\n \n extern rtx ix86_force_to_memory PARAMS ((enum machine_mode, rtx));\n extern void ix86_free_from_memory PARAMS ((enum machine_mode));\n-extern void ix86_split_fp_branch PARAMS ((rtx, rtx, rtx, rtx, rtx, rtx));\n+extern void ix86_split_fp_branch PARAMS ((enum rtx_code code, rtx,\n+\t\t\t\t\t  rtx, rtx, rtx, rtx));\n extern int ix86_hard_regno_mode_ok PARAMS ((int, enum machine_mode));\n extern int ix86_register_move_cost PARAMS ((enum machine_mode, enum reg_class,\n \t\t\t\t\t    enum reg_class));\n@@ -155,6 +156,7 @@ extern int ix86_memory_move_cost PARAMS ((enum machine_mode, enum reg_class,\n \t\t\t\t\t  int));\n extern void ix86_set_move_mem_attrs PARAMS ((rtx, rtx, rtx, rtx, rtx));\n extern void emit_i387_cw_initialization PARAMS ((rtx, rtx));\n+extern bool ix86_fp_jump_nontrivial_p PARAMS ((enum rtx_code));\n \n \n #ifdef TREE_CODE"}, {"sha": "dcafe019ba7e50f51b6e5000ce93aa8f07a85353", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 52, "deletions": 25, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03598deac80a78f0d3d63680597af47e1330e289/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03598deac80a78f0d3d63680597af47e1330e289/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=03598deac80a78f0d3d63680597af47e1330e289", "patch": "@@ -6060,6 +6060,18 @@ ix86_expand_compare (code, second_test, bypass_test)\n   return ret;\n }\n \n+/* Return true if the CODE will result in nontrivial jump sequence.  */\n+bool\n+ix86_fp_jump_nontrivial_p (code)\n+    enum rtx_code code;\n+{\n+  enum rtx_code bypass_code, first_code, second_code;\n+  if (!TARGET_CMOVE)\n+    return true;\n+  ix86_fp_comparison_codes (code, &bypass_code, &first_code, &second_code);\n+  return bypass_code != NIL || second_code != NIL;\n+}\n+\n void\n ix86_expand_branch (code, label)\n      enum rtx_code code;\n@@ -6084,34 +6096,48 @@ ix86_expand_branch (code, label)\n     case DFmode:\n     case XFmode:\n     case TFmode:\n-      /* Don't expand the comparison early, so that we get better code\n-\t when jump or whoever decides to reverse the comparison.  */\n       {\n \trtvec vec;\n \tint use_fcomi;\n+\tenum rtx_code bypass_code, first_code, second_code;\n \n \tcode = ix86_prepare_fp_compare_args (code, &ix86_compare_op0,\n \t\t\t\t\t     &ix86_compare_op1);\n-\n-\ttmp = gen_rtx_fmt_ee (code, VOIDmode,\n-\t\t\t      ix86_compare_op0, ix86_compare_op1);\n-\ttmp = gen_rtx_IF_THEN_ELSE (VOIDmode, tmp,\n-\t\t\t\t    gen_rtx_LABEL_REF (VOIDmode, label),\n-\t\t\t\t    pc_rtx);\n-\ttmp = gen_rtx_SET (VOIDmode, pc_rtx, tmp);\n-\n-\tuse_fcomi = ix86_use_fcomi_compare (code);\n-\tvec = rtvec_alloc (3 + !use_fcomi);\n-\tRTVEC_ELT (vec, 0) = tmp;\n-\tRTVEC_ELT (vec, 1)\n-\t  = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (CCFPmode, 18));\n-\tRTVEC_ELT (vec, 2)\n-\t  = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (CCFPmode, 17));\n-\tif (! use_fcomi)\n-\t  RTVEC_ELT (vec, 3)\n-\t    = gen_rtx_CLOBBER (VOIDmode, gen_rtx_SCRATCH (HImode));\n-\n-        emit_jump_insn (gen_rtx_PARALLEL (VOIDmode, vec));\n+\t\n+\tix86_fp_comparison_codes (code, &bypass_code, &first_code, &second_code);\n+\n+\t/* Check whether we will use the natural sequence with one jump.  If\n+\t   so, we can expand jump early.  Otherwise delay expansion by\n+\t   creating compound insn to not confuse optimizers.  */\n+\tif (bypass_code == NIL && second_code == NIL\n+\t    && TARGET_CMOVE)\n+\t  {\n+\t    ix86_split_fp_branch (code, ix86_compare_op0, ix86_compare_op1,\n+\t\t\t\t  gen_rtx_LABEL_REF (VOIDmode, label),\n+\t\t\t\t  pc_rtx, NULL_RTX);\n+\t  }\n+\telse\n+\t  {\n+\t    tmp = gen_rtx_fmt_ee (code, VOIDmode,\n+\t\t\t\t  ix86_compare_op0, ix86_compare_op1);\n+\t    tmp = gen_rtx_IF_THEN_ELSE (VOIDmode, tmp,\n+\t\t\t\t\tgen_rtx_LABEL_REF (VOIDmode, label),\n+\t\t\t\t\tpc_rtx);\n+\t    tmp = gen_rtx_SET (VOIDmode, pc_rtx, tmp);\n+\n+\t    use_fcomi = ix86_use_fcomi_compare (code);\n+\t    vec = rtvec_alloc (3 + !use_fcomi);\n+\t    RTVEC_ELT (vec, 0) = tmp;\n+\t    RTVEC_ELT (vec, 1)\n+\t      = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (CCFPmode, 18));\n+\t    RTVEC_ELT (vec, 2)\n+\t      = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (CCFPmode, 17));\n+\t    if (! use_fcomi)\n+\t      RTVEC_ELT (vec, 3)\n+\t\t= gen_rtx_CLOBBER (VOIDmode, gen_rtx_SCRATCH (HImode));\n+\n+\t    emit_jump_insn (gen_rtx_PARALLEL (VOIDmode, vec));\n+\t  }\n \treturn;\n       }\n \n@@ -6235,12 +6261,13 @@ ix86_expand_branch (code, label)\n \n /* Split branch based on floating point condition.  */\n void\n-ix86_split_fp_branch (condition, op1, op2, target1, target2, tmp)\n-     rtx condition, op1, op2, target1, target2, tmp;\n+ix86_split_fp_branch (code, op1, op2, target1, target2, tmp)\n+     enum rtx_code code;\n+     rtx op1, op2, target1, target2, tmp;\n {\n   rtx second, bypass;\n   rtx label = NULL_RTX;\n-  enum rtx_code code = GET_CODE (condition);\n+  rtx condition;\n \n   if (target2 != pc_rtx)\n     {"}, {"sha": "baff6bc7745314491253fd89adc77f75271dd677", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03598deac80a78f0d3d63680597af47e1330e289/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03598deac80a78f0d3d63680597af47e1330e289/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=03598deac80a78f0d3d63680597af47e1330e289", "patch": "@@ -12686,7 +12686,8 @@\n   \"TARGET_CMOVE && TARGET_80387\n    && !SSE_FLOAT_MODE_P (GET_MODE (operands[1]))\n    && FLOAT_MODE_P (GET_MODE (operands[1]))\n-   && GET_MODE (operands[1]) == GET_MODE (operands[2])\"\n+   && GET_MODE (operands[1]) == GET_MODE (operands[2])\n+   && ix86_fp_jump_nontrivial_p (GET_CODE (operands[0]))\"\n   \"#\")\n \n (define_insn \"*fp_jcc_1_sse\"\n@@ -12700,7 +12701,8 @@\n    (clobber (reg:CCFP 17))]\n   \"TARGET_80387\n    && SSE_FLOAT_MODE_P (GET_MODE (operands[1]))\n-   && GET_MODE (operands[1]) == GET_MODE (operands[2])\"\n+   && GET_MODE (operands[1]) == GET_MODE (operands[2])\n+   && ix86_fp_jump_nontrivial_p (GET_CODE (operands[0]))\"\n   \"#\")\n \n (define_insn \"*fp_jcc_1_sse_only\"\n@@ -12713,7 +12715,8 @@\n    (clobber (reg:CCFP 18))\n    (clobber (reg:CCFP 17))]\n   \"SSE_FLOAT_MODE_P (GET_MODE (operands[1]))\n-   && GET_MODE (operands[1]) == GET_MODE (operands[2])\"\n+   && GET_MODE (operands[1]) == GET_MODE (operands[2])\n+   && ix86_fp_jump_nontrivial_p (GET_CODE (operands[0]))\"\n   \"#\")\n \n (define_insn \"*fp_jcc_2\"\n@@ -12728,7 +12731,8 @@\n   \"TARGET_CMOVE && TARGET_80387\n    && !SSE_FLOAT_MODE_P (GET_MODE (operands[1]))\n    && FLOAT_MODE_P (GET_MODE (operands[1]))\n-   && GET_MODE (operands[1]) == GET_MODE (operands[2])\"\n+   && GET_MODE (operands[1]) == GET_MODE (operands[2])\n+   && ix86_fp_jump_nontrivial_p (GET_CODE (operands[0]))\"\n   \"#\")\n \n (define_insn \"*fp_jcc_2_sse\"\n@@ -12742,7 +12746,8 @@\n    (clobber (reg:CCFP 17))]\n   \"TARGET_80387\n    && SSE_FLOAT_MODE_P (GET_MODE (operands[1]))\n-   && GET_MODE (operands[1]) == GET_MODE (operands[2])\"\n+   && GET_MODE (operands[1]) == GET_MODE (operands[2])\n+   && ix86_fp_jump_nontrivial_p (GET_CODE (operands[0]))\"\n   \"#\")\n \n (define_insn \"*fp_jcc_2_sse_only\"\n@@ -12755,7 +12760,8 @@\n    (clobber (reg:CCFP 18))\n    (clobber (reg:CCFP 17))]\n   \"SSE_FLOAT_MODE_P (GET_MODE (operands[1]))\n-   && GET_MODE (operands[1]) == GET_MODE (operands[2])\"\n+   && GET_MODE (operands[1]) == GET_MODE (operands[2])\n+   && ix86_fp_jump_nontrivial_p (GET_CODE (operands[0]))\"\n   \"#\")\n \n (define_insn \"*fp_jcc_3\"\n@@ -12773,7 +12779,8 @@\n    && GET_MODE (operands[1]) == GET_MODE (operands[2])\n    && !ix86_use_fcomi_compare (GET_CODE (operands[0]))\n    && SELECT_CC_MODE (GET_CODE (operands[0]),\n-\t\t      operands[1], operands[2]) == CCFPmode\"\n+\t\t      operands[1], operands[2]) == CCFPmode\n+   && ix86_fp_jump_nontrivial_p (GET_CODE (operands[0]))\"\n   \"#\")\n \n (define_insn \"*fp_jcc_4\"\n@@ -12791,7 +12798,8 @@\n    && GET_MODE (operands[1]) == GET_MODE (operands[2])\n    && !ix86_use_fcomi_compare (GET_CODE (operands[0]))\n    && SELECT_CC_MODE (GET_CODE (operands[0]),\n-\t\t      operands[1], operands[2]) == CCFPmode\"\n+\t\t      operands[1], operands[2]) == CCFPmode\n+   && ix86_fp_jump_nontrivial_p (GET_CODE (operands[0]))\"\n   \"#\")\n \n (define_insn \"*fp_jcc_5\"\n@@ -12806,7 +12814,8 @@\n    (clobber (match_scratch:HI 4 \"=a\"))]\n   \"TARGET_80387\n    && FLOAT_MODE_P (GET_MODE (operands[1]))\n-   && GET_MODE (operands[1]) == GET_MODE (operands[2])\"\n+   && GET_MODE (operands[1]) == GET_MODE (operands[2])\n+   && ix86_fp_jump_nontrivial_p (GET_CODE (operands[0]))\"\n   \"#\")\n \n (define_insn \"*fp_jcc_6\"\n@@ -12821,7 +12830,8 @@\n    (clobber (match_scratch:HI 4 \"=a\"))]\n   \"TARGET_80387\n    && FLOAT_MODE_P (GET_MODE (operands[1]))\n-   && GET_MODE (operands[1]) == GET_MODE (operands[2])\"\n+   && GET_MODE (operands[1]) == GET_MODE (operands[2])\n+   && ix86_fp_jump_nontrivial_p (GET_CODE (operands[0]))\"\n   \"#\")\n \n (define_split\n@@ -12836,7 +12846,7 @@\n   \"reload_completed\"\n   [(const_int 0)]\n {\n-  ix86_split_fp_branch (operands[0], operands[1], operands[2],\n+  ix86_split_fp_branch (GET_CODE (operands[0]), operands[1], operands[2],\n \t\t\toperands[3], operands[4], NULL_RTX);\n   DONE;\n })\n@@ -12857,7 +12867,7 @@\n \t  (match_dup 3)\n \t  (match_dup 4)))]\n {\n-  ix86_split_fp_branch (operands[0], operands[1], operands[2],\n+  ix86_split_fp_branch (GET_CODE (operands[0]), operands[1], operands[2],\n \t\t\toperands[3], operands[4], operands[5]);\n   DONE;\n })"}, {"sha": "db1ec9df7a35ba273e538a01da150e2168d724ab", "filename": "gcc/loop.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03598deac80a78f0d3d63680597af47e1330e289/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03598deac80a78f0d3d63680597af47e1330e289/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=03598deac80a78f0d3d63680597af47e1330e289", "patch": "@@ -705,6 +705,18 @@ scan_loop (loop, flags)\n \t\t}\n \t    }\n \n+\t  /* For parallels, add any possible uses to the depencies, as we can't move\n+\t     the insn without resolving them first.  */\n+\t  if (GET_CODE (PATTERN (p)) == PARALLEL)\n+\t    {\n+\t      for (i = 0; i < XVECLEN (PATTERN (p), 0); i++)\n+\t\t{\n+\t\t  rtx x = XVECEXP (PATTERN (p), 0, i);\n+\t\t  if (GET_CODE (x) == USE)\n+\t\t    dependencies = gen_rtx_EXPR_LIST (VOIDmode, XEXP (x, 0), dependencies);\n+\t\t}\n+\t    }\n+\n \t  /* Don't try to optimize a register that was made\n \t     by loop-optimization for an inner loop.\n \t     We don't know its life-span, so we can't compute the benefit.  */"}, {"sha": "416187275b38d999e89cad2fd3f5971e5a7540da", "filename": "gcc/toplev.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03598deac80a78f0d3d63680597af47e1330e289/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03598deac80a78f0d3d63680597af47e1330e289/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=03598deac80a78f0d3d63680597af47e1330e289", "patch": "@@ -3422,13 +3422,15 @@ rest_of_compilation (decl)\n #ifdef OPTIMIZE_MODE_SWITCHING\n   timevar_push (TV_GCSE);\n \n+  no_new_pseudos = 1;\n   if (optimize_mode_switching (NULL))\n     {\n       /* We did work, and so had to regenerate global life information.\n \t Take advantage of this and don't re-recompute register life\n \t information below.  */\n       register_life_up_to_date = 1;\n     }\n+  no_new_pseudos = 0;\n \n   timevar_pop (TV_GCSE);\n #endif"}]}