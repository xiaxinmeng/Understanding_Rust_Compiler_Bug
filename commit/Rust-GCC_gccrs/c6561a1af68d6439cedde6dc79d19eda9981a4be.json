{"sha": "c6561a1af68d6439cedde6dc79d19eda9981a4be", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzY1NjFhMWFmNjhkNjQzOWNlZGRlNmRjNzlkMTllZGE5OTgxYTRiZQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-03T21:43:28Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-03T21:43:28Z"}, "message": "Add support for adjusting the number of units in a mode\n\nWe already allow the target to change the size and alignment of a mode.\nThis patch does the same thing for the number of units, which is needed\nto give command-line control of the SVE vector length.\n\n2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* machmode.h (mode_precision): Prefix with CONST_MODE_PRECISION.\n\t(mode_nunits): Likewise CONST_MODE_NUNITS.\n\t* machmode.def (ADJUST_NUNITS): Document.\n\t* genmodes.c (mode_data::need_nunits_adj): New field.\n\t(blank_mode): Update accordingly.\n\t(adj_nunits): New variable.\n\t(print_maybe_const_decl): Replace CATEGORY with a NEEDS_ADJ\n\tparameter.\n\t(emit_mode_size_inline): Set need_bytesize_adj for all modes\n\tlisted in adj_nunits.\n\t(emit_mode_nunits_inline): Set need_nunits_adj for all modes\n\tlisted in adj_nunits.  Don't emit case statements for such modes.\n\t(emit_insn_modes_h): Emit definitions of CONST_MODE_NUNITS\n\tand CONST_MODE_PRECISION.  Make CONST_MODE_SIZE expand to\n\tnothing if adj_nunits is nonnull.\n\t(emit_mode_precision, emit_mode_nunits): Use print_maybe_const_decl.\n\t(emit_mode_unit_size, emit_mode_base_align, emit_mode_ibit)\n\t(emit_mode_fbit): Update use of print_maybe_const_decl.\n\t(emit_move_size): Likewise.  Treat the array as non-const\n\tif adj_nunits.\n\t(emit_mode_adjustments): Handle adj_nunits.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r256204", "tree": {"sha": "e7c537aa897178d8d89fe0a7d45e08bfb47cce28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e7c537aa897178d8d89fe0a7d45e08bfb47cce28"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c6561a1af68d6439cedde6dc79d19eda9981a4be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6561a1af68d6439cedde6dc79d19eda9981a4be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6561a1af68d6439cedde6dc79d19eda9981a4be", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6561a1af68d6439cedde6dc79d19eda9981a4be/comments", "author": null, "committer": null, "parents": [{"sha": "6ce12f6a1647ec2831f3c5908ecf9c23ae191d02", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ce12f6a1647ec2831f3c5908ecf9c23ae191d02", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ce12f6a1647ec2831f3c5908ecf9c23ae191d02"}], "stats": {"total": 105, "additions": 86, "deletions": 19}, "files": [{"sha": "dd5d70306f02ef8df8416151ffddff95681376b5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6561a1af68d6439cedde6dc79d19eda9981a4be/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6561a1af68d6439cedde6dc79d19eda9981a4be/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c6561a1af68d6439cedde6dc79d19eda9981a4be", "patch": "@@ -1,3 +1,29 @@\n+2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* machmode.h (mode_precision): Prefix with CONST_MODE_PRECISION.\n+\t(mode_nunits): Likewise CONST_MODE_NUNITS.\n+\t* machmode.def (ADJUST_NUNITS): Document.\n+\t* genmodes.c (mode_data::need_nunits_adj): New field.\n+\t(blank_mode): Update accordingly.\n+\t(adj_nunits): New variable.\n+\t(print_maybe_const_decl): Replace CATEGORY with a NEEDS_ADJ\n+\tparameter.\n+\t(emit_mode_size_inline): Set need_bytesize_adj for all modes\n+\tlisted in adj_nunits.\n+\t(emit_mode_nunits_inline): Set need_nunits_adj for all modes\n+\tlisted in adj_nunits.  Don't emit case statements for such modes.\n+\t(emit_insn_modes_h): Emit definitions of CONST_MODE_NUNITS\n+\tand CONST_MODE_PRECISION.  Make CONST_MODE_SIZE expand to\n+\tnothing if adj_nunits is nonnull.\n+\t(emit_mode_precision, emit_mode_nunits): Use print_maybe_const_decl.\n+\t(emit_mode_unit_size, emit_mode_base_align, emit_mode_ibit)\n+\t(emit_mode_fbit): Update use of print_maybe_const_decl.\n+\t(emit_move_size): Likewise.  Treat the array as non-const\n+\tif adj_nunits.\n+\t(emit_mode_adjustments): Handle adj_nunits.\n+\n 2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* machmode.def (VECTOR_MODES_WITH_PREFIX): Document."}, {"sha": "c0964345a939823bfe15cb32bd85191685bc2a8b", "filename": "gcc/genmodes.c", "status": "modified", "additions": 52, "deletions": 17, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6561a1af68d6439cedde6dc79d19eda9981a4be/gcc%2Fgenmodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6561a1af68d6439cedde6dc79d19eda9981a4be/gcc%2Fgenmodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmodes.c?ref=c6561a1af68d6439cedde6dc79d19eda9981a4be", "patch": "@@ -72,7 +72,9 @@ struct mode_data\n   unsigned int counter;\t\t/* Rank ordering of modes */\n   unsigned int ibit;\t\t/* the number of integral bits */\n   unsigned int fbit;\t\t/* the number of fractional bits */\n-  bool need_bytesize_adj;\t/* true if this mode need dynamic size\n+  bool need_nunits_adj;\t\t/* true if this mode needs dynamic nunits\n+\t\t\t\t   adjustment */\n+  bool need_bytesize_adj;\t/* true if this mode needs dynamic size\n \t\t\t\t   adjustment */\n   unsigned int int_n;\t\t/* If nonzero, then __int<INT_N> will be defined */\n };\n@@ -85,7 +87,7 @@ static const struct mode_data blank_mode = {\n   0, \"<unknown>\", MAX_MODE_CLASS,\n   -1U, -1U, -1U, -1U,\n   0, 0, 0, 0, 0, 0,\n-  \"<unknown>\", 0, 0, 0, 0, false, 0\n+  \"<unknown>\", 0, 0, 0, 0, false, false, 0\n };\n \n static htab_t modes_by_name;\n@@ -103,6 +105,7 @@ struct mode_adjust\n   unsigned int line;\n };\n \n+static struct mode_adjust *adj_nunits;\n static struct mode_adjust *adj_bytesize;\n static struct mode_adjust *adj_alignment;\n static struct mode_adjust *adj_format;\n@@ -780,6 +783,7 @@ make_vector_mode (enum mode_class bclass,\n #define _ADD_ADJUST(A, M, X, C1, C2) \\\n   new_adjust (#M, &adj_##A, #A, #X, MODE_##C1, MODE_##C2, __FILE__, __LINE__)\n \n+#define ADJUST_NUNITS(M, X)    _ADD_ADJUST (nunits, M, X, RANDOM, RANDOM)\n #define ADJUST_BYTESIZE(M, X)  _ADD_ADJUST (bytesize, M, X, RANDOM, RANDOM)\n #define ADJUST_ALIGNMENT(M, X) _ADD_ADJUST (alignment, M, X, RANDOM, RANDOM)\n #define ADJUST_FLOAT_FORMAT(M, X)    _ADD_ADJUST (format, M, X, FLOAT, FLOAT)\n@@ -949,9 +953,9 @@ calc_wider_mode (void)\n #define print_decl(TYPE, NAME, ASIZE) \\\n   puts (\"\\nconst \" TYPE \" \" NAME \"[\" ASIZE \"] =\\n{\");\n \n-#define print_maybe_const_decl(TYPE, NAME, ASIZE, CATEGORY)\t\\\n+#define print_maybe_const_decl(TYPE, NAME, ASIZE, NEEDS_ADJ)\t\\\n   printf (\"\\n\" TYPE \" \" NAME \"[\" ASIZE \"] = \\n{\\n\",\t\t\\\n-\t  adj_##CATEGORY ? \"\" : \"const \")\n+\t  NEEDS_ADJ ? \"\" : \"const \")\n \n #define print_closer() puts (\"};\")\n \n@@ -1009,6 +1013,11 @@ emit_mode_size_inline (void)\n \tm->need_bytesize_adj = true;\n     }\n \n+  /* Changing the number of units by a factor of X also changes the size\n+     by a factor of X.  */\n+  for (mode_adjust *a = adj_nunits; a; a = a->next)\n+    a->mode->need_bytesize_adj = true;\n+\n   printf (\"\\\n #ifdef __cplusplus\\n\\\n inline __attribute__((__always_inline__))\\n\\\n@@ -1021,7 +1030,7 @@ mode_size_inline (machine_mode mode)\\n\\\n   extern %spoly_uint16_pod mode_size[NUM_MACHINE_MODES];\\n\\\n   gcc_assert (mode >= 0 && mode < NUM_MACHINE_MODES);\\n\\\n   switch (mode)\\n\\\n-    {\\n\", adj_bytesize ? \"\" : \"const \");\n+    {\\n\", adj_nunits || adj_bytesize ? \"\" : \"const \");\n \n   for_all_modes (c, m)\n     if (!m->need_bytesize_adj)\n@@ -1040,7 +1049,10 @@ emit_mode_nunits_inline (void)\n   int c;\n   struct mode_data *m;\n \n-  puts (\"\\\n+  for (mode_adjust *a = adj_nunits; a; a = a->next)\n+    a->mode->need_nunits_adj = true;\n+\n+  printf (\"\\\n #ifdef __cplusplus\\n\\\n inline __attribute__((__always_inline__))\\n\\\n #else\\n\\\n@@ -1049,12 +1061,13 @@ extern __inline__ __attribute__((__always_inline__, __gnu_inline__))\\n\\\n poly_uint16\\n\\\n mode_nunits_inline (machine_mode mode)\\n\\\n {\\n\\\n-  extern poly_uint16_pod mode_nunits[NUM_MACHINE_MODES];\\n\\\n+  extern %spoly_uint16_pod mode_nunits[NUM_MACHINE_MODES];\\n\\\n   switch (mode)\\n\\\n-    {\");\n+    {\\n\", adj_nunits ? \"\" : \"const \");\n \n   for_all_modes (c, m)\n-    printf (\"    case E_%smode: return %u;\\n\", m->name, m->ncomponents);\n+    if (!m->need_nunits_adj)\n+      printf (\"    case E_%smode: return %u;\\n\", m->name, m->ncomponents);\n \n   puts (\"\\\n     default: return mode_nunits[mode];\\n\\\n@@ -1271,7 +1284,10 @@ enum machine_mode\\n{\");\n };\\n\");\n \n   /* I can't think of a better idea, can you?  */\n-  printf (\"#define CONST_MODE_SIZE%s\\n\", adj_bytesize ? \"\" : \" const\");\n+  printf (\"#define CONST_MODE_NUNITS%s\\n\", adj_nunits ? \"\" : \" const\");\n+  printf (\"#define CONST_MODE_PRECISION%s\\n\", adj_nunits ? \"\" : \" const\");\n+  printf (\"#define CONST_MODE_SIZE%s\\n\",\n+\t  adj_bytesize || adj_nunits ? \"\" : \" const\");\n   printf (\"#define CONST_MODE_UNIT_SIZE%s\\n\", adj_bytesize ? \"\" : \" const\");\n   printf (\"#define CONST_MODE_BASE_ALIGN%s\\n\", adj_alignment ? \"\" : \" const\");\n #if 0 /* disabled for backward compatibility, temporary */\n@@ -1386,7 +1402,8 @@ emit_mode_precision (void)\n   int c;\n   struct mode_data *m;\n \n-  print_decl (\"poly_uint16_pod\", \"mode_precision\", \"NUM_MACHINE_MODES\");\n+  print_maybe_const_decl (\"%spoly_uint16_pod\", \"mode_precision\",\n+\t\t\t  \"NUM_MACHINE_MODES\", adj_nunits);\n \n   for_all_modes (c, m)\n     if (m->precision != (unsigned int)-1)\n@@ -1405,7 +1422,7 @@ emit_mode_size (void)\n   struct mode_data *m;\n \n   print_maybe_const_decl (\"%spoly_uint16_pod\", \"mode_size\",\n-\t\t\t  \"NUM_MACHINE_MODES\", bytesize);\n+\t\t\t  \"NUM_MACHINE_MODES\", adj_nunits || adj_bytesize);\n \n   for_all_modes (c, m)\n     tagged_printf (\"{ %u\" ZERO_COEFFS \" }\", m->bytesize, m->name);\n@@ -1419,7 +1436,8 @@ emit_mode_nunits (void)\n   int c;\n   struct mode_data *m;\n \n-  print_decl (\"poly_uint16_pod\", \"mode_nunits\", \"NUM_MACHINE_MODES\");\n+  print_maybe_const_decl (\"%spoly_uint16_pod\", \"mode_nunits\",\n+\t\t\t  \"NUM_MACHINE_MODES\", adj_nunits);\n \n   for_all_modes (c, m)\n     tagged_printf (\"{ %u\" ZERO_COEFFS \" }\", m->ncomponents, m->name);\n@@ -1557,7 +1575,7 @@ emit_mode_unit_size (void)\n   struct mode_data *m;\n \n   print_maybe_const_decl (\"%sunsigned char\", \"mode_unit_size\",\n-\t\t\t  \"NUM_MACHINE_MODES\", bytesize);\n+\t\t\t  \"NUM_MACHINE_MODES\", adj_bytesize);\n \n   for_all_modes (c, m)\n     tagged_printf (\"%u\",\n@@ -1598,7 +1616,7 @@ emit_mode_base_align (void)\n \n   print_maybe_const_decl (\"%sunsigned short\",\n \t\t\t  \"mode_base_align\", \"NUM_MACHINE_MODES\",\n-\t\t\t  alignment);\n+\t\t\t  adj_alignment);\n \n   for_all_modes (c, m)\n     tagged_printf (\"%u\", m->alignment, m->name);\n@@ -1679,6 +1697,23 @@ emit_mode_adjustments (void)\n \\n  poly_uint16 ps ATTRIBUTE_UNUSED;\\n\\\n   size_t s ATTRIBUTE_UNUSED;\");\n \n+  for (a = adj_nunits; a; a = a->next)\n+    {\n+      m = a->mode;\n+      printf (\"\\n\"\n+\t      \"  {\\n\"\n+\t      \"    /* %s:%d */\\n  ps = %s;\\n\",\n+\t      a->file, a->line, a->adjustment);\n+      printf (\"    int old_factor = vector_element_size\"\n+\t      \" (mode_precision[E_%smode], mode_nunits[E_%smode]);\\n\",\n+\t      m->name, m->name);\n+      printf (\"    mode_precision[E_%smode] = ps * old_factor;\\n\",  m->name);\n+      printf (\"    mode_size[E_%smode] = exact_div (mode_precision[E_%smode],\"\n+\t      \" BITS_PER_UNIT);\\n\", m->name, m->name);\n+      printf (\"    mode_nunits[E_%smode] = ps;\\n\", m->name);\n+      printf (\"  }\\n\");\n+    }\n+\n   /* Size adjustments must be propagated to all containing modes.\n      A size adjustment forces us to recalculate the alignment too.  */\n   for (a = adj_bytesize; a; a = a->next)\n@@ -1819,7 +1854,7 @@ emit_mode_ibit (void)\n \n   print_maybe_const_decl (\"%sunsigned char\",\n \t\t\t  \"mode_ibit\", \"NUM_MACHINE_MODES\",\n-\t\t\t  ibit);\n+\t\t\t  adj_ibit);\n \n   for_all_modes (c, m)\n     tagged_printf (\"%u\", m->ibit, m->name);\n@@ -1837,7 +1872,7 @@ emit_mode_fbit (void)\n \n   print_maybe_const_decl (\"%sunsigned char\",\n \t\t\t  \"mode_fbit\", \"NUM_MACHINE_MODES\",\n-\t\t\t  fbit);\n+\t\t\t  adj_fbit);\n \n   for_all_modes (c, m)\n     tagged_printf (\"%u\", m->fbit, m->name);"}, {"sha": "d5d5efc22ab318d0910822c3e2a445f10aa894ed", "filename": "gcc/machmode.def", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6561a1af68d6439cedde6dc79d19eda9981a4be/gcc%2Fmachmode.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6561a1af68d6439cedde6dc79d19eda9981a4be/gcc%2Fmachmode.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.def?ref=c6561a1af68d6439cedde6dc79d19eda9981a4be", "patch": "@@ -174,6 +174,12 @@ along with GCC; see the file COPYING3.  If not see\n \tUnlike a FORMAT argument, if you are adjusting a float format\n \tyou must put an & in front of the name of each format structure.\n \n+     ADJUST_NUNITS (MODE, EXPR);\n+\tLike the above, but set the number of nunits of MODE to EXPR.\n+\tThis changes the size and precision of the mode in proportion\n+\tto the change in the number of units; for example, doubling\n+\tthe number of units doubles the size and precision as well.\n+\n    Note: If a mode is ever made which is more than 255 bytes wide,\n    machmode.h and genmodes.c will have to be changed to allocate\n    more space for the mode_size and mode_alignment arrays.  */"}, {"sha": "b938eeaa26bfa6fa9460cf710a95cdf94e87a3ee", "filename": "gcc/machmode.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6561a1af68d6439cedde6dc79d19eda9981a4be/gcc%2Fmachmode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6561a1af68d6439cedde6dc79d19eda9981a4be/gcc%2Fmachmode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.h?ref=c6561a1af68d6439cedde6dc79d19eda9981a4be", "patch": "@@ -23,9 +23,9 @@ along with GCC; see the file COPYING3.  If not see\n typedef opt_mode<machine_mode> opt_machine_mode;\n \n extern CONST_MODE_SIZE poly_uint16_pod mode_size[NUM_MACHINE_MODES];\n-extern const poly_uint16_pod mode_precision[NUM_MACHINE_MODES];\n+extern CONST_MODE_PRECISION poly_uint16_pod mode_precision[NUM_MACHINE_MODES];\n extern const unsigned char mode_inner[NUM_MACHINE_MODES];\n-extern const poly_uint16_pod mode_nunits[NUM_MACHINE_MODES];\n+extern CONST_MODE_NUNITS poly_uint16_pod mode_nunits[NUM_MACHINE_MODES];\n extern CONST_MODE_UNIT_SIZE unsigned char mode_unit_size[NUM_MACHINE_MODES];\n extern const unsigned short mode_unit_precision[NUM_MACHINE_MODES];\n extern const unsigned char mode_wider[NUM_MACHINE_MODES];"}]}