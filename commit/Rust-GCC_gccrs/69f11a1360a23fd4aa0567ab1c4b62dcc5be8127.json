{"sha": "69f11a1360a23fd4aa0567ab1c4b62dcc5be8127", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjlmMTFhMTM2MGEyM2ZkNGFhMDU2N2FiMWM0YjYyZGNjNWJlODEyNw==", "commit": {"author": {"name": "Ira Rosen", "email": "irar@il.ibm.com", "date": "2010-08-15T07:00:32Z"}, "committer": {"name": "Ira Rosen", "email": "irar@gcc.gnu.org", "date": "2010-08-15T07:00:32Z"}, "message": "tree-vect-data-refs.c (vect_setup_realignment): Support realignment in basic blocks.\n\n\n\t* tree-vect-data-refs.c (vect_setup_realignment): Support realignment\n\tin basic blocks.\n\t(vect_supportable_dr_alignment): Check alignment for basic blocks.\n\t* tree-vect-slp.c (vect_build_slp_tree): Allow different codes for \n\tdata references.\n\t(vect_bb_vectorization_profitable_p): New function.\n\t(vect_slp_analyze_bb): Call vect_bb_vectorization_profitable_p() to\n\tcheck if it's worthwhile to vectorize the basic block.\n\nFrom-SVN: r163260", "tree": {"sha": "2868c764dac1d2da61a9fa63a2657ce295df3224", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2868c764dac1d2da61a9fa63a2657ce295df3224"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/69f11a1360a23fd4aa0567ab1c4b62dcc5be8127", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69f11a1360a23fd4aa0567ab1c4b62dcc5be8127", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69f11a1360a23fd4aa0567ab1c4b62dcc5be8127", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69f11a1360a23fd4aa0567ab1c4b62dcc5be8127/comments", "author": {"login": "irar2", "id": 16818592, "node_id": "MDQ6VXNlcjE2ODE4NTky", "avatar_url": "https://avatars.githubusercontent.com/u/16818592?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irar2", "html_url": "https://github.com/irar2", "followers_url": "https://api.github.com/users/irar2/followers", "following_url": "https://api.github.com/users/irar2/following{/other_user}", "gists_url": "https://api.github.com/users/irar2/gists{/gist_id}", "starred_url": "https://api.github.com/users/irar2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irar2/subscriptions", "organizations_url": "https://api.github.com/users/irar2/orgs", "repos_url": "https://api.github.com/users/irar2/repos", "events_url": "https://api.github.com/users/irar2/events{/privacy}", "received_events_url": "https://api.github.com/users/irar2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2d684b3e96bb8eb338e6609044329e195650394b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d684b3e96bb8eb338e6609044329e195650394b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d684b3e96bb8eb338e6609044329e195650394b"}], "stats": {"total": 237, "additions": 206, "deletions": 31}, "files": [{"sha": "9400493ab4036cc1f7382999a9a87f89a15b2b26", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69f11a1360a23fd4aa0567ab1c4b62dcc5be8127/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69f11a1360a23fd4aa0567ab1c4b62dcc5be8127/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=69f11a1360a23fd4aa0567ab1c4b62dcc5be8127", "patch": "@@ -1,3 +1,14 @@\n+2010-08-15  Ira Rosen  <irar@il.ibm.com>\n+\n+\t* tree-vect-data-refs.c (vect_setup_realignment): Support realignment\n+\tin basic blocks.\n+\t(vect_supportable_dr_alignment): Check alignment for basic blocks.\n+\t* tree-vect-slp.c (vect_build_slp_tree): Allow different codes for \n+\tdata references.\n+\t(vect_bb_vectorization_profitable_p): New function.\n+\t(vect_slp_analyze_bb): Call vect_bb_vectorization_profitable_p() to\n+\tcheck if it's worthwhile to vectorize the basic block.\n+\n 2010-08-14  Anatoly Sokolov  <aesok@post.ru>\n \n \t* reload.h (register_move_cost, memory_move_secondary_cost,"}, {"sha": "d8073be7ed8b53702526df93a609b50d781ba904", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69f11a1360a23fd4aa0567ab1c4b62dcc5be8127/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69f11a1360a23fd4aa0567ab1c4b62dcc5be8127/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=69f11a1360a23fd4aa0567ab1c4b62dcc5be8127", "patch": "@@ -1,3 +1,14 @@\n+2010-08-15  Ira Rosen  <irar@il.ibm.com>\n+\n+\t* gcc.dg/vect/costmodel/ppc/costmodel-bb-slp-9a.c: New test.\n+\t* gcc.dg/vect/costmodel/ppc/ppc-costmodel-vect.exp: Run basic block\n+\tSLP tests.\n+\t* gcc.dg/vect/bb-slp-9.c: Now vectorizable on targets that support\n+\tmisaligned loads.\n+\t* gcc.dg/vect/bb-slp-10.c: Now vectorizable on targets that support\n+\tmisaligned stores.c\n+\t* gcc.dg/vect/bb-slp-2.c: Avoid loop vectorization.\n+\n 2010-08-14  Mingjie Xing  <mingjie.xing@gmail.com>\n \n \t* gcc.dg/vect/fast-math-vect-reduc-8.c: Move"}, {"sha": "991802fb87c16fca32ba0c79594e2c03441743e9", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-10.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69f11a1360a23fd4aa0567ab1c4b62dcc5be8127/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69f11a1360a23fd4aa0567ab1c4b62dcc5be8127/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-10.c?ref=69f11a1360a23fd4aa0567ab1c4b62dcc5be8127", "patch": "@@ -50,7 +50,7 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"basic block vectorized using SLP\" 0 \"slp\" } } */\n-/* { dg-final { scan-tree-dump-times \"unsupported alignment in basic block.\" 1 \"slp\" } } */\n+/* { dg-final { scan-tree-dump-times \"unsupported alignment in basic block.\" 1 \"slp\" { xfail vect_hw_misalign } } } */\n+/* { dg-final { scan-tree-dump-times \"basic block vectorized using SLP\" 1 \"slp\" { target vect_hw_misalign } } } */\n /* { dg-final { cleanup-tree-dump \"slp\" } } */\n   "}, {"sha": "4414a9897775ea29b9eb49ea0d9c9f87fff31b1e", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69f11a1360a23fd4aa0567ab1c4b62dcc5be8127/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69f11a1360a23fd4aa0567ab1c4b62dcc5be8127/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-2.c?ref=69f11a1360a23fd4aa0567ab1c4b62dcc5be8127", "patch": "@@ -24,8 +24,8 @@ main1 (int dummy)\n       *pout++ = *pin++;\n \n       /* Avoid loop vectorization.  */\n-      if (dummy == 32)\n-        abort ();\n+      if (dummy)\n+        __asm__ volatile (\"\" : : : \"memory\");\n     }\n \n   /* check results:  */ "}, {"sha": "40a9f27408c8eec093c5a5bb542599276c3e2d73", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-9.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69f11a1360a23fd4aa0567ab1c4b62dcc5be8127/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69f11a1360a23fd4aa0567ab1c4b62dcc5be8127/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-9.c?ref=69f11a1360a23fd4aa0567ab1c4b62dcc5be8127", "patch": "@@ -47,7 +47,6 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"basic block vectorized using SLP\" 0 \"slp\" } } */\n-/* { dg-final { scan-tree-dump-times \"unsupported alignment in basic block.\" 1 \"slp\" } } */\n+/* { dg-final { scan-tree-dump-times \"basic block vectorized using SLP\" 1 \"slp\"  { xfail  vect_no_align } } } */\n /* { dg-final { cleanup-tree-dump \"slp\" } } */\n   "}, {"sha": "d14ae520c72a997445b5029958236da20a27426a", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-bb-slp-9a.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69f11a1360a23fd4aa0567ab1c4b62dcc5be8127/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fcostmodel-bb-slp-9a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69f11a1360a23fd4aa0567ab1c4b62dcc5be8127/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fcostmodel-bb-slp-9a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fcostmodel-bb-slp-9a.c?ref=69f11a1360a23fd4aa0567ab1c4b62dcc5be8127", "patch": "@@ -0,0 +1,47 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"../../tree-vect.h\"\n+\n+#define N 16 \n+\n+unsigned int out[N];\n+unsigned int in[N] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n+\n+__attribute__ ((noinline)) int\n+main1 (unsigned int x, unsigned int y)\n+{\n+  int i;\n+  unsigned int *pin = &in[1];\n+  unsigned int *pout = &out[0];\n+  unsigned int a0, a1, a2, a3;\n+\n+  /* Misaligned load.  */\n+  *pout++ = *pin++;\n+  *pout++ = *pin++;\n+  *pout++ = *pin++;\n+  *pout++ = *pin++;\n+\n+  /* Check results.  */\n+  if (out[0] != in[1]\n+      || out[1] != in[2]\n+      || out[2] != in[3]\n+      || out[3] != in[4])\n+    abort();\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  check_vect ();\n+\n+  main1 (2, 3);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"basic block vectorized using SLP\" 1 \"slp\"  { xfail  vect_no_align } } } */\n+/* { dg-final { cleanup-tree-dump \"slp\" } } */\n+  "}, {"sha": "806260ab61ef712d564e55d6c87581494f80c54f", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/ppc/ppc-costmodel-vect.exp", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69f11a1360a23fd4aa0567ab1c4b62dcc5be8127/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fppc-costmodel-vect.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69f11a1360a23fd4aa0567ab1c4b62dcc5be8127/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fppc-costmodel-vect.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fppc-costmodel-vect.exp?ref=69f11a1360a23fd4aa0567ab1c4b62dcc5be8127", "patch": "@@ -57,7 +57,10 @@ if [check_vmx_hw_available] {\n # Initialize `dg'.\n dg-init\n \n+set VECT_SLP_CFLAGS $DEFAULT_VECTCFLAGS\n+\n lappend DEFAULT_VECTCFLAGS \"-fdump-tree-vect-details\"\n+lappend VECT_SLP_CFLAGS \"-fdump-tree-slp-details\"\n \n # Main loop.\n dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/costmodel-pr*.\\[cS\\]]]  \\\n@@ -66,6 +69,8 @@ dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/costmodel-vect-*.\\[cS\\]]]  \\\n \t\"\" $DEFAULT_VECTCFLAGS\n dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/costmodel-slp-*.\\[cS\\]]]  \\\n         \"\" $DEFAULT_VECTCFLAGS\n+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/costmodel-bb-slp*.\\[cS\\]]]  \\\n+        \"\" $VECT_SLP_CFLAGS\n \n #### Tests with special options\n global SAVED_DEFAULT_VECTCFLAGS"}, {"sha": "3f63a7fabadcc7d33b3523186e622dd4b7e02cae", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 40, "deletions": 23, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69f11a1360a23fd4aa0567ab1c4b62dcc5be8127/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69f11a1360a23fd4aa0567ab1c4b62dcc5be8127/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=69f11a1360a23fd4aa0567ab1c4b62dcc5be8127", "patch": "@@ -3467,8 +3467,8 @@ vect_setup_realignment (gimple stmt, gimple_stmt_iterator *gsi,\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);\n-  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n-  edge pe;\n+  struct loop *loop = NULL;\n+  edge pe = NULL;\n   tree scalar_dest = gimple_assign_lhs (stmt);\n   tree vec_dest;\n   gimple inc;\n@@ -3483,9 +3483,15 @@ vect_setup_realignment (gimple stmt, gimple_stmt_iterator *gsi,\n   gimple_seq stmts = NULL;\n   bool inv_p;\n   bool compute_in_loop = false;\n-  bool nested_in_vect_loop = nested_in_vect_loop_p (loop, stmt);\n+  bool nested_in_vect_loop = false;\n   struct loop *containing_loop = (gimple_bb (stmt))->loop_father;\n-  struct loop *loop_for_initial_load;\n+  struct loop *loop_for_initial_load = NULL;\n+\n+  if (loop_vinfo)\n+    {\n+      loop = LOOP_VINFO_LOOP (loop_vinfo);\n+      nested_in_vect_loop = nested_in_vect_loop_p (loop, stmt);\n+    }\n \n   gcc_assert (alignment_support_scheme == dr_explicit_realign\n \t      || alignment_support_scheme == dr_explicit_realign_optimized);\n@@ -3523,7 +3529,7 @@ vect_setup_realignment (gimple stmt, gimple_stmt_iterator *gsi,\n      or not, which in turn determines if the misalignment is computed inside\n      the inner-loop, or outside LOOP.  */\n \n-  if (init_addr != NULL_TREE)\n+  if (init_addr != NULL_TREE || !loop_vinfo)\n     {\n       compute_in_loop = true;\n       gcc_assert (alignment_support_scheme == dr_explicit_realign);\n@@ -3555,6 +3561,9 @@ vect_setup_realignment (gimple stmt, gimple_stmt_iterator *gsi,\n   if (at_loop)\n     *at_loop = loop_for_initial_load;\n \n+  if (loop_for_initial_load)\n+    pe = loop_preheader_edge (loop_for_initial_load);\n+\n   /* 3. For the case of the optimized realignment, create the first vector\n       load at the loop preheader.  */\n \n@@ -3563,7 +3572,6 @@ vect_setup_realignment (gimple stmt, gimple_stmt_iterator *gsi,\n       /* Create msq_init = *(floor(p1)) in the loop preheader  */\n \n       gcc_assert (!compute_in_loop);\n-      pe = loop_preheader_edge (loop_for_initial_load);\n       vec_dest = vect_create_destination_var (scalar_dest, vectype);\n       ptr = vect_create_data_ref_ptr (stmt, loop_for_initial_load, NULL_TREE,\n \t\t\t\t      &init_addr, &inc, true, &inv_p);\n@@ -3582,8 +3590,14 @@ vect_setup_realignment (gimple stmt, gimple_stmt_iterator *gsi,\n       new_temp = make_ssa_name (vec_dest, new_stmt);\n       gimple_assign_set_lhs (new_stmt, new_temp);\n       mark_symbols_for_renaming (new_stmt);\n-      new_bb = gsi_insert_on_edge_immediate (pe, new_stmt);\n-      gcc_assert (!new_bb);\n+      if (pe)\n+        {\n+          new_bb = gsi_insert_on_edge_immediate (pe, new_stmt);\n+          gcc_assert (!new_bb);\n+        }\n+      else\n+         gsi_insert_before (gsi, new_stmt, GSI_SAME_STMT);\n+\n       msq_init = gimple_assign_lhs (new_stmt);\n     }\n \n@@ -3596,16 +3610,19 @@ vect_setup_realignment (gimple stmt, gimple_stmt_iterator *gsi,\n       tree builtin_decl;\n \n       /* Compute INIT_ADDR - the initial addressed accessed by this memref.  */\n-      if (compute_in_loop)\n-\tgcc_assert (init_addr); /* already computed by the caller.  */\n-      else\n+      if (!init_addr)\n \t{\n \t  /* Generate the INIT_ADDR computation outside LOOP.  */\n \t  init_addr = vect_create_addr_base_for_vector_ref (stmt, &stmts,\n \t\t\t\t\t\t\tNULL_TREE, loop);\n-\t  pe = loop_preheader_edge (loop);\n-\t  new_bb = gsi_insert_seq_on_edge_immediate (pe, stmts);\n-\t  gcc_assert (!new_bb);\n+          if (loop)\n+            {\n+   \t      pe = loop_preheader_edge (loop);\n+\t      new_bb = gsi_insert_seq_on_edge_immediate (pe, stmts);\n+\t      gcc_assert (!new_bb);\n+            }\n+          else\n+             gsi_insert_seq_before (gsi, stmts, GSI_SAME_STMT);\n \t}\n \n       builtin_decl = targetm.vectorize.builtin_mask_for_load ();\n@@ -3979,12 +3996,11 @@ vect_supportable_dr_alignment (struct data_reference *dr,\n   if (aligned_access_p (dr) && !check_aligned_accesses)\n     return dr_aligned;\n \n-  if (!loop_vinfo)\n-    /* FORNOW: Misaligned accesses are supported only in loops.  */\n-    return dr_unaligned_unsupported;\n-\n-  vect_loop = LOOP_VINFO_LOOP (loop_vinfo);\n-  nested_in_vect_loop = nested_in_vect_loop_p (vect_loop, stmt);\n+  if (loop_vinfo)\n+    {\n+      vect_loop = LOOP_VINFO_LOOP (loop_vinfo);\n+      nested_in_vect_loop = nested_in_vect_loop_p (vect_loop, stmt);\n+    }\n \n   /* Possibly unaligned access.  */\n \n@@ -4059,9 +4075,10 @@ vect_supportable_dr_alignment (struct data_reference *dr,\n \t      || targetm.vectorize.builtin_mask_for_load ()))\n \t{\n \t  tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n-\t  if (nested_in_vect_loop\n-\t      && (TREE_INT_CST_LOW (DR_STEP (dr))\n-\t\t  != GET_MODE_SIZE (TYPE_MODE (vectype))))\n+\t  if ((nested_in_vect_loop\n+\t       && (TREE_INT_CST_LOW (DR_STEP (dr))\n+\t \t   != GET_MODE_SIZE (TYPE_MODE (vectype))))\n+              || !loop_vinfo)\n \t    return dr_explicit_realign;\n \t  else\n \t    return dr_explicit_realign_optimized;"}, {"sha": "7f219d56d8924dedef7c7b0d2864b228ad2692fb", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 87, "deletions": 2, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69f11a1360a23fd4aa0567ab1c4b62dcc5be8127/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69f11a1360a23fd4aa0567ab1c4b62dcc5be8127/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=69f11a1360a23fd4aa0567ab1c4b62dcc5be8127", "patch": "@@ -456,7 +456,12 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t      && (first_stmt_code != IMAGPART_EXPR\n \t\t  || rhs_code != REALPART_EXPR)\n \t      && (first_stmt_code != REALPART_EXPR\n-\t\t  || rhs_code != IMAGPART_EXPR))\n+\t\t  || rhs_code != IMAGPART_EXPR)\n+              && !(STMT_VINFO_STRIDED_ACCESS (vinfo_for_stmt (stmt))\n+                   && (first_stmt_code == ARRAY_REF\n+                       || first_stmt_code == INDIRECT_REF\n+                       || first_stmt_code == COMPONENT_REF\n+                       || first_stmt_code == MEM_REF)))\n \t    {\n \t      if (vect_print_dump_info (REPORT_SLP))\n \t\t{\n@@ -1509,7 +1514,75 @@ vect_slp_analyze_operations (bb_vec_info bb_vinfo)\n }\n \n \n-/* Cheick if the basic block can be vectorized.  */\n+/* Check if vectorization of the basic block is profitable.  */\n+\n+static bool\n+vect_bb_vectorization_profitable_p (bb_vec_info bb_vinfo)\n+{\n+  VEC (slp_instance, heap) *slp_instances = BB_VINFO_SLP_INSTANCES (bb_vinfo);\n+  slp_instance instance;\n+  int i;\n+  unsigned int vec_outside_cost = 0, vec_inside_cost = 0, scalar_cost = 0;\n+  unsigned int stmt_cost;\n+  gimple stmt;\n+  gimple_stmt_iterator si;\n+  basic_block bb = BB_VINFO_BB (bb_vinfo);\n+  stmt_vec_info stmt_info = NULL;\n+  tree dummy_type = NULL;\n+  int dummy = 0;\n+\n+  /* Calculate vector costs.  */\n+  for (i = 0; VEC_iterate (slp_instance, slp_instances, i, instance); i++)\n+    {\n+      vec_outside_cost += SLP_INSTANCE_OUTSIDE_OF_LOOP_COST (instance);\n+      vec_inside_cost += SLP_INSTANCE_INSIDE_OF_LOOP_COST (instance);\n+    }\n+\n+  /* Calculate scalar cost.  */\n+  for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n+    {\n+      stmt = gsi_stmt (si);\n+      stmt_info = vinfo_for_stmt (stmt);\n+\n+      if (!stmt_info || !STMT_VINFO_VECTORIZABLE (stmt_info)\n+          || !PURE_SLP_STMT (stmt_info))\n+        continue;\n+\n+      if (STMT_VINFO_DATA_REF (stmt_info))\n+        {\n+          if (DR_IS_READ (STMT_VINFO_DATA_REF (stmt_info)))\n+            stmt_cost = targetm.vectorize.builtin_vectorization_cost \n+                          (scalar_load, dummy_type, dummy);\n+          else\n+            stmt_cost = targetm.vectorize.builtin_vectorization_cost\n+                          (scalar_store, dummy_type, dummy);\n+        }\n+      else\n+        stmt_cost = targetm.vectorize.builtin_vectorization_cost\n+                      (scalar_stmt, dummy_type, dummy);\n+\n+      scalar_cost += stmt_cost;\n+    }\n+\n+  if (vect_print_dump_info (REPORT_COST))\n+    {\n+      fprintf (vect_dump, \"Cost model analysis: \\n\");\n+      fprintf (vect_dump, \"  Vector inside of basic block cost: %d\\n\",\n+               vec_inside_cost);\n+      fprintf (vect_dump, \"  Vector outside of basic block cost: %d\\n\",\n+               vec_outside_cost);\n+      fprintf (vect_dump, \"  Scalar cost of basic block: %d\", scalar_cost);\n+    }\n+\n+  /* Vectorization is profitable if its cost is less than the cost of scalar\n+     version.  */\n+  if (vec_outside_cost + vec_inside_cost >= scalar_cost)\n+    return false;\n+\n+  return true;\n+}\n+\n+/* Check if the basic block can be vectorized.  */\n \n bb_vec_info\n vect_slp_analyze_bb (basic_block bb)\n@@ -1641,6 +1714,18 @@ vect_slp_analyze_bb (basic_block bb)\n       return NULL;\n     }\n \n+  /* Cost model: check if the vectorization is worthwhile.  */\n+  if (flag_vect_cost_model\n+      && !vect_bb_vectorization_profitable_p (bb_vinfo))\n+    {\n+      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n+        fprintf (vect_dump, \"not vectorized: vectorization is not \"\n+                            \"profitable.\\n\");\n+\n+      destroy_bb_vec_info (bb_vinfo);\n+      return NULL;\n+    }\n+\n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"Basic block will be vectorized using SLP\\n\");\n "}]}