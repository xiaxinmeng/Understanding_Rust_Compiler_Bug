{"sha": "5e0de251204954b4a332a2ed7417623ed826de3e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWUwZGUyNTEyMDQ5NTRiNGEzMzJhMmVkNzQxNzYyM2VkODI2ZGUzZQ==", "commit": {"author": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1993-04-19T19:24:23Z"}, "committer": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1993-04-19T19:24:23Z"}, "message": "(expand_call): Use new FUNCTION_ARG_CALLEE_COPIES macro.\n\nFrom-SVN: r4183", "tree": {"sha": "cfbd4116ad8dc8f6ccdd649076ec02873f0c1902", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cfbd4116ad8dc8f6ccdd649076ec02873f0c1902"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5e0de251204954b4a332a2ed7417623ed826de3e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e0de251204954b4a332a2ed7417623ed826de3e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e0de251204954b4a332a2ed7417623ed826de3e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e0de251204954b4a332a2ed7417623ed826de3e/comments", "author": null, "committer": null, "parents": [{"sha": "fd6b2a6d3e5054e023b85c67e88910a4406d0935", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd6b2a6d3e5054e023b85c67e88910a4406d0935", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd6b2a6d3e5054e023b85c67e88910a4406d0935"}], "stats": {"total": 75, "additions": 47, "deletions": 28}, "files": [{"sha": "f1cbfc2551ca222aaff6ebbc4476ccf3b155c98c", "filename": "gcc/calls.c", "status": "modified", "additions": 47, "deletions": 28, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e0de251204954b4a332a2ed7417623ed826de3e/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e0de251204954b4a332a2ed7417623ed826de3e/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=5e0de251204954b4a332a2ed7417623ed826de3e", "patch": "@@ -915,41 +915,60 @@ expand_call (exp, target, ignore)\n       if (FUNCTION_ARG_PASS_BY_REFERENCE (args_so_far, TYPE_MODE (type), type,\n \t\t\t\t\t  argpos < n_named_args))\n \t{\n-\t  /* We make a copy of the object and pass the address to the function\n-\t     being called.  */\n-\t  rtx copy;\n-\n-\t  if (TYPE_SIZE (type) == 0\n-\t      || TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)\n+#ifdef FUNCTION_ARG_CALLEE_COPIES\n+\t  if (FUNCTION_ARG_CALLEE_COPIES (args_so_far, TYPE_MODE (type), type,\n+\t\t\t\t\t  argpos < n_named_args)\n+\t      /* If it's in a register, we must make a copy of it too.  */\n+\t      /* ??? Is this a sufficient test?  Is there a better one? */\n+\t      && !(TREE_CODE (args[i].tree_value) == VAR_DECL\n+\t\t   && REG_P (DECL_RTL (args[i].tree_value))))\n \t    {\n-\t      /* This is a variable-sized object.  Make space on the stack\n-\t\t for it.  */\n-\t      rtx size_rtx = expr_size (TREE_VALUE (p));\n-\n-\t      if (old_stack_level == 0)\n-\t\t{\n-\t\t  emit_stack_save (SAVE_BLOCK, &old_stack_level, NULL_RTX);\n-\t\t  old_pending_adj = pending_stack_adjust;\n-\t\t  pending_stack_adjust = 0;\n-\t\t}\n-\n-\t      copy = gen_rtx (MEM, BLKmode,\n-\t\t\t      allocate_dynamic_stack_space (size_rtx, NULL_RTX,\n-\t\t\t\t\t\t\t    TYPE_ALIGN (type)));\n+\t      args[i].tree_value = build1 (ADDR_EXPR,\n+\t\t\t\t\t   build_pointer_type (type),\n+\t\t\t\t\t   args[i].tree_value);\n+\t      type = build_pointer_type (type);\n \t    }\n \t  else\n+#endif\n \t    {\n-\t      int size = int_size_in_bytes (type);\n-\t      copy = assign_stack_temp (TYPE_MODE (type), size, 1);\n-\t    }\n+\t      /* We make a copy of the object and pass the address to the\n+\t\t function being called.  */\n+\t      rtx copy;\n \n-\t  store_expr (args[i].tree_value, copy, 0);\n+\t      if (TYPE_SIZE (type) == 0\n+\t\t  || TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)\n+\t\t{\n+\t\t  /* This is a variable-sized object.  Make space on the stack\n+\t\t     for it.  */\n+\t\t  rtx size_rtx = expr_size (TREE_VALUE (p));\n+\n+\t\t  if (old_stack_level == 0)\n+\t\t    {\n+\t\t      emit_stack_save (SAVE_BLOCK, &old_stack_level, NULL_RTX);\n+\t\t      old_pending_adj = pending_stack_adjust;\n+\t\t      pending_stack_adjust = 0;\n+\t\t    }\n+\n+\t\t  copy = gen_rtx (MEM, BLKmode,\n+\t\t\t\t  allocate_dynamic_stack_space (size_rtx,\n+\t\t\t\t\t\t\t\tNULL_RTX,\n+\t\t\t\t\t\t\t\tTYPE_ALIGN (type)));\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  int size = int_size_in_bytes (type);\n+\t\t  copy = assign_stack_temp (TYPE_MODE (type), size, 1);\n+\t\t}\n \n-\t  args[i].tree_value = build1 (ADDR_EXPR, build_pointer_type (type),\n-\t\t\t\t       make_tree (type, copy));\n-\t  type = build_pointer_type (type);\n+\t      store_expr (args[i].tree_value, copy, 0);\n+\n+\t      args[i].tree_value = build1 (ADDR_EXPR,\n+\t\t\t\t\t   build_pointer_type (type),\n+\t\t\t\t\t   make_tree (type, copy));\n+\t      type = build_pointer_type (type);\n+\t    }\n \t}\n-#endif\n+#endif /* FUNCTION_ARG_PASS_BY_REFERENCE */\n \n       mode = TYPE_MODE (type);\n "}]}