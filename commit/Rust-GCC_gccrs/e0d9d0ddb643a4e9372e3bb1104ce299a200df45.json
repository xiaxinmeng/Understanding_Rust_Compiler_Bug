{"sha": "e0d9d0ddb643a4e9372e3bb1104ce299a200df45", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTBkOWQwZGRiNjQzYTRlOTM3MmUzYmIxMTA0Y2UyOTlhMjAwZGY0NQ==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@redhat.com", "date": "2006-12-07T10:54:13Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2006-12-07T10:54:13Z"}, "message": "common.opt (record-gcc-switches): New command line switch.\n\n* common.opt (record-gcc-switches): New command line switch.\n* target.h (print_switch_type): New enum.\n  (print_switch_fn_type): New typedef for a function pointer.\n  (struct gcc_target): Add record_gcc_switches and record_gcc_switches_section fields.\n* target-def.h (TARGET_ASM_RECORD_GCC_SWITCHES): Provide a default definition.\n  (TARGET_ASM_RECORD_GCC_SWITCHES_SECTION): Provide a default definition.\n* toplev.c (print_single_switch): Simplify by providing a pointer to function that will format and output the switch appropriately.\n  (print_switch_values): Likewise.\n  (print_to_asm_out_file): New function.\n  (print_to_stderr): New function.\n  (init_asm_output): If flag_record_gcc_switches is set then if the target supports recording the switches then emit them into the assembler output file, otherwise tell the user that the switch is not supported.\n* varasm.c (eld_record_gcc_switches): New function.  Example handler for the record_gcc_switches target hook.\n* doc/tm.texi (TARGET_ASM_RECORD_GCC_SWITCHES): Document the new target hook.\n  (TARGET_ASM_RECORD_GCC_SWITCHES_SECTION): Likewise.\n* doc/invoke.texi (-frecord-gcc-switches): Document.\n\nFrom-SVN: r119615", "tree": {"sha": "46d6178c94554a22a20fe838a94fbf98cec94d4d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/46d6178c94554a22a20fe838a94fbf98cec94d4d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e0d9d0ddb643a4e9372e3bb1104ce299a200df45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0d9d0ddb643a4e9372e3bb1104ce299a200df45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0d9d0ddb643a4e9372e3bb1104ce299a200df45", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0d9d0ddb643a4e9372e3bb1104ce299a200df45/comments", "author": {"login": "nickclifton", "id": 31441682, "node_id": "MDQ6VXNlcjMxNDQxNjgy", "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nickclifton", "html_url": "https://github.com/nickclifton", "followers_url": "https://api.github.com/users/nickclifton/followers", "following_url": "https://api.github.com/users/nickclifton/following{/other_user}", "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}", "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions", "organizations_url": "https://api.github.com/users/nickclifton/orgs", "repos_url": "https://api.github.com/users/nickclifton/repos", "events_url": "https://api.github.com/users/nickclifton/events{/privacy}", "received_events_url": "https://api.github.com/users/nickclifton/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1d49ee6a7985f8eb2a759a3d22fb3c8fec92a403", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d49ee6a7985f8eb2a759a3d22fb3c8fec92a403", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d49ee6a7985f8eb2a759a3d22fb3c8fec92a403"}], "stats": {"total": 434, "additions": 374, "deletions": 60}, "files": [{"sha": "33bd10262222c2487aa4c42181373e204edfd9e1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0d9d0ddb643a4e9372e3bb1104ce299a200df45/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0d9d0ddb643a4e9372e3bb1104ce299a200df45/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e0d9d0ddb643a4e9372e3bb1104ce299a200df45", "patch": "@@ -1,3 +1,31 @@\n+2006-12-07  Nick Clifton  <nickc@redhat.com>\n+\n+\t* common.opt (record-gcc-switches): New command line switch.\n+\t* target.h (print_switch_type): New enum.\n+\t(print_switch_fn_type): New typedef for a function pointer.\n+\t(struct gcc_target): Add record_gcc_switches and\n+\trecord_gcc_switches_section fields.\n+\t* target-def.h (TARGET_ASM_RECORD_GCC_SWITCHES): Provide a\n+        default definition.\n+\t(TARGET_ASM_RECORD_GCC_SWITCHES_SECTION): Provide a default\n+\tdefinition.\n+\t* toplev.c (print_single_switch): Simplify by providing a\n+\tpointer to function that will format and output the switch\n+\tappropriately.\n+\t(print_switch_values): Likewise.\n+\t(print_to_asm_out_file): New function.\n+\t(print_to_stderr): New function.\n+\t(init_asm_output): If flag_record_gcc_switches is set then if\n+        the target supports recording the switches then emit them into\n+        the assembler output file, otherwise tell the user that the\n+        switch is not supported.\n+\t* varasm.c (eld_record_gcc_switches): New function.  Example\n+\thandler for the record_gcc_switches target hook.\n+\t* doc/tm.texi (TARGET_ASM_RECORD_GCC_SWITCHES): Document the new\n+\ttarget hook.\n+\t(TARGET_ASM_RECORD_GCC_SWITCHES_SECTION): Likewise.\n+\t* doc/invoke.texi (-frecord-gcc-switches): Document.\n+\n 2006-12-07  Maxim Kuvyrkov  <mkuvyrkov@ispras.ru>\n \n \tPR target/29794"}, {"sha": "2251b86e34a4fea102121c42d36b4bd116d936d7", "filename": "gcc/common.opt", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0d9d0ddb643a4e9372e3bb1104ce299a200df45/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0d9d0ddb643a4e9372e3bb1104ce299a200df45/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=e0d9d0ddb643a4e9372e3bb1104ce299a200df45", "patch": "@@ -715,6 +715,16 @@ frandom-seed=\n Common Joined RejectNegative\n -frandom-seed=<string>\tMake compile reproducible using <string>\n \n+; This switch causes the command line that was used to create an\n+; object file to be recorded into the object file.  The exact format\n+; of this recording is target and binary file format dependent.\n+; It is related to the -fverbose-asm switch, but that switch only\n+; records information in the assembler output file as comments, so\n+; they never reach the object file.\n+frecord-gcc-switches\n+Common Report Var(flag_record_gcc_switches)\n+Record gcc command line switches in the object file.\n+\n freg-struct-return\n Common Report Var(flag_pcc_struct_return,0) VarExists\n Return small aggregates in registers"}, {"sha": "2baf3c3984e3a49a1a29e4a620ca9b6eff9cab92", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0d9d0ddb643a4e9372e3bb1104ce299a200df45/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0d9d0ddb643a4e9372e3bb1104ce299a200df45/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=e0d9d0ddb643a4e9372e3bb1104ce299a200df45", "patch": "@@ -783,6 +783,7 @@ See S/390 and zSeries Options.\n -fno-common  -fno-ident @gol\n -fpcc-struct-return  -fpic  -fPIC -fpie -fPIE @gol\n -fno-jump-tables @gol\n+-frecord-gcc-switches @gol\n -freg-struct-return  -fshort-enums @gol\n -fshort-double  -fshort-wchar @gol\n -fverbose-asm  -fpack-struct[=@var{n}]  -fstack-check @gol\n@@ -13508,6 +13509,17 @@ debugging the compiler itself).\n extra information to be omitted and is useful when comparing two assembler\n files.\n \n+@item -frecord-gcc-switches\n+@opindex frecord-gcc-switches\n+This switch causes the command line that was used to invoke the\n+compiler to be recorded into the object file that is being created.\n+This switch is only implemented on some targets and the exact format\n+of the recording is target and binary file format dependent, but it\n+usually takes the form of a section containing ASCII text.  This\n+switch is related to the @option{-fverbose-asm} switch, but that\n+switch only records information in the assembler output file as\n+comments, so it never reaches the object file.\n+\n @item -fpic\n @opindex fpic\n @cindex global offset table"}, {"sha": "52305478d1a59b8e63b7f9dddfcf8f89d9275027", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0d9d0ddb643a4e9372e3bb1104ce299a200df45/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0d9d0ddb643a4e9372e3bb1104ce299a200df45/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=e0d9d0ddb643a4e9372e3bb1104ce299a200df45", "patch": "@@ -6653,6 +6653,58 @@ need to override this if your target has special flags that might be\n set via @code{__attribute__}.\n @end deftypefn\n \n+@deftypefn {Target Hook} {int} TARGET_ASM_RECORD_GCC_SWITCHES (print_switch_type @var{type}, const char * @var{text})\n+Provides the target with the ability to record the gcc command line\n+switches that have been passed to the compiler, and options that are\n+enabled.  The @var{type} argument specifies what is being recorded.\n+It can take the following values:\n+\n+@table @gcctabopt\n+@item SWITCH_TYPE_PASSED\n+@var{text} is a command line switch that has been set by the user.\n+\n+@item SWITCH_TYPE_ENABLED\n+@var{text} is an option which has been enabled.  This might be as a\n+direct result of a command line switch, or because it is enabled by\n+default or because it has been enabled as a side effect of a different\n+command line switch.  For example, the @option{-O2} switch enables\n+various different individual optimization passes.\n+\n+@item SWITCH_TYPE_DESCRIPTIVE\n+@var{text} is either NULL or some descriptive text which should be\n+ignored.  If @var{text} is NULL then it is being used to warn the\n+target hook that either recording is starting or ending.  The first\n+time @var{type} is SWITCH_TYPE_DESCRIPTIVE and @var{text} is NULL, the\n+warning is for start up and the second time the warning is for\n+wind down.  This feature is to allow the target hook to make any\n+necessary preparations before it starts to record switches and to\n+perform any necessary tidying up after it has finished recording\n+switches.\n+\n+@item SWITCH_TYPE_LINE_START\n+This option can be ignored by this target hook.\n+\n+@item  SWITCH_TYPE_LINE_END\n+This option can be ignored by this target hook.\n+@end table\n+\n+The hook's return value must be zero.  Other return values may be\n+supported in the future.\n+\n+By default this hook is set to NULL, but an example implementation is\n+provided for ELF based targets.  Called @var{elf_record_gcc_switches},\n+it records the switches as ASCII text inside a new, string mergeable\n+section in the assembler output file.  The name of the new section is\n+provided by the @code{TARGET_ASM_RECORD_GCC_SWITCHES_SECTION} target\n+hook.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} {const char *} TARGET_ASM_RECORD_GCC_SWITCHES_SECTION\n+This is the name of the section that will be created by the example\n+ELF implementation of the @code{TARGET_ASM_RECORD_GCC_SWITCHES} target\n+hook.\n+@end deftypefn\n+\n @need 2000\n @node Data Output\n @subsection Output of Data"}, {"sha": "8cb5d269278c6f4a5dcda90311c2385c1f8600cb", "filename": "gcc/target-def.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0d9d0ddb643a4e9372e3bb1104ce299a200df45/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0d9d0ddb643a4e9372e3bb1104ce299a200df45/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=e0d9d0ddb643a4e9372e3bb1104ce299a200df45", "patch": "@@ -227,6 +227,13 @@ Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n #define TARGET_ASM_OUTPUT_DWARF_DTPREL NULL\n #endif\n \n+#ifndef TARGET_ASM_RECORD_GCC_SWITCHES\n+#define TARGET_ASM_RECORD_GCC_SWITCHES NULL\n+#endif\n+#ifndef TARGET_ASM_RECORD_GCC_SWITCHES_SECTION\n+#define TARGET_ASM_RECORD_GCC_SWITCHES_SECTION \".GCC.command.line\"\n+#endif\n+\n #define TARGET_ASM_ALIGNED_INT_OP\t\t\t\t\\\n \t\t       {TARGET_ASM_ALIGNED_HI_OP,\t\t\\\n \t\t\tTARGET_ASM_ALIGNED_SI_OP,\t\t\\\n@@ -270,6 +277,8 @@ Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n                         TARGET_ASM_FILE_END,\t\t\t\\\n \t\t\tTARGET_ASM_EXTERNAL_LIBCALL,            \\\n                         TARGET_ASM_MARK_DECL_PRESERVED,\t\t\\\n+\t\t\tTARGET_ASM_RECORD_GCC_SWITCHES,\t\t\\\n+\t\t\tTARGET_ASM_RECORD_GCC_SWITCHES_SECTION,\t\\\n \t\t\tTARGET_ASM_OUTPUT_ANCHOR,\t\t\\\n \t\t\tTARGET_ASM_OUTPUT_DWARF_DTPREL}\n "}, {"sha": "b59f561657f9e379e8fb77d7bdb7150af38b4a2f", "filename": "gcc/target.h", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0d9d0ddb643a4e9372e3bb1104ce299a200df45/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0d9d0ddb643a4e9372e3bb1104ce299a200df45/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=e0d9d0ddb643a4e9372e3bb1104ce299a200df45", "patch": "@@ -51,6 +51,22 @@ Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n #include \"tm.h\"\n #include \"insn-modes.h\"\n \n+/* Types used by the record_gcc_switches() target function.  */\n+typedef enum\n+{\n+  SWITCH_TYPE_PASSED,\t\t/* A switch passed on the command line.  */\n+  SWITCH_TYPE_ENABLED,\t\t/* An option that is currently enabled.  */\n+  SWITCH_TYPE_DESCRIPTIVE,\t/* Descriptive text, not a switch or option.  */\n+  SWITCH_TYPE_LINE_START,\t/* Please emit any necessary text at the start of a line.  */\n+  SWITCH_TYPE_LINE_END\t\t/* Please emit a line terminator.  */\n+}\n+print_switch_type;\n+\n+typedef int (* print_switch_fn_type) (print_switch_type, const char *);\n+\n+/* An example implementation for ELF targets.  Defined in varasm.c  */\n+extern int elf_record_gcc_switches (print_switch_type type, const char *);\n+\n struct stdarg_info;\n struct spec_info_def;\n \n@@ -196,10 +212,18 @@ struct gcc_target\n        external.  */\n     void (*external_libcall) (rtx);\n \n-     /* Output an assembler directive to mark decl live. This instructs\n+    /* Output an assembler directive to mark decl live. This instructs\n \tlinker to not dead code strip this symbol.  */\n     void (*mark_decl_preserved) (const char *);\n \n+    /* Output a record of the command line switches that have been passed.  */\n+    print_switch_fn_type record_gcc_switches;\n+    /* The name of the section that the example ELF implementation of\n+       record_gcc_switches will use to store the information.  Target\n+       specific versions of record_gcc_switches may or may not use\n+       this information.  */\n+    const char * record_gcc_switches_section;\n+\n     /* Output the definition of a section anchor.  */\n     void (*output_anchor) (rtx);\n \n@@ -796,7 +820,7 @@ struct gcc_target\n        target modifications).  */\n     void (*adjust_class_at_definition) (tree type);\n   } cxx;\n-  \n+\n   /* For targets that need to mark extra registers as live on entry to\n      the function, they should define this target hook and set their\n      bits in the bitmap passed in. */  "}, {"sha": "5fd8c4d3b4c7c76cdb1eeffd7d59423d0f868723", "filename": "gcc/toplev.c", "status": "modified", "additions": 136, "deletions": 58, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0d9d0ddb643a4e9372e3bb1104ce299a200df45/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0d9d0ddb643a4e9372e3bb1104ce299a200df45/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=e0d9d0ddb643a4e9372e3bb1104ce299a200df45", "patch": "@@ -112,12 +112,6 @@ static void crash_signal (int) ATTRIBUTE_NORETURN;\n static void setup_core_dumping (void);\n static void compile_file (void);\n \n-static int print_single_switch (FILE *, int, int, const char *,\n-\t\t\t\tconst char *, const char *,\n-\t\t\t\tconst char *, const char *);\n-static void print_switch_values (FILE *, int, int, const char *,\n-\t\t\t\t const char *, const char *);\n-\n /* Nonzero to dump debug info whilst parsing (-dy option).  */\n static int set_yydebug;\n \n@@ -1182,44 +1176,107 @@ print_version (FILE *file, const char *indent)\n \t   PARAM_VALUE (GGC_MIN_EXPAND), PARAM_VALUE (GGC_MIN_HEAPSIZE));\n }\n \n+#ifdef ASM_COMMENT_START\n+static int\n+print_to_asm_out_file (print_switch_type type, const char * text)\n+{\n+  bool prepend_sep = true;\n+\n+  switch (type)\n+    {\n+    case SWITCH_TYPE_LINE_END:\n+      putc ('\\n', asm_out_file);\n+      return 1;\n+\n+    case SWITCH_TYPE_LINE_START:\n+      fputs (ASM_COMMENT_START, asm_out_file);\n+      return strlen (ASM_COMMENT_START);\n+\n+    case SWITCH_TYPE_DESCRIPTIVE:\n+      if (ASM_COMMENT_START[0] == 0)\n+\tprepend_sep = false;\n+      /* Drop through.  */\n+    case SWITCH_TYPE_PASSED:\n+    case SWITCH_TYPE_ENABLED:\n+      if (prepend_sep)\n+\tfputc (' ', asm_out_file);\n+      fprintf (asm_out_file, text);\n+      /* No need to return the length here as\n+\t print_single_switch has already done it.  */\n+      return 0;\n+\n+    default:\n+      return -1;\n+    }\n+}\n+#endif\n+\n+static int\n+print_to_stderr (print_switch_type type, const char * text)\n+{\n+  switch (type)\n+    {\n+    case SWITCH_TYPE_LINE_END:\n+      putc ('\\n', stderr);\n+      return 1;\n+\n+    case SWITCH_TYPE_LINE_START:\n+      return 0;\n+      \n+    case SWITCH_TYPE_PASSED:\n+    case SWITCH_TYPE_ENABLED:\n+      fputc (' ', stderr);\n+      /* Drop through.  */\n+\n+    case SWITCH_TYPE_DESCRIPTIVE:\n+      fprintf (stderr, text);\n+      /* No need to return the length here as\n+\t print_single_switch has already done it.  */\n+      return 0;\n+\n+    default:\n+      return -1;\n+    }\n+}\n+\n /* Print an option value and return the adjusted position in the line.\n-   ??? We don't handle error returns from fprintf (disk full); presumably\n-   other code will catch a disk full though.  */\n+   ??? print_fn doesn't handle errors, eg disk full; presumably other\n+   code will catch a disk full though.  */\n \n static int\n-print_single_switch (FILE *file, int pos, int max,\n-\t\t     const char *indent, const char *sep, const char *term,\n-\t\t     const char *type, const char *name)\n+print_single_switch (print_switch_fn_type print_fn,\n+\t\t     int pos,\n+\t\t     print_switch_type type,\n+\t\t     const char * text)\n {\n-  /* The ultrix fprintf returns 0 on success, so compute the result we want\n-     here since we need it for the following test.  */\n-  int len = strlen (sep) + strlen (type) + strlen (name);\n+  /* The ultrix fprintf returns 0 on success, so compute the result\n+     we want here since we need it for the following test.  The +1\n+     is for the seperator character that will probably be emitted.  */\n+  int len = strlen (text) + 1;\n \n   if (pos != 0\n-      && pos + len > max)\n+      && pos + len > MAX_LINE)\n     {\n-      fprintf (file, \"%s\", term);\n+      print_fn (SWITCH_TYPE_LINE_END, NULL);\n       pos = 0;\n     }\n+\n   if (pos == 0)\n-    {\n-      fprintf (file, \"%s\", indent);\n-      pos = strlen (indent);\n-    }\n-  fprintf (file, \"%s%s%s\", sep, type, name);\n-  pos += len;\n-  return pos;\n+    pos += print_fn (SWITCH_TYPE_LINE_START, NULL);\n+\n+  print_fn (type, text);\n+  return pos + len;\n }\n \n-/* Print active target switches to FILE.\n+/* Print active target switches using PRINT_FN.\n    POS is the current cursor position and MAX is the size of a \"line\".\n    Each line begins with INDENT and ends with TERM.\n    Each switch is separated from the next by SEP.  */\n \n static void\n-print_switch_values (FILE *file, int pos, int max,\n-\t\t     const char *indent, const char *sep, const char *term)\n+print_switch_values (print_switch_fn_type print_fn)\n {\n+  int pos = 0;\n   size_t j;\n   const char **p;\n \n@@ -1228,45 +1285,50 @@ print_switch_values (FILE *file, int pos, int max,\n   randomize ();\n \n   /* Print the options as passed.  */\n-  pos = print_single_switch (file, pos, max, indent, *indent ? \" \" : \"\", term,\n-\t\t\t     _(\"options passed: \"), \"\");\n+  pos = print_single_switch (print_fn, pos,\n+\t\t\t     SWITCH_TYPE_DESCRIPTIVE, _(\"options passed: \"));\n \n   for (p = &save_argv[1]; *p != NULL; p++)\n-    if (**p == '-')\n-      {\n-\t/* Ignore these.  */\n-\tif (strcmp (*p, \"-o\") == 0)\n-\t  {\n-\t    if (p[1] != NULL)\n-\t      p++;\n+    {\n+      if (**p == '-')\n+\t{\n+\t  /* Ignore these.  */\n+\t  if (strcmp (*p, \"-o\") == 0\n+\t      || strcmp (*p, \"-dumpbase\") == 0\n+\t      || strcmp (*p, \"-auxbase\") == 0)\n+\t    {\n+\t      if (p[1] != NULL)\n+\t\tp++;\n+\t      continue;\n+\t    }\n+\n+\t  if (strcmp (*p, \"-quiet\") == 0\n+\t      || strcmp (*p, \"-version\") == 0)\n \t    continue;\n-\t  }\n-\tif (strcmp (*p, \"-quiet\") == 0)\n-\t  continue;\n-\tif (strcmp (*p, \"-version\") == 0)\n-\t  continue;\n-\tif ((*p)[1] == 'd')\n-\t  continue;\n-\n-\tpos = print_single_switch (file, pos, max, indent, sep, term, *p, \"\");\n-      }\n+\n+\t  if ((*p)[1] == 'd')\n+\t    continue;\n+\t}\n+\n+      pos = print_single_switch (print_fn, pos, SWITCH_TYPE_PASSED, *p);\n+    }\n+\n   if (pos > 0)\n-    fprintf (file, \"%s\", term);\n+    print_fn (SWITCH_TYPE_LINE_END, NULL);\n \n   /* Print the -f and -m options that have been enabled.\n      We don't handle language specific options but printing argv\n      should suffice.  */\n-\n-  pos = print_single_switch (file, 0, max, indent, *indent ? \" \" : \"\", term,\n-\t\t\t     _(\"options enabled: \"), \"\");\n+  pos = print_single_switch (print_fn, 0,\n+\t\t\t     SWITCH_TYPE_DESCRIPTIVE, _(\"options enabled: \"));\n \n   for (j = 0; j < cl_options_count; j++)\n     if ((cl_options[j].flags & CL_REPORT)\n \t&& option_enabled (j) > 0)\n-      pos = print_single_switch (file, pos, max, indent, sep, term,\n-\t\t\t\t \"\", cl_options[j].opt_text);\n+      pos = print_single_switch (print_fn, pos,\n+\t\t\t\t SWITCH_TYPE_ENABLED, cl_options[j].opt_text);\n \n-  fprintf (file, \"%s\", term);\n+  print_fn (SWITCH_TYPE_LINE_END, NULL);\n }\n \n /* Open assembly code output file.  Do this even if -fsyntax-only is\n@@ -1284,6 +1346,7 @@ init_asm_output (const char *name)\n \t{\n \t  int len = strlen (dump_base_name);\n \t  char *dumpname = XNEWVEC (char, len + 6);\n+\n \t  memcpy (dumpname, dump_base_name, len + 1);\n \t  strip_off_ending (dumpname, len);\n \t  strcat (dumpname, \".s\");\n@@ -1301,15 +1364,30 @@ init_asm_output (const char *name)\n     {\n       targetm.asm_out.file_start ();\n \n+      if (flag_record_gcc_switches)\n+\t{\n+\t  if (targetm.asm_out.record_gcc_switches)\n+\t    {\n+\t      /* Let the target know that we are about to start recording.  */\n+\t      targetm.asm_out.record_gcc_switches (SWITCH_TYPE_DESCRIPTIVE,\n+\t\t\t\t\t\t   NULL);\n+\t      /* Now record the switches.  */\n+\t      print_switch_values (targetm.asm_out.record_gcc_switches);\n+\t      /* Let the target know that the recording is over.  */\n+\t      targetm.asm_out.record_gcc_switches (SWITCH_TYPE_DESCRIPTIVE,\n+\t\t\t\t\t\t   NULL);\n+\t    }\n+\t  else\n+\t    inform (\"-frecord-gcc-switches is not supported by the current target\");\n+\t}\n+\n #ifdef ASM_COMMENT_START\n       if (flag_verbose_asm)\n \t{\n-\t  /* Print the list of options in effect.  */\n+\t  /* Print the list of switches in effect\n+\t     into the assembler file as comments.  */\n \t  print_version (asm_out_file, ASM_COMMENT_START);\n-\t  print_switch_values (asm_out_file, 0, MAX_LINE,\n-\t\t\t       ASM_COMMENT_START, \" \", \"\\n\");\n-\t  /* Add a blank line here so it appears in assembler output but not\n-\t     screen output.  */\n+\t  print_switch_values (print_to_asm_out_file);\n \t  fprintf (asm_out_file, \"\\n\");\n \t}\n #endif\n@@ -1677,7 +1755,7 @@ process_options (void)\n     {\n       print_version (stderr, \"\");\n       if (! quiet_flag)\n-\tprint_switch_values (stderr, 0, MAX_LINE, \"\", \" \", \"\\n\");\n+\tprint_switch_values (print_to_stderr);\n     }\n \n   if (flag_syntax_only)"}, {"sha": "1e7af0e5b5d70391651a904fa21bdd2b72c80ff6", "filename": "gcc/varasm.c", "status": "modified", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0d9d0ddb643a4e9372e3bb1104ce299a200df45/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0d9d0ddb643a4e9372e3bb1104ce299a200df45/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=e0d9d0ddb643a4e9372e3bb1104ce299a200df45", "patch": "@@ -6226,4 +6226,105 @@ output_object_blocks (void)\n   htab_traverse (object_block_htab, output_object_block_htab, NULL);\n }\n \n+/* This function provides a possible implementation of the\n+   TARGET_ASM_RECORD_GCC_SWITCHES target hook for ELF targets.  When triggered\n+   by -frecord-gcc-switches it creates a new mergeable, string section in the\n+   assembler output file called TARGET_ASM_RECORD_GCC_SWITCHES_SECTION which\n+   contains the switches in ASCII format.\n+\n+   FIXME: This code does not correctly handle double quote characters\n+   that appear inside strings, (it strips them rather than preserving them).\n+   FIXME: ASM_OUTPUT_ASCII, as defined in config/elfos.h will not emit NUL\n+   characters - instead it treats them as sub-string separators.  Since\n+   we want to emit NUL strings terminators into the object file we have to use\n+   ASM_OUTPUT_SKIP.  */\n+\n+int\n+elf_record_gcc_switches (print_switch_type type, const char * name)\n+{\n+  static char buffer[1024];\n+\n+  /* This variable is used as part of a simplistic heuristic to detect\n+     command line switches which take an argument:\n+\n+       \"If a command line option does not start with a dash then\n+        it is an argument for the previous command line option.\"\n+\n+     This fails in the case of the command line option which is the name\n+     of the file to compile, but otherwise it is pretty reasonable.  */\n+  static bool previous_name_held_back = FALSE;\n+\n+  switch (type)\n+    {\n+    case SWITCH_TYPE_PASSED:\n+      if (* name != '-')\n+\t{\n+\t  if (previous_name_held_back)\n+\t    {\n+\t      unsigned int len = strlen (buffer);\n+\n+\t      snprintf (buffer + len, sizeof buffer - len, \" %s\", name);\n+\t      ASM_OUTPUT_ASCII (asm_out_file, buffer, strlen (buffer));\n+\t      ASM_OUTPUT_SKIP (asm_out_file, 1L);\n+\t      previous_name_held_back = FALSE;\n+\t    }\n+\t  else\n+\t    {\n+\t      strncpy (buffer, name, sizeof buffer);\n+\t      ASM_OUTPUT_ASCII (asm_out_file, buffer, strlen (buffer));\n+\t      ASM_OUTPUT_SKIP (asm_out_file, 1L);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  if (previous_name_held_back)\n+\t    {\n+\t      ASM_OUTPUT_ASCII (asm_out_file, buffer, strlen (buffer));\n+\t      ASM_OUTPUT_SKIP (asm_out_file, 1L);\n+\t    }\n+\n+\t  strncpy (buffer, name, sizeof buffer);\n+\t  previous_name_held_back = TRUE;\n+\t}\n+      break;\n+\n+    case SWITCH_TYPE_DESCRIPTIVE:\n+      if (name == NULL)\n+\t{\n+\t  /* Distinguish between invocations where name is NULL.  */\n+\t  static bool started = false;\n+\n+\t  if (started)\n+\t    {\n+\t      if (previous_name_held_back)\n+\t\t{\n+\t\t  ASM_OUTPUT_ASCII (asm_out_file, buffer, strlen (buffer));\n+\t\t  ASM_OUTPUT_SKIP (asm_out_file, 1L);\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      section * sec;\n+\n+\t      sec = get_section (targetm.asm_out.record_gcc_switches_section,\n+\t\t\t\t SECTION_DEBUG\n+\t\t\t\t | SECTION_MERGE\n+\t\t\t\t | SECTION_STRINGS\n+\t\t\t\t | (SECTION_ENTSIZE & 1),\n+\t\t\t\t NULL);\n+\t      switch_to_section (sec);\n+\t      started = true;\n+\t    }\n+\t}\n+\n+    default:\n+      break;\n+    }\n+\n+  /* The return value is currently ignored by the caller, but must be 0.\n+     For -fverbose-asm the return value would be the number of characters\n+     emitted into the assembler file.  */\n+  return 0;\n+}\n+\n #include \"gt-varasm.h\""}]}