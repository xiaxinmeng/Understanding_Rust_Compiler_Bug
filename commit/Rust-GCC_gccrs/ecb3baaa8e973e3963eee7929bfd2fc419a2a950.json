{"sha": "ecb3baaa8e973e3963eee7929bfd2fc419a2a950", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWNiM2JhYWE4ZTk3M2UzOTYzZWVlNzkyOWJmZDJmYzQxOWEyYTk1MA==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2011-01-08T09:38:13Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2011-01-08T09:38:13Z"}, "message": "re PR fortran/45777 (Alias analysis broken for arrays where LHS or RHS is a component ref)\n\n2011-01-08  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/45777\n\t* symbol.c (gfc_symbols_could_alias):  Strip gfc_ prefix,\n\tmake static and move in front of its only caller, to ...\n\t* trans-array.c (symbols_could_alias): ... here.\n\tPass information about pointer and target status as\n\targuments.  Allocatable arrays don't alias anything\n\tunless they have the POINTER attribute.\n\t(gfc_could_be_alias):  Keep track of pointer and target\n\tstatus when following references.  Also check if typespecs\n\tof components match those of other components or symbols.\n\n2011-01-08  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/45777\n\t* gfortran.dg/dependency_39.f90:  New test.\n\nFrom-SVN: r168596", "tree": {"sha": "bc81017a641e2c952741cf0d7f440a5956a9f883", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bc81017a641e2c952741cf0d7f440a5956a9f883"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ecb3baaa8e973e3963eee7929bfd2fc419a2a950", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ecb3baaa8e973e3963eee7929bfd2fc419a2a950", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ecb3baaa8e973e3963eee7929bfd2fc419a2a950", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ecb3baaa8e973e3963eee7929bfd2fc419a2a950/comments", "author": null, "committer": null, "parents": [{"sha": "72e961c86a4da21028ac032ae03d7158af69a1af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72e961c86a4da21028ac032ae03d7158af69a1af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72e961c86a4da21028ac032ae03d7158af69a1af"}], "stats": {"total": 187, "additions": 146, "deletions": 41}, "files": [{"sha": "f313fd8e2dfe3f3ac13a57792bf0fd8b0e670a3e", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecb3baaa8e973e3963eee7929bfd2fc419a2a950/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecb3baaa8e973e3963eee7929bfd2fc419a2a950/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=ecb3baaa8e973e3963eee7929bfd2fc419a2a950", "patch": "@@ -1,3 +1,16 @@\n+2011-01-08  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/45777\n+\t* symbol.c (gfc_symbols_could_alias):  Strip gfc_ prefix,\n+\tmake static and move in front of its only caller, to ...\n+\t* trans-array.c (symbols_could_alias): ... here.\n+\tPass information about pointer and target status as\n+\targuments.  Allocatable arrays don't alias anything\n+\tunless they have the POINTER attribute.\n+\t(gfc_could_be_alias):  Keep track of pointer and target\n+\tstatus when following references.  Also check if typespecs\n+\tof components match those of other components or symbols.\n+\n 2011-01-07  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/41580"}, {"sha": "1444ee8ef65d929209a38fe2ad5f3c2ff9b85abb", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecb3baaa8e973e3963eee7929bfd2fc419a2a950/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecb3baaa8e973e3963eee7929bfd2fc419a2a950/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=ecb3baaa8e973e3963eee7929bfd2fc419a2a950", "patch": "@@ -2561,8 +2561,6 @@ int gfc_get_sym_tree (const char *, gfc_namespace *, gfc_symtree **, bool);\n int gfc_get_ha_symbol (const char *, gfc_symbol **);\n int gfc_get_ha_sym_tree (const char *, gfc_symtree **);\n \n-int gfc_symbols_could_alias (gfc_symbol *, gfc_symbol *);\n-\n void gfc_undo_symbols (void);\n void gfc_commit_symbols (void);\n void gfc_commit_symbol (gfc_symbol *);"}, {"sha": "1a385b5f7bb6239f67b3dfa7669fd8f0926ff016", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecb3baaa8e973e3963eee7929bfd2fc419a2a950/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecb3baaa8e973e3963eee7929bfd2fc419a2a950/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=ecb3baaa8e973e3963eee7929bfd2fc419a2a950", "patch": "@@ -2813,41 +2813,6 @@ gfc_get_ha_symbol (const char *name, gfc_symbol **result)\n   return i;\n }\n \n-/* Return true if both symbols could refer to the same data object.  Does\n-   not take account of aliasing due to equivalence statements.  */\n-\n-int\n-gfc_symbols_could_alias (gfc_symbol *lsym, gfc_symbol *rsym)\n-{\n-  /* Aliasing isn't possible if the symbols have different base types.  */\n-  if (gfc_compare_types (&lsym->ts, &rsym->ts) == 0)\n-    return 0;\n-\n-  /* Pointers can point to other pointers, target objects and allocatable\n-     objects.  Two allocatable objects cannot share the same storage.  */\n-  if (lsym->attr.pointer\n-      && (rsym->attr.pointer || rsym->attr.allocatable || rsym->attr.target))\n-    return 1;\n-  if (lsym->attr.target && rsym->attr.pointer)\n-    return 1;\n-  if (lsym->attr.allocatable && rsym->attr.pointer)\n-    return 1;\n-\n-  /* Special case: Argument association, cf. F90 12.4.1.6, F2003 12.4.1.7\n-     and F2008 12.5.2.13 items 3b and 4b. The pointer case (a) is already\n-     checked above.  */\n-  if (lsym->attr.target && rsym->attr.target\n-      && ((lsym->attr.dummy && !lsym->attr.contiguous\n-\t   && (!lsym->attr.dimension || lsym->as->type == AS_ASSUMED_SHAPE))\n-\t  || (rsym->attr.dummy && !rsym->attr.contiguous\n-\t      && (!rsym->attr.dimension\n-\t\t  || rsym->as->type == AS_ASSUMED_SHAPE))))\n-    return 1;\n-\n-  return 0;\n-}\n-\n-\n /* Undoes all the changes made to symbols in the current statement.\n    This subroutine is made simpler due to the fact that attributes are\n    never removed once added.  */"}, {"sha": "b95dd90a35414c93ad19ea99a1fb574a9a5bfee1", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 91, "deletions": 4, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecb3baaa8e973e3963eee7929bfd2fc419a2a950/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecb3baaa8e973e3963eee7929bfd2fc419a2a950/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=ecb3baaa8e973e3963eee7929bfd2fc419a2a950", "patch": "@@ -3449,6 +3449,37 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n     }\n }\n \n+/* Return true if both symbols could refer to the same data object.  Does\n+   not take account of aliasing due to equivalence statements.  */\n+\n+static int\n+symbols_could_alias (gfc_symbol *lsym, gfc_symbol *rsym, bool lsym_pointer,\n+\t\t     bool lsym_target, bool rsym_pointer, bool rsym_target)\n+{\n+  /* Aliasing isn't possible if the symbols have different base types.  */\n+  if (gfc_compare_types (&lsym->ts, &rsym->ts) == 0)\n+    return 0;\n+\n+  /* Pointers can point to other pointers and target objects.  */\n+\n+  if ((lsym_pointer && (rsym_pointer || rsym_target))\n+      || (rsym_pointer && (lsym_pointer || lsym_target)))\n+    return 1;\n+\n+  /* Special case: Argument association, cf. F90 12.4.1.6, F2003 12.4.1.7\n+     and F2008 12.5.2.13 items 3b and 4b. The pointer case (a) is already\n+     checked above.  */\n+  if (lsym_target && rsym_target\n+      && ((lsym->attr.dummy && !lsym->attr.contiguous\n+\t   && (!lsym->attr.dimension || lsym->as->type == AS_ASSUMED_SHAPE))\n+\t  || (rsym->attr.dummy && !rsym->attr.contiguous\n+\t      && (!rsym->attr.dimension\n+\t\t  || rsym->as->type == AS_ASSUMED_SHAPE))))\n+    return 1;\n+\n+  return 0;\n+}\n+\n \n /* Return true if the two SS could be aliased, i.e. both point to the same data\n    object.  */\n@@ -3461,10 +3492,18 @@ gfc_could_be_alias (gfc_ss * lss, gfc_ss * rss)\n   gfc_ref *rref;\n   gfc_symbol *lsym;\n   gfc_symbol *rsym;\n+  bool lsym_pointer, lsym_target, rsym_pointer, rsym_target;\n \n   lsym = lss->expr->symtree->n.sym;\n   rsym = rss->expr->symtree->n.sym;\n-  if (gfc_symbols_could_alias (lsym, rsym))\n+\n+  lsym_pointer = lsym->attr.pointer;\n+  lsym_target = lsym->attr.target;\n+  rsym_pointer = rsym->attr.pointer;\n+  rsym_target = rsym->attr.target;\n+\n+  if (symbols_could_alias (lsym, rsym, lsym_pointer, lsym_target,\n+\t\t\t   rsym_pointer, rsym_target))\n     return 1;\n \n   if (rsym->ts.type != BT_DERIVED && rsym->ts.type != BT_CLASS\n@@ -3479,27 +3518,75 @@ gfc_could_be_alias (gfc_ss * lss, gfc_ss * rss)\n       if (lref->type != REF_COMPONENT)\n \tcontinue;\n \n-      if (gfc_symbols_could_alias (lref->u.c.sym, rsym))\n+      lsym_pointer = lsym_pointer || lref->u.c.sym->attr.pointer;\n+      lsym_target  = lsym_target  || lref->u.c.sym->attr.target;\n+\n+      if (symbols_could_alias (lref->u.c.sym, rsym, lsym_pointer, lsym_target,\n+\t\t\t       rsym_pointer, rsym_target))\n \treturn 1;\n \n+      if ((lsym_pointer && (rsym_pointer || rsym_target))\n+\t  || (rsym_pointer && (lsym_pointer || lsym_target)))\n+\t{\n+\t  if (gfc_compare_types (&lref->u.c.component->ts,\n+\t\t\t\t &rsym->ts))\n+\t    return 1;\n+\t}\n+\n       for (rref = rss->expr->ref; rref != rss->data.info.ref;\n \t   rref = rref->next)\n \t{\n \t  if (rref->type != REF_COMPONENT)\n \t    continue;\n \n-\t  if (gfc_symbols_could_alias (lref->u.c.sym, rref->u.c.sym))\n+\t  rsym_pointer = rsym_pointer || rref->u.c.sym->attr.pointer;\n+\t  rsym_target  = lsym_target  || rref->u.c.sym->attr.target;\n+\n+\t  if (symbols_could_alias (lref->u.c.sym, rref->u.c.sym,\n+\t\t\t\t   lsym_pointer, lsym_target,\n+\t\t\t\t   rsym_pointer, rsym_target))\n \t    return 1;\n+\n+\t  if ((lsym_pointer && (rsym_pointer || rsym_target))\n+\t      || (rsym_pointer && (lsym_pointer || lsym_target)))\n+\t    {\n+\t      if (gfc_compare_types (&lref->u.c.component->ts,\n+\t\t\t\t     &rref->u.c.sym->ts))\n+\t\treturn 1;\n+\t      if (gfc_compare_types (&lref->u.c.sym->ts,\n+\t\t\t\t     &rref->u.c.component->ts))\n+\t\treturn 1;\n+\t      if (gfc_compare_types (&lref->u.c.component->ts,\n+\t\t\t\t     &rref->u.c.component->ts))\n+\t\treturn 1;\n+\t    }\n \t}\n     }\n \n+  lsym_pointer = lsym->attr.pointer;\n+  lsym_target = lsym->attr.target;\n+  lsym_pointer = lsym->attr.pointer;\n+  lsym_target = lsym->attr.target;\n+\n   for (rref = rss->expr->ref; rref != rss->data.info.ref; rref = rref->next)\n     {\n       if (rref->type != REF_COMPONENT)\n \tbreak;\n \n-      if (gfc_symbols_could_alias (rref->u.c.sym, lsym))\n+      rsym_pointer = rsym_pointer || rref->u.c.sym->attr.pointer;\n+      rsym_target  = lsym_target  || rref->u.c.sym->attr.target;\n+\n+      if (symbols_could_alias (rref->u.c.sym, lsym,\n+\t\t\t       lsym_pointer, lsym_target,\n+\t\t\t       rsym_pointer, rsym_target))\n \treturn 1;\n+\n+      if ((lsym_pointer && (rsym_pointer || rsym_target))\n+\t  || (rsym_pointer && (lsym_pointer || lsym_target)))\n+\t{\n+\t  if (gfc_compare_types (&lsym->ts, &rref->u.c.component->ts))\n+\t    return 1;\n+\t}\n     }\n \n   return 0;"}, {"sha": "5cb1143b13901da954eb443a74178212b13fef66", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecb3baaa8e973e3963eee7929bfd2fc419a2a950/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecb3baaa8e973e3963eee7929bfd2fc419a2a950/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ecb3baaa8e973e3963eee7929bfd2fc419a2a950", "patch": "@@ -1,3 +1,8 @@\n+2011-01-08  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/45777\n+\t* gfortran.dg/dependency_39.f90:  New test.\n+\n 2011-01-07  Jan Hubicka  <jh@suse.cz>\n \n \tGet builtins tests ready for linker plugin."}, {"sha": "68c48a4dc817df6c6bc70bb4c8c38d450ce204ab", "filename": "gcc/testsuite/gfortran.dg/dependency_39.f90", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecb3baaa8e973e3963eee7929bfd2fc419a2a950/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependency_39.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecb3baaa8e973e3963eee7929bfd2fc419a2a950/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependency_39.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdependency_39.f90?ref=ecb3baaa8e973e3963eee7929bfd2fc419a2a950", "patch": "@@ -0,0 +1,37 @@\n+! { dg-do run }\n+! PR 45777 - component ref aliases when both are pointers\n+module m1\n+  type t1\n+     integer, dimension(:), allocatable :: data\n+  end type t1\n+contains\n+  subroutine s1(t,d)\n+    integer, dimension(:), pointer :: d\n+    type(t1), pointer :: t\n+    d(1:5)=t%data(3:7)\n+  end subroutine s1\n+  subroutine s2(d,t)\n+    integer, dimension(:), pointer :: d\n+    type(t1), pointer :: t\n+    t%data(3:7) = d(1:5)\n+  end subroutine s2\n+end module m1\n+\n+program main\n+  use m1\n+  type(t1), pointer :: t\n+  integer, dimension(:), pointer :: d\n+  allocate(t)\n+  allocate(t%data(10))\n+  t%data=(/(i,i=1,10)/)\n+  d=>t%data(5:9)\n+  call s1(t,d)\n+  if (any(d.ne.(/3,4,5,6,7/))) call abort()\n+  t%data=(/(i,i=1,10)/)\n+  d=>t%data(1:5)\n+  call s2(d,t)\n+  if (any(t%data.ne.(/1,2,1,2,3,4,5,8,9,10/))) call abort\n+  deallocate(t%data)\n+  deallocate(t)\n+end program main\n+! { dg-final { cleanup-modules \"m1\" } }"}]}