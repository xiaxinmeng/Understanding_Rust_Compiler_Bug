{"sha": "355142da80432e9a21bc56a8f796636967ea5622", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzU1MTQyZGE4MDQzMmU5YTIxYmM1NmE4Zjc5NjYzNjk2N2VhNTYyMg==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1995-04-05T20:34:58Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1995-04-05T20:34:58Z"}, "message": "Moved 'high-level' error functions from cpperror.c to cpplib.c.\n\nFrom-SVN: r9315", "tree": {"sha": "3f19a4877af3ab4b37d888910ed26b0c9b498db6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3f19a4877af3ab4b37d888910ed26b0c9b498db6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/355142da80432e9a21bc56a8f796636967ea5622", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/355142da80432e9a21bc56a8f796636967ea5622", "html_url": "https://github.com/Rust-GCC/gccrs/commit/355142da80432e9a21bc56a8f796636967ea5622", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/355142da80432e9a21bc56a8f796636967ea5622/comments", "author": null, "committer": null, "parents": [{"sha": "784ea0746840571732d9ed23bc8c3b88034ebe27", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/784ea0746840571732d9ed23bc8c3b88034ebe27", "html_url": "https://github.com/Rust-GCC/gccrs/commit/784ea0746840571732d9ed23bc8c3b88034ebe27"}], "stats": {"total": 448, "additions": 230, "deletions": 218}, "files": [{"sha": "33e2c01188d81906319e916713c50b0282df912a", "filename": "gcc/cpperror.c", "status": "modified", "additions": 10, "deletions": 216, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355142da80432e9a21bc56a8f796636967ea5622/gcc%2Fcpperror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355142da80432e9a21bc56a8f796636967ea5622/gcc%2Fcpperror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpperror.c?ref=355142da80432e9a21bc56a8f796636967ea5622", "patch": "@@ -25,27 +25,6 @@ Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n #include \"cpplib.h\"\n #include <stdio.h>\n \n-/* This defines \"errno\" properly for VMS, and gives us EACCES. */\n-#include <errno.h>\n-#ifndef errno\n-extern int errno;\n-#endif\n-\n-#ifndef VMS\n-#ifndef HAVE_STRERROR\n-extern int sys_nerr;\n-#if defined(bsd4_4)\n-extern const char *const sys_errlist[];\n-#else\n-extern char *sys_errlist[];\n-#endif\n-#else\t/* HAVE_STERRROR */\n-char *strerror ();\n-#endif\n-#else\t/* VMS */\n-char *strerror (int,...);\n-#endif\n-\n /* Print the file names and line numbers of the #include\n    commands which led to the current file.  */\n \n@@ -102,147 +81,25 @@ cpp_print_containing_files (pfile)\n }\n \n void\n-cpp_print_file_and_line (pfile)\n-     cpp_reader *pfile;\n-{\n-  cpp_buffer *ip = cpp_file_buffer (pfile);\n-\n-  if (ip != NULL)\n-    {\n-      long line, col;\n-      cpp_buf_line_and_col (ip, &line, &col);\n-      if (pfile->show_column)\n-\tfprintf (stderr, \"%s:%d:%d: \", ip->nominal_fname, line, col);\n-      else\n-\tfprintf (stderr, \"%s:%d: \", ip->nominal_fname, line);\n-    }\n-}\n-\n-void\n-cpp_error (pfile, msg, arg1, arg2, arg3)\n-     cpp_reader *pfile;\n-     char *msg;\n-     char *arg1, *arg2, *arg3;\n-{\n-  cpp_print_containing_files (pfile);\n-  cpp_print_file_and_line (pfile);\n-  fprintf (stderr, msg, arg1, arg2, arg3);\n-  fprintf (stderr, \"\\n\");\n-  pfile->errors++;\n-}\n-\n-/* Print error message but don't count it.  */\n-\n-void\n-cpp_warning (pfile, msg, arg1, arg2, arg3)\n-     cpp_reader *pfile;\n-     char *msg;\n-     char *arg1, *arg2, *arg3;\n-{\n-  if (CPP_OPTIONS (pfile)->inhibit_warnings)\n-    return;\n-\n-  if (CPP_OPTIONS (pfile)->warnings_are_errors)\n-    pfile->errors++;\n-\n-  cpp_print_containing_files (pfile);\n-  cpp_print_file_and_line (pfile);\n-  fprintf (stderr, \"warning: \");\n-  fprintf (stderr, msg, arg1, arg2, arg3);\n-  fprintf (stderr, \"\\n\");\n-}\n-\n-void\n-cpp_error_with_line (pfile, line, msg, arg1, arg2, arg3)\n-     cpp_reader *pfile;\n-     int line;\n-     char *msg;\n-     char *arg1, *arg2, *arg3;\n-{\n-  int i;\n-  cpp_buffer *ip = cpp_file_buffer (pfile);\n-\n-  cpp_print_containing_files (pfile);\n-\n-  if (ip != NULL)\n-    fprintf (stderr, \"%s:%d: \", ip->nominal_fname, line);\n-\n-  fprintf (stderr, msg, arg1, arg2, arg3);\n-  fprintf (stderr, \"\\n\");\n-  pfile->errors++;\n-}\n-\n-void\n-cpp_warning_with_line (pfile, line, msg, arg1, arg2, arg3)\n-     cpp_reader *pfile;\n-     int line;\n-     char *msg;\n-     char *arg1, *arg2, *arg3;\n-{\n-  int i;\n-  cpp_buffer *ip;\n-\n-  if (CPP_OPTIONS (pfile)->inhibit_warnings)\n-    return;\n-\n-  if (CPP_OPTIONS (pfile)->warnings_are_errors)\n-    pfile->errors++;\n-\n-  cpp_print_containing_files (pfile);\n-\n-  ip = cpp_file_buffer (pfile);\n-\n-  if (ip != NULL)\n-    fprintf (stderr, \"%s:%d: \", ip->nominal_fname, line);\n-  fprintf (stderr, \"warning: \");\n-  fprintf (stderr, msg, arg1, arg2, arg3);\n-  fprintf (stderr, \"\\n\");\n-}\n-\n-/* Print an error message and maybe count it.  */\n-\n-void\n-cpp_pedwarn (pfile, msg, arg1, arg2, arg3)\n+cpp_file_line_for_message (pfile, filename, line, column)\n      cpp_reader *pfile;\n-     char *msg;\n-     char *arg1, *arg2, *arg3;\n-{\n-  if (CPP_OPTIONS (pfile)->pedantic_errors)\n-    cpp_error (pfile, msg, arg1, arg2, arg3);\n-  else\n-    cpp_warning (pfile, msg, arg1, arg2, arg3);\n-}\n-\n-void\n-cpp_pedwarn_with_line (pfile, line, msg, arg1, arg2, arg3)\n-     cpp_reader *pfile;\n-     int line;\n-     char *msg;\n-     char *arg1, *arg2, *arg3;\n+     char *filename;\n+     int line, column;\n {\n-  if (CPP_OPTIONS (pfile)->pedantic_errors)\n-    cpp_error_with_line (pfile, line, msg, arg1, arg2, arg3);\n+  if (column > 0)\n+    fprintf (stderr, \"%s:%d:%d: \", filename, line, column);\n   else\n-    cpp_warning_with_line (pfile, line, msg, arg1, arg2, arg3);\n+    fprintf (stderr, \"%s:%d: \", filename, line);\n }\n \n-/* Report a warning (or an error if pedantic_errors)\n-   giving specified file name and line number, not current.  */\n-\n-void\n-cpp_pedwarn_with_file_and_line (pfile, file, line, msg, arg1, arg2, arg3)\n+/* IS_ERROR is 1 for error, 0 for warning */\n+void cpp_message (pfile, is_error, msg, arg1, arg2, arg3)\n+     int is_error;\n      cpp_reader *pfile;\n-     char *file;\n-     int line;\n      char *msg;\n      char *arg1, *arg2, *arg3;\n {\n-  if (!CPP_OPTIONS (pfile)->pedantic_errors\n-      && CPP_OPTIONS (pfile)->inhibit_warnings)\n-    return;\n-  if (file != NULL)\n-    fprintf (stderr, \"%s:%d: \", file, line);\n-  if (CPP_OPTIONS (pfile)->pedantic_errors)\n+  if (is_error)\n     pfile->errors++;\n   else\n     fprintf (stderr, \"warning: \");\n@@ -261,69 +118,6 @@ fatal (str, arg)\n }\n \n \f\n-/*\n- * my_strerror - return the descriptive text associated with an `errno' code.\n- */\n-\n-char *\n-my_strerror (errnum)\n-     int errnum;\n-{\n-  char *result;\n-\n-#ifndef VMS\n-#ifndef HAVE_STRERROR\n-  result = (char *) ((errnum < sys_nerr) ? sys_errlist[errnum] : 0);\n-#else\n-  result = strerror (errnum);\n-#endif\n-#else\t/* VMS */\n-  /* VAXCRTL's strerror() takes an optional second argument, which only\n-     matters when the first argument is EVMSERR.  However, it's simplest\n-     just to pass it unconditionally.  `vaxc$errno' is declared in\n-     <errno.h>, and maintained by the library in parallel with `errno'.\n-     We assume that caller's `errnum' either matches the last setting of\n-     `errno' by the library or else does not have the value `EVMSERR'.  */\n-\n-  result = strerror (errnum, vaxc$errno);\n-#endif\n-\n-  if (!result)\n-    result = \"undocumented I/O error\";\n-\n-  return result;\n-}\n-\n-/* Error including a message from `errno'.  */\n-\n-void\n-cpp_error_from_errno (pfile, name)\n-     cpp_reader *pfile;\n-     char *name;\n-{\n-  int i;\n-  cpp_buffer *ip = cpp_file_buffer (pfile);\n-\n-  cpp_print_containing_files (pfile);\n-\n-  if (ip != NULL)\n-    fprintf (stderr, \"%s:%d: \", ip->nominal_fname, ip->lineno);\n-\n-  fprintf (stderr, \"%s: %s\\n\", name, my_strerror (errno));\n-\n-  pfile->errors++;\n-}\n-\n-void\n-cpp_perror_with_name (pfile, name)\n-     cpp_reader *pfile;\n-     char *name;\n-{\n-  fprintf (stderr, \"%s: \", progname);\n-  fprintf (stderr, \"%s: %s\\n\", name, my_strerror (errno));\n-  pfile->errors++;\n-}\n-\n void\n cpp_pfatal_with_name (pfile, name)\n      cpp_reader *pfile;"}, {"sha": "6589f80650b2476a276d4c62faf3e0a743da746d", "filename": "gcc/cpplib.c", "status": "modified", "additions": 220, "deletions": 2, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/355142da80432e9a21bc56a8f796636967ea5622/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/355142da80432e9a21bc56a8f796636967ea5622/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=355142da80432e9a21bc56a8f796636967ea5622", "patch": "@@ -4723,7 +4723,9 @@ cpp_get_token (pfile)\n \t      return CPP_COMMENT;\n \t    }\n \t  else if (CPP_TRADITIONAL (pfile))\n-\t    goto get_next;\n+\t    {\n+\t      return CPP_COMMENT;\n+\t    }\n \t  else\n \t    {\n #if 0\n@@ -7289,6 +7291,222 @@ cpp_read_check_assertion (pfile)\n   CPP_ADJUST_WRITTEN (pfile, - name_length);  /* pop */\n   return result;\n }\n+\f\n+void\n+cpp_print_file_and_line (pfile)\n+     cpp_reader *pfile;\n+{\n+  cpp_buffer *ip = cpp_file_buffer (pfile);\n+\n+  if (ip != NULL)\n+    {\n+      long line, col;\n+      cpp_buf_line_and_col (ip, &line, &col);\n+      cpp_file_line_for_message (pfile, ip->nominal_fname,\n+\t\t\t\t line, pfile->show_column ? col : -1);\n+    }\n+}\n+\n+void\n+cpp_error (pfile, msg, arg1, arg2, arg3)\n+     cpp_reader *pfile;\n+     char *msg;\n+     char *arg1, *arg2, *arg3;\n+{\n+  cpp_print_containing_files (pfile);\n+  cpp_print_file_and_line (pfile);\n+  cpp_message (pfile, 1, msg, arg1, arg2, arg3);\n+}\n+\n+/* Print error message but don't count it.  */\n+\n+void\n+cpp_warning (pfile, msg, arg1, arg2, arg3)\n+     cpp_reader *pfile;\n+     char *msg;\n+     char *arg1, *arg2, *arg3;\n+{\n+  if (CPP_OPTIONS (pfile)->inhibit_warnings)\n+    return;\n+\n+  if (CPP_OPTIONS (pfile)->warnings_are_errors)\n+    pfile->errors++;\n+\n+  cpp_print_containing_files (pfile);\n+  cpp_print_file_and_line (pfile);\n+  cpp_message (pfile, 0, msg, arg1, arg2, arg3);\n+}\n+\n+/* Print an error message and maybe count it.  */\n+\n+void\n+cpp_pedwarn (pfile, msg, arg1, arg2, arg3)\n+     cpp_reader *pfile;\n+     char *msg;\n+     char *arg1, *arg2, *arg3;\n+{\n+  if (CPP_OPTIONS (pfile)->pedantic_errors)\n+    cpp_error (pfile, msg, arg1, arg2, arg3);\n+  else\n+    cpp_warning (pfile, msg, arg1, arg2, arg3);\n+}\n+\n+void\n+cpp_error_with_line (pfile, line, msg, arg1, arg2, arg3)\n+     cpp_reader *pfile;\n+     int line;\n+     char *msg;\n+     char *arg1, *arg2, *arg3;\n+{\n+  int i;\n+  cpp_buffer *ip = cpp_file_buffer (pfile);\n+\n+  cpp_print_containing_files (pfile);\n+\n+  if (ip != NULL)\n+    cpp_file_line_for_message (pfile, ip->nominal_fname, line, -1);\n+\n+  cpp_message (pfile, 1, msg, arg1, arg2, arg3);\n+}\n+\n+void\n+cpp_warning_with_line (pfile, line, msg, arg1, arg2, arg3)\n+     cpp_reader *pfile;\n+     int line;\n+     char *msg;\n+     char *arg1, *arg2, *arg3;\n+{\n+  int i;\n+  cpp_buffer *ip;\n+\n+  if (CPP_OPTIONS (pfile)->inhibit_warnings)\n+    return;\n+\n+  if (CPP_OPTIONS (pfile)->warnings_are_errors)\n+    pfile->errors++;\n+\n+  cpp_print_containing_files (pfile);\n+\n+  ip = cpp_file_buffer (pfile);\n+\n+  if (ip != NULL)\n+    cpp_file_line_for_message (pfile, ip->nominal_fname, line, -1);\n+\n+  cpp_message (pfile, 0, msg, arg1, arg2, arg3);\n+}\n+\n+void\n+cpp_pedwarn_with_line (pfile, line, msg, arg1, arg2, arg3)\n+     cpp_reader *pfile;\n+     int line;\n+     char *msg;\n+     char *arg1, *arg2, *arg3;\n+{\n+  if (CPP_OPTIONS (pfile)->pedantic_errors)\n+    cpp_error_with_line (pfile, line, msg, arg1, arg2, arg3);\n+  else\n+    cpp_warning_with_line (pfile, line, msg, arg1, arg2, arg3);\n+}\n+\n+/* Report a warning (or an error if pedantic_errors)\n+   giving specified file name and line number, not current.  */\n+\n+void\n+cpp_pedwarn_with_file_and_line (pfile, file, line, msg, arg1, arg2, arg3)\n+     cpp_reader *pfile;\n+     char *file;\n+     int line;\n+     char *msg;\n+     char *arg1, *arg2, *arg3;\n+{\n+  if (!CPP_OPTIONS (pfile)->pedantic_errors\n+      && CPP_OPTIONS (pfile)->inhibit_warnings)\n+    return;\n+  if (file != NULL)\n+    cpp_file_line_for_message (pfile, file, line, -1);\n+  cpp_message (pfile, CPP_OPTIONS (pfile)->pedantic_errors,\n+\t       msg, arg1, arg2, arg3);\n+}\n+\n+/* This defines \"errno\" properly for VMS, and gives us EACCES. */\n+#include <errno.h>\n+#ifndef errno\n+extern int errno;\n+#endif\n+\n+#ifndef VMS\n+#ifndef HAVE_STRERROR\n+extern int sys_nerr;\n+#if defined(bsd4_4)\n+extern const char *const sys_errlist[];\n+#else\n+extern char *sys_errlist[];\n+#endif\n+#else\t/* HAVE_STERRROR */\n+char *strerror ();\n+#endif\n+#else\t/* VMS */\n+char *strerror (int,...);\n+#endif\n+\n+/*\n+ * my_strerror - return the descriptive text associated with an `errno' code.\n+ */\n+\n+char *\n+my_strerror (errnum)\n+     int errnum;\n+{\n+  char *result;\n+\n+#ifndef VMS\n+#ifndef HAVE_STRERROR\n+  result = (char *) ((errnum < sys_nerr) ? sys_errlist[errnum] : 0);\n+#else\n+  result = strerror (errnum);\n+#endif\n+#else\t/* VMS */\n+  /* VAXCRTL's strerror() takes an optional second argument, which only\n+     matters when the first argument is EVMSERR.  However, it's simplest\n+     just to pass it unconditionally.  `vaxc$errno' is declared in\n+     <errno.h>, and maintained by the library in parallel with `errno'.\n+     We assume that caller's `errnum' either matches the last setting of\n+     `errno' by the library or else does not have the value `EVMSERR'.  */\n+\n+  result = strerror (errnum, vaxc$errno);\n+#endif\n+\n+  if (!result)\n+    result = \"undocumented I/O error\";\n+\n+  return result;\n+}\n+\n+/* Error including a message from `errno'.  */\n+\n+void\n+cpp_error_from_errno (pfile, name)\n+     cpp_reader *pfile;\n+     char *name;\n+{\n+  int i;\n+  cpp_buffer *ip = cpp_file_buffer (pfile);\n+\n+  cpp_print_containing_files (pfile);\n+\n+  if (ip != NULL)\n+    cpp_file_line_for_message (pfile, ip->nominal_fname, ip->lineno, -1);\n+\n+  cpp_message (pfile, 1, \"%s: %s\\n\", name, my_strerror (errno));\n+}\n+\n+void\n+cpp_perror_with_name (pfile, name)\n+     cpp_reader *pfile;\n+     char *name;\n+{\n+  cpp_message (pfile, 1, \"%s: %s: %s\\n\", progname, name, my_strerror (errno));\n+}\n \n /* TODO:\n  * No pre-compiled header file support.\n@@ -7306,7 +7524,7 @@ cpp_read_check_assertion (pfile)\n  *\n  * Support -dM flag (dump_all_macros).\n  *\n- * -include should be made to returns results incrementally.\n+ * -include should be made to return results incrementally.\n  *    (current implementation only works when cpp is used as main program)\n  *\n  */"}]}