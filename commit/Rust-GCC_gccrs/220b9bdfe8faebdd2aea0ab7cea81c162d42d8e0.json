{"sha": "220b9bdfe8faebdd2aea0ab7cea81c162d42d8e0", "node_id": "C_kwDOANBUbNoAKDIyMGI5YmRmZThmYWViZGQyYWVhMGFiN2NlYTgxYzE2MmQ0MmQ4ZTA", "commit": {"author": {"name": "Francois-Xavier Coudert", "email": "fxcoudert@gmail.com", "date": "2021-12-19T23:45:31Z"}, "committer": {"name": "Francois-Xavier Coudert", "email": "fxcoudert@gmail.com", "date": "2021-12-19T23:49:10Z"}, "message": "Fortran: add support for IEEE intrinsics on aarch64 non-glibc targets\n\nThis enables IEEE support on the upcoming aarch64-apple-darwin target,\nand has been tested for some time in an external port.\n\nlibgfortran/ChangeLog:\n\n\t* configure.host: Add aarch64-apple-darwin support.\n\t* config/fpu-aarch64.h: New file.", "tree": {"sha": "95a0f488d0b3bb7cfd55048f833c890eec18a611", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/95a0f488d0b3bb7cfd55048f833c890eec18a611"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/220b9bdfe8faebdd2aea0ab7cea81c162d42d8e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/220b9bdfe8faebdd2aea0ab7cea81c162d42d8e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/220b9bdfe8faebdd2aea0ab7cea81c162d42d8e0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/220b9bdfe8faebdd2aea0ab7cea81c162d42d8e0/comments", "author": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "78fe0f23c73bf3b5d49dd2992d445bcc5db5a55c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78fe0f23c73bf3b5d49dd2992d445bcc5db5a55c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78fe0f23c73bf3b5d49dd2992d445bcc5db5a55c"}], "stats": {"total": 349, "additions": 346, "deletions": 3}, "files": [{"sha": "0746f42938afcbe92c8caa0f675d9503db01b076", "filename": "libgfortran/config/fpu-aarch64.h", "status": "added", "additions": 331, "deletions": 0, "changes": 331, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/220b9bdfe8faebdd2aea0ab7cea81c162d42d8e0/libgfortran%2Fconfig%2Ffpu-aarch64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/220b9bdfe8faebdd2aea0ab7cea81c162d42d8e0/libgfortran%2Fconfig%2Ffpu-aarch64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fconfig%2Ffpu-aarch64.h?ref=220b9bdfe8faebdd2aea0ab7cea81c162d42d8e0", "patch": "@@ -0,0 +1,331 @@\n+/* FPU-related code for aarch64.\n+   Copyright (C) 2020 Free Software Foundation, Inc.\n+   Contributed by Francois-Xavier Coudert <fxcoudert@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+\n+/* Rounding mask and modes */\n+\n+#define FPCR_RM_MASK  0x0c00000\n+#define FE_TONEAREST  0x0000000\n+#define FE_UPWARD     0x0400000\n+#define FE_DOWNWARD   0x0800000\n+#define FE_TOWARDZERO 0x0c00000\n+#define FE_MAP_FZ     0x1000000\n+\n+/* Exceptions */\n+\n+#define FE_INVALID\t1\n+#define FE_DIVBYZERO\t2\n+#define FE_OVERFLOW\t4\n+#define FE_UNDERFLOW\t8\n+#define FE_INEXACT\t16\n+\n+#define FE_ALL_EXCEPT (FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW | FE_INEXACT)\n+#define FE_EXCEPT_SHIFT\t8\n+\n+\n+\n+/* This structure corresponds to the layout of the block\n+   written by FSTENV.  */\n+struct fenv\n+{\n+  unsigned int __fpcr;\n+  unsigned int __fpsr;\n+};\n+\n+/* Check we can actually store the FPU state in the allocated size.  */\n+_Static_assert (sizeof(struct fenv) <= (size_t) GFC_FPE_STATE_BUFFER_SIZE,\n+\t\t\"GFC_FPE_STATE_BUFFER_SIZE is too small\");\n+\n+\n+\n+void\n+set_fpu (void)\n+{\n+  if (options.fpe & GFC_FPE_DENORMAL)\n+    estr_write (\"Fortran runtime warning: Floating point 'denormal operand' \"\n+\t        \"exception not supported.\\n\");\n+\n+  set_fpu_trap_exceptions (options.fpe, 0);\n+}\n+\n+\n+int\n+get_fpu_trap_exceptions (void)\n+{\n+  unsigned int fpcr, exceptions;\n+  int res = 0;\n+\n+  fpcr = __builtin_aarch64_get_fpcr();\n+  exceptions = (fpcr >> FE_EXCEPT_SHIFT) & FE_ALL_EXCEPT;\n+\n+  if (exceptions & FE_INVALID) res |= GFC_FPE_INVALID;\n+  if (exceptions & FE_DIVBYZERO) res |= GFC_FPE_ZERO;\n+  if (exceptions & FE_OVERFLOW) res |= GFC_FPE_OVERFLOW;\n+  if (exceptions & FE_UNDERFLOW) res |= GFC_FPE_UNDERFLOW;\n+  if (exceptions & FE_INEXACT) res |= GFC_FPE_INEXACT;\n+\n+  return res;\n+}\n+\n+\n+void set_fpu_trap_exceptions (int trap, int notrap)\n+{\n+  unsigned int mode_set = 0, mode_clr = 0;\n+  unsigned int fpsr, fpsr_new;\n+  unsigned int fpcr, fpcr_new;\n+\n+  if (trap & GFC_FPE_INVALID)\n+    mode_set |= FE_INVALID;\n+  if (notrap & GFC_FPE_INVALID)\n+    mode_clr |= FE_INVALID;\n+\n+  if (trap & GFC_FPE_ZERO)\n+    mode_set |= FE_DIVBYZERO;\n+  if (notrap & GFC_FPE_ZERO)\n+    mode_clr |= FE_DIVBYZERO;\n+\n+  if (trap & GFC_FPE_OVERFLOW)\n+    mode_set |= FE_OVERFLOW;\n+  if (notrap & GFC_FPE_OVERFLOW)\n+    mode_clr |= FE_OVERFLOW;\n+\n+  if (trap & GFC_FPE_UNDERFLOW)\n+    mode_set |= FE_UNDERFLOW;\n+  if (notrap & GFC_FPE_UNDERFLOW)\n+    mode_clr |= FE_UNDERFLOW;\n+\n+  if (trap & GFC_FPE_INEXACT)\n+    mode_set |= FE_INEXACT;\n+  if (notrap & GFC_FPE_INEXACT)\n+    mode_clr |= FE_INEXACT;\n+\n+  /* Clear stalled exception flags.  */\n+  fpsr = __builtin_aarch64_get_fpsr();\n+  fpsr_new = fpsr & ~FE_ALL_EXCEPT;\n+  if (fpsr_new != fpsr)\n+    __builtin_aarch64_set_fpsr(fpsr_new);\n+\n+  fpcr_new = fpcr = __builtin_aarch64_get_fpcr();\n+  fpcr_new |= (mode_set << FE_EXCEPT_SHIFT);\n+  fpcr_new &= ~(mode_clr << FE_EXCEPT_SHIFT);\n+\n+  if (fpcr_new != fpcr)\n+    __builtin_aarch64_set_fpcr(fpcr_new);\n+}\n+\n+\n+int\n+support_fpu_flag (int flag)\n+{\n+  if (flag & GFC_FPE_DENORMAL)\n+    return 0;\n+\n+  return 1;\n+}\n+\n+\n+int\n+support_fpu_trap (int flag)\n+{\n+  if (flag & GFC_FPE_DENORMAL)\n+    return 0;\n+\n+  return 1;\n+}\n+\n+\n+int\n+get_fpu_except_flags (void)\n+{\n+  int result;\n+  unsigned int fpsr;\n+\n+  result = 0;\n+  fpsr = __builtin_aarch64_get_fpsr() & FE_ALL_EXCEPT;\n+\n+  if (fpsr & FE_INVALID)\n+    result |= GFC_FPE_INVALID;\n+  if (fpsr & FE_DIVBYZERO)\n+    result |= GFC_FPE_ZERO;\n+  if (fpsr & FE_OVERFLOW)\n+    result |= GFC_FPE_OVERFLOW;\n+  if (fpsr & FE_UNDERFLOW)\n+    result |= GFC_FPE_UNDERFLOW;\n+  if (fpsr & FE_INEXACT)\n+    result |= GFC_FPE_INEXACT;\n+\n+  return result;\n+}\n+\n+\n+void\n+set_fpu_except_flags (int set, int clear)\n+{\n+  unsigned int exc_set = 0, exc_clr = 0;\n+  unsigned int fpsr, fpsr_new;\n+\n+  if (set & GFC_FPE_INVALID)\n+    exc_set |= FE_INVALID;\n+  else if (clear & GFC_FPE_INVALID)\n+    exc_clr |= FE_INVALID;\n+\n+  if (set & GFC_FPE_ZERO)\n+    exc_set |= FE_DIVBYZERO;\n+  else if (clear & GFC_FPE_ZERO)\n+    exc_clr |= FE_DIVBYZERO;\n+\n+  if (set & GFC_FPE_OVERFLOW)\n+    exc_set |= FE_OVERFLOW;\n+  else if (clear & GFC_FPE_OVERFLOW)\n+    exc_clr |= FE_OVERFLOW;\n+\n+  if (set & GFC_FPE_UNDERFLOW)\n+    exc_set |= FE_UNDERFLOW;\n+  else if (clear & GFC_FPE_UNDERFLOW)\n+    exc_clr |= FE_UNDERFLOW;\n+\n+  if (set & GFC_FPE_INEXACT)\n+    exc_set |= FE_INEXACT;\n+  else if (clear & GFC_FPE_INEXACT)\n+    exc_clr |= FE_INEXACT;\n+\n+  fpsr_new = fpsr = __builtin_aarch64_get_fpsr();\n+  fpsr_new &= ~exc_clr;\n+  fpsr_new |= exc_set;\n+\n+  if (fpsr_new != fpsr)\n+    __builtin_aarch64_set_fpsr(fpsr_new);\n+}\n+\n+\n+void\n+get_fpu_state (void *state)\n+{\n+  struct fenv *envp = state;\n+  envp->__fpcr = __builtin_aarch64_get_fpcr();\n+  envp->__fpsr = __builtin_aarch64_get_fpsr();\n+}\n+\n+\n+void\n+set_fpu_state (void *state)\n+{\n+  struct fenv *envp = state;\n+  __builtin_aarch64_set_fpcr(envp->__fpcr);\n+  __builtin_aarch64_set_fpsr(envp->__fpsr);\n+}\n+\n+\n+int\n+get_fpu_rounding_mode (void)\n+{\n+  unsigned int fpcr = __builtin_aarch64_get_fpcr();\n+  fpcr &= FPCR_RM_MASK;\n+\n+  switch (fpcr)\n+    {\n+      case FE_TONEAREST:\n+        return GFC_FPE_TONEAREST;\n+      case FE_UPWARD:\n+        return GFC_FPE_UPWARD;\n+      case FE_DOWNWARD:\n+        return GFC_FPE_DOWNWARD;\n+      case FE_TOWARDZERO:\n+        return GFC_FPE_TOWARDZERO;\n+      default:\n+        return 0; /* Should be unreachable.  */\n+    }\n+}\n+\n+\n+void\n+set_fpu_rounding_mode (int round)\n+{\n+  unsigned int fpcr, round_mode;\n+\n+  switch (round)\n+    {\n+    case GFC_FPE_TONEAREST:\n+      round_mode = FE_TONEAREST;\n+      break;\n+    case GFC_FPE_UPWARD:\n+      round_mode = FE_UPWARD;\n+      break;\n+    case GFC_FPE_DOWNWARD:\n+      round_mode = FE_DOWNWARD;\n+      break;\n+    case GFC_FPE_TOWARDZERO:\n+      round_mode = FE_TOWARDZERO;\n+      break;\n+    default:\n+      return; /* Should be unreachable.  */\n+    }\n+\n+  fpcr = __builtin_aarch64_get_fpcr();\n+\n+  /* Only set FPCR if requested mode is different from current.  */\n+  round_mode = (fpcr ^ round_mode) & FPCR_RM_MASK;\n+  if (round_mode != 0)\n+    __builtin_aarch64_set_fpcr(fpcr ^ round_mode);\n+}\n+\n+\n+int\n+support_fpu_rounding_mode (int mode __attribute__((unused)))\n+{\n+  return 1;\n+}\n+\n+\n+int\n+support_fpu_underflow_control (int kind __attribute__((unused)))\n+{\n+  /* Not supported for binary128.  */\n+  return (kind == 4 || kind == 8) ? 1 : 0;\n+}\n+\n+\n+int\n+get_fpu_underflow_mode (void)\n+{\n+  unsigned int fpcr = __builtin_aarch64_get_fpcr();\n+\n+  /* Return 0 for abrupt underflow (flush to zero), 1 for gradual underflow.  */\n+  return (fpcr & FE_MAP_FZ) ? 0 : 1;\n+}\n+\n+\n+void\n+set_fpu_underflow_mode (int gradual __attribute__((unused)))\n+{\n+  unsigned int fpcr = __builtin_aarch64_get_fpcr();\n+\n+  if (gradual)\n+    fpcr &= ~FE_MAP_FZ;\n+  else\n+    fpcr |= FE_MAP_FZ;\n+\n+  __builtin_aarch64_set_fpcr(fpcr);\n+}"}, {"sha": "3d6c2db7772e1caafc421e5498f580376f6fbe26", "filename": "libgfortran/configure.host", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/220b9bdfe8faebdd2aea0ab7cea81c162d42d8e0/libgfortran%2Fconfigure.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/220b9bdfe8faebdd2aea0ab7cea81c162d42d8e0/libgfortran%2Fconfigure.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fconfigure.host?ref=220b9bdfe8faebdd2aea0ab7cea81c162d42d8e0", "patch": "@@ -39,17 +39,29 @@ if test \"x${have_feenableexcept}\" = \"xyes\"; then\n   ieee_support='yes'\n fi\n \n-# x86 asm should be used instead of glibc, since glibc doesn't support\n-# the x86 denormal exception.\n case \"${host_cpu}\" in\n+\n+  # x86 asm should be used instead of glibc, since glibc doesn't support\n+  # the x86 denormal exception.\n   i?86 | x86_64)\n     if test \"x${have_soft_float}\" = \"xyes\"; then\n       fpu_host='fpu-generic'\n+      ieee_support='no'\n     else\n       fpu_host='fpu-387'\n+      ieee_support='yes'\n     fi\n-    ieee_support='yes'\n     ;;\n+\n+  # use asm on aarch64-darwin\n+  aarch64)\n+    case \"${host_os}\" in\n+      darwin*)\n+        fpu_host='fpu-aarch64'\n+        ieee_support='yes'\n+        ;;\n+    esac\n+\n esac\n \n # Some targets require additional compiler options for NaN/Inf."}]}