{"sha": "8fd966327ae16a820143f589dd48b8c17a6f6ae5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGZkOTY2MzI3YWUxNmE4MjAxNDNmNTg5ZGQ0OGI4YzE3YTZmNmFlNQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-06-12T22:33:29Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-06-12T22:33:29Z"}, "message": "Tighten LRA test for reloading the inner reg of a paradoxical subreg\n\nThis patch fixes an LRA cycling problem on the attached testcase.\nThe original insn was:\n\n(insn 74 72 76 8 (set (reg:V2DI 287 [ _166 ])\n        (subreg:V2DI (reg/v/f:DI 112 [ d ]) 0)) 1060 {*aarch64_simd_movv2di}\n     (nil))\n\nwhich IRA converted to:\n\n(insn 74 72 580 8 (set (reg:V2DI 287 [ _166 ])\n        (subreg:V2DI (reg/v/f:DI 517 [orig:112 d ] [112]) 0)) 1060 {*aarch64_simd_movv2di}\n     (nil))\n\nafter creating loop allocnos.  It happens that the ALLOCNO_WMODEs for\nboth 112 and 517 were not set to V2DI due to another bug that I'll post\na separate patch for, but we nevertheless got a valid allocation of\nregister 1.\n\nLRA's first try at constraining the instruction gave:\n\n         Choosing alt 5 in insn 74:  (0) ?w  (1) r {*aarch64_simd_movv2di}\n\nat which point all was good.  But LRA later decided it needed\nto spill r517:\n\n    Spill r517 after risky transformations\n\nso the next constraint attempt gave:\n\n         Choosing alt 0 in insn 74:  (0) =w  (1) m {*aarch64_simd_movv2di}\n\nwhich was still good.  Then during inheritance we had:\n\n      Creating newreg=672 from oldreg=517, assigning class GENERAL_REGS to inheritance r672\n    Original reg change 517->672 (bb8):\n   74: r287:V2DI=r672:DI#0\n    Add inheritance<-original before:\n  939: r672:DI=r517:DI\n\n    Inheritance reuse change 517->672 (bb8):\n  620: r572:DI=r672:DI\n      REG_DEAD r672:DI\n\n    Use smallest class of POINTER_REGS and GENERAL_REGS\n      Creating newreg=673 from oldreg=517, assigning class POINTER_REGS to inheritance r673\n    Original reg change 517->673 (bb8):\n  936: r669:DI=r673:DI\n    Add inheritance<-original before:\n  940: r673:DI=r517:DI\n\n(\"Use smallest class of POINTER_REGS and GENERAL_REGS\" ought to\ngive GENERAL_REGS.  That might be a missed optimisation, and probably\ndue to both classes having the same number of allocatable registers.\nI'll look at that as a follow-on.)\n\nThus LRA created two inheritance registers for r517, one (r673)\nthat included the unallocatable x31 and another (r672) that didn't.\nThe r672 references included the paradoxical subreg in insn 74 but the\nr673 ones didn't.  LRA then allocated x30 to r673, which was a valid\nchoice.\n\nLater LRA decided to \"undo\" the inheritance for insn 620, but because\nof the double inheritance, it got confused as to what the original\nsituation was, and made insn 74 use the other inheritance register\ninstead of r517:\n\n********** Undoing inheritance #2: **********\n\nInherit 11 out of 12 (91.67%)\n   Insn after restoring regs:\n  620: r572:DI=r517:DI\n      REG_DEAD r517:DI\n    Change reload insn:\n   74: r287:V2DI=r673:DI#0       <-------------------\n   Insn after restoring regs:\n  939: r517:DI=r673:DI\n      REG_DEAD r673:DI\n\nThis might be a bug in itself: we should probably look through sets\nof other inheritance pseudos to find the \"real\" origin.\n\nEither way, at this point we had a situation in which r673 was used in an\ninsn whose subreg was larger than the biggest_mode that r673 had when it\nwas allocated.  While x30 was valid for the original biggest_mode, it\nwasn't valid for this subreg use.\n\nThe next attempt to constrain insn 74 was:\n\n        Choosing alt 5 in insn 74:  (0) ?w  (1) r {*aarch64_simd_movv2di}\n      Creating newreg=684, assigning class GENERAL_REGS to r684\n   74: r287:V2DI=r684:V2DI\n    Inserting insn reload before:\n  951: r684:V2DI=r673:DI#0\n\nwhere LRA reloaded the SUBREG rather than the SUBREG_REG.  And it\nthen cycled trying the same thing when reloading the reload (and the\nreload of the reload, etc.).\n\nWhat it should be doing here is reloading the SUBREG_REG instead.\nThere's already code to cope with this case when the paradoxical\nsubreg falls outside the class (which isn't true here, since r673\nis POINTER_REGS and POINTER_REGS includes x31).  But I think we\nshould also test whether LRA is entitled to allocate the spanned\nregisters.  Not doing that seems like a bug regardless of the above\nmissed optimisation and the mix-up undoing inheritance.\n\n2018-05-30  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* lra-constraints.c (simplify_operand_subreg): In the paradoxical\n\tcase, check whether the outer register overlaps an unallocatable\n\tregister, not just whether it fits the required class.\n\ngcc/testsuite/\n\t* g++.dg/torture/aarch64-vect-init-1.C: New test.\n\nFrom-SVN: r261531", "tree": {"sha": "3dd58558d669f2a498d3cf2843c3bade68ea0b1f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3dd58558d669f2a498d3cf2843c3bade68ea0b1f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8fd966327ae16a820143f589dd48b8c17a6f6ae5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fd966327ae16a820143f589dd48b8c17a6f6ae5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8fd966327ae16a820143f589dd48b8c17a6f6ae5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fd966327ae16a820143f589dd48b8c17a6f6ae5/comments", "author": null, "committer": null, "parents": [{"sha": "5284e55987deac1dede0b03f5a27413051c6b02b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5284e55987deac1dede0b03f5a27413051c6b02b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5284e55987deac1dede0b03f5a27413051c6b02b"}], "stats": {"total": 53, "additions": 51, "deletions": 2}, "files": [{"sha": "0cb7cfd91daf1d51540b39549fb20877424f8c2a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fd966327ae16a820143f589dd48b8c17a6f6ae5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fd966327ae16a820143f589dd48b8c17a6f6ae5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8fd966327ae16a820143f589dd48b8c17a6f6ae5", "patch": "@@ -1,3 +1,9 @@\n+2018-06-12  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* lra-constraints.c (simplify_operand_subreg): In the paradoxical\n+\tcase, check whether the outer register overlaps an unallocatable\n+\tregister, not just whether it fits the required class.\n+\n 2018-06-12  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* poly-int.h (can_div_trunc_p): Add new overload in which all values"}, {"sha": "7eeec767445bb1caa7dcac5239bdde1efd42a8b3", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fd966327ae16a820143f589dd48b8c17a6f6ae5/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fd966327ae16a820143f589dd48b8c17a6f6ae5/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=8fd966327ae16a820143f589dd48b8c17a6f6ae5", "patch": "@@ -1722,7 +1722,13 @@ simplify_operand_subreg (int nop, machine_mode reg_mode)\n         (subreg:TI (reg:TI 180 [orig:107 __comp ] [107]) 0)) {*movti_internal_rex64}\n \n      Two reload hard registers will be allocated to reg180 to save TImode data\n-     in LRA_assign.  */\n+     in LRA_assign.\n+\n+     For LRA pseudos this should normally be handled by the biggest_mode\n+     mechanism.  However, it's possible for new uses of an LRA pseudo\n+     to be introduced after we've allocated it, such as when undoing\n+     inheritance, and the allocated register might not then be appropriate\n+     for the new uses.  */\n   else if (REG_P (reg)\n \t   && REGNO (reg) >= FIRST_PSEUDO_REGISTER\n \t   && (hard_regno = lra_get_regno_hard_regno (REGNO (reg))) >= 0\n@@ -1731,7 +1737,9 @@ simplify_operand_subreg (int nop, machine_mode reg_mode)\n \t   && (regclass = lra_get_allocno_class (REGNO (reg)))\n \t   && (type != OP_IN\n \t       || !in_hard_reg_set_p (reg_class_contents[regclass],\n-\t\t\t\t      mode, hard_regno)))\n+\t\t\t\t      mode, hard_regno)\n+\t       || overlaps_hard_reg_set_p (lra_no_alloc_regs,\n+\t\t\t\t\t   mode, hard_regno)))\n     {\n       /* The class will be defined later in curr_insn_transform.  */\n       enum reg_class rclass"}, {"sha": "5f01694b919a3cdc715d7fa74d54b21c6ea86f18", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fd966327ae16a820143f589dd48b8c17a6f6ae5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fd966327ae16a820143f589dd48b8c17a6f6ae5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8fd966327ae16a820143f589dd48b8c17a6f6ae5", "patch": "@@ -1,3 +1,7 @@\n+2018-06-12  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* g++.dg/torture/aarch64-vect-init-1.C: New test.\n+\n 2018-06-12  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* g++.dg/init/delete3.C: New."}, {"sha": "681b71a8269798d843e0990ba3a6415146505cfd", "filename": "gcc/testsuite/g++.dg/torture/aarch64-vect-init-1.C", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fd966327ae16a820143f589dd48b8c17a6f6ae5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Faarch64-vect-init-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fd966327ae16a820143f589dd48b8c17a6f6ae5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Faarch64-vect-init-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Faarch64-vect-init-1.C?ref=8fd966327ae16a820143f589dd48b8c17a6f6ae5", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-mcpu=cortex-a72\" { target aarch64*-*-* } } */\n+\n+class A {\n+public:\n+  unsigned char *fn1();\n+  int fn2();\n+};\n+\n+class B {\n+  A fld1;\n+  int fld2;\n+  void fn3();\n+  unsigned char fld3;\n+};\n+\n+int a;\n+\n+void\n+B::fn3() {\n+  int b = fld1.fn2() / 8;\n+  unsigned char *c = fld1.fn1(), *d = &fld3, *e = c;\n+  for (; a < fld2;)\n+    for (int j = 0; j < b; j++)\n+      *d++ = e[j];\n+  for (; 0 < fld2;)\n+    for (int j = 0; j < b; j++)\n+      e[j] = *d++;\n+  for (; fld2;)\n+    ;\n+}"}]}