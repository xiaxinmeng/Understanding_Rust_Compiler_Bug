{"sha": "1d02ac8371b1d3b31ed029c29fa23fadeca48787", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWQwMmFjODM3MWIxZDNiMzFlZDAyOWMyOWZhMjNmYWRlY2E0ODc4Nw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1999-07-09T12:44:37Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1999-07-09T12:44:37Z"}, "message": "decl2.c (reparse_absdcl_as_casts): Don't warn about old-style casts in system headers or extern \"C\" blocks.\n\n\t* decl2.c (reparse_absdcl_as_casts): Don't warn about old-style\n\tcasts in system headers or extern \"C\" blocks.\n\t* decl2.c (write_virtuals): Deleted declaration.\n\t* cp-tree.h (write_virtuals): Deleted extern declaration.\n\t* class.c (finish_struct_1): Removed #if 0'd code that mentions\n\twrite_virtuals.\n\t* semantics.c (begin_class_definition): Rewrite code to not depend\n\ton write_virtuals.\n\t* lex.c (cp_pragma_interface): New function.\n\t(cp_pragma_implementation): Likewise.\n\t(handle_cp_pragma): Call them.\n\nFrom-SVN: r28045", "tree": {"sha": "ce533478692fb6b5bbf3b4376582f0ed83cc0394", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ce533478692fb6b5bbf3b4376582f0ed83cc0394"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1d02ac8371b1d3b31ed029c29fa23fadeca48787", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d02ac8371b1d3b31ed029c29fa23fadeca48787", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d02ac8371b1d3b31ed029c29fa23fadeca48787", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d02ac8371b1d3b31ed029c29fa23fadeca48787/comments", "author": null, "committer": null, "parents": [{"sha": "6f1b4c42790b1a8083ae217facb58eb3f0cfa819", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f1b4c42790b1a8083ae217facb58eb3f0cfa819", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f1b4c42790b1a8083ae217facb58eb3f0cfa819"}], "stats": {"total": 250, "additions": 117, "deletions": 133}, "files": [{"sha": "ff27a479bafe0c859e4c3379882ee38fb275f671", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d02ac8371b1d3b31ed029c29fa23fadeca48787/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d02ac8371b1d3b31ed029c29fa23fadeca48787/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=1d02ac8371b1d3b31ed029c29fa23fadeca48787", "patch": "@@ -1,10 +1,24 @@\n 1999-07-09  Jason Merrill  <jason@yorick.cygnus.com>\n \n+\t* decl2.c (reparse_absdcl_as_casts): Don't warn about old-style\n+\tcasts in system headers or extern \"C\" blocks.\n+\n \t* pt.c (do_decl_instantiation): Downgrade duplicate instantiation\n \terrors to pedwarn.\n \n 1999-07-09  Michael Tiemann  <tiemann@happy.cygnus.com>\n \n+\t* decl2.c (write_virtuals): Deleted declaration.\n+\t* cp-tree.h (write_virtuals): Deleted extern declaration.\n+\t* class.c (finish_struct_1): Removed #if 0'd code that mentions\n+\twrite_virtuals.\n+\t* semantics.c (begin_class_definition): Rewrite code to not depend\n+\ton write_virtuals.\n+\n+\t* lex.c (cp_pragma_interface): New function.\n+\t(cp_pragma_implementation): Likewise.\n+\t(handle_cp_pragma): Call them.\n+\n \t* typeck.c (comptypes): Simplify C code in look_hard.\n \n \t* xref.c (PALLOC): Use xcalloc, not calloc.\n@@ -25,6 +39,8 @@\n \t* class.c (duplicate_tag_error): Set TYPE_NONCOPIED_PARTS to\n \tNULL_TREE.\n \n+\t* ptree.c (print_lang_type): Added vtable-needs-writing.\n+\n Wed Jul  7 01:26:47 1999  Alexandre Oliva  <oliva@dcc.unicamp.br>\n \n \t* decl2.c (mark_vtable_entries): Fix check for rtti offset."}, {"sha": "4d00dfb547572e712be8ba32d3b17398ff962322", "filename": "gcc/cp/class.c", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d02ac8371b1d3b31ed029c29fa23fadeca48787/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d02ac8371b1d3b31ed029c29fa23fadeca48787/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=1d02ac8371b1d3b31ed029c29fa23fadeca48787", "patch": "@@ -3212,16 +3212,6 @@ finish_struct_1 (t, warn_anon)\n       no_const_asn_ref = 0;\n     }\n \n-#if 0\n-  /* Both of these should be done before now.  */\n-  if (write_virtuals == 3 && CLASSTYPE_INTERFACE_KNOWN (t)\n-      && ! IS_SIGNATURE (t))\n-    {\n-      my_friendly_assert (CLASSTYPE_INTERFACE_ONLY (t) == interface_only, 999);\n-      my_friendly_assert (CLASSTYPE_VTABLE_NEEDS_WRITING (t) == ! interface_only, 999);\n-    }\n-#endif\n-\n   /* The three of these are approximations which may later be\n      modified.  Needed at this point to make add_virtual_function\n      and modify_vtable_entries work.  */"}, {"sha": "cfbe20274f565310609629393ed2a6f35ae0163f", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d02ac8371b1d3b31ed029c29fa23fadeca48787/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d02ac8371b1d3b31ed029c29fa23fadeca48787/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=1d02ac8371b1d3b31ed029c29fa23fadeca48787", "patch": "@@ -490,18 +490,6 @@ extern int warn_old_style_cast;\n \n extern int flag_signed_bitfields;\n \n-/* 3 means write out only virtuals function tables `defined'\n-   in this implementation file.\n-   2 means write out only specific virtual function tables\n-   and give them (C) public access.\n-   1 means write out virtual function tables and give them\n-   (C) public access.\n-   0 means write out virtual function tables and give them\n-   (C) static access (default).\n-   -1 means declare virtual function tables extern.  */\n-\n-extern int write_virtuals;\n-\n /* True for more efficient but incompatible (not fully tested)\n    vtable implementation (using thunks).\n    0 is old behavior; 1 is new behavior.  */"}, {"sha": "d7b17c54ca8ea5983f210be8c472739e98d85f87", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d02ac8371b1d3b31ed029c29fa23fadeca48787/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d02ac8371b1d3b31ed029c29fa23fadeca48787/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=1d02ac8371b1d3b31ed029c29fa23fadeca48787", "patch": "@@ -375,13 +375,6 @@ int flag_detailed_statistics;\n \n int flag_this_is_variable;\n \n-/* 3 means write out only virtuals function tables `defined'\n-   in this implementation file.\n-   0 means write out virtual function tables and give them\n-   (C) static access (default).  */\n-\n-int write_virtuals;\n-\n /* Nonzero means we should attempt to elide constructors when possible.  */\n \n int flag_elide_constructors = 1;\n@@ -3818,7 +3811,8 @@ reparse_absdcl_as_casts (decl, expr)\n       expr = build_c_cast (type, expr);\n     }\n \n-  if (warn_old_style_cast)\n+  if (warn_old_style_cast && ! in_system_header\n+      && current_lang_name != lang_name_c)\n     warning (\"use of old-style cast\");\n \n   return expr;"}, {"sha": "aa4b0ede4482f5436b95db5536f132e2ed2891c6", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 93, "deletions": 93, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d02ac8371b1d3b31ed029c29fa23fadeca48787/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d02ac8371b1d3b31ed029c29fa23fadeca48787/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=1d02ac8371b1d3b31ed029c29fa23fadeca48787", "patch": "@@ -71,6 +71,8 @@ static int set_vardecl_interface_info PROTO((tree *, void *));\n static void store_pending_inline PROTO((tree, struct pending_inline *));\n static void reinit_parse_for_expr PROTO((struct obstack *));\n static int *init_cpp_parse PROTO((void));\n+static void cp_pragma_interface PROTO((char *));\n+static void cp_pragma_implementation PROTO ((char *));\n static int handle_cp_pragma PROTO((const char *));\n #ifdef HANDLE_GENERIC_PRAGMAS\n static int handle_generic_pragma PROTO((int));\n@@ -1136,6 +1138,93 @@ interface_strcmp (s)\n   return 1;\n }\n \n+static void\n+cp_pragma_interface (main_filename)\n+     char *main_filename;\n+{\n+  tree fileinfo \n+    = TIME_IDENTIFIER_FILEINFO (get_time_identifier (input_filename));\n+\n+  if (impl_file_chain == 0)\n+    {\n+      /* If this is zero at this point, then we are\n+\t auto-implementing.  */\n+      if (main_input_filename == 0)\n+\tmain_input_filename = input_filename;\n+\n+#ifdef AUTO_IMPLEMENT\n+      filename = file_name_nondirectory (main_input_filename);\n+      fi = get_time_identifier (filename);\n+      fi = TIME_IDENTIFIER_FILEINFO (fi);\n+      TREE_INT_CST_LOW (fi) = 0;\n+      TREE_INT_CST_HIGH (fi) = 1;\n+      /* Get default.  */\n+      impl_file_chain = (struct impl_files *)permalloc (sizeof (struct impl_files));\n+      impl_file_chain->filename = filename;\n+      impl_file_chain->next = 0;\n+#endif\n+    }\n+\n+  interface_only = interface_strcmp (main_filename);\n+#ifdef MULTIPLE_SYMBOL_SPACES\n+  if (! interface_only)\n+    interface_unknown = 0;\n+#else /* MULTIPLE_SYMBOL_SPACES */\n+  interface_unknown = 0;\n+#endif /* MULTIPLE_SYMBOL_SPACES */\n+  TREE_INT_CST_LOW (fileinfo) = interface_only;\n+  TREE_INT_CST_HIGH (fileinfo) = interface_unknown;\n+}\n+\n+static void\n+cp_pragma_implementation (main_filename)\n+     char *main_filename;\n+{\n+  tree fileinfo \n+    = TIME_IDENTIFIER_FILEINFO (get_time_identifier (input_filename));\n+\n+  if (impl_file_chain)\n+    {\n+      struct impl_files *ifiles = impl_file_chain;\n+      while (ifiles)\n+\t{\n+\t  if (! strcmp (ifiles->filename, main_filename))\n+\t    break;\n+\t  ifiles = ifiles->next;\n+\t}\n+      if (ifiles == 0)\n+\t{\n+\t  ifiles = (struct impl_files*) permalloc (sizeof (struct impl_files));\n+\t  ifiles->filename = main_filename;\n+\t  ifiles->next = impl_file_chain;\n+\t  impl_file_chain = ifiles;\n+\t}\n+    }\n+  else if ((main_input_filename != 0\n+\t    && ! strcmp (main_input_filename, input_filename))\n+\t   || ! strcmp (main_filename, input_filename))\n+    {\n+      impl_file_chain = (struct impl_files*) permalloc (sizeof (struct impl_files));\n+      impl_file_chain->filename = main_filename;\n+      impl_file_chain->next = 0;\n+    }\n+  else\n+    error (\"`#pragma implementation' can only appear at top-level\");\n+  interface_only = 0;\n+#if 1\n+  /* We make this non-zero so that we infer decl linkage\n+     in the impl file only for variables first declared\n+     in the interface file.  */\n+  interface_unknown = 1;\n+#else\n+  /* We make this zero so that templates in the impl\n+     file will be emitted properly.  */\n+  interface_unknown = 0;\n+#endif\n+  TREE_INT_CST_LOW (fileinfo) = interface_only;\n+  TREE_INT_CST_HIGH (fileinfo) = interface_unknown;\n+}\n+\n static int\n set_typedecl_interface_info (t, data)\n      tree *t;\n@@ -2465,15 +2554,6 @@ check_newline ()\n \t    }\n \n \t  main_input_filename = input_filename;\n-\t  if (write_virtuals == 3)\n-\t    {\n-\t      walk_globals (vtable_decl_p,\n-\t\t\t    set_vardecl_interface_info,\n-\t\t\t    /*data=*/0);\n-\t      walk_globals (vtype_decl_p,\n-\t\t\t    set_typedecl_interface_info,\n-\t\t\t    /*data=*/0);\n-\t    }\n \t}\n \n       extract_interface_info ();\n@@ -4804,11 +4884,6 @@ handle_cp_pragma (pname)\n \t  return -1;\n \t}\n \n-      if (write_virtuals != 2)\n-\t{\n-\t  warning (\"use `+e2' option to enable #pragma vtable\");\n-\t  return -1;\n-\t}\n       pending_vtables\n \t= perm_tree_cons (NULL_TREE,\n \t\t\t  get_identifier (TREE_STRING_POINTER (yylval.ttype)),\n@@ -4834,8 +4909,6 @@ handle_cp_pragma (pname)\n     }\n   else if (! strcmp (pname, \"interface\"))\n     {\n-      tree fileinfo \n-\t= TIME_IDENTIFIER_FILEINFO (get_time_identifier (input_filename));\n       char *main_filename = input_filename;\n \n       main_filename = file_name_nondirectory (main_filename);\n@@ -4857,48 +4930,18 @@ handle_cp_pragma (pname)\n       if (token != END_OF_LINE)\n \twarning (\"garbage after `#pragma interface' ignored\");\n \n-      write_virtuals = 3;\n-\n-      if (impl_file_chain == 0)\n-\t{\n-\t  /* If this is zero at this point, then we are\n-\t     auto-implementing.  */\n-\t  if (main_input_filename == 0)\n-\t    main_input_filename = input_filename;\n-\n-#ifdef AUTO_IMPLEMENT\n-\t  filename = file_name_nondirectory (main_input_filename);\n-\t  fi = get_time_identifier (filename);\n-\t  fi = TIME_IDENTIFIER_FILEINFO (fi);\n-\t  TREE_INT_CST_LOW (fi) = 0;\n-\t  TREE_INT_CST_HIGH (fi) = 1;\n-\t  /* Get default.  */\n-\t  impl_file_chain = (struct impl_files *)permalloc (sizeof (struct impl_files));\n-\t  impl_file_chain->filename = filename;\n-\t  impl_file_chain->next = 0;\n-#endif\n-\t}\n-\n-      interface_only = interface_strcmp (main_filename);\n-#ifdef MULTIPLE_SYMBOL_SPACES\n-      if (! interface_only)\n-\tinterface_unknown = 0;\n-#else /* MULTIPLE_SYMBOL_SPACES */\n-      interface_unknown = 0;\n-#endif /* MULTIPLE_SYMBOL_SPACES */\n-      TREE_INT_CST_LOW (fileinfo) = interface_only;\n-      TREE_INT_CST_HIGH (fileinfo) = interface_unknown;\n+      cp_pragma_interface (main_filename);\n \n       return 1;\n     }\n   else if (! strcmp (pname, \"implementation\"))\n     {\n-      tree fileinfo \n-\t= TIME_IDENTIFIER_FILEINFO (get_time_identifier (input_filename));\n       char *main_filename = main_input_filename ? main_input_filename : input_filename;\n \n       main_filename = file_name_nondirectory (main_filename);\n+\n       token = real_yylex ();\n+\n       if (token != END_OF_LINE)\n \t{\n \t  if (token != STRING\n@@ -4914,50 +4957,7 @@ handle_cp_pragma (pname)\n       if (token != END_OF_LINE)\n \twarning (\"garbage after `#pragma implementation' ignored\");\n \n-      if (write_virtuals == 3)\n-\t{\n-\t  struct impl_files *ifiles = impl_file_chain;\n-\t  while (ifiles)\n-\t    {\n-\t      if (! strcmp (ifiles->filename, main_filename))\n-\t\tbreak;\n-\t      ifiles = ifiles->next;\n-\t    }\n-\t  if (ifiles == 0)\n-\t    {\n-\t      ifiles = (struct impl_files*) permalloc (sizeof (struct impl_files));\n-\t      ifiles->filename = main_filename;\n-\t      ifiles->next = impl_file_chain;\n-\t      impl_file_chain = ifiles;\n-\t    }\n-\t}\n-      else if ((main_input_filename != 0\n-\t\t&& ! strcmp (main_input_filename, input_filename))\n-\t       || ! strcmp (input_filename, main_filename))\n-\t{\n-\t  write_virtuals = 3;\n-\t  if (impl_file_chain == 0)\n-\t    {\n-\t      impl_file_chain = (struct impl_files*) permalloc (sizeof (struct impl_files));\n-\t      impl_file_chain->filename = main_filename;\n-\t      impl_file_chain->next = 0;\n-\t    }\n-\t}\n-      else\n-\terror (\"`#pragma implementation' can only appear at top-level\");\n-      interface_only = 0;\n-#if 1\n-      /* We make this non-zero so that we infer decl linkage\n-\t in the impl file only for variables first declared\n-\t in the interface file.  */\n-      interface_unknown = 1;\n-#else\n-      /* We make this zero so that templates in the impl\n-\t file will be emitted properly.  */\n-      interface_unknown = 0;\n-#endif\n-      TREE_INT_CST_LOW (fileinfo) = interface_only;\n-      TREE_INT_CST_HIGH (fileinfo) = interface_unknown;\n+      cp_pragma_implementation (main_filename);\n \n       return 1;\n     }"}, {"sha": "059375b5e270163dd79994193e9102691d571f25", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d02ac8371b1d3b31ed029c29fa23fadeca48787/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d02ac8371b1d3b31ed029c29fa23fadeca48787/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=1d02ac8371b1d3b31ed029c29fa23fadeca48787", "patch": "@@ -1329,16 +1329,12 @@ begin_class_definition (t)\n \t  SET_CLASSTYPE_INTERFACE_UNKNOWN_X\n \t    (t, interface_unknown);\n \t}\n-      \n-      /* Record how to set the access of this class's\n-\t virtual functions.  If write_virtuals == 3, then\n-\t inline virtuals are ``extern inline''.  */\n-      if (write_virtuals == 3)\n-\tneeds_writing = ! CLASSTYPE_INTERFACE_ONLY (t)\n-\t  && CLASSTYPE_INTERFACE_KNOWN (t);\n-      else\n-\tneeds_writing = 1;\n-      CLASSTYPE_VTABLE_NEEDS_WRITING (t) = needs_writing;\n+\n+      /* Only leave this bit clear if we know this\n+\t class is part of an interface-only specification.  */\n+      if (! CLASSTYPE_INTERFACE_KNOWN (t)\n+\t  || ! CLASSTYPE_INTERFACE_ONLY (t))\n+\tCLASSTYPE_VTABLE_NEEDS_WRITING (t) = 1;\n     }\n #if 0\n   tmp = TYPE_IDENTIFIER ($<ttype>0);"}]}