{"sha": "96fcacb7d3047adc23f9f5688927053700476a88", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTZmY2FjYjdkMzA0N2FkYzIzZjlmNTY4ODkyNzA1MzcwMDQ3NmE4OA==", "commit": {"author": {"name": "Maxim Kuvyrkov", "email": "maxim@codesourcery.com", "date": "2008-05-07T08:09:27Z"}, "committer": {"name": "Maxim Kuvyrkov", "email": "mkuvyrkov@gcc.gnu.org", "date": "2008-05-07T08:09:27Z"}, "message": "Cleanup ColdFire scheduling support and add V4 pipeline model.\n\n\t* config/m68k/m68k.md (UNSPEC_TIE): New constant.\n\t(define_attr cpu): Add cfv4 value.\n\t(define_attr type, define_attr type1): Merge into a single 'type'\n\tattribute.  Update all uses.\n\t(define_attr opx_type, define_attr opy_type, define_attr opx_access):\n\tRearrange and update.  Rename value 'reg' to 'Rn', add value 'FPn'.\n\tUpdate all uses.\n\t(define_attr opx_mem, define_attr opy_mem): Remove.\n\t(define_attr op_mem): Clean up, update comment.\n\t(define_attr size): Use specific values instead of general int.\n\t(define_attr guess, define_attr split): Remove.  Update all uses.\n\t(movdf_internal, tstsi_internal, tsthi_internal, tstqi_internal,\n\ttst<mode>_68881, pushexthisi_const, movsi_const0_68000_10,\n\tmovsi_const0_68040_60, movsi_const0, movsi_cf, movstrictqi_cf,\n\tzero_extendhisi2_cf, zero_extendqisi2_cfv4, cfv4_extendhisi2,\n\t68k_extendhisi2, extendqihi2, cfv4_extendqisi2, 68k_extendqisi2,\n\tfloatsi<mode>2_68881, ftrunc<mode>2_68881, ftrunc<mode>2_cf,\n\tfix<mode>qi2_68881, fix<mode>hi2_68881, fix<mode>si2_68881,\n\tadddi_dishl32, addsi3_5200, add<mode>3_floatsi_68881,\n\tadd<mode>3_floathi_68881, add<mode>3_floatqi_68881,\n\tadd<mode>3_68881, add<mode>3_cf, subdi_dishl32, subsi3,\n\tsub<mode>3_floatsi_68881, sub<mode>3_floathi_68881,\n\tsub<mode>3_floatqi_68881, sub<mode>3_68881, sub<mode>3_cf,\n\tmulhi3, mulhisi3, mulhisisi3_s, mulsi3_68020, mulsi3_cf,\n\tumulhisi3, mulhisisi3_z, mul<mode>3_floatsi_68881,\n\tmul<mode>3_floathi_68881, mul<mode>3_floatqi_68881, fmul<mode>3_cf,\n\tdiv<mode>3_cf, sqrt<mode>2_cf, abs<mode>2_cf, clzsi2,\n\tone_cmplsi2_5200, subreghi1ashrdi_const32, ashrsi3, lshrsi3,\n\tbsetmemqi, bsetmemqi_ext, bclrmemqi, bclrmemqi_ext,\n\tbeq, bne, bgt, blt, bordered, bunordered, buneq, bunge, bungt, bunle,\n\tbunlt, bltgt, tablejump_internal, call, non_symbolic_call_value,\n\tsymbolic_call_value_jsr, symbolic_call_value_bsr, link):\n\tUpdate or set attributes.\n\t(stack_tie): New fake instruction.\n\n\t* config/m68k/m68k.h (TUNE_CFV4): New macro.\n\t(m68k_sched_attr_size): Update declaration.\n\t(m68k_sched_attr_type2): Remove.\n\t(m68k_sched_address_bypass_p, m68k_sched_indexed_address_bypass_p):\n\tDeclare new bypass predicates.\n\n\t* config/m68k/m68k.c (m68k_sched_issue_rate,\n\tm68k_sched_first_cycle_multipass_dfa_lookahead): Declare hook\n\timplementations.\n\t(TARGET_SCHED_ISSUE_RATE,\n\tTARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD): Override hooks.\n\t(override_options): Handle scheduling for ColdFire V4 core.\n\t(m68k_expand_prologue): Emit stack_tie.\n\t(enum attr_op_type): Split value 'OP_TYPE_REG' to 'OP_TYPE_RN' and\n\t'OP_TYPE_FPN'.  Update all uses.\n\t(sched_guess_p): Remove.\n\t(sched_address_type): Handle symbolic addresses.\n\t(sched_get_operand): New static function.\n\t(sched_operand_type): Merge into sched_attr_op_type.\n\t(sched_attr_op_type): Handle FP registers, handle quick constants,\n\tupdate.\n\t(m68k_sched_attr_opx_type, m68k_sched_attr_opy_type): Update.\n\t(m68k_sched_attr_size): Update.  Move logic to ...\n\t(sched_get_attr_size_int): New static function.\n\t(sched_get_opxy_mem_type): New static function.\n\t(m68k_sched_attr_op_mem): Update.\n\t(m68k_sched_attr_type2): Remove.\n\t(sched_cfv4_bypass_data): New static variable.\n\t(m68k_sched_adjust_cost): Handle ColdFire V4 bypass.\n\t(m68k_sched_issue_rate): Implement scheduler hook.\n\t(struct _sched_ib: enabled_p): New field.\n\t(m68k_sched_variable_issue): Update.  Handle V4.\n\t(SCHED_DUMP_TODO, SCHED_DUMP_DONE, SCHED_DUMP_NOTHING,\n\tsched_dump_class_func_t, sched_dump_split_class,\n\tsched_dump_dfa_guess_unit_code, sched_dump_dfa_state,\n\tsched_dump_dfa_class, m68k_sched_dump): Remove.\n\t(m68k_sched_first_cycle_multipass_dfa_lookahead): Implement scheduler\n\thook.\n\t(m68k_sched_init_global): Remove statisctics dumping, introduce\n\tsanity check that all instructions have pipeline reservations.  Handle\n\tColdFire V4 core.\n\t(m68k_sched_dfa_pre_advance_cycle, m68k_sched_dfa_post_advance_cycle):\n\tHandle ColdFire V4 core.\n\t(sched_mem_operand_p, sched_get_reg_operand, sched_get_mem_operand):\n\tNew static functions.\n\t(m68k_sched_address_bypass_p): New bypass predicate.\n\t(sched_get_indexed_address_scale): New static function.\n\t(m68k_sched_indexed_address_bypass_p): New bypass predicate.\n\n\t* cf.md: Update comments.\n\t(define_attr type2): Remove.  Use 'type' attribute instead.\n\tUpdate all uses.\n\t(cf_ib): Rename to cfv123_ib.  Update all uses.\n\t(cf_oep): Rename to cfv123_oep.  Update all uses.\n\t(cf_chr): Rename to cfv123_chr.  Update all uses.\n\t(cf_mem): Rename to cfv123_mem.  Update all uses.\n\t(cf_mac): Move to more appropriate place.\n\t(cfv123_guess): New automaton and cpu_unit.\n\t(cfv123_*, cfv12_*, cfv1_*, cfv2_*, cfv3_*): Use type attribute.\n\tUpdate uses of 'size' attribute.  Handle before reload scheduling.\n\t(cfv123_guess): New dummy reservation for unhandled instructions.\n\t(cfv4_*): Pipeline description of ColdFire V4 core.\n\t(ignore): New reservation to handle 'ignore' type.\n\nFrom-SVN: r135033", "tree": {"sha": "f70588bfff0b3c443ce5745fb7846edae048d3b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f70588bfff0b3c443ce5745fb7846edae048d3b9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/96fcacb7d3047adc23f9f5688927053700476a88", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96fcacb7d3047adc23f9f5688927053700476a88", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96fcacb7d3047adc23f9f5688927053700476a88", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96fcacb7d3047adc23f9f5688927053700476a88/comments", "author": null, "committer": null, "parents": [{"sha": "2ee510b4220fe07af99aae860afa178898b12cf7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ee510b4220fe07af99aae860afa178898b12cf7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ee510b4220fe07af99aae860afa178898b12cf7"}], "stats": {"total": 3390, "additions": 2161, "deletions": 1229}, "files": [{"sha": "7679020ed6b19309526505bb49bf5e719349d3ce", "filename": "gcc/ChangeLog", "status": "modified", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96fcacb7d3047adc23f9f5688927053700476a88/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96fcacb7d3047adc23f9f5688927053700476a88/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=96fcacb7d3047adc23f9f5688927053700476a88", "patch": "@@ -1,3 +1,106 @@\n+2008-05-07  Maxim Kuvyrkov  <maxim@codesourcery.com>\n+\n+\tCleanup ColdFire scheduling support and add V4 pipeline model.\n+\n+\t* config/m68k/m68k.md (UNSPEC_TIE): New constant.\n+\t(define_attr cpu): Add cfv4 value.\n+\t(define_attr type, define_attr type1): Merge into a single 'type'\n+\tattribute.  Update all uses.\n+\t(define_attr opx_type, define_attr opy_type, define_attr opx_access):\n+\tRearrange and update.  Rename value 'reg' to 'Rn', add value 'FPn'.\n+\tUpdate all uses.\n+\t(define_attr opx_mem, define_attr opy_mem): Remove.\n+\t(define_attr op_mem): Clean up, update comment.\n+\t(define_attr size): Use specific values instead of general int.\n+\t(define_attr guess, define_attr split): Remove.  Update all uses.\n+\t(movdf_internal, tstsi_internal, tsthi_internal, tstqi_internal,\n+\ttst<mode>_68881, pushexthisi_const, movsi_const0_68000_10,\n+\tmovsi_const0_68040_60, movsi_const0, movsi_cf, movstrictqi_cf,\n+\tzero_extendhisi2_cf, zero_extendqisi2_cfv4, cfv4_extendhisi2,\n+\t68k_extendhisi2, extendqihi2, cfv4_extendqisi2, 68k_extendqisi2,\n+\tfloatsi<mode>2_68881, ftrunc<mode>2_68881, ftrunc<mode>2_cf,\n+\tfix<mode>qi2_68881, fix<mode>hi2_68881, fix<mode>si2_68881,\n+\tadddi_dishl32, addsi3_5200, add<mode>3_floatsi_68881,\n+\tadd<mode>3_floathi_68881, add<mode>3_floatqi_68881,\n+\tadd<mode>3_68881, add<mode>3_cf, subdi_dishl32, subsi3,\n+\tsub<mode>3_floatsi_68881, sub<mode>3_floathi_68881,\n+\tsub<mode>3_floatqi_68881, sub<mode>3_68881, sub<mode>3_cf,\n+\tmulhi3, mulhisi3, mulhisisi3_s, mulsi3_68020, mulsi3_cf,\n+\tumulhisi3, mulhisisi3_z, mul<mode>3_floatsi_68881,\n+\tmul<mode>3_floathi_68881, mul<mode>3_floatqi_68881, fmul<mode>3_cf,\n+\tdiv<mode>3_cf, sqrt<mode>2_cf, abs<mode>2_cf, clzsi2,\n+\tone_cmplsi2_5200, subreghi1ashrdi_const32, ashrsi3, lshrsi3,\n+\tbsetmemqi, bsetmemqi_ext, bclrmemqi, bclrmemqi_ext,\n+\tbeq, bne, bgt, blt, bordered, bunordered, buneq, bunge, bungt, bunle,\n+\tbunlt, bltgt, tablejump_internal, call, non_symbolic_call_value,\n+\tsymbolic_call_value_jsr, symbolic_call_value_bsr, link):\n+\tUpdate or set attributes.\n+\t(stack_tie): New fake instruction.\n+\n+\t* config/m68k/m68k.h (TUNE_CFV4): New macro.\n+\t(m68k_sched_attr_size): Update declaration.\n+\t(m68k_sched_attr_type2): Remove.\n+\t(m68k_sched_address_bypass_p, m68k_sched_indexed_address_bypass_p):\n+\tDeclare new bypass predicates.\n+\n+\t* config/m68k/m68k.c (m68k_sched_issue_rate,\n+\tm68k_sched_first_cycle_multipass_dfa_lookahead): Declare hook\n+\timplementations.\n+\t(TARGET_SCHED_ISSUE_RATE,\n+\tTARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD): Override hooks.\n+\t(override_options): Handle scheduling for ColdFire V4 core.\n+\t(m68k_expand_prologue): Emit stack_tie.\n+\t(enum attr_op_type): Split value 'OP_TYPE_REG' to 'OP_TYPE_RN' and\n+\t'OP_TYPE_FPN'.  Update all uses.\n+\t(sched_guess_p): Remove.\n+\t(sched_address_type): Handle symbolic addresses.\n+\t(sched_get_operand): New static function.\n+\t(sched_operand_type): Merge into sched_attr_op_type.\n+\t(sched_attr_op_type): Handle FP registers, handle quick constants,\n+\tupdate.\n+\t(m68k_sched_attr_opx_type, m68k_sched_attr_opy_type): Update.\n+\t(m68k_sched_attr_size): Update.  Move logic to ...\n+\t(sched_get_attr_size_int): New static function.\n+\t(sched_get_opxy_mem_type): New static function.\n+\t(m68k_sched_attr_op_mem): Update.\n+\t(m68k_sched_attr_type2): Remove.\n+\t(sched_cfv4_bypass_data): New static variable.\n+\t(m68k_sched_adjust_cost): Handle ColdFire V4 bypass.\n+\t(m68k_sched_issue_rate): Implement scheduler hook.\n+\t(struct _sched_ib: enabled_p): New field.\n+\t(m68k_sched_variable_issue): Update.  Handle V4.\n+\t(SCHED_DUMP_TODO, SCHED_DUMP_DONE, SCHED_DUMP_NOTHING,\n+\tsched_dump_class_func_t, sched_dump_split_class,\n+\tsched_dump_dfa_guess_unit_code, sched_dump_dfa_state,\n+\tsched_dump_dfa_class, m68k_sched_dump): Remove.\n+\t(m68k_sched_first_cycle_multipass_dfa_lookahead): Implement scheduler\n+\thook.\n+\t(m68k_sched_init_global): Remove statisctics dumping, introduce\n+\tsanity check that all instructions have pipeline reservations.  Handle\n+\tColdFire V4 core.\n+\t(m68k_sched_dfa_pre_advance_cycle, m68k_sched_dfa_post_advance_cycle):\n+\tHandle ColdFire V4 core.\n+\t(sched_mem_operand_p, sched_get_reg_operand, sched_get_mem_operand):\n+\tNew static functions.\n+\t(m68k_sched_address_bypass_p): New bypass predicate.\n+\t(sched_get_indexed_address_scale): New static function.\n+\t(m68k_sched_indexed_address_bypass_p): New bypass predicate.\n+\n+\t* cf.md: Update comments.\n+\t(define_attr type2): Remove.  Use 'type' attribute instead.\n+\tUpdate all uses.\n+\t(cf_ib): Rename to cfv123_ib.  Update all uses.\n+\t(cf_oep): Rename to cfv123_oep.  Update all uses.\n+\t(cf_chr): Rename to cfv123_chr.  Update all uses.\n+\t(cf_mem): Rename to cfv123_mem.  Update all uses.\n+\t(cf_mac): Move to more appropriate place.\n+\t(cfv123_guess): New automaton and cpu_unit.\n+\t(cfv123_*, cfv12_*, cfv1_*, cfv2_*, cfv3_*): Use type attribute.\n+\tUpdate uses of 'size' attribute.  Handle before reload scheduling.\n+\t(cfv123_guess): New dummy reservation for unhandled instructions.\n+\t(cfv4_*): Pipeline description of ColdFire V4 core.\n+\t(ignore): New reservation to handle 'ignore' type.\n+\n 2008-05-07  Ian Lance Taylor  <iant@google.com>\n \n \tPR middle-end/36013"}, {"sha": "7c4b37a75b42bf74e53088077c41bbe69bc52cd5", "filename": "gcc/config/m68k/cf.md", "status": "modified", "additions": 1324, "deletions": 598, "changes": 1922, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96fcacb7d3047adc23f9f5688927053700476a88/gcc%2Fconfig%2Fm68k%2Fcf.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96fcacb7d3047adc23f9f5688927053700476a88/gcc%2Fconfig%2Fm68k%2Fcf.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fcf.md?ref=96fcacb7d3047adc23f9f5688927053700476a88", "patch": "@@ -1,6 +1,6 @@\n-;; ColdFire V1, V2 and V3 DFA description.\n+;; ColdFire V1, V2, V3 and V4/V4e DFA description.\n ;; Copyright (C) 2007 Free Software Foundation, Inc.\n-;; Contributed by CodeSourcery Inc.\n+;; Contributed by CodeSourcery Inc., www.codesourcery.com\n ;;\n ;; This file is part of GCC.\n ;;\n@@ -19,24 +19,12 @@\n ;; the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n ;; Boston, MA 02110-1301, USA.\n \n-;; Intruction types recognized by DFA.\n-;; This attribute correspond to type1 attribute with the exceptions below.\n-;; omove - optimized move.  All explicit loads on cfv1 and long explicit\n-;;         loads on cfv2 execute one cycle faster then they should.\n-;;         Supposedly, that is due to combined instruction decoding\n-;;         and address generation phases.\n-;; ??? To let genattrtab live, implement this attribute in C.\n-(define_attr \"type2\"\n-  \"alu, alu_reg, bcc, bra, call, jmp, lea, mul_l, mul_w, omove, pea,\n-   rts, unlk, unknown\"\n-  (symbol_ref \"m68k_sched_attr_type2 (insn)\"))\n-\n ;; Instruction Buffer\n-(define_automaton \"cf_ib\")\n+(define_automaton \"cfv123_ib\")\n \n ;; These pseudo units are used to model instruction buffer of ColdFire cores.\n ;; Instruction of size N can be issued only when cf_ib_wN is available.\n-(define_cpu_unit \"cf_ib_w1, cf_ib_w2, cf_ib_w3\" \"cf_ib\")\n+(define_cpu_unit \"cf_ib_w1, cf_ib_w2, cf_ib_w3\" \"cfv123_ib\")\n \n ;; Instruction occupies 1 word in the instruction buffer.\n (define_reservation \"cf_ib1\" \"cf_ib_w1\")\n@@ -61,29 +49,38 @@\n   \"cf_ib_w3|cf_ib_w2|cf_ib_w1\")\n \n ;; Operand Execution Pipeline\n-(define_automaton \"cf_oep\")\n+(define_automaton \"cfv123_oep\")\n \n-(define_cpu_unit \"cf_dsoc, cf_agex\" \"cf_oep\")\n+(define_cpu_unit \"cf_dsoc,cf_agex\" \"cfv123_oep\")\n \n ;; A memory unit that is reffered to as 'certain hardware resources' in\n ;; ColdFire reference manuals.  This unit remains occupied for two cycles\n ;; after last dsoc cycle of a store - hence there is a 2 cycle delay between\n ;; two consecutive stores.\n-(define_automaton \"cf_chr\")\n+(define_automaton \"cfv123_chr\")\n \n-(define_cpu_unit \"cf_chr\" \"cf_chr\")\n+(define_cpu_unit \"cf_chr\" \"cfv123_chr\")\n \n ;; Memory bus\n-(define_automaton \"cf_mem\")\n+(define_automaton \"cfv123_mem\")\n \n ;; When memory bus is subscribed, that implies that instruction buffer won't\n ;; get its portion this cycle.  To model that we query if cf_mem unit is\n ;; subscribed and adjust number of prefetched instruction words accordingly.\n ;; \n-(define_query_cpu_unit \"cf_mem1, cf_mem2\" \"cf_mem\")\n+(define_query_cpu_unit \"cf_mem1, cf_mem2\" \"cfv123_mem\")\n \n (define_reservation \"cf_mem\" \"cf_mem1+cf_mem2\")\n \n+(define_automaton \"cf_mac\")\n+\n+(define_cpu_unit \"cf_mac1,cf_mac2,cf_mac3,cf_mac4\"\n+  \"cf_mac\")\n+\n+(define_automaton \"cfv123_guess\")\n+\n+(define_query_cpu_unit \"cfv123_guess\" \"cfv123_guess\")\n+\n ;; Register to register move.\n ;; Takes 1 cycle.\n (define_reservation \"cfv123_alu_00\"\n@@ -235,11 +232,6 @@\n (define_reservation \"cfv3_mul_w_i0\"\n   \"cf_dsoc,cf_agex,cf_agex,cf_dsoc+cf_mem1,cf_dsoc+cf_mem2,(cf_agex+cf_dsoc)*8,cf_agex\")\n \n-(define_automaton \"cf_mac\")\n-\n-(define_cpu_unit \"cf_mac1,cf_mac2,cf_mac3,cf_mac4\"\n-  \"cf_mac\")\n-\n ;; Long multiplication with mac.\n ;; Takes 5 cycles.\n (define_reservation \"cfv123_mac_l_00\"\n@@ -345,1184 +337,1918 @@\n \n (define_insn_reservation \"cfv123_alu_00_1\" 1\n   (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2,cfv3\")\n-\t\t (eq_attr \"type2\" \"alu,alu_reg,omove\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 1)))\n-       (eq_attr \"op_mem\" \"00\"))\n+\t\t (eq_attr \"type\" \"\n+alu_l,aluq_l,bitr,bitrw,cmp,cmp_l,alux_l,ext,neg_l,scc,shift,\n+clr,clr_l,mov3q_l,move,moveq_l,tst,\n+move_l,tst_l\"))\n+\t    (eq_attr \"op_mem\" \"00\"))\n+       (eq_attr \"size\" \"1\"))\n   \"cf_ib1+cfv123_alu_00\")\n \n (define_insn_reservation \"cfv123_alu_00_2\" 1\n   (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2,cfv3\")\n-\t\t (eq_attr \"type2\" \"alu,alu_reg,omove\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n-       (eq_attr \"op_mem\" \"00\"))\n+\t\t (eq_attr \"type\" \"\n+alu_l,aluq_l,bitr,bitrw,cmp,cmp_l,alux_l,ext,neg_l,scc,shift,\n+clr,clr_l,mov3q_l,move,moveq_l,tst,\n+move_l,tst_l\"))\n+\t    (eq_attr \"op_mem\" \"00\"))\n+       (eq_attr \"size\" \"2\"))\n   \"cf_ib2+cfv123_alu_00\")\n \n (define_insn_reservation \"cfv123_alu_00_3\" 1\n   (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2,cfv3\")\n-\t\t (eq_attr \"type2\" \"alu,alu_reg,omove\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n-       (eq_attr \"op_mem\" \"00\"))\n+\t\t (eq_attr \"type\" \"\n+alu_l,aluq_l,bitr,bitrw,cmp,cmp_l,alux_l,ext,neg_l,scc,shift,\n+clr,clr_l,mov3q_l,move,moveq_l,tst,\n+move_l,tst_l\"))\n+\t    (eq_attr \"op_mem\" \"00\"))\n+       (eq_attr \"size\" \"3\"))\n   \"cf_ib3+cfv123_alu_00\")\n \n-(define_insn_reservation \"cfv12_alu_10_1\" 3\n-  (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n-\t\t (eq_attr \"type2\" \"alu\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 1)))\n-       (eq_attr \"op_mem\" \"10\"))\n+(define_insn_reservation \"cfv1_alu_10_1\" 3\n+  (and (and (and (eq_attr \"cpu\" \"cfv1\")\n+\t\t (eq_attr \"type\" \"\n+alu_l,aluq_l,bitr,bitrw,cmp,cmp_l,alux_l,ext,neg_l,scc,shift\"))\n+\t    (eq_attr \"op_mem\" \"10\"))\n+       (eq_attr \"size\" \"1\"))\n   \"cf_ib1+cfv12_alu_10\")\n \n-(define_insn_reservation \"cfv12_alu_10_2\" 3\n-  (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n-\t\t (eq_attr \"type2\" \"alu\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n-       (eq_attr \"op_mem\" \"10\"))\n+(define_insn_reservation \"cfv1_alu_10_2\" 3\n+  (and (and (and (eq_attr \"cpu\" \"cfv1\")\n+\t\t (eq_attr \"type\" \"\n+alu_l,aluq_l,bitr,bitrw,cmp,cmp_l,alux_l,ext,neg_l,scc,shift\"))\n+\t    (eq_attr \"op_mem\" \"10\"))\n+       (eq_attr \"size\" \"2\"))\n   \"cf_ib2+cfv12_alu_10\")\n \n-(define_insn_reservation \"cfv12_alu_10_3\" 3\n-  (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n-\t\t (eq_attr \"type2\" \"alu\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n-       (eq_attr \"op_mem\" \"10\"))\n+(define_insn_reservation \"cfv1_alu_10_3\" 3\n+  (and (and (and (eq_attr \"cpu\" \"cfv1\")\n+\t\t (eq_attr \"type\" \"\n+alu_l,aluq_l,bitr,bitrw,cmp,cmp_l,alux_l,ext,neg_l,scc,shift\"))\n+\t    (eq_attr \"op_mem\" \"10\"))\n+       (eq_attr \"size\" \"3\"))\n   \"cf_ib3+cfv12_alu_10\")\n \n-(define_insn_reservation \"cfv12_omove_10_1\" 2\n-  (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n-\t\t (eq_attr \"type2\" \"omove\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 1)))\n-       (eq_attr \"op_mem\" \"10\"))\n+(define_insn_reservation \"cfv1_omove_10_1\" 2\n+  (and (and (and (eq_attr \"cpu\" \"cfv1\")\n+\t\t (eq_attr \"type\" \"\n+clr,clr_l,mov3q_l,move,moveq_l,tst,\n+move_l,tst_l\"))\n+\t    (eq_attr \"op_mem\" \"10\"))\n+       (eq_attr \"size\" \"1\"))\n   \"cf_ib1+cfv12_omove_10\")\n \n-(define_insn_reservation \"cfv12_omove_10_2\" 2\n-  (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n-\t\t (eq_attr \"type2\" \"omove\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n-       (eq_attr \"op_mem\" \"10\"))\n+(define_insn_reservation \"cfv1_omove_10_2\" 2\n+  (and (and (and (eq_attr \"cpu\" \"cfv1\")\n+\t\t (eq_attr \"type\" \"\n+clr,clr_l,mov3q_l,move,moveq_l,tst,\n+move_l,tst_l\"))\n+\t    (eq_attr \"op_mem\" \"10\"))\n+       (eq_attr \"size\" \"2\"))\n   \"cf_ib2+cfv12_omove_10\")\n \n-(define_insn_reservation \"cfv12_omove_10_3\" 2\n-  (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n-\t\t (eq_attr \"type2\" \"omove\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n-       (eq_attr \"op_mem\" \"10\"))\n+(define_insn_reservation \"cfv1_omove_10_3\" 2\n+  (and (and (and (eq_attr \"cpu\" \"cfv1\")\n+\t\t (eq_attr \"type\" \"\n+clr,clr_l,mov3q_l,move,moveq_l,tst,\n+move_l,tst_l\"))\n+\t    (eq_attr \"op_mem\" \"10\"))\n+       (eq_attr \"size\" \"3\"))\n+  \"cf_ib3+cfv12_omove_10\")\n+\n+(define_insn_reservation \"cfv2_alu_10_1\" 3\n+  (and (and (and (eq_attr \"cpu\" \"cfv2\")\n+\t\t (eq_attr \"type\" \"\n+alu_l,aluq_l,bitr,bitrw,cmp,cmp_l,alux_l,ext,neg_l,scc,shift,\n+clr,clr_l,mov3q_l,move,moveq_l,tst\"))\n+\t    (eq_attr \"op_mem\" \"10\"))\n+       (eq_attr \"size\" \"1\"))\n+  \"cf_ib1+cfv12_alu_10\")\n+\n+(define_insn_reservation \"cfv2_alu_10_2\" 3\n+  (and (and (and (eq_attr \"cpu\" \"cfv2\")\n+\t\t (eq_attr \"type\" \"\n+alu_l,aluq_l,bitr,bitrw,cmp,cmp_l,alux_l,ext,neg_l,scc,shift,\n+clr,clr_l,mov3q_l,move,moveq_l,tst\"))\n+\t    (eq_attr \"op_mem\" \"10\"))\n+       (eq_attr \"size\" \"2\"))\n+  \"cf_ib2+cfv12_alu_10\")\n+\n+(define_insn_reservation \"cfv2_alu_10_3\" 3\n+  (and (and (and (eq_attr \"cpu\" \"cfv2\")\n+\t\t (eq_attr \"type\" \"\n+alu_l,aluq_l,bitr,bitrw,cmp,cmp_l,alux_l,ext,neg_l,scc,shift,\n+clr,clr_l,mov3q_l,move,moveq_l,tst\"))\n+\t    (eq_attr \"op_mem\" \"10\"))\n+       (eq_attr \"size\" \"3\"))\n+  \"cf_ib3+cfv12_alu_10\")\n+\n+(define_insn_reservation \"cfv2_omove_10_1\" 2\n+  (and (and (and (eq_attr \"cpu\" \"cfv2\")\n+\t\t (eq_attr \"type\" \"\n+move_l,tst_l\"))\n+\t    (eq_attr \"op_mem\" \"10\"))\n+       (eq_attr \"size\" \"1\"))\n+  \"cf_ib1+cfv12_omove_10\")\n+\n+(define_insn_reservation \"cfv2_omove_10_2\" 2\n+  (and (and (and (eq_attr \"cpu\" \"cfv2\")\n+\t\t (eq_attr \"type\" \"\n+move_l,tst_l\"))\n+\t    (eq_attr \"op_mem\" \"10\"))\n+       (eq_attr \"size\" \"2\"))\n+  \"cf_ib2+cfv12_omove_10\")\n+\n+(define_insn_reservation \"cfv2_omove_10_3\" 2\n+  (and (and (and (eq_attr \"cpu\" \"cfv2\")\n+\t\t (eq_attr \"type\" \"\n+move_l,tst_l\"))\n+\t    (eq_attr \"op_mem\" \"10\"))\n+       (eq_attr \"size\" \"3\"))\n   \"cf_ib3+cfv12_omove_10\")\n \n (define_insn_reservation \"cfv3_alu_10_1\" 4\n   (and (and (and (eq_attr \"cpu\" \"cfv3\")\n-\t\t (eq_attr \"type2\" \"alu\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 1)))\n-       (eq_attr \"op_mem\" \"10\"))\n+\t\t (eq_attr \"type\" \"\n+alu_l,aluq_l,bitr,bitrw,cmp,cmp_l,alux_l,ext,neg_l,scc,shift,\n+clr,clr_l,mov3q_l,move,moveq_l,tst\"))\n+\t    (eq_attr \"op_mem\" \"10\"))\n+       (eq_attr \"size\" \"1\"))\n   \"cf_ib1+cfv3_alu_10\")\n \n (define_insn_reservation \"cfv3_alu_10_2\" 4\n   (and (and (and (eq_attr \"cpu\" \"cfv3\")\n-\t\t (eq_attr \"type2\" \"alu\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n-       (eq_attr \"op_mem\" \"10\"))\n+\t\t (eq_attr \"type\" \"\n+alu_l,aluq_l,bitr,bitrw,cmp,cmp_l,alux_l,ext,neg_l,scc,shift,\n+clr,clr_l,mov3q_l,move,moveq_l,tst\"))\n+\t    (eq_attr \"op_mem\" \"10\"))\n+       (eq_attr \"size\" \"2\"))\n   \"cf_ib2+cfv3_alu_10\")\n \n (define_insn_reservation \"cfv3_alu_10_3\" 4\n   (and (and (and (eq_attr \"cpu\" \"cfv3\")\n-\t\t (eq_attr \"type2\" \"alu\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n-       (eq_attr \"op_mem\" \"10\"))\n+\t\t (eq_attr \"type\" \"\n+alu_l,aluq_l,bitr,bitrw,cmp,cmp_l,alux_l,ext,neg_l,scc,shift,\n+clr,clr_l,mov3q_l,move,moveq_l,tst\"))\n+\t    (eq_attr \"op_mem\" \"10\"))\n+       (eq_attr \"size\" \"3\"))\n   \"cf_ib3+cfv3_alu_10\")\n \n (define_insn_reservation \"cfv3_omove_10_1\" 3\n   (and (and (and (eq_attr \"cpu\" \"cfv3\")\n-\t\t (eq_attr \"type2\" \"omove\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 1)))\n-       (eq_attr \"op_mem\" \"10\"))\n+\t\t (eq_attr \"type\" \"\n+move_l,tst_l\"))\n+\t    (eq_attr \"op_mem\" \"10\"))\n+       (eq_attr \"size\" \"1\"))\n   \"cf_ib1+cfv3_omove_10\")\n \n (define_insn_reservation \"cfv3_omove_10_2\" 3\n   (and (and (and (eq_attr \"cpu\" \"cfv3\")\n-\t\t (eq_attr \"type2\" \"omove\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n-       (eq_attr \"op_mem\" \"10\"))\n+\t\t (eq_attr \"type\" \"\n+move_l,tst_l\"))\n+\t    (eq_attr \"op_mem\" \"10\"))\n+       (eq_attr \"size\" \"2\"))\n   \"cf_ib2+cfv3_omove_10\")\n \n (define_insn_reservation \"cfv3_omove_10_3\" 3\n   (and (and (and (eq_attr \"cpu\" \"cfv3\")\n-\t\t (eq_attr \"type2\" \"omove\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n-       (eq_attr \"op_mem\" \"10\"))\n+\t\t (eq_attr \"type\" \"\n+move_l,tst_l\"))\n+\t    (eq_attr \"op_mem\" \"10\"))\n+       (eq_attr \"size\" \"3\"))\n   \"cf_ib3+cfv3_omove_10\")\n \n-(define_insn_reservation \"cfv12_alu_i0_2\" 4\n-  (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n-\t\t (eq_attr \"type2\" \"alu\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n-       (eq_attr \"op_mem\" \"i0\"))\n+(define_insn_reservation \"cfv1_alu_i0_2\" 4\n+  (and (and (and (eq_attr \"cpu\" \"cfv1\")\n+\t\t (eq_attr \"type\" \"\n+alu_l,aluq_l,bitr,bitrw,cmp,cmp_l,alux_l,ext,neg_l,scc,shift\"))\n+\t    (eq_attr \"op_mem\" \"i0\"))\n+       (eq_attr \"size\" \"1,2\"))\n   \"cf_ib2+cfv12_alu_i0\")\n \n-(define_insn_reservation \"cfv12_alu_i0_3\" 4\n-  (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n-\t\t (eq_attr \"type2\" \"alu\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n-       (eq_attr \"op_mem\" \"i0\"))\n+(define_insn_reservation \"cfv1_alu_i0_3\" 4\n+  (and (and (and (eq_attr \"cpu\" \"cfv1\")\n+\t\t (eq_attr \"type\" \"\n+alu_l,aluq_l,bitr,bitrw,cmp,cmp_l,alux_l,ext,neg_l,scc,shift\"))\n+\t    (eq_attr \"op_mem\" \"i0\"))\n+       (eq_attr \"size\" \"3\"))\n   \"cf_ib3+cfv12_alu_i0\")\n \n-(define_insn_reservation \"cfv12_omove_i0_2\" 3\n-  (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n-\t\t (eq_attr \"type2\" \"omove\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n-       (eq_attr \"op_mem\" \"i0\"))\n+(define_insn_reservation \"cfv1_omove_i0_2\" 3\n+  (and (and (and (eq_attr \"cpu\" \"cfv1\")\n+\t\t (eq_attr \"type\" \"\n+clr,clr_l,mov3q_l,move,moveq_l,tst,\n+move_l,tst_l\"))\n+\t    (eq_attr \"op_mem\" \"i0\"))\n+       (eq_attr \"size\" \"1,2\"))\n   \"cf_ib2+cfv12_omove_i0\")\n \n-(define_insn_reservation \"cfv12_omove_i0_3\" 3\n-  (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n-\t\t (eq_attr \"type2\" \"omove\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n-       (eq_attr \"op_mem\" \"i0\"))\n+(define_insn_reservation \"cfv1_omove_i0_3\" 3\n+  (and (and (and (eq_attr \"cpu\" \"cfv1\")\n+\t\t (eq_attr \"type\" \"\n+clr,clr_l,mov3q_l,move,moveq_l,tst,\n+move_l,tst_l\"))\n+\t    (eq_attr \"op_mem\" \"i0\"))\n+       (eq_attr \"size\" \"3\"))\n+  \"cf_ib3+cfv12_omove_i0\")\n+\n+(define_insn_reservation \"cfv2_alu_i0_2\" 4\n+  (and (and (and (eq_attr \"cpu\" \"cfv2\")\n+\t\t (eq_attr \"type\" \"\n+alu_l,aluq_l,bitr,bitrw,cmp,cmp_l,alux_l,ext,neg_l,scc,shift,\n+clr,clr_l,mov3q_l,move,moveq_l,tst\"))\n+\t    (eq_attr \"op_mem\" \"i0\"))\n+       (eq_attr \"size\" \"1,2\"))\n+  \"cf_ib2+cfv12_alu_i0\")\n+\n+(define_insn_reservation \"cfv2_alu_i0_3\" 4\n+  (and (and (and (eq_attr \"cpu\" \"cfv2\")\n+\t\t (eq_attr \"type\" \"\n+alu_l,aluq_l,bitr,bitrw,cmp,cmp_l,alux_l,ext,neg_l,scc,shift,\n+clr,clr_l,mov3q_l,move,moveq_l,tst\"))\n+\t    (eq_attr \"op_mem\" \"i0\"))\n+       (eq_attr \"size\" \"3\"))\n+  \"cf_ib3+cfv12_alu_i0\")\n+\n+(define_insn_reservation \"cfv2_omove_i0_2\" 3\n+  (and (and (and (eq_attr \"cpu\" \"cfv2\")\n+\t\t (eq_attr \"type\" \"\n+move_l,tst_l\"))\n+\t    (eq_attr \"op_mem\" \"i0\"))\n+       (eq_attr \"size\" \"1,2\"))\n+  \"cf_ib2+cfv12_omove_i0\")\n+\n+(define_insn_reservation \"cfv2_omove_i0_3\" 3\n+  (and (and (and (eq_attr \"cpu\" \"cfv2\")\n+\t\t (eq_attr \"type\" \"\n+move_l,tst_l\"))\n+\t    (eq_attr \"op_mem\" \"i0\"))\n+       (eq_attr \"size\" \"3\"))\n   \"cf_ib3+cfv12_omove_i0\")\n \n (define_insn_reservation \"cfv3_alu_i0_2\" 5\n   (and (and (and (eq_attr \"cpu\" \"cfv3\")\n-\t\t (eq_attr \"type2\" \"alu\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n-       (eq_attr \"op_mem\" \"i0\"))\n+\t\t (eq_attr \"type\" \"\n+alu_l,aluq_l,bitr,bitrw,cmp,cmp_l,alux_l,ext,neg_l,scc,shift,\n+clr,clr_l,mov3q_l,move,moveq_l,tst\"))\n+\t    (eq_attr \"op_mem\" \"i0\"))\n+       (eq_attr \"size\" \"1,2\"))\n   \"cf_ib2+cfv3_alu_i0\")\n \n (define_insn_reservation \"cfv3_alu_i0_3\" 5\n   (and (and (and (eq_attr \"cpu\" \"cfv3\")\n-\t\t (eq_attr \"type2\" \"alu\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n-       (eq_attr \"op_mem\" \"i0\"))\n+\t\t (eq_attr \"type\" \"\n+alu_l,aluq_l,bitr,bitrw,cmp,cmp_l,alux_l,ext,neg_l,scc,shift,\n+clr,clr_l,mov3q_l,move,moveq_l,tst\"))\n+\t    (eq_attr \"op_mem\" \"i0\"))\n+       (eq_attr \"size\" \"3\"))\n   \"cf_ib3+cfv3_alu_i0\")\n \n (define_insn_reservation \"cfv3_omove_i0_2\" 4\n   (and (and (and (eq_attr \"cpu\" \"cfv3\")\n-\t\t (eq_attr \"type2\" \"omove\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n-       (eq_attr \"op_mem\" \"i0\"))\n+\t\t (eq_attr \"type\" \"\n+move_l,tst_l\"))\n+\t    (eq_attr \"op_mem\" \"i0\"))\n+       (eq_attr \"size\" \"1,2\"))\n   \"cf_ib2+cfv3_omove_i0\")\n \n (define_insn_reservation \"cfv3_omove_i0_3\" 4\n   (and (and (and (eq_attr \"cpu\" \"cfv3\")\n-\t\t (eq_attr \"type2\" \"omove\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n-       (eq_attr \"op_mem\" \"i0\"))\n+\t\t (eq_attr \"type\" \"\n+move_l,tst_l\"))\n+\t    (eq_attr \"op_mem\" \"i0\"))\n+       (eq_attr \"size\" \"3\"))\n   \"cf_ib3+cfv3_omove_i0\")\n \n-(define_insn_reservation \"cfv12_alu_01_1\" 0\n+(define_insn_reservation \"cfv12_alu_01_1\" 1\n   (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n-\t\t (eq_attr \"type2\" \"alu,omove\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 1)))\n-       (eq_attr \"op_mem\" \"01\"))\n+\t\t (eq_attr \"type\" \"\n+alu_l,aluq_l,bitr,bitrw,cmp,cmp_l,alux_l,ext,neg_l,scc,shift,\n+clr,clr_l,mov3q_l,move,moveq_l,tst,\n+move_l,tst_l\"))\n+\t    (eq_attr \"op_mem\" \"01\"))\n+       (eq_attr \"size\" \"1\"))\n   \"cf_ib1+cfv12_alu_01\")\n \n-(define_insn_reservation \"cfv12_alu_01_2\" 0\n+(define_insn_reservation \"cfv12_alu_01_2\" 1\n   (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n-\t\t (eq_attr \"type2\" \"alu,omove\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n-       (eq_attr \"op_mem\" \"01\"))\n+\t\t (eq_attr \"type\" \"\n+alu_l,aluq_l,bitr,bitrw,cmp,cmp_l,alux_l,ext,neg_l,scc,shift,\n+clr,clr_l,mov3q_l,move,moveq_l,tst,\n+move_l,tst_l\"))\n+\t    (eq_attr \"op_mem\" \"01\"))\n+       (eq_attr \"size\" \"2\"))\n   \"cf_ib2+cfv12_alu_01\")\n \n-(define_insn_reservation \"cfv12_alu_01_3\" 0\n+(define_insn_reservation \"cfv12_alu_01_3\" 1\n   (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n-\t\t (eq_attr \"type2\" \"alu,omove\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n-       (eq_attr \"op_mem\" \"01\"))\n+\t\t (eq_attr \"type\" \"\n+alu_l,aluq_l,bitr,bitrw,cmp,cmp_l,alux_l,ext,neg_l,scc,shift,\n+clr,clr_l,mov3q_l,move,moveq_l,tst,\n+move_l,tst_l\"))\n+\t    (eq_attr \"op_mem\" \"01\"))\n+       (eq_attr \"size\" \"3\"))\n   \"cf_ib3+cfv12_alu_01\")\n \n-(define_insn_reservation \"cfv3_alu_01_1\" 0\n+(define_insn_reservation \"cfv3_alu_01_1\" 1\n   (and (and (and (eq_attr \"cpu\" \"cfv3\")\n-\t\t (eq_attr \"type2\" \"alu,omove\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 1)))\n-       (eq_attr \"op_mem\" \"01\"))\n+\t\t (eq_attr \"type\" \"\n+alu_l,aluq_l,bitr,bitrw,cmp,cmp_l,alux_l,ext,neg_l,scc,shift,\n+clr,clr_l,mov3q_l,move,moveq_l,tst,\n+move_l,tst_l\"))\n+\t    (eq_attr \"op_mem\" \"01\"))\n+       (eq_attr \"size\" \"1\"))\n   \"cf_ib1+cfv3_alu_01\")\n \n-(define_insn_reservation \"cfv3_alu_01_2\" 0\n+(define_insn_reservation \"cfv3_alu_01_2\" 1\n   (and (and (and (eq_attr \"cpu\" \"cfv3\")\n-\t\t (eq_attr \"type2\" \"alu,omove\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n-       (eq_attr \"op_mem\" \"01\"))\n+\t\t (eq_attr \"type\" \"\n+alu_l,aluq_l,bitr,bitrw,cmp,cmp_l,alux_l,ext,neg_l,scc,shift,\n+clr,clr_l,mov3q_l,move,moveq_l,tst,\n+move_l,tst_l\"))\n+\t    (eq_attr \"op_mem\" \"01\"))\n+       (eq_attr \"size\" \"2\"))\n   \"cf_ib2+cfv3_alu_01\")\n \n-(define_insn_reservation \"cfv3_alu_01_3\" 0\n+(define_insn_reservation \"cfv3_alu_01_3\" 1\n   (and (and (and (eq_attr \"cpu\" \"cfv3\")\n-\t\t (eq_attr \"type2\" \"alu,omove\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n-       (eq_attr \"op_mem\" \"01\"))\n+\t\t (eq_attr \"type\" \"\n+alu_l,aluq_l,bitr,bitrw,cmp,cmp_l,alux_l,ext,neg_l,scc,shift,\n+clr,clr_l,mov3q_l,move,moveq_l,tst,\n+move_l,tst_l\"))\n+\t    (eq_attr \"op_mem\" \"01\"))\n+       (eq_attr \"size\" \"3\"))\n   \"cf_ib3+cfv3_alu_01\")\n \n-(define_insn_reservation \"cfv12_alu_0i_2\" 0\n+(define_insn_reservation \"cfv12_alu_0i_2\" 2\n   (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n-\t\t (eq_attr \"type2\" \"alu,omove\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n-       (eq_attr \"op_mem\" \"0i\"))\n+\t\t (eq_attr \"type\" \"\n+alu_l,aluq_l,bitr,bitrw,cmp,cmp_l,alux_l,ext,neg_l,scc,shift,\n+clr,clr_l,mov3q_l,move,moveq_l,tst,\n+move_l,tst_l\"))\n+\t    (eq_attr \"op_mem\" \"0i\"))\n+       (eq_attr \"size\" \"1,2\"))\n   \"cf_ib2+cfv12_alu_0i\")\n \n-(define_insn_reservation \"cfv12_alu_0i_3\" 0\n+(define_insn_reservation \"cfv12_alu_0i_3\" 2\n   (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n-\t\t (eq_attr \"type2\" \"alu,omove\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n-       (eq_attr \"op_mem\" \"0i\"))\n+\t\t (eq_attr \"type\" \"\n+alu_l,aluq_l,bitr,bitrw,cmp,cmp_l,alux_l,ext,neg_l,scc,shift,\n+clr,clr_l,mov3q_l,move,moveq_l,tst,\n+move_l,tst_l\"))\n+\t    (eq_attr \"op_mem\" \"0i\"))\n+       (eq_attr \"size\" \"3\"))\n   \"cf_ib3+cfv12_alu_0i\")\n \n-(define_insn_reservation \"cfv3_alu_0i_2\" 0\n+(define_insn_reservation \"cfv3_alu_0i_2\" 2\n   (and (and (and (eq_attr \"cpu\" \"cfv3\")\n-\t\t (eq_attr \"type2\" \"alu,omove\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n-       (eq_attr \"op_mem\" \"0i\"))\n+\t\t (eq_attr \"type\" \"\n+alu_l,aluq_l,bitr,bitrw,cmp,cmp_l,alux_l,ext,neg_l,scc,shift,\n+clr,clr_l,mov3q_l,move,moveq_l,tst,\n+move_l,tst_l\"))\n+\t    (eq_attr \"op_mem\" \"0i\"))\n+       (eq_attr \"size\" \"1,2\"))\n   \"cf_ib2+cfv3_alu_0i\")\n \n-(define_insn_reservation \"cfv3_alu_0i_3\" 0\n+(define_insn_reservation \"cfv3_alu_0i_3\" 2\n   (and (and (and (eq_attr \"cpu\" \"cfv3\")\n-\t\t (eq_attr \"type2\" \"alu,omove\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n-       (eq_attr \"op_mem\" \"0i\"))\n+\t\t (eq_attr \"type\" \"\n+alu_l,aluq_l,bitr,bitrw,cmp,cmp_l,alux_l,ext,neg_l,scc,shift,\n+clr,clr_l,mov3q_l,move,moveq_l,tst,\n+move_l,tst_l\"))\n+\t    (eq_attr \"op_mem\" \"0i\"))\n+       (eq_attr \"size\" \"3\"))\n   \"cf_ib3+cfv3_alu_0i\")\n \n-(define_insn_reservation \"cfv12_alu_11_1\" 0\n-  (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n-\t\t (eq_attr \"type2\" \"alu\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 1)))\n-       (eq_attr \"op_mem\" \"11\"))\n+(define_insn_reservation \"cfv1_alu_11_1\" 1\n+  (and (and (and (eq_attr \"cpu\" \"cfv1\")\n+\t\t (eq_attr \"type\" \"\n+alu_l,aluq_l,bitr,bitrw,cmp,cmp_l,alux_l,ext,neg_l,scc,shift\"))\n+\t    (eq_attr \"op_mem\" \"11\"))\n+       (eq_attr \"size\" \"1\"))\n   \"cf_ib1+cfv12_alu_11\")\n \n-(define_insn_reservation \"cfv12_alu_11_2\" 0\n-  (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n-\t\t (eq_attr \"type2\" \"alu\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n-       (eq_attr \"op_mem\" \"11\"))\n+(define_insn_reservation \"cfv1_alu_11_2\" 1\n+  (and (and (and (eq_attr \"cpu\" \"cfv1\")\n+\t\t (eq_attr \"type\" \"\n+alu_l,aluq_l,bitr,bitrw,cmp,cmp_l,alux_l,ext,neg_l,scc,shift\"))\n+\t    (eq_attr \"op_mem\" \"11\"))\n+       (eq_attr \"size\" \"2\"))\n   \"cf_ib2+cfv12_alu_11\")\n \n-(define_insn_reservation \"cfv12_alu_11_3\" 0\n-  (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n-\t\t (eq_attr \"type2\" \"alu\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n-       (eq_attr \"op_mem\" \"11\"))\n+(define_insn_reservation \"cfv1_alu_11_3\" 1\n+  (and (and (and (eq_attr \"cpu\" \"cfv1\")\n+\t\t (eq_attr \"type\" \"\n+alu_l,aluq_l,bitr,bitrw,cmp,cmp_l,alux_l,ext,neg_l,scc,shift\"))\n+\t    (eq_attr \"op_mem\" \"11\"))\n+       (eq_attr \"size\" \"3\"))\n   \"cf_ib3+cfv12_alu_11\")\n \n-(define_insn_reservation \"cfv12_omove_11_1\" 0\n-  (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n-\t\t (eq_attr \"type2\" \"omove\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 1)))\n-       (eq_attr \"op_mem\" \"11\"))\n+(define_insn_reservation \"cfv1_omove_11_1\" 1\n+  (and (and (and (eq_attr \"cpu\" \"cfv1\")\n+\t\t (eq_attr \"type\" \"\n+clr,clr_l,mov3q_l,move,moveq_l,tst,\n+move_l,tst_l\"))\n+\t    (eq_attr \"op_mem\" \"11\"))\n+       (eq_attr \"size\" \"1\"))\n   \"cf_ib1+cfv12_omove_11\")\n \n-(define_insn_reservation \"cfv12_omove_11_2\" 0\n-  (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n-\t\t (eq_attr \"type2\" \"omove\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n-       (eq_attr \"op_mem\" \"11\"))\n+(define_insn_reservation \"cfv1_omove_11_2\" 1\n+  (and (and (and (eq_attr \"cpu\" \"cfv1\")\n+\t\t (eq_attr \"type\" \"\n+clr,clr_l,mov3q_l,move,moveq_l,tst,\n+move_l,tst_l\"))\n+\t    (eq_attr \"op_mem\" \"11\"))\n+       (eq_attr \"size\" \"2\"))\n   \"cf_ib2+cfv12_omove_11\")\n \n-(define_insn_reservation \"cfv12_omove_11_3\" 0\n-  (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n-\t\t (eq_attr \"type2\" \"omove\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n-       (eq_attr \"op_mem\" \"11\"))\n+(define_insn_reservation \"cfv1_omove_11_3\" 1\n+  (and (and (and (eq_attr \"cpu\" \"cfv1\")\n+\t\t (eq_attr \"type\" \"\n+clr,clr_l,mov3q_l,move,moveq_l,tst,\n+move_l,tst_l\"))\n+\t    (eq_attr \"op_mem\" \"11\"))\n+       (eq_attr \"size\" \"3\"))\n+  \"cf_ib3+cfv12_omove_11\")\n+\n+(define_insn_reservation \"cfv2_alu_11_1\" 1\n+  (and (and (and (eq_attr \"cpu\" \"cfv2\")\n+\t\t (eq_attr \"type\" \"\n+alu_l,aluq_l,bitr,bitrw,cmp,cmp_l,alux_l,ext,neg_l,scc,shift,\n+clr,clr_l,mov3q_l,move,moveq_l,tst\"))\n+\t    (eq_attr \"op_mem\" \"11\"))\n+       (eq_attr \"size\" \"1\"))\n+  \"cf_ib1+cfv12_alu_11\")\n+\n+(define_insn_reservation \"cfv2_alu_11_2\" 1\n+  (and (and (and (eq_attr \"cpu\" \"cfv2\")\n+\t\t (eq_attr \"type\" \"\n+alu_l,aluq_l,bitr,bitrw,cmp,cmp_l,alux_l,ext,neg_l,scc,shift,\n+clr,clr_l,mov3q_l,move,moveq_l,tst\"))\n+\t    (eq_attr \"op_mem\" \"11\"))\n+       (eq_attr \"size\" \"2\"))\n+  \"cf_ib2+cfv12_alu_11\")\n+\n+(define_insn_reservation \"cfv2_alu_11_3\" 1\n+  (and (and (and (eq_attr \"cpu\" \"cfv2\")\n+\t\t (eq_attr \"type\" \"\n+alu_l,aluq_l,bitr,bitrw,cmp,cmp_l,alux_l,ext,neg_l,scc,shift,\n+clr,clr_l,mov3q_l,move,moveq_l,tst\"))\n+\t    (eq_attr \"op_mem\" \"11\"))\n+       (eq_attr \"size\" \"3\"))\n+  \"cf_ib3+cfv12_alu_11\")\n+\n+(define_insn_reservation \"cfv2_omove_11_1\" 1\n+  (and (and (and (eq_attr \"cpu\" \"cfv2\")\n+\t\t (eq_attr \"type\" \"\n+move_l,tst_l\"))\n+\t    (eq_attr \"op_mem\" \"11\"))\n+       (eq_attr \"size\" \"1\"))\n+  \"cf_ib1+cfv12_omove_11\")\n+\n+(define_insn_reservation \"cfv2_omove_11_2\" 1\n+  (and (and (and (eq_attr \"cpu\" \"cfv2\")\n+\t\t (eq_attr \"type\" \"\n+move_l,tst_l\"))\n+\t    (eq_attr \"op_mem\" \"11\"))\n+       (eq_attr \"size\" \"2\"))\n+  \"cf_ib2+cfv12_omove_11\")\n+\n+(define_insn_reservation \"cfv2_omove_11_3\" 1\n+  (and (and (and (eq_attr \"cpu\" \"cfv2\")\n+\t\t (eq_attr \"type\" \"\n+move_l,tst_l\"))\n+\t    (eq_attr \"op_mem\" \"11\"))\n+       (eq_attr \"size\" \"3\"))\n   \"cf_ib3+cfv12_omove_11\")\n \n-(define_insn_reservation \"cfv3_alu_11_1\" 0\n+(define_insn_reservation \"cfv3_alu_11_1\" 1\n   (and (and (and (eq_attr \"cpu\" \"cfv3\")\n-\t\t (eq_attr \"type2\" \"alu\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 1)))\n-       (eq_attr \"op_mem\" \"11\"))\n+\t\t (eq_attr \"type\" \"\n+alu_l,aluq_l,bitr,bitrw,cmp,cmp_l,alux_l,ext,neg_l,scc,shift,\n+clr,clr_l,mov3q_l,move,moveq_l,tst\"))\n+\t    (eq_attr \"op_mem\" \"11\"))\n+       (eq_attr \"size\" \"1\"))\n   \"cf_ib1+cfv3_alu_11\")\n \n-(define_insn_reservation \"cfv3_alu_11_2\" 0\n+(define_insn_reservation \"cfv3_alu_11_2\" 1\n   (and (and (and (eq_attr \"cpu\" \"cfv3\")\n-\t\t (eq_attr \"type2\" \"alu\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n+\t\t (eq_attr \"type\" \"\n+alu_l,aluq_l,bitr,bitrw,cmp,cmp_l,alux_l,ext,neg_l,scc,shift,\n+clr,clr_l,mov3q_l,move,moveq_l,tst\"))\n+\t    (eq_attr \"size\" \"2\"))\n        (eq_attr \"op_mem\" \"11\"))\n   \"cf_ib2+cfv3_alu_11\")\n \n-(define_insn_reservation \"cfv3_alu_11_3\" 0\n+(define_insn_reservation \"cfv3_alu_11_3\" 1\n   (and (and (and (eq_attr \"cpu\" \"cfv3\")\n-\t\t (eq_attr \"type2\" \"alu\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n-       (eq_attr \"op_mem\" \"11\"))\n+\t\t (eq_attr \"type\" \"\n+alu_l,aluq_l,bitr,bitrw,cmp,cmp_l,alux_l,ext,neg_l,scc,shift,\n+clr,clr_l,mov3q_l,move,moveq_l,tst\"))\n+\t    (eq_attr \"op_mem\" \"11\"))\n+       (eq_attr \"size\" \"3\"))\n   \"cf_ib3+cfv3_alu_11\")\n \n-(define_insn_reservation \"cfv3_omove_11_1\" 0\n+(define_insn_reservation \"cfv3_omove_11_1\" 1\n   (and (and (and (eq_attr \"cpu\" \"cfv3\")\n-\t\t (eq_attr \"type2\" \"omove\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 1)))\n-       (eq_attr \"op_mem\" \"11\"))\n+\t\t (eq_attr \"type\" \"\n+move_l,tst_l\"))\n+\t    (eq_attr \"op_mem\" \"11\"))\n+       (eq_attr \"size\" \"1\"))\n   \"cf_ib1+cfv3_omove_11\")\n \n-(define_insn_reservation \"cfv3_omove_11_2\" 0\n+(define_insn_reservation \"cfv3_omove_11_2\" 1\n   (and (and (and (eq_attr \"cpu\" \"cfv3\")\n-\t\t (eq_attr \"type2\" \"omove\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n+\t\t (eq_attr \"type\" \"\n+move_l,tst_l\"))\n+\t    (eq_attr \"size\" \"2\"))\n        (eq_attr \"op_mem\" \"11\"))\n   \"cf_ib2+cfv3_omove_11\")\n \n-(define_insn_reservation \"cfv3_omove_11_3\" 0\n+(define_insn_reservation \"cfv3_omove_11_3\" 1\n   (and (and (and (eq_attr \"cpu\" \"cfv3\")\n-\t\t (eq_attr \"type2\" \"omove\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n-       (eq_attr \"op_mem\" \"11\"))\n+\t\t (eq_attr \"type\" \"\n+move_l,tst_l\"))\n+\t    (eq_attr \"op_mem\" \"11\"))\n+       (eq_attr \"size\" \"3\"))\n   \"cf_ib3+cfv3_omove_11\")\n \n-(define_insn_reservation \"cfv12_alu_i1_2\" 0\n-  (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n-\t\t (eq_attr \"type2\" \"alu\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n-       (eq_attr \"op_mem\" \"i1\"))\n+(define_insn_reservation \"cfv1_alu_i1_2\" 2\n+  (and (and (and (eq_attr \"cpu\" \"cfv1\")\n+\t\t (eq_attr \"type\" \"\n+alu_l,aluq_l,bitr,bitrw,cmp,cmp_l,alux_l,ext,neg_l,scc,shift\"))\n+\t    (eq_attr \"op_mem\" \"i1\"))\n+       (eq_attr \"size\" \"1,2\"))\n   \"cf_ib2+cfv12_alu_i1\")\n \n-(define_insn_reservation \"cfv12_alu_i1_3\" 0\n-  (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n-\t\t (eq_attr \"type2\" \"alu\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n-       (eq_attr \"op_mem\" \"i1\"))\n+(define_insn_reservation \"cfv1_alu_i1_3\" 2\n+  (and (and (and (eq_attr \"cpu\" \"cfv1\")\n+\t\t (eq_attr \"type\" \"\n+alu_l,aluq_l,bitr,bitrw,cmp,cmp_l,alux_l,ext,neg_l,scc,shift\"))\n+\t    (eq_attr \"op_mem\" \"i1\"))\n+       (eq_attr \"size\" \"3\"))\n   \"cf_ib3+cfv12_alu_i1\")\n \n-(define_insn_reservation \"cfv12_omove_i1_2\" 0\n-  (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n-\t\t (eq_attr \"type2\" \"omove\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n-       (eq_attr \"op_mem\" \"i1\"))\n+(define_insn_reservation \"cfv1_omove_i1_2\" 2\n+  (and (and (and (eq_attr \"cpu\" \"cfv1\")\n+\t\t (eq_attr \"type\" \"\n+clr,clr_l,mov3q_l,move,moveq_l,tst,\n+move_l,tst_l\"))\n+\t    (eq_attr \"op_mem\" \"i1\"))\n+       (eq_attr \"size\" \"1,2\"))\n   \"cf_ib2+cfv12_omove_i1\")\n \n-(define_insn_reservation \"cfv12_omove_i1_3\" 0\n-  (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n-\t\t (eq_attr \"type2\" \"omove\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n-       (eq_attr \"op_mem\" \"i1\"))\n+(define_insn_reservation \"cfv1_omove_i1_3\" 2\n+  (and (and (and (eq_attr \"cpu\" \"cfv1\")\n+\t\t (eq_attr \"type\" \"\n+clr,clr_l,mov3q_l,move,moveq_l,tst,\n+move_l,tst_l\"))\n+\t    (eq_attr \"op_mem\" \"i1\"))\n+       (eq_attr \"size\" \"3\"))\n   \"cf_ib3+cfv12_omove_i1\")\n \n-(define_insn_reservation \"cfv3_alu_i1_2\" 0\n+(define_insn_reservation \"cfv2_alu_i1_2\" 2\n+  (and (and (and (eq_attr \"cpu\" \"cfv2\")\n+\t\t (eq_attr \"type\" \"\n+alu_l,aluq_l,bitr,bitrw,cmp,cmp_l,alux_l,ext,neg_l,scc,shift,\n+clr,clr_l,mov3q_l,move,moveq_l,tst\"))\n+\t    (eq_attr \"op_mem\" \"i1\"))\n+       (eq_attr \"size\" \"1,2\"))\n+  \"cf_ib2+cfv12_alu_i1\")\n+\n+(define_insn_reservation \"cfv2_alu_i1_3\" 2\n+  (and (and (and (eq_attr \"cpu\" \"cfv2\")\n+\t\t (eq_attr \"type\" \"\n+alu_l,aluq_l,bitr,bitrw,cmp,cmp_l,alux_l,ext,neg_l,scc,shift,\n+clr,clr_l,mov3q_l,move,moveq_l,tst\"))\n+\t    (eq_attr \"op_mem\" \"i1\"))\n+       (eq_attr \"size\" \"3\"))\n+  \"cf_ib3+cfv12_alu_i1\")\n+\n+(define_insn_reservation \"cfv2_omove_i1_2\" 2\n+  (and (and (and (eq_attr \"cpu\" \"cfv2\")\n+\t\t (eq_attr \"type\" \"\n+move_l,tst_l\"))\n+\t    (eq_attr \"op_mem\" \"i1\"))\n+       (eq_attr \"size\" \"1,2\"))\n+  \"cf_ib2+cfv12_omove_i1\")\n+\n+(define_insn_reservation \"cfv2_omove_i1_3\" 2\n+  (and (and (and (eq_attr \"cpu\" \"cfv2\")\n+\t\t (eq_attr \"type\" \"\n+move_l,tst_l\"))\n+\t    (eq_attr \"op_mem\" \"i1\"))\n+       (eq_attr \"size\" \"3\"))\n+  \"cf_ib3+cfv12_omove_i1\")\n+\n+(define_insn_reservation \"cfv3_alu_i1_2\" 2\n   (and (and (and (eq_attr \"cpu\" \"cfv3\")\n-\t\t (eq_attr \"type2\" \"alu\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n-       (eq_attr \"op_mem\" \"i1\"))\n+\t\t (eq_attr \"type\" \"\n+alu_l,aluq_l,bitr,bitrw,cmp,cmp_l,alux_l,ext,neg_l,scc,shift,\n+clr,clr_l,mov3q_l,move,moveq_l,tst\"))\n+\t    (eq_attr \"op_mem\" \"i1\"))\n+       (eq_attr \"size\" \"1,2\"))\n   \"cf_ib2+cfv3_alu_i1\")\n \n-(define_insn_reservation \"cfv3_alu_i1_3\" 0\n+(define_insn_reservation \"cfv3_alu_i1_3\" 2\n   (and (and (and (eq_attr \"cpu\" \"cfv3\")\n-\t\t (eq_attr \"type2\" \"alu\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n-       (eq_attr \"op_mem\" \"i1\"))\n+\t\t (eq_attr \"type\" \"\n+alu_l,aluq_l,bitr,bitrw,cmp,cmp_l,alux_l,ext,neg_l,scc,shift,\n+clr,clr_l,mov3q_l,move,moveq_l,tst\"))\n+\t    (eq_attr \"op_mem\" \"i1\"))\n+       (eq_attr \"size\" \"3\"))\n   \"cf_ib3+cfv3_alu_i1\")\n \n-(define_insn_reservation \"cfv3_omove_i1_2\" 0\n+(define_insn_reservation \"cfv3_omove_i1_2\" 2\n   (and (and (and (eq_attr \"cpu\" \"cfv3\")\n-\t\t (eq_attr \"type2\" \"omove\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n-       (eq_attr \"op_mem\" \"i1\"))\n+\t\t (eq_attr \"type\" \"\n+move_l,tst_l\"))\n+\t    (eq_attr \"op_mem\" \"i1\"))\n+       (eq_attr \"size\" \"1,2\"))\n   \"cf_ib2+cfv3_omove_i1\")\n \n-(define_insn_reservation \"cfv3_omove_i1_3\" 0\n+(define_insn_reservation \"cfv3_omove_i1_3\" 2\n   (and (and (and (eq_attr \"cpu\" \"cfv3\")\n-\t\t (eq_attr \"type2\" \"omove\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n-       (eq_attr \"op_mem\" \"i1\"))\n+\t\t (eq_attr \"type\" \"\n+move_l,tst_l\"))\n+\t    (eq_attr \"op_mem\" \"i1\"))\n+       (eq_attr \"size\" \"3\"))\n   \"cf_ib3+cfv3_omove_i1\")\n \n-(define_insn_reservation \"cfv12_alu_1i_2\" 0\n-  (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n-\t\t (eq_attr \"type2\" \"alu\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n-       (eq_attr \"op_mem\" \"1i\"))\n+(define_insn_reservation \"cfv1_alu_1i_2\" 2\n+  (and (and (and (eq_attr \"cpu\" \"cfv1\")\n+\t\t (eq_attr \"type\" \"\n+alu_l,aluq_l,bitr,bitrw,cmp,cmp_l,alux_l,ext,neg_l,scc,shift\"))\n+\t    (eq_attr \"op_mem\" \"1i\"))\n+       (eq_attr \"size\" \"1,2\"))\n   \"cf_ib2+cfv12_alu_1i\")\n \n-(define_insn_reservation \"cfv12_alu_1i_3\" 0\n-  (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n-\t\t (eq_attr \"type2\" \"alu\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n-       (eq_attr \"op_mem\" \"1i\"))\n+(define_insn_reservation \"cfv1_alu_1i_3\" 2\n+  (and (and (and (eq_attr \"cpu\" \"cfv1\")\n+\t\t (eq_attr \"type\" \"\n+alu_l,aluq_l,bitr,bitrw,cmp,cmp_l,alux_l,ext,neg_l,scc,shift\"))\n+\t    (eq_attr \"op_mem\" \"1i\"))\n+       (eq_attr \"size\" \"3\"))\n   \"cf_ib3+cfv12_alu_1i\")\n \n-(define_insn_reservation \"cfv12_omove_1i_2\" 0\n-  (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n-\t\t (eq_attr \"type2\" \"omove\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n-       (eq_attr \"op_mem\" \"1i\"))\n+(define_insn_reservation \"cfv1_omove_1i_2\" 2\n+  (and (and (and (eq_attr \"cpu\" \"cfv1\")\n+\t\t (eq_attr \"type\" \"\n+clr,clr_l,mov3q_l,move,moveq_l,tst,\n+move_l,tst_l\"))\n+\t    (eq_attr \"op_mem\" \"1i\"))\n+       (eq_attr \"size\" \"1,2\"))\n   \"cf_ib2+cfv12_omove_1i\")\n \n-(define_insn_reservation \"cfv12_omove_1i_3\" 0\n-  (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n-\t\t (eq_attr \"type2\" \"omove\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n-       (eq_attr \"op_mem\" \"1i\"))\n+(define_insn_reservation \"cfv1_omove_1i_3\" 2\n+  (and (and (and (eq_attr \"cpu\" \"cfv1\")\n+\t\t (eq_attr \"type\" \"\n+clr,clr_l,mov3q_l,move,moveq_l,tst,\n+move_l,tst_l\"))\n+\t    (eq_attr \"op_mem\" \"1i\"))\n+       (eq_attr \"size\" \"3\"))\n+  \"cf_ib3+cfv12_omove_1i\")\n+\n+(define_insn_reservation \"cfv2_alu_1i_2\" 2\n+  (and (and (and (eq_attr \"cpu\" \"cfv2\")\n+\t\t (eq_attr \"type\" \"\n+alu_l,aluq_l,bitr,bitrw,cmp,cmp_l,alux_l,ext,neg_l,scc,shift,\n+clr,clr_l,mov3q_l,move,moveq_l,tst\"))\n+\t    (eq_attr \"op_mem\" \"1i\"))\n+       (eq_attr \"size\" \"1,2\"))\n+  \"cf_ib2+cfv12_alu_1i\")\n+\n+(define_insn_reservation \"cfv2_alu_1i_3\" 2\n+  (and (and (and (eq_attr \"cpu\" \"cfv2\")\n+\t\t (eq_attr \"type\" \"\n+alu_l,aluq_l,bitr,bitrw,cmp,cmp_l,alux_l,ext,neg_l,scc,shift,\n+clr,clr_l,mov3q_l,move,moveq_l,tst\"))\n+\t    (eq_attr \"op_mem\" \"1i\"))\n+       (eq_attr \"size\" \"3\"))\n+  \"cf_ib3+cfv12_alu_1i\")\n+\n+(define_insn_reservation \"cfv2_omove_1i_2\" 2\n+  (and (and (and (eq_attr \"cpu\" \"cfv2\")\n+\t\t (eq_attr \"type\" \"\n+move_l,tst_l\"))\n+\t    (eq_attr \"op_mem\" \"1i\"))\n+       (eq_attr \"size\" \"1,2\"))\n+  \"cf_ib2+cfv12_omove_1i\")\n+\n+(define_insn_reservation \"cfv2_omove_1i_3\" 2\n+  (and (and (and (eq_attr \"cpu\" \"cfv2\")\n+\t\t (eq_attr \"type\" \"\n+move_l,tst_l\"))\n+\t    (eq_attr \"op_mem\" \"1i\"))\n+       (eq_attr \"size\" \"3\"))\n   \"cf_ib3+cfv12_omove_1i\")\n \n-(define_insn_reservation \"cfv3_alu_1i_2\" 0\n+(define_insn_reservation \"cfv3_alu_1i_2\" 2\n   (and (and (and (eq_attr \"cpu\" \"cfv3\")\n-\t\t (eq_attr \"type2\" \"alu\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n-       (eq_attr \"op_mem\" \"1i\"))\n+\t\t (eq_attr \"type\" \"\n+alu_l,aluq_l,bitr,bitrw,cmp,cmp_l,alux_l,ext,neg_l,scc,shift,\n+clr,clr_l,mov3q_l,move,moveq_l,tst\"))\n+\t    (eq_attr \"op_mem\" \"1i\"))\n+       (eq_attr \"size\" \"1,2\"))\n   \"cf_ib2+cfv3_alu_1i\")\n \n-(define_insn_reservation \"cfv3_alu_1i_3\" 0\n+(define_insn_reservation \"cfv3_alu_1i_3\" 2\n   (and (and (and (eq_attr \"cpu\" \"cfv3\")\n-\t\t (eq_attr \"type2\" \"alu\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n-       (eq_attr \"op_mem\" \"1i\"))\n+\t\t (eq_attr \"type\" \"\n+alu_l,aluq_l,bitr,bitrw,cmp,cmp_l,alux_l,ext,neg_l,scc,shift,\n+clr,clr_l,mov3q_l,move,moveq_l,tst\"))\n+\t    (eq_attr \"op_mem\" \"1i\"))\n+       (eq_attr \"size\" \"3\"))\n   \"cf_ib3+cfv3_alu_1i\")\n \n-(define_insn_reservation \"cfv3_omove_1i_2\" 0\n+(define_insn_reservation \"cfv3_omove_1i_2\" 2\n   (and (and (and (eq_attr \"cpu\" \"cfv3\")\n-\t\t (eq_attr \"type2\" \"omove\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n-       (eq_attr \"op_mem\" \"1i\"))\n+\t\t (eq_attr \"type\" \"\n+move_l,tst_l\"))\n+\t    (eq_attr \"op_mem\" \"1i\"))\n+       (eq_attr \"size\" \"1,2\"))\n   \"cf_ib2+cfv3_omove_1i\")\n \n-(define_insn_reservation \"cfv3_omove_1i_3\" 0\n+(define_insn_reservation \"cfv3_omove_1i_3\" 2\n   (and (and (and (eq_attr \"cpu\" \"cfv3\")\n-\t\t (eq_attr \"type2\" \"omove\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n-       (eq_attr \"op_mem\" \"1i\"))\n+\t\t (eq_attr \"type\" \"\n+move_l,tst_l\"))\n+\t    (eq_attr \"op_mem\" \"1i\"))\n+       (eq_attr \"size\" \"3\"))\n   \"cf_ib3+cfv3_omove_1i\")\n \n (define_insn_reservation \"cfv123_lea_10_1\" 1\n   (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2,cfv3\")\n-\t\t (eq_attr \"type2\" \"lea\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 1)))\n-       (eq_attr \"op_mem\" \"10\"))\n+\t\t (eq_attr \"type\" \"lea\"))\n+\t    (eq_attr \"op_mem\" \"10,11,1i\"))\n+       (eq_attr \"size\" \"1\"))\n   \"cf_ib1+cfv123_lea_10\")\n \n (define_insn_reservation \"cfv123_lea_10_2\" 1\n   (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2,cfv3\")\n-\t\t (eq_attr \"type2\" \"lea\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n-       (eq_attr \"op_mem\" \"10\"))\n+\t\t (eq_attr \"type\" \"lea\"))\n+\t    (eq_attr \"op_mem\" \"10,11,1i\"))\n+       (eq_attr \"size\" \"2\"))\n   \"cf_ib2+cfv123_lea_10\")\n \n (define_insn_reservation \"cfv123_lea_10_3\" 1\n   (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2,cfv3\")\n-\t\t (eq_attr \"type2\" \"lea\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n-       (eq_attr \"op_mem\" \"10\"))\n+\t\t (eq_attr \"type\" \"lea\"))\n+\t    (eq_attr \"op_mem\" \"10,11,1i\"))\n+       (eq_attr \"size\" \"3\"))\n   \"cf_ib3+cfv123_lea_10\")\n \n (define_insn_reservation \"cfv123_lea_i0_2\" 2\n   (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2,cfv3\")\n-\t\t (eq_attr \"type2\" \"lea\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n-       (eq_attr \"op_mem\" \"i0\"))\n+\t\t (eq_attr \"type\" \"lea\"))\n+\t    (eq_attr \"op_mem\" \"i0,i1\"))\n+       (eq_attr \"size\" \"1,2\"))\n   \"cf_ib2+cfv123_lea_i0\")\n \n (define_insn_reservation \"cfv123_lea_i0_3\" 2\n   (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2,cfv3\")\n-\t\t (eq_attr \"type2\" \"lea\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n-       (eq_attr \"op_mem\" \"i0\"))\n+\t\t (eq_attr \"type\" \"lea\"))\n+\t    (eq_attr \"op_mem\" \"i0,i1\"))\n+       (eq_attr \"size\" \"3\"))\n   \"cf_ib3+cfv123_lea_i0\")\n \n-(define_insn_reservation \"cfv12_pea_11_1\" 0\n+(define_insn_reservation \"cfv12_pea_11_1\" 1\n   (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n-\t\t (eq_attr \"type2\" \"pea\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 1)))\n-       (eq_attr \"op_mem\" \"11\"))\n+\t\t (eq_attr \"type\" \"pea\"))\n+\t    (eq_attr \"op_mem\" \"11\"))\n+       (eq_attr \"size\" \"1\"))\n   \"cf_ib1+cfv12_pea_11\")\n \n-(define_insn_reservation \"cfv12_pea_11_2\" 0\n+(define_insn_reservation \"cfv12_pea_11_2\" 1\n   (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n-\t\t (eq_attr \"type2\" \"pea\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n-       (eq_attr \"op_mem\" \"11\"))\n+\t\t (eq_attr \"type\" \"pea\"))\n+\t    (eq_attr \"op_mem\" \"11\"))\n+       (eq_attr \"size\" \"2\"))\n   \"cf_ib2+cfv12_pea_11\")\n \n-(define_insn_reservation \"cfv12_pea_11_3\" 0\n+(define_insn_reservation \"cfv12_pea_11_3\" 1\n   (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n-\t\t (eq_attr \"type2\" \"pea\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n-       (eq_attr \"op_mem\" \"11\"))\n+\t\t (eq_attr \"type\" \"pea\"))\n+\t    (eq_attr \"op_mem\" \"11\"))\n+       (eq_attr \"size\" \"3\"))\n   \"cf_ib3+cfv12_pea_11\")\n \n-(define_insn_reservation \"cfv3_pea_11_1\" 0\n+(define_insn_reservation \"cfv3_pea_11_1\" 1\n   (and (and (and (eq_attr \"cpu\" \"cfv3\")\n-\t\t (eq_attr \"type2\" \"pea\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 1)))\n-       (eq_attr \"op_mem\" \"11\"))\n+\t\t (eq_attr \"type\" \"pea\"))\n+\t    (eq_attr \"op_mem\" \"11\"))\n+       (eq_attr \"size\" \"1\"))\n   \"cf_ib1+cfv3_pea_11\")\n \n-(define_insn_reservation \"cfv3_pea_11_2\" 0\n+(define_insn_reservation \"cfv3_pea_11_2\" 1\n   (and (and (and (eq_attr \"cpu\" \"cfv3\")\n-\t\t (eq_attr \"type2\" \"pea\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n-       (eq_attr \"op_mem\" \"11\"))\n+\t\t (eq_attr \"type\" \"pea\"))\n+\t    (eq_attr \"op_mem\" \"11\"))\n+       (eq_attr \"size\" \"2\"))\n   \"cf_ib2+cfv3_pea_11\")\n \n-(define_insn_reservation \"cfv3_pea_11_3\" 0\n+(define_insn_reservation \"cfv3_pea_11_3\" 1\n   (and (and (and (eq_attr \"cpu\" \"cfv3\")\n-\t\t (eq_attr \"type2\" \"pea\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n-       (eq_attr \"op_mem\" \"11\"))\n+\t\t (eq_attr \"type\" \"pea\"))\n+\t    (eq_attr \"op_mem\" \"11\"))\n+       (eq_attr \"size\" \"3\"))\n   \"cf_ib3+cfv3_pea_11\")\n \n-(define_insn_reservation \"cfv12_pea_i1_2\" 0\n+(define_insn_reservation \"cfv12_pea_i1_2\" 2\n   (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n-\t\t (eq_attr \"type2\" \"pea\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n-       (eq_attr \"op_mem\" \"i1\"))\n+\t\t (eq_attr \"type\" \"pea\"))\n+\t    (eq_attr \"op_mem\" \"i1\"))\n+       (eq_attr \"size\" \"1,2\"))\n   \"cf_ib2+cfv12_pea_i1\")\n \n-(define_insn_reservation \"cfv12_pea_i1_3\" 0\n+(define_insn_reservation \"cfv12_pea_i1_3\" 2\n   (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n-\t\t (eq_attr \"type2\" \"pea\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n-       (eq_attr \"op_mem\" \"i1\"))\n+\t\t (eq_attr \"type\" \"pea\"))\n+\t    (eq_attr \"op_mem\" \"i1\"))\n+       (eq_attr \"size\" \"3\"))\n   \"cf_ib3+cfv12_pea_i1\")\n \n-(define_insn_reservation \"cfv3_pea_i1_2\" 0\n+(define_insn_reservation \"cfv3_pea_i1_2\" 2\n   (and (and (and (eq_attr \"cpu\" \"cfv3\")\n-\t\t (eq_attr \"type2\" \"pea\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n-       (eq_attr \"op_mem\" \"i1\"))\n+\t\t (eq_attr \"type\" \"pea\"))\n+\t    (eq_attr \"op_mem\" \"i1\"))\n+       (eq_attr \"size\" \"1,2\"))\n   \"cf_ib2+cfv3_pea_i1\")\n \n-(define_insn_reservation \"cfv3_pea_i1_3\" 0\n+(define_insn_reservation \"cfv3_pea_i1_3\" 2\n   (and (and (and (eq_attr \"cpu\" \"cfv3\")\n-\t\t (eq_attr \"type2\" \"pea\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n-       (eq_attr \"op_mem\" \"i1\"))\n+\t\t (eq_attr \"type\" \"pea\"))\n+\t    (eq_attr \"op_mem\" \"i1\"))\n+       (eq_attr \"size\" \"3\"))\n   \"cf_ib3+cfv3_pea_i1\")\n \n (define_insn_reservation \"cfv123_mul_l_00_1\" 18\n   (and (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2,cfv3\")\n \t\t      (eq_attr \"mac\" \"no\"))\n-\t\t (eq_attr \"type2\" \"mul_l\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 1)))\n-       (eq_attr \"op_mem\" \"00\"))\n+\t\t (eq_attr \"type\" \"mul_l\"))\n+\t    (eq_attr \"op_mem\" \"00,01,0i\"))\n+       (eq_attr \"size\" \"1\"))\n   \"cf_ib1+cfv123_mul_l_00\")\n \n (define_insn_reservation \"cfv123_mul_l_00_2\" 18\n   (and (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2,cfv3\")\n \t\t      (eq_attr \"mac\" \"no\"))\n-\t\t (eq_attr \"type2\" \"mul_l\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n-       (eq_attr \"op_mem\" \"00\"))\n+\t\t (eq_attr \"type\" \"mul_l\"))\n+\t    (eq_attr \"op_mem\" \"00,01,0i\"))\n+       (eq_attr \"size\" \"2\"))\n   \"cf_ib2+cfv123_mul_l_00\")\n \n (define_insn_reservation \"cfv123_mul_l_00_3\" 18\n   (and (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2,cfv3\")\n \t\t      (eq_attr \"mac\" \"no\"))\n-\t\t (eq_attr \"type2\" \"mul_l\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n-       (eq_attr \"op_mem\" \"00\"))\n+\t\t (eq_attr \"type\" \"mul_l\"))\n+\t    (eq_attr \"op_mem\" \"00,01,0i\"))\n+       (eq_attr \"size\" \"3\"))\n   \"cf_ib3+cfv123_mul_l_00\")\n \n (define_insn_reservation \"cfv123_mul_w_00_1\" 9\n   (and (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2,cfv3\")\n \t\t      (eq_attr \"mac\" \"no\"))\n-\t\t (eq_attr \"type2\" \"mul_w\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 1)))\n-       (eq_attr \"op_mem\" \"00\"))\n+\t\t (eq_attr \"type\" \"mul_w\"))\n+\t    (eq_attr \"op_mem\" \"00,01,0i\"))\n+       (eq_attr \"size\" \"1\"))\n   \"cf_ib1+cfv123_mul_w_00\")\n \n (define_insn_reservation \"cfv123_mul_w_00_2\" 9\n   (and (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2,cfv3\")\n \t\t      (eq_attr \"mac\" \"no\"))\n-\t\t (eq_attr \"type2\" \"mul_w\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n-       (eq_attr \"op_mem\" \"00\"))\n+\t\t (eq_attr \"type\" \"mul_w\"))\n+\t    (eq_attr \"op_mem\" \"00,01,0i\"))\n+       (eq_attr \"size\" \"2\"))\n   \"cf_ib2+cfv123_mul_w_00\")\n \n (define_insn_reservation \"cfv123_mul_w_00_3\" 9\n   (and (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2,cfv3\")\n \t\t      (eq_attr \"mac\" \"no\"))\n-\t\t (eq_attr \"type2\" \"mul_w\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n-       (eq_attr \"op_mem\" \"00\"))\n+\t\t (eq_attr \"type\" \"mul_w\"))\n+\t    (eq_attr \"op_mem\" \"00,01,0i\"))\n+       (eq_attr \"size\" \"3\"))\n   \"cf_ib3+cfv123_mul_w_00\")\n \n (define_insn_reservation \"cfv12_mul_l_10_1\" 20\n   (and (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n \t\t      (eq_attr \"mac\" \"no\"))\n-\t\t (eq_attr \"type2\" \"mul_l\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 1)))\n-       (eq_attr \"op_mem\" \"10\"))\n+\t\t (eq_attr \"type\" \"mul_l\"))\n+\t    (eq_attr \"op_mem\" \"10,i0,i1,11,1i\"))\n+       (eq_attr \"size\" \"1\"))\n   \"cf_ib1+cfv12_mul_l_10\")\n \n (define_insn_reservation \"cfv12_mul_l_10_2\" 20\n   (and (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n \t\t      (eq_attr \"mac\" \"no\"))\n-\t\t (eq_attr \"type2\" \"mul_l\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n-       (eq_attr \"op_mem\" \"10\"))\n+\t\t (eq_attr \"type\" \"mul_l\"))\n+\t    (eq_attr \"op_mem\" \"10,i0,i1,11,1i\"))\n+       (eq_attr \"size\" \"2\"))\n   \"cf_ib2+cfv12_mul_l_10\")\n \n (define_insn_reservation \"cfv12_mul_l_10_3\" 20\n   (and (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n \t\t      (eq_attr \"mac\" \"no\"))\n-\t\t (eq_attr \"type2\" \"mul_l\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n-       (eq_attr \"op_mem\" \"10\"))\n+\t\t (eq_attr \"type\" \"mul_l\"))\n+\t    (eq_attr \"op_mem\" \"10,i0,i1,11,1i\"))\n+       (eq_attr \"size\" \"3\"))\n   \"cf_ib3+cfv12_mul_l_10\")\n \n (define_insn_reservation \"cfv3_mul_l_10_1\" 21\n   (and (and (and (and (eq_attr \"cpu\" \"cfv3\")\n \t\t      (eq_attr \"mac\" \"no\"))\n-\t\t (eq_attr \"type2\" \"mul_l\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 1)))\n-       (eq_attr \"op_mem\" \"10\"))\n+\t\t (eq_attr \"type\" \"mul_l\"))\n+\t    (eq_attr \"op_mem\" \"10,i0,i1,11,1i\"))\n+       (eq_attr \"size\" \"1\"))\n   \"cf_ib1+cfv3_mul_l_10\")\n \n (define_insn_reservation \"cfv3_mul_l_10_2\" 21\n   (and (and (and (and (eq_attr \"cpu\" \"cfv3\")\n \t\t      (eq_attr \"mac\" \"no\"))\n-\t\t (eq_attr \"type2\" \"mul_l\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n-       (eq_attr \"op_mem\" \"10\"))\n+\t\t (eq_attr \"type\" \"mul_l\"))\n+\t    (eq_attr \"op_mem\" \"10,i0,i1,11,1i\"))\n+       (eq_attr \"size\" \"2\"))\n   \"cf_ib2+cfv3_mul_l_10\")\n \n (define_insn_reservation \"cfv3_mul_l_10_3\" 21\n   (and (and (and (and (eq_attr \"cpu\" \"cfv3\")\n \t\t      (eq_attr \"mac\" \"no\"))\n-\t\t (eq_attr \"type2\" \"mul_l\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n-       (eq_attr \"op_mem\" \"10\"))\n+\t\t (eq_attr \"type\" \"mul_l\"))\n+\t    (eq_attr \"op_mem\" \"10,i0,i1,11,1i\"))\n+       (eq_attr \"size\" \"3\"))\n   \"cf_ib3+cfv3_mul_l_10\")\n \n (define_insn_reservation \"cfv12_mul_w_10_1\" 11\n   (and (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n \t\t      (eq_attr \"mac\" \"no\"))\n-\t\t (eq_attr \"type2\" \"mul_w\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 1)))\n-       (eq_attr \"op_mem\" \"10\"))\n+\t\t (eq_attr \"type\" \"mul_w\"))\n+\t    (eq_attr \"op_mem\" \"10,11,1i\"))\n+       (eq_attr \"size\" \"1\"))\n   \"cf_ib1+cfv12_mul_w_10\")\n \n (define_insn_reservation \"cfv12_mul_w_10_2\" 11\n   (and (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n \t\t      (eq_attr \"mac\" \"no\"))\n-\t\t (eq_attr \"type2\" \"mul_w\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n-       (eq_attr \"op_mem\" \"10\"))\n+\t\t (eq_attr \"type\" \"mul_w\"))\n+\t    (eq_attr \"op_mem\" \"10,11,1i\"))\n+       (eq_attr \"size\" \"2\"))\n   \"cf_ib2+cfv12_mul_w_10\")\n \n (define_insn_reservation \"cfv12_mul_w_10_3\" 11\n   (and (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n \t\t      (eq_attr \"mac\" \"no\"))\n-\t\t (eq_attr \"type2\" \"mul_w\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n-       (eq_attr \"op_mem\" \"10\"))\n+\t\t (eq_attr \"type\" \"mul_w\"))\n+\t    (eq_attr \"op_mem\" \"10,11,1i\"))\n+       (eq_attr \"size\" \"3\"))\n   \"cf_ib3+cfv12_mul_w_10\")\n \n (define_insn_reservation \"cfv3_mul_w_10_1\" 12\n   (and (and (and (and (eq_attr \"cpu\" \"cfv3\")\n \t\t      (eq_attr \"mac\" \"no\"))\n-\t\t (eq_attr \"type2\" \"mul_w\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 1)))\n-       (eq_attr \"op_mem\" \"10\"))\n+\t\t (eq_attr \"type\" \"mul_w\"))\n+\t    (eq_attr \"op_mem\" \"10,11,1i\"))\n+       (eq_attr \"size\" \"1\"))\n   \"cf_ib1+cfv3_mul_w_10\")\n \n (define_insn_reservation \"cfv3_mul_w_10_2\" 12\n   (and (and (and (and (eq_attr \"cpu\" \"cfv3\")\n \t\t      (eq_attr \"mac\" \"no\"))\n-\t\t (eq_attr \"type2\" \"mul_w\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n-       (eq_attr \"op_mem\" \"10\"))\n+\t\t (eq_attr \"type\" \"mul_w\"))\n+\t    (eq_attr \"op_mem\" \"10,11,1i\"))\n+       (eq_attr \"size\" \"2\"))\n   \"cf_ib2+cfv3_mul_w_10\")\n \n (define_insn_reservation \"cfv3_mul_w_10_3\" 12\n   (and (and (and (and (eq_attr \"cpu\" \"cfv3\")\n \t\t      (eq_attr \"mac\" \"no\"))\n-\t\t (eq_attr \"type2\" \"mul_w\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n-       (eq_attr \"op_mem\" \"10\"))\n+\t\t (eq_attr \"type\" \"mul_w\"))\n+\t    (eq_attr \"op_mem\" \"10,11,1i\"))\n+       (eq_attr \"size\" \"3\"))\n   \"cf_ib3+cfv3_mul_w_10\")\n \n (define_insn_reservation \"cfv12_mul_w_i0_2\" 12\n   (and (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n \t\t      (eq_attr \"mac\" \"no\"))\n-\t\t (eq_attr \"type2\" \"mul_w\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n-       (eq_attr \"op_mem\" \"i0\"))\n+\t\t (eq_attr \"type\" \"mul_w\"))\n+\t    (eq_attr \"op_mem\" \"i0,i1\"))\n+       (eq_attr \"size\" \"1,2\"))\n   \"cf_ib2+cfv12_mul_w_i0\")\n \n (define_insn_reservation \"cfv12_mul_w_i0_3\" 12\n   (and (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n \t\t      (eq_attr \"mac\" \"no\"))\n-\t\t (eq_attr \"type2\" \"mul_w\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n-       (eq_attr \"op_mem\" \"i0\"))\n+\t\t (eq_attr \"type\" \"mul_w\"))\n+\t    (eq_attr \"op_mem\" \"i0,i1\"))\n+       (eq_attr \"size\" \"3\"))\n   \"cf_ib3+cfv12_mul_w_i0\")\n \n-\n (define_insn_reservation \"cfv3_mul_w_i0_2\" 13\n   (and (and (and (and (eq_attr \"cpu\" \"cfv3\")\n \t\t      (eq_attr \"mac\" \"no\"))\n-\t\t (eq_attr \"type2\" \"mul_w\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n-       (eq_attr \"op_mem\" \"i0\"))\n+\t\t (eq_attr \"type\" \"mul_w\"))\n+\t    (eq_attr \"op_mem\" \"i0,i1\"))\n+       (eq_attr \"size\" \"1,2\"))\n   \"cf_ib2+cfv3_mul_w_i0\")\n \n (define_insn_reservation \"cfv3_mul_w_i0_3\" 13\n   (and (and (and (and (eq_attr \"cpu\" \"cfv3\")\n \t\t      (eq_attr \"mac\" \"no\"))\n-\t\t (eq_attr \"type2\" \"mul_w\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n-       (eq_attr \"op_mem\" \"i0\"))\n+\t\t (eq_attr \"type\" \"mul_w\"))\n+\t    (eq_attr \"op_mem\" \"i0,i1\"))\n+       (eq_attr \"size\" \"3\"))\n   \"cf_ib3+cfv3_mul_w_i0\")\n \n (define_insn_reservation \"cfv123_mac_l_00_1\" 5\n   (and (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2,cfv3\")\n \t\t      (eq_attr \"mac\" \"cf_mac\"))\n-\t\t (eq_attr \"type2\" \"mul_l\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 1)))\n-       (eq_attr \"op_mem\" \"00\"))\n+\t\t (eq_attr \"type\" \"mul_l\"))\n+\t    (eq_attr \"op_mem\" \"00,01,0i\"))\n+       (eq_attr \"size\" \"1\"))\n   \"cf_ib1+cfv123_mac_l_00\")\n \n (define_insn_reservation \"cfv123_mac_l_00_2\" 5\n   (and (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2,cfv3\")\n \t\t      (eq_attr \"mac\" \"cf_mac\"))\n-\t\t (eq_attr \"type2\" \"mul_l\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n-       (eq_attr \"op_mem\" \"00\"))\n+\t\t (eq_attr \"type\" \"mul_l\"))\n+\t    (eq_attr \"op_mem\" \"00,01,0i\"))\n+       (eq_attr \"size\" \"2\"))\n   \"cf_ib2+cfv123_mac_l_00\")\n \n (define_insn_reservation \"cfv123_mac_l_00_3\" 5\n   (and (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2,cfv3\")\n \t\t      (eq_attr \"mac\" \"cf_mac\"))\n-\t\t (eq_attr \"type2\" \"mul_l\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n-       (eq_attr \"op_mem\" \"00\"))\n+\t\t (eq_attr \"type\" \"mul_l\"))\n+\t    (eq_attr \"op_mem\" \"00,01,0i\"))\n+       (eq_attr \"size\" \"3\"))\n   \"cf_ib3+cfv123_mac_l_00\")\n \n (define_insn_reservation \"cfv123_mac_w_00_1\" 3\n   (and (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2,cfv3\")\n \t\t      (eq_attr \"mac\" \"cf_mac\"))\n-\t\t (eq_attr \"type2\" \"mul_w\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 1)))\n-       (eq_attr \"op_mem\" \"00\"))\n+\t\t (eq_attr \"type\" \"mul_w\"))\n+\t    (eq_attr \"op_mem\" \"00,01,0i\"))\n+       (eq_attr \"size\" \"1\"))\n   \"cf_ib1+cfv123_mac_w_00\")\n \n (define_insn_reservation \"cfv123_mac_w_00_2\" 3\n   (and (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2,cfv3\")\n \t\t      (eq_attr \"mac\" \"cf_mac\"))\n-\t\t (eq_attr \"type2\" \"mul_w\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n-       (eq_attr \"op_mem\" \"00\"))\n+\t\t (eq_attr \"type\" \"mul_w\"))\n+\t    (eq_attr \"op_mem\" \"00,01,0i\"))\n+       (eq_attr \"size\" \"2\"))\n   \"cf_ib2+cfv123_mac_w_00\")\n \n (define_insn_reservation \"cfv123_mac_w_00_3\" 3\n   (and (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2,cfv3\")\n \t\t      (eq_attr \"mac\" \"cf_mac\"))\n-\t\t (eq_attr \"type2\" \"mul_w\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n-       (eq_attr \"op_mem\" \"00\"))\n+\t\t (eq_attr \"type\" \"mul_w\"))\n+\t    (eq_attr \"op_mem\" \"00,01,0i\"))\n+       (eq_attr \"size\" \"3\"))\n   \"cf_ib3+cfv123_mac_w_00\")\n \n (define_insn_reservation \"cfv12_mac_l_10_1\" 7\n   (and (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n \t\t      (eq_attr \"mac\" \"cf_mac\"))\n-\t\t (eq_attr \"type2\" \"mul_l\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 1)))\n-       (eq_attr \"op_mem\" \"10\"))\n+\t\t (eq_attr \"type\" \"mul_l\"))\n+\t    (eq_attr \"op_mem\" \"10,i0,i1,11,1i\"))\n+       (eq_attr \"size\" \"1\"))\n   \"cf_ib1+cfv12_mac_l_10\")\n \n (define_insn_reservation \"cfv12_mac_l_10_2\" 7\n   (and (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n \t\t      (eq_attr \"mac\" \"cf_mac\"))\n-\t\t (eq_attr \"type2\" \"mul_l\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n-       (eq_attr \"op_mem\" \"10\"))\n+\t\t (eq_attr \"type\" \"mul_l\"))\n+\t    (eq_attr \"op_mem\" \"10,i0,i1,11,1i\"))\n+       (eq_attr \"size\" \"2\"))\n   \"cf_ib2+cfv12_mac_l_10\")\n \n (define_insn_reservation \"cfv12_mac_l_10_3\" 7\n   (and (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n \t\t      (eq_attr \"mac\" \"cf_mac\"))\n-\t\t (eq_attr \"type2\" \"mul_l\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n-       (eq_attr \"op_mem\" \"10\"))\n+\t\t (eq_attr \"type\" \"mul_l\"))\n+\t    (eq_attr \"op_mem\" \"10,i0,i1,11,1i\"))\n+       (eq_attr \"size\" \"3\"))\n   \"cf_ib3+cfv12_mac_l_10\")\n \n (define_insn_reservation \"cfv3_mac_l_10_1\" 8\n   (and (and (and (and (eq_attr \"cpu\" \"cfv3\")\n \t\t      (eq_attr \"mac\" \"cf_mac\"))\n-\t\t (eq_attr \"type2\" \"mul_l\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 1)))\n-       (eq_attr \"op_mem\" \"10\"))\n+\t\t (eq_attr \"type\" \"mul_l\"))\n+\t    (eq_attr \"op_mem\" \"10,i0,i1,11,1i\"))\n+       (eq_attr \"size\" \"1\"))\n   \"cf_ib1+cfv3_mac_l_10\")\n \n (define_insn_reservation \"cfv3_mac_l_10_2\" 8\n   (and (and (and (and (eq_attr \"cpu\" \"cfv3\")\n \t\t      (eq_attr \"mac\" \"cf_mac\"))\n-\t\t (eq_attr \"type2\" \"mul_l\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n-       (eq_attr \"op_mem\" \"10\"))\n+\t\t (eq_attr \"type\" \"mul_l\"))\n+\t    (eq_attr \"op_mem\" \"10,i0,i1,11,1i\"))\n+       (eq_attr \"size\" \"2\"))\n   \"cf_ib2+cfv3_mac_l_10\")\n \n (define_insn_reservation \"cfv3_mac_l_10_3\" 8\n   (and (and (and (and (eq_attr \"cpu\" \"cfv3\")\n \t\t      (eq_attr \"mac\" \"cf_mac\"))\n-\t\t (eq_attr \"type2\" \"mul_l\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n-       (eq_attr \"op_mem\" \"10\"))\n+\t\t (eq_attr \"type\" \"mul_l\"))\n+\t    (eq_attr \"op_mem\" \"10,i0,i1,11,1i\"))\n+       (eq_attr \"size\" \"3\"))\n   \"cf_ib3+cfv3_mac_l_10\")\n \n (define_insn_reservation \"cfv12_mac_w_10_1\" 5\n   (and (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n \t\t      (eq_attr \"mac\" \"cf_mac\"))\n-\t\t (eq_attr \"type2\" \"mul_w\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 1)))\n-       (eq_attr \"op_mem\" \"10\"))\n+\t\t (eq_attr \"type\" \"mul_w\"))\n+\t    (eq_attr \"op_mem\" \"10,11,1i\"))\n+       (eq_attr \"size\" \"1\"))\n   \"cf_ib1+cfv12_mac_w_10\")\n \n (define_insn_reservation \"cfv12_mac_w_10_2\" 5\n   (and (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n \t\t      (eq_attr \"mac\" \"cf_mac\"))\n-\t\t (eq_attr \"type2\" \"mul_w\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n-       (eq_attr \"op_mem\" \"10\"))\n+\t\t (eq_attr \"type\" \"mul_w\"))\n+\t    (eq_attr \"op_mem\" \"10,11,1i\"))\n+       (eq_attr \"size\" \"2\"))\n   \"cf_ib2+cfv12_mac_w_10\")\n \n (define_insn_reservation \"cfv12_mac_w_10_3\" 5\n   (and (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n \t\t      (eq_attr \"mac\" \"cf_mac\"))\n-\t\t (eq_attr \"type2\" \"mul_w\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n-       (eq_attr \"op_mem\" \"10\"))\n+\t\t (eq_attr \"type\" \"mul_w\"))\n+\t    (eq_attr \"op_mem\" \"10,11,1i\"))\n+       (eq_attr \"size\" \"3\"))\n   \"cf_ib3+cfv12_mac_w_10\")\n \n (define_insn_reservation \"cfv3_mac_w_10_1\" 6\n   (and (and (and (and (eq_attr \"cpu\" \"cfv3\")\n \t\t      (eq_attr \"mac\" \"cf_mac\"))\n-\t\t (eq_attr \"type2\" \"mul_w\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 1)))\n-       (eq_attr \"op_mem\" \"10\"))\n+\t\t (eq_attr \"type\" \"mul_w\"))\n+\t    (eq_attr \"op_mem\" \"10,11,1i\"))\n+       (eq_attr \"size\" \"1\"))\n   \"cf_ib1+cfv3_mac_w_10\")\n \n (define_insn_reservation \"cfv3_mac_w_10_2\" 6\n   (and (and (and (and (eq_attr \"cpu\" \"cfv3\")\n \t\t      (eq_attr \"mac\" \"cf_mac\"))\n-\t\t (eq_attr \"type2\" \"mul_w\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n-       (eq_attr \"op_mem\" \"10\"))\n+\t\t (eq_attr \"type\" \"mul_w\"))\n+\t    (eq_attr \"op_mem\" \"10,11,1i\"))\n+       (eq_attr \"size\" \"2\"))\n   \"cf_ib2+cfv3_mac_w_10\")\n \n (define_insn_reservation \"cfv3_mac_w_10_3\" 6\n   (and (and (and (and (eq_attr \"cpu\" \"cfv3\")\n \t\t      (eq_attr \"mac\" \"cf_mac\"))\n-\t\t (eq_attr \"type2\" \"mul_w\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n-       (eq_attr \"op_mem\" \"10\"))\n+\t\t (eq_attr \"type\" \"mul_w\"))\n+\t    (eq_attr \"op_mem\" \"10,11,1i\"))\n+       (eq_attr \"size\" \"3\"))\n   \"cf_ib3+cfv3_mac_w_10\")\n \n (define_insn_reservation \"cfv12_mac_w_i0_2\" 6\n   (and (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n \t\t      (eq_attr \"mac\" \"cf_mac\"))\n-\t\t (eq_attr \"type2\" \"mul_w\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n-       (eq_attr \"op_mem\" \"i0\"))\n+\t\t (eq_attr \"type\" \"mul_w\"))\n+\t    (eq_attr \"op_mem\" \"i0,i1\"))\n+       (eq_attr \"size\" \"1,2\"))\n   \"cf_ib2+cfv12_mac_w_i0\")\n \n (define_insn_reservation \"cfv12_mac_w_i0_3\" 6\n   (and (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n \t\t      (eq_attr \"mac\" \"cf_mac\"))\n-\t\t (eq_attr \"type2\" \"mul_w\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n-       (eq_attr \"op_mem\" \"i0\"))\n+\t\t (eq_attr \"type\" \"mul_w\"))\n+\t    (eq_attr \"op_mem\" \"i0,i1\"))\n+       (eq_attr \"size\" \"3\"))\n   \"cf_ib3+cfv12_mac_w_i0\")\n \n (define_insn_reservation \"cfv3_mac_w_i0_2\" 7\n   (and (and (and (and (eq_attr \"cpu\" \"cfv3\")\n \t\t      (eq_attr \"mac\" \"cf_mac\"))\n-\t\t (eq_attr \"type2\" \"mul_w\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n-       (eq_attr \"op_mem\" \"i0\"))\n+\t\t (eq_attr \"type\" \"mul_w\"))\n+\t    (eq_attr \"op_mem\" \"i0,i1\"))\n+       (eq_attr \"size\" \"1,2\"))\n   \"cf_ib2+cfv3_mac_w_i0\")\n \n (define_insn_reservation \"cfv3_mac_w_i0_3\" 7\n   (and (and (and (and (eq_attr \"cpu\" \"cfv3\")\n \t\t      (eq_attr \"mac\" \"cf_mac\"))\n-\t\t (eq_attr \"type2\" \"mul_w\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n-       (eq_attr \"op_mem\" \"i0\"))\n+\t\t (eq_attr \"type\" \"mul_w\"))\n+\t    (eq_attr \"op_mem\" \"i0,i1\"))\n+       (eq_attr \"size\" \"3\"))\n   \"cf_ib3+cfv3_mac_w_i0\")\n \n (define_insn_reservation \"cfv123_emac_00_1\" 4\n   (and (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2,cfv3\")\n \t\t      (eq_attr \"mac\" \"cf_emac\"))\n-\t\t (eq_attr \"type2\" \"mul_l,mul_w\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 1)))\n-       (eq_attr \"op_mem\" \"00\"))\n+\t\t (eq_attr \"type\" \"mul_l,mul_w\"))\n+\t    (eq_attr \"op_mem\" \"00,01,0i\"))\n+       (eq_attr \"size\" \"1\"))\n   \"cf_ib1+cfv123_emac_00\")\n \n (define_insn_reservation \"cfv123_emac_00_2\" 4\n   (and (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2,cfv3\")\n \t\t      (eq_attr \"mac\" \"cf_emac\"))\n-\t\t (eq_attr \"type2\" \"mul_l,mul_w\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n-       (eq_attr \"op_mem\" \"00\"))\n+\t\t (eq_attr \"type\" \"mul_l,mul_w\"))\n+\t    (eq_attr \"op_mem\" \"00,01,0i\"))\n+       (eq_attr \"size\" \"2\"))\n   \"cf_ib2+cfv123_emac_00\")\n \n (define_insn_reservation \"cfv123_emac_00_3\" 4\n   (and (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2,cfv3\")\n \t\t      (eq_attr \"mac\" \"cf_emac\"))\n-\t\t (eq_attr \"type2\" \"mul_l,mul_w\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n-       (eq_attr \"op_mem\" \"00\"))\n+\t\t (eq_attr \"type\" \"mul_l,mul_w\"))\n+\t    (eq_attr \"op_mem\" \"00,01,0i\"))\n+       (eq_attr \"size\" \"3\"))\n   \"cf_ib3+cfv123_emac_00\")\n \n-(define_insn_reservation \"cfv12_emac_10_1\" 6\n+(define_insn_reservation \"cfv12_emac_l_10_1\" 6\n   (and (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n \t\t      (eq_attr \"mac\" \"cf_emac\"))\n-\t\t (eq_attr \"type2\" \"mul_l,mul_w\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 1)))\n-       (eq_attr \"op_mem\" \"10\"))\n+\t\t (eq_attr \"type\" \"mul_l\"))\n+\t    (eq_attr \"op_mem\" \"10,i0,i1,11,1i\"))\n+       (eq_attr \"size\" \"1\"))\n   \"cf_ib1+cfv12_emac_10\")\n \n-(define_insn_reservation \"cfv12_emac_10_2\" 6\n+(define_insn_reservation \"cfv12_emac_l_10_2\" 6\n   (and (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n \t\t      (eq_attr \"mac\" \"cf_emac\"))\n-\t\t (eq_attr \"type2\" \"mul_l,mul_w\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n-       (eq_attr \"op_mem\" \"10\"))\n+\t\t (eq_attr \"type\" \"mul_l\"))\n+\t    (eq_attr \"op_mem\" \"10,i0,i1,11,1i\"))\n+       (eq_attr \"size\" \"2\"))\n   \"cf_ib2+cfv12_emac_10\")\n \n-(define_insn_reservation \"cfv12_emac_10_3\" 6\n+(define_insn_reservation \"cfv12_emac_l_10_3\" 6\n   (and (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n \t\t      (eq_attr \"mac\" \"cf_emac\"))\n-\t\t (eq_attr \"type2\" \"mul_l,mul_w\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n-       (eq_attr \"op_mem\" \"10\"))\n+\t\t (eq_attr \"type\" \"mul_l\"))\n+\t    (eq_attr \"op_mem\" \"10,i0,i1,11,1i\"))\n+       (eq_attr \"size\" \"3\"))\n   \"cf_ib3+cfv12_emac_10\")\n \n-(define_insn_reservation \"cfv3_emac_10_1\" 7\n+(define_insn_reservation \"cfv3_emac_l_10_1\" 7\n   (and (and (and (and (eq_attr \"cpu\" \"cfv3\")\n \t\t      (eq_attr \"mac\" \"cf_emac\"))\n-\t\t (eq_attr \"type2\" \"mul_l,mul_w\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 1)))\n-       (eq_attr \"op_mem\" \"10\"))\n+\t\t (eq_attr \"type\" \"mul_l\"))\n+\t    (eq_attr \"op_mem\" \"10,i0,i1,11,1i\"))\n+       (eq_attr \"size\" \"1\"))\n   \"cf_ib1+cfv3_emac_10\")\n \n-(define_insn_reservation \"cfv3_emac_10_2\" 7\n+(define_insn_reservation \"cfv3_emac_l_10_2\" 7\n   (and (and (and (and (eq_attr \"cpu\" \"cfv3\")\n \t\t      (eq_attr \"mac\" \"cf_emac\"))\n-\t\t (eq_attr \"type2\" \"mul_l,mul_w\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n-       (eq_attr \"op_mem\" \"10\"))\n+\t\t (eq_attr \"type\" \"mul_l\"))\n+\t    (eq_attr \"op_mem\" \"10,i0,i1,11,1i\"))\n+       (eq_attr \"size\" \"2\"))\n   \"cf_ib2+cfv3_emac_10\")\n \n-(define_insn_reservation \"cfv3_emac_10_3\" 7\n+(define_insn_reservation \"cfv3_emac_l_10_3\" 7\n   (and (and (and (and (eq_attr \"cpu\" \"cfv3\")\n \t\t      (eq_attr \"mac\" \"cf_emac\"))\n-\t\t (eq_attr \"type2\" \"mul_l,mul_w\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n-       (eq_attr \"op_mem\" \"10\"))\n+\t\t (eq_attr \"type\" \"mul_l\"))\n+\t    (eq_attr \"op_mem\" \"10,i0,i1,11,1i\"))\n+       (eq_attr \"size\" \"3\"))\n+  \"cf_ib3+cfv3_emac_10\")\n+\n+(define_insn_reservation \"cfv12_emac_w_10_1\" 6\n+  (and (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n+\t\t      (eq_attr \"mac\" \"cf_emac\"))\n+\t\t (eq_attr \"type\" \"mul_w\"))\n+\t    (eq_attr \"op_mem\" \"10,11,1i\"))\n+       (eq_attr \"size\" \"1\"))\n+  \"cf_ib1+cfv12_emac_10\")\n+\n+(define_insn_reservation \"cfv12_emac_w_10_2\" 6\n+  (and (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n+\t\t      (eq_attr \"mac\" \"cf_emac\"))\n+\t\t (eq_attr \"type\" \"mul_w\"))\n+\t    (eq_attr \"op_mem\" \"10,11,1i\"))\n+       (eq_attr \"size\" \"2\"))\n+  \"cf_ib2+cfv12_emac_10\")\n+\n+(define_insn_reservation \"cfv12_emac_w_10_3\" 6\n+  (and (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n+\t\t      (eq_attr \"mac\" \"cf_emac\"))\n+\t\t (eq_attr \"type\" \"mul_w\"))\n+\t    (eq_attr \"op_mem\" \"10,11,1i\"))\n+       (eq_attr \"size\" \"3\"))\n+  \"cf_ib3+cfv12_emac_10\")\n+\n+(define_insn_reservation \"cfv3_emac_w_10_1\" 7\n+  (and (and (and (and (eq_attr \"cpu\" \"cfv3\")\n+\t\t      (eq_attr \"mac\" \"cf_emac\"))\n+\t\t (eq_attr \"type\" \"mul_w\"))\n+\t    (eq_attr \"op_mem\" \"10,11,1i\"))\n+       (eq_attr \"size\" \"1\"))\n+  \"cf_ib1+cfv3_emac_10\")\n+\n+(define_insn_reservation \"cfv3_emac_w_10_2\" 7\n+  (and (and (and (and (eq_attr \"cpu\" \"cfv3\")\n+\t\t      (eq_attr \"mac\" \"cf_emac\"))\n+\t\t (eq_attr \"type\" \"mul_w\"))\n+\t    (eq_attr \"op_mem\" \"10,11,1i\"))\n+       (eq_attr \"size\" \"2\"))\n+  \"cf_ib2+cfv3_emac_10\")\n+\n+(define_insn_reservation \"cfv3_emac_w_10_3\" 7\n+  (and (and (and (and (eq_attr \"cpu\" \"cfv3\")\n+\t\t      (eq_attr \"mac\" \"cf_emac\"))\n+\t\t (eq_attr \"type\" \"mul_w\"))\n+\t    (eq_attr \"op_mem\" \"10,11,1i\"))\n+       (eq_attr \"size\" \"3\"))\n   \"cf_ib3+cfv3_emac_10\")\n \n (define_insn_reservation \"cfv12_emac_w_i0_2\" 7\n   (and (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n \t\t      (eq_attr \"mac\" \"cf_emac\"))\n-\t\t (eq_attr \"type2\" \"mul_w\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n-       (eq_attr \"op_mem\" \"i0\"))\n+\t\t (eq_attr \"type\" \"mul_w\"))\n+\t    (eq_attr \"op_mem\" \"i0,i1\"))\n+       (eq_attr \"size\" \"1,2\"))\n   \"cf_ib2+cfv12_emac_w_i0\")\n \n (define_insn_reservation \"cfv12_emac_w_i0_3\" 7\n   (and (and (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n \t\t      (eq_attr \"mac\" \"cf_emac\"))\n-\t\t (eq_attr \"type2\" \"mul_w\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n-       (eq_attr \"op_mem\" \"i0\"))\n+\t\t (eq_attr \"type\" \"mul_w\"))\n+\t    (eq_attr \"op_mem\" \"i0,i1\"))\n+       (eq_attr \"size\" \"3\"))\n   \"cf_ib3+cfv12_emac_w_i0\")\n \n (define_insn_reservation \"cfv3_emac_w_i0_2\" 8\n   (and (and (and (and (eq_attr \"cpu\" \"cfv3\")\n \t\t      (eq_attr \"mac\" \"cf_emac\"))\n-\t\t (eq_attr \"type2\" \"mul_w\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n-       (eq_attr \"op_mem\" \"i0\"))\n+\t\t (eq_attr \"type\" \"mul_w\"))\n+\t    (eq_attr \"op_mem\" \"i0,i1\"))\n+       (eq_attr \"size\" \"1,2\"))\n   \"cf_ib2+cfv3_emac_w_i0\")\n \n (define_insn_reservation \"cfv3_emac_w_i0_3\" 8\n   (and (and (and (and (eq_attr \"cpu\" \"cfv3\")\n \t\t      (eq_attr \"mac\" \"cf_emac\"))\n-\t\t (eq_attr \"type2\" \"mul_w\"))\n-\t    (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n-       (eq_attr \"op_mem\" \"i0\"))\n+\t\t (eq_attr \"type\" \"mul_w\"))\n+\t    (eq_attr \"op_mem\" \"i0,i1\"))\n+       (eq_attr \"size\" \"3\"))\n   \"cf_ib3+cfv3_emac_w_i0\")\n \n-(define_insn_reservation \"cfv12_rts_1\" 5\n-  (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n-\t    (eq_attr \"type2\" \"rts\"))\n-       (eq (symbol_ref \"get_attr_size (insn)\") (const_int 1)))\n+(define_insn_reservation \"cfv12_rts\" 5\n+  (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n+       (eq_attr \"type\" \"rts\"))\n   \"cf_ib1+cfv12_rts\")\n \n-(define_insn_reservation \"cfv3_rts_1\" 8\n-  (and (and (eq_attr \"cpu\" \"cfv3\")\n-\t    (eq_attr \"type2\" \"rts\"))\n-       (eq (symbol_ref \"get_attr_size (insn)\") (const_int 1)))\n+(define_insn_reservation \"cfv3_rts\" 8\n+  (and (eq_attr \"cpu\" \"cfv3\")\n+       (eq_attr \"type\" \"rts\"))\n   \"cf_ib1+cfv3_rts\")\n \n (define_insn_reservation \"cfv12_call_1\" 3\n   (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n-\t    (eq_attr \"type2\" \"call\"))\n-       (eq (symbol_ref \"get_attr_size (insn)\") (const_int 1)))\n+\t    (eq_attr \"type\" \"bsr,jsr\"))\n+       (eq_attr \"size\" \"1\"))\n   \"cf_ib1+cfv12_call\")\n \n (define_insn_reservation \"cfv12_call_2\" 3\n   (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n-\t    (eq_attr \"type2\" \"call\"))\n-       (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n+\t    (eq_attr \"type\" \"bsr,jsr\"))\n+       (eq_attr \"size\" \"2\"))\n   \"cf_ib2+cfv12_call\")\n \n (define_insn_reservation \"cfv12_call_3\" 3\n   (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n-\t    (eq_attr \"type2\" \"call\"))\n-       (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n+\t    (eq_attr \"type\" \"bsr,jsr\"))\n+       (eq_attr \"size\" \"3\"))\n   \"cf_ib3+cfv12_call\")\n \n (define_insn_reservation \"cfv3_call_1\" 1\n   (and (and (eq_attr \"cpu\" \"cfv3\")\n-\t    (eq_attr \"type2\" \"call\"))\n-       (eq (symbol_ref \"get_attr_size (insn)\") (const_int 1)))\n+\t    (eq_attr \"type\" \"bsr,jsr\"))\n+       (eq_attr \"size\" \"1\"))\n   \"cf_ib1+cfv3_call\")\n \n (define_insn_reservation \"cfv3_call_2\" 1\n   (and (and (eq_attr \"cpu\" \"cfv3\")\n-\t    (eq_attr \"type2\" \"call\"))\n-       (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n+\t    (eq_attr \"type\" \"bsr,jsr\"))\n+       (eq_attr \"size\" \"2\"))\n   \"cf_ib2+cfv3_call\")\n \n (define_insn_reservation \"cfv3_call_3\" 1\n   (and (and (eq_attr \"cpu\" \"cfv3\")\n-\t    (eq_attr \"type2\" \"call\"))\n-       (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n+\t    (eq_attr \"type\" \"bsr,jsr\"))\n+       (eq_attr \"size\" \"3\"))\n   \"cf_ib3+cfv3_call\")\n \n (define_insn_reservation \"cfv12_bcc_1\" 2\n   (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n-\t    (eq_attr \"type2\" \"bcc\"))\n-       (eq (symbol_ref \"get_attr_size (insn)\") (const_int 1)))\n+\t    (eq_attr \"type\" \"bcc\"))\n+       (eq_attr \"size\" \"1\"))\n   \"cf_ib1+cfv12_bcc\")\n \n (define_insn_reservation \"cfv12_bcc_2\" 2\n   (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n-\t    (eq_attr \"type2\" \"bcc\"))\n-       (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n+\t    (eq_attr \"type\" \"bcc\"))\n+       (eq_attr \"size\" \"2\"))\n   \"cf_ib2+cfv12_bcc\")\n \n (define_insn_reservation \"cfv12_bcc_3\" 2\n   (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n-\t    (eq_attr \"type2\" \"bcc\"))\n-       (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n+\t    (eq_attr \"type\" \"bcc\"))\n+       (eq_attr \"size\" \"3\"))\n   \"cf_ib3+cfv12_bcc\")\n \n (define_insn_reservation \"cfv3_bcc_1\" 1\n   (and (and (eq_attr \"cpu\" \"cfv3\")\n-\t    (eq_attr \"type2\" \"bcc\"))\n-       (eq (symbol_ref \"get_attr_size (insn)\") (const_int 1)))\n+\t    (eq_attr \"type\" \"bcc\"))\n+       (eq_attr \"size\" \"1\"))\n   \"cf_ib1+cfv3_bcc\")\n \n (define_insn_reservation \"cfv3_bcc_2\" 1\n   (and (and (eq_attr \"cpu\" \"cfv3\")\n-\t    (eq_attr \"type2\" \"bcc\"))\n-       (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n+\t    (eq_attr \"type\" \"bcc\"))\n+       (eq_attr \"size\" \"2\"))\n   \"cf_ib2+cfv3_bcc\")\n \n (define_insn_reservation \"cfv3_bcc_3\" 1\n   (and (and (eq_attr \"cpu\" \"cfv3\")\n-\t    (eq_attr \"type2\" \"bcc\"))\n-       (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n+\t    (eq_attr \"type\" \"bcc\"))\n+       (eq_attr \"size\" \"3\"))\n   \"cf_ib3+cfv3_bcc\")\n \n (define_insn_reservation \"cfv12_bra_1\" 2\n   (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n-\t    (eq_attr \"type2\" \"bra\"))\n-       (eq (symbol_ref \"get_attr_size (insn)\") (const_int 1)))\n+\t    (eq_attr \"type\" \"bra\"))\n+       (eq_attr \"size\" \"1\"))\n   \"cf_ib1+cfv12_bra\")\n \n (define_insn_reservation \"cfv12_bra_2\" 2\n   (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n-\t    (eq_attr \"type2\" \"bra\"))\n-       (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n+\t    (eq_attr \"type\" \"bra\"))\n+       (eq_attr \"size\" \"2\"))\n   \"cf_ib2+cfv12_bra\")\n \n (define_insn_reservation \"cfv12_bra_3\" 2\n   (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n-\t    (eq_attr \"type2\" \"bra\"))\n-       (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n+\t    (eq_attr \"type\" \"bra\"))\n+       (eq_attr \"size\" \"3\"))\n   \"cf_ib3+cfv12_bra\")\n \n (define_insn_reservation \"cfv3_bra_1\" 1\n   (and (and (eq_attr \"cpu\" \"cfv3\")\n-\t    (eq_attr \"type2\" \"bra\"))\n-       (eq (symbol_ref \"get_attr_size (insn)\") (const_int 1)))\n+\t    (eq_attr \"type\" \"bra\"))\n+       (eq_attr \"size\" \"1\"))\n   \"cf_ib1+cfv3_bra\")\n \n (define_insn_reservation \"cfv3_bra_2\" 1\n   (and (and (eq_attr \"cpu\" \"cfv3\")\n-\t    (eq_attr \"type2\" \"bra\"))\n-       (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n+\t    (eq_attr \"type\" \"bra\"))\n+       (eq_attr \"size\" \"2\"))\n   \"cf_ib2+cfv3_bra\")\n \n (define_insn_reservation \"cfv3_bra_3\" 1\n   (and (and (eq_attr \"cpu\" \"cfv3\")\n-\t    (eq_attr \"type2\" \"bra\"))\n-       (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n+\t    (eq_attr \"type\" \"bra\"))\n+       (eq_attr \"size\" \"3\"))\n   \"cf_ib3+cfv3_bra\")\n \n (define_insn_reservation \"cfv12_jmp_1\" 3\n   (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n-\t    (eq_attr \"type2\" \"jmp\"))\n-       (eq (symbol_ref \"get_attr_size (insn)\") (const_int 1)))\n+\t    (eq_attr \"type\" \"jmp\"))\n+       (eq_attr \"size\" \"1\"))\n   \"cf_ib1+cfv12_jmp\")\n \n (define_insn_reservation \"cfv12_jmp_2\" 3\n   (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n-\t    (eq_attr \"type2\" \"jmp\"))\n-       (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n+\t    (eq_attr \"type\" \"jmp\"))\n+       (eq_attr \"size\" \"2\"))\n   \"cf_ib2+cfv12_jmp\")\n \n (define_insn_reservation \"cfv12_jmp_3\" 3\n   (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n-\t    (eq_attr \"type2\" \"jmp\"))\n-       (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n+\t    (eq_attr \"type\" \"jmp\"))\n+       (eq_attr \"size\" \"3\"))\n   \"cf_ib3+cfv12_jmp\")\n \n (define_insn_reservation \"cfv3_jmp_1\" 5\n   (and (and (eq_attr \"cpu\" \"cfv3\")\n-\t    (eq_attr \"type2\" \"jmp\"))\n-       (eq (symbol_ref \"get_attr_size (insn)\") (const_int 1)))\n+\t    (eq_attr \"type\" \"jmp\"))\n+       (eq_attr \"size\" \"1\"))\n   \"cf_ib1+cfv3_jmp\")\n \n (define_insn_reservation \"cfv3_jmp_2\" 5\n   (and (and (eq_attr \"cpu\" \"cfv3\")\n-\t    (eq_attr \"type2\" \"jmp\"))\n-       (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n+\t    (eq_attr \"type\" \"jmp\"))\n+       (eq_attr \"size\" \"2\"))\n   \"cf_ib2+cfv3_jmp\")\n \n (define_insn_reservation \"cfv3_jmp_3\" 5\n   (and (and (eq_attr \"cpu\" \"cfv3\")\n-\t    (eq_attr \"type2\" \"jmp\"))\n-       (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n+\t    (eq_attr \"type\" \"jmp\"))\n+       (eq_attr \"size\" \"3\"))\n   \"cf_ib3+cfv3_jmp\")\n \n-;; Misc reservations.\n-\n-(define_insn_reservation \"cfv12_unlk_1\" 2\n-  (and (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n-\t    (eq_attr \"type2\" \"unlk\"))\n-       (eq (symbol_ref \"get_attr_size (insn)\") (const_int 1)))\n+(define_insn_reservation \"cfv12_unlk\" 2\n+  (and (eq_attr \"cpu\" \"cfv1,cfv2\")\n+       (eq_attr \"type\" \"unlk\"))\n   \"cf_ib1+cfv12_alu_10\")\n \n-(define_insn_reservation \"cfv3_unlk_1\" 3\n-  (and (and (eq_attr \"cpu\" \"cfv3\")\n-\t    (eq_attr \"type2\" \"unlk\"))\n-       (eq (symbol_ref \"get_attr_size (insn)\") (const_int 1)))\n+(define_insn_reservation \"cfv3_unlk\" 3\n+  (and (eq_attr \"cpu\" \"cfv3\")\n+       (eq_attr \"type\" \"unlk\"))\n   \"cf_ib1+cfv3_alu_10\")\n \n-;; This automaton is used to gather statistics on insns that need reservations.\n-(define_automaton \"cf_guess\")\n+;; Dummy reservation for instructions that are not handled.\n+(define_insn_reservation \"cfv123_guess\" 3\n+  (and (eq_attr \"cpu\" \"cfv1,cfv2,cfv3\")\n+       (eq_attr \"type\" \"falu,fbcc,fcmp,fdiv,fmove,fmul,fneg,fsqrt,ftst,\n+                        div_w,div_l,link,mvsz,nop,trap,unknown\"))\n+  \"cf_ib3+cfv123_guess+cf_dsoc+cf_agex+cf_mem\")\n \n-(define_query_cpu_unit \"cf_guess\" \"cf_guess\")\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n \n-;; Dummy reservation for instructions that are not handled yet.\n+;; Below is pipeline description of ColdFire V4 core.\n+;; It is substantially different from the description of V1, V2 or V3 cores,\n+;; primarily due to no need to model the instruction buffer.\n+;;\n+;; V4 pipeline model uses a completely separate set of cpu units.\n+\n+;; Operand Execution Pipeline.\n+(define_automaton \"cfv4_oep\")\n+\n+(define_cpu_unit \"cfv4_oag,cfv4_oc1,cfv4_oc2,cfv4_ex,cfv4_da\"\n+  \"cfv4_oep\")\n+\n+;; This automaton is used to support CFv4 dual-issue.\n+(define_automaton \"cfv4_ds\")\n+\n+;; V4 has 3 cases of dual-issue.\n+;; After issuing a cfv4_pOEPx instruction, it'll be possible to issue\n+;; a cfv4_sOEPx instruction on the same cycle (see final_presence_sets below).\n+(define_cpu_unit \"cfv4_pOEP1,cfv4_sOEP1,\n+                  cfv4_pOEP2,cfv4_sOEP2,\n+                  cfv4_pOEP3,cfv4_sOEP3\" \"cfv4_ds\")\n+\n+(final_presence_set \"cfv4_sOEP1\" \"cfv4_pOEP1\")\n+(final_presence_set \"cfv4_sOEP2\" \"cfv4_pOEP2\")\n+(final_presence_set \"cfv4_sOEP3\" \"cfv4_pOEP3\")\n+\n+;; Reservation for instructions that don't allow dual-issue.\n+(define_reservation \"cfv4_ds\" \"cfv4_pOEP1+cfv4_sOEP1+\n+                               cfv4_pOEP2+cfv4_sOEP2+\n+                               cfv4_pOEP3+cfv4_sOEP3\")\n+\n+;; Memory access resource.\n+(define_automaton \"cfv4_mem\")\n+\n+(define_cpu_unit \"cfv4_mem\" \"cfv4_mem\")\n+\n+;; EMAC.\n+(define_automaton \"cfv4_emac\")\n+\n+(define_cpu_unit \"cfv4_emac\" \"cfv4_emac\")\n+\n+;; FPU.\n+(define_automaton \"cfv4_fp\")\n+\n+(define_cpu_unit \"cfv4_fp\" \"cfv4_fp\")\n+\n+;; Automaton for unknown instruction.\n+(define_automaton \"cfv4_guess\")\n+\n+(define_query_cpu_unit \"cfv4_guess\" \"cfv4_guess\")\n+\n+;; This bypass allows 1st case of dual-issue.\n+(define_bypass 0 \"cfv4_00_oag_pOEP1,cfv4_10_pOEP1,cfv4_i0_pOEP1\"\n+  \"cfv4_00_oag,cfv4_00_oag_pOEP3_sOEP12,cfv4_00_oag_pOEP1,\n+   cfv4_00_oag_moveql,cfv4_00_ex_sOEP13\")\n+\n+;; The following bypasses decrease the latency of producers if it modifies\n+;; a target register in the EX stage and the consumer also uses\n+;; that register in the EX stage.\n+(define_bypass 1 \"cfv4_00_ex\" \"cfv4_00_ex,cfv4_00_ex_sOEP13\")\n+(define_bypass 1 \"cfv4_00_ex\" \"cfv4_10,cfv4_10_pOEP1,cfv4_i0,cfv4_i0_pOEP1\"\n+  \"!m68k_sched_address_bypass_p\")\n+\n+;; Indexed loads with scale factors 2 and 4 require an update of the index\n+;; register in the register file.  Considering that the index register is\n+;; only needed at the second cycle of address generation, we get\n+;; a latency of 4.\n+;; Producers for indexed loads with scale factor 1 should have\n+;; a latency of 3.  Since we're only allowed one bypass, we handle it\n+;; in the adjust_cost hook.\n+(define_bypass 4\n+  \"cfv4_00_oag,cfv4_00_oag_pOEP3_sOEP12,cfv4_00_oag_lea,cfv4_00_oag_pOEP1,\n+   cfv4_00_oag_moveql\"\n+  \"cfv4_i0,cfv4_i0_pOEP1\"\n+  \"m68k_sched_indexed_address_bypass_p\")\n+\n+;; First part of cfv4_00.\n+;; If issued in pairs with cfv4_movel_?0, the cost should be increased.\n+;; ??? Is it possible that combined cfv4_movel_00 and cfv4_oag_00 instructions\n+;; have longer latency than the two instructions emitted sequentially?\n+;; Due to register renaming, the result of the sequence would be available\n+;; after 3 cycles, instead of 4 for combined instruction?\n+(define_insn_reservation \"cfv4_00_oag\" 1\n+  (and (and (eq_attr \"cpu\" \"cfv4\")\n+\t    (eq_attr \"type\" \"alu_l,aluq_l,clr_l,cmp_l,mov3q_l,neg_l\"))\n+       (eq_attr \"op_mem\" \"00\"))\n+  \"cfv4_sOEP1|cfv4_sOEP3|(cfv4_ds,cfv4_oag,cfv4_oc1,cfv4_oc2,cfv4_ex)\")\n+\n+(define_insn_reservation \"cfv4_00_oag_pOEP3_sOEP12\" 1\n+  (and (and (eq_attr \"cpu\" \"cfv4\")\n+\t    (eq_attr \"type\" \"move_l,mov3q_l,clr_l\"))\n+       (and (eq_attr \"op_mem\" \"00\")\n+\t    (and (eq_attr \"opx_type\" \"Rn\")\n+\t\t (eq_attr \"opy_type\" \"none,imm_q,imm_w,imm_l\"))))\n+  \"cfv4_sOEP1|cfv4_sOEP2|(cfv4_pOEP3,cfv4_oag,cfv4_oc1,cfv4_oc2,cfv4_ex)\")\n+\n+(define_insn_reservation \"cfv4_00_oag_lea\" 1\n+  (and (eq_attr \"cpu\" \"cfv4\")\n+       (eq_attr \"type\" \"lea\"))\n+  \"cfv4_pOEP3,cfv4_oag,cfv4_oc1,cfv4_oc2,cfv4_ex\")\n+\n+(define_insn_reservation \"cfv4_00_oag_pOEP1\" 1\n+  (and (and (eq_attr \"cpu\" \"cfv4\")\n+\t    (eq_attr \"type\" \"move_l,mov3q_l,clr_l\"))\n+       (and (eq_attr \"op_mem\" \"00\")\n+\t    (ior (eq_attr \"opx_type\" \"!Rn\")\n+\t\t (eq_attr \"opy_type\" \"!none,imm_q,imm_w,imm_l\"))))\n+  \"cfv4_sOEP1|(cfv4_pOEP1,cfv4_oag,cfv4_oc1,cfv4_oc2,cfv4_ex)\")\n+\n+(define_insn_reservation \"cfv4_00_oag_moveql\" 1\n+  (and (and (eq_attr \"cpu\" \"cfv4\")\n+\t    (eq_attr \"type\" \"moveq_l\"))\n+       (eq_attr \"op_mem\" \"00\"))\n+  \"cfv4_sOEP1|cfv4_sOEP2|cfv4_sOEP3|(cfv4_pOEP3,cfv4_oag,cfv4_oc1,cfv4_oc2,cfv4_ex)\")\n \n-(define_insn_reservation \"cf_guess_1\" 1\n-  (and (and (eq_attr \"cpu\" \"cfv1,cfv2,cfv3\")\n-\t    (eq_attr \"guess\" \"yes\"))\n-       (eq (symbol_ref \"get_attr_size (insn)\") (const_int 1)))\n-  \"cf_ib1+cf_guess+cf_dsoc+cf_agex\")\n+;; Second part of cfv4_00.\n+;; Latency is either 1 or 4 depending on which stage the consumer\n+;; will need the data.\n \n-(define_insn_reservation \"cf_guess_2\" 1\n-  (and (and (eq_attr \"cpu\" \"cfv1,cfv2,cfv3\")\n-\t    (eq_attr \"guess\" \"yes\"))\n-       (eq (symbol_ref \"get_attr_size (insn)\") (const_int 2)))\n-  \"cf_ib2+cf_guess+cf_dsoc+cf_agex\")\n+(define_insn_reservation \"cfv4_00_ex\" 4\n+  (and (and (eq_attr \"cpu\" \"cfv4\")\n+\t    (eq_attr \"type\" \"bitr,bitrw,clr,cmp,move,mvsz,scc,tst\"))\n+       (eq_attr \"op_mem\" \"00\"))\n+  \"cfv4_ds,cfv4_oag,cfv4_oc1,cfv4_oc2,cfv4_ex\")\n+\n+(define_insn_reservation \"cfv4_00_ex_sOEP13\" 4\n+  (and (and (eq_attr \"cpu\" \"cfv4\")\n+\t    (eq_attr \"type\" \"alux_l,ext,shift,tst_l\"))\n+       (eq_attr \"op_mem\" \"00\"))\n+  \"cfv4_sOEP1|cfv4_sOEP3|(cfv4_ds,cfv4_oag,cfv4_oc1,cfv4_oc2,cfv4_ex)\")\n+\n+;; Several types mentioned in this reservation (e.g., ext and shift) don't\n+;; support implicit load.  But we handle them anyway due to first scheduling\n+;; pass, which handles non-strict rtl.\n+;;\n+;; Latency is either 1 or 4 depending in which stage the consumer\n+;; will need the data.\n+(define_insn_reservation \"cfv4_10\" 4\n+  (and (and (eq_attr \"cpu\" \"cfv4\")\n+\t    (eq_attr \"type\" \"alu_l,aluq_l,alux_l,bitr,bitrw,\n+                             clr,clr_l,cmp,cmp_l,ext,\n+                             mov3q_l,move,moveq_l,mvsz,neg_l,\n+                             shift,tst,tst_l\"))\n+       (eq_attr \"op_mem\" \"10\"))\n+  \"cfv4_ds,cfv4_oag,cfv4_oc1+cfv4_mem,cfv4_oc2,cfv4_ex\")\n+\n+;; Specialization of cfv4_10.\n+;; move.l has OC2-to-DS forwarding path, that saves one cycle of latency.\n+(define_insn_reservation \"cfv4_10_pOEP1\" 3\n+  (and (and (eq_attr \"cpu\" \"cfv4\")\n+\t    (eq_attr \"type\" \"move_l\"))\n+       (eq_attr \"op_mem\" \"10\"))\n+  \"cfv4_pOEP1,cfv4_oag,cfv4_oc1+cfv4_mem,cfv4_oc2,cfv4_ex\")\n+\n+;; Same here.  But +1 to latency due to longer OAG.\n+(define_insn_reservation \"cfv4_i0\" 5\n+  (and (and (eq_attr \"cpu\" \"cfv4\")\n+\t    (eq_attr \"type\" \"alu_l,aluq_l,alux_l,bitr,bitrw,\n+                             clr,clr_l,cmp,cmp_l,ext,\n+                             mov3q_l,move,moveq_l,mvsz,neg_l,\n+                             shift,tst,tst_l\"))\n+       (eq_attr \"op_mem\" \"i0\"))\n+  \"cfv4_ds,cfv4_oag,cfv4_oag,cfv4_oc1+cfv4_mem,cfv4_oc2,cfv4_ex\")\n \n-(define_insn_reservation \"cf_guess_3\" 1\n-  (and (and (eq_attr \"cpu\" \"cfv1,cfv2,cfv3\")\n-\t    (eq_attr \"guess\" \"yes\"))\n-       (eq (symbol_ref \"get_attr_size (insn)\") (const_int 3)))\n-  \"cf_ib3+cf_guess+cf_dsoc+cf_agex\")\n+;; ??? Does indexed load trigger dual-issue?\n+;; ??? Does OC2-to-DS forwarding path saves a cycle?\n+(define_insn_reservation \"cfv4_i0_pOEP1\" 4\n+  (and (and (eq_attr \"cpu\" \"cfv4\")\n+\t    (eq_attr \"type\" \"move_l\"))\n+       (eq_attr \"op_mem\" \"i0\"))\n+  \"cfv4_ds,cfv4_oag,cfv4_oag,cfv4_oc1+cfv4_mem,cfv4_oc2,cfv4_ex\")\n+\n+;; This reservation is for moves and clr.  Arithmetic instructions\n+;; don't write to memory unless they also read from it.\n+;; But, before reload we can have all sorts of things.\n+;; With cfv4_pOEP2 allow dual-issue for type 2 cases.\n+(define_insn_reservation \"cfv4_01\" 1\n+  (and (and (eq_attr \"cpu\" \"cfv4\")\n+\t    (eq_attr \"type\" \"alu_l,aluq_l,alux_l,bitr,bitrw,\n+                             clr,clr_l,cmp,cmp_l,ext,\n+                             mov3q_l,move,move_l,moveq_l,mvsz,neg_l,\n+                             shift\"))\n+       (eq_attr \"op_mem\" \"01\"))\n+  \"cfv4_pOEP2,cfv4_oag,cfv4_oc1,cfv4_oc2,cfv4_ex,cfv4_da,cfv4_mem\")\n+\n+;; ??? Does indexed store trigger dual-issue?\n+(define_insn_reservation \"cfv4_0i\" 2\n+  (and (and (eq_attr \"cpu\" \"cfv4\")\n+\t    (eq_attr \"type\" \"alu_l,aluq_l,alux_l,bitr,bitrw,\n+                             clr,clr_l,cmp,cmp_l,ext,\n+                             mov3q_l,move,move_l,moveq_l,mvsz,neg_l,\n+                             shift\"))\n+       (eq_attr \"op_mem\" \"0i\"))\n+  \"cfv4_pOEP2,cfv4_oag,cfv4_oag,cfv4_oc1,cfv4_oc2,cfv4_ex,cfv4_da,cfv4_mem\")\n+\n+(define_insn_reservation \"cfv4_11\" 1\n+  (and (and (eq_attr \"cpu\" \"cfv4\")\n+\t    (eq_attr \"type\" \"alu_l,aluq_l,alux_l,bitr,bitrw,\n+                             clr,clr_l,cmp,cmp_l,ext,\n+                             mov3q_l,move,move_l,moveq_l,mvsz,neg_l,\n+                             shift\"))\n+       (eq_attr \"op_mem\" \"11\"))\n+  \"cfv4_ds,cfv4_oag,cfv4_oc1+cfv4_mem,cfv4_oc2,cfv4_ex,cfv4_da,cfv4_mem\")\n+\n+;; Latency is 2 due to long OAG stage.\n+(define_insn_reservation \"cfv4_i1\" 2\n+  (and (and (eq_attr \"cpu\" \"cfv4\")\n+\t    (eq_attr \"type\" \"alu_l,aluq_l,alux_l,bitr,bitrw,\n+                             clr,clr_l,cmp,cmp_l,ext,\n+                             mov3q_l,move,move_l,moveq_l,mvsz,neg_l,\n+                             shift\"))\n+       (eq_attr \"op_mem\" \"i1\"))\n+  \"cfv4_ds,cfv4_oag,cfv4_oag,cfv4_oc1+cfv4_mem,cfv4_oc2,cfv4_ex,cfv4_da,cfv4_mem\")\n+\n+;; This one is the same as cfv4_i1.\n+;; ??? Should it be different?\n+(define_insn_reservation \"cfv4_1i\" 2\n+  (and (and (eq_attr \"cpu\" \"cfv4\")\n+\t    (eq_attr \"type\" \"alu_l,aluq_l,alux_l,bitr,bitrw,\n+                             clr,clr_l,cmp,cmp_l,ext,\n+                             mov3q_l,move,move_l,moveq_l,mvsz,neg_l,\n+                             shift\"))\n+       (eq_attr \"op_mem\" \"1i\"))\n+  \"cfv4_ds,cfv4_oag,cfv4_oag,cfv4_oc1+cfv4_mem,cfv4_oc2,cfv4_ex,cfv4_da,cfv4_mem\")\n+\n+;; ??? Does pea indeed support case 2 of dual-issue?\n+(define_insn_reservation \"cfv4_11_pea\" 1\n+  (and (and (eq_attr \"cpu\" \"cfv4\")\n+\t    (eq_attr \"type\" \"pea\"))\n+       (eq_attr \"op_mem\" \"11,00,01,0i,10\"))\n+  \"cfv4_pOEP2,cfv4_oag,cfv4_oc1,cfv4_oc2,cfv4_ex,cfv4_da,cfv4_mem\")\n+\n+;; ??? Does pea indeed support case 2 of dual-issue?\n+;; ??? Does indexed store trigger dual-issue?\n+(define_insn_reservation \"cfv4_i1_pea\" 1\n+  (and (and (eq_attr \"cpu\" \"cfv4\")\n+\t    (eq_attr \"type\" \"pea\"))\n+       (eq_attr \"op_mem\" \"i1,1i\"))\n+  \"cfv4_pOEP2,cfv4_oag,cfv4_oag,cfv4_oc1,cfv4_oc2,cfv4_ex,cfv4_da,cfv4_mem\")\n+\n+(define_insn_reservation \"cfv4_link\" 2\n+  (and (eq_attr \"cpu\" \"cfv4\")\n+       (eq_attr \"type\" \"link\"))\n+  \"cfv4_ds,cfv4_oag,cfv4_oc1,cfv4_oc2,cfv4_ex,cfv4_ex,cfv4_da,cfv4_mem\")\n+\n+(define_insn_reservation \"cfv4_unlink\" 2\n+  (and (eq_attr \"cpu\" \"cfv4\")\n+       (eq_attr \"type\" \"unlk\"))\n+  \"cfv4_ds,cfv4_oag,cfv4_oc1+cfv4_mem,cfv4_oc2,cfv4_ex\")\n+\n+(define_insn_reservation \"cfv4_divw_00\" 20\n+  (and (and (eq_attr \"cpu\" \"cfv4\")\n+\t    (eq_attr \"type\" \"div_w\"))\n+       (eq_attr \"op_mem\" \"00,01,0i\"))\n+  \"cfv4_ds,cfv4_oag,cfv4_oc1,cfv4_oc2,cfv4_ex*15\")\n+\n+(define_insn_reservation \"cfv4_divw_10\" 20\n+  (and (and (eq_attr \"cpu\" \"cfv4\")\n+\t    (eq_attr \"type\" \"div_w\"))\n+       (eq_attr \"op_mem\" \"10,11,1i\"))\n+  \"cfv4_ds,cfv4_oag,cfv4_oc1+cfv4_mem,cfv4_oc2,cfv4_ex*15\")\n+\n+(define_insn_reservation \"cfv4_divw_i0\" 21\n+  (and (and (eq_attr \"cpu\" \"cfv4\")\n+\t    (eq_attr \"type\" \"div_w\"))\n+       (eq_attr \"op_mem\" \"i0,i1\"))\n+  \"cfv4_ds,cfv4_oag,cfv4_oag,cfv4_oc1+cfv4_mem,cfv4_oc2,cfv4_ex*15\")\n+\n+(define_insn_reservation \"cfv4_divl_00\" 35\n+  (and (and (eq_attr \"cpu\" \"cfv4\")\n+\t    (eq_attr \"type\" \"div_l\"))\n+       (eq_attr \"op_mem\" \"00,01,0i\"))\n+  \"cfv4_ds,cfv4_oag,cfv4_oc1,cfv4_oc2,cfv4_ex*30\")\n+\n+(define_insn_reservation \"cfv4_divl_10\" 35\n+  (and (and (eq_attr \"cpu\" \"cfv4\")\n+\t    (eq_attr \"type\" \"div_l\"))\n+       (eq_attr \"op_mem\" \"10,11,1i,i0,i1\"))\n+  \"cfv4_ds,cfv4_oag,cfv4_oc1+cfv4_mem,cfv4_oc2,cfv4_ex*30\")\n+\n+(define_insn_reservation \"cfv4_emac_mul_00\" 7\n+  (and (and (eq_attr \"cpu\" \"cfv4\")\n+\t    (eq_attr \"type\" \"mul_w,mul_l\"))\n+       (eq_attr \"op_mem\" \"00,01,0i\"))\n+  \"cfv4_ds,cfv4_oag,cfv4_oc1,cfv4_oc2,cfv4_ex,cfv4_emac\")\n+\n+(define_insn_reservation \"cfv4_emac_mul_10\" 7\n+  (and (and (eq_attr \"cpu\" \"cfv4\")\n+\t    (eq_attr \"type\" \"mul_w,mul_l\"))\n+       (eq_attr \"op_mem\" \"10,11,1i\"))\n+  \"cfv4_ds,cfv4_oag,cfv4_oc1+cfv4_mem,cfv4_oc2,cfv4_ex,cfv4_emac\")\n+\n+(define_insn_reservation \"cfv4_emac_mul_i0\" 8\n+  (and (and (eq_attr \"cpu\" \"cfv4\")\n+\t    (eq_attr \"type\" \"mul_w,mul_l\"))\n+       (eq_attr \"op_mem\" \"i0,i1\"))\n+  \"cfv4_ds,cfv4_oag,cfv4_oag,cfv4_oc1+cfv4_mem,cfv4_oc2,cfv4_ex,cfv4_emac\")\n+\n+(define_insn_reservation \"cfv4_falu_00\" 7\n+  (and (and (eq_attr \"cpu\" \"cfv4\")\n+\t    (eq_attr \"type\" \"falu,fcmp,fmul\"))\n+       (eq_attr \"op_mem\" \"00,01,0i\"))\n+  \"cfv4_ds,cfv4_oag,cfv4_oc1,cfv4_oc2,cfv4_ex,cfv4_fp\")\n+\n+(define_insn_reservation \"cfv4_falu_10\" 7\n+  (and (and (eq_attr \"cpu\" \"cfv4\")\n+\t    (eq_attr \"type\" \"falu,fcmp,fmul\"))\n+       (eq_attr \"op_mem\" \"10,i0,11,1i,i1\"))\n+  \"cfv4_ds,cfv4_oag,cfv4_oc1+cfv4_mem,cfv4_oc2,cfv4_ex,cfv4_fp\")\n+\n+(define_insn_reservation \"cfv4_fneg_00\" 4\n+  (and (and (eq_attr \"cpu\" \"cfv4\")\n+\t    (eq_attr \"type\" \"fmove,fneg,ftst\"))\n+       (eq_attr \"op_mem\" \"00\"))\n+  \"cfv4_ds,cfv4_oag,cfv4_oc1,cfv4_oc2,cfv4_ex,cfv4_fp\")\n+\n+(define_insn_reservation \"cfv4_fmove_fneg_10\" 4\n+  (and (and (eq_attr \"cpu\" \"cfv4\")\n+\t    (eq_attr \"type\" \"fmove,fneg,ftst\"))\n+       (eq_attr \"op_mem\" \"10,i0,11,1i,i1\"))\n+  \"cfv4_ds,cfv4_oag,cfv4_oc1+cfv4_mem,cfv4_oc2,cfv4_ex,cfv4_fp\")\n+\n+(define_insn_reservation \"cfv4_fmove_01\" 1\n+  (and (and (eq_attr \"cpu\" \"cfv4\")\n+\t    (eq_attr \"type\" \"fmove,fneg,ftst\"))\n+       (eq_attr \"op_mem\" \"01,0i\"))\n+  \"cfv4_ds,cfv4_oag,cfv4_oc1,cfv4_oc2,cfv4_ex,cfv4_fp,cfv4_da,cfv4_mem\")\n+\n+(define_insn_reservation \"cfv4_fdiv_00\" 23\n+  (and (and (eq_attr \"cpu\" \"cfv4\")\n+\t    (eq_attr \"type\" \"fdiv\"))\n+       (eq_attr \"op_mem\" \"00,01,0i\"))\n+  \"cfv4_ds,cfv4_oag,cfv4_oc1,cfv4_oc2,cfv4_ex,cfv4_fp*17\")\n+\n+(define_insn_reservation \"cfv4_fdiv_10\" 23\n+  (and (and (eq_attr \"cpu\" \"cfv4\")\n+\t    (eq_attr \"type\" \"fdiv\"))\n+       (eq_attr \"op_mem\" \"10,i0,11,1i,i1\"))\n+  \"cfv4_ds,cfv4_oag,cfv4_oc1+cfv4_mem,cfv4_oc2,cfv4_ex,cfv4_fp*17\")\n+\n+(define_insn_reservation \"cfv4_fsqrt_00\" 56\n+  (and (and (eq_attr \"cpu\" \"cfv4\")\n+\t    (eq_attr \"type\" \"fsqrt\"))\n+       (eq_attr \"op_mem\" \"00,01,0i\"))\n+  \"cfv4_ds,cfv4_oag,cfv4_oc1,cfv4_oc2,cfv4_ex,cfv4_fp*50\")\n+\n+(define_insn_reservation \"cfv4_fsqrt_10\" 56\n+  (and (and (eq_attr \"cpu\" \"cfv4\")\n+\t    (eq_attr \"type\" \"fsqrt\"))\n+       (eq_attr \"op_mem\" \"10,i0,11,1i,i1\"))\n+  \"cfv4_ds,cfv4_oag,cfv4_oc1+cfv4_mem,cfv4_oc2,cfv4_ex,cfv4_fp*50\")\n+\n+(define_insn_reservation \"cfv4_bcc\" 0\n+  (and (eq_attr \"cpu\" \"cfv4\")\n+       (eq_attr \"type\" \"bcc\"))\n+  \"cfv4_ds,cfv4_oag,cfv4_oc1,cfv4_oc2,cfv4_ex\")\n+\n+(define_insn_reservation \"cfv4_fbcc\" 2\n+  (and (eq_attr \"cpu\" \"cfv4\")\n+       (eq_attr \"type\" \"fbcc\"))\n+  \"cfv4_ds,cfv4_oag,cfv4_oc1,cfv4_oc2,cfv4_ex,cfv4_fp\")\n+\n+;; ??? Why is bra said to write to memory: 1(0/1) ?\n+(define_insn_reservation \"cfv4_bra_bsr\" 1\n+  (and (eq_attr \"cpu\" \"cfv4\")\n+       (eq_attr \"type\" \"bra,bsr\"))\n+  \"cfv4_ds,cfv4_oag,cfv4_oc1,cfv4_oc2,cfv4_ex\")\n+\n+(define_insn_reservation \"cfv4_jmp_jsr\" 5\n+  (and (eq_attr \"cpu\" \"cfv4\")\n+       (eq_attr \"type\" \"jmp,jsr\"))\n+  \"cfv4_ds,cfv4_oag,cfv4_oc1,cfv4_oc2,cfv4_ex\")\n+\n+(define_insn_reservation \"cfv4_rts\" 2\n+  (and (eq_attr \"cpu\" \"cfv4\")\n+       (eq_attr \"type\" \"rts\"))\n+  \"cfv4_ds,cfv4_oag,cfv4_oc1+cfv4_mem,cfv4_oc2,cfv4_ex\")\n+\n+(define_insn_reservation \"cfv4_nop\" 1\n+  (and (eq_attr \"cpu\" \"cfv4\")\n+       (eq_attr \"type\" \"nop\"))\n+  \"cfv4_ds+cfv4_oag+cfv4_oc1+cfv4_mem+cfv4_oc2+cfv4_ex\")\n+\n+(define_insn_reservation \"cfv4_guess\" 10\n+  (and (eq_attr \"cpu\" \"cfv4\")\n+       (eq_attr \"type\" \"trap,unknown\"))\n+  \"cfv4_guess+cfv4_ds,cfv4_oag,cfv4_oc1+cfv4_mem,cfv4_oc2,cfv4_ex,cfv4_emac+cfv4_fp\")\n+\n+(define_insn_reservation \"ignore\" 0\n+  (eq_attr \"type\" \"ignore\")\n+  \"nothing\")"}, {"sha": "33025f8f34ac0d27e14f3ace936d9a2a151c7cf8", "filename": "gcc/config/m68k/m68k-protos.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96fcacb7d3047adc23f9f5688927053700476a88/gcc%2Fconfig%2Fm68k%2Fm68k-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96fcacb7d3047adc23f9f5688927053700476a88/gcc%2Fconfig%2Fm68k%2Fm68k-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k-protos.h?ref=96fcacb7d3047adc23f9f5688927053700476a88", "patch": "@@ -71,10 +71,9 @@ extern enum attr_mac m68k_sched_mac;\n \n extern enum attr_opx_type m68k_sched_attr_opx_type (rtx, int);\n extern enum attr_opy_type m68k_sched_attr_opy_type (rtx, int);\n-extern int m68k_sched_attr_size (rtx);\n+extern enum attr_size m68k_sched_attr_size (rtx);\n extern enum attr_op_mem m68k_sched_attr_op_mem (rtx);\n extern enum attr_type m68k_sched_branch_type (rtx);\n-extern enum attr_type2 m68k_sched_attr_type2 (rtx);\n #endif /* HAVE_ATTR_cpu */\n \n #endif /* RTX_CODE */"}, {"sha": "52a60da06640d208739c7aa22c6004e2a15c81bc", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 509, "deletions": 360, "changes": 869, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96fcacb7d3047adc23f9f5688927053700476a88/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96fcacb7d3047adc23f9f5688927053700476a88/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=96fcacb7d3047adc23f9f5688927053700476a88", "patch": "@@ -122,12 +122,14 @@ struct m68k_address {\n };\n \n static int m68k_sched_adjust_cost (rtx, rtx, rtx, int);\n+static int m68k_sched_issue_rate (void);\n static int m68k_sched_variable_issue (FILE *, int, rtx, int);\n static void m68k_sched_md_init_global (FILE *, int, int);\n static void m68k_sched_md_finish_global (FILE *, int);\n static void m68k_sched_md_init (FILE *, int, int);\n static void m68k_sched_dfa_pre_advance_cycle (void);\n static void m68k_sched_dfa_post_advance_cycle (void);\n+static int m68k_sched_first_cycle_multipass_dfa_lookahead (void);\n \n static bool m68k_handle_option (size_t, const char *, int);\n static rtx find_addr_reg (rtx);\n@@ -199,6 +201,9 @@ int m68k_last_compare_had_fp_operands;\n #undef TARGET_SCHED_ADJUST_COST\n #define TARGET_SCHED_ADJUST_COST m68k_sched_adjust_cost\n \n+#undef TARGET_SCHED_ISSUE_RATE\n+#define TARGET_SCHED_ISSUE_RATE m68k_sched_issue_rate\n+\n #undef TARGET_SCHED_VARIABLE_ISSUE\n #define TARGET_SCHED_VARIABLE_ISSUE m68k_sched_variable_issue\n \n@@ -217,6 +222,10 @@ int m68k_last_compare_had_fp_operands;\n #undef TARGET_SCHED_DFA_POST_ADVANCE_CYCLE\n #define TARGET_SCHED_DFA_POST_ADVANCE_CYCLE m68k_sched_dfa_post_advance_cycle\n \n+#undef TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD\n+#define TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD\t\\\n+  m68k_sched_first_cycle_multipass_dfa_lookahead\n+\n #undef TARGET_HANDLE_OPTION\n #define TARGET_HANDLE_OPTION m68k_handle_option\n \n@@ -672,6 +681,8 @@ override_options (void)\n     m68k_sched_cpu = CPU_CFV2;\n   else if (TUNE_CFV3)\n     m68k_sched_cpu = CPU_CFV3;\n+  else if (TUNE_CFV4)\n+    m68k_sched_cpu = CPU_CFV4;\n   else\n     {\n       m68k_sched_cpu = CPU_UNKNOWN;\n@@ -1037,6 +1048,11 @@ m68k_expand_prologue (void)\n \t\t\t\t    stack_pointer_rtx,\n \t\t\t\t    GEN_INT (-fsize_with_regs))));\n \t}\n+\n+      /* If the frame pointer is needed, emit a special barrier that\n+\t will prevent the scheduler from moving stores to the frame\n+\t before the stack adjustment.  */\n+      emit_insn (gen_stack_tie (stack_pointer_rtx, frame_pointer_rtx));\n     }\n   else if (fsize_with_regs != 0)\n     m68k_set_frame_related\n@@ -4579,8 +4595,11 @@ enum attr_op_type\n     /* No operand.  */\n     OP_TYPE_NONE,\n \n-    /* Register.  */\n-    OP_TYPE_REG,\n+    /* Integer register.  */\n+    OP_TYPE_RN,\n+\n+    /* FP register.  */\n+    OP_TYPE_FPN,\n \n     /* Implicit mem reference (e.g. stack).  */\n     OP_TYPE_MEM1,\n@@ -4607,19 +4626,19 @@ enum attr_op_type\n     OP_TYPE_IMM_L\n   };\n \n-/* True if current insn doesn't have complete pipeline description.  */\n-static bool sched_guess_p;\n-\n /* Return type of memory ADDR_RTX refers to.  */\n static enum attr_op_type\n sched_address_type (enum machine_mode mode, rtx addr_rtx)\n {\n   struct m68k_address address;\n \n+  if (symbolic_operand (addr_rtx, VOIDmode))\n+    return OP_TYPE_MEM7;\n+\n   if (!m68k_decompose_address (mode, addr_rtx,\n \t\t\t       reload_completed, &address))\n     {\n-      gcc_assert (sched_guess_p);\n+      gcc_assert (!reload_completed);\n       /* Reload will likely fix the address to be in the register.  */\n       return OP_TYPE_MEM234;\n     }\n@@ -4640,12 +4659,42 @@ sched_address_type (enum machine_mode mode, rtx addr_rtx)\n   return OP_TYPE_MEM7;\n }\n \n-/* Return type of the operand OP.\n-   If ADDRESS_P is true, return type of memory location OP refers to.  */\n+/* Return X or Y (depending on OPX_P) operand of INSN.  */\n+static rtx\n+sched_get_operand (rtx insn, bool opx_p)\n+{\n+  int i;\n+\n+  if (recog_memoized (insn) < 0)\n+    gcc_unreachable ();\n+\n+  extract_constrain_insn_cached (insn);\n+\n+  if (opx_p)\n+    i = get_attr_opx (insn);\n+  else\n+    i = get_attr_opy (insn);\n+\n+  if (i >= recog_data.n_operands)\n+    return NULL;\n+\n+  return recog_data.operand[i];\n+}\n+\n+/* Return type of INSN's operand X (if OPX_P) or operand Y (if !OPX_P).\n+   If ADDRESS_P is true, return type of memory location operand refers to.  */\n static enum attr_op_type\n-sched_operand_type (rtx op, bool address_p)\n+sched_attr_op_type (rtx insn, bool opx_p, bool address_p)\n {\n-  gcc_assert (op != NULL_RTX);\n+  rtx op;\n+\n+  op = sched_get_operand (insn, opx_p);\n+\n+  if (op == NULL)\n+    {\n+      gcc_assert (!reload_completed);\n+      return OP_TYPE_RN;\n+    }\n \n   if (address_p)\n     return sched_address_type (QImode, op);\n@@ -4654,13 +4703,49 @@ sched_operand_type (rtx op, bool address_p)\n     return sched_address_type (GET_MODE (op), XEXP (op, 0));\n \n   if (register_operand (op, VOIDmode))\n-    return OP_TYPE_REG;\n+    {\n+      if ((!reload_completed && FLOAT_MODE_P (GET_MODE (op)))\n+\t  || (reload_completed && FP_REG_P (op)))\n+\treturn OP_TYPE_FPN;\n+\n+      return OP_TYPE_RN;\n+    }\n \n   if (GET_CODE (op) == CONST_INT)\n     {\n-      /* ??? Below condition should probably check if the operation is\n-\t signed or unsigned.  */\n-      if (IN_RANGE (INTVAL (op), -0x8000, 0x7fff))\n+      int ival;\n+\n+      ival = INTVAL (op);\n+\n+      /* Check for quick constants.  */\n+      switch (get_attr_type (insn))\n+\t{\n+\tcase TYPE_ALUQ_L:\n+\t  if (IN_RANGE (ival, 1, 8) || IN_RANGE (ival, -8, -1))\n+\t    return OP_TYPE_IMM_Q;\n+\n+\t  gcc_assert (!reload_completed);\n+\t  break;\n+\n+\tcase TYPE_MOVEQ_L:\n+\t  if (USE_MOVQ (ival))\n+\t    return OP_TYPE_IMM_Q;\n+\n+\t  gcc_assert (!reload_completed);\n+\t  break;\n+\n+\tcase TYPE_MOV3Q_L:\n+\t  if (valid_mov3q_const (ival))\n+\t    return OP_TYPE_IMM_Q;\n+\n+\t  gcc_assert (!reload_completed);\n+\t  break;\n+\n+\tdefault:\n+\t  break;\n+\t}\n+\n+      if (IN_RANGE (ival, -0x8000, 0x7fff))\n \treturn OP_TYPE_IMM_W;\n \n       return OP_TYPE_IMM_L;\n@@ -4706,32 +4791,12 @@ sched_operand_type (rtx op, bool address_p)\n \t}\n     }\n \n-  gcc_assert (sched_guess_p);\n-\n-  return OP_TYPE_REG;\n-}\n-\n-/* Return type of INSN's operand X (if OPX_P) or operand Y (if !OPX_P).\n-   If ADDRESS_P is true, return type of memory location operand refers to.  */\n-static enum attr_op_type\n-sched_attr_op_type (rtx insn, bool opx_p, bool address_p)\n-{\n-  int i;\n-\n-  extract_constrain_insn_cached (insn);\n+  gcc_assert (!reload_completed);\n \n-  if (opx_p)\n-    i = get_attr_opx (insn);\n-  else\n-    i = get_attr_opy (insn);\n+  if (FLOAT_MODE_P (GET_MODE (op)))\n+    return OP_TYPE_FPN;\n \n-  if (i >= recog_data.n_operands)\n-    {\n-      gcc_assert (sched_guess_p);\n-      return OP_TYPE_REG;\n-    }\n-\n-  return sched_operand_type (recog_data.operand[i], address_p);\n+  return OP_TYPE_RN;\n }\n \n /* Implement opx_type attribute.\n@@ -4740,12 +4805,13 @@ sched_attr_op_type (rtx insn, bool opx_p, bool address_p)\n enum attr_opx_type\n m68k_sched_attr_opx_type (rtx insn, int address_p)\n {\n-  sched_guess_p = (get_attr_guess (insn) == GUESS_YES);\n-\n   switch (sched_attr_op_type (insn, true, address_p != 0))\n     {\n-    case OP_TYPE_REG:\n-      return OPX_TYPE_REG;\n+    case OP_TYPE_RN:\n+      return OPX_TYPE_RN;\n+\n+    case OP_TYPE_FPN:\n+      return OPX_TYPE_FPN;\n \n     case OP_TYPE_MEM1:\n       return OPX_TYPE_MEM1;\n@@ -4783,12 +4849,13 @@ m68k_sched_attr_opx_type (rtx insn, int address_p)\n enum attr_opy_type\n m68k_sched_attr_opy_type (rtx insn, int address_p)\n {\n-  sched_guess_p = (get_attr_guess (insn) == GUESS_YES);\n-\n   switch (sched_attr_op_type (insn, false, address_p != 0))\n     {\n-    case OP_TYPE_REG:\n-      return OPY_TYPE_REG;\n+    case OP_TYPE_RN:\n+      return OPY_TYPE_RN;\n+\n+    case OP_TYPE_FPN:\n+      return OPY_TYPE_FPN;\n \n     case OP_TYPE_MEM1:\n       return OPY_TYPE_MEM1;\n@@ -4820,17 +4887,21 @@ m68k_sched_attr_opy_type (rtx insn, int address_p)\n     }\n }\n \n-/* Return the size of INSN.  */\n-int\n-m68k_sched_attr_size (rtx insn)\n+/* Return size of INSN as int.  */\n+static int\n+sched_get_attr_size_int (rtx insn)\n {\n   int size;\n \n-  sched_guess_p = (get_attr_guess (insn) == GUESS_YES);\n-\n-  switch (get_attr_type1 (insn))\n+  switch (get_attr_type (insn))\n     {\n-    case TYPE1_MUL_L:\n+    case TYPE_IGNORE:\n+      /* There should be no references to m68k_sched_attr_size for 'ignore'\n+\t instructions.  */\n+      gcc_unreachable ();\n+      return 0;\n+\n+    case TYPE_MUL_L:\n       size = 2;\n       break;\n \n@@ -4842,7 +4913,8 @@ m68k_sched_attr_size (rtx insn)\n   switch (get_attr_opx_type (insn))\n     {\n     case OPX_TYPE_NONE:\n-    case OPX_TYPE_REG:\n+    case OPX_TYPE_RN:\n+    case OPX_TYPE_FPN:\n     case OPX_TYPE_MEM1:\n     case OPX_TYPE_MEM234:\n     case OPY_TYPE_IMM_Q:\n@@ -4867,7 +4939,8 @@ m68k_sched_attr_size (rtx insn)\n   switch (get_attr_opy_type (insn))\n     {\n     case OPY_TYPE_NONE:\n-    case OPY_TYPE_REG:\n+    case OPY_TYPE_RN:\n+    case OPY_TYPE_FPN:\n     case OPY_TYPE_MEM1:\n     case OPY_TYPE_MEM234:\n     case OPY_TYPE_IMM_Q:\n@@ -4891,30 +4964,108 @@ m68k_sched_attr_size (rtx insn)\n \n   if (size > 3)\n     {\n-      gcc_assert (sched_guess_p);\n+      gcc_assert (!reload_completed);\n \n       size = 3;\n     }\n \n   return size;\n }\n \n+/* Return size of INSN as attribute enum value.  */\n+enum attr_size\n+m68k_sched_attr_size (rtx insn)\n+{\n+  switch (sched_get_attr_size_int (insn))\n+    {\n+    case 1:\n+      return SIZE_1;\n+\n+    case 2:\n+      return SIZE_2;\n+\n+    case 3:\n+      return SIZE_3;\n+\n+    default:\n+      gcc_unreachable ();\n+      return 0;\n+    }\n+}\n+\n+/* Return operand X or Y (depending on OPX_P) of INSN,\n+   if it is a MEM, or NULL overwise.  */\n+static enum attr_op_type\n+sched_get_opxy_mem_type (rtx insn, bool opx_p)\n+{\n+  if (opx_p)\n+    {\n+      switch (get_attr_opx_type (insn))\n+\t{\n+\tcase OPX_TYPE_NONE:\n+\tcase OPX_TYPE_RN:\n+\tcase OPX_TYPE_FPN:\n+\tcase OPX_TYPE_IMM_Q:\n+\tcase OPX_TYPE_IMM_W:\n+\tcase OPX_TYPE_IMM_L:\n+\t  return OP_TYPE_RN;\n+\n+\tcase OPX_TYPE_MEM1:\n+\tcase OPX_TYPE_MEM234:\n+\tcase OPX_TYPE_MEM5:\n+\tcase OPX_TYPE_MEM7:\n+\t  return OP_TYPE_MEM1;\n+\n+\tcase OPX_TYPE_MEM6:\n+\t  return OP_TYPE_MEM6;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t  return 0;\n+\t}\n+    }\n+  else\n+    {\n+      switch (get_attr_opy_type (insn))\n+\t{\n+\tcase OPY_TYPE_NONE:\n+\tcase OPY_TYPE_RN:\n+\tcase OPY_TYPE_FPN:\n+\tcase OPY_TYPE_IMM_Q:\n+\tcase OPY_TYPE_IMM_W:\n+\tcase OPY_TYPE_IMM_L:\n+\t  return OP_TYPE_RN;\n+\n+\tcase OPY_TYPE_MEM1:\n+\tcase OPY_TYPE_MEM234:\n+\tcase OPY_TYPE_MEM5:\n+\tcase OPY_TYPE_MEM7:\n+\t  return OP_TYPE_MEM1;\n+\n+\tcase OPY_TYPE_MEM6:\n+\t  return OP_TYPE_MEM6;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t  return 0;\n+\t}\n+    }\n+}\n+\n /* Implement op_mem attribute.  */\n enum attr_op_mem\n m68k_sched_attr_op_mem (rtx insn)\n {\n-  enum attr_opy_mem opy;\n-  enum attr_opx_mem opx;\n+  enum attr_op_type opx;\n+  enum attr_op_type opy;\n \n-  sched_guess_p = (get_attr_guess (insn) == GUESS_YES);\n+  opx = sched_get_opxy_mem_type (insn, true);\n+  opy = sched_get_opxy_mem_type (insn, false);\n \n-  opy = get_attr_opy_mem (insn);\n-  opx = get_attr_opx_mem (insn);\n-\n-  if (opy == OPY_MEM_R && opx == OPX_MEM_R)\n+  if (opy == OP_TYPE_RN && opx == OP_TYPE_RN)\n     return OP_MEM_00;\n \n-  if (opy == OPY_MEM_R && opx == OPX_MEM_M)\n+  if (opy == OP_TYPE_RN && opx == OP_TYPE_MEM1)\n     {\n       switch (get_attr_opx_access (insn))\n \t{\n@@ -4928,12 +5079,12 @@ m68k_sched_attr_op_mem (rtx insn)\n \t  return OP_MEM_11;\n \n \tdefault:\n-\t  gcc_assert (sched_guess_p);\n-\t  return OP_MEM_UNKNOWN;\n+\t  gcc_unreachable ();\n+\t  return 0;\n \t}\n     }\n \n-  if (opy == OPY_MEM_R && opx == OPX_MEM_I)\n+  if (opy == OP_TYPE_RN && opx == OP_TYPE_MEM6)\n     {\n       switch (get_attr_opx_access (insn))\n \t{\n@@ -4947,59 +5098,59 @@ m68k_sched_attr_op_mem (rtx insn)\n \t  return OP_MEM_I1;\n \n \tdefault:\n-\t  gcc_assert (sched_guess_p);\n-\t  return OP_MEM_UNKNOWN;\n+\t  gcc_unreachable ();\n+\t  return 0;\n \t}\n     }\n \n-  if (opy == OPY_MEM_M && opx == OPX_MEM_R)\n+  if (opy == OP_TYPE_MEM1 && opx == OP_TYPE_RN)\n     return OP_MEM_10;\n \n-  if (opy == OPY_MEM_M && opx == OPX_MEM_M)\n+  if (opy == OP_TYPE_MEM1 && opx == OP_TYPE_MEM1)\n     {\n       switch (get_attr_opx_access (insn))\n \t{\n \tcase OPX_ACCESS_W:\n \t  return OP_MEM_11;\n \n \tdefault:\n-\t  gcc_assert (sched_guess_p);\n-\t  return OP_MEM_UNKNOWN;\n+\t  gcc_assert (!reload_completed);\n+\t  return OP_MEM_11;\n \t}\n     }\n \n-  if (opy == OPY_MEM_M && opx == OPX_MEM_I)\n+  if (opy == OP_TYPE_MEM1 && opx == OP_TYPE_MEM6)\n     {\n       switch (get_attr_opx_access (insn))\n \t{\n \tcase OPX_ACCESS_W:\n \t  return OP_MEM_1I;\n \n \tdefault:\n-\t  gcc_assert (sched_guess_p);\n-\t  return OP_MEM_UNKNOWN;\n+\t  gcc_assert (!reload_completed);\n+\t  return OP_MEM_1I;\n \t}\n     }\n \n-  if (opy == OPY_MEM_I && opx == OPX_MEM_R)\n+  if (opy == OP_TYPE_MEM6 && opx == OP_TYPE_RN)\n     return OP_MEM_I0;\n \n-\n-  if (opy == OPY_MEM_I && opx == OPX_MEM_M)\n+  if (opy == OP_TYPE_MEM6 && opx == OP_TYPE_MEM1)\n     {\n       switch (get_attr_opx_access (insn))\n \t{\n \tcase OPX_ACCESS_W:\n \t  return OP_MEM_I1;\n \n \tdefault:\n-\t  gcc_assert (sched_guess_p);\n-\t  return OP_MEM_UNKNOWN;\n+\t  gcc_assert (!reload_completed);\n+\t  return OP_MEM_I1;\n \t}\n     }\n \n-  gcc_assert (sched_guess_p);\n-  return OP_MEM_UNKNOWN;\n+  gcc_assert (opy == OP_TYPE_MEM6 && opx == OP_TYPE_MEM6);\n+  gcc_assert (!reload_completed);\n+  return OP_MEM_I1;\n }\n \n /* Jump instructions types.  Indexed by INSN_UID.\n@@ -5022,80 +5173,21 @@ m68k_sched_branch_type (rtx insn)\n   return type;\n }\n \n-/* Implement type2 attribute.  */\n-enum attr_type2\n-m68k_sched_attr_type2 (rtx insn)\n+/* Data for ColdFire V4 index bypass.\n+   Producer modifies register that is used as index in consumer with\n+   specified scale.  */\n+static struct\n {\n-  switch (get_attr_type1 (insn))\n-    {\n-    case TYPE1_ALU_L:\n-    case TYPE1_ALUQ_L:\n-    case TYPE1_CMP_L:\n-      return TYPE2_ALU;\n+  /* Producer instruction.  */\n+  rtx pro;\n \n-    case TYPE1_ALU_REG1:\n-    case TYPE1_ALU_REGX:\n-      return TYPE2_ALU_REG;\n+  /* Consumer instruction.  */\n+  rtx con;\n \n-    case TYPE1_BCC:\n-      return TYPE2_BCC;\n-\n-    case TYPE1_BRA:\n-      return TYPE2_BRA;\n-\n-    case TYPE1_BSR:\n-    case TYPE1_JSR:\n-      return TYPE2_CALL;\n-\n-    case TYPE1_JMP:\n-      return TYPE2_JMP;\n-\n-    case TYPE1_LEA:\n-      return TYPE2_LEA;\n-\n-    case TYPE1_CLR:\n-    case TYPE1_MOV3Q_L:\n-    case TYPE1_MOVE:\n-    case TYPE1_MOVEQ_L:\n-    case TYPE1_TST:\n-      switch (m68k_sched_cpu)\n-\t{\n-\tcase CPU_CFV1:\n-\t  return TYPE2_OMOVE;\n-\n-\tcase CPU_CFV2:\n-\tcase CPU_CFV3:\n-\t  return TYPE2_ALU;\n-\n-\tdefault:\n-\t  gcc_assert (get_attr_guess (insn) == GUESS_YES);\n-\t  return TYPE2_UNKNOWN;\n-\t}\n-\n-    case TYPE1_MUL_L:\n-      return TYPE2_MUL_L;\n-\n-    case TYPE1_MUL_W:\n-      return TYPE2_MUL_W;\n-\n-    case TYPE1_MOVE_L:\n-    case TYPE1_TST_L:\n-      return TYPE2_OMOVE;\n-\n-    case TYPE1_PEA:\n-      return TYPE2_PEA;\n-\n-    case TYPE1_RTS:\n-      return TYPE2_RTS;\n-\n-    case TYPE1_UNLK:\n-      return TYPE2_UNLK;\n-\n-    default:\n-      gcc_assert (get_attr_guess (insn) == GUESS_YES);\n-      return TYPE2_UNKNOWN;\n-    }\n-}\n+  /* Scale of indexed memory access within consumer.\n+     Or zero if bypass should not be effective at the moment.  */\n+  int scale;\n+} sched_cfv4_bypass_data;\n \n /* An empty state that is used in m68k_sched_adjust_cost.  */\n static state_t sched_adjust_cost_state;\n@@ -5112,27 +5204,70 @@ m68k_sched_adjust_cost (rtx insn, rtx link ATTRIBUTE_UNUSED, rtx def_insn,\n       || recog_memoized (insn) < 0)\n     return cost;\n \n+  if (sched_cfv4_bypass_data.scale == 1)\n+    /* Handle ColdFire V4 bypass for indexed address with 1x scale.  */\n+    {\n+      /* haifa-sched.c: insn_cost () calls bypass_p () just before\n+\t targetm.sched.adjust_cost ().  Hence, we can be relatively sure\n+\t that the data in sched_cfv4_bypass_data is up to date.  */\n+      gcc_assert (sched_cfv4_bypass_data.pro == def_insn\n+\t\t  && sched_cfv4_bypass_data.con == insn);\n+\n+      if (cost < 3)\n+\tcost = 3;\n+\n+      sched_cfv4_bypass_data.pro = NULL;\n+      sched_cfv4_bypass_data.con = NULL;\n+      sched_cfv4_bypass_data.scale = 0;\n+    }\n+  else\n+    gcc_assert (sched_cfv4_bypass_data.pro == NULL\n+\t\t&& sched_cfv4_bypass_data.con == NULL\n+\t\t&& sched_cfv4_bypass_data.scale == 0);\n+\n   /* Don't try to issue INSN earlier than DFA permits.\n      This is especially useful for instructions that write to memory,\n      as their true dependence (default) latency is better to be set to 0\n      to workaround alias analysis limitations.\n      This is, in fact, a machine independent tweak, so, probably,\n      it should be moved to haifa-sched.c: insn_cost ().  */\n-\n   delay = min_insn_conflict_delay (sched_adjust_cost_state, def_insn, insn);\n   if (delay > cost)\n     cost = delay;\n \n   return cost;\n }\n \n+/* Return maximal number of insns that can be scheduled on a single cycle.  */\n+static int\n+m68k_sched_issue_rate (void)\n+{\n+  switch (m68k_sched_cpu)\n+    {\n+    case CPU_CFV1:\n+    case CPU_CFV2:\n+    case CPU_CFV3:\n+      return 1;\n+\n+    case CPU_CFV4:\n+      return 2;\n+\n+    default:\n+      gcc_unreachable ();\n+      return 0;\n+    }\n+}\n+\n /* Maximal length of instruction for current CPU.\n    E.g. it is 3 for any ColdFire core.  */\n static int max_insn_size;\n \n /* Data to model instruction buffer of CPU.  */\n struct _sched_ib\n {\n+  /* True if instruction buffer model is modeled for current CPU.  */\n+  bool enabled_p;\n+\n   /* Size of the instruction buffer in words.  */\n   int size;\n \n@@ -5175,17 +5310,17 @@ m68k_sched_variable_issue (FILE *sched_dump ATTRIBUTE_UNUSED,\n {\n   int insn_size;\n \n-  if (recog_memoized (insn) >= 0)\n+  if (recog_memoized (insn) >= 0 && get_attr_type (insn) != TYPE_IGNORE)\n     {\n       switch (m68k_sched_cpu)\n \t{\n \tcase CPU_CFV1:\n \tcase CPU_CFV2:\n-\t  insn_size = get_attr_size (insn);\n+\t  insn_size = sched_get_attr_size_int (insn);\n \t  break;\n \n \tcase CPU_CFV3:\n-\t  insn_size = get_attr_size (insn);\n+\t  insn_size = sched_get_attr_size_int (insn);\n \t  \n \t  /* ColdFire V3 and V4 cores have instruction buffers that can\n \t     accumulate up to 8 instructions regardless of instructions'\n@@ -5215,6 +5350,11 @@ m68k_sched_variable_issue (FILE *sched_dump ATTRIBUTE_UNUSED,\n \n \t  break;\n \n+\tcase CPU_CFV4:\n+\t  gcc_assert (!sched_ib.enabled_p);\n+\t  insn_size = 0;\n+\t  break;\n+\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n@@ -5233,194 +5373,12 @@ m68k_sched_variable_issue (FILE *sched_dump ATTRIBUTE_UNUSED,\n   return can_issue_more;\n }\n \n-/* Statistics gatherer.  */\n-\n-typedef enum\n-  {\n-    /* Something needs to be done for this insn.  */\n-    SCHED_DUMP_TODO,\n-\n-    /* Support for this insn is complete.  */\n-    SCHED_DUMP_DONE,\n-\n-    /* This insn didn't require much effort to support it.  */\n-    SCHED_DUMP_NOTHING\n-  } sched_dump_class_def;\n-\n-/* Pointer to functions that classifies insns into 3 above classes.  */\n-typedef sched_dump_class_def (*sched_dump_class_func_t) (rtx);\n-\n-/* Return statistical type of INSN regarding splits.  */\n-static sched_dump_class_def\n-sched_dump_split_class (rtx insn)\n-{\n-  int i;\n-\n-  i = recog_memoized (insn);\n-  gcc_assert (i >= 0);\n-\n-  switch (get_attr_split (insn))\n-    {\n-    case SPLIT_TODO:\n-      return SCHED_DUMP_TODO;\n-\n-    case SPLIT_DONE:\n-      return SCHED_DUMP_DONE;\n-\n-    case SPLIT_NOTHING:\n-      return SCHED_DUMP_NOTHING;\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-\n-/* ID of the guess unit.  */\n-static int sched_dump_dfa_guess_unit_code;\n-\n-/* DFA state for use in sched_dump_dfa_class ().  */\n-static state_t sched_dump_dfa_state;\n-\n-/* Return statistical type of INSN regarding DFA reservations.  */\n-static sched_dump_class_def\n-sched_dump_dfa_class (rtx insn)\n+/* Return how many instructions should scheduler lookahead to choose the\n+   best one.  */\n+static int\n+m68k_sched_first_cycle_multipass_dfa_lookahead (void)\n {\n-  int i;\n-\n-  i = recog_memoized (insn);\n-  gcc_assert (i >= 0 && insn_has_dfa_reservation_p (insn));\n-\n-  if (sched_dump_split_class (insn) == SCHED_DUMP_TODO)\n-    /* Insn is not yet ready for reservations.  */\n-    return SCHED_DUMP_NOTHING;\n-\n-  state_reset (sched_dump_dfa_state);\n-\n-  if (state_transition (sched_dump_dfa_state, insn) >= 0)\n-    gcc_unreachable ();\n-\n-  if (cpu_unit_reservation_p (sched_dump_dfa_state,\n-\t\t\t      sched_dump_dfa_guess_unit_code))\n-    return SCHED_DUMP_TODO;\n-\n-  return SCHED_DUMP_DONE;\n-}\n-\n-/* Dump statistics on current function into file DUMP_FILENAME and prefix\n-   each entry with PREFIX.\n-   Instructions are classified with DUMP_CLASS.  */\n-static void\n-m68k_sched_dump (sched_dump_class_func_t dump_class,\n-\t\t const char *prefix, FILE *dump)\n-{\n-  sbitmap present;\n-  int *todos;\n-  int *dones;\n-  int *nothings;\n-  rtx insn;\n-\n-  gcc_assert (dump != NULL);\n-\n-  present = sbitmap_alloc (CODE_FOR_nothing);\n-  sbitmap_zero (present);\n-\n-  todos = xcalloc (CODE_FOR_nothing, sizeof (*todos));\n-  dones = xcalloc (CODE_FOR_nothing, sizeof (*dones));\n-  nothings = xcalloc (CODE_FOR_nothing, sizeof (*nothings));\n-\n-  /* Gather statistics.  */\n-  for (insn = get_insns (); insn != NULL_RTX; insn = NEXT_INSN (insn))\n-    {\n-      if (INSN_P (insn) && recog_memoized (insn) >= 0)\n-\t{\n-\t  enum insn_code code;\n-\n-\t  code = INSN_CODE (insn);\n-\t  gcc_assert (code < CODE_FOR_nothing);\n-\n-\t  SET_BIT (present, code);\n-\n-\t  switch (dump_class (insn))\n-\t    {\n-\t    case SCHED_DUMP_TODO:\n-\t      ++todos[code];\n-\t      break;\n-\n-\t    case SCHED_DUMP_DONE:\n-\t      ++dones[code];\n-\t      break;\n-\n-\t    case SCHED_DUMP_NOTHING:\n-\t      ++nothings[code];\n-\t      break;\n-\t    }\n-\t}\n-    }\n-\n-  /* Print statisctics.  */\n-  {\n-    unsigned int i;\n-    sbitmap_iterator si;\n-    int total_todo;\n-    int total_done;\n-    int total_nothing;\n-\n-    total_todo = 0;\n-    total_done = 0;\n-    total_nothing = 0;\n-\n-    EXECUTE_IF_SET_IN_SBITMAP (present, 0, i, si)\n-      {\n-\tint todo;\n-\tint done;\n-\tint nothing;\n-\tenum insn_code code;\n-\n-\tcode = (enum insn_code) i;\n-\n-\ttodo = todos[code];\n-\tdone = dones[code];\n-\tnothing = nothings[code];\n-\n-\ttotal_todo += todo;\n-\ttotal_done += done;\n-\ttotal_nothing += nothing;\n-\n-\tif (todo != 0)\n-\t  {\n-\t    fprintf (dump,\n-\t\t     \"%s: %3d: %d / %d / %d ;\",\n-\t\t     prefix, code, todo, done, nothing);\n-\n-\t    {\n-\t      const char *name;\n-\n-\t      name = get_insn_name (code);\n-\n-\t      if (name != NULL)\n-\t\tfprintf (dump, \" {%s}\\n\", name);\n-\t      else\n-\t\tfprintf (dump, \" {unknown}\\n\");\n-\t    }\n-\t  }\n-      }\n-\n-    gcc_assert (CODE_FOR_nothing < 999);\n-\n-    fprintf (dump,\n-\t     \"%s: 999: %d / %d / %d ; {total}\\n\",\n-\t     prefix, total_todo, total_done, total_nothing);\n-  }\n-\n-  free (nothings);\n-  nothings = NULL;\n-  free (dones);\n-  dones = NULL;\n-  free (todos);\n-  todos = NULL;\n-\n-  sbitmap_free (present);\n-  present = NULL;\n+  return m68k_sched_issue_rate () - 1;\n }\n \n /* Implementation of targetm.sched.md_init_global () hook.\n@@ -5446,25 +5404,43 @@ m68k_sched_md_init_global (FILE *sched_dump ATTRIBUTE_UNUSED,\n       }\n   }\n \n-  if (reload_completed && sched_verbose >= 8)\n-    /* Dump statistics.  */\n-    {\n-      m68k_sched_dump (sched_dump_split_class, \"m68k_sched_split\",\n-\t\t       sched_dump);\n+#ifdef ENABLE_CHECKING\n+  /* Check that all instructions have DFA reservations and\n+     that all instructions can be issued from a clean state.  */\n+  {\n+    rtx insn;\n+    state_t state;\n \n-      sched_dump_dfa_guess_unit_code = get_cpu_unit_code (\"cf_guess\");\n-      sched_dump_dfa_state = alloca (state_size ());\n+    state = alloca (state_size ());\n \n-      m68k_sched_dump (sched_dump_dfa_class, \"m68k_sched_dfa\",\n-\t\t       sched_dump);\n+    for (insn = get_insns (); insn != NULL_RTX; insn = NEXT_INSN (insn))\n+      {\n+ \tif (INSN_P (insn) && recog_memoized (insn) >= 0)\n+\t  {\n+ \t    gcc_assert (insn_has_dfa_reservation_p (insn));\n \n-      sched_dump_dfa_state = NULL;\n-      sched_dump_dfa_guess_unit_code = 0;\n-    }\n+ \t    state_reset (state);\n+ \t    if (state_transition (state, insn) >= 0)\n+ \t      gcc_unreachable ();\n+ \t  }\n+      }\n+  }\n+#endif\n \n   /* Setup target cpu.  */\n+\n+  /* ColdFire V4 has a set of features to keep its instruction buffer full\n+     (e.g., a separate memory bus for instructions) and, hence, we do not model\n+     buffer for this CPU.  */\n+  sched_ib.enabled_p = (m68k_sched_cpu != CPU_CFV4);\n+\n   switch (m68k_sched_cpu)\n     {\n+    case CPU_CFV4:\n+      sched_ib.filled = 0;\n+\n+      /* FALLTHRU */\n+\n     case CPU_CFV1:\n     case CPU_CFV2:\n       max_insn_size = 3;\n@@ -5538,13 +5514,19 @@ m68k_sched_md_init (FILE *sched_dump ATTRIBUTE_UNUSED,\n       sched_ib.records.adjust_index = 0;\n       break;\n \n+    case CPU_CFV4:\n+      gcc_assert (!sched_ib.enabled_p);\n+      sched_ib.size = 0;\n+      break;\n+\n     default:\n       gcc_unreachable ();\n     }\n \n-  /* haifa-sched.c: schedule_block () calls advance_cycle () just before\n-     the first cycle.  Workaround that.  */\n-  sched_ib.filled = -2;\n+  if (sched_ib.enabled_p)\n+    /* haifa-sched.c: schedule_block () calls advance_cycle () just before\n+       the first cycle.  Workaround that.  */\n+    sched_ib.filled = -2;\n }\n \n /* Implementation of targetm.sched.dfa_pre_advance_cycle () hook.\n@@ -5553,6 +5535,9 @@ m68k_sched_md_init (FILE *sched_dump ATTRIBUTE_UNUSED,\n static void\n m68k_sched_dfa_pre_advance_cycle (void)\n {\n+  if (!sched_ib.enabled_p)\n+    return;\n+\n   if (!cpu_unit_reservation_p (curr_state, sched_mem_unit_code))\n     {\n       sched_ib.filled += 2;\n@@ -5572,6 +5557,9 @@ m68k_sched_dfa_post_advance_cycle (void)\n {\n   int i;\n \n+  if (!sched_ib.enabled_p)\n+    return;\n+\n   /* Setup number of prefetched instruction words in the instruction\n      buffer.  */\n   i = max_insn_size - sched_ib.filled;\n@@ -5582,3 +5570,164 @@ m68k_sched_dfa_post_advance_cycle (void)\n \tgcc_unreachable ();\n     }\n }\n+\n+/* Return X or Y (depending on OPX_P) operand of INSN,\n+   if it is an integer register, or NULL overwise.  */\n+static rtx\n+sched_get_reg_operand (rtx insn, bool opx_p)\n+{\n+  rtx op = NULL;\n+\n+  if (opx_p)\n+    {\n+      if (get_attr_opx_type (insn) == OPX_TYPE_RN)\n+\t{\n+\t  op = sched_get_operand (insn, true);\n+\t  gcc_assert (op != NULL);\n+\n+\t  if (!reload_completed && !REG_P (op))\n+\t    return NULL;\n+\t}\n+    }\n+  else\n+    {\n+      if (get_attr_opy_type (insn) == OPY_TYPE_RN)\n+\t{\n+\t  op = sched_get_operand (insn, false);\n+\t  gcc_assert (op != NULL);\n+\n+\t  if (!reload_completed && !REG_P (op))\n+\t    return NULL;\n+\t}\n+    }\n+\n+  return op;\n+}\n+\n+/* Return true, if X or Y (depending on OPX_P) operand of INSN\n+   is a MEM.  */\n+static bool\n+sched_mem_operand_p (rtx insn, bool opx_p)\n+{\n+  switch (sched_get_opxy_mem_type (insn, opx_p))\n+    {\n+    case OP_TYPE_MEM1:\n+    case OP_TYPE_MEM6:\n+      return true;\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n+/* Return X or Y (depending on OPX_P) operand of INSN,\n+   if it is a MEM, or NULL overwise.  */\n+static rtx\n+sched_get_mem_operand (rtx insn, bool must_read_p, bool must_write_p)\n+{\n+  bool opx_p;\n+  bool opy_p;\n+\n+  opx_p = false;\n+  opy_p = false;\n+\n+  if (must_read_p)\n+    {\n+      opx_p = true;\n+      opy_p = true;\n+    }\n+\n+  if (must_write_p)\n+    {\n+      opx_p = true;\n+      opy_p = false;\n+    }\n+\n+  if (opy_p && sched_mem_operand_p (insn, false))\n+    return sched_get_operand (insn, false);\n+\n+  if (opx_p && sched_mem_operand_p (insn, true))\n+    return sched_get_operand (insn, true);\n+\n+  gcc_unreachable ();\n+  return NULL;\n+}\n+\n+/* Return non-zero if PRO modifies register used as part of\n+   address in CON.  */\n+int\n+m68k_sched_address_bypass_p (rtx pro, rtx con)\n+{\n+  rtx pro_x;\n+  rtx con_mem_read;\n+\n+  pro_x = sched_get_reg_operand (pro, true);\n+  if (pro_x == NULL)\n+    return 0;\n+\n+  con_mem_read = sched_get_mem_operand (con, true, false);\n+  gcc_assert (con_mem_read != NULL);\n+\n+  if (reg_mentioned_p (pro_x, con_mem_read))\n+    return 1;\n+\n+  return 0;\n+}\n+\n+/* Helper function for m68k_sched_indexed_address_bypass_p.\n+   if PRO modifies register used as index in CON,\n+   return scale of indexed memory access in CON.  Return zero overwise.  */\n+static int\n+sched_get_indexed_address_scale (rtx pro, rtx con)\n+{\n+  rtx reg;\n+  rtx mem;\n+  struct m68k_address address;\n+\n+  reg = sched_get_reg_operand (pro, true);\n+  if (reg == NULL)\n+    return 0;\n+\n+  mem = sched_get_mem_operand (con, true, false);\n+  gcc_assert (mem != NULL && MEM_P (mem));\n+\n+  if (!m68k_decompose_address (GET_MODE (mem), XEXP (mem, 0), reload_completed,\n+\t\t\t       &address))\n+    gcc_unreachable ();\n+\n+  if (REGNO (reg) == REGNO (address.index))\n+    {\n+      gcc_assert (address.scale != 0);\n+      return address.scale;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Return non-zero if PRO modifies register used\n+   as index with scale 2 or 4 in CON.  */\n+int\n+m68k_sched_indexed_address_bypass_p (rtx pro, rtx con)\n+{\n+  gcc_assert (sched_cfv4_bypass_data.pro == NULL\n+\t      && sched_cfv4_bypass_data.con == NULL\n+\t      && sched_cfv4_bypass_data.scale == 0);\n+\n+  switch (sched_get_indexed_address_scale (pro, con))\n+    {\n+    case 1:\n+      /* We can't have a variable latency bypass, so\n+\t remember to adjust the insn cost in adjust_cost hook.  */\n+      sched_cfv4_bypass_data.pro = pro;\n+      sched_cfv4_bypass_data.con = con;\n+      sched_cfv4_bypass_data.scale = 1;\n+      return 0;\n+\n+    case 2:\n+    case 4:\n+      return 1;\n+\n+    default:\n+      return 0;\n+    }\n+}"}, {"sha": "521ad84971650e691bf1f49921baafe3e69a7ea2", "filename": "gcc/config/m68k/m68k.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96fcacb7d3047adc23f9f5688927053700476a88/gcc%2Fconfig%2Fm68k%2Fm68k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96fcacb7d3047adc23f9f5688927053700476a88/gcc%2Fconfig%2Fm68k%2Fm68k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.h?ref=96fcacb7d3047adc23f9f5688927053700476a88", "patch": "@@ -267,6 +267,7 @@ along with GCC; see the file COPYING3.  If not see\n #define TUNE_CFV1       (m68k_tune == ucfv1)\n #define TUNE_CFV2\t(m68k_tune == ucfv2)\n #define TUNE_CFV3       (m68k_tune == ucfv3)\n+#define TUNE_CFV4       (m68k_tune == ucfv4 || m68k_tune == ucfv4e)\n \n #define OVERRIDE_OPTIONS   override_options()\n \n@@ -1149,4 +1150,7 @@ extern M68K_CONST_METHOD m68k_const_method (HOST_WIDE_INT);\n \n extern void m68k_emit_move_double (rtx [2]);\n \n+extern int m68k_sched_address_bypass_p (rtx, rtx);\n+extern int m68k_sched_indexed_address_bypass_p (rtx, rtx);\n+\n #define CPU_UNITS_QUERY 1"}, {"sha": "d142861f8f2323438e2428b4b1c6781c2f80baa4", "filename": "gcc/config/m68k/m68k.md", "status": "modified", "additions": 220, "deletions": 269, "changes": 489, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96fcacb7d3047adc23f9f5688927053700476a88/gcc%2Fconfig%2Fm68k%2Fm68k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96fcacb7d3047adc23f9f5688927053700476a88/gcc%2Fconfig%2Fm68k%2Fm68k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.md?ref=96fcacb7d3047adc23f9f5688927053700476a88", "patch": "@@ -115,6 +115,7 @@\n    (UNSPEC_COS 2)\n    (UNSPEC_GOT 3)\n    (UNSPEC_IB 4)\n+   (UNSPEC_TIE 5)\n   ])\n \n ;; UNSPEC_VOLATILE usage:\n@@ -144,202 +145,104 @@\n ;; ::::::::::::::::::::\n \n ;; Processor type.\n-(define_attr \"cpu\" \"cfv1, cfv2, cfv3, unknown\"\n+(define_attr \"cpu\" \"cfv1, cfv2, cfv3, cfv4, unknown\"\n   (const (symbol_ref \"m68k_sched_cpu\")))\n \n ;; MAC type.\n (define_attr \"mac\" \"no, cf_mac, cf_emac\"\n   (const (symbol_ref \"m68k_sched_mac\")))\n \n-;; Instruction type.\n-;; Basically, an asm pattern.\n-(define_attr \"type\"\n-  \"add_l, addq_l, asr_l, bcc, bclr, bra, bset, bsr,\n-   clr_b, clr_w, clr_l, cmp_l,\n-   ext_w, extb_l, ext_l,\n-   fadd, fcmp, fdiv, ff1, fintrz, fmove, fmul, fsqrt, fsub, ftst, jmp, jsr,\n-   ib,\n-   lea, lsr_l,\n-   move_b, move_w, move_l, moveq_l, mov3q_l, mvs_b, mvs_w, mvz_b, mvz_w,\n-   muls_w, muls_l, mulu_w, mulu_l,\n-   neg_l, nop, not_l,\n-   pea, rts,\n-   scc, sub_l, subq_l,\n-   trap, tst_b, tst_l, tst_w,\n-   unlk, unknown\"\n-  (const_string \"unknown\"))\n-\n ;; Instruction type for use in scheduling description.\n ;; _l and _w suffixes indicate size of the operands of instruction.\n ;; alu - usual arithmetic or logic instruction.\n-;; alu_reg1 - arithmetic or logic instruction with one operand that is\n-;;            a register.\n-;; alu_regx - arithmetic or logic instruction which has a register for its\n-;;            X operand.\n ;; aluq - arithmetic or logic instruction which has a quick immediate (the one\n ;;        that is encoded in the instruction word) for its Y operand.\n-;; <all other values> - corresponding asm instructions.\n-(define_attr \"type1\"\n-  \"alu_l, alu_reg1, alu_regx, aluq_l, bcc, bra, bsr, clr, cmp_l, jmp, jsr, lea,\n-   mov3q_l, move, move_l, moveq_l, mul_l, mul_w, pea, rts, tst, tst_l, unlk,\n+;; alux - Arithmetic instruction that uses carry bit (e.g., addx and subx).\n+;; bcc - conditional branch.\n+;; bitr - bit operation that only updates flags.\n+;; bitrw - bit operation that updates flags and output operand.\n+;; bra, bsr, clr, cmp, div, ext - corresponding instruction.\n+;; falu, fbcc, fcmp, fdiv, fmove, fmul, fneg, fsqrt, ftst - corresponding\n+;;                                                          instruction.\n+;; ib - fake instruction to subscribe slots in ColdFire V1,V2,V3 instruction\n+;;      buffer.\n+;; ignore - fake instruction.\n+;; jmp, jsr, lea, link, mov3q, move, moveq, mul - corresponding instruction.\n+;; mvsz - mvs or mvz instruction.\n+;; neg, nop, pea, rts, scc - corresponding instruction.\n+;; shift - arithmetic or logical shift instruction.\n+;; trap, tst, unlk - corresponding instruction.\n+(define_attr \"type\"\n+  \"alu_l,aluq_l,alux_l,bcc,bitr,bitrw,bra,bsr,clr,clr_l,cmp,cmp_l,\n+   div_w,div_l,ext,\n+   falu,fbcc,fcmp,fdiv,fmove,fmul,fneg,fsqrt,ftst,\n+   ib,ignore,\n+   jmp,jsr,lea,link,mov3q_l,move,move_l,moveq_l,mul_w,mul_l,mvsz,neg_l,nop,\n+   pea,rts,scc,shift,\n+   trap,tst,tst_l,unlk,\n    unknown\"\n-  (cond [(eq_attr \"type\" \"add_l,sub_l\") (const_string \"alu_l\")\n-\t (eq_attr \"type\" \"ext_w,extb_l,ext_l,neg_l,not_l\")\n-\t (const_string \"alu_reg1\")\n-\t (eq_attr \"type\" \"asr_l,lsr_l\") (const_string \"alu_regx\")\n-\t (eq_attr \"type\" \"addq_l,subq_l\") (const_string \"aluq_l\")\n-\t (eq_attr \"type\" \"bcc\") (const_string \"bcc\")\n-\t (eq_attr \"type\" \"bra\") (const_string \"bra\")\n-\t (eq_attr \"type\" \"bsr\") (const_string \"bsr\")\n-\t (eq_attr \"type\" \"clr_b,clr_l,clr_w\") (const_string \"clr\")\n-\t (eq_attr \"type\" \"cmp_l\") (const_string \"cmp_l\")\n-\t (eq_attr \"type\" \"jmp\") (const_string \"jmp\")\n-\t (eq_attr \"type\" \"jsr\") (const_string \"jsr\")\n-\t (eq_attr \"type\" \"lea\") (const_string \"lea\")\n-\t (eq_attr \"type\" \"mov3q_l\") (const_string \"mov3q_l\")\n-\t (eq_attr \"type\" \"move_b,move_w\") (const_string \"move\")\n-\t (eq_attr \"type\" \"move_l\") (const_string \"move_l\")\n-\t (eq_attr \"type\" \"moveq_l\") (const_string \"moveq_l\")\n-\t (eq_attr \"type\" \"muls_l,mulu_l\") (const_string \"mul_l\")\n-\t (eq_attr \"type\" \"muls_w,mulu_w\") (const_string \"mul_w\")\n-\t (eq_attr \"type\" \"pea\") (const_string \"pea\")\n-\t (eq_attr \"type\" \"rts\") (const_string \"rts\")\n-\t (eq_attr \"type\" \"tst_b,tst_w\") (const_string \"tst\")\n-\t (eq_attr \"type\" \"tst_l\") (const_string \"tst_l\")\n-\t (eq_attr \"type\" \"unlk\") (const_string \"unlk\")]\n-\t(const_string \"unknown\")))\n+  (const_string \"unknown\"))\n \n ;; Index of the X or Y operand in recog_data.operand[].\n ;; Should be used only within opx_type and opy_type.\n (define_attr \"opx\" \"\" (const_int 0))\n (define_attr \"opy\" \"\" (const_int 1))\n \n-;; Type of the X operand.\n-;; See m68k.c: enum attr_op_type.\n-(define_attr \"opx_type\"\n-  \"none, reg, mem1, mem234, mem5, mem6, mem7, imm_q, imm_w, imm_l\"\n-  (cond [(eq_attr \"type1\" \"rts,unlk\") (const_string \"none\")\n-\t (eq_attr \"type1\" \"alu_reg1,alu_regx,lea,moveq_l,mul_l,mul_w\")\n-\t (const_string \"reg\")\n-\t (eq_attr \"type1\" \"pea\") (const_string \"mem1\")\n-\t (eq_attr \"type1\" \"bcc\") (const_string \"imm_q\")\n-\t (eq_attr \"type1\" \"bra,bsr\") (const_string \"imm_w\")\n-\t (eq_attr \"type1\" \"jmp,jsr\")\n-\t (symbol_ref \"m68k_sched_attr_opx_type (insn, 1)\")]\n-\t(symbol_ref \"m68k_sched_attr_opx_type (insn, 0)\")))\n-\n ;; Type of the Y operand.\n ;; See m68k.c: enum attr_op_type.\n (define_attr \"opy_type\"\n-  \"none, reg, mem1, mem234, mem5, mem6, mem7, imm_q, imm_w, imm_l\"\n-  (cond [(eq_attr \"type1\" \"alu_reg1,bcc,bra,bsr,clr,jmp,jsr,rts,tst,tst_l,\n-                           unlk\") (const_string \"none\")\n-\t (eq_attr \"type1\" \"mov3q_l,moveq_l,aluq_l\") (const_string \"imm_q\")\n-\t (eq_attr \"type1\" \"lea,pea\")\n+  \"none,Rn,FPn,mem1,mem234,mem5,mem6,mem7,imm_q,imm_w,imm_l\"\n+  (cond [(eq_attr \"type\" \"ext,fbcc,ftst,neg_l,bcc,bra,bsr,clr,clr_l,ib,ignore,\n+                          jmp,jsr,nop,rts,scc,trap,tst,tst_l,\n+                          unlk,unknown\") (const_string \"none\")\n+\t (eq_attr \"type\" \"lea,pea\")\n \t (symbol_ref \"m68k_sched_attr_opy_type (insn, 1)\")]\n \t(symbol_ref \"m68k_sched_attr_opy_type (insn, 0)\")))\n \n-;; Instruction size in words.\n-(define_attr \"size\" \"\"\n-  (cond [(eq_attr \"type1\" \"alu_reg1,moveq_l,rts,unlk\") (const_int 1)]\n-\t(symbol_ref \"m68k_sched_attr_size (insn)\")))\n+;; Type of the X operand.\n+;; See m68k.c: enum attr_op_type.\n+(define_attr \"opx_type\"\n+  \"none,Rn,FPn,mem1,mem234,mem5,mem6,mem7,imm_q,imm_w,imm_l\"\n+  (cond [(eq_attr \"type\" \"ib,ignore,nop,rts,trap,unlk,\n+                          unknown\") (const_string \"none\")\n+\t (eq_attr \"type\" \"pea\") (const_string \"mem1\")\n+\t (eq_attr \"type\" \"jmp,jsr\")\n+\t (symbol_ref \"m68k_sched_attr_opx_type (insn, 1)\")]\n+\t(symbol_ref \"m68k_sched_attr_opx_type (insn, 0)\")))\n \n ;; Access to the X operand: none, read, write, read/write, unknown.\n ;; Access to the Y operand is either none (if opy_type is none)\n ;; or read otherwise.\n-(define_attr \"opx_access\" \"none, r, w, rw, unknown\"\n-  (cond [(eq_attr \"type1\" \"rts,unlk\") (const_string \"none\")\n-\t (eq_attr \"type1\" \"bcc,bra,bsr,cmp_l,jmp,jsr,tst,tst_l\")\n-\t (const_string \"r\")\n-\t (eq_attr \"type1\" \"clr,lea,mov3q_l,move,move_l,moveq_l,pea\")\n-\t (const_string \"w\")\n-\t (eq_attr \"type1\" \"alu_l,alu_reg1,alu_regx,aluq_l\")\n-\t (const_string \"rw\")]\n-\t(const_string \"unknown\")))\n-\n-;; Memory relation of operands:\n-;; r - register or immediate operand\n-;; m - non-indexed memory location\n-;; i - indexed memory location\n-\n-(define_attr \"opx_mem\" \"r, m, i, unknown\"\n-  (cond [(eq_attr \"opx_type\" \"none,reg,imm_q,imm_w,imm_l\") (const_string \"r\")\n-\t (eq_attr \"opx_type\" \"mem1,mem234,mem5,mem7\") (const_string \"m\")\n-\t (eq_attr \"opx_type\" \"mem6\") (const_string \"i\")]\n-\t(const_string \"unknown\")))\n-\n-(define_attr \"opy_mem\" \"r, m, i, unknown\"\n-  (cond [(eq_attr \"opy_type\" \"none,reg,imm_q,imm_w,imm_l\") (const_string \"r\")\n-\t (eq_attr \"opy_type\" \"mem1,mem234,mem5,mem7\") (const_string \"m\")\n-\t (eq_attr \"opy_type\" \"mem6\") (const_string \"i\")]\n-\t(const_string \"unknown\")))\n+(define_attr \"opx_access\" \"none, r, w, rw\"\n+  (cond [(eq_attr \"type\" \"ib,ignore,nop,rts,trap,unlk,\n+                          unknown\") (const_string \"none\")\n+\t (eq_attr \"type\" \"bcc,bra,bsr,bitr,cmp,cmp_l,fbcc,fcmp,ftst,\n+                          jmp,jsr,tst,tst_l\") (const_string \"r\")\n+\t (eq_attr \"type\" \"clr,clr_l,fneg,fmove,lea,\n+                          mov3q_l,move,move_l,moveq_l,mvsz,\n+                          pea,scc\") (const_string \"w\")\n+\t (eq_attr \"type\" \"alu_l,aluq_l,alux_l,bitrw,div_w,div_l,ext,\n+                          falu,fdiv,fmul,fsqrt,link,mul_w,mul_l,\n+                          neg_l,shift\") (const_string \"rw\")]\n+\t;; Should never be used.\n+\t(symbol_ref \"(gcc_unreachable (), OPX_ACCESS_NONE)\")))\n \n ;; Memory accesses of the insn.\n ;; 00 - no memory references\n ;; 10 - memory is read\n-;; i10 - indexed memory is read\n+;; i0 - indexed memory is read\n ;; 01 - memory is written\n-;; 0i1 - indexed memory is written\n+;; 0i - indexed memory is written\n ;; 11 - memory is read, memory is written\n-;; i11 - indexed memory is read, memory is written\n-;; 1i1 - memory is read, indexed memory is written\n-;;\n-;; unknown - should now occur on normal insn.\n-;; ??? This attribute is implemented in C to spare genattrtab from\n-;; ??? optimizing it.\n-(define_attr \"op_mem\" \"00, 10, i0, 01, 0i, 11, i1, 1i, unknown\"\n-;  (cond [(and (eq_attr \"opy_mem\" \"r\") (eq_attr \"opx_mem\" \"r\"))\n-;\t (const_string \"00\")\n-;\n-;\t (and (eq_attr \"opy_mem\" \"r\") (eq_attr \"opx_mem\" \"m\"))\n-;\t (cond [(eq_attr \"opx_access\" \"r\") (const_string \"10\")\n-;\t        (eq_attr \"opx_access\" \"w\") (const_string \"01\")\n-;\t        (eq_attr \"opx_access\" \"rw\") (const_string \"11\")]\n-;\t       (const_string \"unknown\"))\n-;\n-;\t (and (eq_attr \"opy_mem\" \"r\") (eq_attr \"opx_mem\" \"i\"))\n-;\t (cond [(eq_attr \"opx_access\" \"r\") (const_string \"i0\")\n-;\t        (eq_attr \"opx_access\" \"w\") (const_string \"0i\")\n-;\t\t(eq_attr \"opx_access\" \"rw\") (const_string \"i1\")]\n-;\t       (const_string \"unknown\"))\n-;\n-;\t (and (eq_attr \"opy_mem\" \"m\") (eq_attr \"opx_mem\" \"r\"))\n-;\t (const_string \"10\")\n-;\n-;\t (and (eq_attr \"opy_mem\" \"m\") (eq_attr \"opx_mem\" \"m\"))\n-;\t (cond [(eq_attr \"opx_access\" \"w\") (const_string \"11\")]\n-;\t       (const_string \"unknown\"))\n-;\n-;\t (and (eq_attr \"opy_mem\" \"m\") (eq_attr \"opx_mem\" \"i\"))\n-;\t (cond [(eq_attr \"opx_access\" \"w\") (const_string \"1i\")]\n-;\t       (const_string \"unknown\"))\n-;\n-;\t (and (eq_attr \"opy_mem\" \"i\") (eq_attr \"opx_mem\" \"r\"))\n-;\t (const_string \"i0\")\n-;\n-;\t (and (eq_attr \"opy_mem\" \"i\") (eq_attr \"opx_mem\" \"m\"))\n-;\t (cond [(eq_attr \"opx_access\" \"w\") (const_string \"i1\")]\n-;\t       (const_string \"unknown\"))]\n-;\t(const_string \"unknown\"))\n+;; i1 - indexed memory is read, memory is written\n+;; 1i - memory is read, indexed memory is written\n+(define_attr \"op_mem\" \"00, 10, i0, 01, 0i, 11, i1, 1i\"\n   (symbol_ref \"m68k_sched_attr_op_mem (insn)\"))\n \n-;; Attribute to support partial automata description.\n-;; This attribute has value 'yes' for instructions that are not\n-;; fully handled yet.\n-(define_attr \"guess\" \"yes, no\"\n-  (cond [(ior (eq (symbol_ref \"reload_completed\") (const_int 0))\n-\t      (eq_attr \"type1\" \"unknown\"))\n-\t (const_string \"yes\")]\n-\t(const_string \"no\")))\n-\n-;; Attribute to support statistics gathering.\n-;; Todo means that insn lacks something to get pipeline description.\n-;; Done means that insn was transformed to suit pipeline description.\n-;; Nothing means that insn was originally good enough for scheduling. \n-(define_attr \"split\" \"todo, done, nothing\"\n-  (if_then_else (eq_attr \"type\" \"unknown\")\n-\t\t(const_string \"todo\")\n-\t\t(const_string \"nothing\")))\n+;; Instruction size in words.\n+(define_attr \"size\" \"1,2,3\"\n+  (symbol_ref \"m68k_sched_attr_size (insn)\"))\n+\n \f\n ;; Mode macros for floating point operations.\n ;; Valid floating point modes\n@@ -369,8 +272,7 @@\n   m68k_emit_move_double (operands);\n   DONE;\n }\n-  [(set_attr \"type\" \"fmove,*\")\n-   (set_attr \"split\" \"done,*\")])\n+  [(set_attr \"type\" \"fmove,*\")])\n \n (define_insn_and_split \"pushdi\"\n   [(set (match_operand:DI 0 \"push_operand\" \"=m\")\n@@ -450,7 +352,7 @@\n   \"@\n    tst%.l %0\n    cmp%.w #0,%0\"\n-  [(set_attr \"type\" \"tst_l,*\")])\n+  [(set_attr \"type\" \"tst_l,cmp\")])\n \n ;; This can't use an address register, because comparisons\n ;; with address registers as second operand always test the whole word.\n@@ -465,7 +367,7 @@\n \t(match_operand:HI 0 \"nonimmediate_operand\" \"dm\"))]\n   \"\"\n   \"tst%.w %0\"\n-  [(set_attr \"type\" \"tst_w\")])\n+  [(set_attr \"type\" \"tst\")])\n \n (define_expand \"tstqi\"\n   [(set (cc0)\n@@ -478,7 +380,7 @@\n \t(match_operand:QI 0 \"nonimmediate_operand\" \"dm\"))]\n   \"\"\n   \"tst%.b %0\"\n-  [(set_attr \"type\" \"tst_b\")])\n+  [(set_attr \"type\" \"tst\")])\n \n (define_expand \"tst<mode>\"\n   [(set (cc0)\n@@ -497,7 +399,8 @@\n   if (FP_REG_P (operands[0]))\n     return \"ftst%.x %0\";\n   return \"ftst%.<FP:prec> %0\";\n-})\n+}\n+  [(set_attr \"type\" \"ftst\")])\n \n (define_insn \"tst<mode>_cf\"\n   [(set (cc0)\n@@ -605,7 +508,7 @@\n   if ((REG_P (operands[1]) && !ADDRESS_REG_P (operands[1]))\n       || (!REG_P (operands[0]) && GET_CODE (operands[0]) != MEM))\n     {\n-      cc_status.flags |= CC_REVERSED;\n+      cc_status.flags |= CC_REVERSED; /*|*/\n       return \"cmp%.w %d0,%d1\";\n     }\n   return \"cmp%.w %d1,%d0\";\n@@ -797,8 +700,7 @@\n    clr%.l %0\n    mov3q%.l %1,%-\n    pea %a1\"\n-  [(set_attr \"type\" \"clr_l,mov3q_l,pea\")\n-   (set_attr \"split\" \"done\")])\n+  [(set_attr \"type\" \"clr_l,mov3q_l,pea\")])\n \n ;This is never used.\n ;(define_insn \"swapsi\"\n@@ -818,9 +720,8 @@\n    moveq #0,%0\n    sub%.l %0,%0\n    clr%.l %0\"\n-  [(set_attr \"type\" \"moveq_l,sub_l,clr_l\")\n-   (set_attr \"opy_type\" \"imm_q,reg,*\")\n-   (set_attr \"split\" \"done\")])\n+  [(set_attr \"type\" \"moveq_l,alu_l,clr_l\")\n+   (set_attr \"opy\" \"*,0,*\")])\n \n ;; Special case of fullword move when source is zero for 68040_60.\n ;; On the '040, 'subl an,an' takes 2 clocks while lea takes only 1\n@@ -839,9 +740,7 @@\n       return \"\";\n     }\n }\n-  [(set_attr \"type\" \"lea,clr_l\")\n-   (set_attr \"opy_type\" \"imm_w,*\")\n-   (set_attr \"split\" \"done\")])\n+  [(set_attr \"type\" \"lea,clr_l\")])\n \n ;; Special case of fullword move when source is zero.\n (define_insn \"*movsi_const0\"\n@@ -851,9 +750,8 @@\n   \"@\n    sub%.l %0,%0\n    clr%.l %0\"\n-  [(set_attr \"type\" \"sub_l,clr_l\")\n-   (set_attr \"opy_type\" \"reg,*\")\n-   (set_attr \"split\" \"done\")])\n+  [(set_attr \"type\" \"alu_l,clr_l\")\n+   (set_attr \"opy\" \"0,*\")])\n \n ;; General case of fullword move.\n ;;\n@@ -978,11 +876,7 @@\n       return \"\";\n     }\n }\n-  [(set_attr \"type\" \"mov3q_l, moveq_l,*, mvz_w, mvs_w, move_l, move_w, pea, lea, move_l, move_l, move_l\")\n-   (set (attr \"split\")\n-\t(if_then_else (eq_attr \"alternative\" \"2\")\n-\t\t      (const_string \"*\")\n-\t\t      (const_string \"done\")))])\n+  [(set_attr \"type\" \"mov3q_l,moveq_l,*,mvsz,mvsz,move_l,move,pea,lea,move_l,move_l,move_l\")])\n \n ;; Special case of fullword move, where we need to get a non-GOT PIC\n ;; reference into an address register.\n@@ -1071,8 +965,7 @@\n    clr%.b %0\n    move%.b %1,%0\n    move%.b %1,%0\"\n-  [(set_attr \"type\" \"clr_b,clr_b,move_b,move_b\")\n-   (set_attr \"split\" \"done\")])\n+  [(set_attr \"type\" \"clr,clr,move,move\")])\n \n (define_expand \"pushqi1\"\n   [(set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG) (const_int -2)))\n@@ -1693,7 +1586,7 @@\n \t(zero_extend:SI (match_operand:HI 1 \"nonimmediate_src_operand\" \"rmS\")))]\n   \"ISA_HAS_MVS_MVZ\"\n   \"mvz%.w %1,%0\"\n-  [(set_attr \"type\" \"mvz_w\")])\n+  [(set_attr \"type\" \"mvsz\")])\n \n (define_insn \"zero_extendhisi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n@@ -1718,7 +1611,7 @@\n \t(zero_extend:SI (match_operand:QI 1 \"nonimmediate_src_operand\" \"dmS\")))]\n   \"ISA_HAS_MVS_MVZ\"\n   \"mvz%.b %1,%0\"\n-  [(set_attr \"type\" \"mvz_b\")])\n+  [(set_attr \"type\" \"mvsz\")])\n \n (define_insn \"zero_extendqisi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n@@ -1871,7 +1764,7 @@\n \t (match_operand:HI 1 \"nonimmediate_src_operand\" \"rmS\")))]\n   \"ISA_HAS_MVS_MVZ\"\n   \"mvs%.w %1,%0\"\n-  [(set_attr \"type\" \"mvs_w\")])\n+  [(set_attr \"type\" \"mvsz\")])\n \n (define_insn \"*68k_extendhisi2\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=*d,a\")\n@@ -1881,14 +1774,14 @@\n   \"@\n    ext%.l %0\n    move%.w %1,%0\"\n-  [(set_attr \"type\" \"ext_l,move_w\")])\n+  [(set_attr \"type\" \"ext,move\")])\n \n (define_insn \"extendqihi2\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=d\")\n \t(sign_extend:HI (match_operand:QI 1 \"nonimmediate_operand\" \"0\")))]\n   \"\"\n   \"ext%.w %0\"\n-  [(set_attr \"type\" \"ext_w\")])\n+  [(set_attr \"type\" \"ext\")])\n \n (define_expand \"extendqisi2\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n@@ -1901,14 +1794,14 @@\n \t(sign_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"rms\")))]\n   \"ISA_HAS_MVS_MVZ\"\n   \"mvs%.b %1,%0\"\n-  [(set_attr \"type\" \"mvs_b\")])\n+  [(set_attr \"type\" \"mvsz\")])\n \n (define_insn \"*68k_extendqisi2\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d\")\n \t(sign_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"0\")))]\n   \"TARGET_68020 || (TARGET_COLDFIRE && !ISA_HAS_MVS_MVZ)\"\n   \"extb%.l %0\"\n-  [(set_attr \"type\" \"extb_l\")])\n+  [(set_attr \"type\" \"ext\")])\n \f\n ;; Conversions between float and double.\n \n@@ -2026,7 +1919,8 @@\n   [(set (match_operand:FP 0 \"nonimmediate_operand\" \"=f\")\n \t(float:FP (match_operand:SI 1 \"general_operand\" \"dmi\")))]\n   \"TARGET_68881\"\n-  \"f<FP:round>move%.l %1,%0\")\n+  \"f<FP:round>move%.l %1,%0\"\n+  [(set_attr \"type\" \"fmove\")])\n \n (define_insn \"floatsi<mode>2_cf\"\n   [(set (match_operand:FP 0 \"nonimmediate_operand\" \"=f\")\n@@ -2133,7 +2027,8 @@\n   if (FP_REG_P (operands[1]))\n     return \"fintrz%.x %f1,%0\";\n   return \"fintrz%.<FP:prec> %f1,%0\";\n-})\n+}\n+  [(set_attr \"type\" \"falu\")])\n \n (define_insn \"ftrunc<mode>2_cf\"\n   [(set (match_operand:FP 0 \"nonimmediate_operand\" \"=f\")\n@@ -2144,7 +2039,7 @@\n     return \"fintrz%.d %f1,%0\";\n   return \"fintrz%.<FP:prec> %f1,%0\";\n }\n-  [(set_attr \"type\" \"fintrz\")])\n+  [(set_attr \"type\" \"falu\")])\n \n ;; Convert a float whose value is an integer\n ;; to an actual integer.  Second stage of converting float to integer type.\n@@ -2158,7 +2053,8 @@\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=dm\")\n \t(fix:QI (match_operand:FP 1 \"general_operand\" \"f\")))]\n   \"TARGET_68881\"\n-  \"fmove%.b %1,%0\")\n+  \"fmove%.b %1,%0\"\n+  [(set_attr \"type\" \"fmove\")])\n \n (define_insn \"fix<mode>qi2_cf\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=d<Q>U\")\n@@ -2177,7 +2073,8 @@\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=dm\")\n \t(fix:HI (match_operand:FP 1 \"general_operand\" \"f\")))]\n   \"TARGET_68881\"\n-  \"fmove%.w %1,%0\")\n+  \"fmove%.w %1,%0\"\n+  [(set_attr \"type\" \"fmove\")])\n \n (define_insn \"fix<mode>hi2_cf\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=d<Q>U\")\n@@ -2196,7 +2093,8 @@\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=dm\")\n \t(fix:SI (match_operand:FP 1 \"general_operand\" \"f\")))]\n   \"TARGET_68881\"\n-  \"fmove%.l %1,%0\")\n+  \"fmove%.l %1,%0\"\n+  [(set_attr \"type\" \"fmove\")])\n \n (define_insn \"fix<mode>si2_cf\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d<Q>U\")\n@@ -2302,7 +2200,7 @@\n     operands[1] = adjust_address (operands[1], SImode, 4);\n   return \"add%.l %1,%0\";\n }\n-  [(set_attr \"type\" \"add_l\")])\n+  [(set_attr \"type\" \"alu_l\")])\n \n (define_insn \"adddi3\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=o<>,d,d,d\")\n@@ -2469,10 +2367,9 @@\n \t(plus:SI (match_dup 0)\n \t\t (match_dup 1)))]\n   \"\"\n-  [(set_attr \"type\" \"addq_l,subq_l,add_l,add_l,*,lea,lea,lea\")\n+  [(set_attr \"type\" \"aluq_l,aluq_l,alu_l,alu_l,*,lea,lea,lea\")\n    (set_attr \"opy\" \"2,2,2,2,*,*,*,*\")\n-   (set_attr \"opy_type\" \"*,*,*,*,*,mem6,mem6,mem5\")\n-   (set_attr \"split\" \"done,done,done,done,*,done,done,done\")])\n+   (set_attr \"opy_type\" \"*,*,*,*,*,mem6,mem6,mem5\")])\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=a\")\n@@ -2716,21 +2613,27 @@\n \t(plus:FP (float:FP (match_operand:SI 2 \"general_operand\" \"dmi\"))\n \t\t (match_operand:FP 1 \"general_operand\" \"0\")))]\n   \"TARGET_68881\"\n-  \"f<FP:round>add%.l %2,%0\")\n+  \"f<FP:round>add%.l %2,%0\"\n+  [(set_attr \"type\" \"falu\")\n+   (set_attr \"opy\" \"2\")])\n \n (define_insn \"add<mode>3_floathi_68881\"\n   [(set (match_operand:FP 0 \"nonimmediate_operand\" \"=f\")\n \t(plus:FP (float:FP (match_operand:HI 2 \"general_operand\" \"dmn\"))\n \t\t (match_operand:FP 1 \"general_operand\" \"0\")))]\n   \"TARGET_68881\"\n-  \"f<FP:round>add%.w %2,%0\")\n+  \"f<FP:round>add%.w %2,%0\"\n+  [(set_attr \"type\" \"falu\")\n+   (set_attr \"opy\" \"2\")])\n \n (define_insn \"add<mode>3_floatqi_68881\"\n   [(set (match_operand:FP 0 \"nonimmediate_operand\" \"=f\")\n \t(plus:FP (float:FP (match_operand:QI 2 \"general_operand\" \"dmn\"))\n \t\t (match_operand:FP 1 \"general_operand\" \"0\")))]\n   \"TARGET_68881\"\n-  \"f<FP:round>add%.b %2,%0\")\n+  \"f<FP:round>add%.b %2,%0\"\n+  [(set_attr \"type\" \"falu\")\n+   (set_attr \"opy\" \"2\")])\n \n (define_insn \"add<mode>3_68881\"\n   [(set (match_operand:FP 0 \"nonimmediate_operand\" \"=f\")\n@@ -2741,7 +2644,9 @@\n   if (FP_REG_P (operands[2]))\n     return \"f<FP:round>add%.x %2,%0\";\n   return \"f<FP:round>add%.<FP:prec> %f2,%0\";\n-})\n+}\n+  [(set_attr \"type\" \"falu\")\n+   (set_attr \"opy\" \"2\")])\n \n (define_insn \"add<mode>3_cf\"\n   [(set (match_operand:FP 0 \"nonimmediate_operand\" \"=f\")\n@@ -2753,7 +2658,8 @@\n     return \"f<FP:prec>add%.d %2,%0\";\n   return \"f<FP:prec>add%.<FP:prec> %2,%0\";\n }\n-  [(set_attr \"type\" \"fadd\")])\n+  [(set_attr \"type\" \"falu\")\n+   (set_attr \"opy\" \"2\")])\n \f\n ;; subtract instructions\n \n@@ -2788,7 +2694,7 @@\n     operands[1] = adjust_address (operands[1], SImode, 4);\n   return \"sub%.l %1,%0\";\n }\n-  [(set_attr \"type\" \"sub_l\")])\n+  [(set_attr \"type\" \"alu_l\")])\n \n (define_insn \"subdi3\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=o<>,d,d,d\")\n@@ -2879,7 +2785,7 @@\n    sub%.l %2,%0\n    sub%.l %2,%0\n    sub%.l %2,%0\"\n-  [(set_attr \"type\" \"subq_l,sub_l,sub_l,sub_l\")\n+  [(set_attr \"type\" \"aluq_l,alu_l,alu_l,alu_l\")\n    (set_attr \"opy\" \"2\")])\n \n (define_insn \"\"\n@@ -2930,21 +2836,27 @@\n \t(minus:FP (match_operand:FP 1 \"general_operand\" \"0\")\n \t\t  (float:FP (match_operand:SI 2 \"general_operand\" \"dmi\"))))]\n   \"TARGET_68881\"\n-  \"f<FP:round>sub%.l %2,%0\")\n+  \"f<FP:round>sub%.l %2,%0\"\n+  [(set_attr \"type\" \"falu\")\n+   (set_attr \"opy\" \"2\")])\n \n (define_insn \"sub<mode>3_floathi_68881\"\n   [(set (match_operand:FP 0 \"nonimmediate_operand\" \"=f\")\n \t(minus:FP (match_operand:FP 1 \"general_operand\" \"0\")\n \t\t  (float:FP (match_operand:HI 2 \"general_operand\" \"dmn\"))))]\n   \"TARGET_68881\"\n-  \"f<FP:round>sub%.w %2,%0\")\n+  \"f<FP:round>sub%.w %2,%0\"\n+  [(set_attr \"type\" \"falu\")\n+   (set_attr \"opy\" \"2\")])\n \n (define_insn \"sub<mode>3_floatqi_68881\"\n   [(set (match_operand:FP 0 \"nonimmediate_operand\" \"=f\")\n \t(minus:FP (match_operand:FP 1 \"general_operand\" \"0\")\n \t\t  (float:FP (match_operand:QI 2 \"general_operand\" \"dmn\"))))]\n   \"TARGET_68881\"\n-  \"f<FP:round>sub%.b %2,%0\")\n+  \"f<FP:round>sub%.b %2,%0\"\n+  [(set_attr \"type\" \"falu\")\n+   (set_attr \"opy\" \"2\")])\n \n (define_insn \"sub<mode>3_68881\"\n   [(set (match_operand:FP 0 \"nonimmediate_operand\" \"=f\")\n@@ -2955,7 +2867,9 @@\n   if (FP_REG_P (operands[2]))\n     return \"f<FP:round>sub%.x %2,%0\";\n   return \"f<FP:round>sub%.<FP:prec> %f2,%0\";\n-})\n+}\n+  [(set_attr \"type\" \"falu\")\n+   (set_attr \"opy\" \"2\")])\n \n (define_insn \"sub<mode>3_cf\"\n   [(set (match_operand:FP 0 \"nonimmediate_operand\" \"=f\")\n@@ -2967,7 +2881,8 @@\n     return \"f<FP:prec>sub%.d %2,%0\";\n   return \"f<FP:prec>sub%.<FP:prec> %2,%0\";\n }\n-  [(set_attr \"type\" \"fsub\")])\n+  [(set_attr \"type\" \"falu\")\n+   (set_attr \"opy\" \"2\")])\n \f\n ;; multiply instructions\n \n@@ -2979,7 +2894,7 @@\n {\n   return MOTOROLA ? \"muls%.w %2,%0\" : \"muls %2,%0\";\n }\n-  [(set_attr \"type\" \"muls_w\")\n+  [(set_attr \"type\" \"mul_w\")\n    (set_attr \"opy\" \"2\")])\n \n (define_insn \"mulhisi3\"\n@@ -2992,7 +2907,7 @@\n {\n   return MOTOROLA ? \"muls%.w %2,%0\" : \"muls %2,%0\";\n }\n-  [(set_attr \"type\" \"muls_w\")\n+  [(set_attr \"type\" \"mul_w\")\n    (set_attr \"opy\" \"2\")])\n \n (define_insn \"*mulhisisi3_s\"\n@@ -3004,7 +2919,7 @@\n {\n   return MOTOROLA ? \"muls%.w %2,%0\" : \"muls %2,%0\";\n }\n-  [(set_attr \"type\" \"muls_w\")\n+  [(set_attr \"type\" \"mul_w\")\n    (set_attr \"opy\" \"2\")])\n \n (define_expand \"mulsi3\"\n@@ -3021,7 +2936,7 @@\n \n   \"TARGET_68020\"\n   \"muls%.l %2,%0\"\n-  [(set_attr \"type\" \"muls_l\")\n+  [(set_attr \"type\" \"mul_l\")\n    (set_attr \"opy\" \"2\")])\n \n (define_insn \"*mulsi3_cf\"\n@@ -3030,7 +2945,7 @@\n \t\t (match_operand:SI 2 \"general_operand\" \"d<Q>\")))]\n   \"TARGET_COLDFIRE\"\n   \"muls%.l %2,%0\"\n-  [(set_attr \"type\" \"muls_l\")\n+  [(set_attr \"type\" \"mul_l\")\n    (set_attr \"opy\" \"2\")])\n \n (define_insn \"umulhisi3\"\n@@ -3043,7 +2958,7 @@\n {\n   return MOTOROLA ? \"mulu%.w %2,%0\" : \"mulu %2,%0\";\n }\n-  [(set_attr \"type\" \"mulu_w\")\n+  [(set_attr \"type\" \"mul_w\")\n    (set_attr \"opy\" \"2\")])\n \n (define_insn \"*mulhisisi3_z\"\n@@ -3055,7 +2970,7 @@\n {\n   return MOTOROLA ? \"mulu%.w %2,%0\" : \"mulu %2,%0\";\n }\n-  [(set_attr \"type\" \"mulu_w\")\n+  [(set_attr \"type\" \"mul_w\")\n    (set_attr \"opy\" \"2\")])\n \n ;; We need a separate DEFINE_EXPAND for u?mulsidi3 to be able to use the\n@@ -3240,7 +3155,9 @@\n   return TARGET_68040\n \t ? \"f<FP:round>mul%.l %2,%0\"\n \t : \"f<FP:round_mul>mul%.l %2,%0\";\n-})\n+}\n+  [(set_attr \"type\" \"fmul\")\n+   (set_attr \"opy\" \"2\")])\n \n (define_insn \"mul<mode>3_floathi_68881\"\n   [(set (match_operand:FP 0 \"nonimmediate_operand\" \"=f\")\n@@ -3251,7 +3168,9 @@\n   return TARGET_68040\n \t ? \"f<FP:round>mul%.w %2,%0\"\n \t : \"f<FP:round_mul>mul%.w %2,%0\";\n-})\n+}\n+  [(set_attr \"type\" \"fmul\")\n+   (set_attr \"opy\" \"2\")])\n \n (define_insn \"mul<mode>3_floatqi_68881\"\n   [(set (match_operand:FP 0 \"nonimmediate_operand\" \"=f\")\n@@ -3262,7 +3181,9 @@\n   return TARGET_68040\n \t ? \"f<FP:round>mul%.b %2,%0\"\n \t : \"f<FP:round_mul>mul%.b %2,%0\";\n-})\n+}\n+  [(set_attr \"type\" \"fmul\")\n+   (set_attr \"opy\" \"2\")])\n \n (define_insn \"muldf_68881\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f\")\n@@ -3316,7 +3237,8 @@\n     return \"f<FP:prec>mul%.d %2,%0\";\n   return \"f<FP:prec>mul%.<FP:prec> %2,%0\";\n }\n-  [(set_attr \"type\" \"fmul\")])\n+  [(set_attr \"type\" \"fmul\")\n+   (set_attr \"opy\" \"2\")])\n \f\n ;; divide instructions\n \n@@ -3385,7 +3307,8 @@\n     return \"f<FP:prec>div%.d %2,%0\";\n   return \"f<FP:prec>div%.<FP:prec> %2,%0\";\n }\n-  [(set_attr \"type\" \"fdiv\")])\n+  [(set_attr \"type\" \"fdiv\")\n+   (set_attr \"opy\" \"2\")])\n \f\n ;; Remainder instructions.\n \n@@ -3413,7 +3336,9 @@\n     return \"rems%.l %2,%3:%0\";\n   else\n     return \"rems%.l %2,%3:%0\\;divs%.l %2,%0\";\n-})\n+}\n+  [(set_attr \"type\" \"div_l\")\n+   (set_attr \"opy\" \"2\")])\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d\")\n@@ -3453,7 +3378,9 @@\n     return \"remu%.l %2,%3:%0\";\n   else\n     return \"remu%.l %2,%3:%0\\;divu%.l %2,%0\";\n-})\n+}\n+  [(set_attr \"type\" \"div_l\")\n+   (set_attr \"opy\" \"2\")])\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d\")\n@@ -4261,7 +4188,8 @@\n   if (FP_REG_P (operands[1]))\n     return \"f<FP:prec>sqrt%.d %1,%0\";\n   return \"f<FP:prec>sqrt%.<FP:prec> %1,%0\";\n-})\n+}\n+  [(set_attr \"type\" \"fsqrt\")])\n ;; Absolute value instructions\n ;; If using software floating point, just zero the sign bit.\n \n@@ -4384,7 +4312,8 @@\n   if (FP_REG_P (operands[1]))\n     return \"f<FP:prec>abs%.d %1,%0\";\n   return \"f<FP:prec>abs%.<FP:prec> %1,%0\";\n-})\n+}\n+  [(set_attr \"type\" \"bitrw,fneg\")])\n \f\n ;; bit indexing instructions\n \n@@ -4394,7 +4323,7 @@\n  \t(clz:SI (match_operand:SI 1 \"register_operand\" \"0\")))]\n   \"ISA_HAS_FF1\"\n   \"ff1 %0\"\n-  [(set_attr \"type\" \"ff1\")])\n+  [(set_attr \"type\" \"ext\")])\n \f\n ;; one complement instructions\n \n@@ -4438,7 +4367,7 @@\n \t(not:SI (match_operand:SI 1 \"general_operand\" \"0\")))]\n   \"TARGET_COLDFIRE\"\n   \"not%.l %0\"\n-  [(set_attr \"type\" \"not_l\")])\n+  [(set_attr \"type\" \"neg_l\")])\n \n (define_insn \"one_cmplhi2\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=dm\")\n@@ -4790,7 +4719,7 @@\n     operands[1] = adjust_address (operands[1], HImode, 2);\n   return \"move%.w %1,%0\";\n }\n-  [(set_attr \"type\" \"move_w\")])\n+  [(set_attr \"type\" \"move\")])\n \n (define_insn \"subregsi1ashrdi_const32\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm\")\n@@ -4970,7 +4899,7 @@\n \t\t     (match_operand:SI 2 \"general_operand\" \"dI\")))]\n   \"\"\n   \"asr%.l %2,%0\"\n-  [(set_attr \"type\" \"asr_l\")\n+  [(set_attr \"type\" \"shift\")\n    (set_attr \"opy\" \"2\")])\n \n (define_insn \"ashrhi3\"\n@@ -5266,7 +5195,7 @@\n \t\t     (match_operand:SI 2 \"general_operand\" \"dI\")))]\n   \"\"\n   \"lsr%.l %2,%0\"\n-  [(set_attr \"type\" \"lsr_l\")\n+  [(set_attr \"type\" \"shift\")\n    (set_attr \"opy\" \"2\")])\n \n (define_insn \"lshrhi3\"\n@@ -5425,7 +5354,7 @@\n   CC_STATUS_INIT;\n   return \"bset %1,%0\";\n }\n-  [(set_attr \"type\" \"bset\")])\n+  [(set_attr \"type\" \"bitrw\")])\n \n ;; set bit, bit number is (sign/zero)_extended from HImode/QImode\n (define_insn \"*bsetmemqi_ext\"\n@@ -5439,7 +5368,7 @@\n   CC_STATUS_INIT;\n   return \"bset %1,%0\";\n }\n-  [(set_attr \"type\" \"bset\")])\n+  [(set_attr \"type\" \"bitrw\")])\n \n ;; clear bit, bit number is int\n (define_insn \"bclrmemqi\"\n@@ -5453,7 +5382,7 @@\n   CC_STATUS_INIT;\n   return \"bclr %1,%0\";\n }\n-  [(set_attr \"type\" \"bclr\")])\n+  [(set_attr \"type\" \"bitrw\")])\n \n ;; clear bit, bit number is (sign/zero)_extended from HImode/QImode\n (define_insn \"*bclrmemqi_ext\"\n@@ -5468,7 +5397,7 @@\n   CC_STATUS_INIT;\n   return \"bclr %1,%0\";\n }\n-  [(set_attr \"type\" \"bclr\")])\n+  [(set_attr \"type\" \"bitrw\")])\n \n ;; Special cases of bit-field insns which we should\n ;; recognize in preference to the general case.\n@@ -6418,8 +6347,7 @@\n {\n   OUTPUT_JUMP (\"jeq %l0\", \"fjeq %l0\", \"jeq %l0\");\n }\n-  [(set (attr \"type\") (symbol_ref \"m68k_sched_branch_type (insn)\"))\n-   (set_attr \"split\" \"done\")])\n+  [(set (attr \"type\") (symbol_ref \"m68k_sched_branch_type (insn)\"))])\n \n (define_insn \"bne\"\n   [(set (pc)\n@@ -6431,8 +6359,7 @@\n {\n   OUTPUT_JUMP (\"jne %l0\", \"fjne %l0\", \"jne %l0\");\n }\n-  [(set (attr \"type\") (symbol_ref \"m68k_sched_branch_type (insn)\"))\n-   (set_attr \"split\" \"done\")])\n+  [(set (attr \"type\") (symbol_ref \"m68k_sched_branch_type (insn)\"))])\n \n (define_insn \"bgt\"\n   [(set (pc)\n@@ -6444,8 +6371,7 @@\n {\n   OUTPUT_JUMP (\"jgt %l0\", \"fjgt %l0\", 0);\n }\n-  [(set (attr \"type\") (symbol_ref \"m68k_sched_branch_type (insn)\"))\n-   (set_attr \"split\" \"done\")])\n+  [(set (attr \"type\") (symbol_ref \"m68k_sched_branch_type (insn)\"))])\n \n (define_insn \"bgtu\"\n   [(set (pc)\n@@ -6467,8 +6393,7 @@\n {\n   OUTPUT_JUMP (\"jlt %l0\", \"fjlt %l0\", \"jmi %l0\");\n }\n-  [(set (attr \"type\") (symbol_ref \"m68k_sched_branch_type (insn)\"))\n-   (set_attr \"split\" \"done\")])\n+  [(set (attr \"type\") (symbol_ref \"m68k_sched_branch_type (insn)\"))])\n \n (define_insn \"bltu\"\n   [(set (pc)\n@@ -6532,7 +6457,8 @@\n {\n   gcc_assert (cc_prev_status.flags & CC_IN_68881);\n   return \"fjor %l0\";\n-})\n+}\n+  [(set_attr \"type\" \"fbcc\")])\n \n (define_insn \"bunordered\"\n   [(set (pc)\n@@ -6543,7 +6469,8 @@\n {\n   gcc_assert (cc_prev_status.flags & CC_IN_68881);\n   return \"fjun %l0\";\n-})\n+}\n+  [(set_attr \"type\" \"fbcc\")])\n \n (define_insn \"buneq\"\n   [(set (pc)\n@@ -6554,7 +6481,8 @@\n {\n   gcc_assert (cc_prev_status.flags & CC_IN_68881);\n   return \"fjueq %l0\";\n-})\n+}\n+  [(set_attr \"type\" \"fbcc\")])\n \n (define_insn \"bunge\"\n   [(set (pc)\n@@ -6565,7 +6493,8 @@\n {\n   gcc_assert (cc_prev_status.flags & CC_IN_68881);\n   return \"fjuge %l0\";\n-})\n+}\n+  [(set_attr \"type\" \"fbcc\")])\n \n (define_insn \"bungt\"\n   [(set (pc)\n@@ -6576,7 +6505,8 @@\n {\n   gcc_assert (cc_prev_status.flags & CC_IN_68881);\n   return \"fjugt %l0\";\n-})\n+}\n+  [(set_attr \"type\" \"fbcc\")])\n \n (define_insn \"bunle\"\n   [(set (pc)\n@@ -6587,7 +6517,8 @@\n {\n   gcc_assert (cc_prev_status.flags & CC_IN_68881);\n   return \"fjule %l0\";\n-})\n+}\n+  [(set_attr \"type\" \"fbcc\")])\n \n (define_insn \"bunlt\"\n   [(set (pc)\n@@ -6598,7 +6529,8 @@\n {\n   gcc_assert (cc_prev_status.flags & CC_IN_68881);\n   return \"fjult %l0\";\n-})\n+}\n+  [(set_attr \"type\" \"fbcc\")])\n \n (define_insn \"bltgt\"\n   [(set (pc)\n@@ -6609,7 +6541,8 @@\n {\n   gcc_assert (cc_prev_status.flags & CC_IN_68881);\n   return \"fjogl %l0\";\n-})\n+}\n+  [(set_attr \"type\" \"fbcc\")])\n \f\n ;; Negated conditional jump instructions.\n \n@@ -6734,7 +6667,8 @@\n {\n   gcc_assert (cc_prev_status.flags & CC_IN_68881);\n   return \"fjun %l0\";\n-})\n+}\n+  [(set_attr \"type\" \"fbcc\")])\n \n (define_insn \"*bunordered_rev\"\n   [(set (pc)\n@@ -6745,7 +6679,8 @@\n {\n   gcc_assert (cc_prev_status.flags & CC_IN_68881);\n   return \"fjor %l0\";\n-})\n+}\n+  [(set_attr \"type\" \"fbcc\")])\n \n (define_insn \"*buneq_rev\"\n   [(set (pc)\n@@ -6756,7 +6691,8 @@\n {\n   gcc_assert (cc_prev_status.flags & CC_IN_68881);\n   return \"fjogl %l0\";\n-})\n+}\n+  [(set_attr \"type\" \"fbcc\")])\n \n (define_insn \"*bunge_rev\"\n   [(set (pc)\n@@ -6767,7 +6703,8 @@\n {\n   gcc_assert (cc_prev_status.flags & CC_IN_68881);\n   return \"fjolt %l0\";\n-})\n+}\n+  [(set_attr \"type\" \"fbcc\")])\n \n (define_insn \"*bungt_rev\"\n   [(set (pc)\n@@ -6778,7 +6715,8 @@\n {\n   gcc_assert (cc_prev_status.flags & CC_IN_68881);\n   return \"fjole %l0\";\n-})\n+}\n+  [(set_attr \"type\" \"fbcc\")])\n \n (define_insn \"*bunle_rev\"\n   [(set (pc)\n@@ -6789,7 +6727,8 @@\n {\n   gcc_assert (cc_prev_status.flags & CC_IN_68881);\n   return \"fjogt %l0\";\n-})\n+}\n+  [(set_attr \"type\" \"fbcc\")])\n \n (define_insn \"*bunlt_rev\"\n   [(set (pc)\n@@ -6800,7 +6739,8 @@\n {\n   gcc_assert (cc_prev_status.flags & CC_IN_68881);\n   return \"fjoge %l0\";\n-})\n+}\n+  [(set_attr \"type\" \"fbcc\")])\n \n (define_insn \"*bltgt_rev\"\n   [(set (pc)\n@@ -6811,7 +6751,8 @@\n {\n   gcc_assert (cc_prev_status.flags & CC_IN_68881);\n   return \"fjueq %l0\";\n-})\n+}\n+  [(set_attr \"type\" \"fbcc\")])\n \f\n ;; Unconditional and other jump instructions\n (define_insn \"jump\"\n@@ -6840,7 +6781,7 @@\n {\n   return MOTOROLA ? \"jmp (%0)\" : \"jmp %0@\";\n }\n-  [(set_attr \"type\" \"bra\")])\n+  [(set_attr \"type\" \"jmp\")])\n \n ;; Jump to variable address from dispatch table of relative addresses.\n (define_insn \"\"\n@@ -7018,7 +6959,8 @@\n   \"!SIBLING_CALL_P (insn)\"\n {\n   return output_call (operands[0]);\n-})\n+}\n+  [(set_attr \"type\" \"jsr\")])\n \n ;; Call subroutine, returning value in operand 0\n ;; (which must be a hard register).\n@@ -7040,7 +6982,6 @@\n   \"!SIBLING_CALL_P (insn)\"\n   \"jsr %a1\"\n   [(set_attr \"type\" \"jsr\")\n-   (set_attr \"split\" \"done\")\n    (set_attr \"opx\" \"1\")])\n \n (define_insn \"*symbolic_call_value_jsr\"\n@@ -7054,7 +6995,6 @@\n   return m68k_symbolic_call;\n }\n   [(set_attr \"type\" \"jsr\")\n-   (set_attr \"split\" \"done\")\n    (set_attr \"opx\" \"1\")])\n \n (define_insn \"*symbolic_call_value_bsr\"\n@@ -7070,7 +7010,6 @@\n   return m68k_symbolic_call;\n }\n   [(set_attr \"type\" \"bsr\")\n-   (set_attr \"split\" \"done\")\n    (set_attr \"opx\" \"1\")])\n \n ;; Call subroutine returning any type.\n@@ -7236,7 +7175,8 @@\n     return \"link.w %0,%1\";\n   else\n     return \"link.l %0,%1\";\n-})\n+}\n+  [(set_attr \"type\" \"link\")])\n \n (define_expand \"unlink\"\n   [(parallel\n@@ -7726,6 +7666,17 @@\n   }\n })\n \n+;; These are to prevent the scheduler from moving stores to the frame\n+;; before the stack adjustment.\n+(define_insn \"stack_tie\"\n+  [(set (mem:BLK (scratch))\n+\t(unspec:BLK [(match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t     (match_operand:SI 1 \"register_operand\" \"r\")]\n+\t\t    UNSPEC_TIE))]\n+  \"\"\n+  \"\"\n+  [(set_attr \"type\" \"ignore\")])\n+\n ;; Instruction that subscribes one word in ColdFire instruction buffer.\n ;; This instruction is used within scheduler only and should not appear\n ;; in the instruction stream."}]}