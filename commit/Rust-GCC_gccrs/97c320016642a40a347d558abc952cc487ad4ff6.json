{"sha": "97c320016642a40a347d558abc952cc487ad4ff6", "node_id": "C_kwDOANBUbNoAKDk3YzMyMDAxNjY0MmE0MGEzNDdkNTU4YWJjOTUyY2M0ODdhZDRmZjY", "commit": {"author": {"name": "Roger Sayle", "email": "roger@nextmovesoftware.com", "date": "2021-10-13T18:49:47Z"}, "committer": {"name": "Roger Sayle", "email": "roger@nextmovesoftware.com", "date": "2021-10-13T18:49:47Z"}, "message": "x86_64: Some SUBREG related optimization tweaks to i386 backend.\n\nThis patch contains two SUBREG-related optimization enabling tweaks to\nthe x86 backend.\n\nThe first change, to ix86_expand_vector_extract, cures the strange\n-march=cascadelake related non-determinism that affected my new test\ncases last week.  Extracting a QImode or HImode element from an SSE\nvector performs a zero-extension to SImode, which is currently\nrepresented as:\n\n(set (subreg:SI (reg:QI target)) (zero_extend:SI (...))\n\nUnfortunately, the semantics of this RTL doesn't quite match what was\nintended.  A set of a paradoxical subreg allows the high-bits to take\nan arbitrary value (hence the non-determinism).  A more correct\nrepresentation should be:\n\n(set (reg:SI temp) (zero_extend:SI (...))\n(set (reg:QI target) (subreg:QI (reg:SI temp))\n\nOptionally with the SUBREG rtx annotated as SUBREG_PROMOTED_VAR_P to\nindicate that value is already zero-extended in the SUBREG_REG.\n\nThe second change is very similar, which is why I've included it in\nthis patch, where currently the early RTL optimizers can produce:\n\n(set (reg:V?? hardreg) (subreg ...))\n\nwhere this instruction may require a spill/reload from memory when\nthe modes aren't tieable.  Alas the presence of the hard register\nprevents combine/gcse etc. optimizing this away, or reusing the result\nwhich would increase the lifetime of the hard register before reload.\n\nThe solution is to treat vector hard registers the same way as the\nx86 backend handles scalar hard registers, and only allow sets from\npseudos before register allocation, which is achieved by checking\nix86_hardreg_mov_ok.  Hence the above instruction is expanded and\nmaintained as:\n\n(set (reg:V?? pseudo) (subreg ...))\n(set (reg:V?? hardreg) (reg:V?? pseudo))\n\nwhich allows the RTL optimizers freedom to optimize the SUBREG.\n\n2021-10-13  Roger Sayle  <roger@nextmovesoftware.com>\n\ngcc/ChangeLog\n\t* config/i386/i386-expand.c (ix86_expand_vector_move):  Use a\n\tpseudo intermediate when moving a SUBREG into a hard register,\n\tby checking ix86_hardreg_mov_ok.\n\t(ix86_expand_vector_extract): Store zero-extended SImode\n\tintermediate in a pseudo, then set target using a SUBREG_PROMOTED\n\tannotated subreg.\n\t* config/i386/sse.md (mov<VMOVE>_internal): Prevent CSE creating\n\tcomplex (SUBREG) sets of (vector) hard registers before reload, by\n\tchecking ix86_hardreg_mov_ok.", "tree": {"sha": "e89dbe617cd88bbd6b9b683172b149d1c9ceab1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e89dbe617cd88bbd6b9b683172b149d1c9ceab1c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/97c320016642a40a347d558abc952cc487ad4ff6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97c320016642a40a347d558abc952cc487ad4ff6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97c320016642a40a347d558abc952cc487ad4ff6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97c320016642a40a347d558abc952cc487ad4ff6/comments", "author": {"login": "rogersayle", "id": 13512313, "node_id": "MDQ6VXNlcjEzNTEyMzEz", "avatar_url": "https://avatars.githubusercontent.com/u/13512313?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rogersayle", "html_url": "https://github.com/rogersayle", "followers_url": "https://api.github.com/users/rogersayle/followers", "following_url": "https://api.github.com/users/rogersayle/following{/other_user}", "gists_url": "https://api.github.com/users/rogersayle/gists{/gist_id}", "starred_url": "https://api.github.com/users/rogersayle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rogersayle/subscriptions", "organizations_url": "https://api.github.com/users/rogersayle/orgs", "repos_url": "https://api.github.com/users/rogersayle/repos", "events_url": "https://api.github.com/users/rogersayle/events{/privacy}", "received_events_url": "https://api.github.com/users/rogersayle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rogersayle", "id": 13512313, "node_id": "MDQ6VXNlcjEzNTEyMzEz", "avatar_url": "https://avatars.githubusercontent.com/u/13512313?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rogersayle", "html_url": "https://github.com/rogersayle", "followers_url": "https://api.github.com/users/rogersayle/followers", "following_url": "https://api.github.com/users/rogersayle/following{/other_user}", "gists_url": "https://api.github.com/users/rogersayle/gists{/gist_id}", "starred_url": "https://api.github.com/users/rogersayle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rogersayle/subscriptions", "organizations_url": "https://api.github.com/users/rogersayle/orgs", "repos_url": "https://api.github.com/users/rogersayle/repos", "events_url": "https://api.github.com/users/rogersayle/events{/privacy}", "received_events_url": "https://api.github.com/users/rogersayle/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "90582eb6c565afb9cef89c1781af6d9a96b086e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90582eb6c565afb9cef89c1781af6d9a96b086e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90582eb6c565afb9cef89c1781af6d9a96b086e9"}], "stats": {"total": 21, "additions": 18, "deletions": 3}, "files": [{"sha": "707e1462319ec51d7158fcb6cdbbaa51706345a8", "filename": "gcc/config/i386/i386-expand.c", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97c320016642a40a347d558abc952cc487ad4ff6/gcc%2Fconfig%2Fi386%2Fi386-expand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97c320016642a40a347d558abc952cc487ad4ff6/gcc%2Fconfig%2Fi386%2Fi386-expand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-expand.c?ref=97c320016642a40a347d558abc952cc487ad4ff6", "patch": "@@ -615,6 +615,16 @@ ix86_expand_vector_move (machine_mode mode, rtx operands[])\n       return;\n     }\n \n+  /* If operand0 is a hard register, make operand1 a pseudo.  */\n+  if (can_create_pseudo_p ()\n+      && !ix86_hardreg_mov_ok (op0, op1))\n+    {\n+      rtx tmp = gen_reg_rtx (GET_MODE (op0));\n+      emit_move_insn (tmp, op1);\n+      emit_move_insn (op0, tmp);\n+      return;\n+    }\n+\n   /* Make operand1 a register if it isn't already.  */\n   if (can_create_pseudo_p ()\n       && !register_operand (op0, mode)\n@@ -16016,11 +16026,15 @@ ix86_expand_vector_extract (bool mmx_ok, rtx target, rtx vec, int elt)\n       /* Let the rtl optimizers know about the zero extension performed.  */\n       if (inner_mode == QImode || inner_mode == HImode)\n \t{\n+\t  rtx reg = gen_reg_rtx (SImode);\n \t  tmp = gen_rtx_ZERO_EXTEND (SImode, tmp);\n-\t  target = gen_lowpart (SImode, target);\n+\t  emit_move_insn (reg, tmp);\n+\t  tmp = gen_lowpart (inner_mode, reg);\n+\t  SUBREG_PROMOTED_VAR_P (tmp) = 1;\n+\t  SUBREG_PROMOTED_SET (tmp, 1);\n \t}\n \n-      emit_insn (gen_rtx_SET (target, tmp));\n+      emit_move_insn (target, tmp);\n     }\n   else\n     {"}, {"sha": "8a4ab9b6cab53da82f1428375623267282b9b182", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97c320016642a40a347d558abc952cc487ad4ff6/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97c320016642a40a347d558abc952cc487ad4ff6/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=97c320016642a40a347d558abc952cc487ad4ff6", "patch": "@@ -1269,7 +1269,8 @@\n \t \" C,<sseconstm1>,vm,v\"))]\n   \"TARGET_SSE\n    && (register_operand (operands[0], <MODE>mode)\n-       || register_operand (operands[1], <MODE>mode))\"\n+       || register_operand (operands[1], <MODE>mode))\n+   && ix86_hardreg_mov_ok (operands[0], operands[1])\"\n {\n   switch (get_attr_type (insn))\n     {"}]}