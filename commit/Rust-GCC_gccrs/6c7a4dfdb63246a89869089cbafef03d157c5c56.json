{"sha": "6c7a4dfdb63246a89869089cbafef03d157c5c56", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmM3YTRkZmRiNjMyNDZhODk4NjkwODljYmFmZWYwM2QxNTdjNWM1Ng==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2006-02-14T16:38:03Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2006-02-14T16:38:03Z"}, "message": "re PR fortran/25162 (Issue with OpenMP COPYIN and gfortran)\n\ngcc/fortran/\n2006-02-14  Jakub Jelinek  <jakub@redhat.com>\n\t    Richard Henderson  <rth@redhat.com>\n\t    Diego Novillo  <dnovillo@redhat.com>\n\n\t* invoke.texi: Document -fopenmp.\n\t* gfortran.texi (Extensions): Document OpenMP.\n\n\tBackport from gomp-20050608-branch\n\t* trans-openmp.c: Call build_omp_clause instead of\n\tmake_node when creating OMP_CLAUSE_* trees.\n\t(gfc_trans_omp_reduction_list): Remove argument 'code'.\n\tAdjust all callers.\n\n\t* trans.h (build4_v): Define.\n\t* trans-openmp.c: Call build4_v to create OMP_PARALLEL nodes.\n\tCall build3_v to create OMP_SECTIONS nodes.\n\n\tPR fortran/25162\n\t* openmp.c (gfc_match_omp_variable_list): Call gfc_set_sym_referenced\n\ton all symbols added to the variable list.\n\n\t* openmp.c (gfc_match_omp_clauses): Fix check for non-INTRINSIC\n\tprocedure symbol in REDUCTION.\n\n\t* trans-openmp.c (gfc_trans_omp_array_reduction): Use gfc_add\n\tfor MINUS_EXPR OMP_CLAUSE_REDUCTION_CODE.\n\n\t* trans-openmp.c (gfc_trans_omp_do): Add PBLOCK argument.  If PBLOCK\n\tis non-NULL, evaluate INIT/COND/INCR and chunk size expressions in\n\tthat statement block.\n\t(gfc_trans_omp_parallel_do): Pass non-NULL PBLOCK to gfc_trans_omp_do\n\tfor non-ordered non-static combined loops.\n\t(gfc_trans_omp_directive): Pass NULL PBLOCK to gfc_trans_omp_do.\n\n\t* openmp.c: Include target.h and toplev.h.\n\t(gfc_match_omp_threadprivate): Emit diagnostic if target does\n\tnot support TLS.\n\t* Make-lang.in (fortran/openmp.o): Add dependencies on\n\ttarget.h and toplev.h.\n\n\t* trans-decl.c (gfc_get_fake_result_decl): Set GFC_DECL_RESULT.\n\t* trans-openmp.c (gfc_omp_privatize_by_reference): Make\n\tDECL_ARTIFICIAL vars predetermined shared except GFC_DECL_RESULT.\n\t(gfc_omp_disregard_value_expr): Handle GFC_DECL_RESULT.\n\t(gfc_trans_omp_variable): New function.\n\t(gfc_trans_omp_variable_list, gfc_trans_omp_reduction_list): Use it.\n\t* trans.h (GFC_DECL_RESULT): Define.\n\n\t* trans-openmp.c (gfc_omp_firstprivatize_type_sizes): New function.\n\t* f95-lang.c (LANG_HOOKS_OMP_FIRSTPRIVATIZE_TYPE_SIZES): Define.\n\t* trans.h (gfc_omp_firstprivatize_type_sizes): New prototype.\n\n\t* trans-openmp.c (gfc_omp_privatize_by_reference): Return\n\ttrue if a pointer has GFC_DECL_SAVED_DESCRIPTOR set.\n\t(gfc_trans_omp_array_reduction, gfc_trans_omp_reduction_list): New\n\tfunctions.\n\t(gfc_trans_omp_clauses): Add WHERE argument.  Call\n\tgfc_trans_omp_reduction_list rather than gfc_trans_omp_variable_list\n\tfor reductions.\n\t(gfc_trans_omp_do, gfc_trans_omp_parallel, gfc_trans_omp_parallel_do,\n\tgfc_trans_omp_parallel_sections, gfc_trans_omp_parallel_workshare,\n\tgfc_trans_omp_sections, gfc_trans_omp_single): Adjust\n\tgfc_trans_omp_clauses callers.\n\n\t* openmp.c (omp_current_do_code): New var.\n\t(gfc_resolve_omp_do_blocks): New function.\n\t(gfc_resolve_omp_parallel_blocks): Call it.\n\t(gfc_resolve_do_iterator): Add CODE argument.  Don't propagate\n\tpredetermination if argument is !$omp do or !$omp parallel do\n\titeration variable.\n\t* resolve.c (resolve_code): Call gfc_resolve_omp_do_blocks\n\tfor EXEC_OMP_DO.  Adjust gfc_resolve_do_iterator caller.\n\t* fortran.h (gfc_resolve_omp_do_blocks): New prototype.\n\t(gfc_resolve_do_iterator): Add CODE argument.\n\n\t* trans.h (gfc_omp_predetermined_sharing,\n\tgfc_omp_disregard_value_expr, gfc_omp_private_debug_clause): New\n\tprototypes.\n\t(GFC_DECL_COMMON_OR_EQUIV, GFC_DECL_CRAY_POINTEE): Define.\n\t* trans-openmp.c (gfc_omp_predetermined_sharing,\n\tgfc_omp_disregard_value_expr, gfc_omp_private_debug_clause): New\n\tfunctions.\n\t* trans-common.c (build_equiv_decl, build_common_decl,\n\tcreate_common): Set GFC_DECL_COMMON_OR_EQUIV flag on the decls.\n\t* trans-decl.c (gfc_finish_cray_pointee): Set GFC_DECL_CRAY_POINTEE\n\ton the decl.\n\t* f95-lang.c (LANG_HOOKS_OMP_PREDETERMINED_SHARING,\n\tLANG_HOOKS_OMP_DISREGARD_VALUE_EXPR,\n\tLANG_HOOKS_OMP_PRIVATE_DEBUG_CLAUSE): Define.\n\n\t* openmp.c (resolve_omp_clauses): Remove extraneous comma.\n\n\t* symbol.c (check_conflict): Add conflict between cray_pointee and\n\tthreadprivate.\n\t* openmp.c (gfc_match_omp_threadprivate): Fail if\n\tgfc_add_threadprivate returned FAILURE.\n\t(resolve_omp_clauses): Diagnose Cray pointees in SHARED,\n\t{,FIRST,LAST}PRIVATE and REDUCTION clauses and Cray pointers in\n\t{FIRST,LAST}PRIVATE and REDUCTION clauses.\n\n\t* resolve.c (omp_workshare_flag): New variable.\n\t(resolve_function): Diagnose use of non-ELEMENTAL user defined\n\tfunction in WORKSHARE construct.\n\t(resolve_code): Cleanup forall_save use.  Make sure omp_workshare_flag\n\tis set to correct value in different contexts.\n\n\t* openmp.c (resolve_omp_clauses): Replace %s with '%s' when printing\n\tvariable name.\n\t(resolve_omp_atomic): Likewise.\n\n\tPR fortran/24493\n\t* scanner.c (skip_free_comments): Set at_bol at the beginning of the\n\tloop, not before it.\n\t(skip_fixed_comments): Handle ! comments in the middle of line here\n\tas well.\n\t(gfc_skip_comments): Use skip_fixed_comments for FIXED_FORM even if\n\tnot at BOL.\n\t(gfc_next_char_literal): Fix expected canonicalized *$omp string.\n\n\t* trans-openmp.c (gfc_trans_omp_do): Use make_node and explicit\n\tinitialization to build OMP_FOR instead of build.\n\n\t* trans-decl.c (gfc_gimplify_function): Invoke\n\tdiagnose_omp_structured_block_errors.\n\n\t* trans-openmp.c (gfc_trans_omp_master): Use OMP_MASTER.\n\t(gfc_trans_omp_ordered): Use OMP_ORDERED.\n\n\t* gfortran.h (gfc_resolve_do_iterator, gfc_resolve_blocks,\n\tgfc_resolve_omp_parallel_blocks): New prototypes.\n\t* resolve.c (resolve_blocks): Renamed to...\n\t(gfc_resolve_blocks): ... this.  Remove static.\n\t(gfc_resolve_forall): Adjust caller.\n\t(resolve_code): Only call gfc_resolve_blocks if code->block != 0\n\tand not for EXEC_OMP_PARALLEL* directives.  Call\n\tgfc_resolve_omp_parallel_blocks for EXEC_OMP_PARALLEL* directives.\n\tCall gfc_resolve_do_iterator if resolved successfully EXEC_DO\n\titerator.\n\t* openmp.c: Include pointer-set.h.\n\t(omp_current_ctx): New variable.\n\t(gfc_resolve_omp_parallel_blocks, gfc_resolve_do_iterator): New\n\tfunctions.\n\t* Make-lang.in (fortran/openmp.o): Depend on pointer-set.h.\n\n\t* openmp.c (gfc_match_omp_clauses): For max/min/iand/ior/ieor,\n\tlook up symbol if it exists, use its name instead and, if it is not\n\tINTRINSIC, issue diagnostics.\n\n\t* parse.c (parse_omp_do): Handle implied end do properly.\n\t(parse_executable): If parse_omp_do returned ST_IMPLIED_ENDDO,\n\treturn it instead of continuing.\n\n\t* trans-openmp.c (gfc_trans_omp_critical): Update for changed\n\toperand numbering.\n\t(gfc_trans_omp_do, gfc_trans_omp_parallel, gfc_trans_omp_parallel_do,\n\tgfc_trans_omp_parallel_sections, gfc_trans_omp_parallel_workshare,\n\tgfc_trans_omp_sections, gfc_trans_omp_single): Likewise.\n\n\t* trans.h (gfc_omp_privatize_by_reference): New prototype.\n\t* f95-lang.c (LANG_HOOKS_OMP_PRIVATIZE_BY_REFERENCE): Redefine\n\tto gfc_omp_privatize_by_reference.\n\t* trans-openmp.c (gfc_omp_privatize_by_reference): New function.\n\n\t* trans-stmt.h (gfc_trans_omp_directive): Add comment.\n\n\t* openmp.c (gfc_match_omp_variable_list): Add ALLOW_COMMON argument.\n\tDisallow COMMON matching if it is set.\n\t(gfc_match_omp_clauses, gfc_match_omp_flush): Adjust all callers.\n\t(resolve_omp_clauses): Show locus in error messages.  Check that\n\tvariable types in reduction clauses are appropriate for reduction\n\toperators.\n\n\t* resolve.c (resolve_symbol): Don't error if a threadprivate module\n\tvariable isn't SAVEd.\n\n\t* trans-openmp.c (gfc_trans_omp_do): Put count into BLOCK, not BODY.\n\tFix typo in condition.  Fix DOVAR initialization.\n\n\t* openmp.c (gfc_match_omp_clauses): Match min/iand/ior/ieor\n\trather than .min. etc.\n\n\t* trans-openmpc.c (omp_not_yet): Remove.\n\t(gfc_trans_omp_parallel_do): Keep listprivate clause on parallel.\n\tForce creation of BIND_EXPR around the workshare construct.\n\t(gfc_trans_omp_parallel_sections): Likewise.\n\t(gfc_trans_omp_parallel_workshare): Likewise.\n\n\t* types.def (BT_I16, BT_FN_I16_VPTR_I16,\n\tBT_FN_BOOL_VPTR_I16_I16, BT_FN_I16_VPTR_I16_I16): Add.\n\n\t* trans-openmp.c (gfc_trans_omp_clauses): Create OMP_CLAUSE_DEFAULT.\n\t(gfc_trans_omp_code): New function.\n\t(gfc_trans_omp_do): Use it, remove omp_not_yet uses.\n\t(gfc_trans_omp_parallel, gfc_trans_omp_single): Likewise.\n\t(gfc_trans_omp_sections): Likewise.  Only treat empty last section\n\tspecially if lastprivate clause is present.\n\t* f95-lang.c (gfc_init_builtin_functions): Create BUILT_IN_TRAP\n\tbuiltin.\n\n\t* trans-openmp.c (gfc_trans_omp_variable_list): Update for\n\tOMP_CLAUSE_DECL name change.\n\t(gfc_trans_omp_do): Likewise.\n\n\t* trans-openmp.c (gfc_trans_omp_clauses): Create OMP_CLAUSE_REDUCTION\n\tclauses.\n\t(gfc_trans_omp_atomic): Build OMP_ATOMIC instead of expanding\n\tsync builtins directly.\n\t(gfc_trans_omp_single): Build OMP_SINGLE statement.\n\n\t* trans-openmp.c (gfc_trans_add_clause): New.\n\t(gfc_trans_omp_variable_list): Take a tree code and build the clause\n\tnode here.  Link it to the head of a list.\n\t(gfc_trans_omp_clauses): Update to match.\n\t(gfc_trans_omp_do): Use gfc_trans_add_clause.\n\n\t* trans-openmp.c (gfc_trans_omp_clauses): Change second argument to\n\tgfc_omp_clauses *.  Use gfc_evaluate_now instead of creating\n\ttemporaries by hand.\n\t(gfc_trans_omp_atomic, gfc_trans_omp_critical): Use buildN_v macros.\n\t(gfc_trans_omp_do): New function.\n\t(gfc_trans_omp_master): Dont' check for gfc_trans_code returning NULL.\n\t(gfc_trans_omp_parallel): Adjust gfc_trans_omp_clauses caller.\n\tUse buildN_v macros.\n\t(gfc_trans_omp_parallel_do, gfc_trans_omp_parallel_sections,\n\tgfc_trans_omp_parallel_workshare, gfc_trans_omp_sections,\n\tgfc_trans_omp_single, gfc_trans_omp_workshare): New functions.\n\t(gfc_trans_omp_directive): Use them.\n\t* parse.c (parse_omp_do): Allow new_st.op == EXEC_NOP.\n\t* openmp.c (resolve_omp_clauses): Check for list items present\n\tin multiple clauses.\n\t(resolve_omp_do): Check that iteration variable is not THREADPRIVATE\n\tand is not present in any clause variable lists other than PRIVATE\n\tor LASTPRIVATE.\n\n\t* gfortran.h (symbol_attribute): Add threadprivate bit.\n\t(gfc_common_head): Add threadprivate member, change use_assoc\n\tand saved into char to save space.\n\t(gfc_add_threadprivate): New prototype.\n\t* symbol.c (check_conflict): Handle threadprivate.\n\t(gfc_add_threadprivate): New function.\n\t(gfc_copy_attr): Copy threadprivate.\n\t* trans-openmp.c (gfc_trans_omp_clauses): Avoid creating a temporary\n\tif IF or NUM_THREADS is constant.  Create OMP_CLAUSE_SCHEDULE and\n\tOMP_CLAUSE_ORDERED.\n\t* resolve.c (resolve_symbol): Complain if a THREADPRIVATE symbol\n\toutside a module and not in COMMON has is not SAVEd.\n\t(resolve_equivalence): Ensure THREADPRIVATE objects don't get\n\tEQUIVALENCEd.\n\t* trans-common.c: Include target.h and rtl.h.\n\t(build_common_decl): Set DECL_TLS_MODEL if THREADPRIVATE.\n\t* trans-decl.c: Include rtl.h.\n\t(gfc_finish_var_decl): Set DECL_TLS_MODEL if THREADPRIVATE.\n\t* dump-parse-tree.c (gfc_show_attr): Handle THREADPRIVATE.\n\t* Make-lang.in (fortran/trans-decl.o): Depend on $(RTL_H).\n\t(fortran/trans-common.o): Depend on $(RTL_H) and $(TARGET_H).\n\t* openmp.c (gfc_match_omp_variable_list): Ensure COMMON block\n\tis from current namespace.\n\t(gfc_match_omp_threadprivate): Rewrite.\n\t(resolve_omp_clauses): Check some clause restrictions.\n\t* module.c (ab_attribute): Add AB_THREADPRIVATE.\n\t(attr_bits): Add THREADPRIVATE.\n\t(mio_symbol_attribute, mio_symbol_attribute): Handle threadprivate.\n\t(load_commons, write_common, write_blank_common): Adjust for type\n\tchange of saved, store/load threadprivate bit from the integer\n\tas well.\n\n\t* types.def (BT_FN_UINT_UINT): New.\n\t(BT_FN_VOID_UINT_UINT): Remove.\n\n\t* trans-openmp.c (gfc_trans_omp_clauses, gfc_trans_omp_barrier,\n\tgfc_trans_omp_critical, gfc_trans_omp_flush, gfc_trans_omp_master,\n\tgfc_trans_omp_ordered, gfc_trans_omp_parallel): New functions.\n\t(gfc_trans_omp_directive): Use them.\n\n\t* openmp.c (expr_references_sym): Add SE argument, don't look\n\tinto SE tree.\n\t(is_conversion): New function.\n\t(resolve_omp_atomic): Adjust expr_references_sym callers.  Handle\n\tpromoted expressions.\n\t* trans-openmp.c (gfc_trans_omp_atomic): New function.\n\t(gfc_trans_omp_directive): Call it.\n\n\t* f95-lang.c (builtin_type_for_size): New function.\n\t(gfc_init_builtin_functions): Initialize synchronization and\n\tOpenMP builtins.\n\t* types.def: New file.\n\t* Make-lang.in (f95-lang.o): Depend on $(BUILTINS_DEF) and\n\tfortran/types.def.\n\n\t* trans-openmp.c: Rename GOMP_* tree codes into OMP_*.\n\n\t* dump-parse-tree.c (show_symtree): Don't crash if ns->proc_name\n\tis NULL.\n\n\t* dump-parse-tree.c (gfc_show_namelist, gfc_show_omp_node): New\n\tfunctions.\n\t(gfc_show_code_node): Call gfc_show_omp_node for EXEC_OMP_* nodes.\n\n\t* parse.c (parse_omp_do): Call pop_state before next_statement.\n\t* openmp.c (expr_references_sym, resolve_omp_atomic, resolve_omp_do):\n\tNew functions.\n\t(gfc_resolve_omp_directive): Call them.\n\t* match.c (match_exit_cycle): Issue error if EXIT or CYCLE statement\n\tleaves an OpenMP structured block or if EXIT terminates !$omp do\n\tloop.\n\n\t* Make-lang.in (F95_PARSER_OBJS): Add fortran/openmp.o.\n\t(F95_OBJS): Add fortran/trans-openmp.o.\n\t(fortran/trans-openmp.o): Depend on $(GFORTRAN_TRANS_DEPS).\n\t* lang.opt: Add -fopenmp option.\n\t* options.c (gfc_init_options): Initialize it.\n\t(gfc_handle_option): Handle it.\n\t* gfortran.h (ST_OMP_ATOMIC, ST_OMP_BARRIER, ST_OMP_CRITICAL,\n\tST_OMP_END_CRITICAL, ST_OMP_END_DO, ST_OMP_END_MASTER,\n\tST_OMP_END_ORDERED, ST_OMP_END_PARALLEL, ST_OMP_END_PARALLEL_DO,\n\tST_OMP_END_PARALLEL_SECTIONS, ST_OMP_END_PARALLEL_WORKSHARE,\n\tST_OMP_END_SECTIONS, ST_OMP_END_SINGLE, ST_OMP_END_WORKSHARE,\n\tST_OMP_DO, ST_OMP_FLUSH, ST_OMP_MASTER, ST_OMP_ORDERED,\n\tST_OMP_PARALLEL, ST_OMP_PARALLEL_DO, ST_OMP_PARALLEL_SECTIONS,\n\tST_OMP_PARALLEL_WORKSHARE, ST_OMP_SECTIONS, ST_OMP_SECTION,\n\tST_OMP_SINGLE, ST_OMP_THREADPRIVATE, ST_OMP_WORKSHARE): New\n\tstatement codes.\n\t(OMP_LIST_PRIVATE, OMP_LIST_FIRSTPRIVATE, OMP_LIST_LASTPRIVATE,\n\tOMP_LIST_COPYPRIVATE, OMP_LIST_SHARED, OMP_LIST_COPYIN,\n\tOMP_LIST_PLUS, OMP_LIST_REDUCTION_FIRST, OMP_LIST_MULT,\n\tOMP_LIST_SUB, OMP_LIST_AND, OMP_LIST_OR, OMP_LIST_EQV,\n\tOMP_LIST_NEQV, OMP_LIST_MAX, OMP_LIST_MIN, OMP_LIST_IAND,\n\tOMP_LIST_IOR, OMP_LIST_IEOR, OMP_LIST_REDUCTION_LAST, OMP_LIST_NUM):\n\tNew OpenMP variable list types.\n\t(gfc_omp_clauses): New typedef.\n\t(gfc_get_omp_clauses): Define.\n\t(EXEC_OMP_CRITICAL, EXEC_OMP_DO, EXEC_OMP_FLUSH, EXEC_OMP_MASTER,\n\tEXEC_OMP_ORDERED, EXEC_OMP_PARALLEL, EXEC_OMP_PARALLEL_DO,\n\tEXEC_OMP_PARALLEL_SECTIONS, EXEC_OMP_PARALLEL_WORKSHARE,\n\tEXEC_OMP_SECTIONS, EXEC_OMP_SINGLE, EXEC_OMP_WORKSHARE,\n\tEXEC_OMP_ATOMIC, EXEC_OMP_BARRIER, EXEC_OMP_END_NOWAIT,\n\tEXEC_OMP_END_SINGLE): New OpenMP gfc_exec_op codes.\n\t(struct gfc_code): Add omp_clauses, omp_name, omp_namelist\n\tand omp_bool fields to ext union.\n\t(flag_openmp): Declare.\n\t(gfc_free_omp_clauses, gfc_resolve_omp_directive): New prototypes.\n\t* scanner.c (openmp_flag, openmp_locus): New variables.\n\t(skip_free_comments, skip_fixed_comments, gfc_next_char_literal):\n\tHandle OpenMP directive lines and conditional compilation magic\n\tcomments.\n\t* parse.h (COMP_OMP_STRUCTURED_BLOCK): New compile state.\n\t* parse.c (decode_omp_directive, parse_omp_do, parse_omp_atomic,\n\tparse_omp_structured_block): New functions.\n\t(next_free, next_fixed): Parse OpenMP directives.\n\t(case_executable, case_exec_markers, case_decl): Add ST_OMP_*\n\tcodes.\n\t(gfc_ascii_statement): Handle ST_OMP_* codes.\n\t(parse_executable): Rearrange the loop slightly, so that\n\tparse_omp_do can return next_statement.\n\t* match.h (gfc_match_omp_eos, gfc_match_omp_atomic,\n\tgfc_match_omp_barrier, gfc_match_omp_critical, gfc_match_omp_do,\n\tgfc_match_omp_flush, gfc_match_omp_master, gfc_match_omp_ordered,\n\tgfc_match_omp_parallel, gfc_match_omp_parallel_do,\n\tgfc_match_omp_parallel_sections, gfc_match_omp_parallel_workshare,\n\tgfc_match_omp_sections, gfc_match_omp_single,\n\tgfc_match_omp_threadprivate, gfc_match_omp_workshare,\n\tgfc_match_omp_end_nowait, gfc_match_omp_end_single): New prototypes.\n\t* resolve.c (resolve_blocks): Ignore EXEC_OMP_* block directives.\n\t(resolve_code): Call gfc_resolve_omp_directive on EXEC_OMP_*\n\tdirectives.\n\t* trans.c (gfc_trans_code): Call gfc_trans_omp_directive for\n\tEXEC_OMP_* directives.\n\t* st.c (gfc_free_statement): Handle EXEC_OMP_* statement freeing.\n\t* trans-stmt.h (gfc_trans_omp_directive): New prototype.\n\t* openmp.c: New file.\n\t* trans-openmp.c: New file.\n\ngcc/testsuite/\n2006-02-14  Jakub Jelinek  <jakub@redhat.com>\n\t    Diego Novillo  <dnovillo@redhat.com>\n\t    Uros Bizjak  <uros@kss-loka.si>\n\n\t* gfortran.dg/gomp: New directory.\n\nlibgomp/\n2006-02-14  Jakub Jelinek  <jakub@redhat.com>\n\n\t* testsuite/libgomp.fortran/vla7.f90: Add -w to options.\n\tRemove tests for returning assumed character length arrays.\n\nCo-Authored-By: Diego Novillo <dnovillo@redhat.com>\nCo-Authored-By: Richard Henderson <rth@redhat.com>\nCo-Authored-By: Uros Bizjak <uros@kss-loka.si>\n\nFrom-SVN: r110984", "tree": {"sha": "869f129d646d69ab3554ebb97c0c1c603b0f77c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/869f129d646d69ab3554ebb97c0c1c603b0f77c0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6c7a4dfdb63246a89869089cbafef03d157c5c56", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c7a4dfdb63246a89869089cbafef03d157c5c56", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c7a4dfdb63246a89869089cbafef03d157c5c56", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c7a4dfdb63246a89869089cbafef03d157c5c56/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1dc5d842d486b07bcdfe7f13b7f7893133b80055", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1dc5d842d486b07bcdfe7f13b7f7893133b80055", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1dc5d842d486b07bcdfe7f13b7f7893133b80055"}], "stats": {"total": 11337, "additions": 11249, "deletions": 88}, "files": [{"sha": "7a36057a8f22bc7a6b5b50cb33853bf4ceece544", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 372, "deletions": 0, "changes": 372, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -1,3 +1,375 @@\n+2006-02-14  Jakub Jelinek  <jakub@redhat.com>\n+\t    Richard Henderson  <rth@redhat.com>\n+\t    Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* invoke.texi: Document -fopenmp.\n+\t* gfortran.texi (Extensions): Document OpenMP.\n+\n+\tBackport from gomp-20050608-branch\n+\t* trans-openmp.c: Call build_omp_clause instead of\n+\tmake_node when creating OMP_CLAUSE_* trees.\n+\t(gfc_trans_omp_reduction_list): Remove argument 'code'.\n+\tAdjust all callers.\n+\n+\t* trans.h (build4_v): Define.\n+\t* trans-openmp.c: Call build4_v to create OMP_PARALLEL nodes.\n+\tCall build3_v to create OMP_SECTIONS nodes.\n+\n+\tPR fortran/25162\n+\t* openmp.c (gfc_match_omp_variable_list): Call gfc_set_sym_referenced\n+\ton all symbols added to the variable list.\n+\n+\t* openmp.c (gfc_match_omp_clauses): Fix check for non-INTRINSIC\n+\tprocedure symbol in REDUCTION.\n+\n+\t* trans-openmp.c (gfc_trans_omp_array_reduction): Use gfc_add\n+\tfor MINUS_EXPR OMP_CLAUSE_REDUCTION_CODE.\n+\n+\t* trans-openmp.c (gfc_trans_omp_do): Add PBLOCK argument.  If PBLOCK\n+\tis non-NULL, evaluate INIT/COND/INCR and chunk size expressions in\n+\tthat statement block.\n+\t(gfc_trans_omp_parallel_do): Pass non-NULL PBLOCK to gfc_trans_omp_do\n+\tfor non-ordered non-static combined loops.\n+\t(gfc_trans_omp_directive): Pass NULL PBLOCK to gfc_trans_omp_do.\n+\n+\t* openmp.c: Include target.h and toplev.h.\n+\t(gfc_match_omp_threadprivate): Emit diagnostic if target does\n+\tnot support TLS.\n+\t* Make-lang.in (fortran/openmp.o): Add dependencies on\n+\ttarget.h and toplev.h.\n+\n+\t* trans-decl.c (gfc_get_fake_result_decl): Set GFC_DECL_RESULT.\n+\t* trans-openmp.c (gfc_omp_privatize_by_reference): Make\n+\tDECL_ARTIFICIAL vars predetermined shared except GFC_DECL_RESULT.\n+\t(gfc_omp_disregard_value_expr): Handle GFC_DECL_RESULT.\n+\t(gfc_trans_omp_variable): New function.\n+\t(gfc_trans_omp_variable_list, gfc_trans_omp_reduction_list): Use it.\n+\t* trans.h (GFC_DECL_RESULT): Define.\n+\n+\t* trans-openmp.c (gfc_omp_firstprivatize_type_sizes): New function.\n+\t* f95-lang.c (LANG_HOOKS_OMP_FIRSTPRIVATIZE_TYPE_SIZES): Define.\n+\t* trans.h (gfc_omp_firstprivatize_type_sizes): New prototype.\n+\n+\t* trans-openmp.c (gfc_omp_privatize_by_reference): Return\n+\ttrue if a pointer has GFC_DECL_SAVED_DESCRIPTOR set.\n+\t(gfc_trans_omp_array_reduction, gfc_trans_omp_reduction_list): New\n+\tfunctions.\n+\t(gfc_trans_omp_clauses): Add WHERE argument.  Call\n+\tgfc_trans_omp_reduction_list rather than gfc_trans_omp_variable_list\n+\tfor reductions.\n+\t(gfc_trans_omp_do, gfc_trans_omp_parallel, gfc_trans_omp_parallel_do,\n+\tgfc_trans_omp_parallel_sections, gfc_trans_omp_parallel_workshare,\n+\tgfc_trans_omp_sections, gfc_trans_omp_single): Adjust\n+\tgfc_trans_omp_clauses callers.\n+\n+\t* openmp.c (omp_current_do_code): New var.\n+\t(gfc_resolve_omp_do_blocks): New function.\n+\t(gfc_resolve_omp_parallel_blocks): Call it.\n+\t(gfc_resolve_do_iterator): Add CODE argument.  Don't propagate\n+\tpredetermination if argument is !$omp do or !$omp parallel do\n+\titeration variable.\n+\t* resolve.c (resolve_code): Call gfc_resolve_omp_do_blocks\n+\tfor EXEC_OMP_DO.  Adjust gfc_resolve_do_iterator caller.\n+\t* fortran.h (gfc_resolve_omp_do_blocks): New prototype.\n+\t(gfc_resolve_do_iterator): Add CODE argument.\n+\n+\t* trans.h (gfc_omp_predetermined_sharing,\n+\tgfc_omp_disregard_value_expr, gfc_omp_private_debug_clause): New\n+\tprototypes.\n+\t(GFC_DECL_COMMON_OR_EQUIV, GFC_DECL_CRAY_POINTEE): Define.\n+\t* trans-openmp.c (gfc_omp_predetermined_sharing,\n+\tgfc_omp_disregard_value_expr, gfc_omp_private_debug_clause): New\n+\tfunctions.\n+\t* trans-common.c (build_equiv_decl, build_common_decl,\n+\tcreate_common): Set GFC_DECL_COMMON_OR_EQUIV flag on the decls.\n+\t* trans-decl.c (gfc_finish_cray_pointee): Set GFC_DECL_CRAY_POINTEE\n+\ton the decl.\n+\t* f95-lang.c (LANG_HOOKS_OMP_PREDETERMINED_SHARING,\n+\tLANG_HOOKS_OMP_DISREGARD_VALUE_EXPR,\n+\tLANG_HOOKS_OMP_PRIVATE_DEBUG_CLAUSE): Define.\n+\n+\t* openmp.c (resolve_omp_clauses): Remove extraneous comma.\n+\n+\t* symbol.c (check_conflict): Add conflict between cray_pointee and\n+\tthreadprivate.\n+\t* openmp.c (gfc_match_omp_threadprivate): Fail if\n+\tgfc_add_threadprivate returned FAILURE.\n+\t(resolve_omp_clauses): Diagnose Cray pointees in SHARED,\n+\t{,FIRST,LAST}PRIVATE and REDUCTION clauses and Cray pointers in\n+\t{FIRST,LAST}PRIVATE and REDUCTION clauses.\n+\n+\t* resolve.c (omp_workshare_flag): New variable.\n+\t(resolve_function): Diagnose use of non-ELEMENTAL user defined\n+\tfunction in WORKSHARE construct.\n+\t(resolve_code): Cleanup forall_save use.  Make sure omp_workshare_flag\n+\tis set to correct value in different contexts.\n+\n+\t* openmp.c (resolve_omp_clauses): Replace %s with '%s' when printing\n+\tvariable name.\n+\t(resolve_omp_atomic): Likewise.\n+\n+\tPR fortran/24493\n+\t* scanner.c (skip_free_comments): Set at_bol at the beginning of the\n+\tloop, not before it.\n+\t(skip_fixed_comments): Handle ! comments in the middle of line here\n+\tas well.\n+\t(gfc_skip_comments): Use skip_fixed_comments for FIXED_FORM even if\n+\tnot at BOL.\n+\t(gfc_next_char_literal): Fix expected canonicalized *$omp string.\n+\n+\t* trans-openmp.c (gfc_trans_omp_do): Use make_node and explicit\n+\tinitialization to build OMP_FOR instead of build.\n+\n+\t* trans-decl.c (gfc_gimplify_function): Invoke\n+\tdiagnose_omp_structured_block_errors.\n+\n+\t* trans-openmp.c (gfc_trans_omp_master): Use OMP_MASTER.\n+\t(gfc_trans_omp_ordered): Use OMP_ORDERED.\n+\n+\t* gfortran.h (gfc_resolve_do_iterator, gfc_resolve_blocks,\n+\tgfc_resolve_omp_parallel_blocks): New prototypes.\n+\t* resolve.c (resolve_blocks): Renamed to...\n+\t(gfc_resolve_blocks): ... this.  Remove static.\n+\t(gfc_resolve_forall): Adjust caller.\n+\t(resolve_code): Only call gfc_resolve_blocks if code->block != 0\n+\tand not for EXEC_OMP_PARALLEL* directives.  Call\n+\tgfc_resolve_omp_parallel_blocks for EXEC_OMP_PARALLEL* directives.\n+\tCall gfc_resolve_do_iterator if resolved successfully EXEC_DO\n+\titerator.\n+\t* openmp.c: Include pointer-set.h.\n+\t(omp_current_ctx): New variable.\n+\t(gfc_resolve_omp_parallel_blocks, gfc_resolve_do_iterator): New\n+\tfunctions.\n+\t* Make-lang.in (fortran/openmp.o): Depend on pointer-set.h.\n+\n+\t* openmp.c (gfc_match_omp_clauses): For max/min/iand/ior/ieor,\n+\tlook up symbol if it exists, use its name instead and, if it is not\n+\tINTRINSIC, issue diagnostics.\n+\n+\t* parse.c (parse_omp_do): Handle implied end do properly.\n+\t(parse_executable): If parse_omp_do returned ST_IMPLIED_ENDDO,\n+\treturn it instead of continuing.\n+\n+\t* trans-openmp.c (gfc_trans_omp_critical): Update for changed\n+\toperand numbering.\n+\t(gfc_trans_omp_do, gfc_trans_omp_parallel, gfc_trans_omp_parallel_do,\n+\tgfc_trans_omp_parallel_sections, gfc_trans_omp_parallel_workshare,\n+\tgfc_trans_omp_sections, gfc_trans_omp_single): Likewise.\n+\n+\t* trans.h (gfc_omp_privatize_by_reference): New prototype.\n+\t* f95-lang.c (LANG_HOOKS_OMP_PRIVATIZE_BY_REFERENCE): Redefine\n+\tto gfc_omp_privatize_by_reference.\n+\t* trans-openmp.c (gfc_omp_privatize_by_reference): New function.\n+\n+\t* trans-stmt.h (gfc_trans_omp_directive): Add comment.\n+\n+\t* openmp.c (gfc_match_omp_variable_list): Add ALLOW_COMMON argument.\n+\tDisallow COMMON matching if it is set.\n+\t(gfc_match_omp_clauses, gfc_match_omp_flush): Adjust all callers.\n+\t(resolve_omp_clauses): Show locus in error messages.  Check that\n+\tvariable types in reduction clauses are appropriate for reduction\n+\toperators.\n+\n+\t* resolve.c (resolve_symbol): Don't error if a threadprivate module\n+\tvariable isn't SAVEd.\n+\n+\t* trans-openmp.c (gfc_trans_omp_do): Put count into BLOCK, not BODY.\n+\tFix typo in condition.  Fix DOVAR initialization.\n+\n+\t* openmp.c (gfc_match_omp_clauses): Match min/iand/ior/ieor\n+\trather than .min. etc.\n+\n+\t* trans-openmpc.c (omp_not_yet): Remove.\n+\t(gfc_trans_omp_parallel_do): Keep listprivate clause on parallel.\n+\tForce creation of BIND_EXPR around the workshare construct.\n+\t(gfc_trans_omp_parallel_sections): Likewise.\n+\t(gfc_trans_omp_parallel_workshare): Likewise.\n+\n+\t* types.def (BT_I16, BT_FN_I16_VPTR_I16,\n+\tBT_FN_BOOL_VPTR_I16_I16, BT_FN_I16_VPTR_I16_I16): Add.\n+\n+\t* trans-openmp.c (gfc_trans_omp_clauses): Create OMP_CLAUSE_DEFAULT.\n+\t(gfc_trans_omp_code): New function.\n+\t(gfc_trans_omp_do): Use it, remove omp_not_yet uses.\n+\t(gfc_trans_omp_parallel, gfc_trans_omp_single): Likewise.\n+\t(gfc_trans_omp_sections): Likewise.  Only treat empty last section\n+\tspecially if lastprivate clause is present.\n+\t* f95-lang.c (gfc_init_builtin_functions): Create BUILT_IN_TRAP\n+\tbuiltin.\n+\n+\t* trans-openmp.c (gfc_trans_omp_variable_list): Update for\n+\tOMP_CLAUSE_DECL name change.\n+\t(gfc_trans_omp_do): Likewise.\n+\n+\t* trans-openmp.c (gfc_trans_omp_clauses): Create OMP_CLAUSE_REDUCTION\n+\tclauses.\n+\t(gfc_trans_omp_atomic): Build OMP_ATOMIC instead of expanding\n+\tsync builtins directly.\n+\t(gfc_trans_omp_single): Build OMP_SINGLE statement.\n+\n+\t* trans-openmp.c (gfc_trans_add_clause): New.\n+\t(gfc_trans_omp_variable_list): Take a tree code and build the clause\n+\tnode here.  Link it to the head of a list.\n+\t(gfc_trans_omp_clauses): Update to match.\n+\t(gfc_trans_omp_do): Use gfc_trans_add_clause.\n+\n+\t* trans-openmp.c (gfc_trans_omp_clauses): Change second argument to\n+\tgfc_omp_clauses *.  Use gfc_evaluate_now instead of creating\n+\ttemporaries by hand.\n+\t(gfc_trans_omp_atomic, gfc_trans_omp_critical): Use buildN_v macros.\n+\t(gfc_trans_omp_do): New function.\n+\t(gfc_trans_omp_master): Dont' check for gfc_trans_code returning NULL.\n+\t(gfc_trans_omp_parallel): Adjust gfc_trans_omp_clauses caller.\n+\tUse buildN_v macros.\n+\t(gfc_trans_omp_parallel_do, gfc_trans_omp_parallel_sections,\n+\tgfc_trans_omp_parallel_workshare, gfc_trans_omp_sections,\n+\tgfc_trans_omp_single, gfc_trans_omp_workshare): New functions.\n+\t(gfc_trans_omp_directive): Use them.\n+\t* parse.c (parse_omp_do): Allow new_st.op == EXEC_NOP.\n+\t* openmp.c (resolve_omp_clauses): Check for list items present\n+\tin multiple clauses.\n+\t(resolve_omp_do): Check that iteration variable is not THREADPRIVATE\n+\tand is not present in any clause variable lists other than PRIVATE\n+\tor LASTPRIVATE.\n+\n+\t* gfortran.h (symbol_attribute): Add threadprivate bit.\n+\t(gfc_common_head): Add threadprivate member, change use_assoc\n+\tand saved into char to save space.\n+\t(gfc_add_threadprivate): New prototype.\n+\t* symbol.c (check_conflict): Handle threadprivate.\n+\t(gfc_add_threadprivate): New function.\n+\t(gfc_copy_attr): Copy threadprivate.\n+\t* trans-openmp.c (gfc_trans_omp_clauses): Avoid creating a temporary\n+\tif IF or NUM_THREADS is constant.  Create OMP_CLAUSE_SCHEDULE and\n+\tOMP_CLAUSE_ORDERED.\n+\t* resolve.c (resolve_symbol): Complain if a THREADPRIVATE symbol\n+\toutside a module and not in COMMON has is not SAVEd.\n+\t(resolve_equivalence): Ensure THREADPRIVATE objects don't get\n+\tEQUIVALENCEd.\n+\t* trans-common.c: Include target.h and rtl.h.\n+\t(build_common_decl): Set DECL_TLS_MODEL if THREADPRIVATE.\n+\t* trans-decl.c: Include rtl.h.\n+\t(gfc_finish_var_decl): Set DECL_TLS_MODEL if THREADPRIVATE.\n+\t* dump-parse-tree.c (gfc_show_attr): Handle THREADPRIVATE.\n+\t* Make-lang.in (fortran/trans-decl.o): Depend on $(RTL_H).\n+\t(fortran/trans-common.o): Depend on $(RTL_H) and $(TARGET_H).\n+\t* openmp.c (gfc_match_omp_variable_list): Ensure COMMON block\n+\tis from current namespace.\n+\t(gfc_match_omp_threadprivate): Rewrite.\n+\t(resolve_omp_clauses): Check some clause restrictions.\n+\t* module.c (ab_attribute): Add AB_THREADPRIVATE.\n+\t(attr_bits): Add THREADPRIVATE.\n+\t(mio_symbol_attribute, mio_symbol_attribute): Handle threadprivate.\n+\t(load_commons, write_common, write_blank_common): Adjust for type\n+\tchange of saved, store/load threadprivate bit from the integer\n+\tas well.\n+\n+\t* types.def (BT_FN_UINT_UINT): New.\n+\t(BT_FN_VOID_UINT_UINT): Remove.\n+\n+\t* trans-openmp.c (gfc_trans_omp_clauses, gfc_trans_omp_barrier,\n+\tgfc_trans_omp_critical, gfc_trans_omp_flush, gfc_trans_omp_master,\n+\tgfc_trans_omp_ordered, gfc_trans_omp_parallel): New functions.\n+\t(gfc_trans_omp_directive): Use them.\n+\n+\t* openmp.c (expr_references_sym): Add SE argument, don't look\n+\tinto SE tree.\n+\t(is_conversion): New function.\n+\t(resolve_omp_atomic): Adjust expr_references_sym callers.  Handle\n+\tpromoted expressions.\n+\t* trans-openmp.c (gfc_trans_omp_atomic): New function.\n+\t(gfc_trans_omp_directive): Call it.\n+\n+\t* f95-lang.c (builtin_type_for_size): New function.\n+\t(gfc_init_builtin_functions): Initialize synchronization and\n+\tOpenMP builtins.\n+\t* types.def: New file.\n+\t* Make-lang.in (f95-lang.o): Depend on $(BUILTINS_DEF) and\n+\tfortran/types.def.\n+\n+\t* trans-openmp.c: Rename GOMP_* tree codes into OMP_*.\n+\n+\t* dump-parse-tree.c (show_symtree): Don't crash if ns->proc_name\n+\tis NULL.\n+\n+\t* dump-parse-tree.c (gfc_show_namelist, gfc_show_omp_node): New\n+\tfunctions.\n+\t(gfc_show_code_node): Call gfc_show_omp_node for EXEC_OMP_* nodes.\n+\n+\t* parse.c (parse_omp_do): Call pop_state before next_statement.\n+\t* openmp.c (expr_references_sym, resolve_omp_atomic, resolve_omp_do):\n+\tNew functions.\n+\t(gfc_resolve_omp_directive): Call them.\n+\t* match.c (match_exit_cycle): Issue error if EXIT or CYCLE statement\n+\tleaves an OpenMP structured block or if EXIT terminates !$omp do\n+\tloop.\n+\n+\t* Make-lang.in (F95_PARSER_OBJS): Add fortran/openmp.o.\n+\t(F95_OBJS): Add fortran/trans-openmp.o.\n+\t(fortran/trans-openmp.o): Depend on $(GFORTRAN_TRANS_DEPS).\n+\t* lang.opt: Add -fopenmp option.\n+\t* options.c (gfc_init_options): Initialize it.\n+\t(gfc_handle_option): Handle it.\n+\t* gfortran.h (ST_OMP_ATOMIC, ST_OMP_BARRIER, ST_OMP_CRITICAL,\n+\tST_OMP_END_CRITICAL, ST_OMP_END_DO, ST_OMP_END_MASTER,\n+\tST_OMP_END_ORDERED, ST_OMP_END_PARALLEL, ST_OMP_END_PARALLEL_DO,\n+\tST_OMP_END_PARALLEL_SECTIONS, ST_OMP_END_PARALLEL_WORKSHARE,\n+\tST_OMP_END_SECTIONS, ST_OMP_END_SINGLE, ST_OMP_END_WORKSHARE,\n+\tST_OMP_DO, ST_OMP_FLUSH, ST_OMP_MASTER, ST_OMP_ORDERED,\n+\tST_OMP_PARALLEL, ST_OMP_PARALLEL_DO, ST_OMP_PARALLEL_SECTIONS,\n+\tST_OMP_PARALLEL_WORKSHARE, ST_OMP_SECTIONS, ST_OMP_SECTION,\n+\tST_OMP_SINGLE, ST_OMP_THREADPRIVATE, ST_OMP_WORKSHARE): New\n+\tstatement codes.\n+\t(OMP_LIST_PRIVATE, OMP_LIST_FIRSTPRIVATE, OMP_LIST_LASTPRIVATE,\n+\tOMP_LIST_COPYPRIVATE, OMP_LIST_SHARED, OMP_LIST_COPYIN,\n+\tOMP_LIST_PLUS, OMP_LIST_REDUCTION_FIRST, OMP_LIST_MULT,\n+\tOMP_LIST_SUB, OMP_LIST_AND, OMP_LIST_OR, OMP_LIST_EQV,\n+\tOMP_LIST_NEQV, OMP_LIST_MAX, OMP_LIST_MIN, OMP_LIST_IAND,\n+\tOMP_LIST_IOR, OMP_LIST_IEOR, OMP_LIST_REDUCTION_LAST, OMP_LIST_NUM):\n+\tNew OpenMP variable list types.\n+\t(gfc_omp_clauses): New typedef.\n+\t(gfc_get_omp_clauses): Define.\n+\t(EXEC_OMP_CRITICAL, EXEC_OMP_DO, EXEC_OMP_FLUSH, EXEC_OMP_MASTER,\n+\tEXEC_OMP_ORDERED, EXEC_OMP_PARALLEL, EXEC_OMP_PARALLEL_DO,\n+\tEXEC_OMP_PARALLEL_SECTIONS, EXEC_OMP_PARALLEL_WORKSHARE,\n+\tEXEC_OMP_SECTIONS, EXEC_OMP_SINGLE, EXEC_OMP_WORKSHARE,\n+\tEXEC_OMP_ATOMIC, EXEC_OMP_BARRIER, EXEC_OMP_END_NOWAIT,\n+\tEXEC_OMP_END_SINGLE): New OpenMP gfc_exec_op codes.\n+\t(struct gfc_code): Add omp_clauses, omp_name, omp_namelist\n+\tand omp_bool fields to ext union.\n+\t(flag_openmp): Declare.\n+\t(gfc_free_omp_clauses, gfc_resolve_omp_directive): New prototypes.\n+\t* scanner.c (openmp_flag, openmp_locus): New variables.\n+\t(skip_free_comments, skip_fixed_comments, gfc_next_char_literal):\n+\tHandle OpenMP directive lines and conditional compilation magic\n+\tcomments.\n+\t* parse.h (COMP_OMP_STRUCTURED_BLOCK): New compile state.\n+\t* parse.c (decode_omp_directive, parse_omp_do, parse_omp_atomic,\n+\tparse_omp_structured_block): New functions.\n+\t(next_free, next_fixed): Parse OpenMP directives.\n+\t(case_executable, case_exec_markers, case_decl): Add ST_OMP_*\n+\tcodes.\n+\t(gfc_ascii_statement): Handle ST_OMP_* codes.\n+\t(parse_executable): Rearrange the loop slightly, so that\n+\tparse_omp_do can return next_statement.\n+\t* match.h (gfc_match_omp_eos, gfc_match_omp_atomic,\n+\tgfc_match_omp_barrier, gfc_match_omp_critical, gfc_match_omp_do,\n+\tgfc_match_omp_flush, gfc_match_omp_master, gfc_match_omp_ordered,\n+\tgfc_match_omp_parallel, gfc_match_omp_parallel_do,\n+\tgfc_match_omp_parallel_sections, gfc_match_omp_parallel_workshare,\n+\tgfc_match_omp_sections, gfc_match_omp_single,\n+\tgfc_match_omp_threadprivate, gfc_match_omp_workshare,\n+\tgfc_match_omp_end_nowait, gfc_match_omp_end_single): New prototypes.\n+\t* resolve.c (resolve_blocks): Ignore EXEC_OMP_* block directives.\n+\t(resolve_code): Call gfc_resolve_omp_directive on EXEC_OMP_*\n+\tdirectives.\n+\t* trans.c (gfc_trans_code): Call gfc_trans_omp_directive for\n+\tEXEC_OMP_* directives.\n+\t* st.c (gfc_free_statement): Handle EXEC_OMP_* statement freeing.\n+\t* trans-stmt.h (gfc_trans_omp_directive): New prototype.\n+\t* openmp.c: New file.\n+\t* trans-openmp.c: New file.\n+\n 2006-02-13  Andrew Pinski  <pinskia@physics.uc.edu>\n \t    Jakub Jelinek  <jakub@redhat.com>\n "}, {"sha": "74af449756ca40924c283a96ba73ee54b760cf76", "filename": "gcc/fortran/Make-lang.in", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ffortran%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ffortran%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FMake-lang.in?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -1,6 +1,6 @@\n # -*- makefile -*-\n # Top level makefile fragment for GNU gfortran, the GNU Fortran 95 compiler.\n-# Copyright (C) 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n+# Copyright (C) 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.\n # Contributed by Paul Brook <paul@nowt.org\n # and Steven Bosscher <s.bosscher@student.tudelft.nl>\n \n@@ -65,15 +65,16 @@ F95_PARSER_OBJS = fortran/arith.o fortran/array.o fortran/bbt.o \\\n     fortran/error.o fortran/expr.o fortran/interface.o \\\n     fortran/intrinsic.o fortran/io.o fortran/iresolve.o \\\n     fortran/match.o fortran/matchexp.o fortran/misc.o fortran/module.o \\\n-    fortran/options.o fortran/parse.o fortran/primary.o fortran/resolve.o \\\n-    fortran/scanner.o fortran/simplify.o fortran/st.o fortran/symbol.o\n+    fortran/openmp.o fortran/options.o fortran/parse.o fortran/primary.o \\\n+    fortran/resolve.o fortran/scanner.o fortran/simplify.o fortran/st.o \\\n+    fortran/symbol.o\n \n F95_OBJS = $(F95_PARSER_OBJS) \\\n     fortran/convert.o fortran/dependency.o fortran/f95-lang.o \\\n     fortran/trans.o fortran/trans-array.o fortran/trans-common.o \\\n     fortran/trans-const.o fortran/trans-decl.o fortran/trans-expr.o \\\n-    fortran/trans-intrinsic.o fortran/trans-io.o fortran/trans-stmt.o \\\n-    fortran/trans-types.o\n+    fortran/trans-intrinsic.o fortran/trans-io.o fortran/trans-openmp.o \\\n+    fortran/trans-stmt.o fortran/trans-types.o\n \n # GFORTRAN uses GMP for its internal arithmetics.\n F95_LIBS = $(GMPLIBS) $(LIBS)\n@@ -261,31 +262,34 @@ $(F95_PARSER_OBJS): fortran/gfortran.h fortran/intrinsic.h fortran/match.h \\\n \t\t$(CONFIG_H) $(SYSTEM_H) $(TM_H) $(TM_P_H) coretypes.h \\\n \t\t$(RTL_H) $(TREE_H) $(TREE_DUMP_H) $(GGC_H) $(EXPR_H) \\\n \t\tflags.h output.h diagnostic.h errors.h function.h \n+fortran/openmp.o: pointer-set.h $(TARGET_H) toplev.h\n \n GFORTRAN_TRANS_DEPS = fortran/gfortran.h fortran/intrinsic.h fortran/trans-array.h \\\n     fortran/trans-const.h fortran/trans-const.h fortran/trans.h \\\n     fortran/trans-stmt.h fortran/trans-types.h \\\n     $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(TM_H) coretypes.h $(GGC_H)\n \n fortran/f95-lang.o: $(GFORTRAN_TRANS_DEPS) fortran/mathbuiltins.def \\\n-  gt-fortran-f95-lang.h gtype-fortran.h cgraph.h $(TARGET_H)\n+  gt-fortran-f95-lang.h gtype-fortran.h cgraph.h $(TARGET_H) \\\n+  $(BUILTINS_DEF) fortran/types.def\n fortran/scanner.o: toplev.h\n fortran/convert.o: $(GFORTRAN_TRANS_DEPS)\n fortran/trans.o: $(GFORTRAN_TRANS_DEPS)\n fortran/trans-decl.o: $(GFORTRAN_TRANS_DEPS) gt-fortran-trans-decl.h \\\n-  cgraph.h $(TARGET_H) function.h $(FLAGS_H) tree-gimple.h \\\n+  cgraph.h $(TARGET_H) function.h $(FLAGS_H) $(RTL_H) tree-gimple.h \\\n   tree-dump.h\n fortran/trans-types.o: $(GFORTRAN_TRANS_DEPS) gt-fortran-trans-types.h \\\n   real.h toplev.h $(TARGET_H)\n fortran/trans-const.o: $(GFORTRAN_TRANS_DEPS)\n fortran/trans-expr.o: $(GFORTRAN_TRANS_DEPS) fortran/dependency.h\n fortran/trans-stmt.o: $(GFORTRAN_TRANS_DEPS) fortran/dependency.h\n+fortran/trans-openmp.o: $(GFORTRAN_TRANS_DEPS)\n fortran/trans-io.o: $(GFORTRAN_TRANS_DEPS) gt-fortran-trans-io.h \\\n   fortran/ioparm.def\n fortran/trans-array.o: $(GFORTRAN_TRANS_DEPS)\n fortran/trans-intrinsic.o: $(GFORTRAN_TRANS_DEPS) fortran/mathbuiltins.def \\\n   gt-fortran-trans-intrinsic.h\n fortran/dependency.o: $(GFORTRAN_TRANS_DEPS) fortran/dependency.h\n-fortran/trans-common.o: $(GFORTRAN_TRANS_DEPS)\n+fortran/trans-common.o: $(GFORTRAN_TRANS_DEPS) $(TARGET_H) $(RTL_H)\n fortran/resolve.o: fortran/dependency.h\n "}, {"sha": "06322d427719695ee2b8f2cc2b7aba475a16f87a", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 215, "deletions": 0, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -547,6 +547,8 @@ gfc_show_attr (symbol_attribute * attr)\n     gfc_status (\" POINTER\");\n   if (attr->save)\n     gfc_status (\" SAVE\");\n+  if (attr->threadprivate)\n+    gfc_status (\" THREADPRIVATE\");\n   if (attr->target)\n     gfc_status (\" TARGET\");\n   if (attr->dummy)\n@@ -786,6 +788,202 @@ gfc_show_code (int level, gfc_code * c)\n     gfc_show_code_node (level, c);\n }\n \n+static void\n+gfc_show_namelist (gfc_namelist *n)\n+{\n+  for (; n->next; n = n->next)\n+    gfc_status (\"%s,\", n->sym->name);\n+  gfc_status (\"%s\", n->sym->name);\n+}\n+\n+/* Show a single OpenMP directive node and everything underneath it\n+   if necessary.  */\n+\n+static void\n+gfc_show_omp_node (int level, gfc_code * c)\n+{\n+  gfc_omp_clauses *omp_clauses = NULL;\n+  const char *name = NULL;\n+\n+  switch (c->op)\n+    {\n+    case EXEC_OMP_ATOMIC: name = \"ATOMIC\"; break;\n+    case EXEC_OMP_BARRIER: name = \"BARRIER\"; break;\n+    case EXEC_OMP_CRITICAL: name = \"CRITICAL\"; break;\n+    case EXEC_OMP_FLUSH: name = \"FLUSH\"; break;\n+    case EXEC_OMP_DO: name = \"DO\"; break;\n+    case EXEC_OMP_MASTER: name = \"MASTER\"; break;\n+    case EXEC_OMP_ORDERED: name = \"ORDERED\"; break;\n+    case EXEC_OMP_PARALLEL: name = \"PARALLEL\"; break;\n+    case EXEC_OMP_PARALLEL_DO: name = \"PARALLEL DO\"; break;\n+    case EXEC_OMP_PARALLEL_SECTIONS: name = \"PARALLEL SECTIONS\"; break;\n+    case EXEC_OMP_PARALLEL_WORKSHARE: name = \"PARALLEL WORKSHARE\"; break;\n+    case EXEC_OMP_SECTIONS: name = \"SECTIONS\"; break;\n+    case EXEC_OMP_SINGLE: name = \"SINGLE\"; break;\n+    case EXEC_OMP_WORKSHARE: name = \"WORKSHARE\"; break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+  gfc_status (\"!$OMP %s\", name);\n+  switch (c->op)\n+    {\n+    case EXEC_OMP_DO:\n+    case EXEC_OMP_PARALLEL:\n+    case EXEC_OMP_PARALLEL_DO:\n+    case EXEC_OMP_PARALLEL_SECTIONS:\n+    case EXEC_OMP_SECTIONS:\n+    case EXEC_OMP_SINGLE:\n+    case EXEC_OMP_WORKSHARE:\n+    case EXEC_OMP_PARALLEL_WORKSHARE:\n+      omp_clauses = c->ext.omp_clauses;\n+      break;\n+    case EXEC_OMP_CRITICAL:\n+      if (c->ext.omp_name)\n+\tgfc_status (\" (%s)\", c->ext.omp_name);\n+      break;\n+    case EXEC_OMP_FLUSH:\n+      if (c->ext.omp_namelist)\n+\t{\n+\t  gfc_status (\" (\");\n+\t  gfc_show_namelist (c->ext.omp_namelist);\n+\t  gfc_status_char (')');\n+\t}\n+      return;\n+    case EXEC_OMP_BARRIER:\n+      return;\n+    default:\n+      break;\n+    }\n+  if (omp_clauses)\n+    {\n+      int list_type;\n+\n+      if (omp_clauses->if_expr)\n+\t{\n+\t  gfc_status (\" IF(\");\n+\t  gfc_show_expr (omp_clauses->if_expr);\n+\t  gfc_status_char (')');\n+\t}\n+      if (omp_clauses->num_threads)\n+\t{\n+\t  gfc_status (\" NUM_THREADS(\");\n+\t  gfc_show_expr (omp_clauses->num_threads);\n+\t  gfc_status_char (')');\n+\t}\n+      if (omp_clauses->sched_kind != OMP_SCHED_NONE)\n+\t{\n+\t  const char *type;\n+\t  switch (omp_clauses->sched_kind)\n+\t    {\n+\t    case OMP_SCHED_STATIC: type = \"STATIC\"; break;\n+\t    case OMP_SCHED_DYNAMIC: type = \"DYNAMIC\"; break;\n+\t    case OMP_SCHED_GUIDED: type = \"GUIDED\"; break;\n+\t    case OMP_SCHED_RUNTIME: type = \"RUNTIME\"; break;\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n+\t  gfc_status (\" SCHEDULE (%s\", type);\n+\t  if (omp_clauses->chunk_size)\n+\t    {\n+\t      gfc_status_char (',');\n+\t      gfc_show_expr (omp_clauses->chunk_size);\n+\t    }\n+\t  gfc_status_char (')');\n+\t}\n+      if (omp_clauses->default_sharing != OMP_DEFAULT_UNKNOWN)\n+\t{\n+\t  const char *type;\n+\t  switch (omp_clauses->default_sharing)\n+\t    {\n+\t    case OMP_DEFAULT_NONE: type = \"NONE\"; break;\n+\t    case OMP_DEFAULT_PRIVATE: type = \"PRIVATE\"; break;\n+\t    case OMP_DEFAULT_SHARED: type = \"SHARED\"; break;\n+\t    case OMP_SCHED_RUNTIME: type = \"RUNTIME\"; break;\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n+\t  gfc_status (\" DEFAULT(%s)\", type);\n+\t}\n+      if (omp_clauses->ordered)\n+\tgfc_status (\" ORDERED\");\n+      for (list_type = 0; list_type < OMP_LIST_NUM; list_type++)\n+\tif (omp_clauses->lists[list_type] != NULL\n+\t    && list_type != OMP_LIST_COPYPRIVATE)\n+\t  {\n+\t    const char *type;\n+\t    if (list_type >= OMP_LIST_REDUCTION_FIRST)\n+\t      {\n+\t\tswitch (list_type)\n+\t\t  {\n+\t\t  case OMP_LIST_PLUS: type = \"+\"; break;\n+\t\t  case OMP_LIST_MULT: type = \"*\"; break;\n+\t\t  case OMP_LIST_SUB: type = \"-\"; break;\n+\t\t  case OMP_LIST_AND: type = \".AND.\"; break;\n+\t\t  case OMP_LIST_OR: type = \".OR.\"; break;\n+\t\t  case OMP_LIST_EQV: type = \".EQV.\"; break;\n+\t\t  case OMP_LIST_NEQV: type = \".NEQV.\"; break;\n+\t\t  case OMP_LIST_MAX: type = \"MAX\"; break;\n+\t\t  case OMP_LIST_MIN: type = \"MIN\"; break;\n+\t\t  case OMP_LIST_IAND: type = \"IAND\"; break;\n+\t\t  case OMP_LIST_IOR: type = \"IOR\"; break;\n+\t\t  case OMP_LIST_IEOR: type = \"IEOR\"; break;\n+\t\t  default:\n+\t\t    gcc_unreachable ();\n+\t\t  }\n+\t\tgfc_status (\" REDUCTION(%s:\", type);\n+\t      }\n+\t    else\n+\t      {\n+\t\tswitch (list_type)\n+\t\t  {\n+\t\t  case OMP_LIST_PRIVATE: type = \"PRIVATE\"; break;\n+\t\t  case OMP_LIST_FIRSTPRIVATE: type = \"FIRSTPRIVATE\"; break;\n+\t\t  case OMP_LIST_LASTPRIVATE: type = \"LASTPRIVATE\"; break;\n+\t\t  case OMP_LIST_SHARED: type = \"SHARED\"; break;\n+\t\t  case OMP_LIST_COPYIN: type = \"COPYIN\"; break;\n+\t\t  default:\n+\t\t    gcc_unreachable ();\n+\t\t  }\n+\t\tgfc_status (\" %s(\", type);\n+\t      }\n+\t    gfc_show_namelist (omp_clauses->lists[list_type]);\n+\t    gfc_status_char (')');\n+\t  }\n+    }\n+  gfc_status_char ('\\n');\n+  if (c->op == EXEC_OMP_SECTIONS || c->op == EXEC_OMP_PARALLEL_SECTIONS)\n+    {\n+      gfc_code *d = c->block;\n+      while (d != NULL)\n+\t{\n+\t  gfc_show_code (level + 1, d->next);\n+\t  if (d->block == NULL)\n+\t    break;\n+\t  code_indent (level, 0);\n+\t  gfc_status (\"!$OMP SECTION\\n\");\n+\t  d = d->block;\n+\t}\n+    }\n+  else\n+    gfc_show_code (level + 1, c->block->next);\n+  if (c->op == EXEC_OMP_ATOMIC)\n+    return;\n+  code_indent (level, 0);\n+  gfc_status (\"!$OMP END %s\", name);\n+  if (omp_clauses != NULL)\n+    {\n+      if (omp_clauses->lists[OMP_LIST_COPYPRIVATE])\n+\t{\n+\t  gfc_status (\" COPYPRIVATE(\");\n+\t  gfc_show_namelist (omp_clauses->lists[OMP_LIST_COPYPRIVATE]);\n+\t  gfc_status_char (')');\n+\t}\n+      else if (omp_clauses->nowait)\n+\tgfc_status (\" NOWAIT\");\n+    }\n+  else if (c->op == EXEC_OMP_CRITICAL && c->ext.omp_name)\n+    gfc_status (\" (%s)\", c->ext.omp_name);\n+}\n \n /* Show a single code node and everything underneath it if necessary.  */\n \n@@ -1448,6 +1646,23 @@ gfc_show_code_node (int level, gfc_code * c)\n \tgfc_status (\" EOR=%d\", dt->eor->value);\n       break;\n \n+    case EXEC_OMP_ATOMIC:\n+    case EXEC_OMP_BARRIER:\n+    case EXEC_OMP_CRITICAL:\n+    case EXEC_OMP_FLUSH:\n+    case EXEC_OMP_DO:\n+    case EXEC_OMP_MASTER:\n+    case EXEC_OMP_ORDERED:\n+    case EXEC_OMP_PARALLEL:\n+    case EXEC_OMP_PARALLEL_DO:\n+    case EXEC_OMP_PARALLEL_SECTIONS:\n+    case EXEC_OMP_PARALLEL_WORKSHARE:\n+    case EXEC_OMP_SECTIONS:\n+    case EXEC_OMP_SINGLE:\n+    case EXEC_OMP_WORKSHARE:\n+      gfc_show_omp_node (level, c);\n+      break;\n+\n     default:\n       gfc_internal_error (\"gfc_show_code_node(): Bad statement code\");\n     }"}, {"sha": "6722117dd1bada13e05f9ed89c2014b61a53b4e2", "filename": "gcc/fortran/f95-lang.c", "status": "modified", "additions": 199, "deletions": 2, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ffortran%2Ff95-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ffortran%2Ff95-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ff95-lang.c?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -1,6 +1,6 @@\n /* gfortran backend interface\n-   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation,\n-   Inc.\n+   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006\n+   Free Software Foundation, Inc.\n    Contributed by Paul Brook.\n \n This file is part of GCC.\n@@ -116,6 +116,11 @@ static void gfc_expand_function (tree);\n #undef LANG_HOOKS_SIGNED_OR_UNSIGNED_TYPE\n #undef LANG_HOOKS_CALLGRAPH_EXPAND_FUNCTION\n #undef LANG_HOOKS_CLEAR_BINDING_STACK\n+#undef LANG_HOOKS_OMP_PRIVATIZE_BY_REFERENCE\n+#undef LANG_HOOKS_OMP_PREDETERMINED_SHARING\n+#undef LANG_HOOKS_OMP_DISREGARD_VALUE_EXPR\n+#undef LANG_HOOKS_OMP_PRIVATE_DEBUG_CLAUSE\n+#undef LANG_HOOKS_OMP_FIRSTPRIVATIZE_TYPE_SIZES\n \n /* Define lang hooks.  */\n #define LANG_HOOKS_NAME                 \"GNU F95\"\n@@ -134,6 +139,12 @@ static void gfc_expand_function (tree);\n #define LANG_HOOKS_SIGNED_OR_UNSIGNED_TYPE gfc_signed_or_unsigned_type\n #define LANG_HOOKS_CALLGRAPH_EXPAND_FUNCTION gfc_expand_function\n #define LANG_HOOKS_CLEAR_BINDING_STACK     gfc_clear_binding_stack\n+#define LANG_HOOKS_OMP_PRIVATIZE_BY_REFERENCE\tgfc_omp_privatize_by_reference\n+#define LANG_HOOKS_OMP_PREDETERMINED_SHARING\tgfc_omp_predetermined_sharing\n+#define LANG_HOOKS_OMP_DISREGARD_VALUE_EXPR\tgfc_omp_disregard_value_expr\n+#define LANG_HOOKS_OMP_PRIVATE_DEBUG_CLAUSE\tgfc_omp_private_debug_clause\n+#define LANG_HOOKS_OMP_FIRSTPRIVATIZE_TYPE_SIZES \\\n+  gfc_omp_firstprivatize_type_sizes\n \n const struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;\n \n@@ -784,12 +795,53 @@ build_builtin_fntypes (tree * fntype, tree type)\n   fntype[2] = build_function_type (type, tmp);\n }\n \n+static tree\n+builtin_type_for_size (int size, bool unsignedp)\n+{\n+  tree type = lang_hooks.types.type_for_size (size, unsignedp);\n+  return type ? type : error_mark_node;\n+}\n \n /* Initialization of builtin function nodes.  */\n \n static void\n gfc_init_builtin_functions (void)\n {\n+  enum builtin_type\n+  {\n+#define DEF_PRIMITIVE_TYPE(NAME, VALUE) NAME,\n+#define DEF_FUNCTION_TYPE_0(NAME, RETURN) NAME,\n+#define DEF_FUNCTION_TYPE_1(NAME, RETURN, ARG1) NAME,\n+#define DEF_FUNCTION_TYPE_2(NAME, RETURN, ARG1, ARG2) NAME,\n+#define DEF_FUNCTION_TYPE_3(NAME, RETURN, ARG1, ARG2, ARG3) NAME,\n+#define DEF_FUNCTION_TYPE_4(NAME, RETURN, ARG1, ARG2, ARG3, ARG4) NAME,\n+#define DEF_FUNCTION_TYPE_5(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5) NAME,\n+#define DEF_FUNCTION_TYPE_6(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6) NAME,\n+#define DEF_FUNCTION_TYPE_7(NAME, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7) NAME,\n+#define DEF_FUNCTION_TYPE_VAR_0(NAME, RETURN) NAME,\n+#define DEF_POINTER_TYPE(NAME, TYPE) NAME,\n+#include \"types.def\"\n+#undef DEF_PRIMITIVE_TYPE\n+#undef DEF_FUNCTION_TYPE_0\n+#undef DEF_FUNCTION_TYPE_1\n+#undef DEF_FUNCTION_TYPE_2\n+#undef DEF_FUNCTION_TYPE_3\n+#undef DEF_FUNCTION_TYPE_4\n+#undef DEF_FUNCTION_TYPE_5\n+#undef DEF_FUNCTION_TYPE_6\n+#undef DEF_FUNCTION_TYPE_7\n+#undef DEF_FUNCTION_TYPE_VAR_0\n+#undef DEF_POINTER_TYPE\n+    BT_LAST\n+  };\n+  typedef enum builtin_type builtin_type;\n+  enum\n+  {\n+    /* So far we need just these 2 attribute types.  */\n+    ATTR_NOTHROW_LIST,\n+    ATTR_CONST_NOTHROW_LIST\n+  };\n+\n   tree mfunc_float[3];\n   tree mfunc_double[3];\n   tree mfunc_longdouble[3];\n@@ -801,6 +853,7 @@ gfc_init_builtin_functions (void)\n   tree func_clongdouble_longdouble;\n   tree ftype;\n   tree tmp;\n+  tree builtin_types[(int) BT_LAST + 1];\n \n   build_builtin_fntypes (mfunc_float, float_type_node);\n   build_builtin_fntypes (mfunc_double, double_type_node);\n@@ -882,6 +935,150 @@ gfc_init_builtin_functions (void)\n   gfc_define_builtin (\"__builtin_expect\", ftype, BUILT_IN_EXPECT,\n \t\t      \"__builtin_expect\", true);\n \n+#define DEF_PRIMITIVE_TYPE(ENUM, VALUE) \\\n+  builtin_types[(int) ENUM] = VALUE;\n+#define DEF_FUNCTION_TYPE_0(ENUM, RETURN)\t\t\\\n+  builtin_types[(int) ENUM]\t\t\t\t\\\n+    = build_function_type (builtin_types[(int) RETURN],\t\\\n+\t\t\t   void_list_node);\n+#define DEF_FUNCTION_TYPE_1(ENUM, RETURN, ARG1)\t\t\t\t\\\n+  builtin_types[(int) ENUM]\t\t\t\t\t\t\\\n+    = build_function_type (builtin_types[(int) RETURN],\t\t\t\\\n+\t\t\t   tree_cons (NULL_TREE,\t\t\t\\\n+\t\t\t\t      builtin_types[(int) ARG1],\t\\\n+\t\t\t\t      void_list_node));\n+#define DEF_FUNCTION_TYPE_2(ENUM, RETURN, ARG1, ARG2)\t\\\n+  builtin_types[(int) ENUM]\t\t\t\t\\\n+    = build_function_type\t\t\t\t\\\n+      (builtin_types[(int) RETURN],\t\t\t\\\n+       tree_cons (NULL_TREE,\t\t\t\t\\\n+\t\t  builtin_types[(int) ARG1],\t\t\\\n+\t\t  tree_cons (NULL_TREE,\t\t\t\\\n+\t\t\t     builtin_types[(int) ARG2],\t\\\n+\t\t\t     void_list_node)));\n+#define DEF_FUNCTION_TYPE_3(ENUM, RETURN, ARG1, ARG2, ARG3)\t\t \\\n+  builtin_types[(int) ENUM]\t\t\t\t\t\t \\\n+    = build_function_type\t\t\t\t\t\t \\\n+      (builtin_types[(int) RETURN],\t\t\t\t\t \\\n+       tree_cons (NULL_TREE,\t\t\t\t\t\t \\\n+\t\t  builtin_types[(int) ARG1],\t\t\t\t \\\n+\t\t  tree_cons (NULL_TREE,\t\t\t\t\t \\\n+\t\t\t     builtin_types[(int) ARG2],\t\t\t \\\n+\t\t\t     tree_cons (NULL_TREE,\t\t\t \\\n+\t\t\t\t\tbuiltin_types[(int) ARG3],\t \\\n+\t\t\t\t\tvoid_list_node))));\n+#define DEF_FUNCTION_TYPE_4(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4)\t\\\n+  builtin_types[(int) ENUM]\t\t\t\t\t\t\\\n+    = build_function_type\t\t\t\t\t\t\\\n+      (builtin_types[(int) RETURN],\t\t\t\t\t\\\n+       tree_cons (NULL_TREE,\t\t\t\t\t\t\\\n+\t\t  builtin_types[(int) ARG1],\t\t\t\t\\\n+\t\t  tree_cons (NULL_TREE,\t\t\t\t\t\\\n+\t\t\t     builtin_types[(int) ARG2],\t\t\t\\\n+\t\t\t     tree_cons\t\t\t\t\t\\\n+\t\t\t     (NULL_TREE,\t\t\t\t\\\n+\t\t\t      builtin_types[(int) ARG3],\t\t\\\n+\t\t\t      tree_cons (NULL_TREE,\t\t\t\\\n+\t\t\t\t\t builtin_types[(int) ARG4],\t\\\n+\t\t\t\t\t void_list_node)))));\n+#define DEF_FUNCTION_TYPE_5(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5)\t\\\n+  builtin_types[(int) ENUM]\t\t\t\t\t\t\\\n+    = build_function_type\t\t\t\t\t\t\\\n+      (builtin_types[(int) RETURN],\t\t\t\t\t\\\n+       tree_cons (NULL_TREE,\t\t\t\t\t\t\\\n+\t\t  builtin_types[(int) ARG1],\t\t\t\t\\\n+\t\t  tree_cons (NULL_TREE,\t\t\t\t\t\\\n+\t\t\t     builtin_types[(int) ARG2],\t\t\t\\\n+\t\t\t     tree_cons\t\t\t\t\t\\\n+\t\t\t     (NULL_TREE,\t\t\t\t\\\n+\t\t\t      builtin_types[(int) ARG3],\t\t\\\n+\t\t\t      tree_cons (NULL_TREE,\t\t\t\\\n+\t\t\t\t\t builtin_types[(int) ARG4],\t\\\n+\t\t\t\t\t tree_cons (NULL_TREE,\t\t\\\n+\t\t\t\t\t      builtin_types[(int) ARG5],\\\n+\t\t\t\t\t      void_list_node))))));\n+#define DEF_FUNCTION_TYPE_6(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t    ARG6)\t\t\t\t\t\\\n+  builtin_types[(int) ENUM]\t\t\t\t\t\t\\\n+    = build_function_type\t\t\t\t\t\t\\\n+      (builtin_types[(int) RETURN],\t\t\t\t\t\\\n+       tree_cons (NULL_TREE,\t\t\t\t\t\t\\\n+\t\t  builtin_types[(int) ARG1],\t\t\t\t\\\n+\t\t  tree_cons (NULL_TREE,\t\t\t\t\t\\\n+\t\t\t     builtin_types[(int) ARG2],\t\t\t\\\n+\t\t\t     tree_cons\t\t\t\t\t\\\n+\t\t\t     (NULL_TREE,\t\t\t\t\\\n+\t\t\t      builtin_types[(int) ARG3],\t\t\\\n+\t\t\t      tree_cons\t\t\t\t\t\\\n+\t\t\t      (NULL_TREE,\t\t\t\t\\\n+\t\t\t       builtin_types[(int) ARG4],\t\t\\\n+\t\t\t       tree_cons (NULL_TREE,\t\t\t\\\n+\t\t\t\t\t builtin_types[(int) ARG5],\t\\\n+\t\t\t\t\t tree_cons (NULL_TREE,\t\t\\\n+\t\t\t\t\t      builtin_types[(int) ARG6],\\\n+\t\t\t\t\t      void_list_node)))))));\n+#define DEF_FUNCTION_TYPE_7(ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, \\\n+\t\t\t    ARG6, ARG7)\t\t\t\t\t\\\n+  builtin_types[(int) ENUM]\t\t\t\t\t\t\\\n+    = build_function_type\t\t\t\t\t\t\\\n+      (builtin_types[(int) RETURN],\t\t\t\t\t\\\n+       tree_cons (NULL_TREE,\t\t\t\t\t\t\\\n+\t\t  builtin_types[(int) ARG1],\t\t\t\t\\\n+\t\t  tree_cons (NULL_TREE,\t\t\t\t\t\\\n+\t\t\t     builtin_types[(int) ARG2],\t\t\t\\\n+\t\t\t     tree_cons\t\t\t\t\t\\\n+\t\t\t     (NULL_TREE,\t\t\t\t\\\n+\t\t\t      builtin_types[(int) ARG3],\t\t\\\n+\t\t\t      tree_cons\t\t\t\t\t\\\n+\t\t\t      (NULL_TREE,\t\t\t\t\\\n+\t\t\t       builtin_types[(int) ARG4],\t\t\\\n+\t\t\t       tree_cons (NULL_TREE,\t\t\t\\\n+\t\t\t\t\t builtin_types[(int) ARG5],\t\\\n+\t\t\t\t\t tree_cons (NULL_TREE,\t\t\\\n+\t\t\t\t\t      builtin_types[(int) ARG6],\\\n+\t\t\t\t\t tree_cons (NULL_TREE,\t\t\\\n+\t\t\t\t\t      builtin_types[(int) ARG6], \\\n+\t\t\t\t\t      void_list_node))))))));\n+#define DEF_FUNCTION_TYPE_VAR_0(ENUM, RETURN)\t\t\t\t\\\n+  builtin_types[(int) ENUM]\t\t\t\t\t\t\\\n+    = build_function_type (builtin_types[(int) RETURN], NULL_TREE);\n+#define DEF_POINTER_TYPE(ENUM, TYPE)\t\t\t\\\n+  builtin_types[(int) ENUM]\t\t\t\t\\\n+    = build_pointer_type (builtin_types[(int) TYPE]);\n+#include \"types.def\"\n+#undef DEF_PRIMITIVE_TYPE\n+#undef DEF_FUNCTION_TYPE_1\n+#undef DEF_FUNCTION_TYPE_2\n+#undef DEF_FUNCTION_TYPE_3\n+#undef DEF_FUNCTION_TYPE_4\n+#undef DEF_FUNCTION_TYPE_5\n+#undef DEF_FUNCTION_TYPE_6\n+#undef DEF_FUNCTION_TYPE_VAR_0\n+#undef DEF_POINTER_TYPE\n+  builtin_types[(int) BT_LAST] = NULL_TREE;\n+\n+  /* Initialize synchronization builtins.  */\n+#undef DEF_SYNC_BUILTIN\n+#define DEF_SYNC_BUILTIN(code, name, type, attr) \\\n+    gfc_define_builtin (name, builtin_types[type], code, name, \\\n+\t\t\tattr == ATTR_CONST_NOTHROW_LIST);\n+#include \"../sync-builtins.def\"\n+#undef DEF_SYNC_BUILTIN\n+\n+  if (gfc_option.flag_openmp)\n+    {\n+#undef DEF_GOMP_BUILTIN\n+#define DEF_GOMP_BUILTIN(code, name, type, attr) \\\n+      gfc_define_builtin (\"__builtin_\" name, builtin_types[type], \\\n+\t\t\t  code, name, attr == ATTR_CONST_NOTHROW_LIST);\n+#include \"../omp-builtins.def\"\n+#undef DEF_GOMP_BUILTIN\n+    }\n+\n+  gfc_define_builtin (\"__builtin_trap\", builtin_types[BT_FN_VOID],\n+\t\t      BUILT_IN_TRAP, NULL, false);\n+  TREE_THIS_VOLATILE (built_in_decls[BUILT_IN_TRAP]) = 1;\n+\n   build_common_builtin_nodes ();\n   targetm.init_builtins ();\n }"}, {"sha": "16f0a127051000478c8d010f3adba9b6939c9d5d", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 87, "deletions": 4, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -220,7 +220,16 @@ typedef enum\n   ST_STOP, ST_SUBROUTINE, ST_TYPE, ST_USE, ST_WHERE_BLOCK, ST_WHERE, ST_WRITE,\n   ST_ASSIGNMENT, ST_POINTER_ASSIGNMENT, ST_SELECT_CASE, ST_SEQUENCE,\n   ST_SIMPLE_IF, ST_STATEMENT_FUNCTION, ST_DERIVED_DECL, ST_LABEL_ASSIGNMENT,\n-  ST_ENUM, ST_ENUMERATOR, ST_END_ENUM, ST_NONE\n+  ST_ENUM, ST_ENUMERATOR, ST_END_ENUM,\n+  ST_OMP_ATOMIC, ST_OMP_BARRIER, ST_OMP_CRITICAL, ST_OMP_END_CRITICAL,\n+  ST_OMP_END_DO, ST_OMP_END_MASTER, ST_OMP_END_ORDERED, ST_OMP_END_PARALLEL,\n+  ST_OMP_END_PARALLEL_DO, ST_OMP_END_PARALLEL_SECTIONS,\n+  ST_OMP_END_PARALLEL_WORKSHARE, ST_OMP_END_SECTIONS, ST_OMP_END_SINGLE,\n+  ST_OMP_END_WORKSHARE, ST_OMP_DO, ST_OMP_FLUSH, ST_OMP_MASTER, ST_OMP_ORDERED,\n+  ST_OMP_PARALLEL, ST_OMP_PARALLEL_DO, ST_OMP_PARALLEL_SECTIONS,\n+  ST_OMP_PARALLEL_WORKSHARE, ST_OMP_SECTIONS, ST_OMP_SECTION, ST_OMP_SINGLE,\n+  ST_OMP_THREADPRIVATE, ST_OMP_WORKSHARE,\n+  ST_NONE\n }\n gfc_statement;\n \n@@ -451,7 +460,7 @@ typedef struct\n   /* Variable attributes.  */\n   unsigned allocatable:1, dimension:1, external:1, intrinsic:1,\n     optional:1, pointer:1, save:1, target:1,\n-    dummy:1, result:1, assign:1;\n+    dummy:1, result:1, assign:1, threadprivate:1;\n \n   unsigned data:1,\t\t/* Symbol is named in a DATA statement.  */\n     use_assoc:1;\t\t/* Symbol has been use-associated.  */\n@@ -678,6 +687,60 @@ gfc_namelist;\n \n #define gfc_get_namelist() gfc_getmem(sizeof(gfc_namelist))\n \n+enum\n+{\n+  OMP_LIST_PRIVATE,\n+  OMP_LIST_FIRSTPRIVATE,\n+  OMP_LIST_LASTPRIVATE,\n+  OMP_LIST_COPYPRIVATE,\n+  OMP_LIST_SHARED,\n+  OMP_LIST_COPYIN,\n+  OMP_LIST_PLUS,\n+  OMP_LIST_REDUCTION_FIRST = OMP_LIST_PLUS,\n+  OMP_LIST_MULT,\n+  OMP_LIST_SUB,\n+  OMP_LIST_AND,\n+  OMP_LIST_OR,\n+  OMP_LIST_EQV,\n+  OMP_LIST_NEQV,\n+  OMP_LIST_MAX,\n+  OMP_LIST_MIN,\n+  OMP_LIST_IAND,\n+  OMP_LIST_IOR,\n+  OMP_LIST_IEOR,\n+  OMP_LIST_REDUCTION_LAST = OMP_LIST_IEOR,\n+  OMP_LIST_NUM\n+};\n+\n+/* Because a symbol can belong to multiple namelists, they must be\n+   linked externally to the symbol itself.  */\n+typedef struct gfc_omp_clauses\n+{\n+  struct gfc_expr *if_expr;\n+  struct gfc_expr *num_threads;\n+  gfc_namelist *lists[OMP_LIST_NUM];\n+  enum\n+    {\n+      OMP_SCHED_NONE,\n+      OMP_SCHED_STATIC,\n+      OMP_SCHED_DYNAMIC,\n+      OMP_SCHED_GUIDED,\n+      OMP_SCHED_RUNTIME\n+    } sched_kind;\n+  struct gfc_expr *chunk_size;\n+  enum\n+    {\n+      OMP_DEFAULT_UNKNOWN,\n+      OMP_DEFAULT_NONE,\n+      OMP_DEFAULT_PRIVATE,\n+      OMP_DEFAULT_SHARED\n+    } default_sharing;\n+  bool nowait, ordered;\n+}\n+gfc_omp_clauses;\n+\n+#define gfc_get_omp_clauses() gfc_getmem(sizeof(gfc_omp_clauses))\n+\n \n /* The gfc_st_label structure is a doubly linked list attached to a\n    namespace that records the usage of statement labels within that\n@@ -794,7 +857,7 @@ gfc_symbol;\n typedef struct gfc_common_head\n {\n   locus where;\n-  int use_assoc, saved;\n+  char use_assoc, saved, threadprivate;\n   char name[GFC_MAX_SYMBOL_LEN + 1];\n   struct gfc_symbol *head;\n }\n@@ -1402,7 +1465,13 @@ typedef enum\n   EXEC_ALLOCATE, EXEC_DEALLOCATE,\n   EXEC_OPEN, EXEC_CLOSE,\n   EXEC_READ, EXEC_WRITE, EXEC_IOLENGTH, EXEC_TRANSFER, EXEC_DT_END,\n-  EXEC_BACKSPACE, EXEC_ENDFILE, EXEC_INQUIRE, EXEC_REWIND, EXEC_FLUSH\n+  EXEC_BACKSPACE, EXEC_ENDFILE, EXEC_INQUIRE, EXEC_REWIND, EXEC_FLUSH,\n+  EXEC_OMP_CRITICAL, EXEC_OMP_DO, EXEC_OMP_FLUSH, EXEC_OMP_MASTER,\n+  EXEC_OMP_ORDERED, EXEC_OMP_PARALLEL, EXEC_OMP_PARALLEL_DO,\n+  EXEC_OMP_PARALLEL_SECTIONS, EXEC_OMP_PARALLEL_WORKSHARE,\n+  EXEC_OMP_SECTIONS, EXEC_OMP_SINGLE, EXEC_OMP_WORKSHARE,\n+  EXEC_OMP_ATOMIC, EXEC_OMP_BARRIER, EXEC_OMP_END_NOWAIT,\n+  EXEC_OMP_END_SINGLE\n }\n gfc_exec_op;\n \n@@ -1436,6 +1505,10 @@ typedef struct gfc_code\n     struct gfc_code *whichloop;\n     int stop_code;\n     gfc_entry_list *entry;\n+    gfc_omp_clauses *omp_clauses;\n+    const char *omp_name;\n+    gfc_namelist *omp_namelist;\n+    bool omp_bool;\n   }\n   ext;\t\t/* Points to additional structures required by statement */\n \n@@ -1528,6 +1601,7 @@ typedef struct\n   int flag_backslash;\n   int flag_cray_pointer;\n   int flag_d_lines;\n+  int flag_openmp;\n \n   int q_kind;\n \n@@ -1722,6 +1796,7 @@ try gfc_add_cray_pointee (symbol_attribute *, locus *);\n try gfc_mod_pointee_as (gfc_array_spec *as);\n try gfc_add_result (symbol_attribute *, const char *, locus *);\n try gfc_add_save (symbol_attribute *, const char *, locus *);\n+try gfc_add_threadprivate (symbol_attribute *, const char *, locus *);\n try gfc_add_saved_common (symbol_attribute *, locus *);\n try gfc_add_target (symbol_attribute *, locus *);\n try gfc_add_dummy (symbol_attribute *, const char *, locus *);\n@@ -1832,6 +1907,13 @@ void gfc_free_equiv (gfc_equiv *);\n void gfc_free_data (gfc_data *);\n void gfc_free_case_list (gfc_case *);\n \n+/* openmp.c */\n+void gfc_free_omp_clauses (gfc_omp_clauses *);\n+void gfc_resolve_omp_directive (gfc_code *, gfc_namespace *);\n+void gfc_resolve_do_iterator (gfc_code *, gfc_symbol *);\n+void gfc_resolve_omp_parallel_blocks (gfc_code *, gfc_namespace *);\n+void gfc_resolve_omp_do_blocks (gfc_code *, gfc_namespace *);\n+\n /* expr.c */\n void gfc_free_actual_arglist (gfc_actual_arglist *);\n gfc_actual_arglist *gfc_copy_actual_arglist (gfc_actual_arglist *);\n@@ -1880,6 +1962,7 @@ void gfc_free_statements (gfc_code *);\n /* resolve.c */\n try gfc_resolve_expr (gfc_expr *);\n void gfc_resolve (gfc_namespace *);\n+void gfc_resolve_blocks (gfc_code *, gfc_namespace *);\n int gfc_impure_variable (gfc_symbol *);\n int gfc_pure (gfc_symbol *);\n int gfc_elemental (gfc_symbol *);"}, {"sha": "908e05aec76daee0cf4a40a97666160a3fdf3165", "filename": "gcc/fortran/gfortran.texi", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ffortran%2Fgfortran.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ffortran%2Fgfortran.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.texi?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -1,7 +1,7 @@\n \\input texinfo  @c -*-texinfo-*-\n @c %**start of header\n @setfilename gfortran.info\n-@set copyrights-gfortran 1999-2005\n+@set copyrights-gfortran 1999-2006\n \n @include gcc-common.texi\n \n@@ -492,10 +492,6 @@ Allow setting the default unit number.\n Option to initialize otherwise uninitialized integer and floating\n point variables.\n \n-@item\n-Support for OpenMP directives.  This also requires support from the runtime\n-library and the rest of the compiler.\n-\n @item\n Support for Fortran 200x. This includes several new features including\n floating point exceptions, extended use of allocatable arrays, C\n@@ -658,6 +654,7 @@ of extensions, and @option{-std=legacy} allows both without warning.\n * Hollerith constants support::\n * Cray pointers::\n * CONVERT specifier::\n+* OpenMP::\n @end menu\n \n @node Old-style kind specifications\n@@ -1049,6 +1046,22 @@ carries a significant speed overhead.  If speed in this area matters\n to you, it is best if you use this only for data that needs to be\n portable.\n \n+@node OpenMP\n+@section OpenMP\n+@cindex OpenMP\n+\n+gfortran attempts to be OpenMP Application Program Interface v2.5\n+compatible when invoked with the @code{-fopenmp} option.  gfortran\n+then generates parallellized code according to the OpenMP directives\n+used in the source.  The OpenMP Fortran runtime library\n+routines are provided both in a form of Fortran 90 module named\n+@code{omp_lib} and in a form of a Fortran @code{include} file named\n+@code{omp_lib.h}.\n+\n+For details refer to the actual\n+@uref{http://www.openmp.org/drupal/mp-documents/spec25.pdf,\n+OpenMP Application Program Interface v2.5} specification.\n+\n @c ---------------------------------------------------------------------\n @include intrinsic.texi\n @c ---------------------------------------------------------------------"}, {"sha": "c031cd41a2dc082d2f4cbcfd413a54f2e94dfd72", "filename": "gcc/fortran/invoke.texi", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ffortran%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ffortran%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finvoke.texi?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -1,11 +1,11 @@\n-@c Copyright (C) 2004, 2005\n+@c Copyright (C) 2004, 2005, 2006\n @c Free Software Foundation, Inc.\n @c This is part of the GFORTRAN manual.   \n @c For copying conditions, see the file gfortran.texi.\n \n @ignore\n @c man begin COPYRIGHT\n-Copyright @copyright{} 2004, 2005\n+Copyright @copyright{} 2004, 2005, 2006\n Free Software Foundation, Inc.\n \n Permission is granted to copy, distribute and/or modify this document\n@@ -122,7 +122,7 @@ by type.  Explanations are in the following sections.\n -ffixed-line-length-@var{n}  -ffixed-line-length-none @gol\n -ffree-line-length-@var{n}  -ffree-line-length-none @gol\n -fdefault-double-8  -fdefault-integer-8  -fdefault-real-8 @gol\n--fcray-pointer }\n+-fcray-pointer  -fopenmp }\n \n @item Warning Options\n @xref{Warning Options,,Options to Request or Suppress Warnings}.\n@@ -291,6 +291,16 @@ Specify that no implicit typing is allowed, unless overridden by explicit\n @item -fcray-pointer\n Enables the Cray pointer extension, which provides a C-like pointer.\n \n+@cindex -fopenmp\n+@cindex options, -fopenmp\n+@item -fopenmp\n+Enables handling of OpenMP @code{!$omp} directives in free form\n+and @code{c$omp}, @code{*$omp} and @code{!$omp} directives in fixed form,\n+enables @code{!$} conditional compilation sentinels in free form\n+and @code{c$}, @code{*$} and @code{!$} sentinels in fixed form\n+and when linking arranges for the OpenMP runtime library to be linked\n+in.\n+\n @cindex -std=@var{std} option\n @cindex option, -std=@var{std}\n @item -std=@var{std}"}, {"sha": "17522040272e2733de18bc2867efede7af95f1f1", "filename": "gcc/fortran/lang.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ffortran%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ffortran%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Flang.opt?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -117,6 +117,10 @@ ffree-form\n Fortran RejectNegative\n Assume that the source file is free form\n \n+fopenmp\n+Fortran\n+Enable OpenMP\n+\n funderscoring\n Fortran\n Append underscores to externally visible names"}, {"sha": "a2b9c41d5494934415c63899e8799e930d1d121f", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -1341,7 +1341,7 @@ gfc_match_do (void)\n static match\n match_exit_cycle (gfc_statement st, gfc_exec_op op)\n {\n-  gfc_state_data *p;\n+  gfc_state_data *p, *o;\n   gfc_symbol *sym;\n   match m;\n \n@@ -1368,9 +1368,11 @@ match_exit_cycle (gfc_statement st, gfc_exec_op op)\n \n   /* Find the loop mentioned specified by the label (or lack of a\n      label).  */\n-  for (p = gfc_state_stack; p; p = p->previous)\n+  for (o = NULL, p = gfc_state_stack; p; p = p->previous)\n     if (p->state == COMP_DO && (sym == NULL || sym == p->sym))\n       break;\n+    else if (o == NULL && p->state == COMP_OMP_STRUCTURED_BLOCK)\n+      o = p;\n \n   if (p == NULL)\n     {\n@@ -1384,6 +1386,25 @@ match_exit_cycle (gfc_statement st, gfc_exec_op op)\n       return MATCH_ERROR;\n     }\n \n+  if (o != NULL)\n+    {\n+      gfc_error (\"%s statement at %C leaving OpenMP structured block\",\n+\t\t gfc_ascii_statement (st));\n+      return MATCH_ERROR;\n+    }\n+  else if (st == ST_EXIT\n+\t   && p->previous != NULL\n+\t   && p->previous->state == COMP_OMP_STRUCTURED_BLOCK\n+\t   && (p->previous->head->op == EXEC_OMP_DO\n+\t       || p->previous->head->op == EXEC_OMP_PARALLEL_DO))\n+    {\n+      gcc_assert (p->previous->head->next != NULL);\n+      gcc_assert (p->previous->head->next->op == EXEC_DO\n+\t\t  || p->previous->head->next->op == EXEC_DO_WHILE);\n+      gfc_error (\"EXIT statement at %C terminating !$OMP DO loop\");\n+      return MATCH_ERROR;\n+    }\n+\n   /* Save the first statement in the loop - needed by the backend.  */\n   new_st.ext.whichloop = p->head;\n "}, {"sha": "19340cee0f185587378fab1c24f31de009d7d90a", "filename": "gcc/fortran/match.h", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ffortran%2Fmatch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ffortran%2Fmatch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.h?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -90,6 +90,28 @@ match gfc_match_forall (gfc_statement *);\n \n gfc_common_head *gfc_get_common (const char *, int);\n \n+/* openmp.c */\n+\n+/* OpenMP directive matchers */\n+match gfc_match_omp_eos (void);\n+match gfc_match_omp_atomic (void);\n+match gfc_match_omp_barrier (void);\n+match gfc_match_omp_critical (void);\n+match gfc_match_omp_do (void);\n+match gfc_match_omp_flush (void);\n+match gfc_match_omp_master (void);\n+match gfc_match_omp_ordered (void);\n+match gfc_match_omp_parallel (void);\n+match gfc_match_omp_parallel_do (void);\n+match gfc_match_omp_parallel_sections (void);\n+match gfc_match_omp_parallel_workshare (void);\n+match gfc_match_omp_sections (void);\n+match gfc_match_omp_single (void);\n+match gfc_match_omp_threadprivate (void);\n+match gfc_match_omp_workshare (void);\n+match gfc_match_omp_end_nowait (void);\n+match gfc_match_omp_end_single (void);\n+\n /* decl.c */\n \n match gfc_match_data (void);"}, {"sha": "3c45e57cff16deabc35899a5ed2a7787ec56e0b3", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -1432,7 +1432,7 @@ typedef enum\n   AB_DATA, AB_IN_NAMELIST, AB_IN_COMMON, \n   AB_FUNCTION, AB_SUBROUTINE, AB_SEQUENCE, AB_ELEMENTAL, AB_PURE,\n   AB_RECURSIVE, AB_GENERIC, AB_ALWAYS_EXPLICIT, AB_CRAY_POINTER,\n-  AB_CRAY_POINTEE\n+  AB_CRAY_POINTEE, AB_THREADPRIVATE\n }\n ab_attribute;\n \n@@ -1446,6 +1446,7 @@ static const mstring attr_bits[] =\n     minit (\"POINTER\", AB_POINTER),\n     minit (\"SAVE\", AB_SAVE),\n     minit (\"TARGET\", AB_TARGET),\n+    minit (\"THREADPRIVATE\", AB_THREADPRIVATE),\n     minit (\"DUMMY\", AB_DUMMY),\n     minit (\"RESULT\", AB_RESULT),\n     minit (\"DATA\", AB_DATA),\n@@ -1515,6 +1516,8 @@ mio_symbol_attribute (symbol_attribute * attr)\n \tMIO_NAME(ab_attribute) (AB_SAVE, attr_bits);\n       if (attr->target)\n \tMIO_NAME(ab_attribute) (AB_TARGET, attr_bits);\n+      if (attr->threadprivate)\n+\tMIO_NAME(ab_attribute) (AB_THREADPRIVATE, attr_bits);\n       if (attr->dummy)\n \tMIO_NAME(ab_attribute) (AB_DUMMY, attr_bits);\n       if (attr->result)\n@@ -1590,6 +1593,9 @@ mio_symbol_attribute (symbol_attribute * attr)\n \t    case AB_TARGET:\n \t      attr->target = 1;\n \t      break;\n+\t    case AB_THREADPRIVATE:\n+\t      attr->threadprivate = 1;\n+\t      break;\n \t    case AB_DUMMY:\n \t      attr->dummy = 1;\n \t      break;\n@@ -2982,13 +2988,18 @@ load_commons(void)\n \n   while (peek_atom () != ATOM_RPAREN)\n     {\n+      int flags;\n       mio_lparen ();\n       mio_internal_string (name);\n \n       p = gfc_get_common (name, 1);\n \n       mio_symbol_ref (&p->head);\n-      mio_integer (&p->saved);\n+      mio_integer (&flags);\n+      if (flags & 1)\n+\tp->saved = 1;\n+      if (flags & 2)\n+\tp->threadprivate = 1;\n       p->use_assoc = 1;\n \n       mio_rparen();\n@@ -3385,6 +3396,7 @@ write_common (gfc_symtree *st)\n {\n   gfc_common_head *p;\n   const char * name;\n+  int flags;\n \n   if (st == NULL)\n     return;\n@@ -3401,7 +3413,9 @@ write_common (gfc_symtree *st)\n \n   p = st->n.common;\n   mio_symbol_ref(&p->head);\n-  mio_integer(&p->saved);\n+  flags = p->saved ? 1 : 0;\n+  if (p->threadprivate) flags |= 2;\n+  mio_integer(&flags);\n \n   mio_rparen();\n }\n@@ -3412,6 +3426,7 @@ static void\n write_blank_common (void)\n {\n   const char * name = BLANK_COMMON_NAME;\n+  int saved;\n \n   if (gfc_current_ns->blank_common.head == NULL)\n     return;\n@@ -3421,7 +3436,8 @@ write_blank_common (void)\n   mio_pool_string(&name);\n \n   mio_symbol_ref(&gfc_current_ns->blank_common.head);\n-  mio_integer(&gfc_current_ns->blank_common.saved);\n+  saved = gfc_current_ns->blank_common.saved;\n+  mio_integer(&saved);\n \n   mio_rparen();\n }"}, {"sha": "312d5a1e49a0be0d11bb0ba1a7fe2fd41b81b56a", "filename": "gcc/fortran/openmp.c", "status": "added", "additions": 1325, "deletions": 0, "changes": 1325, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ffortran%2Fopenmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ffortran%2Fopenmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fopenmp.c?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,1325 @@\n+/* OpenMP directive matching and resolving.\n+   Copyright (C) 2005, 2006 Free Software Foundation, Inc.\n+   Contributed by Jakub Jelinek\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"flags.h\"\n+#include \"gfortran.h\"\n+#include \"match.h\"\n+#include \"parse.h\"\n+#include \"pointer-set.h\"\n+#include \"target.h\"\n+#include \"toplev.h\"\n+\n+/* Match an end of OpenMP directive.  End of OpenMP directive is optional\n+   whitespace, followed by '\\n' or comment '!'.  */\n+\n+match\n+gfc_match_omp_eos (void)\n+{\n+  locus old_loc;\n+  int c;\n+\n+  old_loc = gfc_current_locus;\n+  gfc_gobble_whitespace ();\n+\n+  c = gfc_next_char ();\n+  switch (c)\n+    {\n+    case '!':\n+      do\n+\tc = gfc_next_char ();\n+      while (c != '\\n');\n+      /* Fall through */\n+\n+    case '\\n':\n+      return MATCH_YES;\n+    }\n+\n+  gfc_current_locus = old_loc;\n+  return MATCH_NO;\n+}\n+\n+/* Free an omp_clauses structure.  */\n+\n+void\n+gfc_free_omp_clauses (gfc_omp_clauses *c)\n+{\n+  int i;\n+  if (c == NULL)\n+    return;\n+\n+  gfc_free_expr (c->if_expr);\n+  gfc_free_expr (c->num_threads);\n+  gfc_free_expr (c->chunk_size);\n+  for (i = 0; i < OMP_LIST_NUM; i++)\n+    gfc_free_namelist (c->lists[i]);\n+  gfc_free (c);\n+}\n+\n+/* Match a variable/common block list and construct a namelist from it.  */\n+\n+static match\n+gfc_match_omp_variable_list (const char *str, gfc_namelist **list,\n+\t\t\t     bool allow_common)\n+{\n+  gfc_namelist *head, *tail, *p;\n+  locus old_loc;\n+  char n[GFC_MAX_SYMBOL_LEN+1];\n+  gfc_symbol *sym;\n+  match m;\n+  gfc_symtree *st;\n+\n+  head = tail = NULL;\n+\n+  old_loc = gfc_current_locus;\n+\n+  m = gfc_match (str);\n+  if (m != MATCH_YES)\n+    return m;\n+\n+  for (;;)\n+    {\n+      m = gfc_match_symbol (&sym, 1);\n+      switch (m)\n+\t{\n+\tcase MATCH_YES:\n+\t  gfc_set_sym_referenced (sym);\n+\t  p = gfc_get_namelist ();\n+\t  if (head == NULL)\n+\t    head = tail = p;\n+\t  else\n+\t    {\n+\t      tail->next = p;\n+\t      tail = tail->next;\n+\t    }\n+\t  tail->sym = sym;\n+\t  goto next_item;\n+\tcase MATCH_NO:\n+\t  break;\n+\tcase MATCH_ERROR:\n+\t  goto cleanup;\n+\t}\n+\n+      if (!allow_common)\n+\tgoto syntax;\n+\n+      m = gfc_match (\" / %n /\", n);\n+      if (m == MATCH_ERROR)\n+\tgoto cleanup;\n+      if (m == MATCH_NO)\n+\tgoto syntax;\n+\n+      st = gfc_find_symtree (gfc_current_ns->common_root, n);\n+      if (st == NULL)\n+\t{\n+\t  gfc_error (\"COMMON block /%s/ not found at %C\", n);\n+\t  goto cleanup;\n+\t}\n+      for (sym = st->n.common->head; sym; sym = sym->common_next)\n+\t{\n+\t  gfc_set_sym_referenced (sym);\n+\t  p = gfc_get_namelist ();\n+\t  if (head == NULL)\n+\t    head = tail = p;\n+\t  else\n+\t    {\n+\t      tail->next = p;\n+\t      tail = tail->next;\n+\t    }\n+\t  tail->sym = sym;\n+\t}\n+\n+    next_item:\n+      if (gfc_match_char (')') == MATCH_YES)\n+\tbreak;\n+      if (gfc_match_char (',') != MATCH_YES)\n+\tgoto syntax;\n+    }\n+\n+  while (*list)\n+    list = &(*list)->next;\n+\n+  *list = head;\n+  return MATCH_YES;\n+\n+syntax:\n+  gfc_error (\"Syntax error in OpenMP variable list at %C\");\n+\n+cleanup:\n+  gfc_free_namelist (head);\n+  gfc_current_locus = old_loc;\n+  return MATCH_ERROR;\n+}\n+\n+#define OMP_CLAUSE_PRIVATE\t(1 << 0)\n+#define OMP_CLAUSE_FIRSTPRIVATE\t(1 << 1)\n+#define OMP_CLAUSE_LASTPRIVATE\t(1 << 2)\n+#define OMP_CLAUSE_COPYPRIVATE\t(1 << 3)\n+#define OMP_CLAUSE_SHARED\t(1 << 4)\n+#define OMP_CLAUSE_COPYIN\t(1 << 5)\n+#define OMP_CLAUSE_REDUCTION\t(1 << 6)\n+#define OMP_CLAUSE_IF\t\t(1 << 7)\n+#define OMP_CLAUSE_NUM_THREADS\t(1 << 8)\n+#define OMP_CLAUSE_SCHEDULE\t(1 << 9)\n+#define OMP_CLAUSE_DEFAULT\t(1 << 10)\n+#define OMP_CLAUSE_ORDERED\t(1 << 11)\n+\n+/* Match OpenMP directive clauses. MASK is a bitmask of\n+   clauses that are allowed for a particular directive.  */\n+\n+static match\n+gfc_match_omp_clauses (gfc_omp_clauses **cp, int mask)\n+{\n+  gfc_omp_clauses *c = gfc_get_omp_clauses ();\n+  locus old_loc;\n+  bool needs_space = true, first = true;\n+\n+  *cp = NULL;\n+  while (1)\n+    {\n+      if ((first || gfc_match_char (',') != MATCH_YES)\n+\t  && (needs_space && gfc_match_space () != MATCH_YES))\n+\tbreak;\n+      needs_space = false;\n+      first = false;\n+      gfc_gobble_whitespace ();\n+      if ((mask & OMP_CLAUSE_IF) && c->if_expr == NULL\n+\t  && gfc_match (\"if ( %e )\", &c->if_expr) == MATCH_YES)\n+\tcontinue;\n+      if ((mask & OMP_CLAUSE_NUM_THREADS) && c->num_threads == NULL\n+\t  && gfc_match (\"num_threads ( %e )\", &c->num_threads) == MATCH_YES)\n+\tcontinue;\n+      if ((mask & OMP_CLAUSE_PRIVATE)\n+\t  && gfc_match_omp_variable_list (\"private (\",\n+\t\t\t\t\t  &c->lists[OMP_LIST_PRIVATE], true)\n+\t     == MATCH_YES)\n+\tcontinue;\n+      if ((mask & OMP_CLAUSE_FIRSTPRIVATE)\n+\t  && gfc_match_omp_variable_list (\"firstprivate (\",\n+\t\t\t\t\t  &c->lists[OMP_LIST_FIRSTPRIVATE],\n+\t\t\t\t\t  true)\n+\t     == MATCH_YES)\n+\tcontinue;\n+      if ((mask & OMP_CLAUSE_LASTPRIVATE)\n+\t  && gfc_match_omp_variable_list (\"lastprivate (\",\n+\t\t\t\t\t  &c->lists[OMP_LIST_LASTPRIVATE],\n+\t\t\t\t\t  true)\n+\t     == MATCH_YES)\n+\tcontinue;\n+      if ((mask & OMP_CLAUSE_COPYPRIVATE)\n+\t  && gfc_match_omp_variable_list (\"copyprivate (\",\n+\t\t\t\t\t  &c->lists[OMP_LIST_COPYPRIVATE],\n+\t\t\t\t\t  true)\n+\t     == MATCH_YES)\n+\tcontinue;\n+      if ((mask & OMP_CLAUSE_SHARED)\n+\t  && gfc_match_omp_variable_list (\"shared (\",\n+\t\t\t\t\t  &c->lists[OMP_LIST_SHARED], true)\n+\t     == MATCH_YES)\n+\tcontinue;\n+      if ((mask & OMP_CLAUSE_COPYIN)\n+\t  && gfc_match_omp_variable_list (\"copyin (\",\n+\t\t\t\t\t  &c->lists[OMP_LIST_COPYIN], true)\n+\t     == MATCH_YES)\n+\tcontinue;\n+      old_loc = gfc_current_locus;\n+      if ((mask & OMP_CLAUSE_REDUCTION)\n+\t  && gfc_match (\"reduction ( \") == MATCH_YES)\n+\t{\n+\t  int reduction = OMP_LIST_NUM;\n+\t  char buffer[GFC_MAX_SYMBOL_LEN + 1];\n+\t  if (gfc_match_char ('+') == MATCH_YES)\n+\t    reduction = OMP_LIST_PLUS;\n+\t  else if (gfc_match_char ('*') == MATCH_YES)\n+\t    reduction = OMP_LIST_MULT;\n+\t  else if (gfc_match_char ('-') == MATCH_YES)\n+\t    reduction = OMP_LIST_SUB;\n+\t  else if (gfc_match (\".and.\") == MATCH_YES)\n+\t    reduction = OMP_LIST_AND;\n+\t  else if (gfc_match (\".or.\") == MATCH_YES)\n+\t    reduction = OMP_LIST_OR;\n+\t  else if (gfc_match (\".eqv.\") == MATCH_YES)\n+\t    reduction = OMP_LIST_EQV;\n+\t  else if (gfc_match (\".neqv.\") == MATCH_YES)\n+\t    reduction = OMP_LIST_NEQV;\n+\t  else if (gfc_match_name (buffer) == MATCH_YES)\n+\t    {\n+\t      gfc_symbol *sym;\n+\t      const char *n = buffer;\n+\n+\t      gfc_find_symbol (buffer, NULL, 1, &sym);\n+\t      if (sym != NULL)\n+\t\t{\n+\t\t  if (sym->attr.intrinsic)\n+\t\t    n = sym->name;\n+\t\t  else if ((sym->attr.flavor != FL_UNKNOWN\n+\t\t\t    && sym->attr.flavor != FL_PROCEDURE)\n+\t\t\t   || sym->attr.external\n+\t\t\t   || sym->attr.generic\n+\t\t\t   || sym->attr.entry\n+\t\t\t   || sym->attr.result\n+\t\t\t   || sym->attr.dummy\n+\t\t\t   || sym->attr.subroutine\n+\t\t\t   || sym->attr.pointer\n+\t\t\t   || sym->attr.target\n+\t\t\t   || sym->attr.cray_pointer\n+\t\t\t   || sym->attr.cray_pointee\n+\t\t\t   || (sym->attr.proc != PROC_UNKNOWN\n+\t\t\t       && sym->attr.proc != PROC_INTRINSIC)\n+\t\t\t   || sym->attr.if_source != IFSRC_UNKNOWN\n+\t\t\t   || sym == sym->ns->proc_name)\n+\t\t    {\n+\t\t      gfc_error_now (\"%s is not INTRINSIC procedure name \"\n+\t\t\t\t     \"at %C\", buffer);\n+\t\t      sym = NULL;\n+\t\t    }\n+\t\t  else\n+\t\t    n = sym->name;\n+\t\t}\n+\t      if (strcmp (n, \"max\") == 0)\n+\t\treduction = OMP_LIST_MAX;\n+\t      else if (strcmp (n, \"min\") == 0)\n+\t\treduction = OMP_LIST_MIN;\n+\t      else if (strcmp (n, \"iand\") == 0)\n+\t\treduction = OMP_LIST_IAND;\n+\t      else if (strcmp (n, \"ior\") == 0)\n+\t\treduction = OMP_LIST_IOR;\n+\t      else if (strcmp (n, \"ieor\") == 0)\n+\t\treduction = OMP_LIST_IEOR;\n+\t      if (reduction != OMP_LIST_NUM\n+\t\t  && sym != NULL\n+\t\t  && ! sym->attr.intrinsic\n+\t\t  && ! sym->attr.use_assoc\n+\t\t  && ((sym->attr.flavor == FL_UNKNOWN\n+\t\t       && gfc_add_flavor (&sym->attr, FL_PROCEDURE,\n+\t\t\t\t\t  sym->name, NULL) == FAILURE)\n+\t\t      || gfc_add_intrinsic (&sym->attr, NULL) == FAILURE))\n+\t\t{\n+\t\t  gfc_free_omp_clauses (c);\n+\t\t  return MATCH_ERROR;\n+\t\t}\n+\t    }\n+\t  if (reduction != OMP_LIST_NUM\n+\t      && gfc_match_omp_variable_list (\" :\", &c->lists[reduction],\n+\t\t\t\t\t      false)\n+\t\t == MATCH_YES)\n+\t    continue;\n+\t  else\n+\t    gfc_current_locus = old_loc;\n+\t}\n+      if ((mask & OMP_CLAUSE_DEFAULT)\n+\t  && c->default_sharing == OMP_DEFAULT_UNKNOWN)\n+\t{\n+\t  if (gfc_match (\"default ( shared )\") == MATCH_YES)\n+\t    c->default_sharing = OMP_DEFAULT_SHARED;\n+\t  else if (gfc_match (\"default ( private )\") == MATCH_YES)\n+\t    c->default_sharing = OMP_DEFAULT_PRIVATE;\n+\t  else if (gfc_match (\"default ( none )\") == MATCH_YES)\n+\t    c->default_sharing = OMP_DEFAULT_NONE;\n+\t  if (c->default_sharing != OMP_DEFAULT_UNKNOWN)\n+\t    continue;\n+\t}\n+      old_loc = gfc_current_locus;\n+      if ((mask & OMP_CLAUSE_SCHEDULE)\n+\t  && c->sched_kind == OMP_SCHED_NONE\n+\t  && gfc_match (\"schedule ( \") == MATCH_YES)\n+\t{\n+\t  if (gfc_match (\"static\") == MATCH_YES)\n+\t    c->sched_kind = OMP_SCHED_STATIC;\n+\t  else if (gfc_match (\"dynamic\") == MATCH_YES)\n+\t    c->sched_kind = OMP_SCHED_DYNAMIC;\n+\t  else if (gfc_match (\"guided\") == MATCH_YES)\n+\t    c->sched_kind = OMP_SCHED_GUIDED;\n+\t  else if (gfc_match (\"runtime\") == MATCH_YES)\n+\t    c->sched_kind = OMP_SCHED_RUNTIME;\n+\t  if (c->sched_kind != OMP_SCHED_NONE)\n+\t    {\n+\t      match m = MATCH_NO;\n+\t      if (c->sched_kind != OMP_SCHED_RUNTIME)\n+\t\tm = gfc_match (\" , %e )\", &c->chunk_size);\n+\t      if (m != MATCH_YES)\n+\t\tm = gfc_match_char (')');\n+\t      if (m != MATCH_YES)\n+\t\tc->sched_kind = OMP_SCHED_NONE;\n+\t    }\n+\t  if (c->sched_kind != OMP_SCHED_NONE)\n+\t    continue;\n+\t  else\n+\t    gfc_current_locus = old_loc;\n+\t}\n+      if ((mask & OMP_CLAUSE_ORDERED) && !c->ordered\n+\t  && gfc_match (\"ordered\") == MATCH_YES)\n+\t{\n+\t  c->ordered = needs_space = true;\n+\t  continue;\n+\t}\n+\n+      break;\n+    }\n+\n+  if (gfc_match_omp_eos () != MATCH_YES)\n+    {\n+      gfc_free_omp_clauses (c);\n+      return MATCH_ERROR;\n+    }\n+\n+  *cp = c;\n+  return MATCH_YES;\n+}\n+\n+#define OMP_PARALLEL_CLAUSES \\\n+  (OMP_CLAUSE_PRIVATE | OMP_CLAUSE_FIRSTPRIVATE | OMP_CLAUSE_SHARED\t\\\n+   | OMP_CLAUSE_COPYIN | OMP_CLAUSE_REDUCTION | OMP_CLAUSE_IF\t\t\\\n+   | OMP_CLAUSE_NUM_THREADS | OMP_CLAUSE_DEFAULT)\n+#define OMP_DO_CLAUSES \\\n+  (OMP_CLAUSE_PRIVATE | OMP_CLAUSE_FIRSTPRIVATE\t\t\t\t\\\n+   | OMP_CLAUSE_LASTPRIVATE | OMP_CLAUSE_REDUCTION\t\t\t\\\n+   | OMP_CLAUSE_SCHEDULE | OMP_CLAUSE_ORDERED)\n+#define OMP_SECTIONS_CLAUSES \\\n+  (OMP_CLAUSE_PRIVATE | OMP_CLAUSE_FIRSTPRIVATE\t\t\t\t\\\n+   | OMP_CLAUSE_LASTPRIVATE | OMP_CLAUSE_REDUCTION)\n+\n+match\n+gfc_match_omp_parallel (void)\n+{\n+  gfc_omp_clauses *c;\n+  if (gfc_match_omp_clauses (&c, OMP_PARALLEL_CLAUSES) != MATCH_YES)\n+    return MATCH_ERROR;\n+  new_st.op = EXEC_OMP_PARALLEL;\n+  new_st.ext.omp_clauses = c;\n+  return MATCH_YES;\n+}\n+\n+match\n+gfc_match_omp_critical (void)\n+{\n+  char n[GFC_MAX_SYMBOL_LEN+1];\n+\n+  if (gfc_match (\" ( %n )\", n) != MATCH_YES)\n+    n[0] = '\\0';\n+  if (gfc_match_omp_eos () != MATCH_YES)\n+    return MATCH_ERROR;\n+  new_st.op = EXEC_OMP_CRITICAL;\n+  new_st.ext.omp_name = n[0] ? xstrdup (n) : NULL;\n+  return MATCH_YES;\n+}\n+\n+match\n+gfc_match_omp_do (void)\n+{\n+  gfc_omp_clauses *c;\n+  if (gfc_match_omp_clauses (&c, OMP_DO_CLAUSES) != MATCH_YES)\n+    return MATCH_ERROR;\n+  new_st.op = EXEC_OMP_DO;\n+  new_st.ext.omp_clauses = c;\n+  return MATCH_YES;\n+}\n+\n+match\n+gfc_match_omp_flush (void)\n+{\n+  gfc_namelist *list = NULL;\n+  gfc_match_omp_variable_list (\" (\", &list, true);\n+  if (gfc_match_omp_eos () != MATCH_YES)\n+    {\n+      gfc_free_namelist (list);\n+      return MATCH_ERROR;\n+    }\n+  new_st.op = EXEC_OMP_FLUSH;\n+  new_st.ext.omp_namelist = list;\n+  return MATCH_YES;\n+}\n+\n+match\n+gfc_match_omp_threadprivate (void)\n+{\n+  locus old_loc;\n+  char n[GFC_MAX_SYMBOL_LEN+1];\n+  gfc_symbol *sym;\n+  match m;\n+  gfc_symtree *st;\n+\n+  old_loc = gfc_current_locus;\n+\n+  m = gfc_match (\" (\");\n+  if (m != MATCH_YES)\n+    return m;\n+\n+  if (!targetm.have_tls)\n+    {\n+      sorry (\"threadprivate variables not supported in this target\");\n+      goto cleanup;\n+    }\n+\n+  for (;;)\n+    {\n+      m = gfc_match_symbol (&sym, 0);\n+      switch (m)\n+\t{\n+\tcase MATCH_YES:\n+\t  if (sym->attr.in_common)\n+\t    gfc_error_now (\"Threadprivate variable at %C is an element of\"\n+\t\t\t   \" a COMMON block\");\n+\t  else if (gfc_add_threadprivate (&sym->attr, sym->name,\n+\t\t   &sym->declared_at) == FAILURE)\n+\t    goto cleanup;\n+\t  goto next_item;\n+\tcase MATCH_NO:\n+\t  break;\n+\tcase MATCH_ERROR:\n+\t  goto cleanup;\n+\t}\n+\n+      m = gfc_match (\" / %n /\", n);\n+      if (m == MATCH_ERROR)\n+\tgoto cleanup;\n+      if (m == MATCH_NO || n[0] == '\\0')\n+\tgoto syntax;\n+\n+      st = gfc_find_symtree (gfc_current_ns->common_root, n);\n+      if (st == NULL)\n+\t{\n+\t  gfc_error (\"COMMON block /%s/ not found at %C\", n);\n+\t  goto cleanup;\n+\t}\n+      st->n.common->threadprivate = 1;\n+      for (sym = st->n.common->head; sym; sym = sym->common_next)\n+\tif (gfc_add_threadprivate (&sym->attr, sym->name,\n+\t\t\t\t   &sym->declared_at) == FAILURE)\n+\t  goto cleanup;\n+\n+    next_item:\n+      if (gfc_match_char (')') == MATCH_YES)\n+\tbreak;\n+      if (gfc_match_char (',') != MATCH_YES)\n+\tgoto syntax;\n+    }\n+\n+  return MATCH_YES;\n+\n+syntax:\n+  gfc_error (\"Syntax error in !$OMP THREADPRIVATE list at %C\");\n+\n+cleanup:\n+  gfc_current_locus = old_loc;\n+  return MATCH_ERROR;\n+}\n+\n+match\n+gfc_match_omp_parallel_do (void)\n+{\n+  gfc_omp_clauses *c;\n+  if (gfc_match_omp_clauses (&c, OMP_PARALLEL_CLAUSES | OMP_DO_CLAUSES)\n+      != MATCH_YES)\n+    return MATCH_ERROR;\n+  new_st.op = EXEC_OMP_PARALLEL_DO;\n+  new_st.ext.omp_clauses = c;\n+  return MATCH_YES;\n+}\n+\n+match\n+gfc_match_omp_parallel_sections (void)\n+{\n+  gfc_omp_clauses *c;\n+  if (gfc_match_omp_clauses (&c, OMP_PARALLEL_CLAUSES | OMP_SECTIONS_CLAUSES)\n+      != MATCH_YES)\n+    return MATCH_ERROR;\n+  new_st.op = EXEC_OMP_PARALLEL_SECTIONS;\n+  new_st.ext.omp_clauses = c;\n+  return MATCH_YES;\n+}\n+\n+match\n+gfc_match_omp_parallel_workshare (void)\n+{\n+  gfc_omp_clauses *c;\n+  if (gfc_match_omp_clauses (&c, OMP_PARALLEL_CLAUSES) != MATCH_YES)\n+    return MATCH_ERROR;\n+  new_st.op = EXEC_OMP_PARALLEL_WORKSHARE;\n+  new_st.ext.omp_clauses = c;\n+  return MATCH_YES;\n+}\n+\n+match\n+gfc_match_omp_sections (void)\n+{\n+  gfc_omp_clauses *c;\n+  if (gfc_match_omp_clauses (&c, OMP_SECTIONS_CLAUSES) != MATCH_YES)\n+    return MATCH_ERROR;\n+  new_st.op = EXEC_OMP_SECTIONS;\n+  new_st.ext.omp_clauses = c;\n+  return MATCH_YES;\n+}\n+\n+match\n+gfc_match_omp_single (void)\n+{\n+  gfc_omp_clauses *c;\n+  if (gfc_match_omp_clauses (&c, OMP_CLAUSE_PRIVATE | OMP_CLAUSE_FIRSTPRIVATE)\n+      != MATCH_YES)\n+    return MATCH_ERROR;\n+  new_st.op = EXEC_OMP_SINGLE;\n+  new_st.ext.omp_clauses = c;\n+  return MATCH_YES;\n+}\n+\n+match\n+gfc_match_omp_workshare (void)\n+{\n+  if (gfc_match_omp_eos () != MATCH_YES)\n+    return MATCH_ERROR;\n+  new_st.op = EXEC_OMP_WORKSHARE;\n+  new_st.ext.omp_clauses = gfc_get_omp_clauses ();\n+  return MATCH_YES;\n+}\n+\n+match\n+gfc_match_omp_master (void)\n+{\n+  if (gfc_match_omp_eos () != MATCH_YES)\n+    return MATCH_ERROR;\n+  new_st.op = EXEC_OMP_MASTER;\n+  new_st.ext.omp_clauses = NULL;\n+  return MATCH_YES;\n+}\n+\n+match\n+gfc_match_omp_ordered (void)\n+{\n+  if (gfc_match_omp_eos () != MATCH_YES)\n+    return MATCH_ERROR;\n+  new_st.op = EXEC_OMP_ORDERED;\n+  new_st.ext.omp_clauses = NULL;\n+  return MATCH_YES;\n+}\n+\n+match\n+gfc_match_omp_atomic (void)\n+{\n+  if (gfc_match_omp_eos () != MATCH_YES)\n+    return MATCH_ERROR;\n+  new_st.op = EXEC_OMP_ATOMIC;\n+  new_st.ext.omp_clauses = NULL;\n+  return MATCH_YES;\n+}\n+\n+match\n+gfc_match_omp_barrier (void)\n+{\n+  if (gfc_match_omp_eos () != MATCH_YES)\n+    return MATCH_ERROR;\n+  new_st.op = EXEC_OMP_BARRIER;\n+  new_st.ext.omp_clauses = NULL;\n+  return MATCH_YES;\n+}\n+\n+match\n+gfc_match_omp_end_nowait (void)\n+{\n+  bool nowait = false;\n+  if (gfc_match (\"% nowait\") == MATCH_YES)\n+    nowait = true;\n+  if (gfc_match_omp_eos () != MATCH_YES)\n+    return MATCH_ERROR;\n+  new_st.op = EXEC_OMP_END_NOWAIT;\n+  new_st.ext.omp_bool = nowait;\n+  return MATCH_YES;\n+}\n+\n+match\n+gfc_match_omp_end_single (void)\n+{\n+  gfc_omp_clauses *c;\n+  if (gfc_match (\"% nowait\") == MATCH_YES)\n+    {\n+      new_st.op = EXEC_OMP_END_NOWAIT;\n+      new_st.ext.omp_bool = true;\n+      return MATCH_YES;\n+    }\n+  if (gfc_match_omp_clauses (&c, OMP_CLAUSE_COPYPRIVATE) != MATCH_YES)\n+    return MATCH_ERROR;\n+  new_st.op = EXEC_OMP_END_SINGLE;\n+  new_st.ext.omp_clauses = c;\n+  return MATCH_YES;\n+}\n+\n+/* OpenMP directive resolving routines.  */\n+\n+static void\n+resolve_omp_clauses (gfc_code *code)\n+{\n+  gfc_omp_clauses *omp_clauses = code->ext.omp_clauses;\n+  gfc_namelist *n;\n+  int list;\n+  static const char *clause_names[]\n+    = { \"PRIVATE\", \"FIRSTPRIVATE\", \"LASTPRIVATE\", \"COPYPRIVATE\", \"SHARED\",\n+\t\"COPYIN\", \"REDUCTION\" };\n+\n+  if (omp_clauses == NULL)\n+    return;\n+\n+  if (omp_clauses->if_expr)\n+    {\n+      gfc_expr *expr = omp_clauses->if_expr;\n+      if (gfc_resolve_expr (expr) == FAILURE\n+\t  || expr->ts.type != BT_LOGICAL || expr->rank != 0)\n+\tgfc_error (\"IF clause at %L requires a scalar LOGICAL expression\",\n+\t\t   &expr->where);\n+    }\n+  if (omp_clauses->num_threads)\n+    {\n+      gfc_expr *expr = omp_clauses->num_threads;\n+      if (gfc_resolve_expr (expr) == FAILURE\n+\t  || expr->ts.type != BT_INTEGER || expr->rank != 0)\n+\tgfc_error (\"NUM_THREADS clause at %L requires a scalar\"\n+\t\t   \" INTEGER expression\", &expr->where);\n+    }\n+  if (omp_clauses->chunk_size)\n+    {\n+      gfc_expr *expr = omp_clauses->chunk_size;\n+      if (gfc_resolve_expr (expr) == FAILURE\n+\t  || expr->ts.type != BT_INTEGER || expr->rank != 0)\n+\tgfc_error (\"SCHEDULE clause's chunk_size at %L requires\"\n+\t\t   \" a scalar INTEGER expression\", &expr->where);\n+    }\n+\n+  /* Check that no symbol appears on multiple clauses, except that\n+     a symbol can appear on both firstprivate and lastprivate.  */\n+  for (list = 0; list < OMP_LIST_NUM; list++)\n+    for (n = omp_clauses->lists[list]; n; n = n->next)\n+      n->sym->mark = 0;\n+\n+  for (list = 0; list < OMP_LIST_NUM; list++)\n+    if (list != OMP_LIST_FIRSTPRIVATE && list != OMP_LIST_LASTPRIVATE)\n+      for (n = omp_clauses->lists[list]; n; n = n->next)\n+\tif (n->sym->mark)\n+\t  gfc_error (\"Symbol '%s' present on multiple clauses at %L\",\n+\t\t     n->sym->name, &code->loc);\n+\telse\n+\t  n->sym->mark = 1;\n+\n+  gcc_assert (OMP_LIST_LASTPRIVATE == OMP_LIST_FIRSTPRIVATE + 1);\n+  for (list = OMP_LIST_FIRSTPRIVATE; list <= OMP_LIST_LASTPRIVATE; list++)\n+    for (n = omp_clauses->lists[list]; n; n = n->next)\n+      if (n->sym->mark)\n+\t{\n+\t  gfc_error (\"Symbol '%s' present on multiple clauses at %L\",\n+\t\t     n->sym->name, &code->loc);\n+\t  n->sym->mark = 0;\n+\t}\n+\n+  for (n = omp_clauses->lists[OMP_LIST_FIRSTPRIVATE]; n; n = n->next)\n+    if (n->sym->mark)\n+      gfc_error (\"Symbol '%s' present on multiple clauses at %L\",\n+\t\t n->sym->name, &code->loc);\n+    else\n+      n->sym->mark = 1;\n+\n+  for (n = omp_clauses->lists[OMP_LIST_LASTPRIVATE]; n; n = n->next)\n+    n->sym->mark = 0;\n+\n+  for (n = omp_clauses->lists[OMP_LIST_LASTPRIVATE]; n; n = n->next)\n+    if (n->sym->mark)\n+      gfc_error (\"Symbol '%s' present on multiple clauses at %L\",\n+\t\t n->sym->name, &code->loc);\n+    else\n+      n->sym->mark = 1;\n+\n+  for (list = 0; list < OMP_LIST_NUM; list++)\n+    if ((n = omp_clauses->lists[list]) != NULL)\n+      {\n+\tconst char *name;\n+\n+\tif (list < OMP_LIST_REDUCTION_FIRST)\n+\t  name = clause_names[list];\n+\telse if (list <= OMP_LIST_REDUCTION_LAST)\n+\t  name = clause_names[OMP_LIST_REDUCTION_FIRST];\n+\telse\n+\t  gcc_unreachable ();\n+\n+\tswitch (list)\n+\t  {\n+\t  case OMP_LIST_COPYIN:\n+\t    for (; n != NULL; n = n->next)\n+\t      {\n+\t\tif (!n->sym->attr.threadprivate)\n+\t\t  gfc_error (\"Non-THREADPRIVATE object '%s' in COPYIN clause\"\n+\t\t\t     \" at %L\", n->sym->name, &code->loc);\n+\t\tif (n->sym->attr.allocatable)\n+\t\t  gfc_error (\"COPYIN clause object '%s' is ALLOCATABLE at %L\",\n+\t\t\t     n->sym->name, &code->loc);\n+\t      }\n+\t    break;\n+\t  case OMP_LIST_COPYPRIVATE:\n+\t    for (; n != NULL; n = n->next)\n+\t      {\n+\t\tif (n->sym->as && n->sym->as->type == AS_ASSUMED_SIZE)\n+\t\t  gfc_error (\"Assumed size array '%s' in COPYPRIVATE clause\"\n+\t\t\t     \" at %L\", n->sym->name, &code->loc);\n+\t\tif (n->sym->attr.allocatable)\n+\t\t  gfc_error (\"COPYPRIVATE clause object '%s' is ALLOCATABLE\"\n+\t\t\t     \" at %L\", n->sym->name, &code->loc);\n+\t      }\n+\t    break;\n+\t  case OMP_LIST_SHARED:\n+\t    for (; n != NULL; n = n->next)\n+\t      {\n+\t\tif (n->sym->attr.threadprivate)\n+\t\t  gfc_error (\"THREADPRIVATE object '%s' in SHARED clause at\"\n+\t\t\t     \" %L\", n->sym->name, &code->loc);\n+\t\tif (n->sym->attr.cray_pointee)\n+\t\t  gfc_error (\"Cray pointee '%s' in SHARED clause at %L\",\n+\t\t\t    n->sym->name, &code->loc);\n+\t      }\n+\t    break;\n+\t  default:\n+\t    for (; n != NULL; n = n->next)\n+\t      {\n+\t\tif (n->sym->attr.threadprivate)\n+\t\t  gfc_error (\"THREADPRIVATE object '%s' in %s clause at %L\",\n+\t\t\t     n->sym->name, name, &code->loc);\n+\t\tif (n->sym->attr.cray_pointee)\n+\t\t  gfc_error (\"Cray pointee '%s' in %s clause at %L\",\n+\t\t\t    n->sym->name, name, &code->loc);\n+\t\tif (list != OMP_LIST_PRIVATE)\n+\t\t  {\n+\t\t    if (n->sym->attr.pointer)\n+\t\t      gfc_error (\"POINTER object '%s' in %s clause at %L\",\n+\t\t\t\t n->sym->name, name, &code->loc);\n+\t\t    if (n->sym->attr.allocatable)\n+\t\t      gfc_error (\"%s clause object '%s' is ALLOCATABLE at %L\",\n+\t\t\t\t name, n->sym->name, &code->loc);\n+\t\t    if (n->sym->attr.cray_pointer)\n+\t\t      gfc_error (\"Cray pointer '%s' in %s clause at %L\",\n+\t\t\t\t n->sym->name, name, &code->loc);\n+\t\t  }\n+\t\tif (n->sym->as && n->sym->as->type == AS_ASSUMED_SIZE)\n+\t\t  gfc_error (\"Assumed size array '%s' in %s clause at %L\",\n+\t\t\t     n->sym->name, name, &code->loc);\n+\t\tif (n->sym->attr.in_namelist\n+\t\t    && (list < OMP_LIST_REDUCTION_FIRST\n+\t\t\t|| list > OMP_LIST_REDUCTION_LAST))\n+\t\t  gfc_error (\"Variable '%s' in %s clause is used in\"\n+\t\t\t     \" NAMELIST statement at %L\",\n+\t\t\t     n->sym->name, name, &code->loc);\n+\t\tswitch (list)\n+\t\t  {\n+\t\t  case OMP_LIST_PLUS:\n+\t\t  case OMP_LIST_MULT:\n+\t\t  case OMP_LIST_SUB:\n+\t\t    if (!gfc_numeric_ts (&n->sym->ts))\n+\t\t      gfc_error (\"%c REDUCTION variable '%s' is %s at %L\",\n+\t\t\t\t list == OMP_LIST_PLUS ? '+'\n+\t\t\t\t : list == OMP_LIST_MULT ? '*' : '-',\n+\t\t\t\t n->sym->name, gfc_typename (&n->sym->ts),\n+\t\t\t\t &code->loc);\n+\t\t    break;\n+\t\t  case OMP_LIST_AND:\n+\t\t  case OMP_LIST_OR:\n+\t\t  case OMP_LIST_EQV:\n+\t\t  case OMP_LIST_NEQV:\n+\t\t    if (n->sym->ts.type != BT_LOGICAL)\n+\t\t      gfc_error (\"%s REDUCTION variable '%s' must be LOGICAL\"\n+\t\t\t\t \" at %L\",\n+\t\t\t\t list == OMP_LIST_AND ? \".AND.\"\n+\t\t\t\t : list == OMP_LIST_OR ? \".OR.\"\n+\t\t\t\t : list == OMP_LIST_EQV ? \".EQV.\" : \".NEQV.\",\n+\t\t\t\t n->sym->name, &code->loc);\n+\t\t    break;\n+\t\t  case OMP_LIST_MAX:\n+\t\t  case OMP_LIST_MIN:\n+\t\t    if (n->sym->ts.type != BT_INTEGER\n+\t\t\t&& n->sym->ts.type != BT_REAL)\n+\t\t      gfc_error (\"%s REDUCTION variable '%s' must be\"\n+\t\t\t\t \" INTEGER or REAL at %L\",\n+\t\t\t\t list == OMP_LIST_MAX ? \"MAX\" : \"MIN\",\n+\t\t\t\t n->sym->name, &code->loc);\n+\t\t    break;\n+\t\t  case OMP_LIST_IAND:\n+\t\t  case OMP_LIST_IOR:\n+\t\t  case OMP_LIST_IEOR:\n+\t\t    if (n->sym->ts.type != BT_INTEGER)\n+\t\t      gfc_error (\"%s REDUCTION variable '%s' must be INTEGER\"\n+\t\t\t\t \" at %L\",\n+\t\t\t\t list == OMP_LIST_IAND ? \"IAND\"\n+\t\t\t\t : list == OMP_LIST_MULT ? \"IOR\" : \"IEOR\",\n+\t\t\t\t n->sym->name, &code->loc);\n+\t\t    break;\n+\t\t  default:\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t    break;\n+\t  }\n+      }\n+}\n+\n+/* Return true if SYM is ever referenced in EXPR except in the SE node.  */\n+\n+static bool\n+expr_references_sym (gfc_expr *e, gfc_symbol *s, gfc_expr *se)\n+{\n+  gfc_actual_arglist *arg;\n+  if (e == NULL || e == se)\n+    return false;\n+  switch (e->expr_type)\n+    {\n+    case EXPR_CONSTANT:\n+    case EXPR_NULL:\n+    case EXPR_VARIABLE:\n+    case EXPR_STRUCTURE:\n+    case EXPR_ARRAY:\n+      if (e->symtree != NULL\n+\t  && e->symtree->n.sym == s)\n+\treturn true;\n+      return false;\n+    case EXPR_SUBSTRING:\n+      if (e->ref != NULL\n+\t  && (expr_references_sym (e->ref->u.ss.start, s, se)\n+\t      || expr_references_sym (e->ref->u.ss.end, s, se)))\n+\treturn true;\n+      return false;\n+    case EXPR_OP:\n+      if (expr_references_sym (e->value.op.op2, s, se))\n+\treturn true;\n+      return expr_references_sym (e->value.op.op1, s, se);\n+    case EXPR_FUNCTION:\n+      for (arg = e->value.function.actual; arg; arg = arg->next)\n+\tif (expr_references_sym (arg->expr, s, se))\n+\t  return true;\n+      return false;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* If EXPR is a conversion function that widens the type\n+   if WIDENING is true or narrows the type if WIDENING is false,\n+   return the inner expression, otherwise return NULL.  */\n+\n+static gfc_expr *\n+is_conversion (gfc_expr *expr, bool widening)\n+{\n+  gfc_typespec *ts1, *ts2;\n+\n+  if (expr->expr_type != EXPR_FUNCTION\n+      || expr->value.function.isym == NULL\n+      || expr->value.function.esym != NULL\n+      || expr->value.function.isym->generic_id != GFC_ISYM_CONVERSION)\n+    return NULL;\n+\n+  if (widening)\n+    {\n+      ts1 = &expr->ts;\n+      ts2 = &expr->value.function.actual->expr->ts;\n+    }\n+  else\n+    {\n+      ts1 = &expr->value.function.actual->expr->ts;\n+      ts2 = &expr->ts;\n+    }\n+\n+  if (ts1->type > ts2->type\n+      || (ts1->type == ts2->type && ts1->kind > ts2->kind))\n+    return expr->value.function.actual->expr;\n+\n+  return NULL;\n+}\n+\n+static void\n+resolve_omp_atomic (gfc_code *code)\n+{\n+  gfc_symbol *var;\n+  gfc_expr *expr2;\n+\n+  code = code->block->next;\n+  gcc_assert (code->op == EXEC_ASSIGN);\n+  gcc_assert (code->next == NULL);\n+\n+  if (code->expr->expr_type != EXPR_VARIABLE\n+      || code->expr->symtree == NULL\n+      || code->expr->rank != 0\n+      || (code->expr->ts.type != BT_INTEGER\n+\t  && code->expr->ts.type != BT_REAL\n+\t  && code->expr->ts.type != BT_COMPLEX\n+\t  && code->expr->ts.type != BT_LOGICAL))\n+    {\n+      gfc_error (\"!$OMP ATOMIC statement must set a scalar variable of\"\n+\t\t \" intrinsic type at %L\", &code->loc);\n+      return;\n+    }\n+\n+  var = code->expr->symtree->n.sym;\n+  expr2 = is_conversion (code->expr2, false);\n+  if (expr2 == NULL)\n+    expr2 = code->expr2;\n+\n+  if (expr2->expr_type == EXPR_OP)\n+    {\n+      gfc_expr *v = NULL, *e, *c;\n+      gfc_intrinsic_op op = expr2->value.op.operator;\n+      gfc_intrinsic_op alt_op = INTRINSIC_NONE;\n+\n+      switch (op)\n+\t{\n+\tcase INTRINSIC_PLUS:\n+\t  alt_op = INTRINSIC_MINUS;\n+\t  break;\n+\tcase INTRINSIC_TIMES:\n+\t  alt_op = INTRINSIC_DIVIDE;\n+\t  break;\n+\tcase INTRINSIC_MINUS:\n+\t  alt_op = INTRINSIC_PLUS;\n+\t  break;\n+\tcase INTRINSIC_DIVIDE:\n+\t  alt_op = INTRINSIC_TIMES;\n+\t  break;\n+\tcase INTRINSIC_AND:\n+\tcase INTRINSIC_OR:\n+\t  break;\n+\tcase INTRINSIC_EQV:\n+\t  alt_op = INTRINSIC_NEQV;\n+\t  break;\n+\tcase INTRINSIC_NEQV:\n+\t  alt_op = INTRINSIC_EQV;\n+\t  break;\n+\tdefault:\n+\t  gfc_error (\"!$OMP ATOMIC assignment operator must be\"\n+\t\t     \" +, *, -, /, .AND., .OR., .EQV. or .NEQV. at %L\",\n+\t\t     &expr2->where);\n+\t  return;\n+\t}\n+\n+      /* Check for var = var op expr resp. var = expr op var where\n+\t expr doesn't reference var and var op expr is mathematically\n+\t equivalent to var op (expr) resp. expr op var equivalent to\n+\t (expr) op var.  We rely here on the fact that the matcher\n+\t for x op1 y op2 z where op1 and op2 have equal precedence\n+\t returns (x op1 y) op2 z.  */\n+      e = expr2->value.op.op2;\n+      if (e->expr_type == EXPR_VARIABLE\n+\t  && e->symtree != NULL\n+\t  && e->symtree->n.sym == var)\n+\tv = e;\n+      else if ((c = is_conversion (e, true)) != NULL\n+\t       && c->expr_type == EXPR_VARIABLE\n+\t       && c->symtree != NULL\n+\t       && c->symtree->n.sym == var)\n+\tv = c;\n+      else\n+\t{\n+\t  gfc_expr **p = NULL, **q;\n+\t  for (q = &expr2->value.op.op1; (e = *q) != NULL; )\n+\t    if (e->expr_type == EXPR_VARIABLE\n+\t\t&& e->symtree != NULL\n+\t\t&& e->symtree->n.sym == var)\n+\t      {\n+\t\tv = e;\n+\t\tbreak;\n+\t      }\n+\t    else if ((c = is_conversion (e, true)) != NULL)\n+\t      q = &e->value.function.actual->expr;\n+\t    else if (e->expr_type != EXPR_OP\n+\t\t     || (e->value.op.operator != op\n+\t\t\t && e->value.op.operator != alt_op)\n+\t\t     || e->rank != 0)\n+\t      break;\n+\t    else\n+\t      {\n+\t\tp = q;\n+\t\tq = &e->value.op.op1;\n+\t      }\n+\n+\t  if (v == NULL)\n+\t    {\n+\t      gfc_error (\"!$OMP ATOMIC assignment must be var = var op expr\"\n+\t\t\t \" or var = expr op var at %L\", &expr2->where);\n+\t      return;\n+\t    }\n+\n+\t  if (p != NULL)\n+\t    {\n+\t      e = *p;\n+\t      switch (e->value.op.operator)\n+\t\t{\n+\t\tcase INTRINSIC_MINUS:\n+\t\tcase INTRINSIC_DIVIDE:\n+\t\tcase INTRINSIC_EQV:\n+\t\tcase INTRINSIC_NEQV:\n+\t\t  gfc_error (\"!$OMP ATOMIC var = var op expr not\"\n+\t\t\t     \" mathematically equivalent to var = var op\"\n+\t\t\t     \" (expr) at %L\", &expr2->where);\n+\t\t  break;\n+\t\tdefault:\n+\t\t  break;\n+\t\t}\n+\n+\t      /* Canonicalize into var = var op (expr).  */\n+\t      *p = e->value.op.op2;\n+\t      e->value.op.op2 = expr2;\n+\t      e->ts = expr2->ts;\n+\t      if (code->expr2 == expr2)\n+\t\tcode->expr2 = expr2 = e;\n+\t      else\n+\t\tcode->expr2->value.function.actual->expr = expr2 = e;\n+\n+\t      if (!gfc_compare_types (&expr2->value.op.op1->ts, &expr2->ts))\n+\t\t{\n+\t\t  for (p = &expr2->value.op.op1; *p != v;\n+\t\t       p = &(*p)->value.function.actual->expr)\n+\t\t    ;\n+\t\t  *p = NULL;\n+\t\t  gfc_free_expr (expr2->value.op.op1);\n+\t\t  expr2->value.op.op1 = v;\n+\t\t  gfc_convert_type (v, &expr2->ts, 2);\n+\t\t}\n+\t    }\n+\t}\n+\n+      if (e->rank != 0 || expr_references_sym (code->expr2, var, v))\n+\t{\n+\t  gfc_error (\"expr in !$OMP ATOMIC assignment var = var op expr\"\n+\t\t     \" must be scalar and cannot reference var at %L\",\n+\t\t     &expr2->where);\n+\t  return;\n+\t}\n+    }\n+  else if (expr2->expr_type == EXPR_FUNCTION\n+\t   && expr2->value.function.isym != NULL\n+\t   && expr2->value.function.esym == NULL\n+\t   && expr2->value.function.actual != NULL\n+\t   && expr2->value.function.actual->next != NULL)\n+    {\n+      gfc_actual_arglist *arg, *var_arg;\n+\n+      switch (expr2->value.function.isym->generic_id)\n+\t{\n+\tcase GFC_ISYM_MIN:\n+\tcase GFC_ISYM_MAX:\n+\t  break;\n+\tcase GFC_ISYM_IAND:\n+\tcase GFC_ISYM_IOR:\n+\tcase GFC_ISYM_IEOR:\n+\t  if (expr2->value.function.actual->next->next != NULL)\n+\t    {\n+\t      gfc_error (\"!$OMP ATOMIC assignment intrinsic IAND, IOR\"\n+\t\t\t \"or IEOR must have two arguments at %L\",\n+\t\t\t &expr2->where);\n+\t      return;\n+\t    }\n+\t  break;\n+\tdefault:\n+\t  gfc_error (\"!$OMP ATOMIC assignment intrinsic must be\"\n+\t\t     \" MIN, MAX, IAND, IOR or IEOR at %L\",\n+\t\t     &expr2->where);\n+\t  return;\n+\t}\n+\n+      var_arg = NULL;\n+      for (arg = expr2->value.function.actual; arg; arg = arg->next)\n+\t{\n+\t  if ((arg == expr2->value.function.actual\n+\t       || (var_arg == NULL && arg->next == NULL))\n+\t      && arg->expr->expr_type == EXPR_VARIABLE\n+\t      && arg->expr->symtree != NULL\n+\t      && arg->expr->symtree->n.sym == var)\n+\t    var_arg = arg;\n+\t  else if (expr_references_sym (arg->expr, var, NULL))\n+\t    gfc_error (\"!$OMP ATOMIC intrinsic arguments except one must not\"\n+\t\t       \" reference '%s' at %L\", var->name, &arg->expr->where);\n+\t  if (arg->expr->rank != 0)\n+\t    gfc_error (\"!$OMP ATOMIC intrinsic arguments must be scalar\"\n+\t\t       \" at %L\", &arg->expr->where);\n+\t}\n+\n+      if (var_arg == NULL)\n+\t{\n+\t  gfc_error (\"First or last !$OMP ATOMIC intrinsic argument must\"\n+\t\t     \" be '%s' at %L\", var->name, &expr2->where);\n+\t  return;\n+\t}\n+\n+      if (var_arg != expr2->value.function.actual)\n+\t{\n+\t  /* Canonicalize, so that var comes first.  */\n+\t  gcc_assert (var_arg->next == NULL);\n+\t  for (arg = expr2->value.function.actual;\n+\t       arg->next != var_arg; arg = arg->next)\n+\t    ;\n+\t  var_arg->next = expr2->value.function.actual;\n+\t  expr2->value.function.actual = var_arg;\n+\t  arg->next = NULL;\n+\t}\n+    }\n+  else\n+    gfc_error (\"!$OMP ATOMIC assignment must have an operator or intrinsic\"\n+\t       \" on right hand side at %L\", &expr2->where);\n+}\n+\n+struct omp_context\n+{\n+  gfc_code *code;\n+  struct pointer_set_t *sharing_clauses;\n+  struct pointer_set_t *private_iterators;\n+  struct omp_context *previous;\n+} *omp_current_ctx;\n+gfc_code *omp_current_do_code;\n+\n+void\n+gfc_resolve_omp_do_blocks (gfc_code *code, gfc_namespace *ns)\n+{\n+  if (code->block->next && code->block->next->op == EXEC_DO)\n+    omp_current_do_code = code->block->next;\n+  gfc_resolve_blocks (code->block, ns);\n+}\n+\n+void\n+gfc_resolve_omp_parallel_blocks (gfc_code *code, gfc_namespace *ns)\n+{\n+  struct omp_context ctx;\n+  gfc_omp_clauses *omp_clauses = code->ext.omp_clauses;\n+  gfc_namelist *n;\n+  int list;\n+\n+  ctx.code = code;\n+  ctx.sharing_clauses = pointer_set_create ();\n+  ctx.private_iterators = pointer_set_create ();\n+  ctx.previous = omp_current_ctx;\n+  omp_current_ctx = &ctx;\n+\n+  for (list = 0; list < OMP_LIST_NUM; list++)\n+    for (n = omp_clauses->lists[list]; n; n = n->next)\n+      pointer_set_insert (ctx.sharing_clauses, n->sym);\n+\n+  if (code->op == EXEC_OMP_PARALLEL_DO)\n+    gfc_resolve_omp_do_blocks (code, ns);\n+  else\n+    gfc_resolve_blocks (code->block, ns);\n+\n+  omp_current_ctx = ctx.previous;\n+  pointer_set_destroy (ctx.sharing_clauses);\n+  pointer_set_destroy (ctx.private_iterators);\n+}\n+\n+/* Note a DO iterator variable.  This is special in !$omp parallel\n+   construct, where they are predetermined private.  */\n+\n+void\n+gfc_resolve_do_iterator (gfc_code *code, gfc_symbol *sym)\n+{\n+  struct omp_context *ctx;\n+\n+  if (sym->attr.threadprivate)\n+    return;\n+\n+  /* !$omp do and !$omp parallel do iteration variable is predetermined\n+     private just in the !$omp do resp. !$omp parallel do construct,\n+     with no implications for the outer parallel constructs.  */\n+  if (code == omp_current_do_code)\n+    return;\n+\n+  for (ctx = omp_current_ctx; ctx; ctx = ctx->previous)\n+    {\n+      if (pointer_set_contains (ctx->sharing_clauses, sym))\n+\tcontinue;\n+\n+      if (! pointer_set_insert (ctx->private_iterators, sym))\n+\t{\n+\t  gfc_omp_clauses *omp_clauses = ctx->code->ext.omp_clauses;\n+\t  gfc_namelist *p;\n+\n+\t  p = gfc_get_namelist ();\n+\t  p->sym = sym;\n+\t  p->next = omp_clauses->lists[OMP_LIST_PRIVATE];\n+\t  omp_clauses->lists[OMP_LIST_PRIVATE] = p;\n+\t}\n+    }\n+}\n+\n+static void\n+resolve_omp_do (gfc_code *code)\n+{\n+  gfc_code *do_code;\n+  int list;\n+  gfc_namelist *n;\n+  gfc_symbol *dovar;\n+\n+  if (code->ext.omp_clauses)\n+    resolve_omp_clauses (code);\n+\n+  do_code = code->block->next;\n+  if (do_code->op == EXEC_DO_WHILE)\n+    gfc_error (\"!$OMP DO cannot be a DO WHILE or DO without loop control at %L\",\n+\t       &do_code->loc);\n+  else\n+    {\n+      gcc_assert (do_code->op == EXEC_DO);\n+      if (do_code->ext.iterator->var->ts.type != BT_INTEGER)\n+\tgfc_error (\"!$OMP DO iteration variable must be of type integer at %L\",\n+\t\t   &do_code->loc);\n+      dovar = do_code->ext.iterator->var->symtree->n.sym;\n+      if (dovar->attr.threadprivate)\n+\tgfc_error (\"!$OMP DO iteration variable must not be THREADPRIVATE at %L\",\n+\t\t   &do_code->loc);\n+      if (code->ext.omp_clauses)\n+\tfor (list = 0; list < OMP_LIST_NUM; list++)\n+\t  if (list != OMP_LIST_PRIVATE && list != OMP_LIST_LASTPRIVATE)\n+\t    for (n = code->ext.omp_clauses->lists[list]; n; n = n->next)\n+\t      if (dovar == n->sym)\n+\t\t{\n+\t\t  gfc_error (\"!$OMP DO iteration variable present on clause\"\n+\t\t\t     \" other than PRIVATE or LASTPRIVATE at %L\",\n+\t\t\t     &do_code->loc);\n+\t\t  break;\n+\t\t}\n+    }\n+}\n+\n+/* Resolve OpenMP directive clauses and check various requirements\n+   of each directive.  */\n+\n+void\n+gfc_resolve_omp_directive (gfc_code *code, gfc_namespace *ns ATTRIBUTE_UNUSED)\n+{\n+  switch (code->op)\n+    {\n+    case EXEC_OMP_DO:\n+    case EXEC_OMP_PARALLEL_DO:\n+      resolve_omp_do (code);\n+      break;\n+    case EXEC_OMP_WORKSHARE:\n+    case EXEC_OMP_PARALLEL_WORKSHARE:\n+    case EXEC_OMP_PARALLEL:\n+    case EXEC_OMP_PARALLEL_SECTIONS:\n+    case EXEC_OMP_SECTIONS:\n+    case EXEC_OMP_SINGLE:\n+      if (code->ext.omp_clauses)\n+\tresolve_omp_clauses (code);\n+      break;\n+    case EXEC_OMP_ATOMIC:\n+      resolve_omp_atomic (code);\n+      break;\n+    default:\n+      break;\n+    }\n+}"}, {"sha": "bf1da85b8ba13a590ecdd34502f9fbbda541c616", "filename": "gcc/fortran/options.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ffortran%2Foptions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ffortran%2Foptions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Foptions.c?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -1,6 +1,6 @@\n /* Parse and display command line options.\n-   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation,\n-   Inc.\n+   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006\n+   Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n \n This file is part of GCC.\n@@ -77,6 +77,7 @@ gfc_init_options (unsigned int argc ATTRIBUTE_UNUSED,\n   gfc_option.flag_backslash = 1;\n   gfc_option.flag_cray_pointer = 0;\n   gfc_option.flag_d_lines = -1;\n+  gfc_option.flag_openmp = 0;\n \n   gfc_option.q_kind = gfc_default_double_kind;\n \n@@ -456,6 +457,10 @@ gfc_handle_option (size_t scode, const char *arg, int value)\n       gfc_option.source_form = FORM_FREE;\n       break;\n \n+    case OPT_fopenmp:\n+      gfc_option.flag_openmp = value;\n+      break;\n+\n     case OPT_ffree_line_length_none:\n       gfc_option.free_line_length = 0;\n       break;"}, {"sha": "832848237e907b10721c0e5f0734616962207cd1", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 520, "deletions": 15, "changes": 535, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -300,6 +300,107 @@ decode_statement (void)\n   return ST_NONE;\n }\n \n+static gfc_statement\n+decode_omp_directive (void)\n+{\n+  locus old_locus;\n+  int c;\n+\n+#ifdef GFC_DEBUG\n+  gfc_symbol_state ();\n+#endif\n+\n+  gfc_clear_error ();\t/* Clear any pending errors.  */\n+  gfc_clear_warning ();\t/* Clear any pending warnings.  */\n+\n+  if (gfc_pure (NULL))\n+    {\n+      gfc_error_now (\"OpenMP directives at %C may not appear in PURE or ELEMENTAL procedures\");\n+      gfc_error_recovery ();\n+      return ST_NONE;\n+    }\n+\n+  old_locus = gfc_current_locus;\n+\n+  /* General OpenMP directive matching: Instead of testing every possible\n+     statement, we eliminate most possibilities by peeking at the\n+     first character.  */\n+\n+  c = gfc_peek_char ();\n+\n+  switch (c)\n+    {\n+    case 'a':\n+      match (\"atomic\", gfc_match_omp_atomic, ST_OMP_ATOMIC);\n+      break;\n+    case 'b':\n+      match (\"barrier\", gfc_match_omp_barrier, ST_OMP_BARRIER);\n+      break;\n+    case 'c':\n+      match (\"critical\", gfc_match_omp_critical, ST_OMP_CRITICAL);\n+      break;\n+    case 'd':\n+      match (\"do\", gfc_match_omp_do, ST_OMP_DO);\n+      break;\n+    case 'e':\n+      match (\"end critical\", gfc_match_omp_critical, ST_OMP_END_CRITICAL);\n+      match (\"end do\", gfc_match_omp_end_nowait, ST_OMP_END_DO);\n+      match (\"end master\", gfc_match_omp_eos, ST_OMP_END_MASTER);\n+      match (\"end ordered\", gfc_match_omp_eos, ST_OMP_END_ORDERED);\n+      match (\"end parallel do\", gfc_match_omp_eos, ST_OMP_END_PARALLEL_DO);\n+      match (\"end parallel sections\", gfc_match_omp_eos,\n+\t     ST_OMP_END_PARALLEL_SECTIONS);\n+      match (\"end parallel workshare\", gfc_match_omp_eos,\n+\t     ST_OMP_END_PARALLEL_WORKSHARE);\n+      match (\"end parallel\", gfc_match_omp_eos, ST_OMP_END_PARALLEL);\n+      match (\"end sections\", gfc_match_omp_end_nowait, ST_OMP_END_SECTIONS);\n+      match (\"end single\", gfc_match_omp_end_single, ST_OMP_END_SINGLE);\n+      match (\"end workshare\", gfc_match_omp_end_nowait,\n+\t     ST_OMP_END_WORKSHARE);\n+      break;\n+    case 'f':\n+      match (\"flush\", gfc_match_omp_flush, ST_OMP_FLUSH);\n+      break;\n+    case 'm':\n+      match (\"master\", gfc_match_omp_master, ST_OMP_MASTER);\n+      break;\n+    case 'o':\n+      match (\"ordered\", gfc_match_omp_ordered, ST_OMP_ORDERED);\n+      break;\n+    case 'p':\n+      match (\"parallel do\", gfc_match_omp_parallel_do, ST_OMP_PARALLEL_DO);\n+      match (\"parallel sections\", gfc_match_omp_parallel_sections,\n+\t     ST_OMP_PARALLEL_SECTIONS);\n+      match (\"parallel workshare\", gfc_match_omp_parallel_workshare,\n+\t     ST_OMP_PARALLEL_WORKSHARE);\n+      match (\"parallel\", gfc_match_omp_parallel, ST_OMP_PARALLEL);\n+      break;\n+    case 's':\n+      match (\"sections\", gfc_match_omp_sections, ST_OMP_SECTIONS);\n+      match (\"section\", gfc_match_omp_eos, ST_OMP_SECTION);\n+      match (\"single\", gfc_match_omp_single, ST_OMP_SINGLE);\n+      break;\n+    case 't':\n+      match (\"threadprivate\", gfc_match_omp_threadprivate,\n+\t     ST_OMP_THREADPRIVATE);\n+    case 'w':\n+      match (\"workshare\", gfc_match_omp_workshare, ST_OMP_WORKSHARE);\n+      break;\n+    }\n+\n+  /* All else has failed, so give up.  See if any of the matchers has\n+     stored an error message of some sort.  */\n+\n+  if (gfc_error_check () == 0)\n+    gfc_error_now (\"Unclassifiable OpenMP directive at %C\");\n+\n+  reject_statement ();\n+\n+  gfc_error_recovery ();\n+\n+  return ST_NONE;\n+}\n+\n #undef match\n \n \n@@ -355,6 +456,22 @@ next_free (void)\n \t    }\n \t}\n     }\n+  else if (c == '!')\n+    {\n+      /* Comments have already been skipped by the time we get here,\n+\t except for OpenMP directives.  */\n+      if (gfc_option.flag_openmp)\n+\t{\n+\t  int i;\n+\n+\t  c = gfc_next_char ();\n+\t  for (i = 0; i < 5; i++, c = gfc_next_char ())\n+\t    gcc_assert (c == \"!$omp\"[i]);\n+\n+\t  gcc_assert (c == ' ');\n+\t  return decode_omp_directive ();\n+\t}\n+    }\n \n   return decode_statement ();\n }\n@@ -405,7 +522,26 @@ next_fixed (void)\n \t  digit_flag = 1;\n \t  break;\n \n-          /* Comments have already been skipped by the time we get\n+\t  /* Comments have already been skipped by the time we get\n+\t     here, except for OpenMP directives.  */\n+\tcase '*':\n+\t  if (gfc_option.flag_openmp)\n+\t    {\n+\t      for (i = 0; i < 5; i++, c = gfc_next_char_literal (0))\n+\t\tgcc_assert (TOLOWER (c) == \"*$omp\"[i]);\n+\n+\t      if (c != ' ' && c != '0')\n+\t\t{\n+\t\t  gfc_buffer_error (0);\n+\t\t  gfc_error (\"Bad continuation line at %C\");\n+\t\t  return ST_NONE;\n+\t\t}\n+\n+\t      return decode_omp_directive ();\n+\t    }\n+\t  /* FALLTHROUGH */\n+\n+\t  /* Comments have already been skipped by the time we get\n \t     here so don't bother checking for them.  */\n \n \tdefault:\n@@ -534,18 +670,23 @@ next_statement (void)\n   case ST_PAUSE: case ST_STOP: case ST_WRITE: case ST_ASSIGNMENT: \\\n   case ST_POINTER_ASSIGNMENT: case ST_EXIT: case ST_CYCLE: \\\n   case ST_ARITHMETIC_IF: case ST_WHERE: case ST_FORALL: \\\n-  case ST_LABEL_ASSIGNMENT: case ST_FLUSH\n+  case ST_LABEL_ASSIGNMENT: case ST_FLUSH: case ST_OMP_FLUSH: \\\n+  case ST_OMP_BARRIER\n \n /* Statements that mark other executable statements.  */\n \n #define case_exec_markers case ST_DO: case ST_FORALL_BLOCK: case ST_IF_BLOCK: \\\n-  case ST_WHERE_BLOCK: case ST_SELECT_CASE\n+  case ST_WHERE_BLOCK: case ST_SELECT_CASE: case ST_OMP_PARALLEL: \\\n+  case ST_OMP_PARALLEL_SECTIONS: case ST_OMP_SECTIONS: case ST_OMP_ORDERED: \\\n+  case ST_OMP_CRITICAL: case ST_OMP_MASTER: case ST_OMP_SINGLE: \\\n+  case ST_OMP_DO: case ST_OMP_PARALLEL_DO: case ST_OMP_ATOMIC: \\\n+  case ST_OMP_WORKSHARE: case ST_OMP_PARALLEL_WORKSHARE\n \n /* Declaration statements */\n \n #define case_decl case ST_ATTR_DECL: case ST_COMMON: case ST_DATA_DECL: \\\n   case ST_EQUIVALENCE: case ST_NAMELIST: case ST_STATEMENT_FUNCTION: \\\n-  case ST_TYPE: case ST_INTERFACE\n+  case ST_TYPE: case ST_INTERFACE: case ST_OMP_THREADPRIVATE\n \n /* Block end statements.  Errors associated with interchanging these\n    are detected in gfc_match_end().  */\n@@ -963,6 +1104,87 @@ gfc_ascii_statement (gfc_statement st)\n     case ST_END_ENUM:\n       p = \"END ENUM\";\n       break;\n+    case ST_OMP_ATOMIC:\n+      p = \"!$OMP ATOMIC\";\n+      break;\n+    case ST_OMP_BARRIER:\n+      p = \"!$OMP BARRIER\";\n+      break;\n+    case ST_OMP_CRITICAL:\n+      p = \"!$OMP CRITICAL\";\n+      break;\n+    case ST_OMP_DO:\n+      p = \"!$OMP DO\";\n+      break;\n+    case ST_OMP_END_CRITICAL:\n+      p = \"!$OMP END CRITICAL\";\n+      break;\n+    case ST_OMP_END_DO:\n+      p = \"!$OMP END DO\";\n+      break;\n+    case ST_OMP_END_MASTER:\n+      p = \"!$OMP END MASTER\";\n+      break;\n+    case ST_OMP_END_ORDERED:\n+      p = \"!$OMP END ORDERED\";\n+      break;\n+    case ST_OMP_END_PARALLEL:\n+      p = \"!$OMP END PARALLEL\";\n+      break;\n+    case ST_OMP_END_PARALLEL_DO:\n+      p = \"!$OMP END PARALLEL DO\";\n+      break;\n+    case ST_OMP_END_PARALLEL_SECTIONS:\n+      p = \"!$OMP END PARALLEL SECTIONS\";\n+      break;\n+    case ST_OMP_END_PARALLEL_WORKSHARE:\n+      p = \"!$OMP END PARALLEL WORKSHARE\";\n+      break;\n+    case ST_OMP_END_SECTIONS:\n+      p = \"!$OMP END SECTIONS\";\n+      break;\n+    case ST_OMP_END_SINGLE:\n+      p = \"!$OMP END SINGLE\";\n+      break;\n+    case ST_OMP_END_WORKSHARE:\n+      p = \"!$OMP END WORKSHARE\";\n+      break;\n+    case ST_OMP_FLUSH:\n+      p = \"!$OMP FLUSH\";\n+      break;\n+    case ST_OMP_MASTER:\n+      p = \"!$OMP MASTER\";\n+      break;\n+    case ST_OMP_ORDERED:\n+      p = \"!$OMP ORDERED\";\n+      break;\n+    case ST_OMP_PARALLEL:\n+      p = \"!$OMP PARALLEL\";\n+      break;\n+    case ST_OMP_PARALLEL_DO:\n+      p = \"!$OMP PARALLEL DO\";\n+      break;\n+    case ST_OMP_PARALLEL_SECTIONS:\n+      p = \"!$OMP PARALLEL SECTIONS\";\n+      break;\n+    case ST_OMP_PARALLEL_WORKSHARE:\n+      p = \"!$OMP PARALLEL WORKSHARE\";\n+      break;\n+    case ST_OMP_SECTIONS:\n+      p = \"!$OMP SECTIONS\";\n+      break;\n+    case ST_OMP_SECTION:\n+      p = \"!$OMP SECTION\";\n+      break;\n+    case ST_OMP_SINGLE:\n+      p = \"!$OMP SINGLE\";\n+      break;\n+    case ST_OMP_THREADPRIVATE:\n+      p = \"!$OMP THREADPRIVATE\";\n+      break;\n+    case ST_OMP_WORKSHARE:\n+      p = \"!$OMP WORKSHARE\";\n+      break;\n     default:\n       gfc_internal_error (\"gfc_ascii_statement(): Bad statement code\");\n     }\n@@ -2070,6 +2292,266 @@ parse_do_block (void)\n }\n \n \n+/* Parse the statements of OpenMP do/parallel do.  */\n+\n+static gfc_statement\n+parse_omp_do (gfc_statement omp_st)\n+{\n+  gfc_statement st;\n+  gfc_code *cp, *np;\n+  gfc_state_data s;\n+\n+  accept_statement (omp_st);\n+\n+  cp = gfc_state_stack->tail;\n+  push_state (&s, COMP_OMP_STRUCTURED_BLOCK, NULL);\n+  np = new_level (cp);\n+  np->op = cp->op;\n+  np->block = NULL;\n+\n+  for (;;)\n+    {\n+      st = next_statement ();\n+      if (st == ST_NONE)\n+\tunexpected_eof ();\n+      else if (st == ST_DO)\n+\tbreak;\n+      else\n+\tunexpected_statement (st);\n+    }\n+\n+  parse_do_block ();\n+  if (gfc_statement_label != NULL\n+      && gfc_state_stack->previous != NULL\n+      && gfc_state_stack->previous->state == COMP_DO\n+      && gfc_state_stack->previous->ext.end_do_label == gfc_statement_label)\n+    {\n+      /* In\n+         DO 100 I=1,10\n+           !$OMP DO\n+             DO J=1,10\n+             ...\n+             100 CONTINUE\n+         there should be no !$OMP END DO.  */\n+      pop_state ();\n+      return ST_IMPLIED_ENDDO;\n+    }\n+\n+  check_do_closure ();\n+  pop_state ();\n+\n+  st = next_statement ();\n+  if (st == (omp_st == ST_OMP_DO ? ST_OMP_END_DO : ST_OMP_END_PARALLEL_DO))\n+    {\n+      if (new_st.op == EXEC_OMP_END_NOWAIT)\n+\tcp->ext.omp_clauses->nowait |= new_st.ext.omp_bool;\n+      else\n+\tgcc_assert (new_st.op == EXEC_NOP);\n+      gfc_clear_new_st ();\n+      st = next_statement ();\n+    }\n+  return st;\n+}\n+\n+\n+/* Parse the statements of OpenMP atomic directive.  */\n+\n+static void\n+parse_omp_atomic (void)\n+{\n+  gfc_statement st;\n+  gfc_code *cp, *np;\n+  gfc_state_data s;\n+\n+  accept_statement (ST_OMP_ATOMIC);\n+\n+  cp = gfc_state_stack->tail;\n+  push_state (&s, COMP_OMP_STRUCTURED_BLOCK, NULL);\n+  np = new_level (cp);\n+  np->op = cp->op;\n+  np->block = NULL;\n+\n+  for (;;)\n+    {\n+      st = next_statement ();\n+      if (st == ST_NONE)\n+\tunexpected_eof ();\n+      else if (st == ST_ASSIGNMENT)\n+\tbreak;\n+      else\n+\tunexpected_statement (st);\n+    }\n+\n+  accept_statement (st);\n+\n+  pop_state ();\n+}\n+\n+\n+/* Parse the statements of an OpenMP structured block.  */\n+\n+static void\n+parse_omp_structured_block (gfc_statement omp_st, bool workshare_stmts_only)\n+{\n+  gfc_statement st, omp_end_st;\n+  gfc_code *cp, *np;\n+  gfc_state_data s;\n+\n+  accept_statement (omp_st);\n+\n+  cp = gfc_state_stack->tail;\n+  push_state (&s, COMP_OMP_STRUCTURED_BLOCK, NULL);\n+  np = new_level (cp);\n+  np->op = cp->op;\n+  np->block = NULL;\n+\n+  switch (omp_st)\n+    {\n+    case ST_OMP_PARALLEL:\n+      omp_end_st = ST_OMP_END_PARALLEL;\n+      break;\n+    case ST_OMP_PARALLEL_SECTIONS:\n+      omp_end_st = ST_OMP_END_PARALLEL_SECTIONS;\n+      break;\n+    case ST_OMP_SECTIONS:\n+      omp_end_st = ST_OMP_END_SECTIONS;\n+      break;\n+    case ST_OMP_ORDERED:\n+      omp_end_st = ST_OMP_END_ORDERED;\n+      break;\n+    case ST_OMP_CRITICAL:\n+      omp_end_st = ST_OMP_END_CRITICAL;\n+      break;\n+    case ST_OMP_MASTER:\n+      omp_end_st = ST_OMP_END_MASTER;\n+      break;\n+    case ST_OMP_SINGLE:\n+      omp_end_st = ST_OMP_END_SINGLE;\n+      break;\n+    case ST_OMP_WORKSHARE:\n+      omp_end_st = ST_OMP_END_WORKSHARE;\n+      break;\n+    case ST_OMP_PARALLEL_WORKSHARE:\n+      omp_end_st = ST_OMP_END_PARALLEL_WORKSHARE;\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  do\n+    {\n+      if (workshare_stmts_only)\n+\t{\n+\t  /* Inside of !$omp workshare, only\n+\t     scalar assignments\n+\t     array assignments\n+\t     where statements and constructs\n+\t     forall statements and constructs\n+\t     !$omp atomic\n+\t     !$omp critical\n+\t     !$omp parallel\n+\t     are allowed.  For !$omp critical these\n+\t     restrictions apply recursively.  */\n+\t  bool cycle = true;\n+\n+\t  st = next_statement ();\n+\t  for (;;)\n+\t    {\n+\t      switch (st)\n+\t\t{\n+\t\tcase ST_NONE:\n+\t\t  unexpected_eof ();\n+\n+\t\tcase ST_ASSIGNMENT:\n+\t\tcase ST_WHERE:\n+\t\tcase ST_FORALL:\n+\t\t  accept_statement (st);\n+\t\t  break;\n+\n+\t\tcase ST_WHERE_BLOCK:\n+\t\t  parse_where_block ();\n+\t\t  break;\n+\n+\t\tcase ST_FORALL_BLOCK:\n+\t\t  parse_forall_block ();\n+\t\t  break;\n+\n+\t\tcase ST_OMP_PARALLEL:\n+\t\tcase ST_OMP_PARALLEL_SECTIONS:\n+\t\t  parse_omp_structured_block (st, false);\n+\t\t  break;\n+\n+\t\tcase ST_OMP_PARALLEL_WORKSHARE:\n+\t\tcase ST_OMP_CRITICAL:\n+\t\t  parse_omp_structured_block (st, true);\n+\t\t  break;\n+\n+\t\tcase ST_OMP_PARALLEL_DO:\n+\t\t  st = parse_omp_do (st);\n+\t\t  continue;\n+\n+\t\tcase ST_OMP_ATOMIC:\n+\t\t  parse_omp_atomic ();\n+\t\t  break;\n+\n+\t\tdefault:\n+\t\t  cycle = false;\n+\t\t  break;\n+\t\t}\n+\n+\t      if (!cycle)\n+\t\tbreak;\n+\n+\t      st = next_statement ();\n+\t    }\n+\t}\n+      else\n+\tst = parse_executable (ST_NONE);\n+      if (st == ST_NONE)\n+\tunexpected_eof ();\n+      else if (st == ST_OMP_SECTION\n+\t       && (omp_st == ST_OMP_SECTIONS\n+\t\t   || omp_st == ST_OMP_PARALLEL_SECTIONS))\n+\t{\n+\t  np = new_level (np);\n+\t  np->op = cp->op;\n+\t  np->block = NULL;\n+\t}\n+      else if (st != omp_end_st)\n+\tunexpected_statement (st);\n+    }\n+  while (st != omp_end_st);\n+\n+  switch (new_st.op)\n+    {\n+    case EXEC_OMP_END_NOWAIT:\n+      cp->ext.omp_clauses->nowait |= new_st.ext.omp_bool;\n+      break;\n+    case EXEC_OMP_CRITICAL:\n+      if (((cp->ext.omp_name == NULL) ^ (new_st.ext.omp_name == NULL))\n+\t  || (new_st.ext.omp_name != NULL\n+\t      && strcmp (cp->ext.omp_name, new_st.ext.omp_name) != 0))\n+\tgfc_error (\"Name after !$omp critical and !$omp end critical does\"\n+\t\t   \" not match at %C\");\n+      gfc_free ((char *) new_st.ext.omp_name);\n+      break;\n+    case EXEC_OMP_END_SINGLE:\n+      cp->ext.omp_clauses->lists[OMP_LIST_COPYPRIVATE]\n+\t= new_st.ext.omp_clauses->lists[OMP_LIST_COPYPRIVATE];\n+      new_st.ext.omp_clauses->lists[OMP_LIST_COPYPRIVATE] = NULL;\n+      gfc_free_omp_clauses (new_st.ext.omp_clauses);\n+      break;\n+    case EXEC_NOP:\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  gfc_clear_new_st ();\n+  pop_state ();\n+}\n+\n+\n /* Accept a series of executable statements.  We return the first\n    statement that doesn't fit to the caller.  Any block statements are\n    passed on to the correct handler, which usually passes the buck\n@@ -2083,9 +2565,8 @@ parse_executable (gfc_statement st)\n   if (st == ST_NONE)\n     st = next_statement ();\n \n-  for (;; st = next_statement ())\n+  for (;;)\n     {\n-\n       close_flag = check_do_closure ();\n       if (close_flag)\n \tswitch (st)\n@@ -2125,38 +2606,62 @@ parse_executable (gfc_statement st)\n \t  accept_statement (st);\n \t  if (close_flag == 1)\n \t    return ST_IMPLIED_ENDDO;\n-\t  continue;\n+\t  break;\n \n \tcase ST_IF_BLOCK:\n \t  parse_if_block ();\n-\t  continue;\n+\t  break;\n \n \tcase ST_SELECT_CASE:\n \t  parse_select_block ();\n-\t  continue;\n+\t  break;\n \n \tcase ST_DO:\n \t  parse_do_block ();\n \t  if (check_do_closure () == 1)\n \t    return ST_IMPLIED_ENDDO;\n-\t  continue;\n+\t  break;\n \n \tcase ST_WHERE_BLOCK:\n \t  parse_where_block ();\n-\t  continue;\n+\t  break;\n \n \tcase ST_FORALL_BLOCK:\n \t  parse_forall_block ();\n+\t  break;\n+\n+\tcase ST_OMP_PARALLEL:\n+\tcase ST_OMP_PARALLEL_SECTIONS:\n+\tcase ST_OMP_SECTIONS:\n+\tcase ST_OMP_ORDERED:\n+\tcase ST_OMP_CRITICAL:\n+\tcase ST_OMP_MASTER:\n+\tcase ST_OMP_SINGLE:\n+\t  parse_omp_structured_block (st, false);\n+\t  break;\n+\n+\tcase ST_OMP_WORKSHARE:\n+\tcase ST_OMP_PARALLEL_WORKSHARE:\n+\t  parse_omp_structured_block (st, true);\n+\t  break;\n+\n+\tcase ST_OMP_DO:\n+\tcase ST_OMP_PARALLEL_DO:\n+\t  st = parse_omp_do (st);\n+\t  if (st == ST_IMPLIED_ENDDO)\n+\t    return st;\n \t  continue;\n \n-\tdefault:\n+\tcase ST_OMP_ATOMIC:\n+\t  parse_omp_atomic ();\n \t  break;\n+\n+\tdefault:\n+\t  return st;\n \t}\n \n-      break;\n+      st = next_statement ();\n     }\n-\n-  return st;\n }\n \n "}, {"sha": "f3b12e17b0ae198e6d3cbd400cf915394f10a642", "filename": "gcc/fortran/parse.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ffortran%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ffortran%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.h?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -1,5 +1,5 @@\n /* Parser header\n-   Copyright (C) 2003 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2005, 2006 Free Software Foundation, Inc.\n    Contributed by Steven Bosscher\n \n This file is part of GCC.\n@@ -30,7 +30,8 @@ typedef enum\n {\n   COMP_NONE, COMP_PROGRAM, COMP_MODULE, COMP_SUBROUTINE, COMP_FUNCTION,\n   COMP_BLOCK_DATA, COMP_INTERFACE, COMP_DERIVED, COMP_IF, COMP_DO,\n-  COMP_SELECT, COMP_FORALL, COMP_WHERE, COMP_CONTAINS, COMP_ENUM\n+  COMP_SELECT, COMP_FORALL, COMP_WHERE, COMP_CONTAINS, COMP_ENUM,\n+  COMP_OMP_STRUCTURED_BLOCK\n }\n gfc_compile_state;\n "}, {"sha": "61983d153a0857550f4e1ca88ab548e23ba58cdf", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 105, "deletions": 16, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -48,10 +48,14 @@ code_stack;\n static code_stack *cs_base = NULL;\n \n \n-/* Nonzero if we're inside a FORALL block */\n+/* Nonzero if we're inside a FORALL block.  */\n \n static int forall_flag;\n \n+/* Nonzero if we're inside a OpenMP WORKSHARE or PARALLEL WORKSHARE block.  */\n+\n+static int omp_workshare_flag;\n+\n /* Nonzero if we are processing a formal arglist. The corresponding function\n    resets the flag each time that it is read.  */\n static int formal_arg_flag = 0;\n@@ -1314,6 +1318,15 @@ resolve_function (gfc_expr * expr)\n \t    return FAILURE;\n \t}\n     }\n+  if (omp_workshare_flag\n+      && expr->value.function.esym\n+      && ! gfc_elemental (expr->value.function.esym))\n+    {\n+      gfc_error (\"User defined non-ELEMENTAL function '%s' at %L not allowed\"\n+\t\t \" in WORKSHARE construct\", expr->value.function.esym->name,\n+\t\t &expr->where);\n+      t = FAILURE;\n+    }\n \n   else if (expr->value.function.actual != NULL\n \t     && expr->value.function.isym != NULL\n@@ -4036,7 +4049,7 @@ gfc_resolve_forall_body (gfc_code *code, int nvar, gfc_expr **var_expr)\n           gfc_resolve_assign_in_forall (c, nvar, var_expr);\n           break;\n \n-        /* Because the resolve_blocks() will handle the nested FORALL,\n+        /* Because the gfc_resolve_blocks() will handle the nested FORALL,\n            there is no need to handle it here.  */\n         case EXEC_FORALL:\n           break;\n@@ -4055,8 +4068,6 @@ gfc_resolve_forall_body (gfc_code *code, int nvar, gfc_expr **var_expr)\n /* Given a FORALL construct, first resolve the FORALL iterator, then call\n    gfc_resolve_forall_body to resolve the FORALL body.  */\n \n-static void resolve_blocks (gfc_code *, gfc_namespace *);\n-\n static void\n gfc_resolve_forall (gfc_code *code, gfc_namespace *ns, int forall_save)\n {\n@@ -4122,7 +4133,7 @@ gfc_resolve_forall (gfc_code *code, gfc_namespace *ns, int forall_save)\n   gfc_resolve_forall_body (code, nvar, var_expr);\n \n   /* May call gfc_resolve_forall to resolve the inner FORALL loop.  */\n-  resolve_blocks (code->block, ns);\n+  gfc_resolve_blocks (code->block, ns);\n \n   /* Free VAR_EXPR after the whole FORALL construct resolved.  */\n   for (i = 0; i < total_var; i++)\n@@ -4139,8 +4150,8 @@ gfc_resolve_forall (gfc_code *code, gfc_namespace *ns, int forall_save)\n \n static void resolve_code (gfc_code *, gfc_namespace *);\n \n-static void\n-resolve_blocks (gfc_code * b, gfc_namespace * ns)\n+void\n+gfc_resolve_blocks (gfc_code * b, gfc_namespace * ns)\n {\n   try t;\n \n@@ -4183,6 +4194,20 @@ resolve_blocks (gfc_code * b, gfc_namespace * ns)\n \tcase EXEC_IOLENGTH:\n \t  break;\n \n+\tcase EXEC_OMP_ATOMIC:\n+\tcase EXEC_OMP_CRITICAL:\n+\tcase EXEC_OMP_DO:\n+\tcase EXEC_OMP_MASTER:\n+\tcase EXEC_OMP_ORDERED:\n+\tcase EXEC_OMP_PARALLEL:\n+\tcase EXEC_OMP_PARALLEL_DO:\n+\tcase EXEC_OMP_PARALLEL_SECTIONS:\n+\tcase EXEC_OMP_PARALLEL_WORKSHARE:\n+\tcase EXEC_OMP_SECTIONS:\n+\tcase EXEC_OMP_SINGLE:\n+\tcase EXEC_OMP_WORKSHARE:\n+\t  break;\n+\n \tdefault:\n \t  gfc_internal_error (\"resolve_block(): Bad block type\");\n \t}\n@@ -4198,7 +4223,7 @@ resolve_blocks (gfc_code * b, gfc_namespace * ns)\n static void\n resolve_code (gfc_code * code, gfc_namespace * ns)\n {\n-  int forall_save = 0;\n+  int omp_workshare_save;\n   code_stack frame;\n   gfc_alloc *a;\n   try t;\n@@ -4213,15 +4238,44 @@ resolve_code (gfc_code * code, gfc_namespace * ns)\n \n       if (code->op == EXEC_FORALL)\n \t{\n-\t  forall_save = forall_flag;\n+\t  int forall_save = forall_flag;\n+\n \t  forall_flag = 1;\n-          gfc_resolve_forall (code, ns, forall_save);\n-        }\n-      else\n-        resolve_blocks (code->block, ns);\n+\t  gfc_resolve_forall (code, ns, forall_save);\n+\t  forall_flag = forall_save;\n+\t}\n+      else if (code->block)\n+\t{\n+\t  omp_workshare_save = -1;\n+\t  switch (code->op)\n+\t    {\n+\t    case EXEC_OMP_PARALLEL_WORKSHARE:\n+\t      omp_workshare_save = omp_workshare_flag;\n+\t      omp_workshare_flag = 1;\n+\t      gfc_resolve_omp_parallel_blocks (code, ns);\n+\t      break;\n+\t    case EXEC_OMP_PARALLEL:\n+\t    case EXEC_OMP_PARALLEL_DO:\n+\t    case EXEC_OMP_PARALLEL_SECTIONS:\n+\t      omp_workshare_save = omp_workshare_flag;\n+\t      omp_workshare_flag = 0;\n+\t      gfc_resolve_omp_parallel_blocks (code, ns);\n+\t      break;\n+\t    case EXEC_OMP_DO:\n+\t      gfc_resolve_omp_do_blocks (code, ns);\n+\t      break;\n+\t    case EXEC_OMP_WORKSHARE:\n+\t      omp_workshare_save = omp_workshare_flag;\n+\t      omp_workshare_flag = 1;\n+\t      /* FALLTHROUGH */\n+\t    default:\n+\t      gfc_resolve_blocks (code->block, ns);\n+\t      break;\n+\t    }\n \n-      if (code->op == EXEC_FORALL)\n-\tforall_flag = forall_save;\n+\t  if (omp_workshare_save != -1)\n+\t    omp_workshare_flag = omp_workshare_save;\n+\t}\n \n       t = gfc_resolve_expr (code->expr);\n       if (gfc_resolve_expr (code->expr2) == FAILURE)\n@@ -4358,7 +4412,11 @@ resolve_code (gfc_code * code, gfc_namespace * ns)\n \n \tcase EXEC_DO:\n \t  if (code->ext.iterator != NULL)\n-\t    gfc_resolve_iterator (code->ext.iterator, true);\n+\t    {\n+\t      gfc_iterator *iter = code->ext.iterator;\n+\t      if (gfc_resolve_iterator (iter, true) != FAILURE)\n+\t\tgfc_resolve_do_iterator (code, iter->var->symtree->n.sym);\n+\t    }\n \t  break;\n \n \tcase EXEC_DO_WHILE:\n@@ -4456,6 +4514,29 @@ resolve_code (gfc_code * code, gfc_namespace * ns)\n \t       &code->expr->where);\n \t  break;\n \n+\tcase EXEC_OMP_ATOMIC:\n+\tcase EXEC_OMP_BARRIER:\n+\tcase EXEC_OMP_CRITICAL:\n+\tcase EXEC_OMP_FLUSH:\n+\tcase EXEC_OMP_DO:\n+\tcase EXEC_OMP_MASTER:\n+\tcase EXEC_OMP_ORDERED:\n+\tcase EXEC_OMP_SECTIONS:\n+\tcase EXEC_OMP_SINGLE:\n+\tcase EXEC_OMP_WORKSHARE:\n+\t  gfc_resolve_omp_directive (code, ns);\n+\t  break;\n+\n+\tcase EXEC_OMP_PARALLEL:\n+\tcase EXEC_OMP_PARALLEL_DO:\n+\tcase EXEC_OMP_PARALLEL_SECTIONS:\n+\tcase EXEC_OMP_PARALLEL_WORKSHARE:\n+\t  omp_workshare_save = omp_workshare_flag;\n+\t  omp_workshare_flag = 0;\n+\t  gfc_resolve_omp_directive (code, ns);\n+\t  omp_workshare_flag = omp_workshare_save;\n+\t  break;\n+\n \tdefault:\n \t  gfc_internal_error (\"resolve_code(): Bad statement code\");\n \t}\n@@ -5133,6 +5214,14 @@ resolve_symbol (gfc_symbol * sym)\n       gfc_resolve (sym->formal_ns);\n       formal_ns_flag = formal_ns_save;\n     }\n+\n+  /* Check threadprivate restrictions.  */\n+  if (sym->attr.threadprivate && !sym->attr.save\n+      && (!sym->attr.in_common\n+          && sym->module == NULL\n+          && (sym->ns->proc_name == NULL\n+              || sym->ns->proc_name->attr.flavor != FL_MODULE)))\n+    gfc_error (\"Threadprivate at %L isn't SAVEd\", &sym->declared_at);\n }\n \n "}, {"sha": "2aadc1cc68ef695665b8b981b95d4afd892d64d7", "filename": "gcc/fortran/scanner.c", "status": "modified", "additions": 186, "deletions": 23, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ffortran%2Fscanner.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ffortran%2Fscanner.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fscanner.c?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -1,5 +1,5 @@\n /* Character scanner.\n-   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005\n+   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006\n    Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n \n@@ -60,7 +60,8 @@ static gfc_directorylist *include_dirs;\n \n static gfc_file *file_head, *current_file;\n \n-static int continue_flag, end_flag;\n+static int continue_flag, end_flag, openmp_flag;\n+static locus openmp_locus;\n \n gfc_source_form gfc_current_form;\n static gfc_linebuf *line_head, *line_tail;\n@@ -328,17 +329,17 @@ skip_free_comments (void)\n {\n   locus start;\n   char c;\n+  int at_bol;\n \n   for (;;)\n     {\n+      at_bol = gfc_at_bol ();\n       start = gfc_current_locus;\n       if (gfc_at_eof ())\n \tbreak;\n \n       do\n-\t{\n-\t  c = next_char ();\n-\t}\n+\tc = next_char ();\n       while (gfc_is_whitespace (c));\n \n       if (c == '\\n')\n@@ -349,13 +350,55 @@ skip_free_comments (void)\n \n       if (c == '!')\n \t{\n+\t  /* If -fopenmp, we need to handle here 2 things:\n+\t     1) don't treat !$omp as comments, but directives\n+\t     2) handle OpenMP conditional compilation, where\n+\t\t!$ should be treated as 2 spaces (for initial lines\n+\t\tonly if followed by space).  */\n+\t  if (gfc_option.flag_openmp && at_bol)\n+\t    {\n+\t      locus old_loc = gfc_current_locus;\n+\t      if (next_char () == '$')\n+\t\t{\n+\t\t  c = next_char ();\n+\t\t  if (c == 'o' || c == 'O')\n+\t\t    {\n+\t\t      if (((c = next_char ()) == 'm' || c == 'M')\n+\t\t\t  && ((c = next_char ()) == 'p' || c == 'P')\n+\t\t\t  && ((c = next_char ()) == ' ' || continue_flag))\n+\t\t\t{\n+\t\t\t  while (gfc_is_whitespace (c))\n+\t\t\t    c = next_char ();\n+\t\t\t  if (c != '\\n' && c != '!')\n+\t\t\t    {\n+\t\t\t      openmp_flag = 1;\n+\t\t\t      openmp_locus = old_loc;\n+\t\t\t      gfc_current_locus = start;\n+\t\t\t      return;\n+\t\t\t    }\n+\t\t\t}\n+\t\t      gfc_current_locus = old_loc;\n+\t\t      next_char ();\n+\t\t      c = next_char ();\n+\t\t    }\n+\t\t  if (continue_flag || c == ' ')\n+\t\t    {\n+\t\t      gfc_current_locus = old_loc;\n+\t\t      next_char ();\n+\t\t      return;\n+\t\t    }\n+\t\t}\n+\t      gfc_current_locus = old_loc;\n+\t    }\n \t  skip_comment_line ();\n \t  continue;\n \t}\n \n       break;\n     }\n \n+  if (openmp_flag && at_bol)\n+    openmp_flag = 0;\n   gfc_current_locus = start;\n }\n \n@@ -372,6 +415,28 @@ skip_fixed_comments (void)\n   int col;\n   char c;\n \n+  if (! gfc_at_bol ())\n+    {\n+      start = gfc_current_locus;\n+      if (! gfc_at_eof ())\n+\t{\n+\t  do\n+\t    c = next_char ();\n+\t  while (gfc_is_whitespace (c));\n+\n+\t  if (c == '\\n')\n+\t    gfc_advance_line ();\n+\t  else if (c == '!')\n+\t    skip_comment_line ();\n+\t}\n+\n+      if (! gfc_at_bol ())\n+\t{\n+\t  gfc_current_locus = start;\n+\t  return;\n+\t}\n+    }\n+\n   for (;;)\n     {\n       start = gfc_current_locus;\n@@ -387,6 +452,66 @@ skip_fixed_comments (void)\n \n       if (c == '!' || c == 'c' || c == 'C' || c == '*')\n \t{\n+\t  /* If -fopenmp, we need to handle here 2 things:\n+\t     1) don't treat !$omp|c$omp|*$omp as comments, but directives\n+\t     2) handle OpenMP conditional compilation, where\n+\t\t!$|c$|*$ should be treated as 2 spaces if the characters\n+\t\tin columns 3 to 6 are valid fixed form label columns\n+\t\tcharacters.  */\n+\t  if (gfc_option.flag_openmp)\n+\t    {\n+\t      if (next_char () == '$')\n+\t\t{\n+\t\t  c = next_char ();\n+\t\t  if (c == 'o' || c == 'O')\n+\t\t    {\n+\t\t      if (((c = next_char ()) == 'm' || c == 'M')\n+\t\t\t  && ((c = next_char ()) == 'p' || c == 'P'))\n+\t\t\t{\n+\t\t\t  c = next_char ();\n+\t\t\t  if (c != '\\n'\n+\t\t\t      && ((openmp_flag && continue_flag)\n+\t\t\t\t  || c == ' ' || c == '0'))\n+\t\t\t    {\n+\t\t\t      c = next_char ();\n+\t\t\t      while (gfc_is_whitespace (c))\n+\t\t\t\tc = next_char ();\n+\t\t\t      if (c != '\\n' && c != '!')\n+\t\t\t\t{\n+\t\t\t\t  /* Canonicalize to *$omp.  */\n+\t\t\t\t  *start.nextc = '*';\n+\t\t\t\t  openmp_flag = 1;\n+\t\t\t\t  gfc_current_locus = start;\n+\t\t\t\t  return;\n+\t\t\t\t}\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      int digit_seen = 0;\n+\n+\t\t      for (col = 3; col < 6; col++, c = next_char ())\n+\t\t\tif (c == ' ')\n+\t\t\t  continue;\n+\t\t\telse if (c < '0' || c > '9')\n+\t\t\t  break;\n+\t\t\telse\n+\t\t\t  digit_seen = 1;\n+\n+\t\t      if (col == 6 && c != '\\n'\n+\t\t\t  && ((continue_flag && !digit_seen)\n+\t\t\t      || c == ' ' || c == '0'))\n+\t\t\t{\n+\t\t\t  gfc_current_locus = start;\n+\t\t\t  start.nextc[0] = ' ';\n+\t\t\t  start.nextc[1] = ' ';\n+\t\t\t  continue;\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t      gfc_current_locus = start;\n+\t    }\n \t  skip_comment_line ();\n \t  continue;\n \t}\n@@ -425,18 +550,17 @@ skip_fixed_comments (void)\n       break;\n     }\n \n+  openmp_flag = 0;\n   gfc_current_locus = start;\n }\n \n \n-/* Skips the current line if it is a comment.  Assumes that we are at\n-   the start of the current line.  */\n+/* Skips the current line if it is a comment.  */\n \n void\n gfc_skip_comments (void)\n {\n-\n-  if (!gfc_at_bol () || gfc_current_form == FORM_FREE)\n+  if (gfc_current_form == FORM_FREE)\n     skip_free_comments ();\n   else\n     skip_fixed_comments ();\n@@ -454,7 +578,7 @@ int\n gfc_next_char_literal (int in_string)\n {\n   locus old_loc;\n-  int i, c;\n+  int i, c, prev_openmp_flag;\n \n   continue_flag = 0;\n \n@@ -465,9 +589,13 @@ gfc_next_char_literal (int in_string)\n \n   if (gfc_current_form == FORM_FREE)\n     {\n-\n       if (!in_string && c == '!')\n \t{\n+\t  if (openmp_flag\n+\t      && memcmp (&gfc_current_locus, &openmp_locus,\n+\t\t sizeof (gfc_current_locus)) == 0)\n+\t    goto done;\n+\n \t  /* This line can't be continued */\n \t  do\n \t    {\n@@ -485,15 +613,15 @@ gfc_next_char_literal (int in_string)\n \tgoto done;\n \n       /* If the next nonblank character is a ! or \\n, we've got a\n-         continuation line.  */\n+\t continuation line.  */\n       old_loc = gfc_current_locus;\n \n       c = next_char ();\n       while (gfc_is_whitespace (c))\n \tc = next_char ();\n \n       /* Character constants to be continued cannot have commentary\n-         after the '&'.  */\n+\t after the '&'.  */\n \n       if (in_string && c != '\\n')\n \t{\n@@ -509,30 +637,50 @@ gfc_next_char_literal (int in_string)\n \t  goto done;\n \t}\n \n+      prev_openmp_flag = openmp_flag;\n       continue_flag = 1;\n       if (c == '!')\n \tskip_comment_line ();\n       else\n \tgfc_advance_line ();\n \n       /* We've got a continuation line and need to find where it continues.\n-         First eat any comment lines.  */\n+\t First eat any comment lines.  */\n       gfc_skip_comments ();\n \n+      if (prev_openmp_flag != openmp_flag)\n+\t{\n+\t  gfc_current_locus = old_loc;\n+\t  openmp_flag = prev_openmp_flag;\n+\t  c = '&';\n+\t  goto done;\n+\t}\n+\n       /* Now that we have a non-comment line, probe ahead for the\n-         first non-whitespace character.  If it is another '&', then\n-         reading starts at the next character, otherwise we must back\n-         up to where the whitespace started and resume from there.  */\n+\t first non-whitespace character.  If it is another '&', then\n+\t reading starts at the next character, otherwise we must back\n+\t up to where the whitespace started and resume from there.  */\n \n       old_loc = gfc_current_locus;\n \n       c = next_char ();\n       while (gfc_is_whitespace (c))\n \tc = next_char ();\n \n+      if (openmp_flag)\n+\t{\n+\t  for (i = 0; i < 5; i++, c = next_char ())\n+\t    {\n+\t      gcc_assert (TOLOWER (c) == \"!$omp\"[i]);\n+\t      if (i == 4)\n+\t\told_loc = gfc_current_locus;\n+\t    }\n+\t  while (gfc_is_whitespace (c))\n+\t    c = next_char ();\n+\t}\n+\n       if (c != '&')\n \tgfc_current_locus = old_loc;\n-\n     }\n   else\n     {\n@@ -553,22 +701,37 @@ gfc_next_char_literal (int in_string)\n       if (c != '\\n')\n \tgoto done;\n \n+      prev_openmp_flag = openmp_flag;\n       continue_flag = 1;\n       old_loc = gfc_current_locus;\n \n       gfc_advance_line ();\n       gfc_skip_comments ();\n \n       /* See if this line is a continuation line.  */\n-      for (i = 0; i < 5; i++)\n+      if (openmp_flag != prev_openmp_flag)\n \t{\n-\t  c = next_char ();\n-\t  if (c != ' ')\n-\t    goto not_continuation;\n+\t  openmp_flag = prev_openmp_flag;\n+\t  goto not_continuation;\n \t}\n \n+      if (!openmp_flag)\n+\tfor (i = 0; i < 5; i++)\n+\t  {\n+\t    c = next_char ();\n+\t    if (c != ' ')\n+\t      goto not_continuation;\n+\t  }\n+      else\n+\tfor (i = 0; i < 5; i++)\n+\t  {\n+\t    c = next_char ();\n+\t    if (TOLOWER (c) != \"*$omp\"[i])\n+\t      goto not_continuation;\n+\t  }\n+\n       c = next_char ();\n-      if (c == '0' || c == ' ')\n+      if (c == '0' || c == ' ' || c == '\\n')\n \tgoto not_continuation;\n     }\n "}, {"sha": "e7461a70c5d4d51c477a0accd5363264e8fbf19f", "filename": "gcc/fortran/st.c", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ffortran%2Fst.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ffortran%2Fst.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fst.c?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -1,5 +1,6 @@\n /* Build executable statement trees.\n-   Copyright (C) 2000, 2001, 2002, 2004, 2005 Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2001, 2002, 2004, 2005, 2006\n+   Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n \n This file is part of GCC.\n@@ -161,6 +162,33 @@ gfc_free_statement (gfc_code * p)\n       gfc_free_forall_iterator (p->ext.forall_iterator);\n       break;\n \n+    case EXEC_OMP_DO:\n+    case EXEC_OMP_END_SINGLE:\n+    case EXEC_OMP_PARALLEL:\n+    case EXEC_OMP_PARALLEL_DO:\n+    case EXEC_OMP_PARALLEL_SECTIONS:\n+    case EXEC_OMP_SECTIONS:\n+    case EXEC_OMP_SINGLE:\n+    case EXEC_OMP_WORKSHARE:\n+    case EXEC_OMP_PARALLEL_WORKSHARE:\n+      gfc_free_omp_clauses (p->ext.omp_clauses);\n+      break;\n+\n+    case EXEC_OMP_CRITICAL:\n+      gfc_free ((char *) p->ext.omp_name);\n+      break;\n+\n+    case EXEC_OMP_FLUSH:\n+      gfc_free_namelist (p->ext.omp_namelist);\n+      break;\n+\n+    case EXEC_OMP_ATOMIC:\n+    case EXEC_OMP_BARRIER:\n+    case EXEC_OMP_MASTER:\n+    case EXEC_OMP_ORDERED:\n+    case EXEC_OMP_END_NOWAIT:\n+      break;\n+\n     default:\n       gfc_internal_error (\"gfc_free_statement(): Bad statement\");\n     }"}, {"sha": "7fc7ef1b6f8b5e8d7b7e5a6b9900cff51efc8b34", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -265,6 +265,7 @@ check_conflict (symbol_attribute * attr, const char * name, locus * where)\n     *dimension = \"DIMENSION\", *in_equivalence = \"EQUIVALENCE\",\n     *use_assoc = \"USE ASSOCIATED\", *cray_pointer = \"CRAY POINTER\",\n     *cray_pointee = \"CRAY POINTEE\", *data = \"DATA\";\n+  static const char *threadprivate = \"THREADPRIVATE\";\n \n   const char *a1, *a2;\n \n@@ -308,6 +309,7 @@ check_conflict (symbol_attribute * attr, const char * name, locus * where)\n     }\n \n   conf (dummy, save);\n+  conf (dummy, threadprivate);\n   conf (pointer, target);\n   conf (pointer, external);\n   conf (pointer, intrinsic);\n@@ -347,6 +349,7 @@ check_conflict (symbol_attribute * attr, const char * name, locus * where)\n   conf (in_equivalence, result);\n   conf (in_equivalence, entry);\n   conf (in_equivalence, allocatable);\n+  conf (in_equivalence, threadprivate);\n \n   conf (in_namelist, pointer);\n   conf (in_namelist, allocatable);\n@@ -381,6 +384,7 @@ check_conflict (symbol_attribute * attr, const char * name, locus * where)\n   conf (cray_pointee, entry);\n   conf (cray_pointee, in_common);\n   conf (cray_pointee, in_equivalence);\n+  conf (cray_pointee, threadprivate);\n \n   conf (data, dummy);\n   conf (data, function);\n@@ -417,6 +421,7 @@ check_conflict (symbol_attribute * attr, const char * name, locus * where)\n       conf2 (optional);\n       conf2 (function);\n       conf2 (subroutine);\n+      conf2 (threadprivate);\n       break;\n \n     case FL_VARIABLE:\n@@ -435,6 +440,7 @@ check_conflict (symbol_attribute * attr, const char * name, locus * where)\n \t  conf2(result);\n \t  conf2(in_namelist);\n \t  conf2(function);\n+\t  conf2(threadprivate);\n \t}\n \n       switch (attr->proc)\n@@ -452,6 +458,7 @@ check_conflict (symbol_attribute * attr, const char * name, locus * where)\n \t  conf2 (result);\n \t  conf2 (in_common);\n \t  conf2 (save);\n+\t  conf2 (threadprivate);\n \t  break;\n \n \tdefault:\n@@ -472,6 +479,7 @@ check_conflict (symbol_attribute * attr, const char * name, locus * where)\n       conf2 (entry);\n       conf2 (function);\n       conf2 (subroutine);\n+      conf2 (threadprivate);\n \n       if (attr->intent != INTENT_UNKNOWN)\n \t{\n@@ -493,6 +501,7 @@ check_conflict (symbol_attribute * attr, const char * name, locus * where)\n       conf2 (dummy);\n       conf2 (in_common);\n       conf2 (save);\n+      conf2 (threadprivate);\n       break;\n \n     default:\n@@ -781,6 +790,23 @@ gfc_add_save (symbol_attribute * attr, const char *name, locus * where)\n }\n \n \n+try\n+gfc_add_threadprivate (symbol_attribute * attr, const char *name, locus * where)\n+{\n+  if (check_used (attr, name, where))\n+    return FAILURE;\n+\n+  if (attr->threadprivate)\n+    {\n+      duplicate_attr (\"THREADPRIVATE\", where);\n+      return FAILURE;\n+    }\n+\n+  attr->threadprivate = 1;\n+  return check_conflict (attr, name, where);\n+}\n+\n+\n try\n gfc_add_target (symbol_attribute * attr, locus * where)\n {\n@@ -1191,6 +1217,8 @@ gfc_copy_attr (symbol_attribute * dest, symbol_attribute * src, locus * where)\n     goto fail;\n   if (src->save && gfc_add_save (dest, NULL, where) == FAILURE)\n     goto fail;\n+  if (src->threadprivate && gfc_add_threadprivate (dest, NULL, where) == FAILURE)\n+    goto fail;\n   if (src->target && gfc_add_target (dest, where) == FAILURE)\n     goto fail;\n   if (src->dummy && gfc_add_dummy (dest, NULL, where) == FAILURE)"}, {"sha": "c8f92bd329bb510c1f2642d756dd0820b5f4fa51", "filename": "gcc/fortran/trans-common.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ffortran%2Ftrans-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ffortran%2Ftrans-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-common.c?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -1,5 +1,6 @@\n /* Common block and equivalence list handling\n-   Copyright (C) 2000, 2003, 2004, 2005 Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2003, 2004, 2005, 2006\n+   Free Software Foundation, Inc.\n    Contributed by Canqun Yang <canqun@nudt.edu.cn>\n \n This file is part of GCC.\n@@ -96,13 +97,15 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n+#include \"target.h\"\n #include \"tree.h\"\n #include \"toplev.h\"\n #include \"tm.h\"\n #include \"gfortran.h\"\n #include \"trans.h\"\n #include \"trans-types.h\"\n #include \"trans-const.h\"\n+#include \"rtl.h\"\n \n \n /* Holds a single variable in an equivalence set.  */\n@@ -278,6 +281,7 @@ build_equiv_decl (tree union_type, bool is_init, bool is_saved)\n     {\n       decl = gfc_create_var (union_type, \"equiv\");\n       TREE_STATIC (decl) = 1;\n+      GFC_DECL_COMMON_OR_EQUIV (decl) = 1;\n       return decl;\n     }\n \n@@ -292,6 +296,7 @@ build_equiv_decl (tree union_type, bool is_init, bool is_saved)\n \n   TREE_ADDRESSABLE (decl) = 1;\n   TREE_USED (decl) = 1;\n+  GFC_DECL_COMMON_OR_EQUIV (decl) = 1;\n \n   /* The source location has been lost, and doesn't really matter.\n      We need to set it to something though.  */\n@@ -349,9 +354,13 @@ build_common_decl (gfc_common_head *com, tree union_type, bool is_init)\n       TREE_STATIC (decl) = 1;\n       DECL_ALIGN (decl) = BIGGEST_ALIGNMENT;\n       DECL_USER_ALIGN (decl) = 0;\n+      GFC_DECL_COMMON_OR_EQUIV (decl) = 1;\n \n       gfc_set_decl_location (decl, &com->where);\n \n+      if (com->threadprivate && targetm.have_tls)\n+\tDECL_TLS_MODEL (decl) = decl_default_tls_model (decl);\n+\n       /* Place the back end declaration for this common block in\n          GLOBAL_BINDING_LEVEL.  */\n       common_sym->backend_decl = pushdecl_top_level (decl);\n@@ -493,6 +502,7 @@ create_common (gfc_common_head *com, segment_info * head, bool saw_equiv)\n \t\t\t   build3 (COMPONENT_REF, TREE_TYPE (s->field),\n \t\t\t\t   decl, s->field, NULL_TREE));\n       DECL_HAS_VALUE_EXPR_P (var_decl) = 1;\n+      GFC_DECL_COMMON_OR_EQUIV (var_decl) = 1;\n \n       if (s->sym->attr.assign)\n \t{"}, {"sha": "1def170e64f82f9312a95f8141a6d94239b459fd", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -40,6 +40,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"trans-types.h\"\n #include \"trans-array.h\"\n #include \"trans-const.h\"\n+#include \"rtl.h\"\n /* Only for gfc_trans_code.  Shouldn't need to include this.  */\n #include \"trans-stmt.h\"\n \n@@ -389,6 +390,7 @@ gfc_finish_cray_pointee (tree decl, gfc_symbol *sym)\n \n   SET_DECL_VALUE_EXPR (decl, value);\n   DECL_HAS_VALUE_EXPR_P (decl) = 1;\n+  GFC_DECL_CRAY_POINTEE (decl) = 1;\n   /* This is a fake variable just for debugging purposes.  */\n   TREE_ASM_WRITTEN (decl) = 1;\n }\n@@ -508,6 +510,11 @@ gfc_finish_var_decl (tree decl, gfc_symbol * sym)\n       && INTEGER_CST_P (DECL_SIZE_UNIT (decl))\n       && !gfc_can_put_var_on_stack (DECL_SIZE_UNIT (decl)))\n     TREE_STATIC (decl) = 1;\n+\n+  /* Handle threadprivate variables.  */\n+  if (sym->attr.threadprivate && targetm.have_tls\n+      && (TREE_STATIC (decl) || DECL_EXTERNAL (decl)))\n+    DECL_TLS_MODEL (decl) = decl_default_tls_model (decl);\n }\n \n \n@@ -1473,6 +1480,11 @@ gfc_gimplify_function (tree fndecl)\n   gimplify_function_tree (fndecl);\n   dump_function (TDI_generic, fndecl);\n \n+  /* Generate errors for structured block violations.  */\n+  /* ??? Could be done as part of resolve_labels.  */\n+  if (flag_openmp)\n+    diagnose_omp_structured_block_errors (fndecl);\n+\n   /* Convert all nested functions to GIMPLE now.  We do things in this order\n      so that items like VLA sizes are expanded properly in the context of the\n      correct function.  */\n@@ -1755,6 +1767,7 @@ gfc_get_fake_result_decl (gfc_symbol * sym)\n \t\t\t NULL_TREE);\n \t}\n       var = gfc_create_var (TREE_TYPE (decl), sym->name);\n+      GFC_DECL_RESULT (var) = 1;\n       SET_DECL_VALUE_EXPR (var, decl);\n       DECL_HAS_VALUE_EXPR_P (var) = 1;\n       TREE_CHAIN (current_fake_result_decl)\n@@ -1806,6 +1819,7 @@ gfc_get_fake_result_decl (gfc_symbol * sym)\n       DECL_EXTERNAL (decl) = 0;\n       TREE_PUBLIC (decl) = 0;\n       TREE_USED (decl) = 1;\n+      GFC_DECL_RESULT (decl) = 1;\n \n       layout_decl (decl, 0);\n "}, {"sha": "44be1b752dede3e9a77cca75decfd68c00a6580b", "filename": "gcc/fortran/trans-openmp.c", "status": "added", "additions": 1203, "deletions": 0, "changes": 1203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,1203 @@\n+/* OpenMP directive translation -- generate GCC trees from gfc_code.\n+   Copyright (C) 2005, 2006 Free Software Foundation, Inc.\n+   Contributed by Jakub Jelinek <jakub@redhat.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"tree-gimple.h\"\n+#include \"ggc.h\"\n+#include \"toplev.h\"\n+#include \"real.h\"\n+#include \"gfortran.h\"\n+#include \"trans.h\"\n+#include \"trans-stmt.h\"\n+#include \"trans-types.h\"\n+#include \"trans-array.h\"\n+#include \"trans-const.h\"\n+#include \"arith.h\"\n+\n+\n+/* True if OpenMP should privatize what this DECL points to rather\n+   than the DECL itself.  */\n+\n+bool\n+gfc_omp_privatize_by_reference (tree decl)\n+{\n+  tree type = TREE_TYPE (decl);\n+\n+  if (TREE_CODE (type) == REFERENCE_TYPE)\n+    return true;\n+\n+  if (TREE_CODE (type) == POINTER_TYPE)\n+    {\n+      /* POINTER/ALLOCATABLE have aggregate types, all user variables\n+\t that have POINTER_TYPE type are supposed to be privatized\n+\t by reference.  */\n+      if (!DECL_ARTIFICIAL (decl))\n+\treturn true;\n+\n+      /* Some arrays are expanded as DECL_ARTIFICIAL pointers\n+\t by the frontend.  */\n+      if (DECL_LANG_SPECIFIC (decl)\n+\t  && GFC_DECL_SAVED_DESCRIPTOR (decl))\n+\treturn true;\n+    }\n+\n+  return false;\n+}\n+\n+/* True if OpenMP sharing attribute of DECL is predetermined.  */\n+\n+enum omp_clause_default_kind\n+gfc_omp_predetermined_sharing (tree decl)\n+{\n+  if (DECL_ARTIFICIAL (decl) && ! GFC_DECL_RESULT (decl))\n+    return OMP_CLAUSE_DEFAULT_SHARED;\n+\n+  /* Cray pointees shouldn't be listed in any clauses and should be\n+     gimplified to dereference of the corresponding Cray pointer.\n+     Make them all private, so that they are emitted in the debug\n+     information.  */\n+  if (GFC_DECL_CRAY_POINTEE (decl))\n+    return OMP_CLAUSE_DEFAULT_PRIVATE;\n+\n+  /* COMMON and EQUIVALENCE decls are shared.  They\n+     are only referenced through DECL_VALUE_EXPR of the variables\n+     contained in them.  If those are privatized, they will not be\n+     gimplified to the COMMON or EQUIVALENCE decls.  */\n+  if (GFC_DECL_COMMON_OR_EQUIV (decl) && ! DECL_HAS_VALUE_EXPR_P (decl))\n+    return OMP_CLAUSE_DEFAULT_SHARED;\n+\n+  if (GFC_DECL_RESULT (decl) && ! DECL_HAS_VALUE_EXPR_P (decl))\n+    return OMP_CLAUSE_DEFAULT_SHARED;\n+\n+  return OMP_CLAUSE_DEFAULT_UNSPECIFIED;\n+}\n+\n+/* Return true if DECL's DECL_VALUE_EXPR (if any) should be\n+   disregarded in OpenMP construct, because it is going to be\n+   remapped during OpenMP lowering.  SHARED is true if DECL\n+   is going to be shared, false if it is going to be privatized.  */\n+\n+bool\n+gfc_omp_disregard_value_expr (tree decl, bool shared)\n+{\n+  if (GFC_DECL_COMMON_OR_EQUIV (decl)\n+      && DECL_HAS_VALUE_EXPR_P (decl))\n+    {\n+      tree value = DECL_VALUE_EXPR (decl);\n+\n+      if (TREE_CODE (value) == COMPONENT_REF\n+\t  && TREE_CODE (TREE_OPERAND (value, 0)) == VAR_DECL\n+\t  && GFC_DECL_COMMON_OR_EQUIV (TREE_OPERAND (value, 0)))\n+\t{\n+\t  /* If variable in COMMON or EQUIVALENCE is privatized, return\n+\t     true, as just that variable is supposed to be privatized,\n+\t     not the whole COMMON or whole EQUIVALENCE.\n+\t     For shared variables in COMMON or EQUIVALENCE, let them be\n+\t     gimplified to DECL_VALUE_EXPR, so that for multiple shared vars\n+\t     from the same COMMON or EQUIVALENCE just one sharing of the\n+\t     whole COMMON or EQUIVALENCE is enough.  */\n+\t  return ! shared;\n+\t}\n+    }\n+\n+  if (GFC_DECL_RESULT (decl) && DECL_HAS_VALUE_EXPR_P (decl))\n+    return ! shared;\n+\n+  return false;\n+}\n+\n+/* Return true if DECL that is shared iff SHARED is true should\n+   be put into OMP_CLAUSE_PRIVATE with OMP_CLAUSE_PRIVATE_DEBUG\n+   flag set.  */\n+\n+bool\n+gfc_omp_private_debug_clause (tree decl, bool shared)\n+{\n+  if (GFC_DECL_CRAY_POINTEE (decl))\n+    return true;\n+\n+  if (GFC_DECL_COMMON_OR_EQUIV (decl)\n+      && DECL_HAS_VALUE_EXPR_P (decl))\n+    {\n+      tree value = DECL_VALUE_EXPR (decl);\n+\n+      if (TREE_CODE (value) == COMPONENT_REF\n+\t  && TREE_CODE (TREE_OPERAND (value, 0)) == VAR_DECL\n+\t  && GFC_DECL_COMMON_OR_EQUIV (TREE_OPERAND (value, 0)))\n+\treturn shared;\n+    }\n+\n+  return false;\n+}\n+\n+/* Register language specific type size variables as potentially OpenMP\n+   firstprivate variables.  */\n+\n+void\n+gfc_omp_firstprivatize_type_sizes (struct gimplify_omp_ctx *ctx, tree type)\n+{\n+  if (GFC_ARRAY_TYPE_P (type) || GFC_DESCRIPTOR_TYPE_P (type))\n+    {\n+      int r;\n+\n+      gcc_assert (TYPE_LANG_SPECIFIC (type) != NULL);\n+      for (r = 0; r < GFC_TYPE_ARRAY_RANK (type); r++)\n+\t{\n+\t  omp_firstprivatize_variable (ctx, GFC_TYPE_ARRAY_LBOUND (type, r));\n+\t  omp_firstprivatize_variable (ctx, GFC_TYPE_ARRAY_UBOUND (type, r));\n+\t  omp_firstprivatize_variable (ctx, GFC_TYPE_ARRAY_STRIDE (type, r));\n+\t}\n+      omp_firstprivatize_variable (ctx, GFC_TYPE_ARRAY_SIZE (type));\n+      omp_firstprivatize_variable (ctx, GFC_TYPE_ARRAY_OFFSET (type));\n+    }\n+}\n+\n+\n+static inline tree\n+gfc_trans_add_clause (tree node, tree tail)\n+{\n+  OMP_CLAUSE_CHAIN (node) = tail;\n+  return node;\n+}\n+\n+static tree\n+gfc_trans_omp_variable (gfc_symbol *sym)\n+{\n+  tree t = gfc_get_symbol_decl (sym);\n+\n+  /* Special case for assigning the return value of a function.\n+     Self recursive functions must have an explicit return value.  */\n+  if (t == current_function_decl && sym->attr.function\n+      && (sym->result == sym))\n+    t = gfc_get_fake_result_decl (sym);\n+\n+  /* Similarly for alternate entry points.  */\n+  else if (sym->attr.function && sym->attr.entry\n+\t   && (sym->result == sym)\n+\t   && sym->ns->proc_name->backend_decl == current_function_decl)\n+    {\n+      gfc_entry_list *el = NULL;\n+\n+      for (el = sym->ns->entries; el; el = el->next)\n+\tif (sym == el->sym)\n+\t  {\n+\t    t = gfc_get_fake_result_decl (sym);\n+\t    break;\n+\t  }\n+    }\n+\n+  else if (sym->attr.result\n+\t   && sym->ns->proc_name->backend_decl == current_function_decl\n+\t   && sym->ns->proc_name->attr.entry_master\n+\t   && !gfc_return_by_reference (sym->ns->proc_name))\n+    t = gfc_get_fake_result_decl (sym);\n+\n+  return t;\n+}\n+\n+static tree\n+gfc_trans_omp_variable_list (enum omp_clause_code code, gfc_namelist *namelist,\n+\t\t\t     tree list)\n+{\n+  for (; namelist != NULL; namelist = namelist->next)\n+    if (namelist->sym->attr.referenced)\n+      {\n+\ttree t = gfc_trans_omp_variable (namelist->sym);\n+\tif (t != error_mark_node)\n+\t  {\n+\t    tree node = build_omp_clause (code);\n+\t    OMP_CLAUSE_DECL (node) = t;\n+\t    list = gfc_trans_add_clause (node, list);\n+\t  }\n+      }\n+  return list;\n+}\n+\n+static void\n+gfc_trans_omp_array_reduction (tree c, gfc_symbol *sym, locus where)\n+{\n+  gfc_symtree *root1 = NULL, *root2 = NULL, *root3 = NULL, *root4 = NULL;\n+  gfc_symtree *symtree1, *symtree2, *symtree3, *symtree4 = NULL;\n+  gfc_symbol init_val_sym, outer_sym, intrinsic_sym;\n+  gfc_expr *e1, *e2, *e3, *e4;\n+  gfc_ref *ref;\n+  tree decl, backend_decl;\n+  locus old_loc = gfc_current_locus;\n+  const char *iname;\n+  try t;\n+\n+  decl = OMP_CLAUSE_DECL (c);\n+  gfc_current_locus = where;\n+\n+  /* Create a fake symbol for init value.  */\n+  memset (&init_val_sym, 0, sizeof (init_val_sym));\n+  init_val_sym.ns = sym->ns;\n+  init_val_sym.name = sym->name;\n+  init_val_sym.ts = sym->ts;\n+  init_val_sym.attr.referenced = 1;\n+  init_val_sym.declared_at = where;\n+  backend_decl = omp_reduction_init (c, gfc_sym_type (&init_val_sym));\n+  init_val_sym.backend_decl = backend_decl;\n+\n+  /* Create a fake symbol for the outer array reference.  */\n+  outer_sym = *sym;\n+  outer_sym.as = gfc_copy_array_spec (sym->as);\n+  outer_sym.attr.dummy = 0;\n+  outer_sym.attr.result = 0;\n+  outer_sym.backend_decl = create_tmp_var_raw (TREE_TYPE (decl), NULL);\n+\n+  /* Create fake symtrees for it.  */\n+  symtree1 = gfc_new_symtree (&root1, sym->name);\n+  symtree1->n.sym = sym;\n+  gcc_assert (symtree1 == root1);\n+\n+  symtree2 = gfc_new_symtree (&root2, sym->name);\n+  symtree2->n.sym = &init_val_sym;\n+  gcc_assert (symtree2 == root2);\n+\n+  symtree3 = gfc_new_symtree (&root3, sym->name);\n+  symtree3->n.sym = &outer_sym;\n+  gcc_assert (symtree3 == root3);\n+\n+  /* Create expressions.  */\n+  e1 = gfc_get_expr ();\n+  e1->expr_type = EXPR_VARIABLE;\n+  e1->where = where;\n+  e1->symtree = symtree1;\n+  e1->ts = sym->ts;\n+  e1->ref = ref = gfc_get_ref ();\n+  ref->u.ar.where = where;\n+  ref->u.ar.as = sym->as;\n+  ref->u.ar.type = AR_FULL;\n+  ref->u.ar.dimen = 0;\n+  t = gfc_resolve_expr (e1);\n+  gcc_assert (t == SUCCESS);\n+\n+  e2 = gfc_get_expr ();\n+  e2->expr_type = EXPR_VARIABLE;\n+  e2->where = where;\n+  e2->symtree = symtree2;\n+  e2->ts = sym->ts;\n+  t = gfc_resolve_expr (e2);\n+  gcc_assert (t == SUCCESS);\n+\n+  e3 = gfc_copy_expr (e1);\n+  e3->symtree = symtree3;\n+  t = gfc_resolve_expr (e3);\n+  gcc_assert (t == SUCCESS);\n+\n+  iname = NULL;\n+  switch (OMP_CLAUSE_REDUCTION_CODE (c))\n+    {\n+    case PLUS_EXPR:\n+    case MINUS_EXPR:\n+      e4 = gfc_add (e3, e1);\n+      break;\n+    case MULT_EXPR:\n+      e4 = gfc_multiply (e3, e1);\n+      break;\n+    case TRUTH_ANDIF_EXPR:\n+      e4 = gfc_and (e3, e1);\n+      break;\n+    case TRUTH_ORIF_EXPR:\n+      e4 = gfc_or (e3, e1);\n+      break;\n+    case EQ_EXPR:\n+      e4 = gfc_eqv (e3, e1);\n+      break;\n+    case NE_EXPR:\n+      e4 = gfc_neqv (e3, e1);\n+      break;\n+    case MIN_EXPR:\n+      iname = \"min\";\n+      break;\n+    case MAX_EXPR:\n+      iname = \"max\";\n+      break;\n+    case BIT_AND_EXPR:\n+      iname = \"iand\";\n+      break;\n+    case BIT_IOR_EXPR:\n+      iname = \"ior\";\n+      break;\n+    case BIT_XOR_EXPR:\n+      iname = \"ieor\";\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+  if (iname != NULL)\n+    {\n+      memset (&intrinsic_sym, 0, sizeof (intrinsic_sym));\n+      intrinsic_sym.ns = sym->ns;\n+      intrinsic_sym.name = iname;\n+      intrinsic_sym.ts = sym->ts;\n+      intrinsic_sym.attr.referenced = 1;\n+      intrinsic_sym.attr.intrinsic = 1;\n+      intrinsic_sym.attr.function = 1;\n+      intrinsic_sym.result = &intrinsic_sym;\n+      intrinsic_sym.declared_at = where;\n+\n+      symtree4 = gfc_new_symtree (&root4, iname);\n+      symtree4->n.sym = &intrinsic_sym;\n+      gcc_assert (symtree4 == root4);\n+\n+      e4 = gfc_get_expr ();\n+      e4->expr_type = EXPR_FUNCTION;\n+      e4->where = where;\n+      e4->symtree = symtree4;\n+      e4->value.function.isym = gfc_find_function (iname);\n+      e4->value.function.actual = gfc_get_actual_arglist ();\n+      e4->value.function.actual->expr = e3;\n+      e4->value.function.actual->next = gfc_get_actual_arglist ();\n+      e4->value.function.actual->next->expr = e1;\n+    }\n+  /* e1 and e3 have been stored as arguments of e4, avoid sharing.  */\n+  e1 = gfc_copy_expr (e1);\n+  e3 = gfc_copy_expr (e3);\n+  t = gfc_resolve_expr (e4);\n+  gcc_assert (t == SUCCESS);\n+\n+  /* Create the init statement list.  */\n+  OMP_CLAUSE_REDUCTION_INIT (c) = gfc_trans_assignment (e1, e2);\n+\n+  /* Create the merge statement list.  */\n+  OMP_CLAUSE_REDUCTION_MERGE (c) = gfc_trans_assignment (e3, e4);\n+\n+  /* And stick the placeholder VAR_DECL into the clause as well.  */\n+  OMP_CLAUSE_REDUCTION_PLACEHOLDER (c) = outer_sym.backend_decl;\n+\n+  gfc_current_locus = old_loc;\n+\n+  gfc_free_expr (e1);\n+  gfc_free_expr (e2);\n+  gfc_free_expr (e3);\n+  gfc_free_expr (e4);\n+  gfc_free (symtree1);\n+  gfc_free (symtree2);\n+  gfc_free (symtree3);\n+  if (symtree4)\n+    gfc_free (symtree4);\n+  gfc_free_array_spec (outer_sym.as);\n+}\n+\n+static tree\n+gfc_trans_omp_reduction_list (gfc_namelist *namelist, tree list, \n+                              enum tree_code reduction_code, locus where)\n+{\n+  for (; namelist != NULL; namelist = namelist->next)\n+    if (namelist->sym->attr.referenced)\n+      {\n+\ttree t = gfc_trans_omp_variable (namelist->sym);\n+\tif (t != error_mark_node)\n+\t  {\n+\t    tree node = build_omp_clause (OMP_CLAUSE_REDUCTION);\n+\t    OMP_CLAUSE_DECL (node) = t;\n+\t    OMP_CLAUSE_REDUCTION_CODE (node) = reduction_code;\n+\t    if (namelist->sym->attr.dimension)\n+\t      gfc_trans_omp_array_reduction (node, namelist->sym, where);\n+\t    list = gfc_trans_add_clause (node, list);\n+\t  }\n+      }\n+  return list;\n+}\n+\n+static tree\n+gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n+\t\t       locus where)\n+{\n+  tree omp_clauses = NULL_TREE, chunk_size, c, old_clauses;\n+  int list;\n+  enum omp_clause_code clause_code;\n+  gfc_se se;\n+\n+  if (clauses == NULL)\n+    return NULL_TREE;\n+\n+  for (list = 0; list < OMP_LIST_NUM; list++)\n+    {\n+      gfc_namelist *n = clauses->lists[list];\n+\n+      if (n == NULL)\n+\tcontinue;\n+      if (list >= OMP_LIST_REDUCTION_FIRST\n+\t  && list <= OMP_LIST_REDUCTION_LAST)\n+\t{\n+\t  enum tree_code reduction_code;\n+\t  switch (list)\n+\t    {\n+\t    case OMP_LIST_PLUS:\n+\t      reduction_code = PLUS_EXPR;\n+\t      break;\n+\t    case OMP_LIST_MULT:\n+\t      reduction_code = MULT_EXPR;\n+\t      break;\n+\t    case OMP_LIST_SUB:\n+\t      reduction_code = MINUS_EXPR;\n+\t      break;\n+\t    case OMP_LIST_AND:\n+\t      reduction_code = TRUTH_ANDIF_EXPR;\n+\t      break;\n+\t    case OMP_LIST_OR:\n+\t      reduction_code = TRUTH_ORIF_EXPR;\n+\t      break;\n+\t    case OMP_LIST_EQV:\n+\t      reduction_code = EQ_EXPR;\n+\t      break;\n+\t    case OMP_LIST_NEQV:\n+\t      reduction_code = NE_EXPR;\n+\t      break;\n+\t    case OMP_LIST_MAX:\n+\t      reduction_code = MAX_EXPR;\n+\t      break;\n+\t    case OMP_LIST_MIN:\n+\t      reduction_code = MIN_EXPR;\n+\t      break;\n+\t    case OMP_LIST_IAND:\n+\t      reduction_code = BIT_AND_EXPR;\n+\t      break;\n+\t    case OMP_LIST_IOR:\n+\t      reduction_code = BIT_IOR_EXPR;\n+\t      break;\n+\t    case OMP_LIST_IEOR:\n+\t      reduction_code = BIT_XOR_EXPR;\n+\t      break;\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n+\t  old_clauses = omp_clauses;\n+\t  omp_clauses\n+\t    = gfc_trans_omp_reduction_list (n, omp_clauses, reduction_code,\n+\t\t\t\t\t    where);\n+\t  continue;\n+\t}\n+      switch (list)\n+\t{\n+\tcase OMP_LIST_PRIVATE:\n+\t  clause_code = OMP_CLAUSE_PRIVATE;\n+\t  goto add_clause;\n+\tcase OMP_LIST_SHARED:\n+\t  clause_code = OMP_CLAUSE_SHARED;\n+\t  goto add_clause;\n+\tcase OMP_LIST_FIRSTPRIVATE:\n+\t  clause_code = OMP_CLAUSE_FIRSTPRIVATE;\n+\t  goto add_clause;\n+\tcase OMP_LIST_LASTPRIVATE:\n+\t  clause_code = OMP_CLAUSE_LASTPRIVATE;\n+\t  goto add_clause;\n+\tcase OMP_LIST_COPYIN:\n+\t  clause_code = OMP_CLAUSE_COPYIN;\n+\t  goto add_clause;\n+\tcase OMP_LIST_COPYPRIVATE:\n+\t  clause_code = OMP_CLAUSE_COPYPRIVATE;\n+\t  /* FALLTHROUGH */\n+\tadd_clause:\n+\t  omp_clauses\n+\t    = gfc_trans_omp_variable_list (clause_code, n, omp_clauses);\n+\t  break;\n+\tdefault:\n+\t  break;\n+\t}\n+    }\n+\n+  if (clauses->if_expr)\n+    {\n+      tree if_var;\n+\n+      gfc_init_se (&se, NULL);\n+      gfc_conv_expr (&se, clauses->if_expr);\n+      gfc_add_block_to_block (block, &se.pre);\n+      if_var = gfc_evaluate_now (se.expr, block);\n+      gfc_add_block_to_block (block, &se.post);\n+\n+      c = build_omp_clause (OMP_CLAUSE_IF);\n+      OMP_CLAUSE_IF_EXPR (c) = if_var;\n+      omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n+    }\n+\n+  if (clauses->num_threads)\n+    {\n+      tree num_threads;\n+\n+      gfc_init_se (&se, NULL);\n+      gfc_conv_expr (&se, clauses->num_threads);\n+      gfc_add_block_to_block (block, &se.pre);\n+      num_threads = gfc_evaluate_now (se.expr, block);\n+      gfc_add_block_to_block (block, &se.post);\n+\n+      c = build_omp_clause (OMP_CLAUSE_NUM_THREADS);\n+      OMP_CLAUSE_NUM_THREADS_EXPR (c) = num_threads;\n+      omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n+    }\n+\n+  chunk_size = NULL_TREE;\n+  if (clauses->chunk_size)\n+    {\n+      gfc_init_se (&se, NULL);\n+      gfc_conv_expr (&se, clauses->chunk_size);\n+      gfc_add_block_to_block (block, &se.pre);\n+      chunk_size = gfc_evaluate_now (se.expr, block);\n+      gfc_add_block_to_block (block, &se.post);\n+    }\n+\n+  if (clauses->sched_kind != OMP_SCHED_NONE)\n+    {\n+      c = build_omp_clause (OMP_CLAUSE_SCHEDULE);\n+      OMP_CLAUSE_SCHEDULE_CHUNK_EXPR (c) = chunk_size;\n+      switch (clauses->sched_kind)\n+\t{\n+\tcase OMP_SCHED_STATIC:\n+\t  OMP_CLAUSE_SCHEDULE_KIND (c) = OMP_CLAUSE_SCHEDULE_STATIC;\n+\t  break;\n+\tcase OMP_SCHED_DYNAMIC:\n+\t  OMP_CLAUSE_SCHEDULE_KIND (c) = OMP_CLAUSE_SCHEDULE_DYNAMIC;\n+\t  break;\n+\tcase OMP_SCHED_GUIDED:\n+\t  OMP_CLAUSE_SCHEDULE_KIND (c) = OMP_CLAUSE_SCHEDULE_GUIDED;\n+\t  break;\n+\tcase OMP_SCHED_RUNTIME:\n+\t  OMP_CLAUSE_SCHEDULE_KIND (c) = OMP_CLAUSE_SCHEDULE_RUNTIME;\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+      omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n+    }\n+\n+  if (clauses->default_sharing != OMP_DEFAULT_UNKNOWN)\n+    {\n+      c = build_omp_clause (OMP_CLAUSE_DEFAULT);\n+      switch (clauses->default_sharing)\n+\t{\n+\tcase OMP_DEFAULT_NONE:\n+\t  OMP_CLAUSE_DEFAULT_KIND (c) = OMP_CLAUSE_DEFAULT_NONE;\n+\t  break;\n+\tcase OMP_DEFAULT_SHARED:\n+\t  OMP_CLAUSE_DEFAULT_KIND (c) = OMP_CLAUSE_DEFAULT_SHARED;\n+\t  break;\n+\tcase OMP_DEFAULT_PRIVATE:\n+\t  OMP_CLAUSE_DEFAULT_KIND (c) = OMP_CLAUSE_DEFAULT_PRIVATE;\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+      omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n+    }\n+\n+  if (clauses->nowait)\n+    {\n+      c = build_omp_clause (OMP_CLAUSE_NOWAIT);\n+      omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n+    }\n+\n+  if (clauses->ordered)\n+    {\n+      c = build_omp_clause (OMP_CLAUSE_ORDERED);\n+      omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n+    }\n+\n+  return omp_clauses;\n+}\n+\n+/* Like gfc_trans_code, but force creation of a BIND_EXPR around it.  */\n+\n+static tree\n+gfc_trans_omp_code (gfc_code *code, bool force_empty)\n+{\n+  tree stmt;\n+\n+  pushlevel (0);\n+  stmt = gfc_trans_code (code);\n+  if (TREE_CODE (stmt) != BIND_EXPR)\n+    {\n+      if (!IS_EMPTY_STMT (stmt) || force_empty)\n+\t{\n+\t  tree block = poplevel (1, 0, 0);\n+\t  stmt = build3_v (BIND_EXPR, NULL, stmt, block);\n+\t}\n+      else\n+\tpoplevel (0, 0, 0);\n+    }\n+  else\n+    poplevel (0, 0, 0);\n+  return stmt;\n+}\n+\n+\n+static tree gfc_trans_omp_sections (gfc_code *, gfc_omp_clauses *);\n+static tree gfc_trans_omp_workshare (gfc_code *, gfc_omp_clauses *);\n+\n+static tree\n+gfc_trans_omp_atomic (gfc_code *code)\n+{\n+  gfc_se lse;\n+  gfc_se rse;\n+  gfc_expr *expr2, *e;\n+  gfc_symbol *var;\n+  stmtblock_t block;\n+  tree lhsaddr, type, rhs, x;\n+  enum tree_code op = ERROR_MARK;\n+  bool var_on_left = false;\n+\n+  code = code->block->next;\n+  gcc_assert (code->op == EXEC_ASSIGN);\n+  gcc_assert (code->next == NULL);\n+  var = code->expr->symtree->n.sym;\n+\n+  gfc_init_se (&lse, NULL);\n+  gfc_init_se (&rse, NULL);\n+  gfc_start_block (&block);\n+\n+  gfc_conv_expr (&lse, code->expr);\n+  gfc_add_block_to_block (&block, &lse.pre);\n+  type = TREE_TYPE (lse.expr);\n+  lhsaddr = gfc_build_addr_expr (NULL, lse.expr);\n+\n+  expr2 = code->expr2;\n+  if (expr2->expr_type == EXPR_FUNCTION\n+      && expr2->value.function.isym->generic_id == GFC_ISYM_CONVERSION)\n+    expr2 = expr2->value.function.actual->expr;\n+\n+  if (expr2->expr_type == EXPR_OP)\n+    {\n+      gfc_expr *e;\n+      switch (expr2->value.op.operator)\n+\t{\n+\tcase INTRINSIC_PLUS:\n+\t  op = PLUS_EXPR;\n+\t  break;\n+\tcase INTRINSIC_TIMES:\n+\t  op = MULT_EXPR;\n+\t  break;\n+\tcase INTRINSIC_MINUS:\n+\t  op = MINUS_EXPR;\n+\t  break;\n+\tcase INTRINSIC_DIVIDE:\n+\t  if (expr2->ts.type == BT_INTEGER)\n+\t    op = TRUNC_DIV_EXPR;\n+\t  else\n+\t    op = RDIV_EXPR;\n+\t  break;\n+\tcase INTRINSIC_AND:\n+\t  op = TRUTH_ANDIF_EXPR;\n+\t  break;\n+\tcase INTRINSIC_OR:\n+\t  op = TRUTH_ORIF_EXPR;\n+\t  break;\n+\tcase INTRINSIC_EQV:\n+\t  op = EQ_EXPR;\n+\t  break;\n+\tcase INTRINSIC_NEQV:\n+\t  op = NE_EXPR;\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+      e = expr2->value.op.op1;\n+      if (e->expr_type == EXPR_FUNCTION\n+\t  && e->value.function.isym->generic_id == GFC_ISYM_CONVERSION)\n+\te = e->value.function.actual->expr;\n+      if (e->expr_type == EXPR_VARIABLE\n+\t  && e->symtree != NULL\n+\t  && e->symtree->n.sym == var)\n+\t{\n+\t  expr2 = expr2->value.op.op2;\n+\t  var_on_left = true;\n+\t}\n+      else\n+\t{\n+\t  e = expr2->value.op.op2;\n+\t  if (e->expr_type == EXPR_FUNCTION\n+\t      && e->value.function.isym->generic_id == GFC_ISYM_CONVERSION)\n+\t    e = e->value.function.actual->expr;\n+\t  gcc_assert (e->expr_type == EXPR_VARIABLE\n+\t\t      && e->symtree != NULL\n+\t\t      && e->symtree->n.sym == var);\n+\t  expr2 = expr2->value.op.op1;\n+\t  var_on_left = false;\n+\t}\n+      gfc_conv_expr (&rse, expr2);\n+      gfc_add_block_to_block (&block, &rse.pre);\n+    }\n+  else\n+    {\n+      gcc_assert (expr2->expr_type == EXPR_FUNCTION);\n+      switch (expr2->value.function.isym->generic_id)\n+\t{\n+\tcase GFC_ISYM_MIN:\n+\t  op = MIN_EXPR;\n+\t  break;\n+\tcase GFC_ISYM_MAX:\n+\t  op = MAX_EXPR;\n+\t  break;\n+\tcase GFC_ISYM_IAND:\n+\t  op = BIT_AND_EXPR;\n+\t  break;\n+\tcase GFC_ISYM_IOR:\n+\t  op = BIT_IOR_EXPR;\n+\t  break;\n+\tcase GFC_ISYM_IEOR:\n+\t  op = BIT_XOR_EXPR;\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+      e = expr2->value.function.actual->expr;\n+      gcc_assert (e->expr_type == EXPR_VARIABLE\n+\t\t  && e->symtree != NULL\n+\t\t  && e->symtree->n.sym == var);\n+\n+      gfc_conv_expr (&rse, expr2->value.function.actual->next->expr);\n+      gfc_add_block_to_block (&block, &rse.pre);\n+      if (expr2->value.function.actual->next->next != NULL)\n+\t{\n+\t  tree accum = gfc_create_var (TREE_TYPE (rse.expr), NULL);\n+\t  gfc_actual_arglist *arg;\n+\n+\t  gfc_add_modify_expr (&block, accum, rse.expr);\n+\t  for (arg = expr2->value.function.actual->next->next; arg;\n+\t       arg = arg->next)\n+\t    {\n+\t      gfc_init_block (&rse.pre);\n+\t      gfc_conv_expr (&rse, arg->expr);\n+\t      gfc_add_block_to_block (&block, &rse.pre);\n+\t      x = fold_build2 (op, TREE_TYPE (accum), accum, rse.expr);\n+\t      gfc_add_modify_expr (&block, accum, x);\n+\t    }\n+\n+\t  rse.expr = accum;\n+\t}\n+\n+      expr2 = expr2->value.function.actual->next->expr;\n+    }\n+\n+  lhsaddr = save_expr (lhsaddr);\n+  rhs = gfc_evaluate_now (rse.expr, &block);\n+  x = convert (TREE_TYPE (rhs), build_fold_indirect_ref (lhsaddr));\n+\n+  if (var_on_left)\n+    x = fold_build2 (op, TREE_TYPE (rhs), x, rhs);\n+  else\n+    x = fold_build2 (op, TREE_TYPE (rhs), rhs, x);\n+\n+  if (TREE_CODE (TREE_TYPE (rhs)) == COMPLEX_TYPE\n+      && TREE_CODE (type) != COMPLEX_TYPE)\n+    x = build1 (REALPART_EXPR, TREE_TYPE (TREE_TYPE (rhs)), x);\n+\n+  x = build2_v (OMP_ATOMIC, lhsaddr, convert (type, x));\n+  gfc_add_expr_to_block (&block, x);\n+\n+  gfc_add_block_to_block (&block, &lse.pre);\n+  gfc_add_block_to_block (&block, &rse.pre);\n+\n+  return gfc_finish_block (&block);\n+}\n+\n+static tree\n+gfc_trans_omp_barrier (void)\n+{\n+  tree decl = built_in_decls [BUILT_IN_GOMP_BARRIER];\n+  return build_function_call_expr (decl, NULL);\n+}\n+\n+static tree\n+gfc_trans_omp_critical (gfc_code *code)\n+{\n+  tree name = NULL_TREE, stmt;\n+  if (code->ext.omp_name != NULL)\n+    name = get_identifier (code->ext.omp_name);\n+  stmt = gfc_trans_code (code->block->next);\n+  return build2_v (OMP_CRITICAL, stmt, name);\n+}\n+\n+static tree\n+gfc_trans_omp_do (gfc_code *code, stmtblock_t *pblock,\n+\t\t  gfc_omp_clauses *clauses)\n+{\n+  gfc_se se;\n+  tree dovar, stmt, from, to, step, type, init, cond, incr;\n+  tree count = NULL_TREE, cycle_label, tmp, omp_clauses;\n+  stmtblock_t block;\n+  stmtblock_t body;\n+  int simple = 0;\n+  bool dovar_found = false;\n+\n+  code = code->block->next;\n+  gcc_assert (code->op == EXEC_DO);\n+\n+  if (pblock == NULL)\n+    {\n+      gfc_start_block (&block);\n+      pblock = &block;\n+    }\n+\n+  omp_clauses = gfc_trans_omp_clauses (pblock, clauses, code->loc);\n+  if (clauses)\n+    {\n+      gfc_namelist *n;\n+      for (n = clauses->lists[OMP_LIST_LASTPRIVATE]; n != NULL; n = n->next)\n+\tif (code->ext.iterator->var->symtree->n.sym == n->sym)\n+\t  break;\n+      if (n == NULL)\n+\tfor (n = clauses->lists[OMP_LIST_PRIVATE]; n != NULL; n = n->next)\n+\t  if (code->ext.iterator->var->symtree->n.sym == n->sym)\n+\t    break;\n+      if (n != NULL)\n+\tdovar_found = true;\n+    }\n+\n+  /* Evaluate all the expressions in the iterator.  */\n+  gfc_init_se (&se, NULL);\n+  gfc_conv_expr_lhs (&se, code->ext.iterator->var);\n+  gfc_add_block_to_block (pblock, &se.pre);\n+  dovar = se.expr;\n+  type = TREE_TYPE (dovar);\n+  gcc_assert (TREE_CODE (type) == INTEGER_TYPE);\n+\n+  gfc_init_se (&se, NULL);\n+  gfc_conv_expr_val (&se, code->ext.iterator->start);\n+  gfc_add_block_to_block (pblock, &se.pre);\n+  from = gfc_evaluate_now (se.expr, pblock);\n+\n+  gfc_init_se (&se, NULL);\n+  gfc_conv_expr_val (&se, code->ext.iterator->end);\n+  gfc_add_block_to_block (pblock, &se.pre);\n+  to = gfc_evaluate_now (se.expr, pblock);\n+\n+  gfc_init_se (&se, NULL);\n+  gfc_conv_expr_val (&se, code->ext.iterator->step);\n+  gfc_add_block_to_block (pblock, &se.pre);\n+  step = gfc_evaluate_now (se.expr, pblock);\n+\n+  /* Special case simple loops.  */\n+  if (integer_onep (step))\n+    simple = 1;\n+  else if (tree_int_cst_equal (step, integer_minus_one_node))\n+    simple = -1;\n+\n+  /* Loop body.  */\n+  if (simple)\n+    {\n+      init = build2_v (MODIFY_EXPR, dovar, from);\n+      cond = build2 (simple > 0 ? LE_EXPR : GE_EXPR, boolean_type_node,\n+\t\t     dovar, to);\n+      incr = fold_build2 (PLUS_EXPR, type, dovar, step);\n+      incr = fold_build2 (MODIFY_EXPR, type, dovar, incr);\n+      if (pblock != &block)\n+\t{\n+\t  pushlevel (0);\n+\t  gfc_start_block (&block);\n+\t}\n+      gfc_start_block (&body);\n+    }\n+  else\n+    {\n+      /* STEP is not 1 or -1.  Use:\n+\t for (count = 0; count < (to + step - from) / step; count++)\n+\t   {\n+\t     dovar = from + count * step;\n+\t     body;\n+\t   cycle_label:;\n+\t   }  */\n+      tmp = fold_build2 (MINUS_EXPR, type, step, from);\n+      tmp = fold_build2 (PLUS_EXPR, type, to, tmp);\n+      tmp = fold_build2 (TRUNC_DIV_EXPR, type, tmp, step);\n+      tmp = gfc_evaluate_now (tmp, pblock);\n+      count = gfc_create_var (type, \"count\");\n+      init = build2_v (MODIFY_EXPR, count, build_int_cst (type, 0));\n+      cond = build2 (LT_EXPR, boolean_type_node, count, tmp);\n+      incr = fold_build2 (PLUS_EXPR, type, count, build_int_cst (type, 1));\n+      incr = fold_build2 (MODIFY_EXPR, type, count, incr);\n+\n+      if (pblock != &block)\n+\t{\n+\t  pushlevel (0);\n+\t  gfc_start_block (&block);\n+\t}\n+      gfc_start_block (&body);\n+\n+      /* Initialize DOVAR.  */\n+      tmp = fold_build2 (MULT_EXPR, type, count, step);\n+      tmp = build2 (PLUS_EXPR, type, from, tmp);\n+      gfc_add_modify_expr (&body, dovar, tmp);\n+    }\n+\n+  if (!dovar_found)\n+    {\n+      tmp = build_omp_clause (OMP_CLAUSE_PRIVATE);\n+      OMP_CLAUSE_DECL (tmp) = dovar;\n+      omp_clauses = gfc_trans_add_clause (tmp, omp_clauses);\n+    }\n+  if (!simple)\n+    {\n+      tmp = build_omp_clause (OMP_CLAUSE_PRIVATE);\n+      OMP_CLAUSE_DECL (tmp) = count;\n+      omp_clauses = gfc_trans_add_clause (tmp, omp_clauses);\n+    }\n+\n+  /* Cycle statement is implemented with a goto.  Exit statement must not be\n+     present for this loop.  */\n+  cycle_label = gfc_build_label_decl (NULL_TREE);\n+\n+  /* Put these labels where they can be found later. We put the\n+     labels in a TREE_LIST node (because TREE_CHAIN is already\n+     used). cycle_label goes in TREE_PURPOSE (backend_decl), exit\n+     label in TREE_VALUE (backend_decl).  */\n+\n+  code->block->backend_decl = tree_cons (cycle_label, NULL, NULL);\n+\n+  /* Main loop body.  */\n+  tmp = gfc_trans_omp_code (code->block->next, true);\n+  gfc_add_expr_to_block (&body, tmp);\n+\n+  /* Label for cycle statements (if needed).  */\n+  if (TREE_USED (cycle_label))\n+    {\n+      tmp = build1_v (LABEL_EXPR, cycle_label);\n+      gfc_add_expr_to_block (&body, tmp);\n+    }\n+\n+  /* End of loop body.  */\n+  stmt = make_node (OMP_FOR);\n+\n+  TREE_TYPE (stmt) = void_type_node;\n+  OMP_FOR_BODY (stmt) = gfc_finish_block (&body);\n+  OMP_FOR_CLAUSES (stmt) = omp_clauses;\n+  OMP_FOR_INIT (stmt) = init;\n+  OMP_FOR_COND (stmt) = cond;\n+  OMP_FOR_INCR (stmt) = incr;\n+  gfc_add_expr_to_block (&block, stmt);\n+\n+  return gfc_finish_block (&block);\n+}\n+\n+static tree\n+gfc_trans_omp_flush (void)\n+{\n+  tree decl = built_in_decls [BUILT_IN_SYNCHRONIZE];\n+  return build_function_call_expr (decl, NULL);\n+}\n+\n+static tree\n+gfc_trans_omp_master (gfc_code *code)\n+{\n+  tree stmt = gfc_trans_code (code->block->next);\n+  if (IS_EMPTY_STMT (stmt))\n+    return stmt;\n+  return build1_v (OMP_MASTER, stmt);\n+}\n+\n+static tree\n+gfc_trans_omp_ordered (gfc_code *code)\n+{\n+  return build1_v (OMP_ORDERED, gfc_trans_code (code->block->next));\n+}\n+\n+static tree\n+gfc_trans_omp_parallel (gfc_code *code)\n+{\n+  stmtblock_t block;\n+  tree stmt, omp_clauses;\n+\n+  gfc_start_block (&block);\n+  omp_clauses = gfc_trans_omp_clauses (&block, code->ext.omp_clauses,\n+\t\t\t\t       code->loc);\n+  stmt = gfc_trans_omp_code (code->block->next, true);\n+  stmt = build4_v (OMP_PARALLEL, stmt, omp_clauses, NULL, NULL);\n+  gfc_add_expr_to_block (&block, stmt);\n+  return gfc_finish_block (&block);\n+}\n+\n+static tree\n+gfc_trans_omp_parallel_do (gfc_code *code)\n+{\n+  stmtblock_t block, *pblock = NULL;\n+  gfc_omp_clauses parallel_clauses, do_clauses;\n+  tree stmt, omp_clauses = NULL_TREE;\n+\n+  gfc_start_block (&block);\n+\n+  memset (&do_clauses, 0, sizeof (do_clauses));\n+  if (code->ext.omp_clauses != NULL)\n+    {\n+      memcpy (&parallel_clauses, code->ext.omp_clauses,\n+\t      sizeof (parallel_clauses));\n+      do_clauses.sched_kind = parallel_clauses.sched_kind;\n+      do_clauses.chunk_size = parallel_clauses.chunk_size;\n+      do_clauses.ordered = parallel_clauses.ordered;\n+      parallel_clauses.sched_kind = OMP_SCHED_NONE;\n+      parallel_clauses.chunk_size = NULL;\n+      parallel_clauses.ordered = false;\n+      omp_clauses = gfc_trans_omp_clauses (&block, &parallel_clauses,\n+\t\t\t\t\t   code->loc);\n+    }\n+  do_clauses.nowait = true;\n+  if (!do_clauses.ordered && do_clauses.sched_kind != OMP_SCHED_STATIC)\n+    pblock = &block;\n+  else\n+    pushlevel (0);\n+  stmt = gfc_trans_omp_do (code, pblock, &do_clauses);\n+  if (TREE_CODE (stmt) != BIND_EXPR)\n+    stmt = build3_v (BIND_EXPR, NULL, stmt, poplevel (1, 0, 0));\n+  else\n+    poplevel (0, 0, 0);\n+  stmt = build4_v (OMP_PARALLEL, stmt, omp_clauses, NULL, NULL);\n+  gfc_add_expr_to_block (&block, stmt);\n+  return gfc_finish_block (&block);\n+}\n+\n+static tree\n+gfc_trans_omp_parallel_sections (gfc_code *code)\n+{\n+  stmtblock_t block;\n+  gfc_omp_clauses section_clauses;\n+  tree stmt, omp_clauses;\n+\n+  memset (&section_clauses, 0, sizeof (section_clauses));\n+  section_clauses.nowait = true;\n+\n+  gfc_start_block (&block);\n+  omp_clauses = gfc_trans_omp_clauses (&block, code->ext.omp_clauses,\n+\t\t\t\t       code->loc);\n+  pushlevel (0);\n+  stmt = gfc_trans_omp_sections (code, &section_clauses);\n+  if (TREE_CODE (stmt) != BIND_EXPR)\n+    stmt = build3_v (BIND_EXPR, NULL, stmt, poplevel (1, 0, 0));\n+  else\n+    poplevel (0, 0, 0);\n+  stmt = build4_v (OMP_PARALLEL, stmt, omp_clauses, NULL, NULL);\n+  gfc_add_expr_to_block (&block, stmt);\n+  return gfc_finish_block (&block);\n+}\n+\n+static tree\n+gfc_trans_omp_parallel_workshare (gfc_code *code)\n+{\n+  stmtblock_t block;\n+  gfc_omp_clauses workshare_clauses;\n+  tree stmt, omp_clauses;\n+\n+  memset (&workshare_clauses, 0, sizeof (workshare_clauses));\n+  workshare_clauses.nowait = true;\n+\n+  gfc_start_block (&block);\n+  omp_clauses = gfc_trans_omp_clauses (&block, code->ext.omp_clauses,\n+\t\t\t\t       code->loc);\n+  pushlevel (0);\n+  stmt = gfc_trans_omp_workshare (code, &workshare_clauses);\n+  if (TREE_CODE (stmt) != BIND_EXPR)\n+    stmt = build3_v (BIND_EXPR, NULL, stmt, poplevel (1, 0, 0));\n+  else\n+    poplevel (0, 0, 0);\n+  stmt = build4_v (OMP_PARALLEL, stmt, omp_clauses, NULL, NULL);\n+  gfc_add_expr_to_block (&block, stmt);\n+  return gfc_finish_block (&block);\n+}\n+\n+static tree\n+gfc_trans_omp_sections (gfc_code *code, gfc_omp_clauses *clauses)\n+{\n+  stmtblock_t block, body;\n+  tree omp_clauses, stmt;\n+  bool has_lastprivate = clauses->lists[OMP_LIST_LASTPRIVATE] != NULL;\n+\n+  gfc_start_block (&block);\n+\n+  omp_clauses = gfc_trans_omp_clauses (&block, clauses, code->loc);\n+\n+  gfc_init_block (&body);\n+  for (code = code->block; code; code = code->block)\n+    {\n+      /* Last section is special because of lastprivate, so even if it\n+\t is empty, chain it in.  */\n+      stmt = gfc_trans_omp_code (code->next,\n+\t\t\t\t has_lastprivate && code->block == NULL);\n+      if (! IS_EMPTY_STMT (stmt))\n+\t{\n+\t  stmt = build1_v (OMP_SECTION, stmt);\n+\t  gfc_add_expr_to_block (&body, stmt);\n+\t}\n+    }\n+  stmt = gfc_finish_block (&body);\n+\n+  stmt = build3_v (OMP_SECTIONS, stmt, omp_clauses, NULL);\n+  gfc_add_expr_to_block (&block, stmt);\n+\n+  return gfc_finish_block (&block);\n+}\n+\n+static tree\n+gfc_trans_omp_single (gfc_code *code, gfc_omp_clauses *clauses)\n+{\n+  tree omp_clauses = gfc_trans_omp_clauses (NULL, clauses, code->loc);\n+  tree stmt = gfc_trans_omp_code (code->block->next, true);\n+  stmt = build2_v (OMP_SINGLE, stmt, omp_clauses);\n+  return stmt;\n+}\n+\n+static tree\n+gfc_trans_omp_workshare (gfc_code *code, gfc_omp_clauses *clauses)\n+{\n+  /* XXX */\n+  return gfc_trans_omp_single (code, clauses);\n+}\n+\n+tree\n+gfc_trans_omp_directive (gfc_code *code)\n+{\n+  switch (code->op)\n+    {\n+    case EXEC_OMP_ATOMIC:\n+      return gfc_trans_omp_atomic (code);\n+    case EXEC_OMP_BARRIER:\n+      return gfc_trans_omp_barrier ();\n+    case EXEC_OMP_CRITICAL:\n+      return gfc_trans_omp_critical (code);\n+    case EXEC_OMP_DO:\n+      return gfc_trans_omp_do (code, NULL, code->ext.omp_clauses);\n+    case EXEC_OMP_FLUSH:\n+      return gfc_trans_omp_flush ();\n+    case EXEC_OMP_MASTER:\n+      return gfc_trans_omp_master (code);\n+    case EXEC_OMP_ORDERED:\n+      return gfc_trans_omp_ordered (code);\n+    case EXEC_OMP_PARALLEL:\n+      return gfc_trans_omp_parallel (code);\n+    case EXEC_OMP_PARALLEL_DO:\n+      return gfc_trans_omp_parallel_do (code);\n+    case EXEC_OMP_PARALLEL_SECTIONS:\n+      return gfc_trans_omp_parallel_sections (code);\n+    case EXEC_OMP_PARALLEL_WORKSHARE:\n+      return gfc_trans_omp_parallel_workshare (code);\n+    case EXEC_OMP_SECTIONS:\n+      return gfc_trans_omp_sections (code, code->ext.omp_clauses);\n+    case EXEC_OMP_SINGLE:\n+      return gfc_trans_omp_single (code, code->ext.omp_clauses);\n+    case EXEC_OMP_WORKSHARE:\n+      return gfc_trans_omp_workshare (code, code->ext.omp_clauses);\n+    default:\n+      gcc_unreachable ();\n+    }\n+}"}, {"sha": "a71c8bfbede1d76cbee88149e364f400fa58a414", "filename": "gcc/fortran/trans-stmt.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ffortran%2Ftrans-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ffortran%2Ftrans-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.h?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -51,6 +51,9 @@ tree gfc_trans_allocate (gfc_code *);\n tree gfc_trans_deallocate (gfc_code *);\n tree gfc_trans_deallocate_array (tree);\n \n+/* trans-openmp.c */\n+tree gfc_trans_omp_directive (gfc_code *);\n+\n /* trans-io.c */\n tree gfc_trans_open (gfc_code *);\n tree gfc_trans_close (gfc_code *);"}, {"sha": "a586932c9d6932b7df8737f6cd9bbf4f1c129f7d", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -583,6 +583,23 @@ gfc_trans_code (gfc_code * code)\n \t  res = gfc_trans_dt_end (code);\n \t  break;\n \n+\tcase EXEC_OMP_ATOMIC:\n+\tcase EXEC_OMP_BARRIER:\n+\tcase EXEC_OMP_CRITICAL:\n+\tcase EXEC_OMP_DO:\n+\tcase EXEC_OMP_FLUSH:\n+\tcase EXEC_OMP_MASTER:\n+\tcase EXEC_OMP_ORDERED:\n+\tcase EXEC_OMP_PARALLEL:\n+\tcase EXEC_OMP_PARALLEL_DO:\n+\tcase EXEC_OMP_PARALLEL_SECTIONS:\n+\tcase EXEC_OMP_PARALLEL_WORKSHARE:\n+\tcase EXEC_OMP_SECTIONS:\n+\tcase EXEC_OMP_SINGLE:\n+\tcase EXEC_OMP_WORKSHARE:\n+\t  res = gfc_trans_omp_directive (code);\n+\t  break;\n+\n \tdefault:\n \t  internal_error (\"gfc_trans_code(): Bad statement code\");\n \t}"}, {"sha": "82f74e049fabe4090002e7cc067298d6bee6f58a", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -439,6 +439,14 @@ tree gfc_truthvalue_conversion (tree);\n tree builtin_function (const char *, tree, int, enum built_in_class,\n \t\t       const char *, tree);\n \n+/* In trans-openmp.c */\n+bool gfc_omp_privatize_by_reference (tree);\n+enum omp_clause_default_kind gfc_omp_predetermined_sharing (tree);\n+bool gfc_omp_disregard_value_expr (tree, bool);\n+bool gfc_omp_private_debug_clause (tree, bool);\n+struct gimplify_omp_ctx;\n+void gfc_omp_firstprivatize_type_sizes (struct gimplify_omp_ctx *, tree);\n+\n /* Runtime library function decls.  */\n extern GTY(()) tree gfor_fndecl_internal_malloc;\n extern GTY(()) tree gfor_fndecl_internal_malloc64;\n@@ -548,6 +556,9 @@ struct lang_decl\t\tGTY(())\n #define GFC_DECL_PACKED_ARRAY(node) DECL_LANG_FLAG_0(node)\n #define GFC_DECL_PARTIAL_PACKED_ARRAY(node) DECL_LANG_FLAG_1(node)\n #define GFC_DECL_ASSIGN(node) DECL_LANG_FLAG_2(node)\n+#define GFC_DECL_COMMON_OR_EQUIV(node) DECL_LANG_FLAG_3(node)\n+#define GFC_DECL_CRAY_POINTEE(node) DECL_LANG_FLAG_4(node)\n+#define GFC_DECL_RESULT(node) DECL_LANG_FLAG_5(node)\n \n /* An array descriptor.  */\n #define GFC_DESCRIPTOR_TYPE_P(node) TYPE_LANG_FLAG_1(node)\n@@ -580,6 +591,8 @@ struct lang_decl\t\tGTY(())\n                                           arg1, arg2)\n #define build3_v(code, arg1, arg2, arg3) build3(code, void_type_node, \\\n                                                 arg1, arg2, arg3)\n+#define build4_v(code, arg1, arg2, arg3, arg4) build4(code, void_type_node, \\\n+\t\t\t\t\t\t      arg1, arg2, arg3, arg4)\n \n /* This group of functions allows a caller to evaluate an expression from\n    the callee's interface.  It establishes a mapping between the interface's"}, {"sha": "5a3e5d72221c6daaed44212a56ffd27f29dd8b1c", "filename": "gcc/fortran/types.def", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ffortran%2Ftypes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ffortran%2Ftypes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftypes.def?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,132 @@\n+/* Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006\n+   Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+/* This header contains a subset of ../builtin-types.def needed for\n+   Fortran frontend builtins.\n+\n+   Before including this header, you must define the following macros:\n+\n+   DEF_PRIMITIVE_TYPE (ENUM, TYPE)\n+\n+     The ENUM is an identifier indicating which type is being defined.\n+     TYPE is an expression for a `tree' that represents the type.\n+\n+   DEF_FUNCTION_TYPE_0 (ENUM, RETURN)\n+   DEF_FUNCTION_TYPE_1 (ENUM, RETURN, ARG1)\n+   DEF_FUNCTION_TYPE_2 (ENUM, RETURN, ARG1, ARG2)\n+   DEF_FUNCTION_TYPE_3 (ENUM, RETURN, ARG1, ARG2, ARG3)\n+   DEF_FUNCTION_TYPE_4 (ENUM, RETURN, ARG1, ARG2, ARG3, ARG4)\n+   DEF_FUNCTION_TYPE_5 (ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5)\n+   DEF_FUNCTION_TYPE_6 (ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6)\n+   DEF_FUNCTION_TYPE_7 (ENUM, RETURN, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7)\n+\n+     These macros describe function types.  ENUM is as above.  The\n+     RETURN type is one of the enumerals already defined.  ARG1, ARG2,\n+     and ARG3 give the types of the arguments, similarly.\n+\n+   DEF_FUNCTION_TYPE_VAR_0 (ENUM, RETURN)\n+\n+     Similar, but for function types that take variable arguments.\n+\n+  DEF_POINTER_TYPE (ENUM, TYPE)\n+\n+    This macro describes a pointer type.  ENUM is as above; TYPE is\n+    the type pointed to.  */\n+\n+DEF_PRIMITIVE_TYPE (BT_VOID, void_type_node)\n+DEF_PRIMITIVE_TYPE (BT_BOOL, boolean_type_node)\n+DEF_PRIMITIVE_TYPE (BT_INT, integer_type_node)\n+DEF_PRIMITIVE_TYPE (BT_UINT, unsigned_type_node)\n+DEF_PRIMITIVE_TYPE (BT_LONG, long_integer_type_node)\n+\n+DEF_PRIMITIVE_TYPE (BT_I1, builtin_type_for_size (BITS_PER_UNIT*1, 1))\n+DEF_PRIMITIVE_TYPE (BT_I2, builtin_type_for_size (BITS_PER_UNIT*2, 1))\n+DEF_PRIMITIVE_TYPE (BT_I4, builtin_type_for_size (BITS_PER_UNIT*4, 1))\n+DEF_PRIMITIVE_TYPE (BT_I8, builtin_type_for_size (BITS_PER_UNIT*8, 1))\n+DEF_PRIMITIVE_TYPE (BT_I16, builtin_type_for_size (BITS_PER_UNIT*16, 1))\n+\n+DEF_PRIMITIVE_TYPE (BT_PTR, ptr_type_node)\n+DEF_PRIMITIVE_TYPE (BT_CONST_PTR, const_ptr_type_node)\n+DEF_PRIMITIVE_TYPE (BT_VOLATILE_PTR,\n+                    build_pointer_type\n+                     (build_qualified_type (void_type_node,\n+                                            TYPE_QUAL_VOLATILE)))\n+\n+DEF_POINTER_TYPE (BT_PTR_LONG, BT_LONG)\n+DEF_POINTER_TYPE (BT_PTR_PTR, BT_PTR)\n+DEF_FUNCTION_TYPE_0 (BT_FN_BOOL, BT_BOOL)\n+DEF_FUNCTION_TYPE_0 (BT_FN_PTR, BT_PTR)\n+DEF_FUNCTION_TYPE_0 (BT_FN_INT, BT_INT)\n+DEF_FUNCTION_TYPE_0 (BT_FN_UINT, BT_UINT)\n+DEF_FUNCTION_TYPE_0 (BT_FN_VOID, BT_VOID)\n+\n+DEF_FUNCTION_TYPE_1 (BT_FN_VOID_PTR, BT_VOID, BT_PTR)\n+DEF_FUNCTION_TYPE_1 (BT_FN_VOID_PTRPTR, BT_VOID, BT_PTR_PTR)\n+DEF_FUNCTION_TYPE_1 (BT_FN_VOID_VPTR, BT_VOID, BT_VOLATILE_PTR)\n+DEF_FUNCTION_TYPE_1 (BT_FN_UINT_UINT, BT_UINT, BT_UINT)\n+\n+DEF_POINTER_TYPE (BT_PTR_FN_VOID_PTR, BT_FN_VOID_PTR)\n+\n+DEF_FUNCTION_TYPE_2 (BT_FN_BOOL_LONGPTR_LONGPTR,\n+                     BT_BOOL, BT_PTR_LONG, BT_PTR_LONG)\n+DEF_FUNCTION_TYPE_2 (BT_FN_I1_VPTR_I1, BT_I1, BT_VOLATILE_PTR, BT_I1)\n+DEF_FUNCTION_TYPE_2 (BT_FN_I2_VPTR_I2, BT_I2, BT_VOLATILE_PTR, BT_I2)\n+DEF_FUNCTION_TYPE_2 (BT_FN_I4_VPTR_I4, BT_I4, BT_VOLATILE_PTR, BT_I4)\n+DEF_FUNCTION_TYPE_2 (BT_FN_I8_VPTR_I8, BT_I8, BT_VOLATILE_PTR, BT_I8)\n+DEF_FUNCTION_TYPE_2 (BT_FN_I16_VPTR_I16, BT_I16, BT_VOLATILE_PTR, BT_I16)\n+\n+DEF_FUNCTION_TYPE_3 (BT_FN_BOOL_VPTR_I1_I1, BT_BOOL, BT_VOLATILE_PTR,\n+                     BT_I1, BT_I1)\n+DEF_FUNCTION_TYPE_3 (BT_FN_BOOL_VPTR_I2_I2, BT_BOOL, BT_VOLATILE_PTR,\n+                     BT_I2, BT_I2)\n+DEF_FUNCTION_TYPE_3 (BT_FN_BOOL_VPTR_I4_I4, BT_BOOL, BT_VOLATILE_PTR,\n+                     BT_I4, BT_I4)\n+DEF_FUNCTION_TYPE_3 (BT_FN_BOOL_VPTR_I8_I8, BT_BOOL, BT_VOLATILE_PTR,\n+                     BT_I8, BT_I8)\n+DEF_FUNCTION_TYPE_3 (BT_FN_BOOL_VPTR_I16_I16, BT_BOOL, BT_VOLATILE_PTR,\n+                     BT_I16, BT_I16)\n+DEF_FUNCTION_TYPE_3 (BT_FN_I1_VPTR_I1_I1, BT_I1, BT_VOLATILE_PTR, BT_I1, BT_I1)\n+DEF_FUNCTION_TYPE_3 (BT_FN_I2_VPTR_I2_I2, BT_I2, BT_VOLATILE_PTR, BT_I2, BT_I2)\n+DEF_FUNCTION_TYPE_3 (BT_FN_I4_VPTR_I4_I4, BT_I4, BT_VOLATILE_PTR, BT_I4, BT_I4)\n+DEF_FUNCTION_TYPE_3 (BT_FN_I8_VPTR_I8_I8, BT_I8, BT_VOLATILE_PTR, BT_I8, BT_I8)\n+DEF_FUNCTION_TYPE_3 (BT_FN_I16_VPTR_I16_I16, BT_I16, BT_VOLATILE_PTR,\n+\t\t     BT_I16, BT_I16)\n+DEF_FUNCTION_TYPE_3 (BT_FN_VOID_OMPFN_PTR_UINT, BT_VOID, BT_PTR_FN_VOID_PTR,\n+                     BT_PTR, BT_UINT)\n+\n+DEF_FUNCTION_TYPE_4 (BT_FN_VOID_OMPFN_PTR_UINT_UINT,\n+                     BT_VOID, BT_PTR_FN_VOID_PTR, BT_PTR, BT_UINT, BT_UINT)\n+\n+DEF_FUNCTION_TYPE_5 (BT_FN_BOOL_LONG_LONG_LONG_LONGPTR_LONGPTR,\n+                     BT_BOOL, BT_LONG, BT_LONG, BT_LONG,\n+\t\t     BT_PTR_LONG, BT_PTR_LONG)\n+\n+DEF_FUNCTION_TYPE_6 (BT_FN_BOOL_LONG_LONG_LONG_LONG_LONGPTR_LONGPTR,\n+                     BT_BOOL, BT_LONG, BT_LONG, BT_LONG, BT_LONG,\n+\t\t     BT_PTR_LONG, BT_PTR_LONG)\n+DEF_FUNCTION_TYPE_6 (BT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG,\n+                     BT_VOID, BT_PTR_FN_VOID_PTR, BT_PTR, BT_UINT,\n+                     BT_LONG, BT_LONG, BT_LONG)\n+\n+DEF_FUNCTION_TYPE_7 (BT_FN_VOID_OMPFN_PTR_UINT_LONG_LONG_LONG_LONG,\n+                     BT_VOID, BT_PTR_FN_VOID_PTR, BT_PTR, BT_UINT,\n+                     BT_LONG, BT_LONG, BT_LONG, BT_LONG)\n+\n+DEF_FUNCTION_TYPE_VAR_0 (BT_FN_VOID_VAR, BT_VOID)"}, {"sha": "d12f8741c62163aafa30913ba3cd9fb3314f81a6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -1,3 +1,9 @@\n+2006-02-14  Jakub Jelinek  <jakub@redhat.com>\n+\t    Diego Novillo  <dnovillo@redhat.com>\n+\t    Uros Bizjak  <uros@kss-loka.si>\n+\n+\t* gfortran.dg/gomp: New directory.\n+\n 2006-02-14  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/26258"}, {"sha": "fd83131b5e9274d20606e3004bbb4850249f207c", "filename": "gcc/testsuite/gfortran.dg/gomp/appendix-a/a.1.1.f90", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.1.1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.1.1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.1.1.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,10 @@\n+! { dg-do compile }\n+      SUBROUTINE A1(N, A, B)\n+      INTEGER I, N\n+      REAL B(N), A(N)\n+!$OMP PARALLEL DO !I is private by default\n+      DO I=2,N\n+          B(I) = (A(I) + A(I-1)) / 2.0\n+      ENDDO\n+!$OMP END PARALLEL DO\n+      END SUBROUTINE A1"}, {"sha": "eb8455e19bb9aa8af5d1ee4be212087c17cdddb0", "filename": "gcc/testsuite/gfortran.dg/gomp/appendix-a/a.11.1.f90", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.11.1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.11.1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.11.1.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,12 @@\n+! { dg-do compile }\n+      SUBROUTINE A11_1(AA, BB, CC, DD, EE, FF, N)\n+      INTEGER N\n+      REAL AA(N,N), BB(N,N), CC(N,N), DD(N,N), EE(N,N), FF(N,N)\n+!$OMP PARALLEL\n+!$OMP WORKSHARE\n+            AA = BB\n+            CC = DD\n+            EE = FF\n+!$OMP END WORKSHARE\n+!$OMP END PARALLEL\n+      END SUBROUTINE A11_1"}, {"sha": "11fdc1caa477d0f964fc829baa750609b0263538", "filename": "gcc/testsuite/gfortran.dg/gomp/appendix-a/a.11.2.f90", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.11.2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.11.2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.11.2.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,16 @@\n+! { do-do compile }\n+\n+      SUBROUTINE A11_2(AA, BB, CC, DD, EE, FF, N)\n+      INTEGER N\n+      REAL AA(N,N), BB(N,N), CC(N,N)\n+      REAL DD(N,N), EE(N,N), FF(N,N)\n+!$OMP PARALLEL\n+!$OMP WORKSHARE\n+            AA = BB\n+            CC = DD\n+!$OMP END WORKSHARE NOWAIT\n+!$OMP WORKSHARE\n+            EE = FF\n+!$OMP END WORKSHARE\n+!$OMP END PARALLEL\n+      END SUBROUTINE A11_2"}, {"sha": "b87232f9c669e7e57653033b013d31a20b65a8b3", "filename": "gcc/testsuite/gfortran.dg/gomp/appendix-a/a.11.3.f90", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.11.3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.11.3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.11.3.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,15 @@\n+! { dg-do compile }\n+      SUBROUTINE A11_3(AA, BB, CC, DD, N)\n+      INTEGER N\n+      REAL AA(N,N), BB(N,N), CC(N,N), DD(N,N)\n+      REAL R\n+        R=0\n+!$OMP PARALLEL\n+!$OMP WORKSHARE\n+             AA = BB\n+!$OMP ATOMIC\n+               R = R + SUM(AA)\n+             CC = DD\n+!$OMP END WORKSHARE\n+!$OMP END PARALLEL\n+      END SUBROUTINE A11_3"}, {"sha": "ae95c1f98e2bb3304a3776f1463474b452dbc980", "filename": "gcc/testsuite/gfortran.dg/gomp/appendix-a/a.11.4.f90", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.11.4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.11.4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.11.4.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,16 @@\n+! { dg-do compile }\n+\n+      SUBROUTINE A11_4(AA, BB, CC, DD, EE, FF, GG, HH, N)\n+      INTEGER N\n+      REAL AA(N,N), BB(N,N), CC(N,N)\n+      REAL DD(N,N), EE(N,N), FF(N,N)\n+      REAL GG(N,N), HH(N,N)\n+!$OMP PARALLEL\n+!$OMP WORKSHARE\n+            AA = BB\n+            CC = DD\n+            WHERE (EE .ne. 0) FF = 1 / EE\n+            GG = HH\n+!$OMP END WORKSHARE\n+!$OMP END PARALLEL\n+      END SUBROUTINE A11_4"}, {"sha": "6b8e4fa3debc4dd2b0abe5dbc9dea62c8d5fff46", "filename": "gcc/testsuite/gfortran.dg/gomp/appendix-a/a.11.5.f90", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.11.5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.11.5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.11.5.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,14 @@\n+! { dg-do compile }\n+        SUBROUTINE A11_5(AA, BB, CC, DD, N)\n+        INTEGER N\n+        REAL AA(N,N), BB(N,N), CC(N,N), DD(N,N)\n+        INTEGER SHR\n+!$OMP PARALLEL SHARED(SHR)\n+!$OMP WORKSHARE\n+            AA = BB\n+            SHR = 1\n+            CC = DD * SHR\n+!$OMP END WORKSHARE\n+!$OMP END PARALLEL\n+      END SUBROUTINE A11_5\n+"}, {"sha": "fa31bcffcd3b1df456379f701ac6906642405596", "filename": "gcc/testsuite/gfortran.dg/gomp/appendix-a/a.11.6.f90", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.11.6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.11.6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.11.6.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,14 @@\n+! { dg-do compile }\n+\n+      SUBROUTINE A11_6_WRONG(AA, BB, CC, DD, N)\n+      INTEGER N\n+      REAL AA(N,N), BB(N,N), CC(N,N), DD(N,N)\n+        INTEGER PRI\n+!$OMP PARALLEL PRIVATE(PRI)\n+!$OMP WORKSHARE\n+            AA = BB\n+            PRI = 1\n+            CC = DD * PRI\n+!$OMP END WORKSHARE\n+!$OMP END PARALLEL\n+      END SUBROUTINE A11_6_WRONG"}, {"sha": "86b8c7bc5b52e95b74fde0b3a1d75b1c44c36f6f", "filename": "gcc/testsuite/gfortran.dg/gomp/appendix-a/a.11.7.f90", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.11.7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.11.7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.11.7.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,11 @@\n+! { dg-do compile }\n+      SUBROUTINE A11_7(AA, BB, CC, N)\n+      INTEGER N\n+      REAL AA(N), BB(N), CC(N)\n+!$OMP PARALLEL\n+!$OMP WORKSHARE\n+            AA(1:50) = BB(11:60)\n+            CC(11:20) = AA(1:10)\n+!$OMP END WORKSHARE\n+!$OMP END PARALLEL\n+      END SUBROUTINE A11_7"}, {"sha": "38389e4f4a6f6b08e9d48b1de94507e376941d14", "filename": "gcc/testsuite/gfortran.dg/gomp/appendix-a/a.12.1.f90", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.12.1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.12.1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.12.1.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,32 @@\n+! { dg-do compile }\n+      SUBROUTINE A12( X, XOLD, N, TOL )\n+      REAL X(*), XOLD(*), TOL\n+      INTEGER N\n+      INTEGER C, I, TOOBIG\n+      REAL ERROR, Y, AVERAGE\n+      EXTERNAL AVERAGE\n+      C=0\n+      TOOBIG = 1\n+!$OMP PARALLEL\n+        DO WHILE( TOOBIG > 0 )\n+!$OMP DO PRIVATE(I)\n+            DO I = 2, N-1\n+               XOLD(I) = X(I)\n+            ENDDO\n+!$OMP SINGLE\n+            TOOBIG = 0\n+!$OMP END SINGLE\n+!$OMP DO PRIVATE(I,Y,ERROR), REDUCTION(+:TOOBIG)\n+            DO I = 2, N-1\n+               Y = X(I)\n+               X(I) = AVERAGE( XOLD(I-1), X(I), XOLD(I+1) )\n+               ERROR = Y-X(I)\n+               IF( ERROR > TOL .OR. ERROR < -TOL ) TOOBIG = TOOBIG+1\n+            ENDDO\n+!$OMP MASTER\n+            C=C+1\n+            PRINT *, \"Iteration \", C, \" TOOBIG=\", TOOBIG\n+!$OMP END MASTER\n+        ENDDO\n+!$OMP END PARALLEL\n+      END SUBROUTINE A12"}, {"sha": "57f5b8912fc64c1b87b5295ba5a1a05003d219e2", "filename": "gcc/testsuite/gfortran.dg/gomp/appendix-a/a.13.1.f90", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.13.1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.13.1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.13.1.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,16 @@\n+! { dg-do compile }\n+        SUBROUTINE A13(X, Y)\n+        REAL X(*), Y(*)\n+        INTEGER IX_NEXT, IY_NEXT\n+!$OMP PARALLEL SHARED(X, Y) PRIVATE(IX_NEXT, IY_NEXT)\n+!$OMP CRITICAL(XAXIS)\n+        CALL DEQUEUE(IX_NEXT, X)\n+!$OMP END CRITICAL(XAXIS)\n+        CALL WORK(IX_NEXT, X)\n+!$OMP CRITICAL(YAXIS)\n+        CALL DEQUEUE(IY_NEXT,Y)\n+!$OMP END CRITICAL(YAXIS)\n+        CALL WORK(IY_NEXT, Y)\n+!$OMP END PARALLEL\n+      END SUBROUTINE A13\n+"}, {"sha": "6db107afa4a5cef32bcff3f911221d6b4cf1b7d4", "filename": "gcc/testsuite/gfortran.dg/gomp/appendix-a/a.14.1.f90", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.14.1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.14.1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.14.1.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,15 @@\n+! { dg-do compile }\n+      SUBROUTINE A14()\n+        INTEGER I\n+        I=1\n+!$OMP PARALLEL SECTIONS\n+!$OMP SECTION\n+!$OMP CRITICAL (NAME)\n+!$OMP PARALLEL\n+!$OMP SINGLE\n+                  I=I+1\n+!$OMP END SINGLE\n+!$OMP END PARALLEL\n+!$OMP END CRITICAL (NAME)\n+!$OMP END PARALLEL SECTIONS\n+      END SUBROUTINE A14"}, {"sha": "8fd600176caccda570051d4975f5bc80921b6ff4", "filename": "gcc/testsuite/gfortran.dg/gomp/appendix-a/a.17.1.f90", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.17.1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.17.1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.17.1.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,14 @@\n+! { dg-do compile }\n+      SUBROUTINE A17_1_WRONG()\n+        INTEGER:: I\n+        REAL:: R\n+        EQUIVALENCE(I,R)\n+!$OMP PARALLEL\n+!$OMP ATOMIC\n+            I=I+1\n+!$OMP ATOMIC\n+            R = R + 1.0\n+! incorrect because I and R reference the same location\n+! but have different types\n+!$OMP END PARALLEL\n+        END SUBROUTINE A17_1_WRONG"}, {"sha": "a19db8c0dc9243f1d0743c3eb1ca6e10e14134cf", "filename": "gcc/testsuite/gfortran.dg/gomp/appendix-a/a.17.2.f90", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.17.2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.17.2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.17.2.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,19 @@\n+! { dg-do compile }\n+\n+      SUBROUTINE SUB()\n+        COMMON /BLK/ R\n+        REAL R\n+!$OMP ATOMIC\n+        R = R + 1.0\n+      END SUBROUTINE SUB\n+\n+      SUBROUTINE A17_2_WRONG()\n+      COMMON /BLK/ I\n+      INTEGER I\n+!$OMP PARALLEL\n+!$OMP ATOMIC\n+            I=I+1\n+          CALL SUB()\n+!$OMP END PARALLEL\n+      END SUBROUTINE A17_2_WRONG\n+"}, {"sha": "4f4f55c0943b134599e083faffd21dd51ff31c56", "filename": "gcc/testsuite/gfortran.dg/gomp/appendix-a/a.17.3.f90", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.17.3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.17.3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.17.3.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,18 @@\n+! { dg-do compile }\n+      SUBROUTINE A17_3_WRONG\n+        INTEGER:: I\n+        REAL:: R\n+        EQUIVALENCE(I,R)\n+!$OMP PARALLEL\n+!$OMP ATOMIC\n+            I=I+1\n+! incorrect because I and R reference the same location\n+! but have different types\n+!$OMP END PARALLEL\n+!$OMP PARALLEL\n+!$OMP ATOMIC\n+            R = R + 1.0\n+! incorrect because I and R reference the same location\n+! but have different types\n+!$OMP END PARALLEL\n+      END SUBROUTINE A17_3_WRONG"}, {"sha": "87359a152a66eed1406392483a8f2dc3bae58463", "filename": "gcc/testsuite/gfortran.dg/gomp/appendix-a/a.21.2.f90", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.21.2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.21.2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.21.2.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,20 @@\n+! { dg-do compile }\n+\n+      SUBROUTINE WORK(I)\n+      INTEGER I\n+      END SUBROUTINE WORK\n+      SUBROUTINE A21_WRONG(N)\n+      INTEGER N\n+        INTEGER I\n+!$OMP DO ORDERED\n+        DO I = 1, N\n+! incorrect because an iteration may not execute more than one\n+! ordered region\n+!$OMP ORDERED\n+            CALL WORK(I)\n+!$OMP END ORDERED\n+!$OMP ORDERED\n+            CALL WORK(I+1)\n+!$OMP END ORDERED\n+        END DO\n+      END SUBROUTINE A21_WRONG"}, {"sha": "97ca8f45812b9fcd8cfd617ef77be9201fe4dc53", "filename": "gcc/testsuite/gfortran.dg/gomp/appendix-a/a.21.3.f90", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.21.3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.21.3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.21.3.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,18 @@\n+! { dg-do compile }\n+\n+      SUBROUTINE A21_GOOD(N)\n+      INTEGER N\n+!$OMP DO ORDERED\n+        DO I = 1,N\n+          IF (I <= 10) THEN\n+!$OMP ORDERED\n+              CALL WORK(I)\n+!$OMP END ORDERED\n+          ENDIF\n+          IF (I > 10) THEN\n+!$OMP ORDERED\n+              CALL WORK(I+1)\n+!$OMP END ORDERED\n+          ENDIF\n+        ENDDO\n+      END SUBROUTINE A21_GOOD"}, {"sha": "cc94b140384c55e9fdfd20f1ae1d0ab2f6f5e4ae", "filename": "gcc/testsuite/gfortran.dg/gomp/appendix-a/a.22.1.f90", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.22.1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.22.1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.22.1.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,10 @@\n+! { dg-do compile }\n+! { dg-require-effective-target tls }\n+\n+      INTEGER FUNCTION INCREMENT_COUNTER()\n+        COMMON/A22_COMMON/COUNTER\n+!$OMP THREADPRIVATE(/A22_COMMON/)\n+        COUNTER = COUNTER +1\n+        INCREMENT_COUNTER = COUNTER\n+        RETURN\n+      END FUNCTION INCREMENT_COUNTER"}, {"sha": "f769fc18f3e79aaf8641412ca18a533769beed33", "filename": "gcc/testsuite/gfortran.dg/gomp/appendix-a/a.22.4.f90", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.22.4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.22.4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.22.4.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,11 @@\n+! { dg-do compile }\n+! { dg-require-effective-target tls }\n+\n+      MODULE A22_MODULE\n+      COMMON /T/ A\n+      END MODULE A22_MODULE\n+      SUBROUTINE A22_4_WRONG()\n+        USE A22_MODULE\n+!$OMP THREADPRIVATE(/T/)\t! { dg-error \"COMMON block\" }\n+      !non-conforming because /T/ not declared in A22_4_WRONG\n+      END SUBROUTINE A22_4_WRONG"}, {"sha": "6531d826c576d8a77bfc59f89f062a7ca8200a4f", "filename": "gcc/testsuite/gfortran.dg/gomp/appendix-a/a.22.5.f90", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.22.5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.22.5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.22.5.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,13 @@\n+! { dg-do compile }\n+! { dg-require-effective-target tls }\n+\n+      SUBROUTINE A22_5_WRONG()\n+        COMMON /T/ A\n+!$OMP THREADPRIVATE(/T/)\n+        CONTAINS\n+          SUBROUTINE A22_5S_WRONG()\n+!$OMP PARALLEL COPYIN(/T/)\t! { dg-error \"COMMON block\" }\n+      !non-conforming because /T/ not declared in A22_5S_WRONG\n+!$OMP END PARALLEL\t\t! { dg-error \"Unexpected\" }\n+          END SUBROUTINE A22_5S_WRONG\n+      END SUBROUTINE A22_5_WRONG"}, {"sha": "0a2e6a6836f88d07797700ffd3f9a24bb619c094", "filename": "gcc/testsuite/gfortran.dg/gomp/appendix-a/a.22.6.f90", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.22.6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.22.6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.22.6.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,14 @@\n+! { dg-do compile }\n+! { dg-require-effective-target tls }\n+\n+       SUBROUTINE A22_6_GOOD()\n+             COMMON /T/ A\n+!$OMP THREADPRIVATE(/T/)\n+       CONTAINS\n+         SUBROUTINE A22_6S_GOOD()\n+           COMMON /T/ A\n+!$OMP THREADPRIVATE(/T/)\n+!$OMP PARALLEL COPYIN(/T/)\n+!$OMP END PARALLEL\n+        END SUBROUTINE A22_6S_GOOD\n+      END SUBROUTINE A22_6_GOOD"}, {"sha": "6eab6872985cae5b5929670d511ef1cee5d10ad8", "filename": "gcc/testsuite/gfortran.dg/gomp/appendix-a/a.23.1.f90", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.23.1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.23.1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.23.1.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,11 @@\n+! { dg-do compile }\n+      SUBROUTINE A23_1_GOOD()\n+        COMMON /C/ X,Y\n+        REAL X, Y\n+!$OMP PARALLEL PRIVATE (/C/)\n+          ! do work here\n+!$OMP END PARALLEL\n+!$OMP PARALLEL SHARED (X,Y)\n+          ! do work here\n+!$OMP END PARALLEL\n+      END SUBROUTINE A23_1_GOOD"}, {"sha": "ecfdbe5a2a0c8ca2a5dd60884b061309f288e92d", "filename": "gcc/testsuite/gfortran.dg/gomp/appendix-a/a.23.2.f90", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.23.2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.23.2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.23.2.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,19 @@\n+! { dg-do compile }\n+      SUBROUTINE A23_2_GOOD()\n+         COMMON /C/ X,Y\n+         REAL X, Y\n+         INTEGER I\n+!$OMP PARALLEL\n+!$OMP DO PRIVATE(/C/)\n+           DO I=1,1000\n+             ! do work here\n+           ENDDO\n+!$OMP END DO\n+!\n+!$OMP DO PRIVATE(X)\n+           DO I=1,1000\n+             ! do work here\n+           ENDDO\n+!$OMP END DO\n+!$OMP END PARALLEL\n+       END SUBROUTINE A23_2_GOOD"}, {"sha": "abd80410284b6cca47b6c152f40ccc19ea6df26b", "filename": "gcc/testsuite/gfortran.dg/gomp/appendix-a/a.23.3.f90", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.23.3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.23.3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.23.3.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,11 @@\n+! { dg-do compile }\n+\n+      SUBROUTINE A23_3_GOOD()\n+        COMMON /C/ X,Y\n+!$OMP PARALLEL PRIVATE (/C/)\n+          ! do work here\n+!$OMP END PARALLEL\n+!$OMP PARALLEL SHARED (/C/)\n+          ! do work here\n+!$OMP END PARALLEL\n+      END SUBROUTINE A23_3_GOOD"}, {"sha": "8c6e2281d17ffba645780f06224f071c5130e000", "filename": "gcc/testsuite/gfortran.dg/gomp/appendix-a/a.23.4.f90", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.23.4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.23.4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.23.4.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,9 @@\n+! { dg-do compile }\n+\n+        SUBROUTINE A23_4_WRONG()\n+        COMMON /C/ X,Y\n+! Incorrect because X is a constituent element of C\n+!$OMP PARALLEL PRIVATE(/C/), SHARED(X)\t! { dg-error \"Symbol 'x' present\" }\n+          ! do work here\n+!$OMP END PARALLEL\n+      END SUBROUTINE A23_4_WRONG"}, {"sha": "732c15f2385283ccaafdadcc48820f50a2285a55", "filename": "gcc/testsuite/gfortran.dg/gomp/appendix-a/a.23.5.f90", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.23.5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.23.5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.23.5.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,12 @@\n+! { dg-do compile }\n+\n+      SUBROUTINE A23_5_WRONG()\n+        COMMON /C/ X,Y\n+! Incorrect: common block C cannot be declared both\n+! shared and private\n+!$OMP PARALLEL PRIVATE (/C/), SHARED(/C/)\n+          ! { dg-error \"Symbol 'y' present\" \"\" { target *-*-* } 7 }\n+          ! { dg-error \"Symbol 'x' present\" \"\" { target *-*-* } 7 }\n+          ! do work here\n+!$OMP END PARALLEL\n+      END SUBROUTINE A23_5_WRONG"}, {"sha": "e5b95450d28bbba2cfd7e49836cc108adc37b63e", "filename": "gcc/testsuite/gfortran.dg/gomp/appendix-a/a.24.1.f90", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.24.1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.24.1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.24.1.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,31 @@\n+! { dg-do compile }\n+! { dg-require-effective-target tls }\n+\n+      SUBROUTINE A24(A)\n+      INTEGER A\n+      INTEGER X, Y, Z(1000)\n+      INTEGER OMP_GET_NUM_THREADS\n+      COMMON/BLOCKX/X\n+      COMMON/BLOCKY/Y\n+      COMMON/BLOCKZ/Z\n+!$OMP THREADPRIVATE(/BLOCKX/)\n+      INTEGER I, J\n+      i=1\n+!$OMP PARALLEL DEFAULT(NONE) PRIVATE(A) SHARED(Z) PRIVATE(J)\n+      J = OMP_GET_NUM_THREADS();\n+               ! O.K. - J is listed in PRIVATE clause\n+      A = Z(J) ! O.K. - A is listed in PRIVATE clause\n+               !       - Z is listed in SHARED clause\n+      X=1      ! O.K. - X is THREADPRIVATE\n+      Z(I) = Y ! Error - cannot reference I or Y here\n+! { dg-error \"'i' not specified\" \"\" { target *-*-* } 20 } */\n+! { dg-error \"enclosing parallel\" \"\" { target *-*-* } 14 } */\n+! { dg-error \"'y' not specified\" \"\" { target *-*-* } 20 }  */\n+!$OMP DO firstprivate(y)\n+      DO I = 1,10\n+        Z(I) = Y ! O.K. - I is the loop iteration variable\n+                 ! Y is listed in FIRSTPRIVATE clause\n+      END DO\n+      Z(I) = Y    ! Error - cannot reference I or Y here\n+!$OMP END PARALLEL\n+      END SUBROUTINE A24"}, {"sha": "66bfba80ed19d8be30b5c0696f08c199b1fadd84", "filename": "gcc/testsuite/gfortran.dg/gomp/appendix-a/a.25.1.f90", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.25.1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.25.1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.25.1.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,19 @@\n+! { dg-do compile }\n+\n+        SUBROUTINE A25\n+        INTEGER OMP_GET_THREAD_NUM\n+        REAL A(20)\n+        INTEGER MYTHREAD\n+        !$OMP PARALLEL SHARED(A) PRIVATE(MYTHREAD)\n+        MYTHREAD = OMP_GET_THREAD_NUM()\n+        IF (MYTHREAD .EQ. 0) THEN\n+            CALL SUB(A(1:10)) ! compiler may introduce writes to A(6:10)\n+        ELSE\n+            A(6:10) = 12\n+        ENDIF\n+        !$OMP END PARALLEL\n+        END SUBROUTINE A25\n+        SUBROUTINE SUB(X)\n+        REAL X(*)\n+        X(1:5) = 4\n+        END SUBROUTINE SUB"}, {"sha": "97c14d945d1ddeb8fea116aa239ec712bf3044d6", "filename": "gcc/testsuite/gfortran.dg/gomp/appendix-a/a.26.2.f90", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.26.2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.26.2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.26.2.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,22 @@\n+! { dg-do compile }\n+\n+       MODULE A26_2\n+       REAL A\n+       CONTAINS\n+         SUBROUTINE G(K)\n+           REAL K\n+           A = K ! This is A in module A26_2, not the private\n+                  ! A in F\n+         END SUBROUTINE G\n+         SUBROUTINE F(N)\n+         INTEGER N\n+         REAL A\n+            INTEGER I\n+!$OMP PARALLEL DO PRIVATE(A)\n+              DO I = 1,N\n+                A=I\n+                CALL G(A*2)\n+              ENDDO\n+!$OMP END PARALLEL DO\n+          END SUBROUTINE F\n+      END MODULE A26_2"}, {"sha": "f564bd380c2eac61ecc4a1a8376d4bcac6d7d60d", "filename": "gcc/testsuite/gfortran.dg/gomp/appendix-a/a.27.1.f90", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.27.1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.27.1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.27.1.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,12 @@\n+! { dg-do compile }\n+\n+       SUBROUTINE A27()\n+         INTEGER I, A\n+!$OMP PARALLEL PRIVATE(A)\n+!$OMP PARALLEL DO PRIVATE(A)\n+           DO I = 1, 10\n+              ! do work here\n+          END DO\n+!$OMP END PARALLEL DO\n+!$OMP END PARALLEL\n+      END SUBROUTINE A27"}, {"sha": "e62cbf81bbcac12045706ab4ff439878e21ed81a", "filename": "gcc/testsuite/gfortran.dg/gomp/appendix-a/a.30.1.f90", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.30.1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.30.1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.30.1.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,14 @@\n+! { dg-do compile }\n+\n+      SUBROUTINE A30(N, A, B)\n+       INTEGER N\n+       REAL A(*), B(*)\n+        INTEGER I\n+!$OMP PARALLEL\n+!$OMP DO LASTPRIVATE(I)\n+        DO I=1,N-1\n+          A(I) = B(I) + B(I+1)\n+        ENDDO\n+!$OMP END PARALLEL\n+        A(I) = B(I)      ! I has the value of N here\n+      END SUBROUTINE A30"}, {"sha": "294926bfdcad85fdc90e994b2eccbf8d70a6d744", "filename": "gcc/testsuite/gfortran.dg/gomp/appendix-a/a.31.1.f90", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.31.1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.31.1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.31.1.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,15 @@\n+! { dg-do compile }\n+\n+      SUBROUTINE A31_1(A, B, X, Y, N)\n+        INTEGER N\n+        REAL X(*), Y(*), A, B\n+!$OMP PARALLEL DO PRIVATE(I) SHARED(X, N) REDUCTION(+:A)\n+!$OMP& REDUCTION(MIN:B)\n+        DO I=1,N\n+           A = A + X(I)\n+           B = MIN(B, Y(I))\n+!  Note that some reductions can be expressed in\n+!  other forms. For example, the MIN could be expressed as\n+!  IF (B > Y(I)) B = Y(I)\n+         END DO\n+      END SUBROUTINE A31_1"}, {"sha": "f78188c7c28c8c449587ed42dcc51c456c247d48", "filename": "gcc/testsuite/gfortran.dg/gomp/appendix-a/a.31.2.f90", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.31.2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.31.2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.31.2.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,20 @@\n+! { dg-do compile }\n+\n+       SUBROUTINE A31_2 (A, B, X, Y, N)\n+         INTEGER N\n+         REAL X(*), Y(*), A, B, A_P, B_P\n+!$OMP PARALLEL SHARED(X, Y, N, A, B) PRIVATE(A_P, B_P)\n+        A_P = 0.0\n+        B_P = HUGE(B_P)\n+!$OMP DO PRIVATE(I)\n+        DO I=1,N\n+          A_P = A_P + X(I)\n+          B_P = MIN(B_P, Y(I))\n+        ENDDO\n+!$OMP END DO\n+!$OMP CRITICAL\n+          A = A + A_P\n+          B = MIN(B, B_P)\n+!$OMP END CRITICAL\n+!$OMP END PARALLEL\n+      END SUBROUTINE A31_2"}, {"sha": "f67c91c215b0b6f680be02d04d53b7c5347601ec", "filename": "gcc/testsuite/gfortran.dg/gomp/appendix-a/a.31.3.f90", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.31.3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.31.3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.31.3.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,15 @@\n+! { dg-do compile }\n+        PROGRAM A31_3_WRONG\n+        MAX = HUGE(0)\n+        M=0\n+        !$OMP PARALLEL DO REDUCTION(MAX: M) ! MAX is no longer the\n+                                            ! intrinsic so this\n+                                            ! is non-conforming\n+! { dg-error \"is not INTRINSIC procedure name\" \"\" { target *-*-* } 5 } */\n+        DO I = 1, 100\n+        CALL SUB(M,I)\n+        END DO\n+        END PROGRAM A31_3_WRONG\n+        SUBROUTINE SUB(M,I)\n+        M = MAX(M,I)\n+        END SUBROUTINE SUB"}, {"sha": "8e0b5e093c57f45dc728d1be9a6ac0615d38d9ca", "filename": "gcc/testsuite/gfortran.dg/gomp/appendix-a/a.32.1.f90", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.32.1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.32.1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.32.1.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,24 @@\n+! { dg-do compile }\n+! { dg-require-effective-target tls }\n+\n+      MODULE M\n+        REAL, POINTER, SAVE :: WORK(:)\n+        INTEGER :: SIZE\n+        REAL :: TOL\n+!$OMP THREADPRIVATE(WORK,SIZE,TOL)\n+      END MODULE M\n+      SUBROUTINE A32( T, N )\n+        USE M\n+        REAL :: T\n+        INTEGER :: N\n+        TOL = T\n+        SIZE = N\n+!$OMP PARALLEL COPYIN(TOL,SIZE)\n+        CALL BUILD\n+!$OMP END PARALLEL\n+      END SUBROUTINE A32\n+      SUBROUTINE BUILD\n+        USE M\n+        ALLOCATE(WORK(SIZE))\n+        WORK = TOL\n+      END SUBROUTINE BUILD"}, {"sha": "05145b1715f460339ff61ecca233361d64f303bf", "filename": "gcc/testsuite/gfortran.dg/gomp/appendix-a/a.33.1.f90", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.33.1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.33.1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.33.1.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,11 @@\n+! { dg-do compile }\n+! { dg-require-effective-target tls }\n+\n+      SUBROUTINE INIT(A,B)\n+      REAL A, B\n+        COMMON /XY/ X,Y\n+!$OMP THREADPRIVATE (/XY/)\n+!$OMP SINGLE\n+          READ (11) A,B,X,Y\n+!$OMP END SINGLE COPYPRIVATE (A,B,/XY/)\n+      END SUBROUTINE INIT"}, {"sha": "ced23c856b4d87142ffbaa3d1f7dda536a29f03b", "filename": "gcc/testsuite/gfortran.dg/gomp/appendix-a/a.33.2.f90", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.33.2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.33.2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.33.2.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,17 @@\n+! { dg-do compile }\n+\n+      REAL FUNCTION READ_NEXT()\n+        REAL, POINTER :: TMP\n+!$OMP SINGLE\n+          ALLOCATE (TMP)\n+!$OMP END SINGLE COPYPRIVATE (TMP) ! copies the pointer only\n+!$OMP MASTER\n+          READ (11) TMP\n+!$OMP END MASTER\n+!$OMP BARRIER\n+          READ_NEXT = TMP\n+!$OMP BARRIER\n+!$OMP SINGLE\n+          DEALLOCATE (TMP)\n+!$OMP END SINGLE NOWAIT\n+      END FUNCTION READ_NEXT"}, {"sha": "9685b5939c81575aeaea22a734fa502c10bea527", "filename": "gcc/testsuite/gfortran.dg/gomp/appendix-a/a.33.4.f90", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.33.4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.33.4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.33.4.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,19 @@\n+! { dg-do compile }\n+        SUBROUTINE S(N)\n+        INTEGER N\n+        REAL, DIMENSION(:), ALLOCATABLE :: A\n+        REAL, DIMENSION(:), POINTER :: B\n+        ALLOCATE (A(N))\n+!$OMP SINGLE            ! { dg-error \"COPYPRIVATE clause object 'a'\" }\n+            ALLOCATE (B(N))\n+        READ (11) A,B\n+!$OMP END SINGLE COPYPRIVATE(A,B)\n+        ! Variable A designates a private object\n+        !   which has the same value in each thread\n+        ! Variable B designates a shared object\n+!$OMP BARRIER\n+!$OMP SINGLE\n+          DEALLOCATE (B)\n+!$OMP END SINGLE NOWAIT\n+      END SUBROUTINE S\n+"}, {"sha": "29ea952cb364b7a336762ca59b1adbc9a64a4436", "filename": "gcc/testsuite/gfortran.dg/gomp/appendix-a/a.34.1.f90", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.34.1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.34.1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.34.1.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,19 @@\n+! { dg-do compile }\n+      SUBROUTINE WORK(I, J)\n+      INTEGER I, J\n+      END SUBROUTINE WORK\n+      SUBROUTINE GOOD_NESTING(N)\n+      INTEGER N\n+        INTEGER I\n+!$OMP PARALLEL DEFAULT(SHARED)\n+!$OMP DO\n+          DO I = 1, N\n+!$OMP PARALLEL SHARED(I,N)\n+!$OMP DO\n+               DO J = 1, N\n+                  CALL WORK(I,J)\n+               END DO\n+!$OMP END PARALLEL\n+          END DO\n+!$OMP END PARALLEL\n+      END SUBROUTINE GOOD_NESTING"}, {"sha": "980a623726a69e1014859a458e7ac03e8d19add3", "filename": "gcc/testsuite/gfortran.dg/gomp/appendix-a/a.34.2.f90", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.34.2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.34.2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.34.2.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,22 @@\n+! { dg-do compile }\n+      SUBROUTINE WORK(I, J)\n+      INTEGER I, J\n+      END SUBROUTINE WORK\n+      SUBROUTINE WORK1(I, N)\n+      INTEGER J\n+!$OMP PARALLEL DEFAULT(SHARED)\n+!$OMP DO\n+         DO J = 1, N\n+           CALL WORK(I,J)\n+         END DO\n+!$OMP END PARALLEL\n+      END SUBROUTINE WORK1\n+      SUBROUTINE GOOD_NESTING2(N)\n+      INTEGER N\n+!$OMP PARALLEL DEFAULT(SHARED)\n+!$OMP DO\n+      DO I = 1, N\n+          CALL WORK1(I, N)\n+      END DO\n+!$OMP END PARALLEL\n+      END SUBROUTINE GOOD_NESTING2"}, {"sha": "7325e34005e22db98442bc8c1313bd60c750e598", "filename": "gcc/testsuite/gfortran.dg/gomp/appendix-a/a.35.1.f90", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.35.1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.35.1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.35.1.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,18 @@\n+! { dg-do compile }\n+\n+      SUBROUTINE WORK(I, J)\n+      INTEGER I, J\n+      END SUBROUTINE WORK\n+      SUBROUTINE WRONG1(N)\n+      INTEGER N\n+        INTEGER I,J\n+!$OMP PARALLEL DEFAULT(SHARED)\n+!$OMP DO\n+          DO I = 1, N\n+!$OMP DO              ! incorrect nesting of loop regions\n+             DO J = 1, N\n+                CALL WORK(I,J)\n+             END DO\n+          END DO\n+!$OMP END PARALLEL\n+      END SUBROUTINE WRONG1"}, {"sha": "5fad2c05f7abf545a7821623feeda2d8bb781645", "filename": "gcc/testsuite/gfortran.dg/gomp/appendix-a/a.35.2.f90", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.35.2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.35.2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.35.2.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,20 @@\n+! { dg-do compile }\n+\n+      SUBROUTINE WORK1(I,N)\n+      INTEGER I, N\n+        INTEGER J\n+!$OMP DO        ! incorrect nesting of loop regions\n+        DO J = 1, N\n+           CALL WORK(I,J)\n+        END DO\n+      END SUBROUTINE WORK1\n+      SUBROUTINE WRONG2(N)\n+      INTEGER N\n+        INTEGER I\n+!$OMP PARALLEL DEFAULT(SHARED)\n+!$OMP DO\n+           DO I = 1, N\n+              CALL WORK1(I,N)\n+           END DO\n+!$OMP END PARALLEL\n+      END SUBROUTINE WRONG2"}, {"sha": "63a558f72ab9d7dd7db5ffa2ddde3daa3a9df8ba", "filename": "gcc/testsuite/gfortran.dg/gomp/appendix-a/a.35.3.f90", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.35.3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.35.3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.35.3.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,14 @@\n+! { dg-do compile }\n+\n+      SUBROUTINE WRONG3(N)\n+      INTEGER N\n+        INTEGER I\n+!$OMP PARALLEL DEFAULT(SHARED)\n+!$OMP DO\n+          DO I = 1, N\n+!$OMP SINGLE            ! incorrect nesting of regions\n+               CALL WORK(I, 1)\n+!$OMP END SINGLE\n+          END DO\n+!$OMP END PARALLEL\n+      END SUBROUTINE WRONG3"}, {"sha": "e44952263f1ac39d34a4db2b90bb4f92cd14f814", "filename": "gcc/testsuite/gfortran.dg/gomp/appendix-a/a.35.4.f90", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.35.4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.35.4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.35.4.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,15 @@\n+! { dg-do compile }\n+\n+      SUBROUTINE WRONG4(N)\n+      INTEGER N\n+        INTEGER I\n+!$OMP PARALLEL DEFAULT(SHARED)\n+!$OMP DO\n+          DO I = 1, N\n+             CALL WORK(I, 1)\n+! incorrect nesting of barrier region in a loop region\n+!$OMP BARRIER\n+             CALL WORK(I, 2)\n+          END DO\n+!$OMP END PARALLEL\n+      END SUBROUTINE WRONG4"}, {"sha": "083c0b3b7232efb217acdee83eb3324e8a833d18", "filename": "gcc/testsuite/gfortran.dg/gomp/appendix-a/a.35.5.f90", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.35.5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.35.5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.35.5.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,13 @@\n+! { dg-do compile }\n+\n+      SUBROUTINE WRONG5(N)\n+      INTEGER N\n+!$OMP PARALLEL DEFAULT(SHARED)\n+!$OMP CRITICAL\n+            CALL WORK(N,1)\n+! incorrect nesting of barrier region in a critical region\n+!$OMP BARRIER\n+            CALL WORK(N,2)\n+!$OMP END CRITICAL\n+!$OMP END PARALLEL\n+      END SUBROUTINE WRONG5"}, {"sha": "0488537dd1039de6e3c8a07cfefeec710ca2c2db", "filename": "gcc/testsuite/gfortran.dg/gomp/appendix-a/a.35.6.f90", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.35.6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.35.6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.35.6.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,14 @@\n+! { dg-do compile }\n+\n+         SUBROUTINE WRONG6(N)\n+         INTEGER N\n+!$OMP PARALLEL DEFAULT(SHARED)\n+!$OMP SINGLE\n+           CALL WORK(N,1)\n+! incorrect nesting of barrier region in a single region\n+!$OMP BARRIER\n+            CALL WORK(N,2)\n+!$OMP END SINGLE\n+!$OMP END PARALLEL\n+      END SUBROUTINE WRONG6\n+"}, {"sha": "be68188ec981c84c8eab179020cf87b6697137b9", "filename": "gcc/testsuite/gfortran.dg/gomp/appendix-a/a.36.1.f90", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.36.1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.36.1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.36.1.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,23 @@\n+! { dg-do compile }\n+\n+      SUBROUTINE DO_BY_16(X, IAM, IPOINTS)\n+        REAL X(*)\n+        INTEGER IAM, IPOINTS\n+      END SUBROUTINE DO_BY_16\n+      SUBROUTINE SUBA36(X, NPOINTS)\n+        INTEGER NPOINTS\n+        REAL X(NPOINTS)\n+        INTEGER IAM, IPOINTS\n+        EXTERNAL OMP_SET_DYNAMIC, OMP_SET_NUM_THREADS\n+        INTEGER OMP_GET_NUM_THREADS, OMP_GET_THREAD_NUM\n+        CALL OMP_SET_DYNAMIC(.FALSE.)\n+        CALL OMP_SET_NUM_THREADS(16)\n+!$OMP PARALLEL SHARED(X,NPOINTS) PRIVATE(IAM, IPOINTS)\n+          IF (OMP_GET_NUM_THREADS() .NE. 16) THEN\n+            STOP\n+          ENDIF\n+          IAM = OMP_GET_THREAD_NUM()\n+          IPOINTS = NPOINTS/16\n+          CALL DO_BY_16(X,IAM,IPOINTS)\n+!$OMP END PARALLEL\n+      END SUBROUTINE SUBA36"}, {"sha": "473c1fec826b92756e0ecffdf15323965fa72090", "filename": "gcc/testsuite/gfortran.dg/gomp/appendix-a/a.37.1.f90", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.37.1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.37.1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.37.1.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,15 @@\n+! { dg-do compile }\n+      SUBROUTINE WORK(I)\n+      INTEGER I\n+        I=I+1\n+      END SUBROUTINE WORK\n+      SUBROUTINE INCORRECT()\n+        INTEGER OMP_GET_NUM_THREADS\n+        INTEGER I, NP\n+        NP = OMP_GET_NUM_THREADS()   !misplaced: will return 1\n+!$OMP PARALLEL DO SCHEDULE(STATIC)\n+          DO I = 0, NP-1\n+            CALL WORK(I)\n+          ENDDO\n+!$OMP END PARALLEL DO\n+      END SUBROUTINE INCORRECT"}, {"sha": "c5fbcbbd0b3cfda632babad380382423f5aa4723", "filename": "gcc/testsuite/gfortran.dg/gomp/appendix-a/a.37.2.f90", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.37.2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.37.2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.37.2.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,13 @@\n+! { dg-do compile }\n+      SUBROUTINE WORK(I)\n+        INTEGER I\n+        I=I+1\n+      END SUBROUTINE WORK\n+      SUBROUTINE CORRECT()\n+        INTEGER OMP_GET_THREAD_NUM\n+        INTEGER I\n+!$OMP PARALLEL PRIVATE(I)\n+          I = OMP_GET_THREAD_NUM()\n+          CALL WORK(I)\n+!$OMP END PARALLEL\n+      END SUBROUTINE CORRECT"}, {"sha": "f1c6c659617f87c853edbbd24f5a03fe27527a83", "filename": "gcc/testsuite/gfortran.dg/gomp/appendix-a/a.6.1.f90", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.6.1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.6.1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.6.1.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,24 @@\n+! { dg-do compile }\n+\n+      SUBROUTINE WORK(I, J)\n+      INTEGER I,J\n+      END SUBROUTINE WORK\n+      SUBROUTINE A6_GOOD()\n+        INTEGER I, J\n+        REAL A(1000)\n+        DO 100 I = 1,10\n+!$OMP DO\n+           DO 100 J = 1,10\n+              CALL WORK(I,J)\n+            100     CONTINUE        ! !$OMP ENDDO implied here\n+!$OMP DO\n+        DO 200 J = 1,10\n+200        A(I) = I + 1\n+!$OMP ENDDO\n+!$OMP DO\n+        DO 300 I = 1,10\n+           DO 300 J = 1,10\n+              CALL WORK(I,J)\n+300     CONTINUE\n+!$OMP ENDDO\n+      END SUBROUTINE A6_GOOD"}, {"sha": "e1388089962cc03faaf82558ff5070e0ff2bdc76", "filename": "gcc/testsuite/gfortran.dg/gomp/appendix-a/a.6.2.f90", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.6.2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.6.2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.6.2.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,15 @@\n+! { dg-do compile }\n+\n+        SUBROUTINE WORK(I, J)\n+        INTEGER I,J\n+        END SUBROUTINE WORK\n+\n+        SUBROUTINE A6_WRONG\n+        INTEGER I, J\n+        DO 100 I = 1,10\n+!$OMP DO\n+        DO 100 J = 1,10\n+        CALL WORK(I,J)\n+        100      CONTINUE\n+!$OMP ENDDO\t! { dg-error \"Unexpected ..OMP END DO statement\" }\n+        END SUBROUTINE A6_WRONG"}, {"sha": "9f3b08d2e5199ca8d1ac9a6df1d7491f3ec965e8", "filename": "gcc/testsuite/gfortran.dg/gomp/appendix-a/a.7.1.f90", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.7.1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.7.1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.7.1.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,12 @@\n+! { dg-do compile }\n+SUBROUTINE A7_1(A,N)\n+INTEGER OMP_GET_THREAD_NUM\n+REAL A(*)\n+INTEGER I, MYOFFSET, N\n+!$OMP PARALLEL PRIVATE(MYOFFSET)\n+       MYOFFSET = OMP_GET_THREAD_NUM()*N\n+       DO I = 1, N\n+          A(MYOFFSET+I) = FLOAT(I)\n+       ENDDO\n+!$OMP END PARALLEL\n+END SUBROUTINE A7_1"}, {"sha": "23f2318764c7df625ccfb3653ab74e6100e622de", "filename": "gcc/testsuite/gfortran.dg/gomp/appendix-a/a.7.2.f90", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.7.2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.7.2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.7.2.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,22 @@\n+! { dg-do compile }\n+\n+SUBROUTINE A7_2(A,B,N,I1,I2)\n+REAL A(*), B(*)\n+INTEGER I1, I2, N\n+!$OMP PARALLEL SHARED(A,B,I1,I2)\n+!$OMP SECTIONS\n+!$OMP SECTION\n+     DO I1 = I1, N\n+       IF (A(I1).NE.0.0) EXIT\n+     ENDDO\n+!$OMP SECTION\n+     DO I2 = I2, N\n+       IF (B(I2).NE.0.0) EXIT\n+     ENDDO\n+!$OMP END SECTIONS\n+!$OMP SINGLE\n+    IF (I1.LE.N) PRINT *, \"ITEMS IN A UP TO \", I1, \" ARE ALL ZERO.\"\n+    IF (I2.LE.N) PRINT *, \"ITEMS IN B UP TO \", I2, \" ARE ALL ZERO.\"\n+!$OMP END SINGLE\n+!$OMP END PARALLEL\n+END SUBROUTINE A7_2"}, {"sha": "f499e7f8979fe849f59e947ade6b7eeba44d03aa", "filename": "gcc/testsuite/gfortran.dg/gomp/appendix-a/a.8.1.f90", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.8.1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.8.1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.8.1.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,18 @@\n+! { dg-do compile }\n+      SUBROUTINE A8(N, M, A, B, Y, Z)\n+         INTEGER N, M\n+         REAL A(*), B(*), Y(*), Z(*)\n+         INTEGER I\n+!$OMP PARALLEL\n+!$OMP DO\n+         DO I=2,N\n+           B(I) = (A(I) + A(I-1)) / 2.0\n+         ENDDO\n+!$OMP END DO NOWAIT\n+!$OMP DO\n+         DO I=1,M\n+           Y(I) = SQRT(Z(I))\n+         ENDDO\n+!$OMP END DO NOWAIT\n+!$OMP END PARALLEL\n+      END SUBROUTINE A8"}, {"sha": "fc7b67de53ec7ba494c395ae8fddc1078e749efe", "filename": "gcc/testsuite/gfortran.dg/gomp/appendix-a/a.9.1.f90", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.9.1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.9.1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fappendix-a%2Fa.9.1.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,11 @@\n+! { dg-do compile }\n+      SUBROUTINE A9()\n+!$OMP PARALLEL SECTIONS\n+!$OMP SECTION\n+        CALL XAXIS()\n+!$OMP SECTION\n+        CALL YAXIS()\n+!$OMP SECTION\n+        CALL ZAXIS()\n+!$OMP END PARALLEL SECTIONS\n+      END SUBROUTINE A9"}, {"sha": "f03602ab2f418a1851fa35c80f43fbd87acc762a", "filename": "gcc/testsuite/gfortran.dg/gomp/block-1.f90", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fblock-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fblock-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fblock-1.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,10 @@\n+! { dg-do compile }\n+\n+!$omp parallel\n+!$omp critical\n+       goto 10\t\t! { dg-error \"invalid exit\" }\n+!$omp end critical\n+ 10    x = 1\n+!$omp end parallel\n+\n+       end"}, {"sha": "fca5606e0324ccc247df121d142a50c835394717", "filename": "gcc/testsuite/gfortran.dg/gomp/crayptr1.f90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fcrayptr1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fcrayptr1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fcrayptr1.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,51 @@\n+! { dg-do compile }\n+! { dg-options \"-fopenmp -fcray-pointer\" }\n+\n+  integer :: a, b, c, d, i\n+  pointer (ip1, a)\n+  pointer (ip2, b)\n+  pointer (ip3, c)\n+  pointer (ip4, d)\n+\n+!$omp parallel shared (a)\t! { dg-error \"Cray pointee 'a' in SHARED clause\" }\n+!$omp end parallel\n+\n+!$omp parallel private (b)\t! { dg-error \"Cray pointee 'b' in PRIVATE clause\" }\n+!$omp end parallel\n+\n+!$omp parallel firstprivate (c)\t! { dg-error \"Cray pointee 'c' in FIRSTPRIVATE clause\" }\n+!$omp end parallel\n+\n+!$omp parallel do lastprivate (d) ! { dg-error \"Cray pointee 'd' in LASTPRIVATE clause\" }\n+  do i = 1, 10\n+    if (i .eq. 10) d = 1\n+  end do\n+!$omp end parallel do\n+\n+!$omp parallel reduction (+: a)\t! { dg-error \"Cray pointee 'a' in REDUCTION clause\" }\n+!$omp end parallel\n+\n+  ip1 = loc (i)\n+!$omp parallel shared (ip1)\n+  a = 2\n+!$omp end parallel\n+\n+!$omp parallel private (ip2, i)\n+  ip2 = loc (i)\n+  b = 1\n+!$omp end parallel\n+\n+  ip3 = loc (i)\n+!$omp parallel firstprivate (ip3) ! { dg-error \"Cray pointer 'ip3' in FIRSTPRIVATE clause\" }\n+!$omp end parallel\n+\n+!$omp parallel do lastprivate (ip4) ! { dg-error \"Cray pointer 'ip4' in LASTPRIVATE clause\" }\n+  do i = 1, 10\n+    if (i .eq. 10) ip4 = loc (i)\n+  end do\n+!$omp end parallel do\n+\n+!$omp parallel reduction (+: ip1) ! { dg-error \"Cray pointer 'ip1' in REDUCTION clause\" }\n+!$omp end parallel\n+\n+end"}, {"sha": "476d7b9e771c2fabaf236620f44f370eba601865", "filename": "gcc/testsuite/gfortran.dg/gomp/crayptr2.f90", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fcrayptr2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fcrayptr2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fcrayptr2.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,17 @@\n+! { dg-do compile }\n+! { dg-options \"-fopenmp -fcray-pointer\" }\n+! { dg-require-effective-target tls }\n+\n+module crayptr2\n+  integer :: e\t\t! { dg-error \"CRAY POINTEE attribute conflicts with THREADPRIVATE\" }\n+  pointer (ip5, e)\n+\n+! The standard is not very clear about this.\n+! Certainly, Cray pointees can't be SAVEd, nor they can be\n+! in COMMON, so the only way to make threadprivate Cray pointees would\n+! be if they are module variables.  But threadprivate pointees don't\n+! make any sense anyway.\n+\n+!$omp threadprivate (e)\n+\n+end module crayptr2"}, {"sha": "be8f5a0f4a7e5f63965a2538c9216410dc5d6b2e", "filename": "gcc/testsuite/gfortran.dg/gomp/crayptr3.f90", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fcrayptr3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fcrayptr3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fcrayptr3.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,22 @@\n+! { dg-do compile }\n+! { dg-options \"-fopenmp -fcray-pointer\" }\n+\n+  integer :: a, b\n+  pointer (ip, a)\n+\n+  b = 2\n+  ip = loc (b)\n+!$omp parallel default (none) shared (ip)\n+  a = 1\n+!$omp end parallel\n+\n+!$omp parallel default (none) private (ip, b)\n+  b = 3\n+  ip = loc (b)\n+  a = 1\n+!$omp end parallel\n+\n+!$omp parallel default (none)\t! { dg-error \"enclosing parallel\" }\n+  a = 1\t\t! { dg-error \"'ip' not specified in enclosing parallel\" }\n+!$omp end parallel\n+end"}, {"sha": "d7da0bd8cc98b081ead45438fe50898b78e5dbfe", "filename": "gcc/testsuite/gfortran.dg/gomp/crayptr4.f90", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fcrayptr4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fcrayptr4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fcrayptr4.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,24 @@\n+! { dg-do compile }\n+! { dg-options \"-fopenmp -fcray-pointer\" }\n+\n+subroutine foo (n)\n+  integer :: a, b (38), n\n+  pointer (ip, a (n + 1))\n+\n+  b = 2\n+  n = 36\n+  ip = loc (b)\n+!$omp parallel default (none) shared (ip)\n+!$omp parallel default (none) shared (ip)\n+  a = 1\n+!$omp end parallel\n+!$omp end parallel\n+\n+!$omp parallel default (none)\n+!$omp parallel default (none) private (ip, b)\n+  b = 3\n+  ip = loc (b)\n+  a = 1\n+!$omp end parallel\n+!$omp end parallel\n+end"}, {"sha": "a9c9cf11df6ccaf621f385450929e93b23b17338", "filename": "gcc/testsuite/gfortran.dg/gomp/do-1.f90", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdo-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdo-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdo-1.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,26 @@\n+! { dg-do compile }\n+! { dg-options \"-O -fopenmp -fdump-tree-omplower\" }\n+\n+subroutine foo (i, j, k, s, a)\n+  integer :: i, j, k, s, a(100), l\n+!$omp parallel do schedule (dynamic, s * 2)\n+  do 100, l = j, k\n+100 a(l) = i\n+!$omp parallel do schedule (dynamic, s * 2)\n+  do 101, l = j, k, 3\n+101 a(l) = i + 1\n+end subroutine foo\n+\n+subroutine bar (i, j, k, s, a)\n+  integer :: i, j, k, s, a(100), l\n+!$omp parallel do schedule (guided, s * 2)\n+  do 100, l = j, k\n+100 a(l) = i\n+!$omp parallel do schedule (guided, s * 2)\n+  do 101, l = j, k, 3\n+101 a(l) = i + 1\n+end subroutine bar\n+\n+! { dg-final { scan-tree-dump-times \"GOMP_parallel_loop_dynamic_start\" 2 \"omplower\" { xfail *-*-* } } }\n+! { dg-final { scan-tree-dump-times \"GOMP_parallel_loop_guided_start\" 2 \"omplower\" { xfail *-*-* } } }\n+! { dg-final { cleanup-tree-dump \"omplower\" } }"}, {"sha": "d61f2ba638d7fa8731bfd59077886071e471724e", "filename": "gcc/testsuite/gfortran.dg/gomp/fixed-1.f", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ffixed-1.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ffixed-1.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ffixed-1.f?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,22 @@\n+C PR fortran/24493\n+C { dg-do compile }\n+C { dg-require-effective-target tls }\n+      INTEGER I, J, K, L, M\n+C$OMP THREADPRIVATE(I)\n+C SOME COMMENT\n+      SAVE I ! ANOTHER COMMENT\n+C$OMP THREADPRIVATE\n+C$OMP+(J) ! OMP DIRECTIVE COMMENT\n+* NORMAL COMMENT\n+c$OMP THREAD! COMMENT\n+C$OMP&PRIVATE! COMMENT\n+*$OMP+    (K)\n+C$OMP THREADPRIVATE (L ! COMMENT\n+*$OMP& , M)\n+      SAVE J, K, L, M\n+      I = 1\n+      J = 2\n+      K = 3\n+      L = 4\n+      M = 5\n+      END"}, {"sha": "f6f9de4441bc6b8bf22a7a087b13648ae0927e38", "filename": "gcc/testsuite/gfortran.dg/gomp/free-1.f90", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ffree-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ffree-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ffree-1.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,8 @@\n+! { dg-require-effective-target tls }\n+\n+subroutine foo\n+integer, save :: i ! Some comment\n+!$omp threadpri&\n+      !$omp&vate (i)\n+i = 1\n+end subroutine"}, {"sha": "0cafd924d79cabcb1e5faeeeda69e88a7021ed77", "filename": "gcc/testsuite/gfortran.dg/gomp/gomp.exp", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fgomp.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fgomp.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fgomp.exp?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,14 @@\n+# GCC testsuite that uses the `dg.exp' driver.\n+\n+# Load support procs.\n+load_lib gfortran-dg.exp\n+\n+# Initialize `dg'.\n+dg-init\n+\n+# Main loop.\n+gfortran-dg-runtest [lsort \\\n+       [find $srcdir/$subdir *.\\[fF\\]{,90,95} ] ] \" -fopenmp\"\n+\n+# All done.\n+dg-finish"}, {"sha": "247f8ae50abb763adf4d4fcee442a1d15c8da8cb", "filename": "gcc/testsuite/gfortran.dg/gomp/omp_atomic1.f90", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fomp_atomic1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fomp_atomic1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fomp_atomic1.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,38 @@\n+! { dg-do compile }\n+subroutine test_atomic\n+    integer (kind = 4) :: a\n+    integer :: b\n+    real :: c, f\n+    double precision :: d\n+    integer, dimension (10) :: e\n+    a = 1\n+    b = 2\n+    c = 3\n+    d = 4\n+    e = 5\n+    f = 6\n+!$omp atomic\n+    a = a + 4\n+!$omp atomic\n+    b = 4 - b\n+!$omp atomic\n+    c = c * 2\n+!$omp atomic\n+    d = 2 / d\n+!$omp atomic\n+    e = 1 ! { dg-error \"must set a scalar variable\" }\n+!$omp atomic\n+    a = a ** 8 ! { dg-error \"assignment operator must be\" }\n+!$omp atomic\n+    b = b + 3 + b ! { dg-error \"cannot reference\" }\n+!$omp atomic\n+    c = c - f + 1 ! { dg-error \"not mathematically equivalent to\" }\n+!$omp atomic\n+    a = ishft (a, 1) ! { dg-error \"assignment intrinsic must be\" }\n+!$omp atomic\n+    c = min (c, 2.1, c) ! { dg-error \"intrinsic arguments except one\" }\n+!$omp atomic\n+    a = max (b, e(1)) ! { dg-error \"intrinsic argument must be 'a'\" }\n+!$omp atomic\n+    d = 12 ! { dg-error \"assignment must have an operator\" }\n+end subroutine test_atomic"}, {"sha": "8851101b92c7ac659fd87d6e05a9d1ffbbd2ae35", "filename": "gcc/testsuite/gfortran.dg/gomp/omp_clauses1.f90", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fomp_clauses1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fomp_clauses1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fomp_clauses1.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,25 @@\n+! { dg-do compile }\n+      subroutine test1\n+\tinteger :: i, j, k, l\n+\tcommon /b/ j, k\n+!$omp parallel shared (i) private (/b/)\n+!$omp end parallel\n+!$omp parallel do shared (/b/), firstprivate (i), lastprivate (i)\n+\tdo l = 1, 10\n+\tend do\n+!$omp end parallel do\n+!$omp parallel shared (j) private (/b/) ! { dg-error \"'j' present on multiple clauses\" }\n+!$omp end parallel\n+!$omp parallel shared (j, j) private (i) ! { dg-error \"'j' present on multiple clauses\" }\n+!$omp end parallel\n+!$omp parallel firstprivate (i, j, i) ! { dg-error \"'i' present on multiple clauses\" }\n+!$omp end parallel\n+!$omp parallel shared (i) private (/b/, /b/) ! { dg-error \"'\\[jk\\]' present on multiple clauses\" }\n+!$omp end parallel\n+!$omp parallel shared (i) reduction (+ : i, j) ! { dg-error \"'i' present on multiple clauses\" }\n+!$omp end parallel\n+!$omp parallel do shared (/b/), firstprivate (/b/), lastprivate (i) ! { dg-error \"'\\[jk\\]' present on multiple clauses\" }\n+\tdo l = 1, 10\n+\tend do\n+!$omp end parallel do\n+      end subroutine test1"}, {"sha": "3dfd43d43e3b6078fff3ef915b3394a041c7f091", "filename": "gcc/testsuite/gfortran.dg/gomp/omp_do1.f90", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fomp_do1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fomp_do1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fomp_do1.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,57 @@\n+! { dg-do compile }\n+! { dg-options \"-fopenmp -std=gnu\" }\n+subroutine foo\n+  integer :: i, j\n+  integer, dimension (30) :: a\n+  double precision :: d\n+  i = 0\n+!$omp do private (i)\n+  do 100 ! { dg-error \"cannot be a DO WHILE or DO without loop control\" }\n+    if (i .gt. 0) exit ! { dg-error \"EXIT statement\" }\n+100 i = i + 1\n+  i = 0\n+!$omp do private (i)\n+  do ! { dg-error \"cannot be a DO WHILE or DO without loop control\" }\n+    if (i .gt. 0) exit ! { dg-error \"EXIT statement\" }\n+    i = i + 1\n+  end do\n+  i = 0\n+!$omp do private (i)\n+  do 200 while (i .lt. 4) ! { dg-error \"cannot be a DO WHILE or DO without loop control\" }\n+200 i = i + 1\n+!$omp do private (i)\n+  do while (i .lt. 8) ! { dg-error \"cannot be a DO WHILE or DO without loop control\" }\n+    i = i + 1\n+  end do\n+!$omp do\n+  do 300 d = 1, 30, 6 ! { dg-warning \"Obsolete: REAL DO loop iterator\" }\n+    i = d\n+300 a(i) = 1\n+!$omp do\n+  do d = 1, 30, 5 ! { dg-warning \"Obsolete: REAL DO loop iterator\" }\n+    i = d\n+    a(i) = 2\n+  end do\n+!$omp do\n+  do i = 1, 30\n+    if (i .eq. 16) exit ! { dg-error \"EXIT statement\" }\n+  end do\n+!$omp do\n+outer: do i = 1, 30\n+    do j = 5, 10\n+      if (i .eq. 6 .and. j .eq. 7) exit outer ! { dg-error \"EXIT statement\" }\n+    end do\n+  end do outer\n+last: do i = 1, 30\n+!$omp parallel\n+    if (i .eq. 21) exit last ! { dg-error \"leaving OpenMP structured block\" }\n+!$omp end parallel\n+  end do last\n+!$omp parallel do shared (i)\n+  do i = 1, 30, 2 ! { dg-error \"iteration variable present on clause\" }\n+    a(i) = 5\n+  end do\n+!$omp end parallel do\n+end subroutine\n+! { dg-error \"iteration variable must be of type integer\" \"\" { target *-*-* } 27 }\n+! { dg-error \"iteration variable must be of type integer\" \"\" { target *-*-* } 31 }"}, {"sha": "55aad067082e31cbcdc152e7e6abcdd4cbc1026a", "filename": "gcc/testsuite/gfortran.dg/gomp/omp_threadprivate1.f90", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fomp_threadprivate1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fomp_threadprivate1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fomp_threadprivate1.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,17 @@\n+! { dg-require-effective-target tls }\n+      module omp_threadprivate1\n+\tcommon /T/ a\n+      end module omp_threadprivate1\n+      subroutine bad1\n+\tuse omp_threadprivate1\n+!$omp threadprivate (/T/)\t! { dg-error \"not found\" }\n+      end subroutine bad1\n+      subroutine bad2\n+\tcommon /S/ b\n+!$omp threadprivate (/S/)\n+      contains\n+\tsubroutine bad3\n+!$omp parallel copyin (/T/)\t! { dg-error \"not found\" }\n+!$omp end parallel\t\t! { dg-error \"\" }\n+\tend subroutine bad3\n+      end subroutine bad2"}, {"sha": "cd1ab5cd60a3fc248c78b3c568454e002c13573a", "filename": "gcc/testsuite/gfortran.dg/gomp/omp_threadprivate2.f90", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fomp_threadprivate2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fomp_threadprivate2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fomp_threadprivate2.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,6 @@\n+! { dg-do compile }\n+! { dg-require-effective-target tls }\n+      subroutine bad1\n+\tdouble precision :: d\t! { dg-error \"isn't SAVEd\" }\n+!$omp threadprivate (d)\n+      end subroutine bad1"}, {"sha": "b69714d4b914db0bb592430ffd1c18aabb2dcebe", "filename": "gcc/testsuite/gfortran.dg/gomp/reduction1.f90", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Freduction1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Freduction1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Freduction1.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,131 @@\n+! { dg-do compile }\n+! { dg-require-effective-target tls }\n+\n+subroutine foo (ia1)\n+integer :: i1, i2, i3\n+integer, dimension (*) :: ia1\n+integer, dimension (10) :: ia2\n+real :: r1\n+real, dimension (5) :: ra1\n+double precision :: d1\n+double precision, dimension (4) :: da1\n+complex :: c1\n+complex, dimension (7) :: ca1\n+logical :: l1\n+logical, dimension (3) :: la1\n+character (5) :: a1\n+type t\n+  integer :: i\n+end type\n+type(t) :: t1\n+type(t), dimension (2) :: ta1\n+real, pointer :: p1 => NULL()\n+integer, allocatable :: aa1 (:,:)\n+save i2\n+!$omp threadprivate (i2)\n+common /blk/ i1\n+\n+!$omp parallel reduction (+:i3, ia2, r1, ra1, d1, da1, c1, ca1)\n+!$omp end parallel\n+!$omp parallel reduction (*:i3, ia2, r1, ra1, d1, da1, c1, ca1)\n+!$omp end parallel\n+!$omp parallel reduction (-:i3, ia2, r1, ra1, d1, da1, c1, ca1)\n+!$omp end parallel\n+!$omp parallel reduction (.and.:l1, la1)\n+!$omp end parallel\n+!$omp parallel reduction (.or.:l1, la1)\n+!$omp end parallel\n+!$omp parallel reduction (.eqv.:l1, la1)\n+!$omp end parallel\n+!$omp parallel reduction (.neqv.:l1, la1)\n+!$omp end parallel\n+!$omp parallel reduction (min:i3, ia2, r1, ra1, d1, da1)\n+!$omp end parallel\n+!$omp parallel reduction (max:i3, ia2, r1, ra1, d1, da1)\n+!$omp end parallel\n+!$omp parallel reduction (iand:i3, ia2)\n+!$omp end parallel\n+!$omp parallel reduction (ior:i3, ia2)\n+!$omp end parallel\n+!$omp parallel reduction (ieor:i3, ia2)\n+!$omp end parallel\n+!$omp parallel reduction (+:/blk/)\t! { dg-error \"Syntax error\" }\n+!$omp end parallel\t\t\t! { dg-error \"Unexpected\" }\n+!$omp parallel reduction (+:i2)\t\t! { dg-error \"THREADPRIVATE object\" }\n+!$omp end parallel\n+!$omp parallel reduction (*:p1)\t\t! { dg-error \"POINTER object\" }\n+!$omp end parallel\n+!$omp parallel reduction (-:aa1)\t! { dg-error \"is ALLOCATABLE\" }\n+!$omp end parallel\n+!$omp parallel reduction (*:ia1)\t! { dg-error \"Assumed size\" }\n+!$omp end parallel\n+!$omp parallel reduction (+:l1)\t\t! { dg-error \"is LOGICAL\" }\n+!$omp end parallel\n+!$omp parallel reduction (*:la1)\t! { dg-error \"is LOGICAL\" }\n+!$omp end parallel\n+!$omp parallel reduction (-:a1)\t\t! { dg-error \"is CHARACTER\" }\n+!$omp end parallel\n+!$omp parallel reduction (+:t1)\t\t! { dg-error \"is TYPE\" }\n+!$omp end parallel\n+!$omp parallel reduction (*:ta1)\t! { dg-error \"is TYPE\" }\n+!$omp end parallel\n+!$omp parallel reduction (.and.:i3)\t! { dg-error \"must be LOGICAL\" }\n+!$omp end parallel\n+!$omp parallel reduction (.or.:ia2)\t! { dg-error \"must be LOGICAL\" }\n+!$omp end parallel\n+!$omp parallel reduction (.eqv.:r1)\t! { dg-error \"must be LOGICAL\" }\n+!$omp end parallel\n+!$omp parallel reduction (.neqv.:ra1)\t! { dg-error \"must be LOGICAL\" }\n+!$omp end parallel\n+!$omp parallel reduction (.and.:d1)\t! { dg-error \"must be LOGICAL\" }\n+!$omp end parallel\n+!$omp parallel reduction (.or.:da1)\t! { dg-error \"must be LOGICAL\" }\n+!$omp end parallel\n+!$omp parallel reduction (.eqv.:c1)\t! { dg-error \"must be LOGICAL\" }\n+!$omp end parallel\n+!$omp parallel reduction (.neqv.:ca1)\t! { dg-error \"must be LOGICAL\" }\n+!$omp end parallel\n+!$omp parallel reduction (.and.:a1)\t! { dg-error \"must be LOGICAL\" }\n+!$omp end parallel\n+!$omp parallel reduction (.or.:t1)\t! { dg-error \"must be LOGICAL\" }\n+!$omp end parallel\n+!$omp parallel reduction (.eqv.:ta1)\t! { dg-error \"must be LOGICAL\" }\n+!$omp end parallel\n+!$omp parallel reduction (min:c1)\t! { dg-error \"must be INTEGER or REAL\" }\n+!$omp end parallel\n+!$omp parallel reduction (max:ca1)\t! { dg-error \"must be INTEGER or REAL\" }\n+!$omp end parallel\n+!$omp parallel reduction (max:l1)\t! { dg-error \"must be INTEGER or REAL\" }\n+!$omp end parallel\n+!$omp parallel reduction (min:la1)\t! { dg-error \"must be INTEGER or REAL\" }\n+!$omp end parallel\n+!$omp parallel reduction (max:a1)\t! { dg-error \"must be INTEGER or REAL\" }\n+!$omp end parallel\n+!$omp parallel reduction (min:t1)\t! { dg-error \"must be INTEGER or REAL\" }\n+!$omp end parallel\n+!$omp parallel reduction (max:ta1)\t! { dg-error \"must be INTEGER or REAL\" }\n+!$omp end parallel\n+!$omp parallel reduction (iand:r1)\t! { dg-error \"must be INTEGER\" }\n+!$omp end parallel\n+!$omp parallel reduction (ior:ra1)\t! { dg-error \"must be INTEGER\" }\n+!$omp end parallel\n+!$omp parallel reduction (ieor:d1)\t! { dg-error \"must be INTEGER\" }\n+!$omp end parallel\n+!$omp parallel reduction (ior:da1)\t! { dg-error \"must be INTEGER\" }\n+!$omp end parallel\n+!$omp parallel reduction (iand:c1)\t! { dg-error \"must be INTEGER\" }\n+!$omp end parallel\n+!$omp parallel reduction (ior:ca1)\t! { dg-error \"must be INTEGER\" }\n+!$omp end parallel\n+!$omp parallel reduction (ieor:l1)\t! { dg-error \"must be INTEGER\" }\n+!$omp end parallel\n+!$omp parallel reduction (iand:la1)\t! { dg-error \"must be INTEGER\" }\n+!$omp end parallel\n+!$omp parallel reduction (ior:a1)\t! { dg-error \"must be INTEGER\" }\n+!$omp end parallel\n+!$omp parallel reduction (ieor:t1)\t! { dg-error \"must be INTEGER\" }\n+!$omp end parallel\n+!$omp parallel reduction (iand:ta1)\t! { dg-error \"must be INTEGER\" }\n+!$omp end parallel\n+\n+end subroutine"}, {"sha": "f855d0e7fa787914501cb92ddbbdb0d0145d1499", "filename": "gcc/testsuite/gfortran.dg/gomp/reduction2.f90", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Freduction2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Freduction2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Freduction2.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,33 @@\n+! { dg-do compile }\n+\n+subroutine f1\n+  integer :: i\n+  i = 0\n+!$omp parallel reduction (ior:i)\n+  i = ior (i, 3)\n+!$omp end parallel\n+!$omp parallel reduction (ior:i)\n+  i = ior (i, 16)\n+!$omp end parallel\n+end subroutine f1\n+subroutine f2\n+  integer :: i\n+  i = ior (2, 4)\n+!$omp parallel reduction (ior:i)\n+  i = ior (i, 3)\n+!$omp end parallel\n+end subroutine f2\n+subroutine f3\n+  integer :: i\n+  i = 6\n+!$omp parallel reduction (ior:i)\n+  i = ior (i, 3)\n+!$omp end parallel\n+end subroutine f3\n+subroutine f4\n+  integer :: i, ior\n+  i = 6\n+!$omp parallel reduction (ior:i)\n+  i = ior (i, 3)\n+!$omp end parallel\n+end subroutine f4"}, {"sha": "1bb0e21c387c7330550ba74103ce4b45f276897c", "filename": "gcc/testsuite/gfortran.dg/gomp/reduction3.f90", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Freduction3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Freduction3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Freduction3.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,69 @@\n+! { dg-do compile }\n+\n+module mreduction3\n+  interface\n+    function ior (a, b)\n+      integer :: ior, a, b\n+    end function\n+  end interface\n+contains\n+  function iand (a, b)\n+    integer :: iand, a, b\n+    iand = a + b\n+  end function\n+end module mreduction3\n+subroutine f1\n+  integer :: i, ior\n+  ior = 6\n+  i = 6\n+!$omp parallel reduction (ior:i) ! { dg-error \"is not INTRINSIC procedure name\" }\n+!$omp end parallel\n+end subroutine f1\n+subroutine f2\n+  integer :: i\n+  interface\n+    function ior (a, b)\n+      integer :: ior, a, b\n+    end function\n+  end interface\n+  i = 6\n+!$omp parallel reduction (ior:i) ! { dg-error \"is not INTRINSIC procedure name\" }\n+  i = ior (i, 3)\n+!$omp end parallel\n+end subroutine f2\n+subroutine f3\n+  integer :: i\n+  interface\n+    function ior (a, b)\n+      integer :: ior, a, b\n+    end function\n+  end interface\n+  intrinsic ior\n+  i = 6\n+!$omp parallel reduction (ior:i)\n+  i = ior (i, 3)\n+!$omp end parallel\n+end subroutine f3\n+subroutine f4\n+  integer :: i, ior\n+  i = 6\n+!$omp parallel reduction (ior:i)\n+  ior = 4\t\t\t ! { dg-error \"Expected VARIABLE\" }\n+!$omp end parallel\n+end subroutine f4\n+subroutine f5\n+  use mreduction3\n+  integer :: i\n+  i = 6\n+!$omp parallel reduction (ior:i) ! { dg-error \"is not INTRINSIC procedure name\" }\n+  i = ior (i, 7)\n+!$omp end parallel\n+end subroutine f5\n+subroutine f6\n+  use mreduction3\n+  integer :: i\n+  i = 6\n+!$omp parallel reduction (iand:i) ! { dg-error \"is not INTRINSIC procedure name\" }\n+  i = iand (i, 18)\n+!$omp end parallel\n+end subroutine f6"}, {"sha": "7a107ffe7cbd9a61e8ef0530000a1cdaeb925966", "filename": "gcc/testsuite/gfortran.dg/gomp/sharing-1.f90", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fsharing-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fsharing-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fsharing-1.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,28 @@\n+! { dg-do compile }\n+! { dg-require-effective-target tls }\n+\n+  integer :: thrpriv, thr, i, j, s, g1, g2, m\n+  integer, dimension (6) :: p\n+  common /thrblk/ thr\n+  common /gblk/ g1\n+  save thrpriv, g2\n+!$omp threadprivate (/thrblk/, thrpriv)\n+  s = 1\n+!$omp parallel do default (none) &\n+!$omp & private (p) shared (s) ! { dg-error \"enclosing parallel\" }\n+  do i = 1, 64\n+    call foo (thrpriv)\t! Predetermined - threadprivate\n+    call foo (thr)\t! Predetermined - threadprivate\n+    call foo (i)\t! Predetermined - omp do iteration var\n+    do j = 1, 64\t! Predetermined - sequential loop\n+      call foo (j)\t! iteration variable\n+    end do\n+    call bar ((/ (k * 4, k = 1, 8) /)) ! Predetermined - implied do\n+    forall (l = 1 : i) &! Predetermined - forall indice\n+      p(l) = 6\t\t! Explicitly determined - private\n+    call foo (s)\t! Explicitly determined - shared\n+    call foo (g1)\t! { dg-error \"not specified in\" }\n+    call foo (g2)\t! { dg-error \"not specified in\" }\n+    call foo (m)\t! { dg-error \"not specified in\" }\n+  end do\n+end"}, {"sha": "aede06c9c0ff6e014b12c9cdbf042c799864166b", "filename": "gcc/testsuite/gfortran.dg/gomp/sharing-2.f90", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fsharing-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fsharing-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fsharing-2.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,84 @@\n+  integer :: i, j, k, l\n+  integer, dimension (10, 10) :: a\n+!$omp parallel do default (none) shared (a)\n+  do i = 1, 10\n+    j = 4\n+    do j = 1, 10\n+      a(i, j) = i + j\n+    end do\n+    j = 8\n+  end do\n+!$omp end parallel do\n+!$omp parallel default (none) shared (a) ! { dg-error \"enclosing parallel\" }\n+  i = 1\n+  j = 1\n+  k = 1\n+  l = 1\t\t! { dg-error \"not specified in\" }\n+  do i = 1, 10\n+    a(i, 1) = 1\n+  end do\n+!$omp critical\n+  do j = 1, 10\n+    a(1, j) = j\n+  end do\n+!$omp end critical\n+!$omp single\n+  do k = 1, 10\n+    a(k, k) = k\n+  end do\n+!$omp end single\n+!$omp end parallel\n+!$omp parallel default (none) shared (a)\n+  i = 1\n+  j = 1\n+  k = 1\n+!$omp parallel default (none) shared (a)\n+  i = 1\n+  j = 1\n+  k = 1\n+  do i = 1, 10\n+    a(i, 1) = 1\n+  end do\n+!$omp critical\n+  do j = 1, 10\n+    a(1, j) = j\n+  end do\n+!$omp end critical\n+!$omp single\n+  do k = 1, 10\n+    a(k, k) = k\n+  end do\n+!$omp end single\n+!$omp end parallel\n+  i = 1\n+  j = 1\n+  k = 1\n+!$omp end parallel\n+!$omp parallel default (none) shared (a) ! { dg-error \"enclosing parallel\" }\n+  i = 1\t\t! { dg-error \"not specified in\" }\n+!$omp do\n+  do i = 1, 10\n+    a(i, 1) = i + 1\n+  end do\n+!$omp end parallel\n+!$omp parallel default (none) shared (a) ! { dg-error \"enclosing parallel\" }\n+  i = 1\t\t! { dg-error \"not specified in\" }\n+!$omp parallel do default (none) shared (a)\n+  do i = 1, 10\n+    a(i, 1) = i + 1\n+  end do\n+!$omp end parallel\n+!$omp parallel default (none) shared (a)\n+  i = 1\n+!$omp parallel default (none) shared (a, i)\n+  i = 2\n+!$omp parallel default (none) shared (a)\n+  do i = 1, 10\n+    a(i, 1) = i\n+  end do\n+!$omp end parallel\n+  i = 3\n+!$omp end parallel\n+  i = 4\n+!$omp end parallel\n+end"}, {"sha": "ffbb1db8211bc2ecb338e407dbebf7a36f1958cf", "filename": "gcc/testsuite/gfortran.dg/gomp/workshare1.f90", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fworkshare1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fworkshare1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fworkshare1.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,42 @@\n+! { dg-do compile }\n+\n+interface\n+  subroutine foo\n+  end subroutine\n+  function bar ()\n+  integer :: bar\n+  end function bar\n+  elemental function baz ()\n+  integer :: baz\n+  end function baz\n+end interface\n+\n+  integer :: i, j\n+  real :: a, b (10), c\n+  a = 0.5\n+  b = 0.25\n+!$omp parallel workshare\n+  a = sin (a)\n+  b = sin (b)\n+  forall (i = 1:10) b(i) = cos (b(i)) - 0.5\n+  j = baz ()\n+!$omp parallel if (bar () .gt. 2) &\n+!$omp & num_threads (bar () + 1)\n+  i = bar ()\n+!$omp end parallel\n+!$omp parallel do schedule (static, bar () + 4)\n+  do j = 1, 10\n+    i = bar ()\n+  end do\n+!$omp end parallel do\n+!$omp end parallel workshare\n+!$omp parallel workshare\n+  call foo\t\t\t! { dg-error \"CALL statement\" }\n+  i = bar ()\t\t\t! { dg-error \"non-ELEMENTAL\" }\n+!$omp critical\n+  i = bar ()\t\t\t! { dg-error \"non-ELEMENTAL\" }\n+!$omp end critical\n+!$omp atomic\n+  j = j + bar ()\t\t! { dg-error \"non-ELEMENTAL\" }\n+!$omp end parallel workshare\n+end"}, {"sha": "fd21de23a5295971325667c1c580710b039de9e1", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -1,3 +1,8 @@\n+2006-02-13  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* testsuite/libgomp.fortran/vla7.f90: Add -w to options.\n+\tRemove tests for returning assumed character length arrays.\n+\n 2006-02-12  Roger Sayle  <roger@eyesopen.com>\n \t    John David Anglin  <dave@hiauly1.hia.nrc.ca>\n "}, {"sha": "3d95451eaff406d16ece162b6b0699e3375a3306", "filename": "libgomp/testsuite/libgomp.fortran/appendix-a/a.15.1.f90", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.15.1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.15.1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.15.1.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,31 @@\n+! { dg-do compile }\n+      SUBROUTINE WORK(N)\n+        INTEGER N\n+      END SUBROUTINE WORK\n+      SUBROUTINE SUB3(N)\n+      INTEGER N\n+        CALL WORK(N)\n+!$OMP BARRIER\n+        CALL WORK(N)\n+      END SUBROUTINE SUB3\n+      SUBROUTINE SUB2(K)\n+      INTEGER K\n+!$OMP PARALLEL SHARED(K)\n+          CALL SUB3(K)\n+!$OMP END PARALLEL\n+      END SUBROUTINE SUB2\n+      SUBROUTINE SUB1(N)\n+      INTEGER N\n+        INTEGER I\n+!$OMP PARALLEL PRIVATE(I) SHARED(N)\n+!$OMP DO\n+          DO I = 1, N\n+             CALL SUB2(I)\n+          END DO\n+!$OMP END PARALLEL\n+      END SUBROUTINE SUB1\n+      PROGRAM A15\n+        CALL SUB1(2)\n+        CALL SUB2(2)\n+        CALL SUB3(2)\n+      END PROGRAM A15"}, {"sha": "014d4fd5ac4ef2d50067b95eb925478e2c685c8f", "filename": "libgomp/testsuite/libgomp.fortran/appendix-a/a.16.1.f90", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.16.1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.16.1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.16.1.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,41 @@\n+! { dg-do run }\n+        REAL FUNCTION WORK1(I)\n+            INTEGER I\n+            WORK1 = 1.0 * I\n+            RETURN\n+        END FUNCTION WORK1\n+\n+        REAL FUNCTION WORK2(I)\n+            INTEGER I\n+            WORK2 = 2.0 * I\n+            RETURN\n+        END FUNCTION WORK2\n+\n+        SUBROUTINE SUBA16(X, Y, INDEX, N)\n+        REAL X(*), Y(*)\n+        INTEGER INDEX(*), N\n+        INTEGER I\n+!$OMP PARALLEL DO SHARED(X, Y, INDEX, N)\n+          DO I=1,N\n+!$OMP ATOMIC\n+              X(INDEX(I)) = X(INDEX(I)) + WORK1(I)\n+            Y(I) = Y(I) + WORK2(I)\n+          ENDDO\n+      END SUBROUTINE SUBA16\n+\n+      PROGRAM A16\n+        REAL X(1000), Y(10000)\n+        INTEGER INDEX(10000)\n+        INTEGER I\n+        DO I=1,10000\n+          INDEX(I) = MOD(I, 1000) + 1\n+          Y(I) = 0.0\n+        ENDDO\n+        DO I = 1,1000\n+          X(I) = 0.0\n+        ENDDO\n+        CALL SUBA16(X, Y, INDEX, 10000)\n+        DO I = 1,10\n+          PRINT *, \"X(\", I, \") = \", X(I), \", Y(\", I, \") = \", Y(I)\n+        ENDDO\n+      END PROGRAM A16"}, {"sha": "3321485efc31157b7289c83970745bf4d6058ec7", "filename": "libgomp/testsuite/libgomp.fortran/appendix-a/a.18.1.f90", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.18.1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.18.1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.18.1.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,59 @@\n+! { dg-do run }\n+! { dg-options \"-ffixed-form\" }\n+      REAL FUNCTION FN1(I)\n+        INTEGER I\n+        FN1 = I * 2.0\n+        RETURN\n+      END FUNCTION FN1\n+\n+      REAL FUNCTION FN2(A, B)\n+        REAL A, B\n+        FN2 = A + B\n+        RETURN\n+      END FUNCTION FN2\n+\n+      PROGRAM A18\n+      INCLUDE \"omp_lib.h\"     ! or USE OMP_LIB\n+      INTEGER ISYNC(256)\n+      REAL    WORK(256)\n+      REAL    RESULT(256)\n+      INTEGER IAM, NEIGHBOR\n+!$OMP PARALLEL PRIVATE(IAM, NEIGHBOR) SHARED(WORK, ISYNC) NUM_THREADS(4)\n+          IAM = OMP_GET_THREAD_NUM() + 1\n+          ISYNC(IAM) = 0\n+!$OMP BARRIER\n+!     Do computation into my portion of work array\n+          WORK(IAM) = FN1(IAM)\n+!     Announce that I am done with my work.\n+!     The first flush ensures that my work is made visible before\n+!     synch. The second flush ensures that synch is made visible.\n+!$OMP FLUSH(WORK,ISYNC)\n+       ISYNC(IAM) = 1\n+!$OMP FLUSH(ISYNC)\n+\n+!      Wait until neighbor is done. The first flush ensures that\n+!      synch is read from memory, rather than from the temporary\n+!      view of memory. The second flush ensures that work is read\n+!      from memory, and is done so after the while loop exits.\n+       IF (IAM .EQ. 1) THEN\n+            NEIGHBOR = OMP_GET_NUM_THREADS()\n+        ELSE\n+            NEIGHBOR = IAM - 1\n+        ENDIF\n+        DO WHILE (ISYNC(NEIGHBOR) .EQ. 0)\n+!$OMP FLUSH(ISYNC)\n+        END DO\n+!$OMP FLUSH(WORK, ISYNC)\n+        RESULT(IAM) = FN2(WORK(NEIGHBOR), WORK(IAM))\n+!$OMP END PARALLEL\n+        DO I=1,4\n+          IF (I .EQ. 1) THEN\n+                NEIGHBOR = 4\n+          ELSE\n+                NEIGHBOR = I - 1\n+          ENDIF\n+          IF (RESULT(I) .NE. I * 2 + NEIGHBOR * 2) THEN\n+            CALL ABORT\n+          ENDIF\n+        ENDDO\n+        END PROGRAM A18"}, {"sha": "1fe1c4247268649bd4b63a6f628e4a5a40d5ab3d", "filename": "libgomp/testsuite/libgomp.fortran/appendix-a/a.19.1.f90", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.19.1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.19.1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.19.1.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,60 @@\n+! { dg-do run }\n+        SUBROUTINE F1(Q)\n+        COMMON /DATA/ P, X\n+        INTEGER, TARGET :: X\n+        INTEGER, POINTER :: P\n+        INTEGER Q\n+        Q=1\n+!$OMP FLUSH\n+        ! X, P and Q are flushed\n+        ! because they are shared and accessible\n+      END SUBROUTINE F1\n+      SUBROUTINE F2(Q)\n+        COMMON /DATA/ P, X\n+        INTEGER, TARGET :: X\n+        INTEGER, POINTER :: P\n+        INTEGER Q\n+!$OMP BARRIER\n+          Q=2\n+!$OMP BARRIER\n+          ! a barrier implies a flush\n+          ! X, P and Q are flushed\n+          ! because they are shared and accessible\n+        END SUBROUTINE F2\n+\n+      INTEGER FUNCTION G(N)\n+          COMMON /DATA/ P, X\n+          INTEGER, TARGET :: X\n+          INTEGER, POINTER :: P\n+          INTEGER N\n+          INTEGER I, J, SUM\n+          I=1\n+          SUM = 0\n+          P=1\n+!$OMP PARALLEL REDUCTION(+: SUM) NUM_THREADS(2)\n+          CALL F1(J)\n+                ! I, N and SUM were not flushed\n+                !   because they were not accessible in F1\n+                ! J was flushed because it was accessible\n+          SUM = SUM + J\n+          CALL F2(J)\n+                ! I, N, and SUM were not flushed\n+                ! because they were not accessible in f2\n+                ! J was flushed because it was accessible\n+          SUM = SUM + I + J + P + N\n+!$OMP END PARALLEL\n+          G = SUM\n+      END FUNCTION G\n+\n+      PROGRAM A19\n+        COMMON /DATA/ P, X\n+        INTEGER, TARGET :: X\n+        INTEGER, POINTER :: P\n+        INTEGER RESULT, G\n+        P => X\n+        RESULT = G(10)\n+        PRINT *, RESULT\n+        IF (RESULT .NE. 30) THEN\n+          CALL ABORT\n+        ENDIF\n+      END PROGRAM A19"}, {"sha": "2b09f5b1fd5407af1aef3b359291f927af8cf9f9", "filename": "libgomp/testsuite/libgomp.fortran/appendix-a/a.2.1.f90", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.2.1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.2.1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.2.1.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,22 @@\n+! { dg-do run }\n+PROGRAM A2\n+  INCLUDE \"omp_lib.h\"      ! or USE OMP_LIB\n+  INTEGER X\n+  X=2\n+!$OMP PARALLEL NUM_THREADS(2) SHARED(X)\n+    IF (OMP_GET_THREAD_NUM() .EQ. 0) THEN\n+       X=5\n+    ELSE\n+    ! PRINT 1: The following read of x has a race\n+      PRINT *,\"1: THREAD# \", OMP_GET_THREAD_NUM(), \"X = \", X\n+    ENDIF\n+!$OMP BARRIER\n+    IF (OMP_GET_THREAD_NUM() .EQ. 0) THEN\n+    ! PRINT 2\n+      PRINT *,\"2: THREAD# \", OMP_GET_THREAD_NUM(), \"X = \", X\n+    ELSE\n+    ! PRINT 3\n+      PRINT *,\"3: THREAD# \", OMP_GET_THREAD_NUM(), \"X = \", X\n+    ENDIF\n+!$OMP END PARALLEL\n+END PROGRAM A2"}, {"sha": "c22fa116927b9cdfa552a29c4548f86bd4dd7cb8", "filename": "libgomp/testsuite/libgomp.fortran/appendix-a/a.21.1.f90", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.21.1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.21.1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.21.1.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,19 @@\n+! { dg-do compile }\n+      SUBROUTINE WORK(K)\n+        INTEGER k\n+!$OMP ORDERED\n+        WRITE(*,*) K\n+!$OMP END ORDERED\n+      END SUBROUTINE WORK\n+      SUBROUTINE SUBA21(LB, UB, STRIDE)\n+        INTEGER LB, UB, STRIDE\n+        INTEGER I\n+!$OMP PARALLEL DO ORDERED SCHEDULE(DYNAMIC)\n+        DO I=LB,UB,STRIDE\n+          CALL WORK(I)\n+        END DO\n+!$OMP END PARALLEL DO\n+      END SUBROUTINE SUBA21\n+      PROGRAM A21\n+        CALL SUBA21(1,100,5)\n+      END PROGRAM A21"}, {"sha": "fff4e6d499751adbec92b62fb6fe8cb1f355983c", "filename": "libgomp/testsuite/libgomp.fortran/appendix-a/a.22.7.f90", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.22.7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.22.7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.22.7.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,33 @@\n+! { dg-do run }\n+! { dg-require-effective-target tls_runtime }\n+\n+      PROGRAM A22_7_GOOD\n+        INTEGER, ALLOCATABLE, SAVE :: A(:)\n+        INTEGER, POINTER, SAVE :: PTR\n+        INTEGER, SAVE :: I\n+        INTEGER, TARGET :: TARG\n+        LOGICAL :: FIRSTIN = .TRUE.\n+!$OMP THREADPRIVATE(A, I, PTR)\n+        ALLOCATE (A(3))\n+        A = (/1,2,3/)\n+        PTR => TARG\n+        I=5\n+!$OMP PARALLEL COPYIN(I, PTR)\n+!$OMP CRITICAL\n+            IF (FIRSTIN) THEN\n+              TARG = 4           ! Update target of ptr\n+              I = I + 10\n+              IF (ALLOCATED(A)) A = A + 10\n+              FIRSTIN = .FALSE.\n+            END IF\n+            IF (ALLOCATED(A)) THEN\n+              PRINT *, \"a = \", A\n+            ELSE\n+              PRINT *, \"A is not allocated\"\n+            END IF\n+            PRINT *, \"ptr = \", PTR\n+            PRINT *, \"i = \", I\n+            PRINT *\n+!$OMP END CRITICAL\n+!$OMP END PARALLEL\n+      END PROGRAM A22_7_GOOD"}, {"sha": "cf6d90ee828064697deda03e9b85b32dd31e0bc6", "filename": "libgomp/testsuite/libgomp.fortran/appendix-a/a.22.8.f90", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.22.8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.22.8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.22.8.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,25 @@\n+! { dg-do run }\n+! { dg-require-effective-target tls_runtime }\n+       MODULE A22_MODULE8\n+         REAL, POINTER :: WORK(:)\n+         SAVE WORK\n+!$OMP THREADPRIVATE(WORK)\n+       END MODULE A22_MODULE8\n+       SUBROUTINE SUB1(N)\n+       USE A22_MODULE8\n+!$OMP PARALLEL PRIVATE(THE_SUM)\n+         ALLOCATE(WORK(N))\n+         CALL SUB2(THE_SUM)\n+        WRITE(*,*)THE_SUM\n+!$OMP END PARALLEL\n+       END SUBROUTINE SUB1\n+       SUBROUTINE SUB2(THE_SUM)\n+        USE A22_MODULE8\n+        WORK(:) = 10\n+        THE_SUM=SUM(WORK)\n+        END SUBROUTINE SUB2\n+        PROGRAM A22_8_GOOD\n+        N = 10\n+        CALL SUB1(N)\n+        END PROGRAM A22_8_GOOD\n+"}, {"sha": "e9ebf87af73cb0d7fd099063eec5e727b5903f7f", "filename": "libgomp/testsuite/libgomp.fortran/appendix-a/a.26.1.f90", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.26.1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.26.1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.26.1.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,11 @@\n+! { dg-do run }\n+       PROGRAM A26\n+         INTEGER I, J\n+         I=1\n+         J=2\n+!$OMP PARALLEL PRIVATE(I) FIRSTPRIVATE(J)\n+           I=3\n+           J=J+2\n+!$OMP END PARALLEL\n+          PRINT *, I, J ! I and J are undefined\n+      END PROGRAM A26"}, {"sha": "c271333a86d5ac750493902a00b391d1a364280f", "filename": "libgomp/testsuite/libgomp.fortran/appendix-a/a.28.1.f90", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.28.1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.28.1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.28.1.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,14 @@\n+! { dg-do run }\n+\n+       SUBROUTINE SUB()\n+       COMMON /BLOCK/ X\n+       PRINT *,X              ! X is undefined\n+       END SUBROUTINE SUB\n+       PROGRAM A28_1\n+         COMMON /BLOCK/ X\n+         X = 1.0\n+!$OMP PARALLEL PRIVATE (X)\n+         X = 2.0\n+         CALL SUB()\n+!$OMP END PARALLEL\n+      END PROGRAM A28_1"}, {"sha": "1145e54102614c5d0104c530c83524fc96dec955", "filename": "libgomp/testsuite/libgomp.fortran/appendix-a/a.28.2.f90", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.28.2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.28.2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.28.2.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,16 @@\n+! { dg-do run }\n+\n+      PROGRAM A28_2\n+        COMMON /BLOCK2/ X\n+        X = 1.0\n+!$OMP PARALLEL PRIVATE (X)\n+          X = 2.0\n+          CALL SUB()\n+!$OMP END PARALLEL\n+       CONTAINS\n+        SUBROUTINE SUB()\n+        COMMON /BLOCK2/ Y\n+        PRINT *,X                 ! X is undefined\n+        PRINT *,Y                 ! Y is undefined\n+        END SUBROUTINE SUB\n+      END PROGRAM A28_2"}, {"sha": "a337f3bc7d547d2dacc6fc7dedda3b0dc47349f9", "filename": "libgomp/testsuite/libgomp.fortran/appendix-a/a.28.3.f90", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.28.3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.28.3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.28.3.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,11 @@\n+! { dg-do run }\n+\n+        PROGRAM A28_3\n+        EQUIVALENCE (X,Y)\n+        X = 1.0\n+!$OMP PARALLEL PRIVATE(X)\n+          PRINT *,Y         ! Y is undefined\n+          Y = 10\n+          PRINT *,X         ! X is undefined\n+!$OMP END PARALLEL\n+      END PROGRAM A28_3"}, {"sha": "c5a5cd74cf582c451d64babd28af4b1f89bf6fe3", "filename": "libgomp/testsuite/libgomp.fortran/appendix-a/a.28.4.f90", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.28.4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.28.4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.28.4.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,24 @@\n+! { dg-do run }\n+\n+       PROGRAM A28_4\n+         INTEGER I, J\n+         INTEGER A(100), B(100)\n+         EQUIVALENCE (A(51), B(1))\n+!$OMP PARALLEL DO DEFAULT(PRIVATE) PRIVATE(I,J) LASTPRIVATE(A)\n+           DO I=1,100\n+               DO J=1,100\n+                 B(J) = J - 1\n+               ENDDO\n+               DO J=1,100\n+                 A(J) = J    ! B becomes undefined at this point\n+               ENDDO\n+               DO J=1,50\n+                 B(J) = B(J) + 1 ! B is undefined\n+                            ! A becomes undefined at this point\n+               ENDDO\n+           ENDDO\n+!$OMP END PARALLEL DO          ! The LASTPRIVATE write for A has\n+                               ! undefined results\n+        PRINT *, B  ! B is undefined since the LASTPRIVATE\n+                    ! write of A was not defined\n+        END PROGRAM A28_4"}, {"sha": "e3775822f108d7c49e8ba1a4ac8a0e8099b46ed8", "filename": "libgomp/testsuite/libgomp.fortran/appendix-a/a.28.5.f90", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.28.5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.28.5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.28.5.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,29 @@\n+! { dg-do compile }\n+\n+      SUBROUTINE SUB1(X)\n+        DIMENSION X(10)\n+        ! This use of X does not conform to the\n+        ! specification. It would be legal Fortran 90,\n+        ! but the OpenMP private directive allows the\n+        ! compiler to break the sequence association that\n+        ! A had with the rest of the common block.\n+        FORALL (I = 1:10) X(I) = I\n+      END SUBROUTINE SUB1\n+      PROGRAM A28_5\n+        COMMON /BLOCK5/ A\n+        DIMENSION B(10)\n+        EQUIVALENCE (A,B(1))\n+        ! the common block has to be at least 10 words\n+        A=0\n+!$OMP PARALLEL PRIVATE(/BLOCK5/)\n+          ! Without the private clause,\n+          ! we would be passing a member of a sequence\n+          ! that is at least ten elements long.\n+          ! With the private clause, A may no longer be\n+          ! sequence-associated.\n+          CALL SUB1(A)\n+!$OMP MASTER\n+            PRINT *, A\n+!$OMP END MASTER\n+!$OMP END PARALLEL\n+      END PROGRAM A28_5"}, {"sha": "0a175727279f199e441ef34a670a87fc935e4839", "filename": "libgomp/testsuite/libgomp.fortran/appendix-a/a.3.1.f90", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.3.1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.3.1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.3.1.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,6 @@\n+! { dg-do run }\n+! { dg-options \"-ffixed-form\" }\n+      PROGRAM A3\n+!234567890\n+!$    PRINT *, \"Compiled by an OpenMP-compliant implementation.\"\n+      END PROGRAM A3"}, {"sha": "69882c1e6b95db7b1f4a88d7a70835277e6c4687", "filename": "libgomp/testsuite/libgomp.fortran/appendix-a/a.31.4.f90", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.31.4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.31.4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.31.4.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,12 @@\n+! { dg-do run }\n+        MODULE M\n+        INTRINSIC MAX\n+        END MODULE M\n+        PROGRAM A31_4\n+        USE M, REN => MAX\n+        N=0\n+!$OMP PARALLEL DO REDUCTION(REN: N) ! still does MAX\n+        DO I = 1, 100\n+            N = MAX(N,I)\n+        END DO\n+        END PROGRAM A31_4"}, {"sha": "91a97cd829d1fefe56bb8bee4677accfec3455a1", "filename": "libgomp/testsuite/libgomp.fortran/appendix-a/a.31.5.f90", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.31.5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.31.5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.31.5.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,14 @@\n+! { dg-do run }\n+            MODULE MOD\n+            INTRINSIC MAX, MIN\n+            END MODULE MOD\n+            PROGRAM A31_5\n+            USE MOD, MIN=>MAX, MAX=>MIN\n+            REAL :: R\n+            R = -HUGE(0.0)\n+            !$OMP PARALLEL DO REDUCTION(MIN: R) ! still does MAX\n+            DO I = 1, 1000\n+                R = MIN(R, SIN(REAL(I)))\n+            END DO\n+            PRINT *, R\n+            END PROGRAM A31_5"}, {"sha": "adc493fcf0aa47df1e19647159d5affe6c2dcd17", "filename": "libgomp/testsuite/libgomp.fortran/appendix-a/a.33.3.f90", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.33.3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.33.3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.33.3.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,10 @@\n+! { dg-do compile }\n+\n+      FUNCTION NEW_LOCK()\n+      USE OMP_LIB       ! or INCLUDE \"omp_lib.h\"\n+        INTEGER(OMP_LOCK_KIND), POINTER :: NEW_LOCK\n+!$OMP SINGLE\n+          ALLOCATE(NEW_LOCK)\n+          CALL OMP_INIT_LOCK(NEW_LOCK)\n+!$OMP END SINGLE COPYPRIVATE(NEW_LOCK)\n+      END FUNCTION NEW_LOCK"}, {"sha": "55541303cea83f090316a92c9414725fd8de307a", "filename": "libgomp/testsuite/libgomp.fortran/appendix-a/a.38.1.f90", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.38.1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.38.1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.38.1.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,12 @@\n+! { dg-do compile }\n+\n+      FUNCTION NEW_LOCKS()\n+        USE OMP_LIB        ! or INCLUDE \"omp_lib.h\"\n+        INTEGER(OMP_LOCK_KIND), DIMENSION(1000) :: NEW_LOCKS\n+        INTEGER I\n+!$OMP PARALLEL DO PRIVATE(I)\n+          DO I=1,1000\n+            CALL OMP_INIT_LOCK(NEW_LOCKS(I))\n+          END DO\n+!$OMP END PARALLEL DO\n+      END FUNCTION NEW_LOCKS"}, {"sha": "540d17f5b026d4356f7c898fc610180dba249006", "filename": "libgomp/testsuite/libgomp.fortran/appendix-a/a.39.1.f90", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.39.1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.39.1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.39.1.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,26 @@\n+! { dg-do run }\n+\n+      SUBROUTINE SKIP(ID)\n+      END SUBROUTINE SKIP\n+      SUBROUTINE WORK(ID)\n+      END SUBROUTINE WORK\n+      PROGRAM A39\n+        INCLUDE \"omp_lib.h\"      ! or USE OMP_LIB\n+        INTEGER(OMP_LOCK_KIND) LCK\n+        INTEGER ID\n+        CALL OMP_INIT_LOCK(LCK)\n+!$OMP PARALLEL SHARED(LCK) PRIVATE(ID)\n+          ID = OMP_GET_THREAD_NUM()\n+          CALL OMP_SET_LOCK(LCK)\n+          PRINT *, \"My thread id is \", ID\n+          CALL OMP_UNSET_LOCK(LCK)\n+          DO WHILE (.NOT. OMP_TEST_LOCK(LCK))\n+            CALL SKIP(ID)     ! We do not yet have the lock\n+                              ! so we must do something else\n+          END DO\n+          CALL WORK(ID)       ! We now have the lock\n+                              ! and can do the work\n+          CALL OMP_UNSET_LOCK( LCK )\n+!$OMP END PARALLEL\n+        CALL OMP_DESTROY_LOCK( LCK )\n+        END PROGRAM A39"}, {"sha": "3c2a74a4fdd24789fcbc0033aae45b28a226e13b", "filename": "libgomp/testsuite/libgomp.fortran/appendix-a/a.4.1.f90", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.4.1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.4.1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.4.1.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,29 @@\n+! { dg-do run }\n+      SUBROUTINE SUBDOMAIN(X, ISTART, IPOINTS)\n+          INTEGER ISTART, IPOINTS\n+          REAL X(*)\n+          INTEGER I\n+          DO 100 I=1,IPOINTS\n+             X(ISTART+I) = 123.456\n+ 100      CONTINUE\n+      END SUBROUTINE SUBDOMAIN\n+      SUBROUTINE SUB(X, NPOINTS)\n+          INCLUDE \"omp_lib.h\"      ! or USE OMP_LIB\n+          REAL X(*)\n+          INTEGER NPOINTS\n+          INTEGER IAM, NT, IPOINTS, ISTART\n+!$OMP PARALLEL DEFAULT(PRIVATE) SHARED(X,NPOINTS)\n+          IAM = OMP_GET_THREAD_NUM()\n+          NT = OMP_GET_NUM_THREADS()\n+          IPOINTS = NPOINTS/NT\n+          ISTART = IAM * IPOINTS\n+          IF (IAM .EQ. NT-1) THEN\n+              IPOINTS = NPOINTS - ISTART\n+          ENDIF\n+          CALL SUBDOMAIN(X,ISTART,IPOINTS)\n+!$OMP END PARALLEL\n+      END SUBROUTINE SUB\n+      PROGRAM A4\n+          REAL ARRAY(10000)\n+          CALL SUB(ARRAY, 10000)\n+      END PROGRAM A4"}, {"sha": "38fbca3fceda0cfa62413fcfb35c949dcf091219", "filename": "libgomp/testsuite/libgomp.fortran/appendix-a/a.40.1.f90", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.40.1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.40.1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.40.1.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,52 @@\n+! { dg-do compile }\n+! { dg-options \"-ffixed-form\" }\n+        MODULE DATA\n+        USE OMP_LIB, ONLY: OMP_NEST_LOCK_KIND\n+        TYPE LOCKED_PAIR\n+        INTEGER A\n+        INTEGER B\n+        INTEGER (OMP_NEST_LOCK_KIND) LCK\n+        END TYPE\n+            END MODULE DATA\n+        SUBROUTINE INCR_A(P, A)\n+            ! called only from INCR_PAIR, no need to lock\n+            USE DATA\n+            TYPE(LOCKED_PAIR) :: P\n+            INTEGER A\n+            P%A = P%A + A\n+        END SUBROUTINE INCR_A\n+        SUBROUTINE INCR_B(P, B)\n+            ! called from both INCR_PAIR and elsewhere,\n+            ! so we need a nestable lock\n+            USE OMP_LIB       ! or INCLUDE \"omp_lib.h\"\n+            USE DATA\n+            TYPE(LOCKED_PAIR) :: P\n+            INTEGER B\n+            CALL OMP_SET_NEST_LOCK(P%LCK)\n+            P%B = P%B + B\n+            CALL OMP_UNSET_NEST_LOCK(P%LCK)\n+        END SUBROUTINE INCR_B\n+        SUBROUTINE INCR_PAIR(P, A, B)\n+            USE OMP_LIB         ! or INCLUDE \"omp_lib.h\"\n+            USE DATA\n+            TYPE(LOCKED_PAIR) :: P\n+            INTEGER A\n+            INTEGER B\n+        CALL OMP_SET_NEST_LOCK(P%LCK)\n+        CALL INCR_A(P, A)\n+        CALL INCR_B(P, B)\n+        CALL OMP_UNSET_NEST_LOCK(P%LCK)\n+      END SUBROUTINE INCR_PAIR\n+      SUBROUTINE A40(P)\n+        USE OMP_LIB        ! or INCLUDE \"omp_lib.h\"\n+        USE DATA\n+        TYPE(LOCKED_PAIR) :: P\n+        INTEGER WORK1, WORK2, WORK3\n+        EXTERNAL WORK1, WORK2, WORK3\n+!$OMP PARALLEL SECTIONS\n+!$OMP SECTION\n+          CALL INCR_PAIR(P, WORK1(), WORK2())\n+!$OMP SECTION\n+          CALL INCR_B(P, WORK3())\n+!$OMP END PARALLEL SECTIONS\n+      END SUBROUTINE A40"}, {"sha": "13e451e506a7dcd48062669f1884289bbc768d82", "filename": "libgomp/testsuite/libgomp.fortran/appendix-a/a.5.1.f90", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.5.1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.5.1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa.5.1.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,8 @@\n+! { dg-do run }\n+      PROGRAM A5\n+        INCLUDE \"omp_lib.h\"      ! or USE OMP_LIB\n+        CALL OMP_SET_DYNAMIC(.TRUE.)\n+!$OMP PARALLEL NUM_THREADS(10)\n+            ! do work here\n+!$OMP END PARALLEL\n+      END PROGRAM A5"}, {"sha": "c1564bf4b3f379d775a49192c6619e89849d0d22", "filename": "libgomp/testsuite/libgomp.fortran/appendix-a/a10.1.f90", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa10.1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa10.1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fappendix-a%2Fa10.1.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,20 @@\n+! { dg-do run }\n+      SUBROUTINE WORK1()\n+      END SUBROUTINE WORK1\n+      SUBROUTINE WORK2()\n+      END SUBROUTINE WORK2\n+      PROGRAM A10\n+!$OMP PARALLEL\n+!$OMP SINGLE\n+        print *, \"Beginning work1.\"\n+!$OMP END SINGLE\n+        CALL WORK1()\n+!$OMP SINGLE\n+        print *, \"Finishing work1.\"\n+!$OMP END SINGLE\n+!$OMP SINGLE\n+        print *, \"Finished work1 and beginning work2.\"\n+!$OMP END SINGLE NOWAIT\n+        CALL WORK2()\n+!$OMP END PARALLEL\n+      END PROGRAM A10"}, {"sha": "f75ae27e8f90997c0d754e83fbaccfd2e7c1aa72", "filename": "libgomp/testsuite/libgomp.fortran/character1.f90", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fcharacter1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fcharacter1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fcharacter1.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,72 @@\n+! { dg-do run }\n+!$ use omp_lib\n+\n+  character (len = 8) :: h, i\n+  character (len = 4) :: j, k\n+  h = '01234567'\n+  i = 'ABCDEFGH'\n+  j = 'IJKL'\n+  k = 'MN'\n+  call test (h, j)\n+contains\n+  subroutine test (p, q)\n+    character (len = 8) :: p\n+    character (len = 4) :: q, r\n+    character (len = 16) :: f\n+    character (len = 32) :: g\n+    integer, dimension (18) :: s\n+    logical :: l\n+    integer :: m\n+    f = 'test16'\n+    g = 'abcdefghijklmnopqrstuvwxyz'\n+    r = ''\n+    l = .false.\n+    s = -6\n+!$omp parallel firstprivate (f, p, s) private (r, m) reduction (.or.:l) &\n+!$omp & num_threads (4)\n+    m = omp_get_thread_num ()\n+    if (any (s .ne. -6)) l = .true.\n+    l = l .or. f .ne. 'test16' .or. p .ne. '01234567'\n+    l = l .or. g .ne. 'abcdefghijklmnopqrstuvwxyz'\n+    l = l .or. i .ne. 'ABCDEFGH' .or. q .ne. 'IJKL'\n+    l = l .or. k .ne. 'MN'\n+!$omp barrier\n+    if (m .eq. 0) then\n+      f = 'ffffffff0'\n+      g = 'xyz'\n+      i = '123'\n+      k = '9876'\n+      p = '_abc'\n+      q = '_def'\n+      r = '1_23'\n+    else if (m .eq. 1) then\n+      f = '__'\n+      p = 'xxx'\n+      r = '7575'\n+    else if (m .eq. 2) then\n+      f = 'ZZ'\n+      p = 'm2'\n+      r = 'M2'\n+    else if (m .eq. 3) then\n+      f = 'YY'\n+      p = 'm3'\n+      r = 'M3'\n+    end if\n+    s = m\n+!$omp barrier\n+    l = l .or. g .ne. 'xyz' .or. i .ne. '123' .or. k .ne. '9876'\n+    l = l .or. q .ne. '_def'\n+    if (any (s .ne. m)) l = .true.\n+    if (m .eq. 0) then\n+      l = l .or. f .ne. 'ffffffff0' .or. p .ne. '_abc' .or. r .ne. '1_23'\n+    else if (m .eq. 1) then\n+      l = l .or. f .ne. '__' .or. p .ne. 'xxx' .or. r .ne. '7575'\n+    else if (m .eq. 2) then\n+      l = l .or. f .ne. 'ZZ' .or. p .ne. 'm2' .or. r .ne. 'M2'\n+    else if (m .eq. 3) then\n+      l = l .or. f .ne. 'YY' .or. p .ne. 'm3' .or. r .ne. 'M3'\n+    end if\n+!$omp end parallel\n+    if (l) call abort\n+  end subroutine test\n+end"}, {"sha": "d59032b57a00721555f80443639c2c1810450848", "filename": "libgomp/testsuite/libgomp.fortran/character2.f90", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fcharacter2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fcharacter2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fcharacter2.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,61 @@\n+! { dg-do run }\n+!$ use omp_lib\n+\n+  character (len = 8) :: h\n+  character (len = 9) :: i\n+  h = '01234567'\n+  i = 'ABCDEFGHI'\n+  call test (h, i, 9)\n+contains\n+  subroutine test (p, q, n)\n+    character (len = *) :: p\n+    character (len = n) :: q\n+    character (len = n) :: r\n+    character (len = n) :: t\n+    character (len = n) :: u\n+    integer, dimension (n + 4) :: s\n+    logical :: l\n+    integer :: m\n+    r = ''\n+    if (n .gt. 8) r = 'jklmnopqr'\n+    do m = 1, n + 4\n+      s(m) = m\n+    end do\n+    u = 'abc'\n+    l = .false.\n+!$omp parallel firstprivate (p, q, r) private (t, m) reduction (.or.:l) &\n+!$omp & num_threads (2)\n+    do m = 1, 13\n+      if (s(m) .ne. m) l = .true.\n+    end do\n+    m = omp_get_thread_num ()\n+    l = l .or. p .ne. '01234567' .or. q .ne. 'ABCDEFGHI'\n+    l = l .or. r .ne. 'jklmnopqr' .or. u .ne. 'abc'\n+!$omp barrier\n+    if (m .eq. 0) then\n+      p = 'A'\n+      q = 'B'\n+      r = 'C'\n+      t = '123'\n+      u = '987654321'\n+    else if (m .eq. 1) then\n+      p = 'D'\n+      q = 'E'\n+      r = 'F'\n+      t = '456'\n+      s = m\n+    end if\n+!$omp barrier\n+    l = l .or. u .ne. '987654321'\n+    if (any (s .ne. 1)) l = .true.\n+    if (m .eq. 0) then\n+      l = l .or. p .ne. 'A' .or. q .ne. 'B' .or. r .ne. 'C'\n+      l = l .or. t .ne. '123'\n+    else\n+      l = l .or. p .ne. 'D' .or. q .ne. 'E' .or. r .ne. 'F'\n+      l = l .or. t .ne. '456'\n+    end if\n+!$omp end parallel\n+    if (l) call abort\n+  end subroutine test\n+end"}, {"sha": "57c59f71f9fe7ffbe89fbb75b4bd9fc2f28dd82e", "filename": "libgomp/testsuite/libgomp.fortran/crayptr1.f90", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fcrayptr1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fcrayptr1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fcrayptr1.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,46 @@\n+! { dg-do run }\n+! { dg-options \"-fopenmp -fcray-pointer\" }\n+\n+  use omp_lib\n+  integer :: a, b, c, p\n+  logical :: l\n+  pointer (ip, p)\n+  a = 1\n+  b = 2\n+  c = 3\n+  l = .false.\n+  ip = loc (a)\n+\n+!$omp parallel num_threads (2) reduction (.or.:l)\n+  l = p .ne. 1\n+!$omp barrier\n+!$omp master\n+  ip = loc (b)\n+!$omp end master\n+!$omp barrier\n+  l = l .or. p .ne. 2\n+!$omp barrier\n+  if (omp_get_thread_num () .eq. 1 .or. omp_get_num_threads () .lt. 2) &\n+    ip = loc (c)\n+!$omp barrier\n+  l = l .or. p .ne. 3\n+!$omp end parallel\n+\n+  if (l) call abort\n+\n+  l = .false.\n+!$omp parallel num_threads (2) reduction (.or.:l) default (private)\n+  ip = loc (a)\n+  a = 3 * omp_get_thread_num () + 4\n+  b = a + 1\n+  c = a + 2\n+  l = p .ne. 3 * omp_get_thread_num () + 4\n+  ip = loc (c)\n+  l = l .or. p .ne. 3 * omp_get_thread_num () + 6\n+  ip = loc (b)\n+  l = l .or. p .ne. 3 * omp_get_thread_num () + 5\n+!$omp end parallel\n+\n+  if (l) call abort\n+\n+end"}, {"sha": "2a48c7345fc040c80f01c86f3710bf01f86f499d", "filename": "libgomp/testsuite/libgomp.fortran/do1.f90", "status": "added", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fdo1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fdo1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fdo1.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,179 @@\n+! { dg-do run }\n+\n+  integer, dimension (128) :: a, b\n+  integer :: i\n+  a = -1\n+  b = -1\n+  do i = 1, 128\n+    if (i .ge. 8 .and. i .le. 15) then\n+      b(i) = 1 * 256 + i\n+    else if (i .ge. 19 .and. i .le. 23) then\n+      b(i) = 2 * 256 + i\n+    else if (i .ge. 28 .and. i .le. 38) then\n+      if (iand (i, 1) .eq. 0) b(i) = 3 * 256 + i\n+    else if (i .ge. 59 .and. i .le. 79) then\n+      if (iand (i - 59, 3) .eq. 0) b(i) = 4 * 256 + i\n+    else if (i .ge. 101 .and. i .le. 125) then\n+      if (mod (i - 101, 12) .eq. 0) b(i) = 5 * 256 + i\n+    end if\n+  end do\n+\n+!$omp parallel num_threads (4)\n+\n+!$omp do\n+  do i = 8, 15\n+    a(i) = 1 * 256 + i\n+  end do\n+\n+!$omp do\n+  do i = 23, 19, -1\n+    a(i) = 2 * 256 + i\n+  end do\n+\n+!$omp do\n+  do i = 28, 39, 2\n+    a(i) = 3 * 256 + i\n+  end do\n+\n+!$omp do\n+  do i = 79, 59, -4\n+    a(i) = 4 * 256 + i\n+  end do\n+\n+!$omp do\n+  do i = 125, 90, -12\n+    a(i) = 5 * 256 + i\n+  end do\n+\n+!$omp end parallel\n+\n+  if (any (a .ne. b)) call abort\n+  a = -1\n+\n+!$omp parallel num_threads (4)\n+\n+!$omp do schedule (static)\n+  do i = 8, 15\n+    a(i) = 1 * 256 + i\n+  end do\n+\n+!$omp do schedule (static, 1)\n+  do i = 23, 19, -1\n+    a(i) = 2 * 256 + i\n+  end do\n+\n+!$omp do schedule (static, 3)\n+  do i = 28, 39, 2\n+    a(i) = 3 * 256 + i\n+  end do\n+\n+!$omp do schedule (static, 6)\n+  do i = 79, 59, -4\n+    a(i) = 4 * 256 + i\n+  end do\n+\n+!$omp do schedule (static, 2)\n+  do i = 125, 90, -12\n+    a(i) = 5 * 256 + i\n+  end do\n+\n+!$omp end parallel\n+\n+  if (any (a .ne. b)) call abort\n+  a = -1\n+\n+!$omp parallel num_threads (4)\n+\n+!$omp do schedule (dynamic)\n+  do i = 8, 15\n+    a(i) = 1 * 256 + i\n+  end do\n+\n+!$omp do schedule (dynamic, 4)\n+  do i = 23, 19, -1\n+    a(i) = 2 * 256 + i\n+  end do\n+\n+!$omp do schedule (dynamic, 1)\n+  do i = 28, 39, 2\n+    a(i) = 3 * 256 + i\n+  end do\n+\n+!$omp do schedule (dynamic, 2)\n+  do i = 79, 59, -4\n+    a(i) = 4 * 256 + i\n+  end do\n+\n+!$omp do schedule (dynamic, 3)\n+  do i = 125, 90, -12\n+    a(i) = 5 * 256 + i\n+  end do\n+\n+!$omp end parallel\n+\n+  if (any (a .ne. b)) call abort\n+  a = -1\n+\n+!$omp parallel num_threads (4)\n+\n+!$omp do schedule (guided)\n+  do i = 8, 15\n+    a(i) = 1 * 256 + i\n+  end do\n+\n+!$omp do schedule (guided, 4)\n+  do i = 23, 19, -1\n+    a(i) = 2 * 256 + i\n+  end do\n+\n+!$omp do schedule (guided, 1)\n+  do i = 28, 39, 2\n+    a(i) = 3 * 256 + i\n+  end do\n+\n+!$omp do schedule (guided, 2)\n+  do i = 79, 59, -4\n+    a(i) = 4 * 256 + i\n+  end do\n+\n+!$omp do schedule (guided, 3)\n+  do i = 125, 90, -12\n+    a(i) = 5 * 256 + i\n+  end do\n+\n+!$omp end parallel\n+\n+  if (any (a .ne. b)) call abort\n+  a = -1\n+\n+!$omp parallel num_threads (4)\n+\n+!$omp do schedule (runtime)\n+  do i = 8, 15\n+    a(i) = 1 * 256 + i\n+  end do\n+\n+!$omp do schedule (runtime)\n+  do i = 23, 19, -1\n+    a(i) = 2 * 256 + i\n+  end do\n+\n+!$omp do schedule (runtime)\n+  do i = 28, 39, 2\n+    a(i) = 3 * 256 + i\n+  end do\n+\n+!$omp do schedule (runtime)\n+  do i = 79, 59, -4\n+    a(i) = 4 * 256 + i\n+  end do\n+\n+!$omp do schedule (runtime)\n+  do i = 125, 90, -12\n+    a(i) = 5 * 256 + i\n+  end do\n+\n+!$omp end parallel\n+\n+  if (any (a .ne. b)) call abort\n+end"}, {"sha": "b90ccddd80b919eb36e88c52033b9d2110acd025", "filename": "libgomp/testsuite/libgomp.fortran/do2.f90", "status": "added", "additions": 366, "deletions": 0, "changes": 366, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fdo2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fdo2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fdo2.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,366 @@\n+! { dg-do run }\n+\n+  integer, dimension (128) :: a, b\n+  integer :: i, j\n+  logical :: k\n+  a = -1\n+  b = -1\n+  do i = 1, 128\n+    if (i .ge. 8 .and. i .le. 15) then\n+      b(i) = 1 * 256 + i\n+    else if (i .ge. 19 .and. i .le. 23) then\n+      b(i) = 2 * 256 + i\n+    else if (i .ge. 28 .and. i .le. 38) then\n+      if (iand (i, 1) .eq. 0) b(i) = 3 * 256 + i\n+    else if (i .ge. 59 .and. i .le. 79) then\n+      if (iand (i - 59, 3) .eq. 0) b(i) = 4 * 256 + i\n+    else if (i .ge. 101 .and. i .le. 125) then\n+      if (mod (i - 101, 12) .eq. 0) b(i) = 5 * 256 + i\n+    end if\n+  end do\n+\n+  k = .false.\n+  j = 8\n+!$omp parallel num_threads (4)\n+\n+!$omp do ordered\n+  do i = 8, 15\n+    a(i) = 1 * 256 + i\n+!$omp ordered\n+    if (i .ne. j) k = .true.\n+    j = j + 1\n+!$omp end ordered\n+  end do\n+\n+!$omp single\n+  j = 23\n+!$omp end single\n+\n+!$omp do ordered\n+  do i = 23, 19, -1\n+    a(i) = 2 * 256 + i\n+!$omp ordered\n+    if (i .ne. j) k = .true.\n+    j = j - 1\n+!$omp end ordered\n+  end do\n+\n+!$omp single\n+  j = 28\n+!$omp end single\n+\n+!$omp do ordered\n+  do i = 28, 39, 2\n+    a(i) = 3 * 256 + i\n+!$omp ordered\n+    if (i .ne. j) k = .true.\n+    j = j + 2\n+!$omp end ordered\n+  end do\n+\n+!$omp single\n+  j = 79\n+!$omp end single\n+\n+!$omp do ordered\n+  do i = 79, 59, -4\n+    a(i) = 4 * 256 + i\n+!$omp ordered\n+    if (i .ne. j) k = .true.\n+    j = j - 4\n+!$omp end ordered\n+  end do\n+\n+!$omp single\n+  j = 125\n+!$omp end single\n+\n+!$omp do ordered\n+  do i = 125, 90, -12\n+    a(i) = 5 * 256 + i\n+!$omp ordered\n+    if (i .ne. j) k = .true.\n+    j = j - 12\n+!$omp end ordered\n+  end do\n+\n+!$omp end parallel\n+\n+  if (any (a .ne. b) .or. k) call abort\n+  a = -1\n+  k = .false.\n+  j = 8\n+!$omp parallel num_threads (4)\n+\n+!$omp do ordered schedule (static)\n+  do i = 8, 15\n+    a(i) = 1 * 256 + i\n+!$omp ordered\n+    if (i .ne. j) k = .true.\n+    j = j + 1\n+!$omp end ordered\n+  end do\n+\n+!$omp single\n+  j = 23\n+!$omp end single\n+\n+!$omp do ordered schedule (static, 1)\n+  do i = 23, 19, -1\n+    a(i) = 2 * 256 + i\n+!$omp ordered\n+    if (i .ne. j) k = .true.\n+    j = j - 1\n+!$omp end ordered\n+  end do\n+\n+!$omp single\n+  j = 28\n+!$omp end single\n+\n+!$omp do ordered schedule (static, 3)\n+  do i = 28, 39, 2\n+    a(i) = 3 * 256 + i\n+!$omp ordered\n+    if (i .ne. j) k = .true.\n+    j = j + 2\n+!$omp end ordered\n+  end do\n+\n+!$omp single\n+  j = 79\n+!$omp end single\n+\n+!$omp do ordered schedule (static, 6)\n+  do i = 79, 59, -4\n+    a(i) = 4 * 256 + i\n+!$omp ordered\n+    if (i .ne. j) k = .true.\n+    j = j - 4\n+!$omp end ordered\n+  end do\n+\n+!$omp single\n+  j = 125\n+!$omp end single\n+\n+!$omp do ordered schedule (static, 2)\n+  do i = 125, 90, -12\n+    a(i) = 5 * 256 + i\n+!$omp ordered\n+    if (i .ne. j) k = .true.\n+    j = j - 12\n+!$omp end ordered\n+  end do\n+\n+!$omp end parallel\n+\n+  if (any (a .ne. b) .or. k) call abort\n+  a = -1\n+  k = .false.\n+  j = 8\n+!$omp parallel num_threads (4)\n+\n+!$omp do ordered schedule (dynamic)\n+  do i = 8, 15\n+    a(i) = 1 * 256 + i\n+!$omp ordered\n+    if (i .ne. j) k = .true.\n+    j = j + 1\n+!$omp end ordered\n+  end do\n+\n+!$omp single\n+  j = 23\n+!$omp end single\n+\n+!$omp do ordered schedule (dynamic, 4)\n+  do i = 23, 19, -1\n+    a(i) = 2 * 256 + i\n+!$omp ordered\n+    if (i .ne. j) k = .true.\n+    j = j - 1\n+!$omp end ordered\n+  end do\n+\n+!$omp single\n+  j = 28\n+!$omp end single\n+\n+!$omp do ordered schedule (dynamic, 1)\n+  do i = 28, 39, 2\n+    a(i) = 3 * 256 + i\n+!$omp ordered\n+    if (i .ne. j) k = .true.\n+    j = j + 2\n+!$omp end ordered\n+  end do\n+\n+!$omp single\n+  j = 79\n+!$omp end single\n+\n+!$omp do ordered schedule (dynamic, 2)\n+  do i = 79, 59, -4\n+    a(i) = 4 * 256 + i\n+!$omp ordered\n+    if (i .ne. j) k = .true.\n+    j = j - 4\n+!$omp end ordered\n+  end do\n+\n+!$omp single\n+  j = 125\n+!$omp end single\n+\n+!$omp do ordered schedule (dynamic, 3)\n+  do i = 125, 90, -12\n+    a(i) = 5 * 256 + i\n+!$omp ordered\n+    if (i .ne. j) k = .true.\n+    j = j - 12\n+!$omp end ordered\n+  end do\n+\n+!$omp end parallel\n+\n+  if (any (a .ne. b) .or. k) call abort\n+  a = -1\n+  k = .false.\n+  j = 8\n+!$omp parallel num_threads (4)\n+\n+!$omp do ordered schedule (guided)\n+  do i = 8, 15\n+    a(i) = 1 * 256 + i\n+!$omp ordered\n+    if (i .ne. j) k = .true.\n+    j = j + 1\n+!$omp end ordered\n+  end do\n+\n+!$omp single\n+  j = 23\n+!$omp end single\n+\n+!$omp do ordered schedule (guided, 4)\n+  do i = 23, 19, -1\n+    a(i) = 2 * 256 + i\n+!$omp ordered\n+    if (i .ne. j) k = .true.\n+    j = j - 1\n+!$omp end ordered\n+  end do\n+\n+!$omp single\n+  j = 28\n+!$omp end single\n+\n+!$omp do ordered schedule (guided, 1)\n+  do i = 28, 39, 2\n+    a(i) = 3 * 256 + i\n+!$omp ordered\n+    if (i .ne. j) k = .true.\n+    j = j + 2\n+!$omp end ordered\n+  end do\n+\n+!$omp single\n+  j = 79\n+!$omp end single\n+\n+!$omp do ordered schedule (guided, 2)\n+  do i = 79, 59, -4\n+    a(i) = 4 * 256 + i\n+!$omp ordered\n+    if (i .ne. j) k = .true.\n+    j = j - 4\n+!$omp end ordered\n+  end do\n+\n+!$omp single\n+  j = 125\n+!$omp end single\n+\n+!$omp do ordered schedule (guided, 3)\n+  do i = 125, 90, -12\n+    a(i) = 5 * 256 + i\n+!$omp ordered\n+    if (i .ne. j) k = .true.\n+    j = j - 12\n+!$omp end ordered\n+  end do\n+\n+!$omp end parallel\n+\n+  if (any (a .ne. b) .or. k) call abort\n+  a = -1\n+  k = .false.\n+  j = 8\n+!$omp parallel num_threads (4)\n+\n+!$omp do ordered schedule (runtime)\n+  do i = 8, 15\n+    a(i) = 1 * 256 + i\n+!$omp ordered\n+    if (i .ne. j) k = .true.\n+    j = j + 1\n+!$omp end ordered\n+  end do\n+\n+!$omp single\n+  j = 23\n+!$omp end single\n+\n+!$omp do ordered schedule (runtime)\n+  do i = 23, 19, -1\n+    a(i) = 2 * 256 + i\n+!$omp ordered\n+    if (i .ne. j) k = .true.\n+    j = j - 1\n+!$omp end ordered\n+  end do\n+\n+!$omp single\n+  j = 28\n+!$omp end single\n+\n+!$omp do ordered schedule (runtime)\n+  do i = 28, 39, 2\n+    a(i) = 3 * 256 + i\n+!$omp ordered\n+    if (i .ne. j) k = .true.\n+    j = j + 2\n+!$omp end ordered\n+  end do\n+\n+!$omp single\n+  j = 79\n+!$omp end single\n+\n+!$omp do ordered schedule (runtime)\n+  do i = 79, 59, -4\n+    a(i) = 4 * 256 + i\n+!$omp ordered\n+    if (i .ne. j) k = .true.\n+    j = j - 4\n+!$omp end ordered\n+  end do\n+\n+!$omp single\n+  j = 125\n+!$omp end single\n+\n+!$omp do ordered schedule (runtime)\n+  do i = 125, 90, -12\n+    a(i) = 5 * 256 + i\n+!$omp ordered\n+    if (i .ne. j) k = .true.\n+    j = j - 12\n+!$omp end ordered\n+  end do\n+\n+!$omp end parallel\n+\n+  if (any (a .ne. b) .or. k) call abort\n+end"}, {"sha": "e7ee746c282ca4b8b8447a0b5f5c0a074fc94422", "filename": "libgomp/testsuite/libgomp.fortran/fortran.exp", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ffortran.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ffortran.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Ffortran.exp?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,20 @@\n+set lang_library_path\t\"../libgfortran/.libs\"\n+set lang_test_file\t\"${lang_library_path}/libgfortranbegin.a\"\n+set lang_link_flags\t\"-lgfortranbegin -lgfortran\"\n+\n+load_lib libgomp-dg.exp\n+\n+# Initialize dg.\n+dg-init\n+\n+if [file exists \"${blddir}/${lang_test_file}\"] {\n+\n+    # Gather a list of all tests.\n+    set tests [lsort [find $srcdir/$subdir *.\\[fF\\]{,90,95}]]\n+\n+    # Main loop.\n+    gfortran-dg-runtest $tests \"\"\n+}\n+\n+# All done.\n+dg-finish"}, {"sha": "b27e20f27669e242ca8a0b2306552a3b0127ef65", "filename": "libgomp/testsuite/libgomp.fortran/jacobi.f", "status": "added", "additions": 261, "deletions": 0, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fjacobi.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fjacobi.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fjacobi.f?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,261 @@\n+* { dg-do run }\n+\n+      program main \n+************************************************************\n+* program to solve a finite difference \n+* discretization of Helmholtz equation :  \n+* (d2/dx2)u + (d2/dy2)u - alpha u = f \n+* using Jacobi iterative method. \n+*\n+* Modified: Sanjiv Shah,       Kuck and Associates, Inc. (KAI), 1998\n+* Author:   Joseph Robicheaux, Kuck and Associates, Inc. (KAI), 1998\n+* \n+* Directives are used in this code to achieve paralleism. \n+* All do loops are parallized with default 'static' scheduling.\n+* \n+* Input :  n - grid dimension in x direction \n+*          m - grid dimension in y direction\n+*          alpha - Helmholtz constant (always greater than 0.0)\n+*          tol   - error tolerance for iterative solver\n+*          relax - Successice over relaxation parameter\n+*          mits  - Maximum iterations for iterative solver\n+*\n+* On output \n+*       : u(n,m) - Dependent variable (solutions)\n+*       : f(n,m) - Right hand side function \n+*************************************************************\n+      implicit none \n+\n+      integer n,m,mits,mtemp\n+      include \"omp_lib.h\"\n+      double precision tol,relax,alpha \n+\n+      common /idat/ n,m,mits,mtemp\n+      common /fdat/tol,alpha,relax\n+* \n+* Read info \n+* \n+      write(*,*) \"Input n,m - grid dimension in x,y direction \" \n+      n = 64\n+      m = 64\n+*     read(5,*) n,m \n+      write(*,*) n, m\n+      write(*,*) \"Input alpha - Helmholts constant \" \n+      alpha = 0.5\n+*     read(5,*) alpha\n+      write(*,*) alpha\n+      write(*,*) \"Input relax - Successive over-relaxation parameter\"\n+      relax = 0.9\n+*     read(5,*) relax \n+      write(*,*) relax\n+      write(*,*) \"Input tol - error tolerance for iterative solver\" \n+      tol = 1.0E-12\n+*     read(5,*) tol \n+      write(*,*) tol\n+      write(*,*) \"Input mits - Maximum iterations for solver\" \n+      mits = 100\n+*     read(5,*) mits\n+      write(*,*) mits\n+\n+      call omp_set_num_threads (2)\n+\n+*\n+* Calls a driver routine \n+* \n+      call driver () \n+\n+      stop\n+      end \n+\n+      subroutine driver ( ) \n+*************************************************************\n+* Subroutine driver () \n+* This is where the arrays are allocated and initialzed. \n+*\n+* Working varaibles/arrays \n+*     dx  - grid spacing in x direction \n+*     dy  - grid spacing in y direction \n+*************************************************************\n+      implicit none \n+\n+      integer n,m,mits,mtemp \n+      double precision tol,relax,alpha \n+\n+      common /idat/ n,m,mits,mtemp\n+      common /fdat/tol,alpha,relax\n+\n+      double precision u(n,m),f(n,m),dx,dy\n+\n+* Initialize data\n+\n+      call initialize (n,m,alpha,dx,dy,u,f)\n+\n+* Solve Helmholtz equation\n+\n+      call jacobi (n,m,dx,dy,alpha,relax,u,f,tol,mits)\n+\n+* Check error between exact solution\n+\n+      call  error_check (n,m,alpha,dx,dy,u,f)\n+\n+      return \n+      end \n+\n+      subroutine initialize (n,m,alpha,dx,dy,u,f) \n+******************************************************\n+* Initializes data \n+* Assumes exact solution is u(x,y) = (1-x^2)*(1-y^2)\n+*\n+******************************************************\n+      implicit none \n+     \n+      integer n,m\n+      double precision u(n,m),f(n,m),dx,dy,alpha\n+      \n+      integer i,j, xx,yy\n+      double precision PI \n+      parameter (PI=3.1415926)\n+\n+      dx = 2.0 / (n-1)\n+      dy = 2.0 / (m-1)\n+\n+* Initilize initial condition and RHS\n+\n+!$omp parallel do private(xx,yy)\n+      do j = 1,m\n+         do i = 1,n\n+            xx = -1.0 + dx * dble(i-1)        ! -1 < x < 1\n+            yy = -1.0 + dy * dble(j-1)        ! -1 < y < 1\n+            u(i,j) = 0.0 \n+            f(i,j) = -alpha *(1.0-xx*xx)*(1.0-yy*yy) \n+     &           - 2.0*(1.0-xx*xx)-2.0*(1.0-yy*yy)\n+         enddo\n+      enddo\n+!$omp end parallel do\n+\n+      return \n+      end \n+\n+      subroutine jacobi (n,m,dx,dy,alpha,omega,u,f,tol,maxit)\n+******************************************************************\n+* Subroutine HelmholtzJ\n+* Solves poisson equation on rectangular grid assuming : \n+* (1) Uniform discretization in each direction, and \n+* (2) Dirichlect boundary conditions \n+* \n+* Jacobi method is used in this routine \n+*\n+* Input : n,m   Number of grid points in the X/Y directions \n+*         dx,dy Grid spacing in the X/Y directions \n+*         alpha Helmholtz eqn. coefficient \n+*         omega Relaxation factor \n+*         f(n,m) Right hand side function \n+*         u(n,m) Dependent variable/Solution\n+*         tol    Tolerance for iterative solver \n+*         maxit  Maximum number of iterations \n+*\n+* Output : u(n,m) - Solution \n+*****************************************************************\n+      implicit none \n+      integer n,m,maxit\n+      double precision dx,dy,f(n,m),u(n,m),alpha, tol,omega\n+*\n+* Local variables \n+* \n+      integer i,j,k,k_local \n+      double precision error,resid,rsum,ax,ay,b\n+      double precision error_local, uold(n,m)\n+\n+      real ta,tb,tc,td,te,ta1,ta2,tb1,tb2,tc1,tc2,td1,td2\n+      real te1,te2\n+      real second\n+      external second\n+*\n+* Initialize coefficients \n+      ax = 1.0/(dx*dx) ! X-direction coef \n+      ay = 1.0/(dy*dy) ! Y-direction coef\n+      b  = -2.0/(dx*dx)-2.0/(dy*dy) - alpha ! Central coeff  \n+\n+      error = 10.0 * tol \n+      k = 1\n+\n+      do while (k.le.maxit .and. error.gt. tol) \n+\n+         error = 0.0    \n+\n+* Copy new solution into old\n+!$omp parallel\n+\n+!$omp do \n+         do j=1,m\n+            do i=1,n\n+               uold(i,j) = u(i,j) \n+            enddo\n+         enddo\n+\n+* Compute stencil, residual, & update\n+\n+!$omp do private(resid) reduction(+:error)\n+         do j = 2,m-1\n+            do i = 2,n-1 \n+*     Evaluate residual \n+               resid = (ax*(uold(i-1,j) + uold(i+1,j)) \n+     &                + ay*(uold(i,j-1) + uold(i,j+1))\n+     &                 + b * uold(i,j) - f(i,j))/b\n+* Update solution \n+               u(i,j) = uold(i,j) - omega * resid\n+* Accumulate residual error\n+               error = error + resid*resid \n+            end do\n+         enddo\n+!$omp enddo nowait\n+\n+!$omp end parallel\n+\n+* Error check \n+\n+         k = k + 1\n+\n+         error = sqrt(error)/dble(n*m)\n+*\n+      enddo                     ! End iteration loop \n+*\n+      print *, 'Total Number of Iterations ', k \n+      print *, 'Residual                   ', error \n+\n+      return \n+      end \n+\n+      subroutine error_check (n,m,alpha,dx,dy,u,f) \n+      implicit none \n+************************************************************\n+* Checks error between numerical and exact solution \n+*\n+************************************************************ \n+     \n+      integer n,m\n+      double precision u(n,m),f(n,m),dx,dy,alpha \n+      \n+      integer i,j\n+      double precision xx,yy,temp,error \n+\n+      dx = 2.0 / (n-1)\n+      dy = 2.0 / (m-1)\n+      error = 0.0 \n+\n+!$omp parallel do private(xx,yy,temp) reduction(+:error)\n+      do j = 1,m\n+         do i = 1,n\n+            xx = -1.0d0 + dx * dble(i-1)\n+            yy = -1.0d0 + dy * dble(j-1)\n+            temp  = u(i,j) - (1.0-xx*xx)*(1.0-yy*yy)\n+            error = error + temp*temp \n+         enddo\n+      enddo\n+  \n+      error = sqrt(error)/dble(n*m)\n+\n+      print *, 'Solution Error : ',error\n+\n+      return \n+      end "}, {"sha": "8840018674adb62c3ae6e5d91c057b7dcacd8649", "filename": "libgomp/testsuite/libgomp.fortran/lib1.f90", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Flib1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Flib1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Flib1.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,76 @@\n+! { dg-do run }\n+\n+  use omp_lib\n+\n+  double precision :: d, e\n+  logical :: l\n+  integer (kind = omp_lock_kind) :: lck\n+  integer (kind = omp_nest_lock_kind) :: nlck\n+\n+  d = omp_get_wtime ()\n+\n+  call omp_init_lock (lck)\n+  call omp_set_lock (lck)\n+  if (omp_test_lock (lck)) call abort\n+  call omp_unset_lock (lck)\n+  if (.not. omp_test_lock (lck)) call abort\n+  if (omp_test_lock (lck)) call abort\n+  call omp_unset_lock (lck)\n+  call omp_destroy_lock (lck)\n+\n+  call omp_init_nest_lock (nlck)\n+  if (omp_test_nest_lock (nlck) .ne. 1) call abort\n+  call omp_set_nest_lock (nlck)\n+  if (omp_test_nest_lock (nlck) .ne. 3) call abort\n+  call omp_unset_nest_lock (nlck)\n+  call omp_unset_nest_lock (nlck)\n+  if (omp_test_nest_lock (nlck) .ne. 2) call abort\n+  call omp_unset_nest_lock (nlck)\n+  call omp_unset_nest_lock (nlck)\n+  call omp_destroy_nest_lock (nlck)\n+\n+  call omp_set_dynamic (.true.)\n+  if (.not. omp_get_dynamic ()) call abort\n+  call omp_set_dynamic (.false.)\n+  if (omp_get_dynamic ()) call abort\n+\n+  call omp_set_nested (.true.)\n+  if (.not. omp_get_nested ()) call abort\n+  call omp_set_nested (.false.)\n+  if (omp_get_nested ()) call abort\n+\n+  call omp_set_num_threads (5)\n+  if (omp_get_num_threads () .ne. 1) call abort\n+  if (omp_get_max_threads () .ne. 5) call abort\n+  if (omp_get_thread_num () .ne. 0) call abort\n+  call omp_set_num_threads (3)\n+  if (omp_get_num_threads () .ne. 1) call abort\n+  if (omp_get_max_threads () .ne. 3) call abort\n+  if (omp_get_thread_num () .ne. 0) call abort\n+  l = .false.\n+!$omp parallel reduction (.or.:l)\n+  l = omp_get_num_threads () .ne. 3\n+  l = l .or. (omp_get_thread_num () .lt. 0)\n+  l = l .or. (omp_get_thread_num () .ge. 3)\n+!$omp master\n+  l = l .or. (omp_get_thread_num () .ne. 0)\n+!$omp end master\n+!$omp end parallel\n+  if (l) call abort\n+\n+  if (omp_get_num_procs () .le. 0) call abort\n+  if (omp_in_parallel ()) call abort\n+!$omp parallel reduction (.or.:l)\n+  l = .not. omp_in_parallel ()\n+!$omp end parallel\n+!$omp parallel reduction (.or.:l) if (.true.)\n+  l = .not. omp_in_parallel ()\n+!$omp end parallel\n+\n+  e = omp_get_wtime ()\n+  if (d .gt. e) call abort\n+  d = omp_get_wtick ()\n+  ! Negative precision is definitely wrong,\n+  ! bigger than 1s clock resolution is also strange\n+  if (d .le. 0 .or. d .gt. 1.) call abort\n+end"}, {"sha": "75510827043ec732ada4efb6f79285d9fd1fe047", "filename": "libgomp/testsuite/libgomp.fortran/lib2.f", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Flib2.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Flib2.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Flib2.f?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,76 @@\n+C { dg-do run }\n+\n+      USE OMP_LIB\n+\n+      DOUBLE PRECISION :: D, E\n+      LOGICAL :: L\n+      INTEGER (KIND = OMP_LOCK_KIND) :: LCK\n+      INTEGER (KIND = OMP_NEST_LOCK_KIND) :: NLCK\n+\n+      D = OMP_GET_WTIME ()\n+\n+      CALL OMP_INIT_LOCK (LCK)\n+      CALL OMP_SET_LOCK (LCK)\n+      IF (OMP_TEST_LOCK (LCK)) CALL ABORT\n+      CALL OMP_UNSET_LOCK (LCK)\n+      IF (.NOT. OMP_TEST_LOCK (LCK)) CALL ABORT\n+      IF (OMP_TEST_LOCK (LCK)) CALL ABORT\n+      CALL OMP_UNSET_LOCK (LCK)\n+      CALL OMP_DESTROY_LOCK (LCK)\n+\n+      CALL OMP_INIT_NEST_LOCK (NLCK)\n+      IF (OMP_TEST_NEST_LOCK (NLCK) .NE. 1) CALL ABORT\n+      CALL OMP_SET_NEST_LOCK (NLCK)\n+      IF (OMP_TEST_NEST_LOCK (NLCK) .NE. 3) CALL ABORT\n+      CALL OMP_UNSET_NEST_LOCK (NLCK)\n+      CALL OMP_UNSET_NEST_LOCK (NLCK)\n+      IF (OMP_TEST_NEST_LOCK (NLCK) .NE. 2) CALL ABORT\n+      CALL OMP_UNSET_NEST_LOCK (NLCK)\n+      CALL OMP_UNSET_NEST_LOCK (NLCK)\n+      CALL OMP_DESTROY_NEST_LOCK (NLCK)\n+\n+      CALL OMP_SET_DYNAMIC (.TRUE.)\n+      IF (.NOT. OMP_GET_DYNAMIC ()) CALL ABORT\n+      CALL OMP_SET_DYNAMIC (.FALSE.)\n+      IF (OMP_GET_DYNAMIC ()) CALL ABORT\n+\n+      CALL OMP_SET_NESTED (.TRUE.)\n+      IF (.NOT. OMP_GET_NESTED ()) CALL ABORT\n+      CALL OMP_SET_NESTED (.FALSE.)\n+      IF (OMP_GET_NESTED ()) CALL ABORT\n+\n+      CALL OMP_SET_NUM_THREADS (5)\n+      IF (OMP_GET_NUM_THREADS () .NE. 1) CALL ABORT\n+      IF (OMP_GET_MAX_THREADS () .NE. 5) CALL ABORT\n+      IF (OMP_GET_THREAD_NUM () .NE. 0) CALL ABORT\n+      CALL OMP_SET_NUM_THREADS (3)\n+      IF (OMP_GET_NUM_THREADS () .NE. 1) CALL ABORT\n+      IF (OMP_GET_MAX_THREADS () .NE. 3) CALL ABORT\n+      IF (OMP_GET_THREAD_NUM () .NE. 0) CALL ABORT\n+      L = .FALSE.\n+C$OMP PARALLEL REDUCTION (.OR.:L)\n+      L = OMP_GET_NUM_THREADS () .NE. 3\n+      L = L .OR. (OMP_GET_THREAD_NUM () .LT. 0)\n+      L = L .OR. (OMP_GET_THREAD_NUM () .GE. 3)\n+C$OMP MASTER\n+      L = L .OR. (OMP_GET_THREAD_NUM () .NE. 0)\n+C$OMP END MASTER\n+C$OMP END PARALLEL\n+      IF (L) CALL ABORT\n+\n+      IF (OMP_GET_NUM_PROCS () .LE. 0) CALL ABORT\n+      IF (OMP_IN_PARALLEL ()) CALL ABORT\n+C$OMP PARALLEL REDUCTION (.OR.:L)\n+      L = .NOT. OMP_IN_PARALLEL ()\n+C$OMP END PARALLEL\n+C$OMP PARALLEL REDUCTION (.OR.:L) IF (.TRUE.)\n+      L = .NOT. OMP_IN_PARALLEL ()\n+C$OMP END PARALLEL\n+\n+      E = OMP_GET_WTIME ()\n+      IF (D .GT. E) CALL ABORT\n+      D = OMP_GET_WTICK ()\n+C Negative precision is definitely wrong,\n+C bigger than 1s clock resolution is also strange\n+      IF (D .LE. 0 .OR. D .GT. 1.) CALL ABORT\n+      END"}, {"sha": "fa7b227c0ef7f7a7a745edbf407cf8be2a848728", "filename": "libgomp/testsuite/libgomp.fortran/lib3.f", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Flib3.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Flib3.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Flib3.f?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,76 @@\n+C { dg-do run }\n+\n+      INCLUDE \"omp_lib.h\"\n+\n+      DOUBLE PRECISION :: D, E\n+      LOGICAL :: L\n+      INTEGER (KIND = OMP_LOCK_KIND) :: LCK\n+      INTEGER (KIND = OMP_NEST_LOCK_KIND) :: NLCK\n+\n+      D = OMP_GET_WTIME ()\n+\n+      CALL OMP_INIT_LOCK (LCK)\n+      CALL OMP_SET_LOCK (LCK)\n+      IF (OMP_TEST_LOCK (LCK)) CALL ABORT\n+      CALL OMP_UNSET_LOCK (LCK)\n+      IF (.NOT. OMP_TEST_LOCK (LCK)) CALL ABORT\n+      IF (OMP_TEST_LOCK (LCK)) CALL ABORT\n+      CALL OMP_UNSET_LOCK (LCK)\n+      CALL OMP_DESTROY_LOCK (LCK)\n+\n+      CALL OMP_INIT_NEST_LOCK (NLCK)\n+      IF (OMP_TEST_NEST_LOCK (NLCK) .NE. 1) CALL ABORT\n+      CALL OMP_SET_NEST_LOCK (NLCK)\n+      IF (OMP_TEST_NEST_LOCK (NLCK) .NE. 3) CALL ABORT\n+      CALL OMP_UNSET_NEST_LOCK (NLCK)\n+      CALL OMP_UNSET_NEST_LOCK (NLCK)\n+      IF (OMP_TEST_NEST_LOCK (NLCK) .NE. 2) CALL ABORT\n+      CALL OMP_UNSET_NEST_LOCK (NLCK)\n+      CALL OMP_UNSET_NEST_LOCK (NLCK)\n+      CALL OMP_DESTROY_NEST_LOCK (NLCK)\n+\n+      CALL OMP_SET_DYNAMIC (.TRUE.)\n+      IF (.NOT. OMP_GET_DYNAMIC ()) CALL ABORT\n+      CALL OMP_SET_DYNAMIC (.FALSE.)\n+      IF (OMP_GET_DYNAMIC ()) CALL ABORT\n+\n+      CALL OMP_SET_NESTED (.TRUE.)\n+      IF (.NOT. OMP_GET_NESTED ()) CALL ABORT\n+      CALL OMP_SET_NESTED (.FALSE.)\n+      IF (OMP_GET_NESTED ()) CALL ABORT\n+\n+      CALL OMP_SET_NUM_THREADS (5)\n+      IF (OMP_GET_NUM_THREADS () .NE. 1) CALL ABORT\n+      IF (OMP_GET_MAX_THREADS () .NE. 5) CALL ABORT\n+      IF (OMP_GET_THREAD_NUM () .NE. 0) CALL ABORT\n+      CALL OMP_SET_NUM_THREADS (3)\n+      IF (OMP_GET_NUM_THREADS () .NE. 1) CALL ABORT\n+      IF (OMP_GET_MAX_THREADS () .NE. 3) CALL ABORT\n+      IF (OMP_GET_THREAD_NUM () .NE. 0) CALL ABORT\n+      L = .FALSE.\n+C$OMP PARALLEL REDUCTION (.OR.:L)\n+      L = OMP_GET_NUM_THREADS () .NE. 3\n+      L = L .OR. (OMP_GET_THREAD_NUM () .LT. 0)\n+      L = L .OR. (OMP_GET_THREAD_NUM () .GE. 3)\n+C$OMP MASTER\n+      L = L .OR. (OMP_GET_THREAD_NUM () .NE. 0)\n+C$OMP END MASTER\n+C$OMP END PARALLEL\n+      IF (L) CALL ABORT\n+\n+      IF (OMP_GET_NUM_PROCS () .LE. 0) CALL ABORT\n+      IF (OMP_IN_PARALLEL ()) CALL ABORT\n+C$OMP PARALLEL REDUCTION (.OR.:L)\n+      L = .NOT. OMP_IN_PARALLEL ()\n+C$OMP END PARALLEL\n+C$OMP PARALLEL REDUCTION (.OR.:L) IF (.TRUE.)\n+      L = .NOT. OMP_IN_PARALLEL ()\n+C$OMP END PARALLEL\n+\n+      E = OMP_GET_WTIME ()\n+      IF (D .GT. E) CALL ABORT\n+      D = OMP_GET_WTICK ()\n+C Negative precision is definitely wrong,\n+C bigger than 1s clock resolution is also strange\n+      IF (D .LE. 0 .OR. D .GT. 1.) CALL ABORT\n+      END"}, {"sha": "67dadd6dfc1229870a7d86425d297ceef0390b00", "filename": "libgomp/testsuite/libgomp.fortran/nestedfn1.f90", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fnestedfn1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fnestedfn1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fnestedfn1.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,43 @@\n+! { dg-do run }\n+\n+  integer :: a, b, c\n+  a = 1\n+  b = 2\n+  c = 3\n+  call foo\n+  if (a .ne. 7) call abort\n+contains\n+  subroutine foo\n+    use omp_lib\n+    logical :: l\n+    l = .false.\n+!$omp parallel shared (a) private (b) firstprivate (c) &\n+!$omp num_threads (2) reduction (.or.:l)\n+    if (a .ne. 1 .or. c .ne. 3) l = .true.\n+!$omp barrier\n+    if (omp_get_thread_num () .eq. 0) then\n+      a = 4\n+      b = 5\n+      c = 6\n+    end if\n+!$omp barrier\n+    if (omp_get_thread_num () .eq. 1) then\n+      if (a .ne. 4 .or. c .ne. 3) l = .true.\n+      a = 7\n+      b = 8\n+      c = 9\n+    else if (omp_get_num_threads () .eq. 1) then\n+      a = 7\n+    end if\n+!$omp barrier\n+    if (omp_get_thread_num () .eq. 0) then\n+      if (a .ne. 7 .or. b .ne. 5 .or. c .ne. 6) l = .true.\n+    end if\n+!$omp barrier\n+    if (omp_get_thread_num () .eq. 1) then\n+      if (a .ne. 7 .or. b .ne. 8 .or. c .ne. 9) l = .true.\n+    end if\n+!$omp end parallel\n+    if (l) call abort\n+  end subroutine foo\n+end"}, {"sha": "dfb12ae6622c863113d635f13ecf3a4dd0798b97", "filename": "libgomp/testsuite/libgomp.fortran/nestedfn2.f90", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fnestedfn2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fnestedfn2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fnestedfn2.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,34 @@\n+! { dg-do run }\n+\n+  integer :: i\n+  common /c/ i\n+  i = -1\n+!$omp parallel shared (i) num_threads (4)\n+  call test1\n+!$omp end parallel\n+end\n+subroutine test1\n+  integer :: vari\n+  call test2\n+  call test3\n+contains\n+  subroutine test2\n+    use omp_lib\n+    integer :: i\n+    common /c/ i\n+!$omp single\n+    i = omp_get_thread_num ()\n+    call test4\n+!$omp end single copyprivate (vari)\n+  end subroutine test2\n+  subroutine test3\n+    integer :: i\n+    common /c/ i\n+    if (i .lt. 0 .or. i .ge. 4) call abort\n+    if (i + 10 .ne. vari) call abort\n+  end subroutine test3\n+  subroutine test4\n+    use omp_lib\n+    vari = omp_get_thread_num () + 10\n+  end subroutine test4\n+end subroutine test1"}, {"sha": "f9ce94b9ad7a3088aa84d4bb58696d53ac1a4440", "filename": "libgomp/testsuite/libgomp.fortran/omp_atomic1.f90", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fomp_atomic1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fomp_atomic1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fomp_atomic1.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,39 @@\n+! { dg-do run }\n+    integer (kind = 4) :: a\n+    integer (kind = 2) :: b\n+    real :: c, f\n+    double precision :: d\n+    integer, dimension (10) :: e\n+    a = 1\n+    b = 2\n+    c = 3\n+    d = 4\n+    e = 5\n+    f = 6\n+!$omp atomic\n+    a = a + 4\n+!$omp atomic\n+    b = 4 - b\n+!$omp atomic\n+    c = c * 2\n+!$omp atomic\n+    d = 2 / d\n+    if (a .ne. 5 .or. b .ne. 2 .or. c .ne. 6 .or. d .ne. 0.5) call abort\n+    d = 1.2\n+!$omp atomic\n+    a = a + c + d\n+!$omp atomic\n+    b = b - (a + c + d)\n+    if (a .ne. 12 .or. b .ne. -17) call abort\n+!$omp atomic\n+    a = c + d + a\n+!$omp atomic\n+    b = a + c + d - b\n+    if (a .ne. 19 .or. b .ne. 43) call abort\n+!$omp atomic\n+    b = (a + c + d) - b\n+    a = 32\n+!$omp atomic\n+    a = a / 3.4\n+    if (a .ne. 9 .or. b .ne. -16) call abort\n+end"}, {"sha": "1dea2c8ebd88dc081d4ee2cce888990343d0cee9", "filename": "libgomp/testsuite/libgomp.fortran/omp_atomic2.f90", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fomp_atomic2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fomp_atomic2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fomp_atomic2.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,54 @@\n+! { dg-do run }\n+  real, dimension (20) :: r\n+  integer, dimension (20) :: d\n+  integer :: i, j, k, n\n+  integer (kind = 2) :: a, b, c\n+\n+  do 10 i = 1, 20\n+    r(i) = i\n+10  d(i) = 21 - i\n+\n+  n = 20\n+  call foo (r, d, n)\n+\n+  if (n .ne. 22) call abort\n+  if (any (r .ne. 33)) call abort\n+\n+  i = 1\n+  j = 18\n+  k = 23\n+!$omp atomic\n+  i = min (i, j, k, n)\n+  if (i .ne. 1) call abort\n+!$omp atomic\n+  i = max (j, n, k, i)\n+  if (i .ne. 23) call abort\n+\n+  a = 1\n+  b = 18\n+  c = 23\n+!$omp atomic\n+  a = min (a, b, c)\n+  if (a .ne. 1) call abort\n+!$omp atomic\n+  a = max (a, b, c)\n+  if (a .ne. 23) call abort\n+\n+contains\n+  function bar (i)\n+    real bar\n+    integer i\n+    bar = 12.0 + i\n+  end function bar\n+\n+  subroutine foo (x, y, n)\n+    integer i, y (*), n\n+    real x (*)\n+    do i = 1, n\n+!$omp atomic\n+      x(y(i)) = x(y(i)) + bar (i)\n+    end do\n+!$omp atomic\n+    n = n + 2\n+  end subroutine foo\n+end"}, {"sha": "b557d90800354fc252d0aa8165c39aff27f248ba", "filename": "libgomp/testsuite/libgomp.fortran/omp_cond1.f", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fomp_cond1.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fomp_cond1.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fomp_cond1.f?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,22 @@\n+C Test conditional compilation in fixed form if -fopenmp\n+! { dg-options \"-fopenmp\" }\n+   10 foo = 2\n+     &56\n+      if (foo.ne.256) call abort\n+      bar = 26\n+!$2 0 ba\n+c$   +r = 42\n+      !$ bar = 62\n+!$    bar = bar + 1\n+      if (bar.ne.43) call abort\n+      baz = bar\n+*$   0baz = 5\n+C$   +12! Comment\n+c$   !4\n+!$   +!Another comment\n+*$   &2\n+!$ X  baz = 0 ! Not valid OpenMP conditional compilation lines\n+! $   baz = 1\n+c$ 10&baz = 2\n+      if (baz.ne.51242) call abort\n+      end"}, {"sha": "6df891c6c67051eee42a42f978871c37dcd1cd31", "filename": "libgomp/testsuite/libgomp.fortran/omp_cond2.f", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fomp_cond2.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fomp_cond2.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fomp_cond2.f?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,22 @@\n+c Test conditional compilation in fixed form if -fno-openmp\n+! { dg-options \"-fno-openmp\" }\n+   10 foo = 2\n+     &56\n+      if (foo.ne.256) call abort\n+      bar = 26\n+!$2 0 ba\n+c$   +r = 42\n+      !$ bar = 62\n+!$    bar = bar + 1\n+      if (bar.ne.26) call abort\n+      baz = bar\n+*$   0baz = 5\n+C$   +12! Comment\n+c$   !4\n+!$   +!Another comment\n+*$   &2\n+!$ X  baz = 0 ! Not valid OpenMP conditional compilation lines\n+! $   baz = 1\n+c$ 10&baz = 2\n+      if (baz.ne.26) call abort\n+      end"}, {"sha": "6c4e36e2293d55a9305e8feac521923429842a10", "filename": "libgomp/testsuite/libgomp.fortran/omp_cond3.F90", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fomp_cond3.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fomp_cond3.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fomp_cond3.F90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,24 @@\n+! Test conditional compilation in free form if -fopenmp\n+! { dg-options \"-fopenmp\" }\n+   10 foo = 2&\n+  &56\n+  if (foo.ne.256) call abort\n+  bar = 26\n+   !$  20 ba&\n+!$   &r = 4&\n+  !$2\n+      !$bar = 62\n+   !$ bar = bar + 2\n+#ifdef _OPENMP\n+bar = bar - 1\n+#endif\n+  if (bar.ne.43) call abort\n+      baz = bar\n+!$ 30 baz = 5&     ! Comment\n+!$12  &  \n+  !$ + 2\n+!$X baz = 0 ! Not valid OpenMP conditional compilation lines\n+! $   baz = 1\n+baz = baz + 1 !$ baz = 2\n+      if (baz.ne.515) call abort\n+      end"}, {"sha": "aa4c5cb76d6f834a208a35e4dcd67f1e612a18f1", "filename": "libgomp/testsuite/libgomp.fortran/omp_cond4.F90", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fomp_cond4.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fomp_cond4.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fomp_cond4.F90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,24 @@\n+! Test conditional compilation in free form if -fno-openmp\n+! { dg-options \"-fno-openmp\" }\n+   10 foo = 2&\n+  &56\n+  if (foo.ne.256) call abort\n+  bar = 26\n+   !$  20 ba&\n+!$   &r = 4&\n+  !$2\n+      !$bar = 62\n+   !$ bar = bar + 2\n+#ifdef _OPENMP\n+bar = bar - 1\n+#endif\n+  if (bar.ne.26) call abort\n+      baz = bar\n+!$ 30 baz = 5&     ! Comment\n+!$12  &  \n+  !$ + 2\n+!$X baz = 0 ! Not valid OpenMP conditional compilation lines\n+! $   baz = 1\n+baz = baz + 1 !$ baz = 2\n+      if (baz.ne.27) call abort\n+      end"}, {"sha": "ba44531262508aa3a2bb3e4dd72f155ec6778720", "filename": "libgomp/testsuite/libgomp.fortran/omp_hello.f", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fomp_hello.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fomp_hello.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fomp_hello.f?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,36 @@\n+C******************************************************************************\n+C FILE: omp_hello.f\n+C DESCRIPTION:\n+C   OpenMP Example - Hello World - Fortran Version\n+C   In this simple example, the master thread forks a parallel region.\n+C   All threads in the team obtain their unique thread number and print it.\n+C   The master thread only prints the total number of threads.  Two OpenMP\n+C   library routines are used to obtain the number of threads and each\n+C   thread's number.\n+C AUTHOR: Blaise Barney  5/99\n+C LAST REVISED:\n+C******************************************************************************\n+\n+      PROGRAM HELLO\n+\n+      INTEGER NTHREADS, TID, OMP_GET_NUM_THREADS,\n+     +        OMP_GET_THREAD_NUM\n+\n+C     Fork a team of threads giving them their own copies of variables\n+!$OMP PARALLEL PRIVATE(NTHREADS, TID)\n+\n+\n+C     Obtain thread number\n+      TID = OMP_GET_THREAD_NUM()\n+      PRINT *, 'Hello World from thread = ', TID\n+\n+C     Only master thread does this\n+      IF (TID .EQ. 0) THEN\n+        NTHREADS = OMP_GET_NUM_THREADS()\n+        PRINT *, 'Number of threads = ', NTHREADS\n+      END IF\n+\n+C     All threads join master thread and disband\n+!$OMP END PARALLEL\n+\n+      END"}, {"sha": "7653c78d2e40d42d88a65b8882594bca5f32dbd6", "filename": "libgomp/testsuite/libgomp.fortran/omp_orphan.f", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fomp_orphan.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fomp_orphan.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fomp_orphan.f?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,44 @@\n+C******************************************************************************\n+C FILE: omp_orphan.f\n+C DESCRIPTION:\n+C   OpenMP Example - Parallel region with an orphaned directive - Fortran\n+C   Version\n+C   This example demonstrates a dot product being performed by an orphaned\n+C   loop reduction construct.  Scoping of the reduction variable is critical.\n+C AUTHOR: Blaise Barney  5/99\n+C LAST REVISED:\n+C******************************************************************************\n+\n+      PROGRAM ORPHAN\n+      COMMON /DOTDATA/ A, B, SUM\n+      INTEGER I, VECLEN\n+      PARAMETER (VECLEN = 100)\n+      REAL*8 A(VECLEN), B(VECLEN), SUM\n+\n+      DO I=1, VECLEN\n+         A(I) = 1.0 * I\n+         B(I) = A(I)\n+      ENDDO\n+      SUM = 0.0\n+!$OMP PARALLEL\n+      CALL DOTPROD\n+!$OMP END PARALLEL\n+      WRITE(*,*) \"Sum = \", SUM\n+      END\n+\n+\n+\n+      SUBROUTINE DOTPROD\n+      COMMON /DOTDATA/ A, B, SUM\n+      INTEGER I, TID, OMP_GET_THREAD_NUM, VECLEN\n+      PARAMETER (VECLEN = 100)\n+      REAL*8 A(VECLEN), B(VECLEN), SUM\n+\n+      TID = OMP_GET_THREAD_NUM()\n+!$OMP DO REDUCTION(+:SUM)\n+      DO I=1, VECLEN\n+         SUM = SUM + (A(I)*B(I))\n+         PRINT *, '  TID= ',TID,'I= ',I\n+      ENDDO\n+      RETURN\n+      END"}, {"sha": "9cd8cc2ba13499d43e0119951c2945896c0d5cd9", "filename": "libgomp/testsuite/libgomp.fortran/omp_parse1.f90", "status": "added", "additions": 185, "deletions": 0, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fomp_parse1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fomp_parse1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fomp_parse1.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,185 @@\n+! { dg-do run }\n+use omp_lib\n+  call test_parallel\n+  call test_do\n+  call test_sections\n+  call test_single\n+\n+contains\n+  subroutine test_parallel\n+    integer :: a, b, c, e, f, g, i, j\n+    integer, dimension (20) :: d\n+    logical :: h\n+    a = 6\n+    b = 8\n+    c = 11\n+    d(:) = -1\n+    e = 13\n+    f = 24\n+    g = 27\n+    h = .false.\n+    i = 1\n+    j = 16\n+!$omp para&\n+!$omp&llel &\n+!$omp if (a .eq. 6) private (b, c) shared (d) private (e) &\n+  !$omp firstprivate(f) num_threads (a - 1) first&\n+!$ompprivate(g)default (shared) reduction (.or. : h) &\n+!$omp reduction(*:i)\n+    if (i .ne. 1) h = .true.\n+    i = 2\n+    if (f .ne. 24) h = .true.\n+    if (g .ne. 27) h = .true.\n+    e = 7\n+    b = omp_get_thread_num ()\n+    if (b .eq. 0) j = 24\n+    f = b\n+    g = f\n+    c = omp_get_num_threads ()\n+    if (c .gt. a - 1 .or. c .le. 0) h = .true.\n+    if (b .ge. c) h = .true.\n+    d(b + 1) = c\n+    if (f .ne. g .or. f .ne. b) h = .true.\n+!$omp endparallel\n+    if (h) call abort\n+    if (a .ne. 6) call abort\n+    if (j .ne. 24) call abort\n+    if (d(1) .eq. -1) call abort\n+    e = 1\n+    do g = 1, d(1)\n+      if (d(g) .ne. d(1)) call abort\n+      e = e * 2\n+    end do\n+    if (e .ne. i) call abort\n+  end subroutine test_parallel\n+\n+  subroutine test_do_orphan\n+    integer :: k, l\n+!$omp parallel do private (l)\n+    do 600 k = 1, 16, 2\n+600   l = k\n+  end subroutine test_do_orphan\n+\n+  subroutine test_do\n+    integer :: i, j, k, l, n\n+    integer, dimension (64) :: d\n+    logical :: m\n+\n+    j = 16\n+    d(:) = -1\n+    m = .true.\n+    n = 24\n+!$omp parallel num_threads (4) shared (i, k, d) private (l) &\n+!$omp&reduction (.and. : m)\n+    if (omp_get_thread_num () .eq. 0) then\n+      k = omp_get_num_threads ()\n+    end if\n+    call test_do_orphan\n+!$omp do schedule (static) firstprivate (n)\n+    do 200 i = 1, j\n+      if (i .eq. 1 .and. n .ne. 24) call abort\n+      n = i\n+200   d(n) = omp_get_thread_num ()\n+!$omp enddo nowait\n+\n+!$omp do lastprivate (i) schedule (static, 5)\n+    do 201 i = j + 1, 2 * j\n+201   d(i) = omp_get_thread_num () + 1024\n+    ! Implied omp end do here\n+\n+    if (i .ne. 33) m = .false.\n+\n+!$omp do private (j) schedule (dynamic)\n+    do i = 33, 48\n+      d(i) = omp_get_thread_num () + 2048\n+    end do\n+!$omp end do nowait\n+\n+!$omp do schedule (runtime)\n+    do i = 49, 4 * j\n+      d(i) = omp_get_thread_num () + 4096\n+    end do\n+    ! Implied omp end do here\n+!$omp end parallel\n+    if (.not. m) call abort\n+\n+    j = 0\n+    do i = 1, 64\n+      if (d(i) .lt. j .or. d(i) .ge. j + k) call abort\n+      if (i .eq. 16) j = 1024\n+      if (i .eq. 32) j = 2048\n+      if (i .eq. 48) j = 4096\n+    end do\n+  end subroutine test_do\n+\n+  subroutine test_sections\n+    integer :: i, j, k, l, m, n\n+    i = 9\n+    j = 10\n+    k = 11\n+    l = 0\n+    m = 0\n+    n = 30\n+    call omp_set_dynamic (.false.)\n+    call omp_set_num_threads (4)\n+!$omp parallel num_threads (4)\n+!$omp sections private (i) firstprivate (j, k) lastprivate (j) &\n+!$omp& reduction (+ : l, m)\n+!$omp section\n+    i = 24\n+    if (j .ne. 10 .or. k .ne. 11 .or. m .ne. 0) l = 1\n+    m = m + 4\n+!$omp section\n+    i = 25\n+    if (j .ne. 10 .or. k .ne. 11) l = 1\n+    m = m + 6\n+!$omp section\n+    i = 26\n+    if (j .ne. 10 .or. k .ne. 11) l = 1\n+    m = m + 8\n+!$omp section\n+    i = 27\n+    if (j .ne. 10 .or. k .ne. 11) l = 1\n+    m = m + 10\n+    j = 271\n+!$omp end sections nowait\n+!$omp sections lastprivate (n)\n+!$omp section\n+    n = 6\n+!$omp section\n+    n = 7\n+!$omp endsections\n+!$omp end parallel\n+    if (j .ne. 271 .or. l .ne. 0) call abort\n+    if (m .ne. 4 + 6 + 8 + 10) call abort\n+    if (n .ne. 7) call abort\n+  end subroutine test_sections\n+\n+  subroutine test_single\n+    integer :: i, j, k, l\n+    logical :: m\n+    i = 200\n+    j = 300\n+    k = 400\n+    l = 500\n+    m = .false.\n+!$omp parallel num_threads (4), private (i, j), reduction (.or. : m)\n+    i = omp_get_thread_num ()\n+    j = omp_get_thread_num ()\n+!$omp single private (k)\n+    k = 64\n+!$omp end single nowait\n+!$omp single private (k) firstprivate (l)\n+    if (i .ne. omp_get_thread_num () .or. i .ne. j) then\n+      j = -1\n+    else\n+      j = -2\n+    end if\n+    if (l .ne. 500) j = -1\n+    l = 265\n+!$omp end single copyprivate (j)\n+    if (i .ne. omp_get_thread_num () .or. j .ne. -2) m = .true.\n+!$omp endparallel\n+    if (m) call abort\n+  end subroutine test_single\n+end"}, {"sha": "da54a987275601a4eab837fbbef2dd46bdb189e6", "filename": "libgomp/testsuite/libgomp.fortran/omp_parse2.f90", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fomp_parse2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fomp_parse2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fomp_parse2.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,102 @@\n+! { dg-do run }\n+use omp_lib\n+  call test_master\n+  call test_critical\n+  call test_barrier\n+  call test_atomic\n+\n+contains\n+  subroutine test_master\n+    logical :: i, j\n+    i = .false.\n+    j = .false.\n+!$omp parallel num_threads (4)\n+!$omp master\n+    i = .true.\n+    j = omp_get_thread_num () .eq. 0\n+!$omp endmaster\n+!$omp end parallel\n+    if (.not. (i .or. j)) call abort\n+  end subroutine test_master\n+\n+  subroutine test_critical_1 (i, j)\n+    integer :: i, j\n+!$omp critical(critical_foo) \n+    i = i + 1\n+!$omp end critical (critical_foo)\n+!$omp critical\n+    j = j + 1\n+!$omp end critical\n+    end subroutine test_critical_1\n+\n+  subroutine test_critical\n+    integer :: i, j, n\n+    n = -1\n+    i = 0\n+    j = 0\n+!$omp parallel num_threads (4)\n+    if (omp_get_thread_num () .eq. 0) n = omp_get_num_threads ()\n+    call test_critical_1 (i, j)\n+    call test_critical_1 (i, j)\n+!$omp critical\n+    j = j + 1\n+!$omp end critical\n+!$omp critical (critical_foo)\n+    i = i + 1\n+!$omp endcritical (critical_foo)\n+!$omp end parallel\n+    if (n .lt. 1 .or. i .ne. n * 3 .or. j .ne. n * 3) call abort\n+  end subroutine test_critical\n+\n+  subroutine test_barrier\n+    integer :: i\n+    logical :: j\n+    i = 23\n+    j = .false.\n+!$omp parallel num_threads (4)\n+    if (omp_get_thread_num () .eq. 0) i = 5\n+!$omp flush (i)\n+!$omp barrier\n+    if (i .ne. 5) then\n+!$omp atomic\n+      j = j .or. .true.\n+    end if\n+!$omp end parallel\n+    if (i .ne. 5 .or. j) call abort\n+  end subroutine test_barrier\n+\n+  subroutine test_atomic\n+    integer :: a, b, c, d, e, f, g\n+    a = 0\n+    b = 1\n+    c = 0\n+    d = 1024\n+    e = 1024\n+    f = -1\n+    g = -1\n+!$omp parallel num_threads (8)\n+!$omp atomic\n+    a = a + 2 + 4\n+!$omp atomic\n+    b = 3 * b\n+!$omp atomic\n+    c = 8 - c\n+!$omp atomic\n+    d = d / 2\n+!$omp atomic\n+    e = min (e, omp_get_thread_num ())\n+!$omp atomic\n+    f = max (omp_get_thread_num (), f)\n+    if (omp_get_thread_num () .eq. 0) g = omp_get_num_threads ()\n+!$omp end parallel\n+    if (g .le. 0 .or. g .gt. 8) call abort\n+    if (a .ne. 6 * g .or. b .ne. 3 ** g) call abort\n+    if (iand (g, 1) .eq. 1) then\n+      if (c .ne. 8) call abort\n+    else if (c .ne. 0) then\n+      call abort\n+    end if\n+    if (d .ne. 1024 / (2 ** g)) call abort\n+    if (e .ne. 0 .or. f .ne. g - 1) call abort\n+  end subroutine test_atomic\n+end"}, {"sha": "98c94b93b796f87f1af50bad0039b647877edc7f", "filename": "libgomp/testsuite/libgomp.fortran/omp_parse3.f90", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fomp_parse3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fomp_parse3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fomp_parse3.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,95 @@\n+! { dg-do run }\n+! { dg-require-effective-target tls_runtime }\n+use omp_lib\n+  common /tlsblock/ x, y\n+  integer :: x, y, z\n+  save z\n+!$omp threadprivate (/tlsblock/, z)\n+\n+  call test_flush\n+  call test_ordered\n+  call test_threadprivate\n+\n+contains\n+  subroutine test_flush\n+    integer :: i, j\n+    i = 0\n+    j = 0\n+!$omp parallel num_threads (4)\n+    if (omp_get_thread_num () .eq. 0) i = omp_get_num_threads ()\n+    if (omp_get_thread_num () .eq. 0) j = j + 1\n+!$omp flush (i, j)\n+!$omp barrier\n+    if (omp_get_thread_num () .eq. 1) j = j + 2\n+!$omp flush\n+!$omp barrier\n+    if (omp_get_thread_num () .eq. 2) j = j + 3\n+!$omp flush (i)\n+!$omp flush (j)\n+!$omp barrier\n+    if (omp_get_thread_num () .eq. 3) j = j + 4\n+!$omp end parallel\n+  end subroutine test_flush\n+\n+  subroutine test_ordered\n+    integer :: i, j\n+    integer, dimension (100) :: d\n+    d(:) = -1\n+!$omp parallel do ordered schedule (dynamic) num_threads (4)\n+    do i = 1, 100, 5\n+!$omp ordered\n+      d(i) = i\n+!$omp end ordered\n+    end do\n+    j = 1\n+    do 100 i = 1, 100\n+      if (i .eq. j) then\n+\tif (d(i) .ne. i) call abort\n+\tj = i + 5\n+      else\n+\tif (d(i) .ne. -1) call abort\n+      end if\n+100   d(i) = -1\n+  end subroutine test_ordered\n+\n+  subroutine test_threadprivate\n+    common /tlsblock/ x, y\n+!$omp threadprivate (/tlsblock/)\n+    integer :: i, j\n+    logical :: m, n\n+    call omp_set_num_threads (4)\n+    call omp_set_dynamic (.false.)\n+    i = -1\n+    x = 6\n+    y = 7\n+    z = 8\n+    n = .false.\n+    m = .false.\n+!$omp parallel copyin (/tlsblock/, z) reduction (.or.:m) &\n+!$omp& num_threads (4)\n+    if (omp_get_thread_num () .eq. 0) i = omp_get_num_threads ()\n+    if (x .ne. 6 .or. y .ne. 7 .or. z .ne. 8) call abort\n+    x = omp_get_thread_num ()\n+    y = omp_get_thread_num () + 1024\n+    z = omp_get_thread_num () + 4096\n+!$omp end parallel\n+    if (x .ne. 0 .or. y .ne. 1024 .or. z .ne. 4096) call abort\n+!$omp parallel num_threads (4), private (j) reduction (.or.:n)\n+    if (omp_get_num_threads () .eq. i) then\n+      j = omp_get_thread_num ()\n+      if (x .ne. j .or. y .ne. j + 1024 .or. z .ne. j + 4096) &\n+&       call abort\n+    end if\n+!$omp end parallel\n+    m = m .or. n\n+    n = .false.\n+!$omp parallel num_threads (4), copyin (z) reduction (.or. : n)\n+    if (z .ne. 4096) n = .true.\n+    if (omp_get_num_threads () .eq. i) then\n+      j = omp_get_thread_num ()\n+      if (x .ne. j .or. y .ne. j + 1024) call abort\n+    end if\n+!$omp end parallel\n+    if (m .or. n) call abort\n+  end subroutine test_threadprivate\n+end"}, {"sha": "ba35bcb2ad4c1b18abb5ba8d961978d64ba91c83", "filename": "libgomp/testsuite/libgomp.fortran/omp_parse4.f90", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fomp_parse4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fomp_parse4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fomp_parse4.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,72 @@\n+! { dg-do run }\n+!$ use omp_lib\n+  call test_workshare\n+\n+contains\n+  subroutine test_workshare\n+    integer :: i, j, k, l, m\n+    double precision, dimension (64) :: d, e\n+    integer, dimension (10) :: f, g\n+    integer, dimension (16, 16) :: a, b, c\n+    integer, dimension (16) :: n\n+    d(:) = 1\n+    e = 7\n+    f = 10\n+    l = 256\n+    m = 512\n+    g(1:3) = -1\n+    g(4:6) = 0\n+    g(7:8) = 5\n+    g(9:10) = 10\n+    forall (i = 1:16, j = 1:16) a (i, j) = i * 16 + j\n+    forall (j = 1:16) n (j) = j\n+!$omp parallel num_threads (4) private (j, k)\n+!$omp barrier\n+!$omp workshare\n+    i = 6\n+    e(:) = d(:)\n+    where (g .lt. 0)\n+      f = 100\n+    elsewhere (g .eq. 0)\n+      f = 200 + f\n+    elsewhere\n+      where (g .gt. 6) f = f + sum (g)\n+      f = 300 + f\n+    end where\n+    where (f .gt. 210) g = 0\n+!$omp end workshare nowait\n+!$omp workshare\n+    forall (j = 1:16, k = 1:16) b (k, j) = a (j, k)\n+    forall (k = 1:16) c (k, 1:16) = a (1:16, k)\n+    forall (j = 2:16, n (17 - j) / 4 * 4 .ne. n (17 - j))\n+      n (j) = n (j - 1) * n (j)\n+    end forall\n+!$omp endworkshare\n+!$omp workshare\n+!$omp atomic\n+    i = i + 8 + 6\n+!$omp critical\n+!$omp critical (critical_foox)\n+    l = 128\n+!$omp end critical (critical_foox)\n+!$omp endcritical\n+!$omp parallel num_threads (2)\n+!$  if (omp_get_thread_num () .eq. 0) m = omp_get_num_threads ()\n+!$omp atomic\n+    l = 1 + l\n+!$omp end parallel\n+!$omp end workshare\n+!$omp end parallel\n+\n+    if (any (f .ne. (/100, 100, 100, 210, 210, 210, 310, 310, 337, 337/))) &\n+&     call abort\n+    if (any (g .ne. (/-1, -1, -1, 0, 0, 0, 0, 0, 0, 0/))) call abort\n+    if (i .ne. 20) call abort\n+!$  if (l .ne. 128 + m) call abort\n+    if (any (d .ne. 1 .or. e .ne. 1)) call abort\n+    if (any (b .ne. transpose (a))) call abort\n+    if (any (c .ne. b)) call abort\n+    if (any (n .ne. (/1, 2, 6, 12, 5, 30, 42, 56, 9, 90, &\n+&                     110, 132, 13, 182, 210, 240/))) call abort\n+  end subroutine test_workshare\n+end"}, {"sha": "0560bd8963d9a307519f915b4f30bc8803beda8c", "filename": "libgomp/testsuite/libgomp.fortran/omp_reduction.f", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fomp_reduction.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fomp_reduction.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fomp_reduction.f?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,33 @@\n+C******************************************************************************\n+C FILE: omp_reduction.f\n+C DESCRIPTION:\n+C   OpenMP Example - Combined Parallel Loop Reduction - Fortran Version\n+C   This example demonstrates a sum reduction within a combined parallel loop\n+C   construct.  Notice that default data element scoping is assumed - there\n+C   are no clauses specifying shared or private variables.  OpenMP will\n+C   automatically make loop index variables private within team threads, and\n+C   global variables shared.\n+C AUTHOR: Blaise Barney  5/99\n+C LAST REVISED:\n+C******************************************************************************\n+\n+      PROGRAM REDUCTION\n+\n+      INTEGER I, N\n+      REAL A(100), B(100), SUM\n+\n+!     Some initializations\n+      N = 100\n+      DO I = 1, N\n+        A(I) = I *1.0\n+        B(I) = A(I)\n+      ENDDO\n+      SUM = 0.0\n+\n+!$OMP PARALLEL DO REDUCTION(+:SUM)\n+      DO I = 1, N\n+        SUM = SUM + (A(I) * B(I))\n+      ENDDO\n+\n+      PRINT *, '   Sum = ', SUM\n+      END"}, {"sha": "8aef69406de186a5f1dc0fbac3817b062c745904", "filename": "libgomp/testsuite/libgomp.fortran/omp_workshare1.f", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fomp_workshare1.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fomp_workshare1.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fomp_workshare1.f?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,48 @@\n+C******************************************************************************\n+C FILE: omp_workshare1.f\n+C DESCRIPTION:\n+C   OpenMP Example - Loop Work-sharing - Fortran Version\n+C   In this example, the iterations of a loop are scheduled dynamically\n+C   across the team of threads.  A thread will perform CHUNK iterations\n+C   at a time before being scheduled for the next CHUNK of work.\n+C AUTHOR: Blaise Barney  5/99\n+C LAST REVISED: 01/09/04\n+C******************************************************************************\n+\n+      PROGRAM WORKSHARE1\n+\n+      INTEGER NTHREADS, TID, OMP_GET_NUM_THREADS,\n+     +  OMP_GET_THREAD_NUM, N, CHUNKSIZE, CHUNK, I\n+      PARAMETER (N=100)\n+      PARAMETER (CHUNKSIZE=10)\n+      REAL A(N), B(N), C(N)\n+\n+!     Some initializations\n+      DO I = 1, N\n+        A(I) = I * 1.0\n+        B(I) = A(I)\n+      ENDDO\n+      CHUNK = CHUNKSIZE\n+\n+!$OMP PARALLEL SHARED(A,B,C,NTHREADS,CHUNK) PRIVATE(I,TID)\n+\n+      TID = OMP_GET_THREAD_NUM()\n+      IF (TID .EQ. 0) THEN\n+        NTHREADS = OMP_GET_NUM_THREADS()\n+        PRINT *, 'Number of threads =', NTHREADS\n+      END IF\n+      PRINT *, 'Thread',TID,' starting...'\n+\n+!$OMP DO SCHEDULE(DYNAMIC,CHUNK)\n+      DO I = 1, N\n+        C(I) = A(I) + B(I)\n+        WRITE(*,100) TID,I,C(I)\n+ 100    FORMAT(' Thread',I2,': C(',I3,')=',F8.2)\n+      ENDDO\n+!$OMP END DO NOWAIT\n+\n+      PRINT *, 'Thread',TID,' done.'\n+\n+!$OMP END PARALLEL\n+\n+      END"}, {"sha": "9e61da91e9be65778ad1b3a81f16da825a2eefa7", "filename": "libgomp/testsuite/libgomp.fortran/omp_workshare2.f", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fomp_workshare2.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fomp_workshare2.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fomp_workshare2.f?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,56 @@\n+C******************************************************************************\n+C FILE: omp_workshare2.f\n+C DESCRIPTION:\n+C   OpenMP Example - Sections Work-sharing - Fortran Version\n+C   In this example, the OpenMP SECTION directive is used to assign\n+C   different array operations to threads that execute a SECTION. Each\n+C   thread receives its own copy of the result array to work with.\n+C AUTHOR: Blaise Barney  5/99\n+C LAST REVISED: 01/09/04\n+C******************************************************************************\n+\n+      PROGRAM WORKSHARE2\n+\n+      INTEGER N, I, NTHREADS, TID, OMP_GET_NUM_THREADS,\n+     +        OMP_GET_THREAD_NUM\n+      PARAMETER (N=50)\n+      REAL A(N), B(N), C(N)\n+\n+!     Some initializations\n+      DO I = 1, N\n+        A(I) = I * 1.0\n+        B(I) = A(I)\n+      ENDDO\n+\n+!$OMP PARALLEL SHARED(A,B,NTHREADS), PRIVATE(C,I,TID)\n+      TID = OMP_GET_THREAD_NUM()\n+      IF (TID .EQ. 0) THEN\n+        NTHREADS = OMP_GET_NUM_THREADS()\n+        PRINT *, 'Number of threads =', NTHREADS\n+      END IF\n+      PRINT *, 'Thread',TID,' starting...'\n+\n+!$OMP SECTIONS\n+\n+!$OMP SECTION\n+      PRINT *, 'Thread',TID,' doing section 1'\n+      DO I = 1, N\n+         C(I) = A(I) + B(I)\n+         WRITE(*,100) TID,I,C(I)\n+ 100     FORMAT(' Thread',I2,': C(',I2,')=',F8.2)\n+      ENDDO\n+\n+!$OMP SECTION\n+      PRINT *, 'Thread',TID,' doing section 2'\n+      DO I = 1+N/2, N\n+         C(I) = A(I) * B(I)\n+         WRITE(*,100) TID,I,C(I)\n+      ENDDO\n+\n+!$OMP END SECTIONS NOWAIT\n+\n+      PRINT *, 'Thread',TID,' done.'\n+\n+!$OMP END PARALLEL\n+\n+      END"}, {"sha": "a868ea4c9b2c64e627744b5fc15f88d5dba5ac2b", "filename": "libgomp/testsuite/libgomp.fortran/pr25162.f", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fpr25162.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fpr25162.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fpr25162.f?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,40 @@\n+C PR fortran/25162\n+C { dg-do run }\n+C { dg-require-effective-target tls_runtime }\n+      PROGRAM PR25162\n+      CALL TEST1\n+      CALL TEST2\n+      END\n+      SUBROUTINE TEST1\n+      DOUBLE PRECISION BPRIM\n+      COMMON /TESTCOM/ BPRIM(100)\n+C$OMP THREADPRIVATE(/TESTCOM/)\n+      INTEGER I\n+      DO I = 1, 100\n+         BPRIM( I ) = DBLE( I )\n+      END DO\n+      RETURN\n+      END\n+      SUBROUTINE TEST2\n+      DOUBLE PRECISION BPRIM\n+      COMMON /TESTCOM/ BPRIM(100)\n+C$OMP THREADPRIVATE(/TESTCOM/)\n+      INTEGER I, IDUM(50)\n+      DO I = 1, 50\n+         IDUM(I) = I\n+      END DO\n+C$OMP PARALLEL COPYIN(/TESTCOM/) NUM_THREADS(4)\n+      CALL TEST3\n+C$OMP END PARALLEL\n+      RETURN\n+      END\n+      SUBROUTINE TEST3\n+      DOUBLE PRECISION BPRIM\n+      COMMON /TESTCOM/ BPRIM(100)\n+C$OMP THREADPRIVATE(/TESTCOM/)\n+      INTEGER K\n+      DO K = 1, 10\n+         IF (K.NE.BPRIM(K)) CALL ABORT\n+      END DO\n+      RETURN\n+      END"}, {"sha": "7fe1a53aa1c1f05311d9ade93bb50feaffcdcc7d", "filename": "libgomp/testsuite/libgomp.fortran/pr25219.f90", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fpr25219.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fpr25219.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fpr25219.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,15 @@\n+! PR fortran/25219\n+\n+  implicit none\n+  save\n+  integer :: i, k\n+  k = 3\n+!$omp parallel\n+!$omp do lastprivate (k)\n+  do i = 1, 100\n+    k = i\n+  end do\n+!$omp end do\n+!$omp end parallel\n+  if (k .ne. 100) call abort\n+end"}, {"sha": "d6ceb081443a8b75ac51566101beb136cc7188a9", "filename": "libgomp/testsuite/libgomp.fortran/reduction1.f90", "status": "added", "additions": 181, "deletions": 0, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Freduction1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Freduction1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Freduction1.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,181 @@\n+! { dg-do run }\n+!$ use omp_lib\n+\n+  integer :: i, ia (6), n, cnt\n+  real :: r, ra (4)\n+  double precision :: d, da (5)\n+  complex :: c, ca (3)\n+  logical :: v\n+\n+  i = 1\n+  ia = 2\n+  r = 3\n+  ra = 4\n+  d = 5.5\n+  da = 6.5\n+  c = cmplx (7.5, 1.5)\n+  ca = cmplx (8.5, -3.0)\n+  v = .false.\n+  cnt = -1\n+\n+!$omp parallel num_threads (3) private (n) reduction (.or.:v) &\n+!$omp & reduction (+:i, ia, r, ra, d, da, c, ca)\n+!$ if (i .ne. 0 .or. any (ia .ne. 0)) v = .true.\n+!$ if (r .ne. 0 .or. any (ra .ne. 0)) v = .true.\n+!$ if (d .ne. 0 .or. any (da .ne. 0)) v = .true.\n+!$ if (c .ne. cmplx (0) .or. any (ca .ne. cmplx (0))) v = .true.\n+  n = omp_get_thread_num ()\n+  if (n .eq. 0) then\n+    cnt = omp_get_num_threads ()\n+    i = 4\n+    ia(3:5) = -2\n+    r = 5\n+    ra(1:2) = 6.5\n+    d = -2.5\n+    da(2:4) = 8.5\n+    c = cmplx (2.5, -3.5)\n+    ca(1) = cmplx (4.5, 5)\n+  else if (n .eq. 1) then\n+    i = 2\n+    ia(4:6) = 5\n+    r = 1\n+    ra(2:4) = -1.5\n+    d = 8.5\n+    da(1:3) = 2.5\n+    c = cmplx (0.5, -3)\n+    ca(2:3) = cmplx (-1, 6)\n+  else\n+    i = 1\n+    ia = 1\n+    r = -1\n+    ra = -1\n+    d = 1\n+    da = -1\n+    c = 1\n+    ca = cmplx (-1, 0)\n+  end if\n+!$omp end parallel\n+  if (v) call abort\n+  if (cnt .eq. 3) then\n+    if (i .ne. 8 .or. any (ia .ne. (/3, 3, 1, 6, 6, 8/))) call abort\n+    if (r .ne. 8 .or. any (ra .ne. (/9.5, 8.0, 1.5, 1.5/))) call abort\n+    if (d .ne. 12.5 .or. any (da .ne. (/8.0, 16.5, 16.5, 14.0, 5.5/))) call abort\n+    if (c .ne. cmplx (11.5, -5)) call abort\n+    if (ca(1) .ne. cmplx (12, 2)) call abort\n+    if (ca(2) .ne. cmplx (6.5, 3) .or. ca(2) .ne. ca(3)) call abort\n+  end if\n+\n+  i = 1\n+  ia = 2\n+  r = 3\n+  ra = 4\n+  d = 5.5\n+  da = 6.5\n+  c = cmplx (7.5, 1.5)\n+  ca = cmplx (8.5, -3.0)\n+  v = .false.\n+  cnt = -1\n+\n+!$omp parallel num_threads (3) private (n) reduction (.or.:v) &\n+!$omp & reduction (-:i, ia, r, ra, d, da, c, ca)\n+!$ if (i .ne. 0 .or. any (ia .ne. 0)) v = .true.\n+!$ if (r .ne. 0 .or. any (ra .ne. 0)) v = .true.\n+!$ if (d .ne. 0 .or. any (da .ne. 0)) v = .true.\n+!$ if (c .ne. cmplx (0) .or. any (ca .ne. cmplx (0))) v = .true.\n+  n = omp_get_thread_num ()\n+  if (n .eq. 0) then\n+    cnt = omp_get_num_threads ()\n+    i = 4\n+    ia(3:5) = -2\n+    r = 5\n+    ra(1:2) = 6.5\n+    d = -2.5\n+    da(2:4) = 8.5\n+    c = cmplx (2.5, -3.5)\n+    ca(1) = cmplx (4.5, 5)\n+  else if (n .eq. 1) then\n+    i = 2\n+    ia(4:6) = 5\n+    r = 1\n+    ra(2:4) = -1.5\n+    d = 8.5\n+    da(1:3) = 2.5\n+    c = cmplx (0.5, -3)\n+    ca(2:3) = cmplx (-1, 6)\n+  else\n+    i = 1\n+    ia = 1\n+    r = -1\n+    ra = -1\n+    d = 1\n+    da = -1\n+    c = 1\n+    ca = cmplx (-1, 0)\n+  end if\n+!$omp end parallel\n+  if (v) call abort\n+  if (cnt .eq. 3) then\n+    if (i .ne. 8 .or. any (ia .ne. (/3, 3, 1, 6, 6, 8/))) call abort\n+    if (r .ne. 8 .or. any (ra .ne. (/9.5, 8.0, 1.5, 1.5/))) call abort\n+    if (d .ne. 12.5 .or. any (da .ne. (/8.0, 16.5, 16.5, 14.0, 5.5/))) call abort\n+    if (c .ne. cmplx (11.5, -5)) call abort\n+    if (ca(1) .ne. cmplx (12, 2)) call abort\n+    if (ca(2) .ne. cmplx (6.5, 3) .or. ca(2) .ne. ca(3)) call abort\n+  end if\n+\n+  i = 1\n+  ia = 2\n+  r = 4\n+  ra = 8\n+  d = 16\n+  da = 32\n+  c = 2\n+  ca = cmplx (0, 2)\n+  v = .false.\n+  cnt = -1\n+\n+!$omp parallel num_threads (3) private (n) reduction (.or.:v) &\n+!$omp & reduction (*:i, ia, r, ra, d, da, c, ca)\n+!$ if (i .ne. 1 .or. any (ia .ne. 1)) v = .true.\n+!$ if (r .ne. 1 .or. any (ra .ne. 1)) v = .true.\n+!$ if (d .ne. 1 .or. any (da .ne. 1)) v = .true.\n+!$ if (c .ne. cmplx (1) .or. any (ca .ne. cmplx (1))) v = .true.\n+  n = omp_get_thread_num ()\n+  if (n .eq. 0) then\n+    cnt = omp_get_num_threads ()\n+    i = 3\n+    ia(3:5) = 2\n+    r = 0.5\n+    ra(1:2) = 2\n+    d = -1\n+    da(2:4) = -2\n+    c = 2.5\n+    ca(1) = cmplx (-5, 0)\n+  else if (n .eq. 1) then\n+    i = 2\n+    ia(4:6) = -2\n+    r = 8\n+    ra(2:4) = -0.5\n+    da(1:3) = -1\n+    c = -3\n+    ca(2:3) = cmplx (0, -1)\n+  else\n+    ia = 2\n+    r = 0.5\n+    ra = 0.25\n+    d = 2.5\n+    da = -1\n+    c = cmplx (0, -1)\n+    ca = cmplx (-1, 0)\n+  end if\n+!$omp end parallel\n+  if (v) call abort\n+  if (cnt .eq. 3) then\n+    if (i .ne. 6 .or. any (ia .ne. (/4, 4, 8, -16, -16, -8/))) call abort\n+    if (r .ne. 8 .or. any (ra .ne. (/4., -2., -1., -1./))) call abort\n+    if (d .ne. -40 .or. any (da .ne. (/32., -64., -64., 64., -32./))) call abort\n+    if (c .ne. cmplx (0, 15)) call abort\n+    if (ca(1) .ne. cmplx (0, 10)) call abort\n+    if (ca(2) .ne. cmplx (-2, 0) .or. ca(2) .ne. ca(3)) call abort\n+  end if\n+end"}, {"sha": "9bdeb77de857474d1acf172cf567ca47bd205fb0", "filename": "libgomp/testsuite/libgomp.fortran/reduction2.f90", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Freduction2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Freduction2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Freduction2.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,73 @@\n+! { dg-do run }\n+!$ use omp_lib\n+\n+  logical :: l, la (4), m, ma (4), v\n+  integer :: n, cnt\n+\n+  l = .true.\n+  la = (/.true., .false., .true., .true./)\n+  m = .false.\n+  ma = (/.false., .false., .false., .true./)\n+  v = .false.\n+  cnt = -1\n+\n+!$omp parallel num_threads (3) private (n) reduction (.or.:v) &\n+!$omp & reduction (.and.:l, la) reduction (.or.:m, ma)\n+!$ if (.not. l .or. any (.not. la)) v = .true.\n+!$ if (m .or. any (ma)) v = .true.\n+  n = omp_get_thread_num ()\n+  if (n .eq. 0) then\n+    cnt = omp_get_num_threads ()\n+    l = .false.\n+    la(3) = .false.\n+    ma(2) = .true.\n+  else if (n .eq. 1) then\n+    l = .false.\n+    la(4) = .false.\n+    ma(1) = .true.\n+  else\n+    la(3) = .false.\n+    m = .true.\n+    ma(1) = .true.\n+  end if\n+!$omp end parallel\n+  if (v) call abort\n+  if (cnt .eq. 3) then\n+    if (l .or. any (la .neqv. (/.true., .false., .false., .false./))) call abort\n+    if (.not. m .or. any (ma .neqv. (/.true., .true., .false., .true./))) call abort\n+  end if\n+\n+  l = .true.\n+  la = (/.true., .false., .true., .true./)\n+  m = .false.\n+  ma = (/.false., .false., .false., .true./)\n+  v = .false.\n+  cnt = -1\n+\n+!$omp parallel num_threads (3) private (n) reduction (.or.:v) &\n+!$omp & reduction (.eqv.:l, la) reduction (.neqv.:m, ma)\n+!$ if (.not. l .or. any (.not. la)) v = .true.\n+!$ if (m .or. any (ma)) v = .true.\n+  n = omp_get_thread_num ()\n+  if (n .eq. 0) then\n+    cnt = omp_get_num_threads ()\n+    l = .false.\n+    la(3) = .false.\n+    ma(2) = .true.\n+  else if (n .eq. 1) then\n+    l = .false.\n+    la(4) = .false.\n+    ma(1) = .true.\n+  else\n+    la(3) = .false.\n+    m = .true.\n+    ma(1) = .true.\n+  end if\n+!$omp end parallel\n+  if (v) call abort\n+  if (cnt .eq. 3) then\n+    if (.not. l .or. any (la .neqv. (/.true., .false., .true., .false./))) call abort\n+    if (.not. m .or. any (ma .neqv. (/.false., .true., .false., .true./))) call abort\n+  end if\n+\n+end"}, {"sha": "a0786eca00835e41d1db5d734cbea105d3756a40", "filename": "libgomp/testsuite/libgomp.fortran/reduction3.f90", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Freduction3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Freduction3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Freduction3.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,103 @@\n+! { dg-do run }\n+!$ use omp_lib\n+\n+  integer (kind = 4) :: i, ia (6), n, cnt\n+  real :: r, ra (4)\n+  double precision :: d, da (5)\n+  logical :: v\n+\n+  i = 1\n+  ia = 2\n+  r = 3\n+  ra = 4\n+  d = 5.5\n+  da = 6.5\n+  v = .false.\n+  cnt = -1\n+\n+!$omp parallel num_threads (3) private (n) reduction (.or.:v) &\n+!$omp & reduction (max:i, ia, r, ra, d, da)\n+!$ if (i .ne. -2147483648 .or. any (ia .ne. -2147483648)) v = .true.\n+!$ if (r .ge. -1.0d38 .or. any (ra .ge. -1.0d38)) v = .true.\n+!$ if (d .ge. -1.0d300 .or. any (da .ge. -1.0d300)) v = .true.\n+  n = omp_get_thread_num ()\n+  if (n .eq. 0) then\n+    cnt = omp_get_num_threads ()\n+    i = 4\n+    ia(3:5) = -2\n+    ia(1) = 7\n+    r = 5\n+    ra(1:2) = 6.5\n+    d = -2.5\n+    da(2:4) = 8.5\n+  else if (n .eq. 1) then\n+    i = 2\n+    ia(4:6) = 5\n+    r = 1\n+    ra(2:4) = -1.5\n+    d = 8.5\n+    da(1:3) = 2.5\n+  else\n+    i = 1\n+    ia = 1\n+    r = -1\n+    ra = -1\n+    d = 1\n+    da = -1\n+  end if\n+!$omp end parallel\n+  if (v) call abort\n+  if (cnt .eq. 3) then\n+    if (i .ne. 4 .or. any (ia .ne. (/7, 2, 2, 5, 5, 5/))) call abort\n+    if (r .ne. 5 .or. any (ra .ne. (/6.5, 6.5, 4., 4./))) call abort\n+    if (d .ne. 8.5 .or. any (da .ne. (/6.5, 8.5, 8.5, 8.5, 6.5/))) call abort\n+  end if\n+\n+  i = 1\n+  ia = 2\n+  r = 3\n+  ra = 4\n+  d = 5.5\n+  da = 6.5\n+  v = .false.\n+  cnt = -1\n+\n+!$omp parallel num_threads (3) private (n) reduction (.or.:v) &\n+!$omp & reduction (min:i, ia, r, ra, d, da)\n+!$ if (i .ne. 2147483647 .or. any (ia .ne. 2147483647)) v = .true.\n+!$ if (r .le. 1.0d38 .or. any (ra .le. 1.0d38)) v = .true.\n+!$ if (d .le. 1.0d300 .or. any (da .le. 1.0d300)) v = .true.\n+  n = omp_get_thread_num ()\n+  if (n .eq. 0) then\n+    cnt = omp_get_num_threads ()\n+    i = 4\n+    ia(3:5) = -2\n+    ia(1) = 7\n+    r = 5\n+    ra(1:2) = 6.5\n+    d = -2.5\n+    da(2:4) = 8.5\n+  else if (n .eq. 1) then\n+    i = 2\n+    ia(4:6) = 5\n+    r = 1\n+    ra(2:4) = -1.5\n+    d = 8.5\n+    da(1:3) = 2.5\n+  else\n+    i = 1\n+    ia = 1\n+    r = -1\n+    ra = 7\n+    ra(3) = -8.5\n+    d = 1\n+    da(1:4) = 6\n+  end if\n+!$omp end parallel\n+  if (v) call abort\n+  if (cnt .eq. 3) then\n+    if (i .ne. 1 .or. any (ia .ne. (/1, 1, -2, -2, -2, 1/))) call abort\n+    if (r .ne. -1 .or. any (ra .ne. (/4., -1.5, -8.5, -1.5/))) call abort\n+    if (d .ne. -2.5 .or. any (da .ne. (/2.5, 2.5, 2.5, 6., 6.5/))) call abort\n+  end if\n+end"}, {"sha": "5a5e852bea7905c14e619a2e90fc4b3a75a8d6e2", "filename": "libgomp/testsuite/libgomp.fortran/reduction4.f90", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Freduction4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Freduction4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Freduction4.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,56 @@\n+! { dg-do run }\n+!$ use omp_lib\n+\n+  integer (kind = 4) :: i, ia (6), j, ja (6), k, ka (6), ta (6), n, cnt, x\n+  logical :: v\n+\n+  i = Z'ffff0f'\n+  ia = Z'f0ff0f'\n+  j = Z'0f0000'\n+  ja = Z'0f5a00'\n+  k = Z'055aa0'\n+  ka = Z'05a5a5'\n+  v = .false.\n+  cnt = -1\n+  x = Z'ffffffff'\n+\n+!$omp parallel num_threads (3) private (n) reduction (.or.:v) &\n+!$omp & reduction (iand:i, ia) reduction (ior:j, ja) reduction (ieor:k, ka)\n+!$ if (i .ne. x .or. any (ia .ne. x)) v = .true.\n+!$ if (j .ne. 0 .or. any (ja .ne. 0)) v = .true.\n+!$ if (k .ne. 0 .or. any (ka .ne. 0)) v = .true.\n+  n = omp_get_thread_num ()\n+  if (n .eq. 0) then\n+    cnt = omp_get_num_threads ()\n+    i = Z'ff7fff'\n+    ia(3:5) = Z'fffff1'\n+    j = Z'078000'\n+    ja(1:3) = 1\n+    k = Z'78'\n+    ka(3:6) = Z'f0f'\n+  else if (n .eq. 1) then\n+    i = Z'ffff77'\n+    ia(2:5) = Z'ffafff'\n+    j = Z'007800'\n+    ja(2:5) = 8\n+    k = Z'57'\n+    ka(3:4) = Z'f0108'\n+  else\n+    i = Z'777fff'\n+    ia(1:2) = Z'fffff3'\n+    j = Z'000780'\n+    ja(5:6) = Z'f00'\n+    k = Z'1000'\n+    ka(6:6) = Z'777'\n+  end if\n+!$omp end parallel\n+  if (v) call abort\n+  if (cnt .eq. 3) then\n+    ta = (/Z'f0ff03', Z'f0af03', Z'f0af01', Z'f0af01', Z'f0af01', Z'f0ff0f'/)\n+    if (i .ne. Z'777f07' .or. any (ia .ne. ta)) call abort\n+    ta = (/Z'f5a01', Z'f5a09', Z'f5a09', Z'f5a08', Z'f5f08', Z'f5f00'/)\n+    if (j .ne. Z'fff80' .or. any (ja .ne. ta)) call abort\n+    ta = (/Z'5a5a5', Z'5a5a5', Z'aaba2', Z'aaba2', Z'5aaaa', Z'5addd'/)\n+    if (k .ne. Z'54a8f' .or. any (ka .ne. ta)) call abort\n+  end if\n+end"}, {"sha": "bfdd43a93fa332e46456dab2a5f38bb83a3654a4", "filename": "libgomp/testsuite/libgomp.fortran/reduction5.f90", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Freduction5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Freduction5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Freduction5.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,41 @@\n+! { dg-do run }\n+\n+module reduction5\n+  intrinsic ior, min, max\n+end module reduction5\n+\n+  call test1\n+  call test2\n+contains\n+  subroutine test1\n+    use reduction5, bitwise_or => ior\n+    integer :: n\n+    n = Z'f'\n+!$omp parallel sections num_threads (3) reduction (bitwise_or: n)\n+    n = ior (n, Z'20')\n+!$omp section\n+    n = bitwise_or (Z'410', n)\n+!$omp section\n+    n = bitwise_or (n, Z'2000')\n+!$omp end parallel sections\n+    if (n .ne. Z'243f') call abort\n+  end subroutine\n+  subroutine test2\n+    use reduction5, min => max, max => min\n+    integer :: m, n\n+    m = 8\n+    n = 4\n+!$omp parallel sections num_threads (3) reduction (min: n) &\n+!$omp & reduction (max: m)\n+    if (m .gt. 13) m = 13\n+    if (n .lt. 11) n = 11\n+!$omp section\n+    if (m .gt. 5) m = 5\n+    if (n .lt. 15) n = 15\n+!$omp section\n+    if (m .gt. 3) m = 3\n+    if (n .lt. -1) n = -1\n+!$omp end parallel sections\n+    if (m .ne. 3 .or. n .ne. 15) call abort\n+  end subroutine test2\n+end"}, {"sha": "9f3ec6ca8935cd816901c4c751656417b2862392", "filename": "libgomp/testsuite/libgomp.fortran/reduction6.f90", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Freduction6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Freduction6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Freduction6.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,32 @@\n+! { dg-do run }\n+\n+  integer, dimension (6, 6) :: a\n+  character (36) :: c\n+  integer nthreads\n+  a = 9\n+  nthreads = -1\n+  call foo (a (2:4, 3:5), nthreads)\n+  if (nthreads .eq. 3) then\n+    write (c, '(36i1)') a\n+    if (c .ne. '999999999999966699966699966699999999') call abort\n+  end if\n+contains\n+  subroutine foo (b, nthreads)\n+    use omp_lib\n+    integer, dimension (3:, 5:) :: b\n+    integer :: err, nthreads\n+    b = 0\n+    err = 0\n+!$omp parallel num_threads (3) reduction (+:b)\n+    if (any (b .ne. 0)) then\n+!$omp atomic\n+      err = err + 1\n+    end if\n+!$omp master\n+    nthreads = omp_get_num_threads ()\n+!$omp end master\n+    b = 2\n+!$omp end parallel\n+    if (err .gt. 0) call abort\n+  end subroutine foo\n+end"}, {"sha": "b959e2716b89f42b6f69511f3551f4b6b6c1ab29", "filename": "libgomp/testsuite/libgomp.fortran/reference1.f90", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Freference1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Freference1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Freference1.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,34 @@\n+! { dg-do run }\n+!$ use omp_lib\n+\n+  integer :: i, j, k\n+  double precision :: d\n+  i = 6\n+  j = 19\n+  k = 0\n+  d = 24.5\n+  call test (i, j, k, d)\n+  if (i .ne. 38) call abort\n+  if (iand (k, 255) .ne. 0) call abort\n+  if (iand (k, 65280) .eq. 0) then\n+    if (k .ne. 65536 * 4) call abort\n+  end if\n+contains\n+  subroutine test (i, j, k, d)\n+    integer :: i, j, k\n+    double precision :: d\n+\n+!$omp parallel firstprivate (d) private (j) num_threads (4) reduction (+:k)\n+    if (i .ne. 6 .or. d .ne. 24.5 .or. k .ne. 0) k = k + 1\n+    if (omp_get_num_threads () .ne. 4) k = k + 256\n+    d = d / 2\n+    j = 8\n+    k = k + 65536\n+!$omp barrier\n+    if (d .ne. 12.25 .or. j .ne. 8) k = k + 1\n+!$omp single\n+    i = i + 32\n+!$omp end single nowait\n+!$omp end parallel\n+  end subroutine test\n+end"}, {"sha": "1232b6926cb368b2afd37b5cba6c84b6389051a1", "filename": "libgomp/testsuite/libgomp.fortran/reference2.f90", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Freference2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Freference2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Freference2.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,21 @@\n+! { dg-do run }\n+  real, dimension (5) :: b\n+  b = 5\n+  call foo (b)\n+contains\n+  subroutine foo (a)\n+    real, dimension (5) :: a\n+    logical :: l\n+    l = .false.\n+!$omp parallel private (a) reduction (.or.:l)\n+    a = 15\n+    l = bar (a)\n+!$omp end parallel\n+    if (l) call abort\n+  end subroutine\n+  function bar (a)\n+    real, dimension (5) :: a\n+    logical :: bar\n+    bar = any (a .ne. 15)\n+  end function\n+end"}, {"sha": "8bb07f8fce6f60d97ec7520f539fb59e8971e5bb", "filename": "libgomp/testsuite/libgomp.fortran/retval1.f90", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fretval1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fretval1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fretval1.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,120 @@\n+! { dg-do run }\n+\n+function f1 ()\n+  use omp_lib\n+  real :: f1\n+  logical :: l\n+  f1 = 6.5\n+  l = .false.\n+!$omp parallel firstprivate (f1) num_threads (2) reduction (.or.:l)\n+  l = f1 .ne. 6.5\n+  if (omp_get_thread_num () .eq. 0) f1 = 8.5\n+  if (omp_get_thread_num () .eq. 1) f1 = 14.5\n+!$omp barrier\n+  l = l .or. (omp_get_thread_num () .eq. 0 .and. f1 .ne. 8.5)\n+  l = l .or. (omp_get_thread_num () .eq. 1 .and. f1 .ne. 14.5)\n+!$omp end parallel\n+  if (l) call abort\n+  f1 = -2.5\n+end function f1\n+function f2 ()\n+  use omp_lib\n+  real :: f2, e2\n+  logical :: l\n+entry e2 ()\n+  f2 = 6.5\n+  l = .false.\n+!$omp parallel firstprivate (e2) num_threads (2) reduction (.or.:l)\n+  l = e2 .ne. 6.5\n+  if (omp_get_thread_num () .eq. 0) e2 = 8.5\n+  if (omp_get_thread_num () .eq. 1) e2 = 14.5\n+!$omp barrier\n+  l = l .or. (omp_get_thread_num () .eq. 0 .and. e2 .ne. 8.5)\n+  l = l .or. (omp_get_thread_num () .eq. 1 .and. e2 .ne. 14.5)\n+!$omp end parallel\n+  if (l) call abort\n+  e2 = 7.5\n+end function f2\n+function f3 ()\n+  use omp_lib\n+  real :: f3, e3\n+  logical :: l\n+entry e3 ()\n+  f3 = 6.5\n+  l = .false.\n+!$omp parallel firstprivate (f3, e3) num_threads (2) reduction (.or.:l)\n+  l = e3 .ne. 6.5\n+  l = l .or. f3 .ne. 6.5\n+  if (omp_get_thread_num () .eq. 0) e3 = 8.5\n+  if (omp_get_thread_num () .eq. 1) e3 = 14.5\n+  f3 = e3 - 4.5\n+!$omp barrier\n+  l = l .or. (omp_get_thread_num () .eq. 0 .and. e3 .ne. 8.5)\n+  l = l .or. (omp_get_thread_num () .eq. 1 .and. e3 .ne. 14.5)\n+  l = l .or. f3 .ne. e3 - 4.5\n+!$omp end parallel\n+  if (l) call abort\n+  e3 = 0.5\n+end function f3\n+function f4 () result (r4)\n+  use omp_lib\n+  real :: r4, s4\n+  logical :: l\n+entry e4 () result (s4)\n+  r4 = 6.5\n+  l = .false.\n+!$omp parallel firstprivate (r4, s4) num_threads (2) reduction (.or.:l)\n+  l = s4 .ne. 6.5\n+  l = l .or. r4 .ne. 6.5\n+  if (omp_get_thread_num () .eq. 0) s4 = 8.5\n+  if (omp_get_thread_num () .eq. 1) s4 = 14.5\n+  r4 = s4 - 4.5\n+!$omp barrier\n+  l = l .or. (omp_get_thread_num () .eq. 0 .and. s4 .ne. 8.5)\n+  l = l .or. (omp_get_thread_num () .eq. 1 .and. s4 .ne. 14.5)\n+  l = l .or. r4 .ne. s4 - 4.5\n+!$omp end parallel\n+  if (l) call abort\n+  s4 = -0.5\n+end function f4\n+function f5 (is_f5)\n+  use omp_lib\n+  real :: f5\n+  integer :: e5\n+  logical :: l, is_f5\n+entry e5 (is_f5)\n+  if (is_f5) then\n+    f5 = 6.5\n+  else\n+    e5 = 8\n+  end if\n+  l = .false.\n+!$omp parallel firstprivate (f5, e5) shared (is_f5) num_threads (2) &\n+!$omp reduction (.or.:l)\n+  l = .not. is_f5 .and. e5 .ne. 8\n+  l = l .or. (is_f5 .and. f5 .ne. 6.5)\n+  if (omp_get_thread_num () .eq. 0) e5 = 8\n+  if (omp_get_thread_num () .eq. 1) e5 = 14\n+  f5 = e5 - 4.5\n+!$omp barrier\n+  l = l .or. (omp_get_thread_num () .eq. 0 .and. e5 .ne. 8)\n+  l = l .or. (omp_get_thread_num () .eq. 1 .and. e5 .ne. 14)\n+  l = l .or. f5 .ne. e5 - 4.5\n+!$omp end parallel\n+  if (l) call abort\n+  if (is_f5) f5 = -2.5\n+  if (.not. is_f5) e5 = 8\n+end function f5\n+\n+  real :: f1, f2, e2, f3, e3, f4, e4, f5\n+  integer :: e5\n+  if (f1 () .ne. -2.5) call abort\n+  if (f2 () .ne. 7.5) call abort\n+  if (e2 () .ne. 7.5) call abort\n+  if (f3 () .ne. 0.5) call abort\n+  if (e3 () .ne. 0.5) call abort\n+  if (f4 () .ne. -0.5) call abort\n+  if (e4 () .ne. -0.5) call abort\n+  if (f5 (.true.) .ne. -2.5) call abort\n+  if (e5 (.false.) .ne. 8) call abort\n+end"}, {"sha": "063e7db835783531a6f3d6a7bc8cbbbd70b4208d", "filename": "libgomp/testsuite/libgomp.fortran/sharing1.f90", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fsharing1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fsharing1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fsharing1.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,29 @@\n+! { dg-do run }\n+\n+  use omp_lib\n+  integer :: i, j, k\n+  logical :: l\n+  common /b/ i, j\n+  i = 4\n+  j = 8\n+  l = .false.\n+!$omp parallel private (k) firstprivate (i) shared (j) num_threads (2) &\n+!$omp& reduction (.or.:l)\n+  if (i .ne. 4 .or. j .ne. 8) l = .true.\n+!$omp barrier\n+  k = omp_get_thread_num ()\n+  if (k .eq. 0) then\n+    i = 14\n+    j = 15\n+  end if\n+!$omp barrier\n+  if (k .eq. 1) then\n+    if (i .ne. 4 .or. j .ne. 15) l = .true.\n+    i = 24\n+    j = 25\n+  end if\n+!$omp barrier\n+  if (j .ne. 25 .or. i .ne. (k * 10 + 14)) l = .true.\n+!$omp end parallel\n+  if (l .or. j .ne. 25) call abort\n+end"}, {"sha": "266dd46fadb01fce48266b57248044e05bea55a8", "filename": "libgomp/testsuite/libgomp.fortran/sharing2.f90", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fsharing2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fsharing2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fsharing2.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,32 @@\n+! { dg-do run }\n+\n+  use omp_lib\n+  integer :: i, j, k, m, n\n+  logical :: l\n+  equivalence (i, m)\n+  equivalence (j, n)\n+  i = 4\n+  j = 8\n+  l = .false.\n+!$omp parallel private (k) firstprivate (i) shared (j) num_threads (2) &\n+!$omp& reduction (.or.:l)\n+  l = l .or. i .ne. 4\n+  l = l .or. j .ne. 8\n+!$omp barrier\n+  k = omp_get_thread_num ()\n+  if (k .eq. 0) then\n+    i = 14\n+    j = 15\n+  end if\n+!$omp barrier\n+  if (k .eq. 1) then\n+    if (i .ne. 4 .or. j .ne. 15) l = .true.\n+    i = 24\n+    j = 25\n+  end if\n+!$omp barrier\n+  if (j .ne. 25 .or. i .ne. (k * 10 + 14)) l = .true.\n+!$omp end parallel\n+  if (l) call abort\n+  if (j .ne. 25) call abort\n+end"}, {"sha": "99a20185509b97ea7696be02092f3548f2a3ec1e", "filename": "libgomp/testsuite/libgomp.fortran/threadprivate1.f90", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fthreadprivate1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fthreadprivate1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fthreadprivate1.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,19 @@\n+! { dg-do run }\n+! { dg-require-effective-target tls_runtime }\n+\n+module threadprivate1\n+  double precision :: d\n+!$omp threadprivate (d)\n+end module threadprivate1\n+\n+!$ use omp_lib\n+  use threadprivate1\n+  logical :: l\n+  l = .false.\n+!$omp parallel num_threads (4) reduction (.or.:l)\n+  d = omp_get_thread_num () + 6.5\n+!$omp barrier\n+  if (d .ne. omp_get_thread_num () + 6.5) l = .true.\n+!$omp end parallel\n+  if (l) call abort ()\n+end"}, {"sha": "f3a4af0fc132ca45c19a444bddcd3f63b3c59ead", "filename": "libgomp/testsuite/libgomp.fortran/threadprivate2.f90", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fthreadprivate2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fthreadprivate2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fthreadprivate2.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,94 @@\n+! { dg-do run }\n+! { dg-require-effective-target tls_runtime }\n+\n+module threadprivate2\n+  integer, dimension(:,:), allocatable :: foo\n+!$omp threadprivate (foo)\n+end module threadprivate2\n+\n+  use omp_lib\n+  use threadprivate2\n+\n+  integer, dimension(:), pointer :: bar1\n+  integer, dimension(2), target :: bar2\n+  common /thrc/ bar1, bar2\n+!$omp threadprivate (/thrc/)\n+\n+  integer, dimension(:), pointer, save :: bar3 => NULL()\n+!$omp threadprivate (bar3)\n+\n+  logical :: l\n+  type tt\n+    integer :: a\n+    integer :: b = 32\n+  end type tt\n+  type (tt), save :: baz\n+!$omp threadprivate (baz)\n+\n+  l = .false.\n+  call omp_set_dynamic (.false.)\n+  call omp_set_num_threads (4)\n+\n+!$omp parallel num_threads (4) reduction (.or.:l)\n+  l = allocated (foo)\n+  allocate (foo (6 + omp_get_thread_num (), 3))\n+  l = l.or..not.allocated (foo)\n+  l = l.or.size (foo).ne.(18 + 3 * omp_get_thread_num ())\n+  foo = omp_get_thread_num () + 1\n+\n+  bar2 = omp_get_thread_num ()\n+  l = l.or.associated (bar3)\n+  bar1 => bar2\n+  l = l.or..not.associated (bar1)\n+  l = l.or..not.associated (bar1, bar2)\n+  l = l.or.any (bar1.ne.omp_get_thread_num ())\n+  nullify (bar1)\n+  l = l.or.associated (bar1)\n+  allocate (bar3 (4))\n+  l = l.or..not.associated (bar3)\n+  bar3 = omp_get_thread_num () - 2\n+\n+  l = l.or.(baz%b.ne.32)\n+  baz%a = omp_get_thread_num () * 2\n+  baz%b = omp_get_thread_num () * 2 + 1\n+!$omp end parallel\n+\n+  if (l) call abort\n+  if (.not.allocated (foo)) call abort\n+  if (size (foo).ne.18) call abort\n+  if (any (foo.ne.1)) call abort\n+\n+  if (associated (bar1)) call abort\n+  if (.not.associated (bar3)) call abort\n+  if (any (bar3 .ne. -2)) call abort\n+  deallocate (bar3)\n+  if (associated (bar3)) call abort\n+\n+!$omp parallel num_threads (4) reduction (.or.:l)\n+  l = l.or..not.allocated (foo)\n+  l = l.or.size (foo).ne.(18 + 3 * omp_get_thread_num ())\n+  l = l.or.any (foo.ne.(omp_get_thread_num () + 1))\n+  if (omp_get_thread_num () .ne. 0) then\n+    deallocate (foo)\n+    l = l.or.allocated (foo)\n+  end if\n+\n+  l = l.or.associated (bar1)\n+  if (omp_get_thread_num () .ne. 0) then\n+    l = l.or..not.associated (bar3)\n+    l = l.or.any (bar3 .ne. omp_get_thread_num () - 2)\n+    deallocate (bar3)\n+  end if\n+  l = l.or.associated (bar3)\n+\n+  l = l.or.(baz%a.ne.(omp_get_thread_num () * 2))\n+  l = l.or.(baz%b.ne.(omp_get_thread_num () * 2 + 1))\n+!$omp end parallel\n+\n+  if (l) call abort\n+  if (.not.allocated (foo)) call abort\n+  if (size (foo).ne.18) call abort\n+  if (any (foo.ne.1)) call abort\n+  deallocate (foo)\n+  if (allocated (foo)) call abort\n+end"}, {"sha": "d20a6520a8a3311f5db4fe0f40c8e4d5a14f85e4", "filename": "libgomp/testsuite/libgomp.fortran/threadprivate3.f90", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fthreadprivate3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fthreadprivate3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fthreadprivate3.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,106 @@\n+! { dg-do run }\n+! { dg-require-effective-target tls_runtime }\n+\n+module threadprivate3\n+  integer, dimension(:,:), pointer :: foo => NULL()\n+!$omp threadprivate (foo)\n+end module threadprivate3\n+\n+  use omp_lib\n+  use threadprivate3\n+\n+  integer, dimension(:), pointer :: bar1\n+  integer, dimension(2), target :: bar2, var\n+  common /thrc/ bar1, bar2\n+!$omp threadprivate (/thrc/)\n+\n+  integer, dimension(:), pointer, save :: bar3 => NULL()\n+!$omp threadprivate (bar3)\n+\n+  logical :: l\n+  type tt\n+    integer :: a\n+    integer :: b = 32\n+  end type tt\n+  type (tt), save :: baz\n+!$omp threadprivate (baz)\n+\n+  l = .false.\n+  call omp_set_dynamic (.false.)\n+  call omp_set_num_threads (4)\n+  var = 6\n+\n+!$omp parallel num_threads (4) reduction (.or.:l)\n+  bar2 = omp_get_thread_num ()\n+  l = associated (bar3)\n+  bar1 => bar2\n+  l = l.or..not.associated (bar1)\n+  l = l.or..not.associated (bar1, bar2)\n+  l = l.or.any (bar1.ne.omp_get_thread_num ())\n+  nullify (bar1)\n+  l = l.or.associated (bar1)\n+  allocate (bar3 (4))\n+  l = l.or..not.associated (bar3)\n+  bar3 = omp_get_thread_num () - 2\n+  if (omp_get_thread_num () .ne. 0) then\n+    deallocate (bar3)\n+    if (associated (bar3)) call abort\n+  else\n+    bar1 => var\n+  end if\n+  bar2 = omp_get_thread_num () * 6 + 130\n+\n+  l = l.or.(baz%b.ne.32)\n+  baz%a = omp_get_thread_num () * 2\n+  baz%b = omp_get_thread_num () * 2 + 1\n+!$omp end parallel\n+\n+  if (l) call abort\n+  if (.not.associated (bar1)) call abort\n+  if (any (bar1.ne.6)) call abort\n+  if (.not.associated (bar3)) call abort\n+  if (any (bar3 .ne. -2)) call abort\n+  deallocate (bar3)\n+  if (associated (bar3)) call abort\n+\n+  allocate (bar3 (10))\n+  bar3 = 17\n+\n+!$omp parallel copyin (bar1, bar2, bar3, baz) num_threads (4) &\n+!$omp& reduction (.or.:l)\n+  l = l.or..not.associated (bar1)\n+  l = l.or.any (bar1.ne.6)\n+  l = l.or.any (bar2.ne.130)\n+  l = l.or..not.associated (bar3)\n+  l = l.or.size (bar3).ne.10\n+  l = l.or.any (bar3.ne.17)\n+  allocate (bar1 (4))\n+  bar1 = omp_get_thread_num ()\n+  bar2 = omp_get_thread_num () + 8\n+\n+  l = l.or.(baz%a.ne.0)\n+  l = l.or.(baz%b.ne.1)\n+  baz%a = omp_get_thread_num () * 3 + 4\n+  baz%b = omp_get_thread_num () * 3 + 5\n+\n+!$omp barrier\n+  if (omp_get_thread_num () .eq. 0) then\n+    deallocate (bar3)\n+  end if\n+  bar3 => bar2\n+!$omp barrier\n+\n+  l = l.or..not.associated (bar1)\n+  l = l.or..not.associated (bar3)\n+  l = l.or.any (bar1.ne.omp_get_thread_num ())\n+  l = l.or.size (bar1).ne.4\n+  l = l.or.any (bar2.ne.omp_get_thread_num () + 8)\n+  l = l.or.any (bar3.ne.omp_get_thread_num () + 8)\n+  l = l.or.size (bar3).ne.2\n+\n+  l = l.or.(baz%a .ne. omp_get_thread_num () * 3 + 4)\n+  l = l.or.(baz%b .ne. omp_get_thread_num () * 3 + 5)\n+!$omp end parallel\n+\n+  if (l) call abort\n+end"}, {"sha": "c22165ee0a180128694db89dc1e7c4faf490b45a", "filename": "libgomp/testsuite/libgomp.fortran/vla1.f90", "status": "added", "additions": 185, "deletions": 0, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fvla1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fvla1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fvla1.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,185 @@\n+! { dg-do run }\n+\n+  call test\n+contains\n+  subroutine check (x, y, l)\n+    integer :: x, y\n+    logical :: l\n+    l = l .or. x .ne. y\n+  end subroutine check\n+\n+  subroutine foo (c, d, e, f, g, h, i, j, k, n)\n+    use omp_lib\n+    integer :: n\n+    character (len = *) :: c\n+    character (len = n) :: d\n+    integer, dimension (2, 3:5, n) :: e\n+    integer, dimension (2, 3:n, n) :: f\n+    character (len = *), dimension (5, 3:n) :: g\n+    character (len = n), dimension (5, 3:n) :: h\n+    real, dimension (:, :, :) :: i\n+    double precision, dimension (3:, 5:, 7:) :: j\n+    integer, dimension (:, :, :) :: k\n+    logical :: l\n+    integer :: p, q, r\n+    character (len = n) :: s\n+    integer, dimension (2, 3:5, n) :: t\n+    integer, dimension (2, 3:n, n) :: u\n+    character (len = n), dimension (5, 3:n) :: v\n+    character (len = 2 * n + 24) :: w\n+    integer :: x\n+    character (len = 1) :: y\n+    s = 'PQRSTUV'\n+    forall (p = 1:2, q = 3:5, r = 1:7) t(p, q, r) = -10 + p - q + 2 * r\n+    forall (p = 1:2, q = 3:7, r = 1:7) u(p, q, r) = 30 - p + q - 2 * r\n+    forall (p = 1:5, q = 3:7, p + q .le. 8) v(p, q) = '_+|/Oo_'\n+    forall (p = 1:5, q = 3:7, p + q .gt. 8) v(p, q) = '///|||!'\n+    l = .false.\n+!$omp parallel default (none) firstprivate (c, d, e, f, g, h, i, j, k) &\n+!$omp & firstprivate (s, t, u, v) reduction (.or.:l) num_threads (6) &\n+!$omp private (p, q, r, w, x, y)\n+    l = l .or. c .ne. 'abcdefghijkl'\n+    l = l .or. d .ne. 'ABCDEFG'\n+    l = l .or. s .ne. 'PQRSTUV'\n+    do 100, p = 1, 2\n+      do 100, q = 3, 7\n+\tdo 100, r = 1, 7\n+\t  if (q .lt. 6) l = l .or. e(p, q, r) .ne. 5 + p + q + 2 * r\n+\t  l = l .or. f(p, q, r) .ne. 25 + p + q + 2 * r\n+\t  if (r .lt. 6 .and. q + r .le. 8) l = l .or. g(r, q) .ne. '0123456789AB'\n+\t  if (r .lt. 6 .and. q + r .gt. 8) l = l .or. g(r, q) .ne. '9876543210ZY'\n+\t  if (r .lt. 6 .and. q + r .le. 8) l = l .or. h(r, q) .ne. '0123456'\n+\t  if (r .lt. 6 .and. q + r .gt. 8) l = l .or. h(r, q) .ne. '9876543'\n+\t  if (q .lt. 6) l = l .or. t(p, q, r) .ne. -10 + p - q + 2 * r\n+\t  l = l .or. u(p, q, r) .ne. 30 - p + q - 2 * r\n+\t  if (r .lt. 6 .and. q + r .le. 8) l = l .or. v(r, q) .ne. '_+|/Oo_'\n+\t  if (r .lt. 6 .and. q + r .gt. 8) l = l .or. v(r, q) .ne. '///|||!'\n+100 continue\n+    do 101, p = 3, 5\n+      do 101, q = 2, 6\n+\tdo 101, r = 1, 7\n+\t  l = l .or. i(p - 2, q - 1, r) .ne. 7.5 * p * q * r\n+\t  l = l .or. j(p, q + 3, r + 6) .ne. 9.5 * p * q * r\n+101 continue\n+    do 102, p = 1, 5\n+      do 102, q = 4, 6\n+\tl = l .or. k(p, 1, q - 3) .ne. 19 + p + 7 + 3 * q\n+102 continue\n+    x = omp_get_thread_num ()\n+    w = ''\n+    if (x .eq. 0) w = 'thread0thr_number_0THREAD0THR_NUMBER_0'\n+    if (x .eq. 1) w = 'thread1thr_number_1THREAD1THR_NUMBER_1'\n+    if (x .eq. 2) w = 'thread2thr_number_2THREAD2THR_NUMBER_2'\n+    if (x .eq. 3) w = 'thread3thr_number_3THREAD3THR_NUMBER_3'\n+    if (x .eq. 4) w = 'thread4thr_number_4THREAD4THR_NUMBER_4'\n+    if (x .eq. 5) w = 'thread5thr_number_5THREAD5THR_NUMBER_5'\n+    c = w(8:19)\n+    d = w(1:7)\n+    forall (p = 1:2, q = 3:5, r = 1:7) e(p, q, r) = 5 * x + p + q + 2 * r\n+    forall (p = 1:2, q = 3:7, r = 1:7) f(p, q, r) = 25 * x + p + q + 2 * r\n+    forall (p = 1:5, q = 3:7, p + q .le. 8) g(p, q) = w(8:19)\n+    forall (p = 1:5, q = 3:7, p + q .gt. 8) g(p, q) = w(27:38)\n+    forall (p = 1:5, q = 3:7, p + q .le. 8) h(p, q) = w(1:7)\n+    forall (p = 1:5, q = 3:7, p + q .gt. 8) h(p, q) = w(20:26)\n+    forall (p = 3:5, q = 2:6, r = 1:7) i(p - 2, q - 1, r) = (7.5 + x) * p * q * r\n+    forall (p = 3:5, q = 2:6, r = 1:7) j(p, q + 3, r + 6) = (9.5 + x) * p * q * r\n+    forall (p = 1:5, q = 7:7, r = 4:6) k(p, q - 6, r - 3) = 19 + x + p + q + 3 * r\n+    s = w(20:26)\n+    forall (p = 1:2, q = 3:5, r = 1:7) t(p, q, r) = -10 + x + p - q + 2 * r\n+    forall (p = 1:2, q = 3:7, r = 1:7) u(p, q, r) = 30 - x - p + q - 2 * r\n+    forall (p = 1:5, q = 3:7, p + q .le. 8) v(p, q) = w(1:7)\n+    forall (p = 1:5, q = 3:7, p + q .gt. 8) v(p, q) = w(20:26)\n+!$omp barrier\n+    y = ''\n+    if (x .eq. 0) y = '0'\n+    if (x .eq. 1) y = '1'\n+    if (x .eq. 2) y = '2'\n+    if (x .eq. 3) y = '3'\n+    if (x .eq. 4) y = '4'\n+    if (x .eq. 5) y = '5'\n+    l = l .or. w(7:7) .ne. y\n+    l = l .or. w(19:19) .ne. y\n+    l = l .or. w(26:26) .ne. y\n+    l = l .or. w(38:38) .ne. y\n+    l = l .or. c .ne. w(8:19)\n+    l = l .or. d .ne. w(1:7)\n+    l = l .or. s .ne. w(20:26)\n+    do 103, p = 1, 2\n+      do 103, q = 3, 7\n+\tdo 103, r = 1, 7\n+\t  if (q .lt. 6) l = l .or. e(p, q, r) .ne. 5 * x + p + q + 2 * r\n+\t  l = l .or. f(p, q, r) .ne. 25 * x + p + q + 2 * r\n+\t  if (r .lt. 6 .and. q + r .le. 8) l = l .or. g(r, q) .ne. w(8:19)\n+\t  if (r .lt. 6 .and. q + r .gt. 8) l = l .or. g(r, q) .ne. w(27:38)\n+\t  if (r .lt. 6 .and. q + r .le. 8) l = l .or. h(r, q) .ne. w(1:7)\n+\t  if (r .lt. 6 .and. q + r .gt. 8) l = l .or. h(r, q) .ne. w(20:26)\n+\t  if (q .lt. 6) l = l .or. t(p, q, r) .ne. -10 + x + p - q + 2 * r\n+\t  l = l .or. u(p, q, r) .ne. 30 - x - p + q - 2 * r\n+\t  if (r .lt. 6 .and. q + r .le. 8) l = l .or. v(r, q) .ne. w(1:7)\n+\t  if (r .lt. 6 .and. q + r .gt. 8) l = l .or. v(r, q) .ne. w(20:26)\n+103 continue\n+    do 104, p = 3, 5\n+      do 104, q = 2, 6\n+\tdo 104, r = 1, 7\n+\t  l = l .or. i(p - 2, q - 1, r) .ne. (7.5 + x) * p * q * r\n+\t  l = l .or. j(p, q + 3, r + 6) .ne. (9.5 + x) * p * q * r\n+104 continue\n+    do 105, p = 1, 5\n+      do 105, q = 4, 6\n+\tl = l .or. k(p, 1, q - 3) .ne. 19 + x + p + 7 + 3 * q\n+105 continue\n+    call check (size (e, 1), 2, l)\n+    call check (size (e, 2), 3, l)\n+    call check (size (e, 3), 7, l)\n+    call check (size (e), 42, l)\n+    call check (size (f, 1), 2, l)\n+    call check (size (f, 2), 5, l)\n+    call check (size (f, 3), 7, l)\n+    call check (size (f), 70, l)\n+    call check (size (g, 1), 5, l)\n+    call check (size (g, 2), 5, l)\n+    call check (size (g), 25, l)\n+    call check (size (h, 1), 5, l)\n+    call check (size (h, 2), 5, l)\n+    call check (size (h), 25, l)\n+    call check (size (i, 1), 3, l)\n+    call check (size (i, 2), 5, l)\n+    call check (size (i, 3), 7, l)\n+    call check (size (i), 105, l)\n+    call check (size (j, 1), 4, l)\n+    call check (size (j, 2), 5, l)\n+    call check (size (j, 3), 7, l)\n+    call check (size (j), 140, l)\n+    call check (size (k, 1), 5, l)\n+    call check (size (k, 2), 1, l)\n+    call check (size (k, 3), 3, l)\n+    call check (size (k), 15, l)\n+!$omp end parallel\n+    if (l) call abort\n+  end subroutine foo\n+\n+  subroutine test\n+    character (len = 12) :: c\n+    character (len = 7) :: d\n+    integer, dimension (2, 3:5, 7) :: e\n+    integer, dimension (2, 3:7, 7) :: f\n+    character (len = 12), dimension (5, 3:7) :: g\n+    character (len = 7), dimension (5, 3:7) :: h\n+    real, dimension (3:5, 2:6, 1:7) :: i\n+    double precision, dimension (3:6, 2:6, 1:7) :: j\n+    integer, dimension (1:5, 7:7, 4:6) :: k\n+    integer :: p, q, r\n+    c = 'abcdefghijkl'\n+    d = 'ABCDEFG'\n+    forall (p = 1:2, q = 3:5, r = 1:7) e(p, q, r) = 5 + p + q + 2 * r\n+    forall (p = 1:2, q = 3:7, r = 1:7) f(p, q, r) = 25 + p + q + 2 * r\n+    forall (p = 1:5, q = 3:7, p + q .le. 8) g(p, q) = '0123456789AB'\n+    forall (p = 1:5, q = 3:7, p + q .gt. 8) g(p, q) = '9876543210ZY'\n+    forall (p = 1:5, q = 3:7, p + q .le. 8) h(p, q) = '0123456'\n+    forall (p = 1:5, q = 3:7, p + q .gt. 8) h(p, q) = '9876543'\n+    forall (p = 3:5, q = 2:6, r = 1:7) i(p, q, r) = 7.5 * p * q * r\n+    forall (p = 3:6, q = 2:6, r = 1:7) j(p, q, r) = 9.5 * p * q * r\n+    forall (p = 1:5, q = 7:7, r = 4:6) k(p, q, r) = 19 + p + q + 3 * r\n+    call foo (c, d, e, f, g, h, i, j, k, 7)\n+  end subroutine test\n+end"}, {"sha": "a9510fd385ad29af8d1ed53411c365737a550d4f", "filename": "libgomp/testsuite/libgomp.fortran/vla2.f90", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fvla2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fvla2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fvla2.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,142 @@\n+! { dg-do run }\n+\n+  call test\n+contains\n+  subroutine check (x, y, l)\n+    integer :: x, y\n+    logical :: l\n+    l = l .or. x .ne. y\n+  end subroutine check\n+\n+  subroutine foo (c, d, e, f, g, h, i, j, k, n)\n+    use omp_lib\n+    integer :: n\n+    character (len = *) :: c\n+    character (len = n) :: d\n+    integer, dimension (2, 3:5, n) :: e\n+    integer, dimension (2, 3:n, n) :: f\n+    character (len = *), dimension (5, 3:n) :: g\n+    character (len = n), dimension (5, 3:n) :: h\n+    real, dimension (:, :, :) :: i\n+    double precision, dimension (3:, 5:, 7:) :: j\n+    integer, dimension (:, :, :) :: k\n+    logical :: l\n+    integer :: p, q, r\n+    character (len = n) :: s\n+    integer, dimension (2, 3:5, n) :: t\n+    integer, dimension (2, 3:n, n) :: u\n+    character (len = n), dimension (5, 3:n) :: v\n+    character (len = 2 * n + 24) :: w\n+    integer :: x\n+    character (len = 1) :: y\n+    l = .false.\n+!$omp parallel default (none) private (c, d, e, f, g, h, i, j, k) &\n+!$omp & private (s, t, u, v) reduction (.or.:l) num_threads (6) &\n+!$omp private (p, q, r, w, x, y)\n+    x = omp_get_thread_num ()\n+    w = ''\n+    if (x .eq. 0) w = 'thread0thr_number_0THREAD0THR_NUMBER_0'\n+    if (x .eq. 1) w = 'thread1thr_number_1THREAD1THR_NUMBER_1'\n+    if (x .eq. 2) w = 'thread2thr_number_2THREAD2THR_NUMBER_2'\n+    if (x .eq. 3) w = 'thread3thr_number_3THREAD3THR_NUMBER_3'\n+    if (x .eq. 4) w = 'thread4thr_number_4THREAD4THR_NUMBER_4'\n+    if (x .eq. 5) w = 'thread5thr_number_5THREAD5THR_NUMBER_5'\n+    c = w(8:19)\n+    d = w(1:7)\n+    forall (p = 1:2, q = 3:5, r = 1:7) e(p, q, r) = 5 * x + p + q + 2 * r\n+    forall (p = 1:2, q = 3:7, r = 1:7) f(p, q, r) = 25 * x + p + q + 2 * r\n+    forall (p = 1:5, q = 3:7, p + q .le. 8) g(p, q) = w(8:19)\n+    forall (p = 1:5, q = 3:7, p + q .gt. 8) g(p, q) = w(27:38)\n+    forall (p = 1:5, q = 3:7, p + q .le. 8) h(p, q) = w(1:7)\n+    forall (p = 1:5, q = 3:7, p + q .gt. 8) h(p, q) = w(20:26)\n+    forall (p = 3:5, q = 2:6, r = 1:7) i(p - 2, q - 1, r) = (7.5 + x) * p * q * r\n+    forall (p = 3:5, q = 2:6, r = 1:7) j(p, q + 3, r + 6) = (9.5 + x) * p * q * r\n+    forall (p = 1:5, q = 7:7, r = 4:6) k(p, q - 6, r - 3) = 19 + x + p + q + 3 * r\n+    s = w(20:26)\n+    forall (p = 1:2, q = 3:5, r = 1:7) t(p, q, r) = -10 + x + p - q + 2 * r\n+    forall (p = 1:2, q = 3:7, r = 1:7) u(p, q, r) = 30 - x - p + q - 2 * r\n+    forall (p = 1:5, q = 3:7, p + q .le. 8) v(p, q) = w(1:7)\n+    forall (p = 1:5, q = 3:7, p + q .gt. 8) v(p, q) = w(20:26)\n+!$omp barrier\n+    y = ''\n+    if (x .eq. 0) y = '0'\n+    if (x .eq. 1) y = '1'\n+    if (x .eq. 2) y = '2'\n+    if (x .eq. 3) y = '3'\n+    if (x .eq. 4) y = '4'\n+    if (x .eq. 5) y = '5'\n+    l = l .or. w(7:7) .ne. y\n+    l = l .or. w(19:19) .ne. y\n+    l = l .or. w(26:26) .ne. y\n+    l = l .or. w(38:38) .ne. y\n+    l = l .or. c .ne. w(8:19)\n+    l = l .or. d .ne. w(1:7)\n+    l = l .or. s .ne. w(20:26)\n+    do 103, p = 1, 2\n+      do 103, q = 3, 7\n+\tdo 103, r = 1, 7\n+\t  if (q .lt. 6) l = l .or. e(p, q, r) .ne. 5 * x + p + q + 2 * r\n+\t  l = l .or. f(p, q, r) .ne. 25 * x + p + q + 2 * r\n+\t  if (r .lt. 6 .and. q + r .le. 8) l = l .or. g(r, q) .ne. w(8:19)\n+\t  if (r .lt. 6 .and. q + r .gt. 8) l = l .or. g(r, q) .ne. w(27:38)\n+\t  if (r .lt. 6 .and. q + r .le. 8) l = l .or. h(r, q) .ne. w(1:7)\n+\t  if (r .lt. 6 .and. q + r .gt. 8) l = l .or. h(r, q) .ne. w(20:26)\n+\t  if (q .lt. 6) l = l .or. t(p, q, r) .ne. -10 + x + p - q + 2 * r\n+\t  l = l .or. u(p, q, r) .ne. 30 - x - p + q - 2 * r\n+\t  if (r .lt. 6 .and. q + r .le. 8) l = l .or. v(r, q) .ne. w(1:7)\n+\t  if (r .lt. 6 .and. q + r .gt. 8) l = l .or. v(r, q) .ne. w(20:26)\n+103 continue\n+    do 104, p = 3, 5\n+      do 104, q = 2, 6\n+\tdo 104, r = 1, 7\n+\t  l = l .or. i(p - 2, q - 1, r) .ne. (7.5 + x) * p * q * r\n+\t  l = l .or. j(p, q + 3, r + 6) .ne. (9.5 + x) * p * q * r\n+104 continue\n+    do 105, p = 1, 5\n+      do 105, q = 4, 6\n+\tl = l .or. k(p, 1, q - 3) .ne. 19 + x + p + 7 + 3 * q\n+105 continue\n+    call check (size (e, 1), 2, l)\n+    call check (size (e, 2), 3, l)\n+    call check (size (e, 3), 7, l)\n+    call check (size (e), 42, l)\n+    call check (size (f, 1), 2, l)\n+    call check (size (f, 2), 5, l)\n+    call check (size (f, 3), 7, l)\n+    call check (size (f), 70, l)\n+    call check (size (g, 1), 5, l)\n+    call check (size (g, 2), 5, l)\n+    call check (size (g), 25, l)\n+    call check (size (h, 1), 5, l)\n+    call check (size (h, 2), 5, l)\n+    call check (size (h), 25, l)\n+    call check (size (i, 1), 3, l)\n+    call check (size (i, 2), 5, l)\n+    call check (size (i, 3), 7, l)\n+    call check (size (i), 105, l)\n+    call check (size (j, 1), 4, l)\n+    call check (size (j, 2), 5, l)\n+    call check (size (j, 3), 7, l)\n+    call check (size (j), 140, l)\n+    call check (size (k, 1), 5, l)\n+    call check (size (k, 2), 1, l)\n+    call check (size (k, 3), 3, l)\n+    call check (size (k), 15, l)\n+!$omp end parallel\n+    if (l) call abort\n+  end subroutine foo\n+\n+  subroutine test\n+    character (len = 12) :: c\n+    character (len = 7) :: d\n+    integer, dimension (2, 3:5, 7) :: e\n+    integer, dimension (2, 3:7, 7) :: f\n+    character (len = 12), dimension (5, 3:7) :: g\n+    character (len = 7), dimension (5, 3:7) :: h\n+    real, dimension (3:5, 2:6, 1:7) :: i\n+    double precision, dimension (3:6, 2:6, 1:7) :: j\n+    integer, dimension (1:5, 7:7, 4:6) :: k\n+    integer :: p, q, r\n+    call foo (c, d, e, f, g, h, i, j, k, 7)\n+  end subroutine test\n+end"}, {"sha": "bfafc4f7d0546c32a67d9c9e5017055801063182", "filename": "libgomp/testsuite/libgomp.fortran/vla3.f90", "status": "added", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fvla3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fvla3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fvla3.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,191 @@\n+! { dg-do run }\n+\n+  call test\n+contains\n+  subroutine check (x, y, l)\n+    integer :: x, y\n+    logical :: l\n+    l = l .or. x .ne. y\n+  end subroutine check\n+\n+  subroutine foo (c, d, e, f, g, h, i, j, k, n)\n+    use omp_lib\n+    integer :: n\n+    character (len = *) :: c\n+    character (len = n) :: d\n+    integer, dimension (2, 3:5, n) :: e\n+    integer, dimension (2, 3:n, n) :: f\n+    character (len = *), dimension (5, 3:n) :: g\n+    character (len = n), dimension (5, 3:n) :: h\n+    real, dimension (:, :, :) :: i\n+    double precision, dimension (3:, 5:, 7:) :: j\n+    integer, dimension (:, :, :) :: k\n+    logical :: l\n+    integer :: p, q, r\n+    character (len = n) :: s\n+    integer, dimension (2, 3:5, n) :: t\n+    integer, dimension (2, 3:n, n) :: u\n+    character (len = n), dimension (5, 3:n) :: v\n+    character (len = 2 * n + 24) :: w\n+    integer :: x, z\n+    character (len = 1) :: y\n+    s = 'PQRSTUV'\n+    forall (p = 1:2, q = 3:5, r = 1:7) t(p, q, r) = -10 + p - q + 2 * r\n+    forall (p = 1:2, q = 3:7, r = 1:7) u(p, q, r) = 30 - p + q - 2 * r\n+    forall (p = 1:5, q = 3:7, p + q .le. 8) v(p, q) = '_+|/Oo_'\n+    forall (p = 1:5, q = 3:7, p + q .gt. 8) v(p, q) = '///|||!'\n+    l = .false.\n+!$omp parallel default (none) shared (c, d, e, f, g, h, i, j, k) &\n+!$omp & shared (s, t, u, v) reduction (.or.:l) num_threads (6) &\n+!$omp private (p, q, r, w, x, y)\n+    l = l .or. c .ne. 'abcdefghijkl'\n+    l = l .or. d .ne. 'ABCDEFG'\n+    l = l .or. s .ne. 'PQRSTUV'\n+    do 100, p = 1, 2\n+      do 100, q = 3, 7\n+\tdo 100, r = 1, 7\n+\t  if (q .lt. 6) l = l .or. e(p, q, r) .ne. 5 + p + q + 2 * r\n+\t  l = l .or. f(p, q, r) .ne. 25 + p + q + 2 * r\n+\t  if (r .lt. 6 .and. q + r .le. 8) l = l .or. g(r, q) .ne. '0123456789AB'\n+\t  if (r .lt. 6 .and. q + r .gt. 8) l = l .or. g(r, q) .ne. '9876543210ZY'\n+\t  if (r .lt. 6 .and. q + r .le. 8) l = l .or. h(r, q) .ne. '0123456'\n+\t  if (r .lt. 6 .and. q + r .gt. 8) l = l .or. h(r, q) .ne. '9876543'\n+\t  if (q .lt. 6) l = l .or. t(p, q, r) .ne. -10 + p - q + 2 * r\n+\t  l = l .or. u(p, q, r) .ne. 30 - p + q - 2 * r\n+\t  if (r .lt. 6 .and. q + r .le. 8) l = l .or. v(r, q) .ne. '_+|/Oo_'\n+\t  if (r .lt. 6 .and. q + r .gt. 8) l = l .or. v(r, q) .ne. '///|||!'\n+100 continue\n+    do 101, p = 3, 5\n+      do 101, q = 2, 6\n+\tdo 101, r = 1, 7\n+\t  l = l .or. i(p - 2, q - 1, r) .ne. 7.5 * p * q * r\n+\t  l = l .or. j(p, q + 3, r + 6) .ne. 9.5 * p * q * r\n+101 continue\n+    do 102, p = 1, 5\n+      do 102, q = 4, 6\n+\tl = l .or. k(p, 1, q - 3) .ne. 19 + p + 7 + 3 * q\n+102 continue\n+    do 110 z = 0, omp_get_num_threads () - 1\n+!$omp barrier\n+      x = omp_get_thread_num ()\n+      w = ''\n+      if (z .eq. 0) w = 'thread0thr_number_0THREAD0THR_NUMBER_0'\n+      if (z .eq. 1) w = 'thread1thr_number_1THREAD1THR_NUMBER_1'\n+      if (z .eq. 2) w = 'thread2thr_number_2THREAD2THR_NUMBER_2'\n+      if (z .eq. 3) w = 'thread3thr_number_3THREAD3THR_NUMBER_3'\n+      if (z .eq. 4) w = 'thread4thr_number_4THREAD4THR_NUMBER_4'\n+      if (z .eq. 5) w = 'thread5thr_number_5THREAD5THR_NUMBER_5'\n+      if (x .eq. z) then\n+\tc = w(8:19)\n+\td = w(1:7)\n+\tforall (p = 1:2, q = 3:5, r = 1:7) e(p, q, r) = 5 * x + p + q + 2 * r\n+\tforall (p = 1:2, q = 3:7, r = 1:7) f(p, q, r) = 25 * x + p + q + 2 * r\n+\tforall (p = 1:5, q = 3:7, p + q .le. 8) g(p, q) = w(8:19)\n+\tforall (p = 1:5, q = 3:7, p + q .gt. 8) g(p, q) = w(27:38)\n+\tforall (p = 1:5, q = 3:7, p + q .le. 8) h(p, q) = w(1:7)\n+\tforall (p = 1:5, q = 3:7, p + q .gt. 8) h(p, q) = w(20:26)\n+\tforall (p = 3:5, q = 2:6, r = 1:7) i(p - 2, q - 1, r) = (7.5 + x) * p * q * r\n+\tforall (p = 3:5, q = 2:6, r = 1:7) j(p, q + 3, r + 6) = (9.5 + x) * p * q * r\n+\tforall (p = 1:5, q = 7:7, r = 4:6) k(p, q - 6, r - 3) = 19 + x + p + q + 3 * r\n+\ts = w(20:26)\n+\tforall (p = 1:2, q = 3:5, r = 1:7) t(p, q, r) = -10 + x + p - q + 2 * r\n+\tforall (p = 1:2, q = 3:7, r = 1:7) u(p, q, r) = 30 - x - p + q - 2 * r\n+\tforall (p = 1:5, q = 3:7, p + q .le. 8) v(p, q) = w(1:7)\n+\tforall (p = 1:5, q = 3:7, p + q .gt. 8) v(p, q) = w(20:26)\n+      end if\n+!$omp barrier\n+      x = z\n+      y = ''\n+      if (x .eq. 0) y = '0'\n+      if (x .eq. 1) y = '1'\n+      if (x .eq. 2) y = '2'\n+      if (x .eq. 3) y = '3'\n+      if (x .eq. 4) y = '4'\n+      if (x .eq. 5) y = '5'\n+      l = l .or. w(7:7) .ne. y\n+      l = l .or. w(19:19) .ne. y\n+      l = l .or. w(26:26) .ne. y\n+      l = l .or. w(38:38) .ne. y\n+      l = l .or. c .ne. w(8:19)\n+      l = l .or. d .ne. w(1:7)\n+      l = l .or. s .ne. w(20:26)\n+      do 103, p = 1, 2\n+\tdo 103, q = 3, 7\n+\t  do 103, r = 1, 7\n+\t    if (q .lt. 6) l = l .or. e(p, q, r) .ne. 5 * x + p + q + 2 * r\n+\t    l = l .or. f(p, q, r) .ne. 25 * x + p + q + 2 * r\n+\t    if (r .lt. 6 .and. q + r .le. 8) l = l .or. g(r, q) .ne. w(8:19)\n+\t    if (r .lt. 6 .and. q + r .gt. 8) l = l .or. g(r, q) .ne. w(27:38)\n+\t    if (r .lt. 6 .and. q + r .le. 8) l = l .or. h(r, q) .ne. w(1:7)\n+\t    if (r .lt. 6 .and. q + r .gt. 8) l = l .or. h(r, q) .ne. w(20:26)\n+\t    if (q .lt. 6) l = l .or. t(p, q, r) .ne. -10 + x + p - q + 2 * r\n+\t    l = l .or. u(p, q, r) .ne. 30 - x - p + q - 2 * r\n+\t    if (r .lt. 6 .and. q + r .le. 8) l = l .or. v(r, q) .ne. w(1:7)\n+\t    if (r .lt. 6 .and. q + r .gt. 8) l = l .or. v(r, q) .ne. w(20:26)\n+103   continue\n+      do 104, p = 3, 5\n+\tdo 104, q = 2, 6\n+\t  do 104, r = 1, 7\n+\t    l = l .or. i(p - 2, q - 1, r) .ne. (7.5 + x) * p * q * r\n+\t    l = l .or. j(p, q + 3, r + 6) .ne. (9.5 + x) * p * q * r\n+104   continue\n+      do 105, p = 1, 5\n+\tdo 105, q = 4, 6\n+\t  l = l .or. k(p, 1, q - 3) .ne. 19 + x + p + 7 + 3 * q\n+105   continue\n+110 continue\n+    call check (size (e, 1), 2, l)\n+    call check (size (e, 2), 3, l)\n+    call check (size (e, 3), 7, l)\n+    call check (size (e), 42, l)\n+    call check (size (f, 1), 2, l)\n+    call check (size (f, 2), 5, l)\n+    call check (size (f, 3), 7, l)\n+    call check (size (f), 70, l)\n+    call check (size (g, 1), 5, l)\n+    call check (size (g, 2), 5, l)\n+    call check (size (g), 25, l)\n+    call check (size (h, 1), 5, l)\n+    call check (size (h, 2), 5, l)\n+    call check (size (h), 25, l)\n+    call check (size (i, 1), 3, l)\n+    call check (size (i, 2), 5, l)\n+    call check (size (i, 3), 7, l)\n+    call check (size (i), 105, l)\n+    call check (size (j, 1), 4, l)\n+    call check (size (j, 2), 5, l)\n+    call check (size (j, 3), 7, l)\n+    call check (size (j), 140, l)\n+    call check (size (k, 1), 5, l)\n+    call check (size (k, 2), 1, l)\n+    call check (size (k, 3), 3, l)\n+    call check (size (k), 15, l)\n+!$omp end parallel\n+    if (l) call abort\n+  end subroutine foo\n+\n+  subroutine test\n+    character (len = 12) :: c\n+    character (len = 7) :: d\n+    integer, dimension (2, 3:5, 7) :: e\n+    integer, dimension (2, 3:7, 7) :: f\n+    character (len = 12), dimension (5, 3:7) :: g\n+    character (len = 7), dimension (5, 3:7) :: h\n+    real, dimension (3:5, 2:6, 1:7) :: i\n+    double precision, dimension (3:6, 2:6, 1:7) :: j\n+    integer, dimension (1:5, 7:7, 4:6) :: k\n+    integer :: p, q, r\n+    c = 'abcdefghijkl'\n+    d = 'ABCDEFG'\n+    forall (p = 1:2, q = 3:5, r = 1:7) e(p, q, r) = 5 + p + q + 2 * r\n+    forall (p = 1:2, q = 3:7, r = 1:7) f(p, q, r) = 25 + p + q + 2 * r\n+    forall (p = 1:5, q = 3:7, p + q .le. 8) g(p, q) = '0123456789AB'\n+    forall (p = 1:5, q = 3:7, p + q .gt. 8) g(p, q) = '9876543210ZY'\n+    forall (p = 1:5, q = 3:7, p + q .le. 8) h(p, q) = '0123456'\n+    forall (p = 1:5, q = 3:7, p + q .gt. 8) h(p, q) = '9876543'\n+    forall (p = 3:5, q = 2:6, r = 1:7) i(p, q, r) = 7.5 * p * q * r\n+    forall (p = 3:6, q = 2:6, r = 1:7) j(p, q, r) = 9.5 * p * q * r\n+    forall (p = 1:5, q = 7:7, r = 4:6) k(p, q, r) = 19 + p + q + 3 * r\n+    call foo (c, d, e, f, g, h, i, j, k, 7)\n+  end subroutine test\n+end"}, {"sha": "58caabc6248263eb07c68eb8fccd7013c0fa13fe", "filename": "libgomp/testsuite/libgomp.fortran/vla4.f90", "status": "added", "additions": 228, "deletions": 0, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fvla4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fvla4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fvla4.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,228 @@\n+! { dg-do run }\n+\n+  call test\n+contains\n+  subroutine check (x, y, l)\n+    integer :: x, y\n+    logical :: l\n+    l = l .or. x .ne. y\n+  end subroutine check\n+\n+  subroutine foo (c, d, e, f, g, h, i, j, k, n)\n+    use omp_lib\n+    integer :: n\n+    character (len = *) :: c\n+    character (len = n) :: d\n+    integer, dimension (2, 3:5, n) :: e\n+    integer, dimension (2, 3:n, n) :: f\n+    character (len = *), dimension (5, 3:n) :: g\n+    character (len = n), dimension (5, 3:n) :: h\n+    real, dimension (:, :, :) :: i\n+    double precision, dimension (3:, 5:, 7:) :: j\n+    integer, dimension (:, :, :) :: k\n+    logical :: l\n+    integer :: p, q, r\n+    character (len = n) :: s\n+    integer, dimension (2, 3:5, n) :: t\n+    integer, dimension (2, 3:n, n) :: u\n+    character (len = n), dimension (5, 3:n) :: v\n+    character (len = 2 * n + 24) :: w\n+    integer :: x, z, z2\n+    character (len = 1) :: y\n+    s = 'PQRSTUV'\n+    forall (p = 1:2, q = 3:5, r = 1:7) t(p, q, r) = -10 + p - q + 2 * r\n+    forall (p = 1:2, q = 3:7, r = 1:7) u(p, q, r) = 30 - p + q - 2 * r\n+    forall (p = 1:5, q = 3:7, p + q .le. 8) v(p, q) = '_+|/Oo_'\n+    forall (p = 1:5, q = 3:7, p + q .gt. 8) v(p, q) = '///|||!'\n+    l = .false.\n+    call omp_set_dynamic (.false.)\n+    call omp_set_num_threads (6)\n+!$omp parallel do default (none) firstprivate (c, d, e, f, g, h, i, j, k) &\n+!$omp & firstprivate (s, t, u, v) reduction (.or.:l) num_threads (6) &\n+!$omp private (p, q, r, w, x, y) schedule (static) shared (z2) &\n+!$omp lastprivate (c, d, e, f, g, h, i, j, k, s, t, u, v)\n+    do 110 z = 0, omp_get_num_threads () - 1\n+    if (omp_get_thread_num () .eq. 0) z2 = omp_get_num_threads ()\n+    l = l .or. c .ne. 'abcdefghijkl'\n+    l = l .or. d .ne. 'ABCDEFG'\n+    l = l .or. s .ne. 'PQRSTUV'\n+    do 100, p = 1, 2\n+      do 100, q = 3, 7\n+\tdo 100, r = 1, 7\n+\t  if (q .lt. 6) l = l .or. e(p, q, r) .ne. 5 + p + q + 2 * r\n+\t  l = l .or. f(p, q, r) .ne. 25 + p + q + 2 * r\n+\t  if (r .lt. 6 .and. q + r .le. 8) l = l .or. g(r, q) .ne. '0123456789AB'\n+\t  if (r .lt. 6 .and. q + r .gt. 8) l = l .or. g(r, q) .ne. '9876543210ZY'\n+\t  if (r .lt. 6 .and. q + r .le. 8) l = l .or. h(r, q) .ne. '0123456'\n+\t  if (r .lt. 6 .and. q + r .gt. 8) l = l .or. h(r, q) .ne. '9876543'\n+\t  if (q .lt. 6) l = l .or. t(p, q, r) .ne. -10 + p - q + 2 * r\n+\t  l = l .or. u(p, q, r) .ne. 30 - p + q - 2 * r\n+\t  if (r .lt. 6 .and. q + r .le. 8) l = l .or. v(r, q) .ne. '_+|/Oo_'\n+\t  if (r .lt. 6 .and. q + r .gt. 8) l = l .or. v(r, q) .ne. '///|||!'\n+100 continue\n+    do 101, p = 3, 5\n+      do 101, q = 2, 6\n+\tdo 101, r = 1, 7\n+\t  l = l .or. i(p - 2, q - 1, r) .ne. 7.5 * p * q * r\n+\t  l = l .or. j(p, q + 3, r + 6) .ne. 9.5 * p * q * r\n+101 continue\n+    do 102, p = 1, 5\n+      do 102, q = 4, 6\n+\tl = l .or. k(p, 1, q - 3) .ne. 19 + p + 7 + 3 * q\n+102 continue\n+    x = omp_get_thread_num ()\n+    w = ''\n+    if (x .eq. 0) w = 'thread0thr_number_0THREAD0THR_NUMBER_0'\n+    if (x .eq. 1) w = 'thread1thr_number_1THREAD1THR_NUMBER_1'\n+    if (x .eq. 2) w = 'thread2thr_number_2THREAD2THR_NUMBER_2'\n+    if (x .eq. 3) w = 'thread3thr_number_3THREAD3THR_NUMBER_3'\n+    if (x .eq. 4) w = 'thread4thr_number_4THREAD4THR_NUMBER_4'\n+    if (x .eq. 5) w = 'thread5thr_number_5THREAD5THR_NUMBER_5'\n+    c = w(8:19)\n+    d = w(1:7)\n+    forall (p = 1:2, q = 3:5, r = 1:7) e(p, q, r) = 5 * x + p + q + 2 * r\n+    forall (p = 1:2, q = 3:7, r = 1:7) f(p, q, r) = 25 * x + p + q + 2 * r\n+    forall (p = 1:5, q = 3:7, p + q .le. 8) g(p, q) = w(8:19)\n+    forall (p = 1:5, q = 3:7, p + q .gt. 8) g(p, q) = w(27:38)\n+    forall (p = 1:5, q = 3:7, p + q .le. 8) h(p, q) = w(1:7)\n+    forall (p = 1:5, q = 3:7, p + q .gt. 8) h(p, q) = w(20:26)\n+    forall (p = 3:5, q = 2:6, r = 1:7) i(p - 2, q - 1, r) = (7.5 + x) * p * q * r\n+    forall (p = 3:5, q = 2:6, r = 1:7) j(p, q + 3, r + 6) = (9.5 + x) * p * q * r\n+    forall (p = 1:5, q = 7:7, r = 4:6) k(p, q - 6, r - 3) = 19 + x + p + q + 3 * r\n+    s = w(20:26)\n+    forall (p = 1:2, q = 3:5, r = 1:7) t(p, q, r) = -10 + x + p - q + 2 * r\n+    forall (p = 1:2, q = 3:7, r = 1:7) u(p, q, r) = 30 - x - p + q - 2 * r\n+    forall (p = 1:5, q = 3:7, p + q .le. 8) v(p, q) = w(1:7)\n+    forall (p = 1:5, q = 3:7, p + q .gt. 8) v(p, q) = w(20:26)\n+!$omp barrier\n+    y = ''\n+    if (x .eq. 0) y = '0'\n+    if (x .eq. 1) y = '1'\n+    if (x .eq. 2) y = '2'\n+    if (x .eq. 3) y = '3'\n+    if (x .eq. 4) y = '4'\n+    if (x .eq. 5) y = '5'\n+    l = l .or. w(7:7) .ne. y\n+    l = l .or. w(19:19) .ne. y\n+    l = l .or. w(26:26) .ne. y\n+    l = l .or. w(38:38) .ne. y\n+    l = l .or. c .ne. w(8:19)\n+    l = l .or. d .ne. w(1:7)\n+    l = l .or. s .ne. w(20:26)\n+    do 103, p = 1, 2\n+      do 103, q = 3, 7\n+\tdo 103, r = 1, 7\n+\t  if (q .lt. 6) l = l .or. e(p, q, r) .ne. 5 * x + p + q + 2 * r\n+\t  l = l .or. f(p, q, r) .ne. 25 * x + p + q + 2 * r\n+\t  if (r .lt. 6 .and. q + r .le. 8) l = l .or. g(r, q) .ne. w(8:19)\n+\t  if (r .lt. 6 .and. q + r .gt. 8) l = l .or. g(r, q) .ne. w(27:38)\n+\t  if (r .lt. 6 .and. q + r .le. 8) l = l .or. h(r, q) .ne. w(1:7)\n+\t  if (r .lt. 6 .and. q + r .gt. 8) l = l .or. h(r, q) .ne. w(20:26)\n+\t  if (q .lt. 6) l = l .or. t(p, q, r) .ne. -10 + x + p - q + 2 * r\n+\t  l = l .or. u(p, q, r) .ne. 30 - x - p + q - 2 * r\n+\t  if (r .lt. 6 .and. q + r .le. 8) l = l .or. v(r, q) .ne. w(1:7)\n+\t  if (r .lt. 6 .and. q + r .gt. 8) l = l .or. v(r, q) .ne. w(20:26)\n+103 continue\n+    do 104, p = 3, 5\n+      do 104, q = 2, 6\n+\tdo 104, r = 1, 7\n+\t  l = l .or. i(p - 2, q - 1, r) .ne. (7.5 + x) * p * q * r\n+\t  l = l .or. j(p, q + 3, r + 6) .ne. (9.5 + x) * p * q * r\n+104 continue\n+    do 105, p = 1, 5\n+      do 105, q = 4, 6\n+\tl = l .or. k(p, 1, q - 3) .ne. 19 + x + p + 7 + 3 * q\n+105 continue\n+    call check (size (e, 1), 2, l)\n+    call check (size (e, 2), 3, l)\n+    call check (size (e, 3), 7, l)\n+    call check (size (e), 42, l)\n+    call check (size (f, 1), 2, l)\n+    call check (size (f, 2), 5, l)\n+    call check (size (f, 3), 7, l)\n+    call check (size (f), 70, l)\n+    call check (size (g, 1), 5, l)\n+    call check (size (g, 2), 5, l)\n+    call check (size (g), 25, l)\n+    call check (size (h, 1), 5, l)\n+    call check (size (h, 2), 5, l)\n+    call check (size (h), 25, l)\n+    call check (size (i, 1), 3, l)\n+    call check (size (i, 2), 5, l)\n+    call check (size (i, 3), 7, l)\n+    call check (size (i), 105, l)\n+    call check (size (j, 1), 4, l)\n+    call check (size (j, 2), 5, l)\n+    call check (size (j, 3), 7, l)\n+    call check (size (j), 140, l)\n+    call check (size (k, 1), 5, l)\n+    call check (size (k, 2), 1, l)\n+    call check (size (k, 3), 3, l)\n+    call check (size (k), 15, l)\n+110 continue\n+!$omp end parallel do\n+    if (l) call abort\n+    if (z2 == 6) then\n+      x = 5\n+      w = 'thread5thr_number_5THREAD5THR_NUMBER_5'\n+      y = '5'\n+      l = l .or. w(7:7) .ne. y\n+      l = l .or. w(19:19) .ne. y\n+      l = l .or. w(26:26) .ne. y\n+      l = l .or. w(38:38) .ne. y\n+      l = l .or. c .ne. w(8:19)\n+      l = l .or. d .ne. w(1:7)\n+      l = l .or. s .ne. w(20:26)\n+      do 113, p = 1, 2\n+\tdo 113, q = 3, 7\n+\t  do 113, r = 1, 7\n+\t    if (q .lt. 6) l = l .or. e(p, q, r) .ne. 5 * x + p + q + 2 * r\n+\t    l = l .or. f(p, q, r) .ne. 25 * x + p + q + 2 * r\n+\t    if (r .lt. 6 .and. q + r .le. 8) l = l .or. g(r, q) .ne. w(8:19)\n+\t    if (r .lt. 6 .and. q + r .gt. 8) l = l .or. g(r, q) .ne. w(27:38)\n+\t    if (r .lt. 6 .and. q + r .le. 8) l = l .or. h(r, q) .ne. w(1:7)\n+\t    if (r .lt. 6 .and. q + r .gt. 8) l = l .or. h(r, q) .ne. w(20:26)\n+\t    if (q .lt. 6) l = l .or. t(p, q, r) .ne. -10 + x + p - q + 2 * r\n+\t    l = l .or. u(p, q, r) .ne. 30 - x - p + q - 2 * r\n+\t    if (r .lt. 6 .and. q + r .le. 8) l = l .or. v(r, q) .ne. w(1:7)\n+\t    if (r .lt. 6 .and. q + r .gt. 8) l = l .or. v(r, q) .ne. w(20:26)\n+113   continue\n+      do 114, p = 3, 5\n+\tdo 114, q = 2, 6\n+\t  do 114, r = 1, 7\n+\t    l = l .or. i(p - 2, q - 1, r) .ne. (7.5 + x) * p * q * r\n+\t    l = l .or. j(p, q + 3, r + 6) .ne. (9.5 + x) * p * q * r\n+114   continue\n+      do 115, p = 1, 5\n+\tdo 115, q = 4, 6\n+\t  l = l .or. k(p, 1, q - 3) .ne. 19 + x + p + 7 + 3 * q\n+115   continue\n+      if (l) call abort\n+    end if\n+  end subroutine foo\n+\n+  subroutine test\n+    character (len = 12) :: c\n+    character (len = 7) :: d\n+    integer, dimension (2, 3:5, 7) :: e\n+    integer, dimension (2, 3:7, 7) :: f\n+    character (len = 12), dimension (5, 3:7) :: g\n+    character (len = 7), dimension (5, 3:7) :: h\n+    real, dimension (3:5, 2:6, 1:7) :: i\n+    double precision, dimension (3:6, 2:6, 1:7) :: j\n+    integer, dimension (1:5, 7:7, 4:6) :: k\n+    integer :: p, q, r\n+    c = 'abcdefghijkl'\n+    d = 'ABCDEFG'\n+    forall (p = 1:2, q = 3:5, r = 1:7) e(p, q, r) = 5 + p + q + 2 * r\n+    forall (p = 1:2, q = 3:7, r = 1:7) f(p, q, r) = 25 + p + q + 2 * r\n+    forall (p = 1:5, q = 3:7, p + q .le. 8) g(p, q) = '0123456789AB'\n+    forall (p = 1:5, q = 3:7, p + q .gt. 8) g(p, q) = '9876543210ZY'\n+    forall (p = 1:5, q = 3:7, p + q .le. 8) h(p, q) = '0123456'\n+    forall (p = 1:5, q = 3:7, p + q .gt. 8) h(p, q) = '9876543'\n+    forall (p = 3:5, q = 2:6, r = 1:7) i(p, q, r) = 7.5 * p * q * r\n+    forall (p = 3:6, q = 2:6, r = 1:7) j(p, q, r) = 9.5 * p * q * r\n+    forall (p = 1:5, q = 7:7, r = 4:6) k(p, q, r) = 19 + p + q + 3 * r\n+    call foo (c, d, e, f, g, h, i, j, k, 7)\n+  end subroutine test\n+end"}, {"sha": "5c889f9923aa6e2196adf6bc7745c9ddc1c1c646", "filename": "libgomp/testsuite/libgomp.fortran/vla5.f90", "status": "added", "additions": 200, "deletions": 0, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fvla5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fvla5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fvla5.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,200 @@\n+! { dg-do run }\n+\n+  call test\n+contains\n+  subroutine check (x, y, l)\n+    integer :: x, y\n+    logical :: l\n+    l = l .or. x .ne. y\n+  end subroutine check\n+\n+  subroutine foo (c, d, e, f, g, h, i, j, k, n)\n+    use omp_lib\n+    integer :: n\n+    character (len = *) :: c\n+    character (len = n) :: d\n+    integer, dimension (2, 3:5, n) :: e\n+    integer, dimension (2, 3:n, n) :: f\n+    character (len = *), dimension (5, 3:n) :: g\n+    character (len = n), dimension (5, 3:n) :: h\n+    real, dimension (:, :, :) :: i\n+    double precision, dimension (3:, 5:, 7:) :: j\n+    integer, dimension (:, :, :) :: k\n+    logical :: l\n+    integer :: p, q, r\n+    character (len = n) :: s\n+    integer, dimension (2, 3:5, n) :: t\n+    integer, dimension (2, 3:n, n) :: u\n+    character (len = n), dimension (5, 3:n) :: v\n+    character (len = 2 * n + 24) :: w\n+    integer :: x, z, z2\n+    character (len = 1) :: y\n+    s = 'PQRSTUV'\n+    forall (p = 1:2, q = 3:5, r = 1:7) t(p, q, r) = -10 + p - q + 2 * r\n+    forall (p = 1:2, q = 3:7, r = 1:7) u(p, q, r) = 30 - p + q - 2 * r\n+    forall (p = 1:5, q = 3:7, p + q .le. 8) v(p, q) = '_+|/Oo_'\n+    forall (p = 1:5, q = 3:7, p + q .gt. 8) v(p, q) = '///|||!'\n+    l = .false.\n+    call omp_set_dynamic (.false.)\n+    call omp_set_num_threads (6)\n+!$omp parallel do default (none) lastprivate (c, d, e, f, g, h, i, j, k) &\n+!$omp & lastprivate (s, t, u, v) reduction (.or.:l) num_threads (6) &\n+!$omp private (p, q, r, w, x, y) schedule (static) shared (z2)\n+    do 110 z = 0, omp_get_num_threads () - 1\n+    if (omp_get_thread_num () .eq. 0) z2 = omp_get_num_threads ()\n+    x = omp_get_thread_num ()\n+    w = ''\n+    if (x .eq. 0) w = 'thread0thr_number_0THREAD0THR_NUMBER_0'\n+    if (x .eq. 1) w = 'thread1thr_number_1THREAD1THR_NUMBER_1'\n+    if (x .eq. 2) w = 'thread2thr_number_2THREAD2THR_NUMBER_2'\n+    if (x .eq. 3) w = 'thread3thr_number_3THREAD3THR_NUMBER_3'\n+    if (x .eq. 4) w = 'thread4thr_number_4THREAD4THR_NUMBER_4'\n+    if (x .eq. 5) w = 'thread5thr_number_5THREAD5THR_NUMBER_5'\n+    c = w(8:19)\n+    d = w(1:7)\n+    forall (p = 1:2, q = 3:5, r = 1:7) e(p, q, r) = 5 * x + p + q + 2 * r\n+    forall (p = 1:2, q = 3:7, r = 1:7) f(p, q, r) = 25 * x + p + q + 2 * r\n+    forall (p = 1:5, q = 3:7, p + q .le. 8) g(p, q) = w(8:19)\n+    forall (p = 1:5, q = 3:7, p + q .gt. 8) g(p, q) = w(27:38)\n+    forall (p = 1:5, q = 3:7, p + q .le. 8) h(p, q) = w(1:7)\n+    forall (p = 1:5, q = 3:7, p + q .gt. 8) h(p, q) = w(20:26)\n+    forall (p = 3:5, q = 2:6, r = 1:7) i(p - 2, q - 1, r) = (7.5 + x) * p * q * r\n+    forall (p = 3:5, q = 2:6, r = 1:7) j(p, q + 3, r + 6) = (9.5 + x) * p * q * r\n+    forall (p = 1:5, q = 7:7, r = 4:6) k(p, q - 6, r - 3) = 19 + x + p + q + 3 * r\n+    s = w(20:26)\n+    forall (p = 1:2, q = 3:5, r = 1:7) t(p, q, r) = -10 + x + p - q + 2 * r\n+    forall (p = 1:2, q = 3:7, r = 1:7) u(p, q, r) = 30 - x - p + q - 2 * r\n+    forall (p = 1:5, q = 3:7, p + q .le. 8) v(p, q) = w(1:7)\n+    forall (p = 1:5, q = 3:7, p + q .gt. 8) v(p, q) = w(20:26)\n+!$omp barrier\n+    y = ''\n+    if (x .eq. 0) y = '0'\n+    if (x .eq. 1) y = '1'\n+    if (x .eq. 2) y = '2'\n+    if (x .eq. 3) y = '3'\n+    if (x .eq. 4) y = '4'\n+    if (x .eq. 5) y = '5'\n+    l = l .or. w(7:7) .ne. y\n+    l = l .or. w(19:19) .ne. y\n+    l = l .or. w(26:26) .ne. y\n+    l = l .or. w(38:38) .ne. y\n+    l = l .or. c .ne. w(8:19)\n+    l = l .or. d .ne. w(1:7)\n+    l = l .or. s .ne. w(20:26)\n+    do 103, p = 1, 2\n+      do 103, q = 3, 7\n+\tdo 103, r = 1, 7\n+\t  if (q .lt. 6) l = l .or. e(p, q, r) .ne. 5 * x + p + q + 2 * r\n+\t  l = l .or. f(p, q, r) .ne. 25 * x + p + q + 2 * r\n+\t  if (r .lt. 6 .and. q + r .le. 8) l = l .or. g(r, q) .ne. w(8:19)\n+\t  if (r .lt. 6 .and. q + r .gt. 8) l = l .or. g(r, q) .ne. w(27:38)\n+\t  if (r .lt. 6 .and. q + r .le. 8) l = l .or. h(r, q) .ne. w(1:7)\n+\t  if (r .lt. 6 .and. q + r .gt. 8) l = l .or. h(r, q) .ne. w(20:26)\n+\t  if (q .lt. 6) l = l .or. t(p, q, r) .ne. -10 + x + p - q + 2 * r\n+\t  l = l .or. u(p, q, r) .ne. 30 - x - p + q - 2 * r\n+\t  if (r .lt. 6 .and. q + r .le. 8) l = l .or. v(r, q) .ne. w(1:7)\n+\t  if (r .lt. 6 .and. q + r .gt. 8) l = l .or. v(r, q) .ne. w(20:26)\n+103 continue\n+    do 104, p = 3, 5\n+      do 104, q = 2, 6\n+\tdo 104, r = 1, 7\n+\t  l = l .or. i(p - 2, q - 1, r) .ne. (7.5 + x) * p * q * r\n+\t  l = l .or. j(p, q + 3, r + 6) .ne. (9.5 + x) * p * q * r\n+104 continue\n+    do 105, p = 1, 5\n+      do 105, q = 4, 6\n+\tl = l .or. k(p, 1, q - 3) .ne. 19 + x + p + 7 + 3 * q\n+105 continue\n+    call check (size (e, 1), 2, l)\n+    call check (size (e, 2), 3, l)\n+    call check (size (e, 3), 7, l)\n+    call check (size (e), 42, l)\n+    call check (size (f, 1), 2, l)\n+    call check (size (f, 2), 5, l)\n+    call check (size (f, 3), 7, l)\n+    call check (size (f), 70, l)\n+    call check (size (g, 1), 5, l)\n+    call check (size (g, 2), 5, l)\n+    call check (size (g), 25, l)\n+    call check (size (h, 1), 5, l)\n+    call check (size (h, 2), 5, l)\n+    call check (size (h), 25, l)\n+    call check (size (i, 1), 3, l)\n+    call check (size (i, 2), 5, l)\n+    call check (size (i, 3), 7, l)\n+    call check (size (i), 105, l)\n+    call check (size (j, 1), 4, l)\n+    call check (size (j, 2), 5, l)\n+    call check (size (j, 3), 7, l)\n+    call check (size (j), 140, l)\n+    call check (size (k, 1), 5, l)\n+    call check (size (k, 2), 1, l)\n+    call check (size (k, 3), 3, l)\n+    call check (size (k), 15, l)\n+110 continue\n+!$omp end parallel do\n+    if (l) call abort\n+    if (z2 == 6) then\n+      x = 5\n+      w = 'thread5thr_number_5THREAD5THR_NUMBER_5'\n+      y = '5'\n+      l = l .or. w(7:7) .ne. y\n+      l = l .or. w(19:19) .ne. y\n+      l = l .or. w(26:26) .ne. y\n+      l = l .or. w(38:38) .ne. y\n+      l = l .or. c .ne. w(8:19)\n+      l = l .or. d .ne. w(1:7)\n+      l = l .or. s .ne. w(20:26)\n+      do 113, p = 1, 2\n+\tdo 113, q = 3, 7\n+\t  do 113, r = 1, 7\n+\t    if (q .lt. 6) l = l .or. e(p, q, r) .ne. 5 * x + p + q + 2 * r\n+\t    l = l .or. f(p, q, r) .ne. 25 * x + p + q + 2 * r\n+\t    if (r .lt. 6 .and. q + r .le. 8) l = l .or. g(r, q) .ne. w(8:19)\n+\t    if (r .lt. 6 .and. q + r .gt. 8) l = l .or. g(r, q) .ne. w(27:38)\n+\t    if (r .lt. 6 .and. q + r .le. 8) l = l .or. h(r, q) .ne. w(1:7)\n+\t    if (r .lt. 6 .and. q + r .gt. 8) l = l .or. h(r, q) .ne. w(20:26)\n+\t    if (q .lt. 6) l = l .or. t(p, q, r) .ne. -10 + x + p - q + 2 * r\n+\t    l = l .or. u(p, q, r) .ne. 30 - x - p + q - 2 * r\n+\t    if (r .lt. 6 .and. q + r .le. 8) l = l .or. v(r, q) .ne. w(1:7)\n+\t    if (r .lt. 6 .and. q + r .gt. 8) l = l .or. v(r, q) .ne. w(20:26)\n+113   continue\n+      do 114, p = 3, 5\n+\tdo 114, q = 2, 6\n+\t  do 114, r = 1, 7\n+\t    l = l .or. i(p - 2, q - 1, r) .ne. (7.5 + x) * p * q * r\n+\t    l = l .or. j(p, q + 3, r + 6) .ne. (9.5 + x) * p * q * r\n+114   continue\n+      do 115, p = 1, 5\n+\tdo 115, q = 4, 6\n+\t  l = l .or. k(p, 1, q - 3) .ne. 19 + x + p + 7 + 3 * q\n+115   continue\n+      if (l) call abort\n+    end if\n+  end subroutine foo\n+\n+  subroutine test\n+    character (len = 12) :: c\n+    character (len = 7) :: d\n+    integer, dimension (2, 3:5, 7) :: e\n+    integer, dimension (2, 3:7, 7) :: f\n+    character (len = 12), dimension (5, 3:7) :: g\n+    character (len = 7), dimension (5, 3:7) :: h\n+    real, dimension (3:5, 2:6, 1:7) :: i\n+    double precision, dimension (3:6, 2:6, 1:7) :: j\n+    integer, dimension (1:5, 7:7, 4:6) :: k\n+    integer :: p, q, r\n+    c = 'abcdefghijkl'\n+    d = 'ABCDEFG'\n+    forall (p = 1:2, q = 3:5, r = 1:7) e(p, q, r) = 5 + p + q + 2 * r\n+    forall (p = 1:2, q = 3:7, r = 1:7) f(p, q, r) = 25 + p + q + 2 * r\n+    forall (p = 1:5, q = 3:7, p + q .le. 8) g(p, q) = '0123456789AB'\n+    forall (p = 1:5, q = 3:7, p + q .gt. 8) g(p, q) = '9876543210ZY'\n+    forall (p = 1:5, q = 3:7, p + q .le. 8) h(p, q) = '0123456'\n+    forall (p = 1:5, q = 3:7, p + q .gt. 8) h(p, q) = '9876543'\n+    forall (p = 3:5, q = 2:6, r = 1:7) i(p, q, r) = 7.5 * p * q * r\n+    forall (p = 3:6, q = 2:6, r = 1:7) j(p, q, r) = 9.5 * p * q * r\n+    forall (p = 1:5, q = 7:7, r = 4:6) k(p, q, r) = 19 + p + q + 3 * r\n+    call foo (c, d, e, f, g, h, i, j, k, 7)\n+  end subroutine test\n+end"}, {"sha": "bb9c4916d40f3ce1cfda9af18e173227f4e375b6", "filename": "libgomp/testsuite/libgomp.fortran/vla6.f90", "status": "added", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fvla6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fvla6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fvla6.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,191 @@\n+! { dg-do run }\n+\n+  call test\n+contains\n+  subroutine check (x, y, l)\n+    integer :: x, y\n+    logical :: l\n+    l = l .or. x .ne. y\n+  end subroutine check\n+\n+  subroutine foo (c, d, e, f, g, h, i, j, k, n)\n+    use omp_lib\n+    integer :: n\n+    character (len = *) :: c\n+    character (len = n) :: d\n+    integer, dimension (2, 3:5, n) :: e\n+    integer, dimension (2, 3:n, n) :: f\n+    character (len = *), dimension (5, 3:n) :: g\n+    character (len = n), dimension (5, 3:n) :: h\n+    real, dimension (:, :, :) :: i\n+    double precision, dimension (3:, 5:, 7:) :: j\n+    integer, dimension (:, :, :) :: k\n+    logical :: l\n+    integer :: p, q, r\n+    character (len = n) :: s\n+    integer, dimension (2, 3:5, n) :: t\n+    integer, dimension (2, 3:n, n) :: u\n+    character (len = n), dimension (5, 3:n) :: v\n+    character (len = 2 * n + 24) :: w\n+    integer :: x, z\n+    character (len = 1) :: y\n+    l = .false.\n+!$omp parallel default (none) private (c, d, e, f, g, h, i, j, k) &\n+!$omp & private (s, t, u, v) reduction (.or.:l) num_threads (6) &\n+!$omp private (p, q, r, w, x, y) shared (z)\n+    x = omp_get_thread_num ()\n+    w = ''\n+    if (x .eq. 0) w = 'thread0thr_number_0THREAD0THR_NUMBER_0'\n+    if (x .eq. 1) w = 'thread1thr_number_1THREAD1THR_NUMBER_1'\n+    if (x .eq. 2) w = 'thread2thr_number_2THREAD2THR_NUMBER_2'\n+    if (x .eq. 3) w = 'thread3thr_number_3THREAD3THR_NUMBER_3'\n+    if (x .eq. 4) w = 'thread4thr_number_4THREAD4THR_NUMBER_4'\n+    if (x .eq. 5) w = 'thread5thr_number_5THREAD5THR_NUMBER_5'\n+    c = w(8:19)\n+    d = w(1:7)\n+    forall (p = 1:2, q = 3:5, r = 1:7) e(p, q, r) = 5 * x + p + q + 2 * r\n+    forall (p = 1:2, q = 3:7, r = 1:7) f(p, q, r) = 25 * x + p + q + 2 * r\n+    forall (p = 1:5, q = 3:7, p + q .le. 8) g(p, q) = w(8:19)\n+    forall (p = 1:5, q = 3:7, p + q .gt. 8) g(p, q) = w(27:38)\n+    forall (p = 1:5, q = 3:7, p + q .le. 8) h(p, q) = w(1:7)\n+    forall (p = 1:5, q = 3:7, p + q .gt. 8) h(p, q) = w(20:26)\n+    forall (p = 3:5, q = 2:6, r = 1:7) i(p - 2, q - 1, r) = (7.5 + x) * p * q * r\n+    forall (p = 3:5, q = 2:6, r = 1:7) j(p, q + 3, r + 6) = (9.5 + x) * p * q * r\n+    forall (p = 1:5, q = 7:7, r = 4:6) k(p, q - 6, r - 3) = 19 + x + p + q + 3 * r\n+    s = w(20:26)\n+    forall (p = 1:2, q = 3:5, r = 1:7) t(p, q, r) = -10 + x + p - q + 2 * r\n+    forall (p = 1:2, q = 3:7, r = 1:7) u(p, q, r) = 30 - x - p + q - 2 * r\n+    forall (p = 1:5, q = 3:7, p + q .le. 8) v(p, q) = w(1:7)\n+    forall (p = 1:5, q = 3:7, p + q .gt. 8) v(p, q) = w(20:26)\n+!$omp barrier\n+    y = ''\n+    if (x .eq. 0) y = '0'\n+    if (x .eq. 1) y = '1'\n+    if (x .eq. 2) y = '2'\n+    if (x .eq. 3) y = '3'\n+    if (x .eq. 4) y = '4'\n+    if (x .eq. 5) y = '5'\n+    l = l .or. w(7:7) .ne. y\n+    l = l .or. w(19:19) .ne. y\n+    l = l .or. w(26:26) .ne. y\n+    l = l .or. w(38:38) .ne. y\n+    l = l .or. c .ne. w(8:19)\n+    l = l .or. d .ne. w(1:7)\n+    l = l .or. s .ne. w(20:26)\n+    do 103, p = 1, 2\n+      do 103, q = 3, 7\n+\tdo 103, r = 1, 7\n+\t  if (q .lt. 6) l = l .or. e(p, q, r) .ne. 5 * x + p + q + 2 * r\n+\t  l = l .or. f(p, q, r) .ne. 25 * x + p + q + 2 * r\n+\t  if (r .lt. 6 .and. q + r .le. 8) l = l .or. g(r, q) .ne. w(8:19)\n+\t  if (r .lt. 6 .and. q + r .gt. 8) l = l .or. g(r, q) .ne. w(27:38)\n+\t  if (r .lt. 6 .and. q + r .le. 8) l = l .or. h(r, q) .ne. w(1:7)\n+\t  if (r .lt. 6 .and. q + r .gt. 8) l = l .or. h(r, q) .ne. w(20:26)\n+\t  if (q .lt. 6) l = l .or. t(p, q, r) .ne. -10 + x + p - q + 2 * r\n+\t  l = l .or. u(p, q, r) .ne. 30 - x - p + q - 2 * r\n+\t  if (r .lt. 6 .and. q + r .le. 8) l = l .or. v(r, q) .ne. w(1:7)\n+\t  if (r .lt. 6 .and. q + r .gt. 8) l = l .or. v(r, q) .ne. w(20:26)\n+103 continue\n+    do 104, p = 3, 5\n+      do 104, q = 2, 6\n+\tdo 104, r = 1, 7\n+\t  l = l .or. i(p - 2, q - 1, r) .ne. (7.5 + x) * p * q * r\n+\t  l = l .or. j(p, q + 3, r + 6) .ne. (9.5 + x) * p * q * r\n+104 continue\n+    do 105, p = 1, 5\n+      do 105, q = 4, 6\n+\tl = l .or. k(p, 1, q - 3) .ne. 19 + x + p + 7 + 3 * q\n+105 continue\n+    call check (size (e, 1), 2, l)\n+    call check (size (e, 2), 3, l)\n+    call check (size (e, 3), 7, l)\n+    call check (size (e), 42, l)\n+    call check (size (f, 1), 2, l)\n+    call check (size (f, 2), 5, l)\n+    call check (size (f, 3), 7, l)\n+    call check (size (f), 70, l)\n+    call check (size (g, 1), 5, l)\n+    call check (size (g, 2), 5, l)\n+    call check (size (g), 25, l)\n+    call check (size (h, 1), 5, l)\n+    call check (size (h, 2), 5, l)\n+    call check (size (h), 25, l)\n+    call check (size (i, 1), 3, l)\n+    call check (size (i, 2), 5, l)\n+    call check (size (i, 3), 7, l)\n+    call check (size (i), 105, l)\n+    call check (size (j, 1), 4, l)\n+    call check (size (j, 2), 5, l)\n+    call check (size (j, 3), 7, l)\n+    call check (size (j), 140, l)\n+    call check (size (k, 1), 5, l)\n+    call check (size (k, 2), 1, l)\n+    call check (size (k, 3), 3, l)\n+    call check (size (k), 15, l)\n+!$omp single\n+    z = omp_get_thread_num ()\n+!$omp end single copyprivate (c, d, e, f, g, h, i, j, k, s, t, u, v)\n+    w = ''\n+    x = z\n+    if (x .eq. 0) w = 'thread0thr_number_0THREAD0THR_NUMBER_0'\n+    if (x .eq. 1) w = 'thread1thr_number_1THREAD1THR_NUMBER_1'\n+    if (x .eq. 2) w = 'thread2thr_number_2THREAD2THR_NUMBER_2'\n+    if (x .eq. 3) w = 'thread3thr_number_3THREAD3THR_NUMBER_3'\n+    if (x .eq. 4) w = 'thread4thr_number_4THREAD4THR_NUMBER_4'\n+    if (x .eq. 5) w = 'thread5thr_number_5THREAD5THR_NUMBER_5'\n+    y = ''\n+    if (x .eq. 0) y = '0'\n+    if (x .eq. 1) y = '1'\n+    if (x .eq. 2) y = '2'\n+    if (x .eq. 3) y = '3'\n+    if (x .eq. 4) y = '4'\n+    if (x .eq. 5) y = '5'\n+    l = l .or. w(7:7) .ne. y\n+    l = l .or. w(19:19) .ne. y\n+    l = l .or. w(26:26) .ne. y\n+    l = l .or. w(38:38) .ne. y\n+    l = l .or. c .ne. w(8:19)\n+    l = l .or. d .ne. w(1:7)\n+    l = l .or. s .ne. w(20:26)\n+    do 113, p = 1, 2\n+      do 113, q = 3, 7\n+\tdo 113, r = 1, 7\n+\t  if (q .lt. 6) l = l .or. e(p, q, r) .ne. 5 * x + p + q + 2 * r\n+\t  l = l .or. f(p, q, r) .ne. 25 * x + p + q + 2 * r\n+\t  if (r .lt. 6 .and. q + r .le. 8) l = l .or. g(r, q) .ne. w(8:19)\n+\t  if (r .lt. 6 .and. q + r .gt. 8) l = l .or. g(r, q) .ne. w(27:38)\n+\t  if (r .lt. 6 .and. q + r .le. 8) l = l .or. h(r, q) .ne. w(1:7)\n+\t  if (r .lt. 6 .and. q + r .gt. 8) l = l .or. h(r, q) .ne. w(20:26)\n+\t  if (q .lt. 6) l = l .or. t(p, q, r) .ne. -10 + x + p - q + 2 * r\n+\t  l = l .or. u(p, q, r) .ne. 30 - x - p + q - 2 * r\n+\t  if (r .lt. 6 .and. q + r .le. 8) l = l .or. v(r, q) .ne. w(1:7)\n+\t  if (r .lt. 6 .and. q + r .gt. 8) l = l .or. v(r, q) .ne. w(20:26)\n+113 continue\n+    do 114, p = 3, 5\n+      do 114, q = 2, 6\n+\tdo 114, r = 1, 7\n+\t  l = l .or. i(p - 2, q - 1, r) .ne. (7.5 + x) * p * q * r\n+\t  l = l .or. j(p, q + 3, r + 6) .ne. (9.5 + x) * p * q * r\n+114 continue\n+    do 115, p = 1, 5\n+      do 115, q = 4, 6\n+\tl = l .or. k(p, 1, q - 3) .ne. 19 + x + p + 7 + 3 * q\n+115 continue\n+!$omp end parallel\n+    if (l) call abort\n+  end subroutine foo\n+\n+  subroutine test\n+    character (len = 12) :: c\n+    character (len = 7) :: d\n+    integer, dimension (2, 3:5, 7) :: e\n+    integer, dimension (2, 3:7, 7) :: f\n+    character (len = 12), dimension (5, 3:7) :: g\n+    character (len = 7), dimension (5, 3:7) :: h\n+    real, dimension (3:5, 2:6, 1:7) :: i\n+    double precision, dimension (3:6, 2:6, 1:7) :: j\n+    integer, dimension (1:5, 7:7, 4:6) :: k\n+    integer :: p, q, r\n+    call foo (c, d, e, f, g, h, i, j, k, 7)\n+  end subroutine test\n+end"}, {"sha": "29a6696443a8b16ec6518e41a9f7d4ca75da32e4", "filename": "libgomp/testsuite/libgomp.fortran/vla7.f90", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fvla7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fvla7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fvla7.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,143 @@\n+! { dg-do run }\n+! { dg-options \"-w\" }\n+\n+  character (6) :: c, f2\n+  character (6) :: d(2)\n+  c = f1 (6)\n+  if (c .ne. 'opqrst') call abort\n+  c = f2 (6)\n+  if (c .ne. '_/!!/_') call abort\n+  d = f3 (6)\n+  if (d(1) .ne. 'opqrst' .or. d(2) .ne. 'a') call abort\n+  d = f4 (6)\n+  if (d(1) .ne. 'Opqrst' .or. d(2) .ne. 'A') call abort\n+contains\n+  function f1 (n)\n+    use omp_lib\n+    character (n) :: f1\n+    logical :: l\n+    f1 = 'abcdef'\n+    l = .false.\n+!$omp parallel firstprivate (f1) reduction (.or.:l) num_threads (2)\n+    l = f1 .ne. 'abcdef'\n+    if (omp_get_thread_num () .eq. 0) f1 = 'ijklmn'\n+    if (omp_get_thread_num () .eq. 1) f1 = 'IJKLMN'\n+!$omp barrier\n+    l = l .or. (omp_get_thread_num () .eq. 0 .and. f1 .ne. 'ijklmn')\n+    l = l .or. (omp_get_thread_num () .eq. 1 .and. f1 .ne. 'IJKLMN')\n+!$omp end parallel\n+    f1 = 'zZzz_z'\n+!$omp parallel shared (f1) reduction (.or.:l) num_threads (2)\n+    l = l .or. f1 .ne. 'zZzz_z'\n+!$omp barrier\n+!$omp master\n+    f1 = 'abc'\n+!$omp end master\n+!$omp barrier\n+    l = l .or. f1 .ne. 'abc'\n+!$omp barrier\n+    if (omp_get_thread_num () .eq. 1) f1 = 'def'\n+!$omp barrier\n+    l = l .or. f1 .ne. 'def'\n+!$omp end parallel\n+    if (l) call abort\n+    f1 = 'opqrst'\n+  end function f1\n+  function f3 (n)\n+    use omp_lib\n+    character (n), dimension (2) :: f3\n+    logical :: l\n+    f3 = 'abcdef'\n+    l = .false.\n+!$omp parallel firstprivate (f3) reduction (.or.:l) num_threads (2)\n+    l = any (f3 .ne. 'abcdef')\n+    if (omp_get_thread_num () .eq. 0) f3 = 'ijklmn'\n+    if (omp_get_thread_num () .eq. 1) f3 = 'IJKLMN'\n+!$omp barrier\n+    l = l .or. (omp_get_thread_num () .eq. 0 .and. any (f3 .ne. 'ijklmn'))\n+    l = l .or. (omp_get_thread_num () .eq. 1 .and. any (f3 .ne. 'IJKLMN'))\n+!$omp end parallel\n+    f3 = 'zZzz_z'\n+!$omp parallel shared (f3) reduction (.or.:l) num_threads (2)\n+    l = l .or. any (f3 .ne. 'zZzz_z')\n+!$omp barrier\n+!$omp master\n+    f3 = 'abc'\n+!$omp end master\n+!$omp barrier\n+    l = l .or. any (f3 .ne. 'abc')\n+!$omp barrier\n+    if (omp_get_thread_num () .eq. 1) f3 = 'def'\n+!$omp barrier\n+    l = l .or. any (f3 .ne. 'def')\n+!$omp end parallel\n+    if (l) call abort\n+    f3(1) = 'opqrst'\n+    f3(2) = 'a'\n+  end function f3\n+  function f4 (n)\n+    use omp_lib\n+    character (n), dimension (n - 4) :: f4\n+    logical :: l\n+    f4 = 'abcdef'\n+    l = .false.\n+!$omp parallel firstprivate (f4) reduction (.or.:l) num_threads (2)\n+    l = any (f4 .ne. 'abcdef')\n+    if (omp_get_thread_num () .eq. 0) f4 = 'ijklmn'\n+    if (omp_get_thread_num () .eq. 1) f4 = 'IJKLMN'\n+!$omp barrier\n+    l = l .or. (omp_get_thread_num () .eq. 0 .and. any (f4 .ne. 'ijklmn'))\n+    l = l .or. (omp_get_thread_num () .eq. 1 .and. any (f4 .ne. 'IJKLMN'))\n+    l = l .or. size (f4) .ne. 2\n+!$omp end parallel\n+    f4 = 'zZzz_z'\n+!$omp parallel shared (f4) reduction (.or.:l) num_threads (2)\n+    l = l .or. any (f4 .ne. 'zZzz_z')\n+!$omp barrier\n+!$omp master\n+    f4 = 'abc'\n+!$omp end master\n+!$omp barrier\n+    l = l .or. any (f4 .ne. 'abc')\n+!$omp barrier\n+    if (omp_get_thread_num () .eq. 1) f4 = 'def'\n+!$omp barrier\n+    l = l .or. any (f4 .ne. 'def')\n+    l = l .or. size (f4) .ne. 2\n+!$omp end parallel\n+    if (l) call abort\n+    f4(1) = 'Opqrst'\n+    f4(2) = 'A'\n+  end function f4\n+end\n+function f2 (n)\n+  use omp_lib\n+  character (*) :: f2\n+  logical :: l\n+  f2 = 'abcdef'\n+  l = .false.\n+!$omp parallel firstprivate (f2) reduction (.or.:l) num_threads (2)\n+  l = f2 .ne. 'abcdef'\n+  if (omp_get_thread_num () .eq. 0) f2 = 'ijklmn'\n+  if (omp_get_thread_num () .eq. 1) f2 = 'IJKLMN'\n+!$omp barrier\n+  l = l .or. (omp_get_thread_num () .eq. 0 .and. f2 .ne. 'ijklmn')\n+  l = l .or. (omp_get_thread_num () .eq. 1 .and. f2 .ne. 'IJKLMN')\n+!$omp end parallel\n+  f2 = 'zZzz_z'\n+!$omp parallel shared (f2) reduction (.or.:l) num_threads (2)\n+  l = l .or. f2 .ne. 'zZzz_z'\n+!$omp barrier\n+!$omp master\n+  f2 = 'abc'\n+!$omp end master\n+!$omp barrier\n+  l = l .or. f2 .ne. 'abc'\n+!$omp barrier\n+  if (omp_get_thread_num () .eq. 1) f2 = 'def'\n+!$omp barrier\n+  l = l .or. f2 .ne. 'def'\n+!$omp end parallel\n+  if (l) call abort\n+  f2 = '_/!!/_'\n+end function f2"}, {"sha": "a0e6ff919e517c29cd9989a5ce51d610833b6424", "filename": "libgomp/testsuite/libgomp.fortran/workshare1.f90", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fworkshare1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7a4dfdb63246a89869089cbafef03d157c5c56/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fworkshare1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fworkshare1.f90?ref=6c7a4dfdb63246a89869089cbafef03d157c5c56", "patch": "@@ -0,0 +1,30 @@\n+function foo ()\n+  integer :: foo\n+  logical :: foo_seen\n+  common /foo_seen/ foo_seen\n+  foo_seen = .true.\n+  foo = 3\n+end\n+function bar ()\n+  integer :: bar\n+  logical :: bar_seen\n+  common /bar_seen/ bar_seen\n+  bar_seen = .true.\n+  bar = 3\n+end\n+  integer :: a (10), b (10), foo, bar\n+  logical :: foo_seen, bar_seen\n+  common /foo_seen/ foo_seen\n+  common /bar_seen/ bar_seen\n+\n+  foo_seen = .false.\n+  bar_seen = .false.\n+!$omp parallel workshare if (foo () .gt. 2) num_threads (bar () + 1)\n+  a = 10\n+  b = 20\n+  a(1:5) = max (a(1:5), b(1:5))\n+!$omp end parallel workshare\n+  if (any (a(1:5) .ne. 20)) call abort\n+  if (any (a(6:10) .ne. 10)) call abort\n+  if (.not. foo_seen .or. .not. bar_seen) call abort\n+end"}]}