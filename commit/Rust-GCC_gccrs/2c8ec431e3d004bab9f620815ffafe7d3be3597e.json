{"sha": "2c8ec431e3d004bab9f620815ffafe7d3be3597e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmM4ZWM0MzFlM2QwMDRiYWI5ZjYyMDgxNWZmYWZlN2QzYmUzNTk3ZQ==", "commit": {"author": {"name": "Don Lindsay", "email": "dlindsay@cygnus.com", "date": "1999-06-17T15:09:47Z"}, "committer": {"name": "Don Lindsay", "email": "dlindsay@gcc.gnu.org", "date": "1999-06-17T15:09:47Z"}, "message": "Added -mpcrel flag, and underlying support for PC-relative addressing on m68k.\n\nh\nAdded -mpcrel flag, and underlying support for PC-relative addressing\non m68k. Patch is tested, and approved by Jim Wilson.\n\nFrom-SVN: r27576", "tree": {"sha": "2dcfc57a63ac1ac16c4f9a4c78bb79ef0a1a5b64", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2dcfc57a63ac1ac16c4f9a4c78bb79ef0a1a5b64"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c8ec431e3d004bab9f620815ffafe7d3be3597e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c8ec431e3d004bab9f620815ffafe7d3be3597e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c8ec431e3d004bab9f620815ffafe7d3be3597e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c8ec431e3d004bab9f620815ffafe7d3be3597e/comments", "author": null, "committer": null, "parents": [{"sha": "fb8684745d6485ed60a4e88d0b2a8fc8b4d4acfa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb8684745d6485ed60a4e88d0b2a8fc8b4d4acfa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb8684745d6485ed60a4e88d0b2a8fc8b4d4acfa"}], "stats": {"total": 535, "additions": 425, "deletions": 110}, "files": [{"sha": "b27735919625f56942369cd86408232d57449a47", "filename": "ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c8ec431e3d004bab9f620815ffafe7d3be3597e/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c8ec431e3d004bab9f620815ffafe7d3be3597e/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=2c8ec431e3d004bab9f620815ffafe7d3be3597e", "patch": "@@ -1,3 +1,46 @@\n+Thu Jun 17 15:06:10 PDT 1999 Don Lindsay  <dlindsay@cygnus.com>\n+\n+        * added support for -mpcrel (PC relative addressing for m68k) \n+\tbased on code done by Michael Tiemann  <tiemann@axon.cygnus.com>.\n+\t* invoke.texi (m68000 options): Add documentation for -mpcrel flag.\n+\t* m68k.c (print_operand_address): Handle 32-bit PIC case.\n+\t(comments for general_src_operand): Add some explanation\n+\tabout EXTRA_CONSTRAINTS.\n+\t(OVERRIDE_OPTIONS): Enable -fPIC in combination with -mpcrel.\n+\t* m68kelf.h (OVERRIDE_OPTIONS): Ditto.\n+\t(LEGITIMATE_PIC_OPERAND_P): Fix typo.\n+\t(LEGITIMATE_PIC_OPERAND_P): Re-derive from m68k.h case.\n+\t* m68k.h (LEGITIMATE_PIC_OPERAND_P): Fix delete-o.\n+\t(INDIRECTABLE_1_ADDRESS): Delete spurious '/' at end of macro.\n+\t(OVERRIDE_OPTIONS): Change behavior so that -mpcrel implies -fpic\n+\tif not already set.\n+\t(OVERRIDE_OPTIONS): Merge in changes from m68k.h.\n+\t* m68k.h (TARGET_PCREL): New target flag.\n+\t(TARGET_SWITCHES): Add \"pcrel\" as a recognized switch.\n+\t(OVERRIDE_OPTIONS): Add checks for -mpcrel.\n+\t(LEGITIMATE_PIC_OPERAND_P): Don't normally accept anything that\n+\tcontains a SYMBOL_REF.  Relax this constraint during reload, since\n+\twe want to use the predicates, not reload's built-in concept of a\n+\tvalid memory address, to control what insns need reloading.\n+\t(EXTRA_CONSTRAINT): Define constraints to accept pc-relative\n+\toperands (essentially 'g', 'm', and 's' under normal circumstances).\n+\t* m68k.c (print_operand): Cause printing of pc-relative addresses\n+ \tto include pc register.\n+\t(print_operand_address): Ditto.\n+\t(general_src_operand): Accept operands that are not only\n+\tgeneral_operands, but are also valid when used as a pc-relative\n+\tsource.\n+\t(nonimmediate_src_operand): Similar, for nonimmediate_operands.\n+\t(memory_src_operand): Similar, for memory_operands.\n+\t(pcrel_address): New predicate to accept the special case of a\n+\tpc-relative address.\n+\t* m68k.md (many patterns): Rewrite common SImode, HImode, and\n+\tQImode insns to accept *_src_operand instead of *_operand where\n+\tpc-relative operands can fit.  For example, a pc-relative operand\n+\tcan be used as a memory source operand for addsi3, but not as a\n+\tmemory destination.\n+\t* hp320.h linux.h m68kv4.h (LEGITIMATE_PIC_OPERAND_P) as in m68k.h.\n+\n Sun May 30 16:03:16 1999  Cort Dougan  <cort@cs.nmt.edu>\n \n \t* config.guess (ppc-*-linux-gnu): Also use ld emul elf32ppclinux."}, {"sha": "977812e65a80f32a10a098dd163ec3da36f9d1a2", "filename": "gcc/config/m68k/hp320.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c8ec431e3d004bab9f620815ffafe7d3be3597e/gcc%2Fconfig%2Fm68k%2Fhp320.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c8ec431e3d004bab9f620815ffafe7d3be3597e/gcc%2Fconfig%2Fm68k%2Fhp320.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fhp320.h?ref=2c8ec431e3d004bab9f620815ffafe7d3be3597e", "patch": "@@ -635,7 +635,8 @@ do { register int i;\t\t\t\\\n     && ! (GET_CODE (X) == CONST_DOUBLE && CONST_DOUBLE_MEM (X)\t\\\n \t  && GET_CODE (CONST_DOUBLE_MEM (X)) == MEM\t\t\\\n \t  && symbolic_operand (XEXP (CONST_DOUBLE_MEM (X), 0), VOIDmode))) \\\n-   || (GET_CODE (X) == SYMBOL_REF && SYMBOL_REF_FLAG (X)))\n+   || (GET_CODE (X) == SYMBOL_REF && SYMBOL_REF_FLAG (X))       \\\n+   || PCREL_GENERAL_OPERAND_OK)\n \n /* hpux8 and later have C++ compatible include files, so do not\n    pretend they are `extern \"C\"'.  */"}, {"sha": "a1a4fffbb20da6cb277fd74258b6c95afa5d4f10", "filename": "gcc/config/m68k/linux.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c8ec431e3d004bab9f620815ffafe7d3be3597e/gcc%2Fconfig%2Fm68k%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c8ec431e3d004bab9f620815ffafe7d3be3597e/gcc%2Fconfig%2Fm68k%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Flinux.h?ref=2c8ec431e3d004bab9f620815ffafe7d3be3597e", "patch": "@@ -310,7 +310,8 @@ do {\t\t\t\t\t\t\t\t\t\\\n     && ! (GET_CODE (X) == CONST_DOUBLE && CONST_DOUBLE_MEM (X)\t\\\n \t  && GET_CODE (CONST_DOUBLE_MEM (X)) == MEM\t\t\\\n \t  && symbolic_operand (XEXP (CONST_DOUBLE_MEM (X), 0), VOIDmode))) \\\n-   || (GET_CODE (X) == SYMBOL_REF && SYMBOL_REF_FLAG (X)))\n+   || (GET_CODE (X) == SYMBOL_REF && SYMBOL_REF_FLAG (X))       \\\n+   || PCREL_GENERAL_OPERAND_OK)\n \n /* Turn off function cse if we are doing PIC. We always want function\n    call to be done as `bsr foo@PLTPC', so it will force the assembler"}, {"sha": "2d2028b8caaa0b57c1afd8a9432f3d1032f6cb7f", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 161, "deletions": 2, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c8ec431e3d004bab9f620815ffafe7d3be3597e/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c8ec431e3d004bab9f620815ffafe7d3be3597e/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=2c8ec431e3d004bab9f620815ffafe7d3be3597e", "patch": "@@ -54,6 +54,7 @@ int switch_table_difference_label_flag;\n \n static rtx find_addr_reg ();\n rtx legitimize_pic_address ();\n+void print_operand_address ();\n \f\n \n /* Alignment to use for loops and jumps */\n@@ -2717,6 +2718,8 @@ standard_sun_fpa_constant_p (x)\n    'b' for byte insn (no effect, on the Sun; this is for the ISI).\n    'd' to force memory addressing to be absolute, not relative.\n    'f' for float insn (print a CONST_DOUBLE as a float rather than in hex)\n+   'o' for operands to go directly to output_operand_address (bypassing\n+       print_operand_address--used only for SYMBOL_REFs under TARGET_PCREL)\n    'w' for FPA insn (print a CONST_DOUBLE as a SunFPA constant rather\n        than directly).  Second part of 'y' below.\n    'x' for float insn (print a CONST_DOUBLE as a float rather than in hex),\n@@ -2793,6 +2796,14 @@ print_operand (file, op, letter)\n     {\n       asm_fprintf (file, \"%R\");\n     }\n+  else if (letter == 'o')\n+    {\n+      /* This is only for direct addresses with TARGET_PCREL */\n+      if (GET_CODE (op) != MEM || GET_CODE (XEXP (op, 0)) != SYMBOL_REF\n+          || !TARGET_PCREL) \n+\tabort ();\n+      output_addr_const (file, XEXP (op, 0));\n+    }\n   else if (GET_CODE (op) == REG)\n     {\n #ifdef SUPPORT_SUN_FPA\n@@ -2858,7 +2869,14 @@ print_operand (file, op, letter)\n     }\n   else\n     {\n-      asm_fprintf (file, \"%0I\"); output_addr_const (file, op);\n+      /* Use `print_operand_address' instead of `output_addr_const'\n+\t to ensure that we print relevant PIC stuff.  */\n+      asm_fprintf (file, \"%0I\");\n+      if (TARGET_PCREL\n+\t  && (GET_CODE (op) == SYMBOL_REF || GET_CODE (op) == CONST))\n+\tprint_operand_address (file, op);\n+      else\n+\toutput_addr_const (file, op);\n     }\n }\n \n@@ -3159,7 +3177,7 @@ print_operand_address (file, addr)\n \t    fprintf (file, \"l)\");\n \t    break;\n \t  }\n-\t/* FALL-THROUGH (is this really what we want? */\n+\t/* FALL-THROUGH (is this really what we want?)  */\n       default:\n         if (GET_CODE (addr) == CONST_INT\n \t    && INTVAL (addr) < 0x8000\n@@ -3176,6 +3194,25 @@ print_operand_address (file, addr)\n \t    fprintf (file, \"%d:w\", INTVAL (addr));\n #endif\n \t  }\n+\telse if (GET_CODE (addr) == CONST_INT)\n+\t  {\n+\t    fprintf (file,\n+#if HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_INT\n+\t\t     \"%d\",\n+#else\n+\t\t     \"%ld\",\n+#endif\n+\t\t     INTVAL (addr));\n+\t  }\n+\telse if (TARGET_PCREL)\n+\t  {\n+\t    fputc ('(', file);\n+\t    output_addr_const (file, addr);\n+\t    if (flag_pic == 1)\n+\t      asm_fprintf (file, \":w,%Rpc)\");\n+\t    else\n+\t      asm_fprintf (file, \":l,%Rpc)\");\n+\t  }\n \telse\n \t  {\n \t    /* Special case for SYMBOL_REF if the symbol name ends in\n@@ -3288,6 +3325,128 @@ const_sint32_operand (op, mode)\n \t  && (INTVAL (op) >= (-0x7fffffff - 1) && INTVAL (op) <= 0x7fffffff));\n }\n \n+/* Operand predicates for implementing asymmetric pc-relative addressing\n+   on m68k.  The m68k supports pc-relative addressing (mode 7, register 2)\n+   when used as a source operand, but not as a destintation operand.\n+\n+   We model this by restricting the meaning of the basic predicates\n+   (general_operand, memory_operand, etc) to forbid the use of this\n+   addressing mode, and then define the following predicates that permit\n+   this addressing mode.  These predicates can then be used for the\n+   source operands of the appropriate instructions.\n+\n+   n.b.  While it is theoretically possible to change all machine patterns\n+   to use this addressing more where permitted by the architecture,\n+   it has only been implemented for \"common\" cases: SImode, HImode, and\n+   QImode operands, and only for the principle operations that would\n+   require this addressing mode: data movement and simple integer operations.\n+\n+   In parallel with these new predicates, two new constraint letters\n+   were defined: 'S' and 'T'.  'S' is the -mpcrel analog of 'm'.\n+   'T' replaces 's' in the non-pcrel case.  It is a no-op in the pcrel case.\n+   In the pcrel case 's' is only valid in combination with 'a' registers.\n+   See addsi3, subsi3, cmpsi, and movsi patterns for a better understanding\n+   of how these constraints are used.\n+\n+   The use of these predicates is strictly optional, though patterns that\n+   don't will cause an extra reload register to be allocated where one\n+   was not necessary:\n+\n+\tlea (abc:w,%pc),%a0\t; need to reload address\n+\tmoveq &1,%d1\t\t; since write to pc-relative space\n+\tmovel %d1,%a0@\t\t; is not allowed\n+\t...\n+\tlea (abc:w,%pc),%a1\t; no need to reload address here\n+\tmovel %a1@,%d0\t\t; since \"movel (abc:w,%pc),%d0\" is ok\n+\n+   For more info, consult tiemann@cygnus.com.\n+\n+\n+   All of the ugliness with predicates and constraints is due to the\n+   simple fact that the m68k does not allow a pc-relative addressing\n+   mode as a destination.  gcc does not distinguish between source and\n+   destination addresses.  Hence, if we claim that pc-relative address\n+   modes are valid, e.g. GO_IF_LEGITIMATE_ADDRESS accepts them, then we\n+   end up with invalid code.  To get around this problem, we left\n+   pc-relative modes as invalid addresses, and then added special\n+   predicates and constraints to accept them.\n+\n+   A cleaner way to handle this is to modify gcc to distinguish\n+   between source and destination addresses.  We can then say that\n+   pc-relative is a valid source address but not a valid destination\n+   address, and hopefully avoid a lot of the predicate and constraint\n+   hackery.  Unfortunately, this would be a pretty big change.  It would\n+   be a useful change for a number of ports, but there aren't any current\n+   plans to undertake this.\n+\n+   ***************************************************************************/\n+\n+\n+/* Special case of a general operand that's used as a source operand.\n+   Use this to permit reads from PC-relative memory when -mpcrel\n+   is specified.  */\n+\n+int\n+general_src_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (TARGET_PCREL\n+      && GET_CODE (op) == MEM\n+      && (GET_CODE (XEXP (op, 0)) == SYMBOL_REF\n+\t  || GET_CODE (XEXP (op, 0)) == LABEL_REF\n+\t  || GET_CODE (XEXP (op, 0)) == CONST))\n+    return 1;\n+  return general_operand (op, mode);\n+}\n+\n+/* Special case of a nonimmediate operand that's used as a source.\n+   Use this to permit reads from PC-relative memory when -mpcrel\n+   is specified.  */\n+\n+int\n+nonimmediate_src_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (TARGET_PCREL && GET_CODE (op) == MEM\n+      && (GET_CODE (XEXP (op, 0)) == SYMBOL_REF\n+\t  || GET_CODE (XEXP (op, 0)) == LABEL_REF\n+\t  || GET_CODE (XEXP (op, 0)) == CONST))\n+    return 1;\n+  return nonimmediate_operand (op, mode);\n+}\n+\n+/* Special case of a memory operand that's used as a source.\n+   Use this to permit reads from PC-relative memory when -mpcrel\n+   is specified.  */\n+\n+int\n+memory_src_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (TARGET_PCREL && GET_CODE (op) == MEM\n+      && (GET_CODE (XEXP (op, 0)) == SYMBOL_REF\n+\t  || GET_CODE (XEXP (op, 0)) == LABEL_REF\n+\t  || GET_CODE (XEXP (op, 0)) == CONST))\n+    return 1;\n+  return memory_operand (op, mode);\n+}\n+\n+/* Predicate that accepts only a pc-relative address.  This is needed\n+   because pc-relative addresses don't satisfy the predicate\n+   \"general_src_operand\".  */\n+\n+int\n+pcrel_address (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (GET_CODE (op) == SYMBOL_REF || GET_CODE (op) == LABEL_REF\n+\t  || GET_CODE (op) == CONST);\n+}\n+\n char *\n output_andsi3 (operands)\n      rtx *operands;"}, {"sha": "83af5901299c6503cb64971fa9460f9659ef8dd0", "filename": "gcc/config/m68k/m68k.h", "status": "modified", "additions": 64, "deletions": 8, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c8ec431e3d004bab9f620815ffafe7d3be3597e/gcc%2Fconfig%2Fm68k%2Fm68k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c8ec431e3d004bab9f620815ffafe7d3be3597e/gcc%2Fconfig%2Fm68k%2Fm68k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.h?ref=2c8ec431e3d004bab9f620815ffafe7d3be3597e", "patch": "@@ -123,6 +123,18 @@ extern int target_flags;\n \t/* A 68020 without bitfields is a good heuristic for a CPU32 */\n #define TARGET_CPU32\t(TARGET_68020 && !TARGET_BITFIELD)\n \n+/* Use PC-relative addressing modes (without using a global offset table).\n+   The m68000 supports 16-bit PC-relative addressing.\n+   The m68020 supports 32-bit PC-relative addressing\n+   (using outer displacements).\n+\n+   Under this model, all SYMBOL_REFs (and CONSTs) and LABEL_REFs are\n+   treated as all containing an implicit PC-relative component, and hence\n+   cannot be used directly as addresses for memory writes.  See the comments\n+   in m68k.c for more information.  */\n+#define MASK_PCREL\t4096\n+#define TARGET_PCREL\t(target_flags & MASK_PCREL)\n+\n /* Macro to define tables used to set the flags.\n    This is a list in braces of pairs in braces,\n    each pair being { \"NAME\", VALUE }\n@@ -181,6 +193,7 @@ extern int target_flags;\n     { \"cpu32\", MASK_68020},\t\t\t\t\t\t\\\n     { \"align-int\", MASK_ALIGN_INT },\t\t\t\t\t\\\n     { \"no-align-int\", -MASK_ALIGN_INT },\t\t\t\t\\\n+    { \"pcrel\", MASK_PCREL},\t\t\t\t\t\t\\\n     SUBTARGET_SWITCHES\t\t\t\t\t\t\t\\\n     { \"\", TARGET_DEFAULT}}\n /* TARGET_DEFAULT is defined in sun*.h and isi.h, etc.  */\n@@ -215,6 +228,8 @@ extern int target_flags;\n   override_options();\t\t\t\\\n   if (! TARGET_68020 && flag_pic == 2)\t\\\n     error(\"-fPIC is not currently supported on the 68000 or 68010\\n\");\t\\\n+  if (TARGET_PCREL && flag_pic == 0)\t\\\n+    flag_pic = 1;\t\t\t\\\n   SUBTARGET_OVERRIDE_OPTIONS;\t\t\\\n }\n \n@@ -760,11 +775,35 @@ extern enum reg_class regno_reg_class[];\n    C.  If C is not defined as an extra constraint, the value returned should \n    be 0 regardless of VALUE.  */\n \n-/* For the m68k, `Q' means address register indirect addressing mode. */\n-\n-#define EXTRA_CONSTRAINT(OP, C)\t\\\n-  ((C) == 'Q' ? (GET_CODE (OP) == MEM && GET_CODE (XEXP (OP, 0)) == REG) : \\\n-   0 )\n+/* Letters in the range `Q' through `U' may be defined in a\n+   machine-dependent fashion to stand for arbitrary operand types. \n+   The machine description macro `EXTRA_CONSTRAINT' is passed the\n+   operand as its first argument and the constraint letter as its\n+   second operand.\n+\n+   `Q' means address register indirect addressing mode.\n+   `S' is for operands that satisfy 'm' when -mpcrel is in effect.\n+   `T' is for operands that satisfy 's' when -mpcrel is not in effect.  */\n+\n+#define EXTRA_CONSTRAINT(OP,CODE)\t\t\t\\\n+  (((CODE) == 'S')\t\t\t\t\t\\\n+   ? (TARGET_PCREL\t\t\t\t\t\\\n+      && GET_CODE (OP) == MEM\t\t\t\t\\\n+      && (GET_CODE (XEXP (OP, 0)) == SYMBOL_REF\t\t\\\n+\t  || GET_CODE (XEXP (OP, 0)) == LABEL_REF\t\\\n+\t  || GET_CODE (XEXP (OP, 0)) == CONST))\t\t\\\n+   : \t\t\t\t\t\t\t\\\n+  (((CODE) == 'T')\t\t\t\t\t\\\n+   ? ( !TARGET_PCREL \t\t\t\t\t\\\n+      && (GET_CODE (OP) == SYMBOL_REF\t\t\t\\\n+\t  || GET_CODE (OP) == LABEL_REF\t\t\t\\\n+\t  || GET_CODE (OP) == CONST))\t\t\t\\\n+   :\t\t\t\t\t\t\t\\\n+  (((CODE) == 'Q')\t\t\t\t\t\\\n+   ? (GET_CODE (OP) == MEM \t\t\t\t\\\n+      && GET_CODE (XEXP (OP, 0)) == REG)\t\t\\\n+   :\t\t\t\t\t\t\t\\\n+   0)))\n \n /* Given an rtx X being reloaded into a reg required to be\n    in class CLASS, return the class of reg to actually use.\n@@ -789,6 +828,10 @@ extern enum reg_class regno_reg_class[];\n    ? (! CONST_DOUBLE_OK_FOR_LETTER_P (X, 'G')\t\\\n       && (CLASS == FP_REGS || CLASS == DATA_OR_FP_REGS) \\\n       ? FP_REGS : NO_REGS)\t\t\t\\\n+   : (TARGET_PCREL\t\t\t\t\\\n+      && (GET_CODE (X) == SYMBOL_REF || GET_CODE (X) == CONST \\\n+\t  || GET_CODE (X) == LABEL_REF))\t\\\n+   ? ADDR_REGS\t\t\t\t\t\\\n    : (CLASS))\n \n /* Force QImode output reloads from subregs to be allocated to data regs,\n@@ -1353,15 +1396,26 @@ __transfer_from_trampoline ()\t\t\t\t\t\\\n \n /* Nonzero if the constant value X is a legitimate general operand\n    when generating PIC code.  It is given that flag_pic is on and \n-   that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n+   that X satisfies CONSTANT_P or is a CONST_DOUBLE.\n+\n+   PCREL_GENERAL_OPERAND_OK makes reload accept addresses that are\n+   accepted by insn predicates, but which would otherwise fail the\n+   `general_operand' test.  */\n+\n+#ifndef REG_OK_STRICT\n+#define PCREL_GENERAL_OPERAND_OK 0\n+#else\n+#define PCREL_GENERAL_OPERAND_OK (TARGET_PCREL)\n+#endif\n \n #define LEGITIMATE_PIC_OPERAND_P(X)\t\\\n   ((! symbolic_operand (X, VOIDmode)\t\t\t\t\\\n     && ! (GET_CODE (X) == CONST_DOUBLE && CONST_DOUBLE_MEM (X)\t\\\n \t  && GET_CODE (CONST_DOUBLE_MEM (X)) == MEM\t\t\\\n \t  && symbolic_operand (XEXP (CONST_DOUBLE_MEM (X), 0),\t\\\n \t\t\t       VOIDmode)))\t\t\t\\\n-   || (GET_CODE (X) == SYMBOL_REF && SYMBOL_REF_FLAG (X)))\n+   || (GET_CODE (X) == SYMBOL_REF && SYMBOL_REF_FLAG (X))\t\\\n+   || PCREL_GENERAL_OPERAND_OK)\n \n /* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n    and check its validity for a certain class.\n@@ -1431,7 +1485,7 @@ __transfer_from_trampoline ()\t\t\t\t\t\\\n    || (GET_CODE (X) == PLUS && XEXP (X, 0) == pic_offset_table_rtx \t\\\n        && flag_pic && GET_CODE (XEXP (X, 1)) == SYMBOL_REF)\t\t\\\n    || (GET_CODE (X) == PLUS && XEXP (X, 0) == pic_offset_table_rtx \t\\\n-       && flag_pic && GET_CODE (XEXP (X, 1)) == LABEL_REF))\t\t\\\n+       && flag_pic && GET_CODE (XEXP (X, 1)) == LABEL_REF))\n \n #define GO_IF_NONINDEXED_ADDRESS(X, ADDR)  \\\n { if (INDIRECTABLE_1_ADDRESS_P (X)) goto ADDR; }\n@@ -2032,6 +2086,8 @@ do { long l;\t\t\t\t\t\t\\\n    'b' for byte insn (no effect, on the Sun; this is for the ISI).\n    'd' to force memory addressing to be absolute, not relative.\n    'f' for float insn (print a CONST_DOUBLE as a float rather than in hex)\n+   'o' for operands to go directly to output_operand_address (bypassing\n+       print_operand_address--used only for SYMBOL_REFs under TARGET_PCREL)\n    'w' for FPA insn (print a CONST_DOUBLE as a SunFPA constant rather\n        than directly).  Second part of 'y' below.\n    'x' for float insn (print a CONST_DOUBLE as a float rather than in hex),"}, {"sha": "c36e5dd3fae8175eb4f0c1163dab52516d1ceac1", "filename": "gcc/config/m68k/m68k.md", "status": "modified", "additions": 144, "deletions": 94, "changes": 238, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c8ec431e3d004bab9f620815ffafe7d3be3597e/gcc%2Fconfig%2Fm68k%2Fm68k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c8ec431e3d004bab9f620815ffafe7d3be3597e/gcc%2Fconfig%2Fm68k%2Fm68k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.md?ref=2c8ec431e3d004bab9f620815ffafe7d3be3597e", "patch": "@@ -502,7 +502,7 @@\n   \"\n {\n   m68k_last_compare_had_fp_operands = 0;\n-  if (flag_pic && symbolic_operand (operands[1], SImode))\n+  if (flag_pic && !TARGET_PCREL && symbolic_operand (operands[1], SImode))\n     {\n       /* The source is an address which requires PIC relocation.\n          Call legitimize_pic_address with the source, mode, and a relocation\n@@ -517,8 +517,8 @@\n ;; A composite of the cmp, cmpa, cmpi & cmpm m68000 op codes.\n (define_insn \"\"\n   [(set (cc0)\n-\t(compare (match_operand:SI 0 \"nonimmediate_operand\" \"rKs,mr,>\")\n-\t\t (match_operand:SI 1 \"general_operand\" \"mr,rKs,>\")))]\n+        (compare (match_operand:SI 0 \"nonimmediate_operand\" \"rKT,rKs,mSr,mSa,>\")\n+                 (match_operand:SI 1 \"general_src_operand\" \"mSr,mSa,KTr,Ksr,>\")))]\n   \"!TARGET_5200\"\n   \"*\n {\n@@ -580,15 +580,15 @@\n \n (define_expand \"cmphi\"\n   [(set (cc0)\n-\t(compare (match_operand:HI 0 \"nonimmediate_operand\" \"\")\n-\t\t (match_operand:HI 1 \"general_operand\" \"\")))]\n+        (compare (match_operand:HI 0 \"nonimmediate_src_operand\" \"\")\n+                 (match_operand:HI 1 \"general_src_operand\" \"\")))]\n   \"!TARGET_5200\"\n   \"m68k_last_compare_had_fp_operands = 0;\")\n \n (define_insn \"\"\n   [(set (cc0)\n-\t(compare (match_operand:HI 0 \"nonimmediate_operand\" \"rnm,d,n,m,>\")\n-\t\t (match_operand:HI 1 \"general_operand\" \"d,rnm,m,n,>\")))]\n+        (compare (match_operand:HI 0 \"nonimmediate_src_operand\" \"rnmS,d,n,mS,>\")\n+                 (match_operand:HI 1 \"general_src_operand\" \"d,rnmS,mS,n,>\")))]\n   \"!TARGET_5200\"\n   \"*\n {\n@@ -616,15 +616,15 @@\n \n (define_expand \"cmpqi\"\n   [(set (cc0)\n-\t(compare (match_operand:QI 0 \"nonimmediate_operand\" \"\")\n-\t\t (match_operand:QI 1 \"general_operand\" \"\")))]\n+        (compare (match_operand:QI 0 \"nonimmediate_src_operand\" \"\")\n+                 (match_operand:QI 1 \"general_src_operand\" \"\")))]\n   \"!TARGET_5200\"\n   \"m68k_last_compare_had_fp_operands = 0;\")\n \n (define_insn \"\"\n   [(set (cc0)\n-\t(compare (match_operand:QI 0 \"nonimmediate_operand\" \"dn,md,>\")\n-\t\t (match_operand:QI 1 \"general_operand\" \"dm,nd,>\")))]\n+        (compare (match_operand:QI 0 \"nonimmediate_src_operand\" \"dn,dmS,>\")\n+                 (match_operand:QI 1 \"general_src_operand\" \"dmS,nd,>\")))]\n   \"!TARGET_5200\"\n   \"*\n {\n@@ -765,7 +765,7 @@\n ;; from a MEM at a constant bit position if we can't use this as a constraint.\n \n (define_insn \"\"\n-  [(set (cc0) (zero_extract (match_operand:QI 0 \"memory_operand\" \"o\")\n+  [(set (cc0) (zero_extract (match_operand:QI 0 \"memory_src_operand\" \"oS\")\n \t\t\t    (const_int 1)\n \t\t\t    (minus:SI (const_int 7)\n \t\t\t\t      (match_operand:SI 1 \"general_operand\" \"di\"))))]\n@@ -948,7 +948,7 @@\n   \"\"\n   \"\n {\n-  if (flag_pic && symbolic_operand (operands[1], SImode))\n+  if (flag_pic && !TARGET_PCREL && symbolic_operand (operands[1], SImode))\n     {\n       /* The source is an address which requires PIC relocation.\n          Call legitimize_pic_address with the source, mode, and a relocation\n@@ -958,6 +958,17 @@\n       rtx temp = reload_in_progress ? operands[0] : gen_reg_rtx (Pmode);\n       operands[1] = legitimize_pic_address (operands[1], SImode, temp);\n     }\n+  else if (flag_pic && TARGET_PCREL && ! reload_in_progress)\n+    {\n+      /* Don't allow writes to memory except via a register;\n+\t the m68k doesn't consider PC-relative addresses to be writable.  */\n+      if (symbolic_operand (operands[0], SImode))\n+\toperands[0] = force_reg (SImode, XEXP (operands[0], 0));\n+      else if (GET_CODE (operands[0]) == MEM\n+\t       && symbolic_operand (XEXP (operands[0], 0), SImode))\n+\toperands[0] = gen_rtx (MEM, SImode,\n+\t\t\t       force_reg (SImode, XEXP (operands[0], 0)));\n+    }\n }\")\n \n ;; General case of fullword move.  The register constraints\n@@ -967,12 +978,13 @@\n   ;; Notes: make sure no alternative allows g vs g.\n   ;; We don't allow f-regs since fixed point cannot go in them.\n   ;; We do allow y and x regs since fixed point is allowed in them.\n-  [(set (match_operand:SI 0 \"general_operand\" \"=g,da,y,!*x*r*m\")\n-\t(match_operand:SI 1 \"general_operand\" \"daymKs,i,g,*x*r*m\"))]\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g,d,a<,y,!*x*r*m\")\n+        (match_operand:SI 1 \"general_src_operand\" \"daymSKT,n,i,g,*x*r*m\"))]\n+\n   \"!TARGET_5200\"\n   \"*\n {\n-  if (which_alternative == 3)\n+  if (which_alternative == 4)\n     return \\\"fpmove%.l %x1,fpa0\\;fpmove%.l fpa0,%x0\\\";\n   if (FPA_REG_P (operands[1]) || FPA_REG_P (operands[0]))\n     return \\\"fpmove%.l %x1,%x0\\\";\n@@ -985,6 +997,19 @@\n   \"TARGET_5200\"\n   \"* return output_move_simode (operands);\")\n \n+;; Special case of fullword move, where we need to get a non-GOT PIC\n+;; reference into an address register.\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=a<\")\n+        (match_operand:SI 1 \"pcrel_address\" \"\"))]\n+  \"TARGET_PCREL\"\n+  \"*\n+{\n+  if (push_operand (operands[0], SImode))\n+    return \\\"pea %a1\\\";\n+  return \\\"lea %a1,%0\\\";\n+}\")\n+\n (define_expand \"movhi\"\n   [(set (match_operand:HI 0 \"general_operand\" \"\")\n \t(match_operand:HI 1 \"general_operand\" \"\"))]\n@@ -993,7 +1018,7 @@\n \n (define_insn \"\"\n   [(set (match_operand:HI 0 \"general_operand\" \"=g\")\n-\t(match_operand:HI 1 \"general_operand\" \"g\"))]\n+        (match_operand:HI 1 \"general_src_operand\" \"gS\"))]\n   \"!TARGET_5200\"\n   \"* return output_move_himode (operands);\")\n \n@@ -1005,55 +1030,55 @@\n \n (define_expand \"movstricthi\"\n   [(set (strict_low_part (match_operand:HI 0 \"general_operand\" \"\"))\n-\t(match_operand:HI 1 \"general_operand\" \"\"))]\n+        (match_operand:HI 1 \"general_src_operand\" \"\"))]\n   \"\"\n   \"\")\n \n (define_insn \"\"\n   [(set (strict_low_part (match_operand:HI 0 \"general_operand\" \"+dm\"))\n-\t(match_operand:HI 1 \"general_operand\" \"rmn\"))]\n+\t(match_operand:HI 1 \"general_src_operand\" \"rmSn\"))]\n   \"!TARGET_5200\"\n   \"* return output_move_stricthi (operands);\")\n \n (define_insn \"\"\n   [(set (strict_low_part (match_operand:HI 0 \"general_operand\" \"+d,m\"))\n-\t(match_operand:HI 1 \"general_operand\" \"rmn,r\"))]\n+\t(match_operand:HI 1 \"general_src_operand\" \"rmn,r\"))]\n   \"TARGET_5200\"\n   \"* return output_move_stricthi (operands);\")\n \n (define_expand \"movqi\"\n   [(set (match_operand:QI 0 \"general_operand\" \"\")\n-\t(match_operand:QI 1 \"general_operand\" \"\"))]\n+        (match_operand:QI 1 \"general_src_operand\" \"\"))]\n   \"\"\n   \"\")\n \n (define_insn \"\"\n   [(set (match_operand:QI 0 \"general_operand\" \"=d,*a,m\")\n-\t(match_operand:QI 1 \"general_operand\" \"dmi*a,di*a,dmi\"))]\n+\t(match_operand:QI 1 \"general_src_operand\" \"dmSi*a,di*a,dmSi\"))]\n   \"!TARGET_5200\"\n   \"* return output_move_qimode (operands);\")\n \n (define_insn \"\"\n   [(set (match_operand:QI 0 \"general_operand\" \"=d<Q>,dm,d*a\")\n-\t(match_operand:QI 1 \"general_operand\" \"dmi,d<Q>,di*a\"))]\n+\t(match_operand:QI 1 \"general_src_operand\" \"dmi,d<Q>,di*a\"))]\n   \"TARGET_5200\"\n   \"* return output_move_qimode (operands);\")\n \n (define_expand \"movstrictqi\"\n   [(set (strict_low_part (match_operand:QI 0 \"general_operand\" \"\"))\n-\t(match_operand:QI 1 \"general_operand\" \"\"))]\n+        (match_operand:QI 1 \"general_src_operand\" \"\"))]\n   \"\"\n   \"\")\n \n (define_insn \"\"\n   [(set (strict_low_part (match_operand:QI 0 \"general_operand\" \"+dm\"))\n-\t(match_operand:QI 1 \"general_operand\" \"dmn\"))]\n+\t(match_operand:QI 1 \"general_src_operand\" \"dmSn\"))]\n   \"!TARGET_5200\"\n   \"* return output_move_strictqi (operands);\")\n \n (define_insn \"\"\n   [(set (strict_low_part (match_operand:QI 0 \"general_operand\" \"+d,m\"))\n-\t(match_operand:QI 1 \"general_operand\" \"dmn,d\"))]\n+\t(match_operand:QI 1 \"general_src_operand\" \"dmn,d\"))]\n   \"TARGET_5200\"\n   \"* return output_move_strictqi (operands);\")\n \n@@ -1234,6 +1259,15 @@\n \toperands[1] = change_address (operands[1], XFmode,\n \t\t\t\t      XEXP (operands[1], 0));\n     }\n+  if (flag_pic && TARGET_PCREL && ! reload_in_progress)\n+    {\n+      /* Don't allow writes to memory except via a register;\n+\t the m68k doesn't consider PC-relative addresses to be writable.  */\n+      if (GET_CODE (operands[0]) == MEM\n+\t  && symbolic_operand (XEXP (operands[0], 0), SImode))\n+\toperands[0] = gen_rtx (MEM, XFmode,\n+\t\t\t       force_reg (SImode, XEXP (operands[0], 0)));\n+    }\n }\")\n \n (define_insn \"\"\n@@ -1398,7 +1432,7 @@\n (define_insn \"truncsiqi2\"\n   [(set (match_operand:QI 0 \"general_operand\" \"=dm,d\")\n \t(truncate:QI\n-\t (match_operand:SI 1 \"general_operand\" \"doJ,i\")))]\n+\t (match_operand:SI 1 \"general_src_operand\" \"doJS,i\")))]\n   \"\"\n   \"*\n {\n@@ -1417,7 +1451,7 @@\n (define_insn \"trunchiqi2\"\n   [(set (match_operand:QI 0 \"general_operand\" \"=dm,d\")\n \t(truncate:QI\n-\t (match_operand:HI 1 \"general_operand\" \"doJ,i\")))]\n+\t (match_operand:HI 1 \"general_src_operand\" \"doJS,i\")))]\n   \"\"\n   \"*\n {\n@@ -1445,7 +1479,7 @@\n (define_insn \"truncsihi2\"\n   [(set (match_operand:HI 0 \"general_operand\" \"=dm,d\")\n \t(truncate:HI\n-\t (match_operand:SI 1 \"general_operand\" \"roJ,i\")))]\n+\t (match_operand:SI 1 \"general_src_operand\" \"roJS,i\")))]\n   \"\"\n   \"*\n {\n@@ -1565,7 +1599,7 @@\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=do<>,d<\")\n-\t(zero_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"r,m\")))]\n+\t(zero_extend:SI (match_operand:HI 1 \"nonimmediate_src_operand\" \"r,mS\")))]\n   \"GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM\"\n   \"*\n {\n@@ -1594,7 +1628,7 @@\n \n (define_insn \"\"\n   [(set (match_operand:HI 0 \"general_operand\" \"=do<>,d\")\n-\t(zero_extend:HI (match_operand:QI 1 \"nonimmediate_operand\" \"d,m\")))]\n+\t(zero_extend:HI (match_operand:QI 1 \"nonimmediate_src_operand\" \"d,mS\")))]\n   \"GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM\"\n   \"*\n {\n@@ -1635,7 +1669,7 @@\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=do<>,d\")\n-\t(zero_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"d,m\")))]\n+\t(zero_extend:SI (match_operand:QI 1 \"nonimmediate_src_operand\" \"d,mS\")))]\n   \"GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM\"\n   \"*\n {\n@@ -1688,7 +1722,7 @@\n \n (define_insn \"extendqidi2\"\n   [(set (match_operand:DI 0 \"general_operand\" \"=d\")\n-\t(sign_extend:DI (match_operand:QI 1 \"general_operand\" \"dm\")))]\n+        (sign_extend:DI (match_operand:QI 1 \"general_src_operand\" \"rmS\")))]\n   \"\"\n   \"*\n {\n@@ -1703,7 +1737,7 @@\n (define_insn \"extendhidi2\"\n   [(set (match_operand:DI 0 \"general_operand\" \"=d\")\n \t(sign_extend:DI\n-\t (match_operand:HI 1 \"general_operand\" \"rm\")))]\n+\t (match_operand:HI 1 \"general_src_operand\" \"rmS\")))]\n   \"\"\n   \"*\n {\n@@ -1765,7 +1799,7 @@\n (define_insn \"extendhisi2\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=*d,a\")\n \t(sign_extend:SI\n-\t (match_operand:HI 1 \"nonimmediate_operand\" \"0,rm\")))]\n+\t (match_operand:HI 1 \"nonimmediate_src_operand\" \"0,rmS\")))]\n   \"\"\n   \"*\n {\n@@ -2278,7 +2312,7 @@\n (define_expand \"addsi3\"\n   [(set (match_operand:SI 0 \"general_operand\" \"\")\n \t(plus:SI (match_operand:SI 1 \"general_operand\" \"\")\n-\t\t (match_operand:SI 2 \"general_operand\" \"\")))]\n+\t\t (match_operand:SI 2 \"general_src_operand\" \"\")))]\n   \"\"\n   \"\")\n \n@@ -2287,31 +2321,33 @@\n ;; This is needed since they are not themselves reloaded,\n ;; so commutativity won't apply to them.\n (define_insn \"*addsi3_internal\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=m,?a,?a,r\")\n-\t(plus:SI (match_operand:SI 1 \"general_operand\" \"%0,a,rJK,0\")\n-\t\t (match_operand:SI 2 \"general_operand\" \"dIKLs,rJK,a,mrIKLs\")))]\n+  [(set (match_operand:SI 0 \"general_operand\" \"=m,?a,?a,d,a\")\n+        (plus:SI (match_operand:SI 1 \"general_operand\" \"%0,a,rJK,0,0\")\n+                 (match_operand:SI 2 \"general_src_operand\" \"dIKLT,rJK,a,mSrIKLT,mSrIKLs\")))]\n+\n+\n   \"! TARGET_5200\"\n   \"* return output_addsi3 (operands);\")\n \n (define_insn \"*addsi3_5200\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=m,?a,?a,r\")\n \t(plus:SI (match_operand:SI 1 \"general_operand\" \"%0,a,rJK,0\")\n-\t\t (match_operand:SI 2 \"general_operand\" \"d,rJK,a,mrIKLs\")))]\n+\t\t (match_operand:SI 2 \"general_src_operand\" \"d,rJK,a,mrIKLs\")))]\n   \"TARGET_5200\"\n   \"* return output_addsi3 (operands);\")\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=a\")\n \t(plus:SI (match_operand:SI 1 \"general_operand\" \"0\")\n \t\t (sign_extend:SI\n-\t\t  (match_operand:HI 2 \"nonimmediate_operand\" \"rm\"))))]\n+\t\t  (match_operand:HI 2 \"nonimmediate_src_operand\" \"rmS\"))))]\n   \"!TARGET_5200\"\n   \"add%.w %2,%0\")\n \n (define_insn \"addhi3\"\n   [(set (match_operand:HI 0 \"general_operand\" \"=m,r\")\n \t(plus:HI (match_operand:HI 1 \"general_operand\" \"%0,0\")\n-\t\t (match_operand:HI 2 \"general_operand\" \"dn,rmn\")))]\n+\t\t (match_operand:HI 2 \"general_src_operand\" \"dn,rmSn\")))]\n   \"!TARGET_5200\"\n   \"*\n {\n@@ -2373,7 +2409,7 @@\n (define_insn \"\"\n   [(set (strict_low_part (match_operand:HI 0 \"general_operand\" \"+m,d\"))\n \t(plus:HI (match_dup 0)\n-\t\t (match_operand:HI 1 \"general_operand\" \"dn,rmn\")))]\n+\t\t (match_operand:HI 1 \"general_src_operand\" \"dn,rmSn\")))]\n   \"!TARGET_5200\"\n   \"*\n {\n@@ -2428,7 +2464,7 @@\n \n (define_insn \"\"\n   [(set (strict_low_part (match_operand:HI 0 \"general_operand\" \"+m,d\"))\n-\t(plus:HI (match_operand:HI 1 \"general_operand\" \"dn,rmn\")\n+\t(plus:HI (match_operand:HI 1 \"general_src_operand\" \"dn,rmSn\")\n \t\t (match_dup 0)))]\n   \"!TARGET_5200\"\n   \"*\n@@ -2485,7 +2521,7 @@\n (define_insn \"addqi3\"\n   [(set (match_operand:QI 0 \"general_operand\" \"=m,d\")\n \t(plus:QI (match_operand:QI 1 \"general_operand\" \"%0,0\")\n-\t\t (match_operand:QI 2 \"general_operand\" \"dn,dmn\")))]\n+\t\t (match_operand:QI 2 \"general_src_operand\" \"dn,dmSn\")))]\n   \"!TARGET_5200\"\n   \"*\n {\n@@ -2511,7 +2547,7 @@\n (define_insn \"\"\n   [(set (strict_low_part (match_operand:QI 0 \"general_operand\" \"+m,d\"))\n \t(plus:QI (match_dup 0)\n-\t\t (match_operand:QI 1 \"general_operand\" \"dn,dmn\")))]\n+\t\t (match_operand:QI 1 \"general_src_operand\" \"dn,dmSn\")))]\n   \"!TARGET_5200\"\n   \"*\n {\n@@ -2536,7 +2572,7 @@\n \n (define_insn \"\"\n   [(set (strict_low_part (match_operand:QI 0 \"general_operand\" \"+m,d\"))\n-\t(plus:QI (match_operand:QI 1 \"general_operand\" \"dn,dmn\")\n+\t(plus:QI (match_operand:QI 1 \"general_src_operand\" \"dn,dmSn\")\n \t\t (match_dup 0)))]\n   \"!TARGET_5200\"\n   \"*\n@@ -2802,45 +2838,45 @@\n } \")\n \n (define_insn \"subsi3\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=m,r\")\n-\t(minus:SI (match_operand:SI 1 \"general_operand\" \"0,0\")\n-\t\t  (match_operand:SI 2 \"general_operand\" \"ds,mrs\")))]\n+  [(set (match_operand:SI 0 \"general_operand\" \"=m,d,a\")\n+\t(minus:SI (match_operand:SI 1 \"general_operand\" \"0,0,0\")\n+\t\t  (match_operand:SI 2 \"general_src_operand\" \"dT,mSrT,mSrs\")))]\n   \"\"\n   \"sub%.l %2,%0\")\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=a\")\n \t(minus:SI (match_operand:SI 1 \"general_operand\" \"0\")\n \t\t  (sign_extend:SI\n-\t\t   (match_operand:HI 2 \"nonimmediate_operand\" \"rm\"))))]\n+\t\t   (match_operand:HI 2 \"nonimmediate_src_operand\" \"rmS\"))))]\n   \"!TARGET_5200\"\n   \"sub%.w %2,%0\")\n \n (define_insn \"subhi3\"\n   [(set (match_operand:HI 0 \"general_operand\" \"=m,r\")\n \t(minus:HI (match_operand:HI 1 \"general_operand\" \"0,0\")\n-\t\t  (match_operand:HI 2 \"general_operand\" \"dn,rmn\")))]\n+\t\t  (match_operand:HI 2 \"general_src_operand\" \"dn,rmSn\")))]\n   \"!TARGET_5200\"\n   \"sub%.w %2,%0\")\n \n (define_insn \"\"\n   [(set (strict_low_part (match_operand:HI 0 \"general_operand\" \"+m,d\"))\n \t(minus:HI (match_dup 0)\n-\t\t  (match_operand:HI 1 \"general_operand\" \"dn,rmn\")))]\n+\t\t  (match_operand:HI 1 \"general_src_operand\" \"dn,rmSn\")))]\n   \"!TARGET_5200\"\n   \"sub%.w %1,%0\")\n \n (define_insn \"subqi3\"\n   [(set (match_operand:QI 0 \"general_operand\" \"=m,d\")\n \t(minus:QI (match_operand:QI 1 \"general_operand\" \"0,0\")\n-\t\t  (match_operand:QI 2 \"general_operand\" \"dn,dmn\")))]\n+\t\t  (match_operand:QI 2 \"general_src_operand\" \"dn,dmSn\")))]\n   \"!TARGET_5200\"\n   \"sub%.b %2,%0\")\n \n (define_insn \"\"\n   [(set (strict_low_part (match_operand:QI 0 \"general_operand\" \"+m,d\"))\n \t(minus:QI (match_dup 0)\n-\t\t  (match_operand:QI 1 \"general_operand\" \"dn,dmn\")))]\n+\t\t  (match_operand:QI 1 \"general_src_operand\" \"dn,dmSn\")))]\n   \"!TARGET_5200\"\n   \"sub%.b %1,%0\")\n \n@@ -2961,7 +2997,7 @@\n (define_insn \"mulhi3\"\n   [(set (match_operand:HI 0 \"general_operand\" \"=d\")\n \t(mult:HI (match_operand:HI 1 \"general_operand\" \"%0\")\n-\t\t (match_operand:HI 2 \"general_operand\" \"dmn\")))]\n+\t\t (match_operand:HI 2 \"general_src_operand\" \"dmSn\")))]\n   \"\"\n   \"*\n {\n@@ -2977,7 +3013,7 @@\n \t(mult:SI (sign_extend:SI\n \t\t  (match_operand:HI 1 \"nonimmediate_operand\" \"%0\"))\n \t\t (sign_extend:SI\n-\t\t  (match_operand:HI 2 \"nonimmediate_operand\" \"dm\"))))]\n+\t\t  (match_operand:HI 2 \"nonimmediate_src_operand\" \"dmS\"))))]\n   \"\"\n   \"*\n {\n@@ -3013,7 +3049,8 @@\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n \t(mult:SI (match_operand:SI 1 \"general_operand\" \"%0\")\n-\t\t (match_operand:SI 2 \"general_operand\" \"dmsK\")))]\n+                 (match_operand:SI 2 \"general_src_operand\" \"dmSTK\")))]\n+\n   \"TARGET_68020\"\n   \"muls%.l %2,%0\")\n \n@@ -3029,7 +3066,7 @@\n \t(mult:SI (zero_extend:SI\n \t\t  (match_operand:HI 1 \"nonimmediate_operand\" \"%0\"))\n \t\t (zero_extend:SI\n-\t\t  (match_operand:HI 2 \"nonimmediate_operand\" \"dm\"))))]\n+\t\t  (match_operand:HI 2 \"nonimmediate_src_operand\" \"dmS\"))))]\n   \"\"\n   \"*\n {\n@@ -3519,7 +3556,7 @@\n (define_insn \"divmodsi4\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n \t(div:SI (match_operand:SI 1 \"general_operand\" \"0\")\n-\t\t(match_operand:SI 2 \"general_operand\" \"dmsK\")))\n+\t\t(match_operand:SI 2 \"general_src_operand\" \"dmSTK\")))\n    (set (match_operand:SI 3 \"general_operand\" \"=d\")\n \t(mod:SI (match_dup 1) (match_dup 2)))]\n   \"TARGET_68020 && !TARGET_5200\"\n@@ -3534,7 +3571,7 @@\n (define_insn \"udivmodsi4\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n \t(udiv:SI (match_operand:SI 1 \"general_operand\" \"0\")\n-\t\t (match_operand:SI 2 \"general_operand\" \"dmsK\")))\n+\t\t (match_operand:SI 2 \"general_src_operand\" \"dmSTK\")))\n    (set (match_operand:SI 3 \"general_operand\" \"=d\")\n \t(umod:SI (match_dup 1) (match_dup 2)))]\n   \"TARGET_68020 && !TARGET_5200\"\n@@ -3549,7 +3586,7 @@\n (define_insn \"divmodhi4\"\n   [(set (match_operand:HI 0 \"general_operand\" \"=d\")\n \t(div:HI (match_operand:HI 1 \"general_operand\" \"0\")\n-\t\t(match_operand:HI 2 \"general_operand\" \"dmsK\")))\n+\t\t(match_operand:HI 2 \"general_src_operand\" \"dmSKT\")))\n    (set (match_operand:HI 3 \"general_operand\" \"=d\")\n \t(mod:HI (match_dup 1) (match_dup 2)))]\n   \"!TARGET_5200\"\n@@ -3572,7 +3609,7 @@\n (define_insn \"udivmodhi4\"\n   [(set (match_operand:HI 0 \"general_operand\" \"=d\")\n \t(udiv:HI (match_operand:HI 1 \"general_operand\" \"0\")\n-\t\t (match_operand:HI 2 \"general_operand\" \"dmsK\")))\n+\t\t (match_operand:HI 2 \"general_src_operand\" \"dmSKT\")))\n    (set (match_operand:HI 3 \"general_operand\" \"=d\")\n \t(umod:HI (match_dup 1) (match_dup 2)))]\n   \"!TARGET_5200\"\n@@ -3675,16 +3712,16 @@\n ;; can't allocate pseudos into it.\n \n (define_expand \"andsi3\"\n-  [(set (match_operand:SI 0 \"not_sp_operand\" \"=m,d\")\n-\t(and:SI (match_operand:SI 1 \"general_operand\" \"%0,0\")\n-\t\t(match_operand:SI 2 \"general_operand\" \"dKs,dmMs\")))]\n+  [(set (match_operand:SI 0 \"not_sp_operand\" \"\")\n+\t(and:SI (match_operand:SI 1 \"general_operand\" \"\")\n+\t\t(match_operand:SI 2 \"general_src_operand\" \"\")))]\n   \"\"\n   \"\")\n \n (define_insn \"andsi3_internal\"\n   [(set (match_operand:SI 0 \"not_sp_operand\" \"=m,d\")\n \t(and:SI (match_operand:SI 1 \"general_operand\" \"%0,0\")\n-\t\t(match_operand:SI 2 \"general_operand\" \"dKs,dmMs\")))]\n+\t\t(match_operand:SI 2 \"general_src_operand\" \"dKT,dmSM\")))]\n   \"!TARGET_5200\"\n   \"*\n {\n@@ -3694,48 +3731,48 @@\n (define_insn \"andsi3_5200\"\n   [(set (match_operand:SI 0 \"not_sp_operand\" \"=m,d\")\n \t(and:SI (match_operand:SI 1 \"general_operand\" \"%0,0\")\n-\t\t(match_operand:SI 2 \"general_operand\" \"d,dmsK\")))]\n+\t\t(match_operand:SI 2 \"general_src_operand\" \"d,dmsK\")))]\n   \"TARGET_5200\"\n   \"and%.l %2,%0\")\n \n (define_insn \"andhi3\"\n   [(set (match_operand:HI 0 \"general_operand\" \"=m,d\")\n \t(and:HI (match_operand:HI 1 \"general_operand\" \"%0,0\")\n-\t\t(match_operand:HI 2 \"general_operand\" \"dn,dmn\")))]\n+\t\t(match_operand:HI 2 \"general_src_operand\" \"dn,dmSn\")))]\n   \"!TARGET_5200\"\n   \"and%.w %2,%0\")\n \n (define_insn \"\"\n   [(set (strict_low_part (match_operand:HI 0 \"general_operand\" \"+m,d\"))\n \t(and:HI (match_dup 0)\n-\t\t(match_operand:HI 1 \"general_operand\" \"dn,dmn\")))]\n+\t\t(match_operand:HI 1 \"general_src_operand\" \"dn,dmSn\")))]\n   \"!TARGET_5200\"\n   \"and%.w %1,%0\")\n \n (define_insn \"\"\n   [(set (strict_low_part (match_operand:HI 0 \"general_operand\" \"+m,d\"))\n-\t(and:HI (match_operand:HI 1 \"general_operand\" \"dn,dmn\")\n+\t(and:HI (match_operand:HI 1 \"general_src_operand\" \"dn,dmSn\")\n \t\t(match_dup 0)))]\n   \"!TARGET_5200\"\n   \"and%.w %1,%0\")\n \n (define_insn \"andqi3\"\n   [(set (match_operand:QI 0 \"general_operand\" \"=m,d\")\n \t(and:QI (match_operand:QI 1 \"general_operand\" \"%0,0\")\n-\t\t(match_operand:QI 2 \"general_operand\" \"dn,dmn\")))]\n+\t\t(match_operand:QI 2 \"general_src_operand\" \"dn,dmSn\")))]\n   \"!TARGET_5200\"\n   \"and%.b %2,%0\")\n \n (define_insn \"\"\n   [(set (strict_low_part (match_operand:QI 0 \"general_operand\" \"+m,d\"))\n \t(and:QI (match_dup 0)\n-\t\t(match_operand:QI 1 \"general_operand\" \"dn,dmn\")))]\n+\t\t(match_operand:QI 1 \"general_src_operand\" \"dn,dmSn\")))]\n   \"!TARGET_5200\"\n   \"and%.b %1,%0\")\n \n (define_insn \"\"\n   [(set (strict_low_part (match_operand:QI 0 \"general_operand\" \"+m,d\"))\n-\t(and:QI (match_operand:QI 1 \"general_operand\" \"dn,dmn\")\n+\t(and:QI (match_operand:QI 1 \"general_src_operand\" \"dn,dmSn\")\n \t\t(match_dup 0)))]\n   \"!TARGET_5200\"\n   \"and%.b %1,%0\")\n@@ -3850,14 +3887,14 @@\n (define_expand \"iorsi3\"\n   [(set (match_operand:SI 0 \"general_operand\" \"\")\n \t(ior:SI (match_operand:SI 1 \"general_operand\" \"\")\n-\t\t(match_operand:SI 2 \"general_operand\" \"\")))]\n+\t\t(match_operand:SI 2 \"general_src_operand\" \"\")))]\n   \"\"\n   \"\")\n \n (define_insn \"iorsi3_internal\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=m,d\")\n \t(ior:SI (match_operand:SI 1 \"general_operand\" \"%0,0\")\n-\t\t(match_operand:SI 2 \"general_operand\" \"dKs,dmMs\")))]\n+                (match_operand:SI 2 \"general_src_operand\" \"dKT,dmSMT\")))]\n   \"! TARGET_5200\"\n   \"*\n {\n@@ -3867,48 +3904,48 @@\n (define_insn \"iorsi3_5200\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=m,d\")\n \t(ior:SI (match_operand:SI 1 \"general_operand\" \"%0,0\")\n-\t\t(match_operand:SI 2 \"general_operand\" \"d,dmsK\")))]\n+\t\t(match_operand:SI 2 \"general_src_operand\" \"d,dmsK\")))]\n   \"TARGET_5200\"\n   \"or%.l %2,%0\")\n \n (define_insn \"iorhi3\"\n   [(set (match_operand:HI 0 \"general_operand\" \"=m,d\")\n \t(ior:HI (match_operand:HI 1 \"general_operand\" \"%0,0\")\n-\t\t(match_operand:HI 2 \"general_operand\" \"dn,dmn\")))]\n+\t\t(match_operand:HI 2 \"general_src_operand\" \"dn,dmSn\")))]\n   \"!TARGET_5200\"\n   \"or%.w %2,%0\")\n \n (define_insn \"\"\n   [(set (strict_low_part (match_operand:HI 0 \"general_operand\" \"+m,d\"))\n \t(ior:HI (match_dup 0)\n-\t\t(match_operand:HI 1 \"general_operand\" \"dn,dmn\")))]\n+\t\t(match_operand:HI 1 \"general_src_operand\" \"dn,dmSn\")))]\n   \"!TARGET_5200\"\n   \"or%.w %1,%0\")\n \n (define_insn \"\"\n   [(set (strict_low_part (match_operand:HI 0 \"general_operand\" \"+m,d\"))\n-\t(ior:HI (match_operand:HI 1 \"general_operand\" \"dn,dmn\")\n+\t(ior:HI (match_operand:HI 1 \"general_src_operand\" \"dn,dmSn\")\n \t\t(match_dup 0)))]\n   \"!TARGET_5200\"\n   \"or%.w %1,%0\")\n \n (define_insn \"iorqi3\"\n   [(set (match_operand:QI 0 \"general_operand\" \"=m,d\")\n \t(ior:QI (match_operand:QI 1 \"general_operand\" \"%0,0\")\n-\t\t(match_operand:QI 2 \"general_operand\" \"dn,dmn\")))]\n+                (match_operand:QI 2 \"general_src_operand\" \"dn,dmSn\")))]\n   \"!TARGET_5200\"\n   \"or%.b %2,%0\")\n \n (define_insn \"\"\n   [(set (strict_low_part (match_operand:QI 0 \"general_operand\" \"+m,d\"))\n \t(ior:QI (match_dup 0)\n-\t\t(match_operand:QI 1 \"general_operand\" \"dn,dmn\")))]\n+                (match_operand:QI 1 \"general_src_operand\" \"dn,dmSn\")))]\n   \"!TARGET_5200\"\n   \"or%.b %1,%0\")\n \n (define_insn \"\"\n   [(set (strict_low_part (match_operand:QI 0 \"general_operand\" \"+m,d\"))\n-\t(ior:QI (match_operand:QI 1 \"general_operand\" \"dn,dmn\")\n+        (ior:QI (match_operand:QI 1 \"general_src_operand\" \"dn,dmSn\")\n \t\t(match_dup 0)))]\n   \"!TARGET_5200\"\n   \"or%.b %1,%0\")\n@@ -4046,7 +4083,8 @@\n (define_insn \"xorsi3_internal\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=do,m\")\n \t(xor:SI (match_operand:SI 1 \"general_operand\" \"%0,0\")\n-\t\t(match_operand:SI 2 \"general_operand\" \"di,dKs\")))]\n+                (match_operand:SI 2 \"general_operand\" \"di,dKT\")))]\n+\n   \"!TARGET_5200\"\n   \"*\n {\n@@ -5267,7 +5305,7 @@\n   [(set (zero_extract:SI (match_operand:QI 0 \"memory_operand\" \"+o\")\n \t\t\t (const_int 32)\n \t\t\t (match_operand:SI 2 \"const_int_operand\" \"n\"))\n-\t(match_operand:SI 3 \"general_operand\" \"rmi\"))]\n+\t(match_operand:SI 3 \"general_src_operand\" \"rmSi\"))]\n   \"TARGET_68020 && TARGET_BITFIELD\n    && (INTVAL (operands[2]) % 8) == 0\n    && ! mode_dependent_address_p (XEXP (operands[0], 0))\"\n@@ -5318,7 +5356,7 @@\n ;\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n-\t(zero_extract:SI (match_operand:QI 1 \"memory_operand\" \"o\")\n+\t(zero_extract:SI (match_operand:QI 1 \"memory_src_operand\" \"oS\")\n \t\t\t (const_int 32)\n \t\t\t (match_operand:SI 3 \"const_int_operand\" \"n\")))]\n   \"TARGET_68020 && TARGET_BITFIELD\n@@ -5372,7 +5410,7 @@\n ;\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n-\t(sign_extract:SI (match_operand:QI 1 \"memory_operand\" \"o\")\n+\t(sign_extract:SI (match_operand:QI 1 \"memory_src_operand\" \"oS\")\n \t\t\t (const_int 32)\n \t\t\t (match_operand:SI 3 \"const_int_operand\" \"n\")))]\n   \"TARGET_68020 && TARGET_BITFIELD\n@@ -6823,21 +6861,28 @@\n   \"*\n   if (GET_CODE (operands[0]) == MEM\n       && GET_CODE (XEXP (operands[0], 0)) == SYMBOL_REF)\n+    {\n+      if (TARGET_PCREL) return \\\"bsr.l %o0\\\";\n #ifdef MOTOROLA\n #ifdef HPUX_ASM\n-    return \\\"bsr.l %0\\\";\n+      return \\\"bsr.l %0\\\";\n #else\n #ifdef USE_GAS\n-    return \\\"bsr.l %0@PLTPC\\\";\n+      return \\\"bsr.l %0@PLTPC\\\";\n #else\n-    return \\\"bsr %0@PLTPC\\\";\n+      return \\\"bsr %0@PLTPC\\\";\n #endif\n #endif\n #else\n-    /* The ',a1' is a dummy argument telling the Sun assembler we want PIC,\n-       GAS just plain ignores it.  */\n-    return \\\"jbsr %0,a1\\\";\n+#ifdef USE_GAS\n+      return \\\"bsr.l %0\\\";\n+#else\n+      /* The ',a1' is a dummy argument telling the Sun assembler we want PIC,\n+\t GAS just plain ignores it.  FIXME: not anymore, gas doesnt!  */\n+      return \\\"jbsr %0,a1\\\";\n #endif\n+#endif\n+    }\n   return \\\"jsr %0\\\";\n \")\n \n@@ -6887,6 +6932,7 @@\n   if (GET_CODE (operands[1]) == MEM\n       && GET_CODE (XEXP (operands[1], 0)) == SYMBOL_REF)\n     {\n+      if (TARGET_PCREL) return \\\"bsr.l %o1\\\";\n #ifdef MOTOROLA\n #ifdef HPUX_ASM\n       return \\\"bsr.l %1\\\";\n@@ -6897,10 +6943,14 @@\n       return \\\"bsr %1@PLTPC\\\";\n #endif\n #endif\n+#else\n+#ifdef USE_GAS\n+      return \\\"bsr.l %1\\\";\n #else\n       /* The ',a1' is a dummy argument telling the Sun assembler we want PIC\n-         GAS just plain ignores it.  */\n+         GAS just plain ignores it.  FIXME: Not anymore, gas doesnt!  */\n       return \\\"jbsr %1,a1\\\";\n+#endif\n #endif\n     }\n   return \\\"jsr %1\\\";"}, {"sha": "88dfc3db9a234464bfe80270f4769046ccda2264", "filename": "gcc/config/m68k/m68kelf.h", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c8ec431e3d004bab9f620815ffafe7d3be3597e/gcc%2Fconfig%2Fm68k%2Fm68kelf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c8ec431e3d004bab9f620815ffafe7d3be3597e/gcc%2Fconfig%2Fm68k%2Fm68kelf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68kelf.h?ref=2c8ec431e3d004bab9f620815ffafe7d3be3597e", "patch": "@@ -246,9 +246,11 @@ extern int switch_table_difference_label_flag;\n /* In m68k svr4, a symbol_ref rtx can be a valid PIC operand if it is an\n    operand of a function call. */\n #undef LEGITIMATE_PIC_OPERAND_P\n-#define LEGITIMATE_PIC_OPERAND_P(X) \\\n-  (! symbolic_operand (X, VOIDmode) \\\n-   || ((GET_CODE(X) == SYMBOL_REF) && SYMBOL_REF_FLAG(X)))\n+\n+#define LEGITIMATE_PIC_OPERAND_P(X)\t\\\n+  (! symbolic_operand (X, VOIDmode)\t\t\t\t\\\n+   || (GET_CODE (X) == SYMBOL_REF && SYMBOL_REF_FLAG (X))\t\\\n+   || PCREL_GENERAL_OPERAND_OK)\n \n /* Turn off function cse if we are doing PIC. We always want function call\n    to be done as `bsr foo@PLTPC', so it will force the assembler to create \n@@ -261,6 +263,8 @@ extern int switch_table_difference_label_flag;\n   if (flag_pic) flag_no_function_cse = 1; \\\n   if (! TARGET_68020 && flag_pic == 2)\t\\\n     error(\"-fPIC is not currently supported on the 68000 or 68010\\n\");\t\\\n+  if (TARGET_PCREL && flag_pic == 0)\t\\\n+    flag_pic = 1;\t\t\t\\\n }\n /* end of stuff from m68kv4.h */\n "}, {"sha": "9f2744db0dce9be50dad940495871677112dd2b6", "filename": "gcc/config/m68k/m68kv4.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c8ec431e3d004bab9f620815ffafe7d3be3597e/gcc%2Fconfig%2Fm68k%2Fm68kv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c8ec431e3d004bab9f620815ffafe7d3be3597e/gcc%2Fconfig%2Fm68k%2Fm68kv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68kv4.h?ref=2c8ec431e3d004bab9f620815ffafe7d3be3597e", "patch": "@@ -297,7 +297,8 @@ int switch_table_difference_label_flag;\n     && ! (GET_CODE (X) == CONST_DOUBLE && CONST_DOUBLE_MEM (X)\t\\\n \t  && GET_CODE (CONST_DOUBLE_MEM (X)) == MEM\t\t\\\n \t  && symbolic_operand (XEXP (CONST_DOUBLE_MEM (X), 0), VOIDmode))) \\\n-   || (GET_CODE (X) == SYMBOL_REF && SYMBOL_REF_FLAG (X)))\n+   || (GET_CODE (X) == SYMBOL_REF && SYMBOL_REF_FLAG (X))       \\\n+   || PCREL_GENERAL_OPERAND_OK)\n \n /* Turn off function cse if we are doing PIC. We always want function call\n    to be done as `bsr foo@PLTPC', so it will force the assembler to create "}]}