{"sha": "aef308d0d6a4d64fb220d88d0e7b736d70fd88da", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWVmMzA4ZDBkNmE0ZDY0ZmIyMjBkODhkMGU3YjczNmQ3MGZkODhkYQ==", "commit": {"author": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2015-03-02T10:59:32Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-03-02T10:59:32Z"}, "message": "utils.c (gnat_pushdecl): For non-artificial pointer types...\n\n2015-03-02  Pierre-Marie de Rodat  <derodat@adacore.com>                  \n                                                                          \n\t* gcc-interface/utils.c (gnat_pushdecl): For non-artificial pointer     \n\ttypes, preserve the original type and create copies just like the C\n\tfront-end does.  For artificial ones, do not define a name for\n\tthe original type.\n\t(create_type_decl): When gnat_pushdecl made the input type the\n\toriginal type for the new declaration, do not define a stub   \n\tdeclaration for it.\n\t* gcc-interface/utils2.c (build_binary_op): Accept two different        \n\tpointer types when they point to the same type.\n\nFrom-SVN: r221108", "tree": {"sha": "52a6e66a285b54a02a7555a6e7d81b48214a6807", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/52a6e66a285b54a02a7555a6e7d81b48214a6807"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aef308d0d6a4d64fb220d88d0e7b736d70fd88da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aef308d0d6a4d64fb220d88d0e7b736d70fd88da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aef308d0d6a4d64fb220d88d0e7b736d70fd88da", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aef308d0d6a4d64fb220d88d0e7b736d70fd88da/comments", "author": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "184a23e94a1b968a1b94defad02a00479a3264a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/184a23e94a1b968a1b94defad02a00479a3264a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/184a23e94a1b968a1b94defad02a00479a3264a2"}], "stats": {"total": 96, "additions": 66, "deletions": 30}, "files": [{"sha": "97c86f3134cda2a9168a793576321891afc2c24c", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aef308d0d6a4d64fb220d88d0e7b736d70fd88da/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aef308d0d6a4d64fb220d88d0e7b736d70fd88da/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=aef308d0d6a4d64fb220d88d0e7b736d70fd88da", "patch": "@@ -1,3 +1,15 @@\n+2015-03-02  Pierre-Marie de Rodat  <derodat@adacore.com>\n+\n+\t* gcc-interface/utils.c (gnat_pushdecl): For non-artificial pointer\n+\ttypes, preserve the original type and create copies just like the C\n+\tfront-end does.  For artificial ones, do not define a name for\n+\tthe original type.\n+\t(create_type_decl): When gnat_pushdecl made the input type the\n+\toriginal type for the new declaration, do not define a stub\n+\tdeclaration for it.\n+\t* gcc-interface/utils2.c (build_binary_op): Accept two different\n+\tpointer types when they point to the same type.\n+\n 2015-03-02  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* exp_util.adb (Possible_Bit_Aligned_Component): Do not process"}, {"sha": "8d36cf74969e3d82ca686c734f068dff1b5c03c7", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 47, "deletions": 30, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aef308d0d6a4d64fb220d88d0e7b736d70fd88da/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aef308d0d6a4d64fb220d88d0e7b736d70fd88da/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=aef308d0d6a4d64fb220d88d0e7b736d70fd88da", "patch": "@@ -773,65 +773,77 @@ gnat_pushdecl (tree decl, Node_Id gnat_node)\n \t}\n     }\n \n-  /* For the declaration of a type, set its name if it either is not already\n+  /* For the declaration of a type, set its name either if it isn't already\n      set or if the previous type name was not derived from a source name.\n      We'd rather have the type named with a real name and all the pointer\n-     types to the same object have the same POINTER_TYPE node.  Code in the\n-     equivalent function of c-decl.c makes a copy of the type node here, but\n-     that may cause us trouble with incomplete types.  We make an exception\n-     for fat pointer types because the compiler automatically builds them\n-     for unconstrained array types and the debugger uses them to represent\n-     both these and pointers to these.  */\n+     types to the same object have the same node, except when the names are\n+     both derived from source names.  */\n   if (TREE_CODE (decl) == TYPE_DECL && DECL_NAME (decl))\n     {\n       tree t = TREE_TYPE (decl);\n \n-      if (!(TYPE_NAME (t) && TREE_CODE (TYPE_NAME (t)) == TYPE_DECL))\n+      if (!(TYPE_NAME (t) && TREE_CODE (TYPE_NAME (t)) == TYPE_DECL)\n+\t  && (TREE_CODE (t) != POINTER_TYPE || DECL_ARTIFICIAL (decl)))\n \t{\n-\t  /* Array and pointer types aren't \"tagged\" types so we force the\n-\t     type to be associated with its typedef in the DWARF back-end,\n-\t     in order to make sure that the latter is always preserved.  */\n-\t  if (!DECL_ARTIFICIAL (decl)\n-\t      && (TREE_CODE (t) == ARRAY_TYPE\n-\t\t  || TREE_CODE (t) == POINTER_TYPE))\n+\t  /* Array types aren't \"tagged\" types so we force the type to be\n+\t     associated with its typedef in the DWARF back-end, in order to\n+\t     make sure that the latter is always preserved.  We used to do the\n+\t     same for pointer types, but to have consistent DWARF output we now\n+\t     create copies for DECL_ORIGINAL_TYPE just like the C front-end\n+\t     does in c-common.c:set_underlying_type.  */\n+\t  if (!DECL_ARTIFICIAL (decl) && TREE_CODE (t) == ARRAY_TYPE)\n \t    {\n \t      tree tt = build_distinct_type_copy (t);\n \t      if (TREE_CODE (t) == POINTER_TYPE)\n \t\tTYPE_NEXT_PTR_TO (t) = tt;\n-\t      TYPE_NAME (tt) = DECL_NAME (decl);\n+\t      /* Array types need to have a name so that they can be related to\n+\t\t their GNAT encodings.  */\n+\t      if (TREE_CODE (t) == ARRAY_TYPE)\n+\t\tTYPE_NAME (tt) = DECL_NAME (decl);\n \t      defer_or_set_type_context (tt,\n \t\t\t\t\t DECL_CONTEXT (decl),\n \t\t\t\t\t deferred_decl_context);\n \t      TYPE_STUB_DECL (tt) = TYPE_STUB_DECL (t);\n \t      DECL_ORIGINAL_TYPE (decl) = tt;\n \t    }\n \t}\n-      else if (TYPE_IS_FAT_POINTER_P (t))\n+      else if (!DECL_ARTIFICIAL (decl)\n+\t       && (TREE_CODE (t) == POINTER_TYPE || TYPE_IS_FAT_POINTER_P (t)))\n \t{\n-\t  /* We need a variant for the placeholder machinery to work.  */\n-\t  tree tt = build_variant_type_copy (t);\n+\t  tree tt;\n+\t  /* ??? We need a variant for the placeholder machinery to work.  */\n+\t  if (TYPE_IS_FAT_POINTER_P (t))\n+\t    tt = build_variant_type_copy (t);\n+\t  else\n+\t    tt = build_distinct_type_copy (t);\n+\t  if (TREE_CODE (t) == POINTER_TYPE)\n+\t    TYPE_NEXT_PTR_TO (t) = tt;\n \t  TYPE_NAME (tt) = decl;\n \t  defer_or_set_type_context (tt,\n \t\t\t\t     DECL_CONTEXT (decl),\n \t\t\t\t     deferred_decl_context);\n \t  TREE_USED (tt) = TREE_USED (t);\n \t  TREE_TYPE (decl) = tt;\n-\t  if (DECL_ORIGINAL_TYPE (TYPE_NAME (t)))\n+\t  if (TYPE_NAME (t) != NULL_TREE\n+\t      && TREE_CODE (TYPE_NAME (t)) == TYPE_DECL\n+\t      && DECL_ORIGINAL_TYPE (TYPE_NAME (t)))\n \t    DECL_ORIGINAL_TYPE (decl) = DECL_ORIGINAL_TYPE (TYPE_NAME (t));\n \t  else\n \t    DECL_ORIGINAL_TYPE (decl) = t;\n-\t  DECL_ARTIFICIAL (decl) = 0;\n \t  t = NULL_TREE;\n \t}\n-      else if (DECL_ARTIFICIAL (TYPE_NAME (t)) && !DECL_ARTIFICIAL (decl))\n+      else if (TYPE_NAME (t) != NULL_TREE\n+\t       && TREE_CODE (TYPE_NAME (t)) == TYPE_DECL\n+\t       && DECL_ARTIFICIAL (TYPE_NAME (t)) && !DECL_ARTIFICIAL (decl))\n \t;\n       else\n \tt = NULL_TREE;\n \n       /* Propagate the name to all the anonymous variants.  This is needed\n-\t for the type qualifiers machinery to work properly.  Also propagate\n-\t the context to them.  Note that the context will be propagated to all\n-\t parallel types too thanks to gnat_set_type_context.  */\n+\t for the type qualifiers machinery to work properly (see\n+\t check_qualified_type).  Also propagate the context to them.  Note that\n+\t the context will be propagated to all parallel types too thanks to\n+\t gnat_set_type_context.  */\n       if (t)\n \tfor (t = TYPE_MAIN_VARIANT (t); t; t = TYPE_NEXT_VARIANT (t))\n \t  if (!(TYPE_NAME (t) && TREE_CODE (TYPE_NAME (t)) == TYPE_DECL))\n@@ -2277,11 +2289,16 @@ create_type_decl (tree type_name, tree type, bool artificial_p,\n   /* Add this decl to the current binding level.  */\n   gnat_pushdecl (type_decl, gnat_node);\n \n-  /* If we're naming the type, equate the TYPE_STUB_DECL to the name.\n-     This causes the name to be also viewed as a \"tag\" by the debug\n-     back-end, with the advantage that no DW_TAG_typedef is emitted\n-     for artificial \"tagged\" types in DWARF.  */\n-  if (!named)\n+  /* If we're naming the type, equate the TYPE_STUB_DECL to the name.  This\n+     causes the name to be also viewed as a \"tag\" by the debug back-end, with\n+     the advantage that no DW_TAG_typedef is emitted for artificial \"tagged\"\n+     types in DWARF.\n+\n+     Note that if \"type\" is used as a DECL_ORIGINAL_TYPE, it may be referenced\n+     from multiple contexts, and \"type_decl\" references a copy of it: in such a\n+     case, do not mess TYPE_STUB_DECL: we do not want to re-use the TYPE_DECL\n+     with the mechanism above.  */\n+  if (!named && type != DECL_ORIGINAL_TYPE (type_decl))\n     TYPE_STUB_DECL (type) = type_decl;\n \n   /* Do not generate debug info for UNCONSTRAINED_ARRAY_TYPE that the\n@@ -5216,7 +5233,7 @@ gnat_write_global_declarations (void)\n /* The general scheme is fairly simple:\n \n    For each builtin function/type to be declared, gnat_install_builtins calls\n-   internal facilities which eventually get to gnat_push_decl, which in turn\n+   internal facilities which eventually get to gnat_pushdecl, which in turn\n    tracks the so declared builtin function decls in the 'builtin_decls' global\n    datastructure. When an Intrinsic subprogram declaration is processed, we\n    search this global datastructure to retrieve the associated BUILT_IN DECL"}, {"sha": "e04add97d085a207a1801448547f52f44566f532", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aef308d0d6a4d64fb220d88d0e7b736d70fd88da/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aef308d0d6a4d64fb220d88d0e7b736d70fd88da/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=aef308d0d6a4d64fb220d88d0e7b736d70fd88da", "patch": "@@ -1062,6 +1062,13 @@ build_binary_op (enum tree_code op_code, tree result_type,\n \t\tgcc_unreachable ();\n \t    }\n \n+\t  else if (POINTER_TYPE_P (left_base_type)\n+\t\t   && POINTER_TYPE_P (right_base_type))\n+\t    {\n+\t      gcc_assert (TREE_TYPE (left_base_type)\n+\t\t\t  == TREE_TYPE (right_base_type));\n+\t      best_type = left_base_type;\n+\t    }\n \t  else\n \t    gcc_unreachable ();\n "}]}