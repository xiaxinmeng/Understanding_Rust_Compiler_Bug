{"sha": "19fad46721af338b24aff48127ae654673bffa7b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTlmYWQ0NjcyMWFmMzM4YjI0YWZmNDgxMjdhZTY1NDY3M2JmZmE3Yg==", "commit": {"author": {"name": "Andrew Stubbs", "email": "ams@codesourcery.com", "date": "2020-07-31T10:27:24Z"}, "committer": {"name": "Andrew Stubbs", "email": "ams@codesourcery.com", "date": "2020-08-04T14:45:22Z"}, "message": "amdgcn: TImode shifts\n\nImplement TImode shifts in the backend.\n\nThe middle-end support that does it for other architectures doesn't work for\nGCN because BITS_PER_WORD==32, meaning that TImode is quad-word, not\ndouble-word.\n\ngcc/ChangeLog:\n\n\t* config/gcn/gcn.md (\"<expander>ti3\"): New.", "tree": {"sha": "eb86e68fa4014f08e0a04d800877d3898a9e6b25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eb86e68fa4014f08e0a04d800877d3898a9e6b25"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/19fad46721af338b24aff48127ae654673bffa7b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19fad46721af338b24aff48127ae654673bffa7b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19fad46721af338b24aff48127ae654673bffa7b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19fad46721af338b24aff48127ae654673bffa7b/comments", "author": {"login": "ams-cs", "id": 2235130, "node_id": "MDQ6VXNlcjIyMzUxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2235130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ams-cs", "html_url": "https://github.com/ams-cs", "followers_url": "https://api.github.com/users/ams-cs/followers", "following_url": "https://api.github.com/users/ams-cs/following{/other_user}", "gists_url": "https://api.github.com/users/ams-cs/gists{/gist_id}", "starred_url": "https://api.github.com/users/ams-cs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ams-cs/subscriptions", "organizations_url": "https://api.github.com/users/ams-cs/orgs", "repos_url": "https://api.github.com/users/ams-cs/repos", "events_url": "https://api.github.com/users/ams-cs/events{/privacy}", "received_events_url": "https://api.github.com/users/ams-cs/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ams-cs", "id": 2235130, "node_id": "MDQ6VXNlcjIyMzUxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2235130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ams-cs", "html_url": "https://github.com/ams-cs", "followers_url": "https://api.github.com/users/ams-cs/followers", "following_url": "https://api.github.com/users/ams-cs/following{/other_user}", "gists_url": "https://api.github.com/users/ams-cs/gists{/gist_id}", "starred_url": "https://api.github.com/users/ams-cs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ams-cs/subscriptions", "organizations_url": "https://api.github.com/users/ams-cs/orgs", "repos_url": "https://api.github.com/users/ams-cs/repos", "events_url": "https://api.github.com/users/ams-cs/events{/privacy}", "received_events_url": "https://api.github.com/users/ams-cs/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "843710c037c1396dcdbc23e5b6b456b8ae6e2b8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/843710c037c1396dcdbc23e5b6b456b8ae6e2b8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/843710c037c1396dcdbc23e5b6b456b8ae6e2b8b"}], "stats": {"total": 105, "additions": 105, "deletions": 0}, "files": [{"sha": "ed98d2d27065219e77a4112635397f8cb61c448a", "filename": "gcc/config/gcn/gcn.md", "status": "modified", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19fad46721af338b24aff48127ae654673bffa7b/gcc%2Fconfig%2Fgcn%2Fgcn.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19fad46721af338b24aff48127ae654673bffa7b/gcc%2Fconfig%2Fgcn%2Fgcn.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fgcn.md?ref=19fad46721af338b24aff48127ae654673bffa7b", "patch": "@@ -1538,6 +1538,111 @@\n   [(set_attr \"type\" \"sop2,sop2,vop2\")\n    (set_attr \"length\" \"8\")])\n \n+;; }}}\n+;; {{{ ALU: generic 128-bit binop\n+\n+; TImode shifts can't be synthesized by the middle-end\n+(define_expand \"<expander>ti3\"\n+  [(set (match_operand:TI 0 \"register_operand\")\n+\t(vec_and_scalar_nocom:TI\n+\t  (match_operand:TI 1 \"gcn_alu_operand\")\n+\t  (match_operand:SI 2 \"gcn_alu_operand\")))]\n+  \"\"\n+  {\n+    rtx dest = operands[0];\n+    rtx src = operands[1];\n+    rtx shift = operands[2];\n+\n+    enum {ashr, lshr, ashl} shiftop = <expander>;\n+    rtx (*inverse_shift_fn) (rtx, rtx, rtx)\n+      = (shiftop == ashl ? gen_lshrdi3 : gen_ashldi3);\n+    rtx (*logical_shift_fn) (rtx, rtx, rtx)\n+      = (shiftop == ashl ? gen_ashldi3 : gen_lshrdi3);\n+\n+    /* We shift \"from\" one subreg \"to\" the other, according to shiftop.  */\n+    int from = (shiftop == ashl ? 0 : 8);\n+    int to = (shiftop == ashl ? 8 : 0);\n+    rtx destfrom = simplify_gen_subreg (DImode, dest, TImode, from);\n+    rtx destto = simplify_gen_subreg (DImode, dest, TImode, to);\n+    rtx srcfrom = simplify_gen_subreg (DImode, src, TImode, from);\n+    rtx srcto = simplify_gen_subreg (DImode, src, TImode, to);\n+\n+    int shiftval = (CONST_INT_P (shift) ? INTVAL (shift) : -1);\n+    enum {RUNTIME, ZERO, SMALL, LARGE} shiftcomparison\n+     = (!CONST_INT_P (shift) ? RUNTIME\n+        : shiftval == 0 ? ZERO\n+        : shiftval < 64 ? SMALL\n+        : LARGE);\n+\n+    rtx large_label, zero_label, exit_label;\n+\n+    if (shiftcomparison == RUNTIME)\n+      {\n+        zero_label = gen_label_rtx ();\n+        large_label = gen_label_rtx ();\n+        exit_label = gen_label_rtx ();\n+\n+        rtx cond = gen_rtx_EQ (VOIDmode, shift, const0_rtx);\n+        emit_insn (gen_cbranchsi4 (cond, shift, const0_rtx, zero_label));\n+\n+        rtx sixtyfour = GEN_INT (64);\n+        cond = gen_rtx_GE (VOIDmode, shift, sixtyfour);\n+        emit_insn (gen_cbranchsi4 (cond, shift, sixtyfour, large_label));\n+      }\n+\n+    if (shiftcomparison == SMALL || shiftcomparison == RUNTIME)\n+      {\n+        /* Shift both parts by the same amount, then patch in the bits that\n+           cross the boundary.\n+           This does *not* work for zero-length shifts.  */\n+        rtx tmpto1 = gen_reg_rtx (DImode);\n+        rtx tmpto2 = gen_reg_rtx (DImode);\n+        emit_insn (gen_<expander>di3 (destfrom, srcfrom, shift));\n+        emit_insn (logical_shift_fn (tmpto1, srcto, shift));\n+        rtx lessershiftval = gen_reg_rtx (SImode);\n+        emit_insn (gen_subsi3 (lessershiftval, GEN_INT (64), shift));\n+        emit_insn (inverse_shift_fn (tmpto2, srcfrom, lessershiftval));\n+        emit_insn (gen_iordi3 (destto, tmpto1, tmpto2));\n+      }\n+\n+    if (shiftcomparison == RUNTIME)\n+      {\n+        emit_jump_insn (gen_jump (exit_label));\n+        emit_barrier ();\n+\n+        emit_label (zero_label);\n+      }\n+\n+    if (shiftcomparison == ZERO || shiftcomparison == RUNTIME)\n+      emit_move_insn (dest, src);\n+\n+    if (shiftcomparison == RUNTIME)\n+      {\n+        emit_jump_insn (gen_jump (exit_label));\n+        emit_barrier ();\n+\n+        emit_label (large_label);\n+      }\n+\n+    if (shiftcomparison == LARGE || shiftcomparison == RUNTIME)\n+      {\n+        /* Do the shift within one part, and set the other part appropriately.\n+           Shifts of 128+ bits are an error.  */\n+        rtx lessershiftval = gen_reg_rtx (SImode);\n+        emit_insn (gen_subsi3 (lessershiftval, shift, GEN_INT (64)));\n+        emit_insn (gen_<expander>di3 (destto, srcfrom, lessershiftval));\n+        if (shiftop == ashr)\n+          emit_insn (gen_ashrdi3 (destfrom, srcfrom, GEN_INT (63)));\n+        else\n+          emit_move_insn (destfrom, const0_rtx);\n+      }\n+\n+    if (shiftcomparison == RUNTIME)\n+      emit_label (exit_label);\n+\n+    DONE;\n+  })\n+\n ;; }}}\n ;; {{{ Atomics\n "}]}