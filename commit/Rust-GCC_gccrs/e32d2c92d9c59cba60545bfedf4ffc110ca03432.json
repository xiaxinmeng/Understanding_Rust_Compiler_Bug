{"sha": "e32d2c92d9c59cba60545bfedf4ffc110ca03432", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTMyZDJjOTJkOWM1OWNiYTYwNTQ1YmZlZGY0ZmZjMTEwY2EwMzQzMg==", "commit": {"author": {"name": "Kugan Vivekanandarajah", "email": "kuganv@linaro.org", "date": "2016-11-10T07:13:39Z"}, "committer": {"name": "Kugan Vivekanandarajah", "email": "kugan@gcc.gnu.org", "date": "2016-11-10T07:13:39Z"}, "message": "revert: ipa-cp.c (ipa_get_jf_pass_through_result): Handle unary expressions.\n\n2016-11-10  Kugan Vivekanandarajah  <kuganv@linaro.org>\n\n\tRevert\n\t2016-11-09  Kugan Vivekanandarajah  <kuganv@linaro.org>\n\n\t* ipa-cp.c (ipa_get_jf_pass_through_result): Handle unary expressions.\n\t(propagate_vr_accross_jump_function): Likewise.\n\t* ipa-prop.c (ipa_set_jf_unary_pass_through): New.\n\t(load_from_param_1): New.\n\t(load_from_unmodified_param): Factor common part into load_from_param_1.\n\t(load_from_param): New.\n\t(compute_complex_assign_jump_func): Handle unary expressions.\n\t(ipa_write_jump_function): Likewise.\n\t(ipa_read_jump_function): Likewise.\n\nFrom-SVN: r242032", "tree": {"sha": "7555541f1ed283f51353aef1309b44615f43c303", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7555541f1ed283f51353aef1309b44615f43c303"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e32d2c92d9c59cba60545bfedf4ffc110ca03432", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e32d2c92d9c59cba60545bfedf4ffc110ca03432", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e32d2c92d9c59cba60545bfedf4ffc110ca03432", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e32d2c92d9c59cba60545bfedf4ffc110ca03432/comments", "author": null, "committer": null, "parents": [{"sha": "a62436c0a505155fc8becac07a8c0abe2c265bfe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a62436c0a505155fc8becac07a8c0abe2c265bfe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a62436c0a505155fc8becac07a8c0abe2c265bfe"}], "stats": {"total": 141, "additions": 33, "deletions": 108}, "files": [{"sha": "2e3819eac6e86f77420a9e6b32bd3e623192be3b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e32d2c92d9c59cba60545bfedf4ffc110ca03432/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e32d2c92d9c59cba60545bfedf4ffc110ca03432/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e32d2c92d9c59cba60545bfedf4ffc110ca03432", "patch": "@@ -1,3 +1,18 @@\n+2016-11-10  Kugan Vivekanandarajah  <kuganv@linaro.org>\n+\n+\tRevert\n+\t2016-11-09  Kugan Vivekanandarajah  <kuganv@linaro.org>\n+\n+\t* ipa-cp.c (ipa_get_jf_pass_through_result): Handle unary expressions.\n+\t(propagate_vr_accross_jump_function): Likewise.\n+\t* ipa-prop.c (ipa_set_jf_unary_pass_through): New.\n+\t(load_from_param_1): New.\n+\t(load_from_unmodified_param): Factor common part into load_from_param_1.\n+\t(load_from_param): New.\n+\t(compute_complex_assign_jump_func): Handle unary expressions.\n+\t(ipa_write_jump_function): Likewise.\n+\t(ipa_read_jump_function): Likewise.\n+\n 2016-11-09  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \t* simplify-rtx.c (simplify_binary_operation_1): Simplify"}, {"sha": "79e621a174af8271cf917eb015f107f30832800a", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 6, "deletions": 31, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e32d2c92d9c59cba60545bfedf4ffc110ca03432/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e32d2c92d9c59cba60545bfedf4ffc110ca03432/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=e32d2c92d9c59cba60545bfedf4ffc110ca03432", "patch": "@@ -1219,19 +1219,13 @@ ipa_get_jf_pass_through_result (struct ipa_jump_func *jfunc, tree input)\n     return NULL_TREE;\n \n   if (TREE_CODE_CLASS (ipa_get_jf_pass_through_operation (jfunc))\n-      == tcc_unary)\n-    res = fold_unary (ipa_get_jf_pass_through_operation (jfunc),\n-\t\t      TREE_TYPE (input), input);\n+      == tcc_comparison)\n+    restype = boolean_type_node;\n   else\n-    {\n-      if (TREE_CODE_CLASS (ipa_get_jf_pass_through_operation (jfunc))\n-\t  == tcc_comparison)\n-\trestype = boolean_type_node;\n-      else\n-\trestype = TREE_TYPE (input);\n-      res = fold_binary (ipa_get_jf_pass_through_operation (jfunc), restype,\n-\t\t\t input, ipa_get_jf_pass_through_operand (jfunc));\n-    }\n+    restype = TREE_TYPE (input);\n+  res = fold_binary (ipa_get_jf_pass_through_operation (jfunc), restype,\n+\t\t     input, ipa_get_jf_pass_through_operand (jfunc));\n+\n   if (res && !is_gimple_ip_invariant (res))\n     return NULL_TREE;\n \n@@ -1870,25 +1864,6 @@ propagate_vr_accross_jump_function (cgraph_edge *cs,\n \n       if (ipa_get_jf_pass_through_operation (jfunc) == NOP_EXPR)\n \treturn dest_lat->meet_with (src_lats->m_value_range);\n-      else if (param_type\n-\t       && (TREE_CODE_CLASS (ipa_get_jf_pass_through_operation (jfunc))\n-\t\t   == tcc_unary))\n-\t{\n-\t  value_range vr;\n-\t  memset (&vr, 0, sizeof (vr));\n-\t  tree operand_type = ipa_get_type (caller_info, src_idx);\n-\t  enum tree_code operation = ipa_get_jf_pass_through_operation (jfunc);\n-\n-\t  if (src_lats->m_value_range.bottom_p ())\n-\t    return false;\n-\n-\t  extract_range_from_unary_expr (&vr,\n-\t\t\t\t\t operation,\n-\t\t\t\t\t param_type,\n-\t\t\t\t\t &src_lats->m_value_range.m_vr,\n-\t\t\t\t\t operand_type);\n-\t  return dest_lat->meet_with (&vr);\n-\t}\n     }\n   else if (jfunc->type == IPA_JF_CONST)\n     {"}, {"sha": "74fe199ea71a4b0ba858c47d060a5cb9441877dc", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 12, "deletions": 77, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e32d2c92d9c59cba60545bfedf4ffc110ca03432/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e32d2c92d9c59cba60545bfedf4ffc110ca03432/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=e32d2c92d9c59cba60545bfedf4ffc110ca03432", "patch": "@@ -446,18 +446,6 @@ ipa_set_jf_simple_pass_through (struct ipa_jump_func *jfunc, int formal_id,\n   jfunc->value.pass_through.agg_preserved = agg_preserved;\n }\n \n-/* Set JFUNC to be an unary pass through jump function.  */\n-\n-static void\n-ipa_set_jf_unary_pass_through (struct ipa_jump_func *jfunc, int formal_id,\n-\t\t\t       enum tree_code operation)\n-{\n-  jfunc->type = IPA_JF_PASS_THROUGH;\n-  jfunc->value.pass_through.operand = NULL_TREE;\n-  jfunc->value.pass_through.formal_id = formal_id;\n-  jfunc->value.pass_through.operation = operation;\n-  jfunc->value.pass_through.agg_preserved = false;\n-}\n /* Set JFUNC to be an arithmetic pass through jump function.  */\n \n static void\n@@ -861,31 +849,6 @@ parm_preserved_before_stmt_p (struct ipa_func_body_info *fbi, int index,\n   return !modified;\n }\n \n-/* Main worker for load_from_unmodified_param and load_from_param.\n-   If STMT is an assignment that loads a value from an parameter declaration,\n-   return the index of the parameter in ipa_node_params.  Otherwise return -1.  */\n-\n-static int\n-load_from_param_1 (struct ipa_func_body_info *fbi,\n-\t\t   vec<ipa_param_descriptor> descriptors,\n-\t\t   gimple *stmt)\n-{\n-  int index;\n-  tree op1;\n-\n-  gcc_checking_assert (is_gimple_assign (stmt));\n-  op1 = gimple_assign_rhs1 (stmt);\n-  if (TREE_CODE (op1) != PARM_DECL)\n-    return -1;\n-\n-  index = ipa_get_param_decl_index_1 (descriptors, op1);\n-  if (index < 0\n-      || !parm_preserved_before_stmt_p (fbi, index, stmt, op1))\n-    return -1;\n-\n-  return index;\n-}\n-\n /* If STMT is an assignment that loads a value from an parameter declaration,\n    return the index of the parameter in ipa_node_params which has not been\n    modified.  Otherwise return -1.  */\n@@ -895,29 +858,22 @@ load_from_unmodified_param (struct ipa_func_body_info *fbi,\n \t\t\t    vec<ipa_param_descriptor> descriptors,\n \t\t\t    gimple *stmt)\n {\n+  int index;\n+  tree op1;\n+\n   if (!gimple_assign_single_p (stmt))\n     return -1;\n \n-  return load_from_param_1 (fbi, descriptors, stmt);\n-}\n-\n-/* If STMT is an assignment that loads a value from an parameter declaration,\n-   return the index of the parameter in ipa_node_params.  Otherwise return -1.  */\n-\n-static int\n-load_from_param (struct ipa_func_body_info *fbi,\n-\t\t vec<ipa_param_descriptor> descriptors,\n-\t\t gimple *stmt)\n-{\n-  if (!is_gimple_assign (stmt))\n+  op1 = gimple_assign_rhs1 (stmt);\n+  if (TREE_CODE (op1) != PARM_DECL)\n     return -1;\n \n-  enum tree_code rhs_code = gimple_assign_rhs_code (stmt);\n-  if ((get_gimple_rhs_class (rhs_code) != GIMPLE_SINGLE_RHS)\n-      && (get_gimple_rhs_class (rhs_code) != GIMPLE_UNARY_RHS))\n+  index = ipa_get_param_decl_index_1 (descriptors, op1);\n+  if (index < 0\n+      || !parm_preserved_before_stmt_p (fbi, index, stmt, op1))\n     return -1;\n \n-  return load_from_param_1 (fbi, descriptors, stmt);\n+  return index;\n }\n \n /* Return true if memory reference REF (which must be a load through parameter\n@@ -1153,7 +1109,6 @@ compute_complex_assign_jump_func (struct ipa_func_body_info *fbi,\n   tree op1, tc_ssa, base, ssa;\n   bool reverse;\n   int index;\n-  gimple *stmt2 = stmt;\n \n   op1 = gimple_assign_rhs1 (stmt);\n \n@@ -1162,16 +1117,13 @@ compute_complex_assign_jump_func (struct ipa_func_body_info *fbi,\n       if (SSA_NAME_IS_DEFAULT_DEF (op1))\n \tindex = ipa_get_param_decl_index (info, SSA_NAME_VAR (op1));\n       else\n-\t{\n-\t  index = load_from_param (fbi, info->descriptors,\n-\t\t\t\t   SSA_NAME_DEF_STMT (op1));\n-\t  stmt2 = SSA_NAME_DEF_STMT (op1);\n-\t}\n+\tindex = load_from_unmodified_param (fbi, info->descriptors,\n+\t\t\t\t\t    SSA_NAME_DEF_STMT (op1));\n       tc_ssa = op1;\n     }\n   else\n     {\n-      index = load_from_param (fbi, info->descriptors, stmt);\n+      index = load_from_unmodified_param (fbi, info->descriptors, stmt);\n       tc_ssa = gimple_assign_lhs (stmt);\n     }\n \n@@ -1195,13 +1147,6 @@ compute_complex_assign_jump_func (struct ipa_func_body_info *fbi,\n \t  bool agg_p = parm_ref_data_pass_through_p (fbi, index, call, tc_ssa);\n \t  ipa_set_jf_simple_pass_through (jfunc, index, agg_p);\n \t}\n-      else if (is_gimple_assign (stmt2)\n-\t       && (gimple_expr_code (stmt2) != NOP_EXPR)\n-\t       && (TREE_CODE_CLASS (gimple_expr_code (stmt2)) == tcc_unary))\n-\t{\n-\t  ipa_set_jf_unary_pass_through (jfunc, index,\n-\t\t\t\t\t gimple_assign_rhs_code (stmt2));\n-\t}\n       return;\n     }\n \n@@ -4721,11 +4666,6 @@ ipa_write_jump_function (struct output_block *ob,\n \t  bp_pack_value (&bp, jump_func->value.pass_through.agg_preserved, 1);\n \t  streamer_write_bitpack (&bp);\n \t}\n-      else if (TREE_CODE_CLASS (jump_func->value.pass_through.operation)\n-\t       == tcc_unary)\n-\t{\n-\t  streamer_write_uhwi (ob, jump_func->value.pass_through.formal_id);\n-\t}\n       else\n \t{\n \t  stream_write_tree (ob, jump_func->value.pass_through.operand, true);\n@@ -4805,11 +4745,6 @@ ipa_read_jump_function (struct lto_input_block *ib,\n \t  bool agg_preserved = bp_unpack_value (&bp, 1);\n \t  ipa_set_jf_simple_pass_through (jump_func, formal_id, agg_preserved);\n \t}\n-      else if (TREE_CODE_CLASS (operation) == tcc_unary)\n-\t{\n-\t  int formal_id =  streamer_read_uhwi (ib);\n-\t  ipa_set_jf_unary_pass_through (jump_func, formal_id, operation);\n-\t}\n       else\n \t{\n \t  tree operand = stream_read_tree (ib, data_in);"}]}