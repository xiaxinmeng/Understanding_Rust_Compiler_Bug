{"sha": "0d189b16f81fb9dced0b29495b5d100492b779d8", "node_id": "C_kwDOANBUbNoAKDBkMTg5YjE2ZjgxZmI5ZGNlZDBiMjk0OTViNWQxMDA0OTJiNzc5ZDg", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2022-05-18T14:27:55Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2022-05-18T14:30:48Z"}, "message": "Reduce usage of limited_with clauses with -fdump-ada-spec\n\nThe problem is that subtypes are not part of the limited view of a package\nso we need to use types in conjunction with limited_with clauses, which is\nnot always desirable as this yields less portable Ada bindings.  The patch\nalso contains a small enhancement for complex floating-point types.\n\ngcc/c-family/\n\t* c-ada-spec.cc (dump_ada_node) <COMPLEX_TYPE>: Deal with usual\n\tfloating-point complex types.\n\t<POINTER_TYPE>: Do not use limited_with clause if the designated\n\ttype is a scalar type.", "tree": {"sha": "b0c8faae6ad001bd54008f6f564c82db259f566a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b0c8faae6ad001bd54008f6f564c82db259f566a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0d189b16f81fb9dced0b29495b5d100492b779d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d189b16f81fb9dced0b29495b5d100492b779d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d189b16f81fb9dced0b29495b5d100492b779d8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d189b16f81fb9dced0b29495b5d100492b779d8/comments", "author": null, "committer": null, "parents": [{"sha": "297a69068ddfe2eaeddfce7249c5709504a83dcb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/297a69068ddfe2eaeddfce7249c5709504a83dcb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/297a69068ddfe2eaeddfce7249c5709504a83dcb"}], "stats": {"total": 32, "additions": 27, "deletions": 5}, "files": [{"sha": "faf71742522bd063165c5464f4375ab1a600e6af", "filename": "gcc/c-family/c-ada-spec.cc", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d189b16f81fb9dced0b29495b5d100492b779d8/gcc%2Fc-family%2Fc-ada-spec.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d189b16f81fb9dced0b29495b5d100492b779d8/gcc%2Fc-family%2Fc-ada-spec.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-ada-spec.cc?ref=0d189b16f81fb9dced0b29495b5d100492b779d8", "patch": "@@ -2105,6 +2105,21 @@ dump_ada_node (pretty_printer *buffer, tree node, tree type, int spc,\n \t  append_withs (\"Interfaces.C.Extensions\", false);\n \t  pp_string (buffer, \"Extensions.CFloat_128\");\n \t}\n+      else if (TREE_TYPE (node) == float_type_node)\n+\t{\n+\t  append_withs (\"Ada.Numerics.Complex_Types\", false);\n+\t  pp_string (buffer, \"Ada.Numerics.Complex_Types.Complex\");\n+\t}\n+      else if (TREE_TYPE (node) == double_type_node)\n+\t{\n+\t  append_withs (\"Ada.Numerics.Long_Complex_Types\", false);\n+\t  pp_string (buffer, \"Ada.Numerics.Long_Complex_Types.Complex\");\n+\t}\n+      else if (TREE_TYPE (node) == long_double_type_node)\n+\t{\n+\t  append_withs (\"Ada.Numerics.Long_Long_Complex_Types\", false);\n+\t  pp_string (buffer, \"Ada.Numerics.Long_Long_Complex_Types.Complex\");\n+\t}\n       else\n \tpp_string (buffer, \"<complex>\");\n       break;\n@@ -2190,7 +2205,7 @@ dump_ada_node (pretty_printer *buffer, tree node, tree type, int spc,\n \t{\n \t  tree ref_type = TREE_TYPE (node);\n \t  const unsigned int quals = TYPE_QUALS (ref_type);\n-\t  bool is_access = false;\n+\t  bool is_access;\n \n \t  if (VOID_TYPE_P (ref_type))\n \t    {\n@@ -2242,7 +2257,10 @@ dump_ada_node (pretty_printer *buffer, tree node, tree type, int spc,\n \t\t    }\n \n \t\t  if (!package_prefix)\n-\t\t    pp_string (buffer, \"access\");\n+\t\t    {\n+\t\t      is_access = false;\n+\t\t      pp_string (buffer, \"access\");\n+\t\t    }\n \t\t  else if (AGGREGATE_TYPE_P (ref_type))\n \t\t    {\n \t\t      if (!type || TREE_CODE (type) != FUNCTION_DECL)\n@@ -2256,17 +2274,21 @@ dump_ada_node (pretty_printer *buffer, tree node, tree type, int spc,\n \t\t\t    pp_string (buffer, \"all \");\n \t\t\t}\n \t\t      else if (quals & TYPE_QUAL_CONST)\n-\t\t\tpp_string (buffer, \"in \");\n+\t\t\t{\n+\t\t\t  is_access = false;\n+\t\t\t  pp_string (buffer, \"in \");\n+\t\t\t}\n \t\t      else\n \t\t\t{\n \t\t\t  is_access = true;\n \t\t\t  pp_string (buffer, \"access \");\n-\t\t\t  /* ??? should be configurable: access or in out.  */\n \t\t\t}\n \t\t    }\n \t\t  else\n \t\t    {\n-\t\t      is_access = true;\n+\t\t      /* We want to use regular with clauses for scalar types,\n+\t\t\t as they are not involved in circular declarations.  */\n+\t\t      is_access = false;\n \t\t      pp_string (buffer, \"access \");\n \n \t\t      if (!name_only)"}]}