{"sha": "47c8cf914763cec943ddafe373cf75f64d93c5a3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDdjOGNmOTE0NzYzY2VjOTQzZGRhZmUzNzNjZjc1ZjY0ZDkzYzVhMw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "1997-02-03T18:04:00Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "1997-02-03T18:04:00Z"}, "message": "Add INPADDR_ADDRESS and OUTADDR_ADDRESS reload types\n\nFrom-SVN: r13600", "tree": {"sha": "8507c30ec93900ecf31eb989170ec7ad89a5a432", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8507c30ec93900ecf31eb989170ec7ad89a5a432"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/47c8cf914763cec943ddafe373cf75f64d93c5a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47c8cf914763cec943ddafe373cf75f64d93c5a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47c8cf914763cec943ddafe373cf75f64d93c5a3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47c8cf914763cec943ddafe373cf75f64d93c5a3/comments", "author": null, "committer": null, "parents": [{"sha": "5ff0385cdb4d5261f8677bde78a725249542ce2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ff0385cdb4d5261f8677bde78a725249542ce2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ff0385cdb4d5261f8677bde78a725249542ce2e"}], "stats": {"total": 257, "additions": 216, "deletions": 41}, "files": [{"sha": "f1b79234c27bceea276605c934a3d84325077aee", "filename": "gcc/reload.c", "status": "modified", "additions": 65, "deletions": 20, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47c8cf914763cec943ddafe373cf75f64d93c5a3/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47c8cf914763cec943ddafe373cf75f64d93c5a3/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=47c8cf914763cec943ddafe373cf75f64d93c5a3", "patch": "@@ -296,6 +296,15 @@ static int output_reloadnum;\n \t || (when1) == RELOAD_FOR_OPERAND_ADDRESS\t\\\n \t || (when1) == RELOAD_FOR_OTHER_ADDRESS))\n \n+  /* If we are going to reload an address, compute the reload type to\n+     use.  */\n+#define ADDR_TYPE(type)\t\t\t\t\t\\\n+  ((type) == RELOAD_FOR_INPUT_ADDRESS\t\t\t\\\n+   ? RELOAD_FOR_INPADDR_ADDRESS\t\t\t\t\\\n+   : ((type) == RELOAD_FOR_OUTPUT_ADDRESS\t\t\\\n+      ? RELOAD_FOR_OUTADDR_ADDRESS\t\t\t\\\n+      : (type)))\n+\n static int push_secondary_reload PROTO((int, rtx, int, int, enum reg_class,\n \t\t\t\t\tenum machine_mode, enum reload_type,\n \t\t\t\t\tenum insn_code *));\n@@ -359,7 +368,10 @@ push_secondary_reload (in_p, x, opnum, optional, reload_class, reload_mode,\n   int i;\n   int s_reload, t_reload = -1;\n \n-  if (type == RELOAD_FOR_INPUT_ADDRESS || type == RELOAD_FOR_OUTPUT_ADDRESS)\n+  if (type == RELOAD_FOR_INPUT_ADDRESS\n+      || type == RELOAD_FOR_OUTPUT_ADDRESS\n+      || type == RELOAD_FOR_INPADDR_ADDRESS\n+      || type == RELOAD_FOR_OUTADDR_ADDRESS)\n     secondary_type = type;\n   else\n     secondary_type = in_p ? RELOAD_FOR_INPUT_ADDRESS : RELOAD_FOR_OUTPUT_ADDRESS;\n@@ -1528,6 +1540,7 @@ combine_reloads ()\n     if (reload_in[i] && ! reload_optional[i] && ! reload_nocombine[i]\n \t/* Life span of this reload must not extend past main insn.  */\n \t&& reload_when_needed[i] != RELOAD_FOR_OUTPUT_ADDRESS\n+\t&& reload_when_needed[i] != RELOAD_FOR_OUTADDR_ADDRESS\n \t&& reload_when_needed[i] != RELOAD_OTHER\n \t&& (CLASS_MAX_NREGS (reload_reg_class[i], reload_inmode[i])\n \t    == CLASS_MAX_NREGS (reload_reg_class[output_reload],\n@@ -3535,10 +3548,19 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t       we must change these to RELOAD_FOR_INPUT_ADDRESS.  */\n \n \t    if (modified[i] == RELOAD_WRITE)\n-\t      for (j = 0; j < n_reloads; j++)\n-\t\tif (reload_opnum[j] == i\n-\t\t    && reload_when_needed[j] == RELOAD_FOR_OUTPUT_ADDRESS)\n-\t\t  reload_when_needed[j] = RELOAD_FOR_INPUT_ADDRESS;\n+\t      {\n+\t\tfor (j = 0; j < n_reloads; j++)\n+\t\t  {\n+\t\t    if (reload_opnum[j] == i)\n+\t\t      {\n+\t\t\tif (reload_when_needed[j] == RELOAD_FOR_OUTPUT_ADDRESS)\n+\t\t\t  reload_when_needed[j] = RELOAD_FOR_INPUT_ADDRESS;\n+\t\t\telse if (reload_when_needed[j]\n+\t\t\t\t == RELOAD_FOR_OUTADDR_ADDRESS)\n+\t\t\t  reload_when_needed[j] = RELOAD_FOR_INPADDR_ADDRESS;\n+\t\t      }\n+\t\t  }\n+\t      }\n \t  }\n \telse if (goal_alternative_matched[i] == -1)\n \t  operand_reloadnum[i] =\n@@ -3725,9 +3747,13 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \n       for (j = i + 1; j < n_reloads; j++)\n \tif ((reload_when_needed[i] == RELOAD_FOR_INPUT_ADDRESS\n-\t     || reload_when_needed[i] == RELOAD_FOR_OUTPUT_ADDRESS)\n+\t     || reload_when_needed[i] == RELOAD_FOR_OUTPUT_ADDRESS\n+\t     || reload_when_needed[i] == RELOAD_FOR_INPADDR_ADDRESS\n+\t     || reload_when_needed[i] == RELOAD_FOR_OUTADDR_ADDRESS)\n \t    && (reload_when_needed[j] == RELOAD_FOR_INPUT_ADDRESS\n-\t\t|| reload_when_needed[j] == RELOAD_FOR_OUTPUT_ADDRESS)\n+\t\t|| reload_when_needed[j] == RELOAD_FOR_OUTPUT_ADDRESS\n+\t\t|| reload_when_needed[j] == RELOAD_FOR_INPADDR_ADDRESS\n+\t\t|| reload_when_needed[j] == RELOAD_FOR_OUTADDR_ADDRESS)\n \t    && rtx_equal_p (reload_in[i], reload_in[j])\n \t    && (operand_reloadnum[reload_opnum[i]] < 0\n \t\t|| reload_optional[operand_reloadnum[reload_opnum[i]]])\n@@ -3741,7 +3767,11 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t      if (replacements[k].what == j)\n \t\treplacements[k].what = i;\n \n-\t    reload_when_needed[i] = RELOAD_FOR_OPERAND_ADDRESS;\n+\t    if (reload_when_needed[i] == RELOAD_FOR_INPADDR_ADDRESS\n+\t\t|| reload_when_needed[i] == RELOAD_FOR_OUTADDR_ADDRESS)\n+\t      reload_when_needed[i] = RELOAD_FOR_OPADDR_ADDR;\n+\t    else\n+\t      reload_when_needed[i] = RELOAD_FOR_OPERAND_ADDRESS;\n \t    reload_in[j] = 0;\n \t  }\n     }\n@@ -3770,14 +3800,17 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \treload_when_needed[i] = address_type[reload_opnum[i]];\n \n       if ((reload_when_needed[i] == RELOAD_FOR_INPUT_ADDRESS\n-\t   || reload_when_needed[i] == RELOAD_FOR_OUTPUT_ADDRESS)\n+\t   || reload_when_needed[i] == RELOAD_FOR_OUTPUT_ADDRESS\n+\t   || reload_when_needed[i] == RELOAD_FOR_INPADDR_ADDRESS\n+\t   || reload_when_needed[i] == RELOAD_FOR_OUTADDR_ADDRESS)\n \t  && (operand_reloadnum[reload_opnum[i]] < 0\n \t      || reload_optional[operand_reloadnum[reload_opnum[i]]]))\n \t{\n \t  /* If we have a secondary reload to go along with this reload,\n \t     change its type to RELOAD_FOR_OPADDR_ADDR.  */\n \n-\t  if (reload_when_needed[i] == RELOAD_FOR_INPUT_ADDRESS\n+\t  if ((reload_when_needed[i] == RELOAD_FOR_INPUT_ADDRESS\n+\t       || reload_when_needed[i] == RELOAD_FOR_INPADDR_ADDRESS)\n \t      && reload_secondary_in_reload[i] != -1)\n \t    {\n \t      int secondary_in_reload = reload_secondary_in_reload[i];\n@@ -3792,7 +3825,8 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t  = RELOAD_FOR_OPADDR_ADDR;\n \t    }\n \n-\t  if (reload_when_needed[i] == RELOAD_FOR_OUTPUT_ADDRESS\n+\t  if ((reload_when_needed[i] == RELOAD_FOR_OUTPUT_ADDRESS\n+\t       || reload_when_needed[i] == RELOAD_FOR_OUTADDR_ADDRESS)\n \t      && reload_secondary_out_reload[i] != -1)\n \t    {\n \t      int secondary_out_reload = reload_secondary_out_reload[i];\n@@ -3806,10 +3840,15 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\treload_when_needed[reload_secondary_out_reload[secondary_out_reload]] \n \t\t  = RELOAD_FOR_OPADDR_ADDR;\n \t    }\n-\t  reload_when_needed[i] = RELOAD_FOR_OPERAND_ADDRESS;\n+\t  if (reload_when_needed[i] == RELOAD_FOR_INPADDR_ADDRESS\n+\t      || reload_when_needed[i] == RELOAD_FOR_OUTADDR_ADDRESS)\n+\t    reload_when_needed[i] = RELOAD_FOR_OPADDR_ADDR;\n+\t  else\n+\t    reload_when_needed[i] = RELOAD_FOR_OPERAND_ADDRESS;\n \t}\n \n-      if (reload_when_needed[i] == RELOAD_FOR_INPUT_ADDRESS\n+      if ((reload_when_needed[i] == RELOAD_FOR_INPUT_ADDRESS\n+\t   || reload_when_needed[i] == RELOAD_FOR_INPADDR_ADDRESS)\n \t  && operand_reloadnum[reload_opnum[i]] >= 0\n \t  && (reload_when_needed[operand_reloadnum[reload_opnum[i]]] \n \t      == RELOAD_OTHER))\n@@ -3827,6 +3866,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n   for (i = 0; i < n_reloads; i++)\n     if (reload_in[i] != 0 && reload_out[i] == 0\n \t&& (reload_when_needed[i] == RELOAD_FOR_OPERAND_ADDRESS\n+\t    || reload_when_needed[i] == RELOAD_FOR_OPADDR_ADDR\n \t    || reload_when_needed[i] == RELOAD_FOR_OTHER_ADDRESS))\n       for (j = 0; j < n_reloads; j++)\n \tif (i != j && reload_in[j] != 0 && reload_out[j] == 0\n@@ -4217,7 +4257,8 @@ find_reloads_address (mode, memrefloc, ad, loc, opnum, type, ind_levels)\n \t{\n \t  tem = make_memloc (ad, regno);\n \t  find_reloads_address (GET_MODE (tem), NULL_PTR, XEXP (tem, 0),\n-\t\t\t\t&XEXP (tem, 0), opnum, type, ind_levels);\n+\t\t\t\t&XEXP (tem, 0), opnum, ADDR_TYPE (type),\n+\t\t\t\tind_levels);\n \t  push_reload (tem, NULL_RTX, loc, NULL_PTR,\n \t\t       reload_address_base_reg_class,\n \t\t       GET_MODE (ad), VOIDmode, 0, 0,\n@@ -4292,7 +4333,8 @@ find_reloads_address (mode, memrefloc, ad, loc, opnum, type, ind_levels)\n \t indirect addresses are valid, reload the MEM into a register.  */\n       tem = ad;\n       find_reloads_address (GET_MODE (ad), &tem, XEXP (ad, 0), &XEXP (ad, 0),\n-\t\t\t    opnum, type, ind_levels == 0 ? 0 : ind_levels - 1);\n+\t\t\t    opnum, ADDR_TYPE (type),\n+\t\t\t    ind_levels == 0 ? 0 : ind_levels - 1);\n \n       /* If tem was changed, then we must create a new memory reference to\n \t hold it and store it back into memrefloc.  */\n@@ -4815,7 +4857,8 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels)\n \t      rtx tem = make_memloc (XEXP (x, 0), regno);\n \t      /* First reload the memory location's address.  */\n \t      find_reloads_address (GET_MODE (tem), 0, XEXP (tem, 0),\n-\t\t\t\t    &XEXP (tem, 0), opnum, type, ind_levels);\n+\t\t\t\t    &XEXP (tem, 0), opnum, ADDR_TYPE (type),\n+\t\t\t\t    ind_levels);\n \t      /* Put this inside a new increment-expression.  */\n \t      x = gen_rtx (GET_CODE (x), GET_MODE (x), tem);\n \t      /* Proceed to reload that, as if it contained a register.  */\n@@ -4883,7 +4926,7 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels)\n \t     reload1.c here.  */\n \t  find_reloads_address (GET_MODE (x), &XEXP (x, 0),\n \t\t\t\tXEXP (XEXP (x, 0), 0), &XEXP (XEXP (x, 0), 0),\n-\t\t\t\topnum, type, ind_levels);\n+\t\t\t\topnum, ADDR_TYPE (type), ind_levels);\n \n \t  reloadnum = push_reload (x, NULL_RTX, loc, NULL_PTR,\n \t\t\t\t   (context\n@@ -4915,7 +4958,7 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels)\n \t reload1.c here.  */\n \n       find_reloads_address (GET_MODE (x), loc, XEXP (x, 0), &XEXP (x, 0),\n-\t\t\t    opnum, type, ind_levels);\n+\t\t\t    opnum, ADDR_TYPE (type), ind_levels);\n       push_reload (*loc, NULL_RTX, loc, NULL_PTR,\n \t\t   (context ? reload_address_index_reg_class\n \t\t    : reload_address_base_reg_class),\n@@ -4953,7 +4996,7 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels)\n \t  {\n \t    x = make_memloc (x, regno);\n \t    find_reloads_address (GET_MODE (x), 0, XEXP (x, 0), &XEXP (x, 0),\n-\t\t\t\t  opnum, type, ind_levels);\n+\t\t\t\t  opnum, ADDR_TYPE (type), ind_levels);\n \t  }\n \n \tif (reg_renumber[regno] >= 0)\n@@ -5958,8 +6001,10 @@ static char *reload_when_needed_name[] =\n   \"RELOAD_FOR_INPUT\", \n   \"RELOAD_FOR_OUTPUT\", \n   \"RELOAD_FOR_INSN\",\n-  \"RELOAD_FOR_INPUT_ADDRESS\", \n+  \"RELOAD_FOR_INPUT_ADDRESS\",\n+  \"RELOAD_FOR_INPADDR_ADDRESS\",\n   \"RELOAD_FOR_OUTPUT_ADDRESS\",\n+  \"RELOAD_FOR_OUTADDR_ADDRESS\",\n   \"RELOAD_FOR_OPERAND_ADDRESS\", \n   \"RELOAD_FOR_OPADDR_ADDR\",\n   \"RELOAD_OTHER\", "}, {"sha": "ae6ce54cecef508f188a26591ab08cd50cd6a654", "filename": "gcc/reload.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47c8cf914763cec943ddafe373cf75f64d93c5a3/gcc%2Freload.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47c8cf914763cec943ddafe373cf75f64d93c5a3/gcc%2Freload.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.h?ref=47c8cf914763cec943ddafe373cf75f64d93c5a3", "patch": "@@ -70,7 +70,9 @@ extern rtx reload_reg_rtx[MAX_RELOADS];\n \t\t\t\tsomething used before or after the insn\n    RELOAD_FOR_INPUT_ADDRESS\treload for parts of the address of an object\n \t\t\t\tthat is an input reload\n-   RELOAD_FOR_OUTPUT_ADDRESS\tlikewise, for output reload\n+   RELOAD_FOR_INPADDR_ADDRESS\treload needed for RELOAD_FOR_INPUT_ADDRESS\n+   RELOAD_FOR_OUTPUT_ADDRESS\tlike RELOAD_FOR INPUT_ADDRESS, for output\n+   RELOAD_FOR_OUTADDR_ADDRESS\treload needed for RELOAD_FOR_OUTPUT_ADDRESS\n    RELOAD_FOR_OPERAND_ADDRESS\treload for the address of a non-reloaded\n \t\t\t\toperand; these don't conflict with\n \t\t\t\tany other addresses.\n@@ -86,7 +88,8 @@ extern rtx reload_reg_rtx[MAX_RELOADS];\n enum reload_type\n {\n   RELOAD_FOR_INPUT, RELOAD_FOR_OUTPUT, RELOAD_FOR_INSN, \n-  RELOAD_FOR_INPUT_ADDRESS, RELOAD_FOR_OUTPUT_ADDRESS,\n+  RELOAD_FOR_INPUT_ADDRESS, RELOAD_FOR_INPADDR_ADDRESS,\n+  RELOAD_FOR_OUTPUT_ADDRESS, RELOAD_FOR_OUTADDR_ADDRESS,\n   RELOAD_FOR_OPERAND_ADDRESS, RELOAD_FOR_OPADDR_ADDR,\n   RELOAD_OTHER, RELOAD_FOR_OTHER_ADDRESS\n };"}, {"sha": "d380b532ae05dc84755bc81c6167578ec65252cb", "filename": "gcc/reload1.c", "status": "modified", "additions": 146, "deletions": 19, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47c8cf914763cec943ddafe373cf75f64d93c5a3/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47c8cf914763cec943ddafe373cf75f64d93c5a3/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=47c8cf914763cec943ddafe373cf75f64d93c5a3", "patch": "@@ -1050,7 +1050,9 @@ reload (first, global, dumpfile)\n \t\tstruct needs op_addr;\n \t\tstruct needs op_addr_reload;\n \t\tstruct needs in_addr[MAX_RECOG_OPERANDS];\n+\t\tstruct needs in_addr_addr[MAX_RECOG_OPERANDS];\n \t\tstruct needs out_addr[MAX_RECOG_OPERANDS];\n+\t\tstruct needs out_addr_addr[MAX_RECOG_OPERANDS];\n \t      } insn_needs;\n \n \t      /* If needed, eliminate any eliminable registers.  */\n@@ -1210,9 +1212,15 @@ reload (first, global, dumpfile)\n \t\t    case RELOAD_FOR_INPUT_ADDRESS:\n \t\t      this_needs = &insn_needs.in_addr[reload_opnum[i]];\n \t\t      break;\n+\t\t    case RELOAD_FOR_INPADDR_ADDRESS:\n+\t\t      this_needs = &insn_needs.in_addr_addr[reload_opnum[i]];\n+\t\t      break;\n \t\t    case RELOAD_FOR_OUTPUT_ADDRESS:\n \t\t      this_needs = &insn_needs.out_addr[reload_opnum[i]];\n \t\t      break;\n+\t\t    case RELOAD_FOR_OUTADDR_ADDRESS:\n+\t\t      this_needs = &insn_needs.out_addr_addr[reload_opnum[i]];\n+\t\t      break;\n \t\t    case RELOAD_FOR_OPERAND_ADDRESS:\n \t\t      this_needs = &insn_needs.op_addr;\n \t\t      break;\n@@ -1286,8 +1294,14 @@ reload (first, global, dumpfile)\n \t\t\t{\n \t\t\t  in_max\n \t\t\t    = MAX (in_max, insn_needs.in_addr[k].regs[j][i]);\n+\t\t\t  in_max\n+\t\t\t    = MAX (in_max,\n+\t\t\t\t   insn_needs.in_addr_addr[k].regs[j][i]);\n \t\t\t  out_max\n \t\t\t    = MAX (out_max, insn_needs.out_addr[k].regs[j][i]);\n+\t\t\t  out_max\n+\t\t\t    = MAX (out_max,\n+\t\t\t\t   insn_needs.out_addr_addr[k].regs[j][i]);\n \t\t\t}\n \n \t\t      /* RELOAD_FOR_INSN reloads conflict with inputs, outputs,\n@@ -1321,8 +1335,12 @@ reload (first, global, dumpfile)\n \t\t       j < reload_n_operands; j++)\n \t\t    {\n \t\t      in_max = MAX (in_max, insn_needs.in_addr[j].groups[i]);\n+\t\t      in_max = MAX (in_max,\n+\t\t\t\t     insn_needs.in_addr_addr[j].groups[i]);\n \t\t      out_max\n \t\t\t= MAX (out_max, insn_needs.out_addr[j].groups[i]);\n+\t\t      out_max\n+\t\t\t= MAX (out_max, insn_needs.out_addr_addr[j].groups[i]);\n \t\t    }\n \n \t\t  in_max = MAX (MAX (insn_needs.op_addr.groups[i],\n@@ -4277,8 +4295,12 @@ reload_reg_class_lower (r1p, r2p)\n static HARD_REG_SET reload_reg_used;\n /* If reg is in use for a RELOAD_FOR_INPUT_ADDRESS reload for operand I.  */\n static HARD_REG_SET reload_reg_used_in_input_addr[MAX_RECOG_OPERANDS];\n+/* If reg is in use for a RELOAD_FOR_INPADDR_ADDRESS reload for operand I.  */\n+static HARD_REG_SET reload_reg_used_in_inpaddr_addr[MAX_RECOG_OPERANDS];\n /* If reg is in use for a RELOAD_FOR_OUTPUT_ADDRESS reload for operand I.  */\n static HARD_REG_SET reload_reg_used_in_output_addr[MAX_RECOG_OPERANDS];\n+/* If reg is in use for a RELOAD_FOR_OUTADDR_ADDRESS reload for operand I.  */\n+static HARD_REG_SET reload_reg_used_in_outaddr_addr[MAX_RECOG_OPERANDS];\n /* If reg is in use for a RELOAD_FOR_INPUT reload for operand I.  */\n static HARD_REG_SET reload_reg_used_in_input[MAX_RECOG_OPERANDS];\n /* If reg is in use for a RELOAD_FOR_OUTPUT reload for operand I.  */\n@@ -4325,10 +4347,18 @@ mark_reload_reg_in_use (regno, opnum, type, mode)\n \t  SET_HARD_REG_BIT (reload_reg_used_in_input_addr[opnum], i);\n \t  break;\n \n+\tcase RELOAD_FOR_INPADDR_ADDRESS:\n+\t  SET_HARD_REG_BIT (reload_reg_used_in_inpaddr_addr[opnum], i);\n+\t  break;\n+\n \tcase RELOAD_FOR_OUTPUT_ADDRESS:\n \t  SET_HARD_REG_BIT (reload_reg_used_in_output_addr[opnum], i);\n \t  break;\n \n+\tcase RELOAD_FOR_OUTADDR_ADDRESS:\n+\t  SET_HARD_REG_BIT (reload_reg_used_in_outaddr_addr[opnum], i);\n+\t  break;\n+\n \tcase RELOAD_FOR_OPERAND_ADDRESS:\n \t  SET_HARD_REG_BIT (reload_reg_used_in_op_addr, i);\n \t  break;\n@@ -4382,10 +4412,18 @@ clear_reload_reg_in_use (regno, opnum, type, mode)\n \t  CLEAR_HARD_REG_BIT (reload_reg_used_in_input_addr[opnum], i);\n \t  break;\n \n+\tcase RELOAD_FOR_INPADDR_ADDRESS:\n+\t  CLEAR_HARD_REG_BIT (reload_reg_used_in_inpaddr_addr[opnum], i);\n+\t  break;\n+\n \tcase RELOAD_FOR_OUTPUT_ADDRESS:\n \t  CLEAR_HARD_REG_BIT (reload_reg_used_in_output_addr[opnum], i);\n \t  break;\n \n+\tcase RELOAD_FOR_OUTADDR_ADDRESS:\n+\t  CLEAR_HARD_REG_BIT (reload_reg_used_in_outaddr_addr[opnum], i);\n+\t  break;\n+\n \tcase RELOAD_FOR_OPERAND_ADDRESS:\n \t  CLEAR_HARD_REG_BIT (reload_reg_used_in_op_addr, i);\n \t  break;\n@@ -4439,7 +4477,9 @@ reload_reg_free_p (regno, opnum, type)\n \n       for (i = 0; i < reload_n_operands; i++)\n \tif (TEST_HARD_REG_BIT (reload_reg_used_in_input_addr[i], regno)\n+\t    || TEST_HARD_REG_BIT (reload_reg_used_in_inpaddr_addr[i], regno)\n \t    || TEST_HARD_REG_BIT (reload_reg_used_in_output_addr[i], regno)\n+\t    || TEST_HARD_REG_BIT (reload_reg_used_in_outaddr_addr[i], regno)\n \t    || TEST_HARD_REG_BIT (reload_reg_used_in_input[i], regno)\n \t    || TEST_HARD_REG_BIT (reload_reg_used_in_output[i], regno))\n \t  return 0;\n@@ -4461,15 +4501,30 @@ reload_reg_free_p (regno, opnum, type)\n \n       /* If it is used in a later operand's address, can't use it.  */\n       for (i = opnum + 1; i < reload_n_operands; i++)\n-\tif (TEST_HARD_REG_BIT (reload_reg_used_in_input_addr[i], regno))\n+\tif (TEST_HARD_REG_BIT (reload_reg_used_in_input_addr[i], regno)\n+\t    || TEST_HARD_REG_BIT (reload_reg_used_in_inpaddr_addr[i], regno))\n \t  return 0;\n \n       return 1;\n \n     case RELOAD_FOR_INPUT_ADDRESS:\n       /* Can't use a register if it is used for an input address for this\n \t operand or used as an input in an earlier one.  */\n-      if (TEST_HARD_REG_BIT (reload_reg_used_in_input_addr[opnum], regno))\n+      if (TEST_HARD_REG_BIT (reload_reg_used_in_input_addr[opnum], regno)\n+\t  || TEST_HARD_REG_BIT (reload_reg_used_in_inpaddr_addr[opnum], regno))\n+\treturn 0;\n+\n+      for (i = 0; i < opnum; i++)\n+\tif (TEST_HARD_REG_BIT (reload_reg_used_in_input[i], regno))\n+\t  return 0;\n+\n+      return 1;\n+\n+    case RELOAD_FOR_INPADDR_ADDRESS:\n+      /* Can't use a register if it is used for an input address\n+         address for this operand or used as an input in an earlier\n+         one.  */\n+      if (TEST_HARD_REG_BIT (reload_reg_used_in_inpaddr_addr[opnum], regno))\n \treturn 0;\n \n       for (i = 0; i < opnum; i++)\n@@ -4490,6 +4545,19 @@ reload_reg_free_p (regno, opnum, type)\n \n       return 1;\n \n+    case RELOAD_FOR_OUTADDR_ADDRESS:\n+      /* Can't use a register if it is used for an output address\n+         address for this operand or used as an output in this or a\n+         later operand.  */\n+      if (TEST_HARD_REG_BIT (reload_reg_used_in_outaddr_addr[opnum], regno))\n+\treturn 0;\n+\n+      for (i = opnum; i < reload_n_operands; i++)\n+\tif (TEST_HARD_REG_BIT (reload_reg_used_in_output[i], regno))\n+\t  return 0;\n+\n+      return 1;\n+\n     case RELOAD_FOR_OPERAND_ADDRESS:\n       for (i = 0; i < reload_n_operands; i++)\n \tif (TEST_HARD_REG_BIT (reload_reg_used_in_input[i], regno))\n@@ -4516,7 +4584,8 @@ reload_reg_free_p (regno, opnum, type)\n \t  return 0;\n \n       for (i = 0; i <= opnum; i++)\n-\tif (TEST_HARD_REG_BIT (reload_reg_used_in_output_addr[i], regno))\n+\tif (TEST_HARD_REG_BIT (reload_reg_used_in_output_addr[i], regno)\n+\t    || TEST_HARD_REG_BIT (reload_reg_used_in_outaddr_addr[i], regno))\n \t  return 0;\n \n       return 1;\n@@ -4570,12 +4639,14 @@ reload_reg_free_before_p (regno, opnum, type)\n \t the first place, since we know that it was allocated.  */\n \n     case RELOAD_FOR_OUTPUT_ADDRESS:\n+    case RELOAD_FOR_OUTADDR_ADDRESS:\n       /* Earlier reloads are for earlier outputs or their addresses,\n \t any RELOAD_FOR_INSN reloads, any inputs or their addresses, or any\n \t RELOAD_FOR_OTHER_ADDRESS reloads (we know it can't conflict with\n \t RELOAD_OTHER)..  */\n       for (i = 0; i < opnum; i++)\n \tif (TEST_HARD_REG_BIT (reload_reg_used_in_output_addr[i], regno)\n+\t    || TEST_HARD_REG_BIT (reload_reg_used_in_outaddr_addr[i], regno)\n \t    || TEST_HARD_REG_BIT (reload_reg_used_in_output[i], regno))\n \t  return 0;\n \n@@ -4584,6 +4655,7 @@ reload_reg_free_before_p (regno, opnum, type)\n \n       for (i = 0; i < reload_n_operands; i++)\n \tif (TEST_HARD_REG_BIT (reload_reg_used_in_input_addr[i], regno)\n+\t    || TEST_HARD_REG_BIT (reload_reg_used_in_inpaddr_addr[i], regno)\n \t    || TEST_HARD_REG_BIT (reload_reg_used_in_input[i], regno))\n \t  return 0;\n \n@@ -4596,16 +4668,19 @@ reload_reg_free_before_p (regno, opnum, type)\n \t anything that can't be used for it, except that we've already\n \t tested for RELOAD_FOR_INSN objects.  */\n \n-      if (TEST_HARD_REG_BIT (reload_reg_used_in_output_addr[opnum], regno))\n+      if (TEST_HARD_REG_BIT (reload_reg_used_in_output_addr[opnum], regno)\n+\t  || TEST_HARD_REG_BIT (reload_reg_used_in_outaddr_addr[opnum], regno))\n \treturn 0;\n \n       for (i = 0; i < opnum; i++)\n \tif (TEST_HARD_REG_BIT (reload_reg_used_in_output_addr[i], regno)\n+\t    || TEST_HARD_REG_BIT (reload_reg_used_in_outaddr_addr[i], regno)\n \t    || TEST_HARD_REG_BIT (reload_reg_used_in_output[i], regno))\n \t  return 0;\n \n       for (i = 0; i < reload_n_operands; i++)\n \tif (TEST_HARD_REG_BIT (reload_reg_used_in_input_addr[i], regno)\n+\t    || TEST_HARD_REG_BIT (reload_reg_used_in_inpaddr_addr[i], regno)\n \t    || TEST_HARD_REG_BIT (reload_reg_used_in_input[i], regno)\n \t    || TEST_HARD_REG_BIT (reload_reg_used_in_op_addr, regno))\n \t  return 0;\n@@ -4619,7 +4694,8 @@ reload_reg_free_before_p (regno, opnum, type)\n \t test is input addresses and the addresses of OTHER items.  */\n \n       for (i = 0; i < reload_n_operands; i++)\n-\tif (TEST_HARD_REG_BIT (reload_reg_used_in_input_addr[i], regno))\n+\tif (TEST_HARD_REG_BIT (reload_reg_used_in_input_addr[i], regno)\n+\t    || TEST_HARD_REG_BIT (reload_reg_used_in_inpaddr_addr[i], regno))\n \t  return 0;\n \n       return ! TEST_HARD_REG_BIT (reload_reg_used_in_other_addr, regno);\n@@ -4630,16 +4706,19 @@ reload_reg_free_before_p (regno, opnum, type)\n \t with), and addresses of RELOAD_OTHER objects.  */\n \n       for (i = 0; i <= opnum; i++)\n-\tif (TEST_HARD_REG_BIT (reload_reg_used_in_input_addr[i], regno))\n+\tif (TEST_HARD_REG_BIT (reload_reg_used_in_input_addr[i], regno)\n+\t    || TEST_HARD_REG_BIT (reload_reg_used_in_inpaddr_addr[i], regno))\n \t  return 0;\n \n       return ! TEST_HARD_REG_BIT (reload_reg_used_in_other_addr, regno);\n \n     case RELOAD_FOR_INPUT_ADDRESS:\n+    case RELOAD_FOR_INPADDR_ADDRESS:\n       /* Similarly, all we have to check is for use in earlier inputs'\n \t addresses.  */\n       for (i = 0; i < opnum; i++)\n-\tif (TEST_HARD_REG_BIT (reload_reg_used_in_input_addr[i], regno))\n+\tif (TEST_HARD_REG_BIT (reload_reg_used_in_input_addr[i], regno)\n+\t    || TEST_HARD_REG_BIT (reload_reg_used_in_inpaddr_addr[i], regno))\n \t  return 0;\n \n       return ! TEST_HARD_REG_BIT (reload_reg_used_in_other_addr, regno);\n@@ -4681,8 +4760,10 @@ reload_reg_reaches_end_p (regno, opnum, type)\n \n       for (i = 0; i < reload_n_operands; i++)\n \tif (TEST_HARD_REG_BIT (reload_reg_used_in_output_addr[i], regno)\n+\t    || TEST_HARD_REG_BIT (reload_reg_used_in_outaddr_addr[i], regno)\n \t    || TEST_HARD_REG_BIT (reload_reg_used_in_output[i], regno)\n \t    || TEST_HARD_REG_BIT (reload_reg_used_in_input_addr[i], regno)\n+\t    || TEST_HARD_REG_BIT (reload_reg_used_in_inpaddr_addr[i], regno)\n \t    || TEST_HARD_REG_BIT (reload_reg_used_in_input[i], regno))\n \t  return 0;\n \n@@ -4691,6 +4772,7 @@ reload_reg_reaches_end_p (regno, opnum, type)\n \t      && ! TEST_HARD_REG_BIT (reload_reg_used, regno));\n \n     case RELOAD_FOR_INPUT_ADDRESS:\n+    case RELOAD_FOR_INPADDR_ADDRESS:\n       /* Similar, except that we check only for this and subsequent inputs\n \t and the address of only subsequent inputs and we do not need\n \t to check for RELOAD_OTHER objects since they are known not to\n@@ -4701,11 +4783,13 @@ reload_reg_reaches_end_p (regno, opnum, type)\n \t  return 0;\n \n       for (i = opnum + 1; i < reload_n_operands; i++)\n-\tif (TEST_HARD_REG_BIT (reload_reg_used_in_input_addr[i], regno))\n+\tif (TEST_HARD_REG_BIT (reload_reg_used_in_input_addr[i], regno)\n+\t    || TEST_HARD_REG_BIT (reload_reg_used_in_inpaddr_addr[i], regno))\n \t  return 0;\n \n       for (i = 0; i < reload_n_operands; i++)\n \tif (TEST_HARD_REG_BIT (reload_reg_used_in_output_addr[i], regno)\n+\t    || TEST_HARD_REG_BIT (reload_reg_used_in_outaddr_addr[i], regno)\n \t    || TEST_HARD_REG_BIT (reload_reg_used_in_output[i], regno))\n \t  return 0;\n \n@@ -4723,6 +4807,7 @@ reload_reg_reaches_end_p (regno, opnum, type)\n \n       for (i = opnum + 1; i < reload_n_operands; i++)\n \tif (TEST_HARD_REG_BIT (reload_reg_used_in_input_addr[i], regno)\n+\t    || TEST_HARD_REG_BIT (reload_reg_used_in_inpaddr_addr[i], regno)\n \t    || TEST_HARD_REG_BIT (reload_reg_used_in_input[i], regno))\n \t  return 0;\n \n@@ -4733,6 +4818,7 @@ reload_reg_reaches_end_p (regno, opnum, type)\n \n       for (i = 0; i < reload_n_operands; i++)\n \tif (TEST_HARD_REG_BIT (reload_reg_used_in_output_addr[i], regno)\n+\t    || TEST_HARD_REG_BIT (reload_reg_used_in_outaddr_addr[i], regno)\n \t    || TEST_HARD_REG_BIT (reload_reg_used_in_output[i], regno))\n \t  return 0;\n \n@@ -4741,6 +4827,7 @@ reload_reg_reaches_end_p (regno, opnum, type)\n     case RELOAD_FOR_OPADDR_ADDR:\n       for (i = 0; i < reload_n_operands; i++)\n \tif (TEST_HARD_REG_BIT (reload_reg_used_in_output_addr[i], regno)\n+\t    || TEST_HARD_REG_BIT (reload_reg_used_in_outaddr_addr[i], regno)\n \t    || TEST_HARD_REG_BIT (reload_reg_used_in_output[i], regno))\n \t  return 0;\n \n@@ -4757,10 +4844,12 @@ reload_reg_reaches_end_p (regno, opnum, type)\n \n     case RELOAD_FOR_OUTPUT:\n     case RELOAD_FOR_OUTPUT_ADDRESS:\n+    case RELOAD_FOR_OUTADDR_ADDRESS:\n       /* We already know these can't conflict with a later output.  So the\n \t only thing to check are later output addresses.  */\n       for (i = opnum + 1; i < reload_n_operands; i++)\n-\tif (TEST_HARD_REG_BIT (reload_reg_used_in_output_addr[i], regno))\n+\tif (TEST_HARD_REG_BIT (reload_reg_used_in_output_addr[i], regno)\n+\t    || TEST_HARD_REG_BIT (reload_reg_used_in_outaddr_addr[i], regno))\n \t  return 0;\n \n       return 1;\n@@ -4796,16 +4885,26 @@ reloads_conflict (r1, r2)\n \t      || r2_type == RELOAD_FOR_OPERAND_ADDRESS\n \t      || r2_type == RELOAD_FOR_OPADDR_ADDR\n \t      || r2_type == RELOAD_FOR_INPUT\n-\t      || (r2_type == RELOAD_FOR_INPUT_ADDRESS && r2_opnum > r1_opnum));\n+\t      || ((r2_type == RELOAD_FOR_INPUT_ADDRESS\n+\t\t   || r2_type == RELOAD_FOR_INPADDR_ADDRESS)\n+\t\t  && r2_opnum > r1_opnum));\n \n     case RELOAD_FOR_INPUT_ADDRESS:\n       return ((r2_type == RELOAD_FOR_INPUT_ADDRESS && r1_opnum == r2_opnum)\n \t      || (r2_type == RELOAD_FOR_INPUT && r2_opnum < r1_opnum));\n \n+    case RELOAD_FOR_INPADDR_ADDRESS:\n+      return ((r2_type == RELOAD_FOR_INPADDR_ADDRESS && r1_opnum == r2_opnum)\n+\t      || (r2_type == RELOAD_FOR_INPUT && r2_opnum < r1_opnum));\n+\n     case RELOAD_FOR_OUTPUT_ADDRESS:\n       return ((r2_type == RELOAD_FOR_OUTPUT_ADDRESS && r2_opnum == r1_opnum)\n \t      || (r2_type == RELOAD_FOR_OUTPUT && r2_opnum >= r1_opnum));\n \n+    case RELOAD_FOR_OUTADDR_ADDRESS:\n+      return ((r2_type == RELOAD_FOR_OUTADDR_ADDRESS && r2_opnum == r1_opnum)\n+\t      || (r2_type == RELOAD_FOR_OUTPUT && r2_opnum >= r1_opnum));\n+\n     case RELOAD_FOR_OPERAND_ADDRESS:\n       return (r2_type == RELOAD_FOR_INPUT || r2_type == RELOAD_FOR_INSN\n \t      || r2_type == RELOAD_FOR_OPERAND_ADDRESS);\n@@ -4816,7 +4915,8 @@ reloads_conflict (r1, r2)\n \n     case RELOAD_FOR_OUTPUT:\n       return (r2_type == RELOAD_FOR_INSN || r2_type == RELOAD_FOR_OUTPUT\n-\t      || (r2_type == RELOAD_FOR_OUTPUT_ADDRESS\n+\t      || ((r2_type == RELOAD_FOR_OUTPUT_ADDRESS\n+\t\t   || r2_type == RELOAD_FOR_OUTADDR_ADDRESS)\n \t\t  && r2_opnum >= r1_opnum));\n \n     case RELOAD_FOR_INSN:\n@@ -5078,7 +5178,9 @@ choose_reload_regs (insn, avoid_return_reg)\n   int save_reload_spill_index[MAX_RELOADS];\n   HARD_REG_SET save_reload_reg_used;\n   HARD_REG_SET save_reload_reg_used_in_input_addr[MAX_RECOG_OPERANDS];\n+  HARD_REG_SET save_reload_reg_used_in_inpaddr_addr[MAX_RECOG_OPERANDS];\n   HARD_REG_SET save_reload_reg_used_in_output_addr[MAX_RECOG_OPERANDS];\n+  HARD_REG_SET save_reload_reg_used_in_outaddr_addr[MAX_RECOG_OPERANDS];\n   HARD_REG_SET save_reload_reg_used_in_input[MAX_RECOG_OPERANDS];\n   HARD_REG_SET save_reload_reg_used_in_output[MAX_RECOG_OPERANDS];\n   HARD_REG_SET save_reload_reg_used_in_op_addr;\n@@ -5103,7 +5205,9 @@ choose_reload_regs (insn, avoid_return_reg)\n       CLEAR_HARD_REG_SET (reload_reg_used_in_output[i]);\n       CLEAR_HARD_REG_SET (reload_reg_used_in_input[i]);\n       CLEAR_HARD_REG_SET (reload_reg_used_in_input_addr[i]);\n+      CLEAR_HARD_REG_SET (reload_reg_used_in_inpaddr_addr[i]);\n       CLEAR_HARD_REG_SET (reload_reg_used_in_output_addr[i]);\n+      CLEAR_HARD_REG_SET (reload_reg_used_in_outaddr_addr[i]);\n     }\n \n #ifdef SMALL_REGISTER_CLASSES\n@@ -5242,8 +5346,12 @@ choose_reload_regs (insn, avoid_return_reg)\n \t\t\t reload_reg_used_in_input[i]);\n       COPY_HARD_REG_SET (save_reload_reg_used_in_input_addr[i],\n \t\t\t reload_reg_used_in_input_addr[i]);\n+      COPY_HARD_REG_SET (save_reload_reg_used_in_inpaddr_addr[i],\n+\t\t\t reload_reg_used_in_inpaddr_addr[i]);\n       COPY_HARD_REG_SET (save_reload_reg_used_in_output_addr[i],\n \t\t\t reload_reg_used_in_output_addr[i]);\n+      COPY_HARD_REG_SET (save_reload_reg_used_in_outaddr_addr[i],\n+\t\t\t reload_reg_used_in_outaddr_addr[i]);\n     }\n \n   /* If -O, try first with inheritance, then turning it off.\n@@ -5621,8 +5729,12 @@ choose_reload_regs (insn, avoid_return_reg)\n \t\t\t     save_reload_reg_used_in_output[i]);\n \t  COPY_HARD_REG_SET (reload_reg_used_in_input_addr[i],\n \t\t\t     save_reload_reg_used_in_input_addr[i]);\n+\t  COPY_HARD_REG_SET (reload_reg_used_in_inpaddr_addr[i],\n+\t\t\t     save_reload_reg_used_in_inpaddr_addr[i]);\n \t  COPY_HARD_REG_SET (reload_reg_used_in_output_addr[i],\n \t\t\t     save_reload_reg_used_in_output_addr[i]);\n+\t  COPY_HARD_REG_SET (reload_reg_used_in_outaddr_addr[i],\n+\t\t\t     save_reload_reg_used_in_outaddr_addr[i]);\n \t}\n     }\n \n@@ -5796,8 +5908,9 @@ merge_assigned_reloads (insn)\n \t\t  && reg_overlap_mentioned_for_reload_p (reload_in[j],\n \t\t\t\t\t\t\t reload_in[i]))\n \t\treload_when_needed[j]\n-\t\t  = reload_when_needed[i] == RELOAD_FOR_INPUT_ADDRESS\n-\t\t    ? RELOAD_FOR_OTHER_ADDRESS : RELOAD_OTHER;\n+\t\t  = ((reload_when_needed[i] == RELOAD_FOR_INPUT_ADDRESS\n+\t\t      || reload_when_needed[i] == RELOAD_FOR_INPADDR_ADDRESS)\n+\t\t     ? RELOAD_FOR_OTHER_ADDRESS : RELOAD_OTHER);\n \t}\n     }\n }\t    \n@@ -5814,8 +5927,10 @@ emit_reload_insns (insn)\n   rtx other_input_address_reload_insns = 0;\n   rtx other_input_reload_insns = 0;\n   rtx input_address_reload_insns[MAX_RECOG_OPERANDS];\n+  rtx inpaddr_address_reload_insns[MAX_RECOG_OPERANDS];\n   rtx output_reload_insns[MAX_RECOG_OPERANDS];\n   rtx output_address_reload_insns[MAX_RECOG_OPERANDS];\n+  rtx outaddr_address_reload_insns[MAX_RECOG_OPERANDS];\n   rtx operand_reload_insns = 0;\n   rtx other_operand_reload_insns = 0;\n   rtx other_output_reload_insns[MAX_RECOG_OPERANDS];\n@@ -5827,7 +5942,9 @@ emit_reload_insns (insn)\n \n   for (j = 0; j < reload_n_operands; j++)\n     input_reload_insns[j] = input_address_reload_insns[j]\n+      = inpaddr_address_reload_insns[j]\n       = output_reload_insns[j] = output_address_reload_insns[j]\n+      = outaddr_address_reload_insns[j]\n       = other_output_reload_insns[j] = 0;\n \n   /* Now output the instructions to copy the data into and out of the\n@@ -6022,9 +6139,15 @@ emit_reload_insns (insn)\n \t    case RELOAD_FOR_INPUT_ADDRESS:\n \t      where = &input_address_reload_insns[reload_opnum[j]];\n \t      break;\n+\t    case RELOAD_FOR_INPADDR_ADDRESS:\n+\t      where = &inpaddr_address_reload_insns[reload_opnum[j]];\n+\t      break;\n \t    case RELOAD_FOR_OUTPUT_ADDRESS:\n \t      where = &output_address_reload_insns[reload_opnum[j]];\n \t      break;\n+\t    case RELOAD_FOR_OUTADDR_ADDRESS:\n+\t      where = &outaddr_address_reload_insns[reload_opnum[j]];\n+\t      break;\n \t    case RELOAD_FOR_OPERAND_ADDRESS:\n \t      where = &operand_reload_insns;\n \t      break;\n@@ -6627,25 +6750,28 @@ emit_reload_insns (insn)\n \n      RELOAD_OTHER reloads.\n \n-     For each operand, any RELOAD_FOR_INPUT_ADDRESS reloads followed by\n-     the RELOAD_FOR_INPUT reload for the operand.\n+     For each operand, any RELOAD_FOR_INPADDR_ADDRESS reloads followed\n+     by any RELOAD_FOR_INPUT_ADDRESS reloads followed by the\n+     RELOAD_FOR_INPUT reload for the operand.\n \n      RELOAD_FOR_OPADDR_ADDRS reloads.\n \n      RELOAD_FOR_OPERAND_ADDRESS reloads.\n \n      After the insn being reloaded, we write the following:\n \n-     For each operand, any RELOAD_FOR_OUTPUT_ADDRESS reload followed by\n-     the RELOAD_FOR_OUTPUT reload, followed by any RELOAD_OTHER output\n-     reloads for the operand.  The RELOAD_OTHER output reloads are output\n-     in descending order by reload number.  */\n+     For each operand, any RELOAD_FOR_OUTADDR_ADDRESS reloads followed\n+     by any RELOAD_FOR_OUTPUT_ADDRESS reload followed by the\n+     RELOAD_FOR_OUTPUT reload, followed by any RELOAD_OTHER output\n+     reloads for the operand.  The RELOAD_OTHER output reloads are\n+     output in descending order by reload number.  */\n \n   emit_insns_before (other_input_address_reload_insns, before_insn);\n   emit_insns_before (other_input_reload_insns, before_insn);\n \n   for (j = 0; j < reload_n_operands; j++)\n     {\n+      emit_insns_before (inpaddr_address_reload_insns[j], before_insn);\n       emit_insns_before (input_address_reload_insns[j], before_insn);\n       emit_insns_before (input_reload_insns[j], before_insn);\n     }\n@@ -6655,6 +6781,7 @@ emit_reload_insns (insn)\n \n   for (j = 0; j < reload_n_operands; j++)\n     {\n+      emit_insns_before (outaddr_address_reload_insns[j], following_insn);\n       emit_insns_before (output_address_reload_insns[j], following_insn);\n       emit_insns_before (output_reload_insns[j], following_insn);\n       emit_insns_before (other_output_reload_insns[j], following_insn);"}]}