{"sha": "5d09245e6a54b290b5f44b686214b41cf555152a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWQwOTI0NWU2YTU0YjI5MGI1ZjQ0YjY4NjIxNGI0MWNmNTU1MTUyYQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-08-09T12:24:25Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-08-09T12:24:25Z"}, "message": "[multiple changes]\n\n2004-08-09  Thomas Quinot  <quinot@act-europe.fr>\n\n\t* g-socket.adb (Abort_Selector): Initialize Buf to prevent valgrind\n\tfrom complaining on potential uninitialized reference.\n\tChange calls to GNAT.Sockets.Thin.Is_Socket_In_Set to account for\n\tnew specification and test explicitly for non-zero return value.\n\n\t* g-socthi.ads (Is_Socket_In_Set): Declare imported function as\n\treturning C.int, to avoid using a derived boolean type.\n\n\t* exp_ch5.adb (Make_Tag_Ctrl_Assignments): Use\n\tDuplicate_Subexpr_No_Checks in preference to direct use of\n\tRemove_Side_Effects and New_Copy_Tree.\n\tClear Comes_From_Source on prefix of 'Size attribute reference.\n\n\t* g-socthi.adb, g-socthi-vms.adb, g-socthi-mingw.adb,\n\tg-socthi-vxworks.adb: Change calls to\n\tGNAT.Sockets.Thin.Is_Socket_In_Set to account for new specification\n\tand test explicitly for non-zero return value.\n\n\t* g-socthi-vms.ads, g-socthi-mingw.ads, g-socthi-vxworks.ads:\n\t(Is_Socket_In_Set): Declare imported function as returning C.int, to\n\tavoid using a derived boolean type.\n\n2004-08-09  Albert Lee  <lee@gnat.com>\n\n\t* system-irix-n32.ads: Refine tasking priority constants for IRIX.\n\n2004-08-09  Pascal Obry  <obry@gnat.com>\n\n\t* gnat_ugn.texi: Document new way to build DLLs on Windows using\n\tGCC's -shared option.\n\n\t* mlib-tgt-mingw.adb (Build_Dynamic_Library): Pass GCC's options into\n\tOptions_2 parameter (options put after object files).\n\n2004-08-09  Olivier Hainque  <hainque@act-europe.fr>\n\n\t* decl.c (gnat_to_gnu_entity) <E_Array_Subtype>: Adjust condition to\n\tignore overflows on low and high bounds of an index to also account for\n\tdifferences in signedness between sizetype and gnu_index_subtype.\n\tThese are as legitimate as the ones caused by a lower TYPE_PRECISION\n\ton sizetype.\n\n2004-08-09  Robert Dewar  <dewar@gnat.com>\n\n\t* s-solita.ads, s-solita.adb: Minor reformatting\n\n\t* gnat_rm.texi: Add documentation for pragma Profile (Restricted)\n\tMove pragma Restricted_Run_Time, No_Run_Time, Ravenscar to new\n\tobsolescent section\n\tAdd note that No_Implicit_Conditionals does not suppress\n\trun time constraint checks.\n\n\t* vms_conv.ads: Minor reformatting\n\n\t* s-secsta.adb: Use SS_Ptr instead of Mark_Id as stack pointer (cleanup\n\tand necessary for following change).\n\t(Mark): Return new format Mark_Id containing sec stack address\n\t(Release): Use sec stack address from Mark_Id avoiding Self call\n\n\t* s-secsta.ads: Define SS_Ptr to be used instead of Mark_Id as stack\n\tpointer (cleanup and necessary for following change).\n\tDefine Mark_Id as record containing address of secondary stack, that way\n\tRelease does not need to find the stack again, decreasing the number of\n\tcalls to Self and improving efficiency.\n\n\t* sem_util.ads: Add a ??? comment for Is_Local_Variable_Reference\n\n\t* sem_ch5.adb (Analyze_Case_Statement): Add circuitry to track value of\n\tcase variable into the individual case branches when possible.\n\n\t* sem_ch11.adb: Minor reformatting\n\n\t* prj.ads: Correct spelling of suffixs\n\n\t* prj-nmsc.adb: Minor reformatting\n\tCorrect spelling suffixs throughout (also in identifiers)\n\n\t* freeze.adb: Minor spelling correction\n\n\t* exp_ch2.adb: Cleanups to handling of Current_Value\n\t(no functional effect).\n\n\t* bld.adb: Correct spelling of suffixs\n\n\t* einfo.adb (Enclosing_Dynamic_Scope): Defend against junk argument\n\n2004-08-09  Ed Schonberg  <schonberg@gnat.com>\n\n\tPR ada/15408\n\n\t* sem_ch7.adb (Install_Private_Declarations): In the body of the\n\tpackage or of a child, private entities are both immediately_visible\n\tand not hidden.\n\n2004-08-09  Ed Schonberg  <schonberg@gnat.com>\n\n\t* sem_eval.adb (Eval_Integer_Literal): If the context is Any_Integer,\n\tthere are no range checks on the value of the literal.\n\n\t* exp_ch7.adb (Insert_Actions_In_Scope_Around): If the node being\n\twrapped is the triggering alternative of an asynchronous select, action\n\tstatements mustbe inserted before the select itself.\n\n\t* sem_attr.adb (Analyze_Attribute, case 'Size): Handle properly the\n\tcase where the prefix is a protected function call.\n\t(Resolve_Attribute, case 'Access): The attribute reference on a\n\tsubprogram is legal in a generic body if the subprogram is declared\n\telsewhere.\n\n2004-08-09  Vincent Celier  <celier@gnat.com>\n\n\t* makegpr.adb (Build_Library): Link with g++ if C++ is one of the\n\tlanguages, otherwise building the library may fail with unresolved\n\tsymbols.\n\t(Compile_Sources): Do not build libraries if -c switch is used\n\n\t* gnatlink.adb (Process_Args): New switches -M and -Mmap\n\t(Write_Usage): If map file creation is supported, output new switches\n\t-M and -Mmap.\n\t(Gnatlink): When -M is specified, add the necessary switch(es) to the\n\tgcc call, when supported.\n\n\t* Makefile.in: Added indepsw.o to the object list for gnatlink\n\tSpecified the AIX, GNU/Linux and Windows versions of indepsw.adb\n\n\t* indepsw-aix.adb, indepsw-linux.adb, indepsw-mingw.adb,\n\tindepsw.adb, indepsw.ads: New files.\n\n2004-08-09  Bernard Banner  <banner@gnat.com>\n\n\t* system-vxworks-x86.ads, s-vxwork-x86.ads: New files.\n\n\t* Makefile.in: add section for vxworks x86\n\n2004-08-09  Hristian Kirtchev  <kirtchev@gnat.com>\n\n\t* exp_ch3.adb (Build_Init_Statements): Add extra condition to deal with\n\tper-object constrained components where the discriminant is of an\n\tAccess type.\n\t(Build_Record_Init_Proc): Add condition to prevent the inheritance of\n\tthe parent initialization procedure for derived Unchecked_Unions.\n\tInstead, derived Unchecked_Unions build their own initialization\n\tprocedure.\n\t(Build_Variant_Record_Equality): Implement Unchecked_Union equality.\n\tCheck the body of the subprogram for details.\n\t(Freeze_Record_Type): Prevent the inheritance of discriminant checking\n\tfunctions for derived Unchecked_Union types by introducing a condition.\n\tAllow the creation of TSS equality functions for Unchecked_Unions.\n\t(Make_Eq_Case): Rename formal parameter Node to E in function signature.\n\tAdd formal parameter Discr to function signature. Discr is used to\n\tcontrol the generated case statement for Unchecked_Union types.\n\t(Make_Eq_If): Rename formal parameter Node to E in function signature.\n\n\t* exp_ch4.adb (Build_Equality_Call): Implement equality calls for\n\tUnchecked_Unions.\n\tCheck the body of the subprogram for details.\n\t(Expand_Composite_Equality): Augment composite type equality to include\n\tcorrect handling of Unchecked_Union components.\n\t(Expand_N_In): Add condition to detect illegal membership tests when the\n\tsubtype mark is a constrained Unchecked_Union and the expression lacks\n\tinferable discriminants, and build a Raise_Program_Error node.\n\t(Expand_N_Op_Eq): Add function Has_Unconstrained_UU_Component. Used\n\tto detect types that contain components of unconstrained Unchecked_Union\n\tsubtype. Add condition to detect equality between types that have an\n\tunconstrained Unchecked_Union component, and build a Raise_Program_Error\n\tnode. Add condition to detect equality between Unchecked_Union types\n\tthat lack inferable discriminants, and build a Raise_Program_Error node.\n\tOtherwise build a TSS equality function call.\n\t(Expand_N_Type_Conversion): Add condition to detect illegal conversions\n\tfrom a derived Unchecked_Union to an unconstrained non-Unchecked_Union\n\twith the operand lacking inferable discriminants, and build a Raise_\n\tProgram_Error node.\n\t(Expand_Record_Equality): Remove guard that prevents Unchecked_Union\n\tcomposite equality.\n\t(Has_Inferable_Discriminants): Implement new predicate for objects and\n\texpressions of Unchecked_Union type. Check the body of subprogram for\n\tdetails.\n\t(Has_Unconstrained_UU_Components): Add function\n\tComponent_Is_Unconstrained_UU. It is used to detect whether a single\n\tcomponent is of an unconstrained Unchecked_Union subtype. Add function\n\tVariant_Is_Unconstrained_UU. It is used to detect whether a single\n\tcomponent inside a variant is of an unconstrained Unchecked_Union type.\n\n\t* exp_ch5.adb (Expand_Assign_Record): Add condition to copy the\n\tinferred discriminant values. Add condition to generate a case\n\tstatement with an inferred discriminant as the switch.\n\t(Make_Component_List_Assign): Introduce a Boolean flag that determines\n\tthe behaviour of the subprogram in the presence of an Unchecked_Union.\n\tAdd condition to trigger the usage of the inferred discriminant value\n\tas the generated case statement switch.\n\t(Make_Field_Assign): Introduce a Boolean flag that determines the\n\tbehaviour of the subprogram in the presence of an Unchecked_Union. Add\n\tcondition to trigger the usage of the inferred discriminant value as\n\tthe right-hand side of the generated assignment.\n\n\t* exp_ch6.adb (Expand_Call): Add condition to skip extra actual\n\tparameter generation when dealing with Unchecked_Unions.\n\n\t* checks.adb (Apply_Discriminant_Check): Do not apply discriminant\n\tchecks for Unchecked_Unions.\n\n\t* einfo.ads: Update comment on usage of flag Has_Per_Object_Constraint\n\n\t* exp_attr.adb (Expand_N_Attribute_Reference): Produce\n\tRaise_Program_Error nodes for the execution of Read and Write\n\tattributes of Unchecked_Union types and the execution of Input and\n\tOutput attributes of Unchecked_Union types that lack default\n\tdiscriminant values.\n\n\t* sem_prag.adb (Analyze_Pragma): Remodel the analysis of pragma\n\tUnchecked_Union. Add procedure Check_Component. It is used to inspect\n\tper-object constrained components of Unchecked_Unions for being\n\tUnchecked_Unions themselves. Add procedure Check_Variant. It is used to\n\tcheck individual components withing a variant.\n\n\t* sem_res.adb (Resolve_Comparison_Op): Remove guard that prevents\n\tcomparison of Unchecked_Unions.\n\t(Resolve_Equality_OP): Remove guard that prevents equality between\n\tUnchecked_Unions.\n\n\t* sem_util.adb (Build_Component_Subtype): Add guard to prevent creation\n\tof component subtypes for Unchecked_Union components.\n\t(Get_Actual_Subtype): Add condition that returs the Unchecked_Union type\n\tsince it is the actual subtype.\n\n\t* sem_ch12.adb (Instantiate_Type): Add condition to detect the correct\n\tpass of Unchecked_Union subtypes as generic actuals to formal types\n\tthat lack known_discriminant_parts or that are derived Unchecked_Union\n\ttypes, and do nothing. In any other case, produce an error message.\n\n\t* sem_ch3.adb (Analyze_Component_Declaration): Add function\n\tContains_POC. It determines whether a constraint uses the discriminant\n\tof an enclosing record type.\n\tAdd condition to detect per-object constrained component and set the\n\tappropriate flag.\n\t(Derived_Type_Declaration): Remove guard that prevents derivation from\n\tUnchecked_Union types.\n\t(Process_Subtype): Remove quard that prevents the creation of Unchecked_\n\tUnion subtypes.\n\n\t* sem_ch4.adb (Analyze_Selected_Component): Correct the detection of\n\treferences to Unchecked_Union discriminants.\n\n\t* sem_ch6.adb (Create_Extra_Formals): Add condition to skip extra\n\tformal generation when dealing with Unchecked_Unions.\n\t(Set_Actual_Subtypes): Add condition to prevent generation of actual\n\tsubtypes for Unchecked_Unions.\n\n\t* sem_ch7.adb (Analyze_Package_Specification): Add procedure\n\tInspect_Unchecked_Union_Completion. It is used to detect incorrect\n\tcompletions of discriminated partial views by Unchecked_Unions and\n\tproduce an error message.\n\n2004-08-09  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n\n\t* trans.c (struct stmt_group): New field, GLOBAL.\n\t(global_stmt_group, gnu_elab_proc_decl, build_unit_elab): Deleted.\n\t(struct elab_info): New struct.\n\t(elab_info_list, gnu_elab_proc_stack): New variables.\n\t(Compilation_Unit_to_gnu): New procedure.\n\t(gigi): Call it and also handle elaboration procs we've saved.\n\t(gnat_init_stmt_group): Don't set global_stmt_group; instead initialize\n\tglobal field from parent.\n\t(gnat_to_gnu): Get decl from gnu_elab_proc_stack.\n\t(gnat_to_gnu, case N_Compilation_Unit): Call Compilation_Unit_to_gnu.\n\t(start_stmt_group): Initialize global field from parent.\n\t(add_decl_expr): Set to global for current statement group.\n\t(gnat_gimplify_expr, case NULL_EXPR): Add operand 0 to pre list, not\n\tpost.\n\n\t* utils.c (global_bindings_p): True when no current_function_decl; no\n\tlonger check current_binding_level.\n\n2004-08-09  Ben Brosgol  <brosgol@gnat.com>\n\n\t* xgnatugn.adb: Added logic to deal with @ifset/@ifclear for edition\n\tchoice.\n\n\t* gnat_rm.texi, gnat_ugn.texi: Added edition conditionalization logic.\n\nFrom-SVN: r85714", "tree": {"sha": "395000c4629fbf7cd7f7141f5caa3a8080d5dd8e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/395000c4629fbf7cd7f7141f5caa3a8080d5dd8e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5d09245e6a54b290b5f44b686214b41cf555152a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d09245e6a54b290b5f44b686214b41cf555152a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d09245e6a54b290b5f44b686214b41cf555152a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d09245e6a54b290b5f44b686214b41cf555152a/comments", "author": null, "committer": null, "parents": [{"sha": "b3bcf92c93a54c6f8be4eab8e5056a671af21e3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3bcf92c93a54c6f8be4eab8e5056a671af21e3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3bcf92c93a54c6f8be4eab8e5056a671af21e3c"}], "stats": {"total": 4010, "additions": 3204, "deletions": 806}, "files": [{"sha": "daf1367a866fd29f21c4e1fcbe3745d8e98e6ffc", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 282, "deletions": 0, "changes": 282, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=5d09245e6a54b290b5f44b686214b41cf555152a", "patch": "@@ -1,3 +1,285 @@\n+2004-08-09  Thomas Quinot  <quinot@act-europe.fr>\n+\n+\t* g-socket.adb (Abort_Selector): Initialize Buf to prevent valgrind\n+\tfrom complaining on potential uninitialized reference.\n+\tChange calls to GNAT.Sockets.Thin.Is_Socket_In_Set to account for\n+\tnew specification and test explicitly for non-zero return value.\n+\n+\t* g-socthi.ads (Is_Socket_In_Set): Declare imported function as\n+\treturning C.int, to avoid using a derived boolean type.\n+\n+\t* exp_ch5.adb (Make_Tag_Ctrl_Assignments): Use\n+\tDuplicate_Subexpr_No_Checks in preference to direct use of\n+\tRemove_Side_Effects and New_Copy_Tree.\n+\tClear Comes_From_Source on prefix of 'Size attribute reference.\n+\n+\t* g-socthi.adb, g-socthi-vms.adb, g-socthi-mingw.adb,\n+\tg-socthi-vxworks.adb: Change calls to\n+\tGNAT.Sockets.Thin.Is_Socket_In_Set to account for new specification\n+\tand test explicitly for non-zero return value.\n+\n+\t* g-socthi-vms.ads, g-socthi-mingw.ads, g-socthi-vxworks.ads: \n+\t(Is_Socket_In_Set): Declare imported function as returning C.int, to\n+\tavoid using a derived boolean type.\n+\n+2004-08-09  Albert Lee  <lee@gnat.com>\n+\n+\t* system-irix-n32.ads: Refine tasking priority constants for IRIX.\n+\n+2004-08-09  Pascal Obry  <obry@gnat.com>\n+\n+\t* gnat_ugn.texi: Document new way to build DLLs on Windows using\n+\tGCC's -shared option.\n+\n+\t* mlib-tgt-mingw.adb (Build_Dynamic_Library): Pass GCC's options into\n+\tOptions_2 parameter (options put after object files).\n+\n+2004-08-09  Olivier Hainque  <hainque@act-europe.fr>\n+\n+\t* decl.c (gnat_to_gnu_entity) <E_Array_Subtype>: Adjust condition to\n+\tignore overflows on low and high bounds of an index to also account for\n+\tdifferences in signedness between sizetype and gnu_index_subtype.\n+\tThese are as legitimate as the ones caused by a lower TYPE_PRECISION\n+\ton sizetype.\n+\n+2004-08-09  Robert Dewar  <dewar@gnat.com>\n+\n+\t* s-solita.ads, s-solita.adb: Minor reformatting\n+\n+\t* gnat_rm.texi: Add documentation for pragma Profile (Restricted)\n+\tMove pragma Restricted_Run_Time, No_Run_Time, Ravenscar to new\n+\tobsolescent section\n+\tAdd note that No_Implicit_Conditionals does not suppress\n+\trun time constraint checks.\n+\n+\t* vms_conv.ads: Minor reformatting\n+\n+\t* s-secsta.adb: Use SS_Ptr instead of Mark_Id as stack pointer (cleanup\n+\tand necessary for following change).\n+\t(Mark): Return new format Mark_Id containing sec stack address\n+\t(Release): Use sec stack address from Mark_Id avoiding Self call\n+\n+\t* s-secsta.ads: Define SS_Ptr to be used instead of Mark_Id as stack\n+\tpointer (cleanup and necessary for following change).\n+\tDefine Mark_Id as record containing address of secondary stack, that way\n+\tRelease does not need to find the stack again, decreasing the number of\n+\tcalls to Self and improving efficiency.\n+\n+\t* sem_util.ads: Add a ??? comment for Is_Local_Variable_Reference\n+\n+\t* sem_ch5.adb (Analyze_Case_Statement): Add circuitry to track value of\n+\tcase variable into the individual case branches when possible.\n+\n+\t* sem_ch11.adb: Minor reformatting\n+\n+\t* prj.ads: Correct spelling of suffixs\n+\n+\t* prj-nmsc.adb: Minor reformatting\n+\tCorrect spelling suffixs throughout (also in identifiers)\n+\n+\t* freeze.adb: Minor spelling correction\n+\n+\t* exp_ch2.adb: Cleanups to handling of Current_Value\n+\t(no functional effect).\n+\n+\t* bld.adb: Correct spelling of suffixs\n+\n+\t* einfo.adb (Enclosing_Dynamic_Scope): Defend against junk argument\n+\n+2004-08-09  Ed Schonberg  <schonberg@gnat.com>\n+\n+\tPR ada/15408\n+\n+\t* sem_ch7.adb (Install_Private_Declarations): In the body of the\n+\tpackage or of a child, private entities are both immediately_visible\n+\tand not hidden.\n+\n+2004-08-09  Ed Schonberg  <schonberg@gnat.com>\n+\n+\t* sem_eval.adb (Eval_Integer_Literal): If the context is Any_Integer,\n+\tthere are no range checks on the value of the literal.\n+\n+\t* exp_ch7.adb (Insert_Actions_In_Scope_Around): If the node being\n+\twrapped is the triggering alternative of an asynchronous select, action\n+\tstatements mustbe inserted before the select itself.\n+\n+\t* sem_attr.adb (Analyze_Attribute, case 'Size): Handle properly the\n+\tcase where the prefix is a protected function call.\n+\t(Resolve_Attribute, case 'Access): The attribute reference on a\n+\tsubprogram is legal in a generic body if the subprogram is declared\n+\telsewhere.\n+\n+2004-08-09  Vincent Celier  <celier@gnat.com>\n+\n+\t* makegpr.adb (Build_Library): Link with g++ if C++ is one of the\n+\tlanguages, otherwise building the library may fail with unresolved\n+\tsymbols.\n+\t(Compile_Sources): Do not build libraries if -c switch is used\n+\n+\t* gnatlink.adb (Process_Args): New switches -M and -Mmap\n+\t(Write_Usage): If map file creation is supported, output new switches\n+\t-M and -Mmap.\n+\t(Gnatlink): When -M is specified, add the necessary switch(es) to the\n+\tgcc call, when supported.\n+\n+\t* Makefile.in: Added indepsw.o to the object list for gnatlink\n+\tSpecified the AIX, GNU/Linux and Windows versions of indepsw.adb\n+\n+\t* indepsw-aix.adb, indepsw-linux.adb, indepsw-mingw.adb,\n+\tindepsw.adb, indepsw.ads: New files.\n+\n+2004-08-09  Bernard Banner  <banner@gnat.com>\n+\n+\t* system-vxworks-x86.ads, s-vxwork-x86.ads: New files.\n+\n+\t* Makefile.in: add section for vxworks x86\n+\n+2004-08-09  Hristian Kirtchev  <kirtchev@gnat.com>\n+\n+\t* exp_ch3.adb (Build_Init_Statements): Add extra condition to deal with\n+\tper-object constrained components where the discriminant is of an\n+\tAccess type.\n+\t(Build_Record_Init_Proc): Add condition to prevent the inheritance of\n+\tthe parent initialization procedure for derived Unchecked_Unions.\n+\tInstead, derived Unchecked_Unions build their own initialization\n+\tprocedure.\n+\t(Build_Variant_Record_Equality): Implement Unchecked_Union equality.\n+\tCheck the body of the subprogram for details.\n+\t(Freeze_Record_Type): Prevent the inheritance of discriminant checking\n+\tfunctions for derived Unchecked_Union types by introducing a condition.\n+\tAllow the creation of TSS equality functions for Unchecked_Unions.\n+\t(Make_Eq_Case): Rename formal parameter Node to E in function signature.\n+\tAdd formal parameter Discr to function signature. Discr is used to\n+\tcontrol the generated case statement for Unchecked_Union types.\n+\t(Make_Eq_If): Rename formal parameter Node to E in function signature.\n+\n+\t* exp_ch4.adb (Build_Equality_Call): Implement equality calls for\n+\tUnchecked_Unions.\n+\tCheck the body of the subprogram for details.\n+\t(Expand_Composite_Equality): Augment composite type equality to include\n+\tcorrect handling of Unchecked_Union components.\n+\t(Expand_N_In): Add condition to detect illegal membership tests when the\n+\tsubtype mark is a constrained Unchecked_Union and the expression lacks\n+\tinferable discriminants, and build a Raise_Program_Error node.\n+\t(Expand_N_Op_Eq): Add function Has_Unconstrained_UU_Component. Used\n+\tto detect types that contain components of unconstrained Unchecked_Union\n+\tsubtype. Add condition to detect equality between types that have an\n+\tunconstrained Unchecked_Union component, and build a Raise_Program_Error\n+\tnode. Add condition to detect equality between Unchecked_Union types\n+\tthat lack inferable discriminants, and build a Raise_Program_Error node.\n+\tOtherwise build a TSS equality function call.\n+\t(Expand_N_Type_Conversion): Add condition to detect illegal conversions\n+\tfrom a derived Unchecked_Union to an unconstrained non-Unchecked_Union\n+\twith the operand lacking inferable discriminants, and build a Raise_\n+\tProgram_Error node.\n+\t(Expand_Record_Equality): Remove guard that prevents Unchecked_Union\n+\tcomposite equality.\n+\t(Has_Inferable_Discriminants): Implement new predicate for objects and\n+\texpressions of Unchecked_Union type. Check the body of subprogram for\n+\tdetails.\n+\t(Has_Unconstrained_UU_Components): Add function\n+\tComponent_Is_Unconstrained_UU. It is used to detect whether a single\n+\tcomponent is of an unconstrained Unchecked_Union subtype. Add function\n+\tVariant_Is_Unconstrained_UU. It is used to detect whether a single\n+\tcomponent inside a variant is of an unconstrained Unchecked_Union type.\n+\n+\t* exp_ch5.adb (Expand_Assign_Record): Add condition to copy the\n+\tinferred discriminant values. Add condition to generate a case\n+\tstatement with an inferred discriminant as the switch.\n+\t(Make_Component_List_Assign): Introduce a Boolean flag that determines\n+\tthe behaviour of the subprogram in the presence of an Unchecked_Union.\n+\tAdd condition to trigger the usage of the inferred discriminant value\n+\tas the generated case statement switch.\n+\t(Make_Field_Assign): Introduce a Boolean flag that determines the\n+\tbehaviour of the subprogram in the presence of an Unchecked_Union. Add\n+\tcondition to trigger the usage of the inferred discriminant value as\n+\tthe right-hand side of the generated assignment.\n+\n+\t* exp_ch6.adb (Expand_Call): Add condition to skip extra actual\n+\tparameter generation when dealing with Unchecked_Unions.\n+\n+\t* checks.adb (Apply_Discriminant_Check): Do not apply discriminant\n+\tchecks for Unchecked_Unions.\n+\n+\t* einfo.ads: Update comment on usage of flag Has_Per_Object_Constraint\n+\n+\t* exp_attr.adb (Expand_N_Attribute_Reference): Produce\n+\tRaise_Program_Error nodes for the execution of Read and Write\n+\tattributes of Unchecked_Union types and the execution of Input and\n+\tOutput attributes of Unchecked_Union types that lack default\n+\tdiscriminant values.\n+\n+\t* sem_prag.adb (Analyze_Pragma): Remodel the analysis of pragma\n+\tUnchecked_Union. Add procedure Check_Component. It is used to inspect\n+\tper-object constrained components of Unchecked_Unions for being\n+\tUnchecked_Unions themselves. Add procedure Check_Variant. It is used to\n+\tcheck individual components withing a variant.\n+\n+\t* sem_res.adb (Resolve_Comparison_Op): Remove guard that prevents\n+\tcomparison of Unchecked_Unions.\n+\t(Resolve_Equality_OP): Remove guard that prevents equality between\n+\tUnchecked_Unions.\n+\n+\t* sem_util.adb (Build_Component_Subtype): Add guard to prevent creation\n+\tof component subtypes for Unchecked_Union components.\n+\t(Get_Actual_Subtype): Add condition that returs the Unchecked_Union type\n+\tsince it is the actual subtype.\n+\n+\t* sem_ch12.adb (Instantiate_Type): Add condition to detect the correct\n+\tpass of Unchecked_Union subtypes as generic actuals to formal types\n+\tthat lack known_discriminant_parts or that are derived Unchecked_Union\n+\ttypes, and do nothing. In any other case, produce an error message.\n+\n+\t* sem_ch3.adb (Analyze_Component_Declaration): Add function\n+\tContains_POC. It determines whether a constraint uses the discriminant\n+\tof an enclosing record type.\n+\tAdd condition to detect per-object constrained component and set the\n+\tappropriate flag.\n+\t(Derived_Type_Declaration): Remove guard that prevents derivation from\n+\tUnchecked_Union types.\n+\t(Process_Subtype): Remove quard that prevents the creation of Unchecked_\n+\tUnion subtypes.\n+\n+\t* sem_ch4.adb (Analyze_Selected_Component): Correct the detection of\n+\treferences to Unchecked_Union discriminants.\n+\n+\t* sem_ch6.adb (Create_Extra_Formals): Add condition to skip extra\n+\tformal generation when dealing with Unchecked_Unions.\n+\t(Set_Actual_Subtypes): Add condition to prevent generation of actual\n+\tsubtypes for Unchecked_Unions.\n+\n+\t* sem_ch7.adb (Analyze_Package_Specification): Add procedure\n+\tInspect_Unchecked_Union_Completion. It is used to detect incorrect\n+\tcompletions of discriminated partial views by Unchecked_Unions and\n+\tproduce an error message.\n+\n+2004-08-09  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* trans.c (struct stmt_group): New field, GLOBAL.\n+\t(global_stmt_group, gnu_elab_proc_decl, build_unit_elab): Deleted.\n+\t(struct elab_info): New struct.\n+\t(elab_info_list, gnu_elab_proc_stack): New variables.\n+\t(Compilation_Unit_to_gnu): New procedure.\n+\t(gigi): Call it and also handle elaboration procs we've saved.\n+\t(gnat_init_stmt_group): Don't set global_stmt_group; instead initialize\n+\tglobal field from parent.\n+\t(gnat_to_gnu): Get decl from gnu_elab_proc_stack.\n+\t(gnat_to_gnu, case N_Compilation_Unit): Call Compilation_Unit_to_gnu.\n+\t(start_stmt_group): Initialize global field from parent.\n+\t(add_decl_expr): Set to global for current statement group.\n+\t(gnat_gimplify_expr, case NULL_EXPR): Add operand 0 to pre list, not\n+\tpost.\n+\n+\t* utils.c (global_bindings_p): True when no current_function_decl; no\n+\tlonger check current_binding_level.\n+\n+2004-08-09  Ben Brosgol  <brosgol@gnat.com>\n+\n+\t* xgnatugn.adb: Added logic to deal with @ifset/@ifclear for edition\n+\tchoice.\n+\n+\t* gnat_rm.texi, gnat_ugn.texi: Added edition conditionalization logic.\n+\n 2004-08-06  Andreas Schwab  <schwab@suse.de>\n \n \t* utils.c (gnat_define_builtin): Remove second parameter of"}, {"sha": "e3b9507c1f60451bf04f331ea35b2da56abb5faa", "filename": "gcc/ada/Makefile.in", "status": "modified", "additions": 51, "deletions": 4, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.in?ref=5d09245e6a54b290b5f44b686214b41cf555152a", "patch": "@@ -298,7 +298,7 @@ Makefile: ../config.status $(srcdir)/Makefile.in $(srcdir)/../version.c\n \n GNATLINK_OBJS = gnatlink.o \\\n  a-except.o ali.o alloc.o butil.o casing.o csets.o debug.o fmap.o fname.o gnatvsn.o \\\n- hostparm.o interfac.o i-c.o i-cstrin.o namet.o opt.o osint.o output.o rident.o \\\n+ hostparm.o indepsw.o interfac.o i-c.o i-cstrin.o namet.o opt.o osint.o output.o rident.o \\\n  s-exctab.o s-secsta.o s-stalib.o s-stoele.o sdefault.o stylesw.o switch.o system.o \\\n  table.o tree_io.o types.o validsw.o widechar.o\n \n@@ -592,6 +592,46 @@ ifeq ($(strip $(filter-out sparc% wrs vx%,$(targ))),)\n   EXTRA_GNATRTL_TASKING_OBJS=s-vxwork.o\n endif\n \n+ifeq ($(strip $(filter-out %86 wrs vxworks,$(targ))),)\n+  LIBGNAT_TARGET_PAIRS = \\\n+  a-sytaco.ads<a-sytaco-vxworks.ads \\\n+  a-sytaco.adb<a-sytaco-vxworks.adb \\\n+  a-intnam.ads<a-intnam-vxworks.ads \\\n+  s-inmaop.adb<s-inmaop-posix.adb \\\n+  s-interr.adb<s-interr-vxworks.adb \\\n+  s-intman.ads<s-intman-vxworks.ads \\\n+  s-intman.adb<s-intman-vxworks.adb \\\n+  a-numaux.adb<a-numaux-x86.adb \\\n+  a-numaux.ads<a-numaux-x86.ads \\\n+  s-osinte.adb<s-osinte-vxworks.adb \\\n+  s-osinte.ads<s-osinte-vxworks.ads \\\n+  s-osprim.adb<s-osprim-vxworks.adb \\\n+  s-parame.ads<s-parame-vxworks.ads \\\n+  s-stchop.adb<s-stchop-vxworks.adb \\\n+  s-taprop.adb<s-taprop-vxworks.adb \\\n+  s-taspri.ads<s-taspri-vxworks.ads \\\n+  s-tpopsp.adb<s-tpopsp-vxworks.adb \\\n+  s-vxwork.ads<s-vxwork-x86.ads \\\n+  g-soccon.ads<g-soccon-vxworks.ads \\\n+  g-socthi.ads<g-socthi-vxworks.ads \\\n+  g-socthi.adb<g-socthi-vxworks.adb \\\n+  system.ads<system-vxworks-x86.ads\n+\n+  TOOLS_TARGET_PAIRS=mlib-tgt.adb<mlib-tgt-vxworks.adb\n+\n+  ifeq ($(strip $(filter-out yes,$(TRACE))),)\n+    LIBGNAT_TARGET_PAIRS += \\\n+    s-traces.adb<s-traces-default.adb \\\n+    s-trafor.adb<s-trafor-default.adb \\\n+    s-trafor.ads<s-trafor-default.ads \\\n+    s-tratas.adb<s-tratas-default.adb \\\n+    s-tfsetr.adb<s-tfsetr-vxworks.adb\n+  endif\n+\n+  EXTRA_GNATRTL_NONTASKING_OBJS=i-vxwork.o i-vxwoio.o\n+  EXTRA_GNATRTL_TASKING_OBJS=s-vxwork.o\n+endif\n+\n ifeq ($(strip $(filter-out xscale% coff wrs vx%,$(targ))),)\n   LIBGNAT_TARGET_PAIRS = \\\n   a-sytaco.ads<a-sytaco-vxworks.ads \\\n@@ -784,7 +824,8 @@ ifeq ($(strip $(filter-out %86 linux%,$(arch) $(osys))),)\n   system.ads<system-linux-x86.ads\n \n   TOOLS_TARGET_PAIRS =  \\\n-    mlib-tgt.adb<mlib-tgt-linux.adb\n+    mlib-tgt.adb<mlib-tgt-linux.adb \\\n+    indepsw.adb<indepsw-linux.adb\n \n   SYMLIB = $(ADDR2LINE_SYMLIB)\n   THREADSLIB = -lpthread\n@@ -1033,7 +1074,10 @@ ifeq ($(strip $(filter-out ibm aix%,$(manu) $(osys))),)\n     THREADSLIB = -lgthreads -lmalloc\n   endif\n \n-  TOOLS_TARGET_PAIRS = mlib-tgt.adb<mlib-tgt-aix.adb\n+  TOOLS_TARGET_PAIRS = \\\n+  mlib-tgt.adb<mlib-tgt-aix.adb \\\n+  indepsw.adb<indepsw-aix.adb\n+\n   GMEM_LIB = gmemlib\n   SYMLIB = $(ADDR2LINE_SYMLIB)\n \n@@ -1253,7 +1297,10 @@ ifeq ($(strip $(filter-out cygwin32% mingw32% pe,$(osys))),)\n   g-soliop.ads<g-soliop-mingw.ads \\\n   system.ads<system-mingw.ads\n \n-  TOOLS_TARGET_PAIRS=mlib-tgt.adb<mlib-tgt-mingw.adb\n+  TOOLS_TARGET_PAIRS= \\\n+  mlib-tgt.adb<mlib-tgt-mingw.adb \\\n+  indepsw.adb<indepsw-mingw.adb\n+\n   MISCLIB = -lwsock32\n   SYMLIB = $(ADDR2LINE_SYMLIB)\n   GMEM_LIB = gmemlib"}, {"sha": "6d52e8b50112023749e236424799fbcbcb529e33", "filename": "gcc/ada/bld.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fbld.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fbld.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbld.adb?ref=5d09245e6a54b290b5f44b686214b41cf555152a", "patch": "@@ -80,7 +80,7 @@ package body Bld is\n    Expression_Value  : String_Access := new String (1 .. 10);\n    Expression_Last   : Natural := 0;\n \n-   --  The following variables indicates if the suffixs and the languages\n+   --  The following variables indicates if the suffixes and the languages\n    --  are statically specified and, if they are, their values.\n \n    C_Suffix          : String_Access := new String (1 .. 10);\n@@ -2803,7 +2803,7 @@ package body Bld is\n \n                There_Are_Cases := Last_Case /= Last_Case_Construction;\n \n-               --  If the suffixs and the languages have not been specified,\n+               --  If the suffixes and the languages have not been specified,\n                --  give them the default values.\n \n                if C_Suffix_Static and then C_Suffix_Last = 0 then\n@@ -2920,7 +2920,7 @@ package body Bld is\n                         end if;\n \n                         --  If we still don't know the language, and all\n-                        --  suffixs are static, then it cannot any of the\n+                        --  suffixes are static, then it cannot any of the\n                         --  processed languages.\n \n                         if Source_Kind = Unknown"}, {"sha": "7ffa17dcddab1acbee04b7b85a8ccf42e9ee8b5f", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 26, "deletions": 7, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=5d09245e6a54b290b5f44b686214b41cf555152a", "patch": "@@ -43,6 +43,7 @@ with Rident;   use Rident;\n with Rtsfind;  use Rtsfind;\n with Sem;      use Sem;\n with Sem_Eval; use Sem_Eval;\n+with Sem_Ch3;  use Sem_Ch3;\n with Sem_Ch8;  use Sem_Ch8;\n with Sem_Res;  use Sem_Res;\n with Sem_Util; use Sem_Util;\n@@ -1163,6 +1164,12 @@ package body Checks is\n          return;\n       end if;\n \n+      --  Nothing to do if the type is an Unchecked_Union\n+\n+      if Is_Unchecked_Union (Base_Type (T_Typ)) then\n+         return;\n+      end if;\n+\n       --  Suppress checks if the subtypes are the same.\n       --  the check must be preserved in an assignment to a formal, because\n       --  the constraint is given by the actual.\n@@ -2377,14 +2384,26 @@ package body Checks is\n             Dval := Duplicate_Subexpr_No_Checks (Dval);\n          end if;\n \n-         Dref :=\n-           Make_Selected_Component (Loc,\n-             Prefix =>\n-               Duplicate_Subexpr_No_Checks (N, Name_Req => True),\n-             Selector_Name =>\n-               Make_Identifier (Loc, Chars (Disc_Ent)));\n+         --  If we have an Unchecked_Union node, we can infer the discriminants\n+         --  of the node.\n+\n+         if Is_Unchecked_Union (Base_Type (T_Typ)) then\n+            Dref := New_Copy (\n+              Get_Discriminant_Value (\n+                First_Discriminant (T_Typ),\n+                T_Typ,\n+                Stored_Constraint (T_Typ)));\n+\n+         else\n+            Dref :=\n+              Make_Selected_Component (Loc,\n+                Prefix =>\n+                  Duplicate_Subexpr_No_Checks (N, Name_Req => True),\n+                Selector_Name =>\n+                  Make_Identifier (Loc, Chars (Disc_Ent)));\n \n-         Set_Is_In_Discriminant_Check (Dref);\n+            Set_Is_In_Discriminant_Check (Dref);\n+         end if;\n \n          Evolve_Or_Else (Cond,\n            Make_Op_Ne (Loc,"}, {"sha": "702e348acdb348c931dd83a9835970f248deaab5", "filename": "gcc/ada/decl.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdecl.c?ref=5d09245e6a54b290b5f44b686214b41cf555152a", "patch": "@@ -348,7 +348,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t not a deferred constant but a constant whose value is built\n \t manually.  */\n \n-      if (definition && !gnu_expr \n+      if (definition && !gnu_expr\n \t  && !No_Initialization (Declaration_Node (gnat_entity))\n \t  && No (Renamed_Object (gnat_entity)))\n \t{\n@@ -1786,7 +1786,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t does not overflow in SIZETYPE, ignore the overflow\n \t\t indications.  */\n \t      if ((TYPE_PRECISION (gnu_index_subtype)\n-\t\t   > TYPE_PRECISION (sizetype))\n+\t\t   > TYPE_PRECISION (sizetype)\n+\t\t   || TYPE_UNSIGNED (gnu_index_subtype)\n+\t\t      != TYPE_UNSIGNED (sizetype))\n \t\t  && TREE_CODE (gnu_min) == INTEGER_CST\n \t\t  && TREE_CODE (gnu_max) == INTEGER_CST\n \t\t  && TREE_OVERFLOW (gnu_min) && TREE_OVERFLOW (gnu_max)\n@@ -1801,7 +1803,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      /* Similarly, if the range is null, use bounds of 1..0 for\n \t\t the sizetype bounds.  */\n \t      else if ((TYPE_PRECISION (gnu_index_subtype)\n-\t\t\t> TYPE_PRECISION (sizetype))\n+\t\t\t> TYPE_PRECISION (sizetype)\n+\t\t       || TYPE_UNSIGNED (gnu_index_subtype)\n+\t\t          != TYPE_UNSIGNED (sizetype))\n \t\t       && TREE_CODE (gnu_min) == INTEGER_CST\n \t\t       && TREE_CODE (gnu_max) == INTEGER_CST\n \t\t       && (TREE_OVERFLOW (gnu_min) || TREE_OVERFLOW (gnu_max))\n@@ -5450,7 +5454,7 @@ components_to_record (tree gnu_record_type, Node_Id component_list,\n   else if (gnu_our_rep_list)\n     {\n       tree gnu_rep_type\n-\t= (gnu_field_list ? gnu_record_type : make_node (RECORD_TYPE));\n+\t= (gnu_field_list ? make_node (RECORD_TYPE) : gnu_record_type);\n       int len = list_length (gnu_our_rep_list);\n       tree *gnu_arr = (tree *) alloca (sizeof (tree) * len);\n       int i;"}, {"sha": "5f613dc3efd90a3c98710f3aa351d2d363350c39", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=5d09245e6a54b290b5f44b686214b41cf555152a", "patch": "@@ -4678,6 +4678,15 @@ package body Einfo is\n       S  : Entity_Id;\n \n    begin\n+      --  The following test is an error defense against some syntax\n+      --  errors that can leave scopes very messed up.\n+\n+      if Id = Standard_Standard then\n+         return Id;\n+      end if;\n+\n+      --  Normal case, search enclosing scopes\n+\n       S := Scope (Id);\n       while S /= Standard_Standard\n         and then not Is_Dynamic_Scope (S)"}, {"sha": "5ebe8dad72bfdf4e6d27d6c34e186455a4e5e4f8", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=5d09245e6a54b290b5f44b686214b41cf555152a", "patch": "@@ -1399,8 +1399,19 @@ package Einfo is\n \n --    Has_Per_Object_Constraint (Flag154)\n --       Present in E_Component entities, true if the subtype of the\n---       component has a per object constraint, i.e. an actual discriminant\n---       value of the form T'Access, where T is the enclosing type.\n+--       component has a per object constraint. Per object constraints result\n+--       from the following situations:\n+--\n+--       1. N_Attribute_Reference - when the prefix is the enclosing type and\n+--          the attribute is Access.\n+--       2. N_Discriminant_Association - when the expression uses the\n+--          discriminant of the enclosing type.\n+--       3. N_Index_Or_Discriminant_Constraint - when at least one of the\n+--          individual constraints is a per object constraint.\n+--       4. N_Range - when the lower or upper bound uses the discriminant of\n+--          the enclosing type.\n+--       5. N_Range_Constraint - when the range expression uses the\n+--          discriminant of the enclosing type.\n \n --    Has_Pragma_Controlled (Flag27) [implementation base type only]\n --       Present in access type entities. It is set if a pragma Controlled"}, {"sha": "f87d503db62dad744342eb89f999117b96d6f321", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 51, "deletions": 2, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=5d09245e6a54b290b5f44b686214b41cf555152a", "patch": "@@ -27,6 +27,7 @@\n with Atree;    use Atree;\n with Checks;   use Checks;\n with Einfo;    use Einfo;\n+with Elists;   use Elists;\n with Exp_Ch2;  use Exp_Ch2;\n with Exp_Ch9;  use Exp_Ch9;\n with Exp_Imgv; use Exp_Imgv;\n@@ -1883,6 +1884,21 @@ package body Exp_Attr is\n                pragma Assert\n                  (Is_Record_Type (U_Type) or else Is_Protected_Type (U_Type));\n \n+               --  Ada 2005 (AI-216): Program_Error is raised when executing\n+               --  the default implementation of the Input attribute of an\n+               --  unchecked union type if the type lacks default discriminant\n+               --  values.\n+\n+               if Is_Unchecked_Union (Base_Type (U_Type))\n+                 and then not Present (Discriminant_Constraint (U_Type))\n+               then\n+                  Insert_Action (N,\n+                    Make_Raise_Program_Error (Loc,\n+                      Reason => PE_Unchecked_Union_Restriction));\n+\n+                  return;\n+               end if;\n+\n                Build_Record_Or_Elementary_Input_Function\n                  (Loc, Base_Type (U_Type), Decl, Fname);\n                Insert_Action (N, Decl);\n@@ -2393,6 +2409,21 @@ package body Exp_Attr is\n                pragma Assert\n                  (Is_Record_Type (U_Type) or else Is_Protected_Type (U_Type));\n \n+               --  Ada 2005 (AI-216): Program_Error is raised when executing\n+               --  the default implementation of the Output attribute of an\n+               --  unchecked union type if the type lacks default discriminant\n+               --  values.\n+\n+               if Is_Unchecked_Union (Base_Type (U_Type))\n+                 and then not Present (Discriminant_Constraint (U_Type))\n+               then\n+                  Insert_Action (N,\n+                    Make_Raise_Program_Error (Loc,\n+                      Reason => PE_Unchecked_Union_Restriction));\n+\n+                  return;\n+               end if;\n+\n                Build_Record_Or_Elementary_Output_Procedure\n                  (Loc, Base_Type (U_Type), Decl, Pname);\n                Insert_Action (N, Decl);\n@@ -2779,13 +2810,22 @@ package body Exp_Attr is\n                pragma Assert\n                  (Is_Record_Type (U_Type) or else Is_Protected_Type (U_Type));\n \n+               --  Ada 2005 (AI-216): Program_Error is raised when executing\n+               --  the default implementation of the Read attribute of an\n+               --  Unchecked_Union type.\n+\n+               if Is_Unchecked_Union (Base_Type (U_Type)) then\n+                  Insert_Action (N,\n+                    Make_Raise_Program_Error (Loc,\n+                      Reason => PE_Unchecked_Union_Restriction));\n+               end if;\n+\n                if Has_Discriminants (U_Type)\n                  and then Present\n                    (Discriminant_Default_Value (First_Discriminant (U_Type)))\n                then\n                   Build_Mutable_Record_Read_Procedure\n                     (Loc, Base_Type (U_Type), Decl, Pname);\n-\n                else\n                   Build_Record_Read_Procedure\n                     (Loc, Base_Type (U_Type), Decl, Pname);\n@@ -3960,13 +4000,22 @@ package body Exp_Attr is\n                pragma Assert\n                  (Is_Record_Type (U_Type) or else Is_Protected_Type (U_Type));\n \n+               --  Ada 2005 (AI-216): Program_Error is raised when executing\n+               --  the default implementation of the Write attribute of an\n+               --  Unchecked_Union type.\n+\n+               if Is_Unchecked_Union (Base_Type (U_Type)) then\n+                  Insert_Action (N,\n+                    Make_Raise_Program_Error (Loc,\n+                      Reason => PE_Unchecked_Union_Restriction));\n+               end if;\n+\n                if Has_Discriminants (U_Type)\n                  and then Present\n                    (Discriminant_Default_Value (First_Discriminant (U_Type)))\n                then\n                   Build_Mutable_Record_Write_Procedure\n                     (Loc, Base_Type (U_Type), Decl, Pname);\n-\n                else\n                   Build_Record_Write_Procedure\n                     (Loc, Base_Type (U_Type), Decl, Pname);"}, {"sha": "130d74d80db9ef5a38ae4b4a32fef3fb6b853af2", "filename": "gcc/ada/exp_ch2.adb", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fexp_ch2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fexp_ch2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch2.adb?ref=5d09245e6a54b290b5f44b686214b41cf555152a", "patch": "@@ -56,9 +56,9 @@ package body Exp_Ch2 is\n    --  Given a node N for a variable whose Current_Value field is set.\n    --  If the node is for a discrete type, replaces the node with a\n    --  copy of the referenced value. This provides a limited form of\n-   --  value propagation for variables which are initialized and have\n-   --  not been modified at the time of reference. The call has no\n-   --  effect if the Current_Value refers to a conditional with a\n+   --  value propagation for variables which are initialized or assigned\n+   --  not been further modified at the time of reference. The call has\n+   --  no effect if the Current_Value refers to a conditional with a\n    --  condition other than equality.\n \n    procedure Expand_Discriminant (N : Node_Id);\n@@ -159,11 +159,7 @@ package body Exp_Ch2 is\n                CS := Scope (CS);\n \n             --  Otherwise, the reference is dubious, and we cannot be\n-            --  sure that it is safe to do the replacement. Note in\n-            --  particular, in a loop (except for the special case\n-            --  tested above), we cannot safely do a replacement since\n-            --  there may be an assignment at the bottom of the loop\n-            --  that will affect a reference at the top of the loop.\n+            --  sure that it is safe to do the replacement.\n \n             else\n                exit;\n@@ -178,6 +174,10 @@ package body Exp_Ch2 is\n    begin\n       if True\n \n+         --  No replacement if value raises constraint error\n+\n+         and then Nkind (CV) /= N_Raise_Constraint_Error\n+\n          --  Do this only for discrete types\n \n          and then Is_Discrete_Type (T)\n@@ -419,7 +419,6 @@ package body Exp_Ch2 is\n                or else\n              Ekind (E) = E_Out_Parameter)\n         and then Present (Current_Value (E))\n-        and then Nkind (Current_Value (E)) /= N_Raise_Constraint_Error\n       then\n          Expand_Current_Value (N);\n "}, {"sha": "39d704efab5001b0e034ad84e5bed60016182249", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 164, "deletions": 42, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=5d09245e6a54b290b5f44b686214b41cf555152a", "patch": "@@ -179,21 +179,27 @@ package body Exp_Ch3 is\n    --  Check if E is defined in the RTL (in a child of Ada or System). Used\n    --  to avoid to bring in the overhead of _Input, _Output for tagged types.\n \n-   function Make_Eq_Case (Node : Node_Id; CL : Node_Id) return List_Id;\n+   function Make_Eq_Case\n+     (E     : Entity_Id;\n+      CL    : Node_Id;\n+      Discr : Entity_Id := Empty) return List_Id;\n    --  Building block for variant record equality. Defined to share the\n    --  code between the tagged and non-tagged case. Given a Component_List\n    --  node CL, it generates an 'if' followed by a 'case' statement that\n    --  compares all components of local temporaries named X and Y (that\n-   --  are declared as formals at some upper level). Node provides the\n-   --  Sloc to be used for the generated code.\n+   --  are declared as formals at some upper level). E provides the Sloc to be\n+   --  used for the generated code. Discr is used as the case statement switch\n+   --  in the case of Unchecked_Union equality.\n \n-   function Make_Eq_If (Node : Node_Id; L : List_Id) return Node_Id;\n+   function Make_Eq_If\n+     (E : Entity_Id;\n+      L : List_Id) return Node_Id;\n    --  Building block for variant record equality. Defined to share the\n    --  code between the tagged and non-tagged case. Given the list of\n    --  components (or discriminants) L, it generates a return statement\n    --  that compares all components of local temporaries named X and Y\n-   --  (that are declared as formals at some upper level). Node provides\n-   --  the Sloc to be used for the generated code.\n+   --  (that are declared as formals at some upper level). E provides the Sloc\n+   --  to be used for the generated code.\n \n    procedure Make_Predefined_Primitive_Specs\n      (Tag_Typ     : Entity_Id;\n@@ -1920,6 +1926,39 @@ package body Exp_Ch3 is\n          Id  : Entity_Id;\n          Typ : Entity_Id;\n \n+         function Has_Access_Constraint (E : Entity_Id) return Boolean;\n+         --  Components with access discriminants that depend on the current\n+         --  instance must be initialized after all other components.\n+\n+         ---------------------------\n+         -- Has_Access_Constraint --\n+         ---------------------------\n+\n+         function Has_Access_Constraint (E : Entity_Id) return Boolean is\n+            Disc : Entity_Id;\n+            T    : constant Entity_Id := Etype (E);\n+\n+         begin\n+            if Has_Per_Object_Constraint (E)\n+              and then Has_Discriminants (T)\n+            then\n+               Disc := First_Discriminant (T);\n+               while Present (Disc) loop\n+                  if Is_Access_Type (Etype (Disc)) then\n+                     return True;\n+                  end if;\n+\n+                  Next_Discriminant (Disc);\n+               end loop;\n+\n+               return False;\n+            else\n+               return False;\n+            end if;\n+         end Has_Access_Constraint;\n+\n+      --  Start of processing for Build_Init_Statements\n+\n       begin\n          if Null_Present (Comp_List) then\n             return New_List (Make_Null_Statement (Loc));\n@@ -1934,7 +1973,7 @@ package body Exp_Ch3 is\n \n          Per_Object_Constraint_Components := False;\n \n-         --  First step : regular components.\n+         --  First step : regular components\n \n          Decl := First_Non_Pragma (Component_Items (Comp_List));\n          while Present (Decl) loop\n@@ -1945,7 +1984,7 @@ package body Exp_Ch3 is\n             Id := Defining_Identifier (Decl);\n             Typ := Etype (Id);\n \n-            if Has_Per_Object_Constraint (Id)\n+            if Has_Access_Constraint (Id)\n               and then No (Expression (Decl))\n             then\n                --  Skip processing for now and ask for a second pass\n@@ -2025,7 +2064,7 @@ package body Exp_Ch3 is\n                Id := Defining_Identifier (Decl);\n                Typ := Etype (Id);\n \n-               if Has_Per_Object_Constraint (Id)\n+               if Has_Access_Constraint (Id)\n                  and then No (Expression (Decl))\n                then\n                   if Has_Non_Null_Base_Init_Proc (Typ) then\n@@ -2457,6 +2496,7 @@ package body Exp_Ch3 is\n \n       if Is_Derived_Type (Rec_Type)\n         and then not Is_Tagged_Type (Rec_Type)\n+        and then not Is_Unchecked_Union (Rec_Type)\n         and then not Has_New_Non_Standard_Rep (Rec_Type)\n         and then not Parent_Subtype_Renaming_Discrims\n         and then Has_Non_Null_Base_Init_Proc (Etype (Rec_Type))\n@@ -2466,7 +2506,9 @@ package body Exp_Ch3 is\n       --  Otherwise if we need an initialization procedure, then build one,\n       --  mark it as public and inlinable and as having a completion.\n \n-      elsif Requires_Init_Proc (Rec_Type) then\n+      elsif Requires_Init_Proc (Rec_Type)\n+        or else Is_Unchecked_Union (Rec_Type)\n+      then\n          Build_Init_Procedure;\n          Set_Is_Public (Proc_Id, Is_Public (Pe));\n \n@@ -2849,9 +2891,14 @@ package body Exp_Ch3 is\n       Def   : constant Node_Id := Parent (Typ);\n       Comps : constant Node_Id := Component_List (Type_Definition (Def));\n       Stmts : constant List_Id := New_List;\n+      Pspecs : constant List_Id := New_List;\n \n    begin\n+      --  Derived Unchecked_Union types no longer inherit the equality function\n+      --  of their parent.\n+\n       if Is_Derived_Type (Typ)\n+        and then not Is_Unchecked_Union (Typ)\n         and then not Has_New_Non_Standard_Rep (Typ)\n       then\n          declare\n@@ -2871,34 +2918,86 @@ package body Exp_Ch3 is\n           Specification =>\n             Make_Function_Specification (Loc,\n               Defining_Unit_Name       => F,\n-              Parameter_Specifications => New_List (\n-                Make_Parameter_Specification (Loc,\n-                  Defining_Identifier => X,\n-                  Parameter_Type      => New_Reference_To (Typ, Loc)),\n-\n-                Make_Parameter_Specification (Loc,\n-                  Defining_Identifier => Y,\n-                  Parameter_Type      => New_Reference_To (Typ, Loc))),\n-\n+              Parameter_Specifications => Pspecs,\n               Subtype_Mark => New_Reference_To (Standard_Boolean, Loc)),\n-\n           Declarations               => New_List,\n           Handled_Statement_Sequence =>\n             Make_Handled_Sequence_Of_Statements (Loc,\n               Statements => Stmts)));\n \n-      --  For unchecked union case, raise program error. This will only\n-      --  happen in the case of dynamic dispatching for a tagged type,\n-      --  since in the static cases it is a compile time error.\n+      Append_To (Pspecs,\n+        Make_Parameter_Specification (Loc,\n+          Defining_Identifier => X,\n+          Parameter_Type      => New_Reference_To (Typ, Loc)));\n+\n+      Append_To (Pspecs,\n+        Make_Parameter_Specification (Loc,\n+          Defining_Identifier => Y,\n+          Parameter_Type      => New_Reference_To (Typ, Loc)));\n+\n+      --  Unchecked_Unions require additional machinery to support equality.\n+      --  Two extra parameters (A and B) are added to the equality function\n+      --  parameter list in order to capture the inferred values of the\n+      --  discriminants in later calls.\n+\n+      if Is_Unchecked_Union (Typ) then\n+         declare\n+            Discr_Type : constant Node_Id := Etype (First_Discriminant (Typ));\n+\n+            A : constant Node_Id :=\n+                  Make_Defining_Identifier (Loc,\n+                    Chars => Name_A);\n+\n+            B : constant Node_Id :=\n+                  Make_Defining_Identifier (Loc,\n+                    Chars => Name_B);\n+\n+         begin\n+            --  Add A and B to the parameter list\n+\n+            Append_To (Pspecs,\n+              Make_Parameter_Specification (Loc,\n+                Defining_Identifier => A,\n+                Parameter_Type => New_Reference_To (Discr_Type, Loc)));\n+\n+            Append_To (Pspecs,\n+              Make_Parameter_Specification (Loc,\n+                Defining_Identifier => B,\n+                Parameter_Type => New_Reference_To (Discr_Type, Loc)));\n+\n+            --  Generate the following header code to compare the inferred\n+            --  discriminants:\n+\n+            --  if a /= b then\n+            --     return False;\n+            --  end if;\n+\n+            Append_To (Stmts,\n+              Make_If_Statement (Loc,\n+                Condition =>\n+                  Make_Op_Ne (Loc,\n+                    Left_Opnd => New_Reference_To (A, Loc),\n+                    Right_Opnd => New_Reference_To (B, Loc)),\n+                Then_Statements => New_List (\n+                  Make_Return_Statement (Loc,\n+                    Expression => New_Occurrence_Of (Standard_False, Loc)))));\n+\n+            --  Generate component-by-component comparison. Note that we must\n+            --  propagate one of the inferred discriminant formals to act as\n+            --  the case statement switch.\n+\n+            Append_List_To (Stmts,\n+              Make_Eq_Case (Typ, Comps, A));\n+\n+         end;\n+\n+      --  Normal case (not unchecked union)\n \n-      if Has_Unchecked_Union (Typ) then\n-         Append_To (Stmts,\n-           Make_Raise_Program_Error (Loc,\n-             Reason => PE_Unchecked_Union_Restriction));\n       else\n          Append_To (Stmts,\n            Make_Eq_If (Typ,\n              Discriminant_Specifications (Def)));\n+\n          Append_List_To (Stmts,\n            Make_Eq_Case (Typ, Comps));\n       end if;\n@@ -4160,6 +4259,12 @@ package body Exp_Ch3 is\n \n       elsif Is_Derived_Type (Def_Id)\n         and then not Is_Tagged_Type (Def_Id)\n+\n+         --  If we have a derived Unchecked_Union, we do not inherit the\n+         --  discriminant checking functions from the parent type since the\n+         --  discriminants are non existent.\n+\n+        and then not Is_Unchecked_Union (Def_Id)\n         and then Has_Discriminants (Def_Id)\n       then\n          declare\n@@ -4329,7 +4434,6 @@ package body Exp_Ch3 is\n          begin\n             if Present (Comps)\n               and then Present (Variant_Part (Comps))\n-              and then not Is_Unchecked_Union (Def_Id)\n             then\n                Build_Variant_Record_Equality (Def_Id);\n             end if;\n@@ -5108,14 +5212,18 @@ package body Exp_Ch3 is\n    --     when Vn => <Make_Eq_Case> on subcomponents\n    --  end case;\n \n-   function Make_Eq_Case (Node : Node_Id; CL : Node_Id) return List_Id is\n-      Loc      : constant Source_Ptr := Sloc (Node);\n+   function Make_Eq_Case\n+     (E     : Entity_Id;\n+      CL    : Node_Id;\n+      Discr : Entity_Id := Empty) return List_Id\n+   is\n+      Loc      : constant Source_Ptr := Sloc (E);\n       Result   : constant List_Id    := New_List;\n       Variant  : Node_Id;\n       Alt_List : List_Id;\n \n    begin\n-      Append_To (Result, Make_Eq_If (Node, Component_Items (CL)));\n+      Append_To (Result, Make_Eq_If (E, Component_Items (CL)));\n \n       if No (Variant_Part (CL)) then\n          return Result;\n@@ -5133,18 +5241,29 @@ package body Exp_Ch3 is\n          Append_To (Alt_List,\n            Make_Case_Statement_Alternative (Loc,\n              Discrete_Choices => New_Copy_List (Discrete_Choices (Variant)),\n-             Statements => Make_Eq_Case (Node, Component_List (Variant))));\n+             Statements => Make_Eq_Case (E, Component_List (Variant))));\n \n          Next_Non_Pragma (Variant);\n       end loop;\n \n-      Append_To (Result,\n-        Make_Case_Statement (Loc,\n-          Expression =>\n-            Make_Selected_Component (Loc,\n-              Prefix => Make_Identifier (Loc, Name_X),\n-              Selector_Name => New_Copy (Name (Variant_Part (CL)))),\n-          Alternatives => Alt_List));\n+      --  If we have an Unchecked_Union, use one of the parameters that\n+      --  captures the discriminants.\n+\n+      if Is_Unchecked_Union (E) then\n+         Append_To (Result,\n+           Make_Case_Statement (Loc,\n+             Expression => New_Reference_To (Discr, Loc),\n+             Alternatives => Alt_List));\n+\n+      else\n+         Append_To (Result,\n+           Make_Case_Statement (Loc,\n+             Expression =>\n+               Make_Selected_Component (Loc,\n+                 Prefix => Make_Identifier (Loc, Name_X),\n+                 Selector_Name => New_Copy (Name (Variant_Part (CL)))),\n+             Alternatives => Alt_List));\n+      end if;\n \n       return Result;\n    end Make_Eq_Case;\n@@ -5166,8 +5285,11 @@ package body Exp_Ch3 is\n \n    --  or a null statement if the list L is empty\n \n-   function Make_Eq_If (Node : Node_Id; L : List_Id) return Node_Id is\n-      Loc        : constant Source_Ptr := Sloc (Node);\n+   function Make_Eq_If\n+     (E : Entity_Id;\n+      L : List_Id) return Node_Id\n+   is\n+      Loc        : constant Source_Ptr := Sloc (E);\n       C          : Node_Id;\n       Field_Name : Name_Id;\n       Cond       : Node_Id;\n@@ -5213,7 +5335,7 @@ package body Exp_Ch3 is\n \n          else\n             return\n-              Make_Implicit_If_Statement (Node,\n+              Make_Implicit_If_Statement (E,\n                 Condition => Cond,\n                 Then_Statements => New_List (\n                   Make_Return_Statement (Loc,"}, {"sha": "7f57b02425cb4890a61d4ea32f5926181442fd3b", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 614, "deletions": 30, "changes": 644, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=5d09245e6a54b290b5f44b686214b41cf555152a", "patch": "@@ -47,6 +47,7 @@ with Opt;      use Opt;\n with Rtsfind;  use Rtsfind;\n with Sem;      use Sem;\n with Sem_Cat;  use Sem_Cat;\n+with Sem_Ch3;  use Sem_Ch3;\n with Sem_Ch13; use Sem_Ch13;\n with Sem_Eval; use Sem_Eval;\n with Sem_Res;  use Sem_Res;\n@@ -154,6 +155,17 @@ package body Exp_Ch4 is\n    --  for created object. If context is an access parameter, create a\n    --  local access type to have a usable finalization list.\n \n+   function Has_Inferable_Discriminants (N : Node_Id) return Boolean;\n+   --  Ada 2005 (AI-216): A view of an Unchecked_Union object has inferable\n+   --  discriminants if it has a constrained nominal type, unless the object\n+   --  is a component of an enclosing Unchecked_Union object that is subject\n+   --  to a per-object constraint and the enclosing object lacks inferable\n+   --  discriminants.\n+   --\n+   --  An expression of an Unchecked_Union type has inferable discriminants\n+   --  if it is either a name of an object with inferable discriminants or a\n+   --  qualified expression whose subtype mark denotes a constrained subtype.\n+\n    procedure Insert_Dereference_Action (N : Node_Id);\n    --  N is an expression whose type is an access. When the type of the\n    --  associated storage pool is derived from Checked_Pool, generate a\n@@ -1581,6 +1593,123 @@ package body Exp_Ch4 is\n                end;\n \n             else\n+               --  Comparison between Unchecked_Union components\n+\n+               if Is_Unchecked_Union (Full_Type) then\n+                  declare\n+                     Lhs_Type      : Node_Id := Full_Type;\n+                     Rhs_Type      : Node_Id := Full_Type;\n+                     Lhs_Discr_Val : Node_Id;\n+                     Rhs_Discr_Val : Node_Id;\n+\n+                  begin\n+                     --  Lhs subtype\n+\n+                     if Nkind (Lhs) = N_Selected_Component then\n+                        Lhs_Type := Etype (Entity (Selector_Name (Lhs)));\n+                     end if;\n+\n+                     --  Rhs subtype\n+\n+                     if Nkind (Rhs) = N_Selected_Component then\n+                        Rhs_Type := Etype (Entity (Selector_Name (Rhs)));\n+                     end if;\n+\n+                     --  Lhs of the composite equality\n+\n+                     if Is_Constrained (Lhs_Type) then\n+\n+                        --  Since the enclosing record can never be an\n+                        --  Unchecked_Union (this code is executed for records\n+                        --  that do not have variants), we may reference its\n+                        --  discriminant(s).\n+\n+                        if Nkind (Lhs) = N_Selected_Component\n+                          and then Has_Per_Object_Constraint (\n+                                     Entity (Selector_Name (Lhs)))\n+                        then\n+                           Lhs_Discr_Val :=\n+                             Make_Selected_Component (Loc,\n+                               Prefix => Prefix (Lhs),\n+                               Selector_Name =>\n+                                 New_Copy (\n+                                   Get_Discriminant_Value (\n+                                     First_Discriminant (Lhs_Type),\n+                                     Lhs_Type,\n+                                     Stored_Constraint (Lhs_Type))));\n+\n+                        else\n+                           Lhs_Discr_Val := New_Copy (\n+                             Get_Discriminant_Value (\n+                               First_Discriminant (Lhs_Type),\n+                               Lhs_Type,\n+                               Stored_Constraint (Lhs_Type)));\n+\n+                        end if;\n+                     else\n+                        --  It is not possible to infer the discriminant since\n+                        --  the subtype is not constrained.\n+\n+                        Insert_Action (Nod,\n+                          Make_Raise_Program_Error (Loc,\n+                            Reason => PE_Unchecked_Union_Restriction));\n+\n+                        --  Prevent Gigi from generating illegal code, change\n+                        --  the equality to a standard False.\n+\n+                        return New_Occurrence_Of (Standard_False, Loc);\n+                     end if;\n+\n+                     --  Rhs of the composite equality\n+\n+                     if Is_Constrained (Rhs_Type) then\n+                        if Nkind (Rhs) = N_Selected_Component\n+                          and then Has_Per_Object_Constraint (\n+                                     Entity (Selector_Name (Rhs)))\n+                        then\n+                           Rhs_Discr_Val :=\n+                             Make_Selected_Component (Loc,\n+                               Prefix => Prefix (Rhs),\n+                               Selector_Name =>\n+                                 New_Copy (\n+                                   Get_Discriminant_Value (\n+                                     First_Discriminant (Rhs_Type),\n+                                     Rhs_Type,\n+                                     Stored_Constraint (Rhs_Type))));\n+\n+                        else\n+                           Rhs_Discr_Val := New_Copy (\n+                             Get_Discriminant_Value (\n+                               First_Discriminant (Rhs_Type),\n+                               Rhs_Type,\n+                               Stored_Constraint (Rhs_Type)));\n+\n+                        end if;\n+                     else\n+                        Insert_Action (Nod,\n+                          Make_Raise_Program_Error (Loc,\n+                            Reason => PE_Unchecked_Union_Restriction));\n+\n+                        return Empty;\n+                     end if;\n+\n+                     --  Call the TSS equality function with the inferred\n+                     --  discriminant values.\n+\n+                     return\n+                       Make_Function_Call (Loc,\n+                         Name => New_Reference_To (Eq_Op, Loc),\n+                         Parameter_Associations => New_List (\n+                           Lhs,\n+                           Rhs,\n+                           Lhs_Discr_Val,\n+                           Rhs_Discr_Val));\n+                  end;\n+               end if;\n+\n+               --  Shouldn't this be an else, we can't fall through\n+               --  the above IF, right???\n+\n                return\n                  Make_Function_Call (Loc,\n                    Name => New_Reference_To (Eq_Op, Loc),\n@@ -2963,6 +3092,27 @@ package body Exp_Ch4 is\n                        Prefix => New_Reference_To (Typ, Loc))));\n                Analyze_And_Resolve (N, Rtyp);\n                return;\n+\n+            --  Ada 2005 (AI-216): Program_Error is raised when evaluating\n+            --  a membership test if the subtype mark denotes a constrained\n+            --  Unchecked_Union subtype and the expression lacks inferable\n+            --  discriminants.\n+\n+            elsif Is_Unchecked_Union (Base_Type (Typ))\n+              and then Is_Constrained (Typ)\n+              and then not Has_Inferable_Discriminants (Lop)\n+            then\n+               Insert_Action (N,\n+                 Make_Raise_Program_Error (Loc,\n+                   Reason => PE_Unchecked_Union_Restriction));\n+\n+               --  Prevent Gigi from generating incorrect code by rewriting\n+               --  the test as a standard False.\n+\n+               Rewrite (N,\n+                 New_Occurrence_Of (Standard_False, Loc));\n+\n+               return;\n             end if;\n \n             --  Here we have a non-scalar type\n@@ -3714,6 +3864,10 @@ package body Exp_Ch4 is\n       --  build and analyze call, adding conversions if the operation is\n       --  inherited.\n \n+      function Has_Unconstrained_UU_Component (Typ : Node_Id) return Boolean;\n+      --  Determines whether a type has a subcompoment of an unconstrained\n+      --  Unchecked_Union subtype. Typ is a record type.\n+\n       -------------------------\n       -- Build_Equality_Call --\n       -------------------------\n@@ -3731,14 +3885,315 @@ package body Exp_Ch4 is\n             R_Exp := OK_Convert_To (Op_Type, R_Exp);\n          end if;\n \n-         Rewrite (N,\n-           Make_Function_Call (Loc,\n-             Name => New_Reference_To (Eq, Loc),\n-             Parameter_Associations => New_List (L_Exp, R_Exp)));\n+         --  If we have an Unchecked_Union, we need to add the inferred\n+         --  discriminant values as actuals in the function call. At this\n+         --  point, the expansion has determined that both operands have\n+         --  inferable discriminants.\n+\n+         if Is_Unchecked_Union (Op_Type) then\n+            declare\n+               Lhs_Type      : constant Node_Id := Etype (L_Exp);\n+               Rhs_Type      : constant Node_Id := Etype (R_Exp);\n+               Lhs_Discr_Val : Node_Id;\n+               Rhs_Discr_Val : Node_Id;\n+\n+            begin\n+               --  Per-object constrained selected components require special\n+               --  attention. If the enclosing scope of the component is an\n+               --  Unchecked_Union, we can not reference its discriminants\n+               --  directly. This is why we use the two extra parameters of\n+               --  the equality function of the enclosing Unchecked_Union.\n+\n+               --  type UU_Type (Discr : Integer := 0) is\n+               --     . . .\n+               --  end record;\n+               --  pragma Unchecked_Union (UU_Type);\n+\n+               --  1. Unchecked_Union enclosing record:\n+\n+               --     type Enclosing_UU_Type (Discr : Integer := 0) is record\n+               --        . . .\n+               --        Comp : UU_Type (Discr);\n+               --        . . .\n+               --     end Enclosing_UU_Type;\n+               --     pragma Unchecked_Union (Enclosing_UU_Type);\n+\n+               --     Obj1 : Enclosing_UU_Type;\n+               --     Obj2 : Enclosing_UU_Type (1);\n+\n+               --     . . . Obj1 = Obj2 . . .\n+\n+               --     Generated code:\n+\n+               --     if not (uu_typeEQ (obj1.comp, obj2.comp, a, b)) then\n+\n+               --  A and B are the formal parameters of the equality function\n+               --  of Enclosing_UU_Type. The function always has two extra\n+               --  formals to capture the inferred discriminant values.\n+\n+               --  2. Non-Unchecked_Union enclosing record:\n+\n+               --     type\n+               --       Enclosing_Non_UU_Type (Discr : Integer := 0)\n+               --     is record\n+               --        . . .\n+               --        Comp : UU_Type (Discr);\n+               --        . . .\n+               --     end Enclosing_Non_UU_Type;\n+\n+               --     Obj1 : Enclosing_Non_UU_Type;\n+               --     Obj2 : Enclosing_Non_UU_Type (1);\n+\n+               --     . . . Obj1 = Obj2 . . .\n+\n+               --     Generated code:\n+\n+               --     if not (uu_typeEQ (obj1.comp, obj2.comp,\n+               --                        obj1.discr, obj2.discr)) then\n+\n+               --  In this case we can directly reference the discriminants of\n+               --  the enclosing record.\n+\n+               --  Lhs of equality\n+\n+               if Nkind (Lhs) = N_Selected_Component\n+                 and then Has_Per_Object_Constraint (\n+                            Entity (Selector_Name (Lhs)))\n+               then\n+                  --  Enclosing record is an Unchecked_Union, use formal A\n+\n+                  if Is_Unchecked_Union (Scope\n+                       (Entity (Selector_Name (Lhs))))\n+                  then\n+                     Lhs_Discr_Val :=\n+                       Make_Identifier (Loc,\n+                         Chars => Name_A);\n+\n+                  --  Enclosing record is of a non-Unchecked_Union type, it is\n+                  --  possible to reference the discriminant.\n+\n+                  else\n+                     Lhs_Discr_Val :=\n+                       Make_Selected_Component (Loc,\n+                         Prefix => Prefix (Lhs),\n+                         Selector_Name =>\n+                           New_Copy (Get_Discriminant_Value (\n+                             First_Discriminant (Lhs_Type),\n+                             Lhs_Type,\n+                             Stored_Constraint (Lhs_Type))));\n+\n+                  end if;\n+\n+               --  Comment needed here ???\n+\n+               else\n+                  --  Infer the discriminant value\n+\n+                  Lhs_Discr_Val :=\n+                    New_Copy (Get_Discriminant_Value (\n+                      First_Discriminant (Lhs_Type),\n+                      Lhs_Type,\n+                      Stored_Constraint (Lhs_Type)));\n+\n+               end if;\n+\n+               --  Rhs of equality\n+\n+               if Nkind (Rhs) = N_Selected_Component\n+                  and then Has_Per_Object_Constraint (\n+                             Entity (Selector_Name (Rhs)))\n+               then\n+                  if Is_Unchecked_Union (Scope\n+                       (Entity (Selector_Name (Rhs))))\n+                  then\n+                     Rhs_Discr_Val :=\n+                       Make_Identifier (Loc,\n+                         Chars => Name_B);\n+\n+                  else\n+                     Rhs_Discr_Val :=\n+                       Make_Selected_Component (Loc,\n+                         Prefix => Prefix (Rhs),\n+                         Selector_Name =>\n+                           New_Copy (Get_Discriminant_Value (\n+                             First_Discriminant (Rhs_Type),\n+                             Rhs_Type,\n+                             Stored_Constraint (Rhs_Type))));\n+\n+                  end if;\n+               else\n+                  Rhs_Discr_Val :=\n+                    New_Copy (Get_Discriminant_Value (\n+                      First_Discriminant (Rhs_Type),\n+                      Rhs_Type,\n+                      Stored_Constraint (Rhs_Type)));\n+\n+               end if;\n+\n+               Rewrite (N,\n+                 Make_Function_Call (Loc,\n+                   Name => New_Reference_To (Eq, Loc),\n+                   Parameter_Associations => New_List (\n+                     L_Exp,\n+                     R_Exp,\n+                     Lhs_Discr_Val,\n+                     Rhs_Discr_Val)));\n+            end;\n+\n+         --  Normal case, not an unchecked union\n+\n+         else\n+            Rewrite (N,\n+              Make_Function_Call (Loc,\n+                Name => New_Reference_To (Eq, Loc),\n+                Parameter_Associations => New_List (L_Exp, R_Exp)));\n+         end if;\n \n          Analyze_And_Resolve (N, Standard_Boolean, Suppress => All_Checks);\n       end Build_Equality_Call;\n \n+      ------------------------------------\n+      -- Has_Unconstrained_UU_Component --\n+      ------------------------------------\n+\n+      function Has_Unconstrained_UU_Component\n+        (Typ : Node_Id) return Boolean\n+      is\n+         Tdef  : constant Node_Id :=\n+                   Type_Definition (Declaration_Node (Typ));\n+         Clist : Node_Id;\n+         Vpart : Node_Id;\n+\n+         function Component_Is_Unconstrained_UU\n+           (Comp : Node_Id) return Boolean;\n+         --  Determines whether the subtype of the component is an\n+         --  unconstrained Unchecked_Union.\n+\n+         function Variant_Is_Unconstrained_UU\n+           (Variant : Node_Id) return Boolean;\n+         --  Determines whether a component of the variant has an unconstrained\n+         --  Unchecked_Union subtype.\n+\n+         -----------------------------------\n+         -- Component_Is_Unconstrained_UU --\n+         -----------------------------------\n+\n+         function Component_Is_Unconstrained_UU\n+           (Comp : Node_Id) return Boolean\n+         is\n+         begin\n+            if Nkind (Comp) /= N_Component_Declaration then\n+               return False;\n+            end if;\n+\n+            declare\n+               Sindic : constant Node_Id :=\n+                          Subtype_Indication (Component_Definition (Comp));\n+\n+            begin\n+               --  Unconstrained nominal type. In the case of a constraint\n+               --  present, the node kind would have been N_Subtype_Indication.\n+\n+               if Nkind (Sindic) = N_Identifier then\n+                  return Is_Unchecked_Union (Base_Type (Etype (Sindic)));\n+               end if;\n+\n+               return False;\n+            end;\n+         end Component_Is_Unconstrained_UU;\n+\n+         ---------------------------------\n+         -- Variant_Is_Unconstrained_UU --\n+         ---------------------------------\n+\n+         function Variant_Is_Unconstrained_UU\n+           (Variant : Node_Id) return Boolean\n+         is\n+            Clist : constant Node_Id := Component_List (Variant);\n+\n+         begin\n+            if Is_Empty_List (Component_Items (Clist)) then\n+               return False;\n+            end if;\n+\n+            declare\n+               Comp : Node_Id := First (Component_Items (Clist));\n+\n+            begin\n+               while Present (Comp) loop\n+\n+                  --  One component is sufficent\n+\n+                  if Component_Is_Unconstrained_UU (Comp) then\n+                     return True;\n+                  end if;\n+\n+                  Next (Comp);\n+               end loop;\n+            end;\n+\n+            --  None of the components withing the variant were of\n+            --  unconstrained Unchecked_Union type.\n+\n+            return False;\n+         end Variant_Is_Unconstrained_UU;\n+\n+      --  Start of processing for Has_Unconstrained_UU_Component\n+\n+      begin\n+         if Null_Present (Tdef) then\n+            return False;\n+         end if;\n+\n+         Clist := Component_List (Tdef);\n+         Vpart := Variant_Part (Clist);\n+\n+         --  Inspect available components\n+\n+         if Present (Component_Items (Clist)) then\n+            declare\n+               Comp : Node_Id := First (Component_Items (Clist));\n+\n+            begin\n+               while Present (Comp) loop\n+\n+                  --  One component is sufficent\n+\n+                  if Component_Is_Unconstrained_UU (Comp) then\n+                     return True;\n+                  end if;\n+\n+                  Next (Comp);\n+               end loop;\n+            end;\n+         end if;\n+\n+         --  Inspect available components withing variants\n+\n+         if Present (Vpart) then\n+            declare\n+               Variant : Node_Id := First (Variants (Vpart));\n+\n+            begin\n+               while Present (Variant) loop\n+\n+                  --  One component within a variant is sufficent\n+\n+                  if Variant_Is_Unconstrained_UU (Variant) then\n+                     return True;\n+                  end if;\n+\n+                  Next (Variant);\n+               end loop;\n+            end;\n+         end if;\n+\n+         --  Neither the available components, nor the components inside the\n+         --  variant parts were of an unconstrained Unchecked_Union subtype.\n+\n+         return False;\n+      end Has_Unconstrained_UU_Component;\n+\n    --  Start of processing for Expand_N_Op_Eq\n \n    begin\n@@ -3899,6 +4354,50 @@ package body Exp_Ch4 is\n \n             Build_Equality_Call (Op_Name);\n \n+         --  Ada 2005 (AI-216): Program_Error is raised when evaluating the\n+         --  predefined equality operator for a type which has a subcomponent\n+         --  of an Unchecked_Union type whose nominal subtype is unconstrained.\n+\n+         elsif Has_Unconstrained_UU_Component (Typl) then\n+            Insert_Action (N,\n+              Make_Raise_Program_Error (Loc,\n+                Reason => PE_Unchecked_Union_Restriction));\n+\n+            --  Prevent Gigi from generating incorrect code by rewriting the\n+            --  equality as a standard False.\n+\n+            Rewrite (N,\n+              New_Occurrence_Of (Standard_False, Loc));\n+\n+         elsif Is_Unchecked_Union (Typl) then\n+\n+            --  If we can infer the discriminants of the operands, we make a\n+            --  call to the TSS equality function.\n+\n+            if Has_Inferable_Discriminants (Lhs)\n+                 and then\n+               Has_Inferable_Discriminants (Rhs)\n+            then\n+               Build_Equality_Call\n+                 (TSS (Root_Type (Typl), TSS_Composite_Equality));\n+\n+            else\n+               --  Ada 2005 (AI-216): Program_Error is raised when evaluating\n+               --  the predefined equality operator for an Unchecked_Union type\n+               --  if either of the operands lack inferable discriminants.\n+\n+               Insert_Action (N,\n+                 Make_Raise_Program_Error (Loc,\n+                   Reason => PE_Unchecked_Union_Restriction));\n+\n+               --  Prevent Gigi from generating incorrect code by rewriting\n+               --  the equality as a standard False.\n+\n+               Rewrite (N,\n+                 New_Occurrence_Of (Standard_False, Loc));\n+\n+            end if;\n+\n          --  If a type support function is present (for complex cases), use it\n \n          elsif Present (TSS (Root_Type (Typl), TSS_Composite_Equality)) then\n@@ -6288,7 +6787,33 @@ package body Exp_Ch4 is\n       --  assignment processing.\n \n       elsif Is_Record_Type (Target_Type) then\n-         Handle_Changed_Representation;\n+\n+         --  Ada 2005 (AI-216): Program_Error is raised when converting from\n+         --  a derived Unchecked_Union type to an unconstrained non-Unchecked_\n+         --  Union type if the operand lacks inferable discriminants.\n+\n+         if Is_Derived_Type (Operand_Type)\n+           and then Is_Unchecked_Union (Base_Type (Operand_Type))\n+           and then not Is_Constrained (Target_Type)\n+           and then not Is_Unchecked_Union (Base_Type (Target_Type))\n+           and then not Has_Inferable_Discriminants (Operand)\n+         then\n+            --  To prevent Gigi from generating illegal code, we make a\n+            --  Program_Error node, but we give it the target type of the\n+            --  conversion.\n+\n+            declare\n+               PE : constant Node_Id := Make_Raise_Program_Error (Loc,\n+                      Reason => PE_Unchecked_Union_Restriction);\n+\n+            begin\n+               Set_Etype (PE, Target_Type);\n+               Rewrite (N, PE);\n+\n+            end;\n+         else\n+            Handle_Changed_Representation;\n+         end if;\n \n       --  Case of conversions of enumeration types\n \n@@ -6555,31 +7080,6 @@ package body Exp_Ch4 is\n    --  Start of processing for Expand_Record_Equality\n \n    begin\n-      --  Special processing for the unchecked union case, which will occur\n-      --  only in the context of tagged types and dynamic dispatching, since\n-      --  other cases are handled statically. We return True, but insert a\n-      --  raise Program_Error statement.\n-\n-      if Is_Unchecked_Union (Typ) then\n-\n-         --  If this is a component of an enclosing record, return the Raise\n-         --  statement directly.\n-\n-         if No (Parent (Lhs)) then\n-            Result :=\n-              Make_Raise_Program_Error (Loc,\n-                Reason => PE_Unchecked_Union_Restriction);\n-            Set_Etype (Result, Standard_Boolean);\n-            return Result;\n-\n-         else\n-            Insert_Action (Lhs,\n-              Make_Raise_Program_Error (Loc,\n-                Reason => PE_Unchecked_Union_Restriction));\n-            return New_Occurrence_Of (Standard_True, Loc);\n-         end if;\n-      end if;\n-\n       --  Generates the following code: (assuming that Typ has one Discr and\n       --  component C2 is also a record)\n \n@@ -6712,6 +7212,90 @@ package body Exp_Ch4 is\n       return Find_Final_List (Owner);\n    end Get_Allocator_Final_List;\n \n+   ---------------------------------\n+   -- Has_Inferable_Discriminants --\n+   ---------------------------------\n+\n+   function Has_Inferable_Discriminants (N : Node_Id) return Boolean is\n+\n+      function Prefix_Is_Formal_Parameter (N : Node_Id) return Boolean;\n+      --  Determines whether the left-most prefix of a selected component is a\n+      --  formal parameter in a subprogram. Assumes N is a selected component.\n+\n+      --------------------------------\n+      -- Prefix_Is_Formal_Parameter --\n+      --------------------------------\n+\n+      function Prefix_Is_Formal_Parameter (N : Node_Id) return Boolean is\n+         Sel_Comp : Node_Id := N;\n+\n+      begin\n+         --  Move to the left-most prefix by climbing up the tree\n+\n+         while Present (Parent (Sel_Comp))\n+           and then Nkind (Parent (Sel_Comp)) = N_Selected_Component\n+         loop\n+            Sel_Comp := Parent (Sel_Comp);\n+         end loop;\n+\n+         return Ekind (Entity (Prefix (Sel_Comp))) in Formal_Kind;\n+      end Prefix_Is_Formal_Parameter;\n+\n+   --  Start of processing for Has_Inferable_Discriminants\n+\n+   begin\n+      --  For identifiers and indexed components, it is sufficent to have a\n+      --  constrained Unchecked_Union nominal subtype.\n+\n+      if Nkind (N) = N_Identifier\n+           or else\n+         Nkind (N) = N_Indexed_Component\n+      then\n+         return Is_Unchecked_Union (Base_Type (Etype (N)))\n+                  and then\n+                Is_Constrained (Etype (N));\n+\n+      --  For selected components, the subtype of the selector must be a\n+      --  constrained Unchecked_Union. If the component is subject to a\n+      --  per-object constraint, then the enclosing object must have inferable\n+      --  discriminants.\n+\n+      elsif Nkind (N) = N_Selected_Component then\n+         if Has_Per_Object_Constraint (Entity (Selector_Name (N))) then\n+\n+            --  A small hack. If we have a per-object constrained selected\n+            --  component of a formal parameter, return True since we do not\n+            --  know the actual parameter association yet.\n+\n+            if Prefix_Is_Formal_Parameter (N) then\n+               return True;\n+            end if;\n+\n+            --  Otherwise, check the enclosing object and the selector\n+\n+            return Has_Inferable_Discriminants (Prefix (N))\n+                     and then\n+                   Has_Inferable_Discriminants (Selector_Name (N));\n+         end if;\n+\n+         --  The call to Has_Inferable_Discriminants will determine whether\n+         --  the selector has a constrained Unchecked_Union nominal type.\n+\n+         return Has_Inferable_Discriminants (Selector_Name (N));\n+\n+      --  A qualified expression has inferable discriminants if its subtype\n+      --  mark is a constrained Unchecked_Union subtype.\n+\n+      elsif Nkind (N) = N_Qualified_Expression then\n+         return Is_Unchecked_Union (Subtype_Mark (N))\n+                  and then\n+                Is_Constrained (Subtype_Mark (N));\n+\n+      end if;\n+\n+      return False;\n+   end Has_Inferable_Discriminants;\n+\n    -------------------------------\n    -- Insert_Dereference_Action --\n    -------------------------------"}, {"sha": "1d982eeea4beef573ca6e9d9ce8caa4fb24473f1", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 255, "deletions": 146, "changes": 401, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=5d09245e6a54b290b5f44b686214b41cf555152a", "patch": "@@ -43,6 +43,7 @@ with Rident;   use Rident;\n with Rtsfind;  use Rtsfind;\n with Sinfo;    use Sinfo;\n with Sem;      use Sem;\n+with Sem_Ch3;  use Sem_Ch3;\n with Sem_Ch8;  use Sem_Ch8;\n with Sem_Ch13; use Sem_Ch13;\n with Sem_Eval; use Sem_Eval;\n@@ -1096,13 +1097,22 @@ package body Exp_Ch5 is\n          --  the type may be private and resolution by identifier alone would\n          --  fail.\n \n-         function Make_Component_List_Assign (CL : Node_Id) return List_Id;\n+         function Make_Component_List_Assign\n+           (CL  : Node_Id;\n+            U_U : Boolean := False) return List_Id;\n          --  Returns a sequence of statements to assign the components that\n-         --  are referenced in the given component list.\n-\n-         function Make_Field_Assign (C : Entity_Id) return Node_Id;\n-         --  Given C, the entity for a discriminant or component, build\n-         --  an assignment for the corresponding field values.\n+         --  are referenced in the given component list. The flag U_U is\n+         --  used to force the usage of the inferred value of the variant\n+         --  part expression as the switch for the generated case statement.\n+\n+         function Make_Field_Assign\n+           (C : Entity_Id;\n+            U_U : Boolean := False) return Node_Id;\n+         --  Given C, the entity for a discriminant or component, build an\n+         --  assignment for the corresponding field values. The flag U_U\n+         --  signals the presence of an Unchecked_Union and forces the usage\n+         --  of the inferred discriminant value of C as the right hand side\n+         --  of the assignment.\n \n          function Make_Field_Assigns (CI : List_Id) return List_Id;\n          --  Given CI, a component items list, construct series of statements\n@@ -1136,15 +1146,19 @@ package body Exp_Ch5 is\n          -- Make_Component_List_Assign --\n          --------------------------------\n \n-         function Make_Component_List_Assign (CL : Node_Id) return List_Id is\n+         function Make_Component_List_Assign\n+           (CL  : Node_Id;\n+            U_U : Boolean := False) return List_Id\n+         is\n             CI : constant List_Id := Component_Items (CL);\n             VP : constant Node_Id := Variant_Part (CL);\n \n-            Result : List_Id;\n             Alts   : List_Id;\n-            V      : Node_Id;\n             DC     : Node_Id;\n             DCH    : List_Id;\n+            Expr   : Node_Id;\n+            Result : List_Id;\n+            V      : Node_Id;\n \n          begin\n             Result := Make_Field_Assigns (CI);\n@@ -1170,15 +1184,29 @@ package body Exp_Ch5 is\n                   Next_Non_Pragma (V);\n                end loop;\n \n+               --  If we have an Unchecked_Union, use the value of the inferred\n+               --  discriminant of the variant part expression as the switch\n+               --  for the case statement. The case statement may later be\n+               --  folded.\n+\n+               if U_U then\n+                  Expr :=\n+                    New_Copy (Get_Discriminant_Value (\n+                      Entity (Name (VP)),\n+                      Etype (Rhs),\n+                      Discriminant_Constraint (Etype (Rhs))));\n+               else\n+                  Expr :=\n+                    Make_Selected_Component (Loc,\n+                      Prefix => Duplicate_Subexpr (Rhs),\n+                      Selector_Name =>\n+                        Make_Identifier (Loc, Chars (Name (VP))));\n+               end if;\n+\n                Append_To (Result,\n                  Make_Case_Statement (Loc,\n-                   Expression =>\n-                     Make_Selected_Component (Loc,\n-                       Prefix => Duplicate_Subexpr (Rhs),\n-                       Selector_Name =>\n-                         Make_Identifier (Loc, Chars (Name (VP)))),\n+                   Expression => Expr,\n                    Alternatives => Alts));\n-\n             end if;\n \n             return Result;\n@@ -1188,21 +1216,37 @@ package body Exp_Ch5 is\n          -- Make_Field_Assign --\n          -----------------------\n \n-         function Make_Field_Assign (C : Entity_Id) return Node_Id is\n-            A : Node_Id;\n+         function Make_Field_Assign\n+           (C : Entity_Id;\n+            U_U : Boolean := False) return Node_Id\n+         is\n+            A    : Node_Id;\n+            Expr : Node_Id;\n \n          begin\n+            --  In the case of an Unchecked_Union, use the discriminant\n+            --  constraint value as on the right hand side of the assignment.\n+\n+            if U_U then\n+               Expr :=\n+                 New_Copy (Get_Discriminant_Value (C,\n+                   Etype (Rhs),\n+                   Discriminant_Constraint (Etype (Rhs))));\n+            else\n+               Expr :=\n+                 Make_Selected_Component (Loc,\n+                   Prefix => Duplicate_Subexpr (Rhs),\n+                   Selector_Name => New_Occurrence_Of (C, Loc));\n+            end if;\n+\n             A :=\n               Make_Assignment_Statement (Loc,\n                 Name =>\n                   Make_Selected_Component (Loc,\n                     Prefix => Duplicate_Subexpr (Lhs),\n                     Selector_Name =>\n                       New_Occurrence_Of (Find_Component (L_Typ, C), Loc)),\n-                Expression =>\n-                  Make_Selected_Component (Loc,\n-                    Prefix => Duplicate_Subexpr (Rhs),\n-                    Selector_Name => New_Occurrence_Of (C, Loc)));\n+                Expression => Expr);\n \n             --  Set Assignment_OK, so discriminants can be assigned\n \n@@ -1221,7 +1265,6 @@ package body Exp_Ch5 is\n          begin\n             Item := First (CI);\n             Result := New_List;\n-\n             while Present (Item) loop\n                if Nkind (Item) = N_Component_Declaration then\n                   Append_To\n@@ -1251,7 +1294,13 @@ package body Exp_Ch5 is\n          if Has_Discriminants (L_Typ) then\n             F := First_Discriminant (R_Typ);\n             while Present (F) loop\n-               Insert_Action (N, Make_Field_Assign (F));\n+\n+               if Is_Unchecked_Union (Base_Type (R_Typ)) then\n+                  Insert_Action (N, Make_Field_Assign (F, True));\n+               else\n+                  Insert_Action (N, Make_Field_Assign (F));\n+               end if;\n+\n                Next_Discriminant (F);\n             end loop;\n          end if;\n@@ -1270,8 +1319,14 @@ package body Exp_Ch5 is\n          if Nkind (RDef) = N_Record_Definition\n            and then Present (Component_List (RDef))\n          then\n-            Insert_Actions\n-              (N, Make_Component_List_Assign (Component_List (RDef)));\n+\n+            if Is_Unchecked_Union (R_Typ) then\n+               Insert_Actions (N,\n+                 Make_Component_List_Assign (Component_List (RDef), True));\n+            else\n+               Insert_Actions\n+                 (N, Make_Component_List_Assign (Component_List (RDef)));\n+            end if;\n \n             Rewrite (N, Make_Null_Statement (Loc));\n          end if;\n@@ -3032,7 +3087,6 @@ package body Exp_Ch5 is\n \n       Res       : List_Id;\n       Tag_Tmp   : Entity_Id;\n-      Original_Size, Range_Type, Opaque_Type : Entity_Id;\n \n    begin\n       Res := New_List;\n@@ -3091,83 +3145,21 @@ package body Exp_Ch5 is\n          Tag_Tmp := Empty;\n       end if;\n \n-      --  We really need a comment here ???\n-\n-      if Ctrl_Act then\n-\n-         --  subtype G is Storage_Offset range 1 .. Expr'Size\n-\n-         Original_Size :=\n-           Make_Defining_Identifier (Loc,\n-             New_Internal_Name ('S'));\n-\n-         Append_To (Res,\n-           Make_Object_Declaration (Loc,\n-             Defining_Identifier => Original_Size,\n-             Constant_Present    => True,\n-             Object_Definition   => New_Occurrence_Of (\n-               RTE (RE_Storage_Offset), Loc),\n-             Expression          =>\n-               Make_Op_Divide (Loc,\n-                 Left_Opnd =>\n-                   Make_Attribute_Reference (Loc,\n-                     Prefix =>\n-                       Duplicate_Subexpr_No_Checks (L),\n-                     Attribute_Name => Name_Size),\n-                 Right_Opnd => Make_Integer_Literal (Loc,\n-                     Intval => System_Storage_Unit))));\n-\n-         Range_Type :=\n-           Make_Defining_Identifier (Loc,\n-             New_Internal_Name ('G'));\n+      --  Processing for controlled types and types with controlled components\n \n-         Append_To (Res,\n-           Make_Subtype_Declaration (Loc,\n-             Defining_Identifier => Range_Type,\n-             Subtype_Indication =>\n-               Make_Subtype_Indication (Loc,\n-                 Subtype_Mark =>\n-                   New_Reference_To (RTE (RE_Storage_Offset), Loc),\n-                 Constraint   => Make_Range_Constraint (Loc,\n-                   Range_Expression =>\n-                     Make_Range (Loc,\n-                       Low_Bound  => Make_Integer_Literal (Loc, 1),\n-                       High_Bound => New_Occurrence_Of (\n-                         Original_Size, Loc))))));\n-\n-         --  subtype S is Storage_Array (G)\n+      --  Variables of such types contain pointers used to chain them in\n+      --  finalization lists, in addition to user data. These pointers are\n+      --  specific to each object of the type, not to the value being assigned.\n+      --  Thus they need to be left intact during the assignment. We achieve\n+      --  this by constructing a Storage_Array subtype, and by overlaying\n+      --  objects of this type on the source and target of the assignment.\n+      --  The assignment is then rewritten to assignments of slices of these\n+      --  arrays, copying the user data, and leaving the pointers untouched.\n \n-         Append_To (Res,\n-           Make_Subtype_Declaration (Loc,\n-             Defining_Identifier =>\n-               Make_Defining_Identifier (Loc,\n-                 New_Internal_Name ('S')),\n-             Subtype_Indication  =>\n-               Make_Subtype_Indication (Loc,\n-                 Subtype_Mark =>\n-                   New_Reference_To (RTE (RE_Storage_Array), Loc),\n-                 Constraint =>\n-                   Make_Index_Or_Discriminant_Constraint (Loc,\n-                     Constraints =>\n-                       New_List (New_Reference_To (Range_Type, Loc))))));\n-\n-         --  type A is access S\n-\n-         Opaque_Type := Make_Defining_Identifier (Loc,\n-           New_Internal_Name ('A'));\n-         Append_To (Res,\n-           Make_Full_Type_Declaration (Loc,\n-             Defining_Identifier => Opaque_Type,\n-             Type_Definition     =>\n-               Make_Access_To_Object_Definition (Loc,\n-                 Subtype_Indication =>\n-                   New_Occurrence_Of (\n-                     Defining_Identifier (Last (Res)), Loc))));\n-\n-         --  Give a label name to this declare block, and add comments here???\n-\n-         declare\n+      if Ctrl_Act then\n+         Controlled_Actions : declare\n             Prev_Ref : Node_Id;\n+            --  A reference to the Prev component of the record controller\n \n             First_After_Root : Node_Id := Empty;\n             --  Index of first byte to be copied (used to skip\n@@ -3184,31 +3176,44 @@ package body Exp_Ch5 is\n             --  Index of first byte to be copied after outermost record\n             --  controller data.\n \n+            Expr, Source_Size      : Node_Id;\n+            --  Used for computation of the size of the data to be copied\n+\n+            Range_Type  : Entity_Id;\n+            Opaque_Type : Entity_Id;\n+\n             function Build_Slice\n-              (Rec    : Entity_Id;\n-               Lo, Hi : Node_Id) return Node_Id;\n-            --  Function specs must have comments, saying what all the\n-            --  parameters are and what the function does ???\n+              (Rec : Entity_Id;\n+               Lo  : Node_Id;\n+               Hi  : Node_Id) return Node_Id;\n+            --  Build and return a slice of an array of type S overlaid\n+            --  on object Rec, with bounds specified by Lo and Hi. If either\n+            --  bound is empty, a default of S'First (respectively S'Last)\n+            --  is used.\n \n             -----------------\n             -- Build_Slice --\n             -----------------\n \n             function Build_Slice\n-              (Rec    : Node_Id;\n-               Lo, Hi : Node_Id) return Node_Id\n+              (Rec : Node_Id;\n+               Lo  : Node_Id;\n+               Hi  : Node_Id) return Node_Id\n             is\n-               Lo_Bound, Hi_Bound : Node_Id;\n+               Lo_Bound : Node_Id;\n+               Hi_Bound : Node_Id;\n \n                Opaque : constant Node_Id :=\n                           Unchecked_Convert_To (Opaque_Type,\n                             Make_Attribute_Reference (Loc,\n                               Prefix         => Rec,\n                               Attribute_Name => Name_Address));\n-               --  Comment required, what is this???\n+               --  Access value designating an opaque storage array of\n+               --  type S overlaid on record Rec.\n \n             begin\n-               --  Comments required in this body ???\n+               --  Compute slice bounds using S'First (1) and S'Last\n+               --  as default values when not specified by the caller.\n \n                if No (Lo) then\n                   Lo_Bound := Make_Integer_Literal (Loc, 1);\n@@ -3231,12 +3236,102 @@ package body Exp_Ch5 is\n                    Lo_Bound, Hi_Bound));\n             end Build_Slice;\n \n-         --  Start of processing for ??? (name of block)\n+         --  Start of processing for Controlled_Actions\n \n          begin\n+            --  Create a constrained subtype of Storage_Array whose size\n+            --  corresponds to the value being assigned.\n+\n+            --  subtype G is Storage_Offset range\n+            --    1 .. (Expr'Size + Storage_Unit - 1) / Storage_Unit\n+\n+            Expr := Duplicate_Subexpr_No_Checks (Expression (N));\n+\n+            if Nkind (Expr) = N_Qualified_Expression then\n+               Expr := Expression (Expr);\n+            end if;\n+\n+            Source_Size :=\n+              Make_Op_Add (Loc,\n+                Left_Opnd =>\n+                  Make_Attribute_Reference (Loc,\n+                    Prefix =>\n+                      Expr,\n+                    Attribute_Name =>\n+                      Name_Size),\n+                Right_Opnd =>\n+                  Make_Integer_Literal (Loc,\n+                  System_Storage_Unit - 1));\n+\n+            --  If Expr is a type conversion, standard Ada does not allow\n+            --  'Size to be taken on it, but Gigi can handle this case,\n+            --  and thus we can determine the amount of data to be copied.\n+            --  The appropriate circuitry is enabled only for conversions\n+            --  that do not Come_From_Source.\n+\n+            Set_Comes_From_Source (Prefix (Left_Opnd (Source_Size)), False);\n+\n+            Source_Size :=\n+              Make_Op_Divide (Loc,\n+                Left_Opnd => Source_Size,\n+                Right_Opnd =>\n+                  Make_Integer_Literal (Loc,\n+                    Intval => System_Storage_Unit));\n+\n+            Range_Type :=\n+              Make_Defining_Identifier (Loc,\n+                New_Internal_Name ('G'));\n+\n+            Append_To (Res,\n+              Make_Subtype_Declaration (Loc,\n+                Defining_Identifier => Range_Type,\n+                Subtype_Indication =>\n+                  Make_Subtype_Indication (Loc,\n+                    Subtype_Mark =>\n+                      New_Reference_To (RTE (RE_Storage_Offset), Loc),\n+                    Constraint   => Make_Range_Constraint (Loc,\n+                      Range_Expression =>\n+                        Make_Range (Loc,\n+                          Low_Bound  => Make_Integer_Literal (Loc, 1),\n+                          High_Bound => Source_Size)))));\n+\n+            --  subtype S is Storage_Array (G)\n+\n+            Append_To (Res,\n+              Make_Subtype_Declaration (Loc,\n+                Defining_Identifier =>\n+                  Make_Defining_Identifier (Loc,\n+                    New_Internal_Name ('S')),\n+                Subtype_Indication  =>\n+                  Make_Subtype_Indication (Loc,\n+                    Subtype_Mark =>\n+                      New_Reference_To (RTE (RE_Storage_Array), Loc),\n+                    Constraint =>\n+                      Make_Index_Or_Discriminant_Constraint (Loc,\n+                        Constraints =>\n+                          New_List (New_Reference_To (Range_Type, Loc))))));\n+\n+            --  type A is access S\n+\n+            Opaque_Type :=\n+              Make_Defining_Identifier (Loc,\n+                Chars => New_Internal_Name ('A'));\n+\n+            Append_To (Res,\n+              Make_Full_Type_Declaration (Loc,\n+                Defining_Identifier => Opaque_Type,\n+                Type_Definition     =>\n+                  Make_Access_To_Object_Definition (Loc,\n+                    Subtype_Indication =>\n+                      New_Occurrence_Of (\n+                        Defining_Identifier (Last (Res)), Loc))));\n+\n+            --  Generate appropriate slice assignments\n+\n             First_After_Root := Make_Integer_Literal (Loc, 1);\n \n-            --  Comment ???\n+            --  For the case of a controlled object, skip the\n+            --  Root_Controlled part.\n \n             if Is_Controlled (T) then\n                First_After_Root :=\n@@ -3250,12 +3345,12 @@ package body Exp_Ch5 is\n                      Make_Integer_Literal (Loc, System_Storage_Unit)));\n             end if;\n \n-            if Has_Controlled_Component (T) then\n-\n-               --  The record controller Prev and Next pointers must be left\n-               --  intact in the target object, not copied. Compute the bounds\n-               --  of the hole to be skipped in copying the objecct.\n+            --  For the case of a record with controlled components, skip\n+            --  the Prev and Next components of the record controller.\n+            --  These components constitute a 'hole' in the middle of the\n+            --  data to be copied.\n \n+            if Has_Controlled_Component (T) then\n                Prev_Ref :=\n                  Make_Selected_Component (Loc,\n                    Prefix =>\n@@ -3265,7 +3360,8 @@ package body Exp_Ch5 is\n                          New_Reference_To (Controller_Component (T), Loc)),\n                    Selector_Name =>  Make_Identifier (Loc, Name_Prev));\n \n-               --  Last index before hole\n+               --  Last index before hole: determined by position of\n+               --  the _Controller.Prev component.\n \n                Last_Before_Hole :=\n                  Make_Defining_Identifier (Loc,\n@@ -3285,18 +3381,20 @@ package body Exp_Ch5 is\n                          Prefix => New_Copy_Tree (Prefix (Prev_Ref)),\n                          Attribute_Name => Name_Position))));\n \n-               --  Hole length\n+               --  Hole length: size of the Prev and Next components\n \n                Hole_Length :=\n                  Make_Op_Multiply (Loc,\n-                   Make_Integer_Literal (Loc, Uint_2),\n+                   Left_Opnd  => Make_Integer_Literal (Loc, Uint_2),\n+                   Right_Opnd =>\n                      Make_Op_Divide (Loc,\n-                       Make_Attribute_Reference (Loc,\n-                         Prefix =>\n-                           New_Copy_Tree (Prev_Ref),\n-                         Attribute_Name =>\n-                           Name_Size),\n-                     Make_Integer_Literal (Loc, System_Storage_Unit)));\n+                       Left_Opnd =>\n+                         Make_Attribute_Reference (Loc,\n+                           Prefix         => New_Copy_Tree (Prev_Ref),\n+                           Attribute_Name => Name_Size),\n+                       Right_Opnd =>\n+                         Make_Integer_Literal (Loc,\n+                           Intval => System_Storage_Unit)));\n \n                --  First index after hole\n \n@@ -3312,44 +3410,55 @@ package body Exp_Ch5 is\n                    Constant_Present    => True,\n                    Expression          =>\n                      Make_Op_Add (Loc,\n-                       Make_Op_Add (Loc,\n-                         New_Occurrence_Of (Last_Before_Hole, Loc),\n-                         Hole_Length),\n-                       Make_Integer_Literal (Loc, 1))));\n+                       Left_Opnd  =>\n+                         Make_Op_Add (Loc,\n+                           Left_Opnd  =>\n+                             New_Occurrence_Of (Last_Before_Hole, Loc),\n+                           Right_Opnd => Hole_Length),\n+                       Right_Opnd => Make_Integer_Literal (Loc, 1))));\n \n                Last_Before_Hole := New_Occurrence_Of (Last_Before_Hole, Loc);\n                First_After_Hole := New_Occurrence_Of (First_After_Hole, Loc);\n             end if;\n \n-            --  More comments needed everywhere ???\n+            --  Assign the first slice (possibly skipping Root_Controlled,\n+            --  up to the beginning of the record controller if present,\n+            --  up to the end of the object if not).\n \n             Append_To (Res, Make_Assignment_Statement (Loc,\n-              Name       => Build_Slice (Duplicate_Subexpr_No_Checks (L),\n-                                         First_After_Root,\n-                                         Last_Before_Hole),\n-\n-              Expression => Build_Slice (Expression (N),\n-                                         First_After_Root,\n-                                         New_Copy_Tree (Last_Before_Hole))));\n+              Name       => Build_Slice (\n+                Rec => Duplicate_Subexpr_No_Checks (L),\n+                Lo  => First_After_Root,\n+                Hi  => Last_Before_Hole),\n \n+              Expression => Build_Slice (\n+                Rec => Expression (N),\n+                Lo  => First_After_Root,\n+                Hi  => New_Copy_Tree (Last_Before_Hole))));\n \n             if Present (First_After_Hole) then\n-               Remove_Side_Effects (Expression (N));\n+\n+               --  If a record controller is present, copy the second slice,\n+               --  from right after the _Controller.Next component up to the\n+               --  end of the object.\n+\n                Append_To (Res, Make_Assignment_Statement (Loc,\n-                 Name       => Build_Slice (Duplicate_Subexpr_No_Checks (L),\n-                                            First_After_Hole,\n-                                            Empty),\n-                 Expression => Build_Slice (New_Copy_Tree (Expression (N)),\n-                                            New_Copy_Tree (First_After_Hole),\n-                                            Empty)));\n+                 Name       => Build_Slice (\n+                   Rec => Duplicate_Subexpr_No_Checks (L),\n+                   Lo  => First_After_Hole,\n+                   Hi  => Empty),\n+                 Expression => Build_Slice (\n+                   Rec => Duplicate_Subexpr_No_Checks (Expression (N)),\n+                   Lo  => New_Copy_Tree (First_After_Hole),\n+                   Hi  => Empty)));\n             end if;\n-         end;\n+         end Controlled_Actions;\n \n       else\n          Append_To (Res, Relocate_Node (N));\n       end if;\n \n-      --  Restore the Tag\n+      --  Restore the tag\n \n       if Save_Tag then\n          Append_To (Res,"}, {"sha": "62de53a77c8c85e90d7f90043a1ce741bcf29168", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=5d09245e6a54b290b5f44b686214b41cf555152a", "patch": "@@ -1376,6 +1376,12 @@ package body Exp_Ch6 is\n                  New_Occurrence_Of (Standard_True, Loc),\n                  Extra_Constrained (Formal));\n \n+            --  Do not produce extra actuals for Unchecked_Union parameters.\n+            --  Jump directly to the end of the loop.\n+\n+            elsif Is_Unchecked_Union (Base_Type (Etype (Actual))) then\n+               goto Skip_Extra_Actual_Generation;\n+\n             else\n                --  If the actual is a type conversion, then the constrained\n                --  test applies to the actual, not the target type.\n@@ -1660,6 +1666,11 @@ package body Exp_Ch6 is\n                     Reason => PE_Illegal_RACW_E_4_18))));\n          end if;\n \n+         --  This label is required when skipping extra actual generation for\n+         --  Unchecked_Union parameters.\n+\n+         <<Skip_Extra_Actual_Generation>>\n+\n          Next_Actual (Actual);\n          Next_Formal (Formal);\n       end loop;"}, {"sha": "eb6abd02f343fc4156bb767c8fe58eb2bd4af86f", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=5d09245e6a54b290b5f44b686214b41cf555152a", "patch": "@@ -1984,16 +1984,28 @@ package body Exp_Ch7 is\n    ------------------------------------\n \n    procedure Insert_Actions_In_Scope_Around (N : Node_Id) is\n-      SE : Scope_Stack_Entry renames Scope_Stack.Table (Scope_Stack.Last);\n+      SE     : Scope_Stack_Entry renames Scope_Stack.Table (Scope_Stack.Last);\n+      Target : Node_Id;\n \n    begin\n+      --  If the node to be wrapped is the triggering alternative of an\n+      --  asynchronous select, it is not part of a statement list. The\n+      --  actions must be inserted before the Select itself, which is\n+      --  part of some list of statements.\n+\n+      if Nkind (Parent (Node_To_Be_Wrapped)) = N_Triggering_Alternative then\n+         Target := Parent (Parent (Node_To_Be_Wrapped));\n+      else\n+         Target := N;\n+      end if;\n+\n       if Present (SE.Actions_To_Be_Wrapped_Before) then\n-         Insert_List_Before (N, SE.Actions_To_Be_Wrapped_Before);\n+         Insert_List_Before (Target, SE.Actions_To_Be_Wrapped_Before);\n          SE.Actions_To_Be_Wrapped_Before := No_List;\n       end if;\n \n       if Present (SE.Actions_To_Be_Wrapped_After) then\n-         Insert_List_After (N, SE.Actions_To_Be_Wrapped_After);\n+         Insert_List_After (Target, SE.Actions_To_Be_Wrapped_After);\n          SE.Actions_To_Be_Wrapped_After := No_List;\n       end if;\n    end Insert_Actions_In_Scope_Around;"}, {"sha": "cee69c4776254ae60f93c1def3384308ab7ee081", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=5d09245e6a54b290b5f44b686214b41cf555152a", "patch": "@@ -4275,7 +4275,7 @@ package body Freeze is\n       Ensure_Type_Is_SA (Etype (E));\n \n       --  Reset True_Constant flag, since something strange is going on\n-      --  with the scoping here, and our simple value traceing may not\n+      --  with the scoping here, and our simple value tracing may not\n       --  be sufficient for this indication to be reliable. We kill the\n       --  Constant_Value indication for the same reason.\n "}, {"sha": "b2d4f259cc30ed2fc5d51c5cda77f504d01c09f2", "filename": "gcc/ada/g-socket.adb", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fg-socket.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fg-socket.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-socket.adb?ref=5d09245e6a54b290b5f44b686214b41cf555152a", "patch": "@@ -44,7 +44,7 @@ with GNAT.Task_Lock;\n \n with GNAT.Sockets.Linker_Options;\n pragma Warnings (Off, GNAT.Sockets.Linker_Options);\n---  Need to include pragma Linker_Options which is platform dependent.\n+--  Need to include pragma Linker_Options which is platform dependent\n \n with System; use System;\n \n@@ -226,9 +226,9 @@ package body GNAT.Sockets is\n    --------------------\n \n    procedure Abort_Selector (Selector : Selector_Type) is\n-      Buf     : Character;\n+      Buf     : aliased Character := ASCII.NUL;\n       Discard : C.int;\n-      pragma Warnings (Off, Discard);\n+      pragma Unreferenced (Discard);\n \n    begin\n       --  Send an empty array to unblock C select system call\n@@ -1288,7 +1288,7 @@ package body GNAT.Sockets is\n    begin\n       return Item.Last /= No_Socket\n         and then Socket <= Item.Last\n-        and then Is_Socket_In_Set (Item.Set, C.int (Socket));\n+        and then Is_Socket_In_Set (Item.Set, C.int (Socket)) /= 0;\n    end Is_Set;\n \n    -------------------\n@@ -1865,22 +1865,23 @@ package body GNAT.Sockets is\n       use type C.unsigned_short;\n \n    begin\n-      pragma Warnings (Off);\n-\n       --  Big-endian case. No conversion needed. On these platforms,\n       --  htons() defaults to a null procedure.\n \n+      pragma Warnings (Off);\n+      --  Since the test can generate \"always True/False\" warning\n+\n       if Default_Bit_Order = High_Order_First then\n          return S;\n \n+         pragma Warnings (On);\n+\n       --  Little-endian case. We must swap the high and low bytes of this\n       --  short to make the port number network compliant.\n \n       else\n          return (S / 256) + (S mod 256) * 256;\n       end if;\n-\n-      pragma Warnings (On);\n    end Short_To_Network;\n \n    ---------------------"}, {"sha": "214e0f37740131a9999f7eceb30e5fa50860df4a", "filename": "gcc/ada/g-socthi-mingw.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fg-socthi-mingw.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fg-socthi-mingw.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-socthi-mingw.adb?ref=5d09245e6a54b290b5f44b686214b41cf555152a", "patch": "@@ -385,7 +385,7 @@ package body GNAT.Sockets.Thin is\n                   --  is not watching for it.\n \n                   if WFSC /= No_Fd_Set\n-                    and then Is_Socket_In_Set (WFSC, S)\n+                    and then (Is_Socket_In_Set (WFSC, S) /= 0)\n                   then\n                      Insert_Socket_In_Set (WFS, S);\n                   end if;"}, {"sha": "f13b907ecf0f0a5e500b1f252eaadb00db830ae4", "filename": "gcc/ada/g-socthi-mingw.ads", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fg-socthi-mingw.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fg-socthi-mingw.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-socthi-mingw.ads?ref=5d09245e6a54b290b5f44b686214b41cf555152a", "patch": "@@ -364,8 +364,9 @@ package GNAT.Sockets.Thin is\n \n    function  Is_Socket_In_Set\n      (Set    : Fd_Set_Access;\n-      Socket : C.int) return Boolean;\n-   --  Check whether Socket is in the socket set\n+      Socket : C.int) return C.int;\n+   --  Check whether Socket is in the socket set, return a non-zero\n+   --  value if it is, zero if it is not.\n \n    procedure Last_Socket_In_Set\n      (Set  : Fd_Set_Access;"}, {"sha": "4d4a9110e5f0602ec0fd944e6c6f338d1eb5a7cc", "filename": "gcc/ada/g-socthi-vms.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fg-socthi-vms.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fg-socthi-vms.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-socthi-vms.adb?ref=5d09245e6a54b290b5f44b686214b41cf555152a", "patch": "@@ -403,7 +403,7 @@ package body GNAT.Sockets.Thin is\n       R : Boolean;\n    begin\n       Task_Lock.Lock;\n-      R := Is_Socket_In_Set (Non_Blocking_Sockets, S);\n+      R := (Is_Socket_In_Set (Non_Blocking_Sockets, S) /= 0);\n       Task_Lock.Unlock;\n       return R;\n    end Non_Blocking_Socket;"}, {"sha": "47f2827d761150ed9328ddd9b8687286259ffea1", "filename": "gcc/ada/g-socthi-vms.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fg-socthi-vms.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fg-socthi-vms.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-socthi-vms.ads?ref=5d09245e6a54b290b5f44b686214b41cf555152a", "patch": "@@ -385,9 +385,9 @@ package GNAT.Sockets.Thin is\n \n    function  Is_Socket_In_Set\n      (Set    : Fd_Set_Access;\n-      Socket : C.int)\n-     return Boolean;\n-   --  Check whether Socket is in the socket set.\n+      Socket : C.int) return C.int;\n+   --  Check whether Socket is in the socket set, return a non-zero\n+   --  value if it is, zero if it is not.\n \n    procedure Last_Socket_In_Set\n      (Set    : Fd_Set_Access;"}, {"sha": "06a60cae2d96427a2f3a7fbd31237de07c2e529e", "filename": "gcc/ada/g-socthi-vxworks.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fg-socthi-vxworks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fg-socthi-vxworks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-socthi-vxworks.adb?ref=5d09245e6a54b290b5f44b686214b41cf555152a", "patch": "@@ -518,7 +518,7 @@ package body GNAT.Sockets.Thin is\n \n    begin\n       Task_Lock.Lock;\n-      R := Is_Socket_In_Set (Non_Blocking_Sockets, S);\n+      R := (Is_Socket_In_Set (Non_Blocking_Sockets, S) /= 0);\n       Task_Lock.Unlock;\n       return R;\n    end Non_Blocking_Socket;"}, {"sha": "f389e9a484de3f1881318500da7f7bdd26a47982", "filename": "gcc/ada/g-socthi-vxworks.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fg-socthi-vxworks.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fg-socthi-vxworks.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-socthi-vxworks.ads?ref=5d09245e6a54b290b5f44b686214b41cf555152a", "patch": "@@ -387,9 +387,9 @@ package GNAT.Sockets.Thin is\n \n    function  Is_Socket_In_Set\n      (Set    : Fd_Set_Access;\n-      Socket : C.int)\n-     return Boolean;\n-   --  Check whether Socket is in the socket set\n+      Socket : C.int) return C.int;\n+   --  Check whether Socket is in the socket set, return a non-zero\n+   --  value if it is, zero if it is not.\n \n    procedure Last_Socket_In_Set\n      (Set    : Fd_Set_Access;"}, {"sha": "9600cda64285dbd76228f6f43d87b4b80e789b4f", "filename": "gcc/ada/g-socthi.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fg-socthi.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fg-socthi.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-socthi.adb?ref=5d09245e6a54b290b5f44b686214b41cf555152a", "patch": "@@ -407,7 +407,7 @@ package body GNAT.Sockets.Thin is\n       R : Boolean;\n    begin\n       Task_Lock.Lock;\n-      R := Is_Socket_In_Set (Non_Blocking_Sockets, S);\n+      R := (Is_Socket_In_Set (Non_Blocking_Sockets, S) /= 0);\n       Task_Lock.Unlock;\n       return R;\n    end Non_Blocking_Socket;"}, {"sha": "7a818d88a374d6c503fb471d9a5e2fe59ba192a5", "filename": "gcc/ada/g-socthi.ads", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fg-socthi.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fg-socthi.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-socthi.ads?ref=5d09245e6a54b290b5f44b686214b41cf555152a", "patch": "@@ -360,8 +360,9 @@ package GNAT.Sockets.Thin is\n \n    function  Is_Socket_In_Set\n      (Set    : Fd_Set_Access;\n-      Socket : C.int) return Boolean;\n-   --  Check whether Socket is in the socket set\n+      Socket : C.int) return C.int;\n+   --  Check whether Socket is in the socket set, return a non-zero\n+   --  value if it is, zero if it is not.\n \n    procedure Last_Socket_In_Set\n      (Set    : Fd_Set_Access;"}, {"sha": "d3d28367e8831fc1a81bc24c6a4b2462bdf2b37a", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 115, "deletions": 42, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=5d09245e6a54b290b5f44b686214b41cf555152a", "patch": "@@ -16,7 +16,11 @@\n @c oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\n \n @setfilename gnat_rm.info\n+\n+@set FSFEDITION\n+\n @settitle GNAT Reference Manual\n+\n @setchapternewpage odd\n @syncodeindex fn cp\n \n@@ -82,6 +86,7 @@ Ada Core Technologies, Inc.\n * Specialized Needs Annexes::\n * Implementation of Specific Ada Features::\n * Project File Reference::\n+* Obsolescent Features::\n * GNU Free Documentation License::\n * Index::\n \n@@ -152,10 +157,10 @@ Implementation Defined Pragmas\n * Pragma Passive::\n * Pragma Polling::\n * Pragma Profile (Ravenscar)::\n+* Pragma Profile (Restricted)::\n * Pragma Propagate_Exceptions::\n * Pragma Psect_Object::\n * Pragma Pure_Function::\n-* Pragma Restricted_Run_Time::\n * Pragma Restriction_Warnings::\n * Pragma Source_File_Name::\n * Pragma Source_File_Name_Project::\n@@ -378,6 +383,8 @@ Implementation of Specific Ada Features\n \n Project File Reference\n \n+Obsolescent Features\n+\n GNU Free Documentation License\n \n Index\n@@ -388,11 +395,21 @@ Index\n @node About This Guide\n @unnumbered About This Guide\n \n+@ifclear PROEDITION\n @noindent\n This manual contains useful information in writing programs using the\n GNAT compiler.  It includes information on implementation dependent\n characteristics of GNAT, including all the information required by Annex\n M of the standard.\n+@end ifclear\n+\n+@ifset PROEDITION\n+@noindent\n+This manual contains useful information in writing programs using the\n+GNAT Pro compiler.  It includes information on implementation dependent\n+characteristics of GNAT Pro, including all the information required by Annex\n+M of the standard.\n+@end ifset\n \n Ada 95 is designed to be highly portable.\n In general, a program will have the same effect even when compiled by\n@@ -408,6 +425,11 @@ may be non-portable.  You should follow good programming practice and\n isolate and clearly document any sections of your program that make use\n of these features in a non-portable manner.\n \n+@ifset PROEDITION\n+For ease of exposition, ``GNAT Pro'' will be referred to simply as\n+``GNAT'' in the remainder of this document.\n+@end ifset\n+\n @menu\n * What This Reference Manual Contains::\n * Conventions::\n@@ -481,6 +503,12 @@ other features.\n @ref{Project File Reference}, presents the syntax and semantics\n of project files.\n \n+@item\n+@ref{Obsolescent Features} documents implementation dependent features,\n+including pragmas and attributes, which are considered obsolescent, since\n+there are other preferred ways of achieving the same results. These\n+obsolescent forms are retained for backwards compatibilty.\n+\n @end itemize\n \n @cindex Ada 95 ISO/ANSI Standard\n@@ -643,10 +671,10 @@ consideration, the use of these pragmas should be minimized.\n * Pragma Passive::\n * Pragma Polling::\n * Pragma Profile (Ravenscar)::\n+* Pragma Profile (Restricted)::\n * Pragma Propagate_Exceptions::\n * Pragma Psect_Object::\n * Pragma Pure_Function::\n-* Pragma Restricted_Run_Time::\n * Pragma Restriction_Warnings::\n * Pragma Source_File_Name::\n * Pragma Source_File_Name_Project::\n@@ -2945,14 +2973,51 @@ AI-305) available at\n respectively.\n \n The above set is a superset of the restrictions provided by pragma\n-@code{Restricted_Run_Time}, it includes six additional restrictions\n+@code{Profile (Restricted)}, it includes six additional restrictions\n (@code{Simple_Barriers}, @code{No_Select_Statements},\n @code{No_Calendar}, @code{No_Implicit_Heap_Allocations},\n @code{No_Relative_Delay} and @code{No_Task_Termination}).  This means\n that pragma @code{Profile (Ravenscar)}, like the pragma\n-@code{Restricted_Run_Time}, automatically causes the use of a simplified,\n+@code{Profile (Restricted)},\n+automatically causes the use of a simplified,\n more efficient version of the tasking run-time system.\n \n+@node Pragma Profile (Restricted)\n+@unnumberedsec Pragma Profile (Restricted)\n+@findex Restricted Run Time\n+@noindent\n+Syntax:\n+\n+@smallexample @c ada\n+pragma Profile (Restricted);\n+@end smallexample\n+\n+@noindent\n+A configuration pragma that establishes the following set of restrictions:\n+\n+@itemize @bullet\n+@item No_Abort_Statements\n+@item No_Entry_Queue\n+@item No_Task_Hierarchy\n+@item No_Task_Allocators\n+@item No_Dynamic_Priorities\n+@item No_Terminate_Alternatives\n+@item No_Dynamic_Attachment\n+@item No_Protected_Type_Allocators\n+@item No_Local_Protected_Objects\n+@item No_Requeue_Statements\n+@item No_Task_Attributes_Package\n+@item Max_Asynchronous_Select_Nesting =  0\n+@item Max_Task_Entries =  0\n+@item Max_Protected_Entries = 1\n+@item Max_Select_Alternatives = 0\n+@end itemize\n+\n+@noindent\n+This set of restrictions causes the automatic selection of a simplified\n+version of the run time that provides improved performance for the\n+limited set of tasking functionality permitted by this set of restrictions.\n+\n @node Pragma Propagate_Exceptions\n @unnumberedsec Pragma Propagate_Exceptions\n @findex Propagate_Exceptions\n@@ -3063,42 +3128,6 @@ applies to the underlying renamed function.  This can be used to\n disambiguate cases of overloading where some but not all functions\n in a set of overloaded functions are to be designated as pure.\n \n-@node Pragma Restricted_Run_Time\n-@unnumberedsec Pragma Restricted_Run_Time\n-@findex Restricted_Run_Time\n-@noindent\n-Syntax:\n-\n-@smallexample @c ada\n-pragma Restricted_Run_Time;\n-@end smallexample\n-\n-@noindent\n-A configuration pragma that establishes the following set of restrictions:\n-\n-@itemize @bullet\n-@item No_Abort_Statements\n-@item No_Entry_Queue\n-@item No_Task_Hierarchy\n-@item No_Task_Allocators\n-@item No_Dynamic_Priorities\n-@item No_Terminate_Alternatives\n-@item No_Dynamic_Attachment\n-@item No_Protected_Type_Allocators\n-@item No_Local_Protected_Objects\n-@item No_Requeue_Statements\n-@item No_Task_Attributes_Package\n-@item Max_Asynchronous_Select_Nesting =  0\n-@item Max_Task_Entries =  0\n-@item Max_Protected_Entries = 1\n-@item Max_Select_Alternatives = 0\n-@end itemize\n-\n-@noindent\n-This set of restrictions causes the automatic selection of a simplified\n-version of the run time that provides improved performance for the\n-limited set of tasking functionality permitted by this set of restrictions.\n-\n @node Pragma Restriction_Warnings\n @unnumberedsec Pragma Restriction_Warnings\n @findex Restriction_Warnings\n@@ -6031,7 +6060,7 @@ restrictions to produce a more efficient implementation.\n GNAT currently takes advantage of these restrictions by providing an optimized\n run time when the Ravenscar profile and the GNAT restricted run time set\n of restrictions are specified.  See pragma @code{Profile (Ravenscar)} and\n-pragma @code{Restricted_Run_Time} for more details.\n+pragma @code{Profile (Restricted)} for more details.\n \n @cindex Time, monotonic\n @unnumberedsec D.8(47-49): Monotonic Time\n@@ -6975,7 +7004,10 @@ of exceptions when they are declared.\n This restriction ensures that the generated code does not contain any\n implicit conditionals, either by modifying the generated code where possible,\n or by rejecting any construct that would otherwise generate an implicit\n-conditional.\n+conditional. Note that this check does not include run time constraint\n+checks, which on some targets may generate implicit conditionals as\n+well. To control the latter, constraint checks can be suppressed in the\n+normal manner.\n \n @item No_Implicit_Dynamic_Code\n @findex No_Implicit_Dynamic_Code\n@@ -14196,6 +14228,47 @@ sequential elaboration of all its declarations. The computed values of\n attributes and variables in the project are then used to establish the\n environment in which the gnat tool will execute.\n \n+@node Obsolescent Features\n+@chapter Obsolescent Features\n+\n+@noindent\n+This chapter describes features that are provided by GNAT, but are\n+considered obsolescent since there are preferred ways of achieving\n+the same effect. These features are provided solely for historical\n+compatibility purposes.\n+\n+@menu\n+* pragma No_Run_Time::\n+* pragma Ravenscar::\n+* pragma Restricted_Run_Time::\n+@end menu\n+\n+@node pragma No_Run_Time\n+@section pragma No_Run_Time\n+\n+The pragma @code{No_Run_Time} is used to achieve an affect similar\n+to the use of the \"Zero Foot Print\" configurable run time, but without\n+requiring a specially configured run time. The result of using this\n+pragma, which must be used for all units in a partition, is to restrict\n+the use of any language features requiring run-time support code. The\n+preferred usage is to use an appropriately configured run-time that\n+includes just those features that are to be made accessible.\n+\n+@node pragma Ravenscar\n+@section pragma Ravenscar\n+\n+The pragma @code{Ravenscar} has exactly the same effect as pragma\n+@code{Profile (Ravenscar)}. The latter usage is preferred since it\n+is part of the new Ada 2005 standard.\n+\n+@node pragma Restricted_Run_Time\n+@section pragma Restricted_Run_Time\n+\n+The pragma @code{Restricted_Run_Time} has exactly the same effect as\n+pragma @code{Profile (Restricted)}. The latter usage is\n+preferred since the Ada 2005 pragma @code{Profile} is intended for\n+this kind of implementation dependent addition.\n+\n @include fdl.texi\n @c GNU Free Documentation License\n "}, {"sha": "640f74d3399ea0e3539e4aca646b6e39b9e2f9b3", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 128, "deletions": 49, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=5d09245e6a54b290b5f44b686214b41cf555152a", "patch": "@@ -85,20 +85,26 @@\n @setfilename gnat_ugn_unw.info\n @end ifset\n \n+@set FSFEDITION\n+@set EDITION GNAT\n+\n+@ifset unw\n+@set PLATFORM Unix and Windows\n+@set FILE gnat_ugn_unw\n+@end ifset\n+\n @ifset vms\n-@settitle GNAT User's Guide for Native Platforms / OpenVMS Alpha\n-@dircategory GNU Ada tools\n-@direntry\n-* GNAT User's Guide (gnat_ugn_vms) for Native Platforms / OpenVMS Alpha\n-@end direntry\n+@set PLATFORM OpenVMS Alpha\n+@set FILE gnat_ugn_vms\n @end ifset\n \n-@ifset unw\n-@settitle GNAT User's Guide for Native Platforms / Unix and Windows\n+\n+\n+@settitle @value{EDITION} User's Guide for Native Platforms / @value{PLATFORM}\n+@dircategory GNU Ada tools\n @direntry\n-* GNAT User's Guide (gnat_ugn_unw) for Native Platforms / Unix and Windows\n+* @value{EDITION} User's Guide (@value{FILE}) for Native Platforms / @value{PLATFORM}\n @end direntry\n-@end ifset\n \n @include gcc-common.texi\n \n@@ -114,30 +120,20 @@ under the terms of the GNU Free Documentation License, Version 1.2\n or any later version published by the Free Software Foundation;\n with the Invariant Sections being ``GNU Free Documentation License'', with the\n Front-Cover Texts being\n-@ifset vms\n-``GNAT User's Guide for Native Platforms / OpenVMS Alpha'',\n-@end ifset\n-@ifset unw\n-``GNAT User's Guide for Native Platforms / Unix and Windows'',\n-@end ifset\n+``GNAT User's Guide for Native Platforms / @value{PLATFORM}'',\n and with no Back-Cover Texts.\n A copy of the license is included in the section entitled\n ``GNU Free Documentation License''.\n @end copying\n \n @titlepage\n \n-@title GNAT User's Guide\n+@title @value{EDITION} User's Guide\n @center @titlefont{for Native Platforms}\n @sp 1\n \n @flushright\n-@ifset unw\n-@titlefont{@i{Unix and Windows}}\n-@end ifset\n-@ifset vms\n-@titlefont{@i{OpenVMS Alpha}}\n-@end ifset\n+@titlefont{@i{@value{PLATFORM}}}\n @end flushright\n @sp 2\n \n@@ -156,17 +152,10 @@ A copy of the license is included in the section entitled\n \n @ifnottex\n @node Top, About This Guide, (dir), (dir)\n-@top GNAT User's Guide\n-\n-@ifset vms\n-@noindent\n-GNAT User's Guide for Native Platforms / OpenVMS Alpha\n-@end ifset\n+@top @value{EDITION} User's Guide\n \n-@ifset unw\n @noindent\n-GNAT User's Guide for Native Platforms / Unix and Windows\n-@end ifset\n+@value{EDITION} User's Guide for Native Platforms / @value{PLATFORM}\n \n @noindent\n GNAT, The GNU Ada 95 Compiler@*\n@@ -643,16 +632,25 @@ Microsoft Windows Topics\n \n @noindent\n @ifset vms\n-This guide describes the use of of GNAT, a full language compiler for the Ada\n+This guide describes the use of of @value{EDITION},\n+a full language compiler for the Ada\n 95 programming language, implemented on HP OpenVMS Alpha platforms.\n @end ifset\n @ifclear vms\n-This guide describes the use of GNAT, a compiler and software development\n+This guide describes the use of @value{EDITION},\n+a compiler and software development\n toolset for the full Ada 95 programming language.\n @end ifclear\n It describes the features of the compiler and tools, and details\n how to use them to build Ada 95 applications.\n \n+@ifset PROEDITION\n+For ease of exposition, ``GNAT Pro'' will be referred to simply as\n+``GNAT'' in the remainder of this document.\n+@end ifset\n+\n+\n+\n @menu\n * What This Guide Contains::\n * What You Should Know before Reading This Guide::\n@@ -26123,6 +26121,8 @@ platforms (NT, 2000, and XP Professional).\n * Introduction to Dynamic Link Libraries (DLLs)::\n * Using DLLs with GNAT::\n * Building DLLs with GNAT::\n+* Building DLLs with GNAT Project files::\n+* Building DLLs with gnatdll::\n * GNAT and Windows Resources::\n * Debugging a DLL::\n * GNAT and COM/DCOM Objects::\n@@ -26503,13 +26503,14 @@ slower since, as you will understand below, such calls are indirect.\n \n To illustrate the remainder of this section, suppose that an application\n wants to use the services of a DLL @file{API.dll}. To use the services\n-provided by @file{API.dll} you must statically link against an import\n-library which contains a jump table with an entry for each routine and\n-variable exported by the DLL. In the Microsoft world this import library is\n-called @file{API.lib}. When using GNAT this import library is called either\n-@file{libAPI.a} or @file{libapi.a} (names are case insensitive).\n-\n-After you have statically linked your application with the import library\n+provided by @file{API.dll} you must statically link against the DLL or\n+an import library which contains a jump table with an entry for each\n+routine and variable exported by the DLL. In the Microsoft world this\n+import library is called @file{API.lib}. When using GNAT this import\n+library is called either @file{libAPI.a} or @file{libapi.a} (names are\n+case insensitive).\n+\n+After you have linked your application with the DLL or the import library\n and you run your application, here is what happens:\n \n @enumerate\n@@ -26537,9 +26538,10 @@ routines and routines in the application using the DLL.\n @end itemize\n \n @item\n-The entries in the @file{libAPI.a} or @file{API.lib} jump table which is\n-part of your application are initialized with the addresses of the routines\n-and variables in @file{API.dll}.\n+The entries in the jump table (from the import library @file{libAPI.a}\n+or @file{API.lib} or automatically created when linking against a DLL)\n+which is part of your application are initialized with the addresses\n+of the routines and variables in @file{API.dll}.\n \n @item\n If present in @file{API.dll}, routines @code{DllMain} or\n@@ -26564,8 +26566,8 @@ still be relocated.\n As a side note, an interesting difference between Microsoft DLLs and\n Unix shared libraries, is the fact that on most Unix systems all public\n routines are exported by default in a Unix shared library, while under\n-Windows the exported routines must be listed explicitly in a definition\n-file (@pxref{The Definition File}).\n+Windows it is possible (but not required) to list exported routines in\n+a definition file (@pxref{The Definition File}).\n \n @node Using DLLs with GNAT\n @section Using DLLs with GNAT\n@@ -26590,7 +26592,8 @@ The import library (@file{libAPI.a} or @file{API.lib}). As previously\n mentioned an import library is a statically linked library containing the\n import table which will be filled at load time to point to the actual\n @file{API.dll} routines. Sometimes you don't have an import library for the\n-DLL you want to use. The following sections will explain how to build one.\n+DLL you want to use. The following sections will explain how to build\n+one. Note that this is optional.\n \n @item\n The actual DLL, @file{API.dll}.\n@@ -26685,7 +26688,9 @@ subprograms, the @code{DLL} convention is a synonym of @code{Stdcall}\n @noindent\n If a Microsoft-style import library @file{API.lib} or a GNAT-style\n import library @file{libAPI.a} is available with @file{API.dll} you\n-can skip this section. Otherwise read on.\n+can skip this section. You can also skip this section if\n+@file{API.dll} is built with GNU tools as in this case it is possible\n+to link directly against the DLL. Otherwise read on.\n \n @node The Definition File\n @subsubsection The Definition File\n@@ -26850,6 +26855,75 @@ See the Microsoft documentation for further details about the usage of\n @section Building DLLs with GNAT\n @cindex DLLs, building\n \n+@noindent\n+This section explain how to build DLLs using the GNAT built-in DLL\n+support. With the following procedure it is straight forward to build\n+and use DLLs with GNAT.\n+\n+@enumerate\n+\n+@item building object files\n+\n+The first step is to build all objects files that are to be included\n+into the DLL. This is done by using the standard @code{gnatmake} tool.\n+\n+@item building the DLL\n+\n+To build the DLL you must use @code{gcc}'s @code{-shared}\n+option. It is quite simple to use this method:\n+\n+@smallexample\n+$ gcc -shared -o api.dll obj1.o obj2.o ...\n+@end smallexample\n+\n+It is important to note that in this case all symbols found in the\n+object files are automatically exported. It is possible to restrict\n+the set of symbols to export by passing to @code{gcc} a definition\n+file, @pxref{The Definition File}. For example:\n+\n+@smallexample\n+$ gcc -shared -o api.dll api.def obj1.o obj2.o ...\n+@end smallexample\n+\n+If you use a definition file you must export the elaboration procedures\n+for every package that required one. Elaboration procedures are named\n+using the package name followed by \"_E\".\n+\n+@item preparing DLL to be used\n+\n+For the DLL to be used by client programs the bodies must be hidden\n+from it and the .ali set with read-only attribute. This is very important\n+otherwise GNAT will recompile all packages and will not actually use\n+the code in the DLL. For example:\n+\n+@smallexample\n+$ mkdir apilib\n+$ copy *.ads *.ali api.dll apilib\n+$ attrib +R apilib\\*.ali\n+@end smallexample\n+\n+@end enumerate\n+\n+At this point it is possible to use the DLL by directly linking\n+against it. Note that you must use the GNAT shared runtime when using\n+GNAT shared libraries. This is achieved by using @code{-shared} binder's\n+option.\n+\n+@smallexample\n+$ gnatmake main -Iapilib -bargs -shared -largs -Lapilib -lAPI\n+@end smallexample\n+\n+@node Building DLLs with GNAT Project files\n+@section Building DLLs with GNAT Project files\n+@cindex DLLs, building\n+\n+@noindent\n+There is nothing specific to Windows in this area. @pxref{Library Projects}.\n+\n+@node Building DLLs with gnatdll\n+@section Building DLLs with gnatdll\n+@cindex DLLs, building\n+\n @menu\n * Limitations When Using Ada DLLs from Ada::\n * Exporting Ada Entities::\n@@ -26861,8 +26935,13 @@ See the Microsoft documentation for further details about the usage of\n @end menu\n \n @noindent\n-This section explains how to build DLLs containing Ada code. These DLLs\n-will be referred to as Ada DLLs in the remainder of this section.\n+Note that it is prefered to use the built-in GNAT DLL support\n+(@pxref{Building DLLs with GNAT}) or GNAT Project files\n+(@pxref{Building DLLs with GNAT Project files}) to build DLLs.\n+\n+This section explains how to build DLLs containing Ada code using\n+@code{gnatdll}. These DLLs will be referred to as Ada DLLs in the\n+remainder of this section.\n \n The steps required to build an Ada DLL that is to be used by Ada as well as\n non-Ada applications are as follows:"}, {"sha": "5d30a57c709d483da1d639a8698b3c358a916474", "filename": "gcc/ada/gnatlink.adb", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fgnatlink.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fgnatlink.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatlink.adb?ref=5d09245e6a54b290b5f44b686214b41cf555152a", "patch": "@@ -29,6 +29,7 @@\n with ALI;      use ALI;\n with Gnatvsn;  use Gnatvsn;\n with Hostparm;\n+with Indepsw;  use Indepsw;\n with Namet;    use Namet;\n with Opt;\n with Osint;    use Osint;\n@@ -157,6 +158,10 @@ procedure Gnatlink is\n    Compile_Bind_File : Boolean := True;\n    --  Set to False if bind file is not to be compiled\n \n+   Create_Map_File : Boolean := False;\n+   --  Set to True by switch -M. The map file name is derived from\n+   --  the ALI file name (mainprog.ali => mainprog.map).\n+\n    Object_List_File_Supported : Boolean;\n    pragma Import\n      (C, Object_List_File_Supported, \"__gnat_objlist_file_supported\");\n@@ -327,6 +332,21 @@ procedure Gnatlink is\n                   Binder_Options.Table (Binder_Options.Last) :=\n                     Linker_Options.Table (Linker_Options.Last);\n \n+               elsif Arg'Length >= 3 and then Arg (2) = 'M' then\n+                  declare\n+                     Switches : String_List_Access;\n+                  begin\n+                     Convert (Map_File, Arg (3 .. Arg'Last), Switches);\n+\n+                     if Switches /= null then\n+                        for J in Switches'Range loop\n+                           Linker_Options.Increment_Last;\n+                           Linker_Options.Table (Linker_Options.Last) :=\n+                             Switches (J);\n+                        end loop;\n+                     end if;\n+                  end;\n+\n                elsif Arg'Length = 2 then\n                   case Arg (2) is\n                      when 'A' =>\n@@ -377,6 +397,9 @@ procedure Gnatlink is\n                              (\"Object list file not supported on this target\");\n                         end if;\n \n+                     when 'M' =>\n+                        Create_Map_File := True;\n+\n                      when 'n' =>\n                         Compile_Bind_File := False;\n \n@@ -1287,6 +1310,12 @@ procedure Gnatlink is\n       Write_Line (\"  -o nam     Use 'nam' as the name of the executable\");\n       Write_Line (\"  -b target  Compile the binder source to run on target\");\n       Write_Line (\"  -Bdir      Load compiler executables from dir\");\n+\n+      if Is_Supported (Map_File) then\n+         Write_Line (\"  -Mmap      Create map file map\");\n+         Write_Line (\"  -M         Create map file mainprog.map\");\n+      end if;\n+\n       Write_Line (\"  --GCC=comp Use comp as the compiler\");\n       Write_Line (\"  --LINK=nam Use 'nam' for the linking rather than 'gcc'\");\n       Write_Eol;\n@@ -1492,6 +1521,25 @@ begin\n                    & \"\"\" may conflict with shell command\");\n    end if;\n \n+   --  If -M switch was specified, add the switches to create the map file\n+\n+   if Create_Map_File then\n+      declare\n+         Map_Name : constant String := Base_Name (Ali_File_Name.all) & \".map\";\n+         Switches : String_List_Access;\n+\n+      begin\n+         Convert (Map_File, Map_Name, Switches);\n+\n+         if Switches /= null then\n+            for J in Switches'Range loop\n+               Linker_Options.Increment_Last;\n+               Linker_Options.Table (Linker_Options.Last) := Switches (J);\n+            end loop;\n+         end if;\n+      end;\n+   end if;\n+\n    --  Perform consistency checks\n \n    --  Transform the .ali file name into the binder output file name"}, {"sha": "bdff9712e9191241c34215e76b256408f88d67e1", "filename": "gcc/ada/indepsw-aix.adb", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Findepsw-aix.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Findepsw-aix.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Findepsw-aix.adb?ref=5d09245e6a54b290b5f44b686214b41cf555152a", "patch": "@@ -0,0 +1,69 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              I N D E P S W                               --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                              (AIX version)                               --\n+--                                                                          --\n+--            Copyright (C) 2004 Free Software Foundation, Inc.             --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is the AIX version\n+\n+package body Indepsw is\n+\n+   Map_Switch : aliased constant String := \"-Wl,-b,map:\";\n+\n+   -------------\n+   -- Convert --\n+   -------------\n+\n+   procedure Convert\n+     (Switch   : Switch_Kind;\n+      Argument : String;\n+      To       : out String_List_Access)\n+   is\n+   begin\n+      case Switch is\n+         when Map_File =>\n+            To := new Argument_List'(1 => new String'(Map_Switch & Argument));\n+      end case;\n+   end Convert;\n+\n+   ------------------\n+   -- Is_Supported --\n+   ------------------\n+\n+   function Is_Supported (Switch : Switch_Kind) return Boolean is\n+   begin\n+      case Switch is\n+         when Map_File =>\n+            return True;\n+      end case;\n+   end Is_Supported;\n+\n+end Indepsw;"}, {"sha": "74538a8c6935ac92a94498f23127748f08c1ed17", "filename": "gcc/ada/indepsw-linux.adb", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Findepsw-linux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Findepsw-linux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Findepsw-linux.adb?ref=5d09245e6a54b290b5f44b686214b41cf555152a", "patch": "@@ -0,0 +1,69 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              I N D E P S W                               --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                            (GNU/Linux version)                           --\n+--                                                                          --\n+--            Copyright (C) 2004 Free Software Foundation, Inc.             --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is the GNU/Linux version\n+\n+package body Indepsw is\n+\n+   Map_Switch : aliased constant String := \"-Wl,-Map,\";\n+\n+   -------------\n+   -- Convert --\n+   -------------\n+\n+   procedure Convert\n+     (Switch   : Switch_Kind;\n+      Argument : String;\n+      To       : out String_List_Access)\n+   is\n+   begin\n+      case Switch is\n+         when Map_File =>\n+            To := new Argument_List'(1 => new String'(Map_Switch & Argument));\n+      end case;\n+   end Convert;\n+\n+   ------------------\n+   -- Is_Supported --\n+   ------------------\n+\n+   function Is_Supported (Switch : Switch_Kind) return Boolean is\n+   begin\n+      case Switch is\n+         when Map_File =>\n+            return True;\n+      end case;\n+   end Is_Supported;\n+\n+end Indepsw;"}, {"sha": "bf591514e88cff620ee2396adbfec7c2c36f9bb5", "filename": "gcc/ada/indepsw-mingw.adb", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Findepsw-mingw.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Findepsw-mingw.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Findepsw-mingw.adb?ref=5d09245e6a54b290b5f44b686214b41cf555152a", "patch": "@@ -0,0 +1,69 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              I N D E P S W                               --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                            (Windows version)                             --\n+--                                                                          --\n+--            Copyright (C) 2004 Free Software Foundation, Inc.             --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is the Windows version\n+\n+package body Indepsw is\n+\n+   Map_Switch : aliased constant String := \"-Wl,-Map,\";\n+\n+   -------------\n+   -- Convert --\n+   -------------\n+\n+   procedure Convert\n+     (Switch   : Switch_Kind;\n+      Argument : String;\n+      To       : out String_List_Access)\n+   is\n+   begin\n+      case Switch is\n+         when Map_File =>\n+            To := new Argument_List'(1 => new String'(Map_Switch & Argument));\n+      end case;\n+   end Convert;\n+\n+   ------------------\n+   -- Is_Supported --\n+   ------------------\n+\n+   function Is_Supported (Switch : Switch_Kind) return Boolean is\n+   begin\n+      case Switch is\n+         when Map_File =>\n+            return True;\n+      end case;\n+   end Is_Supported;\n+\n+end Indepsw;"}, {"sha": "ce86d2cda1a25dad143548bbfa9ea3862127b469", "filename": "gcc/ada/indepsw.adb", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Findepsw.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Findepsw.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Findepsw.adb?ref=5d09245e6a54b290b5f44b686214b41cf555152a", "patch": "@@ -0,0 +1,69 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              I N D E P S W                               --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--              Copyright (C) 2004 Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is the default version: no switches are supported\n+\n+with Output; use Output;\n+\n+package body Indepsw is\n+\n+   -------------\n+   -- Convert --\n+   -------------\n+\n+   procedure Convert\n+     (Switch   : Switch_Kind;\n+      Argument : String;\n+      To       : out String_List_Access)\n+   is\n+      pragma Unreferenced (Argument);\n+   begin\n+      case Switch is\n+         when others =>\n+            Write_Str (\"warning: \");\n+            Write_Line (No_Support_For (Switch).all);\n+            To := null;\n+      end case;\n+   end Convert;\n+\n+   ------------------\n+   -- Is_Supported --\n+   ------------------\n+\n+   function Is_Supported (Switch : Switch_Kind) return Boolean is\n+      pragma Unreferenced (Switch);\n+   begin\n+      return False;\n+   end Is_Supported;\n+\n+end Indepsw;"}, {"sha": "e206515b88d421e2d2612037bc602d7dfdab4204", "filename": "gcc/ada/indepsw.ads", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Findepsw.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Findepsw.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Findepsw.ads?ref=5d09245e6a54b290b5f44b686214b41cf555152a", "patch": "@@ -0,0 +1,84 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              I N D E P S W                               --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2004 Free Software Foundation, Inc.             --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  GNATLINK platform-independent switches\n+\n+--  Used to convert GNAT switches to their platform-dependent switch\n+--  equivalent for the underlying linker.\n+\n+with GNAT.OS_Lib; use GNAT.OS_Lib;\n+\n+package Indepsw is\n+\n+   type Switch_Kind is\n+   --  Independent switches currently supported\n+\n+     (Map_File);\n+      --  Produce a map file. The path name of the map file to produce\n+      --  is given as an argument.\n+\n+   procedure Convert\n+     (Switch   : Switch_Kind;\n+      Argument : String;\n+      To       : out String_List_Access);\n+   --  Convert Switch to the platform-dependent linker switch (with or without\n+   --  additional arguments) To. Issue a warning if Switch is not supported\n+   --  for the platform; in this case, To is set to null.\n+\n+   function Is_Supported (Switch : Switch_Kind) return Boolean;\n+   --  Return True for each independent switch supported by the platform.\n+\n+private\n+   --  Default warning messages when the switches are not supported by the\n+   --  implementation. These are in the spec so that the platform specific\n+   --  bodies do not need to redefine them.\n+\n+   Map_File_Not_Supported : aliased String :=\n+     \"the underlying linker does not allow the output of a map file\";\n+\n+   No_Support_For : constant array (Switch_Kind) of String_Access :=\n+                      (Map_File => Map_File_Not_Supported'Access);\n+   --  All implementations of procedure Convert should include a case\n+   --  statements with a \"when others =>\" choice that output the default\n+   --  warning message:\n+\n+   --   case Switch is\n+   --      when ... =>\n+   --         ...\n+   --      when others =>\n+   --         Write_Str (\"warning: \");\n+   --         Write_Line (No_Support_For (Switch).all);\n+   --         To := null;\n+   --   end case;\n+\n+end Indepsw;"}, {"sha": "6b51b3286395d939e80cd7982c456fb9dd0f0eeb", "filename": "gcc/ada/makegpr.adb", "status": "modified", "additions": 67, "deletions": 47, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fmakegpr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fmakegpr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmakegpr.adb?ref=5d09245e6a54b290b5f44b686214b41cf555152a", "patch": "@@ -1337,6 +1337,7 @@ package body Makegpr is\n \n       Object_Name : Name_Id;\n       Time_Stamp  : Time_Stamp_Type;\n+      Driver_Name : Name_Id := No_Name;\n \n    begin\n       Check_Archive_Builder;\n@@ -1527,61 +1528,76 @@ package body Makegpr is\n \n          Last_Argument := 0;\n \n-            --  If there are sources in Ada, then gnatmake will build the\n-            --  library, so nothing to do.\n+         --  If there are sources in Ada, then gnatmake will build the\n+         --  library, so nothing to do.\n \n-            if not Data.Languages (Lang_Ada) then\n+         if not Data.Languages (Lang_Ada) then\n \n-               --  Get all the object files of the project\n+            --  Get all the object files of the project\n \n-               Source_Id := Data.First_Other_Source;\n+            Source_Id := Data.First_Other_Source;\n \n-               while Source_Id /= No_Other_Source loop\n-                  Source := Other_Sources.Table (Source_Id);\n-                  Add_Argument\n-                    (Get_Name_String (Source.Object_Name), Verbose_Mode);\n-                  Source_Id := Source.Next;\n-               end loop;\n+            while Source_Id /= No_Other_Source loop\n+               Source := Other_Sources.Table (Source_Id);\n+               Add_Argument\n+                 (Get_Name_String (Source.Object_Name), Verbose_Mode);\n+               Source_Id := Source.Next;\n+            end loop;\n \n-               --  If it is a library, it need to be built it the same way\n-               --  Ada libraries are built.\n+            --  If it is a library, it need to be built it the same way\n+            --  Ada libraries are built.\n \n-               if Data.Library_Kind = Static then\n-                  MLib.Build_Library\n-                    (Ofiles => Arguments (1 .. Last_Argument),\n-                     Afiles => No_Argument,\n-                     Output_File => Get_Name_String (Data.Library_Name),\n-                     Output_Dir  => Get_Name_String (Data.Library_Dir));\n+            if Data.Library_Kind = Static then\n+               MLib.Build_Library\n+                 (Ofiles      => Arguments (1 .. Last_Argument),\n+                  Afiles      => No_Argument,\n+                  Output_File => Get_Name_String (Data.Library_Name),\n+                  Output_Dir  => Get_Name_String (Data.Library_Dir));\n \n-               else\n-                  MLib.Tgt.Build_Dynamic_Library\n-                    (Ofiles       => Arguments (1 .. Last_Argument),\n-                     Foreign      => Arguments (1 .. Last_Argument),\n-                     Afiles       => No_Argument,\n-                     Options      => No_Argument,\n-                     Interfaces   => No_Argument,\n-                     Lib_Filename => Get_Name_String (Data.Library_Name),\n-                     Lib_Dir      => Get_Name_String (Data.Library_Dir),\n-                     Symbol_Data  => No_Symbols,\n-                     Driver_Name  => No_Name,\n-                     Lib_Version  => \"\",\n-                     Auto_Init    => False);\n+            else\n+               --  Link with g++ if C++ is one of the languages, otherwise\n+               --  building the library may fail with unresolved symbols.\n+\n+               if C_Plus_Plus_Is_Used then\n+                  if Compiler_Names (Lang_C_Plus_Plus) = null then\n+                     Get_Compiler (Lang_C_Plus_Plus);\n+                  end if;\n+\n+                  if Compiler_Is_Gcc (Lang_C_Plus_Plus) then\n+                     Name_Len := 0;\n+                     Add_Str_To_Name_Buffer\n+                       (Compiler_Names (Lang_C_Plus_Plus).all);\n+                     Driver_Name := Name_Find;\n+                  end if;\n                end if;\n-            end if;\n \n-            --  Create fake empty archive, so we can check its time stamp later\n+               MLib.Tgt.Build_Dynamic_Library\n+                 (Ofiles       => Arguments (1 .. Last_Argument),\n+                  Foreign      => Arguments (1 .. Last_Argument),\n+                  Afiles       => No_Argument,\n+                  Options      => No_Argument,\n+                  Interfaces   => No_Argument,\n+                  Lib_Filename => Get_Name_String (Data.Library_Name),\n+                  Lib_Dir      => Get_Name_String (Data.Library_Dir),\n+                  Symbol_Data  => No_Symbols,\n+                  Driver_Name  => Driver_Name,\n+                  Lib_Version  => \"\",\n+                  Auto_Init    => False);\n+            end if;\n+         end if;\n \n-            declare\n-               Archive : Ada.Text_IO.File_Type;\n-               use Ada.Text_IO;\n-            begin\n-               Create (Archive, Out_File, Archive_Name);\n-               Close (Archive);\n-            end;\n+         --  Create fake empty archive, so we can check its time stamp later\n \n-            Create_Archive_Dependency_File\n-              (Archive_Dep_Name, Data.First_Other_Source);\n+         declare\n+            Archive : Ada.Text_IO.File_Type;\n+            use Ada.Text_IO;\n+         begin\n+            Create (Archive, Out_File, Archive_Name);\n+            Close (Archive);\n+         end;\n \n+         Create_Archive_Dependency_File\n+           (Archive_Dep_Name, Data.First_Other_Source);\n       end if;\n    end Build_Library;\n \n@@ -2539,12 +2555,13 @@ package body Makegpr is\n                Need_To_Rebuild_Global_Archive := True;\n             end if;\n \n-            --  If there was no compilation error, build/rebuild the archive\n-            --  if necessary.\n+            --  If there was no compilation error and -c was not used,\n+            --  build / rebuild the archive if necessary.\n \n             if not Local_Errors\n               and then Data.Library\n               and then not Data.Languages (Lang_Ada)\n+              and then not Compile_Only\n             then\n                Build_Library (Project, Need_To_Rebuild_Archive);\n             end if;\n@@ -2985,7 +3002,11 @@ package body Makegpr is\n          end if;\n \n       else\n-         --  First compile sources and build archives for library project,\n+         --  First check for C++, to link libraries with g++, rather than gcc\n+\n+         Check_For_C_Plus_Plus;\n+\n+         --  Compile sources and build archives for library project,\n          --  if necessary.\n \n          Compile_Sources;\n@@ -3000,7 +3021,6 @@ package body Makegpr is\n \n          if not Compile_Only then\n             Build_Global_Archive;\n-            Check_For_C_Plus_Plus;\n             Link_Executables;\n          end if;\n "}, {"sha": "1efebfd5638c78b769c7d95d9905df4f5279fe69", "filename": "gcc/ada/mlib-tgt-mingw.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fmlib-tgt-mingw.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fmlib-tgt-mingw.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-tgt-mingw.adb?ref=5d09245e6a54b290b5f44b686214b41cf555152a", "patch": "@@ -121,7 +121,8 @@ package body MLib.Tgt is\n       Tools.Gcc\n         (Output_File => Lib_File,\n          Objects     => Ofiles,\n-         Options     => Options,\n+         Options     => Tools.No_Argument_List,\n+         Options_2   => Options,\n          Driver_Name => Driver_Name);\n    end Build_Dynamic_Library;\n "}, {"sha": "53e0853164433bd85fbe42fc8159149f84f86805", "filename": "gcc/ada/prj-nmsc.adb", "status": "modified", "additions": 41, "deletions": 43, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fprj-nmsc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fprj-nmsc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.adb?ref=5d09245e6a54b290b5f44b686214b41cf555152a", "patch": "@@ -2526,11 +2526,12 @@ package body Prj.Nmsc is\n       end if;\n \n       if For_Language = Lang_Ada then\n-         --  If we have looked for sources and found none, then\n-         --  it is an error, except if it is an extending project.\n-         --  If a non extending project is not supposed to contain\n-         --  any source, then we never call Find_Sources.\n-         --  No error either when setting up projects (gnat setup).\n+\n+         --  If we have looked for sources and found none, then it is an\n+         --  error, except if it is an extending project. If a non-extending\n+         --  project is not supposed to contain any source, then we never\n+         --  Find_Sources. No error is signalled when setting up projects\n+         --  using gnat setup.\n \n          if Current_Source /= Nil_String then\n             Data.Ada_Sources_Present := True;\n@@ -3305,9 +3306,8 @@ package body Prj.Nmsc is\n                   Object_Dir.Location);\n \n             else\n-               --  We check that the specified object directory\n-               --  does exist, and attempt to create it if setting up projects\n-               --  (gnat setup).\n+               --  Check that the specified object directory does exist, and\n+               --  attempt to create it if setting up projects (gnat setup).\n \n                Locate_Directory\n                  (Object_Dir.Value, Data.Display_Directory,\n@@ -3319,17 +3319,17 @@ package body Prj.Nmsc is\n                  and then Data.Object_Directory = No_Name\n                then\n                   --  The object directory does not exist, report an error\n+\n                   Err_Vars.Error_Msg_Name_1 := Object_Dir.Value;\n                   Error_Msg\n                     (Project,\n                      \"the object directory { cannot be found\",\n                      Data.Location);\n \n                   --  Do not keep a nil Object_Directory. Set it to the\n-                  --  specified (relative or absolute) path.\n-                  --  This is for the benefit of tools that recover from\n-                  --  errors; for example, these tools could create the\n-                  --  non existent directory.\n+                  --  specified (relative or absolute) path. This is for the\n+                  --  benefit of tools that recover from errors. For example,\n+                  --  these tools could create the non-existent directory.\n \n                   Data.Display_Object_Dir := Object_Dir.Value;\n                   Get_Name_String (Object_Dir.Value);\n@@ -3447,10 +3447,10 @@ package body Prj.Nmsc is\n \n          elsif Source_Dirs.Values = Nil_String then\n \n-            --  If Source_Dirs is an empty string list, this means\n-            --  that this project contains no source. For projects that\n-            --  don't extend other projects, this also means that there is no\n-            --  need for an object directory, if not specified.\n+            --  If Source_Dirs is an empty string list, this means that this\n+            --  contains no sources. For projects that do not extend other\n+            --  projects, this also means that there is no need for an object\n+            --  directory unless one is specified explicitly.\n \n             if Data.Extends = No_Project\n               and then  Data.Object_Directory = Data.Directory\n@@ -3531,8 +3531,8 @@ package body Prj.Nmsc is\n \n             begin\n                --  If the project extended is a library project, we inherit\n-               --  the library name, if it is not redefined; we check that\n-               --  the library directory is specified; and we reset the\n+               --  the library name, if it is not redefined, we check that\n+               --  the library directory is specified, and we reset the\n                --  library flag for the extended project.\n \n                if Extended_Data.Library then\n@@ -3773,36 +3773,35 @@ package body Prj.Nmsc is\n             --  Check Spec_Suffix\n \n             declare\n-               Spec_Suffixs : Array_Element_Id :=\n-                                Util.Value_Of\n-                                  (Name_Spec_Suffix,\n-                                   Naming.Decl.Arrays);\n+               Spec_Suffixes : Array_Element_Id :=\n+                                 Util.Value_Of\n+                                   (Name_Spec_Suffix,\n+                                    Naming.Decl.Arrays);\n                Suffix  : Array_Element_Id;\n                Element : Array_Element;\n                Suffix2 : Array_Element_Id;\n \n             begin\n-               --  If some suffixs have been specified, we make sure that\n+               --  If some suffixes have been specified, we make sure that\n                --  for each language for which a default suffix has been\n                --  specified, there is a suffix specified, either the one\n                --  in the project file or if there were none, the default.\n \n-               if Spec_Suffixs /= No_Array_Element then\n+               if Spec_Suffixes /= No_Array_Element then\n                   Suffix := Data.Naming.Spec_Suffix;\n \n                   while Suffix /= No_Array_Element loop\n                      Element := Array_Elements.Table (Suffix);\n-                     Suffix2 := Spec_Suffixs;\n+                     Suffix2 := Spec_Suffixes;\n \n                      while Suffix2 /= No_Array_Element loop\n                         exit when Array_Elements.Table (Suffix2).Index =\n                           Element.Index;\n                         Suffix2 := Array_Elements.Table (Suffix2).Next;\n                      end loop;\n \n-                     --  There is a registered default suffix, but no\n-                     --  suffix specified in the project file.\n-                     --  Add the default to the array.\n+                     --  There is a registered default suffix, but no suffix is\n+                     --  specified in the project file. Add default to array.\n \n                      if Suffix2 = No_Array_Element then\n                         Array_Elements.Increment_Last;\n@@ -3811,16 +3810,16 @@ package body Prj.Nmsc is\n                            Src_Index => Element.Src_Index,\n                            Index_Case_Sensitive => False,\n                            Value     => Element.Value,\n-                           Next      => Spec_Suffixs);\n-                        Spec_Suffixs := Array_Elements.Last;\n+                           Next      => Spec_Suffixes);\n+                        Spec_Suffixes := Array_Elements.Last;\n                      end if;\n \n                      Suffix := Element.Next;\n                   end loop;\n \n-                  --  Put the resulting array as the specification suffixs\n+                  --  Put the resulting array as the specification suffixes\n \n-                  Data.Naming.Spec_Suffix := Spec_Suffixs;\n+                  Data.Naming.Spec_Suffix := Spec_Suffixes;\n                end if;\n             end;\n \n@@ -3848,27 +3847,26 @@ package body Prj.Nmsc is\n             --  Check Body_Suffix\n \n             declare\n-               Impl_Suffixs : Array_Element_Id :=\n-                                Util.Value_Of\n-                                  (Name_Body_Suffix,\n-                                   Naming.Decl.Arrays);\n+               Impl_Suffixes : Array_Element_Id :=\n+                                 Util.Value_Of\n+                                   (Name_Body_Suffix, Naming.Decl.Arrays);\n \n                Suffix  : Array_Element_Id;\n                Element : Array_Element;\n                Suffix2 : Array_Element_Id;\n \n             begin\n-               --  If some suffixs have been specified, we make sure that\n+               --  If some suffixes have been specified, we make sure that\n                --  for each language for which a default suffix has been\n                --  specified, there is a suffix specified, either the one\n                --  in the project file or if there were noe, the default.\n \n-               if Impl_Suffixs /= No_Array_Element then\n+               if Impl_Suffixes /= No_Array_Element then\n                   Suffix := Data.Naming.Body_Suffix;\n \n                   while Suffix /= No_Array_Element loop\n                      Element := Array_Elements.Table (Suffix);\n-                     Suffix2 := Impl_Suffixs;\n+                     Suffix2 := Impl_Suffixes;\n \n                      while Suffix2 /= No_Array_Element loop\n                         exit when Array_Elements.Table (Suffix2).Index =\n@@ -3887,16 +3885,16 @@ package body Prj.Nmsc is\n                            Src_Index => Element.Src_Index,\n                            Index_Case_Sensitive => False,\n                            Value => Element.Value,\n-                           Next  => Impl_Suffixs);\n-                        Impl_Suffixs := Array_Elements.Last;\n+                           Next  => Impl_Suffixes);\n+                        Impl_Suffixes := Array_Elements.Last;\n                      end if;\n \n                      Suffix := Element.Next;\n                   end loop;\n \n-                  --  Put the resulting array as the implementation suffixs\n+                  --  Put the resulting array as the implementation suffixes\n \n-                  Data.Naming.Body_Suffix := Impl_Suffixs;\n+                  Data.Naming.Body_Suffix := Impl_Suffixes;\n                end if;\n             end;\n "}, {"sha": "1af7f5989185a2436e35f78de67c3dca92b0aa4f", "filename": "gcc/ada/prj.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fprj.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fprj.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.ads?ref=5d09245e6a54b290b5f44b686214b41cf555152a", "patch": "@@ -675,7 +675,7 @@ package Prj is\n       Language_Independent_Checked : Boolean := False;\n       --  A flag that indicates that the project file has been checked\n       --  for language independent features: Object_Directory,\n-      --  Source_Directories, Library, non empty Naming Suffixs.\n+      --  Source_Directories, Library, non empty Naming Suffixes.\n \n       Checked : Boolean := False;\n       --  A flag to avoid checking repetitively the naming scheme of\n@@ -732,7 +732,7 @@ package Prj is\n      (Language            : Name_Id;\n       Default_Spec_Suffix : Name_Id;\n       Default_Body_Suffix : Name_Id);\n-   --  Register the default suffixs for a given language. These extensions\n+   --  Register the default suffixes for a given language. These extensions\n    --  will be ignored if the user has specified a new naming scheme in a\n    --  project file.\n    --"}, {"sha": "91e8278d0066d5764fe789c09187e57a31d50dc7", "filename": "gcc/ada/s-secsta.adb", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fs-secsta.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fs-secsta.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-secsta.adb?ref=5d09245e6a54b290b5f44b686214b41cf555152a", "patch": "@@ -54,7 +54,7 @@ package body System.Secondary_Stack is\n    --  then the secondary stack is allocated statically by grabbing a\n    --  section of the primary stack and using it for this purpose.\n \n-   type Memory is array (Mark_Id range <>) of SSE.Storage_Element;\n+   type Memory is array (SS_Ptr range <>) of SSE.Storage_Element;\n    for Memory'Alignment use Standard'Maximum_Alignment;\n    --  This is the type used for actual allocation of secondary stack\n    --  areas. We require maximum alignment for all such allocations.\n@@ -98,16 +98,16 @@ package body System.Secondary_Stack is\n    --    +-----------------+               +------------------+\n    --\n \n-   type Chunk_Id (First, Last : Mark_Id);\n+   type Chunk_Id (First, Last : SS_Ptr);\n    type Chunk_Ptr is access all Chunk_Id;\n \n-   type Chunk_Id (First, Last : Mark_Id) is record\n+   type Chunk_Id (First, Last : SS_Ptr) is record\n       Prev, Next : Chunk_Ptr;\n       Mem        : Memory (First .. Last);\n    end record;\n \n    type Stack_Id is record\n-      Top           : Mark_Id;\n+      Top           : SS_Ptr;\n       Default_Size  : SSE.Storage_Count;\n       Current_Chunk : Chunk_Ptr;\n    end record;\n@@ -134,16 +134,16 @@ package body System.Secondary_Stack is\n    --  by the following data strcuture\n \n    type Fixed_Stack_Id is record\n-      Top : Mark_Id;\n+      Top : SS_Ptr;\n       --  Index of next available location in Mem. This is initialized to\n       --  0, and then incremented on Allocate, and Decremented on Release.\n \n-      Last : Mark_Id;\n+      Last : SS_Ptr;\n       --  Length of usable Mem array, which is thus the index past the\n       --  last available location in Mem. Mem (Last-1) can be used. This\n       --  is used to check that the stack does not overflow.\n \n-      Max : Mark_Id;\n+      Max : SS_Ptr;\n       --  Maximum value of Top. Initialized to 0, and then may be incremented\n       --  on Allocate, but is never Decremented. The last used location will\n       --  be Mem (Max - 1), so Max is the maximum count of used stack space.\n@@ -177,9 +177,9 @@ package body System.Secondary_Stack is\n      (Addr         : out Address;\n       Storage_Size : SSE.Storage_Count)\n    is\n-      Max_Align    : constant Mark_Id := Mark_Id (Standard'Maximum_Alignment);\n-      Max_Size     : constant Mark_Id :=\n-                       ((Mark_Id (Storage_Size) + Max_Align - 1) / Max_Align)\n+      Max_Align    : constant SS_Ptr := SS_Ptr (Standard'Maximum_Alignment);\n+      Max_Size     : constant SS_Ptr :=\n+                       ((SS_Ptr (Storage_Size) + Max_Align - 1) / Max_Align)\n                          * Max_Align;\n \n    begin\n@@ -256,7 +256,7 @@ package body System.Secondary_Stack is\n                   Chunk.Next :=\n                     new Chunk_Id\n                       (First => Chunk.Last + 1,\n-                       Last  => Chunk.Last + Mark_Id (Stack.Default_Size));\n+                       Last  => Chunk.Last + SS_Ptr (Stack.Default_Size));\n \n                   Chunk.Next.Prev := Chunk;\n \n@@ -359,12 +359,12 @@ package body System.Secondary_Stack is\n          begin\n             Put_Line (\n                       \"  Total size              : \"\n-                      & Mark_Id'Image (Fixed_Stack.Last)\n+                      & SS_Ptr'Image (Fixed_Stack.Last)\n                       & \" bytes\");\n \n             Put_Line (\n                       \"  Current allocated space : \"\n-                      & Mark_Id'Image (Fixed_Stack.Top - 1)\n+                      & SS_Ptr'Image (Fixed_Stack.Top - 1)\n                       & \" bytes\");\n          end;\n \n@@ -391,12 +391,12 @@ package body System.Secondary_Stack is\n \n             Put_Line (\n                       \"  Total size              : \"\n-                      & Mark_Id'Image (Chunk.Last)\n+                      & SS_Ptr'Image (Chunk.Last)\n                       & \" bytes\");\n \n             Put_Line (\n                       \"  Current allocated space : \"\n-                      & Mark_Id'Image (Stack.Top - 1)\n+                      & SS_Ptr'Image (Stack.Top - 1)\n                       & \" bytes\");\n \n             Put_Line (\n@@ -434,7 +434,7 @@ package body System.Secondary_Stack is\n                Fixed_Stack.Last := 0;\n             else\n                Fixed_Stack.Last :=\n-                 Mark_Id (Size) - Dummy_Fixed_Stack.Mem'Position;\n+                 SS_Ptr (Size) - Dummy_Fixed_Stack.Mem'Position;\n             end if;\n          end;\n \n@@ -445,7 +445,7 @@ package body System.Secondary_Stack is\n             Stack : Stack_Ptr;\n          begin\n             Stack               := new Stack_Id;\n-            Stack.Current_Chunk := new Chunk_Id (1, Mark_Id (Size));\n+            Stack.Current_Chunk := new Chunk_Id (1, SS_Ptr (Size));\n             Stack.Top           := 1;\n             Stack.Default_Size  := SSE.Storage_Count (Size);\n             Stk := To_Addr (Stack);\n@@ -458,11 +458,12 @@ package body System.Secondary_Stack is\n    -------------\n \n    function SS_Mark return Mark_Id is\n+      Sstk : constant System.Address := SSL.Get_Sec_Stack_Addr.all;\n    begin\n       if SS_Ratio_Dynamic then\n-         return To_Stack_Ptr (SSL.Get_Sec_Stack_Addr.all).Top;\n+         return (Sstk => Sstk, Sptr => To_Stack_Ptr (Sstk).Top);\n       else\n-         return To_Fixed_Stack_Ptr (SSL.Get_Sec_Stack_Addr.all).Top;\n+         return (Sstk => Sstk, Sptr => To_Fixed_Stack_Ptr (Sstk).Top);\n       end if;\n    end SS_Mark;\n \n@@ -473,9 +474,9 @@ package body System.Secondary_Stack is\n    procedure SS_Release (M : Mark_Id) is\n    begin\n       if SS_Ratio_Dynamic then\n-         To_Stack_Ptr (SSL.Get_Sec_Stack_Addr.all).Top := M;\n+         To_Stack_Ptr (M.Sstk).Top := M.Sptr;\n       else\n-         To_Fixed_Stack_Ptr (SSL.Get_Sec_Stack_Addr.all).Top := M;\n+         To_Fixed_Stack_Ptr (M.Sstk).Top := M.Sptr;\n       end if;\n    end SS_Release;\n \n@@ -491,7 +492,7 @@ package body System.Secondary_Stack is\n    Stack : aliased Stack_Id;\n    for Stack'Alignment use Standard'Maximum_Alignment;\n \n-   Chunk : aliased Chunk_Id (1, Mark_Id (Default_Secondary_Stack_Size));\n+   Chunk : aliased Chunk_Id (1, SS_Ptr (Default_Secondary_Stack_Size));\n    for Chunk'Alignment use Standard'Maximum_Alignment;\n \n    Chunk_Address : Address;"}, {"sha": "ad2b34e3ab48c2fb4fe66e11fd321f05fa8f5423", "filename": "gcc/ada/s-secsta.ads", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fs-secsta.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fs-secsta.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-secsta.ads?ref=5d09245e6a54b290b5f44b686214b41cf555152a", "patch": "@@ -73,7 +73,7 @@ package System.Secondary_Stack is\n    --  to System.Null_Address.\n \n    type Mark_Id is private;\n-   --  Type used to mark the stack\n+   --  Type used to mark the stack for mark/release processing\n \n    function SS_Mark return Mark_Id;\n    --  Return the Mark corresponding to the current state of the stack\n@@ -102,6 +102,15 @@ private\n    --  Unused entity that is just present to ease the sharing of the pool\n    --  mechanism for specific allocation/deallocation in the compiler\n \n-   type Mark_Id is new SSE.Integer_Address;\n+   type SS_Ptr is new SSE.Integer_Address;\n+   --  Stack pointer value for secondary stack\n+\n+   type Mark_Id is record\n+      Sstk : System.Address;\n+      Sptr : SS_Ptr;\n+   end record;\n+   --  A mark value contains the address of the secondary stack structure,\n+   --  as returned by System.Soft_Links.Get_Sec_Stack_Addr, and a stack\n+   --  pointer value corresponding to the point of the mark call.\n \n end System.Secondary_Stack;"}, {"sha": "79c1b36b78e6419685e7e7214baca04b0328aff4", "filename": "gcc/ada/s-solita.adb", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fs-solita.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fs-solita.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-solita.adb?ref=5d09245e6a54b290b5f44b686214b41cf555152a", "patch": "@@ -31,8 +31,6 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This package contains the tasking versions soft links.\n-\n pragma Style_Checks (All_Checks);\n --  Turn off subprogram alpha ordering check, since we group soft link\n --  bodies and dummy soft link bodies together separately in this unit.\n@@ -59,9 +57,9 @@ package body System.Soft_Links.Tasking is\n    --  Boolean flag that indicates whether the tasking soft links have\n    --  already been set.\n \n-   ----------------------------------------------------------------------\n-   -- Tasking versions of some services needed by non-tasking programs --\n-   ----------------------------------------------------------------------\n+   -----------------------------------------------------------------\n+   -- Tasking Versions of Services Needed by Non-Tasking Programs --\n+   -----------------------------------------------------------------\n \n    function  Get_Jmpbuf_Address return  Address;\n    procedure Set_Jmpbuf_Address (Addr : Address);\n@@ -131,10 +129,10 @@ package body System.Soft_Links.Tasking is\n \n    procedure Init_Tasking_Soft_Links is\n    begin\n-      --  If the tasking soft links have already been initialized do not\n-      --  repeat it.\n+      --  Set links only if not set already\n \n       if not Initialized then\n+\n          --  Mark tasking soft links as initialized\n \n          Initialized := True;\n@@ -158,7 +156,6 @@ package body System.Soft_Links.Tasking is\n          SSL.Set_Jmpbuf_Address     (SSL.Get_Jmpbuf_Address_NT);\n          SSL.Set_Machine_State_Addr (SSL.Get_Machine_State_Addr_NT);\n       end if;\n-\n    end Init_Tasking_Soft_Links;\n \n end System.Soft_Links.Tasking;"}, {"sha": "70252ca085801651ce5bde5758a54c7039f73cde", "filename": "gcc/ada/s-solita.ads", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fs-solita.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fs-solita.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-solita.ads?ref=5d09245e6a54b290b5f44b686214b41cf555152a", "patch": "@@ -34,8 +34,7 @@\n --  This package contains the tasking versions soft links that are common\n --  to the full and the restricted run times. The rest of the required soft\n --  links are set by System.Tasking.Initialization and System.Tasking.Stages\n---  (full run time) or System.Tasking.Restricted.Stages (restricted run\n---  time).\n+--  (full run time) or System.Tasking.Restricted.Stages (restricted run time).\n \n package System.Soft_Links.Tasking is\n "}, {"sha": "11a3bcece35210613a929b478e550cd3c958625d", "filename": "gcc/ada/s-vxwork-x86.ads", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fs-vxwork-x86.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fs-vxwork-x86.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-vxwork-x86.ads?ref=5d09245e6a54b290b5f44b686214b41cf555152a", "patch": "@@ -0,0 +1,53 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                 GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS              --\n+--                                                                          --\n+--                        S Y S T E M . V X W O R K S                       --\n+--                                                                          --\n+--                                   S p e c                                --\n+--                                                                          --\n+--            Copyright (C) 1998-2004 Free Software Foundation, Inc.        --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNARL; see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University.       --\n+-- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is the x86 VxWorks version of this package\n+\n+package System.VxWorks is\n+   pragma Preelaborate (System.VxWorks);\n+\n+   --  Floating point context record. x86 version\n+\n+   --  For now this is a dummy implementation (more work needed ???)\n+\n+   type FP_CONTEXT is record\n+      Dummy : Integer;\n+   end record;\n+\n+   for FP_CONTEXT'Alignment use 4;\n+   pragma Convention (C, FP_CONTEXT);\n+\n+   Num_HW_Interrupts : constant := 256;\n+   --  Number of entries in hardware interrupt vector table\n+\n+end System.VxWorks;"}, {"sha": "b69e9678a91d0962733a5daeab4320f82c600ebd", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=5d09245e6a54b290b5f44b686214b41cf555152a", "patch": "@@ -3306,10 +3306,23 @@ package body Sem_Attr is\n       when Attribute_Size | Attribute_VADS_Size =>\n          Check_E0;\n \n-         if Is_Object_Reference (P)\n-           or else (Is_Entity_Name (P)\n-                     and then Ekind (Entity (P)) = E_Function)\n+         --  If prefix is parameterless function call, rewrite and resolve\n+         --  as such.\n+\n+         if Is_Entity_Name (P)\n+           and then Ekind (Entity (P)) = E_Function\n          then\n+            Resolve (P);\n+\n+         --  Similar processing for a protected function call\n+\n+         elsif Nkind (P) = N_Selected_Component\n+           and then Ekind (Entity (Selector_Name (P))) = E_Function\n+         then\n+            Resolve (P);\n+         end if;\n+\n+         if Is_Object_Reference (P) then\n             Check_Object_Reference (P);\n \n          elsif Is_Entity_Name (P)\n@@ -6566,15 +6579,16 @@ package body Sem_Attr is\n                   --  outside a generic body when the subprogram is declared\n                   --  within that generic body.\n \n-                  elsif Enclosing_Generic_Body (Entity (P))\n-                    /= Enclosing_Generic_Body (Btyp)\n+                  elsif Present (Enclosing_Generic_Body (Entity (P)))\n+                    and then Enclosing_Generic_Body (Entity (P)) /=\n+                             Enclosing_Generic_Body (Btyp)\n                   then\n                      Error_Msg_N\n                        (\"access type must not be outside generic body\", P);\n                   end if;\n                end if;\n \n-               --  if this is a renaming, an inherited operation, or a\n+               --  If this is a renaming, an inherited operation, or a\n                --  subprogram instance, use the original entity.\n \n                if Is_Entity_Name (P)\n@@ -6603,7 +6617,8 @@ package body Sem_Attr is\n \n             elsif Is_Overloaded (P) then\n \n-               --  Use the designated type of the context  to disambiguate.\n+               --  Use the designated type of the context  to disambiguate\n+\n                declare\n                   Index : Interp_Index;\n                   It    : Interp;\n@@ -7263,7 +7278,6 @@ package body Sem_Attr is\n       --  Finally perform static evaluation on the attribute reference\n \n       Eval_Attribute (N);\n-\n    end Resolve_Attribute;\n \n end Sem_Attr;"}, {"sha": "5eafc79d97eea4beaef2fd9a94c82bb9124b46dc", "filename": "gcc/ada/sem_ch11.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fsem_ch11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fsem_ch11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch11.adb?ref=5d09245e6a54b290b5f44b686214b41cf555152a", "patch": "@@ -479,7 +479,6 @@ package body Sem_Ch11 is\n             Rewrite (N, Make_Null_Statement (Sloc (N)));\n          end if;\n       end if;\n-\n    end Analyze_Raise_xxx_Error;\n \n    -----------------------------"}, {"sha": "2e0534a16d49532905a62130cc275c3ba6e3f4a0", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=5d09245e6a54b290b5f44b686214b41cf555152a", "patch": "@@ -8178,6 +8178,26 @@ package body Sem_Ch12 is\n       else\n          Act_T := Entity (Actual);\n \n+         --  Ada 2005 (AI-216): An Unchecked_Union subtype shall only be passed\n+         --  as a generic actual parameter if the corresponding formal type\n+         --  does not have a known_discriminant_part, or is a formal derived\n+         --  type that is an Unchecked_Union type.\n+\n+         if Is_Unchecked_Union (Base_Type (Act_T)) then\n+            if not Has_Discriminants (A_Gen_T)\n+                     or else\n+                   (Is_Derived_Type (A_Gen_T)\n+                     and then\n+                    Is_Unchecked_Union (A_Gen_T))\n+            then\n+               null;\n+            else\n+               Error_Msg_N (\"Unchecked_Union cannot be the actual for a\" &\n+                 \" discriminated formal type\", Act_T);\n+\n+            end if;\n+         end if;\n+\n          --  Deal with fixed/floating restrictions\n \n          if Is_Floating_Point_Type (Act_T) then"}, {"sha": "670ee7656a304a222a75b9f3c0c8f897973afbdc", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 75, "deletions": 10, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=5d09245e6a54b290b5f44b686214b41cf555152a", "patch": "@@ -950,6 +950,63 @@ package body Sem_Ch3 is\n       T  : Entity_Id;\n       P  : Entity_Id;\n \n+      function Contains_POC (Constr : Node_Id) return Boolean;\n+      --  Determines whether a constraint uses the discriminant of a record\n+      --  type thus becoming a per-object constraint (POC).\n+\n+      ------------------\n+      -- Contains_POC --\n+      ------------------\n+\n+      function Contains_POC (Constr : Node_Id) return Boolean is\n+      begin\n+         case Nkind (Constr) is\n+\n+            when N_Attribute_Reference =>\n+               return Attribute_Name (Constr) = Name_Access\n+                        and\n+                      Prefix (Constr) = Scope (Entity (Prefix (Constr)));\n+\n+            when N_Discriminant_Association =>\n+               return Denotes_Discriminant (Expression (Constr));\n+\n+            when N_Identifier =>\n+               return Denotes_Discriminant (Constr);\n+\n+            when N_Index_Or_Discriminant_Constraint =>\n+               declare\n+                  IDC : Node_Id := First (Constraints (Constr));\n+               begin\n+                  while Present (IDC) loop\n+\n+                     --  One per-object constraint is sufficent\n+\n+                     if Contains_POC (IDC) then\n+                        return True;\n+                     end if;\n+\n+                     Next (IDC);\n+                  end loop;\n+\n+                  return False;\n+               end;\n+\n+            when N_Range =>\n+               return Denotes_Discriminant (Low_Bound (Constr))\n+                        or\n+                      Denotes_Discriminant (High_Bound (Constr));\n+\n+            when N_Range_Constraint =>\n+               return Denotes_Discriminant (Range_Expression (Constr));\n+\n+            when others =>\n+               return False;\n+\n+         end case;\n+      end Contains_POC;\n+\n+   --  Start of processing for Analyze_Component_Declaration\n+\n    begin\n       Generate_Definition (Id);\n       Enter_Name (Id);\n@@ -1042,6 +1099,24 @@ package body Sem_Ch3 is\n       Set_Etype (Id, T);\n       Set_Is_Aliased (Id, Aliased_Present (Component_Definition (N)));\n \n+      --  The component declaration may have a per-object constraint, set the\n+      --  appropriate flag in the defining identifier of the subtype.\n+\n+      if Present (Subtype_Indication (Component_Definition (N))) then\n+         declare\n+            Sindic : constant Node_Id :=\n+               Subtype_Indication (Component_Definition (N));\n+\n+         begin\n+            if Nkind (Sindic) = N_Subtype_Indication\n+              and then Present (Constraint (Sindic))\n+              and then Contains_POC (Constraint (Sindic))\n+            then\n+               Set_Has_Per_Object_Constraint (Id);\n+            end if;\n+         end;\n+      end if;\n+\n       --  Ada 2005 (AI-231): Propagate the null-excluding attribute and carry\n       --  out some static checks\n \n@@ -9492,9 +9567,6 @@ package body Sem_Ch3 is\n \n          return;\n \n-      elsif Is_Unchecked_Union (Parent_Type) then\n-         Error_Msg_N (\"cannot derive from Unchecked_Union type\", N);\n-\n       --  Ada 2005 (AI-231): Static check\n \n       elsif Is_Access_Type (Parent_Type)\n@@ -12581,13 +12653,6 @@ package body Sem_Ch3 is\n          P := Parent (S);\n          Subtype_Mark_Id := Entity (Subtype_Mark (S));\n \n-         if Is_Unchecked_Union (Subtype_Mark_Id)\n-           and then Comes_From_Source (Related_Nod)\n-         then\n-            Error_Msg_N\n-              (\"cannot create subtype of Unchecked_Union\", Related_Nod);\n-         end if;\n-\n          --  Explicit subtype declaration case\n \n          if Nkind (P) = N_Subtype_Declaration then"}, {"sha": "e8cdf002e5c3336eff7d22d4fc1ade9bd9af75d5", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 39, "deletions": 29, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=5d09245e6a54b290b5f44b686214b41cf555152a", "patch": "@@ -2590,7 +2590,7 @@ package body Sem_Ch4 is\n                Set_Etype (Sel, Etype (Comp));\n \n                if Ekind (Comp) = E_Discriminant then\n-                  if Is_Unchecked_Union (Prefix_Type) then\n+                  if Is_Unchecked_Union (Base_Type (Prefix_Type)) then\n                      Error_Msg_N\n                        (\"cannot reference discriminant of Unchecked_Union\",\n                         Sel);\n@@ -4653,13 +4653,14 @@ package body Sem_Ch4 is\n    --------------------------\n \n    function Try_Object_Operation (N : Node_Id) return Boolean is\n-      Obj        : constant Node_Id := Prefix (N);\n-      Obj_Type   : Entity_Id;\n-      Actual     : Node_Id;\n-      Last_Node  : Node_Id;\n-      --  Last_Node is used to free all the nodes generated while trying the\n-      --  alternatives. NOTE: This must be removed because it is considered\n-      --  too low level\n+      Obj       : constant Node_Id := Prefix (N);\n+      Obj_Type  : Entity_Id;\n+      Actual    : Node_Id;\n+\n+      Last_Node : Node_Id;\n+      --  Used to free all the nodes generated while trying the alternatives.\n+      --  To me removed later, too low level ???\n+\n       use Atree_Private_Part;\n \n       function Try_Replacement\n@@ -4673,21 +4674,23 @@ package body Sem_Ch4 is\n       --  Nam_Ent is the entity that provides the formals against which\n       --  the actuals are checked. If the actuals are compatible with\n       --  Ent_Nam, this function returns true.\n+      --  Document other parameters, also what is Ent_Nam???\n \n       function Try_Primitive_Operations\n         (New_Prefix : Entity_Id;\n          New_Subprg : Node_Id;\n          Obj        : Node_Id;\n          Obj_Type   : Entity_Id) return Boolean;\n-      --  Traverse the list of primitive subprograms to look for the\n+      --  Traverse list of primitive subprograms to look for the subprogram\n+      --  Parameters should be documented ???\n       --  subprogram.\n \n       function Try_Class_Wide_Operation\n         (New_Subprg : Node_Id;\n          Obj        : Node_Id;\n          Obj_Type   : Entity_Id) return Boolean;\n-      --  Traverse all the ancestor types to look for a class-wide\n-      --  subprogram\n+      --  Traverse all the ancestor types to look for a class-wide subprogram\n+      --  Parameters should be documented ???\n \n       ------------------------------\n       -- Try_Primitive_Operations --\n@@ -4699,9 +4702,9 @@ package body Sem_Ch4 is\n          Obj        : Node_Id;\n          Obj_Type   : Entity_Id) return Boolean\n       is\n-         Deref      : Node_Id;\n-         Elmt       : Elmt_Id;\n-         Prim_Op    : Entity_Id;\n+         Deref   : Node_Id;\n+         Elmt    : Elmt_Id;\n+         Prim_Op : Entity_Id;\n \n       begin\n          --  Look for the subprogram in the list of primitive operations.\n@@ -4711,7 +4714,6 @@ package body Sem_Ch4 is\n          --  analysis after the node replacement will resolve it.\n \n          Elmt := First_Elmt (Primitive_Operations (Obj_Type));\n-\n          while Present (Elmt) loop\n             Prim_Op := Node (Elmt);\n \n@@ -4754,19 +4756,19 @@ package body Sem_Ch4 is\n          Obj        : Node_Id;\n          Obj_Type   : Entity_Id) return Boolean\n       is\n-         Deref      : Node_Id;\n-         Hom        : Entity_Id;\n-         Typ        : Entity_Id;\n+         Deref : Node_Id;\n+         Hom   : Entity_Id;\n+         Typ   : Entity_Id;\n \n       begin\n-         Typ := Obj_Type;\n+         --  Loop through ancestor types\n \n+         Typ := Obj_Type;\n          loop\n             --  For each parent subtype we traverse all the homonym chain\n             --  looking for a candidate class-wide subprogram\n \n             Hom := Current_Entity (New_Subprg);\n-\n             while Present (Hom) loop\n                if (Ekind (Hom) = E_Procedure\n                      or else Ekind (Hom) = E_Function)\n@@ -4801,9 +4803,10 @@ package body Sem_Ch4 is\n                Hom := Homonym (Hom);\n             end loop;\n \n-            exit when Etype (Typ) = Typ;\n+            --  Climb to ancestor type if there is one\n \n-            Typ := Etype (Typ); --  Climb to the ancestor type\n+            exit when Etype (Typ) = Typ;\n+            Typ := Etype (Typ);\n          end loop;\n \n          return False;\n@@ -4838,8 +4841,11 @@ package body Sem_Ch4 is\n \n          if (Nkind (Parent (N)) = N_Procedure_Call_Statement\n                or else Nkind (Parent (N)) = N_Function_Call)\n-             and then N /= First (Parameter_Associations (Parent (N)))\n-               --  Protect against recursive call; It occurs in \"..:= F (O.P)\"\n+\n+            --  Protect against recursive call; It occurs in \"..:= F (O.P)\"\n+\n+            and then N /= First (Parameter_Associations (Parent (N)))\n+\n          then\n             Node_To_Replace := Parent (N);\n \n@@ -4886,9 +4892,10 @@ package body Sem_Ch4 is\n             --  Previous analysis transformed the node with the name\n             --  and we have to reset it to properly re-analyze it.\n \n-            New_Name := Make_Selected_Component (Loc,\n-                          Prefix        => New_Reference_To (New_Prefix, Loc),\n-                          Selector_Name => New_Copy_Tree (New_Subprg));\n+            New_Name :=\n+              Make_Selected_Component (Loc,\n+                Prefix        => New_Reference_To (New_Prefix, Loc),\n+                Selector_Name => New_Copy_Tree (New_Subprg));\n             Set_Name (Call_Node, New_Name);\n \n             Set_Analyzed (Call_Node, False);\n@@ -4898,6 +4905,7 @@ package body Sem_Ch4 is\n             return True;\n \n          --  Free all the nodes used for this test and return\n+\n          else\n             Nodes.Set_Last (Last_Node);\n             return False;\n@@ -4927,8 +4935,10 @@ package body Sem_Ch4 is\n \n       if (Nkind (Parent (N)) = N_Procedure_Call_Statement\n             or else Nkind (Parent (N)) = N_Function_Call)\n-          and then N /= First (Parameter_Associations (Parent (N)))\n-            --  Protects against recursive call in case of \"..:= F (O.Proc)\"\n+\n+         --  Protects against recursive call in case of \"..:= F (O.Proc)\"\n+\n+         and then N /= First (Parameter_Associations (Parent (N)))\n       then\n          Actual := First (Parameter_Associations (Parent (N)));\n "}, {"sha": "0077db2677aa4ec7e46e8adce58e033ef30b988e", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 54, "deletions": 9, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=5d09245e6a54b290b5f44b686214b41cf555152a", "patch": "@@ -597,6 +597,12 @@ package body Sem_Ch5 is\n    ----------------------------\n \n    procedure Analyze_Case_Statement (N : Node_Id) is\n+      Exp            : Node_Id;\n+      Exp_Type       : Entity_Id;\n+      Exp_Btype      : Entity_Id;\n+      Last_Choice    : Nat;\n+      Dont_Care      : Boolean;\n+      Others_Present : Boolean;\n \n       Statements_Analyzed : Boolean := False;\n       --  Set True if at least some statement sequences get analyzed.\n@@ -640,22 +646,61 @@ package body Sem_Ch5 is\n       ------------------------\n \n       procedure Process_Statements (Alternative : Node_Id) is\n+         Choices : constant List_Id := Discrete_Choices (Alternative);\n+         Ent     : Entity_Id;\n+\n       begin\n          Unblocked_Exit_Count := Unblocked_Exit_Count + 1;\n          Statements_Analyzed := True;\n+\n+         --  An interesting optimization. If the case statement expression\n+         --  is a simple entity, then we can set the current value within\n+         --  an alternative if the alternative has one possible value.\n+\n+         --    case N is\n+         --      when 1      => alpha\n+         --      when 2 | 3  => beta\n+         --      when others => gamma\n+\n+         --  Here we know that N is initially 1 within alpha, but for beta\n+         --  and gamma, we do not know anything more about the initial value.\n+\n+         if Is_Entity_Name (Exp) then\n+            Ent := Entity (Exp);\n+\n+            if Ekind (Ent) = E_Variable\n+                 or else\n+               Ekind (Ent) = E_In_Out_Parameter\n+                 or else\n+               Ekind (Ent) = E_Out_Parameter\n+            then\n+               if List_Length (Choices) = 1\n+                 and then Nkind (First (Choices)) in N_Subexpr\n+                 and then Compile_Time_Known_Value (First (Choices))\n+               then\n+                  Set_Current_Value (Entity (Exp), First (Choices));\n+               end if;\n+\n+               Analyze_Statements (Statements (Alternative));\n+\n+               --  After analyzing the case, set the current value to empty\n+               --  since we won't know what it is for the next alternative\n+               --  (unless reset by this same circuit), or after the case.\n+\n+               Set_Current_Value (Entity (Exp), Empty);\n+               return;\n+            end if;\n+         end if;\n+\n+         --  Case where expression is not an entity name of a variable\n+\n          Analyze_Statements (Statements (Alternative));\n       end Process_Statements;\n \n-      --  Variables local to Analyze_Case_Statement.\n-\n-      Exp       : Node_Id;\n-      Exp_Type  : Entity_Id;\n-      Exp_Btype : Entity_Id;\n+      --  Table to record choices. Put after subprograms since we make\n+      --  a call to Number_Of_Choices to get the right number of entries.\n \n-      Case_Table     : Choice_Table_Type (1 .. Number_Of_Choices (N));\n-      Last_Choice    : Nat;\n-      Dont_Care      : Boolean;\n-      Others_Present : Boolean;\n+      Case_Table : Choice_Table_Type (1 .. Number_Of_Choices (N));\n \n    --  Start of processing for Analyze_Case_Statement\n "}, {"sha": "9ed4bc4d54a5df0efd10115495fb23de2c1f847c", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=5d09245e6a54b290b5f44b686214b41cf555152a", "patch": "@@ -3285,6 +3285,13 @@ package body Sem_Ch6 is\n                Formal_Type := Etype (Formal);\n             end if;\n \n+            --  Do not produce extra formals for Unchecked_Union parameters.\n+            --  Jump directly to the end of the loop.\n+\n+            if Is_Unchecked_Union (Base_Type (Formal_Type)) then\n+               goto Skip_Extra_Formal_Generation;\n+            end if;\n+\n             if not Has_Discriminants (Formal_Type)\n               and then Ekind (Formal_Type) in Private_Kind\n               and then Present (Underlying_Type (Formal_Type))\n@@ -3339,6 +3346,11 @@ package body Sem_Ch6 is\n             Next_Formal (P_Formal);\n          end if;\n \n+         --  This label is required when skipping extra formal generation for\n+         --  Unchecked_Union parameters.\n+\n+         <<Skip_Extra_Formal_Generation>>\n+\n          Next_Formal (Formal);\n       end loop;\n    end Create_Extra_Formals;\n@@ -5225,6 +5237,7 @@ package body Sem_Ch6 is\n          elsif Is_Record_Type (T)\n            and then Ekind (Formal) = E_In_Parameter\n            and then Chars (Formal) /= Name_uInit\n+           and then not Is_Unchecked_Union (T)\n            and then not Is_Discrim_SO_Function (Subp)\n          then\n             AS_Needed := True;"}, {"sha": "91d3067ba95794c117d0a9d0bbfdabb3d652c971", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 53, "deletions": 4, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=5d09245e6a54b290b5f44b686214b41cf555152a", "patch": "@@ -692,10 +692,15 @@ package body Sem_Ch7 is\n       --  is a public child of Parent as defined in 10.1.1\n \n       procedure Inspect_Deferred_Constant_Completion;\n-      --  Examines the deferred constants in the private part of the\n-      --  package specification. Emits the error \"constant declaration\n-      --  requires initialization expression \" if not completed by an\n-      --  import pragma.\n+      --  Examines the deferred constants in the private part of the package\n+      --  specification. Emits the error message \"constant declaration requires\n+      --  initialization expression \" if not completed by an Import pragma.\n+\n+      procedure Inspect_Unchecked_Union_Completion (Decls : List_Id);\n+      --  Detects all incomplete or private type declarations having a known\n+      --  discriminant part that are completed by an Unchecked_Union. Emits\n+      --  the error message \"Unchecked_Union may not complete discriminated\n+      --  partial view\".\n \n       ---------------------\n       -- Clear_Constants --\n@@ -834,6 +839,37 @@ package body Sem_Ch7 is\n          end loop;\n       end Inspect_Deferred_Constant_Completion;\n \n+      ----------------------------------------\n+      -- Inspect_Unchecked_Union_Completion --\n+      ----------------------------------------\n+\n+      procedure Inspect_Unchecked_Union_Completion (Decls : List_Id) is\n+         Decl : Node_Id := First (Decls);\n+\n+      begin\n+         while Present (Decl) loop\n+\n+            --  We are looking at an incomplete or private type declaration\n+            --  with a known_discriminant_part whose full view is an\n+            --  Unchecked_Union.\n+\n+            if (Nkind (Decl) = N_Incomplete_Type_Declaration\n+                  or else\n+                Nkind (Decl) = N_Private_Type_Declaration)\n+              and then Has_Discriminants (Defining_Identifier (Decl))\n+              and then Present (Full_View (Defining_Identifier (Decl)))\n+              and then Is_Unchecked_Union\n+                (Full_View (Defining_Identifier (Decl)))\n+            then\n+               Error_Msg_N (\"completion of discriminated partial view\" &\n+                 \" cannot be an Unchecked_Union\",\n+                 Full_View (Defining_Identifier (Decl)));\n+            end if;\n+\n+            Next (Decl);\n+         end loop;\n+      end Inspect_Unchecked_Union_Completion;\n+\n    --  Start of processing for Analyze_Package_Specification\n \n    begin\n@@ -982,6 +1018,18 @@ package body Sem_Ch7 is\n          Next_Entity (E);\n       end loop;\n \n+      --  Ada 2005 (AI-216): The completion of an incomplete or private type\n+      --  declaration having a known_discriminant_part shall not be an\n+      --  Unchecked_Union type.\n+\n+      if Present (Vis_Decls) then\n+         Inspect_Unchecked_Union_Completion (Vis_Decls);\n+      end if;\n+\n+      if Present (Priv_Decls) then\n+         Inspect_Unchecked_Union_Completion (Priv_Decls);\n+      end if;\n+\n       if Ekind (Id) = E_Generic_Package\n         and then Nkind (Orig_Decl) = N_Generic_Package_Declaration\n         and then Present (Priv_Decls)\n@@ -1443,6 +1491,7 @@ package body Sem_Ch7 is\n \n       while Present (Id) loop\n          Install_Package_Entity (Id);\n+         Set_Is_Hidden (Id, False);\n          Next_Entity (Id);\n       end loop;\n "}, {"sha": "5416e96965875b324b45d2677a4f5c0600bc53de", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=5d09245e6a54b290b5f44b686214b41cf555152a", "patch": "@@ -1530,13 +1530,45 @@ package body Sem_Eval is\n    procedure Eval_Integer_Literal (N : Node_Id) is\n       T : constant Entity_Id := Etype (N);\n \n+      function In_Any_Integer_Context return Boolean;\n+      --  If the literal is resolved with a specific type in a context\n+      --  where the expected type is Any_Integer, there are no range checks\n+      --  on the literal. By the time the literal is evaluated, it carries\n+      --  the type imposed by the enclosing expression, and we must recover\n+      --  the context to determine that Any_Integer is meant.\n+\n+      ----------------------------\n+      -- To_Any_Integer_Context --\n+      ----------------------------\n+\n+      function In_Any_Integer_Context return Boolean is\n+         Par : constant Node_Id   := Parent (N);\n+         K   : constant Node_Kind := Nkind (Par);\n+\n+      begin\n+         --  Any_Integer also appears in digits specifications for real types,\n+         --  but those have bounds smaller that those of any integer base\n+         --  type, so we can safely ignore these cases.\n+\n+         return    K = N_Number_Declaration\n+           or else K = N_Attribute_Reference\n+           or else K = N_Attribute_Definition_Clause\n+           or else K = N_Modular_Type_Definition\n+           or else K = N_Signed_Integer_Type_Definition;\n+      end In_Any_Integer_Context;\n+\n+   --  Start of processing for Eval_Integer_Literal\n+\n    begin\n+\n       --  If the literal appears in a non-expression context, then it is\n       --  certainly appearing in a non-static context, so check it. This\n       --  is actually a redundant check, since Check_Non_Static_Context\n       --  would check it, but it seems worth while avoiding the call.\n \n-      if Nkind (Parent (N)) not in N_Subexpr then\n+      if Nkind (Parent (N)) not in N_Subexpr\n+        and then not In_Any_Integer_Context\n+      then\n          Check_Non_Static_Context (N);\n       end if;\n "}, {"sha": "6edf69ccca6591f81e39b63679ba36532a451389", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 79, "deletions": 50, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=5d09245e6a54b290b5f44b686214b41cf555152a", "patch": "@@ -329,6 +329,10 @@ package body Sem_Prag is\n       procedure Check_At_Most_N_Arguments (N : Nat);\n       --  Check there are no more than N arguments present\n \n+      procedure Check_Component (Comp : Node_Id);\n+      --  Examine Unchecked_Union component for correct use of per-object\n+      --  constrained subtypes.\n+\n       procedure Check_Duplicated_Export_Name (Nam : Node_Id);\n       --  Nam is an N_String_Literal node containing the external name set\n       --  by an Import or Export pragma (or extended Import or Export pragma).\n@@ -392,6 +396,10 @@ package body Sem_Prag is\n       --  and to library level instantiations), and they are simply ignored,\n       --  which is implemented by rewriting them as null statements.\n \n+      procedure Check_Variant (Variant : Node_Id);\n+      --  Check Unchecked_Union variant for lack of nested variants and\n+      --  presence of at least one component.\n+\n       procedure Error_Pragma (Msg : String);\n       pragma No_Return (Error_Pragma);\n       --  Outputs error message for current pragma. The message contains an %\n@@ -923,6 +931,36 @@ package body Sem_Prag is\n          end if;\n       end Check_At_Most_N_Arguments;\n \n+      ---------------------\n+      -- Check_Component --\n+      ---------------------\n+\n+      procedure Check_Component (Comp : Node_Id) is\n+      begin\n+         if Nkind (Comp) = N_Component_Declaration then\n+            declare\n+               Sindic : constant Node_Id :=\n+                          Subtype_Indication (Component_Definition (Comp));\n+\n+            begin\n+               if Nkind (Sindic) = N_Subtype_Indication then\n+\n+                  --  Ada 2005 (AI-216): If a component subtype is subject to\n+                  --  a per-object constraint, then the component type shall\n+                  --  be an Unchecked_Union.\n+\n+                  if Has_Per_Object_Constraint (Defining_Identifier (Comp))\n+                    and then\n+                      not Is_Unchecked_Union (Etype (Subtype_Mark (Sindic)))\n+                  then\n+                     Error_Msg_N (\"component subtype subject to per-object\" &\n+                       \" constraint must be an Unchecked_Union\", Comp);\n+                  end if;\n+               end if;\n+            end;\n+         end if;\n+      end Check_Component;\n+\n       ----------------------------------\n       -- Check_Duplicated_Export_Name --\n       ----------------------------------\n@@ -1417,6 +1455,37 @@ package body Sem_Prag is\n          end if;\n       end Check_Valid_Library_Unit_Pragma;\n \n+      -------------------\n+      -- Check_Variant --\n+      -------------------\n+\n+      procedure Check_Variant (Variant : Node_Id) is\n+         Clist : constant Node_Id := Component_List (Variant);\n+         Comp  : Node_Id;\n+\n+      begin\n+         if Present (Variant_Part (Clist)) then\n+            Error_Msg_N\n+              (\"Unchecked_Union may not have nested variants\",\n+               Variant_Part (Clist));\n+         end if;\n+\n+         if not Is_Non_Empty_List (Component_Items (Clist)) then\n+            Error_Msg_N\n+              (\"Unchecked_Union may not have empty component list\",\n+               Variant);\n+            return;\n+         end if;\n+\n+         Comp := First (Component_Items (Clist));\n+         while Present (Comp) loop\n+\n+            Check_Component (Comp);\n+            Next (Comp);\n+\n+         end loop;\n+      end Check_Variant;\n+\n       ------------------\n       -- Error_Pragma --\n       ------------------\n@@ -9741,6 +9810,14 @@ package body Sem_Prag is\n                Tdef  := Type_Definition (Declaration_Node (Typ));\n                Clist := Component_List (Tdef);\n \n+               Comp := First (Component_Items (Clist));\n+               while Present (Comp) loop\n+\n+                  Check_Component (Comp);\n+                  Next (Comp);\n+\n+               end loop;\n+\n                if No (Clist) or else No (Variant_Part (Clist)) then\n                   Error_Msg_N\n                     (\"Unchecked_Union must have variant part\",\n@@ -9749,60 +9826,12 @@ package body Sem_Prag is\n                end if;\n \n                Vpart := Variant_Part (Clist);\n-\n-               if Is_Non_Empty_List (Component_Items (Clist)) then\n-                  Error_Msg_N\n-                    (\"components before variant not allowed \" &\n-                     \"in Unchecked_Union\",\n-                     First (Component_Items (Clist)));\n-               end if;\n-\n                Variant := First (Variants (Vpart));\n                while Present (Variant) loop\n-                  Clist := Component_List (Variant);\n-\n-                  if Present (Variant_Part (Clist)) then\n-                     Error_Msg_N\n-                       (\"Unchecked_Union may not have nested variants\",\n-                        Variant_Part (Clist));\n-                  end if;\n-\n-                  if not Is_Non_Empty_List (Component_Items (Clist)) then\n-                     Error_Msg_N\n-                       (\"Unchecked_Union may not have empty component list\",\n-                        Variant);\n-                     return;\n-                  end if;\n-\n-                  Comp := First (Component_Items (Clist));\n-\n-                  if Nkind (Comp) = N_Component_Declaration then\n-\n-                     if Present (Expression (Comp)) then\n-                        Error_Msg_N\n-                          (\"default initialization not allowed \" &\n-                           \"in Unchecked_Union\",\n-                           Expression (Comp));\n-                     end if;\n-\n-                     declare\n-                        Sindic : constant Node_Id :=\n-                          Subtype_Indication (Component_Definition (Comp));\n-\n-                     begin\n-                        if Nkind (Sindic) = N_Subtype_Indication then\n-                           Check_Static_Constraint (Constraint (Sindic));\n-                        end if;\n-                     end;\n-                  end if;\n-\n-                  if Present (Next (Comp)) then\n-                     Error_Msg_N\n-                       (\"Unchecked_Union variant can have only one component\",\n-                        Next (Comp));\n-                  end if;\n \n+                  Check_Variant (Variant);\n                   Next (Variant);\n+\n                end loop;\n             end if;\n "}, {"sha": "863e96b5ab4c5f65cf9869b1e91e63d962a9be88", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=5d09245e6a54b290b5f44b686214b41cf555152a", "patch": "@@ -4005,13 +4005,6 @@ package body Sem_Res is\n             return;\n \n          else\n-            if Comes_From_Source (N)\n-              and then Has_Unchecked_Union (T)\n-            then\n-               Error_Msg_N\n-                (\"cannot compare Unchecked_Union values\", N);\n-            end if;\n-\n             Resolve (L, T);\n             Resolve (R, T);\n             Check_Unset_Reference (L);\n@@ -4748,13 +4741,6 @@ package body Sem_Res is\n             end if;\n          end if;\n \n-         if Comes_From_Source (N)\n-           and then Has_Unchecked_Union (T)\n-         then\n-            Error_Msg_N\n-              (\"cannot compare Unchecked_Union values\", N);\n-         end if;\n-\n          Resolve (L, T);\n          Resolve (R, T);\n "}, {"sha": "0f1894aef824f4aff452b426502ac65e9dd5b392", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=5d09245e6a54b290b5f44b686214b41cf555152a", "patch": "@@ -467,6 +467,12 @@ package body Sem_Util is\n       Decl : Node_Id;\n \n    begin\n+      --  Unchecked_Union components do not require component subtypes\n+\n+      if Is_Unchecked_Union (T) then\n+         return Empty;\n+      end if;\n+\n       Subt :=\n         Make_Defining_Identifier (Loc,\n           Chars => New_Internal_Name ('S'));\n@@ -2394,7 +2400,7 @@ package body Sem_Util is\n       --  because the discriminant is not available. The restrictions on\n       --  Unchecked_Union are designed to make sure that this is OK.\n \n-      elsif Is_Unchecked_Union (Utyp) then\n+      elsif Is_Unchecked_Union (Base_Type (Utyp)) then\n          return Typ;\n \n       --  Here for the unconstrained case, we must find actual subtype"}, {"sha": "5212ffb49e3780f00d1b56731e911850421d17a1", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=5d09245e6a54b290b5f44b686214b41cf555152a", "patch": "@@ -503,6 +503,7 @@ package Sem_Util is\n    function Is_Local_Variable_Reference (Expr : Node_Id) return Boolean;\n    --  Determines whether Expr is a refeference to a variable or IN OUT\n    --  mode parameter of the current enclosing subprogram.\n+   --  Why are OUT parameters not considered here ???\n \n    function Is_Object_Reference (N : Node_Id) return Boolean;\n    --  Determines if the tree referenced by N represents an object. Both"}, {"sha": "0bdc08b1fcb8fed9787fc2f4970ad15b065f35ec", "filename": "gcc/ada/system-irix-n32.ads", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fsystem-irix-n32.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fsystem-irix-n32.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsystem-irix-n32.ads?ref=5d09245e6a54b290b5f44b686214b41cf555152a", "patch": "@@ -90,14 +90,26 @@ pragma Pure (System);\n \n    --  Priority-related Declarations (RM D.1)\n \n-   Max_Priority           : constant Positive := 30;\n-   Max_Interrupt_Priority : constant Positive := 31;\n-\n-   subtype Any_Priority       is Integer      range  0 .. 31;\n-   subtype Priority           is Any_Priority range  0 .. 30;\n-   subtype Interrupt_Priority is Any_Priority range 31 .. 31;\n-\n-   Default_Priority : constant Priority := 15;\n+   --  IRIX priorities as defined by realtime(5):\n+   --\n+   --  255        is for system-level interrupts\n+   --  240 - 254  are suggested for hard real-time threads\n+   --  200 - 239  are used by system device driver interrupt threads\n+   --  110 - 199  are suggested for interactive real-time applications\n+   --   90 - 109  are used by system daemon threads\n+   --    0 -  89  are suggested for soft real-time applications\n+   --\n+   --  We don't express the full range of IRIX priorities.  For now, we\n+   --  handle only the subset for soft real-time applications.\n+\n+   Max_Priority           : constant Positive := 88;\n+   Max_Interrupt_Priority : constant Positive := 89;\n+\n+   subtype Any_Priority       is Integer      range  0 .. 89;\n+   subtype Priority           is Any_Priority range  0 .. 88;\n+   subtype Interrupt_Priority is Any_Priority range 89 .. 89;\n+\n+   Default_Priority : constant Priority := 44;\n \n private\n "}, {"sha": "1575fdfea90452fd1146790648f54f617606e62d", "filename": "gcc/ada/system-vxworks-x86.ads", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fsystem-vxworks-x86.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fsystem-vxworks-x86.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsystem-vxworks-x86.ads?ref=5d09245e6a54b290b5f44b686214b41cf555152a", "patch": "@@ -0,0 +1,158 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                        GNAT RUN-TIME COMPONENTS                          --\n+--                                                                          --\n+--                               S Y S T E M                                --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                         (VxWorks Version x86)                            --\n+--                                                                          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package System is\n+pragma Pure (System);\n+--  Note that we take advantage of the implementation permission to\n+--  make this unit Pure instead of Preelaborable, see RM 13.7(36)\n+\n+   type Name is (SYSTEM_NAME_GNAT);\n+   System_Name : constant Name := SYSTEM_NAME_GNAT;\n+\n+   --  System-Dependent Named Numbers\n+\n+   Min_Int               : constant := Long_Long_Integer'First;\n+   Max_Int               : constant := Long_Long_Integer'Last;\n+\n+   Max_Binary_Modulus    : constant := 2 ** Long_Long_Integer'Size;\n+   Max_Nonbinary_Modulus : constant := Integer'Last;\n+\n+   Max_Base_Digits       : constant := Long_Long_Float'Digits;\n+   Max_Digits            : constant := Long_Long_Float'Digits;\n+\n+   Max_Mantissa          : constant := 63;\n+   Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n+\n+   Tick                  : constant := 1.0 / 60.0;\n+\n+   --  Storage-related Declarations\n+\n+   type Address is private;\n+   Null_Address : constant Address;\n+\n+   Storage_Unit : constant := 8;\n+   Word_Size    : constant := 32;\n+   Memory_Size  : constant := 2 ** 32;\n+\n+   --  Address comparison\n+\n+   function \"<\"  (Left, Right : Address) return Boolean;\n+   function \"<=\" (Left, Right : Address) return Boolean;\n+   function \">\"  (Left, Right : Address) return Boolean;\n+   function \">=\" (Left, Right : Address) return Boolean;\n+   function \"=\"  (Left, Right : Address) return Boolean;\n+\n+   pragma Import (Intrinsic, \"<\");\n+   pragma Import (Intrinsic, \"<=\");\n+   pragma Import (Intrinsic, \">\");\n+   pragma Import (Intrinsic, \">=\");\n+   pragma Import (Intrinsic, \"=\");\n+\n+   --  Other System-Dependent Declarations\n+\n+   type Bit_Order is (High_Order_First, Low_Order_First);\n+   Default_Bit_Order : constant Bit_Order := Low_Order_First;\n+\n+   --  Priority-related Declarations (RM D.1)\n+\n+   --  256        is reserved for the VxWorks kernel\n+   --  248 - 255  correspond to hardware interrupt levels 0 .. 7\n+   --  247        is a catchall default \"interrupt\" priority for signals,\n+   --             allowing higher priority than normal tasks, but lower than\n+   --             hardware priority levels.  Protected Object ceilings can\n+   --             override these values.\n+   --  246        is used by the Interrupt_Manager task\n+\n+   Max_Priority           : constant Positive := 245;\n+   Max_Interrupt_Priority : constant Positive := 255;\n+\n+   subtype Any_Priority       is Integer      range   0 .. 255;\n+   subtype Priority           is Any_Priority range   0 .. 245;\n+   subtype Interrupt_Priority is Any_Priority range 246 .. 255;\n+\n+   Default_Priority : constant Priority := 122;\n+\n+private\n+\n+   type Address is mod Memory_Size;\n+   Null_Address : constant Address := 0;\n+\n+   --------------------------------------\n+   -- System Implementation Parameters --\n+   --------------------------------------\n+\n+   --  These parameters provide information about the target that is used\n+   --  by the compiler. They are in the private part of System, where they\n+   --  can be accessed using the special circuitry in the Targparm unit\n+   --  whose source should be consulted for more detailed descriptions\n+   --  of the individual switch values.\n+\n+   AAMP                      : constant Boolean := False;\n+   Backend_Divide_Checks     : constant Boolean := False;\n+   Backend_Overflow_Checks   : constant Boolean := False;\n+   Command_Line_Args         : constant Boolean := False;\n+   Configurable_Run_Time     : constant Boolean := False;\n+   Denorm                    : constant Boolean := True;\n+   Duration_32_Bits          : constant Boolean := False;\n+   Exit_Status_Supported     : constant Boolean := True;\n+   Fractional_Fixed_Ops      : constant Boolean := False;\n+   Frontend_Layout           : constant Boolean := False;\n+   Functions_Return_By_DSP   : constant Boolean := False;\n+   Machine_Overflows         : constant Boolean := False;\n+   Machine_Rounds            : constant Boolean := True;\n+   OpenVMS                   : constant Boolean := False;\n+   Signed_Zeros              : constant Boolean := True;\n+   Stack_Check_Default       : constant Boolean := False;\n+   Stack_Check_Probes        : constant Boolean := False;\n+   Support_64_Bit_Divides    : constant Boolean := True;\n+   Support_Aggregates        : constant Boolean := True;\n+   Support_Composite_Assign  : constant Boolean := True;\n+   Support_Composite_Compare : constant Boolean := True;\n+   Support_Long_Shifts       : constant Boolean := True;\n+   Suppress_Standard_Library : constant Boolean := False;\n+   Use_Ada_Main_Program_Name : constant Boolean := True;\n+   ZCX_By_Default            : constant Boolean := False;\n+   GCC_ZCX_Support           : constant Boolean := False;\n+   Front_End_ZCX_Support     : constant Boolean := False;\n+\n+   --  Obsolete entries, to be removed eventually (bootstrap issues!)\n+\n+   High_Integrity_Mode       : constant Boolean := False;\n+   Long_Shifts_Inlined       : constant Boolean := False;\n+\n+end System;"}, {"sha": "91b051882c6ee5db2c82d14c8a0555dbe20b1009", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 129, "deletions": 111, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=5d09245e6a54b290b5f44b686214b41cf555152a", "patch": "@@ -82,17 +82,30 @@ bool type_annotate_only;\n \n struct stmt_group GTY((chain_next (\"%h.previous\"))) {\n   struct stmt_group *previous;\t/* Previous code group.  */\n+  struct stmt_group *global;\t/* Global code group from the level.  */\n   tree stmt_list;\t\t/* List of statements for this code group. */\n   tree block;\t\t\t/* BLOCK for this code group, if any. */\n   tree cleanups;\t\t/* Cleanups for this code group, if any.  */\n };\n \n static GTY(()) struct stmt_group *current_stmt_group;\n-static struct stmt_group *global_stmt_group;\n \n /* List of unused struct stmt_group nodes.  */\n static GTY((deletable)) struct stmt_group *stmt_group_free_list;\n \n+/* A structure used to record information on elaboration procedures\n+   we've made and need to process.\n+\n+   ??? gnat_node should be Node_Id, but gengtype gets confused.  */\n+\n+struct elab_info GTY((chain_next (\"%h.next\"))) {\n+  struct elab_info *next;\t/* Pointer to next in chain. */\n+  tree elab_proc;\t\t/* Elaboration procedure.  */\n+  int gnat_node;\t\t/* The N_Compilation_Unit.  */\n+};\n+\n+static GTY(()) struct elab_info *elab_info_list;\n+\n /* Free list of TREE_LIST nodes used for stacks.  */\n static GTY((deletable)) tree gnu_stack_free_list;\n \n@@ -102,6 +115,10 @@ static GTY((deletable)) tree gnu_stack_free_list;\n    handler.  Not used in the zero-cost case.  */\n static GTY(()) tree gnu_except_ptr_stack;\n \n+/* List of TREE_LIST nodes used to store the current elaboration procedure\n+   decl.  TREE_VALUE is the decl.  */\n+static GTY(()) tree gnu_elab_proc_stack;\n+\n /* Variable that stores a list of labels to be used as a goto target instead of\n    a return in some functions.  See processing for N_Subprogram_Body.  */\n static GTY(()) tree gnu_return_label_stack;\n@@ -114,15 +131,13 @@ static GTY(()) tree gnu_loop_label_stack;\n    TREE_VALUE of each entry is the label at the end of the switch.  */\n static GTY(()) tree gnu_switch_label_stack;\n \n-/* The FUNCTION_DECL for the elaboration procedure for the main unit.  */\n-static GTY(()) tree gnu_elab_proc_decl;\n-\n /* Map GNAT tree codes to GCC tree codes for simple expressions.  */\n static enum tree_code gnu_codes[Number_Node_Kinds];\n \n /* Current node being treated, in case abort called.  */\n Node_Id error_gnat_node;\n \n+static void Compilation_Unit_to_gnu (Node_Id);\n static void record_code_position (Node_Id);\n static void insert_code_for (Node_Id);\n static void start_stmt_group (void);\n@@ -149,7 +164,6 @@ static tree extract_values (tree, tree);\n static tree pos_to_constructor (Node_Id, tree, Entity_Id);\n static tree maybe_implicit_deref (tree);\n static tree gnat_stabilize_reference_1 (tree, bool);\n-static bool build_unit_elab (void);\n static void annotate_with_node (tree, Node_Id);\n \n /* Constants for +0.5 and -0.5 for float-to-integer rounding.  */\n@@ -169,10 +183,9 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name,\n       Entity_Id standard_long_long_float, Entity_Id standard_exception_type,\n       Int gigi_operating_mode)\n {\n-  bool body_p;\n-  Entity_Id gnat_unit_entity;\n   tree gnu_standard_long_long_float;\n   tree gnu_standard_exception_type;\n+  struct elab_info *info;\n \n   max_gnat_nodes = max_gnat_node;\n   number_names = number_name;\n@@ -226,53 +239,42 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name,\n   if (Exception_Mechanism == GCC_ZCX)\n     gnat_init_gcc_eh ();\n \n-  /* Make the decl for the elaboration procedure.  */\n-  body_p = (Defining_Entity (Unit (gnat_root)),\n-\t    Nkind (Unit (gnat_root)) == N_Package_Body\n-\t    || Nkind (Unit (gnat_root)) == N_Subprogram_Body);\n-  gnat_unit_entity = Defining_Entity (Unit (gnat_root));\n-\n-  gnu_elab_proc_decl\n-    = create_subprog_decl\n-      (create_concat_name (gnat_unit_entity,\n-\t\t\t   body_p ? \"elabb\" : \"elabs\"),\n-       NULL_TREE, void_ftype, NULL_TREE, false, true, false, NULL,\n-       gnat_unit_entity);\n-\n-  DECL_ELABORATION_PROC_P (gnu_elab_proc_decl) = 1;\n-  allocate_struct_function (gnu_elab_proc_decl);\n-  Sloc_to_locus (Sloc (gnat_unit_entity), &cfun->function_end_locus);\n-  cfun = 0;\n-\n-      /* For a body, first process the spec if there is one. */\n-  if (Nkind (Unit (gnat_root)) == N_Package_Body\n-      || (Nkind (Unit (gnat_root)) == N_Subprogram_Body\n-\t      && !Acts_As_Spec (gnat_root)))\n-    add_stmt (gnat_to_gnu (Library_Unit (gnat_root)));\n+  if (Nkind (gnat_root) != N_Compilation_Unit)\n+    abort ();\n \n-  process_inlined_subprograms (gnat_root);\n+  Compilation_Unit_to_gnu (gnat_root);\n \n-  if (type_annotate_only)\n+  /* Now see if we have any elaboration procedures to deal with. */\n+  for (info = elab_info_list; info; info = info->next)\n     {\n-      elaborate_all_entities (gnat_root);\n-\n-\t  if (Nkind (Unit (gnat_root)) == N_Subprogram_Declaration\n-\t      || Nkind (Unit (gnat_root)) == N_Generic_Package_Declaration\n-\t      || Nkind (Unit (gnat_root)) == N_Generic_Subprogram_Declaration)\n-\t    return;\n+      tree gnu_body = DECL_SAVED_TREE (info->elab_proc);\n+      tree gnu_stmts;\n+\n+      /* Mark everything we have as not visited.  */\n+      walk_tree_without_duplicates (&gnu_body, mark_unvisited, NULL);\n+\n+      /* Set the current function to be the elaboration procedure and gimplify\n+\t what we have.  */\n+      current_function_decl = info->elab_proc;\n+      gimplify_body (&gnu_body, info->elab_proc);\n+\n+      /* We should have a BIND_EXPR, but it may or may not have any statements\n+\t in it.  If it doesn't have any, we have nothing to do.  */\n+      gnu_stmts = gnu_body;\n+      if (TREE_CODE (gnu_stmts) == BIND_EXPR)\n+\tgnu_stmts = BIND_EXPR_BODY (gnu_stmts);\n+\n+      /* If there are no statements, there is no elaboration code.  */\n+      if (!gnu_stmts || !STATEMENT_LIST_HEAD (gnu_stmts))\n+\tSet_Has_No_Elaboration_Code (info->gnat_node, 1);\n+      else\n+\t{\n+\t  /* Otherwise, compile the function.  Note that we'll be gimplifying\n+\t     it twice, but that's fine for the nodes we use.  */\n+\t  begin_subprog_body (info->elab_proc);\n+\t  end_subprog_body (gnu_body);\n+\t}\n     }\n-\n-  process_decls (Declarations (Aux_Decls_Node (gnat_root)), Empty, Empty,\n-\t\t true, true);\n-  add_stmt (gnat_to_gnu (Unit (gnat_root)));\n-\n-  /* Process any pragmas and actions following the unit.  */\n-  add_stmt_list (Pragmas_After (Aux_Decls_Node (gnat_root)));\n-  add_stmt_list (Actions (Aux_Decls_Node (gnat_root)));\n-\n-  /* Generate elaboration code for this unit, if necessary, and say whether\n-     we did or not.  */\n-  Set_Has_No_Elaboration_Code (gnat_root, build_unit_elab ());\n }\n \f\n /* Perform initializations for this module.  */\n@@ -284,7 +286,7 @@ gnat_init_stmt_group ()\n   init_code_table ();\n   start_stmt_group ();\n \n-  global_stmt_group = current_stmt_group;\n+  current_stmt_group->global = current_stmt_group;\n \n   /* Enable GNAT stack checking method if needed */\n   if (!Stack_Check_Probes_On_Target)\n@@ -2331,6 +2333,73 @@ Exception_Handler_to_gnu_zcx (Node_Id gnat_node)\n \t\tend_stmt_group ());\n }\n \f\n+/* Subroutine of gnat_to_gnu to generate code for an N_Compilation unit.  */\n+\n+static void\n+Compilation_Unit_to_gnu (Node_Id gnat_node)\n+{\n+  /* Make the decl for the elaboration procedure.  */\n+  bool body_p = (Defining_Entity (Unit (gnat_node)),\n+\t    Nkind (Unit (gnat_node)) == N_Package_Body\n+\t    || Nkind (Unit (gnat_node)) == N_Subprogram_Body);\n+  Entity_Id gnat_unit_entity = Defining_Entity (Unit (gnat_node));\n+  tree gnu_elab_proc_decl\n+    = create_subprog_decl\n+      (create_concat_name (gnat_unit_entity,\n+\t\t\t   body_p ? \"elabb\" : \"elabs\"),\n+       NULL_TREE, void_ftype, NULL_TREE, false, true, false, NULL,\n+       gnat_unit_entity);\n+  struct elab_info *info;\n+\n+  push_stack (&gnu_elab_proc_stack, NULL_TREE, gnu_elab_proc_decl);\n+\n+  DECL_ELABORATION_PROC_P (gnu_elab_proc_decl) = 1;\n+  allocate_struct_function (gnu_elab_proc_decl);\n+  Sloc_to_locus (Sloc (gnat_unit_entity), &cfun->function_end_locus);\n+  cfun = 0;\n+\n+      /* For a body, first process the spec if there is one. */\n+  if (Nkind (Unit (gnat_node)) == N_Package_Body\n+      || (Nkind (Unit (gnat_node)) == N_Subprogram_Body\n+\t      && !Acts_As_Spec (gnat_node)))\n+    add_stmt (gnat_to_gnu (Library_Unit (gnat_node)));\n+\n+  process_inlined_subprograms (gnat_node);\n+\n+  if (type_annotate_only)\n+    {\n+      elaborate_all_entities (gnat_node);\n+\n+      if (Nkind (Unit (gnat_node)) == N_Subprogram_Declaration\n+\t  || Nkind (Unit (gnat_node)) == N_Generic_Package_Declaration\n+\t  || Nkind (Unit (gnat_node)) == N_Generic_Subprogram_Declaration)\n+\treturn;\n+    }\n+\n+  process_decls (Declarations (Aux_Decls_Node (gnat_node)), Empty, Empty,\n+\t\t true, true);\n+  add_stmt (gnat_to_gnu (Unit (gnat_node)));\n+\n+  /* Process any pragmas and actions following the unit.  */\n+  add_stmt_list (Pragmas_After (Aux_Decls_Node (gnat_node)));\n+  add_stmt_list (Actions (Aux_Decls_Node (gnat_node)));\n+\n+  /* Save away what we've made so far and record this potential elaboration\n+     procedure.  */\n+  info = (struct elab_info *) ggc_alloc (sizeof (struct elab_info));\n+  set_current_block_context (gnu_elab_proc_decl);\n+  gnat_poplevel ();\n+  DECL_SAVED_TREE (gnu_elab_proc_decl) = end_stmt_group ();\n+  info->next = elab_info_list;\n+  info->elab_proc = gnu_elab_proc_decl;\n+  info->gnat_node = gnat_node;\n+  elab_info_list = info;\n+\n+  /* Generate elaboration code for this unit, if necessary, and say whether\n+     we did or not.  */\n+  pop_stack (&gnu_elab_proc_stack);\n+}\n+\f\n /* This function is the driver of the GNAT to GCC tree transformation\n    process.  It is the entry point of the tree transformer.  GNAT_NODE is the\n    root of some GNAT tree.  Return the root of the corresponding GCC tree.\n@@ -2382,7 +2451,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t       || Nkind (gnat_node) == N_Raise_Program_Error)\n \t      && (Ekind (Etype (gnat_node)) == E_Void))))\n     {\n-      current_function_decl = gnu_elab_proc_decl;\n+      current_function_decl = TREE_VALUE (gnu_elab_proc_stack);\n       start_stmt_group ();\n       gnat_pushlevel ();\n       went_into_elab_proc = true;\n@@ -3587,24 +3656,11 @@ gnat_to_gnu (Node_Id gnat_node)\n       /* This is not called for the main unit, which is handled in function\n \t gigi above.  */\n       start_stmt_group ();\n+      current_stmt_group->global = current_stmt_group;\n+      gnat_pushlevel ();\n \n-      /* For a body, first process the spec if there is one. */\n-      if (Nkind (Unit (gnat_node)) == N_Package_Body\n-\t  || (Nkind (Unit (gnat_node)) == N_Subprogram_Body\n-\t      && !Acts_As_Spec (gnat_node)))\n-\tadd_stmt (gnat_to_gnu (Library_Unit (gnat_node)));\n-\n-      process_inlined_subprograms (gnat_node);\n-      process_decls (Declarations (Aux_Decls_Node (gnat_node)),\n-\t\t     Empty, Empty, true, true);\n-      add_stmt (gnat_to_gnu (Unit (gnat_node)));\n-\n-      /* Process any pragmas and actions following the unit.  */\n-      add_stmt_list (Pragmas_After (Aux_Decls_Node (gnat_node)));\n-      add_stmt_list (Actions (Aux_Decls_Node (gnat_node)));\n-\n-      Set_Has_No_Elaboration_Code (gnat_node, 1);\n-      gnu_result = end_stmt_group ();\n+      Compilation_Unit_to_gnu (gnat_node);\n+      gnu_result = alloc_stmt_list ();\n       break;\n \n     case N_Subprogram_Body_Stub:\n@@ -4057,6 +4113,7 @@ start_stmt_group ()\n \n   group->previous = current_stmt_group;\n   group->stmt_list = group->block = group->cleanups = NULL_TREE;\n+  group->global = current_stmt_group ? current_stmt_group->global : NULL;\n   current_stmt_group = group;\n }\n \n@@ -4117,7 +4174,7 @@ add_decl_expr (tree gnu_decl, Entity_Id gnat_entity)\n     return;\n \n   if (global_bindings_p ())\n-    current_stmt_group = global_stmt_group;\n+    current_stmt_group = current_stmt_group->global;\n \n   add_stmt_with_node (build (DECL_EXPR, void_type_node, gnu_decl),\n \t\t      gnat_entity);\n@@ -4339,7 +4396,7 @@ gnat_expand_stmt (tree gnu_stmt)\n /* Generate GIMPLE in place for the expression at *EXPR_P.  */\n \n int\n-gnat_gimplify_expr (tree *expr_p, tree *pre_p ATTRIBUTE_UNUSED, tree *post_p)\n+gnat_gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p ATTRIBUTE_UNUSED)\n {\n   tree expr = *expr_p;\n \n@@ -4362,7 +4419,7 @@ gnat_gimplify_expr (tree *expr_p, tree *pre_p ATTRIBUTE_UNUSED, tree *post_p)\n \t  TREE_NO_WARNING (*expr_p) = 1;\n \t}\n \n-      append_to_statement_list (TREE_OPERAND (expr, 0), post_p);\n+      append_to_statement_list (TREE_OPERAND (expr, 0), pre_p);\n       return GS_OK;\n \n     case UNCONSTRAINED_ARRAY_REF:\n@@ -5614,45 +5671,6 @@ gnat_stabilize_reference_1 (tree e, bool force)\n   return result;\n }\n \f\n-/* Take care of building the elaboration procedure for the main unit.\n-\n-   Return true if we didn't need an elaboration function, false otherwise.  */\n-\n-static bool\n-build_unit_elab ()\n-{\n-  tree body, stmts;\n-\n-  /* Mark everything we have as not visited.  */\n-  walk_tree_without_duplicates (&current_stmt_group->stmt_list,\n-\t\t\t\tmark_unvisited, NULL);\n-\n-  /* Set the current function to be the elaboration procedure, pop our\n-     binding level, end our statement group, and gimplify what we have.  */\n-  set_current_block_context (gnu_elab_proc_decl);\n-  gnat_poplevel ();\n-  body = end_stmt_group ();\n-  current_function_decl = gnu_elab_proc_decl;\n-  gimplify_body (&body, gnu_elab_proc_decl);\n-\n-  /* We should have a BIND_EXPR, but it may or may not have any statements\n-     in it.  If it doesn't have any, we have nothing to do.  */\n-  stmts = body;\n-  if (TREE_CODE (stmts) == BIND_EXPR)\n-    stmts = BIND_EXPR_BODY (stmts);\n-\n-  /* If there are no statements, we have nothing to do.  */\n-  if (!stmts || !STATEMENT_LIST_HEAD (stmts))\n-    return true;\n-\n-  /* Otherwise, compile the function.  Note that we'll be gimplifying\n-     it twice, but that's fine for the nodes we use.  */\n-  begin_subprog_body (gnu_elab_proc_decl);\n-  end_subprog_body (body);\n-\n-  return false;\n-}\n-\f\n extern char *__gnat_to_canonical_file_spec (char *);\n \n /* Convert Sloc into *LOCUS (a location_t).  Return true if this Sloc"}, {"sha": "46c5639480b6e1768cb4168ef96d9aef17f186b0", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=5d09245e6a54b290b5f44b686214b41cf555152a", "patch": "@@ -193,8 +193,7 @@ present_gnu_tree (Entity_Id gnat_entity)\n int\n global_bindings_p (void)\n {\n-  return (force_global || !current_binding_level\n-\t  || !current_binding_level->chain ? -1 : 0);\n+  return ((force_global || !current_function_decl) ? -1 : 0);\n }\n \n /* Enter a new binding level. */\n@@ -365,7 +364,7 @@ gnat_pushdecl (tree decl, Node_Id gnat_node)\n     TYPE_NAME (TREE_TYPE (decl)) = decl;\n \n   if (TREE_CODE (decl) != CONST_DECL)\n-    rest_of_decl_compilation (decl, NULL, global_bindings_p (), 0);\n+    rest_of_decl_compilation (decl, global_bindings_p (), 0);\n }\n \f\n /* Do little here.  Set up the standard declarations later after the"}, {"sha": "1682c879142f6960cf0c3e512c7378b8f5fdd473", "filename": "gcc/ada/vms_conv.ads", "status": "modified", "additions": 30, "deletions": 15, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fvms_conv.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fvms_conv.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fvms_conv.ads?ref=5d09245e6a54b290b5f44b686214b41cf555152a", "patch": "@@ -24,11 +24,9 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This package is part of the GNAT driver. It contains a procedure\n---  VMS_Conversion to convert the command line in VMS form to the equivalent\n---  command line with switches for the GNAT tools that the GNAT driver will\n---  invoke.\n---\n+--  This package is part of the GNAT driver. It contains the procedure\n+--  VMS_Conversion to convert a VMS command line to the equivalent command\n+--  line with switches for the GNAT tools that the GNAT driver will invoke.\n --  The qualifier declarations are contained in package VMS_Data.\n \n with Table;\n@@ -61,7 +59,7 @@ package VMS_Conv is\n    --  Set true if /? switch causes display of generated command (on VMS)\n \n    -------------------\n-   -- COMMAND TABLE --\n+   -- Command Table --\n    -------------------\n \n    --  The command table contains an entry for each command recognized by\n@@ -71,10 +69,10 @@ package VMS_Conv is\n    --  A parameter is defined as a whitespace bounded string, not begining\n    --   with a slash. (But see note under FILES_OR_WILDCARD).\n      (File,\n-      --  A required file or directory parameter.\n+      --  A required file or directory parameter\n \n       Optional_File,\n-      --  An optional file or directory parameter.\n+      --  An optional file or directory parameter\n \n       Other_As_Is,\n       --  A parameter that's passed through as is (not canonicalized)\n@@ -96,12 +94,29 @@ package VMS_Conv is\n    type Parameter_Ref is access all Parameter_Array;\n \n    type Command_Type is\n-     (Bind, Chop, Clean, Compile, Elim, Find, Krunch, Library, Link, List,\n-      Make, Metric, Name, Preprocess, Pretty, Setup, Shared, Stub, Xref,\n+     (Bind,\n+      Chop,\n+      Clean,\n+      Compile,\n+      Elim,\n+      Find,\n+      Krunch,\n+      Library,\n+      Link,\n+      List,\n+      Make,\n+      Metric,\n+      Name,\n+      Preprocess,\n+      Pretty,\n+      Setup,\n+      Shared,\n+      Stub,\n+      Xref,\n       Undefined);\n \n    type Alternate_Command is (Comp, Ls, Kr, Pp, Prep);\n-   --  Alternate command libel for non VMS system\n+   --  Alternate command label for non VMS system use\n \n    Corresponding_To : constant array (Alternate_Command) of Command_Type :=\n      (Comp  => Compile,\n@@ -144,7 +159,7 @@ package VMS_Conv is\n    end record;\n \n    -------------------------\n-   -- INTERNAL STRUCTURES --\n+   -- Internal Structures --\n    -------------------------\n \n    --  The switches and commands are defined by strings in the previous\n@@ -271,9 +286,9 @@ package VMS_Conv is\n    subtype Switch_Item  is Item (Id_Switch);\n    subtype Option_Item  is Item (Id_Option);\n \n-   ------------------\n-   -- SWITCH TABLE --\n-   ------------------\n+   -------------------\n+   -- Switch Tables --\n+   -------------------\n \n    --  The switch tables contain an entry for each switch recognized by the\n    --  command processor. It is initialized by procedure Initialize."}, {"sha": "a995edb81ce922af5081c18b5183186512eb1829", "filename": "gcc/ada/xgnatugn.adb", "status": "modified", "additions": 77, "deletions": 49, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fxgnatugn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d09245e6a54b290b5f44b686214b41cf555152a/gcc%2Fada%2Fxgnatugn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fxgnatugn.adb?ref=5d09245e6a54b290b5f44b686214b41cf555152a", "patch": "@@ -86,8 +86,11 @@\n --       output. A line containing this escape sequence may not also contain\n --       a ^alpha^beta^ sequence.\n \n---       Recognize @ifset and @ifclear (this is because we have menu problems\n---       if we let makeinfo handle the ifset/ifclear pairs\n+--       Process @ifset and @ifclear for the target flags (unw, vms);\n+--       this is because we have menu problems if we let makeinfo handle\n+--       these ifset/ifclear pairs.\n+--       Note: @ifset/@ifclear commands for the edition flags (FSFEDITION,\n+--       PROEDITION, ACADEMICEDITION) are passed through unchanged\n \n with Ada.Command_Line;           use Ada.Command_Line;\n with Ada.Strings;                use Ada.Strings;\n@@ -143,7 +146,7 @@ procedure Xgnatugn is\n    procedure Warning\n      (Input        : Input_File;\n       Message      : String);\n-   --  Like Error, but just print a warning message.\n+   --  Like Error, but just print a warning message\n \n    Dictionary_File : aliased Input_File;\n    procedure Read_Dictionary_File;\n@@ -158,11 +161,24 @@ procedure Xgnatugn is\n    --  It contains the Texinfo source code. Process_Source_File\n    --  performs the necessary replacements.\n \n-   type Target_Type is (UNW, VMS);\n+   type Flag_Type is (UNW, VMS, FSFEDITION, PROEDITION, ACADEMICEDITION);\n+   --  The flags permitted in @ifset or @ifclear commands:\n+   --\n+   --  Targets for preprocessing\n+   --    UNW (Unix and Windows) or VMS\n+   --\n+   --  Editions of the manual\n+   --    FSFEDITION, PROEDITION, or ACADEMICEDITION\n+   --\n+   --  Conditional commands for target are processed by xgnatugn\n+   --\n+   --  Conditional commands for edition are passed through unchanged\n+\n+   subtype Target_Type is Flag_Type range UNW .. VMS;\n+   subtype Edition_Type is Flag_Type range FSFEDITION .. ACADEMICEDITION;\n+\n    Target : Target_Type;\n-   --  The target for which preprocessing is performed:\n-   --  UNW (Unix and Windows) or VMS\n-   --  The Target variable is initialized using the command line.\n+   --  The Target variable is initialized using the command line\n \n    Valid_Characters : constant Character_Set\n      := To_Set (Span => (' ',  '~'));\n@@ -191,7 +207,7 @@ procedure Xgnatugn is\n    --  execution terminates with a Fatal_Line_Length exception.\n \n    VMS_Escape_Character : constant Character := '^';\n-   --  The character used to mark VMS alternatives (^alpha^beta^).\n+   --  The character used to mark VMS alternatives (^alpha^beta^)\n \n    Extensions : GNAT.Spitbol.Table_VString.Table (20);\n    procedure Initialize_Extensions;\n@@ -231,7 +247,7 @@ procedure Xgnatugn is\n    --  Target.\n \n    function In_VMS_Section return Boolean;\n-   --  Returns True if in an \"@ifset vms\" section.\n+   --  Returns True if in an \"@ifset vms\" section\n \n    procedure Check_No_Pending_Conditional;\n    --  Checks that all preprocessing directives have been properly matched by\n@@ -244,7 +260,7 @@ procedure Xgnatugn is\n    type Conditional_Context is record\n       Starting_Line : Positive;\n       Cond          : Conditional;\n-      Flag          : Target_Type;\n+      Flag          : Flag_Type;\n       Excluding     : Boolean;\n    end record;\n \n@@ -254,7 +270,7 @@ procedure Xgnatugn is\n      array (1 .. Conditional_Stack_Depth) of Conditional_Context;\n \n    Conditional_TOS : Natural := 0;\n-   --  Pointer to the Top Of Stack for Conditional_Stack.\n+   --  Pointer to the Top Of Stack for Conditional_Stack\n \n    -----------\n    -- Usage --\n@@ -263,7 +279,7 @@ procedure Xgnatugn is\n    procedure Usage is\n    begin\n       Put_Line (Standard_Error,\n-              \"usage: xgnatug TARGET SOURCE DICTIONARY [OUTFILE [WARNINGS]]\");\n+            \"usage: xgnatugn TARGET SOURCE DICTIONARY [OUTFILE [WARNINGS]]\");\n       New_Line;\n       Put_Line (Standard_Error, \"TARGET is one of:\");\n \n@@ -342,8 +358,8 @@ procedure Xgnatugn is\n    -----------\n \n    procedure Error\n-     (Input        : Input_File;\n-      Message      : String)\n+     (Input   : Input_File;\n+      Message : String)\n    is\n    begin\n       Error (Input, 0, Message);\n@@ -586,7 +602,7 @@ procedure Xgnatugn is\n             return;\n          end if;\n \n-         --  ^alpha^beta^, the VMS_Alternative case.\n+         --  ^alpha^beta^, the VMS_Alternative case\n \n          if Remaining_Line (Remaining_Line'First) = VMS_Escape_Character then\n             declare\n@@ -786,8 +802,7 @@ procedure Xgnatugn is\n                        (Line (Token.Span.First .. Token.Span.Last)));\n                Next_Token;\n             else\n-               --  We already have: Word \".\", followed by an unknown\n-               --  token.\n+               --  We already have: Word \".\", followed by an unknown token\n \n                Append (Rewritten_Line, First_Word & '.');\n \n@@ -894,7 +909,7 @@ procedure Xgnatugn is\n       Ifset       : constant String := \"@ifset \";\n       Ifclear     : constant String := \"@ifclear \";\n       Endsetclear : constant String := \"@end \";\n-      --  Strings to be recognized for conditional processing.\n+      --  Strings to be recognized for conditional processing\n \n    begin\n       while not End_Of_File (Source_File.Data) loop\n@@ -910,14 +925,14 @@ procedure Xgnatugn is\n             --  directive.\n \n             Cond : Conditional;\n-            --  The kind of the directive.\n+            --  The kind of the directive\n \n-            Flag : Target_Type;\n-            --  Its flag.\n+            Flag : Flag_Type;\n+            --  Its flag\n \n          begin\n             --  If the line starts with @ifset or @ifclear, we try to convert\n-            --  the following flag to one of our target types. If we fail,\n+            --  the following flag to one of our flag types. If we fail,\n             --  Have_Conditional remains False.\n \n             if Line'Length >= Ifset'Length\n@@ -930,16 +945,21 @@ procedure Xgnatugn is\n                           Trim (Line (Ifset'Length + 1 .. Line'Last), Both);\n \n                begin\n-                  Flag := Target_Type'Value (Arg);\n-\n-                  if Translate (Target_Type'Image (Flag), Lower_Case_Map)\n-                                                                    /= Arg\n-                  then\n-                     Error (Source_File, \"flag has to be lowercase\");\n-                  end if;\n-\n+                  Flag := Flag_Type'Value (Arg);\n                   Have_Conditional := True;\n \n+                  case Flag is\n+                     when Target_Type =>\n+                        if Translate (Target_Type'Image (Flag),\n+                                      Lower_Case_Map)\n+                                                      /= Arg\n+                        then\n+                           Error (Source_File, \"flag has to be lowercase\");\n+                        end if;\n+\n+                     when Edition_Type =>\n+                        null;\n+                  end case;\n                exception\n                   when Constraint_Error =>\n                      Error (Source_File, \"unknown flag for '@ifset'\");\n@@ -955,22 +975,28 @@ procedure Xgnatugn is\n                           Trim (Line (Ifclear'Length + 1 .. Line'Last), Both);\n \n                begin\n-                  Flag := Target_Type'Value (Arg);\n-                  if Translate (Target_Type'Image (Flag), Lower_Case_Map)\n-                                                                     /= Arg\n-                  then\n-                     Error (Source_File, \"flag has to be lowercase\");\n-                  end if;\n-\n+                  Flag := Flag_Type'Value (Arg);\n                   Have_Conditional := True;\n \n+                  case Flag is\n+                     when Target_Type =>\n+                        if Translate (Target_Type'Image (Flag),\n+                                      Lower_Case_Map)\n+                                                      /= Arg\n+                        then\n+                           Error (Source_File, \"flag has to be lowercase\");\n+                        end if;\n+\n+                     when Edition_Type =>\n+                        null;\n+                  end case;\n                exception\n                   when Constraint_Error =>\n                      Error (Source_File, \"unknown flag for '@ifclear'\");\n                end;\n             end if;\n \n-            if Have_Conditional then\n+            if Have_Conditional and (Flag in Target_Type) then\n \n                --  We create a new conditional context and suppress the\n                --  directive in the output.\n@@ -979,6 +1005,7 @@ procedure Xgnatugn is\n \n             elsif Line'Length >= Endsetclear'Length\n               and then Line (1 .. Endsetclear'Length) = Endsetclear\n+              and then (Flag in Target_Type)\n             then\n                --  The '@end ifset'/'@end ifclear' case is handled here. We\n                --  have to pop the conditional context.\n@@ -1016,7 +1043,7 @@ procedure Xgnatugn is\n                end;\n             end if;                     --  Have_Conditional\n \n-            if not Have_Conditional then\n+            if (not Have_Conditional) or (Flag in Edition_Type) then\n \n                --  The ordinary case.\n \n@@ -1252,31 +1279,32 @@ procedure Xgnatugn is\n       end loop;\n    end Check_No_Pending_Conditional;\n \n-   ------------------\n-   -- Main Program --\n-   ------------------\n+--  Start of processing for Xgnatugn\n \n    Valid_Command_Line : Boolean;\n    Output_File_Name   : VString;\n \n begin\n    Initialize_Extensions;\n-\n    Valid_Command_Line := Argument_Count in 3 .. 5;\n \n-   --  First argument: Target.\n+   --  First argument: Target\n \n    if Valid_Command_Line then\n       begin\n-         Target := Target_Type'Value (Argument (1));\n+         Target := Flag_Type'Value (Argument (1));\n+\n+         if Target not in Target_Type then\n+            Valid_Command_Line := False;\n+         end if;\n \n       exception\n          when Constraint_Error =>\n             Valid_Command_Line := False;\n       end;\n    end if;\n \n-   --  Second argument: Source_File.\n+   --  Second argument: Source_File\n \n    if Valid_Command_Line then\n       begin\n@@ -1289,7 +1317,7 @@ begin\n       end;\n    end if;\n \n-   --  Third argument: Dictionary_File.\n+   --  Third argument: Dictionary_File\n \n    if Valid_Command_Line then\n       begin\n@@ -1302,7 +1330,7 @@ begin\n       end;\n    end if;\n \n-   --  Fourth argument: Output_File.\n+   --  Fourth argument: Output_File\n \n    if Valid_Command_Line then\n       if Argument_Count in 4 .. 5 then\n@@ -1335,7 +1363,7 @@ begin\n       Read_Dictionary_File;\n       Close (Dictionary_File.Data);\n \n-      --  Main processing starts here.\n+      --  Main processing starts here\n \n       Process_Source_File;\n       Close (Output_File);"}]}