{"sha": "f161bfd3300fb19ae04a865806612e4f8e7847d7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjE2MWJmZDMzMDBmYjE5YWUwNGE4NjU4MDY2MTJlNGY4ZTc4NDdkNw==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2013-06-28T16:15:17Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2013-06-28T16:15:17Z"}, "message": "re PR target/57744 (Power8 support has problems with quad word atomic instructions)\n\n[gcc]\n2013-06-28  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\tPR target/57744\n\t* config/rs6000/rs6000.h (MODES_TIEABLE_P): Do not allow PTImode\n\tto tie with any other modes.  Eliminate Altivec vector mode tests,\n\tsince these are a subset of ALTIVEC or VSX vector modes.  Simplify\n\tcode, to return 0 if testing MODE2 for a condition, if we've\n\talready tested MODE1 for the same condition.\n\n[gcc/testsuite]\n2013-06-28  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\tPR target/57744\n\t* gcc.target/powerpc/pr57744.c: New test to make sure lqarx and\n\tstqcx. get even registers.\n\nFrom-SVN: r200538", "tree": {"sha": "67dc85a8d10766cb6d86972ba83068da0b058c27", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/67dc85a8d10766cb6d86972ba83068da0b058c27"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f161bfd3300fb19ae04a865806612e4f8e7847d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f161bfd3300fb19ae04a865806612e4f8e7847d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f161bfd3300fb19ae04a865806612e4f8e7847d7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f161bfd3300fb19ae04a865806612e4f8e7847d7/comments", "author": null, "committer": null, "parents": [{"sha": "7d9800e39ad29174231a13405f11e82dd9d430d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d9800e39ad29174231a13405f11e82dd9d430d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d9800e39ad29174231a13405f11e82dd9d430d2"}], "stats": {"total": 76, "additions": 66, "deletions": 10}, "files": [{"sha": "6c86c2597ed261b1724ce7545606fd5d46dec317", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f161bfd3300fb19ae04a865806612e4f8e7847d7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f161bfd3300fb19ae04a865806612e4f8e7847d7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f161bfd3300fb19ae04a865806612e4f8e7847d7", "patch": "@@ -1,3 +1,12 @@\n+2013-06-28  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/57744\n+\t* config/rs6000/rs6000.h (MODES_TIEABLE_P): Do not allow PTImode\n+\tto tie with any other modes.  Eliminate Altivec vector mode tests,\n+\tsince these are a subset of ALTIVEC or VSX vector modes.  Simplify\n+\tcode, to return 0 if testing MODE2 for a condition, if we've\n+\talready tested MODE1 for the same condition.\n+\n 2013-06-28  Marcus Shawcroft  <marcus.shawcroft@arm.com>\n \n \t* config/aarch64/aarch64.c (aarch64_cannot_force_const_mem): Adjust"}, {"sha": "98a44aa32e19f62a3174215c83b9072873659f72", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f161bfd3300fb19ae04a865806612e4f8e7847d7/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f161bfd3300fb19ae04a865806612e4f8e7847d7/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=f161bfd3300fb19ae04a865806612e4f8e7847d7", "patch": "@@ -1180,28 +1180,32 @@ enum data_align { align_abi, align_opt, align_both };\n /* Value is 1 if it is a good idea to tie two pseudo registers\n    when one has mode MODE1 and one has mode MODE2.\n    If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n-   for any hard reg, then this must be 0 for correct output.  */\n+   for any hard reg, then this must be 0 for correct output.\n+\n+   PTImode cannot tie with other modes because PTImode is restricted to even\n+   GPR registers, and TImode can go in any GPR as well as VSX registers (PR\n+   57744).  */\n #define MODES_TIEABLE_P(MODE1, MODE2)\t\t\\\n-  (SCALAR_FLOAT_MODE_P (MODE1)\t\t\t\\\n+  ((MODE1) == PTImode\t\t\t\t\\\n+   ? (MODE2) == PTImode\t\t\t\t\\\n+   : (MODE2) == PTImode\t\t\t\t\\\n+   ? 0\t\t\t\t\t\t\\\n+   : SCALAR_FLOAT_MODE_P (MODE1)\t\t\\\n    ? SCALAR_FLOAT_MODE_P (MODE2)\t\t\\\n    : SCALAR_FLOAT_MODE_P (MODE2)\t\t\\\n-   ? SCALAR_FLOAT_MODE_P (MODE1)\t\t\\\n+   ? 0\t\t\t\t\t\t\\\n    : GET_MODE_CLASS (MODE1) == MODE_CC\t\t\\\n    ? GET_MODE_CLASS (MODE2) == MODE_CC\t\t\\\n    : GET_MODE_CLASS (MODE2) == MODE_CC\t\t\\\n-   ? GET_MODE_CLASS (MODE1) == MODE_CC\t\t\\\n+   ? 0\t\t\t\t\t\t\\\n    : SPE_VECTOR_MODE (MODE1)\t\t\t\\\n    ? SPE_VECTOR_MODE (MODE2)\t\t\t\\\n    : SPE_VECTOR_MODE (MODE2)\t\t\t\\\n-   ? SPE_VECTOR_MODE (MODE1)\t\t\t\\\n+   ? 0\t\t\t\t\t\t\\\n    : ALTIVEC_OR_VSX_VECTOR_MODE (MODE1)\t\t\\\n    ? ALTIVEC_OR_VSX_VECTOR_MODE (MODE2)\t\t\\\n    : ALTIVEC_OR_VSX_VECTOR_MODE (MODE2)\t\t\\\n-   ? ALTIVEC_OR_VSX_VECTOR_MODE (MODE1)\t\t\\\n-   : ALTIVEC_VECTOR_MODE (MODE1)\t\t\\\n-   ? ALTIVEC_VECTOR_MODE (MODE2)\t\t\\\n-   : ALTIVEC_VECTOR_MODE (MODE2)\t\t\\\n-   ? ALTIVEC_VECTOR_MODE (MODE1)\t\t\\\n+   ? 0\t\t\t\t\t\t\\\n    : 1)\n \n /* Post-reload, we can't use any new AltiVec registers, as we already"}, {"sha": "c0b52841023fc84d4f7d8d49e300726b88c81ce9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f161bfd3300fb19ae04a865806612e4f8e7847d7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f161bfd3300fb19ae04a865806612e4f8e7847d7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f161bfd3300fb19ae04a865806612e4f8e7847d7", "patch": "@@ -1,3 +1,9 @@\n+2013-06-28  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/57744\n+\t* gcc.target/powerpc/pr57744.c: New test to make sure lqarx and\n+\tstqcx. get even registers.\n+\n 2013-06-28  Marc Glisse  <marc.glisse@inria.fr>\n \n \tPR c++/57509"}, {"sha": "d1522f7bb13d95653f2e884b096750956404b13a", "filename": "gcc/testsuite/gcc.target/powerpc/pr57744.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f161bfd3300fb19ae04a865806612e4f8e7847d7/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr57744.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f161bfd3300fb19ae04a865806612e4f8e7847d7/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr57744.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr57744.c?ref=f161bfd3300fb19ae04a865806612e4f8e7847d7", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do run { target { powerpc*-*-* && lp64 } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-options \"-mcpu=power8 -O3\" } */\n+\n+typedef unsigned U_16 __attribute__((mode(TI)));\n+\n+extern int libat_compare_exchange_16 (U_16 *, U_16 *, U_16, int, int)\n+  __attribute__((__noinline__));\n+\n+/* PR 57744: lqarx/stqcx needs even/odd register pairs.  The assembler will\n+   complain if the compiler gets an odd/even register pair.  Create a function\n+   which has the 16 byte compare and exchange instructions, but don't actually\n+   execute it, so that we can detect these failures on older machines. */\n+\n+int\n+libat_compare_exchange_16 (U_16 *mptr, U_16 *eptr, U_16 newval,\n+         int smodel, int fmodel __attribute__((unused)))\n+{\n+  if (((smodel) == 0))\n+    return __atomic_compare_exchange_n (mptr, eptr, newval, 0, 0, 0);\n+  else if (((smodel) != 5))\n+    return __atomic_compare_exchange_n (mptr, eptr, newval, 0, 4, 0);\n+  else\n+    return __atomic_compare_exchange_n (mptr, eptr, newval, 0, 5, 0);\n+}\n+\n+U_16 a = 1, b = 1, c = -2;\n+volatile int do_test = 0;\n+\n+int main (void)\n+{\n+  if (do_test && !libat_compare_exchange_16 (&a, &b, c, 0, 0))\n+    aborrt ();\n+\n+  return 0;\n+}"}]}