{"sha": "4bcf68150f3205da124e9ea303444ebbcb22c151", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGJjZjY4MTUwZjMyMDVkYTEyNGU5ZWEzMDM0NDRlYmJjYjIyYzE1MQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-01-21T07:47:43Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-01-21T07:47:43Z"}, "message": "[multiple changes]\n\n2014-01-21  Robert Dewar  <dewar@adacore.com>\n\n\t* gcc-interface/gigi.h: Get Flags array address.\n\t* gcc-interface/trans.c: Acquire Flags array address.\n\t* atree.adb: Add support for Flags array and Flag0,1,2,3.\n\t* atree.ads: Add support for Flags array and Flag0,1,2,3.\n\t* atree.h: Add support for Flags array and Flag0,1,2,3.\n\t* back_end.adb: Pass Flags array address to gigi.\n\n2014-01-21  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch8.adb (Attribute_Renaming): Transfer original attribute\n\treference to generated body so that legality checks on stream\n\tattributes are properly applied. If type is tagged and already\n\tfrozen, insert generated body at the point of the renaming\n\tdeclaration.\n\n2014-01-21  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch12.adb: Code clean up.\n\t* sem_ch8.adb: Minor reformatting\n\nFrom-SVN: r206870", "tree": {"sha": "6a5905648b64368c86fe9569e960384b27f0aa55", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6a5905648b64368c86fe9569e960384b27f0aa55"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4bcf68150f3205da124e9ea303444ebbcb22c151", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bcf68150f3205da124e9ea303444ebbcb22c151", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4bcf68150f3205da124e9ea303444ebbcb22c151", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bcf68150f3205da124e9ea303444ebbcb22c151/comments", "author": null, "committer": null, "parents": [{"sha": "721ee6cf8ed7f7b67a4f90d29c2e92b39b5ddf95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/721ee6cf8ed7f7b67a4f90d29c2e92b39b5ddf95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/721ee6cf8ed7f7b67a4f90d29c2e92b39b5ddf95"}], "stats": {"total": 285, "additions": 248, "deletions": 37}, "files": [{"sha": "1a872b2094e17681bcfedbc93492599fe66b4065", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bcf68150f3205da124e9ea303444ebbcb22c151/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bcf68150f3205da124e9ea303444ebbcb22c151/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=4bcf68150f3205da124e9ea303444ebbcb22c151", "patch": "@@ -1,3 +1,25 @@\n+2014-01-21  Robert Dewar  <dewar@adacore.com>\n+\n+\t* gcc-interface/gigi.h: Get Flags array address.\n+\t* gcc-interface/trans.c: Acquire Flags array address.\n+\t* atree.adb: Add support for Flags array and Flag0,1,2,3.\n+\t* atree.ads: Add support for Flags array and Flag0,1,2,3.\n+\t* atree.h: Add support for Flags array and Flag0,1,2,3.\n+\t* back_end.adb: Pass Flags array address to gigi.\n+\n+2014-01-21  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch8.adb (Attribute_Renaming): Transfer original attribute\n+\treference to generated body so that legality checks on stream\n+\tattributes are properly applied. If type is tagged and already\n+\tfrozen, insert generated body at the point of the renaming\n+\tdeclaration.\n+\n+2014-01-21  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch12.adb: Code clean up.\n+\t* sem_ch8.adb: Minor reformatting\n+\n 2014-01-20  Robert Dewar  <dewar@adacore.com>\n \n \t* checks.adb: Check SPARK_Mode instead of GNATProve_Mode for"}, {"sha": "ee53b977afae1a7a72da12ff7d6d7dd3debce735", "filename": "gcc/ada/atree.adb", "status": "modified", "additions": 82, "deletions": 1, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bcf68150f3205da124e9ea303444ebbcb22c151/gcc%2Fada%2Fatree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bcf68150f3205da124e9ea303444ebbcb22c151/gcc%2Fada%2Fatree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.adb?ref=4bcf68150f3205da124e9ea303444ebbcb22c151", "patch": "@@ -568,14 +568,17 @@ package body Atree is\n         and then Src = Nodes.Last\n       then\n          New_Id := Src;\n+\n       else\n          --  We are allocating a new node, or extending a node\n          --  other than Nodes.Last.\n \n          if Present (Src) then\n             Nodes.Append (Nodes.Table (Src));\n+            Flags.Append (Flags.Table (Src));\n          else\n             Nodes.Append (Default_Node);\n+            Flags.Append (Default_Flags);\n          end if;\n \n          New_Id := Nodes.Last;\n@@ -596,10 +599,12 @@ package body Atree is\n          if Present (Src) and then Has_Extension (Src) then\n             for J in 1 .. Num_Extension_Nodes loop\n                Nodes.Append (Nodes.Table (Src + Node_Id (J)));\n+               Flags.Append (Flags.Table (Src + Node_Id (J)));\n             end loop;\n          else\n             for J in 1 .. Num_Extension_Nodes loop\n                Nodes.Append (Default_Node_Extension);\n+               Flags.Append (Default_Flags);\n             end loop;\n          end if;\n       end if;\n@@ -680,6 +685,8 @@ package body Atree is\n       Nodes.Table (N).Nkind             := New_Node_Kind;\n       Nodes.Table (N).Error_Posted      := Save_Posted;\n \n+      Flags.Table (N) := Default_Flags;\n+\n       if New_Node_Kind in N_Subexpr then\n          Set_Paren_Count (N, Par_Count);\n       end if;\n@@ -718,14 +725,17 @@ package body Atree is\n       Nodes.Table (Destination).In_List := Save_In_List;\n       Nodes.Table (Destination).Link    := Save_Link;\n \n+      Flags.Table (Destination) := Flags.Table (Source);\n+\n       --  Specifically set Paren_Count to make sure auxiliary table entry\n       --  gets correctly made if the parentheses count is at the max value.\n \n       if Nkind (Destination) in N_Subexpr then\n          Set_Paren_Count (Destination, Paren_Count (Source));\n       end if;\n \n-      --  Deal with copying extension nodes if present\n+      --  Deal with copying extension nodes if present. No need to copy flags\n+      --  table entries, since they are always zero for extending components.\n \n       if Has_Extension (Source) then\n          pragma Assert (Has_Extension (Destination));\n@@ -1094,6 +1104,7 @@ package body Atree is\n \n    procedure Exchange_Entities (E1 : Entity_Id; E2 : Entity_Id) is\n       Temp_Ent : Node_Record;\n+      Temp_Flg : Flags_Byte;\n \n    begin\n       pragma Assert (Has_Extension (E1)\n@@ -1127,6 +1138,13 @@ package body Atree is\n       Nodes.Table (E1 + 5) := Nodes.Table (E2 + 5);\n       Nodes.Table (E2 + 5) := Temp_Ent;\n \n+      --  Exchange flag bytes for first component. No need to do the exchange\n+      --  for the other components, since the flag bytes are always zero.\n+\n+      Temp_Flg := Flags.Table (E1);\n+      Flags.Table (E1) := Flags.Table (E2);\n+      Flags.Table (E2) := Temp_Flg;\n+\n       --  That exchange exchanged the parent pointers as well, which is what\n       --  we want, but we need to patch up the defining identifier pointers\n       --  in the parent nodes (the child pointers) to match this switch\n@@ -1231,6 +1249,15 @@ package body Atree is\n       Fix_Parent (Field5 (Fix_Node));\n    end Fix_Parents;\n \n+   -------------------\n+   -- Flags_Address --\n+   -------------------\n+\n+   function Flags_Address return System.Address is\n+   begin\n+      return Flags.Table (First_Node_Id)'Address;\n+   end Flags_Address;\n+\n    -----------------------------------\n    -- Get_Comes_From_Source_Default --\n    -----------------------------------\n@@ -1270,6 +1297,7 @@ package body Atree is\n    begin\n       Node_Count := 0;\n       Atree_Private_Part.Nodes.Init;\n+      Atree_Private_Part.Flags.Init;\n       Orig_Nodes.Init;\n       Paren_Counts.Init;\n \n@@ -1320,8 +1348,10 @@ package body Atree is\n    procedure Lock is\n    begin\n       Nodes.Locked := True;\n+      Flags.Locked := True;\n       Orig_Nodes.Locked := True;\n       Nodes.Release;\n+      Flags.Release;\n       Orig_Nodes.Release;\n    end Lock;\n \n@@ -2157,6 +2187,7 @@ package body Atree is\n    begin\n       Tree_Read_Int (Node_Count);\n       Nodes.Tree_Read;\n+      Flags.Tree_Read;\n       Orig_Nodes.Tree_Read;\n       Paren_Counts.Tree_Read;\n    end Tree_Read;\n@@ -2169,6 +2200,7 @@ package body Atree is\n    begin\n       Tree_Write_Int (Node_Count);\n       Nodes.Tree_Write;\n+      Flags.Tree_Write;\n       Orig_Nodes.Tree_Write;\n       Paren_Counts.Tree_Write;\n    end Tree_Write;\n@@ -3006,6 +3038,30 @@ package body Atree is\n          return From_Union (Nodes.Table (N + 3).Field8);\n       end Ureal21;\n \n+      function Flag0 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (N <= Nodes.Last);\n+         return Flags.Table (N).Flag0;\n+      end Flag0;\n+\n+      function Flag1 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (N <= Nodes.Last);\n+         return Flags.Table (N).Flag1;\n+      end Flag1;\n+\n+      function Flag2 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (N <= Nodes.Last);\n+         return Flags.Table (N).Flag2;\n+      end Flag2;\n+\n+      function Flag3 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (N <= Nodes.Last);\n+         return Flags.Table (N).Flag3;\n+      end Flag3;\n+\n       function Flag4 (N : Node_Id) return Boolean is\n       begin\n          pragma Assert (N <= Nodes.Last);\n@@ -5563,6 +5619,30 @@ package body Atree is\n          Nodes.Table (N + 3).Field8 := To_Union (Val);\n       end Set_Ureal21;\n \n+      procedure Set_Flag0 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (N <= Nodes.Last);\n+         Flags.Table (N).Flag0 := Val;\n+      end Set_Flag0;\n+\n+      procedure Set_Flag1 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (N <= Nodes.Last);\n+         Flags.Table (N).Flag1 := Val;\n+      end Set_Flag1;\n+\n+      procedure Set_Flag2 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (N <= Nodes.Last);\n+         Flags.Table (N).Flag2 := Val;\n+      end Set_Flag2;\n+\n+      procedure Set_Flag3 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (N <= Nodes.Last);\n+         Flags.Table (N).Flag3 := Val;\n+      end Set_Flag3;\n+\n       procedure Set_Flag4 (N : Node_Id; Val : Boolean) is\n       begin\n          pragma Assert (N <= Nodes.Last);\n@@ -7924,6 +8004,7 @@ package body Atree is\n    procedure Unlock is\n    begin\n       Nodes.Locked := False;\n+      Flags.Locked := False;\n       Orig_Nodes.Locked := False;\n    end Unlock;\n "}, {"sha": "0896e423a29f869b347eacd15e508742556ef61d", "filename": "gcc/ada/atree.ads", "status": "modified", "additions": 78, "deletions": 15, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bcf68150f3205da124e9ea303444ebbcb22c151/gcc%2Fada%2Fatree.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bcf68150f3205da124e9ea303444ebbcb22c151/gcc%2Fada%2Fatree.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.ads?ref=4bcf68150f3205da124e9ea303444ebbcb22c151", "patch": "@@ -168,16 +168,20 @@ package Atree is\n    --   it is useful to be able to do untyped traversals, and an internal\n    --   package in Atree allows for direct untyped accesses in such cases.\n \n-   --   Flag4         Fifteen Boolean flags (use depends on Nkind and\n-   --   Flag5         Ekind, as described for FieldN). Again the access\n-   --   Flag6         is usually via subprograms in Sinfo and Einfo which\n-   --   Flag7         provide high-level synonyms for these flags, and\n-   --   Flag8         contain debugging code that checks that the values\n-   --   Flag9         in Nkind and Ekind are appropriate for the access.\n+   --   Flag0         Nineteen Boolean flags (use depends on Nkind and\n+   --   Flag1         Ekind, as described for FieldN). Again the access\n+   --   Flag2         is usually via subprograms in Sinfo and Einfo which\n+   --   Flag3         provide high-level synonyms for these flags, and\n+   --   Flag4         contain debugging code that checks that the values\n+   --   Flag5         in Nkind and Ekind are appropriate for the access.\n+   --   Flag6\n+   --   Flag7\n+   --   Flag8\n+   --   Flag9\n    --   Flag10\n-   --   Flag11        Note that Flag1-3 are missing from this list. For\n-   --   Flag12        historical reasons, these flag names are unused.\n-   --   Flag13\n+   --   Flag11        Note that Flag0-3 are stored separately in the Flags\n+   --   Flag12        table, but that's a detail of the implementation which\n+   --   Flag13        is entirely hidden by the funcitonal interface.\n    --   Flag14\n    --   Flag15\n    --   Flag16\n@@ -220,6 +224,9 @@ package Atree is\n    function Nodes_Address return System.Address;\n    --  Return address of Nodes table (used in Back_End for Gigi call)\n \n+   function Flags_Address return System.Address;\n+   --  Return address of Flags table (used in Back_End for Gigi call)\n+\n    function Num_Nodes return Nat;\n    --  Total number of nodes allocated, where an entity counts as a single\n    --  node. This count is incremented every time a node or entity is\n@@ -350,7 +357,7 @@ package Atree is\n    -------------------------------------\n \n    --  A subpackage Atree.Unchecked_Access provides routines for reading and\n-   --  writing the fields defined above (Field1-35, Node1-35, Flag4-317 etc).\n+   --  writing the fields defined above (Field1-35, Node1-35, Flag0-317 etc).\n    --  These unchecked access routines can be used for untyped traversals.\n    --  In addition they are used in the implementations of the Sinfo and\n    --  Einfo packages. These packages both provide logical synonyms for\n@@ -1341,6 +1348,18 @@ package Atree is\n       function Ureal21 (N : Node_Id) return Ureal;\n       pragma Inline (Ureal21);\n \n+      function Flag0 (N : Node_Id) return Boolean;\n+      pragma Inline (Flag0);\n+\n+      function Flag1 (N : Node_Id) return Boolean;\n+      pragma Inline (Flag1);\n+\n+      function Flag2 (N : Node_Id) return Boolean;\n+      pragma Inline (Flag2);\n+\n+      function Flag3 (N : Node_Id) return Boolean;\n+      pragma Inline (Flag3);\n+\n       function Flag4 (N : Node_Id) return Boolean;\n       pragma Inline (Flag4);\n \n@@ -2624,6 +2643,18 @@ package Atree is\n       procedure Set_Ureal21 (N : Node_Id; Val : Ureal);\n       pragma Inline (Set_Ureal21);\n \n+      procedure Set_Flag0 (N : Node_Id; Val : Boolean);\n+      pragma Inline (Set_Flag0);\n+\n+      procedure Set_Flag1 (N : Node_Id; Val : Boolean);\n+      pragma Inline (Set_Flag1);\n+\n+      procedure Set_Flag2 (N : Node_Id; Val : Boolean);\n+      pragma Inline (Set_Flag2);\n+\n+      procedure Set_Flag3 (N : Node_Id; Val : Boolean);\n+      pragma Inline (Set_Flag3);\n+\n       procedure Set_Flag4 (N : Node_Id; Val : Boolean);\n       pragma Inline (Set_Flag4);\n \n@@ -3621,12 +3652,12 @@ package Atree is\n       -------------------------\n \n       --  The nodes of the tree are stored in a table (i.e. an array). In the\n-      --  case of extended nodes five consecutive components in the array are\n+      --  case of extended nodes six consecutive components in the array are\n       --  used. There are thus two formats for array components. One is used\n       --  for non-extended nodes, and for the first component of extended\n       --  nodes. The other is used for the extension parts (second, third,\n-      --  fourth and fifth components) of an extended node. A variant record\n-      --  structure is used to distinguish the two formats.\n+      --  fourth, fifth, and sixth components) of an extended node. A variant\n+      --  record structure is used to distinguish the two formats.\n \n       type Node_Record (Is_Extension : Boolean := False) is record\n \n@@ -3680,7 +3711,8 @@ package Atree is\n          Flag16 : Boolean;\n          Flag17 : Boolean;\n          Flag18 : Boolean;\n-         --  The eighteen flags for a normal node\n+         --  Flags 4-18 for a normal node. Note that Flags 0-3 are stored\n+         --  separately in the Flags array.\n \n          --  The above fields are used as follows in components 2-6 of\n          --  an extended node entry.\n@@ -3888,7 +3920,7 @@ package Atree is\n          Field12           => Empty_List_Or_Node);\n \n       --  The following defines the extendable array used for the nodes table\n-      --  Nodes with extensions use five consecutive entries in the array\n+      --  Nodes with extensions use six consecutive entries in the array\n \n       package Nodes is new Table.Table (\n         Table_Component_Type => Node_Record,\n@@ -3898,6 +3930,37 @@ package Atree is\n         Table_Increment      => Alloc.Nodes_Increment,\n         Table_Name           => \"Nodes\");\n \n+      --  The following is a parallel table to Nodes, which provides 8 more\n+      --  bits of space that logically belong to the corresponding node. This\n+      --  is currently used to implement Flags 0,1,2,3 for normal nodes, or\n+      --  the first component of an extended node (four bits unused). Entries\n+      --  for extending components are completely unused.\n+\n+      type Flags_Byte is record\n+         Flag0  : Boolean;\n+         Flag1  : Boolean;\n+         Flag2  : Boolean;\n+         Flag3  : Boolean;\n+         Spare0 : Boolean;\n+         Spare1 : Boolean;\n+         Spare2 : Boolean;\n+         Spare3 : Boolean;\n+      end record;\n+\n+      for Flags_Byte'Size use 8;\n+      pragma Pack (Flags_Byte);\n+\n+      Default_Flags : constant Flags_Byte := (others => False);\n+      --  Default value used to initialize new entries\n+\n+      package Flags is new Table.Table (\n+        Table_Component_Type => Flags_Byte,\n+        Table_Index_Type     => Node_Id'Base,\n+        Table_Low_Bound      => First_Node_Id,\n+        Table_Initial        => Alloc.Nodes_Initial,\n+        Table_Increment      => Alloc.Nodes_Increment,\n+        Table_Name           => \"Flags\");\n+\n    end Atree_Private_Part;\n \n end Atree;"}, {"sha": "f3913852e12afda295edb261cbba032beb4fb3b2", "filename": "gcc/ada/atree.h", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bcf68150f3205da124e9ea303444ebbcb22c151/gcc%2Fada%2Fatree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bcf68150f3205da124e9ea303444ebbcb22c151/gcc%2Fada%2Fatree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.h?ref=4bcf68150f3205da124e9ea303444ebbcb22c151", "patch": "@@ -359,6 +359,21 @@ extern struct Node *Nodes_Ptr;\n #define Parent atree__parent\n extern Node_Id Parent (Node_Id);\n \n+/* The auxiliary flags array which is allocated in parallel to Nodes */\n+\n+struct Flags\n+{\n+    Boolean      Flag0  : 1;\n+    Boolean      Flag1  : 1;\n+    Boolean      Flag2  : 1;\n+    Boolean      Flag3  : 1;\n+    Boolean      Spare0 : 1;\n+    Boolean      Spare1 : 1;\n+    Boolean      Spare2 : 1;\n+    Boolean      Spare3 : 1;\n+};\n+extern struct Flags *Flags_Ptr;\n+\n /* Overloaded Functions:\n \n    These functions are overloaded in the original Ada source, but there is\n@@ -531,6 +546,11 @@ extern Node_Id Current_Error_Node;\n #define Convention(N) \\\n     (Nodes_Ptr[(N) - First_Node_Id + 2].V.EX.U.fw.convention)\n \n+#define Flag0(N)      (Flags_Ptr[(N) - First_Node_Id].Flag0)\n+#define Flag1(N)      (Flags_Ptr[(N) - First_Node_Id].Flag1)\n+#define Flag2(N)      (Flags_Ptr[(N) - First_Node_Id].Flag2)\n+#define Flag3(N)      (Flags_Ptr[(N) - First_Node_Id].Flag3)\n+\n #define Flag4(N)      (Nodes_Ptr[(N) - First_Node_Id].U.K.flag4)\n #define Flag5(N)      (Nodes_Ptr[(N) - First_Node_Id].U.K.flag5)\n #define Flag6(N)      (Nodes_Ptr[(N) - First_Node_Id].U.K.flag6)"}, {"sha": "6488da1e4687cf9d2456250e574f1b3d55b1c314", "filename": "gcc/ada/back_end.adb", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bcf68150f3205da124e9ea303444ebbcb22c151/gcc%2Fada%2Fback_end.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bcf68150f3205da124e9ea303444ebbcb22c151/gcc%2Fada%2Fback_end.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fback_end.adb?ref=4bcf68150f3205da124e9ea303444ebbcb22c151", "patch": "@@ -87,6 +87,7 @@ package body Back_End is\n          max_gnat_node                 : Int;\n          number_name                   : Nat;\n          nodes_ptr                     : Address;\n+         flags_ptr                     : Address;\n \n          next_node_ptr                 : Address;\n          prev_node_ptr                 : Address;\n@@ -141,6 +142,7 @@ package body Back_End is\n          max_gnat_node      => Int (Last_Node_Id - First_Node_Id + 1),\n          number_name        => Name_Entries_Count,\n          nodes_ptr          => Nodes_Address,\n+         flags_ptr          => Flags_Address,\n \n          next_node_ptr      => Next_Node_Address,\n          prev_node_ptr      => Prev_Node_Address,"}, {"sha": "cf75bd62040e9be5a1e00f77e4e1bd95e6b06162", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bcf68150f3205da124e9ea303444ebbcb22c151/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bcf68150f3205da124e9ea303444ebbcb22c151/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=4bcf68150f3205da124e9ea303444ebbcb22c151", "patch": "@@ -238,10 +238,14 @@ extern \"C\" {\n \n /* This is the main program of the back-end.  It sets up all the table\n    structures and then generates code.  */\n-extern void gigi (Node_Id gnat_root, int max_gnat_node,\n+extern void gigi (Node_Id gnat_root,\n+\t          int max_gnat_node,\n                   int number_name ATTRIBUTE_UNUSED,\n-                  struct Node *nodes_ptr, Node_Id *next_node_ptr,\n-                  Node_Id *prev_node_ptr, struct Elist_Header *elists_ptr,\n+\t\t  struct Node *nodes_ptr,\n+\t\t  struct Flags *Flags_Ptr,\n+\t\t  Node_Id *next_node_ptr,\n+\t\t  Node_Id *prev_node_ptr,\n+\t\t  struct Elist_Header *elists_ptr,\n                   struct Elmt_Item *elmts_ptr,\n                   struct String_Entry *strings_ptr,\n                   Char_Code *strings_chars_ptr,"}, {"sha": "b0cbedb78f09d3f4692063df4b4438d8a0028402", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bcf68150f3205da124e9ea303444ebbcb22c151/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bcf68150f3205da124e9ea303444ebbcb22c151/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=4bcf68150f3205da124e9ea303444ebbcb22c151", "patch": "@@ -90,6 +90,7 @@ static location_t block_end_locus_sink;\n \n /* Pointers to front-end tables accessed through macros.  */\n struct Node *Nodes_Ptr;\n+struct Flags *Flags_Ptr;\n Node_Id *Next_Node_Ptr;\n Node_Id *Prev_Node_Ptr;\n struct Elist_Header *Elists_Ptr;\n@@ -273,15 +274,26 @@ static const char *decode_name (const char *) ATTRIBUTE_UNUSED;\n    structures and then generates code.  */\n \n void\n-gigi (Node_Id gnat_root, int max_gnat_node, int number_name ATTRIBUTE_UNUSED,\n-      struct Node *nodes_ptr, Node_Id *next_node_ptr, Node_Id *prev_node_ptr,\n-      struct Elist_Header *elists_ptr, struct Elmt_Item *elmts_ptr,\n-      struct String_Entry *strings_ptr, Char_Code *string_chars_ptr,\n-      struct List_Header *list_headers_ptr, Nat number_file,\n+gigi (Node_Id gnat_root,\n+      int max_gnat_node,\n+      int number_name ATTRIBUTE_UNUSED,\n+      struct Node *nodes_ptr,\n+      struct Flags *flags_ptr,\n+      Node_Id *next_node_ptr,\n+      Node_Id *prev_node_ptr,\n+      struct Elist_Header *elists_ptr,\n+      struct Elmt_Item *elmts_ptr,\n+      struct String_Entry *strings_ptr,\n+      Char_Code *string_chars_ptr,\n+      struct List_Header *list_headers_ptr,\n+      Nat number_file,\n       struct File_Info_Type *file_info_ptr,\n-      Entity_Id standard_boolean, Entity_Id standard_integer,\n-      Entity_Id standard_character, Entity_Id standard_long_long_float,\n-      Entity_Id standard_exception_type, Int gigi_operating_mode)\n+      Entity_Id standard_boolean,\n+      Entity_Id standard_integer,\n+      Entity_Id standard_character,\n+      Entity_Id standard_long_long_float,\n+      Entity_Id standard_exception_type,\n+      Int gigi_operating_mode)\n {\n   Node_Id gnat_iter;\n   Entity_Id gnat_literal;\n@@ -293,6 +305,7 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name ATTRIBUTE_UNUSED,\n   max_gnat_nodes = max_gnat_node;\n \n   Nodes_Ptr = nodes_ptr;\n+  Flags_Ptr = flags_ptr;\n   Next_Node_Ptr = next_node_ptr;\n   Prev_Node_Ptr = prev_node_ptr;\n   Elists_Ptr = elists_ptr;"}, {"sha": "d90d58c7b30f6df1871800aeac94df185d0e27c1", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bcf68150f3205da124e9ea303444ebbcb22c151/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bcf68150f3205da124e9ea303444ebbcb22c151/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=4bcf68150f3205da124e9ea303444ebbcb22c151", "patch": "@@ -13060,10 +13060,12 @@ package body Sem_Ch12 is\n                --  package, which is necessary semantically but complicates\n                --  ASIS tree traversal, so we recover the original entity to\n                --  expose the renaming. Take into account that the context may\n-               --  be a nested generic and that the original node may itself\n-               --  have an associated node that had better be an entity.\n+               --  be a nested generic, that the original node may itself have\n+               --  an associated node that had better be an entity, and that\n+               --  the current node is still a selected component.\n \n                if Ekind (E) = E_Package\n+                 and then Nkind (N) = N_Selected_Component\n                  and then Nkind (Parent (N)) = N_Expanded_Name\n                  and then Present (Original_Node (N2))\n                  and then Is_Entity_Name (Original_Node (N2))"}, {"sha": "792b85ffab275d96a73b1f4a0bc44c031cdce2e9", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bcf68150f3205da124e9ea303444ebbcb22c151/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bcf68150f3205da124e9ea303444ebbcb22c151/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=4bcf68150f3205da124e9ea303444ebbcb22c151", "patch": "@@ -3437,13 +3437,12 @@ package body Sem_Ch8 is\n       --  a list of expressions corresponding to the subprogram formals.\n       --  A renaming declaration is not a freeze point, and the analysis of\n       --  the attribute reference should not freeze the type of the prefix.\n+      --  We use the original node in the renaming so that its source location\n+      --  is preserved, and checks on stream attributes are properly applied.\n \n       else\n-         Attr_Node :=\n-           Make_Attribute_Reference (Loc,\n-             Prefix         => Prefix (Nam),\n-             Attribute_Name => Aname,\n-             Expressions    => Expr_List);\n+         Attr_Node := Relocate_Node (Nam);\n+         Set_Expressions (Attr_Node, Expr_List);\n \n          Set_Must_Not_Freeze (Attr_Node);\n          Set_Must_Not_Freeze (Prefix (Nam));\n@@ -3459,8 +3458,8 @@ package body Sem_Ch8 is\n \n          Find_Type (Result_Definition (Spec));\n          Rewrite (Result_Definition (Spec),\n-             New_Reference_To (\n-               Base_Type (Entity (Result_Definition (Spec))), Loc));\n+           New_Reference_To\n+             (Base_Type (Entity (Result_Definition (Spec))), Loc));\n \n          Body_Node :=\n            Make_Subprogram_Body (Loc,\n@@ -3522,7 +3521,12 @@ package body Sem_Ch8 is\n                Find_Type (P);\n             end if;\n \n-            if Is_Tagged_Type (Etype (P)) then\n+            --  If the target type is not yet frozen, add the body to the\n+            --  actions to be elaborated at freeze time.\n+\n+            if Is_Tagged_Type (Etype (P))\n+              and then In_Open_Scopes (Scope (Etype (P)))\n+            then\n                Ensure_Freeze_Node (Etype (P));\n                Append_Freeze_Action (Etype (P), Body_Node);\n             else"}]}