{"sha": "f60c15f5099349ccc04a697e4d37154c371253a3", "node_id": "C_kwDOANBUbNoAKGY2MGMxNWY1MDk5MzQ5Y2NjMDRhNjk3ZTRkMzcxNTRjMzcxMjUzYTM", "commit": {"author": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2023-02-15T15:53:41Z"}, "committer": {"name": "CohenArthur", "email": "arthur.cohen@embecosm.com", "date": "2023-02-23T13:54:18Z"}, "message": "parser: Add parsing of auto traits\n\nThis adds enough handling to start parsing `auto` traits but not handle\nthem in the AST, lowering phase or HIR yet.\n\nThe feature is named `optin_builtin_traits` in Rust 1.49 but changes to\n`auto_traits` later down the line. So we'll need to take care of this later\non.\n\nFinally, this also changes the way the lexer detects if a string is a\nkeyword or not. We relied on a call to `std::lower_bound` to figure\nout if a string was contained in an array or not, and this ended up\ncausing issues when adding new keywords. We can instead switch to a\nsimple hashmap and search for the key. The code *might* be less\noptimized (unsure) but it is definitely simpler and easier to read.\n\nFixes #1814\n\ngcc/rust/ChangeLog:\n\n\t* ast/rust-item.h (class Trait): Add `has_auto` field.\n\t* checks/errors/rust-feature.cc: Add handling for `feature(optin_builtin_traits)`\n\t* checks/errors/rust-feature.h: Likewise.\n\t* lex/rust-lex.cc: Fix keyword classification using hashmap.\n\t* lex/rust-token.h: Add `auto` keyword token.\n\t* parse/rust-parse-impl.h (Parser::parse_vis_item): Parse auto traits\n\ton `auto` keyword.\n\ngcc/testsuite/ChangeLog:\n\n\t* rust/compile/auto_trait_invalid.rs: New test.\n\t* rust/compile/auto_trait_valid.rs: New test.", "tree": {"sha": "7453ed1d10bce6cb8238198b3af61ceedd28ac16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7453ed1d10bce6cb8238198b3af61ceedd28ac16"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f60c15f5099349ccc04a697e4d37154c371253a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f60c15f5099349ccc04a697e4d37154c371253a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f60c15f5099349ccc04a697e4d37154c371253a3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f60c15f5099349ccc04a697e4d37154c371253a3/comments", "author": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "918851ad2c965cef63dd0cb0be01f80a80d6c9c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/918851ad2c965cef63dd0cb0be01f80a80d6c9c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/918851ad2c965cef63dd0cb0be01f80a80d6c9c7"}], "stats": {"total": 107, "additions": 78, "deletions": 29}, "files": [{"sha": "f66a8c54032918d42a0910d348ba698fb0ccc420", "filename": "gcc/rust/ast/rust-item.h", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f60c15f5099349ccc04a697e4d37154c371253a3/gcc%2Frust%2Fast%2Frust-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f60c15f5099349ccc04a697e4d37154c371253a3/gcc%2Frust%2Fast%2Frust-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-item.h?ref=f60c15f5099349ccc04a697e4d37154c371253a3", "patch": "@@ -3399,6 +3399,7 @@ class TraitItemType : public TraitItem\n class Trait : public VisItem\n {\n   bool has_unsafe;\n+  bool has_auto;\n   Identifier name;\n   std::vector<std::unique_ptr<GenericParam>> generic_params;\n   std::vector<std::unique_ptr<TypeParamBound>> type_param_bounds;\n@@ -3428,17 +3429,18 @@ class Trait : public VisItem\n   Identifier get_identifier () const { return name; }\n \n   bool is_unsafe () const { return has_unsafe; }\n+  bool is_auto () const { return has_auto; }\n \n   // Mega-constructor\n-  Trait (Identifier name, bool is_unsafe,\n+  Trait (Identifier name, bool is_unsafe, bool is_auto,\n \t std::vector<std::unique_ptr<GenericParam>> generic_params,\n \t std::vector<std::unique_ptr<TypeParamBound>> type_param_bounds,\n \t WhereClause where_clause,\n \t std::vector<std::unique_ptr<TraitItem>> trait_items, Visibility vis,\n \t std::vector<Attribute> outer_attrs, std::vector<Attribute> inner_attrs,\n \t Location locus)\n     : VisItem (std::move (vis), std::move (outer_attrs)),\n-      has_unsafe (is_unsafe), name (std::move (name)),\n+      has_unsafe (is_unsafe), has_auto (is_auto), name (std::move (name)),\n       generic_params (std::move (generic_params)),\n       type_param_bounds (std::move (type_param_bounds)),\n       where_clause (std::move (where_clause)),\n@@ -3448,9 +3450,9 @@ class Trait : public VisItem\n \n   // Copy constructor with vector clone\n   Trait (Trait const &other)\n-    : VisItem (other), has_unsafe (other.has_unsafe), name (other.name),\n-      where_clause (other.where_clause), inner_attrs (other.inner_attrs),\n-      locus (other.locus)\n+    : VisItem (other), has_unsafe (other.has_unsafe), has_auto (other.has_auto),\n+      name (other.name), where_clause (other.where_clause),\n+      inner_attrs (other.inner_attrs), locus (other.locus)\n   {\n     generic_params.reserve (other.generic_params.size ());\n     for (const auto &e : other.generic_params)\n@@ -3471,6 +3473,7 @@ class Trait : public VisItem\n     VisItem::operator= (other);\n     name = other.name;\n     has_unsafe = other.has_unsafe;\n+    has_auto = other.has_auto;\n     where_clause = other.where_clause;\n     inner_attrs = other.inner_attrs;\n     locus = other.locus;"}, {"sha": "ceae2aaddec9e27418da531ef5a42d40c34e985d", "filename": "gcc/rust/checks/errors/rust-feature.cc", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f60c15f5099349ccc04a697e4d37154c371253a3/gcc%2Frust%2Fchecks%2Ferrors%2Frust-feature.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f60c15f5099349ccc04a697e4d37154c371253a3/gcc%2Frust%2Fchecks%2Ferrors%2Frust-feature.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fchecks%2Ferrors%2Frust-feature.cc?ref=f60c15f5099349ccc04a697e4d37154c371253a3", "patch": "@@ -53,7 +53,10 @@ const std::map<std::string, Feature::Name> Feature::name_hash_map = {\n   {\"intrinsics\", Feature::Name::INTRINSICS},\n   {\"rustc_attrs\", Feature::Name::RUSTC_ATTRS},\n   {\"decl_macro\", Feature::Name::DECL_MACRO},\n-};\n+  // TODO: Rename to \"auto_traits\" when supporting\n+  // later Rust versions\n+  {\"optin_builtin_traits\", Feature::Name::AUTO_TRAITS},\n+}; // namespace Rust\n \n Optional<Feature::Name>\n Feature::as_name (const std::string &name)"}, {"sha": "1f580a00a0a16bfcb8a8330800e12fe8f44ea6d5", "filename": "gcc/rust/checks/errors/rust-feature.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f60c15f5099349ccc04a697e4d37154c371253a3/gcc%2Frust%2Fchecks%2Ferrors%2Frust-feature.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f60c15f5099349ccc04a697e4d37154c371253a3/gcc%2Frust%2Fchecks%2Ferrors%2Frust-feature.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fchecks%2Ferrors%2Frust-feature.h?ref=f60c15f5099349ccc04a697e4d37154c371253a3", "patch": "@@ -41,6 +41,7 @@ class Feature\n     INTRINSICS,\n     RUSTC_ATTRS,\n     DECL_MACRO,\n+    AUTO_TRAITS,\n   };\n \n   const std::string &as_string () { return m_name_str; }"}, {"sha": "d80ce9a1fb608d0b66918ae2b3e17ac9da86cbd6", "filename": "gcc/rust/lex/rust-lex.cc", "status": "modified", "additions": 5, "deletions": 18, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f60c15f5099349ccc04a697e4d37154c371253a3/gcc%2Frust%2Flex%2Frust-lex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f60c15f5099349ccc04a697e4d37154c371253a3/gcc%2Frust%2Flex%2Frust-lex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flex%2Frust-lex.cc?ref=f60c15f5099349ccc04a697e4d37154c371253a3", "patch": "@@ -240,45 +240,32 @@ Lexer::replace_current_token (TokenPtr replacement)\n  * created with x-macros. */\n namespace {\n // TODO: make constexpr when update to c++20\n-const std::string keyword_index[] = {\n+const std::map<std::string, TokenId> keywords = {\n #define RS_TOKEN(x, y)\n-#define RS_TOKEN_KEYWORD(name, keyword) keyword,\n+#define RS_TOKEN_KEYWORD(tok, key) {key, tok},\n   RS_TOKEN_LIST\n #undef RS_TOKEN_KEYWORD\n #undef RS_TOKEN\n };\n-\n-constexpr TokenId keyword_keys[] = {\n-#define RS_TOKEN(x, y)\n-#define RS_TOKEN_KEYWORD(name, keyword) name,\n-  RS_TOKEN_LIST\n-#undef RS_TOKEN_KEYWORD\n-#undef RS_TOKEN\n-};\n-\n-constexpr int num_keywords = sizeof (keyword_index) / sizeof (*keyword_index);\n } // namespace\n \n /* Determines whether the string passed in is a keyword or not. If it is, it\n  * returns the keyword name.  */\n TokenId\n Lexer::classify_keyword (const std::string &str)\n {\n-  const std::string *last = keyword_index + num_keywords;\n-  const std::string *idx = std::lower_bound (keyword_index, last, str);\n+  auto keyword = keywords.find (str);\n+  auto id = keyword->second;\n \n-  if (idx == last || str != *idx)\n+  if (keyword == keywords.end ())\n     return IDENTIFIER;\n \n-  // TODO: possibly replace this x-macro system with something like hash map?\n-\n   // We now have the expected token ID of the reserved keyword. However, some\n   // keywords are reserved starting in certain editions. For example, `try` is\n   // only a reserved keyword in editions >=2018. The language might gain new\n   // reserved keywords in the future.\n   //\n   // https://doc.rust-lang.org/reference/keywords.html#reserved-keywords\n-  auto id = keyword_keys[idx - keyword_index];\n \n   // `try` is not a reserved keyword before 2018\n   if (Session::get_instance ().options.get_edition ()"}, {"sha": "f00d9cf07dded4789cb99c837b550b5be2a5ce34", "filename": "gcc/rust/lex/rust-token.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f60c15f5099349ccc04a697e4d37154c371253a3/gcc%2Frust%2Flex%2Frust-token.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f60c15f5099349ccc04a697e4d37154c371253a3/gcc%2Frust%2Flex%2Frust-token.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flex%2Frust-token.h?ref=f60c15f5099349ccc04a697e4d37154c371253a3", "patch": "@@ -149,7 +149,8 @@ enum PrimitiveCoreType\n   /* have \"weak\" union and 'static keywords? */                                \\\n   RS_TOKEN_KEYWORD (ABSTRACT, \"abstract\") /* unused */                         \\\n   RS_TOKEN_KEYWORD (AS, \"as\")                                                  \\\n-  RS_TOKEN_KEYWORD (ASYNC, \"async\")   /* unused */                             \\\n+  RS_TOKEN_KEYWORD (ASYNC, \"async\") /* unused */                               \\\n+  RS_TOKEN_KEYWORD (AUTO, \"auto\")                                              \\\n   RS_TOKEN_KEYWORD (BECOME, \"become\") /* unused */                             \\\n   RS_TOKEN_KEYWORD (BOX, \"box\")\t      /* unused */                             \\\n   RS_TOKEN_KEYWORD (BREAK, \"break\")                                            \\"}, {"sha": "0841db4dc927c4ac5e38e107ad1a0d9a2b82c269", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 32, "deletions": 4, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f60c15f5099349ccc04a697e4d37154c371253a3/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f60c15f5099349ccc04a697e4d37154c371253a3/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=f60c15f5099349ccc04a697e4d37154c371253a3", "patch": "@@ -1057,6 +1057,7 @@ Parser<ManagedTokenSource>::parse_item (bool called_from_statement)\n     case ENUM_TOK:\n     case CONST:\n     case STATIC_TOK:\n+    case AUTO:\n     case TRAIT:\n     case IMPL:\n     case MACRO:\n@@ -1304,6 +1305,7 @@ Parser<ManagedTokenSource>::parse_vis_item (AST::AttrVec outer_attrs)\n \t}\n     case STATIC_TOK:\n       return parse_static_item (std::move (vis), std::move (outer_attrs));\n+    case AUTO:\n     case TRAIT:\n       return parse_trait (std::move (vis), std::move (outer_attrs));\n     case IMPL:\n@@ -1314,6 +1316,7 @@ Parser<ManagedTokenSource>::parse_vis_item (AST::AttrVec outer_attrs)\n \n       switch (t->get_id ())\n \t{\n+\tcase AUTO:\n \tcase TRAIT:\n \t  return parse_trait (std::move (vis), std::move (outer_attrs));\n \tcase EXTERN_TOK:\n@@ -2034,6 +2037,7 @@ Parser<ManagedTokenSource>::parse_macro_match ()\n \t  case STATIC_TOK:\n \t  case STRUCT_TOK:\n \t  case SUPER:\n+\t  case AUTO:\n \t  case TRAIT:\n \t  case TRUE_LITERAL:\n \t  case TRY:\n@@ -4753,12 +4757,20 @@ Parser<ManagedTokenSource>::parse_trait (AST::Visibility vis,\n {\n   Location locus = lexer.peek_token ()->get_locus ();\n   bool is_unsafe = false;\n+  bool is_auto_trait = false;\n+\n   if (lexer.peek_token ()->get_id () == UNSAFE)\n     {\n       is_unsafe = true;\n       lexer.skip_token ();\n     }\n \n+  if (lexer.peek_token ()->get_id () == AUTO)\n+    {\n+      is_auto_trait = true;\n+      lexer.skip_token ();\n+    }\n+\n   skip_token (TRAIT);\n \n   // parse trait name\n@@ -4824,12 +4836,25 @@ Parser<ManagedTokenSource>::parse_trait (AST::Visibility vis,\n       return nullptr;\n     }\n \n+  if (is_auto_trait && !trait_items.empty ())\n+    {\n+      add_error (\n+\tError (locus, \"associated items are forbidden within auto traits\"));\n+\n+      // FIXME: unsure if this should be done at parsing time or not\n+      for (const auto &item : trait_items)\n+\tadd_error (Error::Hint (item->get_locus (), \"remove this item\"));\n+\n+      return nullptr;\n+    }\n+\n   trait_items.shrink_to_fit ();\n   return std::unique_ptr<AST::Trait> (\n-    new AST::Trait (std::move (ident), is_unsafe, std::move (generic_params),\n-\t\t    std::move (type_param_bounds), std::move (where_clause),\n-\t\t    std::move (trait_items), std::move (vis),\n-\t\t    std::move (outer_attrs), std::move (inner_attrs), locus));\n+    new AST::Trait (std::move (ident), is_unsafe, is_auto_trait,\n+\t\t    std::move (generic_params), std::move (type_param_bounds),\n+\t\t    std::move (where_clause), std::move (trait_items),\n+\t\t    std::move (vis), std::move (outer_attrs),\n+\t\t    std::move (inner_attrs), locus));\n }\n \n // Parses a trait item used inside traits (not trait, the Item).\n@@ -6120,6 +6145,7 @@ Parser<ManagedTokenSource>::parse_stmt (ParseRestrictions restrictions)\n     case ENUM_TOK:\n     case CONST:\n     case STATIC_TOK:\n+    case AUTO:\n     case TRAIT:\n     case IMPL:\n     case MACRO:\n@@ -11769,6 +11795,7 @@ Parser<ManagedTokenSource>::parse_stmt_or_expr_without_block ()\n     case ENUM_TOK:\n     case CONST:\n     case STATIC_TOK:\n+    case AUTO:\n     case TRAIT:\n       case IMPL: {\n \tstd::unique_ptr<AST::VisItem> item (\n@@ -11790,6 +11817,7 @@ Parser<ManagedTokenSource>::parse_stmt_or_expr_without_block ()\n \t      // unsafe block\n \t      return parse_stmt_or_expr_with_block (std::move (outer_attrs));\n \t    }\n+\t  case AUTO:\n \t    case TRAIT: {\n \t      // unsafe trait\n \t      std::unique_ptr<AST::VisItem> item ("}, {"sha": "16dca571849126b17679e9c2eaeb291582ada1f9", "filename": "gcc/testsuite/rust/compile/auto_trait_invalid.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f60c15f5099349ccc04a697e4d37154c371253a3/gcc%2Ftestsuite%2Frust%2Fcompile%2Fauto_trait_invalid.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f60c15f5099349ccc04a697e4d37154c371253a3/gcc%2Ftestsuite%2Frust%2Fcompile%2Fauto_trait_invalid.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fauto_trait_invalid.rs?ref=f60c15f5099349ccc04a697e4d37154c371253a3", "patch": "@@ -0,0 +1,16 @@\n+// #![feature(auto_traits)] // not present in Rust 1.49 yet\n+\n+#![feature(optin_builtin_traits)]\n+\n+unsafe auto trait Invalid { // { dg-error \"associated items are forbidden within auto traits\" }\n+    fn foo(); // { dg-message \"remove this item\" }\n+\n+    fn bar() {} // { dg-message \"remove this item\" }\n+\n+    type Foo; // { dg-message \"remove this item\" }\n+\n+    const FOO: i32; // { dg-message \"remove this item\" }\n+\n+    const BAR: i32 = 15; // { dg-message \"remove this item\" }\n+}\n+// { dg-error \"failed to parse item in crate\" \"\" {target *-*-* } .+1 }"}, {"sha": "0fdab7ff3b136f26d450543ea97ffffd7bf46818", "filename": "gcc/testsuite/rust/compile/auto_trait_valid.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f60c15f5099349ccc04a697e4d37154c371253a3/gcc%2Ftestsuite%2Frust%2Fcompile%2Fauto_trait_valid.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f60c15f5099349ccc04a697e4d37154c371253a3/gcc%2Ftestsuite%2Frust%2Fcompile%2Fauto_trait_valid.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fauto_trait_valid.rs?ref=f60c15f5099349ccc04a697e4d37154c371253a3", "patch": "@@ -0,0 +1,10 @@\n+// #![feature(auto_traits)] // not present in Rust 1.49 yet\n+\n+#![feature(optin_builtin_traits)]\n+\n+auto trait MegaSend {}\n+pub auto trait MegaSync {}\n+unsafe auto trait SuperSync {}\n+pub unsafe auto trait SuperSend {}\n+\n+fn main() {}"}]}