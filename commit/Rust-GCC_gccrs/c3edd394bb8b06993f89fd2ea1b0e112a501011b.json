{"sha": "c3edd394bb8b06993f89fd2ea1b0e112a501011b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzNlZGQzOTRiYjhiMDY5OTNmODlmZDJlYTFiMGUxMTJhNTAxMDExYg==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@redhat.com", "date": "2000-11-25T00:43:32Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2000-11-25T00:43:32Z"}, "message": "Use target specific, language specific object files feature to allow build\nv850 pragma support into gcc and gxx.\n\nFrom-SVN: r37727", "tree": {"sha": "97b5bb36bfa627b71d12b3bd70d0231be076ce0e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/97b5bb36bfa627b71d12b3bd70d0231be076ce0e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c3edd394bb8b06993f89fd2ea1b0e112a501011b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3edd394bb8b06993f89fd2ea1b0e112a501011b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3edd394bb8b06993f89fd2ea1b0e112a501011b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3edd394bb8b06993f89fd2ea1b0e112a501011b/comments", "author": {"login": "nickclifton", "id": 31441682, "node_id": "MDQ6VXNlcjMxNDQxNjgy", "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nickclifton", "html_url": "https://github.com/nickclifton", "followers_url": "https://api.github.com/users/nickclifton/followers", "following_url": "https://api.github.com/users/nickclifton/following{/other_user}", "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}", "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions", "organizations_url": "https://api.github.com/users/nickclifton/orgs", "repos_url": "https://api.github.com/users/nickclifton/repos", "events_url": "https://api.github.com/users/nickclifton/events{/privacy}", "received_events_url": "https://api.github.com/users/nickclifton/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "aac69a49c996b35d3dca614d8cf880611423014b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aac69a49c996b35d3dca614d8cf880611423014b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aac69a49c996b35d3dca614d8cf880611423014b"}], "stats": {"total": 588, "additions": 345, "deletions": 243}, "files": [{"sha": "b91468a64b202992ad6e830a959cf784a975a7cf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3edd394bb8b06993f89fd2ea1b0e112a501011b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3edd394bb8b06993f89fd2ea1b0e112a501011b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c3edd394bb8b06993f89fd2ea1b0e112a501011b", "patch": "@@ -1,3 +1,33 @@\n+2000-11-24  Nick Clifton  <nickc@redhat.com>\n+\n+\t* config.gcc (v850-*-*): Define c_target_objs and\n+        cxx_target_objs.\n+\n+\t* config/v850/t-v850: Define how to build v850-c.o\n+\n+\t* config/v850/v850.h (struct data_area_stack_element): Move\n+\tdefinition here from v850.c.\n+\n+\t* config/v850v850.c: Include gcc.h to avoid compile time\n+\twarning.\n+\t(push_data_area): Move to v850-c.c.\n+\t(pop_data_area): Move to v850-c.c.\n+\t(mark_current_function_as_interrupt): Move to v850-c.c.\n+\t(GHS_default_section_names): Allow to be exported.\n+\t(GHS_current_section_names): Allow to be exported.\n+\t(data_area_stack_elements): Allow to be exported.\n+\t(ghs_pragma_section): Move to v850-c.c.\n+\t(ghs_pragma_interrupt): Move to v850-c.c.\n+\t(ghs_pragma_starttda): Move to v850-c.c.\n+\t(ghs_pragma_startsda): Move to v850-c.c.\n+\t(ghs_pragma_startzda): Move to v850-c.c.\n+\t(ghs_pragma_endtda): Move to v850-c.c.\n+\t(ghs_pragma_endsda): Move to v850-c.c.\n+\t(ghs_pragma_endzda): Move to v850-c.c.\n+\n+\t* config/v850/v850-c.c: New file: Contains v850 specific\n+\tpragma parsing functions.\n+\n 2000-11-24  Nick Clifton  <nickc@redhat.com>\n \n \t* config.gcc (extra_objs): Remove duplicate description."}, {"sha": "9f25880924ed941080196841e1cab10264967022", "filename": "gcc/config.gcc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3edd394bb8b06993f89fd2ea1b0e112a501011b/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3edd394bb8b06993f89fd2ea1b0e112a501011b/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=c3edd394bb8b06993f89fd2ea1b0e112a501011b", "patch": "@@ -3133,6 +3133,8 @@ v850-*-rtems*)\n \t\ttm_file=\"${tm_file} dbx.h\"\n \tfi\n \tuse_collect2=no\n+\tc_target_objs=\"v850-c.o\"\n+\tcxx_target_objs=\"v850-c.o\"\n \t;;\n v850-*-*)\n \ttarget_cpu_default=\"TARGET_CPU_generic\"\n@@ -3145,6 +3147,8 @@ v850-*-*)\n \t\ttm_file=\"${tm_file} dbx.h\"\n \tfi\n \tuse_collect2=no\n+\tc_target_objs=\"v850-c.o\"\n+\tcxx_target_objs=\"v850-c.o\"\n \t;;\n vax-*-bsd*)\t\t\t# vaxen running BSD\n \tuse_collect2=yes"}, {"sha": "479a23572054f0da98fcfcebad4c61ecd25728a0", "filename": "gcc/config/v850/t-v850", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3edd394bb8b06993f89fd2ea1b0e112a501011b/gcc%2Fconfig%2Fv850%2Ft-v850", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3edd394bb8b06993f89fd2ea1b0e112a501011b/gcc%2Fconfig%2Fv850%2Ft-v850", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Ft-v850?ref=c3edd394bb8b06993f89fd2ea1b0e112a501011b", "patch": "@@ -31,7 +31,6 @@ LIB1ASMFUNCS\t= _mulsi3 \\\n \t\t  _save_varargs \\\n \t\t  _save_interrupt \\\n \t\t  _save_all_interrupt\n-\t\n \n # We want fine grained libraries, so use the new code to build the\n # floating point emulation libraries.\n@@ -52,3 +51,7 @@ fp-bit.c: $(srcdir)/config/fp-bit.c\n \tcat $(srcdir)/config/fp-bit.c >> fp-bit.c\n \n TCFLAGS = -Wa,-mwarn-signed-overflow -Wa,-mwarn-unsigned-overflow\n+\n+v850-c.o: $(srcdir)/config/v850/v850-c.c\n+\t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $<\n+"}, {"sha": "d541a6657a3b1372539bc96c2fd9cf15f0a0642f", "filename": "gcc/config/v850/v850-c.c", "status": "added", "additions": 276, "deletions": 0, "changes": 276, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3edd394bb8b06993f89fd2ea1b0e112a501011b/gcc%2Fconfig%2Fv850%2Fv850-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3edd394bb8b06993f89fd2ea1b0e112a501011b/gcc%2Fconfig%2Fv850%2Fv850-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850-c.c?ref=c3edd394bb8b06993f89fd2ea1b0e112a501011b", "patch": "@@ -0,0 +1,276 @@\n+/* v850 specific, C compiler specific functions.\n+   Copyright (C) 2000 Free Software Foundation, Inc.\n+   Contributed by Jeff Law (law@cygnus.com).\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"cpplib.h\"\n+#include \"tree.h\"\n+#include \"c-pragma.h\"\n+#include \"c-lex.h\"\n+#include \"toplev.h\"\n+#include \"ggc.h\"\n+#include \"tm_p.h\"\n+\n+#ifndef streq\n+#define streq(a,b) (strcmp (a, b) == 0)\n+#endif\n+\f\n+static int  pop_data_area          PARAMS ((v850_data_area));\n+static int  push_data_area         PARAMS ((v850_data_area));\n+static int  mark_current_function_as_interrupt PARAMS ((void));\n+\f\n+/* Push a data area onto the stack.  */\n+\n+static int\n+push_data_area (data_area)\n+     v850_data_area data_area;\n+{\n+  data_area_stack_element * elem;\n+\n+  elem = (data_area_stack_element *) xmalloc (sizeof (* elem));\n+\n+  if (elem == NULL)\n+    return 0;\n+\n+  elem->prev      = data_area_stack;\n+  elem->data_area = data_area;\n+\n+  data_area_stack = elem;\n+\n+  return 1;\n+}\n+\n+/* Remove a data area from the stack.  */\n+\n+static int\n+pop_data_area (data_area)\n+     v850_data_area data_area;\n+{\n+  if (data_area_stack == NULL)\n+    warning (\"#pragma GHS endXXXX found without previous startXXX\");\n+  else if (data_area != data_area_stack->data_area)\n+    warning (\"#pragma GHS endXXX does not match previous startXXX\");\n+  else\n+    {\n+      data_area_stack_element * elem;\n+\n+      elem = data_area_stack;\n+      data_area_stack = data_area_stack->prev;\n+\n+      free (elem);\n+\n+      return 1;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Set the machine specific 'interrupt' attribute on the current function.  */\n+\n+static int\n+mark_current_function_as_interrupt ()\n+{\n+  tree name;\n+  \n+  if (current_function_decl ==  NULL_TREE)\n+    {\n+      warning (\"Cannot set interrupt attribute: no current function\");\n+      return 0;\n+    }\n+\n+  name = get_identifier (\"interrupt\");\n+\n+  if (name == NULL_TREE || TREE_CODE (name) != IDENTIFIER_NODE)\n+    {\n+      warning (\"Cannot set interrupt attribute: no such identifier\");\n+      return 0;\n+    }\n+  \n+  return valid_machine_attribute\n+    (name, NULL_TREE, current_function_decl, NULL_TREE);\n+}\n+\n+\f\n+/* Support for GHS pragmata.  */\n+\n+void\n+ghs_pragma_section (pfile)\n+     cpp_reader *pfile ATTRIBUTE_UNUSED;\n+{\n+  int repeat;\n+\n+  /* #pragma ghs section [name = alias [, name = alias [, ...]]] */\n+  do\n+    {\n+      tree x;\n+      enum cpp_ttype type;\n+      const char *sect, *alias;\n+      enum GHS_section_kind kind;\n+      \n+      type = c_lex (&x);\n+      \n+      if (type == CPP_EOF && !repeat)\n+\tgoto reset;\n+      else if (type == CPP_NAME)\n+\tsect = IDENTIFIER_POINTER (x);\n+      else\n+\tgoto bad;\n+      repeat = 0;\n+      \n+      if (c_lex (&x) != CPP_EQ)\n+\tgoto bad;\n+      if (c_lex (&x) != CPP_NAME)\n+\tgoto bad;\n+      \n+      alias = IDENTIFIER_POINTER (x);\n+      \n+      type = c_lex (&x);\n+      if (type == CPP_COMMA)\n+\trepeat = 1;\n+      else if (type != CPP_EOF)\n+\twarning (\"junk at end of #pragma ghs section\");\n+      \n+      if      (streq (sect, \"data\"))    kind = GHS_SECTION_KIND_DATA;\n+      else if (streq (sect, \"text\"))    kind = GHS_SECTION_KIND_TEXT;\n+      else if (streq (sect, \"rodata\"))  kind = GHS_SECTION_KIND_RODATA;\n+      else if (streq (sect, \"const\"))   kind = GHS_SECTION_KIND_RODATA;\n+      else if (streq (sect, \"rosdata\")) kind = GHS_SECTION_KIND_ROSDATA;\n+      else if (streq (sect, \"rozdata\")) kind = GHS_SECTION_KIND_ROZDATA;\n+      else if (streq (sect, \"sdata\"))   kind = GHS_SECTION_KIND_SDATA;\n+      else if (streq (sect, \"tdata\"))   kind = GHS_SECTION_KIND_TDATA;\n+      else if (streq (sect, \"zdata\"))   kind = GHS_SECTION_KIND_ZDATA;\n+      /* According to GHS beta documentation, the following should not be\n+\t allowed!  */\n+      else if (streq (sect, \"bss\"))     kind = GHS_SECTION_KIND_BSS;\n+      else if (streq (sect, \"zbss\"))    kind = GHS_SECTION_KIND_ZDATA;\n+      else\n+\t{\n+\t  warning (\"unrecognised section name \\\"%s\\\"\", sect);\n+\t  return;\n+\t}\n+      \n+      if (streq (alias, \"default\"))\n+\tGHS_current_section_names [kind] = NULL;\n+      else\n+\tGHS_current_section_names [kind] =\n+\t  build_string (strlen (alias) + 1, alias);\n+    }\n+  while (repeat);\n+\n+  return;\n+\n+ bad:\n+  warning (\"malformed #pragma ghs section\");\n+  return;\n+\n+ reset:\n+  /* #pragma ghs section \\n: Reset all section names back to their defaults.  */\n+  {\n+    int i;\n+    \n+    for (i = COUNT_OF_GHS_SECTION_KINDS; i--;)\n+      GHS_current_section_names [i] = NULL;\n+  }\n+}\n+\n+void\n+ghs_pragma_interrupt (pfile)\n+     cpp_reader *pfile ATTRIBUTE_UNUSED;\n+{\n+  tree x;\n+  \n+  if (c_lex (&x) != CPP_EOF)\n+    warning (\"junk at end of #pragma ghs interrupt\");\n+  \n+  mark_current_function_as_interrupt ();\n+}\n+\n+void\n+ghs_pragma_starttda (pfile)\n+     cpp_reader *pfile ATTRIBUTE_UNUSED;\n+{\n+  tree x;\n+  \n+  if (c_lex (&x) != CPP_EOF)\n+    warning (\"junk at end of #pragma ghs starttda\");\n+  \n+  push_data_area (DATA_AREA_TDA);\n+}\n+\n+void\n+ghs_pragma_startsda (pfile)\n+     cpp_reader *pfile ATTRIBUTE_UNUSED;\n+{\n+  tree x;\n+  \n+  if (c_lex (&x) != CPP_EOF)\n+    warning (\"junk at end of #pragma ghs startsda\");\n+  \n+  push_data_area (DATA_AREA_SDA);\n+}\n+\n+void\n+ghs_pragma_startzda (pfile)\n+     cpp_reader *pfile ATTRIBUTE_UNUSED;\n+{\n+  tree x;\n+  \n+  if (c_lex (&x) != CPP_EOF)\n+    warning (\"junk at end of #pragma ghs startzda\");\n+  \n+  push_data_area (DATA_AREA_ZDA);\n+}\n+\n+void\n+ghs_pragma_endtda (pfile)\n+     cpp_reader *pfile ATTRIBUTE_UNUSED;\n+{\n+  tree x;\n+  \n+  if (c_lex (&x) != CPP_EOF)\n+    warning (\"junk at end of #pragma ghs endtda\");\n+  \n+  pop_data_area (DATA_AREA_TDA);\n+}\n+\n+void\n+ghs_pragma_endsda (pfile)\n+     cpp_reader *pfile ATTRIBUTE_UNUSED;\n+{\n+  tree x;\n+  \n+  if (c_lex (&x) != CPP_EOF)\n+    warning (\"junk at end of #pragma ghs endsda\");\n+  \n+  pop_data_area (DATA_AREA_SDA);\n+}\n+\n+void\n+ghs_pragma_endzda (pfile)\n+     cpp_reader *pfile ATTRIBUTE_UNUSED;\n+{\n+  tree x;\n+  \n+  if (c_lex (&x) != CPP_EOF)\n+    warning (\"junk at end of #pragma ghs endzda\");\n+  \n+  pop_data_area (DATA_AREA_ZDA);\n+}"}, {"sha": "8fd16026719d3bed280aa3e8a18bae07b8081e09", "filename": "gcc/config/v850/v850.c", "status": "modified", "additions": 13, "deletions": 242, "changes": 255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3edd394bb8b06993f89fd2ea1b0e112a501011b/gcc%2Fconfig%2Fv850%2Fv850.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3edd394bb8b06993f89fd2ea1b0e112a501011b/gcc%2Fconfig%2Fv850%2Fv850.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.c?ref=c3edd394bb8b06993f89fd2ea1b0e112a501011b", "patch": "@@ -38,7 +38,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"toplev.h\"\n #include \"cpplib.h\"\n #include \"c-lex.h\"\n-#include \"c-pragma.h\"\n+#include \"ggc.h\"\n #include \"tm_p.h\"\n \n #ifndef streq\n@@ -50,10 +50,7 @@ static void const_double_split\n   PARAMS ((rtx, HOST_WIDE_INT *, HOST_WIDE_INT *));\n static int  const_costs_int        PARAMS ((HOST_WIDE_INT, int));\n static void substitute_ep_register PARAMS ((rtx, rtx, int, int, rtx *, rtx *));\n-static int  push_data_area         PARAMS ((v850_data_area));\n-static int  pop_data_area          PARAMS ((v850_data_area));\n static int  ep_memory_offset       PARAMS ((enum machine_mode, int));\n-static int  mark_current_function_as_interrupt PARAMS ((void));\n static void v850_set_data_area     PARAMS ((tree, v850_data_area));\n \n /* True if the current function has anonymous arguments.  */\n@@ -68,8 +65,16 @@ struct small_memory_info small_memory[ (int)SMALL_MEMORY_max ] =\n   { \"zda\",\t(char *)0,\t0,\t\t32768 },\n };\n \n+/* Names of the various data areas used on the v850.  */\n+tree GHS_default_section_names [(int) COUNT_OF_GHS_SECTION_KINDS];\n+tree GHS_current_section_names [(int) COUNT_OF_GHS_SECTION_KINDS];\n+\n+/* Track the current data area set by the data area pragma (which \n+   can be nested).  Tested by check_default_data_area.  */\n+data_area_stack_element * data_area_stack = NULL;\n+\n /* True if we don't need to check any more if the current\n-   function is an interrupt handler */\n+   function is an interrupt handler.  */\n static int v850_interrupt_cache_p = FALSE;\n \n /* Whether current function is an interrupt handler.  */\n@@ -1028,7 +1033,7 @@ not_power_of_two_operand (op, mode)\n   else if (mode == HImode)\n     mask = 0xffff;\n   else if (mode == SImode)\n-    mask = 0xffffffff; \n+    mask = 0xffffffffU;\n   else\n     return 0;\n \n@@ -1104,12 +1109,12 @@ Saved %d bytes (%d uses of register %s) in function %s, starting as insn %d, end\n \t\t{\n \t\t  rtx addr = XEXP (*p_mem, 0);\n \n-\t\t  if (GET_CODE (addr) == REG && REGNO (addr) == regno)\n+\t\t  if (GET_CODE (addr) == REG && REGNO (addr) == (unsigned) regno)\n \t\t    *p_mem = change_address (*p_mem, VOIDmode, *p_ep);\n \n \t\t  else if (GET_CODE (addr) == PLUS\n \t\t\t   && GET_CODE (XEXP (addr, 0)) == REG\n-\t\t\t   && REGNO (XEXP (addr, 0)) == regno\n+\t\t\t   && REGNO (XEXP (addr, 0)) == (unsigned) regno\n \t\t\t   && GET_CODE (XEXP (addr, 1)) == CONST_INT\n \t\t\t   && ((INTVAL (XEXP (addr, 1)))\n \t\t\t       < ep_memory_offset (GET_MODE (*p_mem),\n@@ -2638,240 +2643,6 @@ v850_output_local (file, decl, name, size, align)\n   ASM_OUTPUT_ALIGNED_DECL_COMMON (file, decl, name, size, align);\n }\n \n-/* The following code is for handling pragmas supported by the\n-   v850 compiler produced by Green Hills Software.  This is at\n-   the specific request of a customer.  */\n-\n-/* Track the current data area set by the data area pragma (which \n-   can be nested).  Tested by check_default_data_area. */\n-\n-typedef struct data_area_stack_element\n-{\n-  struct data_area_stack_element * prev;\n-  v850_data_area                   data_area; /* current default data area. */\n-} data_area_stack_element;\n-\n-static data_area_stack_element * data_area_stack = NULL;\n-\n-/* Names of the various data areas used on the v850.  */\n-static tree GHS_default_section_names [(int) COUNT_OF_GHS_SECTION_KINDS];\n-static tree GHS_current_section_names [(int) COUNT_OF_GHS_SECTION_KINDS];\n-\n-/* Push a data area onto the stack.  */\n-static int\n-push_data_area (data_area)\n-     v850_data_area data_area;\n-{\n-  data_area_stack_element * elem;\n-\n-  elem = (data_area_stack_element *) xmalloc (sizeof (* elem));\n-\n-  if (elem == NULL)\n-    return 0;\n-\n-  elem->prev      = data_area_stack;\n-  elem->data_area = data_area;\n-\n-  data_area_stack = elem;\n-\n-  return 1;\n-}\n-\n-/* Remove a data area from the stack.  */\n-static int\n-pop_data_area (data_area)\n-     v850_data_area data_area;\n-{\n-  if (data_area_stack == NULL)\n-    warning (\"#pragma GHS endXXXX found without previous startXXX\");\n-  else if (data_area != data_area_stack->data_area)\n-    warning (\"#pragma GHS endXXX does not match previous startXXX\");\n-  else\n-    {\n-      data_area_stack_element * elem;\n-\n-      elem = data_area_stack;\n-      data_area_stack = data_area_stack->prev;\n-\n-      free (elem);\n-\n-      return 1;\n-    }\n-\n-  return 0;\n-}\n-\n-/* Set the machine specific 'interrupt' attribute on the current function.  */\n-static int\n-mark_current_function_as_interrupt ()\n-{\n-  tree name;\n-  \n-  if (current_function_decl ==  NULL_TREE)\n-    {\n-      warning (\"Cannot set interrupt attribute: no current function\");\n-      return 0;\n-    }\n-\n-  name = get_identifier (\"interrupt\");\n-\n-  if (name == NULL_TREE || TREE_CODE (name) != IDENTIFIER_NODE)\n-    {\n-      warning (\"Cannot set interrupt attribute: no such identifier\");\n-      return 0;\n-    }\n-  \n-  return valid_machine_attribute\n-    (name, NULL_TREE, current_function_decl, NULL_TREE);\n-}\n-\n-/* Support for GHS pragmata.  */\n-\n-void\n-ghs_pragma_section (pfile)\n-     cpp_reader *pfile ATTRIBUTE_UNUSED;\n-{\n-  int repeat;\n-\n-  /* #pragma ghs section [name = alias [, name = alias [, ...]]] */\n-  do {\n-    tree x;\n-    enum cpp_ttype type;\n-    const char *sect, *alias;\n-    enum GHS_section_kind kind;\n-\n-    type = c_lex (&x);\n-    if (type == CPP_EOF && !repeat)\n-      goto reset;\n-    else if (type == CPP_NAME)\n-      sect = IDENTIFIER_POINTER (x);\n-    else\n-      goto bad;\n-    repeat = 0;\n-\n-    if (c_lex (&x) != CPP_EQ)\n-      goto bad;\n-    if (c_lex (&x) != CPP_NAME)\n-      goto bad;\n-    alias = IDENTIFIER_POINTER (x);\n-\n-    type = c_lex (&x);\n-    if (type == CPP_COMMA)\n-      repeat = 1;\n-    else if (type != CPP_EOF)\n-      warning (\"junk at end of #pragma ghs section\");\n-\n-    if      (streq (sect, \"data\"))    kind = GHS_SECTION_KIND_DATA;\n-    else if (streq (sect, \"text\"))    kind = GHS_SECTION_KIND_TEXT;\n-    else if (streq (sect, \"rodata\"))  kind = GHS_SECTION_KIND_RODATA;\n-    else if (streq (sect, \"const\"))   kind = GHS_SECTION_KIND_RODATA;\n-    else if (streq (sect, \"rosdata\")) kind = GHS_SECTION_KIND_ROSDATA;\n-    else if (streq (sect, \"rozdata\")) kind = GHS_SECTION_KIND_ROZDATA;\n-    else if (streq (sect, \"sdata\"))   kind = GHS_SECTION_KIND_SDATA;\n-    else if (streq (sect, \"tdata\"))   kind = GHS_SECTION_KIND_TDATA;\n-    else if (streq (sect, \"zdata\"))   kind = GHS_SECTION_KIND_ZDATA;\n-    /* According to GHS beta documentation, the following should not be\n-       allowed!  */\n-    else if (streq (sect, \"bss\"))     kind = GHS_SECTION_KIND_BSS;\n-    else if (streq (sect, \"zbss\"))    kind = GHS_SECTION_KIND_ZDATA;\n-    else\n-      {\n-\twarning (\"unrecognised section name \\\"%s\\\"\", sect);\n-\treturn;\n-      }\n-\n-    if (streq (alias, \"default\"))\n-      GHS_current_section_names [kind] = NULL;\n-    else\n-      GHS_current_section_names [kind] =\n-\tbuild_string (strlen (alias) + 1, alias);\n-\n-  } while (repeat);\n-  return;\n-\n- bad:\n-  warning (\"malformed #pragma ghs section\");\n-  return;\n-\n- reset:\n-  /* #pragma ghs section \\n: Reset all section names back to their defaults.  */\n-  {\n-    int i;\n-    for (i = COUNT_OF_GHS_SECTION_KINDS; i--;)\n-      GHS_current_section_names [i] = NULL;\n-  }\n-}\n-\n-void\n-ghs_pragma_interrupt (pfile)\n-     cpp_reader *pfile ATTRIBUTE_UNUSED;\n-{\n-  tree x;\n-  if (c_lex (&x) != CPP_EOF)\n-    warning (\"junk at end of #pragma ghs interrupt\");\n-  mark_current_function_as_interrupt ();\n-}\n-\n-void\n-ghs_pragma_starttda (pfile)\n-     cpp_reader *pfile ATTRIBUTE_UNUSED;\n-{\n-  tree x;\n-  if (c_lex (&x) != CPP_EOF)\n-    warning (\"junk at end of #pragma ghs starttda\");\n-  push_data_area (DATA_AREA_TDA);\n-}\n-\n-void\n-ghs_pragma_startsda (pfile)\n-     cpp_reader *pfile ATTRIBUTE_UNUSED;\n-{\n-  tree x;\n-  if (c_lex (&x) != CPP_EOF)\n-    warning (\"junk at end of #pragma ghs startsda\");\n-  push_data_area (DATA_AREA_SDA);\n-}\n-\n-void\n-ghs_pragma_startzda (pfile)\n-     cpp_reader *pfile ATTRIBUTE_UNUSED;\n-{\n-  tree x;\n-  if (c_lex (&x) != CPP_EOF)\n-    warning (\"junk at end of #pragma ghs startzda\");\n-  push_data_area (DATA_AREA_ZDA);\n-}\n-\n-void\n-ghs_pragma_endtda (pfile)\n-     cpp_reader *pfile ATTRIBUTE_UNUSED;\n-{\n-  tree x;\n-  if (c_lex (&x) != CPP_EOF)\n-    warning (\"junk at end of #pragma ghs endtda\");\n-  pop_data_area (DATA_AREA_TDA);\n-}\n-\n-void\n-ghs_pragma_endsda (pfile)\n-     cpp_reader *pfile ATTRIBUTE_UNUSED;\n-{\n-  tree x;\n-  if (c_lex (&x) != CPP_EOF)\n-    warning (\"junk at end of #pragma ghs endsda\");\n-  pop_data_area (DATA_AREA_SDA);\n-}\n-\n-void\n-ghs_pragma_endzda (pfile)\n-     cpp_reader *pfile ATTRIBUTE_UNUSED;\n-{\n-  tree x;\n-  if (c_lex (&x) != CPP_EOF)\n-    warning (\"junk at end of #pragma ghs endzda\");\n-  pop_data_area (DATA_AREA_ZDA);\n-}\n-\n /* Add data area to the given declaration if a ghs data area pragma is\n    currently in effect (#pragma ghs startXXX/endXXX).  */\n void"}, {"sha": "ccf49674d1da0112d9152c11aa88c95870cfb298", "filename": "gcc/config/v850/v850.h", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3edd394bb8b06993f89fd2ea1b0e112a501011b/gcc%2Fconfig%2Fv850%2Fv850.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3edd394bb8b06993f89fd2ea1b0e112a501011b/gcc%2Fconfig%2Fv850%2Fv850.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.h?ref=c3edd394bb8b06993f89fd2ea1b0e112a501011b", "patch": "@@ -1555,6 +1555,24 @@ enum GHS_section_kind\n   COUNT_OF_GHS_SECTION_KINDS  /* must be last */\n };\n \n+/* The following code is for handling pragmas supported by the\n+   v850 compiler produced by Green Hills Software.  This is at\n+   the specific request of a customer.  */\n+\n+typedef struct data_area_stack_element\n+{\n+  struct data_area_stack_element * prev;\n+  v850_data_area                   data_area; /* Current default data area.  */\n+} data_area_stack_element;\n+\n+/* Track the current data area set by the\n+   data area pragma (which can be nested).  */\n+extern data_area_stack_element * data_area_stack;\n+\n+/* Names of the various data areas used on the v850.  */\n+extern union tree_node * GHS_default_section_names [(int) COUNT_OF_GHS_SECTION_KINDS];\n+extern union tree_node * GHS_current_section_names [(int) COUNT_OF_GHS_SECTION_KINDS];\n+\n /* The assembler op to start the file.  */\n \n #define FILE_ASM_OP \"\\t.file\\n\""}]}