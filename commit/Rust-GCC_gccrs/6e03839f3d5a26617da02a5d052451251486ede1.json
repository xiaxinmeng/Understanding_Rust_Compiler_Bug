{"sha": "6e03839f3d5a26617da02a5d052451251486ede1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmUwMzgzOWYzZDVhMjY2MTdkYTAyYTVkMDUyNDUxMjUxNDg2ZWRlMQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2018-05-31T10:47:14Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2018-05-31T10:47:14Z"}, "message": "[Ada] Fix wrong value returned for unconstrained packed array\n\n2018-05-31  Eric Botcazou  <ebotcazou@adacore.com>\n\ngcc/ada/\n\n\t* gcc-interface/trans.c (Call_to_gnu): In the by-reference case, if\n\tthe type of the parameter is an unconstrained array type, convert\n\tto the type of the actual before the type of the formal only if the\n\tconversion was suppressed earlier.  Use in_param and gnu_actual_type\n\tlocal variables throughout, and uniform spelling for In Out or Out.\n\tAlso remove dead code in the component-by-reference case.\n\nFrom-SVN: r261011", "tree": {"sha": "73c2559dee0f49f3f4017c3df6e244a7d68c810c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/73c2559dee0f49f3f4017c3df6e244a7d68c810c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e03839f3d5a26617da02a5d052451251486ede1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e03839f3d5a26617da02a5d052451251486ede1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e03839f3d5a26617da02a5d052451251486ede1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e03839f3d5a26617da02a5d052451251486ede1/comments", "author": null, "committer": null, "parents": [{"sha": "fe1db400ad466c7c62a37d89f51ee4474bdba214", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe1db400ad466c7c62a37d89f51ee4474bdba214", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe1db400ad466c7c62a37d89f51ee4474bdba214"}], "stats": {"total": 50, "additions": 26, "deletions": 24}, "files": [{"sha": "8e7eb1181406d451c6594036d895393bb31772f8", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e03839f3d5a26617da02a5d052451251486ede1/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e03839f3d5a26617da02a5d052451251486ede1/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=6e03839f3d5a26617da02a5d052451251486ede1", "patch": "@@ -1,3 +1,12 @@\n+2018-05-31  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/trans.c (Call_to_gnu): In the by-reference case, if\n+\tthe type of the parameter is an unconstrained array type, convert\n+\tto the type of the actual before the type of the formal only if the\n+\tconversion was suppressed earlier.  Use in_param and gnu_actual_type\n+\tlocal variables throughout, and uniform spelling for In Out or Out.\n+\tAlso remove dead code in the component-by-reference case.\n+\n 2018-05-31  Frederic Konrad  <konrad@adacore.com>\n \n \t* tracebak.c (STOP_FRAME): Harden condition."}, {"sha": "32b5ef1dc750af9b05973627ccb7470e8877933c", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 17, "deletions": 24, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e03839f3d5a26617da02a5d052451251486ede1/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e03839f3d5a26617da02a5d052451251486ede1/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=6e03839f3d5a26617da02a5d052451251486ede1", "patch": "@@ -4421,13 +4421,14 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n       tree gnu_formal_type = gnat_to_gnu_type (gnat_formal_type);\n       tree gnu_formal = present_gnu_tree (gnat_formal)\n \t\t\t? get_gnu_tree (gnat_formal) : NULL_TREE;\n+      const bool in_param = (Ekind (gnat_formal) == E_In_Parameter);\n       const bool is_true_formal_parm\n \t= gnu_formal && TREE_CODE (gnu_formal) == PARM_DECL;\n       const bool is_by_ref_formal_parm\n \t= is_true_formal_parm\n \t  && (DECL_BY_REF_P (gnu_formal)\n \t      || DECL_BY_COMPONENT_PTR_P (gnu_formal));\n-      /* In the Out or In Out case, we must suppress conversions that yield\n+      /* In the In Out or Out case, we must suppress conversions that yield\n \t an lvalue but can nevertheless cause the creation of a temporary,\n \t because we need the real object in this case, either to pass its\n \t address if it's passed by reference or as target of the back copy\n@@ -4438,7 +4439,7 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n \t test is applied to the real object.  */\n       const bool suppress_type_conversion\n \t= ((Nkind (gnat_actual) == N_Unchecked_Type_Conversion\n-\t    && (Ekind (gnat_formal) != E_In_Parameter\n+\t    && (!in_param\n \t\t|| (Is_Composite_Type (Underlying_Type (gnat_formal_type))\n \t\t    && !Is_Constrained (Underlying_Type (gnat_formal_type)))))\n \t   || (Nkind (gnat_actual) == N_Type_Conversion\n@@ -4450,7 +4451,7 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n       /* If it's possible we may need to use this expression twice, make sure\n \t that any side-effects are handled via SAVE_EXPRs; likewise if we need\n \t to force side-effects before the call.  */\n-      if (Ekind (gnat_formal) != E_In_Parameter && !is_by_ref_formal_parm)\n+      if (!in_param && !is_by_ref_formal_parm)\n \t{\n \t  tree init = NULL_TREE;\n \t  gnu_name = gnat_stabilize_reference (gnu_name, true, &init);\n@@ -4460,13 +4461,12 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n \t}\n \n       /* If we are passing a non-addressable parameter by reference, pass the\n-\t address of a copy.  In the Out or In Out case, set up to copy back\n+\t address of a copy.  In the In Out or Out case, set up to copy back\n \t out after the call.  */\n       if (is_by_ref_formal_parm\n \t  && (gnu_name_type = gnat_to_gnu_type (Etype (gnat_name)))\n \t  && !addressable_p (gnu_name, gnu_name_type))\n \t{\n-\t  bool in_param = (Ekind (gnat_formal) == E_In_Parameter);\n \t  tree gnu_orig = gnu_name, gnu_temp, gnu_stmt;\n \n \t  /* Do not issue warnings for CONSTRUCTORs since this is not a copy\n@@ -4616,7 +4616,7 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n \n       /* Unless this is an In parameter, we must remove any justified modular\n \t building from GNU_NAME to get an lvalue.  */\n-      if (Ekind (gnat_formal) != E_In_Parameter\n+      if (!in_param\n \t  && TREE_CODE (gnu_name) == CONSTRUCTOR\n \t  && TREE_CODE (TREE_TYPE (gnu_name)) == RECORD_TYPE\n \t  && TYPE_JUSTIFIED_MODULAR_P (TREE_TYPE (gnu_name)))\n@@ -4626,7 +4626,7 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n       /* First see if the parameter is passed by reference.  */\n       if (is_true_formal_parm && DECL_BY_REF_P (gnu_formal))\n \t{\n-\t  if (Ekind (gnat_formal) != E_In_Parameter)\n+\t  if (!in_param)\n \t    {\n \t      /* In Out or Out parameters passed by reference don't use the\n \t\t copy-in/copy-out mechanism so the address of the real object\n@@ -4648,24 +4648,23 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n \t\t  && TYPE_CONTAINS_TEMPLATE_P (TREE_TYPE (gnu_actual))\n \t\t  && Is_Constr_Subt_For_UN_Aliased (Etype (gnat_actual))\n \t\t  && Is_Array_Type (Underlying_Type (Etype (gnat_actual))))\n-\t\tgnu_actual = convert (gnat_to_gnu_type (Etype (gnat_actual)),\n-\t\t\t\t      gnu_actual);\n+\t\tgnu_actual = convert (gnu_actual_type, gnu_actual);\n \t    }\n \n \t  /* There is no need to convert the actual to the formal's type before\n \t     taking its address.  The only exception is for unconstrained array\n \t     types because of the way we build fat pointers.  */\n \t  if (TREE_CODE (gnu_formal_type) == UNCONSTRAINED_ARRAY_TYPE)\n \t    {\n-\t      /* Put back a view conversion for In Out or Out parameters.  */\n-\t      if (Ekind (gnat_formal) != E_In_Parameter)\n-\t\tgnu_actual = convert (gnat_to_gnu_type (Etype (gnat_actual)),\n-\t\t\t\t      gnu_actual);\n+\t      /* Put back the conversion we suppressed above for In Out or Out\n+\t\t parameters, since it may set the bounds of the actual.  */\n+\t      if (!in_param && suppress_type_conversion)\n+\t\tgnu_actual = convert (gnu_actual_type, gnu_actual);\n \t      gnu_actual = convert (gnu_formal_type, gnu_actual);\n \t    }\n \n-\t  /* The symmetry of the paths to the type of an entity is broken here\n-\t     since arguments don't know that they will be passed by ref.  */\n+\t  /* Take the address of the object and convert to the proper pointer\n+\t     type.  */\n \t  gnu_formal_type = TREE_TYPE (gnu_formal);\n \t  gnu_actual = build_unary_op (ADDR_EXPR, gnu_formal_type, gnu_actual);\n \t}\n@@ -4674,22 +4673,16 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n \t subprogram.  */\n       else if (is_true_formal_parm && DECL_BY_COMPONENT_PTR_P (gnu_formal))\n \t{\n-\t  gnu_formal_type = TREE_TYPE (gnu_formal);\n \t  gnu_actual = maybe_implicit_deref (gnu_actual);\n \t  gnu_actual = maybe_unconstrained_array (gnu_actual);\n \n-\t  if (TYPE_IS_PADDING_P (gnu_formal_type))\n-\t    {\n-\t      gnu_formal_type = TREE_TYPE (TYPE_FIELDS (gnu_formal_type));\n-\t      gnu_actual = convert (gnu_formal_type, gnu_actual);\n-\t    }\n-\n \t  /* Take the address of the object and convert to the proper pointer\n \t     type.  We'd like to actually compute the address of the beginning\n \t     of the array using an ADDR_EXPR of an ARRAY_REF, but there's a\n \t     possibility that the ARRAY_REF might return a constant and we'd be\n \t     getting the wrong address.  Neither approach is exactly correct,\n \t     but this is the most likely to work in all cases.  */\n+\t  gnu_formal_type = TREE_TYPE (gnu_formal);\n \t  gnu_actual = build_unary_op (ADDR_EXPR, gnu_formal_type, gnu_actual);\n \t}\n \n@@ -4698,7 +4691,7 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n \t{\n \t  tree gnu_size;\n \n-\t  if (Ekind (gnat_formal) != E_In_Parameter)\n+\t  if (!in_param)\n \t    gnu_name_list = tree_cons (NULL_TREE, gnu_name, gnu_name_list);\n \n \t  /* If we didn't create a PARM_DECL for the formal, this means that\n@@ -4803,7 +4796,7 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n \t\t  || DECL_BY_COMPONENT_PTR_P (get_gnu_tree (gnat_formal))))\n \t    && Ekind (gnat_formal) != E_In_Parameter)\n \t  {\n-\t    /* Get the value to assign to this Out or In Out parameter.  It is\n+\t    /* Get the value to assign to this In Out or Out parameter.  It is\n \t       either the result of the function if there is only a single such\n \t       parameter or the appropriate field from the record returned.  */\n \t    tree gnu_result"}]}