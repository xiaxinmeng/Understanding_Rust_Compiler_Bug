{"sha": "04b633a8c872b91fdb78a8adf30ba922bc4f4157", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDRiNjMzYThjODcyYjkxZmRiNzhhOGFkZjMwYmE5MjJiYzRmNDE1Nw==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@gnat.com", "date": "2004-10-27T13:39:21Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-10-27T13:39:21Z"}, "message": "s-arit64.adb: (Le3): New function, used by Scaled_Divide\n\n2004-10-26  Robert Dewar  <dewar@gnat.com>\n\n\t* s-arit64.adb: (Le3): New function, used by Scaled_Divide\n\t(Sub3): New procedure, used by Scaled_Divide\n\t(Scaled_Divide): Substantial rewrite, avoid duplicated code, and also\n\tcorrect more than one instance of failure to propagate carries\n\tcorrectly.\n\t(Double_Divide): Handle overflow case of largest negative number\n\tdivided by minus one.\n\n\t* s-arit64.ads (Double_Divide): Document that overflow can occur in\n\tthe case of a quotient value out of range.\n\tFix comments.\n\nFrom-SVN: r89663", "tree": {"sha": "7ea13d10c80a2d0637721168e92bd18c827a37c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7ea13d10c80a2d0637721168e92bd18c827a37c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/04b633a8c872b91fdb78a8adf30ba922bc4f4157", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04b633a8c872b91fdb78a8adf30ba922bc4f4157", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04b633a8c872b91fdb78a8adf30ba922bc4f4157", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04b633a8c872b91fdb78a8adf30ba922bc4f4157/comments", "author": null, "committer": null, "parents": [{"sha": "1ae44ba2e358541d7d22f99c1ae370b78cbb289d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ae44ba2e358541d7d22f99c1ae370b78cbb289d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ae44ba2e358541d7d22f99c1ae370b78cbb289d"}], "stats": {"total": 272, "additions": 127, "deletions": 145}, "files": [{"sha": "869a18eda53ee8888c24ad7048d0355af2a27c69", "filename": "gcc/ada/s-arit64.adb", "status": "modified", "additions": 119, "deletions": 136, "changes": 255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04b633a8c872b91fdb78a8adf30ba922bc4f4157/gcc%2Fada%2Fs-arit64.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04b633a8c872b91fdb78a8adf30ba922bc4f4157/gcc%2Fada%2Fs-arit64.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-arit64.adb?ref=04b633a8c872b91fdb78a8adf30ba922bc4f4157", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2002 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -56,10 +56,6 @@ package body System.Arith_64 is\n    pragma Inline (\"+\");\n    --  Length doubling additions\n \n-   function \"-\" (A : Uns64; B : Uns32) return Uns64;\n-   pragma Inline (\"-\");\n-   --  Length doubling subtraction\n-\n    function \"*\" (A, B : Uns32) return Uns64;\n    pragma Inline (\"*\");\n    --  Length doubling multiplication\n@@ -76,6 +72,9 @@ package body System.Arith_64 is\n    pragma Inline (\"&\");\n    --  Concatenate hi, lo values to form 64-bit result\n \n+   function Le3 (X1, X2, X3 : Uns32; Y1, Y2, Y3 : Uns32) return Boolean;\n+   --  Determines if 96 bit value X1&X2&X3 <= Y1&Y2&Y3\n+\n    function Lo (A : Uns64) return Uns32;\n    pragma Inline (Lo);\n    --  Low order half of 64-bit value\n@@ -84,6 +83,9 @@ package body System.Arith_64 is\n    pragma Inline (Hi);\n    --  High order half of 64-bit value\n \n+   procedure Sub3 (X1, X2, X3 : in out Uns32; Y1, Y2, Y3 : in Uns32);\n+   --  Computes X1&X2&X3 := X1&X2&X3 - Y1&Y1&Y3 with mod 2**96 wrap\n+\n    function To_Neg_Int (A : Uns64) return Int64;\n    --  Convert to negative integer equivalent. If the input is in the range\n    --  0 .. 2 ** 63, then the corresponding negative signed integer (obtained\n@@ -131,15 +133,6 @@ package body System.Arith_64 is\n       return A + Uns64 (B);\n    end \"+\";\n \n-   ---------\n-   -- \"-\" --\n-   ---------\n-\n-   function \"-\" (A : Uns64; B : Uns32) return Uns64 is\n-   begin\n-      return A - Uns64 (B);\n-   end \"-\";\n-\n    ---------\n    -- \"/\" --\n    ---------\n@@ -285,6 +278,25 @@ package body System.Arith_64 is\n       return Uns32 (Shift_Right (A, 32));\n    end Hi;\n \n+   ---------\n+   -- Le3 --\n+   ---------\n+\n+   function Le3 (X1, X2, X3 : Uns32; Y1, Y2, Y3 : Uns32) return Boolean is\n+   begin\n+      if X1 < Y1 then\n+         return True;\n+      elsif X1 > Y1 then\n+         return False;\n+      elsif X2 < Y2 then\n+         return True;\n+      elsif X2 > Y2 then\n+         return False;\n+      else\n+         return X3 <= Y3;\n+      end if;\n+   end Le3;\n+\n    --------\n    -- Lo --\n    --------\n@@ -382,11 +394,11 @@ package body System.Arith_64 is\n       Zhi : Uns32 := Hi (Zu);\n       Zlo : Uns32 := Lo (Zu);\n \n-      D1, D2, D3, D4 : Uns32;\n-      --  The dividend, four digits (D1 is high order)\n+      D : array (1 .. 4) of Uns32;\n+      --  The dividend, four digits (D(1) is high order)\n \n-      Q1, Q2 : Uns32;\n-      --  The quotient, two digits (Q1 is high order)\n+      Qd : array (1 .. 2) of Uns32;\n+      --  The quotient digits, two digits (Qd(1) is high order)\n \n       S1, S2, S3 : Uns32;\n       --  Value to subtract, three digits (S1 is high order)\n@@ -408,71 +420,71 @@ package body System.Arith_64 is\n       --  First do the multiplication, giving the four digit dividend\n \n       T1 := Xlo * Ylo;\n-      D4 := Lo (T1);\n-      D3 := Hi (T1);\n+      D (4) := Lo (T1);\n+      D (3) := Hi (T1);\n \n       if Yhi /= 0 then\n          T1 := Xlo * Yhi;\n-         T2 := D3 + Lo (T1);\n-         D3 := Lo (T2);\n-         D2 := Hi (T1) + Hi (T2);\n+         T2 := D (3) + Lo (T1);\n+         D (3) := Lo (T2);\n+         D (2) := Hi (T1) + Hi (T2);\n \n          if Xhi /= 0 then\n             T1 := Xhi * Ylo;\n-            T2 := D3 + Lo (T1);\n-            D3 := Lo (T2);\n-            T3 := D2 + Hi (T1);\n+            T2 := D (3) + Lo (T1);\n+            D (3) := Lo (T2);\n+            T3 := D (2) + Hi (T1);\n             T3 := T3 + Hi (T2);\n-            D2 := Lo (T3);\n-            D1 := Hi (T3);\n+            D (2) := Lo (T3);\n+            D (1) := Hi (T3);\n \n-            T1 := (D1 & D2) + Uns64'(Xhi * Yhi);\n-            D1 := Hi (T1);\n-            D2 := Lo (T1);\n+            T1 := (D (1) & D (2)) + Uns64'(Xhi * Yhi);\n+            D (1) := Hi (T1);\n+            D (2) := Lo (T1);\n \n          else\n-            D1 := 0;\n+            D (1) := 0;\n          end if;\n \n       else\n          if Xhi /= 0 then\n             T1 := Xhi * Ylo;\n-            T2 := D3 + Lo (T1);\n-            D3 := Lo (T2);\n-            D2 := Hi (T1) + Hi (T2);\n+            T2 := D (3) + Lo (T1);\n+            D (3) := Lo (T2);\n+            D (2) := Hi (T1) + Hi (T2);\n \n          else\n-            D2 := 0;\n+            D (2) := 0;\n          end if;\n \n-         D1 := 0;\n+         D (1) := 0;\n       end if;\n \n       --  Now it is time for the dreaded multiple precision division. First\n       --  an easy case, check for the simple case of a one digit divisor.\n \n       if Zhi = 0 then\n-         if D1 /= 0 or else D2 >= Zlo then\n+         if D (1) /= 0 or else D (2) >= Zlo then\n             Raise_Error;\n \n          --  Here we are dividing at most three digits by one digit\n \n          else\n-            T1 := D2 & D3;\n-            T2 := Lo (T1 rem Zlo) & D4;\n+            T1 := D (2) & D (3);\n+            T2 := Lo (T1 rem Zlo) & D (4);\n \n             Qu := Lo (T1 / Zlo) & Lo (T2 / Zlo);\n             Ru := T2 rem Zlo;\n          end if;\n \n       --  If divisor is double digit and too large, raise error\n \n-      elsif (D1 & D2) >= Zu then\n+      elsif (D (1) & D (2)) >= Zu then\n          Raise_Error;\n \n       --  This is the complex case where we definitely have a double digit\n       --  divisor and a dividend of at least three digits. We use the classical\n-      --  multiple division algorithm (see  section (4.3.1) of Knuth's \"The Art\n+      --  multiple division algorithm (see section (4.3.1) of Knuth's \"The Art\n       --  of Computer Programming\", Vol. 2 for a description (algorithm D).\n \n       else\n@@ -511,115 +523,63 @@ package body System.Arith_64 is\n \n          --  Note that when we scale up the dividend, it still fits in four\n          --  digits, since we already tested for overflow, and scaling does\n-         --  not change the invariant that (D1 & D2) >= Zu.\n-\n-         T1 := Shift_Left (D1 & D2, Scale);\n-         D1 := Hi (T1);\n-         T2 := Shift_Left (0 & D3, Scale);\n-         D2 := Lo (T1) or Hi (T2);\n-         T3 := Shift_Left (0 & D4, Scale);\n-         D3 := Lo (T2) or Hi (T3);\n-         D4 := Lo (T3);\n-\n-         --  Compute first quotient digit. We have to divide three digits by\n-         --  two digits, and we estimate the quotient by dividing the leading\n-         --  two digits by the leading digit. Given the scaling we did above\n-         --  which ensured the first bit of the divisor is set, this gives an\n-         --  estimate of the quotient that is at most two too high.\n-\n-         if D1 = Zhi then\n-            Q1 := 2 ** 32 - 1;\n-         else\n-            Q1 := Lo ((D1 & D2) / Zhi);\n-         end if;\n-\n-         --  Compute amount to subtract\n-\n-         T1 := Q1 * Zlo;\n-         T2 := Q1 * Zhi;\n-         S3 := Lo (T1);\n-         T1 := Hi (T1) + Lo (T2);\n-         S2 := Lo (T1);\n-         S1 := Hi (T1) + Hi (T2);\n-\n-         --  Adjust quotient digit if it was too high\n-\n-         loop\n-            exit when S1 < D1;\n-\n-            if S1 = D1 then\n-               exit when S2 < D2;\n-\n-               if S2 = D2 then\n-                  exit when S3 <= D3;\n-               end if;\n+         --  not change the invariant that (D (1) & D (2)) >= Zu.\n+\n+         T1 := Shift_Left (D (1) & D (2), Scale);\n+         D (1) := Hi (T1);\n+         T2 := Shift_Left (0 & D (3), Scale);\n+         D (2) := Lo (T1) or Hi (T2);\n+         T3 := Shift_Left (0 & D (4), Scale);\n+         D (3) := Lo (T2) or Hi (T3);\n+         D (4) := Lo (T3);\n+\n+         --  Loop to compute quotient digits, runs twice for Qd(1) and Qd(2).\n+\n+         for J in 0 .. 1 loop\n+\n+            --  Compute next quotient digit. We have to divide three digits by\n+            --  two digits. We estimate the quotient by dividing the leading\n+            --  two digits by the leading digit. Given the scaling we did above\n+            --  which ensured the first bit of the divisor is set, this gives\n+            --  an estimate of the quotient that is at most two too high.\n+\n+            if D (J + 1) = Zhi then\n+               Qd (J + 1) := 2 ** 32 - 1;\n+            else\n+               Qd (J + 1) := Lo ((D (J + 1) & D (J + 2)) / Zhi);\n             end if;\n \n-            Q1 := Q1 - 1;\n+            --  Compute amount to subtract\n \n-            T1 := (S2 & S3) - Zlo;\n+            T1 := Qd (J + 1) * Zlo;\n+            T2 := Qd (J + 1) * Zhi;\n             S3 := Lo (T1);\n-            T1 := (S1 & S2) - Zhi;\n+            T1 := Hi (T1) + Lo (T2);\n             S2 := Lo (T1);\n-            S1 := Hi (T1);\n-         end loop;\n+            S1 := Hi (T1) + Hi (T2);\n \n-         --  Subtract from dividend (note: do not bother to set D1 to\n-         --  zero, since it is no longer needed in the calculation).\n+            --  Adjust quotient digit if it was too high\n \n-         T1 := (D2 & D3) - S3;\n-         D3 := Lo (T1);\n-         T1 := (D1 & Hi (T1)) - S2;\n-         D2 := Lo (T1);\n+            loop\n+               exit when Le3 (S1, S2, S3, D (J + 1), D (J + 2), D (J + 3));\n+               Qd (J + 1) := Qd (J + 1) - 1;\n+               Sub3 (S1, S2, S3, 0, Zhi, Zlo);\n+            end loop;\n \n-         --  Compute second quotient digit in same manner\n+            --  Now subtract S1&S2&S3 from D1&D2&D3 ready for next step\n \n-         if D2 = Zhi then\n-            Q2 := 2 ** 32 - 1;\n-         else\n-            Q2 := Lo ((D2 & D3) / Zhi);\n-         end if;\n-\n-         T1 := Q2 * Zlo;\n-         T2 := Q2 * Zhi;\n-         S3 := Lo (T1);\n-         T1 := Hi (T1) + Lo (T2);\n-         S2 := Lo (T1);\n-         S1 := Hi (T1) + Hi (T2);\n-\n-         loop\n-            exit when S1 < D2;\n-\n-            if S1 = D2 then\n-               exit when S2 < D3;\n-\n-               if S2 = D3 then\n-                  exit when S3 <= D4;\n-               end if;\n-            end if;\n-\n-            Q2 := Q2 - 1;\n-\n-            T1 := (S2 & S3) - Zlo;\n-            S3 := Lo (T1);\n-            T1 := (S1 & S2) - Zhi;\n-            S2 := Lo (T1);\n-            S1 := Hi (T1);\n+            Sub3 (D (J + 1), D (J + 2), D (J + 3), S1, S2, S3);\n          end loop;\n \n-         T1 := (D3 & D4) - S3;\n-         D4 := Lo (T1);\n-         T1 := (D2 & Hi (T1)) - S2;\n-         D3 := Lo (T1);\n-\n          --  The two quotient digits are now set, and the remainder of the\n-         --  scaled division is in (D3 & D4). To get the remainder for the\n+         --  scaled division is in D3&D4. To get the remainder for the\n          --  original unscaled division, we rescale this dividend.\n+\n          --  We rescale the divisor as well, to make the proper comparison\n          --  for rounding below.\n \n-         Qu := Q1 & Q2;\n-         Ru := Shift_Right (D3 & D4, Scale);\n+         Qu := Qd (1) & Qd (2);\n+         Ru := Shift_Right (D (3) & D (4), Scale);\n          Zu := Shift_Right (Zu, Scale);\n       end if;\n \n@@ -655,9 +615,32 @@ package body System.Arith_64 is\n             Q := To_Pos_Int (Qu);\n          end if;\n       end if;\n-\n    end Scaled_Divide;\n \n+   ----------\n+   -- Sub3 --\n+   ----------\n+\n+   procedure Sub3 (X1, X2, X3 : in out Uns32; Y1, Y2, Y3 : in Uns32) is\n+   begin\n+      if Y3 > X3 then\n+         if X2 = 0 then\n+            X1 := X1 - 1;\n+         end if;\n+\n+         X2 := X2 - 1;\n+      end if;\n+\n+      X3 := X3 - Y3;\n+\n+      if Y2 > X2 then\n+         X1 := X1 - 1;\n+      end if;\n+\n+      X2 := X2 - Y2;\n+      X1 := X1 - Y1;\n+   end Sub3;\n+\n    -------------------------------\n    -- Subtract_With_Ovflo_Check --\n    -------------------------------"}, {"sha": "55afeaee40365b6cd1bc62deaa518c2e44dea9a4", "filename": "gcc/ada/s-arit64.ads", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04b633a8c872b91fdb78a8adf30ba922bc4f4157/gcc%2Fada%2Fs-arit64.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04b633a8c872b91fdb78a8adf30ba922bc4f4157/gcc%2Fada%2Fs-arit64.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-arit64.ads?ref=04b633a8c872b91fdb78a8adf30ba922bc4f4157", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---        Copyright (C) 1994,1995,1996 Free Software Foundation, Inc.       --\n+--          Copyright (C) 1992-2004, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -52,7 +52,7 @@ pragma Pure (Arith_64);\n \n    function Multiply_With_Ovflo_Check (X, Y : Int64) return Int64;\n    --  Raises Constraint_Error if product of operands overflows 64\n-   --  bits, otherwise returns the 64-bit signed integer difference.\n+   --  bits, otherwise returns the 64-bit signed integer product.\n \n    procedure Scaled_Divide\n      (X, Y, Z : Int64;\n@@ -71,12 +71,11 @@ pragma Pure (Arith_64);\n       Q, R    : out Int64;\n       Round   : Boolean);\n    --  Performs the division X / (Y * Z), storing the quotient in Q and\n-   --  the remainder in R. Constraint_Error is raised if Y or Z is zero.\n-   --  Round indicates if the result should be rounded. If Round is False,\n-   --  then Q, R are the normal quotient and remainder from a truncating\n-   --  division. If Round is True, then Q is the rounded quotient. The\n-   --  remainder R is not affected by the setting of the Round flag. The\n-   --  result is known to be in range except for the noted possibility of\n-   --  Y or Z being zero, so no other overflow checks are required.\n+   --  the remainder in R. Constraint_Error is raised if Y or Z is zero,\n+   --  or if the quotient does not fit in 64-bits. Round indicates if the\n+   --  result should be rounded. If Round is False, then Q, R are the normal\n+   --  quotient and remainder from a truncating division. If Round is True,\n+   --  then Q is the rounded quotient. The remainder R is not affected by the\n+   --  setting of the Round flag.\n \n end System.Arith_64;"}]}