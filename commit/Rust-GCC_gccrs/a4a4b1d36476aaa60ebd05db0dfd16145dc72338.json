{"sha": "a4a4b1d36476aaa60ebd05db0dfd16145dc72338", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTRhNGIxZDM2NDc2YWFhNjBlYmQwNWRiMGRmZDE2MTQ1ZGM3MjMzOA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2004-02-04T05:13:43Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2004-02-04T05:13:43Z"}, "message": "config.gcc: Remove obsolete ports and configurations.\n\n\tgcc/\n\t* config.gcc: Remove obsolete ports and configurations.\n\t* config/linux-aout.h, config/netware.h,\n\tconfig/t-linux-gnulibc1, config/d30v/abi,\n\tconfig/d30v/d30v-protos.h, config/d30v/d30v.c,\n\tconfig/d30v/d30v.h, config/d30v/d30v.md,\n\tconfig/d30v/libgcc1.asm, config/d30v/t-d30v,\n\tconfig/dsp16xx/dsp16xx-modes.def,\n\tconfig/dsp16xx/dsp16xx-protos.h, config/dsp16xx/dsp16xx.c,\n\tconfig/dsp16xx/dsp16xx.h, config/dsp16xx/dsp16xx.md,\n\tconfig/i370/README, config/i370/i370-c.c,\n\tconfig/i370/i370-protos.h, config/i370/i370.c,\n\tconfig/i370/i370.h, config/i370/i370.md, config/i370/linux.h,\n\tconfig/i370/mvs.h, config/i370/oe.h, config/i370/t-i370,\n\tconfig/i386/freebsd-aout.h, config/i386/linux-aout.h,\n\tconfig/i386/moss.h, config/i386/netware.h,\n\tconfig/i386/svr3.ifile, config/i386/svr3dbx.h,\n\tconfig/i386/svr3gas.h, config/i386/svr3z.ifile,\n\tconfig/i386/t-udk, config/i386/udk.h, config/i386/vsta.h,\n\tconfig/i960/i960-c.c, config/i960/i960-coff.h,\n\tconfig/i960/i960-modes.def, config/i960/i960-protos.h,\n\tconfig/i960/i960.c, config/i960/i960.h, config/i960/i960.md,\n\tconfig/i960/rtems.h, config/i960/t-960bare,\n\tconfig/m68k/hp310.h, config/m68k/hp320.h,\n\tconfig/m68k/hp320base.h, config/m68k/m68kv4.h,\n\tconfig/m68k/netbsd.h, config/m68k/sgs.h, config/m68k/t-hp320:\n\tRemove.\n\t* doc/extend.texi, doc/install.texi, doc/invoke.texi,\n\tdoc/md.texi: Remove mentions of obsolete ports.\n\n\ttestsuite/\n\t* gcc.dg/20020312-2.c, gcc.dg/builtin-inf-1.c,\n\tgcc.dg/sibcall-3.c, gcc.dg/sibcall-4.c, gcc.dg/cpp/assert4.c:\n\tRemove mentions of obsolete ports.\n\nFrom-SVN: r77216", "tree": {"sha": "ce646f5c227e247e4200d85892382a8f5bb625d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ce646f5c227e247e4200d85892382a8f5bb625d6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a4a4b1d36476aaa60ebd05db0dfd16145dc72338", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4a4b1d36476aaa60ebd05db0dfd16145dc72338", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4a4b1d36476aaa60ebd05db0dfd16145dc72338", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4a4b1d36476aaa60ebd05db0dfd16145dc72338/comments", "author": null, "committer": null, "parents": [{"sha": "c3bf16ff7dec47581f450b1a486cfdf9d566927e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3bf16ff7dec47581f450b1a486cfdf9d566927e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3bf16ff7dec47581f450b1a486cfdf9d566927e"}], "stats": {"total": 35875, "additions": 45, "deletions": 35830}, "files": [{"sha": "2c62f0142fb1d7576c963c908b436dd0c653ffc4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4a4b1d36476aaa60ebd05db0dfd16145dc72338/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4a4b1d36476aaa60ebd05db0dfd16145dc72338/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a4a4b1d36476aaa60ebd05db0dfd16145dc72338", "patch": "@@ -1,3 +1,34 @@\n+2004-02-04  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* config.gcc: Remove obsolete ports and configurations.\n+\t* config/linux-aout.h, config/netware.h,\n+\tconfig/t-linux-gnulibc1, config/d30v/abi,\n+\tconfig/d30v/d30v-protos.h, config/d30v/d30v.c,\n+\tconfig/d30v/d30v.h, config/d30v/d30v.md,\n+\tconfig/d30v/libgcc1.asm, config/d30v/t-d30v,\n+\tconfig/dsp16xx/dsp16xx-modes.def,\n+\tconfig/dsp16xx/dsp16xx-protos.h, config/dsp16xx/dsp16xx.c,\n+\tconfig/dsp16xx/dsp16xx.h, config/dsp16xx/dsp16xx.md,\n+\tconfig/i370/README, config/i370/i370-c.c,\n+\tconfig/i370/i370-protos.h, config/i370/i370.c,\n+\tconfig/i370/i370.h, config/i370/i370.md, config/i370/linux.h,\n+\tconfig/i370/mvs.h, config/i370/oe.h, config/i370/t-i370,\n+\tconfig/i386/freebsd-aout.h, config/i386/linux-aout.h,\n+\tconfig/i386/moss.h, config/i386/netware.h,\n+\tconfig/i386/svr3.ifile, config/i386/svr3dbx.h,\n+\tconfig/i386/svr3gas.h, config/i386/svr3z.ifile,\n+\tconfig/i386/t-udk, config/i386/udk.h, config/i386/vsta.h,\n+\tconfig/i960/i960-c.c, config/i960/i960-coff.h,\n+\tconfig/i960/i960-modes.def, config/i960/i960-protos.h,\n+\tconfig/i960/i960.c, config/i960/i960.h, config/i960/i960.md,\n+\tconfig/i960/rtems.h, config/i960/t-960bare,\n+\tconfig/m68k/hp310.h, config/m68k/hp320.h,\n+\tconfig/m68k/hp320base.h, config/m68k/m68kv4.h,\n+\tconfig/m68k/netbsd.h, config/m68k/sgs.h, config/m68k/t-hp320:\n+\tRemove.\n+\t* doc/extend.texi, doc/install.texi, doc/invoke.texi,\n+\tdoc/md.texi: Remove mentions of obsolete ports.\n+\n 2004-02-04  Jan Hubicka  <jh@suse.cz>\n \n \t* alias.c (find_base_term, get_addr):  Do not dereference NULL"}, {"sha": "42aab18f74b48f574ffdd8149b5df9150bb37444", "filename": "gcc/config.gcc", "status": "modified", "additions": 2, "deletions": 199, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4a4b1d36476aaa60ebd05db0dfd16145dc72338/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4a4b1d36476aaa60ebd05db0dfd16145dc72338/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=a4a4b1d36476aaa60ebd05db0dfd16145dc72338", "patch": "@@ -58,7 +58,7 @@\n #\t\t\ttm_file=\"${tm_file} dbxelf.h elfos.h svr4.h ${cpu_type.h}/elf.h\"\n #\t\t\tNote that the preferred order is:\n #\t\t\t- specific target header \"${cpu_type}/${cpu_type.h}\"\n-#\t\t\t- generic headers like dbxelf.h elfos.h, netware.h, etc.\n+#\t\t\t- generic headers like dbxelf.h elfos.h, etc.\n #\t\t\t- specializing target headers like ${cpu_type.h}/elf.h\n #\t\t\tThis helps to keep OS specific stuff out of the CPU\n #\t\t\tdefining header ${cpu_type}/${cpu_type.h}.\n@@ -182,23 +182,7 @@ md_file=\n \n # Obsolete configurations.\n case ${target} in\n- d30v-* | \\\n- dsp16xx-* | \\\n- i370-* | \\\n- i960-* | \\\n- i?86-moss-msdos | i?86-*-moss* | \\\n- i?86-ncr-sysv4* | \\\n- i?86-*-netware | \\\n- i?86-*-freebsd2* | i?86-*-freebsd*aout* | \\\n- i?86-*-linux*aout* | \\\n- i?86-*-linux*libc1* | \\\n- i?86-*-interix | \\\n- i?86-*-mach* | \\\n- i?86-*-udk* | \\\n- i?86-*-sysv[123]* | \\\n- i386-*-vsta | \\\n- m68k-hp-hpux* | m68000-hp-hpux* | \\\n- m68k-*-sysv4*)\n+ dummy*)\n     if test \"x$enable_obsolete\" != xyes; then\n       echo \"*** Configuration ${target} is obsolete.\" >&2\n       echo \"*** Specify --enable-obsolete to build it anyway.\" >&2\n@@ -726,12 +710,6 @@ cris-*-linux*)\n \ttm_file=\"dbxelf.h elfos.h svr4.h ${tm_file} linux.h cris/linux.h\"\n \ttmake_file=\"cris/t-cris t-slibgcc-elf-ver cris/t-linux\"\n \t;;\n-d30v-*)\n-\ttm_file=\"dbxelf.h elfos.h svr4.h ${tm_file}\"\n-\t;;\n-dsp16xx-*)\n-\tuse_fixproto=yes\n-\t;;\n fr30-*-elf)\n \ttm_file=\"dbxelf.h elfos.h svr4.h ${tm_file}\"\n \ttmake_file=fr30/t-fr30\n@@ -900,16 +878,6 @@ i[34567]86-*-elf*)\n \ttmake_file=\"i386/t-i386elf t-svr4\"\n \tuse_fixproto=yes\n \t;;\n-i[34567]86-ncr-sysv4*)\t\t# NCR 3000 - ix86 running system V.4\n-\txm_defines=\"SMALL_ARG_MAX\"\n-\ttm_file=\"${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h svr4.h i386/sysv4.h i386/sysv4-cpp.h\"\n-\textra_parts=\"crtbegin.o crtend.o\"\n-\ttmake_file=i386/t-crtpic\n-\tuse_fixproto=yes\n-\t;;\n-i[34567]86-*-netware)\t\t# Intel 80386's running netware\n-\ttm_file=\"${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h svr4.h i386/sysv4.h netware.h i386/netware.h\"\n-\t;;\n i[34567]86-sequent-ptx4* | i[34567]86-sequent-sysv4*)\n \tif test x$gas = xyes\n \tthen\n@@ -930,10 +898,6 @@ i[34567]86-*-beoself* | i[34567]86-*-beos*)\n \ttm_file=\"${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h svr4.h i386/beos-elf.h\"\n \textra_parts='crtbegin.o crtend.o'\n \t;;\n-i[34567]86-*-freebsd2 | i[34567]86-*-freebsd2.* | i[34567]86-*-freebsd*aout*)\n-\ttm_file=\"${tm_file} i386/unix.h i386/bsd.h i386/gas.h i386/gstabs.h i386/freebsd-aout.h\"\n-\ttmake_file=t-freebsd\n-\t;;\n i[34567]86-*-freebsd*)\n \ttm_file=\"${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h ${fbsd_tm_file} i386/freebsd.h\"\n \t;;\n@@ -963,23 +927,6 @@ i[34567]86-*-coff*)\n \ttm_file=\"${tm_file} i386/unix.h i386/bsd.h i386/gas.h dbxcoff.h i386/i386-coff.h\"\n \tuse_fixproto=yes\n \t;;\n-i[34567]86-*-linux*aout*)\t# Intel 80386's running GNU/Linux\n-\t\t\t\t# with a.out format\n-\ttmake_file=\"i386/t-crtstuff\"\n-\ttm_file=\"${tm_file} i386/unix.h i386/bsd.h i386/gas.h i386/gstabs.h linux-aout.h i386/linux-aout.h\"\n-\tgnu_ld=yes\n-\t;;\n-i[34567]86-*-linux*libc1)\t# Intel 80386's running GNU/Linux\n-\t\t\t\t# with ELF format using the\n-\t\t\t\t# GNU/Linux C library 5\n-\ttm_file=\"${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h svr4.h linux.h i386/linux.h\"\n-\ttmake_file=\"t-slibgcc-elf-ver t-linux t-linux-gnulibc1 i386/t-crtstuff\"\n-\textra_parts=\"crtbegin.o crtbeginS.o crtend.o crtendS.o\"\n-\tgnu_ld=yes\n-\tif test x$enable_threads = xyes; then\n-\t\tthread_file='single'\n-\tfi\n-\t;;\n i[34567]86-*-linux*)\t# Intel 80386's running GNU/Linux\n \t\t\t# with ELF format using glibc 2\n \t\t\t# aka GNU/Linux C library 6\n@@ -1006,13 +953,6 @@ i[34567]86-pc-msdosdjgpp*)\n \tgnu_ld=yes\n \tgas=yes\n \t;;\n-i[34567]86-moss-msdos* | i[34567]86-*-moss*)\n-\ttm_file=\"${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h svr4.h linux.h i386/linux.h i386/moss.h\"\n-\ttmake_file=t-libc-ok\n-\tgnu_ld=yes\n-\tgas=yes\n-\tuse_fixproto=yes\n-\t;;\n i[34567]86-*-lynxos*)\n \tif test x$gas = xyes\n \tthen\n@@ -1022,12 +962,6 @@ i[34567]86-*-lynxos*)\n \tfi\n \tuse_fixproto=yes\n \t;;\n-i[34567]86-*-mach*)\n-\ttm_file=\"${tm_file} i386/unix.h i386/bsd.h i386/gas.h i386/gstabs.h i386/mach.h\"\n-#\ttmake_file=t-libc-ok\n-\tuse_collect2=yes\n-\tuse_fixproto=yes\n-\t;;\n i[34567]86-*-nto-qnx*)\n \ttm_file=\"${tm_file} i386/att.h dbxelf.h tm-dwarf2.h elfos.h svr4.h i386/unix.h i386/nto.h\"\n \ttmake_file=i386/t-nto\n@@ -1097,38 +1031,6 @@ i[34567]86-*-sysv4*)\t\t# Intel 80386's running system V.4\n \textra_parts=\"crtbegin.o crtend.o\"\n \tuse_fixproto=yes\n \t;;\n-i[34567]86-*-udk*)      # Intel x86 on SCO UW/OSR5 Dev Kit\n-\ttm_file=\"${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h svr4.h i386/sysv4.h i386/sysv5.h i386/udk.h\"\n-\ttmake_file=\"i386/t-crtpic i386/t-udk t-svr4\"\n-\textra_parts=\"crtbegin.o crtend.o\"\n-\tuse_fixproto=yes\n-\t;;\n-i[34567]86-*-sysv*)\t\t# Intel 80386's running system V\n-\tif test x$gas = xyes\n-\tthen\n-\t\tif test x$stabs = xyes\n-\t\tthen\n-\t\t\ttm_file=\"${tm_file} i386/unix.h i386/bsd.h i386/gas.h i386/svr3gas.h i386/svr3dbx.h\"\n-\t\t\ttmake_file=i386/t-svr3dbx\n-\t\t\textra_parts=\"svr3.ifile svr3z.ifile\"\n-\t\telse\n-\t\t\ttm_file=\"${tm_file} i386/unix.h i386/bsd.h i386/gas.h i386/svr3gas.h\"\n-\t\t\textra_parts=\"crtbegin.o crtend.o\"\n-\t\t\ttmake_file=i386/t-crtstuff\n-\t\tfi\n-\telse\n-\t\ttm_file=\"${tm_file} svr3.h i386/unix.h i386/att.h i386/sysv3.h\"\n-\t\textra_parts=\"crtbegin.o crtend.o\"\n-\t\ttmake_file=i386/t-crtstuff\n-\tfi\n-\ttmake_file=\"$tmake_file i386/t-crtpic\"\n-\tuse_fixproto=yes\n-\t;;\n-i386-*-vsta)\t\t\t# Intel 80386's running VSTa kernel\n-\txm_file=\"i386/xm-vsta.h\"\n-\ttm_file=\"${tm_file} i386/unix.h i386/bsd.h i386/gas.h i386/vsta.h\"\n-\tuse_fixproto=yes\n-\t;;\n i[4567]86-wrs-vxworks)\n \ttm_file=\"${tm_file} i386/sysv4.h i386/unix.h i386/vxworks.h\"\n \ttmake_file=\"${tmake_file} i386/t-vxworks\"\n@@ -1180,17 +1082,6 @@ i[34567]86-*-interix3*)\n \t\ttm_file=\"${tm_file} dbxcoff.h\"\n \tfi\n \t;;\n-i[34567]86-*-interix*)\n-\ttm_file=\"${tm_file} i386/unix.h i386/bsd.h i386/gas.h i386/i386-interix.h interix.h\"\n-\ttmake_file=\"i386/t-interix\"\n-\textra_objs=winnt.o\n-\tif test x$enable_threads = xyes ; then\n-\t\tthread_file='posix'\n-\tfi\n-\tif test x$stabs = xyes ; then\n-\t\ttm_file=\"${tm_file} dbxcoff.h\"\n-\tfi\n-\t;;\n i[34567]86-*-kaos*)\n \ttm_file=\"${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h i386/i386elf.h kaos.h i386/kaos-i386.h\"\n \ttmake_file=\"i386/t-i386elf t-svr4\"\n@@ -1201,25 +1092,6 @@ i860-*-sysv4*)\n         extra_parts=\"crtbegin.o crtend.o\"\n \tuse_fixproto=yes\n         ;;\n-i960-*-coff*)\n-\ttm_file=\"${tm_file} dbxcoff.h i960/i960-coff.h libgloss.h\"\n-\ttmake_file=i960/t-960bare\n-\tc_target_objs=\"i960-c.o\"\n-\tcxx_target_objs=\"i960-c.o\"\n-\t;;\n-i960-*-rtems)\n-\ttmake_file=\"i960/t-960bare t-rtems\"\n-\ttm_file=\"${tm_file} dbxcoff.h i960/i960-coff.h i960/rtems.h rtems.h\"\n-\tc_target_objs=\"i960-c.o\"\n-\tcxx_target_objs=\"i960-c.o\"\n-\t;;\n-i960-*-*)\t\t\t# Default i960 environment.\n-\tuse_collect2=yes\n-\ttmake_file=i960/t-960bare\n-\tc_target_objs=\"i960-c.o\"\n-\tcxx_target_objs=\"i960-c.o\"\n-\tuse_fixproto=yes\n-\t;;\n ia64*-*-elf*)\n \ttm_file=\"${tm_file} dbxelf.h elfos.h ia64/sysv4.h ia64/elf.h\"\n \ttmake_file=\"ia64/t-ia64\"\n@@ -1324,37 +1196,6 @@ m68hc12-*-*|m6812-*-*)\n \ttmake_file=\"m68hc11/t-m68hc11-gas\"\n \tuse_fixproto=yes\n         ;;\n-m68000-hp-hpux*)\t\t# HP 9000 series 300\n-\ttm_file=\"m68k/hp320base.h m68k/m68k.h m68k/hp320.h m68k/hp310.h\"\n-\ttm_defines=\"TARGET_DEFAULT=0\" # 68000, no 68881, no bitfield ops\n-\tif test x$gas = xyes\n-\tthen\n-\t\ttm_defines=\"${tm_defines} DBX_DEBUGGING_INFO=1 USE_GAS\"\n-\tfi\n-\ttmake_file=m68k/t-hp320\n-\tuse_collect2=yes\n-\tuse_fixproto=yes\n-\t;;\n-m68k-hp-hpux7*)\t# HP 9000 series 300 running HPUX version 7.\n-\ttm_file=\"m68k/hp320base.h m68k/m68k.h m68k/hp320.h\"\n-\tif test x$gas = xyes\n-\tthen\n-\t\ttm_defines=\"DBX_DEBUGGING_INFO=1 USE_GAS\"\n-\telse\n-\t\ttm_defines=\"NO_DOT_IN_LABEL NO_BUGS\"\n-\tfi\n-\tuse_collect2=yes\n-\tuse_fixproto=yes\n-\t;;\n-m68k-hp-hpux*)\t# HP 9000 series 300\n-\ttm_file=\"m68k/hp320base.h m68k/m68k.h m68k/hp320.h\"\n-\tif test x$gas = xyes\n-\tthen\n-\t\ttm_defines=\"DBX_DEBUGGING_INFO=1 USE_GAS\"\n-\tfi\n-\tuse_collect2=yes\n-\tuse_fixproto=yes\n-\t;;\n m68k-*-aout*)\n \ttmake_file=m68k/t-m68kbare\n \ttm_file=\"m68k/m68k.h m68k/m68k-none.h m68k/m68kemb.h m68k/m68k-aout.h libgloss.h\"\n@@ -1384,34 +1225,6 @@ m68010-*-netbsdelf* | m68k*-*-netbsdelf*)\n \t\t;;\n \tesac\n \t;;\n-m68k*-*-netbsd*)\n-    if test \"x$enable_obsolete\" != xyes; then\n-      echo \"*** Configuration ${target} is obsolete.\" >&2\n-      echo \"*** Specify --enable-obsolete to build it anyway.\" >&2\n-      echo \"*** Support will be REMOVED in the next major release of GCC,\" >&2\n-      echo \"*** unless a maintainer comes forward.\" >&2\n-      exit 1\n-    fi\n-\ttm_file=\"m68k/m68k.h netbsd.h netbsd-aout.h m68k/netbsd.h\"\n-\ttmake_file=t-netbsd\n-\textra_parts=\"\"\n-\tuse_collect2=yes\n-\t;;\n-m68k*-*-openbsd*)\n-\t# needed to unconfuse gdb\n-\ttm_defines=\"OBSD_OLD_GAS TARGET_DEFAULT=(MASK_68020|MASK_68881|MASK_BITFIELD)\"\n-\ttm_file=\"m68k/m68k.h openbsd.h m68k/openbsd.h\"\n-\ttmake_file=\"t-libc-ok t-openbsd m68k/t-openbsd\"\n-\t# we need collect2 until our bug is fixed...\n-\tuse_collect2=yes\n-\t;;\n-m68k-*-sysv4*)\t\t\t# Motorola m68k's running system V.4\n-\ttm_file=\"m68k/m68k.h m68k/sgs.h dbxelf.h elfos.h svr4.h m68k/m68kv4.h\"\n-\ttm_defines=\"MOTOROLA SGS SGS_CMP_ORDER SGS_SWITCH_TABLES\"\n-\ttmake_file=t-svr4\n-\textra_parts=\"crtbegin.o crtend.o\"\n-\tuse_fixproto=yes\n-\t;;\n m68k-*-uclinux*)\t\t# Motorola m68k/ColdFire running uClinux with uClibc\n \ttm_file=\"m68k/m68k.h m68k/m68k-none.h m68k/m68kelf.h dbxelf.h elfos.h m68k/uclinux.h\"\n  \ttm_defines=\"MOTOROLA USE_GAS\"\n@@ -2214,16 +2027,6 @@ vax-*-ultrix*)\t\t\t# VAXen running ultrix\n \ttm_file=\"${tm_file} vax/ultrix.h\"\n \tuse_fixproto=yes\n \t;;\n-vax-*-*)\t\t\t# VAX default entry\n-    if test \"x$enable_obsolete\" != xyes; then\n-      echo \"*** Configuration ${target} is obsolete.\" >&2\n-      echo \"*** Specify --enable-obsolete to build it anyway.\" >&2\n-      echo \"*** Support will be REMOVED in the next major release of GCC,\" >&2\n-      echo \"*** unless a maintainer comes forward.\" >&2\n-      exit 1\n-    fi\n-\tuse_fixproto=yes\n-\t;;\n xscale-*-elf)\n \ttm_file=\"arm/xscale-elf.h dbxelf.h elfos.h arm/unknown-elf.h arm/elf.h arm/aout.h arm/arm.h\"\n \ttmake_file=arm/t-xscale-elf"}, {"sha": "c706e94f63fd6b7188e10318637d37a716790380", "filename": "gcc/config/d30v/abi", "status": "removed", "additions": 0, "deletions": 231, "changes": 231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fd30v%2Fabi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fd30v%2Fabi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fd30v%2Fabi?ref=c3bf16ff7dec47581f450b1a486cfdf9d566927e", "patch": "@@ -1,231 +0,0 @@\n--*- Text -*-\n-\n-This document describes the proposed ABI for the D30V processor.  This is\n-revision 2 of the document.\n-\n-Revision history:\n-\n-Revision 1:\n-\tOriginal revision of this document.\n-\n-Revision 2:\n-\tDone after consultation with Mitsubshi about the calling sequence.\n-\tThis revision now reduces the number of registers the compiler will not\n-\ttouch from 18 registers down to 8.\n-\n-\tRegister 1 is now a normal temporary register, since mvfacc rx,ay,32 is\n-\tlegal.\n-\n-\tArguments greater than 4 bytes must be passed in an even register or at\n-\ta double word alignment.\n-\n-\tThe va_list type is a structure, not a char *.\n-\n-\tThe stack must be aligned to 8 byte boundary.  Doubles and long longs\n-\tmust also be aligned to 8 byte boundaries.\n-\n-\tSystem calls are specified via trap 31.\n-\n-Revision 3:\n-\tI added discussion about compiler switches.\n-\n-Register usage:\n-===============\n-\n-\tRegisters\tCall Status\tUsage\n-\t---------\t-----------\t-----\n-\tR0\t\thardware\tHardwired to 0\n-\tR1\t\tvolatile\ttemp\n-\tR2\t\tvolatile\tArg 1 and main return value.\n-\tR3\t\tvolatile\tArg 2 and low bits of 64 bit returns\n-\tR4 - R17\tvolatile\tArgs 3-16\n-\tR18\t\tvolatile\tStatic chain if used\n-\tR19 - R25\tvolatile\ttemps\n-\tR26 - R33\tsaved\t\tReserved for user use\n-\tR34 - R60\tsaved\t\tRegisters preserved across calls\n-\tR61\t\tsaved\t\tFrame pointer if needed.\n-\tR62\t\tsaved\t\tReturn address pointer (hardware)\n-\tR63\t\tsaved\t\tStack pointer\n-\tCR0 - CR3\thardware\t{normal,backup} {psw,pc}\n-\tCR4 - CR6\thardware\tReserved for future use\n-\tCR7 - CR9\tvolatile\tRepeat count, addresses\n-\tCR10 - CR11\tsaved\t\tModulo start/end\n-\tCR12 - CR14\thardware\tReserved for future use\n-\tCR15 - CR17\thardware\tInterrupt support\n-\tF0 - F1\t\tvolatile\tExecution flags\n-\tF2 - F3\t\tvolatile\tGeneral flags\n-\tF4 - F7\t\tvolatile\tSpecial purpose flags\n-\tA0\t\tvolatile\tAccumulator\n-\tA1\t\tsaved\t\tAccumulator\n-\n-Notes on the register usage:\n-============================\n-\n-   1)\tR61 will hold the frame pointer if it is needed.  Normally the frame\n-\tpointer will not be needed, in which case this will become another\n-\tsaved register.\n-\n-   2)\tRepeat instructions and delayed branches cannot cross call boundaries.\n-\tSimilarly, all flags are assumed to not be preserved across calls.\n-\n-   3)\tSince so many registers are available, I reserved 8 registers (r26-r33)\n-\tfor the user to use for any purpose (global variables, interrupt\n-\troutines, thread pointer, etc.).  These registers will not be used by\n-\tthe compiler for any purpose.\n-\n-   4)\tOne of the two accumulators is saved across calls.\n-\n-   5)\tDoubles and long longs will only be allocated to even/odd register\n-\tpairs to allow use of the ld2w/st2w instructions.\n-\n-Miscellaneous call information:\n-===============================\n-\n-   1)\tStructures are passed in registers, rounding them up to word\n-\tboundaries.\n-\n-   2)\tAny argument that is greater than word size (4 bytes) must be aligned\n-\tto a double word boundary and/or start in an even register.  The\n-\tintention here is to be able to use the ld2w/st2w instructions for\n-\tmoving doubles and long longs.\n-\n-   3)\tVariable argument functions are called with the same calling sequence\n-\tas non-variable argument functions.  When called, a variable argument\n-\tfunction first saves the 16 registers (R2 - R17) used for passing\n-\targuments.  The va_list type is a structure.  The first element of the\n-\tstructure is a pointer to the first word saved on the stack, and the\n-\tsecond element is a number that gives which argument number is being\n-\tprocessed.\n-\n-   4)\tWord and double word sized structures/unions are returned in registers,\n-\tother functions returning structures expect a temporary area address to\n-\tbe passed as the first argument.\n-\n-\n-The stack frame when a function is called looks like:\n-\n-high\t\t|  ....\t\t\t\t|\n-\t\t+-------------------------------+\n-\t\t| Argument word #20\t\t|\n-\t\t+-------------------------------+\n-\t\t| Argument word #19\t\t|\n-\t\t+-------------------------------+\n-\t\t| Argument word #18\t\t|\n-\t\t+-------------------------------+\n-\t\t| Argument word #17\t\t|\n-low\tSP---->\t+-------------------------------+\n-\n-After the prologue is executed, the stack frame will look like:\n-\n-high\t\t|  ....\t\t\t\t|\n-\t\t+-------------------------------+\n-\t\t| Argument word #20\t\t|\n-\t\t+-------------------------------+\n-\t\t| Argument word #19\t\t|\n-\t\t+-------------------------------+\n-\t\t| Argument word #18\t\t|\n-\t\t+-------------------------------+\n-\t\t| Argument word #17\t\t|\n-\tPrev sp\t+-------------------------------+\n-\t\t|\t\t\t\t|\n-\t\t| Save for arguments 1..16 if\t|\n-\t\t| the func. uses stdarg/varargs\t|\n-\t\t|\t\t\t\t|\n-\t\t+-------------------------------+\n-\t\t|\t\t\t\t|\n-\t\t| Save area for preserved regs\t|\n-\t\t|\t\t\t\t|\n-\t\t+-------------------------------+\n-\t\t|\t\t\t\t|\n-\t\t| Local variables\t\t|\n-\t\t|\t\t\t\t|\n-\t\t+-------------------------------+\n-\t\t|\t\t\t\t|\n-\t\t| alloca space if used\t\t|\n-\t\t|\t\t\t\t|\n-\t\t+-------------------------------+\n-\t\t|\t\t\t\t|\n-\t\t| Space for outgoing arguments\t|\n-\t\t|\t\t\t\t|\n-low\tSP---->\t+-------------------------------+\n-\n-System Calls\n-============\n-\n-System calls will be done using \"TRAP 31\".  Input arguments will be in R2 - R5,\n-and the system call number will be in R6.  Return values from the system call\n-will be in R2.  Negative values of the return indicate the system call failed,\n-and the value is the negative of the error code.  Here are the assigned system\n-call numbers (value in R6):\n-\n-\texit\t1\n-\topen\t2\n-\tclose\t3\n-\tread\t4\n-\twrite\t5\n-\tlseek\t6\n-\tunlink\t7\n-\tgetpid\t8\n-\tkill\t9\n-\tfstat   10\n-\t\t\t(11 is reserved for sbrk)\n-\targvlen\t12\n-\targv\t13\n-\tchdir\t14\n-\tstat\t15\n-\tchmod \t16\n-\tutime \t17\n-\ttime \t18\n-\n-Compiler Switches\n-=================\n-\n-The following d30v specific compiler switches are currently supported:\n-\n-    -mextmem\t\tLink .text/.data/.bss/etc in external memory.\n-\n-    -mextmemory\t\tSame as -mextmem.\n-\n-    -monchip\t\tLink .text/.data/.bss/etc in the onchip data/text\n-\t\t\tmemory.\n-\n-    -mno-asm-optimize\tDo not pass -O to the assembler when optimizing (the -O\n-\t\t\tswitch will mark two short instructions that don't\n-\t\t\tinterfere with each other as being done parallel\n-\t\t\tinstead of sequentially).\n-\n-    -masm-optimize\t[default] If optimizing, pass -O to the assembler.\n-\n-    -mbranch-cost=n\tIncrease the internal costs of branches to n.  Higher\n-\t\t\tcosts means that the compiler will issue more\n-\t\t\tinstructions to avoid doing a branch. The default is\n-\t\t\t2.\n-\n-    -mcond-exec=n\tReplace branches around n insns with conditional\n-\t\t\texecution if we can.  Default is 4.\n-\n-\n-Sections\n-========\n-\n-You can override the effect of the -mextmem/-monchip options by putting\n-functions into either the \".stext\" or \".etext\" sections.  If you put them into\n-the \".stext\" section, the linker will always link the function into the onchip\n-memory area.  Similarly, if you put the function in the \".etext\" section, the\n-linker will always link the function into the external memory area.\n-\n-Data can be controlled as well.  If you put the data in the \".sdata\" section,\n-the linker will put the data into the onchip data area.  Similarly, if you put\n-the data in the \".edata\" section, the linker will put the data into the\n-external memory.\n-\n-\n-Stack pointer\n-=============\n-\n-The crt0.o that we ship loads up the stack pointer with the value of the label\n-__stack.  If you do not define a value for __stack, the linker will choose the\n-top of the onchip data area (0x20008000) for the stack pointer.  You can set a\n-new value via the options:\n-\n-\t-Wl,-defsym,__stack=0x20008000"}, {"sha": "1f93f3b38b8421b51993a67f776d7c8784e9a7ec", "filename": "gcc/config/d30v/d30v-protos.h", "status": "removed", "additions": 0, "deletions": 142, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fd30v%2Fd30v-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fd30v%2Fd30v-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fd30v%2Fd30v-protos.h?ref=c3bf16ff7dec47581f450b1a486cfdf9d566927e", "patch": "@@ -1,142 +0,0 @@\n-/* d30v prototypes.\n-   Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n-   Contributed by Cygnus Solutions.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-/* External functions called.  */\n-\n-extern void override_options (void);\n-#ifdef RTX_CODE\n-extern int short_memory_operand (rtx, enum machine_mode);\n-extern int long_memory_operand (rtx, enum machine_mode);\n-extern int d30v_memory_operand (rtx, enum machine_mode);\n-extern int single_reg_memory_operand (rtx, enum machine_mode);\n-extern int const_addr_memory_operand (rtx, enum machine_mode);\n-extern int call_operand (rtx, enum machine_mode);\n-extern int gpr_operand (rtx, enum machine_mode);\n-extern int accum_operand (rtx, enum machine_mode);\n-extern int gpr_or_accum_operand (rtx, enum machine_mode);\n-extern int cr_operand (rtx, enum machine_mode);\n-extern int repeat_operand (rtx, enum machine_mode);\n-extern int flag_operand (rtx, enum machine_mode);\n-extern int br_flag_operand (rtx, enum machine_mode);\n-extern int br_flag_or_constant_operand (rtx, enum machine_mode);\n-extern int gpr_br_flag_operand (rtx, enum machine_mode);\n-extern int f0_operand (rtx, enum machine_mode);\n-extern int f1_operand (rtx, enum machine_mode);\n-extern int carry_operand (rtx, enum machine_mode);\n-extern int reg_or_0_operand (rtx, enum machine_mode);\n-extern int gpr_or_signed6_operand (rtx, enum machine_mode);\n-extern int gpr_or_unsigned5_operand (rtx, enum machine_mode);\n-extern int gpr_or_unsigned6_operand (rtx, enum machine_mode);\n-extern int gpr_or_constant_operand (rtx, enum machine_mode);\n-extern int gpr_or_dbl_const_operand (rtx, enum machine_mode);\n-extern int gpr_or_memory_operand (rtx, enum machine_mode);\n-extern int move_input_operand (rtx, enum machine_mode);\n-extern int move_output_operand (rtx, enum machine_mode);\n-extern int signed6_operand (rtx, enum machine_mode);\n-extern int unsigned5_operand (rtx, enum machine_mode);\n-extern int unsigned6_operand (rtx, enum machine_mode);\n-extern int bitset_operand (rtx, enum machine_mode);\n-extern int condexec_test_operator (rtx, enum machine_mode);\n-extern int condexec_branch_operator (rtx, enum machine_mode);\n-extern int condexec_unary_operator (rtx, enum machine_mode);\n-extern int condexec_addsub_operator (rtx, enum machine_mode);\n-extern int condexec_binary_operator (rtx, enum machine_mode);\n-extern int condexec_shiftl_operator (rtx, enum machine_mode);\n-extern int condexec_extend_operator (rtx, enum machine_mode);\n-extern int branch_zero_operator (rtx, enum machine_mode);\n-extern int cond_move_dest_operand (rtx, enum machine_mode);\n-extern int cond_move_operand (rtx, enum machine_mode);\n-extern int cond_exec_operand (rtx, enum machine_mode);\n-extern int srelational_si_operator (rtx, enum machine_mode);\n-extern int urelational_si_operator (rtx, enum machine_mode);\n-extern int relational_di_operator (rtx, enum machine_mode);\n-#endif\n-extern d30v_stack_t *d30v_stack_info (void);\n-extern int direct_return (void);\n-\n-#ifdef TREE_CODE\n-#ifdef RTX_CODE\n-extern void d30v_init_cumulative_args (CUMULATIVE_ARGS *, tree,\n-\t\t\t\t       rtx, tree, int);\n-#endif\n-extern int d30v_function_arg_boundary (enum machine_mode, tree);\n-#ifdef RTX_CODE\n-extern rtx d30v_function_arg (CUMULATIVE_ARGS *,\n-\t\t\t      enum machine_mode, tree, int, int);\n-#endif\n-extern int d30v_function_arg_partial_nregs (CUMULATIVE_ARGS *,\n-\t\t\t\t\t    enum machine_mode, tree, int);\n-\n-extern int d30v_function_arg_pass_by_reference (CUMULATIVE_ARGS *,\n-\t\t\t\t\t\tenum machine_mode, tree, int);\n-\n-extern void d30v_function_arg_advance (CUMULATIVE_ARGS *,\n-\t\t\t\t       enum machine_mode, tree, int);\n-#endif\n-\n-#ifdef RTX_CODE\n-extern rtx d30v_expand_builtin_saveregs (void);\n-#endif\n-#ifdef TREE_CODE\n-extern void d30v_setup_incoming_varargs (CUMULATIVE_ARGS *,\n-\t\t\t\t\t enum machine_mode, tree, int *, int);\n-#ifdef RTX_CODE\n-extern void d30v_expand_builtin_va_start (tree, rtx);\n-extern rtx d30v_expand_builtin_va_arg (tree, tree);\n-#endif /* RTX_CODE */\n-#endif /* TREE_CODE */\n-\n-extern void d30v_expand_prologue (void);\n-extern void d30v_expand_epilogue (void);\n-extern void d30v_function_profiler (FILE *, int);\n-#ifdef RTX_CODE\n-extern void d30v_split_double (rtx, rtx *, rtx *);\n-extern void d30v_print_operand (FILE *, rtx, int);\n-extern void d30v_print_operand_address (FILE *, rtx);\n-#endif\n-extern int d30v_trampoline_size (void);\n-#ifdef RTX_CODE\n-extern void d30v_initialize_trampoline (rtx, rtx, rtx);\n-extern int d30v_legitimate_address_p (enum machine_mode, rtx, int);\n-extern rtx d30v_legitimize_address (rtx, rtx, enum machine_mode, int);\n-extern int d30v_mode_dependent_address_p (rtx);\n-extern rtx d30v_emit_comparison (int, rtx, rtx, rtx);\n-extern const char *d30v_move_2words (rtx *, rtx);\n-extern int d30v_emit_cond_move (rtx, rtx, rtx, rtx);\n-extern rtx d30v_return_addr (void);\n-#endif\n-extern void d30v_init_expanders (void);\n-extern void debug_stack_info (d30v_stack_t *);\n-\f\n-\n-/* External variables referenced */\n-\n-/* Define the information needed to generate branch and scc insns.  This is\n-   stored from the compare operation.  */\n-\n-extern GTY(()) rtx d30v_compare_op0;\n-extern GTY(()) rtx d30v_compare_op1;\n-\n-/* Define the information needed to modify the epilogue for EH.  */\n-\n-#ifdef RTX_CODE\n-extern rtx d30v_eh_epilogue_sp_ofs;\n-#endif"}, {"sha": "5794d0bb64f615a2bd7fde2791f80af5808ba986", "filename": "gcc/config/d30v/d30v.c", "status": "removed", "additions": 0, "deletions": 3525, "changes": 3525, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fd30v%2Fd30v.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fd30v%2Fd30v.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fd30v%2Fd30v.c?ref=c3bf16ff7dec47581f450b1a486cfdf9d566927e"}, {"sha": "f63292ecaa3a6741919d62d4a2198c15674e1923", "filename": "gcc/config/d30v/d30v.h", "status": "removed", "additions": 0, "deletions": 2069, "changes": 2069, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fd30v%2Fd30v.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fd30v%2Fd30v.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fd30v%2Fd30v.h?ref=c3bf16ff7dec47581f450b1a486cfdf9d566927e", "patch": "@@ -1,2069 +0,0 @@\n-/* Definitions of target machine for Mitsubishi D30V.\n-   Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004\n-   Free Software Foundation, Inc.\n-   Contributed by Cygnus Solutions.\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 2, or (at your option)\n-   any later version.\n-\n-   GCC is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING.  If not, write to\n-   the Free Software Foundation, 59 Temple Place - Suite 330,\n-   Boston, MA 02111-1307, USA.  */\n-\n-#ifndef GCC_D30V_H\n-\n-/* D30V specific macros */\n-\n-/* Align an address */\n-#define D30V_ALIGN(addr,align) (((addr) + (align) - 1) & ~((align) - 1))\n-\n-\f\n-/* Driver configuration */\n-\n-/* Defined in svr4.h.  */\n-/* #define SWITCH_TAKES_ARG(CHAR) */\n-\n-/* Defined in svr4.h.  */\n-/* #define WORD_SWITCH_TAKES_ARG(NAME) */\n-\n-/* Defined in svr4.h.  */\n-#undef\tASM_SPEC\n-#define ASM_SPEC \"\\\n-%{!mno-asm-optimize: %{O*: %{!O0: -O} %{O0: %{masm-optimize: -O}}}} \\\n-%{v} %{n} %{T} %{Ym,*} %{Yd,*} %{Wa,*:%*}\"\n-\n-/* Defined in svr4.h.  */\n-#undef\tLINK_SPEC\n-#define LINK_SPEC \"\\\n-%{h*} %{v:-V} \\\n-%{b} %{Wl,*:%*} \\\n-%{static:-dn -Bstatic} \\\n-%{shared:-G -dy -z text} \\\n-%{symbolic:-Bsymbolic -G -dy -z text} \\\n-%{G:-G} \\\n-%{YP,*} \\\n-%{Qy:} %{!Qn:-Qy} \\\n-%{mextmem: -m d30v_e} %{mextmemory: -m d30v_e} %{monchip: -m d30v_o}\"\n-\n-/* Defined in svr4.h.  */\n-#undef\tLIB_SPEC\n-#define LIB_SPEC \"--start-group -lsim -lc --end-group\"\n-\n-/* Defined in svr4.h.  */\n-#undef\tSTARTFILE_SPEC\n-#define STARTFILE_SPEC \"crt0%O%s crtbegin%O%s\"\n-\n-/* Defined in svr4.h.  */\n-#undef\tENDFILE_SPEC\n-#define ENDFILE_SPEC \"crtend%O%s\"\n-\n-/* Defined in svr4.h for host compilers.  */\n-/* #define MD_EXEC_PREFIX \"\" */\n-\n-/* Defined in svr4.h for host compilers.  */\n-/* #define MD_STARTFILE_PREFIX \"\" */\n-\n-\f\n-/* Run-time target specifications */\n-\n-#define TARGET_CPU_CPP_BUILTINS()\t\t\\\n-  do\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\\\n-      builtin_define (\"__D30V__\");\t\t\\\n-      builtin_assert (\"machine=d30v\");\t\t\\\n-    }\t\t\t\t\t\t\\\n-  while (0)\n-\n-/* This declaration should be present.  */\n-extern int target_flags;\n-\n-#define MASK_NO_COND_MOVE\t0x00000001\t/* disable conditional moves */\n-\n-#define MASK_DEBUG_ARG\t\t0x10000000\t/* debug argument handling */\n-#define MASK_DEBUG_STACK\t0x20000000\t/* debug stack allocations */\n-#define MASK_DEBUG_ADDR\t\t0x40000000\t/* debug GO_IF_LEGITIMATE_ADDRESS */\n-\n-#define TARGET_NO_COND_MOVE\t(target_flags & MASK_NO_COND_MOVE)\n-#define TARGET_DEBUG_ARG\t(target_flags & MASK_DEBUG_ARG)\n-#define TARGET_DEBUG_STACK\t(target_flags & MASK_DEBUG_STACK)\n-#define TARGET_DEBUG_ADDR\t(target_flags & MASK_DEBUG_ADDR)\n-\n-#define TARGET_COND_MOVE\t(! TARGET_NO_COND_MOVE)\n-\n-/* Default switches used.  */\n-#ifndef TARGET_DEFAULT\n-#define TARGET_DEFAULT 0\n-#endif\n-\n-#define TARGET_SWITCHES\t\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  { \"cond-move\",\t-MASK_NO_COND_MOVE,\t\t\t\t\\\n-      N_(\"Enable use of conditional move instructions\") },\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  { \"no-cond-move\",\tMASK_NO_COND_MOVE,\t\t\t\t\\\n-      N_(\"Disable use of conditional move instructions\") },\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  { \"debug-arg\",\t MASK_DEBUG_ARG,\t\t\t\t\\\n-      N_(\"Debug argument support in compiler\") },\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  { \"debug-stack\",\t MASK_DEBUG_STACK,\t\t\t\t\\\n-      N_(\"Debug stack support in compiler\") },\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  { \"debug-addr\",\t MASK_DEBUG_ADDR,\t\t\t\t\\\n-      N_(\"Debug memory address support in compiler\") },\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  { \"asm-optimize\",\t 0,\t\t\t\t\t\t\\\n-      N_(\"Make adjacent short instructions parallel if possible\") },\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  { \"no-asm-optimize\",\t 0,\t\t\t\t\t\t\\\n-      N_(\"Do not make adjacent short instructions parallel\") },\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  { \"extmem\",\t\t 0,\t\t\t\t\t\t\\\n-      N_(\"Link programs/data to be in external memory by default\") },\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  { \"extmemory\",\t 0,\t\t\t\t\t\t\\\n-      N_(\"Link programs/data to be in external memory by default\") },\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  { \"onchip\",\t\t 0,\t\t\t\t\t\t\\\n-      N_(\"Link programs/data to be in onchip memory by default\") },\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  { \"\",\t\t\t TARGET_DEFAULT, \"\" },\t\t\t\t\\\n-}\n-\n-#define TARGET_OPTIONS\t\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  {\"branch-cost=\",  &d30v_branch_cost_string,\t\t\t\t\\\n-     N_(\"Change the branch costs within the compiler\"), 0},\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  {\"cond-exec=\",    &d30v_cond_exec_string,\t\t\t\t\\\n-     N_(\"Change the threshold for conversion to conditional execution\"), 0}, \\\n-}\n-\n-#define TARGET_VERSION fprintf (stderr, \" d30v\")\n-\n-#define OVERRIDE_OPTIONS override_options ()\n-\n-#define CAN_DEBUG_WITHOUT_FP\n-\n-\f\n-/* Storage Layout */\n-\n-#define BITS_BIG_ENDIAN 1\n-\n-#define BYTES_BIG_ENDIAN 1\n-\n-#define WORDS_BIG_ENDIAN 1\n-\n-#define UNITS_PER_WORD 4\n-\n-#define PROMOTE_MODE(MODE,UNSIGNEDP,TYPE)\t\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  if (GET_MODE_CLASS (MODE) == MODE_INT\t\t\t\t\t\\\n-      && GET_MODE_SIZE (MODE) < 4)\t\t\t\t\t\\\n-    (MODE) = SImode;\t\t\t\t\t\t\t\\\n-} while (0)\n-\n-#define PARM_BOUNDARY 32\n-\n-#define STACK_BOUNDARY 64\n-\n-#define FUNCTION_BOUNDARY 64\n-\n-#define BIGGEST_ALIGNMENT 64\n-\n-/* Defined in svr4.h.  */\n-/* #define MAX_OFILE_ALIGNMENT */\n-\n-#define DATA_ALIGNMENT(TYPE, ALIGN)\t\t\\\n-  (TREE_CODE (TYPE) == ARRAY_TYPE\t\t\\\n-   && TYPE_MODE (TREE_TYPE (TYPE)) == QImode\t\\\n-   && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))\n-\n-#define CONSTANT_ALIGNMENT(EXP, ALIGN)  \\\n-  (TREE_CODE (EXP) == STRING_CST\t\\\n-   && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))\n-\n-#define STRICT_ALIGNMENT 1\n-\n-/* Defined in svr4.h.  */\n-\n-#define PCC_BITFIELD_TYPE_MATTERS 1\n-\f\n-/* Layout of Source Language Data Types */\n-\n-#define INT_TYPE_SIZE 32\n-\n-#define SHORT_TYPE_SIZE 16\n-\n-#define LONG_TYPE_SIZE 32\n-\n-#define LONG_LONG_TYPE_SIZE 64\n-\n-#define FLOAT_TYPE_SIZE 32\n-\n-#define DOUBLE_TYPE_SIZE 64\n-\n-#define LONG_DOUBLE_TYPE_SIZE 64\n-\n-#define DEFAULT_SIGNED_CHAR 1\n-\n-/* Defined in svr4.h.  */\n-/* #define SIZE_TYPE */\n-\n-/* Defined in svr4.h.  */\n-/* #define PTRDIFF_TYPE */\n-\n-/* Defined in svr4.h.  */\n-/* #define WCHAR_TYPE */\n-\n-/* Defined in svr4.h.  */\n-/* #define WCHAR_TYPE_SIZE */\n-\n-\f\n-/* D30V register layout.  */\n-\n-/* Return true if a value is inside a range */\n-#define IN_RANGE_P(VALUE, LOW, HIGH) \\\n-  (((unsigned)((VALUE) - (LOW))) <= ((unsigned)((HIGH) - (LOW))))\n-\n-/* General purpose registers.  */\n-#define GPR_FIRST\t0\t\t\t/* First gpr */\n-#define GPR_LAST\t(GPR_FIRST + 63)\t/* Last gpr */\n-#define GPR_R0\t\tGPR_FIRST\t\t/* R0, constant 0 */\n-#define GPR_ARG_FIRST\t(GPR_FIRST + 2)\t\t/* R2, first argument reg */\n-#define GPR_ARG_LAST\t(GPR_FIRST + 17)\t/* R17, last argument reg */\n-#define GPR_RET_VALUE\tGPR_ARG_FIRST\t\t/* R2, function return reg */\n-#define GPR_ATMP_FIRST\t(GPR_FIRST + 20)\t/* R20, tmp to save accs */\n-#define GPR_ATMP_LAST\t(GPR_FIRST + 21)\t/* R21, tmp to save accs */\n-#define GPR_STACK_TMP\t(GPR_FIRST + 22)\t/* R22, tmp for saving stack */\n-#define GPR_RES_FIRST\t(GPR_FIRST + 32)\t/* R32, first reserved reg */\n-#define GPR_RES_LAST\t(GPR_FIRST + 35)\t/* R35, last reserved reg */\n-#define GPR_FP\t\t(GPR_FIRST + 61)\t/* Frame pointer */\n-#define GPR_LINK\t(GPR_FIRST + 62)\t/* Return address register */\n-#define GPR_SP\t\t(GPR_FIRST + 63)\t/* Stack pointer */\n-\n-/* Argument register that is eliminated in favor of the frame and/or stack\n-   pointer.  Also add register to point to where the return address is\n-   stored.  */\n-#define SPECIAL_REG_FIRST\t\t(GPR_LAST + 1)\n-#define SPECIAL_REG_LAST\t\t(SPECIAL_REG_FIRST)\n-#define ARG_POINTER_REGNUM\t\t(SPECIAL_REG_FIRST + 0)\n-#define SPECIAL_REG_P(R)\t\t((R) == SPECIAL_REG_FIRST)\n-\n-#define GPR_OR_SPECIAL_REG_P(R)\t\tIN_RANGE_P (R, GPR_FIRST, SPECIAL_REG_LAST)\n-#define GPR_P(R)\t\t\tIN_RANGE_P (R, GPR_FIRST, GPR_LAST)\n-#define GPR_OR_PSEUDO_P(R)\t\t(GPR_OR_SPECIAL_REG_P (R)\t\\\n-\t\t\t\t\t || (R) >= FIRST_PSEUDO_REGISTER)\n-\n-/* Flag bits.  */\n-#define FLAG_FIRST\t(SPECIAL_REG_LAST + 1)\t/* First flag */\n-#define FLAG_LAST\t(FLAG_FIRST + 7)\t/* Last flag */\n-#define FLAG_F0\t\t(FLAG_FIRST)\t\t/* F0, used in prediction */\n-#define FLAG_F1\t\t(FLAG_FIRST + 1)\t/* F1, used in prediction */\n-#define FLAG_F2\t\t(FLAG_FIRST + 2)\t/* F2, general flag */\n-#define FLAG_F3\t\t(FLAG_FIRST + 3)\t/* F3, general flag */\n-#define FLAG_SAT\t(FLAG_FIRST + 4)\t/* F4, saturation flag */\n-#define FLAG_OVERFLOW\t(FLAG_FIRST + 5)\t/* F5, overflow flag */\n-#define FLAG_ACC_OVER\t(FLAG_FIRST + 6)\t/* F6, accumulated overflow */\n-#define FLAG_CARRY\t(FLAG_FIRST + 7)\t/* F7, carry/borrow flag */\n-#define FLAG_BORROW\tFLAG_CARRY\n-\n-#define FLAG_P(R)\t\tIN_RANGE_P (R, FLAG_FIRST, FLAG_LAST)\n-#define FLAG_OR_PSEUDO_P(R)\t(FLAG_P (R) || (R) >= FIRST_PSEUDO_REGISTER)\n-\n-#define BR_FLAG_P(R)\t\tIN_RANGE_P (R, FLAG_F0, FLAG_F1)\n-#define BR_FLAG_OR_PSEUDO_P(R)\t(BR_FLAG_P (R) || (R) >= FIRST_PSEUDO_REGISTER)\n-\n-/* Accumulators */\n-#define ACCUM_FIRST\t(FLAG_LAST + 1)\t\t/* First accumulator */\n-#define ACCUM_A0\tACCUM_FIRST\t\t/* Register A0 */\n-#define ACCUM_A1\t(ACCUM_FIRST + 1)\t/* Register A1 */\n-#define ACCUM_LAST\t(ACCUM_FIRST + 1)\t/* Last accumulator */\n-\n-#define ACCUM_P(R)\t\tIN_RANGE_P (R, ACCUM_FIRST, ACCUM_LAST)\n-#define ACCUM_OR_PSEUDO_P(R)\t(ACCUM_P (R) || (R) >= FIRST_PSEUDO_REGISTER)\n-\n-/* Special registers.  Note, we only define the registers that can actually\n-   be used.  */\n-#define CR_FIRST\t(ACCUM_LAST + 1)\t/* First CR */\n-#define CR_LAST\t\t(CR_FIRST + 14)\t\t/* Last CR */\n-#define CR_PSW\t\t(CR_FIRST + 0)\t\t/* CR0, Program status word */\n-#define CR_BPSW\t\t(CR_FIRST + 1)\t\t/* CR1, Backup PSW */\n-#define CR_PC\t\t(CR_FIRST + 2)\t\t/* CR2, Program counter */\n-#define CR_BPC\t\t(CR_FIRST + 3)\t\t/* CR3, Backup PC */\n-#define CR_DPSW\t\t(CR_FIRST + 4)\t\t/* CR4, Debug PSW */\n-#define CR_DPC\t\t(CR_FIRST + 5)\t\t/* CR5, Debug PC */\n-#define CR_RPT_C\t(CR_FIRST + 6)\t\t/* CR7, loop count register */\n-#define CR_RPT_S\t(CR_FIRST + 7)\t\t/* CR8, loop start address */\n-#define CR_RPT_E\t(CR_FIRST + 8)\t\t/* CR9, loop end address */\n-#define CR_MOD_S\t(CR_FIRST + 9)\t\t/* CR10, modulo address start*/\n-#define CR_MOD_E\t(CR_FIRST + 10)\t\t/* CR11, modulo address */\n-#define CR_IBA\t\t(CR_FIRST + 11)\t\t/* CR14, Interrupt break addr */\n-#define CR_EIT_VB\t(CR_FIRST + 12)\t\t/* CR15, EIT vector address */\n-#define CR_INT_S\t(CR_FIRST + 13)\t\t/* CR16, Interrupt status */\n-#define CR_INT_M\t(CR_FIRST + 14)\t\t/* CR17, Interrupt mask */\n-\n-#define CR_P(R)\t\t\tIN_RANGE_P (R, CR_FIRST, CR_LAST)\n-#define CR_OR_PSEUDO_P(R)\t(CR_P (R) || (R) >= FIRST_PSEUDO_REGISTER)\n-\n-\f\n-/* Register Basics */\n-\n-/* Number of hardware registers known to the compiler.  They receive numbers 0\n-   through `FIRST_PSEUDO_REGISTER-1'; thus, the first pseudo register's number\n-   really is assigned the number `FIRST_PSEUDO_REGISTER'.  */\n-#define FIRST_PSEUDO_REGISTER (CR_LAST + 1)\n-\n-/* An initializer that says which registers are used for fixed purposes all\n-   throughout the compiled code and are therefore not available for general\n-   allocation.  These would include the stack pointer, the frame pointer\n-   (except on machines where that can be used as a general register when no\n-   frame pointer is needed), the program counter on machines where that is\n-   considered one of the addressable registers, and any other numbered register\n-   with a standard use.\n-\n-   This information is expressed as a sequence of numbers, separated by commas\n-   and surrounded by braces.  The Nth number is 1 if register N is fixed, 0\n-   otherwise.\n-\n-   The table initialized from this macro, and the table initialized by the\n-   following one, may be overridden at run time either automatically, by the\n-   actions of the macro `CONDITIONAL_REGISTER_USAGE', or by the user with the\n-   command options `-ffixed-REG', `-fcall-used-REG' and `-fcall-saved-REG'.  */\n-#define FIXED_REGISTERS\t\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  /* R0  - R15 */\t\\\n-  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,  /* R16 - R31 */\t\\\n-  1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  /* R32 - R47 */\t\\\n-  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,  /* R48 - R63 */\t\\\n-  1,\t\t\t\t\t\t   /* ARG ptr */\t\\\n-  0, 0, 0, 0, 1, 1, 1, 1,\t\t\t   /* F0 - F7 */\t\\\n-  0, 0,\t\t\t\t\t\t   /* A0 - A1 */\t\\\n-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t   /* CRs */\t\t\\\n-}\n-\n-/* Like `FIXED_REGISTERS' but has 1 for each register that is clobbered (in\n-   general) by function calls as well as for fixed registers.  This macro\n-   therefore identifies the registers that are not available for general\n-   allocation of values that must live across function calls.\n-\n-   If a register has 0 in `CALL_USED_REGISTERS', the compiler automatically\n-   saves it on function entry and restores it on function exit, if the register\n-   is used within the function.  */\n-#define CALL_USED_REGISTERS\t\t        \t\t\t\\\n-{\t\t\t\t\t        \t\t\t\\\n-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  /* R0  - R15 */\t\\\n-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  /* R16 - R31 */\t\\\n-  1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  /* R32 - R47 */\t\\\n-  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,  /* R48 - R63 */\t\\\n-  1,\t\t\t\t\t\t   /* ARG ptr */\t\\\n-  1, 1, 1, 1, 1, 1, 1, 1,\t\t\t   /* F0 - F7 */\t\\\n-  1, 0,\t\t\t\t\t\t   /* A0 - A1 */\t\\\n-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t   /* CRs */\t\t\\\n-}\n-\n-\f\n-/* Order of allocation of registers */\n-\n-/* If defined, an initializer for a vector of integers, containing the numbers\n-   of hard registers in the order in which GCC should prefer to use them\n-   (from most preferred to least).\n-\n-   If this macro is not defined, registers are used lowest numbered first (all\n-   else being equal).\n-\n-   One use of this macro is on machines where the highest numbered registers\n-   must always be saved and the save-multiple-registers instruction supports\n-   only sequences of consecutive registers.  On such machines, define\n-   `REG_ALLOC_ORDER' to be an initializer that lists the highest numbered\n-   allocatable register first.  */\n-\n-#define REG_ALLOC_ORDER\t\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  /* volatile registers */\t\t\t\t\t\t\\\n-  GPR_FIRST + 2,    GPR_FIRST + 3,    GPR_FIRST + 4,    GPR_FIRST + 5,\t\\\n-  GPR_FIRST + 6,    GPR_FIRST + 7,    GPR_FIRST + 8,    GPR_FIRST + 9,\t\\\n-  GPR_FIRST + 10,   GPR_FIRST + 11,   GPR_FIRST + 12,   GPR_FIRST + 13,\t\\\n-  GPR_FIRST + 14,   GPR_FIRST + 15,   GPR_FIRST + 16,   GPR_FIRST + 17,\t\\\n-  GPR_FIRST + 18,   GPR_FIRST + 19,   GPR_FIRST + 20,   GPR_FIRST + 21,\t\\\n-  GPR_FIRST + 22,   GPR_FIRST + 23,   GPR_FIRST + 24,   GPR_FIRST + 25, \\\n-  GPR_FIRST + 1,\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  /* saved registers */\t\t\t\t\t\t\t\\\n-  GPR_FIRST + 34,   GPR_FIRST + 35,   GPR_FIRST + 36,   GPR_FIRST + 37,\t\\\n-  GPR_FIRST + 38,   GPR_FIRST + 39,   GPR_FIRST + 40,   GPR_FIRST + 41,\t\\\n-  GPR_FIRST + 42,   GPR_FIRST + 43,   GPR_FIRST + 44,   GPR_FIRST + 45,\t\\\n-  GPR_FIRST + 46,   GPR_FIRST + 47,   GPR_FIRST + 48,   GPR_FIRST + 49,\t\\\n-  GPR_FIRST + 50,   GPR_FIRST + 51,   GPR_FIRST + 52,   GPR_FIRST + 53,\t\\\n-  GPR_FIRST + 54,   GPR_FIRST + 55,   GPR_FIRST + 56,   GPR_FIRST + 57,\t\\\n-  GPR_FIRST + 58,   GPR_FIRST + 59,   GPR_FIRST + 60,   GPR_FIRST + 61,\t\\\n-  GPR_FIRST + 62,\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  /* flags */\t\t\t\t\t\t\t\t\\\n-  FLAG_F2,          FLAG_F3,          FLAG_F0,          FLAG_F1,\t\\\n-  FLAG_SAT,         FLAG_OVERFLOW,    FLAG_ACC_OVER,    FLAG_CARRY,\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  /* accumultors */\t\t\t\t\t\t\t\\\n-  ACCUM_FIRST + 0,  ACCUM_FIRST + 1,\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  /* fixed registers */\t\t\t\t\t\t\t\\\n-  GPR_FIRST + 0,    GPR_FIRST + 26,   GPR_FIRST + 27,   GPR_FIRST + 28,\t\\\n-  GPR_FIRST + 29,   GPR_FIRST + 30,   GPR_FIRST + 31,   GPR_FIRST + 32,\t\\\n-  GPR_FIRST + 33,   GPR_FIRST + 63,\t\t\t\t\t\\\n-  CR_PSW,\t    CR_BPSW,\t      CR_PC,\t\tCR_BPC,\t\t\\\n-  CR_DPSW,\t    CR_DPC,\t      CR_RPT_C,\t\tCR_RPT_S,\t\\\n-  CR_RPT_E,\t    CR_MOD_S,\t      CR_MOD_E,\t\tCR_IBA,\t\t\\\n-  CR_EIT_VB,\t    CR_INT_S,\t      CR_INT_M,\t\t\t\t\\\n-  ARG_POINTER_REGNUM,\t\t\t\t\t\t\t\\\n-}\n-\n-\f\n-/* How Values Fit in Registers */\n-\n-/* A C expression for the number of consecutive hard registers, starting at\n-   register number REGNO, required to hold a value of mode MODE.\n-\n-   On a machine where all registers are exactly one word, a suitable definition\n-   of this macro is\n-\n-        #define HARD_REGNO_NREGS(REGNO, MODE)            \\\n-           ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1)  \\\n-            / UNITS_PER_WORD))  */\n-\n-#define HARD_REGNO_NREGS(REGNO, MODE)\t\t\t\t\t\\\n-(ACCUM_P (REGNO) ? ((GET_MODE_SIZE (MODE) + 2*UNITS_PER_WORD - 1)\t\\\n-\t\t    / (2*UNITS_PER_WORD))\t\t\t\t\\\n-\t\t : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1)\t\t\\\n-\t\t    / UNITS_PER_WORD))\n-\n-/* A C expression that is nonzero if it is permissible to store a value of mode\n-   MODE in hard register number REGNO (or in several registers starting with\n-   that one).  For a machine where all registers are equivalent, a suitable\n-   definition is\n-\n-        #define HARD_REGNO_MODE_OK(REGNO, MODE) 1\n-\n-   It is not necessary for this macro to check for the numbers of fixed\n-   registers, because the allocation mechanism considers them to be always\n-   occupied.\n-\n-   On some machines, double-precision values must be kept in even/odd register\n-   pairs.  The way to implement that is to define this macro to reject odd\n-   register numbers for such modes.\n-\n-   The minimum requirement for a mode to be OK in a register is that the\n-   `movMODE' instruction pattern support moves between the register and any\n-   other hard register for which the mode is OK; and that moving a value into\n-   the register and back out not alter it.\n-\n-   Since the same instruction used to move `SImode' will work for all narrower\n-   integer modes, it is not necessary on any machine for `HARD_REGNO_MODE_OK'\n-   to distinguish between these modes, provided you define patterns `movhi',\n-   etc., to take advantage of this.  This is useful because of the interaction\n-   between `HARD_REGNO_MODE_OK' and `MODES_TIEABLE_P'; it is very desirable for\n-   all integer modes to be tieable.\n-\n-   Many machines have special registers for floating point arithmetic.  Often\n-   people assume that floating point machine modes are allowed only in floating\n-   point registers.  This is not true.  Any registers that can hold integers\n-   can safely *hold* a floating point machine mode, whether or not floating\n-   arithmetic can be done on it in those registers.  Integer move instructions\n-   can be used to move the values.\n-\n-   On some machines, though, the converse is true: fixed-point machine modes\n-   may not go in floating registers.  This is true if the floating registers\n-   normalize any value stored in them, because storing a non-floating value\n-   there would garble it.  In this case, `HARD_REGNO_MODE_OK' should reject\n-   fixed-point machine modes in floating registers.  But if the floating\n-   registers do not automatically normalize, if you can store any bit pattern\n-   in one and retrieve it unchanged without a trap, then any machine mode may\n-   go in a floating register, so you can define this macro to say so.\n-\n-   The primary significance of special floating registers is rather that they\n-   are the registers acceptable in floating point arithmetic instructions.\n-   However, this is of no concern to `HARD_REGNO_MODE_OK'.  You handle it by\n-   writing the proper constraints for those instructions.\n-\n-   On some machines, the floating registers are especially slow to access, so\n-   that it is better to store a value in a stack frame than in such a register\n-   if floating point arithmetic is not being done.  As long as the floating\n-   registers are not in class `GENERAL_REGS', they will not be used unless some\n-   pattern's constraint asks for one.  */\n-\n-extern unsigned char hard_regno_mode_ok[][FIRST_PSEUDO_REGISTER];\n-#define HARD_REGNO_MODE_OK(REGNO, MODE) hard_regno_mode_ok[ (int)MODE ][ REGNO ]\n-\n-/* A C expression that is nonzero if it is desirable to choose register\n-   allocation so as to avoid move instructions between a value of mode MODE1\n-   and a value of mode MODE2.\n-\n-   If `HARD_REGNO_MODE_OK (R, MODE1)' and `HARD_REGNO_MODE_OK (R, MODE2)' are\n-   ever different for any R, then `MODES_TIEABLE_P (MODE1, MODE2)' must be\n-   zero.  */\n-\n-extern unsigned char modes_tieable_p[];\n-#define MODES_TIEABLE_P(MODE1, MODE2) \\\n-  modes_tieable_p[ (((int)(MODE1)) * (NUM_MACHINE_MODES)) + (int)(MODE2) ]\n-\n-/* Define this macro if the compiler should avoid copies to/from CCmode\n-   registers.  You should only define this macro if support fo copying to/from\n-   CCmode is incomplete.  */\n-   \n-/* On the D30V, copying to/from CCmode is complete, but since there are only\n-   two CC registers usable for conditional tests, this helps gcse not compound\n-   the reload problem.  */\n-#define AVOID_CCMODE_COPIES\n-\n-\f\n-/* Register Classes */\n-\n-/* An enumeral type that must be defined with all the register class names as\n-   enumeral values.  `NO_REGS' must be first.  `ALL_REGS' must be the last\n-   register class, followed by one more enumeral value, `LIM_REG_CLASSES',\n-   which is not a register class but rather tells how many classes there are.\n-\n-   Each register class has a number, which is the value of casting the class\n-   name to type `int'.  The number serves as an index in many of the tables\n-   described below.  */\n-enum reg_class\n-{\n-  NO_REGS,\n-  REPEAT_REGS,\n-  CR_REGS,\n-  ACCUM_REGS,\n-  OTHER_FLAG_REGS,\n-  F0_REGS,\n-  F1_REGS,\n-  BR_FLAG_REGS,\n-  FLAG_REGS,\n-  EVEN_REGS,\n-  GPR_REGS,\n-  ALL_REGS,\n-  LIM_REG_CLASSES\n-};\n-\n-#define GENERAL_REGS GPR_REGS\n-\n-/* The number of distinct register classes, defined as follows:\n-\n-        #define N_REG_CLASSES (int) LIM_REG_CLASSES  */\n-#define N_REG_CLASSES ((int) LIM_REG_CLASSES)\n-\n-/* An initializer containing the names of the register classes as C string\n-   constants.  These names are used in writing some of the debugging dumps.  */\n-#define REG_CLASS_NAMES\t\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  \"NO_REGS\",\t\t\t\t\t\t\t\t\\\n-  \"REPEAT_REGS\",\t\t\t\t\t\t\t\\\n-  \"CR_REGS\",\t\t\t\t\t\t\t\t\\\n-  \"ACCUM_REGS\",\t\t\t\t\t\t\t\t\\\n-  \"OTHER_FLAG_REGS\",\t\t\t\t\t\t\t\\\n-  \"F0_REGS\",\t\t\t\t\t\t\t\t\\\n-  \"F1_REGS\",\t\t\t\t\t\t\t\t\\\n-  \"BR_FLAG_REGS\",\t\t\t\t\t\t\t\\\n-  \"FLAG_REGS\",\t\t\t\t\t\t\t\t\\\n-  \"EVEN_REGS\",\t\t\t\t\t\t\t\t\\\n-  \"GPR_REGS\",\t\t\t\t\t\t\t\t\\\n-  \"ALL_REGS\",\t\t\t\t\t\t\t\t\\\n-}\n-\n-/* Create mask bits for 3rd word of REG_CLASS_CONTENTS */\n-#define MASK_WORD3(REG) ((long)1 << ((REG) - 64))\n-\n-#define NO_MASK\t\t0\n-#define REPEAT_MASK\tMASK_WORD3 (CR_RPT_C)\n-#define CR_MASK\t\t(MASK_WORD3 (CR_PSW)\t | MASK_WORD3 (CR_BPSW)\t  \\\n-\t\t\t | MASK_WORD3 (CR_PC)\t | MASK_WORD3 (CR_BPC)\t  \\\n-\t\t\t | MASK_WORD3 (CR_DPSW)\t | MASK_WORD3 (CR_DPC)\t  \\\n-\t\t\t | MASK_WORD3 (CR_RPT_C) | MASK_WORD3 (CR_RPT_S)  \\\n-\t\t\t | MASK_WORD3 (CR_RPT_E) | MASK_WORD3 (CR_MOD_S)  \\\n-\t\t\t | MASK_WORD3 (CR_MOD_E) | MASK_WORD3 (CR_IBA)\t  \\\n-\t\t\t | MASK_WORD3 (CR_EIT_VB) | MASK_WORD3 (CR_INT_S) \\\n-\t\t\t | MASK_WORD3 (CR_INT_M))\n-\n-#define ACCUM_MASK\t(MASK_WORD3 (ACCUM_A0)\t | MASK_WORD3 (ACCUM_A1))\n-#define OTHER_FLAG_MASK\t(MASK_WORD3 (FLAG_F2)\t | MASK_WORD3 (FLAG_F3)\t\\\n-\t\t\t | MASK_WORD3 (FLAG_SAT) | MASK_WORD3 (FLAG_OVERFLOW) \\\n-\t\t\t | MASK_WORD3 (FLAG_ACC_OVER) | MASK_WORD3 (FLAG_CARRY))\n-\n-#define F0_MASK\t\tMASK_WORD3 (FLAG_F0)\n-#define F1_MASK\t\tMASK_WORD3 (FLAG_F1)\n-#define BR_FLAG_MASK\t(F0_MASK | F1_MASK)\n-#define FLAG_MASK\t(BR_FLAG_MASK | OTHER_FLAG_MASK)\n-#define SPECIAL_MASK\tMASK_WORD3 (ARG_POINTER_REGNUM)\n-\n-#define ALL_MASK\t(CR_MASK | ACCUM_MASK | FLAG_MASK | SPECIAL_MASK)\n-\n-/* An initializer containing the contents of the register classes, as integers\n-   which are bit masks.  The Nth integer specifies the contents of class N.\n-   The way the integer MASK is interpreted is that register R is in the class\n-   if `MASK & (1 << R)' is 1.\n-\n-   When the machine has more than 32 registers, an integer does not suffice.\n-   Then the integers are replaced by sub-initializers, braced groupings\n-   containing several integers.  Each sub-initializer must be suitable as an\n-   initializer for the type `HARD_REG_SET' which is defined in\n-   `hard-reg-set.h'.  */\n-#define REG_CLASS_CONTENTS\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  { 0x00000000, 0x00000000, NO_MASK },\t\t/* NO_REGS */\t\t\\\n-  { 0x00000000, 0x00000000, REPEAT_MASK },\t/* REPEAT_REGS */\t\\\n-  { 0x00000000, 0x00000000, CR_MASK },\t\t/* CR_REGS */\t\t\\\n-  { 0x00000000, 0x00000000, ACCUM_MASK },\t/* ACCUM_REGS */\t\\\n-  { 0x00000000, 0x00000000, OTHER_FLAG_MASK },\t/* OTHER_FLAG_REGS */\t\\\n-  { 0x00000000, 0x00000000, F0_MASK },\t\t/* F0_REGS */\t\t\\\n-  { 0x00000000, 0x00000000, F1_MASK },\t\t/* F1_REGS */\t\t\\\n-  { 0x00000000, 0x00000000, BR_FLAG_MASK },\t/* BR_FLAG_REGS */\t\\\n-  { 0x00000000, 0x00000000, FLAG_MASK },\t/* FLAG_REGS */\t\t\\\n-  { 0xfffffffc, 0x3fffffff, NO_MASK },\t\t/* EVEN_REGS */\t\t\\\n-  { 0xffffffff, 0xffffffff, SPECIAL_MASK },\t/* GPR_REGS */\t\t\\\n-  { 0xffffffff, 0xffffffff, ALL_MASK },\t\t/* ALL_REGS */\t\t\\\n-}\n-\n-/* A C expression whose value is a register class containing hard register\n-   REGNO.  In general there is more than one such class; choose a class which\n-   is \"minimal\", meaning that no smaller class also contains the register.  */\n-\n-extern enum reg_class regno_reg_class[FIRST_PSEUDO_REGISTER];\n-#define REGNO_REG_CLASS(REGNO) regno_reg_class[ (REGNO) ]\n-\n-/* A macro whose definition is the name of the class to which a valid base\n-   register must belong.  A base register is one used in an address which is\n-   the register value plus a displacement.  */\n-#define BASE_REG_CLASS GPR_REGS\n-\n-/* A macro whose definition is the name of the class to which a valid index\n-   register must belong.  An index register is one used in an address where its\n-   value is either multiplied by a scale factor or added to another register\n-   (as well as added to a displacement).  */\n-#define INDEX_REG_CLASS GPR_REGS\n-\n-/* A C expression which defines the machine-dependent operand constraint\n-   letters for register classes.  If CHAR is such a letter, the value should be\n-   the register class corresponding to it.  Otherwise, the value should be\n-   `NO_REGS'.  The register letter `r', corresponding to class `GENERAL_REGS',\n-   will not be passed to this macro; you do not need to handle it.\n-\n-   The following letters are unavailable, due to being used as\n-   constraints:\n-\t'0'..'9'\n-\t'<', '>'\n-\t'E', 'F', 'G', 'H'\n-\t'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P'\n-\t'Q', 'R', 'S', 'T', 'U'\n-\t'V', 'X'\n-\t'g', 'i', 'm', 'n', 'o', 'p', 'r', 's' */\n-\n-extern enum reg_class reg_class_from_letter[256];\n-#define REG_CLASS_FROM_LETTER(CHAR) reg_class_from_letter[(unsigned char)(CHAR)]\n-\n-/* A C expression which is nonzero if register number NUM is suitable for use\n-   as a base register in operand addresses.  It may be either a suitable hard\n-   register or a pseudo register that has been allocated such a hard register.  */\n-\n-#define REGNO_OK_FOR_BASE_P(NUM) \t\t\t\t\t\\\n-((NUM) < FIRST_PSEUDO_REGISTER\t\t\t\t\t\t\\\n- ? GPR_P (NUM)\t\t\t\t\t\t\t\t\\\n- : (reg_renumber[NUM] >= 0 && GPR_P (reg_renumber[NUM])))\n-\n-\n-/* A C expression which is nonzero if register number NUM is suitable for use\n-   as an index register in operand addresses.  It may be either a suitable hard\n-   register or a pseudo register that has been allocated such a hard register.\n-\n-   The difference between an index register and a base register is that the\n-   index register may be scaled.  If an address involves the sum of two\n-   registers, neither one of them scaled, then either one may be labeled the\n-   \"base\" and the other the \"index\"; but whichever labeling is used must fit\n-   the machine's constraints of which registers may serve in each capacity.\n-   The compiler will try both labelings, looking for one that is valid, and\n-   will reload one or both registers only if neither labeling works.  */\n-\n-#define REGNO_OK_FOR_INDEX_P(NUM)\t\t\t\t\t\\\n-((NUM) < FIRST_PSEUDO_REGISTER\t\t\t\t\t\t\\\n- ? GPR_P (NUM)\t\t\t\t\t\t\t\t\\\n- : (reg_renumber[NUM] >= 0 && GPR_P (reg_renumber[NUM])))\n-\n-/* A C expression that places additional restrictions on the register class to\n-   use when it is necessary to copy value X into a register in class CLASS.\n-   The value is a register class; perhaps CLASS, or perhaps another, smaller\n-   class.  On many machines, the following definition is safe:\n-\n-        #define PREFERRED_RELOAD_CLASS(X,CLASS) CLASS\n-\n-   Sometimes returning a more restrictive class makes better code.  For\n-   example, on the 68000, when X is an integer constant that is in range for a\n-   `moveq' instruction, the value of this macro is always `DATA_REGS' as long\n-   as CLASS includes the data registers.  Requiring a data register guarantees\n-   that a `moveq' will be used.\n-\n-   If X is a `const_double', by returning `NO_REGS' you can force X into a\n-   memory constant.  This is useful on certain machines where immediate\n-   floating values cannot be loaded into certain kinds of registers.  */\n-#define PREFERRED_RELOAD_CLASS(X, CLASS) CLASS\n-\n-/* Many machines have some registers that cannot be copied directly to or from\n-   memory or even from other types of registers.  An example is the `MQ'\n-   register, which on most machines, can only be copied to or from general\n-   registers, but not memory.  Some machines allow copying all registers to and\n-   from memory, but require a scratch register for stores to some memory\n-   locations (e.g., those with symbolic address on the RT, and those with\n-   certain symbolic address on the SPARC when compiling PIC).  In some cases,\n-   both an intermediate and a scratch register are required.\n-\n-   You should define these macros to indicate to the reload phase that it may\n-   need to allocate at least one register for a reload in addition to the\n-   register to contain the data.  Specifically, if copying X to a register\n-   CLASS in MODE requires an intermediate register, you should define\n-   `SECONDARY_INPUT_RELOAD_CLASS' to return the largest register class all of\n-   whose registers can be used as intermediate registers or scratch registers.\n-\n-   If copying a register CLASS in MODE to X requires an intermediate or scratch\n-   register, `SECONDARY_OUTPUT_RELOAD_CLASS' should be defined to return the\n-   largest register class required.  If the requirements for input and output\n-   reloads are the same, the macro `SECONDARY_RELOAD_CLASS' should be used\n-   instead of defining both macros identically.\n-\n-   The values returned by these macros are often `GENERAL_REGS'.  Return\n-   `NO_REGS' if no spare register is needed; i.e., if X can be directly copied\n-   to or from a register of CLASS in MODE without requiring a scratch register.\n-   Do not define this macro if it would always return `NO_REGS'.\n-\n-   If a scratch register is required (either with or without an intermediate\n-   register), you should define patterns for `reload_inM' or `reload_outM', as\n-   required (*note Standard Names::..  These patterns, which will normally be\n-   implemented with a `define_expand', should be similar to the `movM'\n-   patterns, except that operand 2 is the scratch register.\n-\n-   Define constraints for the reload register and scratch register that contain\n-   a single register class.  If the original reload register (whose class is\n-   CLASS) can meet the constraint given in the pattern, the value returned by\n-   these macros is used for the class of the scratch register.  Otherwise, two\n-   additional reload registers are required.  Their classes are obtained from\n-   the constraints in the insn pattern.\n-\n-   X might be a pseudo-register or a `subreg' of a pseudo-register, which could\n-   either be in a hard register or in memory.  Use `true_regnum' to find out;\n-   it will return -1 if the pseudo is in memory and the hard register number if\n-   it is in a register.\n-\n-   These macros should not be used in the case where a particular class of\n-   registers can only be copied to memory and not to another class of\n-   registers.  In that case, secondary reload registers are not needed and\n-   would not be helpful.  Instead, a stack location must be used to perform the\n-   copy and the `movM' pattern should use memory as an intermediate storage.\n-   This case often occurs between floating-point and general registers.  */\n-\n-#define SECONDARY_RELOAD_CLASS(CLASS, MODE, X)\t\t\t\t\\\n-((CLASS) == GPR_REGS\t\t? NO_REGS\t\t\t\t\\\n- : (CLASS) == EVEN_REGS\t\t? NO_REGS\t\t\t\t\\\n- : (CLASS) == ACCUM_REGS\t? EVEN_REGS\t\t\t\t\\\n- :\t\t\t\t  GPR_REGS)\n-\n-/* A C expression whose value is nonzero if pseudos that have been assigned to\n-   registers of class CLASS would likely be spilled because registers of CLASS\n-   are needed for spill registers.\n-\n-   The default value of this macro returns 1 if CLASS has exactly one register\n-   and zero otherwise.  On most machines, this default should be used.  Only\n-   define this macro to some other expression if pseudo allocated by\n-   `local-alloc.c' end up in memory because their hard registers were needed\n-   for spill registers.  If this macro returns nonzero for those classes, those\n-   pseudos will only be allocated by `global.c', which knows how to reallocate\n-   the pseudo to another register.  If there would not be another register\n-   available for reallocation, you should not change the definition of this\n-   macro since the only effect of such a definition would be to slow down\n-   register allocation.  */\n-#define CLASS_LIKELY_SPILLED_P(CLASS) \\\n-  ((CLASS) != GPR_REGS && (CLASS) != EVEN_REGS)\n-\n-/* A C expression for the maximum number of consecutive registers of\n-   class CLASS needed to hold a value of mode MODE.\n-\n-   This is closely related to the macro `HARD_REGNO_NREGS'.  In fact, the value\n-   of the macro `CLASS_MAX_NREGS (CLASS, MODE)' should be the maximum value of\n-   `HARD_REGNO_NREGS (REGNO, MODE)' for all REGNO values in the class CLASS.\n-\n-   This macro helps control the handling of multiple-word values in\n-   the reload pass.  */\n-\n-#define CLASS_MAX_NREGS(CLASS, MODE)\t\t\t\t\t\\\n-(((CLASS) == ACCUM_REGS)\t\t\t\t\t\t\\\n- ? ((GET_MODE_SIZE (MODE) + 8 - 1) / 8)\t\t\t\t\t\\\n- : ((GET_MODE_SIZE (MODE) + 4 - 1) / 4))\n-\n-/* A C expression that defines the machine-dependent operand constraint letters\n-   (`I', `J', `K', .. 'P') that specify particular ranges of integer values.\n-   If C is one of those letters, the expression should check that VALUE, an\n-   integer, is in the appropriate range and return 1 if so, 0 otherwise.  If C\n-   is not one of those letters, the value should be 0 regardless of VALUE.  */\n-#define CONST_OK_FOR_LETTER_P(VALUE, C)\t\t\t\t\t\\\n-((C) == 'I'\t? IN_RANGE_P (VALUE, -32, 31)\t\t\t\t\\\n- : (C) == 'J'\t? IN_RANGE_P (VALUE, 0, 31)\t\t\t\t\\\n- : (C) == 'K'\t? IN_RANGE_P (exact_log2 (VALUE), 0, 31)\t\t\\\n- : (C) == 'L'\t? IN_RANGE_P (exact_log2 (~ (VALUE)), 0, 31)\t\t\\\n- : (C) == 'M'\t? ((VALUE) == 32)\t\t\t\t\t\\\n- : (C) == 'N'\t? ((VALUE) == 1)\t\t\t\t\t\\\n- : (C) == 'O'\t? ((VALUE) == 0)\t\t\t\t\t\\\n- : (C) == 'P'\t? IN_RANGE_P (VALUE, 32, 63)\t\t\t\t\\\n- :\t\t  FALSE)\n-\n-/* A C expression that defines the machine-dependent operand constraint letters\n-   (`G', `H') that specify particular ranges of `const_double' values.\n-\n-   If C is one of those letters, the expression should check that VALUE, an RTX\n-   of code `const_double', is in the appropriate range and return 1 if so, 0\n-   otherwise.  If C is not one of those letters, the value should be 0\n-   regardless of VALUE.\n-\n-   `const_double' is used for all floating-point constants and for `DImode'\n-   fixed-point constants.  A given letter can accept either or both kinds of\n-   values.  It can use `GET_MODE' to distinguish between these kinds.  */\n-#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)\t\t\t\t\\\n-((C) == 'G'\t? (CONST_DOUBLE_LOW (VALUE) == 0\t\t\t\\\n-\t\t   && CONST_DOUBLE_HIGH (VALUE) == 0)\t\t\t\\\n- : (C) == 'H'\t? FALSE\t\t\t\t\t\t\t\\\n- :\t\t  FALSE)\n-\n-/* A C expression that defines the optional machine-dependent constraint\n-   letters (`Q', `R', `S', `T', `U') that can be used to segregate specific\n-   types of operands, usually memory references, for the target machine.\n-   Normally this macro will not be defined.  If it is required for a particular\n-   target machine, it should return 1 if VALUE corresponds to the operand type\n-   represented by the constraint letter C.  If C is not defined as an extra\n-   constraint, the value returned should be 0 regardless of VALUE.\n-\n-   For example, on the ROMP, load instructions cannot have their output in r0\n-   if the memory reference contains a symbolic address.  Constraint letter `Q'\n-   is defined as representing a memory address that does *not* contain a\n-   symbolic address.  An alternative is specified with a `Q' constraint on the\n-   input and `r' on the output.  The next alternative specifies `m' on the\n-   input and a register class that does not include r0 on the output.  */\n-\n-#define EXTRA_CONSTRAINT(VALUE, C)\t\t\t\t\t\\\n-(((C) == 'Q')\t? short_memory_operand ((VALUE), GET_MODE (VALUE))\t\\\n- : ((C) == 'R')\t? single_reg_memory_operand ((VALUE), GET_MODE (VALUE))\t\\\n- : ((C) == 'S')\t? const_addr_memory_operand ((VALUE), GET_MODE (VALUE))\t\\\n- : ((C) == 'T')\t? long_memory_operand ((VALUE), GET_MODE (VALUE))\t\\\n- : ((C) == 'U')\t? FALSE\t\t\t\t\t\t\t\\\n- :\t\t  FALSE)\n-\n-\f\n-/* Basic Stack Layout */\n-\n-/* Stack layout */\n-\n-/* Structure used to define the d30v stack */\n-typedef struct d30v_stack {\n-  int varargs_p;\t\t/* whether this is a varargs function */\n-  int varargs_size;\t\t/* size to hold varargs args passed in regs */\n-  int vars_size;\t\t/* variable save area size */\n-  int parm_size;\t\t/* outgoing parameter size */\n-  int gpr_size;\t\t\t/* size of saved GPR registers */\n-  int accum_size;\t\t/* size of saved ACCUM registers */\n-  int total_size;\t\t/* total bytes allocated for stack */\n-\t\t\t\t/* which registers are to be saved */\n-  int save_offset;\t\t/* offset from new sp to start saving vars at */\n-  int link_offset;\t\t/* offset r62 is saved at */\n-  int memrefs_varargs;\t\t/* # of 2 word memory references for varargs */\n-  int memrefs_2words;\t\t/* # of 2 word memory references */\n-  int memrefs_1word;\t\t/* # of 1 word memory references */\n-\t\t\t\t/* 1 for ldw/stw ops; 2 for ld2w/st2w ops */\n-  unsigned char save_p[FIRST_PSEUDO_REGISTER];\n-} d30v_stack_t;\n-\n-/* Define this macro if pushing a word onto the stack moves the stack pointer\n-   to a smaller address.\n-\n-   When we say, \"define this macro if ...,\" it means that the compiler checks\n-   this macro only with `#ifdef' so the precise definition used does not\n-   matter.  */\n-#define STACK_GROWS_DOWNWARD 1\n-\n-/* Offset from the frame pointer to the first local variable slot to be\n-   allocated.\n-\n-   If `FRAME_GROWS_DOWNWARD', find the next slot's offset by subtracting the\n-   first slot's length from `STARTING_FRAME_OFFSET'.  Otherwise, it is found by\n-   adding the length of the first slot to the value `STARTING_FRAME_OFFSET'.  */\n-\n-#define STARTING_FRAME_OFFSET\t\t\t\t\t\t\\\n-  (D30V_ALIGN (current_function_outgoing_args_size,\t\t\t\\\n-\t       (STACK_BOUNDARY / BITS_PER_UNIT)))\n-\n-/* Offset from the argument pointer register to the first argument's address.\n-   On some machines it may depend on the data type of the function.\n-\n-   If `ARGS_GROW_DOWNWARD', this is the offset to the location above the first\n-   argument's address.  */\n-#define FIRST_PARM_OFFSET(FUNDECL) 0\n-\n-/* A C expression whose value is RTL representing the value of the return\n-   address for the frame COUNT steps up from the current frame, after the\n-   prologue.  FRAMEADDR is the frame pointer of the COUNT frame, or the frame\n-   pointer of the COUNT - 1 frame if `RETURN_ADDR_IN_PREVIOUS_FRAME' is\n-   defined.\n-\n-   The value of the expression must always be the correct address when COUNT is\n-   zero, but may be `NULL_RTX' if there is not way to determine the return\n-   address of other frames.  */\n-\n-/* ??? This definition fails for leaf functions.  There is currently no\n-   general solution for this problem.  */\n-\n-/* ??? There appears to be no way to get the return address of any previous\n-   frame except by disassembling instructions in the prologue/epilogue.\n-   So currently we support only the current frame.  */\n-\n-#define RETURN_ADDR_RTX(COUNT, FRAME)\t\t\t\t\t\\\n-  ((COUNT) == 0 ? d30v_return_addr() : const0_rtx)\n-\n-/* A C expression whose value is RTL representing the location of the incoming\n-   return address at the beginning of any function, before the prologue.  This\n-   RTL is either a `REG', indicating that the return value is saved in `REG',\n-   or a `MEM' representing a location in the stack.\n-\n-   You only need to define this macro if you want to support call frame\n-   debugging information like that provided by DWARF 2.  */\n-\n-/* Before the prologue, RA lives in r62.  */\n-#define INCOMING_RETURN_ADDR_RTX  gen_rtx (REG, Pmode, GPR_LINK)\n-\n-/* A C expression whose value is an integer giving the offset, in bytes, from\n-   the value of the stack pointer register to the top of the stack frame at the\n-   beginning of any function, before the prologue.  The top of the frame is\n-   defined to be the value of the stack pointer in the previous frame, just\n-   before the call instruction.\n-\n-   You only need to define this macro if you want to support call frame\n-   debugging information like that provided by DWARF 2.  */\n-#define INCOMING_FRAME_SP_OFFSET 0\n-\n-/* Initialize data used by insn expanders.  This is called from insn_emit,\n-   once for every function before code is generated.  */\n-\n-#define INIT_EXPANDERS  d30v_init_expanders ()\n-\n-\f\n-/* Register That Address the Stack Frame.  */\n-\n-/* The register number of the stack pointer register, which must also be a\n-   fixed register according to `FIXED_REGISTERS'.  On most machines, the\n-   hardware determines which register this is.  */\n-#define STACK_POINTER_REGNUM GPR_SP\n-\n-/* The register number of the frame pointer register, which is used to access\n-   automatic variables in the stack frame.  On some machines, the hardware\n-   determines which register this is.  On other machines, you can choose any\n-   register you wish for this purpose.  */\n-#define FRAME_POINTER_REGNUM GPR_FP\n-\n-/* Register numbers used for passing a function's static chain pointer.  If\n-   register windows are used, the register number as seen by the called\n-   function is `STATIC_CHAIN_INCOMING_REGNUM', while the register number as\n-   seen by the calling function is `STATIC_CHAIN_REGNUM'.  If these registers\n-   are the same, `STATIC_CHAIN_INCOMING_REGNUM' need not be defined.\n-\n-   The static chain register need not be a fixed register.\n-\n-   If the static chain is passed in memory, these macros should not be defined;\n-   instead, the next two macros should be defined.  */\n-\n-#define STATIC_CHAIN_REGNUM (GPR_FIRST + 18)\n-\n-\f\n-/* Eliminating the Frame Pointer and the Arg Pointer */\n-\n-/* A C expression which is nonzero if a function must have and use a frame\n-   pointer.  This expression is evaluated in the reload pass.  If its value is\n-   nonzero the function will have a frame pointer.\n-\n-   The expression can in principle examine the current function and decide\n-   according to the facts, but on most machines the constant 0 or the constant\n-   1 suffices.  Use 0 when the machine allows code to be generated with no\n-   frame pointer, and doing so saves some time or space.  Use 1 when there is\n-   no possible advantage to avoiding a frame pointer.\n-\n-   In certain cases, the compiler does not know how to produce valid code\n-   without a frame pointer.  The compiler recognizes those cases and\n-   automatically gives the function a frame pointer regardless of what\n-   `FRAME_POINTER_REQUIRED' says.  You don't need to worry about them.\n-\n-   In a function that does not require a frame pointer, the frame pointer\n-   register can be allocated for ordinary usage, unless you mark it as a fixed\n-   register.  See `FIXED_REGISTERS' for more information.  */\n-#define FRAME_POINTER_REQUIRED 0\n-\n-/* If defined, this macro specifies a table of register pairs used to eliminate\n-   unneeded registers that point into the stack frame.  If it is not defined,\n-   the only elimination attempted by the compiler is to replace references to\n-   the frame pointer with references to the stack pointer.\n-\n-   The definition of this macro is a list of structure initializations, each of\n-   which specifies an original and replacement register.\n-\n-   On some machines, the position of the argument pointer is not known until\n-   the compilation is completed.  In such a case, a separate hard register must\n-   be used for the argument pointer.  This register can be eliminated by\n-   replacing it with either the frame pointer or the argument pointer,\n-   depending on whether or not the frame pointer has been eliminated.\n-\n-   In this case, you might specify:\n-        #define ELIMINABLE_REGS  \\\n-        {{ARG_POINTER_REGNUM, STACK_POINTER_REGNUM}, \\\n-         {ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM}, \\\n-         {FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM}}\n-\n-   Note that the elimination of the argument pointer with the stack pointer is\n-   specified first since that is the preferred elimination.  */\n-#define ELIMINABLE_REGS\t\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  { ARG_POINTER_REGNUM,\t\tSTACK_POINTER_REGNUM },\t\t\t\\\n-  { ARG_POINTER_REGNUM,\t\tFRAME_POINTER_REGNUM },\t\t\t\\\n-  { FRAME_POINTER_REGNUM,\tSTACK_POINTER_REGNUM }\t\t\t\\\n-}\n-\n-/* A C expression that returns nonzero if the compiler is allowed to try to\n-   replace register number FROM-REG with register number TO-REG.  This macro\n-   need only be defined if `ELIMINABLE_REGS' is defined, and will usually be\n-   the constant 1, since most of the cases preventing register elimination are\n-   things that the compiler already knows about.  */\n-\n-#define CAN_ELIMINATE(FROM, TO)\t\t\t\t\t\t\\\n- ((FROM) == ARG_POINTER_REGNUM && (TO) == STACK_POINTER_REGNUM\t\t\\\n-  ? ! frame_pointer_needed\t\t\t\t\t\t\\\n-  : 1)\n-\n-/* This macro is similar to `INITIAL_FRAME_POINTER_OFFSET'.  It specifies the\n-   initial difference between the specified pair of registers.  This macro must\n-   be defined if `ELIMINABLE_REGS' is defined.  */\n-\n-#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  d30v_stack_t *info = d30v_stack_info ();\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  if ((FROM) == FRAME_POINTER_REGNUM)\t\t\t\t\t\\\n-    (OFFSET) = 0;\t\t\t\t\t\t\t\\\n-  else if ((FROM) == ARG_POINTER_REGNUM)\t\t\t\t\\\n-    (OFFSET) = info->total_size - current_function_pretend_args_size;\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    abort ();\t\t\t\t\t\t\t\t\\\n-}\n-\n-\f\n-/* Passing Function Arguments on the Stack */\n-\n-/* If defined, the maximum amount of space required for outgoing arguments will\n-   be computed and placed into the variable\n-   `current_function_outgoing_args_size'.  No space will be pushed onto the\n-   stack for each call; instead, the function prologue should increase the\n-   stack frame size by this amount.\n-\n-   Defining both `PUSH_ROUNDING' and `ACCUMULATE_OUTGOING_ARGS' is not\n-   proper.  */\n-#define ACCUMULATE_OUTGOING_ARGS 1\n-\n-/* A C expression that should indicate the number of bytes of its own arguments\n-   that a function pops on returning, or 0 if the function pops no arguments\n-   and the caller must therefore pop them all after the function returns.\n-\n-   FUNDECL is a C variable whose value is a tree node that describes the\n-   function in question.  Normally it is a node of type `FUNCTION_DECL' that\n-   describes the declaration of the function.  From this it is possible to\n-   obtain the DECL_ATTRIBUTES of the function.\n-\n-   FUNTYPE is a C variable whose value is a tree node that describes the\n-   function in question.  Normally it is a node of type `FUNCTION_TYPE' that\n-   describes the data type of the function.  From this it is possible to obtain\n-   the data types of the value and arguments (if known).\n-\n-   When a call to a library function is being considered, FUNTYPE will contain\n-   an identifier node for the library function.  Thus, if you need to\n-   distinguish among various library functions, you can do so by their names.\n-   Note that \"library function\" in this context means a function used to\n-   perform arithmetic, whose name is known specially in the compiler and was\n-   not mentioned in the C code being compiled.\n-\n-   STACK-SIZE is the number of bytes of arguments passed on the stack.  If a\n-   variable number of bytes is passed, it is zero, and argument popping will\n-   always be the responsibility of the calling function.\n-\n-   On the VAX, all functions always pop their arguments, so the definition of\n-   this macro is STACK-SIZE.  On the 68000, using the standard calling\n-   convention, no functions pop their arguments, so the value of the macro is\n-   always 0 in this case.  But an alternative calling convention is available\n-   in which functions that take a fixed number of arguments pop them but other\n-   functions (such as `printf') pop nothing (the caller pops all).  When this\n-   convention is in use, FUNTYPE is examined to determine whether a function\n-   takes a fixed number of arguments.  */\n-#define RETURN_POPS_ARGS(FUNDECL, FUNTYPE, STACK_SIZE) 0\n-\n-\f\n-/* Function Arguments in Registers */\n-\n-/* A C expression that controls whether a function argument is passed in a\n-   register, and which register.\n-\n-   The arguments are CUM, which summarizes all the previous arguments; MODE,\n-   the machine mode of the argument; TYPE, the data type of the argument as a\n-   tree node or 0 if that is not known (which happens for C support library\n-   functions); and NAMED, which is 1 for an ordinary argument and 0 for\n-   nameless arguments that correspond to `...' in the called function's\n-   prototype.\n-\n-   The value of the expression should either be a `reg' RTX for the hard\n-   register in which to pass the argument, or zero to pass the argument on the\n-   stack.\n-\n-   For machines like the VAX and 68000, where normally all arguments are\n-   pushed, zero suffices as a definition.\n-\n-   The usual way to make the ANSI library `stdarg.h' work on a machine where\n-   some arguments are usually passed in registers, is to cause nameless\n-   arguments to be passed on the stack instead.  This is done by making\n-   `FUNCTION_ARG' return 0 whenever NAMED is 0.\n-\n-   You may use the macro `MUST_PASS_IN_STACK (MODE, TYPE)' in the definition of\n-   this macro to determine if this argument is of a type that must be passed in\n-   the stack.  If `REG_PARM_STACK_SPACE' is not defined and `FUNCTION_ARG'\n-   returns nonzero for such an argument, the compiler will abort.  If\n-   `REG_PARM_STACK_SPACE' is defined, the argument will be computed in the\n-   stack and then loaded into a register.  */\n-\n-#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n-  d30v_function_arg (&CUM, (int)MODE, TYPE, NAMED, FALSE)\n-\n-/* Define this macro if the target machine has \"register windows\", so that the\n-   register in which a function sees an arguments is not necessarily the same\n-   as the one in which the caller passed the argument.\n-\n-   For such machines, `FUNCTION_ARG' computes the register in which the caller\n-   passes the value, and `FUNCTION_INCOMING_ARG' should be defined in a similar\n-   fashion to tell the function being called where the arguments will arrive.\n-\n-   If `FUNCTION_INCOMING_ARG' is not defined, `FUNCTION_ARG' serves both\n-   purposes.  */\n-\n-#define FUNCTION_INCOMING_ARG(CUM, MODE, TYPE, NAMED) \\\n-  d30v_function_arg (&CUM, (int)MODE, TYPE, NAMED, TRUE)\n-\n-/* A C expression for the number of words, at the beginning of an argument,\n-   must be put in registers.  The value must be zero for arguments that are\n-   passed entirely in registers or that are entirely pushed on the stack.\n-\n-   On some machines, certain arguments must be passed partially in registers\n-   and partially in memory.  On these machines, typically the first N words of\n-   arguments are passed in registers, and the rest on the stack.  If a\n-   multi-word argument (a `double' or a structure) crosses that boundary, its\n-   first few words must be passed in registers and the rest must be pushed.\n-   This macro tells the compiler when this occurs, and how many of the words\n-   should go in registers.\n-\n-   `FUNCTION_ARG' for these arguments should return the first register to be\n-   used by the caller for this argument; likewise `FUNCTION_INCOMING_ARG', for\n-   the called function.  */\n-#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) \\\n-  d30v_function_arg_partial_nregs (&CUM, (int)MODE, TYPE, NAMED)\n-\n-/* A C expression that indicates when an argument must be passed by reference.\n-   If nonzero for an argument, a copy of that argument is made in memory and a\n-   pointer to the argument is passed instead of the argument itself.  The\n-   pointer is passed in whatever way is appropriate for passing a pointer to\n-   that type.\n-\n-   On machines where `REG_PARM_STACK_SPACE' is not defined, a suitable\n-   definition of this macro might be\n-        #define FUNCTION_ARG_PASS_BY_REFERENCE\\\n-        (CUM, MODE, TYPE, NAMED)  \\\n-          MUST_PASS_IN_STACK (MODE, TYPE)  */\n-#define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED) 0\n-\n-/* A C type for declaring a variable that is used as the first argument of\n-   `FUNCTION_ARG' and other related values.  For some target machines, the type\n-   `int' suffices and can hold the number of bytes of argument so far.\n-\n-   There is no need to record in `CUMULATIVE_ARGS' anything about the arguments\n-   that have been passed on the stack.  The compiler has other variables to\n-   keep track of that.  For target machines on which all arguments are passed\n-   on the stack, there is no need to store anything in `CUMULATIVE_ARGS';\n-   however, the data structure must exist and should not be empty, so use\n-   `int'.  */\n-#define CUMULATIVE_ARGS int\n-\n-/* A C statement (sans semicolon) for initializing the variable CUM for the\n-   state at the beginning of the argument list.  The variable has type\n-   `CUMULATIVE_ARGS'.  The value of FNTYPE is the tree node for the data type\n-   of the function which will receive the args, or 0 if the args are to a\n-   compiler support library function.  The value of INDIRECT is nonzero when\n-   processing an indirect call, for example a call through a function pointer.\n-   The value of INDIRECT is zero for a call to an explicitly named function, a\n-   library function call, or when `INIT_CUMULATIVE_ARGS' is used to find\n-   arguments for the function being compiled.\n-\n-   When processing a call to a compiler support library function, LIBNAME\n-   identifies which one.  It is a `symbol_ref' rtx which contains the name of\n-   the function, as a string.  LIBNAME is 0 when an ordinary C function call is\n-   being processed.  Thus, each time this macro is called, either LIBNAME or\n-   FNTYPE is nonzero, but never both of them at once.  */\n-\n-#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, FNDECL) \\\n-  d30v_init_cumulative_args (&CUM, FNTYPE, LIBNAME, FNDECL, FALSE)\n-\n-/* Like `INIT_CUMULATIVE_ARGS' but overrides it for the purposes of finding the\n-   arguments for the function being compiled.  If this macro is undefined,\n-   `INIT_CUMULATIVE_ARGS' is used instead.\n-\n-   The value passed for LIBNAME is always 0, since library routines with\n-   special calling conventions are never compiled with GCC.  The argument\n-   LIBNAME exists for symmetry with `INIT_CUMULATIVE_ARGS'.  */\n-\n-#define INIT_CUMULATIVE_INCOMING_ARGS(CUM, FNTYPE, LIBNAME) \\\n-  d30v_init_cumulative_args (&CUM, FNTYPE, LIBNAME, NULL, TRUE)\n-\n-/* A C statement (sans semicolon) to update the summarizer variable CUM to\n-   advance past an argument in the argument list.  The values MODE, TYPE and\n-   NAMED describe that argument.  Once this is done, the variable CUM is\n-   suitable for analyzing the *following* argument with `FUNCTION_ARG', etc.\n-\n-   This macro need not do anything if the argument in question was passed on\n-   the stack.  The compiler knows how to track the amount of stack space used\n-   for arguments without any special help.  */\n-\n-#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED) \\\n-  d30v_function_arg_advance (&CUM, (int) MODE, TYPE, NAMED)\n-\n-/* If defined, a C expression that gives the alignment boundary, in bits, of an\n-   argument with the specified mode and type.  If it is not defined,\n-   `PARM_BOUNDARY' is used for all arguments.  */\n-\n-#define FUNCTION_ARG_BOUNDARY(MODE, TYPE) \\\n-  d30v_function_arg_boundary ((int) MODE, TYPE)\n-\n-/* A C expression that is nonzero if REGNO is the number of a hard register in\n-   which function arguments are sometimes passed.  This does *not* include\n-   implicit arguments such as the static chain and the structure-value address.\n-   On many machines, no registers can be used for this purpose since all\n-   function arguments are pushed on the stack.  */\n-\n-#define FUNCTION_ARG_REGNO_P(REGNO) \\\n-  IN_RANGE_P (REGNO, GPR_ARG_FIRST, GPR_ARG_LAST)\n-\n-\f\n-/* How Scalar Function Values are Returned */\n-\n-/* A C expression to create an RTX representing the place where a function\n-   returns a value of data type VALTYPE.  VALTYPE is a tree node representing a\n-   data type.  Write `TYPE_MODE (VALTYPE)' to get the machine mode used to\n-   represent that type.  On many machines, only the mode is relevant.\n-   (Actually, on most machines, scalar values are returned in the same place\n-   regardless of mode).\n-\n-   If `PROMOTE_FUNCTION_RETURN' is defined, you must apply the same promotion\n-   rules specified in `PROMOTE_MODE' if VALTYPE is a scalar type.\n-\n-   If the precise function being called is known, FUNC is a tree node\n-   (`FUNCTION_DECL') for it; otherwise, FUNC is a null pointer.  This makes it\n-   possible to use a different value-returning convention for specific\n-   functions when all their calls are known.\n-\n-   `FUNCTION_VALUE' is not used for return vales with aggregate data types,\n-   because these are returned in another way.  See `STRUCT_VALUE_REGNUM' and\n-   related macros, below.  */\n-\n-#define FUNCTION_VALUE(VALTYPE, FUNC) \\\n-  gen_rtx (REG, TYPE_MODE (VALTYPE), GPR_RET_VALUE)\n-\n-/* A C expression to create an RTX representing the place where a library\n-   function returns a value of mode MODE.  If the precise function being called\n-   is known, FUNC is a tree node (`FUNCTION_DECL') for it; otherwise, FUNC is a\n-   null pointer.  This makes it possible to use a different value-returning\n-   convention for specific functions when all their calls are known.\n-\n-   Note that \"library function\" in this context means a compiler support\n-   routine, used to perform arithmetic, whose name is known specially by the\n-   compiler and was not mentioned in the C code being compiled.\n-\n-   The definition of `LIBRARY_VALUE' need not be concerned aggregate data\n-   types, because none of the library functions returns such types.  */\n-\n-#define LIBCALL_VALUE(MODE) gen_rtx (REG, MODE, GPR_RET_VALUE)\n-\n-/* A C expression that is nonzero if REGNO is the number of a hard register in\n-   which the values of called function may come back.\n-\n-   A register whose use for returning values is limited to serving as the\n-   second of a pair (for a value of type `double', say) need not be recognized\n-   by this macro.  So for most machines, this definition suffices:\n-\n-        #define FUNCTION_VALUE_REGNO_P(N) ((N) == 0)\n-\n-   If the machine has register windows, so that the caller and the called\n-   function use different registers for the return value, this macro should\n-   recognize only the caller's register numbers.  */\n-\n-#define FUNCTION_VALUE_REGNO_P(REGNO) ((REGNO) == GPR_RET_VALUE)\n-\n-\f\n-/* How Large Values are Returned */\n-\n-/* If the structure value address is passed in a register, then\n-   `STRUCT_VALUE_REGNUM' should be the number of that register.  */\n-\n-#define STRUCT_VALUE_REGNUM GPR_ARG_FIRST\n-\n-/* If the structure value address is not passed in a register, define\n-   `STRUCT_VALUE' as an expression returning an RTX for the place where the\n-   address is passed.  If it returns 0, the address is passed as an \"invisible\"\n-   first argument.  */\n-\n-#define STRUCT_VALUE 0\n-\n-\f\n-/* Define this macro as a C expression that is nonzero for registers\n-   are used by the epilogue or the `return' pattern.  The stack and\n-   frame pointer registers are already be assumed to be used as\n-   needed.  */\n-#define EPILOGUE_USES(REGNO)  ((REGNO) == GPR_LINK)\n-\n-/* A C structure for machine-specific, per-function data.\n-   This is added to the cfun structure.  */\n-typedef struct machine_function GTY(())\n-{\n-  /* Additionsl stack adjustment in __builtin_eh_throw.  */\n-  rtx eh_epilogue_sp_ofs;\n-} machine_function;\n-\n-\f\n-/* Generating Code for Profiling.  */\n-\n-/* A C statement or compound statement to output to FILE some assembler code to\n-   call the profiling subroutine `mcount'.  Before calling, the assembler code\n-   must load the address of a counter variable into a register where `mcount'\n-   expects to find the address.  The name of this variable is `LP' followed by\n-   the number LABELNO, so you would generate the name using `LP%d' in a\n-   `fprintf'.\n-\n-   The details of how the address should be passed to `mcount' are determined\n-   by your operating system environment, not by GCC.  To figure them out,\n-   compile a small program for profiling using the system's installed C\n-   compiler and look at the assembler code that results.  */\n-\n-#define FUNCTION_PROFILER(FILE, LABELNO) d30v_function_profiler (FILE, LABELNO)\n-\n-\f\n-/* Implementing the Varargs Macros.  */\n-\n-/* If defined, is a C expression that produces the machine-specific code for a\n-   call to `__builtin_saveregs'.  This code will be moved to the very beginning\n-   of the function, before any parameter access are made.  The return value of\n-   this function should be an RTX that contains the value to use as the return\n-   of `__builtin_saveregs'.\n-\n-   If this macro is not defined, the compiler will output an ordinary call to\n-   the library function `__builtin_saveregs'.  */\n-\n-#define EXPAND_BUILTIN_SAVEREGS() d30v_expand_builtin_saveregs ()\n-\n-/* This macro offers an alternative to using `__builtin_saveregs' and defining\n-   the macro `EXPAND_BUILTIN_SAVEREGS'.  Use it to store the anonymous register\n-   arguments into the stack so that all the arguments appear to have been\n-   passed consecutively on the stack.  Once this is done, you can use the\n-   standard implementation of varargs that works for machines that pass all\n-   their arguments on the stack.\n-\n-   The argument ARGS_SO_FAR is the `CUMULATIVE_ARGS' data structure, containing\n-   the values that obtain after processing of the named arguments.  The\n-   arguments MODE and TYPE describe the last named argument--its machine mode\n-   and its data type as a tree node.\n-\n-   The macro implementation should do two things: first, push onto the stack\n-   all the argument registers *not* used for the named arguments, and second,\n-   store the size of the data thus pushed into the `int'-valued variable whose\n-   name is supplied as the argument PRETEND_ARGS_SIZE.  The value that you\n-   store here will serve as additional offset for setting up the stack frame.\n-\n-   Because you must generate code to push the anonymous arguments at compile\n-   time without knowing their data types, `SETUP_INCOMING_VARARGS' is only\n-   useful on machines that have just a single category of argument register and\n-   use it uniformly for all data types.\n-\n-   If the argument SECOND_TIME is nonzero, it means that the arguments of the\n-   function are being analyzed for the second time.  This happens for an inline\n-   function, which is not actually compiled until the end of the source file.\n-   The macro `SETUP_INCOMING_VARARGS' should not generate any instructions in\n-   this case.  */\n-\n-#define SETUP_INCOMING_VARARGS(ARGS_SO_FAR, MODE, TYPE, PRETEND_ARGS_SIZE, SECOND_TIME) \\\n-  d30v_setup_incoming_varargs (&ARGS_SO_FAR, (int) MODE, TYPE,\t\t\\\n-\t\t\t       &PRETEND_ARGS_SIZE, SECOND_TIME)\n-\n-/* Implement the stdarg/varargs va_start macro.  STDARG_P is nonzero if this\n-   is stdarg.h instead of varargs.h.  VALIST is the tree of the va_list\n-   variable to initialize.  NEXTARG is the machine independent notion of the\n-   'next' argument after the variable arguments.  If not defined, a standard\n-   implementation will be defined that works for arguments passed on the stack.  */\n-\n-#define EXPAND_BUILTIN_VA_START(VALIST, NEXTARG)\t\t\\\n-  d30v_expand_builtin_va_start(VALIST, NEXTARG)\n-\n-/* Implement the stdarg/varargs va_arg macro.  VALIST is the variable of type\n-   va_list as a tree, TYPE is the type passed to va_arg.  */\n-\n-#define EXPAND_BUILTIN_VA_ARG(VALIST, TYPE)\t\t\t\t\\\n-(d30v_expand_builtin_va_arg (VALIST, TYPE))\n-\f\n-/* Trampolines for Nested Functions.  */\n-\n-/* A C expression for the size in bytes of the trampoline, as an integer.  */\n-#define TRAMPOLINE_SIZE (d30v_trampoline_size ())\n-\n-/* Alignment required for trampolines, in bits.\n-\n-   If you don't define this macro, the value of `BIGGEST_ALIGNMENT' is used for\n-   aligning trampolines.  */\n-#define TRAMPOLINE_ALIGNMENT 64\n-\n-/* A C statement to initialize the variable parts of a trampoline.  ADDR is an\n-   RTX for the address of the trampoline; FNADDR is an RTX for the address of\n-   the nested function; STATIC_CHAIN is an RTX for the static chain value that\n-   should be passed to the function when it is called.  */\n-#define INITIALIZE_TRAMPOLINE(ADDR, FNADDR, STATIC_CHAIN) \\\n-  d30v_initialize_trampoline (ADDR, FNADDR, STATIC_CHAIN)\n-\n-\f\n-/* Addressing Modes */\n-\n-/* Define this macro if the machine supports post-increment addressing.  */\n-#define HAVE_POST_INCREMENT 1\n-\n-/* Similar for other kinds of addressing.  */\n-#define HAVE_POST_DECREMENT 1\n-\n-/* A C expression that is 1 if the RTX X is a constant which is a valid\n-   address.  On most machines, this can be defined as `CONSTANT_P (X)', but a\n-   few machines are more restrictive in which constant addresses are supported.\n-\n-   `CONSTANT_P' accepts integer-values expressions whose values are not\n-   explicitly known, such as `symbol_ref', `label_ref', and `high' expressions\n-   and `const' arithmetic expressions, in addition to `const_int' and\n-   `const_double' expressions.  */\n-#define CONSTANT_ADDRESS_P(X) CONSTANT_P (X)\n-\n-/* A number, the maximum number of registers that can appear in a valid memory\n-   address.  Note that it is up to you to specify a value equal to the maximum\n-   number that `GO_IF_LEGITIMATE_ADDRESS' would ever accept.  */\n-#define MAX_REGS_PER_ADDRESS 2\n-\n-/* A C compound statement with a conditional `goto LABEL;' executed if X (an\n-   RTX) is a legitimate memory address on the target machine for a memory\n-   operand of mode MODE.  */\n-\n-#ifdef\tREG_OK_STRICT\n-#define REG_OK_STRICT_P 1\n-#else\n-#define REG_OK_STRICT_P 0\n-#endif\n-\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-    if (d30v_legitimate_address_p ((int)MODE, X, REG_OK_STRICT_P))\t\\\n-      goto ADDR;\t\t\t\t\t\t\t\\\n-} while (0)\n-\n-/* A C expression that is nonzero if X (assumed to be a `reg' RTX) is valid for\n-   use as a base register.  For hard registers, it should always accept those\n-   which the hardware permits and reject the others.  Whether the macro accepts\n-   or rejects pseudo registers must be controlled by `REG_OK_STRICT' as\n-   described above.  This usually requires two variant definitions, of which\n-   `REG_OK_STRICT' controls the one actually used.  */\n-\n-#ifdef REG_OK_STRICT\n-#define REG_OK_FOR_BASE_P(X) (GPR_P (REGNO (X)))\n-#else\n-#define REG_OK_FOR_BASE_P(X) (GPR_OR_PSEUDO_P (REGNO (X)))\n-#endif\n-\n-/* A C expression that is nonzero if X (assumed to be a `reg' RTX) is valid for\n-   use as an index register.\n-\n-   The difference between an index register and a base register is that the\n-   index register may be scaled.  If an address involves the sum of two\n-   registers, neither one of them scaled, then either one may be labeled the\n-   \"base\" and the other the \"index\"; but whichever labeling is used must fit\n-   the machine's constraints of which registers may serve in each capacity.\n-   The compiler will try both labelings, looking for one that is valid, and\n-   will reload one or both registers only if neither labeling works.  */\n-\n-#define REG_OK_FOR_INDEX_P(X) REG_OK_FOR_BASE_P (X)\n-\n-/* A C compound statement that attempts to replace X with a valid memory\n-   address for an operand of mode MODE.  WIN will be a C statement label\n-   elsewhere in the code; the macro definition may use\n-\n-        GO_IF_LEGITIMATE_ADDRESS (MODE, X, WIN);\n-\n-   to avoid further processing if the address has become legitimate.\n-\n-   X will always be the result of a call to `break_out_memory_refs', and OLDX\n-   will be the operand that was given to that function to produce X.\n-\n-   The code generated by this macro should not alter the substructure of X.  If\n-   it transforms X into a more legitimate form, it should assign X (which will\n-   always be a C variable) a new value.\n-\n-   It is not necessary for this macro to come up with a legitimate address.\n-   The compiler has standard ways of doing so in all cases.  In fact, it is\n-   safe for this macro to do nothing.  But often a machine-dependent strategy\n-   can generate better code.  */\n-\n-#define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)\t\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  rtx y = d30v_legitimize_address (X, OLDX, (int)MODE, REG_OK_STRICT_P); \\\n-  if (y)\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      X = y;\t\t\t\t\t\t\t\t\\\n-      GO_IF_LEGITIMATE_ADDRESS (MODE, X, WIN);\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-} while (0)\n-\n-/* A C statement or compound statement with a conditional `goto LABEL;'\n-   executed if memory address X (an RTX) can have different meanings depending\n-   on the machine mode of the memory reference it is used for or if the address\n-   is valid for some modes but not others.\n-\n-   Autoincrement and autodecrement addresses typically have mode-dependent\n-   effects because the amount of the increment or decrement is the size of the\n-   operand being addressed.  Some machines have other mode-dependent addresses.\n-   Many RISC machines have no mode-dependent addresses.\n-\n-   You may assume that ADDR is a valid address for the machine.  */\n-\n-#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR, LABEL)\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  if (d30v_mode_dependent_address_p (ADDR))\t\t\t\t\\\n-    goto LABEL;\t\t\t\t\t\t\t\t\\\n-} while (0)\t\t\t\t\t\t\t\t\\\n-\n-/* A C expression that is nonzero if X is a legitimate constant for an\n-   immediate operand on the target machine.  You can assume that X satisfies\n-   `CONSTANT_P', so you need not check this.  In fact, `1' is a suitable\n-   definition for this macro on machines where anything `CONSTANT_P' is valid.  */\n-#define LEGITIMATE_CONSTANT_P(X) 1\n-\n-\f\n-/* Describing Relative Costs of Operations */\n-\n-/* A C expression for the cost of moving data from a register in class FROM to\n-   one in class TO.  The classes are expressed using the enumeration values\n-   such as `GENERAL_REGS'.  A value of 4 is the default; other values are\n-   interpreted relative to that.\n-\n-   It is not required that the cost always equal 2 when FROM is the same as TO;\n-   on some machines it is expensive to move between registers if they are not\n-   general registers.\n-\n-   If reload sees an insn consisting of a single `set' between two hard\n-   registers, and if `REGISTER_MOVE_COST' applied to their classes returns a\n-   value of 2, reload does not check to ensure that the constraints of the insn\n-   are met.  Setting a cost of other than 2 will allow reload to verify that\n-   the constraints are met.  You should do this if the `movM' pattern's\n-   constraints do not allow such copying.  */\n-\n-#define REGISTER_MOVE_COST(MODE, FROM, TO)\t\t\t\t\\\n-  (((FROM) != GPR_REGS && (FROM) != EVEN_REGS\t\t\t\t\\\n-   && (TO) != GPR_REGS && (TO) != EVEN_REGS) ? 4 : 2)\n-\n-/* A C expression for the cost of moving data of mode M between a register and\n-   memory.  A value of 2 is the default; this cost is relative to those in\n-   `REGISTER_MOVE_COST'.\n-\n-   If moving between registers and memory is more expensive than between two\n-   registers, you should define this macro to express the relative cost.  */\n-#define MEMORY_MOVE_COST(M,C,I) 4\n-\n-/* A C expression for the cost of a branch instruction.  A value of 1 is the\n-   default; other values are interpreted relative to that.  */\n-\n-#define BRANCH_COST d30v_branch_cost\n-\n-#define D30V_DEFAULT_BRANCH_COST 2\n-\n-/* Values of the -mbranch-cost=n string.  */\n-extern int d30v_branch_cost;\n-extern const char *d30v_branch_cost_string;\n-\n-/* Here are additional macros which do not specify precise relative costs, but\n-   only that certain actions are more expensive than GCC would ordinarily\n-   expect.  */\n-\n-/* Define this macro as a C expression which is nonzero if accessing less than\n-   a word of memory (i.e. a `char' or a `short') is no faster than accessing a\n-   word of memory, i.e., if such access require more than one instruction or if\n-   there is no difference in cost between byte and (aligned) word loads.\n-\n-   When this macro is not defined, the compiler will access a field by finding\n-   the smallest containing object; when it is defined, a fullword load will be\n-   used if alignment permits.  Unless bytes accesses are faster than word\n-   accesses, using word accesses is preferable since it may eliminate\n-   subsequent memory access if subsequent accesses occur to other fields in the\n-   same word of the structure, but to different bytes.  */\n-#define SLOW_BYTE_ACCESS 1\n-\n-/* Define this macro if it is as good or better to call a constant function\n-   address than to call an address kept in a register.  */\n-#define NO_FUNCTION_CSE\n-\n-\f\n-/* Dividing the output into sections.  */\n-\n-/* A C expression whose value is a string containing the assembler operation\n-   that should precede instructions and read-only data.  Normally `\".text\"' is\n-   right.  */\n-#define TEXT_SECTION_ASM_OP \"\\t.text\"\n-\n-/* A C expression whose value is a string containing the assembler operation to\n-   identify the following data as writable initialized data.  Normally\n-   `\".data\"' is right.  */\n-#define DATA_SECTION_ASM_OP \"\\t.data\"\n-\n-/* If defined, a C expression whose value is a string containing the\n-   assembler operation to identify the following data as\n-   uninitialized global data.  If not defined, and neither\n-   `ASM_OUTPUT_BSS' nor `ASM_OUTPUT_ALIGNED_BSS' are defined,\n-   uninitialized global data will be output in the data section if\n-   `-fno-common' is passed, otherwise `ASM_OUTPUT_COMMON' will be\n-   used.  */\n-#define BSS_SECTION_ASM_OP \"\\t.section .bss\"\n-\n-\f\n-/* The Overall Framework of an Assembler File.  */\n-\n-/* A C string constant describing how to begin a comment in the target\n-   assembler language.  The compiler assumes that the comment will end at the\n-   end of the line.  */\n-#define ASM_COMMENT_START \";\"\n-\n-/* A C string constant for text to be output before each `asm' statement or\n-   group of consecutive ones.  Normally this is `\"#APP\"', which is a comment\n-   that has no effect on most assemblers but tells the GNU assembler that it\n-   must check the lines that follow for all valid assembler constructs.  */\n-#define ASM_APP_ON \"#APP\\n\"\n-\n-/* A C string constant for text to be output after each `asm' statement or\n-   group of consecutive ones.  Normally this is `\"#NO_APP\"', which tells the\n-   GNU assembler to resume making the time-saving assumptions that are valid\n-   for ordinary compiler output.  */\n-#define ASM_APP_OFF \"#NO_APP\\n\"\n-\n-\f\n-/* Output and Generation of Labels.  */\n-\n-/* Globalizing directive for a label.  */\n-#define GLOBAL_ASM_OP \"\\t.globl \"\n-\n-\f\n-/* Macros Controlling Initialization Routines.  */\n-\n-/* If defined, `main' will call `__main' despite the presence of\n-   `INIT_SECTION_ASM_OP'.  This macro should be defined for systems where the\n-   init section is not actually run automatically, but is still useful for\n-   collecting the lists of constructors and destructors.  */\n-#define INVOKE__main\n-\n-\f\n-/* Output of Assembler Instructions.  */\n-\n-/* A C initializer containing the assembler's names for the machine registers,\n-   each one as a C string constant.  This is what translates register numbers\n-   in the compiler into assembler language.  */\n-#define REGISTER_NAMES\t\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  \"r0\",\t\t\"r1\",\t\t\"r2\",\t\t\"r3\",\t\t\t\\\n-  \"r4\",\t\t\"r5\",\t\t\"r6\",\t\t\"r7\",\t\t\t\\\n-  \"r8\",\t\t\"r9\",\t\t\"r10\",\t\t\"r11\",\t\t\t\\\n-  \"r12\",\t\"r13\",\t\t\"r14\",\t\t\"r15\",\t\t\t\\\n-  \"r16\",\t\"r17\",\t\t\"r18\",\t\t\"r19\",\t\t\t\\\n-  \"r20\",\t\"r21\",\t\t\"r22\",\t\t\"r23\",\t\t\t\\\n-  \"r24\",\t\"r25\",\t\t\"r26\",\t\t\"r27\",\t\t\t\\\n-  \"r28\",\t\"r29\",\t\t\"r30\",\t\t\"r31\",\t\t\t\\\n-  \"r32\",\t\"r33\",\t\t\"r34\",\t\t\"r35\",\t\t\t\\\n-  \"r36\",\t\"r37\",\t\t\"r38\",\t\t\"r39\",\t\t\t\\\n-  \"r40\",\t\"r41\",\t\t\"r42\",\t\t\"r43\",\t\t\t\\\n-  \"r44\",\t\"r45\",\t\t\"r46\",\t\t\"r47\",\t\t\t\\\n-  \"r48\",\t\"r49\",\t\t\"r50\",\t\t\"r51\",\t\t\t\\\n-  \"r52\",\t\"r53\",\t\t\"r54\",\t\t\"r55\",\t\t\t\\\n-  \"r56\",\t\"r57\",\t\t\"r58\",\t\t\"r59\",\t\t\t\\\n-  \"r60\",\t\"r61\",\t\t\"link\",\t\t\"sp\",\t\t\t\\\n-  \"ap\",\t\t\t\t\t\t\t\t\t\\\n-  \"f0\",\t\t\"f1\",\t\t\"f2\",\t\t\"f3\",\t\t\t\\\n-  \"s\",\t\t\"v\",\t\t\"va\",\t\t\"c\",\t\t\t\\\n-  \"a0\",\t\t\"a1\",\t\t\t\t\t\t\t\\\n-  \"psw\",\t\"bpsw\",\t\t\"pc\",\t\t\"bpc\",\t\t\t\\\n-  \"dpsw\",\t\"dpc\",\t\t\"rpt_c\",\t\"rpt_s\",\t\t\\\n-  \"rpt_e\",\t\"mod_s\",\t\"mod_e\",\t\"iba\",\t\t\t\\\n-  \"eit_vb\",\t\"int_s\",\t\"int_m\",\t\t\t\t\\\n-}\n-\n-/* If defined, a C initializer for an array of structures containing a name and\n-   a register number.  This macro defines additional names for hard registers,\n-   thus allowing the `asm' option in declarations to refer to registers using\n-   alternate names.  */\n-#define ADDITIONAL_REGISTER_NAMES\t\t\\\n-{\t\t\t\t\t\t\\\n-  {\"r62\",\tGPR_LINK},\t\t\t\\\n-  {\"r63\",\tGPR_SP},\t\t\t\\\n-  {\"f4\",\tFLAG_SAT},\t\t\t\\\n-  {\"f5\",\tFLAG_OVERFLOW},\t\t\t\\\n-  {\"f6\",\tFLAG_ACC_OVER},\t\t\t\\\n-  {\"f7\",\tFLAG_CARRY},\t\t\t\\\n-  {\"carry\",\tFLAG_CARRY},\t\t\t\\\n-  {\"borrow\",\tFLAG_BORROW},\t\t\t\\\n-  {\"b\",\t\tFLAG_BORROW},\t\t\t\\\n-  {\"cr0\",\tCR_PSW},\t\t\t\\\n-  {\"cr1\",\tCR_BPSW},\t\t\t\\\n-  {\"cr2\",\tCR_PC},\t\t\t\t\\\n-  {\"cr3\",\tCR_BPC},\t\t\t\\\n-  {\"cr4\",\tCR_DPSW},\t\t\t\\\n-  {\"cr5\",\tCR_DPC},\t\t\t\\\n-  {\"cr7\",\tCR_RPT_C},\t\t\t\\\n-  {\"cr8\",\tCR_RPT_S},\t\t\t\\\n-  {\"cr9\",\tCR_RPT_E},\t\t\t\\\n-  {\"cr10\",\tCR_MOD_S},\t\t\t\\\n-  {\"cr11\",\tCR_MOD_E},\t\t\t\\\n-  {\"cr14\",\tCR_IBA},\t\t\t\\\n-  {\"cr15\",\tCR_EIT_VB},\t\t\t\\\n-  {\"cr16\",\tCR_INT_S},\t\t\t\\\n-  {\"cr17\",\tCR_INT_M}\t\t\t\\\n-}\n-\n-/* A C compound statement to output to stdio stream STREAM the assembler syntax\n-   for an instruction operand X.  X is an RTL expression.\n-\n-   CODE is a value that can be used to specify one of several ways of printing\n-   the operand.  It is used when identical operands must be printed differently\n-   depending on the context.  CODE comes from the `%' specification that was\n-   used to request printing of the operand.  If the specification was just\n-   `%DIGIT' then CODE is 0; if the specification was `%LTR DIGIT' then CODE is\n-   the ASCII code for LTR.\n-\n-   If X is a register, this macro should print the register's name.  The names\n-   can be found in an array `reg_names' whose type is `char *[]'.  `reg_names'\n-   is initialized from `REGISTER_NAMES'.\n-\n-   When the machine description has a specification `%PUNCT' (a `%' followed by\n-   a punctuation character), this macro is called with a null pointer for X and\n-   the punctuation character for CODE.\n-\n-   Standard operand flags that are handled elsewhere:\n-\t`='  Output a number unique to each instruction in the compilation.\n-\t`a'  Substitute an operand as if it were a memory reference.\n-\t`c'  Omit the syntax that indicates an immediate operand.\n-\t`l'  Substitute a LABEL_REF into a jump instruction.\n-\t`n'  Like %cDIGIT, except negate the value before printing.\n-\n-   The d30v specific operand flags are:\n-\t`.'  Print r0.\n-\t`f'  Print a SF constant as an int.\n-\t`s'  Subtract 32 and negate.\n-\t`A'  Print accumulator number without an `a' in front of it.\n-\t`B'  Print bit offset for BSET, etc. instructions.\n-\t`E'  Print u if this is zero extend, nothing if this is sign extend.\n-\t`F'  Emit /{f,t,x}{f,t,x} for executing a false condition.\n-\t`L'  Print the lower half of a 64 bit item.\n-\t`M'  Print a memory reference for ld/st instructions.\n-\t`R'  Return appropriate cmp instruction for relational test.\n-\t`S'  Subtract 32.\n-\t`T'  Emit /{f,t,x}{f,t,x} for executing a true condition.\n-\t`U'  Print the upper half of a 64 bit item.  */\n-\n-#define PRINT_OPERAND(STREAM, X, CODE) d30v_print_operand (STREAM, X, CODE)\n-\n-/* A C expression which evaluates to true if CODE is a valid punctuation\n-   character for use in the `PRINT_OPERAND' macro.  If\n-   `PRINT_OPERAND_PUNCT_VALID_P' is not defined, it means that no punctuation\n-   characters (except for the standard one, `%') are used in this way.  */\n-\n-#define PRINT_OPERAND_PUNCT_VALID_P(CODE) ((CODE) == '.' || (CODE) == ':')\n-\n-/* A C compound statement to output to stdio stream STREAM the assembler syntax\n-   for an instruction operand that is a memory reference whose address is X.  X\n-   is an RTL expression.  */\n-\n-#define PRINT_OPERAND_ADDRESS(STREAM, X) d30v_print_operand_address (STREAM, X)\n-\n-/* If defined, C string expressions to be used for the `%R', `%L', `%U', and\n-   `%I' options of `asm_fprintf' (see `final.c').  These are useful when a\n-   single `md' file must support multiple assembler formats.  In that case, the\n-   various `tm.h' files can define these macros differently.\n-\n-   USER_LABEL_PREFIX is defined in svr4.h.  */\n-\n-#define REGISTER_PREFIX \"%\"\n-#define LOCAL_LABEL_PREFIX \".\"\n-#define USER_LABEL_PREFIX \"\"\n-#define IMMEDIATE_PREFIX \"\"\n-\n-\f\n-/* Output of dispatch tables.  */\n-\n-/* This macro should be provided on machines where the addresses in a dispatch\n-   table are relative to the table's own address.\n-\n-   The definition should be a C statement to output to the stdio stream STREAM\n-   an assembler pseudo-instruction to generate a difference between two labels.\n-   VALUE and REL are the numbers of two internal labels.  The definitions of\n-   these labels are output using `(*targetm.asm_out.internal_label)', and they must be\n-   printed in the same way here.  For example,\n-\n-        fprintf (STREAM, \"\\t.word L%d-L%d\\n\", VALUE, REL)  */\n-\n-#define ASM_OUTPUT_ADDR_DIFF_ELT(STREAM, BODY, VALUE, REL) \\\n-fprintf (STREAM, \"\\t.word .L%d-.L%d\\n\", VALUE, REL)\n-\n-/* This macro should be provided on machines where the addresses in a dispatch\n-   table are absolute.\n-\n-   The definition should be a C statement to output to the stdio stream STREAM\n-   an assembler pseudo-instruction to generate a reference to a label.  VALUE\n-   is the number of an internal label whose definition is output using\n-   `(*targetm.asm_out.internal_label)'.  For example,\n-\n-        fprintf (STREAM, \"\\t.word L%d\\n\", VALUE)  */\n-\n-#define ASM_OUTPUT_ADDR_VEC_ELT(STREAM, VALUE) \\\n-fprintf (STREAM, \"\\t.word .L%d\\n\", VALUE)\n-\n-\f\n-/* Assembler Commands for Alignment.  */\n-\n-/* A C statement to output to the stdio stream STREAM an assembler command to\n-   advance the location counter to a multiple of 2 to the POWER bytes.  POWER\n-   will be a C expression of type `int'.  */\n-#define ASM_OUTPUT_ALIGN(STREAM, POWER) \\\n-  fprintf ((STREAM), \"\\t.p2align %d\\n\", (POWER))\n-\n-\f\n-/* Macros Affecting all Debug Formats.  */\n-\n-/* A C expression that returns the DBX register number for the compiler\n-   register number REGNO.  In simple cases, the value of this expression may be\n-   REGNO itself.  But sometimes there are some registers that the compiler\n-   knows about and DBX does not, or vice versa.  In such cases, some register\n-   may need to have one number in the compiler and another for DBX.\n-\n-   If two registers have consecutive numbers inside GCC, and they can be\n-   used as a pair to hold a multiword value, then they *must* have consecutive\n-   numbers after renumbering with `DBX_REGISTER_NUMBER'.  Otherwise, debuggers\n-   will be unable to access such a pair, because they expect register pairs to\n-   be consecutive in their own numbering scheme.\n-\n-   If you find yourself defining `DBX_REGISTER_NUMBER' in way that does not\n-   preserve register pairs, then what you must do instead is redefine the\n-   actual register numbering scheme.  */\n-#define DBX_REGISTER_NUMBER(REGNO)\t\t\t\t\t\\\n-(GPR_P (REGNO)\t\t\t ? ((REGNO) - GPR_FIRST)\t\t\\\n- : ACCUM_P (REGNO)\t\t ? ((REGNO) - ACCUM_FIRST + 84)\t\t\\\n- : FLAG_P (REGNO)\t\t ? 66 /* return psw for all flags */\t\\\n- : (REGNO) == ARG_POINTER_REGNUM ? (GPR_SP - GPR_FIRST)\t\t\t\\\n- : (REGNO) == CR_PSW\t\t ? (66 + 0)\t\t\t\t\\\n- : (REGNO) == CR_BPSW\t\t ? (66 + 1)\t\t\t\t\\\n- : (REGNO) == CR_PC\t\t ? (66 + 2)\t\t\t\t\\\n- : (REGNO) == CR_BPC\t\t ? (66 + 3)\t\t\t\t\\\n- : (REGNO) == CR_DPSW\t\t ? (66 + 4)\t\t\t\t\\\n- : (REGNO) == CR_DPC\t\t ? (66 + 5)\t\t\t\t\\\n- : (REGNO) == CR_RPT_C\t\t ? (66 + 7)\t\t\t\t\\\n- : (REGNO) == CR_RPT_S\t\t ? (66 + 8)\t\t\t\t\\\n- : (REGNO) == CR_RPT_E\t\t ? (66 + 9)\t\t\t\t\\\n- : (REGNO) == CR_MOD_S\t\t ? (66 + 10)\t\t\t\t\\\n- : (REGNO) == CR_MOD_E\t\t ? (66 + 11)\t\t\t\t\\\n- : (REGNO) == CR_IBA\t\t ? (66 + 14)\t\t\t\t\\\n- : (REGNO) == CR_EIT_VB\t\t ? (66 + 15)\t\t\t\t\\\n- : (REGNO) == CR_INT_S\t\t ? (66 + 16)\t\t\t\t\\\n- : (REGNO) == CR_INT_M\t\t ? (66 + 17)\t\t\t\t\\\n- :\t\t\t\t   -1)\n-\n-/* A C expression that returns the type of debugging output GCC produces\n-   when the user specifies `-g' or `-ggdb'.  Define this if you have arranged\n-   for GCC to support more than one format of debugging output.  Currently,\n-   the allowable values are `DBX_DEBUG', `SDB_DEBUG', `DWARF_DEBUG',\n-   `DWARF2_DEBUG', and `XCOFF_DEBUG'.\n-\n-   The value of this macro only affects the default debugging output; the user\n-   can always get a specific type of output by using `-gstabs', `-gcoff',\n-   `-gdwarf-1', `-gdwarf-2', or `-gxcoff'.\n-\n-   Defined in svr4.h.  */\n-\n-#undef\tPREFERRED_DEBUGGING_TYPE\n-#define\tPREFERRED_DEBUGGING_TYPE DBX_DEBUG\n-\n-\f\n-/* Miscellaneous Parameters.  */\n-\n-/* Define this if you have defined special-purpose predicates in the file\n-   `MACHINE.c'.  This macro is called within an initializer of an array of\n-   structures.  The first field in the structure is the name of a predicate and\n-   the second field is an array of rtl codes.  For each predicate, list all rtl\n-   codes that can be in expressions matched by the predicate.  The list should\n-   have a trailing comma.  Here is an example of two entries in the list for a\n-   typical RISC machine:\n-\n-        #define PREDICATE_CODES \\\n-          {\"gen_reg_rtx_operand\", {SUBREG, REG}},  \\\n-          {\"reg_or_short_cint_operand\", {SUBREG, REG, CONST_INT}},\n-\n-   Defining this macro does not affect the generated code (however, incorrect\n-   definitions that omit an rtl code that may be matched by the predicate can\n-   cause the compiler to malfunction).  Instead, it allows the table built by\n-   `genrecog' to be more compact and efficient, thus speeding up the compiler.\n-   The most important predicates to include in the list specified by this macro\n-   are thoses used in the most insn patterns.  */\n-\n-#define PREDICATE_CODES\t\t\t\t\t\t\t\\\n-  { \"short_memory_operand\",\t\t{ MEM }},\t\t\t\\\n-  { \"long_memory_operand\",\t\t{ MEM }},\t\t\t\\\n-  { \"d30v_memory_operand\",\t\t{ MEM }},\t\t\t\\\n-  { \"single_reg_memory_operand\",\t{ MEM }},\t\t\t\\\n-  { \"const_addr_memory_operand\",\t{ MEM }},\t\t\t\\\n-  { \"call_operand\",\t\t\t{ MEM }},\t\t\t\\\n-  { \"gpr_operand\",\t\t\t{ REG, SUBREG }},\t\t\\\n-  { \"accum_operand\",\t\t\t{ REG, SUBREG }},\t\t\\\n-  { \"gpr_or_accum_operand\",\t\t{ REG, SUBREG }},\t\t\\\n-  { \"cr_operand\",\t\t\t{ REG, SUBREG }},\t\t\\\n-  { \"repeat_operand\",\t\t\t{ REG, SUBREG }},\t\t\\\n-  { \"flag_operand\",\t\t\t{ REG, SUBREG }},\t\t\\\n-  { \"br_flag_operand\",\t\t\t{ REG, SUBREG }},\t\t\\\n-  { \"br_flag_or_constant_operand\",\t{ REG, SUBREG, CONST_INT }},\t\\\n-  { \"gpr_or_br_flag_operand\",\t\t{ REG, SUBREG }},\t\t\\\n-  { \"f0_operand\",\t\t\t{ REG, SUBREG }},\t\t\\\n-  { \"f1_operand\",\t\t\t{ REG, SUBREG }},\t\t\\\n-  { \"carry_operand\",\t\t\t{ REG, SUBREG }},\t\t\\\n-  { \"reg_or_0_operand\",\t\t\t{ REG, SUBREG, CONST_INT,\t\\\n-\t\t\t\t\t  CONST_DOUBLE }},\t\t\\\n-  { \"gpr_or_signed6_operand\",\t\t{ REG, SUBREG, CONST_INT }},\t\\\n-  { \"gpr_or_unsigned5_operand\",\t\t{ REG, SUBREG, CONST_INT }},\t\\\n-  { \"gpr_or_unsigned6_operand\",\t\t{ REG, SUBREG, CONST_INT }},\t\\\n-  { \"gpr_or_constant_operand\",\t\t{ REG, SUBREG, CONST_INT,\t\\\n-\t\t\t\t\t  CONST, SYMBOL_REF,\t\t\\\n-\t\t\t\t\t  LABEL_REF }},\t\t\t\\\n-  { \"gpr_or_dbl_const_operand\",\t\t{ REG, SUBREG, CONST_INT,\t\\\n-\t\t\t\t\t  CONST, SYMBOL_REF,\t\t\\\n-\t\t\t\t\t  LABEL_REF, CONST_DOUBLE }},\t\\\n-  { \"gpr_or_memory_operand\",\t\t{ REG, SUBREG, MEM }},\t\t\\\n-  { \"move_input_operand\",\t\t{ REG, SUBREG, MEM, CONST_INT,\t\\\n-\t\t\t\t\t  CONST, SYMBOL_REF,\t\t\\\n-\t\t\t\t\t  LABEL_REF, CONST_DOUBLE }},\t\\\n-  { \"move_output_operand\",\t\t{ REG, SUBREG, MEM }},\t\t\\\n-  { \"signed6_operand\",\t\t\t{ CONST_INT }},\t\t\t\\\n-  { \"unsigned5_operand\",\t\t{ CONST_INT }},\t\t\t\\\n-  { \"unsigned6_operand\",\t\t{ CONST_INT }},\t\t\t\\\n-  { \"bitset_operand\",\t\t\t{ CONST_INT }},\t\t\t\\\n-  { \"condexec_test_operator\",\t\t{ EQ, NE }},\t\t\t\\\n-  { \"condexec_branch_operator\",\t\t{ EQ, NE }},\t\t\t\\\n-  { \"condexec_unary_operator\",\t\t{ ABS, NEG, NOT, ZERO_EXTEND }}, \\\n-  { \"condexec_addsub_operator\",\t\t{ PLUS, MINUS }},\t\t\\\n-  { \"condexec_binary_operator\",\t\t{ MULT, AND, IOR, XOR,\t\t\\\n-\t\t\t\t\t  ASHIFT, ASHIFTRT, LSHIFTRT,\t\\\n-\t\t\t\t\t  ROTATE, ROTATERT }},\t\t\\\n-  { \"condexec_shiftl_operator\",\t\t{ ASHIFT, ROTATE }},\t\t\\\n-  { \"condexec_extend_operator\",\t\t{ SIGN_EXTEND, ZERO_EXTEND }},\t\\\n-  { \"branch_zero_operator\",\t\t{ EQ, NE }},\t\t\t\\\n-  { \"cond_move_dest_operand\",\t\t{ REG, SUBREG, MEM }},\t\t\\\n-  { \"cond_move_operand\",\t\t{ REG, SUBREG, CONST_INT,\t\\\n-\t\t\t\t\t  CONST, SYMBOL_REF,\t\t\\\n-\t\t\t\t\t  LABEL_REF, MEM }},\t\t\\\n-  { \"cond_exec_operand\",\t\t{ REG, SUBREG, CONST_INT,\t\\\n-\t\t\t\t\t  CONST, SYMBOL_REF,\t\t\\\n-\t\t\t\t\t  LABEL_REF, MEM }},\t\t\\\n-  { \"srelational_si_operator\",\t\t{ EQ, NE, LT, LE, GT, GE }},\t\\\n-  { \"urelational_si_operator\",\t\t{ LTU, LEU, GTU, GEU }},\t\\\n-  { \"relational_di_operator\",\t\t{ EQ, NE, LT, LE, GT, GE,\t\\\n-\t\t\t\t\t  LTU, LEU, GTU, GEU }},\n-\n-/* An alias for a machine mode name.  This is the machine mode that elements of\n-   a jump-table should have.  */\n-#define CASE_VECTOR_MODE SImode\n-\n-/* Define this macro if operations between registers with integral mode smaller\n-   than a word are always performed on the entire register.  Most RISC machines\n-   have this property and most CISC machines do not.  */\n-#define WORD_REGISTER_OPERATIONS 1\n-\n-/* Define this macro to be a C expression indicating when insns that read\n-   memory in MODE, an integral mode narrower than a word, set the bits outside\n-   of MODE to be either the sign-extension or the zero-extension of the data\n-   read.  Return `SIGN_EXTEND' for values of MODE for which the insn\n-   sign-extends, `ZERO_EXTEND' for which it zero-extends, and `NIL' for other\n-   modes.\n-\n-   This macro is not called with MODE non-integral or with a width greater than\n-   or equal to `BITS_PER_WORD', so you may return any value in this case.  Do\n-   not define this macro if it would always return `NIL'.  On machines where\n-   this macro is defined, you will normally define it as the constant\n-   `SIGN_EXTEND' or `ZERO_EXTEND'.  */\n-\n-#define LOAD_EXTEND_OP(MODE) SIGN_EXTEND\n-\n-/* Define if loading short immediate values into registers sign extends.  */\n-#define SHORT_IMMEDIATES_SIGN_EXTEND\n-\n-/* The maximum number of bytes that a single instruction can move quickly from\n-   memory to memory.  */\n-#define MOVE_MAX 8\n-\n-/* A C expression which is nonzero if on this machine it is safe to \"convert\"\n-   an integer of INPREC bits to one of OUTPREC bits (where OUTPREC is smaller\n-   than INPREC) by merely operating on it as if it had only OUTPREC bits.\n-\n-   On many machines, this expression can be 1.\n-\n-   When `TRULY_NOOP_TRUNCATION' returns 1 for a pair of sizes for modes for\n-   which `MODES_TIEABLE_P' is 0, suboptimal code can result.  If this is the\n-   case, making `TRULY_NOOP_TRUNCATION' return 0 in such cases may improve\n-   things.  */\n-#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n-\n-/* An alias for the machine mode for pointers.  On most machines, define this\n-   to be the integer mode corresponding to the width of a hardware pointer;\n-   `SImode' on 32-bit machine or `DImode' on 64-bit machines.  On some machines\n-   you must define this to be one of the partial integer modes, such as\n-   `PSImode'.\n-\n-   The width of `Pmode' must be at least as large as the value of\n-   `POINTER_SIZE'.  If it is not equal, you must define the macro\n-   `POINTERS_EXTEND_UNSIGNED' to specify how pointers are extended to `Pmode'.  */\n-#define Pmode SImode\n-\n-/* An alias for the machine mode used for memory references to functions being\n-   called, in `call' RTL expressions.  On most machines this should be\n-   `QImode'.  */\n-#define FUNCTION_MODE QImode\n-\n-/* Define this macro to handle System V style pragmas (particularly #pack).\n-\n-   Defined in svr4.h.  */\n-#define HANDLE_SYSV_PRAGMA 1\n-\n-/* A C expression for the maximum number of instructions to execute via\n-   conditional execution instructions instead of a branch.  A value of\n-   BRANCH_COST+1 is the default if the machine does not use cc0, and 1 if it\n-   does use cc0. */\n-#define MAX_CONDITIONAL_EXECUTE d30v_cond_exec\n-\n-#define D30V_DEFAULT_MAX_CONDITIONAL_EXECUTE 4\n-\n-/* Values of the -mcond-exec=n string.  */\n-extern int d30v_cond_exec;\n-extern const char *d30v_cond_exec_string;\n-\n-#endif /* GCC_D30V_H */"}, {"sha": "7846074261d039b6975b3d1fbd0cbb76984ff11a", "filename": "gcc/config/d30v/d30v.md", "status": "removed", "additions": 0, "deletions": 3361, "changes": 3361, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fd30v%2Fd30v.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fd30v%2Fd30v.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fd30v%2Fd30v.md?ref=c3bf16ff7dec47581f450b1a486cfdf9d566927e"}, {"sha": "ed359fc552ec8d0fa1deb99f24db8bd00d5d540a", "filename": "gcc/config/d30v/libgcc1.asm", "status": "removed", "additions": 0, "deletions": 187, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fd30v%2Flibgcc1.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fd30v%2Flibgcc1.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fd30v%2Flibgcc1.asm?ref=c3bf16ff7dec47581f450b1a486cfdf9d566927e", "patch": "@@ -1,187 +0,0 @@\n-/* Assembly support functions for libgcc.\n- *\n- *   Copyright (C) 1997 Free Software Foundation, Inc.\n- *   Contributed by Cygnus Support\n- * \n- * This file is free software; you can redistribute it and/or modify it\n- * under the terms of the GNU General Public License as published by the\n- * Free Software Foundation; either version 2, or (at your option) any\n- * later version.\n- * \n- * In addition to the permissions in the GNU General Public License, the\n- * Free Software Foundation gives you unlimited permission to link the\n- * compiled version of this file into combinations with other programs,\n- * and to distribute those combinations without any restriction coming\n- * from the use of this file.  (The General Public License restrictions\n- * do apply in other respects; for example, they cover modification of\n- * the file, and distribution when not linked into a combine\n- * executable.)\n- * \n- * This file is distributed in the hope that it will be useful, but\n- * WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n- * General Public License for more details.\n- * \n- * You should have received a copy of the GNU General Public License\n- * along with this program; see the file COPYING.  If not, write to\n- * the Free Software Foundation, 59 Temple Place - Suite 330,\n- * Boston, MA 02111-1307, USA.\n- * \n- */\n-\n-\f\n-#ifdef L_udivsi3\n-\n-/* For division, we use the following algorithm:\n- *\n- *\tunsigned\n- *\t__divsi3 (unsigned a, unsigned b)\n- *\t{\n- *\t  unsigned al = a;\n- *\t  unsigned ah = 0;\n- *\t  unsigned tmpf;\n- *\t  int i;\n- *\n- *\t  for (i = 32; i > 0; i--)\n- *\t    {\n- *\t      ah = (ah << 1) | (al >> 31);\n- *\t      tmpf = (ah >= b) ? 1 : 0;\n- *\t      ah -= ((tmpf) ? b : 0);\n- *\t      al = (al << 1) | tmpf;\n- *\t    }\n- *\n- *\t  return al;\t// for __udivsi3\n- *\t  return ah;\t// for __umodsi3\n- *\t}\n- */\n-\n-\t.file\t\"_udivsi3\"\n-\t.text\n-\t.globl\t__umodsi3\n-\t.globl\t__udivsi3\n-\t.type\t__umodsi3,@function\n-\t.type\t__udivsi3,@function\n-\t.stabs\t\"libgcc1.asm\",100,0,0,__umodsi3\n-\t.stabs\t\"int:t(0,1)=r(0,1);-2147483648;2147483647;\",128,0,0,0\n-\t.stabs\t\"__umodsi3:F(0,1)\",36,0,1,__umodsi3\n-\t.stabs\t\"a:P(0,1)\",64,0,1,2\n-\t.stabs\t\"b:P(0,1)\",64,0,1,3\n-\n-__umodsi3:\n-\tbra.s .Lmerge\t\t|| orfg\tf1,f1,1\t\t; indicate this is __umodsi3\n-.Lumod:\n-\t.size\t__umodsi3,.Lumod-__umodsi3\n-\t.stabs\t\"\",36,0,0,.Lumod-__umodsi3\n-\n-\t.stabs\t\"__udivsi3:F(0,1)\",36,0,1,__udivsi3\n-\t.stabs\t\"a:P(0,1)\",64,0,1,2\n-\t.stabs\t\"b:P(0,1)\",64,0,1,3\n-__udivsi3:\n-\tandfg\tf1,f1,0\t\t|| nop\t\t\t; indicate this is __udivsi3\n-\n-.Lmerge:\n-\t; r2 = al\n-\t; r3 = b\n-\t; r4 = ah\n-\t; r5 = loop counter\n-\t; f0 = tmpf\n-\t; f1 = 1 if this is mod, 0 if this is div\n-\tor\t r4,r0,0\t|| sub\t r5,r0,-32\t; ah = 0, loop = 32\n-\n-.Lloop:\n-\tsrc\t r4,r2,-1\t|| sub\t r5,r5,1\t; ah = (ah << 1) | (al >> 31); decrement loop count\n-\tcmpuge\t f0,r4,r3\t|| sra\t r2,r2,-1\t; f0 = (ah >= b); al <<= 1\n-\tsub/tx\t r4,r4,r3\t|| or/tx r2,r2,1\t; ah -= (tmpf) ? b : 0; al |= tmpf\n-\tbratnz.s r5,.Lloop\t|| nop\t\t\t; loop back if not done\n-\tjmp\t link           || or/xt r2,r0,r4\t; if mod, update register, then return to user\n-.Ludiv:\n-\t.size\t __udivsi3,.Ludiv-__udivsi3\n-\t.stabs\t\"\",36,0,0,.Ludiv-__udivsi3\n-\n-#endif /* L_udivsi3 */\n-\n-\f\n-#ifdef L_divsi3\n-\n-/* For division, we use the following algorithm:\n- *\n- *\tunsigned\n- *\t__divsi3 (unsigned a, unsigned b)\n- *\t{\n- *\t  unsigned al = __builtin_abs (a);\n- *\t  unsigned b2 = __builtin_abs (b);\n- *\t  unsigned ah = 0;\n- *\t  unsigned tmpf;\n- *\t  int i;\n- *\n- *\t  for (i = 32; i > 0; i--)\n- *\t    {\n- *\t      ah = (ah << 1) | (al >> 31);\n- *\t      tmpf = (ah >= b2) ? 1 : 0;\n- *\t      ah -= ((tmpf) ? b2 : 0);\n- *\t      al = (al << 1) | tmpf;\n- *\t    }\n- *\n- *\t  if (a < 0)\n- *\t    ah = -ah, al = -al;\n- *\n- *\t  if (b < 0)\n- *\t    al = -al;\n- *\n- *\t  return al;\t// for __divsi3\n- *\t  return ah;\t// for __modsi3\n- *\t}\n- */\n-\n-\t.file\t\"_divsi3\"\n-\t.text\n-\t.globl\t__modsi3\n-\t.globl\t__divsi3\n-\t.type\t__modsi3,@function\n-\t.type\t__divsi3,@function\n-\t.stabs\t\"libgcc1.asm\",100,0,0,__modsi3\n-\t.stabs\t\"int:t(0,1)=r(0,1);-2147483648;2147483647;\",128,0,0,0\n-\t.stabs\t\"__modsi3:F(0,1)\",36,0,1,__modsi3\n-\t.stabs\t\"a:P(0,1)\",64,0,1,2\n-\t.stabs\t\"b:P(0,1)\",64,0,1,3\n-\n-__modsi3:\n-\tbra.s .Lmerge\t\t|| orfg\tf1,f1,1\t\t; indicate this is __modsi3\n-.Lmod:\n-\t.size\t__modsi3,.Lmod-__modsi3\n-\t.stabs\t\"\",36,0,0,.Lmod-__modsi3\n-\n-\t.stabs\t\"__divsi3:F(0,1)\",36,0,1,__divsi3\n-\t.stabs\t\"a:P(0,1)\",64,0,1,2\n-\t.stabs\t\"b:P(0,1)\",64,0,1,3\n-__divsi3:\n-\tandfg\tf1,f1,0\t\t|| nop\t\t\t; indicate this is __divsi3\n-\n-.Lmerge:\n-\t; r2 = al\n-\t; r3 = b2\n-\t; r4 = ah\n-\t; r5 = loop counter\n-\t; r6 = a\n-\t; r7 = b\n-\t; f0 = tmpf\n-\t; f1 = 1 if this is mod, 0 if this is div\n-\tor\t r6,r0,r2\t|| or\t  r7,r0,r3\t; copy original inputs\n-\tabs\t r2,r2\t\t|| abs\t  r3,r3\t\t; make both postive\n-\tor\t r4,r0,0\t|| sub\t r5,r0,-32\t; ah = 0, loop = 32\n-\n-.Lloop:\n-\tsrc\t r4,r2,-1\t|| sub\t  r5,r5,1\t; ah = (ah << 1) | (al >> 31); decrement loop count\n-\tcmpuge\t f0,r4,r3\t|| sra\t  r2,r2,-1\t; f0 = (ah >= b); al <<= 1\n-\tsub/tx\t r4,r4,r3\t|| or/tx  r2,r2,1\t; ah -= (tmpf) ? b : 0; al |= tmpf\n-\tbratnz.s r5,.Lloop\t|| nop\t\t\t; loop back if not done\n-\tcmplt    f0,r6,0\t|| nop\t\t\t; f0 = (a < 0)\n-\n-\tsub/tx\t r2,r0,r2\t|| sub/tx r4,r0,r4\t; negate both al, ah if (a < 0)\n-\tcmplt\t f0,r7,0\t-> sub/tx r2,r0,r2\t; negate al if (b < 0)\n-\tjmp\t link\t\t|| or/xt  r2,r0,r4\t; update result if mod; return to user\n-.Ldiv:\n-\t.size\t __divsi3,.Ldiv-__divsi3\n-\t.stabs\t\"\",36,0,0,.Ldiv-__divsi3\n-\n-#endif /* L_divsi3 */"}, {"sha": "2544f3db35e4932889d70bb95794768871a5d579", "filename": "gcc/config/d30v/t-d30v", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fd30v%2Ft-d30v", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fd30v%2Ft-d30v", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fd30v%2Ft-d30v?ref=c3bf16ff7dec47581f450b1a486cfdf9d566927e", "patch": "@@ -1,32 +0,0 @@\n-LIB1ASMSRC = d30v/libgcc1.asm\n-LIB1ASMFUNCS = _udivsi3 _divsi3\n-\n-# Turn on full debug for libgcc.a.\n-LIBGCC2_DEBUG_CFLAGS = -g\n-\n-# We want fine grained libraries, so use the new code to build the\n-# floating point emulation libraries.\n-FPBIT = fp-bit.c\n-DPBIT = dp-bit.c\n-\n-dp-bit.c: $(srcdir)/config/fp-bit.c config.status\n-\tcat $(srcdir)/config/fp-bit.c > dp-bit.c\n-\n-fp-bit.c: $(srcdir)/config/fp-bit.c config.status\n-\techo '#define FLOAT' > fp-bit.c\n-\techo '#define _fpadd_parts _fpadd_parts_sf' >> fp-bit.c\n-\tcat $(srcdir)/config/fp-bit.c >> fp-bit.c\n-\n-# For svr4 we build crtbegin.o and crtend.o which serve to add begin and\n-# end labels to the .ctors and .dtors section when we link using gcc.\n-\n-EXTRA_PARTS=crtbegin.o crtend.o\n-\n-# We need to use -fPIC when we are using gcc to compile the routines in\n-# crtstuff.c.  This is only really needed when we are going to use gcc/g++\n-# to produce a shared library, but since we don't know ahead of time when\n-# we will be doing that, we just always use -fPIC when compiling the\n-# routines in crtstuff.c.\n-\n-# Right now, disable, since we don't support shared libraries on d30v yet.\n-#CRTSTUFF_T_CFLAGS = -fPIC"}, {"sha": "968e271ff44ad6bb0d11a31c7afd7a5405ce4cf6", "filename": "gcc/config/dsp16xx/dsp16xx-modes.def", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx-modes.def?ref=c3bf16ff7dec47581f450b1a486cfdf9d566927e", "patch": "@@ -1,23 +0,0 @@\n-/* DSP16xx extra modes.\n-   Copyright (C) 2003 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-/* HFmode is the DSP16xx's equivalent of SFmode.\n-   FIXME: What format is this anyway? */ \n-FLOAT_MODE (HF, 2, 0);"}, {"sha": "802c69b62ec8e50d5a0349eeff040a719608c302", "filename": "gcc/config/dsp16xx/dsp16xx-protos.h", "status": "removed", "additions": 0, "deletions": 86, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx-protos.h?ref=c3bf16ff7dec47581f450b1a486cfdf9d566927e", "patch": "@@ -1,86 +0,0 @@\n-/* Definitions of target machine for GNU compiler.  AT&T DSP1600.\n-   Copyright (C) 2000 Free Software Foundation, Inc.\n-   Contributed by Michael Collison (collison@world.std.com).\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#ifdef RTX_CODE\n-extern struct rtx_def *gen_compare_reg (enum rtx_code, rtx, rtx);\n-extern int call_address_operand (rtx, enum machine_mode);\n-extern int arith_reg_operand (rtx, enum machine_mode);\n-extern int symbolic_address_operand (rtx, enum machine_mode);\n-extern int Y_address_operand (rtx, enum machine_mode);\n-extern int sp_operand (rtx, enum machine_mode);\n-extern int sp_operand2 (rtx, enum machine_mode);\n-extern int nonmemory_arith_operand (rtx, enum machine_mode);\n-extern int dsp16xx_comparison_operator (rtx, enum machine_mode);\n-extern int unx_comparison_operator (rtx, enum machine_mode);\n-extern int signed_comparison_operator (rtx, enum machine_mode);\n-\n-extern void notice_update_cc (rtx);\n-extern void double_reg_from_memory (rtx[]);\n-extern void double_reg_to_memory (rtx[]);\n-extern enum rtx_code next_cc_user_code (rtx);\n-extern int next_cc_user_unsigned (rtx);\n-extern struct rtx_def *gen_tst_reg (rtx);\n-extern const char *output_block_move (rtx[]);\n-extern enum reg_class preferred_reload_class (rtx, enum reg_class);\n-extern enum reg_class secondary_reload_class (enum reg_class,\n-\t\t\t\t\t      enum machine_mode, rtx);\n-extern int emit_move_sequence (rtx *, enum machine_mode);\n-extern void print_operand (FILE *, rtx, int);\n-extern void print_operand_address (FILE *, rtx);\n-extern void output_dsp16xx_float_const (rtx *);\n-extern void emit_1600_core_shift (enum rtx_code, rtx *, int);\n-extern int symbolic_address_p (rtx);\n-extern int uns_comparison_operator (rtx, enum machine_mode);\n-#endif /* RTX_CODE */\n-\n-\n-#ifdef TREE_CODE\n-extern struct rtx_def *dsp16xx_function_arg (CUMULATIVE_ARGS,\n-\t\t\t\t\t     enum machine_mode,\n-\t\t\t\t\t     tree, int);\n-extern void dsp16xx_function_arg_advance (CUMULATIVE_ARGS *,\n-\t\t\t\t\t  enum machine_mode,\n-\t\t\t\t\t  tree, int);\n-#endif /* TREE_CODE */\n-\n-extern void dsp16xx_invalid_register_for_compare (void);\n-extern int class_max_nregs (enum reg_class, enum machine_mode);\n-extern enum reg_class limit_reload_class (enum reg_class, enum machine_mode);\n-extern int dsp16xx_register_move_cost (enum reg_class, enum reg_class);\n-extern int dsp16xx_makes_calls (void);\n-extern long compute_frame_size (int);\n-extern int dsp16xx_call_saved_register (int);\n-extern int dsp16xx_call_saved_register (int);\n-extern void init_emulation_routines (void);\n-extern int ybase_regs_ever_used (void);\n-extern void override_options (void);\n-extern int dsp16xx_starting_frame_offset (void);\n-extern int initial_frame_pointer_offset (void);\n-extern void asm_output_common (FILE *, const char *, int, int);\n-extern void asm_output_local (FILE *, const char *, int, int);\n-extern void asm_output_float (FILE *, double);\n-extern bool dsp16xx_compare_gen;\n-extern int hard_regno_mode_ok (int, enum machine_mode);\n-extern enum reg_class dsp16xx_reg_class_from_letter (int);\n-extern int regno_reg_class (int);\n-extern void function_prologue (FILE *, int);\n-extern void function_epilogue (FILE *, int);\n-extern int num_1600_core_shifts (int);"}, {"sha": "14d9c5e088e21515d56ee000fcf17e1d2407c8ee", "filename": "gcc/config/dsp16xx/dsp16xx.c", "status": "removed", "additions": 0, "deletions": 2632, "changes": 2632, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.c?ref=c3bf16ff7dec47581f450b1a486cfdf9d566927e", "patch": "@@ -1,2632 +0,0 @@\n-/* Subroutines for assembler code output on the DSP1610.\n-   Copyright (C) 1994, 1995, 1997, 1998, 2001 Free Software Foundation, Inc.\n-   Contributed by Michael Collison (collison@isisinc.net).\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-/* Some output-actions in dsp1600.md need these.  */\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"rtl.h\"\n-#include \"regs.h\"\n-#include \"hard-reg-set.h\"\n-#include \"real.h\"\n-#include \"insn-config.h\"\n-#include \"conditions.h\"\n-#include \"output.h\"\n-#include \"insn-attr.h\"\n-#include \"tree.h\"\n-#include \"expr.h\"\n-#include \"function.h\"\n-#include \"flags.h\"\n-#include \"ggc.h\"\n-#include \"toplev.h\"\n-#include \"recog.h\"\n-#include \"tm_p.h\"\n-#include \"target.h\"\n-#include \"target-def.h\"\n-\n-const char *text_seg_name;\n-const char *rsect_text;\n-const char *data_seg_name;\n-const char *rsect_data;\n-const char *bss_seg_name;\n-const char *rsect_bss;\n-const char *const_seg_name;\n-const char *rsect_const;\n-\n-const char *chip_name;\n-const char *save_chip_name;\n-\n-/* Save the operands of a compare. The 16xx has not lt or gt, so\n-   in these cases we swap the operands and reverse the condition.  */\n-\n-rtx dsp16xx_compare_op0;\n-rtx dsp16xx_compare_op1;\n-bool dsp16xx_compare_gen;\n-\n-static const char *fp;\n-static const char *sp;\n-static const char *rr;\n-static const char *a1h;\n-\n-struct dsp16xx_frame_info current_frame_info;\n-struct dsp16xx_frame_info zero_frame_info;\n-\n-rtx dsp16xx_addhf3_libcall = (rtx) 0;\n-rtx dsp16xx_subhf3_libcall = (rtx) 0;\n-rtx dsp16xx_mulhf3_libcall = (rtx) 0;\n-rtx dsp16xx_divhf3_libcall = (rtx) 0;\n-rtx dsp16xx_cmphf3_libcall = (rtx) 0;\n-rtx dsp16xx_fixhfhi2_libcall = (rtx) 0;\n-rtx dsp16xx_floathihf2_libcall = (rtx) 0;\n-rtx dsp16xx_neghf2_libcall = (rtx) 0;\n-\n-rtx dsp16xx_mulhi3_libcall = (rtx) 0;\n-rtx dsp16xx_udivqi3_libcall = (rtx) 0;\n-rtx dsp16xx_udivhi3_libcall = (rtx) 0;\n-rtx dsp16xx_divqi3_libcall = (rtx) 0;\n-rtx dsp16xx_divhi3_libcall = (rtx) 0;\n-rtx dsp16xx_modqi3_libcall = (rtx) 0;\n-rtx dsp16xx_modhi3_libcall = (rtx) 0;\n-rtx dsp16xx_umodqi3_libcall = (rtx) 0;\n-rtx dsp16xx_umodhi3_libcall = (rtx) 0;\n-rtx dsp16xx_ashrhi3_libcall = (rtx) 0;\n-rtx dsp16xx_ashlhi3_libcall = (rtx) 0;\n-rtx dsp16xx_ucmphi2_libcall = (rtx) 0;\n-rtx dsp16xx_lshrhi3_libcall = (rtx) 0;\n-\n-static const char *const himode_reg_name[] = HIMODE_REGISTER_NAMES;\n-\n-#define SHIFT_INDEX_1   0\n-#define SHIFT_INDEX_4   1\n-#define SHIFT_INDEX_8   2\n-#define SHIFT_INDEX_16  3\n-\n-static const char *const ashift_right_asm[] = \n-{\n-  \"%0=%0>>1\",\n-  \"%0=%0>>4\",\n-  \"%0=%0>>8\",\n-  \"%0=%0>>16\"\n-};\n-\n-static const char *const ashift_right_asm_first[] = \n-{\n-  \"%0=%1>>1\",\n-  \"%0=%1>>4\",\n-  \"%0=%1>>8\",\n-  \"%0=%1>>16\"\n-};\n-\n-static const char *const ashift_left_asm[] = \n-{\n-  \"%0=%0<<1\",\n-  \"%0=%0<<4\",\n-  \"%0=%0<<8\",\n-  \"%0=%0<<16\"\n-};\n-\n-static const char *const ashift_left_asm_first[] = \n-{\n-  \"%0=%1<<1\",\n-  \"%0=%1<<4\",\n-  \"%0=%1<<8\",\n-  \"%0=%1<<16\"\n-};\n-\n-static const char *const lshift_right_asm[] = \n-{\n-  \"%0=%0>>1\\n\\t%0=%b0&0x7fff\",\n-  \"%0=%0>>4\\n\\t%0=%b0&0x0fff\",\n-  \"%0=%0>>8\\n\\t%0=%b0&0x00ff\",\n-  \"%0=%0>>16\\n\\t%0=%b0&0x0000\"\n-};\n-\n-static const char *const lshift_right_asm_first[] = \n-{\n-  \"%0=%1>>1\\n\\t%0=%b0&0x7fff\",\n-  \"%0=%1>>4\\n\\t%0=%b0&0x0fff\",\n-  \"%0=%1>>8\\n\\t%0=%b0&0x00ff\",\n-  \"%0=%1>>16\\n\\t%0=%b0&0x0000\"\n-};\n-\n-static int reg_save_size (void);\n-static void dsp16xx_output_function_prologue (FILE *, HOST_WIDE_INT);\n-static void dsp16xx_output_function_epilogue (FILE *, HOST_WIDE_INT);\n-static void dsp16xx_file_start (void);\n-static bool dsp16xx_rtx_costs (rtx, int, int, int *);\n-static int dsp16xx_address_cost (rtx);\n-\f\n-/* Initialize the GCC target structure.  */\n-\n-#undef TARGET_ASM_BYTE_OP\n-#define TARGET_ASM_BYTE_OP \"\\tint\\t\"\n-#undef TARGET_ASM_ALIGNED_HI_OP\n-#define TARGET_ASM_ALIGNED_HI_OP NULL\n-#undef TARGET_ASM_ALIGNED_SI_OP\n-#define TARGET_ASM_ALIGNED_SI_OP NULL\n-\n-#undef TARGET_ASM_FUNCTION_PROLOGUE\n-#define TARGET_ASM_FUNCTION_PROLOGUE dsp16xx_output_function_prologue\n-#undef TARGET_ASM_FUNCTION_EPILOGUE\n-#define TARGET_ASM_FUNCTION_EPILOGUE dsp16xx_output_function_epilogue\n-\n-#undef TARGET_ASM_FILE_START\n-#define TARGET_ASM_FILE_START dsp16xx_file_start\n-\n-#undef TARGET_RTX_COSTS\n-#define TARGET_RTX_COSTS dsp16xx_rtx_costs\n-#undef TARGET_ADDRESS_COST\n-#define TARGET_ADDRESS_COST dsp16xx_address_cost\n-\n-struct gcc_target targetm = TARGET_INITIALIZER;\n-\n-int \n-hard_regno_mode_ok (regno, mode)\n-     int regno;\n-     enum machine_mode mode;\n-{\n-  switch ((int) mode)\n-    {\n-    case VOIDmode:\n-      return 1;\n-      \n-      /* We can't use the c0-c2 for QImode, since they are only\n-\t 8 bits in length.  */\n-\n-    case QImode:\n-      if (regno != REG_C0 && regno != REG_C1 && regno != REG_C2)\n-\treturn 1;\n-      else\n-\treturn 0;\n-      \n-      /* We only allow a0, a1, y, and p to be allocated for 32-bit modes.\n-         Additionally we allow the virtual ybase registers to be used for 32-bit\n-\t modes.  */\n-      \n-    case HFmode:\n-    case HImode:\n-#if 0 /* ??? These modes do not appear in the machine description nor\n-         are there library routines for them.  */\n-    case SFmode:\n-    case DFmode:\n-    case XFmode:\n-    case SImode:\n-    case DImode:\n-#endif\n-      if (regno == REG_A0 || regno == REG_A1 || regno == REG_Y || regno == REG_PROD\n-\t  || (IS_YBASE_REGISTER_WINDOW(regno) && ((regno & 1) == 0)))\n-\treturn 1;\n-      else\n-\treturn 0;\n-      \n-    default:\n-      return 0;\n-    }\n-}\n-\n-enum reg_class\n-dsp16xx_reg_class_from_letter (c)\n-     int c;\n-{\n-  switch (c)\n-    {\n-    case 'A':\n-      return ACCUM_REGS;\n-\n-    case 'l':\n-      return A0_REG;\n-\n-    case 'C':\n-      return A1_REG;\n-      \n-    case 'h':\n-      return ACCUM_HIGH_REGS;\n-      \n-    case 'j':\n-      return A0H_REG;\n-      \n-    case 'k':\n-      return A0L_REG;\n-      \n-    case 'q':\n-      return A1H_REG;\n-      \n-    case 'u':\n-      return A1L_REG;\n-      \n-    case 'x':\n-      return X_REG;\n-\n-    case 'y':\n-      return YH_REG;\n-\n-    case 'z':\n-      return YL_REG;\n-\n-    case 't':\n-      return P_REG;\n-\n-    case 'Z':\n-      return Y_OR_P_REGS;\n-\n-    case 'd':\n-      return ACCUM_Y_OR_P_REGS;\n-\n-    case 'a':\n-      return Y_ADDR_REGS;\n-\n-    case 'B':\n-      return (TARGET_BMU ? BMU_REGS : NO_REGS);\n-\n-    case 'Y':\n-      return YBASE_VIRT_REGS;\n-\n-    case 'v':\n-      return PH_REG;\n-\n-    case 'w':\n-      return PL_REG;\n-\n-    case 'W':\n-      return J_REG;\n-\n-    case 'e':\n-      return YBASE_ELIGIBLE_REGS;\n-\n-    case 'b':\n-      return ACCUM_LOW_REGS;\n-\n-    case 'c':\n-      return NON_YBASE_REGS;\n-\n-    case 'f':\n-      return Y_REG;\n-\n-    case 'D':\n-      return SLOW_MEM_LOAD_REGS;\n-\n-    default:\n-      return NO_REGS;\n-    }\n-}\n-\n-/* Return the class number of the smallest class containing\n-   reg number REGNO.  */\n-\n-int \n-regno_reg_class(regno)\n-     int regno;\n-{\n-  switch (regno)\n-    {\n-    case REG_A0L:\n-      return (int) A0L_REG;\n-    case REG_A1L:\n-      return (int) A1L_REG;\n-      \n-    case REG_A0:\n-      return (int) A0H_REG;\n-    case REG_A1:\n-      return (int) A1H_REG;\n-      \n-    case REG_X:\n-      return (int) X_REG;\n-      \n-    case REG_Y:\n-      return (int) YH_REG;\n-    case REG_YL:\n-      return (int) YL_REG;\n-      \n-    case REG_PROD:\n-      return (int) PH_REG;\n-    case REG_PRODL:\n-      return (int) PL_REG;\n-      \n-    case REG_R0: case REG_R1: case REG_R2: case REG_R3:\n-      return (int) Y_ADDR_REGS;\n-      \n-    case REG_J:\n-      return (int) J_REG;\n-    case REG_K:\n-      return (int) GENERAL_REGS;\n-      \n-    case REG_YBASE:\n-      return (int) GENERAL_REGS;\n-      \n-    case REG_PT:\n-      return (int) GENERAL_REGS;\n-      \n-    case REG_AR0: case REG_AR1: case REG_AR2: case REG_AR3:\n-      return (int) BMU_REGS;\n-      \n-    case REG_C0: case REG_C1: case REG_C2:\n-      return (int) GENERAL_REGS;\n-      \n-    case REG_PR:\n-      return (int) GENERAL_REGS;\n-      \n-    case REG_RB:\n-      return (int) GENERAL_REGS;\n-      \n-    case REG_YBASE0: case REG_YBASE1: case REG_YBASE2: case REG_YBASE3:\n-    case REG_YBASE4: case REG_YBASE5: case REG_YBASE6: case REG_YBASE7:\n-    case REG_YBASE8: case REG_YBASE9: case REG_YBASE10: case REG_YBASE11:\n-    case REG_YBASE12: case REG_YBASE13: case REG_YBASE14: case REG_YBASE15:\n-    case REG_YBASE16: case REG_YBASE17: case REG_YBASE18: case REG_YBASE19:\n-    case REG_YBASE20: case REG_YBASE21: case REG_YBASE22: case REG_YBASE23:\n-    case REG_YBASE24: case REG_YBASE25: case REG_YBASE26: case REG_YBASE27:\n-    case REG_YBASE28: case REG_YBASE29: case REG_YBASE30: case REG_YBASE31:\n-      return (int) YBASE_VIRT_REGS;\n-      \n-    default:\n-      return (int) NO_REGS;\n-    }\n-}\n-\n-/* A C expression for the maximum number of consecutive registers of class CLASS\n-   needed to hold a value of mode MODE.  */\n-\n-int\n-class_max_nregs(class, mode)\n-     enum reg_class class ATTRIBUTE_UNUSED;\n-     enum machine_mode mode;\n-{\n-    return (GET_MODE_SIZE(mode));\n-}\n-\n-enum reg_class\n-limit_reload_class (mode, class)\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-     enum reg_class class;\n-{\n-  return class;\n-}\n-\n-int\n-dsp16xx_register_move_cost (from, to)\n-     enum reg_class from, to;\n-{\n-  if (from == A0H_REG || from == A0L_REG || from == A0_REG ||\n-      from == A1H_REG || from == ACCUM_HIGH_REGS || from == A1L_REG ||\n-      from == ACCUM_LOW_REGS || from == A1_REG || from == ACCUM_REGS)\n-    {\n-      if (to == Y_REG || to == P_REG)\n-\treturn 4;\n-      else\n-\treturn 2;\n-    }\n-\n-  if (to == A0H_REG || to == A0L_REG || to == A0_REG ||\n-      to == A1H_REG || to == ACCUM_HIGH_REGS || to == A1L_REG ||\n-      to == ACCUM_LOW_REGS || to == A1_REG || to == ACCUM_REGS)\n-    {\n-      return 2;\n-    }\n-\n-  if (from == YBASE_VIRT_REGS)\n-    {\n-      if (to == YBASE_VIRT_REGS)\n-\treturn 16;\n-\n-      if (to == X_REG || to == YH_REG || to == YL_REG ||\n-\t  to == Y_REG || to == PL_REG || to == PH_REG ||\n-\t  to == P_REG || to == Y_ADDR_REGS || to == YBASE_ELIGIBLE_REGS ||\n-\t  to == Y_OR_P_REGS)\n-\t{\n-\t  return 8;\n-\t}\n-      else\n-\treturn 10;\n-    }\n-\n-  if (to == YBASE_VIRT_REGS)\n-    {\n-      if (from == X_REG || from == YH_REG || from == YL_REG ||\n-\t  from == Y_REG || from == PL_REG || from == PH_REG ||\n-\t  from == P_REG || from == Y_ADDR_REGS || from == YBASE_ELIGIBLE_REGS ||\n-\t  from == Y_OR_P_REGS)\n-\t{\n-\t  return 8;\n-\t}\n-      else\n-\treturn 10;\n-    }\n-\n-  return 8;\n-}\n-\n-/* Given an rtx X being reloaded into a reg required to be\n-   in class CLASS, return the class of reg to actually use.\n-   In general this is just CLASS; but on some machines\n-   in some cases it is preferable to use a more restrictive class.\n-   Also, we must ensure that a PLUS is reloaded either\n-   into an accumulator or an address register.  */\n-\n-enum reg_class\n-preferred_reload_class (x, class)\n-     rtx x;\n-     enum reg_class class;\n-{\n-  /* The ybase registers cannot have constants copied directly\n-     to them.  */\n-\n-  if (CONSTANT_P (x))\n-    {\n-      switch ((int) class)\n-\t{\n-\tcase YBASE_VIRT_REGS:\n-\t  return (!reload_in_progress ? NO_REGS : class);\n-\n-\tcase ACCUM_LOW_OR_YBASE_REGS:\n-\t  return ACCUM_LOW_REGS;\n-\n-\tcase ACCUM_OR_YBASE_REGS:\n-\t  return ACCUM_REGS;\n-\n-\tcase X_OR_YBASE_REGS:\n-\t  return X_REG;\n-\n-\tcase Y_OR_YBASE_REGS:\n-\t  return Y_REG;\n-\n-\tcase ACCUM_LOW_YL_PL_OR_YBASE_REGS:\n-\t  return YL_OR_PL_OR_ACCUM_LOW_REGS;\n-\n-\tcase P_OR_YBASE_REGS:\n-\t  return P_REG;\n-\n-\tcase ACCUM_Y_P_OR_YBASE_REGS:\n-\t  return ACCUM_Y_OR_P_REGS;\n-\n-\tcase Y_ADDR_OR_YBASE_REGS:\n-\t  return Y_ADDR_REGS;\n-\n-\tcase YBASE_OR_NOHIGH_YBASE_ELIGIBLE_REGS:\n-\t  return NON_HIGH_YBASE_ELIGIBLE_REGS;;\n-\t  \n-\tcase YBASE_OR_YBASE_ELIGIBLE_REGS:\n-\t  return YBASE_ELIGIBLE_REGS;\n-\n-\tcase NO_HIGH_ALL_REGS:\n-\t  return NOHIGH_NON_YBASE_REGS;\n-\n-\tcase ALL_REGS:\n-\t  return NON_YBASE_REGS;\n-\n-\tdefault:\n-\t  return class;\n-\t}\n-    }\n-\n-  /* If x is not an accumulator or a ybase register, restrict the class of registers\n-     we can copy the register into.  */\n-\n-  if (REG_P (x) && !IS_ACCUM_REG (REGNO (x)) && !IS_YBASE_REGISTER_WINDOW (REGNO (x)))\n-    {\n-      switch ((int) class)\n-\t{\n-\tcase NO_REGS:\n-\tcase A0H_REG: case A0L_REG: case A0_REG: case A1H_REG:\n-\tcase ACCUM_HIGH_REGS: case A1L_REG: case ACCUM_LOW_REGS: \n-\tcase A1_REG: case ACCUM_REGS:\n-\t  return class;\n-\n-\tcase X_REG: \n-\t  return (!reload_in_progress ? NO_REGS : class);\n-\n-\tcase X_OR_ACCUM_LOW_REGS: \n-\t  return ACCUM_LOW_REGS;\n-\n-\tcase X_OR_ACCUM_REGS:\n-\t  return ACCUM_REGS;\n-\n-\tcase YH_REG:\n-\t  return (!reload_in_progress ? NO_REGS : class);\n-\n-\tcase YH_OR_ACCUM_HIGH_REGS:\n-\t  return ACCUM_HIGH_REGS;\n-\n-\tcase X_OR_YH_REGS: \n-\tcase YL_REG:\n-\t  return (!reload_in_progress ? NO_REGS : class);\n-\n-\tcase YL_OR_ACCUM_LOW_REGS: \n-\t  return ACCUM_LOW_REGS;\n-\n-\tcase X_OR_YL_REGS:\n-\tcase X_OR_Y_REGS: case Y_REG:\n-\t  return (!reload_in_progress ? NO_REGS : class);\n-\n-\tcase ACCUM_OR_Y_REGS: \n-\t  return ACCUM_REGS;\n-\n-\tcase PH_REG:\n-\tcase X_OR_PH_REGS: case PL_REG: \n-\t  return (!reload_in_progress ? NO_REGS : class);\n-\n-\tcase PL_OR_ACCUM_LOW_REGS:\n- \t  return ACCUM_LOW_REGS;\n-\n-\tcase X_OR_PL_REGS:\n-\t  return (!reload_in_progress ? NO_REGS : class);\n-\n-\tcase YL_OR_PL_OR_ACCUM_LOW_REGS: \n- \t  return ACCUM_LOW_REGS;\n-\n-\tcase P_REG:\n-\t  return (!reload_in_progress ? NO_REGS : class);\n-\n-\tcase ACCUM_OR_P_REGS: \n-\t  return ACCUM_REGS;\n-\n-\tcase YL_OR_P_REGS:\n-\t  return (!reload_in_progress ? NO_REGS : class);\n-\n-\tcase ACCUM_LOW_OR_YL_OR_P_REGS: \n- \t  return ACCUM_LOW_REGS;\n-\n-\tcase Y_OR_P_REGS:\n-\t  return (!reload_in_progress ? NO_REGS : class);\n-\n-\tcase ACCUM_Y_OR_P_REGS: \n-\t  return ACCUM_REGS;\n-\n-\tcase NO_FRAME_Y_ADDR_REGS:\n-\tcase Y_ADDR_REGS:\n-\t  return (!reload_in_progress ? NO_REGS : class);\n-\n-\tcase ACCUM_LOW_OR_Y_ADDR_REGS:\n- \t  return ACCUM_LOW_REGS;\n-\n-\tcase ACCUM_OR_Y_ADDR_REGS: \n-\t  return ACCUM_REGS;\n-\n-\tcase X_OR_Y_ADDR_REGS:\n-\tcase Y_OR_Y_ADDR_REGS: \n-\tcase P_OR_Y_ADDR_REGS:\n-\t  return (!reload_in_progress ? NO_REGS : class);\n-\n-\tcase NON_HIGH_YBASE_ELIGIBLE_REGS: \n- \t  return ACCUM_LOW_REGS;\n-\n-\tcase YBASE_ELIGIBLE_REGS:\n-\t  return ACCUM_REGS;\n-\n-\tcase J_REG:\n-\tcase J_OR_DAU_16_BIT_REGS:\n-\tcase BMU_REGS: \n-\t  return (!reload_in_progress ? NO_REGS : class);\n-\n-\tcase YBASE_VIRT_REGS:\n-\t  if (IS_YBASE_ELIGIBLE_REG (REGNO (x)))\n-\t    return class;\n-\t  else\n-\t    return (!reload_in_progress ? NO_REGS : class);\n-\n-\tcase ACCUM_LOW_OR_YBASE_REGS:\n-\t  if (IS_YBASE_ELIGIBLE_REG (REGNO (x)))\n-\t    return class;\n-\t  else\n-\t    return ACCUM_LOW_REGS;\n-\n-\tcase ACCUM_OR_YBASE_REGS:\n-\t  if (IS_YBASE_ELIGIBLE_REG (REGNO (x)))\n-\t    return class;\n-\t  else\n-\t    return ACCUM_REGS;\n-\n-\tcase X_OR_YBASE_REGS:\n-\tcase Y_OR_YBASE_REGS:\n-\t  if (IS_YBASE_ELIGIBLE_REG (REGNO (x)))\n-\t    return YBASE_VIRT_REGS;\n-\t  else\n-\t    return (!reload_in_progress ? NO_REGS : class);\n-\n-\tcase ACCUM_LOW_YL_PL_OR_YBASE_REGS:\n-\t  if (IS_YBASE_ELIGIBLE_REG (REGNO (x)))\n-\t    return ACCUM_LOW_OR_YBASE_REGS;\n-\t  else\n-\t    return ACCUM_LOW_REGS;\n-\n-\tcase P_OR_YBASE_REGS:\n-\t  if (IS_YBASE_ELIGIBLE_REG (REGNO (x)))\n-\t    return YBASE_VIRT_REGS;\n-\t  else\n-\t    return (!reload_in_progress ? NO_REGS : class);\n-\n-\tcase ACCUM_Y_P_OR_YBASE_REGS:\n-\t  if (IS_YBASE_ELIGIBLE_REG (REGNO (x)))\n-\t    return ACCUM_OR_YBASE_REGS;\n-\t  else\n-\t    return ACCUM_REGS;\n-\n-\tcase Y_ADDR_OR_YBASE_REGS:\n-\t  if (IS_YBASE_ELIGIBLE_REG (REGNO (x)))\n-\t    return YBASE_VIRT_REGS;\n-\t  else\n-\t    return (!reload_in_progress ? NO_REGS : class);\n-\n-\tcase YBASE_OR_NOHIGH_YBASE_ELIGIBLE_REGS:\n-\t  if (IS_YBASE_ELIGIBLE_REG (REGNO (x)))\n-\t    return ACCUM_LOW_OR_YBASE_REGS;\n-\t  else\n-\t    return ACCUM_LOW_REGS;\n-\n-\tcase YBASE_OR_YBASE_ELIGIBLE_REGS:\n-\t  if (IS_YBASE_ELIGIBLE_REG (REGNO (x)))\n-\t    return ACCUM_OR_YBASE_REGS;\n-\t  else\n-\t    return ACCUM_REGS;\n-\n-\tcase NO_HIGH_ALL_REGS:\n-\t  if (IS_YBASE_ELIGIBLE_REG (REGNO (x)))\n-\t    return ACCUM_LOW_OR_YBASE_REGS;\n-\t  else\n-\t    return ACCUM_LOW_REGS;\n-\n-\tcase ALL_REGS: \n-\t  if (IS_YBASE_ELIGIBLE_REG (REGNO (x)))\n-\t    return ACCUM_OR_YBASE_REGS;\n-\t  else\n-\t    return ACCUM_REGS;\n-\n-\tcase NOHIGH_NON_ADDR_REGS:\n-\t    return ACCUM_LOW_REGS;\n-\n-\tcase NON_ADDR_REGS:\n-\tcase SLOW_MEM_LOAD_REGS:\n-\t    return ACCUM_REGS;\n-\n-\tcase NOHIGH_NON_YBASE_REGS:\n-\t    return ACCUM_LOW_REGS;\n-\n-\tcase NO_ACCUM_NON_YBASE_REGS:\n-\t  return (!reload_in_progress ? NO_REGS : class);\n-\n-\tcase NON_YBASE_REGS:\n-\t    return ACCUM_REGS;\n-\n-\tdefault:\n-\t  return class;\n-\t}\n-    }\n-\n-  /* If x (the input) is a ybase register, restrict the class of registers\n-     we can copy the register into.  */\n-\n-  if (REG_P (x) && !TARGET_RESERVE_YBASE\n-      && IS_YBASE_REGISTER_WINDOW (REGNO(x)))\n-    {\n-      switch ((int) class)\n-\t{\n-\tcase NO_REGS:\n-\tcase A0H_REG: case A0L_REG: case A0_REG: case A1H_REG:\n-\tcase ACCUM_HIGH_REGS: case A1L_REG: case ACCUM_LOW_REGS: \n-\tcase A1_REG: case ACCUM_REGS: case X_REG: \n-\tcase X_OR_ACCUM_LOW_REGS: case X_OR_ACCUM_REGS:\n-\tcase YH_REG: case YH_OR_ACCUM_HIGH_REGS:\n-\tcase X_OR_YH_REGS: case YL_REG:\n-\tcase YL_OR_ACCUM_LOW_REGS: case X_OR_YL_REGS:\n-\tcase X_OR_Y_REGS: case Y_REG:\n-\tcase ACCUM_OR_Y_REGS: case PH_REG:\n-\tcase X_OR_PH_REGS: case PL_REG: \n-\tcase PL_OR_ACCUM_LOW_REGS: case X_OR_PL_REGS:\n-\tcase YL_OR_PL_OR_ACCUM_LOW_REGS: case P_REG:\n-\tcase ACCUM_OR_P_REGS: case YL_OR_P_REGS:\n-\tcase ACCUM_LOW_OR_YL_OR_P_REGS: case Y_OR_P_REGS:\n-\tcase ACCUM_Y_OR_P_REGS: case NO_FRAME_Y_ADDR_REGS:\n-\tcase Y_ADDR_REGS: case ACCUM_LOW_OR_Y_ADDR_REGS:\n-\tcase ACCUM_OR_Y_ADDR_REGS: case X_OR_Y_ADDR_REGS:\n-\tcase Y_OR_Y_ADDR_REGS: case P_OR_Y_ADDR_REGS:\n-\tcase NON_HIGH_YBASE_ELIGIBLE_REGS: case YBASE_ELIGIBLE_REGS:\n-\tdefault:\n-\t  return class;\n-\n-\tcase J_REG:\n-\t  return (!reload_in_progress ? NO_REGS : class);\n-\n-\tcase J_OR_DAU_16_BIT_REGS:\n-\t  return ACCUM_HIGH_REGS;\n-\n-\tcase BMU_REGS: \n-\tcase YBASE_VIRT_REGS:\n-\t  return (!reload_in_progress ? NO_REGS : class);\n-\n-\tcase ACCUM_LOW_OR_YBASE_REGS:\n-\t  return ACCUM_LOW_REGS;\n-\n-\tcase ACCUM_OR_YBASE_REGS:\n-\t  return ACCUM_REGS;\n-\n-\tcase X_OR_YBASE_REGS:\n-\t  return X_REG;\n-\n-\tcase Y_OR_YBASE_REGS:\n-\t  return Y_REG;\n-\n-\tcase ACCUM_LOW_YL_PL_OR_YBASE_REGS:\n-\t  return YL_OR_PL_OR_ACCUM_LOW_REGS; \n-\n-\tcase P_OR_YBASE_REGS:\n-\t  return P_REG;\n-\n-\tcase ACCUM_Y_P_OR_YBASE_REGS:\n-\t  return ACCUM_Y_OR_P_REGS;\n-\n-\tcase Y_ADDR_OR_YBASE_REGS:\n-\t  return Y_ADDR_REGS;\n-\n-\tcase YBASE_OR_NOHIGH_YBASE_ELIGIBLE_REGS:\n-\t  return NON_HIGH_YBASE_ELIGIBLE_REGS;\n-\n-\tcase YBASE_OR_YBASE_ELIGIBLE_REGS:\n-\t  return YBASE_ELIGIBLE_REGS;\n-\n-\tcase NO_HIGH_ALL_REGS:\n-\t  return NON_HIGH_YBASE_ELIGIBLE_REGS;\n-\n-\tcase ALL_REGS: \n-\t  return YBASE_ELIGIBLE_REGS;\n-\n-\tcase NOHIGH_NON_ADDR_REGS:\n-\t  return ACCUM_LOW_OR_YL_OR_P_REGS;\n-\n-\tcase NON_ADDR_REGS:\n-\t  return ACCUM_Y_OR_P_REGS;\n-\n-\tcase SLOW_MEM_LOAD_REGS:\n-\t  return ACCUM_OR_Y_ADDR_REGS;\n-\n-\tcase NOHIGH_NON_YBASE_REGS:\n-    \t  return NON_HIGH_YBASE_ELIGIBLE_REGS;\n-\n-    \tcase NO_ACCUM_NON_YBASE_REGS:\n-\t  return Y_ADDR_REGS;\n-\n-    \tcase NON_YBASE_REGS:\n-\t  return YBASE_ELIGIBLE_REGS;\n-\t}\n-    }\n-\n-  if (GET_CODE (x) == PLUS)\n-    {\n-      if (GET_MODE (x) == QImode\n-\t  && REG_P (XEXP (x,0))\n-\t  && (XEXP (x,0) == frame_pointer_rtx\n-\t      || XEXP (x,0) == stack_pointer_rtx)\n-\t  && (GET_CODE (XEXP (x,1)) == CONST_INT))\n-\t{\n-\t  if (class == ACCUM_HIGH_REGS)\n-\t    return class;\n-\n-\t  /* If the accumulators are not part of the class\n-\t     being reloaded into, return NO_REGS.  */\n-#if 0\n-\t  if (!reg_class_subset_p (ACCUM_REGS, class))\n-\t    return (!reload_in_progress ? NO_REGS : class);\n-#endif\n-\t  if (reg_class_subset_p (ACCUM_HIGH_REGS, class))\n-\t    return ACCUM_HIGH_REGS;\n-\n-\t  /* We will use accumulator 'a1l' for reloading a\n-\t     PLUS.  We can only use one accumulator because\n-\t     'reload_inqi' only allows one alternative to be\n-\t     used.  */\n-\n-\t  else if (class == ACCUM_LOW_REGS)\n-\t    return A1L_REG;\n-\t  else if (class == A0L_REG)\n-\t    return NO_REGS;\n-\t  else\n-\t    return class;\n-\t}\n-\n-      if (class == NON_YBASE_REGS || class == YBASE_ELIGIBLE_REGS)\n-\treturn Y_ADDR_REGS;\n-      else\n-\treturn class;\n-    }\n-  else if (GET_CODE (x) == MEM)\n-    {\n-      /* We can't copy from a memory location into a\n-\t ybase register.  */\n-      if (reg_class_subset_p(YBASE_VIRT_REGS, class))\n-\t{\n-\t  switch ((int) class)\n-\t    {\n-\t    case YBASE_VIRT_REGS:\n-\t      return (!reload_in_progress ? NO_REGS : class);\n-\n-\t    case ACCUM_LOW_OR_YBASE_REGS:\n-\t      return ACCUM_LOW_REGS;\n-\n-\t    case ACCUM_OR_YBASE_REGS:\n-\t      return ACCUM_REGS;\n-\n-\t    case X_OR_YBASE_REGS:\n-\t      return X_REG;\n-\n-\t    case Y_OR_YBASE_REGS:\n-\t      return Y_REG;\n-\n-\t    case ACCUM_LOW_YL_PL_OR_YBASE_REGS:\n-\t      return YL_OR_PL_OR_ACCUM_LOW_REGS;\n-\n-\t    case P_OR_YBASE_REGS:\n-\t      return P_REG;\n-\n-\t    case ACCUM_Y_P_OR_YBASE_REGS:\n-\t      return ACCUM_Y_OR_P_REGS;\n-\n-\t    case Y_ADDR_OR_YBASE_REGS:\n-\t      return Y_ADDR_REGS;\n-\n-\t    case YBASE_OR_NOHIGH_YBASE_ELIGIBLE_REGS:\n-\t      return NON_HIGH_YBASE_ELIGIBLE_REGS;\n-\t  \n-\t    case YBASE_OR_YBASE_ELIGIBLE_REGS:\n-\t      return YBASE_ELIGIBLE_REGS;\n-\n-\t    case NO_HIGH_ALL_REGS:\n-\t      return NOHIGH_NON_YBASE_REGS;\n-\n-\t    case ALL_REGS:\n-\t      return NON_YBASE_REGS;\n-\n-\t    default:\n-\t      return class;\n-\t    }\n-\t}\n-      else\n-\treturn class;\n-    }\n-  else\n-    return class;\n-}\n-\t\n-/* Return the register class of a scratch register needed to copy IN into\n-   or out of a register in CLASS in MODE.  If it can be done directly,\n-   NO_REGS is returned.  */\n-\n-enum reg_class\n-secondary_reload_class (class, mode, in)\n-     enum reg_class class;\n-     enum machine_mode mode;\n-     rtx in;\n-{\n-  int regno = -1;\n-\n-  if (GET_CODE (in) == REG || GET_CODE (in) == SUBREG)\n-    regno = true_regnum (in);\n-\n-  /* If we are reloading a plus into a high accumulator register,\n-     we need a scratch low accumulator, because the low half gets\n-     clobbered.  */\n-\n-  if (class == ACCUM_HIGH_REGS \n-      || class == A1H_REG\n-      || class == A0H_REG)\n-    {\n-      if (GET_CODE (in) == PLUS && mode == QImode)\n-\treturn ACCUM_LOW_REGS;\n-    }\n-\n-  if (class == ACCUM_HIGH_REGS \n-      || class == ACCUM_LOW_REGS\n-      || class == A1L_REG\n-      || class == A0L_REG\n-      || class == A1H_REG\n-      || class == A0H_REG)\n-    {\n-      if (GET_CODE (in) == PLUS && mode == QImode)\n-\t{\n-\t  rtx addr0 = XEXP (in, 0);\n-\t  rtx addr1 = XEXP (in, 1);\n-\t  \n-\t  /* If we are reloading a plus (reg:QI) (reg:QI)\n-\t     we need an additional register.  */ \n-\t  if (REG_P (addr0) && REG_P (addr1))\n-\t    return NO_REGS;\n-\t}\n-    }\n-\n-  /* We can place anything into ACCUM_REGS and can put ACCUM_REGS\n-     into anything.  */\n-\n-  if ((class == ACCUM_REGS || class == ACCUM_HIGH_REGS ||\n-       class == ACCUM_LOW_REGS || class == A0H_REG || class == A0L_REG ||\n-       class == A1H_REG || class == A1_REG) || \n-      (regno >= REG_A0 && regno < REG_A1L + 1))\n-    return NO_REGS;\n-\n-  if (class == ACCUM_OR_YBASE_REGS && REG_P(in)\n-      && IS_YBASE_ELIGIBLE_REG(regno))\n-    {\n-      return NO_REGS;\n-    }\n-\n-  /* We can copy the ybase registers into:\n-     r0-r3, a0-a1, y, p, & x or the union of\n-     any of these.  */\n-\n-  if (!TARGET_RESERVE_YBASE && IS_YBASE_REGISTER_WINDOW(regno))\n-    {\n-      switch ((int) class)\n-\t{\n-\tcase (int) X_REG:\n-\tcase (int) X_OR_ACCUM_LOW_REGS:\n-\tcase (int) X_OR_ACCUM_REGS:\n-\tcase (int) YH_REG:\n-\tcase (int) YH_OR_ACCUM_HIGH_REGS:\n-\tcase (int) X_OR_YH_REGS:\n-\tcase (int) YL_REG:\n-\tcase (int) YL_OR_ACCUM_LOW_REGS:\n-\tcase (int) X_OR_Y_REGS:\n-\tcase (int) X_OR_YL_REGS:\n-\tcase (int) Y_REG:\n-\tcase (int) ACCUM_OR_Y_REGS:\n-\tcase (int) PH_REG:\n-\tcase (int) X_OR_PH_REGS:\n-\tcase (int) PL_REG:\n-\tcase (int) PL_OR_ACCUM_LOW_REGS:\n-\tcase (int) X_OR_PL_REGS:\n-\tcase (int) YL_OR_PL_OR_ACCUM_LOW_REGS:\n-\tcase (int) P_REG:\n-\tcase (int) ACCUM_OR_P_REGS:\n-\tcase (int) YL_OR_P_REGS:\n-\tcase (int) ACCUM_LOW_OR_YL_OR_P_REGS:\n-\tcase (int) Y_OR_P_REGS:\n-\tcase (int) ACCUM_Y_OR_P_REGS:\n-\tcase (int) Y_ADDR_REGS:\n-\tcase (int) ACCUM_LOW_OR_Y_ADDR_REGS:\n-\tcase (int) ACCUM_OR_Y_ADDR_REGS:\n-\tcase (int) X_OR_Y_ADDR_REGS:\n-\tcase (int) Y_OR_Y_ADDR_REGS:\n-\tcase (int) P_OR_Y_ADDR_REGS:\n-\tcase (int) YBASE_ELIGIBLE_REGS:\n-\t  return NO_REGS;\n-\n-\tdefault:\n-\t  return ACCUM_HIGH_REGS;\n-\t}\n-    }\n-\n-  /* We can copy r0-r3, a0-a1, y, & p\n-     directly to the ybase registers. In addition\n-     we can use any of the ybase virtual registers\n-     as the secondary reload registers when copying\n-     between any of these registers.  */\n-\n-  if (!TARGET_RESERVE_YBASE && regno != -1)\n-    {\n-      switch (regno)\n-\t{\n-\tcase REG_A0:\n-\tcase REG_A0L:\n-\tcase REG_A1:\n-\tcase REG_A1L:\n-\tcase REG_X:\n-\tcase REG_Y:\n-\tcase REG_YL:\n-\tcase REG_PROD:\n-\tcase REG_PRODL:\n-\tcase REG_R0:\n-\tcase REG_R1:\n-\tcase REG_R2:\n-\tcase REG_R3:\n-\t  if (class == YBASE_VIRT_REGS)\n-\t    return NO_REGS;\n-\t  else\n-\t    {\n-\t      switch ((int) class)\n-\t\t{\n-\t\tcase (int) X_REG:\n-\t\tcase (int) X_OR_ACCUM_LOW_REGS:\n-\t\tcase (int) X_OR_ACCUM_REGS:\n-\t\tcase (int) YH_REG:\n-\t\tcase (int) YH_OR_ACCUM_HIGH_REGS:\n-\t\tcase (int) X_OR_YH_REGS:\n-\t\tcase (int) YL_REG:\n-\t\tcase (int) YL_OR_ACCUM_LOW_REGS:\n-\t\tcase (int) X_OR_Y_REGS:\n-\t\tcase (int) X_OR_YL_REGS:\n-\t\tcase (int) Y_REG:\n-\t\tcase (int) ACCUM_OR_Y_REGS:\n-\t\tcase (int) PH_REG:\n-\t\tcase (int) X_OR_PH_REGS:\n-\t\tcase (int) PL_REG:\n-\t\tcase (int) PL_OR_ACCUM_LOW_REGS:\n-\t\tcase (int) X_OR_PL_REGS:\n-\t\tcase (int) YL_OR_PL_OR_ACCUM_LOW_REGS:\n-\t\tcase (int) P_REG:\n-\t\tcase (int) ACCUM_OR_P_REGS:\n-\t\tcase (int) YL_OR_P_REGS:\n-\t\tcase (int) ACCUM_LOW_OR_YL_OR_P_REGS:\n-\t\tcase (int) Y_OR_P_REGS:\n-\t\tcase (int) ACCUM_Y_OR_P_REGS:\n-\t\tcase (int) Y_ADDR_REGS:\n-\t\tcase (int) ACCUM_LOW_OR_Y_ADDR_REGS:\n-\t\tcase (int) ACCUM_OR_Y_ADDR_REGS:\n-\t\tcase (int) X_OR_Y_ADDR_REGS:\n-\t\tcase (int) Y_OR_Y_ADDR_REGS:\n-\t\tcase (int) P_OR_Y_ADDR_REGS:\n-\t\tcase (int) YBASE_ELIGIBLE_REGS:\n-\t\t  return YBASE_VIRT_REGS;\n-\n-\t\tdefault:\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t}\n-    }\n-\n-  /* Memory or constants can be moved from or to any register\n-     except the ybase virtual registers.  */\n-  if (regno == -1 && GET_CODE(in) != PLUS)\n-    {\n-      if (class == YBASE_VIRT_REGS)\n-\treturn NON_YBASE_REGS;\n-      else\n-        return NO_REGS;\n-    }\n-\n-  if (GET_CODE (in) == PLUS && mode == QImode)\n-    {\n-      rtx addr0 = XEXP (in, 0);\n-      rtx addr1 = XEXP (in, 1);\n-\n-      /* If we are reloading a plus (reg:QI) (reg:QI)\n-\t we need a low accumulator, not a high one.  */\n-      if (REG_P (addr0) && REG_P (addr1))\n-\treturn ACCUM_LOW_REGS;\n-    }\n-\n-#if 0\n-  if (REG_P(in))\n-    return ACCUM_REGS;\n-#endif\n-\n-  /* Otherwise, we need a high accumulator(s).  */\n-  return ACCUM_HIGH_REGS;\n-}\n-\n-int\n-symbolic_address_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-{\n-  return (symbolic_address_p (op));\n-}\n-\n-int\n-symbolic_address_p (op)\n-     rtx op;\n-{\n-  switch (GET_CODE (op))\n-    {\n-    case SYMBOL_REF:\n-    case LABEL_REF:\n-      return 1;\n-\n-    case CONST:\n-      op = XEXP (op, 0);\n-      return ((GET_CODE (XEXP (op, 0)) == SYMBOL_REF\n-\t       || GET_CODE (XEXP (op, 0)) == LABEL_REF)\n-\t      && GET_CODE (XEXP (op, 1)) == CONST_INT\n-              && INTVAL (XEXP (op,1)) < 0x20);\n-\n-    default:\n-      return 0;\n-    }\n-}\n-\n-/* For a Y address space operand we allow only *rn, *rn++, *rn--.\n-   This routine only recognizes *rn, the '<>' constraints recognize\n-   (*rn++), and (*rn--).  */\n-\n-int\n-Y_address_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  return (memory_address_p (mode, op) && !symbolic_address_p (op));\n-}\t     \n-\n-int\n-sp_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-{\n-    return (GET_CODE (op) == PLUS\n-\t    && (XEXP (op, 0) == stack_pointer_rtx\n-\t\t|| XEXP (op, 0) == frame_pointer_rtx)\n-\t    && GET_CODE (XEXP (op,1)) == CONST_INT);\n-}\n-\n-int\n-sp_operand2 (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-{\n-  if ((GET_CODE (op) == PLUS \n-       && (XEXP (op, 0) == stack_pointer_rtx\n-\t   || XEXP (op, 0) == frame_pointer_rtx)\n-       && (REG_P (XEXP (op,1))\n-\t   && IS_ADDRESS_REGISTER (REGNO (XEXP(op, 1))))))\n-    return 1;\n-  else if ((GET_CODE (op) == PLUS\n-       && (XEXP (op, 1) == stack_pointer_rtx\n-\t   || XEXP (op, 1) == frame_pointer_rtx)\n-       && (REG_P (XEXP (op,0))\n-\t   && IS_ADDRESS_REGISTER (REGNO (XEXP(op, 1))))))\n-    return 1;\n-  else\n-    return 0;\n-}\n-\n-int\n-nonmemory_arith_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  return (immediate_operand (op, mode) || arith_reg_operand (op, mode));\n-}\n-\n-int\n-arith_reg_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  return (register_operand (op, mode)\n-\t  && (GET_CODE (op) != REG\n-\t      || REGNO (op) >= FIRST_PSEUDO_REGISTER\n-\t      || (!(IS_YBASE_REGISTER_WINDOW (REGNO (op)))\n-\t\t  && REGNO (op) != FRAME_POINTER_REGNUM)));\n-}\n-\n-int\n-call_address_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-{\n-    if (symbolic_address_p (op) || REG_P(op))\n-    {\n-\treturn 1;\n-    }\n-\n-    return 0;\n-}\n-\n-int\n-dsp16xx_comparison_operator (op, mode)\n-    register rtx op;\n-    enum machine_mode mode;\n-{\n-  return ((mode == VOIDmode || GET_MODE (op) == mode)\n-\t  && GET_RTX_CLASS (GET_CODE (op)) == '<'\n-\t  && (GET_CODE(op) != GE && GET_CODE (op) != LT &&\n-\t      GET_CODE (op) != GEU && GET_CODE (op) != LTU));\n-}\n-\n-void\n-notice_update_cc(exp)\n-     rtx exp;\n-{\n-    if (GET_CODE (exp) == SET)\n-    {\n-\t/* Jumps do not alter the cc's.  */\n-\n-\tif (SET_DEST (exp) == pc_rtx)\n-\t    return;\n-\n-\t/* Moving register or memory into a register:\n-\t   it doesn't alter the cc's, but it might invalidate\n-\t   the RTX's which we remember the cc's came from.\n-\t   (Note that moving a constant 0 or 1 MAY set the cc's).  */\n-\tif (REG_P (SET_DEST (exp))\n-\t    && (REG_P (SET_SRC (exp)) || GET_CODE (SET_SRC (exp)) == MEM))\n-\t{\n-\t    if (cc_status.value1\n-\t\t&& reg_overlap_mentioned_p (SET_DEST (exp), cc_status.value1))\n-\t\tcc_status.value1 = 0;\n-\t    if (cc_status.value2\n-\t\t&& reg_overlap_mentioned_p (SET_DEST (exp), cc_status.value2))\n-\t\tcc_status.value2 = 0;\n-\t    return;\n-\t}\n-\t/* Moving register into memory doesn't alter the cc's.\n-\t   It may invalidate the RTX's which we remember the cc's came from.  */\n-\tif (GET_CODE (SET_DEST (exp)) == MEM && REG_P (SET_SRC (exp)))\n-\t{\n-\t    if (cc_status.value1 && GET_CODE (cc_status.value1) == MEM)\n-\t\tcc_status.value1 = 0;\n-\t    if (cc_status.value2 && GET_CODE (cc_status.value2) == MEM)\n-\t\tcc_status.value2 = 0;\n-\t    return;\n-\t}\n-\t/* Function calls clobber the cc's.  */\n-\telse if (GET_CODE (SET_SRC (exp)) == CALL)\n-\t{\n-\t    CC_STATUS_INIT;\n-\t    return;\n-\t}\n-\t/* Tests and compares set the cc's in predictable ways.  */\n-\telse if (SET_DEST (exp) == cc0_rtx)\n-\t{\n-\t    CC_STATUS_INIT;\n-\t    cc_status.value1 = SET_SRC (exp);\n-\t    return;\n-\t}\n-\t/* Certain instructions effect the condition codes.  */\n-\telse if (GET_MODE_CLASS (GET_MODE (SET_SRC (exp))) == MODE_INT)\n-\t    switch (GET_CODE (SET_SRC (exp)))\n-\t    {\n-\t    case PLUS: \n-\t    case MINUS:\n-\t      if (REG_P (SET_DEST (exp)))\n-\t\t{\n-\t\t  /* Address registers don't set the condition codes.  */\n-\t\t  if (IS_ADDRESS_REGISTER (REGNO (SET_DEST (exp))))\n-\t\t    {\n-\t\t      CC_STATUS_INIT;\n-\t\t      break;\n-\t\t    }\n-\t\t}\n-\t    case ASHIFTRT: \n-\t    case LSHIFTRT:\n-\t    case ASHIFT: \n-\t    case AND: \n-\t    case IOR: \n-\t    case XOR:\n-\t    case MULT:\n-\t    case NEG:\n-\t    case NOT:\n-\t      cc_status.value1 = SET_SRC (exp);\n-\t      cc_status.value2 = SET_DEST (exp);\n-\t      break;\n-\t      \n-\t    default:\n-\t      CC_STATUS_INIT;\n-\t    }\n-\telse\n-\t{\n-\t    CC_STATUS_INIT;\n-\t}\n-    }\n-    else if (GET_CODE (exp) == PARALLEL\n-\t     && GET_CODE (XVECEXP (exp, 0, 0)) == SET)\n-    {\n-\tif (SET_DEST (XVECEXP (exp, 0, 0)) == pc_rtx)\n-\t    return;\n-\n-\tif (SET_DEST (XVECEXP (exp, 0, 0)) == cc0_rtx)\n-\t{\n-\t    CC_STATUS_INIT;\n-\t    cc_status.value1 = SET_SRC (XVECEXP (exp, 0, 0));\n-\t    return;\n-\t}\n-\n-\tCC_STATUS_INIT;\n-    }\n-    else\n-    {\n-\tCC_STATUS_INIT;\n-    }\n-}\n-\n-int\n-dsp16xx_makes_calls ()\n-{\n-  rtx insn;\n-\n-  for (insn = get_insns (); insn; insn = next_insn (insn))\n-    if (GET_CODE (insn) == CALL_INSN)\n-      return (1);\n-\n-  return 0;\n-}\n-\n-long\n-compute_frame_size (size)\n-     int size;\n-{\n-  long total_size;\n-  long var_size;\n-  long args_size;\n-  long extra_size;\n-  long reg_size;\n-\n-  /* This value is needed to compute reg_size.  */\n-  current_frame_info.function_makes_calls = !leaf_function_p ();\n-\n-  reg_size = 0;\n-  extra_size = 0;\n-  var_size = size;\n-  args_size = current_function_outgoing_args_size;\n-  reg_size = reg_save_size ();  \n-\n-  total_size = var_size + args_size + extra_size + reg_size;\n-\n-\n-  /* Save other computed information.  */\n-  current_frame_info.total_size  = total_size;\n-  current_frame_info.var_size    = var_size;\n-  current_frame_info.args_size   = args_size;\n-  current_frame_info.extra_size  = extra_size;\n-  current_frame_info.reg_size    = reg_size;\n-  current_frame_info.initialized = reload_completed;\n-  current_frame_info.reg_size\t = reg_size / UNITS_PER_WORD;\n-\n-  if (reg_size)\n-    {\n-      unsigned long offset = args_size + var_size + reg_size;\n-      current_frame_info.sp_save_offset = offset;\n-      current_frame_info.fp_save_offset = offset - total_size;\n-    }\n-\n-  return total_size;\n-}\n-\n-int\n-dsp16xx_call_saved_register (regno)\n-     int regno;\n-{\n-#if 0\n-  if (regno == REG_PR && current_frame_info.function_makes_calls)\n-    return 1;\n-#endif\n-  return (regs_ever_live[regno] && !call_used_regs[regno] &&\n-\t  !IS_YBASE_REGISTER_WINDOW(regno));\n-}\n-\n-int\n-ybase_regs_ever_used ()\n-{\n-  int regno;\n-  int live = 0;\n-\n-  for (regno = REG_YBASE0; regno <= REG_YBASE31; regno++)\n-    if (regs_ever_live[regno])\n-      {\n-\tlive = 1;\n-\tbreak;\n-      }\n-\n-  return live;\n-}\n-\n-static void \n-dsp16xx_output_function_prologue (file, size)\n-     FILE *file;\n-     HOST_WIDE_INT size;\n-{\n-  int regno;\n-  long total_size;\n-  fp = reg_names[FRAME_POINTER_REGNUM];\n-  sp = reg_names[STACK_POINTER_REGNUM];\n-  rr = reg_names[RETURN_ADDRESS_REGNUM];   /* return address register */\n-  a1h = reg_names[REG_A1];\n-  \n-  total_size = compute_frame_size (size);\n-  \n-  fprintf (file, \"\\t/* FUNCTION PROLOGUE: */\\n\");\n-  fprintf (file, \"\\t/* total=%ld, vars= %ld, regs= %d, args=%d, extra= %ld */\\n\",\n-\t   current_frame_info.total_size,\n-\t   current_frame_info.var_size,\n-\t   current_frame_info.reg_size,\n-\t   current_function_outgoing_args_size,\n-\t   current_frame_info.extra_size);\n-  \n-  fprintf (file, \"\\t/* fp save offset= %ld, sp save_offset= %ld */\\n\\n\",\n-\t   current_frame_info.fp_save_offset,\n-\t   current_frame_info.sp_save_offset);\n-  /* Set up the 'ybase' register window.  */\n-  \n-  if (ybase_regs_ever_used())\n-    {\n-      fprintf (file, \"\\t%s=%s\\n\", a1h, reg_names[REG_YBASE]);\n-      if (TARGET_YBASE_HIGH)\n-\tfprintf (file, \"\\t%s=%sh-32\\n\", reg_names[REG_A1], a1h);\n-      else\n-\tfprintf (file, \"\\t%s=%sh+32\\n\", reg_names[REG_A1], a1h);\n-      fprintf (file, \"\\t%s=%s\\n\", reg_names[REG_YBASE], a1h);\n-    }\n-  \n-  if (current_frame_info.var_size)\n-    {\n-      if (current_frame_info.var_size == 1)\n-\tfprintf (file, \"\\t*%s++\\n\", sp);\n-      else\n-        {\n-\t  if (SMALL_INTVAL(current_frame_info.var_size) && ((current_frame_info.var_size & 0x8000) == 0))\n-\t    fprintf (file, \"\\t%s=%ld\\n\\t*%s++%s\\n\", reg_names[REG_J], current_frame_info.var_size, sp, reg_names[REG_J]);\n-\t  else\n-\t    fatal_error (\"stack size > 32k\");\n-\t}\n-    }\n-  \n-  /* Save any registers this function uses, unless they are\n-     used in a call, in which case we don't need to.  */\n-  \n-  for(regno = 0; regno < FIRST_PSEUDO_REGISTER; ++ regno)\n-    if (dsp16xx_call_saved_register (regno)) \n-      {\n-\tfprintf (file, \"\\tpush(*%s)=%s\\n\", sp, reg_names[regno]);\n-      }\n-\n-  /* For debugging purposes, we want the return address to be at a predictable\n-     location.  */\n-  if (current_frame_info.function_makes_calls)\n-    fprintf (file, \"\\tpush(*%s)=%s\\n\", sp, reg_names[RETURN_ADDRESS_REGNUM]);\n-\n-  if (current_frame_info.args_size)\n-    {\n-      if (current_frame_info.args_size == 1)\n-\tfprintf (file, \"\\t*%s++\\n\", sp);\n-      else\n-\terror (\"stack size > 32k\");\n-    }\n-   \n-  if (frame_pointer_needed)\n-    {\n-      fprintf (file, \"\\t%s=%s\\n\", a1h, sp);\n-      fprintf (file, \"\\t%s=%s\\n\", fp, a1h);  /* Establish new base frame */\n-      fprintf (file, \"\\t%s=%ld\\n\", reg_names[REG_J], -total_size);\n-      fprintf (file, \"\\t*%s++%s\\n\", fp, reg_names[REG_J]);\n-    }\n-  \n-  fprintf (file, \"\\t/* END FUNCTION PROLOGUE: */\\n\\n\");\n-}\n-\n-void\n-init_emulation_routines ()\n-{\n- dsp16xx_addhf3_libcall = (rtx) 0;\n- dsp16xx_subhf3_libcall = (rtx) 0;\n- dsp16xx_mulhf3_libcall = (rtx) 0;\n- dsp16xx_divhf3_libcall = (rtx) 0;\n- dsp16xx_cmphf3_libcall = (rtx) 0;\n- dsp16xx_fixhfhi2_libcall = (rtx) 0;\n- dsp16xx_floathihf2_libcall = (rtx) 0;\n- dsp16xx_neghf2_libcall = (rtx) 0;\n-\n- dsp16xx_mulhi3_libcall = (rtx) 0;\n- dsp16xx_udivqi3_libcall = (rtx) 0;\n- dsp16xx_udivhi3_libcall = (rtx) 0;\n- dsp16xx_divqi3_libcall = (rtx) 0;\n- dsp16xx_divhi3_libcall = (rtx) 0;\n- dsp16xx_modqi3_libcall = (rtx) 0;\n- dsp16xx_modhi3_libcall = (rtx) 0;\n- dsp16xx_umodqi3_libcall = (rtx) 0;\n- dsp16xx_umodhi3_libcall = (rtx) 0;\n- dsp16xx_ashrhi3_libcall = (rtx) 0;\n- dsp16xx_ashlhi3_libcall = (rtx) 0;\n- dsp16xx_ucmphi2_libcall = (rtx) 0;\n- dsp16xx_lshrhi3_libcall = (rtx) 0;\n-\n-}\n-static void\n-dsp16xx_output_function_epilogue (file, size)\n-     FILE *file;\n-     HOST_WIDE_INT size ATTRIBUTE_UNUSED;\n-{\n-  int regno;\n-  \n-  fp = reg_names[FRAME_POINTER_REGNUM];\n-  sp = reg_names[STACK_POINTER_REGNUM];\n-  rr = reg_names[RETURN_ADDRESS_REGNUM];   /* return address register */\n-  a1h = reg_names[REG_A1];\n-  \n-  fprintf (file, \"\\n\\t/* FUNCTION EPILOGUE: */\\n\");\n-  \n-  if (current_frame_info.args_size)\n-    {\n-      if (current_frame_info.args_size == 1)\n-\tfprintf (file, \"\\t*%s--\\n\", sp);\n-      else\n-\t{\n-\t  fprintf (file, \"\\t%s=%ld\\n\\t*%s++%s\\n\", \n-\t\t   reg_names[REG_J], -current_frame_info.args_size, sp, reg_names[REG_J]);\n-\t}\n-    }\n-  \n-  if (ybase_regs_ever_used())\n-    {\n-      fprintf (file, \"\\t%s=%s\\n\", a1h, reg_names[REG_YBASE]);\n-      if (TARGET_YBASE_HIGH)\n-\tfprintf (file, \"\\t%s=%sh+32\\n\", reg_names[REG_A1], a1h);\n-      else\n-\tfprintf (file, \"\\t%s=%sh-32\\n\", reg_names[REG_A1], a1h);\n-      fprintf (file, \"\\t%s=%s\\n\", reg_names[REG_YBASE], a1h);\n-    }\n-\n-  if (current_frame_info.function_makes_calls)\n-    fprintf (file, \"\\t%s=pop(*%s)\\n\", reg_names[RETURN_ADDRESS_REGNUM], sp);\n-  \n-  for (regno = FIRST_PSEUDO_REGISTER - 1; regno >= 0; --regno)\n-    if (dsp16xx_call_saved_register(regno))\n-      {\n-\tfprintf (file, \"\\t%s=pop(*%s)\\n\", reg_names[regno], sp);\n-      }\n-  \n-  if (current_frame_info.var_size)\n-    {\n-      if (current_frame_info.var_size == 1)\n-\tfprintf (file, \"\\t*%s--\\n\", sp);\n-      else\n-\t{\n-\t  fprintf (file, \"\\t%s=%ld\\n\\t*%s++%s\\n\", \n-\t\t   reg_names[REG_J], -current_frame_info.var_size, sp, reg_names[REG_J]);\n-\t}\n-    }\n-  \n-  fprintf (file, \"\\treturn\\n\");\n-  /* Reset the frame info for the next function.  */\n-  current_frame_info = zero_frame_info;\n-  init_emulation_routines ();\n-}\n-\n-/* Emit insns to move operands[1] into operands[0].\n-\n-   Return 1 if we have written out everything that needs to be done to\n-   do the move.  Otherwise, return 0 and the caller will emit the move\n-   normally.  */\n-\n-int\n-emit_move_sequence (operands, mode)\n-     rtx *operands;\n-     enum machine_mode mode;\n-{\n-  register rtx operand0 = operands[0];\n-  register rtx operand1 = operands[1];\n-\n-  /* We can only store registers to memory.  */\n-\n-  if (GET_CODE (operand0) == MEM && GET_CODE (operand1) != REG)\n-    operands[1] = force_reg (mode, operand1);\n-\n-  return 0;\n-}\n-\n-void\n-double_reg_from_memory (operands)\n-     rtx operands[];\n-{\n-    rtx xoperands[4];\n-\n-    if (GET_CODE(XEXP(operands[1],0)) == POST_INC)\n-    {\n-\toutput_asm_insn (\"%u0=%1\", operands);\n-\toutput_asm_insn (\"%w0=%1\", operands);\n-    }\n-    else if (GET_CODE(XEXP(operands[1],0)) == POST_DEC)\n-    {\n-\txoperands[1] = XEXP (XEXP (operands[1], 0), 0);\n-\txoperands[0] = operands[0];\n-\t\n-\t/* We can't use j anymore since the compiler can allocate it.  */\n-/*\toutput_asm_insn (\"j=-3\\n\\t%u0=*%1++\\n\\t%w0=*%1++j\", xoperands); */\n-\toutput_asm_insn (\"%u0=*%1++\\n\\t%w0=*%1--\\n\\t*%1--\\n\\t*%1--\", xoperands);\n-    }\n-    else if (GET_CODE(XEXP(operands[1],0)) == PLUS)\n-    {\n-      rtx addr;\n-      int offset = 0;\n-\n-      output_asm_insn (\"%u0=%1\", operands);\n-\n-\n-      /* In order to print out the least significant word we must\n-\t use 'offset + 1'.  */\n-      addr = XEXP (operands[1], 0);\n-      if (GET_CODE (XEXP(addr,0)) == CONST_INT)\n-\toffset = INTVAL(XEXP(addr,0)) + 1;\n-      else if (GET_CODE (XEXP(addr,1)) == CONST_INT)\n-\toffset = INTVAL(XEXP(addr,1)) + 1;\n-\n-      fprintf (asm_out_file, \"\\t%s=*(%d)\\n\", reg_names[REGNO(operands[0]) + 1], offset + 31);\n-    }\n-    else\n-    {\n-\txoperands[1] = XEXP(operands[1],0);\n-\txoperands[0] = operands[0];\n-\n-\toutput_asm_insn (\"%u0=*%1++\\n\\t%w0=*%1--\", xoperands);\n-    }\n-}\n-\n-\n-void\n-double_reg_to_memory (operands)\n-     rtx operands[];\n-{\n-    rtx xoperands[4];\n-\n-    if (GET_CODE(XEXP(operands[0],0)) == POST_INC)\n-    {\n-\toutput_asm_insn (\"%0=%u1\", operands);\n-\toutput_asm_insn (\"%0=%w1\", operands);\n-    }\n-    else if (GET_CODE(XEXP(operands[0],0)) == POST_DEC)\n-    {\n-\txoperands[0] = XEXP (XEXP (operands[0], 0), 0);\n-\txoperands[1] = operands[1];\n-\t\n-\t/* We can't use j anymore since the compiler can allocate it.  */\n-\n-/*\toutput_asm_insn (\"j=-3\\n\\t*%0++=%u1\\n\\t*%0++j=%w1\", xoperands); */\n-\toutput_asm_insn (\"*%0++=%u1\\n\\t*%0--=%w1\\n\\t*%0--\\n\\t*%0--\", xoperands);\n-\n-    }\n-    else if (GET_CODE(XEXP(operands[0],0)) == PLUS)\n-    {\n-      rtx addr;\n-      int offset = 0;\n-\n-      output_asm_insn (\"%0=%u1\", operands);\n-\n-      /* In order to print out the least significant word we must\n-\t use 'offset + 1'.  */\n-      addr = XEXP (operands[0], 0);\n-      if (GET_CODE (XEXP(addr,0)) == CONST_INT)\n-\toffset = INTVAL(XEXP(addr,0)) + 1;\n-      else if (GET_CODE (XEXP(addr,1)) == CONST_INT)\n-\toffset = INTVAL(XEXP(addr,1)) + 1;\n-      else\n-\tfatal_error (\"invalid addressing mode\");\n-\n-      fprintf (asm_out_file, \"\\t*(%d)=%s\\n\", offset + 31, reg_names[REGNO(operands[1]) + 1]);\n-    }\n-    else\n-    {\n-\txoperands[0] = XEXP(operands[0],0);\n-\txoperands[1] = operands[1];\n-\n-\toutput_asm_insn (\"*%0++=%u1\\n\\t*%0--=%w1\", xoperands);\n-    }\n-}\n-\n-void\n-override_options ()\n-{\n-  if (chip_name == (char *) 0)\n-    chip_name = DEFAULT_CHIP_NAME;\n-\n-  if (text_seg_name == (char *) 0)\n-    text_seg_name = DEFAULT_TEXT_SEG_NAME;\n-  \n-  if (data_seg_name == (char *) 0)\n-    data_seg_name = DEFAULT_DATA_SEG_NAME;\n-  \n-  if (bss_seg_name == (char *) 0)\n-    bss_seg_name = DEFAULT_BSS_SEG_NAME;\n-  \n-  if (const_seg_name == (char *) 0)\n-    const_seg_name = DEFAULT_CONST_SEG_NAME;\n-  \n-  save_chip_name = xstrdup (chip_name);\n-\n-  rsect_text = concat (\".rsect \\\"\", text_seg_name, \"\\\"\", NULL);\n-  rsect_data = concat (\".rsect \\\"\", data_seg_name, \"\\\"\", NULL);\n-  rsect_bss = concat (\".rsect \\\"\", bss_seg_name, \"\\\"\", NULL);\n-  rsect_const = concat (\".rsect \\\"\", const_seg_name, \"\\\"\", NULL);\n-}\n-\n-int\n-next_cc_user_unsigned (insn)\n-     rtx insn;\n-{\n-  switch (next_cc_user_code (insn))\n-    {\n-    case GTU:\n-    case GEU:\n-    case LTU:\n-    case LEU:\n-      return 1;\n-    default:\n-      return 0;\n-    }\n-}\n-\n-enum rtx_code\n-next_cc_user_code (insn)\n-     rtx insn;\n-{\n-  /* If no insn could be found we assume that the jump has been\n-     deleted and the compare will be deleted later.  */\n-\n-  if (!(insn = next_cc0_user (insn)))\n-    return (enum rtx_code) 0;\n-  else if (GET_CODE (insn) == JUMP_INSN\n-\t   && GET_CODE (PATTERN (insn)) == SET\n-\t   && GET_CODE (SET_SRC (PATTERN (insn))) == IF_THEN_ELSE)\n-    return GET_CODE (XEXP (SET_SRC (PATTERN (insn)), 0));\n-  else if (GET_CODE (insn) == INSN\n-\t   && GET_CODE (PATTERN (insn)) == SET\n-\t   && comparison_operator (SET_SRC (PATTERN (insn)), VOIDmode))\n-    return GET_CODE (SET_SRC (PATTERN (insn)));\n-  else\n-    abort ();\n-}\n-\n-void\n-print_operand(file, op, letter)\n-     FILE *file;\n-     rtx op;\n-     int letter;\n-{\n-    enum rtx_code code;\n-\n-    code = GET_CODE(op);\n-\n-    switch (letter)\n-    {\n-       case 'I':\n-\t  code = reverse_condition (code);\n-\t  /* Fallthrough */\n-\n-       case 'C':\n-          if (code == EQ) \n-          { \n-\t      fputs (\"eq\", file); \n-\t      return; \n-\t  }\n-          else if (code == NE)  \n-\t  { \n-\t      fputs (\"ne\", file); \n-\t      return; \n-\t  }\n-          else if (code == GT || code == GTU)  \n-\t  { \n-\t      fputs (\"gt\", file); \n-\t      return; \n-\t  }\n-          else if (code == LT || code == LTU)  \n-\t  { \n-\t      fputs (\"mi\", file); \n-\t      return; \n-\t  }\n-          else if (code == GE || code == GEU)  \n-\t  {\n-\t      fputs (\"pl\", file); \n-\t      return; \n-\t  }\n-          else if (code == LE || code == LEU)  \n-\t  { \n-\t      fputs (\"le\", file); \n-\t      return; \n-\t  }\n-          else \n-\t      abort ();\n-\t  break;\n-\n-       default:\n-          break;  \n-    }\n-\n-    if (code == REG)\n-    {\n-\t/* Print the low half of a 32-bit register pair.  */\n-        if (letter == 'w')\n-           fprintf (file, \"%s\", reg_names[REGNO (op) + 1]);\n-        else if (letter == 'u' || !letter)\n-           fprintf (file, \"%s\", reg_names[REGNO (op)]);\n-\telse if (letter == 'b')\n-\t    fprintf (file, \"%sh\", reg_names[REGNO (op)]);\n-\telse if (letter == 'm')\n-\t  fprintf (file, \"%s\", himode_reg_name[REGNO (op)]);\n-        else\n-\t  output_operand_lossage (\"bad register extension code\");\n-    }\n-    else if (code == MEM)\n-      output_address (XEXP(op,0));\n-    else if (code == CONST_INT)\n-      { \n-\tHOST_WIDE_INT val = INTVAL (op);\n-\n-        if (letter == 'H')\n-\t  fprintf (file, HOST_WIDE_INT_PRINT_HEX, val & 0xffff);\n-\telse if (letter == 'h')\n-\t  fprintf (file, HOST_WIDE_INT_PRINT_DEC, val);\n-        else if (letter == 'U')\n-\t  fprintf (file, HOST_WIDE_INT_PRINT_HEX, (val >> 16) & 0xffff);\n-        else\n-           output_addr_const(file, op);\n-      }\n-    else if (code == CONST_DOUBLE && GET_MODE(op) != DImode)\n-      {\n-\tlong l;\n-\tREAL_VALUE_TYPE r;\n-\tREAL_VALUE_FROM_CONST_DOUBLE (r, op);\n-\tREAL_VALUE_TO_TARGET_SINGLE (r, l);\n-\tfprintf (file, \"0x%lx\", l);\n-      }\n-    else if (code == CONST)\n-      {\n-\trtx addr = XEXP (op, 0);\n-\t\n-\tif (GET_CODE (addr) != PLUS)\n-\t  {\n-\t    output_addr_const(file, op);\n-\t    return;\n-\t  }\n-\t\n-\tif ((GET_CODE (XEXP (addr, 0)) == SYMBOL_REF\n-\t     || GET_CODE (XEXP (addr, 0)) == LABEL_REF)\n-\t    && (GET_CODE (XEXP (addr, 1)) == CONST_INT))\n-\t  {\n-\t    int n = INTVAL (XEXP(addr, 1));\n-\t    output_addr_const (file, XEXP (addr, 0));\n-\t    \n-\t    if (n >= 0)\n-\t      fprintf (file, \"+\");\n-\t    \n-\t    n = (int) (short) n;\n-\t    fprintf (file, \"%d\", n);\n-\t  }\n-\telse if ((GET_CODE (XEXP (addr, 1)) == SYMBOL_REF\n-\t\t  || GET_CODE (XEXP (addr, 1)) == LABEL_REF)\n-\t\t && (GET_CODE (XEXP (addr, 0)) == CONST_INT))\n-\t  {\n-\t    int n = INTVAL (XEXP(addr, 0));\n-\t    output_addr_const (file, XEXP (addr, 1));\n-\t    \n-\t    if (n >= 0)\n-\t      fprintf (file, \"+\");\n-\t    \n-\t    n = (int) (short) n;\n-\t    fprintf (file, \"%d\", n);\n-\t  }\n-\telse\n-\t  output_addr_const(file, op);\n-      }\n-    else\n-      output_addr_const (file, op);\n-}\n-\n-\n-void\n-print_operand_address(file, addr)\n-     FILE *file;\n-     rtx addr;\n-{\n-  rtx base;\n-  int offset = 0;;\n-  \n-  switch (GET_CODE (addr))\n-    {\n-    case REG:\n-      fprintf (file, \"*%s\", reg_names[REGNO (addr)]);\n-      break;\n-    case POST_DEC:\n-      fprintf (file, \"*%s--\", reg_names[REGNO (XEXP (addr, 0))]);\n-      break;\n-    case POST_INC:\n-      fprintf (file, \"*%s++\", reg_names[REGNO (XEXP (addr, 0))]);\n-      break;\n-    case PLUS:\n-      if (GET_CODE (XEXP(addr,0)) == CONST_INT)\n-\toffset = INTVAL(XEXP(addr,0)), base = XEXP(addr,1);\n-      else if (GET_CODE (XEXP(addr,1)) == CONST_INT)\n-\toffset = INTVAL(XEXP(addr,1)), base = XEXP(addr,0);\n-      else\n-\tabort();\n-      if (GET_CODE (base) == REG && REGNO(base) == STACK_POINTER_REGNUM)\n-\t{\n-\t  if (offset >= -31 && offset <= 0)\n-\t    offset = 31 + offset;\n-\t  else\n-\t    fatal_error (\"invalid offset in ybase addressing\");\n-\t}\n-      else\n-\tfatal_error (\"invalid register in ybase addressing\");\n-      \n-      fprintf (file, \"*(%d)\", offset);\n-      break;\n-      \n-    default:\n-      if (FITS_5_BITS (addr))\n-\tfprintf (file, \"*(0x%x)\", (int)(INTVAL (addr) & 0x20));\n-      else\n-\toutput_addr_const (file, addr);\n-    }\n-}\n-\n-void\n-output_dsp16xx_float_const (operands)\n-     rtx *operands;\n-{\n-  rtx src = operands[1];\n-  \n-  REAL_VALUE_TYPE d;\n-  long value;\n-  \n-  REAL_VALUE_FROM_CONST_DOUBLE (d, src);\n-  REAL_VALUE_TO_TARGET_SINGLE (d, value);\n-  \n-  operands[1] = GEN_INT (value);\n-  output_asm_insn (\"%u0=%U1\\n\\t%w0=%H1\", operands);\n-}\n-\n-static int\n-reg_save_size ()\n-{\n-  int reg_save_size = 0;\n-  int regno;\n-\n-  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-    if (dsp16xx_call_saved_register (regno))\n-      {\n-\treg_save_size += UNITS_PER_WORD;\n-      }\n-\n-  /* If the function makes calls we will save need to save the 'pr' register.  */\n-  if (current_frame_info.function_makes_calls)\n-    reg_save_size += 1;\n-\n-  return (reg_save_size);\n-}\n-\n-#if 0\n-int\n-dsp16xx_starting_frame_offset()\n-{\n-  int reg_save_size = 0;\n- int regno;\n- \n-  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-    if (dsp16xx_call_saved_register (regno))\n-      {\n-\treg_save_size += UNITS_PER_WORD;\n-      }\n-\n-  return (reg_save_size);\n-}\n-#endif\n-\n-int\n-initial_frame_pointer_offset()\n-{\n-  int offset = 0;\n-  \n-  offset = compute_frame_size (get_frame_size());\n-\n-#ifdef STACK_GROWS_DOWNWARD\n-  return (offset);\n-#else\n-  return (-offset);\n-#endif\n-}\n-\n-/* Generate the minimum number of 1600 core shift instructions\n-   to shift by 'shift_amount'.  */\n-\n-#if 0\n-void\n-emit_1600_core_shift (shift_op, operands, shift_amount, mode)\n-     enum rtx_code shift_op;\n-     rtx *operands;\n-     int shift_amount;\n-     enum machine_mode mode;\n-{\n-  int quotient;\n-  int i;\n-  int first_shift_emitted = 0;\n-  \n-  while (shift_amount != 0)\n-    {\n-      if (shift_amount/16)\n-\t{\n-\t  quotient = shift_amount/16;\n-\t  shift_amount = shift_amount - (quotient * 16);\n-\t  for (i = 0; i < quotient; i++)\n-\t    emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n-\t\t\t\t    gen_rtx (shift_op, mode, \n-\t\t\t\t\t     first_shift_emitted\n-\t\t\t\t\t     ? operands[0] : operands[1],\n-\t\t\t\t\t     GEN_INT (16))));\n-\t  first_shift_emitted = 1;\n-\t}\n-      else if (shift_amount/8)\n-\t{\n-\t  quotient = shift_amount/8;\n-\t  shift_amount = shift_amount - (quotient * 8);\n-\t  for (i = 0; i < quotient; i++)\n-\t    emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n-\t\t\t\t    gen_rtx (shift_op, mode, \n-\t\t\t\t\t     first_shift_emitted\n-\t\t\t\t\t     ? operands[0] : operands[1],\n-\t\t\t\t\t     GEN_INT (8))));\n-\t  first_shift_emitted = 1;\n-\t}\n-      else if (shift_amount/4)\n-\t{\n-\t  quotient = shift_amount/4;\n-\t  shift_amount = shift_amount - (quotient * 4);\n-\t  for (i = 0; i < quotient; i++)\n-\t    emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n-\t\t\t\t    gen_rtx (shift_op, mode, \n-\t\t\t\t\t     first_shift_emitted\n-\t\t\t\t\t     ? operands[0] : operands[1],\n-\t\t\t\t\t     GEN_INT (4))));\n-\t  first_shift_emitted = 1;\n-\t}\n-      else if (shift_amount/1)\n-\t{\n-\t  quotient = shift_amount/1;\n-\t  shift_amount = shift_amount - (quotient * 1);\n-\t  for (i = 0; i < quotient; i++)\n-\t    emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n-\t\t\t\t    gen_rtx (shift_op, mode, \n-\t\t\t\t\t     first_shift_emitted\n-\t\t\t\t\t     ? operands[0] : operands[1],\n-\t\t\t\t\t     GEN_INT (1))));\n-\t  first_shift_emitted = 1;\n-\t}\n-    }\n-}\n-#else\n-void\n-emit_1600_core_shift (shift_op, operands, shift_amount)\n-     enum rtx_code shift_op;\n-     rtx *operands;\n-     int shift_amount;\n-{\n-  int quotient;\n-  int i;\n-  int first_shift_emitted = 0;\n-  const char * const *shift_asm_ptr;\n-  const char * const *shift_asm_ptr_first;\n-\n-  if (shift_op == ASHIFT)\n-    {\n-      shift_asm_ptr = ashift_left_asm;\n-      shift_asm_ptr_first = ashift_left_asm_first;\n-    }\n-  else if (shift_op == ASHIFTRT)\n-    {\n-      shift_asm_ptr = ashift_right_asm;\n-      shift_asm_ptr_first = ashift_right_asm_first;\n-    }\n-  else if (shift_op == LSHIFTRT)\n-    {\n-      shift_asm_ptr = lshift_right_asm;\n-      shift_asm_ptr_first = lshift_right_asm_first;\n-    }\n-  else\n-    fatal_error (\"invalid shift operator in emit_1600_core_shift\");\n-\n-  while (shift_amount != 0)\n-    {\n-      if (shift_amount/16)\n-\t{\n-\t  quotient = shift_amount/16;\n-\t  shift_amount = shift_amount - (quotient * 16);\n-\t  for (i = 0; i < quotient; i++)\n-\t    output_asm_insn ((first_shift_emitted ? shift_asm_ptr[SHIFT_INDEX_16]\n-\t\t\t      : shift_asm_ptr_first[SHIFT_INDEX_16]), operands);\n-\t  first_shift_emitted = 1;\n-\t}\n-      else if (shift_amount/8)\n-\t{\n-\t  quotient = shift_amount/8;\n-\t  shift_amount = shift_amount - (quotient * 8);\n-\t  for (i = 0; i < quotient; i++)\n-\t    output_asm_insn ((first_shift_emitted ? shift_asm_ptr[SHIFT_INDEX_8]\n-\t\t\t      : shift_asm_ptr_first[SHIFT_INDEX_8]), operands);\n-\t  first_shift_emitted = 1;\n-\t}\n-      else if (shift_amount/4)\n-\t{\n-\t  quotient = shift_amount/4;\n-\t  shift_amount = shift_amount - (quotient * 4);\n-\t  for (i = 0; i < quotient; i++)\n-\t    output_asm_insn ((first_shift_emitted ? shift_asm_ptr[SHIFT_INDEX_4]\n-\t\t\t      : shift_asm_ptr_first[SHIFT_INDEX_4]), operands);\n-\t  first_shift_emitted = 1;\n-\t}\n-      else if (shift_amount/1)\n-\t{\n-\t  quotient = shift_amount/1;\n-\t  shift_amount = shift_amount - (quotient * 1);\n-\t  for (i = 0; i < quotient; i++)\n-\t    output_asm_insn ((first_shift_emitted ? shift_asm_ptr[SHIFT_INDEX_1]\n-\t\t\t      : shift_asm_ptr_first[SHIFT_INDEX_1]), operands);\n-\t  first_shift_emitted = 1;\n-\t}\n-    }\n-}\n-#endif\n-\n-int\n-num_1600_core_shifts (shift_amount)\n-int shift_amount;\n-{\n-  int quotient;\n-  int i;\n-  int first_shift_emitted = 0;\n-  int num_shifts = 0;\n-\n-  while (shift_amount != 0)\n-    {\n-      if (shift_amount/16)\n-\t{\n-\t  quotient = shift_amount/16;\n-\t  shift_amount = shift_amount - (quotient * 16);\n-\t  for (i = 0; i < quotient; i++)\n-\t    num_shifts++;\n-\t  first_shift_emitted = 1;\n-\t}\n-      else if (shift_amount/8)\n-\t{\n-\t  quotient = shift_amount/8;\n-\t  shift_amount = shift_amount - (quotient * 8);\n-\t  for (i = 0; i < quotient; i++)\n-\t    num_shifts++;\n-\n-\t  first_shift_emitted = 1;\n-\t}\n-      else if (shift_amount/4)\n-\t{\n-\t  quotient = shift_amount/4;\n-\t  shift_amount = shift_amount - (quotient * 4);\n-\t  for (i = 0; i < quotient; i++)\n-\t    num_shifts++;\n-\n-\t  first_shift_emitted = 1;\n-\t}\n-      else if (shift_amount/1)\n-\t{\n-\t  quotient = shift_amount/1;\n-\t  shift_amount = shift_amount - (quotient * 1);\n-\t  for (i = 0; i < quotient; i++)\n-\t    num_shifts++;\n-\n-\t  first_shift_emitted = 1;\n-\t}\n-    }\n-  return num_shifts;\n-}\n-\n-void\n-asm_output_common(file, name, size, rounded)\n-     FILE *file;\n-     const char *name;\n-     int size ATTRIBUTE_UNUSED;\n-     int rounded;\n-{\n-    bss_section ();\n-    (*targetm.asm_out.globalize_label) (file, name);\n-    assemble_name (file, name);\n-    fputs (\":\", file);\n-    if (rounded > 1)\n-\tfprintf (file, \"%d * int\\n\", rounded);\n-    else\n-\tfprintf (file, \"int\\n\");\n-}\n-\n-void\n-asm_output_local(file, name, size, rounded)\n-     FILE *file;\n-     const char *name;\n-     int size ATTRIBUTE_UNUSED;\n-     int rounded;\n-{\n-    bss_section ();\n-    assemble_name (file, name);\n-    fputs (\":\", file);\n-    if (rounded > 1)\n-\tfprintf (file, \"%d * int\\n\", rounded);\n-    else\n-\tfprintf (file, \"int\\n\");\n-}\n-\n-static int\n-dsp16xx_address_cost (addr)\n-     rtx addr;\n-{\n-    switch (GET_CODE (addr))\n-    {\n-\t  default:\n-\t     break;\n-\n-\t  case REG:\n-\t     return 1;\n-\n-\t  case CONST:\n-\t     {\n-\t        rtx offset = const0_rtx;\n-\t        addr = eliminate_constant_term (addr, &offset);\n-\n-\t        if (GET_CODE (addr) == LABEL_REF)\n-\t            return 2;\n-\n-\t        if (GET_CODE (addr) != SYMBOL_REF)\n-\t            return 4;\n-\n-\t        if (INTVAL (offset) == 0)\n-\t            return 2;\n-             }\n-\t     /* fall through */\n-\n-\t  case POST_INC: case POST_DEC:\n-\t     return (GET_MODE (addr) == QImode ? 1 : 2);\n-\n-\t  case SYMBOL_REF: case LABEL_REF:\n-\t     return 2;\n-\n-\t  case PLUS:\n-\t  {\n-\t     register rtx plus0 = XEXP (addr, 0);\n-\t     register rtx plus1 = XEXP (addr, 1);\n-\t     \n-\t     if (GET_CODE (plus0) != REG && GET_CODE (plus1) == REG)\n-\t     {\n-\t\t plus0 = XEXP (addr, 1);\n-\t\t plus1 = XEXP (addr, 0);\n-\t     }\n-\t     \n-\t     if (GET_CODE (plus0) != REG)\n-\t\t break;\n-\t     \n-\t     switch (GET_CODE (plus1))\n-\t     {\n-\t\t   default:\n-\t\t      break;\n-\t\t \n-\t\t   case CONST_INT:\n-\t\t      return 4;\n-\n-\t\t   case CONST:\n-\t\t   case SYMBOL_REF:\n-\t\t   case LABEL_REF:\n-\t\t      return dsp16xx_address_cost (plus1) + 1;\n-\t     }\n-\t  }\n-     }\n-\t     \n-     return 4;\n-}\n-\n-\f\n-/* Determine whether a function argument is passed in a register, and\n-   which register.\n-\n-   The arguments are CUM, which summarizes all the previous\n-   arguments; MODE, the machine mode of the argument; TYPE,\n-   the data type of the argument as a tree node or 0 if that is not known\n-   (which happens for C support library functions); and NAMED,\n-   which is 1 for an ordinary argument and 0 for nameless arguments that\n-   correspond to `...' in the called function's prototype.\n-\n-   The value of the expression should either be a `reg' RTX for the\n-   hard register in which to pass the argument, or zero to pass the\n-   argument on the stack.\n-\n-   On the dsp1610 the first four words of args are normally in registers\n-   and the rest are pushed. If we a long or on float mode, the argument\n-   must begin on an even register boundary\n-\n-   Note that FUNCTION_ARG and FUNCTION_INCOMING_ARG were different.\n-   For structures that are passed in memory, but could have been\n-   passed in registers, we first load the structure into the\n-   register, and then when the last argument is passed, we store\n-   the registers into the stack locations.  This fixes some bugs\n-   where GCC did not expect to have register arguments, followed.  */\n-\n-struct rtx_def *\n-dsp16xx_function_arg (args_so_far, mode, type, named)\n-     CUMULATIVE_ARGS args_so_far;\n-     enum machine_mode mode;\n-     tree type;\n-     int named;\n-{\n-  if (TARGET_REGPARM)\n-    {\n-      if ((args_so_far & 1) != 0\n-\t  && (mode == HImode || GET_MODE_CLASS(mode) == MODE_FLOAT))\n-\targs_so_far++;\n-\n-      if (type == void_type_node)\n-\treturn (struct rtx_def *) 0;\n-\n-      if (named && args_so_far < 4 && !MUST_PASS_IN_STACK (mode,type))\n-\treturn gen_rtx_REG (mode, args_so_far + FIRST_REG_FOR_FUNCTION_ARG);\n-      else\n-\treturn (struct rtx_def *) 0;\n-    }\n-  else\n-    return (struct rtx_def *) 0;\n-}\n-\n-/* Advance the argument to the next argument position.  */\n-\n-void\n-dsp16xx_function_arg_advance (cum, mode, type, named)\n-     CUMULATIVE_ARGS *cum;\t/* current arg information */\n-     enum machine_mode mode;\t/* current arg mode */\n-     tree type;\t\t\t/* type of the argument or 0 if lib support */\n-     int named ATTRIBUTE_UNUSED;/* whether or not the argument was named */\n-{\n-  if (TARGET_REGPARM)\n-    {\n-      if ((*cum & 1) != 0\n-\t  && (mode == HImode || GET_MODE_CLASS(mode) == MODE_FLOAT))\n-\t*cum += 1;\n-\n-      if (mode != BLKmode)\n-\t*cum += GET_MODE_SIZE (mode);\n-      else\n-\t*cum += int_size_in_bytes (type);\n-    }\n-}\n-\n-static void\n-dsp16xx_file_start ()\n-{\n-  fprintf (asm_out_file, \"#include <%s.h>\\n\", save_chip_name);\n-}\n-\n-rtx\n-gen_tst_reg (x)\n-     rtx x;\n-{\n-  enum machine_mode mode;\n-\n-  mode = GET_MODE (x);\n-\n-  if (mode == QImode)\n-    emit_insn (gen_rtx_PARALLEL\n-\t       (VOIDmode,\n-\t\tgen_rtvec (2, gen_rtx_SET (VOIDmode, cc0_rtx, x),\n-\t\t\t   gen_rtx_CLOBBER (VOIDmode,\n-\t\t\t\t\t    gen_rtx_SCRATCH (QImode)))));\n-  else if (mode == HImode)\n-    emit_insn (gen_rtx_SET (VOIDmode, cc0_rtx, x));\n-  else\n-    fatal_error (\"invalid mode for gen_tst_reg\");\n-\n-  return cc0_rtx;\n-}\n-\n-rtx\n-gen_compare_reg (code, x, y)\n-     enum rtx_code code;\n-     rtx x, y;\n-{\n-  enum machine_mode mode;\n-\n-  mode = GET_MODE (x);\n-  /* For floating point compare insns, a call is generated so don't\n-     do anything here.  */\n-\n-  if (GET_MODE_CLASS (mode) == MODE_FLOAT)\n-    return cc0_rtx;\n-\n-  if (mode == QImode)\n-    {\n-      if (code == GTU || code == GEU\n-\t  || code == LTU || code == LEU)\n-\t{\n-\t  emit_insn (gen_rtx_PARALLEL\n-\t\t     (VOIDmode,\n-\t\t      gen_rtvec (3,\n-\t\t\t\t gen_rtx_SET (VOIDmode, cc0_rtx,\n-\t\t\t\t\t      gen_rtx_COMPARE (mode, x, y)),\n-\t\t\t\t gen_rtx_CLOBBER (VOIDmode,\n-\t\t\t\t\t\t  gen_rtx_SCRATCH (QImode)),\n-\t\t\t\t gen_rtx_CLOBBER (VOIDmode,\n-\t\t\t\t\t\t  gen_rtx_SCRATCH (QImode)))));\n-\t}\n-      else\n-\t{\n-\t  emit_insn (gen_rtx_PARALLEL\n-\t\t     (VOIDmode,\n-\t\t      gen_rtvec (3, gen_rtx_SET (VOIDmode, cc0_rtx,\n-\t\t\t\t\t\t gen_rtx_COMPARE (mode, x, y)),\n-\t\t\t\t gen_rtx_CLOBBER (VOIDmode,\n-\t\t\t\t\t\t  gen_rtx_SCRATCH (QImode)),\n-\t\t\t\t gen_rtx_CLOBBER (VOIDmode,\n-\t\t\t\t\t\t  gen_rtx_SCRATCH (QImode)))));\n-\t}\n-    }\n-  else if (mode == HImode)\n-    {\n-      if (code == GTU || code == GEU\n-\t  || code == LTU || code == LEU)\n-\t{\n-\t  emit_insn (gen_rtx_PARALLEL \n-\t\t     (VOIDmode, \n-\t\t      gen_rtvec (5,\n-\t\t\t\t gen_rtx_SET (VOIDmode, cc0_rtx, \n-\t\t\t\t\t      gen_rtx_COMPARE (VOIDmode, x, y)),\n-\t\t\t\t gen_rtx_CLOBBER (VOIDmode, \n-\t\t\t\t\t\t  gen_rtx_SCRATCH (QImode)),\n-\t\t\t\t gen_rtx_CLOBBER (VOIDmode, \n-\t\t\t\t\t\t  gen_rtx_SCRATCH (QImode)),\n-\t\t\t\t gen_rtx_CLOBBER (VOIDmode, \n-\t\t\t\t\t\t  gen_rtx_SCRATCH (QImode)),\n-\t\t\t\t gen_rtx_CLOBBER (VOIDmode, \n-\t\t\t\t\t\t  gen_rtx_SCRATCH (QImode)))));\n-\t}\n-      else\n-\temit_insn (gen_rtx_SET (VOIDmode, cc0_rtx,\n-\t\t\t\tgen_rtx_COMPARE (VOIDmode,\n-\t\t\t\t\t\t force_reg (HImode, x), \n-\t\t\t\t\t\t force_reg (HImode,y))));\n-    }\n-  else\n-    fatal_error (\"invalid mode for integer comparison in gen_compare_reg\");\n-\n-  return cc0_rtx;\n-}\n-\n-const char *\n-output_block_move (operands)\n-     rtx operands[];\n-{\n-  int loop_count = INTVAL(operands[2]);\n-  rtx xoperands[4];\n-\n-  fprintf (asm_out_file, \"\\tdo %d {\\n\", loop_count);\n-  xoperands[0] = operands[4];\n-  xoperands[1] = operands[1];\n-  output_asm_insn (\"%0=*%1++\", xoperands);\n-\n-  xoperands[0] = operands[0];\n-  xoperands[1] = operands[4];\n-  output_asm_insn (\"*%0++=%1\", xoperands);\n-\n-  fprintf (asm_out_file, \"\\t}\\n\");\n-  return \"\";\n-}\n-\n-int\n-uns_comparison_operator (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  if (mode == VOIDmode || GET_MODE (op) == mode)\n-    {\n-      enum rtx_code code;\n-      \n-      code = GET_CODE(op);\n-\n-      if (code == LEU || code == LTU || code == GEU\n-\t  || code == GTU)\n-\t{\n-\t  return 1;\n-\t}\n-      else\n-\treturn 0;\n-    }\n-\n-  return 0;\n-}\n-\n-int\n-signed_comparison_operator (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  if (mode == VOIDmode || GET_MODE (op) == mode)\n-    {\n-      enum rtx_code code;\n-      \n-      code = GET_CODE(op);\n-\n-      if (!(code == LEU || code == LTU || code == GEU\n-\t  || code == GTU))\n-\t{\n-\t  return 1;\n-\t}\n-      else\n-\treturn 0;\n-    }\n-\n-  return 0;\n-}\n-\f\n-static bool\n-dsp16xx_rtx_costs (x, code, outer_code, total)\n-     rtx x;\n-     int code;\n-     int outer_code ATTRIBUTE_UNUSED;\n-     int *total;\n-{\n-  switch (code)\n-    {\n-    case CONST_INT:\n-      *total = (unsigned HOST_WIDE_INT) INTVAL (x) < 65536 ? 0 : 2;\n-      return true;\n-\n-    case LABEL_REF:\n-    case SYMBOL_REF:\n-    case CONST:\n-      *total = COSTS_N_INSNS (1);\n-      return true;\n-\n-    case CONST_DOUBLE:\n-      *total = COSTS_N_INSNS (2);\n-      return true;\n-\n-    case MEM:\n-      *total = COSTS_N_INSNS (GET_MODE (x) == QImode ? 2 : 4);\n-      return true;\n-\n-    case DIV:\n-    case MOD:\n-      *total = COSTS_N_INSNS (38);\n-      return true;\n-\n-    case MULT:\n-      if (GET_MODE (x) == QImode)\n-        *total = COSTS_N_INSNS (2);\n-      else\n-\t*total = COSTS_N_INSNS (38);\n-      return true;\n-\n-    case PLUS:\n-    case MINUS:\n-    case AND:\n-    case IOR:\n-    case XOR:\n-      if (GET_MODE_CLASS (GET_MODE (x)) == MODE_INT)\n-\t{\n-\t  *total = 1;\n-\t  return false;\n-\t}\n-      else\n-\t{\n-          *total = COSTS_N_INSNS (38);\n-\t  return true;\n-\t}\n-\n-    case NEG:\n-    case NOT:\n-      *total = COSTS_N_INSNS (1);\n-      return true;\n-\n-    case ASHIFT:\n-    case ASHIFTRT:\n-    case LSHIFTRT:\n-      if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n-\t{\n-\t  HOST_WIDE_INT number = INTVAL (XEXP (x, 1));\n-\t  if (number == 1 || number == 4 || number == 8\n-\t      || number == 16)\n-\t    *total = COSTS_N_INSNS (1);\n-\t  else if (TARGET_BMU)\n-            *total = COSTS_N_INSNS (2);\n-          else\n-            *total = COSTS_N_INSNS (num_1600_core_shifts (number));\n-\t  return true;\n-\t}\n-      break;\n-    }\n-\n-  if (TARGET_BMU)\n-    *total = COSTS_N_INSNS (1);\n-  else\n-    *total = COSTS_N_INSNS (15);\n-  return true;\n-}"}, {"sha": "cea995ca1044b53be6dc058b1558b6041591c298", "filename": "gcc/config/dsp16xx/dsp16xx.h", "status": "removed", "additions": 0, "deletions": 1767, "changes": 1767, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.h?ref=c3bf16ff7dec47581f450b1a486cfdf9d566927e", "patch": "@@ -1,1767 +0,0 @@\n-/* Definitions of target machine for GNU compiler.  AT&T DSP1600.\n-   Copyright (C) 1994, 1995, 1996, 1997, 1998, 2000, 2001, 2002, 2003\n-   Free Software Foundation, Inc.\n-   Contributed by Michael Collison (collison@isisinc.net).\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-extern const char *low_reg_names[];\n-extern const char *text_seg_name;\n-extern const char *rsect_text;\n-extern const char *data_seg_name;\n-extern const char *rsect_data;\n-extern const char *bss_seg_name;\n-extern const char *rsect_bss;\n-extern const char *const_seg_name;\n-extern const char *rsect_const;\n-extern const char *chip_name;\n-extern const char *save_chip_name;\n-extern GTY(()) rtx dsp16xx_compare_op0;\n-extern GTY(()) rtx dsp16xx_compare_op1;\n-extern GTY(()) rtx dsp16xx_addhf3_libcall;\n-extern GTY(()) rtx dsp16xx_subhf3_libcall;\n-extern GTY(()) rtx dsp16xx_mulhf3_libcall;\n-extern GTY(()) rtx dsp16xx_divhf3_libcall;\n-extern GTY(()) rtx dsp16xx_cmphf3_libcall;\n-extern GTY(()) rtx dsp16xx_fixhfhi2_libcall;\n-extern GTY(()) rtx dsp16xx_floathihf2_libcall;\n-extern GTY(()) rtx dsp16xx_neghf2_libcall;\n-extern GTY(()) rtx dsp16xx_mulhi3_libcall;\n-extern GTY(()) rtx dsp16xx_udivqi3_libcall;\n-extern GTY(()) rtx dsp16xx_udivhi3_libcall;\n-extern GTY(()) rtx dsp16xx_divqi3_libcall;\n-extern GTY(()) rtx dsp16xx_divhi3_libcall;\n-extern GTY(()) rtx dsp16xx_modqi3_libcall;\n-extern GTY(()) rtx dsp16xx_modhi3_libcall;\n-extern GTY(()) rtx dsp16xx_umodqi3_libcall;\n-extern GTY(()) rtx dsp16xx_umodhi3_libcall;\n-\n-extern GTY(()) rtx dsp16xx_ashrhi3_libcall;\n-extern GTY(()) rtx dsp16xx_ashlhi3_libcall;\n-extern GTY(()) rtx dsp16xx_lshrhi3_libcall;\n-\n-/* RUN-TIME TARGET SPECIFICATION */\n-#define DSP16XX   1\n-\n-/* Name of the AT&T assembler */\n-\n-#define ASM_PROG \"as1600\"\n-\n-/* Name of the AT&T linker */\n-\n-#define LD_PROG \"ld1600\"\n-\n-/* Define which switches take word arguments */\n-#define WORD_SWITCH_TAKES_ARG(STR)              \\\n-  (!strcmp (STR, \"ifile\") ? 1 :                 \\\n-   0)\n-\n-#undef  CC1_SPEC\n-#define CC1_SPEC       \"%{!O*:-O}\"\n-\n-/* Define this as a spec to call the AT&T assembler */\n-\n-#define CROSS_ASM_SPEC   \"%{!S:as1600 %a %i\\n }\"\n-\n-/* Define this as a spec to call the AT&T linker */\n-\n-#define CROSS_LINK_SPEC  \"%{!c:%{!M:%{!MM:%{!E:%{!S:ld1600 %l %X %{o*} %{m} \\\n-\t\t\t%{r} %{s} %{t} %{u*} %{x}\\\n-\t\t\t%{!A:%{!nostdlib:%{!nostartfiles:%S}}} %{static:}\\\n-\t\t\t%{L*} %D %o %{!nostdlib:-le1600 %L -le1600}\\\n-\t\t\t%{!A:%{!nostdlib:%{!nostartfiles:%E}}}\\n }}}}}\"\n-\n-/* Nothing complicated here, just link with libc.a under normal\n-   circumstances */\n-#define LIB_SPEC \"-lc\"\n-\n-/* Specify the startup file to link with.  */\n-#define STARTFILE_SPEC \"%{mmap1:m1_crt0.o%s}  \\\n-%{mmap2:m2_crt0.o%s}                          \\\n-%{mmap3:m3_crt0.o%s}                          \\\n-%{mmap4:m4_crt0.o%s}                          \\\n-%{!mmap*: %{!ifile*: m4_crt0.o%s} %{ifile*:     \\\n-%ea -ifile option requires a -map option}}\"\n-\n-/* Specify the end file to link with */\n-\n-#define ENDFILE_SPEC \"%{mmap1:m1_crtn.o%s}  \\\n-%{mmap2:m2_crtn.o%s}                          \\\n-%{mmap3:m3_crtn.o%s}                          \\\n-%{mmap4:m4_crtn.o%s}                          \\\n-%{!mmap*: %{!ifile*: m4_crtn.o%s} %{ifile*:     \\\n-%ea -ifile option requires a -map option}}\"\n-\n-\n-/* Tell gcc where to look for the startfile */\n-/*#define STANDARD_STARTFILE_PREFIX   \"/d1600/lib\"*/\n-\n-/* Tell gcc where to look for it's executables */\n-/*#define STANDARD_EXEC_PREFIX  \"/d1600/bin\"*/\n-\n-/* Command line options to the AT&T assembler */\n-#define ASM_SPEC  \"%{V} %{v:%{!V:-V}} %{g*:-g}\"\n-\n-/* Command line options for the AT&T linker */\n-\n-#define LINK_SPEC \"%{V} %{v:%{!V:-V}} %{minit:-i}  \\\n-%{!ifile*:%{mmap1:m1_deflt.if%s}         \\\n-          %{mmap2:m2_deflt.if%s}         \\\n-          %{mmap3:m3_deflt.if%s}         \\\n-          %{mmap4:m4_deflt.if%s}         \\\n-          %{!mmap*:m4_deflt.if%s}}       \\\n-%{ifile*:%*} %{r}\"\n-\n-/* Include path is determined from the environment variable */\n-#define INCLUDE_DEFAULTS     \\\n-{                            \\\n-  { 0, 0, 0, 0, 0 }          \\\n-}\n-\n-/* Names to predefine in the preprocessor for this target machine.  */\n-#define TARGET_CPU_CPP_BUILTINS()\t\t\\\n-  do\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\\\n-      builtin_define_std (\"dsp1600\");\t\t\\\n-      builtin_define_std (\"DSP1600\");\t\t\\\n-    }\t\t\t\t\t\t\\\n-  while (0)\n-\n-#ifdef __MSDOS__\n-# define TARGET_OS_CPP_BUILTINS()\t\t\\\n-  do\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\\\n-      builtin_define_std (\"MSDOS\");\t\t\\\n-    }\t\t\t\t\t\t\\\n-  while (0)\n-#else\n-# define TARGET_OS_CPP_BUILTINS()\t\t\\\n-  do\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\\\n-      builtin_define_std (\"dsp1610\");\t\t\\\n-      builtin_define_std (\"DSP1610\");\t\t\\\n-    }\t\t\t\t\t\t\\\n-  while (0)\n-#endif\n-\n-/* Run-time compilation parameters selecting different hardware subsets.  */\n-\n-extern int target_flags;\n-\n-/* Macros used in the machine description to test the flags.  */\n-\n-#define MASK_REGPARM         0x00000001    /* Pass parameters in registers */\n-#define MASK_NEAR_CALL       0x00000002    /* The call is on the same 4k page */\n-#define MASK_NEAR_JUMP       0x00000004    /* The jump is on the same 4k page */\n-#define MASK_BMU             0x00000008    /* Use the 'bmu' shift instructions */\n-#define MASK_MAP1            0x00000040    /* Link with map1 */\n-#define MASK_MAP2            0x00000080    /* Link with map2 */\n-#define MASK_MAP3            0x00000100    /* Link with map3 */\n-#define MASK_MAP4            0x00000200    /* Link with map4 */\n-#define MASK_YBASE_HIGH      0x00000400    /* The ybase register window starts high */\n-#define MASK_INIT\t     0x00000800    /* Have the linker generate tables to\n-\t\t\t\t\t      initialize data at startup */\n-#define MASK_RESERVE_YBASE   0x00002000    /* Reserved the ybase registers */\n-#define MASK_DEBUG           0x00004000\t   /* Debugging turned on*/\n-#define MASK_SAVE_TEMPS      0x00008000    /* Save temps. option seen */\n-\n-/* Compile passing first two args in regs 0 and 1.\n-   This exists only to test compiler features that will\n-   be needed for RISC chips.  It is not usable\n-   and is not intended to be usable on this cpu.  */\n-#define TARGET_REGPARM   (target_flags & MASK_REGPARM)\n-\n-/* The call is on the same 4k page, so instead of loading\n-   the 'pt' register and branching, we can branch directly */\n-\n-#define TARGET_NEAR_CALL (target_flags & MASK_NEAR_CALL)\n-\n-/* The jump is on the same 4k page, so instead of loading\n-   the 'pt' register and branching, we can branch directly */\n-\n-#define TARGET_NEAR_JUMP (target_flags & MASK_NEAR_JUMP)\n-\n-/* Generate shift instructions to use the 1610 Bit Manipulation\n-   Unit.  */\n-#define TARGET_BMU (target_flags & MASK_BMU)\n-\n-#define TARGET_YBASE_HIGH (target_flags & MASK_YBASE_HIGH)\n-\n-/* Direct the linker to output extra info for initialized data */\n-#define TARGET_MASK_INIT (target_flags & MASK_INIT)\n-\n-#define TARGET_INLINE_MULT (target_flags & MASK_INLINE_MULT)\n-\n-/* Reserve the ybase registers *(0) - *(31) */\n-#define TARGET_RESERVE_YBASE (target_flags & MASK_RESERVE_YBASE)\n-\n-/* We turn this option on internally after seeing \"-g\" */\n-#define TARGET_DEBUG            (target_flags & MASK_DEBUG)\n-\n-/* We turn this option on internally after seeing \"-save-temps */\n-#define TARGET_SAVE_TEMPS       (target_flags & MASK_SAVE_TEMPS)\n-\n-\n-/* Macro to define tables used to set the flags.\n-   This is a list in braces of pairs in braces,\n-   each pair being { \"NAME\", VALUE }\n-   where VALUE is the bits to set or minus the bits to clear.\n-   An empty string NAME is used to identify the default VALUE.  */\n-\n-\n-#define TARGET_SWITCHES                                           \\\n-  {\t\t\t\t                                  \\\n-    { \"regparm\",       MASK_REGPARM,                              \\\n-      N_(\"Pass parameters in registers (default)\") },             \\\n-    { \"no-regparm\",   -MASK_REGPARM,\t                          \\\n-      N_(\"Don't pass parameters in registers\") },                 \\\n-    { \"near-call\",     MASK_NEAR_JUMP,                            \\\n-      N_(\"Generate code for near calls\") },                       \\\n-    { \"no-near-call\", -MASK_NEAR_CALL,                            \\\n-      N_(\"Don't generate code for near calls\") },                 \\\n-    { \"near-jump\",     MASK_NEAR_JUMP,                            \\\n-      N_(\"Generate code for near jumps\") },                       \\\n-    { \"no-near-jump\", -MASK_NEAR_JUMP,                            \\\n-      N_(\"Don't generate code for near jumps\") },                 \\\n-    { \"bmu\",           MASK_BMU,                                  \\\n-      N_(\"Generate code for a bit-manipulation unit\") },          \\\n-    { \"no-bmu\",       -MASK_BMU,                                  \\\n-      N_(\"Don't generate code for a bit-manipulation unit\") },    \\\n-    { \"map1\",          MASK_MAP1,                                 \\\n-      N_(\"Generate code for memory map1\") },                      \\\n-    { \"map2\",          MASK_MAP2,                                 \\\n-      N_(\"Generate code for memory map2\") },                      \\\n-    { \"map3\",          MASK_MAP3,                                 \\\n-      N_(\"Generate code for memory map3\") },                      \\\n-    { \"map4\",          MASK_MAP4,                                 \\\n-      N_(\"Generate code for memory map4\") },                      \\\n-    { \"init\",          MASK_INIT,                                 \\\n-      N_(\"Ouput extra code for initialized data\") },              \\\n-    { \"reserve-ybase\", MASK_RESERVE_YBASE,                        \\\n-      N_(\"Don't let reg. allocator use ybase registers\") },       \\\n-    { \"debug\",         MASK_DEBUG,                                \\\n-      N_(\"Output extra debug info in Luxworks environment\") },    \\\n-    { \"save-temporaries\",    MASK_SAVE_TEMPS,                     \\\n-      N_(\"Save temp. files in Luxworks environment\") },           \\\n-    { \"\",              TARGET_DEFAULT, \"\"}                        \\\n-  }\n-\n-/* Default target_flags if no switches are specified */\n-#ifndef TARGET_DEFAULT\n-#define TARGET_DEFAULT  MASK_REGPARM|MASK_YBASE_HIGH\n-#endif\n-\n-#define TARGET_OPTIONS\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-  { \"text=\",\t&text_seg_name,\t\t\t\t        \\\n-    N_(\"Specify alternate name for text section\"), 0},          \\\n-  { \"data=\",\t&data_seg_name,\t\t\t\t        \\\n-    N_(\"Specify alternate name for data section\"), 0},          \\\n-  { \"bss=\",\t&bss_seg_name,\t\t\t\t        \\\n-    N_(\"Specify alternate name for bss section\"), 0},           \\\n-  { \"const=\",   &const_seg_name,                                \\\n-    N_(\"Specify alternate name for constant section\"), 0},      \\\n-  { \"chip=\",    &chip_name,                                     \\\n-    N_(\"Specify alternate name for dsp16xx chip\"), 0},          \\\n-}\n-\n-/* Sometimes certain combinations of command options do not make sense\n-   on a particular target machine.  You can define a macro\n-   `OVERRIDE_OPTIONS' to take account of this.  This macro, if\n-   defined, is executed once just after all the command options have\n-   been parsed.\n-  \n-   Don't use this macro to turn on various extra optimizations for\n-   `-O'.  That is what `OPTIMIZATION_OPTIONS' is for.  */\n-\n-#define OVERRIDE_OPTIONS override_options ()\n-\n-#define OPTIMIZATION_OPTIONS(LEVEL,SIZE)              \\\n-{                                                     \\\n-    if (LEVEL >= 2)                                   \\\n-    {                                                 \\\n-        /* The dsp16xx family has so few registers    \\\n-         * that running the first instruction         \\\n-         * scheduling is bad for reg. allocation      \\\n-         * since it increases lifetimes of pseudos.   \\\n-         * So turn of first scheduling pass.          \\\n-         */                                           \\\n-        flag_schedule_insns          = FALSE;         \\\n-    }                                                 \\\n-}\n-\f\n-/* STORAGE LAYOUT */\n-\n-/* Define this if most significant bit is lowest numbered\n-   in instructions that operate on numbered bit-fields.\n- */\n-#define BITS_BIG_ENDIAN  0\n-\n-/* Define this if most significant byte of a word is the lowest numbered.\n-   We define big-endian, but since the 1600 series cannot address bytes\n-   it does not matter.  */\n-#define BYTES_BIG_ENDIAN 1\n-\n-/* Define this if most significant word of a multiword number is numbered.\n-   For the 1600 we can decide arbitrarily since there are no machine instructions for them.  */\n-#define WORDS_BIG_ENDIAN 1\n-\n-/* number of bits in an addressable storage unit */\n-#define BITS_PER_UNIT 16\n-\n-/* Maximum number of bits in a word.  */\n-#define MAX_BITS_PER_WORD 16\n-\n-/* Width of a word, in units (bytes).  */\n-#define UNITS_PER_WORD 1\n-\n-/* Allocation boundary (in *bits*) for storing pointers in memory.  */\n-#define POINTER_BOUNDARY 16\n-\n-/* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n-#define PARM_BOUNDARY 16\n-\n-/* Boundary (in *bits*) on which stack pointer should be aligned.  */\n-#define STACK_BOUNDARY 16\n-\n-/* Allocation boundary (in *bits*) for the code of a function.  */\n-#define FUNCTION_BOUNDARY 16\n-\n-/* Biggest alignment that any data type can require on this machine, in bits.  */\n-#define BIGGEST_ALIGNMENT 16\n-\n-/* Biggest alignment that any structure field can require on this machine, in bits */\n-#define BIGGEST_FIELD_ALIGNMENT 16\n-\n-/* Alignment of field after `int : 0' in a structure.  */\n-#define EMPTY_FIELD_BOUNDARY 16\n-\n-/* Number of bits which any structure or union's size must be a multiple of. Each structure\n-   or union's size is rounded up to a multiple of this */\n-#define STRUCTURE_SIZE_BOUNDARY 16\n-\n-/* Define this if move instructions will actually fail to work\n-   when given unaligned data.  */\n-#define STRICT_ALIGNMENT  1\n-\n-/* An integer expression for the size in bits of the largest integer machine mode that\n-   should actually be used. All integer machine modes of this size or smaller can be\n-   used for structures and unions with the appropriate sizes.  */\n-#define MAX_FIXED_MODE_SIZE 32\n-\f\n-/* LAYOUT OF SOURCE LANGUAGE DATA TYPES */\n-\n-#define SHORT_TYPE_SIZE        16\n-#define INT_TYPE_SIZE          16\n-#define LONG_TYPE_SIZE         32\n-#define LONG_LONG_TYPE_SIZE    32\n-#define FLOAT_TYPE_SIZE        32\n-#define DOUBLE_TYPE_SIZE       32\n-#define LONG_DOUBLE_TYPE_SIZE  32\n-\n-/* An expression whose value is 1 or 0, according to whether the type char should be\n-   signed or unsigned by default.  */\n-\n-#define DEFAULT_SIGNED_CHAR 1\n-\n-/* A C expression to determine whether to give an enum type only as many bytes\n-   as it takes to represent the range of possible values of that type. A nonzero\n-   value means to do that; a zero value means all enum types should be allocated\n-   like int.  */\n-\n-#define DEFAULT_SHORT_ENUMS 0\n-\n-/* A C expression for a string describing the name of the data type to use for\n-   size values.  */\n-\n-#define SIZE_TYPE    \"unsigned int\"\n-\n-/* A C expression for a string describing the name of the data type to use for the\n-   result of subtracting two pointers */\n-\n-#define PTRDIFF_TYPE \"int\"\n-\n-\f\n-/* REGISTER USAGE.  */\n-\n-#define ALL_16_BIT_REGISTERS  1\n-\n-/* Number of actual hardware registers.\n-   The hardware registers are assigned numbers for the compiler\n-   from 0 to FIRST_PSEUDO_REGISTER-1 */\n-\n-#define FIRST_PSEUDO_REGISTER (REG_YBASE31 + 1)\n-\n-/* 1 for registers that have pervasive standard uses\n-   and are not available for the register allocator.\n-\n-   The registers are laid out as follows:\n-\n-   {a0,a0l,a1,a1l,x,y,yl,p,pl} - Data Arithmetic Unit\n-   {r0,r1,r2,r3,j,k,ybase} - Y Space Address Arithmetic Unit\n-   {pt} - X Space Address Arithmetic Unit\n-   {ar0,ar1,ar2,ar3} - Bit Manipulation UNit\n-   {pr} - Return Address Register\n-\n-   We reserve r2 for the Stack Pointer.\n-   We specify r3 for the Frame Pointer but allow the compiler\n-   to omit it when possible since we have so few pointer registers.  */\n-\n-#define REG_A0     0\n-#define REG_A0L    1\n-#define REG_A1     2\n-#define REG_A1L    3 \n-#define REG_X      4\n-#define REG_Y      5\n-#define REG_YL     6\n-#define REG_PROD   7\n-#define REG_PRODL  8\n-#define REG_R0     9\n-#define REG_R1     10\n-#define REG_R2     11\n-#define REG_R3     12\n-#define REG_J      13\n-#define REG_K      14\n-#define REG_YBASE  15\n-#define REG_PT     16\n-#define REG_AR0    17\n-#define REG_AR1    18\n-#define REG_AR2    19\n-#define REG_AR3    20\n-#define REG_C0     21\n-#define REG_C1     22\n-#define REG_C2     23\n-#define REG_PR     24\n-#define REG_RB     25\n-#define REG_YBASE0 26\n-#define REG_YBASE1 27\n-#define REG_YBASE2 28\n-#define REG_YBASE3 29\n-#define REG_YBASE4 30\n-#define REG_YBASE5 31\n-#define REG_YBASE6 32\n-#define REG_YBASE7 33\n-#define REG_YBASE8 34\n-#define REG_YBASE9 35\n-#define REG_YBASE10 36\n-#define REG_YBASE11 37\n-#define REG_YBASE12 38\n-#define REG_YBASE13 39\n-#define REG_YBASE14 40\n-#define REG_YBASE15 41\n-#define REG_YBASE16 42\n-#define REG_YBASE17 43\n-#define REG_YBASE18 44\n-#define REG_YBASE19 45\n-#define REG_YBASE20 46\n-#define REG_YBASE21 47\n-#define REG_YBASE22 48\n-#define REG_YBASE23 49\n-#define REG_YBASE24 50\n-#define REG_YBASE25 51\n-#define REG_YBASE26 52\n-#define REG_YBASE27 53\n-#define REG_YBASE28 54\n-#define REG_YBASE29 55\n-#define REG_YBASE30 56\n-#define REG_YBASE31 57\n-\n-/* Do we have an accumulator register? */\n-#define IS_ACCUM_REG(REGNO) IN_RANGE ((REGNO), REG_A0, REG_A1L)\n-#define IS_ACCUM_LOW_REG(REGNO) ((REGNO) == REG_A0L || (REGNO) == REG_A1L)\n-\n-/* Do we have a virtual ybase register */\n-#define IS_YBASE_REGISTER_WINDOW(REGNO) ((REGNO) >= REG_YBASE0 && (REGNO) <= REG_YBASE31)\n-\n-#define IS_YBASE_ELIGIBLE_REG(REGNO) (IS_ACCUM_REG (REGNO) || IS_ADDRESS_REGISTER(REGNO) \\\n-                                      || REGNO == REG_X || REGNO == REG_Y || REGNO == REG_YL \\\n-                                      || REGNO == REG_PROD || REGNO == REG_PRODL)\n-\n-#define IS_ADDRESS_REGISTER(REGNO) ((REGNO) >= REG_R0 && (REGNO) <= REG_R3)\n-\n-#define FIXED_REGISTERS     \\\n-{0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n- 0, 0, 0, 1, 0, 0, 1,       \\\n- 1,                         \\\n- 0, 0, 0, 0,                \\\n- 1, 1, 1,                   \\\n- 1, 0,                      \\\n- 0, 0, 0, 0, 0, 0, 0, 0,    \\\n- 0, 0, 0, 0, 0, 0, 0, 0,    \\\n- 0, 0, 0, 0, 0, 0, 0, 0,    \\\n- 0, 0, 0, 0, 0, 0, 0, 0}\n-\n-/* 1 for registers not available across function calls.\n-   These must include the FIXED_REGISTERS and also any\n-   registers that can be used without being saved.\n-   The latter must include the registers where values are returned\n-   and the register where structure-value addresses are passed.\n-   On the 1610 'a0' holds return values from functions. 'r0' holds\n-   structure-value addresses.\n-\n-   In addition we don't save either j, k, ybase or any of the\n-   bit manipulation registers.  */\n-\n-\n-#define CALL_USED_REGISTERS\t\t\t\\\n-{1, 1, 1, 1, 0, 1, 1, 1, 1,\t/* 0-8 */\t\\\n- 1, 0, 0, 1, 1, 1, 1,\t\t/* 9-15 */\t\\\n- 1,                             /* 16 */\t\\\n- 0, 0, 1, 1,\t\t\t/* 17-20 */\t\\\n- 1, 1, 1,\t\t\t/* 21-23 */\t\\\n- 1, 1,\t\t\t\t/* 24-25 */\t\\\n- 0, 0, 0, 0, 0, 0, 0, 0,\t/* 26-33 */\t\\\n- 0, 0, 0, 0, 0, 0, 0, 0,\t/* 34-41 */\t\\\n- 0, 0, 0, 0, 0, 0, 0, 0,\t/* 42-49 */\t\\\n- 0, 0, 0, 0, 0, 0, 0, 0}\t/* 50-57 */\n-\n-/* List the order in which to allocate registers.  Each register must be\n-   listed once, even those in FIXED_REGISTERS.\n-\n-   We allocate in the following order:\n- */\n-\n-#if 0\n-#define REG_ALLOC_ORDER\t\t\t\t\t\\\n-{ REG_R0, REG_R1, REG_R2, REG_PROD, REG_Y, REG_X,       \\\n-  REG_PRODL, REG_YL, REG_AR0, REG_AR1,                  \\\n-  REG_RB, REG_A0, REG_A1, REG_A0L,                      \\\n-  REG_A1L, REG_AR2, REG_AR3,                            \\\n-  REG_YBASE, REG_J, REG_K, REG_PR, REG_PT, REG_C0,      \\\n-  REG_C1, REG_C2, REG_R3,\t\t\t\t\\\n-  REG_YBASE0, REG_YBASE1, REG_YBASE2, REG_YBASE3,       \\\n-  REG_YBASE4, REG_YBASE5, REG_YBASE6, REG_YBASE7,       \\\n-  REG_YBASE8, REG_YBASE9, REG_YBASE10, REG_YBASE11,     \\\n-  REG_YBASE12, REG_YBASE13, REG_YBASE14, REG_YBASE15,   \\\n-  REG_YBASE16, REG_YBASE17, REG_YBASE18, REG_YBASE19,   \\\n-  REG_YBASE20, REG_YBASE21, REG_YBASE22, REG_YBASE23,   \\\n-  REG_YBASE24, REG_YBASE25, REG_YBASE26, REG_YBASE27,   \\\n-  REG_YBASE28, REG_YBASE29, REG_YBASE30, REG_YBASE31 }\n-#else\n-#define REG_ALLOC_ORDER                                 \\\n-{                                                       \\\n-  REG_A0, REG_A0L, REG_A1, REG_A1L, REG_Y, REG_YL,      \\\n-  REG_PROD,                                             \\\n-  REG_PRODL, REG_R0, REG_J, REG_K, REG_AR2, REG_AR3,    \\\n-  REG_X, REG_R1, REG_R2, REG_RB, REG_AR0, REG_AR1,      \\\n-  REG_YBASE0, REG_YBASE1, REG_YBASE2, REG_YBASE3,       \\\n-  REG_YBASE4, REG_YBASE5, REG_YBASE6, REG_YBASE7,       \\\n-  REG_YBASE8, REG_YBASE9, REG_YBASE10, REG_YBASE11,     \\\n-  REG_YBASE12, REG_YBASE13, REG_YBASE14, REG_YBASE15,   \\\n-  REG_YBASE16, REG_YBASE17, REG_YBASE18, REG_YBASE19,   \\\n-  REG_YBASE20, REG_YBASE21, REG_YBASE22, REG_YBASE23,   \\\n-  REG_YBASE24, REG_YBASE25, REG_YBASE26, REG_YBASE27,   \\\n-  REG_YBASE28, REG_YBASE29, REG_YBASE30, REG_YBASE31,   \\\n-  REG_R3, REG_YBASE, REG_PT, REG_C0, REG_C1, REG_C2,    \\\n-  REG_PR }\n-#endif\n-/* Zero or more C statements that may conditionally modify two\n-   variables `fixed_regs' and `call_used_regs' (both of type `char\n-   []') after they have been initialized from the two preceding\n-   macros.\n-\n-   This is necessary in case the fixed or call-clobbered registers\n-   depend on target flags.\n-\n-   You need not define this macro if it has no work to do.\n-\n-   If the usage of an entire class of registers depends on the target\n-   flags, you may indicate this to GCC by using this macro to modify\n-   `fixed_regs' and `call_used_regs' to 1 for each of the registers in\n-   the classes which should not be used by GCC.  Also define the macro\n-   `REG_CLASS_FROM_LETTER' to return `NO_REGS' if it is called with a\n-   letter for a class that shouldn't be used.\n-\n-   (However, if this class is not included in `GENERAL_REGS' and all\n-   of the insn patterns whose constraints permit this class are\n-   controlled by target switches, then GCC will automatically avoid\n-   using these registers when the target switches are opposed to\n-   them.)  If the user tells us there is no BMU, we can't use\n-   ar0-ar3 for register allocation */\n-\n-#define CONDITIONAL_REGISTER_USAGE\t\t\t\t\t\\\n-do\t\t\t\t\t\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\t\\\n-    if (!TARGET_BMU)\t\t\t\t\t\t        \\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tint regno;\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\tfor (regno = REG_AR0; regno <= REG_AR3; regno++)\t        \\\n-\t  fixed_regs[regno] = call_used_regs[regno] = 1;\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    if (TARGET_RESERVE_YBASE)\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tint regno;\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-\tfor (regno = REG_YBASE0; regno <= REG_YBASE31; regno++)\t        \\\n-\t  fixed_regs[regno] = call_used_regs[regno] = 1;\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-  }\t\t\t\t\t\t\t\t\t\\\n-while (0)\n-\n-/* Determine which register classes are very likely used by spill registers.\n-   local-alloc.c won't allocate pseudos that have these classes as their\n-   preferred class unless they are \"preferred or nothing\".  */\n-\n-#define CLASS_LIKELY_SPILLED_P(CLASS) \\\n- ((CLASS) != ALL_REGS && (CLASS) != YBASE_VIRT_REGS)\n-\n-/* Return number of consecutive hard regs needed starting at reg REGNO\n-   to hold something of mode MODE.\n-   This is ordinarily the length in words of a value of mode MODE\n-   but can be less for certain modes in special long registers.  */\n-\n-#define HARD_REGNO_NREGS(REGNO, MODE)                                 \\\n-  (GET_MODE_SIZE(MODE))\n-\n-/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.  */\n-\n-#define HARD_REGNO_MODE_OK(REGNO, MODE) hard_regno_mode_ok(REGNO, MODE)\n-\n-/* Value is 1 if it is a good idea to tie two pseudo registers\n-   when one has mode MODE1 and one has mode MODE2.\n-   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n-   for any hard reg, then this must be 0 for correct output.  */\n-#define MODES_TIEABLE_P(MODE1, MODE2)\t\t     \\\n-  (((MODE1) == (MODE2)) ||                           \\\n-   (GET_MODE_CLASS((MODE1)) == MODE_FLOAT)           \\\n-    == (GET_MODE_CLASS((MODE2)) == MODE_FLOAT))\n-\n-/* Specify the registers used for certain standard purposes.\n-   The values of these macros are register numbers.  */\n-\n-/* DSP1600 pc isn't overloaded on a register.  */\n-/* #define PC_REGNUM  */\n-\n-/* Register to use for pushing function arguments.  \n-   This is r3 in our case */\n-#define STACK_POINTER_REGNUM  REG_R3\n-\n-/* Base register for access to local variables of the function.\n-   This is r2 in our case   */\n-#define FRAME_POINTER_REGNUM  REG_R2\n-\n-/* We can debug without the frame pointer */\n-#define CAN_DEBUG_WITHOUT_FP 1\n-\n-/* The 1610 saves the return address in this register */\n-#define RETURN_ADDRESS_REGNUM REG_PR\n-\n-/* Base register for access to arguments of the function.  */\n-#define ARG_POINTER_REGNUM FRAME_POINTER_REGNUM\n-\n-/* Register in which static-chain is passed to a function.  */\n-\n-#define STATIC_CHAIN_REGNUM 4\n-\n-/* Register in which address to store a structure value\n-   is passed to a function.  This is 'r0' in our case */\n-#define STRUCT_VALUE_REGNUM   REG_R0\n-\f\n-/* Define the classes of registers for register constraints in the\n-   machine description.  Also define ranges of constants.\n-\n-   One of the classes must always be named ALL_REGS and include all hard regs.\n-   If there is more than one class, another class must be named NO_REGS\n-   and contain no registers.\n-\n-   The name GENERAL_REGS must be the name of a class (or an alias for\n-   another name such as ALL_REGS).  This is the class of registers\n-   that is allowed by \"g\" or \"r\" in a register constraint.\n-   Also, registers outside this class are allocated only when\n-   instructions express preferences for them.\n-\n-   The classes must be numbered in nondecreasing order; that is,\n-   a larger-numbered class must never be contained completely\n-   in a smaller-numbered class.\n-\n-   For any two classes, it is very desirable that there be another\n-   class that represents their union.  */\n-\n-\n-enum reg_class \n-{ \n-    NO_REGS, \n-    A0H_REG,\n-    A0L_REG,\n-    A0_REG,\n-    A1H_REG,\n-    ACCUM_HIGH_REGS,\n-    A1L_REG,\n-    ACCUM_LOW_REGS, \n-    A1_REG,\n-    ACCUM_REGS, \n-    X_REG, \n-    X_OR_ACCUM_LOW_REGS,\n-    X_OR_ACCUM_REGS,\n-    YH_REG,\n-    YH_OR_ACCUM_HIGH_REGS,\n-    X_OR_YH_REGS,\n-    YL_REG,\n-    YL_OR_ACCUM_LOW_REGS,\n-    X_OR_YL_REGS,\n-    X_OR_Y_REGS,\n-    Y_REG,\n-    ACCUM_OR_Y_REGS,\n-    PH_REG,\n-    X_OR_PH_REGS, \n-    PL_REG, \n-    PL_OR_ACCUM_LOW_REGS,\n-    X_OR_PL_REGS,\n-    YL_OR_PL_OR_ACCUM_LOW_REGS,\n-    P_REG,\n-    ACCUM_OR_P_REGS,\n-    YL_OR_P_REGS,\n-    ACCUM_LOW_OR_YL_OR_P_REGS,\n-    Y_OR_P_REGS,\n-    ACCUM_Y_OR_P_REGS, \n-    NO_FRAME_Y_ADDR_REGS,\n-    Y_ADDR_REGS, \n-    ACCUM_LOW_OR_Y_ADDR_REGS,\n-    ACCUM_OR_Y_ADDR_REGS,\n-    X_OR_Y_ADDR_REGS,\n-    Y_OR_Y_ADDR_REGS,\n-    P_OR_Y_ADDR_REGS,\n-    NON_HIGH_YBASE_ELIGIBLE_REGS,\n-    YBASE_ELIGIBLE_REGS,\n-    J_REG,\n-    J_OR_DAU_16_BIT_REGS,\n-    BMU_REGS, \n-    NOHIGH_NON_ADDR_REGS,\n-    NON_ADDR_REGS,\n-    SLOW_MEM_LOAD_REGS,\n-    NOHIGH_NON_YBASE_REGS,\n-    NO_ACCUM_NON_YBASE_REGS,\n-    NON_YBASE_REGS,\n-    YBASE_VIRT_REGS,\n-    ACCUM_LOW_OR_YBASE_REGS,\n-    ACCUM_OR_YBASE_REGS,\n-    X_OR_YBASE_REGS,\n-    Y_OR_YBASE_REGS,\n-    ACCUM_LOW_YL_PL_OR_YBASE_REGS,\n-    P_OR_YBASE_REGS,\n-    ACCUM_Y_P_OR_YBASE_REGS,\n-    Y_ADDR_OR_YBASE_REGS,\n-    YBASE_OR_NOHIGH_YBASE_ELIGIBLE_REGS,\n-    YBASE_OR_YBASE_ELIGIBLE_REGS,\n-    NO_HIGH_ALL_REGS,\n-    ALL_REGS, \n-    LIM_REG_CLASSES \n-};\n-\n-/* GENERAL_REGS must be the name of a register class */\n-#define GENERAL_REGS ALL_REGS\n-\n-#define N_REG_CLASSES (int) LIM_REG_CLASSES\n-\n-/* Give names of register classes as strings for dump file.  */\n-\n-#define REG_CLASS_NAMES        \\\n-{                              \\\n-    \"NO_REGS\",                 \\\n-    \"A0H_REG\",                 \\\n-    \"A0L_REG\",                 \\\n-    \"A0_REG\",                  \\\n-    \"A1H_REG\",                 \\\n-    \"ACCUM_HIGH_REGS\",         \\\n-    \"A1L_REG\",                 \\\n-    \"ACCUM_LOW_REGS\",          \\\n-    \"A1_REG\",                  \\\n-    \"ACCUM_REGS\",              \\\n-    \"X_REG\",                   \\\n-    \"X_OR_ACCUM_LOW_REGS\",     \\\n-    \"X_OR_ACCUM_REGS\",         \\\n-    \"YH_REG\",                  \\\n-    \"YH_OR_ACCUM_HIGH_REGS\",   \\\n-    \"X_OR_YH_REGS\",            \\\n-    \"YL_REG\",                  \\\n-    \"YL_OR_ACCUM_LOW_REGS\",    \\\n-    \"X_OR_YL_REGS\",            \\\n-    \"X_OR_Y_REGS\",             \\\n-    \"Y_REG\",                   \\\n-    \"ACCUM_OR_Y_REGS\",         \\\n-    \"PH_REG\",                  \\\n-    \"X_OR_PH_REGS\",            \\\n-    \"PL_REG\",                  \\\n-    \"PL_OR_ACCUM_LOW_REGS\",    \\\n-    \"X_OR_PL_REGS\",            \\\n-    \"PL_OR_YL_OR_ACCUM_LOW_REGS\", \\\n-    \"P_REG\",                   \\\n-    \"ACCUM_OR_P_REGS\",         \\\n-    \"YL_OR_P_REGS\",            \\\n-    \"ACCUM_LOW_OR_YL_OR_P_REGS\", \\\n-    \"Y_OR_P_REGS\",             \\\n-    \"ACCUM_Y_OR_P_REGS\",       \\\n-    \"NO_FRAME_Y_ADDR_REGS\",      \\\n-    \"Y_ADDR_REGS\",               \\\n-    \"ACCUM_LOW_OR_Y_ADDR_REGS\",  \\\n-    \"ACCUM_OR_Y_ADDR_REGS\",    \\\n-    \"X_OR_Y_ADDR_REGS\",        \\\n-    \"Y_OR_Y_ADDR_REGS\",        \\\n-    \"P_OR_Y_ADDR_REGS\",        \\\n-    \"NON_HIGH_YBASE_ELIGIBLE_REGS\", \\\n-    \"YBASE_ELIGIBLE_REGS\",     \\\n-    \"J_REG\",                   \\\n-    \"J_OR_DAU_16_BIT_REGS\",    \\\n-    \"BMU_REGS\",                \\\n-    \"NOHIGH_NON_ADDR_REGS\",    \\\n-    \"NON_ADDR_REGS\",           \\\n-    \"SLOW_MEM_LOAD_REGS\",      \\\n-    \"NOHIGH_NON_YBASE_REGS\",   \\\n-    \"NO_ACCUM_NON_YBASE_REGS\", \\\n-    \"NON_YBASE_REGS\",          \\\n-    \"YBASE_VIRT_REGS\",         \\\n-    \"ACCUM_LOW_OR_YBASE_REGS\", \\\n-    \"ACCUM_OR_YBASE_REGS\",     \\\n-    \"X_OR_YBASE_REGS\",         \\\n-    \"Y_OR_YBASE_REGS\",         \\\n-    \"ACCUM_LOW_YL_PL_OR_YBASE_REGS\", \\\n-    \"P_OR_YBASE_REGS\",         \\\n-    \"ACCUM_Y_P_OR_YBASE_REGS\", \\\n-    \"Y_ADDR_OR_YBASE_REGS\",    \\\n-    \"YBASE_OR_NOHIGH_YBASE_ELIGIBLE_REGS\", \\\n-    \"YBASE_OR_YBASE_ELIGIBLE_REGS\", \\\n-    \"NO_HIGH_ALL_REGS\",        \\\n-    \"ALL_REGS\"                 \\\n-}\n-\n-/* Define which registers fit in which classes.\n-   This is an initializer for a vector of HARD_REG_SET\n-   of length N_REG_CLASSES.  */\n-\n-#define REG_CLASS_CONTENTS   \\\n-{                            \\\n-    {0x00000000,  0x00000000},      /* no reg */                             \\\n-    {0x00000001,  0x00000000},      /* a0h */                                \\\n-    {0x00000002,  0x00000000},      /* a0l */                                \\\n-    {0x00000003,  0x00000000},      /* a0h:a0l */                            \\\n-    {0x00000004,  0x00000000},      /* a1h */                                \\\n-    {0x00000005,  0x00000000},      /* accum high */                         \\\n-    {0x00000008,  0x00000000},      /* a1l */                                \\\n-    {0x0000000A,  0x00000000},      /* accum low */                          \\\n-    {0x0000000c,  0x00000000},      /* a1h:a1l */                            \\\n-    {0x0000000f,  0x00000000},      /* accum regs */                         \\\n-    {0x00000010,  0x00000000},      /* x reg */                              \\\n-    {0x0000001A,  0x00000000},      /* x & accum_low_regs */                 \\\n-    {0x0000001f,  0x00000000},      /* x & accum regs */                     \\\n-    {0x00000020,  0x00000000},      /* y high */                             \\\n-    {0x00000025,  0x00000000},      /* yh, accum high */                     \\\n-    {0x00000030,  0x00000000},      /* x & yh */                             \\\n-    {0x00000040,  0x00000000},      /* y low */                              \\\n-    {0x0000004A,  0x00000000},      /* y low, accum_low */                   \\\n-    {0x00000050,  0x00000000},      /* x & yl */                             \\\n-    {0x00000060,  0x00000000},      /* yl:yh */                              \\\n-    {0x00000070,  0x00000000},      /* x, yh,a nd yl */                      \\\n-    {0x0000006F,  0x00000000},      /* accum, y */                           \\\n-    {0x00000080,  0x00000000},      /* p high */                             \\\n-    {0x00000090,  0x00000000},      /* x & ph */                             \\\n-    {0x00000100,  0x00000000},      /* p low */                              \\\n-    {0x0000010A,  0x00000000},      /* p_low and accum_low */                \\\n-    {0x00000110,  0x00000000},      /* x & pl */                             \\\n-    {0x0000014A,  0x00000000},      /* pl,yl,a1l,a0l */                      \\\n-    {0x00000180,  0x00000000},      /* pl:ph */                              \\\n-    {0x0000018F,  0x00000000},      /* accum, p */                           \\\n-    {0x000001C0,  0x00000000},      /* pl:ph and yl */                       \\\n-    {0x000001CA,  0x00000000},      /* pl:ph, yl, a0l, a1l */                \\\n-    {0x000001E0,  0x00000000},      /* y or p */                             \\\n-    {0x000001EF,  0x00000000},      /* accum, y or p */                      \\\n-    {0x00000E00,  0x00000000},      /* r0-r2 */                              \\\n-    {0x00001E00,  0x00000000},      /* r0-r3 */                              \\\n-    {0x00001E0A,  0x00000000},      /* r0-r3, accum_low */                   \\\n-    {0x00001E0F,  0x00000000},      /* accum,r0-r3 */                        \\\n-    {0x00001E10,  0x00000000},      /* x,r0-r3 */                            \\\n-    {0x00001E60,  0x00000000},      /* y,r0-r3 */                            \\\n-    {0x00001F80,  0x00000000},      /* p,r0-r3 */                            \\\n-    {0x00001FDA,  0x00000000},      /* ph:pl, r0-r3, x,a0l,a1l */            \\\n-    {0x00001fff,  0x00000000},      /* accum,x,y,p,r0-r3 */                  \\\n-    {0x00002000,  0x00000000},      /* j */                                  \\\n-    {0x00002025,  0x00000000},      /* j, yh, a1h, a0h */                    \\\n-    {0x001E0000,  0x00000000},      /* ar0-ar3 */                            \\\n-    {0x03FFE1DA,  0x00000000},      /* non_addr except yh,a0h,a1h */         \\\n-    {0x03FFE1FF,  0x00000000},      /* non_addr regs */                      \\\n-    {0x03FFFF8F,  0x00000000},      /* non ybase except yh, yl, and x */     \\\n-    {0x03FFFFDA,  0x00000000},      /* non ybase regs except yh,a0h,a1h */   \\\n-    {0x03FFFFF0,  0x00000000},      /* non ybase except a0,a0l,a1,a1l */     \\\n-    {0x03FFFFFF,  0x00000000},      /* non ybase regs */                     \\\n-    {0xFC000000,  0x03FFFFFF},      /* virt ybase regs */                    \\\n-    {0xFC00000A,  0x03FFFFFF},      /* accum_low, virt ybase regs */         \\\n-    {0xFC00000F,  0x03FFFFFF},      /* accum, virt ybase regs */             \\\n-    {0xFC000010,  0x03FFFFFF},      /* x,virt ybase regs */                  \\\n-    {0xFC000060,  0x03FFFFFF},      /* y,virt ybase regs */                  \\\n-    {0xFC00014A,  0x03FFFFFF},      /* accum_low, yl, pl, ybase */           \\\n-    {0xFC000180,  0x03FFFFFF},      /* p,virt ybase regs */                  \\\n-    {0xFC0001EF,  0x03FFFFFF},      /* accum,y,p,ybase regs */               \\\n-    {0xFC001E00,  0x03FFFFFF},      /* r0-r3, ybase regs */                  \\\n-    {0xFC001FDA,  0x03FFFFFF},      /* r0-r3, pl:ph,yl,x,a1l,a0l */          \\\n-    {0xFC001FFF,  0x03FFFFFF},      /* virt ybase, ybase eligible regs */    \\\n-    {0xFCFFFFDA,  0x03FFFFFF},      /* all regs except yh,a0h,a1h */         \\\n-    {0xFFFFFFFF,  0x03FFFFFF}       /* all regs */                           \\\n-}\n-\n-\n-/* The same information, inverted:\n-   Return the class number of the smallest class containing\n-   reg number REGNO.  This could be a conditional expression\n-   or could index an array.  */\n-\n-#define REGNO_REG_CLASS(REGNO) regno_reg_class(REGNO)\n-\n-/* The class value for index registers, and the one for base regs.  */\n-\n-#define INDEX_REG_CLASS NO_REGS\n-#define BASE_REG_CLASS  Y_ADDR_REGS\n-\n-/* Get reg_class from a letter such as appears in the machine description.  */\n-\n-#define REG_CLASS_FROM_LETTER(C) \\\n-  dsp16xx_reg_class_from_letter(C)\n-\n-#define SECONDARY_RELOAD_CLASS(CLASS, MODE, X)  \\\n-   secondary_reload_class(CLASS, MODE, X)\n-\n-/* When defined, the compiler allows registers explicitly used in the\n-   rtl to be used as spill registers but prevents the compiler from\n-   extending the lifetime of these registers.  */\n-\n-#define SMALL_REGISTER_CLASSES 1\n-\n-/* Macros to check register numbers against specific register classes.  */\n-\n-/* These assume that REGNO is a hard or pseudo reg number.\n-   They give nonzero only if REGNO is a hard reg of the suitable class\n-   or a pseudo reg currently allocated to a suitable hard reg.\n-   Since they use reg_renumber, they are safe only once reg_renumber\n-   has been allocated, which happens in local-alloc.c.  */\n-\n-/* A C expression which is nonzero if register REGNO is suitable for use\n-   as a base register in operand addresses. It may be either a suitable\n-   hard register or a pseudo register that has been allocated such a\n-   hard register. \n-\n-  On the 1610 the Y address pointers can be used as a base registers */\n-#define REGNO_OK_FOR_BASE_P(REGNO) \\\n-(((REGNO) >= REG_R0 && (REGNO) < REG_R3 + 1) || ((unsigned) reg_renumber[REGNO] >= REG_R0  \\\n-                                   && (unsigned) reg_renumber[REGNO] < REG_R3 + 1))\n-\n-#define REGNO_OK_FOR_YBASE_P(REGNO) \\\n-  (((REGNO) == REG_YBASE) || ((unsigned) reg_renumber[REGNO] == REG_YBASE))\n-\n-#define REGNO_OK_FOR_INDEX_P(REGNO)  0\n-\n-#ifdef ALL_16_BIT_REGISTERS\n-#define IS_32_BIT_REG(REGNO)  0\n-#else\n-#define IS_32_BIT_REG(REGNO)     \\\n-  ((REGNO) == REG_A0 || (REGNO) == REG_A1 || (REGNO) == REG_Y || (REGNO) == REG_PROD)\n-#endif\n-\n-/* Given an rtx X being reloaded into a reg required to be\n-   in class CLASS, return the class of reg to actually use.\n-   In general this is just CLASS; but on some machines\n-   in some cases it is preferable to use a more restrictive class.\n-   Also, we must ensure that a PLUS is reloaded either\n-   into an accumulator or an address register.  */\n-\n-#define PREFERRED_RELOAD_CLASS(X,CLASS)\t preferred_reload_class (X, CLASS)\n-\n-/*   A C expression that places additional restrictions on the register\n-     class to use when it is necessary to be able to hold a value of\n-     mode MODE in a reload register for which class CLASS would\n-     ordinarily be used.\n-\n-     Unlike `PREFERRED_RELOAD_CLASS', this macro should be used when\n-     there are certain modes that simply can't go in certain reload\n-     classes.\n-\n-     The value is a register class; perhaps CLASS, or perhaps another,\n-     smaller class.\n-\n-     Don't define this macro unless the target machine has limitations\n-     which require the macro to do something nontrivial.  */\n-\n-#if 0\n-#define LIMIT_RELOAD_CLASS(MODE, CLASS) dsp16xx_limit_reload_class (MODE, CLASS)\n-#endif\n-\n-/* A C expression for the maximum number of consecutive registers of class CLASS\n-   needed to hold a value of mode MODE */\n-#define CLASS_MAX_NREGS(CLASS, MODE)                                \\\n-    class_max_nregs(CLASS, MODE)\n-\n-/* The letters 'I' through 'P' in a register constraint string\n-   can be used to stand for particular ranges of immediate operands.\n-   This macro defines what the ranges are.\n-   C is the letter, and VALUE is a constant value.\n-   Return 1 if VALUE is in the range specified by C.\n-\n-   For the 16xx, the following constraints are used:\n-   'I' requires a non-negative 16-bit value.\n-   'J' requires a non-negative 9-bit value\n-   'K' requires a constant 0 operand.\n-   'L' constant for use in add or sub from low 16-bits\n-   'M' 32-bit value -- low 16-bits zero\n-   'N' constant for use incrementing or decrementing an address register\n-   'O' constant for use with and'ing only high 16-bit\n-   'P' constant for use with and'ing only low 16-bit\n- */\n-\n-#define SMALL_INT(X) (SMALL_INTVAL (INTVAL (X)))\n-#define SMALL_INTVAL(I) ((unsigned) (I) < 0x10000)\n-#define SHORT_IMMEDIATE(X)  (SHORT_INTVAL (INTVAL(X)))\n-#define SHORT_INTVAL(I)     ((unsigned) (I) < 0x100)\n-#define ADD_LOW_16(I)       ((I) >= 0 && (I) <= 32767)\n-#define ADD_HIGH_16(I)      (((I) & 0x0000ffff) == 0)\n-#define AND_LOW_16(I)       ((I) >= 0 && (I) <= 32767)\n-#define AND_HIGH_16(I)      (((I) & 0x0000ffff) == 0)\n-\n-#define CONST_OK_FOR_LETTER_P(VALUE, C)                           \\\n-   ((C) == 'I' ? (SMALL_INTVAL(VALUE))                            \\\n-    : (C) == 'J' ? (SHORT_INTVAL(VALUE))                          \\\n-    : (C) == 'K' ? ((VALUE) == 0)                                 \\\n-    : (C) == 'L' ? ((VALUE) >= 0 && (VALUE) <= 32767)             \\\n-    : (C) == 'M' ? (((VALUE) & 0x0000ffff) == 0)                  \\\n-    : (C) == 'N' ? ((VALUE) == -1 || (VALUE) == 1                 \\\n-                    || (VALUE) == -2 || (VALUE) == 2)             \\\n-    : (C) == 'O' ? (((VALUE) & 0xffff0000) == 0xffff0000)         \\\n-    : (C) == 'P' ? (((VALUE) & 0x0000ffff) == 0xffff)             \\\n-    : 0)\n-\n-#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)   1\n-\n-/* Optional extra constraints for this machine */\n-#define EXTRA_CONSTRAINT(OP,C)                                    \\\n-  ((C) == 'R' ? symbolic_address_p (OP)                           \\\n-   : 0)\n-\f\n-/* DESCRIBING STACK LAYOUT AND CALLING CONVENTIONS */\n-\n-/* Define this if pushing a word on the stack\n-   makes the stack pointer a smaller address.  */\n-/* #define STACK_GROWS_DOWNWARD */\n-\n-/* Define this if the nominal address of the stack frame\n-   is at the high-address end of the local variables;\n-   that is, each additional local variable allocated\n-   goes at a more negative offset in the frame.  */\n-/* #define FRAME_GROWS_DOWNWARD */\n-\n-#define ARGS_GROW_DOWNWARD\n-\n-/* We use post decrement on the 1600 because there isn't\n-   a pre-decrement addressing mode. This means that we\n-   assume the stack pointer always points at the next\n-   FREE location on the stack.  */\n-#define STACK_PUSH_CODE POST_INC\n-\n-/* Offset within stack frame to start allocating local variables at.\n-   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n-   first local allocated.  Otherwise, it is the offset to the BEGINNING\n-   of the first local allocated.  */\n-#define STARTING_FRAME_OFFSET  0\n-\n-/* Offset from the stack pointer register to the first\n-   location at which outgoing arguments are placed.  */\n-#define STACK_POINTER_OFFSET (0)\n-\n-struct dsp16xx_frame_info\n-{\n-  unsigned long total_size;\t/* # bytes that the entire frame takes up */\n-  unsigned long var_size;\t/* # bytes that variables take up */\n-  unsigned long args_size;\t/* # bytes that outgoing arguments take up */\n-  unsigned long extra_size;\t/* # bytes of extra gunk */\n-  unsigned int  reg_size;\t/* # bytes needed to store regs */\n-  long\t\tfp_save_offset;\t/* offset from vfp to store registers */\n-  unsigned long sp_save_offset;\t/* offset from new sp to store registers */\n-  int\t\tpr_save_offset;\t/* offset to saved PR */\n-  int\t\tinitialized;\t/* != 0 if frame size already calculated */\n-  int\t\tnum_regs;\t/* number of registers saved */\n-  int           function_makes_calls;  /* Does the function make calls */\n-};\n-\n-extern struct dsp16xx_frame_info current_frame_info;\n-\n-#define RETURN_ADDR_OFF current_frame_info.pr_save_offset\n-\n-/* If we generate an insn to push BYTES bytes,\n-   this says how many the stack pointer really advances by.  */\n-/* #define PUSH_ROUNDING(BYTES) ((BYTES)) */\n-\n-/* If defined, the maximum amount of space required for outgoing\n-   arguments will be computed and placed into the variable\n-   'current_function_outgoing_args_size'. No space will be pushed\n-   onto the stack for each call; instead, the function prologue should\n-   increase the stack frame size by this amount.\n-\n-   It is not proper to define both 'PUSH_ROUNDING' and\n-   'ACCUMULATE_OUTGOING_ARGS'.  */\n-#define ACCUMULATE_OUTGOING_ARGS 1\n-\n-/* Offset of first parameter from the argument pointer\n-   register value.  */\n-\n-#define FIRST_PARM_OFFSET(FNDECL)   (0)\n-\n-/* Value is 1 if returning from a function call automatically\n-   pops the arguments described by the number-of-args field in the call.\n-   FUNDECL is the declaration node of the function (as a tree),\n-   FUNTYPE is the data type of the function (as a tree),\n-   or for a library call it is an identifier node for the subroutine name.  */\n-\n-#define RETURN_POPS_ARGS(FUNDECL,FUNTYPE,SIZE) 0\n-\n-/* Define how to find the value returned by a function.\n-   VALTYPE is the data type of the value (as a tree).\n-   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n-   otherwise, FUNC is 0. On the 1610 all function return their values\n-   in a0 (i.e. the upper 16 bits). If the return value is 32-bits the\n-   entire register is significant.  */\n-\n-#define VALUE_REGNO(MODE)  (REG_Y)\n-\n-#define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n-  gen_rtx_REG (TYPE_MODE (VALTYPE), VALUE_REGNO(TYPE_MODE(VALTYPE)))\n-\n-/* Define how to find the value returned by a library function\n-   assuming the value has mode MODE.  */\n-#define LIBCALL_VALUE(MODE)  gen_rtx_REG (MODE, VALUE_REGNO(MODE))\n-\n-/* 1 if N is a possible register number for a function value.  */\n-#define FUNCTION_VALUE_REGNO_P(N) ((N) == REG_Y)\n-\f\n-\n-/* Define where to put the arguments to a function.\n-   Value is zero to push the argument on the stack,\n-   or a hard register in which to store the argument.\n-\n-   MODE is the argument's machine mode.\n-   TYPE is the data type of the argument (as a tree).\n-    This is null for libcalls where that information may\n-    not be available.\n-   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n-    the preceding args and about the function being called.\n-   NAMED is nonzero if this argument is a named parameter\n-    (otherwise it is an extra parameter matching an ellipsis).  */\n-\n-/* On the 1610 all args are pushed, except if -mregparm is specified\n-   then the first two words of arguments are passed in a0, a1.  */\n-#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n-  dsp16xx_function_arg (CUM, MODE, TYPE, NAMED)\n-\n-/* Define the first register to be used for argument passing */\n-#define FIRST_REG_FOR_FUNCTION_ARG REG_Y\n-\n-/* Define the profitability of saving registers around calls.\n-   NOTE: For now we turn this off because of a bug in the\n-   caller-saves code and also because i'm not sure it is helpful\n-   on the 1610.  */\n-\n-#define CALLER_SAVE_PROFITABLE(REFS,CALLS) 0\n-\n-/* This indicates that an argument is to be passed with an invisible reference\n-   (i.e., a pointer to the object is passed).\n-\n-   On the dsp16xx, we do this if it must be passed on the stack.  */\n-\n-#define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED)\t\\\n-  (MUST_PASS_IN_STACK (MODE, TYPE))\n-\n-/* For an arg passed partly in registers and partly in memory,\n-   this is the number of registers used.\n-   For args passed entirely in registers or entirely in memory, zero.  */\n-\n-#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED)  (0)\n-\n-/* Define a data type for recording info about an argument list\n-   during the scan of that argument list.  This data type should\n-   hold all necessary information about the function itself\n-   and about the args processed so far, enough to enable macros\n-   such as FUNCTION_ARG to determine where the next arg should go.  */\n-#define CUMULATIVE_ARGS int\n-\n-/* Initialize a variable CUM of type CUMULATIVE_ARGS\n-   for a call to a function whose data type is FNTYPE.\n-   For a library call, FNTYPE is 0.  */\n-#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME,INDIRECT)  ((CUM) = 0)\n-\n-/* Update the data in CUM to advance over an argument\n-   of mode MODE and data type TYPE.\n-   (TYPE is null for libcalls where that information may not be available.)  */\n-\n-#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n-  dsp16xx_function_arg_advance (&CUM, MODE,TYPE, NAMED)\n-\n-/* 1 if N is a possible register number for function argument passing.  */\n-#define FUNCTION_ARG_REGNO_P(N)   \\\n-  ((N) == REG_Y || (N) == REG_YL || (N) == REG_PROD || (N) == REG_PRODL)\n-\n-/* Output assembler code to FILE to increment profiler label # LABELNO\n-   for profiling a function entry.  */\n-\n-#define FUNCTION_PROFILER(FILE, LABELNO)        \\\n-  internal_error (\"profiling not implemented yet\")\n-\n-/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n-   the stack pointer does not matter.  The value is tested only in\n-   functions that have frame pointers.\n-   No definition is equivalent to always zero.  */\n-\n-#define EXIT_IGNORE_STACK  (0)\n-\n-#define TRAMPOLINE_TEMPLATE(FILE) \\\n-  internal_error (\"trampolines not yet implemented\");\n-\n-/* Length in units of the trampoline for entering a nested function.\n-   This is a dummy value  */\n-\n-#define TRAMPOLINE_SIZE 20\n-\n-/* Emit RTL insns to initialize the variable parts of a trampoline.\n-   FNADDR is an RTX for the address of the function's pure code.\n-   CXT is an RTX for the static chain value for the function.  */\n-\n-#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\t\\\n-  internal_error (\"trampolines not yet implemented\");\n-\n-/* A C expression which is nonzero if a function must have and use a\n-   frame pointer. If its value is nonzero the functions will have a\n-   frame pointer.  */\n-#define FRAME_POINTER_REQUIRED  (current_function_calls_alloca)\n-\n-/* A C statement to store in the variable 'DEPTH' the difference\n-   between the frame pointer and the stack pointer values immediately\n-   after the function prologue.  */\n-#define INITIAL_FRAME_POINTER_OFFSET(DEPTH)                     \\\n-{  (DEPTH) = initial_frame_pointer_offset();\t                \\\n-}\n-\f\n-/* IMPLICIT CALLS TO LIBRARY ROUTINES */\n-\n-#define ADDHF3_LIBCALL      \"__Emulate_addhf3\"\n-#define SUBHF3_LIBCALL      \"__Emulate_subhf3\"\n-#define MULHF3_LIBCALL      \"__Emulate_mulhf3\"\n-#define DIVHF3_LIBCALL      \"__Emulate_divhf3\"\n-#define CMPHF3_LIBCALL      \"__Emulate_cmphf3\"\n-#define FIXHFHI2_LIBCALL    \"__Emulate_fixhfhi2\"\n-#define FLOATHIHF2_LIBCALL  \"__Emulate_floathihf2\"\n-#define NEGHF2_LIBCALL      \"__Emulate_neghf2\"\n-\n-#define UMULHI3_LIBCALL     \"__Emulate_umulhi3\"\n-#define MULHI3_LIBCALL      \"__Emulate_mulhi3\"\n-#define UDIVQI3_LIBCALL     \"__Emulate_udivqi3\"\n-#define UDIVHI3_LIBCALL     \"__Emulate_udivhi3\"\n-#define DIVQI3_LIBCALL      \"__Emulate_divqi3\"\n-#define DIVHI3_LIBCALL      \"__Emulate_divhi3\"\n-#define MODQI3_LIBCALL      \"__Emulate_modqi3\"\n-#define MODHI3_LIBCALL      \"__Emulate_modhi3\"\n-#define UMODQI3_LIBCALL     \"__Emulate_umodqi3\"\n-#define UMODHI3_LIBCALL     \"__Emulate_umodhi3\"\n-#define ASHRHI3_LIBCALL     \"__Emulate_ashrhi3\"\n-#define LSHRHI3_LIBCALL     \"__Emulate_lshrhi3\"\n-#define ASHLHI3_LIBCALL     \"__Emulate_ashlhi3\"\n-#define LSHLHI3_LIBCALL     \"__Emulate_lshlhi3\"   /* NOT USED */\n-\n-/* Define this macro if calls to the ANSI C library functions memcpy and\n-   memset should be generated instead of the BSD function bcopy & bzero.  */\n-#define TARGET_MEM_FUNCTIONS\n-\n-\f\n-/* ADDRESSING MODES */\n-\n-/* The 1610 has post-increment and decrement, but no pre-modify */\n-#define HAVE_POST_INCREMENT 1\n-#define HAVE_POST_DECREMENT 1\n-\n-/* Recognize any constant value that is a valid address.  */\n-#define CONSTANT_ADDRESS_P(X)  CONSTANT_P (X)\n-\n-/* Maximum number of registers that can appear in a valid memory address.  */\n-#define MAX_REGS_PER_ADDRESS 1\n-\n-/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n-   and check its validity for a certain class.\n-   We have two alternate definitions for each of them.\n-   The usual definition accepts all pseudo regs; the other rejects\n-   them unless they have been allocated suitable hard regs.\n-   The symbol REG_OK_STRICT causes the latter definition to be used.\n-\n-   Most source files want to accept pseudo regs in the hope that\n-   they will get allocated to the class that the insn wants them to be in.\n-   Source files for reload pass need to be strict.\n-   After reload, it makes no difference, since pseudo regs have\n-   been eliminated by then.  */\n-\n-#ifndef REG_OK_STRICT\n-\n-/* Nonzero if X is a hard reg that can be used as an index\n-   or if it is a pseudo reg.  */\n-#define REG_OK_FOR_INDEX_P(X)  0\n-\n-/* Nonzero if X is a hard reg that can be used as a base reg\n-   or if it is a pseudo reg.  */\n-#define REG_OK_FOR_BASE_P(X)    \\\n-    ((REGNO (X) >= REG_R0 && REGNO (X) < REG_R3 + 1 )          \\\n-       || (REGNO (X) >= FIRST_PSEUDO_REGISTER))\n-\n-/* Nonzero if X is the 'ybase' register */\n-#define REG_OK_FOR_YBASE_P(X)   \\\n-  (REGNO(X) == REG_YBASE || (REGNO (X) >= FIRST_PSEUDO_REGISTER))\n-#else\n-\n-/* Nonzero if X is a hard reg that can be used as an index.  */\n-#define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n-\n-/* Nonzero if X is a hard reg that can be used as a base reg.  */\n-#define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n-\n-/* Nonzero if X is the 'ybase' register */\n-#define REG_OK_FOR_YBASE_P(X) REGNO_OK_FOR_YBASE_P (REGNO(X))\n-\n-#endif\n-\f\n-/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n-   that is a valid memory address for an instruction.\n-   The MODE argument is the machine mode for the MEM expression\n-   that wants to use this address.\n-\n-   On the 1610, the actual legitimate addresses must be N (N must fit in\n-   5 bits), *rn (register indirect), *rn++, or *rn-- */\n-\n-#define INT_FITS_5_BITS(I)    ((unsigned long) (I) < 0x20)\n-#define INT_FITS_16_BITS(I)   ((unsigned long) (I) < 0x10000)\n-#define YBASE_CONST_OFFSET(I)       ((I) >= -31 && (I) <= 0)\n-#define YBASE_OFFSET(X)       (GET_CODE (X) == CONST_INT && YBASE_CONST_OFFSET (INTVAL(X)))\n-\n-#define FITS_16_BITS(X)       (GET_CODE (X) == CONST_INT && INT_FITS_16_BITS(INTVAL(X)))\n-#define FITS_5_BITS(X)        (GET_CODE (X) == CONST_INT && INT_FITS_5_BITS(INTVAL(X)))\n-#define ILLEGAL_HIMODE_ADDR(MODE, CONST)  ((MODE) == HImode && CONST == -31)\n-\n-#define INDIRECTABLE_ADDRESS_P(X)                            \\\n-    ((GET_CODE(X) == REG && REG_OK_FOR_BASE_P(X))            \\\n-  || ((GET_CODE(X) == POST_DEC || GET_CODE(X) == POST_INC)   \\\n-       && REG_P(XEXP(X,0)) && REG_OK_FOR_BASE_P(XEXP(X,0)))  \\\n-  || (GET_CODE(X) == CONST_INT && (unsigned long) (X) < 0x20))\n-\n-\n-#define INDEXABLE_ADDRESS_P(X,MODE)                                 \\\n-   ((GET_CODE(X) == PLUS && GET_CODE (XEXP (X,0)) == REG &&         \\\n-     XEXP(X,0) == stack_pointer_rtx && YBASE_OFFSET(XEXP(X,1)) &&   \\\n-     !ILLEGAL_HIMODE_ADDR(MODE, INTVAL(XEXP(X,1)))) ||              \\\n-    (GET_CODE(X) == PLUS && GET_CODE (XEXP (X,1)) == REG &&         \\\n-     XEXP(X,1) == stack_pointer_rtx && YBASE_OFFSET(XEXP(X,0)) &&  \\\n-     !ILLEGAL_HIMODE_ADDR(MODE, INTVAL(XEXP(X,0)))))\n-\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)                     \\\n-{\t\t\t\t\t\t\t            \\\n-    if (INDIRECTABLE_ADDRESS_P(X))                                  \\\n-        goto ADDR;                                                  \\\n-}\n-\n-\f\n-/* Try machine-dependent ways of modifying an illegitimate address\n-   to be legitimate.  If we find one, return the new, valid address.\n-   This macro is used in only one place: `memory_address' in explow.c.\n-\n-   OLDX is the address as it was before break_out_memory_refs was called.\n-   In some cases it is useful to look at this to decide what needs to be done.\n-\n-   MODE and WIN are passed so that this macro can use\n-   GO_IF_LEGITIMATE_ADDRESS.\n-\n-   It is always safe for this macro to do nothing.  It exists to recognize\n-   opportunities to optimize the output.\n-\n-   For the 1610, we need not do anything.  However, if we don't,\n-   `memory_address' will try lots of things to get a valid address, most of\n-   which will result in dead code and extra pseudos.  So we make the address\n-   valid here.\n-\n-   This is easy:  The only valid addresses are an offset from a register\n-   and we know the address isn't valid.  So just call either `force_operand'\n-   or `force_reg' unless this is a (plus (reg ...) (const_int 0)).  */\n-\n-#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)\t\t\t\\\n-{ if (GET_CODE (X) == PLUS && XEXP (X, 1) == const0_rtx)\t\\\n-    X = XEXP (x, 0);\t\t\t\t\t\t\\\n-  if (GET_CODE (X) == MULT || GET_CODE (X) == PLUS)\t\t\\\n-    X = force_operand (X, 0);\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\\\n-    X = force_reg (Pmode, X);\t\t\t\t\t\\\n-  goto WIN;\t\t\t\t\t\t\t\\\n-}\n-\n-/* Go to LABEL if ADDR (a legitimate address expression)\n-   has an effect that depends on the machine mode it is used for.\n-   On the 1610, only postdecrement and postincrement address depend thus\n-   (the amount of decrement or increment being the length of the operand).  */\n-\n-#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)\t\\\n- if (GET_CODE (ADDR) == POST_INC || GET_CODE (ADDR) == POST_DEC) goto LABEL\n-\n-/* Nonzero if the constant value X is a legitimate general operand.\n-   It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n-#define LEGITIMATE_CONSTANT_P(X) (1)\n-\n-\f\n-/* CONDITION CODE INFORMATION */\n-\n-/* Store in cc_status the expressions\n-   that the condition codes will describe\n-   after execution of an instruction whose pattern is EXP.\n-   Do not alter them if the instruction would not alter the cc's.  */\n-\n-#define NOTICE_UPDATE_CC(EXP, INSN) \\\n-   notice_update_cc( (EXP) )\n-\f\n-/* DESCRIBING RELATIVE COSTS OF OPERATIONS */\n-\n-/* A c expression for the cost of moving data from a register in\n-   class FROM to one in class TO. The classes are expressed using\n-   the enumeration values such as GENERAL_REGS. A value of 2 is\n-   the default.  */\n-#define REGISTER_MOVE_COST(MODE,FROM,TO)  dsp16xx_register_move_cost (FROM, TO)\n-\n-/* A C expression for the cost of moving data of mode MODE between\n-   a register and memory. A value of 2 is the default.  */\n-#define MEMORY_MOVE_COST(MODE,CLASS,IN)                          \\\n-  (GET_MODE_CLASS(MODE) == MODE_INT && MODE == QImode ? 12       \\\n-   : 16)\n-\n-/* A C expression for the cost of a branch instruction. A value of\n-   1 is the default; */\n-#define BRANCH_COST 1\n-\f\n-\n-/* Define this because otherwise gcc will try to put the function address\n-   in any old pseudo register. We can only use pt.  */\n-#define NO_FUNCTION_CSE\n-\n-/* Define this macro as a C expression which is nonzero if accessing less\n-   than a word of memory (i.e a char or short) is no faster than accessing\n-   a word of memory, i.e if such access require more than one instruction\n-   or if there is no difference in cost between byte and (aligned) word\n-   loads.  */\n-#define SLOW_BYTE_ACCESS 1\n-\n-/* Define this macro if unaligned accesses have a cost many times greater than\n-   aligned accesses, for example if they are emulated in a trap handler */\n-/* define SLOW_UNALIGNED_ACCESS(MODE, ALIGN) */\n-\n-\f\n-/* DIVIDING THE OUTPUT IN SECTIONS */\n-/* Output before read-only data.  */\n-\n-#define DEFAULT_TEXT_SEG_NAME \".text\"\n-#define TEXT_SECTION_ASM_OP  rsect_text\n-\n-/* Output before constants and strings */\n-#define DEFAULT_CONST_SEG_NAME  \".const\"\n-#define READONLY_DATA_SECTION_ASM_OP rsect_const\n-\n-/* Output before writable data.  */\n-#define DEFAULT_DATA_SEG_NAME \".data\"\n-#define DATA_SECTION_ASM_OP  rsect_data\n-\n-#define DEFAULT_BSS_SEG_NAME \".bss\"\n-#define BSS_SECTION_ASM_OP rsect_bss\n-\n-/* We will default to using 1610 if the user doesn't\n-   specify it.  */\n-#define DEFAULT_CHIP_NAME \"1610\"\n-\f\n-/* THE OVERALL FRAMEWORK OF AN ASSEMBLER FILE */\n-\n-/* A C string constant describing how to begin a comment in the target\n-   assembler language.  */\n-#define ASM_COMMENT_START \"\"\n-#define ASM_COMMENT_END \"\"\n-\n-/* Output to assembler file text saying following lines\n-   may contain character constants, extra white space, comments, etc.  */\n-#define ASM_APP_ON \"\"\n-\n-/* Output to assembler file text saying following lines\n-   no longer contain unusual constructs.  */\n-#define ASM_APP_OFF \"\"\n-\f\n-/* OUTPUT OF DATA */\n-\n-/* This is how we output a 'c' character string. For the 16xx\n-   assembler we have to do it one letter at a time */\n-\n-#define ASCII_LENGTH 10\n-\n-#define ASM_OUTPUT_ASCII(MYFILE, MYSTRING, MYLENGTH) \\\n-  do {\t\t\t\t\t\t\t\t\t      \\\n-    FILE *_hide_asm_out_file = (MYFILE);\t\t\t\t      \\\n-    const unsigned char *_hide_p = (const unsigned char *) (MYSTRING);\t      \\\n-    int _hide_thissize = (MYLENGTH);\t\t\t\t\t      \\\n-    {\t\t\t\t\t\t\t\t\t      \\\n-      FILE *asm_out_file = _hide_asm_out_file;\t\t\t\t      \\\n-      const unsigned char *p = _hide_p;\t\t\t\t\t      \\\n-      int thissize = _hide_thissize;\t\t\t\t\t      \\\n-      int i;\t\t\t\t\t\t\t\t      \\\n-\t\t\t\t\t\t\t\t\t      \\\n-      for (i = 0; i < thissize; i++)\t\t\t\t\t      \\\n-\t{\t\t\t\t\t\t\t\t      \\\n-\t  register int c = p[i];\t\t\t\t\t      \\\n-\t  \t\t\t\t\t\t\t\t      \\\n-\t  if (i % ASCII_LENGTH == 0) \\\n-\t    fprintf (asm_out_file, \"\\tint \");\t\t\t\t      \\\n-\t    \t\t\t\t\t\t\t\t\\\n-\t  if (c >= ' ' && c < 0177 && c != '\\'')\t\t\t      \\\n-\t  {\t\t\t\t\t\t\t\t      \\\n-\t    putc ('\\'', asm_out_file);\t\t\t\t\t      \\\n-\t    putc (c, asm_out_file);\t\t\t\t\t      \\\n-\t    putc ('\\'', asm_out_file);\t\t\t\t\t      \\\n-\t  }\t\t\t\t\t\t\t\t      \\\n-\t  else\t\t\t\t\t\t\t\t      \\\n-\t    {\t\t\t\t\t\t\t\t      \\\n-\t      fprintf (asm_out_file, \"%d\", c);\t\t\t              \\\n-\t      /* After an octal-escape, if a digit follows,\t\t      \\\n-\t\t terminate one string constant and start another.\t      \\\n-\t\t The VAX assembler fails to stop reading the escape\t      \\\n-\t\t after three digits, so this is the only way we\t\t      \\\n-\t\t can get it to parse the data properly.  \t\t      \\\n-\t      if (i < thissize - 1 && ISDIGIT (p[i + 1]))\t\t      \\\n-\t\tfprintf (asm_out_file, \"\\'\\n\\tint \\'\");\t\t              \\\n-\t\t*/ \\\n-\t  }\t\t\t\t\t\t\t\t      \\\n-\t  /* if: \\\n-\t     we are not at the last char (i != thissize -1) \\\n-\t     and (we are not at a line break multiple  \\\n-\t     but i == 0) (it will be the very first time) \\\n-\t     then put out a comma to extend. \\\n-\t   */ \\\n-\t  if ((i != thissize - 1) && ((i + 1) % ASCII_LENGTH))\t      \\\n-\t    fprintf(asm_out_file, \",\");\t \t                      \\\n-\t  if (!((i + 1) % ASCII_LENGTH)) \\\n-\t    fprintf (asm_out_file, \"\\n\");\t\t\t      \\\n-\t}\t\t\t\t\t\t\t\t      \\\n-      fprintf (asm_out_file, \"\\n\");\t\t\t\t\t      \\\n-    }\t\t\t\t\t\t\t\t\t      \\\n-  }\t\t\t\t\t\t\t\t\t      \\\n-  while (0)\n-\n-#define ASM_PN_FORMAT \"*L%s_%lu\"\n-\f\n-/* OUTPUT OF UNINITIALIZED VARIABLES */\n-\n-/* This says how to output an assembler line\n-   to define a global common symbol.  */\n-\n-#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)  \\\n-  asm_output_common (FILE, NAME, SIZE, ROUNDED);\n-\n-/* This says how to output an assembler line\n-   to define a local common symbol.  */\n-\n-#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)  \\\n-  asm_output_local (FILE, NAME, SIZE, ROUNDED);\n-\f\n-/* OUTPUT AND GENERATION OF LABELS */\n-\n-/* Globalizing directive for a label.  */\n-#define GLOBAL_ASM_OP \".global \"\n-\n-/* A C statement to output to the stdio stream any text necessary\n-   for declaring the name of an external symbol named name which\n-   is referenced in this compilation but not defined.  */\n-\n-#define ASM_OUTPUT_EXTERNAL(FILE, DECL, NAME)   \\\n-{\t\t\t\t\t\\\n-\tfprintf (FILE, \".extern \");\t\\\n-\tassemble_name (FILE, NAME);\t\\\n-\tfprintf (FILE, \"\\n\");\t\t\\\n-}\n-/* A C statement to output on stream an assembler pseudo-op to\n-   declare a library function named external.  */\n-\n-#define ASM_OUTPUT_EXTERNAL_LIBCALL(FILE, FUN)    \\\n-{\t\t\t\t\t\t\\\n-\tfprintf (FILE, \".extern \");\t\t\\\n-\tassemble_name (FILE, XSTR (FUN, 0));\t\\\n-\tfprintf (FILE, \"\\n\");\t\t\t\\\n-}\n-\n-/* The prefix to add to user-visible assembler symbols.  */\n-\n-#define USER_LABEL_PREFIX \"_\"\n-\n-/* This is how to store into the string LABEL\n-   the symbol_ref name of an internal numbered label where\n-   PREFIX is the class of label and NUM is the number within the class.\n-   This is suitable for output with `assemble_name'.  */\n-#define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)\t\\\n-  sprintf (LABEL, \"*%s%lu\", PREFIX, (unsigned long)(NUM))\n-\n-\f\n-/* OUTPUT OF ASSEMBLER INSTRUCTIONS */\n-\n-/* How to refer to registers in assembler output.\n-   This sequence is indexed by compiler's hard-register-number (see above).  */\n-\n-#define REGISTER_NAMES \\\n-{\"a0\", \"a0l\", \"a1\", \"a1l\", \"x\", \"y\", \"yl\", \"p\", \"pl\",  \\\n- \"r0\", \"r1\", \"r2\",  \"r3\", \"j\", \"k\", \"ybase\", \"pt\",     \\\n- \"ar0\", \"ar1\", \"ar2\", \"ar3\",                           \\\n- \"c0\", \"c1\", \"c2\", \"pr\", \"rb\",                         \\\n- \"*(0)\", \"*(1)\", \"*(2)\", \"*(3)\", \"*(4)\", \"*(5)\",       \\\n- \"*(6)\", \"*(7)\", \"*(8)\", \"*(9)\", \"*(10)\", \"*(11)\",     \\\n- \"*(12)\", \"*(13)\", \"*(14)\", \"*(15)\", \"*(16)\", \"*(17)\", \\\n- \"*(18)\", \"*(19)\", \"*(20)\", \"*(21)\", \"*(22)\", \"*(23)\", \\\n- \"*(24)\", \"*(25)\", \"*(26)\", \"*(27)\", \"*(28)\", \"*(29)\", \\\n- \"*(30)\", \"*(31)\" }\n-\n-#define HIMODE_REGISTER_NAMES \\\n-{\"a0\", \"a0\", \"a1\", \"a1\", \"x\", \"y\", \"y\", \"p\", \"p\",  \\\n- \"r0\", \"r1\", \"r2\",  \"r3\", \"j\", \"k\", \"ybase\", \"pt\",     \\\n- \"ar0\", \"ar1\", \"ar2\", \"ar3\",                           \\\n- \"c0\", \"c1\", \"c2\", \"pr\", \"rb\",                         \\\n- \"*(0)\", \"*(1)\", \"*(2)\", \"*(3)\", \"*(4)\", \"*(5)\",       \\\n- \"*(6)\", \"*(7)\", \"*(8)\", \"*(9)\", \"*(10)\", \"*(11)\",     \\\n- \"*(12)\", \"*(13)\", \"*(14)\", \"*(15)\", \"*(16)\", \"*(17)\", \\\n- \"*(18)\", \"*(19)\", \"*(20)\", \"*(21)\", \"*(22)\", \"*(23)\", \\\n- \"*(24)\", \"*(25)\", \"*(26)\", \"*(27)\", \"*(28)\", \"*(29)\", \\\n- \"*(30)\", \"*(31)\" }\n-\n-#define PRINT_OPERAND_PUNCT_VALID_P(CODE)  0\n-\n-/* Print operand X (an rtx) in assembler syntax to file FILE.\n-   CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n-   For `%' followed by punctuation, CODE is the punctuation and X is null.\n-   \n-   DSP1610 extensions for operand codes:\n-\n-   %H - print lower 16 bits of constant\n-   %U - print upper 16 bits of constant\n-   %w - print low half of register (e.g 'a0l')\n-   %u - print upper half of register (e.g 'a0')\n-   %b - print high half of accumulator for F3 ALU instructions\n-   %h - print constant in decimal   */\n-\n-#define PRINT_OPERAND(FILE, X, CODE) print_operand(FILE, X, CODE)\n-\n-\n-/* Print a memory address as an operand to reference that memory location.  */\n-\n-#define PRINT_OPERAND_ADDRESS(FILE, ADDR)  print_operand_address (FILE, ADDR)\n-\n-/* This is how to output an insn to push a register on the stack.\n-   It need not be very fast code since it is used only for profiling  */\n-#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)    \\\n-  internal_error (\"profiling not implemented yet\");\n-\n-/* This is how to output an insn to pop a register from the stack.\n-   It need not be very fast code since it is used only for profiling  */\n-#define ASM_OUTPUT_REG_POP(FILE,REGNO)     \\\n-  internal_error (\"profiling not implemented yet\"); \n-\f\n-/* OUTPUT OF DISPATCH TABLES */\n-\n-/* This macro should be provided on machines where the addresses in a dispatch\n-   table are relative to the table's own address.  */\n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)  \\\n-  fprintf (FILE, \"\\tint L%d-L%d\\n\", VALUE, REL)\n-\n-/* This macro should be provided on machines where the addresses in a dispatch\n-   table are absolute.  */\n-#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n-  fprintf (FILE, \"\\tint L%d\\n\", VALUE)\n-\n-/* ASSEMBLER COMMANDS FOR ALIGNMENT */\n-\n-/* This is how to output an assembler line that says to advance \n-   the location counter to a multiple of 2**LOG bytes. We should\n-   not have to do any alignment since the 1610 is a word machine.  */\n-#define ASM_OUTPUT_ALIGN(FILE,LOG)\n-\n-/* Define this macro if ASM_OUTPUT_SKIP should not be used in the text section\n-   because it fails to put zero1 in the bytes that are skipped.  */\n-#define ASM_NO_SKIP_IN_TEXT 1\n-\n-#define ASM_OUTPUT_SKIP(FILE,SIZE)  \\\n-  fprintf (FILE, \"\\t%d * int 0\\n\", (int)(SIZE))\n-\n-/* CONTROLLING DEBUGGING INFORMATION FORMAT */\n-\n-#define PREFERRED_DEBUGGING_TYPE DWARF2_DEBUG\n-\n-#define ASM_OUTPUT_DEF(asm_out_file, LABEL1, LABEL2) \\\n-         do {\t\t\t\t\t\t\\\n-\t fprintf (asm_out_file, \".alias \" ); \\\n-         ASM_OUTPUT_LABELREF(asm_out_file, LABEL1);  \\\n-\t fprintf (asm_out_file, \"=\" ); \\\n-         ASM_OUTPUT_LABELREF(asm_out_file, LABEL2); \\\n-\t fprintf (asm_out_file, \"\\n\" );\t\t\t\\\n-\t } while (0)\n-\n-\f\n-/* MISCELLANEOUS PARAMETERS */\n-\n-/* Specify the machine mode that this machine uses\n-   for the index in the tablejump instruction.  */\n-#define CASE_VECTOR_MODE QImode\n-\n-/* Define as C expression which evaluates to nonzero if the tablejump\n-   instruction expects the table to contain offsets from the address of the\n-   table.\n-   Do not define this if the table should contain absolute addresses.  */\n-/* #define CASE_VECTOR_PC_RELATIVE 1 */\n-\n-/* Max number of bytes we can move from memory to memory\n-   in one reasonably fast instruction.  */\n-#define MOVE_MAX 1\n-\n-/* Defining this macro causes the compiler to omit a sign-extend, zero-extend,\n-   or bitwise 'and' instruction that truncates the count of a shift operation\n-   to a width equal to the number of bits needed to represent the size of the\n-   object being shifted. Do not define this macro unless the truncation applies\n-   to both shift operations and bit-field operations (if any).  */\n-/* #define SHIFT_COUNT_TRUNCATED */\n-\n-/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n-   is done just by pretending it is already truncated.  */\n-#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n-\n-/* When a prototype says `char' or `short', really pass an `int'.  */\n-#define PROMOTE_PROTOTYPES 1\n-\n-/* An alias for the machine mode used for pointers */\n-#define Pmode  QImode\n-\n-/* A function address in a call instruction\n-   is a byte address (for indexing purposes)\n-   so give the MEM rtx a byte's mode.  */\n-#define FUNCTION_MODE  QImode\n-\n-#if !defined(__DATE__)\n-#define TARGET_VERSION fprintf (stderr, \" (%s)\", VERSION_INFO1)\n-#else\n-#define TARGET_VERSION fprintf (stderr, \" (%s, %s)\", VERSION_INFO1, __DATE__)\n-#endif\n-\n-#define VERSION_INFO1 \"Lucent DSP16xx C Cross Compiler, version 1.3.0b\"\n-\n-\n-/* Define this as 1 if `char' should by default be signed; else as 0.  */\n-#define DEFAULT_SIGNED_CHAR 1\n-\n-/* Define this so gcc does not output a call to __main, since we\n-   are not currently supporting c++.  */\n-#define INIT_SECTION_ASM_OP  1\n-"}, {"sha": "fffd2a9d9e0b9e6333ca2b945fafe4385094afd8", "filename": "gcc/config/dsp16xx/dsp16xx.md", "status": "removed", "additions": 0, "deletions": 3049, "changes": 3049, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.md?ref=c3bf16ff7dec47581f450b1a486cfdf9d566927e"}, {"sha": "56c6342dc64675d91fed1431520d6b17f2ffbac4", "filename": "gcc/config/i370/README", "status": "removed", "additions": 0, "deletions": 125, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fi370%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fi370%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2FREADME?ref=c3bf16ff7dec47581f450b1a486cfdf9d566927e", "patch": "@@ -1,125 +0,0 @@\n-\n-This directory contains code for building a compiler for the\n-32-bit ESA/390 architecture.  It supports three different styles \n-of assembly:\n-\n--- MVS for use with the HLASM assembler\n--- Open Edition (USS Unix System Services) \n--- ELF/Linux for use with the binutils/gas GNU assembler.\n-\n-\n-Cross-compiling Hints\n----------------------\n-When building a cross-compiler on AIX, set the environment variable CC\n-and be sure to set the -ma and -qcpluscmt flags; i.e.\n-\n-   export CC=\"cc -ma -qcpluscmt\"\n-\n-do this *before* running configure, e.g.\n-\n-   configure --target=i370-ibm-linux --prefix=/where/to/install/usr\n-\n-The Objective-C and FORTRAN front ends don't build.  To avoid looking at\n-errors, do only \n-\n-   make LANGUAGES=c\n-\n-\n-OpenEdition Hints\n------------------\n-The shell script \"install\" is handy for users of OpenEdition.\n-\n-\n-The ELF ABI\n------------\n-This compiler, in conjunction with the gas/binutils assembler, defines\n-a defacto ELF-based ABI for the ESA/390 architecture.  Be warned: this \n-ABI has several major faults.  It should be fixed.  As it is fixed,\n-it is subject to change without warning.  You should not commit to major\n-software systems without further exploring and fixing these problems.\n-Here are some of the problems:\n-\n--- No support for shared libraries or dynamically loadable objects.\n-   This is because the compiler currently places address literals in \n-   the text section.  Although the GAS assembler supports a syntax for \n-   USING that will place address literals in the data section, this forces\n-   the use of two base registers, one for branches and one for the literal \n-   pool. Work is needed to redesign the function prologue, epilogue and the \n-   base register reloads to minimize the currently excessive use of reserved \n-   registers. \n-\n-   I beleive the best solution would be to add a toc or plt, and extending\n-   the meaning of the USING directive to encompass this.  This would \n-   allow the continued use of the human-readable and familiar practice\n-   of using =A() and =F'' to denote address literals, as opposed to more \n-   difficult jump-table notation.\n-\n--- the stackframe is almost twice as big as it needs to be.\n-\n--- currently, r15 is used to return 32-bit values.  Because this is the\n-   last register, it prevents 64-bit ints and small structures from being \n-   returned in registers, forcing return in memory.  It would be more\n-   efficient to use r14 to return 32-bit values, and r14+r15 to return\n-   64-bit values.\n-\n--- all arguments are currently passed in memory.  It would be more efficient \n-   to pass arguments in registers.\n-\n-\n-\n-\n-ChangeLog\n----------\n-Oct98-Dec98 -- add ELF back end; work on getting ABI more or less functional.\n-98.12.05 -- fix numerous MVC bugs\n-99.02.06 -- multiply insn sometimes not generated when needed.\n-         -- extendsidi bugs, bad literal values printed\n-         -- remove broken adddi subdi patterns\n-99.02.15 -- add clrstrsi pattern\n-         -- fix -O2 divide bug\n-99.03.04 -- base & index reg usage bugs\n-99.03.15 -- fixes for returning long longs and structs (struct value return)\n-99.03.29 -- fix handling & alignment of shorts\n-99.03.31 -- clobbered register 14 is not always clobbered\n-99.04.02 -- operand constraints for cmphi\n-99.04.07 -- function pointer fixes for call, call_value patterns,\n-            function pointers derefed once too often.\n-99.04.14 -- add pattern to print double-wide int\n-         -- check intval<4096 for misc operands\n-         -- add clrstrsi pattern\n-         -- movstrsi fixes\n-99.04.16 -- use r2 to pass args into r11 in subroutine call.\n-         -- fixes to movsi; some operand combinations impossible;\n-            rework constraints\n-         -- start work on forward jump optimization\n-         -- char alignment bug\n-99.04.25 -- add untyped_call pattern so that builtin_apply works\n-99.04.27 -- fixes to compare logical under mask\n-99.04.28 -- reg 2 is clobbered by calls\n-99.04.30 -- fix rare mulsi bug\n-99.04.30 -- add constraints so that all RS, SI, SS forms insns have valid\n-            addressing modes\n-99.04.30 -- major condition code fixes. The old code was just way off \n-            w.r.t. which insns set condition code, and the codes that\n-            were set.  The extent of this damage was unbeleivable.\n-99.05.01 -- restructuring of operand constraints on many patterns,\n-            many lead to invalid instructions being genned.\n-99.05.02 -- float pt fixes\n-         -- fix movdi issue bugs\n-99.05.03 -- fix divide insn; was dividing incorrectly\n-99.05.05 -- fix sign extension problems on andhi\n-         -- deprecate some constraints\n-99.05.06 -- add set_attr insn lengths; fix misc litpool sizes\n-         -- add notes about how unsigned jumps work (i.e. \n-            arithmetic vs. logical vs. signed vs unsigned).\n-99.05.11 -- use insn length to predict forward branch target;\n-            use relative branchining where possible,\n-            remove un-needed base register reload.\n-99.05.15 -- fix movstrsi, clrstrsi, cmpstrsi patterns as per conversation \n-            w/ Richard Henderson\n-\n-\n-\n-\n-\n-"}, {"sha": "fe39191cfa294103639ca3a1632bc3fa8a674ca0", "filename": "gcc/config/i370/i370-c.c", "status": "removed", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fi370%2Fi370-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fi370%2Fi370-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fi370-c.c?ref=c3bf16ff7dec47581f450b1a486cfdf9d566927e", "patch": "@@ -1,64 +0,0 @@\n-/* Subroutines for the C front end for System/370.\n-   Copyright (C) 1989, 1993, 1995, 1997, 1998, 1999, 2000\n-   Free Software Foundation, Inc.\n-   Contributed by Jan Stein (jan@cd.chalmers.se).\n-   Modified for OS/390 LanguageEnvironment C by Dave Pitts (dpitts@cozx.com)\n-   Hacked for Linux-ELF/390 by Linas Vepstas (linas@linas.org) \n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"tree.h\"\n-#include \"toplev.h\"\n-#include \"cpplib.h\"\n-#include \"c-pragma.h\"\n-#include \"tm_p.h\"\n-\n-#ifdef TARGET_HLASM\n-\n-/* #pragma map (name, alias) -\n-   In this implementation both name and alias are required to be\n-   identifiers.  The older code seemed to be more permissive.  Can\n-   anyone clarify?  */\n-\n-void\n-i370_pr_map (pfile)\n-     cpp_reader *pfile ATTRIBUTE_UNUSED;\n-{\n-  tree name, alias, x;\n-\n-  if (c_lex (&x)        == CPP_OPEN_PAREN\n-      && c_lex (&name)  == CPP_NAME\n-      && c_lex (&x)     == CPP_COMMA\n-      && c_lex (&alias) == CPP_NAME\n-      && c_lex (&x)     == CPP_CLOSE_PAREN)\n-    {\n-      if (c_lex (&x) != CPP_EOF)\n-\twarning (\"junk at end of #pragma map\");\n-\n-      mvs_add_alias (IDENTIFIER_POINTER (name), IDENTIFIER_POINTER (alias), 1);\n-      return;\n-    }\n-\n-  warning (\"malformed #pragma map, ignored\");\n-}\n-\n-#endif"}, {"sha": "666db0b7aa601bcf78890bfc079009cf9f14e4de", "filename": "gcc/config/i370/i370-protos.h", "status": "removed", "additions": 0, "deletions": 55, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fi370%2Fi370-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fi370%2Fi370-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fi370-protos.h?ref=c3bf16ff7dec47581f450b1a486cfdf9d566927e", "patch": "@@ -1,55 +0,0 @@\n-/* Definitions of target machine for GNU compiler.  System/370 version.\n-   Copyright (C) 2000 Free Software Foundation, Inc.\n-   Contributed by Jan Stein (jan@cd.chalmers.se).\n-   Modified for OS/390 LanguageEnvironment C by Dave Pitts (dpitts@cozx.com)\n-   Hacked for Linux-ELF/390 by Linas Vepstas (linas@linas.org)\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#ifndef GCC_I370_PROTOS_H\n-#define GCC_I370_PROTOS_H\n-\n-extern void override_options (void);\n-\n-#ifdef RTX_CODE\n-extern int i370_branch_dest (rtx);\n-extern int i370_branch_length (rtx);\n-extern int i370_short_branch (rtx);\n-extern int s_operand (rtx, enum machine_mode);\n-extern int r_or_s_operand (rtx, enum machine_mode);\n-extern int unsigned_jump_follows_p (rtx);\n-#endif /* RTX_CODE */\n-\n-#ifdef TREE_CODE\n-extern int handle_pragma (int (*)(void), void (*)(int), const char *);\n-#endif /* TREE_CODE */\n-\n-extern void mvs_add_label (int);\n-extern int mvs_check_label (int);\n-extern int mvs_check_page (FILE *, int, int);\n-extern int mvs_function_check (const char *);\n-extern void mvs_add_alias (const char *, const char *, int);\n-extern int mvs_need_alias (const char *);\n-extern int mvs_get_alias (const char *, char *);\n-extern int mvs_check_alias (const char *, char *);\n-extern void check_label_emit (void);\n-extern void mvs_free_label_list (void);\n-\n-extern void i370_pr_map (struct cpp_reader *);\n-\n-#endif /* ! GCC_I370_PROTOS_H */"}, {"sha": "2cfe4fe3269013f889dad8d0c4c01b2c5f545723", "filename": "gcc/config/i370/i370.c", "status": "removed", "additions": 0, "deletions": 1514, "changes": 1514, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fi370%2Fi370.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fi370%2Fi370.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fi370.c?ref=c3bf16ff7dec47581f450b1a486cfdf9d566927e", "patch": "@@ -1,1514 +0,0 @@\n-/* Subroutines for insn-output.c for System/370.\n-   Copyright (C) 1989, 1993, 1995, 1997, 1998, 1999, 2000, 2002\n-   Free Software Foundation, Inc.\n-   Contributed by Jan Stein (jan@cd.chalmers.se).\n-   Modified for OS/390 LanguageEnvironment C by Dave Pitts (dpitts@cozx.com)\n-   Hacked for Linux-ELF/390 by Linas Vepstas (linas@linas.org) \n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"rtl.h\"\n-#include \"tree.h\"\n-#include \"regs.h\"\n-#include \"hard-reg-set.h\"\n-#include \"real.h\"\n-#include \"insn-config.h\"\n-#include \"conditions.h\"\n-#include \"output.h\"\n-#include \"insn-attr.h\"\n-#include \"function.h\"\n-#include \"expr.h\"\n-#include \"flags.h\"\n-#include \"recog.h\"\n-#include \"toplev.h\"\n-#include \"cpplib.h\"\n-#include \"tm_p.h\"\n-#include \"target.h\"\n-#include \"target-def.h\"\n-\n-extern FILE *asm_out_file;\n-\n-/* Label node.  This structure is used to keep track of labels \n-      on the various pages in the current routine.\n-   The label_id is the numeric ID of the label,\n-   The label_page is the page on which it actually appears,\n-   The first_ref_page is the page on which the true first ref appears.\n-   The label_addr is an estimate of its location in the current routine,\n-   The label_first & last_ref are estimates of where the earliest and\n-      latest references to this label occur.  */\n-\n-typedef struct label_node\n-  {\n-    struct label_node *label_next;\n-    int label_id;\n-    int label_page;\n-    int first_ref_page;\n-\n-    int label_addr;\n-    int label_first_ref;\n-    int label_last_ref;\n-  }\n-label_node_t;\n-\n-/* Is 1 when a label has been generated and the base register must be reloaded.  */\n-int mvs_need_base_reload = 0;\n-\n-/* Current function starting base page.  */\n-int function_base_page;\n-\n-/* Length of the current page code.  */\n-int mvs_page_code;\n-\n-/* Length of the current page literals.  */\n-int mvs_page_lit;\n-\n-/* Current function name.  */\n-char *mvs_function_name = 0;\n-\n-/* Current function name length.  */\n-size_t mvs_function_name_length = 0;\n-\n-/* Page number for multi-page functions.  */\n-int mvs_page_num = 0;\n-\n-/* Label node list anchor.  */\n-static label_node_t *label_anchor = 0;\n-\n-/* Label node free list anchor.  */\n-static label_node_t *free_anchor = 0;\n-\n-/* Assembler source file descriptor.  */\n-static FILE *assembler_source = 0;\n-\n-static label_node_t * mvs_get_label (int);\n-static void i370_label_scan (void);\n-#ifdef TARGET_HLASM\n-static bool i370_hlasm_assemble_integer (rtx, unsigned int, int);\n-static void i370_globalize_label (FILE *, const char *);\n-#endif\n-static void i370_output_function_prologue (FILE *, HOST_WIDE_INT);\n-static void i370_output_function_epilogue (FILE *, HOST_WIDE_INT);\n-static void i370_file_start (void);\n-static void i370_file_end (void);\n-\n-#ifdef LONGEXTERNAL\n-static int mvs_hash_alias (const char *);\n-#endif\n-static void i370_internal_label (FILE *, const char *, unsigned long);\n-static bool i370_rtx_costs (rtx, int, int, int *);\n-\n-/* ===================================================== */\n-/* defines and functions specific to the HLASM assembler */\n-#ifdef TARGET_HLASM\n-\n-#define MVS_HASH_PRIME 999983\n-#if HOST_CHARSET == HOST_CHARSET_EBCDIC\n-#define MVS_SET_SIZE 256\n-#else\n-#define MVS_SET_SIZE 128\n-#endif\n-\n-#ifndef MAX_MVS_LABEL_SIZE\n-#define MAX_MVS_LABEL_SIZE 8\n-#endif\n-\n-#define MAX_LONG_LABEL_SIZE 255\n-\n-/* Alias node, this structure is used to keep track of aliases to external\n-   variables. The IBM assembler allows an alias to an external name \n-   that is longer that 8 characters; but only once per assembly.\n-   Also, this structure stores the #pragma map info.  */\n-typedef struct alias_node\n-  {\n-    struct alias_node *alias_next;\n-    int  alias_emitted;\n-    char alias_name [MAX_MVS_LABEL_SIZE + 1];\n-    char real_name [MAX_LONG_LABEL_SIZE + 1];\n-  }\n-alias_node_t;\n-\n-/* Alias node list anchor.  */\n-static alias_node_t *alias_anchor = 0;\n-\n-/* Define the length of the internal MVS function table.  */\n-#define MVS_FUNCTION_TABLE_LENGTH 32\n-\n-/* C/370 internal function table.  These functions use non-standard linkage\n-   and must handled in a special manner.  */\n-static const char *const mvs_function_table[MVS_FUNCTION_TABLE_LENGTH] =\n-{\n-#if HOST_CHARSET == HOST_CHARSET_EBCDIC /* Changed for EBCDIC collating sequence */\n-   \"ceil\",     \"edc_acos\", \"edc_asin\", \"edc_atan\", \"edc_ata2\", \"edc_cos\",\n-   \"edc_cosh\", \"edc_erf\",  \"edc_erfc\", \"edc_exp\",  \"edc_gamm\", \"edc_lg10\",\n-   \"edc_log\",  \"edc_sin\",  \"edc_sinh\", \"edc_sqrt\", \"edc_tan\",  \"edc_tanh\",\n-   \"fabs\",     \"floor\",    \"fmod\",     \"frexp\",    \"hypot\",    \"jn\",\n-   \"j0\",       \"j1\",       \"ldexp\",    \"modf\",     \"pow\",      \"yn\",\n-   \"y0\",       \"y1\"\n-#else\n-   \"ceil\",     \"edc_acos\", \"edc_asin\", \"edc_ata2\", \"edc_atan\", \"edc_cos\",\n-   \"edc_cosh\", \"edc_erf\",  \"edc_erfc\", \"edc_exp\",  \"edc_gamm\", \"edc_lg10\",\n-   \"edc_log\",  \"edc_sin\",  \"edc_sinh\", \"edc_sqrt\", \"edc_tan\",  \"edc_tanh\",\n-   \"fabs\",     \"floor\",    \"fmod\",     \"frexp\",    \"hypot\",    \"j0\",\n-   \"j1\",       \"jn\",       \"ldexp\",    \"modf\",     \"pow\",      \"y0\",\n-   \"y1\",       \"yn\"\n-#endif\n-};\n-\n-#endif /* TARGET_HLASM */\n-/* ===================================================== */\n-\n-\f\n-/* Initialize the GCC target structure.  */\n-#ifdef TARGET_HLASM\n-#undef TARGET_ASM_BYTE_OP\n-#define TARGET_ASM_BYTE_OP NULL\n-#undef TARGET_ASM_ALIGNED_HI_OP\n-#define TARGET_ASM_ALIGNED_HI_OP NULL\n-#undef TARGET_ASM_ALIGNED_SI_OP\n-#define TARGET_ASM_ALIGNED_SI_OP NULL\n-#undef TARGET_ASM_INTEGER\n-#define TARGET_ASM_INTEGER i370_hlasm_assemble_integer\n-#undef TARGET_ASM_GLOBALIZE_LABEL\n-#define TARGET_ASM_GLOBALIZE_LABEL i370_globalize_label\n-#endif\n-\n-#undef TARGET_ASM_FUNCTION_PROLOGUE\n-#define TARGET_ASM_FUNCTION_PROLOGUE i370_output_function_prologue\n-#undef TARGET_ASM_FUNCTION_EPILOGUE\n-#define TARGET_ASM_FUNCTION_EPILOGUE i370_output_function_epilogue\n-#undef TARGET_ASM_FILE_START\n-#define TARGET_ASM_FILE_START i370_file_start\n-#undef TARGET_ASM_FILE_END\n-#define TARGET_ASM_FILE_END i370_file_end\n-#undef TARGET_ASM_INTERNAL_LABEL\n-#define  TARGET_ASM_INTERNAL_LABEL i370_internal_label\n-#undef TARGET_RTX_COSTS\n-#define TARGET_RTX_COSTS i370_rtx_costs\n-\n-struct gcc_target targetm = TARGET_INITIALIZER;\n-\f\n-/* Set global variables as needed for the options enabled.  */\n-\n-void\n-override_options ()\n-{\n-  /* We're 370 floating point, not IEEE floating point.  */\n-  memset (real_format_for_mode, 0, sizeof real_format_for_mode);\n-  REAL_MODE_FORMAT (SFmode) = &i370_single_format;\n-  REAL_MODE_FORMAT (DFmode) = &i370_double_format;\n-}\n-\n-/* ===================================================== */\n-/* The following three routines are used to determine whther \n-   forward branch is on this page, or is a far jump.  We use\n-   the \"length\" attr on an insn [(set_atter \"length\" \"4\")]\n-   to store the largest possible code length that insn\n-   could have.  This gives us a hint of the address of a\n-   branch destination, and from that, we can work out \n-   the length of the jump, and whether its on page or not. \n- */\n-\n-/* Return the destination address of a branch.  */\n-\n-int\n-i370_branch_dest (branch)\n-     rtx branch;\n-{\n-  rtx dest = SET_SRC (PATTERN (branch));\n-  int dest_uid;\n-  int dest_addr;\n-\n-  /* first, compute the estimated address of the branch target */\n-  if (GET_CODE (dest) == IF_THEN_ELSE)\n-    dest = XEXP (dest, 1);\n-  dest = XEXP (dest, 0);\n-  dest_uid = INSN_UID (dest);\n-  dest_addr = INSN_ADDRESSES (dest_uid);\n-\n-  /* next, record the address of this insn as the true addr of first ref */\n-  {\n-     label_node_t *lp;\n-     rtx label = JUMP_LABEL (branch);\n-     int labelno = CODE_LABEL_NUMBER (label);\n-\n-     if (!label || CODE_LABEL != GET_CODE (label)) abort ();\n-\n-     lp = mvs_get_label (labelno);\n-     if (-1 == lp -> first_ref_page) lp->first_ref_page = mvs_page_num;\n-  }\n-  return dest_addr;\n-}\n-\n-int\n-i370_branch_length (insn)\n-     rtx insn;\n-{\n-  int here, there;\n-  here = INSN_ADDRESSES (INSN_UID (insn));\n-  there = i370_branch_dest (insn);\n-  return (there - here);\n-}\n-\n-\n-int\n-i370_short_branch (insn)\n-     rtx insn;\n-{\n-  int base_offset;\n-\n-  base_offset = i370_branch_length(insn);\n-  if (0 > base_offset) \n-    {\n-      base_offset += mvs_page_code;\n-    } \n-  else \n-    {\n-      /* avoid bumping into lit pool; use 2x to estimate max possible lits */\n-      base_offset *= 2;\n-      base_offset += mvs_page_code + mvs_page_lit;\n-    }\n-  \n-  /* make a conservative estimate of room left on page */\n-  if ((4060 >base_offset) && ( 0 < base_offset)) return 1;\n-  return 0;\n-}\n-\n-/* The i370_label_scan() routine is supposed to loop over\n-   all labels and label references in a compilation unit,\n-   and determine whether all label refs appear on the same \n-   code page as the label. If they do, then we can avoid \n-   a reload of the base register for that label.\n-  \n-   Note that the instruction addresses used here are only \n-   approximate, and make the sizes of the jumps appear\n-   farther apart then they will actually be.  This makes \n-   this code far more conservative than it needs to be.\n- */\n-\n-#define I370_RECORD_LABEL_REF(label,addr) {\t\t\t\t\\\n-\tlabel_node_t *lp;\t\t\t\t\t\t\\\n-\tint labelno = CODE_LABEL_NUMBER (label);\t\t\t\\\n-\tlp = mvs_get_label (labelno);\t\t\t\t\t\\\n-\tif (addr < lp -> label_first_ref) lp->label_first_ref = addr;\t\\\n-\tif (addr > lp -> label_last_ref) lp->label_last_ref = addr;\t\\\n-}\n-\n-static void \n-i370_label_scan () \n-{\n-   rtx insn;\n-   label_node_t *lp;\n-   int tablejump_offset = 0;\n-\n-   for (insn = get_insns(); insn; insn = NEXT_INSN(insn))\n-     {\n-       int here = INSN_ADDRESSES (INSN_UID (insn));\n-       enum rtx_code code = GET_CODE(insn);\n-\n-       /* ??? adjust for tables embedded in the .text section that\n-        * the compiler didn't take into account */\n-       here += tablejump_offset;\n-       INSN_ADDRESSES (INSN_UID (insn)) = here;\n-\n-       /* check to see if this insn is a label ...  */\n-       if (CODE_LABEL == code)\n-         {\n-           int labelno = CODE_LABEL_NUMBER (insn);\n-\n-           lp = mvs_get_label (labelno);\n-           lp -> label_addr = here;\n-#if 0\n-           /* Supposedly, labels are supposed to have circular\n-              lists of label-refs that reference them, \n-              setup in flow.c, but this does not appear to be the case.  */\n-           rtx labelref = LABEL_REFS (insn);\n-           rtx ref = labelref;\n-           do \n-             {\n-               rtx linsn = CONTAINING_INSN(ref);\n-               ref =  LABEL_NEXTREF(ref);\n-             } while (ref && (ref != labelref));\n-#endif\n-         }\n-       else\n-       if (JUMP_INSN == code)\n-         {\n-           rtx label = JUMP_LABEL (insn);\n-\n-           /* If there is no label for this jump, then this\n-              had better be a ADDR_VEC or an ADDR_DIFF_VEC\n-              and there had better be a vector of labels.  */\n-           if (!label) \n-             {\n-               int j;\n-               rtx body = PATTERN (insn);\n-               if (ADDR_VEC == GET_CODE(body)) \n-                 {\n-                    for (j=0; j < XVECLEN (body, 0); j++)\n-                      {\n-                         rtx lref = XVECEXP (body, 0, j);\n-                         if (LABEL_REF != GET_CODE (lref)) abort ();\n-                         label = XEXP (lref,0);\n-                         if (CODE_LABEL != GET_CODE (label)) abort ();\n-                         tablejump_offset += 4;\n-                         here += 4;\n-                         I370_RECORD_LABEL_REF(label,here);\n-                      }\n-                    /* finished with the vector go do next insn */\n-                    continue;\n-                 }\n-               else\n-               if (ADDR_DIFF_VEC == GET_CODE(body))\n-                 {\n-/* XXX hack alert.\n-   Right now, we leave this as a no-op, but strictly speaking,\n-   this is incorrect.  It is possible that a table-jump\n-   driven off of a relative address could take us off-page,\n-   to a place where we need to reload the base reg.  So really,\n-   we need to examing both labels, and compare thier values\n-   to the current basereg value.\n-  \n-   More generally, this brings up a troubling issue overall:\n-   what happens if a tablejump is split across two pages? I do \n-   not beleive that this case is handled correctly at all, and\n-   can only lead to horrible results if this were to occur.\n-  \n-   However, the current situation is not any worse than it was \n-   last week, and so we punt for now.  */\n-\n-                    debug_rtx (insn);\n-                    for (j=0; j < XVECLEN (body, 0); j++)\n-                      {\n-                      }\n-                    /* finished with the vector go do next insn */\n-                    continue;\n-                 }\n-               else \n-                 {\n-/* XXX hack alert.\n-   Compiling the exception handling (L_eh) in libgcc2.a will trip\n-   up right here, with something that looks like\n-   (set (pc) (mem:SI (plus:SI (reg/v:SI 1 r1) (const_int 4))))\n-      {indirect_jump} \n-   I'm not sure of what leads up to this, but it looks like\n-   the makings of a long jump which will surely get us into trouble\n-   because the base & page registers don't get reloaded.  For now\n-   I'm not sure of what to do ... again we punt ... we are not worse\n-   off than yesterday.  */\n-\n-                    /* print_rtl_single (stdout, insn); */\n-                    debug_rtx (insn);\n-                    /* abort(); */\n-                    continue;\n-                 }\n-            }\n-          else\n-            {\n-              /* At this point, this jump_insn had better be a plain-old\n-                 ordinary one, grap the label id and go */\n-              if (CODE_LABEL != GET_CODE (label)) abort ();\n-              I370_RECORD_LABEL_REF(label,here);\n-            }\n-        }\n-\n-      /* Sometimes, we take addresses of labels and use them\n-         as instruction operands ... these show up as REG_NOTES */\n-      else\n-      if (INSN == code)\n-       {\n-         if ('i' == GET_RTX_CLASS (code)) \n-           {\n-              rtx note;\n-              for (note = REG_NOTES (insn); note;  note = XEXP(note,1))\n-                {\n-                   if (REG_LABEL == REG_NOTE_KIND(note))\n-                     {\n-                        rtx label = XEXP (note,0);\n-                        if (!label || CODE_LABEL != GET_CODE (label)) abort ();\n-\n-                        I370_RECORD_LABEL_REF(label,here);\n-                     }\n-                }\n-           }\n-       }\n-   }\n-}\n-\n-/* ===================================================== */\n-\n-/* Emit reload of base register if indicated.  This is to eliminate multiple\n-   reloads when several labels are generated pointing to the same place\n-   in the code.  \n-\n-   The page table is written at the end of the function. \n-   The entries in the page table look like\n-     .LPGT0:          // PGT0 EQU *\n-     .long .LPG0      // DC A(PG0)\n-     .long .LPG1      // DC A(PG1)\n-  while the prologue generates\n-      L       r4,=A(.LPGT0)\n-\n-  Note that this paging scheme breaks down if a single subroutine \n-  has more than about 10MB of code in it ... as long as humans write\n-  code, this shouldn't be a problem ...\n- */\n-\n-void\n-check_label_emit ()\n-{\n-  if (mvs_need_base_reload)\n-    {\n-      mvs_need_base_reload = 0;\n-\n-      mvs_page_code += 4;\n-      fprintf (assembler_source, \"\\tL\\t%d,%d(,%d)\\n\",\n-\t  BASE_REGISTER, (mvs_page_num - function_base_page) * 4,\n-\t  PAGE_REGISTER);\n-    }\n-}\n-\n-/* Add the label to the current page label list.  If a free element is available\n-   it will be used for the new label.  Otherwise, a label element will be\n-   allocated from memory.\n-   ID is the label number of the label being added to the list.  */\n-\n-static label_node_t *\n-mvs_get_label (id)\n-     int id;\n-{\n-  label_node_t *lp;\n-\n-  /* first, lets see if we already go one, if so, use that.  */\n-  for (lp = label_anchor; lp; lp = lp->label_next)\n-    {\n-      if (lp->label_id == id) return lp;\n-    }\n-\n-  /* not found, get a new one */\n-  if (free_anchor)\n-    {\n-      lp = free_anchor;\n-      free_anchor = lp->label_next;\n-    }\n-  else\n-    {\n-      lp = (label_node_t *) xmalloc (sizeof (label_node_t));\n-    }\n-\n-  /* initialize for new label */\n-  lp->label_id = id;\n-  lp->label_page = -1;\n-  lp->label_next = label_anchor;\n-  lp->label_first_ref = 2000123123;\n-  lp->label_last_ref = -1;\n-  lp->label_addr = -1;\n-  lp->first_ref_page = -1;\n-  label_anchor = lp;\n-\n-  return lp;\n-}\n-\n-void\n-mvs_add_label (id)\n-     int id;\n-{\n-  label_node_t *lp;\n-  int fwd_distance;\n-\n-  lp = mvs_get_label (id);\n-  lp->label_page = mvs_page_num;\n-\n-  /* OK, we just saw the label.  Determine if this label\n-   * needs a reload of the base register */\n-  if ((-1 != lp->first_ref_page) && \n-      (lp->first_ref_page != mvs_page_num)) \n-    {\n-      /* Yep; the first label_ref was on a different page.  */\n-      mvs_need_base_reload ++;\n-      return;\n-    }\n-\n-  /* Hmm.  Try to see if the estimated address of the last\n-     label_ref is on the current page.  If it is, then we\n-     don't need a base reg reload.  Note that this estimate\n-     is very conservatively handled; we'll tend to have \n-     a good bit more reloads than actually needed.  Someday,\n-     we should tighten the estimates (which are driven by\n-     the (set_att \"length\") insn attibute.\n-    \n-     Currently, we estimate that number of page literals \n-     same as number of insns, which is a vast overestimate,\n-     esp that the estimate of each insn size is its max size.  */\n-\n-  /* if latest ref comes before label, we are clear */\n-  if (lp->label_last_ref < lp->label_addr) return;\n-\n-  fwd_distance = lp->label_last_ref - lp->label_addr;\n-\n-  if (mvs_page_code + 2 * fwd_distance + mvs_page_lit < 4060) return;\n-\n-  mvs_need_base_reload ++;\n-}\n-\n-/* Check to see if the label is in the list and in the current\n-   page.  If not found, we have to make worst case assumption \n-   that label will be on a different page, and thus will have to\n-   generate a load and branch on register.  This is rather\n-   ugly for forward-jumps, but what can we do? For backward\n-   jumps on the same page we can branch directly to address.\n-   ID is the label number of the label being checked.  */\n-\n-int\n-mvs_check_label (id)\n-     int id;\n-{\n-  label_node_t *lp;\n-\n-  for (lp = label_anchor; lp; lp = lp->label_next)\n-    {\n-      if (lp->label_id == id) \n-        {\n-          if (lp->label_page == mvs_page_num) \n-            {\n-               return 1;\n-            } \n-          else \n-            {\n-\t       return 0;\n-            } \n-        }\n-    }\n-  return 0;\n-}\n-\n-/* Get the page on which the label sits.  This will be used to \n-   determine is a register reload is really needed.  */\n-\n-#if 0\n-int\n-mvs_get_label_page(int id)\n-{\n-  label_node_t *lp;\n-\n-  for (lp = label_anchor; lp; lp = lp->label_next)\n-    {\n-      if (lp->label_id == id)\n-\treturn lp->label_page;\n-    }\n-  return -1;\n-}\n-#endif\n-\n-/* The label list for the current page freed by linking the list onto the free\n-   label element chain.  */\n-\n-void\n-mvs_free_label_list ()\n-{\n-\n-  if (label_anchor)\n-    {\n-      label_node_t *last_lp = label_anchor;\n-      while (last_lp->label_next) last_lp = last_lp->label_next;\n-      last_lp->label_next = free_anchor;\n-      free_anchor = label_anchor;\n-    }\n-  label_anchor = 0;\n-}\n-\n-/* ====================================================================== */\n-/* If the page size limit is reached a new code page is started, and the base\n-   register is set to it.  This page break point is counted conservatively,\n-   most literals that have the same value are collapsed by the assembler.\n-   True is returned when a new page is started.\n-   FILE is the assembler output file descriptor.\n-   CODE is the length, in bytes, of the instruction to be emitted.\n-   LIT is the length of the literal to be emitted.  */\n-\n-#ifdef TARGET_HLASM\n-int\n-mvs_check_page (file, code, lit)\n-     FILE *file;\n-     int code, lit;\n-{\n-  if (file)\n-    assembler_source = file;\n-\n-  if (mvs_page_code + code + mvs_page_lit + lit > MAX_MVS_PAGE_LENGTH)\n-    {\n-      fprintf (assembler_source, \"\\tB\\tPGE%d\\n\", mvs_page_num);\n-      fprintf (assembler_source, \"\\tDS\\t0F\\n\");\n-      fprintf (assembler_source, \"\\tLTORG\\n\");\n-      fprintf (assembler_source, \"\\tDS\\t0F\\n\");\n-      fprintf (assembler_source, \"PGE%d\\tEQU\\t*\\n\", mvs_page_num);\n-      fprintf (assembler_source, \"\\tDROP\\t%d\\n\", BASE_REGISTER);\n-      mvs_page_num++;\n-      /* Safe to use BASR not BALR, since we are\n-       * not switching addressing mode here ...  */\n-      fprintf (assembler_source, \"\\tBASR\\t%d,0\\n\", BASE_REGISTER);\n-      fprintf (assembler_source, \"PG%d\\tEQU\\t*\\n\", mvs_page_num);\n-      fprintf (assembler_source, \"\\tUSING\\t*,%d\\n\", BASE_REGISTER);\n-      mvs_page_code = code;\n-      mvs_page_lit = lit;\n-      return 1;\n-    }\n-  mvs_page_code += code;\n-  mvs_page_lit += lit;\n-  return 0;\n-}\n-#endif /* TARGET_HLASM */\n-\n-\n-#ifdef TARGET_ELF_ABI\n-int\n-mvs_check_page (file, code, lit)\n-     FILE *file;\n-     int code, lit;\n-{\n-  if (file)\n-    assembler_source = file;\n-\n-  if (mvs_page_code + code + mvs_page_lit + lit > MAX_MVS_PAGE_LENGTH)\n-    {\n-      /* hop past the literal pool */\n-      fprintf (assembler_source, \"\\tB\\t.LPGE%d\\n\", mvs_page_num);\n-\n-      /* dump the literal pool. The .baligns are optional, since \n-       * ltorg will align to the size of the largest literal \n-       * (which is possibly 8 bytes) */\n-      fprintf (assembler_source, \"\\t.balign\\t4\\n\");\n-      fprintf (assembler_source, \"\\t.LTORG\\n\");\n-      fprintf (assembler_source, \"\\t.balign\\t4\\n\");\n-\n-      /* we continue execution here ...  */\n-      fprintf (assembler_source, \".LPGE%d:\\n\", mvs_page_num);\n-      fprintf (assembler_source, \"\\t.DROP\\t%d\\n\", BASE_REGISTER);\n-      mvs_page_num++;\n-\n-      /* BASR puts the contents of the PSW into r3\n-       * that is, r3 will be loaded with the address of \".\" */\n-      fprintf (assembler_source, \"\\tBASR\\tr%d,0\\n\", BASE_REGISTER);\n-      fprintf (assembler_source, \".LPG%d:\\n\", mvs_page_num);\n-      fprintf (assembler_source, \"\\t.USING\\t.,r%d\\n\", BASE_REGISTER);\n-      mvs_page_code = code;\n-      mvs_page_lit = lit;\n-      return 1;\n-    }\n-  mvs_page_code += code;\n-  mvs_page_lit += lit;\n-  return 0;\n-}\n-#endif /* TARGET_ELF_ABI */\n-\n-/* ===================================================== */\n-/* defines and functions specific to the HLASM assembler */\n-#ifdef TARGET_HLASM\n-\n-/* Check for C/370 runtime function, they don't use standard calling\n-   conventions.  True is returned if the function is in the table.\n-   NAME is the name of the current function.  */\n-\n-int\n-mvs_function_check (name)\n-     const char *name;\n-{\n-  int lower, middle, upper;\n-  int i;\n-\n-  lower = 0;\n-  upper = MVS_FUNCTION_TABLE_LENGTH - 1;\n-  while (lower <= upper)\n-    {\n-      middle = (lower + upper) / 2;\n-      i = strcmp (name, mvs_function_table[middle]);\n-      if (i == 0)\n-\treturn 1;\n-      if (i < 0)\n-\tupper = middle - 1;\n-      else\n-\tlower = middle + 1;\n-    }\n-  return 0;\n-}\n-\n-/* Generate a hash for a given key.  */\n-\n-#ifdef LONGEXTERNAL\n-static int\n-mvs_hash_alias (key)\n-     const char *key;\n-{\n-  int h;\n-  int i;\n-  int l = strlen (key);\n-\n-  h = key[0];\n-  for (i = 1; i < l; i++)\n-    h = ((h * MVS_SET_SIZE) + key[i]) % MVS_HASH_PRIME;\n-  return (h);\n-}\n-#endif\n-\n-/* Add the alias to the current alias list.  */\n-\n-void\n-mvs_add_alias (realname, aliasname, emitted)\n-     const char *realname;\n-     const char *aliasname;\n-     int   emitted;\n-{\n-  alias_node_t *ap;\n-\n-  ap = (alias_node_t *) xmalloc (sizeof (alias_node_t));\n-  if (strlen (realname) > MAX_LONG_LABEL_SIZE)\n-    {\n-      warning (\"real name is too long - alias ignored\");\n-      return;\n-    }\n-  if (strlen (aliasname) > MAX_MVS_LABEL_SIZE)\n-    {\n-      warning (\"alias name is too long - alias ignored\");\n-      return;\n-    }\n-      \n-  strcpy (ap->real_name, realname);\n-  strcpy (ap->alias_name, aliasname);\n-  ap->alias_emitted = emitted;\n-  ap->alias_next = alias_anchor;\n-  alias_anchor = ap;\n-}\n-\n-/* Check to see if the name needs aliasing. ie. the name is either:\n-     1. Longer than 8 characters\n-     2. Contains an underscore\n-     3. Is mixed case */\n-\n-int\n-mvs_need_alias (realname)\n-      const char *realname;\n-{\n-   int i, j = strlen (realname);\n-\n-   if (mvs_function_check (realname))\n-     return 0;\n-#if 0\n-   if (!strcmp (realname, \"gccmain\"))\n-     return 0;\n-   if (!strcmp (realname, \"main\"))\n-     return 0;\n-#endif\n-   if (j > MAX_MVS_LABEL_SIZE)\n-     return 1;\n-   if (strchr (realname, '_') != 0)\n-     return 1;\n-   if (ISUPPER (realname[0]))\n-     {\n-       for (i = 1; i < j; i++)\n-\t {\n-\t   if (ISLOWER (realname[i]))\n-\t     return 1;\n-\t }\n-     }\n-   else\n-     {\n-       for (i = 1; i < j; i++)\n-         {\n-\t   if (ISUPPER (realname[i]))\n-\t     return 1;\n-\t }\n-     }\n-\n-   return 0;\n-}\n-\n-/* Get the alias from the list. \n-   If 1 is returned then it's in the alias list, 0 if it was not */\n-\n-int\n-mvs_get_alias (realname, aliasname)\n-     const char *realname;\n-     char *aliasname;\n-{\n-#ifdef LONGEXTERNAL\n-  alias_node_t *ap;\n-\n-  for (ap = alias_anchor; ap; ap = ap->alias_next)\n-    {\n-      if (!strcmp (ap->real_name, realname))\n-\t{\n-\t  strcpy (aliasname, ap->alias_name);\n-\t  return 1;\n-\t}\n-    }\n-  if (mvs_need_alias (realname))\n-    {\n-      char c1, c2;\n-\n-      c1 = realname[0];\n-      c2 = realname[1];\n-      if (ISLOWER (c1)) c1 = TOUPPER (c1);\n-      else if (c1 == '_') c1 = 'A';\n-      if (ISLOWER (c2)) c2 = TOUPPER (c2);\n-      else if (c2 == '_' || c2 == '\\0') c2 = '#';\n-\n-      sprintf (aliasname, \"%c%c%06d\", c1, c2, mvs_hash_alias (realname));\n-      mvs_add_alias (realname, aliasname, 0);\n-      return 1;\n-    }\n-#else\n-  if (strlen (realname) > MAX_MVS_LABEL_SIZE)\n-    {\n-      strncpy (aliasname, realname, MAX_MVS_LABEL_SIZE);\n-      aliasname[MAX_MVS_LABEL_SIZE] = '\\0';\n-      return 1;\n-    }\n-#endif\n-  return 0;\n-}\n-\n-/* Check to see if the alias is in the list. \n-   If 1 is returned then it's in the alias list, 2 it was emitted  */\n-\n-int\n-mvs_check_alias (realname, aliasname)\n-     const char *realname;\n-     char *aliasname;\n-{\n-#ifdef LONGEXTERNAL\n-  alias_node_t *ap;\n-\n-  for (ap = alias_anchor; ap; ap = ap->alias_next)\n-    {\n-      if (!strcmp (ap->real_name, realname))\n-\t{\n-\t  int rc = (ap->alias_emitted == 1) ? 1 : 2; \n-\t  strcpy (aliasname, ap->alias_name);\n-\t  ap->alias_emitted = 1; \n-\t  return rc;\n-\t}\n-    }\n-  if (mvs_need_alias (realname))\n-    {\n-      char c1, c2;\n-\n-      c1 = realname[0];\n-      c2 = realname[1];\n-      if (ISLOWER (c1)) c1 = TOUPPER (c1);\n-      else if (c1 == '_') c1 = 'A';\n-      if (ISLOWER (c2)) c2 = TOUPPER (c2);\n-      else if (c2 == '_' || c2 == '\\0') c2 = '#';\n-\n-      sprintf (aliasname, \"%c%c%06d\", c1, c2, mvs_hash_alias (realname));\n-      mvs_add_alias (realname, aliasname, 0);\n-      alias_anchor->alias_emitted = 1;\n-      return 2;\n-    }\n-#else\n-  if (strlen (realname) > MAX_MVS_LABEL_SIZE)\n-    {\n-      strncpy (aliasname, realname, MAX_MVS_LABEL_SIZE);\n-      aliasname[MAX_MVS_LABEL_SIZE] = '\\0';\n-      return 1;\n-    }\n-#endif\n-  return 0;\n-}\n-\n-/* defines and functions specific to the HLASM assembler */\n-#endif /* TARGET_HLASM */\n-/* ===================================================== */\n-/* ===================================================== */\n-/* defines and functions specific to the gas assembler */\n-#ifdef TARGET_ELF_ABI\n-\n-/* Check for C/370 runtime function, they don't use standard calling\n-   conventions.  True is returned if the function is in the table.\n-   NAME is the name of the current function.  */\n-/* no special calling conventions (yet ??) */\n-\n-int\n-mvs_function_check (name)\n-     const char *name ATTRIBUTE_UNUSED;\n-{\n-   return 0;\n-}\n-\n-#endif /* TARGET_ELF_ABI */\n-/* ===================================================== */\n-\n-\n-/* Return 1 if OP is a valid S operand for an RS, SI or SS type instruction.\n-   OP is the current operation.\n-   MODE is the current operation mode.  */\n-\n-int\n-s_operand (op, mode)\n-     register rtx op;\n-     enum machine_mode mode;\n-{\n-  extern int volatile_ok;\n-  register enum rtx_code code = GET_CODE (op);\n-\n-  if (CONSTANT_ADDRESS_P (op))\n-    return 1;\n-  if (mode == VOIDmode || GET_MODE (op) != mode)\n-    return 0;\n-  if (code == MEM)\n-    {\n-      register rtx x = XEXP (op, 0);\n-\n-      if (!volatile_ok && op->volatil)\n-\treturn 0;\n-      if (REG_P (x) && REG_OK_FOR_BASE_P (x))\n-\treturn 1;\n-      if (GET_CODE (x) == PLUS\n-\t  && REG_P (XEXP (x, 0)) && REG_OK_FOR_BASE_P (XEXP (x, 0))\n-\t  && GET_CODE (XEXP (x, 1)) == CONST_INT\n-\t  && (unsigned) INTVAL (XEXP (x, 1)) < 4096)\n-\treturn 1;\n-    }\n-  return 0;\n-}\n-\n-\n-/* Return 1 if OP is a valid R or S operand for an RS, SI or SS type\n-   instruction.\n-   OP is the current operation.\n-   MODE is the current operation mode.  */\n-\n-int\n-r_or_s_operand (op, mode)\n-     register rtx op;\n-     enum machine_mode mode;\n-{\n-  extern int volatile_ok;\n-  register enum rtx_code code = GET_CODE (op);\n-\n-  if (CONSTANT_ADDRESS_P (op))\n-    return 1;\n-  if (mode == VOIDmode || GET_MODE (op) != mode)\n-    return 0;\n-  if (code == REG)\n-    return 1;\n-  else if (code == MEM)\n-    {\n-      register rtx x = XEXP (op, 0);\n-\n-      if (!volatile_ok && op->volatil)\n-\treturn 0;\n-      if (REG_P (x) && REG_OK_FOR_BASE_P (x))\n-\treturn 1;\n-      if (GET_CODE (x) == PLUS\n-\t  && REG_P (XEXP (x, 0)) && REG_OK_FOR_BASE_P (XEXP (x, 0))\n-\t  && GET_CODE (XEXP (x, 1)) == CONST_INT\n-\t  && (unsigned) INTVAL (XEXP (x, 1)) < 4096)\n-\treturn 1;\n-    }\n-  return 0;\n-}\n-\n-\n-/* Some remarks about unsigned_jump_follows_p():\n-   gcc is built around the assumption that branches are signed\n-   or unsigned, whereas the 370 doesn't care; its the compares that\n-   are signed or unsigned.  Thus, we need to somehow know if we\n-   need to do a signed or an unsigned compare, and we do this by \n-   looking ahead in the instruction sequence until we find a jump.\n-   We then note whether this jump is signed or unsigned, and do the \n-   compare appropriately.  Note that we have to scan ahead indefinitley,\n-   as the gcc optimizer may insert any number of instructions between \n-   the compare and the jump.\n-  \n-   Note that using conditional branch expanders seems to be be a more \n-   elegant/correct way of doing this.   See, for instance, the Alpha \n-   cmpdi and bgt patterns.  Note also that for the i370, various\n-   arithmetic insn's set the condition code as well.\n-\n-   The unsigned_jump_follows_p() routine  returns a 1 if the next jump \n-   is unsigned.  INSN is the current instruction.  */\n-\n-int\n-unsigned_jump_follows_p (insn)\n-     register rtx insn;\n-{\n-  rtx orig_insn = insn;\n-  while (1) \n-    {\n-      register rtx tmp_insn;\n-      enum rtx_code coda;\n-  \n-      insn = NEXT_INSN (insn);\n-      if (!insn) fatal_insn (\"internal error--no jump follows compare:\", orig_insn);\n-  \n-      if (GET_CODE (insn) != JUMP_INSN) continue;\n-    \n-      tmp_insn = XEXP (insn, 3);\n-      if (GET_CODE (tmp_insn) != SET) continue;\n-    \n-      if (GET_CODE (XEXP (tmp_insn, 0)) != PC) continue;\n-    \n-      tmp_insn = XEXP (tmp_insn, 1);\n-      if (GET_CODE (tmp_insn) != IF_THEN_ELSE) continue;\n-    \n-      /* if we got to here, this instruction is a jump.  Is it signed? */\n-      tmp_insn = XEXP (tmp_insn, 0);\n-      coda = GET_CODE (tmp_insn);\n-  \n-      return coda != GE && coda != GT && coda != LE && coda != LT;\n-    }\n-}\n-\n-#ifdef TARGET_HLASM\n-\n-/* Target hook for assembling integer objects.  This version handles all\n-   objects when TARGET_HLASM is defined.  */\n-\n-static bool\n-i370_hlasm_assemble_integer (x, size, aligned_p)\n-     rtx x;\n-     unsigned int size;\n-     int aligned_p;\n-{\n-  const char *int_format = NULL;\n-\n-  if (aligned_p)\n-    switch (size)\n-      {\n-      case 1:\n-\tint_format = \"\\tDC\\tX'%02X'\\n\";\n-\tbreak;\n-\n-      case 2:\n-\tint_format = \"\\tDC\\tX'%04X'\\n\";\n-\tbreak;\n-\n-      case 4:\n-\tif (GET_CODE (x) == CONST_INT)\n-\t  {\n-\t    fputs (\"\\tDC\\tF'\", asm_out_file);\n-\t    output_addr_const (asm_out_file, x);\n-\t    fputs (\"'\\n\", asm_out_file);\n-\t  }\n-\telse\n-\t  {\n-\t    fputs (\"\\tDC\\tA(\", asm_out_file);\n-\t    output_addr_const (asm_out_file, x);\n-\t    fputs (\")\\n\", asm_out_file);\n-\t  }\n-\treturn true;\n-      }\n-\n-  if (int_format && GET_CODE (x) == CONST_INT)\n-    {\n-      fprintf (asm_out_file, int_format, INTVAL (x));\n-      return true;\n-    }\n-  return default_assemble_integer (x, size, aligned_p);\n-}\n-\n-/* Generate the assembly code for function entry.  FILE is a stdio\n-   stream to output the code to.  SIZE is an int: how many units of\n-   temporary storage to allocate.\n-\n-   Refer to the array `regs_ever_live' to determine which registers to\n-   save; `regs_ever_live[I]' is nonzero if register number I is ever\n-   used in the function.  This function is responsible for knowing\n-   which registers should not be saved even if used.  */\n-\n-static void\n-i370_output_function_prologue (f, l)\n-     FILE *f;\n-     HOST_WIDE_INT l;\n-{\n-#if MACROPROLOGUE == 1\n-  fprintf (f, \"* Function %s prologue\\n\", mvs_function_name);\n-  fprintf (f, \"\\tEDCPRLG USRDSAL=%d,BASEREG=%d\\n\",\n-\t   STACK_POINTER_OFFSET + l - 120 +\n-\t   current_function_outgoing_args_size, BASE_REGISTER);\n-#else /* MACROPROLOGUE != 1 */\n-  static int function_label_index = 1;\n-  static int function_first = 0;\n-  static int function_year, function_month, function_day;\n-  static int function_hour, function_minute, function_second;\n-#if defined(LE370)\n-  if (!function_first)\n-    {\n-      struct tm *function_time;\n-      time_t lcltime;\n-      time (&lcltime);\n-      function_time = localtime (&lcltime);\n-      function_year = function_time->tm_year + 1900;\n-      function_month = function_time->tm_mon + 1;\n-      function_day = function_time->tm_mday;\n-      function_hour = function_time->tm_hour;\n-      function_minute = function_time->tm_min;\n-      function_second = function_time->tm_sec;\n-    }\n-  fprintf (f, \"* Function %s prologue\\n\", mvs_function_name);\n-  fprintf (f, \"FDSE%03d\\tDSECT\\n\", function_label_index);\n-  fprintf (f, \"\\tDS\\tD\\n\");\n-  fprintf (f, \"\\tDS\\tCL(\" HOST_WIDE_INT_PRINT_DEC \")\\n\",\n-\t   STACK_POINTER_OFFSET + l\n-\t   + current_function_outgoing_args_size);\n-  fprintf (f, \"\\tORG\\tFDSE%03d\\n\", function_label_index);\n-  fprintf (f, \"\\tDS\\tCL(120+8)\\n\");\n-  fprintf (f, \"\\tORG\\n\");\n-  fprintf (f, \"\\tDS\\t0D\\n\");\n-  fprintf (f, \"FDSL%03d\\tEQU\\t*-FDSE%03d-8\\n\", function_label_index,\n-\t   function_label_index);\n-  fprintf (f, \"\\tDS\\t0H\\n\");\n-  assemble_name (f, mvs_function_name);\n-  fprintf (f, \"\\tCSECT\\n\");\n-  fprintf (f, \"\\tUSING\\t*,15\\n\");\n-  fprintf (f, \"\\tB\\tFENT%03d\\n\", function_label_index);\n-  fprintf (f, \"\\tDC\\tAL1(FNAM%03d+4-*)\\n\", function_label_index);\n-  fprintf (f, \"\\tDC\\tX'CE',X'A0',AL1(16)\\n\");\n-  fprintf (f, \"\\tDC\\tAL4(FPPA%03d)\\n\", function_label_index);\n-  fprintf (f, \"\\tDC\\tAL4(0)\\n\");\n-  fprintf (f, \"\\tDC\\tAL4(FDSL%03d)\\n\", function_label_index);\n-  fprintf (f, \"FNAM%03d\\tEQU\\t*\\n\", function_label_index);\n-  fprintf (f, \"\\tDC\\tAL2(%d),C'%s'\\n\", strlen (mvs_function_name),\n-\tmvs_function_name);\n-  fprintf (f, \"FPPA%03d\\tDS\\t0F\\n\", function_label_index);\n-  fprintf (f, \"\\tDC\\tX'03',X'00',X'33',X'00'\\n\");\n-  fprintf (f, \"\\tDC\\tV(CEESTART)\\n\");\n-  fprintf (f, \"\\tDC\\tAL4(0)\\n\");\n-  fprintf (f, \"\\tDC\\tAL4(FTIM%03d)\\n\", function_label_index);\n-  fprintf (f, \"FTIM%03d\\tDS\\t0F\\n\", function_label_index);\n-  fprintf (f, \"\\tDC\\tCL4'%d',CL4'%02d%02d',CL6'%02d%02d00'\\n\",\n-  \t\t function_year, function_month, function_day,\n-    \t\t function_hour, function_minute);\n-  fprintf (f, \"\\tDC\\tCL2'01',CL4'0100'\\n\");\n-  fprintf (f, \"FENT%03d\\tDS\\t0H\\n\", function_label_index);\n-  fprintf (f, \"\\tSTM\\t14,12,12(13)\\n\");\n-  fprintf (f, \"\\tL\\t2,76(,13)\\n\");\n-  fprintf (f, \"\\tL\\t0,16(,15)\\n\");\n-  fprintf (f, \"\\tALR\\t0,2\\n\");\n-  fprintf (f, \"\\tCL\\t0,12(,12)\\n\");\n-  fprintf (f, \"\\tBNH\\t*+10\\n\");\n-  fprintf (f, \"\\tL\\t15,116(,12)\\n\");\n-  fprintf (f, \"\\tBALR\\t14,15\\n\");\n-  fprintf (f, \"\\tL\\t15,72(,13)\\n\");\n-  fprintf (f, \"\\tSTM\\t15,0,72(2)\\n\");\n-  fprintf (f, \"\\tMVI\\t0(2),X'10'\\n\");\n-  fprintf (f, \"\\tST\\t2,8(,13)\\n \");\n-  fprintf (f, \"\\tST\\t13,4(,2)\\n \");\n-  fprintf (f, \"\\tLR\\t13,2\\n\");\n-  fprintf (f, \"\\tDROP\\t15\\n\");\n-  fprintf (f, \"\\tBALR\\t%d,0\\n\", BASE_REGISTER);\n-  fprintf (f, \"\\tUSING\\t*,%d\\n\", BASE_REGISTER);\n-  function_first = 1;\n-  function_label_index ++;\n-#else /* !LE370 */\n-  if (!function_first)\n-    {\n-      struct tm *function_time;\n-      time_t lcltime;\n-      time (&lcltime);\n-      function_time = localtime (&lcltime);\n-      function_year = function_time->tm_year + 1900;\n-      function_month = function_time->tm_mon + 1;\n-      function_day = function_time->tm_mday;\n-      function_hour = function_time->tm_hour;\n-      function_minute = function_time->tm_min;\n-      function_second = function_time->tm_sec;\n-      fprintf (f, \"PPA2\\tDS\\t0F\\n\");\n-      fprintf (f, \"\\tDC\\tX'03',X'00',X'33',X'00'\\n\");\n-      fprintf (f, \"\\tDC\\tV(CEESTART),A(0)\\n\");\n-      fprintf (f, \"\\tDC\\tA(CEETIMES)\\n\");\n-      fprintf (f, \"CEETIMES\\tDS\\t0F\\n\");\n-      fprintf (f, \"\\tDC\\tCL4'%d',CL4'%02d%02d',CL6'%02d%02d00'\\n\",\n-    \t\t function_year, function_month, function_day,\n-    \t\t function_hour, function_minute, function_second);\n-      fprintf (f, \"\\tDC\\tCL2'01',CL4'0100'\\n\");\n-    }\n-  fprintf (f, \"* Function %s prologue\\n\", mvs_function_name);\n-  fprintf (f, \"FDSD%03d\\tDSECT\\n\", function_label_index);\n-  fprintf (f, \"\\tDS\\tD\\n\");\n-  fprintf (f, \"\\tDS\\tCL(%d)\\n\", STACK_POINTER_OFFSET + l\n-\t\t\t+ current_function_outgoing_args_size);\n-  fprintf (f, \"\\tORG\\tFDSD%03d\\n\", function_label_index);\n-  fprintf (f, \"\\tDS\\tCL(120+8)\\n\");\n-  fprintf (f, \"\\tORG\\n\");\n-  fprintf (f, \"\\tDS\\t0D\\n\");\n-  fprintf (f, \"FDSL%03d\\tEQU\\t*-FDSD%03d-8\\n\", function_label_index,\n-\t   function_label_index);\n-  fprintf (f, \"\\tDS\\t0H\\n\");\n-  assemble_name (f, mvs_function_name);\n-  fprintf (f, \"\\tCSECT\\n\");\n-  fprintf (f, \"\\tUSING\\t*,15\\n\");\n-  fprintf (f, \"\\tB\\tFPL%03d\\n\", function_label_index);\n-  fprintf (f, \"\\tDC\\tAL1(FPL%03d+4-*)\\n\", function_label_index + 1);\n-  fprintf (f, \"\\tDC\\tX'CE',X'A0',AL1(16)\\n\");\n-  fprintf (f, \"\\tDC\\tAL4(PPA2)\\n\");\n-  fprintf (f, \"\\tDC\\tAL4(0)\\n\");\n-  fprintf (f, \"\\tDC\\tAL4(FDSL%03d)\\n\", function_label_index);\n-  fprintf (f, \"FPL%03d\\tEQU\\t*\\n\", function_label_index + 1);\n-  fprintf (f, \"\\tDC\\tAL2(%d),C'%s'\\n\", strlen (mvs_function_name),\n-\tmvs_function_name);\n-  fprintf (f, \"FPL%03d\\tDS\\t0H\\n\", function_label_index);\n-  fprintf (f, \"\\tSTM\\t14,12,12(13)\\n\");\n-  fprintf (f, \"\\tL\\t2,76(,13)\\n\");\n-  fprintf (f, \"\\tL\\t0,16(,15)\\n\");\n-  fprintf (f, \"\\tALR\\t0,2\\n\");\n-  fprintf (f, \"\\tCL\\t0,12(,12)\\n\");\n-  fprintf (f, \"\\tBNH\\t*+10\\n\");\n-  fprintf (f, \"\\tL\\t15,116(,12)\\n\");\n-  fprintf (f, \"\\tBALR\\t14,15\\n\");\n-  fprintf (f, \"\\tL\\t15,72(,13)\\n\");\n-  fprintf (f, \"\\tSTM\\t15,0,72(2)\\n\");\n-  fprintf (f, \"\\tMVI\\t0(2),X'10'\\n\");\n-  fprintf (f, \"\\tST\\t2,8(,13)\\n \");\n-  fprintf (f, \"\\tST\\t13,4(,2)\\n \");\n-  fprintf (f, \"\\tLR\\t13,2\\n\");\n-  fprintf (f, \"\\tDROP\\t15\\n\");\n-  fprintf (f, \"\\tBALR\\t%d,0\\n\", BASE_REGISTER);\n-  fprintf (f, \"\\tUSING\\t*,%d\\n\", BASE_REGISTER);\n-  function_first = 1;\n-  function_label_index += 2;\n-#endif /* !LE370 */\n-#endif /* MACROPROLOGUE */\n-  fprintf (f, \"PG%d\\tEQU\\t*\\n\", mvs_page_num );\n-  fprintf (f, \"\\tLR\\t11,1\\n\"); \n-  fprintf (f, \"\\tL\\t%d,=A(PGT%d)\\n\", PAGE_REGISTER, mvs_page_num);\n-  fprintf (f, \"* Function %s code\\n\", mvs_function_name);\n-\n-  mvs_free_label_list ();\n-  mvs_page_code = 6;\n-  mvs_page_lit = 4;\n-  mvs_check_page (f, 0, 0);\n-  function_base_page = mvs_page_num;\n-\n-  /* find all labels in this routine */\n-  i370_label_scan ();\n-}\n-\n-static void\n-i370_globalize_label (stream, name)\n-     FILE *stream;\n-     const char *name;\n-{\n-  char temp[MAX_MVS_LABEL_SIZE + 1];\n-  if (mvs_check_alias (name, temp) == 2)\n-    fprintf (stream, \"%s\\tALIAS\\tC'%s'\\n\", temp, name);\n-  fputs (\"\\tENTRY\\t\", stream);\n-  assemble_name (stream, name);\n-  putc ('\\n', stream);\n-}\n-#endif /* TARGET_HLASM */\n-\n-\n-#ifdef TARGET_ELF_ABI\n-/*\n-   The 370_function_prolog() routine generates the current ELF ABI ES/390 prolog.\n-   It implements a stack that grows downward. \n-   It performs the following steps:\n-   -- saves the callers non-volatile registers on the callers stack.\n-   -- subtracts stackframe size from the stack pointer.\n-   -- stores backpointer to old caller stack.\n-  \n-   XXX hack alert -- if the global var int leaf_function is nonzero, \n-   then this is a leaf, and it might be possible to optimize the prologue\n-   into doing even less, e.g. not grabbing a new stackframe or maybe just a\n-   partial stack frame.\n-  \n-   XXX hack alert -- the current stack frame is bloated into twice the \n-   needed size by unused entries. These entries make it marginally \n-   compatible with MVS/OE/USS C environment, but really they're not used\n-   and could probably chopped out. Modifications to i370.md would be needed\n-   also, to quite using addresses 136, 140, etc.\n- */\n-\n-static void\n-i370_output_function_prologue (f, frame_size)\n-     FILE *f;\n-     HOST_WIDE_INT frame_size;\n-{\n-  static int function_label_index = 1;\n-  static int function_first = 0;\n-  int stackframe_size, aligned_size;\n-\n-  fprintf (f, \"# Function prologue\\n\");\n-  /* define the stack, put it into its own data segment\n-     FDSE == Function Stack Entry\n-     FDSL == Function Stack Length */\n-  stackframe_size = \n-     STACK_POINTER_OFFSET + current_function_outgoing_args_size + frame_size;\n-  aligned_size = (stackframe_size + 7) >> 3;\n-  aligned_size <<= 3;\n-  \n-  fprintf (f, \"# arg_size=0x%x frame_size=\" HOST_WIDE_INT_PRINT_HEX\n-\t   \" aligned size=0x%x\\n\", \n-     current_function_outgoing_args_size, frame_size, aligned_size);\n-\n-  fprintf (f, \"\\t.using\\t.,r15\\n\");\n-\n-  /* Branch to exectuable part of prologue.  */\n-  fprintf (f, \"\\tB\\t.LFENT%03d\\n\", function_label_index);\n-\n-  /* write the length of the stackframe */\n-  fprintf (f, \"\\t.long\\t%d\\n\", aligned_size);\n-\n-  /* FENT == function prologue entry */\n-  fprintf (f, \"\\t.balign 2\\n.LFENT%03d:\\n\",\n-              function_label_index);\n-\n-  /* store multiple registers 14,15,0,...12 at 12 bytes from sp */\n-  fprintf (f, \"\\tSTM\\tr14,r12,12(sp)\\n\");\n-\n-  /* r3 == saved callee stack pointer */\n-  fprintf (f, \"\\tLR\\tr3,sp\\n\");\n-\n-  /* 4(r15) == stackframe size */\n-  fprintf (f, \"\\tSL\\tsp,4(,r15)\\n\");\n-\n-  /* r11 points to arg list in callers stackframe; was passed in r2 */\n-  fprintf (f, \"\\tLR\\tr11,r2\\n\");\n-\n-  /* store callee stack pointer at 8(sp) */\n-  /* fprintf (f, \"\\tST\\tsp,8(,r3)\\n \");  wasted cycles, no one uses this ...  */\n-\n-  /* backchain -- store caller sp at 4(callee_sp)  */\n-  fprintf (f, \"\\tST\\tr3,4(,sp)\\n \");\n-\n-  fprintf (f, \"\\t.drop\\tr15\\n\");\n-  /* Place contents of the PSW into r3\n-     that is, place the address of \".\" into r3 */\n-  fprintf (f, \"\\tBASR\\tr%d,0\\n\", BASE_REGISTER);\n-  fprintf (f, \"\\t.using\\t.,r%d\\n\", BASE_REGISTER);\n-  function_first = 1;\n-  function_label_index ++;\n-\n-  fprintf (f, \".LPG%d:\\n\", mvs_page_num  );\n-  fprintf (f, \"\\tL\\tr%d,=A(.LPGT%d)\\n\", PAGE_REGISTER, mvs_page_num);\n-  fprintf (f, \"# Function code\\n\");\n-\n-  mvs_free_label_list ();\n-  mvs_page_code = 6;\n-  mvs_page_lit = 4;\n-  mvs_check_page (f, 0, 0);\n-  function_base_page = mvs_page_num;\n-\n-  /* find all labels in this routine */\n-  i370_label_scan ();\n-}\n-#endif /* TARGET_ELF_ABI */\n-\n-/* This function generates the assembly code for function exit.\n-   Args are as for output_function_prologue ().\n-\n-   The function epilogue should not depend on the current stack\n-   pointer!  It should use the frame pointer only.  This is mandatory\n-   because of alloca; we also take advantage of it to omit stack\n-   adjustments before returning.  */\n-\n-static void\n-i370_output_function_epilogue (file, l)\n-     FILE *file;\n-     HOST_WIDE_INT l ATTRIBUTE_UNUSED;\n-{\n-  int i;\n-\n-  check_label_emit ();\n-  mvs_check_page (file, 14, 0);\n-  fprintf (file, \"* Function %s epilogue\\n\", mvs_function_name);\n-  mvs_page_num++;\n-\n-#if MACROEPILOGUE == 1\n-  fprintf (file, \"\\tEDCEPIL\\n\");\n-#else /* MACROEPILOGUE != 1 */\n-  fprintf (file, \"\\tL\\t13,4(,13)\\n\");\n-  fprintf (file, \"\\tL\\t14,12(,13)\\n\");\n-  fprintf (file, \"\\tLM\\t2,12,28(13)\\n\");\n-  fprintf (file, \"\\tBALR\\t1,14\\n\");\n-  fprintf (file, \"\\tDC\\tA(\");\n-  assemble_name (file, mvs_function_name);\n-  fprintf (file, \")\\n\" );\n-#endif /* MACROEPILOGUE */\n-\n-  fprintf (file, \"* Function %s literal pool\\n\", mvs_function_name);\n-  fprintf (file, \"\\tDS\\t0F\\n\" );\n-  fprintf (file, \"\\tLTORG\\n\");\n-  fprintf (file, \"* Function %s page table\\n\", mvs_function_name);\n-  fprintf (file, \"\\tDS\\t0F\\n\");\n-  fprintf (file, \"PGT%d\\tEQU\\t*\\n\", function_base_page);\n-\n-  mvs_free_label_list();\n-  for (i = function_base_page; i < mvs_page_num; i++)\n-    fprintf (file, \"\\tDC\\tA(PG%d)\\n\", i);\n-}\n-\n-static void\n-i370_file_start ()\n-{\n-  fputs (\"\\tRMODE\\tANY\\n\\tCSECT\\n\", asm_out_file);\n-}\n-\n-static void\n-i370_file_end ()\n-{\n-  fputs (\"\\tEND\\n\", asm_out_file);\n-}\n-\n-static void\n-i370_internal_label (stream, prefix, labelno)\n-     FILE *stream;\n-     const char *prefix;\n-     unsigned long labelno;\n-{\n-  if (!strcmp (prefix, \"L\"))\n-    mvs_add_label(labelno);\n-\n-  default_internal_label (stream, prefix, labelno);\n-}\n-\n-static bool\n-i370_rtx_costs (x, code, outer_code, total)\n-     rtx x;\n-     int code;\n-     int outer_code ATTRIBUTE_UNUSED;\n-     int *total;\n-{\n-  switch (code)\n-    {\n-    case CONST_INT:\n-      if ((unsigned HOST_WIDE_INT) INTVAL (x) < 0xfff)\n-\t{\n-\t  *total = 1;\n-\t  return true;\n-\t}\n-      /* FALLTHRU */\n-\n-    case CONST:\n-    case LABEL_REF:\n-    case SYMBOL_REF:\n-      *total = 2;\n-      return true;\n-\n-    case CONST_DOUBLE:\n-      *total = 4;\n-      return true;\n-\n-    default:\n-      return false;\n-    }\n-}"}, {"sha": "8109ddedc2e99df044235852f39ee4ee6b1d6b0a", "filename": "gcc/config/i370/i370.h", "status": "removed", "additions": 0, "deletions": 1862, "changes": 1862, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fi370%2Fi370.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fi370%2Fi370.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fi370.h?ref=c3bf16ff7dec47581f450b1a486cfdf9d566927e", "patch": "@@ -1,1862 +0,0 @@\n-/* Definitions of target machine for GNU compiler.  System/370 version.\n-   Copyright (C) 1989, 1993, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,\n-   2003 Free Software Foundation, Inc.\n-   Contributed by Jan Stein (jan@cd.chalmers.se).\n-   Modified for OS/390 LanguageEnvironment C by Dave Pitts (dpitts@cozx.com)\n-   Hacked for Linux-ELF/390 by Linas Vepstas (linas@linas.org)\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#ifndef GCC_I370_H\n-#define GCC_I370_H\n-\n-/* Target CPU builtins.  */\n-#define TARGET_CPU_CPP_BUILTINS()\t\t\\\n-  do\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\\\n-      builtin_define_std (\"GCC\");\t\t\\\n-      builtin_define_std (\"gcc\");\t\t\\\n-      builtin_assert (\"machine=i370\");\t\t\\\n-      builtin_assert (\"cpu=i370\");\t\t\\\n-    }\t\t\t\t\t\t\\\n-  while (0)\n-\n-/* Run-time compilation parameters selecting different hardware subsets.  */\n-\n-extern int target_flags;\n-\n-/* The sizes of the code and literals on the current page.  */\n-\n-extern int mvs_page_code, mvs_page_lit;\n-\n-/* The current page number and the base page number for the function.  */\n-\n-extern int mvs_page_num, function_base_page;\n-\n-/* The name of the current function.  */\n-\n-extern char *mvs_function_name;\n-\n-/* The length of the function name malloc'd area.  */\n-\n-extern size_t mvs_function_name_length;\n-\n-/* Compile using char instructions (mvc, nc, oc, xc).  On 4341 use this since\n-   these are more than twice as fast as load-op-store.\n-   On 3090 don't use this since load-op-store is much faster.  */\n-\n-#define TARGET_CHAR_INSTRUCTIONS (target_flags & 1)\n-\n-/* Default target switches */\n-\n-#define TARGET_DEFAULT 1\n-\n-/* Macro to define tables used to set the flags.  This is a list in braces\n-   of pairs in braces, each pair being { \"NAME\", VALUE }\n-   where VALUE is the bits to set or minus the bits to clear.\n-   An empty string NAME is used to identify the default VALUE.  */\n-\n-#define TARGET_SWITCHES\t\t\t\t\t\t\t\\\n-{ { \"char-instructions\", 1, N_(\"Generate char instructions\")},            \\\n-  { \"no-char-instructions\", -1, N_(\"Do not generate char instructions\")}, \\\n-  { \"\", TARGET_DEFAULT, 0} }\n-\n-#define OVERRIDE_OPTIONS  override_options ()\n-\n-/* To use IBM supplied macro function prologue and epilogue, define the\n-   following to 1.  Should only be needed if IBM changes the definition\n-   of their prologue and epilogue.  */\n-\n-#define MACROPROLOGUE 0\n-#define MACROEPILOGUE 0\n-\n-/* Target machine storage layout */\n-\n-/* Define this if most significant bit is lowest numbered in instructions\n-   that operate on numbered bit-fields.  */\n-\n-#define BITS_BIG_ENDIAN 1\n-\n-/* Define this if most significant byte of a word is the lowest numbered.  */\n-\n-#define BYTES_BIG_ENDIAN 1\n-\n-/* Define this if MS word of a multiword is the lowest numbered.  */\n-\n-#define WORDS_BIG_ENDIAN 1\n-\n-/* Width of a word, in units (bytes).  */\n-\n-#define UNITS_PER_WORD 4\n-\n-/* Allocation boundary (in *bits*) for storing pointers in memory.  */\n-\n-#define POINTER_BOUNDARY 32\n-\n-/* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n-\n-#define PARM_BOUNDARY 32\n-\n-/* Boundary (in *bits*) on which stack pointer should be aligned.  */\n-\n-#define STACK_BOUNDARY 32\n-\n-/* Allocation boundary (in *bits*) for the code of a function.  */\n-\n-#define FUNCTION_BOUNDARY 32\n-\n-/* There is no point aligning anything to a rounder boundary than this.  */\n-\n-#define BIGGEST_ALIGNMENT 64\n-\n-/* Alignment of field after `int : 0' in a structure.  */\n-\n-#define EMPTY_FIELD_BOUNDARY 32\n-\n-/* Define this if move instructions will actually fail to work when given\n-   unaligned data.  */\n-\n-#define STRICT_ALIGNMENT 0\n-\n-/* Define target floating point format.  */\n-\n-#define TARGET_FLOAT_FORMAT IBM_FLOAT_FORMAT\n-\n-#ifdef TARGET_HLASM\n-/* HLASM requires #pragma map.  */\n-#define REGISTER_TARGET_PRAGMAS() c_register_pragma (0, \"map\", i370_pr_map)\n-#endif /* TARGET_HLASM */\n-\n-/* Define maximum length of page minus page escape overhead.  */\n-\n-#define MAX_MVS_PAGE_LENGTH 4080\n-\n-/* Define special register allocation order desired.  \n-   Don't fiddle with this.  I did, and I got all sorts of register \n-   spill errors when compiling even relatively simple programs...\n-   I have no clue why ...\n-   E.g. this one is bad:\n-   { 0, 1, 2, 9, 8, 7, 6, 5, 10, 15, 14, 12, 3, 4, 16, 17, 18, 19, 11, 13 }\n- */\n-\n-#define REG_ALLOC_ORDER\t\t\t\t\t\t\t\\\n-{ 0, 1, 2, 3, 14, 15, 12, 10, 9, 8, 7, 6, 5, 4, 16, 17, 18, 19, 11, 13 }\n-\n-/* Standard register usage.  */\n-\n-/* Number of actual hardware registers.  The hardware registers are\n-   assigned numbers for the compiler from 0 to just below\n-   FIRST_PSEUDO_REGISTER.\n-   All registers that the compiler knows about must be given numbers,\n-   even those that are not normally considered general registers.\n-   For the 370, we give the data registers numbers 0-15,\n-   and the floating point registers numbers 16-19.  */\n-\n-#define FIRST_PSEUDO_REGISTER 20\n-\n-/* Define base and page registers.  */\n-\n-#define BASE_REGISTER 3\n-#define PAGE_REGISTER 4\n-\n-#ifdef TARGET_HLASM\n-/* 1 for registers that have pervasive standard uses and are not available\n-   for the register allocator.  These are registers that must have fixed,\n-   valid values stored in them for the entire length of the subroutine call,\n-   and must not in any way be moved around, jiggered with, etc. That is,\n-   they must never be clobbered, and, if clobbered, the register allocator \n-   will never restore them back.\n-   \n-   We use five registers in this special way:\n-   -- R3 which is used as the base register\n-   -- R4 the page origin table pointer used to load R3,\n-   -- R11 the arg pointer.  \n-   -- R12 the TCA pointer\n-   -- R13 the stack (DSA) pointer\n-\n-   A fifth register is also exceptional: R14 is used in many branch\n-   instructions to hold the target of the branch.  Technically, this\n-   does not qualify R14 as a register with a long-term meaning; it should\n-   be enough, theoretically, to note that these instructions clobber\n-   R14, and let the compiler deal with that.  In practice, however,\n-   the \"clobber\" directive acts as a barrier to optimization, and the\n-   optimizer appears to be unable to perform optimizations around branches.\n-   Thus, a much better strategy appears to give R14 a pervasive use;\n-   this eliminates it from the register pool witout hurting optimization.\n-\n-   There are other registers which have special meanings, but its OK\n-   for them to get clobbered, since other allocator config below will\n-   make sure that they always have the right value.  These are for \n-   example:\n-   -- R1 the returned structure pointer.\n-   -- R10 the static chain reg.\n-   -- R15 holds the value a subroutine returns.\n-\n-   Notice that it is *almost* safe to mark R11 as available to the allocator.\n-   By marking it as a call_used_register, in most cases, the compiler\n-   can handle it being clobbered.  However, there are a few rare\n-   circumstances where the register allocator will allocate r11 and \n-   also try to use it as the arg pointer ... thus it must be marked fixed.\n-   I think this is a bug, but I can't track it down...\n- */\n-\n-#define FIXED_REGISTERS \t\t\t\t\t\t\\\n-{ 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0 }\n-/*0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19*/\n-\n-/* 1 for registers not available across function calls.  These must include\n-   the FIXED_REGISTERS and also any registers that can be used without being\n-   saved.\n-   The latter must include the registers where values are returned\n-   and the register where structure-value addresses are passed.\n-   NOTE: all floating registers are undefined across calls.  \n-*/\n-\n-#define CALL_USED_REGISTERS \t\t\t\t\t\t\\\n-{ 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1 }\n-/*0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19*/\n-\n-/* Return number of consecutive hard regs needed starting at reg REGNO\n-   to hold something of mode MODE.\n-   This is ordinarily the length in words of a value of mode MODE\n-   but can be less for certain modes in special long registers.  \n-   Note that DCmode (complex double) needs two regs.\n-*/\n-#endif /* TARGET_HLASM */\n-\n-/* ================= */\n-#ifdef TARGET_ELF_ABI \n-/* The Linux/ELF ABI uses the same register layout as the \n- * the MVS/OE version, with the following exceptions:\n- * -- r12 (rtca) is not used.\n- */\n-\n-#define FIXED_REGISTERS \t\t\t\t\t\t\\\n-{ 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0 }\n-/*0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19*/\n-\n-#define CALL_USED_REGISTERS \t\t\t\t\t\t\\\n-{ 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1 }\n-/*0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19*/\n-\n-#endif /* TARGET_ELF_ABI */\n-/* ================= */\n-\n-\n-#define HARD_REGNO_NREGS(REGNO, MODE) \t\t\t\t\t\\\n-  ((REGNO) > 15 ? \t\t\t\t\t\t\t\\\n-   ((GET_MODE_SIZE (MODE) + 2*UNITS_PER_WORD - 1) / (2*UNITS_PER_WORD)) :\t\\\n-   (GET_MODE_SIZE(MODE)+UNITS_PER_WORD-1) / UNITS_PER_WORD)\n-\n-/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n-   On the 370, the cpu registers can hold QI, HI, SI, SF and DF.  The\n-   even registers can hold DI.  The floating point registers can hold\n-   either SF, DF, SC or DC.  */\n-\n-#define HARD_REGNO_MODE_OK(REGNO, MODE)\t\t\t\t\t\\\n-  ((REGNO) < 16 ? (((REGNO) & 1) == 0 || \t\t\t\t\\\n-\t\t  (((MODE) != DImode) && ((MODE) != DFmode)))\t\t\\\n-\t\t: ((MODE) == SFmode || (MODE) == DFmode) ||\t\t\\\n-                   (MODE) == SCmode || (MODE) == DCmode)\n-\n-/* Value is 1 if it is a good idea to tie two pseudo registers when one has\n-   mode MODE1 and one has mode MODE2.\n-   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n-   for any hard reg, then this must be 0 for correct output.  */\n-\n-#define MODES_TIEABLE_P(MODE1, MODE2)\t\t\t\t\t\\\n-  (((MODE1) == SFmode || (MODE1) == DFmode)\t\t\t\t\\\n-   == ((MODE2) == SFmode || (MODE2) == DFmode))\n-\n-/* Specify the registers used for certain standard purposes.\n-   The values of these macros are register numbers.  */\n-\n-/* 370 PC isn't overloaded on a register.  */\n-\n-/* #define PC_REGNUM */\n-\n-/* Register to use for pushing function arguments.  */\n-\n-#define STACK_POINTER_REGNUM 13\n-\n-/* Base register for access to local variables of the function.  */\n-\n-#define FRAME_POINTER_REGNUM 13\n-\n-/* Value should be nonzero if functions must have frame pointers.\n-   Zero means the frame pointer need not be set up (and parms may be\n-   accessed via the stack pointer) in functions that seem suitable.\n-   This is computed in `reload', in reload1.c.  */\n-\n-#define FRAME_POINTER_REQUIRED 1\n-\n-/* Base register for access to arguments of the function.  */\n-\n-#define ARG_POINTER_REGNUM 11\n-\n-/* R10 is register in which static-chain is passed to a function.  \n-   Static-chaining is done when a nested function references as a global\n-   a stack variable of its parent: e.g.\n-        int parent_func (int arg) { \n-             int x;                            // x is in parents stack\n-             void child_func (void) { x++: }   // child references x as global var\n-             ... \n-        }\n- */\n-\n-#define STATIC_CHAIN_REGNUM 10\n-\n-/* R1 is register in which address to store a structure value is passed to\n-   a function.  This is used only when returning 64-bit long-long in a 32-bit arch\n-   and when calling functions that return structs by value. e.g.\n-        typedef struct A_s { int a,b,c; } A_t;\n-        A_t fun_returns_value (void) { \n-            A_t a; a.a=1; a.b=2 a.c=3;\n-            return a;\n-        } \n-   In the above, the storage for the return value is in the callers stack, and \n-   the R1 points at that mem location.\n- */\n-\n-#define STRUCT_VALUE_REGNUM 1\n-\n-/* Define the classes of registers for register constraints in the\n-   machine description.  Also define ranges of constants.\n-\n-   One of the classes must always be named ALL_REGS and include all hard regs.\n-   If there is more than one class, another class must be named NO_REGS\n-   and contain no registers.\n-\n-   The name GENERAL_REGS must be the name of a class (or an alias for\n-   another name such as ALL_REGS).  This is the class of registers\n-   that is allowed by \"g\" or \"r\" in a register constraint.\n-   Also, registers outside this class are allocated only when\n-   instructions express preferences for them.\n-\n-   The classes must be numbered in nondecreasing order; that is,\n-   a larger-numbered class must never be contained completely\n-   in a smaller-numbered class.\n-\n-   For any two classes, it is very desirable that there be another\n-   class that represents their union.  */\n-\n-enum reg_class\n-  {\n-    NO_REGS, ADDR_REGS, DATA_REGS,\n-    FP_REGS, ALL_REGS, LIM_REG_CLASSES\n-  };\n-\n-#define GENERAL_REGS DATA_REGS\n-#define N_REG_CLASSES (int) LIM_REG_CLASSES\n-\n-/* Give names of register classes as strings for dump file.  */\n-\n-#define REG_CLASS_NAMES \t\t\t\t\t\t\\\n-{ \"NO_REGS\", \"ADDR_REGS\", \"DATA_REGS\", \"FP_REGS\", \"ALL_REGS\" }\n-\n-/* Define which registers fit in which classes.  This is an initializer for\n-   a vector of HARD_REG_SET of length N_REG_CLASSES.  */\n-\n-#define REG_CLASS_CONTENTS {{0}, {0x0fffe}, {0x0ffff}, {0xf0000}, {0xfffff}}\n-\n-/* The same information, inverted:\n-   Return the class number of the smallest class containing\n-   reg number REGNO.  This could be a conditional expression\n-   or could index an array.  */\n-\n-#define REGNO_REG_CLASS(REGNO) \t\t\t\t\t\t\\\n-  ((REGNO) >= 16 ? FP_REGS : (REGNO) != 0 ? ADDR_REGS : DATA_REGS)\n-\n-/* The class value for index registers, and the one for base regs.  */\n-\n-#define INDEX_REG_CLASS ADDR_REGS\n-#define BASE_REG_CLASS ADDR_REGS\n-\n-/* Get reg_class from a letter such as appears in the machine description.  */\n-\n-#define REG_CLASS_FROM_LETTER(C)\t\t\t\t\t\\\n-  ((C) == 'a' ? ADDR_REGS :\t\t\t\t\t\t\\\n-  ((C) == 'd' ? DATA_REGS :\t\t\t\t\t\t\\\n-  ((C) == 'f' ? FP_REGS   : NO_REGS)))\n-\n-/* The letters I, J, K, L and M in a register constraint string can be used\n-   to stand for particular ranges of immediate operands.\n-   This macro defines what the ranges are.\n-   C is the letter, and VALUE is a constant value.\n-   Return 1 if VALUE is in the range specified by C.  */\n-\n-#define CONST_OK_FOR_LETTER_P(VALUE, C)\t\t\t\t\t\\\n-  ((C) == 'I' ? (unsigned) (VALUE) < 256 :\t\t\t\t\\\n-   (C) == 'J' ? (unsigned) (VALUE) < 4096 :\t\t\t\t\\\n-   (C) == 'K' ? (VALUE) >= -32768 && (VALUE) < 32768 : 0)\n-\n-/* Similar, but for floating constants, and defining letters G and H.\n-   Here VALUE is the CONST_DOUBLE rtx itself.  */\n-\n-#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)  1\n-\n-/* see recog.c for details */\n-#define EXTRA_CONSTRAINT(OP,C)\t\t\t\t\t\t\\\n-   ((C) == 'R' ? r_or_s_operand (OP, GET_MODE(OP)) :\t\t\t\\\n-    (C) == 'S' ? s_operand (OP, GET_MODE(OP)) :\t0)\t\t\t\\\n-\n-/* Given an rtx X being reloaded into a reg required to be in class CLASS,\n-   return the class of reg to actually use.  In general this is just CLASS;\n-   but on some machines in some cases it is preferable to use a more\n-   restrictive class.  \n-\n-   XXX We reload CONST_INT's into ADDR not DATA regs because on certain \n-   rare occasions when lots of egisters are spilled, reload() will try\n-   to put a const int into r0 and then use r0 as an index register.\n-*/\n-\n-#define PREFERRED_RELOAD_CLASS(X, CLASS)\t\t\t\t\\\n-    (GET_CODE(X) == CONST_DOUBLE ? FP_REGS :\t\t\t\t\\\n-     GET_CODE(X) == CONST_INT ? (reload_in_progress ? ADDR_REGS : DATA_REGS) :\t\\\n-     GET_CODE(X) == LABEL_REF ||\t\t\t\t\t\\\n-     GET_CODE(X) == SYMBOL_REF ||\t\t\t\t\t\\\n-     GET_CODE(X) == CONST ? ADDR_REGS : (CLASS))\n-\n-/* Return the maximum number of consecutive registers needed to represent\n-   mode MODE in a register of class CLASS.  \n-   Note that DCmode (complex double) needs two regs.\n-*/\n-\n-#define CLASS_MAX_NREGS(CLASS, MODE)\t\t\t\t\t\\\n-  ((CLASS) == FP_REGS ? \t\t\t\t\t\t\\\n-   ((GET_MODE_SIZE (MODE) + 2*UNITS_PER_WORD - 1) / (2*UNITS_PER_WORD)) :\t\\\n-   (GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n-\n-/* Stack layout; function entry, exit and calling.  */\n-\n-/* Define this if pushing a word on the stack makes the stack pointer a\n-   smaller address.  */\n-/* ------------------------------------------------------------------- */\n-\n-/* ================= */\n-#ifdef TARGET_HLASM\n-/* #define STACK_GROWS_DOWNWARD */\n-\n-/* Define this if the nominal address of the stack frame is at the\n-   high-address end of the local variables; that is, each additional local\n-   variable allocated goes at a more negative offset in the frame.  */\n-\n-/* #define FRAME_GROWS_DOWNWARD */\n-\n-/* Offset within stack frame to start allocating local variables at.\n-   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n-   first local allocated.  Otherwise, it is the offset to the BEGINNING\n-   of the first local allocated.  */\n-\n-#define STARTING_FRAME_OFFSET  \t\t\t\t\t\t\\\n-     (STACK_POINTER_OFFSET + current_function_outgoing_args_size)\n-\n-#define INITIAL_FRAME_POINTER_OFFSET(DEPTH) (DEPTH) = STARTING_FRAME_OFFSET\n-\n-/* If we generate an insn to push BYTES bytes, this says how many the stack\n-   pointer really advances by.  On the 370, we have no push instruction.  */\n-\n-#endif /* TARGET_HLASM */\n-\n-/* ================= */\n-#ifdef TARGET_ELF_ABI \n-\n-/* With ELF/Linux, stack is placed at large virtual addrs and grows down.\n-   But we want the compiler to generate posistive displacements from the \n-   stack pointer, and so we make the frame lie above the stack.  */\n-\n-#define STACK_GROWS_DOWNWARD \n-/* #define FRAME_GROWS_DOWNWARD */\n-\n-/* Offset within stack frame to start allocating local variables at.\n-   This is the offset to the BEGINNING of the first local allocated.  */\n-\n-#define STARTING_FRAME_OFFSET  \t\t\t\t\t\t\\\n-     (STACK_POINTER_OFFSET + current_function_outgoing_args_size)\n-\n-#define INITIAL_FRAME_POINTER_OFFSET(DEPTH) (DEPTH) = STARTING_FRAME_OFFSET\n-\n-#endif /* TARGET_ELF_ABI */\n-/* ================= */\n-\n-/* #define PUSH_ROUNDING(BYTES) */\n-\n-/* Accumulate the outgoing argument count so we can request the right\n-   DSA size and determine stack offset.  */\n-\n-#define ACCUMULATE_OUTGOING_ARGS 1\n-\n-/* Define offset from stack pointer, to location where a parm can be\n-   pushed.  */\n-\n-#define STACK_POINTER_OFFSET 148\n-\n-/* Offset of first parameter from the argument pointer register value.  */\n-\n-#define FIRST_PARM_OFFSET(FNDECL) 0\n-\n-/* 1 if N is a possible register number for function argument passing.\n-   On the 370, no registers are used in this way.  */\n-\n-#define FUNCTION_ARG_REGNO_P(N) 0\n-\n-/* Define a data type for recording info about an argument list during\n-   the scan of that argument list.  This data type should hold all\n-   necessary information about the function itself and about the args\n-   processed so far, enough to enable macros such as FUNCTION_ARG to\n-   determine where the next arg should go.  */\n-\n-#define CUMULATIVE_ARGS int\n-\n-/* Initialize a variable CUM of type CUMULATIVE_ARGS for a call to\n-   a function whose data type is FNTYPE.\n-   For a library call, FNTYPE is 0.  */\n-\n-#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, INDIRECT)  ((CUM) = 0)\n-\n-/* Update the data in CUM to advance over an argument of mode MODE and\n-   data type TYPE.  (TYPE is null for libcalls where that information\n-   may not be available.) */\n-\n-#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\t\t\\\n- ((CUM) += ((MODE) == DFmode || (MODE) == SFmode\t\t\t\\\n-\t    ? 256\t\t\t\t\t\t\t\\\n-\t    : (MODE) != BLKmode                 \t\t\t\\\n-\t    ? (GET_MODE_SIZE (MODE) + 3) / 4 \t\t\t\t\\\n-\t    : (int_size_in_bytes (TYPE) + 3) / 4))\n-\n-/* Define where to put the arguments to a function.  Value is zero to push\n-   the argument on the stack, or a hard register in which to store the\n-   argument.  */\n-\n-#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) 0\n-\n-/* For an arg passed partly in registers and partly in memory, this is the\n-   number of registers used.  For args passed entirely in registers or\n-   entirely in memory, zero.  */\n-\n-#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) 0\n-\n-/* Define if returning from a function call automatically pops the\n-   arguments described by the number-of-args field in the call.  */\n-\n-#define RETURN_POPS_ARGS(FUNDECL,FUNTYPE,SIZE) 0\n-\n-/* The FUNCTION_VALUE macro defines how to find the value returned by a \n-   function.  VALTYPE is the data type of the value (as a tree).\n-   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n-   otherwise, FUNC is NULL.  \n-\n-   On the 370 the return value is in R15 or R16.  However,\n-   DImode (64-bit ints) scalars need to get returned on the stack, \n-   with r15 pointing to the location.  To accomplish this, we define\n-   the RETURN_IN_MEMORY macro to be true for both blockmode (structures)\n-   and the DImode scalars.\n- */\n-\n-#define RET_REG(MODE)\t\\\n-    (((MODE) == DCmode || (MODE) == SCmode \\\n-      || (MODE) == DFmode || (MODE) == SFmode) ? 16 : 15)\n-\n-#define FUNCTION_VALUE(VALTYPE, FUNC)  \t\t\t\t\t\\\n-  gen_rtx_REG (TYPE_MODE (VALTYPE), RET_REG (TYPE_MODE (VALTYPE)))\n-\n-#define RETURN_IN_MEMORY(VALTYPE)  \\\n-  ((DImode == TYPE_MODE (VALTYPE)) || (BLKmode == TYPE_MODE (VALTYPE)))\n-\n-/* Define how to find the value returned by a library function assuming\n-   the value has mode MODE.  */\n-\n-#define LIBCALL_VALUE(MODE)  gen_rtx_REG (MODE, RET_REG (MODE))\n-\n-/* 1 if N is a possible register number for a function value.\n-   On the 370 under C/370, R15 and R16 are thus used.  */\n-\n-#define FUNCTION_VALUE_REGNO_P(N) ((N) == 15 || (N) == 16)\n-\n-/* This macro definition sets up a default value for `main' to return.  */\n-\n-#define DEFAULT_MAIN_RETURN  c_expand_return (integer_zero_node)\n-\n-\n-/* Output assembler code for a block containing the constant parts of a\n-   trampoline, leaving space for the variable parts.\n-\n-   On the 370, the trampoline contains these instructions:\n-\n-        BALR  14,0\n-        USING *,14\n-        L     STATIC_CHAIN_REGISTER,X\n-        L     15,Y\n-        BR    15\n-   X    DS    0F\n-   Y    DS    0F  */\n-/*\n-   I am confused as to why this emitting raw binary, instead of instructions ...\n-   see for example, rs6000/rs000.c for an example of a different way to\n-   do this ... especially since BASR should probably be substituted for BALR.\n- */\n-\n-#define TRAMPOLINE_TEMPLATE(FILE)\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  assemble_aligned_integer (2, GEN_INT (0x05E0));\t\t\t\\\n-  assemble_aligned_integer (2, GEN_INT (0x5800 | STATIC_CHAIN_REGNUM << 4)); \\\n-  assemble_aligned_integer (2, GEN_INT (0xE00A));\t\t\t\\\n-  assemble_aligned_integer (2, GEN_INT (0x58F0)); \t\t\t\\\n-  assemble_aligned_integer (2, GEN_INT (0xE00E));\t\t\t\\\n-  assemble_aligned_integer (2, GEN_INT (0x07FF));\t\t\t\\\n-  assemble_aligned_integer (2, const0_rtx);\t\t\t\t\\\n-  assemble_aligned_integer (2, const0_rtx);\t\t\t\t\\\n-  assemble_aligned_integer (2, const0_rtx);\t\t\t\t\\\n-  assemble_aligned_integer (2, const0_rtx);\t\t\t\t\\\n-}\n-\n-/* Length in units of the trampoline for entering a nested function.  */\n-\n-#define TRAMPOLINE_SIZE 20\n-\n-/* Emit RTL insns to initialize the variable parts of a trampoline.  */\n-\n-#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (TRAMP, 12)), CXT); \\\n-  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (TRAMP, 16)), FNADDR); \\\n-}\n-\n-/* Define EXIT_IGNORE_STACK if, when returning from a function, the stack\n-   pointer does not matter (provided there is a frame pointer).  */\n-\n-#define EXIT_IGNORE_STACK\t1\n-\n-/* Addressing modes, and classification of registers for them.  */\n-\n-/* These assume that REGNO is a hard or pseudo reg number.  They give\n-   nonzero only if REGNO is a hard reg of the suitable class or a pseudo\n-   reg currently allocated to a suitable hard reg.\n-   These definitions are NOT overridden anywhere.  */\n-\n-#define REGNO_OK_FOR_INDEX_P(REGNO) \t\t\t\t\t\\\n-  (((REGNO) > 0 && (REGNO) < 16)\t\t\t\t\t\\\n-    || (reg_renumber[REGNO] > 0 && reg_renumber[REGNO] < 16))\n-\n-#define REGNO_OK_FOR_BASE_P(REGNO) REGNO_OK_FOR_INDEX_P(REGNO)\n-\n-#define REGNO_OK_FOR_DATA_P(REGNO) \t\t\t\t\t\\\n-  ((REGNO) < 16 || (unsigned) reg_renumber[REGNO] < 16)\n-\n-#define REGNO_OK_FOR_FP_P(REGNO) \t\t\t\t\t\\\n-  ((unsigned) ((REGNO) - 16) < 4 || (unsigned) (reg_renumber[REGNO] - 16) < 4)\n-\n-/* Now macros that check whether X is a register and also,\n-   strictly, whether it is in a specified class.  */\n-\n-/* 1 if X is a data register.  */\n-\n-#define DATA_REG_P(X) (REG_P (X) && REGNO_OK_FOR_DATA_P (REGNO (X)))\n-\n-/* 1 if X is an fp register.  */\n-\n-#define FP_REG_P(X) (REG_P (X) && REGNO_OK_FOR_FP_P (REGNO (X)))\n-\n-/* 1 if X is an address register.  */\n-\n-#define ADDRESS_REG_P(X) (REG_P (X) && REGNO_OK_FOR_BASE_P (REGNO (X)))\n-\n-/* Maximum number of registers that can appear in a valid memory address.  */\n-\n-#define MAX_REGS_PER_ADDRESS 2\n-\n-/* Recognize any constant value that is a valid address.  */\n-\n-#define CONSTANT_ADDRESS_P(X)\t\t\t\t\t\t\\\n-  (GET_CODE (X) == LABEL_REF || GET_CODE (X) == SYMBOL_REF\t\t\\\n-  || GET_CODE (X) == CONST_INT || GET_CODE (X) == CONST_DOUBLE\t\t\\\n-  || (GET_CODE (X) == CONST\t\t\t\t\t\t\\\n-\t  && GET_CODE (XEXP (XEXP (X, 0), 0)) == LABEL_REF)\t\t\\\n-  || (GET_CODE (X) == CONST\t\t\t\t\t\t\\\n-\t  && GET_CODE (XEXP (XEXP (X, 0), 0)) == SYMBOL_REF\t\t\\\n-\t  && !SYMBOL_REF_EXTERNAL_P (XEXP (XEXP (X, 0), 0))))\n-\n-/* Nonzero if the constant value X is a legitimate general operand.\n-   It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n-\n-#define LEGITIMATE_CONSTANT_P(X) 1\n-\n-/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx and check\n-   its validity for a certain class.  We have two alternate definitions\n-   for each of them.  The usual definition accepts all pseudo regs; the\n-   other rejects them all.  The symbol REG_OK_STRICT causes the latter\n-   definition to be used.\n-\n-   Most source files want to accept pseudo regs in the hope that they will\n-   get allocated to the class that the insn wants them to be in.\n-   Some source files that are used after register allocation\n-   need to be strict.  */\n-\n-#ifndef REG_OK_STRICT\n-\n-/* Nonzero if X is a hard reg that can be used as an index or if it is\n-  a pseudo reg.  */\n-\n-#define REG_OK_FOR_INDEX_P(X)\t\t\t\t\t\t\\\n-  ((REGNO(X) > 0 && REGNO(X) < 16) || REGNO(X) >= 20)\n-\n-/* Nonzero if X is a hard reg that can be used as a base reg or if it is\n-   a pseudo reg.  */\n-\n-#define REG_OK_FOR_BASE_P(X)\tREG_OK_FOR_INDEX_P(X)\n-\n-#else /* REG_OK_STRICT */\n-\n-/* Nonzero if X is a hard reg that can be used as an index.  */\n-\n-#define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P(REGNO(X))\n-\n-/* Nonzero if X is a hard reg that can be used as a base reg.  */\n-\n-#define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P(REGNO(X))\n-\n-#endif /* REG_OK_STRICT */\n-\n-/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression that is a\n-   valid memory address for an instruction.\n-   The MODE argument is the machine mode for the MEM expression\n-   that wants to use this address.\n-\n-   The other macros defined here are used only in GO_IF_LEGITIMATE_ADDRESS,\n-   except for CONSTANT_ADDRESS_P which is actually machine-independent.  \n-*/\n-\n-#define COUNT_REGS(X, REGS, FAIL)\t\t\t\t\t\\\n- if (REG_P (X)) {\t\t\t\t\t\t\t\\\n-   if (REG_OK_FOR_BASE_P (X)) REGS += 1;\t\t\t\t\\\n-   else goto FAIL;\t\t\t\t\t\t\t\\\n- }\t\t\t\t\t\t\t\t\t\\\n- else if (GET_CODE (X) != CONST_INT || (unsigned) INTVAL (X) >= 4096)\t\\\n-   goto FAIL;\n-\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  if (REG_P (X) && REG_OK_FOR_BASE_P (X))\t\t\t\t\\\n-    goto ADDR;\t\t\t\t\t\t\t\t\\\n-  if (GET_CODE (X) == PLUS)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      int regs = 0;\t\t\t\t\t\t\t\\\n-      rtx x0 = XEXP (X, 0);\t\t\t\t\t\t\\\n-      rtx x1 = XEXP (X, 1);\t\t\t\t\t\t\\\n-      if (GET_CODE (x0) == PLUS)\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  COUNT_REGS (XEXP (x0, 0), regs, FAIL);\t\t\t\\\n-\t  COUNT_REGS (XEXP (x0, 1), regs, FAIL);\t\t\t\\\n-\t  COUNT_REGS (x1, regs, FAIL);\t\t\t\t\t\\\n-\t  if (regs == 2)\t\t\t\t\t\t\\\n-\t    goto ADDR;\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      else if (GET_CODE (x1) == PLUS)\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  COUNT_REGS (x0, regs, FAIL);\t\t\t\t\t\\\n-\t  COUNT_REGS (XEXP (x1, 0), regs, FAIL);\t\t\t\\\n-\t  COUNT_REGS (XEXP (x1, 1), regs, FAIL);\t\t\t\\\n-\t  if (regs == 2)\t\t\t\t\t\t\\\n-\t    goto ADDR;\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  COUNT_REGS (x0, regs, FAIL);\t\t\t\t\t\\\n-\t  COUNT_REGS (x1, regs, FAIL);\t\t\t\t\t\\\n-\t  if (regs != 0)\t\t\t\t\t\t\\\n-\t    goto ADDR;\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  FAIL: ;\t\t\t\t\t\t\t\t\\\n-}\n-\n-/* The 370 has no mode dependent addresses.  */\n-\n-#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR, LABEL)\n-\n-/* Macro: LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)\n-   Try machine-dependent ways of modifying an illegitimate address\n-   to be legitimate.  If we find one, return the new, valid address.\n-   This macro is used in only one place: `memory_address' in explow.c. \n-  \n-   Several comments:\n-   (1) It's not obvious that this macro results in better code\n-       than its omission does. For historical reasons we leave it in.\n-  \n-   (2) This macro may be (???) implicated in the accidental promotion\n-       or RS operand to RX operands, which bombs out any RS, SI, SS \n-       instruction that was expecting a simple address.  Note that \n-       this occurs fairly rarely ...\n-  \n-   (3) There is a bug somewhere that causes either r4 to be spilled,\n-       or causes r0 to be used as a base register.  Changeing the macro \n-       below will make the bug move around, but will not make it go away \n-       ... Note that this is a rare bug ...\n-   \n- */\n-\n-#define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  if (GET_CODE (X) == PLUS && CONSTANT_ADDRESS_P (XEXP (X, 1)))\t\t\\\n-    (X) = gen_rtx_PLUS (SImode, XEXP (X, 0),\t\t\t\t\\\n-\t\t\tcopy_to_mode_reg (SImode, XEXP (X, 1)));\t\\\n-  if (GET_CODE (X) == PLUS && CONSTANT_ADDRESS_P (XEXP (X, 0)))\t\t\\\n-    (X) = gen_rtx_PLUS (SImode, XEXP (X, 1),\t\t\t\t\\\n-\t\t\tcopy_to_mode_reg (SImode, XEXP (X, 0)));\t\\\n-  if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 0)) == MULT)\t\t\\\n-    (X) = gen_rtx_PLUS (SImode, XEXP (X, 1),\t\t\t\t\\\n-\t\t\tforce_operand (XEXP (X, 0), 0));\t\t\\\n-  if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 1)) == MULT)\t\t\\\n-    (X) = gen_rtx_PLUS (SImode, XEXP (X, 0),\t\t\t\t\\\n-\t\t\tforce_operand (XEXP (X, 1), 0));\t\t\\\n-  if (memory_address_p (MODE, X))\t\t\t\t\t\\\n-    goto WIN;\t\t\t\t\t\t\t\t\\\n-}\n-\n-/* Specify the machine mode that this machine uses for the index in the\n-   tablejump instruction.  */\n-\n-#define CASE_VECTOR_MODE SImode\n-\n-/* Define this if the tablejump instruction expects the table to contain\n-   offsets from the address of the table.\n-   Do not define this if the table should contain absolute addresses.  */\n-\n-/* #define CASE_VECTOR_PC_RELATIVE */\n-\n-/* Define this if fixuns_trunc is the same as fix_trunc.  */\n-\n-#define FIXUNS_TRUNC_LIKE_FIX_TRUNC\n-\n-/* We use \"unsigned char\" as default.  */\n-\n-#define DEFAULT_SIGNED_CHAR 0\n-\n-/* Max number of bytes we can move from memory to memory in one reasonably\n-   fast instruction.  */\n-\n-#define MOVE_MAX 256\n-\n-/* Nonzero if access to memory by bytes is slow and undesirable.  */\n-\n-#define SLOW_BYTE_ACCESS 1\n-\n-/* Define if shifts truncate the shift count which implies one can omit\n-   a sign-extension or zero-extension of a shift count.  */\n-\n-/* #define SHIFT_COUNT_TRUNCATED */\n-\n-/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n-   is done just by pretending it is already truncated.  */\n-\n-#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC)\t(OUTPREC != 16)\n-\n-/* ??? Investigate defining STORE_FLAG_VALUE to (-1).  */\n-\n-/* When a prototype says `char' or `short', really pass an `int'.  */\n-\n-#define PROMOTE_PROTOTYPES 1\n-\n-/* Don't perform CSE on function addresses.  */\n-\n-#define NO_FUNCTION_CSE\n-\n-/* Specify the machine mode that pointers have.\n-   After generation of rtl, the compiler makes no further distinction\n-   between pointers and any other objects of this machine mode.  */\n-\n-#define Pmode SImode\n-\n-/* A function address in a call instruction is a byte address (for\n-   indexing purposes) so give the MEM rtx a byte's mode.  */\n-\n-#define FUNCTION_MODE QImode\n-\n-/*   A C statement (sans semicolon) to update the integer variable COST\n-     based on the relationship between INSN that is dependent on\n-     DEP_INSN through the dependence LINK.  The default is to make no\n-     adjustment to COST.  This can be used for example to specify to\n-     the scheduler that an output- or anti-dependence does not incur\n-     the same cost as a data-dependence. \n-\n-     We will want to use this to indicate that there is a cost associated \n-     with the loading, followed by use of base registers ... \n-#define ADJUST_COST (INSN, LINK, DEP_INSN, COST)\n- */\n-\n-/* Tell final.c how to eliminate redundant test instructions.  */\n-\n-/* Here we define machine-dependent flags and fields in cc_status\n-   (see `conditions.h').  */\n-\n-/* Store in cc_status the expressions that the condition codes will\n-   describe after execution of an instruction whose pattern is EXP.\n-   Do not alter them if the instruction would not alter the cc's.\n-\n-   On the 370, load insns do not alter the cc's.  However, in some\n-   cases these instructions can make it possibly invalid to use the\n-   saved cc's.  In those cases we clear out some or all of the saved\n-   cc's so they won't be used.  \n-\n-   Note that only some arith instructions set the CC.  These include\n-   add, subtract, complement, various shifts.  Note that multiply\n-   and divide do *not* set set the CC.  Therefore, in the code below,\n-   don't set the status for MUL, DIV, etc.\n-\n-   Note that the bitwise ops set the condition code, but not in a \n-   way that we can make use of it. So we treat these as clobbering, \n-   rather than setting the CC.  These are clobbered in the individual\n-   instruction patterns that use them.  Use CC_STATUS_INIT to clobber.\n-*/\n-\n-#define NOTICE_UPDATE_CC(EXP, INSN)\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  rtx exp = (EXP);\t\t\t\t\t\t\t\\\n-  if (GET_CODE (exp) == PARALLEL) /* Check this */\t\t\t\\\n-    exp = XVECEXP (exp, 0, 0);\t\t\t\t\t\t\\\n-  if (GET_CODE (exp) != SET)\t\t\t\t\t\t\\\n-    CC_STATUS_INIT;\t\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      if (XEXP (exp, 0) == cc0_rtx)\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  cc_status.value1 = XEXP (exp, 0);\t\t\t\t\\\n-\t  cc_status.value2 = XEXP (exp, 1);\t\t\t\t\\\n-\t  cc_status.flags = 0;\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  if (cc_status.value1\t\t\t\t\t\t\\\n-\t      && reg_mentioned_p (XEXP (exp, 0), cc_status.value1))\t\\\n-\t    cc_status.value1 = 0;\t\t\t\t\t\\\n-\t  if (cc_status.value2\t\t\t\t\t\t\\\n-\t      && reg_mentioned_p (XEXP (exp, 0), cc_status.value2))\t\\\n-\t    cc_status.value2 = 0;\t\t\t\t\t\\\n-\t  switch (GET_CODE (XEXP (exp, 1)))\t\t\t\t\\\n-\t    {\t\t\t\t\t\t\t\t\\\n-\t      case PLUS:     case MINUS: case NEG:    \t\t\t\\\n-\t      case NOT:\t case ABS:\t\t\t\t\t\\\n-\t\tCC_STATUS_SET (XEXP (exp, 0), XEXP (exp, 1));\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-              /* mult and div don't set any cc codes !! */\t\t\\\n-\t      case MULT:  /* case UMULT: */ case DIV:      case UDIV: \t\\\n-              /* and, or and xor set the cc's the wrong way !! */\t\\\n-\t      case AND:   case IOR:    case XOR:  \t\t\t\\\n-              /* some shifts set the CC some don't.  */\t\t\t\\\n-              case ASHIFT: \t case ASHIFTRT:  \t\t\t\\\n-                 do {} while (0);\t\t\t\t\t\\\n-              default:\t\t\t\t\t\t\t\\\n-                break;\t\t\t\t\t\t\t\\\n-\t    }\t\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-}\n-\n-\n-#define CC_STATUS_SET(V1, V2)\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  cc_status.flags = 0;\t\t\t\t\t\t\t\\\n-  cc_status.value1 = (V1);\t\t\t\t\t\t\\\n-  cc_status.value2 = (V2);\t\t\t\t\t\t\\\n-  if (cc_status.value1\t\t\t\t\t\t\t\\\n-      && reg_mentioned_p (cc_status.value1, cc_status.value2))\t\t\\\n-    cc_status.value2 = 0;\t\t\t\t\t\t\\\n-}\n-\n-#define OUTPUT_JUMP(NORMAL, FLOAT, NO_OV) \t\t\t\t\\\n-{ if (cc_status.flags & CC_NO_OVERFLOW)\treturn NO_OV; return NORMAL; }\n-\n-/* ------------------------------------------ */\n-/* Control the assembler format that we output.  */\n-\n-/* Define standard character escape sequences for non-ASCII targets\n-   only.  */\n-\n-#ifdef TARGET_EBCDIC\n-#define TARGET_ESC\t39\n-#define TARGET_BELL\t47\n-#define TARGET_BS\t22\n-#define TARGET_TAB\t5\n-#define TARGET_NEWLINE\t21\n-#define TARGET_VT\t11\n-#define TARGET_FF\t12\n-#define TARGET_CR\t13\n-#endif\n-\n-/* ======================================================== */\n-\n-#ifdef TARGET_HLASM\n-#define TEXT_SECTION_ASM_OP \"* Program text area\"\n-#define DATA_SECTION_ASM_OP \"* Program data area\"\n-#define INIT_SECTION_ASM_OP \"* Program initialization area\"\n-#define SHARED_SECTION_ASM_OP \"* Program shared data\"\n-#define CTOR_LIST_BEGIN\t\t/* NO OP */\n-#define CTOR_LIST_END\t\t/* NO OP */\n-#define MAX_MVS_LABEL_SIZE 8\n-\n-/* How to refer to registers in assembler output.  This sequence is\n-   indexed by compiler's hard-register-number (see above).  */\n-\n-#define REGISTER_NAMES\t\t\t\t\t\t\t\\\n-{ \"0\",  \"1\",  \"2\",  \"3\",  \"4\",  \"5\",  \"6\",  \"7\",\t\t\t\\\n-  \"8\",  \"9\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\",\t\t\t\\\n-  \"0\",  \"2\",  \"4\",  \"6\"\t\t\t\t\t\t\t\\\n-}\n-\n-#define ASM_COMMENT_START \"*\"\n-#define ASM_APP_OFF \"\"\n-#define ASM_APP_ON \"\"\n-\n-#define ASM_OUTPUT_LABEL(FILE, NAME) \t\t\t\t\t\\\n-{ assemble_name (FILE, NAME); fputs (\"\\tEQU\\t*\\n\", FILE); }\n-\n-#define ASM_OUTPUT_EXTERNAL(FILE, DECL, NAME)\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  char temp[MAX_MVS_LABEL_SIZE + 1];\t\t\t\t\t\\\n-  if (mvs_check_alias (NAME, temp) == 2)\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"%s\\tALIAS\\tC'%s'\\n\", temp, NAME);\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-}\n-\n-/* MVS externals are limited to 8 characters, upper case only.\n-   The '_' is mapped to '@', except for MVS functions, then '#'.  */\n-\n-\n-#define ASM_OUTPUT_LABELREF(FILE, NAME)\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  char *bp, ch, temp[MAX_MVS_LABEL_SIZE + 1];\t\t\t\t\\\n-  if (!mvs_get_alias (NAME, temp))\t\t\t\t\t\\\n-    strcpy (temp, NAME);\t\t\t\t\t\t\\\n-  if (!strcmp (temp,\"main\"))\t\t\t\t\t\t\\\n-    strcpy (temp,\"gccmain\");\t\t\t\t\t\t\\\n-  if (mvs_function_check (temp))\t\t\t\t\t\\\n-    ch = '#';\t\t\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    ch = '@';\t\t\t\t\t\t\t\t\\\n-  for (bp = temp; *bp; bp++)\t\t\t\t\t\t\\\n-    *bp = (*bp == '_' ? ch : TOUPPER (*bp));\t\t\t\t\\\n-  fprintf (FILE, \"%s\", temp);\t\t\t\t\t\t\\\n-}\n-\n-#define ASM_GENERATE_INTERNAL_LABEL(LABEL, PREFIX, NUM)\t\t\t\\\n-  sprintf (LABEL, \"*%s%lu\", PREFIX, (unsigned long)(NUM))\n-\n-/* Generate case label.  For HLASM we can change to the data CSECT\n-   and put the vectors out of the code body. The assembler just\n-   concatenates CSECTs with the same name.  */\n-\n-#define ASM_OUTPUT_CASE_LABEL(FILE, PREFIX, NUM, TABLE)\t\t\t\\\n-  fprintf (FILE, \"\\tDS\\t0F\\n\");                                         \\\n-  fprintf (FILE,\"\\tCSECT\\n\");                                           \\\n-  fprintf (FILE, \"%s%d\\tEQU\\t*\\n\", PREFIX, NUM)\n-\n-/* Put the CSECT back to the code body */\n-\n-#define ASM_OUTPUT_CASE_END(FILE, NUM, TABLE)                           \\\n-  assemble_name (FILE, mvs_function_name);                              \\\n-  fputs (\"\\tCSECT\\n\", FILE);\n-\n-/* This is how to output an element of a case-vector that is absolute.  */\n-\n-#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \t\t\t\t\\\n-  fprintf (FILE, \"\\tDC\\tA(L%d)\\n\", VALUE)\n-\n-/* This is how to output an element of a case-vector that is relative.  */\n-\n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \t\t\\\n-  fprintf (FILE, \"\\tDC\\tA(L%d-L%d)\\n\", VALUE, REL)\n-\n-/* This is how to output an insn to push a register on the stack.\n-    It need not be very fast code.  \n-   Right now, PUSH & POP are used only when profiling is enabled, \n-   and then, only to push the static chain reg and the function struct \n-   value reg, and only if those are used.  Since profiling is not\n-   supported anyway, punt on this.  */\n-\n-#define ASM_OUTPUT_REG_PUSH(FILE, REGNO)\t\t\t\t\\\n-  mvs_check_page (FILE, 8, 4);\t\t\t\t\t\t\\\n-  fprintf (FILE, \"\\tS\\t13,=F'4'\\n\\tST\\t%s,%d(13)\\n\",\t\t\t\\\n-     reg_names[REGNO], STACK_POINTER_OFFSET)\n-\n-/* This is how to output an insn to pop a register from the stack.\n-   It need not be very fast code.  */\n-\n-#define ASM_OUTPUT_REG_POP(FILE, REGNO)\t\t\t\t\t\\\n-  mvs_check_page (FILE, 8, 0);\t\t\t\t\t\t\\\n-  fprintf (FILE, \"\\tL\\t%s,%d(13)\\n\\tLA\\t13,4(13)\\n\",\t\t\t\\\n-     reg_names[REGNO], STACK_POINTER_OFFSET)\n-\n-/* This outputs a text string.  The string are chopped up to fit into\n-   an 80 byte record.  Also, control and special characters, interpreted\n-   by the IBM assembler, are output numerically.  */\n-\n-#define MVS_ASCII_TEXT_LENGTH 48\n-\n-#define ASM_OUTPUT_ASCII(FILE, PTR, LEN)\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  size_t i, limit = (LEN);\t\t\t\t\t\t\\\n-  int j;\t\t\t\t\t\t\t\t\\\n-  for (j = 0, i = 0; i < limit; j++, i++)\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      int c = (PTR)[i];\t\t\t\t\t\t\t\\\n-      if (ISCNTRL (c) || c == '&')\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  if (j % MVS_ASCII_TEXT_LENGTH != 0 )\t\t\t\t\\\n-\t    fprintf (FILE, \"'\\n\");\t\t\t\t\t\\\n-\t  j = -1;\t\t\t\t\t\t\t\\\n-\t  fprintf (FILE, \"\\tDC\\tX'%X'\\n\", c );\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  if (j % MVS_ASCII_TEXT_LENGTH == 0)\t\t\t\t\\\n-            fprintf (FILE, \"\\tDC\\tC'\");\t\t\t\t\t\\\n-          if ( c == '\\'' )                                       \t\\\n-\t    fprintf (FILE, \"%c%c\", c, c);                        \t\\\n-\t  else                                                   \t\\\n-\t    fprintf (FILE, \"%c\", c);                             \t\\\n-\t  if (j % MVS_ASCII_TEXT_LENGTH == MVS_ASCII_TEXT_LENGTH - 1)\t\\\n-\t    fprintf (FILE, \"'\\n\" );\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  if (j % MVS_ASCII_TEXT_LENGTH != 0)\t\t\t\t\t\\\n-    fprintf (FILE, \"'\\n\");\t\t\t\t\t\t\\\n-}\n-\n-/* This is how to output an assembler line that says to advance the\n-   location counter to a multiple of 2**LOG bytes.  */\n-\n-#define ASM_OUTPUT_ALIGN(FILE, LOG)\t\t\t\t\t\\\n-  if (LOG)\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      if ((LOG) == 1)\t\t\t\t\t\t\t\\\n-        fprintf (FILE, \"\\tDS\\t0H\\n\" );\t\t\t\t\t\\\n-      else \t\t\t\t\t\t\t\t\\\n-        fprintf (FILE, \"\\tDS\\t0F\\n\" );\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-\n-/* The maximum length of memory that the IBM assembler will allow in one\n-   DS operation.  */\n-\n-#define MAX_CHUNK 32767\n-\n-/* A C statement to output to the stdio stream FILE an assembler\n-   instruction to advance the location counter by SIZE bytes. Those\n-   bytes should be zero when loaded.  */\n-\n-#define ASM_OUTPUT_SKIP(FILE, SIZE)  \t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  unsigned HOST_WIDE_INT s;\t\t\t\t\t\t\\\n-  int  k;\t\t\t\t\t\t\t\t\\\n-  for (s = (SIZE); s > 0; s -= MAX_CHUNK)\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      if (s > MAX_CHUNK)\t\t\t\t\t\t\\\n-\tk = MAX_CHUNK;\t\t\t\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\t\\\n-\tk = s;\t\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\tDS\\tXL%d\\n\", k);\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-}\n-\n-/* A C statement (sans semicolon) to output to the stdio stream\n-   FILE the assembler definition of a common-label named NAME whose\n-   size is SIZE bytes.  The variable ROUNDED is the size rounded up\n-   to whatever alignment the caller wants.  */\n-\n-#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED) \t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  char temp[MAX_MVS_LABEL_SIZE + 1];\t\t\t\t\t\\\n-  if (mvs_check_alias(NAME, temp) == 2)\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"%s\\tALIAS\\tC'%s'\\n\", temp, NAME);\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  fputs (\"\\tENTRY\\t\", FILE);\t\t\t\t\t\t\\\n-  assemble_name (FILE, NAME);\t\t\t\t\t\t\\\n-  fputs (\"\\n\", FILE);\t\t\t\t\t\t\t\\\n-  fprintf (FILE, \"\\tDS\\t0F\\n\");\t\t\t\t\t\t\\\n-  ASM_OUTPUT_LABEL (FILE,NAME);\t\t\t\t\t\t\\\n-  ASM_OUTPUT_SKIP (FILE,SIZE);\t\t\t\t\t\t\\\n-}\n-\n-/* A C statement (sans semicolon) to output to the stdio stream\n-   FILE the assembler definition of a local-common-label named NAME\n-   whose size is SIZE bytes.  The variable ROUNDED is the size\n-   rounded up to whatever alignment the caller wants.  */\n-\n-#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED) \t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  fprintf (FILE, \"\\tDS\\t0F\\n\");\t\t\t\t\t\t\\\n-  ASM_OUTPUT_LABEL (FILE,NAME);\t\t\t\t\t\t\\\n-  ASM_OUTPUT_SKIP (FILE,SIZE);\t\t\t\t\t\t\\\n-}\n-\n-#define ASM_PN_FORMAT \"%s%lu\"\n-\n-/* Print operand XV (an rtx) in assembler syntax to file FILE.\n-   CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n-   For `%' followed by punctuation, CODE is the punctuation and XV is null.  */\n-\n-#define PRINT_OPERAND(FILE, XV, CODE)\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  switch (GET_CODE (XV))\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      static char curreg[4];\t\t\t\t\t\t\\\n-      case REG:\t\t\t\t\t\t\t\t\\\n-\tif (CODE == 'N')\t\t\t\t\t\t\\\n-\t    strcpy (curreg, reg_names[REGNO (XV) + 1]);\t\t\t\\\n-\telse\t\t\t\t\t\t\t\t\\\n-\t    strcpy (curreg, reg_names[REGNO (XV)]);\t\t\t\\\n-\tfprintf (FILE, \"%s\", curreg);\t\t\t\t\t\\\n-\tbreak;\t\t\t\t\t\t\t\t\\\n-      case MEM:\t\t\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  rtx addr = XEXP (XV, 0);\t\t\t\t\t\\\n-\t  if (CODE == 'O')\t\t\t\t\t\t\\\n-\t    {\t\t\t\t\t\t\t\t\\\n-\t      if (GET_CODE (addr) == PLUS)\t\t\t\t\\\n-\t\tfprintf (FILE, HOST_WIDE_INT_PRINT_DEC, INTVAL (XEXP (addr, 1))); \\\n-\t      else\t\t\t\t\t\t\t\\\n-\t\tfprintf (FILE, \"0\");\t\t\t\t\t\\\n-\t    }\t\t\t\t\t\t\t\t\\\n-\t  else if (CODE == 'R')\t\t\t\t\t\t\\\n-\t    {\t\t\t\t\t\t\t\t\\\n-\t      if (GET_CODE (addr) == PLUS)\t\t\t\t\\\n-\t\tfprintf (FILE, \"%s\", reg_names[REGNO (XEXP (addr, 0))]);\\\n-\t      else\t\t\t\t\t\t\t\\\n-\t\tfprintf (FILE, \"%s\", reg_names[REGNO (addr)]);\t\t\\\n-\t    }\t\t\t\t\t\t\t\t\\\n-\t  else\t\t\t\t\t\t\t\t\\\n-\t    output_address (XEXP (XV, 0));\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-\tbreak;\t\t\t\t\t\t\t\t\\\n-      case SYMBOL_REF:\t\t\t\t\t\t\t\\\n-      case LABEL_REF:\t\t\t\t\t\t\t\\\n-\tmvs_page_lit += 4;\t\t\t\t\t\t\\\n-\tif (SYMBOL_REF_EXTERNAL_P (XV)) fprintf (FILE, \"=V(\");\t\t\\\n-\telse                      fprintf (FILE, \"=A(\");\t\t\\\n-\toutput_addr_const (FILE, XV);\t\t\t\t\t\\\n-\tfprintf (FILE, \")\");\t\t\t\t\t\t\\\n-\tbreak;\t\t\t\t\t\t\t\t\\\n-      case CONST_INT:\t\t\t\t\t        \t\\\n-\tif (CODE == 'B')\t\t\t\t\t\t\\\n-\t  fprintf (FILE, \"%d\", (int) (INTVAL (XV) & 0xff));\t\t\\\n-\telse if (CODE == 'X')\t\t\t\t\t\t\\\n-\t  fprintf (FILE, \"%02X\", (int) (INTVAL (XV) & 0xff));\t\t\\\n-\telse if (CODE == 'h')\t\t\t\t\t\t\\\n-\t  fprintf (FILE, HOST_WIDE_INT_PRINT_DEC, (INTVAL (XV) << 16) >> 16); \\\n-\telse if (CODE == 'H')\t\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    mvs_page_lit += 2;\t\t\t\t\t\t\\\n-\t    fprintf (FILE, \"=H'\" HOST_WIDE_INT_PRINT_DEC \"'\", (INTVAL (XV) << 16) >> 16); \\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\telse if (CODE == 'K')\t\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-            /* auto sign-extension of signed 16-bit to signed 32-bit */\t\\\n-\t    mvs_page_lit += 4;\t\t\t\t\t\t\\\n-\t    fprintf (FILE, \"=F'\" HOST_WIDE_INT_PRINT_DEC \"'\", (INTVAL (XV) << 16) >> 16); \\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\telse if (CODE == 'W')\t\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-            /* hand-built sign-extension of signed 32-bit to 64-bit */\t\\\n-\t    mvs_page_lit += 8;\t\t\t\t\t\t\\\n-\t    if (0 <=  INTVAL (XV)) {\t\t\t\t\t\\\n-\t       fprintf (FILE, \"=XL8'00000000\");\t\t\t\t\\\n-            } else {\t\t\t\t\t\t\t\\\n-\t       fprintf (FILE, \"=XL8'FFFFFFFF\");\t\t\t\t\\\n-            }\t\t\t\t\t\t\t\t\\\n-\t    fprintf (FILE, \"%08X'\", INTVAL (XV));\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\telse\t\t\t\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    mvs_page_lit += 4;\t\t\t\t\t\t\\\n-\t    fprintf (FILE, \"=F'\" HOST_WIDE_INT_PRINT_DEC \"'\", INTVAL (XV)); \\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\tbreak;\t\t\t\t\t\t\t\t\\\n-      case CONST_DOUBLE:\t\t\t\t\t\t\\\n-\tif (GET_MODE (XV) == DImode)\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    if (CODE == 'M')\t\t\t\t\t\t\\\n-\t      {\t\t\t\t\t\t\t\t\\\n-\t\tmvs_page_lit += 4;\t\t\t\t\t\\\n-\t\tfprintf (FILE, \"=XL4'%08X'\", CONST_DOUBLE_LOW (XV));\t\\\n-\t      }\t\t\t\t\t\t\t\t\\\n-\t    else if (CODE == 'L')\t\t\t\t\t\\\n-\t      {\t\t\t\t\t\t\t\t\\\n-\t\tmvs_page_lit += 4;\t\t\t\t\t\\\n-\t\tfprintf (FILE, \"=XL4'%08X'\", CONST_DOUBLE_HIGH (XV));\t\\\n-\t      }\t\t\t\t\t\t\t\t\\\n-\t    else\t\t\t\t\t\t\t\\\n-\t      {\t\t\t\t\t\t\t\t\\\n-\t\tmvs_page_lit += 8;\t\t\t\t\t\\\n-\t\tfprintf (FILE, \"=XL8'%08X%08X'\", CONST_DOUBLE_LOW (XV),\t\\\n-\t\t\tCONST_DOUBLE_HIGH (XV));\t\t\t\\\n-\t      }\t\t\t\t\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\telse\t\t\t\t\t\t\t\t\\\n-\t  { \t\t\t\t\t\t\t\t\\\n-            char buf[50];\t\t\t\t\t\t\\\n-\t    if (GET_MODE (XV) == SFmode)\t\t\t\t\\\n-\t      {\t\t\t\t\t\t\t\t\\\n-\t\tmvs_page_lit += 4;\t\t\t\t\t\\\n-\t\treal_to_decimal (buf, CONST_DOUBLE_REAL_VALUE (XV),\t\\\n-\t\t\t\t sizeof (buf), 0, 1);\t\t\t\\\n-\t\tfprintf (FILE, \"=E'%s'\", buf);\t\t\t\t\\\n-\t      }\t\t\t\t\t\t\t\t\\\n-\t    else if (GET_MODE (XV) == DFmode)\t\t\t\t\\\n-\t      {\t\t\t\t\t\t\t\t\\\n-\t\tmvs_page_lit += 8;\t\t\t\t\t\\\n-\t\treal_to_decimal (buf, CONST_DOUBLE_REAL_VALUE (XV),\t\\\n-\t\t\t\t sizeof (buf), 0, 1);\t\t\t\\\n-\t\tfprintf (FILE, \"=D'%s'\", buf);\t\t\t\t\\\n-\t      }\t\t\t\t\t\t\t\t\\\n-\t    else /* VOIDmode */\t\t\t\t\t\t\\\n-\t      {\t\t\t\t\t\t\t\t\\\n-\t\tmvs_page_lit += 8;\t\t\t\t\t\\\n-\t\tfprintf (FILE, \"=XL8'%08X%08X'\", \t\t\t\\\n-\t\t\tCONST_DOUBLE_HIGH (XV), CONST_DOUBLE_LOW (XV));\t\\\n-\t      }\t\t\t\t\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\tbreak;\t\t\t\t\t\t\t\t\\\n-      case CONST:\t\t\t\t\t\t\t\\\n-\tif (GET_CODE (XEXP (XV, 0)) == PLUS\t\t\t\t\\\n-\t   && GET_CODE (XEXP (XEXP (XV, 0), 0)) == SYMBOL_REF)\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    mvs_page_lit += 4;\t\t\t\t\t\t\\\n-\t    if (SYMBOL_REF_EXTERNAL_P (XEXP (XEXP (XV, 0), 0)))\t\t\\\n-\t      {\t\t\t\t\t\t\t\t\\\n-\t\tfprintf (FILE, \"=V(\");\t\t\t\t\t\\\n-\t\tASM_OUTPUT_LABELREF (FILE,\t\t\t\t\\\n-\t\t\t\t  XSTR (XEXP (XEXP (XV, 0), 0), 0));\t\\\n-\t\tfprintf (FILE, \")\\n\\tA\\t%s,=F'\" HOST_WIDE_INT_PRINT_DEC \"'\", \\\n-\t\t\t curreg, INTVAL (XEXP (XEXP (XV, 0), 1)));\t\\\n-\t      }\t\t\t\t\t\t\t\t\\\n-\t    else\t\t\t\t\t\t\t\\\n-\t      {\t\t\t\t\t\t\t\t\\\n-\t\tfprintf (FILE, \"=A(\");\t\t\t\t\t\\\n-\t\toutput_addr_const (FILE, XV);\t\t\t\t\\\n-\t\tfprintf (FILE, \")\");\t\t\t\t\t\\\n-\t      }\t\t\t\t\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\telse\t\t\t\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    mvs_page_lit += 4;\t\t\t\t\t\t\\\n-\t    fprintf (FILE, \"=F'\");\t\t\t\t\t\\\n-\t    output_addr_const (FILE, XV);\t\t\t\t\\\n-\t    fprintf (FILE, \"'\");\t\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\tbreak;\t\t\t\t\t\t\t\t\\\n-      default:\t\t\t\t\t\t\t\t\\\n-\tabort();\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-}\n-\n-#define PRINT_OPERAND_ADDRESS(FILE, ADDR)\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  rtx breg, xreg, offset, plus;\t\t\t\t\t\t\\\n-  \t\t\t\t\t\t\t\t\t\\\n-  switch (GET_CODE (ADDR))\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      case REG:\t\t\t\t\t\t\t\t\\\n-\tfprintf (FILE, \"0(%s)\", reg_names[REGNO (ADDR)]);\t\t\\\n-\tbreak;\t\t\t\t\t\t\t\t\\\n-      case PLUS:\t\t\t\t\t\t\t\\\n-\tbreg = 0;\t\t\t\t\t\t\t\\\n-\txreg = 0;\t\t\t\t\t\t\t\\\n-\toffset = 0;\t\t\t\t\t\t\t\\\n-\tif (GET_CODE (XEXP (ADDR, 0)) == PLUS)\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    if (GET_CODE (XEXP (ADDR, 1)) == REG)\t\t\t\\\n-\t      breg = XEXP (ADDR, 1);\t\t\t\t\t\\\n-\t    else\t\t\t\t\t\t\t\\\n-\t      offset = XEXP (ADDR, 1);\t\t\t\t\t\\\n-\t    plus = XEXP (ADDR, 0);\t\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\telse\t\t\t\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    if (GET_CODE (XEXP (ADDR, 0)) == REG)\t\t\t\\\n-\t      breg = XEXP (ADDR, 0);\t\t\t\t\t\\\n-\t    else\t\t\t\t\t\t\t\\\n-\t      offset = XEXP (ADDR, 0);\t\t\t\t\t\\\n-\t    plus = XEXP (ADDR, 1);\t\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\tif (GET_CODE (plus) == PLUS)\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    if (GET_CODE (XEXP (plus, 0)) == REG)\t\t\t\\\n-\t      {\t\t\t\t\t\t\t\t\\\n-\t\tif (breg)\t\t\t\t\t\t\\\n-\t\t  xreg = XEXP (plus, 0);\t\t\t\t\\\n-\t\telse\t\t\t\t\t\t\t\\\n-\t\t  breg = XEXP (plus, 0);\t\t\t\t\\\n-\t      }\t\t\t\t\t\t\t\t\\\n-\t    else\t\t\t\t\t\t\t\\\n-\t      {\t\t\t\t\t\t\t\t\\\n-\t\toffset = XEXP (plus, 0);\t\t\t\t\\\n-\t      }\t\t\t\t\t\t\t\t\\\n-\t    if (GET_CODE (XEXP (plus, 1)) == REG)\t\t\t\\\n-\t      {\t\t\t\t\t\t\t\t\\\n-\t\tif (breg)\t\t\t\t\t\t\\\n-\t\t  xreg = XEXP (plus, 1);\t\t\t\t\\\n-\t\telse\t\t\t\t\t\t\t\\\n-\t\t  breg = XEXP (plus, 1);\t\t\t\t\\\n-\t      }\t\t\t\t\t\t\t\t\\\n-\t    else\t\t\t\t\t\t\t\\\n-\t      {\t\t\t\t\t\t\t\t\\\n-\t\toffset = XEXP (plus, 1);\t\t\t\t\\\n-\t      }\t\t\t\t\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\telse if (GET_CODE (plus) == REG)\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    if (breg)\t\t\t\t\t\t\t\\\n-\t      xreg = plus;\t\t\t\t\t\t\\\n-\t    else\t\t\t\t\t\t\t\\\n-\t      breg = plus;\t\t\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\telse\t\t\t\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    offset = plus;\t\t\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\tif (offset)\t\t\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    if (GET_CODE (offset) == LABEL_REF)\t\t\t\t\\\n-\t      fprintf (FILE, \"L%d\",\t\t\t\t\t\\\n-\t\t\tCODE_LABEL_NUMBER (XEXP (offset, 0)));\t\t\\\n-\t    else\t\t\t\t\t\t\t\\\n-\t      output_addr_const (FILE, offset);\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\telse\t\t\t\t\t\t\t\t\\\n-\t  fprintf (FILE, \"0\");\t\t\t\t\t\t\\\n-\tif (xreg)\t\t\t\t\t\t\t\\\n-\t    fprintf (FILE, \"(%s,%s)\",\t\t\t\t\t\\\n-\t\t    reg_names[REGNO (xreg)], reg_names[REGNO (breg)]); \t\\\n-\telse\t\t\t\t\t\t\t\t\\\n-\t  fprintf (FILE, \"(%s)\", reg_names[REGNO (breg)]);\t\t\\\n-\tbreak;\t\t\t\t\t\t\t\t\\\n-      default:\t\t\t\t\t\t\t\t\\\n-\tmvs_page_lit += 4;\t\t\t\t\t\t\\\n-\tif (SYMBOL_REF_EXTERNAL_P (ADDR)) fprintf (FILE, \"=V(\");\t\\\n-\telse                        fprintf (FILE, \"=A(\");\t\t\\\n-\toutput_addr_const (FILE, ADDR);\t\t\t\t\t\\\n-\tfprintf (FILE, \")\");\t\t\t\t\t\t\\\n-\tbreak;\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-}\n-\n-#define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  if (strlen (NAME) + 1 > mvs_function_name_length)\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      if (mvs_function_name)\t\t\t\t\t\t\\\n-\tfree (mvs_function_name);\t\t\t\t\t\\\n-      mvs_function_name = 0;\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  if (!mvs_function_name)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      mvs_function_name_length = strlen (NAME) * 2 + 1;\t\t\t\\\n-      mvs_function_name = (char *) xmalloc (mvs_function_name_length);\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  if (!strcmp (NAME, \"main\"))\t\t\t\t\t\t\\\n-    strcpy (mvs_function_name, \"gccmain\");\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    strcpy (mvs_function_name, NAME);\t\t\t\t\t\\\n-  fprintf (FILE, \"\\tDS\\t0F\\n\");\t\t\t\t\t\t\\\n-  assemble_name (FILE, mvs_function_name);\t\t\t\t\\\n-  fputs (\"\\tRMODE\\tANY\\n\", FILE);\t\t\t\t\t\\\n-  assemble_name (FILE, mvs_function_name);\t\t\t\t\\\n-  fputs (\"\\tCSECT\\n\", FILE);\t\t\t\t\t\t\\\n-}\n-\n-/* Output assembler code to FILE to increment profiler label # LABELNO\n-   for profiling a function entry.  */\n-\n-#define FUNCTION_PROFILER(FILE, LABELNO) \t\t\t\t\\\n-  fprintf (FILE, \"Error: No profiling available.\\n\")\n-\n-#endif /* TARGET_HLASM */\n-\n-/* ======================================================== */\n-\n-#ifdef TARGET_ELF_ABI \n-\n-/* How to refer to registers in assembler output.  This sequence is\n-   indexed by compiler's hard-register-number (see above).  */\n-\n-#define REGISTER_NAMES\t\t\t\t\t\t\t\\\n-{ \"r0\",  \"r1\",  \"r2\",  \"r3\",  \"r4\",  \"r5\",  \"r6\",  \"r7\",\t\t\\\n-  \"r8\",  \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\",\t\t\\\n-  \"f0\",  \"f2\",  \"f4\",  \"f6\"\t\t\t\t\t\t\\\n-}\n-\n-/* Print operand XV (an rtx) in assembler syntax to file FILE.\n-   CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n-   For `%' followed by punctuation, CODE is the punctuation and XV is null.  */\n-\n-#define PRINT_OPERAND(FILE, XV, CODE)\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  switch (GET_CODE (XV))\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      static char curreg[4];\t\t\t\t\t\t\\\n-      case REG:\t\t\t\t\t\t\t\t\\\n-\tif (CODE == 'N')\t\t\t\t\t\t\\\n-\t    strcpy (curreg, reg_names[REGNO (XV) + 1]);\t\t\t\\\n-\telse\t\t\t\t\t\t\t\t\\\n-\t    strcpy (curreg, reg_names[REGNO (XV)]);\t\t\t\\\n-\tfprintf (FILE, \"%s\", curreg);\t\t\t\t\t\\\n-\tbreak;\t\t\t\t\t\t\t\t\\\n-      case MEM:\t\t\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  rtx addr = XEXP (XV, 0);\t\t\t\t\t\\\n-\t  if (CODE == 'O')\t\t\t\t\t\t\\\n-\t    {\t\t\t\t\t\t\t\t\\\n-\t      if (GET_CODE (addr) == PLUS)\t\t\t\t\\\n-\t\tfprintf (FILE, HOST_WIDE_INT_PRINT_DEC, INTVAL (XEXP (addr, 1))); \\\n-\t      else\t\t\t\t\t\t\t\\\n-\t\tfprintf (FILE, \"0\");\t\t\t\t\t\\\n-\t    }\t\t\t\t\t\t\t\t\\\n-\t  else if (CODE == 'R')\t\t\t\t\t\t\\\n-\t    {\t\t\t\t\t\t\t\t\\\n-\t      if (GET_CODE (addr) == PLUS)\t\t\t\t\\\n-\t\tfprintf (FILE, \"%s\", reg_names[REGNO (XEXP (addr, 0))]);\\\n-\t      else\t\t\t\t\t\t\t\\\n-\t\tfprintf (FILE, \"%s\", reg_names[REGNO (addr)]);\t\t\\\n-\t    }\t\t\t\t\t\t\t\t\\\n-\t  else\t\t\t\t\t\t\t\t\\\n-\t    output_address (XEXP (XV, 0));\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-\tbreak;\t\t\t\t\t\t\t\t\\\n-      case SYMBOL_REF:\t\t\t\t\t\t\t\\\n-      case LABEL_REF:\t\t\t\t\t\t\t\\\n-\tmvs_page_lit += 4;\t\t\t\t\t\t\\\n-        if (SYMBOL_REF_EXTERNAL_P (XV)) fprintf (FILE, \"=V(\");\t\t\\\n-        else                      fprintf (FILE, \"=A(\");                \\\n-        output_addr_const (FILE, XV);                                   \\\n-        fprintf (FILE, \")\");                                            \\\n-\tbreak;\t\t\t\t\t\t\t\t\\\n-      case CONST_INT:\t\t\t\t\t        \t\\\n-\tif (CODE == 'B')\t\t\t\t\t\t\\\n-\t  fprintf (FILE, \"%d\", (int) (INTVAL (XV) & 0xff));\t\t\\\n-\telse if (CODE == 'X')\t\t\t\t\t\t\\\n-\t  fprintf (FILE, \"%02X\", (int) (INTVAL (XV) & 0xff));\t\t\\\n-\telse if (CODE == 'h')\t\t\t\t\t\t\\\n-\t  fprintf (FILE, HOST_WIDE_INT_PRINT_DEC, (INTVAL (XV) << 16) >> 16); \\\n-\telse if (CODE == 'H')\t\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    mvs_page_lit += 2;\t\t\t\t\t\t\\\n-\t    fprintf (FILE, \"=H'\" HOST_WIDE_INT_PRINT_DEC \"'\",\t\t\\\n-\t\t     (INTVAL (XV) << 16) >> 16);\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\telse if (CODE == 'K')\t\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-            /* auto sign-extension of signed 16-bit to signed 32-bit */\t\\\n-\t    mvs_page_lit += 4;\t\t\t\t\t\t\\\n-\t    fprintf (FILE, \"=F'\" HOST_WIDE_INT_PRINT_DEC \"'\",\t\t\\\n-\t\t     (INTVAL (XV) << 16) >> 16);\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\telse if (CODE == 'W')\t\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-            /* hand-built sign-extension of signed 32-bit to 64-bit */\t\\\n-\t    mvs_page_lit += 8;\t\t\t\t\t\t\\\n-\t    if (0 <=  INTVAL (XV)) {\t\t\t\t\t\\\n-\t       fprintf (FILE, \"=XL8'00000000\");\t\t\t\t\\\n-            } else {\t\t\t\t\t\t\t\\\n-\t       fprintf (FILE, \"=XL8'FFFFFFFF\");\t\t\t\t\\\n-            }\t\t\t\t\t\t\t\t\\\n-\t    fprintf (FILE, \"%08X'\", INTVAL (XV));\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\telse\t\t\t\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    mvs_page_lit += 4;\t\t\t\t\t\t\\\n-\t    fprintf (FILE, \"=F'\" HOST_WIDE_INT_PRINT_DEC \"'\", INTVAL (XV)); \\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\tbreak;\t\t\t\t\t\t\t\t\\\n-      case CONST_DOUBLE:\t\t\t\t\t\t\\\n-\tif (GET_MODE (XV) == DImode)\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    if (CODE == 'M')\t\t\t\t\t\t\\\n-\t      {\t\t\t\t\t\t\t\t\\\n-\t\tmvs_page_lit += 4;\t\t\t\t\t\\\n-\t\tfprintf (FILE, \"=XL4'%08X'\", CONST_DOUBLE_LOW (XV));\t\\\n-\t      }\t\t\t\t\t\t\t\t\\\n-\t    else if (CODE == 'L')\t\t\t\t\t\\\n-\t      {\t\t\t\t\t\t\t\t\\\n-\t\tmvs_page_lit += 4;\t\t\t\t\t\\\n-\t\tfprintf (FILE, \"=XL4'%08X'\", CONST_DOUBLE_HIGH (XV));\t\\\n-\t      }\t\t\t\t\t\t\t\t\\\n-\t    else\t\t\t\t\t\t\t\\\n-\t      {\t\t\t\t\t\t\t\t\\\n-\t\tmvs_page_lit += 8;\t\t\t\t\t\\\n-\t\tfprintf (FILE, \"=yyyyXL8'%08X%08X'\", \t\t\t\\\n-\t\t\tCONST_DOUBLE_HIGH (XV), CONST_DOUBLE_LOW (XV));\t\\\n-\t      }\t\t\t\t\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\telse\t\t\t\t\t\t\t\t\\\n-\t  { \t\t\t\t\t\t\t\t\\\n-            char buf[50];\t\t\t\t\t\t\\\n-\t    if (GET_MODE (XV) == SFmode)\t\t\t\t\\\n-\t      {\t\t\t\t\t\t\t\t\\\n-\t\tmvs_page_lit += 4;\t\t\t\t\t\\\n-\t\treal_to_decimal (buf, CONST_DOUBLE_REAL_VALUE (XV),\t\\\n-\t\t\t\t sizeof (buf), 0, 1);\t\t\t\\\n-\t\tfprintf (FILE, \"=E'%s'\", buf);\t\t\t\t\\\n-\t      }\t\t\t\t\t\t\t\t\\\n-\t    else if (GET_MODE (XV) == DFmode)\t\t\t\t\\\n-\t      {\t\t\t\t\t\t\t\t\\\n-\t\tmvs_page_lit += 8;\t\t\t\t\t\\\n-\t\treal_to_decimal (buf, CONST_DOUBLE_REAL_VALUE (XV),\t\\\n-\t\t\t\t sizeof (buf), 0, 1);\t\t\t\\\n-\t\tfprintf (FILE, \"=D'%s'\", buf);\t\t\t\t\\\n-\t      }\t\t\t\t\t\t\t\t\\\n-\t    else /* VOIDmode */\t\t\t\t\t\t\\\n-\t      {\t\t\t\t\t\t\t\t\\\n-\t\tmvs_page_lit += 8;\t\t\t\t\t\\\n-\t\tfprintf (FILE, \"=XL8'%08X%08X'\", \t\t\t\\\n-\t\t\tCONST_DOUBLE_HIGH (XV), CONST_DOUBLE_LOW (XV));\t\\\n-\t      }\t\t\t\t\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\tbreak;\t\t\t\t\t\t\t\t\\\n-      case CONST:\t\t\t\t\t\t\t\\\n-\tif (GET_CODE (XEXP (XV, 0)) == PLUS\t\t\t\t\\\n-\t   && GET_CODE (XEXP (XEXP (XV, 0), 0)) == SYMBOL_REF)\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    mvs_page_lit += 4;\t\t\t\t\t\t\\\n-\t    if (SYMBOL_REF_EXTERNAL_P (XEXP (XEXP (XV, 0), 0)))\t\t\\\n-\t      {\t\t\t\t\t\t\t\t\\\n-\t\tfprintf (FILE, \"=V(\");\t\t\t\t\t\\\n-\t\tASM_OUTPUT_LABELREF (FILE,\t\t\t\t\\\n-\t\t\t\t  XSTR (XEXP (XEXP (XV, 0), 0), 0));\t\\\n-\t\tfprintf (FILE, \")\\n\\tA\\t%s,=F'\" HOST_WIDE_INT_PRINT_DEC \"'\", \\\n-\t\t\t curreg, INTVAL (XEXP (XEXP (XV, 0), 1)));\t\\\n-\t      }\t\t\t\t\t\t\t\t\\\n-\t    else\t\t\t\t\t\t\t\\\n-\t      {\t\t\t\t\t\t\t\t\\\n-\t\tfprintf (FILE, \"=A(\");\t\t\t\t\t\\\n-\t\toutput_addr_const (FILE, XV);\t\t\t\t\\\n-\t\tfprintf (FILE, \")\");\t\t\t\t\t\\\n-\t      }\t\t\t\t\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\telse\t\t\t\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    mvs_page_lit += 4;\t\t\t\t\t\t\\\n-\t    fprintf (FILE, \"=bogus_bad_F'\");\t\t\t\t\\\n-\t    output_addr_const (FILE, XV);\t\t\t\t\\\n-\t    fprintf (FILE, \"'\");\t\t\t\t\t\\\n-/* XXX hack alert this gets gen'd in -fPIC code in relation to a tablejump */  \\\n-/* but its somehow fundamentally broken, I can't make any sense out of it */  \\\n-debug_rtx (XV); \\\n-abort(); \\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\tbreak;\t\t\t\t\t\t\t\t\\\n-      default:\t\t\t\t\t\t\t\t\\\n-\tabort();\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-}\n-\n-#define PRINT_OPERAND_ADDRESS(FILE, ADDR)\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  rtx breg, xreg, offset, plus;\t\t\t\t\t\t\\\n-  \t\t\t\t\t\t\t\t\t\\\n-  switch (GET_CODE (ADDR))\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      case REG:\t\t\t\t\t\t\t\t\\\n-\tfprintf (FILE, \"0(%s)\", reg_names[REGNO (ADDR)]);\t\t\\\n-\tbreak;\t\t\t\t\t\t\t\t\\\n-      case PLUS:\t\t\t\t\t\t\t\\\n-\tbreg = 0;\t\t\t\t\t\t\t\\\n-\txreg = 0;\t\t\t\t\t\t\t\\\n-\toffset = 0;\t\t\t\t\t\t\t\\\n-\tif (GET_CODE (XEXP (ADDR, 0)) == PLUS)\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    if (GET_CODE (XEXP (ADDR, 1)) == REG)\t\t\t\\\n-\t      breg = XEXP (ADDR, 1);\t\t\t\t\t\\\n-\t    else\t\t\t\t\t\t\t\\\n-\t      offset = XEXP (ADDR, 1);\t\t\t\t\t\\\n-\t    plus = XEXP (ADDR, 0);\t\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\telse\t\t\t\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    if (GET_CODE (XEXP (ADDR, 0)) == REG)\t\t\t\\\n-\t      breg = XEXP (ADDR, 0);\t\t\t\t\t\\\n-\t    else\t\t\t\t\t\t\t\\\n-\t      offset = XEXP (ADDR, 0);\t\t\t\t\t\\\n-\t    plus = XEXP (ADDR, 1);\t\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\tif (GET_CODE (plus) == PLUS)\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    if (GET_CODE (XEXP (plus, 0)) == REG)\t\t\t\\\n-\t      {\t\t\t\t\t\t\t\t\\\n-\t\tif (breg)\t\t\t\t\t\t\\\n-\t\t  xreg = XEXP (plus, 0);\t\t\t\t\\\n-\t\telse\t\t\t\t\t\t\t\\\n-\t\t  breg = XEXP (plus, 0);\t\t\t\t\\\n-\t      }\t\t\t\t\t\t\t\t\\\n-\t    else\t\t\t\t\t\t\t\\\n-\t      {\t\t\t\t\t\t\t\t\\\n-\t\toffset = XEXP (plus, 0);\t\t\t\t\\\n-\t      }\t\t\t\t\t\t\t\t\\\n-\t    if (GET_CODE (XEXP (plus, 1)) == REG)\t\t\t\\\n-\t      {\t\t\t\t\t\t\t\t\\\n-\t\tif (breg)\t\t\t\t\t\t\\\n-\t\t  xreg = XEXP (plus, 1);\t\t\t\t\\\n-\t\telse\t\t\t\t\t\t\t\\\n-\t\t  breg = XEXP (plus, 1);\t\t\t\t\\\n-\t      }\t\t\t\t\t\t\t\t\\\n-\t    else\t\t\t\t\t\t\t\\\n-\t      {\t\t\t\t\t\t\t\t\\\n-\t\toffset = XEXP (plus, 1);\t\t\t\t\\\n-\t      }\t\t\t\t\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\telse if (GET_CODE (plus) == REG)\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    if (breg)\t\t\t\t\t\t\t\\\n-\t      xreg = plus;\t\t\t\t\t\t\\\n-\t    else\t\t\t\t\t\t\t\\\n-\t      breg = plus;\t\t\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\telse\t\t\t\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    offset = plus;\t\t\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\tif (offset)\t\t\t\t\t\t\t\\\n-\t  {\t\t\t\t\t\t\t\t\\\n-\t    if (GET_CODE (offset) == LABEL_REF)\t\t\t\t\\\n-\t      fprintf (FILE, \"L%d\",\t\t\t\t\t\\\n-\t\t\tCODE_LABEL_NUMBER (XEXP (offset, 0)));\t\t\\\n-\t    else\t\t\t\t\t\t\t\\\n-\t      output_addr_const (FILE, offset);\t\t\t\t\\\n-\t  }\t\t\t\t\t\t\t\t\\\n-\telse\t\t\t\t\t\t\t\t\\\n-\t  fprintf (FILE, \"0\");\t\t\t\t\t\t\\\n-\tif (xreg)\t\t\t\t\t\t\t\\\n-\t    fprintf (FILE, \"(%s,%s)\",\t\t\t\t\t\\\n-\t\t    reg_names[REGNO (xreg)], reg_names[REGNO (breg)]); \t\\\n-\telse\t\t\t\t\t\t\t\t\\\n-\t  fprintf (FILE, \"(%s)\", reg_names[REGNO (breg)]);\t\t\\\n-\tbreak;\t\t\t\t\t\t\t\t\\\n-      default:\t\t\t\t\t\t\t\t\\\n-\tmvs_page_lit += 4;\t\t\t\t\t\t\\\n-\tif (SYMBOL_REF_EXTERNAL_P (ADDR)) fprintf (FILE, \"=V(\");\t\\\n-\telse                        fprintf (FILE, \"=A(\");\t\t\\\n-\toutput_addr_const (FILE, ADDR);\t\t\t\t\t\\\n-\tfprintf (FILE, \")\");\t\t\t\t\t\t\\\n-\tbreak;\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-}\n-\n-/* Output assembler code to FILE to increment profiler label # LABELNO\n-   for profiling a function entry.  */\n-/* Make it a no-op for now, so we can at least compile glibc */\n-#define FUNCTION_PROFILER(FILE, LABELNO)  {\t\t\t\t\\\n-  mvs_check_page (FILE, 24, 4);\t\t\t\t\t\t\\\n-     fprintf (FILE, \"\\tSTM\\tr1,r2,%d(sp)\\n\", STACK_POINTER_OFFSET-8);\t\\\n-     fprintf (FILE, \"\\tLA\\tr1,1(0,0)\\n\"); \t\t\t\t\\\n-     fprintf (FILE, \"\\tL\\tr2,=A(.LP%d)\\n\", LABELNO);\t\t\t\\\n-     fprintf (FILE, \"\\tA\\tr1,0(r2)\\n\");\t\t\t \t\t\\\n-     fprintf (FILE, \"\\tST\\tr1,0(r2)\\n\");\t\t \t\t\\\n-     fprintf (FILE, \"\\tLM\\tr1,r2,%d(sp)\\n\", STACK_POINTER_OFFSET-8);\t\\\n-}\n-\n-/* Don't bother to output .extern pseudo-ops.  They are not needed by\n-   ELF assemblers.  */\n-\n-#undef ASM_OUTPUT_EXTERNAL\n-\n-#define ASM_DOUBLE \"\\t.double\"     \n-\n-/* #define ASM_OUTPUT_LABELREF(FILE, NAME) */\t/* use gas -- defaults.h */\n-\n-/* let config/svr4.h define this ...\n- *  #define ASM_OUTPUT_CASE_LABEL(FILE, PREFIX, NUM, TABLE)\n- *    fprintf (FILE, \"%s%d:\\n\", PREFIX, NUM)\n- */\n-\n-/* This is how to output an element of a case-vector that is absolute.  */\n-#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \t\t\t\t\\\n-  mvs_check_page (FILE, 4, 0);\t\t\t\t\t\t\\\n-  fprintf (FILE, \"\\t.long\\t.L%d\\n\", VALUE)\n-\n-/* This is how to output an element of a case-vector that is relative.  */\n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \t\t\\\n-  mvs_check_page (FILE, 4, 0);\t\t\t\t\t\t\\\n-  fprintf (FILE, \"\\t.long\\t.L%d-.L%d\\n\", VALUE, REL)\n-\n-/* Right now, PUSH & POP are used only when profiling is enabled, \n-   and then, only to push the static chain reg and the function struct \n-   value reg, and only if those are used by the function being profiled.\n-   We don't need this for profiling, so punt.  */\n-#define ASM_OUTPUT_REG_PUSH(FILE, REGNO) \n-#define ASM_OUTPUT_REG_POP(FILE, REGNO)\t\n-\n-\n-/* Indicate that jump tables go in the text section.  This is\n-   necessary when compiling PIC code.  */\n-#define JUMP_TABLES_IN_TEXT_SECTION 1\n-\n-/* Define macro used to output shift-double opcodes when the shift\n-   count is in %cl.  Some assemblers require %cl as an argument;\n-   some don't.\n-\n-   GAS requires the %cl argument, so override i386/unix.h.  */\n-\n-#undef SHIFT_DOUBLE_OMITS_COUNT\n-#define SHIFT_DOUBLE_OMITS_COUNT 0\n-\n-/* Implicit library calls should use memcpy, not bcopy, etc.  */\n-#define TARGET_MEM_FUNCTIONS\n- \n-/* Output before read-only data.  */\n-#define TEXT_SECTION_ASM_OP \"\\t.text\"\n-\n-/* Output before writable (initialized) data.  */\n-#define DATA_SECTION_ASM_OP \"\\t.data\"\n-\n-/* Output before writable (uninitialized) data.  */\n-#define BSS_SECTION_ASM_OP \"\\t.bss\"\n-\n-/* In the past there was confusion as to what the argument to .align was\n-   in GAS.  For the last several years the rule has been this: for a.out\n-   file formats that argument is LOG, and for all other file formats the\n-   argument is 1<<LOG.\n-\n-   However, GAS now has .p2align and .balign pseudo-ops so to remove any\n-   doubt or guess work, and since this file is used for both a.out and other\n-   file formats, we use one of them.  */\n-\n-#define ASM_OUTPUT_ALIGN(FILE,LOG) \\\n-  if ((LOG)!=0) fprintf ((FILE), \"\\t.balign %d\\n\", 1<<(LOG))\n- \n-/* Globalizing directive for a label.  */\n-#define GLOBAL_ASM_OP \".globl \"\n-\n-/* This says how to output an assembler line\n-   to define a global common symbol.  */\n-\n-#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)  \\\n-( fputs (\".comm \", (FILE)),                     \\\n-  assemble_name ((FILE), (NAME)),               \\\n-  fprintf ((FILE), \",\"HOST_WIDE_INT_PRINT_UNSIGNED\"\\n\", (ROUNDED)))\n-\n-/* This says how to output an assembler line\n-   to define a local common symbol.  */\n-\n-#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)  \\\n-( fputs (\".lcomm \", (FILE)),                    \\\n-  assemble_name ((FILE), (NAME)),               \\\n-  fprintf ((FILE), \",\"HOST_WIDE_INT_PRINT_UNSIGNED\"\\n\", (ROUNDED)))\n-\n-#endif /* TARGET_ELF_ABI */\n-#endif /* ! GCC_I370_H */"}, {"sha": "342b6e8727e38d4f60821d8dcbe51ce5e65a965c", "filename": "gcc/config/i370/i370.md", "status": "removed", "additions": 0, "deletions": 4739, "changes": 4739, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fi370%2Fi370.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fi370%2Fi370.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fi370.md?ref=c3bf16ff7dec47581f450b1a486cfdf9d566927e"}, {"sha": "f402fbde9f3d50ddbfac43c651fb29340aa656c8", "filename": "gcc/config/i370/linux.h", "status": "removed", "additions": 0, "deletions": 113, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fi370%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fi370%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Flinux.h?ref=c3bf16ff7dec47581f450b1a486cfdf9d566927e", "patch": "@@ -1,113 +0,0 @@\n-/* Definitions of target machine for GNU compiler.  System/370 version.\n-   Copyright (C) 1989, 1993, 1995, 1996, 1997, 2003\n-   Free Software Foundation, Inc.\n-   Contributed by Jan Stein (jan@cd.chalmers.se).\n-   Modified for Linux/390 by Linas Vepstas (linas@linas.org)\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-\n-#define TARGET_VERSION fprintf (stderr, \" (i370 GNU/Linux with ELF)\");\n-\n-/* Specify that we're generating code for a Linux port to 370 */\n-\n-#define TARGET_ELF_ABI\n-\n-/* Target OS preprocessor built-ins.  */\n-#define TARGET_OS_CPP_BUILTINS() LINUX_TARGET_OS_CPP_BUILTINS()\n-\n-/* Options for this target machine.  */\n-\n-#define LIBGCC_SPEC \"libgcc.a%s\"\n-\n-#ifdef SOME_FUTURE_DAY\n- \n-#define CPP_SPEC \"%{posix: -D_POSIX_SOURCE} %(cpp_sysv) %(cpp_endian_big) \\\n-%{mcall-linux: %(cpp_os_linux) } \\\n-%{!mcall-linux: %(cpp_os_default) }\"\n-\n-#define LIB_SPEC \"\\\n-%{mcall-linux: %(lib_linux) } \\\n-%{!mcall-linux:%(lib_default) }\"\n-\n-#define STARTFILE_SPEC \"\\\n-%{mcall-linux: %(startfile_linux) } \\\n-%{!mcall-linux: %(startfile_default) }\"\n-\n-#define ENDFILE_SPEC \"\\\n-%{mcall-linux: %(endfile_linux) } \\\n-%{!mcall-linux: %(endfile_default) }\"\n-\n-/* GNU/Linux support.  */\n-#ifndef LIB_LINUX_SPEC\n-#define LIB_LINUX_SPEC \"%{mnewlib: --start-group -llinux -lc --end-group } %{!mnewlib: -lc }\"\n-#endif\n-\n-#ifndef STARTFILE_LINUX_SPEC\n-#define STARTFILE_LINUX_SPEC \"\\\n-%{!shared: %{pg:gcrt1.o%s} %{!pg:%{p:gcrt1.o%s} %{!p:crt1.o%s}}} \\\n-%{mnewlib: ecrti.o%s} \\\n-%{!mnewlib: crti.o%s %{!shared:crtbegin.o%s} %{shared:crtbeginS.o%s}}\"\n-#endif\n-\n-#ifndef ENDFILE_LINUX_SPEC\n-#define ENDFILE_LINUX_SPEC \"\\\n-%{mnewlib: ecrtn.o%s} \\\n-%{!mnewlib: %{!shared:crtend.o%s} %{shared:crtendS.o%s} crtn.o%s}\"\n-#endif\n-\n-#ifndef LINK_START_LINUX_SPEC\n-#define LINK_START_LINUX_SPEC \"-Ttext 0x10000\"\n-#endif\n-\n-#ifndef LINK_OS_LINUX_SPEC\n-#define LINK_OS_LINUX_SPEC \"\"\n-#endif\n-\n-#ifndef CPP_OS_LINUX_SPEC\n-#define CPP_OS_LINUX_SPEC \"-D__unix__ -D__gnu_linux__ -D__linux__ \\\n-%{!ansi: -Dunix -Dlinux } \\\n--Asystem=unix -Asystem=linux\"\n-#endif\n-\n-#ifndef CPP_OS_LINUX_SPEC\n-#define CPP_OS_LINUX_SPEC \"\"\n-#endif\n-\n-\n-/* Define any extra SPECS that the compiler needs to generate.  */\n-#undef  SUBTARGET_EXTRA_SPECS\n-#define SUBTARGET_EXTRA_SPECS                                           \\\n-  { \"lib_linux\",                LIB_LINUX_SPEC },                       \\\n-  { \"lib_default\",              LIB_DEFAULT_SPEC },                     \\\n-  { \"startfile_linux\",          STARTFILE_LINUX_SPEC },                 \\\n-  { \"startfile_default\",        STARTFILE_DEFAULT_SPEC },               \\\n-  { \"endfile_linux\",            ENDFILE_LINUX_SPEC },                   \\\n-  { \"endfile_default\",          ENDFILE_DEFAULT_SPEC },                 \\\n-  { \"link_shlib\",               LINK_SHLIB_SPEC },                      \\\n-  { \"link_target\",              LINK_TARGET_SPEC },                     \\\n-  { \"link_start\",               LINK_START_SPEC },                      \\\n-  { \"link_start_linux\",         LINK_START_LINUX_SPEC },                \\\n-  { \"link_os\",                  LINK_OS_SPEC },                         \\\n-  { \"link_os_linux\",            LINK_OS_LINUX_SPEC },                   \\\n-  { \"link_os_default\",          LINK_OS_DEFAULT_SPEC },                 \\\n-  { \"cpp_endian_big\",           CPP_ENDIAN_BIG_SPEC },                  \\\n-  { \"cpp_os_linux\",             CPP_OS_LINUX_SPEC },                    \\\n-  { \"cpp_os_default\",           CPP_OS_DEFAULT_SPEC },\n-\n-#endif /* SOME_FUTURE_DAY */"}, {"sha": "dfb4cba188ae9a5fa1a550bf003237ca698079e5", "filename": "gcc/config/i370/mvs.h", "status": "removed", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fi370%2Fmvs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fi370%2Fmvs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fmvs.h?ref=c3bf16ff7dec47581f450b1a486cfdf9d566927e", "patch": "@@ -1,49 +0,0 @@\n-/* Definitions of target machine for GNU compiler.  System/370 version.\n-   Copyright (C) 1989, 1993, 1995, 1996, 1997, 2003\n-   Free Software Foundation, Inc.\n-   Contributed by Jan Stein (jan@cd.chalmers.se).\n-   Modified for OS/390 LanguageEnvironment C by Dave Pitts (dpitts@cozx.com)\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#define TARGET_VERSION printf (\" (370/MVS)\");\n-\n-/* Specify that we're generating code for the Language Environment */\n-\n-#define LE370 1\n-#define TARGET_EBCDIC 1\n-#define TARGET_HLASM 1\n-\n-/* Options for the preprocessor for this target machine.  */\n-\n-#define CPP_SPEC \"-trigraphs\"\n-\n-/* Target OS preprocessor built-ins.  */\n-#define TARGET_OS_CPP_BUILTINS()\t\t\\\n-    do {\t\t\t\t\t\\\n-\tbuiltin_define_std (\"MVS\");\t\t\\\n-\tbuiltin_define_std (\"mvs\");\t\t\\\n-\tMAYBE_LE370_MACROS();\t\t\t\\\n-\tbuiltin_assert (\"system=mvs\");\t\t\\\n-    } while (0)\n-\n-#if defined(LE370)\n-# define MAYBE_LE370_MACROS() do {builtin_define_std (\"LE370\");} while (0)\n-#else\n-# define MAYBE_LE370_MACROS()\n-#endif"}, {"sha": "088c043530eeacbb0dd38e2f9315a23f71a1fbb0", "filename": "gcc/config/i370/oe.h", "status": "removed", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fi370%2Foe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fi370%2Foe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Foe.h?ref=c3bf16ff7dec47581f450b1a486cfdf9d566927e", "patch": "@@ -1,53 +0,0 @@\n-/* Definitions of target machine for GNU compiler.  System/370 version.\n-   Copyright (C) 1989, 1993, 1995, 1996, 1997, 2003\n-   Free Software Foundation, Inc.\n-   Contributed by Jan Stein (jan@cd.chalmers.se).\n-   Modified for OS/390 OpenEdition by Dave Pitts (dpitts@cozx.com)\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#define TARGET_VERSION printf (\" (370/OpenEdition)\");\n-\n-/* Specify that we're generating code for the Language Environment */\n-\n-#define LE370 1\n-#define LONGEXTERNAL 1\n-#define TARGET_EBCDIC 1\n-#define TARGET_HLASM 1\n-\n-/* Options for the preprocessor for this target machine.  */\n-\n-#define CPP_SPEC \"-trigraphs\"\n-\n-/* Options for this target machine.  */\n-\n-#define LIB_SPEC \"\"\n-#define LIBGCC_SPEC \"\"\n-#define STARTFILE_SPEC \"/usr/local/lib/gccmain.o\"\n-\n-/* Target OS preprocessor built-ins.  */\n-#define TARGET_OS_CPP_BUILTINS()\t\t\\\n-    do {\t\t\t\t\t\\\n-\tbuiltin_define_std (\"unix\");\t\t\\\n-\tbuiltin_define_std (\"UNIX\");\t\t\\\n-\tbuiltin_define_std (\"openedition\");\t\\\n-\tbuiltin_define (\"__i370__\");\t\t\\\n-\tbuiltin_assert (\"system=openedition\");\t\\\n-\tbuiltin_assert (\"system=unix\");\t\t\\\n-    } while (0)\n-"}, {"sha": "fccd1632fde40e63f20385f2e5eb2ab18aec7a02", "filename": "gcc/config/i370/t-i370", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fi370%2Ft-i370", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fi370%2Ft-i370", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Ft-i370?ref=c3bf16ff7dec47581f450b1a486cfdf9d566927e", "patch": "@@ -1,3 +0,0 @@\n-i370-c.o: $(srcdir)/config/i370/i370-c.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n-  $(TM_H) $(TREE_H) toplev.h $(CPPLIB_H) c-pragma.h $(TM_P_H)\n-\t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $(srcdir)/config/i370/i370-c.c"}, {"sha": "663ed8dac09c29c892ccce50a518bc197cf116ea", "filename": "gcc/config/i386/freebsd-aout.h", "status": "removed", "additions": 0, "deletions": 230, "changes": 230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fi386%2Ffreebsd-aout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fi386%2Ffreebsd-aout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Ffreebsd-aout.h?ref=c3bf16ff7dec47581f450b1a486cfdf9d566927e", "patch": "@@ -1,230 +0,0 @@\n-/* Definitions of target machine for GNU compiler for Intel 80386\n-   running FreeBSD.\n-   Copyright (C) 1988, 1992, 1994, 1996, 1997, 1999, 2000, 2002, 2003\n-   Free Software Foundation, Inc.\n-   Contributed by Poul-Henning Kamp <phk@login.dkuug.dk>\n-   Continued development by David O'Brien <obrien@NUXI.org>\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-/* Don't assume anything about the header files.  */\n-#define NO_IMPLICIT_EXTERN_C\n-\n-/* This goes away when the math-emulator is fixed */\n-#undef TARGET_SUBTARGET_DEFAULT\n-#define TARGET_SUBTARGET_DEFAULT \\\n-  (MASK_80387 | MASK_IEEE_FP | MASK_FLOAT_RETURNS | MASK_NO_FANCY_MATH_387)\n-\n-/* The macro defined in i386.h doesn't work with the old gas of\n-   FreeBSD 2.x.  The definition in sco.h and sol2.h appears to work,\n-   but it turns out that, even though the assembler doesn't complain,\n-   we get incorrect results.  Fortunately, the definition in\n-   defaults.h works.  */\n-#undef ASM_PREFERRED_EH_DATA_FORMAT\n-\n-#define TARGET_OS_CPP_BUILTINS()\t\t\\\n-  do\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\\\n-\tbuiltin_define_std (\"unix\");\t\t\\\n-\tbuiltin_define (\"__FreeBSD__\");\t\t\\\n-\tbuiltin_assert (\"system=unix\");\t\t\\\n-\tbuiltin_assert (\"system=bsd\");\t\t\\\n-\tbuiltin_assert (\"system=FreeBSD\");\t\\\n-    }\t\t\t\t\t\t\\\n-  while (0)\n-\n-/* Like the default, except no -lg.  */\n-#define LIB_SPEC \"%{!shared:%{!pg:-lc}%{pg:-lc_p}}\"\n-\n-#undef SIZE_TYPE\n-#define SIZE_TYPE \"unsigned int\"\n-\n-#undef PTRDIFF_TYPE\n-#define PTRDIFF_TYPE \"int\"\n-\n-#undef WCHAR_TYPE\n-#define WCHAR_TYPE \"int\"\n-\n-#undef WCHAR_TYPE_SIZE\n-#define WCHAR_TYPE_SIZE BITS_PER_WORD\n-\n-/* Override the default comment-starter of \"/\".  */\n-\n-#undef ASM_COMMENT_START\n-#define ASM_COMMENT_START \"#\"\n-\n-#undef ASM_APP_ON\n-#define ASM_APP_ON \"#APP\\n\"\n-\n-#undef ASM_APP_OFF\n-#define ASM_APP_OFF \"#NO_APP\\n\"\n-\n-/* FreeBSD using a.out does not support DWARF2 unwinding mechanisms.  */\n-#define DWARF2_UNWIND_INFO 0\n-\f\n-/* Don't default to pcc-struct-return, because in FreeBSD we prefer the\n-   superior nature of the older gcc way.  */\n-#define DEFAULT_PCC_STRUCT_RETURN 0\n-\n-/* Ensure we the configuration knows our system correctly so we can link with\n-   libraries compiled with the native cc.  */\n-#undef NO_DOLLAR_IN_LABEL\n-\f\n-/* i386 freebsd still uses old binutils that don't insert nops by default\n-   when the .align directive demands to insert extra space in the text\n-   segment.  */\n-#undef ASM_OUTPUT_ALIGN\n-#define ASM_OUTPUT_ALIGN(FILE,LOG) \\\n-  if ((LOG)!=0) fprintf ((FILE), \"\\t.align %d,0x90\\n\", (LOG))\n-\f\n-/* Profiling routines, partially copied from i386/osfrose.h.  */\n-\n-/* Tell final.c that we don't need a label passed to mcount.  */\n-#define NO_PROFILE_COUNTERS 1\n-\n-#undef MCOUNT_NAME\n-#define MCOUNT_NAME \"mcount\"\n-#undef PROFILE_COUNT_REGISTER\n-#define PROFILE_COUNT_REGISTER \"eax\"\n-\n-/*\n- * Some imports from svr4.h in support of shared libraries.\n- * Currently, we need the DECLARE_OBJECT_SIZE stuff.\n- */\n-\n-/* Define the strings used for the special svr4 .type and .size directives.\n-   These strings generally do not vary from one system running svr4 to\n-   another, but if a given system (e.g. m88k running svr) needs to use\n-   different pseudo-op names for these, they may be overridden in the\n-   file which includes this one.  */\n-\n-#define TYPE_ASM_OP\t\"\\t.type\\t\"\n-#define SIZE_ASM_OP\t\"\\t.size\\t\"\n-#define SET_ASM_OP\t\"\\t.set\\t\"\n-\n-/* The following macro defines the format used to output the second\n-   operand of the .type assembler directive.  Different svr4 assemblers\n-   expect various different forms for this operand.  The one given here\n-   is just a default.  You may need to override it in your machine-\n-   specific tm.h file (depending upon the particulars of your assembler).  */\n-\n-#define TYPE_OPERAND_FMT\t\"@%s\"\n-\n-#define HANDLE_SYSV_PRAGMA\t1\n-\n-#define ASM_WEAKEN_LABEL(FILE,NAME) \\\n-\tdo { fputs (\"\\t.weak\\t\", FILE); assemble_name (FILE, NAME); \\\n-\tfputc ('\\n', FILE); } while (0)\n-\n-/* Write the extra assembler code needed to declare a function's result.\n-   Most svr4 assemblers don't require any special declaration of the\n-   result value, but there are exceptions.  */\n-\n-#ifndef ASM_DECLARE_RESULT\n-#define ASM_DECLARE_RESULT(FILE, RESULT)\n-#endif\n-\n-/* These macros generate the special .type and .size directives which\n-   are used to set the corresponding fields of the linker symbol table\n-   entries in an ELF object file under SVR4.  These macros also output\n-   the starting labels for the relevant functions/objects.  */\n-\n-/* Write the extra assembler code needed to declare a function properly.\n-   Some svr4 assemblers need to also have something extra said about the\n-   function's return value.  We allow for that here.  */\n-\n-#define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)\t\t\\\n-  do\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      ASM_OUTPUT_TYPE_DIRECTIVE (FILE, NAME, \"function\");\t\\\n-      ASM_DECLARE_RESULT (FILE, DECL_RESULT (DECL));\t\t\\\n-      ASM_OUTPUT_LABEL (FILE, NAME);\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  while (0)\n-\n-/* Write the extra assembler code needed to declare an object properly.  */\n-\n-#define ASM_DECLARE_OBJECT_NAME(FILE, NAME, DECL)\t\t\\\n-  do\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      HOST_WIDE_INT size;\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-      ASM_OUTPUT_TYPE_DIRECTIVE (FILE, NAME, \"object\");\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-      size_directive_output = 0;\t\t\t\t\\\n-      if (!flag_inhibit_size_directive\t\t\t\t\\\n-\t  && (DECL) && DECL_SIZE (DECL))\t\t\t\\\n-\t{\t\t\t\t\t\t\t\\\n-\t  size_directive_output = 1;\t\t\t\t\\\n-\t  size = int_size_in_bytes (TREE_TYPE (DECL));\t\t\\\n-\t  ASM_OUTPUT_SIZE_DIRECTIVE (FILE, NAME, size);\t\t\\\n-\t}\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-      ASM_OUTPUT_LABEL (FILE, NAME);\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  while (0)\n-\n-/* Output the size directive for a decl in rest_of_decl_compilation\n-   in the case where we did not do so before the initializer.\n-   Once we find the error_mark_node, we know that the value of\n-   size_directive_output was set\n-   by ASM_DECLARE_OBJECT_NAME when it was run for the same decl.  */\n-\n-#undef ASM_FINISH_DECLARE_OBJECT\n-#define ASM_FINISH_DECLARE_OBJECT(FILE, DECL, TOP_LEVEL, AT_END)        \\\n-do {                                                                    \\\n-     const char *name = XSTR (XEXP (DECL_RTL (DECL), 0), 0);            \\\n-     HOST_WIDE_INT size;\t\t\t\t\t\t\\\n-     if (!flag_inhibit_size_directive && DECL_SIZE (DECL)\t        \\\n-         && ! AT_END && TOP_LEVEL                                       \\\n-         && DECL_INITIAL (DECL) == error_mark_node                      \\\n-         && !size_directive_output)                                     \\\n-       {                                                                \\\n-\t size_directive_output = 1;\t\t\t\t\t\\\n-\t size = int_size_in_bytes (TREE_TYPE (DECL));\t\t\t\\\n-\t ASM_OUTPUT_SIZE_DIRECTIVE (FILE, name, size);\t\t\t\\\n-       }\t\t\t\t\t\t\t\t\\\n-   } while (0)\n-\n-/* This is how to declare the size of a function.  */\n-\n-#define ASM_DECLARE_FUNCTION_SIZE(FILE, FNAME, DECL)\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    if (!flag_inhibit_size_directive)\t\t\t\t\t\\\n-      ASM_OUTPUT_MEASURED_SIZE (FILE, FNAME);\t\t\t\t\\\n-  } while (0)\n-\n-#define AS_NEEDS_DASH_FOR_PIPED_INPUT\n-#define ASM_SPEC   \"%{fpic|fpie|fPIC|fPIE:-k}\"\n-#define LINK_SPEC \\\n-  \"%{p:%e`-p' not supported; use `-pg' and gprof(1)} \\\n-   %{shared:-Bshareable} \\\n-   %{!shared:%{!nostdlib:%{!r:%{!e*:-e start}}} -dc -dp %{static:-Bstatic} \\\n-   %{pg:-Bstatic} %{Z}} \\\n-   %{assert*} %{R*}\"\n-\n-#define STARTFILE_SPEC  \\\n-  \"%{shared:c++rt0.o%s} \\\n-   %{!shared:%{pg:gcrt0.o%s}%{!pg:%{static:scrt0.o%s}%{!static:crt0.o%s}}}\"\n-\n-/* Define this so we can compile MS code for use with WINE.  */\n-#define HANDLE_PRAGMA_PACK_PUSH_POP\n-\n-/* FreeBSD 2.2.7's assembler does not support .quad properly.  Do not\n-   use it.  */\n-#undef ASM_QUAD"}, {"sha": "d7be93c73128c36898804cf43fb987a5e12ecc66", "filename": "gcc/config/i386/linux-aout.h", "status": "removed", "additions": 0, "deletions": 73, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fi386%2Flinux-aout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fi386%2Flinux-aout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Flinux-aout.h?ref=c3bf16ff7dec47581f450b1a486cfdf9d566927e", "patch": "@@ -1,73 +0,0 @@\n-/* Definitions for Intel 386 running Linux-based GNU systems using a.out.\n-   Copyright (C) 1992, 1994, 1995, 1997, 1998, 2002\n-   Free Software Foundation, Inc.\n-   Contributed by H.J. Lu (hjl@nynexst.com)\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#undef ASM_COMMENT_START\n-#define ASM_COMMENT_START \"#\"\n-\n-#define TARGET_OS_CPP_BUILTINS()\t\t\\\n-  do\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\\\n-\tLINUX_TARGET_OS_CPP_BUILTINS();\t\t\\\n-\tif (flag_pic)\t\t\t\t\\\n-\t  {\t\t\t\t\t\\\n-\t    builtin_define (\"__PIC__\");\t\t\\\n-\t    builtin_define (\"__pic__\");\t\t\\\n-\t  }\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\\\n-  while (0)\n-\n-#undef CPP_SPEC\n-#define CPP_SPEC \"%{posix:-D_POSIX_SOURCE}\"\n-\n-#undef SIZE_TYPE\n-#define SIZE_TYPE \"unsigned int\"\n-\n-#undef PTRDIFF_TYPE\n-#define PTRDIFF_TYPE \"int\"\n-\n-#undef WCHAR_TYPE\n-#define WCHAR_TYPE \"long int\"\n-\n-#undef WCHAR_TYPE_SIZE\n-#define WCHAR_TYPE_SIZE BITS_PER_WORD\n-\n-/* Don't default to pcc-struct-return, because gcc is the only compiler,\n-   and we want to retain compatibility with older gcc versions.  */\n-#define DEFAULT_PCC_STRUCT_RETURN 0\n-\n-#undef LIB_SPEC\n-\n-#if 1\n-/* We no longer link with libc_p.a or libg.a by default. If you\n-   want to profile or debug the GNU/Linux C library, please add\n-   -lc_p or -ggdb to LDFLAGS at the link time, respectively.  */\n-#define LIB_SPEC \\\n-\"%{mieee-fp:-lieee} %{p:-lgmon} %{pg:-lgmon} %{!ggdb:-lc} %{ggdb:-lg}\"\n-#else    \n-#define LIB_SPEC \\\n-\"%{mieee-fp:-lieee} %{p:-lgmon -lc_p} %{pg:-lgmon -lc_p} \\\n- %{!p:%{!pg:%{!g*:-lc} %{g*:-lg -static}}}\" \n-#endif\n-\n-\f\n-#undef LINK_SPEC\n-#define LINK_SPEC\t\"-m i386linux\""}, {"sha": "3b748cfe1d9f72b88288c4fbc0c185011bc8c29d", "filename": "gcc/config/i386/moss.h", "status": "removed", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fi386%2Fmoss.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fi386%2Fmoss.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fmoss.h?ref=c3bf16ff7dec47581f450b1a486cfdf9d566927e", "patch": "@@ -1,43 +0,0 @@\n-/* Definitions for Intel 386 running MOSS\n-   Copyright (C) 1996, 2001 Free Software Foundation, Inc.\n-   Contributed by Bryan Ford <baford@cs.utah.edu>\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#undef TARGET_OS_CPP_BUILTINS /* config.gcc includes i386/linux.h.  */\n-#define TARGET_OS_CPP_BUILTINS()\t\t\\\n-  do\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\\\n-\tbuiltin_define_std (\"moss\");\t\t\\\n-\tbuiltin_assert (\"system=posix\");\t\\\n-\tif (flag_pic)\t\t\t\t\\\n-\t  {\t\t\t\t\t\\\n-\t    builtin_define (\"__PIC__\");\t\t\\\n-\t    builtin_define (\"__pic__\");\t\t\\\n-\t  }\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\\\n-  while (0)\n-\n-#undef STARTFILE_SPEC\n-#define STARTFILE_SPEC  \"crt0.o%s\"\n-\n-#undef ENDFILE_SPEC\n-#define ENDFILE_SPEC  \"crtn.o%s\"\n-\n-#undef\tLINK_SPEC\n-"}, {"sha": "28adf7256c57564aaedbd2bec639393767908b34", "filename": "gcc/config/i386/netware.h", "status": "removed", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fi386%2Fnetware.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fi386%2Fnetware.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fnetware.h?ref=c3bf16ff7dec47581f450b1a486cfdf9d566927e", "patch": "@@ -1,40 +0,0 @@\n-/* Core target definitions for GCC for Intel 80386 running Netware 4.\n-   and using stabs-in-elf for the debugging format.\n-   Copyright (C) 1993, 1994 Free Software Foundation, Inc.\n-\n-   Written by David V. Henkel-Wallace (gumby@cygnus.com)\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#undef TARGET_VERSION\n-#define TARGET_VERSION fprintf (stderr, \" (i386 Netware 4)\");\n-\n-#define TARGET_OS_CPP_BUILTINS()\t\t\\\n-  do\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\\\n-\tbuiltin_define_std (\"APX386\");\t\t\\\n-\tbuiltin_define (\"__netware__\");\t\t\\\n-\tbuiltin_assert (\"system=netware\");\t\\\n-    }\t\t\t\t\t\t\\\n-  while (0)\n-\n-#undef WCHAR_TYPE\n-#define WCHAR_TYPE \"short unsigned int\"\n-\n-#undef WCHAR_TYPE_SIZE\n-#define WCHAR_TYPE_SIZE 16"}, {"sha": "32b3ddc2bf321f2f6a3dd0d95fce4d1e4b98d6ca", "filename": "gcc/config/i386/svr3.ifile", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fi386%2Fsvr3.ifile", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fi386%2Fsvr3.ifile", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsvr3.ifile?ref=c3bf16ff7dec47581f450b1a486cfdf9d566927e", "patch": "@@ -1,48 +0,0 @@\n-/*\n- *      svr3.ifile - for collectless G++ on i386 System V.\n- *\tLeaves memory configured at address 0.\n- *\t\n- *      Install this file as $prefix/gcc-lib/TARGET/VERSION/gcc.ifile\n- *\n- *\tBLOCK to an offset that leaves room for many headers ( the value\n- *\there allows for a file header, an outheader, and up to 11 section \n- *\theaders on most systems.\n- *\tBIND to an address that includes page 0 in mapped memory. The value\n- *\tused for BLOCK should be or'd into this value. Here I'm setting BLOCK\n- *\tto 0x200 and BIND to ( value_used_for(BLOCK) )\n- *\tIf you are using shared libraries, watch that you don't overlap the\n- *\taddress ranges assigned for shared libs.\n- *\n- *\tGROUP BIND to a location in the next segment.  Here, the only value\n- *\tthat you should change (I think) is that within NEXT, which I've set\n- *\tto my hardware segment size. You can always use a larger size, but not\n- *\ta smaller one.\n- */\n-SECTIONS\n-{\n-\t.text BIND(0x000200) BLOCK (0x200) :\n-\t{\n-\t\t /* plenty for room for headers */\n-\t\t*(.init)\n-\t\t*(.text)\n-\t\tvfork = fork; /* I got tired of editing peoples sloppy code */\n-\t\t*(.fini)\n-\t}\n-\t.stab BIND(ADDR(.text) + SIZEOF(.text)): { }\n-\t.stabstr BIND(ADDR(.stab) + SIZEOF(.stab)): { }\n-\tGROUP BIND( NEXT(0x400000) +\n-\t\t(ADDR(.stabstr) + (SIZEOF(.stabstr)) % 0x1000)):\n-\t{\n-\t\t\t.data : {\n-\t\t\t\t__CTOR_LIST__ = . ; \n-\t\t\t\t. += 4 ;\t/* leading NULL */\n-\t\t\t\t*(.ctor) \n-\t\t\t\t. += 4 ;\t/* trailing NULL */\n-\t\t\t\t__DTOR_LIST__ = . ;\n-\t\t\t\t. += 4 ;\t/* leading NULL */\n-\t\t\t\t*(.dtor) \n-\t\t\t\t. += 4 ; \t/* trailing NULL */\n-\t\t\t }\n-\t\t\t.bss : { }\n-\t}\n-}"}, {"sha": "d06d9117d4130cb48da1684a72467156e8aef4ee", "filename": "gcc/config/i386/svr3dbx.h", "status": "removed", "additions": 0, "deletions": 81, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fi386%2Fsvr3dbx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fi386%2Fsvr3dbx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsvr3dbx.h?ref=c3bf16ff7dec47581f450b1a486cfdf9d566927e", "patch": "@@ -1,81 +0,0 @@\n-/* Definitions for Intel 386 running system V, using dbx-in-coff encapsulation.\n-   Copyright (C) 1992, 1995, 2002 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-/* We do not want to output SDB debugging information.  */\n-\n-#undef SDB_DEBUGGING_INFO\n-\n-/* We want to output DBX debugging information.  */\n-\n-#define DBX_DEBUGGING_INFO 1\n-\n-/* Compensate for botch in dbxout_init/dbxout_source_file which\n-   unconditionally drops the first character from ltext_label_name */\n-\n-#undef ASM_GENERATE_INTERNAL_LABEL\n-#define ASM_GENERATE_INTERNAL_LABEL(BUF,PREFIX,NUMBER)\t\\\n-    sprintf ((BUF), \"*.%s%ld\", (PREFIX), (long)(NUMBER))\n-\n-/* With the current gas, .align N aligns to an N-byte boundary.\n-   This is done to be compatible with the system assembler.\n-   You must specify -DOTHER_ALIGN when building gas-1.38.1.  */\n-\n-#undef ASM_OUTPUT_ALIGN\n-#define ASM_OUTPUT_ALIGN(FILE,LOG)\t\\\n-     if ((LOG)!=0) fprintf ((FILE), \"\\t.align %d\\n\", 1<<(LOG))\n-\n-/* Align labels, etc. at 4-byte boundaries.\n-   For the 486, align to 16-byte boundary for sake of cache.  */\n-\n-#undef LABEL_ALIGN_AFTER_BARRIER\n-#define LABEL_ALIGN_AFTER_BARRIER(LABEL) (i386_align_jumps)\n-\n-/* Align start of loop at 4-byte boundary.  */\n-\n-#undef LOOP_ALIGN\n-#define LOOP_ALIGN(LABEL) (i386_align_loops)\n-\n-\n-/* Additional overrides needed for dbx-in-coff gas, mostly taken from pbb.h */\n-\n-/* Although the gas we use can create .ctor and .dtor sections from N_SETT\n-   stabs, it does not support section directives, so we need to have the loader\n-   define the lists.\n- */\n-#define CTOR_LISTS_DEFINED_EXTERNALLY\n-\n-/* Use crt1.o as a startup file and crtn.o as a closing file.  */\n-/*\n- * The loader directive file svr3.ifile defines how to merge the constructor \n- * sections into the data section.  Also, since gas only puts out those \n- * sections in response to N_SETT stabs, and does not (yet) have a \n- * \".sections\" directive, svr3.ifile also defines the list symbols \n- * __DTOR_LIST__ and __CTOR_LIST__.\n- */\n-#undef STARTFILE_SPEC\n-#define STARTFILE_SPEC \\\n-  \"%{!r:%{!z:svr3.ifile%s}%{z:svr3z.ifile%s}}\\\n-   %{pg:gcrt1.o%s}%{!pg:%{posix:%{p:mcrtp1.o%s}%{!p:crtp1.o%s}}%{!posix:%{p:mcrt1.o%s}%{!p:crt1.o%s}}} \\\n-   %{p:-L/usr/lib/libp}%{pg:-L/usr/lib/libp}\"\n-  \n-#define ENDFILE_SPEC \"crtn.o%s\"\n-  \n-#undef LIB_SPEC\n-#define LIB_SPEC \"%{posix:-lcposix} %{shlib:-lc_s} -lc -lg\""}, {"sha": "81428aeb9e4e5816d31b80d2f1f6dc6b480004ff", "filename": "gcc/config/i386/svr3gas.h", "status": "removed", "additions": 0, "deletions": 141, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fi386%2Fsvr3gas.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fi386%2Fsvr3gas.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsvr3gas.h?ref=c3bf16ff7dec47581f450b1a486cfdf9d566927e", "patch": "@@ -1,141 +0,0 @@\n-/* Definitions for Intel 386 running system V, using gas.\n-   Copyright (C) 1992, 1996, 2000, 2002 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#define TARGET_VERSION fprintf (stderr, \" (80386, ATT syntax)\"); \n-\n-/* Add stuff that normally comes from i386/sysv3.h */\n-\n-/* longjmp may fail to restore the registers if called from the same\n-   function that called setjmp.  To compensate, the compiler avoids\n-   putting variables in registers in functions that use both setjmp\n-   and longjmp.  */\n-\n-#define NON_SAVING_SETJMP \\\n-  (current_function_calls_setjmp && current_function_calls_longjmp)\n-\n-/* longjmp may fail to restore the stack pointer if the saved frame\n-   pointer is the same as the caller's frame pointer.  Requiring a frame\n-   pointer in any function that calls setjmp or longjmp avoids this\n-   problem, unless setjmp and longjmp are called from the same function.\n-   Since a frame pointer will be required in such a function, it is OK\n-   that the stack pointer is not restored.  */\n-\n-#undef SUBTARGET_FRAME_POINTER_REQUIRED\n-#define SUBTARGET_FRAME_POINTER_REQUIRED \\\n-  (current_function_calls_setjmp || current_function_calls_longjmp)\n-\n-/* Modify ASM_OUTPUT_LOCAL slightly to test -msvr3-shlib, adapted to gas  */\n-#undef ASM_OUTPUT_LOCAL\n-#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)\t\\\n-  do {\t\t\t\t\t\t\t\\\n-    int align = exact_log2 (ROUNDED);\t\t\t\\\n-    if (align > 2) align = 2;\t\t\t\t\\\n-    if (TARGET_SVR3_SHLIB)\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\\\n-\tdata_section ();\t\t\t\t\\\n-\tASM_OUTPUT_ALIGN ((FILE), align == -1 ? 2 : align); \\\n-\tASM_OUTPUT_LABEL ((FILE), (NAME));\t\t\\\n-\tfprintf ((FILE), \"\\t.set .,.+%u\\n\", (int)(ROUNDED));\t\\\n-      }\t\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\\\n-\tfputs (\".lcomm \", (FILE));\t\t\t\\\n-\tassemble_name ((FILE), (NAME));\t\t\t\\\n-\tfprintf ((FILE), \",%u\\n\", (int)(ROUNDED));\t\\\n-      }\t\t\t\t\t\t\t\\\n-  } while (0)\n-\n-/* Add stuff that normally comes from i386/sysv3.h via svr3.h */\n-\n-/* Define the actual types of some ANSI-mandated types.  These\n-   definitions should work for most SVR3 systems.  */\n-\n-#undef SIZE_TYPE\n-#define SIZE_TYPE \"unsigned int\"\n-\n-#undef PTRDIFF_TYPE\n-#define PTRDIFF_TYPE \"int\"\n-\n-#undef WCHAR_TYPE\n-#define WCHAR_TYPE \"long int\"\n-\n-#undef WCHAR_TYPE_SIZE\n-#define WCHAR_TYPE_SIZE BITS_PER_WORD\n-\f\n-/* ??? This stuff is copied from config/svr3.h.  In the future,\n-   this file should be rewritten to include config/svr3.h\n-   and override what isn't right.  */\n-\n-#define INIT_SECTION_ASM_OP     \"\\t.section\\t.init\"\n-#define FINI_SECTION_ASM_OP     \"\\t.section .fini,\\\"x\\\"\"\n-#define CTORS_SECTION_ASM_OP\tINIT_SECTION_ASM_OP\n-#define DTORS_SECTION_ASM_OP    FINI_SECTION_ASM_OP\n-\n-/* CTOR_LIST_BEGIN and CTOR_LIST_END are machine-dependent\n-   because they push on the stack.  */\n-/* This is copied from i386/sysv3.h.  */\n-\n-#define CTOR_LIST_BEGIN\t\t\t\t\\\n-  asm (INIT_SECTION_ASM_OP);\t\t\t\\\n-  asm (\"pushl $0\")\n-#define CTOR_LIST_END CTOR_LIST_BEGIN\n-\n-/* Constructor list on stack is in reverse order.  Go to the end of the\n-   list and go backwards to call constructors in the right order.  */\n-#define DO_GLOBAL_CTORS_BODY\t\t\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\\\n-  func_ptr *p, *beg = alloca (0);\t\t\t\t\\\n-  for (p = beg; *p; p++)\t\t\t\t\t\\\n-    ;\t\t\t\t\t\t\t\t\\\n-  while (p != beg)\t\t\t\t\t\t\\\n-    (*--p) ();\t\t\t\t\t\t\t\\\n-} while (0)\n-\n-#undef EXTRA_SECTIONS\n-#define EXTRA_SECTIONS in_init, in_fini\n-\n-#undef EXTRA_SECTION_FUNCTIONS\n-#define EXTRA_SECTION_FUNCTIONS\t\t\t\t\t\\\n-  INIT_SECTION_FUNCTION\t\t\t\t\t\t\\\n-  FINI_SECTION_FUNCTION\n-\n-#define INIT_SECTION_FUNCTION\t\t\t\t\t\\\n-void\t\t\t\t\t\t\t\t\\\n-init_section ()\t\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-  if (in_section != in_init)\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      fprintf (asm_out_file, \"%s\\n\", INIT_SECTION_ASM_OP);\t\\\n-      in_section = in_init;\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-}\n-\n-#define FINI_SECTION_FUNCTION\t\t\t\t\t\\\n-void\t\t\t\t\t\t\t\t\\\n-fini_section ()\t\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-  if (in_section != in_fini)\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      fprintf (asm_out_file, \"%s\\n\", FINI_SECTION_ASM_OP);\t\\\n-      in_section = in_fini;\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-}\n-\n-#define TARGET_ASM_CONSTRUCTOR  ix86_svr3_asm_out_constructor"}, {"sha": "4946051235e456d95b3e029e1fa8066411abb51a", "filename": "gcc/config/i386/svr3z.ifile", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fi386%2Fsvr3z.ifile", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fi386%2Fsvr3z.ifile", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsvr3z.ifile?ref=c3bf16ff7dec47581f450b1a486cfdf9d566927e", "patch": "@@ -1,48 +0,0 @@\n-/*\n- *      svr3z.ifile - for collectless G++ on i386 System V.\n- *\tLeaves memory unconfigured at address 0.\n- *\t\n- *      Install this file as $prefix/gcc-lib/TARGET/VERSION/gccz.ifile\n- *\n- *\tBLOCK to an offset that leaves room for many headers ( the value\n- *\there allows for a file header, an outheader, and up to 11 section \n- *\theaders on most systems.\n- *\tBIND to an address that excludes page 0 from being mapped. The value\n- *\tused for BLOCK should be or'd into this value. Here I'm setting BLOCK\n- *\tto 0x200 and BIND to ( 0x400000 | value_used_for(BLOCK) )\n- *\tIf you are using shared libraries, watch that you don't overlap the\n- *\taddress ranges assigned for shared libs.\n- *\n- *\tGROUP BIND to a location in the next segment.  Here, the only value\n- *\tthat you should change (I think) is that within NEXT, which I've set\n- *\tto my hardware segment size. You can always use a larger size, but not\n- *\ta smaller one.\n- */\n-SECTIONS\n-{\n-\t.text BIND(0x400200) BLOCK (0x200) :\n-\t{\n-\t\t /* plenty for room for headers */\n-\t\t*(.init)\n-\t\t*(.text)\n-\t\tvfork = fork; /* I got tired of editing peoples sloppy code */\n-\t\t*(.fini)\n-\t}\n-\t.stab BIND(ADDR(.text) + SIZEOF(.text)): { }\n-\t.stabstr BIND(ADDR(.stab) + SIZEOF(.stab)): { }\n-\tGROUP BIND( NEXT(0x400000) +\n-\t\t(ADDR(.stabstr) + (SIZEOF(.stabstr)) % 0x1000)):\n-\t{\n-\t\t\t.data : {\n-\t\t\t\t__CTOR_LIST__ = . ; \n-\t\t\t\t. += 4 ;\t/* leading NULL */\n-\t\t\t\t*(.ctor) \n-\t\t\t\t. += 4 ;\t/* trailing NULL */\n-\t\t\t\t__DTOR_LIST__ = . ;\n-\t\t\t\t. += 4 ;\t/* leading NULL */\n-\t\t\t\t*(.dtor) \n-\t\t\t\t. += 4 ; \t/* trailing NULL */\n-\t\t\t }\n-\t\t\t.bss : { }\n-\t}\n-}"}, {"sha": "96e186439795766be9467d2388fd8321334e5a83", "filename": "gcc/config/i386/t-udk", "status": "removed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fi386%2Ft-udk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fi386%2Ft-udk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Ft-udk?ref=c3bf16ff7dec47581f450b1a486cfdf9d566927e", "patch": "@@ -1,2 +0,0 @@\n-# Tell fixincludes to work on this set of headers\n-SYSTEM_HEADER_DIR = /udk/usr/include"}, {"sha": "66f5b87067e337b21963f941b54749a4dd51b783", "filename": "gcc/config/i386/udk.h", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fi386%2Fudk.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fi386%2Fudk.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fudk.h?ref=c3bf16ff7dec47581f450b1a486cfdf9d566927e", "patch": "@@ -1,28 +0,0 @@\n-/* Configuration for i386 interfacing with SCO's Universal Development Kit\n-   probably running on OpenServer 5, Unixware 2, or Unixware 5\n- */\n-\n-\n-/* We're very much the SVR4 target with \"/udk\" prepended to everything that's\n-   interesting */\n-\n-#undef MD_EXEC_PREFIX\n-#define MD_EXEC_PREFIX \t\t\"/udk/usr/ccs/bin/\" \n-\n-#undef MD_STARTFILE_PREFIX\n-#define MD_STARTFILE_PREFIX \t\"/udk/usr/ccs/lib/\" \n-\n-#define STANDARD_INCLUDE_DIR\t\"/udk/usr/include\"\n-\n-#undef LINK_SPEC\n-#define LINK_SPEC \"%{h*} %{v:-V} \\\n-\t%{b} %{Wl,*:%*} \\\n-\t%{static:-dn -Bstatic} \\\n-\t%{shared:-G -dy -z text} \\\n-\t%{symbolic:-Bsymbolic -G -dy -z text} \\\n-\t%{G:-G} \\\n-\t%{YP,*} \\\n-\t%{!YP,*:%{p:-Y P,/udk/usr/ccs/lib/libp:/udk/usr/lib/libp:/udk/usr/ccs/lib:/udk/usr/lib} \\\n-\t%{!p:-Y P,/udk/usr/ccs/lib:/udk/usr/lib}} \\\n-\t%{Qy:} %{!Qn:-Qy}\"\n-"}, {"sha": "f9c4710c6ffad69b81916a21f662c36ccba1aab6", "filename": "gcc/config/i386/vsta.h", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fi386%2Fvsta.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fi386%2Fvsta.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fvsta.h?ref=c3bf16ff7dec47581f450b1a486cfdf9d566927e", "patch": "@@ -1,32 +0,0 @@\n-/* Configuration for an i386 running VSTa micro-kernel.\n-   Copyright (C) 1994, 2002 Free Software Foundation, Inc.\n-   Contributed by Rob Savoye (rob@cygnus.com).\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#define TARGET_VERSION fprintf (stderr, \" (80386, BSD syntax)\"); \n-\n-#define TARGET_OS_CPP_BUILTINS()\t\t\\\n-  do\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\\\n-\tbuiltin_define_std (\"unix\");\t\t\\\n-\tbuiltin_define (\"VSTA\");\t\t\\\n-\tbuiltin_assert (\"system=unix\");\t\t\\\n-\tbuiltin_assert (\"system=vsta\");\t\t\\\n-    }\t\t\t\t\t\t\\\n-  while (0)"}, {"sha": "6c1199e352e4085d06be5082a3dd4b3ab49f61d2", "filename": "gcc/config/i960/i960-c.c", "status": "removed", "additions": 0, "deletions": 117, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fi960%2Fi960-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fi960%2Fi960-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960-c.c?ref=c3bf16ff7dec47581f450b1a486cfdf9d566927e", "patch": "@@ -1,117 +0,0 @@\n-/* Intel 80960 specific, C compiler specific functions.\n-   Copyright (C) 1992, 1995, 1996, 1997, 1998, 1999, 2000\n-   Free Software Foundation, Inc.\n-   Contributed by Steven McGeady, Intel Corp.\n-   Additional Work by Glenn Colon-Bonet, Jonathan Shapiro, Andy Wilson\n-   Converted to GCC 2.0 by Jim Wilson and Michael Tiemann, Cygnus Support.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"cpplib.h\"\n-#include \"tree.h\"\n-#include \"c-pragma.h\"\n-#include \"toplev.h\"\n-#include \"ggc.h\"\n-#include \"tm_p.h\"\n-\n-/* Handle pragmas for compatibility with Intel's compilers.  */\n-\n-/* NOTE: ic960 R3.0 pragma align definition:\n-\n-   #pragma align [(size)] | (identifier=size[,...])\n-   #pragma noalign [(identifier)[,...]]\n-     \n-   (all parens are optional)\n-     \n-   - size is [1,2,4,8,16]\n-   - noalign means size==1\n-   - applies only to component elements of a struct (and union?)\n-   - identifier applies to structure tag (only)\n-   - missing identifier means next struct\n-     \n-   - alignment rules for bitfields need more investigation.\n-\n-   This implementation only handles the case of no identifiers.  */\n-\n-void\n-i960_pr_align (pfile)\n-     cpp_reader *pfile ATTRIBUTE_UNUSED;\n-{\n-  tree number;\n-  enum cpp_ttype type;\n-  int align;\n-\n-  type = c_lex (&number);\n-  if (type == CPP_OPEN_PAREN)\n-    type = c_lex (&number);\n-  if (type == CPP_NAME)\n-    {\n-      warning (\"sorry, not implemented: #pragma align NAME=SIZE\");\n-      return;\n-    }\n-  if (type != CPP_NUMBER)\n-    {\n-      warning (\"malformed #pragma align - ignored\");\n-      return;\n-    }\n-\n-  align = TREE_INT_CST_LOW (number);\n-  switch (align)\n-    {\n-    case 0:\n-      /* Return to last alignment.  */\n-      align = i960_last_maxbitalignment / 8;\n-      /* Fall through.  */\n-    case 16:\n-    case 8:\n-    case 4:\n-    case 2:\n-    case 1:\n-      i960_last_maxbitalignment = i960_maxbitalignment;\n-      i960_maxbitalignment = align * 8;\n-      break;\n-      \n-    default:\n-      /* Silently ignore bad values.  */\n-      break;\n-    }\n-}\n-\n-void\n-i960_pr_noalign (pfile)\n-     cpp_reader *pfile ATTRIBUTE_UNUSED;\n-{\n-  enum cpp_ttype type;\n-  tree number;\n-\n-  type = c_lex (&number);\n-  if (type == CPP_OPEN_PAREN)\n-    type = c_lex (&number);\n-  if (type == CPP_NAME)\n-    {\n-      warning (\"sorry, not implemented: #pragma noalign NAME\");\n-      return;\n-    }\n-\n-  i960_last_maxbitalignment = i960_maxbitalignment;\n-  i960_maxbitalignment = 8;\n-}"}, {"sha": "465ea33cc3e76a2aad2e0e693f93baca5f0444e4", "filename": "gcc/config/i960/i960-coff.h", "status": "removed", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fi960%2Fi960-coff.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fi960%2Fi960-coff.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960-coff.h?ref=c3bf16ff7dec47581f450b1a486cfdf9d566927e", "patch": "@@ -1,43 +0,0 @@\n-/* Definitions of target machine for GNU compiler, for \"naked\" Intel\n-   80960 using coff object format and coff debugging symbols.\n-   Copyright (C) 1988, 1989, 1991, 1996, 2000 Free Software Foundation.\n-   Contributed by Steven McGeady (mcg@omepd.intel.com)\n-   Additional work by Glenn Colon-Bonet, Jonathan Shapiro, Andy Wilson\n-   Converted to GCC 2.0 by Michael Tiemann, Cygnus Support.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-/* Support -gstabs using stabs in COFF sections.  */\n-\n-/* Generate SDB_DEBUGGING_INFO by default.  */\n-#undef PREFERRED_DEBUGGING_TYPE\n-#define PREFERRED_DEBUGGING_TYPE SDB_DEBUG\n-\n-/* This is intended to be used with Cygnus's newlib library, so we want to\n-   use the standard definition of LIB_SPEC.  */\n-#undef LIB_SPEC\n-\n-/* Emit a .file directive.  */\n-#define TARGET_ASM_FILE_START_FILE_DIRECTIVE true\n-\n-/* Support the ctors and dtors sections for g++.  */\n-\n-#define CTORS_SECTION_ASM_OP\t\"\\t.section\\t.ctors,\\\"x\\\"\"\n-#define DTORS_SECTION_ASM_OP\t\"\\t.section\\t.dtors,\\\"x\\\"\"\n-\n-/* end of i960-coff.h */"}, {"sha": "e99939049c62734e62d3f7aba6e239841f2ecb37", "filename": "gcc/config/i960/i960-modes.def", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fi960%2Fi960-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fi960%2Fi960-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960-modes.def?ref=c3bf16ff7dec47581f450b1a486cfdf9d566927e", "patch": "@@ -1,33 +0,0 @@\n-/* Definitions of target machine for GNU compiler, for Intel 80960\n-   Copyright (C) 2002 Free Software Foundation, Inc.\n-   Contributed by Steven McGeady, Intel Corp.\n-   Additional Work by Glenn Colon-Bonet, Jonathan Shapiro, Andy Wilson\n-   Converted to GCC 2.0 by Jim Wilson and Michael Tiemann, Cygnus Support.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-/* long double */\n-FLOAT_MODE (TF, 16, ieee_extended_intel_128_format);\n-\n-/* Add any extra modes needed to represent the condition code.\n-\n-   Also, signed and unsigned comparisons are distinguished, as\n-   are operations which are compatible with chkbit insns.  */\n-\n-CC_MODE (CC_UNS);\n-CC_MODE (CC_CHK);"}, {"sha": "269a40be19cbbd99622c0cd221a1e2788cbd1c2a", "filename": "gcc/config/i960/i960-protos.h", "status": "removed", "additions": 0, "deletions": 102, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fi960%2Fi960-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fi960%2Fi960-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960-protos.h?ref=c3bf16ff7dec47581f450b1a486cfdf9d566927e", "patch": "@@ -1,102 +0,0 @@\n-/* Definitions of target machine for GNU compiler, for Intel 80960\n-   Copyright (C) 2000\n-   Free Software Foundation, Inc.\n-   Contributed by Steven McGeady, Intel Corp.\n-   Additional Work by Glenn Colon-Bonet, Jonathan Shapiro, Andy Wilson\n-   Converted to GCC 2.0 by Jim Wilson and Michael Tiemann, Cygnus Support.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#ifndef GCC_I960_PROTOS_H\n-#define GCC_I960_PROTOS_H\n-\n-#ifdef RTX_CODE\n-extern struct rtx_def *legitimize_address (rtx, rtx, enum machine_mode);\n-/* Define the function that build the compare insn for scc and bcc.  */\n-\n-extern struct rtx_def *gen_compare_reg (enum rtx_code, rtx, rtx);\n-\n-/* Define functions in i960.c and used in insn-output.c.  */\n-\n-extern const char *i960_output_ldconst (rtx, rtx);\n-extern const char *i960_output_call_insn (rtx, rtx, rtx, rtx);\n-extern const char *i960_output_ret_insn (rtx);\n-extern const char *i960_output_move_double (rtx, rtx);\n-extern const char *i960_output_move_double_zero (rtx);\n-extern const char *i960_output_move_quad (rtx, rtx);\n-extern const char *i960_output_move_quad_zero (rtx);\n-\n-extern int literal (rtx, enum machine_mode);\n-extern int hard_regno_mode_ok (int, enum machine_mode);\n-extern int fp_literal (rtx, enum machine_mode);\n-extern int signed_literal (rtx, enum machine_mode);\n-extern int legitimate_address_p (enum machine_mode, rtx, int);\n-extern void i960_print_operand (FILE *, rtx, int);\n-extern int fpmove_src_operand (rtx, enum machine_mode);\n-extern int arith_operand (rtx, enum machine_mode);\n-extern int logic_operand (rtx, enum machine_mode);\n-extern int fp_arith_operand (rtx, enum machine_mode);\n-extern int signed_arith_operand (rtx, enum machine_mode);\n-extern int fp_literal_one (rtx, enum machine_mode);\n-extern int fp_literal_zero (rtx, enum machine_mode);\n-extern int symbolic_memory_operand (rtx, enum machine_mode);\n-extern int eq_or_neq (rtx, enum machine_mode);\n-extern int arith32_operand (rtx, enum machine_mode);\n-extern int power2_operand (rtx, enum machine_mode);\n-extern int cmplpower2_operand (rtx, enum machine_mode);\n-extern enum machine_mode select_cc_mode (RTX_CODE, rtx);\n-extern int emit_move_sequence (rtx *, enum machine_mode);\n-extern int i960_bypass (rtx, rtx, rtx, int);\n-extern void i960_print_operand_addr (FILE *, rtx);\n-extern int i960_expr_alignment (rtx, int);\n-extern int i960_improve_align (rtx, rtx, int);\n-extern int i960_si_ti (rtx, rtx);\n-extern int i960_si_di (rtx, rtx);\n-#ifdef TREE_CODE\n-extern struct rtx_def *i960_function_arg (CUMULATIVE_ARGS *,\n-\t\t\t\t\t  enum machine_mode,\n-\t\t\t\t\t  tree, int);\n-extern rtx i960_va_arg (tree, tree);\n-extern void i960_va_start (tree, rtx);\n-#endif /* TREE_CODE */\n-extern enum reg_class secondary_reload_class (enum reg_class, enum machine_mode, rtx);\n-#endif /* RTX_CODE */\n-\n-#ifdef TREE_CODE\n-extern void i960_function_name_declare (FILE *, const char *, tree);\n-extern void i960_function_arg_advance (CUMULATIVE_ARGS *, enum machine_mode, tree, int);\n-extern int i960_round_align (int, tree);\n-extern void i960_setup_incoming_varargs (CUMULATIVE_ARGS *, enum machine_mode, tree, int *, int);\n-extern int i960_final_reg_parm_stack_space (int, tree);\n-extern int i960_reg_parm_stack_space (tree);\n-#endif /* TREE_CODE */\n-\n-extern int process_pragma (int(*)(void), void(*)(int), const char *);\n-extern int i960_object_bytes_bitalign (int);\n-extern void i960_initialize (void);\n-extern int bitpos (unsigned int);\n-extern int is_mask (unsigned int);\n-extern int bitstr (unsigned int, int *, int *);\n-extern int compute_frame_size (int);\n-extern void output_function_profiler (FILE *, int);\n-extern void i960_scan_opcode (const char *);\n-\n-extern void i960_pr_align (struct cpp_reader *);\n-extern void i960_pr_noalign (struct cpp_reader *);\n-\n-#endif /* ! GCC_I960_PROTOS_H  */"}, {"sha": "3d976b65fd4e32d732cb6693235f71cd18d87bcb", "filename": "gcc/config/i960/i960.c", "status": "removed", "additions": 0, "deletions": 2917, "changes": 2917, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fi960%2Fi960.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fi960%2Fi960.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.c?ref=c3bf16ff7dec47581f450b1a486cfdf9d566927e", "patch": "@@ -1,2917 +0,0 @@\n-/* Subroutines used for code generation on intel 80960.\n-   Copyright (C) 1992, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003\n-   Free Software Foundation, Inc.\n-   Contributed by Steven McGeady, Intel Corp.\n-   Additional Work by Glenn Colon-Bonet, Jonathan Shapiro, Andy Wilson\n-   Converted to GCC 2.0 by Jim Wilson and Michael Tiemann, Cygnus Support.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include <math.h>\n-#include \"rtl.h\"\n-#include \"regs.h\"\n-#include \"hard-reg-set.h\"\n-#include \"real.h\"\n-#include \"insn-config.h\"\n-#include \"conditions.h\"\n-#include \"output.h\"\n-#include \"insn-attr.h\"\n-#include \"flags.h\"\n-#include \"tree.h\"\n-#include \"expr.h\"\n-#include \"except.h\"\n-#include \"function.h\"\n-#include \"recog.h\"\n-#include \"toplev.h\"\n-#include \"tm_p.h\"\n-#include \"target.h\"\n-#include \"target-def.h\"\n-\n-static void i960_output_function_prologue (FILE *, HOST_WIDE_INT);\n-static void i960_output_function_epilogue (FILE *, HOST_WIDE_INT);\n-static void i960_output_mi_thunk (FILE *, tree, HOST_WIDE_INT,\n-\t\t\t\t  HOST_WIDE_INT, tree);\n-static bool i960_rtx_costs (rtx, int, int, int *);\n-static int i960_address_cost (rtx);\n-static tree i960_build_builtin_va_list (void);\n-\n-/* Save the operands last given to a compare for use when we\n-   generate a scc or bcc insn.  */\n-\n-rtx i960_compare_op0, i960_compare_op1;\n-\n-/* Used to implement #pragma align/noalign.  Initialized by OVERRIDE_OPTIONS\n-   macro in i960.h.  */\n-\n-int i960_maxbitalignment;\n-int i960_last_maxbitalignment;\n-\n-/* Used to implement switching between MEM and ALU insn types, for better\n-   C series performance.  */\n-\n-enum insn_types i960_last_insn_type;\n-\n-/* The leaf-procedure return register.  Set only if this is a leaf routine.  */\n-\n-static int i960_leaf_ret_reg;\n-\n-/* True if replacing tail calls with jumps is OK.  */\n-\n-static int tail_call_ok;\n-\n-/* A string containing a list of insns to emit in the epilogue so as to\n-   restore all registers saved by the prologue.  Created by the prologue\n-   code as it saves registers away.  */\n-\n-char epilogue_string[1000];\n-\n-/* A unique number (per function) for return labels.  */\n-\n-static int ret_label = 0;\n-\n-/* This is true if FNDECL is either a varargs or a stdarg function.\n-   This is used to help identify functions that use an argument block.  */\n-\n-#define VARARGS_STDARG_FUNCTION(FNDECL)\t\\\n-(TYPE_ARG_TYPES (TREE_TYPE (FNDECL)) != 0\t\t\t\t\\\n-  && (TREE_VALUE (tree_last (TYPE_ARG_TYPES (TREE_TYPE (FNDECL)))))\t\\\n-      != void_type_node)\n-\f\n-/* Initialize the GCC target structure.  */\n-#undef TARGET_ASM_ALIGNED_SI_OP\n-#define TARGET_ASM_ALIGNED_SI_OP \"\\t.word\\t\"\n-\n-#undef TARGET_ASM_FUNCTION_PROLOGUE\n-#define TARGET_ASM_FUNCTION_PROLOGUE i960_output_function_prologue\n-#undef TARGET_ASM_FUNCTION_EPILOGUE\n-#define TARGET_ASM_FUNCTION_EPILOGUE i960_output_function_epilogue\n-\n-#undef TARGET_ASM_OUTPUT_MI_THUNK\n-#define TARGET_ASM_OUTPUT_MI_THUNK i960_output_mi_thunk\n-#undef TARGET_CAN_ASM_OUTPUT_MI_THUNK\n-#define TARGET_CAN_ASM_OUTPUT_MI_THUNK default_can_output_mi_thunk_no_vcall\n-\n-#undef TARGET_RTX_COSTS\n-#define TARGET_RTX_COSTS i960_rtx_costs\n-#undef TARGET_ADDRESS_COST\n-#define TARGET_ADDRESS_COST i960_address_cost\n-\n-#undef TARGET_BUILD_BUILTIN_VA_LIST\n-#define TARGET_BUILD_BUILTIN_VA_LIST i960_build_builtin_va_list\n-\n-struct gcc_target targetm = TARGET_INITIALIZER;\n-\f\n-/* Override conflicting target switch options.\n-   Doesn't actually detect if more than one -mARCH option is given, but\n-   does handle the case of two blatantly conflicting -mARCH options.\n-\n-   Also initialize variables before compiling any files.  */\n-\n-void\n-i960_initialize ()\n-{\n-  if (TARGET_K_SERIES && TARGET_C_SERIES)\n-    {\n-      warning (\"conflicting architectures defined - using C series\");\n-      target_flags &= ~TARGET_FLAG_K_SERIES;\n-    }\n-  if (TARGET_K_SERIES && TARGET_MC)\n-    {\n-      warning (\"conflicting architectures defined - using K series\");\n-      target_flags &= ~TARGET_FLAG_MC;\n-    }\n-  if (TARGET_C_SERIES && TARGET_MC)\n-    {\n-      warning (\"conflicting architectures defined - using C series\");\n-      target_flags &= ~TARGET_FLAG_MC;\n-    }\n-  if (TARGET_IC_COMPAT3_0)\n-    {\n-      flag_short_enums = 1;\n-      flag_signed_char = 1;\n-      target_flags |= TARGET_FLAG_CLEAN_LINKAGE;\n-      if (TARGET_IC_COMPAT2_0)\n-\t{\n-\t  warning (\"iC2.0 and iC3.0 are incompatible - using iC3.0\");\n-\t  target_flags &= ~TARGET_FLAG_IC_COMPAT2_0;\n-\t}\n-    }\n-  if (TARGET_IC_COMPAT2_0)\n-    {\n-      flag_signed_char = 1;\n-      target_flags |= TARGET_FLAG_CLEAN_LINKAGE;\n-    }\n-\n-  if (TARGET_IC_COMPAT2_0)\n-    {\n-      i960_maxbitalignment = 8;\n-      i960_last_maxbitalignment = 128;\n-    }\n-  else\n-    {\n-      i960_maxbitalignment = 128;\n-      i960_last_maxbitalignment = 8;\n-    }\n-}\n-\f\n-/* Return true if OP can be used as the source of an fp move insn.  */\n-\n-int\n-fpmove_src_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  return (GET_CODE (op) == CONST_DOUBLE || general_operand (op, mode));\n-}\n-\n-#if 0\n-/* Return true if OP is a register or zero.  */\n-\n-int\n-reg_or_zero_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  return register_operand (op, mode) || op == const0_rtx;\n-}\n-#endif\n-\n-/* Return truth value of whether OP can be used as an operands in a three\n-   address arithmetic insn (such as add %o1,7,%l2) of mode MODE.  */\n-\n-int\n-arith_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  return (register_operand (op, mode) || literal (op, mode));\n-}\n-\n-/* Return truth value of whether OP can be used as an operands in a three\n-   address logic insn, possibly complementing OP, of mode MODE.  */\n-\n-int\n-logic_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  return (register_operand (op, mode)\n-\t  || (GET_CODE (op) == CONST_INT\n-\t      && INTVAL(op) >= -32 && INTVAL(op) < 32));\n-}\n-\n-/* Return true if OP is a register or a valid floating point literal.  */\n-\n-int\n-fp_arith_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  return (register_operand (op, mode) || fp_literal (op, mode));\n-}\n-\n-/* Return true if OP is a register or a valid signed integer literal.  */\n-\n-int\n-signed_arith_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  return (register_operand (op, mode) || signed_literal (op, mode));\n-}\n-\n-/* Return truth value of whether OP is an integer which fits the\n-   range constraining immediate operands in three-address insns.  */\n-\n-int\n-literal (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-{\n-  return ((GET_CODE (op) == CONST_INT) && INTVAL(op) >= 0 && INTVAL(op) < 32);\n-}\n-\n-/* Return true if OP is a float constant of 1.  */\n-\n-int\n-fp_literal_one (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  return (TARGET_NUMERICS && mode == GET_MODE (op) && op == CONST1_RTX (mode));\n-}\n-\n-/* Return true if OP is a float constant of 0.  */\n-\n-int\n-fp_literal_zero (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  return (TARGET_NUMERICS && mode == GET_MODE (op) && op == CONST0_RTX (mode));\n-}\n-\n-/* Return true if OP is a valid floating point literal.  */\n-\n-int\n-fp_literal(op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  return fp_literal_zero (op, mode) || fp_literal_one (op, mode);\n-}\n-\n-/* Return true if OP is a valid signed immediate constant.  */\n-\n-int\n-signed_literal(op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-{\n-  return ((GET_CODE (op) == CONST_INT) && INTVAL(op) > -32 && INTVAL(op) < 32);\n-}\n-\n-/* Return truth value of statement that OP is a symbolic memory\n-   operand of mode MODE.  */\n-\n-int\n-symbolic_memory_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-{\n-  if (GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n-  if (GET_CODE (op) != MEM)\n-    return 0;\n-  op = XEXP (op, 0);\n-  return (GET_CODE (op) == SYMBOL_REF || GET_CODE (op) == CONST\n-\t  || GET_CODE (op) == HIGH || GET_CODE (op) == LABEL_REF);\n-}\n-\n-/* Return truth value of whether OP is EQ or NE.  */\n-\n-int\n-eq_or_neq (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-{\n-  return (GET_CODE (op) == EQ || GET_CODE (op) == NE);\n-}\n-\n-/* OP is an integer register or a constant.  */\n-\n-int\n-arith32_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  if (register_operand (op, mode))\n-    return 1;\n-  return (CONSTANT_P (op));\n-}\n-\n-/* Return true if OP is an integer constant which is a power of 2.  */\n-\n-int\n-power2_operand (op,mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-{\n-  if (GET_CODE (op) != CONST_INT)\n-    return 0;\n-\n-  return exact_log2 (INTVAL (op)) >= 0;\n-}\n-\n-/* Return true if OP is an integer constant which is the complement of a\n-   power of 2.  */\n-\n-int\n-cmplpower2_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-{\n-  if (GET_CODE (op) != CONST_INT)\n-    return 0;\n-\n-  return exact_log2 (~ INTVAL (op)) >= 0;\n-}\n-\n-/* If VAL has only one bit set, return the index of that bit.  Otherwise\n-   return -1.  */\n-\n-int\n-bitpos (val)\n-     unsigned int val;\n-{\n-  register int i;\n-\n-  for (i = 0; val != 0; i++, val >>= 1)\n-    {\n-      if (val & 1)\n-\t{\n-\t  if (val != 1)\n-\t    return -1;\n-\t  return i;\n-\t}\n-    }\n-  return -1;\n-}\n-\n-/* Return nonzero if OP is a mask, i.e. all one bits are consecutive.\n-   The return value indicates how many consecutive nonzero bits exist\n-   if this is a mask.  This is the same as the next function, except that\n-   it does not indicate what the start and stop bit positions are.  */\n-\n-int\n-is_mask (val)\n-     unsigned int val;\n-{\n-  register int start, end = 0, i;\n-\n-  start = -1;\n-  for (i = 0; val != 0; val >>= 1, i++)\n-    {\n-      if (val & 1)\n-\t{\n-\t  if (start < 0)\n-\t    start = i;\n-\n-\t  end = i;\n-\t  continue;\n-\t}\n-      /* Still looking for the first bit.  */\n-      if (start < 0)\n-\tcontinue;\n-\n-      /* We've seen the start of a bit sequence, and now a zero.  There\n-\t must be more one bits, otherwise we would have exited the loop.\n-\t Therefore, it is not a mask.  */\n-      if (val)\n-\treturn 0;\n-    }\n-\n-  /* The bit string has ones from START to END bit positions only.  */\n-  return end - start + 1;\n-}\n-\n-/* If VAL is a mask, then return nonzero, with S set to the starting bit\n-   position and E set to the ending bit position of the mask.  The return\n-   value indicates how many consecutive bits exist in the mask.  This is\n-   the same as the previous function, except that it also indicates the\n-   start and end bit positions of the mask.  */\n-\n-int\n-bitstr (val, s, e)\n-     unsigned int val;\n-     int *s, *e;\n-{\n-  register int start, end, i;\n-\n-  start = -1;\n-  end = -1;\n-  for (i = 0; val != 0; val >>= 1, i++)\n-    {\n-      if (val & 1)\n-\t{\n-\t  if (start < 0)\n-\t    start = i;\n-\n-\t  end = i;\n-\t  continue;\n-\t}\n-\n-      /* Still looking for the first bit.  */\n-      if (start < 0)\n-\tcontinue;\n-\n-      /* We've seen the start of a bit sequence, and now a zero.  There\n-\t must be more one bits, otherwise we would have exited the loop.\n-\t Therefor, it is not a mask.  */\n-      if (val)\n-\t{\n-\t  start = -1;\n-\t  end = -1;\n-\t  break;\n-\t}\n-    }\n-\n-  /* The bit string has ones from START to END bit positions only.  */\n-  *s = start;\n-  *e = end;\n-  return ((start < 0) ? 0 : end - start + 1);\n-}\n-\f\n-/* Return the machine mode to use for a comparison.  */\n-\n-enum machine_mode\n-select_cc_mode (op, x)\n-     RTX_CODE op;\n-     rtx x ATTRIBUTE_UNUSED;\n-{\n-  if (op == GTU || op == LTU || op == GEU || op == LEU)\n-    return CC_UNSmode;\n-  return CCmode;\n-}\n-\n-/* X and Y are two things to compare using CODE.  Emit the compare insn and\n-   return the rtx for register 36 in the proper mode.  */\n-\n-rtx\n-gen_compare_reg (code, x, y)\n-     enum rtx_code code;\n-     rtx x, y;\n-{\n-  rtx cc_reg;\n-  enum machine_mode ccmode = SELECT_CC_MODE (code, x, y);\n-  enum machine_mode mode\n-    = GET_MODE (x) == VOIDmode ? GET_MODE (y) : GET_MODE (x);\n-\n-  if (mode == SImode)\n-    {\n-      if (! arith_operand (x, mode))\n-\tx = force_reg (SImode, x);\n-      if (! arith_operand (y, mode))\n-\ty = force_reg (SImode, y);\n-    }\n-\n-  cc_reg = gen_rtx_REG (ccmode, 36);\n-  emit_insn (gen_rtx_SET (VOIDmode, cc_reg,\n-\t\t\t  gen_rtx_COMPARE (ccmode, x, y)));\n-\n-  return cc_reg;\n-}\n-\n-/* For the i960, REG is cost 1, REG+immed CONST is cost 2, REG+REG is cost 2,\n-   REG+nonimmed CONST is cost 4.  REG+SYMBOL_REF, SYMBOL_REF, and similar\n-   are 4.  Indexed addresses are cost 6.  */\n-\n-/* ??? Try using just RTX_COST, i.e. not defining ADDRESS_COST.  */\n-\n-static int\n-i960_address_cost (x)\n-     rtx x;\n-{\n-  if (GET_CODE (x) == REG)\n-    return 1;\n-\n-  /* This is a MEMA operand -- it's free.  */\n-  if (GET_CODE (x) == CONST_INT\n-      && INTVAL (x) >= 0\n-      && INTVAL (x) < 4096)\n-    return 0;\n-\n-  if (GET_CODE (x) == PLUS)\n-    {\n-      rtx base = XEXP (x, 0);\n-      rtx offset = XEXP (x, 1);\n-\n-      if (GET_CODE (base) == SUBREG)\n-\tbase = SUBREG_REG (base);\n-      if (GET_CODE (offset) == SUBREG)\n-\toffset = SUBREG_REG (offset);\n-\n-      if (GET_CODE (base) == REG)\n-\t{\n-\t  if (GET_CODE (offset) == REG)\n-\t    return 2;\n-\t  if (GET_CODE (offset) == CONST_INT)\n-\t    {\n-\t      if ((unsigned)INTVAL (offset) < 2047)\n-\t\treturn 2;\n-\t      return 4;\n-\t    }\n-\t  if (CONSTANT_P (offset))\n-\t    return 4;\n-\t}\n-      if (GET_CODE (base) == PLUS || GET_CODE (base) == MULT)\n-\treturn 6;\n-\n-      /* This is an invalid address.  The return value doesn't matter, but\n-\t for convenience we make this more expensive than anything else.  */\n-      return 12;\n-    }\n-  if (GET_CODE (x) == MULT)\n-    return 6;\n-\n-  /* Symbol_refs and other unrecognized addresses are cost 4.  */\n-  return 4;\n-}\n-\f\n-/* Emit insns to move operands[1] into operands[0].\n-\n-   Return 1 if we have written out everything that needs to be done to\n-   do the move.  Otherwise, return 0 and the caller will emit the move\n-   normally.  */\n-\n-int\n-emit_move_sequence (operands, mode)\n-     rtx *operands;\n-     enum machine_mode mode;\n-{\n-  /* We can only store registers to memory.  */\n-  \n-  if (GET_CODE (operands[0]) == MEM && GET_CODE (operands[1]) != REG\n-      && (operands[1] != const0_rtx || current_function_args_size\n-\t  || current_function_stdarg\n-\t  || rtx_equal_function_value_matters))\n-    /* Here we use the same test as movsi+1 pattern -- see i960.md.  */\n-    operands[1] = force_reg (mode, operands[1]);\n-\n-  /* Storing multi-word values in unaligned hard registers to memory may\n-     require a scratch since we have to store them a register at a time and\n-     adding 4 to the memory address may not yield a valid insn.  */\n-  /* ??? We don't always need the scratch, but that would complicate things.\n-     Maybe later.  */\n-  /* ??? We must also handle stores to pseudos here, because the pseudo may be\n-     replaced with a MEM later.  This would be cleaner if we didn't have\n-     a separate pattern for unaligned DImode/TImode stores.  */\n-  if (GET_MODE_SIZE (mode) > UNITS_PER_WORD\n-      && (GET_CODE (operands[0]) == MEM\n-\t  || (GET_CODE (operands[0]) == REG\n-\t      && REGNO (operands[0]) >= FIRST_PSEUDO_REGISTER))\n-      && GET_CODE (operands[1]) == REG\n-      && REGNO (operands[1]) < FIRST_PSEUDO_REGISTER\n-      && ! HARD_REGNO_MODE_OK (REGNO (operands[1]), mode))\n-    {\n-      emit_insn (gen_rtx_PARALLEL\n-\t\t (VOIDmode,\n-\t\t  gen_rtvec (2,\n-\t\t\t     gen_rtx_SET (VOIDmode, operands[0], operands[1]),\n-\t\t\t     gen_rtx_CLOBBER (VOIDmode,\n-\t\t\t\t\t      gen_rtx_SCRATCH (Pmode)))));\n-      return 1;\n-    }\n-\n-  return 0;\n-}\n-\n-/* Output assembler to move a double word value.  */\n-\n-const char *\n-i960_output_move_double (dst, src)\n-     rtx dst, src;\n-{\n-  rtx operands[5];\n-\n-  if (GET_CODE (dst) == REG\n-      && GET_CODE (src) == REG)\n-    {\n-      if ((REGNO (src) & 1)\n-\t  || (REGNO (dst) & 1))\n-\t{\n-\t  /* We normally copy the low-numbered register first.  However, if\n-\t     the second source register is the same as the first destination\n-\t     register, we must copy in the opposite order.  */\n-\t  if (REGNO (src) + 1 == REGNO (dst))\n-\t    return \"mov\t%D1,%D0\\n\\tmov\t%1,%0\";\n-\t  else\n-\t    return \"mov\t%1,%0\\n\\tmov\t%D1,%D0\";\n-\t}\n-      else\n-\treturn \"movl\t%1,%0\";\n-    }\n-  else if (GET_CODE (dst) == REG\n-\t   && GET_CODE (src) == CONST_INT\n-\t   && CONST_OK_FOR_LETTER_P (INTVAL (src), 'I'))\n-    {\n-      if (REGNO (dst) & 1)\n-\treturn \"mov\t%1,%0\\n\\tmov\t0,%D0\";\n-      else\n-\treturn \"movl\t%1,%0\";\n-    }\n-  else if (GET_CODE (dst) == REG\n-\t   && GET_CODE (src) == MEM)\n-    {\n-      if (REGNO (dst) & 1)\n-\t{\n-\t  /* One can optimize a few cases here, but you have to be\n-\t     careful of clobbering registers used in the address and\n-\t     edge conditions.  */\n-\t  operands[0] = dst;\n-\t  operands[1] = src;\n-\t  operands[2] = gen_rtx_REG (Pmode, REGNO (dst) + 1);\n-\t  operands[3] = gen_rtx_MEM (word_mode, operands[2]);\n-\t  operands[4] = adjust_address (operands[3], word_mode,\n-\t\t\t\t\tUNITS_PER_WORD);\n-\t  output_asm_insn\n-\t    (\"lda\t%1,%2\\n\\tld\t%3,%0\\n\\tld\t%4,%D0\", operands);\n-\t  return \"\";\n-\t}\n-      else\n-\treturn \"ldl\t%1,%0\";\n-    }\n-  else if (GET_CODE (dst) == MEM\n-\t   && GET_CODE (src) == REG)\n-    {\n-      if (REGNO (src) & 1)\n-\t{\n-\t  operands[0] = dst;\n-\t  operands[1] = adjust_address (dst, word_mode, UNITS_PER_WORD);\n-\t  if (! memory_address_p (word_mode, XEXP (operands[1], 0)))\n-\t    abort ();\n-\t  operands[2] = src;\n-\t  output_asm_insn (\"st\t%2,%0\\n\\tst\t%D2,%1\", operands);\n-\t  return \"\";\n-\t}\n-      return \"stl\t%1,%0\";\n-    }\n-  else\n-    abort ();\n-}\n-\n-/* Output assembler to move a double word zero.  */\n-\n-const char *\n-i960_output_move_double_zero (dst)\n-     rtx dst;\n-{\n-  rtx operands[2];\n-\n-  operands[0] = dst;\n-    {\n-      operands[1] = adjust_address (dst, word_mode, 4);\n-      output_asm_insn (\"st\tg14,%0\\n\\tst\tg14,%1\", operands);\n-    }\n-  return \"\";\n-}\n-\n-/* Output assembler to move a quad word value.  */\n-\n-const char *\n-i960_output_move_quad (dst, src)\n-     rtx dst, src;\n-{\n-  rtx operands[7];\n-\n-  if (GET_CODE (dst) == REG\n-      && GET_CODE (src) == REG)\n-    {\n-      if ((REGNO (src) & 3)\n-\t  || (REGNO (dst) & 3))\n-\t{\n-\t  /* We normally copy starting with the low numbered register.\n-\t     However, if there is an overlap such that the first dest reg\n-\t     is <= the last source reg but not < the first source reg, we\n-\t     must copy in the opposite order.  */\n-\t  if (REGNO (dst) <= REGNO (src) + 3\n-\t      && REGNO (dst) >= REGNO (src))\n-\t    return \"mov\t%F1,%F0\\n\\tmov\t%E1,%E0\\n\\tmov\t%D1,%D0\\n\\tmov\t%1,%0\";\n-\t  else\n-\t    return \"mov\t%1,%0\\n\\tmov\t%D1,%D0\\n\\tmov\t%E1,%E0\\n\\tmov\t%F1,%F0\";\n-\t}\n-      else\n-\treturn \"movq\t%1,%0\";\n-    }\n-  else if (GET_CODE (dst) == REG\n-\t   && GET_CODE (src) == CONST_INT\n-\t   && CONST_OK_FOR_LETTER_P (INTVAL (src), 'I'))\n-    {\n-      if (REGNO (dst) & 3)\n-\treturn \"mov\t%1,%0\\n\\tmov\t0,%D0\\n\\tmov\t0,%E0\\n\\tmov\t0,%F0\";\n-      else\n-\treturn \"movq\t%1,%0\";\n-    }\n-  else if (GET_CODE (dst) == REG\n-\t   && GET_CODE (src) == MEM)\n-    {\n-      if (REGNO (dst) & 3)\n-\t{\n-\t  /* One can optimize a few cases here, but you have to be\n-\t     careful of clobbering registers used in the address and\n-\t     edge conditions.  */\n-\t  operands[0] = dst;\n-\t  operands[1] = src;\n-\t  operands[2] = gen_rtx_REG (Pmode, REGNO (dst) + 3);\n-\t  operands[3] = gen_rtx_MEM (word_mode, operands[2]);\n-\t  operands[4]\n-\t    = adjust_address (operands[3], word_mode, UNITS_PER_WORD);\n-\t  operands[5]\n-\t    = adjust_address (operands[4], word_mode, UNITS_PER_WORD);\n-\t  operands[6]\n-\t    = adjust_address (operands[5], word_mode, UNITS_PER_WORD);\n-\t  output_asm_insn (\"lda\t%1,%2\\n\\tld\t%3,%0\\n\\tld\t%4,%D0\\n\\tld\t%5,%E0\\n\\tld\t%6,%F0\", operands);\n-\t  return \"\";\n-\t}\n-      else\n-\treturn \"ldq\t%1,%0\";\n-    }\n-  else if (GET_CODE (dst) == MEM\n-\t   && GET_CODE (src) == REG)\n-    {\n-      if (REGNO (src) & 3)\n-\t{\n-\t  operands[0] = dst;\n-\t  operands[1] = adjust_address (dst, word_mode, UNITS_PER_WORD);\n-\t  operands[2] = adjust_address (dst, word_mode, 2 * UNITS_PER_WORD);\n-\t  operands[3] = adjust_address (dst, word_mode, 3 * UNITS_PER_WORD);\n-\t  if (! memory_address_p (word_mode, XEXP (operands[3], 0)))\n-\t    abort ();\n-\t  operands[4] = src;\n-\t  output_asm_insn (\"st\t%4,%0\\n\\tst\t%D4,%1\\n\\tst\t%E4,%2\\n\\tst\t%F4,%3\", operands);\n-\t  return \"\";\n-\t}\n-      return \"stq\t%1,%0\";\n-    }\n-  else\n-    abort ();\n-}\n-\n-/* Output assembler to move a quad word zero.  */\n-\n-const char *\n-i960_output_move_quad_zero (dst)\n-     rtx dst;\n-{\n-  rtx operands[4];\n-\n-  operands[0] = dst;\n-    {\n-      operands[1] = adjust_address (dst, word_mode, 4);\n-      operands[2] = adjust_address (dst, word_mode, 8);\n-      operands[3] = adjust_address (dst, word_mode, 12);\n-      output_asm_insn (\"st\tg14,%0\\n\\tst\tg14,%1\\n\\tst\tg14,%2\\n\\tst\tg14,%3\", operands);\n-    }\n-  return \"\";\n-}\n-\n-\f\n-/* Emit insns to load a constant to non-floating point registers.\n-   Uses several strategies to try to use as few insns as possible.  */\n-\n-const char *\n-i960_output_ldconst (dst, src)\n-     register rtx dst, src;\n-{\n-  register int rsrc1;\n-  register unsigned rsrc2;\n-  enum machine_mode mode = GET_MODE (dst);\n-  rtx operands[4];\n-\n-  operands[0] = operands[2] = dst;\n-  operands[1] = operands[3] = src;\n-\n-  /* Anything that isn't a compile time constant, such as a SYMBOL_REF,\n-     must be a ldconst insn.  */\n-\n-  if (GET_CODE (src) != CONST_INT && GET_CODE (src) != CONST_DOUBLE)\n-    {\n-      output_asm_insn (\"ldconst\t%1,%0\", operands);\n-      return \"\";\n-    }\n-  else if (mode == TFmode)\n-    {\n-      REAL_VALUE_TYPE d;\n-      long value_long[3];\n-      int i;\n-\n-      if (fp_literal_zero (src, TFmode))\n-\treturn \"movt\t0,%0\";\n-\n-      REAL_VALUE_FROM_CONST_DOUBLE (d, src);\n-      REAL_VALUE_TO_TARGET_LONG_DOUBLE (d, value_long);\n-\n-      output_asm_insn (\"# ldconst\t%1,%0\",operands);\n-\n-      for (i = 0; i < 3; i++)\n-\t{\n-\t  operands[0] = gen_rtx_REG (SImode, REGNO (dst) + i);\n-\t  operands[1] = GEN_INT (value_long[i]);\n-\t  output_asm_insn (i960_output_ldconst (operands[0], operands[1]),\n-\t\t\t   operands);\n-\t}\n-\n-      return \"\"; \n-   }\n-  else if (mode == DFmode)\n-    {\n-      rtx first, second;\n-\n-      if (fp_literal_zero (src, DFmode))\n-\treturn \"movl\t0,%0\";\n-\n-      split_double (src, &first, &second);\n-\n-      output_asm_insn (\"# ldconst\t%1,%0\",operands);\n-\n-      operands[0] = gen_rtx_REG (SImode, REGNO (dst));\n-      operands[1] = first;\n-      output_asm_insn (i960_output_ldconst (operands[0], operands[1]),\n-\t\t      operands);\n-      operands[0] = gen_rtx_REG (SImode, REGNO (dst) + 1);\n-      operands[1] = second;\n-      output_asm_insn (i960_output_ldconst (operands[0], operands[1]),\n-\t\t      operands);\n-      return \"\";\n-    }\n-  else if (mode == SFmode)\n-    {\n-      REAL_VALUE_TYPE d;\n-      long value;\n-\n-      REAL_VALUE_FROM_CONST_DOUBLE (d, src);\n-      REAL_VALUE_TO_TARGET_SINGLE (d, value);\n-\n-      output_asm_insn (\"# ldconst\t%1,%0\",operands);\n-      operands[0] = gen_rtx_REG (SImode, REGNO (dst));\n-      operands[1] = GEN_INT (value);\n-      output_asm_insn (i960_output_ldconst (operands[0], operands[1]),\n-\t\t      operands);\n-      return \"\";\n-    }\n-  else if (mode == TImode)\n-    {\n-      /* ??? This is currently not handled at all.  */\n-      abort ();\n-\n-      /* Note: lowest order word goes in lowest numbered reg.  */\n-      rsrc1 = INTVAL (src);\n-      if (rsrc1 >= 0 && rsrc1 < 32)\n-\treturn \"movq\t%1,%0\";\n-      else\n-\toutput_asm_insn (\"movq\\t0,%0\\t# ldconstq %1,%0\",operands);\n-      /* Go pick up the low-order word.  */\n-    }\n-  else if (mode == DImode)\n-    {\n-      rtx upperhalf, lowerhalf, xoperands[2];\n-\n-      if (GET_CODE (src) == CONST_DOUBLE || GET_CODE (src) == CONST_INT)\n- \tsplit_double (src, &lowerhalf, &upperhalf);\n-\n-      else\n-\tabort ();\n-\n-      /* Note: lowest order word goes in lowest numbered reg.  */\n-      /* Numbers from 0 to 31 can be handled with a single insn.  */\n-      rsrc1 = INTVAL (lowerhalf);\n-      if (upperhalf == const0_rtx && rsrc1 >= 0 && rsrc1 < 32)\n-\treturn \"movl\t%1,%0\";\n-\n-      /* Output the upper half with a recursive call.  */\n-      xoperands[0] = gen_rtx_REG (SImode, REGNO (dst) + 1);\n-      xoperands[1] = upperhalf;\n-      output_asm_insn (i960_output_ldconst (xoperands[0], xoperands[1]),\n-\t\t       xoperands);\n-      /* The lower word is emitted as normally.  */\n-    }\n-  else\n-    {\n-      rsrc1 = INTVAL (src);\n-      if (mode == QImode)\n-\t{\n-\t  if (rsrc1 > 0xff)\n-\t    rsrc1 &= 0xff;\n-\t}\n-      else if (mode == HImode)\n-\t{\n-\t  if (rsrc1 > 0xffff)\n-\t    rsrc1 &= 0xffff;\n-\t}\n-    }\n-\n-  if (rsrc1 >= 0)\n-    {\n-      /* ldconst\t0..31,X\t\t-> \tmov\t0..31,X  */\n-      if (rsrc1 < 32)\n-\t{\n-\t  if (i960_last_insn_type == I_TYPE_REG && TARGET_C_SERIES)\n-\t    return \"lda\t%1,%0\";\n-\t  return \"mov\t%1,%0\";\n-\t}\n-\n-      /* ldconst\t32..63,X\t->\tadd\t31,nn,X  */\n-      if (rsrc1 < 63)\n-\t{\n-\t  if (i960_last_insn_type == I_TYPE_REG && TARGET_C_SERIES)\n-\t    return \"lda\t%1,%0\";\n-\t  operands[1] = GEN_INT (rsrc1 - 31);\n-\t  output_asm_insn (\"addo\\t31,%1,%0\\t# ldconst %3,%0\", operands);\n-\t  return \"\";\n-\t}\n-    }\n-  else if (rsrc1 < 0)\n-    {\n-      /* ldconst\t-1..-31\t\t->\tsub\t0,0..31,X  */\n-      if (rsrc1 >= -31)\n-\t{\n-\t  /* return 'sub -(%1),0,%0' */\n-\t  operands[1] = GEN_INT (- rsrc1);\n-\t  output_asm_insn (\"subo\\t%1,0,%0\\t# ldconst %3,%0\", operands);\n-\t  return \"\";\n-\t}\n-      \n-      /* ldconst\t-32\t\t->\tnot\t31,X  */\n-      if (rsrc1 == -32)\n-\t{\n-\t  operands[1] = GEN_INT (~rsrc1);\n-\t  output_asm_insn (\"not\\t%1,%0\t# ldconst %3,%0\", operands);\n-\t  return \"\";\n-\t}\n-    }\n-\n-  /* If const is a single bit.  */\n-  if (bitpos (rsrc1) >= 0)\n-    {\n-      operands[1] = GEN_INT (bitpos (rsrc1));\n-      output_asm_insn (\"setbit\\t%1,0,%0\\t# ldconst %3,%0\", operands);\n-      return \"\";\n-    }\n-\n-  /* If const is a bit string of less than 6 bits (1..31 shifted).  */\n-  if (is_mask (rsrc1))\n-    {\n-      int s, e;\n-\n-      if (bitstr (rsrc1, &s, &e) < 6)\n-\t{\n-\t  rsrc2 = ((unsigned int) rsrc1) >> s;\n-\t  operands[1] = GEN_INT (rsrc2);\n-\t  operands[2] = GEN_INT (s);\n-\t  output_asm_insn (\"shlo\\t%2,%1,%0\\t# ldconst %3,%0\", operands);\n-\t  return \"\";\n-\t}\n-    }\n-\n-  /* Unimplemented cases:\n-     const is in range 0..31 but rotated around end of word:\n-     ror\t31,3,g0\t-> ldconst 0xe0000003,g0\n-   \n-     and any 2 instruction cases that might be worthwhile  */\n-  \n-  output_asm_insn (\"ldconst\t%1,%0\", operands);\n-  return \"\";\n-}\n-\n-/* Determine if there is an opportunity for a bypass optimization.\n-   Bypass succeeds on the 960K* if the destination of the previous\n-   instruction is the second operand of the current instruction.\n-   Bypass always succeeds on the C*.\n- \n-   Return 1 if the pattern should interchange the operands.\n-\n-   CMPBR_FLAG is true if this is for a compare-and-branch insn.\n-   OP1 and OP2 are the two source operands of a 3 operand insn.  */\n-\n-int\n-i960_bypass (insn, op1, op2, cmpbr_flag)\n-     register rtx insn, op1, op2;\n-     int cmpbr_flag;\n-{\n-  register rtx prev_insn, prev_dest;\n-\n-  if (TARGET_C_SERIES)\n-    return 0;\n-\n-  /* Can't do this if op1 isn't a register.  */\n-  if (! REG_P (op1))\n-    return 0;\n-\n-  /* Can't do this for a compare-and-branch if both ops aren't regs.  */\n-  if (cmpbr_flag && ! REG_P (op2))\n-    return 0;\n-\n-  prev_insn = prev_real_insn (insn);\n-\n-  if (prev_insn && GET_CODE (prev_insn) == INSN\n-      && GET_CODE (PATTERN (prev_insn)) == SET)\n-    {\n-      prev_dest = SET_DEST (PATTERN (prev_insn));\n-      if ((GET_CODE (prev_dest) == REG && REGNO (prev_dest) == REGNO (op1))\n-\t  || (GET_CODE (prev_dest) == SUBREG\n-\t      && GET_CODE (SUBREG_REG (prev_dest)) == REG\n-\t      && REGNO (SUBREG_REG (prev_dest)) == REGNO (op1)))\n-\treturn 1;\n-    }\n-  return 0;\n-}\n-\f\n-/* Output the code which declares the function name.  This also handles\n-   leaf routines, which have special requirements, and initializes some\n-   global variables.  */\n-\n-void\n-i960_function_name_declare (file, name, fndecl)\n-     FILE *file;\n-     const char *name;\n-     tree fndecl;\n-{\n-  register int i, j;\n-  int leaf_proc_ok;\n-  rtx insn;\n-\n-  /* Increment global return label.  */\n-\n-  ret_label++;\n-\n-  /* Compute whether tail calls and leaf routine optimizations can be performed\n-     for this function.  */\n-\n-  if (TARGET_TAILCALL)\n-    tail_call_ok = 1;\n-  else\n-    tail_call_ok = 0;\n-\n-  if (TARGET_LEAFPROC)\n-    leaf_proc_ok = 1;\n-  else\n-    leaf_proc_ok = 0;\n-\n-  /* Even if nobody uses extra parms, can't have leafproc or tail calls if\n-     argblock, because argblock uses g14 implicitly.  */\n-\n-  if (current_function_args_size != 0 || VARARGS_STDARG_FUNCTION (fndecl))\n-    {\n-      tail_call_ok = 0;\n-      leaf_proc_ok = 0;\n-    }\n-      \n-  /* See if caller passes in an address to return value.  */\n-\n-  if (aggregate_value_p (DECL_RESULT (fndecl), fndecl))\n-    {\n-      tail_call_ok = 0;\n-      leaf_proc_ok = 0;\n-    }\n-\n-  /* Can not use tail calls or make this a leaf routine if there is a non\n-     zero frame size.  */\n-\n-  if (get_frame_size () != 0)\n-    leaf_proc_ok = 0;\n-\n-  /* I don't understand this condition, and do not think that it is correct.\n-     Apparently this is just checking whether the frame pointer is used, and\n-     we can't trust regs_ever_live[fp] since it is (almost?) always set.  */\n-\n-  if (tail_call_ok)\n-    for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n-      if (GET_CODE (insn) == INSN\n-\t  && reg_mentioned_p (frame_pointer_rtx, insn))\n-\t{\n-\t  tail_call_ok = 0;\n-\t  break;\n-\t}\n-\n-  /* Check for CALL insns.  Can not be a leaf routine if there are any.  */\n-\n-  if (leaf_proc_ok)\n-    for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n-      if (GET_CODE (insn) == CALL_INSN)\n-\t{\n-\t  leaf_proc_ok = 0;\n-\t  break;\n-\t}\n-\n-  /* Can not be a leaf routine if any non-call clobbered registers are\n-     used in this function.  */\n-\n-  if (leaf_proc_ok)\n-    for (i = 0, j = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-      if (regs_ever_live[i]\n-\t  && ((! call_used_regs[i]) || (i > 7 && i < 12)))\n-\t{\n-\t  /* Global registers.  */\n-\t  if (i < 16 && i > 7 && i != 13)\n-\t    leaf_proc_ok = 0;\n-\t  /* Local registers.  */\n-\t  else if (i < 32)\n-\t    leaf_proc_ok = 0;\n-\t}\n-\n-  /* Now choose a leaf return register, if we can find one, and if it is\n-     OK for this to be a leaf routine.  */\n-\n-  i960_leaf_ret_reg = -1;\n-\n-  if (optimize && leaf_proc_ok)\n-    {\n-      for (i960_leaf_ret_reg = -1, i = 0; i < 8; i++)\n-\tif (regs_ever_live[i] == 0)\n-\t  {\n-\t    i960_leaf_ret_reg = i;\n-\t    regs_ever_live[i] = 1;\n-\t    break;\n-\t  }\n-    }\n-\n-  /* Do this after choosing the leaf return register, so it will be listed\n-     if one was chosen.  */\n-\n-  fprintf (file, \"\\t#  Function '%s'\\n\", (name[0] == '*' ? &name[1] : name));\n-  fprintf (file, \"\\t#  Registers used: \");\n-\n-  for (i = 0, j = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    {\n-      if (regs_ever_live[i])\n-\t{\n-\t  fprintf (file, \"%s%s \", reg_names[i], call_used_regs[i] ? \"\" : \"*\");\n-\n-\t  if (i > 15 && j == 0)\n-\t    {\n-\t      fprintf (file,\"\\n\\t#\\t\\t   \");\n-\t      j++;\n-            }\n-        }\n-    }\n-\n-  fprintf (file, \"\\n\");\n-\n-  if (i960_leaf_ret_reg >= 0)\n-    {\n-      /* Make it a leaf procedure.  */\n-\n-      if (TREE_PUBLIC (fndecl))\n-\tfprintf (file,\"\\t.globl\\t%s.lf\\n\", (name[0] == '*' ? &name[1] : name));\n-\n-      fprintf (file, \"\\t.leafproc\\t\");\n-      assemble_name (file, name);\n-      fprintf (file, \",%s.lf\\n\", (name[0] == '*' ? &name[1] : name));\n-      ASM_OUTPUT_LABEL (file, name);\n-      fprintf (file, \"\\tlda    Li960R%d,g14\\n\", ret_label);\n-      fprintf (file, \"%s.lf:\\n\", (name[0] == '*' ? &name[1] : name));\n-      fprintf (file, \"\\tmov    g14,g%d\\n\", i960_leaf_ret_reg);\n-\n-      if (TARGET_C_SERIES)\n-\t{\n-\t  fprintf (file, \"\\tlda    0,g14\\n\");\n-\t  i960_last_insn_type = I_TYPE_MEM;\n-\t}\n-      else\n-\t{\n-\t  fprintf (file, \"\\tmov    0,g14\\n\");\n-\t  i960_last_insn_type = I_TYPE_REG;\n-\t}\n-    }\n-  else\n-    {\n-      ASM_OUTPUT_LABEL (file, name);\n-      i960_last_insn_type = I_TYPE_CTRL; \n-    }\n-}\n-\f\n-/* Compute and return the frame size.  */\n-\n-int\n-compute_frame_size (size)\n-     int size;\n-{\n-  int actual_fsize;\n-  int outgoing_args_size = current_function_outgoing_args_size;\n-\n-  /* The STARTING_FRAME_OFFSET is totally hidden to us as far\n-     as size is concerned.  */\n-  actual_fsize = (size + 15) & -16;\n-  actual_fsize += (outgoing_args_size + 15) & -16;\n-\n-  return actual_fsize;\n-}\n-\n-/* Here register group is range of registers which can be moved by\n-   one i960 instruction.  */\n-\n-struct reg_group\n-{\n-  char start_reg;\n-  char length;\n-};\n-\n-static int i960_form_reg_groups (int, int, int *, int, struct reg_group *);\n-static int i960_reg_group_compare (const void *, const void *);\n-static int i960_split_reg_group (struct reg_group *, int, int);\n-static void i960_arg_size_and_align (enum machine_mode, tree, int *, int *);\n-\n-/* The following functions forms the biggest as possible register\n-   groups with registers in STATE.  REGS contain states of the\n-   registers in range [start, finish_reg).  The function returns the\n-   number of groups formed.  */\n-static int\n-i960_form_reg_groups (start_reg, finish_reg, regs, state, reg_groups)\n-     int start_reg;\n-     int finish_reg;\n-     int *regs;\n-     int state;\n-     struct reg_group *reg_groups;\n-{\n-  int i;\n-  int nw = 0;\n-\n-  for (i = start_reg; i < finish_reg; )\n-    {\n-      if (regs [i] != state)\n-\t{\n-\t  i++;\n-\t  continue;\n-\t}\n-      else if (i % 2 != 0 || regs [i + 1] != state)\n-\treg_groups [nw].length = 1;\n-      else if (i % 4 != 0 || regs [i + 2] != state)\n-\treg_groups [nw].length = 2;\n-      else if (regs [i + 3] != state)\n-\treg_groups [nw].length = 3;\n-      else\n-\treg_groups [nw].length = 4;\n-      reg_groups [nw].start_reg = i;\n-      i += reg_groups [nw].length;\n-      nw++;\n-    }\n-  return nw;\n-}\n-\n-/* We sort register winodws in descending order by length.  */\n-static int\n-i960_reg_group_compare (group1, group2)\n-     const void *group1;\n-     const void *group2;\n-{\n-  const struct reg_group *w1 = group1;\n-  const struct reg_group *w2 = group2;\n-\n-  if (w1->length > w2->length)\n-    return -1;\n-  else if (w1->length < w2->length)\n-    return 1;\n-  else\n-    return 0;\n-}\n-\n-/* Split the first register group in REG_GROUPS on subgroups one of\n-   which will contain SUBGROUP_LENGTH registers.  The function\n-   returns new number of winodws.  */\n-static int\n-i960_split_reg_group (reg_groups, nw, subgroup_length)\n-     struct reg_group *reg_groups;\n-     int nw;\n-     int subgroup_length;\n-{\n-  if (subgroup_length < reg_groups->length - subgroup_length)\n-    /* This guarantees correct alignments of the two subgroups for\n-       i960 (see spliting for the group length 2, 3, 4).  More\n-       generalized algorithm would require splitting the group more\n-       two subgroups.  */\n-    subgroup_length = reg_groups->length - subgroup_length;\n-  /* More generalized algorithm would require to try merging\n-     subgroups here.  But in case i960 it always results in failure\n-     because of register group alignment.  */\n-  reg_groups[nw].length = reg_groups->length - subgroup_length;\n-  reg_groups[nw].start_reg = reg_groups->start_reg + subgroup_length;\n-  nw++;\n-  reg_groups->length = subgroup_length;\n-  qsort (reg_groups, nw, sizeof (struct reg_group), i960_reg_group_compare);\n-  return nw;\n-}\n-\n-/* Output code for the function prologue.  */\n-\n-static void\n-i960_output_function_prologue (file, size)\n-     FILE *file;\n-     HOST_WIDE_INT size;\n-{\n-  register int i, j, nr;\n-  int n_saved_regs = 0;\n-  int n_remaining_saved_regs;\n-  HOST_WIDE_INT lvar_size;\n-  HOST_WIDE_INT actual_fsize, offset;\n-  int gnw, lnw;\n-  struct reg_group *g, *l;\n-  char tmpstr[1000];\n-  /* -1 if reg must be saved on proc entry, 0 if available, 1 if saved\n-     somewhere.  */\n-  int regs[FIRST_PSEUDO_REGISTER];\n-  /* All global registers (which must be saved) divided by groups.  */\n-  struct reg_group global_reg_groups [16];\n-  /* All local registers (which are available) divided by groups.  */\n-  struct reg_group local_reg_groups [16];\n-\n-\n-  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    if (regs_ever_live[i]\n-\t&& ((! call_used_regs[i]) || (i > 7 && i < 12))\n-\t/* No need to save the static chain pointer.  */\n-\t&& ! (i == STATIC_CHAIN_REGNUM && current_function_needs_context))\n-      {\n-\tregs[i] = -1;\n-        /* Count global registers that need saving.  */\n-\tif (i < 16)\n-\t  n_saved_regs++;\n-      }\n-    else\n-      regs[i] = 0;\n-\n-  n_remaining_saved_regs = n_saved_regs;\n-\n-  epilogue_string[0] = '\\0';\n-\n-  if (current_function_profile)\n-    {\n-      /* When profiling, we may use registers 20 to 27 to save arguments, so\n-\t they can't be used here for saving globals.  J is the number of\n-\t argument registers the mcount call will save.  */\n-      for (j = 7; j >= 0 && ! regs_ever_live[j]; j--)\n-\t;\n-\n-      for (i = 20; i <= j + 20; i++)\n-\tregs[i] = -1;\n-    }\n-\n-  gnw = i960_form_reg_groups (0, 16, regs, -1, global_reg_groups);\n-  lnw = i960_form_reg_groups (19, 32, regs, 0, local_reg_groups);\n-  qsort (global_reg_groups, gnw, sizeof (struct reg_group),\n-\t i960_reg_group_compare);\n-  qsort (local_reg_groups, lnw, sizeof (struct reg_group),\n-\t i960_reg_group_compare);\n-  for (g = global_reg_groups, l = local_reg_groups; lnw != 0 && gnw != 0;)\n-    {\n-      if (g->length == l->length)\n-\t{\n-\t  fprintf (file, \"\\tmov%s\t%s,%s\\n\",\n-\t\t   ((g->length == 4) ? \"q\" :\n-\t\t    (g->length == 3) ? \"t\" :\n-\t\t    (g->length == 2) ? \"l\" : \"\"),\n-\t\t   reg_names[(unsigned char) g->start_reg],\n-\t\t   reg_names[(unsigned char) l->start_reg]);\n-\t  sprintf (tmpstr, \"\\tmov%s\t%s,%s\\n\",\n-\t\t   ((g->length == 4) ? \"q\" :\n-\t\t    (g->length == 3) ? \"t\" :\n-\t\t    (g->length == 2) ? \"l\" : \"\"),\n-\t\t   reg_names[(unsigned char) l->start_reg],\n-\t\t   reg_names[(unsigned char) g->start_reg]);\n-\t  strcat (epilogue_string, tmpstr);\n-\t  n_remaining_saved_regs -= g->length;\n-\t  for (i = 0; i < g->length; i++)\n-\t    {\n-\t      regs [i + g->start_reg] = 1;\n-\t      regs [i + l->start_reg] = -1;\n-\t      regs_ever_live [i + l->start_reg] = 1;\n-\t    }\n-\t  g++;\n-\t  l++;\n-\t  gnw--;\n-\t  lnw--;\n-\t}\n-      else if (g->length > l->length)\n-\tgnw = i960_split_reg_group (g, gnw, l->length);\n-      else\n-\tlnw = i960_split_reg_group (l, lnw, g->length);\n-    }\n-\n-  actual_fsize = compute_frame_size (size) + 4 * n_remaining_saved_regs;\n-#if 0\n-  /* ??? The 1.2.1 compiler does this also.  This is meant to round the frame\n-     size up to the nearest multiple of 16.  I don't know whether this is\n-     necessary, or even desirable.\n-\n-     The frame pointer must be aligned, but the call instruction takes care of\n-     that.  If we leave the stack pointer unaligned, we may save a little on\n-     dynamic stack allocation.  And we don't lose, at least according to the\n-     i960CA manual.  */\n-  actual_fsize = (actual_fsize + 15) & ~0xF;\n-#endif\n-\n-  /* Check stack limit if necessary.  */\n-  if (current_function_limit_stack)\n-    {\n-      rtx min_stack = stack_limit_rtx;\n-      if (actual_fsize != 0)\n-\tmin_stack = plus_constant (stack_limit_rtx, -actual_fsize);\n-\n-      /* Now, emulate a little bit of reload.  We want to turn 'min_stack'\n-\t into an arith_operand.  Use register 20 as the temporary.  */\n-      if (legitimate_address_p (Pmode, min_stack, 1) \n-\t  && !arith_operand (min_stack, Pmode))\n-\t{\n-\t  rtx tmp = gen_rtx_MEM (Pmode, min_stack);\n-\t  fputs (\"\\tlda\\t\", file);\n-\t  i960_print_operand (file, tmp, 0);\n-\t  fputs (\",r4\\n\", file);\n-\t  min_stack = gen_rtx_REG (Pmode, 20);\n-\t}\n-      if (arith_operand (min_stack, Pmode))\n-\t{\n-\t  fputs (\"\\tcmpo\\tsp,\", file);\n-\t  i960_print_operand (file, min_stack, 0);\n-\t  fputs (\"\\n\\tfaultge.f\\n\", file);\n-\t}\n-      else\n-\twarning (\"stack limit expression is not supported\");\n-    }\n-\n-  /* Allocate space for register save and locals.  */\n-  if (actual_fsize > 0)\n-    {\n-      if (actual_fsize < 32)\n-\tfprintf (file, \"\\taddo\t\" HOST_WIDE_INT_PRINT_DEC \",sp,sp\\n\",\n-\t\t actual_fsize);\n-      else\n-\tfprintf (file, \"\\tlda\\t\" HOST_WIDE_INT_PRINT_DEC \"(sp),sp\\n\",\n-\t\t actual_fsize);\n-    }\n-\n-  /* Take hardware register save area created by the call instruction\n-     into account, but store them before the argument block area.  */\n-  lvar_size = actual_fsize - compute_frame_size (0) - n_remaining_saved_regs * 4;\n-  offset = STARTING_FRAME_OFFSET + lvar_size;\n-  /* Save registers on stack if needed.  */\n-  /* ??? Is it worth to use the same algorithm as one for saving\n-     global registers in local registers? */\n-  for (i = 0, j = n_remaining_saved_regs; j > 0 && i < 16; i++)\n-    {\n-      if (regs[i] != -1)\n-\tcontinue;\n-\n-      nr = 1;\n-\n-      if (i <= 14 && i % 2 == 0 && regs[i+1] == -1 && offset % 2 == 0)\n-\tnr = 2;\n-\n-      if (nr == 2 && i <= 12 && i % 4 == 0 && regs[i+2] == -1\n-\t  && offset % 4 == 0)\n-\tnr = 3;\n-\n-      if (nr == 3 && regs[i+3] == -1)\n-\tnr = 4;\n-\n-      fprintf (file,\"\\tst%s\t%s,\" HOST_WIDE_INT_PRINT_DEC \"(fp)\\n\",\n-\t       ((nr == 4) ? \"q\" :\n-\t\t(nr == 3) ? \"t\" :\n-\t\t(nr == 2) ? \"l\" : \"\"),\n-\t       reg_names[i], offset);\n-      sprintf (tmpstr,\"\\tld%s\t\" HOST_WIDE_INT_PRINT_DEC \"(fp),%s\\n\",\n-\t       ((nr == 4) ? \"q\" :\n-\t\t(nr == 3) ? \"t\" :\n-\t\t(nr == 2) ? \"l\" : \"\"),\n-\t       offset, reg_names[i]);\n-      strcat (epilogue_string, tmpstr);\n-      i += nr-1;\n-      j -= nr;\n-      offset += nr * 4;\n-    }\n-\n-  if (actual_fsize == 0)\n-    return;\n-\n-  fprintf (file, \"\\t#Prologue stats:\\n\");\n-  fprintf (file, \"\\t#  Total Frame Size: \" HOST_WIDE_INT_PRINT_DEC \" bytes\\n\",\n-\t   actual_fsize);\n-\n-  if (lvar_size)\n-    fprintf (file, \"\\t#  Local Variable Size: \" HOST_WIDE_INT_PRINT_DEC\n-\t     \" bytes\\n\", lvar_size);\n-  if (n_saved_regs)\n-    fprintf (file, \"\\t#  Register Save Size: %d regs, %d bytes\\n\",\n-\t     n_saved_regs, n_saved_regs * 4);\n-  fprintf (file, \"\\t#End Prologue#\\n\");\n-}\n-\n-/* Output code for the function profiler.  */\n-\n-void\n-output_function_profiler (file, labelno)\n-     FILE *file;\n-     int labelno;\n-{\n-  /* The last used parameter register.  */\n-  int last_parm_reg;\n-  int i, j, increment;\n-  int varargs_stdarg_function\n-    = VARARGS_STDARG_FUNCTION (current_function_decl);\n-\n-  /* Figure out the last used parameter register.  The proper thing to do\n-     is to walk incoming args of the function.  A function might have live\n-     parameter registers even if it has no incoming args.  Note that we\n-     don't have to save parameter registers g8 to g11 because they are\n-     call preserved.  */\n-\n-  /* See also output_function_prologue, which tries to use local registers\n-     for preserved call-saved global registers.  */\n-\n-  for (last_parm_reg = 7;\n-       last_parm_reg >= 0 && ! regs_ever_live[last_parm_reg];\n-       last_parm_reg--)\n-    ;\n-\n-  /* Save parameter registers in regs r4 (20) to r11 (27).  */\n-\n-  for (i = 0, j = 4; i <= last_parm_reg; i += increment, j += increment)\n-    {\n-      if (i % 4 == 0 && (last_parm_reg - i) >= 3)\n-\tincrement = 4;\n-      else if (i % 4 == 0 && (last_parm_reg - i) >= 2)\n-\tincrement = 3;\n-      else if (i % 2 == 0 && (last_parm_reg - i) >= 1)\n-\tincrement = 2;\n-      else\n-\tincrement = 1;\n-\n-      fprintf (file, \"\\tmov%s\tg%d,r%d\\n\",\n-\t       (increment == 4 ? \"q\" : increment == 3 ? \"t\"\n-\t\t: increment == 2 ? \"l\": \"\"), i, j);\n-      }\n-\n-  /* If this function uses the arg pointer, then save it in r3 and then\n-     set it to zero.  */\n-\n-  if (current_function_args_size != 0 || varargs_stdarg_function)\n-    fprintf (file, \"\\tmov\tg14,r3\\n\\tmov\t0,g14\\n\");\n-\n-  /* Load location address into g0 and call mcount.  */\n-\n-  fprintf (file, \"\\tlda\\tLP%d,g0\\n\\tcallx\\tmcount\\n\", labelno);\n-\n-  /* If this function uses the arg pointer, restore it.  */\n-\n-  if (current_function_args_size != 0 || varargs_stdarg_function)\n-    fprintf (file, \"\\tmov\tr3,g14\\n\");\n-\n-  /* Restore parameter registers.  */\n-\n-  for (i = 0, j = 4; i <= last_parm_reg; i += increment, j += increment)\n-    {\n-      if (i % 4 == 0 && (last_parm_reg - i) >= 3)\n-\tincrement = 4;\n-      else if (i % 4 == 0 && (last_parm_reg - i) >= 2)\n-\tincrement = 3;\n-      else if (i % 2 == 0 && (last_parm_reg - i) >= 1)\n-\tincrement = 2;\n-      else\n-\tincrement = 1;\n-\n-      fprintf (file, \"\\tmov%s\tr%d,g%d\\n\",\n-\t       (increment == 4 ? \"q\" : increment == 3 ? \"t\"\n-\t\t: increment == 2 ? \"l\": \"\"), j, i);\n-    }\n-}\n-\n-/* Output code for the function epilogue.  */\n-\n-static void\n-i960_output_function_epilogue (file, size)\n-     FILE *file;\n-     HOST_WIDE_INT size ATTRIBUTE_UNUSED;\n-{\n-  if (i960_leaf_ret_reg >= 0)\n-    {\n-      fprintf (file, \"Li960R%d:\tret\\n\", ret_label);\n-      return;\n-    }\n-\n-  if (*epilogue_string == 0)\n-    {\n-      register rtx tmp;\n-\t\n-      /* Emit a return insn, but only if control can fall through to here.  */\n-\n-      tmp = get_last_insn ();\n-      while (tmp)\n-\t{\n-\t  if (GET_CODE (tmp) == BARRIER)\n-\t    return;\n-\t  if (GET_CODE (tmp) == CODE_LABEL)\n-\t    break;\n-\t  if (GET_CODE (tmp) == JUMP_INSN)\n-\t    {\n-\t      if (GET_CODE (PATTERN (tmp)) == RETURN)\n-\t\treturn;\n-\t      break;\n-\t    }\n-\t  if (GET_CODE (tmp) == NOTE)\n-\t    {\n-\t      tmp = PREV_INSN (tmp);\n-\t      continue;\n-\t    }\n-\t  break;\n-\t}\n-      fprintf (file, \"Li960R%d:\tret\\n\", ret_label);\n-      return;\n-    }\n-\n-  fprintf (file, \"Li960R%d:\\n\", ret_label);\n-\n-  fprintf (file, \"\\t#EPILOGUE#\\n\");\n-\n-  /* Output the string created by the prologue which will restore all\n-     registers saved by the prologue.  */\n-\n-  if (epilogue_string[0] != '\\0')\n-    fprintf (file, \"%s\", epilogue_string);\n-\n-  /* Must clear g14 on return if this function set it.\n-     Only varargs/stdarg functions modify g14.  */\n-\n-  if (VARARGS_STDARG_FUNCTION (current_function_decl))\n-    fprintf (file, \"\\tmov\t0,g14\\n\");\n-\n-  fprintf (file, \"\\tret\\n\");\n-  fprintf (file, \"\\t#End Epilogue#\\n\");\n-}\n-\n-/* Output code for a call insn.  */\n-\n-const char *\n-i960_output_call_insn (target, argsize_rtx, arg_pointer, insn)\n-     register rtx target, argsize_rtx, arg_pointer, insn;\n-{\n-  int argsize = INTVAL (argsize_rtx);\n-  rtx nexti = next_real_insn (insn);\n-  rtx operands[2];\n-  int varargs_stdarg_function\n-    = VARARGS_STDARG_FUNCTION (current_function_decl);\n-\n-  operands[0] = target;\n-  operands[1] = arg_pointer;\n-\n-  if (current_function_args_size != 0 || varargs_stdarg_function)\n-    output_asm_insn (\"mov\tg14,r3\", operands);\n-\n-  if (argsize > 48)\n-    output_asm_insn (\"lda\t%a1,g14\", operands);\n-  else if (current_function_args_size != 0 || varargs_stdarg_function)\n-    output_asm_insn (\"mov\t0,g14\", operands);\n-\n-  /* The code used to assume that calls to SYMBOL_REFs could not be more\n-     than 24 bits away (b vs bx, callj vs callx).  This is not true.  This\n-     feature is now implemented by relaxing in the GNU linker.  It can convert\n-     bx to b if in range, and callx to calls/call/balx/bal as appropriate.  */\n-\n-  /* Nexti could be zero if the called routine is volatile.  */\n-  if (optimize && (*epilogue_string == 0) && argsize == 0 && tail_call_ok \n-      && (nexti == 0 || GET_CODE (PATTERN (nexti)) == RETURN))\n-    {\n-      /* Delete following return insn.  */\n-      if (nexti && no_labels_between_p (insn, nexti))\n-\tdelete_insn (nexti);\n-      output_asm_insn (\"bx\t%0\", operands);\n-      return \"# notreached\";\n-    }\n-\n-  output_asm_insn (\"callx\t%0\", operands);\n-\n-  /* If the caller sets g14 to the address of the argblock, then the caller\n-     must clear it after the return.  */\n-\n-  if (current_function_args_size != 0 || varargs_stdarg_function)\n-    output_asm_insn (\"mov\tr3,g14\", operands);\n-  else if (argsize > 48)\n-    output_asm_insn (\"mov\t0,g14\", operands);\n-\n-  return \"\";\n-}\n-\n-/* Output code for a return insn.  */\n-\n-const char *\n-i960_output_ret_insn (insn)\n-     register rtx insn;\n-{\n-  static char lbuf[20];\n-  \n-  if (*epilogue_string != 0)\n-    {\n-      if (! TARGET_CODE_ALIGN && next_real_insn (insn) == 0)\n-\treturn \"\";\n-\n-      sprintf (lbuf, \"b\tLi960R%d\", ret_label);\n-      return lbuf;\n-    }\n-\n-  /* Must clear g14 on return if this function set it.\n-     Only varargs/stdarg functions modify g14.  */\n-\n-  if (VARARGS_STDARG_FUNCTION (current_function_decl))\n-    output_asm_insn (\"mov\t0,g14\", 0);\n-\n-  if (i960_leaf_ret_reg >= 0)\n-    {\n-      sprintf (lbuf, \"bx\t(%s)\", reg_names[i960_leaf_ret_reg]);\n-      return lbuf;\n-    }\n-  return \"ret\";\n-}\n-\f\n-/* Print the operand represented by rtx X formatted by code CODE.  */\n-\n-void\n-i960_print_operand (file, x, code)\n-     FILE *file;\n-     rtx x;\n-     int code;\n-{\n-  enum rtx_code rtxcode = x ? GET_CODE (x) : NIL;\n-\n-  if (rtxcode == REG)\n-    {\n-      switch (code)\n-\t{\n-\tcase 'D':\n-\t  /* Second reg of a double or quad.  */\n-\t  fprintf (file, \"%s\", reg_names[REGNO (x)+1]);\n-\t  break;\n-\n-\tcase 'E':\n-\t  /* Third reg of a quad.  */\n-\t  fprintf (file, \"%s\", reg_names[REGNO (x)+2]);\n-\t  break;\n-\n-\tcase 'F':\n-\t  /* Fourth reg of a quad.  */\n-\t  fprintf (file, \"%s\", reg_names[REGNO (x)+3]);\n-\t  break;\n-\n-\tcase 0:\n-\t  fprintf (file, \"%s\", reg_names[REGNO (x)]);\n-\t  break;\n-\n-\tdefault:\n-\t  abort ();\n-\t}\n-      return;\n-    }\n-  else if (rtxcode == MEM)\n-    {\n-      output_address (XEXP (x, 0));\n-      return;\n-    }\n-  else if (rtxcode == CONST_INT)\n-    {\n-      HOST_WIDE_INT val = INTVAL (x);\n-      if (code == 'C')\n-\tval = ~val;\n-      if (val > 9999 || val < -999)\n-\tfprintf (file, HOST_WIDE_INT_PRINT_HEX, val);\n-      else\n-\tfprintf (file, HOST_WIDE_INT_PRINT_DEC, val);\n-      return;\n-    }\n-  else if (rtxcode == CONST_DOUBLE)\n-    {\n-      char dstr[30];\n-\n-      if (x == CONST0_RTX (GET_MODE (x)))\n-\t{\n-\t  fprintf (file, \"0f0.0\");\n-\t  return;\n-\t}\n-      else if (x == CONST1_RTX (GET_MODE (x)))\n-\t{\n-\t  fprintf (file, \"0f1.0\");\n-\t  return;\n-\t}\n-\n-      real_to_decimal (dstr, CONST_DOUBLE_REAL_VALUE (x), sizeof (dstr), 0, 1);\n-      fprintf (file, \"0f%s\", dstr);\n-      return;\n-    }\n-\n-  switch(code)\n-    {\n-    case 'B':\n-      /* Branch or jump, depending on assembler.  */\n-      if (TARGET_ASM_COMPAT)\n-\tfputs (\"j\", file);\n-      else\n-\tfputs (\"b\", file);\n-      break;\n-\n-    case 'S':\n-      /* Sign of condition.  */\n-      if ((rtxcode == EQ) || (rtxcode == NE) || (rtxcode == GTU)\n-\t  || (rtxcode == LTU) || (rtxcode == GEU) || (rtxcode == LEU))\n-\tfputs (\"o\", file);\n-      else if ((rtxcode == GT) || (rtxcode == LT)\n-\t  || (rtxcode == GE) || (rtxcode == LE))\n-\tfputs (\"i\", file);\n-      else\n-\tabort();\n-      break;\n-\n-    case 'I':\n-      /* Inverted condition.  */\n-      rtxcode = reverse_condition (rtxcode);\n-      goto normal;\n-\n-    case 'X':\n-      /* Inverted condition w/ reversed operands.  */\n-      rtxcode = reverse_condition (rtxcode);\n-      /* Fallthrough.  */\n-\n-    case 'R':\n-      /* Reversed operand condition.  */\n-      rtxcode = swap_condition (rtxcode);\n-      /* Fallthrough.  */\n-\n-    case 'C':\n-      /* Normal condition.  */\n-    normal:\n-      if (rtxcode == EQ)  { fputs (\"e\", file); return; }\n-      else if (rtxcode == NE)  { fputs (\"ne\", file); return; }\n-      else if (rtxcode == GT)  { fputs (\"g\", file); return; }\n-      else if (rtxcode == GTU) { fputs (\"g\", file); return; }\n-      else if (rtxcode == LT)  { fputs (\"l\", file); return; }\n-      else if (rtxcode == LTU) { fputs (\"l\", file); return; }\n-      else if (rtxcode == GE)  { fputs (\"ge\", file); return; }\n-      else if (rtxcode == GEU) { fputs (\"ge\", file); return; }\n-      else if (rtxcode == LE)  { fputs (\"le\", file); return; }\n-      else if (rtxcode == LEU) { fputs (\"le\", file); return; }\n-      else abort ();\n-      break;\n-\n-    case '+':\n-      /* For conditional branches, substitute \".t\" or \".f\".  */\n-      if (TARGET_BRANCH_PREDICT)\n-\t{\n-\t  x = find_reg_note (current_output_insn, REG_BR_PROB, 0);\n-\t  if (x)\n-\t    {\n-\t      int pred_val = INTVAL (XEXP (x, 0));\n-\t      fputs ((pred_val < REG_BR_PROB_BASE / 2 ? \".f\" : \".t\"), file);\n-\t    }\n-\t}\n-      break;\n-\n-    case 0:\n-      output_addr_const (file, x);\n-      break;\n-\n-    default:\n-      abort ();\n-    }\n-\n-  return;\n-}\n-\f\n-/* Print a memory address as an operand to reference that memory location.\n-\n-   This is exactly the same as legitimate_address_p, except that it the prints\n-   addresses instead of recognizing them.  */\n-\n-void\n-i960_print_operand_addr (file, addr)\n-     FILE *file;\n-     register rtx addr;\n-{\n-  rtx breg, ireg;\n-  rtx scale, offset;\n-\n-  ireg = 0;\n-  breg = 0;\n-  offset = 0;\n-  scale = const1_rtx;\n-\n-  if (GET_CODE (addr) == REG)\n-    breg = addr;\n-  else if (CONSTANT_P (addr))\n-    offset = addr;\n-  else if (GET_CODE (addr) == PLUS)\n-    {\n-      rtx op0, op1;\n-\n-      op0 = XEXP (addr, 0);\n-      op1 = XEXP (addr, 1);\n-\n-      if (GET_CODE (op0) == REG)\n-\t{\n-\t  breg = op0;\n-\t  if (GET_CODE (op1) == REG)\n-\t    ireg = op1;\n-\t  else if (CONSTANT_P (op1))\n-\t    offset = op1;\n-\t  else\n-\t    abort ();\n-\t}\n-      else if (GET_CODE (op0) == PLUS)\n-\t{\n-\t  if (GET_CODE (XEXP (op0, 0)) == MULT)\n-\t    {\n-\t      ireg = XEXP (XEXP (op0, 0), 0);\n-\t      scale = XEXP (XEXP (op0, 0), 1);\n-\t      if (GET_CODE (XEXP (op0, 1)) == REG)\n-\t\t{\n-\t\t  breg = XEXP (op0, 1);\n-\t\t  offset = op1;\n-\t\t}\n-\t      else\n-\t\tabort ();\n-\t    }\n-\t  else if (GET_CODE (XEXP (op0, 0)) == REG)\n-\t    {\n-\t      breg = XEXP (op0, 0);\n-\t      if (GET_CODE (XEXP (op0, 1)) == REG)\n-\t\t{\n-\t\t  ireg = XEXP (op0, 1);\n-\t\t  offset = op1;\n-\t\t}\n-\t      else\n-\t\tabort ();\n-\t    }\n-\t  else\n-\t    abort ();\n-\t}\n-      else if (GET_CODE (op0) == MULT)\n-\t{\n-\t  ireg = XEXP (op0, 0);\n-\t  scale = XEXP (op0, 1);\n-\t  if (GET_CODE (op1) == REG)\n-\t    breg = op1;\n-\t  else if (CONSTANT_P (op1))\n-\t    offset = op1;\n-\t  else\n-\t    abort ();\n-\t}\n-      else\n-\tabort ();\n-    }\n-  else if (GET_CODE (addr) == MULT)\n-    {\n-      ireg = XEXP (addr, 0);\n-      scale = XEXP (addr, 1);\n-    }\n-  else\n-    abort ();\n-\n-  if (offset)\n-    output_addr_const (file, offset);\n-  if (breg)\n-    fprintf (file, \"(%s)\", reg_names[REGNO (breg)]);\n-  if (ireg)\n-    fprintf (file, \"[%s*\" HOST_WIDE_INT_PRINT_DEC \"]\",\n-\t     reg_names[REGNO (ireg)], INTVAL (scale));\n-}\n-\f\n-/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n-   that is a valid memory address for an instruction.\n-   The MODE argument is the machine mode for the MEM expression\n-   that wants to use this address.\n-\n-\tOn 80960, legitimate addresses are:\n-\t\tbase\t\t\t\tld\t(g0),r0\n-\t\tdisp\t(12 or 32 bit)\t\tld\tfoo,r0\n-\t\tbase + index\t\t\tld\t(g0)[g1*1],r0\n-\t\tbase + displ\t\t\tld\t0xf00(g0),r0\n-\t\tbase + index*scale + displ\tld\t0xf00(g0)[g1*4],r0\n-\t\tindex*scale + base\t\tld\t(g0)[g1*4],r0\n-\t\tindex*scale + displ\t\tld\t0xf00[g1*4],r0\n-\t\tindex*scale\t\t\tld\t[g1*4],r0\n-\t\tindex + base + displ\t\tld\t0xf00(g0)[g1*1],r0\n-\n-\tIn each case, scale can be 1, 2, 4, 8, or 16.  */\n-\n-/* This is exactly the same as i960_print_operand_addr, except that\n-   it recognizes addresses instead of printing them.\n-\n-   It only recognizes address in canonical form.  LEGITIMIZE_ADDRESS should\n-   convert common non-canonical forms to canonical form so that they will\n-   be recognized.  */\n-\n-/* These two macros allow us to accept either a REG or a SUBREG anyplace\n-   where a register is valid.  */\n-\n-#define RTX_OK_FOR_BASE_P(X, STRICT)\t\t\t\t\t\\\n-  ((GET_CODE (X) == REG\t\t\t\t\t\t\t\\\n-    && (STRICT ? REG_OK_FOR_BASE_P_STRICT (X) : REG_OK_FOR_BASE_P (X)))\t\\\n-   || (GET_CODE (X) == SUBREG\t\t\t\t\t\t\\\n-       && GET_CODE (SUBREG_REG (X)) == REG\t\t\t\t\\\n-       && (STRICT ? REG_OK_FOR_BASE_P_STRICT (SUBREG_REG (X))\t\t\\\n-\t   : REG_OK_FOR_BASE_P (SUBREG_REG (X)))))\n-\n-#define RTX_OK_FOR_INDEX_P(X, STRICT)\t\t\t\t\t\\\n-  ((GET_CODE (X) == REG\t\t\t\t\t\t\t\\\n-    && (STRICT ? REG_OK_FOR_INDEX_P_STRICT (X) : REG_OK_FOR_INDEX_P (X)))\\\n-   || (GET_CODE (X) == SUBREG\t\t\t\t\t\t\\\n-       && GET_CODE (SUBREG_REG (X)) == REG\t\t\t\t\\\n-       && (STRICT ? REG_OK_FOR_INDEX_P_STRICT (SUBREG_REG (X))\t\t\\\n-\t   : REG_OK_FOR_INDEX_P (SUBREG_REG (X)))))\n-\n-int\n-legitimate_address_p (mode, addr, strict)\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-     register rtx addr;\n-     int strict;\n-{\n-  if (RTX_OK_FOR_BASE_P (addr, strict))\n-    return 1;\n-  else if (CONSTANT_P (addr))\n-    return 1;\n-  else if (GET_CODE (addr) == PLUS)\n-    {\n-      rtx op0, op1;\n-\n-      if (! TARGET_COMPLEX_ADDR && ! reload_completed)\n-\treturn 0;\n-\n-      op0 = XEXP (addr, 0);\n-      op1 = XEXP (addr, 1);\n-\n-      if (RTX_OK_FOR_BASE_P (op0, strict))\n-\t{\n-\t  if (RTX_OK_FOR_INDEX_P (op1, strict))\n-\t    return 1;\n-\t  else if (CONSTANT_P (op1))\n-\t    return 1;\n-\t  else\n-\t    return 0;\n-\t}\n-      else if (GET_CODE (op0) == PLUS)\n-\t{\n-\t  if (GET_CODE (XEXP (op0, 0)) == MULT)\n-\t    {\n-\t      if (! (RTX_OK_FOR_INDEX_P (XEXP (XEXP (op0, 0), 0), strict)\n-\t\t     && SCALE_TERM_P (XEXP (XEXP (op0, 0), 1))))\n-\t\treturn 0;\n-\n-\t      if (RTX_OK_FOR_BASE_P (XEXP (op0, 1), strict)\n-\t\t  && CONSTANT_P (op1))\n-\t\treturn 1;\n-\t      else\n-\t\treturn 0;\n-\t    }\n-\t  else if (RTX_OK_FOR_BASE_P (XEXP (op0, 0), strict))\n-\t    {\n-\t      if (RTX_OK_FOR_INDEX_P (XEXP (op0, 1), strict)\n-\t\t  && CONSTANT_P (op1))\n-\t\treturn 1;\n-\t      else\n-\t\treturn 0;\n-\t    }\n-\t  else\n-\t    return 0;\n-\t}\n-      else if (GET_CODE (op0) == MULT)\n-\t{\n-\t  if (! (RTX_OK_FOR_INDEX_P (XEXP (op0, 0), strict)\n-\t\t && SCALE_TERM_P (XEXP (op0, 1))))\n-\t    return 0;\n-\n-\t  if (RTX_OK_FOR_BASE_P (op1, strict))\n-\t    return 1;\n-\t  else if (CONSTANT_P (op1))\n-\t    return 1;\n-\t  else\n-\t    return 0;\n-\t}\n-      else\n-\treturn 0;\n-    }\n-  else if (GET_CODE (addr) == MULT)\n-    {\n-      if (! TARGET_COMPLEX_ADDR && ! reload_completed)\n-\treturn 0;\n-\n-      return (RTX_OK_FOR_INDEX_P (XEXP (addr, 0), strict)\n-\t      && SCALE_TERM_P (XEXP (addr, 1)));\n-    }\n-  else\n-    return 0;\n-}\n-\n-/* Try machine-dependent ways of modifying an illegitimate address\n-   to be legitimate.  If we find one, return the new, valid address.\n-   This macro is used in only one place: `memory_address' in explow.c.\n-\n-   This converts some non-canonical addresses to canonical form so they\n-   can be recognized.  */\n-\n-rtx\n-legitimize_address (x, oldx, mode)\n-     register rtx x;\n-     register rtx oldx ATTRIBUTE_UNUSED;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-{ \n-  if (GET_CODE (x) == SYMBOL_REF)\n-    {\n-      abort ();\n-      x = copy_to_reg (x);\n-    }\n-\n-  if (! TARGET_COMPLEX_ADDR && ! reload_completed)\n-    return x;\n-\n-  /* Canonicalize (plus (mult (reg) (const)) (plus (reg) (const)))\n-     into (plus (plus (mult (reg) (const)) (reg)) (const)).  This can be\n-     created by virtual register instantiation, register elimination, and\n-     similar optimizations.  */\n-  if (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 0)) == MULT\n-      && GET_CODE (XEXP (x, 1)) == PLUS)\n-    x = gen_rtx_PLUS (Pmode,\n-\t\t      gen_rtx_PLUS (Pmode, XEXP (x, 0), XEXP (XEXP (x, 1), 0)),\n-\t\t      XEXP (XEXP (x, 1), 1));\n-\n-  /* Canonicalize (plus (plus (mult (reg) (const)) (plus (reg) (const))) const)\n-     into (plus (plus (mult (reg) (const)) (reg)) (const)).  */\n-  else if (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 0)) == PLUS\n-\t   && GET_CODE (XEXP (XEXP (x, 0), 0)) == MULT\n-\t   && GET_CODE (XEXP (XEXP (x, 0), 1)) == PLUS\n-\t   && CONSTANT_P (XEXP (x, 1)))\n-    {\n-      rtx constant, other;\n-\n-      if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n-\t{\n-\t  constant = XEXP (x, 1);\n-\t  other = XEXP (XEXP (XEXP (x, 0), 1), 1);\n-\t}\n-      else if (GET_CODE (XEXP (XEXP (XEXP (x, 0), 1), 1)) == CONST_INT)\n-\t{\n-\t  constant = XEXP (XEXP (XEXP (x, 0), 1), 1);\n-\t  other = XEXP (x, 1);\n-\t}\n-      else\n-\tconstant = 0, other = 0;\n-\n-      if (constant)\n-\tx = gen_rtx_PLUS (Pmode,\n-\t\t\t  gen_rtx_PLUS (Pmode, XEXP (XEXP (x, 0), 0),\n-\t\t\t\t\tXEXP (XEXP (XEXP (x, 0), 1), 0)),\n-\t\t\t  plus_constant (other, INTVAL (constant)));\n-    }\n-\n-  return x;\n-}\n-\f\n-#if 0\n-/* Return the most stringent alignment that we are willing to consider\n-   objects of size SIZE and known alignment ALIGN as having.  */\n-   \n-int\n-i960_alignment (size, align)\n-     int size;\n-     int align;\n-{\n-  int i;\n-\n-  if (! TARGET_STRICT_ALIGN)\n-    if (TARGET_IC_COMPAT2_0 || align >= 4)\n-      {\n-\ti = i960_object_bytes_bitalign (size) / BITS_PER_UNIT;\n-\tif (i > align)\n-\t  align = i;\n-      }\n-\n-  return align;\n-}\n-#endif\n-\f\n-\n-int\n-hard_regno_mode_ok (regno, mode)\n-     int regno;\n-     enum machine_mode mode;\n-{\n-  if (regno < 32)\n-    {\n-      switch (mode)\n-\t{\n-\tcase CCmode: case CC_UNSmode: case CC_CHKmode:\n-\t  return 0;\n-\n-\tcase DImode: case DFmode:\n-\t  return (regno & 1) == 0;\n-\n-\tcase TImode: case TFmode:\n-\t  return (regno & 3) == 0;\n-\n-\tdefault:\n-\t  return 1;\n-\t}\n-    }\n-  else if (regno >= 32 && regno < 36)\n-    {\n-      switch (mode)\n-\t{\n-\tcase SFmode: case DFmode: case TFmode:\n-\tcase SCmode: case DCmode:\n-\t  return 1;\n-\n-\tdefault:\n-\t  return 0;\n-\t}\n-    }\n-  else if (regno == 36)\n-    {\n-      switch (mode)\n-\t{\n-\tcase CCmode: case CC_UNSmode: case CC_CHKmode:\n-\t  return 1;\n-\n-\tdefault:\n-\t  return 0;\n-\t}\n-    }\n-  else if (regno == 37)\n-    return 0;\n-\n-  abort ();\n-}\n-\n-\f\n-/* Return the minimum alignment of an expression rtx X in bytes.  This takes\n-   advantage of machine specific facts, such as knowing that the frame pointer\n-   is always 16 byte aligned.  */\n-\n-int\n-i960_expr_alignment (x, size)\n-     rtx x;\n-     int size;\n-{\n-  int align = 1;\n-\n-  if (x == 0)\n-    return 1;\n-\n-  switch (GET_CODE(x))\n-    {\n-    case CONST_INT:\n-      align = INTVAL(x);\n-\n-      if ((align & 0xf) == 0)\n-\talign = 16;\n-      else if ((align & 0x7) == 0)\n-\talign = 8;\n-      else if ((align & 0x3) == 0)\n-\talign = 4;\n-      else if ((align & 0x1) == 0)\n-\talign = 2;\n-      else\n-\talign = 1;\n-      break;\n-\n-    case PLUS:\n-      align = MIN (i960_expr_alignment (XEXP (x, 0), size),\n-\t\t   i960_expr_alignment (XEXP (x, 1), size));\n-      break;\n-\n-    case SYMBOL_REF:\n-      /* If this is a valid program, objects are guaranteed to be\n-\t correctly aligned for whatever size the reference actually is.  */\n-      align = i960_object_bytes_bitalign (size) / BITS_PER_UNIT;\n-      break;\n-\n-    case REG:\n-      if (REGNO (x) == FRAME_POINTER_REGNUM)\n-\talign = 16;\n-      break;\n-\n-    case ASHIFT:\n-      align = i960_expr_alignment (XEXP (x, 0), size);\n-\n-      if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n-\t{\n-\t  align = align << INTVAL (XEXP (x, 1));\n-\t  align = MIN (align, 16);\n-\t}\n-      break;\n-\n-    case MULT:\n-      align = (i960_expr_alignment (XEXP (x, 0), size) *\n-\t       i960_expr_alignment (XEXP (x, 1), size));\n-\n-      align = MIN (align, 16);\n-      break;\n-    default:\n-      break;\n-    }\n-\n-  return align;\n-}\n-\n-/* Return true if it is possible to reference both BASE and OFFSET, which\n-   have alignment at least as great as 4 byte, as if they had alignment valid\n-   for an object of size SIZE.  */\n-\n-int\n-i960_improve_align (base, offset, size)\n-     rtx base;\n-     rtx offset;\n-     int size;\n-{\n-  int i, j;\n-\n-  /* We have at least a word reference to the object, so we know it has to\n-     be aligned at least to 4 bytes.  */\n-\n-  i = MIN (i960_expr_alignment (base, 4),\n-\t   i960_expr_alignment (offset, 4));\n-\n-  i = MAX (i, 4);\n-\n-  /* We know the size of the request.  If strict align is not enabled, we\n-     can guess that the alignment is OK for the requested size.  */\n-\n-  if (! TARGET_STRICT_ALIGN)\n-    if ((j = (i960_object_bytes_bitalign (size) / BITS_PER_UNIT)) > i)\n-      i = j;\n-\n-  return (i >= size);\n-}\n-\n-/* Return true if it is possible to access BASE and OFFSET, which have 4 byte\n-   (SImode) alignment as if they had 16 byte (TImode) alignment.  */\n-\n-int\n-i960_si_ti (base, offset)\n-     rtx base;\n-     rtx offset;\n-{\n-  return i960_improve_align (base, offset, 16);\n-}\n-\n-/* Return true if it is possible to access BASE and OFFSET, which have 4 byte\n-   (SImode) alignment as if they had 8 byte (DImode) alignment.  */\n-\n-int\n-i960_si_di (base, offset)\n-     rtx base;\n-     rtx offset;\n-{\n-  return i960_improve_align (base, offset, 8);\n-}\n-\f\n-/* Return raw values of size and alignment (in words) for the data\n-   type being accessed.  These values will be rounded by the caller.  */\n-\n-static void \n-i960_arg_size_and_align (mode, type, size_out, align_out)\n-     enum machine_mode mode;\n-     tree type;\n-     int *size_out;\n-     int *align_out;\n-{\n-  int size, align;\n-\n-  /* Use formal alignment requirements of type being passed, except make\n-     it at least a word.  If we don't have a type, this is a library call,\n-     and the parm has to be of scalar type.  In this case, consider its\n-     formal alignment requirement to be its size in words.  */\n-\n-  if (mode == BLKmode)\n-    size = (int_size_in_bytes (type) + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n-  else if (mode == VOIDmode)\n-    {\n-      /* End of parm list.  */\n-      if (type == 0 || TYPE_MODE (type) != VOIDmode)\n-\tabort ();\n-      size = 1;\n-    }\n-  else\n-    size = (GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n-\n-  if (type == 0)\n-    align = size;\n-  else if (TYPE_ALIGN (type) >= BITS_PER_WORD)\n-    align = TYPE_ALIGN (type) / BITS_PER_WORD;\n-  else\n-    align = 1;\n-\n-  *size_out  = size;\n-  *align_out = align;\n-}\n-\n-/* On the 80960 the first 12 args are in registers and the rest are pushed.\n-   Any arg that is bigger than 4 words is placed on the stack and all\n-   subsequent arguments are placed on the stack.\n-\n-   Additionally, parameters with an alignment requirement stronger than\n-   a word must be aligned appropriately.  Note that this means that a\n-   64 bit object with a 32 bit alignment is not 64 bit aligned and may be\n-   passed in an odd/even register pair.  */\n-\n-/* Update CUM to advance past an argument described by MODE and TYPE.  */\n-\n-void\n-i960_function_arg_advance (cum, mode, type, named)\n-     CUMULATIVE_ARGS *cum;\n-     enum machine_mode mode;\n-     tree type;\n-     int named ATTRIBUTE_UNUSED;\n-{\n-  int size, align;\n-\n-  i960_arg_size_and_align (mode, type, &size, &align);\n-\n-  if (size > 4 || cum->ca_nstackparms != 0\n-      || (size + ROUND_PARM (cum->ca_nregparms, align)) > NPARM_REGS\n-      || MUST_PASS_IN_STACK (mode, type))\n-    {\n-      /* Indicate that all the registers are in use, even if all are not,\n-\t so va_start will compute the right value.  */\n-      cum->ca_nregparms = NPARM_REGS;\n-      cum->ca_nstackparms = ROUND_PARM (cum->ca_nstackparms, align) + size;\n-    }\n-  else\n-    cum->ca_nregparms = ROUND_PARM (cum->ca_nregparms, align) + size;\n-}\n-\n-/* Return the register that the argument described by MODE and TYPE is\n-   passed in, or else return 0 if it is passed on the stack.  */\n-\n-rtx\n-i960_function_arg (cum, mode, type, named)\n-     CUMULATIVE_ARGS *cum;\n-     enum machine_mode mode;\n-     tree type;\n-     int named ATTRIBUTE_UNUSED;\n-{\n-  rtx ret;\n-  int size, align;\n-\n-  if (mode == VOIDmode)\n-    return 0;\n-\n-  i960_arg_size_and_align (mode, type, &size, &align);\n-\n-  if (size > 4 || cum->ca_nstackparms != 0\n-      || (size + ROUND_PARM (cum->ca_nregparms, align)) > NPARM_REGS\n-      || MUST_PASS_IN_STACK (mode, type))\n-    {\n-      cum->ca_nstackparms = ROUND_PARM (cum->ca_nstackparms, align);\n-      ret = 0;\n-    }\n-  else\n-    {\n-      cum->ca_nregparms = ROUND_PARM (cum->ca_nregparms, align);\n-      ret = gen_rtx_REG (mode, cum->ca_nregparms);\n-    }\n-\n-  return ret;\n-}\n-\f\n-/* Return the number of bits that an object of size N bytes is aligned to.  */\n-\n-int\n-i960_object_bytes_bitalign (n)\n-     int n;\n-{\n-  if (n > 8)      n = 128;\n-  else if (n > 4) n = 64;\n-  else if (n > 2) n = 32;\n-  else if (n > 1) n = 16;\n-  else            n = 8;\n-\n-  return n;\n-}\n-\n-/* Compute the alignment for an aggregate type TSIZE.\n-   Alignment is MAX (greatest member alignment,\n-                     MIN (pragma align, structure size alignment)).  */\n-\n-int\n-i960_round_align (align, type)\n-     int align;\n-     tree type;\n-{\n-  int new_align;\n-  tree tsize;\n-\n-  if (TARGET_OLD_ALIGN || TYPE_PACKED (type))\n-    return align;\n-  if (TREE_CODE (type) != RECORD_TYPE)\n-    return align;\n-  tsize = TYPE_SIZE (type);\n-\n-  if (! tsize || TREE_CODE (tsize) != INTEGER_CST)\n-    return align;\n-\n-  new_align = i960_object_bytes_bitalign (TREE_INT_CST_LOW (tsize)\n-\t\t\t\t\t  / BITS_PER_UNIT);\n-  /* Handle #pragma align.  */\n-  if (new_align > i960_maxbitalignment)\n-    new_align = i960_maxbitalignment;\n-\n-  if (align < new_align)\n-    align = new_align;\n-\n-  return align;\n-}\n-\f\n-/* Do any needed setup for a varargs function.  For the i960, we must\n-   create a register parameter block if one doesn't exist, and then copy\n-   all register parameters to memory.  */\n-\n-void\n-i960_setup_incoming_varargs (cum, mode, type, pretend_size, no_rtl)\n-     CUMULATIVE_ARGS *cum;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-     tree type ATTRIBUTE_UNUSED;\n-     int *pretend_size ATTRIBUTE_UNUSED;\n-     int no_rtl;\n-{\n-  /* Note: for a varargs fn with only a va_alist argument, this is 0.  */\n-  int first_reg = cum->ca_nregparms;\n-\n-  /* Copy only unnamed register arguments to memory.  If there are\n-     any stack parms, there are no unnamed arguments in registers, and\n-     an argument block was already allocated by the caller.\n-     Remember that any arg bigger than 4 words is passed on the stack as\n-     are all subsequent args.\n-\n-     If there are no stack arguments but there are exactly NPARM_REGS\n-     registers, either there were no extra arguments or the caller\n-     allocated an argument block.  */\n-\n-  if (cum->ca_nstackparms == 0 && first_reg < NPARM_REGS && !no_rtl)\n-    {\n-      rtx label = gen_label_rtx ();\n-      rtx regblock, fake_arg_pointer_rtx;\n-\n-      /* Use a different rtx than arg_pointer_rtx so that cse and friends\n-\t can go on believing that the argument pointer can never be zero.  */\n-      fake_arg_pointer_rtx = gen_raw_REG (Pmode, ARG_POINTER_REGNUM);\n-\n-      /* If the argument pointer is 0, no arguments were passed on the stack\n-\t and we need to allocate a chunk to save the registers (if any\n-\t arguments were passed on the stack the caller would allocate the\n-\t 48 bytes as well).  We must allocate all 48 bytes (12*4) because\n-\t va_start assumes it.  */\n-      emit_insn (gen_cmpsi (fake_arg_pointer_rtx, const0_rtx));\n-      emit_jump_insn (gen_bne (label));\n-      emit_insn (gen_rtx_SET (VOIDmode, fake_arg_pointer_rtx,\n-\t\t\t      stack_pointer_rtx));\n-      emit_insn (gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n-\t\t\t      memory_address (SImode,\n-\t\t\t\t\t      plus_constant (stack_pointer_rtx,\n-\t\t\t\t\t\t\t     48))));\n-      emit_label (label);\n-\n-      /* ??? Note that we unnecessarily store one extra register for stdarg\n-\t fns.  We could optimize this, but it's kept as for now.  */\n-      regblock = gen_rtx_MEM (BLKmode,\n-\t\t\t      plus_constant (arg_pointer_rtx, first_reg * 4));\n-      set_mem_alias_set (regblock, get_varargs_alias_set ());\n-      set_mem_align (regblock, BITS_PER_WORD);\n-      move_block_from_reg (first_reg, regblock,\n-\t\t\t   NPARM_REGS - first_reg);\n-    }\n-}\n-\n-/* Define the `__builtin_va_list' type for the ABI.  */\n-\n-static tree\n-i960_build_builtin_va_list ()\n-{\n-  return build_array_type (unsigned_type_node,\n-\t\t\t   build_index_type (size_one_node));\n-}\n-\n-/* Implement `va_start' for varargs and stdarg.  */\n-\n-void\n-i960_va_start (valist, nextarg)\n-     tree valist;\n-     rtx nextarg ATTRIBUTE_UNUSED;\n-{\n-  tree s, t, base, num;\n-  rtx fake_arg_pointer_rtx;\n-\n-  /* The array type always decays to a pointer before we get here, so we\n-     can't use ARRAY_REF.  */\n-  base = build1 (INDIRECT_REF, unsigned_type_node, valist);\n-  num = build1 (INDIRECT_REF, unsigned_type_node,\n-\t\tbuild (PLUS_EXPR, unsigned_type_node, valist,\n-\t\t       TYPE_SIZE_UNIT (TREE_TYPE (valist))));\n-\n-  /* Use a different rtx than arg_pointer_rtx so that cse and friends\n-     can go on believing that the argument pointer can never be zero.  */\n-  fake_arg_pointer_rtx = gen_raw_REG (Pmode, ARG_POINTER_REGNUM);\n-  s = make_tree (unsigned_type_node, fake_arg_pointer_rtx);\n-  t = build (MODIFY_EXPR, unsigned_type_node, base, s);\n-  TREE_SIDE_EFFECTS (t) = 1;\n-  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-\n-  s = build_int_2 ((current_function_args_info.ca_nregparms\n-\t\t    + current_function_args_info.ca_nstackparms) * 4, 0);\n-  t = build (MODIFY_EXPR, unsigned_type_node, num, s);\n-  TREE_SIDE_EFFECTS (t) = 1;\n-  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-}\n-\n-/* Implement `va_arg'.  */\n-\n-rtx\n-i960_va_arg (valist, type)\n-     tree valist, type;\n-{\n-  HOST_WIDE_INT siz, ali;\n-  tree base, num, pad, next, this, t1, t2, int48;\n-  rtx addr_rtx;\n-\n-  /* The array type always decays to a pointer before we get here, so we\n-     can't use ARRAY_REF.  */\n-  base = build1 (INDIRECT_REF, unsigned_type_node, valist);\n-  num = build1 (INDIRECT_REF, unsigned_type_node,\n-\t\tbuild (PLUS_EXPR, unsigned_type_node, valist,\n-\t\t       TYPE_SIZE_UNIT (TREE_TYPE (valist))));\n-\n-  /* Round up sizeof(type) to a word.  */\n-  siz = (int_size_in_bytes (type) + UNITS_PER_WORD - 1) & -UNITS_PER_WORD;\n-\n-  /* Round up alignment to a word.  */\n-  ali = TYPE_ALIGN (type);\n-  if (ali < BITS_PER_WORD)\n-    ali = BITS_PER_WORD;\n-  ali /= BITS_PER_UNIT;\n-\n-  /* Align NUM appropriate for the argument.  */\n-  pad = fold (build (PLUS_EXPR, unsigned_type_node, num, \n-\t\t      build_int_2 (ali - 1, 0)));\n-  pad = fold (build (BIT_AND_EXPR, unsigned_type_node, pad,\n-\t\t      build_int_2 (-ali, -1)));\n-  pad = save_expr (pad);\n-\n-  /* Increment VPAD past this argument.  */\n-  next = fold (build (PLUS_EXPR, unsigned_type_node, pad,\n-\t\t      build_int_2 (siz, 0)));\n-  next = save_expr (next);\n-\n-  /* Find the offset for the current argument.  Mind peculiar overflow\n-     from registers to stack.  */\n-  int48 = build_int_2 (48, 0);\n-  if (siz > 16)\n-    t2 = integer_one_node;\n-  else\n-    t2 = fold (build (GT_EXPR, integer_type_node, next, int48));\n-  t1 = fold (build (LE_EXPR, integer_type_node, num, int48));\n-  t1 = fold (build (TRUTH_AND_EXPR, integer_type_node, t1, t2));\n-  this = fold (build (COND_EXPR, unsigned_type_node, t1, int48, pad));\n-\n-  /* Find the address for the current argument.  */\n-  t1 = fold (build (PLUS_EXPR, unsigned_type_node, base, this));\n-  t1 = build1 (NOP_EXPR, ptr_type_node, t1);\n-  addr_rtx = expand_expr (t1, NULL_RTX, Pmode, EXPAND_NORMAL);\n-\n-  /* Increment NUM.  */\n-  t1 = build (MODIFY_EXPR, unsigned_type_node, num, next);\n-  TREE_SIDE_EFFECTS (t1) = 1;\n-  expand_expr (t1, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-  \n-  return addr_rtx;\n-}\n-\n-/* Calculate the final size of the reg parm stack space for the current\n-   function, based on how many bytes would be allocated on the stack.  */\n-\n-int\n-i960_final_reg_parm_stack_space (const_size, var_size)\n-     int const_size;\n-     tree var_size;\n-{\n-  if (var_size || const_size > 48)\n-    return 48;\n-  else\n-    return 0;\n-}\n-\n-/* Calculate the size of the reg parm stack space.  This is a bit complicated\n-   on the i960.  */\n-\n-int\n-i960_reg_parm_stack_space (fndecl)\n-     tree fndecl;\n-{\n-  /* In this case, we are called from emit_library_call, and we don't need\n-     to pretend we have more space for parameters than what's apparent.  */\n-  if (fndecl == 0)\n-    return 0;\n-\n-  /* In this case, we are called from locate_and_pad_parms when we're\n-     not IN_REGS, so we have an arg block.  */\n-  if (fndecl != current_function_decl)\n-    return 48;\n-\n-  /* Otherwise, we have an arg block if the current function has more than\n-     48 bytes of parameters.  */\n-  if (current_function_args_size != 0 || VARARGS_STDARG_FUNCTION (fndecl))\n-    return 48;\n-  else\n-    return 0;\n-}\n-\f\n-/* Return the register class of a scratch register needed to copy IN into\n-   or out of a register in CLASS in MODE.  If it can be done directly,\n-   NO_REGS is returned.  */\n-\n-enum reg_class\n-secondary_reload_class (class, mode, in)\n-     enum reg_class class;\n-     enum machine_mode mode;\n-     rtx in;\n-{\n-  int regno = -1;\n-\n-  if (GET_CODE (in) == REG || GET_CODE (in) == SUBREG)\n-    regno = true_regnum (in);\n-\n-  /* We can place anything into LOCAL_OR_GLOBAL_REGS and can put\n-     LOCAL_OR_GLOBAL_REGS into anything.  */\n-  if (class == LOCAL_OR_GLOBAL_REGS || class == LOCAL_REGS\n-      || class == GLOBAL_REGS || (regno >= 0 && regno < 32))\n-    return NO_REGS;\n-\n-  /* We can place any hard register, 0.0, and 1.0 into FP_REGS.  */\n-  if (class == FP_REGS\n-      && ((regno >= 0 && regno < FIRST_PSEUDO_REGISTER)\n-\t  || in == CONST0_RTX (mode) || in == CONST1_RTX (mode)))\n-    return NO_REGS;\n-\n-  return LOCAL_OR_GLOBAL_REGS;\n-}\n-\f\n-/* Look at the opcode P, and set i96_last_insn_type to indicate which\n-   function unit it executed on.  */\n-\n-/* ??? This would make more sense as an attribute.  */\n-\n-void\n-i960_scan_opcode (p)\n-     const char *p;\n-{\n-  switch (*p)\n-    {\n-    case 'a':\n-    case 'd':\n-    case 'e':\n-    case 'm':\n-    case 'n':\n-    case 'o':\n-    case 'r':\n-      /* Ret is not actually of type REG, but it won't matter, because no\n-\t insn will ever follow it.  */\n-    case 'u':\n-    case 'x':\n-      i960_last_insn_type = I_TYPE_REG;\n-      break;\n-\n-    case 'b':\n-      if (p[1] == 'x' || p[3] == 'x')\n-        i960_last_insn_type = I_TYPE_MEM;\n-      i960_last_insn_type = I_TYPE_CTRL;\n-      break;\n-\n-    case 'f':\n-    case 't':\n-      i960_last_insn_type = I_TYPE_CTRL;\n-      break;\n-\n-    case 'c':\n-      if (p[1] == 'a')\n-\t{\n-\t  if (p[4] == 'x')\n-\t    i960_last_insn_type = I_TYPE_MEM;\n-\t  else\n-\t    i960_last_insn_type = I_TYPE_CTRL;\n-\t}\n-      else if (p[1] == 'm')\n-\t{\n-\t  if (p[3] == 'd')\n-\t    i960_last_insn_type = I_TYPE_REG;\n-\t  else if (p[4] == 'b' || p[4] == 'j')\n-\t    i960_last_insn_type = I_TYPE_CTRL;\n-\t  else\n-\t    i960_last_insn_type = I_TYPE_REG;\n-\t}\n-      else\n-        i960_last_insn_type = I_TYPE_REG;\n-      break;\n-\n-    case 'l':\n-      i960_last_insn_type = I_TYPE_MEM;\n-      break;\n-\n-    case 's':\n-      if (p[1] == 't')\n-        i960_last_insn_type = I_TYPE_MEM;\n-      else\n-        i960_last_insn_type = I_TYPE_REG;\n-      break;\n-    }\n-}\n-\n-static void\n-i960_output_mi_thunk (file, thunk, delta, vcall_offset, function)\n-     FILE *file;\n-     tree thunk ATTRIBUTE_UNUSED;\n-     HOST_WIDE_INT delta;\n-     HOST_WIDE_INT vcall_offset ATTRIBUTE_UNUSED;\n-     tree function;\n-{\n-  int d = delta;\n-  if (d < 0 && d > -32)\t\t\t\t\t\t\t\n-    fprintf (file, \"\\tsubo %d,g0,g0\\n\", -d);\t\t\t\t\n-  else if (d > 0 && d < 32)\t\t\t\t\t\t\n-    fprintf (file, \"\\taddo %d,g0,g0\\n\", d);\t\t\t\t\n-  else\t\t\t\t\t\t\t\t\t\n-    {\t\t\t\t\t\t\t\t\t\n-      fprintf (file, \"\\tldconst %d,r5\\n\", d);\t\t\t\t\n-      fprintf (file, \"\\taddo r5,g0,g0\\n\");\t\t\t\t\n-    }\t\t\t\t\t\t\t\t\t\n-  fprintf (file, \"\\tbx \");\t\t\t\t\t\t\n-  assemble_name (file, XSTR (XEXP (DECL_RTL (function), 0), 0));\t\n-  fprintf (file, \"\\n\");\t\t\t\t\t\t\t\n-}\n-\n-static bool\n-i960_rtx_costs (x, code, outer_code, total)\n-     rtx x;\n-     int code, outer_code;\n-     int *total;\n-{\n-  switch (code)\n-    {\n-      /* Constants that can be (non-ldconst) insn operands are cost 0.\n-\t Constants that can be non-ldconst operands in rare cases are cost 1.\n-         Other constants have higher costs.\n-\n-         Must check for OUTER_CODE of SET for power2_operand, because\n-         reload_cse_move2add calls us with OUTER_CODE of PLUS to decide\n-\t when to replace set with add.  */\n-\n-    case CONST_INT:\n-      if ((INTVAL (x) >= 0 && INTVAL (x) < 32)\n-\t  || (outer_code == SET && power2_operand (x, VOIDmode)))\n-\t{\n-\t  *total = 0;\n-\t  return true;\n-\t}\n-      else if (INTVAL (x) >= -31 && INTVAL (x) < 0)\n-\t{\n-\t  *total = 1;\n-\t  return true;\n-\t}\n-      /* FALLTHRU */\n-\n-    case CONST:\n-    case LABEL_REF:\n-    case SYMBOL_REF:\n-      *total = (TARGET_C_SERIES ? 6 : 8);\n-      return true;\n-\n-    case CONST_DOUBLE:\n-      if (x == CONST0_RTX (DFmode) || x == CONST0_RTX (SFmode)\n-\t  || x == CONST1_RTX (DFmode) || x == CONST1_RTX (SFmode))\n-\t*total = 1;\n-      else\n-\t*total = 12;\n-      return true;\n-\n-    default:\n-      return false;\n-    }\n-}"}, {"sha": "ad86dba003bd0bcde2a612f581ace9995a9df420", "filename": "gcc/config/i960/i960.h", "status": "removed", "additions": 0, "deletions": 1404, "changes": 1404, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fi960%2Fi960.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fi960%2Fi960.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.h?ref=c3bf16ff7dec47581f450b1a486cfdf9d566927e", "patch": "@@ -1,1404 +0,0 @@\n-/* Definitions of target machine for GNU compiler, for Intel 80960\n-   Copyright (C) 1992, 1993, 1995, 1996, 1998, 1999, 2000, 2001, 2002\n-   Free Software Foundation, Inc.\n-   Contributed by Steven McGeady, Intel Corp.\n-   Additional Work by Glenn Colon-Bonet, Jonathan Shapiro, Andy Wilson\n-   Converted to GCC 2.0 by Jim Wilson and Michael Tiemann, Cygnus Support.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-/* Note that some other tm.h files may include this one and then override\n-   many of the definitions that relate to assembler syntax.  */\n-\n-/* Target CPU builtins.  */\n-#define TARGET_CPU_CPP_BUILTINS()\t\t\\\n-  do\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\\\n-\tbuiltin_define_std (\"i960\");\t\t\\\n-\tbuiltin_define_std (\"I960\");\t\t\\\n-\tbuiltin_define_std (\"i80960\");\t\t\\\n-\tbuiltin_define_std (\"I80960\");\t\t\\\n-\tbuiltin_assert (\"cpu=i960\");\t\t\\\n-\tbuiltin_assert (\"machine=i960\");\t\\\n-    }\t\t\t\t\t\t\\\n-  while (0)\n-\n-#define MULTILIB_DEFAULTS { \"mnumerics\" }\n-\n-/* Name to predefine in the preprocessor for processor variations.\n-   -mic* options make characters signed by default.  */\n-#define\tCPP_SPEC \"%{mic*:-D__i960 -fsigned-char\\\n-\t\t\t%{mka:-D__i960KA}%{mkb:-D__i960KB}\\\n-\t\t\t%{mja:-D__i960JA}%{mjd:-D__i960JD}%{mjf:-D__i960JF}\\\n-\t\t\t%{mrp:-D__i960RP}\\\n-\t\t\t%{msa:-D__i960SA}%{msb:-D__i960SB}\\\n-\t\t\t%{mmc:-D__i960MC}\\\n-\t\t\t%{mca:-D__i960CA}%{mcc:-D__i960CC}\\\n-\t\t\t%{mcf:-D__i960CF}}\\\n-\t%{msoft-float:-D_SOFT_FLOAT}\\\n-\t%{mka:-D__i960KA__ -D__i960_KA__}\\\n-\t%{mkb:-D__i960KB__ -D__i960_KB__}\\\n-\t%{msa:-D__i960SA__ -D__i960_SA__}\\\n-\t%{msb:-D__i960SB__ -D__i960_SB__}\\\n-\t%{mmc:-D__i960MC__ -D__i960_MC__}\\\n-\t%{mca:-D__i960CA__ -D__i960_CA__}\\\n-\t%{mcc:-D__i960CC__ -D__i960_CC__}\\\n-\t%{mcf:-D__i960CF__ -D__i960_CF__}\\\n-\t%{!mka:%{!mkb:%{!msa:%{!msb:%{!mmc:%{!mca:\\\n-\t\t%{!mcc:%{!mcf:-D__i960_KB -D__i960KB__ %{mic*:-D__i960KB}}}}}}}}}\\\n-\t%{mlong-double-64:-D__LONG_DOUBLE_64__}\"\n-\n-/* Specs for the compiler, to handle processor variations. \n-   If the user gives an explicit -gstabs or -gcoff option, then do not\n-   try to add an implicit one, as this will fail. \n-   -mic* options make characters signed by default.  */\n-#define CC1_SPEC \\\n-\t\"%{mic*:-fsigned-char}\\\n-%{!mka:%{!mkb:%{!msa:%{!msb:%{!mmc:%{!mca:%{!mcc:%{!mcf:%{!mja:%{!mjd:%{!mjf:%{!mrp:-mka}}}}}}}}}}}}\\\n-\t %{!gs*:%{!gc*:%{mbout:%{g*:-gstabs}}\\\n-\t\t       %{mcoff:%{g*:-gcoff}}\\\n-\t\t       %{!mbout:%{!mcoff:%{g*:-gstabs}}}}}\"\n-\n-/* Specs for the assembler, to handle processor variations.\n-   For compatibility with Intel's gnu960 tool chain, pass -A options to\n-   the assembler.  */\n-#define ASM_SPEC \\\n-\t\"%{mka:-AKA}%{mkb:-AKB}%{msa:-ASA}%{msb:-ASB}\\\n-\t%{mmc:-AMC}%{mca:-ACA}%{mcc:-ACC}%{mcf:-ACF}\\\n-        %{mja:-AJX}%{mjd:-AJX}%{mjf:-AJX}%{mrp:-AJX}\\\n-\t%{!mka:%{!mkb:%{!msa:%{!msb:%{!mmc:%{!mca:%{!mcc:%{!mcf:%{!mja:%{!mjd:%{!mjf:%{!mrp:-AKB}}}}}}}}}}}}\\\n-\t%{mlink-relax:-linkrelax}\"\n-\n-/* Specs for the linker, to handle processor variations.\n-   For compatibility with Intel's gnu960 tool chain, pass -F and -A options\n-   to the linker.  */\n-#define LINK_SPEC \\\n-\t\"%{mka:-AKA}%{mkb:-AKB}%{msa:-ASA}%{msb:-ASB}\\\n-\t%{mmc:-AMC}%{mca:-ACA}%{mcc:-ACC}%{mcf:-ACF}\\\n-        %{mja:-AJX}%{mjd:-AJX}%{mjf:-AJX}%{mrp:-AJX}\\\n-\t%{mbout:-Fbout}%{mcoff:-Fcoff}\\\n-\t%{mlink-relax:-relax}\"\n-\n-/* Specs for the libraries to link with, to handle processor variations.\n-   Compatible with Intel's gnu960 tool chain.  */\n-#define LIB_SPEC \"%{!nostdlib:-lcg %{p:-lprof}%{pg:-lgprof}\\\n-\t  %{mka:-lfpg}%{msa:-lfpg}%{mca:-lfpg}%{mcf:-lfpg} -lgnu}\"\n-\n-/* Defining the macro shows we can debug even without a frame pointer.\n-   Actually, we can debug without FP.  But defining the macro results in\n-   that -O means FP elimination.  Addressing through sp requires\n-   negative offset and more one word addressing in the most cases\n-   (offsets except for 0-4095 require one more word).  Therefore we've\n-   not defined the macro.  */\n-/*#define CAN_DEBUG_WITHOUT_FP*/\n-\n-/* Do leaf procedure and tail call optimizations for -O2 and higher.  */\n-#define OPTIMIZATION_OPTIONS(LEVEL,SIZE)\t\\\n-{\t\t\t\t\t\t\\\n-  if ((LEVEL) >= 2)\t\t\t\t\\\n-    {\t\t\t\t\t\t\\\n-      target_flags |= TARGET_FLAG_LEAFPROC;\t\\\n-      target_flags |= TARGET_FLAG_TAILCALL;\t\\\n-    }\t\t\t\t\t\t\\\n-}\n-\n-/* Print subsidiary information on the compiler version in use.  */\n-#define TARGET_VERSION fprintf (stderr,\" (intel 80960)\");\n-\n-/* Generate DBX debugging information.  */\n-#define DBX_DEBUGGING_INFO 1\n-\n-/* Generate SDB style debugging information.  */\n-#define SDB_DEBUGGING_INFO 1\n-#define EXTENDED_SDB_BASIC_TYPES\n-\n-/* Generate DBX_DEBUGGING_INFO by default.  */\n-#define PREFERRED_DEBUGGING_TYPE DBX_DEBUG\n-\n-/* Redefine this to print in hex.  No value adjustment is necessary\n-   anymore.  */\n-#define PUT_SDB_TYPE(A) \\\n-  fprintf (asm_out_file, \"\\t.type\\t0x%x;\", A)\n-\n-/* Handle pragmas for compatibility with Intel's compilers.  */\n-\n-extern int i960_maxbitalignment;\n-extern int i960_last_maxbitalignment;\n-\n-#define REGISTER_TARGET_PRAGMAS() do {\t\t\t\\\n-  c_register_pragma (0, \"align\", i960_pr_align);\t\\\n-  c_register_pragma (0, \"noalign\", i960_pr_noalign);\t\\\n-} while (0)\n-\n-/* Run-time compilation parameters selecting different hardware subsets.  */\n-\n-/* 960 architecture with floating-point.  */\n-#define TARGET_FLAG_NUMERICS\t0x01\n-#define TARGET_NUMERICS\t\t(target_flags & TARGET_FLAG_NUMERICS)\n-\n-/* 960 architecture with memory management.  */\n-/* ??? Not used currently.  */\n-#define\tTARGET_FLAG_PROTECTED\t0x02\n-#define\tTARGET_PROTECTED\t(target_flags & TARGET_FLAG_PROTECTED)\n-\n-/* The following three are mainly used to provide a little sanity checking\n-   against the -mARCH flags given. The Jx series, for the purposes of\n-   gcc, is a Kx with a data cache.  */\n-\n-/* Nonzero if we should generate code for the KA and similar processors.\n-   No FPU, no microcode instructions.  */\n-#define TARGET_FLAG_K_SERIES\t0x04\n-#define TARGET_K_SERIES\t\t(target_flags & TARGET_FLAG_K_SERIES)\n-\n-/* Nonzero if we should generate code for the MC processor.\n-   Not really different from KB for our purposes.  */\n-#define\tTARGET_FLAG_MC\t\t0x08\n-#define TARGET_MC \t\t(target_flags & TARGET_FLAG_MC)\n-\n-/* Nonzero if we should generate code for the CA processor.\n-   Enables different optimization strategies.  */\n-#define\tTARGET_FLAG_C_SERIES\t0x10\n-#define\tTARGET_C_SERIES \t(target_flags & TARGET_FLAG_C_SERIES)\n-\n-/* Nonzero if we should generate leaf-procedures when we find them.\n-   You may not want to do this because leaf-proc entries are\n-   slower when not entered via BAL - this would be true when\n-   a linker not supporting the optimization is used.  */\n-#define\tTARGET_FLAG_LEAFPROC\t0x20\n-#define\tTARGET_LEAFPROC\t\t(target_flags & TARGET_FLAG_LEAFPROC)\n-\n-/* Nonzero if we should perform tail-call optimizations when we find them.\n-   You may not want to do this because the detection of cases where\n-   this is not valid is not totally complete.  */\n-#define\tTARGET_FLAG_TAILCALL\t0x40\n-#define\tTARGET_TAILCALL\t\t(target_flags & TARGET_FLAG_TAILCALL)\n-\n-/* Nonzero if use of a complex addressing mode is a win on this implementation.\n-   Complex addressing modes are probably not worthwhile on the K-series,\n-   but they definitely are on the C-series.  */\n-#define\tTARGET_FLAG_COMPLEX_ADDR 0x80\n-#define\tTARGET_COMPLEX_ADDR\t(target_flags & TARGET_FLAG_COMPLEX_ADDR)\n-\n-/* Align code to 8 byte boundaries for faster fetching.  */\n-#define\tTARGET_FLAG_CODE_ALIGN\t0x100\n-#define\tTARGET_CODE_ALIGN\t(target_flags  & TARGET_FLAG_CODE_ALIGN)\n-\n-/* Append branch prediction suffixes to branch opcodes.  */\n-/* ??? Not used currently.  */\n-#define\tTARGET_FLAG_BRANCH_PREDICT 0x200\n-#define\tTARGET_BRANCH_PREDICT\t(target_flags  & TARGET_FLAG_BRANCH_PREDICT)\n-\n-/* Forces prototype and return promotions.  */\n-/* ??? This does not work.  */\n-#define\tTARGET_FLAG_CLEAN_LINKAGE 0x400\n-#define\tTARGET_CLEAN_LINKAGE\t(target_flags & TARGET_FLAG_CLEAN_LINKAGE)\n-\n-/* For compatibility with iC960 v3.0.  */\n-#define\tTARGET_FLAG_IC_COMPAT3_0 0x800 \n-#define\tTARGET_IC_COMPAT3_0\t(target_flags & TARGET_FLAG_IC_COMPAT3_0)\n-\n-/* For compatibility with iC960 v2.0.  */\n-#define\tTARGET_FLAG_IC_COMPAT2_0 0x1000\n-#define\tTARGET_IC_COMPAT2_0\t(target_flags & TARGET_FLAG_IC_COMPAT2_0)\n-\n-/* If no unaligned accesses are to be permitted.  */\n-#define\tTARGET_FLAG_STRICT_ALIGN 0x2000\n-#define\tTARGET_STRICT_ALIGN\t(target_flags & TARGET_FLAG_STRICT_ALIGN)\n-\n-/* For compatibility with iC960 assembler.  */\n-#define\tTARGET_FLAG_ASM_COMPAT\t0x4000\n-#define\tTARGET_ASM_COMPAT\t(target_flags & TARGET_FLAG_ASM_COMPAT)\n-\n-/* For compatibility with the gcc960 v1.2 compiler.  Use the old structure\n-   alignment rules.  Also, turns on STRICT_ALIGNMENT.  */\n-#define TARGET_FLAG_OLD_ALIGN\t0x8000\n-#define TARGET_OLD_ALIGN\t(target_flags & TARGET_FLAG_OLD_ALIGN)\n-\n-/* Nonzero if long doubles are to be 64 bits.  Useful for soft-float targets\n-   if 80 bit long double support is missing.  */\n-#define TARGET_FLAG_LONG_DOUBLE_64\t0x10000\n-#define TARGET_LONG_DOUBLE_64\t(target_flags & TARGET_FLAG_LONG_DOUBLE_64)\n-\n-extern int target_flags;\n-\n-/* Macro to define tables used to set the flags.\n-   This is a list in braces of pairs in braces,\n-   each pair being { \"NAME\", VALUE }\n-   where VALUE is the bits to set or minus the bits to clear.\n-   An empty string NAME is used to identify the default VALUE.  */\n-\n-/* ??? Not all ten of these architecture variations actually exist, but I\n-   am not sure which are real and which aren't.  */\n-\n-#define TARGET_SWITCHES  \\\n-  { {\"sa\", (TARGET_FLAG_K_SERIES|TARGET_FLAG_COMPLEX_ADDR),\t\t\\\n-       N_(\"Generate SA code\")},\t\t\t\t\t\t\\\n-    {\"sb\", (TARGET_FLAG_NUMERICS|TARGET_FLAG_K_SERIES|\t\t\t\\\n-\t\t\tTARGET_FLAG_COMPLEX_ADDR),\t\t\t\\\n-       N_(\"Generate SB code\")},\t\t\t\t\t\t\\\n-/*  {\"sc\", (TARGET_FLAG_NUMERICS|TARGET_FLAG_PROTECTED|\t\t\t\\\n-\t\t\tTARGET_FLAG_MC|TARGET_FLAG_COMPLEX_ADDR),\t\\\n-       N_(\"Generate SC code\")}, */\t\t\t\t\t\\\n-    {\"ka\", (TARGET_FLAG_K_SERIES|TARGET_FLAG_COMPLEX_ADDR),\t\t\\\n-       N_(\"Generate KA code\")},\t\t\t\t\t\t\\\n-    {\"kb\", (TARGET_FLAG_NUMERICS|TARGET_FLAG_K_SERIES|\t\t\t\\\n-\t\t\tTARGET_FLAG_COMPLEX_ADDR),\t\t\t\\\n-       N_(\"Generate KB code\")},\t\t\t\t\t\t\\\n-/*  {\"kc\", (TARGET_FLAG_NUMERICS|TARGET_FLAG_PROTECTED|\t\t\t\\\n-\t\t\tTARGET_FLAG_MC|TARGET_FLAG_COMPLEX_ADDR),\t\\\n-       N_(\"Generate KC code\")}, */\t\t\t\t\t\\\n-    {\"ja\", (TARGET_FLAG_K_SERIES|TARGET_FLAG_COMPLEX_ADDR),\t\t\\\n-       N_(\"Generate JA code\")},\t\t\t\t\t\t\\\n-    {\"jd\", (TARGET_FLAG_K_SERIES|TARGET_FLAG_COMPLEX_ADDR),\t\t\\\n-       N_(\"Generate JD code\")},\t\t\t\t\t\t\\\n-    {\"jf\", (TARGET_FLAG_NUMERICS|TARGET_FLAG_K_SERIES|\t\t\t\\\n-\t\t\tTARGET_FLAG_COMPLEX_ADDR),\t\t\t\\\n-       N_(\"Generate JF code\")},\t\t\t\t\t\t\\\n-    {\"rp\", (TARGET_FLAG_K_SERIES|TARGET_FLAG_COMPLEX_ADDR),\t\t\\\n-       N_(\"generate RP code\")},\t\t\t\t\t\t\\\n-    {\"mc\", (TARGET_FLAG_NUMERICS|TARGET_FLAG_PROTECTED|\t\t\t\\\n-\t\t\tTARGET_FLAG_MC|TARGET_FLAG_COMPLEX_ADDR),\t\\\n-       N_(\"Generate MC code\")},\t\t\t\t\t\t\\\n-    {\"ca\", (TARGET_FLAG_C_SERIES|TARGET_FLAG_BRANCH_PREDICT|\t\t\\\n-\t\t\tTARGET_FLAG_CODE_ALIGN|TARGET_FLAG_COMPLEX_ADDR),\\\n-       N_(\"Generate CA code\")},\t\t\t\t\t\t\\\n-/*  {\"cb\", (TARGET_FLAG_NUMERICS|TARGET_FLAG_C_SERIES|\t\t\t\\\n-\t\t\tTARGET_FLAG_BRANCH_PREDICT|TARGET_FLAG_CODE_ALIGN),\\\n-       N_(\"Generate CB code\")},\t\t\t\t\t\t\\\n-    {\"cc\", (TARGET_FLAG_NUMERICS|TARGET_FLAG_PROTECTED|\t\t\t\\\n-\t\t\tTARGET_FLAG_C_SERIES|TARGET_FLAG_BRANCH_PREDICT|\\\n-\t\t\tTARGET_FLAG_CODE_ALIGN),\t\t\t\\\n-       N_(\"Generate CC code\")}, */\t\t\t\t\t\\\n-    {\"cf\", (TARGET_FLAG_C_SERIES|TARGET_FLAG_BRANCH_PREDICT|\t\t\\\n-\t\t\tTARGET_FLAG_CODE_ALIGN|TARGET_FLAG_COMPLEX_ADDR),\\\n-       N_(\"Generate CF code\")},\t\t\t\t\t\t\\\n-    {\"numerics\", (TARGET_FLAG_NUMERICS),\t\t\t\t\\\n-       N_(\"Use hardware floating point instructions\")},\t\t\t\\\n-    {\"soft-float\", -(TARGET_FLAG_NUMERICS),\t\t\t\t\\\n-       N_(\"Use software floating point\")},\t\t\t\t\\\n-    {\"leaf-procedures\", TARGET_FLAG_LEAFPROC,\t\t\t\t\\\n-       N_(\"Use alternate leaf function entries\")},\t\t\t\\\n-    {\"no-leaf-procedures\", -(TARGET_FLAG_LEAFPROC),\t\t\t\\\n-       N_(\"Do not use alternate leaf function entries\")},\t\t\\\n-    {\"tail-call\", TARGET_FLAG_TAILCALL,\t\t\t\t\t\\\n-       N_(\"Perform tail call optimization\")},\t\t\t\t\\\n-    {\"no-tail-call\", -(TARGET_FLAG_TAILCALL),\t\t\t\t\\\n-       N_(\"Do not perform tail call optimization\")},\t\t\t\\\n-    {\"complex-addr\", TARGET_FLAG_COMPLEX_ADDR, \t\t\t\t\\\n-       N_(\"Use complex addressing modes\")},\t\t\t\t\\\n-    {\"no-complex-addr\", -(TARGET_FLAG_COMPLEX_ADDR),\t\t\t\\\n-       N_(\"Do not use complex addressing modes\")},\t\t\t\\\n-    {\"code-align\", TARGET_FLAG_CODE_ALIGN,\t\t\t\t\\\n-       N_(\"Align code to 8 byte boundary\")},\t\t\t\t\\\n-    {\"no-code-align\", -(TARGET_FLAG_CODE_ALIGN),\t\t\t\\\n-       N_(\"Do not align code to 8 byte boundary\")},\t\t\t\\\n-/*  {\"clean-linkage\", (TARGET_FLAG_CLEAN_LINKAGE),\t\t\t\\\n-       N_(\"Force use of prototypes\")},\t\t\t\t\t\\\n-    {\"no-clean-linkage\", -(TARGET_FLAG_CLEAN_LINKAGE),\t\t\t\\\n-       N_(\"Do not force use of prototypes\")}, */\t\t\t\\\n-    {\"ic-compat\", TARGET_FLAG_IC_COMPAT2_0,\t\t\t\t\\\n-       N_(\"Enable compatibility with iC960 v2.0\")},\t\t\t\\\n-    {\"ic2.0-compat\", TARGET_FLAG_IC_COMPAT2_0,\t\t\t\t\\\n-       N_(\"Enable compatibility with iC960 v2.0\")},\t\t\t\\\n-    {\"ic3.0-compat\", TARGET_FLAG_IC_COMPAT3_0,\t\t\t\t\\\n-       N_(\"Enable compatibility with iC960 v3.0\")},\t\t\t\\\n-    {\"asm-compat\", TARGET_FLAG_ASM_COMPAT,\t\t\t\t\\\n-       N_(\"Enable compatibility with ic960 assembler\")},\t\t\\\n-    {\"intel-asm\", TARGET_FLAG_ASM_COMPAT,\t\t\t\t\\\n-       N_(\"Enable compatibility with ic960 assembler\")},\t\t\\\n-    {\"strict-align\", TARGET_FLAG_STRICT_ALIGN,\t\t\t\t\\\n-       N_(\"Do not permit unaligned accesses\")},\t\t\t\t\\\n-    {\"no-strict-align\", -(TARGET_FLAG_STRICT_ALIGN),\t\t\t\\\n-       N_(\"Permit unaligned accesses\")},\t\t\t\t\\\n-    {\"old-align\", (TARGET_FLAG_OLD_ALIGN|TARGET_FLAG_STRICT_ALIGN),\t\\\n-       N_(\"Layout types like Intel's v1.3 gcc\")},\t\t\t\\\n-    {\"no-old-align\", -(TARGET_FLAG_OLD_ALIGN|TARGET_FLAG_STRICT_ALIGN),\t\\\n-       N_(\"Do not layout types like Intel's v1.3 gcc\")},\t\t\\\n-    {\"long-double-64\", TARGET_FLAG_LONG_DOUBLE_64,\t\t\t\\\n-       N_(\"Use 64 bit long doubles\")},\t\t\t\t\t\\\n-    {\"link-relax\", 0,\t\t\t\t\t\t\t\\\n-       N_(\"Enable linker relaxation\")},\t\t\t\t\t\\\n-    {\"no-link-relax\", 0,\t\t\t\t\t\t\\\n-       N_(\"Do not enable linker relaxation\")},\t\t\t\t\\\n-    SUBTARGET_SWITCHES                                                  \\\n-    { \"\", TARGET_DEFAULT,\t\t\t\t\t\t\\\n-\tNULL}}\n-\n-/* This are meant to be redefined in the host dependent files */\n-#define SUBTARGET_SWITCHES\n-\n-/* Override conflicting target switch options.\n-   Doesn't actually detect if more than one -mARCH option is given, but\n-   does handle the case of two blatantly conflicting -mARCH options.  */\n-#define OVERRIDE_OPTIONS  i960_initialize ()\n-\n-/* Don't enable anything by default.  The user is expected to supply a -mARCH\n-   option.  If none is given, then -mka is added by CC1_SPEC.  */\n-#define TARGET_DEFAULT 0\n-\f\n-/* Target machine storage layout.  */\n-\n-/* Define this if most significant bit is lowest numbered\n-   in instructions that operate on numbered bit-fields.  */\n-#define BITS_BIG_ENDIAN 0\n-\n-/* Define this if most significant byte of a word is the lowest numbered.\n-   The i960 case be either big endian or little endian.  We only support\n-   little endian, which is the most common.  */\n-#define BYTES_BIG_ENDIAN 0\n-\n-/* Define this if most significant word of a multiword number is lowest\n-   numbered.  */\n-#define WORDS_BIG_ENDIAN 0\n-\n-/* Bitfields cannot cross word boundaries.  */\n-#define BITFIELD_NBYTES_LIMITED 1\n-\n-/* Width of a word, in units (bytes).  */\n-#define UNITS_PER_WORD 4\n-\n-/* Width in bits of a long double.  */\n-#define\tLONG_DOUBLE_TYPE_SIZE (TARGET_LONG_DOUBLE_64 ? 64 : 128)\n-#define MAX_LONG_DOUBLE_TYPE_SIZE 128\n-\n-/* Define this to set long double type size to use in libgcc2.c, which can\n-   not depend on target_flags.  */\n-#if defined(__LONG_DOUBLE_64__)\n-#define LIBGCC2_LONG_DOUBLE_TYPE_SIZE 64\n-#else\n-#define LIBGCC2_LONG_DOUBLE_TYPE_SIZE 128\n-#endif\n-\n-/* Allocation boundary (in *bits*) for storing pointers in memory.  */\n-#define POINTER_BOUNDARY 32\n-\n-/* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n-#define PARM_BOUNDARY 32\n-\n-/* Boundary (in *bits*) on which stack pointer should be aligned.  */\n-#define STACK_BOUNDARY 128\n-\n-/* Allocation boundary (in *bits*) for the code of a function.  */\n-#define FUNCTION_BOUNDARY 128\n-\n-/* Alignment of field after `int : 0' in a structure.  */\n-#define EMPTY_FIELD_BOUNDARY 32\n-\n-/* This makes zero-length anonymous fields lay the next field\n-   at a word boundary.  It also makes the whole struct have\n-   at least word alignment if there are any bitfields at all.  */\n-#define PCC_BITFIELD_TYPE_MATTERS 1\n-\n-/* Every structure's size must be a multiple of this.  */\n-#define STRUCTURE_SIZE_BOUNDARY 8\n-\n-/* No data type wants to be aligned rounder than this.\n-   Extended precision floats gets 4-word alignment.  */\n-#define BIGGEST_ALIGNMENT 128\n-\n-/* Define this if move instructions will actually fail to work\n-   when given unaligned data.\n-   80960 will work even with unaligned data, but it is slow.  */\n-#define STRICT_ALIGNMENT TARGET_STRICT_ALIGN\n-\n-/* Specify alignment for string literals (which might be higher than the\n-   base type's minimal alignment requirement.  This allows strings to be\n-   aligned on word boundaries, and optimizes calls to the str* and mem*\n-   library functions.  */\n-#define CONSTANT_ALIGNMENT(EXP, ALIGN) \\\n-  (TREE_CODE (EXP) == STRING_CST\t\\\n-   && i960_object_bytes_bitalign (int_size_in_bytes (TREE_TYPE (EXP))) > (int)(ALIGN) \\\n-   ? i960_object_bytes_bitalign (int_size_in_bytes (TREE_TYPE (EXP)))\t    \\\n-   : (int)(ALIGN))\n-\n-/* Macros to determine size of aggregates (structures and unions\n-   in C).  Normally, these may be defined to simply return the maximum\n-   alignment and simple rounded-up size, but on some machines (like\n-   the i960), the total size of a structure is based on a non-trivial\n-   rounding method.  */\n-\n-#define ROUND_TYPE_ALIGN(TYPE, COMPUTED, SPECIFIED) \\\n-  i960_round_align (MAX ((COMPUTED), (SPECIFIED)), TYPE)\n-\f\n-/* Standard register usage.  */\n-\n-/* Number of actual hardware registers.\n-   The hardware registers are assigned numbers for the compiler\n-   from 0 to just below FIRST_PSEUDO_REGISTER.\n-   All registers that the compiler knows about must be given numbers,\n-   even those that are not normally considered general registers.\n-\n-   Registers 0-15 are the global registers (g0-g15).\n-   Registers 16-31 are the local registers (r0-r15).\n-   Register 32-35 are the fp registers (fp0-fp3).\n-   Register 36 is the condition code register.\n-   Register 37 is unused.  */\n-\n-#define FIRST_PSEUDO_REGISTER 38\n-\n-/* 1 for registers that have pervasive standard uses and are not available\n-   for the register allocator.  On 80960, this includes the frame pointer\n-   (g15), the previous FP (r0), the stack pointer (r1), the return\n-   instruction pointer (r2), and the argument pointer (g14).  */\n-#define FIXED_REGISTERS  \\\n- {0, 0, 0, 0, 0, 0, 0, 0,\t\\\n-  0, 0, 0, 0, 0, 0, 1, 1,\t\\\n-  1, 1, 1, 0, 0, 0, 0, 0,\t\\\n-  0, 0, 0, 0, 0, 0, 0, 0,\t\\\n-  0, 0, 0, 0, 1, 1}\n-\n-/* 1 for registers not available across function calls.\n-   These must include the FIXED_REGISTERS and also any\n-   registers that can be used without being saved.\n-   The latter must include the registers where values are returned\n-   and the register where structure-value addresses are passed.\n-   Aside from that, you can include as many other registers as you like.  */\n-\n-/* On the 80960, note that:\n-\tg0..g3 are used for return values,\n-\tg0..g7 may always be used for parameters,\n-\tg8..g11 may be used for parameters, but are preserved if they aren't,\n-\tg12 is the static chain if needed, otherwise is preserved\n-\tg13 is the struct return ptr if used, or temp, but may be trashed,\n-\tg14 is the leaf return ptr or the arg block ptr otherwise zero,\n-\t\tmust be reset to zero before returning if it was used,\n-\tg15 is the frame pointer,\n-\tr0 is the previous FP,\n-\tr1 is the stack pointer,\n-\tr2 is the return instruction pointer,\n-\tr3-r15 are always available,\n-\tr3 is clobbered by calls in functions that use the arg pointer\n-\tr4-r11 may be clobbered by the mcount call when profiling\n-\tr4-r15 if otherwise unused may be used for preserving global registers\n-\tfp0..fp3 are never available.  */\n-#define CALL_USED_REGISTERS  \\\n- {1, 1, 1, 1, 1, 1, 1, 1,\t\\\n-  0, 0, 0, 0, 0, 1, 1, 1,\t\\\n-  1, 1, 1, 0, 0, 0, 0, 0,\t\\\n-  0, 0, 0, 0, 0, 0, 0, 0,\t\\\n-  1, 1, 1, 1, 1, 1}\n-\n-/* If no fp unit, make all of the fp registers fixed so that they can't\n-   be used.  */\n-#define\tCONDITIONAL_REGISTER_USAGE\t\\\n-  if (! TARGET_NUMERICS) {\t\t\t\t\t\t\\\n-     fixed_regs[32] = fixed_regs[33] = fixed_regs[34] = fixed_regs[35] = 1;\\\n-  }\t\t\t\t\t\t\t\t\t\\\n-\n-/* Return number of consecutive hard regs needed starting at reg REGNO\n-   to hold something of mode MODE.\n-   This is ordinarily the length in words of a value of mode MODE\n-   but can be less for certain modes in special long registers.\n-\n-   On 80960, ordinary registers hold 32 bits worth, but can be ganged\n-   together to hold double or extended precision floating point numbers,\n-   and the floating point registers hold any size floating point number */\n-#define HARD_REGNO_NREGS(REGNO, MODE)   \\\n-  ((REGNO) < 32\t\t\t\t\t\t\t\\\n-   ? (((MODE) == VOIDmode)\t\t\t\t\t\\\n-      ? 1 : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)) \\\n-   : ((REGNO) < FIRST_PSEUDO_REGISTER) ? 1 : 0)\n-\n-/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n-   On 80960, the cpu registers can hold any mode but the float registers\n-   can only hold SFmode, DFmode, or TFmode.  */\n-#define HARD_REGNO_MODE_OK(REGNO, MODE) hard_regno_mode_ok ((REGNO), (MODE))\n-\n-/* Value is 1 if it is a good idea to tie two pseudo registers\n-   when one has mode MODE1 and one has mode MODE2.\n-   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n-   for any hard reg, then this must be 0 for correct output.  */\n-\n-#define MODES_TIEABLE_P(MODE1, MODE2) \\\n-  ((MODE1) == (MODE2) || GET_MODE_CLASS (MODE1) == GET_MODE_CLASS (MODE2))\n-\n-/* Specify the registers used for certain standard purposes.\n-   The values of these macros are register numbers.  */\n-\n-/* 80960 pc isn't overloaded on a register that the compiler knows about.  */\n-/* #define PC_REGNUM  */\n-\n-/* Register to use for pushing function arguments.  */\n-#define STACK_POINTER_REGNUM 17\n-\n-/* Actual top-of-stack address is same as\n-   the contents of the stack pointer register.  */\n-#define STACK_POINTER_OFFSET (-current_function_outgoing_args_size)\n-\n-/* Base register for access to local variables of the function.  */\n-#define FRAME_POINTER_REGNUM 15\n-\n-/* Value should be nonzero if functions must have frame pointers.\n-   Zero means the frame pointer need not be set up (and parms\n-   may be accessed via the stack pointer) in functions that seem suitable.\n-   This is computed in `reload', in reload1.c.  */\n-/* ??? It isn't clear to me why this is here.  Perhaps because of a bug (since\n-   fixed) in the definition of INITIAL_FRAME_POINTER_OFFSET which would have\n-   caused this to fail.  */\n-/* ??? Must check current_function_has_nonlocal_goto, otherwise frame pointer\n-  elimination messes up nonlocal goto sequences.  I think this works for other\n-  targets because they use indirect jumps for the return which disables fp\n-  elimination.  */\n-#define FRAME_POINTER_REQUIRED \\\n-  (! leaf_function_p () || current_function_has_nonlocal_goto)\n-\n-/* Definitions for register eliminations.\n-\n-   This is an array of structures.  Each structure initializes one pair\n-   of eliminable registers.  The \"from\" register number is given first,\n-   followed by \"to\".  Eliminations of the same \"from\" register are listed\n-   in order of preference..  */\n-\n-#define ELIMINABLE_REGS\t {{FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM}}\n-\n-/* Given FROM and TO register numbers, say whether this elimination is allowed.\n-   Frame pointer elimination is automatically handled.  */\n-#define CAN_ELIMINATE(FROM, TO) 1\n-\n-/* Define the offset between two registers, one to be eliminated, and\n-   the other its replacement, at the start of a routine.\n-\n-   Since the stack grows upward on the i960, this must be a negative number.\n-   This includes the 64 byte hardware register save area and the size of\n-   the frame.  */\n-\n-#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)\t\t\t\\\n-  do { (OFFSET) = - (64 + compute_frame_size (get_frame_size ())); } while (0)\n-\n-/* Base register for access to arguments of the function.  */\n-#define ARG_POINTER_REGNUM 14\n-\n-/* Register in which static-chain is passed to a function.\n-   On i960, we use g12.  We can't use any local register, because we need\n-   a register that can be set before a call or before a jump.  */\n-#define STATIC_CHAIN_REGNUM 12\n- \n-/* Functions which return large structures get the address\n-   to place the wanted value at in g13.  */\n-\n-#define STRUCT_VALUE_REGNUM 13 \n-\n-/* The order in which to allocate registers.  */\n-\n-#define\tREG_ALLOC_ORDER\t\\\n-{  4, 5, 6, 7, 0, 1, 2, 3, 13,\t /* g4, g5, g6, g7, g0, g1, g2, g3, g13  */ \\\n-  20, 21, 22, 23, 24, 25, 26, 27,/* r4, r5, r6, r7, r8, r9, r10, r11  */    \\\n-  28, 29, 30, 31, 19, 8, 9, 10,\t /* r12, r13, r14, r15, r3, g8, g9, g10  */ \\\n-  11, 12,\t\t\t /* g11, g12  */\t\t\t    \\\n-  32, 33, 34, 35,\t\t /* fp0, fp1, fp2, fp3  */\t\t    \\\n-  /* We can't actually allocate these.  */\t\t\t\t    \\\n-  16, 17, 18, 14, 15, 36, 37}\t /* r0, r1, r2, g14, g15, cc  */\n-\f\n-/* Define the classes of registers for register constraints in the\n-   machine description.  Also define ranges of constants.\n-\n-   One of the classes must always be named ALL_REGS and include all hard regs.\n-   If there is more than one class, another class must be named NO_REGS\n-   and contain no registers.\n-\n-   The name GENERAL_REGS must be the name of a class (or an alias for\n-   another name such as ALL_REGS).  This is the class of registers\n-   that is allowed by \"g\" or \"r\" in a register constraint.\n-   Also, registers outside this class are allocated only when\n-   instructions express preferences for them.\n-\n-   The classes must be numbered in nondecreasing order; that is,\n-   a larger-numbered class must never be contained completely\n-   in a smaller-numbered class.\n-\n-   For any two classes, it is very desirable that there be another\n-   class that represents their union.  */\n-   \n-/* The 80960 has four kinds of registers, global, local, floating point,\n-   and condition code.  The cc register is never allocated, so no class\n-   needs to be defined for it.  */\n-\n-enum reg_class { NO_REGS, GLOBAL_REGS, LOCAL_REGS, LOCAL_OR_GLOBAL_REGS,\n-  FP_REGS, ALL_REGS, LIM_REG_CLASSES };\n-\n-/* 'r' includes floating point registers if TARGET_NUMERICS.  'd' never\n-   does.  */\n-#define\tGENERAL_REGS\t((TARGET_NUMERICS) ? ALL_REGS : LOCAL_OR_GLOBAL_REGS)\n-\n-#define N_REG_CLASSES (int) LIM_REG_CLASSES\n-\n-/* Give names of register classes as strings for dump file.  */\n-\n-#define REG_CLASS_NAMES\t\t\t\t\t\t\t\\\n-{ \"NO_REGS\", \"GLOBAL_REGS\", \"LOCAL_REGS\", \"LOCAL_OR_GLOBAL_REGS\",\t\\\n-  \"FP_REGS\", \"ALL_REGS\" }\n-\n-/* Define which registers fit in which classes.\n-   This is an initializer for a vector of HARD_REG_SET\n-   of length N_REG_CLASSES.  */\n-\n-#define REG_CLASS_CONTENTS\t\\\n-{ {0, 0}, {0x0ffff, 0}, {0xffff0000, 0}, {-1,0}, {0, -1}, {-1,-1}}\n-\n-/* The same information, inverted:\n-   Return the class number of the smallest class containing\n-   reg number REGNO.  This could be a conditional expression\n-   or could index an array.  */\n-\n-#define REGNO_REG_CLASS(REGNO)\t\\\n-  ((REGNO) < 16 ? GLOBAL_REGS\t\\\n-   : (REGNO) < 32 ? LOCAL_REGS\t\\\n-   : (REGNO) < 36 ? FP_REGS\t\\\n-   : NO_REGS)\n-\n-/* The class value for index registers, and the one for base regs.\n-   There is currently no difference between base and index registers on the\n-   i960, but this distinction may one day be useful.  */\n-#define INDEX_REG_CLASS LOCAL_OR_GLOBAL_REGS\n-#define BASE_REG_CLASS LOCAL_OR_GLOBAL_REGS\n-\n-/* Get reg_class from a letter such as appears in the machine description.\n-   'f' is a floating point register (fp0..fp3)\n-   'l' is a local register (r0-r15)\n-   'b' is a global register (g0-g15)\n-   'd' is any local or global register\n-   'r' or 'g' are pre-defined to the class GENERAL_REGS.  */\n-/* 'l' and 'b' are probably never used.  Note that 'd' and 'r' are *not*\n-   the same thing, since 'r' may include the fp registers.  */\n-#define REG_CLASS_FROM_LETTER(C) \\\n-  (((C) == 'f') && (TARGET_NUMERICS) ? FP_REGS : ((C) == 'l' ? LOCAL_REGS : \\\n-    (C) == 'b' ? GLOBAL_REGS : ((C) == 'd' ? LOCAL_OR_GLOBAL_REGS : NO_REGS)))\n-\n-/* The letters I, J, K, L and M in a register constraint string\n-   can be used to stand for particular ranges of immediate operands.\n-   This macro defines what the ranges are.\n-   C is the letter, and VALUE is a constant value.\n-   Return 1 if VALUE is in the range specified by C.\n-\n-   For 80960:\n-\t'I' is used for literal values 0..31\n-   \t'J' means literal 0\n-\t'K' means 0..-31.  */\n-\n-#define CONST_OK_FOR_LETTER_P(VALUE, C)  \t\t\t\t\\\n-  ((C) == 'I' ? (((unsigned) (VALUE)) <= 31)\t\t\t\t\\\n-   : (C) == 'J' ? ((VALUE) == 0)\t\t\t\t\t\\\n-   : (C) == 'K' ? ((VALUE) >= -31 && (VALUE) <= 0)\t\t\t\\\n-   : (C) == 'M' ? ((VALUE) >= -32 && (VALUE) <= 0)\t\t\t\\\n-   : 0)\n-\n-/* Similar, but for floating constants, and defining letters G and H.\n-   Here VALUE is the CONST_DOUBLE rtx itself.\n-   For the 80960, G is 0.0 and H is 1.0.  */\n-\n-#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)\t\t\t\t\\\n-  ((TARGET_NUMERICS) &&\t\t\t\t\t\t\t\\\n-   (((C) == 'G' && (VALUE) == CONST0_RTX (GET_MODE (VALUE)))\t\t\\\n-    || ((C) == 'H' && ((VALUE) == CONST1_RTX (GET_MODE (VALUE))))))\n-\n-/* Given an rtx X being reloaded into a reg required to be\n-   in class CLASS, return the class of reg to actually use.\n-   In general this is just CLASS; but on some machines\n-   in some cases it is preferable to use a more restrictive class.  */\n-\n-/* On 960, can't load constant into floating-point reg except\n-   0.0 or 1.0.\n-\n-   Any hard reg is ok as a src operand of a reload insn.  */\n-\n-#define PREFERRED_RELOAD_CLASS(X,CLASS)\t\t\t\\\n-  (GET_CODE (X) == REG && REGNO (X) < FIRST_PSEUDO_REGISTER\t\\\n-   ? (CLASS)\t\t\t\t\t\t\t\\\n-   : ((CLASS) == FP_REGS && CONSTANT_P (X)\t\t\t\\\n-      && (X) != CONST0_RTX (DFmode) && (X) != CONST1_RTX (DFmode)\\\n-      && (X) != CONST0_RTX (SFmode) && (X) != CONST1_RTX (SFmode)\\\n-      ? NO_REGS\t\t\t\t\t\t\t\\\n-      : (CLASS) == ALL_REGS ? LOCAL_OR_GLOBAL_REGS : (CLASS)))\n-\n-#define SECONDARY_RELOAD_CLASS(CLASS,MODE,IN) \\\n-  secondary_reload_class (CLASS, MODE, IN)\n-\n-/* Return the maximum number of consecutive registers\n-   needed to represent mode MODE in a register of class CLASS.  */\n-/* On 80960, this is the size of MODE in words,\n-   except in the FP regs, where a single reg is always enough.  */\n-#define CLASS_MAX_NREGS(CLASS, MODE)\t\t\t\t\t\\\n-  ((CLASS) == FP_REGS ? 1 : HARD_REGNO_NREGS (0, (MODE)))\n-\f\n-/* Stack layout; function entry, exit and calling.  */\n-\n-/* Define this if pushing a word on the stack\n-   makes the stack pointer a smaller address.  */\n-/* #define STACK_GROWS_DOWNWARD */\n-\n-/* Define this if the nominal address of the stack frame\n-   is at the high-address end of the local variables;\n-   that is, each additional local variable allocated\n-   goes at a more negative offset in the frame.  */\n-/* #define FRAME_GROWS_DOWNWARD */\n-\n-/* Offset within stack frame to start allocating local variables at.\n-   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n-   first local allocated.  Otherwise, it is the offset to the BEGINNING\n-   of the first local allocated.\n-\n-   The i960 has a 64 byte register save area, plus possibly some extra\n-   bytes allocated for varargs functions.  */\n-#define STARTING_FRAME_OFFSET 64\n-\n-/* If we generate an insn to push BYTES bytes,\n-   this says how many the stack pointer really advances by.\n-   On 80960, don't define this because there are no push insns.  */\n-/* #define PUSH_ROUNDING(BYTES) BYTES */\n-\n-/* Offset of first parameter from the argument pointer register value.  */\n-#define FIRST_PARM_OFFSET(FNDECL) 0\n-\n-/* When a parameter is passed in a register, no stack space is\n-   allocated for it.  However, when args are passed in the\n-   stack, space is allocated for every register parameter.  */\n-#define MAYBE_REG_PARM_STACK_SPACE 48\n-#define FINAL_REG_PARM_STACK_SPACE(CONST_SIZE, VAR_SIZE)\t\\\n-  i960_final_reg_parm_stack_space (CONST_SIZE, VAR_SIZE);\n-#define REG_PARM_STACK_SPACE(DECL) i960_reg_parm_stack_space (DECL)\n-#define OUTGOING_REG_PARM_STACK_SPACE\n-\n-/* Keep the stack pointer constant throughout the function.  */\n-#define ACCUMULATE_OUTGOING_ARGS 1\n-\n-/* Value is 1 if returning from a function call automatically\n-   pops the arguments described by the number-of-args field in the call.\n-   FUNDECL is the declaration node of the function (as a tree),\n-   FUNTYPE is the data type of the function (as a tree),\n-   or for a library call it is an identifier node for the subroutine name.  */\n-\n-#define RETURN_POPS_ARGS(FUNDECL,FUNTYPE,SIZE) 0\n-\n-/* Define how to find the value returned by a library function\n-   assuming the value has mode MODE.  */\n-\n-#define LIBCALL_VALUE(MODE) gen_rtx_REG ((MODE), 0)\n-\n-/* 1 if N is a possible register number for a function value\n-   as seen by the caller.\n-   On 80960, returns are in g0..g3 */\n-\n-#define FUNCTION_VALUE_REGNO_P(N) ((N) == 0)\n-\n-/* 1 if N is a possible register number for function argument passing.\n-   On 80960, parameters are passed in g0..g11 */\n-\n-#define FUNCTION_ARG_REGNO_P(N) ((N) < 12)\n-\n-/* Perform any needed actions needed for a function that is receiving a\n-   variable number of arguments. \n-\n-   CUM is as above.\n-\n-   MODE and TYPE are the mode and type of the current parameter.\n-\n-   PRETEND_SIZE is a variable that should be set to the amount of stack\n-   that must be pushed by the prolog to pretend that our caller pushed\n-   it.\n-\n-   Normally, this macro will push all remaining incoming registers on the\n-   stack and set PRETEND_SIZE to the length of the registers pushed.  */\n-\n-#define SETUP_INCOMING_VARARGS(CUM,MODE,TYPE,PRETEND_SIZE,NO_RTL) \\\n-  i960_setup_incoming_varargs(&CUM,MODE,TYPE,&PRETEND_SIZE,NO_RTL)\n-\n-/* Implement `va_start' for varargs and stdarg.  */\n-#define EXPAND_BUILTIN_VA_START(valist, nextarg) \\\n-  i960_va_start (valist, nextarg)\n-\n-/* Implement `va_arg'.  */\n-#define EXPAND_BUILTIN_VA_ARG(valist, type) \\\n-  i960_va_arg (valist, type)\n-\f\n-/* Define a data type for recording info about an argument list\n-   during the scan of that argument list.  This data type should\n-   hold all necessary information about the function itself\n-   and about the args processed so far, enough to enable macros\n-   such as FUNCTION_ARG to determine where the next arg should go.\n-\n-   On 80960, this is two integers, which count the number of register\n-   parameters and the number of stack parameters seen so far.  */\n-\n-struct cum_args { int ca_nregparms; int ca_nstackparms; };\n-\n-#define CUMULATIVE_ARGS struct cum_args\n-\n-/* Define the number of registers that can hold parameters.\n-   This macro is used only in macro definitions below and/or i960.c.  */\n-#define NPARM_REGS 12\n-\n-/* Define how to round to the next parameter boundary.\n-   This macro is used only in macro definitions below and/or i960.c.  */\n-#define ROUND_PARM(X, MULTIPLE_OF)\t\\\n-  ((((X) + (MULTIPLE_OF) - 1) / (MULTIPLE_OF)) * MULTIPLE_OF)\n-\n-/* Initialize a variable CUM of type CUMULATIVE_ARGS\n-   for a call to a function whose data type is FNTYPE.\n-   For a library call, FNTYPE is 0.\n-\n-   On 80960, the offset always starts at 0; the first parm reg is g0.  */\n-\n-#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME,INDIRECT)\t\\\n-  ((CUM).ca_nregparms = 0, (CUM).ca_nstackparms = 0)\n-\n-/* Update the data in CUM to advance over an argument\n-   of mode MODE and data type TYPE.\n-   CUM should be advanced to align with the data type accessed and\n-   also the size of that data type in # of regs.\n-   (TYPE is null for libcalls where that information may not be available.)  */\n-\n-#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n-  i960_function_arg_advance(&CUM, MODE, TYPE, NAMED)\n-\n-/* Indicate the alignment boundary for an argument of the specified mode and\n-   type.  */\n-#define FUNCTION_ARG_BOUNDARY(MODE, TYPE)\t\t\t\t\\\n-  (((TYPE) != 0)\t\t\t\t\t\t\t\\\n-   ? ((TYPE_ALIGN (TYPE) <= PARM_BOUNDARY)\t\t\t\t\\\n-      ? PARM_BOUNDARY\t\t\t\t\t\t\t\\\n-      : TYPE_ALIGN (TYPE))\t\t\t\t\t\t\\\n-   : ((GET_MODE_ALIGNMENT (MODE) <= PARM_BOUNDARY)\t\t\t\\\n-      ? PARM_BOUNDARY\t\t\t\t\t\t\t\\\n-      : GET_MODE_ALIGNMENT (MODE)))\n-\n-/* Determine where to put an argument to a function.\n-   Value is zero to push the argument on the stack,\n-   or a hard register in which to store the argument.\n-\n-   MODE is the argument's machine mode.\n-   TYPE is the data type of the argument (as a tree).\n-    This is null for libcalls where that information may\n-    not be available.\n-   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n-    the preceding args and about the function being called.\n-   NAMED is nonzero if this argument is a named parameter\n-    (otherwise it is an extra parameter matching an ellipsis).  */\n-\n-#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED)\t\\\n-  i960_function_arg(&CUM, MODE, TYPE, NAMED)\n-\n-/* Define how to find the value returned by a function.\n-   VALTYPE is the data type of the value (as a tree).\n-   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n-   otherwise, FUNC is 0.  */\n-\n-#define FUNCTION_VALUE(TYPE, FUNC) \\\n-  gen_rtx_REG (TYPE_MODE (TYPE), 0)\n-\n-/* Force aggregates and objects larger than 16 bytes to be returned in memory,\n-   since we only have 4 registers available for return values.  */\n-\n-#define RETURN_IN_MEMORY(TYPE) \\\n-  (TYPE_MODE (TYPE) == BLKmode || int_size_in_bytes (TYPE) > 16)\n-\n-/* Don't default to pcc-struct-return, because we have already specified\n-   exactly how to return structures in the RETURN_IN_MEMORY macro.  */\n-#define DEFAULT_PCC_STRUCT_RETURN 0\n-\n-/* For an arg passed partly in registers and partly in memory,\n-   this is the number of registers used.\n-   This never happens on 80960.  */\n-\n-#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) 0\n-\f\n-/* Output the label for a function definition.\n-  This handles leaf functions and a few other things for the i960.  */\n-\n-#define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)\t\\\n-  i960_function_name_declare (FILE, NAME, DECL)\n-\n-/* Output assembler code to FILE to increment profiler label # LABELNO\n-   for profiling a function entry.  */\n-\n-#define FUNCTION_PROFILER(FILE, LABELNO)\t\\\n-  output_function_profiler ((FILE), (LABELNO));\n-\n-/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n-   the stack pointer does not matter.  The value is tested only in\n-   functions that have frame pointers.\n-   No definition is equivalent to always zero.  */\n-\n-#define\tEXIT_IGNORE_STACK 1\n-\f\n-/* Addressing modes, and classification of registers for them.  */\n-\n-/* Macros to check register numbers against specific register classes.  */\n-\n-/* These assume that REGNO is a hard or pseudo reg number.\n-   They give nonzero only if REGNO is a hard reg of the suitable class\n-   or a pseudo reg currently allocated to a suitable hard reg.\n-   Since they use reg_renumber, they are safe only once reg_renumber\n-   has been allocated, which happens in local-alloc.c.  */\n-\n-#define REGNO_OK_FOR_INDEX_P(REGNO) \\\n-  ((REGNO) < 32 || (unsigned) reg_renumber[REGNO] < 32)\n-#define REGNO_OK_FOR_BASE_P(REGNO) \\\n-  ((REGNO) < 32 || (unsigned) reg_renumber[REGNO] < 32)\n-#define REGNO_OK_FOR_FP_P(REGNO) \\\n-  ((REGNO) < 36 || (unsigned) reg_renumber[REGNO] < 36)\n-\n-/* Now macros that check whether X is a register and also,\n-   strictly, whether it is in a specified class.\n-\n-   These macros are specific to the 960, and may be used only\n-   in code for printing assembler insns and in conditions for\n-   define_optimization.  */\n-\n-/* 1 if X is an fp register.  */\n-\n-#define FP_REG_P(X) (REGNO (X) >= 32 && REGNO (X) < 36)\n-\n-/* Maximum number of registers that can appear in a valid memory address.  */\n-#define\tMAX_REGS_PER_ADDRESS 2\n-\n-#define CONSTANT_ADDRESS_P(X)   \\\n-  (GET_CODE (X) == LABEL_REF || GET_CODE (X) == SYMBOL_REF\t\t\\\n-   || GET_CODE (X) == CONST_INT || GET_CODE (X) == CONST\t\t\\\n-   || GET_CODE (X) == HIGH)\n-\n-/* LEGITIMATE_CONSTANT_P is nonzero if the constant value X\n-   is a legitimate general operand.\n-   It is given that X satisfies CONSTANT_P.\n-\n-   Anything but a CONST_DOUBLE can be made to work, excepting 0.0 and 1.0.\n-\n-   ??? This probably should be defined to 1.  */\n-\n-#define LEGITIMATE_CONSTANT_P(X) \\\n-  ((GET_CODE (X) != CONST_DOUBLE) || fp_literal ((X), GET_MODE (X)))\n-\n-/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n-   and check its validity for a certain class.\n-   We have two alternate definitions for each of them.\n-   The usual definition accepts all pseudo regs; the other rejects\n-   them unless they have been allocated suitable hard regs.\n-   The symbol REG_OK_STRICT causes the latter definition to be used.\n-\n-   Most source files want to accept pseudo regs in the hope that\n-   they will get allocated to the class that the insn wants them to be in.\n-   Source files for reload pass need to be strict.\n-   After reload, it makes no difference, since pseudo regs have\n-   been eliminated by then.  */\n-\n-#ifndef REG_OK_STRICT\n-\n-/* Nonzero if X is a hard reg that can be used as an index\n-   or if it is a pseudo reg.  */\n-#define REG_OK_FOR_INDEX_P(X) \\\n-  (REGNO (X) < 32 || REGNO (X) >= FIRST_PSEUDO_REGISTER)\n-/* Nonzero if X is a hard reg that can be used as a base reg\n-   or if it is a pseudo reg.  */\n-#define REG_OK_FOR_BASE_P(X) \\\n-  (REGNO (X) < 32 || REGNO (X) >= FIRST_PSEUDO_REGISTER)\n-\n-#define REG_OK_FOR_INDEX_P_STRICT(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n-#define REG_OK_FOR_BASE_P_STRICT(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n-\n-#else\n-\n-/* Nonzero if X is a hard reg that can be used as an index.  */\n-#define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n-/* Nonzero if X is a hard reg that can be used as a base reg.  */\n-#define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n-\n-#endif\n-\f\n-/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n-   that is a valid memory address for an instruction.\n-   The MODE argument is the machine mode for the MEM expression\n-   that wants to use this address.\n-\n-\tOn 80960, legitimate addresses are:\n-\t\tbase\t\t\t\tld\t(g0),r0\n-\t\tdisp\t(12 or 32 bit)\t\tld\tfoo,r0\n-\t\tbase + index\t\t\tld\t(g0)[g1*1],r0\n-\t\tbase + displ\t\t\tld\t0xf00(g0),r0\n-\t\tbase + index*scale + displ\tld\t0xf00(g0)[g1*4],r0\n-\t\tindex*scale + base\t\tld\t(g0)[g1*4],r0\n-\t\tindex*scale + displ\t\tld\t0xf00[g1*4],r0\n-\t\tindex*scale\t\t\tld\t[g1*4],r0\n-\t\tindex + base + displ\t\tld\t0xf00(g0)[g1*1],r0\n-\n-\tIn each case, scale can be 1, 2, 4, 8, or 16.  */\n-\n-/* Returns 1 if the scale factor of an index term is valid.  */\n-#define SCALE_TERM_P(X)\t\t\t\t\t\t\t\\\n-  (GET_CODE (X) == CONST_INT\t\t\t\t\t\t\\\n-   && (INTVAL (X) == 1 || INTVAL (X) == 2 || INTVAL (X) == 4 \t\t\\\n-       || INTVAL(X) == 8 || INTVAL (X) == 16))\n-\n-\n-#ifdef REG_OK_STRICT\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR) \\\n-  { if (legitimate_address_p (MODE, X, 1)) goto ADDR; }\n-#else\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR) \\\n-  { if (legitimate_address_p (MODE, X, 0)) goto ADDR; }\n-#endif\n-\f\n-/* Try machine-dependent ways of modifying an illegitimate address\n-   to be legitimate.  If we find one, return the new, valid address.\n-   This macro is used in only one place: `memory_address' in explow.c.\n-\n-   OLDX is the address as it was before break_out_memory_refs was called.\n-   In some cases it is useful to look at this to decide what needs to be done.\n-\n-   MODE and WIN are passed so that this macro can use\n-   GO_IF_LEGITIMATE_ADDRESS.\n-\n-   It is always safe for this macro to do nothing.  It exists to recognize\n-   opportunities to optimize the output.  */\n-\n-/* On 80960, convert non-canonical addresses to canonical form.  */\n-\n-#define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)\t\\\n-{ rtx orig_x = (X);\t\t\t\t\\\n-  (X) = legitimize_address (X, OLDX, MODE);\t\\\n-  if ((X) != orig_x && memory_address_p (MODE, X)) \\\n-    goto WIN; }\n-\n-/* Go to LABEL if ADDR (a legitimate address expression)\n-   has an effect that depends on the machine mode it is used for.\n-   On the 960 this is never true.  */\n-\n-#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)\n-\f\n-/* Specify the machine mode that this machine uses\n-   for the index in the tablejump instruction.  */\n-#define CASE_VECTOR_MODE SImode\n-\n-/* Define as C expression which evaluates to nonzero if the tablejump\n-   instruction expects the table to contain offsets from the address of the\n-   table.\n-   Do not define this if the table should contain absolute addresses.  */\n-/* #define CASE_VECTOR_PC_RELATIVE 1 */\n-\n-/* Define this as 1 if `char' should by default be signed; else as 0.  */\n-#define DEFAULT_SIGNED_CHAR 0\n-\n-/* Max number of bytes we can move from memory to memory\n-   in one reasonably fast instruction.  */\n-#define MOVE_MAX 16\n-\n-/* Define if operations between registers always perform the operation\n-   on the full register even if a narrower mode is specified.  */\n-#define WORD_REGISTER_OPERATIONS\n-\n-/* Define if loading in MODE, an integral mode narrower than BITS_PER_WORD\n-   will either zero-extend or sign-extend.  The value of this macro should\n-   be the code that says which one of the two operations is implicitly\n-   done, NIL if none.  */\n-#define LOAD_EXTEND_OP(MODE) ZERO_EXTEND\n-\n-/* Nonzero if access to memory by bytes is no faster than for words.\n-   Value changed to 1 after reports of poor bit-field code with g++.\n-   Indications are that code is usually as good, sometimes better.  */   \n-\n-#define SLOW_BYTE_ACCESS 1\n-\n-/* Define this to be nonzero if shift instructions ignore all but the low-order\n-   few bits.  */\n-#define SHIFT_COUNT_TRUNCATED 0\n-\n-/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n-   is done just by pretending it is already truncated.  */\n-#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n-\n-/* Specify the machine mode that pointers have.\n-   After generation of rtl, the compiler makes no further distinction\n-   between pointers and any other objects of this machine mode.  */\n-#define Pmode SImode\n-\n-/* Specify the widest mode that BLKmode objects can be promoted to */\n-#define\tMAX_FIXED_MODE_SIZE GET_MODE_BITSIZE (TImode)\n-\f\n-/* These global variables are used to pass information between\n-   cc setter and cc user at insn emit time.  */\n-\n-extern struct rtx_def *i960_compare_op0, *i960_compare_op1;\n-\n-/* Given a comparison code (EQ, NE, etc.) and the first operand of a COMPARE,\n-   return the mode to be used for the comparison.  For floating-point, CCFPmode\n-   should be used.  CC_NOOVmode should be used when the first operand is a\n-   PLUS, MINUS, or NEG.  CCmode should be used when no special processing is\n-   needed.  */\n-#define SELECT_CC_MODE(OP,X,Y) select_cc_mode (OP, X)\n-\n-/* A function address in a call instruction is a byte address\n-   (for indexing purposes) so give the MEM rtx a byte's mode.  */\n-#define FUNCTION_MODE SImode\n-\n-/* Define this if addresses of constant functions\n-   shouldn't be put through pseudo regs where they can be cse'd.\n-   Desirable on machines where ordinary constants are expensive\n-   but a CALL with constant address is cheap.  */\n-#define NO_FUNCTION_CSE\n-\n-/* Use memcpy, etc. instead of bcopy.  */\n-\n-#ifndef WIND_RIVER\n-#define\tTARGET_MEM_FUNCTIONS\t1\n-#endif\n-\f\n-/* Control the assembler format that we output.  */\n-\n-/* Output to assembler file text saying following lines\n-   may contain character constants, extra white space, comments, etc.  */\n-\n-#define ASM_APP_ON \"\"\n-\n-/* Output to assembler file text saying following lines\n-   no longer contain unusual constructs.  */\n-\n-#define ASM_APP_OFF \"\"\n-\n-/* Output before read-only data.  */\n-\n-#define TEXT_SECTION_ASM_OP \"\\t.text\"\n-\n-/* Output before writable data.  */\n-\n-#define DATA_SECTION_ASM_OP \"\\t.data\"\n-\n-/* How to refer to registers in assembler output.\n-   This sequence is indexed by compiler's hard-register-number (see above).  */\n-\n-#define REGISTER_NAMES {\t\t\t\t\t\t\\\n-\t\"g0\", \"g1\", \"g2\",  \"g3\",  \"g4\",  \"g5\",  \"g6\",  \"g7\",\t\t\\\n-\t\"g8\", \"g9\", \"g10\", \"g11\", \"g12\", \"g13\", \"g14\", \"fp\",\t\t\\\n-\t\"pfp\",\"sp\", \"rip\", \"r3\",  \"r4\",  \"r5\",  \"r6\",  \"r7\",\t\t\\\n-\t\"r8\", \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\",\t\t\\\n-\t\"fp0\",\"fp1\",\"fp2\", \"fp3\", \"cc\", \"fake\" }\n-\n-/* How to renumber registers for dbx and gdb.\n-   In the 960 encoding, g0..g15 are registers 16..31.  */\n-\n-#define DBX_REGISTER_NUMBER(REGNO)\t\t\t\t\t\\\n-  (((REGNO) < 16) ? (REGNO) + 16\t\t\t\t\t\\\n-   : (((REGNO) > 31) ? (REGNO) : (REGNO) - 16))\n-\n-/* Don't emit dbx records longer than this.  This is an arbitrary value.  */\n-#define DBX_CONTIN_LENGTH 1500\n-\n-/* This is how to output a note to DBX telling it the line number\n-   to which the following sequence of instructions corresponds.  */\n-\n-#define ASM_OUTPUT_SOURCE_LINE(FILE, LINE, COUNTER)\t\t\\\n-{ if (write_symbols == SDB_DEBUG) {\t\t\t\t\\\n-    fprintf ((FILE), \"\\t.ln\t%d\\n\",\t\t\t\t\\\n-\t     (sdb_begin_function_line\t\t\t\t\\\n-\t      ? (LINE) - sdb_begin_function_line : 1));\t\t\\\n-  } else if (write_symbols == DBX_DEBUG) {\t\t\t\\\n-\tfprintf((FILE),\"\\t.stabd\t68,0,%d\\n\",(LINE));\t\\\n-  } }\n-\n-/* Globalizing directive for a label.  */\n-#define GLOBAL_ASM_OP \"\\t.globl \"\n-\n-/* The prefix to add to user-visible assembler symbols.  */\n-\n-#define USER_LABEL_PREFIX \"_\"\n-\n-/* This is how to store into the string LABEL\n-   the symbol_ref name of an internal numbered label where\n-   PREFIX is the class of label and NUM is the number within the class.\n-   This is suitable for output with `assemble_name'.  */\n-\n-#define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)\t\\\n-  sprintf (LABEL, \"*%s%lu\", PREFIX, (unsigned long)(NUM))\n-\n-#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)  \\\n-  fprintf (FILE, \"\\tst\\t%s,(sp)\\n\\taddo\\t4,sp,sp\\n\", reg_names[REGNO])\n-\n-/* This is how to output an insn to pop a register from the stack.\n-   It need not be very fast code.  */\n-\n-#define ASM_OUTPUT_REG_POP(FILE,REGNO)  \\\n-  fprintf (FILE, \"\\tsubo\\t4,sp,sp\\n\\tld\\t(sp),%s\\n\", reg_names[REGNO])\n-\n-/* This is how to output an element of a case-vector that is absolute.  */\n-\n-#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n-  fprintf (FILE, \"\\t.word L%d\\n\", VALUE)\n-\n-/* This is how to output an element of a case-vector that is relative.  */\n-\n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)  \\\n-  fprintf (FILE, \"\\t.word L%d-L%d\\n\", VALUE, REL)\n-\n-/* This is how to output an assembler line that says to advance the\n-   location counter to a multiple of 2**LOG bytes.  */\n-\n-#define ASM_OUTPUT_ALIGN(FILE,LOG)\t\\\n-  fprintf (FILE, \"\\t.align %d\\n\", (LOG))\n-\n-#define ASM_OUTPUT_SKIP(FILE,SIZE)  \\\n-  fprintf (FILE, \"\\t.space %d\\n\", (int)(SIZE))\n-\n-/* This says how to output an assembler line\n-   to define a global common symbol.  */\n-\n-/* For common objects, output unpadded size... gld960 & lnk960 both\n-   have code to align each common object at link time.  Also, if size\n-   is 0, treat this as a declaration, not a definition - i.e.,\n-   do nothing at all.  */\n-\n-#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)\t\\\n-{ if ((SIZE) != 0)\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      fputs (\".globl \", (FILE)),\t\t\t\\\n-      assemble_name ((FILE), (NAME)),\t\t\t\\\n-      fputs (\"\\n.comm \", (FILE)),\t\t\t\\\n-      assemble_name ((FILE), (NAME)),\t\t\t\\\n-      fprintf ((FILE), \",%d\\n\", (int)(SIZE));\t\t\\\n-    }\t\t\t\t\t\t\t\\\n-}\n-\n-/* This says how to output an assembler line to define a local common symbol.\n-   Output unpadded size, with request to linker to align as requested.\n-   0 size should not be possible here.  */\n-\n-#define ASM_OUTPUT_ALIGNED_LOCAL(FILE, NAME, SIZE, ALIGN)  \\\n-( fputs (\".bss\\t\", (FILE)),\t\t\t\\\n-  assemble_name ((FILE), (NAME)),\t\t\\\n-  fprintf ((FILE), \",%d,%d\\n\", (int)(SIZE),\t\\\n-\t   (floor_log2 ((ALIGN) / BITS_PER_UNIT))))\n-\n-/* A C statement (sans semicolon) to output to the stdio stream\n-   FILE the assembler definition of uninitialized global DECL named\n-   NAME whose size is SIZE bytes and alignment is ALIGN bytes.\n-   Try to use asm_output_aligned_bss to implement this macro.  */\n-\n-#define ASM_OUTPUT_ALIGNED_BSS(FILE, DECL, NAME, SIZE, ALIGN)\t\\\n-  do {\t\t\t\t\t\t\t\t\\\n-    ASM_OUTPUT_ALIGNED_LOCAL (FILE, NAME, SIZE, ALIGN);\t\t\\\n-  } while (0)\n-\n-/* Output text for an #ident directive.  */\n-#define\tASM_OUTPUT_IDENT(FILE, STR)  fprintf(FILE, \"\\t# %s\\n\", STR);\n-\n-/* Align code to 8 byte boundary if TARGET_CODE_ALIGN is true.  */\n-\n-#define\tLABEL_ALIGN_AFTER_BARRIER(LABEL) (TARGET_CODE_ALIGN ? 3 : 0)\n-\n-\f\n-/* Print operand X (an rtx) in assembler syntax to file FILE.\n-   CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n-   For `%' followed by punctuation, CODE is the punctuation and X is null.  */\n-\n-#define PRINT_OPERAND(FILE, X, CODE)  \\\n-  i960_print_operand (FILE, X, CODE);\n-\n-/* Print a memory address as an operand to reference that memory location.  */\n-\n-#define PRINT_OPERAND_ADDRESS(FILE, ADDR)\t\\\n-  i960_print_operand_addr (FILE, ADDR)\n-\n-/* Determine which codes are valid without a following integer.  These must\n-   not be alphabetic (the characters are chosen so that\n-   PRINT_OPERAND_PUNCT_VALID_P translates into a simple range change when\n-   using ASCII).  */\n-\n-#define PRINT_OPERAND_PUNCT_VALID_P(CODE)   ((CODE) == '+')\n-\f\n-/* Output assembler code for a block containing the constant parts\n-   of a trampoline, leaving space for the variable parts.  */\n-\n-/* On the i960, the trampoline contains three instructions:\n-     ldconst _function, r4\n-     ldconst static addr, g12\n-     jump (r4)  */\n-\n-#define TRAMPOLINE_TEMPLATE(FILE)\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  assemble_aligned_integer (UNITS_PER_WORD, GEN_INT (0x8C203000));\t\\\n-  assemble_aligned_integer (UNITS_PER_WORD, GEN_INT (0x00000000));\t\\\n-  assemble_aligned_integer (UNITS_PER_WORD, GEN_INT (0x8CE03000));\t\\\n-  assemble_aligned_integer (UNITS_PER_WORD, GEN_INT (0x00000000));\t\\\n-  assemble_aligned_integer (UNITS_PER_WORD, GEN_INT (0x84212000));\t\\\n-}\n-\n-/* Length in units of the trampoline for entering a nested function.  */\n-\n-#define TRAMPOLINE_SIZE 20\n-\n-/* Emit RTL insns to initialize the variable parts of a trampoline.\n-   FNADDR is an RTX for the address of the function's pure code.\n-   CXT is an RTX for the static chain value for the function.  */\n-\n-#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (TRAMP, 4)), FNADDR); \\\n-  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (TRAMP, 12)), CXT); \\\n-}\n-\n-/* Generate RTL to flush the register windows so as to make arbitrary frames\n-   available.  */\n-#define SETUP_FRAME_ADDRESSES()\t\t\\\n-  emit_insn (gen_flush_register_windows ())\n-\n-#define BUILTIN_SETJMP_FRAME_VALUE hard_frame_pointer_rtx\n-\n-#if 0\n-/* Promote char and short arguments to ints, when want compatibility with\n-   the iC960 compilers.  */\n-\n-/* ??? In order for this to work, all users would need to be changed\n-   to test the value of the macro at run time.  */\n-#define PROMOTE_PROTOTYPES\tTARGET_CLEAN_LINKAGE\n-/* ??? This does not exist.  */\n-#define PROMOTE_RETURN\t\tTARGET_CLEAN_LINKAGE\n-#endif\n-\n-/* Instruction type definitions.  Used to alternate instructions types for\n-   better performance on the C series chips.  */\n-\n-enum insn_types { I_TYPE_REG, I_TYPE_MEM, I_TYPE_CTRL };\n-\n-/* Holds the insn type of the last insn output to the assembly file.  */\n-\n-extern enum insn_types i960_last_insn_type;\n-\n-/* Parse opcodes, and set the insn last insn type based on them.  */\n-\n-#define ASM_OUTPUT_OPCODE(FILE, INSN)\ti960_scan_opcode (INSN)\n-\n-/* Table listing what rtl codes each predicate in i960.c will accept.  */\n-\n-#define PREDICATE_CODES \\\n-  {\"fpmove_src_operand\", {CONST_INT, CONST_DOUBLE, CONST, SYMBOL_REF,\t\\\n-\t\t\t  LABEL_REF, SUBREG, REG, MEM}},\t\t\\\n-  {\"arith_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\t\\\n-  {\"logic_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\t\\\n-  {\"fp_arith_operand\", {SUBREG, REG, CONST_DOUBLE}},\t\t\t\\\n-  {\"signed_arith_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n-  {\"literal\", {CONST_INT}},\t\t\t\t\t\t\\\n-  {\"fp_literal_one\", {CONST_DOUBLE}},\t\t\t\t\t\\\n-  {\"fp_literal_double\", {CONST_DOUBLE}},\t\t\t\t\\\n-  {\"fp_literal\", {CONST_DOUBLE}},\t\t\t\t\t\\\n-  {\"signed_literal\", {CONST_INT}},\t\t\t\t\t\\\n-  {\"symbolic_memory_operand\", {SUBREG, MEM}},\t\t\t\t\\\n-  {\"eq_or_neq\", {EQ, NE}},\t\t\t\t\t\t\\\n-  {\"arith32_operand\", {SUBREG, REG, LABEL_REF, SYMBOL_REF, CONST_INT,\t\\\n-\t\t       CONST_DOUBLE, CONST}},\t\t\t\t\\\n-  {\"power2_operand\", {CONST_INT}},\t\t\t\t\t\\\n-  {\"cmplpower2_operand\", {CONST_INT}},\n-\n-/* Defined in reload.c, and used in insn-recog.c.  */\n-\n-extern int rtx_equal_function_value_matters;"}, {"sha": "ad1678a7077a5237285404f13f8dc4a2bb7a3bde", "filename": "gcc/config/i960/i960.md", "status": "removed", "additions": 0, "deletions": 2818, "changes": 2818, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fi960%2Fi960.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fi960%2Fi960.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.md?ref=c3bf16ff7dec47581f450b1a486cfdf9d566927e", "patch": "@@ -1,2818 +0,0 @@\n-;;- Machine description for Intel 80960 chip for GNU C compiler\n-;;   Copyright (C) 1992, 1995, 1998, 2001 Free Software Foundation, Inc.\n-;;   Contributed by Steven McGeady, Intel Corp.\n-;;   Additional work by Glenn Colon-Bonet, Jonathan Shapiro, Andy Wilson\n-;;   Converted to GCC 2.0 by Jim Wilson and Michael Tiemann, Cygnus Support.\n-\n-;; This file is part of GCC.\n-\n-;; GCC is free software; you can redistribute it and/or modify\n-;; it under the terms of the GNU General Public License as published by\n-;; the Free Software Foundation; either version 2, or (at your option)\n-;; any later version.\n-\n-;; GCC is distributed in the hope that it will be useful,\n-;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n-;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-;; GNU General Public License for more details.\n-\n-;; You should have received a copy of the GNU General Public License\n-;; along with GCC; see the file COPYING.  If not, write to\n-;; the Free Software Foundation, 59 Temple Place - Suite 330,\n-;; Boston, MA 02111-1307, USA.\n-\n-;;- See file \"rtl.def\" for documentation on define_insn, match_*, et. al.\n-\f\n-;; There are very few (4) 'f' registers, they can't be loaded/stored from/to\n-;; memory, and some instructions explicitly require them, so we get better\n-;; code by discouraging pseudo-registers from being allocated to them.\n-;; However, we do want to allow all patterns which can store to them to\n-;; include them in their constraints, so we always use '*f' in a destination\n-;; constraint except when 'f' is the only alternative.\n-\f\n-;; Insn attributes which describe the i960.\n-\n-;; Modscan is not used, since the compiler never emits any of these insns.\n-(define_attr \"type\"\n-  \"move,arith,alu2,mult,div,modscan,load,store,branch,call,address,compare,fpload,fpstore,fpmove,fpcvt,fpcc,fpadd,fpmul,fpdiv,multi,misc\"\n-  (const_string \"arith\"))\n-\n-;; Length (in # of insns).\n-(define_attr \"length\" \"\"\n-  (cond [(eq_attr \"type\" \"load,fpload\")\n-\t      (if_then_else (match_operand 1 \"symbolic_memory_operand\" \"\")\n-\t\t\t    (const_int 2)\n-\t\t\t    (const_int 1))\n-\t (eq_attr \"type\" \"store,fpstore\")\n-\t      (if_then_else (match_operand 0 \"symbolic_memory_operand\" \"\")\n-\t\t\t    (const_int 2)\n-\t\t\t    (const_int 1))\n-\t (eq_attr \"type\" \"address\")\n-\t      (const_int 2)]\n-\t(const_int 1)))\n-\n-(define_asm_attributes\n-  [(set_attr \"length\" \"1\")\n-   (set_attr \"type\" \"multi\")])\n-\n-;; (define_function_unit {name} {num-units} {n-users} {test}\n-;;                       {ready-delay} {issue-delay} [{conflict-list}])\n-\n-;; The integer ALU\n-(define_function_unit \"alu\" 2 0 (eq_attr \"type\" \"arith,compare,move,address\") 1 0)\n-(define_function_unit \"alu\" 2 0 (eq_attr \"type\" \"alu2\") 2 0)\n-(define_function_unit \"alu\" 2 0 (eq_attr \"type\" \"mult\") 5 0)\n-(define_function_unit \"alu\" 2 0 (eq_attr \"type\" \"div\") 35 0)\n-(define_function_unit \"alu\" 2 0 (eq_attr \"type\" \"modscan\") 3 0)\n-\n-;; Memory with load-delay of 1 (i.e., 2 cycle load).\n-(define_function_unit \"memory\" 1 0 (eq_attr \"type\" \"load,fpload\") 2 0)\n-\n-;; Floating point operations.\n-(define_function_unit \"fp\" 1 2 (eq_attr \"type\" \"fpmove\") 5 0)\n-(define_function_unit \"fp\" 1 2 (eq_attr \"type\" \"fpcvt\") 35 0)\n-(define_function_unit \"fp\" 1 2 (eq_attr \"type\" \"fpcc\") 10 0)\n-(define_function_unit \"fp\" 1 2 (eq_attr \"type\" \"fpadd\") 10 0)\n-(define_function_unit \"fp\" 1 2 (eq_attr \"type\" \"fpmul\") 20 0)\n-(define_function_unit \"fp\" 1 2 (eq_attr \"type\" \"fpdiv\") 35 0)\n-\f\n-;; Compare instructions.\n-;; This controls RTL generation and register allocation.\n-\n-;; We generate RTL for comparisons and branches by having the cmpxx \n-;; patterns store away the operands.  Then, the scc and bcc patterns\n-;; emit RTL for both the compare and the branch.\n-;;\n-;; We start with the DEFINE_EXPANDs, then DEFINE_INSNs to match\n-;; the patterns.  Finally, we have the DEFINE_SPLITs for some of the scc\n-;; insns that actually require more than one machine instruction.\n-\n-;; Put cmpsi first because it is expected to be the most common.\n-\n-(define_expand \"cmpsi\"\n-  [(set (reg:CC 36)\n-\t(compare:CC (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n-\t\t    (match_operand:SI 1 \"general_operand\" \"\")))]\n-  \"\"\n-  \"\n-{\n-  i960_compare_op0 = operands[0];\n-  i960_compare_op1 = operands[1];\n-  DONE;\n-}\")\n-\n-(define_expand \"cmpdf\"\n-  [(set (reg:CC 36)\n-\t(compare:CC (match_operand:DF 0 \"register_operand\" \"r\")\n-\t\t    (match_operand:DF 1 \"nonmemory_operand\" \"rGH\")))]\n-  \"TARGET_NUMERICS\"\n-  \"\n-{\n-  i960_compare_op0 = operands[0];\n-  i960_compare_op1 = operands[1];\n-  DONE;\n-}\")\n-\n-(define_expand \"cmpsf\"\n-  [(set (reg:CC 36)\n-\t(compare:CC (match_operand:SF 0 \"register_operand\" \"r\")\n-\t\t    (match_operand:SF 1 \"nonmemory_operand\" \"rGH\")))]\n-  \"TARGET_NUMERICS\"\n-  \"\n-{\n-  i960_compare_op0 = operands[0];\n-  i960_compare_op1 = operands[1];\n-  DONE;\n-}\")\n-\n-;; Now the DEFINE_INSNs for the compare and scc cases.  First the compares.\n-\n-(define_insn \"\"\n-  [(set (reg:CC 36)\n-\t(compare:CC (match_operand:SI 0 \"register_operand\" \"d\")\n-\t\t    (match_operand:SI 1 \"arith_operand\" \"dI\")))]\n-  \"\"\n-  \"cmpi\t%0,%1\"\n-  [(set_attr \"type\" \"compare\")])\n-\n-(define_insn \"\"\n-  [(set (reg:CC_UNS 36)\n-\t(compare:CC_UNS (match_operand:SI 0 \"register_operand\" \"d\")\n-\t\t\t(match_operand:SI 1 \"arith_operand\" \"dI\")))]\n-  \"\"\n-  \"cmpo\t%0,%1\"\n-  [(set_attr \"type\" \"compare\")])\n-\n-(define_insn \"\"\n-  [(set (reg:CC 36)\n-\t(compare:CC (match_operand:DF 0 \"register_operand\" \"r\")\n-\t\t    (match_operand:DF 1 \"nonmemory_operand\" \"rGH\")))]\n-  \"TARGET_NUMERICS\"\n-  \"cmprl %0,%1\"\n-  [(set_attr \"type\" \"fpcc\")])\n-\n-(define_insn \"\"\n-  [(set (reg:CC 36)\n-\t(compare:CC (match_operand:SF 0 \"register_operand\" \"r\")\n-\t\t    (match_operand:SF 1 \"nonmemory_operand\" \"rGH\")))]\n-  \"TARGET_NUMERICS\"\n-  \"cmpr %0,%1\"\n-  [(set_attr \"type\" \"fpcc\")])\n-\n-;; Instruction definitions for branch-on-bit-set and clear insns.\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else\n-\t (ne (sign_extract:SI (match_operand:SI 0 \"register_operand\" \"d\")\n-\t\t\t      (const_int 1)\n-\t\t\t      (match_operand:SI 1 \"arith_operand\" \"dI\"))\n-\t     (const_int 0))\n-\t (label_ref (match_operand 2 \"\" \"\"))\n-\t (pc)))]\n-  \"\"\n-  \"bbs%+\t%1,%0,%l2\"\n-  [(set_attr \"type\" \"branch\")])\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else\n-\t (eq (sign_extract:SI (match_operand:SI 0 \"register_operand\" \"d\")\n-\t\t\t      (const_int 1)\n-\t\t\t      (match_operand:SI 1 \"arith_operand\" \"dI\"))\n-\t     (const_int 0))\n-\t (label_ref (match_operand 2 \"\" \"\"))\n-\t (pc)))]\n-  \"\"\n-  \"bbc%+\t%1,%0,%l2\"\n-  [(set_attr \"type\" \"branch\")])\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else\n-\t (ne (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"d\")\n-\t\t\t      (const_int 1)\n-\t\t\t      (match_operand:SI 1 \"arith_operand\" \"dI\"))\n-\t     (const_int 0))\n-\t (label_ref (match_operand 2 \"\" \"\"))\n-\t (pc)))]\n-  \"\"\n-  \"bbs%+\t%1,%0,%l2\"\n-  [(set_attr \"type\" \"branch\")])\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else\n-\t (eq (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"d\")\n-\t\t\t      (const_int 1)\n-\t\t\t      (match_operand:SI 1 \"arith_operand\" \"dI\"))\n-\t     (const_int 0))\n-\t (label_ref (match_operand 2 \"\" \"\"))\n-\t (pc)))]\n-  \"\"\n-  \"bbc%+\t%1,%0,%l2\"\n-  [(set_attr \"type\" \"branch\")])\n-\n-;; ??? These will never match.  The LOG_LINKs necessary to make these match\n-;; are not created by flow.  These remain as a reminder to make this work\n-;; some day.\n-\n-(define_insn \"\"\n-  [(set (reg:CC 36)\n-\t(compare (match_operand:SI 0 \"arith_operand\" \"d\")\n-\t\t (match_operand:SI 1 \"arith_operand\" \"+d\")))\n-   (set (match_dup 1) (plus:SI (match_dup 1) (const_int 1)))]\n-  \"0\"\n-  \"cmpinci\t%0,%1\"\n-  [(set_attr \"type\" \"compare\")])\n-\n-(define_insn \"\"\n-  [(set (reg:CC_UNS 36)\n-\t(compare (match_operand:SI 0 \"arith_operand\" \"d\")\n-\t\t (match_operand:SI 1 \"arith_operand\" \"+d\")))\n-   (set (match_dup 1) (plus:SI (match_dup 1) (const_int 1)))]\n-  \"0\"\n-  \"cmpinco\t%0,%1\"\n-  [(set_attr \"type\" \"compare\")])\n-\n-(define_insn \"\"\n-  [(set (reg:CC 36)\n-\t(compare (match_operand:SI 0 \"arith_operand\" \"d\")\n-\t\t (match_operand:SI 1 \"arith_operand\" \"+d\")))\n-   (set (match_dup 1) (minus:SI (match_dup 1) (const_int 1)))]\n-  \"0\"\n-  \"cmpdeci\t%0,%1\"\n-  [(set_attr \"type\" \"compare\")])\n-\n-(define_insn \"\"\n-  [(set (reg:CC_UNS 36)\n-\t(compare (match_operand:SI 0 \"arith_operand\" \"d\")\n-\t\t (match_operand:SI 1 \"arith_operand\" \"+d\")))\n-   (set (match_dup 1) (minus:SI (match_dup 1) (const_int 1)))]\n-  \"0\"\n-  \"cmpdeco\t%0,%1\"\n-  [(set_attr \"type\" \"compare\")])\n-\f\n-;; Templates to store result of condition.\n-;; '1' is stored if condition is true.\n-;; '0' is stored if condition is false.\n-;; These should use predicate \"general_operand\", since\n-;; gcc seems to be creating mem references which use these\n-;; templates.\n-\n-(define_expand \"seq\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n-\t(eq:SI (match_dup 1) (const_int 0)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = gen_compare_reg (EQ, i960_compare_op0, i960_compare_op1);\n-}\")\n-\n-(define_expand \"sne\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n-\t(ne:SI (match_dup 1) (const_int 0)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = gen_compare_reg (NE, i960_compare_op0, i960_compare_op1);\n-}\")\n-\n-(define_expand \"sgt\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n-\t(gt:SI (match_dup 1) (const_int 0)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = gen_compare_reg (GT, i960_compare_op0, i960_compare_op1);\n-}\")\n-\n-(define_expand \"sgtu\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n-\t(gtu:SI (match_dup 1) (const_int 0)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = gen_compare_reg (GTU, i960_compare_op0, i960_compare_op1);\n-}\")\n-\n-(define_expand \"slt\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n-\t(lt:SI (match_dup 1) (const_int 0)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = gen_compare_reg (LT, i960_compare_op0, i960_compare_op1);\n-}\")\n-\n-(define_expand \"sltu\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n-\t(ltu:SI (match_dup 1) (const_int 0)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = gen_compare_reg (LTU, i960_compare_op0, i960_compare_op1);\n-}\")\n-\n-(define_expand \"sge\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n-\t(ge:SI (match_dup 1) (const_int 0)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = gen_compare_reg (GE, i960_compare_op0, i960_compare_op1);\n-}\")\n-\n-(define_expand \"sgeu\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n-\t(geu:SI (match_dup 1) (const_int 0)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = gen_compare_reg (GEU, i960_compare_op0, i960_compare_op1);\n-}\")\n-\n-(define_expand \"sle\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n-\t(le:SI (match_dup 1) (const_int 0)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = gen_compare_reg (LE, i960_compare_op0, i960_compare_op1);\n-}\")\n-\n-(define_expand \"sleu\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n-\t(leu:SI (match_dup 1) (const_int 0)))]\n-  \"\"\n-  \"\n-{\n-  operands[1] = gen_compare_reg (LEU, i960_compare_op0, i960_compare_op1);\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n-\t(eq:SI (match_operand:SI 1 \"register_operand\" \"d\") (const_int 0)))]\n-  \"\"\n-  \"shro\t%1,1,%0\"\n-  [(set_attr \"type\" \"alu2\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n-\t(match_operator:SI 1 \"comparison_operator\" [(reg:CC 36) (const_int 0)]))]\n-  \"\"\n-  \"test%C1\t%0\"\n-  [(set_attr \"type\" \"compare\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n-\t(match_operator:SI 1 \"comparison_operator\" [(reg:CC_UNS 36) (const_int 0)]))]\n-  \"\"\n-  \"test%C1\t%0\"\n-  [(set_attr \"type\" \"compare\")])\n-\f\n-;; These control RTL generation for conditional jump insns\n-;; and match them for register allocation.\n-\n-(define_expand \"beq\"\n-  [(set (pc)\n-\t(if_then_else (eq (match_dup 1)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{ operands[1] = gen_compare_reg (EQ, i960_compare_op0, i960_compare_op1); }\")\n-\n-(define_expand \"bne\"\n-  [(set (pc)\n-\t(if_then_else (ne (match_dup 1)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{ operands[1] = gen_compare_reg (NE, i960_compare_op0, i960_compare_op1); }\")\n-\n-(define_expand \"bgt\"\n-  [(set (pc)\n-\t(if_then_else (gt (match_dup 1)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{ operands[1] = gen_compare_reg (GT, i960_compare_op0, i960_compare_op1); }\")\n-\n-(define_expand \"bgtu\"\n-  [(set (pc)\n-\t(if_then_else (gtu (match_dup 1)\n-\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{ operands[1] = gen_compare_reg (GTU, i960_compare_op0, i960_compare_op1); }\")\n-\n-(define_expand \"blt\"\n-  [(set (pc)\n-\t(if_then_else (lt (match_dup 1)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{ operands[1] = gen_compare_reg (LT, i960_compare_op0, i960_compare_op1); }\")\n-\n-(define_expand \"bltu\"\n-  [(set (pc)\n-\t(if_then_else (ltu (match_dup 1)\n-\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{ operands[1] = gen_compare_reg (LTU, i960_compare_op0, i960_compare_op1); }\")\n-\n-(define_expand \"bge\"\n-  [(set (pc)\n-\t(if_then_else (ge (match_dup 1)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{ operands[1] = gen_compare_reg (GE, i960_compare_op0, i960_compare_op1); }\")\n-\n-(define_expand \"bgeu\"\n-  [(set (pc)\n-\t(if_then_else (geu (match_dup 1)\n-\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{ operands[1] = gen_compare_reg (GEU, i960_compare_op0, i960_compare_op1); }\")\n-\n-(define_expand \"ble\"\n-  [(set (pc)\n-\t(if_then_else (le (match_dup 1)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{ operands[1] = gen_compare_reg (LE, i960_compare_op0, i960_compare_op1); }\")\n-\n-(define_expand \"bleu\"\n-  [(set (pc)\n-\t(if_then_else (leu (match_dup 1)\n-\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"\n-{ operands[1] = gen_compare_reg (LEU, i960_compare_op0, i960_compare_op1); }\")\n-\f\n-;; Now the normal branch insns (forward and reverse).\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (match_operator 0 \"comparison_operator\"\n-\t\t\t\t      [(reg:CC 36) (const_int 0)])\n-\t\t      (label_ref (match_operand 1 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"b%C0%+ %l1\"\n-  [(set_attr \"type\" \"branch\")])\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (match_operator 0 \"comparison_operator\"\n-\t\t\t\t      [(reg:CC 36) (const_int 0)])\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 1 \"\" \"\"))))]\n-  \"\"\n-  \"b%I0%+ %l1\"\n-  [(set_attr \"type\" \"branch\")])\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (match_operator 0 \"comparison_operator\"\n-\t\t\t\t      [(reg:CC_UNS 36) (const_int 0)])\n-\t\t      (label_ref (match_operand 1 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"b%C0%+ %l1\"\n-  [(set_attr \"type\" \"branch\")])\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (match_operator 0 \"comparison_operator\"\n-\t\t\t\t      [(reg:CC_UNS 36) (const_int 0)])\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 1 \"\" \"\"))))]\n-  \"\"\n-  \"b%I0%+ %l1\"\n-  [(set_attr \"type\" \"branch\")])\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else\n-\t (match_operator 0 \"comparison_operator\"\n-\t\t\t [(match_operand:SI 1 \"arith_operand\" \"d\")\n-\t\t\t  (match_operand:SI 2 \"arith_operand\" \"dI\")])\n-\t (label_ref (match_operand 3 \"\" \"\"))\n-\t (pc)))]\n-  \"\"\n-  \"cmp%S0%B0%R0%+\t%2,%1,%l3\"\n-  [(set_attr \"type\" \"branch\")])\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else\n-\t (match_operator 0 \"comparison_operator\"\n-\t\t\t [(match_operand:SI 1 \"arith_operand\" \"d\")\n-\t\t\t  (match_operand:SI 2 \"arith_operand\" \"dI\")])\n-\t (pc)\n-\t (label_ref (match_operand 3 \"\" \"\"))))]\n-  \"\"\n-  \"cmp%S0%B0%X0%+\t%2,%1,%l3\"\n-  [(set_attr \"type\" \"branch\")])\n-\f\n-;; Now the trap instructions.  The i960 appears to only have conditional\n-;; traps...\n-\n-(define_insn (\"trap\")\n-  [(trap_if (const_int 1) (const_int 0))]\n-  \"\"\n-  \"cmpo g0,g0 ; faulte.t\")\n-\n-(define_expand \"conditional_trap\"\n-  [(trap_if (match_operator 0 \"comparison_operator\"\n-\t     [(match_dup 2) (const_int 0)]) \n-\t    (match_operand 1 \"const_int_operand\" \"i\"))]\n-  \"\"\n-  \"\n-{\n-  operands[2] = gen_compare_reg (GET_CODE (operands[0]), \n-\t\t\t\t i960_compare_op0, i960_compare_op1);\n-}\")\n-\n-(define_insn \"\"\n-  [(trap_if (match_operator 0 \"comparison_operator\"\n-\t     [(reg:CC 36) (const_int 0)]) \n-\t    (match_operand 1 \"const_int_operand\" \"i\"))]\n-  \"\"\n-  \"fault%C0.f\")\n-\n-(define_insn \"\"\n-  [(trap_if (match_operator 0 \"comparison_operator\"\n-\t     [(reg:CC_UNS 36) (const_int 0)]) \n-\t    (match_operand 1 \"const_int_operand\" \"i\"))]\n-  \"\"\n-  \"fault%C0.f\")\n-\f\n-;; Normal move instructions.\n-;; This code is based on the sparc machine description.\n-\n-(define_expand \"movsi\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"\")\n-\t(match_operand:SI 1 \"general_operand\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  if (emit_move_sequence (operands, SImode))\n-    DONE;\n-}\")\n-\n-;; The store case can not be separate, because reload may convert a register\n-;; to register move insn to a store (or load) insn without rerecognizing\n-;; the insn.\n-\n-;; The i960 does not have any store constant to memory instruction.  However,\n-;; the calling convention is defined so that the arg pointer when it is not\n-;; overwise being used is zero.  Thus, we can handle store zero to memory\n-;; by storing an unused arg pointer.  The arg pointer will be unused if\n-;; current_function_args_size is zero and this is not a stdarg\n-;; function.  This value of the former variable is not valid until after\n-;; all rtl generation is complete, including function inlining (because a\n-;; function that doesn't need an arg pointer may be inlined into a function\n-;; that does need an arg pointer), so we must also check that\n-;; rtx_equal_function_value_matters is zero.\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d,d,d,m\")\n-\t(match_operand:SI 1 \"general_operand\" \"dI,i,m,dJ\"))]\n-  \"(current_function_args_size == 0\n-    && current_function_stdarg == 0\n-    && rtx_equal_function_value_matters == 0)\n-   && (register_operand (operands[0], SImode)\n-       || register_operand (operands[1], SImode)\n-       || operands[1] == const0_rtx)\"\n-  \"*\n-{\n-  switch (which_alternative)\n-    {\n-    case 0:\n-      if (i960_last_insn_type == I_TYPE_REG && TARGET_C_SERIES)\n-\t{\n-\t  if (GET_CODE (operands[1]) == REG)\n-\t    return \\\"lda\t(%1),%0\\\";\n-\t  else\n-\t    return \\\"lda\t%1,%0\\\";\n-\t}\n-      return \\\"mov\t%1,%0\\\";\n-    case 1:\n-      return i960_output_ldconst (operands[0], operands[1]);\n-    case 2:\n-      return \\\"ld\t%1,%0\\\";\n-    case 3:\n-      if (operands[1] == const0_rtx)\n-\treturn \\\"st\tg14,%0\\\";\n-      return \\\"st\t%1,%0\\\";      \n-    default:\n-      abort();\n-    }\n-}\"\n-  [(set_attr \"type\" \"move,address,load,store\")\n-   (set_attr \"length\" \"*,3,*,*\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d,d,d,m\")\n-\t(match_operand:SI 1 \"general_operand\" \"dI,i,m,d\"))]\n-  \"(current_function_args_size != 0\n-    || current_function_stdarg != 0\n-    || rtx_equal_function_value_matters != 0)\n-   && (register_operand (operands[0], SImode)\n-       || register_operand (operands[1], SImode))\"\n-  \"*\n-{\n-  switch (which_alternative)\n-    {\n-    case 0:\n-      if (i960_last_insn_type == I_TYPE_REG && TARGET_C_SERIES)\n-\t{\n-\t  if (GET_CODE (operands[1]) == REG)\n-\t    return \\\"lda\t(%1),%0\\\";\n-\t  else\n-\t    return \\\"lda\t%1,%0\\\";\n-\t}\n-      return \\\"mov\t%1,%0\\\";\n-    case 1:\n-      return i960_output_ldconst (operands[0], operands[1]);\n-    case 2:\n-      return \\\"ld\t%1,%0\\\";\n-    case 3:\n-      return \\\"st\t%1,%0\\\";      \n-    default:\n-      abort();\n-    }\n-}\"\n-  [(set_attr \"type\" \"move,address,load,store\")\n-   (set_attr \"length\" \"*,3,*,*\")])\n-\n-(define_expand \"movhi\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"\")\n-\t(match_operand:HI 1 \"general_operand\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  if (emit_move_sequence (operands, HImode))\n-    DONE;\n-}\")\n-\n-;; Special pattern for zero stores to memory for functions which don't use\n-;; the arg pointer.\n-\n-;; The store case can not be separate.  See above.\n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=d,d,d,m\")\n-\t(match_operand:HI 1 \"general_operand\" \"dI,i,m,dJ\"))]\n-  \"(current_function_args_size == 0\n-    && current_function_stdarg == 0\n-    && rtx_equal_function_value_matters == 0)\n-   && (register_operand (operands[0], HImode)\n-       || register_operand (operands[1], HImode)\n-       || operands[1] == const0_rtx)\"\n-  \"*\n-{\n-  switch (which_alternative)\n-    {\n-    case 0:\n-      if (i960_last_insn_type == I_TYPE_REG && TARGET_C_SERIES)\n-\t{\n-\t  if (GET_CODE (operands[1]) == REG)\n-\t    return \\\"lda\t(%1),%0\\\";\n-\t  else\n-\t    return \\\"lda\t%1,%0\\\";\n-\t}\n-      return \\\"mov\t%1,%0\\\";\n-    case 1:\n-      return i960_output_ldconst (operands[0], operands[1]);\n-    case 2:\n-      return \\\"ldos\t%1,%0\\\";\n-    case 3:\n-      if (operands[1] == const0_rtx)\n-\treturn \\\"stos\tg14,%0\\\";\n-      return \\\"stos\t%1,%0\\\";\n-    default:\n-      abort();\n-    }\n-}\"\n-  [(set_attr \"type\" \"move,misc,load,store\")\n-   (set_attr \"length\" \"*,3,*,*\")])\n-\n-;; The store case can not be separate.  See above.\n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=d,d,d,m\")\n-\t(match_operand:HI 1 \"general_operand\" \"dI,i,m,d\"))]\n-  \"(current_function_args_size != 0\n-    || current_function_stdarg != 0\n-    || rtx_equal_function_value_matters != 0)\n-   && (register_operand (operands[0], HImode)\n-       || register_operand (operands[1], HImode))\"\n-  \"*\n-{\n-  switch (which_alternative)\n-    {\n-    case 0:\n-      if (i960_last_insn_type == I_TYPE_REG && TARGET_C_SERIES)\n-\t{\n-\t  if (GET_CODE (operands[1]) == REG)\n-\t    return \\\"lda\t(%1),%0\\\";\n-\t  else\n-\t    return \\\"lda\t%1,%0\\\";\n-\t}\n-      return \\\"mov\t%1,%0\\\";\n-    case 1:\n-      return i960_output_ldconst (operands[0], operands[1]);\n-    case 2:\n-      return \\\"ldos\t%1,%0\\\";\n-    case 3:\n-      return \\\"stos\t%1,%0\\\";\n-    default:\n-      abort();\n-    }\n-}\"\n-  [(set_attr \"type\" \"move,misc,load,store\")\n-   (set_attr \"length\" \"*,3,*,*\")])\n-\n-(define_expand \"movqi\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"\")\n-\t(match_operand:QI 1 \"general_operand\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  if (emit_move_sequence (operands, QImode))\n-    DONE;\n-}\")\n-\n-;; The store case can not be separate.  See comment above.\n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=d,d,d,m\")\n-\t(match_operand:QI 1 \"general_operand\" \"dI,i,m,dJ\"))]\n-  \"(current_function_args_size == 0\n-    && current_function_stdarg == 0\n-    && rtx_equal_function_value_matters == 0)\n-   && (register_operand (operands[0], QImode)\n-       || register_operand (operands[1], QImode)\n-       || operands[1] == const0_rtx)\"\n-  \"*\n-{\n-  switch (which_alternative)\n-    {\n-    case 0:\n-      if (i960_last_insn_type == I_TYPE_REG && TARGET_C_SERIES)\n-\t{\n-\t  if (GET_CODE (operands[1]) == REG)\n-\t    return \\\"lda\t(%1),%0\\\";\n-\t  else\n-\t    return \\\"lda\t%1,%0\\\";\n-\t}\n-      return \\\"mov\t%1,%0\\\";\n-    case 1:\n-      return i960_output_ldconst (operands[0], operands[1]);\n-    case 2:\n-      return \\\"ldob\t%1,%0\\\";\n-    case 3:\n-      if (operands[1] == const0_rtx)\n-\treturn \\\"stob\tg14,%0\\\";\n-      return \\\"stob\t%1,%0\\\";\n-    default:\n-      abort();\n-    }\n-}\"\n-  [(set_attr \"type\" \"move,misc,load,store\")\n-   (set_attr \"length\" \"*,3,*,*\")])\n-\n-;; The store case can not be separate.  See comment above.\n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=d,d,d,m\")\n-\t(match_operand:QI 1 \"general_operand\" \"dI,i,m,d\"))]\n-  \"(current_function_args_size != 0\n-    || current_function_stdarg != 0\n-    || rtx_equal_function_value_matters != 0)\n-   && (register_operand (operands[0], QImode)\n-       || register_operand (operands[1], QImode))\"\n-  \"*\n-{\n-  switch (which_alternative)\n-    {\n-    case 0:\n-      if (i960_last_insn_type == I_TYPE_REG && TARGET_C_SERIES)\n-\t{\n-\t  if (GET_CODE (operands[1]) == REG)\n-\t    return \\\"lda\t(%1),%0\\\";\n-\t  else\n-\t    return \\\"lda\t%1,%0\\\";\n-\t}\n-      return \\\"mov\t%1,%0\\\";\n-    case 1:\n-      return i960_output_ldconst (operands[0], operands[1]);\n-    case 2:\n-      return \\\"ldob\t%1,%0\\\";\n-    case 3:\n-      return \\\"stob\t%1,%0\\\";\n-    default:\n-      abort();\n-    }\n-}\"\n-  [(set_attr \"type\" \"move,misc,load,store\")\n-   (set_attr \"length\" \"*,3,*,*\")])\n-\n-(define_expand \"movdi\"\n-  [(set (match_operand:DI 0 \"general_operand\" \"\")\n-\t(match_operand:DI 1 \"general_operand\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  if (emit_move_sequence (operands, DImode))\n-    DONE;\n-}\")\n-\n-;; The store case can not be separate.  See comment above.\n-(define_insn \"\"\n-  [(set (match_operand:DI 0 \"general_operand\" \"=d,d,d,d,m,o\")\n-\t(match_operand:DI 1 \"general_operand\" \"d,I,i,m,d,J\"))]\n-  \"(current_function_args_size == 0\n-    && current_function_stdarg == 0\n-    && rtx_equal_function_value_matters == 0)\n-   && (register_operand (operands[0], DImode)\n-       || register_operand (operands[1], DImode)\n-       || operands[1] == const0_rtx)\"\n-  \"*\n-{\n-  switch (which_alternative)\n-    {\n-    case 0:\n-    case 1:\n-    case 3:\n-    case 4:\n-      return i960_output_move_double (operands[0], operands[1]);\n-    case 2:\n-      return i960_output_ldconst (operands[0], operands[1]);\n-    case 5:\n-       return i960_output_move_double_zero (operands[0]);\n-    default:\n-      abort();\n-    }\n-}\"\n-  [(set_attr \"type\" \"move,move,load,load,store,store\")])\n-\n-;; The store case can not be separate.  See comment above.\n-(define_insn \"\"\n-  [(set (match_operand:DI 0 \"general_operand\" \"=d,d,d,d,m\")\n-\t(match_operand:DI 1 \"general_operand\" \"d,I,i,m,d\"))]\n-  \"(current_function_args_size != 0\n-    || current_function_stdarg != 0\n-    || rtx_equal_function_value_matters != 0)\n-   && (register_operand (operands[0], DImode)\n-       || register_operand (operands[1], DImode))\"\n-  \"*\n-{\n-  switch (which_alternative)\n-    {\n-    case 0:\n-    case 1:\n-    case 3:\n-    case 4:\n-      return i960_output_move_double (operands[0], operands[1]);\n-    case 2:\n-      return i960_output_ldconst (operands[0], operands[1]);\n-    default:\n-      abort();\n-    }\n-}\"\n-  [(set_attr \"type\" \"move,move,load,load,store\")])\n-\n-(define_insn \"*store_unaligned_di_reg\"\n-  [(set (match_operand:DI 0 \"general_operand\" \"=d,m\")\n-\t(match_operand:DI 1 \"register_operand\" \"d,d\"))\n-   (clobber (match_scratch:SI 2 \"=X,&d\"))]\n-  \"\"\n-  \"*\n-{\n-  if (which_alternative == 0)\n-    return i960_output_move_double (operands[0], operands[1]);\n-    \n-  operands[3] = gen_rtx_MEM (word_mode, operands[2]);\n-  operands[4] = adjust_address (operands[3], word_mode, UNITS_PER_WORD);\n-  return \\\"lda\t%0,%2\\;st\t%1,%3\\;st\t%D1,%4\\\";\n-}\"\n-  [(set_attr \"type\" \"move,store\")])\n-\n-(define_expand \"movti\"\n-  [(set (match_operand:TI 0 \"general_operand\" \"\")\n-\t(match_operand:TI 1 \"general_operand\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  if (emit_move_sequence (operands, TImode))\n-    DONE;\n-}\")\n-\n-;; The store case can not be separate.  See comment above.\n-(define_insn \"\"\n-  [(set (match_operand:TI 0 \"general_operand\" \"=d,d,d,d,m,o\")\n-\t(match_operand:TI 1 \"general_operand\" \"d,I,i,m,d,J\"))]\n-  \"(current_function_args_size == 0\n-    && current_function_stdarg == 0\n-    && rtx_equal_function_value_matters == 0)\n-   && (register_operand (operands[0], TImode)\n-       || register_operand (operands[1], TImode)\n-       || operands[1] == const0_rtx)\"\n-  \"*\n-{\n-  switch (which_alternative)\n-    {\n-    case 0:\n-    case 1:\n-    case 3:\n-    case 4:\n-      return i960_output_move_quad (operands[0], operands[1]);\n-    case 2:\n-      return i960_output_ldconst (operands[0], operands[1]);\n-    case 5:\n-      return i960_output_move_quad_zero (operands[0]);\n-    default:\n-      abort();\n-    }\n-}\"\n-  [(set_attr \"type\" \"move,move,load,load,store,store\")])\n-\n-;; The store case can not be separate.  See comment above.\n-(define_insn \"\"\n-  [(set (match_operand:TI 0 \"general_operand\" \"=d,d,d,d,m\")\n-\t(match_operand:TI 1 \"general_operand\" \"d,I,i,m,d\"))]\n-  \"(current_function_args_size != 0\n-    || current_function_stdarg != 0\n-    || rtx_equal_function_value_matters != 0)\n-   && (register_operand (operands[0], TImode)\n-       || register_operand (operands[1], TImode))\"\n-  \"*\n-{\n-  switch (which_alternative)\n-    {\n-    case 0:\n-    case 1:\n-    case 3:\n-    case 4:\n-      return i960_output_move_quad (operands[0], operands[1]);\n-    case 2:\n-      return i960_output_ldconst (operands[0], operands[1]);\n-    default:\n-      abort();\n-    }\n-}\"\n-  [(set_attr \"type\" \"move,move,load,load,store\")])\n-\n-(define_insn \"*store_unaligned_ti_reg\"\n-  [(set (match_operand:TI 0 \"general_operand\" \"=d,m\")\n-\t(match_operand:TI 1 \"register_operand\" \"d,d\"))\n-   (clobber (match_scratch:SI 2 \"=X,&d\"))]\n-  \"\"\n-  \"*\n-{\n-  if (which_alternative == 0)\n-    return i960_output_move_quad (operands[0], operands[1]);\n-\n-  operands[3] = gen_rtx_MEM (word_mode, operands[2]);\n-  operands[4] = adjust_address (operands[3], word_mode, UNITS_PER_WORD);\n-  operands[5] = adjust_address (operands[4], word_mode, UNITS_PER_WORD);\n-  operands[6] = adjust_address (operands[5], word_mode, UNITS_PER_WORD);\n-  return \\\"lda\t%0,%2\\;st\t%1,%3\\;st\t%D1,%4\\;st\t%E1,%5\\;st\t%F1,%6\\\";\n-}\"\n-  [(set_attr \"type\" \"move,store\")])\n-\n-(define_expand \"store_multiple\"\n-  [(set (match_operand:SI 0 \"\" \"\")\t;;- dest\n-\t(match_operand:SI 1 \"\" \"\"))\t;;- src\n-   (use (match_operand:SI 2 \"\" \"\"))]\t;;- nregs\n-  \"\"\n-  \"\n-{\n-  int regno;\n-  int count;\n-  int offset = 0;\n-\n-  if (GET_CODE (operands[0]) != MEM\n-      || GET_CODE (operands[1]) != REG\n-      || GET_CODE (operands[2]) != CONST_INT)\n-    FAIL;\n-\n-  count = INTVAL (operands[2]);\n-  if (count > 12)\n-    FAIL;\n-\n-  regno = REGNO (operands[1]);\n-  while (count >= 4 && ((regno & 3) == 0))\n-    {\n-      emit_move_insn (adjust_address (operands[0], TImode, offset),\n-\t\t      gen_rtx_REG (TImode, regno));\n-      count -= 4;\n-      regno += 4;\n-      offset += 16;\n-    }\n-  while (count >= 2 && ((regno & 1) == 0))\n-    {\n-      emit_move_insn (adjust_address (operands[0], DImode, offset),\n-\t\t      gen_rtx_REG (DImode, regno));\n-      count -= 2;\n-      regno += 2;\n-      offset += 8;\n-    }\n-  while (count > 0)\n-    {\n-      emit_move_insn (adjust_address (operands[0], SImode, offset),\n-\t\t      gen_rtx_REG (SImode, regno));\n-      count -= 1;\n-      regno += 1;\n-      offset += 4;\n-    }\n-  DONE;\n-}\")\n-\f\n-;; Floating point move insns\n-\n-(define_expand \"movdf\"\n-  [(set (match_operand:DF 0 \"general_operand\" \"\")\n-\t(match_operand:DF 1 \"fpmove_src_operand\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  if (emit_move_sequence (operands, DFmode))\n-    DONE;\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"general_operand\" \"=r,*f,d,d,m,o\")\n-\t(match_operand:DF 1 \"fpmove_src_operand\" \"r,GH,F,m,d,G\"))]\n-  \"(current_function_args_size == 0\n-    && current_function_stdarg == 0\n-    && rtx_equal_function_value_matters == 0)\n-   && (register_operand (operands[0], DFmode)\n-       || register_operand (operands[1], DFmode)\n-       || operands[1] == CONST0_RTX (DFmode))\"\n-  \"*\n-{\n-  switch (which_alternative)\n-    {\n-    case 0:\n-      if (FP_REG_P (operands[0]) || FP_REG_P (operands[1]))\n-\treturn \\\"movrl\t%1,%0\\\";\n-      else\n-\treturn \\\"movl\t%1,%0\\\";\n-    case 1:\n-      return \\\"movrl\t%1,%0\\\";\n-    case 2:\n-      return i960_output_ldconst (operands[0], operands[1]);\n-    case 3:\n-      return \\\"ldl\t%1,%0\\\";\n-    case 4:\n-      return \\\"stl\t%1,%0\\\";\n-    case 5:\n-      operands[1] = adjust_address (operands[0], VOIDmode, 4);\n-      return \\\"st\tg14,%0\\;st\tg14,%1\\\";\n-    default:\n-      abort();\n-    }\n-}\"\n-  [(set_attr \"type\" \"move,move,load,fpload,fpstore,fpstore\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"general_operand\" \"=r,*f,d,d,m\")\n-\t(match_operand:DF 1 \"fpmove_src_operand\" \"r,GH,F,m,d\"))]\n-  \"(current_function_args_size != 0\n-    || current_function_stdarg != 0\n-    || rtx_equal_function_value_matters != 0)\n-   && (register_operand (operands[0], DFmode)\n-       || register_operand (operands[1], DFmode))\"\n-  \"*\n-{\n-  switch (which_alternative)\n-    {\n-    case 0:\n-      if (FP_REG_P (operands[0]) || FP_REG_P (operands[1]))\n-\treturn \\\"movrl\t%1,%0\\\";\n-      else\n-\treturn \\\"movl\t%1,%0\\\";\n-    case 1:\n-      return \\\"movrl\t%1,%0\\\";\n-    case 2:\n-      return i960_output_ldconst (operands[0], operands[1]);\n-    case 3:\n-      return \\\"ldl\t%1,%0\\\";\n-    case 4:\n-      return \\\"stl\t%1,%0\\\";\n-    default:\n-      abort();\n-    }\n-}\"\n-  [(set_attr \"type\" \"move,move,load,fpload,fpstore\")])\n-\n-(define_expand \"movsf\"\n-  [(set (match_operand:SF 0 \"general_operand\" \"\")\n-\t(match_operand:SF 1 \"fpmove_src_operand\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  if (emit_move_sequence (operands, SFmode))\n-    DONE;\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"general_operand\" \"=r,*f,d,d,m\")\n-\t(match_operand:SF 1 \"fpmove_src_operand\" \"r,GH,F,m,dG\"))]\n-  \"(current_function_args_size == 0\n-    && current_function_stdarg == 0\n-    && rtx_equal_function_value_matters == 0)\n-   && (register_operand (operands[0], SFmode)\n-       || register_operand (operands[1], SFmode)\n-       || operands[1] == CONST0_RTX (SFmode))\"\n-  \"*\n-{\n-  switch (which_alternative)\n-    {\n-    case 0:\n-      if (FP_REG_P (operands[0]) || FP_REG_P (operands[1]))\n-\treturn \\\"movr\t%1,%0\\\";\n-      else\n-\treturn \\\"mov\t%1,%0\\\";\n-    case 1:\n-      return \\\"movr\t%1,%0\\\";\n-    case 2:\n-      return i960_output_ldconst (operands[0], operands[1]);\n-    case 3:\n-      return \\\"ld\t%1,%0\\\";\n-    case 4:\n-      if (operands[1] == CONST0_RTX (SFmode))\n-\treturn \\\"st\tg14,%0\\\";\n-      return \\\"st\t%1,%0\\\";\n-    default:\n-      abort();\n-    }\n-}\"\n-  [(set_attr \"type\" \"move,move,load,fpload,fpstore\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"general_operand\" \"=r,*f,d,d,m\")\n-\t(match_operand:SF 1 \"fpmove_src_operand\" \"r,GH,F,m,d\"))]\n-  \"(current_function_args_size != 0\n-    || current_function_stdarg != 0\n-    || rtx_equal_function_value_matters != 0)\n-   && (register_operand (operands[0], SFmode)\n-       || register_operand (operands[1], SFmode))\"\n-  \"*\n-{\n-  switch (which_alternative)\n-    {\n-    case 0:\n-      if (FP_REG_P (operands[0]) || FP_REG_P (operands[1]))\n-\treturn \\\"movr\t%1,%0\\\";\n-      else\n-\treturn \\\"mov\t%1,%0\\\";\n-    case 1:\n-      return \\\"movr\t%1,%0\\\";\n-    case 2:\n-      return i960_output_ldconst (operands[0], operands[1]);\n-    case 3:\n-      return \\\"ld\t%1,%0\\\";\n-    case 4:\n-      return \\\"st\t%1,%0\\\";\n-    default:\n-      abort();\n-    }\n-}\"\n-  [(set_attr \"type\" \"move,move,load,fpload,fpstore\")])\n-\f\n-;; Mixed-mode moves with sign and zero-extension.\n-\n-;; Note that the one starting from HImode comes before those for QImode\n-;; so that a constant operand will match HImode, not QImode.\n-\n-(define_expand \"extendhisi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(sign_extend:SI\n-\t (match_operand:HI 1 \"nonimmediate_operand\" \"\")))]\n- \"\"\n- \"\n-{\n-  if (GET_CODE (operand1) == REG\n-      || (GET_CODE (operand1) == SUBREG\n-\t  && GET_CODE (XEXP (operand1, 0)) == REG))\n-    {\n-      rtx temp = gen_reg_rtx (SImode);\n-      rtx shift_16 = GEN_INT (16);\n-      int op1_subreg_byte = 0;\n-\n-      if (GET_CODE (operand1) == SUBREG)\n-\t{\n-\t  op1_subreg_byte = SUBREG_BYTE (operand1);\n-\t  op1_subreg_byte /= GET_MODE_SIZE (SImode);\n-\t  op1_subreg_byte *= GET_MODE_SIZE (SImode);\n-\t  operand1 = SUBREG_REG (operand1);\n-\t}\n-      if (GET_MODE (operand1) != SImode)\n-\toperand1 = gen_rtx (SUBREG, SImode, operand1, op1_subreg_byte);\n-\n-      emit_insn (gen_ashlsi3 (temp, operand1, shift_16));\n-      emit_insn (gen_ashrsi3 (operand0, temp, shift_16));\n-      DONE;\n-    }\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(sign_extend:SI (match_operand:HI 1 \"memory_operand\" \"m\")))]\n-  \"\"\n-  \"ldis\t%1,%0\"\n-  [(set_attr \"type\" \"load\")])\n-\n-(define_expand \"extendqisi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(sign_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"\")))]\n-  \"\"\n-  \"\n-{\n-  if (GET_CODE (operand1) == REG\n-      || (GET_CODE (operand1) == SUBREG\n-\t  && GET_CODE (XEXP (operand1, 0)) == REG))\n-    {\n-      rtx temp = gen_reg_rtx (SImode);\n-      rtx shift_24 = GEN_INT (24);\n-      int op1_subreg_byte = 0;\n-\n-      if (GET_CODE (operand1) == SUBREG)\n-\t{\n-\t  op1_subreg_byte = SUBREG_BYTE (operand1);\n-\t  op1_subreg_byte /= GET_MODE_SIZE (SImode);\n-\t  op1_subreg_byte *= GET_MODE_SIZE (SImode);\n-\t  operand1 = SUBREG_REG (operand1);\n-\t}\n-      if (GET_MODE (operand1) != SImode)\n-\toperand1 = gen_rtx (SUBREG, SImode, operand1, op1_subreg_byte);\n-\n-      emit_insn (gen_ashlsi3 (temp, operand1, shift_24));\n-      emit_insn (gen_ashrsi3 (operand0, temp, shift_24));\n-      DONE;\n-    }\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(sign_extend:SI (match_operand:QI 1 \"memory_operand\" \"m\")))]\n-  \"\"\n-  \"ldib\t%1,%0\"\n-  [(set_attr \"type\" \"load\")])\n-\n-(define_expand \"extendqihi2\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"\")\n-\t(sign_extend:HI\n-\t (match_operand:QI 1 \"nonimmediate_operand\" \"\")))]\n-  \"\"\n-  \"\n-{\n-  if (GET_CODE (operand1) == REG\n-      || (GET_CODE (operand1) == SUBREG\n-\t  && GET_CODE (XEXP (operand1, 0)) == REG))\n-    {\n-      rtx temp = gen_reg_rtx (SImode);\n-      rtx shift_24 = GEN_INT (24);\n-      int op0_subreg_byte = 0;\n-      int op1_subreg_byte = 0;\n-\n-      if (GET_CODE (operand1) == SUBREG)\n-\t{\n-\t  op1_subreg_byte = SUBREG_BYTE (operand1);\n-\t  op1_subreg_byte /= GET_MODE_SIZE (SImode);\n-\t  op1_subreg_byte *= GET_MODE_SIZE (SImode);\n-\t  operand1 = SUBREG_REG (operand1);\n-\t}\n-      if (GET_MODE (operand1) != SImode)\n-\toperand1 = gen_rtx (SUBREG, SImode, operand1, op1_subreg_byte);\n-\n-      if (GET_CODE (operand0) == SUBREG)\n-\t{\n-\t  op0_subreg_byte = SUBREG_BYTE (operand0);\n-\t  op0_subreg_byte /= GET_MODE_SIZE (SImode);\n-\t  op0_subreg_byte *= GET_MODE_SIZE (SImode);\n-\t  operand0 = SUBREG_REG (operand0);\n-\t}\n-      if (GET_MODE (operand0) != SImode)\n-\toperand0 = gen_rtx_SUBREG (SImode, operand0, op0_subreg_byte);\n-\n-      emit_insn (gen_ashlsi3 (temp, operand1, shift_24));\n-      emit_insn (gen_ashrsi3 (operand0, temp, shift_24));\n-      DONE;\n-    }\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=d\")\n-\t(sign_extend:HI (match_operand:QI 1 \"memory_operand\" \"m\")))]\n-  \"\"\n-  \"ldib\t%1,%0\"\n-  [(set_attr \"type\" \"load\")])\n-\n-(define_expand \"zero_extendhisi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(zero_extend:SI\n-\t (match_operand:HI 1 \"nonimmediate_operand\" \"\")))]\n- \"\"\n- \"\n-{\n-  if (GET_CODE (operand1) == REG\n-      || (GET_CODE (operand1) == SUBREG\n-\t  && GET_CODE (XEXP (operand1, 0)) == REG))\n-    {\n-      rtx temp = gen_reg_rtx (SImode);\n-      rtx shift_16 = GEN_INT (16);\n-      int op1_subreg_byte = 0;\n-\n-      if (GET_CODE (operand1) == SUBREG)\n-\t{\n-\t  op1_subreg_byte = SUBREG_BYTE (operand1);\n-\t  op1_subreg_byte /= GET_MODE_SIZE (SImode);\n-\t  op1_subreg_byte *= GET_MODE_SIZE (SImode);\n-\t  operand1 = SUBREG_REG (operand1);\n-\t}\n-      if (GET_MODE (operand1) != SImode)\n-\toperand1 = gen_rtx (SUBREG, SImode, operand1, op1_subreg_byte);\n-\n-      emit_insn (gen_ashlsi3 (temp, operand1, shift_16));\n-      emit_insn (gen_lshrsi3 (operand0, temp, shift_16));\n-      DONE;\n-    }\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(zero_extend:SI (match_operand:HI 1 \"memory_operand\" \"m\")))]\n-  \"\"\n-  \"ldos\t%1,%0\"\n-  [(set_attr \"type\" \"load\")])\n-\n-;; Using shifts here generates much better code than doing an `and 255'.\n-;; This is mainly because the `and' requires loading the constant separately,\n-;; the constant is likely to get optimized, and then the compiler can't\n-;; optimize the `and' because it doesn't know that one operand is a constant.\n-\n-(define_expand \"zero_extendqisi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(zero_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"\")))]\n-  \"\"\n-  \"\n-{\n-  if (GET_CODE (operand1) == REG\n-      || (GET_CODE (operand1) == SUBREG\n-\t  && GET_CODE (XEXP (operand1, 0)) == REG))\n-    {\n-      rtx temp = gen_reg_rtx (SImode);\n-      rtx shift_24 = GEN_INT (24);\n-      int op1_subreg_byte = 0;\n-\n-      if (GET_CODE (operand1) == SUBREG)\n-\t{\n-          op1_subreg_byte = SUBREG_BYTE (operand1);\n-          op1_subreg_byte /= GET_MODE_SIZE (SImode);\n-          op1_subreg_byte *= GET_MODE_SIZE (SImode);\n-          operand1 = SUBREG_REG (operand1);\n-\t}\n-      if (GET_MODE (operand1) != SImode)\n-\toperand1 = gen_rtx (SUBREG, SImode, operand1, op1_subreg_byte);\n-\n-      emit_insn (gen_ashlsi3 (temp, operand1, shift_24));\n-      emit_insn (gen_lshrsi3 (operand0, temp, shift_24));\n-      DONE;\n-    }\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(zero_extend:SI (match_operand:QI 1 \"memory_operand\" \"m\")))]\n-  \"\"\n-  \"ldob\t%1,%0\"\n-  [(set_attr \"type\" \"load\")])\n-\n-(define_expand \"zero_extendqihi2\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"\")\n-\t(zero_extend:HI\n-\t (match_operand:QI 1 \"nonimmediate_operand\" \"\")))]\n-  \"\"\n-  \"\n-{\n-  if (GET_CODE (operand1) == REG\n-      || (GET_CODE (operand1) == SUBREG\n-\t  && GET_CODE (XEXP (operand1, 0)) == REG))\n-    {\n-      rtx temp = gen_reg_rtx (SImode);\n-      rtx shift_24 = GEN_INT (24);\n-      int op0_subreg_byte = 0;\n-      int op1_subreg_byte = 0;\n-\n-      if (GET_CODE (operand1) == SUBREG)\n-\t{\n-\t  op1_subreg_byte = SUBREG_BYTE (operand1);\n-\t  operand1 = SUBREG_REG (operand1);\n-\t}\n-      if (GET_MODE (operand1) != SImode)\n-\toperand1 = gen_rtx (SUBREG, SImode, operand1, op1_subreg_byte);\n-\n-      if (GET_CODE (operand0) == SUBREG)\n-\t{\n-\t  op0_subreg_byte = SUBREG_BYTE (operand0);\n-\t  operand0 = SUBREG_REG (operand0);\n-\t}\n-      if (GET_MODE (operand0) != SImode)\n-\toperand0 = gen_rtx_SUBREG (SImode, operand0, op0_subreg_byte);\n-\n-      emit_insn (gen_ashlsi3 (temp, operand1, shift_24));\n-      emit_insn (gen_lshrsi3 (operand0, temp, shift_24));\n-      DONE;\n-    }\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=d\")\n-\t(zero_extend:HI (match_operand:QI 1 \"memory_operand\" \"m\")))]\n-  \"\"\n-  \"ldob\t%1,%0\"\n-  [(set_attr \"type\" \"load\")])\n-\f\n-;; Conversions between float and double.\n-\n-(define_insn \"extendsfdf2\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=*f,d\")\n-\t(float_extend:DF (match_operand:SF 1 \"fp_arith_operand\" \"dGH,fGH\")))]\n-  \"TARGET_NUMERICS\"\n-  \"@\n-  movr\t%1,%0\n-  movrl\t%1,%0\"\n-  [(set_attr \"type\" \"fpmove\")])\n-\n-(define_insn \"truncdfsf2\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=d\")\n-\t(float_truncate:SF\n-\t (match_operand:DF 1 \"fp_arith_operand\" \"fGH\")))]\n-  \"TARGET_NUMERICS\"\n-  \"movr\t%1,%0\"\n-  [(set_attr \"type\" \"fpmove\")])\n-\n-;; Conversion between fixed point and floating point.\n-\n-(define_insn \"floatsidf2\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n-\t(float:DF (match_operand:SI 1 \"register_operand\" \"d\")))]\n-  \"TARGET_NUMERICS\"\n-  \"cvtir\t%1,%0\"\n-  [(set_attr \"type\" \"fpcvt\")])\n-\n-(define_insn \"floatsisf2\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=d*f\")\n-\t(float:SF (match_operand:SI 1 \"register_operand\" \"d\")))]\n-  \"TARGET_NUMERICS\"\n-  \"cvtir\t%1,%0\"\n-  [(set_attr \"type\" \"fpcvt\")])\n-\n-;; Convert a float to an actual integer.\n-;; Truncation is performed as part of the conversion.\n-;; The i960 requires conversion from DFmode to DImode to make\n-;; unsigned conversions work properly.\n-\n-(define_insn \"fixuns_truncdfdi2\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-\t(unsigned_fix:DI (fix:DF (match_operand:DF 1 \"fp_arith_operand\" \"fGH\"))))]\n-  \"TARGET_NUMERICS\"\n-  \"cvtzril\t%1,%0\"\n-  [(set_attr \"type\" \"fpcvt\")])\n-\n-(define_insn \"fixuns_truncsfdi2\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-\t(unsigned_fix:DI (fix:SF (match_operand:SF 1 \"fp_arith_operand\" \"fGH\"))))]\n-  \"TARGET_NUMERICS\"\n-  \"cvtzril\t%1,%0\"\n-  [(set_attr \"type\" \"fpcvt\")])\n-\n-(define_insn \"fix_truncdfsi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(fix:SI (fix:DF (match_operand:DF 1 \"fp_arith_operand\" \"fGH\"))))]\n-  \"TARGET_NUMERICS\"\n-  \"cvtzri\t%1,%0\"\n-  [(set_attr \"type\" \"fpcvt\")])\n-\n-(define_expand \"fixuns_truncdfsi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(unsigned_fix:SI (fix:DF (match_operand:DF 1 \"fp_arith_operand\" \"\"))))]\n-  \"TARGET_NUMERICS\"\n-  \"\n-{\n-  rtx temp = gen_reg_rtx (DImode);\n-  emit_insn (gen_rtx_SET (VOIDmode, temp,\n-\t\t\t  gen_rtx_UNSIGNED_FIX (DImode,\n-\t\t\t\t\t\tgen_rtx_FIX (DFmode,\n-\t\t\t\t\t\t\t     operands[1]))));\n-  emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n-\t\t\t  gen_rtx_SUBREG (SImode, temp, 0)));\n-  DONE;\n-}\")\n-\n-(define_insn \"fix_truncsfsi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(fix:SI (fix:SF (match_operand:SF 1 \"fp_arith_operand\" \"dfGH\"))))]\n-  \"TARGET_NUMERICS\"\n-  \"cvtzri\t%1,%0\"\n-  [(set_attr \"type\" \"fpcvt\")])\n-\n-(define_expand \"fixuns_truncsfsi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(unsigned_fix:SI (fix:SF (match_operand:SF 1 \"fp_arith_operand\" \"\"))))]\n-  \"TARGET_NUMERICS\"\n-  \"\n-{\n-  rtx temp = gen_reg_rtx (DImode);\n-  emit_insn (gen_rtx_SET (VOIDmode, temp,\n-\t\t\t  gen_rtx_UNSIGNED_FIX (DImode,\n-\t\t\t\t\t\tgen_rtx_FIX (SFmode,\n-\t\t\t\t\t\t\t     operands[1]))));\n-  emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n-\t\t\t  gen_rtx_SUBREG (SImode, temp, 0)));\n-  DONE;\n-}\")\n-\f\n-;; Arithmetic instructions.\n-\n-(define_insn \"subsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(minus:SI (match_operand:SI 1 \"arith_operand\" \"dI\")\n-\t\t  (match_operand:SI 2 \"arith_operand\" \"dI\")))]\n-  \"\"\n-  \"subo\t%2,%1,%0\")\n-\n-;; Try to generate an lda instruction when it would be faster than an\n-;; add instruction.\n-;; Some assemblers apparently won't accept two addresses added together.\n-\n-;; ??? The condition should be improved to reject the case of two\n-;; symbolic constants.\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d,d,d\")\n-\t(plus:SI (match_operand:SI 1 \"arith32_operand\" \"%dn,i,dn\")\n-\t\t (match_operand:SI 2 \"arith32_operand\" \"dn,dn,i\")))]\n-  \"(TARGET_C_SERIES) && (CONSTANT_P (operands[1]) || CONSTANT_P (operands[2]))\"\n-  \"*\n-{\n-  if (GET_CODE (operands[1]) == CONST_INT)\n-    {\n-      rtx tmp = operands[1];\n-      operands[1] = operands[2];\n-      operands[2] = tmp;\n-    }\n-  if (GET_CODE (operands[2]) == CONST_INT\n-      && GET_CODE (operands[1]) == REG\n-      && i960_last_insn_type != I_TYPE_REG)\n-    {\n-      if (INTVAL (operands[2]) < 0 && INTVAL (operands[2]) > -32)\n-\treturn \\\"subo\t%n2,%1,%0\\\";\n-      else if (INTVAL (operands[2]) >= 0 && INTVAL (operands[2]) < 32)\n-\treturn \\\"addo\t%1,%2,%0\\\";\n-    }\n-  /* Non-canonical results (op1 == const, op2 != const) have been seen\n-     in reload output when both operands were symbols before reload, so\n-     we deal with it here.  This may be a fault of the constraints above.  */\n-  if (CONSTANT_P (operands[1]))\n-    {\n-      if (CONSTANT_P (operands[2]))\n-\treturn \\\"lda\t%1+%2,%0\\\";\n-      else\n-\treturn \\\"lda\t%1(%2),%0\\\";\n-    }\n-  return \\\"lda\t%2(%1),%0\\\";\n-}\")\n-\n-(define_insn \"addsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(plus:SI (match_operand:SI 1 \"signed_arith_operand\" \"%dI\")\n-\t\t (match_operand:SI 2 \"signed_arith_operand\" \"dIK\")))]\n-  \"\"\n-  \"*\n-{\n-  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) < 0)\n-    return \\\"subo\t%n2,%1,%0\\\";\n-  if (i960_bypass (insn, operands[1], operands[2], 0))\n-    return \\\"addo\t%2,%1,%0\\\";\n-  return \\\"addo\t%1,%2,%0\\\";\n-}\")\n-\n-(define_insn \"mulsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(mult:SI (match_operand:SI 1 \"arith_operand\" \"%dI\")\n-\t\t (match_operand:SI 2 \"arith_operand\" \"dI\")))]\n-  \"\"\n-  \"*\n-{\n-  if (i960_bypass (insn, operands[1], operands[2], 0))\n-    return \\\"mulo\t%2,%1,%0\\\";\n-  return \\\"mulo\t%1,%2,%0\\\";\n-}\"\n-  [(set_attr \"type\" \"mult\")])\n-\n-(define_insn \"umulsidi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-\t(mult:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"d\"))\n-\t\t (zero_extend:DI (match_operand:SI 2 \"register_operand\" \"d\"))))]\n-  \"\"\n-  \"*\n-{\n-  if (i960_bypass (insn, operands[1], operands[2], 0))\n-    return \\\"emul\t%2,%1,%0\\\";\n-  return \\\"emul\t%1,%2,%0\\\";\n-}\"\n-  [(set_attr \"type\" \"mult\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-\t(mult:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"%d\"))\n-\t\t (match_operand:SI 2 \"literal\" \"I\")))]\n-  \"\"\n-  \"*\n-{\n-  if (i960_bypass (insn, operands[1], operands[2], 0))\n-    return \\\"emul\t%2,%1,%0\\\";\n-  return \\\"emul\t%1,%2,%0\\\";\n-}\"\n-  [(set_attr \"type\" \"mult\")])\n-\n-;; This goes after the move/add/sub/mul instructions  \n-;; because those instructions are better when they apply.\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(match_operand:SI 1 \"address_operand\" \"p\"))]\n-  \"\"\n-  \"lda\t%a1,%0\"\n-  [(set_attr \"type\" \"load\")])\n-\n-;; This will never be selected because of an \"optimization\" that GCC does.\n-;; It always converts divides by a power of 2 into a sequence of instructions\n-;; that does a right shift, and then corrects the result if it was negative.\n-\n-;; (define_insn \"\"\n-;;   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-;;         (div:SI (match_operand:SI 1 \"arith_operand\" \"dI\")\n-;;                 (match_operand:SI 2 \"power2_operand\" \"nI\")))]\n-;;   \"\"\n-;;   \"*{\n-;; \toperands[2] = GEN_INT (bitpos (INTVAL (operands[2])));\n-;; \treturn \\\"shrdi\t%2,%1,%0\\\";\n-;;   }\"\n-\n-(define_insn \"divsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (div:SI (match_operand:SI 1 \"arith_operand\" \"dI\")\n-                (match_operand:SI 2 \"arith_operand\" \"dI\")))]\n-  \"\"\n-  \"divi\t%2,%1,%0\"\n-  [(set_attr \"type\" \"div\")])\n-\n-(define_insn \"udivsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (udiv:SI (match_operand:SI 1 \"arith_operand\" \"dI\")\n-\t\t (match_operand:SI 2 \"arith_operand\" \"dI\")))]\n-  \"\"\n-  \"divo\t%2,%1,%0\"\n-  [(set_attr \"type\" \"div\")])\n-\n-;; We must use `remi' not `modi' here, to ensure that `%' has the effects\n-;; specified by the ANSI C standard.\n-\n-(define_insn \"modsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (mod:SI (match_operand:SI 1 \"arith_operand\" \"dI\")\n-                (match_operand:SI 2 \"arith_operand\" \"dI\")))]\n-  \"\"\n-  \"remi\t%2,%1,%0\"\n-  [(set_attr \"type\" \"div\")])\n-\n-(define_insn \"umodsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-        (umod:SI (match_operand:SI 1 \"arith_operand\" \"dI\")\n-\t\t (match_operand:SI 2 \"arith_operand\" \"dI\")))]\n-  \"\"\n-  \"remo\t%2,%1,%0\"\n-  [(set_attr \"type\" \"div\")])\n-\n-;; And instructions (with complement also).\n-\n-(define_insn \"andsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(and:SI (match_operand:SI 1 \"register_operand\" \"%d\")\n-\t\t(match_operand:SI 2 \"logic_operand\" \"dIM\")))]\n-  \"\"\n-  \"*\n-{\n-  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) < 0)\n-    return \\\"andnot\t%C2,%1,%0\\\";\n-  if (i960_bypass (insn, operands[1], operands[2], 0))\n-    return \\\"and\t%2,%1,%0\\\";\n-  return \\\"and\t%1,%2,%0\\\";\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(and:SI (match_operand:SI 1 \"arith_operand\" \"dI\")\n-\t\t(match_operand:SI 2 \"cmplpower2_operand\" \"n\")))]\n-  \"\"\n-  \"*\n-{\n-  operands[2] = GEN_INT (bitpos (~INTVAL (operands[2])));\n-  return \\\"clrbit\t%2,%1,%0\\\";\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(and:SI (not:SI (match_operand:SI 1 \"register_operand\" \"d\"))\n-\t\t(match_operand:SI 2 \"logic_operand\" \"dIM\")))]\n-  \"\"\n-  \"*\n-{\n-  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) < 0)\n-    return \\\"nor\t%C2,%1,%0\\\";\n-  if (i960_bypass (insn, operands[1], operands[2], 0))\n-    return \\\"notand\t%2,%1,%0\\\";\n-  return \\\"andnot\t%1,%2,%0\\\";\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(ior:SI (not:SI (match_operand:SI 1 \"register_operand\" \"%d\"))\n-\t\t(not:SI (match_operand:SI 2 \"register_operand\" \"d\"))))]\n-  \"\"\n-  \"*\n-{\n-  if (i960_bypass (insn, operands[1], operands[2], 0))\n-    return \\\"nand\t%2,%1,%0\\\";\n-  return \\\"nand\t%1,%2,%0\\\";\n-}\")\n-\n-(define_insn \"iorsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(ior:SI (match_operand:SI 1 \"register_operand\" \"%d\")\n-\t\t(match_operand:SI 2 \"logic_operand\" \"dIM\")))]\n-  \"\"\n-  \"*\n-{\n-  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) < 0)\n-    return \\\"ornot\t%C2,%1,%0\\\";\n-  if (i960_bypass (insn, operands[1], operands[2], 0))\n-    return \\\"or\t%2,%1,%0\\\";\n-  return \\\"or\t%1,%2,%0\\\";\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(ior:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-\t\t(match_operand:SI 2 \"power2_operand\" \"n\")))]\n-  \"\"\n-  \"*\n-{\n-  operands[2] = GEN_INT (bitpos (INTVAL (operands[2])));\n-  return \\\"setbit\t%2,%1,%0\\\";\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(ior:SI (not:SI (match_operand:SI 1 \"register_operand\" \"d\"))\n-\t\t(match_operand:SI 2 \"logic_operand\" \"dIM\")))]\n-  \"\"\n-  \"*\n-{\n-  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) < 0)\n-    return \\\"nand\t%C2,%1,%0\\\";\n-  if (i960_bypass (insn, operands[1], operands[2], 0))\n-    return \\\"notor\t%2,%1,%0\\\";\n-  return \\\"ornot\t%1,%2,%0\\\";\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(and:SI (not:SI (match_operand:SI 1 \"register_operand\" \"%d\"))\n-\t\t(not:SI (match_operand:SI 2 \"register_operand\" \"d\"))))]\n-  \"\"\n-  \"*\n-{\n-  if (i960_bypass (insn, operands[1], operands[2], 0))\n-    return \\\"nor\t%2,%1,%0\\\";\n-  return \\\"nor\t%1,%2,%0\\\";\n-}\")\n-\n-(define_insn \"xorsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(xor:SI (match_operand:SI 1 \"register_operand\" \"%d\")\n-\t\t(match_operand:SI 2 \"logic_operand\" \"dIM\")))]\n-  \"\"\n-  \"*\n-{\n-  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) < 0)\n-    return \\\"xnor\t%C2,%1,%0\\\";\n-  if (i960_bypass (insn, operands[1], operands[2], 0))\n-    return \\\"xor\t%2,%1,%0\\\";\n-  return \\\"xor\t%1,%2,%0\\\";\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(xor:SI (match_operand:SI 1 \"arith_operand\" \"dI\")\n-\t\t(match_operand:SI 2 \"power2_operand\" \"n\")))]\n-  \"\"\n-  \"*\n-{\n-  operands[2] = GEN_INT (bitpos (INTVAL (operands[2])));\n-  return \\\"notbit\t%2,%1,%0\\\";\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(not:SI (xor:SI (match_operand:SI 1 \"register_operand\" \"%d\")\n-\t\t\t(match_operand:SI 2 \"register_operand\" \"d\"))))]\n-  \"\"\n-  \"*\n-{\n-  if (i960_bypass (insn, operands[1], operands[2], 0))\n-    return \\\"xnor\t%2,%1,%0\\\";\n-  return \\\"xnor\t%2,%1,%0\\\";\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(ior:SI (ashift:SI (const_int 1)\n-\t\t\t   (match_operand:SI 1 \"register_operand\" \"d\"))\n-\t\t(match_operand:SI 2 \"arith_operand\" \"dI\")))]\n-  \"\"\n-  \"setbit\t%1,%2,%0\")\n-\n-;; (not (ashift 1 reg)) canonicalizes to (rotate -2 reg)\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(and:SI (rotate:SI (const_int -2)\n-\t\t\t   (match_operand:SI 1 \"register_operand\" \"d\"))\n-\t\t(match_operand:SI 2 \"register_operand\" \"d\")))]\n-  \"\"\n-  \"clrbit\t%1,%2,%0\")\n-\n-;; The above pattern canonicalizes to this when both the input and output\n-;; are the same pseudo-register.\n-(define_insn \"\"\n-  [(set (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"+d\")\n-\t\t\t (const_int 1)\n-\t\t\t (match_operand:SI 1 \"register_operand\" \"d\"))\n-\t(const_int 0))]\n-  \"\"\n-  \"clrbit\t%1,%0,%0\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(xor:SI (ashift:SI (const_int 1)\n-\t\t\t   (match_operand:SI 1 \"register_operand\" \"d\"))\n-\t\t(match_operand:SI 2 \"arith_operand\" \"dI\")))]\n-  \"\"\n-  \"notbit\t%1,%2,%0\")\n-\n-(define_insn \"negsi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(neg:SI (match_operand:SI 1 \"arith_operand\" \"dI\")))]\n-  \"\"\n-  \"subo\t%1,0,%0\"\n-  [(set_attr \"length\" \"1\")])\n-\n-(define_insn \"one_cmplsi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(not:SI (match_operand:SI 1 \"arith_operand\" \"dI\")))]\n-  \"\"\n-  \"not\t%1,%0\"\n-  [(set_attr \"length\" \"1\")])\n-\f\n-;; Floating point arithmetic instructions.\n-\n-(define_insn \"adddf3\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=d*f\")\n-\t(plus:DF (match_operand:DF 1 \"fp_arith_operand\" \"%rGH\")\n-\t\t (match_operand:DF 2 \"fp_arith_operand\" \"rGH\")))]\n-  \"TARGET_NUMERICS\"\n-  \"addrl\t%1,%2,%0\"\n-  [(set_attr \"type\" \"fpadd\")])\n-\n-(define_insn \"addsf3\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=d*f\")\n-\t(plus:SF (match_operand:SF 1 \"fp_arith_operand\" \"%rGH\")\n-\t\t (match_operand:SF 2 \"fp_arith_operand\" \"rGH\")))]\n-  \"TARGET_NUMERICS\"\n-  \"addr\t%1,%2,%0\"\n-  [(set_attr \"type\" \"fpadd\")])\n-\n-\n-(define_insn \"subdf3\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=d*f\")\n-\t(minus:DF (match_operand:DF 1 \"fp_arith_operand\" \"rGH\")\n-\t\t  (match_operand:DF 2 \"fp_arith_operand\" \"rGH\")))]\n-  \"TARGET_NUMERICS\"\n-  \"subrl\t%2,%1,%0\"\n-  [(set_attr \"type\" \"fpadd\")])\n-\n-(define_insn \"subsf3\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=d*f\")\n-\t(minus:SF (match_operand:SF 1 \"fp_arith_operand\" \"rGH\")\n-\t\t  (match_operand:SF 2 \"fp_arith_operand\" \"rGH\")))]\n-  \"TARGET_NUMERICS\"\n-  \"subr\t%2,%1,%0\"\n-  [(set_attr \"type\" \"fpadd\")])\n-\n-\n-(define_insn \"muldf3\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=d*f\")\n-\t(mult:DF (match_operand:DF 1 \"fp_arith_operand\" \"%rGH\")\n-\t\t (match_operand:DF 2 \"fp_arith_operand\" \"rGH\")))]\n-  \"TARGET_NUMERICS\"\n-  \"mulrl\t%1,%2,%0\"\n-  [(set_attr \"type\" \"fpmul\")])\n-\n-(define_insn \"mulsf3\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=d*f\")\n-\t(mult:SF (match_operand:SF 1 \"fp_arith_operand\" \"%rGH\")\n-\t\t (match_operand:SF 2 \"fp_arith_operand\" \"rGH\")))]\n-  \"TARGET_NUMERICS\"\n-  \"mulr\t%1,%2,%0\"\n-  [(set_attr \"type\" \"fpmul\")])\n-\n-\n-(define_insn \"divdf3\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=d*f\")\n-\t(div:DF (match_operand:DF 1 \"fp_arith_operand\" \"rGH\")\n-\t\t(match_operand:DF 2 \"fp_arith_operand\" \"rGH\")))]\n-  \"TARGET_NUMERICS\"\n-  \"divrl\t%2,%1,%0\"\n-  [(set_attr \"type\" \"fpdiv\")])\n-\n-(define_insn \"divsf3\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=d*f\")\n-\t(div:SF (match_operand:SF 1 \"fp_arith_operand\" \"rGH\")\n-\t\t(match_operand:SF 2 \"fp_arith_operand\" \"rGH\")))]\n-  \"TARGET_NUMERICS\"\n-  \"divr\t%2,%1,%0\"\n-  [(set_attr \"type\" \"fpdiv\")])\n-\n-(define_insn \"negdf2\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=d,d*f\")\n-\t(neg:DF (match_operand:DF 1 \"register_operand\" \"d,r\")))]\n-  \"\"\n-  \"*\n-{\n-  if (which_alternative == 0)\n-    {\n-      if (REGNO (operands[0]) == REGNO (operands[1]))\n-\treturn \\\"notbit\t31,%D1,%D0\\\";\n-      return \\\"mov\t%1,%0\\;notbit\t31,%D1,%D0\\\";\n-    }\n-  return \\\"subrl\t%1,0f0.0,%0\\\";\n-}\"\n-  [(set_attr \"type\" \"fpadd\")])\n-\n-(define_insn \"negsf2\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=d,d*f\")\n-\t(neg:SF (match_operand:SF 1 \"register_operand\" \"d,r\")))]\n-  \"\"\n-  \"@\n-  notbit\t31,%1,%0\n-  subr\t%1,0f0.0,%0\"\n-  [(set_attr \"type\" \"fpadd\")])\n-\n-;;; The abs patterns also work even if the target machine doesn't have\n-;;; floating point, because in that case dstreg and srcreg will always be\n-;;; less than 32.\n-\n-(define_insn \"absdf2\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=d*f\")\n-\t(abs:DF (match_operand:DF 1 \"register_operand\" \"df\")))]\n-  \"\"\n-  \"*\n-{\n-  int dstreg = REGNO (operands[0]);\n-  int srcreg = REGNO (operands[1]);\n-\n-  if (dstreg < 32)\n-    {\n-      if (srcreg < 32)\n-\t{\n-\t  if (dstreg != srcreg)\n-\t    output_asm_insn (\\\"mov\t%1,%0\\\", operands);\n-\t  return \\\"clrbit\t31,%D1,%D0\\\";\n-\t}\n-      /* Src is an fp reg.  */\n-      return \\\"movrl\t%1,%0\\;clrbit\t31,%D1,%D0\\\";\n-    }\n-  if (srcreg >= 32)\n-    return \\\"cpysre\t%1,0f0.0,%0\\\";\n-  return \\\"movrl\t%1,%0\\;cpysre\t%0,0f0.0,%0\\\";\n-}\"\n-  [(set_attr \"type\" \"multi\")])\n-\n-(define_insn \"abssf2\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=d*f\")\n-\t(abs:SF (match_operand:SF 1 \"register_operand\" \"df\")))]\n-  \"\"\n-  \"*\n-{\n-  int dstreg = REGNO (operands[0]);\n-  int srcreg = REGNO (operands[1]);\n-\n-  if (dstreg < 32 && srcreg < 32)\n-    return \\\"clrbit\t31,%1,%0\\\";\n-\n-  if (dstreg >= 32 && srcreg >= 32)\n-    return \\\"cpysre\t%1,0f0.0,%0\\\";\n-\n-  if (dstreg < 32)\n-    return \\\"movr\t%1,%0\\;clrbit\t31,%0,%0\\\";\n-\n-  return \\\"movr\t%1,%0\\;cpysre\t%0,0f0.0,%0\\\";\n-}\"\n-  [(set_attr \"type\" \"multi\")])\n-\f\n-;; Tetra (16 byte) float support.\n-\n-(define_expand \"cmptf\"\n-  [(set (reg:CC 36)\n-\t(compare:CC (match_operand:TF 0 \"register_operand\" \"\")\n-\t\t    (match_operand:TF 1 \"nonmemory_operand\" \"\")))]\n-  \"TARGET_NUMERICS\"\n-  \"\n-{\n-  i960_compare_op0 = operands[0];\n-  i960_compare_op1 = operands[1];\n-  DONE;\n-}\")\n-\n-(define_insn \"\"\n-  [(set (reg:CC 36)\n-\t(compare:CC (match_operand:TF 0 \"register_operand\" \"f\")\n-\t\t    (match_operand:TF 1 \"nonmemory_operand\" \"fGH\")))]\n-  \"TARGET_NUMERICS\"\n-  \"cmpr %0,%1\"\n-  [(set_attr \"type\" \"fpcc\")])\n-\n-(define_expand \"movtf\"\n-  [(set (match_operand:TF 0 \"general_operand\" \"\")\n-\t(match_operand:TF 1 \"fpmove_src_operand\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  if (emit_move_sequence (operands, TFmode))\n-    DONE;\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:TF 0 \"general_operand\" \"=r,f,d,d,m\")\n-\t(match_operand:TF 1 \"fpmove_src_operand\" \"r,GH,F,m,d\"))]\n-  \"register_operand (operands[0], TFmode)\n-   || register_operand (operands[1], TFmode)\"\n-  \"*\n-{\n-  switch (which_alternative)\n-    {\n-    case 0:\n-      if (FP_REG_P (operands[0]) || FP_REG_P (operands[1]))\n-\treturn \\\"movre\t%1,%0\\\";\n-      else\n-\treturn \\\"movq\t%1,%0\\\";\n-    case 1:\n-      return \\\"movre\t%1,%0\\\";\n-    case 2:\n-      return i960_output_ldconst (operands[0], operands[1]);\n-    case 3:\n-      return \\\"ldt\t%1,%0\\\";\n-    case 4:\n-      return \\\"stt\t%1,%0\\\";\n-    default:\n-      abort();\n-    }\n-}\"\n-  [(set_attr \"type\" \"move,move,load,fpload,fpstore\")])\n-\n-(define_insn \"extendsftf2\"\n-  [(set (match_operand:TF 0 \"register_operand\" \"=f,d\")\n-\t(float_extend:TF\n-\t (match_operand:SF 1 \"register_operand\" \"d,f\")))]\n-  \"TARGET_NUMERICS\"\n-  \"@\n-  movr\t%1,%0\n-  movre\t%1,%0\"\n-  [(set_attr \"type\" \"fpmove\")])\n-\n-(define_insn \"extenddftf2\"\n-  [(set (match_operand:TF 0 \"register_operand\" \"=f,d\")\n-\t(float_extend:TF\n-\t (match_operand:DF 1 \"register_operand\" \"d,f\")))]\n-  \"TARGET_NUMERICS\"\n-  \"@\n-  movrl\t%1,%0\n-  movre\t%1,%0\"\n-  [(set_attr \"type\" \"fpmove\")])\n-\n-(define_insn \"trunctfdf2\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=d\")\n-\t(float_truncate:DF\n-\t (match_operand:TF 1 \"register_operand\" \"f\")))]\n-  \"TARGET_NUMERICS\"\n-  \"movrl\t%1,%0\"\n-  [(set_attr \"type\" \"fpmove\")])\n-\n-(define_insn \"trunctfsf2\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=d\")\n-\t(float_truncate:SF\n-\t (match_operand:TF 1 \"register_operand\" \"f\")))]\n-  \"TARGET_NUMERICS\"\n-  \"movr\t%1,%0\"\n-  [(set_attr \"type\" \"fpmove\")])\n-\n-(define_insn \"floatsitf2\"\n-  [(set (match_operand:TF 0 \"register_operand\" \"=f\")\n-\t(float:TF (match_operand:SI 1 \"register_operand\" \"d\")))]\n-  \"TARGET_NUMERICS\"\n-  \"cvtir\t%1,%0\"\n-  [(set_attr \"type\" \"fpcvt\")])\n-\n-(define_insn \"fix_trunctfsi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(fix:SI (fix:TF (match_operand:TF 1 \"register_operand\" \"f\"))))]\n-  \"TARGET_NUMERICS\"\n-  \"cvtzri\t%1,%0\"\n-  [(set_attr \"type\" \"fpcvt\")])\n-\n-(define_insn \"fixuns_trunctfsi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(unsigned_fix:SI (fix:TF (match_operand:TF 1 \"register_operand\" \"f\"))))]\n-  \"TARGET_NUMERICS\"\n-  \"cvtzri\t%1,%0\"\n-  [(set_attr \"type\" \"fpcvt\")])\n-\n-(define_insn \"addtf3\"\n-  [(set (match_operand:TF 0 \"register_operand\" \"=f\")\n-\t(plus:TF (match_operand:TF 1 \"nonmemory_operand\" \"%fGH\")\n-\t\t (match_operand:TF 2 \"nonmemory_operand\" \"fGH\")))]\n-  \"TARGET_NUMERICS\"\n-  \"addr\t%1,%2,%0\"\n-  [(set_attr \"type\" \"fpadd\")])\n-\n-(define_insn \"subtf3\"\n-  [(set (match_operand:TF 0 \"register_operand\" \"=f\")\n-\t(minus:TF (match_operand:TF 1 \"nonmemory_operand\" \"fGH\")\n-\t\t  (match_operand:TF 2 \"nonmemory_operand\" \"fGH\")))]\n-  \"TARGET_NUMERICS\"\n-  \"subr\t%2,%1,%0\"\n-  [(set_attr \"type\" \"fpadd\")])\n-\n-(define_insn \"multf3\"\n-  [(set (match_operand:TF 0 \"register_operand\" \"=f\")\n-\t(mult:TF (match_operand:TF 1 \"nonmemory_operand\" \"%fGH\")\n-\t\t (match_operand:TF 2 \"nonmemory_operand\" \"fGH\")))]\n-  \"TARGET_NUMERICS\"\n-  \"mulr\t%1,%2,%0\"\n-  [(set_attr \"type\" \"fpmul\")])\n-\n-(define_insn \"divtf3\"\n-  [(set (match_operand:TF 0 \"register_operand\" \"=f\")\n-\t(div:TF (match_operand:TF 1 \"nonmemory_operand\" \"fGH\")\n-\t\t(match_operand:TF 2 \"nonmemory_operand\" \"fGH\")))]\n-  \"TARGET_NUMERICS\"\n-  \"divr\t%2,%1,%0\"\n-  [(set_attr \"type\" \"fpdiv\")])\n-\n-(define_insn \"negtf2\"\n-  [(set (match_operand:TF 0 \"register_operand\" \"=f\")\n-\t(neg:TF (match_operand:TF 1 \"register_operand\" \"f\")))]\n-  \"TARGET_NUMERICS\"\n-  \"subr\t%1,0f0.0,%0\"\n-  [(set_attr \"type\" \"fpadd\")])\n-\n-(define_insn \"abstf2\"\n-  [(set (match_operand:TF 0 \"register_operand\" \"=f\")\n-\t(abs:TF (match_operand:TF 1 \"register_operand\" \"f\")))]\n-  \"(TARGET_NUMERICS)\"\n-  \"cpysre\t%1,0f0.0,%0\"\n-  [(set_attr \"type\" \"fpmove\")])\n-\f\n-;; Arithmetic shift instructions.\n-\n-;; The shli instruction generates an overflow fault if the sign changes.\n-;; In the case of overflow, it does not give the natural result, it instead\n-;; gives the last shift value before the overflow.  We can not use this\n-;; instruction because gcc thinks that arithmetic left shift and logical\n-;; left shift are identical, and sometimes canonicalizes the logical left\n-;; shift to an arithmetic left shift.  Therefore we must always use the\n-;; logical left shift instruction.\n-\n-(define_insn \"ashlsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(ashift:SI (match_operand:SI 1 \"arith_operand\" \"dI\")\n-\t\t   (match_operand:SI 2 \"arith_operand\" \"dI\")))]\n-  \"\"\n-  \"shlo\t%2,%1,%0\"\n-  [(set_attr \"type\" \"alu2\")])\n-\n-(define_insn \"ashrsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(ashiftrt:SI (match_operand:SI 1 \"arith_operand\" \"dI\")\n-\t\t     (match_operand:SI 2 \"arith_operand\" \"dI\")))]\n-  \"\"\n-  \"shri\t%2,%1,%0\"\n-  [(set_attr \"type\" \"alu2\")])\n-\n-(define_insn \"lshrsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(lshiftrt:SI (match_operand:SI 1 \"arith_operand\" \"dI\")\n-\t\t   (match_operand:SI 2 \"arith_operand\" \"dI\")))]\n-  \"\"\n-  \"shro\t%2,%1,%0\"\n-  [(set_attr \"type\" \"alu2\")])\n-\f\n-;; Unconditional and other jump instructions.\n-\n-(define_insn \"jump\"\n-  [(set (pc)\n-\t(label_ref (match_operand 0 \"\" \"\")))]\n-  \"\"\n-  \"b\t%l0\"\n-  [(set_attr \"type\" \"branch\")])\n-\n-(define_insn \"indirect_jump\"\n-  [(set (pc) (match_operand:SI 0 \"address_operand\" \"p\"))]\n-  \"\"\n-  \"bx\t%a0\"\n-  [(set_attr \"type\" \"branch\")])\n-\n-(define_insn \"tablejump\"\n-  [(set (pc) (match_operand:SI 0 \"register_operand\" \"d\"))\n-   (use (label_ref (match_operand 1 \"\" \"\")))]\n-  \"\"\n-  \"*\n-{\n-  if (flag_pic)\n-    return \\\"bx\t%l1(%0)\\\";\n-  else\n-    return \\\"bx\t(%0)\\\";\n-}\"\n-  [(set_attr \"type\" \"branch\")])\n-\n-;;- jump to subroutine\n-\n-(define_expand \"call\"\n-  [(call (match_operand:SI 0 \"memory_operand\" \"m\")\n-\t (match_operand:SI 1 \"immediate_operand\" \"i\"))]\n-  \"\"\n-  \"\n-{\n-  emit_call_insn (gen_call_internal (operands[0], operands[1],\n-\t\t\t\t     virtual_outgoing_args_rtx));\n-  DONE;\n-}\")\n-\n-;; We need a call saved register allocated for the match_scratch, so we use\n-;; 'l' because all local registers are call saved.\n-\n-;; ??? I would prefer to use a match_scratch here, but match_scratch allocated\n-;; registers can't be used for spills.  In a function with lots of calls,\n-;; local-alloc may allocate all local registers to a match_scratch, leaving\n-;; no local registers available for spills.\n-\n-(define_insn \"call_internal\"\n-  [(call (match_operand:SI 0 \"memory_operand\" \"m\")\n-\t (match_operand:SI 1 \"immediate_operand\" \"i\"))\n-   (use (match_operand:SI 2 \"address_operand\" \"p\"))\n-   (clobber (reg:SI 19))]\n-  \"\"\n-  \"* return i960_output_call_insn (operands[0], operands[1], operands[2],\n-\t\t\t\t   insn);\"\n-  [(set_attr \"type\" \"call\")])\n-\n-(define_expand \"call_value\"\n-  [(set (match_operand 0 \"register_operand\" \"=d\")\n-\t(call (match_operand:SI 1 \"memory_operand\" \"m\")\n-\t      (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n-  \"\"\n-  \"\n-{\n-  emit_call_insn (gen_call_value_internal (operands[0], operands[1],\n-\t\t\t\t\t   operands[2],\n-\t\t\t\t           virtual_outgoing_args_rtx));\n-  DONE;\n-}\")\n-\n-;; We need a call saved register allocated for the match_scratch, so we use\n-;; 'l' because all local registers are call saved.\n-\n-(define_insn \"call_value_internal\"\n-  [(set (match_operand 0 \"register_operand\" \"=d\")\n-\t(call (match_operand:SI 1 \"memory_operand\" \"m\")\n-\t      (match_operand:SI 2 \"immediate_operand\" \"i\")))\n-   (use (match_operand:SI 3 \"address_operand\" \"p\"))\n-   (clobber (reg:SI 19))]\n-  \"\"\n-  \"* return i960_output_call_insn (operands[1], operands[2], operands[3],\n-\t\t\t\t   insn);\"\n-  [(set_attr \"type\" \"call\")])\n-\n-(define_insn \"return\"\n-  [(return)]\n-  \"\"\n-  \"* return i960_output_ret_insn (insn);\"\n-  [(set_attr \"type\" \"branch\")])\n-\n-;; A return instruction.  Used only by nonlocal_goto to change the\n-;; stack pointer, frame pointer, previous frame pointer and the return\n-;; instruction pointer.\n-(define_insn \"ret\"\n-  [(set (pc) (unspec_volatile [(reg:SI 16)] 3))]\n-  \"\"\n-  \"ret\"\n-  [(set_attr \"type\" \"branch\")\n-   (set_attr \"length\" \"1\")])\n-\n-(define_expand \"nonlocal_goto\"\n-  [(match_operand:SI 0 \"\" \"\")\n-   (match_operand:SI 1 \"general_operand\" \"\")\n-   (match_operand:SI 2 \"general_operand\" \"\")\n-   (match_operand:SI 3 \"general_operand\" \"\")]\n-  \"\"\n-  \"\n-{\n-  rtx chain = operands[0];\n-  rtx handler = operands[1];\n-  rtx stack = operands[2];\n-\n-  /* We must restore the stack pointer, frame pointer, previous frame\n-     pointer and the return instruction pointer.  Since the ret\n-     instruction does all this for us with one instruction, we arrange\n-     everything so that ret will do everything we need done.  */\n-\n-  /* First, we must flush the register windows, so that we can modify\n-     the saved local registers on the stack directly and because we\n-     are going to change the previous frame pointer.  */\n-\n-  emit_insn (gen_flush_register_windows ());\n-\n-  /* Load the static chain value for the containing fn into fp.  This is needed\n-     because STACK refers to fp.  */\n-  emit_move_insn (hard_frame_pointer_rtx, chain);\n-\n-  /* Now move the adjusted value into the pfp register for the following return\n-     instruction.  */\n-  emit_move_insn (gen_rtx (REG, SImode, 16),\n-\t\t  plus_constant (hard_frame_pointer_rtx, -64));\n-\n-  /* Next, we put the address that we want to transfer to, into the\n-     saved $rip value in the frame.  Once we ret below, that value\n-     will be loaded into the pc (IP).  */\n-\n-  emit_move_insn (gen_rtx (MEM, SImode,\n-\t\t\t   plus_constant (hard_frame_pointer_rtx, -56)),\n-\t\t  handler);\n-\n-  /* Next, we put stack into the saved $sp value in the frame.  */\n-  emit_move_insn (gen_rtx (MEM, SImode,\n-\t\t\t   plus_constant (hard_frame_pointer_rtx, -60)),\n-\t\t  stack);\n-\n-  /* And finally, we can now just ret to get all the values saved\n-     above into all the right registers, and also, all the local\n-     register that were in use in the function, are restored from\n-     their saved values (from the call instruction) on the stack\n-     because we are very careful to ret from the exact save area in\n-     use during the original call.  */\n-\n-  emit_jump_insn (gen_ret ());\n-  emit_barrier ();\n-  DONE;\n-}\")\n-\n-;; Special insn to flush register windows.\n-(define_insn \"flush_register_windows\"\n-  [(unspec_volatile [(const_int 0)] 1)]\n-  \"\"\n-  \"flushreg\"\n-  [(set_attr \"type\" \"misc\")\n-   (set_attr \"length\" \"1\")])\n-\n-(define_insn \"nop\"\n-  [(const_int 0)]\n-  \"\"\n-  \"\")\n-\f\n-;; Various peephole optimizations for multiple-word moves, loads, and stores.\n-;; Multiple register moves.\n-\n-;; Matched 5/28/91\n-(define_peephole\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(match_operand:SI 1 \"register_operand\" \"r\"))\n-   (set (match_operand:SI 2 \"register_operand\" \"=r\")\n-\t(match_operand:SI 3 \"register_operand\" \"r\"))\n-   (set (match_operand:SI 4 \"register_operand\" \"=r\")\n-\t(match_operand:SI 5 \"register_operand\" \"r\"))\n-   (set (match_operand:SI 6 \"register_operand\" \"=r\")\n-\t(match_operand:SI 7 \"register_operand\" \"r\"))]\n-  \"((REGNO (operands[0]) & 3) == 0)\n-   && ((REGNO (operands[1]) & 3) == 0)\n-   && (REGNO (operands[0]) + 1 == REGNO (operands[2]))\n-   && (REGNO (operands[1]) + 1 == REGNO (operands[3]))\n-   && (REGNO (operands[0]) + 2 == REGNO (operands[4]))\n-   && (REGNO (operands[1]) + 2 == REGNO (operands[5]))\n-   && (REGNO (operands[0]) + 3 == REGNO (operands[6]))\n-   && (REGNO (operands[1]) + 3 == REGNO (operands[7]))\"\n-  \"movq\t%1,%0\")\n-\n-;; Matched 4/17/92\n-(define_peephole\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(match_operand:DI 1 \"register_operand\" \"r\"))\n-   (set (match_operand:DI 2 \"register_operand\" \"=r\")\n-\t(match_operand:DI 3 \"register_operand\" \"r\"))]\n-  \"((REGNO (operands[0]) & 3) == 0)\n-   && ((REGNO (operands[1]) & 3) == 0)\n-   && (REGNO (operands[0]) + 2 == REGNO (operands[2]))\n-   && (REGNO (operands[1]) + 2 == REGNO (operands[3]))\"\n-  \"movq\t%1,%0\")\n-\n-;; Matched 4/17/92\n-(define_peephole\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(match_operand:DI 1 \"register_operand\" \"r\"))\n-   (set (match_operand:SI 2 \"register_operand\" \"=r\")\n-\t(match_operand:SI 3 \"register_operand\" \"r\"))\n-   (set (match_operand:SI 4 \"register_operand\" \"=r\")\n-\t(match_operand:SI 5 \"register_operand\" \"r\"))]\n-  \"((REGNO (operands[0]) & 3) == 0)\n-   && ((REGNO (operands[1]) & 3) == 0)\n-   && (REGNO (operands[0]) + 2 == REGNO (operands[2]))\n-   && (REGNO (operands[1]) + 2 == REGNO (operands[3]))\n-   && (REGNO (operands[0]) + 3 == REGNO (operands[4]))\n-   && (REGNO (operands[1]) + 3 == REGNO (operands[5]))\"\n-  \"movq\t%1,%0\")\n-\n-;; Matched 4/17/92\n-(define_peephole\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(match_operand:SI 1 \"register_operand\" \"r\"))\n-   (set (match_operand:SI 2 \"register_operand\" \"=r\")\n-\t(match_operand:SI 3 \"register_operand\" \"r\"))\n-   (set (match_operand:DI 4 \"register_operand\" \"=r\")\n-\t(match_operand:DI 5 \"register_operand\" \"r\"))]\n-  \"((REGNO (operands[0]) & 3) == 0)\n-   && ((REGNO (operands[1]) & 3) == 0)\n-   && (REGNO (operands[0]) + 1 == REGNO (operands[2]))\n-   && (REGNO (operands[1]) + 1 == REGNO (operands[3]))\n-   && (REGNO (operands[0]) + 2 == REGNO (operands[4]))\n-   && (REGNO (operands[1]) + 2 == REGNO (operands[5]))\"\n-  \"movq\t%1,%0\")\n-\n-;; Matched 4/17/92\n-(define_peephole\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(match_operand:DI 1 \"register_operand\" \"r\"))\n-   (set (match_operand:SI 2 \"register_operand\" \"=r\")\n-\t(match_operand:SI 3 \"register_operand\" \"r\"))]\n-  \"((REGNO (operands[0]) & 3) == 0)\n-   && ((REGNO (operands[1]) & 3) == 0)\n-   && (REGNO (operands[0]) + 2 == REGNO (operands[2]))\n-   && (REGNO (operands[1]) + 2 == REGNO (operands[3]))\"\n-  \"movt\t%1,%0\")\n-\n-;; Matched 5/28/91\n-(define_peephole\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(match_operand:SI 1 \"register_operand\" \"r\"))\n-   (set (match_operand:SI 2 \"register_operand\" \"=r\")\n-\t(match_operand:SI 3 \"register_operand\" \"r\"))\n-   (set (match_operand:SI 4 \"register_operand\" \"=r\")\n-\t(match_operand:SI 5 \"register_operand\" \"r\"))]\n-  \"((REGNO (operands[0]) & 3) == 0)\n-   && ((REGNO (operands[1]) & 3) == 0)\n-   && (REGNO (operands[0]) + 1 == REGNO (operands[2]))\n-   && (REGNO (operands[1]) + 1 == REGNO (operands[3]))\n-   && (REGNO (operands[0]) + 2 == REGNO (operands[4]))\n-   && (REGNO (operands[1]) + 2 == REGNO (operands[5]))\"\n-  \"movt\t%1,%0\")\n-\n-;; Matched 5/28/91\n-(define_peephole\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(match_operand:SI 1 \"register_operand\" \"r\"))\n-   (set (match_operand:SI 2 \"register_operand\" \"=r\")\n-\t(match_operand:SI 3 \"register_operand\" \"r\"))]\n-  \"((REGNO (operands[0]) & 1) == 0)\n-   && ((REGNO (operands[1]) & 1) == 0)\n-   && (REGNO (operands[0]) + 1 == REGNO (operands[2]))\n-   && (REGNO (operands[1]) + 1 == REGNO (operands[3]))\"\n-  \"movl\t%1,%0\")\n-\f\n-; Multiple register loads.\n-\n-;; Matched 6/15/91\n-(define_peephole\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(mem:SI (plus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t\t (match_operand:SI 2 \"immediate_operand\" \"n\"))))\n-   (set (match_operand:SI 3 \"register_operand\" \"=r\")\n-\t(mem:SI (plus:SI (match_dup 1)\n-\t\t\t (match_operand:SI 4 \"immediate_operand\" \"n\"))))\n-   (set (match_operand:SI 5 \"register_operand\" \"=r\")\n-\t(mem:SI (plus:SI (match_dup 1)\n-\t\t\t (match_operand:SI 6 \"immediate_operand\" \"n\"))))\n-   (set (match_operand:SI 7 \"register_operand\" \"=r\")\n-\t(mem:SI (plus:SI (match_dup 1)\n-\t\t\t (match_operand:SI 8 \"immediate_operand\" \"n\"))))]\n-  \"(i960_si_ti (operands[1], operands[2]) && ((REGNO (operands[0]) & 3) == 0)\n-   && (REGNO (operands[1]) != REGNO (operands[0]))\n-   && (REGNO (operands[0]) + 1 == REGNO (operands[3]))\n-   && (REGNO (operands[1]) != REGNO (operands[3]))\n-   && (REGNO (operands[0]) + 2 == REGNO (operands[5]))\n-   && (REGNO (operands[1]) != REGNO (operands[5]))\n-   && (REGNO (operands[0]) + 3 == REGNO (operands[7]))\n-   && (INTVAL (operands[2]) + 4 == INTVAL (operands[4]))\n-   && (INTVAL (operands[2]) + 8 == INTVAL (operands[6]))\n-   && (INTVAL (operands[2]) + 12 == INTVAL (operands[8])))\"\n-  \"ldq\t%2(%1),%0\")\n-\n-;; Matched 5/28/91\n-(define_peephole\n-  [(set (match_operand:DF 0 \"register_operand\" \"=d\")\n-\t(mem:DF (plus:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-\t\t\t (match_operand:SI 2 \"immediate_operand\" \"n\"))))\n-   (set (match_operand:DF 3 \"register_operand\" \"=d\")\n-\t(mem:DF (plus:SI (match_dup 1)\n-\t\t\t (match_operand:SI 4 \"immediate_operand\" \"n\"))))]\n-  \"(i960_si_ti (operands[1], operands[2]) && ((REGNO (operands[0]) & 3) == 0)\n-   && (REGNO (operands[1]) != REGNO (operands[0]))\n-   && (REGNO (operands[0]) + 2 == REGNO (operands[3]))\n-   && (REGNO (operands[1]) != REGNO (operands[3]))\n-   && (INTVAL (operands[2]) + 8 == INTVAL (operands[4])))\"\n-  \"ldq\t%2(%1),%0\")\n-\n-;; Matched 1/24/92\n-(define_peephole\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-\t(mem:DI (plus:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-\t\t\t (match_operand:SI 2 \"immediate_operand\" \"n\"))))\n-   (set (match_operand:DI 3 \"register_operand\" \"=d\")\n-\t(mem:DI (plus:SI (match_dup 1)\n-\t\t\t (match_operand:SI 4 \"immediate_operand\" \"n\"))))]\n-  \"(i960_si_ti (operands[1], operands[2]) && ((REGNO (operands[0]) & 3) == 0)\n-   && (REGNO (operands[1]) != REGNO (operands[0]))\n-   && (REGNO (operands[0]) + 2 == REGNO (operands[3]))\n-   && (REGNO (operands[1]) != REGNO (operands[3]))\n-   && (INTVAL (operands[2]) + 8 == INTVAL (operands[4])))\"\n-  \"ldq\t%2(%1),%0\")\n-\n-;; Matched 4/17/92\n-(define_peephole\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(mem:SI (match_operand:SI 1 \"register_operand\" \"d\")))\n-   (set (match_operand:SI 2 \"register_operand\" \"=d\")\n-\t(mem:SI (plus:SI (match_dup 1)\n-\t\t\t (match_operand:SI 3 \"immediate_operand\" \"n\"))))\n-   (set (match_operand:SI 4 \"register_operand\" \"=d\")\n-\t(mem:SI (plus:SI (match_dup 1)\n-\t\t\t (match_operand:SI 5 \"immediate_operand\" \"n\"))))\n-   (set (match_operand:SI 6 \"register_operand\" \"=d\")\n-\t(mem:SI (plus:SI (match_dup 1)\n-\t\t\t (match_operand:SI 7 \"immediate_operand\" \"n\"))))]\n-  \"(i960_si_ti (operands[1], 0) && ((REGNO (operands[0]) & 3) == 0)\n-   && (REGNO (operands[1]) != REGNO (operands[0]))\n-   && (REGNO (operands[0]) + 1 == REGNO (operands[2]))\n-   && (REGNO (operands[1]) != REGNO (operands[2]))\n-   && (REGNO (operands[0]) + 2 == REGNO (operands[4]))\n-   && (REGNO (operands[1]) != REGNO (operands[4]))\n-   && (REGNO (operands[0]) + 3 == REGNO (operands[6]))\n-   && (INTVAL (operands[3]) == 4)\n-   && (INTVAL (operands[5]) == 8)\n-   && (INTVAL (operands[7]) == 12))\"\n-  \"ldq\t(%1),%0\")\n-\n-;; Matched 5/28/91\n-(define_peephole\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(mem:SI (plus:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-\t\t\t (match_operand:SI 2 \"immediate_operand\" \"n\"))))\n-   (set (match_operand:SI 3 \"register_operand\" \"=d\")\n-\t(mem:SI (plus:SI (match_dup 1)\n-\t\t\t (match_operand:SI 4 \"immediate_operand\" \"n\"))))\n-   (set (match_operand:SI 5 \"register_operand\" \"=d\")\n-\t(mem:SI (plus:SI (match_dup 1)\n-\t\t\t (match_operand:SI 6 \"immediate_operand\" \"n\"))))]\n-  \"(i960_si_ti (operands[1], operands[2]) && ((REGNO (operands[0]) & 3) == 0)\n-   && (REGNO (operands[1]) != REGNO (operands[0]))\n-   && (REGNO (operands[0]) + 1 == REGNO (operands[3]))\n-   && (REGNO (operands[1]) != REGNO (operands[3]))\n-   && (REGNO (operands[0]) + 2 == REGNO (operands[5]))\n-   && (INTVAL (operands[2]) + 4 == INTVAL (operands[4]))\n-   && (INTVAL (operands[2]) + 8 == INTVAL (operands[6])))\"\n-  \"ldt\t%2(%1),%0\")\n-\n-;; Matched 6/15/91\n-(define_peephole\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(mem:SI (match_operand:SI 1 \"register_operand\" \"d\")))\n-   (set (match_operand:SI 2 \"register_operand\" \"=d\")\n-\t(mem:SI (plus:SI (match_dup 1)\n-\t\t\t (match_operand:SI 3 \"immediate_operand\" \"n\"))))\n-   (set (match_operand:SI 4 \"register_operand\" \"=d\")\n-\t(mem:SI (plus:SI (match_dup 1)\n-\t\t\t (match_operand:SI 5 \"immediate_operand\" \"n\"))))]\n-  \"(i960_si_ti (operands[1], 0) && ((REGNO (operands[0]) & 3) == 0)\n-   && (REGNO (operands[1]) != REGNO (operands[0]))\n-   && (REGNO (operands[0]) + 1 == REGNO (operands[2]))\n-   && (REGNO (operands[1]) != REGNO (operands[2]))\n-   && (REGNO (operands[0]) + 2 == REGNO (operands[4]))\n-   && (INTVAL (operands[3]) == 4)\n-   && (INTVAL (operands[5]) == 8))\"\n-  \"ldt\t(%1),%0\")\n-\n-;; Matched 5/28/91\n-(define_peephole\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(mem:SI (plus:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-\t\t\t (match_operand:SI 2 \"immediate_operand\" \"n\"))))\n-   (set (match_operand:SI 3 \"register_operand\" \"=d\")\n-\t(mem:SI (plus:SI (match_dup 1)\n-\t\t\t (match_operand:SI 4 \"immediate_operand\" \"n\"))))]\n-  \"(i960_si_di (operands[1], operands[2]) && ((REGNO (operands[0]) & 1) == 0)\n-   && (REGNO (operands[1]) != REGNO (operands[0]))\n-   && (REGNO (operands[0]) + 1 == REGNO (operands[3]))\n-   && (INTVAL (operands[2]) + 4 == INTVAL (operands[4])))\"\n-  \"ldl\t%2(%1),%0\")\n-\n-;; Matched 5/28/91\n-(define_peephole\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(mem:SI (match_operand:SI 1 \"register_operand\" \"d\")))\n-   (set (match_operand:SI 2 \"register_operand\" \"=d\")\n-\t(mem:SI (plus:SI (match_dup 1)\n-\t\t\t (match_operand:SI 3 \"immediate_operand\" \"n\"))))]\n-  \"(i960_si_di (operands[1], 0) && ((REGNO (operands[0]) & 1) == 0)\n-   && (REGNO (operands[1]) != REGNO (operands[0]))\n-   && (REGNO (operands[0]) + 1 == REGNO (operands[2]))\n-   && (INTVAL (operands[3]) == 4))\"\n-  \"ldl\t(%1),%0\")\n-\f\n-; Multiple register stores.\n-\n-;; Matched 5/28/91\n-(define_peephole\n-  [(set (mem:SI (plus:SI (match_operand:SI 0 \"register_operand\" \"d\")\n-\t\t\t (match_operand:SI 1 \"immediate_operand\" \"n\")))\n-\t(match_operand:SI 2 \"register_operand\" \"d\"))\n-   (set (mem:SI (plus:SI (match_dup 0)\n-\t\t\t (match_operand:SI 3 \"immediate_operand\" \"n\")))\n-\t(match_operand:SI 4 \"register_operand\" \"d\"))\n-   (set (mem:SI (plus:SI (match_dup 0)\n-\t\t\t (match_operand:SI 5 \"immediate_operand\" \"n\")))\n-\t(match_operand:SI 6 \"register_operand\" \"d\"))\n-   (set (mem:SI (plus:SI (match_dup 0)\n-\t\t\t (match_operand:SI 7 \"immediate_operand\" \"n\")))\n-\t(match_operand:SI 8 \"register_operand\" \"d\"))]\n-  \"(i960_si_ti (operands[0], operands[1]) && ((REGNO (operands[2]) & 3) == 0)\n-   && (REGNO (operands[2]) + 1 == REGNO (operands[4]))\n-   && (REGNO (operands[2]) + 2 == REGNO (operands[6]))\n-   && (REGNO (operands[2]) + 3 == REGNO (operands[8]))\n-   && (INTVAL (operands[1]) + 4 == INTVAL (operands[3]))\n-   && (INTVAL (operands[1]) + 8 == INTVAL (operands[5]))\n-   && (INTVAL (operands[1]) + 12 == INTVAL (operands[7])))\"\n-  \"stq\t%2,%1(%0)\")\n-\n-;; Matched 6/16/91\n-(define_peephole\n-  [(set (mem:DF (plus:SI (match_operand:SI 0 \"register_operand\" \"d\")\n-\t\t\t (match_operand:SI 1 \"immediate_operand\" \"n\")))\n-\t(match_operand:DF 2 \"register_operand\" \"d\"))\n-   (set (mem:DF (plus:SI (match_dup 0)\n-\t\t\t (match_operand:SI 3 \"immediate_operand\" \"n\")))\n-\t(match_operand:DF 4 \"register_operand\" \"d\"))]\n-  \"(i960_si_ti (operands[0], operands[1]) && ((REGNO (operands[2]) & 3) == 0)\n-   && (REGNO (operands[2]) + 2 == REGNO (operands[4]))\n-   && (INTVAL (operands[1]) + 8 == INTVAL (operands[3])))\"\n-  \"stq\t%2,%1(%0)\")\n-\n-;; Matched 4/17/92\n-(define_peephole\n-  [(set (mem:DI (plus:SI (match_operand:SI 0 \"register_operand\" \"d\")\n-\t\t\t (match_operand:SI 1 \"immediate_operand\" \"n\")))\n-\t(match_operand:DI 2 \"register_operand\" \"d\"))\n-   (set (mem:DI (plus:SI (match_dup 0)\n-\t\t\t (match_operand:SI 3 \"immediate_operand\" \"n\")))\n-\t(match_operand:DI 4 \"register_operand\" \"d\"))]\n-  \"(i960_si_ti (operands[0], operands[1]) && ((REGNO (operands[2]) & 3) == 0)\n-   && (REGNO (operands[2]) + 2 == REGNO (operands[4]))\n-   && (INTVAL (operands[1]) + 8 == INTVAL (operands[3])))\"\n-  \"stq\t%2,%1(%0)\")\n-\n-;; Matched 1/23/92\n-(define_peephole\n-  [(set (mem:SI (match_operand:SI 0 \"register_operand\" \"d\"))\n-\t(match_operand:SI 1 \"register_operand\" \"d\"))\n-   (set (mem:SI (plus:SI (match_dup 0)\n-\t\t\t (match_operand:SI 2 \"immediate_operand\" \"n\")))\n-\t(match_operand:SI 3 \"register_operand\" \"d\"))\n-   (set (mem:SI (plus:SI (match_dup 0)\n-\t\t\t (match_operand:SI 4 \"immediate_operand\" \"n\")))\n-\t(match_operand:SI 5 \"register_operand\" \"d\"))\n-   (set (mem:SI (plus:SI (match_dup 0)\n-\t\t\t (match_operand:SI 6 \"immediate_operand\" \"n\")))\n-\t(match_operand:SI 7 \"register_operand\" \"d\"))]\n-  \"(i960_si_ti (operands[0], 0) && ((REGNO (operands[1]) & 3) == 0)\n-   && (REGNO (operands[1]) + 1 == REGNO (operands[3]))\n-   && (REGNO (operands[1]) + 2 == REGNO (operands[5]))\n-   && (REGNO (operands[1]) + 3 == REGNO (operands[7]))\n-   && (INTVAL (operands[2]) == 4)\n-   && (INTVAL (operands[4]) == 8)\n-   && (INTVAL (operands[6]) == 12))\"\n-  \"stq\t%1,(%0)\")\n-\n-;; Matched 5/29/91\n-(define_peephole\n-  [(set (mem:SI (plus:SI (match_operand:SI 0 \"register_operand\" \"d\")\n-\t\t\t (match_operand:SI 1 \"immediate_operand\" \"n\")))\n-\t(match_operand:SI 2 \"register_operand\" \"d\"))\n-   (set (mem:SI (plus:SI (match_dup 0)\n-\t\t\t (match_operand:SI 3 \"immediate_operand\" \"n\")))\n-\t(match_operand:SI 4 \"register_operand\" \"d\"))\n-   (set (mem:SI (plus:SI (match_dup 0)\n-\t\t\t (match_operand:SI 5 \"immediate_operand\" \"n\")))\n-\t(match_operand:SI 6 \"register_operand\" \"d\"))]\n-  \"(i960_si_ti (operands[0], operands[1]) && ((REGNO (operands[2]) & 3) == 0)\n-   && (REGNO (operands[2]) + 1 == REGNO (operands[4]))\n-   && (REGNO (operands[2]) + 2 == REGNO (operands[6]))\n-   && (INTVAL (operands[1]) + 4 == INTVAL (operands[3]))\n-   && (INTVAL (operands[1]) + 8 == INTVAL (operands[5])))\"\n-  \"stt\t%2,%1(%0)\")\n-\n-;; Matched 5/29/91\n-(define_peephole\n-  [(set (mem:SI (match_operand:SI 0 \"register_operand\" \"d\"))\n-\t(match_operand:SI 1 \"register_operand\" \"d\"))\n-   (set (mem:SI (plus:SI (match_dup 0)\n-\t\t\t (match_operand:SI 2 \"immediate_operand\" \"n\")))\n-\t(match_operand:SI 3 \"register_operand\" \"d\"))\n-   (set (mem:SI (plus:SI (match_dup 0)\n-\t\t\t (match_operand:SI 4 \"immediate_operand\" \"n\")))\n-\t(match_operand:SI 5 \"register_operand\" \"d\"))]\n-  \"(i960_si_ti (operands[0], 0) && ((REGNO (operands[1]) & 3) == 0)\n-   && (REGNO (operands[1]) + 1 == REGNO (operands[3]))\n-   && (REGNO (operands[1]) + 2 == REGNO (operands[5]))\n-   && (INTVAL (operands[2]) == 4)\n-   && (INTVAL (operands[4]) == 8))\"\n-  \"stt\t%1,(%0)\")\n-\n-;; Matched 5/28/91\n-(define_peephole\n-  [(set (mem:SI (plus:SI (match_operand:SI 0 \"register_operand\" \"d\")\n-\t\t\t (match_operand:SI 1 \"immediate_operand\" \"n\")))\n-\t(match_operand:SI 2 \"register_operand\" \"d\"))\n-   (set (mem:SI (plus:SI (match_dup 0)\n-\t\t\t (match_operand:SI 3 \"immediate_operand\" \"n\")))\n-\t(match_operand:SI 4 \"register_operand\" \"d\"))]\n-  \"(i960_si_di (operands[0], operands[1]) && ((REGNO (operands[2]) & 1) == 0)\n-   && (REGNO (operands[2]) + 1 == REGNO (operands[4]))\n-   && (INTVAL (operands[1]) + 4 == INTVAL (operands[3])))\"\n-  \"stl\t%2,%1(%0)\")\n-\n-;; Matched 5/28/91\n-(define_peephole\n-  [(set (mem:SI (match_operand:SI 0 \"register_operand\" \"d\"))\n-\t(match_operand:SI 1 \"register_operand\" \"d\"))\n-   (set (mem:SI (plus:SI (match_dup 0)\n-\t\t\t (match_operand:SI 2 \"immediate_operand\" \"n\")))\n-\t(match_operand:SI 3 \"register_operand\" \"d\"))]\n-  \"(i960_si_di (operands[0], 0) && ((REGNO (operands[1]) & 1) == 0)\n-   && (REGNO (operands[1]) + 1 == REGNO (operands[3]))\n-   && (INTVAL (operands[2]) == 4))\"\n-  \"stl\t%1,(%0)\")"}, {"sha": "092b7920abf360579d1e10e4e6d86aaf9355294c", "filename": "gcc/config/i960/rtems.h", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fi960%2Frtems.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fi960%2Frtems.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Frtems.h?ref=c3bf16ff7dec47581f450b1a486cfdf9d566927e", "patch": "@@ -1,29 +0,0 @@\n-/* Definitions for rtems targeting an Intel i960.\n-   Copyright (C) 1996, 1997, 2000, 2002 Free Software Foundation, Inc.\n-   Contributed by Joel Sherrill (joel@OARcorp.com).\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-/* Target OS builtins.  */\n-#define TARGET_OS_CPP_BUILTINS()\t\t\\\n-  do\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\\\n-\tbuiltin_define (\"__rtems__\");\t\t\\\n-\tbuiltin_assert (\"system=rtems\");\t\\\n-    }\t\t\t\t\t\t\\\n-  while (0)"}, {"sha": "9cbaa9f9065a435f7440abc1451e332bb0342838", "filename": "gcc/config/i960/t-960bare", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fi960%2Ft-960bare", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fi960%2Ft-960bare", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Ft-960bare?ref=c3bf16ff7dec47581f450b1a486cfdf9d566927e", "patch": "@@ -1,30 +0,0 @@\n-LIB2FUNCS_EXTRA = xp-bit.c\n-\n-# We want fine grained libraries, so use the new code to build the\n-# floating point emulation libraries.\n-FPBIT = fp-bit.c\n-DPBIT = dp-bit.c\n-\n-dp-bit.c: $(srcdir)/config/fp-bit.c\n-\techo '#define FLOAT_BIT_ORDER_MISMATCH' > dp-bit.c\n-\tcat $(srcdir)/config/fp-bit.c >> dp-bit.c\n-\n-fp-bit.c: $(srcdir)/config/fp-bit.c\n-\techo '#define FLOAT' > fp-bit.c\n-\techo '#define FLOAT_BIT_ORDER_MISMATCH' >> fp-bit.c\n-\tcat $(srcdir)/config/fp-bit.c >> fp-bit.c\n-\n-xp-bit.c: $(srcdir)/config/fp-bit.c\n-\techo '#define EXTENDED_FLOAT_STUBS' > xp-bit.c\n-\tcat $(srcdir)/config/fp-bit.c >> xp-bit.c\n-\n-i960-c.o: $(srcdir)/config/i960/i960-c.c $(CONFIG_H) $(SYSTEM_H) \\\n-  coretypes.h $(TM_H) $(CPPLIB_H) $(TREE_H) c-pragma.h toplev.h $(GGC_H) $(TM_P_H)\n-\t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $(srcdir)/config/i960/i960-c.c\n-\n-MULTILIB_OPTIONS=mnumerics/msoft-float mlong-double-64\n-MULTILIB_DIRNAMES=float soft-float ld64\n-MULTILIB_MATCHES=mnumerics=msb mnumerics=msc mnumerics=mkb mnumerics=mkc mnumerics=mmc mnumerics=mcb mnumerics=mcc mnumerics=mjf msoft-float=msa msoft-float=mka msoft-float=mca msoft-float=mcf\n-\n-LIBGCC = stmp-multilib\n-INSTALL_LIBGCC = install-multilib"}, {"sha": "5701fd94ded63ca1b8047c0a675161b4fce34c20", "filename": "gcc/config/linux-aout.h", "status": "removed", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Flinux-aout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Flinux-aout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Flinux-aout.h?ref=c3bf16ff7dec47581f450b1a486cfdf9d566927e", "patch": "@@ -1,37 +0,0 @@\n-/* Definitions for Linux-based GNU systems with a.out binaries.\n-   Copyright (C) 1995, 1997, 1999, 2000 Free Software Foundation, Inc.\n-   Contributed by H.J. Lu (hjl@nynexst.com)\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-/* Don't assume anything about the header files.  */\n-#define NO_IMPLICIT_EXTERN_C\n-\n-#undef STARTFILE_SPEC\n-#define STARTFILE_SPEC  \"%{pg:gcrt0.o%s} %{!pg:%{p:gcrt0.o%s} %{!p:crt0.o%s}} %{static:-static}\"\n-\n-#undef ASM_APP_ON\n-#define ASM_APP_ON \"#APP\\n\"\n-\n-#undef ASM_APP_OFF\n-#define ASM_APP_OFF \"#NO_APP\\n\"\n-\n-#define SET_ASM_OP\t\"\\t.set\\t\"\n-\n-/* We need that too.  */\n-#define HANDLE_SYSV_PRAGMA 1"}, {"sha": "1abbeaeddc9210d15113b67bf16e5920a4e9ce05", "filename": "gcc/config/m68k/hp310.h", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fm68k%2Fhp310.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fm68k%2Fhp310.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fhp310.h?ref=c3bf16ff7dec47581f450b1a486cfdf9d566927e", "patch": "@@ -1,29 +0,0 @@\n-/* Definitions of target machine for GNU compiler.  HP-UX 68010 version.  */\n-\n-/* Don't try using XFmode.  */\n-#undef LONG_DOUBLE_TYPE_SIZE\n-#define LONG_DOUBLE_TYPE_SIZE 64\n-\n-#undef CPP_SPEC\n-#undef ASM_SPEC\n-\n-/* HP does not support a 68020 without a 68881 or a 68010 with a 68881.\n-   However, -m68020 does not imply -m68881.  You must specify both\n-   if you want both.  */\n-\n-#ifdef HPUX_ASM\n-\n-#define CPP_SPEC \"-D__HPUX_ASM__ %{m68881: -D__HAVE_68881__}\\\n-%{m68020: -Dmc68020}%{mc68020: -Dmc68020} -D_INCLUDE__STDC__\"\n-\n-#define ASM_SPEC \"%{!m68020:%{!mc68020:+X}}\"\n-\n-#else\t/* not HPUX_ASM */\n-\n-#define CPP_SPEC \"%{m68881: -D__HAVE_68881__}\\\n-%{m68020: -Dmc68020}%{mc68020: -Dmc68020} -D_INCLUDE__STDC__\"\n-\n-#define ASM_SPEC \\\n- \"%{m68000:-mc68000}%{mc68000:-mc68000}%{!mc68000:%{!m68000:-mc68020}}\"\n-\n-#endif\t/* not HPUX_ASM */"}, {"sha": "69bb726934d238ed7df83b565aa7cbe3e910e41f", "filename": "gcc/config/m68k/hp320.h", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fm68k%2Fhp320.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fm68k%2Fhp320.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fhp320.h?ref=c3bf16ff7dec47581f450b1a486cfdf9d566927e"}, {"sha": "b35c48be2a731ca9a9133e77c08807b13d883d91", "filename": "gcc/config/m68k/hp320base.h", "status": "removed", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fm68k%2Fhp320base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fm68k%2Fhp320base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fhp320base.h?ref=c3bf16ff7dec47581f450b1a486cfdf9d566927e"}, {"sha": "f7886b50bcc630cc430dfff6506b53ca6cf5dd81", "filename": "gcc/config/m68k/m68kv4.h", "status": "removed", "additions": 0, "deletions": 298, "changes": 298, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fm68k%2Fm68kv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fm68k%2Fm68kv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68kv4.h?ref=c3bf16ff7dec47581f450b1a486cfdf9d566927e"}, {"sha": "2b4fd855a9f93074faa074e992bca6479fc79af1", "filename": "gcc/config/m68k/netbsd.h", "status": "removed", "additions": 0, "deletions": 62, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fm68k%2Fnetbsd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fm68k%2Fnetbsd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fnetbsd.h?ref=c3bf16ff7dec47581f450b1a486cfdf9d566927e"}, {"sha": "e1967df8990b9fa1cf4f1936e0c4ed5deb8d9dc0", "filename": "gcc/config/m68k/sgs.h", "status": "removed", "additions": 0, "deletions": 367, "changes": 367, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fm68k%2Fsgs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fm68k%2Fsgs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fsgs.h?ref=c3bf16ff7dec47581f450b1a486cfdf9d566927e"}, {"sha": "d3bbb66f229b56b2d763e27e8afd8e1986625160", "filename": "gcc/config/m68k/t-hp320", "status": "removed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fm68k%2Ft-hp320", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fm68k%2Ft-hp320", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Ft-hp320?ref=c3bf16ff7dec47581f450b1a486cfdf9d566927e"}, {"sha": "241e92dcf7c22839f7cf8152565bb64793db8489", "filename": "gcc/config/netware.h", "status": "removed", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fnetware.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Fnetware.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnetware.h?ref=c3bf16ff7dec47581f450b1a486cfdf9d566927e"}, {"sha": "52effd5ca2f3701328f1135c6115c4de4c996e60", "filename": "gcc/config/t-linux-gnulibc1", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Ft-linux-gnulibc1", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3bf16ff7dec47581f450b1a486cfdf9d566927e/gcc%2Fconfig%2Ft-linux-gnulibc1", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ft-linux-gnulibc1?ref=c3bf16ff7dec47581f450b1a486cfdf9d566927e"}, {"sha": "7c6b4fa8e2776ad99c960793954abb190ed387d5", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4a4b1d36476aaa60ebd05db0dfd16145dc72338/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4a4b1d36476aaa60ebd05db0dfd16145dc72338/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=a4a4b1d36476aaa60ebd05db0dfd16145dc72338"}, {"sha": "31f51040f5921f893ccac40f3e88d0f93fe8194e", "filename": "gcc/doc/install.texi", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4a4b1d36476aaa60ebd05db0dfd16145dc72338/gcc%2Fdoc%2Finstall.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4a4b1d36476aaa60ebd05db0dfd16145dc72338/gcc%2Fdoc%2Finstall.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finstall.texi?ref=a4a4b1d36476aaa60ebd05db0dfd16145dc72338"}, {"sha": "adf156f89e32ec9427f7e3d4ab7c5cd65a17930a", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 0, "deletions": 172, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4a4b1d36476aaa60ebd05db0dfd16145dc72338/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4a4b1d36476aaa60ebd05db0dfd16145dc72338/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=a4a4b1d36476aaa60ebd05db0dfd16145dc72338"}, {"sha": "e81e350578bdfc7899171b84ea6751a83bbc0d20", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4a4b1d36476aaa60ebd05db0dfd16145dc72338/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4a4b1d36476aaa60ebd05db0dfd16145dc72338/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=a4a4b1d36476aaa60ebd05db0dfd16145dc72338"}, {"sha": "62ae2ac8dffc0fb1e52ab448a36f8e2e6252ceb2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4a4b1d36476aaa60ebd05db0dfd16145dc72338/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4a4b1d36476aaa60ebd05db0dfd16145dc72338/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a4a4b1d36476aaa60ebd05db0dfd16145dc72338"}, {"sha": "6e59cd6cf6ffe60220477a4e43666f355f55b75f", "filename": "gcc/testsuite/gcc.dg/20020312-2.c", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4a4b1d36476aaa60ebd05db0dfd16145dc72338/gcc%2Ftestsuite%2Fgcc.dg%2F20020312-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4a4b1d36476aaa60ebd05db0dfd16145dc72338/gcc%2Ftestsuite%2Fgcc.dg%2F20020312-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2F20020312-2.c?ref=a4a4b1d36476aaa60ebd05db0dfd16145dc72338"}, {"sha": "d2d28415899bb031fc62280dd196465649081f7d", "filename": "gcc/testsuite/gcc.dg/builtin-inf-1.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4a4b1d36476aaa60ebd05db0dfd16145dc72338/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-inf-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4a4b1d36476aaa60ebd05db0dfd16145dc72338/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-inf-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-inf-1.c?ref=a4a4b1d36476aaa60ebd05db0dfd16145dc72338"}, {"sha": "82ae7aa6efb3ffdabfba74c8d036caac46d9a196", "filename": "gcc/testsuite/gcc.dg/cpp/assert4.c", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4a4b1d36476aaa60ebd05db0dfd16145dc72338/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fassert4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4a4b1d36476aaa60ebd05db0dfd16145dc72338/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fassert4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fassert4.c?ref=a4a4b1d36476aaa60ebd05db0dfd16145dc72338"}, {"sha": "f1e9fa1ca7f0bd805f2a44f59616299d8c83432a", "filename": "gcc/testsuite/gcc.dg/sibcall-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4a4b1d36476aaa60ebd05db0dfd16145dc72338/gcc%2Ftestsuite%2Fgcc.dg%2Fsibcall-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4a4b1d36476aaa60ebd05db0dfd16145dc72338/gcc%2Ftestsuite%2Fgcc.dg%2Fsibcall-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsibcall-3.c?ref=a4a4b1d36476aaa60ebd05db0dfd16145dc72338"}, {"sha": "1624b897874fa43a118f5446a20cc2c30c0bd962", "filename": "gcc/testsuite/gcc.dg/sibcall-4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4a4b1d36476aaa60ebd05db0dfd16145dc72338/gcc%2Ftestsuite%2Fgcc.dg%2Fsibcall-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4a4b1d36476aaa60ebd05db0dfd16145dc72338/gcc%2Ftestsuite%2Fgcc.dg%2Fsibcall-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsibcall-4.c?ref=a4a4b1d36476aaa60ebd05db0dfd16145dc72338"}]}