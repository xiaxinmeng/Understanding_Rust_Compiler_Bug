{"sha": "617a1b714435a270ccf699c4c6e17767088e2242", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjE3YTFiNzE0NDM1YTI3MGNjZjY5OWM0YzZlMTc3NjcwODhlMjI0Mg==", "commit": {"author": {"name": "Paul Brook", "email": "paul@codesourcery.com", "date": "2005-06-28T19:52:27Z"}, "committer": {"name": "Paul Brook", "email": "pbrook@gcc.gnu.org", "date": "2005-06-28T19:52:27Z"}, "message": "Makefile.in: Set and use UNWIND_H.\n\n2005-06-28  Paul Brook  <paul@codesourcery.com>\n\ngcc/\n\t* Makefile.in: Set and use UNWIND_H.  Install as unwind.h.\n\t* c-decl.c (finish_decl): Call default_init_unwind_resume_libfunc.\n\t* except.c (add_ehspec_entry): Generate arm eabi filter lists.\n\t(assign_filter_values): Ditto.\n\t(output_ttype): New function.\n\t(output_function_exception_table): Use output_ttype.  Generate arm\n\teabi filter lists.\n\t(default_init_unwind_resume_libfunc): New function.\n\t* except.h (default_init_unwind_resume_libfunc): Add prototype.\n\t* optabs.c (init_optabs): Don't set unwind_resume_libfunc.\n\t* opts.c (decode_options): Use targetm.unwind_tables_default.\n\t* target-def.h (TARGET_ASM_TTYPE): Provide and use definition.\n\t(TARGET_ARM_EABI_UNWINDER, TARGET_UNWIND_TABLES_DEFAULT): Ditto.\n\t* target.h (struct gcc_target): Add asm.ttype, unwind_tables_default\n\tand arm_eabi_unwinder.\n\t* unwind-c.c: Support Arm EABI unwinder.\n\t* unwind.h: Rename ...\n\t* unwind-generic.h: ... To this.\n\t* doc/tm.texi (TARGET_ASM_TTYPE, TARGET_ARM_EABI_UNWINDER): Document.\n\t(TARGET_UNWID_TABLES_DEFAULT): Document.\n\n\t* config/arm/arm-protos.h (arm_output_fn_unwind): Add prototype.\n\t* config/arm/arm.c (arm_unwind_emit, arm_output_ttype): New functions.\n\t(TARGET_UNWIND_EMIT, TARGET_ASM_TTYPE, TARGET_ARM_EABI_UNWINDER):\n\tDefine.\n\t(thumb_pushpop, thumb_output_function_prologue): Output unwinding\n\tdirectives.\n\t(arm_unwind_emit_stm, arm_unwind_emit_set): New functions.\n\t* config/arm/arm.h (MUST_USE_SJLJ_EXCEPTIONS): Only define when\n\t!TARGET_UNWIND_INFO.\n\t(ARM_OUTPUT_FN_UNWIND, ARM_EABI_UNWIND_TABLES): Define.\n\t* config/arm/bpabi.h (TARGET_UNWIND_INFO): Define.\n\t* config/arm/elf.h (ASM_DECLARE_FUNCTION_NAME,\n\tASM_DECLARE_FUNCTION_SIZE): Use ARM_OUTPUT_FN_UNWIND.\n\t* config/arm/lib1funcs.asm: Include libunwind.S.\n\t* config/arm/libgcc-bpabi.ver: Add unwinding routines.\n\t* config/arm/libunwind.S: New file.\n\t* config/arm/pr-support.c: New file.\n\t* config/arm/t-bpabi (LIB1ASMFUNCS): Add _unwind.\n\t(UNWIND_H, LIB2ADDEH, LIB2ADDEHDEP): Set.\n\t* config/arm/t-symbian (UNWIND_H, LIB2ADDEH, LIB2ADDEHDEP): Set.\n\t* config/arm/unwind-arm.c: New file.\n\t* config/arm/unwind-arm.h: New file.\n\t* config/i386/t-netware (USER_H): Remove unwind.h.\n\t* config/ia64/ia64.h (TARGET_UNWIND_TABLES_DEFAULT): Define.\n\ngcc/cp/\n\t* Make-lang.in (cp/except.o): Depend on $(TARGET_H)\n\t* except.c: Include target.h.\n\t(init_exception_processing): Initialize unwind_resume_libfunc.\n\t* doc/tm.texi: Document TARGET_ASM_TTYPE\ngcc/ada/\n\t* misc.c (gnat_init_gcc_eh): Call default_init_unwind_resume_libfunc.\ngcc/java/\n\t* decl.c (java_init_decl_processing): Call\n\tdefault_init_unwind_resume_libfunc.\ngcc/objc/\n\t* objc-act.c (objc_init_exceptions): Call\n\tdefault_init_unwind_resume_libfunc.\nlibstdc++/\n\t* acinclude.m4 (GLIBCXX_ENABLE_SJLJ_EXCEPTIONS): Check for\n\t__cxa_end_cleanup.\n\t* libsupc++/Makefile.am (sources): Add eh_call.c and eh_arm.c.\n\t* libsupc++/eh_arm.cc: New file.\n\t* libsupc++/eh_call.cc: New file.\n\t* libsupc++/eh_catch.cc (__cxa_get_exception_ptr): Use\n\t__gxx_caught_object.\n\t(__cxa_begin_catch): Ditto. Use __is_gxx_exception_class. Call\n\t_Unwind_Complete when using the ARM EABI.\n\t(__cxa_end_catch): Use __is_gxx_exception_class.\n\t* libsupc++/eh_personality.cc: Define NO_SIZE_OF_ENCODED_VALUE when\n\tusing the ARM EABI.\n\t(save_caught_exception, restore_caught_exception): New functions.\n\t(_throw_typet): New typedef.\n\t(get_ttype_entry, get_adjusted_ptr, check_exception_spec): Add ARM\n\tEABI implementations.\n\t(PERSONALITY_FUNCTION): Use new functions.  Addd support for ARM EABI\n\tunwinding libary.\n\t(__cxa_unexpected): Disable when using the ARM EABI.\n\t* libsupc++/eh_throw.cc (__cxa_throw): Use __GXX_INIT_EXCEPTION_CLASS.\n\t(__cxa_rethrow): Use __is_gxx_exception_class.  Call\n\t_Unwind_RaiseException when using the ARM EABI.\n\t* libsupc++/unwind-cxx.h (struct __cxa_exception): Add fields for ARM\n\tEABI semantics.\n\t(struct __cxa_eh_globals): Ditto.\n\t(__cxa_call_terminate): Add prototype.\n\t(__cxa_type_match, __cxa_begin_cleanup, __cxa_end_cleanup): Add\n\tprototypes.\n\t(__get_exception_header_from_obj, __get_exception_header_from_ue):\n\tMove earlier in file.\n\t(__is_gxx_exception_class, __GXX_INIT_EXCEPTION_CLASS,\n\t__gxx_caught_object): New functions.\n\t* aclocal.m4: Regenerate.\n\t* configure: Regenerate.\n\t* Makefile.in: Regenerate.\n\t* include/Makefile.in: Regenerate.\n\t* libmath/Makefile.in: Regenerate.\n\t* libsupc++/Makefile.in: Regenerate.\n\t* po/Makefile.in: Regenerate.\n\t* src/Makefie.in: Regenerate.\n\t* testsuite/makefile.in: Regenerate.\n\nFrom-SVN: r101385", "tree": {"sha": "c9a2afea8c3e3d2ed63f6bfa76d8c96c5534d972", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c9a2afea8c3e3d2ed63f6bfa76d8c96c5534d972"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/617a1b714435a270ccf699c4c6e17767088e2242", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/617a1b714435a270ccf699c4c6e17767088e2242", "html_url": "https://github.com/Rust-GCC/gccrs/commit/617a1b714435a270ccf699c4c6e17767088e2242", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/617a1b714435a270ccf699c4c6e17767088e2242/comments", "author": null, "committer": null, "parents": [{"sha": "3176a0c28f6c38963c5beecdbbd44a91b62fc8eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3176a0c28f6c38963c5beecdbbd44a91b62fc8eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3176a0c28f6c38963c5beecdbbd44a91b62fc8eb"}], "stats": {"total": 1527, "additions": 1159, "deletions": 368}, "files": [{"sha": "81a31064f8445e87c87ade336ddcc482984be8c9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617a1b714435a270ccf699c4c6e17767088e2242/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617a1b714435a270ccf699c4c6e17767088e2242/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=617a1b714435a270ccf699c4c6e17767088e2242", "patch": "@@ -1,3 +1,51 @@\n+2005-06-28  Paul Brook  <paul@codesourcery.com>\n+\n+\t* Makefile.in: Set and use UNWIND_H.  Install as unwind.h.\n+\t* c-decl.c (finish_decl): Call default_init_unwind_resume_libfunc.\n+\t* except.c (add_ehspec_entry): Generate arm eabi filter lists.\n+\t(assign_filter_values): Ditto.\n+\t(output_ttype): New function.\n+\t(output_function_exception_table): Use output_ttype.  Generate arm\n+\teabi filter lists.\n+\t(default_init_unwind_resume_libfunc): New function.\n+\t* except.h (default_init_unwind_resume_libfunc): Add prototype.\n+\t* optabs.c (init_optabs): Don't set unwind_resume_libfunc.\n+\t* opts.c (decode_options): Use targetm.unwind_tables_default.\n+\t* target-def.h (TARGET_ASM_TTYPE): Provide and use definition.\n+\t(TARGET_ARM_EABI_UNWINDER, TARGET_UNWIND_TABLES_DEFAULT): Ditto.\n+\t* target.h (struct gcc_target): Add asm.ttype, unwind_tables_default\n+\tand arm_eabi_unwinder.\n+\t* unwind-c.c: Support Arm EABI unwinder.\n+\t* unwind.h: Rename ...\n+\t* unwind-generic.h: ... To this.\n+\t* doc/tm.texi (TARGET_ASM_TTYPE, TARGET_ARM_EABI_UNWINDER): Document.\n+\t(TARGET_UNWID_TABLES_DEFAULT): Document.\n+\n+\t* config/arm/arm-protos.h (arm_output_fn_unwind): Add prototype.\n+\t* config/arm/arm.c (arm_unwind_emit, arm_output_ttype): New functions.\n+\t(TARGET_UNWIND_EMIT, TARGET_ASM_TTYPE, TARGET_ARM_EABI_UNWINDER):\n+\tDefine.\n+\t(thumb_pushpop, thumb_output_function_prologue): Output unwinding\n+\tdirectives.\n+\t(arm_unwind_emit_stm, arm_unwind_emit_set): New functions.\n+\t* config/arm/arm.h (MUST_USE_SJLJ_EXCEPTIONS): Only define when\n+\t!TARGET_UNWIND_INFO.\n+\t(ARM_OUTPUT_FN_UNWIND, ARM_EABI_UNWIND_TABLES): Define.\n+\t* config/arm/bpabi.h (TARGET_UNWIND_INFO): Define.\n+\t* config/arm/elf.h (ASM_DECLARE_FUNCTION_NAME,\n+\tASM_DECLARE_FUNCTION_SIZE): Use ARM_OUTPUT_FN_UNWIND.\n+\t* config/arm/lib1funcs.asm: Include libunwind.S.\n+\t* config/arm/libgcc-bpabi.ver: Add unwinding routines.\n+\t* config/arm/libunwind.S: New file.\n+\t* config/arm/pr-support.c: New file.\n+\t* config/arm/t-bpabi (LIB1ASMFUNCS): Add _unwind.\n+\t(UNWIND_H, LIB2ADDEH, LIB2ADDEHDEP): Set.\n+\t* config/arm/t-symbian (UNWIND_H, LIB2ADDEH, LIB2ADDEHDEP): Set.\n+\t* config/arm/unwind-arm.c: New file.\n+\t* config/arm/unwind-arm.h: New file.\n+\t* config/i386/t-netware (USER_H): Remove unwind.h.\n+\t* config/ia64/ia64.h (TARGET_UNWIND_TABLES_DEFAULT): Define.\n+\n 2005-06-28  DJ Delorie  <dj@redhat.com>\n \n \t* c-decl.c (pop_scope): Move warning control into warning call."}, {"sha": "3ff5c94820a43c32f92d44c92d7aa6671f50706b", "filename": "gcc/Makefile.in", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617a1b714435a270ccf699c4c6e17767088e2242/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617a1b714435a270ccf699c4c6e17767088e2242/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=617a1b714435a270ccf699c4c6e17767088e2242", "patch": "@@ -313,9 +313,10 @@ USER_H = $(srcdir)/ginclude/float.h \\\n \t $(srcdir)/ginclude/stdbool.h \\\n \t $(srcdir)/ginclude/stddef.h \\\n \t $(srcdir)/ginclude/varargs.h \\\n-\t $(srcdir)/unwind.h \\\n \t $(EXTRA_HEADERS)\n \n+UNWIND_H = $(srcdir)/unwind-generic.h\n+\n # The GCC to use for compiling libgcc.a and crt*.o.\n # Usually the one we just built.\n # Don't use this as a dependency--use $(GCC_PASSES) or $(GCC_PARTS).\n@@ -534,7 +535,7 @@ LIB2ADDEH = $(srcdir)/unwind-dw2.c $(srcdir)/unwind-dw2-fde.c \\\n    $(srcdir)/unwind-sjlj.c $(srcdir)/gthr-gnat.c $(srcdir)/unwind-c.c\n LIB2ADDEHSTATIC = $(LIB2ADDEH)\n LIB2ADDEHSHARED = $(LIB2ADDEH)\n-LIB2ADDEHDEP = unwind.h unwind-pe.h unwind.inc unwind-dw2-fde.h unwind-dw2.h\n+LIB2ADDEHDEP = $(UNWIND_H) unwind-pe.h unwind.inc unwind-dw2-fde.h unwind-dw2.h\n \n # Don't build libunwind by default.\n LIBUNWIND =\n@@ -3034,7 +3035,7 @@ gcov-dump$(exeext): $(GCOV_DUMP_OBJS) $(LIBDEPS)\n # be rebuilt.\n \n # Build the include directory\n-stmp-int-hdrs: $(STMP_FIXINC) $(USER_H) xlimits.h\n+stmp-int-hdrs: $(STMP_FIXINC) $(USER_H) xlimits.h $(UNWIND_H)\n # Copy in the headers provided with gcc.\n # The sed command gets just the last file name component;\n # this is necessary because VPATH could add a dirname.\n@@ -3052,6 +3053,7 @@ stmp-int-hdrs: $(STMP_FIXINC) $(USER_H) xlimits.h\n \tdone\n \trm -f include/limits.h\n \tcp xlimits.h include/limits.h\n+\tcp $(UNWIND_H) include/unwind.h\n \tchmod a+r include/limits.h\n # Install the README\n \trm -f include/README\n@@ -3684,6 +3686,7 @@ install-mkheaders: stmp-int-hdrs $(STMP_FIXPROTO) install-itoolsdirs \\\n \t    $(DESTDIR)$(itoolsdatadir)/include/$$realfile ; \\\n \tdone\n \t$(INSTALL_DATA) xlimits.h $(DESTDIR)$(itoolsdatadir)/include/limits.h\n+\t$(INSTALL_DATA) $(UNWIND_H) $(DESTDIR)$(itoolsdatadir)/include/unwind.h\n \t$(INSTALL_DATA) $(srcdir)/gsyslimits.h \\\n \t  $(DESTDIR)$(itoolsdatadir)/gsyslimits.h\n \t$(INSTALL_DATA) macro_list $(DESTDIR)$(itoolsdatadir)/macro_list"}, {"sha": "18b366bce898c84b90d1f65dfbff71ba76a8a15b", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617a1b714435a270ccf699c4c6e17767088e2242/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617a1b714435a270ccf699c4c6e17767088e2242/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=617a1b714435a270ccf699c4c6e17767088e2242", "patch": "@@ -1,3 +1,7 @@\n+2005-06-28  Paul Brook  <paul@codesourcery.com>\n+\n+\t* misc.c (gnat_init_gcc_eh): Call default_init_unwind_resume_libfunc.\n+\n 2005-06-14  Olivier Hainque  <hainque@adacore.com>\n \t    Eric Botcazou  <ebotcazou@adacore.com>\n "}, {"sha": "544419dedc59763aaef0b4eebb667d93dfa0f1c6", "filename": "gcc/ada/misc.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617a1b714435a270ccf699c4c6e17767088e2242/gcc%2Fada%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617a1b714435a270ccf699c4c6e17767088e2242/gcc%2Fada%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmisc.c?ref=617a1b714435a270ccf699c4c6e17767088e2242", "patch": "@@ -462,6 +462,7 @@ gnat_init_gcc_eh (void)\n   using_eh_for_cleanups ();\n \n   eh_personality_libfunc = init_one_libfunc (\"__gnat_eh_personality\");\n+  default_init_unwind_resume_libfunc ();\n   lang_eh_type_covers = gnat_eh_type_covers;\n   lang_eh_runtime_type = gnat_eh_runtime_type;\n "}, {"sha": "eececb18d39b5b7c19ef8735756df051ee1a7372", "filename": "gcc/c-decl.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617a1b714435a270ccf699c4c6e17767088e2242/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617a1b714435a270ccf699c4c6e17767088e2242/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=617a1b714435a270ccf699c4c6e17767088e2242", "patch": "@@ -3537,6 +3537,7 @@ finish_decl (tree decl, tree init, tree asmspec_tree)\n \t\t= init_one_libfunc (USING_SJLJ_EXCEPTIONS\n \t\t\t\t    ? \"__gcc_personality_sj0\"\n \t\t\t\t    : \"__gcc_personality_v0\");\n+\t      default_init_unwind_resume_libfunc ();\n \t      using_eh_for_cleanups ();\n \t    }\n "}, {"sha": "b15fe10ce438a4e571b4fcb78b5e95b186da5f05", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617a1b714435a270ccf699c4c6e17767088e2242/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617a1b714435a270ccf699c4c6e17767088e2242/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=617a1b714435a270ccf699c4c6e17767088e2242", "patch": "@@ -39,6 +39,8 @@ extern HOST_WIDE_INT arm_compute_initial_elimination_offset (unsigned int,\n extern HOST_WIDE_INT thumb_compute_initial_elimination_offset (unsigned int,\n \t\t\t\t\t\t\t       unsigned int);\n extern unsigned int arm_dbx_register_number (unsigned int);\n+extern void arm_output_fn_unwind (FILE *, bool);\n+  \n \n #ifdef TREE_CODE\n extern int arm_return_in_memory (tree);"}, {"sha": "4e17d3a7fe316bed35f84fc81d3401c6488d9d81", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 297, "deletions": 0, "changes": 297, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617a1b714435a270ccf699c4c6e17767088e2242/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617a1b714435a270ccf699c4c6e17767088e2242/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=617a1b714435a270ccf699c4c6e17767088e2242", "patch": "@@ -171,6 +171,10 @@ static bool arm_default_short_enums (void);\n static bool arm_align_anon_bitfield (void);\n static bool arm_return_in_msb (tree);\n static bool arm_must_pass_in_stack (enum machine_mode, tree);\n+#ifdef TARGET_UNWIND_INFO\n+static void arm_unwind_emit (FILE *, rtx);\n+static bool arm_output_ttype (rtx);\n+#endif\n \n static tree arm_cxx_guard_type (void);\n static bool arm_cxx_guard_mask_bit (void);\n@@ -337,6 +341,18 @@ static unsigned HOST_WIDE_INT arm_shift_truncation_mask (enum machine_mode);\n #undef TARGET_MUST_PASS_IN_STACK\n #define TARGET_MUST_PASS_IN_STACK arm_must_pass_in_stack\n \n+#ifdef TARGET_UNWIND_INFO\n+#undef TARGET_UNWIND_EMIT\n+#define TARGET_UNWIND_EMIT arm_unwind_emit\n+\n+/* EABI unwinding tables use a different format for the typeinfo tables.  */\n+#undef TARGET_ASM_TTYPE\n+#define TARGET_ASM_TTYPE arm_output_ttype\n+\n+#undef TARGET_ARM_EABI_UNWINDER\n+#define TARGET_ARM_EABI_UNWINDER true\n+#endif /* TARGET_UNWIND_INFO */\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Obstack for minipool constant handling.  */\n@@ -12417,6 +12433,21 @@ thumb_pushpop (FILE *f, unsigned long mask, int push, int *cfa_offset,\n       return;\n     }\n \n+  if (ARM_EABI_UNWIND_TABLES && push)\n+    {\n+      fprintf (f, \"\\t.save\\t{\");\n+      for (regno = 0; regno < 15; regno++)\n+\t{\n+\t  if (real_regs & (1 << regno))\n+\t    {\n+\t      if (real_regs & ((1 << regno) -1))\n+\t\tfprintf (f, \", \");\n+\t      asm_fprintf (f, \"%r\", regno);\n+\t    }\n+\t}\n+      fprintf (f, \"}\\n\");\n+    }\n+\n   fprintf (f, \"\\t%s\\t{\", push ? \"push\" : \"pop\");\n \n   /* Look at the low registers first.  */\n@@ -13370,6 +13401,11 @@ thumb_output_function_prologue (FILE *f, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n \n   if (current_function_pretend_args_size)\n     {\n+      /* Output unwind directive for the stack adjustment.  */\n+      if (ARM_EABI_UNWIND_TABLES)\n+\tfprintf (f, \"\\t.pad #%d\\n\",\n+\t\t current_function_pretend_args_size);\n+\n       if (cfun->machine->uses_anonymous_args)\n \t{\n \t  int num_pushes;\n@@ -13435,6 +13471,9 @@ thumb_output_function_prologue (FILE *f, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n \n       work_register = thumb_find_work_register (live_regs_mask);\n \n+      if (ARM_EABI_UNWIND_TABLES)\n+\tasm_fprintf (f, \"\\t.pad #16\\n\");\n+\n       asm_fprintf\n \t(f, \"\\tsub\\t%r, %r, #16\\t%@ Create stack backtrace structure\\n\",\n \t SP_REGNUM, SP_REGNUM);\n@@ -14662,3 +14701,261 @@ arm_dbx_register_number (unsigned int regno)\n   gcc_unreachable ();\n }\n \n+\n+#ifdef TARGET_UNWIND_INFO\n+/* Emit unwind directives for a store-multiple instruction.  This should\n+   only ever be generated by the function prologue code, so we expect it\n+   to have a particular form.  */\n+\n+static void\n+arm_unwind_emit_stm (FILE * asm_out_file, rtx p)\n+{\n+  int i;\n+  HOST_WIDE_INT offset;\n+  HOST_WIDE_INT nregs;\n+  int reg_size;\n+  unsigned reg;\n+  unsigned lastreg;\n+  rtx e;\n+\n+  /* First insn will adjust the stack pointer.  */\n+  e = XVECEXP (p, 0, 0);\n+  if (GET_CODE (e) != SET\n+      || GET_CODE (XEXP (e, 0)) != REG\n+      || REGNO (XEXP (e, 0)) != SP_REGNUM\n+      || GET_CODE (XEXP (e, 1)) != PLUS)\n+    abort ();\n+\n+  offset = -INTVAL (XEXP (XEXP (e, 1), 1));\n+  nregs = XVECLEN (p, 0) - 1;\n+\n+  reg = REGNO (XEXP (XVECEXP (p, 0, 1), 1));\n+  if (reg < 16)\n+    {\n+      /* The function prologue may also push pc, but not annotate it as it is\n+\t never restored.  We turn this into an stack pointer adjustment.  */\n+      if (nregs * 4 == offset - 4)\n+\t{\n+\t  fprintf (asm_out_file, \"\\t.pad #4\\n\");\n+\t  offset -= 4;\n+\t}\n+      reg_size = 4;\n+    }\n+  else if (IS_VFP_REGNUM (reg))\n+    {\n+      /* FPA register saves use an additional word.  */\n+      offset -= 4;\n+      reg_size = 8;\n+    }\n+  else if (reg >= FIRST_FPA_REGNUM && reg <= LAST_FPA_REGNUM)\n+    {\n+      /* FPA registers are done differently.  */\n+      asm_fprintf (asm_out_file, \"\\t.save %r, %d\\n\", reg, nregs);\n+      return;\n+    }\n+  else\n+    /* Unknown register type.  */\n+    abort ();\n+\n+  /* If the stack increment doesn't match the size of the saved registers,\n+     something has gone horribly wrong.  */\n+  if (offset != nregs * reg_size)\n+    abort ();\n+\n+  fprintf (asm_out_file, \"\\t.save {\");\n+\n+  offset = 0;\n+  lastreg = 0;\n+  /* The remaining insns will describe the stores.  */\n+  for (i = 1; i <= nregs; i++)\n+    {\n+      /* Expect (set (mem <addr>) (reg)).\n+         Where <addr> is (reg:SP) or (plus (reg:SP) (const_int)).  */\n+      e = XVECEXP (p, 0, i);\n+      if (GET_CODE (e) != SET\n+\t  || GET_CODE (XEXP (e, 0)) != MEM\n+\t  || GET_CODE (XEXP (e, 1)) != REG)\n+\tabort ();\n+      \n+      reg = REGNO (XEXP (e, 1));\n+      if (reg < lastreg)\n+\tabort ();\n+\t  \n+      if (i != 1)\n+\tfprintf (asm_out_file, \", \");\n+      /* We can't use %r for vfp because we need to use the\n+\t double precision register names.  */\n+      if (IS_VFP_REGNUM (reg))\n+\tasm_fprintf (asm_out_file, \"d%d\", (reg - FIRST_VFP_REGNUM) / 2);\n+      else\n+\tasm_fprintf (asm_out_file, \"%r\", reg);\n+\n+#ifdef ENABLE_CHECKING\n+      /* Check that the addresses are consecutive.  */\n+      e = XEXP (XEXP (e, 0), 0);\n+      if (GET_CODE (e) == PLUS)\n+\t{\n+\t  offset += reg_size;\n+\t  if (GET_CODE (XEXP (e, 0)) != REG\n+\t      || REGNO (XEXP (e, 0)) != SP_REGNUM\n+\t      || GET_CODE (XEXP (e, 1)) != CONST_INT\n+\t      || offset != INTVAL (XEXP (e, 1)))\n+\t    abort ();\n+\t}\n+      else if (i != 1\n+\t       || GET_CODE (e) != REG\n+\t       || REGNO (e) != SP_REGNUM)\n+\tabort ();\n+#endif\n+    }\n+  fprintf (asm_out_file, \"}\\n\");\n+}\n+\n+/*  Emit unwind directives for a SET.  */\n+\n+static void\n+arm_unwind_emit_set (FILE * asm_out_file, rtx p)\n+{\n+  rtx e0;\n+  rtx e1;\n+\n+  e0 = XEXP (p, 0);\n+  e1 = XEXP (p, 1);\n+  switch (GET_CODE (e0))\n+    {\n+    case MEM:\n+      /* Pushing a single register.  */\n+      if (GET_CODE (XEXP (e0, 0)) != PRE_DEC\n+\t  || GET_CODE (XEXP (XEXP (e0, 0), 0)) != REG\n+\t  || REGNO (XEXP (XEXP (e0, 0), 0)) != SP_REGNUM)\n+\tabort ();\n+\n+      asm_fprintf (asm_out_file, \"\\t.save \");\n+      if (IS_VFP_REGNUM (REGNO (e1)))\n+\tasm_fprintf(asm_out_file, \"{d%d}\\n\",\n+\t\t    (REGNO (e1) - FIRST_VFP_REGNUM) / 2);\n+      else\n+\tasm_fprintf(asm_out_file, \"{%r}\\n\", REGNO (e1));\n+      break;\n+\n+    case REG:\n+      if (REGNO (e0) == SP_REGNUM)\n+\t{\n+\t  /* A stack increment.  */\n+\t  if (GET_CODE (e1) != PLUS\n+\t      || GET_CODE (XEXP (e1, 0)) != REG\n+\t      || REGNO (XEXP (e1, 0)) != SP_REGNUM\n+\t      || GET_CODE (XEXP (e1, 1)) != CONST_INT)\n+\t    abort ();\n+\n+\t  asm_fprintf (asm_out_file, \"\\t.pad #%d\\n\",\n+\t\t       -INTVAL (XEXP (e1, 1)));\n+\t}\n+      else if (REGNO (e0) == HARD_FRAME_POINTER_REGNUM)\n+\t{\n+\t  HOST_WIDE_INT offset;\n+\t  unsigned reg;\n+\t  \n+\t  if (GET_CODE (e1) == PLUS)\n+\t    {\n+\t      if (GET_CODE (XEXP (e1, 0)) != REG\n+\t\t  || GET_CODE (XEXP (e1, 1)) != CONST_INT)\n+\t\tabort ();\n+\t      reg = REGNO (XEXP (e1, 0));\n+\t      offset = INTVAL (XEXP (e1, 1));\n+\t      asm_fprintf (asm_out_file, \"\\t.setfp %r, %r, #%d\\n\",\n+\t\t\t   HARD_FRAME_POINTER_REGNUM, reg,\n+\t\t\t   INTVAL (XEXP (e1, 1)));\n+\t    }\n+\t  else if (GET_CODE (e1) == REG)\n+\t    {\n+\t      reg = REGNO (e1);\n+\t      asm_fprintf (asm_out_file, \"\\t.setfp %r, %r\\n\",\n+\t\t\t   HARD_FRAME_POINTER_REGNUM, reg);\n+\t    }\n+\t  else\n+\t    abort ();\n+\t}\n+      else if (GET_CODE (e1) == REG && REGNO (e1) == SP_REGNUM)\n+\t{\n+\t  /* Move from sp to reg.  */\n+\t  asm_fprintf (asm_out_file, \"\\t.movsp %r\\n\", REGNO (e0));\n+\t}\n+      else\n+\tabort ();\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n+}\n+\n+\n+/* Emit unwind directives for the given insn.  */\n+\n+static void\n+arm_unwind_emit (FILE * asm_out_file, rtx insn)\n+{\n+  rtx pat;\n+\n+  if (!ARM_EABI_UNWIND_TABLES)\n+    return;\n+\n+  if (GET_CODE (insn) == NOTE || !RTX_FRAME_RELATED_P (insn))\n+    return;\n+\n+  pat = find_reg_note (insn, REG_FRAME_RELATED_EXPR, NULL_RTX);\n+  if (pat)\n+    pat = XEXP (pat, 0);\n+  else\n+    pat = PATTERN (insn);\n+\n+  switch (GET_CODE (pat))\n+    {\n+    case SET:\n+      arm_unwind_emit_set (asm_out_file, pat);\n+      break;\n+\n+    case SEQUENCE:\n+      /* Store multiple.  */\n+      arm_unwind_emit_stm (asm_out_file, pat);\n+      break;\n+\n+    default:\n+      abort();\n+    }\n+}\n+\n+\n+/* Output a reference from a function exception table to the type_info\n+   object X.  The EABI specifies that the symbol should be relocated by\n+   an R_ARM_TARGET2 relocation.  */\n+\n+static bool\n+arm_output_ttype (rtx x)\n+{\n+  fputs (\"\\t.word\\t\", asm_out_file);\n+  output_addr_const (asm_out_file, x);\n+  /* Use special relocations for symbol references.  */\n+  if (GET_CODE (x) != CONST_INT)\n+    fputs (\"(TARGET2)\", asm_out_file);\n+  fputc ('\\n', asm_out_file);\n+\n+  return TRUE;\n+}\n+#endif /* TARGET_UNWIND_INFO */\n+\n+\n+/* Output unwind directives for the start/end of a function.  */\n+\n+void\n+arm_output_fn_unwind (FILE * f, bool prologue)\n+{\n+  if (!ARM_EABI_UNWIND_TABLES)\n+    return;\n+\n+  if (prologue)\n+    fputs (\"\\t.fnstart\\n\", f);\n+  else\n+    fputs (\"\\t.fnend\\n\", f);\n+}"}, {"sha": "327393c7e3dd7b3c266ea8c341cf80c2fbc25b1f", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617a1b714435a270ccf699c4c6e17767088e2242/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617a1b714435a270ccf699c4c6e17767088e2242/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=617a1b714435a270ccf699c4c6e17767088e2242", "patch": "@@ -770,8 +770,11 @@ extern int arm_structure_size_boundary;\n #define FIRST_HI_REGNUM\t\t8\n #define LAST_HI_REGNUM\t\t11\n \n+#ifndef TARGET_UNWIND_INFO\n /* We use sjlj exceptions for backwards compatibility.  */\n #define MUST_USE_SJLJ_EXCEPTIONS 1\n+#endif\n+\n /* We can generate DWARF2 Unwind info, even though we don't use it.  */\n #define DWARF2_UNWIND_INFO 1\n \n@@ -1977,6 +1980,15 @@ typedef struct\n   if (!TARGET_LONG_CALLS || ! DECL_SECTION_NAME (DECL)) \\\n     arm_encode_call_attribute (DECL, SHORT_CALL_FLAG_CHAR)\n \n+#define ARM_OUTPUT_FN_UNWIND(F, PROLOGUE) arm_output_fn_unwind (F, PROLOGUE)\n+\n+#ifdef TARGET_UNWIND_INFO\n+#define ARM_EABI_UNWIND_TABLES \\\n+  ((!USING_SJLJ_EXCEPTIONS && flag_exceptions) || flag_unwind_tables)\n+#else\n+#define ARM_EABI_UNWIND_TABLES 0\n+#endif\n+\n /* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n    and check its validity for a certain class.\n    We have two alternate definitions for each of them."}, {"sha": "7fb7d6a265bafb7587f2f37d2b2e68a8d987d222", "filename": "gcc/config/arm/bpabi.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617a1b714435a270ccf699c4c6e17767088e2242/gcc%2Fconfig%2Farm%2Fbpabi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617a1b714435a270ccf699c4c6e17767088e2242/gcc%2Fconfig%2Farm%2Fbpabi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fbpabi.h?ref=617a1b714435a270ccf699c4c6e17767088e2242", "patch": "@@ -26,6 +26,9 @@\n /* Assume that AAPCS ABIs should adhere to the full BPABI.  */ \n #define TARGET_BPABI (TARGET_AAPCS_BASED)\n \n+/* BPABI targets use EABI frame unwinding tables.  */\n+#define TARGET_UNWIND_INFO 1\n+\n /* Section 4.1 of the AAPCS requires the use of VFP format.  */\n #define FPUTYPE_DEFAULT FPUTYPE_VFP\n "}, {"sha": "ae3d5338d8f85601544a3ab07457dc25e3305dac", "filename": "gcc/config/arm/elf.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617a1b714435a270ccf699c4c6e17767088e2242/gcc%2Fconfig%2Farm%2Felf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617a1b714435a270ccf699c4c6e17767088e2242/gcc%2Fconfig%2Farm%2Felf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Felf.h?ref=617a1b714435a270ccf699c4c6e17767088e2242", "patch": "@@ -77,6 +77,7 @@\n       ASM_OUTPUT_TYPE_DIRECTIVE (FILE, NAME, \"function\");\t\\\n       ASM_DECLARE_RESULT (FILE, DECL_RESULT (DECL));\t\t\\\n       ASM_OUTPUT_LABEL(FILE, NAME);\t\t\t\t\\\n+      ARM_OUTPUT_FN_UNWIND (FILE, TRUE);\t\t\t\\\n     }\t\t\t\t\t\t\t\t\\\n   while (0)\n \n@@ -85,6 +86,7 @@\n #define ASM_DECLARE_FUNCTION_SIZE(FILE, FNAME, DECL)\t\t\\\n   do\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\\\n+      ARM_OUTPUT_FN_UNWIND (FILE, FALSE);\t\t\t\\\n       ARM_DECLARE_FUNCTION_SIZE (FILE, FNAME, DECL);\t\t\\\n       if (!flag_inhibit_size_directive)\t\t\t\t\\\n \tASM_OUTPUT_MEASURED_SIZE (FILE, FNAME);\t\t\t\\"}, {"sha": "ebf31eb8cc5c8de9d3d53734dbcc7db3b93fce19", "filename": "gcc/config/arm/lib1funcs.asm", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617a1b714435a270ccf699c4c6e17767088e2242/gcc%2Fconfig%2Farm%2Flib1funcs.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617a1b714435a270ccf699c4c6e17767088e2242/gcc%2Fconfig%2Farm%2Flib1funcs.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Flib1funcs.asm?ref=617a1b714435a270ccf699c4c6e17767088e2242", "patch": "@@ -1309,4 +1309,5 @@ LSYM(Lchange_\\register):\n #include \"ieee754-df.S\"\n #include \"ieee754-sf.S\"\n #include \"bpabi.S\"\n+#include \"libunwind.S\"\n #endif /* __symbian__ */"}, {"sha": "35966bbfc72876234941e569d7e3bb86d8cf7bbe", "filename": "gcc/config/arm/libgcc-bpabi.ver", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617a1b714435a270ccf699c4c6e17767088e2242/gcc%2Fconfig%2Farm%2Flibgcc-bpabi.ver", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617a1b714435a270ccf699c4c6e17767088e2242/gcc%2Fconfig%2Farm%2Flibgcc-bpabi.ver", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Flibgcc-bpabi.ver?ref=617a1b714435a270ccf699c4c6e17767088e2242", "patch": "@@ -60,4 +60,18 @@ GCC_3.5 {\n   __aeabi_ulcmp\n   __aeabi_ul2d\n   __aeabi_ul2f\n+\n+  # Exception-Handling\n+  # \\S 7.5\n+  _Unwind_Complete\n+  _Unwind_VRS_Get\n+  _Unwind_VRS_Set\n+  _Unwind_VRS_Pop\n+  # \\S 9.2\n+  __aeabi_unwind_cpp_pr0\n+  __aeabi_unwind_cpp_pr1\n+  __aeabi_unwind_cpp_pr2\n+  # The libstdc++ exception-handling personality routine uses this \n+  # GNU-specific entry point.\n+  __gnu_unwind_frame\n }"}, {"sha": "74c0ae138a3ae618f803fd2a01db63a68e4f2642", "filename": "gcc/config/arm/t-bpabi", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617a1b714435a270ccf699c4c6e17767088e2242/gcc%2Fconfig%2Farm%2Ft-bpabi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617a1b714435a270ccf699c4c6e17767088e2242/gcc%2Fconfig%2Farm%2Ft-bpabi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ft-bpabi?ref=617a1b714435a270ccf699c4c6e17767088e2242", "patch": "@@ -1,9 +1,15 @@\n # Add the bpabi.S functions.\n-LIB1ASMFUNCS += _aeabi_lcmp _aeabi_ulcmp _aeabi_ldivmod _aeabi_uldivmod\n+LIB1ASMFUNCS += _aeabi_lcmp _aeabi_ulcmp _aeabi_ldivmod _aeabi_uldivmod \\\n+  _unwind\n \n # Add the BPABI C functions.\n LIB2FUNCS_EXTRA = $(srcdir)/config/arm/bpabi.c\n \n+UNWIND_H = $(srcdir)/config/arm/unwind-arm.h\n+LIB2ADDEH = $(srcdir)/config/arm/unwind-arm.c \\\n+  $(srcdir)/config/arm/pr-support.c $(srcdir)/unwind-c.c\n+LIB2ADDEHDEP = $(UNWIND_H)\n+\n # Add the BPABI names.\n SHLIB_MAPFILES += $(srcdir)/config/arm/libgcc-bpabi.ver\n "}, {"sha": "8f72b3ea89d469a2b425cbcf5cfd8462e7ba7327", "filename": "gcc/config/arm/t-symbian", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617a1b714435a270ccf699c4c6e17767088e2242/gcc%2Fconfig%2Farm%2Ft-symbian", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617a1b714435a270ccf699c4c6e17767088e2242/gcc%2Fconfig%2Farm%2Ft-symbian", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ft-symbian?ref=617a1b714435a270ccf699c4c6e17767088e2242", "patch": "@@ -12,6 +12,11 @@ LIB1ASMFUNCS += \\\n \t_truncdfsf2 _negsf2 _addsubsf3 _muldivsf3 _cmpsf2 _unordsf2 \\\n \t_fixsfsi _fixunssfsi\n \n+# Include the gcc personality routine\n+UNWIND_H = $(srcdir)/config/arm/unwind-arm.h\n+LIB2ADDEH = $(srcdir)/unwind-c.c\n+LIB2ADDEHDEP = $(UNWIND_H)\n+\n # Create a multilib for processors with VFP floating-point, and a\n # multilib for those without -- using the soft-float ABI in both\n # cases.  Symbian OS object should be compiled with interworking"}, {"sha": "2d3a828a5e5d12c44d9f413455bc5d5c694e3431", "filename": "gcc/config/i386/t-netware", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617a1b714435a270ccf699c4c6e17767088e2242/gcc%2Fconfig%2Fi386%2Ft-netware", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617a1b714435a270ccf699c4c6e17767088e2242/gcc%2Fconfig%2Fi386%2Ft-netware", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Ft-netware?ref=617a1b714435a270ccf699c4c6e17767088e2242", "patch": "@@ -6,5 +6,4 @@ netware.o: $(srcdir)/config/i386/netware.c $(RTL_H) $(TREE_H) $(CONFIG_H) $(TM_P\n # We don't need some of GCC's own include files.\n USER_H = $(srcdir)/ginclude/stdarg.h \\\n          $(srcdir)/ginclude/varargs.h \\\n-         $(srcdir)/unwind.h \\\n     $(EXTRA_HEADERS) $(LANG_EXTRA_HEADERS)"}, {"sha": "9e52773fdcbbdca1c36c3976d21dfd51981c1033", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617a1b714435a270ccf699c4c6e17767088e2242/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617a1b714435a270ccf699c4c6e17767088e2242/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=617a1b714435a270ccf699c4c6e17767088e2242", "patch": "@@ -1985,6 +1985,8 @@ extern int ia64_final_schedule;\n \n #define TARGET_UNWIND_INFO\t1\n \n+#define TARGET_UNWIND_TABLES_DEFAULT true\n+\n #define EH_RETURN_DATA_REGNO(N) ((N) < 4 ? (N) + 15 : INVALID_REGNUM)\n \n /* This function contains machine specific function data.  */"}, {"sha": "128ea648dfe8794de079a4a71f706c6a85879054", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617a1b714435a270ccf699c4c6e17767088e2242/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617a1b714435a270ccf699c4c6e17767088e2242/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=617a1b714435a270ccf699c4c6e17767088e2242", "patch": "@@ -1,3 +1,10 @@\n+2005-06-28  Paul Brook  <paul@codesourcery.com>\n+\n+\t* Make-lang.in (cp/except.o): Depend on $(TARGET_H)\n+\t* except.c: Include target.h.\n+\t(init_exception_processing): Initialize unwind_resume_libfunc.\n+\t* doc/tm.texi: Document TARGET_ASM_TTYPE\n+\n 2005-06-26  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* call.c (build_over_call): Pass in named argument list to"}, {"sha": "f555f31ede93909481a6e701b9bc7598ec2f48de", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617a1b714435a270ccf699c4c6e17767088e2242/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617a1b714435a270ccf699c4c6e17767088e2242/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=617a1b714435a270ccf699c4c6e17767088e2242", "patch": "@@ -272,7 +272,7 @@ cp/ptree.o: cp/ptree.c $(CXX_TREE_H) $(TM_H)\n cp/rtti.o: cp/rtti.c $(CXX_TREE_H) $(TM_H) flags.h toplev.h convert.h \\\n   gt-cp-rtti.h\n cp/except.o: cp/except.c $(CXX_TREE_H) $(TM_H) flags.h $(RTL_H) except.h \\\n-  toplev.h cp/cfns.h $(EXPR_H) libfuncs.h tree-inline.h\n+  toplev.h cp/cfns.h $(EXPR_H) libfuncs.h tree-inline.h $(TARGET_H)\n cp/expr.o: cp/expr.c $(CXX_TREE_H) $(TM_H) $(RTL_H) flags.h $(EXPR_H) \\\n   toplev.h except.h $(TM_P_H)\n cp/pt.o: cp/pt.c $(CXX_TREE_H) $(TM_H) cp/decl.h cp/cp-objcp-common.h \\"}, {"sha": "be7208e2f0fd23a0f9e48853df7b7ce5fa38435f", "filename": "gcc/cp/except.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617a1b714435a270ccf699c4c6e17767088e2242/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617a1b714435a270ccf699c4c6e17767088e2242/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=617a1b714435a270ccf699c4c6e17767088e2242", "patch": "@@ -38,6 +38,7 @@ Boston, MA 02110-1301, USA.  */\n #include \"toplev.h\"\n #include \"tree-inline.h\"\n #include \"tree-iterator.h\"\n+#include \"target.h\"\n \n static void push_eh_cleanup (tree);\n static tree prepare_eh_type (tree);\n@@ -79,6 +80,10 @@ init_exception_processing (void)\n   eh_personality_libfunc = init_one_libfunc (USING_SJLJ_EXCEPTIONS\n \t\t\t\t\t     ? \"__gxx_personality_sj0\"\n \t\t\t\t\t     : \"__gxx_personality_v0\");\n+  if (targetm.arm_eabi_unwinder)\n+    unwind_resume_libfunc = init_one_libfunc (\"__cxa_end_cleanup\");\n+  else\n+    default_init_unwind_resume_libfunc ();\n \n   lang_eh_runtime_type = build_eh_type_type;\n   lang_protect_cleanup_actions = &cp_protect_cleanup_actions;"}, {"sha": "bbca6b9a6997040edbc350d0d8ce0d48856c27bd", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617a1b714435a270ccf699c4c6e17767088e2242/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617a1b714435a270ccf699c4c6e17767088e2242/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=617a1b714435a270ccf699c4c6e17767088e2242", "patch": "@@ -7648,6 +7648,11 @@ Define this macro if your target has ABI specified unwind tables.  Usually\n these will be output by @code{TARGET_UNWIND_EMIT}.\n @end defmac\n \n+@deftypevar {Target Hook} bool TARGET_UNWID_TABLES_DEFAULT\n+This variable should be set to @code{true} if the target ABI requires unwinding\n+tables even when exceptions are not used.\n+@end deftypevar\n+\n @defmac MUST_USE_SJLJ_EXCEPTIONS\n This macro need only be defined if @code{DWARF2_UNWIND_INFO} is\n runtime-variable.  In that case, @file{except.h} cannot correctly\n@@ -7698,6 +7703,20 @@ register in Dwarf.  Otherwise, this hook should return @code{NULL_RTX}.\n If not defined, the default is to return @code{NULL_RTX}.\n @end deftypefn\n \n+@deftypefn {Target Hook} bool TARGET_ASM_TTYPE (rtx @var{sym})\n+This hook is used to output a reference from a frame unwinding table to\n+the type_info object identified by @var{sym}.  It should return @code{true}\n+if the reference was output.  Returning @code{false} will cause the\n+reference to be output using the normal Dwarf2 routines.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} bool TARGET_ARM_EABI_UNWINDER\n+This hook should be set to @code{true} on targets that use an ARM EABI\n+based unwinding library, and @code{false} on other targets.  This effects\n+the format of unwinding tables, and how the unwinder in entered after\n+running a cleanup.  The default is @code{false}.\n+@end deftypefn\n+\n @node Alignment Output\n @subsection Assembler Commands for Alignment\n "}, {"sha": "1bcdc28f8b12ef1b138cbbb939ab904219ddcf89", "filename": "gcc/except.c", "status": "modified", "additions": 92, "deletions": 42, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617a1b714435a270ccf699c4c6e17767088e2242/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617a1b714435a270ccf699c4c6e17767088e2242/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=617a1b714435a270ccf699c4c6e17767088e2242", "patch": "@@ -1134,12 +1134,23 @@ add_ehspec_entry (htab_t ehspec_hash, htab_t ttypes_hash, tree list)\n       n->filter = -(VARRAY_ACTIVE_SIZE (cfun->eh->ehspec_data) + 1);\n       *slot = n;\n \n-      /* Look up each type in the list and encode its filter\n-\t value as a uleb128.  Terminate the list with 0.  */\n+      /* Generate a 0 terminated list of filter values.  */\n       for (; list ; list = TREE_CHAIN (list))\n-\tpush_uleb128 (&cfun->eh->ehspec_data,\n-\t\t      add_ttypes_entry (ttypes_hash, TREE_VALUE (list)));\n-      VARRAY_PUSH_UCHAR (cfun->eh->ehspec_data, 0);\n+\t{\n+\t  if (targetm.arm_eabi_unwinder)\n+\t    VARRAY_PUSH_TREE (cfun->eh->ehspec_data, TREE_VALUE (list));\n+\t  else\n+\t    {\n+\t      /* Look up each type in the list and encode its filter\n+\t\t value as a uleb128.  */\n+\t      push_uleb128 (&cfun->eh->ehspec_data,\n+\t\t  add_ttypes_entry (ttypes_hash, TREE_VALUE (list)));\n+\t    }\n+\t}\n+      if (targetm.arm_eabi_unwinder)\n+\tVARRAY_PUSH_TREE (cfun->eh->ehspec_data, NULL_TREE);\n+      else\n+\tVARRAY_PUSH_UCHAR (cfun->eh->ehspec_data, 0);\n     }\n \n   return n->filter;\n@@ -1157,7 +1168,10 @@ assign_filter_values (void)\n   htab_t ttypes, ehspec;\n \n   cfun->eh->ttype_data = VEC_alloc (tree, gc, 16);\n-  VARRAY_UCHAR_INIT (cfun->eh->ehspec_data, 64, \"ehspec_data\");\n+  if (targetm.arm_eabi_unwinder)\n+    VARRAY_TREE_INIT (cfun->eh->ehspec_data, 64, \"ehspec_data\");\n+  else\n+    VARRAY_UCHAR_INIT (cfun->eh->ehspec_data, 64, \"ehspec_data\");\n \n   ttypes = htab_create (31, ttypes_filter_hash, ttypes_filter_eq, free);\n   ehspec = htab_create (31, ehspec_filter_hash, ehspec_filter_eq, free);\n@@ -3377,6 +3391,54 @@ default_exception_section (void)\n     readonly_data_section ();\n }\n \n+\n+/* Output a reference from an exception table to the type_info object TYPE.\n+   TT_FORMAT and TT_FORMAT_SIZE descibe the DWARF encoding method used for\n+   the value.  */\n+\n+static void\n+output_ttype (tree type, int tt_format, int tt_format_size)\n+{\n+  rtx value;\n+\n+  if (type == NULL_TREE)\n+    value = const0_rtx;\n+  else\n+    {\n+      struct cgraph_varpool_node *node;\n+\n+      type = lookup_type_for_runtime (type);\n+      value = expand_expr (type, NULL_RTX, VOIDmode, EXPAND_INITIALIZER);\n+\n+      /* Let cgraph know that the rtti decl is used.  Not all of the\n+\t paths below go through assemble_integer, which would take\n+\t care of this for us.  */\n+      STRIP_NOPS (type);\n+      if (TREE_CODE (type) == ADDR_EXPR)\n+\t{\n+\t  type = TREE_OPERAND (type, 0);\n+\t  if (TREE_CODE (type) == VAR_DECL)\n+\t    {\n+\t      node = cgraph_varpool_node (type);\n+\t      if (node)\n+\t\tcgraph_varpool_mark_needed_node (node);\n+\t    }\n+\t}\n+      else if (TREE_CODE (type) != INTEGER_CST)\n+\tabort ();\n+    }\n+\n+  /* Allow the target to override the type table entry format.  */\n+  if (targetm.asm_out.ttype (value))\n+    return;\n+\n+  if (tt_format == DW_EH_PE_absptr || tt_format == DW_EH_PE_aligned)\n+    assemble_integer (value, tt_format_size,\n+\t\t      tt_format_size * BITS_PER_UNIT, 1);\n+  else\n+    dw2_asm_output_encoded_addr_rtx (tt_format, value, NULL);\n+}\n+\n void\n output_function_exception_table (void)\n {\n@@ -3536,40 +3598,7 @@ output_function_exception_table (void)\n   while (i-- > 0)\n     {\n       tree type = VEC_index (tree, cfun->eh->ttype_data, i);\n-      rtx value;\n-\n-      if (type == NULL_TREE)\n-\tvalue = const0_rtx;\n-      else\n-\t{\n-\t  struct cgraph_varpool_node *node;\n-\n-\t  type = lookup_type_for_runtime (type);\n-\t  value = expand_expr (type, NULL_RTX, VOIDmode, EXPAND_INITIALIZER);\n-\n-\t  /* Let cgraph know that the rtti decl is used.  Not all of the\n-\t     paths below go through assemble_integer, which would take\n-\t     care of this for us.  */\n-\t  STRIP_NOPS (type);\n-\t  if (TREE_CODE (type) == ADDR_EXPR)\n-\t    {\n-\t      type = TREE_OPERAND (type, 0);\n-\t      if (TREE_CODE (type) == VAR_DECL)\n-\t\t{\n-\t          node = cgraph_varpool_node (type);\n-\t          if (node)\n-\t\t    cgraph_varpool_mark_needed_node (node);\n-\t\t}\n-\t    }\n-\t  else\n-\t    gcc_assert (TREE_CODE (type) == INTEGER_CST);\n-\t}\n-\n-      if (tt_format == DW_EH_PE_absptr || tt_format == DW_EH_PE_aligned)\n-\tassemble_integer (value, tt_format_size,\n-\t\t\t  tt_format_size * BITS_PER_UNIT, 1);\n-      else\n-\tdw2_asm_output_encoded_addr_rtx (tt_format, value, NULL);\n+      output_ttype (type, tt_format, tt_format_size);\n     }\n \n #ifdef HAVE_AS_LEB128\n@@ -3580,8 +3609,16 @@ output_function_exception_table (void)\n   /* ??? Decode and interpret the data for flag_debug_asm.  */\n   n = VARRAY_ACTIVE_SIZE (cfun->eh->ehspec_data);\n   for (i = 0; i < n; ++i)\n-    dw2_asm_output_data (1, VARRAY_UCHAR (cfun->eh->ehspec_data, i),\n-\t\t\t (i ? NULL : \"Exception specification table\"));\n+    {\n+      if (targetm.arm_eabi_unwinder)\n+\t{\n+\t  tree type = VARRAY_TREE (cfun->eh->ehspec_data, i);\n+\t  output_ttype (type, tt_format, tt_format_size);\n+\t}\n+      else\n+\tdw2_asm_output_data (1, VARRAY_UCHAR (cfun->eh->ehspec_data, i),\n+\t\t\t     (i ? NULL : \"Exception specification table\"));\n+    }\n \n   current_function_section (current_function_decl);\n }\n@@ -3730,4 +3767,17 @@ verify_eh_tree (struct function *fun)\n \t}\n     }\n }\n+\n+\n+/* Initialize unwind_resume_libfunc.  */\n+\n+void\n+default_init_unwind_resume_libfunc (void)\n+{\n+  /* The default c++ routines aren't actually c++ specific, so use those.  */\n+  unwind_resume_libfunc =\n+    init_one_libfunc ( USING_SJLJ_EXCEPTIONS ? \"_Unwind_SjLj_Resume\"\n+\t\t\t\t\t     : \"_Unwind_Resume\");\n+}\n+\n #include \"gt-except.h\""}, {"sha": "d5e391d9c77bbad3de31aa95681b6899160280d4", "filename": "gcc/except.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617a1b714435a270ccf699c4c6e17767088e2242/gcc%2Fexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617a1b714435a270ccf699c4c6e17767088e2242/gcc%2Fexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.h?ref=617a1b714435a270ccf699c4c6e17767088e2242", "patch": "@@ -85,6 +85,7 @@ typedef tree (*duplicate_eh_regions_map) (tree, void *);\n extern int duplicate_eh_regions (struct function *, duplicate_eh_regions_map, void *, int);\n \n extern void sjlj_emit_function_exit_after (rtx);\n+extern void default_init_unwind_resume_libfunc (void);\n \n extern struct eh_region *gen_eh_region_cleanup (struct eh_region *,\n \t\t\t\t\t\tstruct eh_region *);"}, {"sha": "68699ffe3cf922a7116ef86e83a97ca30c9568a1", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617a1b714435a270ccf699c4c6e17767088e2242/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617a1b714435a270ccf699c4c6e17767088e2242/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=617a1b714435a270ccf699c4c6e17767088e2242", "patch": "@@ -1,3 +1,8 @@\n+2005-06-28  Paul Brook  <paul@codesourcery.com>\n+\n+\t* decl.c (java_init_decl_processing): Call\n+\tdefault_init_unwind_resume_libfunc.\n+\n 2005-06-27  Tom Tromey  <tromey@redhat.com>\n \n \tPR java/21540, PR java/13788:"}, {"sha": "e63ef840af9646feed45771c2392828838fc9b1f", "filename": "gcc/java/decl.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617a1b714435a270ccf699c4c6e17767088e2242/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617a1b714435a270ccf699c4c6e17767088e2242/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=617a1b714435a270ccf699c4c6e17767088e2242", "patch": "@@ -1197,6 +1197,7 @@ java_init_decl_processing (void)\n   eh_personality_libfunc = init_one_libfunc (USING_SJLJ_EXCEPTIONS\n                                              ? \"__gcj_personality_sj0\"\n                                              : \"__gcj_personality_v0\");\n+  default_init_unwind_resume_libfunc ();\n \n   lang_eh_runtime_type = do_nothing;\n "}, {"sha": "52325f4b70abd222eef5604b43d01c5f8e9f601b", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617a1b714435a270ccf699c4c6e17767088e2242/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617a1b714435a270ccf699c4c6e17767088e2242/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=617a1b714435a270ccf699c4c6e17767088e2242", "patch": "@@ -1,3 +1,8 @@\n+2005-06-28  Paul Brook  <paul@codesourcery.com>\n+\n+\t* objc-act.c (objc_init_exceptions): Call\n+\tdefault_init_unwind_resume_libfunc.\n+\n 2005-06-27  Ziemowit Laski  <zlaski@apple.com>\n \n \t* objc-act.c (objc_build_struct): Save the TYPE_OBJC_INFO"}, {"sha": "d4c20a87ec9f2688196932a26cecef4f2bf833c0", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617a1b714435a270ccf699c4c6e17767088e2242/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617a1b714435a270ccf699c4c6e17767088e2242/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=617a1b714435a270ccf699c4c6e17767088e2242", "patch": "@@ -3407,6 +3407,7 @@ objc_init_exceptions (void)\n \t= init_one_libfunc (USING_SJLJ_EXCEPTIONS\n \t\t\t    ? \"__gnu_objc_personality_sj0\"\n \t\t\t    : \"__gnu_objc_personality_v0\");\n+      default_init_unwind_resume_libfunc ();\n       using_eh_for_cleanups ();\n       lang_eh_runtime_type = objc_eh_runtime_type;\n     }"}, {"sha": "6f5716ebcdac3b90a8df57c697d22440a5e1a545", "filename": "gcc/optabs.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617a1b714435a270ccf699c4c6e17767088e2242/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617a1b714435a270ccf699c4c6e17767088e2242/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=617a1b714435a270ccf699c4c6e17767088e2242", "patch": "@@ -5288,9 +5288,6 @@ init_optabs (void)\n   memset_libfunc = init_one_libfunc (\"memset\");\n   setbits_libfunc = init_one_libfunc (\"__setbits\");\n \n-  unwind_resume_libfunc = init_one_libfunc (USING_SJLJ_EXCEPTIONS\n-\t\t\t\t\t    ? \"_Unwind_SjLj_Resume\"\n-\t\t\t\t\t    : \"_Unwind_Resume\");\n #ifndef DONT_USE_BUILTIN_SETJMP\n   setjmp_libfunc = init_one_libfunc (\"__builtin_setjmp\");\n   longjmp_libfunc = init_one_libfunc (\"__builtin_longjmp\");"}, {"sha": "e96d6d56a5516f330adacb51cc299d99daca8c83", "filename": "gcc/opts.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617a1b714435a270ccf699c4c6e17767088e2242/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617a1b714435a270ccf699c4c6e17767088e2242/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=617a1b714435a270ccf699c4c6e17767088e2242", "patch": "@@ -627,11 +627,8 @@ decode_options (unsigned int argc, const char **argv)\n      modify it.  */\n   target_flags = targetm.default_target_flags;\n \n-  /* Unwind tables are always present when a target has ABI-specified unwind\n-     tables, so the default should be ON.  */\n-#ifdef TARGET_UNWIND_INFO\n-  flag_unwind_tables = TARGET_UNWIND_INFO;\n-#endif\n+  /* Some tagets have ABI-specified unwind tables.  */\n+  flag_unwind_tables = targetm.unwind_tables_default;\n \n #ifdef OPTIMIZATION_OPTIONS\n   /* Allow default optimizations to be specified on a per-machine basis.  */"}, {"sha": "9998a19b5aa55f6dc24933a8990f949ddb7a1dbb", "filename": "gcc/target-def.h", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617a1b714435a270ccf699c4c6e17767088e2242/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617a1b714435a270ccf699c4c6e17767088e2242/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=617a1b714435a270ccf699c4c6e17767088e2242", "patch": "@@ -70,6 +70,10 @@ Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n #define TARGET_ASM_INTERNAL_LABEL default_internal_label\n #endif\n \n+#ifndef TARGET_ARM_TTYPE\n+#define TARGET_ASM_TTYPE hook_bool_rtx_false\n+#endif\n+\n #ifndef TARGET_ASM_ASSEMBLE_VISIBILITY\n #define TARGET_ASM_ASSEMBLE_VISIBILITY default_assemble_visibility\n #endif\n@@ -217,6 +221,7 @@ Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n                         TARGET_ASM_EMIT_UNWIND_LABEL,           \\\n \t\t\tTARGET_UNWIND_EMIT,\t\t\t\\\n \t\t\tTARGET_ASM_INTERNAL_LABEL,\t\t\\\n+\t\t\tTARGET_ASM_TTYPE,\t\t\t\\\n \t\t\tTARGET_ASM_ASSEMBLE_VISIBILITY,\t\t\\\n \t\t\tTARGET_ASM_FUNCTION_PROLOGUE,\t\t\\\n \t\t\tTARGET_ASM_FUNCTION_END_PROLOGUE,\t\\\n@@ -401,6 +406,8 @@ Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n #define TARGET_STACK_PROTECT_GUARD  default_stack_protect_guard\n #define TARGET_STACK_PROTECT_FAIL   default_external_stack_protect_fail\n \n+#define TARGET_ARM_EABI_UNWINDER false\n+\n #define TARGET_PROMOTE_FUNCTION_ARGS hook_bool_tree_false\n #define TARGET_PROMOTE_FUNCTION_RETURN hook_bool_tree_false\n #define TARGET_PROMOTE_PROTOTYPES hook_bool_tree_false\n@@ -444,6 +451,9 @@ Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n    TARGET_INVALID_ARG_FOR_UNPROTOTYPED_FN\t\t\t\\\n    }\n \n+#ifndef TARGET_UNWIND_TABLES_DEFAULT\n+#define TARGET_UNWIND_TABLES_DEFAULT false\n+#endif\n \n #ifndef TARGET_HANDLE_PRAGMA_REDEFINE_EXTNAME\n #define TARGET_HANDLE_PRAGMA_REDEFINE_EXTNAME 0\n@@ -506,7 +516,7 @@ Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n     TARGET_CXX_KEY_METHOD_MAY_BE_INLINE,\t\\\n     TARGET_CXX_DETERMINE_CLASS_DATA_VISIBILITY,\t\\\n     TARGET_CXX_CLASS_DATA_ALWAYS_COMDAT,        \\\n-    TARGET_CXX_USE_AEABI_ATEXIT\t\t\t\\\n+    TARGET_CXX_USE_AEABI_ATEXIT,\t\t\\\n   }\n \n /* The whole shebang.  */\n@@ -572,6 +582,7 @@ Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n   TARGET_INVALID_WITHIN_DOLOOP,\t\t\t\\\n   TARGET_CALLS,\t\t\t\t\t\\\n   TARGET_CXX,\t\t\t\t\t\\\n+  TARGET_UNWIND_TABLES_DEFAULT,\t\t\t\\\n   TARGET_HAVE_NAMED_SECTIONS,\t\t\t\\\n   TARGET_HAVE_CTORS_DTORS,\t\t\t\\\n   TARGET_HAVE_TLS,\t\t\t\t\\\n@@ -582,6 +593,7 @@ Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n   TARGET_HANDLE_PRAGMA_REDEFINE_EXTNAME,\t\\\n   TARGET_HANDLE_PRAGMA_EXTERN_PREFIX,\t\t\\\n   TARGET_RELAXED_ORDERING,\t\t\t\\\n+  TARGET_ARM_EABI_UNWINDER\t\t\t\\\n }\n \n #include \"hooks.h\""}, {"sha": "364e95afbbde76925ec5c2cef2ab8c6aa517d283", "filename": "gcc/target.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617a1b714435a270ccf699c4c6e17767088e2242/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617a1b714435a270ccf699c4c6e17767088e2242/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=617a1b714435a270ccf699c4c6e17767088e2242", "patch": "@@ -93,6 +93,9 @@ struct gcc_target\n     /* Output an internal label.  */\n     void (* internal_label) (FILE *, const char *, unsigned long);\n \n+    /* Emit a ttype table reference to a typeinfo object.  */\n+    bool (* ttype) (rtx);\n+\n     /* Emit an assembler directive to set visibility for the symbol\n        associated with the tree decl.  */\n     void (* visibility) (tree, int);\n@@ -635,6 +638,9 @@ struct gcc_target\n     bool (*use_aeabi_atexit) (void);\n   } cxx;\n \n+  /* True if unwinding tables should be generated by default.  */\n+  bool unwind_tables_default;\n+\n   /* Leave the boolean fields at the end.  */\n \n   /* True if arbitrary sections are supported.  */\n@@ -671,6 +677,11 @@ struct gcc_target\n      synchronization is explicitly requested.  */\n   bool relaxed_ordering;\n \n+  /* Returns true if we should generate exception tables for use with the\n+     ARM EABI.  The effects the encoding of function exception specifications.\n+   */\n+  bool arm_eabi_unwinder;\n+\n   /* Leave the boolean fields at the end.  */\n };\n "}, {"sha": "6fb66e0b7382c19bf40515fb0b7ee31965c14c57", "filename": "gcc/unwind-c.c", "status": "modified", "additions": 41, "deletions": 5, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617a1b714435a270ccf699c4c6e17767088e2242/gcc%2Funwind-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617a1b714435a270ccf699c4c6e17767088e2242/gcc%2Funwind-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funwind-c.c?ref=617a1b714435a270ccf699c4c6e17767088e2242", "patch": "@@ -81,13 +81,37 @@ parse_lsda_header (struct _Unwind_Context *context, const unsigned char *p,\n   return p;\n }\n \n+#ifdef __ARM_EABI_UNWINDER__\n+/* ARM EABI personality routines must also unwind the stack.  */\n+#define CONTINUE_UNWINDING \\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      if (__gnu_unwind_frame (ue_header, context) != _URC_OK)\t\\\n+\treturn _URC_FAILURE;\t\t\t\t\t\\\n+      return _URC_CONTINUE_UNWIND;\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n+#else\n+#define CONTINUE_UNWINDING return _URC_CONTINUE_UNWIND\n+#endif\n+\n #ifdef __USING_SJLJ_EXCEPTIONS__\n #define PERSONALITY_FUNCTION    __gcc_personality_sj0\n #define __builtin_eh_return_data_regno(x) x\n #else\n #define PERSONALITY_FUNCTION    __gcc_personality_v0\n #endif\n \n+#ifdef __ARM_EABI_UNWINDER__\n+_Unwind_Reason_Code\n+PERSONALITY_FUNCTION (_Unwind_State, struct _Unwind_Exception *,\n+\t\t      struct _Unwind_Context *);\n+\n+_Unwind_Reason_Code\n+PERSONALITY_FUNCTION (_Unwind_State state,\n+\t\t      struct _Unwind_Exception * ue_header,\n+\t\t      struct _Unwind_Context * context)\n+#else\n _Unwind_Reason_Code\n PERSONALITY_FUNCTION (int, _Unwind_Action, _Unwind_Exception_Class,\n \t\t      struct _Unwind_Exception *, struct _Unwind_Context *);\n@@ -98,24 +122,37 @@ PERSONALITY_FUNCTION (int version,\n \t\t      _Unwind_Exception_Class exception_class ATTRIBUTE_UNUSED,\n \t\t      struct _Unwind_Exception *ue_header,\n \t\t      struct _Unwind_Context *context)\n+#endif\n {\n   lsda_header_info info;\n   const unsigned char *language_specific_data, *p, *action_record;\n   _Unwind_Ptr landing_pad, ip;\n \n+#ifdef __ARM_EABI_UNWINDER__\n+  if (state != _US_UNWIND_FRAME_STARTING)\n+    CONTINUE_UNWINDING;\n+\n+  /* The dwarf unwinder assumes the context structure holds things like the\n+     function and LSDA pointers.  The ARM implementation caches these in\n+     the exception header (UCB).  To avoid rewriting everything we make the\n+     virtual IP register point at the UCB.  */\n+  ip = (_Unwind_Ptr) ue_header;\n+  _Unwind_SetGR (context, 12, ip);\n+#else\n   if (version != 1)\n     return _URC_FATAL_PHASE1_ERROR;\n \n   /* Currently we only support cleanups for C.  */\n   if ((actions & _UA_CLEANUP_PHASE) == 0)\n-    return _URC_CONTINUE_UNWIND;\n+    CONTINUE_UNWINDING;\n+#endif\n \n   language_specific_data = (const unsigned char *)\n     _Unwind_GetLanguageSpecificData (context);\n \n   /* If no LSDA, then there are no handlers or cleanups.  */\n   if (! language_specific_data)\n-    return _URC_CONTINUE_UNWIND;\n+    CONTINUE_UNWINDING;\n \n   /* Parse the LSDA header.  */\n   p = parse_lsda_header (context, language_specific_data, &info);\n@@ -171,20 +208,19 @@ PERSONALITY_FUNCTION (int version,\n \t  goto found_something;\n \t}\n     }\n-  \n #endif\n \n   /* IP is not in table.  No associated cleanups.  */\n   /* ??? This is where C++ calls std::terminate to catch throw\n      from a destructor.  */\n-  return _URC_CONTINUE_UNWIND;\n+  CONTINUE_UNWINDING;\n \n  found_something:\n   if (landing_pad == 0)\n     {\n       /* IP is present, but has a null landing pad.\n \t No handler to be run.  */\n-      return _URC_CONTINUE_UNWIND;\n+      CONTINUE_UNWINDING;\n     }\n \n   _Unwind_SetGR (context, __builtin_eh_return_data_regno (0),"}, {"sha": "c46431fbdd3ec98b5f7f958a89d757944fde562a", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617a1b714435a270ccf699c4c6e17767088e2242/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617a1b714435a270ccf699c4c6e17767088e2242/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=617a1b714435a270ccf699c4c6e17767088e2242", "patch": "@@ -1,3 +1,47 @@\n+2005-06-28  Paul Brook  <paul@codesourcery.com>\n+\n+\t* acinclude.m4 (GLIBCXX_ENABLE_SJLJ_EXCEPTIONS): Check for\n+\t__cxa_end_cleanup.\n+\t* libsupc++/Makefile.am (sources): Add eh_call.c and eh_arm.c.\n+\t* libsupc++/eh_arm.cc: New file.\n+\t* libsupc++/eh_call.cc: New file.\n+\t* libsupc++/eh_catch.cc (__cxa_get_exception_ptr): Use\n+\t__gxx_caught_object.\n+\t(__cxa_begin_catch): Ditto. Use __is_gxx_exception_class. Call\n+\t_Unwind_Complete when using the ARM EABI.\n+\t(__cxa_end_catch): Use __is_gxx_exception_class.\n+\t* libsupc++/eh_personality.cc: Define NO_SIZE_OF_ENCODED_VALUE when\n+\tusing the ARM EABI.\n+\t(save_caught_exception, restore_caught_exception): New functions.\n+\t(_throw_typet): New typedef.\n+\t(get_ttype_entry, get_adjusted_ptr, check_exception_spec): Add ARM\n+\tEABI implementations.\n+\t(PERSONALITY_FUNCTION): Use new functions.  Addd support for ARM EABI\n+\tunwinding libary.\n+\t(__cxa_unexpected): Disable when using the ARM EABI.\n+\t* libsupc++/eh_throw.cc (__cxa_throw): Use __GXX_INIT_EXCEPTION_CLASS.\n+\t(__cxa_rethrow): Use __is_gxx_exception_class.  Call\n+\t_Unwind_RaiseException when using the ARM EABI.\n+\t* libsupc++/unwind-cxx.h (struct __cxa_exception): Add fields for ARM\n+\tEABI semantics.\n+\t(struct __cxa_eh_globals): Ditto.\n+\t(__cxa_call_terminate): Add prototype.\n+\t(__cxa_type_match, __cxa_begin_cleanup, __cxa_end_cleanup): Add\n+\tprototypes.\n+\t(__get_exception_header_from_obj, __get_exception_header_from_ue):\n+\tMove earlier in file.\n+\t(__is_gxx_exception_class, __GXX_INIT_EXCEPTION_CLASS,\n+\t__gxx_caught_object): New functions.\n+\t* aclocal.m4: Regenerate.\n+\t* configure: Regenerate.\n+\t* Makefile.in: Regenerate.\n+\t* include/Makefile.in: Regenerate.\n+\t* libmath/Makefile.in: Regenerate.\n+\t* libsupc++/Makefile.in: Regenerate.\n+\t* po/Makefile.in: Regenerate.\n+\t* src/Makefie.in: Regenerate.\n+\t* testsuite/makefile.in: Regenerate.\n+\n 2005-06-27  Paolo Carlini  <pcarlini@suse.de>\n \n \tPR libstdc++/22102"}, {"sha": "f2da8e9acf7aba648881b958fc9bb23759a032ba", "filename": "libstdc++-v3/Makefile.in", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617a1b714435a270ccf699c4c6e17767088e2242/libstdc%2B%2B-v3%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617a1b714435a270ccf699c4c6e17767088e2242/libstdc%2B%2B-v3%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FMakefile.in?ref=617a1b714435a270ccf699c4c6e17767088e2242", "patch": "@@ -1,8 +1,8 @@\n-# Makefile.in generated by automake 1.9.3 from Makefile.am.\n+# Makefile.in generated by automake 1.9.5 from Makefile.am.\n # @configure_input@\n \n # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,\n-# 2003, 2004  Free Software Foundation, Inc.\n+# 2003, 2004, 2005  Free Software Foundation, Inc.\n # This Makefile.in is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n # with or without modifications, as long as this notice is preserved.\n@@ -408,7 +408,13 @@ uninstall-info-am:\n #     (which will cause the Makefiles to be regenerated when you run `make');\n # (2) otherwise, pass the desired values on the `make' command line.\n $(RECURSIVE_TARGETS):\n-\t@set fnord $$MAKEFLAGS; amf=$$2; \\\n+\t@failcom='exit 1'; \\\n+\tfor f in x $$MAKEFLAGS; do \\\n+\t  case $$f in \\\n+\t    *=* | --[!k]*);; \\\n+\t    *k*) failcom='fail=yes';; \\\n+\t  esac; \\\n+\tdone; \\\n \tdot_seen=no; \\\n \ttarget=`echo $@ | sed s/-recursive//`; \\\n \tlist='$(SUBDIRS)'; for subdir in $$list; do \\\n@@ -420,15 +426,21 @@ $(RECURSIVE_TARGETS):\n \t    local_target=\"$$target\"; \\\n \t  fi; \\\n \t  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \\\n-\t   || case \"$$amf\" in *=*) exit 1;; *k*) fail=yes;; *) exit 1;; esac; \\\n+\t  || eval $$failcom; \\\n \tdone; \\\n \tif test \"$$dot_seen\" = \"no\"; then \\\n \t  $(MAKE) $(AM_MAKEFLAGS) \"$$target-am\" || exit 1; \\\n \tfi; test -z \"$$fail\"\n \n mostlyclean-recursive clean-recursive distclean-recursive \\\n maintainer-clean-recursive:\n-\t@set fnord $$MAKEFLAGS; amf=$$2; \\\n+\t@failcom='exit 1'; \\\n+\tfor f in x $$MAKEFLAGS; do \\\n+\t  case $$f in \\\n+\t    *=* | --[!k]*);; \\\n+\t    *k*) failcom='fail=yes';; \\\n+\t  esac; \\\n+\tdone; \\\n \tdot_seen=no; \\\n \tcase \"$@\" in \\\n \t  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \\\n@@ -449,7 +461,7 @@ maintainer-clean-recursive:\n \t    local_target=\"$$target\"; \\\n \t  fi; \\\n \t  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \\\n-\t   || case \"$$amf\" in *=*) exit 1;; *k*) fail=yes;; *) exit 1;; esac; \\\n+\t  || eval $$failcom; \\\n \tdone && test -z \"$$fail\"\n tags-recursive:\n \tlist='$(SUBDIRS)'; for subdir in $$list; do \\"}, {"sha": "d3156f2b2c434f19998cb182f5e5d76405545a66", "filename": "libstdc++-v3/acinclude.m4", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617a1b714435a270ccf699c4c6e17767088e2242/libstdc%2B%2B-v3%2Facinclude.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617a1b714435a270ccf699c4c6e17767088e2242/libstdc%2B%2B-v3%2Facinclude.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Facinclude.m4?ref=617a1b714435a270ccf699c4c6e17767088e2242", "patch": "@@ -1626,6 +1626,8 @@ EOF\n         enable_sjlj_exceptions=yes\n       elif grep _Unwind_Resume conftest.s >/dev/null 2>&1 ; then\n         enable_sjlj_exceptions=no\n+      elif grep __cxa_end_cleanup conftest.s >/dev/null 2>&1 ; then\n+        enable_sjlj_exceptions=no\n       fi\n     fi\n     CXXFLAGS=\"$old_CXXFLAGS\""}, {"sha": "79d81ccfab27e6c7cb2d8cc42e402a103bed4839", "filename": "libstdc++-v3/aclocal.m4", "status": "modified", "additions": 88, "deletions": 222, "changes": 310, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617a1b714435a270ccf699c4c6e17767088e2242/libstdc%2B%2B-v3%2Faclocal.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617a1b714435a270ccf699c4c6e17767088e2242/libstdc%2B%2B-v3%2Faclocal.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Faclocal.m4?ref=617a1b714435a270ccf699c4c6e17767088e2242", "patch": "@@ -1,7 +1,7 @@\n-# generated automatically by aclocal 1.9.3 -*- Autoconf -*-\n+# generated automatically by aclocal 1.9.5 -*- Autoconf -*-\n \n-# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004\n-# Free Software Foundation, Inc.\n+# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,\n+# 2005  Free Software Foundation, Inc.\n # This file is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n # with or without modifications, as long as this notice is preserved.\n@@ -11,23 +11,11 @@\n # even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n # PARTICULAR PURPOSE.\n \n-#                                                        -*- Autoconf -*-\n-# Copyright (C) 2002, 2003  Free Software Foundation, Inc.\n-# Generated from amversion.in; do not edit by hand.\n-\n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 2, or (at your option)\n-# any later version.\n-\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-\n-# You should have received a copy of the GNU General Public License\n-# along with this program; if not, write to the Free Software\n-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\n+# Copyright (C) 2002, 2003, 2005  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n \n # AM_AUTOMAKE_VERSION(VERSION)\n # ----------------------------\n@@ -40,26 +28,15 @@ AC_DEFUN([AM_AUTOMAKE_VERSION], [am__api_version=\"1.9\"])\n # Call AM_AUTOMAKE_VERSION so it can be traced.\n # This function is AC_REQUIREd by AC_INIT_AUTOMAKE.\n AC_DEFUN([AM_SET_CURRENT_AUTOMAKE_VERSION],\n-\t [AM_AUTOMAKE_VERSION([1.9.3])])\n-\n-# AM_AUX_DIR_EXPAND\n-\n-# Copyright (C) 2001, 2003 Free Software Foundation, Inc.\n-\n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 2, or (at your option)\n-# any later version.\n+\t [AM_AUTOMAKE_VERSION([1.9.5])])\n \n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n+# AM_AUX_DIR_EXPAND                                         -*- Autoconf -*-\n \n-# You should have received a copy of the GNU General Public License\n-# along with this program; if not, write to the Free Software\n-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\n-# 02111-1307, USA.\n+# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n \n # For projects using AC_CONFIG_AUX_DIR([foo]), Autoconf sets\n # $ac_aux_dir to `$srcdir/foo'.  In other projects, it is set to\n@@ -106,26 +83,16 @@ AC_PREREQ([2.50])dnl\n am_aux_dir=`cd $ac_aux_dir && pwd`\n ])\n \n-# AM_CONDITIONAL                                              -*- Autoconf -*-\n-\n-# Copyright (C) 1997, 2000, 2001, 2003, 2004 Free Software Foundation, Inc.\n-\n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 2, or (at your option)\n-# any later version.\n-\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n+# AM_CONDITIONAL                                            -*- Autoconf -*-\n \n-# You should have received a copy of the GNU General Public License\n-# along with this program; if not, write to the Free Software\n-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\n-# 02111-1307, USA.\n+# Copyright (C) 1997, 2000, 2001, 2003, 2004, 2005\n+# Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n \n-# serial 6\n+# serial 7\n \n # AM_CONDITIONAL(NAME, SHELL-CONDITION)\n # -------------------------------------\n@@ -149,30 +116,19 @@ AC_CONFIG_COMMANDS_PRE(\n Usually this means the macro was only invoked conditionally.]])\n fi])])\n \n-# Do all the work for Automake.                            -*- Autoconf -*-\n-\n-# This macro actually does too much some checks are only needed if\n-# your package does certain things.  But this isn't really a big deal.\n+# Do all the work for Automake.                             -*- Autoconf -*-\n \n-# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004\n+# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005\n # Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n \n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 2, or (at your option)\n-# any later version.\n-\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-\n-# You should have received a copy of the GNU General Public License\n-# along with this program; if not, write to the Free Software\n-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\n-# 02111-1307, USA.\n+# serial 12\n \n-# serial 11\n+# This macro actually does too much.  Some checks are only needed if\n+# your package does certain things.  But this isn't really a big deal.\n \n # AM_INIT_AUTOMAKE(PACKAGE, VERSION, [NO-DEFINE])\n # AM_INIT_AUTOMAKE([OPTIONS])\n@@ -300,28 +256,17 @@ AC_DEFUN([AM_PROG_INSTALL_SH],\n install_sh=${install_sh-\"$am_aux_dir/install-sh\"}\n AC_SUBST(install_sh)])\n \n-# Add --enable-maintainer-mode option to configure.\n+# Add --enable-maintainer-mode option to configure.         -*- Autoconf -*-\n # From Jim Meyering\n \n-# Copyright (C) 1996, 1998, 2000, 2001, 2002, 2003, 2004\n+# Copyright (C) 1996, 1998, 2000, 2001, 2002, 2003, 2004, 2005\n # Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n \n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 2, or (at your option)\n-# any later version.\n-\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-\n-# You should have received a copy of the GNU General Public License\n-# along with this program; if not, write to the Free Software\n-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\n-# 02111-1307, USA.\n-\n-# serial 3\n+# serial 4\n \n AC_DEFUN([AM_MAINTAINER_MODE],\n [AC_MSG_CHECKING([whether to enable maintainer-specific portions of Makefiles])\n@@ -340,27 +285,16 @@ AC_DEFUN([AM_MAINTAINER_MODE],\n \n AU_DEFUN([jm_MAINTAINER_MODE], [AM_MAINTAINER_MODE])\n \n-#  -*- Autoconf -*-\n-\n-\n-# Copyright (C) 1997, 1999, 2000, 2001, 2003 Free Software Foundation, Inc.\n-\n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 2, or (at your option)\n-# any later version.\n-\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n+# Fake the existence of programs that GNU maintainers use.  -*- Autoconf -*-\n \n-# You should have received a copy of the GNU General Public License\n-# along with this program; if not, write to the Free Software\n-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\n-# 02111-1307, USA.\n+# Copyright (C) 1997, 1999, 2000, 2001, 2003, 2005\n+# Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n \n-# serial 3\n+# serial 4\n \n # AM_MISSING_PROG(NAME, PROGRAM)\n # ------------------------------\n@@ -386,27 +320,16 @@ else\n fi\n ])\n \n+# Copyright (C) 2003, 2004, 2005  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n # AM_PROG_MKDIR_P\n # ---------------\n # Check whether `mkdir -p' is supported, fallback to mkinstalldirs otherwise.\n-\n-# Copyright (C) 2003, 2004 Free Software Foundation, Inc.\n-\n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 2, or (at your option)\n-# any later version.\n-\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-\n-# You should have received a copy of the GNU General Public License\n-# along with this program; if not, write to the Free Software\n-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\n-# 02111-1307, USA.\n-\n+#\n # Automake 1.8 used `mkdir -m 0755 -p --' to ensure that directories\n # created by `make install' are always world readable, even if the\n # installer happens to have an overly restrictive umask (e.g. 077).\n@@ -460,25 +383,14 @@ else\n fi\n AC_SUBST([mkdir_p])])\n \n-# Copyright (C) 1998, 1999, 2000, 2001, 2003, 2004\n+# Copyright (C) 1998, 1999, 2000, 2001, 2003, 2004, 2005\n # Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n \n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 2, or (at your option)\n-# any later version.\n-\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-\n-# You should have received a copy of the GNU General Public License\n-# along with this program; if not, write to the Free Software\n-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\n-# 02111-1307, USA.\n-\n-# serial 4\n+# serial 5\n \n # AM_ENABLE_MULTILIB([MAKEFILE], [REL-TO-TOP-SRCDIR])\n # ---------------------------------------------------\n@@ -529,26 +441,15 @@ multi_basedir=\"$multi_basedir\"\n CONFIG_SHELL=${CONFIG_SHELL-/bin/sh}\n CC=\"$CC\"])])dnl\n \n-# Helper functions for option handling.                    -*- Autoconf -*-\n-\n-# Copyright (C) 2001, 2002, 2003  Free Software Foundation, Inc.\n-\n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 2, or (at your option)\n-# any later version.\n-\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n+# Helper functions for option handling.                     -*- Autoconf -*-\n \n-# You should have received a copy of the GNU General Public License\n-# along with this program; if not, write to the Free Software\n-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\n-# 02111-1307, USA.\n+# Copyright (C) 2001, 2002, 2003, 2005  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n \n-# serial 2\n+# serial 3\n \n # _AM_MANGLE_OPTION(NAME)\n # -----------------------\n@@ -573,28 +474,16 @@ AC_DEFUN([_AM_SET_OPTIONS],\n AC_DEFUN([_AM_IF_OPTION],\n [m4_ifset(_AM_MANGLE_OPTION([$1]), [$2], [$3])])\n \n-#\n-# Check to make sure that the build environment is sane.\n-#\n-\n-# Copyright (C) 1996, 1997, 2000, 2001, 2003 Free Software Foundation, Inc.\n-\n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 2, or (at your option)\n-# any later version.\n-\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n+# Check to make sure that the build environment is sane.    -*- Autoconf -*-\n \n-# You should have received a copy of the GNU General Public License\n-# along with this program; if not, write to the Free Software\n-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\n-# 02111-1307, USA.\n+# Copyright (C) 1996, 1997, 2000, 2001, 2003, 2005\n+# Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n \n-# serial 3\n+# serial 4\n \n # AM_SANITY_CHECK\n # ---------------\n@@ -637,25 +526,14 @@ Check your system clock])\n fi\n AC_MSG_RESULT(yes)])\n \n-# AM_PROG_INSTALL_STRIP\n-\n-# Copyright (C) 2001, 2003 Free Software Foundation, Inc.\n-\n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 2, or (at your option)\n-# any later version.\n-\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-\n-# You should have received a copy of the GNU General Public License\n-# along with this program; if not, write to the Free Software\n-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\n-# 02111-1307, USA.\n+# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n \n+# AM_PROG_INSTALL_STRIP\n+# ---------------------\n # One issue with vendor `install' (even GNU) is that you can't\n # specify the program used to strip binaries.  This is especially\n # annoying in cross-compiling environments, where the build's strip\n@@ -678,25 +556,13 @@ AC_SUBST([INSTALL_STRIP_PROGRAM])])\n \n # Check how to create a tarball.                            -*- Autoconf -*-\n \n-# Copyright (C) 2004  Free Software Foundation, Inc.\n-\n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 2, or (at your option)\n-# any later version.\n-\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-\n-# You should have received a copy of the GNU General Public License\n-# along with this program; if not, write to the Free Software\n-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\n-# 02111-1307, USA.\n-\n-# serial 1\n+# Copyright (C) 2004, 2005  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n \n+# serial 2\n \n # _AM_PROG_TAR(FORMAT)\n # --------------------"}, {"sha": "b679737757c2795267d3b78164e1f7b22b8deb46", "filename": "libstdc++-v3/configure", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617a1b714435a270ccf699c4c6e17767088e2242/libstdc%2B%2B-v3%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617a1b714435a270ccf699c4c6e17767088e2242/libstdc%2B%2B-v3%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfigure?ref=617a1b714435a270ccf699c4c6e17767088e2242", "patch": "@@ -5079,6 +5079,8 @@ EOF\n         enable_sjlj_exceptions=yes\n       elif grep _Unwind_Resume conftest.s >/dev/null 2>&1 ; then\n         enable_sjlj_exceptions=no\n+      elif grep __cxa_end_cleanup conftest.s >/dev/null 2>&1 ; then\n+        enable_sjlj_exceptions=no\n       fi\n     fi\n     CXXFLAGS=\"$old_CXXFLAGS\""}, {"sha": "f075d3e16c0999802a903161139736966975d6e6", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617a1b714435a270ccf699c4c6e17767088e2242/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617a1b714435a270ccf699c4c6e17767088e2242/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=617a1b714435a270ccf699c4c6e17767088e2242", "patch": "@@ -1,8 +1,8 @@\n-# Makefile.in generated by automake 1.9.3 from Makefile.am.\n+# Makefile.in generated by automake 1.9.5 from Makefile.am.\n # @configure_input@\n \n # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,\n-# 2003, 2004  Free Software Foundation, Inc.\n+# 2003, 2004, 2005  Free Software Foundation, Inc.\n # This Makefile.in is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n # with or without modifications, as long as this notice is preserved."}, {"sha": "3f0cf27e997089c3be1f5d1cf9645cb91cab6b3e", "filename": "libstdc++-v3/libmath/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617a1b714435a270ccf699c4c6e17767088e2242/libstdc%2B%2B-v3%2Flibmath%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617a1b714435a270ccf699c4c6e17767088e2242/libstdc%2B%2B-v3%2Flibmath%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibmath%2FMakefile.in?ref=617a1b714435a270ccf699c4c6e17767088e2242", "patch": "@@ -1,8 +1,8 @@\n-# Makefile.in generated by automake 1.9.3 from Makefile.am.\n+# Makefile.in generated by automake 1.9.5 from Makefile.am.\n # @configure_input@\n \n # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,\n-# 2003, 2004  Free Software Foundation, Inc.\n+# 2003, 2004, 2005  Free Software Foundation, Inc.\n # This Makefile.in is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n # with or without modifications, as long as this notice is preserved."}, {"sha": "c67c294fca07c4cac2a1de7dc020b5171ec51014", "filename": "libstdc++-v3/libsupc++/Makefile.am", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617a1b714435a270ccf699c4c6e17767088e2242/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617a1b714435a270ccf699c4c6e17767088e2242/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.am?ref=617a1b714435a270ccf699c4c6e17767088e2242", "patch": "@@ -45,7 +45,9 @@ sources = \\\n \tdel_opv.cc \\\n \tdel_opvnt.cc \\\n \teh_alloc.cc \\\n+\teh_arm.cc \\\n \teh_aux_runtime.cc \\\n+\teh_call.cc \\\n \teh_catch.cc \\\n \teh_exception.cc \\\n \teh_globals.cc \\"}, {"sha": "4c0650ec91d2c05811fba23929f444c6de157cc4", "filename": "libstdc++-v3/libsupc++/Makefile.in", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617a1b714435a270ccf699c4c6e17767088e2242/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617a1b714435a270ccf699c4c6e17767088e2242/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.in?ref=617a1b714435a270ccf699c4c6e17767088e2242", "patch": "@@ -1,8 +1,8 @@\n-# Makefile.in generated by automake 1.9.3 from Makefile.am.\n+# Makefile.in generated by automake 1.9.5 from Makefile.am.\n # @configure_input@\n \n # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,\n-# 2003, 2004  Free Software Foundation, Inc.\n+# 2003, 2004, 2005  Free Software Foundation, Inc.\n # This Makefile.in is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n # with or without modifications, as long as this notice is preserved.\n@@ -65,29 +65,31 @@ toolexeclibLTLIBRARIES_INSTALL = $(INSTALL)\n LTLIBRARIES = $(noinst_LTLIBRARIES) $(toolexeclib_LTLIBRARIES)\n libsupc___la_LIBADD =\n am__libsupc___la_SOURCES_DIST = del_op.cc del_opnt.cc del_opv.cc \\\n-\tdel_opvnt.cc eh_alloc.cc eh_aux_runtime.cc eh_catch.cc \\\n-\teh_exception.cc eh_globals.cc eh_personality.cc \\\n-\teh_term_handler.cc eh_terminate.cc eh_throw.cc eh_type.cc \\\n-\teh_unex_handler.cc guard.cc new_handler.cc new_op.cc \\\n-\tnew_opnt.cc new_opv.cc new_opvnt.cc pure.cc tinfo.cc tinfo2.cc \\\n-\tvec.cc vterminate.cc cp-demangle.c\n+\tdel_opvnt.cc eh_alloc.cc eh_arm.cc eh_aux_runtime.cc \\\n+\teh_call.cc eh_catch.cc eh_exception.cc eh_globals.cc \\\n+\teh_personality.cc eh_term_handler.cc eh_terminate.cc \\\n+\teh_throw.cc eh_type.cc eh_unex_handler.cc guard.cc \\\n+\tnew_handler.cc new_op.cc new_opnt.cc new_opv.cc new_opvnt.cc \\\n+\tpure.cc tinfo.cc tinfo2.cc vec.cc vterminate.cc cp-demangle.c\n am__objects_1 = del_op.lo del_opnt.lo del_opv.lo del_opvnt.lo \\\n-\teh_alloc.lo eh_aux_runtime.lo eh_catch.lo eh_exception.lo \\\n-\teh_globals.lo eh_personality.lo eh_term_handler.lo \\\n-\teh_terminate.lo eh_throw.lo eh_type.lo eh_unex_handler.lo \\\n-\tguard.lo new_handler.lo new_op.lo new_opnt.lo new_opv.lo \\\n-\tnew_opvnt.lo pure.lo tinfo.lo tinfo2.lo vec.lo vterminate.lo\n+\teh_alloc.lo eh_arm.lo eh_aux_runtime.lo eh_call.lo eh_catch.lo \\\n+\teh_exception.lo eh_globals.lo eh_personality.lo \\\n+\teh_term_handler.lo eh_terminate.lo eh_throw.lo eh_type.lo \\\n+\teh_unex_handler.lo guard.lo new_handler.lo new_op.lo \\\n+\tnew_opnt.lo new_opv.lo new_opvnt.lo pure.lo tinfo.lo tinfo2.lo \\\n+\tvec.lo vterminate.lo\n @GLIBCXX_HOSTED_TRUE@am__objects_2 = cp-demangle.lo\n am_libsupc___la_OBJECTS = $(am__objects_1) $(am__objects_2)\n libsupc___la_OBJECTS = $(am_libsupc___la_OBJECTS)\n libsupc__convenience_la_LIBADD =\n am__libsupc__convenience_la_SOURCES_DIST = del_op.cc del_opnt.cc \\\n-\tdel_opv.cc del_opvnt.cc eh_alloc.cc eh_aux_runtime.cc \\\n-\teh_catch.cc eh_exception.cc eh_globals.cc eh_personality.cc \\\n-\teh_term_handler.cc eh_terminate.cc eh_throw.cc eh_type.cc \\\n-\teh_unex_handler.cc guard.cc new_handler.cc new_op.cc \\\n-\tnew_opnt.cc new_opv.cc new_opvnt.cc pure.cc tinfo.cc tinfo2.cc \\\n-\tvec.cc vterminate.cc cp-demangle.c\n+\tdel_opv.cc del_opvnt.cc eh_alloc.cc eh_arm.cc \\\n+\teh_aux_runtime.cc eh_call.cc eh_catch.cc eh_exception.cc \\\n+\teh_globals.cc eh_personality.cc eh_term_handler.cc \\\n+\teh_terminate.cc eh_throw.cc eh_type.cc eh_unex_handler.cc \\\n+\tguard.cc new_handler.cc new_op.cc new_opnt.cc new_opv.cc \\\n+\tnew_opvnt.cc pure.cc tinfo.cc tinfo2.cc vec.cc vterminate.cc \\\n+\tcp-demangle.c\n am_libsupc__convenience_la_OBJECTS = $(am__objects_1) $(am__objects_2)\n libsupc__convenience_la_OBJECTS =  \\\n \t$(am_libsupc__convenience_la_OBJECTS)\n@@ -309,7 +311,9 @@ sources = \\\n \tdel_opv.cc \\\n \tdel_opvnt.cc \\\n \teh_alloc.cc \\\n+\teh_arm.cc \\\n \teh_aux_runtime.cc \\\n+\teh_call.cc \\\n \teh_catch.cc \\\n \teh_exception.cc \\\n \teh_globals.cc \\"}, {"sha": "47b459638055e143642bf05d4e1707e2dd14bf2b", "filename": "libstdc++-v3/libsupc++/eh_catch.cc", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617a1b714435a270ccf699c4c6e17767088e2242/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_catch.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617a1b714435a270ccf699c4c6e17767088e2242/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_catch.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_catch.cc?ref=617a1b714435a270ccf699c4c6e17767088e2242", "patch": "@@ -38,9 +38,8 @@ __cxxabiv1::__cxa_get_exception_ptr(void *exc_obj_in) throw()\n {\n   _Unwind_Exception *exceptionObject\n     = reinterpret_cast <_Unwind_Exception *>(exc_obj_in);\n-  __cxa_exception *header = __get_exception_header_from_ue (exceptionObject);\n \n-  return header->adjustedPtr;\n+  return __gxx_caught_object(exceptionObject);\n }\n \n extern \"C\" void *\n@@ -51,12 +50,13 @@ __cxxabiv1::__cxa_begin_catch (void *exc_obj_in) throw()\n   __cxa_eh_globals *globals = __cxa_get_globals ();\n   __cxa_exception *prev = globals->caughtExceptions;\n   __cxa_exception *header = __get_exception_header_from_ue (exceptionObject);\n+  void* objectp;\n \n   // Foreign exceptions can't be stacked here.  If the exception stack is\n   // empty, then fine.  Otherwise we really have no choice but to terminate.\n   // Note that this use of \"header\" is a lie.  It's fine so long as we only\n   // examine header->unwindHeader though.\n-  if (header->unwindHeader.exception_class != __gxx_exception_class)\n+  if (!__is_gxx_exception_class(header->unwindHeader.exception_class))\n     {\n       if (prev != 0)\n \tstd::terminate ();\n@@ -85,7 +85,11 @@ __cxxabiv1::__cxa_begin_catch (void *exc_obj_in) throw()\n       globals->caughtExceptions = header;\n     }\n \n-  return header->adjustedPtr;\n+  objectp = __gxx_caught_object(exceptionObject);\n+#ifdef __ARM_EABI_UNWINDER__\n+  _Unwind_Complete(exceptionObject);\n+#endif\n+  return objectp;\n }\n \n \n@@ -102,7 +106,7 @@ __cxxabiv1::__cxa_end_catch ()\n \n   // A foreign exception couldn't have been stacked (see above),\n   // so by definition processing must be complete.\n-  if (header->unwindHeader.exception_class != __gxx_exception_class)\n+  if (!__is_gxx_exception_class(header->unwindHeader.exception_class))\n     {\n       globals->caughtExceptions = 0;\n       _Unwind_DeleteException (&header->unwindHeader);"}, {"sha": "ecade83399f305644dfbfff07c0016fe586a5f22", "filename": "libstdc++-v3/libsupc++/eh_personality.cc", "status": "modified", "additions": 263, "deletions": 30, "changes": 293, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617a1b714435a270ccf699c4c6e17767088e2242/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_personality.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617a1b714435a270ccf699c4c6e17767088e2242/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_personality.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_personality.cc?ref=617a1b714435a270ccf699c4c6e17767088e2242", "patch": "@@ -35,6 +35,10 @@\n \n using namespace __cxxabiv1;\n \n+#ifdef __ARM_EABI_UNWINDER__\n+#define NO_SIZE_OF_ENCODED_VALUE\n+#endif\n+\n #include \"unwind-pe.h\"\n \n \f\n@@ -84,6 +88,117 @@ parse_lsda_header (_Unwind_Context *context, const unsigned char *p,\n   return p;\n }\n \n+#ifdef __ARM_EABI_UNWINDER__\n+\n+// Return an element from a type table.\n+\n+static const std::type_info*\n+get_ttype_entry(lsda_header_info* info, _Unwind_Word i)\n+{\n+  _Unwind_Ptr ptr;\n+\n+  ptr = (_Unwind_Ptr) (info->TType - (i * 4));\n+  ptr = _Unwind_decode_target2(ptr);\n+  \n+  return reinterpret_cast<const std::type_info *>(ptr);\n+}\n+\n+// The ABI provides a routine for matching exception object types.\n+typedef _Unwind_Control_Block _throw_typet;\n+#define get_adjusted_ptr(catch_type, throw_type, thrown_ptr_p) \\\n+  (__cxa_type_match (throw_type, catch_type, false, thrown_ptr_p) \\\n+   != ctm_failed)\n+\n+// Return true if THROW_TYPE matches one if the filter types.\n+\n+static bool\n+check_exception_spec(lsda_header_info* info, _throw_typet* throw_type,\n+\t\t     void* thrown_ptr, _Unwind_Sword filter_value)\n+{\n+  const _Unwind_Word* e = ((const _Unwind_Word*) info->TType)\n+\t\t\t  - filter_value - 1;\n+\n+  while (1)\n+    {\n+      const std::type_info* catch_type;\n+      _Unwind_Word tmp;\n+\n+      tmp = *e;\n+      \n+      // Zero signals the end of the list.  If we've not found\n+      // a match by now, then we've failed the specification.\n+      if (tmp == 0)\n+        return false;\n+\n+      tmp = _Unwind_decode_target2((_Unwind_Word) e);\n+\n+      // Match a ttype entry.\n+      catch_type = reinterpret_cast<const std::type_info*>(tmp);\n+\n+      // ??? There is currently no way to ask the RTTI code about the\n+      // relationship between two types without reference to a specific\n+      // object.  There should be; then we wouldn't need to mess with\n+      // thrown_ptr here.\n+      if (get_adjusted_ptr(catch_type, throw_type, &thrown_ptr))\n+\treturn true;\n+\n+      // Advance to the next entry.\n+      e++;\n+    }\n+}\n+\n+\n+// Save stage1 handler information in the exception object\n+\n+static inline void\n+save_caught_exception(struct _Unwind_Exception* ue_header,\n+\t\t      struct _Unwind_Context* context,\n+\t\t      void* thrown_ptr,\n+\t\t      int handler_switch_value,\n+\t\t      const unsigned char* language_specific_data,\n+\t\t      _Unwind_Ptr landing_pad,\n+\t\t      const unsigned char* action_record\n+\t\t\t__attribute__((__unused__)))\n+{\n+    ue_header->barrier_cache.sp = _Unwind_GetGR(context, 13);\n+    ue_header->barrier_cache.bitpattern[0] = (_uw) thrown_ptr;\n+    ue_header->barrier_cache.bitpattern[1]\n+      = (_uw) handler_switch_value;\n+    ue_header->barrier_cache.bitpattern[2]\n+      = (_uw) language_specific_data;\n+    ue_header->barrier_cache.bitpattern[3] = (_uw) landing_pad;\n+}\n+\n+\n+// Restore the catch handler data saved during phase1.\n+\n+static inline void\n+restore_caught_exception(struct _Unwind_Exception* ue_header,\n+\t\t\t int& handler_switch_value,\n+\t\t\t const unsigned char*& language_specific_data,\n+\t\t\t _Unwind_Ptr& landing_pad)\n+{\n+  handler_switch_value = (int) ue_header->barrier_cache.bitpattern[1];\n+  language_specific_data =\n+    (const unsigned char*) ue_header->barrier_cache.bitpattern[2];\n+  landing_pad = (_Unwind_Ptr) ue_header->barrier_cache.bitpattern[3];\n+}\n+\n+#define CONTINUE_UNWINDING \\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      if (__gnu_unwind_frame(ue_header, context) != _URC_OK)\t\\\n+\treturn _URC_FAILURE;\t\t\t\t\t\\\n+      return _URC_CONTINUE_UNWIND;\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+#else\n+typedef const std::type_info _throw_typet;\n+\n+\n+// Return an element from a type table.\n+\n static const std::type_info *\n get_ttype_entry (lsda_header_info *info, _Unwind_Word i)\n {\n@@ -127,8 +242,8 @@ get_adjusted_ptr (const std::type_info *catch_type,\n // Return true if THROW_TYPE matches one if the filter types.\n \n static bool\n-check_exception_spec (lsda_header_info *info, const std::type_info *throw_type,\n-\t\t      void *thrown_ptr, _Unwind_Sword filter_value)\n+check_exception_spec(lsda_header_info* info, _throw_typet* throw_type,\n+\t\t      void* thrown_ptr, _Unwind_Sword filter_value)\n {\n   const unsigned char *e = info->TType - filter_value - 1;\n \n@@ -156,6 +271,50 @@ check_exception_spec (lsda_header_info *info, const std::type_info *throw_type,\n     }\n }\n \n+\n+// Save stage1 handler information in the exception object\n+\n+static inline void\n+save_caught_exception(struct _Unwind_Exception* ue_header,\n+\t\t      struct _Unwind_Context* context\n+\t\t\t__attribute__((__unused__)),\n+\t\t      void* thrown_ptr,\n+\t\t      int handler_switch_value,\n+\t\t      const unsigned char* language_specific_data,\n+\t\t      _Unwind_Ptr landing_pad __attribute__((__unused__)),\n+\t\t      const unsigned char* action_record)\n+{\n+  __cxa_exception* xh = __get_exception_header_from_ue(ue_header);\n+\n+  xh->handlerSwitchValue = handler_switch_value;\n+  xh->actionRecord = action_record;\n+  xh->languageSpecificData = language_specific_data;\n+  xh->adjustedPtr = thrown_ptr;\n+\n+  // ??? Completely unknown what this field is supposed to be for.\n+  // ??? Need to cache TType encoding base for call_unexpected.\n+  xh->catchTemp = landing_pad;\n+}\n+\n+\n+// Restore the catch handler information saved during phase1.\n+\n+static inline void\n+restore_caught_exception(struct _Unwind_Exception* ue_header,\n+\t\t\t int& handler_switch_value,\n+\t\t\t const unsigned char*& language_specific_data,\n+\t\t\t _Unwind_Ptr& landing_pad)\n+{\n+  __cxa_exception* xh = __get_exception_header_from_ue(ue_header);\n+  handler_switch_value = xh->handlerSwitchValue;\n+  language_specific_data = xh->languageSpecificData;\n+  landing_pad = (_Unwind_Ptr) xh->catchTemp;\n+}\n+\n+#define CONTINUE_UNWINDING return _URC_CONTINUE_UNWIND\n+\n+#endif // !__ARM_EABI_UNWINDER__\n+\n // Return true if the filter spec is empty, ie throw().\n \n static bool\n@@ -178,14 +337,18 @@ empty_exception_spec (lsda_header_info *info, _Unwind_Sword filter_value)\n #endif\n \n extern \"C\" _Unwind_Reason_Code\n+#ifdef __ARM_EABI_UNWINDER__\n+PERSONALITY_FUNCTION (_Unwind_State state,\n+\t\t      struct _Unwind_Exception* ue_header,\n+\t\t      struct _Unwind_Context* context)\n+#else\n PERSONALITY_FUNCTION (int version,\n \t\t      _Unwind_Action actions,\n \t\t      _Unwind_Exception_Class exception_class,\n \t\t      struct _Unwind_Exception *ue_header,\n \t\t      struct _Unwind_Context *context)\n+#endif\n {\n-  __cxa_exception *xh = __get_exception_header_from_ue (ue_header);\n-\n   enum found_handler_type\n   {\n     found_nothing,\n@@ -200,19 +363,58 @@ PERSONALITY_FUNCTION (int version,\n   const unsigned char *p;\n   _Unwind_Ptr landing_pad, ip;\n   int handler_switch_value;\n-  void *thrown_ptr = xh + 1;\n+  void* thrown_ptr = ue_header + 1;\n+  bool foreign_exception;\n+\n+#ifdef __ARM_EABI_UNWINDER__\n+  _Unwind_Action actions;\n+\n+  switch (state)\n+    {\n+    case _US_VIRTUAL_UNWIND_FRAME:\n+      actions = _UA_SEARCH_PHASE;\n+      break;\n+\n+    case _US_UNWIND_FRAME_STARTING:\n+      actions = _UA_CLEANUP_PHASE;\n+      if (ue_header->barrier_cache.sp == _Unwind_GetGR(context, 13))\n+\tactions |= _UA_HANDLER_FRAME;\n+      break;\n+\n+    case _US_UNWIND_FRAME_RESUME:\n+      CONTINUE_UNWINDING;\n+      break;\n+\n+    default:\n+      abort();\n+    }\n+\n+  // We don't know which runtime we're working with, so can't check this.\n+  // However the ABI routines hide this from us, and we don't actually need\n+  // to know.\n+  foreign_exception = false;\n+\n+  // The dwarf unwinder assumes the context structure holds things like the\n+  // function and LSDA pointers.  The ARM implementation caches these in\n+  // the exception header (UCB).  To avoid rewriting everything we make the\n+  // virtual IP register point at the UCB.\n+  ip = (_Unwind_Ptr) ue_header;\n+  _Unwind_SetGR(context, 12, ip);\n+#else\n+  __cxa_exception* xh = __get_exception_header_from_ue(ue_header);\n \n   // Interface version check.\n   if (version != 1)\n     return _URC_FATAL_PHASE1_ERROR;\n+  foreign_exception = !__is_gxx_exception_class(exception_class);\n+#endif\n \n   // Shortcut for phase 2 found handler for domestic exception.\n   if (actions == (_UA_CLEANUP_PHASE | _UA_HANDLER_FRAME)\n-      && exception_class == __gxx_exception_class)\n+      && !foreign_exception)\n     {\n-      handler_switch_value = xh->handlerSwitchValue;\n-      language_specific_data = xh->languageSpecificData;\n-      landing_pad = (_Unwind_Ptr) xh->catchTemp;\n+      restore_caught_exception(ue_header, handler_switch_value,\n+\t\t\t       language_specific_data, landing_pad);\n       found_type = (landing_pad == 0 ? found_terminate : found_handler);\n       goto install_context;\n     }\n@@ -222,11 +424,11 @@ PERSONALITY_FUNCTION (int version,\n \n   // If no LSDA, then there are no handlers or cleanups.\n   if (! language_specific_data)\n-    return _URC_CONTINUE_UNWIND;\n+    CONTINUE_UNWINDING;\n \n   // Parse the LSDA header.\n   p = parse_lsda_header (context, language_specific_data, &info);\n-  info.ttype_base = base_of_encoded_value (info.ttype_encoding, context);\n+  info.ttype_base = 0;\n   ip = _Unwind_GetIP (context) - 1;\n   landing_pad = 0;\n   action_record = 0;\n@@ -312,19 +514,24 @@ PERSONALITY_FUNCTION (int version,\n       // Otherwise we have a catch handler or exception specification.\n \n       _Unwind_Sword ar_filter, ar_disp;\n-      const std::type_info *throw_type, *catch_type;\n+      const std::type_info* catch_type;\n+      _throw_typet* throw_type;\n       bool saw_cleanup = false;\n       bool saw_handler = false;\n \n       // During forced unwinding, we only run cleanups.  With a foreign\n       // exception class, there's no exception type.\n       // ??? What to do about GNU Java and GNU Ada exceptions.\n \n+#ifdef __ARM_EABI_UNWINDER__\n+      throw_type = ue_header;\n+#else\n       if ((actions & _UA_FORCE_UNWIND)\n-\t  || exception_class != __gxx_exception_class)\n+\t  || foreign_exception)\n \tthrow_type = 0;\n       else\n \tthrow_type = xh->exceptionType;\n+#endif\n \n       while (1)\n \t{\n@@ -387,34 +594,31 @@ PERSONALITY_FUNCTION (int version,\n \n  do_something:\n    if (found_type == found_nothing)\n-     return _URC_CONTINUE_UNWIND;\n+     CONTINUE_UNWINDING;\n \n   if (actions & _UA_SEARCH_PHASE)\n     {\n       if (found_type == found_cleanup)\n-\treturn _URC_CONTINUE_UNWIND;\n+\tCONTINUE_UNWINDING;\n \n       // For domestic exceptions, we cache data from phase 1 for phase 2.\n-      if (exception_class == __gxx_exception_class)\n+      if (!foreign_exception)\n         {\n-          xh->handlerSwitchValue = handler_switch_value;\n-          xh->actionRecord = action_record;\n-          xh->languageSpecificData = language_specific_data;\n-          xh->adjustedPtr = thrown_ptr;\n-\n-          // ??? Completely unknown what this field is supposed to be for.\n-          // ??? Need to cache TType encoding base for call_unexpected.\n-          xh->catchTemp = landing_pad;\n+\t  save_caught_exception(ue_header, context, thrown_ptr,\n+\t\t\t\thandler_switch_value, language_specific_data,\n+\t\t\t\tlanding_pad, action_record);\n \t}\n       return _URC_HANDLER_FOUND;\n     }\n \n  install_context:\n+  \n+#ifndef __ARM_EABI_UNWINDER__\n   // We can't use any of the cxa routines with foreign exceptions,\n   // because they all expect ue_header to be a struct __cxa_exception.\n   // So in that case, call terminate or unexpected directly.\n   if ((actions & _UA_FORCE_UNWIND)\n-      || exception_class != __gxx_exception_class)\n+      || foreign_exception)\n     {\n       if (found_type == found_terminate)\n \tstd::terminate ();\n@@ -427,32 +631,60 @@ PERSONALITY_FUNCTION (int version,\n \t}\n     }\n   else\n+#endif\n     {\n       if (found_type == found_terminate)\n-\t{\n-\t  __cxa_begin_catch (&xh->unwindHeader);\n-\t  __terminate (xh->terminateHandler);\n-\t}\n+\t__cxa_call_terminate(ue_header);\n \n       // Cache the TType base value for __cxa_call_unexpected, as we won't\n       // have an _Unwind_Context then.\n       if (handler_switch_value < 0)\n \t{\n \t  parse_lsda_header (context, language_specific_data, &info);\n+\n+#ifdef __ARM_EABI_UNWINDER__\n+\t  const _Unwind_Word* e;\n+\t  _Unwind_Word n;\n+\t  \n+\t  e = ((const _Unwind_Word*) info.TType) - handler_switch_value - 1;\n+\t  // Count the number of rtti objects.\n+\t  n = 0;\n+\t  while (e[n] != 0)\n+\t    n++;\n+\n+\t  // Count.\n+\t  ue_header->barrier_cache.bitpattern[1] = n;\n+\t  // Base (obsolete)\n+\t  ue_header->barrier_cache.bitpattern[2] = 0;\n+\t  // Stride.\n+\t  ue_header->barrier_cache.bitpattern[3] = 4;\n+\t  // List head.\n+\t  ue_header->barrier_cache.bitpattern[4] = (_Unwind_Word) e;\n+#else\n \t  xh->catchTemp = base_of_encoded_value (info.ttype_encoding, context);\n+#endif\n \t}\n     }\n \n   /* For targets with pointers smaller than the word size, we must extend the\n      pointer, and this extension is target dependent.  */\n   _Unwind_SetGR (context, __builtin_eh_return_data_regno (0),\n-\t\t __builtin_extend_pointer (&xh->unwindHeader));\n+\t\t __builtin_extend_pointer (ue_header));\n   _Unwind_SetGR (context, __builtin_eh_return_data_regno (1),\n \t\t handler_switch_value);\n   _Unwind_SetIP (context, landing_pad);\n+#ifdef __ARM_EABI_UNWINDER__\n+  if (found_type == found_cleanup)\n+    __cxa_begin_cleanup(ue_header);\n+#endif\n   return _URC_INSTALL_CONTEXT;\n }\n \n+/* The ARM EABI implementation of __cxa_call_unexpected is in a different\n+   file so that the personality routine san be used standalone.  The generic\n+   routine sahred datastructures with the PR so it is most convenient to\n+   implement it here.  */\n+#ifndef __ARM_EABI_UNWINDER__\n extern \"C\" void\n __cxa_call_unexpected (void *exc_obj_in)\n {\n@@ -513,3 +745,4 @@ __cxa_call_unexpected (void *exc_obj_in)\n       __terminate (xh_terminate_handler);\n     }\n }\n+#endif"}, {"sha": "eebd56c2316bfaeeac70d906a98bec6d5b456691", "filename": "libstdc++-v3/libsupc++/eh_throw.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617a1b714435a270ccf699c4c6e17767088e2242/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_throw.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617a1b714435a270ccf699c4c6e17767088e2242/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_throw.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_throw.cc?ref=617a1b714435a270ccf699c4c6e17767088e2242", "patch": "@@ -63,7 +63,7 @@ __cxxabiv1::__cxa_throw (void *obj, std::type_info *tinfo,\n   header->exceptionDestructor = dest;\n   header->unexpectedHandler = __unexpected_handler;\n   header->terminateHandler = __terminate_handler;\n-  header->unwindHeader.exception_class = __gxx_exception_class;\n+  __GXX_INIT_EXCEPTION_CLASS(header->unwindHeader.exception_class);\n   header->unwindHeader.exception_cleanup = __gxx_exception_cleanup;\n \n #ifdef _GLIBCXX_SJLJ_EXCEPTIONS\n@@ -89,15 +89,15 @@ __cxxabiv1::__cxa_rethrow ()\n   if (header)\n     {\n       // Tell __cxa_end_catch this is a rethrow.\n-      if (header->unwindHeader.exception_class != __gxx_exception_class)\n+      if (!__is_gxx_exception_class(header->unwindHeader.exception_class))\n \tglobals->caughtExceptions = 0;\n       else\n \theader->handlerCount = -header->handlerCount;\n \n #ifdef _GLIBCXX_SJLJ_EXCEPTIONS\n       _Unwind_SjLj_Resume_or_Rethrow (&header->unwindHeader);\n #else\n-#ifdef _LIBUNWIND_STD_ABI\n+#if defined(_LIBUNWIND_STD_ABI) || defined (__ARM_EABI_UNWINDER__)\n       _Unwind_RaiseException (&header->unwindHeader);\n #else\n       _Unwind_Resume_or_Rethrow (&header->unwindHeader);"}, {"sha": "a2c2f4886cca08b6cade68be7a587952f6798112", "filename": "libstdc++-v3/libsupc++/unwind-cxx.h", "status": "modified", "additions": 86, "deletions": 11, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617a1b714435a270ccf699c4c6e17767088e2242/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Funwind-cxx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617a1b714435a270ccf699c4c6e17767088e2242/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Funwind-cxx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Funwind-cxx.h?ref=617a1b714435a270ccf699c4c6e17767088e2242", "patch": "@@ -67,13 +67,21 @@ struct __cxa_exception\n   // value is a signal that this object has been rethrown.\n   int handlerCount;\n \n+#ifdef __ARM_EABI_UNWINDER__\n+  // Stack of exceptions in cleanups.\n+  __cxa_exception* nextPropagatingException;\n+\n+  // The nuber of active cleanup handlers for this exception.\n+  int propagationCount;\n+#else\n   // Cache parsed handler data from the personality routine Phase 1\n   // for Phase 2 and __cxa_call_unexpected.\n   int handlerSwitchValue;\n   const unsigned char *actionRecord;\n   const unsigned char *languageSpecificData;\n   _Unwind_Ptr catchTemp;\n   void *adjustedPtr;\n+#endif\n \n   // The generic exception header.  Must be last.\n   _Unwind_Exception unwindHeader;\n@@ -84,6 +92,9 @@ struct __cxa_eh_globals\n {\n   __cxa_exception *caughtExceptions;\n   unsigned int uncaughtExceptions;\n+#ifdef __ARM_EABI_UNWINDER__\n+  __cxa_exception* propagatingExceptions;\n+#endif\n };\n \n \n@@ -122,6 +133,20 @@ extern \"C\" void __cxa_bad_typeid ();\n // throws, and if bad_exception needs to be thrown.  Called from the\n // compiler.\n extern \"C\" void __cxa_call_unexpected (void *) __attribute__((noreturn));\n+extern \"C\" void __cxa_call_terminate (void*) __attribute__((noreturn));\n+\n+#ifdef __ARM_EABI_UNWINDER__\n+// Arm EABI specified routines.\n+typedef enum {\n+  ctm_failed = 0,\n+  ctm_succeeded = 1,\n+  ctm_succeeded_with_ptr_to_base = 2\n+} __cxa_type_match_result;\n+extern \"C\" bool __cxa_type_match(_Unwind_Exception*, const std::type_info*,\n+\t\t\t\t bool, void**);\n+extern \"C\" void __cxa_begin_cleanup (_Unwind_Exception*);\n+extern \"C\" void __cxa_end_cleanup (void);\n+#endif\n \n // Invokes given handler, dying appropriately if the user handler was\n // so inconsiderate as to return.\n@@ -134,6 +159,54 @@ extern std::unexpected_handler __unexpected_handler;\n \n // These are explicitly GNU C++ specific.\n \n+// Acquire the C++ exception header from the C++ object.\n+static inline __cxa_exception *\n+__get_exception_header_from_obj (void *ptr)\n+{\n+  return reinterpret_cast<__cxa_exception *>(ptr) - 1;\n+}\n+\n+// Acquire the C++ exception header from the generic exception header.\n+static inline __cxa_exception *\n+__get_exception_header_from_ue (_Unwind_Exception *exc)\n+{\n+  return reinterpret_cast<__cxa_exception *>(exc + 1) - 1;\n+}\n+\n+#ifdef __ARM_EABI_UNWINDER__\n+static inline bool\n+__is_gxx_exception_class(_Unwind_Exception_Class c)\n+{\n+  // TODO: Take advantage of the fact that c will always be word aligned.\n+  return c[0] == 'G'\n+\t && c[1] == 'N'\n+\t && c[2] == 'U'\n+\t && c[3] == 'C'\n+\t && c[4] == 'C'\n+\t && c[5] == '+'\n+\t && c[6] == '+'\n+\t && c[7] == '\\0';\n+}\n+\n+static inline void\n+__GXX_INIT_EXCEPTION_CLASS(_Unwind_Exception_Class c)\n+{\n+  c[0] = 'G';\n+  c[1] = 'N';\n+  c[2] = 'U';\n+  c[3] = 'C';\n+  c[4] = 'C';\n+  c[5] = '+';\n+  c[6] = '+';\n+  c[7] = '\\0';\n+}\n+\n+static inline void*\n+__gxx_caught_object(_Unwind_Exception* eo)\n+{\n+  return (void*)eo->barrier_cache.bitpattern[0];\n+}\n+#else // !__ARM_EABI_UNWINDER__\n // This is the exception class we report -- \"GNUCC++\\0\".\n const _Unwind_Exception_Class __gxx_exception_class\n = ((((((((_Unwind_Exception_Class) 'G' \n@@ -145,6 +218,14 @@ const _Unwind_Exception_Class __gxx_exception_class\n     << 8 | (_Unwind_Exception_Class) '+')\n    << 8 | (_Unwind_Exception_Class) '\\0');\n \n+static inline bool\n+__is_gxx_exception_class(_Unwind_Exception_Class c)\n+{\n+  return c == __gxx_exception_class;\n+}\n+\n+#define __GXX_INIT_EXCEPTION_CLASS(c) c = __gxx_exception_class\n+\n // GNU C++ personality routine, Version 0.\n extern \"C\" _Unwind_Reason_Code __gxx_personality_v0\n      (int, _Unwind_Action, _Unwind_Exception_Class,\n@@ -155,19 +236,13 @@ extern \"C\" _Unwind_Reason_Code __gxx_personality_sj0\n      (int, _Unwind_Action, _Unwind_Exception_Class,\n       struct _Unwind_Exception *, struct _Unwind_Context *);\n \n-// Acquire the C++ exception header from the C++ object.\n-static inline __cxa_exception *\n-__get_exception_header_from_obj (void *ptr)\n+static inline void*\n+__gxx_caught_object(_Unwind_Exception* eo)\n {\n-  return reinterpret_cast<__cxa_exception *>(ptr) - 1;\n-}\n-\n-// Acquire the C++ exception header from the generic exception header.\n-static inline __cxa_exception *\n-__get_exception_header_from_ue (_Unwind_Exception *exc)\n-{\n-  return reinterpret_cast<__cxa_exception *>(exc + 1) - 1;\n+  __cxa_exception* header = __get_exception_header_from_ue (eo);\n+  return header->adjustedPtr;\n }\n+#endif // !__ARM_EABI_UNWINDER__\n \n } /* namespace __cxxabiv1 */\n "}, {"sha": "804a9cd8c8126289d25661372c5488582c018463", "filename": "libstdc++-v3/po/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617a1b714435a270ccf699c4c6e17767088e2242/libstdc%2B%2B-v3%2Fpo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617a1b714435a270ccf699c4c6e17767088e2242/libstdc%2B%2B-v3%2Fpo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fpo%2FMakefile.in?ref=617a1b714435a270ccf699c4c6e17767088e2242", "patch": "@@ -1,8 +1,8 @@\n-# Makefile.in generated by automake 1.9.3 from Makefile.am.\n+# Makefile.in generated by automake 1.9.5 from Makefile.am.\n # @configure_input@\n \n # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,\n-# 2003, 2004  Free Software Foundation, Inc.\n+# 2003, 2004, 2005  Free Software Foundation, Inc.\n # This Makefile.in is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n # with or without modifications, as long as this notice is preserved."}, {"sha": "3a0670c8015846f3ae4a05ae3e4f74ddc54d5a3e", "filename": "libstdc++-v3/src/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617a1b714435a270ccf699c4c6e17767088e2242/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617a1b714435a270ccf699c4c6e17767088e2242/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in?ref=617a1b714435a270ccf699c4c6e17767088e2242", "patch": "@@ -1,8 +1,8 @@\n-# Makefile.in generated by automake 1.9.3 from Makefile.am.\n+# Makefile.in generated by automake 1.9.5 from Makefile.am.\n # @configure_input@\n \n # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,\n-# 2003, 2004  Free Software Foundation, Inc.\n+# 2003, 2004, 2005  Free Software Foundation, Inc.\n # This Makefile.in is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n # with or without modifications, as long as this notice is preserved."}, {"sha": "242dc2e30a0b330ab62abc51c5edd7c65a44f270", "filename": "libstdc++-v3/testsuite/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617a1b714435a270ccf699c4c6e17767088e2242/libstdc%2B%2B-v3%2Ftestsuite%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617a1b714435a270ccf699c4c6e17767088e2242/libstdc%2B%2B-v3%2Ftestsuite%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2FMakefile.in?ref=617a1b714435a270ccf699c4c6e17767088e2242", "patch": "@@ -1,8 +1,8 @@\n-# Makefile.in generated by automake 1.9.3 from Makefile.am.\n+# Makefile.in generated by automake 1.9.5 from Makefile.am.\n # @configure_input@\n \n # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,\n-# 2003, 2004  Free Software Foundation, Inc.\n+# 2003, 2004, 2005  Free Software Foundation, Inc.\n # This Makefile.in is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n # with or without modifications, as long as this notice is preserved."}]}