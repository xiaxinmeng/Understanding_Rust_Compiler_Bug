{"sha": "be4e989cd110e3eda9b9b14e6d3f73c9408e8816", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmU0ZTk4OWNkMTEwZTNlZGE5YjliMTRlNmQzZjczYzk0MDhlODgxNg==", "commit": {"author": {"name": "Bob Duff", "email": "duff@adacore.com", "date": "2017-01-23T11:13:23Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-01-23T11:13:23Z"}, "message": "sem_res.adb (Resolve_Call): In the part of the code where it is deciding whether to turn the call into an...\n\n2017-01-23  Bob Duff  <duff@adacore.com>\n\n\t* sem_res.adb (Resolve_Call): In the part of the code where\n\tit is deciding whether to turn the call into an indexed\n\tcomponent, avoid doing so if the call is to an instance of\n\tUnchecked_Conversion. Otherwise, the compiler turns it into an\n\tindexed component, and resolution of that turns it back into a\n\tfunction call, and so on, resulting in infinite recursion.\n\t* sem_util.adb (Needs_One_Actual): If the first formal has a\n\tdefault, then return False.\n\nFrom-SVN: r244774", "tree": {"sha": "8784926c11173491046562803de287383babcc32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8784926c11173491046562803de287383babcc32"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/be4e989cd110e3eda9b9b14e6d3f73c9408e8816", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be4e989cd110e3eda9b9b14e6d3f73c9408e8816", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be4e989cd110e3eda9b9b14e6d3f73c9408e8816", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be4e989cd110e3eda9b9b14e6d3f73c9408e8816/comments", "author": {"login": "bobduff", "id": 29099567, "node_id": "MDQ6VXNlcjI5MDk5NTY3", "avatar_url": "https://avatars.githubusercontent.com/u/29099567?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobduff", "html_url": "https://github.com/bobduff", "followers_url": "https://api.github.com/users/bobduff/followers", "following_url": "https://api.github.com/users/bobduff/following{/other_user}", "gists_url": "https://api.github.com/users/bobduff/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobduff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobduff/subscriptions", "organizations_url": "https://api.github.com/users/bobduff/orgs", "repos_url": "https://api.github.com/users/bobduff/repos", "events_url": "https://api.github.com/users/bobduff/events{/privacy}", "received_events_url": "https://api.github.com/users/bobduff/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e3d53f96ed595fd6e8bef75f166a93e5309b0c2a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3d53f96ed595fd6e8bef75f166a93e5309b0c2a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3d53f96ed595fd6e8bef75f166a93e5309b0c2a"}], "stats": {"total": 26, "additions": 23, "deletions": 3}, "files": [{"sha": "e482e850f7e8d26c7487af4a024453ac5f7d3cc6", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be4e989cd110e3eda9b9b14e6d3f73c9408e8816/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be4e989cd110e3eda9b9b14e6d3f73c9408e8816/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=be4e989cd110e3eda9b9b14e6d3f73c9408e8816", "patch": "@@ -1,3 +1,14 @@\n+2017-01-23  Bob Duff  <duff@adacore.com>\n+\n+\t* sem_res.adb (Resolve_Call): In the part of the code where\n+\tit is deciding whether to turn the call into an indexed\n+\tcomponent, avoid doing so if the call is to an instance of\n+\tUnchecked_Conversion. Otherwise, the compiler turns it into an\n+\tindexed component, and resolution of that turns it back into a\n+\tfunction call, and so on, resulting in infinite recursion.\n+\t* sem_util.adb (Needs_One_Actual): If the first formal has a\n+\tdefault, then return False.\n+\n 2017-01-21  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* sem_eval.adb (Compile_Time_Compare): Reinstate the expr+literal (etc)"}, {"sha": "58ee4036948214a1bac001270fd68a6b465cdffb", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be4e989cd110e3eda9b9b14e6d3f73c9408e8816/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be4e989cd110e3eda9b9b14e6d3f73c9408e8816/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=be4e989cd110e3eda9b9b14e6d3f73c9408e8816", "patch": "@@ -5974,7 +5974,12 @@ package body Sem_Res is\n       --  component type of that array type, the node is really an indexing of\n       --  the parameterless call. Resolve as such. A pathological case occurs\n       --  when the type of the component is an access to the array type. In\n-      --  this case the call is truly ambiguous.\n+      --  this case the call is truly ambiguous. If the call is to an intrinsic\n+      --  subprogram, it can't be an indexed component. This check is necessary\n+      --  because if it's Unchecked_Conversion, and we have \"type T_Ptr is\n+      --  access T;\" and \"type T is array (...) of T_Ptr;\" (i.e. an array of\n+      --  pointers to the same array), the compiler gets confused and does an\n+      --  infinite recursion.\n \n       elsif (Needs_No_Actuals (Nam) or else Needs_One_Actual (Nam))\n         and then\n@@ -5984,7 +5989,8 @@ package body Sem_Res is\n              (Is_Access_Type (Etype (Nam))\n                and then Is_Array_Type (Designated_Type (Etype (Nam)))\n                and then\n-                 Covers (Typ, Component_Type (Designated_Type (Etype (Nam))))))\n+                 Covers (Typ, Component_Type (Designated_Type (Etype (Nam))))\n+               and then not Is_Intrinsic_Subprogram (Entity (Subp))))\n       then\n          declare\n             Index_Node : Node_Id;"}, {"sha": "f8ac8ce0d381ac850ff487ae7b26e6353b3073ed", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be4e989cd110e3eda9b9b14e6d3f73c9408e8816/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be4e989cd110e3eda9b9b14e6d3f73c9408e8816/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=be4e989cd110e3eda9b9b14e6d3f73c9408e8816", "patch": "@@ -16089,7 +16089,10 @@ package body Sem_Util is\n    begin\n       --  Ada 2005 or later, and formals present\n \n-      if Ada_Version >= Ada_2005 and then Present (First_Formal (E)) then\n+      if Ada_Version >= Ada_2005\n+        and then Present (First_Formal (E))\n+        and then No (Default_Value (First_Formal (E)))\n+      then\n          Formal := Next_Formal (First_Formal (E));\n          while Present (Formal) loop\n             if No (Default_Value (Formal)) then"}]}