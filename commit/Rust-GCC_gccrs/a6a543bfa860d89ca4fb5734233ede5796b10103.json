{"sha": "a6a543bfa860d89ca4fb5734233ede5796b10103", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTZhNTQzYmZhODYwZDg5Y2E0ZmI1NzM0MjMzZWRlNTc5NmIxMDEwMw==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2015-03-04T20:28:08Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-03-04T20:28:08Z"}, "message": "cgraph.c (cgraph_node::can_remove_if_no_direct_calls_p): Rewrite for correct comdat handling.\n\n\t* cgraph.c (cgraph_node::can_remove_if_no_direct_calls_p): Rewrite\n\tfor correct comdat handling.\n\t(cgraph_node::will_be_removed_from_program_if_no_direct_calls_p):\n\tLikewise.\n\t* cgraph.h (call_for_symbol_and_aliases): Fix formating.\n\t(used_from_object_file_p_worker): Remove.\n\t(cgraph_node::only_called_directly_or_alised): Add\n\tused_from_object_file_p.\n\t* ipa-inline-analysis.c (growth_likely_positive): Optimie.\n\t* ipa-inline-transform.c (can_remove_node_now_p_1): Use\n\tcan_remove_if_no_direct_calls_and_refs_p.\n\nFrom-SVN: r221193", "tree": {"sha": "2724c9b62285c2c1dc7ecae0dea0d9cc465c8847", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2724c9b62285c2c1dc7ecae0dea0d9cc465c8847"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a6a543bfa860d89ca4fb5734233ede5796b10103", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6a543bfa860d89ca4fb5734233ede5796b10103", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6a543bfa860d89ca4fb5734233ede5796b10103", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6a543bfa860d89ca4fb5734233ede5796b10103/comments", "author": null, "committer": null, "parents": [{"sha": "d720e658eba57e78e8493d9126921bd4f07130b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d720e658eba57e78e8493d9126921bd4f07130b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d720e658eba57e78e8493d9126921bd4f07130b0"}], "stats": {"total": 150, "additions": 113, "deletions": 37}, "files": [{"sha": "db131ee786805fc697aeeed021faabe070e25156", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6a543bfa860d89ca4fb5734233ede5796b10103/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6a543bfa860d89ca4fb5734233ede5796b10103/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a6a543bfa860d89ca4fb5734233ede5796b10103", "patch": "@@ -1,3 +1,17 @@\n+2015-03-03  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* cgraph.c (cgraph_node::can_remove_if_no_direct_calls_p): Rewrite\n+\tfor correct comdat handling.\n+\t(cgraph_node::will_be_removed_from_program_if_no_direct_calls_p):\n+\tLikewise.\n+\t* cgraph.h (call_for_symbol_and_aliases): Fix formating.\n+\t(used_from_object_file_p_worker): Remove.\n+\t(cgraph_node::only_called_directly_or_alised): Add\n+\tused_from_object_file_p.\n+\t* ipa-inline-analysis.c (growth_likely_positive): Optimie.\n+\t* ipa-inline-transform.c (can_remove_node_now_p_1): Use\n+\tcan_remove_if_no_direct_calls_and_refs_p.\n+\n 2015-03-04  Nick Clifton  <nickc@redhat.com>\n \n \t* config/rl78/rl78.h (enum reg_class): Remove real registers from"}, {"sha": "b2109bd5172abfda49593da6a8739550e9292fe9", "filename": "gcc/cgraph.c", "status": "modified", "additions": 82, "deletions": 15, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6a543bfa860d89ca4fb5734233ede5796b10103/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6a543bfa860d89ca4fb5734233ede5796b10103/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=a6a543bfa860d89ca4fb5734233ede5796b10103", "patch": "@@ -2411,18 +2411,57 @@ nonremovable_p (cgraph_node *node, void *)\n   return !node->can_remove_if_no_direct_calls_and_refs_p ();\n }\n \n-/* Return true when function cgraph_node and its aliases can be removed from\n-   callgraph if all direct calls are eliminated.  */\n+/* Return true if whole comdat group can be removed if there are no direct\n+   calls to THIS.  */\n \n bool\n cgraph_node::can_remove_if_no_direct_calls_p (void)\n {\n-  /* Extern inlines can always go, we will use the external definition.  */\n-  if (DECL_EXTERNAL (decl))\n-    return true;\n-  if (address_taken)\n+  struct ipa_ref *ref;\n+\n+  /* For local symbols or non-comdat group it is the same as \n+     can_remove_if_no_direct_calls_p.  */\n+  if (!externally_visible || !same_comdat_group)\n+    {\n+      if (DECL_EXTERNAL (decl))\n+\treturn true;\n+      if (address_taken)\n+\treturn false;\n+      return !call_for_symbol_and_aliases (nonremovable_p, NULL, true);\n+    }\n+\n+  /* Otheriwse check if we can remove the symbol itself and then verify\n+     that only uses of the comdat groups are direct call to THIS\n+     or its aliases.   */\n+  if (!can_remove_if_no_direct_calls_and_refs_p ())\n     return false;\n-  return !call_for_symbol_and_aliases (nonremovable_p, NULL, true);\n+\n+  /* Check that all refs come from within the comdat group.  */\n+  for (int i = 0; iterate_referring (i, ref); i++)\n+    if (ref->referring->get_comdat_group () != get_comdat_group ())\n+      return false;\n+\n+  struct cgraph_node *target = ultimate_alias_target ();\n+  for (cgraph_node *next = dyn_cast<cgraph_node *> (same_comdat_group);\n+       next != this; next = dyn_cast<cgraph_node *> (next->same_comdat_group))\n+    {\n+      if (!externally_visible)\n+\tcontinue;\n+      if (!next->alias\n+\t  && !next->can_remove_if_no_direct_calls_and_refs_p ())\n+\treturn false;\n+\n+      /* If we see different symbol than THIS, be sure to check calls.  */\n+      if (next->ultimate_alias_target () != target)\n+\tfor (cgraph_edge *e = next->callers; e; e = e->next_caller)\n+\t  if (e->caller->get_comdat_group () != get_comdat_group ())\n+\t    return false;\n+\n+      for (int i = 0; next->iterate_referring (i, ref); i++)\n+\tif (ref->referring->get_comdat_group () != get_comdat_group ())\n+\t  return false;\n+    }\n+  return true;\n }\n \n /* Return true when function cgraph_node can be expected to be removed\n@@ -2442,19 +2481,47 @@ cgraph_node::can_remove_if_no_direct_calls_p (void)\n bool\n cgraph_node::will_be_removed_from_program_if_no_direct_calls_p (void)\n {\n+  struct ipa_ref *ref;\n   gcc_assert (!global.inlined_to);\n+  if (DECL_EXTERNAL (decl))\n+    return true;\n \n-  if (call_for_symbol_and_aliases (used_from_object_file_p_worker,\n-\t\t\t\t   NULL, true))\n-    return false;\n   if (!in_lto_p && !flag_whole_program)\n-    return only_called_directly_p ();\n-  else\n     {\n-       if (DECL_EXTERNAL (decl))\n-         return true;\n-      return can_remove_if_no_direct_calls_p ();\n+      /* If the symbol is in comdat group, we need to verify that whole comdat\n+\t group becomes unreachable.  Technically we could skip references from\n+\t within the group, too.  */\n+      if (!only_called_directly_p ())\n+\treturn false;\n+      if (same_comdat_group && externally_visible)\n+\t{\n+\t  struct cgraph_node *target = ultimate_alias_target ();\n+\t  for (cgraph_node *next = dyn_cast<cgraph_node *> (same_comdat_group);\n+\t       next != this;\n+\t       next = dyn_cast<cgraph_node *> (next->same_comdat_group))\n+\t    {\n+\t      if (!externally_visible)\n+\t\tcontinue;\n+\t      if (!next->alias\n+\t\t  && !next->only_called_directly_p ())\n+\t\treturn false;\n+\n+\t      /* If we see different symbol than THIS,\n+\t\t be sure to check calls.  */\n+\t      if (next->ultimate_alias_target () != target)\n+\t\tfor (cgraph_edge *e = next->callers; e; e = e->next_caller)\n+\t\t  if (e->caller->get_comdat_group () != get_comdat_group ())\n+\t\t    return false;\n+\n+\t      for (int i = 0; next->iterate_referring (i, ref); i++)\n+\t\tif (ref->referring->get_comdat_group () != get_comdat_group ())\n+\t\t  return false;\n+\t    }\n+\t}\n+      return true;\n     }\n+  else\n+    return can_remove_if_no_direct_calls_p ();\n }\n \n "}, {"sha": "c4f39bab4e1347c2f51d47c3434b69d0e75a6e7b", "filename": "gcc/cgraph.h", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6a543bfa860d89ca4fb5734233ede5796b10103/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6a543bfa860d89ca4fb5734233ede5796b10103/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=a6a543bfa860d89ca4fb5734233ede5796b10103", "patch": "@@ -258,8 +258,8 @@ class GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n      When INCLUDE_OVERWRITABLE is false, overwritable aliases and thunks are\n      skipped.  */\n   bool call_for_symbol_and_aliases (bool (*callback) (symtab_node *, void *),\n-\t\t\t\t  void *data,\n-\t\t\t\t  bool include_overwrite);\n+\t\t\t\t    void *data,\n+\t\t\t\t    bool include_overwrite);\n \n   /* If node can not be interposable by static or dynamic linker to point to\n      different definition, return this symbol. Otherwise look for alias with\n@@ -1187,12 +1187,6 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node {\n      returns cgraph_node::get (DECL).  */\n   static cgraph_node * create_same_body_alias (tree alias, tree decl);\n \n-  /* Worker for cgraph_can_remove_if_no_direct_calls_p.  */\n-  static bool used_from_object_file_p_worker (cgraph_node *node, void *)\n-  {\n-    return node->used_from_object_file_p ();\n-  }\n-\n   /* Verify whole cgraph structure.  */\n   static void DEBUG_FUNCTION verify_cgraph_nodes (void);\n \n@@ -2736,6 +2730,7 @@ cgraph_node::only_called_directly_or_aliased_p (void)\n \t  && !DECL_VIRTUAL_P (decl)\n \t  && !DECL_STATIC_CONSTRUCTOR (decl)\n \t  && !DECL_STATIC_DESTRUCTOR (decl)\n+\t  && !used_from_object_file_p ()\n \t  && !externally_visible);\n }\n "}, {"sha": "d74716306170fc91dbe290edf6a1761ccbc15869", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6a543bfa860d89ca4fb5734233ede5796b10103/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6a543bfa860d89ca4fb5734233ede5796b10103/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=a6a543bfa860d89ca4fb5734233ede5796b10103", "patch": "@@ -4007,25 +4007,22 @@ growth_likely_positive (struct cgraph_node *node,\n   struct cgraph_edge *e;\n   gcc_checking_assert (edge_growth > 0);\n \n+  if (DECL_EXTERNAL (node->decl))\n+    return true;\n   /* Unlike for functions called once, we play unsafe with\n      COMDATs.  We can allow that since we know functions\n      in consideration are small (and thus risk is small) and\n      moreover grow estimates already accounts that COMDAT\n      functions may or may not disappear when eliminated from\n      current unit. With good probability making aggressive\n      choice in all units is going to make overall program\n-     smaller.\n-\n-     Consequently we ask cgraph_can_remove_if_no_direct_calls_p\n-     instead of\n-     cgraph_will_be_removed_from_program_if_no_direct_calls  */\n-  if (DECL_EXTERNAL (node->decl)\n-      || !node->can_remove_if_no_direct_calls_p ())\n-    return true;\n-\n-  if (!node->will_be_removed_from_program_if_no_direct_calls_p ()\n-      && (!DECL_COMDAT (node->decl)\n-\t  || !node->can_remove_if_no_direct_calls_p ()))\n+     smaller.  */\n+  if (DECL_COMDAT (node->decl))\n+    {\n+      if (!node->can_remove_if_no_direct_calls_p ())\n+\treturn true;\n+    }\n+  else if (!node->will_be_removed_from_program_if_no_direct_calls_p ())\n     return true;\n   max_callers = inline_summaries->get (node)->size * 4 / edge_growth + 2;\n "}, {"sha": "43bb41fa8fa960a88b5c88cee0a6125512e7b256", "filename": "gcc/ipa-inline-transform.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6a543bfa860d89ca4fb5734233ede5796b10103/gcc%2Fipa-inline-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6a543bfa860d89ca4fb5734233ede5796b10103/gcc%2Fipa-inline-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-transform.c?ref=a6a543bfa860d89ca4fb5734233ede5796b10103", "patch": "@@ -112,9 +112,12 @@ can_remove_node_now_p_1 (struct cgraph_node *node, struct cgraph_edge *e)\n     }\n   /* FIXME: When address is taken of DECL_EXTERNAL function we still\n      can remove its offline copy, but we would need to keep unanalyzed node in\n-     the callgraph so references can point to it.  */\n+     the callgraph so references can point to it.\n+\n+     Also for comdat group we can ignore references inside a group as we\n+     want to prove the group as a whole to be dead.  */\n   return (!node->address_taken\n-\t  && node->can_remove_if_no_direct_calls_p ()\n+\t  && node->can_remove_if_no_direct_calls_and_refs_p ()\n \t  /* Inlining might enable more devirtualizing, so we want to remove\n \t     those only after all devirtualizable virtual calls are processed.\n \t     Lacking may edges in callgraph we just preserve them post"}]}