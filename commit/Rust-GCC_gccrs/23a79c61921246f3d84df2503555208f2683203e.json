{"sha": "23a79c61921246f3d84df2503555208f2683203e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjNhNzljNjE5MjEyNDZmM2Q4NGRmMjUwMzU1NTIwOGYyNjgzMjAzZQ==", "commit": {"author": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "1998-11-24T17:57:41Z"}, "committer": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "1998-11-24T17:57:41Z"}, "message": "[multiple changes]\n\nTue Nov 24 17:06:38 1998  Per Bothner  <bothner@cygnus.com>\n\t* (generate_classfile): Always write class access flag with\n \tACC_SUPER set.\nTue Nov 24 16:34:33 1998  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\t* class.c (maybe_layout_super_class): New function.\n\t(layout_class): Reorganized. Loop on class methods dispatched into\n \ta new function. Call maybe_layout_super_class.\n\t(layout_class_methods, layout_class_method): New functions.\n\t* expr.c (expand_java_NEW): Call layout_class_methods on loaded\n \tclass.\n\t(expand_invoke): Likewise.\n\t* java-tree.h (all_class_list): New global variable declared.\n\t(layout_class_methods, layout_class_method): New function\n \tprototypes.\n\t(LAYOUT_SEEN_CLASS_METHODS): New macro.\n\t* jcf-parse.c (all_class_list): New global variable.\n\t(load_class): Extended what class_or_name can be. Use parser\n \tcontext mechanism to save globals before calling jcf_parse.\n\t(jcf_parse_source): Don't parse twice if HAS_BEEN_ALREADY_PARSED_P\n \tis set on the file name.\n\t(jcf_parse): Layout class methods when Object is loaded, otherwise\n \trecord class in all_class_list for delayed method layout.\n\t(parse_class_file): Use LAYOUT_SEEN_CLASS_METHODS.\n\t* lang.c (put_decl_node): Decode <init> into the decl context\n \tclass name.\n\t* lex.c (java_allocate_new_line): Use xmalloc.\n\t* parse.h (INCOMPLETE_TYPE_P): Redefined to work with incomplete\n \tpointers, not TREE_LIST elements.\n\t(struct parser_ctxt): Fixed comment indentations, added comments\n \tand reordered some fields.\n\t(java_check_methods): Function prototype removed.\n\t* parse.y (java_push_parser_context): Use xmalloc.\n\t(java_parser_context_restore_global): Pop extra pushed ctxp only\n \twhen there's nothing next.\n\t(maybe_create_class_interface_decl): Fixed comment, add new\n \tcreated class decl to all_class_list.\n\t(method_header): Use GET_REAL_TYPE on argument's types.\n\t(method_declarator): Use GET_REAL_TYPE, change type to the real\n \ttype in TREE_LIST dependency node. Build argument list with the\n \treal type.\n\t(create_jdep_list): Use xmalloc. Removed allocation error message.\n\t(obtain_incomplete_type): Fixed leading comment. Broadened\n \tincoming argument meaning.\n\t(register_incomplete_type): Use xmalloc. Removed allocation error\n \tmessage.\n\t(safe_layout_class): Fixed leading comment.\n\t(jdep_resolve_class): Reversed if statement condition and switch\n \tif and else bodies.\n\t(resolve_and_layout): Fixed leading comment. Broadened incoming\n \targument meaning.\n\t(complete_class_report_errors): New local variable name, for\n \tclarity. purify_type_name used for all error cases.\n\t(java_get_real_method_name): Stricter check on constructors.\n\t(java_check_regular_methods): Reverse methods list only if not\n \talready laid out. Layout artificial constructor.\n\t(java_check_methods): Deleted.\n\t(source_start_java_method): Obtain incomplete type for patchable\n \tmethod arguments.\n\t(java_layout_classes): Fixed leading comment. Use\n \tLAYOUT_SEEN_CLASS_METHODS, use a loop to check methods. Added else\n \tstatement to layout operation, reuse LAYOUT_SEEN_CLASS_METHODS\n \tbefore returning. Fixed comments.\n\t(java_expand_classes): Check for errors up front.\n\t(patch_method_invocation): Class to search is resolved and laid\n \tout.\nA step forward truly mixing .class and .java during package\ncompilation. Includes a Per's patch.\n\nFrom-SVN: r23834", "tree": {"sha": "ddfaaed8a863a8721201f3dd3d76d282cc58791c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ddfaaed8a863a8721201f3dd3d76d282cc58791c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/23a79c61921246f3d84df2503555208f2683203e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23a79c61921246f3d84df2503555208f2683203e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23a79c61921246f3d84df2503555208f2683203e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23a79c61921246f3d84df2503555208f2683203e/comments", "author": null, "committer": null, "parents": [{"sha": "333a9f0aafc0d0e426d948e545daae6f6d277f19", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/333a9f0aafc0d0e426d948e545daae6f6d277f19", "html_url": "https://github.com/Rust-GCC/gccrs/commit/333a9f0aafc0d0e426d948e545daae6f6d277f19"}], "stats": {"total": 1011, "additions": 649, "deletions": 362}, "files": [{"sha": "a0dd3fb7bab6ce891531dfcdc9a030bb25a7fc91", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23a79c61921246f3d84df2503555208f2683203e/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23a79c61921246f3d84df2503555208f2683203e/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=23a79c61921246f3d84df2503555208f2683203e", "patch": "@@ -1,3 +1,72 @@\n+Tue Nov 24 17:06:38 1998  Per Bothner  <bothner@cygnus.com>\n+\n+\t* (generate_classfile): Always write class access flag with\n+ \tACC_SUPER set.\n+\n+Tue Nov 24 16:34:33 1998  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* class.c (maybe_layout_super_class): New function.\n+\t(layout_class): Reorganized. Loop on class methods dispatched into\n+ \ta new function. Call maybe_layout_super_class.\n+\t(layout_class_methods, layout_class_method): New functions.\n+\t* expr.c (expand_java_NEW): Call layout_class_methods on loaded\n+ \tclass.\n+\t(expand_invoke): Likewise.\n+\t* java-tree.h (all_class_list): New global variable declared.\n+\t(layout_class_methods, layout_class_method): New function\n+ \tprototypes.\n+\t(LAYOUT_SEEN_CLASS_METHODS): New macro.\n+\t* jcf-parse.c (all_class_list): New global variable.\n+\t(load_class): Extended what class_or_name can be. Use parser\n+ \tcontext mechanism to save globals before calling jcf_parse.\n+\t(jcf_parse_source): Don't parse twice if HAS_BEEN_ALREADY_PARSED_P\n+ \tis set on the file name.\n+\t(jcf_parse): Layout class methods when Object is loaded, otherwise\n+ \trecord class in all_class_list for delayed method layout.\n+\t(parse_class_file): Use LAYOUT_SEEN_CLASS_METHODS.\n+\t* lang.c (put_decl_node): Decode <init> into the decl context\n+ \tclass name.\n+\t* lex.c (java_allocate_new_line): Use xmalloc.\n+\t* parse.h (INCOMPLETE_TYPE_P): Redefined to work with incomplete\n+ \tpointers, not TREE_LIST elements.\n+\t(struct parser_ctxt): Fixed comment indentations, added comments\n+ \tand reordered some fields.\n+\t(java_check_methods): Function prototype removed.\n+\t* parse.y (java_push_parser_context): Use xmalloc.\n+\t(java_parser_context_restore_global): Pop extra pushed ctxp only\n+ \twhen there's nothing next.\n+\t(maybe_create_class_interface_decl): Fixed comment, add new\n+ \tcreated class decl to all_class_list.\n+\t(method_header): Use GET_REAL_TYPE on argument's types.\n+\t(method_declarator): Use GET_REAL_TYPE, change type to the real\n+ \ttype in TREE_LIST dependency node. Build argument list with the\n+ \treal type.\n+\t(create_jdep_list): Use xmalloc. Removed allocation error message.\n+\t(obtain_incomplete_type): Fixed leading comment. Broadened\n+ \tincoming argument meaning.\n+\t(register_incomplete_type): Use xmalloc. Removed allocation error\n+ \tmessage.\n+\t(safe_layout_class): Fixed leading comment.\n+\t(jdep_resolve_class): Reversed if statement condition and switch\n+ \tif and else bodies.\n+\t(resolve_and_layout): Fixed leading comment. Broadened incoming\n+ \targument meaning.\n+\t(complete_class_report_errors): New local variable name, for\n+ \tclarity. purify_type_name used for all error cases.\n+\t(java_get_real_method_name): Stricter check on constructors.\n+\t(java_check_regular_methods): Reverse methods list only if not\n+ \talready laid out. Layout artificial constructor.\n+\t(java_check_methods): Deleted.\n+\t(source_start_java_method): Obtain incomplete type for patchable\n+ \tmethod arguments.\n+\t(java_layout_classes): Fixed leading comment. Use\n+ \tLAYOUT_SEEN_CLASS_METHODS, use a loop to check methods. Added else\n+ \tstatement to layout operation, reuse LAYOUT_SEEN_CLASS_METHODS\n+ \tbefore returning. Fixed comments.\n+\t(java_expand_classes): Check for errors up front.\n+\t(patch_method_invocation): Class to search is resolved and laid\n+ \tout.\n+\t\n Tue Nov 24 12:57:13 1998  Per Bothner  <bothner@cygnus.com>\n \n \t* expr.c (java_lang_expand_expr):  Add missing emit_queue."}, {"sha": "e0ea241c763579262b420a462535e1dcdddf466e", "filename": "gcc/java/class.c", "status": "modified", "additions": 214, "deletions": 159, "changes": 373, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23a79c61921246f3d84df2503555208f2683203e/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23a79c61921246f3d84df2503555208f2683203e/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=23a79c61921246f3d84df2503555208f2683203e", "patch": "@@ -1323,39 +1323,55 @@ push_super_field (this_class, super_class)\n   DECL_SIZE (base_decl) = TYPE_SIZE (super_class);\n }\n \n+/* Handle the different manners we may have to lay out a super class.  */\n+\n+static tree\n+maybe_layout_super_class (super_class)\n+     tree super_class;\n+{\n+  if (TREE_CODE (super_class) == RECORD_TYPE)\n+    {\n+      if (!CLASS_LOADED_P (super_class) \n+\t  && CLASS_FROM_SOURCE_P (super_class))\n+\tsafe_layout_class (super_class);\n+      if (!CLASS_LOADED_P (super_class))\n+\tload_class (super_class, 1);\n+    }\n+  /* We might have to layout the class before its dependency on\n+     the super class gets resolved by java_complete_class  */\n+  else if (TREE_CODE (super_class) == TREE_LIST)\n+    {\n+      tree name = TYPE_NAME (TREE_PURPOSE (super_class));\n+      load_class (name, 1);\n+      super_class = IDENTIFIER_CLASS_VALUE (name);\n+      if (!super_class)\n+\t    return;\n+      super_class = TREE_TYPE (super_class);\n+    }\n+  if (!TYPE_SIZE (super_class))\n+    safe_layout_class (super_class);\n+\n+  return super_class;\n+}\n+\n void\n layout_class (this_class)\n      tree this_class;\n {\n   tree super_class = CLASSTYPE_SUPER (this_class);\n-  tree handle_type = CLASS_TO_HANDLE_TYPE (this_class);\n-  tree method_decl, field;\n-  tree dtable_count;\n-  int i;\n+  tree field;\n \n   if (super_class)\n     {\n-      /* Class seen in source are now complete and can be layed out.\n-\t Once layed out, a class seen in the source has its\n-\t CLASS_LOADED_P flag set */\n-      if (CLASS_FROM_SOURCE_P (super_class) && !CLASS_LOADED_P (super_class))\n-\tsafe_layout_class (super_class);\n-      if (! CLASS_LOADED_P (super_class))\n-\tload_class (super_class, 1);\n+      super_class = maybe_layout_super_class (super_class);\n       if (TREE_CODE (TYPE_SIZE (super_class)) == ERROR_MARK)\n \t{\n \t  TYPE_SIZE (this_class) = error_mark_node;\n \t  return;\n \t}\n-      dtable_count = TYPE_NVIRTUALS (super_class);\n-\n       if (TYPE_SIZE (this_class) == NULL_TREE)\n \tpush_super_field (this_class, super_class);\n     }\n-  else\n-    {\n-      dtable_count = integer_zero_node;\n-    }\n \n   for (field = TYPE_FIELDS (this_class);\n        field != NULL_TREE;  field = TREE_CHAIN (field))\n@@ -1368,178 +1384,217 @@ layout_class (this_class)\n     }\n \n   layout_type (this_class);\n+}\n \n-  TYPE_METHODS (handle_type) = nreverse (TYPE_METHODS (handle_type));\n+void\n+layout_class_methods (this_class)\n+     tree this_class;\n+{\n+  tree method_decl, dtable_count;\n+  tree super_class, handle_type;\n+\n+  if (TYPE_NVIRTUALS (this_class))\n+    return;\n+\n+  push_obstacks (&permanent_obstack, &permanent_obstack);\n+  super_class = CLASSTYPE_SUPER (this_class);\n+  handle_type = CLASS_TO_HANDLE_TYPE (this_class);\n \n-  for (method_decl = TYPE_METHODS (handle_type), i = 0;\n-       method_decl; method_decl = TREE_CHAIN (method_decl), i++)\n+  if (super_class)\n     {\n-      char *ptr;\n-      char buf[8];\n-      char *asm_name;\n-      tree method_name = DECL_NAME (method_decl);\n-      int method_name_is_wfl = \n-\t(TREE_CODE (method_name) == EXPR_WITH_FILE_LOCATION);\n-      if (method_name_is_wfl)\n-\tmethod_name = java_get_real_method_name (method_decl);\n+      super_class = maybe_layout_super_class (super_class);\n+      if (!TYPE_NVIRTUALS (super_class))\n+\tlayout_class_methods (super_class);\n+      dtable_count = TYPE_NVIRTUALS (super_class);\n+    }\n+  else\n+    dtable_count = integer_zero_node;\n+  \n+  TYPE_METHODS (handle_type) = nreverse (TYPE_METHODS (handle_type));\n+\n+  for (method_decl = TYPE_METHODS (handle_type);\n+       method_decl; method_decl = TREE_CHAIN (method_decl))\n+    dtable_count = layout_class_method (this_class, super_class, \n+\t\t\t\t\tmethod_decl, dtable_count);\n+\n+  TYPE_NVIRTUALS (this_class) = dtable_count;\n+\n+#ifdef JAVA_USE_HANDLES\n+  layout_type (handle_type);\n+#endif\n+  pop_obstacks ();\n+}\n+\n+/* Lay METHOD_DECL out, returning a possibly new value of\n+   DTABLE_COUNT.  */\n+\n+tree\n+layout_class_method (this_class, super_class, method_decl, dtable_count)\n+     tree this_class, super_class, method_decl, dtable_count;\n+{\n+  char *ptr;\n+  char buf[8];\n+  char *asm_name;\n+  tree method_name = DECL_NAME (method_decl);\n+  int method_name_is_wfl = \n+    (TREE_CODE (method_name) == EXPR_WITH_FILE_LOCATION);\n+  if (method_name_is_wfl)\n+    method_name = java_get_real_method_name (method_decl);\n #if 1\n-      /* Remove this once we no longer need old (Kaffe / JDK 1.0)  mangling. */\n-      if (! flag_assume_compiled && METHOD_NATIVE (method_decl))\n+  /* Remove this once we no longer need old (Kaffe / JDK 1.0)  mangling. */\n+  if (! flag_assume_compiled && METHOD_NATIVE (method_decl))\n+    {\n+      for (ptr = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (this_class)));\n+\t   *ptr; )\n+\t{\n+\t  int ch = *ptr++;\n+\t  if (ch == '.')\n+\t    ch = '_';\n+\t  obstack_1grow (&temporary_obstack, (char) ch);\n+\t}\n+      obstack_1grow (&temporary_obstack, (char) '_');\n+      if (method_name == init_identifier_node)\n+\tobstack_grow (&temporary_obstack, \"INIT\", 4);\n+      else\n+\tobstack_grow (&temporary_obstack,\n+\t\t      IDENTIFIER_POINTER (method_name),\n+\t\t      IDENTIFIER_LENGTH (method_name));\n+    }\n+  else\n+#endif\n+    {\n+      int len;  tree arg, arglist, t;\n+      int method_name_needs_escapes = 0;\n+      if (method_name != init_identifier_node \n+\t  && method_name != finit_identifier_node)\n \t{\n-\t  for (ptr = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (this_class)));\n-\t       *ptr; )\n+\t  int encoded_len\n+\t    = unicode_mangling_length (IDENTIFIER_POINTER (method_name), \n+\t\t\t\t       IDENTIFIER_LENGTH (method_name));\n+\t  if (encoded_len > 0)\n \t    {\n-\t      int ch = *ptr++;\n-\t      if (ch == '.')\n-\t\tch = '_';\n-\t      obstack_1grow (&temporary_obstack, (char) ch);\n+\t      method_name_needs_escapes = 1;\n+\t      emit_unicode_mangled_name (&temporary_obstack,\n+\t\t\t\t\t IDENTIFIER_POINTER (method_name), \n+\t\t\t\t\t IDENTIFIER_LENGTH (method_name));\n \t    }\n-\t  obstack_1grow (&temporary_obstack, (char) '_');\n-\t  if (method_name == init_identifier_node)\n-\t    obstack_grow (&temporary_obstack, \"INIT\", 4);\n \t  else\n-\t    obstack_grow (&temporary_obstack,\n-\t\t\t  IDENTIFIER_POINTER (method_name),\n-\t\t\t  IDENTIFIER_LENGTH (method_name));\n+\t    {\n+\t      obstack_grow (&temporary_obstack,\n+\t\t\t    IDENTIFIER_POINTER (method_name),\n+\t\t\t    IDENTIFIER_LENGTH (method_name));\n+\t    }\n \t}\n-      else\n-#endif\n+      \n+      obstack_grow (&temporary_obstack, \"__\", 2);\n+      if (method_name == finit_identifier_node)\n+\tobstack_grow (&temporary_obstack, \"finit\", 5);\n+      append_gpp_mangled_type (&temporary_obstack, this_class);\n+      TREE_PUBLIC (method_decl) = 1;\n+      \n+      t = TREE_TYPE (method_decl);\n+      arglist = TYPE_ARG_TYPES (t);\n+      if (TREE_CODE (t) == METHOD_TYPE)\n+\targlist = TREE_CHAIN (arglist);\n+      for (arg = arglist; arg != NULL_TREE;  )\n \t{\n-\t  int len;  tree arg, arglist, t;\n-\t  int method_name_needs_escapes = 0;\n-\t  if (method_name != init_identifier_node \n-\t      && method_name != finit_identifier_node)\n+\t  tree a = arglist;\n+\t  tree argtype = TREE_VALUE (arg);\n+\t  int tindex = 1;\n+\t  if (TREE_CODE (argtype) == POINTER_TYPE)\n \t    {\n-\t      int encoded_len\n-\t\t= unicode_mangling_length (IDENTIFIER_POINTER (method_name), \n-\t\t\t\t\t   IDENTIFIER_LENGTH (method_name));\n-\t      if (encoded_len > 0)\n-\t\t{\n-\t\t  method_name_needs_escapes = 1;\n-\t\t  emit_unicode_mangled_name (&temporary_obstack,\n-\t\t\t\t\t     IDENTIFIER_POINTER (method_name), \n-\t\t\t\t\t     IDENTIFIER_LENGTH (method_name));\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  obstack_grow (&temporary_obstack,\n-\t\t\t\tIDENTIFIER_POINTER (method_name),\n-\t\t\t\tIDENTIFIER_LENGTH (method_name));\n-\t\t}\n+\t      /* This is O(N**2).  Do we care?  Cfr gcc/cp/method.c. */\n+\t      while (a != arg && argtype != TREE_VALUE (a))\n+\t\ta = TREE_CHAIN (a), tindex++;\n \t    }\n-\n-\t  obstack_grow (&temporary_obstack, \"__\", 2);\n-\t  if (method_name == finit_identifier_node)\n-\t    obstack_grow (&temporary_obstack, \"finit\", 5);\n-\t  append_gpp_mangled_type (&temporary_obstack, this_class);\n-\t  TREE_PUBLIC (method_decl) = 1;\n-\n-\t  t = TREE_TYPE (method_decl);\n-\t  arglist = TYPE_ARG_TYPES (t);\n-\t  if (TREE_CODE (t) == METHOD_TYPE)\n-\t    arglist = TREE_CHAIN (arglist);\n-\t  for (arg = arglist; arg != NULL_TREE;  )\n+\t  else\n+\t    a = arg;\n+\t  if (a != arg)\n \t    {\n-\t      tree a = arglist;\n-\t      tree argtype = TREE_VALUE (arg);\n-\t      int tindex = 1;\n-\t      if (TREE_CODE (argtype) == POINTER_TYPE)\n+\t      char buf[12];\n+\t      int nrepeats = 0;\n+\t      do\n \t\t{\n-\t\t  /* This is O(N**2).  Do we care?  Cfr gcc/cp/method.c. */\n-\t\t  while (a != arg && argtype != TREE_VALUE (a))\n-\t\t    a = TREE_CHAIN (a), tindex++;\n+\t\t  arg = TREE_CHAIN (arg); nrepeats++;\n \t\t}\n-\t      else\n-\t\ta = arg;\n-\t      if (a != arg)\n+\t      while (arg != NULL_TREE && argtype == TREE_VALUE (arg));\n+\t      if (nrepeats > 1)\n \t\t{\n-\t\t  char buf[12];\n-\t\t  int nrepeats = 0;\n-\t\t  do\n-\t\t    {\n-\t\t      arg = TREE_CHAIN (arg); nrepeats++;\n-\t\t    }\n-\t\t  while (arg != NULL_TREE && argtype == TREE_VALUE (arg));\n-\t\t  if (nrepeats > 1)\n-\t\t    {\n-\t\t      obstack_1grow (&temporary_obstack, 'N');\n-\t\t      sprintf (buf, \"%d\", nrepeats);\n-\t\t      obstack_grow (&temporary_obstack, buf, strlen (buf));\n-\t\t      if (nrepeats > 9)\n-\t\t\tobstack_1grow (&temporary_obstack, '_');\n-\t\t    }\n-\t\t  else\n-\t\t    obstack_1grow (&temporary_obstack, 'T');\n-\t\t  sprintf (buf, \"%d\", tindex);\n+\t\t  obstack_1grow (&temporary_obstack, 'N');\n+\t\t  sprintf (buf, \"%d\", nrepeats);\n \t\t  obstack_grow (&temporary_obstack, buf, strlen (buf));\n-\t\t  if (tindex > 9)\n+\t\t  if (nrepeats > 9)\n \t\t    obstack_1grow (&temporary_obstack, '_');\n \t\t}\n \t      else\n-\t\t{\n-\t\t  append_gpp_mangled_type (&temporary_obstack, argtype);\n-\t\t  arg = TREE_CHAIN (arg);\n-\t\t}\n+\t\tobstack_1grow (&temporary_obstack, 'T');\n+\t      sprintf (buf, \"%d\", tindex);\n+\t      obstack_grow (&temporary_obstack, buf, strlen (buf));\n+\t      if (tindex > 9)\n+\t\tobstack_1grow (&temporary_obstack, '_');\n \t    }\n-\t  if (method_name_needs_escapes)\n-\t    obstack_1grow (&temporary_obstack, 'U');\n-\t}\n-      obstack_1grow (&temporary_obstack, '\\0');\n-      asm_name = obstack_finish (&temporary_obstack);\n-      DECL_ASSEMBLER_NAME (method_decl) = get_identifier (asm_name);\n-      if (! METHOD_ABSTRACT (method_decl))\n-\tmake_function_rtl (method_decl);\n-      obstack_free (&temporary_obstack, asm_name);\n-\n-      if (method_name == init_identifier_node)\n-\t{\n-\t  char *p = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (this_class)));\n-\t  for (ptr = p; *ptr; )\n+\t  else\n \t    {\n-\t      if (*ptr++ == '.')\n-\t\tp = ptr;\n+\t      append_gpp_mangled_type (&temporary_obstack, argtype);\n+\t      arg = TREE_CHAIN (arg);\n \t    }\n-\t  if (method_name_is_wfl)\n-\t    EXPR_WFL_NODE (DECL_NAME (method_decl)) = get_identifier (p);\n-\t  else\n-\t    DECL_NAME (method_decl) = get_identifier (p);\n-\t  DECL_CONSTRUCTOR_P (method_decl) = 1;\n \t}\n-      else if (! METHOD_STATIC (method_decl) && !DECL_ARTIFICIAL (method_decl))\n+      if (method_name_needs_escapes)\n+\tobstack_1grow (&temporary_obstack, 'U');\n+    }\n+  obstack_1grow (&temporary_obstack, '\\0');\n+  asm_name = obstack_finish (&temporary_obstack);\n+  DECL_ASSEMBLER_NAME (method_decl) = get_identifier (asm_name);\n+  if (! METHOD_ABSTRACT (method_decl))\n+    make_function_rtl (method_decl);\n+  obstack_free (&temporary_obstack, asm_name);\n+  \n+  if (method_name == init_identifier_node)\n+    {\n+      char *p = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (this_class)));\n+      for (ptr = p; *ptr; )\n \t{\n-\t  tree method_sig = build_java_argument_signature (TREE_TYPE (method_decl));\n-\t  tree super_method = lookup_argument_method (super_class, method_name,\n+\t  if (*ptr++ == '.')\n+\t    p = ptr;\n+\t}\n+      if (method_name_is_wfl)\n+\tEXPR_WFL_NODE (DECL_NAME (method_decl)) = get_identifier (p);\n+      else\n+\tDECL_NAME (method_decl) = get_identifier (p);\n+      DECL_CONSTRUCTOR_P (method_decl) = 1;\n+    }\n+  else if (! METHOD_STATIC (method_decl) && !DECL_ARTIFICIAL (method_decl))\n+    {\n+      tree method_sig = \n+\tbuild_java_argument_signature (TREE_TYPE (method_decl));\n+      tree super_method = lookup_argument_method (super_class, method_name,\n \t\t\t\t\t\t  method_sig);\n-\t  if (super_method != NULL_TREE)\n-\t    {\n-\t      DECL_VINDEX (method_decl) = DECL_VINDEX (super_method);\n-\t      if (DECL_VINDEX (method_decl) == NULL_TREE)\n-\t\terror_with_decl (method_decl,\n-\t\t\t \"non-static method '%s' overrides static method\");\n+      if (super_method != NULL_TREE)\n+\t{\n+\t  DECL_VINDEX (method_decl) = DECL_VINDEX (super_method);\n+\t  if (DECL_VINDEX (method_decl) == NULL_TREE)\n+\t    error_with_decl (method_decl,\n+\t\t\t     \"non-static method '%s' overrides static method\");\n #if 0\n-\t      else if (TREE_TYPE (TREE_TYPE (method_decl))\n-\t\t       != TREE_TYPE (TREE_TYPE (super_method)))\n-\t\t{\n-\t\t  error_with_decl (method_decl,\n-\t\t\t\t \"Method `%s' redefined with different return type\");  \n-\t\t  error_with_decl (super_method,\n-\t\t\t\t \"Overridden decl is here\");\n-\t\t}\n+else if (TREE_TYPE (TREE_TYPE (method_decl))\n+\t != TREE_TYPE (TREE_TYPE (super_method)))\n+  {\n+    error_with_decl (method_decl,\n+\t\t     \"Method `%s' redefined with different return type\");  \n+    error_with_decl (super_method,\n+\t\t     \"Overridden decl is here\");\n+  }\n #endif\n-\t    }\n-\t  else if (! METHOD_FINAL (method_decl)\n-\t\t   && ! CLASS_FINAL (TYPE_NAME (this_class)))\n-\t    {\n-\t      DECL_VINDEX (method_decl) = dtable_count;\n-\t      dtable_count = build_int_2 (1+TREE_INT_CST_LOW (dtable_count), 0);\n-\t    }\n+\t}\n+      else if (! METHOD_FINAL (method_decl)\n+\t       && ! CLASS_FINAL (TYPE_NAME (this_class))\n+\t       && dtable_count)\n+\t{\n+\t  DECL_VINDEX (method_decl) = dtable_count;\n+\t  dtable_count = build_int_2 (1+TREE_INT_CST_LOW (dtable_count), 0);\n \t}\n     }\n-  TYPE_NVIRTUALS (this_class) = dtable_count;\n-\n-#ifdef JAVA_USE_HANDLES\n-  layout_type (handle_type);\n-#endif\n+  return dtable_count;\n }\n \n static tree registered_class = NULL_TREE;"}, {"sha": "7ac3d19c7ec774227a0e53a5619ab54a1d88655c", "filename": "gcc/java/expr.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23a79c61921246f3d84df2503555208f2683203e/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23a79c61921246f3d84df2503555208f2683203e/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=23a79c61921246f3d84df2503555208f2683203e", "patch": "@@ -910,6 +910,7 @@ expand_java_NEW (type)\n {\n   if (! CLASS_LOADED_P (type))\n     load_class (type, 1);\n+  layout_class_methods (type);\n   push_value (build (CALL_EXPR, promote_type (type),\n \t\t     build_address_of (alloc_object_node),\n \t\t     tree_cons (NULL_TREE, build_class_ref (type),\n@@ -1485,6 +1486,7 @@ expand_invoke (opcode, method_ref_index, nargs)\n       if (TREE_CODE (TYPE_SIZE (self_type)) == ERROR_MARK)\n \tfatal (\"failed to find class '%s'\", self_name);\n     }\n+  layout_class_methods (self_type);\n \n   if (method_name == init_identifier_node)\n     method = lookup_java_constructor (CLASS_TO_HANDLE_TYPE (self_type),"}, {"sha": "66aae185e0866502da233407b951f3ebacb5d66c", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23a79c61921246f3d84df2503555208f2683203e/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23a79c61921246f3d84df2503555208f2683203e/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=23a79c61921246f3d84df2503555208f2683203e", "patch": "@@ -112,6 +112,9 @@ extern tree main_class;\n /* The class we are currently processing. */\n extern tree current_class;\n \n+/* List of all class DECLs seen so far.  */\n+extern tree all_class_list;\n+\n /* Nonzero if we want to automatically do array bounds checking;\n    on by default.  Use -fno-bounds-check to disable.  */\n \n@@ -483,6 +486,8 @@ extern tree unmangle_classname PROTO ((const char *name, int name_length));\n extern tree parse_signature_string PROTO ((const unsigned char *, int));\n extern tree get_type_from_signature PROTO ((tree));\n extern void layout_class PROTO ((tree));\n+extern tree layout_class_method PROTO ((tree, tree, tree, tree));\n+extern void layout_class_methods PROTO ((tree));\n extern tree make_class ();\n extern tree build_class_ref PROTO ((tree));\n extern tree build_dtable_decl PROTO ((tree));\n@@ -835,3 +840,10 @@ extern tree *type_map;\n      if (java_error_count)\t\t\t\t\t\t\\\n        return;\t\t\t\t\t\t\t\t\\\n    }\n+\n+#define LAYOUT_SEEN_CLASS_METHODS()\t\t\t\t\t    \\\n+  {\t\t\t\t\t\t\t\t\t    \\\n+    tree current;\t\t\t\t\t\t\t    \\\n+    for (current = all_class_list; current; current = TREE_CHAIN (current)) \\\n+      layout_class_methods (TREE_TYPE (TREE_VALUE (current)));\t\t    \\\n+  }"}, {"sha": "c9f2ed7f5aa894583021c03caf6adf9830c82b8d", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 37, "deletions": 12, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23a79c61921246f3d84df2503555208f2683203e/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23a79c61921246f3d84df2503555208f2683203e/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=23a79c61921246f3d84df2503555208f2683203e", "patch": "@@ -61,7 +61,10 @@ tree current_class = NULL_TREE;\n /* The class we started with. */\n tree main_class = NULL_TREE;\n \n-/* The FIELD_DECL for the current field. */\n+/* List of all class DECL seen so far.  */\n+tree all_class_list = NULL_TREE;\n+\n+/* The FIELD_DECL for the current field.  */\n static tree current_field = NULL_TREE;\n \n /* The METHOD_DECL for the current method.  */\n@@ -450,15 +453,25 @@ load_class (class_or_name, verbose)\n      int verbose;\n {\n   JCF this_jcf, *jcf;\n-  tree name = (TREE_CODE (class_or_name) == IDENTIFIER_NODE ?\n-\t       class_or_name : DECL_NAME (TYPE_NAME (class_or_name)));\n+  tree name;\n   tree save_current_class = current_class;\n   char *save_input_filename = input_filename;\n   JCF *save_current_jcf = current_jcf;\n   long saved_pos;\n   if (current_jcf->read_state)\n     saved_pos = ftell (current_jcf->read_state);\n \n+  /* class_or_name can be the name of the class we want to load */\n+  if (TREE_CODE (class_or_name) == IDENTIFIER_NODE)\n+    name = class_or_name;\n+  /* In some cases, it's a dependency that we process earlier that\n+     we though */\n+  else if (TREE_CODE (class_or_name) == TREE_LIST)\n+    name = TYPE_NAME (TREE_PURPOSE (class_or_name));\n+  /* Or it's a type in the making */\n+  else\n+    name = DECL_NAME (TYPE_NAME (class_or_name));\n+\n   push_obstacks (&permanent_obstack, &permanent_obstack);\n \n   /* Search in current zip first.  */\n@@ -494,10 +507,12 @@ load_class (class_or_name, verbose)\n   if (current_jcf->java_source)\n     jcf_parse_source (current_jcf);\n   else {\n-    int saved_lineno = lineno;\n+    java_parser_context_save_global ();\n+    java_push_parser_context ();\n     input_filename = current_jcf->filename;\n     jcf_parse (current_jcf);\n-    lineno = saved_lineno;\n+    java_pop_parser_context (0);\n+    java_parser_context_restore_global ();\n   }\n \n   if (!current_jcf->seen_in_zip)\n@@ -524,13 +539,16 @@ jcf_parse_source (jcf)\n   java_push_parser_context ();\n   input_filename = current_jcf->filename;\n   file = get_identifier (input_filename);\n-  if (!(finput = fopen (input_filename, \"r\")))\n-    fatal (\"input file `%s' just disappeared - jcf_parse_source\",\n-\t   input_filename);\n-  parse_source_file (file);\n-  if (fclose (finput))\n-    fatal (\"can't close input file `%s' stream - jcf_parse_source\",\n-\t   input_filename);\n+  if (!HAS_BEEN_ALREADY_PARSED_P (file))\n+    {\n+      if (!(finput = fopen (input_filename, \"r\")))\n+\tfatal (\"input file `%s' just disappeared - jcf_parse_source\",\n+\t       input_filename);\n+      parse_source_file (file);\n+      if (fclose (finput))\n+\tfatal (\"can't close input file `%s' stream - jcf_parse_source\",\n+\t       input_filename);\n+    }\n   java_pop_parser_context (IS_A_COMMAND_LINE_FILENAME_P (file));\n   java_parser_context_restore_global ();\n }\n@@ -586,6 +604,11 @@ jcf_parse (jcf)\n \n   push_obstacks (&permanent_obstack, &permanent_obstack);\n   layout_class (current_class);\n+  if (current_class == object_type_node)\n+    layout_class_methods (object_type_node);\n+  else\n+    all_class_list = tree_cons (NULL_TREE, \n+\t\t\t\tTYPE_NAME (current_class), all_class_list );\n   pop_obstacks ();\n }\n \n@@ -612,6 +635,8 @@ parse_class_file ()\n   char *save_input_filename = input_filename;\n   int save_lineno = lineno;\n \n+  LAYOUT_SEEN_CLASS_METHODS ();\n+\n   input_filename = DECL_SOURCE_FILE (TYPE_NAME (current_class));\n   lineno = 0;\n   debug_start_source_file (input_filename);"}, {"sha": "036f4deaa3bc6e099ec7d23c554d2dabcaef89f4", "filename": "gcc/java/jcf-write.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23a79c61921246f3d84df2503555208f2683203e/gcc%2Fjava%2Fjcf-write.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23a79c61921246f3d84df2503555208f2683203e/gcc%2Fjava%2Fjcf-write.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-write.c?ref=23a79c61921246f3d84df2503555208f2683203e", "patch": "@@ -2342,7 +2342,8 @@ generate_classfile (clas, state)\n   else\n     i = 8 + 2 * total_supers;\n   ptr = append_chunk (NULL, i, state);\n-  i = get_access_flags (TYPE_NAME (clas));  PUT2 (i); /* acces_flags */\n+  i = get_access_flags (TYPE_NAME (clas)) | ACC_SUPER;\n+  PUT2 (i); /* acces_flags */\n   i = find_class_constant (&state->cpool, clas);  PUT2 (i);  /* this_class */\n   if (clas == object_type_node)\n     {"}, {"sha": "4e646d24a3774eb4a133cd2a5195f20f608a5405", "filename": "gcc/java/lang.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23a79c61921246f3d84df2503555208f2683203e/gcc%2Fjava%2Flang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23a79c61921246f3d84df2503555208f2683203e/gcc%2Fjava%2Flang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang.c?ref=23a79c61921246f3d84df2503555208f2683203e", "patch": "@@ -358,7 +358,12 @@ put_decl_node (node)\n \t  put_decl_string (\".\", 1);\n \t}\n #endif\n-      put_decl_node (DECL_NAME (node));\n+      if (TREE_CODE (node) == FUNCTION_DECL\n+\t  && DECL_NAME (node) == init_identifier_node\n+\t  && !DECL_ARTIFICIAL (node) && current_class)\n+\tput_decl_node (TYPE_NAME (current_class));\n+      else\n+\tput_decl_node (DECL_NAME (node));\n       if (TREE_CODE (node) == FUNCTION_DECL && TREE_TYPE (node) != NULL_TREE)\n \t{\n \t  int i = 0;"}, {"sha": "946e5740ca8da98bc8c18f4c2bca94cd291d0319", "filename": "gcc/java/lex.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23a79c61921246f3d84df2503555208f2683203e/gcc%2Fjava%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23a79c61921246f3d84df2503555208f2683203e/gcc%2Fjava%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flex.c?ref=23a79c61921246f3d84df2503555208f2683203e", "patch": "@@ -153,12 +153,12 @@ java_allocate_new_line ()\n \n   if (!ctxp->c_line)\n     {\n-      ctxp->c_line = (struct java_line *)malloc (sizeof (struct java_line));\n+      ctxp->c_line = (struct java_line *)xmalloc (sizeof (struct java_line));\n       ctxp->c_line->max = JAVA_LINE_MAX;\n-      ctxp->c_line->line = (unicode_t *)malloc \n-\t  (sizeof (unicode_t)*ctxp->c_line->max);\n+      ctxp->c_line->line = (unicode_t *)xmalloc \n+\t(sizeof (unicode_t)*ctxp->c_line->max);\n       ctxp->c_line->unicode_escape_p = \n-\t  (char *)malloc (sizeof (char)*ctxp->c_line->max);\n+\t  (char *)xmalloc (sizeof (char)*ctxp->c_line->max);\n       ctxp->c_line->white_space_only = 0;\n     }\n "}, {"sha": "8e147cd85d47749d02b60733f0cc8c3cbe51f923", "filename": "gcc/java/parse.c", "status": "modified", "additions": 143, "deletions": 83, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23a79c61921246f3d84df2503555208f2683203e/gcc%2Fjava%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23a79c61921246f3d84df2503555208f2683203e/gcc%2Fjava%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.c?ref=23a79c61921246f3d84df2503555208f2683203e", "patch": "@@ -4675,7 +4675,7 @@ void\n java_push_parser_context ()\n {\n   struct parser_ctxt *new = \n-    (struct parser_ctxt *)malloc(sizeof (struct parser_ctxt));\n+    (struct parser_ctxt *)xmalloc(sizeof (struct parser_ctxt));\n \n   bzero (new, sizeof (struct parser_ctxt));\n   new->next = ctxp;\n@@ -4716,7 +4716,7 @@ java_parser_context_restore_global ()\n   current_class = ctxp->current_class;\n   input_filename = ctxp->filename;\n   current_function_decl = ctxp->current_function_decl;\n-  if (extra_ctxp_pushed_p)\n+  if (!ctxp->next && extra_ctxp_pushed_p)\n     {\n       java_pop_parser_context (0);\n       extra_ctxp_pushed_p = 0;\n@@ -5175,8 +5175,9 @@ maybe_create_class_interface_decl (decl, qualified_name, cl)\n   TREE_CHAIN (decl) = ctxp->class_list;\n   ctxp->class_list = decl;\n \n-  /* Create a new node in the global list */\n+  /* Create a new nodes in the global lists */\n   ctxp->gclass_list = tree_cons (NULL_TREE, decl, ctxp->gclass_list);\n+  all_class_list = tree_cons (NULL_TREE, decl, all_class_list);\n \n   /* Install a new dependency list element */\n   create_jdep_list (ctxp);\n@@ -5310,7 +5311,7 @@ create_class (flags, id, super, interfaces)\n \t  super_decl_type = TREE_TYPE (super_decl);\n \t}\n       else\n-\tsuper_decl_type = \n+\tsuper_decl_type =\n \t  register_incomplete_type (JDEP_SUPER, super, decl, NULL_TREE);\n     }\n   else if (TREE_TYPE (decl) != object_type_node)\n@@ -5689,8 +5690,7 @@ method_header (flags, type, mdecl, throws)\n \t  tree itype;\n \t  patch_stage = JDEP_METHOD_RETURN;\n \t  itype = register_incomplete_type (patch_stage, type, id, NULL_TREE);\n-\t  TREE_TYPE (meth) = (TREE_CODE (itype) == TREE_LIST ? \n-\t\t\t      TREE_PURPOSE (itype) : itype);\n+\t  TREE_TYPE (meth) = GET_REAL_TYPE (itype);\n \t}\n     }\n   else\n@@ -5928,6 +5928,7 @@ method_declarator (id, list)\n       tree name = EXPR_WFL_NODE (wfl_name);\n       tree already, arg_node;\n       tree type_wfl = NULL_TREE;\n+      tree real_type;\n \n       /* Obtain a suitable type for resolution, if necessary */\n       SET_TYPE_FOR_RESOLUTION (type, type_wfl, must_chain);\n@@ -5936,8 +5937,13 @@ method_declarator (id, list)\n       type = build_array_from_name (type, type_wfl, name, &name);\n       EXPR_WFL_NODE (wfl_name) = name;\n \n-      if (TREE_CODE (type) == RECORD_TYPE)\n-\ttype = promote_type (type);\n+      real_type = GET_REAL_TYPE (type);\n+      if (TREE_CODE (real_type) == RECORD_TYPE)\n+\t{\n+\t  real_type = promote_type (real_type);\n+\t  if (TREE_CODE (type) == TREE_LIST)\n+\t    TREE_PURPOSE (type) = real_type;\n+\t}\n \n       /* Check redefinition */\n       for (already = arg_types; already; already = TREE_CHAIN (already))\n@@ -5963,7 +5969,7 @@ method_declarator (id, list)\n \t}\n \n       /* The argument node: a name and a (possibly) incomplete type */\n-      arg_node = build_tree_list (name, type);\n+      arg_node = build_tree_list (name, real_type);\n       if (jdep)\n \tJDEP_GET_PATCH (jdep) = &TREE_VALUE (arg_node);\n       TREE_CHAIN (arg_node) = arg_types;\n@@ -6081,11 +6087,7 @@ static void\n create_jdep_list (ctxp)\n      struct parser_ctxt *ctxp;\n {\n-  jdeplist *new = malloc (sizeof (jdeplist));\t\n-  \n-  if (!new)\n-    fatal (\"Can't alloc jdeplist - create_jdep_list\");\n-    \n+  jdeplist *new = (jdeplist *)xmalloc (sizeof (jdeplist));\t\n   new->first = new->last = NULL;\n   new->next = ctxp->classd_list;\n   ctxp->classd_list = new;\n@@ -6105,14 +6107,22 @@ reverse_jdep_list (ctxp)\n   return prev;\n }\n \n-/* Create a fake pointer based on the ID stored in the WFL */\n+/* Create a fake pointer based on the ID stored in\n+   TYPE_NAME. TYPE_NAME can be a WFL or a incomplete type asking to be\n+   registered again. */\n \n static tree\n-obtain_incomplete_type (wfl)\n-     tree wfl;\n+obtain_incomplete_type (type_name)\n+     tree type_name;\n {\n-  tree ptr;\n-  tree name = EXPR_WFL_NODE (wfl);\n+  tree ptr, name;\n+\n+  if (TREE_CODE (type_name) == EXPR_WITH_FILE_LOCATION)\n+    name = EXPR_WFL_NODE (type_name);\n+  else if (INCOMPLETE_TYPE_P (type_name))\n+    name = TYPE_NAME (type_name);\n+  else\n+    fatal (\"invalid type name - obtain_incomplete_type\");\n \n   for (ptr = ctxp->incomplete_class; ptr; ptr = TREE_CHAIN (ptr))\n     if (TYPE_NAME (TREE_PURPOSE (ptr)) == name)\n@@ -6143,10 +6153,8 @@ register_incomplete_type (kind, wfl, decl, ptr)\n      int kind;\n      tree wfl, decl, ptr;\n {\n-  jdep *new = malloc (sizeof (jdep));\n+  jdep *new = (jdep *)xmalloc (sizeof (jdep));\n \n-  if (!new)\n-    fatal (\"Can't allocate new jdep - register_incomplete_type\");\n   if (!ptr && kind != JDEP_METHOD_END) /* JDEP_METHOD_END is a mere marker */\n     ptr = obtain_incomplete_type (wfl);\n \n@@ -6195,6 +6203,10 @@ java_check_circular_reference ()\n     }\n }\n \n+/* safe_layout_class just makes sure that we can load a class without\n+   disrupting the current_class, input_file, lineno, etc, information\n+   about the class processed currently.  */\n+\n void\n safe_layout_class (class)\n      tree class;\n@@ -6220,20 +6232,18 @@ jdep_resolve_class (dep)\n {\n   tree decl;\n \n-  if (!JDEP_RESOLVED_P (dep))\n+  if (JDEP_RESOLVED_P (dep))\n+    decl = JDEP_RESOLVED_DECL (dep);\n+  else\n     {\n-      decl = \n-\tresolve_class (JDEP_TO_RESOLVE (dep), JDEP_DECL (dep), JDEP_WFL (dep));\n+      decl = resolve_class (JDEP_TO_RESOLVE (dep), \n+\t\t\t    JDEP_DECL (dep), JDEP_WFL (dep));\n       JDEP_RESOLVED (dep, decl);\n     }\n-  else\n-    decl = JDEP_RESOLVED_DECL (dep);\n-\n+    \n   if (!decl)\n-    {\n-      complete_class_report_errors (dep);\n-      return NULL_TREE;\n-    }\n+    complete_class_report_errors (dep);\n+\n   return decl;\n }\n \n@@ -6486,7 +6496,8 @@ do_resolve_class (class_type, decl, cl)\n }\n \n /* Resolve NAME and lay it out (if not done and if not the current\n-   parsed class). Return a decl node.  */\n+   parsed class). Return a decl node. This function is meant to be\n+   called when type resolution is necessary during the walk pass.  */\n \n static tree\n resolve_and_layout (something, cl)\n@@ -6495,20 +6506,49 @@ resolve_and_layout (something, cl)\n {\n   tree decl;\n \n-  if (TREE_CODE (something) == POINTER_TYPE)\n-    something = TREE_TYPE (something);\n+  /* Don't do that on the current class */\n+  if (something == current_class)\n+    return TYPE_NAME (current_class);\n \n+  /* Don't do anything for void and other primitive types */\n   if (JPRIMITIVE_TYPE_P (something) || something == void_type_node)\n     return NULL_TREE;\n \n+  /* Pointer types can be reall pointer types or fake pointers. When\n+     finding a real pointer, recheck for primitive types */\n+  if (TREE_CODE (something) == POINTER_TYPE)\n+    {\n+      if (TREE_TYPE (something))\n+\t{\n+\t  something = TREE_TYPE (something);\n+\t  if (JPRIMITIVE_TYPE_P (something) || something == void_type_node)\n+\t    return NULL_TREE;\n+\t}\n+      else\n+\tsomething = TYPE_NAME (something);\n+    }\n+\n+  /* Don't do anything for arrays of primitive types */\n+  if (TREE_CODE (something) == RECORD_TYPE && TYPE_ARRAY_P (something)\n+      && JPRIMITIVE_TYPE_P (TYPE_ARRAY_ELEMENT (something)))\n+    return NULL_TREE;\n+\n+  /* If something is not and IDENTIFIER_NODE, it can be a a TYPE_DECL\n+     or a real TYPE */\n   if (TREE_CODE (something) != IDENTIFIER_NODE)\n     something = (TREE_CODE (TYPE_NAME (something)) == TYPE_DECL ?\n \t    DECL_NAME (TYPE_NAME (something)) : TYPE_NAME (something));\n \n-  decl = resolve_no_layout (something, cl);\n-  if (decl && TREE_TYPE (decl) != current_class \n-      && !CLASS_LOADED_P (TREE_TYPE (decl)))\n+  if (!(decl = resolve_no_layout (something, cl)))\n+    return NULL_TREE;\n+\n+  /* Resolve and layout if necessary */\n+  layout_class_methods (TREE_TYPE (decl));\n+  if (CLASS_FROM_SOURCE_P (TREE_TYPE (decl)))\n+    CHECK_METHODS (decl);\n+  if (TREE_TYPE (decl) != current_class && !CLASS_LOADED_P (TREE_TYPE (decl)))\n     safe_layout_class (TREE_TYPE (decl));\n+\n   return decl;\n }\n \n@@ -6528,15 +6568,18 @@ resolve_no_layout (name, cl)\n   return decl;\n }\n \n-/* Called to report errors. Skip leader '[' in a complex array type\n-   description that failed to be resolved. */\n+/* Called when reporting errors. Skip leader '[' in a complex array\n+   type description that failed to be resolved. Append a matching\n+   number of [] at the end of a newly allocated string that contains\n+   the type's name part.  */\n \n static char *\n purify_type_name (name)\n      char *name;\n {\n   while (*name && *name == '[')\n     name++;\n+\n   return name;\n }\n \n@@ -6546,33 +6589,39 @@ static void\n complete_class_report_errors (dep)\n      jdep *dep;\n {\n+  char *name;\n+\n+  if (!JDEP_WFL (dep))\n+    return;\n+\n+  name = IDENTIFIER_POINTER (EXPR_WFL_NODE (JDEP_WFL (dep)));\n   switch (JDEP_KIND (dep))\n     {\n     case JDEP_SUPER:\n       parse_error_context  \n \t(JDEP_WFL (dep), \"Superclass `%s' of class `%s' not found\",\n-\t IDENTIFIER_POINTER (EXPR_WFL_NODE (JDEP_WFL (dep))),\n+\t purify_type_name (name),\n \t IDENTIFIER_POINTER (DECL_NAME (JDEP_DECL (dep))));\n       break;\n     case JDEP_FIELD:\n       parse_error_context\n \t(JDEP_WFL (dep), \"Type `%s' not found in declaration of field `%s'\",\n-\t IDENTIFIER_POINTER (EXPR_WFL_NODE (JDEP_WFL (dep))),\n+\t purify_type_name (name),\n \t IDENTIFIER_POINTER (DECL_NAME (JDEP_DECL (dep))));\n       break;\n     case JDEP_METHOD:\t\t/* Covers arguments */\n       parse_error_context\n \t(JDEP_WFL (dep), \"Type `%s' not found in the declaration of the \"\n \t \"argument `%s' of method `%s'\",\n-\t IDENTIFIER_POINTER (EXPR_WFL_NODE (JDEP_WFL (dep))),\n+\t purify_type_name (name),\n \t IDENTIFIER_POINTER (EXPR_WFL_NODE (JDEP_DECL_WFL (dep))),\n \t IDENTIFIER_POINTER (EXPR_WFL_NODE (JDEP_MISC (dep))));\n       break;\n     case JDEP_METHOD_RETURN:\t/* Covers return type */\n       parse_error_context\n \t(JDEP_WFL (dep), \"Type `%s' not found in the declaration of the \"\n \t \"return type of method `%s'\", \n-\t IDENTIFIER_POINTER (EXPR_WFL_NODE (JDEP_WFL (dep))),\n+\t purify_type_name (name),\n \t IDENTIFIER_POINTER (EXPR_WFL_NODE (JDEP_DECL_WFL (dep))));\n       break;\n     case JDEP_INTERFACE:\n@@ -6662,8 +6711,11 @@ java_get_real_method_name (method_decl)\n   tree method_name = DECL_NAME (method_decl);\n   if (DECL_CONSTRUCTOR_P (method_decl))\n     return init_identifier_node;\n-  else if (ctxp \n-\t   && ctxp->current_parsed_class_un == EXPR_WFL_NODE (method_name))\n+  /* Don't confuse method only bearing the name of their class as\n+     constructors */\n+  else if (ctxp && ctxp->current_parsed_class_un == EXPR_WFL_NODE (method_name)\n+\t   && get_access_flags_from_decl (method_decl) <= ACC_PROTECTED\n+\t   && TREE_TYPE (TREE_TYPE (method_decl)) == void_type_node)\n     return init_identifier_node;\n   else\n     return EXPR_WFL_NODE (method_name);\n@@ -6728,7 +6780,8 @@ java_check_regular_methods (class_decl)\n   if (class == object_type_node)\n     return;\n \n-  TYPE_METHODS (class) = nreverse (TYPE_METHODS (class));\n+  if (!TYPE_NVIRTUALS (class))\n+    TYPE_METHODS (class) = nreverse (TYPE_METHODS (class));\n \n   /* Should take interfaces into account. FIXME */\n   for (method = TYPE_METHODS (class); method; method = TREE_CHAIN (method))\n@@ -6877,11 +6930,15 @@ java_check_regular_methods (class_decl)\n   if (found && !DECL_ARTIFICIAL (found) && saved_found_wfl)\n     DECL_NAME (found) = saved_found_wfl;\n \n-  TYPE_METHODS (class) = nreverse (TYPE_METHODS (class));\n+  if (!TYPE_NVIRTUALS (class))\n+    TYPE_METHODS (class) = nreverse (TYPE_METHODS (class));\n \n   if (!saw_constructor)\n     {\n-      /* No constructor seen, we craft one, at line 0 */\n+      /* No constructor seen, we craft one, at line 0. Since this\n+       operation takes place after we laid methods out\n+       (layout_class_methods), we prepare the its DECL\n+       appropriately. */\n       int flags;\n       tree decl;\n \n@@ -6893,6 +6950,7 @@ java_check_regular_methods (class_decl)\n       decl = create_artificial_method (class, flags, void_type_node, \n \t\t\t\t       init_identifier_node, NULL_TREE);\n       DECL_CONSTRUCTOR_P (decl) = 1;\n+      layout_class_method (TREE_TYPE (class_decl), NULL_TREE, decl, NULL_TREE);\n     }\n }\n \n@@ -7013,18 +7071,6 @@ java_check_abstract_methods (interface_decl)\n     }\n }\n \n-/* Check the method on all the defined classes. Process all the\n-   classes that we compiled from source code for this CU.  */\n-\n-void\n-java_check_methods ()\n-{\n-  tree current;\n-  for (current = ctxp->gclass_list; current; current = TREE_CHAIN (current))\n-    if (CLASS_FROM_SOURCE_P (TREE_TYPE (TREE_VALUE (current))))\n-      CHECK_METHODS (TREE_VALUE (current));\n-}\n-\n /* Lookup methods in interfaces using their name and partial\n    signature. Return a matching method only if their types differ.  */\n \n@@ -7598,14 +7644,14 @@ source_start_java_method (fndecl)\n       tree type = TREE_VALUE (tem);\n       tree name = TREE_PURPOSE (tem);\n       \n-      /* If type is incomplete. Layout can't take place\n-\t now. Create an incomplete decl and ask for the decl to be\n-\t patched later */\n+      /* If type is incomplete. Create an incomplete decl and ask for\n+\t the decl to be patched later */\n       if (INCOMPLETE_TYPE_P (type))\n \t{\n \t  jdep *jdep;\n \t  tree real_type = GET_REAL_TYPE (type);\n \t  parm_decl = build_decl (PARM_DECL, name, real_type);\n+\t  type = obtain_incomplete_type (type);\n \t  register_incomplete_type (JDEP_PARM, NULL_TREE, NULL_TREE, type);\n \t  jdep = CLASSD_LAST (ctxp->classd_list);\n \t  JDEP_MISC (jdep) = name;\n@@ -7784,18 +7830,27 @@ add_stmt_to_compound (existing, type, stmt)\n /* Hold THIS for the scope of the current public method decl.  */\n static tree current_this;\n \n-/* Layout all class found during parsing. Also fixes the order of some\n-   lists.  */\n+/* Layout the methods of all classes loaded in one way on an\n+   other. Check methods of source parsed classes. Then reorder the\n+   fields and layout the classes or the type of all source parsed\n+   classes */\n \n void\n java_layout_classes ()\n {\n   tree current;\n \n-  java_check_methods ();\n-  /* Error reported by the caller */\n-  if (java_error_count)\n-    return;\n+  /* Layout the methods of all classes seen so far */\n+  LAYOUT_SEEN_CLASS_METHODS ();\n+  java_parse_abort_on_error ();\n+  all_class_list = NULL_TREE;\n+\n+  /* Then check the methods of all parsed classes */\n+  for (current = ctxp->gclass_list; current; current = TREE_CHAIN (current))\n+    if (CLASS_FROM_SOURCE_P (TREE_TYPE (TREE_VALUE (current))))\n+      CHECK_METHODS (TREE_VALUE (current));\n+  java_parse_abort_on_error ();\n+\n   for (current = ctxp->gclass_list; current; current = TREE_CHAIN (current))\n     {\n       current_class = TREE_TYPE (TREE_VALUE (current));\n@@ -7805,16 +7860,17 @@ java_layout_classes ()\n       if (TYPE_FIELDS (current_class) && current_class != object_type_node\n \t  && current_class != class_type_node)\n       {\n-\t/* Always leave the dummy field in front if its already there,\n-\t   and layout the class for proper field offets. */\n+\t/* If the dummy field is there, reverse the right fields and\n+\t   just layout the type for proper fields offset */\n \tif (!DECL_NAME (TYPE_FIELDS (current_class)))\n \t  {\n \t    tree fields = TYPE_FIELDS (current_class);\n \t    TREE_CHAIN (fields) = nreverse (TREE_CHAIN (fields));\n \t    TYPE_SIZE (current_class) = NULL_TREE;\n \t    layout_type (current_class);\n \t  }\n-\t/* It's time to layout the class */\n+\t/* We don't have a dummy field, we need to layout the class,\n+           after having reversed the fields */\n \telse\n \t  {\n \t    TYPE_FIELDS (current_class) = \n@@ -7823,12 +7879,8 @@ java_layout_classes ()\n \t    layout_class (current_class);\n \t  }\n       }\n-      \n-      /* Do a layout if necessary */\n-      if (!TYPE_SIZE (current_class) \n-\t  || (current_class == object_type_node)\n-\t  || current_class == class_type_node)\n-\tsafe_layout_class (current_class);\n+      else\n+\tlayout_class (current_class);\n \n       /* From now on, the class is considered completely loaded */\n       CLASS_LOADED_P (current_class) = 1;\n@@ -7837,6 +7889,12 @@ java_layout_classes ()\n       if (java_error_count)\n \treturn;\n     }\n+\n+  /* We might have reloaded classes durign the process of laying out\n+     classes for code generation. We must layout the methods of those\n+     late additions, as constructor checks might use them */\n+  LAYOUT_SEEN_CLASS_METHODS ();\n+  java_parse_abort_on_error ();\n }\n \n /* Expand all methods in all registered classes.  */\n@@ -8100,9 +8158,8 @@ java_expand_finals ()\n void\n java_expand_classes ()\n {\n-  ctxp = ctxp_for_generation;\n-  /* If we found error earlier, we don't want to report then twice. */\n-  if (java_error_count || !ctxp)\n+  java_parse_abort_on_error ();\n+  if (!(ctxp = ctxp_for_generation))\n     return;\n   java_layout_classes ();\n   java_parse_abort_on_error ();\n@@ -8996,7 +9053,8 @@ patch_method_invocation (patch, primary, where, is_static, ret_decl, super)\n \t  /* Class to search is NULL if we're searching the current one */\n \t  if (class_to_search)\n \t    {\n-\t      class_to_search = resolve_no_layout (class_to_search, NULL_TREE);\n+\t      class_to_search = resolve_and_layout (class_to_search, \n+\t\t\t\t\t\t    NULL_TREE);\n \t      if (!class_to_search)\n \t\t{\n \t\t  parse_error_context \n@@ -9817,6 +9875,7 @@ java_complete_tree (node)\n       TREE_OPERAND (node, 0) = cn;\n       TREE_TYPE (node) = void_type_node;\n       CAN_COMPLETE_NORMALLY (node) = 1;\n+      TREE_SIDE_EFFECTS (node) = 1;\n       break;\n \n     case DEFAULT_EXPR:\n@@ -9832,6 +9891,7 @@ java_complete_tree (node)\n       else\n \tSWITCH_HAS_DEFAULT (nn) = 1;\n       TREE_TYPE (node) = void_type_node;\n+      TREE_SIDE_EFFECTS (node) = 1;\n       CAN_COMPLETE_NORMALLY (node) = 1;\n       break;\n "}, {"sha": "b73b8db1dc46d640f674828376e596d31882e595", "filename": "gcc/java/parse.h", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23a79c61921246f3d84df2503555208f2683203e/gcc%2Fjava%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23a79c61921246f3d84df2503555208f2683203e/gcc%2Fjava%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.h?ref=23a79c61921246f3d84df2503555208f2683203e", "patch": "@@ -147,10 +147,10 @@ extern tree stabilize_reference PROTO ((tree));\n     TYPE_NAME (ptr) = name;\t\t\t\\\n   }\n \n-#define INCOMPLETE_TYPE_P(NODE)\t\t\t\t\t\\\n-  ((TREE_CODE (NODE) == TREE_LIST) \t\t\t\t\\\n-   && (TREE_CODE (TREE_PURPOSE (NODE)) == POINTER_TYPE) \t\\\n-   && (TREE_TYPE (TREE_PURPOSE (NODE)) == NULL_TREE))\n+#define INCOMPLETE_TYPE_P(NODE)\t\t\t\t\\\n+  ((TREE_CODE (NODE) == POINTER_TYPE)\t\t\t\\\n+   && !TREE_TYPE (NODE) \t\t\t\t\\\n+   && TREE_CODE (TYPE_NAME (NODE)) == IDENTIFIER_NODE)\n \n /* Set the EMIT_LINE_NOTE flag of a EXPR_WLF to 1 if debug information\n    are requested. Works in the context of a parser rule. */\n@@ -589,13 +589,13 @@ struct parser_ctxt {\n   int parser_ccb_indent;\t     /* Keep track of {} indent, parser */\n   int osb_number;\t\t     /* Keep track of ['s */\n   int minus_seen;\t\t     /* Integral literal overflow */\n-  int lineno;\t\t\t    /* Current lineno */\n-  int java_error_flag;\t\t    /* Report error when true */\n+  int lineno;\t\t\t     /* Current lineno */\n+  int java_error_flag;\t\t     /* Report error when true */\n   int deprecated;\t\t     /* @deprecated tag seen */\n \n   /* This section is defined only if we compile jc1 */\n #ifndef JC1_LITE\n-  tree modifier_ctx [11];\t     /* WFL of modifiers */\n+  tree modifier_ctx [11];\t    /* WFL of modifiers */\n   tree current_class;\t\t    /* Current class */\n   tree current_function_decl;\t    /* Current function decl, save/restore */\n \n@@ -609,30 +609,34 @@ struct parser_ctxt {\n \n   tree package;\t\t\t    /* Defined package ID */\n \n+  /* Those tow list are saved accross file traversal */\n   tree  incomplete_class;\t    /* List of non-complete classes */\n-  tree  current_parsed_class;\t    /* Class currently parsed */\n-  tree  current_parsed_class_un;    /* Curr. parsed class unqualified name */\n+  tree  gclass_list;\t\t    /* All classes seen from source code */\n+\n+  /* These two lists won't survive file traversal */\n   tree  class_list;\t\t    /* List of classes in a CU */\n-  tree  gclass_list;\t\t    /* All classes seen so far. */\n   jdeplist *classd_list;\t    /* Classe dependencies in a CU */\n   \n+  tree  current_parsed_class;\t    /* Class currently parsed */\n+  tree  current_parsed_class_un;    /* Curr. parsed class unqualified name */\n+\n   tree non_static_initialized;\t    /* List of non static initialized fields */\n   tree static_initialized;\t    /* List of static non final initialized */\n \n   tree import_list;\t\t    /* List of import */\n   tree import_demand_list;\t    /* List of import on demand */\n \n-  tree current_loop;\t\t     /* List of the currently nested loops/switches */\n-  tree current_labeled_block;\t     /* List of currently nested\n-\t\t\t\t\tlabeled blocks. */\n+  tree current_loop;\t\t    /* List of the currently nested \n+\t\t\t\t       loops/switches */\n+  tree current_labeled_block;\t    /* List of currently nested\n+\t\t\t\t       labeled blocks. */\n \n-  int pending_block;\t\t     /* Pending block to close */\n+  int pending_block;\t\t    /* Pending block to close */\n \n-  int explicit_constructor_p;\t     /* True when processing an\n-\t\t\t\t\texplicit constructor. This flag is \n-\t\t\t\t\tused to trap illegal argument usage \n-\t\t\t\t\tduring an explicit constructor\n-\t\t\t\t\tinvocation. */\n+  int explicit_constructor_p;\t    /* True when processing an explicit\n+\t\t\t\t       constructor. This flag is used to trap\n+\t\t\t\t       illegal argument usage during an\n+\t\t\t\t       explicit constructor invocation. */\n #endif /* JC1_LITE */\n };\n \n@@ -803,7 +807,6 @@ void safe_layout_class PROTO ((tree));\n void java_complete_class PROTO ((void));\n void java_check_circular_reference PROTO ((void));\n void java_check_final PROTO ((void));\n-void java_check_methods PROTO ((void));\n void java_layout_classes PROTO ((void));\n tree java_method_add_stmt PROTO ((tree, tree));\n char *java_get_line_col PROTO ((char *, int, int));"}, {"sha": "be09d7256d42c714fbba9d05b34e3609e5e6cadc", "filename": "gcc/java/parse.y", "status": "modified", "additions": 137, "deletions": 82, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23a79c61921246f3d84df2503555208f2683203e/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23a79c61921246f3d84df2503555208f2683203e/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=23a79c61921246f3d84df2503555208f2683203e", "patch": "@@ -2070,7 +2070,7 @@ void\n java_push_parser_context ()\n {\n   struct parser_ctxt *new = \n-    (struct parser_ctxt *)malloc(sizeof (struct parser_ctxt));\n+    (struct parser_ctxt *)xmalloc(sizeof (struct parser_ctxt));\n \n   bzero (new, sizeof (struct parser_ctxt));\n   new->next = ctxp;\n@@ -2111,7 +2111,7 @@ java_parser_context_restore_global ()\n   current_class = ctxp->current_class;\n   input_filename = ctxp->filename;\n   current_function_decl = ctxp->current_function_decl;\n-  if (extra_ctxp_pushed_p)\n+  if (!ctxp->next && extra_ctxp_pushed_p)\n     {\n       java_pop_parser_context (0);\n       extra_ctxp_pushed_p = 0;\n@@ -2570,8 +2570,9 @@ maybe_create_class_interface_decl (decl, qualified_name, cl)\n   TREE_CHAIN (decl) = ctxp->class_list;\n   ctxp->class_list = decl;\n \n-  /* Create a new node in the global list */\n+  /* Create a new nodes in the global lists */\n   ctxp->gclass_list = tree_cons (NULL_TREE, decl, ctxp->gclass_list);\n+  all_class_list = tree_cons (NULL_TREE, decl, all_class_list);\n \n   /* Install a new dependency list element */\n   create_jdep_list (ctxp);\n@@ -3084,8 +3085,7 @@ method_header (flags, type, mdecl, throws)\n \t  tree itype;\n \t  patch_stage = JDEP_METHOD_RETURN;\n \t  itype = register_incomplete_type (patch_stage, type, id, NULL_TREE);\n-\t  TREE_TYPE (meth) = (TREE_CODE (itype) == TREE_LIST ? \n-\t\t\t      TREE_PURPOSE (itype) : itype);\n+\t  TREE_TYPE (meth) = GET_REAL_TYPE (itype);\n \t}\n     }\n   else\n@@ -3323,6 +3323,7 @@ method_declarator (id, list)\n       tree name = EXPR_WFL_NODE (wfl_name);\n       tree already, arg_node;\n       tree type_wfl = NULL_TREE;\n+      tree real_type;\n \n       /* Obtain a suitable type for resolution, if necessary */\n       SET_TYPE_FOR_RESOLUTION (type, type_wfl, must_chain);\n@@ -3331,8 +3332,13 @@ method_declarator (id, list)\n       type = build_array_from_name (type, type_wfl, name, &name);\n       EXPR_WFL_NODE (wfl_name) = name;\n \n-      if (TREE_CODE (type) == RECORD_TYPE)\n-\ttype = promote_type (type);\n+      real_type = GET_REAL_TYPE (type);\n+      if (TREE_CODE (real_type) == RECORD_TYPE)\n+\t{\n+\t  real_type = promote_type (real_type);\n+\t  if (TREE_CODE (type) == TREE_LIST)\n+\t    TREE_PURPOSE (type) = real_type;\n+\t}\n \n       /* Check redefinition */\n       for (already = arg_types; already; already = TREE_CHAIN (already))\n@@ -3358,7 +3364,7 @@ method_declarator (id, list)\n \t}\n \n       /* The argument node: a name and a (possibly) incomplete type */\n-      arg_node = build_tree_list (name, type);\n+      arg_node = build_tree_list (name, real_type);\n       if (jdep)\n \tJDEP_GET_PATCH (jdep) = &TREE_VALUE (arg_node);\n       TREE_CHAIN (arg_node) = arg_types;\n@@ -3476,11 +3482,7 @@ static void\n create_jdep_list (ctxp)\n      struct parser_ctxt *ctxp;\n {\n-  jdeplist *new = malloc (sizeof (jdeplist));\t\n-  \n-  if (!new)\n-    fatal (\"Can't alloc jdeplist - create_jdep_list\");\n-    \n+  jdeplist *new = (jdeplist *)xmalloc (sizeof (jdeplist));\t\n   new->first = new->last = NULL;\n   new->next = ctxp->classd_list;\n   ctxp->classd_list = new;\n@@ -3500,14 +3502,22 @@ reverse_jdep_list (ctxp)\n   return prev;\n }\n \n-/* Create a fake pointer based on the ID stored in the WFL */\n+/* Create a fake pointer based on the ID stored in\n+   TYPE_NAME. TYPE_NAME can be a WFL or a incomplete type asking to be\n+   registered again. */\n \n static tree\n-obtain_incomplete_type (wfl)\n-     tree wfl;\n+obtain_incomplete_type (type_name)\n+     tree type_name;\n {\n-  tree ptr;\n-  tree name = EXPR_WFL_NODE (wfl);\n+  tree ptr, name;\n+\n+  if (TREE_CODE (type_name) == EXPR_WITH_FILE_LOCATION)\n+    name = EXPR_WFL_NODE (type_name);\n+  else if (INCOMPLETE_TYPE_P (type_name))\n+    name = TYPE_NAME (type_name);\n+  else\n+    fatal (\"invalid type name - obtain_incomplete_type\");\n \n   for (ptr = ctxp->incomplete_class; ptr; ptr = TREE_CHAIN (ptr))\n     if (TYPE_NAME (TREE_PURPOSE (ptr)) == name)\n@@ -3538,10 +3548,8 @@ register_incomplete_type (kind, wfl, decl, ptr)\n      int kind;\n      tree wfl, decl, ptr;\n {\n-  jdep *new = malloc (sizeof (jdep));\n+  jdep *new = (jdep *)xmalloc (sizeof (jdep));\n \n-  if (!new)\n-    fatal (\"Can't allocate new jdep - register_incomplete_type\");\n   if (!ptr && kind != JDEP_METHOD_END) /* JDEP_METHOD_END is a mere marker */\n     ptr = obtain_incomplete_type (wfl);\n \n@@ -3590,6 +3598,10 @@ java_check_circular_reference ()\n     }\n }\n \n+/* safe_layout_class just makes sure that we can load a class without\n+   disrupting the current_class, input_file, lineno, etc, information\n+   about the class processed currently.  */\n+\n void\n safe_layout_class (class)\n      tree class;\n@@ -3615,20 +3627,18 @@ jdep_resolve_class (dep)\n {\n   tree decl;\n \n-  if (!JDEP_RESOLVED_P (dep))\n+  if (JDEP_RESOLVED_P (dep))\n+    decl = JDEP_RESOLVED_DECL (dep);\n+  else\n     {\n-      decl = \n-\tresolve_class (JDEP_TO_RESOLVE (dep), JDEP_DECL (dep), JDEP_WFL (dep));\n+      decl = resolve_class (JDEP_TO_RESOLVE (dep), \n+\t\t\t    JDEP_DECL (dep), JDEP_WFL (dep));\n       JDEP_RESOLVED (dep, decl);\n     }\n-  else\n-    decl = JDEP_RESOLVED_DECL (dep);\n-\n+    \n   if (!decl)\n-    {\n-      complete_class_report_errors (dep);\n-      return NULL_TREE;\n-    }\n+    complete_class_report_errors (dep);\n+\n   return decl;\n }\n \n@@ -3881,7 +3891,8 @@ do_resolve_class (class_type, decl, cl)\n }\n \n /* Resolve NAME and lay it out (if not done and if not the current\n-   parsed class). Return a decl node.  */\n+   parsed class). Return a decl node. This function is meant to be\n+   called when type resolution is necessary during the walk pass.  */\n \n static tree\n resolve_and_layout (something, cl)\n@@ -3890,20 +3901,49 @@ resolve_and_layout (something, cl)\n {\n   tree decl;\n \n-  if (TREE_CODE (something) == POINTER_TYPE)\n-    something = TREE_TYPE (something);\n+  /* Don't do that on the current class */\n+  if (something == current_class)\n+    return TYPE_NAME (current_class);\n \n+  /* Don't do anything for void and other primitive types */\n   if (JPRIMITIVE_TYPE_P (something) || something == void_type_node)\n     return NULL_TREE;\n \n+  /* Pointer types can be reall pointer types or fake pointers. When\n+     finding a real pointer, recheck for primitive types */\n+  if (TREE_CODE (something) == POINTER_TYPE)\n+    {\n+      if (TREE_TYPE (something))\n+\t{\n+\t  something = TREE_TYPE (something);\n+\t  if (JPRIMITIVE_TYPE_P (something) || something == void_type_node)\n+\t    return NULL_TREE;\n+\t}\n+      else\n+\tsomething = TYPE_NAME (something);\n+    }\n+\n+  /* Don't do anything for arrays of primitive types */\n+  if (TREE_CODE (something) == RECORD_TYPE && TYPE_ARRAY_P (something)\n+      && JPRIMITIVE_TYPE_P (TYPE_ARRAY_ELEMENT (something)))\n+    return NULL_TREE;\n+\n+  /* If something is not and IDENTIFIER_NODE, it can be a a TYPE_DECL\n+     or a real TYPE */\n   if (TREE_CODE (something) != IDENTIFIER_NODE)\n     something = (TREE_CODE (TYPE_NAME (something)) == TYPE_DECL ?\n \t    DECL_NAME (TYPE_NAME (something)) : TYPE_NAME (something));\n \n-  decl = resolve_no_layout (something, cl);\n-  if (decl && TREE_TYPE (decl) != current_class \n-      && !CLASS_LOADED_P (TREE_TYPE (decl)))\n+  if (!(decl = resolve_no_layout (something, cl)))\n+    return NULL_TREE;\n+\n+  /* Resolve and layout if necessary */\n+  layout_class_methods (TREE_TYPE (decl));\n+  if (CLASS_FROM_SOURCE_P (TREE_TYPE (decl)))\n+    CHECK_METHODS (decl);\n+  if (TREE_TYPE (decl) != current_class && !CLASS_LOADED_P (TREE_TYPE (decl)))\n     safe_layout_class (TREE_TYPE (decl));\n+\n   return decl;\n }\n \n@@ -3923,8 +3963,8 @@ resolve_no_layout (name, cl)\n   return decl;\n }\n \n-/* Called to report errors. Skip leader '[' in a complex array type\n-   description that failed to be resolved. */\n+/* Called when reporting errors. Skip leader '[' in a complex array\n+   type description that failed to be resolved.  */\n \n static char *\n purify_type_name (name)\n@@ -3941,33 +3981,39 @@ static void\n complete_class_report_errors (dep)\n      jdep *dep;\n {\n+  char *name;\n+\n+  if (!JDEP_WFL (dep))\n+    return;\n+\n+  name = IDENTIFIER_POINTER (EXPR_WFL_NODE (JDEP_WFL (dep)));\n   switch (JDEP_KIND (dep))\n     {\n     case JDEP_SUPER:\n       parse_error_context  \n \t(JDEP_WFL (dep), \"Superclass `%s' of class `%s' not found\",\n-\t IDENTIFIER_POINTER (EXPR_WFL_NODE (JDEP_WFL (dep))),\n+\t purify_type_name (name),\n \t IDENTIFIER_POINTER (DECL_NAME (JDEP_DECL (dep))));\n       break;\n     case JDEP_FIELD:\n       parse_error_context\n \t(JDEP_WFL (dep), \"Type `%s' not found in declaration of field `%s'\",\n-\t IDENTIFIER_POINTER (EXPR_WFL_NODE (JDEP_WFL (dep))),\n+\t purify_type_name (name),\n \t IDENTIFIER_POINTER (DECL_NAME (JDEP_DECL (dep))));\n       break;\n     case JDEP_METHOD:\t\t/* Covers arguments */\n       parse_error_context\n \t(JDEP_WFL (dep), \"Type `%s' not found in the declaration of the \"\n \t \"argument `%s' of method `%s'\",\n-\t IDENTIFIER_POINTER (EXPR_WFL_NODE (JDEP_WFL (dep))),\n+\t purify_type_name (name),\n \t IDENTIFIER_POINTER (EXPR_WFL_NODE (JDEP_DECL_WFL (dep))),\n \t IDENTIFIER_POINTER (EXPR_WFL_NODE (JDEP_MISC (dep))));\n       break;\n     case JDEP_METHOD_RETURN:\t/* Covers return type */\n       parse_error_context\n \t(JDEP_WFL (dep), \"Type `%s' not found in the declaration of the \"\n \t \"return type of method `%s'\", \n-\t IDENTIFIER_POINTER (EXPR_WFL_NODE (JDEP_WFL (dep))),\n+\t purify_type_name (name),\n \t IDENTIFIER_POINTER (EXPR_WFL_NODE (JDEP_DECL_WFL (dep))));\n       break;\n     case JDEP_INTERFACE:\n@@ -4057,8 +4103,11 @@ java_get_real_method_name (method_decl)\n   tree method_name = DECL_NAME (method_decl);\n   if (DECL_CONSTRUCTOR_P (method_decl))\n     return init_identifier_node;\n-  else if (ctxp \n-\t   && ctxp->current_parsed_class_un == EXPR_WFL_NODE (method_name))\n+  /* Don't confuse method only bearing the name of their class as\n+     constructors */\n+  else if (ctxp && ctxp->current_parsed_class_un == EXPR_WFL_NODE (method_name)\n+\t   && get_access_flags_from_decl (method_decl) <= ACC_PROTECTED\n+\t   && TREE_TYPE (TREE_TYPE (method_decl)) == void_type_node)\n     return init_identifier_node;\n   else\n     return EXPR_WFL_NODE (method_name);\n@@ -4123,7 +4172,8 @@ java_check_regular_methods (class_decl)\n   if (class == object_type_node)\n     return;\n \n-  TYPE_METHODS (class) = nreverse (TYPE_METHODS (class));\n+  if (!TYPE_NVIRTUALS (class))\n+    TYPE_METHODS (class) = nreverse (TYPE_METHODS (class));\n \n   /* Should take interfaces into account. FIXME */\n   for (method = TYPE_METHODS (class); method; method = TREE_CHAIN (method))\n@@ -4272,11 +4322,15 @@ java_check_regular_methods (class_decl)\n   if (found && !DECL_ARTIFICIAL (found) && saved_found_wfl)\n     DECL_NAME (found) = saved_found_wfl;\n \n-  TYPE_METHODS (class) = nreverse (TYPE_METHODS (class));\n+  if (!TYPE_NVIRTUALS (class))\n+    TYPE_METHODS (class) = nreverse (TYPE_METHODS (class));\n \n   if (!saw_constructor)\n     {\n-      /* No constructor seen, we craft one, at line 0 */\n+      /* No constructor seen, we craft one, at line 0. Since this\n+       operation takes place after we laid methods out\n+       (layout_class_methods), we prepare the its DECL\n+       appropriately. */\n       int flags;\n       tree decl;\n \n@@ -4288,6 +4342,7 @@ java_check_regular_methods (class_decl)\n       decl = create_artificial_method (class, flags, void_type_node, \n \t\t\t\t       init_identifier_node, NULL_TREE);\n       DECL_CONSTRUCTOR_P (decl) = 1;\n+      layout_class_method (TREE_TYPE (class_decl), NULL_TREE, decl, NULL_TREE);\n     }\n }\n \n@@ -4408,18 +4463,6 @@ java_check_abstract_methods (interface_decl)\n     }\n }\n \n-/* Check the method on all the defined classes. Process all the\n-   classes that we compiled from source code for this CU.  */\n-\n-void\n-java_check_methods ()\n-{\n-  tree current;\n-  for (current = ctxp->gclass_list; current; current = TREE_CHAIN (current))\n-    if (CLASS_FROM_SOURCE_P (TREE_TYPE (TREE_VALUE (current))))\n-      CHECK_METHODS (TREE_VALUE (current));\n-}\n-\n /* Lookup methods in interfaces using their name and partial\n    signature. Return a matching method only if their types differ.  */\n \n@@ -4993,14 +5036,14 @@ source_start_java_method (fndecl)\n       tree type = TREE_VALUE (tem);\n       tree name = TREE_PURPOSE (tem);\n       \n-      /* If type is incomplete. Layout can't take place\n-\t now. Create an incomplete decl and ask for the decl to be\n-\t patched later */\n+      /* If type is incomplete. Create an incomplete decl and ask for\n+\t the decl to be patched later */\n       if (INCOMPLETE_TYPE_P (type))\n \t{\n \t  jdep *jdep;\n \t  tree real_type = GET_REAL_TYPE (type);\n \t  parm_decl = build_decl (PARM_DECL, name, real_type);\n+\t  type = obtain_incomplete_type (type);\n \t  register_incomplete_type (JDEP_PARM, NULL_TREE, NULL_TREE, type);\n \t  jdep = CLASSD_LAST (ctxp->classd_list);\n \t  JDEP_MISC (jdep) = name;\n@@ -5179,18 +5222,27 @@ add_stmt_to_compound (existing, type, stmt)\n /* Hold THIS for the scope of the current public method decl.  */\n static tree current_this;\n \n-/* Layout all class found during parsing. Also fixes the order of some\n-   lists.  */\n+/* Layout the methods of all classes loaded in one way on an\n+   other. Check methods of source parsed classes. Then reorder the\n+   fields and layout the classes or the type of all source parsed\n+   classes */\n \n void\n java_layout_classes ()\n {\n   tree current;\n \n-  java_check_methods ();\n-  /* Error reported by the caller */\n-  if (java_error_count)\n-    return;\n+  /* Layout the methods of all classes seen so far */\n+  LAYOUT_SEEN_CLASS_METHODS ();\n+  java_parse_abort_on_error ();\n+  all_class_list = NULL_TREE;\n+\n+  /* Then check the methods of all parsed classes */\n+  for (current = ctxp->gclass_list; current; current = TREE_CHAIN (current))\n+    if (CLASS_FROM_SOURCE_P (TREE_TYPE (TREE_VALUE (current))))\n+      CHECK_METHODS (TREE_VALUE (current));\n+  java_parse_abort_on_error ();\n+\n   for (current = ctxp->gclass_list; current; current = TREE_CHAIN (current))\n     {\n       current_class = TREE_TYPE (TREE_VALUE (current));\n@@ -5200,16 +5252,17 @@ java_layout_classes ()\n       if (TYPE_FIELDS (current_class) && current_class != object_type_node\n \t  && current_class != class_type_node)\n       {\n-\t/* Always leave the dummy field in front if its already there,\n-\t   and layout the class for proper field offets. */\n+\t/* If the dummy field is there, reverse the right fields and\n+\t   just layout the type for proper fields offset */\n \tif (!DECL_NAME (TYPE_FIELDS (current_class)))\n \t  {\n \t    tree fields = TYPE_FIELDS (current_class);\n \t    TREE_CHAIN (fields) = nreverse (TREE_CHAIN (fields));\n \t    TYPE_SIZE (current_class) = NULL_TREE;\n \t    layout_type (current_class);\n \t  }\n-\t/* It's time to layout the class */\n+\t/* We don't have a dummy field, we need to layout the class,\n+           after having reversed the fields */\n \telse\n \t  {\n \t    TYPE_FIELDS (current_class) = \n@@ -5218,12 +5271,8 @@ java_layout_classes ()\n \t    layout_class (current_class);\n \t  }\n       }\n-      \n-      /* Do a layout if necessary */\n-      if (!TYPE_SIZE (current_class) \n-\t  || (current_class == object_type_node)\n-\t  || current_class == class_type_node)\n-\tsafe_layout_class (current_class);\n+      else\n+\tlayout_class (current_class);\n \n       /* From now on, the class is considered completely loaded */\n       CLASS_LOADED_P (current_class) = 1;\n@@ -5232,6 +5281,12 @@ java_layout_classes ()\n       if (java_error_count)\n \treturn;\n     }\n+\n+  /* We might have reloaded classes durign the process of laying out\n+     classes for code generation. We must layout the methods of those\n+     late additions, as constructor checks might use them */\n+  LAYOUT_SEEN_CLASS_METHODS ();\n+  java_parse_abort_on_error ();\n }\n \n /* Expand all methods in all registered classes.  */\n@@ -5495,9 +5550,8 @@ java_expand_finals ()\n void\n java_expand_classes ()\n {\n-  ctxp = ctxp_for_generation;\n-  /* If we found error earlier, we don't want to report then twice. */\n-  if (java_error_count || !ctxp)\n+  java_parse_abort_on_error ();\n+  if (!(ctxp = ctxp_for_generation))\n     return;\n   java_layout_classes ();\n   java_parse_abort_on_error ();\n@@ -6391,7 +6445,8 @@ patch_method_invocation (patch, primary, where, is_static, ret_decl, super)\n \t  /* Class to search is NULL if we're searching the current one */\n \t  if (class_to_search)\n \t    {\n-\t      class_to_search = resolve_no_layout (class_to_search, NULL_TREE);\n+\t      class_to_search = resolve_and_layout (class_to_search, \n+\t\t\t\t\t\t    NULL_TREE);\n \t      if (!class_to_search)\n \t\t{\n \t\t  parse_error_context "}]}