{"sha": "47b6f9825f7867fcd91e3150ce6f95676ee3985d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDdiNmY5ODI1Zjc4NjdmY2Q5MWUzMTUwY2U2Zjk1Njc2ZWUzOTg1ZA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2014-12-19T04:05:59Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2014-12-19T04:05:59Z"}, "message": "compiler: Avoid multiple evaluations in interface conversions.\n\nAdded assertions for cases that might lead to multiple\nevaluations, and fixed all the problems I saw.\n\nTest case already in master Go testsuite\n(https://go-review.googlesource.com/#/c/1710/).\n\nFrom-SVN: r218884", "tree": {"sha": "f0c7bc42b43b5f309e19843219ffc246003ea207", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f0c7bc42b43b5f309e19843219ffc246003ea207"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/47b6f9825f7867fcd91e3150ce6f95676ee3985d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47b6f9825f7867fcd91e3150ce6f95676ee3985d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47b6f9825f7867fcd91e3150ce6f95676ee3985d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47b6f9825f7867fcd91e3150ce6f95676ee3985d/comments", "author": null, "committer": null, "parents": [{"sha": "0f3e3f28e9c7bcf0fbaeffa00dc60f2a908d5d48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f3e3f28e9c7bcf0fbaeffa00dc60f2a908d5d48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f3e3f28e9c7bcf0fbaeffa00dc60f2a908d5d48"}], "stats": {"total": 175, "additions": 164, "deletions": 11}, "files": [{"sha": "6f5acc1f92e19c8c68c9c052d3bb444b7fcd6310", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 95, "deletions": 9, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47b6f9825f7867fcd91e3150ce6f95676ee3985d/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47b6f9825f7867fcd91e3150ce6f95676ee3985d/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=47b6f9825f7867fcd91e3150ce6f95676ee3985d", "patch": "@@ -302,6 +302,9 @@ Expression::convert_interface_to_interface(Type *lhs_type, Expression* rhs,\n                                            bool for_type_guard,\n                                            Location location)\n {\n+  if (Type::are_identical(lhs_type, rhs->type(), false, NULL))\n+    return rhs;\n+\n   Interface_type* lhs_interface_type = lhs_type->interface_type();\n   bool lhs_is_empty = lhs_interface_type->is_empty();\n \n@@ -313,6 +316,9 @@ Expression::convert_interface_to_interface(Type *lhs_type, Expression* rhs,\n   // to do a runtime check, although we still need to build a new\n   // method table.\n \n+  // We are going to evaluate RHS multiple times.\n+  go_assert(rhs->is_variable());\n+\n   // Get the type descriptor for the right hand side.  This will be\n   // NULL for a nil interface.\n   Expression* rhs_type_expr = Expression::get_interface_type_descriptor(rhs);\n@@ -355,6 +361,9 @@ Expression*\n Expression::convert_interface_to_type(Type *lhs_type, Expression* rhs,\n                                       Location location)\n {\n+  // We are going to evaluate RHS multiple times.\n+  go_assert(rhs->is_variable());\n+\n   // Call a function to check that the type is valid.  The function\n   // will panic with an appropriate runtime type error if the type is\n   // not valid.\n@@ -3155,8 +3164,7 @@ Type_conversion_expression::do_flatten(Gogo*, Named_object*,\n {\n   if (((this->type()->is_string_type()\n         && this->expr_->type()->is_slice_type())\n-       || (this->type()->interface_type() != NULL\n-           && this->expr_->type()->interface_type() != NULL))\n+       || this->expr_->type()->interface_type() != NULL)\n       && !this->expr_->is_variable())\n     {\n       Temporary_statement* temp =\n@@ -3551,7 +3559,8 @@ Unsafe_type_conversion_expression::do_get_backend(Translate_context* context)\n               || et->function_type() != NULL\n               || et->points_to() != NULL\n               || et->map_type() != NULL\n-              || et->channel_type() != NULL);\n+              || et->channel_type() != NULL\n+\t      || et->is_nil_type());\n   else\n     go_unreachable();\n \n@@ -8782,12 +8791,17 @@ Call_expression::do_flatten(Gogo* gogo, Named_object*,\n \t  else\n \t    {\n \t      Location loc = (*pa)->location();\n-\t      Expression* arg =\n-\t\tExpression::convert_for_assignment(gogo, pp->type(), *pa, loc);\n-\t      Temporary_statement* temp =\n-\t\tStatement::make_temporary(pp->type(), arg, loc);\n-\t      inserter->insert(temp);\n-\t      args->push_back(Expression::make_temporary_reference(temp, loc));\n+\t      Expression* arg = *pa;\n+\t      if (!arg->is_variable())\n+\t\t{\n+\t\t  Temporary_statement *temp =\n+\t\t    Statement::make_temporary(NULL, arg, loc);\n+\t\t  inserter->insert(temp);\n+\t\t  arg = Expression::make_temporary_reference(temp, loc);\n+\t\t}\n+\t      arg = Expression::convert_for_assignment(gogo, pp->type(), arg,\n+\t\t\t\t\t\t       loc);\n+\t      args->push_back(arg);\n \t    }\n \t}\n       delete this->args_;\n@@ -11602,6 +11616,9 @@ class Struct_construction_expression : public Expression\n     return ret;\n   }\n \n+  Expression*\n+  do_flatten(Gogo*, Named_object*, Statement_inserter*);\n+\n   Bexpression*\n   do_get_backend(Translate_context*);\n \n@@ -11776,6 +11793,39 @@ Struct_construction_expression::do_check_types(Gogo*)\n   go_assert(pv == this->vals_->end());\n }\n \n+// Flatten a struct construction expression.  Store the values into\n+// temporaries in case they need interface conversion.\n+\n+Expression*\n+Struct_construction_expression::do_flatten(Gogo*, Named_object*,\n+\t\t\t\t\t   Statement_inserter* inserter)\n+{\n+  if (this->vals_ == NULL)\n+    return this;\n+\n+  // If this is a constant struct, we don't need temporaries.\n+  if (this->is_constant_struct())\n+    return this;\n+\n+  Location loc = this->location();\n+  for (Expression_list::iterator pv = this->vals_->begin();\n+       pv != this->vals_->end();\n+       ++pv)\n+    {\n+      if (*pv != NULL)\n+\t{\n+\t  if (!(*pv)->is_variable())\n+\t    {\n+\t      Temporary_statement* temp =\n+\t\tStatement::make_temporary(NULL, *pv, loc);\n+\t      inserter->insert(temp);\n+\t      *pv = Expression::make_temporary_reference(temp, loc);\n+\t    }\n+\t}\n+    }\n+  return this;\n+}\n+\n // Return the backend representation for constructing a struct.\n \n Bexpression*\n@@ -11909,6 +11959,9 @@ class Array_construction_expression : public Expression\n   vals()\n   { return this->vals_; }\n \n+  Expression*\n+  do_flatten(Gogo*, Named_object*, Statement_inserter*);\n+\n   // Get the backend constructor for the array values.\n   Bexpression*\n   get_constructor(Translate_context* context, Btype* btype);\n@@ -12024,6 +12077,39 @@ Array_construction_expression::do_check_types(Gogo*)\n     }\n }\n \n+// Flatten an array construction expression.  Store the values into\n+// temporaries in case they need interface conversion.\n+\n+Expression*\n+Array_construction_expression::do_flatten(Gogo*, Named_object*,\n+\t\t\t\t\t   Statement_inserter* inserter)\n+{\n+  if (this->vals_ == NULL)\n+    return this;\n+\n+  // If this is a constant array, we don't need temporaries.\n+  if (this->is_constant_array())\n+    return this;\n+\n+  Location loc = this->location();\n+  for (Expression_list::iterator pv = this->vals_->begin();\n+       pv != this->vals_->end();\n+       ++pv)\n+    {\n+      if (*pv != NULL)\n+\t{\n+\t  if (!(*pv)->is_variable())\n+\t    {\n+\t      Temporary_statement* temp =\n+\t\tStatement::make_temporary(NULL, *pv, loc);\n+\t      inserter->insert(temp);\n+\t      *pv = Expression::make_temporary_reference(temp, loc);\n+\t    }\n+\t}\n+    }\n+  return this;\n+}\n+\n // Get a constructor expression for the array values.\n \n Bexpression*"}, {"sha": "49be6af61f21be1a6a72455c510c2ebb9b2b2722", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47b6f9825f7867fcd91e3150ce6f95676ee3985d/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47b6f9825f7867fcd91e3150ce6f95676ee3985d/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=47b6f9825f7867fcd91e3150ce6f95676ee3985d", "patch": "@@ -5830,6 +5830,21 @@ Variable::flatten_init_expression(Gogo* gogo, Named_object* function,\n \n       gogo->flatten_expression(function, inserter, &this->init_);\n \n+      // If an interface conversion is needed, we need a temporary\n+      // variable.\n+      if (this->type_ != NULL\n+\t  && !Type::are_identical(this->type_, this->init_->type(), false,\n+\t\t\t\t  NULL)\n+\t  && this->init_->type()->interface_type() != NULL\n+\t  && !this->init_->is_variable())\n+\t{\n+\t  Temporary_statement* temp =\n+\t    Statement::make_temporary(NULL, this->init_, this->location_);\n+\t  inserter->insert(temp);\n+\t  this->init_ = Expression::make_temporary_reference(temp,\n+\t\t\t\t\t\t\t     this->location_);\n+\t}\n+\n       this->seen_ = false;\n       this->init_is_flattened_ = true;\n     }"}, {"sha": "c84df3b5a3e0a7b2d37c7db5867db80227aff407", "filename": "gcc/go/gofrontend/statements.cc", "status": "modified", "additions": 51, "deletions": 2, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47b6f9825f7867fcd91e3150ce6f95676ee3985d/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47b6f9825f7867fcd91e3150ce6f95676ee3985d/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc?ref=47b6f9825f7867fcd91e3150ce6f95676ee3985d", "patch": "@@ -521,6 +521,9 @@ class Assignment_statement : public Statement\n   void\n   do_check_types(Gogo*);\n \n+  Statement*\n+  do_flatten(Gogo*, Named_object*, Block*, Statement_inserter*);\n+\n   Bstatement*\n   do_get_backend(Translate_context*);\n \n@@ -606,6 +609,28 @@ Assignment_statement::do_check_types(Gogo*)\n     this->set_is_error();\n }\n \n+// Flatten an assignment statement.  We may need a temporary for\n+// interface conversion.\n+\n+Statement*\n+Assignment_statement::do_flatten(Gogo*, Named_object*, Block*,\n+\t\t\t\t Statement_inserter* inserter)\n+{\n+  if (!this->lhs_->is_sink_expression()\n+      && !Type::are_identical(this->lhs_->type(), this->rhs_->type(),\n+\t\t\t      false, NULL)\n+      && this->rhs_->type()->interface_type() != NULL\n+      && !this->rhs_->is_variable())\n+    {\n+      Temporary_statement* temp =\n+\tStatement::make_temporary(NULL, this->rhs_, this->location());\n+      inserter->insert(temp);\n+      this->rhs_ = Expression::make_temporary_reference(temp,\n+\t\t\t\t\t\t\tthis->location());\n+    }\n+  return this;\n+}\n+\n // Convert an assignment statement to the backend representation.\n \n Bstatement*\n@@ -2480,12 +2505,13 @@ Thunk_statement::build_thunk(Gogo* gogo, const std::string& thunk_name)\n   gogo->add_block(b, location);\n \n   gogo->lower_block(function, b);\n-  gogo->flatten_block(function, b);\n \n   // We already ran the determine_types pass, so we need to run it\n   // just for the call statement now.  The other types are known.\n   call_statement->determine_types();\n \n+  gogo->flatten_block(function, b);\n+\n   if (may_call_recover || recover_arg != NULL)\n     {\n       // Dig up the call expression, which may have been changed\n@@ -4412,6 +4438,27 @@ Send_statement::do_check_types(Gogo*)\n     }\n }\n \n+// Flatten a send statement.  We may need a temporary for interface\n+// conversion.\n+\n+Statement*\n+Send_statement::do_flatten(Gogo*, Named_object*, Block*,\n+\t\t\t   Statement_inserter* inserter)\n+{\n+  Type* element_type = this->channel_->type()->channel_type()->element_type();\n+  if (!Type::are_identical(element_type, this->val_->type(), false, NULL)\n+      && this->val_->type()->interface_type() != NULL\n+      && !this->val_->is_variable())\n+    {\n+      Temporary_statement* temp =\n+\tStatement::make_temporary(NULL, this->val_, this->location());\n+      inserter->insert(temp);\n+      this->val_ = Expression::make_temporary_reference(temp,\n+\t\t\t\t\t\t\tthis->location());\n+    }\n+  return this;\n+}\n+\n // Convert a send statement to the backend representation.\n \n Bstatement*\n@@ -4421,7 +4468,9 @@ Send_statement::do_get_backend(Translate_context* context)\n \n   Channel_type* channel_type = this->channel_->type()->channel_type();\n   Type* element_type = channel_type->element_type();\n-  Expression* val = Expression::make_cast(element_type, this->val_, loc);\n+  Expression* val = Expression::convert_for_assignment(context->gogo(),\n+\t\t\t\t\t\t       element_type,\n+\t\t\t\t\t\t       this->val_, loc);\n \n   bool is_small;\n   bool can_take_address;"}, {"sha": "aaad66e7fcab405d524f9df440ab75f9c518ebfa", "filename": "gcc/go/gofrontend/statements.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47b6f9825f7867fcd91e3150ce6f95676ee3985d/gcc%2Fgo%2Fgofrontend%2Fstatements.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47b6f9825f7867fcd91e3150ce6f95676ee3985d/gcc%2Fgo%2Fgofrontend%2Fstatements.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.h?ref=47b6f9825f7867fcd91e3150ce6f95676ee3985d", "patch": "@@ -704,6 +704,9 @@ class Send_statement : public Statement\n   void\n   do_check_types(Gogo*);\n \n+  Statement*\n+  do_flatten(Gogo*, Named_object*, Block*, Statement_inserter*);\n+\n   Bstatement*\n   do_get_backend(Translate_context*);\n "}]}