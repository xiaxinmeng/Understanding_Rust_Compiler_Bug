{"sha": "f04b8d6927ad8374c40a3412eeda8f3be18e9fc0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjA0YjhkNjkyN2FkODM3NGM0MGEzNDEyZWVkYThmM2JlMThlOWZjMA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2012-04-30T07:50:07Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2012-04-30T07:50:07Z"}, "message": "gigi.h (mark_out_of_scope): Delete.\n\n\t* gcc-interface/gigi.h (mark_out_of_scope): Delete.\n\t(destroy_gnat_to_gnu): Declare.\n\t(destroy_dummy_type): Likewise.\n\t* gcc-interface/decl.c (mark_out_of_scope): Delete.\n\t* gcc-interface/utils.c (destroy_gnat_to_gnu): New function.\n\t(destroy_dummy_type): Likewise.\n\t* gcc-interface/trans.c (gnat_validate_uc_list): New variable.\n\t(gigi): Call validate_unchecked_conversion on gnat_validate_uc_list\n\tafter the translation is completed. \u00a0Call destroy_gnat_to_gnu and\n\tdestroy_dummy_type at the end.\n\t(Subprogram_Body_to_gnu): Do not call mark_out_of_scope.\n\t(gnat_to_gnu) <N_Block_Statement>: Likewise.\n\t<N_Validate_Unchecked_Conversion>: Do not process the node, only push\n\tit onto gnat_validate_uc_list.\n\t(validate_unchecked_conversion): New function.\n\nFrom-SVN: r186956", "tree": {"sha": "37a384e07b2e25f70080174ef8e49ccde609ad7d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/37a384e07b2e25f70080174ef8e49ccde609ad7d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f04b8d6927ad8374c40a3412eeda8f3be18e9fc0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f04b8d6927ad8374c40a3412eeda8f3be18e9fc0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f04b8d6927ad8374c40a3412eeda8f3be18e9fc0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f04b8d6927ad8374c40a3412eeda8f3be18e9fc0/comments", "author": null, "committer": null, "parents": [{"sha": "90137d8f2c5dfb3cb589e4b3497c63d7f810767e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90137d8f2c5dfb3cb589e4b3497c63d7f810767e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90137d8f2c5dfb3cb589e4b3497c63d7f810767e"}], "stats": {"total": 280, "additions": 156, "deletions": 124}, "files": [{"sha": "e8421391e63c4d15dfc0b2c3022784a0d19493ab", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f04b8d6927ad8374c40a3412eeda8f3be18e9fc0/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f04b8d6927ad8374c40a3412eeda8f3be18e9fc0/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=f04b8d6927ad8374c40a3412eeda8f3be18e9fc0", "patch": "@@ -1,3 +1,21 @@\n+2012-04-30  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/gigi.h (mark_out_of_scope): Delete.\n+\t(destroy_gnat_to_gnu): Declare.\n+\t(destroy_dummy_type): Likewise.\n+\t* gcc-interface/decl.c (mark_out_of_scope): Delete.\n+\t* gcc-interface/utils.c (destroy_gnat_to_gnu): New function.\n+\t(destroy_dummy_type): Likewise.\n+\t* gcc-interface/trans.c (gnat_validate_uc_list): New variable.\n+\t(gigi): Call validate_unchecked_conversion on gnat_validate_uc_list\n+\tafter the translation is completed. \ufffdCall destroy_gnat_to_gnu and\n+\tdestroy_dummy_type at the end.\n+\t(Subprogram_Body_to_gnu): Do not call mark_out_of_scope.\n+\t(gnat_to_gnu) <N_Block_Statement>: Likewise.\n+\t<N_Validate_Unchecked_Conversion>: Do not process the node, only push\n+\tit onto gnat_validate_uc_list.\n+\t(validate_unchecked_conversion): New function.\n+\n 2012-04-26  Tristan Gingold  <gingold@adacore.com>\n \n \t* gcc-interface/Make-lang.in: Update dependencies."}, {"sha": "6f351d3db2e3cbedac73e60c880cd7e23c8a6f8b", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f04b8d6927ad8374c40a3412eeda8f3be18e9fc0/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f04b8d6927ad8374c40a3412eeda8f3be18e9fc0/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=f04b8d6927ad8374c40a3412eeda8f3be18e9fc0", "patch": "@@ -5838,44 +5838,6 @@ elaborate_entity (Entity_Id gnat_entity)\n     }\n }\n \f\n-/* Mark GNAT_ENTITY as going out of scope at this point.  Recursively mark\n-   any entities on its entity chain similarly.  */\n-\n-void\n-mark_out_of_scope (Entity_Id gnat_entity)\n-{\n-  Entity_Id gnat_sub_entity;\n-  unsigned int kind = Ekind (gnat_entity);\n-\n-  /* If this has an entity list, process all in the list.  */\n-  if (IN (kind, Class_Wide_Kind) || IN (kind, Concurrent_Kind)\n-      || IN (kind, Private_Kind)\n-      || kind == E_Block || kind == E_Entry || kind == E_Entry_Family\n-      || kind == E_Function || kind == E_Generic_Function\n-      || kind == E_Generic_Package || kind == E_Generic_Procedure\n-      || kind == E_Loop || kind == E_Operator || kind == E_Package\n-      || kind == E_Package_Body || kind == E_Procedure\n-      || kind == E_Record_Type || kind == E_Record_Subtype\n-      || kind == E_Subprogram_Body || kind == E_Subprogram_Type)\n-    for (gnat_sub_entity = First_Entity (gnat_entity);\n-\t Present (gnat_sub_entity);\n-\t gnat_sub_entity = Next_Entity (gnat_sub_entity))\n-      if (Scope (gnat_sub_entity) == gnat_entity\n-\t  && gnat_sub_entity != gnat_entity)\n-\tmark_out_of_scope (gnat_sub_entity);\n-\n-  /* Now clear this if it has been defined, but only do so if it isn't\n-     a subprogram or parameter.  We could refine this, but it isn't\n-     worth it.  If this is statically allocated, it is supposed to\n-     hang around out of cope.  */\n-  if (present_gnu_tree (gnat_entity) && !Is_Statically_Allocated (gnat_entity)\n-      && kind != E_Procedure && kind != E_Function && !IN (kind, Formal_Kind))\n-    {\n-      save_gnu_tree (gnat_entity, NULL_TREE, true);\n-      save_gnu_tree (gnat_entity, error_mark_node, true);\n-    }\n-}\n-\f\n /* Relate the alias sets of GNU_NEW_TYPE and GNU_OLD_TYPE according to OP.\n    If this is a multi-dimensional array type, do this recursively.\n "}, {"sha": "fb1106f793eeb0eb3e2ccb216a89f219e2912231", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f04b8d6927ad8374c40a3412eeda8f3be18e9fc0/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f04b8d6927ad8374c40a3412eeda8f3be18e9fc0/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=f04b8d6927ad8374c40a3412eeda8f3be18e9fc0", "patch": "@@ -108,10 +108,6 @@ extern Entity_Id Gigi_Equivalent_Type (Entity_Id gnat_entity);\n    be elaborated at the point of its definition, but do nothing else.  */\n extern void elaborate_entity (Entity_Id gnat_entity);\n \n-/* Mark GNAT_ENTITY as going out of scope at this point.  Recursively mark\n-   any entities on its entity chain similarly.  */\n-extern void mark_out_of_scope (Entity_Id gnat_entity);\n-\n /* Get the unpadded version of a GNAT type.  */\n extern tree get_unpadded_type (Entity_Id gnat_entity);\n \n@@ -504,6 +500,9 @@ extern tree convert_to_index_type (tree expr);\n /* Initialize the association of GNAT nodes to GCC trees.  */\n extern void init_gnat_to_gnu (void);\n \n+/* Destroy the association of GNAT nodes to GCC trees.  */\n+extern void destroy_gnat_to_gnu (void);\n+\n /* GNAT_ENTITY is a GNAT tree node for a defining identifier.\n    GNU_DECL is the GCC tree which is to be associated with\n    GNAT_ENTITY. Such gnu tree node is always an ..._DECL node.\n@@ -523,6 +522,9 @@ extern bool present_gnu_tree (Entity_Id gnat_entity);\n /* Initialize the association of GNAT nodes to GCC trees as dummies.  */\n extern void init_dummy_type (void);\n \n+/* Destroy the association of GNAT nodes to GCC trees as dummies.  */\n+extern void destroy_dummy_type (void);\n+\n /* Make a dummy type corresponding to GNAT_TYPE.  */\n extern tree make_dummy_type (Entity_Id gnat_type);\n "}, {"sha": "3698dcaf2a4138a360ae855ec55701606af1bb29", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 82, "deletions": 82, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f04b8d6927ad8374c40a3412eeda8f3be18e9fc0/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f04b8d6927ad8374c40a3412eeda8f3be18e9fc0/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=f04b8d6927ad8374c40a3412eeda8f3be18e9fc0", "patch": "@@ -109,6 +109,12 @@ bool type_annotate_only;\n /* Current filename without path.  */\n const char *ref_filename;\n \n+DEF_VEC_I(Node_Id);\n+DEF_VEC_ALLOC_I(Node_Id,heap);\n+\n+/* List of N_Validate_Unchecked_Conversion nodes in the unit.  */\n+static VEC(Node_Id,heap) *gnat_validate_uc_list;\n+\n /* When not optimizing, we cache the 'First, 'Last and 'Length attributes\n    of unconstrained array IN parameters to avoid emitting a great deal of\n    redundant instructions to recompute them each time.  */\n@@ -251,6 +257,7 @@ static bool addressable_p (tree, tree);\n static tree assoc_to_constructor (Entity_Id, Node_Id, tree);\n static tree extract_values (tree, tree);\n static tree pos_to_constructor (Node_Id, tree, Entity_Id);\n+static void validate_unchecked_conversion (Node_Id);\n static tree maybe_implicit_deref (tree);\n static void set_expr_location_from_node (tree, Node_Id);\n static bool set_end_locus_from_node (tree, Node_Id);\n@@ -278,6 +285,7 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name ATTRIBUTE_UNUSED,\n       Entity_Id standard_character, Entity_Id standard_long_long_float,\n       Entity_Id standard_exception_type, Int gigi_operating_mode)\n {\n+  Node_Id gnat_iter;\n   Entity_Id gnat_literal;\n   tree long_long_float_type, exception_type, t, ftype;\n   tree int64_type = gnat_type_for_size (64, 0);\n@@ -648,6 +656,13 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name ATTRIBUTE_UNUSED,\n   /* Now translate the compilation unit proper.  */\n   Compilation_Unit_to_gnu (gnat_root);\n \n+  /* Then process the N_Validate_Unchecked_Conversion nodes.  We do this at\n+     the very end to avoid having to second-guess the front-end when we run\n+     into dummy nodes during the regular processing.  */\n+  for (i = 0; VEC_iterate (Node_Id, gnat_validate_uc_list, i, gnat_iter); i++)\n+    validate_unchecked_conversion (gnat_iter);\n+  VEC_free (Node_Id, heap, gnat_validate_uc_list);\n+\n   /* Finally see if we have any elaboration procedures to deal with.  */\n   for (info = elab_info_list; info; info = info->next)\n     {\n@@ -669,6 +684,10 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name ATTRIBUTE_UNUSED,\n \t}\n     }\n \n+  /* Destroy ourselves.  */\n+  destroy_gnat_to_gnu ();\n+  destroy_dummy_type ();\n+\n   /* We cannot track the location of errors past this point.  */\n   error_gnat_node = Empty;\n }\n@@ -3480,8 +3499,6 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n   /* If there is a stub associated with the function, build it now.  */\n   if (DECL_FUNCTION_STUB (gnu_subprog_decl))\n     build_function_stub (gnu_subprog_decl, gnat_subprog_id);\n-\n-  mark_out_of_scope (Defining_Unit_Name (Specification (gnat_node)));\n }\n \f\n /* Return true if GNAT_NODE requires atomic synchronization.  */\n@@ -6036,9 +6053,6 @@ gnat_to_gnu (Node_Id gnat_node)\n       add_stmt (gnat_to_gnu (Handled_Statement_Sequence (gnat_node)));\n       gnat_poplevel ();\n       gnu_result = end_stmt_group ();\n-\n-      if (Present (Identifier (gnat_node)))\n-\tmark_out_of_scope (Entity (Identifier (gnat_node)));\n       break;\n \n     case N_Exit_Statement:\n@@ -6760,83 +6774,10 @@ gnat_to_gnu (Node_Id gnat_node)\n       break;\n \n     case N_Validate_Unchecked_Conversion:\n-      {\n-\tEntity_Id gnat_target_type = Target_Type (gnat_node);\n-\ttree gnu_source_type = gnat_to_gnu_type (Source_Type (gnat_node));\n-\ttree gnu_target_type = gnat_to_gnu_type (gnat_target_type);\n-\n-\t/* No need for any warning in this case.  */\n-\tif (!flag_strict_aliasing)\n-\t  ;\n-\n-\t/* If the result is a pointer type, see if we are either converting\n-\t   from a non-pointer or from a pointer to a type with a different\n-\t   alias set and warn if so.  If the result is defined in the same\n-\t   unit as this unchecked conversion, we can allow this because we\n-\t   can know to make the pointer type behave properly.  */\n-\telse if (POINTER_TYPE_P (gnu_target_type)\n-\t\t && !In_Same_Source_Unit (gnat_target_type, gnat_node)\n-\t\t && !No_Strict_Aliasing (Underlying_Type (gnat_target_type)))\n-\t  {\n-\t    tree gnu_source_desig_type = POINTER_TYPE_P (gnu_source_type)\n-\t\t\t\t\t ? TREE_TYPE (gnu_source_type)\n-\t\t\t\t\t : NULL_TREE;\n-\t    tree gnu_target_desig_type = TREE_TYPE (gnu_target_type);\n-\n-\t    if ((TYPE_IS_DUMMY_P (gnu_target_desig_type)\n-\t\t || get_alias_set (gnu_target_desig_type) != 0)\n-\t\t&& (!POINTER_TYPE_P (gnu_source_type)\n-\t\t    || (TYPE_IS_DUMMY_P (gnu_source_desig_type)\n-\t\t\t!= TYPE_IS_DUMMY_P (gnu_target_desig_type))\n-\t\t    || (TYPE_IS_DUMMY_P (gnu_source_desig_type)\n-\t\t\t&& gnu_source_desig_type != gnu_target_desig_type)\n-\t\t    || !alias_sets_conflict_p\n-\t\t\t(get_alias_set (gnu_source_desig_type),\n-\t\t\t get_alias_set (gnu_target_desig_type))))\n-\t      {\n-\t\tpost_error_ne\n-\t\t  (\"?possible aliasing problem for type&\",\n-\t\t   gnat_node, Target_Type (gnat_node));\n-\t\tpost_error\n-\t\t  (\"\\\\?use -fno-strict-aliasing switch for references\",\n-\t\t   gnat_node);\n-\t\tpost_error_ne\n-\t\t  (\"\\\\?or use `pragma No_Strict_Aliasing (&);`\",\n-\t\t   gnat_node, Target_Type (gnat_node));\n-\t      }\n-\t  }\n-\n-\t/* But if the result is a fat pointer type, we have no mechanism to\n-\t   do that, so we unconditionally warn in problematic cases.  */\n-\telse if (TYPE_IS_FAT_POINTER_P (gnu_target_type))\n-\t  {\n-\t    tree gnu_source_array_type\n-\t      = TYPE_IS_FAT_POINTER_P (gnu_source_type)\n-\t\t? TREE_TYPE (TREE_TYPE (TYPE_FIELDS (gnu_source_type)))\n-\t\t: NULL_TREE;\n-\t    tree gnu_target_array_type\n-\t      = TREE_TYPE (TREE_TYPE (TYPE_FIELDS (gnu_target_type)));\n-\n-\t    if ((TYPE_IS_DUMMY_P (gnu_target_array_type)\n-\t\t || get_alias_set (gnu_target_array_type) != 0)\n-\t\t&& (!TYPE_IS_FAT_POINTER_P (gnu_source_type)\n-\t\t    || (TYPE_IS_DUMMY_P (gnu_source_array_type)\n-\t\t\t!= TYPE_IS_DUMMY_P (gnu_target_array_type))\n-\t\t    || (TYPE_IS_DUMMY_P (gnu_source_array_type)\n-\t\t\t&& gnu_source_array_type != gnu_target_array_type)\n-\t\t    || !alias_sets_conflict_p\n-\t\t\t(get_alias_set (gnu_source_array_type),\n-\t\t\t get_alias_set (gnu_target_array_type))))\n-\t      {\n-\t\tpost_error_ne\n-\t\t  (\"?possible aliasing problem for type&\",\n-\t\t   gnat_node, Target_Type (gnat_node));\n-\t\tpost_error\n-\t\t  (\"\\\\?use -fno-strict-aliasing switch for references\",\n-\t\t   gnat_node);\n-\t      }\n-\t  }\n-      }\n+      /* The only validation we currently do on an unchecked conversion is\n+\t that of aliasing assumptions.  */\n+      if (flag_strict_aliasing)\n+\tVEC_safe_push (Node_Id, heap, gnat_validate_uc_list, gnat_node);\n       gnu_result = alloc_stmt_list ();\n       break;\n \n@@ -8723,6 +8664,65 @@ extract_values (tree values, tree record_type)\n   return gnat_build_constructor (record_type, v);\n }\n \f\n+/* Process a N_Validate_Unchecked_Conversion node.  */\n+\n+static void\n+validate_unchecked_conversion (Node_Id gnat_node)\n+{\n+  tree gnu_source_type = gnat_to_gnu_type (Source_Type (gnat_node));\n+  tree gnu_target_type = gnat_to_gnu_type (Target_Type (gnat_node));\n+\n+  /* If the target is a pointer type, see if we are either converting from a\n+     non-pointer or from a pointer to a type with a different alias set and\n+     warn if so, unless the pointer has been marked to alias everything.  */\n+  if (POINTER_TYPE_P (gnu_target_type)\n+      && !TYPE_REF_CAN_ALIAS_ALL (gnu_target_type))\n+    {\n+      tree gnu_source_desig_type = POINTER_TYPE_P (gnu_source_type)\n+\t\t\t\t   ? TREE_TYPE (gnu_source_type)\n+\t\t\t\t   : NULL_TREE;\n+      tree gnu_target_desig_type = TREE_TYPE (gnu_target_type);\n+      alias_set_type target_alias_set = get_alias_set (gnu_target_desig_type);\n+\n+      if (target_alias_set != 0\n+\t  && (!POINTER_TYPE_P (gnu_source_type)\n+\t      || !alias_sets_conflict_p (get_alias_set (gnu_source_desig_type),\n+\t\t\t\t\t target_alias_set)))\n+\t{\n+\t  post_error_ne (\"?possible aliasing problem for type&\",\n+\t\t\t gnat_node, Target_Type (gnat_node));\n+\t  post_error (\"\\\\?use -fno-strict-aliasing switch for references\",\n+\t\t      gnat_node);\n+\t  post_error_ne (\"\\\\?or use `pragma No_Strict_Aliasing (&);`\",\n+\t\t\t gnat_node, Target_Type (gnat_node));\n+\t}\n+    }\n+\n+  /* Likewise if the target is a fat pointer type, but we have no mechanism to\n+     mitigate the problem in this case, so we unconditionally warn.  */\n+  else if (TYPE_IS_FAT_POINTER_P (gnu_target_type))\n+    {\n+      tree gnu_source_desig_type\n+\t= TYPE_IS_FAT_POINTER_P (gnu_source_type)\n+\t  ? TREE_TYPE (TREE_TYPE (TYPE_FIELDS (gnu_source_type)))\n+\t  : NULL_TREE;\n+      tree gnu_target_desig_type\n+\t= TREE_TYPE (TREE_TYPE (TYPE_FIELDS (gnu_target_type)));\n+      alias_set_type target_alias_set = get_alias_set (gnu_target_desig_type);\n+\n+      if (target_alias_set != 0\n+\t  && (!TYPE_IS_FAT_POINTER_P (gnu_source_type)\n+\t      || !alias_sets_conflict_p (get_alias_set (gnu_source_desig_type),\n+\t\t\t\t\t target_alias_set)))\n+\t{\n+\t  post_error_ne (\"?possible aliasing problem for type&\",\n+\t\t\t gnat_node, Target_Type (gnat_node));\n+\t  post_error (\"\\\\?use -fno-strict-aliasing switch for references\",\n+\t\t      gnat_node);\n+\t}\n+    }\n+}\n+\f\n /* EXP is to be treated as an array or record.  Handle the cases when it is\n    an access object and perform the required dereferences.  */\n "}, {"sha": "123c3a5705c3a6ea6b7c36bcab524a898cb24292", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f04b8d6927ad8374c40a3412eeda8f3be18e9fc0/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f04b8d6927ad8374c40a3412eeda8f3be18e9fc0/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=f04b8d6927ad8374c40a3412eeda8f3be18e9fc0", "patch": "@@ -231,6 +231,15 @@ init_gnat_to_gnu (void)\n   associate_gnat_to_gnu = ggc_alloc_cleared_vec_tree (max_gnat_nodes);\n }\n \n+/* Destroy the association of GNAT nodes to GCC trees.  */\n+\n+void\n+destroy_gnat_to_gnu (void)\n+{\n+  ggc_free (associate_gnat_to_gnu);\n+  associate_gnat_to_gnu = NULL;\n+}\n+\n /* GNAT_ENTITY is a GNAT tree node for an entity.  Associate GNU_DECL, a GCC\n    tree node, with GNAT_ENTITY.  If GNU_DECL is not a ..._DECL node, abort.\n    If NO_CHECK is true, the latter check is suppressed.\n@@ -280,6 +289,15 @@ init_dummy_type (void)\n   dummy_node_table = ggc_alloc_cleared_vec_tree (max_gnat_nodes);\n }\n \n+/* Destroy the association of GNAT nodes to GCC trees as dummies.  */\n+\n+void\n+destroy_dummy_type (void)\n+{\n+  ggc_free (dummy_node_table);\n+  dummy_node_table = NULL;\n+}\n+\n /* Make a dummy type corresponding to GNAT_TYPE.  */\n \n tree"}, {"sha": "45bda58a0792204b549e19e4fdd12dafc18e5036", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f04b8d6927ad8374c40a3412eeda8f3be18e9fc0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f04b8d6927ad8374c40a3412eeda8f3be18e9fc0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f04b8d6927ad8374c40a3412eeda8f3be18e9fc0", "patch": "@@ -1,3 +1,7 @@\n+2012-04-30  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/warn6.ad[sb]: New test.\n+\n 2012-04-29  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n \n \tPR 53149"}, {"sha": "0a388f148444bc48cb3b848cd623dc0905287267", "filename": "gcc/testsuite/gnat.dg/warn6.adb", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f04b8d6927ad8374c40a3412eeda8f3be18e9fc0/gcc%2Ftestsuite%2Fgnat.dg%2Fwarn6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f04b8d6927ad8374c40a3412eeda8f3be18e9fc0/gcc%2Ftestsuite%2Fgnat.dg%2Fwarn6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fwarn6.adb?ref=f04b8d6927ad8374c40a3412eeda8f3be18e9fc0", "patch": "@@ -0,0 +1,13 @@\n+-- { dg-do compile }\n+-- { dg-options \"-O2\" }\n+\n+with Unchecked_Conversion;\n+with System;\n+\n+package body Warn6 is\n+\n+  function Conv is new Unchecked_Conversion (System.Address, Q_T);\n+\n+  procedure Dummy is begin null; end;\n+\n+end Warn6;"}, {"sha": "e7495ead101747facb969392634b6b262038c75c", "filename": "gcc/testsuite/gnat.dg/warn6.ads", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f04b8d6927ad8374c40a3412eeda8f3be18e9fc0/gcc%2Ftestsuite%2Fgnat.dg%2Fwarn6.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f04b8d6927ad8374c40a3412eeda8f3be18e9fc0/gcc%2Ftestsuite%2Fgnat.dg%2Fwarn6.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fwarn6.ads?ref=f04b8d6927ad8374c40a3412eeda8f3be18e9fc0", "patch": "@@ -0,0 +1,15 @@\n+package Warn6 is\n+\n+  package Q is\n+    type T is private; -- this is the trigger\n+  private\n+    type T is access Integer;\n+    pragma No_Strict_Aliasing (T);\n+\n+  end Q;\n+\n+  subtype Q_T is Q.T;\n+\n+  procedure Dummy;\n+\n+end Warn6;"}]}