{"sha": "81f2eadbedaf8048f749b2a6c7f550740ece94a4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODFmMmVhZGJlZGFmODA0OGY3NDliMmE2YzdmNTUwNzQwZWNlOTRhNA==", "commit": {"author": {"name": "Josef Zlomek", "email": "zlomekj@suse.cz", "date": "2004-03-11T08:05:14Z"}, "committer": {"name": "Josef Zlomek", "email": "zlomek@gcc.gnu.org", "date": "2004-03-11T08:05:14Z"}, "message": "var-tracking.c (struct variable_def): Added field refcount.\n\n\tPR/14362\n\t* var-tracking.c (struct variable_def): Added field refcount.\n\t(variable_htab_free): Decrease the refcount and delete variable\n\tonly if there are no more references.\n\t(unshare_variable): New function.\n\t(vars_copy_1): Increase refcount instead of copying the variable.\n\t(variable_union): Share the variables where possible, unshare\n\tthe variables if needed.\n\t(variable_different_p): Return false if var1 and var2 are\n\tthe same structure.\n\t(variable_was_changed): Init the refcount of new variable.\n\t(set_frame_base_location): Unshare variable if needed.\n\t(set_variable_part): Init the refcount of new variable.\n\tUnshare the variables if needed.\n\t(delete_variable_part): Unshare the variables if needed.\n\t(emit_notes_for_differences_1): Init the refcount of new variable.\n\t(vt_add_function_parameters): Do not add function parameters to\n\tIN set of ENTRY_BLOCK_PTR because it is unused anyway.\n\t(vt_initialize): Do not add frame_base_decl to IN set of\n\tENTRY_BLOCK_PTR because it is unused anyway.\n\nFrom-SVN: r79307", "tree": {"sha": "8ce1eecafee1cf882113fbad7789e4dd621695cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8ce1eecafee1cf882113fbad7789e4dd621695cf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/81f2eadbedaf8048f749b2a6c7f550740ece94a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81f2eadbedaf8048f749b2a6c7f550740ece94a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81f2eadbedaf8048f749b2a6c7f550740ece94a4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81f2eadbedaf8048f749b2a6c7f550740ece94a4/comments", "author": null, "committer": null, "parents": [{"sha": "f2bd98d4c520787f278cdb6865f3566100b99e93", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2bd98d4c520787f278cdb6865f3566100b99e93", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2bd98d4c520787f278cdb6865f3566100b99e93"}], "stats": {"total": 227, "additions": 189, "deletions": 38}, "files": [{"sha": "6707f581326eb0e005f13e8e800fa8ad9aedb565", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81f2eadbedaf8048f749b2a6c7f550740ece94a4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81f2eadbedaf8048f749b2a6c7f550740ece94a4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=81f2eadbedaf8048f749b2a6c7f550740ece94a4", "patch": "@@ -1,3 +1,26 @@\n+2004-03-11  Josef Zlomek  <zlomekj@suse.cz>\n+\n+\tPR/14362\n+\t* var-tracking.c (struct variable_def): Added field refcount.\n+\t(variable_htab_free): Decrease the refcount and delete variable\n+\tonly if there are no more references.\n+\t(unshare_variable): New function.\n+\t(vars_copy_1): Increase refcount instead of copying the variable.\n+\t(variable_union): Share the variables where possible, unshare\n+\tthe variables if needed.\n+\t(variable_different_p): Return false if var1 and var2 are\n+\tthe same structure.\n+\t(variable_was_changed): Init the refcount of new variable.\n+\t(set_frame_base_location): Unshare variable if needed.\n+\t(set_variable_part): Init the refcount of new variable.\n+\tUnshare the variables if needed.\n+\t(delete_variable_part): Unshare the variables if needed. \n+\t(emit_notes_for_differences_1): Init the refcount of new variable.\n+\t(vt_add_function_parameters): Do not add function parameters to\n+\tIN set of ENTRY_BLOCK_PTR because it is unused anyway.\n+\t(vt_initialize): Do not add frame_base_decl to IN set of\n+\tENTRY_BLOCK_PTR because it is unused anyway.\n+\n 2004-03-11  Josef Zlomek  <zlomekj@suse.cz>\n \n \t* var-tracking.c (vars_copy_1): Cleanup and speedup chain operations."}, {"sha": "5da2376836654e91de896a13a4b4aa6df0ff2c2b", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 166, "deletions": 38, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81f2eadbedaf8048f749b2a6c7f550740ece94a4/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81f2eadbedaf8048f749b2a6c7f550740ece94a4/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=81f2eadbedaf8048f749b2a6c7f550740ece94a4", "patch": "@@ -233,6 +233,9 @@ typedef struct variable_def\n   /* The declaration of the variable.  */\n   tree decl;\n \n+  /* Reference count.  */\n+  int refcount;\n+\n   /* Number of variable parts.  */\n   int n_var_parts;\n \n@@ -285,6 +288,7 @@ static void attrs_list_copy (attrs *, attrs);\n static void attrs_list_union (attrs *, attrs);\n \n static void vars_clear (htab_t);\n+static variable unshare_variable (dataflow_set *set, variable var);\n static int vars_copy_1 (void **, void *);\n static void vars_copy (htab_t, htab_t);\n static void var_reg_delete_and_set (dataflow_set *, rtx);\n@@ -629,6 +633,15 @@ variable_htab_free (void *elem)\n   variable var = (variable) elem;\n   location_chain node, next;\n \n+#ifdef ENABLE_CHECKING\n+  if (var->refcount <= 0)\n+    abort ();\n+#endif\n+\n+  var->refcount--;\n+  if (var->refcount > 0)\n+    return;\n+\n   for (i = 0; i < var->n_var_parts; i++)\n     {\n       for (node = var->var_part[i].loc_chain; node; node = next)\n@@ -732,32 +745,29 @@ vars_clear (htab_t vars)\n   htab_empty (vars);\n }\n \n-/* Copy one variable from *SLOT to hash table DATA.  */\n+/* Return a copy of a variable VAR and insert it to dataflow set SET.  */\n \n-static int\n-vars_copy_1 (void **slot, void *data)\n+static variable\n+unshare_variable (dataflow_set *set, variable var)\n {\n-  htab_t dst = (htab_t) data;\n-  variable src, *dstp, var;\n+  void **slot;\n+  variable new_var;\n   int i;\n \n-  src = *(variable *) slot;\n-  dstp = (variable *) htab_find_slot_with_hash (dst, src->decl,\n-\t\t\t\t\t\tVARIABLE_HASH_VAL (src->decl),\n-\t\t\t\t\t\tINSERT);\n-  var = pool_alloc (var_pool);\n-  var->decl = src->decl;\n-  var->n_var_parts = src->n_var_parts;\n-  *dstp = (void *) var;\n+  new_var = pool_alloc (var_pool);\n+  new_var->decl = var->decl;\n+  new_var->refcount = 1;\n+  var->refcount--;\n+  new_var->n_var_parts = var->n_var_parts;\n \n   for (i = 0; i < var->n_var_parts; i++)\n     {\n       location_chain node;\n       location_chain *nextp;\n \n-      var->var_part[i].offset = src->var_part[i].offset;\n-      nextp = &var->var_part[i].loc_chain;\n-      for (node = src->var_part[i].loc_chain; node; node = node->next)\n+      new_var->var_part[i].offset = var->var_part[i].offset;\n+      nextp = &new_var->var_part[i].loc_chain;\n+      for (node = var->var_part[i].loc_chain; node; node = node->next)\n \t{\n \t  location_chain new_lc;\n \n@@ -771,12 +781,36 @@ vars_copy_1 (void **slot, void *data)\n \n       /* We are at the basic block boundary when copying variable description\n \t so set the CUR_LOC to be the first element of the chain.  */\n-      if (var->var_part[i].loc_chain)\n-\tvar->var_part[i].cur_loc = var->var_part[i].loc_chain->loc;\n+      if (new_var->var_part[i].loc_chain)\n+\tnew_var->var_part[i].cur_loc = new_var->var_part[i].loc_chain->loc;\n       else\n-\tvar->var_part[i].cur_loc = NULL;\n+\tnew_var->var_part[i].cur_loc = NULL;\n     }\n \n+  slot = htab_find_slot_with_hash (set->vars, new_var->decl,\n+\t\t\t\t   VARIABLE_HASH_VAL (new_var->decl),\n+\t\t\t\t   INSERT);\n+  *slot = new_var;\n+  return new_var;\n+}\n+\n+/* Add a variable from *SLOT to hash table DATA and increase its reference\n+   count.  */\n+\n+static int\n+vars_copy_1 (void **slot, void *data)\n+{\n+  htab_t dst = (htab_t) data;\n+  variable src, *dstp;\n+\n+  src = *(variable *) slot;\n+  src->refcount++;\n+\n+  dstp = (variable *) htab_find_slot_with_hash (dst, src->decl,\n+\t\t\t\t\t\tVARIABLE_HASH_VAL (src->decl),\n+\t\t\t\t\t\tINSERT);\n+  *dstp = src;\n+\n   /* Continue traversing the hash table.  */\n   return 1;\n }\n@@ -972,9 +1006,37 @@ variable_union (void **slot, void *data)\n \t\t\t\t\t\tINSERT);\n   if (!*dstp)\n     {\n-      *dstp = dst = pool_alloc (var_pool);\n-      dst->decl = src->decl;\n-      dst->n_var_parts = 0;\n+      src->refcount++;\n+\n+      /* If CUR_LOC of some variable part is not the first element of\n+\t the location chain we are going to change it so we have to make\n+\t a copy of the variable.  */\n+      for (k = 0; k < src->n_var_parts; k++)\n+\t{\n+\t  if (src->var_part[k].loc_chain)\n+\t    {\n+#ifdef ENABLE_CHECKING\n+\t      if (src->var_part[k].cur_loc == NULL)\n+\t\tabort ();\n+#endif\n+\t      if (src->var_part[k].cur_loc != src->var_part[k].loc_chain->loc)\n+\t\tbreak;\n+\t    }\n+#ifdef ENABLE_CHECKING\n+\t  else\n+\t    {\n+\t      if (src->var_part[k].cur_loc != NULL)\n+\t\tabort ();\n+\t    }\n+#endif\n+\t}\n+      if (k < src->n_var_parts)\n+\tunshare_variable (set, src);\n+      else\n+\t*dstp = src;\n+\n+      /* Continue traversing the hash table.  */\n+      return 1;\n     }\n   else\n     dst = *dstp;\n@@ -998,24 +1060,25 @@ variable_union (void **slot, void *data)\n       else\n \tj++;\n     }\n-  if (i < src->n_var_parts)\n-    k += src->n_var_parts - i;\n-  if (j < dst->n_var_parts)\n-    k += dst->n_var_parts - j;\n+  k += src->n_var_parts - i;\n+  k += dst->n_var_parts - j;\n #ifdef ENABLE_CHECKING\n   /* We track only variables whose size is <= MAX_VAR_PARTS bytes\n      thus there are at most MAX_VAR_PARTS different offsets.  */\n   if (k > MAX_VAR_PARTS)\n     abort ();\n #endif\n \n+  if (dst->refcount > 1 && dst->n_var_parts != k)\n+    dst = unshare_variable (set, dst);\n+\n   i = src->n_var_parts - 1;\n   j = dst->n_var_parts - 1;\n   dst->n_var_parts = k;\n \n   for (k--; k >= 0; k--)\n     {\n-      location_chain node;\n+      location_chain node, node2;\n \n       if (i >= 0 && j >= 0\n \t  && src->var_part[i].offset == dst->var_part[j].offset)\n@@ -1026,7 +1089,26 @@ variable_union (void **slot, void *data)\n \t  int dst_l, src_l;\n \t  int ii, jj, n;\n \t  struct variable_union_info *vui;\n-\t  \n+\n+\t  /* If DST is shared compare the location chains.\n+\t     If they are different we will modify the chain in DST with\n+\t     high probability so make a copy of DST.  */\n+\t  if (dst->refcount > 1)\n+\t    {\n+\t      for (node = src->var_part[i].loc_chain,\n+\t\t   node2 = dst->var_part[j].loc_chain; node && node2;\n+\t\t   node = node->next, node2 = node2->next)\n+\t\t{\n+\t\t  if (!((GET_CODE (node2->loc) == REG\n+\t\t\t && GET_CODE (node->loc) == REG\n+\t\t\t && REGNO (node2->loc) == REGNO (node->loc))\n+\t\t\t|| rtx_equal_p (node2->loc, node->loc)))\n+\t\t    break;\n+\t\t}\n+\t      if (node || node2)\n+\t\tdst = unshare_variable (set, dst);\n+\t    }\n+\n \t  src_l = 0;\n \t  for (node = src->var_part[i].loc_chain; node; node = node->next)\n \t    src_l++;\n@@ -1187,6 +1269,9 @@ variable_different_p (variable var1, variable var2)\n {\n   int i;\n \n+  if (var1 == var2)\n+    return false;\n+\n   if (var1->n_var_parts != var2->n_var_parts)\n     return true;\n \n@@ -1791,6 +1876,7 @@ variable_was_changed (variable var, htab_t htab)\n \n \t  empty_var = pool_alloc (var_pool);\n \t  empty_var->decl = var->decl;\n+\t  empty_var->refcount = 1;\n \t  empty_var->n_var_parts = 0;\n \t  *slot = empty_var;\n \n@@ -1843,7 +1929,12 @@ set_frame_base_location (dataflow_set *set, rtx loc)\n     abort ();\n #endif\n \n+  /* If frame_base_decl is shared unshare it first.  */\n+  if (var->refcount > 1)\n+    var = unshare_variable (set, var);\n+\n   var->var_part[0].loc_chain->loc = loc;\n+  var->var_part[0].cur_loc = loc;\n   variable_was_changed (var, set->vars);\n }\n \n@@ -1867,6 +1958,7 @@ set_variable_part (dataflow_set *set, rtx loc, tree decl, HOST_WIDE_INT offset)\n       /* Create new variable information.  */\n       var = pool_alloc (var_pool);\n       var->decl = decl;\n+      var->refcount = 1;\n       var->n_var_parts = 1;\n       var->var_part[0].offset = offset;\n       var->var_part[0].loc_chain = NULL;\n@@ -1891,9 +1983,33 @@ set_variable_part (dataflow_set *set, rtx loc, tree decl, HOST_WIDE_INT offset)\n \t}\n       pos = low;\n \n-      if (pos == var->n_var_parts || var->var_part[pos].offset != offset)\n+      if (pos < var->n_var_parts && var->var_part[pos].offset == offset)\n \t{\n-\t  /* We have not find the location part, new one will be created.  */\n+\t  node = var->var_part[pos].loc_chain;\n+\n+\t  if (node\n+\t      && ((GET_CODE (node->loc) == REG && GET_CODE (loc) == REG\n+\t\t   && REGNO (node->loc) == REGNO (loc))\n+\t\t  || rtx_equal_p (node->loc, loc)))\n+\t    {\n+\t      /* LOC is in the beginning of the chain so we have nothing\n+\t\t to do.  */\n+\t      return;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* We have to make a copy of a shared variable.  */\n+\t      if (var->refcount > 1)\n+\t\tvar = unshare_variable (set, var);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* We have not found the location part, new one will be created.  */\n+\n+\t  /* We have to make a copy of the shared variable.  */\n+\t  if (var->refcount > 1)\n+\t    var = unshare_variable (set, var);\n \n #ifdef ENABLE_CHECKING\n \t  /* We track only variables whose size is <= MAX_VAR_PARTS bytes\n@@ -1914,7 +2030,7 @@ set_variable_part (dataflow_set *set, rtx loc, tree decl, HOST_WIDE_INT offset)\n \t}\n     }\n \n-  /* Delete the location from list.  */\n+  /* Delete the location from the list.  */\n   nextp = &var->var_part[pos].loc_chain;\n   for (node = var->var_part[pos].loc_chain; node; node = next)\n     {\n@@ -1981,6 +2097,23 @@ delete_variable_part (dataflow_set *set, rtx loc, tree decl,\n \t  location_chain *nextp;\n \t  bool changed;\n \n+\t  if (var->refcount > 1)\n+\t    {\n+\t      /* If the variable contains the location part we have to\n+\t\t make a copy of the variable.  */\n+\t      for (node = var->var_part[pos].loc_chain; node;\n+\t\t   node = node->next)\n+\t\t{\n+\t\t  if ((GET_CODE (node->loc) == REG && GET_CODE (loc) == REG\n+\t\t       && REGNO (node->loc) == REGNO (loc))\n+\t\t      || rtx_equal_p (node->loc, loc))\n+\t\t    {\n+\t\t      var = unshare_variable (set, var);\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t    }\n+\n \t  /* Delete the location part.  */\n \t  nextp = &var->var_part[pos].loc_chain;\n \t  for (node = *nextp; node; node = next)\n@@ -2149,6 +2282,7 @@ emit_notes_for_differences_1 (void **slot, void *data)\n \n       empty_var = pool_alloc (var_pool);\n       empty_var->decl = old_var->decl;\n+      empty_var->refcount = 1;\n       empty_var->n_var_parts = 0;\n       variable_was_changed (empty_var, NULL);\n     }\n@@ -2357,7 +2491,7 @@ vt_add_function_parameters (void)\n       rtx incoming = DECL_INCOMING_RTL (parm);\n       tree decl;\n       HOST_WIDE_INT offset;\n-      dataflow_set *in, *out;\n+      dataflow_set *out;\n \n       if (TREE_CODE (parm) != PARM_DECL)\n \tcontinue;\n@@ -2386,7 +2520,6 @@ vt_add_function_parameters (void)\n       incoming = eliminate_regs (incoming, 0, NULL_RTX);\n       if (!frame_pointer_needed && GET_CODE (incoming) == MEM)\n \tincoming = adjust_stack_reference (incoming, -stack_adjust);\n-      in = &VTI (ENTRY_BLOCK_PTR)->in;\n       out = &VTI (ENTRY_BLOCK_PTR)->out;\n \n       if (GET_CODE (incoming) == REG)\n@@ -2395,16 +2528,12 @@ vt_add_function_parameters (void)\n \t  if (REGNO (incoming) >= FIRST_PSEUDO_REGISTER)\n \t    abort ();\n #endif\n-\t  attrs_list_insert (&in->regs[REGNO (incoming)],\n-\t\t\t     parm, offset, incoming);\n \t  attrs_list_insert (&out->regs[REGNO (incoming)],\n \t\t\t     parm, offset, incoming);\n-\t  set_variable_part (in, incoming, parm, offset);\n \t  set_variable_part (out, incoming, parm, offset);\n \t}\n       else if (GET_CODE (incoming) == MEM)\n \t{\n-\t  set_variable_part (in, incoming, parm, offset);\n \t  set_variable_part (out, incoming, parm, offset);\n \t}\n     }\n@@ -2564,7 +2693,6 @@ vt_initialize (void)\n \n       /* Set its initial \"location\".  */\n       base = gen_rtx_MEM (Pmode, stack_pointer_rtx);\n-      set_variable_part (&VTI (ENTRY_BLOCK_PTR)->in, base, frame_base_decl, 0);\n       set_variable_part (&VTI (ENTRY_BLOCK_PTR)->out, base, frame_base_decl, 0);\n     }\n   else"}]}