{"sha": "4068698c47ff67bf48edf5c21a386204de370aaf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDA2ODY5OGM0N2ZmNjdiZjQ4ZWRmNWMyMWEzODYyMDRkZTM3MGFhZg==", "commit": {"author": {"name": "Justin Squirek", "email": "squirek@adacore.com", "date": "2020-12-16T07:00:56Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-04-29T08:00:48Z"}, "message": "[Ada] Missing access-to-discriminated conversion check\n\ngcc/ada/\n\n\t* checks.adb (Apply_Type_Conversion_Checks): Move out constraint\n\tcheck generation, and add case for general access types with\n\tconstraints.\n\t(Make_Discriminant_Constraint_Check): Created to centralize\n\tgeneration of constraint checks for stored discriminants.", "tree": {"sha": "2a9ce0cb1fc45c092faaaec41eba28726201b5ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2a9ce0cb1fc45c092faaaec41eba28726201b5ef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4068698c47ff67bf48edf5c21a386204de370aaf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4068698c47ff67bf48edf5c21a386204de370aaf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4068698c47ff67bf48edf5c21a386204de370aaf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4068698c47ff67bf48edf5c21a386204de370aaf/comments", "author": {"login": "AdaDoom3", "id": 3445599, "node_id": "MDQ6VXNlcjM0NDU1OTk=", "avatar_url": "https://avatars.githubusercontent.com/u/3445599?v=4", "gravatar_id": "", "url": "https://api.github.com/users/AdaDoom3", "html_url": "https://github.com/AdaDoom3", "followers_url": "https://api.github.com/users/AdaDoom3/followers", "following_url": "https://api.github.com/users/AdaDoom3/following{/other_user}", "gists_url": "https://api.github.com/users/AdaDoom3/gists{/gist_id}", "starred_url": "https://api.github.com/users/AdaDoom3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/AdaDoom3/subscriptions", "organizations_url": "https://api.github.com/users/AdaDoom3/orgs", "repos_url": "https://api.github.com/users/AdaDoom3/repos", "events_url": "https://api.github.com/users/AdaDoom3/events{/privacy}", "received_events_url": "https://api.github.com/users/AdaDoom3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "224ae1c7737a7ea307cd80475351fdb5ea25b641", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/224ae1c7737a7ea307cd80475351fdb5ea25b641", "html_url": "https://github.com/Rust-GCC/gccrs/commit/224ae1c7737a7ea307cd80475351fdb5ea25b641"}], "stats": {"total": 201, "additions": 124, "deletions": 77}, "files": [{"sha": "0f8b72b8e1cc3f8429e0ca0200d855b5d18358e8", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 124, "deletions": 77, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4068698c47ff67bf48edf5c21a386204de370aaf/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4068698c47ff67bf48edf5c21a386204de370aaf/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=4068698c47ff67bf48edf5c21a386204de370aaf", "patch": "@@ -3575,6 +3575,102 @@ package body Checks is\n       --  full view might have discriminants with defaults, so we need the\n       --  full view here to retrieve the constraints.\n \n+      procedure Make_Discriminant_Constraint_Check\n+        (Target_Type : Entity_Id;\n+         Expr_Type   : Entity_Id);\n+      --  Generate a discriminant check based on the target type and expression\n+      --  type for Expr.\n+\n+      ----------------------------------------\n+      -- Make_Discriminant_Constraint_Check --\n+      ----------------------------------------\n+\n+      procedure Make_Discriminant_Constraint_Check\n+        (Target_Type : Entity_Id;\n+         Expr_Type   : Entity_Id)\n+      is\n+         Loc         : constant Source_Ptr := Sloc (N);\n+         Cond        : Node_Id;\n+         Constraint  : Elmt_Id;\n+         Discr_Value : Node_Id;\n+         Discr       : Entity_Id;\n+\n+         New_Constraints : constant Elist_Id := New_Elmt_List;\n+         Old_Constraints : constant Elist_Id :=\n+           Discriminant_Constraint (Expr_Type);\n+\n+      begin\n+         --  Build an actual discriminant constraint list using the stored\n+         --  constraint, to verify that the expression of the parent type\n+         --  satisfies the constraints imposed by the (unconstrained) derived\n+         --  type. This applies to value conversions, not to view conversions\n+         --  of tagged types.\n+\n+         Constraint := First_Elmt (Stored_Constraint (Target_Type));\n+         while Present (Constraint) loop\n+            Discr_Value := Node (Constraint);\n+\n+            if Is_Entity_Name (Discr_Value)\n+              and then Ekind (Entity (Discr_Value)) = E_Discriminant\n+            then\n+               Discr := Corresponding_Discriminant (Entity (Discr_Value));\n+\n+               if Present (Discr)\n+                 and then Scope (Discr) = Base_Type (Expr_Type)\n+               then\n+                  --  Parent is constrained by new discriminant. Obtain\n+                  --  Value of original discriminant in expression. If the\n+                  --  new discriminant has been used to constrain more than\n+                  --  one of the stored discriminants, this will provide the\n+                  --  required consistency check.\n+\n+                  Append_Elmt\n+                    (Make_Selected_Component (Loc,\n+                       Prefix        =>\n+                         Duplicate_Subexpr_No_Checks\n+                           (Expr, Name_Req => True),\n+                       Selector_Name =>\n+                         Make_Identifier (Loc, Chars (Discr))),\n+                     New_Constraints);\n+\n+               else\n+                  --  Discriminant of more remote ancestor ???\n+\n+                  return;\n+               end if;\n+\n+            --  Derived type definition has an explicit value for this\n+            --  stored discriminant.\n+\n+            else\n+               Append_Elmt\n+                 (Duplicate_Subexpr_No_Checks (Discr_Value),\n+                  New_Constraints);\n+            end if;\n+\n+            Next_Elmt (Constraint);\n+         end loop;\n+\n+         --  Use the unconstrained expression type to retrieve the\n+         --  discriminants of the parent, and apply momentarily the\n+         --  discriminant constraint synthesized above.\n+\n+         --  Note: We use Expr_Type instead of Target_Type since the number of\n+         --  actual discriminants may be different due to the presence of\n+         --  stored discriminants and cause Build_Discriminant_Checks to fail.\n+\n+         Set_Discriminant_Constraint (Expr_Type, New_Constraints);\n+         Cond := Build_Discriminant_Checks (Expr, Expr_Type);\n+         Set_Discriminant_Constraint (Expr_Type, Old_Constraints);\n+\n+         Insert_Action (N,\n+           Make_Raise_Constraint_Error (Loc,\n+             Condition => Cond,\n+             Reason    => CE_Discriminant_Check_Failed));\n+      end Make_Discriminant_Constraint_Check;\n+\n+   --  Start of processing for Apply_Type_Conversion_Checks\n+\n    begin\n       if Inside_A_Generic then\n          return;\n@@ -3704,91 +3800,42 @@ package body Checks is\n             end if;\n          end;\n \n-      elsif Comes_From_Source (N)\n-        and then not Discriminant_Checks_Suppressed (Target_Type)\n-        and then Is_Record_Type (Target_Type)\n-        and then Is_Derived_Type (Target_Type)\n-        and then not Is_Tagged_Type (Target_Type)\n-        and then not Is_Constrained (Target_Type)\n-        and then Present (Stored_Constraint (Target_Type))\n-      then\n-         --  An unconstrained derived type may have inherited discriminant.\n-         --  Build an actual discriminant constraint list using the stored\n-         --  constraint, to verify that the expression of the parent type\n-         --  satisfies the constraints imposed by the (unconstrained) derived\n-         --  type. This applies to value conversions, not to view conversions\n-         --  of tagged types.\n-\n-         declare\n-            Loc         : constant Source_Ptr := Sloc (N);\n-            Cond        : Node_Id;\n-            Constraint  : Elmt_Id;\n-            Discr_Value : Node_Id;\n-            Discr       : Entity_Id;\n-\n-            New_Constraints : constant Elist_Id := New_Elmt_List;\n-            Old_Constraints : constant Elist_Id :=\n-              Discriminant_Constraint (Expr_Type);\n+      --  Generate discriminant constraint checks for access types on the\n+      --  designated target type's stored constraints.\n \n-         begin\n-            Constraint := First_Elmt (Stored_Constraint (Target_Type));\n-            while Present (Constraint) loop\n-               Discr_Value := Node (Constraint);\n+      --  Do we need to generate subtype predicate checks here as well ???\n \n-               if Is_Entity_Name (Discr_Value)\n-                 and then Ekind (Entity (Discr_Value)) = E_Discriminant\n-               then\n-                  Discr := Corresponding_Discriminant (Entity (Discr_Value));\n-\n-                  if Present (Discr)\n-                    and then Scope (Discr) = Base_Type (Expr_Type)\n-                  then\n-                     --  Parent is constrained by new discriminant. Obtain\n-                     --  Value of original discriminant in expression. If the\n-                     --  new discriminant has been used to constrain more than\n-                     --  one of the stored discriminants, this will provide the\n-                     --  required consistency check.\n-\n-                     Append_Elmt\n-                       (Make_Selected_Component (Loc,\n-                          Prefix        =>\n-                            Duplicate_Subexpr_No_Checks\n-                              (Expr, Name_Req => True),\n-                          Selector_Name =>\n-                            Make_Identifier (Loc, Chars (Discr))),\n-                        New_Constraints);\n-\n-                  else\n-                     --  Discriminant of more remote ancestor ???\n+      elsif Comes_From_Source (N)\n+        and then Ekind (Target_Type) = E_General_Access_Type\n \n-                     return;\n-                  end if;\n+        --  Check that both of the designated types have known discriminants,\n+        --  and that such checks on the target type are not suppressed.\n \n-               --  Derived type definition has an explicit value for this\n-               --  stored discriminant.\n+        and then Has_Discriminants (Directly_Designated_Type (Target_Type))\n+        and then Has_Discriminants (Directly_Designated_Type (Expr_Type))\n+        and then not Discriminant_Checks_Suppressed\n+                       (Directly_Designated_Type (Target_Type))\n \n-               else\n-                  Append_Elmt\n-                    (Duplicate_Subexpr_No_Checks (Discr_Value),\n-                     New_Constraints);\n-               end if;\n-\n-               Next_Elmt (Constraint);\n-            end loop;\n+        --  Verify the designated type of the target has stored constraints\n \n-            --  Use the unconstrained expression type to retrieve the\n-            --  discriminants of the parent, and apply momentarily the\n-            --  discriminant constraint synthesized above.\n+        and then Present\n+                   (Stored_Constraint (Directly_Designated_Type (Target_Type)))\n+      then\n+         Make_Discriminant_Constraint_Check\n+           (Target_Type => Directly_Designated_Type (Target_Type),\n+            Expr_Type   => Directly_Designated_Type (Expr_Type));\n \n-            Set_Discriminant_Constraint (Expr_Type, New_Constraints);\n-            Cond := Build_Discriminant_Checks (Expr, Expr_Type);\n-            Set_Discriminant_Constraint (Expr_Type, Old_Constraints);\n+      --  Create discriminant checks for the Target_Type's stored constraints\n \n-            Insert_Action (N,\n-              Make_Raise_Constraint_Error (Loc,\n-                Condition => Cond,\n-                Reason    => CE_Discriminant_Check_Failed));\n-         end;\n+      elsif Comes_From_Source (N)\n+        and then not Discriminant_Checks_Suppressed (Target_Type)\n+        and then Is_Record_Type (Target_Type)\n+        and then Is_Derived_Type (Target_Type)\n+        and then not Is_Tagged_Type (Target_Type)\n+        and then not Is_Constrained (Target_Type)\n+        and then Present (Stored_Constraint (Target_Type))\n+      then\n+         Make_Discriminant_Constraint_Check (Target_Type, Expr_Type);\n \n       --  For arrays, checks are set now, but conversions are applied during\n       --  expansion, to take into accounts changes of representation. The"}]}