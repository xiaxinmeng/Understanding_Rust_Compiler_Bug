{"sha": "83624b6040aaf0039e65b3160fcbc1111def7260", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODM2MjRiNjA0MGFhZjAwMzllNjViMzE2MGZjYmMxMTExZGVmNzI2MA==", "commit": {"author": {"name": "Thomas Preud'homme", "email": "thomas.preudhomme@arm.com", "date": "2016-11-25T10:03:38Z"}, "committer": {"name": "Thomas Preud'homme", "email": "thopre01@gcc.gnu.org", "date": "2016-11-25T10:03:38Z"}, "message": "Fix PR77673: bswap loads passed end of object\n\n2016-11-25  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n\n    gcc/\n    PR tree-optimization/77673\n    * tree-ssa-math-opts.c (struct symbolic_number): Add new src field.\n    (init_symbolic_number): Initialize src field from src parameter.\n    (perform_symbolic_merge): Select most dominated statement as the\n    source statement.  Set src field of resulting n structure from the\n    input src with the lowest address.\n    (find_bswap_or_nop): Rename source_stmt into ins_stmt.\n    (bswap_replace): Rename src_stmt into ins_stmt.  Initially get source\n    of load from src field rather than insertion statement.  Cancel\n    optimization if statement analyzed is not dominated by the insertion\n    statement.\n    (pass_optimize_bswap::execute): Rename src_stmt to ins_stmt.  Compute\n    dominance information.\n\n    gcc/testsuite/\n    PR tree-optimization/77673\n    * gcc.dg/pr77673.c: New test.\n\nFrom-SVN: r242869", "tree": {"sha": "8853865975f89e472ce29295e57c7d64f0c3f271", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8853865975f89e472ce29295e57c7d64f0c3f271"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/83624b6040aaf0039e65b3160fcbc1111def7260", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83624b6040aaf0039e65b3160fcbc1111def7260", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83624b6040aaf0039e65b3160fcbc1111def7260", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83624b6040aaf0039e65b3160fcbc1111def7260/comments", "author": {"login": "RoboTux", "id": 272327, "node_id": "MDQ6VXNlcjI3MjMyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/272327?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RoboTux", "html_url": "https://github.com/RoboTux", "followers_url": "https://api.github.com/users/RoboTux/followers", "following_url": "https://api.github.com/users/RoboTux/following{/other_user}", "gists_url": "https://api.github.com/users/RoboTux/gists{/gist_id}", "starred_url": "https://api.github.com/users/RoboTux/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RoboTux/subscriptions", "organizations_url": "https://api.github.com/users/RoboTux/orgs", "repos_url": "https://api.github.com/users/RoboTux/repos", "events_url": "https://api.github.com/users/RoboTux/events{/privacy}", "received_events_url": "https://api.github.com/users/RoboTux/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "605040b41ae0e2a7a2361b563f082a9ee7d9696f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/605040b41ae0e2a7a2361b563f082a9ee7d9696f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/605040b41ae0e2a7a2361b563f082a9ee7d9696f"}], "stats": {"total": 84, "additions": 70, "deletions": 14}, "files": [{"sha": "69e123588559488684884c42d031a1801f9d95ba", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83624b6040aaf0039e65b3160fcbc1111def7260/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83624b6040aaf0039e65b3160fcbc1111def7260/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=83624b6040aaf0039e65b3160fcbc1111def7260", "patch": "@@ -1,3 +1,19 @@\n+2016-11-25  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n+\n+\tPR tree-optimization/77673\n+\t* tree-ssa-math-opts.c (struct symbolic_number): Add new src field.\n+\t(init_symbolic_number): Initialize src field from src parameter.\n+\t(perform_symbolic_merge): Select most dominated statement as the\n+\tsource statement.  Set src field of resulting n structure from the\n+\tinput src with the lowest address.\n+\t(find_bswap_or_nop): Rename source_stmt into ins_stmt.\n+\t(bswap_replace): Rename src_stmt into ins_stmt.  Initially get source\n+\tof load from src field rather than insertion statement.  Cancel\n+\toptimization if statement analyzed is not dominated by the insertion\n+\tstatement.\n+\t(pass_optimize_bswap::execute): Rename src_stmt to ins_stmt.  Compute\n+\tdominance information.\n+\n 2016-11-25  Eric Botcazou  <ebotcazou@adacore.com>\n \n \tPR ada/67205"}, {"sha": "7e1aace6837097ebbb4dadb542472c7991375e9b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83624b6040aaf0039e65b3160fcbc1111def7260/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83624b6040aaf0039e65b3160fcbc1111def7260/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=83624b6040aaf0039e65b3160fcbc1111def7260", "patch": "@@ -1,3 +1,8 @@\n+2016-11-25  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n+\n+\tPR tree-optimization/77673\n+\t* gcc.dg/pr77673.c: New test.\n+\n 2016-11-25  Martin Jambor  <mjambor@suse.cz>\n \n \tPR tree-optimization/70965"}, {"sha": "e03bcb9284d1e5a0e496cfa547fdbab630bec04f", "filename": "gcc/testsuite/gcc.dg/pr77673.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83624b6040aaf0039e65b3160fcbc1111def7260/gcc%2Ftestsuite%2Fgcc.dg%2Fpr77673.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83624b6040aaf0039e65b3160fcbc1111def7260/gcc%2Ftestsuite%2Fgcc.dg%2Fpr77673.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr77673.c?ref=83624b6040aaf0039e65b3160fcbc1111def7260", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile { target fpic } } */\n+/* { dg-require-effective-target bswap32 } */\n+/* { dg-options \"-O2 -fPIC -fdump-tree-bswap\" } */\n+/* { dg-additional-options \"-march=z900\" { target s390*-*-* } } */\n+\n+void mach_parse_compressed(unsigned char* ptr, unsigned long int* val)\n+{\n+  if (ptr[0] < 0xC0U) {\n+    *val = ptr[0] + ptr[1];\n+    return;\n+  }\n+\n+  *val = ((unsigned long int)(ptr[0]) << 24)\n+    | ((unsigned long int)(ptr[1]) << 16)\n+    | ((unsigned long int)(ptr[2]) << 8)\n+    | ptr[3];\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"load_dst_\\\\d+ =.* if \\\\(\" \"bswap\" } } */"}, {"sha": "b0b0c2440aec025c551da76ea637f7b9a50acc43", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 30, "deletions": 14, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83624b6040aaf0039e65b3160fcbc1111def7260/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83624b6040aaf0039e65b3160fcbc1111def7260/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=83624b6040aaf0039e65b3160fcbc1111def7260", "patch": "@@ -1957,6 +1957,7 @@ struct symbolic_number {\n   tree base_addr;\n   tree offset;\n   HOST_WIDE_INT bytepos;\n+  tree src;\n   tree alias_set;\n   tree vuse;\n   unsigned HOST_WIDE_INT range;\n@@ -2061,6 +2062,7 @@ init_symbolic_number (struct symbolic_number *n, tree src)\n     return false;\n \n   n->base_addr = n->offset = n->alias_set = n->vuse = NULL_TREE;\n+  n->src = src;\n \n   /* Set up the symbolic number N by setting each byte to a value between 1 and\n      the byte size of rhs1.  The highest order byte is set to n->size and the\n@@ -2185,6 +2187,7 @@ perform_symbolic_merge (gimple *source_stmt1, struct symbolic_number *n1,\n       uint64_t inc;\n       HOST_WIDE_INT start_sub, end_sub, end1, end2, end;\n       struct symbolic_number *toinc_n_ptr, *n_end;\n+      basic_block bb1, bb2;\n \n       if (!n1->base_addr || !n2->base_addr\n \t  || !operand_equal_p (n1->base_addr, n2->base_addr, 0))\n@@ -2198,15 +2201,20 @@ perform_symbolic_merge (gimple *source_stmt1, struct symbolic_number *n1,\n \t{\n \t  n_start = n1;\n \t  start_sub = n2->bytepos - n1->bytepos;\n-\t  source_stmt = source_stmt1;\n \t}\n       else\n \t{\n \t  n_start = n2;\n \t  start_sub = n1->bytepos - n2->bytepos;\n-\t  source_stmt = source_stmt2;\n \t}\n \n+      bb1 = gimple_bb (source_stmt1);\n+      bb2 = gimple_bb (source_stmt2);\n+      if (dominated_by_p (CDI_DOMINATORS, bb1, bb2))\n+\tsource_stmt = source_stmt1;\n+      else\n+\tsource_stmt = source_stmt2;\n+\n       /* Find the highest address at which a load is performed and\n \t compute related info.  */\n       end1 = n1->bytepos + (n1->range - 1);\n@@ -2263,6 +2271,7 @@ perform_symbolic_merge (gimple *source_stmt1, struct symbolic_number *n1,\n   n->vuse = n_start->vuse;\n   n->base_addr = n_start->base_addr;\n   n->offset = n_start->offset;\n+  n->src = n_start->src;\n   n->bytepos = n_start->bytepos;\n   n->type = n_start->type;\n   size = TYPE_PRECISION (n->type) / BITS_PER_UNIT;\n@@ -2512,7 +2521,7 @@ find_bswap_or_nop (gimple *stmt, struct symbolic_number *n, bool *bswap)\n   uint64_t cmpxchg = CMPXCHG;\n   uint64_t cmpnop = CMPNOP;\n \n-  gimple *source_stmt;\n+  gimple *ins_stmt;\n   int limit;\n \n   /* The last parameter determines the depth search limit.  It usually\n@@ -2522,9 +2531,9 @@ find_bswap_or_nop (gimple *stmt, struct symbolic_number *n, bool *bswap)\n      in libgcc, and for initial shift/and operation of the src operand.  */\n   limit = TREE_INT_CST_LOW (TYPE_SIZE_UNIT (gimple_expr_type (stmt)));\n   limit += 1 + (int) ceil_log2 ((unsigned HOST_WIDE_INT) limit);\n-  source_stmt = find_bswap_or_nop_1 (stmt, n, limit);\n+  ins_stmt = find_bswap_or_nop_1 (stmt, n, limit);\n \n-  if (!source_stmt)\n+  if (!ins_stmt)\n     return NULL;\n \n   /* Find real size of result (highest non-zero byte).  */\n@@ -2576,7 +2585,7 @@ find_bswap_or_nop (gimple *stmt, struct symbolic_number *n, bool *bswap)\n     return NULL;\n \n   n->range *= BITS_PER_UNIT;\n-  return source_stmt;\n+  return ins_stmt;\n }\n \n namespace {\n@@ -2625,7 +2634,7 @@ class pass_optimize_bswap : public gimple_opt_pass\n    changing of basic block.  */\n \n static bool\n-bswap_replace (gimple *cur_stmt, gimple *src_stmt, tree fndecl,\n+bswap_replace (gimple *cur_stmt, gimple *ins_stmt, tree fndecl,\n \t       tree bswap_type, tree load_type, struct symbolic_number *n,\n \t       bool bswap)\n {\n@@ -2634,25 +2643,31 @@ bswap_replace (gimple *cur_stmt, gimple *src_stmt, tree fndecl,\n   gimple *bswap_stmt;\n \n   gsi = gsi_for_stmt (cur_stmt);\n-  src = gimple_assign_rhs1 (src_stmt);\n+  src = n->src;\n   tgt = gimple_assign_lhs (cur_stmt);\n \n   /* Need to load the value from memory first.  */\n   if (n->base_addr)\n     {\n-      gimple_stmt_iterator gsi_ins = gsi_for_stmt (src_stmt);\n+      gimple_stmt_iterator gsi_ins = gsi_for_stmt (ins_stmt);\n       tree addr_expr, addr_tmp, val_expr, val_tmp;\n       tree load_offset_ptr, aligned_load_type;\n       gimple *addr_stmt, *load_stmt;\n       unsigned align;\n       HOST_WIDE_INT load_offset = 0;\n+      basic_block ins_bb, cur_bb;\n+\n+      ins_bb = gimple_bb (ins_stmt);\n+      cur_bb = gimple_bb (cur_stmt);\n+      if (!dominated_by_p (CDI_DOMINATORS, cur_bb, ins_bb))\n+\treturn false;\n \n       align = get_object_alignment (src);\n \n       /* Move cur_stmt just before  one of the load of the original\n \t to ensure it has the same VUSE.  See PR61517 for what could\n \t go wrong.  */\n-      if (gimple_bb (cur_stmt) != gimple_bb (src_stmt))\n+      if (gimple_bb (cur_stmt) != gimple_bb (ins_stmt))\n \treset_flow_sensitive_info (gimple_assign_lhs (cur_stmt));\n       gsi_move_before (&gsi, &gsi_ins);\n       gsi = gsi_for_stmt (cur_stmt);\n@@ -2827,6 +2842,7 @@ pass_optimize_bswap::execute (function *fun)\n \n   memset (&nop_stats, 0, sizeof (nop_stats));\n   memset (&bswap_stats, 0, sizeof (bswap_stats));\n+  calculate_dominance_info (CDI_DOMINATORS);\n \n   FOR_EACH_BB_FN (bb, fun)\n     {\n@@ -2838,7 +2854,7 @@ pass_optimize_bswap::execute (function *fun)\n \t variant wouldn't be detected.  */\n       for (gsi = gsi_last_bb (bb); !gsi_end_p (gsi);)\n         {\n-\t  gimple *src_stmt, *cur_stmt = gsi_stmt (gsi);\n+\t  gimple *ins_stmt, *cur_stmt = gsi_stmt (gsi);\n \t  tree fndecl = NULL_TREE, bswap_type = NULL_TREE, load_type;\n \t  enum tree_code code;\n \t  struct symbolic_number n;\n@@ -2871,9 +2887,9 @@ pass_optimize_bswap::execute (function *fun)\n \t      continue;\n \t    }\n \n-\t  src_stmt = find_bswap_or_nop (cur_stmt, &n, &bswap);\n+\t  ins_stmt = find_bswap_or_nop (cur_stmt, &n, &bswap);\n \n-\t  if (!src_stmt)\n+\t  if (!ins_stmt)\n \t    continue;\n \n \t  switch (n.range)\n@@ -2907,7 +2923,7 @@ pass_optimize_bswap::execute (function *fun)\n \t  if (bswap && !fndecl && n.range != 16)\n \t    continue;\n \n-\t  if (bswap_replace (cur_stmt, src_stmt, fndecl, bswap_type, load_type,\n+\t  if (bswap_replace (cur_stmt, ins_stmt, fndecl, bswap_type, load_type,\n \t\t\t     &n, bswap))\n \t    changed = true;\n \t}"}]}