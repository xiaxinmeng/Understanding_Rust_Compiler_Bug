{"sha": "4ae906e46c4c173b79c9c60c6157ff68e05f7464", "node_id": "C_kwDOANBUbNoAKDRhZTkwNmU0NmM0YzE3M2I3OWM5YzYwYzYxNTdmZjY4ZTA1Zjc0NjQ", "commit": {"author": {"name": "Francois-Xavier Coudert", "email": "fxcoudert@gmail.com", "date": "2021-12-25T14:07:12Z"}, "committer": {"name": "Francois-Xavier Coudert", "email": "fxcoudert@gmail.com", "date": "2021-12-25T14:07:12Z"}, "message": "Fortran: simplify library code for integer-to-decimal conversion\n\nlibgfortran/ChangeLog:\n\n\tPR libfortran/81986\n\tPR libfortran/99191\n\n\t* libgfortran.h: Remove gfc_xtoa(), adjust gfc_itoa() and\n\tGFC_ITOA_BUF_SIZE.\n\t* io/write.c (write_decimal): conversion parameter is always\n\tgfc_itoa(), so remove it. Protect from overflow.\n\t(xtoa): Move gfc_xtoa and update its name.\n\t(xtoa_big): Renamed from ztoa_big for consistency.\n\t(write_z): Adjust to new function names.\n\t(write_i, write_integer): Remove last arg of write_decimal.\n\t* runtime/backtrace.c (error_callback): Comment on the use of\n\tgfc_itoa().\n\t* runtime/error.c (gfc_xtoa): Move to io/write.c.\n\t* runtime/string.c (gfc_itoa): Take an unsigned argument,\n\tremove the handling of negative values.", "tree": {"sha": "30547d298d8ea29320e37d7e765c363ff22135ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/30547d298d8ea29320e37d7e765c363ff22135ee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4ae906e46c4c173b79c9c60c6157ff68e05f7464", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ae906e46c4c173b79c9c60c6157ff68e05f7464", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ae906e46c4c173b79c9c60c6157ff68e05f7464", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ae906e46c4c173b79c9c60c6157ff68e05f7464/comments", "author": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ffb5418fb79e951e4a8cc818e2408106aa58b9a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffb5418fb79e951e4a8cc818e2408106aa58b9a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffb5418fb79e951e4a8cc818e2408106aa58b9a8"}], "stats": {"total": 148, "additions": 66, "deletions": 82}, "files": [{"sha": "41c9162ea4c755af7cdcaa370dc9cf6f13615526", "filename": "libgfortran/io/write.c", "status": "modified", "additions": 48, "deletions": 22, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ae906e46c4c173b79c9c60c6157ff68e05f7464/libgfortran%2Fio%2Fwrite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ae906e46c4c173b79c9c60c6157ff68e05f7464/libgfortran%2Fio%2Fwrite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fwrite.c?ref=4ae906e46c4c173b79c9c60c6157ff68e05f7464", "patch": "@@ -795,10 +795,10 @@ write_boz (st_parameter_dt *dtp, const fnode *f, const char *q, int n, int len)\n \n static void\n write_decimal (st_parameter_dt *dtp, const fnode *f, const char *source,\n-\t       int len,\n-               const char *(*conv) (GFC_INTEGER_LARGEST, char *, size_t))\n+\t       int len)\n {\n   GFC_INTEGER_LARGEST n = 0;\n+  GFC_UINTEGER_LARGEST absn;\n   int w, m, digits, nsign, nzero, nblank;\n   char *p;\n   const char *q;\n@@ -831,18 +831,14 @@ write_decimal (st_parameter_dt *dtp, const fnode *f, const char *source,\n \n   sign = calculate_sign (dtp, n < 0);\n   if (n < 0)\n-    n = -n;\n+    /* Use unsigned to protect from overflow. */\n+    absn = -(GFC_UINTEGER_LARGEST) n;\n+  else\n+    absn = n;\n   nsign = sign == S_NONE ? 0 : 1;\n \n-  /* conv calls itoa which sets the negative sign needed\n-     by write_integer. The sign '+' or '-' is set below based on sign\n-     calculated above, so we just point past the sign in the string\n-     before proceeding to avoid double signs in corner cases.\n-     (see PR38504)  */\n-  q = conv (n, itoa_buf, sizeof (itoa_buf));\n-  if (*q == '-')\n-    q++;\n-\n+  /* gfc_itoa() converts the nonnegative value to decimal representation.  */\n+  q = gfc_itoa (absn, itoa_buf, sizeof (itoa_buf));\n   digits = strlen (q);\n \n   /* Select a width if none was specified.  The idea here is to always\n@@ -945,7 +941,37 @@ write_decimal (st_parameter_dt *dtp, const fnode *f, const char *source,\n }\n \n \n-/* Convert unsigned octal to ascii.  */\n+/* Convert hexadecimal to ASCII.  */\n+\n+static const char *\n+xtoa (GFC_UINTEGER_LARGEST n, char *buffer, size_t len)\n+{\n+  int digit;\n+  char *p;\n+\n+  assert (len >= GFC_XTOA_BUF_SIZE);\n+\n+  if (n == 0)\n+    return \"0\";\n+\n+  p = buffer + GFC_XTOA_BUF_SIZE - 1;\n+  *p = '\\0';\n+\n+  while (n != 0)\n+    {\n+      digit = n & 0xF;\n+      if (digit > 9)\n+\tdigit += 'A' - '0' - 10;\n+\n+      *--p = '0' + digit;\n+      n >>= 4;\n+    }\n+\n+  return p;\n+}\n+\n+\n+/* Convert unsigned octal to ASCII.  */\n \n static const char *\n otoa (GFC_UINTEGER_LARGEST n, char *buffer, size_t len)\n@@ -970,7 +996,7 @@ otoa (GFC_UINTEGER_LARGEST n, char *buffer, size_t len)\n }\n \n \n-/* Convert unsigned binary to ascii.  */\n+/* Convert unsigned binary to ASCII.  */\n \n static const char *\n btoa (GFC_UINTEGER_LARGEST n, char *buffer, size_t len)\n@@ -994,7 +1020,7 @@ btoa (GFC_UINTEGER_LARGEST n, char *buffer, size_t len)\n   return p;\n }\n \n-/* The following three functions, btoa_big, otoa_big, and ztoa_big, are needed\n+/* The following three functions, btoa_big, otoa_big, and xtoa_big, are needed\n    to convert large reals with kind sizes that exceed the largest integer type\n    available on certain platforms.  In these cases, byte by byte conversion is\n    performed. Endianess is taken into account.  */\n@@ -1132,10 +1158,10 @@ otoa_big (const char *s, char *buffer, int len, GFC_UINTEGER_LARGEST *n)\n   return q;\n }\n \n-/* Conversion to hexidecimal.  */\n+/* Conversion to hexadecimal.  */\n \n static const char *\n-ztoa_big (const char *s, char *buffer, int len, GFC_UINTEGER_LARGEST *n)\n+xtoa_big (const char *s, char *buffer, int len, GFC_UINTEGER_LARGEST *n)\n {\n   static char a[16] = {'0', '1', '2', '3', '4', '5', '6', '7',\n     '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};\n@@ -1177,7 +1203,7 @@ ztoa_big (const char *s, char *buffer, int len, GFC_UINTEGER_LARGEST *n)\n \t}\n     }\n \n-  /* write_z, which calls ztoa_big, is called from transfer.c,\n+  /* write_z, which calls xtoa_big, is called from transfer.c,\n      formatted_transfer_scalar_write.  There it is passed the kind as\n      argument, which means a maximum of 16.  The buffer is large\n      enough, but the compiler does not know that, so shut up the\n@@ -1201,7 +1227,7 @@ ztoa_big (const char *s, char *buffer, int len, GFC_UINTEGER_LARGEST *n)\n void\n write_i (st_parameter_dt *dtp, const fnode *f, const char *p, int len)\n {\n-  write_decimal (dtp, f, p, len, (void *) gfc_itoa);\n+  write_decimal (dtp, f, p, len);\n }\n \n \n@@ -1258,13 +1284,13 @@ write_z (st_parameter_dt *dtp, const fnode *f, const char *source, int len)\n \n   if (len > (int) sizeof (GFC_UINTEGER_LARGEST))\n     {\n-      p = ztoa_big (source, itoa_buf, len, &n);\n+      p = xtoa_big (source, itoa_buf, len, &n);\n       write_boz (dtp, f, p, n, len);\n     }\n   else\n     {\n       n = extract_uint (source, len);\n-      p = gfc_xtoa (n, itoa_buf, sizeof (itoa_buf));\n+      p = xtoa (n, itoa_buf, sizeof (itoa_buf));\n       write_boz (dtp, f, p, n, len);\n     }\n }\n@@ -1365,7 +1391,7 @@ write_integer (st_parameter_dt *dtp, const char *source, int kind)\n   f.u.integer.w = width;\n   f.u.integer.m = -1;\n   f.format = FMT_NONE;\n-  write_decimal (dtp, &f, source, kind, (void *) gfc_itoa);\n+  write_decimal (dtp, &f, source, kind);\n }\n \n "}, {"sha": "6d60a9ca314613ce1c791392c8753af77f35d227", "filename": "libgfortran/libgfortran.h", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ae906e46c4c173b79c9c60c6157ff68e05f7464/libgfortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ae906e46c4c173b79c9c60c6157ff68e05f7464/libgfortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Flibgfortran.h?ref=4ae906e46c4c173b79c9c60c6157ff68e05f7464", "patch": "@@ -710,7 +710,7 @@ internal_proto(show_backtrace);\n #define GFC_LARGEST_BUF (sizeof (GFC_INTEGER_LARGEST))\n #endif\n \n-#define GFC_ITOA_BUF_SIZE (sizeof (GFC_INTEGER_LARGEST) * 3 + 2)\n+#define GFC_ITOA_BUF_SIZE (sizeof (GFC_INTEGER_LARGEST) * 3 + 1)\n #define GFC_XTOA_BUF_SIZE (GFC_LARGEST_BUF * 2 + 1)\n #define GFC_OTOA_BUF_SIZE (GFC_LARGEST_BUF * 3 + 1)\n #define GFC_BTOA_BUF_SIZE (GFC_LARGEST_BUF * 8 + 1)\n@@ -738,9 +738,6 @@ extern int st_printf (const char *, ...)\n   __attribute__((format (gfc_printf, 1, 2)));\n internal_proto(st_printf);\n \n-extern const char *gfc_xtoa (GFC_UINTEGER_LARGEST, char *, size_t);\n-internal_proto(gfc_xtoa);\n-\n extern _Noreturn void os_error (const char *);\n iexport_proto(os_error);\n \n@@ -896,7 +893,7 @@ internal_proto(fc_strdup);\n extern char *fc_strdup_notrim(const char *, gfc_charlen_type);\n internal_proto(fc_strdup_notrim);\n \n-extern const char *gfc_itoa(GFC_INTEGER_LARGEST, char *, size_t);\n+extern const char *gfc_itoa(GFC_UINTEGER_LARGEST, char *, size_t);\n internal_proto(gfc_itoa);\n \n /* io/intrinsics.c */"}, {"sha": "403c7c37f1813333fc149b2827f465a1a2b9d3f9", "filename": "libgfortran/runtime/backtrace.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ae906e46c4c173b79c9c60c6157ff68e05f7464/libgfortran%2Fruntime%2Fbacktrace.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ae906e46c4c173b79c9c60c6157ff68e05f7464/libgfortran%2Fruntime%2Fbacktrace.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2Fbacktrace.c?ref=4ae906e46c4c173b79c9c60c6157ff68e05f7464", "patch": "@@ -97,6 +97,7 @@ error_callback (void *data, const char *msg, int errnum)\n \t  iov[1].iov_len = strlen (msg);\n \t  iov[2].iov_base = (char*) \", errno: \";\n \t  iov[2].iov_len = strlen (iov[2].iov_base);\n+\t  /* Async-signal-safe function, errnum must be positive.  */\n \t  const char *p = gfc_itoa (errnum, errbuf, sizeof (errbuf));\n \t  iov[3].iov_base = (char*) p;\n \t  iov[3].iov_len = strlen (p);"}, {"sha": "ba6ff866a01f982f5985fb66b5feef23ffad6d8e", "filename": "libgfortran/runtime/error.c", "status": "modified", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ae906e46c4c173b79c9c60c6157ff68e05f7464/libgfortran%2Fruntime%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ae906e46c4c173b79c9c60c6157ff68e05f7464/libgfortran%2Fruntime%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2Ferror.c?ref=4ae906e46c4c173b79c9c60c6157ff68e05f7464", "patch": "@@ -219,37 +219,6 @@ exit_error (int status)\n }\n \n \n-\n-/* gfc_xtoa()-- Integer to hexadecimal conversion.  */\n-\n-const char *\n-gfc_xtoa (GFC_UINTEGER_LARGEST n, char *buffer, size_t len)\n-{\n-  int digit;\n-  char *p;\n-\n-  assert (len >= GFC_XTOA_BUF_SIZE);\n-\n-  if (n == 0)\n-    return \"0\";\n-\n-  p = buffer + GFC_XTOA_BUF_SIZE - 1;\n-  *p = '\\0';\n-\n-  while (n != 0)\n-    {\n-      digit = n & 0xF;\n-      if (digit > 9)\n-\tdigit += 'A' - '0' - 10;\n-\n-      *--p = '0' + digit;\n-      n >>= 4;\n-    }\n-\n-  return p;\n-}\n-\n-\n /* Hopefully thread-safe wrapper for a strerror() style function.  */\n \n char *"}, {"sha": "835027a7cd6b7a7e40ff7bee7cf18396d2f28199", "filename": "libgfortran/runtime/string.c", "status": "modified", "additions": 15, "deletions": 24, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ae906e46c4c173b79c9c60c6157ff68e05f7464/libgfortran%2Fruntime%2Fstring.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ae906e46c4c173b79c9c60c6157ff68e05f7464/libgfortran%2Fruntime%2Fstring.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2Fstring.c?ref=4ae906e46c4c173b79c9c60c6157ff68e05f7464", "patch": "@@ -169,46 +169,37 @@ find_option (st_parameter_common *cmp, const char *s1, gfc_charlen_type s1_len,\n }\n \n \n-/* gfc_itoa()-- Integer to decimal conversion.\n-   The itoa function is a widespread non-standard extension to\n-   standard C, often declared in <stdlib.h>.  Even though the itoa\n-   defined here is a static function we take care not to conflict with\n-   any prior non-static declaration.  Hence the 'gfc_' prefix, which\n-   is normally reserved for functions with external linkage.  Notably,\n-   in contrast to the *printf() family of functions, this ought to be\n-   async-signal-safe.  */\n+/* Integer to decimal conversion.\n+\n+   This function is much more restricted than the widespread (but\n+   non-standard) itoa() function.  This version has the following\n+   characteristics:\n+\n+     - it takes only non-negative arguments\n+     - it is async-signal-safe (we use it runtime/backtrace.c)\n+     - it works in base 10 (see xtoa, otoa, btoa functions\n+       in io/write.c for other radices)\n+ */\n \n const char *\n-gfc_itoa (GFC_INTEGER_LARGEST n, char *buffer, size_t len)\n+gfc_itoa (GFC_UINTEGER_LARGEST n, char *buffer, size_t len)\n {\n-  int negative;\n   char *p;\n-  GFC_UINTEGER_LARGEST t;\n \n   if (len < GFC_ITOA_BUF_SIZE)\n     sys_abort ();\n \n   if (n == 0)\n     return \"0\";\n \n-  negative = 0;\n-  t = n;\n-  if (n < 0)\n-    {\n-      negative = 1;\n-      t = -(GFC_UINTEGER_LARGEST) n;  /* Must use unsigned to protect from overflow. */\n-    }\n-\n   p = buffer + GFC_ITOA_BUF_SIZE - 1;\n   *p = '\\0';\n \n-  while (t != 0)\n+  while (n != 0)\n     {\n-      *--p = '0' + (t % 10);\n-      t /= 10;\n+      *--p = '0' + (n % 10);\n+      n /= 10;\n     }\n \n-  if (negative)\n-    *--p = '-';\n   return p;\n }"}]}