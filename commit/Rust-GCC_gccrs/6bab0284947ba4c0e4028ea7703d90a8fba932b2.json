{"sha": "6bab0284947ba4c0e4028ea7703d90a8fba932b2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmJhYjAyODQ5NDdiYTRjMGU0MDI4ZWE3NzAzZDkwYThmYmE5MzJiMg==", "commit": {"author": {"name": "Andrew Haley", "email": "aph@redhat.com", "date": "2009-11-17T18:05:00Z"}, "committer": {"name": "Andrew Haley", "email": "aph@gcc.gnu.org", "date": "2009-11-17T18:05:00Z"}, "message": "posix-threads.cc (park): Rewrite code to handle time.\n\n2009-11-17  Andrew Haley  <aph@redhat.com>\n\n\t* posix-threads.cc (park): Rewrite code to handle time.\n\tMove mutex lock before the call to compare_and_swap to avoid a\n\trace condition.\n\tAdd some assertions.\n\t(unpark): Add an assertion.\n\t(init): Move here from posix-threads.h.\n\t* include/posix-threads.h (destroy): removed.\n\nFrom-SVN: r154265", "tree": {"sha": "20d1549cdc546ec2d35dc2b1c11cf122162ef5db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/20d1549cdc546ec2d35dc2b1c11cf122162ef5db"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6bab0284947ba4c0e4028ea7703d90a8fba932b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bab0284947ba4c0e4028ea7703d90a8fba932b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6bab0284947ba4c0e4028ea7703d90a8fba932b2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bab0284947ba4c0e4028ea7703d90a8fba932b2/comments", "author": {"login": "theRealAph", "id": 254637, "node_id": "MDQ6VXNlcjI1NDYzNw==", "avatar_url": "https://avatars.githubusercontent.com/u/254637?v=4", "gravatar_id": "", "url": "https://api.github.com/users/theRealAph", "html_url": "https://github.com/theRealAph", "followers_url": "https://api.github.com/users/theRealAph/followers", "following_url": "https://api.github.com/users/theRealAph/following{/other_user}", "gists_url": "https://api.github.com/users/theRealAph/gists{/gist_id}", "starred_url": "https://api.github.com/users/theRealAph/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/theRealAph/subscriptions", "organizations_url": "https://api.github.com/users/theRealAph/orgs", "repos_url": "https://api.github.com/users/theRealAph/repos", "events_url": "https://api.github.com/users/theRealAph/events{/privacy}", "received_events_url": "https://api.github.com/users/theRealAph/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "37740cd3af83c312403d90defa95b2832dbc582a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37740cd3af83c312403d90defa95b2832dbc582a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37740cd3af83c312403d90defa95b2832dbc582a"}], "stats": {"total": 107, "additions": 66, "deletions": 41}, "files": [{"sha": "8d7ddc867b4a68c8bbd8682e0f739aeb12f30c8b", "filename": "libjava/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bab0284947ba4c0e4028ea7703d90a8fba932b2/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bab0284947ba4c0e4028ea7703d90a8fba932b2/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=6bab0284947ba4c0e4028ea7703d90a8fba932b2", "patch": "@@ -1,3 +1,13 @@\n+2009-11-17  Andrew Haley  <aph@redhat.com>\n+\n+\t* posix-threads.cc (park): Rewrite code to handle time.\n+\tMove mutex lock before the call to compare_and_swap to avoid a\n+\trace condition.\n+\tAdd some assertions.\n+\t(unpark): Add an assertion.\n+\t(init): Move here from posix-threads.h.\n+\t* include/posix-threads.h (destroy): removed.\n+\n 2009-11-13  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* exception.cc (PERSONALITY_FUNCTION): Fix oversight."}, {"sha": "59e65f74499b61b0194cc85b3d4d3aa514468ff1", "filename": "libjava/include/posix-threads.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bab0284947ba4c0e4028ea7703d90a8fba932b2/libjava%2Finclude%2Fposix-threads.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bab0284947ba4c0e4028ea7703d90a8fba932b2/libjava%2Finclude%2Fposix-threads.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fposix-threads.h?ref=6bab0284947ba4c0e4028ea7703d90a8fba932b2", "patch": "@@ -374,13 +374,6 @@ struct ParkHelper\n   void unpark ();\n };\n \n-inline void\n-ParkHelper::init ()\n-{\n-  pthread_mutex_init (&mutex, NULL);\n-  pthread_cond_init (&cond, NULL);\n-}\n-\n inline void\n ParkHelper::destroy ()\n {"}, {"sha": "a26c3bd336e78406473514031264ea99cd91494e", "filename": "libjava/posix-threads.cc", "status": "modified", "additions": 56, "deletions": 34, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bab0284947ba4c0e4028ea7703d90a8fba932b2/libjava%2Fposix-threads.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bab0284947ba4c0e4028ea7703d90a8fba932b2/libjava%2Fposix-threads.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fposix-threads.cc?ref=6bab0284947ba4c0e4028ea7703d90a8fba932b2", "patch": "@@ -359,15 +359,16 @@ ParkHelper::unpark ()\n   if (compare_and_swap \n       (ptr, Thread::THREAD_PARK_RUNNING, Thread::THREAD_PARK_PERMIT))\n     return;\n-  \n+\n   /* If this thread is parked, put it into state RUNNING and send it a\n      signal.  */\n-  if (compare_and_swap \n+  if (compare_and_swap\n       (ptr, Thread::THREAD_PARK_PARKED, Thread::THREAD_PARK_RUNNING))\n     {\n       pthread_mutex_lock (&mutex);\n-      pthread_cond_signal (&cond);\n+      int result = pthread_cond_signal (&cond);\n       pthread_mutex_unlock (&mutex);\n+      JvAssert (result == 0);\n     }\n }\n \n@@ -380,6 +381,14 @@ ParkHelper::deactivate ()\n   permit = ::java::lang::Thread::THREAD_PARK_DEAD;\n }\n \n+void\n+ParkHelper::init ()\n+{\n+  pthread_mutex_init (&mutex, NULL);\n+  pthread_cond_init (&cond, NULL);\n+  permit = ::java::lang::Thread::THREAD_PARK_RUNNING;\n+}\n+\n /**\n  * Blocks the thread until a matching _Jv_ThreadUnpark() occurs, the\n  * thread is interrupted or the optional timeout expires.  If an\n@@ -407,32 +416,44 @@ ParkHelper::park (jboolean isAbsolute, jlong time)\n     return;\n \n   struct timespec ts;\n-  jlong millis = 0, nanos = 0;\n \n   if (time)\n     {\n+      unsigned long long seconds;\n+      unsigned long usec;\n+\n       if (isAbsolute)\n \t{\n-\t  millis = time;\n-\t  nanos = 0;\n+\t  ts.tv_sec = time / 1000;\n+\t  ts.tv_nsec = (time % 1000) * 1000 * 1000;\n \t}\n       else\n-\t{\n-\t  millis = java::lang::System::currentTimeMillis();\n-\t  nanos = time;\n-\t}\n-\n-      if (millis > 0 || nanos > 0)\n \t{\n \t  // Calculate the abstime corresponding to the timeout.\n-\t  // Everything is in milliseconds.\n-\t  //\n-\t  // We use `unsigned long long' rather than jlong because our\n-\t  // caller may pass up to Long.MAX_VALUE millis.  This would\n-\t  // overflow the range of a timespec.\n+\t  jlong nanos = time;\n+\t  jlong millis = 0;\n \n-\t  unsigned long long m = (unsigned long long)millis;\n-\t  unsigned long long seconds = m / 1000; \n+\t  // For better accuracy, should use pthread_condattr_setclock\n+\t  // and clock_gettime.\n+#ifdef HAVE_GETTIMEOFDAY\n+\t  timeval tv;\n+\t  gettimeofday (&tv, NULL);\n+\t  usec = tv.tv_usec;\n+\t  seconds = tv.tv_sec;\n+#else\n+\t  unsigned long long startTime\n+\t    = java::lang::System::currentTimeMillis();\n+\t  seconds = startTime / 1000;\n+\t  /* Assume we're about half-way through this millisecond.  */\n+\t  usec = (startTime % 1000) * 1000 + 500;\n+#endif\n+\t  /* These next two statements cannot overflow.  */\n+\t  usec += nanos / 1000;\n+\t  usec += (millis % 1000) * 1000;\n+\t  /* These two statements could overflow only if tv.tv_sec was\n+\t     insanely large.  */\n+\t  seconds += millis / 1000;\n+\t  seconds += usec / 1000000;\n \n \t  ts.tv_sec = seconds;\n \t  if (ts.tv_sec < 0 || (unsigned long long)ts.tv_sec != seconds)\n@@ -442,29 +463,30 @@ ParkHelper::park (jboolean isAbsolute, jlong time)\n \t      millis = nanos = 0;\n \t    }\n \t  else\n-\t    {\n-\t      m %= 1000;\n-\t      ts.tv_nsec = m * 1000000 + (unsigned long long)nanos;\n-\t    }\n+\t    /* This next statement also cannot overflow.  */\n+\t    ts.tv_nsec = (usec % 1000000) * 1000 + (nanos % 1000);\n \t}\n     }\n-      \n+\n+  pthread_mutex_lock (&mutex);\n   if (compare_and_swap \n       (ptr, Thread::THREAD_PARK_RUNNING, Thread::THREAD_PARK_PARKED))\n     {\n-      pthread_mutex_lock (&mutex);\n-      if (millis == 0 && nanos == 0)\n-\tpthread_cond_wait (&cond, &mutex);\n+      int result = 0;\n+\n+      if (! time)\n+\tresult = pthread_cond_wait (&cond, &mutex);\n       else\n-\tpthread_cond_timedwait (&cond, &mutex, &ts);\n-      pthread_mutex_unlock (&mutex);\n-      \n+\tresult = pthread_cond_timedwait (&cond, &mutex, &ts);\n+\n+      JvAssert (result == 0 || result == ETIMEDOUT);\n+\n       /* If we were unparked by some other thread, this will already\n-\t be in state THREAD_PARK_RUNNING.  If we timed out, we have to\n-\t do it ourself.  */\n-      compare_and_swap \n-\t(ptr, Thread::THREAD_PARK_PARKED, Thread::THREAD_PARK_RUNNING);\n+\t be in state THREAD_PARK_RUNNING.  If we timed out or were\n+\t interrupted, we have to do it ourself.  */\n+      permit = Thread::THREAD_PARK_RUNNING;\n     }\n+  pthread_mutex_unlock (&mutex);\n }\n \n static void"}]}