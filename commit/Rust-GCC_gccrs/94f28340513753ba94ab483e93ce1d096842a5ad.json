{"sha": "94f28340513753ba94ab483e93ce1d096842a5ad", "node_id": "C_kwDOANBUbNoAKDk0ZjI4MzQwNTEzNzUzYmE5NGFiNDgzZTkzY2UxZDA5Njg0MmE1YWQ", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-10-25T11:39:07Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-10-26T10:29:48Z"}, "message": "Move negative stride bias out of dr_misalignment\n\nThis moves applying of a bias for negative stride accesses out of\ndr_misalignment in favor of a more general optional offset argument.\nThe negative bias is now computed by get_load_store_type and applied\naccordingly to determine the alignment support scheme.  Likewise\nthe peeling/versioning code is adjusted albeit that still assumes\nwe'll end up with VMAT_CONTIGUOUS_DOWN or VMAT_CONTIGUOUS_REVERSE\nbut at least when not so (VMAT_STRIDED_SLP is one possibility) then\nget_load_store_type will _not_ falsely report an aligned access but\ninstead an access with known misalignment.\n\nThis fixes PR96109.\n\n2021-10-25  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/96109\n\t* tree-vectorizer.h (dr_misalignment): Add optional offset\n\tparameter.\n\t* tree-vect-data-refs.c (dr_misalignment): Likewise.  Remove\n\toffset applied for negative stride accesses.\n\t(vect_enhance_data_refs_alignment): Compute negative stride\n\taccess offset and pass it to dr_misalignment.\n\t* tree-vect-stmts.c (get_negative_load_store_type): Pass\n\tnegative offset to dr_misalignment.\n\t(get_group_load_store_type): Likewise.\n\t(get_load_store_type): Likewise.\n\t(vectorizable_store): Remove asserts about alignment.\n\t(vectorizable_load): Likewise.", "tree": {"sha": "5003f5167c34608c17e64b23298438c50a57a2ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5003f5167c34608c17e64b23298438c50a57a2ed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/94f28340513753ba94ab483e93ce1d096842a5ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94f28340513753ba94ab483e93ce1d096842a5ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94f28340513753ba94ab483e93ce1d096842a5ad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94f28340513753ba94ab483e93ce1d096842a5ad/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "54e4e1769e44b925c35c0ffc11723027ff855bd7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54e4e1769e44b925c35c0ffc11723027ff855bd7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54e4e1769e44b925c35c0ffc11723027ff855bd7"}], "stats": {"total": 81, "additions": 48, "deletions": 33}, "files": [{"sha": "cda89ef9725b56f2ece53c9d9da974150c255426", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 39, "deletions": 19, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94f28340513753ba94ab483e93ce1d096842a5ad/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94f28340513753ba94ab483e93ce1d096842a5ad/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=94f28340513753ba94ab483e93ce1d096842a5ad", "patch": "@@ -887,10 +887,11 @@ vect_slp_analyze_instance_dependence (vec_info *vinfo, slp_instance instance)\n   return res;\n }\n \n-/* Return the misalignment of DR_INFO accessed in VECTYPE.  */\n+/* Return the misalignment of DR_INFO accessed in VECTYPE with OFFSET\n+   applied.  */\n \n int\n-dr_misalignment (dr_vec_info *dr_info, tree vectype)\n+dr_misalignment (dr_vec_info *dr_info, tree vectype, poly_int64 offset)\n {\n   HOST_WIDE_INT diff = 0;\n   /* Alignment is only analyzed for the first element of a DR group,\n@@ -919,13 +920,9 @@ dr_misalignment (dr_vec_info *dr_info, tree vectype)\n \t\ttargetm.vectorize.preferred_vector_alignment (vectype)))\n     return DR_MISALIGNMENT_UNKNOWN;\n \n-  /* If this is a backward running DR then first access in the larger\n-     vectype actually is N-1 elements before the address in the DR.\n-     Adjust misalign accordingly.  */\n-  poly_int64 misalignment = misalign + diff;\n-  if (tree_int_cst_sgn (DR_STEP (dr_info->dr)) < 0)\n-    misalignment += ((TYPE_VECTOR_SUBPARTS (vectype) - 1)\n-\t\t     * -TREE_INT_CST_LOW (TYPE_SIZE_UNIT (TREE_TYPE (vectype))));\n+  /* Apply the offset from the DR group start and the externally supplied\n+     offset which can for example result from a negative stride access.  */\n+  poly_int64 misalignment = misalign + diff + offset;\n \n   /* vect_compute_data_ref_alignment will have ensured that target_alignment\n      is constant and otherwise set misalign to DR_MISALIGNMENT_UNKNOWN.  */\n@@ -1549,8 +1546,15 @@ vect_get_peeling_costs_all_drs (loop_vec_info loop_vinfo,\n       int misalignment;\n       unsigned HOST_WIDE_INT alignment;\n \n+      bool negative = tree_int_cst_compare (DR_STEP (dr_info->dr),\n+\t\t\t\t\t    size_zero_node) < 0;\n+      poly_int64 off = 0;\n+      if (negative)\n+\toff = ((TYPE_VECTOR_SUBPARTS (vectype) - 1)\n+\t       * -TREE_INT_CST_LOW (TYPE_SIZE_UNIT (TREE_TYPE (vectype))));\n+\n       if (npeel == 0)\n-\tmisalignment = dr_misalignment (dr_info, vectype);\n+\tmisalignment = dr_misalignment (dr_info, vectype, off);\n       else if (dr_info == dr0_info\n \t       || vect_dr_aligned_if_peeled_dr_is (dr_info, dr0_info))\n \tmisalignment = 0;\n@@ -1560,7 +1564,7 @@ vect_get_peeling_costs_all_drs (loop_vec_info loop_vinfo,\n \tmisalignment = DR_MISALIGNMENT_UNKNOWN;\n       else\n \t{\n-\t  misalignment = dr_misalignment (dr_info, vectype);\n+\t  misalignment = dr_misalignment (dr_info, vectype, off);\n \t  misalignment += npeel * TREE_INT_CST_LOW (DR_STEP (dr_info->dr));\n \t  misalignment &= alignment - 1;\n \t}\n@@ -1960,8 +1964,11 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t       */\n \t      unsigned int target_align =\n \t\tDR_TARGET_ALIGNMENT (dr_info).to_constant ();\n-\t      unsigned int dr_size = vect_get_scalar_dr_size (dr_info);\n-\t      unsigned int mis = dr_misalignment (dr_info, vectype);\n+\t      unsigned HOST_WIDE_INT dr_size = vect_get_scalar_dr_size (dr_info);\n+\t      poly_int64 off = 0;\n+\t      if (negative)\n+\t\toff = (TYPE_VECTOR_SUBPARTS (vectype) - 1) * -dr_size;\n+\t      unsigned int mis = dr_misalignment (dr_info, vectype, off);\n \t      mis = negative ? mis : -mis;\n \t      if (mis != 0)\n \t\tnpeel_tmp = (mis & (target_align - 1)) / dr_size;\n@@ -2238,8 +2245,13 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n                  updating DR_MISALIGNMENT values.  The peeling factor is the\n                  vectorization factor minus the misalignment as an element\n                  count.  */\n+\t      tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n+\t      poly_int64 off = 0;\n+\t      if (negative)\n+\t\toff = ((TYPE_VECTOR_SUBPARTS (vectype) - 1)\n+\t\t       * -TREE_INT_CST_LOW (TYPE_SIZE_UNIT (TREE_TYPE (vectype))));\n \t      unsigned int mis\n-\t\t= dr_misalignment (dr0_info, STMT_VINFO_VECTYPE (stmt_info));\n+\t\t= dr_misalignment (dr0_info, vectype, off);\n \t      mis = negative ? mis : -mis;\n \t      /* If known_alignment_for_access_p then we have set\n \t         DR_MISALIGNMENT which is only done if we know it at compiler\n@@ -2383,19 +2395,27 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n       FOR_EACH_VEC_ELT (datarefs, i, dr)\n         {\n \t  dr_vec_info *dr_info = loop_vinfo->lookup_dr (dr);\n-\t  stmt_vec_info stmt_info = dr_info->stmt;\n-\t  tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n-\t  int misalignment;\n-\t  if ((misalignment = dr_misalignment (dr_info, vectype)) == 0\n-\t      || !vect_relevant_for_alignment_p (dr_info))\n+\t  if (!vect_relevant_for_alignment_p (dr_info))\n \t    continue;\n \n+\t  stmt_vec_info stmt_info = dr_info->stmt;\n \t  if (STMT_VINFO_STRIDED_P (stmt_info))\n \t    {\n \t      do_versioning = false;\n \t      break;\n \t    }\n \n+\t  tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n+\t  bool negative = tree_int_cst_compare (DR_STEP (dr),\n+\t\t\t\t\t\tsize_zero_node) < 0;\n+\t  poly_int64 off = 0;\n+\t  if (negative)\n+\t    off = ((TYPE_VECTOR_SUBPARTS (vectype) - 1)\n+\t\t   * -TREE_INT_CST_LOW (TYPE_SIZE_UNIT (TREE_TYPE (vectype))));\n+\t  int misalignment;\n+\t  if ((misalignment = dr_misalignment (dr_info, vectype, off)) == 0)\n+\t    continue;\n+\n \t  enum dr_alignment_support supportable_dr_alignment\n \t    = vect_supportable_dr_alignment (loop_vinfo, dr_info, vectype,\n \t\t\t\t\t     misalignment);"}, {"sha": "3cd338a73eb66d266829818b4eabbd479dfd88ba", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94f28340513753ba94ab483e93ce1d096842a5ad/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94f28340513753ba94ab483e93ce1d096842a5ad/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=94f28340513753ba94ab483e93ce1d096842a5ad", "patch": "@@ -2001,7 +2001,7 @@ get_negative_load_store_type (vec_info *vinfo,\n   *poffset = ((-TYPE_VECTOR_SUBPARTS (vectype) + 1)\n \t      * TREE_INT_CST_LOW (TYPE_SIZE_UNIT (TREE_TYPE (vectype))));\n \n-  int misalignment = dr_misalignment (dr_info, vectype);\n+  int misalignment = dr_misalignment (dr_info, vectype, *poffset);\n   alignment_support_scheme\n     = vect_supportable_dr_alignment (vinfo, dr_info, vectype, misalignment);\n   if (alignment_support_scheme != dr_aligned\n@@ -2010,8 +2010,8 @@ get_negative_load_store_type (vec_info *vinfo,\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t \"negative step but alignment required.\\n\");\n-      return VMAT_ELEMENTWISE;\n       *poffset = 0;\n+      return VMAT_ELEMENTWISE;\n     }\n \n   if (vls_type == VLS_STORE_INVARIANT)\n@@ -2320,7 +2320,7 @@ get_group_load_store_type (vec_info *vinfo, stmt_vec_info stmt_info,\n     }\n   else\n     {\n-      *misalignment = dr_misalignment (first_dr_info, vectype);\n+      *misalignment = dr_misalignment (first_dr_info, vectype, *poffset);\n       *alignment_support_scheme\n \t= vect_supportable_dr_alignment (vinfo, first_dr_info, vectype,\n \t\t\t\t\t *misalignment);\n@@ -2470,7 +2470,7 @@ get_load_store_type (vec_info  *vinfo, stmt_vec_info stmt_info,\n \t  else\n \t    *memory_access_type = VMAT_CONTIGUOUS;\n \t  *misalignment = dr_misalignment (STMT_VINFO_DR_INFO (stmt_info),\n-\t\t\t\t\t   vectype);\n+\t\t\t\t\t   vectype, *poffset);\n \t  *alignment_support_scheme\n \t    = vect_supportable_dr_alignment (vinfo,\n \t\t\t\t\t     STMT_VINFO_DR_INFO (stmt_info),\n@@ -8252,10 +8252,7 @@ vectorizable_store (vec_info *vinfo,\n \n \t      align = known_alignment (DR_TARGET_ALIGNMENT (first_dr_info));\n \t      if (alignment_support_scheme == dr_aligned)\n-\t\t{\n-\t\t  gcc_assert (aligned_access_p (first_dr_info, vectype));\n-\t\t  misalign = 0;\n-\t\t}\n+\t\tmisalign = 0;\n \t      else if (misalignment == DR_MISALIGNMENT_UNKNOWN)\n \t\t{\n \t\t  align = dr_alignment (vect_dr_behavior (vinfo, first_dr_info));\n@@ -8340,7 +8337,7 @@ vectorizable_store (vec_info *vinfo,\n \t\t\t\t\t  ? dataref_offset\n \t\t\t\t\t  : build_int_cst (ref_type, 0));\n \t\t  if (alignment_support_scheme == dr_aligned)\n-\t\t    gcc_assert (aligned_access_p (first_dr_info, vectype));\n+\t\t    ;\n \t\t  else\n \t\t    TREE_TYPE (data_ref)\n \t\t      = build_aligned_type (TREE_TYPE (data_ref),\n@@ -9589,10 +9586,7 @@ vectorizable_load (vec_info *vinfo,\n \t\t    align =\n \t\t      known_alignment (DR_TARGET_ALIGNMENT (first_dr_info));\n \t\t    if (alignment_support_scheme == dr_aligned)\n-\t\t      {\n-\t\t\tgcc_assert (aligned_access_p (first_dr_info, vectype));\n-\t\t\tmisalign = 0;\n-\t\t      }\n+\t\t      misalign = 0;\n \t\t    else if (misalignment == DR_MISALIGNMENT_UNKNOWN)\n \t\t      {\n \t\t\talign = dr_alignment"}, {"sha": "52cdfbfae02a75ac6038de4d84e100e226e5e9e2", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94f28340513753ba94ab483e93ce1d096842a5ad/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94f28340513753ba94ab483e93ce1d096842a5ad/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=94f28340513753ba94ab483e93ce1d096842a5ad", "patch": "@@ -1606,7 +1606,8 @@ set_dr_misalignment (dr_vec_info *dr_info, int val)\n   dr_info->misalignment = val;\n }\n \n-extern int dr_misalignment (dr_vec_info *dr_info, tree vectype);\n+extern int dr_misalignment (dr_vec_info *dr_info, tree vectype,\n+\t\t\t    poly_int64 offset = 0);\n \n #define SET_DR_MISALIGNMENT(DR, VAL) set_dr_misalignment (DR, VAL)\n "}]}