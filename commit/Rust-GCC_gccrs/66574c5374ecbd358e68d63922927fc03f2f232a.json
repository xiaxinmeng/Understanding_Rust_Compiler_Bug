{"sha": "66574c5374ecbd358e68d63922927fc03f2f232a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjY1NzRjNTM3NGVjYmQzNThlNjhkNjM5MjI5MjdmYzAzZjJmMjMyYQ==", "commit": {"author": {"name": "Hongtao Liu", "email": "hongtao.liu@intel.com", "date": "2019-06-14T15:41:43Z"}, "committer": {"name": "H.J. Lu", "email": "hjl@gcc.gnu.org", "date": "2019-06-14T15:41:43Z"}, "message": "i386: Update SSE <-> integer move costs\n\nSince inline_secondary_memory_needed has\n\n  /* ??? This is a lie.  We do have moves between mmx/general, and for\n     mmx/sse2.  But by saying we need secondary memory we discourage the\n     register allocator from using the mmx registers unless needed.  */\n  if (MMX_CLASS_P (class1) != MMX_CLASS_P (class2))\n    return true;\n\nmoves between MMX and non-MMX units require secondary memory.   There\nis no need to check moves between MMX and integer units.\n\nstruct processor_costs has:\n\n  const int mmxsse_to_integer;  /* cost of moving mmxsse register to\n                                   integer.  */\n  const int ssemmx_to_integer;  /* cost of moving integer to mmxsse register. */\n\nThis patch also renames mmxsse_to_integer to sse_to_integer and\nssemmx_to_integer to integer_to_sse.\n\nTested on Linux/x86-64.\n\n\tPR target/90877\n\t* config/i386/i386-features.c\n\t(dimode_scalar_chain::compute_convert_gain): Replace\n\tmmxsse_to_integer with sse_to_integer.\n\t* config/i386/i386.c (ix86_register_move_cost): Verify that\n\tmoves between MMX and non-MMX units require secondary memory.\n\tCorrect costs of moves between SSE and integer units.\n\t* config/i386/i386.h (processor_costs): Rename cost of moving\n\tSSE register to integer to sse_to_integer.  Rename cost of\n\tmoving integer register to SSE to integer_to_sse.\n\nFrom-SVN: r272294", "tree": {"sha": "20a9feee570cc504bf8347e92937e6e4507fa0b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/20a9feee570cc504bf8347e92937e6e4507fa0b9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/66574c5374ecbd358e68d63922927fc03f2f232a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66574c5374ecbd358e68d63922927fc03f2f232a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66574c5374ecbd358e68d63922927fc03f2f232a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66574c5374ecbd358e68d63922927fc03f2f232a/comments", "author": {"login": "algebra84", "id": 22926165, "node_id": "MDQ6VXNlcjIyOTI2MTY1", "avatar_url": "https://avatars.githubusercontent.com/u/22926165?v=4", "gravatar_id": "", "url": "https://api.github.com/users/algebra84", "html_url": "https://github.com/algebra84", "followers_url": "https://api.github.com/users/algebra84/followers", "following_url": "https://api.github.com/users/algebra84/following{/other_user}", "gists_url": "https://api.github.com/users/algebra84/gists{/gist_id}", "starred_url": "https://api.github.com/users/algebra84/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/algebra84/subscriptions", "organizations_url": "https://api.github.com/users/algebra84/orgs", "repos_url": "https://api.github.com/users/algebra84/repos", "events_url": "https://api.github.com/users/algebra84/events{/privacy}", "received_events_url": "https://api.github.com/users/algebra84/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9f119e29269b9a63f36c014b1429e96c133148b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f119e29269b9a63f36c014b1429e96c133148b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f119e29269b9a63f36c014b1429e96c133148b4"}], "stats": {"total": 36, "additions": 25, "deletions": 11}, "files": [{"sha": "deba76066594090bf205e5295b2ed5d7ba3d1cf4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66574c5374ecbd358e68d63922927fc03f2f232a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66574c5374ecbd358e68d63922927fc03f2f232a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=66574c5374ecbd358e68d63922927fc03f2f232a", "patch": "@@ -1,3 +1,15 @@\n+2019-06-14  Hongtao Liu  <hongtao.liu@intel.com>\n+\n+\tPR target/90877\n+\t* config/i386/i386-features.c\n+\t(dimode_scalar_chain::compute_convert_gain): Replace\n+\tmmxsse_to_integer with sse_to_integer.\n+\t* config/i386/i386.c (ix86_register_move_cost): Verify that\n+\tmoves between MMX and non-MMX units require secondary memory.\n+\tCorrect costs of moves between SSE and integer units.\n+\t* config/i386/i386.h (processor_costs): Rename cost of moving\n+\tSSE register to integer to sse_to_integer.  Rename cost of\n+\n 2019-06-14  Matt Thomas  <matt@3am-software.com>\n \t    Matthew Green  <mrg@eterna.com.au>\n \t    Nick Hudson  <skrll@netbsd.org>"}, {"sha": "2eac8f715bb0155ed3dbfdcb145c8a364585b958", "filename": "gcc/config/i386/i386-features.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66574c5374ecbd358e68d63922927fc03f2f232a/gcc%2Fconfig%2Fi386%2Fi386-features.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66574c5374ecbd358e68d63922927fc03f2f232a/gcc%2Fconfig%2Fi386%2Fi386-features.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-features.c?ref=66574c5374ecbd358e68d63922927fc03f2f232a", "patch": "@@ -554,7 +554,7 @@ dimode_scalar_chain::compute_convert_gain ()\n     fprintf (dump_file, \"  Instruction conversion gain: %d\\n\", gain);\n \n   EXECUTE_IF_SET_IN_BITMAP (defs_conv, 0, insn_uid, bi)\n-    cost += DF_REG_DEF_COUNT (insn_uid) * ix86_cost->mmxsse_to_integer;\n+    cost += DF_REG_DEF_COUNT (insn_uid) * ix86_cost->sse_to_integer;\n \n   if (dump_file)\n     fprintf (dump_file, \"  Registers conversion cost: %d\\n\", cost);"}, {"sha": "941e208bcf08a91f128c4a5662216f8a180265b5", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66574c5374ecbd358e68d63922927fc03f2f232a/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66574c5374ecbd358e68d63922927fc03f2f232a/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=66574c5374ecbd358e68d63922927fc03f2f232a", "patch": "@@ -18633,18 +18633,21 @@ ix86_register_move_cost (machine_mode mode, reg_class_t class1_i,\n       return cost;\n     }\n \n-  /* Moves between SSE/MMX and integer unit are expensive.  */\n-  if (MMX_CLASS_P (class1) != MMX_CLASS_P (class2)\n-      || SSE_CLASS_P (class1) != SSE_CLASS_P (class2))\n+  /* Moves between MMX and non-MMX units require secondary memory.  */\n+  if (MMX_CLASS_P (class1) != MMX_CLASS_P (class2))\n+    gcc_unreachable ();\n+\n+  /* Moves between SSE and integer units are expensive.  */\n+  if (SSE_CLASS_P (class1) != SSE_CLASS_P (class2))\n \n     /* ??? By keeping returned value relatively high, we limit the number\n-       of moves between integer and MMX/SSE registers for all targets.\n+       of moves between integer and SSE registers for all targets.\n        Additionally, high value prevents problem with x86_modes_tieable_p(),\n-       where integer modes in MMX/SSE registers are not tieable\n+       where integer modes in SSE registers are not tieable\n        because of missing QImode and HImode moves to, from or between\n        MMX/SSE registers.  */\n-    return MAX (8, MMX_CLASS_P (class1) || MMX_CLASS_P (class2)\n-\t\t? ix86_cost->mmxsse_to_integer : ix86_cost->ssemmx_to_integer);\n+    return MAX (8, SSE_CLASS_P (class1)\n+\t\t? ix86_cost->sse_to_integer : ix86_cost->integer_to_sse);\n \n   if (MAYBE_FLOAT_CLASS_P (class1))\n     return ix86_cost->fp_move;"}, {"sha": "0ac5d65182395161b8acbb51b0b7f97cab30bcde", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66574c5374ecbd358e68d63922927fc03f2f232a/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66574c5374ecbd358e68d63922927fc03f2f232a/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=66574c5374ecbd358e68d63922927fc03f2f232a", "patch": "@@ -276,9 +276,8 @@ struct processor_costs {\n   const int sse_store[5];\t/* cost of storing SSE register\n \t\t\t\t   in SImode, DImode and TImode.  */\n   const int sse_unaligned_store[5];/* cost of unaligned store.  */\n-  const int mmxsse_to_integer;\t/* cost of moving mmxsse register to\n-\t\t\t\t   integer.  */\n-  const int ssemmx_to_integer;  /* cost of moving integer to mmxsse register. */\n+  const int sse_to_integer;\t/* cost of moving SSE register to integer.  */\n+  const int integer_to_sse;\t/* cost of moving integer register to SSE. */\n   const int gather_static, gather_per_elt; /* Cost of gather load is computed\n \t\t\t\t   as static + per_item * nelts. */\n   const int scatter_static, scatter_per_elt; /* Cost of gather store is"}]}