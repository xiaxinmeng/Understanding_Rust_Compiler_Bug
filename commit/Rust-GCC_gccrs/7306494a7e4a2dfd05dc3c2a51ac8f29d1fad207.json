{"sha": "7306494a7e4a2dfd05dc3c2a51ac8f29d1fad207", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzMwNjQ5NGE3ZTRhMmRmZDA1ZGMzYzJhNTFhYzhmMjlkMWZhZDIwNw==", "commit": {"author": {"name": "Steven G. Kargl", "email": "kargls@comcast.net", "date": "2008-05-31T19:19:48Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2008-05-31T19:19:48Z"}, "message": "arith.c (gfc_arith_init_1): Remove now unused r and c variables.\n\n2008-05-31  Steven G. Kargl  <kargls@comcast.net>\n\n\t* arith.c (gfc_arith_init_1): Remove now unused r and c variables.\n\tCleanup numerical inquiry function initialization.\n\t(gfc_arith_done_1): Replace multiple mpfr_clear() invocations with\n\ta single mpfr_clears().\n\t(gfc_check_real_range): Re-arrange logic to eliminate multiple\n\tunnecessary branching and assignments.\n\t(gfc_arith_times): Use mpfr_clears() in preference to multiple\n\tmpfr_clear().\n\t(gfc_arith_divide): Ditto.\n\t(complex_reciprocal): Eliminate now unused variables a, re, im.\n\tCleanup the mpfr abuse.  Use mpfr_clears() in preference to\n\tmultiple mpfr_clear().\n\t(complex_pow): Fix comment whitespace.  Use mpfr_clears() in\n\tpreference to multiple mpfr_clear().\n\t* simplify.c (gfc_simplify_and): Remove blank line.\n\t(gfc_simplify_atan2): Move error checking earlier to eliminate\n\ta now unnecessay gfc_free_expr().\n\t(gfc_simplify_bessel_j0): Remove unnecessary gfc_set_model_kind().\n\t(gfc_simplify_bessel_j1): Ditto.\n\t(gfc_simplify_bessel_jn): Ditto.\n \t(gfc_simplify_bessel_y0): Ditto.\n\t(gfc_simplify_bessel_y1): Ditto.\n\t(gfc_simplify_bessel_yn): Ditto. \n\t(only_convert_cmplx_boz): Eliminate unnecessary duplicate code, and\n\tcombine nested if statement rational expressions.\n\t(gfc_simplify_cos): Use mpfr_clears() in preference to multiple\n\tmpfr_clear().\n\t(gfc_simplify_exp): Ditto.\n\t(gfc_simplify_fraction): Move gfc_set_model_kind() to after the\n\tspecial case of 0.  Use mpfr_clears() in preference to multiple\n\tmpfr_clear().\n\t(gfc_simplify_gamma): Eliminate unnecessary gfc_set_model_kind().\n \t(gfc_simplify_lgamma): Ditto.\n\t(gfc_simplify_log10): Ditto.\n\t(gfc_simplify_log): Move gfc_set_model_kind () inside switch\n\tstatement. Use mpfr_clears() in preference to multiple mpfr_clear().\n\t(gfc_simplify_mod):  Eliminate now unused variables quot, iquot,\n\tand term.  Simplify the mpfr magic.\n\t(gfc_simplify_modulo): Ditto.\n\t(gfc_simplify_nearest): Eliminate unnecessary gfc_set_model_kind().\n\t(gfc_simplify_scale): Use mpfr_clears() in preference to multiple\n\tmpfr_clear().\n\t(gfc_simplify_sin): Ditto\n\t(gfc_simplify_sqrt): Ditto\n\t(gfc_simplify_set_exponent):  Move gfc_set_model_kind() to after the\n\tspecial case of 0.  Use mpfr_clears() in preference to multiple\n\tmpfr_clear().\n\nFrom-SVN: r136239", "tree": {"sha": "e063ea48400045bf54d45b2f7c286bbcef129330", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e063ea48400045bf54d45b2f7c286bbcef129330"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7306494a7e4a2dfd05dc3c2a51ac8f29d1fad207", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7306494a7e4a2dfd05dc3c2a51ac8f29d1fad207", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7306494a7e4a2dfd05dc3c2a51ac8f29d1fad207", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7306494a7e4a2dfd05dc3c2a51ac8f29d1fad207/comments", "author": null, "committer": null, "parents": [{"sha": "794cb45e0be66af6533262e255dd276a1cfb3bd8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/794cb45e0be66af6533262e255dd276a1cfb3bd8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/794cb45e0be66af6533262e255dd276a1cfb3bd8"}], "stats": {"total": 366, "additions": 179, "deletions": 187}, "files": [{"sha": "02861b6879d72452734753aeb9b27220c03dcd4b", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7306494a7e4a2dfd05dc3c2a51ac8f29d1fad207/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7306494a7e4a2dfd05dc3c2a51ac8f29d1fad207/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=7306494a7e4a2dfd05dc3c2a51ac8f29d1fad207", "patch": "@@ -1,3 +1,53 @@\n+2008-05-31  Steven G. Kargl  <kargls@comcast.net>\n+\n+\t* arith.c (gfc_arith_init_1): Remove now unused r and c variables.\n+\tCleanup numerical inquiry function initialization.\n+\t(gfc_arith_done_1): Replace multiple mpfr_clear() invocations with\n+\ta single mpfr_clears().\n+\t(gfc_check_real_range): Re-arrange logic to eliminate multiple\n+\tunnecessary branching and assignments.\n+\t(gfc_arith_times): Use mpfr_clears() in preference to multiple\n+\tmpfr_clear().\n+\t(gfc_arith_divide): Ditto.\n+\t(complex_reciprocal): Eliminate now unused variables a, re, im.\n+\tCleanup the mpfr abuse.  Use mpfr_clears() in preference to\n+\tmultiple mpfr_clear().\n+\t(complex_pow): Fix comment whitespace.  Use mpfr_clears() in\n+\tpreference to multiple mpfr_clear().\n+\t* simplify.c (gfc_simplify_and): Remove blank line.\n+\t(gfc_simplify_atan2): Move error checking earlier to eliminate\n+\ta now unnecessay gfc_free_expr().\n+\t(gfc_simplify_bessel_j0): Remove unnecessary gfc_set_model_kind().\n+\t(gfc_simplify_bessel_j1): Ditto.\n+\t(gfc_simplify_bessel_jn): Ditto.\n+ \t(gfc_simplify_bessel_y0): Ditto.\n+\t(gfc_simplify_bessel_y1): Ditto.\n+\t(gfc_simplify_bessel_yn): Ditto. \n+\t(only_convert_cmplx_boz): Eliminate unnecessary duplicate code, and\n+\tcombine nested if statement rational expressions.\n+\t(gfc_simplify_cos): Use mpfr_clears() in preference to multiple\n+\tmpfr_clear().\n+\t(gfc_simplify_exp): Ditto.\n+\t(gfc_simplify_fraction): Move gfc_set_model_kind() to after the\n+\tspecial case of 0.  Use mpfr_clears() in preference to multiple\n+\tmpfr_clear().\n+\t(gfc_simplify_gamma): Eliminate unnecessary gfc_set_model_kind().\n+ \t(gfc_simplify_lgamma): Ditto.\n+\t(gfc_simplify_log10): Ditto.\n+\t(gfc_simplify_log): Move gfc_set_model_kind () inside switch\n+\tstatement. Use mpfr_clears() in preference to multiple mpfr_clear().\n+\t(gfc_simplify_mod):  Eliminate now unused variables quot, iquot,\n+\tand term.  Simplify the mpfr magic.\n+\t(gfc_simplify_modulo): Ditto.\n+\t(gfc_simplify_nearest): Eliminate unnecessary gfc_set_model_kind().\n+\t(gfc_simplify_scale): Use mpfr_clears() in preference to multiple\n+\tmpfr_clear().\n+\t(gfc_simplify_sin): Ditto\n+\t(gfc_simplify_sqrt): Ditto\n+\t(gfc_simplify_set_exponent):  Move gfc_set_model_kind() to after the\n+\tspecial case of 0.  Use mpfr_clears() in preference to multiple\n+\tmpfr_clear().\n+\n 2008-05-29  Daniel Franke  <franke.daniel@gmail.com>\n \n \tPR target/36348"}, {"sha": "8e6de3068f034f1d58acaf310f92a94808b1c6d8", "filename": "gcc/fortran/arith.c", "status": "modified", "additions": 54, "deletions": 99, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7306494a7e4a2dfd05dc3c2a51ac8f29d1fad207/gcc%2Ffortran%2Farith.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7306494a7e4a2dfd05dc3c2a51ac8f29d1fad207/gcc%2Ffortran%2Farith.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farith.c?ref=7306494a7e4a2dfd05dc3c2a51ac8f29d1fad207", "patch": "@@ -123,24 +123,21 @@ gfc_arith_init_1 (void)\n {\n   gfc_integer_info *int_info;\n   gfc_real_info *real_info;\n-  mpfr_t a, b, c;\n-  mpz_t r;\n+  mpfr_t a, b;\n   int i;\n \n   mpfr_set_default_prec (128);\n   mpfr_init (a);\n-  mpz_init (r);\n \n   /* Convert the minimum and maximum values for each kind into their\n      GNU MP representation.  */\n   for (int_info = gfc_integer_kinds; int_info->kind != 0; int_info++)\n     {\n       /* Huge  */\n-      mpz_set_ui (r, int_info->radix);\n-      mpz_pow_ui (r, r, int_info->digits);\n-\n       mpz_init (int_info->huge);\n-      mpz_sub_ui (int_info->huge, r, 1);\n+      mpz_set_ui (int_info->huge, int_info->radix);\n+      mpz_pow_ui (int_info->huge, int_info->huge, int_info->digits);\n+      mpz_sub_ui (int_info->huge, int_info->huge, 1);\n \n       /* These are the numbers that are actually representable by the\n \t target.  For bases other than two, this needs to be changed.  */\n@@ -164,8 +161,7 @@ gfc_arith_init_1 (void)\n       mpfr_set_z (a, int_info->huge, GFC_RND_MODE);\n       mpfr_log10 (a, a, GFC_RND_MODE);\n       mpfr_trunc (a, a);\n-      gfc_mpfr_to_mpz (r, a);\n-      int_info->range = mpz_get_si (r);\n+      int_info->range = (int) mpfr_get_si (a, GFC_RND_MODE);\n     }\n \n   mpfr_clear (a);\n@@ -176,49 +172,43 @@ gfc_arith_init_1 (void)\n \n       mpfr_init (a);\n       mpfr_init (b);\n-      mpfr_init (c);\n \n       /* huge(x) = (1 - b**(-p)) * b**(emax-1) * b  */\n-      /* a = 1 - b**(-p)  */\n-      mpfr_set_ui (a, 1, GFC_RND_MODE);\n-      mpfr_set_ui (b, real_info->radix, GFC_RND_MODE);\n-      mpfr_pow_si (b, b, -real_info->digits, GFC_RND_MODE);\n-      mpfr_sub (a, a, b, GFC_RND_MODE);\n-\n-      /* c = b**(emax-1)  */\n-      mpfr_set_ui (b, real_info->radix, GFC_RND_MODE);\n-      mpfr_pow_ui (c, b, real_info->max_exponent - 1, GFC_RND_MODE);\n+      /* 1 - b**(-p)  */\n+      mpfr_init (real_info->huge);\n+      mpfr_set_ui (real_info->huge, 1, GFC_RND_MODE);\n+      mpfr_set_ui (a, real_info->radix, GFC_RND_MODE);\n+      mpfr_pow_si (a, a, -real_info->digits, GFC_RND_MODE);\n+      mpfr_sub (real_info->huge, real_info->huge, a, GFC_RND_MODE);\n \n-      /* a = a * c = (1 - b**(-p)) * b**(emax-1)  */\n-      mpfr_mul (a, a, c, GFC_RND_MODE);\n+      /* b**(emax-1)  */\n+      mpfr_set_ui (a, real_info->radix, GFC_RND_MODE);\n+      mpfr_pow_ui (a, a, real_info->max_exponent - 1, GFC_RND_MODE);\n \n-      /* a = (1 - b**(-p)) * b**(emax-1) * b  */\n-      mpfr_mul_ui (a, a, real_info->radix, GFC_RND_MODE);\n+      /* (1 - b**(-p)) * b**(emax-1)  */\n+      mpfr_mul (real_info->huge, real_info->huge, a, GFC_RND_MODE);\n \n-      mpfr_init (real_info->huge);\n-      mpfr_set (real_info->huge, a, GFC_RND_MODE);\n+      /* (1 - b**(-p)) * b**(emax-1) * b  */\n+      mpfr_mul_ui (real_info->huge, real_info->huge, real_info->radix,\n+\t\t   GFC_RND_MODE);\n \n       /* tiny(x) = b**(emin-1)  */\n-      mpfr_set_ui (b, real_info->radix, GFC_RND_MODE);\n-      mpfr_pow_si (b, b, real_info->min_exponent - 1, GFC_RND_MODE);\n-\n       mpfr_init (real_info->tiny);\n-      mpfr_set (real_info->tiny, b, GFC_RND_MODE);\n+      mpfr_set_ui (real_info->tiny, real_info->radix, GFC_RND_MODE);\n+      mpfr_pow_si (real_info->tiny, real_info->tiny,\n+\t\t   real_info->min_exponent - 1, GFC_RND_MODE);\n \n       /* subnormal (x) = b**(emin - digit)  */\n-      mpfr_set_ui (b, real_info->radix, GFC_RND_MODE);\n-      mpfr_pow_si (b, b, real_info->min_exponent - real_info->digits,\n-\t\t   GFC_RND_MODE);\n-\n       mpfr_init (real_info->subnormal);\n-      mpfr_set (real_info->subnormal, b, GFC_RND_MODE);\n+      mpfr_set_ui (real_info->subnormal, real_info->radix, GFC_RND_MODE);\n+      mpfr_pow_si (real_info->subnormal, real_info->subnormal,\n+\t\t   real_info->min_exponent - real_info->digits, GFC_RND_MODE);\n \n       /* epsilon(x) = b**(1-p)  */\n-      mpfr_set_ui (b, real_info->radix, GFC_RND_MODE);\n-      mpfr_pow_si (b, b, 1 - real_info->digits, GFC_RND_MODE);\n-\n       mpfr_init (real_info->epsilon);\n-      mpfr_set (real_info->epsilon, b, GFC_RND_MODE);\n+      mpfr_set_ui (real_info->epsilon, real_info->radix, GFC_RND_MODE);\n+      mpfr_pow_si (real_info->epsilon, real_info->epsilon,\n+\t\t   1 - real_info->digits, GFC_RND_MODE);\n \n       /* range(x) = int(min(log10(huge(x)), -log10(tiny))  */\n       mpfr_log10 (a, real_info->huge, GFC_RND_MODE);\n@@ -227,31 +217,23 @@ gfc_arith_init_1 (void)\n \n       /* a = min(a, b)  */\n       mpfr_min (a, a, b, GFC_RND_MODE);\n-\n       mpfr_trunc (a, a);\n-      gfc_mpfr_to_mpz (r, a);\n-      real_info->range = mpz_get_si (r);\n+      real_info->range = (int) mpfr_get_si (a, GFC_RND_MODE);\n \n       /* precision(x) = int((p - 1) * log10(b)) + k  */\n       mpfr_set_ui (a, real_info->radix, GFC_RND_MODE);\n       mpfr_log10 (a, a, GFC_RND_MODE);\n-\n       mpfr_mul_ui (a, a, real_info->digits - 1, GFC_RND_MODE);\n       mpfr_trunc (a, a);\n-      gfc_mpfr_to_mpz (r, a);\n-      real_info->precision = mpz_get_si (r);\n+      real_info->precision = (int) mpfr_get_si (a, GFC_RND_MODE);\n \n       /* If the radix is an integral power of 10, add one to the precision.  */\n       for (i = 10; i <= real_info->radix; i *= 10)\n \tif (i == real_info->radix)\n \t  real_info->precision++;\n \n-      mpfr_clear (a);\n-      mpfr_clear (b);\n-      mpfr_clear (c);\n+      mpfr_clears (a, b, NULL);\n     }\n-\n-  mpz_clear (r);\n }\n \n \n@@ -271,12 +253,7 @@ gfc_arith_done_1 (void)\n     }\n \n   for (rp = gfc_real_kinds; rp->kind; rp++)\n-    {\n-      mpfr_clear (rp->epsilon);\n-      mpfr_clear (rp->huge);\n-      mpfr_clear (rp->tiny);\n-      mpfr_clear (rp->subnormal);\n-    }\n+    mpfr_clears (rp->epsilon, rp->huge, rp->tiny, rp->subnormal, NULL);\n }\n \n \n@@ -345,29 +322,27 @@ gfc_check_real_range (mpfr_t p, int kind)\n   mpfr_init (q);\n   mpfr_abs (q, p, GFC_RND_MODE);\n \n+  retval = ARITH_OK;\n+\n   if (mpfr_inf_p (p))\n     {\n-      if (gfc_option.flag_range_check == 0)\n-\tretval = ARITH_OK;\n-      else\n+      if (gfc_option.flag_range_check != 0)\n \tretval = ARITH_OVERFLOW;\n     }\n   else if (mpfr_nan_p (p))\n     {\n-      if (gfc_option.flag_range_check == 0)\n-\tretval = ARITH_OK;\n-      else\n+      if (gfc_option.flag_range_check != 0)\n \tretval = ARITH_NAN;\n     }\n   else if (mpfr_sgn (q) == 0)\n-    retval = ARITH_OK;\n+    {\n+      mpfr_clear (q);\n+      return retval;\n+    }\n   else if (mpfr_cmp (q, gfc_real_kinds[i].huge) > 0)\n     {\n       if (gfc_option.flag_range_check == 0)\n-\t{\n-\t  mpfr_set_inf (p, mpfr_sgn (p));\n-\t  retval = ARITH_OK;\n-\t}\n+\tmpfr_set_inf (p, mpfr_sgn (p));\n       else\n \tretval = ARITH_OVERFLOW;\n     }\n@@ -383,7 +358,6 @@ gfc_check_real_range (mpfr_t p, int kind)\n \t    }\n \t  else\n \t    mpfr_set_ui (p, 0, GFC_RND_MODE);\n-\t  retval = ARITH_OK;\n \t}\n       else\n \tretval = ARITH_UNDERFLOW;\n@@ -412,11 +386,7 @@ gfc_check_real_range (mpfr_t p, int kind)\n \tmpfr_neg (p, q, GMP_RNDN);\n       else\n \tmpfr_set (p, q, GMP_RNDN);\n-\n-      retval = ARITH_OK;\n     }\n-  else\n-    retval = ARITH_OK;\n \n   mpfr_clear (q);\n \n@@ -779,8 +749,7 @@ gfc_arith_times (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n       mpfr_mul (y, op1->value.complex.i, op2->value.complex.r, GFC_RND_MODE);\n       mpfr_add (result->value.complex.i, x, y, GFC_RND_MODE);\n \n-      mpfr_clear (x);\n-      mpfr_clear (y);\n+      mpfr_clears (x, y, NULL);\n       break;\n \n     default:\n@@ -858,9 +827,7 @@ gfc_arith_divide (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n       mpfr_div (result->value.complex.i, result->value.complex.i, div,\n \t\tGFC_RND_MODE);\n \n-      mpfr_clear (x);\n-      mpfr_clear (y);\n-      mpfr_clear (div);\n+      mpfr_clears (x, y, div, NULL);\n       break;\n \n     default:\n@@ -879,30 +846,22 @@ gfc_arith_divide (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n static void\n complex_reciprocal (gfc_expr *op)\n {\n-  mpfr_t mod, a, re, im;\n+  mpfr_t mod, tmp;\n \n   gfc_set_model (op->value.complex.r);\n   mpfr_init (mod);\n-  mpfr_init (a);\n-  mpfr_init (re);\n-  mpfr_init (im);\n+  mpfr_init (tmp);\n \n   mpfr_mul (mod, op->value.complex.r, op->value.complex.r, GFC_RND_MODE);\n-  mpfr_mul (a, op->value.complex.i, op->value.complex.i, GFC_RND_MODE);\n-  mpfr_add (mod, mod, a, GFC_RND_MODE);\n+  mpfr_mul (tmp, op->value.complex.i, op->value.complex.i, GFC_RND_MODE);\n+  mpfr_add (mod, mod, tmp, GFC_RND_MODE);\n \n-  mpfr_div (re, op->value.complex.r, mod, GFC_RND_MODE);\n+  mpfr_div (op->value.complex.r, op->value.complex.r, mod, GFC_RND_MODE);\n \n-  mpfr_neg (im, op->value.complex.i, GFC_RND_MODE);\n-  mpfr_div (im, im, mod, GFC_RND_MODE);\n+  mpfr_neg (op->value.complex.i, op->value.complex.i, GFC_RND_MODE);\n+  mpfr_div (op->value.complex.i, op->value.complex.i, mod, GFC_RND_MODE);\n \n-  mpfr_set (op->value.complex.r, re, GFC_RND_MODE);\n-  mpfr_set (op->value.complex.i, im, GFC_RND_MODE);\n-\n-  mpfr_clear (re);\n-  mpfr_clear (im);\n-  mpfr_clear (mod);\n-  mpfr_clear (a);\n+  mpfr_clears (tmp, mod, NULL);\n }\n \n \n@@ -934,8 +893,8 @@ complex_pow (gfc_expr *result, gfc_expr *base, mpz_t power)\n   mpfr_set (x_r, base->value.complex.r, GFC_RND_MODE);\n   mpfr_set (x_i, base->value.complex.i, GFC_RND_MODE);\n \n-/* Macro for complex multiplication. We have to take care that\n-   res_r/res_i and a_r/a_i can (and will) be the same variable.  */\n+  /* Macro for complex multiplication. We have to take care that\n+     res_r/res_i and a_r/a_i can (and will) be the same variable.  */\n #define CMULT(res_r,res_i,a_r,a_i,b_r,b_i) \\\n     mpfr_mul (re, a_r, b_r, GFC_RND_MODE), \\\n     mpfr_mul (tmp, a_i, b_i, GFC_RND_MODE), \\\n@@ -964,11 +923,7 @@ complex_pow (gfc_expr *result, gfc_expr *base, mpz_t power)\n #undef res_i\n #undef CMULT\n \n-  mpfr_clear (x_r);\n-  mpfr_clear (x_i);\n-  mpfr_clear (tmp);\n-  mpfr_clear (re);\n-  mpfr_clear (im);\n+  mpfr_clears (x_r, x_i, tmp, re, im, NULL);\n }\n \n "}, {"sha": "58c5e4d642d358045c0a20a321b9b8975607a831", "filename": "gcc/fortran/intrinsic.texi", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7306494a7e4a2dfd05dc3c2a51ac8f29d1fad207/gcc%2Ffortran%2Fintrinsic.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7306494a7e4a2dfd05dc3c2a51ac8f29d1fad207/gcc%2Ffortran%2Fintrinsic.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.texi?ref=7306494a7e4a2dfd05dc3c2a51ac8f29d1fad207", "patch": "@@ -1005,16 +1005,29 @@ Function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n+<<<<<<< .mine\n+@item @var{I} @tab The type shall be either a scalar @code{INTEGER(*)}\n+type or a scalar @code{LOGICAL} type.\n+@item @var{J} @tab The type shall be the same as the type of @var{I}.\n+=======\n @item @var{I} @tab The type shall be either a scalar @code{INTEGER}\n type or a scalar @code{LOGICAL} type.\n @item @var{J} @tab The type shall be the same as the type of @var{I}.\n+>>>>>>> .r136053\n @end multitable\n \n @item @emph{Return value}:\n+<<<<<<< .mine\n+The return type is either a scalar @code{INTEGER(*)} or a scalar\n+@code{LOGICAL}.  If the kind type parameters differ, then the\n+smaller kind type is implicitly converted to larger kind, and the \n+return has the larger kind.\n+=======\n The return type is either a scalar @code{INTEGER} or a scalar\n @code{LOGICAL}.  If the kind type parameters differ, then the\n smaller kind type is implicitly converted to larger kind, and the \n return has the larger kind.\n+>>>>>>> .r136053\n \n @item @emph{Example}:\n @smallexample\n@@ -8310,16 +8323,29 @@ Function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n+<<<<<<< .mine\n+@item @var{X} @tab The type shall be either a scalar @code{INTEGER(*)}\n+type or a scalar @code{LOGICAL} type.\n+@item @var{Y} @tab The type shall be the same as the type of @var{X}.\n+=======\n @item @var{X} @tab The type shall be either a scalar @code{INTEGER}\n type or a scalar @code{LOGICAL} type.\n @item @var{Y} @tab The type shall be the same as the type of @var{X}.\n+>>>>>>> .r136053\n @end multitable\n \n @item @emph{Return value}:\n+<<<<<<< .mine\n+The return type is either a scalar @code{INTEGER(*)} or a scalar\n+@code{LOGICAL}.  If the kind type parameters differ, then the\n+smaller kind type is implicitly converted to larger kind, and the \n+return has the larger kind.\n+=======\n The return type is either a scalar @code{INTEGER} or a scalar\n @code{LOGICAL}.  If the kind type parameters differ, then the\n smaller kind type is implicitly converted to larger kind, and the \n return has the larger kind.\n+>>>>>>> .r136053\n \n @item @emph{Example}:\n @smallexample\n@@ -11055,16 +11081,29 @@ Function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n+<<<<<<< .mine\n+@item @var{X} @tab The type shall be either  a scalar @code{INTEGER(*)}\n+type or a scalar @code{LOGICAL} type.\n+@item @var{Y} @tab The type shall be the same as the type of @var{I}.\n+=======\n @item @var{X} @tab The type shall be either  a scalar @code{INTEGER}\n type or a scalar @code{LOGICAL} type.\n @item @var{Y} @tab The type shall be the same as the type of @var{I}.\n+>>>>>>> .r136053\n @end multitable\n \n @item @emph{Return value}:\n+<<<<<<< .mine\n+The return type is either a scalar @code{INTEGER(*)} or a scalar\n+@code{LOGICAL}.  If the kind type parameters differ, then the\n+smaller kind type is implicitly converted to larger kind, and the \n+return has the larger kind.\n+=======\n The return type is either a scalar @code{INTEGER} or a scalar\n @code{LOGICAL}.  If the kind type parameters differ, then the\n smaller kind type is implicitly converted to larger kind, and the \n return has the larger kind.\n+>>>>>>> .r136053\n \n @item @emph{Example}:\n @smallexample"}, {"sha": "058a9f293a18726697978681ddcf463af6c240f5", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 36, "deletions": 88, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7306494a7e4a2dfd05dc3c2a51ac8f29d1fad207/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7306494a7e4a2dfd05dc3c2a51ac8f29d1fad207/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=7306494a7e4a2dfd05dc3c2a51ac8f29d1fad207", "patch": "@@ -543,7 +543,6 @@ gfc_simplify_and (gfc_expr *x, gfc_expr *y)\n       result->value.logical = x->value.logical && y->value.logical;\n       return result;\n     }\n-\n }\n \n \n@@ -651,16 +650,15 @@ gfc_simplify_atan2 (gfc_expr *y, gfc_expr *x)\n   if (x->expr_type != EXPR_CONSTANT || y->expr_type != EXPR_CONSTANT)\n     return NULL;\n \n-  result = gfc_constant_result (x->ts.type, x->ts.kind, &x->where);\n-\n   if (mpfr_sgn (y->value.real) == 0 && mpfr_sgn (x->value.real) == 0)\n     {\n       gfc_error (\"If first argument of ATAN2 %L is zero, then the \"\n \t\t \"second argument must not be zero\", &x->where);\n-      gfc_free_expr (result);\n       return &gfc_bad_expr;\n     }\n \n+  result = gfc_constant_result (x->ts.type, x->ts.kind, &x->where);\n+\n   mpfr_atan2 (result->value.real, y->value.real, x->value.real, GFC_RND_MODE);\n \n   return range_check (result, \"ATAN2\");\n@@ -677,7 +675,6 @@ gfc_simplify_bessel_j0 (gfc_expr *x ATTRIBUTE_UNUSED)\n     return NULL;\n \n   result = gfc_constant_result (x->ts.type, x->ts.kind, &x->where);\n-  gfc_set_model_kind (x->ts.kind);\n   mpfr_j0 (result->value.real, x->value.real, GFC_RND_MODE);\n \n   return range_check (result, \"BESSEL_J0\");\n@@ -697,7 +694,6 @@ gfc_simplify_bessel_j1 (gfc_expr *x ATTRIBUTE_UNUSED)\n     return NULL;\n \n   result = gfc_constant_result (x->ts.type, x->ts.kind, &x->where);\n-  gfc_set_model_kind (x->ts.kind);\n   mpfr_j1 (result->value.real, x->value.real, GFC_RND_MODE);\n \n   return range_check (result, \"BESSEL_J1\");\n@@ -720,7 +716,6 @@ gfc_simplify_bessel_jn (gfc_expr *order ATTRIBUTE_UNUSED,\n \n   n = mpz_get_si (order->value.integer);\n   result = gfc_constant_result (x->ts.type, x->ts.kind, &x->where);\n-  gfc_set_model_kind (x->ts.kind);\n   mpfr_jn (result->value.real, n, x->value.real, GFC_RND_MODE);\n \n   return range_check (result, \"BESSEL_JN\");\n@@ -740,7 +735,6 @@ gfc_simplify_bessel_y0 (gfc_expr *x ATTRIBUTE_UNUSED)\n     return NULL;\n \n   result = gfc_constant_result (x->ts.type, x->ts.kind, &x->where);\n-  gfc_set_model_kind (x->ts.kind);\n   mpfr_y0 (result->value.real, x->value.real, GFC_RND_MODE);\n \n   return range_check (result, \"BESSEL_Y0\");\n@@ -760,7 +754,6 @@ gfc_simplify_bessel_y1 (gfc_expr *x ATTRIBUTE_UNUSED)\n     return NULL;\n \n   result = gfc_constant_result (x->ts.type, x->ts.kind, &x->where);\n-  gfc_set_model_kind (x->ts.kind);\n   mpfr_y1 (result->value.real, x->value.real, GFC_RND_MODE);\n \n   return range_check (result, \"BESSEL_Y1\");\n@@ -783,7 +776,6 @@ gfc_simplify_bessel_yn (gfc_expr *order ATTRIBUTE_UNUSED,\n \n   n = mpz_get_si (order->value.integer);\n   result = gfc_constant_result (x->ts.type, x->ts.kind, &x->where);\n-  gfc_set_model_kind (x->ts.kind);\n   mpfr_yn (result->value.real, n, x->value.real, GFC_RND_MODE);\n \n   return range_check (result, \"BESSEL_YN\");\n@@ -937,25 +929,16 @@ simplify_cmplx (const char *name, gfc_expr *x, gfc_expr *y, int kind)\n static gfc_expr *\n only_convert_cmplx_boz (gfc_expr *x, gfc_expr *y, int kind)\n {\n-  if (x->is_boz)\n-    {\n-      gfc_typespec ts;\n-      gfc_clear_ts (&ts);\n-      ts.type = BT_REAL;\n-      ts.kind = kind;\n-      if (!gfc_convert_boz (x, &ts))\n-\treturn &gfc_bad_expr;\n-    }\n+  gfc_typespec ts;\n+  gfc_clear_ts (&ts);\n+  ts.type = BT_REAL;\n+  ts.kind = kind;\n \n-  if (y && y->is_boz)\n-    {\n-      gfc_typespec ts;\n-      gfc_clear_ts (&ts);\n-      ts.type = BT_REAL;\n-      ts.kind = kind;\n-      if (!gfc_convert_boz (y, &ts))\n-\treturn &gfc_bad_expr;\n-    }\n+  if (x->is_boz && !gfc_convert_boz (x, &ts))\n+    return &gfc_bad_expr;\n+\n+  if (y && y->is_boz && !gfc_convert_boz (y, &ts))\n+    return &gfc_bad_expr;\n \n   return NULL;\n }\n@@ -1051,8 +1034,7 @@ gfc_simplify_cos (gfc_expr *x)\n       mpfr_mul (xp, xp, xq, GFC_RND_MODE);\n       mpfr_neg (result->value.complex.i, xp, GFC_RND_MODE );\n \n-      mpfr_clear (xp);\n-      mpfr_clear (xq);\n+      mpfr_clears (xp, xq, NULL);\n       break;\n     default:\n       gfc_internal_error (\"in gfc_simplify_cos(): Bad type\");\n@@ -1296,8 +1278,7 @@ gfc_simplify_exp (gfc_expr *x)\n       mpfr_mul (result->value.complex.r, xq, xp, GFC_RND_MODE);\n       mpfr_sin (xp, x->value.complex.i, GFC_RND_MODE);\n       mpfr_mul (result->value.complex.i, xq, xp, GFC_RND_MODE);\n-      mpfr_clear (xp);\n-      mpfr_clear (xq);\n+      mpfr_clears (xp, xq, NULL);\n       break;\n \n     default:\n@@ -1402,14 +1383,13 @@ gfc_simplify_fraction (gfc_expr *x)\n \n   result = gfc_constant_result (BT_REAL, x->ts.kind, &x->where);\n \n-  gfc_set_model_kind (x->ts.kind);\n-\n   if (mpfr_sgn (x->value.real) == 0)\n     {\n       mpfr_set_ui (result->value.real, 0, GFC_RND_MODE);\n       return result;\n     }\n \n+  gfc_set_model_kind (x->ts.kind);\n   mpfr_init (exp);\n   mpfr_init (absv);\n   mpfr_init (pow2);\n@@ -1424,9 +1404,7 @@ gfc_simplify_fraction (gfc_expr *x)\n \n   mpfr_div (result->value.real, absv, pow2, GFC_RND_MODE);\n \n-  mpfr_clear (exp);\n-  mpfr_clear (absv);\n-  mpfr_clear (pow2);\n+  mpfr_clears (exp, absv, pow2, NULL);\n \n   return range_check (result, \"FRACTION\");\n }\n@@ -1442,8 +1420,6 @@ gfc_simplify_gamma (gfc_expr *x)\n \n   result = gfc_constant_result (x->ts.type, x->ts.kind, &x->where);\n \n-  gfc_set_model_kind (x->ts.kind);\n-\n   mpfr_gamma (result->value.real, x->value.real, GFC_RND_MODE);\n \n   return range_check (result, \"GAMMA\");\n@@ -2491,8 +2467,6 @@ gfc_simplify_lgamma (gfc_expr *x ATTRIBUTE_UNUSED)\n \n   result = gfc_constant_result (x->ts.type, x->ts.kind, &x->where);\n \n-  gfc_set_model_kind (x->ts.kind);\n-\n   mpfr_lgamma (result->value.real, &sg, x->value.real, GFC_RND_MODE);\n \n   return range_check (result, \"LGAMMA\");\n@@ -2554,7 +2528,6 @@ gfc_simplify_log (gfc_expr *x)\n \n   result = gfc_constant_result (x->ts.type, x->ts.kind, &x->where);\n \n-  gfc_set_model_kind (x->ts.kind);\n \n   switch (x->ts.type)\n     {\n@@ -2580,6 +2553,7 @@ gfc_simplify_log (gfc_expr *x)\n \t  return &gfc_bad_expr;\n \t}\n \n+      gfc_set_model_kind (x->ts.kind);\n       mpfr_init (xr);\n       mpfr_init (xi);\n \n@@ -2592,8 +2566,7 @@ gfc_simplify_log (gfc_expr *x)\n       mpfr_sqrt (xr, xr, GFC_RND_MODE);\n       mpfr_log (result->value.complex.r, xr, GFC_RND_MODE);\n \n-      mpfr_clear (xr);\n-      mpfr_clear (xi);\n+      mpfr_clears (xr, xi, NULL);\n \n       break;\n \n@@ -2613,8 +2586,6 @@ gfc_simplify_log10 (gfc_expr *x)\n   if (x->expr_type != EXPR_CONSTANT)\n     return NULL;\n \n-  gfc_set_model_kind (x->ts.kind);\n-\n   if (mpfr_sgn (x->value.real) <= 0)\n     {\n       gfc_error (\"Argument of LOG10 at %L cannot be less than or equal \"\n@@ -2812,7 +2783,7 @@ gfc_expr *\n gfc_simplify_mod (gfc_expr *a, gfc_expr *p)\n {\n   gfc_expr *result;\n-  mpfr_t quot, iquot, term;\n+  mpfr_t tmp;\n   int kind;\n \n   if (a->expr_type != EXPR_CONSTANT || p->expr_type != EXPR_CONSTANT)\n@@ -2844,18 +2815,12 @@ gfc_simplify_mod (gfc_expr *a, gfc_expr *p)\n \t}\n \n       gfc_set_model_kind (kind);\n-      mpfr_init (quot);\n-      mpfr_init (iquot);\n-      mpfr_init (term);\n-\n-      mpfr_div (quot, a->value.real, p->value.real, GFC_RND_MODE);\n-      mpfr_trunc (iquot, quot);\n-      mpfr_mul (term, iquot, p->value.real, GFC_RND_MODE);\n-      mpfr_sub (result->value.real, a->value.real, term, GFC_RND_MODE);\n-\n-      mpfr_clear (quot);\n-      mpfr_clear (iquot);\n-      mpfr_clear (term);\n+      mpfr_init (tmp);\n+      mpfr_div (tmp, a->value.real, p->value.real, GFC_RND_MODE);\n+      mpfr_trunc (tmp, tmp);\n+      mpfr_mul (tmp, tmp, p->value.real, GFC_RND_MODE);\n+      mpfr_sub (result->value.real, a->value.real, tmp, GFC_RND_MODE);\n+      mpfr_clear (tmp);\n       break;\n \n     default:\n@@ -2870,7 +2835,7 @@ gfc_expr *\n gfc_simplify_modulo (gfc_expr *a, gfc_expr *p)\n {\n   gfc_expr *result;\n-  mpfr_t quot, iquot, term;\n+  mpfr_t tmp;\n   int kind;\n \n   if (a->expr_type != EXPR_CONSTANT || p->expr_type != EXPR_CONSTANT)\n@@ -2904,18 +2869,12 @@ gfc_simplify_modulo (gfc_expr *a, gfc_expr *p)\n \t}\n \n       gfc_set_model_kind (kind);\n-      mpfr_init (quot);\n-      mpfr_init (iquot);\n-      mpfr_init (term);\n-\n-      mpfr_div (quot, a->value.real, p->value.real, GFC_RND_MODE);\n-      mpfr_floor (iquot, quot);\n-      mpfr_mul (term, iquot, p->value.real, GFC_RND_MODE);\n-      mpfr_sub (result->value.real, a->value.real, term, GFC_RND_MODE);\n-\n-      mpfr_clear (quot);\n-      mpfr_clear (iquot);\n-      mpfr_clear (term);\n+      mpfr_init (tmp);\n+      mpfr_div (tmp, a->value.real, p->value.real, GFC_RND_MODE);\n+      mpfr_floor (tmp, tmp);\n+      mpfr_mul (tmp, tmp, p->value.real, GFC_RND_MODE);\n+      mpfr_sub (result->value.real, a->value.real, tmp, GFC_RND_MODE);\n+      mpfr_clear (tmp);\n       break;\n \n     default:\n@@ -2955,7 +2914,6 @@ gfc_simplify_nearest (gfc_expr *x, gfc_expr *s)\n       return &gfc_bad_expr;\n     }\n \n-  gfc_set_model_kind (x->ts.kind);\n   result = gfc_copy_expr (x);\n \n   /* Save current values of emin and emax.  */\n@@ -3715,8 +3673,7 @@ gfc_simplify_scale (gfc_expr *x, gfc_expr *i)\n   else\n     mpfr_mul (result->value.real, x->value.real, scale, GFC_RND_MODE);\n \n-  mpfr_clear (scale);\n-  mpfr_clear (radix);\n+  mpfr_clears (scale, radix, NULL);\n \n   return range_check (result, \"SCALE\");\n }\n@@ -3944,14 +3901,13 @@ gfc_simplify_set_exponent (gfc_expr *x, gfc_expr *i)\n \n   result = gfc_constant_result (BT_REAL, x->ts.kind, &x->where);\n \n-  gfc_set_model_kind (x->ts.kind);\n-\n   if (mpfr_sgn (x->value.real) == 0)\n     {\n       mpfr_set_ui (result->value.real, 0, GFC_RND_MODE);\n       return result;\n     }\n \n+  gfc_set_model_kind (x->ts.kind);\n   mpfr_init (absv);\n   mpfr_init (log2);\n   mpfr_init (exp);\n@@ -3973,10 +3929,7 @@ gfc_simplify_set_exponent (gfc_expr *x, gfc_expr *i)\n   exp2 = (unsigned long) mpz_get_d (i->value.integer);\n   mpfr_mul_2exp (result->value.real, frac, exp2, GFC_RND_MODE);\n \n-  mpfr_clear (absv);\n-  mpfr_clear (log2);\n-  mpfr_clear (pow2);\n-  mpfr_clear (frac);\n+  mpfr_clears (absv, log2, pow2, frac, NULL);\n \n   return range_check (result, \"SET_EXPONENT\");\n }\n@@ -4137,8 +4090,7 @@ gfc_simplify_sin (gfc_expr *x)\n       mpfr_sinh (xq, x->value.complex.i, GFC_RND_MODE);\n       mpfr_mul (result->value.complex.i, xp, xq, GFC_RND_MODE);\n \n-      mpfr_clear (xp);\n-      mpfr_clear (xq);\n+      mpfr_clears (xp, xq, NULL);\n       break;\n \n     default:\n@@ -4314,11 +4266,7 @@ gfc_simplify_sqrt (gfc_expr *e)\n \tgfc_internal_error (\"invalid complex argument of SQRT at %L\",\n \t\t\t    &e->where);\n \n-      mpfr_clear (s);\n-      mpfr_clear (t);\n-      mpfr_clear (ac);\n-      mpfr_clear (ad);\n-      mpfr_clear (w);\n+      mpfr_clears (s, t, ac, ad, w, NULL);\n \n       break;\n "}]}