{"sha": "41272e2a5dadf20e3477b4b4451bce1fb4240d31", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDEyNzJlMmE1ZGFkZjIwZTM0NzdiNGI0NDUxYmNlMWZiNDI0MGQzMQ==", "commit": {"author": {"name": "Andreas Krebbel", "email": "Andreas.Krebbel@de.ibm.com", "date": "2011-11-16T09:27:56Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2011-11-16T09:27:56Z"}, "message": "re PR middle-end/50325 (76 new fails with rev. 177691)\n\n2011-11-16  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n\n\tPR middle-end/50325\n\t* expmed.c (store_bit_field_1): Use extract_bit_field on big\n\tendian targets if the source cannot be exactly covered by word\n\tmode chunks.\n\nFrom-SVN: r181405", "tree": {"sha": "02abdf440dc27128eba4ca2ee3aa9f9221b990a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/02abdf440dc27128eba4ca2ee3aa9f9221b990a8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/41272e2a5dadf20e3477b4b4451bce1fb4240d31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41272e2a5dadf20e3477b4b4451bce1fb4240d31", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41272e2a5dadf20e3477b4b4451bce1fb4240d31", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41272e2a5dadf20e3477b4b4451bce1fb4240d31/comments", "author": null, "committer": null, "parents": [{"sha": "f2a176dcf5386f2d7d3aaaba966bd4dd7acda1b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2a176dcf5386f2d7d3aaaba966bd4dd7acda1b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2a176dcf5386f2d7d3aaaba966bd4dd7acda1b4"}], "stats": {"total": 25, "additions": 21, "deletions": 4}, "files": [{"sha": "ce6df44a2f3f11124c5e7c188734dd28d12b4006", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41272e2a5dadf20e3477b4b4451bce1fb4240d31/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41272e2a5dadf20e3477b4b4451bce1fb4240d31/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=41272e2a5dadf20e3477b4b4451bce1fb4240d31", "patch": "@@ -1,3 +1,10 @@\n+2011-11-16  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n+\n+\tPR middle-end/50325\n+\t* expmed.c (store_bit_field_1): Use extract_bit_field on big\n+\tendian targets if the source cannot be exactly covered by word\n+\tmode chunks.\n+\n 2011-11-15  Joseph Myers  <joseph@codesourcery.com>\n \n \t* config/i386/i386elf.h (ASM_OUTPUT_ASCII): Change STRING_LIMIT to"}, {"sha": "6a9da64e37cd3aa37b69be74c15f0bd63ee6d9f7", "filename": "gcc/expmed.c", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41272e2a5dadf20e3477b4b4451bce1fb4240d31/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41272e2a5dadf20e3477b4b4451bce1fb4240d31/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=41272e2a5dadf20e3477b4b4451bce1fb4240d31", "patch": "@@ -543,7 +543,8 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t is not allowed.  */\n       fieldmode = GET_MODE (value);\n       if (fieldmode == VOIDmode)\n-\tfieldmode = smallest_mode_for_size (nwords * BITS_PER_WORD, MODE_INT);\n+\tfieldmode = smallest_mode_for_size (nwords *\n+\t\t\t\t\t    BITS_PER_WORD, MODE_INT);\n \n       last = get_last_insn ();\n       for (i = 0; i < nwords; i++)\n@@ -557,9 +558,18 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t\t\t\t\t    0)\n \t\t\t\t     : (int) i * BITS_PER_WORD);\n \t  rtx value_word = operand_subword_force (value, wordnum, fieldmode);\n-\n-\t  if (!store_bit_field_1 (op0, MIN (BITS_PER_WORD,\n-\t\t\t\t\t    bitsize - i * BITS_PER_WORD),\n+\t  unsigned HOST_WIDE_INT new_bitsize =\n+\t    MIN (BITS_PER_WORD, bitsize - i * BITS_PER_WORD);\n+\n+\t  /* If the remaining chunk doesn't have full wordsize we have\n+\t     to make sure that for big endian machines the higher order\n+\t     bits are used.  */\n+\t  if (new_bitsize < BITS_PER_WORD && BYTES_BIG_ENDIAN)\n+\t    value_word = extract_bit_field (value_word, new_bitsize, 0,\n+\t\t\t\t\t    true, false, NULL_RTX,\n+\t\t\t\t\t    BLKmode, word_mode);\n+\n+\t  if (!store_bit_field_1 (op0, new_bitsize,\n \t\t\t\t  bitnum + bit_offset,\n \t\t\t\t  bitregion_start, bitregion_end,\n \t\t\t\t  word_mode,"}]}