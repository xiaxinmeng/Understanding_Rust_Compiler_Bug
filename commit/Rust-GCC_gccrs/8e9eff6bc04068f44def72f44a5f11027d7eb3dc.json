{"sha": "8e9eff6bc04068f44def72f44a5f11027d7eb3dc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGU5ZWZmNmJjMDQwNjhmNDRkZWY3MmY0NGE1ZjExMDI3ZDdlYjNkYw==", "commit": {"author": {"name": "Geoffrey Keating", "email": "geoffk@redhat.com", "date": "2001-05-04T06:28:54Z"}, "committer": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "2001-05-04T06:28:54Z"}, "message": "cp-tree.h (enum cp_tree_index): Add CPTI_PFN_VFLAG_IDENTIFIER.\n\n\t* cp-tree.h (enum cp_tree_index): Add CPTI_PFN_VFLAG_IDENTIFIER.\n\t(pfn_vflag_identifier): Define.\n\tUpdate comment about layout of pointer functions.\n\t(build_ptrmemfunc1): Update prototype.\n\t(expand_ptrmemfunc_cst): Update prototype.\n\t* decl.c (initialize_predefined_identifiers): Initialize\n\tpfn_vflag_identifier.\n\t(build_ptrmemfunc_type): When FUNCTION_BOUNDARY < 16, add\n\tan extra field to the type.\n\t* expr.c (cplus_expand_constant): Pass 'flag' between\n\texpand_ptrmemfunc_cst and build_ptrmemfunc1.\n\t* typeck.c (get_member_function_from_ptrfunc): When\n\tFUNCTION_BOUNDARY < 16, look at additional field to determine\n\tif a pointer-to-member is a real pointer or a vtable offset.\n\t(build_ptrmemfunc1): Add new parameter to contain extra field.\n\t(build_ptrmemfunc): Pass the extra field around.\n\t(expand_ptrmemfunc_cst): Add new parameter to return extra field.\n\t(pfn_from_ptrmemfunc): Ignore the extra field.\n\nFrom-SVN: r41824", "tree": {"sha": "d868f5fe0152e84a5178c7af2fe9301e56e71e30", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d868f5fe0152e84a5178c7af2fe9301e56e71e30"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8e9eff6bc04068f44def72f44a5f11027d7eb3dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e9eff6bc04068f44def72f44a5f11027d7eb3dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e9eff6bc04068f44def72f44a5f11027d7eb3dc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e9eff6bc04068f44def72f44a5f11027d7eb3dc/comments", "author": null, "committer": null, "parents": [{"sha": "02d208ff0f057f9b15414f15fd2ece8eef5f49e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02d208ff0f057f9b15414f15fd2ece8eef5f49e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02d208ff0f057f9b15414f15fd2ece8eef5f49e5"}], "stats": {"total": 163, "additions": 106, "deletions": 57}, "files": [{"sha": "9030ae68f1d49dfb4ffd136a02812fe11f4d1dbc", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e9eff6bc04068f44def72f44a5f11027d7eb3dc/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e9eff6bc04068f44def72f44a5f11027d7eb3dc/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=8e9eff6bc04068f44def72f44a5f11027d7eb3dc", "patch": "@@ -1,3 +1,24 @@\n+2001-05-03  Geoffrey Keating  <geoffk@redhat.com>\n+\n+\t* cp-tree.h (enum cp_tree_index): Add CPTI_PFN_VFLAG_IDENTIFIER.\n+\t(pfn_vflag_identifier): Define.\n+\tUpdate comment about layout of pointer functions.\n+\t(build_ptrmemfunc1): Update prototype.\n+\t(expand_ptrmemfunc_cst): Update prototype.\n+\t* decl.c (initialize_predefined_identifiers): Initialize\n+\tpfn_vflag_identifier.\n+\t(build_ptrmemfunc_type): When FUNCTION_BOUNDARY < 16, add\n+\tan extra field to the type.\n+\t* expr.c (cplus_expand_constant): Pass 'flag' between \n+\texpand_ptrmemfunc_cst and build_ptrmemfunc1.\n+\t* typeck.c (get_member_function_from_ptrfunc): When\n+\tFUNCTION_BOUNDARY < 16, look at additional field to determine\n+\tif a pointer-to-member is a real pointer or a vtable offset.\n+\t(build_ptrmemfunc1): Add new parameter to contain extra field.\n+\t(build_ptrmemfunc): Pass the extra field around.\n+\t(expand_ptrmemfunc_cst): Add new parameter to return extra field.\n+\t(pfn_from_ptrmemfunc): Ignore the extra field.\n+\n 2001-05-03  Mark Mitchell  <mark@codesourcery.com>\n \n \t* cp-tree.h (flag_inline_trees): Update documentation."}, {"sha": "e1b93616aa8c366739674ee79b8d45ecd66eee1e", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 24, "deletions": 40, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e9eff6bc04068f44def72f44a5f11027d7eb3dc/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e9eff6bc04068f44def72f44a5f11027d7eb3dc/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=8e9eff6bc04068f44def72f44a5f11027d7eb3dc", "patch": "@@ -611,6 +611,7 @@ enum cp_tree_index\n     CPTI_NELTS_IDENTIFIER,\n     CPTI_THIS_IDENTIFIER,\n     CPTI_PFN_IDENTIFIER,\n+    CPTI_PFN_VFLAG_IDENTIFIER,\n     CPTI_PFN_OR_DELTA2_IDENTIFIER,\n     CPTI_VPTR_IDENTIFIER,\n     CPTI_STD_IDENTIFIER,\n@@ -735,6 +736,7 @@ extern tree cp_global_trees[CPTI_MAX];\n #define nelts_identifier                cp_global_trees[CPTI_NELTS_IDENTIFIER]\n #define this_identifier                 cp_global_trees[CPTI_THIS_IDENTIFIER]\n #define pfn_identifier                  cp_global_trees[CPTI_PFN_IDENTIFIER]\n+#define pfn_vflag_identifier            cp_global_trees[CPTI_PFN_VFLAG_IDENTIFIER]\n #define pfn_or_delta2_identifier        cp_global_trees[CPTI_PFN_OR_DELTA2_IDENTIFIER]\n #define vptr_identifier                 cp_global_trees[CPTI_VPTR_IDENTIFIER]\n /* The name of the std namespace.  */\n@@ -2618,29 +2620,27 @@ extern int flag_new_for_scope;\n /* A pointer-to-function member type looks like:\n \n    struct {\n-     short __delta;\n-     short __index;\n-     union {\n-       P __pfn;\n-       short __delta2;\n-     } __pfn_or_delta2;\n+     __P __pfn;\n+     ptrdiff_t __delta;\n    };\n \n-   where P is a POINTER_TYPE to a METHOD_TYPE appropriate for the\n-   pointer to member.  The fields are used as follows:\n+   where P is either a POINTER_TYPE to a METHOD_TYPE appropriate for\n+   the pointer to member, or one plus twice the index into the vtable;\n+   the two cases are distinguished by looking at the least significant\n+   bit of P.  When FUNCTION_BOUNDARY is less than 16 (and so it might\n+   happen that the function pointer might naturally have the low bit\n+   set), the type is instead\n \n-     If __INDEX is -1, then the function to call is non-virtual, and\n-     is located at the address given by __PFN.\n-\n-     If __INDEX is zero, then this a NULL pointer-to-member.\n+   struct {\n+     __P __pfn;\n+     ptrdiff_t __delta;\n+     char __vflag;\n+   };\n \n-     Otherwise, the function to call is virtual.  Then, __DELTA2 gives\n-     the offset from an instance of the object to the virtual function\n-     table, and __INDEX - 1 is the index into the vtable to use to\n-     find the function.\n+   and __pfn is a pointer to a method when __vflag is zero.\n \n-     The value to use for the THIS parameter is the address of the\n-     object plus __DELTA.\n+   In all cases, the value to use for the THIS parameter is the\n+   address of the object plus __DELTA / 2 .\n \n    For example, given:\n \n@@ -2657,27 +2657,9 @@ extern int flag_new_for_scope;\n \n    the pointer-to-member for `&S::f' looks like:\n \n-     { 4, -1, { &f__2B2 } };\n-\n-   The `4' means that given an `S*' you have to add 4 bytes to get to\n-   the address of the `B2*'.  Then, the -1 indicates that this is a\n-   non-virtual function.  Of course, `&f__2B2' is the name of that\n-   function.\n-\n-   (Of course, the exact values may differ depending on the mangling\n-   scheme, sizes of types, and such.).\n-\n-   Under the new ABI, we do:\n-\n-     struct {\n-       __P __pfn;\n-       ptrdiff_t __delta;\n-     };\n+     { &f__2B2, 4, 0 };\n \n-   (We don't need DELTA2, because the vtable is always the first thing\n-   in the object.)  If the function is virtual, then PFN is one plus\n-   twice the index into the vtable; otherwise, it is just a pointer to\n-   the function.  */\n+*/\n \n /* Get the POINTER_TYPE to the METHOD_TYPE associated with this\n    pointer to member function.  TYPE_PTRMEMFUNC_P _must_ be true,\n@@ -4469,8 +4451,10 @@ extern int cp_type_quals                        PARAMS ((tree));\n extern int cp_has_mutable_p                     PARAMS ((tree));\n extern int at_least_as_qualified_p              PARAMS ((tree, tree));\n extern int more_qualified_p                     PARAMS ((tree, tree));\n-extern tree build_ptrmemfunc1                   PARAMS ((tree, tree, tree));\n-extern void expand_ptrmemfunc_cst               PARAMS ((tree, tree *, tree *));\n+extern tree build_ptrmemfunc1                   PARAMS ((tree, tree, tree, \n+\t\t\t\t\t\t\t tree));\n+extern void expand_ptrmemfunc_cst               PARAMS ((tree, tree *, \n+\t\t\t\t\t\t\t tree *, tree *));\n extern tree pfn_from_ptrmemfunc                 PARAMS ((tree));\n extern tree type_after_usual_arithmetic_conversions PARAMS ((tree, tree));\n extern tree composite_pointer_type              PARAMS ((tree, tree, tree, tree,"}, {"sha": "b04206d0f683f7fbf752746a7c567d22f1ba624e", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e9eff6bc04068f44def72f44a5f11027d7eb3dc/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e9eff6bc04068f44def72f44a5f11027d7eb3dc/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=8e9eff6bc04068f44def72f44a5f11027d7eb3dc", "patch": "@@ -6303,6 +6303,7 @@ initialize_predefined_identifiers ()\n     { \"nelts\", &nelts_identifier, 0 },\n     { THIS_NAME, &this_identifier, 0 },\n     { VTABLE_PFN_NAME, &pfn_identifier, 0 },\n+    { \"__vflag\", &pfn_vflag_identifier, 0 },\n     { \"__pfn_or_delta2\", &pfn_or_delta2_identifier, 0 },\n     { \"_vptr\", &vptr_identifier, 0 },\n     { \"__vtt_parm\", &vtt_parm_identifier, 0 },\n@@ -9156,7 +9157,14 @@ build_ptrmemfunc_type (type)\n   fields[0] = build_decl (FIELD_DECL, pfn_identifier, type);\n   fields[1] = build_decl (FIELD_DECL, delta_identifier,\n \t\t\t  delta_type_node);\n-  finish_builtin_type (t, \"__ptrmemfunc_type\", fields, 1, ptr_type_node);\n+  if (FUNCTION_BOUNDARY < 16)\n+    {\n+      fields[2] = build_decl (FIELD_DECL, pfn_vflag_identifier,\n+\t\t\t      char_type_node);\n+      finish_builtin_type (t, \"__ptrmemfunc_type\", fields, 2, ptr_type_node);\n+    } else {\n+      finish_builtin_type (t, \"__ptrmemfunc_type\", fields, 1, ptr_type_node);\n+    }\n \n   /* Zap out the name so that the back-end will give us the debugging\n      information for this anonymous RECORD_TYPE.  */"}, {"sha": "7163a5b6669f9724ea2802d9f717f87261c64e62", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e9eff6bc04068f44def72f44a5f11027d7eb3dc/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e9eff6bc04068f44def72f44a5f11027d7eb3dc/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=8e9eff6bc04068f44def72f44a5f11027d7eb3dc", "patch": "@@ -62,9 +62,10 @@ cplus_expand_constant (cst)\n \t  {\n \t    tree delta;\n \t    tree pfn;\n+\t    tree flag;\n \n-\t    expand_ptrmemfunc_cst (cst, &delta, &pfn);\n-\t    cst = build_ptrmemfunc1 (type, delta, pfn);\n+\t    expand_ptrmemfunc_cst (cst, &delta, &pfn, &flag);\n+\t    cst = build_ptrmemfunc1 (type, delta, pfn, flag);\n \t  }\n       }\n       break;"}, {"sha": "6d010d85726d6b7dc63c380e44b04e4fb3eadb72", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 49, "deletions": 14, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e9eff6bc04068f44def72f44a5f11027d7eb3dc/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e9eff6bc04068f44def72f44a5f11027d7eb3dc/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=8e9eff6bc04068f44def72f44a5f11027d7eb3dc", "patch": "@@ -2909,9 +2909,22 @@ get_member_function_from_ptrfunc (instance_ptrptr, function)\n       idx = cp_build_binary_op (TRUNC_DIV_EXPR, \n \t\t\t\tbuild1 (NOP_EXPR, vtable_index_type, e3),\n \t\t\t\tTYPE_SIZE_UNIT (vtable_entry_type));\n-      e1 = cp_build_binary_op (BIT_AND_EXPR,\n-\t\t\t       build1 (NOP_EXPR, vtable_index_type, e3),\n-\t\t\t       integer_one_node);\n+      if (FUNCTION_BOUNDARY < 16)\n+\t{\n+\t  tree delta;\n+\t  tree pfn;\n+\t  if (TREE_CODE (function) == PTRMEM_CST)\n+\t    expand_ptrmemfunc_cst (function, &delta, &pfn, &e1);\n+\t  else\n+\t    e1 = build_component_ref (function, pfn_vflag_identifier, \n+\t\t\t\t\t NULL_TREE, 0);\n+\t}\n+      else\n+\t{\n+\t  e1 = cp_build_binary_op (BIT_AND_EXPR,\n+\t\t\t\t   build1 (NOP_EXPR, vtable_index_type, e3),\n+\t\t\t\t   integer_one_node);\n+\t}\n \n       vtbl = convert_pointer_to (ptr_type_node, instance);\n       delta = cp_convert (ptrdiff_type_node,\n@@ -5995,23 +6008,34 @@ get_delta_difference (from, to, force)\n    the other components as specified.  */\n \n tree\n-build_ptrmemfunc1 (type, delta, pfn)\n-     tree type, delta, pfn;\n+build_ptrmemfunc1 (type, delta, pfn, flag)\n+     tree type, delta, pfn, flag;\n {\n   tree u = NULL_TREE;\n   tree delta_field;\n   tree pfn_field;\n+  tree vflag_field;\n \n   /* Pull the FIELD_DECLs out of the type.  */\n   pfn_field = TYPE_FIELDS (type);\n   delta_field = TREE_CHAIN (pfn_field);\n+  vflag_field = TREE_CHAIN (delta_field);  /* NULL if no such field.  */\n \n   /* Make sure DELTA has the type we want.  */\n   delta = convert_and_check (delta_type_node, delta);\n \n   /* Finish creating the initializer.  */\n-  u = tree_cons (pfn_field, pfn,\n-\t\t build_tree_list (delta_field, delta));\n+  if (FUNCTION_BOUNDARY < 16)\n+    {\n+      u = tree_cons (pfn_field, pfn,\n+\t\t     tree_cons (delta_field, delta,\n+\t\t\t\tbuild_tree_list (vflag_field, flag)));\n+    }\n+  else\n+    {\n+      u = tree_cons (pfn_field, pfn,\n+\t\t     build_tree_list (delta_field, delta));\n+    }\n   u = build (CONSTRUCTOR, type, NULL_TREE, u);\n   TREE_CONSTANT (u) = TREE_CONSTANT (pfn) && TREE_CONSTANT (delta);\n   TREE_STATIC (u) = (TREE_CONSTANT (u)\n@@ -6047,6 +6071,7 @@ build_ptrmemfunc (type, pfn, force)\n     {\n       tree delta = NULL_TREE;\n       tree npfn = NULL_TREE;\n+      tree flag = NULL_TREE;\n       tree n;\n \n       if (!force \n@@ -6075,18 +6100,21 @@ build_ptrmemfunc (type, pfn, force)\n \n       /* Obtain the function pointer and the current DELTA.  */\n       if (TREE_CODE (pfn) == PTRMEM_CST)\n-\texpand_ptrmemfunc_cst (pfn, &delta, &npfn);\n+\texpand_ptrmemfunc_cst (pfn, &delta, &npfn, &flag);\n       else\n \t{\n \t  npfn = build_component_ref (pfn, pfn_identifier, NULL_TREE, 0);\n \t  delta = build_component_ref (pfn, delta_identifier, NULL_TREE, 0);\n+\t  if (FUNCTION_BOUNDARY < 16)\n+\t    flag = build_component_ref (pfn, pfn_vflag_identifier, \n+\t\t\t\t\tNULL_TREE, 0);\n \t}\n \n       /* Under the new ABI, the conversion is easy.  Just adjust\n \t the DELTA field.  */\n       delta = cp_convert (ptrdiff_type_node, delta);\n       delta = cp_build_binary_op (PLUS_EXPR, delta, n);\n-      return build_ptrmemfunc1 (to_type, delta, npfn);\n+      return build_ptrmemfunc1 (to_type, delta, npfn, flag);\n     }\n \n   /* Handle null pointer to member function conversions.  */\n@@ -6095,7 +6123,8 @@ build_ptrmemfunc (type, pfn, force)\n       pfn = build_c_cast (type, integer_zero_node);\n       return build_ptrmemfunc1 (to_type,\n \t\t\t\tinteger_zero_node, \n-\t\t\t\tpfn);\n+\t\t\t\tpfn,\n+\t\t\t\tinteger_zero_node);\n     }\n \n   if (type_unknown_p (pfn))\n@@ -6106,18 +6135,19 @@ build_ptrmemfunc (type, pfn, force)\n   return make_ptrmem_cst (to_type, fn);\n }\n \n-/* Return the DELTA, IDX, PFN, and DELTA2 values for the PTRMEM_CST\n+/* Return the DELTA, PFN, and FLAG values for the PTRMEM_CST\n    given by CST.\n \n    ??? There is no consistency as to the types returned for the above\n    values.  Some code acts as if its a sizetype and some as if its\n    integer_type_node.  */\n \n void\n-expand_ptrmemfunc_cst (cst, delta, pfn)\n+expand_ptrmemfunc_cst (cst, delta, pfn, flag)\n      tree cst;\n      tree *delta;\n      tree *pfn;\n+     tree *flag;\n {\n   tree type = TREE_TYPE (cst);\n   tree fn = PTRMEM_CST_MEMBER (cst);\n@@ -6135,7 +6165,10 @@ expand_ptrmemfunc_cst (cst, delta, pfn)\n   *delta = get_delta_difference (fn_class, ptr_class, /*force=*/0);\n \n   if (!DECL_VIRTUAL_P (fn))\n-    *pfn = convert (TYPE_PTRMEMFUNC_FN_TYPE (type), build_addr_func (fn));\n+    {\n+      *pfn = convert (TYPE_PTRMEMFUNC_FN_TYPE (type), build_addr_func (fn));\n+      *flag = integer_zero_node;\n+    }\n   else\n     {\n       /* If we're dealing with a virtual function, we have to adjust 'this'\n@@ -6155,6 +6188,7 @@ expand_ptrmemfunc_cst (cst, delta, pfn)\n \t\t\t  integer_one_node));\n       *pfn = fold (build1 (NOP_EXPR, TYPE_PTRMEMFUNC_FN_TYPE (type),\n \t\t\t   *pfn));\n+      *flag = integer_one_node;\n     }\n }\n \n@@ -6169,8 +6203,9 @@ pfn_from_ptrmemfunc (t)\n     {\n       tree delta;\n       tree pfn;\n+      tree flag;\n       \n-      expand_ptrmemfunc_cst (t, &delta, &pfn);\n+      expand_ptrmemfunc_cst (t, &delta, &pfn, &flag);\n       if (pfn)\n \treturn pfn;\n     }"}]}