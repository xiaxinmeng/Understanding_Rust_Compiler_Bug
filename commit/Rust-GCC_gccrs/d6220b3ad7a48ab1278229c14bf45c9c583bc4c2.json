{"sha": "d6220b3ad7a48ab1278229c14bf45c9c583bc4c2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDYyMjBiM2FkN2E0OGFiMTI3ODIyOWMxNGJmNDVjOWM1ODNiYzRjMg==", "commit": {"author": {"name": "Hans Boehm", "email": "Hans_Boehm@hp.com", "date": "2002-03-26T22:44:48Z"}, "committer": {"name": "Hans Boehm", "email": "hboehm@gcc.gnu.org", "date": "2002-03-26T22:44:48Z"}, "message": "* include/dwarf2-signal.h: Temporarily back out last change.\n\nFrom-SVN: r51415", "tree": {"sha": "304f0cb950ebe668e5655b3714f6bbe60a07c217", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/304f0cb950ebe668e5655b3714f6bbe60a07c217"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d6220b3ad7a48ab1278229c14bf45c9c583bc4c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6220b3ad7a48ab1278229c14bf45c9c583bc4c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6220b3ad7a48ab1278229c14bf45c9c583bc4c2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6220b3ad7a48ab1278229c14bf45c9c583bc4c2/comments", "author": null, "committer": null, "parents": [{"sha": "1eefb6c14905428bd54415913c5622efcd748be8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1eefb6c14905428bd54415913c5622efcd748be8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1eefb6c14905428bd54415913c5622efcd748be8"}], "stats": {"total": 36, "additions": 6, "deletions": 30}, "files": [{"sha": "257e1626a728377fade28c76110d5af29322be59", "filename": "libjava/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6220b3ad7a48ab1278229c14bf45c9c583bc4c2/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6220b3ad7a48ab1278229c14bf45c9c583bc4c2/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=d6220b3ad7a48ab1278229c14bf45c9c583bc4c2", "patch": "@@ -1,3 +1,7 @@\n+2002-03-26  Hans Boehm <Hans_Boehm@hp.com>\n+\n+\t* include/dwarf2-signal.h: Temporarily back out last change.\n+\n 2002-03-26  Loren J. Rittle  <ljrittle@acm.org>\n \n \t* include/posix-threads.h: Support <.../pal.h> on FreeBSD/alpha."}, {"sha": "3a662aec2d979bf6138ec6b5340aa8365aa016f8", "filename": "libjava/include/dwarf2-signal.h", "status": "modified", "additions": 2, "deletions": 30, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6220b3ad7a48ab1278229c14bf45c9c583bc4c2/libjava%2Finclude%2Fdwarf2-signal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6220b3ad7a48ab1278229c14bf45c9c583bc4c2/libjava%2Finclude%2Fdwarf2-signal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fdwarf2-signal.h?ref=d6220b3ad7a48ab1278229c14bf45c9c583bc4c2", "patch": "@@ -41,25 +41,7 @@ do\t\t\t\t\t\t\t\t\t\\\n   _sc->sc_pc += 4;\t\t\t\t\t\t\t\\\n }\t\t\t\t\t\t\t\t\t\\\n while (0)\n-\n-#elif defined(__ia64__)\n-\n-#define MAKE_THROW_FRAME(_exception)\t\t\t\t\t\\\n-do\t\t\t\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  /* IA-64 either leaves PC pointing at a faulting instruction or the\t\\\n-   following instruction, depending on the signal.  SEGV always does\t\\\n-   the former, so we adjust the saved PC to point to the following\t\\\n-   instruction; this is what the handler in libgcc expects.  */\t\t\\\n-  /* Note that we are lying to the unwinder here, which expects the\t\\\n-   faulting pc, not pc+1.  But we claim the unwind information can't\t\\\n-   be changed by such a ld or st instruction, so it doesn't matter. */\t\\\n-  struct sigcontext *_sc = (struct sigcontext *)_p;\t\t\t\\\n-  _sc->sc_ip++;\t\t\t\t\t\t\t\t\\\n-}\t\t\t\t\t\t\t\t\t\\\n-while (0)\n #else\n-#error\n #define MAKE_THROW_FRAME(_exception)\t\t\\\n do\t\t\t\t\t\t\\\n {\t\t\t\t\t\t\\\n@@ -68,16 +50,6 @@ do\t\t\t\t\t\t\\\n while (0)\n #endif\n \n-// FIXME: We shouldn't be using libc_sigaction here, since it should\n-// be glibc private.  But using syscall here would mean translating to\n-// the kernel's struct sigaction and argument sequence, which we\n-// shouldn't either.  The right solution is to call sigaction and to\n-// make sure that we can unwind correctly through the pthread signal\n-// wrapper.\n-extern \"C\" int __libc_sigaction (int __sig, \n-\t\t      __const struct sigaction *__restrict __act,\n-                      struct sigaction *__restrict __oact) throw ();\n-\n #define INIT_SEGV\t\t\t\t\t\t\\\n do\t\t\t\t\t\t\t\t\\\n   {\t\t\t\t\t\t\t\t\\\n@@ -86,7 +58,7 @@ do\t\t\t\t\t\t\t\t\\\n     act.sa_sigaction = _Jv_catch_segv;      \t\t\t\\\n     sigemptyset (&act.sa_mask);\t\t\t\t\t\\\n     act.sa_flags = SA_SIGINFO;\t       \t\t\t\t\\\n-    __libc_sigaction (SIGSEGV, &act, NULL);\t\t\\\n+    syscall (SYS_sigaction, SIGSEGV, &act, NULL);\t\t\\\n   }\t\t\t\t\t\t\t\t\\\n while (0)  \n \n@@ -99,7 +71,7 @@ do\t\t\t\t\t\t\t\t\\\n     act.sa_sigaction = _Jv_catch_fpe;\t\t\t\t\\\n     sigemptyset (&act.sa_mask);\t\t\t\t\t\\\n     act.sa_flags = SA_SIGINFO;\t\t       \t\t\t\\\n-    __libc_sigaction (SIGFPE, &act, NULL);\t\t\\\n+    syscall (SYS_sigaction, SIGFPE, &act, NULL);\t\t\\\n   }\t\t\t\t\t\t\t\t\\\n while (0)  \n "}]}