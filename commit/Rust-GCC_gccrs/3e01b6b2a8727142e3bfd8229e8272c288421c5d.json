{"sha": "3e01b6b2a8727142e3bfd8229e8272c288421c5d", "node_id": "C_kwDOANBUbNoAKDNlMDFiNmIyYTg3MjcxNDJlM2JmZDgyMjllODI3MmMyODg0MjFjNWQ", "commit": {"author": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-04-25T19:41:26Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-04-25T20:38:56Z"}, "message": "ast: resolve: Move ResolveItem into its own source file", "tree": {"sha": "ff18a554f4a09b4b210634db262c582efaab843a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff18a554f4a09b4b210634db262c582efaab843a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3e01b6b2a8727142e3bfd8229e8272c288421c5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e01b6b2a8727142e3bfd8229e8272c288421c5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e01b6b2a8727142e3bfd8229e8272c288421c5d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e01b6b2a8727142e3bfd8229e8272c288421c5d/comments", "author": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2b1cb4ba8693e2c148e7aa406b4f03d34ffc0439", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b1cb4ba8693e2c148e7aa406b4f03d34ffc0439", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b1cb4ba8693e2c148e7aa406b4f03d34ffc0439"}], "stats": {"total": 1876, "additions": 983, "deletions": 893}, "files": [{"sha": "5fa93a08ddb5dd499113fc271cec6288328d7b2a", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e01b6b2a8727142e3bfd8229e8272c288421c5d/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e01b6b2a8727142e3bfd8229e8272c288421c5d/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=3e01b6b2a8727142e3bfd8229e8272c288421c5d", "patch": "@@ -87,6 +87,7 @@ GRS_OBJS = \\\n     rust/rust-ast-lower-pattern.o \\\n     rust/rust-name-resolver.o \\\n     rust/rust-ast-resolve.o \\\n+    rust/rust-ast-resolve-item.o \\\n     rust/rust-ast-resolve-pattern.o \\\n     rust/rust-ast-resolve-expr.o \\\n     rust/rust-ast-resolve-type.o \\"}, {"sha": "954669818dec07fec4af092d40de65c1bd630b5c", "filename": "gcc/rust/resolve/rust-ast-resolve-item.cc", "status": "added", "additions": 952, "deletions": 0, "changes": 952, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e01b6b2a8727142e3bfd8229e8272c288421c5d/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e01b6b2a8727142e3bfd8229e8272c288421c5d/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.cc?ref=3e01b6b2a8727142e3bfd8229e8272c288421c5d", "patch": "@@ -0,0 +1,952 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-ast-resolve-item.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+void\n+ResolveTraitItems::go (AST::TraitItem *item, const CanonicalPath &prefix,\n+\t\t       const CanonicalPath &canonical_prefix)\n+{\n+  if (item->is_marked_for_strip ())\n+    return;\n+\n+  ResolveTraitItems resolver (prefix, canonical_prefix);\n+  item->accept_vis (resolver);\n+}\n+\n+void\n+ResolveTraitItems::visit (AST::TraitItemType &type)\n+{\n+  auto decl = ResolveTraitItemTypeToCanonicalPath::resolve (type);\n+  auto path = prefix.append (decl);\n+  auto cpath = canonical_prefix.append (decl);\n+  mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t   type.get_node_id (), cpath);\n+\n+  for (auto &bound : type.get_type_param_bounds ())\n+    ResolveTypeBound::go (bound.get (), type.get_node_id ());\n+}\n+\n+void\n+ResolveTraitItems::visit (AST::TraitItemFunc &func)\n+{\n+  auto decl = ResolveTraitItemFunctionToCanonicalPath::resolve (func);\n+  auto path = prefix.append (decl);\n+  auto cpath = canonical_prefix.append (decl);\n+  mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t   func.get_node_id (), cpath);\n+\n+  NodeId scope_node_id = func.get_node_id ();\n+  resolver->get_name_scope ().push (scope_node_id);\n+  resolver->get_type_scope ().push (scope_node_id);\n+  resolver->get_label_scope ().push (scope_node_id);\n+  resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n+  resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n+  resolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n+\n+  AST::TraitFunctionDecl &function = func.get_trait_function_decl ();\n+  if (function.has_generics ())\n+    {\n+      for (auto &generic : function.get_generic_params ())\n+\tResolveGenericParam::go (generic.get (), func.get_node_id ());\n+    }\n+\n+  if (function.has_return_type ())\n+    ResolveType::go (function.get_return_type ().get (), func.get_node_id ());\n+\n+  // we make a new scope so the names of parameters are resolved and shadowed\n+  // correctly\n+  for (auto &param : function.get_function_params ())\n+    {\n+      ResolveType::go (param.get_type ().get (), param.get_node_id ());\n+      PatternDeclaration::go (param.get_pattern ().get (),\n+\t\t\t      param.get_node_id ());\n+\n+      // the mutability checker needs to verify for immutable decls the number\n+      // of assignments are <1. This marks an implicit assignment\n+      resolver->mark_assignment_to_decl (\n+\tparam.get_pattern ()->get_pattern_node_id (), param.get_node_id ());\n+    }\n+\n+  if (function.has_where_clause ())\n+    ResolveWhereClause::Resolve (function.get_where_clause ());\n+\n+  // trait items have an optional body\n+  if (func.has_definition ())\n+    ResolveExpr::go (func.get_definition ().get (), func.get_node_id (), path,\n+\t\t     cpath);\n+\n+  resolver->get_name_scope ().pop ();\n+  resolver->get_type_scope ().pop ();\n+  resolver->get_label_scope ().pop ();\n+}\n+\n+void\n+ResolveTraitItems::visit (AST::TraitItemMethod &func)\n+{\n+  auto decl = ResolveTraitItemMethodToCanonicalPath::resolve (func);\n+  auto path = prefix.append (decl);\n+  auto cpath = canonical_prefix.append (decl);\n+  mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t   func.get_node_id (), cpath);\n+\n+  NodeId scope_node_id = func.get_node_id ();\n+  resolver->get_name_scope ().push (scope_node_id);\n+  resolver->get_type_scope ().push (scope_node_id);\n+  resolver->get_label_scope ().push (scope_node_id);\n+  resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n+  resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n+  resolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n+\n+  AST::TraitMethodDecl &function = func.get_trait_method_decl ();\n+  if (function.has_generics ())\n+    {\n+      for (auto &generic : function.get_generic_params ())\n+\tResolveGenericParam::go (generic.get (), func.get_node_id ());\n+    }\n+\n+  if (function.has_return_type ())\n+    ResolveType::go (function.get_return_type ().get (), func.get_node_id ());\n+\n+  // self turns into (self: Self) as a function param\n+  AST::SelfParam &self_param = function.get_self_param ();\n+  AST::IdentifierPattern self_pattern (self_param.get_node_id (), \"self\",\n+\t\t\t\t       self_param.get_locus (),\n+\t\t\t\t       self_param.get_has_ref (),\n+\t\t\t\t       self_param.get_is_mut (),\n+\t\t\t\t       std::unique_ptr<AST::Pattern> (nullptr));\n+\n+  std::vector<std::unique_ptr<AST::TypePathSegment> > segments;\n+  segments.push_back (std::unique_ptr<AST::TypePathSegment> (\n+    new AST::TypePathSegment (\"Self\", false, self_param.get_locus ())));\n+\n+  AST::TypePath self_type_path (std::move (segments), self_param.get_locus ());\n+\n+  ResolveType::go (&self_type_path, self_param.get_node_id ());\n+  PatternDeclaration::go (&self_pattern, self_param.get_node_id ());\n+\n+  resolver->mark_assignment_to_decl (self_pattern.get_node_id (),\n+\t\t\t\t     self_pattern.get_node_id ());\n+\n+  // we make a new scope so the names of parameters are resolved and shadowed\n+  // correctly\n+  for (auto &param : function.get_function_params ())\n+    {\n+      ResolveType::go (param.get_type ().get (), param.get_node_id ());\n+      PatternDeclaration::go (param.get_pattern ().get (),\n+\t\t\t      param.get_node_id ());\n+\n+      // the mutability checker needs to verify for immutable decls the number\n+      // of assignments are <1. This marks an implicit assignment\n+      resolver->mark_assignment_to_decl (\n+\tparam.get_pattern ()->get_pattern_node_id (), param.get_node_id ());\n+    }\n+\n+  if (function.has_where_clause ())\n+    ResolveWhereClause::Resolve (function.get_where_clause ());\n+\n+  // trait items have an optional body\n+  if (func.has_definition ())\n+    ResolveExpr::go (func.get_definition ().get (), func.get_node_id (), path,\n+\t\t     cpath);\n+\n+  resolver->get_name_scope ().pop ();\n+  resolver->get_type_scope ().pop ();\n+  resolver->get_label_scope ().pop ();\n+}\n+\n+void\n+ResolveTraitItems::visit (AST::TraitItemConst &constant)\n+{\n+  auto decl = ResolveTraitItemConstToCanonicalPath::resolve (constant);\n+  auto path = prefix.append (decl);\n+  auto cpath = canonical_prefix.append (decl);\n+  mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t   constant.get_node_id (), cpath);\n+\n+  ResolveType::go (constant.get_type ().get (), constant.get_node_id ());\n+\n+  if (constant.has_expr ())\n+    ResolveExpr::go (constant.get_expr ().get (), constant.get_node_id (), path,\n+\t\t     cpath);\n+\n+  // the mutability checker needs to verify for immutable decls the number\n+  // of assignments are <1. This marks an implicit assignment\n+  resolver->mark_decl_mutability (constant.get_node_id (), false);\n+  resolver->mark_assignment_to_decl (constant.get_node_id (),\n+\t\t\t\t     constant.get_node_id ());\n+}\n+\n+void\n+ResolveItem::go (AST::Item *item, const CanonicalPath &prefix,\n+\t\t const CanonicalPath &canonical_prefix)\n+{\n+  ResolveItem resolver (prefix, canonical_prefix);\n+  item->accept_vis (resolver);\n+}\n+\n+void\n+ResolveItem::visit (AST::TypeAlias &alias)\n+{\n+  auto talias\n+    = CanonicalPath::new_seg (alias.get_node_id (), alias.get_new_type_name ());\n+  auto path = prefix.append (talias);\n+  auto cpath = canonical_prefix.append (talias);\n+  mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t   alias.get_node_id (), cpath);\n+\n+  NodeId scope_node_id = alias.get_node_id ();\n+  resolver->get_type_scope ().push (scope_node_id);\n+\n+  if (alias.has_generics ())\n+    {\n+      for (auto &generic : alias.get_generic_params ())\n+\tResolveGenericParam::go (generic.get (), alias.get_node_id ());\n+    }\n+\n+  if (alias.has_where_clause ())\n+    ResolveWhereClause::Resolve (alias.get_where_clause ());\n+\n+  ResolveType::go (alias.get_type_aliased ().get (), alias.get_node_id ());\n+\n+  resolver->get_type_scope ().pop ();\n+}\n+\n+void\n+ResolveItem::visit (AST::Module &module)\n+{\n+  auto mod = CanonicalPath::new_seg (module.get_node_id (), module.get_name ());\n+  auto path = prefix.append (mod);\n+  auto cpath = canonical_prefix.append (mod);\n+  mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t   module.get_node_id (), cpath);\n+\n+  NodeId scope_node_id = module.get_node_id ();\n+  resolver->get_name_scope ().push (scope_node_id);\n+  resolver->get_type_scope ().push (scope_node_id);\n+  resolver->get_label_scope ().push (scope_node_id);\n+  resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n+  resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n+  resolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n+\n+  for (auto &item : module.get_items ())\n+    ResolveTopLevel::go (item.get (), CanonicalPath::create_empty (), cpath);\n+\n+  for (auto &item : module.get_items ())\n+    ResolveItem::go (item.get (), path, cpath);\n+\n+  resolver->get_name_scope ().pop ();\n+  resolver->get_type_scope ().pop ();\n+  resolver->get_label_scope ().pop ();\n+}\n+\n+void\n+ResolveItem::visit (AST::TupleStruct &struct_decl)\n+{\n+  auto decl = CanonicalPath::new_seg (struct_decl.get_node_id (),\n+\t\t\t\t      struct_decl.get_identifier ());\n+  auto path = prefix.append (decl);\n+  auto cpath = canonical_prefix.append (decl);\n+  mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t   struct_decl.get_node_id (), cpath);\n+\n+  NodeId scope_node_id = struct_decl.get_node_id ();\n+  resolver->get_type_scope ().push (scope_node_id);\n+\n+  if (struct_decl.has_generics ())\n+    {\n+      for (auto &generic : struct_decl.get_generic_params ())\n+\t{\n+\t  ResolveGenericParam::go (generic.get (), struct_decl.get_node_id ());\n+\t}\n+    }\n+\n+  if (struct_decl.has_where_clause ())\n+    ResolveWhereClause::Resolve (struct_decl.get_where_clause ());\n+\n+  for (AST::TupleField &field : struct_decl.get_fields ())\n+    {\n+      if (field.get_field_type ()->is_marked_for_strip ())\n+\tcontinue;\n+\n+      ResolveType::go (field.get_field_type ().get (),\n+\t\t       struct_decl.get_node_id ());\n+    }\n+\n+  resolver->get_type_scope ().pop ();\n+}\n+\n+void\n+ResolveItem::visit (AST::Enum &enum_decl)\n+{\n+  auto decl = CanonicalPath::new_seg (enum_decl.get_node_id (),\n+\t\t\t\t      enum_decl.get_identifier ());\n+  auto path = prefix.append (decl);\n+  auto cpath = canonical_prefix.append (decl);\n+  mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t   enum_decl.get_node_id (), cpath);\n+\n+  NodeId scope_node_id = enum_decl.get_node_id ();\n+  resolver->get_type_scope ().push (scope_node_id);\n+\n+  if (enum_decl.has_generics ())\n+    {\n+      for (auto &generic : enum_decl.get_generic_params ())\n+\t{\n+\t  ResolveGenericParam::go (generic.get (), enum_decl.get_node_id ());\n+\t}\n+    }\n+\n+  if (enum_decl.has_where_clause ())\n+    ResolveWhereClause::Resolve (enum_decl.get_where_clause ());\n+\n+  /* The actual fields are inside the variants.  */\n+  for (auto &variant : enum_decl.get_variants ())\n+    ResolveItem::go (variant.get (), path, cpath);\n+\n+  resolver->get_type_scope ().pop ();\n+}\n+\n+/* EnumItem doesn't need to be handled, no fields.  */\n+void\n+ResolveItem::visit (AST::EnumItem &item)\n+{\n+  auto decl\n+    = CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ());\n+  auto path = prefix.append (decl);\n+  auto cpath = canonical_prefix.append (decl);\n+  mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t   item.get_node_id (), cpath);\n+}\n+\n+void\n+ResolveItem::visit (AST::EnumItemTuple &item)\n+{\n+  auto decl\n+    = CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ());\n+  auto path = prefix.append (decl);\n+  auto cpath = canonical_prefix.append (decl);\n+  mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t   item.get_node_id (), cpath);\n+\n+  for (auto &field : item.get_tuple_fields ())\n+    {\n+      if (field.get_field_type ()->is_marked_for_strip ())\n+\tcontinue;\n+\n+      ResolveType::go (field.get_field_type ().get (), item.get_node_id ());\n+    }\n+}\n+\n+void\n+ResolveItem::visit (AST::EnumItemStruct &item)\n+{\n+  auto decl\n+    = CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ());\n+  auto path = prefix.append (decl);\n+  auto cpath = canonical_prefix.append (decl);\n+  mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t   item.get_node_id (), cpath);\n+\n+  for (auto &field : item.get_struct_fields ())\n+    {\n+      if (field.get_field_type ()->is_marked_for_strip ())\n+\tcontinue;\n+\n+      ResolveType::go (field.get_field_type ().get (), item.get_node_id ());\n+    }\n+}\n+\n+void\n+ResolveItem::visit (AST::EnumItemDiscriminant &item)\n+{\n+  auto decl\n+    = CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ());\n+  auto path = prefix.append (decl);\n+  auto cpath = canonical_prefix.append (decl);\n+\n+  mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t   item.get_node_id (), cpath);\n+}\n+\n+void\n+ResolveItem::visit (AST::StructStruct &struct_decl)\n+{\n+  auto decl = CanonicalPath::new_seg (struct_decl.get_node_id (),\n+\t\t\t\t      struct_decl.get_identifier ());\n+  auto path = prefix.append (decl);\n+  auto cpath = canonical_prefix.append (decl);\n+  mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t   struct_decl.get_node_id (), cpath);\n+\n+  NodeId scope_node_id = struct_decl.get_node_id ();\n+  resolver->get_type_scope ().push (scope_node_id);\n+\n+  if (struct_decl.has_generics ())\n+    {\n+      for (auto &generic : struct_decl.get_generic_params ())\n+\t{\n+\t  ResolveGenericParam::go (generic.get (), struct_decl.get_node_id ());\n+\t}\n+    }\n+\n+  if (struct_decl.has_where_clause ())\n+    ResolveWhereClause::Resolve (struct_decl.get_where_clause ());\n+\n+  for (AST::StructField &field : struct_decl.get_fields ())\n+    {\n+      if (field.get_field_type ()->is_marked_for_strip ())\n+\tcontinue;\n+\n+      ResolveType::go (field.get_field_type ().get (),\n+\t\t       struct_decl.get_node_id ());\n+    }\n+\n+  resolver->get_type_scope ().pop ();\n+}\n+\n+void\n+ResolveItem::visit (AST::Union &union_decl)\n+{\n+  auto decl = CanonicalPath::new_seg (union_decl.get_node_id (),\n+\t\t\t\t      union_decl.get_identifier ());\n+  auto path = prefix.append (decl);\n+  auto cpath = canonical_prefix.append (decl);\n+  mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t   union_decl.get_node_id (), cpath);\n+\n+  NodeId scope_node_id = union_decl.get_node_id ();\n+  resolver->get_type_scope ().push (scope_node_id);\n+\n+  if (union_decl.has_generics ())\n+    {\n+      for (auto &generic : union_decl.get_generic_params ())\n+\t{\n+\t  ResolveGenericParam::go (generic.get (), union_decl.get_node_id ());\n+\t}\n+    }\n+\n+  if (union_decl.has_where_clause ())\n+    ResolveWhereClause::Resolve (union_decl.get_where_clause ());\n+\n+  for (AST::StructField &field : union_decl.get_variants ())\n+    {\n+      if (field.get_field_type ()->is_marked_for_strip ())\n+\tcontinue;\n+\n+      ResolveType::go (field.get_field_type ().get (),\n+\t\t       union_decl.get_node_id ());\n+    }\n+\n+  resolver->get_type_scope ().pop ();\n+}\n+\n+void\n+ResolveItem::visit (AST::StaticItem &var)\n+{\n+  auto decl\n+    = CanonicalPath::new_seg (var.get_node_id (), var.get_identifier ());\n+  auto path = prefix.append (decl);\n+  auto cpath = canonical_prefix.append (decl);\n+  mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t   var.get_node_id (), cpath);\n+\n+  ResolveType::go (var.get_type ().get (), var.get_node_id ());\n+  ResolveExpr::go (var.get_expr ().get (), var.get_node_id (), path, cpath);\n+\n+  // the mutability checker needs to verify for immutable decls the number\n+  // of assignments are <1. This marks an implicit assignment\n+  resolver->mark_assignment_to_decl (var.get_node_id (), var.get_node_id ());\n+}\n+\n+void\n+ResolveItem::visit (AST::ConstantItem &constant)\n+{\n+  auto decl = ResolveConstantItemToCanonicalPath::resolve (constant);\n+  auto path = prefix.append (decl);\n+  auto cpath = canonical_prefix.append (decl);\n+  mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t   constant.get_node_id (), cpath);\n+\n+  ResolveType::go (constant.get_type ().get (), constant.get_node_id ());\n+  ResolveExpr::go (constant.get_expr ().get (), constant.get_node_id (), path,\n+\t\t   cpath);\n+\n+  // the mutability checker needs to verify for immutable decls the number\n+  // of assignments are <1. This marks an implicit assignment\n+  resolver->mark_decl_mutability (constant.get_node_id (), false);\n+  resolver->mark_assignment_to_decl (constant.get_node_id (),\n+\t\t\t\t     constant.get_node_id ());\n+}\n+\n+void\n+ResolveItem::visit (AST::Function &function)\n+{\n+  auto decl = ResolveFunctionItemToCanonicalPath::resolve (function);\n+  auto path = prefix.append (decl);\n+  auto cpath = canonical_prefix.append (decl);\n+  mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t   function.get_node_id (), cpath);\n+\n+  NodeId scope_node_id = function.get_node_id ();\n+  resolver->get_name_scope ().push (scope_node_id);\n+  resolver->get_type_scope ().push (scope_node_id);\n+  resolver->get_label_scope ().push (scope_node_id);\n+  resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n+  resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n+  resolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n+\n+  if (function.has_generics ())\n+    {\n+      for (auto &generic : function.get_generic_params ())\n+\tResolveGenericParam::go (generic.get (), function.get_node_id ());\n+    }\n+\n+  // resolve any where clause items\n+  if (function.has_where_clause ())\n+    ResolveWhereClause::Resolve (function.get_where_clause ());\n+\n+  if (function.has_return_type ())\n+    ResolveType::go (function.get_return_type ().get (),\n+\t\t     function.get_node_id ());\n+\n+  // we make a new scope so the names of parameters are resolved and shadowed\n+  // correctly\n+  for (auto &param : function.get_function_params ())\n+    {\n+      ResolveType::go (param.get_type ().get (), param.get_node_id ());\n+      PatternDeclaration::go (param.get_pattern ().get (),\n+\t\t\t      param.get_node_id ());\n+\n+      // the mutability checker needs to verify for immutable decls the number\n+      // of assignments are <1. This marks an implicit assignment\n+      resolver->mark_assignment_to_decl (\n+\tparam.get_pattern ()->get_pattern_node_id (), param.get_node_id ());\n+    }\n+\n+  // resolve the function body\n+  ResolveExpr::go (function.get_definition ().get (), function.get_node_id (),\n+\t\t   path, cpath);\n+\n+  resolver->get_name_scope ().pop ();\n+  resolver->get_type_scope ().pop ();\n+  resolver->get_label_scope ().pop ();\n+}\n+\n+void\n+ResolveItem::visit (AST::InherentImpl &impl_block)\n+{\n+  NodeId scope_node_id = impl_block.get_node_id ();\n+  resolver->get_name_scope ().push (scope_node_id);\n+  resolver->get_type_scope ().push (scope_node_id);\n+  resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n+  resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n+\n+  if (impl_block.has_generics ())\n+    {\n+      for (auto &generic : impl_block.get_generic_params ())\n+\t{\n+\t  ResolveGenericParam::go (generic.get (), impl_block.get_node_id ());\n+\t}\n+    }\n+\n+  // resolve any where clause items\n+  if (impl_block.has_where_clause ())\n+    ResolveWhereClause::Resolve (impl_block.get_where_clause ());\n+\n+  // FIXME this needs to be protected behind nominal type-checks see:\n+  // rustc --explain E0118\n+\n+  CanonicalPath self_cpath = CanonicalPath::create_empty ();\n+  bool canonicalize_type_with_generics = false;\n+  NodeId resolved_node\n+    = ResolveType::go (impl_block.get_type ().get (), impl_block.get_node_id (),\n+\t\t       canonicalize_type_with_generics, &self_cpath);\n+  if (resolved_node == UNKNOWN_NODEID)\n+    {\n+      resolver->get_type_scope ().pop ();\n+      resolver->get_name_scope ().pop ();\n+      return;\n+    }\n+\n+  // Setup paths\n+  bool canonicalize_type_args = !impl_block.has_generics ();\n+  bool type_resolve_generic_args = false;\n+\n+  CanonicalPath impl_type\n+    = ResolveTypeToCanonicalPath::resolve (*impl_block.get_type ().get (),\n+\t\t\t\t\t   canonicalize_type_args,\n+\t\t\t\t\t   type_resolve_generic_args);\n+  CanonicalPath impl_prefix = prefix.append (impl_type);\n+\n+  // see https://godbolt.org/z/a3vMbsT6W\n+  CanonicalPath cpath = CanonicalPath::create_empty ();\n+  if (canonical_prefix.size () <= 1)\n+    {\n+      cpath = self_cpath;\n+    }\n+  else\n+    {\n+      std::string seg_buf = \"<impl \" + self_cpath.get () + \">\";\n+      CanonicalPath seg\n+\t= CanonicalPath::new_seg (impl_block.get_node_id (), seg_buf);\n+      cpath = canonical_prefix.append (seg);\n+    }\n+  // done setup paths\n+\n+  auto Self\n+    = CanonicalPath::get_big_self (impl_block.get_type ()->get_node_id ());\n+\n+  resolver->get_type_scope ().insert (Self,\n+\t\t\t\t      impl_block.get_type ()->get_node_id (),\n+\t\t\t\t      impl_block.get_type ()->get_locus ());\n+\n+  for (auto &impl_item : impl_block.get_impl_items ())\n+    {\n+      resolve_impl_item (impl_item.get (), impl_prefix, cpath);\n+    }\n+\n+  resolver->get_type_scope ().peek ()->clear_name (\n+    Self, impl_block.get_type ()->get_node_id ());\n+\n+  resolver->get_type_scope ().pop ();\n+  resolver->get_name_scope ().pop ();\n+}\n+\n+void\n+ResolveItem::visit (AST::Method &method)\n+{\n+  auto decl = ResolveMethodItemToCanonicalPath::resolve (method);\n+  auto path = prefix.append (decl);\n+  auto cpath = canonical_prefix.append (decl);\n+  mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t   method.get_node_id (), cpath);\n+\n+  NodeId scope_node_id = method.get_node_id ();\n+  resolver->get_name_scope ().push (scope_node_id);\n+  resolver->get_type_scope ().push (scope_node_id);\n+  resolver->get_label_scope ().push (scope_node_id);\n+  resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n+  resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n+  resolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n+\n+  if (method.has_generics ())\n+    {\n+      for (auto &generic : method.get_generic_params ())\n+\tResolveGenericParam::go (generic.get (), method.get_node_id ());\n+    }\n+\n+  // resolve any where clause items\n+  if (method.has_where_clause ())\n+    ResolveWhereClause::Resolve (method.get_where_clause ());\n+\n+  if (method.has_return_type ())\n+    ResolveType::go (method.get_return_type ().get (), method.get_node_id ());\n+\n+  // self turns into (self: Self) as a function param\n+  AST::SelfParam &self_param = method.get_self_param ();\n+  AST::IdentifierPattern self_pattern (self_param.get_node_id (), \"self\",\n+\t\t\t\t       self_param.get_locus (),\n+\t\t\t\t       self_param.get_has_ref (),\n+\t\t\t\t       self_param.get_is_mut (),\n+\t\t\t\t       std::unique_ptr<AST::Pattern> (nullptr));\n+\n+  std::vector<std::unique_ptr<AST::TypePathSegment> > segments;\n+  segments.push_back (std::unique_ptr<AST::TypePathSegment> (\n+    new AST::TypePathSegment (\"Self\", false, self_param.get_locus ())));\n+\n+  AST::TypePath self_type_path (std::move (segments), self_param.get_locus ());\n+\n+  ResolveType::go (&self_type_path, self_param.get_node_id ());\n+  PatternDeclaration::go (&self_pattern, self_param.get_node_id ());\n+\n+  resolver->mark_assignment_to_decl (self_pattern.get_node_id (),\n+\t\t\t\t     self_pattern.get_node_id ());\n+\n+  // we make a new scope so the names of parameters are resolved and shadowed\n+  // correctly\n+  for (auto &param : method.get_function_params ())\n+    {\n+      ResolveType::go (param.get_type ().get (), param.get_node_id ());\n+      PatternDeclaration::go (param.get_pattern ().get (),\n+\t\t\t      param.get_node_id ());\n+\n+      // the mutability checker needs to verify for immutable decls the number\n+      // of assignments are <1. This marks an implicit assignment\n+      resolver->mark_assignment_to_decl (\n+\tparam.get_pattern ()->get_pattern_node_id (), param.get_node_id ());\n+    }\n+\n+  // resolve any where clause items\n+  if (method.has_where_clause ())\n+    ResolveWhereClause::Resolve (method.get_where_clause ());\n+\n+  // resolve the function body\n+  ResolveExpr::go (method.get_definition ().get (), method.get_node_id (), path,\n+\t\t   cpath);\n+\n+  resolver->get_name_scope ().pop ();\n+  resolver->get_type_scope ().pop ();\n+  resolver->get_label_scope ().pop ();\n+}\n+\n+void\n+ResolveItem::visit (AST::TraitImpl &impl_block)\n+{\n+  NodeId scope_node_id = impl_block.get_node_id ();\n+  resolver->get_name_scope ().push (scope_node_id);\n+  resolver->get_type_scope ().push (scope_node_id);\n+  resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n+  resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n+\n+  if (impl_block.has_generics ())\n+    {\n+      for (auto &generic : impl_block.get_generic_params ())\n+\t{\n+\t  ResolveGenericParam::go (generic.get (), impl_block.get_node_id ());\n+\t}\n+    }\n+\n+  // resolve any where clause items\n+  if (impl_block.has_where_clause ())\n+    ResolveWhereClause::Resolve (impl_block.get_where_clause ());\n+\n+  CanonicalPath canonical_trait_type = CanonicalPath::create_empty ();\n+  bool canonicalize_type_with_generics = false;\n+  NodeId trait_resolved_node\n+    = ResolveType::go (&impl_block.get_trait_path (), impl_block.get_node_id (),\n+\t\t       canonicalize_type_with_generics, &canonical_trait_type);\n+  if (trait_resolved_node == UNKNOWN_NODEID)\n+    {\n+      resolver->get_type_scope ().pop ();\n+      resolver->get_name_scope ().pop ();\n+      return;\n+    }\n+\n+  CanonicalPath canonical_impl_type = CanonicalPath::create_empty ();\n+  NodeId type_resolved_node\n+    = ResolveType::go (impl_block.get_type ().get (), impl_block.get_node_id (),\n+\t\t       canonicalize_type_with_generics, &canonical_impl_type);\n+  if (type_resolved_node == UNKNOWN_NODEID)\n+    {\n+      resolver->get_type_scope ().pop ();\n+      resolver->get_name_scope ().pop ();\n+      return;\n+    }\n+\n+  // setup paths\n+  bool canonicalize_type_args = !impl_block.has_generics ();\n+  bool type_resolve_generic_args = false;\n+\n+  CanonicalPath impl_type_seg\n+    = ResolveTypeToCanonicalPath::resolve (*impl_block.get_type ().get (),\n+\t\t\t\t\t   canonicalize_type_args,\n+\t\t\t\t\t   type_resolve_generic_args);\n+  CanonicalPath trait_type_seg\n+    = ResolveTypeToCanonicalPath::resolve (impl_block.get_trait_path (),\n+\t\t\t\t\t   canonicalize_type_args,\n+\t\t\t\t\t   type_resolve_generic_args);\n+\n+  CanonicalPath projection\n+    = TraitImplProjection::resolve (impl_block.get_node_id (), trait_type_seg,\n+\t\t\t\t    impl_type_seg);\n+  CanonicalPath impl_prefix = prefix.append (projection);\n+\n+  // setup canonical-path\n+  CanonicalPath canonical_projection\n+    = TraitImplProjection::resolve (impl_block.get_node_id (),\n+\t\t\t\t    canonical_trait_type, canonical_impl_type);\n+  CanonicalPath cpath = CanonicalPath::create_empty ();\n+  if (canonical_prefix.size () <= 1)\n+    {\n+      cpath = canonical_projection;\n+    }\n+  else\n+    {\n+      std::string projection_str = canonical_projection.get ();\n+      std::string seg_buf\n+\t= \"<impl \" + projection_str.substr (1, projection_str.size () - 2)\n+\t  + \">\";\n+      CanonicalPath seg\n+\t= CanonicalPath::new_seg (impl_block.get_node_id (), seg_buf);\n+      cpath = canonical_prefix.append (seg);\n+    }\n+\n+  // DONE setup canonical-path\n+\n+  auto Self\n+    = CanonicalPath::get_big_self (impl_block.get_type ()->get_node_id ());\n+\n+  resolver->get_type_scope ().insert (Self,\n+\t\t\t\t      impl_block.get_type ()->get_node_id (),\n+\t\t\t\t      impl_block.get_type ()->get_locus ());\n+\n+  for (auto &impl_item : impl_block.get_impl_items ())\n+    {\n+      resolve_impl_item (impl_item.get (), impl_prefix, cpath);\n+    }\n+\n+  resolver->get_type_scope ().peek ()->clear_name (\n+    Self, impl_block.get_type ()->get_node_id ());\n+  resolver->get_type_scope ().pop ();\n+}\n+\n+void\n+ResolveItem::visit (AST::Trait &trait)\n+{\n+  NodeId scope_node_id = trait.get_node_id ();\n+  resolver->get_name_scope ().push (scope_node_id);\n+  resolver->get_type_scope ().push (scope_node_id);\n+  resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n+  resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n+\n+  // we need to inject an implicit self TypeParam here\n+  AST::TypeParam *implicit_self\n+    = new AST::TypeParam (\"Self\", trait.get_locus ());\n+  trait.insert_implict_self (\n+    std::unique_ptr<AST::GenericParam> (implicit_self));\n+  CanonicalPath Self = CanonicalPath::get_big_self (trait.get_node_id ());\n+\n+  for (auto &generic : trait.get_generic_params ())\n+    {\n+      ResolveGenericParam::go (generic.get (), trait.get_node_id ());\n+    }\n+\n+  // Self is an implicit TypeParam so lets mark it as such\n+  resolver->get_type_scope ().append_reference_for_def (\n+    Self.get_node_id (), implicit_self->get_node_id ());\n+\n+  if (trait.has_type_param_bounds ())\n+    {\n+      for (auto &bound : trait.get_type_param_bounds ())\n+\t{\n+\t  ResolveTypeBound::go (bound.get (), trait.get_node_id ());\n+\t}\n+    }\n+\n+  // resolve any where clause items\n+  if (trait.has_where_clause ())\n+    ResolveWhereClause::Resolve (trait.get_where_clause ());\n+\n+  // resolve the paths\n+  CanonicalPath path = CanonicalPath::create_empty ();\n+  CanonicalPath cpath = CanonicalPath::create_empty ();\n+  //\n+\n+  for (auto &item : trait.get_trait_items ())\n+    {\n+      ResolveTraitItems::go (item.get (), path, cpath);\n+    }\n+\n+  resolver->get_type_scope ().pop ();\n+  resolver->get_name_scope ().pop ();\n+}\n+\n+void\n+ResolveItem::visit (AST::ExternBlock &extern_block)\n+{\n+  for (auto &item : extern_block.get_extern_items ())\n+    {\n+      resolve_extern_item (item.get ());\n+    }\n+}\n+\n+void\n+ResolveImplItems::go (AST::InherentImplItem *item, const CanonicalPath &prefix,\n+\t\t      const CanonicalPath &canonical_prefix)\n+{\n+  if (item->is_marked_for_strip ())\n+    return;\n+\n+  ResolveImplItems resolver (prefix, canonical_prefix);\n+  item->accept_vis (resolver);\n+}\n+\n+void\n+ResolveImplItems::go (AST::TraitImplItem *item, const CanonicalPath &prefix,\n+\t\t      const CanonicalPath &canonical_prefix)\n+{\n+  if (item->is_marked_for_strip ())\n+    return;\n+\n+  ResolveImplItems resolver (prefix, canonical_prefix);\n+  item->accept_vis (resolver);\n+}\n+\n+void\n+ResolveImplItems::visit (AST::TypeAlias &alias)\n+{\n+  ResolveItem::visit (alias);\n+\n+  // FIXME this stops the erronious unused decls which will be fixed later on\n+  resolver->get_type_scope ().append_reference_for_def (alias.get_node_id (),\n+\t\t\t\t\t\t\talias.get_node_id ());\n+}\n+\n+void\n+ResolveExternItem::go (AST::ExternalItem *item)\n+{\n+  ResolveExternItem resolver;\n+  item->accept_vis (resolver);\n+}\n+\n+void\n+ResolveExternItem::visit (AST::ExternalFunctionItem &function)\n+{\n+  NodeId scope_node_id = function.get_node_id ();\n+  resolver->get_name_scope ().push (scope_node_id);\n+  resolver->get_type_scope ().push (scope_node_id);\n+  resolver->get_label_scope ().push (scope_node_id);\n+  resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n+  resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n+  resolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n+\n+  // resolve the generics\n+  if (function.has_generics ())\n+    {\n+      for (auto &generic : function.get_generic_params ())\n+\tResolveGenericParam::go (generic.get (), function.get_node_id ());\n+    }\n+\n+  if (function.has_return_type ())\n+    ResolveType::go (function.get_return_type ().get (),\n+\t\t     function.get_node_id ());\n+\n+  // we make a new scope so the names of parameters are resolved and shadowed\n+  // correctly\n+  for (auto &param : function.get_function_params ())\n+    {\n+      ResolveType::go (param.get_type ().get (), param.get_node_id ());\n+    }\n+\n+  // done\n+  resolver->get_name_scope ().pop ();\n+  resolver->get_type_scope ().pop ();\n+  resolver->get_label_scope ().pop ();\n+}\n+\n+void\n+ResolveExternItem::visit (AST::ExternalStaticItem &item)\n+{\n+  ResolveType::go (item.get_type ().get (), item.get_node_id ());\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "da5d4e823eb22c52551b870ab431390bce930b6b", "filename": "gcc/rust/resolve/rust-ast-resolve-item.h", "status": "modified", "additions": 30, "deletions": 893, "changes": 923, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e01b6b2a8727142e3bfd8229e8272c288421c5d/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e01b6b2a8727142e3bfd8229e8272c288421c5d/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h?ref=3e01b6b2a8727142e3bfd8229e8272c288421c5d", "patch": "@@ -36,173 +36,12 @@ class ResolveTraitItems : public ResolverBase\n \n public:\n   static void go (AST::TraitItem *item, const CanonicalPath &prefix,\n-\t\t  const CanonicalPath &canonical_prefix)\n-  {\n-    if (item->is_marked_for_strip ())\n-      return;\n+\t\t  const CanonicalPath &canonical_prefix);\n \n-    ResolveTraitItems resolver (prefix, canonical_prefix);\n-    item->accept_vis (resolver);\n-  };\n-\n-  void visit (AST::TraitItemType &type) override\n-  {\n-    auto decl = ResolveTraitItemTypeToCanonicalPath::resolve (type);\n-    auto path = prefix.append (decl);\n-    auto cpath = canonical_prefix.append (decl);\n-    mappings->insert_canonical_path (mappings->get_current_crate (),\n-\t\t\t\t     type.get_node_id (), cpath);\n-\n-    for (auto &bound : type.get_type_param_bounds ())\n-      ResolveTypeBound::go (bound.get (), type.get_node_id ());\n-  }\n-\n-  void visit (AST::TraitItemFunc &func) override\n-  {\n-    auto decl = ResolveTraitItemFunctionToCanonicalPath::resolve (func);\n-    auto path = prefix.append (decl);\n-    auto cpath = canonical_prefix.append (decl);\n-    mappings->insert_canonical_path (mappings->get_current_crate (),\n-\t\t\t\t     func.get_node_id (), cpath);\n-\n-    NodeId scope_node_id = func.get_node_id ();\n-    resolver->get_name_scope ().push (scope_node_id);\n-    resolver->get_type_scope ().push (scope_node_id);\n-    resolver->get_label_scope ().push (scope_node_id);\n-    resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n-    resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n-    resolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n-\n-    AST::TraitFunctionDecl &function = func.get_trait_function_decl ();\n-    if (function.has_generics ())\n-      {\n-\tfor (auto &generic : function.get_generic_params ())\n-\t  ResolveGenericParam::go (generic.get (), func.get_node_id ());\n-      }\n-\n-    if (function.has_return_type ())\n-      ResolveType::go (function.get_return_type ().get (), func.get_node_id ());\n-\n-    // we make a new scope so the names of parameters are resolved and shadowed\n-    // correctly\n-    for (auto &param : function.get_function_params ())\n-      {\n-\tResolveType::go (param.get_type ().get (), param.get_node_id ());\n-\tPatternDeclaration::go (param.get_pattern ().get (),\n-\t\t\t\tparam.get_node_id ());\n-\n-\t// the mutability checker needs to verify for immutable decls the number\n-\t// of assignments are <1. This marks an implicit assignment\n-\tresolver->mark_assignment_to_decl (\n-\t  param.get_pattern ()->get_pattern_node_id (), param.get_node_id ());\n-      }\n-\n-    if (function.has_where_clause ())\n-      ResolveWhereClause::Resolve (function.get_where_clause ());\n-\n-    // trait items have an optional body\n-    if (func.has_definition ())\n-      ResolveExpr::go (func.get_definition ().get (), func.get_node_id (), path,\n-\t\t       cpath);\n-\n-    resolver->get_name_scope ().pop ();\n-    resolver->get_type_scope ().pop ();\n-    resolver->get_label_scope ().pop ();\n-  }\n-\n-  void visit (AST::TraitItemMethod &func) override\n-  {\n-    auto decl = ResolveTraitItemMethodToCanonicalPath::resolve (func);\n-    auto path = prefix.append (decl);\n-    auto cpath = canonical_prefix.append (decl);\n-    mappings->insert_canonical_path (mappings->get_current_crate (),\n-\t\t\t\t     func.get_node_id (), cpath);\n-\n-    NodeId scope_node_id = func.get_node_id ();\n-    resolver->get_name_scope ().push (scope_node_id);\n-    resolver->get_type_scope ().push (scope_node_id);\n-    resolver->get_label_scope ().push (scope_node_id);\n-    resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n-    resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n-    resolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n-\n-    AST::TraitMethodDecl &function = func.get_trait_method_decl ();\n-    if (function.has_generics ())\n-      {\n-\tfor (auto &generic : function.get_generic_params ())\n-\t  ResolveGenericParam::go (generic.get (), func.get_node_id ());\n-      }\n-\n-    if (function.has_return_type ())\n-      ResolveType::go (function.get_return_type ().get (), func.get_node_id ());\n-\n-    // self turns into (self: Self) as a function param\n-    AST::SelfParam &self_param = function.get_self_param ();\n-    AST::IdentifierPattern self_pattern (\n-      self_param.get_node_id (), \"self\", self_param.get_locus (),\n-      self_param.get_has_ref (), self_param.get_is_mut (),\n-      std::unique_ptr<AST::Pattern> (nullptr));\n-\n-    std::vector<std::unique_ptr<AST::TypePathSegment> > segments;\n-    segments.push_back (std::unique_ptr<AST::TypePathSegment> (\n-      new AST::TypePathSegment (\"Self\", false, self_param.get_locus ())));\n-\n-    AST::TypePath self_type_path (std::move (segments),\n-\t\t\t\t  self_param.get_locus ());\n-\n-    ResolveType::go (&self_type_path, self_param.get_node_id ());\n-    PatternDeclaration::go (&self_pattern, self_param.get_node_id ());\n-\n-    resolver->mark_assignment_to_decl (self_pattern.get_node_id (),\n-\t\t\t\t       self_pattern.get_node_id ());\n-\n-    // we make a new scope so the names of parameters are resolved and shadowed\n-    // correctly\n-    for (auto &param : function.get_function_params ())\n-      {\n-\tResolveType::go (param.get_type ().get (), param.get_node_id ());\n-\tPatternDeclaration::go (param.get_pattern ().get (),\n-\t\t\t\tparam.get_node_id ());\n-\n-\t// the mutability checker needs to verify for immutable decls the number\n-\t// of assignments are <1. This marks an implicit assignment\n-\tresolver->mark_assignment_to_decl (\n-\t  param.get_pattern ()->get_pattern_node_id (), param.get_node_id ());\n-      }\n-\n-    if (function.has_where_clause ())\n-      ResolveWhereClause::Resolve (function.get_where_clause ());\n-\n-    // trait items have an optional body\n-    if (func.has_definition ())\n-      ResolveExpr::go (func.get_definition ().get (), func.get_node_id (), path,\n-\t\t       cpath);\n-\n-    resolver->get_name_scope ().pop ();\n-    resolver->get_type_scope ().pop ();\n-    resolver->get_label_scope ().pop ();\n-  }\n-\n-  void visit (AST::TraitItemConst &constant) override\n-  {\n-    auto decl = ResolveTraitItemConstToCanonicalPath::resolve (constant);\n-    auto path = prefix.append (decl);\n-    auto cpath = canonical_prefix.append (decl);\n-    mappings->insert_canonical_path (mappings->get_current_crate (),\n-\t\t\t\t     constant.get_node_id (), cpath);\n-\n-    ResolveType::go (constant.get_type ().get (), constant.get_node_id ());\n-\n-    if (constant.has_expr ())\n-      ResolveExpr::go (constant.get_expr ().get (), constant.get_node_id (),\n-\t\t       path, cpath);\n-\n-    // the mutability checker needs to verify for immutable decls the number\n-    // of assignments are <1. This marks an implicit assignment\n-    resolver->mark_decl_mutability (constant.get_node_id (), false);\n-    resolver->mark_assignment_to_decl (constant.get_node_id (),\n-\t\t\t\t       constant.get_node_id ());\n-  }\n+  void visit (AST::TraitItemType &type) override;\n+  void visit (AST::TraitItemFunc &func) override;\n+  void visit (AST::TraitItemMethod &func) override;\n+  void visit (AST::TraitItemConst &constant) override;\n \n private:\n   ResolveTraitItems (const CanonicalPath &prefix,\n@@ -221,667 +60,27 @@ class ResolveItem : public ResolverBase\n   using Rust::Resolver::ResolverBase::visit;\n \n   static void go (AST::Item *item, const CanonicalPath &prefix,\n-\t\t  const CanonicalPath &canonical_prefix)\n-  {\n-    ResolveItem resolver (prefix, canonical_prefix);\n-    item->accept_vis (resolver);\n-  };\n-\n-  void visit (AST::TypeAlias &alias) override\n-  {\n-    auto talias = CanonicalPath::new_seg (alias.get_node_id (),\n-\t\t\t\t\t  alias.get_new_type_name ());\n-    auto path = prefix.append (talias);\n-    auto cpath = canonical_prefix.append (talias);\n-    mappings->insert_canonical_path (mappings->get_current_crate (),\n-\t\t\t\t     alias.get_node_id (), cpath);\n-\n-    NodeId scope_node_id = alias.get_node_id ();\n-    resolver->get_type_scope ().push (scope_node_id);\n-\n-    if (alias.has_generics ())\n-      {\n-\tfor (auto &generic : alias.get_generic_params ())\n-\t  ResolveGenericParam::go (generic.get (), alias.get_node_id ());\n-      }\n-\n-    if (alias.has_where_clause ())\n-      ResolveWhereClause::Resolve (alias.get_where_clause ());\n-\n-    ResolveType::go (alias.get_type_aliased ().get (), alias.get_node_id ());\n-\n-    resolver->get_type_scope ().pop ();\n-  }\n-\n-  void visit (AST::Module &module) override\n-  {\n-    auto mod\n-      = CanonicalPath::new_seg (module.get_node_id (), module.get_name ());\n-    auto path = prefix.append (mod);\n-    auto cpath = canonical_prefix.append (mod);\n-    mappings->insert_canonical_path (mappings->get_current_crate (),\n-\t\t\t\t     module.get_node_id (), cpath);\n-\n-    NodeId scope_node_id = module.get_node_id ();\n-    resolver->get_name_scope ().push (scope_node_id);\n-    resolver->get_type_scope ().push (scope_node_id);\n-    resolver->get_label_scope ().push (scope_node_id);\n-    resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n-    resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n-    resolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n-\n-    for (auto &item : module.get_items ())\n-      ResolveTopLevel::go (item.get (), CanonicalPath::create_empty (), cpath);\n-\n-    for (auto &item : module.get_items ())\n-      ResolveItem::go (item.get (), path, cpath);\n-\n-    resolver->get_name_scope ().pop ();\n-    resolver->get_type_scope ().pop ();\n-    resolver->get_label_scope ().pop ();\n-  }\n-\n-  void visit (AST::TupleStruct &struct_decl) override\n-  {\n-    auto decl = CanonicalPath::new_seg (struct_decl.get_node_id (),\n-\t\t\t\t\tstruct_decl.get_identifier ());\n-    auto path = prefix.append (decl);\n-    auto cpath = canonical_prefix.append (decl);\n-    mappings->insert_canonical_path (mappings->get_current_crate (),\n-\t\t\t\t     struct_decl.get_node_id (), cpath);\n-\n-    NodeId scope_node_id = struct_decl.get_node_id ();\n-    resolver->get_type_scope ().push (scope_node_id);\n-\n-    if (struct_decl.has_generics ())\n-      {\n-\tfor (auto &generic : struct_decl.get_generic_params ())\n-\t  {\n-\t    ResolveGenericParam::go (generic.get (),\n-\t\t\t\t     struct_decl.get_node_id ());\n-\t  }\n-      }\n-\n-    if (struct_decl.has_where_clause ())\n-      ResolveWhereClause::Resolve (struct_decl.get_where_clause ());\n-\n-    for (AST::TupleField &field : struct_decl.get_fields ())\n-      {\n-\tif (field.get_field_type ()->is_marked_for_strip ())\n-\t  continue;\n-\n-\tResolveType::go (field.get_field_type ().get (),\n-\t\t\t struct_decl.get_node_id ());\n-      }\n-\n-    resolver->get_type_scope ().pop ();\n-  }\n-\n-  void visit (AST::Enum &enum_decl) override\n-  {\n-    auto decl = CanonicalPath::new_seg (enum_decl.get_node_id (),\n-\t\t\t\t\tenum_decl.get_identifier ());\n-    auto path = prefix.append (decl);\n-    auto cpath = canonical_prefix.append (decl);\n-    mappings->insert_canonical_path (mappings->get_current_crate (),\n-\t\t\t\t     enum_decl.get_node_id (), cpath);\n-\n-    NodeId scope_node_id = enum_decl.get_node_id ();\n-    resolver->get_type_scope ().push (scope_node_id);\n-\n-    if (enum_decl.has_generics ())\n-      {\n-\tfor (auto &generic : enum_decl.get_generic_params ())\n-\t  {\n-\t    ResolveGenericParam::go (generic.get (), enum_decl.get_node_id ());\n-\t  }\n-      }\n-\n-    if (enum_decl.has_where_clause ())\n-      ResolveWhereClause::Resolve (enum_decl.get_where_clause ());\n-\n-    /* The actual fields are inside the variants.  */\n-    for (auto &variant : enum_decl.get_variants ())\n-      ResolveItem::go (variant.get (), path, cpath);\n-\n-    resolver->get_type_scope ().pop ();\n-  }\n+\t\t  const CanonicalPath &canonical_prefix);\n \n+  void visit (AST::TypeAlias &alias) override;\n+  void visit (AST::Module &module) override;\n+  void visit (AST::TupleStruct &struct_decl) override;\n+  void visit (AST::Enum &enum_decl) override;\n   /* EnumItem doesn't need to be handled, no fields.  */\n-  void visit (AST::EnumItem &item) override\n-  {\n-    auto decl\n-      = CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ());\n-    auto path = prefix.append (decl);\n-    auto cpath = canonical_prefix.append (decl);\n-    mappings->insert_canonical_path (mappings->get_current_crate (),\n-\t\t\t\t     item.get_node_id (), cpath);\n-  }\n-\n-  void visit (AST::EnumItemTuple &item) override\n-  {\n-    auto decl\n-      = CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ());\n-    auto path = prefix.append (decl);\n-    auto cpath = canonical_prefix.append (decl);\n-    mappings->insert_canonical_path (mappings->get_current_crate (),\n-\t\t\t\t     item.get_node_id (), cpath);\n-\n-    for (auto &field : item.get_tuple_fields ())\n-      {\n-\tif (field.get_field_type ()->is_marked_for_strip ())\n-\t  continue;\n-\n-\tResolveType::go (field.get_field_type ().get (), item.get_node_id ());\n-      }\n-  }\n-\n-  void visit (AST::EnumItemStruct &item) override\n-  {\n-    auto decl\n-      = CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ());\n-    auto path = prefix.append (decl);\n-    auto cpath = canonical_prefix.append (decl);\n-    mappings->insert_canonical_path (mappings->get_current_crate (),\n-\t\t\t\t     item.get_node_id (), cpath);\n-\n-    for (auto &field : item.get_struct_fields ())\n-      {\n-\tif (field.get_field_type ()->is_marked_for_strip ())\n-\t  continue;\n-\n-\tResolveType::go (field.get_field_type ().get (), item.get_node_id ());\n-      }\n-  }\n-\n-  void visit (AST::EnumItemDiscriminant &item) override\n-  {\n-    auto decl\n-      = CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ());\n-    auto path = prefix.append (decl);\n-    auto cpath = canonical_prefix.append (decl);\n-\n-    mappings->insert_canonical_path (mappings->get_current_crate (),\n-\t\t\t\t     item.get_node_id (), cpath);\n-  }\n-\n-  void visit (AST::StructStruct &struct_decl) override\n-  {\n-    auto decl = CanonicalPath::new_seg (struct_decl.get_node_id (),\n-\t\t\t\t\tstruct_decl.get_identifier ());\n-    auto path = prefix.append (decl);\n-    auto cpath = canonical_prefix.append (decl);\n-    mappings->insert_canonical_path (mappings->get_current_crate (),\n-\t\t\t\t     struct_decl.get_node_id (), cpath);\n-\n-    NodeId scope_node_id = struct_decl.get_node_id ();\n-    resolver->get_type_scope ().push (scope_node_id);\n-\n-    if (struct_decl.has_generics ())\n-      {\n-\tfor (auto &generic : struct_decl.get_generic_params ())\n-\t  {\n-\t    ResolveGenericParam::go (generic.get (),\n-\t\t\t\t     struct_decl.get_node_id ());\n-\t  }\n-      }\n-\n-    if (struct_decl.has_where_clause ())\n-      ResolveWhereClause::Resolve (struct_decl.get_where_clause ());\n-\n-    for (AST::StructField &field : struct_decl.get_fields ())\n-      {\n-\tif (field.get_field_type ()->is_marked_for_strip ())\n-\t  continue;\n-\n-\tResolveType::go (field.get_field_type ().get (),\n-\t\t\t struct_decl.get_node_id ());\n-      }\n-\n-    resolver->get_type_scope ().pop ();\n-  }\n-\n-  void visit (AST::Union &union_decl) override\n-  {\n-    auto decl = CanonicalPath::new_seg (union_decl.get_node_id (),\n-\t\t\t\t\tunion_decl.get_identifier ());\n-    auto path = prefix.append (decl);\n-    auto cpath = canonical_prefix.append (decl);\n-    mappings->insert_canonical_path (mappings->get_current_crate (),\n-\t\t\t\t     union_decl.get_node_id (), cpath);\n-\n-    NodeId scope_node_id = union_decl.get_node_id ();\n-    resolver->get_type_scope ().push (scope_node_id);\n-\n-    if (union_decl.has_generics ())\n-      {\n-\tfor (auto &generic : union_decl.get_generic_params ())\n-\t  {\n-\t    ResolveGenericParam::go (generic.get (), union_decl.get_node_id ());\n-\t  }\n-      }\n-\n-    if (union_decl.has_where_clause ())\n-      ResolveWhereClause::Resolve (union_decl.get_where_clause ());\n-\n-    for (AST::StructField &field : union_decl.get_variants ())\n-      {\n-\tif (field.get_field_type ()->is_marked_for_strip ())\n-\t  continue;\n-\n-\tResolveType::go (field.get_field_type ().get (),\n-\t\t\t union_decl.get_node_id ());\n-      }\n-\n-    resolver->get_type_scope ().pop ();\n-  }\n-\n-  void visit (AST::StaticItem &var) override\n-  {\n-    auto decl\n-      = CanonicalPath::new_seg (var.get_node_id (), var.get_identifier ());\n-    auto path = prefix.append (decl);\n-    auto cpath = canonical_prefix.append (decl);\n-    mappings->insert_canonical_path (mappings->get_current_crate (),\n-\t\t\t\t     var.get_node_id (), cpath);\n-\n-    ResolveType::go (var.get_type ().get (), var.get_node_id ());\n-    ResolveExpr::go (var.get_expr ().get (), var.get_node_id (), path, cpath);\n-\n-    // the mutability checker needs to verify for immutable decls the number\n-    // of assignments are <1. This marks an implicit assignment\n-    resolver->mark_assignment_to_decl (var.get_node_id (), var.get_node_id ());\n-  }\n-\n-  void visit (AST::ConstantItem &constant) override\n-  {\n-    auto decl = ResolveConstantItemToCanonicalPath::resolve (constant);\n-    auto path = prefix.append (decl);\n-    auto cpath = canonical_prefix.append (decl);\n-    mappings->insert_canonical_path (mappings->get_current_crate (),\n-\t\t\t\t     constant.get_node_id (), cpath);\n-\n-    ResolveType::go (constant.get_type ().get (), constant.get_node_id ());\n-    ResolveExpr::go (constant.get_expr ().get (), constant.get_node_id (), path,\n-\t\t     cpath);\n-\n-    // the mutability checker needs to verify for immutable decls the number\n-    // of assignments are <1. This marks an implicit assignment\n-    resolver->mark_decl_mutability (constant.get_node_id (), false);\n-    resolver->mark_assignment_to_decl (constant.get_node_id (),\n-\t\t\t\t       constant.get_node_id ());\n-  }\n-\n-  void visit (AST::Function &function) override\n-  {\n-    auto decl = ResolveFunctionItemToCanonicalPath::resolve (function);\n-    auto path = prefix.append (decl);\n-    auto cpath = canonical_prefix.append (decl);\n-    mappings->insert_canonical_path (mappings->get_current_crate (),\n-\t\t\t\t     function.get_node_id (), cpath);\n-\n-    NodeId scope_node_id = function.get_node_id ();\n-    resolver->get_name_scope ().push (scope_node_id);\n-    resolver->get_type_scope ().push (scope_node_id);\n-    resolver->get_label_scope ().push (scope_node_id);\n-    resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n-    resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n-    resolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n-\n-    if (function.has_generics ())\n-      {\n-\tfor (auto &generic : function.get_generic_params ())\n-\t  ResolveGenericParam::go (generic.get (), function.get_node_id ());\n-      }\n-\n-    // resolve any where clause items\n-    if (function.has_where_clause ())\n-      ResolveWhereClause::Resolve (function.get_where_clause ());\n-\n-    if (function.has_return_type ())\n-      ResolveType::go (function.get_return_type ().get (),\n-\t\t       function.get_node_id ());\n-\n-    // we make a new scope so the names of parameters are resolved and shadowed\n-    // correctly\n-    for (auto &param : function.get_function_params ())\n-      {\n-\tResolveType::go (param.get_type ().get (), param.get_node_id ());\n-\tPatternDeclaration::go (param.get_pattern ().get (),\n-\t\t\t\tparam.get_node_id ());\n-\n-\t// the mutability checker needs to verify for immutable decls the number\n-\t// of assignments are <1. This marks an implicit assignment\n-\tresolver->mark_assignment_to_decl (\n-\t  param.get_pattern ()->get_pattern_node_id (), param.get_node_id ());\n-      }\n-\n-    // resolve the function body\n-    ResolveExpr::go (function.get_definition ().get (), function.get_node_id (),\n-\t\t     path, cpath);\n-\n-    resolver->get_name_scope ().pop ();\n-    resolver->get_type_scope ().pop ();\n-    resolver->get_label_scope ().pop ();\n-  }\n-\n-  void visit (AST::InherentImpl &impl_block) override\n-  {\n-    NodeId scope_node_id = impl_block.get_node_id ();\n-    resolver->get_name_scope ().push (scope_node_id);\n-    resolver->get_type_scope ().push (scope_node_id);\n-    resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n-    resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n-\n-    if (impl_block.has_generics ())\n-      {\n-\tfor (auto &generic : impl_block.get_generic_params ())\n-\t  {\n-\t    ResolveGenericParam::go (generic.get (), impl_block.get_node_id ());\n-\t  }\n-      }\n-\n-    // resolve any where clause items\n-    if (impl_block.has_where_clause ())\n-      ResolveWhereClause::Resolve (impl_block.get_where_clause ());\n-\n-    // FIXME this needs to be protected behind nominal type-checks see:\n-    // rustc --explain E0118\n-\n-    CanonicalPath self_cpath = CanonicalPath::create_empty ();\n-    bool canonicalize_type_with_generics = false;\n-    NodeId resolved_node\n-      = ResolveType::go (impl_block.get_type ().get (),\n-\t\t\t impl_block.get_node_id (),\n-\t\t\t canonicalize_type_with_generics, &self_cpath);\n-    if (resolved_node == UNKNOWN_NODEID)\n-      {\n-\tresolver->get_type_scope ().pop ();\n-\tresolver->get_name_scope ().pop ();\n-\treturn;\n-      }\n-\n-    // Setup paths\n-    bool canonicalize_type_args = !impl_block.has_generics ();\n-    bool type_resolve_generic_args = false;\n-\n-    CanonicalPath impl_type\n-      = ResolveTypeToCanonicalPath::resolve (*impl_block.get_type ().get (),\n-\t\t\t\t\t     canonicalize_type_args,\n-\t\t\t\t\t     type_resolve_generic_args);\n-    CanonicalPath impl_prefix = prefix.append (impl_type);\n-\n-    // see https://godbolt.org/z/a3vMbsT6W\n-    CanonicalPath cpath = CanonicalPath::create_empty ();\n-    if (canonical_prefix.size () <= 1)\n-      {\n-\tcpath = self_cpath;\n-      }\n-    else\n-      {\n-\tstd::string seg_buf = \"<impl \" + self_cpath.get () + \">\";\n-\tCanonicalPath seg\n-\t  = CanonicalPath::new_seg (impl_block.get_node_id (), seg_buf);\n-\tcpath = canonical_prefix.append (seg);\n-      }\n-    // done setup paths\n-\n-    auto Self\n-      = CanonicalPath::get_big_self (impl_block.get_type ()->get_node_id ());\n-\n-    resolver->get_type_scope ().insert (Self,\n-\t\t\t\t\timpl_block.get_type ()->get_node_id (),\n-\t\t\t\t\timpl_block.get_type ()->get_locus ());\n-\n-    for (auto &impl_item : impl_block.get_impl_items ())\n-      {\n-\tresolve_impl_item (impl_item.get (), impl_prefix, cpath);\n-      }\n-\n-    resolver->get_type_scope ().peek ()->clear_name (\n-      Self, impl_block.get_type ()->get_node_id ());\n-\n-    resolver->get_type_scope ().pop ();\n-    resolver->get_name_scope ().pop ();\n-  }\n-\n-  void visit (AST::Method &method) override\n-  {\n-    auto decl = ResolveMethodItemToCanonicalPath::resolve (method);\n-    auto path = prefix.append (decl);\n-    auto cpath = canonical_prefix.append (decl);\n-    mappings->insert_canonical_path (mappings->get_current_crate (),\n-\t\t\t\t     method.get_node_id (), cpath);\n-\n-    NodeId scope_node_id = method.get_node_id ();\n-    resolver->get_name_scope ().push (scope_node_id);\n-    resolver->get_type_scope ().push (scope_node_id);\n-    resolver->get_label_scope ().push (scope_node_id);\n-    resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n-    resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n-    resolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n-\n-    if (method.has_generics ())\n-      {\n-\tfor (auto &generic : method.get_generic_params ())\n-\t  ResolveGenericParam::go (generic.get (), method.get_node_id ());\n-      }\n-\n-    // resolve any where clause items\n-    if (method.has_where_clause ())\n-      ResolveWhereClause::Resolve (method.get_where_clause ());\n-\n-    if (method.has_return_type ())\n-      ResolveType::go (method.get_return_type ().get (), method.get_node_id ());\n-\n-    // self turns into (self: Self) as a function param\n-    AST::SelfParam &self_param = method.get_self_param ();\n-    AST::IdentifierPattern self_pattern (\n-      self_param.get_node_id (), \"self\", self_param.get_locus (),\n-      self_param.get_has_ref (), self_param.get_is_mut (),\n-      std::unique_ptr<AST::Pattern> (nullptr));\n-\n-    std::vector<std::unique_ptr<AST::TypePathSegment> > segments;\n-    segments.push_back (std::unique_ptr<AST::TypePathSegment> (\n-      new AST::TypePathSegment (\"Self\", false, self_param.get_locus ())));\n-\n-    AST::TypePath self_type_path (std::move (segments),\n-\t\t\t\t  self_param.get_locus ());\n-\n-    ResolveType::go (&self_type_path, self_param.get_node_id ());\n-    PatternDeclaration::go (&self_pattern, self_param.get_node_id ());\n-\n-    resolver->mark_assignment_to_decl (self_pattern.get_node_id (),\n-\t\t\t\t       self_pattern.get_node_id ());\n-\n-    // we make a new scope so the names of parameters are resolved and shadowed\n-    // correctly\n-    for (auto &param : method.get_function_params ())\n-      {\n-\tResolveType::go (param.get_type ().get (), param.get_node_id ());\n-\tPatternDeclaration::go (param.get_pattern ().get (),\n-\t\t\t\tparam.get_node_id ());\n-\n-\t// the mutability checker needs to verify for immutable decls the number\n-\t// of assignments are <1. This marks an implicit assignment\n-\tresolver->mark_assignment_to_decl (\n-\t  param.get_pattern ()->get_pattern_node_id (), param.get_node_id ());\n-      }\n-\n-    // resolve any where clause items\n-    if (method.has_where_clause ())\n-      ResolveWhereClause::Resolve (method.get_where_clause ());\n-\n-    // resolve the function body\n-    ResolveExpr::go (method.get_definition ().get (), method.get_node_id (),\n-\t\t     path, cpath);\n-\n-    resolver->get_name_scope ().pop ();\n-    resolver->get_type_scope ().pop ();\n-    resolver->get_label_scope ().pop ();\n-  }\n-\n-  void visit (AST::TraitImpl &impl_block) override\n-  {\n-    NodeId scope_node_id = impl_block.get_node_id ();\n-    resolver->get_name_scope ().push (scope_node_id);\n-    resolver->get_type_scope ().push (scope_node_id);\n-    resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n-    resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n-\n-    if (impl_block.has_generics ())\n-      {\n-\tfor (auto &generic : impl_block.get_generic_params ())\n-\t  {\n-\t    ResolveGenericParam::go (generic.get (), impl_block.get_node_id ());\n-\t  }\n-      }\n-\n-    // resolve any where clause items\n-    if (impl_block.has_where_clause ())\n-      ResolveWhereClause::Resolve (impl_block.get_where_clause ());\n-\n-    CanonicalPath canonical_trait_type = CanonicalPath::create_empty ();\n-    bool canonicalize_type_with_generics = false;\n-    NodeId trait_resolved_node\n-      = ResolveType::go (&impl_block.get_trait_path (),\n-\t\t\t impl_block.get_node_id (),\n-\t\t\t canonicalize_type_with_generics,\n-\t\t\t &canonical_trait_type);\n-    if (trait_resolved_node == UNKNOWN_NODEID)\n-      {\n-\tresolver->get_type_scope ().pop ();\n-\tresolver->get_name_scope ().pop ();\n-\treturn;\n-      }\n-\n-    CanonicalPath canonical_impl_type = CanonicalPath::create_empty ();\n-    NodeId type_resolved_node\n-      = ResolveType::go (impl_block.get_type ().get (),\n-\t\t\t impl_block.get_node_id (),\n-\t\t\t canonicalize_type_with_generics, &canonical_impl_type);\n-    if (type_resolved_node == UNKNOWN_NODEID)\n-      {\n-\tresolver->get_type_scope ().pop ();\n-\tresolver->get_name_scope ().pop ();\n-\treturn;\n-      }\n-\n-    // setup paths\n-    bool canonicalize_type_args = !impl_block.has_generics ();\n-    bool type_resolve_generic_args = false;\n-\n-    CanonicalPath impl_type_seg\n-      = ResolveTypeToCanonicalPath::resolve (*impl_block.get_type ().get (),\n-\t\t\t\t\t     canonicalize_type_args,\n-\t\t\t\t\t     type_resolve_generic_args);\n-    CanonicalPath trait_type_seg\n-      = ResolveTypeToCanonicalPath::resolve (impl_block.get_trait_path (),\n-\t\t\t\t\t     canonicalize_type_args,\n-\t\t\t\t\t     type_resolve_generic_args);\n-\n-    CanonicalPath projection\n-      = TraitImplProjection::resolve (impl_block.get_node_id (), trait_type_seg,\n-\t\t\t\t      impl_type_seg);\n-    CanonicalPath impl_prefix = prefix.append (projection);\n-\n-    // setup canonical-path\n-    CanonicalPath canonical_projection\n-      = TraitImplProjection::resolve (impl_block.get_node_id (),\n-\t\t\t\t      canonical_trait_type,\n-\t\t\t\t      canonical_impl_type);\n-    CanonicalPath cpath = CanonicalPath::create_empty ();\n-    if (canonical_prefix.size () <= 1)\n-      {\n-\tcpath = canonical_projection;\n-      }\n-    else\n-      {\n-\tstd::string projection_str = canonical_projection.get ();\n-\tstd::string seg_buf\n-\t  = \"<impl \" + projection_str.substr (1, projection_str.size () - 2)\n-\t    + \">\";\n-\tCanonicalPath seg\n-\t  = CanonicalPath::new_seg (impl_block.get_node_id (), seg_buf);\n-\tcpath = canonical_prefix.append (seg);\n-      }\n-\n-    // DONE setup canonical-path\n-\n-    auto Self\n-      = CanonicalPath::get_big_self (impl_block.get_type ()->get_node_id ());\n-\n-    resolver->get_type_scope ().insert (Self,\n-\t\t\t\t\timpl_block.get_type ()->get_node_id (),\n-\t\t\t\t\timpl_block.get_type ()->get_locus ());\n-\n-    for (auto &impl_item : impl_block.get_impl_items ())\n-      {\n-\tresolve_impl_item (impl_item.get (), impl_prefix, cpath);\n-      }\n-\n-    resolver->get_type_scope ().peek ()->clear_name (\n-      Self, impl_block.get_type ()->get_node_id ());\n-    resolver->get_type_scope ().pop ();\n-  }\n-\n-  void visit (AST::Trait &trait) override\n-  {\n-    NodeId scope_node_id = trait.get_node_id ();\n-    resolver->get_name_scope ().push (scope_node_id);\n-    resolver->get_type_scope ().push (scope_node_id);\n-    resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n-    resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n-\n-    // we need to inject an implicit self TypeParam here\n-    AST::TypeParam *implicit_self\n-      = new AST::TypeParam (\"Self\", trait.get_locus ());\n-    trait.insert_implict_self (\n-      std::unique_ptr<AST::GenericParam> (implicit_self));\n-    CanonicalPath Self = CanonicalPath::get_big_self (trait.get_node_id ());\n-\n-    for (auto &generic : trait.get_generic_params ())\n-      {\n-\tResolveGenericParam::go (generic.get (), trait.get_node_id ());\n-      }\n-\n-    // Self is an implicit TypeParam so lets mark it as such\n-    resolver->get_type_scope ().append_reference_for_def (\n-      Self.get_node_id (), implicit_self->get_node_id ());\n-\n-    if (trait.has_type_param_bounds ())\n-      {\n-\tfor (auto &bound : trait.get_type_param_bounds ())\n-\t  {\n-\t    ResolveTypeBound::go (bound.get (), trait.get_node_id ());\n-\t  }\n-      }\n-\n-    // resolve any where clause items\n-    if (trait.has_where_clause ())\n-      ResolveWhereClause::Resolve (trait.get_where_clause ());\n-\n-    // resolve the paths\n-    CanonicalPath path = CanonicalPath::create_empty ();\n-    CanonicalPath cpath = CanonicalPath::create_empty ();\n-    //\n-\n-    for (auto &item : trait.get_trait_items ())\n-      {\n-\tResolveTraitItems::go (item.get (), path, cpath);\n-      }\n-\n-    resolver->get_type_scope ().pop ();\n-    resolver->get_name_scope ().pop ();\n-  }\n-\n-  void visit (AST::ExternBlock &extern_block) override\n-  {\n-    for (auto &item : extern_block.get_extern_items ())\n-      {\n-\tresolve_extern_item (item.get ());\n-      }\n-  }\n+  void visit (AST::EnumItem &item) override;\n+  void visit (AST::EnumItemTuple &item) override;\n+  void visit (AST::EnumItemStruct &item) override;\n+  void visit (AST::EnumItemDiscriminant &item) override;\n+  void visit (AST::StructStruct &struct_decl) override;\n+  void visit (AST::Union &union_decl) override;\n+  void visit (AST::StaticItem &var) override;\n+  void visit (AST::ConstantItem &constant) override;\n+  void visit (AST::Function &function) override;\n+  void visit (AST::InherentImpl &impl_block) override;\n+  void visit (AST::Method &method) override;\n+  void visit (AST::TraitImpl &impl_block) override;\n+  void visit (AST::Trait &trait) override;\n+  void visit (AST::ExternBlock &extern_block) override;\n \n protected:\n   void resolve_impl_item (AST::TraitImplItem *item, const CanonicalPath &prefix,\n@@ -907,33 +106,11 @@ class ResolveImplItems : public ResolveItem\n \n public:\n   static void go (AST::InherentImplItem *item, const CanonicalPath &prefix,\n-\t\t  const CanonicalPath &canonical_prefix)\n-  {\n-    if (item->is_marked_for_strip ())\n-      return;\n-\n-    ResolveImplItems resolver (prefix, canonical_prefix);\n-    item->accept_vis (resolver);\n-  };\n-\n+\t\t  const CanonicalPath &canonical_prefix);\n   static void go (AST::TraitImplItem *item, const CanonicalPath &prefix,\n-\t\t  const CanonicalPath &canonical_prefix)\n-  {\n-    if (item->is_marked_for_strip ())\n-      return;\n-\n-    ResolveImplItems resolver (prefix, canonical_prefix);\n-    item->accept_vis (resolver);\n-  };\n+\t\t  const CanonicalPath &canonical_prefix);\n \n-  void visit (AST::TypeAlias &alias) override\n-  {\n-    ResolveItem::visit (alias);\n-\n-    // FIXME this stops the erronious unused decls which will be fixed later on\n-    resolver->get_type_scope ().append_reference_for_def (alias.get_node_id (),\n-\t\t\t\t\t\t\t  alias.get_node_id ());\n-  }\n+  void visit (AST::TypeAlias &alias) override;\n \n private:\n   ResolveImplItems (const CanonicalPath &prefix,\n@@ -947,50 +124,10 @@ class ResolveExternItem : public ResolverBase\n   using Rust::Resolver::ResolverBase::visit;\n \n public:\n-  static void go (AST::ExternalItem *item)\n-  {\n-    ResolveExternItem resolver;\n-    item->accept_vis (resolver);\n-  };\n-\n-  void visit (AST::ExternalFunctionItem &function) override\n-  {\n-    NodeId scope_node_id = function.get_node_id ();\n-    resolver->get_name_scope ().push (scope_node_id);\n-    resolver->get_type_scope ().push (scope_node_id);\n-    resolver->get_label_scope ().push (scope_node_id);\n-    resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n-    resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n-    resolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n-\n-    // resolve the generics\n-    if (function.has_generics ())\n-      {\n-\tfor (auto &generic : function.get_generic_params ())\n-\t  ResolveGenericParam::go (generic.get (), function.get_node_id ());\n-      }\n-\n-    if (function.has_return_type ())\n-      ResolveType::go (function.get_return_type ().get (),\n-\t\t       function.get_node_id ());\n-\n-    // we make a new scope so the names of parameters are resolved and shadowed\n-    // correctly\n-    for (auto &param : function.get_function_params ())\n-      {\n-\tResolveType::go (param.get_type ().get (), param.get_node_id ());\n-      }\n-\n-    // done\n-    resolver->get_name_scope ().pop ();\n-    resolver->get_type_scope ().pop ();\n-    resolver->get_label_scope ().pop ();\n-  }\n+  static void go (AST::ExternalItem *item);\n \n-  void visit (AST::ExternalStaticItem &item) override\n-  {\n-    ResolveType::go (item.get_type ().get (), item.get_node_id ());\n-  }\n+  void visit (AST::ExternalFunctionItem &function) override;\n+  void visit (AST::ExternalStaticItem &item) override;\n \n private:\n   ResolveExternItem () : ResolverBase (UNKNOWN_NODEID) {}"}]}