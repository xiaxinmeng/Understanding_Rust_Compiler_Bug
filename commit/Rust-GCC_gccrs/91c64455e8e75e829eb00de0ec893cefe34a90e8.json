{"sha": "91c64455e8e75e829eb00de0ec893cefe34a90e8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTFjNjQ0NTVlOGU3NWU4MjllYjAwZGUwZWM4OTNjZWZlMzRhOTBlOA==", "commit": {"author": {"name": "Jozef Lawrynowicz", "email": "jozef.l@mittosystems.com", "date": "2019-10-23T16:52:47Z"}, "committer": {"name": "Jozef Lawrynowicz", "email": "jozefl@gcc.gnu.org", "date": "2019-10-23T16:52:47Z"}, "message": "lib2hw_mul.S: Fix wrong syntax in branch instruction.\n\n2019-10-23  Jozef Lawrynowicz  <jozef.l@mittosystems.com>\n\n\t* config/msp430/lib2hw_mul.S: Fix wrong syntax in branch instruction.\n\ts/RESULT_LO/RESLO, s/RESULT_HI/RESHI, s/MPY_OP1/MPY, \n\ts/MPY_OP1_S/MPYS, s/MAC_OP1/MAC, s/MPY_OP2/OP2, s/MAC_OP2/OP2.\n\tDefine symbols for 32-bit and f5series hardware multiply\n\tregister addresses.\n\tReplace hard-coded register addresses with symbols.\n\tFix \"_mspabi*\" typo.\n\tFix whitespace.\n\t* config/msp430/lib2mul.c: Add comment.\n\nFrom-SVN: r277340", "tree": {"sha": "2faef6076a96b994760e6fc1f25e9fd8211422f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2faef6076a96b994760e6fc1f25e9fd8211422f1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/91c64455e8e75e829eb00de0ec893cefe34a90e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91c64455e8e75e829eb00de0ec893cefe34a90e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91c64455e8e75e829eb00de0ec893cefe34a90e8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91c64455e8e75e829eb00de0ec893cefe34a90e8/comments", "author": {"login": "jozefl-mitto", "id": 36524004, "node_id": "MDQ6VXNlcjM2NTI0MDA0", "avatar_url": "https://avatars.githubusercontent.com/u/36524004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jozefl-mitto", "html_url": "https://github.com/jozefl-mitto", "followers_url": "https://api.github.com/users/jozefl-mitto/followers", "following_url": "https://api.github.com/users/jozefl-mitto/following{/other_user}", "gists_url": "https://api.github.com/users/jozefl-mitto/gists{/gist_id}", "starred_url": "https://api.github.com/users/jozefl-mitto/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jozefl-mitto/subscriptions", "organizations_url": "https://api.github.com/users/jozefl-mitto/orgs", "repos_url": "https://api.github.com/users/jozefl-mitto/repos", "events_url": "https://api.github.com/users/jozefl-mitto/events{/privacy}", "received_events_url": "https://api.github.com/users/jozefl-mitto/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "161c3bf9ee52b6d9ef1ca2529f823c9bb5a6e690", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/161c3bf9ee52b6d9ef1ca2529f823c9bb5a6e690", "html_url": "https://github.com/Rust-GCC/gccrs/commit/161c3bf9ee52b6d9ef1ca2529f823c9bb5a6e690"}], "stats": {"total": 185, "additions": 118, "deletions": 67}, "files": [{"sha": "99199944652b63dc1c003b040f43ef1d35a5bcc6", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91c64455e8e75e829eb00de0ec893cefe34a90e8/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91c64455e8e75e829eb00de0ec893cefe34a90e8/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=91c64455e8e75e829eb00de0ec893cefe34a90e8", "patch": "@@ -1,3 +1,15 @@\n+2019-10-23  Jozef Lawrynowicz  <jozef.l@mittosystems.com>\n+\n+\t* config/msp430/lib2hw_mul.S: Fix wrong syntax in branch instruction.\n+\ts/RESULT_LO/RESLO, s/RESULT_HI/RESHI, s/MPY_OP1/MPY, \n+\ts/MPY_OP1_S/MPYS, s/MAC_OP1/MAC, s/MPY_OP2/OP2, s/MAC_OP2/OP2.\n+\tDefine symbols for 32-bit and f5series hardware multiply\n+\tregister addresses.\n+\tReplace hard-coded register addresses with symbols.\n+\tFix \"_mspabi*\" typo.\n+\tFix whitespace.\n+\t* config/msp430/lib2mul.c: Add comment.\n+\n 2019-10-15  John David Anglin  <danglin@gcc.gnu.org>\n \n \t* config/pa/fptr.c (_dl_read_access_allowed): Change argument to"}, {"sha": "894c551cbf05e49e2bf9c11280b42df9f1b1fdd5", "filename": "libgcc/config/msp430/lib2hw_mul.S", "status": "modified", "additions": 103, "deletions": 67, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91c64455e8e75e829eb00de0ec893cefe34a90e8/libgcc%2Fconfig%2Fmsp430%2Flib2hw_mul.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91c64455e8e75e829eb00de0ec893cefe34a90e8/libgcc%2Fconfig%2Fmsp430%2Flib2hw_mul.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fmsp430%2Flib2hw_mul.S?ref=91c64455e8e75e829eb00de0ec893cefe34a90e8", "patch": "@@ -81,9 +81,9 @@\n \t.type \\gcc_name , @function\n \\gcc_name:\n #ifdef __MSP430X_LARGE__\n-\tBRA\t\\eabi_soft_name\n+\tBRA\t#\\eabi_soft_name\n #else\n-\tBR\t\\eabi_soft_name\n+\tBR\t#\\eabi_soft_name\n #endif\n \t.size \\gcc_name , . - \\gcc_name\n \t.popsection\n@@ -109,7 +109,7 @@\n \tMOV.W\t&\\RESULT, r12\t\t; Move result into return register\n .endm\n \n-.macro mult1632 OP1, OP2, RESULT_LO, RESULT_HI\n+.macro mult1632 OP1, OP2, RESLO, RESHI\n ;* * 16-bit hardware multiply with a 32-bit result:\n ;*\tint32 = int16 * int16\n ;* \tuint32 = uint16 * uint16\n@@ -127,11 +127,11 @@\n \t\n \tMOV.W\tr12, &\\OP1\t\t; Load operand 1 into multiplier\n \tMOV.W\tr13, &\\OP2\t\t; Load operand 2 which triggers MPY\n-\tMOV.W\t&\\RESULT_LO, r12\t; Move low result into return register\n-\tMOV.W\t&\\RESULT_HI, r13\t; Move high result into return register\n+\tMOV.W\t&\\RESLO, r12\t\t; Move low result into return register\n+\tMOV.W\t&\\RESHI, r13\t\t; Move high result into return register\n .endm\n \n-.macro mult32 OP1, OP2, MAC_OP1, MAC_OP2, RESULT_LO, RESULT_HI\n+.macro mult32 OP1, OP2, MAC_OP1, MAC_OP2, RESLO, RESHI\n ;* * 32-bit hardware multiply with a 32-bit result using 16 multiply and accumulate:\n ;*\tint32 = int32 * int32\n ;*  \n@@ -149,16 +149,16 @@\n \tMOV.W\tr12, &\\OP1\t\t; Load operand 1 Low into multiplier\n \tMOV.W\tr14, &\\OP2\t\t; Load operand 2 Low which triggers MPY\n \tMOV.W\tr12, &\\MAC_OP1\t\t; Load operand 1 Low into mac\n-\tMOV.W   &\\RESULT_LO, r12\t; Low 16-bits of result ready for return\n-\tMOV.W   &\\RESULT_HI, &\\RESULT_LO; MOV intermediate mpy high into low\n+\tMOV.W   &\\RESLO, r12\t\t; Low 16-bits of result ready for return\n+\tMOV.W   &\\RESHI, &\\RESLO\t; MOV intermediate mpy high into low\n \tMOV.W\tr15, &\\MAC_OP2\t\t; Load operand 2 High, trigger MAC\n \tMOV.W\tr13, &\\MAC_OP1\t\t; Load operand 1 High\n \tMOV.W\tr14, &\\MAC_OP2\t\t; Load operand 2 Lo, trigger MAC\n-\tMOV.W\t&\\RESULT_LO, r13        ; Upper 16-bits result ready for return\n+\tMOV.W\t&\\RESLO, r13\t\t; Upper 16-bits result ready for return\n .endm\n \n \n-.macro mult32_hw  OP1_LO  OP1_HI  OP2_LO  OP2_HI  RESULT_LO  RESULT_HI\n+.macro mult32_hw  OP1_LO  OP1_HI  OP2_LO  OP2_HI  RESLO  RESHI\n ;* * 32-bit hardware multiply with a 32-bit result\n ;*\tint32 = int32 * int32\n ;*  \n@@ -177,8 +177,8 @@\n \tMOV.W\tr13, &\\OP1_HI\t\t; Load operand 1 High into multiplier\n \tMOV.W\tr14, &\\OP2_LO\t\t; Load operand 2 Low into multiplier\n \tMOV.W\tr15, &\\OP2_HI\t\t; Load operand 2 High, trigger MPY\n-\tMOV.W\t&\\RESULT_LO, r12\t; Ready low 16-bits for return\n-\tMOV.W   &\\RESULT_HI, r13\t; Ready high 16-bits for return\n+\tMOV.W\t&\\RESLO, r12\t\t; Ready low 16-bits for return\n+\tMOV.W   &\\RESHI, r13\t\t; Ready high 16-bits for return\n .endm\n \n .macro mult3264_hw  OP1_LO  OP1_HI  OP2_LO  OP2_HI  RES0 RES1 RES2 RES3\n@@ -264,105 +264,141 @@\n ;; \t      Multiply unsigned long by unsigned long; result is unsigned long long. Uses hardware MPY16\n ;; uint64 __mspabi_mpyull_hw32(uint32 x, uint32 y)\n ;; \t      Multiply unsigned long by unsigned long; result is unsigned long long. Uses hardware MPY32 (F4xx devices).\n-;; uint64 _ _mspabi_mpyull_f5hw(uint32 x, uint32 y)\n+;; uint64 __mspabi_mpyull_f5hw(uint32 x, uint32 y)\n ;;            Multiply unsigned long by unsigned long; result is unsigned long long. Uses hardware MPY32 (F5xx devices and up)\n \n-\n-\n-.set MPY_OP1,   0x0130\n-.set MPY_OP1_S, 0x0132\n-.set MAC_OP1, \t0x0134\n-.set MPY_OP2, \t0x0138\n-.set MAC_OP2, \t0x0138\n-.set RESULT_LO, 0x013A\n-.set RESULT_HI, 0x013C\n+;;;; The register names below are the standardised versions used across TI\n+;;;; literature.\n+\n+;; Hardware multiply register addresses for devices with 16-bit hardware\n+;; multiply.\n+.set MPY,\t0x0130\n+.set MPYS,\t0x0132\n+.set MAC, \t0x0134\n+.set OP2, \t0x0138\n+.set RESLO,\t0x013A\n+.set RESHI,\t0x013C\n+;; Hardware multiply register addresses for devices with 32-bit (non-f5)\n+;; hardware multiply.\n+.set MPY32L,\t0x0140\n+.set MPY32H,\t0x0142\n+.set MPYS32L,\t0x0144\n+.set MPYS32H,\t0x0146\n+.set OP2L,\t0x0150\n+.set OP2H,\t0x0152\n+.set RES0,\t0x0154\n+.set RES1,\t0x0156\n+.set RES2,\t0x0158\n+.set RES3,\t0x015A\n+;; Hardware multiply register addresses for devices with f5series hardware\n+;; multiply.\n+;; The F5xxx series of MCUs support the same 16-bit and 32-bit multiply\n+;; as the second generation hardware, but they are accessed from different\n+;; memory registers.\n+;; These names AREN'T standard.  We've appended _F5 to the standard names.\n+.set MPY_F5,\t\t0x04C0\n+.set MPYS_F5,\t\t0x04C2\n+.set MAC_F5,\t\t0x04C4\n+.set OP2_F5,\t\t0x04C8\n+.set RESLO_F5,\t\t0x04CA\n+.set RESHI_F5,\t\t0x04CC\n+.set MPY32L_F5,\t\t0x04D0\n+.set MPY32H_F5,\t\t0x04D2\n+.set MPYS32L_F5,\t0x04D4\n+.set MPYS32H_F5,\t0x04D6\n+.set OP2L_F5,\t\t0x04E0\n+.set OP2H_F5,\t\t0x04E2\n+.set RES0_F5,\t\t0x04E4\n+.set RES1_F5,\t\t0x04E6\n+.set RES2_F5,\t\t0x04E8\n+.set RES3_F5,\t\t0x04EA\n \n #if defined MUL_16\n ;;  First generation MSP430 hardware multiplies ...\n \n \tstart_func __mulhi2 __mspabi_mpyi  __mspabi_mpyi_hw\n-\tmult16 MPY_OP1, MPY_OP2, RESULT_LO\n+\tmult16 MPY, OP2, RESLO\n \tend_func   __mulhi2\n \n-\tstart_func __mulsihi2  __mspabi_mpysl  __mspabi_mpysl_hw\n-\tmult1632 MPY_OP1_S, MPY_OP2, RESULT_LO, RESULT_HI\n-\tend_func   __mulsihi2\n+\tstart_func __mulhisi2  __mspabi_mpysl  __mspabi_mpysl_hw\n+\tmult1632 MPYS, OP2, RESLO, RESHI\n+\tend_func   __mulhisi2\n \n-\tstart_func __umulsihi2  __mspabi_mpyul  _mspabi_mpyul_hw\n-\tmult1632 MPY_OP1, MPY_OP2, RESULT_LO, RESULT_HI\n-\tend_func   __umulsihi2\n+\tstart_func __umulhisi2  __mspabi_mpyul  __mspabi_mpyul_hw\n+\tmult1632 MPY, OP2, RESLO, RESHI\n+\tend_func   __umulhisi2\n \n \tstart_func __mulsi2  __mspabi_mpyl  __mspabi_mpyl_hw\n-\tmult32 MPY_OP1, MPY_OP2, MAC_OP1, MAC_OP2, RESULT_LO, RESULT_HI\n+\tmult32 MPY, OP2, MAC, OP2, RESLO, RESHI\n \tend_func   __mulsi2\n \n \t;; FIXME: We do not have hardware implementations of these\n \t;; routines, so just jump to the software versions instead.\n-\tfake_func __muldisi2   __mspabi_mpysll  __mspabi_mpysll_hw   \n-\tfake_func __umuldisi2  __mspabi_mpyull  __mspabi_mpyull_hw  \n-\tfake_func __muldi3     __mspabi_mpyll   __mspabi_mpyll_hw\t\n+\tfake_func __mulsidi2   __mspabi_mpysll  __mspabi_mpysll_hw\n+\tfake_func __umulsidi2  __mspabi_mpyull  __mspabi_mpyull_hw\n+\tfake_func __muldi3     __mspabi_mpyll   __mspabi_mpyll_hw\n \n #elif defined MUL_32\n ;;  Second generation MSP430 hardware multiplies ...\n \n \tstart_func __mulhi2  __mspabi_mpyi  __mspabi_mpyi_hw\n-\tmult16 MPY_OP1, MPY_OP2, RESULT_LO\n+\tmult16 MPY, OP2, RESLO\n \tend_func   __mulhi2\n \n-\tstart_func __mulsihi2  __mspabi_mpysl  __mspabi_mpysl_hw\n-\tmult1632 MPY_OP1_S, MPY_OP2, RESULT_LO, RESULT_HI\n-\tend_func   __mulsihi2\n+\tstart_func __mulhisi2  __mspabi_mpysl  __mspabi_mpysl_hw\n+\tmult1632 MPYS, OP2, RESLO, RESHI\n+\tend_func   __mulhisi2\n \n-\tstart_func __umulsihi2  __mspabi_mpyul  _mspabi_mpyul_hw\n-\tmult1632 MPY_OP1, MPY_OP2, RESULT_LO, RESULT_HI\n-\tend_func   __umulsihi2\n+\tstart_func __umulhisi2  __mspabi_mpyul  __mspabi_mpyul_hw\n+\tmult1632 MPY, OP2, RESLO, RESHI\n+\tend_func   __umulhisi2\n \n \tstart_func __mulsi2_hw32  __mspabi_mpyl  __mspabi_mpyl_hw32\n-\tmult32_hw 0x0140, 0x0142, 0x0150, 0x0152, 0x0154, 0x0156\n+\tmult32_hw MPY32L, MPY32H, OP2L, OP2H, RES0, RES1\n \tend_func   __mulsi2_hw32\n \n-\tstart_func __muldisi2  __mspabi_mpysll  __mspabi_mpysll_hw32\n-\tmult3264_hw 0x0144, 0x146, 0x0150, 0x0152, 0x0154, 0x0156, 0x0158, 0x015A\n-\tend_func   __muldisi2\n+\tstart_func __mulsidi2  __mspabi_mpysll  __mspabi_mpysll_hw32\n+\tmult3264_hw MPYS32L, MPYS32H, OP2L, OP2H, RES0, RES1, RES2, RES3\n+\tend_func   __mulsidi2\n \n-\tstart_func __umuldisi2 __mspabi_mpyull  __mspabi_mpyull_hw32\n-\tmult3264_hw 0x0140, 0x142, 0x0150, 0x0152, 0x0154, 0x0156, 0x0158, 0x015A\n-\tend_func   __umuldisi2\n+\tstart_func __umulsidi2 __mspabi_mpyull  __mspabi_mpyull_hw32\n+\tmult3264_hw MPY32L, MPY32H, OP2L, OP2H, RES0, RES1, RES2, RES3\n+\tend_func   __umulsidi2\n \n \t;; FIXME: Add a hardware version of this function.\n-\tfake_func __muldi3    __mspabi_mpyll  __mspabi_mpyll_hw32 \n-\t\n+\tfake_func __muldi3    __mspabi_mpyll  __mspabi_mpyll_hw32\n+\n #elif defined MUL_F5\n /* The F5xxx series of MCUs support the same 16-bit and 32-bit multiply\n    as the second generation hardware, but they are accessed from different\n    memory registers.  */\n \n \tstart_func __mulhi2_f5 __mspabi_mpyi  __mspabi_mpyi_f5hw\n-\tmult16 0x04C0, 0x04C8, 0x04CA\n+\tmult16 MPY_F5, OP2_F5, RESLO_F5\n \tend_func   __mulhi2_f5\n \n-\tstart_func __mulsihi2  __mspabi_mpysl  __mspabi_mpysl_f5hw\n-\tmult1632 0x04C2, 0x04C8, 0x04CA, 0x04CC\n-\tend_func   __mulsihi2\n-\t\n-\tstart_func __umulsihi2  __mspabi_mpyul  _mspabi_mpyul_f5hw\n-\tmult1632 0x04C0, 0x04C8, 0x04CA, 0x04CC\n-\tend_func   __umulsihi2\n+\tstart_func __mulhisi2  __mspabi_mpysl  __mspabi_mpysl_f5hw\n+\tmult1632 MPYS_F5, OP2_F5, RESLO_F5, RESHI_F5\n+\tend_func   __mulhisi2\n+\n+\tstart_func __umulhisi2  __mspabi_mpyul  __mspabi_mpyul_f5hw\n+\tmult1632 MPY_F5, OP2_F5, RESLO_F5, RESHI_F5\n+\tend_func   __umulhisi2\n \n \tstart_func __mulsi2_f5  __mspabi_mpyl  __mspabi_mpyl_f5hw\n-\tmult32_hw 0x04D0, 0x04D2, 0x04E0, 0x04E2, 0x04E4, 0x04E6\n+\tmult32_hw MPY32L_F5, MPY32H_F5, OP2L_F5, OP2H_F5, RES0_F5, RES1_F5\n \tend_func   __mulsi2_f5\n-\t\n-\tstart_func __muldisi2  __mspabi_mpysll  __mspabi_mpysll_f5hw\n-\tmult3264_hw 0x04D4, 0x04D6, 0x04E0, 0x04E2, 0x04E4, 0x04E6, 0x04E8, 0x04EA\n-\tend_func   __muldisi2\n-\t\n-\tstart_func __umuldisi2  __mspabi_mpyull  __mspabi_mpyull_f5hw\n-\tmult3264_hw 0x04D0, 0x04D2, 0x04E0, 0x04E2, 0x04E4, 0x04E6, 0x04E8, 0x04EA\n-\tend_func   __umuldisi2\n+\n+\tstart_func __mulsidi2  __mspabi_mpysll  __mspabi_mpysll_f5hw\n+\tmult3264_hw MPYS32L_F5, MPYS32H_F5, OP2L_F5, OP2H_F5, RES0_F5, RES1_F5, RES2_F5, RES3_F5\n+\tend_func   __mulsidi2\n+\n+\tstart_func __umulsidi2  __mspabi_mpyull  __mspabi_mpyull_f5hw\n+\tmult3264_hw MPY32L_F5, MPY32H_F5, OP2L_F5, OP2H_F5, RES0_F5, RES1_F5, RES2_F5, RES3_F5\n+\tend_func   __umulsidi2\n \n \t;; FIXME: Add a hardware version of this function.\n-\tfake_func __muldi3   __mspabi_mpyll __mspabi_mpyll_f5hw \n+\tfake_func __muldi3   __mspabi_mpyll __mspabi_mpyll_f5hw\n \n #else\n #error MUL type not defined"}, {"sha": "95a2f1a7e30b1683b01e273806410a8e146a438a", "filename": "libgcc/config/msp430/lib2mul.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91c64455e8e75e829eb00de0ec893cefe34a90e8/libgcc%2Fconfig%2Fmsp430%2Flib2mul.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91c64455e8e75e829eb00de0ec893cefe34a90e8/libgcc%2Fconfig%2Fmsp430%2Flib2mul.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fmsp430%2Flib2mul.c?ref=91c64455e8e75e829eb00de0ec893cefe34a90e8", "patch": "@@ -46,6 +46,9 @@ typedef unsigned int  uint08_type   __attribute__ ((mode (QI)));\n \n #elif defined MUL_16\n \n+/* The 16-bit multiply library needs a software version of SI->DI widening\n+   multiplication.  */\n+\n signed long long\n __mspabi_mpysll (signed long a, signed long b)\n {"}]}