{"sha": "c2255bc4884a7624b32185e188fdb94a4167a35c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzIyNTViYzQ4ODRhNzYyNGIzMjE4NWUxODhmZGI5NGE0MTY3YTM1Yw==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2009-06-12T22:06:47Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2009-06-12T22:06:47Z"}, "message": "java-gimplify.c (java_gimplify_block): New argument to build_empty_stmt.\n\ngcc/java/\n\t* java-gimplify.c (java_gimplify_block): New argument to\n\tbuild_empty_stmt.\n\t* expr.c (force_evaluation_order): Same.\n\t* typeck.c: Add location to build_decl or PUSH_FIELD calls.\n\t* class.c: Same.\n\t* decl.c: Same.\n\t* jcf-parse.c: Same.\n\t* constants.c: Same.\n\t* resource.c: Same.\n\t* except.c: Same.\n\t* builtins.c: Same.\n\t* expr.c: Same.\n\t* java-tree.h (PUSH_FIELD): Add location field.\ngcc/objc/\n\t* objc-act.c (finish_var_decl): Pass location to finish_decl.\n\t(objc_get_parm_info): Same.\n\t(get_super_receiver): Same.\n\t* objc-act.c (objc_build_component_ref): Pass location to\n\tbuild_compound_ref.\n\t(build_module_initializer_routine): Pass location to\n\tc_end_compound_stmt.\n\t(objc_generate_static_init_call): Pass location to build_stmt.\n\t(build_typed_selector_reference): New location argument.\n\t(build_selector_reference): Same.\n\t(objc_substitute_decl): Pass location to build_array_ref.\n\t(next_sjlj_build_try_catch_finally): Pass location to build_stmt.\n\t(objc_begin_catch_clause): Same.\n\t(objc_finish_try_stmt): Same.\n\t(objc_finish_catch_clause): Pass location to c_end_compound_stmt.\n\t(objc_build_throw_stmt): New argument.\n\t(generate_shared_structures): Pass location to build_c_cast.\n\t(objc_build_message_expr): Use local location.\n\t(objc_finish_message_expr): Use input_location.\n\t(build_objc_method_call): New argument.\n\t(objc_build_selector_expr): Same.\n\t(get_super_receiver): Pass location to build_c_cast,\n\tbuild_modify_expr, build_compound_expr.\n\t* objc-act.c: Add location to all calls to start_struct, build_decl,\n\tfinish_struct.\ngcc/\n\t* tree-pretty-print.c (dump_generic_node): Dump column numbers.\n\t* gimple-pretty-print.c (dump_gimple_stmt): Same.\n\t* gimplify.c (gimplify_modify_expr): Set location for GIMPLE_ASSIGNs\n\tcreated.\n\t* c-parser.c (c_parser_binary_expression): Use current column while\n\tbuilding binary operations.\n\t* common.opt (fshow-column): Enable by default.\n\t* tree-vrp.c (check_array_ref): Use warning_at.\n\t(check_array_bounds): Use location from call back if expr has no\n\tlocation.\n\t* tree.h: Add location argument to maybe_fold_*.\n\t* tree-ssa-ccp.c (ccp_fold): Pass location to maybe_fold_*.\n\t(maybe_fold_offset_to_array_ref): Add location argument and use it.\n\t(maybe_fold_offset_to_component_ref): Same.\n\t(maybe_fold_offset_to_reference): Same.\n\t(maybe_fold_offset_to_address): Same.\n\t(maybe_fold_stmt_indirect): Same.\n\t(maybe_fold_stmt_addition): Same.\n\t(fold_stmt_r): Pass location to maybe_fold_*.\n\t(fold_gimple_assign): Same.\n\t* c-tree.h: Add location argument to finish_decl,\n\tdefault_function_array_conversion, store_init_value.\n\t* c-decl.c (define_label): Use error_at.\n\t(c_make_fname_decl): Pass location to finish_decl.\n\t(finish_decl): New location argument.\n\t(build_compound_literal): Pass location to store_init_value.\n\t(grokdeclarator): Pass location to finish_decl.\n\t(grokfield): Same.\n\t* c-typeck.c (array_to_pointer_conversion): New location argument.\n\t(function_to_pointer_conversion): Same.\n\t(default_function_array_conversion): Same.\n\t(parser_build_unary_op): Pass location to overflow_warning.\n\t(parser_build_binary_op): Same.  Use warning_at.\n\t(build_unary_op): Pass location to array_to_pointer_conversion.\n\t(build_c_cast): Pass location to digest_init.\n\t(build_modify_expr): New location argument.\n\t(convert_for_assignment): Same.\n\t(store_init_value): Same.\n\t(digest_init): Same.\n\t(output_init_element): Pass location to digest_init and\n\tarray_to_pointer_conversion.\n\t(c_finish_return): Pass location to convert_for_assignment.\n\t* gimplify.c (gimplify_conversion): Pass location to\n\tmaybe_fold_offset_to_address.\n\t* tree-ssa-forwprop.c (forward_propagate_addr_expr_1): Pass location\n\tto maybe_fold_stmt_addition.\n\t* c-omp.c (c_finish_omp_atomic): Pass new location to\n\tbuild_modify_expr.\n\t(c_finish_omp_for): Same.\n\t* c-common.c (overflow_warning): New argument.\n\t* c-common.h: New argument to build_modify_expr, overflow_warning.\n\t* c-parser.c (c_parser_declaration_or_fndef): Pass location to\n\tfinish_decl.\n\t(c_parser_initializer): Pass location to\n\tdefault_function_array_conversion.\n\t(c_parser_initelt): Same.\n\t(c_parser_initval): Same.\n\t(c_parser_asm_operands): Same.\n\t(c_parser_expr_no_commas): Same.  Pass location to build_modify_expr.\n\t(c_parser_conditional_expression): Same.\n\t(c_parser_binary_expression): Add location info to stack.  Use it.\n\t(c_parser_unary_expression): Pass location to\n\tdefault_function_array_conversion, parser_build_unary_op,\n\tbuild_indirect_ref, c_parser_postfix_expression_after_primary.\n\t(c_parser_postfix_expression_after_primary): New location argument.\n\tUse it.\n\t(c_parser_expression_conv): Pass location to\n\tdefault_function_array_conversion.\n\t(c_parser_expr_list): Same.\n\t(c_parser_omp_atomic): Same.\n\t(c_parser_omp_for_loop): Same.\n\t* c-tree.h: (struct c_declarator): Add comment to id_loc.\n\t(build_array_declarator): New argument.\n\t* c-decl.c (build_array_declarator): Add location argument.\n\t(grokdeclarator): Set id_loc for cdk_array.\n\t* c-parser.c (c_parser_direct_declarator_inner): Pass location to\n\tbuild_array_declarator.\n\t* tree.c (build_omp_clause): Add location argument.\n\t* tree.h (OMP_CLAUSE_HAS_LOCATION): New macro.\n\t(OMP_CLAUSE_LOCATION): New macro.\n\t(struct tree_omp_clause): Add location field.\n\t(build_omp_clause): Add argument.\n\t* testsuite/gcc.dg/gomp/for-1.c: Fix column.\n\t* cp/pt.c (tsubst_omp_for_iterator): Pass location to\n\tbuild_omp_clause.\n\t* cp/parser.c (cp_parser_omp_var_list_no_open): Same.\n\t(cp_parser_omp_clause_collapse): Same.\n\t(cp_parser_omp_clause_default): Same.\n\t(cp_parser_omp_clause_if): Same.\n\t(cp_parser_omp_clause_nowait): Same.\n\t(cp_parser_omp_clause_num_threads): Same.\n\t(cp_parser_omp_clause_ordered): Same.\n\t(cp_parser_omp_clause_schedule): Same.\n\t(cp_parser_omp_clause_untied): Same.\n\t(cp_parser_omp_for_loop): Same.\n\t(cp_parser_omp_parallel): Pass location to c_split_parallel_clauses.\n\t* c-tree.h (c_start_case): Add location argument.\n\t(c_process_expr_stmt): Same.\n\t(c_finish_goto_*): Same.\n\t* tree-parloops.c (initialize_reductions): Pass location to\n\tbuild_omp_clause.\n\t(create_parallel_loop): Same.\n\t* fortran/trans-openmp.c (gfc_trans_omp_variable_list): Same.\n\t(gfc_trans_omp_reduction_list): Same.\n\t(gfc_trans_omp_clauses): Same.\n\t(gfc_trans_omp_do): Same.\n\t* c-typeck.c (c_finish_goto_label): Same.\n\t(c_finish_goto_ptr): New location argument.\n\t(c_start_case): Same.\n\t(emit_side_effect_warnings): Same.\n\t(c_process_expr_stmt): Same.\n\t(c_finish_stmt_expr): Same.\n\t(c_finish_omp_clauses): Use error_at instead of error.\n\t* gimplify.c (gimplify_adjust_omp_clauses_1): Pass location to\n\tbuild_omp_clause.\n\t* c-omp.c (c_split_parallel_clauses): New location argument.\n\t* tree-nested.c (convert_nonlocal_reference_stmt): Pass location\n\tto build_omp_clause.\n\t(convert_local_reference_stmt): Same.\n\t(convert_gimple_call): Same.\n\t* c-common.h (c_split_parallel_clauses): New argument.\n\t* c-parser.c (c_parser_statement_after_labels): Pass location to\n\tc_finish_goto_label.\n\t(c_parser_switch_statement): Pass location to c_start_case.\n\t(c_parser_for_statement): Pass location to c_finish_expr_stmt,\n\tand c_process_expr_stmt.\n\t(c_parser_omp_variable_list): Add location argument.\n\t(c_parser_omp_clause_collapse): Pass location to\n\tbuild_omp_clause.\n\t(c_parser_omp_clause_default): Same.\n\t(c_parser_omp_clause_if): Same.\n\t(c_parser_omp_clause_num_threads): Same.\n\t(-c_parser_omp_clause_ordered): Same.\n\t(c_parser_omp_clause_reduction): Pass location to\n\tc_parser_omp_variable_list.\n\t(c_parser_omp_clause_schedule): Pass location to build_omp_clause.\n\t(c_parser_omp_clause_untied): Same.\n\t(c_parser_omp_for_loop): Pass location to c_process_expr_stmt.\n\t(c_parser_omp_parallel): Pass location to\n\tc_split_parallel_clauses.\n\t* c-tree.h (check_for_loop_decls, undeclared_variable,\n\tbuild_component_ref, build_array_ref, build_external_ref,\n\tc_expr_sizeof_expr, c_expr_sizeof_type, parser_build_unary_op,\n\tbuild_conditional_expr, build_compound_expr, c_cast_expr,\n\tbuild_c_cast, build_asm_expr, c_end_compound_stmt, c_finish_stmt_expr,\n\tc_finish_return, c_finish_omp_parallel, c_finish_omp_task): New\n\targument.\n\t* c-semantics.c (build_stmt): Same.\n\t(build_case_label): Same.\n\t* c-decl.c (c_finish_incomplete_decl): Pass location on down.\n\t(undeclared_variable): New argument.\n\t(make_label): Same.\n\t(lookup_label): Pass location on down.\n\t(define_label): Same.\n\t(finish_decl): Same.\n\t(build_compound_literal): Same.\n\t(finish_struct): Same.\n\t(finish_function): Do not set location here.\n\t(check_for_loop_decls): New argument.\n\t* tree.c (save_expr): Set location.\n\t(build_empty_stmt): New argument.\n\t* tree.h (build_empty_stmt): New argument to build_empty_stmt.\n\t(CAN_HAVE_LOCATION_P): Make sure we have a non empty node.\n\t* builtins.c (gimplify_va_arg_expr): Use locations.\n\t(expand_builtin_sync_operation): Same.\n\t* c-typeck.c (build_component_ref): New argument.\n\t(build_array_ref): Same.\n\t(build_external_ref): Same.\n\t(c_expr_sizeof_expr): Same.\n\t(c_expr_sizeof_type): Same.\n\t(parser_build_unary_op): Same.\n\t(build_conditional_expr): Same.\n\t(build_compound_expr): Pass location on down.\n\t(build_compound_expr): New argument.\n\t(build_c_cast): Same.\n\t(c_cast_expr): Same.\n\t(build_asm_expr): Same.\n\t(c_finish_return): Same.\n\t(c_process_expr_stmt): Pass location on down.\n\t(c_finish_stmt_expr): New argument.\n\t(push_clenaup): Same.\n\t(c_finish_omp_parallel): Same.\n\t(c_finish_omp_task): Same.\n\t* gimplify.c (gimplify_call_expr): Pass location on down.\n\t* c-omp.c (c_finish_omp_master): New argument.\n\t(c_finish_omp_critical): Same.\n\t(c_finish_omp_ordered): Same.\n\t(c_finish_omp_barrier): Same.\n\t(-c_finish_omp_taskwait): Same.\n\t(c_finish_omp_atomic): Same.\n\t(c_finish_omp_flush): Same.\n\t* tree-inline.c (copy_tree_body_r): Pass location on down.\n\t(inline_forbidden_p): Remove use of input_location.\n\t* c-gimplify.c (c_build_bind_expr): New argument.\n\t* c-common.c (c_common_truthvalue_conversion): Pass location on down.\n\t(c_sizeof_or_alignof_type): New argument.\n\t(c_alignof_expr): Same.\n\t(build_va_arg): Same.\n\t(c_add_case_label): Same.\n\t* c-common.h (c_sizeof_or_alignof_type, c_alignof_expr,\n\tc_sizeof, c_alignof, build_va_arg, build_stmt, build_case_label,\n\tc_build_bind_expr, objc_build_selector_expr, objc_build_throw_stmt,\n\tc_finish_omp_master, c_finish_omp_critical, c_finish_omp_ordered,\n\tc_finish_omp_barrier, c_finish_omp_atomic, c_finish_omp_flush,\n\tc_finish_omp_taskwait, c_finish_omp_for, c_split_parallel_clauses):\n\tNew argument.\n\t* stub-objc.c (objc_build_selector_expr): Same.\n\t(objc_build_throw_stmt): Same.\n\t* c-parser.c (c_parser_declaration_or_fndef): Pass location on down.\n\t(c_parser_initelt): Same.\n\t(c_parser_compound_statement): Same.\n\t(c_parser_compound_statement_nostart): Same.\n\t(c_parser_label): Same.\n\t(c_parser_statement_after_labels): Same.\n\t(c_parser_if_body): Same.\n\t(c_parser_else_body): Same.\n\t(c_parser_if_statement): Same.\n\t(c_parser_switch_statement): Same.\n\t(c_parser_while_statement): Same.\n\t(c_parser_do_statement): Same.\n\t(c_parser_for_statement): Same.\n\t(c_parser_asm_statement): Same.\n\t(c_parser_conditional_expression): Same.\n\t(c_parser_binary_expression): Same.\n\t(c_parser_cast_expression): Same.\n\t(c_parser_unary_expression): Same.\n\t(c_parser_sizeof_expression): Same.\n\t(c_parser_alignof_expression): Same.\n\t(c_parser_postfix_expression): Same.\n\t(c_parser_expression): Same.\n\t(c_parser_objc_receiver): Same.\n\t(c_parser_omp_variable_list): Same.\n\t(c_parser_omp_structured_block): Same.\n\t(c_parser_omp_atomic): New argument.\n\t(c_parser_omp_barrier): Same.\n\t(c_parser_omp_critical): Same.\n\t(c_parser_omp_flush): Pass location on down.\n\t(c_parser_omp_for_loop): New argument.\n\t(c_parser_omp_for): Same.\n\t(c_parser_omp_master): Same.\n\t(c_parser_omp_ordered): Same.\n\t(c_parser_omp_sections_scope): Same.\n\t(c_parser_omp_sections): Same.\n\t(c_parser_omp_parallel): Same.\n\t(c_parser_omp_single): Same.\n\t(c_parser_omp_task): Same.\n\t(c_parser_omp_taskwait): Pass location on down.\n\t(c_parser_omp_construct): Same.\n\t(c_parser_omp_threadprivate): Same.\n\t* dwarf2asm.c, targhooks.c, optabs.c, tree.c, tree.h, target.h,\n\tbuiltins.c, omp-low.c, cgraphunit.c, tree-call-cdce.c,\n\ttree-ssa-alias.c, gimple-low.c, c-tree.h, expr.c, tree-parloops.c,\n\tc-decl.c, tree-eh.c, langhooks.c, function.c, stor-layout.c,\n\tc-typeck.c, gimplify.c, c-pragma.c, expmed.c, except.c, coverage.c,\n\temit-rtl.c, cfgexpand.c, tree-mudflap.c, varasm.c, tree-nested.c,\n\trtl.h, tree-inline.c, tree-profile.c, c-common.c, c-common.h,\n\ttree-switch-conversion.c, tree-cfg.c, ipa-struct-reorg.c, c-parser.c,\n\tconfig/i386/i386.c, stmt.c:\n\tAdd location argument to the following function definitions and/or\n\tfunction calls: build_decl, objcp_start_struct, objcp_finish_struct,\n\tstart_struct, finish_struct, PUSH_FIELD, create_artificial_label,\n\tcp_make_fname_decl, pushtag, implicitly_declare, c_make_fname_decl,\n\tbuild_compound_literal, parser_xref_tag, resolve_overloaded_builtin,\n\tdo_case, c_finish_bc_stmt, build_compound_literal,\n\tbuild_function_call.\n\t* c-decl.c (build_compound_literal): Add location argument.\n\tMake all diagnostic calls use location.\n\t(start_struct): Same.\n\t(finish_struct): Same.\n\t(start_enum): Same.\n\t(build_enumerator): Same.\n\t(start_function): Same.\n\t(grokdeclarator): Make all diagnostic calls use location.\n\t(store_parm_decls_oldstyle): Same.\n\t* c-typeck.c (build_function_call): Add location argument.\n\tMake all diagnostic calls use location.\n\t(do_case): Same.\n\t(c_finish_bc_stmt): Same.\n\t* tree-nested.c (get_trampoline_type): Add argument.\n\tPass location to build_decl.\n\t(lookup_tramp_for_decl): Pass location to get_trampoline_type.\n\t* rtl.h (RTL_LOCATION): New.\n\t* c-common.c (c_add_case_label): Add location argument.\n\tMake all diagnostic calls use location.\n\t* c-common.h: Add location argument to make_fname_decl, do_case,\n\tc_add_case_label, build_function_call, resolve_overloaded_builtin.\n\t* c-parser.c (c_parser_enum_specifier): Rename ident_loc to enum_loc.\n\tSet it appropriately for every case.  Pass enum_loc to start_enum\n\tcall.  Pass value_loc first to build_enumerator.  Pass enum_loc to\n\tparser_xref_tag.\n\t(c_parser_struct_or_union_specifier): Save location.  Use it for\n\tstart_struct, finish_struct, and parser_xref_tag.\ngcc/testsuite/\n\t* gcc.dg/old-style-prom-3.c: Add column info.\n\t* gcc.dg/overflow-warn-1.c\n\t* gcc.dg/gomp/pr27415.c\n\t* gcc.dg/gomp/for-1.c: Same.\n\t* gcc.dg/enum-compat-1.c: Same.\n\t* gcc.dg/c99-tag-3.c: Same.\n\t* gcc.dg/Wredundant-decls-2.c: Same.\n\t* gcc.dg/func-ptr-conv-1.c: Same.\n\t* gcc.dg/asm-wide-1.c: Same.\n\t* gcc.dg/nofixed-point-2.c: Same.\n\t* gcc.dg/cpp/line3.c: Same.\n\t* gcc.dg/array-10.c: Same.\n\t* gcc.dg/c99-vla-jump-1.c: Same.\n\t* gcc.dg/pr20368-1.c: Same.\n\t* gcc.dg/Wshadow-3.c: Same.\n\t* gcc.dg/c90-const-expr-8.c: Same.\n\t* gcc.dg/label-decl-2.c: Same.\n\t* gcc.dg/dremf-type-compat-2.c: Same.\n\t* gcc.dg/c90-const-expr-5.c: Same.\n\t* gcc.dg/builtins-30.c: Same.\n\t* gcc.dg/Warray-bounds.c: Same.\n\t* gcc.dg/Wcxx-compat-2.c: Same.\n\t* gcc.dg/tree-ssa/col-1.c: Same.\n\t* gcc.dg/old-style-prom-2.c: Same.\n\t* gcc.dg/cast-function-1.c: Same.\n\t* gcc.dg/pr15698-1.c: Same.\n\t* gcc.dg/dremf-type-compat-3.c: Same.\n\t* gcc.dg/vla-8.c: Same.\n\t* gcc.dg/gomp/pr27415.c: Move firstprivate diagnostics to correct\n\tline.\n\t* gcc.dg/label-decl-2.c: Move label diagnostic to correct line.\n\t* gcc.dg/old-style-prom-3.c: Check for error on the correct line.\n\t* gcc.dg/enum-compat-1.c: Same.\n\t* gcc.dg/dremf-type-compat-2.c: Same.\n\t* gcc.dg/old-style-prom-2.c: Same.\n\t* gcc.dg/pr15698-1.c: Same.\n\t* gcc.dg/pr20368-1.c: Same.\n\t* gcc.dg/dremf-type-compat-3.c: Same.\n\t* gcc.dg/builtins-30.c: Same.  Test for columns.\ngcc/objcp/\n\t* objcp-decl.h (c_end_compound_stmt): New argument.\n\t* objcp-decl.c (objcp_start_struct): Add argument.\n\t(objcp_finish_struct): Same.\ngcc/cp/\n\t* typeck.c (cp_build_binary_op): Pass location to overflow_warning.\n\t(build_modify_expr): New arg.\n\t* semantics.c (finish_unary_op_expr): Pass location to\n\toverflow_warning.\n\t(handle_omp_for_class_iterator): Pass location to build_modify_expr.\n\t* typeck.c (cxx_sizeof_or_alignof_type): Pass location to\n\tc_sizeof_or_alignof_type.\n\t(build_array_ref): New argument.\n\t(build_compound_expr): Same.\n\t(build_const_cast): Same.\n\t(build_ptrmemfunc): Pass location to build_c_cast.\n\t* init.c (avoid_placement_new_aliasing): Pass location to\n\tbuild_stmt.\n\t(build_vec_delete_1): Pass location to cp_build_modify_expr,\n\tbuild_compound_expr.\n\t* class.c (build_vtbl_ref_1): Pass location to build_array_ref.\n\t* decl.c (poplevel): Pass location to c_build_bind_expr.\n\t(finish_case_label): Pass location to build_case_label.\n\t(finish_constructor_body): Same.\n\t(finish_destructor_body): Pass location to build_stmt.\n\t(cxx_maybe_build_cleanup): Same, but to build_compound_expr.\n\t* call.c (build_new_op): Pass location to build_array_ref.\n\t(build_x_va_arg): Pass location to build_va_arg.\n\t* except.c (expand_end_catch_block): Pass location to\n\tbuild_stmt.\n\t* cp-tree.h (build_array_ref): New argument.\n\t(build_compound_expr): Same.\n\t(build_c_cast): Same.\n\t* cp-gimplify.c (gimplify_if_stmt): Pass location on down.\n\t(gimplify_switch_stmt): Same.\n\t* typeck2.c (split_nonconstant_init_1): Same.\n\t* pt.c (tsubst_copy): Same.\n\t* semantics.c (add_decl_expr): Same.\n\t(do_poplevel): Same.\n\t(push_cleanup): Same.\n\t(finish_goto_stmt): Same.\n\t(finish_expr_stmt): Same.\n\t(begin_if_stmt): Same.\n\t(begin_while_stmt): Same.\n\t(begin_do_stmt): Same.\n\t(finish_return_stmt): Same.\n\t(begin_for_stmt): Same.\n\t(finish_break_stmt): Same.\n\t(finish_continue_stmt): Same.\n\t(begin_switch_stmt): Same.\n\t(begin_try_block): Same.\n\t(begin_handler): Same.\n\t(finish_asm_stmt): Same.\n\t(finish_label_stmt): Same.\n\t(finish_stmt_expr_expr): Same.\n\t(finalize_nrv_r): Same.\n\t(finish_omp_atomic): Same.\n\t* name-lookup.c (do_using_directive): Same.\n\t* decl2.c (grok_array_decl): Same.\n\t* parser.c (cp_parser_cast_expression): Same.\n\t(cp_parser_selection_statement): Same.\n\t(cp_parser_implicitly_scoped_statement): Same.\n\t(cp_parser_objc_selector_expression): Same.\n\t(cp_parser_objc_synchronized_statement): Same.\n\t(cp_parser_objc_throw_statement): Same.\n\t(cp_parser_omp_critical): Same.\n\t(cp_parser_omp_master): Same.\n\t* typeck.c (build_function_call): Add location argument.\n\t* init.c: Add location argument to all build_decl calls.\n\t* class.c: Same.\n\t* method.c: Same.\n\t* rtti.c: Same.\n\t* tree.c: Same.\n\t* pt.c: Same.\n\t* semantics.c: Same.\n\t* lex.c: Same.\n\t* decl2.c: Same.\n\t* cp-gimplify.c: Same.\n\t* decl.c: Same.\n\t(cp_make_fname_decl): Add location argument.  Pass location ot\n\tbuild_decl.\n\t(finish_case_label): Same.\n\t* cp-tree.h (finish_case_label): Add location argument.\n\t* parser.c (cp_parser_label_for_labeled_statement): Pass location to\n\tfinish_case_label.\ngcc/fortran/\n\t* trans-array.c (gfc_trans_allocate_array_storage): Pass\n\tlocation on down.\n\t(gfc_trans_array_constructor_value): Same.\n\t(gfc_trans_scalarized_loop_end): Same.\n\t(gfc_conv_ss_startstride): Same.\n\t(gfc_trans_g77_array): Same.\n\t(gfc_trans_dummy_array_bias): Same.\n\t(gfc_conv_array_parameter): Same.\n\t(structure_alloc_comps): Same.\n\t* trans-expr.c (gfc_conv_function_call): Same.\n\t(fill_with_spaces): Same.\n\t(gfc_trans_string_copy): Same.\n\t(gfc_trans_scalar_assign): Same.\n\t* trans-stmt.c (gfc_trans_goto): Same.\n\t(gfc_trans_if_1): Same.\n\t(gfc_trans_simple_do): Same.\n\t(gfc_trans_do): Same.\n\t(gfc_trans_do_while): Same.\n\t(gfc_trans_logical_select): Same.\n\t(gfc_trans_select): Same.\n\t(gfc_trans_forall_loop): Same.\n\t(gfc_trans_nested_forall_loop): Same.\n\t(generate_loop_for_temp_to_lhs): Same.\n\t(generate_loop_for_rhs_to_temp): Same.\n\t(gfc_trans_forall_1): Same.\n\t(gfc_trans_where_assign): Same.\n\t(gfc_trans_where_3): Same.\n\t(gfc_trans_allocate): Same.\n\t* trans.c (gfc_finish_block): Same.\n\t(gfc_trans_runtime_check): Same.\n\t(gfc_call_malloc): Same.\n\t(gfc_allocate_with_status): Same.\n\t(gfc_call_free): Same.\n\t(gfc_deallocate_with_status): Same.\n\t(gfc_call_realloc): Same.\n\t(gfc_trans_code): Same.\n\t* trans-decl.c (gfc_init_default_dt): Same.\n\t(gfc_generate_constructors): Same.\n\t* trans-io.c (gfc_trans_io_runtime_check): Same.\n\t* trans-intrinsic.c (gfc_conv_intrinsic_ctime): Same.\n\t(gfc_conv_intrinsic_fdate): Same.\n\t(gfc_conv_intrinsic_ttynam): Same.\n\t(gfc_conv_intrinsic_minmax): Same.\n\t(gfc_conv_intrinsic_minmax_char): Same.\n\t(gfc_conv_intrinsic_anyall): Same.\n\t(gfc_conv_intrinsic_count): Same.\n\t(gfc_conv_intrinsic_arith): Same.\n\t(gfc_conv_intrinsic_minmaxloc): Same.\n\t(gfc_conv_intrinsic_minmaxval): Same.\n\t(gfc_conv_intrinsic_rrspacing): Same.\n\t(gfc_conv_intrinsic_array_transfer): Same.\n\t(gfc_conv_intrinsic_trim): Same.\n\t(gfc_conv_intrinsic_repeat): Same.\n\nFrom-SVN: r148442", "tree": {"sha": "67f495ddc3964a90084152e177995da72e7bce30", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/67f495ddc3964a90084152e177995da72e7bce30"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c2255bc4884a7624b32185e188fdb94a4167a35c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2255bc4884a7624b32185e188fdb94a4167a35c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2255bc4884a7624b32185e188fdb94a4167a35c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2255bc4884a7624b32185e188fdb94a4167a35c/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "312243969e3a0022c0eabe6f974c24abd4a2211b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/312243969e3a0022c0eabe6f974c24abd4a2211b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/312243969e3a0022c0eabe6f974c24abd4a2211b"}], "stats": {"total": 5425, "additions": 3455, "deletions": 1970}, "files": [{"sha": "d1c91f4b8e8a9c334a10afb203ea44b0db7db15d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 296, "deletions": 0, "changes": 296, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -1,3 +1,299 @@\n+2009-06-12  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* tree-pretty-print.c (dump_generic_node): Dump column numbers.\n+\t* gimple-pretty-print.c (dump_gimple_stmt): Same.\n+\t* gimplify.c (gimplify_modify_expr): Set location for GIMPLE_ASSIGNs\n+\tcreated.\n+\t* c-parser.c (c_parser_binary_expression): Use current column while\n+\tbuilding binary operations.\n+\t* common.opt (fshow-column): Enable by default.\n+\t* tree-vrp.c (check_array_ref): Use warning_at.\n+\t(check_array_bounds): Use location from call back if expr has no\n+\tlocation.\n+\t* tree.h: Add location argument to maybe_fold_*.\n+\t* tree-ssa-ccp.c (ccp_fold): Pass location to maybe_fold_*.\n+\t(maybe_fold_offset_to_array_ref): Add location argument and use it.\n+\t(maybe_fold_offset_to_component_ref): Same.\n+\t(maybe_fold_offset_to_reference): Same.\n+\t(maybe_fold_offset_to_address): Same.\n+\t(maybe_fold_stmt_indirect): Same.\n+\t(maybe_fold_stmt_addition): Same.\n+\t(fold_stmt_r): Pass location to maybe_fold_*.\n+\t(fold_gimple_assign): Same.\n+\t* c-tree.h: Add location argument to finish_decl,\n+\tdefault_function_array_conversion, store_init_value.\n+\t* c-decl.c (define_label): Use error_at.\n+\t(c_make_fname_decl): Pass location to finish_decl.\n+\t(finish_decl): New location argument.\n+\t(build_compound_literal): Pass location to store_init_value.\n+\t(grokdeclarator): Pass location to finish_decl.\n+\t(grokfield): Same.\n+\t* c-typeck.c (array_to_pointer_conversion): New location argument.\n+\t(function_to_pointer_conversion): Same.\n+\t(default_function_array_conversion): Same.\n+\t(parser_build_unary_op): Pass location to overflow_warning.\n+\t(parser_build_binary_op): Same.  Use warning_at.\n+\t(build_unary_op): Pass location to array_to_pointer_conversion.\n+\t(build_c_cast): Pass location to digest_init.\n+\t(build_modify_expr): New location argument.\n+\t(convert_for_assignment): Same.\n+\t(store_init_value): Same.\n+\t(digest_init): Same.\n+\t(output_init_element): Pass location to digest_init and\n+\tarray_to_pointer_conversion.\n+\t(c_finish_return): Pass location to convert_for_assignment.\n+\t* gimplify.c (gimplify_conversion): Pass location to\n+\tmaybe_fold_offset_to_address.\n+\t* tree-ssa-forwprop.c (forward_propagate_addr_expr_1): Pass location\n+\tto maybe_fold_stmt_addition.\n+\t* c-omp.c (c_finish_omp_atomic): Pass new location to\n+\tbuild_modify_expr.\n+\t(c_finish_omp_for): Same.\n+\t* c-common.c (overflow_warning): New argument.\n+\t* c-common.h: New argument to build_modify_expr, overflow_warning.\n+\t* c-parser.c (c_parser_declaration_or_fndef): Pass location to\n+\tfinish_decl.\n+\t(c_parser_initializer): Pass location to\n+\tdefault_function_array_conversion.\n+\t(c_parser_initelt): Same.\n+\t(c_parser_initval): Same.\n+\t(c_parser_asm_operands): Same.\n+\t(c_parser_expr_no_commas): Same.  Pass location to build_modify_expr.\n+\t(c_parser_conditional_expression): Same.\n+\t(c_parser_binary_expression): Add location info to stack.  Use it.\n+\t(c_parser_unary_expression): Pass location to\n+\tdefault_function_array_conversion, parser_build_unary_op,\n+\tbuild_indirect_ref, c_parser_postfix_expression_after_primary.\n+\t(c_parser_postfix_expression_after_primary): New location argument.\n+\tUse it.\n+\t(c_parser_expression_conv): Pass location to\n+\tdefault_function_array_conversion.\n+\t(c_parser_expr_list): Same.\n+\t(c_parser_omp_atomic): Same.\n+\t(c_parser_omp_for_loop): Same.\n+\t* c-tree.h: (struct c_declarator): Add comment to id_loc.\n+\t(build_array_declarator): New argument.\n+\t* c-decl.c (build_array_declarator): Add location argument.\n+\t(grokdeclarator): Set id_loc for cdk_array.\n+\t* c-parser.c (c_parser_direct_declarator_inner): Pass location to\n+\tbuild_array_declarator.\n+\t* tree.c (build_omp_clause): Add location argument.\n+\t* tree.h (OMP_CLAUSE_HAS_LOCATION): New macro.\n+\t(OMP_CLAUSE_LOCATION): New macro.\n+\t(struct tree_omp_clause): Add location field.\n+\t(build_omp_clause): Add argument.\n+\t* testsuite/gcc.dg/gomp/for-1.c: Fix column.\n+\t* cp/pt.c (tsubst_omp_for_iterator): Pass location to\n+\tbuild_omp_clause.\n+\t* cp/parser.c (cp_parser_omp_var_list_no_open): Same.\n+\t(cp_parser_omp_clause_collapse): Same.\n+\t(cp_parser_omp_clause_default): Same.\n+\t(cp_parser_omp_clause_if): Same.\n+\t(cp_parser_omp_clause_nowait): Same.\n+\t(cp_parser_omp_clause_num_threads): Same.\n+\t(cp_parser_omp_clause_ordered): Same.\n+\t(cp_parser_omp_clause_schedule): Same.\n+\t(cp_parser_omp_clause_untied): Same.\n+\t(cp_parser_omp_for_loop): Same.\n+\t(cp_parser_omp_parallel): Pass location to c_split_parallel_clauses.\n+\t* c-tree.h (c_start_case): Add location argument.\n+\t(c_process_expr_stmt): Same.\n+\t(c_finish_goto_*): Same.\n+\t* tree-parloops.c (initialize_reductions): Pass location to\n+\tbuild_omp_clause.\n+\t(create_parallel_loop): Same.\n+\t* fortran/trans-openmp.c (gfc_trans_omp_variable_list): Same.\n+\t(gfc_trans_omp_reduction_list): Same.\n+\t(gfc_trans_omp_clauses): Same.\n+\t(gfc_trans_omp_do): Same.\n+\t* c-typeck.c (c_finish_goto_label): Same.\n+\t(c_finish_goto_ptr): New location argument.\n+\t(c_start_case): Same.\n+\t(emit_side_effect_warnings): Same.\n+\t(c_process_expr_stmt): Same.\n+\t(c_finish_stmt_expr): Same.\n+\t(c_finish_omp_clauses): Use error_at instead of error.\n+\t* gimplify.c (gimplify_adjust_omp_clauses_1): Pass location to\n+\tbuild_omp_clause.\n+\t* c-omp.c (c_split_parallel_clauses): New location argument.\n+\t* tree-nested.c (convert_nonlocal_reference_stmt): Pass location\n+\tto build_omp_clause.\n+\t(convert_local_reference_stmt): Same.\n+\t(convert_gimple_call): Same.\n+\t* c-common.h (c_split_parallel_clauses): New argument.\n+\t* c-parser.c (c_parser_statement_after_labels): Pass location to\n+\tc_finish_goto_label.\n+\t(c_parser_switch_statement): Pass location to c_start_case.\n+\t(c_parser_for_statement): Pass location to c_finish_expr_stmt,\n+\tand c_process_expr_stmt.\n+\t(c_parser_omp_variable_list): Add location argument.\n+\t(c_parser_omp_clause_collapse): Pass location to\n+\tbuild_omp_clause.\n+\t(c_parser_omp_clause_default): Same.\n+\t(c_parser_omp_clause_if): Same.\n+\t(c_parser_omp_clause_num_threads): Same.\n+\t(-c_parser_omp_clause_ordered): Same.\n+\t(c_parser_omp_clause_reduction): Pass location to\n+\tc_parser_omp_variable_list.\n+\t(c_parser_omp_clause_schedule): Pass location to build_omp_clause.\n+\t(c_parser_omp_clause_untied): Same.\n+\t(c_parser_omp_for_loop): Pass location to c_process_expr_stmt.\n+\t(c_parser_omp_parallel): Pass location to\n+\tc_split_parallel_clauses.\n+\n+\t* c-tree.h (check_for_loop_decls, undeclared_variable,\n+\tbuild_component_ref, build_array_ref, build_external_ref,\n+\tc_expr_sizeof_expr, c_expr_sizeof_type, parser_build_unary_op,\n+\tbuild_conditional_expr, build_compound_expr, c_cast_expr,\n+\tbuild_c_cast, build_asm_expr, c_end_compound_stmt, c_finish_stmt_expr,\n+\tc_finish_return, c_finish_omp_parallel, c_finish_omp_task): New\n+\targument.\n+\t* c-semantics.c (build_stmt): Same.\n+\t(build_case_label): Same.\n+\t* c-decl.c (c_finish_incomplete_decl): Pass location on down.\n+\t(undeclared_variable): New argument.\n+\t(make_label): Same.\n+\t(lookup_label): Pass location on down.\n+\t(define_label): Same.\n+\t(finish_decl): Same.\n+\t(build_compound_literal): Same.\n+\t(finish_struct): Same.\n+\t(finish_function): Do not set location here.\n+\t(check_for_loop_decls): New argument.\n+\t* tree.c (save_expr): Set location.\n+\t(build_empty_stmt): New argument.\n+\t* tree.h (build_empty_stmt): New argument to build_empty_stmt.\n+\t(CAN_HAVE_LOCATION_P): Make sure we have a non empty node.\n+\t* builtins.c (gimplify_va_arg_expr): Use locations.\n+\t(expand_builtin_sync_operation): Same.\n+\t* c-typeck.c (build_component_ref): New argument.\n+\t(build_array_ref): Same.\n+\t(build_external_ref): Same.\n+\t(c_expr_sizeof_expr): Same.\n+\t(c_expr_sizeof_type): Same.\n+\t(parser_build_unary_op): Same.\n+\t(build_conditional_expr): Same.\n+\t(build_compound_expr): Pass location on down.\n+\t(build_compound_expr): New argument.\n+\t(build_c_cast): Same.\n+\t(c_cast_expr): Same.\n+\t(build_asm_expr): Same.\n+\t(c_finish_return): Same.\n+\t(c_process_expr_stmt): Pass location on down.\n+\t(c_finish_stmt_expr): New argument.\n+\t(push_clenaup): Same.\n+\t(c_finish_omp_parallel): Same.\n+\t(c_finish_omp_task): Same.\n+\t* gimplify.c (gimplify_call_expr): Pass location on down.\n+\t* c-omp.c (c_finish_omp_master): New argument.\n+\t(c_finish_omp_critical): Same.\n+\t(c_finish_omp_ordered): Same.\n+\t(c_finish_omp_barrier): Same.\n+\t(-c_finish_omp_taskwait): Same.\n+\t(c_finish_omp_atomic): Same.\n+\t(c_finish_omp_flush): Same.\n+\t* tree-inline.c (copy_tree_body_r): Pass location on down.\n+\t(inline_forbidden_p): Remove use of input_location.\n+\t* c-gimplify.c (c_build_bind_expr): New argument.\n+\t* c-common.c (c_common_truthvalue_conversion): Pass location on down.\n+\t(c_sizeof_or_alignof_type): New argument.\n+\t(c_alignof_expr): Same.\n+\t(build_va_arg): Same.\n+\t(c_add_case_label): Same.\n+\t* c-common.h (c_sizeof_or_alignof_type, c_alignof_expr,\n+\tc_sizeof, c_alignof, build_va_arg, build_stmt, build_case_label,\n+\tc_build_bind_expr, objc_build_selector_expr, objc_build_throw_stmt,\n+\tc_finish_omp_master, c_finish_omp_critical, c_finish_omp_ordered,\n+\tc_finish_omp_barrier, c_finish_omp_atomic, c_finish_omp_flush,\n+\tc_finish_omp_taskwait, c_finish_omp_for, c_split_parallel_clauses):\n+\tNew argument.\n+\t* stub-objc.c (objc_build_selector_expr): Same.\n+\t(objc_build_throw_stmt): Same.\n+\t* c-parser.c (c_parser_declaration_or_fndef): Pass location on down.\n+\t(c_parser_initelt): Same.\n+\t(c_parser_compound_statement): Same.\n+\t(c_parser_compound_statement_nostart): Same.\n+\t(c_parser_label): Same.\n+\t(c_parser_statement_after_labels): Same.\n+\t(c_parser_if_body): Same.\n+\t(c_parser_else_body): Same.\n+\t(c_parser_if_statement): Same.\n+\t(c_parser_switch_statement): Same.\n+\t(c_parser_while_statement): Same.\n+\t(c_parser_do_statement): Same.\n+\t(c_parser_for_statement): Same.\n+\t(c_parser_asm_statement): Same.\n+\t(c_parser_conditional_expression): Same.\n+\t(c_parser_binary_expression): Same.\n+\t(c_parser_cast_expression): Same.\n+\t(c_parser_unary_expression): Same.\n+\t(c_parser_sizeof_expression): Same.\n+\t(c_parser_alignof_expression): Same.\n+\t(c_parser_postfix_expression): Same.\n+\t(c_parser_expression): Same.\n+\t(c_parser_objc_receiver): Same.\n+\t(c_parser_omp_variable_list): Same.\n+\t(c_parser_omp_structured_block): Same.\n+\t(c_parser_omp_atomic): New argument.\n+\t(c_parser_omp_barrier): Same.\n+\t(c_parser_omp_critical): Same.\n+\t(c_parser_omp_flush): Pass location on down.\n+\t(c_parser_omp_for_loop): New argument.\n+\t(c_parser_omp_for): Same.\n+\t(c_parser_omp_master): Same.\n+\t(c_parser_omp_ordered): Same.\n+\t(c_parser_omp_sections_scope): Same.\n+\t(c_parser_omp_sections): Same.\n+\t(c_parser_omp_parallel): Same.\n+\t(c_parser_omp_single): Same.\n+\t(c_parser_omp_task): Same.\n+\t(c_parser_omp_taskwait): Pass location on down.\n+\t(c_parser_omp_construct): Same.\n+\t(c_parser_omp_threadprivate): Same.\n+\t* dwarf2asm.c, targhooks.c, optabs.c, tree.c, tree.h, target.h,\n+\tbuiltins.c, omp-low.c, cgraphunit.c, tree-call-cdce.c,\n+\ttree-ssa-alias.c, gimple-low.c, c-tree.h, expr.c, tree-parloops.c,\n+\tc-decl.c, tree-eh.c, langhooks.c, function.c, stor-layout.c,\n+\tc-typeck.c, gimplify.c, c-pragma.c, expmed.c, except.c, coverage.c,\n+\temit-rtl.c, cfgexpand.c, tree-mudflap.c, varasm.c, tree-nested.c,\n+\trtl.h, tree-inline.c, tree-profile.c, c-common.c, c-common.h,\n+\ttree-switch-conversion.c, tree-cfg.c, ipa-struct-reorg.c, c-parser.c,\n+\tconfig/i386/i386.c, stmt.c:\n+\tAdd location argument to the following function definitions and/or\n+\tfunction calls: build_decl, objcp_start_struct, objcp_finish_struct,\n+\tstart_struct, finish_struct, PUSH_FIELD, create_artificial_label,\n+\tcp_make_fname_decl, pushtag, implicitly_declare, c_make_fname_decl,\n+\tbuild_compound_literal, parser_xref_tag, resolve_overloaded_builtin,\n+\tdo_case, c_finish_bc_stmt, build_compound_literal,\n+\tbuild_function_call.\n+\t* c-decl.c (build_compound_literal): Add location argument.\n+\tMake all diagnostic calls use location.\n+\t(start_struct): Same.\n+\t(finish_struct): Same.\n+\t(start_enum): Same.\n+\t(build_enumerator): Same.\n+\t(start_function): Same.\n+\t(grokdeclarator): Make all diagnostic calls use location.\n+\t(store_parm_decls_oldstyle): Same.\n+\t* c-typeck.c (build_function_call): Add location argument.\n+\tMake all diagnostic calls use location.\n+\t(do_case): Same.\n+\t(c_finish_bc_stmt): Same.\n+\t* tree-nested.c (get_trampoline_type): Add argument.\n+\tPass location to build_decl.\n+\t(lookup_tramp_for_decl): Pass location to get_trampoline_type.\n+\t* rtl.h (RTL_LOCATION): New.\n+\t* c-common.c (c_add_case_label): Add location argument.\n+\tMake all diagnostic calls use location.\n+\t* c-common.h: Add location argument to make_fname_decl, do_case,\n+\tc_add_case_label, build_function_call, resolve_overloaded_builtin.\n+\t* c-parser.c (c_parser_enum_specifier): Rename ident_loc to enum_loc.\n+\tSet it appropriately for every case.  Pass enum_loc to start_enum\n+\tcall.  Pass value_loc first to build_enumerator.  Pass enum_loc to\n+\tparser_xref_tag.\n+\t(c_parser_struct_or_union_specifier): Save location.  Use it for\n+\tstart_struct, finish_struct, and parser_xref_tag.\n+\n 2009-06-12  Ian Lance Taylor  <iant@google.com>\n \n \t* fold-const.c (fold_unary): Rename local variable and to"}, {"sha": "a6d26efa7767c9eced1282aabf639d4f25188b0d", "filename": "gcc/builtins.c", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -4975,6 +4975,8 @@ gimplify_va_arg_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n   tree valist = TREE_OPERAND (*expr_p, 0);\n   tree type = TREE_TYPE (*expr_p);\n   tree t;\n+  location_t loc = EXPR_HAS_LOCATION (*expr_p) ? EXPR_LOCATION (*expr_p) :\n+    UNKNOWN_LOCATION;\n \n   /* Verify that valist is of the proper type.  */\n   have_va_type = TREE_TYPE (valist);\n@@ -4984,7 +4986,7 @@ gimplify_va_arg_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n \n   if (have_va_type == NULL_TREE)\n     {\n-      error (\"first argument to %<va_arg%> not of type %<va_list%>\");\n+      error_at (loc, \"first argument to %<va_arg%> not of type %<va_list%>\");\n       return GS_ERROR;\n     }\n \n@@ -4999,19 +5001,20 @@ gimplify_va_arg_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n       /* Unfortunately, this is merely undefined, rather than a constraint\n \t violation, so we cannot make this an error.  If this call is never\n \t executed, the program is still strictly conforming.  */\n-      warned = warning (0, \"%qT is promoted to %qT when passed through %<...%>\",\n-\t\t\ttype, promoted_type);\n+      warned = warning_at (loc, 0,\n+\t  \t\t   \"%qT is promoted to %qT when passed through %<...%>\",\n+\t\t\t   type, promoted_type);\n       if (!gave_help && warned)\n \t{\n \t  gave_help = true;\n-\t  inform (input_location, \"(so you should pass %qT not %qT to %<va_arg%>)\",\n-\t\t   promoted_type, type);\n+\t  inform (loc, \"(so you should pass %qT not %qT to %<va_arg%>)\",\n+\t\t  promoted_type, type);\n \t}\n \n       /* We can, however, treat \"undefined\" any way we please.\n \t Call abort to encourage the user to fix the program.  */\n       if (warned)\n-\tinform (input_location, \"if this code is reached, the program will abort\");\n+\tinform (loc, \"if this code is reached, the program will abort\");\n       /* Before the abort, allow the evaluation of the va_list\n \t expression to exit or longjmp.  */\n       gimplify_and_add (valist, pre_p);\n@@ -5984,7 +5987,8 @@ expand_builtin_fork_or_exec (tree fn, tree exp, rtx target, int ignore)\n       gcc_unreachable ();\n     }\n \n-  decl = build_decl (FUNCTION_DECL, id, TREE_TYPE (fn));\n+  decl = build_decl (DECL_SOURCE_LOCATION (fn),\n+\t\t     FUNCTION_DECL, id, TREE_TYPE (fn));\n   DECL_EXTERNAL (decl) = 1;\n   TREE_PUBLIC (decl) = 1;\n   DECL_ARTIFICIAL (decl) = 1;\n@@ -6050,6 +6054,7 @@ expand_builtin_sync_operation (enum machine_mode mode, tree exp,\n {\n   rtx val, mem;\n   enum machine_mode old_mode;\n+  location_t loc = EXPR_LOCATION (exp);\n \n   if (code == NOT && warn_sync_nand)\n     {\n@@ -6070,8 +6075,7 @@ expand_builtin_sync_operation (enum machine_mode mode, tree exp,\n \t    break;\n \n \t  fndecl = implicit_built_in_decls[BUILT_IN_FETCH_AND_NAND_N];\n-\t  inform (input_location,\n-\t\t  \"%qD changed semantics in GCC 4.4\", fndecl);\n+\t  inform (loc, \"%qD changed semantics in GCC 4.4\", fndecl);\n \t  warned_f_a_n = true;\n \t  break;\n \n@@ -6085,8 +6089,7 @@ expand_builtin_sync_operation (enum machine_mode mode, tree exp,\n \t    break;\n \n \t  fndecl = implicit_built_in_decls[BUILT_IN_NAND_AND_FETCH_N];\n-\t  inform (input_location,\n-\t\t  \"%qD changed semantics in GCC 4.4\", fndecl);\n+\t  inform (loc, \"%qD changed semantics in GCC 4.4\", fndecl);\n \t  warned_n_a_f = true;\n \t  break;\n "}, {"sha": "139a5d2346f45a36d3e13a35230a79bc5c115caa", "filename": "gcc/c-common.c", "status": "modified", "additions": 155, "deletions": 102, "changes": 257, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -440,7 +440,7 @@ int max_tinst_depth = 500;\n    type names and storage classes.  It is indexed by a RID_... value.  */\n tree *ridpointers;\n \n-tree (*make_fname_decl) (tree, int);\n+tree (*make_fname_decl) (location_t, tree, int);\n \n /* Nonzero means the expression being parsed will never be evaluated.\n    This is a count, since unevaluated expressions can nest.  */\n@@ -971,7 +971,7 @@ fname_decl (location_t loc, unsigned int rid, tree id)\n       input_location = UNKNOWN_LOCATION;\n \n       stmts = push_stmt_list ();\n-      decl = (*make_fname_decl) (id, fname_vars[ix].pretty);\n+      decl = (*make_fname_decl) (loc, id, fname_vars[ix].pretty);\n       stmts = pop_stmt_list (stmts);\n       if (!IS_EMPTY_STMT (stmts))\n \tsaved_function_name_decls\n@@ -1505,33 +1505,36 @@ constant_expression_error (tree value)\n    already overflowed.  */\n \n void\n-overflow_warning (tree value)\n+overflow_warning (location_t loc, tree value)\n {\n   if (skip_evaluation) return;\n \n   switch (TREE_CODE (value))\n     {\n     case INTEGER_CST:\n-      warning (OPT_Woverflow, \"integer overflow in expression\");\n+      warning_at (loc, OPT_Woverflow, \"integer overflow in expression\");\n       break;\n       \n     case REAL_CST:\n-      warning (OPT_Woverflow, \"floating point overflow in expression\");\n+      warning_at (loc, OPT_Woverflow,\n+\t\t  \"floating point overflow in expression\");\n       break;\n       \n     case FIXED_CST:\n-      warning (OPT_Woverflow, \"fixed-point overflow in expression\");\n+      warning_at (loc, OPT_Woverflow, \"fixed-point overflow in expression\");\n       break;\n \n     case VECTOR_CST:\n-      warning (OPT_Woverflow, \"vector overflow in expression\");\n+      warning_at (loc, OPT_Woverflow, \"vector overflow in expression\");\n       break;\n       \n     case COMPLEX_CST:\n       if (TREE_CODE (TREE_REALPART (value)) == INTEGER_CST)\n-\twarning (OPT_Woverflow, \"complex integer overflow in expression\");\n+\twarning_at (loc, OPT_Woverflow,\n+\t\t    \"complex integer overflow in expression\");\n       else if (TREE_CODE (TREE_REALPART (value)) == REAL_CST)\n-\twarning (OPT_Woverflow, \"complex floating point overflow in expression\");\n+\twarning_at (loc, OPT_Woverflow,\n+\t\t    \"complex floating point overflow in expression\");\n       break;\n \n     default:\n@@ -3224,7 +3227,8 @@ c_register_builtin_type (tree type, const char* name)\n {\n   tree decl;\n \n-  decl = build_decl (TYPE_DECL, get_identifier (name), type);\n+  decl = build_decl (UNKNOWN_LOCATION,\n+\t\t     TYPE_DECL, get_identifier (name), type);\n   DECL_ARTIFICIAL (decl) = 1;\n   if (!TYPE_NAME (type))\n     TYPE_NAME (type) = decl;\n@@ -3799,8 +3803,9 @@ c_common_truthvalue_conversion (location_t location, tree expr)\n     case ORDERED_EXPR: case UNORDERED_EXPR:\n       if (TREE_TYPE (expr) == truthvalue_type_node)\n \treturn expr;\n-      return build2 (TREE_CODE (expr), truthvalue_type_node,\n+      expr = build2 (TREE_CODE (expr), truthvalue_type_node,\n \t\t     TREE_OPERAND (expr, 0), TREE_OPERAND (expr, 1));\n+      goto ret;\n \n     case TRUTH_ANDIF_EXPR:\n     case TRUTH_ORIF_EXPR:\n@@ -3809,18 +3814,20 @@ c_common_truthvalue_conversion (location_t location, tree expr)\n     case TRUTH_XOR_EXPR:\n       if (TREE_TYPE (expr) == truthvalue_type_node)\n \treturn expr;\n-      return build2 (TREE_CODE (expr), truthvalue_type_node,\n-\t\t c_common_truthvalue_conversion (location, \n-\t\t\t\t\t\t TREE_OPERAND (expr, 0)),\n-\t\t c_common_truthvalue_conversion (location,\n-\t\t\t\t\t\t TREE_OPERAND (expr, 1)));\n+      expr = build2 (TREE_CODE (expr), truthvalue_type_node,\n+\t\t     c_common_truthvalue_conversion (location, \n+\t\t\t\t\t\t     TREE_OPERAND (expr, 0)),\n+\t\t     c_common_truthvalue_conversion (location,\n+\t\t\t\t\t\t     TREE_OPERAND (expr, 1)));\n+      goto ret;\n \n     case TRUTH_NOT_EXPR:\n       if (TREE_TYPE (expr) == truthvalue_type_node)\n \treturn expr;\n-      return build1 (TREE_CODE (expr), truthvalue_type_node,\n-\t\t c_common_truthvalue_conversion (location,\n-\t\t\t\t\t\t TREE_OPERAND (expr, 0)));\n+      expr = build1 (TREE_CODE (expr), truthvalue_type_node,\n+\t\t     c_common_truthvalue_conversion (location,\n+\t\t\t\t\t\t     TREE_OPERAND (expr, 0)));\n+      goto ret;\n \n     case ERROR_MARK:\n       return expr;\n@@ -3866,21 +3873,25 @@ c_common_truthvalue_conversion (location_t location, tree expr)\n \t  }\n \n \tif (TREE_SIDE_EFFECTS (inner))\n-\t  return build2 (COMPOUND_EXPR, truthvalue_type_node,\n-\t\t\t inner, truthvalue_true_node);\n+\t  {\n+\t    expr = build2 (COMPOUND_EXPR, truthvalue_type_node,\n+\t\t\t   inner, truthvalue_true_node);\n+\t    goto ret;\n+\t  }\n \telse\n \t  return truthvalue_true_node;\n       }\n \n     case COMPLEX_EXPR:\n-      return build_binary_op (EXPR_LOCATION (expr),\n+      expr = build_binary_op (EXPR_LOCATION (expr),\n \t\t\t      (TREE_SIDE_EFFECTS (TREE_OPERAND (expr, 1))\n \t\t\t       ? TRUTH_OR_EXPR : TRUTH_ORIF_EXPR),\n \t\tc_common_truthvalue_conversion (location,\n \t\t\t\t\t\tTREE_OPERAND (expr, 0)),\n \t\tc_common_truthvalue_conversion (location,\n \t\t\t\t\t\tTREE_OPERAND (expr, 1)),\n \t\t\t      0);\n+      goto ret;\n \n     case NEGATE_EXPR:\n     case ABS_EXPR:\n@@ -3894,33 +3905,42 @@ c_common_truthvalue_conversion (location_t location, tree expr)\n       /* These don't change whether an object is zero or nonzero, but\n \t we can't ignore them if their second arg has side-effects.  */\n       if (TREE_SIDE_EFFECTS (TREE_OPERAND (expr, 1)))\n-\treturn build2 (COMPOUND_EXPR, truthvalue_type_node,\n-\t\t       TREE_OPERAND (expr, 1),\n-\t\t       c_common_truthvalue_conversion \n-\t\t        (location, TREE_OPERAND (expr, 0)));\n+\t{\n+\t  expr = build2 (COMPOUND_EXPR, truthvalue_type_node,\n+\t\t\t TREE_OPERAND (expr, 1),\n+\t\t\t c_common_truthvalue_conversion \n+\t\t\t (location, TREE_OPERAND (expr, 0)));\n+\t  goto ret;\n+\t}\n       else\n \treturn c_common_truthvalue_conversion (location,\n \t\t\t\t\t       TREE_OPERAND (expr, 0));\n \n     case COND_EXPR:\n       /* Distribute the conversion into the arms of a COND_EXPR.  */\n       if (c_dialect_cxx ())\n-\treturn fold_build3 (COND_EXPR, truthvalue_type_node,\n-\t\t\t    TREE_OPERAND (expr, 0),\n-\t\t\t    c_common_truthvalue_conversion (location,\n-\t\t\t\t\t\t\t    TREE_OPERAND (expr,\n-\t\t\t\t\t\t\t\t\t  1)),\n-\t\t\t    c_common_truthvalue_conversion (location,\n-\t\t\t\t\t\t\t    TREE_OPERAND (expr,\n-\t\t\t\t\t\t\t\t\t  2)));\n+\t{\n+\t  expr = fold_build3 (COND_EXPR, truthvalue_type_node,\n+\t\t\t      TREE_OPERAND (expr, 0),\n+\t\t\t      c_common_truthvalue_conversion (location,\n+\t\t\t\t\t\t\t      TREE_OPERAND (expr,\n+\t\t\t\t\t\t\t\t\t    1)),\n+\t\t\t      c_common_truthvalue_conversion (location,\n+\t\t\t\t\t\t\t      TREE_OPERAND (expr,\n+\t\t\t\t\t\t\t\t\t    2)));\n+\t  goto ret;\n+\t}\n       else\n-\t/* Folding will happen later for C.  */\n-\treturn build3 (COND_EXPR, truthvalue_type_node,\n-\t\t       TREE_OPERAND (expr, 0),\n-\t\t       c_common_truthvalue_conversion (location,\n-\t\t\t\t\t\t       TREE_OPERAND (expr, 1)),\n-\t\t       c_common_truthvalue_conversion (location,\n-\t\t\t\t\t\t       TREE_OPERAND (expr, 2)));\n+\t{\n+\t  /* Folding will happen later for C.  */\n+\t  expr = build3 (COND_EXPR, truthvalue_type_node,\n+\t\t\t TREE_OPERAND (expr, 0),\n+\t\t\t c_common_truthvalue_conversion (location,\n+\t\t\t\t\t\t\t TREE_OPERAND (expr, 1)),\n+\t\t\t c_common_truthvalue_conversion (location,\n+\t\t\t\t\t\t\t TREE_OPERAND (expr, 2)));\n+\t  goto ret;\n+\t}\n \n     CASE_CONVERT:\n       /* Don't cancel the effect of a CONVERT_EXPR from a REFERENCE_TYPE,\n@@ -3952,7 +3972,7 @@ c_common_truthvalue_conversion (location_t location, tree expr)\n   if (TREE_CODE (TREE_TYPE (expr)) == COMPLEX_TYPE)\n     {\n       tree t = c_save_expr (expr);\n-      return (build_binary_op\n+      expr = (build_binary_op\n \t      (EXPR_LOCATION (expr),\n \t       (TREE_SIDE_EFFECTS (expr)\n \t\t? TRUTH_OR_EXPR : TRUTH_ORIF_EXPR),\n@@ -3963,6 +3983,7 @@ c_common_truthvalue_conversion (location_t location, tree expr)\n \t       (location,\n \t\tbuild_unary_op (location, IMAGPART_EXPR, t, 0)),\n \t       0));\n+      goto ret;\n     }\n \n   if (TREE_CODE (TREE_TYPE (expr)) == FIXED_POINT_TYPE)\n@@ -3972,8 +3993,12 @@ c_common_truthvalue_conversion (location_t location, tree expr)\n \t\t\t\t\t\t   (TREE_TYPE (expr))));\n       return build_binary_op (location, NE_EXPR, expr, fixed_zero_node, 1);\n     }\n+  else\n+    return build_binary_op (location, NE_EXPR, expr, integer_zero_node, 1);\n \n-  return build_binary_op (location, NE_EXPR, expr, integer_zero_node, 1);\n+ ret:\n+  protected_set_expr_location (expr, location);\n+  return expr;\n }\n \f\n static void def_builtin_1  (enum built_in_function fncode,\n@@ -4214,13 +4239,15 @@ c_common_get_alias_set (tree t)\n   return -1;\n }\n \f\n-/* Compute the value of 'sizeof (TYPE)' or '__alignof__ (TYPE)', where the\n-   second parameter indicates which OPERATOR is being applied.  The COMPLAIN\n-   flag controls whether we should diagnose possibly ill-formed\n-   constructs or not.  */\n+/* Compute the value of 'sizeof (TYPE)' or '__alignof__ (TYPE)', where\n+   the second parameter indicates which OPERATOR is being applied.\n+   The COMPLAIN flag controls whether we should diagnose possibly\n+   ill-formed constructs or not.  LOC is the location of the SIZEOF or\n+   TYPEOF operator.  */\n \n tree\n-c_sizeof_or_alignof_type (tree type, bool is_sizeof, int complain)\n+c_sizeof_or_alignof_type (location_t loc,\n+\t\t\t  tree type, bool is_sizeof, int complain)\n {\n   const char *op_name;\n   tree value = NULL;\n@@ -4233,7 +4260,7 @@ c_sizeof_or_alignof_type (tree type, bool is_sizeof, int complain)\n       if (is_sizeof)\n \t{\n \t  if (complain && (pedantic || warn_pointer_arith))\n-\t    pedwarn (input_location, pedantic ? OPT_pedantic : OPT_Wpointer_arith, \n+\t    pedwarn (loc, pedantic ? OPT_pedantic : OPT_Wpointer_arith, \n \t\t     \"invalid application of %<sizeof%> to a function type\");\n           else if (!complain)\n             return error_mark_node;\n@@ -4246,7 +4273,7 @@ c_sizeof_or_alignof_type (tree type, bool is_sizeof, int complain)\n     {\n       if (type_code == VOID_TYPE\n \t  && complain && (pedantic || warn_pointer_arith))\n-\tpedwarn (input_location, pedantic ? OPT_pedantic : OPT_Wpointer_arith, \n+\tpedwarn (loc, pedantic ? OPT_pedantic : OPT_Wpointer_arith, \n \t\t \"invalid application of %qs to a void type\", op_name);\n       else if (!complain)\n         return error_mark_node;\n@@ -4255,8 +4282,8 @@ c_sizeof_or_alignof_type (tree type, bool is_sizeof, int complain)\n   else if (!COMPLETE_TYPE_P (type))\n     {\n       if (complain)\n-\terror (\"invalid application of %qs to incomplete type %qT \",\n-\t       op_name, type);\n+\terror_at (loc, \"invalid application of %qs to incomplete type %qT \",\n+\t\t  op_name, type);\n       value = size_zero_node;\n     }\n   else\n@@ -4283,10 +4310,11 @@ c_sizeof_or_alignof_type (tree type, bool is_sizeof, int complain)\n /* Implement the __alignof keyword: Return the minimum required\n    alignment of EXPR, measured in bytes.  For VAR_DECLs,\n    FUNCTION_DECLs and FIELD_DECLs return DECL_ALIGN (which can be set\n-   from an \"aligned\" __attribute__ specification).  */\n+   from an \"aligned\" __attribute__ specification).  LOC is the\n+   location of the ALIGNOF operator.  */\n \n tree\n-c_alignof_expr (tree expr)\n+c_alignof_expr (location_t loc, tree expr)\n {\n   tree t;\n \n@@ -4296,7 +4324,7 @@ c_alignof_expr (tree expr)\n   else if (TREE_CODE (expr) == COMPONENT_REF\n \t   && DECL_C_BIT_FIELD (TREE_OPERAND (expr, 1)))\n     {\n-      error (\"%<__alignof%> applied to a bit-field\");\n+      error_at (loc, \"%<__alignof%> applied to a bit-field\");\n       t = size_one_node;\n     }\n   else if (TREE_CODE (expr) == COMPONENT_REF\n@@ -4319,10 +4347,10 @@ c_alignof_expr (tree expr)\n \t  if (thisalign > bestalign)\n \t    best = t, bestalign = thisalign;\n \t}\n-      return c_alignof (TREE_TYPE (TREE_TYPE (best)));\n+      return c_alignof (loc, TREE_TYPE (TREE_TYPE (best)));\n     }\n   else\n-    return c_alignof (TREE_TYPE (expr));\n+    return c_alignof (loc, TREE_TYPE (expr));\n \n   return fold_convert (size_type_node, t);\n }\n@@ -4570,44 +4598,56 @@ c_common_nodes_and_builtins (void)\n \n   /* These are types that c_common_type_for_size and\n      c_common_type_for_mode use.  */\n-  lang_hooks.decls.pushdecl (build_decl (TYPE_DECL, NULL_TREE,\n+  lang_hooks.decls.pushdecl (build_decl (UNKNOWN_LOCATION,\n+\t\t\t\t\t TYPE_DECL, NULL_TREE,\n \t\t\t\t\t intQI_type_node));\n-  lang_hooks.decls.pushdecl (build_decl (TYPE_DECL, NULL_TREE,\n+  lang_hooks.decls.pushdecl (build_decl (UNKNOWN_LOCATION,\n+\t\t\t\t\t TYPE_DECL, NULL_TREE,\n \t\t\t\t\t intHI_type_node));\n-  lang_hooks.decls.pushdecl (build_decl (TYPE_DECL, NULL_TREE,\n+  lang_hooks.decls.pushdecl (build_decl (UNKNOWN_LOCATION,\n+\t\t\t\t\t TYPE_DECL, NULL_TREE,\n \t\t\t\t\t intSI_type_node));\n-  lang_hooks.decls.pushdecl (build_decl (TYPE_DECL, NULL_TREE,\n+  lang_hooks.decls.pushdecl (build_decl (UNKNOWN_LOCATION,\n+\t\t\t\t\t TYPE_DECL, NULL_TREE,\n \t\t\t\t\t intDI_type_node));\n #if HOST_BITS_PER_WIDE_INT >= 64\n   if (targetm.scalar_mode_supported_p (TImode))\n-    lang_hooks.decls.pushdecl (build_decl (TYPE_DECL,\n+    lang_hooks.decls.pushdecl (build_decl (UNKNOWN_LOCATION,\n+\t\t\t\t\t   TYPE_DECL,\n \t\t\t\t\t   get_identifier (\"__int128_t\"),\n \t\t\t\t\t   intTI_type_node));\n #endif\n-  lang_hooks.decls.pushdecl (build_decl (TYPE_DECL, NULL_TREE,\n+  lang_hooks.decls.pushdecl (build_decl (UNKNOWN_LOCATION,\n+\t\t\t\t\t TYPE_DECL, NULL_TREE,\n \t\t\t\t\t unsigned_intQI_type_node));\n-  lang_hooks.decls.pushdecl (build_decl (TYPE_DECL, NULL_TREE,\n+  lang_hooks.decls.pushdecl (build_decl (UNKNOWN_LOCATION,\n+\t\t\t\t\t TYPE_DECL, NULL_TREE,\n \t\t\t\t\t unsigned_intHI_type_node));\n-  lang_hooks.decls.pushdecl (build_decl (TYPE_DECL, NULL_TREE,\n+  lang_hooks.decls.pushdecl (build_decl (UNKNOWN_LOCATION,\n+\t\t\t\t\t TYPE_DECL, NULL_TREE,\n \t\t\t\t\t unsigned_intSI_type_node));\n-  lang_hooks.decls.pushdecl (build_decl (TYPE_DECL, NULL_TREE,\n+  lang_hooks.decls.pushdecl (build_decl (UNKNOWN_LOCATION,\n+\t\t\t\t\t TYPE_DECL, NULL_TREE,\n \t\t\t\t\t unsigned_intDI_type_node));\n #if HOST_BITS_PER_WIDE_INT >= 64\n   if (targetm.scalar_mode_supported_p (TImode))\n-    lang_hooks.decls.pushdecl (build_decl (TYPE_DECL,\n+    lang_hooks.decls.pushdecl (build_decl (UNKNOWN_LOCATION,\n+\t\t\t\t\t   TYPE_DECL,\n \t\t\t\t\t   get_identifier (\"__uint128_t\"),\n \t\t\t\t\t   unsigned_intTI_type_node));\n #endif\n \n   /* Create the widest literal types.  */\n   widest_integer_literal_type_node\n     = make_signed_type (HOST_BITS_PER_WIDE_INT * 2);\n-  lang_hooks.decls.pushdecl (build_decl (TYPE_DECL, NULL_TREE,\n+  lang_hooks.decls.pushdecl (build_decl (UNKNOWN_LOCATION,\n+\t\t\t\t\t TYPE_DECL, NULL_TREE,\n \t\t\t\t\t widest_integer_literal_type_node));\n \n   widest_unsigned_literal_type_node\n     = make_unsigned_type (HOST_BITS_PER_WIDE_INT * 2);\n-  lang_hooks.decls.pushdecl (build_decl (TYPE_DECL, NULL_TREE,\n+  lang_hooks.decls.pushdecl (build_decl (UNKNOWN_LOCATION,\n+\t\t\t\t\t TYPE_DECL, NULL_TREE,\n \t\t\t\t\t widest_unsigned_literal_type_node));\n \n   /* `unsigned long' is the standard type for sizeof.\n@@ -4699,17 +4739,21 @@ c_common_nodes_and_builtins (void)\n \n     }\n \n-  lang_hooks.decls.pushdecl (build_decl (TYPE_DECL,\n+  lang_hooks.decls.pushdecl (build_decl (UNKNOWN_LOCATION,\n+\t\t\t\t\t TYPE_DECL,\n \t\t\t\t\t get_identifier (\"complex int\"),\n \t\t\t\t\t complex_integer_type_node));\n-  lang_hooks.decls.pushdecl (build_decl (TYPE_DECL,\n+  lang_hooks.decls.pushdecl (build_decl (UNKNOWN_LOCATION,\n+\t\t\t\t\t TYPE_DECL,\n \t\t\t\t\t get_identifier (\"complex float\"),\n \t\t\t\t\t complex_float_type_node));\n-  lang_hooks.decls.pushdecl (build_decl (TYPE_DECL,\n+  lang_hooks.decls.pushdecl (build_decl (UNKNOWN_LOCATION,\n+\t\t\t\t\t TYPE_DECL,\n \t\t\t\t\t get_identifier (\"complex double\"),\n \t\t\t\t\t complex_double_type_node));\n   lang_hooks.decls.pushdecl\n-    (build_decl (TYPE_DECL, get_identifier (\"complex long double\"),\n+    (build_decl (UNKNOWN_LOCATION,\n+\t\t TYPE_DECL, get_identifier (\"complex long double\"),\n \t\t complex_long_double_type_node));\n \n   if (c_dialect_cxx ())\n@@ -4903,7 +4947,8 @@ c_common_nodes_and_builtins (void)\n   unsigned_ptrdiff_type_node = c_common_unsigned_type (ptrdiff_type_node);\n \n   lang_hooks.decls.pushdecl\n-    (build_decl (TYPE_DECL, get_identifier (\"__builtin_va_list\"),\n+    (build_decl (UNKNOWN_LOCATION,\n+\t\t TYPE_DECL, get_identifier (\"__builtin_va_list\"),\n \t\t va_list_type_node));\n #ifdef TARGET_ENUM_VA_LIST\n   {\n@@ -4913,7 +4958,8 @@ c_common_nodes_and_builtins (void)\n     for (l = 0; TARGET_ENUM_VA_LIST (l, &pname, &ptype); ++l)\n       {\n \tlang_hooks.decls.pushdecl\n-\t  (build_decl (TYPE_DECL, get_identifier (pname),\n+\t  (build_decl (UNKNOWN_LOCATION,\n+\t\t       TYPE_DECL, get_identifier (pname),\n \t  \t       ptype));\n \n       }\n@@ -4999,9 +5045,11 @@ set_compound_literal_name (tree decl)\n }\n \n tree\n-build_va_arg (tree expr, tree type)\n+build_va_arg (location_t loc, tree expr, tree type)\n {\n-  return build1 (VA_ARG_EXPR, type, expr);\n+  expr = build1 (VA_ARG_EXPR, type, expr);\n+  SET_EXPR_LOCATION (expr, loc);\n+  return expr;\n }\n \n \n@@ -5183,17 +5231,18 @@ case_compare (splay_tree_key k1, splay_tree_key k2)\n   return tree_int_cst_compare ((tree) k1, (tree) k2);\n }\n \n-/* Process a case label for the range LOW_VALUE ... HIGH_VALUE.  If\n-   LOW_VALUE and HIGH_VALUE are both NULL_TREE then this case label is\n-   actually a `default' label.  If only HIGH_VALUE is NULL_TREE, then\n-   case label was declared using the usual C/C++ syntax, rather than\n-   the GNU case range extension.  CASES is a tree containing all the\n-   case ranges processed so far; COND is the condition for the\n-   switch-statement itself.  Returns the CASE_LABEL_EXPR created, or\n-   ERROR_MARK_NODE if no CASE_LABEL_EXPR is created.  */\n+/* Process a case label, located at LOC, for the range LOW_VALUE\n+   ... HIGH_VALUE.  If LOW_VALUE and HIGH_VALUE are both NULL_TREE\n+   then this case label is actually a `default' label.  If only\n+   HIGH_VALUE is NULL_TREE, then case label was declared using the\n+   usual C/C++ syntax, rather than the GNU case range extension.\n+   CASES is a tree containing all the case ranges processed so far;\n+   COND is the condition for the switch-statement itself.  Returns the\n+   CASE_LABEL_EXPR created, or ERROR_MARK_NODE if no CASE_LABEL_EXPR\n+   is created.  */\n \n tree\n-c_add_case_label (splay_tree cases, tree cond, tree orig_type,\n+c_add_case_label (location_t loc, splay_tree cases, tree cond, tree orig_type,\n \t\t  tree low_value, tree high_value)\n {\n   tree type;\n@@ -5202,7 +5251,7 @@ c_add_case_label (splay_tree cases, tree cond, tree orig_type,\n   splay_tree_node node;\n \n   /* Create the LABEL_DECL itself.  */\n-  label = create_artificial_label ();\n+  label = create_artificial_label (loc);\n \n   /* If there was an error processing the switch condition, bail now\n      before we get more confused.  */\n@@ -5214,13 +5263,13 @@ c_add_case_label (splay_tree cases, tree cond, tree orig_type,\n       || (high_value && TREE_TYPE (high_value)\n \t  && POINTER_TYPE_P (TREE_TYPE (high_value))))\n     {\n-      error (\"pointers are not permitted as case values\");\n+      error_at (loc, \"pointers are not permitted as case values\");\n       goto error_out;\n     }\n \n   /* Case ranges are a GNU extension.  */\n   if (high_value)\n-    pedwarn (input_location, OPT_pedantic, \n+    pedwarn (loc, OPT_pedantic, \n \t     \"range expressions in switch statements are non-standard\");\n \n   type = TREE_TYPE (cond);\n@@ -5247,7 +5296,7 @@ c_add_case_label (splay_tree cases, tree cond, tree orig_type,\n       if (tree_int_cst_equal (low_value, high_value))\n \thigh_value = NULL_TREE;\n       else if (!tree_int_cst_lt (low_value, high_value))\n-\twarning (0, \"empty range specified\");\n+\twarning_at (loc, 0, \"empty range specified\");\n     }\n \n   /* See if the case is in range of the type of the original testing\n@@ -5307,24 +5356,26 @@ c_add_case_label (splay_tree cases, tree cond, tree orig_type,\n \n       if (high_value)\n \t{\n-\t  error (\"duplicate (or overlapping) case value\");\n-\t  error (\"%Jthis is the first entry overlapping that value\", duplicate);\n+\t  error_at (loc, \"duplicate (or overlapping) case value\");\n+\t  error_at (DECL_SOURCE_LOCATION (duplicate),\n+\t\t    \"this is the first entry overlapping that value\");\n \t}\n       else if (low_value)\n \t{\n-\t  error (\"duplicate case value\") ;\n-\t  error (\"%Jpreviously used here\", duplicate);\n+\t  error_at (loc, \"duplicate case value\") ;\n+\t  error_at (DECL_SOURCE_LOCATION (duplicate), \"previously used here\");\n \t}\n       else\n \t{\n-\t  error (\"multiple default labels in one switch\");\n-\t  error (\"%Jthis is the first default label\", duplicate);\n+\t  error_at (loc, \"multiple default labels in one switch\");\n+\t  error_at (DECL_SOURCE_LOCATION (duplicate),\n+\t\t    \"this is the first default label\");\n \t}\n       goto error_out;\n     }\n \n   /* Add a CASE_LABEL to the statement-tree.  */\n-  case_label = add_stmt (build_case_label (low_value, high_value, label));\n+  case_label = add_stmt (build_case_label (loc, low_value, high_value, label));\n   /* Register this case label in the splay tree.  */\n   splay_tree_insert (cases,\n \t\t     (splay_tree_key) low_value,\n@@ -5338,8 +5389,8 @@ c_add_case_label (splay_tree cases, tree cond, tree orig_type,\n      that just leads to duplicates and thence to failure later on.  */\n   if (!cases->root)\n     {\n-      tree t = create_artificial_label ();\n-      add_stmt (build_stmt (LABEL_EXPR, t));\n+      tree t = create_artificial_label (loc);\n+      add_stmt (build_stmt (loc, LABEL_EXPR, t));\n     }\n   return error_mark_node;\n }\n@@ -8615,13 +8666,15 @@ sync_resolve_return (tree first_param, tree result)\n    function should be called immediately after parsing the call expression\n    before surrounding code has committed to the type of the expression.\n \n+   LOC is the location of the builtin call.\n+\n    FUNCTION is the DECL that has been invoked; it is known to be a builtin.\n    PARAMS is the argument list for the call.  The return value is non-null\n    when expansion is complete, and null if normal processing should\n    continue.  */\n \n tree\n-resolve_overloaded_builtin (tree function, VEC(tree,gc) *params)\n+resolve_overloaded_builtin (location_t loc, tree function, VEC(tree,gc) *params)\n {\n   enum built_in_function orig_code = DECL_FUNCTION_CODE (function);\n   switch (DECL_BUILT_IN_CLASS (function))\n@@ -8630,7 +8683,7 @@ resolve_overloaded_builtin (tree function, VEC(tree,gc) *params)\n       break;\n     case BUILT_IN_MD:\n       if (targetm.resolve_overloaded_builtin)\n-\treturn targetm.resolve_overloaded_builtin (function, params);\n+\treturn targetm.resolve_overloaded_builtin (loc, function, params);\n       else\n \treturn NULL_TREE;\n     default:\n@@ -8668,7 +8721,7 @@ resolve_overloaded_builtin (tree function, VEC(tree,gc) *params)\n \t  return error_mark_node;\n \n \tfirst_param = VEC_index (tree, params, 0);\n-\tresult = build_function_call_vec (new_function, params, NULL);\n+\tresult = build_function_call_vec (loc, new_function, params, NULL);\n \tif (orig_code != BUILT_IN_BOOL_COMPARE_AND_SWAP_N\n \t    && orig_code != BUILT_IN_LOCK_RELEASE_N)\n \t  result = sync_resolve_return (first_param, result);"}, {"sha": "eecb1895f84b8bddee2c4bb294364015e4dd200e", "filename": "gcc/c-common.h", "status": "modified", "additions": 27, "deletions": 26, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -418,7 +418,7 @@ extern void push_cleanup (tree, tree, bool);\n extern tree pushdecl_top_level (tree);\n extern tree pushdecl (tree);\n extern tree build_modify_expr (location_t, tree, tree, enum tree_code,\n-\t\t\t       tree, tree);\n+\t\t\t       location_t, tree, tree);\n extern tree build_indirect_ref (location_t, tree, const char *);\n \n extern int c_expand_decl (tree);\n@@ -754,7 +754,7 @@ extern const struct attribute_spec c_common_format_attribute_table[];\n    TYPE_DEP indicates whether it depends on type of the function or not\n    (i.e. __PRETTY_FUNCTION__).  */\n \n-extern tree (*make_fname_decl) (tree, int);\n+extern tree (*make_fname_decl) (location_t, tree, int);\n \n extern tree identifier_global_value (tree);\n extern void record_builtin_type (enum rid, const char *, tree);\n@@ -791,8 +791,8 @@ extern tree decl_constant_value_for_optimization (tree);\n extern tree c_save_expr (tree);\n extern tree c_common_truthvalue_conversion (location_t, tree);\n extern void c_apply_type_quals_to_decl (int, tree);\n-extern tree c_sizeof_or_alignof_type (tree, bool, int);\n-extern tree c_alignof_expr (tree);\n+extern tree c_sizeof_or_alignof_type (location_t, tree, bool, int);\n+extern tree c_alignof_expr (location_t, tree);\n /* Print an error message for invalid operands to arith operation CODE.\n    NOP_EXPR is used as a special case (see truthvalue_conversion).  */\n extern void binary_op_error (location_t, enum tree_code, tree, tree);\n@@ -803,7 +803,7 @@ extern void constant_expression_error (tree);\n extern bool strict_aliasing_warning (tree, tree, tree);\n extern void warnings_for_convert_and_check (tree, tree, tree);\n extern tree convert_and_check (tree, tree);\n-extern void overflow_warning (tree);\n+extern void overflow_warning (location_t, tree);\n extern void warn_logical_operator (location_t, enum tree_code, tree,\n \t\t\t\t   enum tree_code, tree, enum tree_code, tree);\n extern void check_main_parameter_types (tree decl);\n@@ -815,8 +815,8 @@ extern void set_float_const_decimal64 (void);\n extern void clear_float_const_decimal64 (void);\n extern bool float_const_decimal64_p (void);\n \n-#define c_sizeof(T)  c_sizeof_or_alignof_type (T, true, 1)\n-#define c_alignof(T) c_sizeof_or_alignof_type (T, false, 1)\n+#define c_sizeof(LOC, T)  c_sizeof_or_alignof_type (LOC, T, true, 1)\n+#define c_alignof(LOC, T) c_sizeof_or_alignof_type (LOC, T, false, 1)\n \n /* Subroutine of build_binary_op, used for certain operations.  */\n extern tree shorten_binary_op (tree result_type, tree op0, tree op1, bool bitwise);\n@@ -841,7 +841,7 @@ extern void disable_builtin_function (const char *);\n \n extern void set_compound_literal_name (tree decl);\n \n-extern tree build_va_arg (tree, tree);\n+extern tree build_va_arg (location_t, tree, tree);\n \n extern unsigned int c_common_init_options (unsigned int, const char **);\n extern bool c_common_post_options (const char **);\n@@ -896,9 +896,9 @@ extern void finish_file\t(void);\n #define CLEAR_DECL_C_BIT_FIELD(NODE) \\\n   (DECL_LANG_FLAG_4 (FIELD_DECL_CHECK (NODE)) = 0)\n \n-extern tree do_case (tree, tree);\n-extern tree build_stmt (enum tree_code, ...);\n-extern tree build_case_label (tree, tree, tree);\n+extern tree do_case (location_t, tree, tree);\n+extern tree build_stmt (location_t, enum tree_code, ...);\n+extern tree build_case_label (location_t, tree, tree, tree);\n \n /* These functions must be defined by each front-end which implements\n    a variant of the C language.  They are used in c-common.c.  */\n@@ -924,15 +924,16 @@ extern tree boolean_increment (enum tree_code, tree);\n \n extern int case_compare (splay_tree_key, splay_tree_key);\n \n-extern tree c_add_case_label (splay_tree, tree, tree, tree, tree);\n+extern tree c_add_case_label (location_t, splay_tree, tree, tree, tree, tree);\n \n extern void c_do_switch_warnings (splay_tree, location_t, tree, tree);\n \n-extern tree build_function_call (tree, tree);\n+extern tree build_function_call (location_t, tree, tree);\n \n-extern tree build_function_call_vec (tree, VEC(tree,gc) *, VEC(tree,gc) *);\n+extern tree build_function_call_vec (location_t, tree,\n+    \t\t\t\t     VEC(tree,gc) *, VEC(tree,gc) *);\n \n-extern tree resolve_overloaded_builtin (tree, VEC(tree,gc) *);\n+extern tree resolve_overloaded_builtin (location_t, tree, VEC(tree,gc) *);\n \n extern tree finish_label_address_expr (tree, location_t);\n \n@@ -1021,7 +1022,7 @@ extern VEC(tree,gc) *make_tree_vector_copy (const VEC(tree,gc) *);\n /* In c-gimplify.c  */\n extern void c_genericize (tree);\n extern int c_gimplify_expr (tree *, gimple_seq *, gimple_seq *);\n-extern tree c_build_bind_expr (tree, tree);\n+extern tree c_build_bind_expr (location_t, tree, tree);\n \n /* In c-pch.c  */\n extern void pch_init (void);\n@@ -1065,7 +1066,7 @@ extern void objc_declare_class (tree);\n extern void objc_declare_protocols (tree);\n extern tree objc_build_message_expr (tree);\n extern tree objc_finish_message_expr (tree, tree, tree);\n-extern tree objc_build_selector_expr (tree);\n+extern tree objc_build_selector_expr (location_t, tree);\n extern tree objc_build_protocol_expr (tree);\n extern tree objc_build_encode_expr (tree);\n extern tree objc_build_string_object (tree);\n@@ -1089,7 +1090,7 @@ extern void objc_start_method_definition (tree);\n extern void objc_finish_method_definition (tree);\n extern void objc_add_instance_variable (tree);\n extern tree objc_build_keyword_decl (tree, tree, tree);\n-extern tree objc_build_throw_stmt (tree);\n+extern tree objc_build_throw_stmt (location_t, tree);\n extern void objc_begin_try_stmt (location_t, tree);\n extern tree objc_finish_try_stmt (void);\n extern void objc_begin_catch_clause (tree);\n@@ -1113,15 +1114,15 @@ extern void pp_dir_change (cpp_reader *, const char *);\n extern bool check_missing_format_attribute (tree, tree);\n \n /* In c-omp.c  */\n-extern tree c_finish_omp_master (tree);\n-extern tree c_finish_omp_critical (tree, tree);\n-extern tree c_finish_omp_ordered (tree);\n-extern void c_finish_omp_barrier (void);\n-extern tree c_finish_omp_atomic (enum tree_code, tree, tree);\n-extern void c_finish_omp_flush (void);\n-extern void c_finish_omp_taskwait (void);\n+extern tree c_finish_omp_master (location_t, tree);\n+extern tree c_finish_omp_critical (location_t, tree, tree);\n+extern tree c_finish_omp_ordered (location_t, tree);\n+extern void c_finish_omp_barrier (location_t);\n+extern tree c_finish_omp_atomic (location_t, enum tree_code, tree, tree);\n+extern void c_finish_omp_flush (location_t);\n+extern void c_finish_omp_taskwait (location_t);\n extern tree c_finish_omp_for (location_t, tree, tree, tree, tree, tree, tree);\n-extern void c_split_parallel_clauses (tree, tree *, tree *);\n+extern void c_split_parallel_clauses (location_t, tree, tree *, tree *);\n extern enum omp_clause_default_kind c_omp_predetermined_sharing (tree);\n \n /* Not in c-omp.c; provided by the front end.  */"}, {"sha": "03d6dbd892b33b7c4eb0a55e75362f647bae4de5", "filename": "gcc/c-decl.c", "status": "modified", "additions": 332, "deletions": 242, "changes": 574, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -443,7 +443,7 @@ static bool next_is_function_body;\n \n /* Forward declarations.  */\n static tree lookup_name_in_scope (tree, struct c_scope *);\n-static tree c_make_fname_decl (tree, int);\n+static tree c_make_fname_decl (location_t, tree, int);\n static tree grokdeclarator (const struct c_declarator *,\n \t\t\t    struct c_declspecs *,\n \t\t\t    enum decl_context, bool, tree *, tree *, tree *,\n@@ -584,7 +584,8 @@ c_finish_incomplete_decl (tree decl)\n \t  && !DECL_EXTERNAL (decl)\n \t  && TYPE_DOMAIN (type) == 0)\n \t{\n-\t  warning (0, \"array %q+D assumed to have one element\", decl);\n+\t  warning_at (DECL_SOURCE_LOCATION (decl),\n+\t\t      0, \"array %q+D assumed to have one element\", decl);\n \n \t  complete_array_type (&TREE_TYPE (decl), NULL_TREE, true);\n \n@@ -843,7 +844,8 @@ pop_scope (void)\n     context = current_function_decl;\n   else if (scope == file_scope)\n     {\n-      tree file_decl = build_decl (TRANSLATION_UNIT_DECL, 0, 0);\n+      tree file_decl = build_decl (UNKNOWN_LOCATION,\n+\t  \t\t\t   TRANSLATION_UNIT_DECL, 0, 0);\n       TREE_CHAIN (file_decl) = all_translation_units;\n       all_translation_units = file_decl;\n       context = file_decl;\n@@ -1089,13 +1091,14 @@ pop_file_scope (void)\n \f\n /* Push a definition or a declaration of struct, union or enum tag \"name\".\n    \"type\" should be the type node.\n-   We assume that the tag \"name\" is not already defined.\n+   We assume that the tag \"name\" is not already defined, and has a location\n+   of LOC.\n \n    Note that the definition may really be just a forward reference.\n    In that case, the TYPE_SIZE will be zero.  */\n \n static void\n-pushtag (tree name, tree type, location_t loc)\n+pushtag (location_t loc, tree name, tree type)\n {\n   /* Record the identifier as the type's name if it has none.  */\n   if (name && !TYPE_NAME (type))\n@@ -1109,7 +1112,8 @@ pushtag (tree name, tree type, location_t loc)\n      us a convenient place to record the \"scope start\" address for the\n      tagged type.  */\n \n-  TYPE_STUB_DECL (type) = pushdecl (build_decl (TYPE_DECL, NULL_TREE, type));\n+  TYPE_STUB_DECL (type) = pushdecl (build_decl (loc,\n+\t\t\t\t\t\tTYPE_DECL, NULL_TREE, type));\n \n   /* An approximation for now, so we can tell this is a function-scope tag.\n      This will be updated in pop_scope.  */\n@@ -2457,11 +2461,11 @@ implicit_decl_warning (tree id, tree olddecl)\n     }\n }\n \n-/* Generate an implicit declaration for identifier FUNCTIONID as a\n+/* Generate an implicit declaration for identifier FUNCTIONID at LOC as a\n    function of type int ().  */\n \n tree\n-implicitly_declare (tree functionid)\n+implicitly_declare (location_t loc, tree functionid)\n {\n   struct c_binding *b;\n   tree decl = 0;\n@@ -2514,17 +2518,16 @@ implicitly_declare (tree functionid)\n \t\t\t\t\t\t      (TREE_TYPE (decl)));\n \t      if (!comptypes (newtype, TREE_TYPE (decl)))\n \t\t{\n-\t\t  warning (0, \"incompatible implicit declaration of built-in\"\n-\t\t\t   \" function %qD\", decl);\n+\t\t  warning_at (loc, 0, \"incompatible implicit declaration of \"\n+\t\t\t      \"built-in function %qD\", decl);\n \t\t  newtype = TREE_TYPE (decl);\n \t\t}\n \t    }\n \t  else\n \t    {\n \t      if (!comptypes (newtype, TREE_TYPE (decl)))\n \t\t{\n-\t\t  error (\"incompatible implicit declaration of function %qD\",\n-\t\t\t decl);\n+\t\t  error_at (loc, \"incompatible implicit declaration of function %qD\", decl);\n \t\t  locate_old_decl (decl);\n \t\t}\n \t    }\n@@ -2538,7 +2541,7 @@ implicitly_declare (tree functionid)\n     }\n \n   /* Not seen before.  */\n-  decl = build_decl (FUNCTION_DECL, functionid, default_function_type);\n+  decl = build_decl (loc, FUNCTION_DECL, functionid, default_function_type);\n   DECL_EXTERNAL (decl) = 1;\n   TREE_PUBLIC (decl) = 1;\n   C_DECL_IMPLICIT (decl) = 1;\n@@ -2570,7 +2573,7 @@ implicitly_declare (tree functionid)\n    in an appropriate scope, which will suppress further errors for the\n    same identifier.  The error message should be given location LOC.  */\n void\n-undeclared_variable (tree id, location_t loc)\n+undeclared_variable (location_t loc, tree id)\n {\n   static bool already = false;\n   struct c_scope *scope;\n@@ -2603,13 +2606,12 @@ undeclared_variable (tree id, location_t loc)\n    LABEL_DECL with all the proper frills.  */\n \n static tree\n-make_label (tree name, location_t location)\n+make_label (location_t location, tree name)\n {\n-  tree label = build_decl (LABEL_DECL, name, void_type_node);\n+  tree label = build_decl (location, LABEL_DECL, name, void_type_node);\n \n   DECL_CONTEXT (label) = current_function_decl;\n   DECL_MODE (label) = VOIDmode;\n-  DECL_SOURCE_LOCATION (label) = location;\n \n   return label;\n }\n@@ -2646,7 +2648,7 @@ lookup_label (tree name)\n     }\n \n   /* No label binding for that identifier; make one.  */\n-  label = make_label (name, input_location);\n+  label = make_label (input_location, name);\n \n   /* Ordinary labels go in the current function scope.  */\n   bind (name, label, current_function_scope,\n@@ -2675,7 +2677,7 @@ declare_label (tree name)\n       return b->decl;\n     }\n \n-  label = make_label (name, input_location);\n+  label = make_label (input_location, name);\n   C_DECLARED_LABEL_FLAG (label) = 1;\n \n   /* Declared labels go in the current scope.  */\n@@ -2704,7 +2706,7 @@ define_label (location_t location, tree name)\n \t  || (DECL_CONTEXT (label) != current_function_decl\n \t      && C_DECLARED_LABEL_FLAG (label))))\n     {\n-      error (\"%Hduplicate label %qD\", &location, label);\n+      error_at (location, \"duplicate label %qD\", label);\n       locate_old_decl (label);\n       return 0;\n     }\n@@ -2714,25 +2716,26 @@ define_label (location_t location, tree name)\n \t but not defined.  Update its location to point to this\n \t definition.  */\n       if (C_DECL_UNDEFINABLE_STMT_EXPR (label))\n-\terror (\"%Jjump into statement expression\", label);\n+\terror_at (location, \"jump into statement expression\");\n       if (C_DECL_UNDEFINABLE_VM (label))\n-\terror (\"%Jjump into scope of identifier with variably modified type\",\n-\t       label);\n+\terror_at (location,\n+\t\t  \"jump into scope of identifier with variably modified type\");\n       DECL_SOURCE_LOCATION (label) = location;\n     }\n   else\n     {\n       /* No label binding for that identifier; make one.  */\n-      label = make_label (name, location);\n+      label = make_label (location, name);\n \n       /* Ordinary labels go in the current function scope.  */\n       bind (name, label, current_function_scope,\n \t    /*invisible=*/false, /*nested=*/false, UNKNOWN_LOCATION);\n     }\n \n   if (!in_system_header && lookup_name (name))\n-    warning (OPT_Wtraditional, \"%Htraditional C lacks a separate namespace \"\n-\t     \"for labels, identifier %qE conflicts\", &location, name);\n+    warning_at (location, OPT_Wtraditional,\n+\t\t\"traditional C lacks a separate namespace \"\n+\t\t\"for labels, identifier %qE conflicts\", name);\n \n   nlist_se = XOBNEW (&parser_obstack, struct c_label_list);\n   nlist_se->next = label_context_stack_se->labels_def;\n@@ -2882,7 +2885,7 @@ c_init_decl_processing (void)\n   truthvalue_false_node = integer_zero_node;\n \n   /* Even in C99, which has a real boolean type.  */\n-  pushdecl (build_decl (TYPE_DECL, get_identifier (\"_Bool\"),\n+  pushdecl (build_decl (UNKNOWN_LOCATION, TYPE_DECL, get_identifier (\"_Bool\"),\n \t\t\tboolean_type_node));\n \n   input_location = save_loc;\n@@ -2893,15 +2896,16 @@ c_init_decl_processing (void)\n   start_fname_decls ();\n }\n \n-/* Create the VAR_DECL for __FUNCTION__ etc. ID is the name to give the\n-   decl, NAME is the initialization string and TYPE_DEP indicates whether\n-   NAME depended on the type of the function.  As we don't yet implement\n-   delayed emission of static data, we mark the decl as emitted\n-   so it is not placed in the output.  Anything using it must therefore pull\n-   out the STRING_CST initializer directly.  FIXME.  */\n+/* Create the VAR_DECL at LOC for __FUNCTION__ etc. ID is the name to\n+   give the decl, NAME is the initialization string and TYPE_DEP\n+   indicates whether NAME depended on the type of the function.  As we\n+   don't yet implement delayed emission of static data, we mark the\n+   decl as emitted so it is not placed in the output.  Anything using\n+   it must therefore pull out the STRING_CST initializer directly.\n+   FIXME.  */\n \n static tree\n-c_make_fname_decl (tree id, int type_dep)\n+c_make_fname_decl (location_t loc, tree id, int type_dep)\n {\n   const char *name = fname_as_string (type_dep);\n   tree decl, type, init;\n@@ -2911,7 +2915,7 @@ c_make_fname_decl (tree id, int type_dep)\n \t\t\t   build_index_type (size_int (length)));\n   type = c_build_qualified_type (type, TYPE_QUAL_CONST);\n \n-  decl = build_decl (VAR_DECL, id, type);\n+  decl = build_decl (loc, VAR_DECL, id, type);\n \n   TREE_STATIC (decl) = 1;\n   TREE_READONLY (decl) = 1;\n@@ -2940,7 +2944,7 @@ c_make_fname_decl (tree id, int type_dep)\n \t    /*invisible=*/false, /*nested=*/false, UNKNOWN_LOCATION);\n     }\n \n-  finish_decl (decl, init, NULL_TREE, NULL_TREE);\n+  finish_decl (decl, loc, init, NULL_TREE, NULL_TREE);\n \n   return decl;\n }\n@@ -3078,7 +3082,7 @@ shadow_tag_warned (const struct c_declspecs *declspecs, int warned)\n \t      if (t == 0)\n \t\t{\n \t\t  t = make_node (code);\n-\t\t  pushtag (name, t, input_location);\n+\t\t  pushtag (input_location, name, t);\n \t\t}\n \t    }\n \t}\n@@ -3174,21 +3178,24 @@ quals_from_declspecs (const struct c_declspecs *specs)\n   return quals;\n }\n \n-/* Construct an array declarator.  EXPR is the expression inside [],\n-   or NULL_TREE.  QUALS are the type qualifiers inside the [] (to be\n-   applied to the pointer to which a parameter array is converted).\n-   STATIC_P is true if \"static\" is inside the [], false otherwise.\n-   VLA_UNSPEC_P is true if the array is [*], a VLA of unspecified\n-   length which is nevertheless a complete type, false otherwise.  The\n-   field for the contained declarator is left to be filled in by\n-   set_array_declarator_inner.  */\n+/* Construct an array declarator.  LOC is the location of the\n+   beginning of the array (usually the opening brace).  EXPR is the\n+   expression inside [], or NULL_TREE.  QUALS are the type qualifiers\n+   inside the [] (to be applied to the pointer to which a parameter\n+   array is converted).  STATIC_P is true if \"static\" is inside the\n+   [], false otherwise.  VLA_UNSPEC_P is true if the array is [*], a\n+   VLA of unspecified length which is nevertheless a complete type,\n+   false otherwise.  The field for the contained declarator is left to\n+   be filled in by set_array_declarator_inner.  */\n \n struct c_declarator *\n-build_array_declarator (tree expr, struct c_declspecs *quals, bool static_p,\n+build_array_declarator (location_t loc,\n+\t\t\ttree expr, struct c_declspecs *quals, bool static_p,\n \t\t\tbool vla_unspec_p)\n {\n   struct c_declarator *declarator = XOBNEW (&parser_obstack,\n \t\t\t\t\t    struct c_declarator);\n+  declarator->id_loc = loc;\n   declarator->kind = cdk_array;\n   declarator->declarator = 0;\n   declarator->u.array.dimen = expr;\n@@ -3207,19 +3214,20 @@ build_array_declarator (tree expr, struct c_declspecs *quals, bool static_p,\n   if (!flag_isoc99)\n     {\n       if (static_p || quals != NULL)\n-\tpedwarn (input_location, OPT_pedantic,\n+\tpedwarn (loc, OPT_pedantic,\n \t\t \"ISO C90 does not support %<static%> or type \"\n \t\t \"qualifiers in parameter array declarators\");\n       if (vla_unspec_p)\n-\tpedwarn (input_location, OPT_pedantic,\n+\tpedwarn (loc, OPT_pedantic,\n \t\t \"ISO C90 does not support %<[*]%> array declarators\");\n     }\n   if (vla_unspec_p)\n     {\n       if (!current_scope->parm_flag)\n \t{\n \t  /* C99 6.7.5.2p4 */\n-\t  error (\"%<[*]%> not allowed in other than function prototype scope\");\n+\t  error_at (loc, \"%<[*]%> not allowed in other than \"\n+\t\t    \"function prototype scope\");\n \t  declarator->u.array.vla_unspec_p = false;\n \t  return NULL;\n \t}\n@@ -3514,10 +3522,13 @@ c_maybe_initialize_eh (void)\n    install its initial value.\n    If ORIGTYPE is not NULL_TREE, it is the original type of INIT.\n    If the length of an array type is not known before,\n-   it must be determined now, from the initial value, or it is an error.  */\n+   it must be determined now, from the initial value, or it is an error.\n+\n+   INIT_LOC is the location of the initial value.  */\n \n void\n-finish_decl (tree decl, tree init, tree origtype, tree asmspec_tree)\n+finish_decl (tree decl, location_t init_loc, tree init,\n+    \t     tree origtype, tree asmspec_tree)\n {\n   tree type;\n   bool was_incomplete = (DECL_SIZE (decl) == 0);\n@@ -3539,7 +3550,7 @@ finish_decl (tree decl, tree init, tree origtype, tree asmspec_tree)\n     init = 0;\n \n   if (init)\n-    store_init_value (decl, init, origtype);\n+    store_init_value (init_loc, decl, init, origtype);\n \n   if (c_dialect_objc () && (TREE_CODE (decl) == VAR_DECL\n \t\t\t    || TREE_CODE (decl) == FUNCTION_DECL\n@@ -3747,7 +3758,8 @@ finish_decl (tree decl, tree init, tree origtype, tree asmspec_tree)\n \t\t  add_stmt (bind);\n \t\t  BIND_EXPR_BODY (bind) = push_stmt_list ();\n \t\t}\n-\t      add_stmt (build_stmt (DECL_EXPR, decl));\n+\t      add_stmt (build_stmt (DECL_SOURCE_LOCATION (decl),\n+\t\t\t\t    DECL_EXPR, decl));\n \t    }\n \t}\n \n@@ -3772,7 +3784,7 @@ finish_decl (tree decl, tree init, tree origtype, tree asmspec_tree)\n     {\n       if (!DECL_FILE_SCOPE_P (decl)\n \t  && variably_modified_type_p (TREE_TYPE (decl), NULL_TREE))\n-\tadd_stmt (build_stmt (DECL_EXPR, decl));\n+\tadd_stmt (build_stmt (DECL_SOURCE_LOCATION (decl), DECL_EXPR, decl));\n \n       rest_of_decl_compilation (decl, DECL_FILE_SCOPE_P (decl), 0);\n     }\n@@ -3798,7 +3810,8 @@ finish_decl (tree decl, tree init, tree origtype, tree asmspec_tree)\n \t  cleanup = build_unary_op (input_location, ADDR_EXPR, decl, 0);\n \t  vec = VEC_alloc (tree, gc, 1);\n \t  VEC_quick_push (tree, vec, cleanup);\n-\t  cleanup = build_function_call_vec (cleanup_decl, vec, NULL);\n+\t  cleanup = build_function_call_vec (DECL_SOURCE_LOCATION (decl),\n+\t      \t\t\t\t     cleanup_decl, vec, NULL);\n \t  VEC_free (tree, gc, vec);\n \n \t  /* Don't warn about decl unused; the cleanup uses it.  */\n@@ -3842,7 +3855,7 @@ push_parm_decl (const struct c_parm *parm)\n \n   decl = pushdecl (decl);\n \n-  finish_decl (decl, NULL_TREE, NULL_TREE, NULL_TREE);\n+  finish_decl (decl, input_location, NULL_TREE, NULL_TREE, NULL_TREE);\n }\n \n /* Mark all the parameter declarations to date as forward decls.\n@@ -3867,12 +3880,12 @@ mark_forward_parm_decls (void)\n \f\n /* Build a COMPOUND_LITERAL_EXPR.  TYPE is the type given in the compound\n    literal, which may be an incomplete array type completed by the\n-   initializer; INIT is a CONSTRUCTOR that initializes the compound\n+   initializer; INIT is a CONSTRUCTOR at LOC that initializes the compound\n    literal.  NON_CONST is true if the initializers contain something\n    that cannot occur in a constant expression.  */\n \n tree\n-build_compound_literal (tree type, tree init, bool non_const)\n+build_compound_literal (location_t loc, tree type, tree init, bool non_const)\n {\n   /* We do not use start_decl here because we have a type, not a declarator;\n      and do not use finish_decl because the decl should be stored inside\n@@ -3884,15 +3897,15 @@ build_compound_literal (tree type, tree init, bool non_const)\n   if (type == error_mark_node)\n     return error_mark_node;\n \n-  decl = build_decl (VAR_DECL, NULL_TREE, type);\n+  decl = build_decl (loc, VAR_DECL, NULL_TREE, type);\n   DECL_EXTERNAL (decl) = 0;\n   TREE_PUBLIC (decl) = 0;\n   TREE_STATIC (decl) = (current_scope == file_scope);\n   DECL_CONTEXT (decl) = current_function_decl;\n   TREE_USED (decl) = 1;\n   TREE_TYPE (decl) = type;\n   TREE_READONLY (decl) = TYPE_READONLY (type);\n-  store_init_value (decl, init, NULL_TREE);\n+  store_init_value (loc, decl, init, NULL_TREE);\n \n   if (TREE_CODE (type) == ARRAY_TYPE && !COMPLETE_TYPE_P (type))\n     {\n@@ -3907,7 +3920,7 @@ build_compound_literal (tree type, tree init, bool non_const)\n   if (type == error_mark_node || !COMPLETE_TYPE_P (type))\n     return error_mark_node;\n \n-  stmt = build_stmt (DECL_EXPR, decl);\n+  stmt = build_stmt (DECL_SOURCE_LOCATION (decl), DECL_EXPR, decl);\n   complit = build1 (COMPOUND_LITERAL_EXPR, type, stmt);\n   TREE_SIDE_EFFECTS (complit) = 1;\n \n@@ -3938,7 +3951,7 @@ build_compound_literal (tree type, tree init, bool non_const)\n    is valid for C++.  */\n \n void\n-check_compound_literal_type (struct c_type_name *type_name, location_t loc)\n+check_compound_literal_type (location_t loc, struct c_type_name *type_name)\n {\n   if (warn_cxx_compat && type_name->specs->tag_defined_p)\n     warning_at (loc, OPT_Wc___compat,\n@@ -4202,6 +4215,7 @@ grokdeclarator (const struct c_declarator *declarator,\n   bool bitfield = width != NULL;\n   tree element_type;\n   struct c_arg_info *arg_info = 0;\n+  location_t loc = UNKNOWN_LOCATION;\n   const char *errmsg;\n   tree expr_dummy;\n   bool expr_const_operands_dummy;\n@@ -4225,8 +4239,11 @@ grokdeclarator (const struct c_declarator *declarator,\n     while (decl)\n       switch (decl->kind)\n \t{\n-\tcase cdk_function:\n \tcase cdk_array:\n+\t  loc = decl->id_loc;\n+\t  /* FALL THRU.  */\n+\n+\tcase cdk_function:\n \tcase cdk_pointer:\n \t  funcdef_syntax = (decl->kind == cdk_function);\n \t  decl = decl->declarator;\n@@ -4237,6 +4254,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \t  break;\n \n \tcase cdk_id:\n+\t  loc = decl->id_loc;\n \t  if (decl->u.id)\n \t    name = decl->u.id;\n \t  decl = 0;\n@@ -4275,9 +4293,9 @@ grokdeclarator (const struct c_declarator *declarator,\n       && variably_modified_type_p (type, NULL_TREE))\n     {\n       if (name)\n-\terror (\"variably modified %qE at file scope\", name);\n+\terror_at (loc, \"variably modified %qE at file scope\", name);\n       else\n-\terror (\"variably modified field at file scope\");\n+\terror_at (loc, \"variably modified field at file scope\");\n       type = integer_type_node;\n     }\n \n@@ -4296,7 +4314,7 @@ grokdeclarator (const struct c_declarator *declarator,\n       else\n \t{\n \t  if (name)\n-\t    pedwarn_c99 (input_location, flag_isoc99 ? 0 : OPT_Wimplicit_int, \n+\t    pedwarn_c99 (loc, flag_isoc99 ? 0 : OPT_Wimplicit_int, \n \t\t\t \"type defaults to %<int%> in declaration of %qE\",\n \t\t\t name);\n \t  else\n@@ -4330,11 +4348,11 @@ grokdeclarator (const struct c_declarator *declarator,\n   if (pedantic && !flag_isoc99)\n     {\n       if (constp > 1)\n-\tpedwarn (input_location, OPT_pedantic, \"duplicate %<const%>\");\n+\tpedwarn (loc, OPT_pedantic, \"duplicate %<const%>\");\n       if (restrictp > 1)\n-\tpedwarn (input_location, OPT_pedantic, \"duplicate %<restrict%>\");\n+\tpedwarn (loc, OPT_pedantic, \"duplicate %<restrict%>\");\n       if (volatilep > 1)\n-\tpedwarn (input_location, OPT_pedantic, \"duplicate %<volatile%>\");\n+\tpedwarn (loc, OPT_pedantic, \"duplicate %<volatile%>\");\n     }\n   if (!flag_gen_aux_info && (TYPE_QUALS (element_type)))\n     type = TYPE_MAIN_VARIANT (type);\n@@ -4352,15 +4370,15 @@ grokdeclarator (const struct c_declarator *declarator,\n \t  || storage_class == csc_typedef))\n     {\n       if (storage_class == csc_auto)\n-\tpedwarn (input_location, \n+\tpedwarn (loc, \n \t\t (current_scope == file_scope) ? 0 : OPT_pedantic, \n \t\t \"function definition declared %<auto%>\");\n       if (storage_class == csc_register)\n-\terror (\"function definition declared %<register%>\");\n+\terror_at (loc, \"function definition declared %<register%>\");\n       if (storage_class == csc_typedef)\n-\terror (\"function definition declared %<typedef%>\");\n+\terror_at (loc, \"function definition declared %<typedef%>\");\n       if (threadp)\n-\terror (\"function definition declared %<__thread%>\");\n+\terror_at (loc, \"function definition declared %<__thread%>\");\n       threadp = false;\n       if (storage_class == csc_auto\n \t  || storage_class == csc_register\n@@ -4377,19 +4395,20 @@ grokdeclarator (const struct c_declarator *declarator,\n \t    {\n \t    case FIELD:\n \t      if (name)\n-\t\terror (\"storage class specified for structure field %qE\",\n-\t\t       name);\n+\t\terror_at (loc, \"storage class specified for structure \"\n+\t\t    \t  \"field %qE\", name);\n \t      else\n-\t\terror (\"storage class specified for structure field\");\n+\t\terror_at (loc, \"storage class specified for structure field\");\n \t      break;\n \t    case PARM:\n \t      if (name)\n-\t\terror (\"storage class specified for parameter %qE\", name);\n+\t\terror_at (loc, \"storage class specified for parameter %qE\",\n+\t\t    \t  name);\n \t      else\n-\t\terror (\"storage class specified for unnamed parameter\");\n+\t\terror_at (loc, \"storage class specified for unnamed parameter\");\n \t      break;\n \t    default:\n-\t      error (\"storage class specified for typename\");\n+\t      error_at (loc, \"storage class specified for typename\");\n \t      break;\n \t    }\n \t  storage_class = csc_none;\n@@ -4406,28 +4425,30 @@ grokdeclarator (const struct c_declarator *declarator,\n            /* It is fine to have 'extern const' when compiling at C\n               and C++ intersection.  */\n            if (!(warn_cxx_compat && constp))\n-             warning (0, \"%qE initialized and declared %<extern%>\", name);\n+             warning_at (loc, 0, \"%qE initialized and declared %<extern%>\",\n+\t\t \t name);\n          }\n       else\n-\terror (\"%qE has both %<extern%> and initializer\", name);\n+\terror_at (loc, \"%qE has both %<extern%> and initializer\", name);\n     }\n   else if (current_scope == file_scope)\n     {\n       if (storage_class == csc_auto)\n-\terror (\"file-scope declaration of %qE specifies %<auto%>\", name);\n+\terror_at (loc, \"file-scope declaration of %qE specifies %<auto%>\",\n+\t    \t  name);\n       if (pedantic && storage_class == csc_register)\n \tpedwarn (input_location, OPT_pedantic,\n \t\t \"file-scope declaration of %qE specifies %<register%>\", name);\n     }\n   else\n     {\n       if (storage_class == csc_extern && funcdef_flag)\n-\terror (\"nested function %qE declared %<extern%>\", name);\n+\terror_at (loc, \"nested function %qE declared %<extern%>\", name);\n       else if (threadp && storage_class == csc_none)\n \t{\n-\t  error (\"function-scope %qE implicitly auto and declared \"\n-\t\t \"%<__thread%>\",\n-\t\t name);\n+\t  error_at (loc, \"function-scope %qE implicitly auto and declared \"\n+\t\t    \"%<__thread%>\",\n+\t\t    name);\n \t  threadp = false;\n \t}\n     }\n@@ -4472,7 +4493,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \t  /* Only the innermost declarator (making a parameter be of\n \t     array type which is converted to pointer type)\n \t     may have static or type qualifiers.  */\n-\t  error (\"static or type qualifiers in non-parameter array declarator\");\n+\t  error_at (loc, \"static or type qualifiers in non-parameter array declarator\");\n \t  array_ptr_quals = TYPE_UNQUALIFIED;\n \t  array_ptr_attrs = NULL_TREE;\n \t  array_parm_static = 0;\n@@ -4520,23 +4541,25 @@ grokdeclarator (const struct c_declarator *declarator,\n \t    if (VOID_TYPE_P (type))\n \t      {\n \t\tif (name)\n-\t\t  error (\"declaration of %qE as array of voids\", name);\n+\t\t  error_at (loc, \"declaration of %qE as array of voids\", name);\n \t\telse\n-\t\t  error (\"declaration of type name as array of voids\");\n+\t\t  error_at (loc, \"declaration of type name as array of voids\");\n \t\ttype = error_mark_node;\n \t      }\n \n \t    if (TREE_CODE (type) == FUNCTION_TYPE)\n \t      {\n \t\tif (name)\n-\t\t  error (\"declaration of %qE as array of functions\", name);\n+\t\t  error_at (loc, \"declaration of %qE as array of functions\",\n+\t\t      \t    name);\n \t\telse\n-\t\t  error (\"declaration of type name as array of functions\");\n+\t\t  error_at (loc, \"declaration of type name as array of \"\n+\t\t            \"functions\");\n \t\ttype = error_mark_node;\n \t      }\n \n \t    if (pedantic && !in_system_header && flexible_array_type_p (type))\n-\t      pedwarn (input_location, OPT_pedantic,\n+\t      pedwarn (loc, OPT_pedantic,\n \t\t       \"invalid use of structure with flexible array member\");\n \n \t    if (size == error_mark_node)\n@@ -4563,9 +4586,11 @@ grokdeclarator (const struct c_declarator *declarator,\n \t\tif (!INTEGRAL_TYPE_P (TREE_TYPE (size)))\n \t\t  {\n \t\t    if (name)\n-\t\t      error (\"size of array %qE has non-integer type\", name);\n+\t\t      error_at (loc, \"size of array %qE has non-integer type\",\n+\t\t\t  \tname);\n \t\t    else\n-\t\t      error (\"size of unnamed array has non-integer type\");\n+\t\t      error_at (loc,\n+\t\t\t  \t\"size of unnamed array has non-integer type\");\n \t\t    size = integer_one_node;\n \t\t  }\n \n@@ -4574,10 +4599,10 @@ grokdeclarator (const struct c_declarator *declarator,\n \t\tif (pedantic && size_maybe_const && integer_zerop (size))\n \t\t  {\n \t\t    if (name)\n-\t\t      pedwarn (input_location, OPT_pedantic,\n+\t\t      pedwarn (loc, OPT_pedantic,\n \t\t\t       \"ISO C forbids zero-size array %qE\", name);\n \t\t    else\n-\t\t      pedwarn (input_location, OPT_pedantic,\n+\t\t      pedwarn (loc, OPT_pedantic,\n \t\t\t       \"ISO C forbids zero-size array\");\n \t\t  }\n \n@@ -4587,9 +4612,9 @@ grokdeclarator (const struct c_declarator *declarator,\n \t\t    if (tree_int_cst_sgn (size) < 0)\n \t\t      {\n \t\t\tif (name)\n-\t\t\t  error (\"size of array %qE is negative\", name);\n+\t\t\t  error_at (loc, \"size of array %qE is negative\", name);\n \t\t\telse\n-\t\t\t  error (\"size of unnamed array is negative\");\n+\t\t\t  error_at (loc, \"size of unnamed array is negative\");\n \t\t\tsize = integer_one_node;\n \t\t      }\n \t\t    /* Handle a size folded to an integer constant but\n@@ -4614,7 +4639,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \t\telse if ((decl_context == NORMAL || decl_context == FIELD)\n \t\t\t && current_scope == file_scope)\n \t\t  {\n-\t\t    error (\"variably modified %qE at file scope\", name);\n+\t\t    error_at (loc, \"variably modified %qE at file scope\", name);\n \t\t    size = integer_one_node;\n \t\t  }\n \t\telse\n@@ -4665,9 +4690,10 @@ grokdeclarator (const struct c_declarator *declarator,\n \t\t\t&& TREE_OVERFLOW (itype))\n \t\t      {\n \t\t\tif (name)\n-\t\t\t  error (\"size of array %qE is too large\", name);\n+\t\t\t  error_at (loc, \"size of array %qE is too large\",\n+\t\t\t            name);\n \t\t\telse\n-\t\t\t  error (\"size of unnamed array is too large\");\n+\t\t\t  error_at (loc, \"size of unnamed array is too large\");\n \t\t\ttype = error_mark_node;\n \t\t\tcontinue;\n \t\t      }\n@@ -4703,7 +4729,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \t\t  }\n \t\tif (flexible_array_member\n \t\t    && pedantic && !flag_isoc99 && !in_system_header)\n-\t\t  pedwarn (input_location, OPT_pedantic,\n+\t\t  pedwarn (loc, OPT_pedantic,\n \t\t\t   \"ISO C90 does not support flexible array members\");\n \n \t\t/* ISO C99 Flexible array members are effectively\n@@ -4738,7 +4764,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \t     /* Complain about arrays of incomplete types.  */\n \t    if (!COMPLETE_TYPE_P (type))\n \t      {\n-\t\terror (\"array type has incomplete element type\");\n+\t\terror_at (loc, \"array type has incomplete element type\");\n \t\ttype = error_mark_node;\n \t      }\n \t    else\n@@ -4788,7 +4814,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \t\t    || array_ptr_attrs != NULL_TREE\n \t\t    || array_parm_static))\n \t      {\n-\t\terror (\"static or type qualifiers in non-parameter array declarator\");\n+\t\terror_at (loc, \"static or type qualifiers in non-parameter array declarator\");\n \t\tarray_ptr_quals = TYPE_UNQUALIFIED;\n \t\tarray_ptr_attrs = NULL_TREE;\n \t\tarray_parm_static = 0;\n@@ -4821,19 +4847,21 @@ grokdeclarator (const struct c_declarator *declarator,\n \t    if (TREE_CODE (type) == FUNCTION_TYPE)\n \t      {\n \t\tif (name)\n-\t\t  error (\"%qE declared as function returning a function\",\n-\t\t\t name);\n+\t\t  error_at (loc, \"%qE declared as function returning a \"\n+\t\t      \t\t \"function\", name);\n \t\telse\n-\t\t  error (\"type name declared as function \"\n-\t\t\t \"returning a function\");\n+\t\t  error_at (loc, \"type name declared as function \"\n+\t\t\t    \"returning a function\");\n \t\ttype = integer_type_node;\n \t      }\n \t    if (TREE_CODE (type) == ARRAY_TYPE)\n \t      {\n \t\tif (name)\n-\t\t  error (\"%qE declared as function returning an array\", name);\n+\t\t  error_at (loc, \"%qE declared as function returning an array\",\n+\t\t      \t    name);\n \t\telse\n-\t\t  error (\"type name declared as function returning an array\");\n+\t\t  error_at (loc, \"type name declared as function returning \"\n+\t\t      \t    \"an array\");\n \t\ttype = integer_type_node;\n \t      }\n \t    errmsg = targetm.invalid_return_type (type);\n@@ -4861,10 +4889,10 @@ grokdeclarator (const struct c_declarator *declarator,\n \t\t   function definitions in ISO C; GCC used to used\n \t\t   them for noreturn functions.  */\n \t\tif (VOID_TYPE_P (type) && really_funcdef)\n-\t\t  pedwarn (input_location, 0,\n+\t\t  pedwarn (loc, 0,\n \t\t\t   \"function definition has qualified void return type\");\n \t\telse\n-\t\t  warning (OPT_Wignored_qualifiers,\n+\t\t  warning_at (loc, OPT_Wignored_qualifiers,\n \t\t\t   \"type qualifiers ignored on function return type\");\n \n \t\ttype = c_build_qualified_type (type, type_quals);\n@@ -4894,7 +4922,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \n \t    if (pedantic && TREE_CODE (type) == FUNCTION_TYPE\n \t\t&& type_quals)\n-\t      pedwarn (input_location, OPT_pedantic,\n+\t      pedwarn (loc, OPT_pedantic,\n \t\t       \"ISO C forbids qualified function types\");\n \t    if (type_quals)\n \t      type = c_build_qualified_type (type, type_quals);\n@@ -4927,10 +4955,10 @@ grokdeclarator (const struct c_declarator *declarator,\n \t\t&& (decl_context == NORMAL || decl_context == FIELD)\n \t\t&& variably_modified_type_p (type, NULL_TREE))\n \t      {\n-\t\ttree decl = build_decl (TYPE_DECL, NULL_TREE, type);\n+\t\ttree decl = build_decl (loc, TYPE_DECL, NULL_TREE, type);\n \t\tDECL_ARTIFICIAL (decl) = 1;\n \t\tpushdecl (decl);\n-\t\tfinish_decl (decl, NULL_TREE, NULL_TREE, NULL_TREE);\n+\t\tfinish_decl (decl, loc, NULL_TREE, NULL_TREE, NULL_TREE);\n \t\tTYPE_NAME (type) = decl;\n \t      }\n \n@@ -4964,9 +4992,9 @@ grokdeclarator (const struct c_declarator *declarator,\n       && TREE_OVERFLOW (TYPE_SIZE_UNIT (type)))\n     {\n       if (name)\n-\terror (\"size of array %qE is too large\", name);\n+\terror_at (loc, \"size of array %qE is too large\", name);\n       else\n-\terror (\"size of unnamed array is too large\");\n+\terror_at (loc, \"size of unnamed array is too large\");\n       /* If we proceed with the array type as it is, we'll eventually\n \t crash in tree_low_cst().  */\n       type = error_mark_node;\n@@ -4979,16 +5007,16 @@ grokdeclarator (const struct c_declarator *declarator,\n       tree decl;\n       if (pedantic && TREE_CODE (type) == FUNCTION_TYPE\n \t  && type_quals)\n-\tpedwarn (input_location, OPT_pedantic,\n+\tpedwarn (loc, OPT_pedantic,\n \t\t \"ISO C forbids qualified function types\");\n       if (type_quals)\n \ttype = c_build_qualified_type (type, type_quals);\n-      decl = build_decl (TYPE_DECL, declarator->u.id, type);\n-      DECL_SOURCE_LOCATION (decl) = declarator->id_loc;\n+      decl = build_decl (declarator->id_loc,\n+\t\t\t TYPE_DECL, declarator->u.id, type);\n       if (declspecs->explicit_signed_p)\n \tC_TYPEDEF_EXPLICITLY_SIGNED (decl) = 1;\n       if (declspecs->inline_p)\n-\tpedwarn (input_location, 0,\"typedef %q+D declared %<inline%>\", decl);\n+\tpedwarn (loc, 0,\"typedef %q+D declared %<inline%>\", decl);\n \n       if (warn_cxx_compat && declarator->u.id != NULL_TREE)\n \t{\n@@ -5023,7 +5051,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \t\t  && !declspecs->inline_p);\n       if (pedantic && TREE_CODE (type) == FUNCTION_TYPE\n \t  && type_quals)\n-\tpedwarn (input_location, OPT_pedantic,\n+\tpedwarn (loc, OPT_pedantic,\n \t\t \"ISO C forbids const or volatile function types\");\n       if (type_quals)\n \ttype = c_build_qualified_type (type, type_quals);\n@@ -5034,8 +5062,8 @@ grokdeclarator (const struct c_declarator *declarator,\n       && variably_modified_type_p (type, NULL_TREE))\n     {\n       /* C99 6.7.2.1p8 */\n-      pedwarn (input_location, OPT_pedantic, \n-\t       \"a member of a structure or union cannot have a variably modified type\");\n+      pedwarn (loc, OPT_pedantic, \"a member of a structure or union cannot \"\n+\t       \"have a variably modified type\");\n     }\n \n   /* Aside from typedefs and type names (handle above),\n@@ -5051,7 +5079,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \t\t    && !(storage_class == csc_static\n \t\t\t || storage_class == csc_register)))))\n     {\n-      error (\"variable or field %qE declared void\", name);\n+      error_at (loc, \"variable or field %qE declared void\", name);\n       type = integer_type_node;\n     }\n \n@@ -5081,15 +5109,15 @@ grokdeclarator (const struct c_declarator *declarator,\n \n \t    /* We don't yet implement attributes in this context.  */\n \t    if (array_ptr_attrs != NULL_TREE)\n-\t      warning (OPT_Wattributes,\n-\t\t       \"attributes in parameter array declarator ignored\");\n+\t      warning_at (loc, OPT_Wattributes,\n+\t\t\t  \"attributes in parameter array declarator ignored\");\n \n \t    size_varies = 0;\n \t  }\n \telse if (TREE_CODE (type) == FUNCTION_TYPE)\n \t  {\n \t    if (type_quals)\n-\t      pedwarn (input_location, OPT_pedantic,\n+\t      pedwarn (loc, OPT_pedantic,\n \t\t       \"ISO C forbids qualified function types\");\n \t    if (type_quals)\n \t      type = c_build_qualified_type (type, type_quals);\n@@ -5099,8 +5127,8 @@ grokdeclarator (const struct c_declarator *declarator,\n \telse if (type_quals)\n \t  type = c_build_qualified_type (type, type_quals);\n \n-\tdecl = build_decl (PARM_DECL, declarator->u.id, type);\n-\tDECL_SOURCE_LOCATION (decl) = declarator->id_loc;\n+\tdecl = build_decl (declarator->id_loc,\n+\t\t\t   PARM_DECL, declarator->u.id, type);\n \tif (size_varies)\n \t  C_DECL_VARIABLE_SIZE (decl) = 1;\n \n@@ -5116,7 +5144,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \n \tDECL_ARG_TYPE (decl) = promoted_type;\n \tif (declspecs->inline_p)\n-\t  pedwarn (input_location, 0, \"parameter %q+D declared %<inline%>\", decl);\n+\t  pedwarn (loc, 0, \"parameter %q+D declared %<inline%>\", decl);\n       }\n     else if (decl_context == FIELD)\n       {\n@@ -5129,21 +5157,21 @@ grokdeclarator (const struct c_declarator *declarator,\n \n \tif (TREE_CODE (type) == FUNCTION_TYPE)\n \t  {\n-\t    error (\"field %qE declared as a function\", name);\n+\t    error_at (loc, \"field %qE declared as a function\", name);\n \t    type = build_pointer_type (type);\n \t  }\n \telse if (TREE_CODE (type) != ERROR_MARK\n \t\t && !COMPLETE_OR_UNBOUND_ARRAY_TYPE_P (type))\n \t  {\n \t    if (name)\n-\t      error (\"field %qE has incomplete type\", name);\n+\t      error_at (loc, \"field %qE has incomplete type\", name);\n \t    else\n-\t      error (\"unnamed field has incomplete type\");\n+\t      error_at (loc, \"unnamed field has incomplete type\");\n \t    type = error_mark_node;\n \t  }\n \ttype = c_build_qualified_type (type, type_quals);\n-\tdecl = build_decl (FIELD_DECL, declarator->u.id, type);\n-\tDECL_SOURCE_LOCATION (decl) = declarator->id_loc;\n+\tdecl = build_decl (declarator->id_loc,\n+\t\t\t   FIELD_DECL, declarator->u.id, type);\n \tDECL_NONADDRESSABLE_P (decl) = bitfield;\n \tif (bitfield && !declarator->u.id)\n \t  TREE_NO_WARNING (decl) = 1;\n@@ -5155,7 +5183,7 @@ grokdeclarator (const struct c_declarator *declarator,\n       {\n \tif (storage_class == csc_register || threadp)\n \t  {\n-\t    error (\"invalid storage class for function %qE\", name);\n+\t    error_at (loc, \"invalid storage class for function %qE\", name);\n \t   }\n \telse if (current_scope != file_scope)\n \t  {\n@@ -5165,31 +5193,31 @@ grokdeclarator (const struct c_declarator *declarator,\n \t       GCC allows 'auto', perhaps with 'inline', to support\n \t       nested functions.  */\n \t    if (storage_class == csc_auto)\n-\t\tpedwarn (input_location, OPT_pedantic,\n+\t\tpedwarn (loc, OPT_pedantic,\n \t\t\t \"invalid storage class for function %qE\", name);\n \t    else if (storage_class == csc_static)\n \t      {\n-\t\terror (\"invalid storage class for function %qE\", name);\n+\t\terror_at (loc, \"invalid storage class for function %qE\", name);\n \t\tif (funcdef_flag)\n \t\t  storage_class = declspecs->storage_class = csc_none;\n \t\telse\n \t\t  return 0;\n \t      }\n \t  }\n \n-\tdecl = build_decl (FUNCTION_DECL, declarator->u.id, type);\n-\tDECL_SOURCE_LOCATION (decl) = declarator->id_loc;\n+\tdecl = build_decl (declarator->id_loc,\n+\t\t\t   FUNCTION_DECL, declarator->u.id, type);\n \tdecl = build_decl_attribute_variant (decl, decl_attr);\n \n \tif (pedantic && type_quals && !DECL_IN_SYSTEM_HEADER (decl))\n-\t  pedwarn (input_location, OPT_pedantic,\n+\t  pedwarn (loc, OPT_pedantic,\n \t\t   \"ISO C forbids qualified function types\");\n \n \t/* GNU C interprets a volatile-qualified function type to indicate\n \t   that the function does not return.  */\n \tif ((type_quals & TYPE_QUAL_VOLATILE)\n \t    && !VOID_TYPE_P (TREE_TYPE (TREE_TYPE (decl))))\n-\t  warning (0, \"%<noreturn%> function returns non-void value\");\n+\t  warning_at (loc, 0, \"%<noreturn%> function returns non-void value\");\n \n \t/* Every function declaration is an external reference\n \t   (DECL_EXTERNAL) except for those which are not at file\n@@ -5225,7 +5253,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \tif (flag_hosted && MAIN_NAME_P (declarator->u.id))\n \t  {\n \t    if (declspecs->inline_p)\n-\t      pedwarn (input_location, 0, \"cannot inline function %<main%>\");\n+\t      pedwarn (loc, 0, \"cannot inline function %<main%>\");\n \t  }\n \telse if (declspecs->inline_p)\n \t  /* Record that the function is declared `inline'.  */\n@@ -5254,17 +5282,17 @@ grokdeclarator (const struct c_declarator *declarator,\n \t\t&& global_decl != visible_decl\n \t\t&& TREE_CODE (global_decl) == VAR_DECL\n \t\t&& !TREE_PUBLIC (global_decl))\n-\t      error (\"variable previously declared %<static%> redeclared \"\n-\t\t     \"%<extern%>\");\n+\t      error_at (loc, \"variable previously declared %<static%> \"\n+\t\t\t\"redeclared %<extern%>\");\n \t  }\n \n-\tdecl = build_decl (VAR_DECL, declarator->u.id, type);\n-\tDECL_SOURCE_LOCATION (decl) = declarator->id_loc;\n+\tdecl = build_decl (declarator->id_loc,\n+\t\t\t   VAR_DECL, declarator->u.id, type);\n \tif (size_varies)\n \t  C_DECL_VARIABLE_SIZE (decl) = 1;\n \n \tif (declspecs->inline_p)\n-\t  pedwarn (input_location, 0, \"variable %q+D declared %<inline%>\", decl);\n+\t  pedwarn (loc, 0, \"variable %q+D declared %<inline%>\", decl);\n \n \t/* At file scope, an initialized extern declaration may follow\n \t   a static declaration.  In that case, DECL_EXTERNAL will be\n@@ -5299,9 +5327,10 @@ grokdeclarator (const struct c_declarator *declarator,\n       {\n \t/* C99 6.7.5.2p2 */\n \tif (TREE_CODE (type) == FUNCTION_TYPE)\n-\t  error (\"non-nested function with variably modified type\");\n+\t  error_at (loc, \"non-nested function with variably modified type\");\n \telse\n-\t  error (\"object with variably modified type must have no linkage\");\n+\t  error_at (loc, \"object with variably modified type must have \"\n+\t      \t    \"no linkage\");\n       }\n \n     /* Record `register' declaration for warnings on &\n@@ -5634,11 +5663,12 @@ get_parm_info (bool ellipsis)\n }\n \f\n /* Get the struct, enum or union (CODE says which) with tag NAME.\n-   Define the tag as a forward-reference if it is not defined.\n-   Return a c_typespec structure for the type specifier.  */\n+   Define the tag as a forward-reference with location LOC if it is\n+   not defined.  Return a c_typespec structure for the type\n+   specifier.  */\n \n struct c_typespec\n-parser_xref_tag (enum tree_code code, tree name, location_t loc)\n+parser_xref_tag (location_t loc, enum tree_code code, tree name)\n {\n   struct c_typespec ret;\n   tree ref;\n@@ -5717,7 +5747,7 @@ parser_xref_tag (enum tree_code code, tree name, location_t loc)\n       TYPE_MAX_VALUE (ref) = TYPE_MAX_VALUE (unsigned_type_node);\n     }\n \n-  pushtag (name, ref, loc);\n+  pushtag (loc, name, ref);\n \n   ret.spec = ref;\n   return ret;\n@@ -5730,11 +5760,12 @@ parser_xref_tag (enum tree_code code, tree name, location_t loc)\n tree\n xref_tag (enum tree_code code, tree name)\n {\n-  return parser_xref_tag (code, name, UNKNOWN_LOCATION).spec;\n+  return parser_xref_tag (input_location, code, name).spec;\n }\n \f\n /* Make sure that the tag NAME is defined *in the current scope*\n    at least as a forward reference.\n+   LOC is the location of the struct's definition.\n    CODE says which kind of tag NAME ought to be.\n \n    This stores the current value of the file static IN_STRUCT in\n@@ -5744,8 +5775,9 @@ xref_tag (enum tree_code code, tree name)\n    finish_struct.  */\n \n tree\n-start_struct (enum tree_code code, tree name, bool *enclosing_in_struct,\n-\t      VEC(tree,heap) **enclosing_struct_types, location_t loc)\n+start_struct (location_t loc, enum tree_code code, tree name,\n+    \t      bool *enclosing_in_struct,\n+\t      VEC(tree,heap) **enclosing_struct_types)\n {\n   /* If there is already a tag defined at this scope\n      (as a forward reference), just return it.  */\n@@ -5787,7 +5819,7 @@ start_struct (enum tree_code code, tree name, bool *enclosing_in_struct,\n   if (ref == NULL_TREE || TREE_CODE (ref) != code)\n     {\n       ref = make_node (code);\n-      pushtag (name, ref, loc);\n+      pushtag (loc, name, ref);\n     }\n \n   C_TYPE_BEING_DEFINED (ref) = 1;\n@@ -5881,7 +5913,7 @@ grokfield (location_t loc,\n \t\t\t  width ? &width : NULL, decl_attrs, NULL, NULL,\n \t\t\t  DEPRECATED_NORMAL);\n \n-  finish_decl (value, NULL_TREE, NULL_TREE, NULL_TREE);\n+  finish_decl (value, loc, NULL_TREE, NULL_TREE, NULL_TREE);\n   DECL_INITIAL (value) = width;\n \n   return value;\n@@ -5945,6 +5977,7 @@ detect_field_duplicates (tree fieldlist)\n }\n \n /* Fill in the fields of a RECORD_TYPE or UNION_TYPE node, T.\n+   LOC is the location of the RECORD_TYPE or UNION_TYPE's definition.\n    FIELDLIST is a chain of FIELD_DECL nodes for the fields.\n    ATTRIBUTES are attributes to be applied to the structure.\n \n@@ -5954,7 +5987,7 @@ detect_field_duplicates (tree fieldlist)\n    for any type defined in the current struct.  */\n \n tree\n-finish_struct (tree t, tree fieldlist, tree attributes,\n+finish_struct (location_t loc, tree t, tree fieldlist, tree attributes,\n \t       bool enclosing_in_struct,\n \t       VEC(tree,heap) *enclosing_struct_types)\n {\n@@ -5981,16 +6014,16 @@ finish_struct (tree t, tree fieldlist, tree attributes,\n \t  if (TREE_CODE (t) == UNION_TYPE)\n \t    {\n \t      if (fieldlist)\n-\t\tpedwarn (input_location, OPT_pedantic, \"union has no named members\");\n+\t\tpedwarn (loc, OPT_pedantic, \"union has no named members\");\n \t      else\n-\t\tpedwarn (input_location, OPT_pedantic, \"union has no members\");\n+\t\tpedwarn (loc, OPT_pedantic, \"union has no members\");\n \t    }\n \t  else\n \t    {\n \t      if (fieldlist)\n-\t\tpedwarn (input_location, OPT_pedantic, \"struct has no named members\");\n+\t\tpedwarn (loc, OPT_pedantic, \"struct has no named members\");\n \t      else\n-\t\tpedwarn (input_location, OPT_pedantic, \"struct has no members\");\n+\t\tpedwarn (loc, OPT_pedantic, \"struct has no members\");\n \t    }\n \t}\n     }\n@@ -6054,24 +6087,28 @@ finish_struct (tree t, tree fieldlist, tree attributes,\n \t{\n \t  if (TREE_CODE (t) == UNION_TYPE)\n \t    {\n-\t      error (\"%Jflexible array member in union\", x);\n+\t      error_at (DECL_SOURCE_LOCATION (x),\n+\t\t\t\"%Jflexible array member in union\", x);\n \t      TREE_TYPE (x) = error_mark_node;\n \t    }\n \t  else if (TREE_CHAIN (x) != NULL_TREE)\n \t    {\n-\t      error (\"%Jflexible array member not at end of struct\", x);\n+\t      error_at (DECL_SOURCE_LOCATION (x),\n+\t\t\t\"%Jflexible array member not at end of struct\", x);\n \t      TREE_TYPE (x) = error_mark_node;\n \t    }\n \t  else if (!saw_named_field)\n \t    {\n-\t      error (\"%Jflexible array member in otherwise empty struct\", x);\n+\t      error_at (DECL_SOURCE_LOCATION (x),\n+\t\t\t\"%Jflexible array member in otherwise empty struct\",\n+\t\t\tx);\n \t      TREE_TYPE (x) = error_mark_node;\n \t    }\n \t}\n \n       if (pedantic && !in_system_header && TREE_CODE (t) == RECORD_TYPE\n \t  && flexible_array_type_p (TREE_TYPE (x)))\n-\tpedwarn (input_location, OPT_pedantic, \n+\tpedwarn (loc, OPT_pedantic, \n \t\t \"%Jinvalid use of structure with flexible array member\", x);\n \n       if (DECL_NAME (x))\n@@ -6181,7 +6218,7 @@ finish_struct (tree t, tree fieldlist, tree attributes,\n       && (!TYPE_FIELDS (t) || TYPE_MODE (t) != DECL_MODE (TYPE_FIELDS (t))))\n     {\n       TYPE_TRANSPARENT_UNION (t) = 0;\n-      warning (0, \"union cannot be made transparent\");\n+      warning_at (loc, 0, \"union cannot be made transparent\");\n     }\n \n   /* If this structure or union completes the type of any previous\n@@ -6212,7 +6249,8 @@ finish_struct (tree t, tree fieldlist, tree attributes,\n      parsing parameters, then arrange for the size of a variable sized type\n      to be bound now.  */\n   if (cur_stmt_list && variably_modified_type_p (t, NULL_TREE))\n-    add_stmt (build_stmt (DECL_EXPR, build_decl (TYPE_DECL, NULL, t)));\n+    add_stmt (build_stmt (loc,\n+\t\t\t  DECL_EXPR, build_decl (loc, TYPE_DECL, NULL, t)));\n \n   /* Set the C_TYPE_DEFINED_IN_STRUCT flag for each type defined in\n      the current struct.  We do this now at the end of the struct\n@@ -6247,12 +6285,13 @@ layout_array_type (tree t)\n \f\n /* Begin compiling the definition of an enumeration type.\n    NAME is its name (or null if anonymous).\n+   LOC is the enum's location.\n    Returns the type object, as yet incomplete.\n    Also records info about it so that build_enumerator\n    may be used to declare the individual values as they are read.  */\n \n tree\n-start_enum (struct c_enum_contents *the_enum, tree name, location_t loc)\n+start_enum (location_t loc, struct c_enum_contents *the_enum, tree name)\n {\n   tree enumtype = NULL_TREE;\n   location_t enumloc = UNKNOWN_LOCATION;\n@@ -6267,7 +6306,7 @@ start_enum (struct c_enum_contents *the_enum, tree name, location_t loc)\n   if (enumtype == 0 || TREE_CODE (enumtype) != ENUMERAL_TYPE)\n     {\n       enumtype = make_node (ENUMERAL_TYPE);\n-      pushtag (name, enumtype, loc);\n+      pushtag (loc, name, enumtype);\n     }\n \n   if (C_TYPE_BEING_DEFINED (enumtype))\n@@ -6452,12 +6491,13 @@ finish_enum (tree enumtype, tree values, tree attributes)\n \n /* Build and install a CONST_DECL for one value of the\n    current enumeration type (one that was begun with start_enum).\n+   LOC is the location of the enumerator.\n    Return a tree-list containing the CONST_DECL and its value.\n    Assignment of sequential values by default is handled here.  */\n \n tree\n-build_enumerator (struct c_enum_contents *the_enum, tree name, tree value,\n-\t\t  location_t value_loc)\n+build_enumerator (location_t loc,\n+\t\t  struct c_enum_contents *the_enum, tree name, tree value)\n {\n   tree decl, type;\n \n@@ -6471,7 +6511,8 @@ build_enumerator (struct c_enum_contents *the_enum, tree name, tree value,\n \tvalue = 0;\n       else if (!INTEGRAL_TYPE_P (TREE_TYPE (value)))\n \t{\n-\t  error (\"enumerator value for %qE is not an integer constant\", name);\n+\t  error_at (loc, \"enumerator value for %qE is not an integer constant\",\n+\t\t    name);\n \t  value = 0;\n \t}\n       else\n@@ -6480,7 +6521,7 @@ build_enumerator (struct c_enum_contents *the_enum, tree name, tree value,\n \t    {\n \t      value = c_fully_fold (value, false, NULL);\n \t      if (TREE_CODE (value) == INTEGER_CST)\n-\t\tpedwarn (value_loc, OPT_pedantic,\n+\t\tpedwarn (loc, OPT_pedantic,\n \t\t\t \"enumerator value for %qE is not an integer \"\n \t\t\t \"constant expression\", name);\n \t    }\n@@ -6505,14 +6546,14 @@ build_enumerator (struct c_enum_contents *the_enum, tree name, tree value,\n     {\n       value = the_enum->enum_next_value;\n       if (the_enum->enum_overflow)\n-\terror (\"overflow in enumeration values\");\n+\terror_at (loc, \"overflow in enumeration values\");\n     }\n   /* Even though the underlying type of an enum is unspecified, the\n      type of enumeration constants is explicitly defined as int\n      (6.4.4.3/2 in the C99 Standard).  GCC allows any integer type as\n      an extension.  */\n   else if (!int_fits_type_p (value, integer_type_node))\n-    pedwarn (value_loc, OPT_pedantic, \n+    pedwarn (loc, OPT_pedantic, \n \t     \"ISO C restricts enumerator values to range of %<int%>\");\n \n   /* The ISO C Standard mandates enumerators to have type int, even\n@@ -6543,7 +6584,7 @@ build_enumerator (struct c_enum_contents *the_enum, tree name, tree value,\n \t\t\t\t  >= TYPE_PRECISION (integer_type_node)\n \t\t\t\t  && TYPE_UNSIGNED (type)));\n \n-  decl = build_decl (CONST_DECL, name, type);\n+  decl = build_decl (loc, CONST_DECL, name, type);\n   DECL_INITIAL (decl) = convert (type, value);\n   pushdecl (decl);\n \n@@ -6571,6 +6612,7 @@ start_function (struct c_declspecs *declspecs, struct c_declarator *declarator,\n   tree restype, resdecl;\n   struct c_label_context_se *nstack_se;\n   struct c_label_context_vm *nstack_vm;\n+  location_t loc;\n \n   current_function_returns_value = 0;  /* Assume, until we see it does.  */\n   current_function_returns_null = 0;\n@@ -6608,13 +6650,16 @@ start_function (struct c_declspecs *declspecs, struct c_declarator *declarator,\n       return 0;\n     }\n \n+  loc = DECL_SOURCE_LOCATION (decl1);\n+\n   decl_attributes (&decl1, attributes, 0);\n \n   if (DECL_DECLARED_INLINE_P (decl1)\n       && DECL_UNINLINABLE (decl1)\n       && lookup_attribute (\"noinline\", DECL_ATTRIBUTES (decl1)))\n-    warning (OPT_Wattributes, \"inline function %q+D given attribute noinline\",\n-\t     decl1);\n+    warning_at (loc, OPT_Wattributes,\n+\t\t\"inline function %qD given attribute noinline\",\n+\t\tdecl1);\n \n   /* Handle gnu_inline attribute.  */\n   if (declspecs->inline_p\n@@ -6631,15 +6676,15 @@ start_function (struct c_declspecs *declspecs, struct c_declarator *declarator,\n \n   if (!COMPLETE_OR_VOID_TYPE_P (TREE_TYPE (TREE_TYPE (decl1))))\n     {\n-      error (\"return type is an incomplete type\");\n+      error_at (loc, \"return type is an incomplete type\");\n       /* Make it return void instead.  */\n       TREE_TYPE (decl1)\n \t= build_function_type (void_type_node,\n \t\t\t       TYPE_ARG_TYPES (TREE_TYPE (decl1)));\n     }\n \n   if (warn_about_return_type)\n-    pedwarn_c99 (input_location, flag_isoc99 ? 0 \n+    pedwarn_c99 (loc, flag_isoc99 ? 0 \n \t\t : (warn_return_type ? OPT_Wreturn_type : OPT_Wimplicit_int),\n \t\t \"return type defaults to %<int%>\");\n \n@@ -6706,40 +6751,42 @@ start_function (struct c_declspecs *declspecs, struct c_declarator *declarator,\n       && old_decl != error_mark_node\n       && TYPE_ARG_TYPES (TREE_TYPE (decl1)) == 0\n       && C_DECL_ISNT_PROTOTYPE (old_decl))\n-    warning (OPT_Wstrict_prototypes,\n-\t     \"function declaration isn%'t a prototype\");\n+    warning_at (loc, OPT_Wstrict_prototypes,\n+\t\t\"function declaration isn%'t a prototype\");\n   /* Optionally warn of any global def with no previous prototype.  */\n   else if (warn_missing_prototypes\n \t   && old_decl != error_mark_node\n \t   && TREE_PUBLIC (decl1)\n \t   && !MAIN_NAME_P (DECL_NAME (decl1))\n \t   && C_DECL_ISNT_PROTOTYPE (old_decl))\n-    warning (OPT_Wmissing_prototypes, \"no previous prototype for %q+D\", decl1);\n+    warning_at (loc, OPT_Wmissing_prototypes,\n+\t\t\"no previous prototype for %qD\", decl1);\n   /* Optionally warn of any def with no previous prototype\n      if the function has already been used.  */\n   else if (warn_missing_prototypes\n \t   && old_decl != 0\n \t   && old_decl != error_mark_node\n \t   && TREE_USED (old_decl)\n \t   && TYPE_ARG_TYPES (TREE_TYPE (old_decl)) == 0)\n-    warning (OPT_Wmissing_prototypes,\n-\t     \"%q+D was used with no prototype before its definition\", decl1);\n+    warning_at (loc, OPT_Wmissing_prototypes,\n+\t\t\"%qD was used with no prototype before its definition\", decl1);\n   /* Optionally warn of any global def with no previous declaration.  */\n   else if (warn_missing_declarations\n \t   && TREE_PUBLIC (decl1)\n \t   && old_decl == 0\n \t   && !MAIN_NAME_P (DECL_NAME (decl1)))\n-    warning (OPT_Wmissing_declarations, \"no previous declaration for %q+D\",\n-\t     decl1);\n+    warning_at (loc, OPT_Wmissing_declarations,\n+\t\t\"no previous declaration for %qD\",\n+\t\tdecl1);\n   /* Optionally warn of any def with no previous declaration\n      if the function has already been used.  */\n   else if (warn_missing_declarations\n \t   && old_decl != 0\n \t   && old_decl != error_mark_node\n \t   && TREE_USED (old_decl)\n \t   && C_DECL_IMPLICIT (old_decl))\n-    warning (OPT_Wmissing_declarations,\n-\t     \"%q+D was used with no declaration before its definition\", decl1);\n+    warning_at (loc, OPT_Wmissing_declarations,\n+\t\t\"%qD was used with no declaration before its definition\", decl1);\n \n   /* This function exists in static storage.\n      (This does not mean `static' in the C sense!)  */\n@@ -6762,12 +6809,13 @@ start_function (struct c_declspecs *declspecs, struct c_declarator *declarator,\n     {\n       if (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (decl1)))\n \t  != integer_type_node)\n-\tpedwarn (input_location, OPT_Wmain, \"return type of %q+D is not %<int%>\", decl1);\n+\tpedwarn (loc, OPT_Wmain, \"return type of %qD is not %<int%>\", decl1);\n \n       check_main_parameter_types (decl1);\n \n       if (!TREE_PUBLIC (decl1))\n-\tpedwarn (input_location, OPT_Wmain, \"%q+D is normally a non-static function\", decl1);\n+\tpedwarn (loc, OPT_Wmain,\n+\t\t \"%qD is normally a non-static function\", decl1);\n     }\n \n   /* Record the decl so that the function name is defined.\n@@ -6780,7 +6828,7 @@ start_function (struct c_declspecs *declspecs, struct c_declarator *declarator,\n   declare_parm_level ();\n \n   restype = TREE_TYPE (TREE_TYPE (current_function_decl));\n-  resdecl = build_decl (RESULT_DECL, NULL_TREE, restype);\n+  resdecl = build_decl (loc, RESULT_DECL, NULL_TREE, restype);\n   DECL_ARTIFICIAL (resdecl) = 1;\n   DECL_IGNORED_P (resdecl) = 1;\n   DECL_RESULT (current_function_decl) = resdecl;\n@@ -6866,16 +6914,17 @@ store_parm_decls_oldstyle (tree fndecl, const struct c_arg_info *arg_info)\n   struct pointer_set_t *seen_args = pointer_set_create ();\n \n   if (!in_system_header)\n-    warning (OPT_Wold_style_definition, \"%Jold-style function definition\",\n-\t     fndecl);\n+    warning_at (DECL_SOURCE_LOCATION (fndecl),\n+\t\tOPT_Wold_style_definition, \"old-style function definition\");\n \n   /* Match each formal parameter name with its declaration.  Save each\n      decl in the appropriate TREE_PURPOSE slot of the parmids chain.  */\n   for (parm = parmids; parm; parm = TREE_CHAIN (parm))\n     {\n       if (TREE_VALUE (parm) == 0)\n \t{\n-\t  error (\"%Jparameter name missing from parameter list\", fndecl);\n+\t  error_at (DECL_SOURCE_LOCATION (fndecl),\n+\t\t    \"parameter name missing from parameter list\");\n \t  TREE_PURPOSE (parm) = 0;\n \t  continue;\n \t}\n@@ -6886,20 +6935,23 @@ store_parm_decls_oldstyle (tree fndecl, const struct c_arg_info *arg_info)\n \t  decl = b->decl;\n \t  /* If we got something other than a PARM_DECL it is an error.  */\n \t  if (TREE_CODE (decl) != PARM_DECL)\n-\t    error (\"%q+D declared as a non-parameter\", decl);\n+\t    error_at (DECL_SOURCE_LOCATION (decl),\n+\t\t      \"%qD declared as a non-parameter\", decl);\n \t  /* If the declaration is already marked, we have a duplicate\n \t     name.  Complain and ignore the duplicate.  */\n \t  else if (pointer_set_contains (seen_args, decl))\n \t    {\n-\t      error (\"multiple parameters named %q+D\", decl);\n+\t      error_at (DECL_SOURCE_LOCATION (decl),\n+\t\t\t\"multiple parameters named %qD\", decl);\n \t      TREE_PURPOSE (parm) = 0;\n \t      continue;\n \t    }\n \t  /* If the declaration says \"void\", complain and turn it into\n \t     an int.  */\n \t  else if (VOID_TYPE_P (TREE_TYPE (decl)))\n \t    {\n-\t      error (\"parameter %q+D declared with void type\", decl);\n+\t      error_at (DECL_SOURCE_LOCATION (decl),\n+\t\t\t\"parameter %qD declared with void type\", decl);\n \t      TREE_TYPE (decl) = integer_type_node;\n \t      DECL_ARG_TYPE (decl) = integer_type_node;\n \t      layout_decl (decl, 0);\n@@ -6909,16 +6961,30 @@ store_parm_decls_oldstyle (tree fndecl, const struct c_arg_info *arg_info)\n       /* If no declaration found, default to int.  */\n       else\n \t{\n-\t  decl = build_decl (PARM_DECL, TREE_VALUE (parm), integer_type_node);\n+\t  /* FIXME diagnostics: This should be the location of the argument,\n+\t     not the FNDECL.  E.g., for an old-style declaration\n+\n+\t       int f10(v) { blah; }\n+\n+\t     We should use the location of the V, not the F10.\n+\t     Unfortunately, the V is an IDENTIFIER_NODE which has no\n+\t     location.  In the future we need locations for c_arg_info\n+\t     entries.\n+\n+\t     See gcc.dg/Wshadow-3.c for an example of this problem. */\n+\t  decl = build_decl (DECL_SOURCE_LOCATION (fndecl),\n+\t\t\t     PARM_DECL, TREE_VALUE (parm), integer_type_node);\n \t  DECL_ARG_TYPE (decl) = TREE_TYPE (decl);\n-\t  DECL_SOURCE_LOCATION (decl) = DECL_SOURCE_LOCATION (fndecl);\n \t  pushdecl (decl);\n \t  warn_if_shadowing (decl);\n \n \t  if (flag_isoc99)\n-\t    pedwarn (input_location, 0, \"type of %q+D defaults to %<int%>\", decl);\n+\t    pedwarn (DECL_SOURCE_LOCATION (decl),\n+\t\t     0, \"type of %qD defaults to %<int%>\", decl);\n \t  else \n-\t    warning (OPT_Wmissing_parameter_type, \"type of %q+D defaults to %<int%>\", decl);\n+\t    warning_at (DECL_SOURCE_LOCATION (decl),\n+\t\t\tOPT_Wmissing_parameter_type,\n+\t\t\t\"type of %qD defaults to %<int%>\", decl);\n \t}\n \n       TREE_PURPOSE (parm) = decl;\n@@ -6937,13 +7003,16 @@ store_parm_decls_oldstyle (tree fndecl, const struct c_arg_info *arg_info)\n       if (TREE_TYPE (parm) != error_mark_node\n \t  && !COMPLETE_TYPE_P (TREE_TYPE (parm)))\n \t{\n-\t  error (\"parameter %q+D has incomplete type\", parm);\n+\t  error_at (DECL_SOURCE_LOCATION (parm),\n+\t\t    \"parameter %qD has incomplete type\", parm);\n \t  TREE_TYPE (parm) = error_mark_node;\n \t}\n \n       if (!pointer_set_contains (seen_args, parm))\n \t{\n-\t  error (\"declaration for parameter %q+D but no such parameter\", parm);\n+\t  error_at (DECL_SOURCE_LOCATION (parm),\n+\t\t    \"declaration for parameter %qD but no such parameter\",\n+\t\t    parm);\n \n \t  /* Pretend the parameter was not missing.\n \t     This gets us to a standard state and minimizes\n@@ -6993,13 +7062,22 @@ store_parm_decls_oldstyle (tree fndecl, const struct c_arg_info *arg_info)\n \t      || TYPE_MAIN_VARIANT (TREE_VALUE (type)) == void_type_node)\n \t    {\n \t      if (current_function_prototype_built_in)\n-\t\twarning (0, \"number of arguments doesn%'t match \"\n-\t\t\t \"built-in prototype\");\n+\t\twarning_at (DECL_SOURCE_LOCATION (fndecl),\n+\t\t\t    0, \"number of arguments doesn%'t match \"\n+\t\t\t    \"built-in prototype\");\n \t      else\n \t\t{\n-\t\t  error (\"number of arguments doesn%'t match prototype\");\n-\t\t  error (\"%Hprototype declaration\",\n-\t\t\t &current_function_prototype_locus);\n+\t\t  /* FIXME diagnostics: This should be the location of\n+\t\t     FNDECL, but there is bug when a prototype is\n+\t\t     declared inside function context, but defined\n+\t\t     outside of it (e.g., gcc.dg/pr15698-2.c).  In\n+\t\t     which case FNDECL gets the location of the\n+\t\t     prototype, not the definition.  */\n+\t\t  error_at (input_location,\n+\t\t\t    \"number of arguments doesn%'t match prototype\");\n+\n+\t\t  error_at (current_function_prototype_locus,\n+\t\t\t    \"prototype declaration\");\n \t\t}\n \t      break;\n \t    }\n@@ -7032,11 +7110,13 @@ store_parm_decls_oldstyle (tree fndecl, const struct c_arg_info *arg_info)\n \t\t     been diagnosed as conflicting with an\n \t\t     old-style definition and discarded?  */\n \t\t  if (current_function_prototype_built_in)\n-\t\t    warning (OPT_pedantic, \"promoted argument %qD \"\n-\t\t\t     \"doesn%'t match built-in prototype\", parm);\n+\t\t    warning_at (DECL_SOURCE_LOCATION (parm),\n+\t\t\t\tOPT_pedantic, \"promoted argument %qD \"\n+\t\t\t\t\"doesn%'t match built-in prototype\", parm);\n \t\t  else\n \t\t    {\n-\t\t      pedwarn (input_location, OPT_pedantic, \"promoted argument %qD \"\n+\t\t      pedwarn (DECL_SOURCE_LOCATION (parm),\n+\t\t\t       OPT_pedantic, \"promoted argument %qD \"\n \t\t\t       \"doesn%'t match prototype\", parm);\n \t\t      pedwarn (current_function_prototype_locus, OPT_pedantic,\n \t\t\t       \"prototype declaration\");\n@@ -7045,13 +7125,15 @@ store_parm_decls_oldstyle (tree fndecl, const struct c_arg_info *arg_info)\n \t      else\n \t\t{\n \t\t  if (current_function_prototype_built_in)\n-\t\t    warning (0, \"argument %qD doesn%'t match \"\n-\t\t\t     \"built-in prototype\", parm);\n+\t\t    warning_at (DECL_SOURCE_LOCATION (parm),\n+\t\t\t\t0, \"argument %qD doesn%'t match \"\n+\t\t\t\t\"built-in prototype\", parm);\n \t\t  else\n \t\t    {\n-\t\t      error (\"argument %qD doesn%'t match prototype\", parm);\n-\t\t      error (\"%Hprototype declaration\",\n-\t\t\t     &current_function_prototype_locus);\n+\t\t      error_at (DECL_SOURCE_LOCATION (parm),\n+\t\t\t\t\"argument %qD doesn%'t match prototype\", parm);\n+\t\t      error_at (current_function_prototype_locus,\n+\t\t\t\t\"prototype declaration\");\n \t\t    }\n \t\t}\n \t    }\n@@ -7228,14 +7310,13 @@ finish_function (void)\n       && TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (fndecl)))\n       == integer_type_node && flag_isoc99)\n     {\n-      tree stmt = c_finish_return (integer_zero_node, NULL_TREE);\n       /* Hack.  We don't want the middle-end to warn that this return\n \t is unreachable, so we mark its location as special.  Using\n \t UNKNOWN_LOCATION has the problem that it gets clobbered in\n \t annotate_one_with_locus.  A cleaner solution might be to\n \t ensure ! should_carry_locus_p (stmt), but that needs a flag.\n       */\n-      SET_EXPR_LOCATION (stmt, BUILTINS_LOCATION);\n+      c_finish_return (BUILTINS_LOCATION, integer_zero_node, NULL_TREE);\n     }\n \n   /* Tie off the statement tree for this function.  */\n@@ -7315,10 +7396,11 @@ finish_function (void)\n }\n \f\n /* Check the declarations given in a for-loop for satisfying the C99\n-   constraints.  If exactly one such decl is found, return it.  */\n+   constraints.  If exactly one such decl is found, return it.  LOC is\n+   the location of the opening parenthesis of the for loop.  */\n \n tree\n-check_for_loop_decls (void)\n+check_for_loop_decls (location_t loc)\n {\n   struct c_binding *b;\n   tree one_decl = NULL_TREE;\n@@ -7330,10 +7412,11 @@ check_for_loop_decls (void)\n       /* If we get here, declarations have been used in a for loop without\n \t the C99 for loop scope.  This doesn't make much sense, so don't\n \t allow it.  */\n-      error (\"%<for%> loop initial declarations are only allowed in C99 mode\");\n+      error_at (loc, \"%<for%> loop initial declarations \"\n+\t\t\"are only allowed in C99 mode\");\n       if (hint)\n \t{\n-\t  inform (input_location, \n+\t  inform (loc,\n \t\t  \"use option -std=c99 or -std=gnu99 to compile your code\");\n \t  hint = false;\n \t}\n@@ -7364,29 +7447,36 @@ check_for_loop_decls (void)\n       switch (TREE_CODE (decl))\n \t{\n \tcase VAR_DECL:\n-\t  if (TREE_STATIC (decl))\n-\t    error (\"declaration of static variable %q+D in %<for%> loop \"\n-\t\t   \"initial declaration\", decl);\n-\t  else if (DECL_EXTERNAL (decl))\n-\t    error (\"declaration of %<extern%> variable %q+D in %<for%> loop \"\n-\t\t   \"initial declaration\", decl);\n+\t  {\n+\t    location_t decl_loc = DECL_SOURCE_LOCATION (decl);\n+\t    if (TREE_STATIC (decl))\n+\t      error_at (decl_loc,\n+\t\t\t\"declaration of static variable %qD in %<for%> loop \"\n+\t\t\t\"initial declaration\", decl);\n+\t    else if (DECL_EXTERNAL (decl))\n+\t      error_at (decl_loc,\n+\t\t\t\"declaration of %<extern%> variable %qD in %<for%> loop \"\n+\t\t\t\"initial declaration\", decl);\n+\t  }\n \t  break;\n \n \tcase RECORD_TYPE:\n-\t  error (\"%<struct %E%> declared in %<for%> loop initial declaration\",\n-\t\t id);\n+\t  error_at (loc,\n+\t\t    \"%<struct %E%> declared in %<for%> loop initial \"\n+\t\t    \"declaration\", id);\n \t  break;\n \tcase UNION_TYPE:\n-\t  error (\"%<union %E%> declared in %<for%> loop initial declaration\",\n-\t\t id);\n+\t  error_at (loc,\n+\t\t    \"%<union %E%> declared in %<for%> loop initial declaration\",\n+\t\t    id);\n \t  break;\n \tcase ENUMERAL_TYPE:\n-\t  error (\"%<enum %E%> declared in %<for%> loop initial declaration\",\n-\t\t id);\n+\t  error_at (loc, \"%<enum %E%> declared in %<for%> loop \"\n+\t\t    \"initial declaration\", id);\n \t  break;\n \tdefault:\n-\t  error (\"declaration of non-variable %q+D in %<for%> loop \"\n-\t\t \"initial declaration\", decl);\n+\t  error_at (loc, \"declaration of non-variable \"\n+\t\t    \"%qD in %<for%> loop initial declaration\", decl);\n \t}\n \n       n_decls++;\n@@ -7506,7 +7596,7 @@ record_builtin_type (enum rid rid_index, const char *name, tree type)\n     id = ridpointers[(int) rid_index];\n   else\n     id = get_identifier (name);\n-  decl = build_decl (TYPE_DECL, id, type);\n+  decl = build_decl (UNKNOWN_LOCATION, TYPE_DECL, id, type);\n   pushdecl (decl);\n   if (debug_hooks->type_decl)\n     debug_hooks->type_decl (decl, false);"}, {"sha": "6595fc8fa03de5727ff7bd39c5cae68b7cf0d0b2", "filename": "gcc/c-gimplify.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fc-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fc-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-gimplify.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -140,7 +140,7 @@ add_block_to_enclosing (tree block)\n      genericized.  */\n \n tree\n-c_build_bind_expr (tree block, tree body)\n+c_build_bind_expr (location_t loc, tree block, tree body)\n {\n   tree decls, bind;\n \n@@ -162,11 +162,12 @@ c_build_bind_expr (tree block, tree body)\n     }\n \n   if (!body)\n-    body = build_empty_stmt ();\n+    body = build_empty_stmt (loc);\n   if (decls || block)\n     {\n       bind = build3 (BIND_EXPR, void_type_node, decls, body, block);\n       TREE_SIDE_EFFECTS (bind) = 1;\n+      SET_EXPR_LOCATION (bind, loc);\n     }\n   else\n     bind = body;"}, {"sha": "5ec9f94ff6818a51c64dfb2ebfa4b199ecdc9142", "filename": "gcc/c-omp.c", "status": "modified", "additions": 53, "deletions": 33, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fc-omp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fc-omp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-omp.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -35,72 +35,81 @@ along with GCC; see the file COPYING3.  If not see\n \n \n /* Complete a #pragma omp master construct.  STMT is the structured-block\n-   that follows the pragma.  */\n+   that follows the pragma.  LOC is the l*/\n \n tree\n-c_finish_omp_master (tree stmt)\n+c_finish_omp_master (location_t loc, tree stmt)\n {\n-  return add_stmt (build1 (OMP_MASTER, void_type_node, stmt));\n+  tree t = add_stmt (build1 (OMP_MASTER, void_type_node, stmt));\n+  SET_EXPR_LOCATION (t, loc);\n+  return t;\n }\n \n /* Complete a #pragma omp critical construct.  STMT is the structured-block\n    that follows the pragma, NAME is the identifier in the pragma, or null\n-   if it was omitted.  */\n+   if it was omitted.  LOC is the location of the #pragma.  */\n \n tree\n-c_finish_omp_critical (tree body, tree name)\n+c_finish_omp_critical (location_t loc, tree body, tree name)\n {\n   tree stmt = make_node (OMP_CRITICAL);\n   TREE_TYPE (stmt) = void_type_node;\n   OMP_CRITICAL_BODY (stmt) = body;\n   OMP_CRITICAL_NAME (stmt) = name;\n+  SET_EXPR_LOCATION (stmt, loc);\n   return add_stmt (stmt);\n }\n \n /* Complete a #pragma omp ordered construct.  STMT is the structured-block\n-   that follows the pragma.  */\n+   that follows the pragma.  LOC is the location of the #pragma.  */\n \n tree\n-c_finish_omp_ordered (tree stmt)\n+c_finish_omp_ordered (location_t loc, tree stmt)\n {\n-  return add_stmt (build1 (OMP_ORDERED, void_type_node, stmt));\n+  tree t = build1 (OMP_ORDERED, void_type_node, stmt);\n+  SET_EXPR_LOCATION (t, loc);\n+  return add_stmt (t);\n }\n \n \n-/* Complete a #pragma omp barrier construct.  */\n+/* Complete a #pragma omp barrier construct.  LOC is the location of\n+   the #pragma.  */\n \n void\n-c_finish_omp_barrier (void)\n+c_finish_omp_barrier (location_t loc)\n {\n   tree x;\n \n   x = built_in_decls[BUILT_IN_GOMP_BARRIER];\n   x = build_call_expr (x, 0);\n+  SET_EXPR_LOCATION (x, loc);\n   add_stmt (x);\n }\n \n \n-/* Complete a #pragma omp taskwait construct.  */\n+/* Complete a #pragma omp taskwait construct.  LOC is the location of the\n+   pragma.  */\n \n void\n-c_finish_omp_taskwait (void)\n+c_finish_omp_taskwait (location_t loc)\n {\n   tree x;\n \n   x = built_in_decls[BUILT_IN_GOMP_TASKWAIT];\n   x = build_call_expr (x, 0);\n+  SET_EXPR_LOCATION (x, loc);\n   add_stmt (x);\n }\n \n \n-/* Complete a #pragma omp atomic construct.  The expression to be \n-   implemented atomically is LHS code= RHS.  The value returned is\n-   either error_mark_node (if the construct was erroneous) or an\n-   OMP_ATOMIC node which should be added to the current statement tree\n-   with add_stmt.  */\n+/* Complete a #pragma omp atomic construct.  The expression to be\n+   implemented atomically is LHS code= RHS.  LOC is the location of\n+   the atomic statement.  The value returned is either error_mark_node\n+   (if the construct was erroneous) or an OMP_ATOMIC node which should\n+   be added to the current statement tree with add_stmt.*/\n \n tree\n-c_finish_omp_atomic (enum tree_code code, tree lhs, tree rhs)\n+c_finish_omp_atomic (location_t loc, enum tree_code code, tree lhs, tree rhs)\n {\n   tree x, type, addr;\n \n@@ -116,15 +125,15 @@ c_finish_omp_atomic (enum tree_code code, tree lhs, tree rhs)\n       && !POINTER_TYPE_P (type)\n       && !SCALAR_FLOAT_TYPE_P (type))\n     {\n-      error (\"invalid expression type for %<#pragma omp atomic%>\");\n+      error_at (loc, \"invalid expression type for %<#pragma omp atomic%>\");\n       return error_mark_node;\n     }\n \n   /* ??? Validate that rhs does not overlap lhs.  */\n \n   /* Take and save the address of the lhs.  From then on we'll reference it\n      via indirection.  */\n-  addr = build_unary_op (input_location, ADDR_EXPR, lhs, 0);\n+  addr = build_unary_op (loc, ADDR_EXPR, lhs, 0);\n   if (addr == error_mark_node)\n     return error_mark_node;\n   addr = save_expr (addr);\n@@ -137,32 +146,37 @@ c_finish_omp_atomic (enum tree_code code, tree lhs, tree rhs)\n       tree var = create_tmp_var_raw (TREE_TYPE (addr), NULL);\n       addr = build4 (TARGET_EXPR, TREE_TYPE (addr), var, addr, NULL, NULL);\n     }\n-  lhs = build_indirect_ref (input_location, addr, NULL);\n+  lhs = build_indirect_ref (loc, addr, NULL);\n \n   /* There are lots of warnings, errors, and conversions that need to happen\n      in the course of interpreting a statement.  Use the normal mechanisms\n      to do this, and then take it apart again.  */\n-  x = build_modify_expr (input_location, lhs, NULL_TREE, code, rhs, NULL_TREE);\n+  x = build_modify_expr (input_location, lhs, NULL_TREE, code,\n+      \t\t\t input_location, rhs, NULL_TREE);\n   if (x == error_mark_node)\n     return error_mark_node;\n   gcc_assert (TREE_CODE (x) == MODIFY_EXPR);  \n   rhs = TREE_OPERAND (x, 1);\n \n   /* Punt the actual generation of atomic operations to common code.  */\n-  return build2 (OMP_ATOMIC, void_type_node, addr, rhs);\n+  x = build2 (OMP_ATOMIC, void_type_node, addr, rhs);\n+  SET_EXPR_LOCATION (x, loc);\n+  return x;\n }\n \n \n-/* Complete a #pragma omp flush construct.  We don't do anything with the\n-   variable list that the syntax allows.  */\n+/* Complete a #pragma omp flush construct.  We don't do anything with\n+   the variable list that the syntax allows.  LOC is the location of\n+   the #pragma.  */\n \n void\n-c_finish_omp_flush (void)\n+c_finish_omp_flush (location_t loc)\n {\n   tree x;\n \n   x = built_in_decls[BUILT_IN_SYNCHRONIZE];\n   x = build_call_expr (x, 0);\n+  SET_EXPR_LOCATION (x, loc);\n   add_stmt (x);\n }\n \n@@ -260,7 +274,11 @@ c_finish_omp_for (location_t locus, tree declv, tree initv, tree condv,\n \t      fail = true;\n \t    }\n \n-\t  init = build_modify_expr (elocus, decl, NULL_TREE, NOP_EXPR, init,\n+\t  init = build_modify_expr (elocus, decl, NULL_TREE, NOP_EXPR, \n+\t      \t\t\t    /* FIXME diagnostics: This should\n+\t\t\t\t       be the location of the INIT.  */\n+\t      \t\t\t    elocus,\n+\t\t\t\t    init,\n \t\t\t\t    NULL_TREE);\n \t}\n       gcc_assert (TREE_CODE (init) == MODIFY_EXPR);\n@@ -448,18 +466,20 @@ c_finish_omp_for (location_t locus, tree declv, tree initv, tree condv,\n }\n \n \n-/* Divide CLAUSES into two lists: those that apply to a parallel construct,\n-   and those that apply to a work-sharing construct.  Place the results in\n-   *PAR_CLAUSES and *WS_CLAUSES respectively.  In addition, add a nowait\n-   clause to the work-sharing list.  */\n+/* Divide CLAUSES into two lists: those that apply to a parallel\n+   construct, and those that apply to a work-sharing construct.  Place\n+   the results in *PAR_CLAUSES and *WS_CLAUSES respectively.  In\n+   addition, add a nowait clause to the work-sharing list.  LOC is the\n+   location of the OMP_PARALLEL*.  */\n \n void\n-c_split_parallel_clauses (tree clauses, tree *par_clauses, tree *ws_clauses)\n+c_split_parallel_clauses (location_t loc, tree clauses,\n+\t\t\t  tree *par_clauses, tree *ws_clauses)\n {\n   tree next;\n \n   *par_clauses = NULL;\n-  *ws_clauses = build_omp_clause (OMP_CLAUSE_NOWAIT);\n+  *ws_clauses = build_omp_clause (loc, OMP_CLAUSE_NOWAIT);\n \n   for (; clauses ; clauses = next)\n     {"}, {"sha": "6c7b8308b285336ba15566205ac2d49376e48415", "filename": "gcc/c-parser.c", "status": "modified", "additions": 373, "deletions": 235, "changes": 608, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parser.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -916,6 +916,7 @@ static struct c_expr c_parser_postfix_expression_after_paren_type (c_parser *,\n \t\t\t\t\t\t\t\t   struct c_type_name *,\n \t\t\t\t\t\t\t\t   location_t);\n static struct c_expr c_parser_postfix_expression_after_primary (c_parser *,\n+\t\t\t\t\t\t\t\tlocation_t loc,\n \t\t\t\t\t\t\t\tstruct c_expr);\n static struct c_expr c_parser_expression (c_parser *);\n static struct c_expr c_parser_expression_conv (c_parser *);\n@@ -1224,6 +1225,7 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok, bool empty_ok,\n \t    {\n \t      tree d;\n \t      struct c_expr init;\n+\t      location_t init_loc;\n \t      c_parser_consume_token (parser);\n \t      /* The declaration of the variable is in effect while\n \t\t its initializer is parsed.  */\n@@ -1232,12 +1234,14 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok, bool empty_ok,\n \t      if (!d)\n \t\td = error_mark_node;\n \t      start_init (d, asm_name, global_bindings_p ());\n+\t      init_loc = c_parser_peek_token (parser)->location;\n \t      init = c_parser_initializer (parser);\n \t      finish_init ();\n \t      if (d != error_mark_node)\n \t\t{\n \t\t  maybe_warn_string_init (TREE_TYPE (d), init);\n-\t\t  finish_decl (d, init.value, init.original_type, asm_name);\n+\t\t  finish_decl (d, init_loc, init.value,\n+\t\t      \t       init.original_type, asm_name);\n \t\t}\n \t    }\n \t  else\n@@ -1246,7 +1250,8 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok, bool empty_ok,\n \t\t\t\t   chainon (postfix_attrs,\n \t\t\t\t\t    all_prefix_attrs));\n \t      if (d)\n-\t\tfinish_decl (d, NULL_TREE, NULL_TREE, asm_name);\n+\t\tfinish_decl (d, UNKNOWN_LOCATION, NULL_TREE,\n+\t\t    \t     NULL_TREE, asm_name);\n \t    }\n \t  if (c_parser_next_token_is (parser, CPP_COMMA))\n \t    {\n@@ -1319,7 +1324,7 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok, bool empty_ok,\n \t  add_stmt (fnbody);\n \t  finish_function ();\n \t  c_pop_function_context ();\n-\t  add_stmt (build_stmt (DECL_EXPR, decl));\n+\t  add_stmt (build_stmt (DECL_SOURCE_LOCATION (decl), DECL_EXPR, decl));\n \t}\n       else\n \t{\n@@ -1628,6 +1633,7 @@ c_parser_enum_specifier (c_parser *parser)\n   enum_loc = c_parser_peek_token (parser)->location;\n   c_parser_consume_token (parser);\n   attrs = c_parser_attributes (parser);\n+  enum_loc = c_parser_peek_token (parser)->location;\n   /* Set the location in case we create a decl now.  */\n   c_parser_set_source_position_from_token (c_parser_peek_token (parser));\n   if (c_parser_next_token_is (parser, CPP_NAME))\n@@ -1641,7 +1647,7 @@ c_parser_enum_specifier (c_parser *parser)\n     {\n       /* Parse an enum definition.  */\n       struct c_enum_contents the_enum;\n-      tree type = start_enum (&the_enum, ident, enum_loc);\n+      tree type = start_enum (enum_loc, &the_enum, ident);\n       tree postfix_attrs;\n       /* We chain the enumerators in reverse order, then put them in\n \t forward order at the end.  */\n@@ -1677,8 +1683,8 @@ c_parser_enum_specifier (c_parser *parser)\n \t    }\n \t  else\n \t    enum_value = NULL_TREE;\n-\t  enum_decl = build_enumerator (&the_enum, enum_id, enum_value, \n-\t\t\t\t\tvalue_loc);\n+\t  enum_decl = build_enumerator (value_loc,\n+\t      \t\t\t\t&the_enum, enum_id, enum_value);\n \t  TREE_CHAIN (enum_decl) = values;\n \t  values = enum_decl;\n \t  seen_comma = false;\n@@ -1720,13 +1726,13 @@ c_parser_enum_specifier (c_parser *parser)\n       ret.expr_const_operands = true;\n       return ret;\n     }\n-  ret = parser_xref_tag (ENUMERAL_TYPE, ident, ident_loc);\n+  ret = parser_xref_tag (ident_loc, ENUMERAL_TYPE, ident);\n   /* In ISO C, enumerated types can be referred to only if already\n      defined.  */\n   if (pedantic && !COMPLETE_TYPE_P (ret.spec))\n     {\n       gcc_assert (ident);\n-      pedwarn (ident_loc, OPT_pedantic,\n+      pedwarn (enum_loc, OPT_pedantic,\n \t       \"ISO C forbids forward references to %<enum%> types\");\n     }\n   return ret;\n@@ -1794,8 +1800,10 @@ c_parser_struct_or_union_specifier (c_parser *parser)\n   struct_loc = c_parser_peek_token (parser)->location;\n   c_parser_consume_token (parser);\n   attrs = c_parser_attributes (parser);\n+\n   /* Set the location in case we create a decl now.  */\n   c_parser_set_source_position_from_token (c_parser_peek_token (parser));\n+\n   if (c_parser_next_token_is (parser, CPP_NAME))\n     {\n       ident = c_parser_peek_token (parser)->value;\n@@ -1809,8 +1817,8 @@ c_parser_struct_or_union_specifier (c_parser *parser)\n \t tag before parsing components.  */\n       bool in_struct;\n       VEC(tree,heap) *struct_types;\n-      tree type = start_struct (code, ident, &in_struct, &struct_types,\n-\t\t\t\tstruct_loc);\n+      tree type = start_struct (struct_loc, code, ident,\n+\t  \t\t\t&in_struct, &struct_types);\n       tree postfix_attrs;\n       /* We chain the components in reverse order, then put them in\n \t forward order at the end.  Each struct-declaration may\n@@ -1899,7 +1907,7 @@ c_parser_struct_or_union_specifier (c_parser *parser)\n \t    }\n \t}\n       postfix_attrs = c_parser_attributes (parser);\n-      ret.spec = finish_struct (type, nreverse (contents),\n+      ret.spec = finish_struct (struct_loc, type, nreverse (contents),\n \t\t\t\tchainon (attrs, postfix_attrs),\n \t\t\t\tin_struct, struct_types);\n       ret.kind = ctsk_tagdef;\n@@ -1916,7 +1924,7 @@ c_parser_struct_or_union_specifier (c_parser *parser)\n       ret.expr_const_operands = true;\n       return ret;\n     }\n-  ret = parser_xref_tag (code, ident, ident_loc);\n+  ret = parser_xref_tag (ident_loc, code, ident);\n   return ret;\n }\n \n@@ -2366,6 +2374,7 @@ c_parser_direct_declarator_inner (c_parser *parser, bool id_present,\n   /* Parse a sequence of array declarators and parameter lists.  */\n   if (c_parser_next_token_is (parser, CPP_OPEN_SQUARE))\n     {\n+      location_t brace_loc = c_parser_peek_token (parser)->location; \n       struct c_declarator *declarator;\n       struct c_declspecs *quals_attrs = build_null_declspecs ();\n       bool static_seen;\n@@ -2423,8 +2432,8 @@ c_parser_direct_declarator_inner (c_parser *parser, bool id_present,\n \t\t\t\t     \"expected %<]%>\");\n \t  return NULL;\n \t}\n-      declarator = build_array_declarator (dimen, quals_attrs, static_seen,\n-\t\t\t\t\t   star_seen);\n+      declarator = build_array_declarator (brace_loc, dimen, quals_attrs,\n+\t\t\t\t\t   static_seen, star_seen);\n       if (declarator == NULL)\n \treturn NULL;\n       inner = set_array_declarator_inner (declarator, inner);\n@@ -3020,10 +3029,11 @@ c_parser_initializer (c_parser *parser)\n   else\n     {\n       struct c_expr ret;\n+      location_t loc = c_parser_peek_token (parser)->location;\n       ret = c_parser_expr_no_commas (parser, NULL);\n       if (TREE_CODE (ret.value) != STRING_CST\n \t  && TREE_CODE (ret.value) != COMPOUND_LITERAL_EXPR)\n-\tret = default_function_array_conversion (ret);\n+\tret = default_function_array_conversion (loc, ret);\n       return ret;\n     }\n }\n@@ -3189,10 +3199,13 @@ c_parser_initelt (c_parser *parser)\n \t\t  while (c_parser_next_token_is (parser, CPP_COMMA))\n \t\t    {\n \t\t      struct c_expr next;\n+\t\t      location_t comma_loc, exp_loc;\n+\t\t      comma_loc = c_parser_peek_token (parser)->location;\n \t\t      c_parser_consume_token (parser);\n+\t\t      exp_loc = c_parser_peek_token (parser)->location;\n \t\t      next = c_parser_expr_no_commas (parser, NULL);\n-\t\t      next = default_function_array_conversion (next);\n-\t\t      rec = build_compound_expr (rec, next.value);\n+\t\t      next = default_function_array_conversion (exp_loc, next);\n+\t\t      rec = build_compound_expr (comma_loc, rec, next.value);\n \t\t    }\n \t\tparse_message_args:\n \t\t  /* Now parse the objc-message-args.  */\n@@ -3279,11 +3292,12 @@ c_parser_initval (c_parser *parser, struct c_expr *after)\n     init = c_parser_braced_init (parser, NULL_TREE, true);\n   else\n     {\n+      location_t loc = c_parser_peek_token (parser)->location;\n       init = c_parser_expr_no_commas (parser, after);\n       if (init.value != NULL_TREE\n \t  && TREE_CODE (init.value) != STRING_CST\n \t  && TREE_CODE (init.value) != COMPOUND_LITERAL_EXPR)\n-\tinit = default_function_array_conversion (init);\n+\tinit = default_function_array_conversion (loc, init);\n     }\n   process_init_element (init, false);\n }\n@@ -3345,17 +3359,19 @@ static tree\n c_parser_compound_statement (c_parser *parser)\n {\n   tree stmt;\n+  location_t brace_loc;\n+  brace_loc = c_parser_peek_token (parser)->location;\n   if (!c_parser_require (parser, CPP_OPEN_BRACE, \"expected %<{%>\"))\n     {\n       /* Ensure a scope is entered and left anyway to avoid confusion\n \t if we have just prepared to enter a function body.  */\n       stmt = c_begin_compound_stmt (true);\n-      c_end_compound_stmt (stmt, true);\n+      c_end_compound_stmt (brace_loc, stmt, true);\n       return error_mark_node;\n     }\n   stmt = c_begin_compound_stmt (true);\n   c_parser_compound_statement_nostart (parser);\n-  return c_end_compound_stmt (stmt, true);\n+  return c_end_compound_stmt (brace_loc, stmt, true);\n }\n \n /* Parse a compound statement except for the opening brace.  This is\n@@ -3377,12 +3393,12 @@ c_parser_compound_statement_nostart (c_parser *parser)\n   mark_valid_location_for_stdc_pragma (true);\n   if (c_parser_next_token_is_keyword (parser, RID_LABEL))\n     {\n-      location_t err_loc = c_parser_peek_token (parser)->location;\n       /* Read zero or more forward-declarations for labels that nested\n \t functions can jump to.  */\n       mark_valid_location_for_stdc_pragma (false);\n       while (c_parser_next_token_is_keyword (parser, RID_LABEL))\n \t{\n+\t  label_loc = c_parser_peek_token (parser)->location;\n \t  c_parser_consume_token (parser);\n \t  /* Any identifiers, including those declared as type names,\n \t     are OK here.  */\n@@ -3397,7 +3413,7 @@ c_parser_compound_statement_nostart (c_parser *parser)\n \t      label\n \t\t= declare_label (c_parser_peek_token (parser)->value);\n \t      C_DECLARED_LABEL_FLAG (label) = 1;\n-\t      add_stmt (build_stmt (DECL_EXPR, label));\n+\t      add_stmt (build_stmt (label_loc, DECL_EXPR, label));\n \t      c_parser_consume_token (parser);\n \t      if (c_parser_next_token_is (parser, CPP_COMMA))\n \t\tc_parser_consume_token (parser);\n@@ -3406,7 +3422,7 @@ c_parser_compound_statement_nostart (c_parser *parser)\n \t    }\n \t  c_parser_skip_until_found (parser, CPP_SEMICOLON, \"expected %<;%>\");\n \t}\n-      pedwarn (err_loc, OPT_pedantic, \"ISO C forbids label declarations\");\n+      pedwarn (label_loc, OPT_pedantic, \"ISO C forbids label declarations\");\n     }\n   /* We must now have at least one statement, label or declaration.  */\n   if (c_parser_next_token_is (parser, CPP_CLOSE_BRACE))\n@@ -3557,14 +3573,14 @@ c_parser_label (c_parser *parser)\n       if (c_parser_next_token_is (parser, CPP_COLON))\n \t{\n \t  c_parser_consume_token (parser);\n-\t  label = do_case (exp1, NULL_TREE);\n+\t  label = do_case (loc1, exp1, NULL_TREE);\n \t}\n       else if (c_parser_next_token_is (parser, CPP_ELLIPSIS))\n \t{\n \t  c_parser_consume_token (parser);\n \t  exp2 = c_parser_expr_no_commas (parser, NULL).value;\n \t  if (c_parser_require (parser, CPP_COLON, \"expected %<:%>\"))\n-\t    label = do_case (exp1, exp2);\n+\t    label = do_case (loc1, exp1, exp2);\n \t}\n       else\n \tc_parser_error (parser, \"expected %<:%> or %<...%>\");\n@@ -3573,7 +3589,7 @@ c_parser_label (c_parser *parser)\n     {\n       c_parser_consume_token (parser);\n       if (c_parser_require (parser, CPP_COLON, \"expected %<:%>\"))\n-\tlabel = do_case (NULL_TREE, NULL_TREE);\n+\tlabel = do_case (loc1, NULL_TREE, NULL_TREE);\n     }\n   else\n     {\n@@ -3590,12 +3606,11 @@ c_parser_label (c_parser *parser)\n       if (tlab)\n \t{\n \t  decl_attributes (&tlab, attrs, 0);\n-\t  label = add_stmt (build_stmt (LABEL_EXPR, tlab));\n+\t  label = add_stmt (build_stmt (loc1, LABEL_EXPR, tlab));\n \t}\n     }\n   if (label)\n     {\n-      SET_EXPR_LOCATION (label, loc1);\n       if (c_parser_next_token_starts_declspecs (parser)\n \t  && !(c_parser_next_token_is (parser, CPP_NAME)\n \t       && c_parser_peek_2nd_token (parser)->type == CPP_COLON))\n@@ -3754,36 +3769,38 @@ c_parser_statement_after_labels (c_parser *parser)\n \t  c_parser_consume_token (parser);\n \t  if (c_parser_next_token_is (parser, CPP_NAME))\n \t    {\n-\t      stmt = c_finish_goto_label (c_parser_peek_token (parser)->value);\n+\t      stmt = c_finish_goto_label (loc,\n+\t\t\t\t\t  c_parser_peek_token (parser)->value);\n \t      c_parser_consume_token (parser);\n \t    }\n \t  else if (c_parser_next_token_is (parser, CPP_MULT))\n \t    {\n \t      c_parser_consume_token (parser);\n-\t      stmt = c_finish_goto_ptr (c_parser_expression (parser).value);\n+\t      stmt = c_finish_goto_ptr (loc,\n+\t\t\t\t\tc_parser_expression (parser).value);\n \t    }\n \t  else\n \t    c_parser_error (parser, \"expected identifier or %<*%>\");\n \t  goto expect_semicolon;\n \tcase RID_CONTINUE:\n \t  c_parser_consume_token (parser);\n-\t  stmt = c_finish_bc_stmt (&c_cont_label, false);\n+\t  stmt = c_finish_bc_stmt (loc, &c_cont_label, false);\n \t  goto expect_semicolon;\n \tcase RID_BREAK:\n \t  c_parser_consume_token (parser);\n-\t  stmt = c_finish_bc_stmt (&c_break_label, true);\n+\t  stmt = c_finish_bc_stmt (loc, &c_break_label, true);\n \t  goto expect_semicolon;\n \tcase RID_RETURN:\n \t  c_parser_consume_token (parser);\n \t  if (c_parser_next_token_is (parser, CPP_SEMICOLON))\n \t    {\n-\t      stmt = c_finish_return (NULL_TREE, NULL_TREE);\n+\t      stmt = c_finish_return (loc, NULL_TREE, NULL_TREE);\n \t      c_parser_consume_token (parser);\n \t    }\n \t  else\n \t    {\n \t      struct c_expr expr = c_parser_expression_conv (parser);\n-\t      stmt = c_finish_return (expr.value, expr.original_type);\n+\t      stmt = c_finish_return (loc, expr.value, expr.original_type);\n \t      goto expect_semicolon;\n \t    }\n \t  break;\n@@ -3795,14 +3812,14 @@ c_parser_statement_after_labels (c_parser *parser)\n \t  c_parser_consume_token (parser);\n \t  if (c_parser_next_token_is (parser, CPP_SEMICOLON))\n \t    {\n-\t      stmt = objc_build_throw_stmt (NULL_TREE);\n+\t      stmt = objc_build_throw_stmt (loc, NULL_TREE);\n \t      c_parser_consume_token (parser);\n \t    }\n \t  else\n \t    {\n \t      tree expr = c_parser_expression (parser).value;\n \t      expr = c_fully_fold (expr, false, NULL);\n-\t      stmt = objc_build_throw_stmt (expr);\n+\t      stmt = objc_build_throw_stmt (loc, expr);\n \t      goto expect_semicolon;\n \t    }\n \t  break;\n@@ -3835,7 +3852,7 @@ c_parser_statement_after_labels (c_parser *parser)\n       break;\n     default:\n     expr_stmt:\n-      stmt = c_finish_expr_stmt (c_parser_expression_conv (parser).value);\n+      stmt = c_finish_expr_stmt (loc, c_parser_expression_conv (parser).value);\n     expect_semicolon:\n       c_parser_skip_until_found (parser, CPP_SEMICOLON, \"expected %<;%>\");\n       break;\n@@ -3850,7 +3867,9 @@ c_parser_statement_after_labels (c_parser *parser)\n      (recursively) all of the component statements should already have\n      line numbers assigned.  ??? Can we discard no-op statements\n      earlier?  */\n-  protected_set_expr_location (stmt, loc);\n+  if (CAN_HAVE_LOCATION_P (stmt)\n+      && EXPR_LOCATION (stmt) == UNKNOWN_LOCATION)\n+    SET_EXPR_LOCATION (stmt, loc);\n \n   parser->in_if_block = in_if_block;\n }\n@@ -3860,9 +3879,8 @@ c_parser_statement_after_labels (c_parser *parser)\n static tree\n c_parser_condition (c_parser *parser)\n {\n-  location_t loc;\n+  location_t loc = c_parser_peek_token (parser)->location;\n   tree cond;\n-  loc = c_parser_peek_token (parser)->location;\n   cond = c_parser_expression_conv (parser).value;\n   cond = c_objc_common_truthvalue_conversion (loc, cond);\n   cond = c_fully_fold (cond, false, NULL);\n@@ -3893,8 +3911,9 @@ static tree\n c_parser_c99_block_statement (c_parser *parser)\n {\n   tree block = c_begin_compound_stmt (flag_isoc99);\n+  location_t loc = c_parser_peek_token (parser)->location;\n   c_parser_statement (parser);\n-  return c_end_compound_stmt (block, flag_isoc99);\n+  return c_end_compound_stmt (loc, block, flag_isoc99);\n }\n \n /* Parse the body of an if statement.  This is just parsing a\n@@ -3909,6 +3928,7 @@ static tree\n c_parser_if_body (c_parser *parser, bool *if_p)\n {\n   tree block = c_begin_compound_stmt (flag_isoc99);\n+  location_t body_loc = c_parser_peek_token (parser)->location;\n   while (c_parser_next_token_is_keyword (parser, RID_CASE)\n \t || c_parser_next_token_is_keyword (parser, RID_DEFAULT)\n \t || (c_parser_next_token_is (parser, CPP_NAME)\n@@ -3918,7 +3938,7 @@ c_parser_if_body (c_parser *parser, bool *if_p)\n   if (c_parser_next_token_is (parser, CPP_SEMICOLON))\n     {\n       location_t loc = c_parser_peek_token (parser)->location;\n-      add_stmt (build_empty_stmt ());\n+      add_stmt (build_empty_stmt (loc));\n       c_parser_consume_token (parser);\n       if (!c_parser_next_token_is_keyword (parser, RID_ELSE))\n \twarning_at (loc, OPT_Wempty_body,\n@@ -3928,7 +3948,7 @@ c_parser_if_body (c_parser *parser, bool *if_p)\n     add_stmt (c_parser_compound_statement (parser));\n   else\n     c_parser_statement_after_labels (parser);\n-  return c_end_compound_stmt (block, flag_isoc99);\n+  return c_end_compound_stmt (body_loc, block, flag_isoc99);\n }\n \n /* Parse the else body of an if statement.  This is just parsing a\n@@ -3938,6 +3958,7 @@ c_parser_if_body (c_parser *parser, bool *if_p)\n static tree\n c_parser_else_body (c_parser *parser)\n {\n+  location_t else_loc = c_parser_peek_token (parser)->location;\n   tree block = c_begin_compound_stmt (flag_isoc99);\n   while (c_parser_next_token_is_keyword (parser, RID_CASE)\n \t || c_parser_next_token_is_keyword (parser, RID_DEFAULT)\n@@ -3946,15 +3967,16 @@ c_parser_else_body (c_parser *parser)\n     c_parser_label (parser);\n   if (c_parser_next_token_is (parser, CPP_SEMICOLON))\n     {\n-      warning_at (c_parser_peek_token (parser)->location,\n+      location_t loc = c_parser_peek_token (parser)->location;\n+      warning_at (loc,\n \t\t  OPT_Wempty_body,\n \t         \"suggest braces around empty body in an %<else%> statement\");\n-      add_stmt (build_empty_stmt ());\n+      add_stmt (build_empty_stmt (loc));\n       c_parser_consume_token (parser);\n     }\n   else \n     c_parser_statement_after_labels (parser);\n-  return c_end_compound_stmt (block, flag_isoc99);\n+  return c_end_compound_stmt (else_loc, block, flag_isoc99);\n }\n \n /* Parse an if statement (C90 6.6.4, C99 6.8.4).\n@@ -3991,7 +4013,7 @@ c_parser_if_statement (c_parser *parser)\n   else\n     second_body = NULL_TREE;\n   c_finish_if_stmt (loc, cond, first_body, second_body, first_if);\n-  add_stmt (c_end_compound_stmt (block, flag_isoc99));\n+  add_stmt (c_end_compound_stmt (loc, block, flag_isoc99));\n }\n \n /* Parse a switch statement (C90 6.6.4, C99 6.8.4).\n@@ -4004,25 +4026,36 @@ static void\n c_parser_switch_statement (c_parser *parser)\n {\n   tree block, expr, body, save_break;\n+  location_t switch_loc = c_parser_peek_token (parser)->location;\n+  location_t switch_cond_loc;\n   gcc_assert (c_parser_next_token_is_keyword (parser, RID_SWITCH));\n   c_parser_consume_token (parser);\n   block = c_begin_compound_stmt (flag_isoc99);\n   if (c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n     {\n+      switch_cond_loc = c_parser_peek_token (parser)->location;\n       expr = c_parser_expression (parser).value;\n       c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n     }\n   else\n-    expr = error_mark_node;\n-  c_start_case (expr);\n+    {\n+      switch_cond_loc = UNKNOWN_LOCATION;\n+      expr = error_mark_node;\n+    }\n+  c_start_case (switch_loc, switch_cond_loc, expr);\n   save_break = c_break_label;\n   c_break_label = NULL_TREE;\n   body = c_parser_c99_block_statement (parser);\n   c_finish_case (body);\n   if (c_break_label)\n-    add_stmt (build1 (LABEL_EXPR, void_type_node, c_break_label));\n+    {\n+      location_t here = c_parser_peek_token (parser)->location;\n+      tree t = build1 (LABEL_EXPR, void_type_node, c_break_label);\n+      SET_EXPR_LOCATION (t, here);\n+      add_stmt (t);\n+    }\n   c_break_label = save_break;\n-  add_stmt (c_end_compound_stmt (block, flag_isoc99));\n+  add_stmt (c_end_compound_stmt (switch_loc, block, flag_isoc99));\n }\n \n /* Parse a while statement (C90 6.6.5, C99 6.8.5).\n@@ -4047,7 +4080,7 @@ c_parser_while_statement (c_parser *parser)\n   c_cont_label = NULL_TREE;\n   body = c_parser_c99_block_statement (parser);\n   c_finish_loop (loc, cond, NULL, body, c_break_label, c_cont_label, true);\n-  add_stmt (c_end_compound_stmt (block, flag_isoc99));\n+  add_stmt (c_end_compound_stmt (loc, block, flag_isoc99));\n   c_break_label = save_break;\n   c_cont_label = save_cont;\n }\n@@ -4085,7 +4118,7 @@ c_parser_do_statement (c_parser *parser)\n   if (!c_parser_require (parser, CPP_SEMICOLON, \"expected %<;%>\"))\n     c_parser_skip_to_end_of_block_or_statement (parser);\n   c_finish_loop (loc, cond, NULL, body, new_break, new_cont, false);\n-  add_stmt (c_end_compound_stmt (block, flag_isoc99));\n+  add_stmt (c_end_compound_stmt (loc, block, flag_isoc99));\n }\n \n /* Parse a for statement (C90 6.6.5, C99 6.8.5).\n@@ -4108,9 +4141,9 @@ static void\n c_parser_for_statement (c_parser *parser)\n {\n   tree block, cond, incr, save_break, save_cont, body;\n-  location_t loc;\n+  location_t loc = c_parser_peek_token (parser)->location;\n+  location_t for_loc = c_parser_peek_token (parser)->location;\n   gcc_assert (c_parser_next_token_is_keyword (parser, RID_FOR));\n-  loc = c_parser_peek_token (parser)->location;\n   c_parser_consume_token (parser);\n   block = c_begin_compound_stmt (flag_isoc99);\n   if (c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n@@ -4119,12 +4152,12 @@ c_parser_for_statement (c_parser *parser)\n       if (c_parser_next_token_is (parser, CPP_SEMICOLON))\n \t{\n \t  c_parser_consume_token (parser);\n-\t  c_finish_expr_stmt (NULL_TREE);\n+\t  c_finish_expr_stmt (loc, NULL_TREE);\n \t}\n       else if (c_parser_next_token_starts_declspecs (parser))\n \t{\n \t  c_parser_declaration_or_fndef (parser, true, true, true, true);\n-\t  check_for_loop_decls ();\n+\t  check_for_loop_decls (for_loc);\n \t}\n       else if (c_parser_next_token_is_keyword (parser, RID_EXTENSION))\n \t{\n@@ -4143,15 +4176,15 @@ c_parser_for_statement (c_parser *parser)\n \t      c_parser_consume_token (parser);\n \t      c_parser_declaration_or_fndef (parser, true, true, true, true);\n \t      restore_extension_diagnostics (ext);\n-\t      check_for_loop_decls ();\n+\t      check_for_loop_decls (for_loc);\n \t    }\n \t  else\n \t    goto init_expr;\n \t}\n       else\n \t{\n \tinit_expr:\n-\t  c_finish_expr_stmt (c_parser_expression (parser).value);\n+\t  c_finish_expr_stmt (loc, c_parser_expression (parser).value);\n \t  c_parser_skip_until_found (parser, CPP_SEMICOLON, \"expected %<;%>\");\n \t}\n       /* Parse the loop condition.  */\n@@ -4167,9 +4200,9 @@ c_parser_for_statement (c_parser *parser)\n \t}\n       /* Parse the increment expression.  */\n       if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))\n-\tincr = c_process_expr_stmt (NULL_TREE);\n+\tincr = c_process_expr_stmt (loc, NULL_TREE);\n       else\n-\tincr = c_process_expr_stmt (c_parser_expression (parser).value);\n+\tincr = c_process_expr_stmt (loc, c_parser_expression (parser).value);\n       c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n     }\n   else\n@@ -4183,7 +4216,7 @@ c_parser_for_statement (c_parser *parser)\n   c_cont_label = NULL_TREE;\n   body = c_parser_c99_block_statement (parser);\n   c_finish_loop (loc, cond, incr, body, c_break_label, c_cont_label, true);\n-  add_stmt (c_end_compound_stmt (block, flag_isoc99));\n+  add_stmt (c_end_compound_stmt (loc, block, flag_isoc99));\n   c_break_label = save_break;\n   c_cont_label = save_cont;\n }\n@@ -4209,6 +4242,7 @@ c_parser_asm_statement (c_parser *parser)\n {\n   tree quals, str, outputs, inputs, clobbers, ret;\n   bool simple;\n+  location_t asm_loc = c_parser_peek_token (parser)->location;\n   gcc_assert (c_parser_next_token_is_keyword (parser, RID_ASM));\n   c_parser_consume_token (parser);\n   if (c_parser_next_token_is_keyword (parser, RID_VOLATILE))\n@@ -4304,7 +4338,7 @@ c_parser_asm_statement (c_parser *parser)\n     }\n   if (!c_parser_require (parser, CPP_SEMICOLON, \"expected %<;%>\"))\n     c_parser_skip_to_end_of_block_or_statement (parser);\n-  ret = build_asm_stmt (quals, build_asm_expr (str, outputs, inputs,\n+  ret = build_asm_stmt (quals, build_asm_expr (asm_loc, str, outputs, inputs,\n \t\t\t\t\t       clobbers, simple));\n   return ret;\n }\n@@ -4326,6 +4360,7 @@ static tree\n c_parser_asm_operands (c_parser *parser, bool convert_p)\n {\n   tree list = NULL_TREE;\n+  location_t loc;\n   while (true)\n     {\n       tree name, str;\n@@ -4360,9 +4395,10 @@ c_parser_asm_operands (c_parser *parser, bool convert_p)\n \t  parser->lex_untranslated_string = true;\n \t  return NULL_TREE;\n \t}\n+      loc = c_parser_peek_token (parser)->location;\n       expr = c_parser_expression (parser);\n       if (convert_p)\n-\texpr = default_function_array_conversion (expr);\n+\texpr = default_function_array_conversion (loc, expr);\n       expr.value = c_fully_fold (expr.value, false, NULL);\n       parser->lex_untranslated_string = true;\n       if (!c_parser_require (parser, CPP_CLOSE_PAREN, \"expected %<)%>\"))\n@@ -4427,7 +4463,7 @@ c_parser_expr_no_commas (c_parser *parser, struct c_expr *after)\n {\n   struct c_expr lhs, rhs, ret;\n   enum tree_code code;\n-  location_t op_location;\n+  location_t op_location, exp_location;\n   gcc_assert (!after || c_dialect_objc ());\n   lhs = c_parser_conditional_expression (parser, after);\n   op_location = c_parser_peek_token (parser)->location;\n@@ -4470,10 +4506,12 @@ c_parser_expr_no_commas (c_parser *parser, struct c_expr *after)\n       return lhs;\n     }\n   c_parser_consume_token (parser);\n+  exp_location = c_parser_peek_token (parser)->location;\n   rhs = c_parser_expr_no_commas (parser, NULL);\n-  rhs = default_function_array_conversion (rhs);\n+  rhs = default_function_array_conversion (exp_location, rhs);\n   ret.value = build_modify_expr (op_location, lhs.value, lhs.original_type,\n-\t\t\t\t code, rhs.value, rhs.original_type);\n+\t\t\t\t code, exp_location, rhs.value,\n+\t\t\t\t rhs.original_type);\n   if (code == NOP_EXPR)\n     ret.original_code = MODIFY_EXPR;\n   else\n@@ -4507,12 +4545,12 @@ c_parser_conditional_expression (c_parser *parser, struct c_expr *after)\n \n   gcc_assert (!after || c_dialect_objc ());\n \n-  cond_loc = c_parser_peek_token (parser)->location;\n   cond = c_parser_binary_expression (parser, after);\n \n   if (c_parser_next_token_is_not (parser, CPP_QUERY))\n     return cond;\n-  cond = default_function_array_conversion (cond);\n+  cond_loc = c_parser_peek_token (parser)->location;\n+  cond = default_function_array_conversion (cond_loc, cond);\n   c_parser_consume_token (parser);\n   if (c_parser_next_token_is (parser, CPP_COLON))\n     {\n@@ -4552,8 +4590,11 @@ c_parser_conditional_expression (c_parser *parser, struct c_expr *after)\n       ret.original_type = NULL;\n       return ret;\n     }\n-  exp2 = c_parser_conditional_expression (parser, NULL);\n-  exp2 = default_function_array_conversion (exp2);\n+  {\n+    location_t exp2_loc = c_parser_peek_token (parser)->location;\n+    exp2 = c_parser_conditional_expression (parser, NULL);\n+    exp2 = default_function_array_conversion (exp2_loc, exp2);\n+  }\n   skip_evaluation -= cond.value == truthvalue_true_node;\n   ret.value = build_conditional_expr (colon_loc, cond.value,\n \t\t\t\t      cond.original_code == C_MAYBE_CONST_EXPR,\n@@ -4702,9 +4743,10 @@ c_parser_binary_expression (c_parser *parser, struct c_expr *after)\n \tbreak;\t\t\t\t\t\t\t\t      \\\n       }\t\t\t\t\t\t\t\t\t      \\\n     stack[sp - 1].expr\t\t\t\t\t\t\t      \\\n-      = default_function_array_conversion (stack[sp - 1].expr);\t\t      \\\n+      = default_function_array_conversion (stack[sp - 1].loc,\t\t      \\\n+\t\t\t\t\t   stack[sp - 1].expr);\t\t      \\\n     stack[sp].expr\t\t\t\t\t\t\t      \\\n-      = default_function_array_conversion (stack[sp].expr);\t\t      \\\n+      = default_function_array_conversion (stack[sp].loc, stack[sp].expr);    \\\n     stack[sp - 1].expr = parser_build_binary_op (stack[sp].loc,\t\t      \\\n \t\t\t\t\t\t stack[sp].op,\t\t      \\\n \t\t\t\t\t\t stack[sp - 1].expr,\t      \\\n@@ -4809,14 +4851,16 @@ c_parser_binary_expression (c_parser *parser, struct c_expr *after)\n \t{\n \tcase TRUTH_ANDIF_EXPR:\n \t  stack[sp].expr\n-\t    = default_function_array_conversion (stack[sp].expr);\n+\t    = default_function_array_conversion (stack[sp].loc,\n+\t\t\t\t\t\t stack[sp].expr);\n \t  stack[sp].expr.value = c_objc_common_truthvalue_conversion\n \t    (stack[sp].loc, default_conversion (stack[sp].expr.value));\n \t  skip_evaluation += stack[sp].expr.value == truthvalue_false_node;\n \t  break;\n \tcase TRUTH_ORIF_EXPR:\n \t  stack[sp].expr\n-\t    = default_function_array_conversion (stack[sp].expr);\n+\t    = default_function_array_conversion (stack[sp].loc,\n+\t\t\t\t\t\t stack[sp].expr);\n \t  stack[sp].expr.value = c_objc_common_truthvalue_conversion\n \t    (stack[sp].loc, default_conversion (stack[sp].expr.value));\n \t  skip_evaluation += stack[sp].expr.value == truthvalue_true_node;\n@@ -4829,6 +4873,7 @@ c_parser_binary_expression (c_parser *parser, struct c_expr *after)\n       stack[sp].expr = c_parser_cast_expression (parser, NULL);\n       stack[sp].prec = oprec;\n       stack[sp].op = ocode;\n+      stack[sp].loc = binary_loc;\n     }\n  out:\n   while (sp > 0)\n@@ -4849,22 +4894,22 @@ c_parser_binary_expression (c_parser *parser, struct c_expr *after)\n static struct c_expr\n c_parser_cast_expression (c_parser *parser, struct c_expr *after)\n {\n+  location_t cast_loc = c_parser_peek_token (parser)->location;\n   gcc_assert (!after || c_dialect_objc ());\n   if (after)\n-    return c_parser_postfix_expression_after_primary (parser, *after);\n+    return c_parser_postfix_expression_after_primary (parser,\n+\t\t\t\t\t\t      cast_loc, *after);\n   /* If the expression begins with a parenthesized type name, it may\n      be either a cast or a compound literal; we need to see whether\n      the next character is '{' to tell the difference.  If not, it is\n      an unary expression.  */\n   if (c_parser_next_token_is (parser, CPP_OPEN_PAREN)\n       && c_token_starts_typename (c_parser_peek_2nd_token (parser)))\n     {\n-      location_t loc;\n       struct c_type_name *type_name;\n       struct c_expr ret;\n       struct c_expr expr;\n       c_parser_consume_token (parser);\n-      loc = c_parser_peek_token (parser)->location;\n       type_name = c_parser_type_name (parser);\n       c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n       if (type_name == NULL)\n@@ -4880,10 +4925,13 @@ c_parser_cast_expression (c_parser *parser, struct c_expr *after)\n \n       if (c_parser_next_token_is (parser, CPP_OPEN_BRACE))\n \treturn c_parser_postfix_expression_after_paren_type (parser, type_name,\n-\t\t\t\t\t\t\t     loc);\n-      expr = c_parser_cast_expression (parser, NULL);\n-      expr = default_function_array_conversion (expr);\n-      ret.value = c_cast_expr (type_name, expr.value, loc);\n+\t\t\t\t\t\t\t     cast_loc);\n+      {\n+\tlocation_t expr_loc = c_parser_peek_token (parser)->location;\n+\texpr = c_parser_cast_expression (parser, NULL);\n+\texpr = default_function_array_conversion (expr_loc, expr);\n+      }\n+      ret.value = c_cast_expr (cast_loc, type_name, expr.value);\n       ret.original_code = ERROR_MARK;\n       ret.original_type = NULL;\n       return ret;\n@@ -4924,63 +4972,70 @@ c_parser_unary_expression (c_parser *parser)\n {\n   int ext;\n   struct c_expr ret, op;\n-  location_t loc = c_parser_peek_token (parser)->location;\n+  location_t op_loc = c_parser_peek_token (parser)->location;\n+  location_t exp_loc;\n   ret.original_code = ERROR_MARK;\n   ret.original_type = NULL;\n   switch (c_parser_peek_token (parser)->type)\n     {\n     case CPP_PLUS_PLUS:\n       c_parser_consume_token (parser);\n+      exp_loc = c_parser_peek_token (parser)->location;\n       op = c_parser_cast_expression (parser, NULL);\n-      op = default_function_array_conversion (op);\n-      return parser_build_unary_op (PREINCREMENT_EXPR, op, loc);\n+      op = default_function_array_conversion (exp_loc, op);\n+      return parser_build_unary_op (op_loc, PREINCREMENT_EXPR, op);\n     case CPP_MINUS_MINUS:\n       c_parser_consume_token (parser);\n+      exp_loc = c_parser_peek_token (parser)->location;\n       op = c_parser_cast_expression (parser, NULL);\n-      op = default_function_array_conversion (op);\n-      return parser_build_unary_op (PREDECREMENT_EXPR, op, loc);\n+      op = default_function_array_conversion (exp_loc, op);\n+      return parser_build_unary_op (op_loc, PREDECREMENT_EXPR, op);\n     case CPP_AND:\n       c_parser_consume_token (parser);\n-      return parser_build_unary_op (ADDR_EXPR,\n-\t\t\t\t    c_parser_cast_expression (parser, NULL),\n-\t\t\t\t    loc);\n+      return parser_build_unary_op (op_loc, ADDR_EXPR,\n+\t\t\t\t    c_parser_cast_expression (parser, NULL));\n     case CPP_MULT:\n       c_parser_consume_token (parser);\n+      exp_loc = c_parser_peek_token (parser)->location;\n       op = c_parser_cast_expression (parser, NULL);\n-      op = default_function_array_conversion (op);\n-      ret.value = build_indirect_ref (loc, op.value, \"unary *\");\n+      op = default_function_array_conversion (exp_loc, op);\n+      ret.value = build_indirect_ref (op_loc, op.value, \"unary *\");\n       return ret;\n     case CPP_PLUS:\n       if (!c_dialect_objc () && !in_system_header)\n-\twarning_at (c_parser_peek_token (parser)->location,\n+\twarning_at (op_loc,\n \t\t    OPT_Wtraditional,\n \t\t    \"traditional C rejects the unary plus operator\");\n       c_parser_consume_token (parser);\n+      exp_loc = c_parser_peek_token (parser)->location;\n       op = c_parser_cast_expression (parser, NULL);\n-      op = default_function_array_conversion (op);\n-      return parser_build_unary_op (CONVERT_EXPR, op, loc);\n+      op = default_function_array_conversion (exp_loc, op);\n+      return parser_build_unary_op (op_loc, CONVERT_EXPR, op);\n     case CPP_MINUS:\n       c_parser_consume_token (parser);\n+      exp_loc = c_parser_peek_token (parser)->location;\n       op = c_parser_cast_expression (parser, NULL);\n-      op = default_function_array_conversion (op);\n-      return parser_build_unary_op (NEGATE_EXPR, op, loc);\n+      op = default_function_array_conversion (exp_loc, op);\n+      return parser_build_unary_op (op_loc, NEGATE_EXPR, op);\n     case CPP_COMPL:\n       c_parser_consume_token (parser);\n+      exp_loc = c_parser_peek_token (parser)->location;\n       op = c_parser_cast_expression (parser, NULL);\n-      op = default_function_array_conversion (op);\n-      return parser_build_unary_op (BIT_NOT_EXPR, op, loc);\n+      op = default_function_array_conversion (exp_loc, op);\n+      return parser_build_unary_op (op_loc, BIT_NOT_EXPR, op);\n     case CPP_NOT:\n       c_parser_consume_token (parser);\n+      exp_loc = c_parser_peek_token (parser)->location;\n       op = c_parser_cast_expression (parser, NULL);\n-      op = default_function_array_conversion (op);\n-      return parser_build_unary_op (TRUTH_NOT_EXPR, op, loc);\n+      op = default_function_array_conversion (exp_loc, op);\n+      return parser_build_unary_op (op_loc, TRUTH_NOT_EXPR, op);\n     case CPP_AND_AND:\n       /* Refer to the address of a label as a pointer.  */\n       c_parser_consume_token (parser);\n       if (c_parser_next_token_is (parser, CPP_NAME))\n \t{\n \t  ret.value = finish_label_address_expr\n-\t    (c_parser_peek_token (parser)->value, loc);\n+\t    (c_parser_peek_token (parser)->value, op_loc);\n \t  c_parser_consume_token (parser);\n \t}\n       else\n@@ -5004,14 +5059,16 @@ c_parser_unary_expression (c_parser *parser)\n \t  return ret;\n \tcase RID_REALPART:\n \t  c_parser_consume_token (parser);\n+\t  exp_loc = c_parser_peek_token (parser)->location;\n \t  op = c_parser_cast_expression (parser, NULL);\n-\t  op = default_function_array_conversion (op);\n-\t  return parser_build_unary_op (REALPART_EXPR, op, loc);\n+\t  op = default_function_array_conversion (exp_loc, op);\n+\t  return parser_build_unary_op (op_loc, REALPART_EXPR, op);\n \tcase RID_IMAGPART:\n \t  c_parser_consume_token (parser);\n+\t  exp_loc = c_parser_peek_token (parser)->location;\n \t  op = c_parser_cast_expression (parser, NULL);\n-\t  op = default_function_array_conversion (op);\n-\t  return parser_build_unary_op (IMAGPART_EXPR, op, loc);\n+\t  op = default_function_array_conversion (exp_loc, op);\n+\t  return parser_build_unary_op (op_loc, IMAGPART_EXPR, op);\n \tdefault:\n \t  return c_parser_postfix_expression (parser);\n \t}\n@@ -5061,7 +5118,7 @@ c_parser_sizeof_expression (c_parser *parser)\n       /* sizeof ( type-name ).  */\n       skip_evaluation--;\n       in_sizeof--;\n-      return c_expr_sizeof_type (type_name);\n+      return c_expr_sizeof_type (expr_loc, type_name);\n     }\n   else\n     {\n@@ -5073,7 +5130,7 @@ c_parser_sizeof_expression (c_parser *parser)\n       if (TREE_CODE (expr.value) == COMPONENT_REF\n \t  && DECL_C_BIT_FIELD (TREE_OPERAND (expr.value, 1)))\n \terror_at (expr_loc, \"%<sizeof%> applied to a bit-field\");\n-      return c_expr_sizeof_expr (expr);\n+      return c_expr_sizeof_expr (expr_loc, expr);\n     }\n }\n \n@@ -5083,6 +5140,7 @@ static struct c_expr\n c_parser_alignof_expression (c_parser *parser)\n {\n   struct c_expr expr;\n+  location_t loc = c_parser_peek_token (parser)->location;\n   gcc_assert (c_parser_next_token_is_keyword (parser, RID_ALIGNOF));\n   c_parser_consume_token (parser);\n   skip_evaluation++;\n@@ -5119,7 +5177,7 @@ c_parser_alignof_expression (c_parser *parser)\n       /* alignof ( type-name ).  */\n       skip_evaluation--;\n       in_alignof--;\n-      ret.value = c_alignof (groktypename (type_name, NULL, NULL));\n+      ret.value = c_alignof (loc, groktypename (type_name, NULL, NULL));\n       ret.original_code = ERROR_MARK;\n       ret.original_type = NULL;\n       return ret;\n@@ -5131,7 +5189,7 @@ c_parser_alignof_expression (c_parser *parser)\n     alignof_expr:\n       skip_evaluation--;\n       in_alignof--;\n-      ret.value = c_alignof_expr (expr.value);\n+      ret.value = c_alignof_expr (loc, expr.value);\n       ret.original_code = ERROR_MARK;\n       ret.original_type = NULL;\n       return ret;\n@@ -5196,7 +5254,7 @@ c_parser_postfix_expression (c_parser *parser)\n {\n   struct c_expr expr, e1, e2, e3;\n   struct c_type_name *t1, *t2;\n-  location_t loc;\n+  location_t loc = c_parser_peek_token (parser)->location;;\n   expr.original_code = ERROR_MARK;\n   expr.original_type = NULL;\n   switch (c_parser_peek_token (parser)->type)\n@@ -5242,11 +5300,10 @@ c_parser_postfix_expression (c_parser *parser)\n \t}\n       {\n \ttree id = c_parser_peek_token (parser)->value;\n-\tlocation_t loc = c_parser_peek_token (parser)->location;\n \tc_parser_consume_token (parser);\n-\texpr.value = build_external_ref (id,\n+\texpr.value = build_external_ref (loc, id,\n \t\t\t\t\t (c_parser_peek_token (parser)->type\n-\t\t\t\t\t  == CPP_OPEN_PAREN), loc,\n+\t\t\t\t\t  == CPP_OPEN_PAREN),\n \t\t\t\t\t &expr.original_type);\n       }\n       break;\n@@ -5257,12 +5314,13 @@ c_parser_postfix_expression (c_parser *parser)\n \t{\n \t  /* A statement expression.  */\n \t  tree stmt;\n-\t  location_t here = c_parser_peek_token (parser)->location;\n+\t  location_t brace_loc;\n \t  c_parser_consume_token (parser);\n+\t  brace_loc = c_parser_peek_token (parser)->location;\n \t  c_parser_consume_token (parser);\n \t  if (cur_stmt_list == NULL)\n \t    {\n-\t      error_at (here, \"braced-group within expression allowed \"\n+\t      error_at (loc, \"braced-group within expression allowed \"\n \t\t\t\"only inside a function\");\n \t      parser->error = true;\n \t      c_parser_skip_until_found (parser, CPP_CLOSE_BRACE, NULL);\n@@ -5274,9 +5332,9 @@ c_parser_postfix_expression (c_parser *parser)\n \t  c_parser_compound_statement_nostart (parser);\n \t  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,\n \t\t\t\t     \"expected %<)%>\");\n-\t  pedwarn (here, OPT_pedantic, \n+\t  pedwarn (loc, OPT_pedantic, \n \t\t   \"ISO C forbids braced-groups within expressions\");\n-\t  expr.value = c_finish_stmt_expr (stmt);\n+\t  expr.value = c_finish_stmt_expr (brace_loc, stmt);\n \t}\n       else if (c_token_starts_typename (c_parser_peek_2nd_token (parser)))\n \t{\n@@ -5320,7 +5378,7 @@ c_parser_postfix_expression (c_parser *parser)\n \tcase RID_FUNCTION_NAME:\n \tcase RID_PRETTY_FUNCTION_NAME:\n \tcase RID_C99_FUNCTION_NAME:\n-\t  expr.value = fname_decl (c_parser_peek_token (parser)->location,\n+\t  expr.value = fname_decl (loc,\n \t\t\t\t   c_parser_peek_token (parser)->keyword,\n \t\t\t\t   c_parser_peek_token (parser)->value);\n \t  c_parser_consume_token (parser);\n@@ -5351,9 +5409,8 @@ c_parser_postfix_expression (c_parser *parser)\n \t  else\n \t    {\n \t      tree type_expr = NULL_TREE;\n-\t      expr.value = c_build_va_arg (e1.value,\n-\t\t\t\t\t   groktypename (t1, &type_expr, NULL),\n-\t\t\t\t\t   loc);\n+\t      expr.value = c_build_va_arg (loc, e1.value,\n+\t\t\t\t\t   groktypename (t1, &type_expr, NULL));\n \t      if (type_expr)\n \t\t{\n \t\t  expr.value = build2 (C_MAYBE_CONST_EXPR,\n@@ -5388,14 +5445,17 @@ c_parser_postfix_expression (c_parser *parser)\n \t    if (type == error_mark_node)\n \t      offsetof_ref = error_mark_node;\n \t    else\n-\t      offsetof_ref = build1 (INDIRECT_REF, type, null_pointer_node);\n+\t      {\n+\t\toffsetof_ref = build1 (INDIRECT_REF, type, null_pointer_node);\n+\t\tSET_EXPR_LOCATION (offsetof_ref, loc);\n+\t      }\n \t    /* Parse the second argument to __builtin_offsetof.  We\n \t       must have one identifier, and beyond that we want to\n \t       accept sub structure and sub array references.  */\n \t    if (c_parser_next_token_is (parser, CPP_NAME))\n \t      {\n \t\toffsetof_ref = build_component_ref\n-\t\t  (offsetof_ref, c_parser_peek_token (parser)->value);\n+\t\t  (loc, offsetof_ref, c_parser_peek_token (parser)->value);\n \t\tc_parser_consume_token (parser);\n \t\twhile (c_parser_next_token_is (parser, CPP_DOT)\n \t\t       || c_parser_next_token_is (parser,\n@@ -5406,9 +5466,9 @@ c_parser_postfix_expression (c_parser *parser)\n \t\t    if (c_parser_next_token_is (parser, CPP_DEREF))\n \t\t      {\n \t\t\tloc = c_parser_peek_token (parser)->location;\n-\t\t\toffsetof_ref = build_array_ref (offsetof_ref,\n-\t\t\t\t\t\t\tinteger_zero_node,\n-\t\t\t\t\t\t\tloc);\n+\t\t\toffsetof_ref = build_array_ref (loc,\n+\t\t\t\t\t\t\toffsetof_ref,\n+\t\t\t\t\t\t\tinteger_zero_node);\n \t\t\tgoto do_dot;\n \t\t      }\n \t\t    else if (c_parser_next_token_is (parser, CPP_DOT))\n@@ -5422,7 +5482,7 @@ c_parser_postfix_expression (c_parser *parser)\n \t\t\t    break;\n \t\t\t  }\n \t\t\toffsetof_ref = build_component_ref\n-\t\t\t  (offsetof_ref,\n+\t\t\t  (loc, offsetof_ref,\n \t\t\t   c_parser_peek_token (parser)->value);\n \t\t\tc_parser_consume_token (parser);\n \t\t      }\n@@ -5435,7 +5495,7 @@ c_parser_postfix_expression (c_parser *parser)\n \t\t\tidx = c_fully_fold (idx, false, NULL);\n \t\t\tc_parser_skip_until_found (parser, CPP_CLOSE_SQUARE,\n \t\t\t\t\t\t   \"expected %<]%>\");\n-\t\t\toffsetof_ref = build_array_ref (offsetof_ref, idx, loc);\n+\t\t\toffsetof_ref = build_array_ref (loc, offsetof_ref, idx);\n \t\t      }\n \t\t  }\n \t      }\n@@ -5534,7 +5594,7 @@ c_parser_postfix_expression (c_parser *parser)\n \t    tree sel = c_parser_objc_selector_arg (parser);\n \t    c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,\n \t\t\t\t       \"expected %<)%>\");\n-\t    expr.value = objc_build_selector_expr (sel);\n+\t    expr.value = objc_build_selector_expr (loc, sel);\n \t  }\n \t  break;\n \tcase RID_AT_PROTOCOL:\n@@ -5608,7 +5668,7 @@ c_parser_postfix_expression (c_parser *parser)\n       expr.value = error_mark_node;\n       break;\n     }\n-  return c_parser_postfix_expression_after_primary (parser, expr);\n+  return c_parser_postfix_expression_after_primary (parser, loc, expr);\n }\n \n /* Parse a postfix expression after a parenthesized type name: the\n@@ -5633,7 +5693,7 @@ c_parser_postfix_expression_after_paren_type (c_parser *parser,\n   location_t start_loc;\n   tree type_expr = NULL_TREE;\n   bool type_expr_const = true;\n-  check_compound_literal_type (type_name, type_loc);\n+  check_compound_literal_type (type_loc, type_name);\n   start_init (NULL_TREE, NULL, 0);\n   type = groktypename (type_name, &type_expr, &type_expr_const);\n   start_loc = c_parser_peek_token (parser)->location;\n@@ -5652,7 +5712,7 @@ c_parser_postfix_expression_after_paren_type (c_parser *parser,\n \t       ? CONSTRUCTOR_NON_CONST (init.value)\n \t       : init.original_code == C_MAYBE_CONST_EXPR);\n   non_const |= !type_expr_const;\n-  expr.value = build_compound_literal (type, init.value, non_const);\n+  expr.value = build_compound_literal (start_loc, type, init.value, non_const);\n   expr.original_code = ERROR_MARK;\n   expr.original_type = NULL;\n   if (type_expr)\n@@ -5669,33 +5729,35 @@ c_parser_postfix_expression_after_paren_type (c_parser *parser,\n \t\t\t       type_expr, expr.value);\n \t}\n     }\n-  return c_parser_postfix_expression_after_primary (parser, expr);\n+  return c_parser_postfix_expression_after_primary (parser, start_loc, expr);\n }\n \n /* Parse a postfix expression after the initial primary or compound\n-   literal; that is, parse a series of postfix operators.  */\n+   literal; that is, parse a series of postfix operators.\n+\n+   EXPR_LOC is the location of the primary expression.  */\n \n static struct c_expr\n c_parser_postfix_expression_after_primary (c_parser *parser,\n+\t\t\t\t\t   location_t expr_loc,\n \t\t\t\t\t   struct c_expr expr)\n {\n   struct c_expr orig_expr;\n   tree ident, idx;\n   VEC(tree,gc) *exprlist;\n   VEC(tree,gc) *origtypes;\n-  location_t loc = c_parser_peek_token (parser)->location;\n   while (true)\n     {\n+      location_t op_loc = c_parser_peek_token (parser)->location;\n       switch (c_parser_peek_token (parser)->type)\n \t{\n \tcase CPP_OPEN_SQUARE:\n \t  /* Array reference.  */\n-\t  loc = c_parser_peek_token (parser)->location;\n \t  c_parser_consume_token (parser);\n \t  idx = c_parser_expression (parser).value;\n \t  c_parser_skip_until_found (parser, CPP_CLOSE_SQUARE,\n \t\t\t\t     \"expected %<]%>\");\n-\t  expr.value = build_array_ref (expr.value, idx, loc);\n+\t  expr.value = build_array_ref (op_loc, expr.value, idx);\n \t  expr.original_code = ERROR_MARK;\n \t  expr.original_type = NULL;\n \t  break;\n@@ -5709,7 +5771,9 @@ c_parser_postfix_expression_after_primary (c_parser *parser,\n \t  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,\n \t\t\t\t     \"expected %<)%>\");\n \t  orig_expr = expr;\n-\t  expr.value = build_function_call_vec (expr.value, exprlist,\n+\t  /* FIXME diagnostics: Ideally we want the FUNCNAME, not the\n+\t     \"(\" after the FUNCNAME, which is what we have now.    */\n+\t  expr.value = build_function_call_vec (op_loc, expr.value, exprlist,\n \t\t\t\t\t\torigtypes);\n \t  expr.original_code = ERROR_MARK;\n \t  if (TREE_CODE (expr.value) == INTEGER_CST\n@@ -5727,7 +5791,7 @@ c_parser_postfix_expression_after_primary (c_parser *parser,\n \tcase CPP_DOT:\n \t  /* Structure element reference.  */\n \t  c_parser_consume_token (parser);\n-\t  expr = default_function_array_conversion (expr);\n+\t  expr = default_function_array_conversion (expr_loc, expr);\n \t  if (c_parser_next_token_is (parser, CPP_NAME))\n \t    ident = c_parser_peek_token (parser)->value;\n \t  else\n@@ -5739,7 +5803,7 @@ c_parser_postfix_expression_after_primary (c_parser *parser,\n \t      return expr;\n \t    }\n \t  c_parser_consume_token (parser);\n-\t  expr.value = build_component_ref (expr.value, ident);\n+\t  expr.value = build_component_ref (op_loc, expr.value, ident);\n \t  expr.original_code = ERROR_MARK;\n \t  if (TREE_CODE (expr.value) != COMPONENT_REF)\n \t    expr.original_type = NULL;\n@@ -5756,7 +5820,7 @@ c_parser_postfix_expression_after_primary (c_parser *parser,\n \tcase CPP_DEREF:\n \t  /* Structure element reference.  */\n \t  c_parser_consume_token (parser);\n-\t  expr = default_function_array_conversion (expr);\n+\t  expr = default_function_array_conversion (expr_loc, expr);\n \t  if (c_parser_next_token_is (parser, CPP_NAME))\n \t    ident = c_parser_peek_token (parser)->value;\n \t  else\n@@ -5768,7 +5832,8 @@ c_parser_postfix_expression_after_primary (c_parser *parser,\n \t      return expr;\n \t    }\n \t  c_parser_consume_token (parser);\n-\t  expr.value = build_component_ref (build_indirect_ref (loc,\n+\t  expr.value = build_component_ref (op_loc,\n+\t\t\t\t\t    build_indirect_ref (op_loc,\n \t\t\t\t\t\t\t\texpr.value,\n \t\t\t\t\t\t\t\t\"->\"),\n \t\t\t\t\t    ident);\n@@ -5788,17 +5853,17 @@ c_parser_postfix_expression_after_primary (c_parser *parser,\n \tcase CPP_PLUS_PLUS:\n \t  /* Postincrement.  */\n \t  c_parser_consume_token (parser);\n-\t  expr = default_function_array_conversion (expr);\n-\t  expr.value = build_unary_op (loc,\n+\t  expr = default_function_array_conversion (expr_loc, expr);\n+\t  expr.value = build_unary_op (op_loc,\n \t\t\t\t       POSTINCREMENT_EXPR, expr.value, 0);\n \t  expr.original_code = ERROR_MARK;\n \t  expr.original_type = NULL;\n \t  break;\n \tcase CPP_MINUS_MINUS:\n \t  /* Postdecrement.  */\n \t  c_parser_consume_token (parser);\n-\t  expr = default_function_array_conversion (expr);\n-\t  expr.value = build_unary_op (loc,\n+\t  expr = default_function_array_conversion (expr_loc, expr);\n+\t  expr.value = build_unary_op (op_loc,\n \t\t\t\t       POSTDECREMENT_EXPR, expr.value, 0);\n \t  expr.original_code = ERROR_MARK;\n \t  expr.original_type = NULL;\n@@ -5824,10 +5889,13 @@ c_parser_expression (c_parser *parser)\n   while (c_parser_next_token_is (parser, CPP_COMMA))\n     {\n       struct c_expr next;\n+      location_t loc = c_parser_peek_token (parser)->location;\n+      location_t expr_loc;\n       c_parser_consume_token (parser);\n+      expr_loc = c_parser_peek_token (parser)->location;\n       next = c_parser_expr_no_commas (parser, NULL);\n-      next = default_function_array_conversion (next);\n-      expr.value = build_compound_expr (expr.value, next.value);\n+      next = default_function_array_conversion (expr_loc, next);\n+      expr.value = build_compound_expr (loc, expr.value, next.value);\n       expr.original_code = COMPOUND_EXPR;\n       expr.original_type = next.original_type;\n     }\n@@ -5841,8 +5909,9 @@ static struct c_expr\n c_parser_expression_conv (c_parser *parser)\n {\n   struct c_expr expr;\n+  location_t loc = c_parser_peek_token (parser)->location;\n   expr = c_parser_expression (parser);\n-  expr = default_function_array_conversion (expr);\n+  expr = default_function_array_conversion (loc, expr);\n   return expr;\n }\n \n@@ -5861,6 +5930,7 @@ c_parser_expr_list (c_parser *parser, bool convert_p, bool fold_p,\n   VEC(tree,gc) *ret;\n   VEC(tree,gc) *orig_types;\n   struct c_expr expr;\n+  location_t loc = c_parser_peek_token (parser)->location;\n \n   ret = make_tree_vector ();\n   if (p_orig_types == NULL)\n@@ -5870,7 +5940,7 @@ c_parser_expr_list (c_parser *parser, bool convert_p, bool fold_p,\n \n   expr = c_parser_expr_no_commas (parser, NULL);\n   if (convert_p)\n-    expr = default_function_array_conversion (expr);\n+    expr = default_function_array_conversion (loc, expr);\n   if (fold_p)\n     expr.value = c_fully_fold (expr.value, false, NULL);\n   VEC_quick_push (tree, ret, expr.value);\n@@ -5879,9 +5949,10 @@ c_parser_expr_list (c_parser *parser, bool convert_p, bool fold_p,\n   while (c_parser_next_token_is (parser, CPP_COMMA))\n     {\n       c_parser_consume_token (parser);\n+      loc = c_parser_peek_token (parser)->location;\n       expr = c_parser_expr_no_commas (parser, NULL);\n       if (convert_p)\n-\texpr = default_function_array_conversion (expr);\n+\texpr = default_function_array_conversion (loc, expr);\n       if (fold_p)\n \texpr.value = c_fully_fold (expr.value, false, NULL);\n       VEC_safe_push (tree, gc, ret, expr.value);\n@@ -6998,7 +7069,8 @@ check_no_duplicate_clause (tree clauses, enum omp_clause_code code,\n   for (c = clauses; c ; c = OMP_CLAUSE_CHAIN (c))\n     if (OMP_CLAUSE_CODE (c) == code)\n       {\n-\terror (\"too many %qs clauses\", name);\n+\tlocation_t loc = OMP_CLAUSE_LOCATION (c);\n+\terror_at (loc, \"too many %qs clauses\", name);\n \tbreak;\n       }\n }\n@@ -7008,14 +7080,17 @@ check_no_duplicate_clause (tree clauses, enum omp_clause_code code,\n      identifier\n      variable-list , identifier\n \n-   If KIND is nonzero, create the appropriate node and install the decl\n-   in OMP_CLAUSE_DECL and add the node to the head of the list.\n+   If KIND is nonzero, create the appropriate node and install the\n+   decl in OMP_CLAUSE_DECL and add the node to the head of the list.\n+   If KIND is nonzero, CLAUSE_LOC is the location of the clause.\n \n    If KIND is zero, create a TREE_LIST with the decl in TREE_PURPOSE;\n    return the list created.  */\n \n static tree\n-c_parser_omp_variable_list (c_parser *parser, enum omp_clause_code kind,\n+c_parser_omp_variable_list (c_parser *parser,\n+\t\t\t    location_t clause_loc,\n+\t\t\t    enum omp_clause_code kind,\n                             tree list)\n {\n   if (c_parser_next_token_is_not (parser, CPP_NAME)\n@@ -7028,13 +7103,13 @@ c_parser_omp_variable_list (c_parser *parser, enum omp_clause_code kind,\n       tree t = lookup_name (c_parser_peek_token (parser)->value);\n \n       if (t == NULL_TREE)\n-\tundeclared_variable (c_parser_peek_token (parser)->value,\n-\t\t\t     c_parser_peek_token (parser)->location);\n+\tundeclared_variable (c_parser_peek_token (parser)->location,\n+\t\t\t     c_parser_peek_token (parser)->value);\n       else if (t == error_mark_node)\n \t;\n       else if (kind != 0)\n \t{\n-\t  tree u = build_omp_clause (kind);\n+\t  tree u = build_omp_clause (clause_loc, kind);\n \t  OMP_CLAUSE_DECL (u) = t;\n \t  OMP_CLAUSE_CHAIN (u) = list;\n \t  list = u;\n@@ -7060,9 +7135,12 @@ static tree\n c_parser_omp_var_list_parens (c_parser *parser, enum omp_clause_code kind,\n \t\t\t      tree list)\n {\n+  /* The clauses location.  */\n+  location_t loc = c_parser_peek_token (parser)->location;\n+\n   if (c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n     {\n-      list = c_parser_omp_variable_list (parser, kind, list);\n+      list = c_parser_omp_variable_list (parser, loc, kind, list);\n       c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n     }\n   return list;\n@@ -7097,7 +7175,7 @@ c_parser_omp_clause_collapse (c_parser *parser, tree list)\n \t\t\"collapse argument needs positive constant integer expression\");\n       return list;\n     }\n-  c = build_omp_clause (OMP_CLAUSE_COLLAPSE);\n+  c = build_omp_clause (loc, OMP_CLAUSE_COLLAPSE);\n   OMP_CLAUSE_COLLAPSE_EXPR (c) = num;\n   OMP_CLAUSE_CHAIN (c) = list;\n   return c;\n@@ -7128,6 +7206,7 @@ static tree\n c_parser_omp_clause_default (c_parser *parser, tree list)\n {\n   enum omp_clause_default_kind kind = OMP_CLAUSE_DEFAULT_UNSPECIFIED;\n+  location_t loc = c_parser_peek_token (parser)->location;\n   tree c;\n \n   if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n@@ -7167,7 +7246,7 @@ c_parser_omp_clause_default (c_parser *parser, tree list)\n     return list;\n \n   check_no_duplicate_clause (list, OMP_CLAUSE_DEFAULT, \"default\");\n-  c = build_omp_clause (OMP_CLAUSE_DEFAULT);\n+  c = build_omp_clause (loc, OMP_CLAUSE_DEFAULT);\n   OMP_CLAUSE_CHAIN (c) = list;\n   OMP_CLAUSE_DEFAULT_KIND (c) = kind;\n \n@@ -7189,14 +7268,15 @@ c_parser_omp_clause_firstprivate (c_parser *parser, tree list)\n static tree\n c_parser_omp_clause_if (c_parser *parser, tree list)\n {\n+  location_t loc = c_parser_peek_token (parser)->location;\n   if (c_parser_next_token_is (parser, CPP_OPEN_PAREN))\n     {\n       tree t = c_parser_paren_condition (parser);\n       tree c;\n \n       check_no_duplicate_clause (list, OMP_CLAUSE_IF, \"if\");\n \n-      c = build_omp_clause (OMP_CLAUSE_IF);\n+      c = build_omp_clause (loc, OMP_CLAUSE_IF);\n       OMP_CLAUSE_IF_EXPR (c) = t;\n       OMP_CLAUSE_CHAIN (c) = list;\n       list = c;\n@@ -7223,10 +7303,11 @@ static tree\n c_parser_omp_clause_nowait (c_parser *parser ATTRIBUTE_UNUSED, tree list)\n {\n   tree c;\n+  location_t loc = c_parser_peek_token (parser)->location;\n \n   check_no_duplicate_clause (list, OMP_CLAUSE_NOWAIT, \"nowait\");\n \n-  c = build_omp_clause (OMP_CLAUSE_NOWAIT);\n+  c = build_omp_clause (loc, OMP_CLAUSE_NOWAIT);\n   OMP_CLAUSE_CHAIN (c) = list;\n   return c;\n }\n@@ -7237,6 +7318,7 @@ c_parser_omp_clause_nowait (c_parser *parser ATTRIBUTE_UNUSED, tree list)\n static tree\n c_parser_omp_clause_num_threads (c_parser *parser, tree list)\n {\n+  location_t num_threads_loc = c_parser_peek_token (parser)->location;\n   if (c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n     {\n       location_t expr_loc = c_parser_peek_token (parser)->location;\n@@ -7254,6 +7336,8 @@ c_parser_omp_clause_num_threads (c_parser *parser, tree list)\n       /* Attempt to statically determine when the number isn't positive.  */\n       c = fold_build2 (LE_EXPR, boolean_type_node, t,\n \t\t       build_int_cst (TREE_TYPE (t), 0));\n+      if (CAN_HAVE_LOCATION_P (c))\n+\tSET_EXPR_LOCATION (c, expr_loc);\n       if (c == boolean_true_node)\n \t{\n \t  warning_at (expr_loc, 0,\n@@ -7263,7 +7347,7 @@ c_parser_omp_clause_num_threads (c_parser *parser, tree list)\n \n       check_no_duplicate_clause (list, OMP_CLAUSE_NUM_THREADS, \"num_threads\");\n \n-      c = build_omp_clause (OMP_CLAUSE_NUM_THREADS);\n+      c = build_omp_clause (num_threads_loc, OMP_CLAUSE_NUM_THREADS);\n       OMP_CLAUSE_NUM_THREADS_EXPR (c) = t;\n       OMP_CLAUSE_CHAIN (c) = list;\n       list = c;\n@@ -7276,14 +7360,16 @@ c_parser_omp_clause_num_threads (c_parser *parser, tree list)\n    ordered */\n \n static tree\n-c_parser_omp_clause_ordered (c_parser *parser ATTRIBUTE_UNUSED, tree list)\n+c_parser_omp_clause_ordered (c_parser *parser, tree list)\n {\n   tree c;\n \n   check_no_duplicate_clause (list, OMP_CLAUSE_ORDERED, \"ordered\");\n \n-  c = build_omp_clause (OMP_CLAUSE_ORDERED);\n+  c = build_omp_clause (c_parser_peek_token (parser)->location,\n+\t\t\tOMP_CLAUSE_ORDERED);\n   OMP_CLAUSE_CHAIN (c) = list;\n+\n   return c;\n }\n \n@@ -7305,6 +7391,7 @@ c_parser_omp_clause_private (c_parser *parser, tree list)\n static tree\n c_parser_omp_clause_reduction (c_parser *parser, tree list)\n {\n+  location_t clause_loc = c_parser_peek_token (parser)->location;\n   if (c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n     {\n       enum tree_code code;\n@@ -7347,7 +7434,8 @@ c_parser_omp_clause_reduction (c_parser *parser, tree list)\n \t{\n \t  tree nl, c;\n \n-\t  nl = c_parser_omp_variable_list (parser, OMP_CLAUSE_REDUCTION, list);\n+\t  nl = c_parser_omp_variable_list (parser, clause_loc,\n+\t\t\t\t\t   OMP_CLAUSE_REDUCTION, list);\n \t  for (c = nl; c != list; c = OMP_CLAUSE_CHAIN (c))\n \t    OMP_CLAUSE_REDUCTION_CODE (c) = code;\n \n@@ -7370,11 +7458,12 @@ static tree\n c_parser_omp_clause_schedule (c_parser *parser, tree list)\n {\n   tree c, t;\n+  location_t loc = c_parser_peek_token (parser)->location;\n \n   if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n     return list;\n \n-  c = build_omp_clause (OMP_CLAUSE_SCHEDULE);\n+  c = build_omp_clause (loc, OMP_CLAUSE_SCHEDULE);\n \n   if (c_parser_next_token_is (parser, CPP_NAME))\n     {\n@@ -7470,8 +7559,10 @@ c_parser_omp_clause_untied (c_parser *parser ATTRIBUTE_UNUSED, tree list)\n   /* FIXME: Should we allow duplicates?  */\n   check_no_duplicate_clause (list, OMP_CLAUSE_UNTIED, \"untied\");\n \n-  c = build_omp_clause (OMP_CLAUSE_UNTIED);\n+  c = build_omp_clause (c_parser_peek_token (parser)->location,\n+\t\t\tOMP_CLAUSE_UNTIED);\n   OMP_CLAUSE_CHAIN (c) = list;\n+\n   return c;\n }\n \n@@ -7607,10 +7698,12 @@ c_parser_omp_structured_block (c_parser *parser)\n    binop:\n      +, *, -, /, &, ^, |, <<, >>\n \n-  where x is an lvalue expression with scalar type.  */\n+  where x is an lvalue expression with scalar type.  \n+\n+  LOC is the location of the #pragma token.  */\n \n static void\n-c_parser_omp_atomic (c_parser *parser)\n+c_parser_omp_atomic (location_t loc, c_parser *parser)\n {\n   tree lhs, rhs;\n   tree stmt;\n@@ -7679,13 +7772,16 @@ c_parser_omp_atomic (c_parser *parser)\n \t}\n \n       c_parser_consume_token (parser);\n-      rhs_expr = c_parser_expression (parser);\n-      rhs_expr = default_function_array_conversion (rhs_expr);\n+      {\n+\tlocation_t rhs_loc = c_parser_peek_token (parser)->location;\n+\trhs_expr = c_parser_expression (parser);\n+\trhs_expr = default_function_array_conversion (rhs_loc, rhs_expr);\n+      }\n       rhs = rhs_expr.value;\n       rhs = c_fully_fold (rhs, false, NULL);\n       break;\n     }\n-  stmt = c_finish_omp_atomic (code, lhs, rhs);\n+  stmt = c_finish_omp_atomic (loc, code, lhs, rhs);\n   if (stmt != error_mark_node)\n     add_stmt (stmt);\n   c_parser_skip_until_found (parser, CPP_SEMICOLON, \"expected %<;%>\");\n@@ -7699,19 +7795,21 @@ c_parser_omp_atomic (c_parser *parser)\n static void\n c_parser_omp_barrier (c_parser *parser)\n {\n+  location_t loc = c_parser_peek_token (parser)->location;\n   c_parser_consume_pragma (parser);\n   c_parser_skip_to_pragma_eol (parser);\n \n-  c_finish_omp_barrier ();\n+  c_finish_omp_barrier (loc);\n }\n \n /* OpenMP 2.5:\n    # pragma omp critical [(name)] new-line\n      structured-block\n-*/\n+\n+  LOC is the location of the #pragma itself.  */\n \n static tree\n-c_parser_omp_critical (c_parser *parser)\n+c_parser_omp_critical (location_t loc, c_parser *parser)\n {\n   tree stmt, name = NULL;\n \n@@ -7732,7 +7830,7 @@ c_parser_omp_critical (c_parser *parser)\n   c_parser_skip_to_pragma_eol (parser);\n \n   stmt = c_parser_omp_structured_block (parser);\n-  return c_finish_omp_critical (stmt, name);\n+  return c_finish_omp_critical (loc, stmt, name);\n }\n \n /* OpenMP 2.5:\n@@ -7744,28 +7842,31 @@ c_parser_omp_critical (c_parser *parser)\n static void\n c_parser_omp_flush (c_parser *parser)\n {\n+  location_t loc = c_parser_peek_token (parser)->location;\n   c_parser_consume_pragma (parser);\n   if (c_parser_next_token_is (parser, CPP_OPEN_PAREN))\n     c_parser_omp_var_list_parens (parser, OMP_CLAUSE_ERROR, NULL);\n   else if (c_parser_next_token_is_not (parser, CPP_PRAGMA_EOL))\n     c_parser_error (parser, \"expected %<(%> or end of line\");\n   c_parser_skip_to_pragma_eol (parser);\n \n-  c_finish_omp_flush ();\n+  c_finish_omp_flush (loc);\n }\n \n /* Parse the restricted form of the for statement allowed by OpenMP.\n    The real trick here is to determine the loop control variable early\n-   so that we can push a new decl if necessary to make it private.  */\n+   so that we can push a new decl if necessary to make it private.\n+   LOC is the location of the OMP in \"#pragma omp\".  */\n \n static tree\n-c_parser_omp_for_loop (c_parser *parser, tree clauses, tree *par_clauses)\n+c_parser_omp_for_loop (location_t loc,\n+\t\t       c_parser *parser, tree clauses, tree *par_clauses)\n {\n   tree decl, cond, incr, save_break, save_cont, body, init, stmt, cl;\n   tree declv, condv, incrv, initv, for_block = NULL, ret = NULL;\n-  location_t loc;\n   bool fail = false, open_brace_parsed = false;\n   int i, collapse = 1, nbraces = 0;\n+  location_t for_loc;\n \n   for (cl = clauses; cl; cl = OMP_CLAUSE_CHAIN (cl))\n     if (OMP_CLAUSE_CODE (cl) == OMP_CLAUSE_COLLAPSE)\n@@ -7783,7 +7884,7 @@ c_parser_omp_for_loop (c_parser *parser, tree clauses, tree *par_clauses)\n       c_parser_error (parser, \"for statement expected\");\n       return NULL;\n     }\n-  loc = c_parser_peek_token (parser)->location;\n+  for_loc = c_parser_peek_token (parser)->location;\n   c_parser_consume_token (parser);\n \n   for (i = 0; i < collapse; i++)\n@@ -7800,7 +7901,7 @@ c_parser_omp_for_loop (c_parser *parser, tree clauses, tree *par_clauses)\n \t    for_block\n \t      = tree_cons (NULL, c_begin_compound_stmt (true), for_block);\n \t  c_parser_declaration_or_fndef (parser, true, true, true, true);\n-\t  decl = check_for_loop_decls ();\n+\t  decl = check_for_loop_decls (for_loc);\n \t  if (decl == NULL)\n \t    goto error_init;\n \t  if (DECL_INITIAL (decl) == error_mark_node)\n@@ -7818,14 +7919,14 @@ c_parser_omp_for_loop (c_parser *parser, tree clauses, tree *par_clauses)\n \t  decl = decl_exp.value;\n \n \t  c_parser_require (parser, CPP_EQ, \"expected %<=%>\");\n-\t  init_loc = c_parser_peek_token (parser)->location;\n \n+\t  init_loc = c_parser_peek_token (parser)->location;\n \t  init_exp = c_parser_expr_no_commas (parser, NULL);\n-\t  init_exp = default_function_array_conversion (init_exp);\n+\t  init_exp = default_function_array_conversion (init_loc, init_exp);\n \t  init = build_modify_expr (init_loc, decl, decl_exp.original_type,\n-\t\t\t\t    NOP_EXPR, init_exp.value,\n+\t\t\t\t    NOP_EXPR, init_loc, init_exp.value,\n \t\t\t\t    init_exp.original_type);\n-\t  init = c_process_expr_stmt (init);\n+\t  init = c_process_expr_stmt (init_loc, init);\n \n \t  c_parser_skip_until_found (parser, CPP_SEMICOLON, \"expected %<;%>\");\n \t}\n@@ -7873,8 +7974,8 @@ c_parser_omp_for_loop (c_parser *parser, tree clauses, tree *par_clauses)\n \t{\n \t  location_t incr_loc = c_parser_peek_token (parser)->location;\n \n-\t  incr = c_process_expr_stmt (c_parser_expression (parser).value);\n-\t  protected_set_expr_location (incr, incr_loc);\n+\t  incr = c_process_expr_stmt (incr_loc,\n+\t\t\t\t      c_parser_expression (parser).value);\n \t}\n       c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, \"expected %<)%>\");\n \n@@ -7937,14 +8038,19 @@ c_parser_omp_for_loop (c_parser *parser, tree clauses, tree *par_clauses)\n \n   if (open_brace_parsed)\n     {\n+      location_t here = c_parser_peek_token (parser)->location;\n       stmt = c_begin_compound_stmt (true);\n       c_parser_compound_statement_nostart (parser);\n-      add_stmt (c_end_compound_stmt (stmt, true));\n+      add_stmt (c_end_compound_stmt (here, stmt, true));\n     }\n   else\n     add_stmt (c_parser_c99_block_statement (parser));\n   if (c_cont_label)\n-    add_stmt (build1 (LABEL_EXPR, void_type_node, c_cont_label));\n+    {\n+      tree t = build1 (LABEL_EXPR, void_type_node, c_cont_label);\n+      SET_EXPR_LOCATION (t, loc);\n+      add_stmt (t);\n+    }\n \n   body = pop_stmt_list (body);\n   c_break_label = save_break;\n@@ -7964,10 +8070,11 @@ c_parser_omp_for_loop (c_parser *parser, tree clauses, tree *par_clauses)\n \t  c_parser_error (parser, \"collapsed loops not perfectly nested\");\n \t  while (nbraces)\n \t    {\n+\t      location_t here = c_parser_peek_token (parser)->location;\n \t      stmt = c_begin_compound_stmt (true);\n \t      add_stmt (body);\n \t      c_parser_compound_statement_nostart (parser);\n-\t      body = c_end_compound_stmt (stmt, true);\n+\t      body = c_end_compound_stmt (here, stmt, true);\n \t      nbraces--;\n \t    }\n \t  goto pop_scopes;\n@@ -8007,7 +8114,8 @@ c_parser_omp_for_loop (c_parser *parser, tree clauses, tree *par_clauses)\n \t\t\t/* Copy lastprivate (decl) clause to OMP_FOR_CLAUSES,\n \t\t\t   change it to shared (decl) in\n \t\t\t   OMP_PARALLEL_CLAUSES.  */\n-\t\t\ttree l = build_omp_clause (OMP_CLAUSE_LASTPRIVATE);\n+\t\t\ttree l = build_omp_clause (OMP_CLAUSE_LOCATION (*c),\n+\t\t\t\t\t\t   OMP_CLAUSE_LASTPRIVATE);\n \t\t\tOMP_CLAUSE_DECL (l) = OMP_CLAUSE_DECL (*c);\n \t\t\tOMP_CLAUSE_CHAIN (l) = clauses;\n \t\t\tclauses = l;\n@@ -8022,7 +8130,10 @@ c_parser_omp_for_loop (c_parser *parser, tree clauses, tree *par_clauses)\n pop_scopes:\n   while (for_block)\n     {\n-      stmt = c_end_compound_stmt (TREE_VALUE (for_block), true);\n+      /* FIXME diagnostics: LOC below should be the actual location of\n+\t this particular for block.  We need to build a list of\n+\t locations to go along with FOR_BLOCK.  */\n+      stmt = c_end_compound_stmt (loc, TREE_VALUE (for_block), true);\n       add_stmt (stmt);\n       for_block = TREE_CHAIN (for_block);\n     }\n@@ -8032,6 +8143,8 @@ c_parser_omp_for_loop (c_parser *parser, tree clauses, tree *par_clauses)\n /* OpenMP 2.5:\n    #pragma omp for for-clause[optseq] new-line\n      for-loop\n+\n+   LOC is the location of the #pragma token.\n */\n \n #define OMP_FOR_CLAUSE_MASK\t\t\t\t\\\n@@ -8045,16 +8158,16 @@ c_parser_omp_for_loop (c_parser *parser, tree clauses, tree *par_clauses)\n \t| (1u << PRAGMA_OMP_CLAUSE_NOWAIT))\n \n static tree\n-c_parser_omp_for (c_parser *parser)\n+c_parser_omp_for (location_t loc, c_parser *parser)\n {\n   tree block, clauses, ret;\n \n   clauses = c_parser_omp_all_clauses (parser, OMP_FOR_CLAUSE_MASK,\n \t\t\t\t      \"#pragma omp for\");\n \n   block = c_begin_compound_stmt (true);\n-  ret = c_parser_omp_for_loop (parser, clauses, NULL);\n-  block = c_end_compound_stmt (block, true);\n+  ret = c_parser_omp_for_loop (loc, parser, clauses, NULL);\n+  block = c_end_compound_stmt (loc, block, true);\n   add_stmt (block);\n \n   return ret;\n@@ -8063,25 +8176,29 @@ c_parser_omp_for (c_parser *parser)\n /* OpenMP 2.5:\n    # pragma omp master new-line\n      structured-block\n+\n+   LOC is the location of the #pragma token.\n */\n \n static tree\n-c_parser_omp_master (c_parser *parser)\n+c_parser_omp_master (location_t loc, c_parser *parser)\n {\n   c_parser_skip_to_pragma_eol (parser);\n-  return c_finish_omp_master (c_parser_omp_structured_block (parser));\n+  return c_finish_omp_master (loc, c_parser_omp_structured_block (parser));\n }\n \n /* OpenMP 2.5:\n    # pragma omp ordered new-line\n      structured-block\n+\n+   LOC is the location of the #pragma itself.\n */\n \n static tree\n-c_parser_omp_ordered (c_parser *parser)\n+c_parser_omp_ordered (location_t loc, c_parser *parser)\n {\n   c_parser_skip_to_pragma_eol (parser);\n-  return c_finish_omp_ordered (c_parser_omp_structured_block (parser));\n+  return c_finish_omp_ordered (loc, c_parser_omp_structured_block (parser));\n }\n \n /* OpenMP 2.5:\n@@ -8091,15 +8208,18 @@ c_parser_omp_ordered (c_parser *parser)\n \n    section-sequence:\n      section-directive[opt] structured-block\n-     section-sequence section-directive structured-block  */\n+     section-sequence section-directive structured-block  \n+\n+    SECTIONS_LOC is the location of the #pragma omp sections.  */\n \n static tree\n-c_parser_omp_sections_scope (c_parser *parser)\n+c_parser_omp_sections_scope (location_t sections_loc, c_parser *parser)\n {\n   tree stmt, substmt;\n   bool error_suppress = false;\n   location_t loc;\n \n+  loc = c_parser_peek_token (parser)->location;\n   if (!c_parser_require (parser, CPP_OPEN_BRACE, \"expected %<{%>\"))\n     {\n       /* Avoid skipping until the end of the block.  */\n@@ -8109,7 +8229,6 @@ c_parser_omp_sections_scope (c_parser *parser)\n \n   stmt = push_stmt_list ();\n \n-  loc = c_parser_peek_token (parser)->location;\n   if (c_parser_peek_token (parser)->pragma_kind != PRAGMA_OMP_SECTION)\n     {\n       substmt = push_stmt_list ();\n@@ -8163,6 +8282,7 @@ c_parser_omp_sections_scope (c_parser *parser)\n   substmt = pop_stmt_list (stmt);\n \n   stmt = make_node (OMP_SECTIONS);\n+  SET_EXPR_LOCATION (stmt, sections_loc);\n   TREE_TYPE (stmt) = void_type_node;\n   OMP_SECTIONS_BODY (stmt) = substmt;\n \n@@ -8172,6 +8292,8 @@ c_parser_omp_sections_scope (c_parser *parser)\n /* OpenMP 2.5:\n    # pragma omp sections sections-clause[optseq] newline\n      sections-scope\n+\n+   LOC is the location of the #pragma token.\n */\n \n #define OMP_SECTIONS_CLAUSE_MASK\t\t\t\\\n@@ -8182,18 +8304,18 @@ c_parser_omp_sections_scope (c_parser *parser)\n \t| (1u << PRAGMA_OMP_CLAUSE_NOWAIT))\n \n static tree\n-c_parser_omp_sections (c_parser *parser)\n+c_parser_omp_sections (location_t loc, c_parser *parser)\n {\n   tree block, clauses, ret;\n \n   clauses = c_parser_omp_all_clauses (parser, OMP_SECTIONS_CLAUSE_MASK,\n \t\t\t\t      \"#pragma omp sections\");\n \n   block = c_begin_compound_stmt (true);\n-  ret = c_parser_omp_sections_scope (parser);\n+  ret = c_parser_omp_sections_scope (loc, parser);\n   if (ret)\n     OMP_SECTIONS_CLAUSES (ret) = clauses;\n-  block = c_end_compound_stmt (block, true);\n+  block = c_end_compound_stmt (loc, block, true);\n   add_stmt (block);\n \n   return ret;\n@@ -8203,6 +8325,8 @@ c_parser_omp_sections (c_parser *parser)\n    # pragma parallel parallel-clause new-line\n    # pragma parallel for parallel-for-clause new-line\n    # pragma parallel sections parallel-sections-clause new-line\n+\n+   LOC is the location of the #pragma token.\n */\n \n #define OMP_PARALLEL_CLAUSE_MASK\t\t\t\\\n@@ -8216,7 +8340,7 @@ c_parser_omp_sections (c_parser *parser)\n \t| (1u << PRAGMA_OMP_CLAUSE_NUM_THREADS))\n \n static tree\n-c_parser_omp_parallel (c_parser *parser)\n+c_parser_omp_parallel (location_t loc, c_parser *parser)\n {\n   enum pragma_kind p_kind = PRAGMA_OMP_PARALLEL;\n   const char *p_name = \"#pragma omp parallel\";\n@@ -8251,24 +8375,24 @@ c_parser_omp_parallel (c_parser *parser)\n     case PRAGMA_OMP_PARALLEL:\n       block = c_begin_omp_parallel ();\n       c_parser_statement (parser);\n-      stmt = c_finish_omp_parallel (clauses, block);\n+      stmt = c_finish_omp_parallel (loc, clauses, block);\n       break;\n \n     case PRAGMA_OMP_PARALLEL_FOR:\n       block = c_begin_omp_parallel ();\n-      c_split_parallel_clauses (clauses, &par_clause, &ws_clause);\n-      c_parser_omp_for_loop (parser, ws_clause, &par_clause);\n-      stmt = c_finish_omp_parallel (par_clause, block);\n+      c_split_parallel_clauses (loc, clauses, &par_clause, &ws_clause);\n+      c_parser_omp_for_loop (loc, parser, ws_clause, &par_clause);\n+      stmt = c_finish_omp_parallel (loc, par_clause, block);\n       OMP_PARALLEL_COMBINED (stmt) = 1;\n       break;\n \n     case PRAGMA_OMP_PARALLEL_SECTIONS:\n       block = c_begin_omp_parallel ();\n-      c_split_parallel_clauses (clauses, &par_clause, &ws_clause);\n-      stmt = c_parser_omp_sections_scope (parser);\n+      c_split_parallel_clauses (loc, clauses, &par_clause, &ws_clause);\n+      stmt = c_parser_omp_sections_scope (loc, parser);\n       if (stmt)\n \tOMP_SECTIONS_CLAUSES (stmt) = ws_clause;\n-      stmt = c_finish_omp_parallel (par_clause, block);\n+      stmt = c_finish_omp_parallel (loc, par_clause, block);\n       OMP_PARALLEL_COMBINED (stmt) = 1;\n       break;\n \n@@ -8282,6 +8406,8 @@ c_parser_omp_parallel (c_parser *parser)\n /* OpenMP 2.5:\n    # pragma omp single single-clause[optseq] new-line\n      structured-block\n+\n+   LOC is the location of the #pragma.\n */\n \n #define OMP_SINGLE_CLAUSE_MASK\t\t\t\t\\\n@@ -8291,9 +8417,10 @@ c_parser_omp_parallel (c_parser *parser)\n \t| (1u << PRAGMA_OMP_CLAUSE_NOWAIT))\n \n static tree\n-c_parser_omp_single (c_parser *parser)\n+c_parser_omp_single (location_t loc, c_parser *parser)\n {\n   tree stmt = make_node (OMP_SINGLE);\n+  SET_EXPR_LOCATION (stmt, loc);\n   TREE_TYPE (stmt) = void_type_node;\n \n   OMP_SINGLE_CLAUSES (stmt)\n@@ -8306,6 +8433,8 @@ c_parser_omp_single (c_parser *parser)\n \n /* OpenMP 3.0:\n    # pragma omp task task-clause[optseq] new-line\n+\n+   LOC is the location of the #pragma.\n */\n \n #define OMP_TASK_CLAUSE_MASK\t\t\t\t\\\n@@ -8317,7 +8446,7 @@ c_parser_omp_single (c_parser *parser)\n \t| (1u << PRAGMA_OMP_CLAUSE_SHARED))\n \n static tree\n-c_parser_omp_task (c_parser *parser)\n+c_parser_omp_task (location_t loc, c_parser *parser)\n {\n   tree clauses, block;\n \n@@ -8326,7 +8455,7 @@ c_parser_omp_task (c_parser *parser)\n \n   block = c_begin_omp_task ();\n   c_parser_statement (parser);\n-  return c_finish_omp_task (clauses, block);\n+  return c_finish_omp_task (loc, clauses, block);\n }\n \n /* OpenMP 3.0:\n@@ -8336,10 +8465,11 @@ c_parser_omp_task (c_parser *parser)\n static void\n c_parser_omp_taskwait (c_parser *parser)\n {\n+  location_t loc = c_parser_peek_token (parser)->location;\n   c_parser_consume_pragma (parser);\n   c_parser_skip_to_pragma_eol (parser);\n \n-  c_finish_omp_taskwait ();\n+  c_finish_omp_taskwait (loc);\n }\n \n /* Main entry point to parsing most OpenMP pragmas.  */\n@@ -8364,38 +8494,38 @@ c_parser_omp_construct (c_parser *parser)\n   switch (p_kind)\n     {\n     case PRAGMA_OMP_ATOMIC:\n-      c_parser_omp_atomic (parser);\n+      c_parser_omp_atomic (loc, parser);\n       return;\n     case PRAGMA_OMP_CRITICAL:\n-      stmt = c_parser_omp_critical (parser);\n+      stmt = c_parser_omp_critical (loc, parser);\n       break;\n     case PRAGMA_OMP_FOR:\n-      stmt = c_parser_omp_for (parser);\n+      stmt = c_parser_omp_for (loc, parser);\n       break;\n     case PRAGMA_OMP_MASTER:\n-      stmt = c_parser_omp_master (parser);\n+      stmt = c_parser_omp_master (loc, parser);\n       break;\n     case PRAGMA_OMP_ORDERED:\n-      stmt = c_parser_omp_ordered (parser);\n+      stmt = c_parser_omp_ordered (loc, parser);\n       break;\n     case PRAGMA_OMP_PARALLEL:\n-      stmt = c_parser_omp_parallel (parser);\n+      stmt = c_parser_omp_parallel (loc, parser);\n       break;\n     case PRAGMA_OMP_SECTIONS:\n-      stmt = c_parser_omp_sections (parser);\n+      stmt = c_parser_omp_sections (loc, parser);\n       break;\n     case PRAGMA_OMP_SINGLE:\n-      stmt = c_parser_omp_single (parser);\n+      stmt = c_parser_omp_single (loc, parser);\n       break;\n     case PRAGMA_OMP_TASK:\n-      stmt = c_parser_omp_task (parser);\n+      stmt = c_parser_omp_task (loc, parser);\n       break;\n     default:\n       gcc_unreachable ();\n     }\n \n   if (stmt)\n-    SET_EXPR_LOCATION (stmt, loc);\n+    gcc_assert (EXPR_LOCATION (stmt) != UNKNOWN_LOCATION);\n }\n \n \n@@ -8406,27 +8536,35 @@ static void\n c_parser_omp_threadprivate (c_parser *parser)\n {\n   tree vars, t;\n+  location_t loc;\n \n   c_parser_consume_pragma (parser);\n+  loc = c_parser_peek_token (parser)->location;\n   vars = c_parser_omp_var_list_parens (parser, OMP_CLAUSE_ERROR, NULL);\n \n   /* Mark every variable in VARS to be assigned thread local storage.  */\n   for (t = vars; t; t = TREE_CHAIN (t))\n     {\n       tree v = TREE_PURPOSE (t);\n \n+      /* FIXME diagnostics: Ideally we should keep individual\n+\t locations for all the variables in the var list to make the\n+\t following errors more precise.  Perhaps\n+\t c_parser_omp_var_list_parens() should construct a list of\n+\t locations to go along with the var list.  */\n+\n       /* If V had already been marked threadprivate, it doesn't matter\n \t whether it had been used prior to this point.  */\n       if (TREE_CODE (v) != VAR_DECL)\n-\terror (\"%qD is not a variable\", v);\n+\terror_at (loc, \"%qD is not a variable\", v);\n       else if (TREE_USED (v) && !C_DECL_THREADPRIVATE_P (v))\n-\terror (\"%qE declared %<threadprivate%> after first use\", v);\n+\terror_at (loc, \"%qE declared %<threadprivate%> after first use\", v);\n       else if (! TREE_STATIC (v) && ! DECL_EXTERNAL (v))\n-\terror (\"automatic variable %qE cannot be %<threadprivate%>\", v);\n+\terror_at (loc, \"automatic variable %qE cannot be %<threadprivate%>\", v);\n       else if (TREE_TYPE (v) == error_mark_node)\n \t;\n       else if (! COMPLETE_TYPE_P (TREE_TYPE (v)))\n-\terror (\"%<threadprivate%> %qE has incomplete type\", v);\n+\terror_at (loc, \"%<threadprivate%> %qE has incomplete type\", v);\n       else\n \t{\n \t  if (! DECL_THREAD_LOCAL_P (v))"}, {"sha": "c91ee991dbab699d2e3bb029f2eced82e71106cd", "filename": "gcc/c-pragma.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fc-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fc-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pragma.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -455,7 +455,8 @@ maybe_apply_pending_pragma_weaks (void)\n       if (TREE_VALUE (t) == NULL)\n \tcontinue;\n \n-      decl = build_decl (FUNCTION_DECL, alias_id, default_function_type);\n+      decl = build_decl (UNKNOWN_LOCATION,\n+\t\t\t FUNCTION_DECL, alias_id, default_function_type);\n \n       DECL_ARTIFICIAL (decl) = 1;\n       TREE_PUBLIC (decl) = 1;"}, {"sha": "2bfad472db071736de9b406c60ecbc41afb0b77d", "filename": "gcc/c-semantics.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fc-semantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fc-semantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-semantics.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -103,12 +103,12 @@ pop_stmt_list (tree t)\n \n /* Build a generic statement based on the given type of node and\n    arguments. Similar to `build_nt', except that we set\n-   EXPR_LOCATION to be the current source location.  */\n+   EXPR_LOCATION to LOC. */\n /* ??? This should be obsolete with the lineno_stmt productions\n    in the grammar.  */\n \n tree\n-build_stmt (enum tree_code code, ...)\n+build_stmt (location_t loc, enum tree_code code, ...)\n {\n   tree ret;\n   int length, i;\n@@ -123,7 +123,7 @@ build_stmt (enum tree_code code, ...)\n   ret = make_node (code);\n   TREE_TYPE (ret) = void_type_node;\n   length = TREE_CODE_LENGTH (code);\n-  SET_EXPR_LOCATION (ret, input_location);\n+  SET_EXPR_LOCATION (ret, loc);\n \n   /* TREE_SIDE_EFFECTS will already be set for statements with\n      implicit side effects.  Here we make sure it is set for other\n@@ -148,7 +148,8 @@ build_stmt (enum tree_code code, ...)\n /* Create a CASE_LABEL_EXPR tree node and return it.  */\n \n tree\n-build_case_label (tree low_value, tree high_value, tree label_decl)\n+build_case_label (location_t loc,\n+\t\t  tree low_value, tree high_value, tree label_decl)\n {\n-  return build_stmt (CASE_LABEL_EXPR, low_value, high_value, label_decl);\n+  return build_stmt (loc, CASE_LABEL_EXPR, low_value, high_value, label_decl);\n }"}, {"sha": "d6062177375c475d267b531b1600d5ad4a486e17", "filename": "gcc/c-tree.h", "status": "modified", "additions": 40, "deletions": 39, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -360,7 +360,7 @@ struct c_declarator {\n   enum c_declarator_kind kind;\n   /* Except for cdk_id, the contained declarator.  For cdk_id, NULL.  */\n   struct c_declarator *declarator;\n-  location_t id_loc; /* Currently only set for cdk_id. */\n+  location_t id_loc; /* Currently only set for cdk_id, cdk_array. */\n   union {\n     /* For identifiers, an IDENTIFIER_NODE or NULL_TREE if an abstract\n        declarator.  */\n@@ -505,26 +505,27 @@ extern void c_init_decl_processing (void);\n extern void c_dup_lang_specific_decl (tree);\n extern void c_print_identifier (FILE *, tree, int);\n extern int quals_from_declspecs (const struct c_declspecs *);\n-extern struct c_declarator *build_array_declarator (tree, struct c_declspecs *,\n+extern struct c_declarator *build_array_declarator (location_t, tree,\n+    \t\t\t\t\t\t    struct c_declspecs *,\n \t\t\t\t\t\t    bool, bool);\n-extern tree build_enumerator (struct c_enum_contents *, tree, tree, location_t);\n-extern tree check_for_loop_decls (void);\n+extern tree build_enumerator (location_t, struct c_enum_contents *, tree, tree);\n+extern tree check_for_loop_decls (location_t);\n extern void mark_forward_parm_decls (void);\n extern void declare_parm_level (void);\n-extern void undeclared_variable (tree, location_t);\n+extern void undeclared_variable (location_t, tree);\n extern tree declare_label (tree);\n extern tree define_label (location_t, tree);\n extern void c_maybe_initialize_eh (void);\n-extern void finish_decl (tree, tree, tree, tree);\n+extern void finish_decl (tree, location_t, tree, tree, tree);\n extern tree finish_enum (tree, tree, tree);\n extern void finish_function (void);\n-extern tree finish_struct (tree, tree, tree, bool, VEC(tree,heap) *);\n+extern tree finish_struct (location_t, tree, tree, tree, bool, VEC(tree,heap) *);\n extern struct c_arg_info *get_parm_info (bool);\n extern tree grokfield (location_t, struct c_declarator *,\n \t\t       struct c_declspecs *, tree, tree *);\n extern tree groktypename (struct c_type_name *, tree *, bool *);\n extern tree grokparm (const struct c_parm *);\n-extern tree implicitly_declare (tree);\n+extern tree implicitly_declare (location_t, tree);\n extern void keep_next_level (void);\n extern void pending_xref_error (void);\n extern void c_push_function_context (void);\n@@ -536,16 +537,15 @@ extern tree c_builtin_function (tree);\n extern tree c_builtin_function_ext_scope (tree);\n extern void shadow_tag (const struct c_declspecs *);\n extern void shadow_tag_warned (const struct c_declspecs *, int);\n-extern tree start_enum (struct c_enum_contents *, tree, location_t);\n+extern tree start_enum (location_t, struct c_enum_contents *, tree);\n extern int  start_function (struct c_declspecs *, struct c_declarator *, tree);\n extern tree start_decl (struct c_declarator *, struct c_declspecs *, bool,\n \t\t\ttree);\n-extern tree start_struct (enum tree_code, tree, bool *, VEC(tree,heap) **,\n-\t\t\t  location_t);\n+extern tree start_struct (location_t, enum tree_code, tree, bool *, VEC(tree,heap) **);\n extern void store_parm_decls (void);\n extern void store_parm_decls_from (struct c_arg_info *);\n extern tree xref_tag (enum tree_code, tree);\n-extern struct c_typespec parser_xref_tag (enum tree_code, tree, location_t);\n+extern struct c_typespec parser_xref_tag (location_t, enum tree_code, tree);\n extern int c_expand_decl (tree);\n extern struct c_parm *build_c_parm (struct c_declspecs *, tree,\n \t\t\t\t    struct c_declarator *);\n@@ -594,24 +594,25 @@ extern bool c_vla_type_p (const_tree);\n extern bool c_mark_addressable (tree);\n extern void c_incomplete_type_error (const_tree, const_tree);\n extern tree c_type_promotes_to (tree);\n-extern struct c_expr default_function_array_conversion (struct c_expr);\n+extern struct c_expr default_function_array_conversion (location_t,\n+    \t\t\t\t\t\t\tstruct c_expr);\n extern tree composite_type (tree, tree);\n-extern tree build_component_ref (tree, tree);\n-extern tree build_array_ref (tree, tree, location_t);\n-extern tree build_external_ref (tree, int, location_t, tree *);\n+extern tree build_component_ref (location_t, tree, tree);\n+extern tree build_array_ref (location_t, tree, tree);\n+extern tree build_external_ref (location_t, tree, int, tree *);\n extern void pop_maybe_used (bool);\n-extern struct c_expr c_expr_sizeof_expr (struct c_expr);\n-extern struct c_expr c_expr_sizeof_type (struct c_type_name *);\n-extern struct c_expr parser_build_unary_op (enum tree_code, struct c_expr,\n-    \t\t\t\t\t    location_t);\n+extern struct c_expr c_expr_sizeof_expr (location_t, struct c_expr);\n+extern struct c_expr c_expr_sizeof_type (location_t, struct c_type_name *);\n+extern struct c_expr parser_build_unary_op (location_t, enum tree_code,\n+    \t\t\t\t\t    struct c_expr);\n extern struct c_expr parser_build_binary_op (location_t, \n     \t\t\t\t\t     enum tree_code, struct c_expr,\n \t\t\t\t\t     struct c_expr);\n extern tree build_conditional_expr (location_t, tree, bool, tree, tree);\n-extern tree build_compound_expr (tree, tree);\n-extern tree c_cast_expr (struct c_type_name *, tree, location_t);\n-extern tree build_c_cast (tree, tree);\n-extern void store_init_value (tree, tree, tree);\n+extern tree build_compound_expr (location_t, tree, tree);\n+extern tree c_cast_expr (location_t, struct c_type_name *, tree);\n+extern tree build_c_cast (location_t, tree, tree);\n+extern void store_init_value (location_t, tree, tree, tree);\n extern void error_init (const char *);\n extern void pedwarn_init (location_t, int opt, const char *);\n extern void maybe_warn_string_init (tree, struct c_expr);\n@@ -623,34 +624,34 @@ extern struct c_expr pop_init_level (int);\n extern void set_init_index (tree, tree);\n extern void set_init_label (tree);\n extern void process_init_element (struct c_expr, bool);\n-extern tree build_compound_literal (tree, tree, bool);\n-extern void check_compound_literal_type (struct c_type_name *, location_t);\n-extern tree c_start_case (tree);\n+extern tree build_compound_literal (location_t, tree, tree, bool);\n+extern void check_compound_literal_type (location_t, struct c_type_name *);\n+extern tree c_start_case (location_t, location_t, tree);\n extern void c_finish_case (tree);\n-extern tree build_asm_expr (tree, tree, tree, tree, bool);\n+extern tree build_asm_expr (location_t, tree, tree, tree, tree, bool);\n extern tree build_asm_stmt (tree, tree);\n extern int c_types_compatible_p (tree, tree);\n extern tree c_begin_compound_stmt (bool);\n-extern tree c_end_compound_stmt (tree, bool);\n+extern tree c_end_compound_stmt (location_t, tree, bool);\n extern void c_finish_if_stmt (location_t, tree, tree, tree, bool);\n extern void c_finish_loop (location_t, tree, tree, tree, tree, tree, bool);\n extern tree c_begin_stmt_expr (void);\n-extern tree c_finish_stmt_expr (tree);\n-extern tree c_process_expr_stmt (tree);\n-extern tree c_finish_expr_stmt (tree);\n-extern tree c_finish_return (tree, tree);\n-extern tree c_finish_bc_stmt (tree *, bool);\n-extern tree c_finish_goto_label (tree);\n-extern tree c_finish_goto_ptr (tree);\n+extern tree c_finish_stmt_expr (location_t, tree);\n+extern tree c_process_expr_stmt (location_t, tree);\n+extern tree c_finish_expr_stmt (location_t, tree);\n+extern tree c_finish_return (location_t, tree, tree);\n+extern tree c_finish_bc_stmt (location_t, tree *, bool);\n+extern tree c_finish_goto_label (location_t, tree);\n+extern tree c_finish_goto_ptr (location_t, tree);\n extern void c_begin_vm_scope (unsigned int);\n extern void c_end_vm_scope (unsigned int);\n extern tree c_expr_to_decl (tree, bool *, bool *);\n extern tree c_begin_omp_parallel (void);\n-extern tree c_finish_omp_parallel (tree, tree);\n+extern tree c_finish_omp_parallel (location_t, tree, tree);\n extern tree c_begin_omp_task (void);\n-extern tree c_finish_omp_task (tree, tree);\n+extern tree c_finish_omp_task (location_t, tree, tree);\n extern tree c_finish_omp_clauses (tree);\n-extern tree c_build_va_arg (tree, tree, location_t);\n+extern tree c_build_va_arg (location_t, tree, tree);\n \n /* Set to 0 at beginning of a function definition, set to 1 if\n    a return statement that specifies a return value is seen.  */"}, {"sha": "978e95c4b456c699124cdced3e579688acabdf4d", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 326, "deletions": 229, "changes": 555, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -98,7 +98,7 @@ static void push_member_name (tree);\n static int spelling_length (void);\n static char *print_spelling (char *);\n static void warning_init (int, const char *);\n-static tree digest_init (tree, tree, tree, bool, bool, int);\n+static tree digest_init (location_t, tree, tree, tree, bool, bool, int);\n static void output_init_element (tree, tree, bool, tree, tree, int, bool);\n static void output_pending_init_elements (int);\n static int set_designator (int);\n@@ -1659,7 +1659,7 @@ decl_constant_value (tree decl)\n \n /* Convert the array expression EXP to a pointer.  */\n static tree\n-array_to_pointer_conversion (tree exp)\n+array_to_pointer_conversion (location_t loc, tree exp)\n {\n   tree orig_exp = exp;\n   tree type = TREE_TYPE (exp);\n@@ -1679,13 +1679,13 @@ array_to_pointer_conversion (tree exp)\n   if (TREE_CODE (exp) == INDIRECT_REF)\n     return convert (ptrtype, TREE_OPERAND (exp, 0));\n \n-  adr = build_unary_op (EXPR_LOCATION (exp), ADDR_EXPR, exp, 1);\n+  adr = build_unary_op (loc, ADDR_EXPR, exp, 1);\n   return convert (ptrtype, adr);\n }\n \n /* Convert the function expression EXP to a pointer.  */\n static tree\n-function_to_pointer_conversion (tree exp)\n+function_to_pointer_conversion (location_t loc, tree exp)\n {\n   tree orig_exp = exp;\n \n@@ -1696,15 +1696,17 @@ function_to_pointer_conversion (tree exp)\n   if (TREE_NO_WARNING (orig_exp))\n     TREE_NO_WARNING (exp) = 1;\n \n-  return build_unary_op (EXPR_LOCATION (exp), ADDR_EXPR, exp, 0);\n+  return build_unary_op (loc, ADDR_EXPR, exp, 0);\n }\n \n /* Perform the default conversion of arrays and functions to pointers.\n    Return the result of converting EXP.  For any other expression, just\n-   return EXP.  */\n+   return EXP.\n+\n+   LOC is the location of the expression.  */\n \n struct c_expr\n-default_function_array_conversion (struct c_expr exp)\n+default_function_array_conversion (location_t loc, struct c_expr exp)\n {\n   tree orig_exp = exp.value;\n   tree type = TREE_TYPE (exp.value);\n@@ -1739,11 +1741,11 @@ default_function_array_conversion (struct c_expr exp)\n \t    return exp;\n \t  }\n \n-\texp.value = array_to_pointer_conversion (exp.value);\n+\texp.value = array_to_pointer_conversion (loc, exp.value);\n       }\n       break;\n     case FUNCTION_TYPE:\n-      exp.value = function_to_pointer_conversion (exp.value);\n+      exp.value = function_to_pointer_conversion (loc, exp.value);\n       break;\n     default:\n       break;\n@@ -1944,11 +1946,12 @@ lookup_field (tree decl, tree component)\n   return tree_cons (NULL_TREE, field, NULL_TREE);\n }\n \n-/* Make an expression to refer to the COMPONENT field of\n-   structure or union value DATUM.  COMPONENT is an IDENTIFIER_NODE.  */\n+/* Make an expression to refer to the COMPONENT field of structure or\n+   union value DATUM.  COMPONENT is an IDENTIFIER_NODE.  LOC is the\n+   location of the COMPONENT_REF.  */\n \n tree\n-build_component_ref (tree datum, tree component)\n+build_component_ref (location_t loc, tree datum, tree component)\n {\n   tree type = TREE_TYPE (datum);\n   enum tree_code code = TREE_CODE (type);\n@@ -1973,7 +1976,7 @@ build_component_ref (tree datum, tree component)\n \n       if (!field)\n \t{\n-\t  error (\"%qT has no member named %qE\", type, component);\n+\t  error_at (loc, \"%qT has no member named %qE\", type, component);\n \t  return error_mark_node;\n \t}\n \n@@ -2006,6 +2009,7 @@ build_component_ref (tree datum, tree component)\n \n \t  ref = build3 (COMPONENT_REF, subtype, datum, subdatum,\n \t\t\tNULL_TREE);\n+\t  SET_EXPR_LOCATION (ref, loc);\n \t  if (TREE_READONLY (subdatum)\n \t      || (use_datum_quals && TREE_READONLY (datum)))\n \t    TREE_READONLY (ref) = 1;\n@@ -2025,8 +2029,9 @@ build_component_ref (tree datum, tree component)\n       return ref;\n     }\n   else if (code != ERROR_MARK)\n-    error (\"request for member %qE in something not a structure or union\",\n-\t   component);\n+    error_at (loc,\n+\t      \"request for member %qE in something not a structure or union\",\n+\t      component);\n \n   return error_mark_node;\n }\n@@ -2113,7 +2118,7 @@ build_indirect_ref (location_t loc, tree ptr, const char *errorstring)\n    LOC is the location to use for the returned expression.  */\n \n tree\n-build_array_ref (tree array, tree index, location_t loc)\n+build_array_ref (location_t loc, tree array, tree index)\n {\n   tree ret;\n   bool swapped = false;\n@@ -2243,7 +2248,7 @@ build_array_ref (tree array, tree index, location_t loc)\n    for CONST_DECLs defined as enum constants.  If the type of the\n    identifier is not available, *TYPE is set to NULL.  */\n tree\n-build_external_ref (tree id, int fun, location_t loc, tree *type)\n+build_external_ref (location_t loc, tree id, int fun, tree *type)\n {\n   tree ref;\n   tree decl = lookup_name (id);\n@@ -2260,14 +2265,14 @@ build_external_ref (tree id, int fun, location_t loc, tree *type)\n     }\n   else if (fun)\n     /* Implicit function declaration.  */\n-    ref = implicitly_declare (id);\n+    ref = implicitly_declare (loc, id);\n   else if (decl == error_mark_node)\n     /* Don't complain about something that's already been\n        complained about.  */\n     return error_mark_node;\n   else\n     {\n-      undeclared_variable (id, loc);\n+      undeclared_variable (loc, id);\n       return error_mark_node;\n     }\n \n@@ -2393,7 +2398,7 @@ pop_maybe_used (bool used)\n /* Return the result of sizeof applied to EXPR.  */\n \n struct c_expr\n-c_expr_sizeof_expr (struct c_expr expr)\n+c_expr_sizeof_expr (location_t loc, struct c_expr expr)\n {\n   struct c_expr ret;\n   if (expr.value == error_mark_node)\n@@ -2408,7 +2413,7 @@ c_expr_sizeof_expr (struct c_expr expr)\n       bool expr_const_operands = true;\n       tree folded_expr = c_fully_fold (expr.value, require_constant_value,\n \t\t\t\t       &expr_const_operands);\n-      ret.value = c_sizeof (TREE_TYPE (folded_expr));\n+      ret.value = c_sizeof (loc, TREE_TYPE (folded_expr));\n       ret.original_code = ERROR_MARK;\n       ret.original_type = NULL;\n       if (c_vla_type_p (TREE_TYPE (folded_expr)))\n@@ -2417,24 +2422,26 @@ c_expr_sizeof_expr (struct c_expr expr)\n \t  ret.value = build2 (C_MAYBE_CONST_EXPR, TREE_TYPE (ret.value),\n \t\t\t      folded_expr, ret.value);\n \t  C_MAYBE_CONST_EXPR_NON_CONST (ret.value) = !expr_const_operands;\n+\t  SET_EXPR_LOCATION (ret.value, loc);\n \t}\n       pop_maybe_used (C_TYPE_VARIABLE_SIZE (TREE_TYPE (folded_expr)));\n     }\n   return ret;\n }\n \n /* Return the result of sizeof applied to T, a structure for the type\n-   name passed to sizeof (rather than the type itself).  */\n+   name passed to sizeof (rather than the type itself).  LOC is the\n+   location of the original expression.  */\n \n struct c_expr\n-c_expr_sizeof_type (struct c_type_name *t)\n+c_expr_sizeof_type (location_t loc, struct c_type_name *t)\n {\n   tree type;\n   struct c_expr ret;\n   tree type_expr = NULL_TREE;\n   bool type_expr_const = true;\n   type = groktypename (t, &type_expr, &type_expr_const);\n-  ret.value = c_sizeof (type);\n+  ret.value = c_sizeof (loc, type);\n   ret.original_code = ERROR_MARK;\n   ret.original_type = NULL;\n   if ((type_expr || TREE_CODE (ret.value) == INTEGER_CST)\n@@ -2459,20 +2466,21 @@ c_expr_sizeof_type (struct c_type_name *t)\n }\n \n /* Build a function call to function FUNCTION with parameters PARAMS.\n+   The function call is at LOC.\n    PARAMS is a list--a chain of TREE_LIST nodes--in which the\n    TREE_VALUE of each node is a parameter-expression.\n    FUNCTION's data type may be a function type or a pointer-to-function.  */\n \n tree\n-build_function_call (tree function, tree params)\n+build_function_call (location_t loc, tree function, tree params)\n {\n   VEC(tree,gc) *vec;\n   tree ret;\n \n   vec = VEC_alloc (tree, gc, list_length (params));\n   for (; params; params = TREE_CHAIN (params))\n     VEC_quick_push (tree, vec, TREE_VALUE (params));\n-  ret = build_function_call_vec (function, vec, NULL);\n+  ret = build_function_call_vec (loc, function, vec, NULL);\n   VEC_free (tree, gc, vec);\n   return ret;\n }\n@@ -2486,7 +2494,7 @@ build_function_call (tree function, tree params)\n    PARAMS.  */\n \n tree\n-build_function_call_vec (tree function, VEC(tree,gc) *params,\n+build_function_call_vec (location_t loc, tree function, VEC(tree,gc) *params,\n \t\t\t VEC(tree,gc) *origtypes)\n {\n   tree fntype, fundecl = 0;\n@@ -2506,15 +2514,15 @@ build_function_call_vec (tree function, VEC(tree,gc) *params,\n \t resolve_overloaded_builtin and targetm.resolve_overloaded_builtin\n \t handle all the type checking.  The result is a complete expression\n \t that implements this function call.  */\n-      tem = resolve_overloaded_builtin (function, params);\n+      tem = resolve_overloaded_builtin (loc, function, params);\n       if (tem)\n \treturn tem;\n \n       name = DECL_NAME (function);\n       fundecl = function;\n     }\n   if (TREE_CODE (TREE_TYPE (function)) == FUNCTION_TYPE)\n-    function = function_to_pointer_conversion (function);\n+    function = function_to_pointer_conversion (loc, function);\n \n   /* For Objective-C, convert any calls via a cast to OBJC_TYPE_REF\n      expressions, like those used for ObjC messenger dispatches.  */\n@@ -2532,7 +2540,7 @@ build_function_call_vec (tree function, VEC(tree,gc) *params,\n   if (!(TREE_CODE (fntype) == POINTER_TYPE\n \t&& TREE_CODE (TREE_TYPE (fntype)) == FUNCTION_TYPE))\n     {\n-      error (\"called object %qE is not a function\", function);\n+      error_at (loc, \"called object %qE is not a function\", function);\n       return error_mark_node;\n     }\n \n@@ -2561,17 +2569,17 @@ build_function_call_vec (tree function, VEC(tree,gc) *params,\n       && !comptypes (fntype, TREE_TYPE (tem)))\n     {\n       tree return_type = TREE_TYPE (fntype);\n-      tree trap = build_function_call (built_in_decls[BUILT_IN_TRAP],\n+      tree trap = build_function_call (loc, built_in_decls[BUILT_IN_TRAP],\n \t\t\t\t       NULL_TREE);\n       int i;\n \n       /* This situation leads to run-time undefined behavior.  We can't,\n \t therefore, simply error unless we can prove that all possible\n \t executions of the program must execute the code.  */\n-      if (warning (0, \"function called through a non-compatible type\"))\n+      if (warning_at (loc, 0, \"function called through a non-compatible type\"))\n \t/* We can, however, treat \"undefined\" any way we please.\n \t   Call abort to encourage the user to fix the program.  */\n-\tinform (input_location, \"if this code is reached, the program will abort\");\n+\tinform (loc, \"if this code is reached, the program will abort\");\n       /* Before the abort, allow the function arguments to exit or\n \t call longjmp.  */\n       for (i = 0; i < nargs; i++)\n@@ -2590,7 +2598,7 @@ build_function_call_vec (tree function, VEC(tree,gc) *params,\n \t  tree rhs;\n \n \t  if (AGGREGATE_TYPE_P (return_type))\n-\t    rhs = build_compound_literal (return_type,\n+\t    rhs = build_compound_literal (loc, return_type,\n \t\t\t\t\t  build_constructor (return_type, 0),\n \t\t\t\t\t  false);\n \t  else\n@@ -2856,7 +2864,8 @@ convert_arguments (tree typelist, VEC(tree,gc) *values,\n \t\t\t   and the actual arg is that enum type.  */\n \t\t\t;\n \t\t      else if (formal_prec != TYPE_PRECISION (type1))\n-\t\t\twarning (OPT_Wtraditional_conversion, \"passing argument %d of %qE \"\n+\t\t\twarning (OPT_Wtraditional_conversion,\n+\t\t\t\t \"passing argument %d of %qE \"\n \t\t\t\t \"with different width due to prototype\",\n \t\t\t\t argnum, rname);\n \t\t      else if (TYPE_UNSIGNED (type) == TYPE_UNSIGNED (type1))\n@@ -2879,11 +2888,13 @@ convert_arguments (tree typelist, VEC(tree,gc) *values,\n \t\t\t       && TYPE_UNSIGNED (valtype))\n \t\t\t;\n \t\t      else if (TYPE_UNSIGNED (type))\n-\t\t\twarning (OPT_Wtraditional_conversion, \"passing argument %d of %qE \"\n+\t\t\twarning (OPT_Wtraditional_conversion,\n+\t\t\t\t \"passing argument %d of %qE \"\n \t\t\t\t \"as unsigned due to prototype\",\n \t\t\t\t argnum, rname);\n \t\t      else\n-\t\t\twarning (OPT_Wtraditional_conversion, \"passing argument %d of %qE \"\n+\t\t\twarning (OPT_Wtraditional_conversion,\n+\t\t\t\t \"passing argument %d of %qE \"\n \t\t\t\t \"as signed due to prototype\", argnum, rname);\n \t\t    }\n \t\t}\n@@ -2957,7 +2968,7 @@ convert_arguments (tree typelist, VEC(tree,gc) *values,\n */\n \n struct c_expr\n-parser_build_unary_op (enum tree_code code, struct c_expr arg, location_t loc)\n+parser_build_unary_op (location_t loc, enum tree_code code, struct c_expr arg)\n {\n   struct c_expr result;\n \n@@ -2966,7 +2977,7 @@ parser_build_unary_op (enum tree_code code, struct c_expr arg, location_t loc)\n   result.original_type = NULL;\n \n   if (TREE_OVERFLOW_P (result.value) && !TREE_OVERFLOW_P (arg.value))\n-    overflow_warning (result.value);\n+    overflow_warning (loc, result.value);\n \n   return result;\n }\n@@ -3020,16 +3031,18 @@ parser_build_binary_op (location_t location, enum tree_code code,\n     {\n       if ((code1 == STRING_CST && !integer_zerop (arg2.value))\n \t  || (code2 == STRING_CST && !integer_zerop (arg1.value)))\n-\twarning (OPT_Waddress, \"comparison with string literal results in unspecified behavior\");\n+\twarning_at (location, OPT_Waddress,\n+\t\t    \"comparison with string literal results in unspecified behavior\");\n     }\n   else if (TREE_CODE_CLASS (code) == tcc_comparison\n \t   && (code1 == STRING_CST || code2 == STRING_CST))\n-    warning (OPT_Waddress, \"comparison with string literal results in unspecified behavior\");\n+    warning_at (location, OPT_Waddress,\n+\t\t\"comparison with string literal results in unspecified behavior\");\n \n   if (TREE_OVERFLOW_P (result.value) \n       && !TREE_OVERFLOW_P (arg1.value) \n       && !TREE_OVERFLOW_P (arg2.value))\n-    overflow_warning (result.value);\n+    overflow_warning (location, result.value);\n \n   /* Warn about comparisons of different enum types.  */\n   if (warn_enum_compare\n@@ -3478,7 +3491,8 @@ build_unary_op (location_t location,\n \t    return error_mark_node;\n \t  return build_binary_op (location, PLUS_EXPR,\n \t\t\t\t  (TREE_CODE (TREE_TYPE (op0)) == ARRAY_TYPE\n-\t\t\t\t   ? array_to_pointer_conversion (op0)\n+\t\t\t\t   ? array_to_pointer_conversion (location,\n+\t\t\t\t\t\t\t\t  op0)\n \t\t\t\t   : op0),\n \t\t\t\t  TREE_OPERAND (arg, 1), 1);\n \t}\n@@ -3755,7 +3769,7 @@ c_mark_addressable (tree exp)\n    IFEXP_BCP then the condition is a call to __builtin_constant_p, and\n    if folded to an integer constant then the unselected half may\n    contain arbitrary operations not normally permitted in constant\n-   expressions.  */\n+   expressions.  Set the location of the expression to LOC.  */\n \n tree\n build_conditional_expr (location_t colon_loc, tree ifexp, bool ifexp_bcp,\n@@ -3983,7 +3997,7 @@ build_conditional_expr (location_t colon_loc, tree ifexp, bool ifexp_bcp,\n \tresult_type = void_type_node;\n       else\n \t{\n-\t  error (\"type mismatch in conditional expression\");\n+\t  error_at (colon_loc, \"type mismatch in conditional expression\");\n \t  return error_mark_node;\n \t}\n     }\n@@ -4032,14 +4046,17 @@ build_conditional_expr (location_t colon_loc, tree ifexp, bool ifexp_bcp,\n   if (ep_result_type)\n     ret = build1 (EXCESS_PRECISION_EXPR, ep_result_type, ret);\n \n+  protected_set_expr_location (ret, colon_loc);\n   return ret;\n }\n \f\n /* Return a compound expression that performs two expressions and\n-   returns the value of the second of them.  */\n+   returns the value of the second of them.\n+\n+   LOC is the location of the COMPOUND_EXPR.  */\n \n tree\n-build_compound_expr (tree expr1, tree expr2)\n+build_compound_expr (location_t loc, tree expr1, tree expr2)\n {\n   bool expr1_int_operands, expr2_int_operands;\n   tree eptype = NULL_TREE;\n@@ -4075,8 +4092,8 @@ build_compound_expr (tree expr1, tree expr2)\n \t\t   && CONVERT_EXPR_P (TREE_OPERAND (expr1, 1)))\n \t    ; /* (void) a, (void) b, c */\n \t  else\n-\t    warning (OPT_Wunused_value, \n-\t\t     \"left-hand operand of comma expression has no effect\");\n+\t    warning_at (loc, OPT_Wunused_value, \n+\t\t\t\"left-hand operand of comma expression has no effect\");\n \t}\n     }\n \n@@ -4085,7 +4102,7 @@ build_compound_expr (tree expr1, tree expr2)\n      `foo() + bar(), baz()' the result of the `+' operator is not used,\n      so we should issue a warning.  */\n   else if (warn_unused_value)\n-    warn_if_unused_value (expr1, input_location);\n+    warn_if_unused_value (expr1, loc);\n \n   if (expr2 == error_mark_node)\n     return error_mark_node;\n@@ -4100,6 +4117,7 @@ build_compound_expr (tree expr1, tree expr2)\n   if (eptype)\n     ret = build1 (EXCESS_PRECISION_EXPR, eptype, ret);\n \n+  protected_set_expr_location (ret, loc);\n   return ret;\n }\n \n@@ -4190,10 +4208,11 @@ handle_warn_cast_qual (tree type, tree otype)\n   while (TREE_CODE (in_type) == POINTER_TYPE);\n }\n \n-/* Build an expression representing a cast to type TYPE of expression EXPR.  */\n+/* Build an expression representing a cast to type TYPE of expression EXPR.  \n+   LOC is the location of the cast-- typically the open paren of the cast.  */\n \n tree\n-build_c_cast (tree type, tree expr)\n+build_c_cast (location_t loc, tree type, tree expr)\n {\n   tree value;\n \n@@ -4215,13 +4234,13 @@ build_c_cast (tree type, tree expr)\n \n   if (TREE_CODE (type) == ARRAY_TYPE)\n     {\n-      error (\"cast specifies array type\");\n+      error_at (loc, \"cast specifies array type\");\n       return error_mark_node;\n     }\n \n   if (TREE_CODE (type) == FUNCTION_TYPE)\n     {\n-      error (\"cast specifies function type\");\n+      error_at (loc, \"cast specifies function type\");\n       return error_mark_node;\n     }\n \n@@ -4236,7 +4255,7 @@ build_c_cast (tree type, tree expr)\n     {\n       if (TREE_CODE (type) == RECORD_TYPE\n \t  || TREE_CODE (type) == UNION_TYPE)\n-\tpedwarn (input_location, OPT_pedantic, \n+\tpedwarn (loc, OPT_pedantic, \n \t\t \"ISO C forbids casting nonscalar to the same type\");\n     }\n   else if (TREE_CODE (type) == UNION_TYPE)\n@@ -4253,23 +4272,26 @@ build_c_cast (tree type, tree expr)\n \t{\n \t  tree t;\n \n-\t  pedwarn (input_location, OPT_pedantic,\n-\t\t   \"ISO C forbids casts to union type\");\n-\t  t = digest_init (type,\n+\t  pedwarn (loc, OPT_pedantic, \"ISO C forbids casts to union type\");\n+\t  t = digest_init (loc, type,\n \t\t\t   build_constructor_single (type, field, value),\n \t\t\t   NULL_TREE, false, true, 0);\n \t  TREE_CONSTANT (t) = TREE_CONSTANT (value);\n \t  return t;\n \t}\n-      error (\"cast to union type from type not present in union\");\n+      error_at (loc, \"cast to union type from type not present in union\");\n       return error_mark_node;\n     }\n   else\n     {\n       tree otype, ovalue;\n \n       if (type == void_type_node)\n-\treturn build1 (CONVERT_EXPR, type, value);\n+\t{\n+\t  tree t = build1 (CONVERT_EXPR, type, value);\n+\t  SET_EXPR_LOCATION (t, loc);\n+\t  return t;\n+\t}\n \n       otype = TREE_TYPE (value);\n \n@@ -4291,8 +4313,8 @@ build_c_cast (tree type, tree expr)\n \t\t|| TREE_CODE (TREE_TYPE (otype)) == RECORD_TYPE)\n \t       && TYPE_MODE (TREE_TYPE (otype)) == VOIDmode)\n \t  && TYPE_ALIGN (TREE_TYPE (type)) > TYPE_ALIGN (TREE_TYPE (otype)))\n-\twarning (OPT_Wcast_align,\n-\t\t \"cast increases required alignment of target type\");\n+\twarning_at (loc, OPT_Wcast_align,\n+\t\t    \"cast increases required alignment of target type\");\n \n       if (TREE_CODE (type) == INTEGER_TYPE\n \t  && TREE_CODE (otype) == POINTER_TYPE\n@@ -4302,21 +4324,23 @@ build_c_cast (tree type, tree expr)\n          of cases such as SIG_*, warn about converting constant\n          pointers to integers. In some cases it may cause unwanted\n          sign extension, and a warning is appropriate.  */\n-\twarning (OPT_Wpointer_to_int_cast,\n-\t\t \"cast from pointer to integer of different size\");\n+\twarning_at (loc, OPT_Wpointer_to_int_cast,\n+\t\t    \"cast from pointer to integer of different size\");\n \n       if (TREE_CODE (value) == CALL_EXPR\n \t  && TREE_CODE (type) != TREE_CODE (otype))\n-\twarning (OPT_Wbad_function_cast, \"cast from function call of type %qT \"\n-\t\t \"to non-matching type %qT\", otype, type);\n+\twarning_at (loc, OPT_Wbad_function_cast,\n+\t\t    \"cast from function call of type %qT \"\n+\t\t    \"to non-matching type %qT\", otype, type);\n \n       if (TREE_CODE (type) == POINTER_TYPE\n \t  && TREE_CODE (otype) == INTEGER_TYPE\n \t  && TYPE_PRECISION (type) != TYPE_PRECISION (otype)\n \t  /* Don't warn about converting any constant.  */\n \t  && !TREE_CONSTANT (value))\n-\twarning (OPT_Wint_to_pointer_cast, \"cast to pointer from integer \"\n-\t\t \"of different size\");\n+\twarning_at (loc,\n+\t\t    OPT_Wint_to_pointer_cast, \"cast to pointer from integer \"\n+\t\t    \"of different size\");\n \n       if (warn_strict_aliasing <= 2)\n         strict_aliasing_warning (otype, type, expr);\n@@ -4329,7 +4353,7 @@ build_c_cast (tree type, tree expr)\n \t  && TREE_CODE (otype) == POINTER_TYPE\n \t  && TREE_CODE (TREE_TYPE (otype)) == FUNCTION_TYPE\n \t  && TREE_CODE (TREE_TYPE (type)) != FUNCTION_TYPE)\n-\tpedwarn (input_location, OPT_pedantic, \"ISO C forbids \"\n+\tpedwarn (loc, OPT_pedantic, \"ISO C forbids \"\n \t\t \"conversion of function pointer to object pointer type\");\n \n       if (pedantic\n@@ -4338,7 +4362,7 @@ build_c_cast (tree type, tree expr)\n \t  && TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE\n \t  && TREE_CODE (TREE_TYPE (otype)) != FUNCTION_TYPE\n \t  && !null_pointer_constant_p (value))\n-\tpedwarn (input_location, OPT_pedantic, \"ISO C forbids \"\n+\tpedwarn (loc, OPT_pedantic, \"ISO C forbids \"\n \t\t \"conversion of object pointer to function pointer type\");\n \n       ovalue = value;\n@@ -4382,12 +4406,16 @@ build_c_cast (tree type, tree expr)\n \t       || TREE_CODE (expr) == COMPLEX_CST)))\n       value = build1 (NOP_EXPR, type, value);\n \n+  if (CAN_HAVE_LOCATION_P (value))\n+    SET_EXPR_LOCATION (value, loc);\n   return value;\n }\n \n-/* Interpret a cast of expression EXPR to type TYPE.  */\n+/* Interpret a cast of expression EXPR to type TYPE.  LOC is the\n+   location of the open paren of the cast, or the position of the cast\n+   expr.  */\n tree\n-c_cast_expr (struct c_type_name *type_name, tree expr, location_t loc)\n+c_cast_expr (location_t loc, struct c_type_name *type_name, tree expr)\n {\n   tree type;\n   tree type_expr = NULL_TREE;\n@@ -4402,11 +4430,12 @@ c_cast_expr (struct c_type_name *type_name, tree expr, location_t loc)\n   type = groktypename (type_name, &type_expr, &type_expr_const);\n   warn_strict_prototypes = saved_wsp;\n \n-  ret = build_c_cast (type, expr);\n+  ret = build_c_cast (loc, type, expr);\n   if (type_expr)\n     {\n       ret = build2 (C_MAYBE_CONST_EXPR, TREE_TYPE (ret), type_expr, ret);\n       C_MAYBE_CONST_EXPR_NON_CONST (ret) = !type_expr_const;\n+      SET_EXPR_LOCATION (ret, loc);\n     }\n \n   if (CAN_HAVE_LOCATION_P (ret) && !EXPR_HAS_LOCATION (ret))\n@@ -4429,11 +4458,13 @@ c_cast_expr (struct c_type_name *type_name, tree expr, location_t loc)\n    If RHS_ORIGTYPE is not NULL_TREE, it is the original type of RHS,\n    which may differ from TREE_TYPE (RHS) for an enum value.\n \n-   LOCATION is the location of the MODIFYCODE operator.  */\n+   LOCATION is the location of the MODIFYCODE operator.\n+   RHS_LOC is the location of the RHS.  */\n \n tree\n build_modify_expr (location_t location, tree lhs, tree lhs_origtype,\n-\t\t   enum tree_code modifycode, tree rhs, tree rhs_origtype)\n+\t\t   enum tree_code modifycode, \n+\t\t   location_t rhs_loc, tree rhs, tree rhs_origtype)\n {\n   tree result;\n   tree newrhs;\n@@ -4463,7 +4494,7 @@ build_modify_expr (location_t location, tree lhs, tree lhs_origtype,\n   if (TREE_CODE (lhs) == C_MAYBE_CONST_EXPR)\n     {\n       tree inner = build_modify_expr (location, C_MAYBE_CONST_EXPR_EXPR (lhs),\n-\t\t\t\t      lhs_origtype, modifycode, rhs,\n+\t\t\t\t      lhs_origtype, modifycode, rhs_loc, rhs,\n \t\t\t\t      rhs_origtype);\n       if (inner == error_mark_node)\n \treturn error_mark_node;\n@@ -4596,6 +4627,7 @@ build_modify_expr (location_t location, tree lhs, tree lhs_origtype,\n    ERRTYPE says whether it is argument passing, assignment,\n    initialization or return.\n \n+   LOCATION is the location of the RHS.\n    FUNCTION is a tree for the function being called.\n    PARMNUM is the number of the argument, for printing in error messages.  */\n \n@@ -4634,14 +4666,14 @@ convert_for_assignment (location_t location, tree type, tree rhs,\n   /* This macro is used to emit diagnostics to ensure that all format\n      strings are complete sentences, visible to gettext and checked at\n      compile time.  */\n-#define WARN_FOR_ASSIGNMENT(LOCATION, OPT, AR, AS, IN, RE)               \\\n+#define WARN_FOR_ASSIGNMENT(LOCATION, OPT, AR, AS, IN, RE)             \t \\\n   do {                                                                   \\\n     switch (errtype)                                                     \\\n       {                                                                  \\\n       case ic_argpass:                                                   \\\n         if (pedwarn (LOCATION, OPT, AR, parmnum, rname))                 \\\n-          inform ((fundecl && !DECL_IS_BUILTIN (fundecl))                \\\n-\t\t  ? DECL_SOURCE_LOCATION (fundecl) : LOCATION,           \\\n+          inform ((fundecl && !DECL_IS_BUILTIN (fundecl))\t         \\\n+\t      \t  ? DECL_SOURCE_LOCATION (fundecl) : LOCATION,\t\t \\\n                   \"expected %qT but argument is of type %qT\",            \\\n                   type, rhstype);                                        \\\n         break;                                                           \\\n@@ -4652,7 +4684,7 @@ convert_for_assignment (location_t location, tree type, tree rhs,\n         pedwarn (LOCATION, OPT, IN);                                     \\\n         break;                                                           \\\n       case ic_return:                                                    \\\n-        pedwarn (LOCATION, OPT, RE);                                     \\\n+        pedwarn (LOCATION, OPT, RE);                                 \t \\\n         break;                                                           \\\n       default:                                                           \\\n         gcc_unreachable ();                                              \\\n@@ -4723,7 +4755,7 @@ convert_for_assignment (location_t location, tree type, tree rhs,\n \t an unprototyped function, it is compile-time undefined;\n \t making it a constraint in that case was rejected in\n \t DR#252.  */\n-      error (\"void value not ignored as it ought to be\");\n+      error_at (location, \"void value not ignored as it ought to be\");\n       return error_mark_node;\n     }\n   rhs = require_complete_type (rhs);\n@@ -4737,22 +4769,27 @@ convert_for_assignment (location_t location, tree type, tree rhs,\n     {\n       if (!lvalue_p (rhs))\n \t{\n-\t  error (\"cannot pass rvalue to reference parameter\");\n+\t  error_at (location, \"cannot pass rvalue to reference parameter\");\n \t  return error_mark_node;\n \t}\n       if (!c_mark_addressable (rhs))\n \treturn error_mark_node;\n       rhs = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (rhs)), rhs);\n+      SET_EXPR_LOCATION (rhs, location);\n \n       /* We already know that these two types are compatible, but they\n \t may not be exactly identical.  In fact, `TREE_TYPE (type)' is\n \t likely to be __builtin_va_list and `TREE_TYPE (rhs)' is\n \t likely to be va_list, a typedef to __builtin_va_list, which\n \t is different enough that it will cause problems later.  */\n       if (TREE_TYPE (TREE_TYPE (rhs)) != TREE_TYPE (type))\n-\trhs = build1 (NOP_EXPR, build_pointer_type (TREE_TYPE (type)), rhs);\n+\t{\n+\t  rhs = build1 (NOP_EXPR, build_pointer_type (TREE_TYPE (type)), rhs);\n+\t  SET_EXPR_LOCATION (rhs, location);\n+\t}\n \n       rhs = build1 (NOP_EXPR, type, rhs);\n+      SET_EXPR_LOCATION (rhs, location);\n       return rhs;\n     }\n   /* Some types can interconvert without explicit casts.  */\n@@ -4859,7 +4896,7 @@ convert_for_assignment (location_t location, tree type, tree rhs,\n \t\t     function where an ordinary one is wanted, but not\n \t\t     vice-versa.  */\n \t\t  if (TYPE_QUALS (ttl) & ~TYPE_QUALS (ttr))\n-\t\t    WARN_FOR_ASSIGNMENT (input_location, 0,\n+\t\t    WARN_FOR_ASSIGNMENT (location, 0,\n \t\t\t\t\t G_(\"passing argument %d of %qE \"\n \t\t\t\t\t    \"makes qualified function \"\n \t\t\t\t\t    \"pointer from unqualified\"),\n@@ -4873,7 +4910,7 @@ convert_for_assignment (location_t location, tree type, tree rhs,\n \t\t\t\t\t    \"pointer from unqualified\"));\n \t\t}\n \t      else if (TYPE_QUALS (ttr) & ~TYPE_QUALS (ttl))\n-\t\tWARN_FOR_ASSIGNMENT (input_location, 0,\n+\t\tWARN_FOR_ASSIGNMENT (location, 0,\n \t\t\t\t     G_(\"passing argument %d of %qE discards \"\n \t\t\t\t\t\"qualifiers from pointer target type\"),\n \t\t\t\t     G_(\"assignment discards qualifiers \"\n@@ -4887,7 +4924,7 @@ convert_for_assignment (location_t location, tree type, tree rhs,\n \t    }\n \n \t  if (!fundecl || !DECL_IN_SYSTEM_HEADER (fundecl))\n-\t    pedwarn (input_location, OPT_pedantic, \n+\t    pedwarn (location, OPT_pedantic, \n \t\t     \"ISO C prohibits argument conversion to union type\");\n \n \t  rhs = fold_convert (TREE_TYPE (memb), rhs);\n@@ -4921,8 +4958,9 @@ convert_for_assignment (location_t location, tree type, tree rhs,\n \n \t where NULL is typically defined in C to be '(void *) 0'.  */\n       if (VOID_TYPE_P (ttr) && rhs != null_pointer_node && !VOID_TYPE_P (ttl))\n-\twarning (OPT_Wc___compat, \"request for implicit conversion from \"\n-\t\t \"%qT to %qT not permitted in C++\", rhstype, type);\n+\twarning_at (location, OPT_Wc___compat,\n+\t    \t    \"request for implicit conversion \"\n+\t\t    \"from %qT to %qT not permitted in C++\", rhstype, type);\n \n       /* Check if the right-hand side has a format attribute but the\n \t left-hand side doesn't.  */\n@@ -4932,25 +4970,25 @@ convert_for_assignment (location_t location, tree type, tree rhs,\n \t  switch (errtype)\n \t  {\n \t  case ic_argpass:\n-\t    warning (OPT_Wmissing_format_attribute,\n-\t\t     \"argument %d of %qE might be \"\n-\t\t     \"a candidate for a format attribute\",\n-\t\t     parmnum, rname);\n+\t    warning_at (location, OPT_Wmissing_format_attribute,\n+\t\t\t\"argument %d of %qE might be \"\n+\t\t\t\"a candidate for a format attribute\",\n+\t\t\tparmnum, rname);\n \t    break;\n \t  case ic_assign:\n-\t    warning (OPT_Wmissing_format_attribute,\n-\t\t     \"assignment left-hand side might be \"\n-\t\t     \"a candidate for a format attribute\");\n+\t    warning_at (location, OPT_Wmissing_format_attribute,\n+\t\t\t\"assignment left-hand side might be \"\n+\t\t\t\"a candidate for a format attribute\");\n \t    break;\n \t  case ic_init:\n-\t    warning (OPT_Wmissing_format_attribute,\n-\t\t     \"initialization left-hand side might be \"\n-\t\t     \"a candidate for a format attribute\");\n+\t    warning_at (location, OPT_Wmissing_format_attribute,\n+\t\t\t\"initialization left-hand side might be \"\n+\t\t\t\"a candidate for a format attribute\");\n \t    break;\n \t  case ic_return:\n-\t    warning (OPT_Wmissing_format_attribute,\n-\t\t     \"return type might be \"\n-\t\t     \"a candidate for a format attribute\");\n+\t    warning_at (location, OPT_Wmissing_format_attribute,\n+\t\t\t\"return type might be \"\n+\t\t\t\"a candidate for a format attribute\");\n \t    break;\n \t  default:\n \t    gcc_unreachable ();\n@@ -4972,7 +5010,7 @@ convert_for_assignment (location_t location, tree type, tree rhs,\n \t\t  (VOID_TYPE_P (ttr)\n \t\t   && !null_pointer_constant\n \t\t   && TREE_CODE (ttl) == FUNCTION_TYPE)))\n-\t    WARN_FOR_ASSIGNMENT (input_location, OPT_pedantic,\n+\t    WARN_FOR_ASSIGNMENT (location, OPT_pedantic,\n \t\t\t\t G_(\"ISO C forbids passing argument %d of \"\n \t\t\t\t    \"%qE between function pointer \"\n \t\t\t\t    \"and %<void *%>\"),\n@@ -4993,7 +5031,7 @@ convert_for_assignment (location_t location, tree type, tree rhs,\n \t\t     qualifier are acceptable if the 'volatile' has been added\n \t\t     in by the Objective-C EH machinery.  */\n \t\t  if (!objc_type_quals_match (ttl, ttr))\n-\t\t    WARN_FOR_ASSIGNMENT (input_location, 0,\n+\t\t    WARN_FOR_ASSIGNMENT (location, 0,\n \t\t\t\t\t G_(\"passing argument %d of %qE discards \"\n \t\t\t\t\t    \"qualifiers from pointer target type\"),\n \t\t\t\t\t G_(\"assignment discards qualifiers \"\n@@ -5010,7 +5048,7 @@ convert_for_assignment (location_t location, tree type, tree rhs,\n \t\t;\n \t      /* If there is a mismatch, do warn.  */\n \t      else if (warn_pointer_sign)\n-\t\tWARN_FOR_ASSIGNMENT (input_location, OPT_Wpointer_sign,\n+\t\tWARN_FOR_ASSIGNMENT (location, OPT_Wpointer_sign,\n \t\t\t\t     G_(\"pointer targets in passing argument \"\n \t\t\t\t\t\"%d of %qE differ in signedness\"),\n \t\t\t\t     G_(\"pointer targets in assignment \"\n@@ -5028,7 +5066,7 @@ convert_for_assignment (location_t location, tree type, tree rhs,\n \t\t it is okay to use a const or volatile function\n \t\t where an ordinary one is wanted, but not vice-versa.  */\n \t      if (TYPE_QUALS (ttl) & ~TYPE_QUALS (ttr))\n-\t\tWARN_FOR_ASSIGNMENT (input_location, 0,\n+\t\tWARN_FOR_ASSIGNMENT (location, 0,\n \t\t\t\t     G_(\"passing argument %d of %qE makes \"\n \t\t\t\t\t\"qualified function pointer \"\n \t\t\t\t\t\"from unqualified\"),\n@@ -5043,7 +5081,7 @@ convert_for_assignment (location_t location, tree type, tree rhs,\n       else\n \t/* Avoid warning about the volatile ObjC EH puts on decls.  */\n \tif (!objc_ok)\n-\t  WARN_FOR_ASSIGNMENT (input_location, 0,\n+\t  WARN_FOR_ASSIGNMENT (location, 0,\n \t\t\t       G_(\"passing argument %d of %qE from \"\n \t\t\t\t  \"incompatible pointer type\"),\n \t\t\t       G_(\"assignment from incompatible pointer type\"),\n@@ -5057,7 +5095,7 @@ convert_for_assignment (location_t location, tree type, tree rhs,\n     {\n       /* ??? This should not be an error when inlining calls to\n \t unprototyped functions.  */\n-      error (\"invalid use of non-lvalue array\");\n+      error_at (location, \"invalid use of non-lvalue array\");\n       return error_mark_node;\n     }\n   else if (codel == POINTER_TYPE && coder == INTEGER_TYPE)\n@@ -5066,7 +5104,7 @@ convert_for_assignment (location_t location, tree type, tree rhs,\n \t or one that results from arithmetic, even including\n \t a cast to integer type.  */\n       if (!null_pointer_constant)\n-\tWARN_FOR_ASSIGNMENT (input_location, 0,\n+\tWARN_FOR_ASSIGNMENT (location, 0,\n \t\t\t     G_(\"passing argument %d of %qE makes \"\n \t\t\t\t\"pointer from integer without a cast\"),\n \t\t\t     G_(\"assignment makes pointer from integer \"\n@@ -5080,7 +5118,7 @@ convert_for_assignment (location_t location, tree type, tree rhs,\n     }\n   else if (codel == INTEGER_TYPE && coder == POINTER_TYPE)\n     {\n-      WARN_FOR_ASSIGNMENT (input_location, 0,\n+      WARN_FOR_ASSIGNMENT (location, 0,\n \t\t\t   G_(\"passing argument %d of %qE makes integer \"\n \t\t\t      \"from pointer without a cast\"),\n \t\t\t   G_(\"assignment makes integer from pointer \"\n@@ -5104,22 +5142,24 @@ convert_for_assignment (location_t location, tree type, tree rhs,\n   switch (errtype)\n     {\n     case ic_argpass:\n-      error (\"incompatible type for argument %d of %qE\", parmnum, rname);\n+      error_at (location, \"incompatible type for argument %d of %qE\", parmnum, rname);\n       inform ((fundecl && !DECL_IS_BUILTIN (fundecl))\n \t      ? DECL_SOURCE_LOCATION (fundecl) : input_location,\n \t      \"expected %qT but argument is of type %qT\", type, rhstype);\n       break;\n     case ic_assign:\n-      error (\"incompatible types when assigning to type %qT from type %qT\",\n-\t     type, rhstype);\n+      error_at (location, \"incompatible types when assigning to type %qT from \"\n+\t\t\"type %qT\", type, rhstype);\n       break;\n     case ic_init:\n-      error (\"incompatible types when initializing type %qT using type %qT\",\n-\t     type, rhstype);\n+      error_at (location,\n+\t  \t\"incompatible types when initializing type %qT using type %qT\",\n+\t\ttype, rhstype);\n       break;\n     case ic_return:\n-      error (\"incompatible types when returning type %qT but %qT was expected\",\n-\t     rhstype, type);\n+      error_at (location,\n+\t  \t\"incompatible types when returning type %qT but %qT was \"\n+\t\t\"expected\", rhstype, type);\n       break;\n     default:\n       gcc_unreachable ();\n@@ -5155,10 +5195,12 @@ valid_compound_expr_initializer (tree value, tree endtype)\n    store it in the declaration DECL,\n    and print any error messages that are appropriate.\n    If ORIGTYPE is not NULL_TREE, it is the original type of INIT.\n-   If the init is invalid, store an ERROR_MARK.  */\n+   If the init is invalid, store an ERROR_MARK.\n+\n+   INIT_LOC is the location of the initial value.  */\n \n void\n-store_init_value (tree decl, tree init, tree origtype)\n+store_init_value (location_t init_loc, tree decl, tree init, tree origtype)\n {\n   tree value, type;\n   bool npc = false;\n@@ -5173,7 +5215,8 @@ store_init_value (tree decl, tree init, tree origtype)\n \n   if (init)\n     npc = null_pointer_constant_p (init);\n-  value = digest_init (type, init, origtype, npc, true, TREE_STATIC (decl));\n+  value = digest_init (init_loc, type, init, origtype, npc,\n+      \t\t       true, TREE_STATIC (decl));\n \n   /* Store the expression if valid; else report error.  */\n \n@@ -5414,12 +5457,15 @@ maybe_warn_string_init (tree type, struct c_expr expr)\n    unparenthesized or we should not warn here for it being parenthesized.\n    For other types of INIT, STRICT_STRING is not used.\n \n+   INIT_LOC is the location of the INIT.\n+\n    REQUIRE_CONSTANT requests an error if non-constant initializers or\n    elements are seen.  */\n \n static tree\n-digest_init (tree type, tree init, tree origtype, bool null_pointer_constant,\n-\t     bool strict_string, int require_constant)\n+digest_init (location_t init_loc, tree type, tree init, tree origtype,\n+    \t     bool null_pointer_constant, bool strict_string,\n+\t     int require_constant)\n {\n   enum tree_code code = TREE_CODE (type);\n   tree inside_init = init;\n@@ -5469,7 +5515,7 @@ digest_init (tree type, tree init, tree origtype, bool null_pointer_constant,\n \t  maybe_warn_string_init (type, expr);\n \n \t  if (TYPE_DOMAIN (type) && !TYPE_MAX_VALUE (TYPE_DOMAIN (type)))\n-\t    pedwarn_init (input_location, OPT_pedantic,\n+\t    pedwarn_init (init_loc, OPT_pedantic,\n \t\t\t  \"initialization of a flexible array member\");\n \n \t  if (comptypes (TYPE_MAIN_VARIANT (TREE_TYPE (inside_init)),\n@@ -5511,7 +5557,7 @@ digest_init (tree type, tree init, tree origtype, bool null_pointer_constant,\n \t\t\t\t       TREE_STRING_LENGTH (inside_init)\n \t\t\t\t       - (TYPE_PRECISION (typ1)\n \t\t\t\t\t  / BITS_PER_UNIT)))\n-\t    pedwarn_init (input_location, 0, \n+\t    pedwarn_init (init_loc, 0, \n \t\t\t  \"initializer-string for array of chars is too long\");\n \n \t  return inside_init;\n@@ -5582,7 +5628,8 @@ digest_init (tree type, tree init, tree origtype, bool null_pointer_constant,\n \t    {\n \t      if (TREE_CODE (inside_init) == STRING_CST\n \t\t  || TREE_CODE (inside_init) == COMPOUND_LITERAL_EXPR)\n-\t\tinside_init = array_to_pointer_conversion (inside_init);\n+\t\tinside_init = array_to_pointer_conversion\n+\t\t  (init_loc, inside_init);\n \t      else\n \t\t{\n \t\t  error_init (\"invalid use of non-lvalue array\");\n@@ -5627,7 +5674,7 @@ digest_init (tree type, tree init, tree origtype, bool null_pointer_constant,\n \t  if (inside_init == error_mark_node)\n \t    error_init (\"initializer element is not constant\");\n \t  else\n-\t    pedwarn_init (input_location, OPT_pedantic,\n+\t    pedwarn_init (init_loc, OPT_pedantic,\n \t\t\t  \"initializer element is not constant\");\n \t  if (flag_pedantic_errors)\n \t    inside_init = error_mark_node;\n@@ -5640,13 +5687,13 @@ digest_init (tree type, tree init, tree origtype, bool null_pointer_constant,\n \t  inside_init = error_mark_node;\n \t}\n       else if (require_constant && !maybe_const)\n-\tpedwarn_init (input_location, 0,\n+\tpedwarn_init (init_loc, 0,\n \t\t      \"initializer element is not a constant expression\");\n \n       /* Added to enable additional -Wmissing-format-attribute warnings.  */\n       if (TREE_CODE (TREE_TYPE (inside_init)) == POINTER_TYPE)\n-\tinside_init = convert_for_assignment (input_location, type,\n-\t\t\t\t\t      inside_init, origtype,\n+\tinside_init = convert_for_assignment (init_loc, type, inside_init,\n+\t    \t\t\t\t      origtype,\n \t\t\t\t\t      ic_init, null_pointer_constant,\n \t\t\t\t\t      NULL_TREE, NULL_TREE, 0);\n       return inside_init;\n@@ -5661,13 +5708,13 @@ digest_init (tree type, tree init, tree origtype, bool null_pointer_constant,\n       if (TREE_CODE (TREE_TYPE (init)) == ARRAY_TYPE\n \t  && (TREE_CODE (init) == STRING_CST\n \t      || TREE_CODE (init) == COMPOUND_LITERAL_EXPR))\n-\tinside_init = init = array_to_pointer_conversion (init);\n+\tinside_init = init = array_to_pointer_conversion (init_loc, init);\n       if (semantic_type)\n \tinside_init = build1 (EXCESS_PRECISION_EXPR, semantic_type,\n \t\t\t      inside_init);\n       inside_init\n-\t= convert_for_assignment (input_location, type, inside_init, origtype,\n-\t\t\t\t  ic_init, null_pointer_constant,\n+\t= convert_for_assignment (init_loc, type, inside_init, origtype,\n+\t    \t\t\t  ic_init, null_pointer_constant,\n \t\t\t\t  NULL_TREE, NULL_TREE, 0);\n \n       /* Check to see if we have already given an error message.  */\n@@ -5686,7 +5733,7 @@ digest_init (tree type, tree init, tree origtype, bool null_pointer_constant,\n \t  inside_init = error_mark_node;\n \t}\n       else if (require_constant && !maybe_const)\n-\tpedwarn_init (input_location, 0,\n+\tpedwarn_init (init_loc, 0,\n \t\t      \"initializer element is not a constant expression\");\n \n       return inside_init;\n@@ -7092,7 +7139,7 @@ output_init_element (tree value, tree origtype, bool strict_string, tree type,\n \t   && INTEGRAL_TYPE_P (TREE_TYPE (type)))\n       && !comptypes (TYPE_MAIN_VARIANT (TREE_TYPE (value)),\n \t\t     TYPE_MAIN_VARIANT (type)))\n-    value = array_to_pointer_conversion (value);\n+    value = array_to_pointer_conversion (input_location, value);\n \n   if (TREE_CODE (value) == COMPOUND_LITERAL_EXPR\n       && require_constant_value && !flag_isoc99 && pending)\n@@ -7171,8 +7218,8 @@ output_init_element (tree value, tree origtype, bool strict_string, tree type,\n \n   if (semantic_type)\n     value = build1 (EXCESS_PRECISION_EXPR, semantic_type, value);\n-  value = digest_init (type, value, origtype, npc, strict_string,\n-\t\t       require_constant_value);\n+  value = digest_init (input_location, type, value, origtype, npc,\n+      \t\t       strict_string, require_constant_value);\n   if (value == error_mark_node)\n     {\n       constructor_erroneous = 1;\n@@ -7831,8 +7878,8 @@ build_asm_stmt (tree cv_qualifier, tree args)\n    string in the asm expression -- asm(\"blah\") and asm(\"blah\" : )\n    are subtly different.  We use a ASM_EXPR node to represent this.  */\n tree\n-build_asm_expr (tree string, tree outputs, tree inputs, tree clobbers,\n-\t\tbool simple)\n+build_asm_expr (location_t loc, tree string, tree outputs, tree inputs,\n+\t\ttree clobbers, bool simple)\n {\n   tree tail;\n   tree args;\n@@ -7916,7 +7963,7 @@ build_asm_expr (tree string, tree outputs, tree inputs, tree clobbers,\n       TREE_VALUE (tail) = input;\n     }\n \n-  args = build_stmt (ASM_EXPR, string, outputs, inputs, clobbers);\n+  args = build_stmt (loc, ASM_EXPR, string, outputs, inputs, clobbers);\n \n   /* asm statements without outputs, including simple ones, are treated\n      as volatile.  */\n@@ -7926,24 +7973,26 @@ build_asm_expr (tree string, tree outputs, tree inputs, tree clobbers,\n   return args;\n }\n \f\n-/* Generate a goto statement to LABEL.  */\n+/* Generate a goto statement to LABEL.  LOC is the location of the\n+   GOTO.  */\n \n tree\n-c_finish_goto_label (tree label)\n+c_finish_goto_label (location_t loc, tree label)\n {\n   tree decl = lookup_label (label);\n   if (!decl)\n     return NULL_TREE;\n \n   if (C_DECL_UNJUMPABLE_STMT_EXPR (decl))\n     {\n-      error (\"jump into statement expression\");\n+      error_at (loc, \"jump into statement expression\");\n       return NULL_TREE;\n     }\n \n   if (C_DECL_UNJUMPABLE_VM (decl))\n     {\n-      error (\"jump into scope of identifier with variably modified type\");\n+      error_at (loc,\n+\t\t\"jump into scope of identifier with variably modified type\");\n       return NULL_TREE;\n     }\n \n@@ -7971,33 +8020,43 @@ c_finish_goto_label (tree label)\n     }\n \n   TREE_USED (decl) = 1;\n-  return add_stmt (build1 (GOTO_EXPR, void_type_node, decl));\n+  {\n+    tree t = build1 (GOTO_EXPR, void_type_node, decl);\n+    SET_EXPR_LOCATION (t, loc);\n+    return add_stmt (t);\n+  }\n }\n \n-/* Generate a computed goto statement to EXPR.  */\n+/* Generate a computed goto statement to EXPR.  LOC is the location of\n+   the GOTO.  */\n \n tree\n-c_finish_goto_ptr (tree expr)\n+c_finish_goto_ptr (location_t loc, tree expr)\n {\n-  pedwarn (input_location, OPT_pedantic, \"ISO C forbids %<goto *expr;%>\");\n+  tree t;\n+  pedwarn (loc, OPT_pedantic, \"ISO C forbids %<goto *expr;%>\");\n   expr = c_fully_fold (expr, false, NULL);\n   expr = convert (ptr_type_node, expr);\n-  return add_stmt (build1 (GOTO_EXPR, void_type_node, expr));\n+  t = build1 (GOTO_EXPR, void_type_node, expr);\n+  SET_EXPR_LOCATION (t, loc);\n+  return add_stmt (t);\n }\n \n /* Generate a C `return' statement.  RETVAL is the expression for what\n-   to return, or a null pointer for `return;' with no value.  If\n-   ORIGTYPE is not NULL_TREE, it is the original type of RETVAL.  */\n+   to return, or a null pointer for `return;' with no value.  LOC is\n+   the location of the return statement.  If ORIGTYPE is not NULL_TREE, it\n+   is the original type of RETVAL.  */\n \n tree\n-c_finish_return (tree retval, tree origtype)\n+c_finish_return (location_t loc, tree retval, tree origtype)\n {\n   tree valtype = TREE_TYPE (TREE_TYPE (current_function_decl)), ret_stmt;\n   bool no_warning = false;\n   bool npc = false;\n \n   if (TREE_THIS_VOLATILE (current_function_decl))\n-    warning (0, \"function declared %<noreturn%> has a %<return%> statement\");\n+    warning_at (loc, 0,\n+\t\t\"function declared %<noreturn%> has a %<return%> statement\");\n \n   if (retval)\n     {\n@@ -8019,7 +8078,7 @@ c_finish_return (tree retval, tree origtype)\n       if ((warn_return_type || flag_isoc99)\n \t  && valtype != 0 && TREE_CODE (valtype) != VOID_TYPE)\n \t{\n-\t  pedwarn_c99 (input_location, flag_isoc99 ? 0 : OPT_Wreturn_type, \n+\t  pedwarn_c99 (loc, flag_isoc99 ? 0 : OPT_Wreturn_type, \n \t\t       \"%<return%> with no value, in \"\n \t\t       \"function returning non-void\");\n \t  no_warning = true;\n@@ -8029,17 +8088,17 @@ c_finish_return (tree retval, tree origtype)\n     {\n       current_function_returns_null = 1;\n       if (TREE_CODE (TREE_TYPE (retval)) != VOID_TYPE)\n-\tpedwarn (input_location, 0, \n+\tpedwarn (loc, 0, \n \t\t \"%<return%> with a value, in function returning void\");\n       else \n-\tpedwarn (input_location, OPT_pedantic, \"ISO C forbids \"\n+\tpedwarn (loc, OPT_pedantic, \"ISO C forbids \"\n \t\t \"%<return%> with expression, in function returning void\");\n     }\n   else\n     {\n-      tree t = convert_for_assignment (input_location, valtype, retval,\n-\t\t\t\t       origtype, ic_return, npc,\n-\t\t\t\t       NULL_TREE, NULL_TREE, 0);\n+      tree t = convert_for_assignment (loc, valtype, retval, origtype,\n+\t  \t\t\t       ic_return,\n+\t\t\t\t       npc, NULL_TREE, NULL_TREE, 0);\n       tree res = DECL_RESULT (current_function_decl);\n       tree inner;\n \n@@ -8092,7 +8151,8 @@ c_finish_return (tree retval, tree origtype)\n \t\t  && !DECL_EXTERNAL (inner)\n \t\t  && !TREE_STATIC (inner)\n \t\t  && DECL_CONTEXT (inner) == current_function_decl)\n-\t\twarning (0, \"function returns address of local variable\");\n+\t\twarning_at (loc,\n+\t\t\t    0, \"function returns address of local variable\");\n \t      break;\n \n \t    default:\n@@ -8103,12 +8163,13 @@ c_finish_return (tree retval, tree origtype)\n \t}\n \n       retval = build2 (MODIFY_EXPR, TREE_TYPE (res), res, t);\n+      SET_EXPR_LOCATION (retval, loc);\n \n       if (warn_sequence_point)\n \tverify_sequence_points (retval);\n     }\n \n-  ret_stmt = build_stmt (RETURN_EXPR, retval);\n+  ret_stmt = build_stmt (loc, RETURN_EXPR, retval);\n   TREE_NO_WARNING (ret_stmt) |= no_warning;\n   return add_stmt (ret_stmt);\n }\n@@ -8151,10 +8212,13 @@ struct c_switch {\n struct c_switch *c_switch_stack;\n \n /* Start a C switch statement, testing expression EXP.  Return the new\n-   SWITCH_EXPR.  */\n+   SWITCH_EXPR.  SWITCH_LOC is the location of the `switch'.\n+   SWITCH_COND_LOC is the location of the switch's condition.  */\n \n tree\n-c_start_case (tree exp)\n+c_start_case (location_t switch_loc,\n+\t      location_t switch_cond_loc,\n+\t      tree exp)\n {\n   tree orig_type = error_mark_node;\n   struct c_switch *cs;\n@@ -8167,7 +8231,7 @@ c_start_case (tree exp)\n \t{\n \t  if (orig_type != error_mark_node)\n \t    {\n-\t      error (\"switch quantity not an integer\");\n+\t      error_at (switch_cond_loc, \"switch quantity not an integer\");\n \t      orig_type = error_mark_node;\n \t    }\n \t  exp = integer_zero_node;\n@@ -8179,8 +8243,9 @@ c_start_case (tree exp)\n \t  if (!in_system_header\n \t      && (type == long_integer_type_node\n \t\t  || type == long_unsigned_type_node))\n-\t    warning (OPT_Wtraditional, \"%<long%> switch expression not \"\n-\t\t     \"converted to %<int%> in ISO C\");\n+\t    warning_at (switch_cond_loc,\n+\t\t\tOPT_Wtraditional, \"%<long%> switch expression not \"\n+\t\t\t\"converted to %<int%> in ISO C\");\n \n \t  exp = c_fully_fold (exp, false, NULL);\n \t  exp = default_conversion (exp);\n@@ -8193,6 +8258,7 @@ c_start_case (tree exp)\n   /* Add this new SWITCH_EXPR to the stack.  */\n   cs = XNEW (struct c_switch);\n   cs->switch_expr = build3 (SWITCH_EXPR, orig_type, exp, NULL_TREE, NULL_TREE);\n+  SET_EXPR_LOCATION (cs->switch_expr, switch_loc);\n   cs->orig_type = orig_type;\n   cs->cases = splay_tree_new (case_compare, NULL, NULL);\n   cs->blocked_stmt_expr = 0;\n@@ -8203,10 +8269,10 @@ c_start_case (tree exp)\n   return add_stmt (cs->switch_expr);\n }\n \n-/* Process a case label.  */\n+/* Process a case label at location LOC.  */\n \n tree\n-do_case (tree low_value, tree high_value)\n+do_case (location_t loc, tree low_value, tree high_value)\n {\n   tree label = NULL_TREE;\n \n@@ -8229,7 +8295,7 @@ do_case (tree low_value, tree high_value)\n   if (c_switch_stack && !c_switch_stack->blocked_stmt_expr\n       && !c_switch_stack->blocked_vm)\n     {\n-      label = c_add_case_label (c_switch_stack->cases,\n+      label = c_add_case_label (loc, c_switch_stack->cases,\n \t\t\t\tSWITCH_COND (c_switch_stack->switch_expr),\n \t\t\t\tc_switch_stack->orig_type,\n \t\t\t\tlow_value, high_value);\n@@ -8239,25 +8305,26 @@ do_case (tree low_value, tree high_value)\n   else if (c_switch_stack && c_switch_stack->blocked_stmt_expr)\n     {\n       if (low_value)\n-\terror (\"case label in statement expression not containing \"\n-\t       \"enclosing switch statement\");\n+\terror_at (loc, \"case label in statement expression not containing \"\n+\t\t  \"enclosing switch statement\");\n       else\n-\terror (\"%<default%> label in statement expression not containing \"\n-\t       \"enclosing switch statement\");\n+\terror_at (loc, \"%<default%> label in statement expression not containing \"\n+\t\t  \"enclosing switch statement\");\n     }\n   else if (c_switch_stack && c_switch_stack->blocked_vm)\n     {\n       if (low_value)\n-\terror (\"case label in scope of identifier with variably modified \"\n-\t       \"type not containing enclosing switch statement\");\n+\terror_at (loc, \"case label in scope of identifier with variably \"\n+\t\t  \"modified type not containing enclosing switch statement\");\n       else\n-\terror (\"%<default%> label in scope of identifier with variably \"\n-\t       \"modified type not containing enclosing switch statement\");\n+\terror_at (loc, \"%<default%> label in scope of identifier with \"\n+\t\t  \"variably modified type not containing enclosing switch \"\n+\t\t  \"statement\");\n     }\n   else if (low_value)\n-    error (\"case label not within a switch statement\");\n+    error_at (loc, \"case label not within a switch statement\");\n   else\n-    error (\"%<default%> label not within a switch statement\");\n+    error_at (loc, \"%<default%> label not within a switch statement\");\n \n   return label;\n }\n@@ -8278,10 +8345,7 @@ c_finish_case (tree body)\n   gcc_assert (!cs->blocked_stmt_expr);\n \n   /* Emit warnings as needed.  */\n-  if (EXPR_HAS_LOCATION (cs->switch_expr))\n-    switch_location = EXPR_LOCATION (cs->switch_expr);\n-  else\n-    switch_location = input_location;\n+  switch_location = EXPR_LOCATION (cs->switch_expr);\n   c_do_switch_warnings (cs->cases, switch_location,\n \t\t\tTREE_TYPE (cs->switch_expr),\n \t\t\tSWITCH_COND (cs->switch_expr));\n@@ -8418,7 +8482,7 @@ c_finish_loop (location_t start_locus, tree cond, tree incr, tree body,\n }\n \n tree\n-c_finish_bc_stmt (tree *label_p, bool is_break)\n+c_finish_bc_stmt (location_t loc, tree *label_p, bool is_break)\n {\n   bool skip;\n   tree label = *label_p;\n@@ -8435,22 +8499,22 @@ c_finish_bc_stmt (tree *label_p, bool is_break)\n   if (!label)\n     {\n       if (!skip)\n-\t*label_p = label = create_artificial_label ();\n+\t*label_p = label = create_artificial_label (loc);\n     }\n   else if (TREE_CODE (label) == LABEL_DECL)\n     ;\n   else switch (TREE_INT_CST_LOW (label))\n     {\n     case 0:\n       if (is_break)\n-\terror (\"break statement not within loop or switch\");\n+\terror_at (loc, \"break statement not within loop or switch\");\n       else\n-\terror (\"continue statement not within a loop\");\n+\terror_at (loc, \"continue statement not within a loop\");\n       return NULL_TREE;\n \n     case 1:\n       gcc_assert (is_break);\n-      error (\"break statement used with OpenMP for loop\");\n+      error_at (loc, \"break statement used with OpenMP for loop\");\n       return NULL_TREE;\n \n     default:\n@@ -8469,25 +8533,25 @@ c_finish_bc_stmt (tree *label_p, bool is_break)\n /* A helper routine for c_process_expr_stmt and c_finish_stmt_expr.  */\n \n static void\n-emit_side_effect_warnings (tree expr)\n+emit_side_effect_warnings (location_t loc, tree expr)\n {\n   if (expr == error_mark_node)\n     ;\n   else if (!TREE_SIDE_EFFECTS (expr))\n     {\n       if (!VOID_TYPE_P (TREE_TYPE (expr)) && !TREE_NO_WARNING (expr))\n-\twarning (OPT_Wunused_value, \"%Hstatement with no effect\",\n-\t\t EXPR_HAS_LOCATION (expr) ? EXPR_LOCUS (expr) : &input_location);\n+\twarning_at (loc, OPT_Wunused_value, \"statement with no effect\");\n     }\n   else\n-    warn_if_unused_value (expr, input_location);\n+    warn_if_unused_value (expr, loc);\n }\n \n /* Process an expression as if it were a complete statement.  Emit\n-   diagnostics, but do not call ADD_STMT.  */\n+   diagnostics, but do not call ADD_STMT.  LOC is the location of the\n+   statement.  */\n \n tree\n-c_process_expr_stmt (tree expr)\n+c_process_expr_stmt (location_t loc, tree expr)\n {\n   if (!expr)\n     return NULL_TREE;\n@@ -8500,33 +8564,34 @@ c_process_expr_stmt (tree expr)\n   if (TREE_TYPE (expr) != error_mark_node\n       && !COMPLETE_OR_VOID_TYPE_P (TREE_TYPE (expr))\n       && TREE_CODE (TREE_TYPE (expr)) != ARRAY_TYPE)\n-    error (\"expression statement has incomplete type\");\n+    error_at (loc, \"expression statement has incomplete type\");\n \n   /* If we're not processing a statement expression, warn about unused values.\n      Warnings for statement expressions will be emitted later, once we figure\n      out which is the result.  */\n   if (!STATEMENT_LIST_STMT_EXPR (cur_stmt_list)\n       && warn_unused_value)\n-    emit_side_effect_warnings (expr);\n+    emit_side_effect_warnings (loc, expr);\n \n   /* If the expression is not of a type to which we cannot assign a line\n      number, wrap the thing in a no-op NOP_EXPR.  */\n   if (DECL_P (expr) || CONSTANT_CLASS_P (expr))\n-    expr = build1 (NOP_EXPR, TREE_TYPE (expr), expr);\n-\n-  if (CAN_HAVE_LOCATION_P (expr))\n-    SET_EXPR_LOCATION (expr, input_location);\n+    {\n+      expr = build1 (NOP_EXPR, TREE_TYPE (expr), expr);\n+      SET_EXPR_LOCATION (expr, loc);\n+    }\n \n   return expr;\n }\n \n-/* Emit an expression as a statement.  */\n+/* Emit an expression as a statement.  LOC is the location of the\n+   expression.  */\n \n tree\n-c_finish_expr_stmt (tree expr)\n+c_finish_expr_stmt (location_t loc, tree expr)\n {\n   if (expr)\n-    return add_stmt (c_process_expr_stmt (expr));\n+    return add_stmt (c_process_expr_stmt (loc, expr));\n   else\n     return NULL;\n }\n@@ -8569,14 +8634,17 @@ c_begin_stmt_expr (void)\n   return ret;\n }\n \n+/* LOC is the location of the compound statement to which this body\n+   belongs.  */\n+\n tree\n-c_finish_stmt_expr (tree body)\n+c_finish_stmt_expr (location_t loc, tree body)\n {\n   tree last, type, tmp, val;\n   tree *last_p;\n   struct c_label_list *dlist, *glist, *glist_prev = NULL;\n \n-  body = c_end_compound_stmt (body, true);\n+  body = c_end_compound_stmt (loc, body, true);\n   if (c_switch_stack)\n     {\n       gcc_assert (c_switch_stack->blocked_stmt_expr != 0);\n@@ -8625,7 +8693,13 @@ c_finish_stmt_expr (tree body)\n       if (warn_unused_value)\n \t{\n \t  for (i = tsi_start (last); !tsi_one_before_end_p (i); tsi_next (&i))\n-\t    emit_side_effect_warnings (tsi_stmt (i));\n+\t    {\n+\t      location_t tloc;\n+\t      tree t = tsi_stmt (i);\n+\n+\t      tloc = EXPR_HAS_LOCATION (t) ? EXPR_LOCATION (t) : loc;\n+\t      emit_side_effect_warnings (tloc, t);\n+\t    }\n \t}\n       else\n \ti = tsi_last (last);\n@@ -8682,7 +8756,11 @@ c_finish_stmt_expr (tree body)\n   *last_p = build2 (MODIFY_EXPR, void_type_node, tmp, val);\n   SET_EXPR_LOCUS (*last_p, EXPR_LOCUS (last));\n \n-  return build4 (TARGET_EXPR, type, tmp, body, NULL_TREE, NULL_TREE);\n+  {\n+    tree t = build4 (TARGET_EXPR, type, tmp, body, NULL_TREE, NULL_TREE);\n+    SET_EXPR_LOCATION (t, loc);\n+    return t;\n+  }\n }\n \n /* Begin the scope of an identifier of variably modified type, scope\n@@ -8771,8 +8849,12 @@ c_begin_compound_stmt (bool do_scope)\n   return stmt;\n }\n \n+/* End a compound statement.  STMT is the statement.  LOC is the\n+   location of the compound statement-- this is usually the location\n+   of the opening brace.  */\n+\n tree\n-c_end_compound_stmt (tree stmt, bool do_scope)\n+c_end_compound_stmt (location_t loc, tree stmt, bool do_scope)\n {\n   tree block = NULL;\n \n@@ -8784,7 +8866,7 @@ c_end_compound_stmt (tree stmt, bool do_scope)\n     }\n \n   stmt = pop_stmt_list (stmt);\n-  stmt = c_build_bind_expr (block, stmt);\n+  stmt = c_build_bind_expr (loc, block, stmt);\n \n   /* If this compound statement is nested immediately inside a statement\n      expression, then force a BIND_EXPR to be created.  Otherwise we'll\n@@ -8797,6 +8879,7 @@ c_end_compound_stmt (tree stmt, bool do_scope)\n     {\n       stmt = build3 (BIND_EXPR, void_type_node, NULL, stmt, NULL);\n       TREE_SIDE_EFFECTS (stmt) = 1;\n+      SET_EXPR_LOCATION (stmt, loc);\n     }\n \n   return stmt;\n@@ -8807,14 +8890,14 @@ c_end_compound_stmt (tree stmt, bool do_scope)\n    meant to apply to normal control flow transfer.  */\n \n void\n-push_cleanup (tree ARG_UNUSED (decl), tree cleanup, bool eh_only)\n+push_cleanup (tree decl, tree cleanup, bool eh_only)\n {\n   enum tree_code code;\n   tree stmt, list;\n   bool stmt_expr;\n \n   code = eh_only ? TRY_CATCH_EXPR : TRY_FINALLY_EXPR;\n-  stmt = build_stmt (code, NULL, cleanup);\n+  stmt = build_stmt (DECL_SOURCE_LOCATION (decl), code, NULL, cleanup);\n   add_stmt (stmt);\n   stmt_expr = STATEMENT_LIST_STMT_EXPR (cur_stmt_list);\n   list = push_stmt_list ();\n@@ -9749,19 +9832,21 @@ c_begin_omp_parallel (void)\n   return block;\n }\n \n-/* Generate OMP_PARALLEL, with CLAUSES and BLOCK as its compound statement.  */\n+/* Generate OMP_PARALLEL, with CLAUSES and BLOCK as its compound\n+   statement.  LOC is the location of the OMP_PARALLEL.  */\n \n tree\n-c_finish_omp_parallel (tree clauses, tree block)\n+c_finish_omp_parallel (location_t loc, tree clauses, tree block)\n {\n   tree stmt;\n \n-  block = c_end_compound_stmt (block, true);\n+  block = c_end_compound_stmt (loc, block, true);\n \n   stmt = make_node (OMP_PARALLEL);\n   TREE_TYPE (stmt) = void_type_node;\n   OMP_PARALLEL_CLAUSES (stmt) = clauses;\n   OMP_PARALLEL_BODY (stmt) = block;\n+  SET_EXPR_LOCATION (stmt, loc);\n \n   return add_stmt (stmt);\n }\n@@ -9779,19 +9864,21 @@ c_begin_omp_task (void)\n   return block;\n }\n \n-/* Generate OMP_TASK, with CLAUSES and BLOCK as its compound statement.  */\n+/* Generate OMP_TASK, with CLAUSES and BLOCK as its compound\n+   statement.  LOC is the location of the #pragma.  */\n \n tree\n-c_finish_omp_task (tree clauses, tree block)\n+c_finish_omp_task (location_t loc, tree clauses, tree block)\n {\n   tree stmt;\n \n-  block = c_end_compound_stmt (block, true);\n+  block = c_end_compound_stmt (loc, block, true);\n \n   stmt = make_node (OMP_TASK);\n   TREE_TYPE (stmt) = void_type_node;\n   OMP_TASK_CLAUSES (stmt) = clauses;\n   OMP_TASK_BODY (stmt) = block;\n+  SET_EXPR_LOCATION (stmt, loc);\n \n   return add_stmt (stmt);\n }\n@@ -9837,7 +9924,8 @@ c_finish_omp_clauses (tree clauses)\n \t  if (AGGREGATE_TYPE_P (TREE_TYPE (t))\n \t      || POINTER_TYPE_P (TREE_TYPE (t)))\n \t    {\n-\t      error (\"%qE has invalid type for %<reduction%>\", t);\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%qE has invalid type for %<reduction%>\", t);\n \t      remove = true;\n \t    }\n \t  else if (FLOAT_TYPE_P (TREE_TYPE (t)))\n@@ -9871,8 +9959,9 @@ c_finish_omp_clauses (tree clauses)\n \t\t}\n \t      if (r_name)\n \t\t{\n-\t\t  error (\"%qE has invalid type for %<reduction(%s)%>\",\n-\t\t\t t, r_name);\n+\t\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t    \"%qE has invalid type for %<reduction(%s)%>\",\n+\t\t\t    t, r_name);\n \t\t  remove = true;\n \t\t}\n \t    }\n@@ -9887,7 +9976,8 @@ c_finish_omp_clauses (tree clauses)\n \t  t = OMP_CLAUSE_DECL (c);\n \t  if (TREE_CODE (t) != VAR_DECL || !DECL_THREAD_LOCAL_P (t))\n \t    {\n-\t      error (\"%qE must be %<threadprivate%> for %<copyin%>\", t);\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%qE must be %<threadprivate%> for %<copyin%>\", t);\n \t      remove = true;\n \t    }\n \t  goto check_dup_generic;\n@@ -9896,14 +9986,16 @@ c_finish_omp_clauses (tree clauses)\n \t  t = OMP_CLAUSE_DECL (c);\n \t  if (TREE_CODE (t) != VAR_DECL && TREE_CODE (t) != PARM_DECL)\n \t    {\n-\t      error (\"%qE is not a variable in clause %qs\", t, name);\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%qE is not a variable in clause %qs\", t, name);\n \t      remove = true;\n \t    }\n \t  else if (bitmap_bit_p (&generic_head, DECL_UID (t))\n \t\t   || bitmap_bit_p (&firstprivate_head, DECL_UID (t))\n \t\t   || bitmap_bit_p (&lastprivate_head, DECL_UID (t)))\n \t    {\n-\t      error (\"%qE appears more than once in data clauses\", t);\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%qE appears more than once in data clauses\", t);\n \t      remove = true;\n \t    }\n \t  else\n@@ -9917,13 +10009,15 @@ c_finish_omp_clauses (tree clauses)\n \t  need_implicitly_determined = true;\n \t  if (TREE_CODE (t) != VAR_DECL && TREE_CODE (t) != PARM_DECL)\n \t    {\n-\t      error (\"%qE is not a variable in clause %<firstprivate%>\", t);\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%qE is not a variable in clause %<firstprivate%>\", t);\n \t      remove = true;\n \t    }\n \t  else if (bitmap_bit_p (&generic_head, DECL_UID (t))\n \t\t   || bitmap_bit_p (&firstprivate_head, DECL_UID (t)))\n \t    {\n-\t      error (\"%qE appears more than once in data clauses\", t);\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%qE appears more than once in data clauses\", t);\n \t      remove = true;\n \t    }\n \t  else\n@@ -9937,13 +10031,15 @@ c_finish_omp_clauses (tree clauses)\n \t  need_implicitly_determined = true;\n \t  if (TREE_CODE (t) != VAR_DECL && TREE_CODE (t) != PARM_DECL)\n \t    {\n-\t      error (\"%qE is not a variable in clause %<lastprivate%>\", t);\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"%qE is not a variable in clause %<lastprivate%>\", t);\n \t      remove = true;\n \t    }\n \t  else if (bitmap_bit_p (&generic_head, DECL_UID (t))\n \t\t   || bitmap_bit_p (&lastprivate_head, DECL_UID (t)))\n \t    {\n-\t      error (\"%qE appears more than once in data clauses\", t);\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t     \"%qE appears more than once in data clauses\", t);\n \t      remove = true;\n \t    }\n \t  else\n@@ -9997,8 +10093,9 @@ c_finish_omp_clauses (tree clauses)\n \t\t}\n \t      if (share_name)\n \t\t{\n-\t\t  error (\"%qE is predetermined %qs for %qs\",\n-\t\t\t t, share_name, name);\n+\t\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t    \"%qE is predetermined %qs for %qs\",\n+\t\t\t    t, share_name, name);\n \t\t  remove = true;\n \t\t}\n \t    }\n@@ -10082,10 +10179,10 @@ c_build_qualified_type (tree type, int type_quals)\n /* Build a VA_ARG_EXPR for the C parser.  */\n \n tree\n-c_build_va_arg (tree expr, tree type, location_t loc)\n+c_build_va_arg (location_t loc, tree expr, tree type)\n {\n   if (warn_cxx_compat && TREE_CODE (type) == ENUMERAL_TYPE)\n     warning_at (loc, OPT_Wc___compat,\n \t\t\"C++ requires promoted type, not enum type, in %<va_arg%>\");\n-  return build_va_arg (expr, type);\n+  return build_va_arg (loc, expr, type);\n }"}, {"sha": "62b5c4515d1e98836505fb86355c40f08b9032ca", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -1410,7 +1410,8 @@ add_stack_protection_conflicts (void)\n static void\n create_stack_guard (void)\n {\n-  tree guard = build_decl (VAR_DECL, NULL, ptr_type_node);\n+  tree guard = build_decl (DECL_SOURCE_LOCATION (current_function_decl),\n+\t\t\t   VAR_DECL, NULL, ptr_type_node);\n   TREE_THIS_VOLATILE (guard) = 1;\n   TREE_USED (guard) = 1;\n   expand_one_stack_var (guard);"}, {"sha": "310e5f9cef9ff4146e9baf28e9a3309ad7dca9f5", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -1429,11 +1429,12 @@ cgraph_build_static_cdtor (char which, tree body, int priority)\n   sprintf (which_buf, \"%c_%.5d_%d\", which, priority, counter++);\n   name = get_file_function_name (which_buf);\n \n-  decl = build_decl (FUNCTION_DECL, name,\n+  decl = build_decl (input_location, FUNCTION_DECL, name,\n \t\t     build_function_type (void_type_node, void_list_node));\n   current_function_decl = decl;\n \n-  resdecl = build_decl (RESULT_DECL, NULL_TREE, void_type_node);\n+  resdecl = build_decl (input_location,\n+\t\t\tRESULT_DECL, NULL_TREE, void_type_node);\n   DECL_ARTIFICIAL (resdecl) = 1;\n   DECL_RESULT (decl) = resdecl;\n   DECL_CONTEXT (resdecl) = decl;"}, {"sha": "9129fc39114ed8aa5b06a0f5a47f93ab79725124", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -6529,15 +6529,20 @@ ix86_build_builtin_va_list_abi (enum calling_abi abi)\n     return build_pointer_type (char_type_node);\n \n   record = (*lang_hooks.types.make_type) (RECORD_TYPE);\n-  type_decl = build_decl (TYPE_DECL, get_identifier (\"__va_list_tag\"), record);\n+  type_decl = build_decl (BUILTINS_LOCATION,\n+\t\t\t  TYPE_DECL, get_identifier (\"__va_list_tag\"), record);\n \n-  f_gpr = build_decl (FIELD_DECL, get_identifier (\"gp_offset\"),\n+  f_gpr = build_decl (BUILTINS_LOCATION,\n+\t\t      FIELD_DECL, get_identifier (\"gp_offset\"),\n \t\t      unsigned_type_node);\n-  f_fpr = build_decl (FIELD_DECL, get_identifier (\"fp_offset\"),\n+  f_fpr = build_decl (BUILTINS_LOCATION,\n+\t\t      FIELD_DECL, get_identifier (\"fp_offset\"),\n \t\t      unsigned_type_node);\n-  f_ovf = build_decl (FIELD_DECL, get_identifier (\"overflow_arg_area\"),\n+  f_ovf = build_decl (BUILTINS_LOCATION,\n+\t\t      FIELD_DECL, get_identifier (\"overflow_arg_area\"),\n \t\t      ptr_type_node);\n-  f_sav = build_decl (FIELD_DECL, get_identifier (\"reg_save_area\"),\n+  f_sav = build_decl (BUILTINS_LOCATION,\n+\t\t      FIELD_DECL, get_identifier (\"reg_save_area\"),\n \t\t      ptr_type_node);\n \n   va_list_gpr_counter_field = f_gpr;\n@@ -6929,8 +6934,8 @@ ix86_gimplify_va_arg (tree valist, tree type, gimple_seq *pre_p,\n       bool need_temp;\n       tree int_addr, sse_addr;\n \n-      lab_false = create_artificial_label ();\n-      lab_over = create_artificial_label ();\n+      lab_false = create_artificial_label (UNKNOWN_LOCATION);\n+      lab_over = create_artificial_label (UNKNOWN_LOCATION);\n \n       examine_argument (nat_mode, type, 0, &needed_intregs, &needed_sseregs);\n \n@@ -7512,7 +7517,8 @@ ix86_file_end (void)\n \t{\n \t  tree decl;\n \n-\t  decl = build_decl (FUNCTION_DECL, get_identifier (name),\n+\t  decl = build_decl (BUILTINS_LOCATION,\n+\t\t\t     FUNCTION_DECL, get_identifier (name),\n \t\t\t     error_mark_node);\n \t  TREE_PUBLIC (decl) = 1;\n \t  TREE_STATIC (decl) = 1;\n@@ -10257,7 +10263,8 @@ get_dllimport_decl (tree decl)\n   *loc = h = GGC_NEW (struct tree_map);\n   h->hash = in.hash;\n   h->base.from = decl;\n-  h->to = to = build_decl (VAR_DECL, NULL, ptr_type_node);\n+  h->to = to = build_decl (DECL_SOURCE_LOCATION (decl),\n+\t\t\t   VAR_DECL, NULL, ptr_type_node);\n   DECL_ARTIFICIAL (to) = 1;\n   DECL_IGNORED_P (to) = 1;\n   DECL_EXTERNAL (to) = 1;\n@@ -25923,7 +25930,8 @@ ix86_veclibabi_svml (enum built_in_function fn, tree type_out, tree type_in)\n     fntype = build_function_type_list (type_out, type_in, type_in, NULL);\n \n   /* Build a function declaration for the vectorized function.  */\n-  new_fndecl = build_decl (FUNCTION_DECL, get_identifier (name), fntype);\n+  new_fndecl = build_decl (BUILTINS_LOCATION,\n+\t\t\t   FUNCTION_DECL, get_identifier (name), fntype);\n   TREE_PUBLIC (new_fndecl) = 1;\n   DECL_EXTERNAL (new_fndecl) = 1;\n   DECL_IS_NOVOPS (new_fndecl) = 1;\n@@ -26007,7 +26015,8 @@ ix86_veclibabi_acml (enum built_in_function fn, tree type_out, tree type_in)\n     fntype = build_function_type_list (type_out, type_in, type_in, NULL);\n \n   /* Build a function declaration for the vectorized function.  */\n-  new_fndecl = build_decl (FUNCTION_DECL, get_identifier (name), fntype);\n+  new_fndecl = build_decl (BUILTINS_LOCATION,\n+\t\t\t   FUNCTION_DECL, get_identifier (name), fntype);\n   TREE_PUBLIC (new_fndecl) = 1;\n   DECL_EXTERNAL (new_fndecl) = 1;\n   DECL_IS_NOVOPS (new_fndecl) = 1;"}, {"sha": "ebdc696218bec101f457ee73a53bc3d2f6081376", "filename": "gcc/coverage.c", "status": "modified", "additions": 36, "deletions": 18, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fcoverage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fcoverage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -418,7 +418,8 @@ coverage_counter_alloc (unsigned counter, unsigned num)\n       tree gcov_type_array_type\n         = build_array_type (gcov_type_node, NULL_TREE);\n       tree_ctr_tables[counter]\n-        = build_decl (VAR_DECL, NULL_TREE, gcov_type_array_type);\n+        = build_decl (BUILTINS_LOCATION,\n+\t\t      VAR_DECL, NULL_TREE, gcov_type_array_type);\n       TREE_STATIC (tree_ctr_tables[counter]) = 1;\n       ASM_GENERATE_INTERNAL_LABEL (buf, \"LPBX\", counter + 1);\n       DECL_NAME (tree_ctr_tables[counter]) = get_identifier (buf);\n@@ -639,10 +640,12 @@ build_fn_info_type (unsigned int counters)\n   tree array_type;\n \n   /* ident */\n-  fields = build_decl (FIELD_DECL, NULL_TREE, get_gcov_unsigned_t ());\n+  fields = build_decl (BUILTINS_LOCATION,\n+\t\t       FIELD_DECL, NULL_TREE, get_gcov_unsigned_t ());\n \n   /* checksum */\n-  field = build_decl (FIELD_DECL, NULL_TREE, get_gcov_unsigned_t ());\n+  field = build_decl (BUILTINS_LOCATION,\n+\t\t      FIELD_DECL, NULL_TREE, get_gcov_unsigned_t ());\n   TREE_CHAIN (field) = fields;\n   fields = field;\n \n@@ -651,7 +654,8 @@ build_fn_info_type (unsigned int counters)\n   array_type = build_array_type (get_gcov_unsigned_t (), array_type);\n \n   /* counters */\n-  field = build_decl (FIELD_DECL, NULL_TREE, array_type);\n+  field = build_decl (BUILTINS_LOCATION,\n+\t\t      FIELD_DECL, NULL_TREE, array_type);\n   TREE_CHAIN (field) = fields;\n   fields = field;\n \n@@ -714,12 +718,14 @@ build_ctr_info_type (void)\n   tree gcov_merge_fn_type;\n \n   /* counters */\n-  field = build_decl (FIELD_DECL, NULL_TREE, get_gcov_unsigned_t ());\n+  field = build_decl (BUILTINS_LOCATION,\n+\t\t      FIELD_DECL, NULL_TREE, get_gcov_unsigned_t ());\n   TREE_CHAIN (field) = fields;\n   fields = field;\n \n   /* values */\n-  field = build_decl (FIELD_DECL, NULL_TREE, gcov_ptr_type);\n+  field = build_decl (BUILTINS_LOCATION,\n+\t\t      FIELD_DECL, NULL_TREE, gcov_ptr_type);\n   TREE_CHAIN (field) = fields;\n   fields = field;\n \n@@ -728,7 +734,8 @@ build_ctr_info_type (void)\n     build_function_type_list (void_type_node,\n \t\t\t      gcov_ptr_type, get_gcov_unsigned_t (),\n \t\t\t      NULL_TREE);\n-  field = build_decl (FIELD_DECL, NULL_TREE,\n+  field = build_decl (BUILTINS_LOCATION,\n+\t\t      FIELD_DECL, NULL_TREE,\n \t\t      build_pointer_type (gcov_merge_fn_type));\n   TREE_CHAIN (field) = fields;\n   fields = field;\n@@ -780,7 +787,8 @@ build_ctr_info_value (unsigned int counter, tree type)\n     value = tree_cons (fields, null_pointer_node, value);\n   fields = TREE_CHAIN (fields);\n \n-  fn = build_decl (FUNCTION_DECL,\n+  fn = build_decl (BUILTINS_LOCATION,\n+\t\t   FUNCTION_DECL,\n \t\t   get_identifier (ctr_merge_functions[counter]),\n \t\t   TREE_TYPE (TREE_TYPE (fields)));\n   DECL_EXTERNAL (fn) = 1;\n@@ -825,20 +833,23 @@ build_gcov_info (void)\n   const_type = build_qualified_type (type, TYPE_QUAL_CONST);\n \n   /* Version ident */\n-  field = build_decl (FIELD_DECL, NULL_TREE, get_gcov_unsigned_t ());\n+  field = build_decl (BUILTINS_LOCATION,\n+\t\t      FIELD_DECL, NULL_TREE, get_gcov_unsigned_t ());\n   TREE_CHAIN (field) = fields;\n   fields = field;\n   value = tree_cons (field, build_int_cstu (TREE_TYPE (field), GCOV_VERSION),\n \t\t     value);\n \n   /* next -- NULL */\n-  field = build_decl (FIELD_DECL, NULL_TREE, build_pointer_type (const_type));\n+  field = build_decl (BUILTINS_LOCATION,\n+\t\t      FIELD_DECL, NULL_TREE, build_pointer_type (const_type));\n   TREE_CHAIN (field) = fields;\n   fields = field;\n   value = tree_cons (field, null_pointer_node, value);\n \n   /* stamp */\n-  field = build_decl (FIELD_DECL, NULL_TREE, get_gcov_unsigned_t ());\n+  field = build_decl (BUILTINS_LOCATION,\n+\t\t      FIELD_DECL, NULL_TREE, get_gcov_unsigned_t ());\n   TREE_CHAIN (field) = fields;\n   fields = field;\n   value = tree_cons (field, build_int_cstu (TREE_TYPE (field), local_tick),\n@@ -847,7 +858,8 @@ build_gcov_info (void)\n   /* Filename */\n   string_type = build_pointer_type (build_qualified_type (char_type_node,\n \t\t\t\t\t\t    TYPE_QUAL_CONST));\n-  field = build_decl (FIELD_DECL, NULL_TREE, string_type);\n+  field = build_decl (BUILTINS_LOCATION,\n+\t\t      FIELD_DECL, NULL_TREE, string_type);\n   TREE_CHAIN (field) = fields;\n   fields = field;\n   da_file_name_len = strlen (da_file_name);\n@@ -882,21 +894,24 @@ build_gcov_info (void)\n     fn_info_value = null_pointer_node;\n \n   /* number of functions */\n-  field = build_decl (FIELD_DECL, NULL_TREE, get_gcov_unsigned_t ());\n+  field = build_decl (BUILTINS_LOCATION,\n+\t\t      FIELD_DECL, NULL_TREE, get_gcov_unsigned_t ());\n   TREE_CHAIN (field) = fields;\n   fields = field;\n   value = tree_cons (field,\n \t\t     build_int_cstu (get_gcov_unsigned_t (), n_fns),\n \t\t     value);\n \n   /* fn_info table */\n-  field = build_decl (FIELD_DECL, NULL_TREE, fn_info_ptr_type);\n+  field = build_decl (BUILTINS_LOCATION,\n+\t\t      FIELD_DECL, NULL_TREE, fn_info_ptr_type);\n   TREE_CHAIN (field) = fields;\n   fields = field;\n   value = tree_cons (field, fn_info_value, value);\n \n   /* counter_mask */\n-  field = build_decl (FIELD_DECL, NULL_TREE, get_gcov_unsigned_t ());\n+  field = build_decl (BUILTINS_LOCATION,\n+\t\t      FIELD_DECL, NULL_TREE, get_gcov_unsigned_t ());\n   TREE_CHAIN (field) = fields;\n   fields = field;\n   value = tree_cons (field,\n@@ -917,7 +932,8 @@ build_gcov_info (void)\n   ctr_info_value = build_constructor_from_list (ctr_info_ary_type,\n \t\t\t\t                nreverse (ctr_info_value));\n \n-  field = build_decl (FIELD_DECL, NULL_TREE, ctr_info_ary_type);\n+  field = build_decl (BUILTINS_LOCATION,\n+\t\t      FIELD_DECL, NULL_TREE, ctr_info_ary_type);\n   TREE_CHAIN (field) = fields;\n   fields = field;\n   value = tree_cons (field, ctr_info_value, value);\n@@ -947,7 +963,8 @@ create_coverage (void)\n \n   t = build_gcov_info ();\n \n-  gcov_info = build_decl (VAR_DECL, NULL_TREE, TREE_TYPE (t));\n+  gcov_info = build_decl (BUILTINS_LOCATION,\n+\t\t\t  VAR_DECL, NULL_TREE, TREE_TYPE (t));\n   TREE_STATIC (gcov_info) = 1;\n   ASM_GENERATE_INTERNAL_LABEL (name_buf, \"LPBX\", 0);\n   DECL_NAME (gcov_info) = get_identifier (name_buf);\n@@ -959,7 +976,8 @@ create_coverage (void)\n   /* Build a decl for __gcov_init.  */\n   t = build_pointer_type (TREE_TYPE (gcov_info));\n   t = build_function_type_list (void_type_node, t, NULL);\n-  t = build_decl (FUNCTION_DECL, get_identifier (\"__gcov_init\"), t);\n+  t = build_decl (BUILTINS_LOCATION,\n+\t\t  FUNCTION_DECL, get_identifier (\"__gcov_init\"), t);\n   TREE_PUBLIC (t) = 1;\n   DECL_EXTERNAL (t) = 1;\n   gcov_init = t;"}, {"sha": "ec8cef035ede250ef07ab72dafcbf42ebf24f85d", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -1,3 +1,86 @@\n+2009-06-12  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* typeck.c (cp_build_binary_op): Pass location to overflow_warning.\n+\t(build_modify_expr): New arg.\n+\t* semantics.c (finish_unary_op_expr): Pass location to\n+\toverflow_warning.\n+\t(handle_omp_for_class_iterator): Pass location to build_modify_expr.\n+\t* typeck.c (cxx_sizeof_or_alignof_type): Pass location to\n+\tc_sizeof_or_alignof_type.\n+\t(build_array_ref): New argument.\n+\t(build_compound_expr): Same.\n+\t(build_const_cast): Same.\n+\t(build_ptrmemfunc): Pass location to build_c_cast.\n+\t* init.c (avoid_placement_new_aliasing): Pass location to\n+\tbuild_stmt.\n+\t(build_vec_delete_1): Pass location to cp_build_modify_expr,\n+\tbuild_compound_expr.\n+\t* class.c (build_vtbl_ref_1): Pass location to build_array_ref.\n+\t* decl.c (poplevel): Pass location to c_build_bind_expr.\n+\t(finish_case_label): Pass location to build_case_label.\n+\t(finish_constructor_body): Same.\n+\t(finish_destructor_body): Pass location to build_stmt.\n+\t(cxx_maybe_build_cleanup): Same, but to build_compound_expr.\n+\t* call.c (build_new_op): Pass location to build_array_ref.\n+\t(build_x_va_arg): Pass location to build_va_arg.\n+\t* except.c (expand_end_catch_block): Pass location to\n+\tbuild_stmt.\n+\t* cp-tree.h (build_array_ref): New argument.\n+\t(build_compound_expr): Same.\n+\t(build_c_cast): Same.\n+\t* cp-gimplify.c (gimplify_if_stmt): Pass location on down.\n+\t(gimplify_switch_stmt): Same.\n+\t* typeck2.c (split_nonconstant_init_1): Same.\n+\t* pt.c (tsubst_copy): Same.\n+\t* semantics.c (add_decl_expr): Same.\n+\t(do_poplevel): Same.\n+\t(push_cleanup): Same.\n+\t(finish_goto_stmt): Same.\n+\t(finish_expr_stmt): Same.\n+\t(begin_if_stmt): Same.\n+\t(begin_while_stmt): Same.\n+\t(begin_do_stmt): Same.\n+\t(finish_return_stmt): Same.\n+\t(begin_for_stmt): Same.\n+\t(finish_break_stmt): Same.\n+\t(finish_continue_stmt): Same.\n+\t(begin_switch_stmt): Same.\n+\t(begin_try_block): Same.\n+\t(begin_handler): Same.\n+\t(finish_asm_stmt): Same.\n+\t(finish_label_stmt): Same.\n+\t(finish_stmt_expr_expr): Same.\n+\t(finalize_nrv_r): Same.\n+\t(finish_omp_atomic): Same.\n+\t* name-lookup.c (do_using_directive): Same.\n+\t* decl2.c (grok_array_decl): Same.\n+\t* parser.c (cp_parser_cast_expression): Same.\n+\t(cp_parser_selection_statement): Same.\n+\t(cp_parser_implicitly_scoped_statement): Same.\n+\t(cp_parser_objc_selector_expression): Same.\n+\t(cp_parser_objc_synchronized_statement): Same.\n+\t(cp_parser_objc_throw_statement): Same.\n+\t(cp_parser_omp_critical): Same.\n+\t(cp_parser_omp_master): Same.\n+\t* typeck.c (build_function_call): Add location argument.\n+\t* init.c: Add location argument to all build_decl calls.\n+\t* class.c: Same.\n+\t* method.c: Same.\n+\t* rtti.c: Same.\n+\t* tree.c: Same.\n+\t* pt.c: Same.\n+\t* semantics.c: Same.\n+\t* lex.c: Same.\n+\t* decl2.c: Same.\n+\t* cp-gimplify.c: Same.\n+\t* decl.c: Same.\n+\t(cp_make_fname_decl): Add location argument.  Pass location ot\n+\tbuild_decl.\n+\t(finish_case_label): Same.\n+\t* cp-tree.h (finish_case_label): Add location argument.\n+\t* parser.c (cp_parser_label_for_labeled_statement): Pass location to\n+\tfinish_case_label.\n+\t\n 2009-06-09  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/40381"}, {"sha": "f33d64573dd35f93b0028a46b44df57467311b9e", "filename": "gcc/cp/call.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -4398,7 +4398,7 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3,\n       return cp_build_unary_op (code, arg1, candidates != 0, complain);\n \n     case ARRAY_REF:\n-      return build_array_ref (arg1, arg2, input_location);\n+      return build_array_ref (input_location, arg1, arg2);\n \n     case COND_EXPR:\n       return build_conditional_expr (arg1, arg2, arg3, complain);\n@@ -5102,7 +5102,7 @@ build_x_va_arg (tree expr, tree type)\n       return expr;\n     }\n \n-  return build_va_arg (expr, type);\n+  return build_va_arg (input_location, expr, type);\n }\n \n /* TYPE has been given to va_arg.  Apply the default conversions which"}, {"sha": "94b75ca61534500c8faf532ba0913f7b8a969e03", "filename": "gcc/cp/class.c", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -626,7 +626,7 @@ build_vtbl_ref_1 (tree instance, tree idx)\n     vtbl = build_vfield_ref (instance, basetype);\n \n \n-  aref = build_array_ref (vtbl, idx, input_location);\n+  aref = build_array_ref (input_location, vtbl, idx);\n   TREE_CONSTANT (aref) |= TREE_CONSTANT (vtbl) && TREE_CONSTANT (idx);\n \n   return aref;\n@@ -3636,7 +3636,8 @@ build_base_field (record_layout_info rli, tree binfo,\n       CLASSTYPE_EMPTY_P (t) = 0;\n \n       /* Create the FIELD_DECL.  */\n-      decl = build_decl (FIELD_DECL, NULL_TREE, CLASSTYPE_AS_BASE (basetype));\n+      decl = build_decl (input_location,\n+\t\t\t FIELD_DECL, NULL_TREE, CLASSTYPE_AS_BASE (basetype));\n       DECL_ARTIFICIAL (decl) = 1;\n       DECL_IGNORED_P (decl) = 1;\n       DECL_FIELD_CONTEXT (decl) = t;\n@@ -4428,7 +4429,8 @@ create_vtable_ptr (tree t, tree* virtuals_p)\n \t stores cannot alias stores to void*!  */\n       tree field;\n \n-      field = build_decl (FIELD_DECL, get_vfield_name (t), vtbl_ptr_type_node);\n+      field = build_decl (input_location, \n+\t\t\t  FIELD_DECL, get_vfield_name (t), vtbl_ptr_type_node);\n       DECL_VIRTUAL_P (field) = 1;\n       DECL_ARTIFICIAL (field) = 1;\n       DECL_FIELD_CONTEXT (field) = t;\n@@ -5008,7 +5010,8 @@ layout_class_type (tree t, tree *virtuals_p)\n \t{\n \t  tree padding_field;\n \n-\t  padding_field = build_decl (FIELD_DECL,\n+\t  padding_field = build_decl (input_location,\n+\t\t\t\t      FIELD_DECL,\n \t\t\t\t      NULL_TREE,\n \t\t\t\t      char_type_node);\n \t  DECL_BIT_FIELD (padding_field) = 1;\n@@ -5096,7 +5099,8 @@ layout_class_type (tree t, tree *virtuals_p)\n       for (field = TYPE_FIELDS (t); field; field = TREE_CHAIN (field))\n \tif (TREE_CODE (field) == FIELD_DECL)\n \t  {\n-\t    *next_field = build_decl (FIELD_DECL,\n+\t    *next_field = build_decl (input_location,\n+\t\t\t\t      FIELD_DECL,\n \t\t\t\t      DECL_NAME (field),\n \t\t\t\t      TREE_TYPE (field));\n \t    DECL_CONTEXT (*next_field) = base_t;\n@@ -5137,7 +5141,8 @@ layout_class_type (tree t, tree *virtuals_p)\n   /* Make sure not to create any structures with zero size.  */\n   if (integer_zerop (rli_size_unit_so_far (rli)) && CLASSTYPE_EMPTY_P (t))\n     place_field (rli,\n-\t\t build_decl (FIELD_DECL, NULL_TREE, char_type_node));\n+\t\t build_decl (input_location,\n+\t\t\t     FIELD_DECL, NULL_TREE, char_type_node));\n \n   /* Let the back end lay out the type.  */\n   finish_record_layout (rli, /*free_p=*/true);"}, {"sha": "29f4f382e5cbacd65f964db43825a691f9c67987", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -50,7 +50,7 @@ static tree bc_label[2];\n static tree\n begin_bc_block (enum bc_t bc)\n {\n-  tree label = create_artificial_label ();\n+  tree label = create_artificial_label (input_location);\n   TREE_CHAIN (label) = bc_label[bc];\n   bc_label[bc] = label;\n   return label;\n@@ -169,9 +169,9 @@ genericize_if_stmt (tree *stmt_p)\n   else_ = ELSE_CLAUSE (stmt);\n \n   if (!then_)\n-    then_ = build_empty_stmt ();\n+    then_ = build_empty_stmt (locus);\n   if (!else_)\n-    else_ = build_empty_stmt ();\n+    else_ = build_empty_stmt (locus);\n \n   if (integer_nonzerop (cond) && !TREE_SIDE_EFFECTS (else_))\n     stmt = then_;\n@@ -226,7 +226,7 @@ gimplify_cp_loop (tree cond, tree body, tree incr, bool cond_is_first)\n \t back through the main gimplifier to lower it.  Given that we\n \t have to gimplify the loop body NOW so that we can resolve\n \t break/continue stmts, seems easier to just expand to gotos.  */\n-      top = gimple_build_label (create_artificial_label ());\n+      top = gimple_build_label (create_artificial_label (stmt_locus));\n \n       /* If we have an exit condition, then we build an IF with gotos either\n \t out of the loop, or to the top of it.  If there's no exit condition,\n@@ -247,7 +247,8 @@ gimplify_cp_loop (tree cond, tree body, tree incr, bool cond_is_first)\n \t    {\n \t      if (incr)\n \t\t{\n-\t\t  entry = gimple_build_label (create_artificial_label ());\n+\t\t  entry = gimple_build_label \n+\t\t    (create_artificial_label (stmt_locus));\n \t\t  stmt = gimple_build_goto (gimple_label_label (entry));\n \t\t}\n \t      else\n@@ -334,7 +335,7 @@ gimplify_switch_stmt (tree *stmt_p, gimple_seq *pre_p)\n \n   body = SWITCH_STMT_BODY (stmt);\n   if (!body)\n-    body = build_empty_stmt ();\n+    body = build_empty_stmt (stmt_locus);\n \n   t = build3 (SWITCH_EXPR, SWITCH_STMT_TYPE (stmt),\n \t      SWITCH_STMT_COND (stmt), body, NULL_TREE);\n@@ -939,7 +940,7 @@ cxx_omp_clause_apply_fn (tree fn, tree arg1, tree arg2)\n \t  append_to_statement_list (t, &ret);\n \t}\n \n-      lab = create_artificial_label ();\n+      lab = create_artificial_label (input_location);\n       t = build1 (LABEL_EXPR, void_type_node, lab);\n       append_to_statement_list (t, &ret);\n "}, {"sha": "19d61bfe208d70aeaa3f4730db1641a5075d61b5", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -4380,7 +4380,7 @@ extern tree reshape_init (tree, tree);\n \n extern bool defer_mark_used_calls;\n extern GTY(()) VEC(tree, gc) *deferred_mark_used_calls;\n-extern tree finish_case_label\t\t\t(tree, tree);\n+extern tree finish_case_label\t\t\t(location_t, tree, tree);\n extern tree cxx_maybe_build_cleanup\t\t(tree);\n \n /* in decl2.c */\n@@ -4542,7 +4542,8 @@ extern tree type_uses_auto\t\t\t(tree);\n extern void append_type_to_template_for_access_check (tree, tree, tree);\n extern tree splice_late_return_type\t\t(tree, tree);\n extern bool is_auto\t\t\t\t(const_tree);\n-extern tree process_template_parm\t\t(tree, tree, bool, bool);\n+extern tree process_template_parm\t\t(tree, location_t, tree, \n+\t\t\t\t\t\t bool, bool);\n extern tree end_template_parm_list\t\t(tree);\n extern void end_template_decl\t\t\t(void);\n extern bool check_default_tmpl_args             (tree, tree, int, int, int);\n@@ -4933,7 +4934,7 @@ extern tree build_x_indirect_ref\t\t(tree, const char *,\n                                                  tsubst_flags_t);\n extern tree cp_build_indirect_ref\t\t(tree, const char *,\n                                                  tsubst_flags_t);\n-extern tree build_array_ref\t\t\t(tree, tree, location_t);\n+extern tree build_array_ref\t\t\t(location_t, tree, tree);\n extern tree get_member_function_from_ptrfunc\t(tree *, tree);\n extern tree cp_build_function_call              (tree, tree, tsubst_flags_t);\n extern tree cp_build_function_call_vec\t\t(tree, VEC(tree,gc) **,\n@@ -4953,12 +4954,12 @@ extern tree build_x_conditional_expr\t\t(tree, tree, tree,\n extern tree build_x_compound_expr_from_list\t(tree, const char *);\n extern tree build_x_compound_expr_from_vec\t(VEC(tree,gc) *, const char *);\n extern tree build_x_compound_expr\t\t(tree, tree, tsubst_flags_t);\n-extern tree build_compound_expr                 (tree, tree);\n+extern tree build_compound_expr                 (location_t, tree, tree);\n extern tree cp_build_compound_expr\t\t(tree, tree, tsubst_flags_t);\n extern tree build_static_cast\t\t\t(tree, tree, tsubst_flags_t);\n extern tree build_reinterpret_cast\t\t(tree, tree, tsubst_flags_t);\n extern tree build_const_cast\t\t\t(tree, tree, tsubst_flags_t);\n-extern tree build_c_cast\t\t\t(tree, tree);\n+extern tree build_c_cast\t\t\t(location_t, tree, tree);\n extern tree cp_build_c_cast\t\t\t(tree, tree, tsubst_flags_t);\n extern tree build_x_modify_expr\t\t\t(tree, enum tree_code, tree,\n \t\t\t\t\t\t tsubst_flags_t);"}, {"sha": "22c426b3247b2121258af17a000dc78488ee26d4", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 39, "deletions": 34, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -94,7 +94,7 @@ static tree get_atexit_node (void);\n static tree get_dso_handle_node (void);\n static tree start_cleanup_fn (void);\n static void end_cleanup_fn (void);\n-static tree cp_make_fname_decl (tree, int);\n+static tree cp_make_fname_decl (location_t, tree, int);\n static void initialize_predefined_identifiers (void);\n static tree check_special_function_return_type\n \t(special_function_kind, tree, tree);\n@@ -743,7 +743,7 @@ poplevel (int keep, int reverse, int functionbody)\n \t have pushed a statement list level.  Pop that, create a new\n \t BIND_EXPR for the block, and insert it into the stream.  */\n       stmt = pop_stmt_list (current_binding_level->statement_list);\n-      stmt = c_build_bind_expr (block, stmt);\n+      stmt = c_build_bind_expr (input_location, block, stmt);\n       add_stmt (stmt);\n     }\n \n@@ -842,7 +842,7 @@ create_implicit_typedef (tree name, tree type)\n {\n   tree decl;\n \n-  decl = build_decl (TYPE_DECL, name, type);\n+  decl = build_decl (input_location, TYPE_DECL, name, type);\n   DECL_ARTIFICIAL (decl) = 1;\n   /* There are other implicit type declarations, like the one *within*\n      a class that allows you to write `S::S'.  We must distinguish\n@@ -2368,7 +2368,7 @@ make_label_decl (tree id, int local_p)\n   void **slot;\n   tree decl;\n \n-  decl = build_decl (LABEL_DECL, id, void_type_node);\n+  decl = build_decl (input_location, LABEL_DECL, id, void_type_node);\n \n   DECL_CONTEXT (decl) = current_function_decl;\n   DECL_MODE (decl) = VOIDmode;\n@@ -2795,7 +2795,7 @@ pop_switch (void)\n    is a bad place for one.  */\n \n tree\n-finish_case_label (tree low_value, tree high_value)\n+finish_case_label (location_t loc, tree low_value, tree high_value)\n {\n   tree cond, r;\n   struct cp_binding_level *p;\n@@ -2806,8 +2806,8 @@ finish_case_label (tree low_value, tree high_value)\n \n       /* For templates, just add the case label; we'll do semantic\n \t analysis at instantiation-time.  */\n-      label = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n-      return add_stmt (build_case_label (low_value, high_value, label));\n+      label = build_decl (loc, LABEL_DECL, NULL_TREE, NULL_TREE);\n+      return add_stmt (build_case_label (loc, low_value, high_value, label));\n     }\n \n   /* Find the condition on which this switch statement depends.  */\n@@ -2818,7 +2818,7 @@ finish_case_label (tree low_value, tree high_value)\n   if (!check_switch_goto (switch_stack->level))\n     return error_mark_node;\n \n-  r = c_add_case_label (switch_stack->cases, cond,\n+  r = c_add_case_label (loc, switch_stack->cases, cond,\n \t\t\tSWITCH_STMT_TYPE (switch_stack->switch_stmt),\n \t\t\tlow_value, high_value);\n \n@@ -2915,7 +2915,7 @@ build_typename_type (tree context, tree name, tree fullname,\n       TYPENAME_IS_CLASS_P (t) = ti.class_p;\n \n       /* Build the corresponding TYPE_DECL.  */\n-      d = build_decl (TYPE_DECL, name, t);\n+      d = build_decl (input_location, TYPE_DECL, name, t);\n       TYPE_NAME (TREE_TYPE (d)) = d;\n       TYPE_STUB_DECL (TREE_TYPE (d)) = d;\n       DECL_CONTEXT (d) = FROB_CONTEXT (context);\n@@ -3113,7 +3113,7 @@ make_unbound_class_template (tree context, tree name, tree parm_list,\n   SET_TYPE_STRUCTURAL_EQUALITY (t);\n \n   /* Build the corresponding TEMPLATE_DECL.  */\n-  d = build_decl (TEMPLATE_DECL, name, t);\n+  d = build_decl (input_location, TEMPLATE_DECL, name, t);\n   TYPE_NAME (TREE_TYPE (d)) = d;\n   TYPE_STUB_DECL (TREE_TYPE (d)) = d;\n   DECL_CONTEXT (d) = FROB_CONTEXT (context);\n@@ -3150,15 +3150,15 @@ record_builtin_type (enum rid rid_index,\n      up built-in types by name.  */\n   if (tname)\n     {\n-      tdecl = build_decl (TYPE_DECL, tname, type);\n+      tdecl = build_decl (BUILTINS_LOCATION, TYPE_DECL, tname, type);\n       DECL_ARTIFICIAL (tdecl) = 1;\n       SET_IDENTIFIER_GLOBAL_VALUE (tname, tdecl);\n     }\n   if (rname)\n     {\n       if (!tdecl)\n \t{\n-\t  tdecl = build_decl (TYPE_DECL, rname, type);\n+\t  tdecl = build_decl (BUILTINS_LOCATION, TYPE_DECL, rname, type);\n \t  DECL_ARTIFICIAL (tdecl) = 1;\n \t}\n       SET_IDENTIFIER_GLOBAL_VALUE (rname, tdecl);\n@@ -3218,7 +3218,8 @@ record_builtin_java_type (const char* name, int size)\n static void\n record_unknown_type (tree type, const char* name)\n {\n-  tree decl = pushdecl (build_decl (TYPE_DECL, get_identifier (name), type));\n+  tree decl = pushdecl (build_decl (UNKNOWN_LOCATION,\n+\t\t\t\t    TYPE_DECL, get_identifier (name), type));\n   /* Make sure the \"unknown type\" typedecl gets ignored for debug info.  */\n   DECL_IGNORED_P (decl) = 1;\n   TYPE_DECL_SUPPRESS_DEBUG (decl) = 1;\n@@ -3492,20 +3493,21 @@ cp_fname_init (const char* name, tree *type_p)\n   return init;\n }\n \n-/* Create the VAR_DECL for __FUNCTION__ etc. ID is the name to give the\n-   decl, NAME is the initialization string and TYPE_DEP indicates whether\n-   NAME depended on the type of the function. We make use of that to detect\n-   __PRETTY_FUNCTION__ inside a template fn. This is being done\n-   lazily at the point of first use, so we mustn't push the decl now.  */\n+/* Create the VAR_DECL for __FUNCTION__ etc. ID is the name to give\n+   the decl, LOC is the location to give the decl, NAME is the\n+   initialization string and TYPE_DEP indicates whether NAME depended\n+   on the type of the function. We make use of that to detect\n+   __PRETTY_FUNCTION__ inside a template fn. This is being done lazily\n+   at the point of first use, so we mustn't push the decl now.  */\n \n static tree\n-cp_make_fname_decl (tree id, int type_dep)\n+cp_make_fname_decl (location_t loc, tree id, int type_dep)\n {\n   const char *const name = (type_dep && processing_template_decl\n \t\t\t    ? NULL : fname_as_string (type_dep));\n   tree type;\n   tree init = cp_fname_init (name, &type);\n-  tree decl = build_decl (VAR_DECL, id, type);\n+  tree decl = build_decl (loc, VAR_DECL, id, type);\n \n   if (name)\n     free (CONST_CAST (char *, name));\n@@ -5898,7 +5900,7 @@ declare_global_var (tree name, tree type)\n   tree decl;\n \n   push_to_top_level ();\n-  decl = build_decl (VAR_DECL, name, type);\n+  decl = build_decl (input_location, VAR_DECL, name, type);\n   TREE_PUBLIC (decl) = 1;\n   DECL_EXTERNAL (decl) = 1;\n   DECL_ARTIFICIAL (decl) = 1;\n@@ -6952,7 +6954,7 @@ grokvardecl (tree type,\n \t  || TYPE_P (scope)))\n     decl = build_lang_decl (VAR_DECL, name, type);\n   else\n-    decl = build_decl (VAR_DECL, name, type);\n+    decl = build_decl (input_location, VAR_DECL, name, type);\n \n   if (explicit_scope && TREE_CODE (explicit_scope) == NAMESPACE_DECL)\n     set_decl_namespace (decl, explicit_scope, 0);\n@@ -7063,10 +7065,11 @@ build_ptrmemfunc_type (tree type)\n   /* ... and not really a class type.  */\n   SET_CLASS_TYPE_P (t, 0);\n \n-  field = build_decl (FIELD_DECL, pfn_identifier, type);\n+  field = build_decl (input_location, FIELD_DECL, pfn_identifier, type);\n   fields = field;\n \n-  field = build_decl (FIELD_DECL, delta_identifier, delta_type_node);\n+  field = build_decl (input_location, FIELD_DECL, delta_identifier, \n+\t\t      delta_type_node);\n   TREE_CHAIN (field) = fields;\n   fields = field;\n \n@@ -8804,7 +8807,7 @@ grokdeclarator (const cp_declarator *declarator,\n       if (decl_context == FIELD)\n \tdecl = build_lang_decl (TYPE_DECL, unqualified_id, type);\n       else\n-\tdecl = build_decl (TYPE_DECL, unqualified_id, type);\n+\tdecl = build_decl (input_location, TYPE_DECL, unqualified_id, type);\n       if (id_declarator && declarator->u.id.qualifying_scope) {\n \terror (\"%Jtypedef name may not be a nested-name-specifier\", decl);\n \tTREE_TYPE (decl) = error_mark_node;\n@@ -9310,7 +9313,8 @@ grokdeclarator (const cp_declarator *declarator,\n \t      }\n \t    else\n \t      {\n-\t\tdecl = build_decl (FIELD_DECL, unqualified_id, type);\n+\t\tdecl = build_decl (input_location,\n+\t\t\t\t   FIELD_DECL, unqualified_id, type);\n \t\tDECL_NONADDRESSABLE_P (decl) = bitfield;\n \t\tif (bitfield && !unqualified_id)\n \t\t  TREE_NO_WARNING (decl) = 1;\n@@ -11387,7 +11391,7 @@ build_enumerator (tree name, tree value, tree enumtype)\n   else\n     /* It's a global enum, or it's local to a function.  (Note local to\n       a function could mean local to a class method.  */\n-    decl = build_decl (CONST_DECL, name, type);\n+    decl = build_decl (input_location, CONST_DECL, name, type);\n \n   DECL_CONTEXT (decl) = FROB_CONTEXT (context);\n   TREE_CONSTANT (decl) = 1;\n@@ -11614,7 +11618,7 @@ start_preparsed_function (tree decl1, tree attrs, int flags)\n     {\n       tree resdecl;\n \n-      resdecl = build_decl (RESULT_DECL, 0, restype);\n+      resdecl = build_decl (input_location, RESULT_DECL, 0, restype);\n       DECL_ARTIFICIAL (resdecl) = 1;\n       DECL_IGNORED_P (resdecl) = 1;\n       DECL_RESULT (decl1) = resdecl;\n@@ -11857,7 +11861,8 @@ start_preparsed_function (tree decl1, tree attrs, int flags)\n       || (DECL_CONSTRUCTOR_P (decl1)\n \t  && targetm.cxx.cdtor_returns_this ()))\n     {\n-      cdtor_label = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n+      cdtor_label = build_decl (input_location, \n+\t\t\t\tLABEL_DECL, NULL_TREE, NULL_TREE);\n       DECL_CONTEXT (cdtor_label) = current_function_decl;\n     }\n \n@@ -12039,13 +12044,13 @@ finish_constructor_body (void)\n       && (! TYPE_FOR_JAVA (current_class_type)))\n     {\n       /* Any return from a constructor will end up here.  */\n-      add_stmt (build_stmt (LABEL_EXPR, cdtor_label));\n+      add_stmt (build_stmt (input_location, LABEL_EXPR, cdtor_label));\n \n       val = DECL_ARGUMENTS (current_function_decl);\n       val = build2 (MODIFY_EXPR, TREE_TYPE (val),\n \t\t    DECL_RESULT (current_function_decl), val);\n       /* Return the address of the object.  */\n-      exprstmt = build_stmt (RETURN_EXPR, val);\n+      exprstmt = build_stmt (input_location, RETURN_EXPR, val);\n       add_stmt (exprstmt);\n     }\n }\n@@ -12087,7 +12092,7 @@ finish_destructor_body (void)\n \n   /* Any return from a destructor will end up here; that way all base\n      and member cleanups will be run when the function returns.  */\n-  add_stmt (build_stmt (LABEL_EXPR, cdtor_label));\n+  add_stmt (build_stmt (input_location, LABEL_EXPR, cdtor_label));\n \n   /* In a virtual destructor, we must call delete.  */\n   if (DECL_VIRTUAL_P (current_function_decl))\n@@ -12125,7 +12130,7 @@ finish_destructor_body (void)\n       val = build2 (MODIFY_EXPR, TREE_TYPE (val),\n \t\t    DECL_RESULT (current_function_decl), val);\n       /* Return the address of the object.  */\n-      exprstmt = build_stmt (RETURN_EXPR, val);\n+      exprstmt = build_stmt (input_location, RETURN_EXPR, val);\n       add_stmt (exprstmt);\n     }\n }\n@@ -12709,7 +12714,7 @@ cxx_maybe_build_cleanup (tree decl)\n       call = build_delete (TREE_TYPE (addr), addr,\n \t\t\t   sfk_complete_destructor, flags, 0);\n       if (cleanup)\n-\tcleanup = build_compound_expr (cleanup, call);\n+\tcleanup = build_compound_expr (input_location, cleanup, call);\n       else\n \tcleanup = call;\n     }"}, {"sha": "c540c08e932c80ee39640b6b754f49516b250442", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -132,7 +132,8 @@ build_memfn_type (tree fntype, tree ctype, cp_cv_quals quals)\n tree\n cp_build_parm_decl (tree name, tree type)\n {\n-  tree parm = build_decl (PARM_DECL, name, type);\n+  tree parm = build_decl (input_location,\n+\t\t\t  PARM_DECL, name, type);\n   /* DECL_ARG_TYPE is only used by the back end and the back end never\n      sees templates.  */\n   if (!processing_template_decl)\n@@ -354,7 +355,7 @@ grok_array_decl (tree array_expr, tree index_exp)\n       if (array_expr == error_mark_node || index_exp == error_mark_node)\n \terror (\"ambiguous conversion for array subscript\");\n \n-      expr = build_array_ref (array_expr, index_exp, input_location);\n+      expr = build_array_ref (input_location, array_expr, index_exp);\n     }\n   if (processing_template_decl && expr != error_mark_node)\n     return build_min_non_dep (ARRAY_REF, expr, orig_array_expr, orig_index_exp,\n@@ -1287,7 +1288,8 @@ build_anon_union_vars (tree type, tree object)\n \t{\n \t  tree base;\n \n-\t  decl = build_decl (VAR_DECL, DECL_NAME (field), TREE_TYPE (field));\n+\t  decl = build_decl (input_location,\n+\t\t\t     VAR_DECL, DECL_NAME (field), TREE_TYPE (field));\n \t  DECL_ANON_UNION_VAR_P (decl) = 1;\n \n \t  base = get_base_address (object);\n@@ -2495,7 +2497,8 @@ get_guard (tree decl)\n       /* We use a type that is big enough to contain a mutex as well\n \t as an integer counter.  */\n       guard_type = targetm.cxx.guard_type ();\n-      guard = build_decl (VAR_DECL, sname, guard_type);\n+      guard = build_decl (DECL_SOURCE_LOCATION (decl),\n+\t\t\t  VAR_DECL, sname, guard_type);\n \n       /* The guard should have the same linkage as what it guards.  */\n       TREE_PUBLIC (guard) = TREE_PUBLIC (decl);"}, {"sha": "92def0f72d084354f27c4bdf0b50d9cc26faf3c6", "filename": "gcc/cp/except.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -521,7 +521,7 @@ expand_end_catch_block (void)\n tree\n begin_eh_spec_block (void)\n {\n-  tree r = build_stmt (EH_SPEC_BLOCK, NULL_TREE, NULL_TREE);\n+  tree r = build_stmt (input_location, EH_SPEC_BLOCK, NULL_TREE, NULL_TREE);\n   add_stmt (r);\n   EH_SPEC_STMTS (r) = push_stmt_list ();\n   return r;"}, {"sha": "26089965d0c6ab27ed496c3c66946319d93549af", "filename": "gcc/cp/init.c", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -2399,7 +2399,8 @@ build_java_class_ref (tree type)\n   class_decl = IDENTIFIER_GLOBAL_VALUE (name);\n   if (class_decl == NULL_TREE)\n     {\n-      class_decl = build_decl (VAR_DECL, name, TREE_TYPE (jclass_node));\n+      class_decl = build_decl (input_location,\n+\t\t\t       VAR_DECL, name, TREE_TYPE (jclass_node));\n       TREE_STATIC (class_decl) = 1;\n       DECL_EXTERNAL (class_decl) = 1;\n       TREE_PUBLIC (class_decl) = 1;\n@@ -2465,15 +2466,17 @@ build_vec_delete_1 (tree base, tree maxindex, tree type,\n \t\t\t fold_convert (ptype, base)));\n   tmp = fold_build1 (NEGATE_EXPR, sizetype, size_exp);\n   body = build_compound_expr\n-    (body, cp_build_modify_expr (tbase, NOP_EXPR,\n+    (input_location, \n+     body, cp_build_modify_expr (tbase, NOP_EXPR,\n \t\t\t\t build2 (POINTER_PLUS_EXPR, ptype, tbase, tmp),\n \t\t\t\t tf_warning_or_error));\n   body = build_compound_expr\n-    (body, build_delete (ptype, tbase, sfk_complete_destructor,\n+    (input_location,\n+     body, build_delete (ptype, tbase, sfk_complete_destructor,\n \t\t\t LOOKUP_NORMAL|LOOKUP_DESTRUCTOR, 1));\n \n   loop = build1 (LOOP_EXPR, void_type_node, body);\n-  loop = build_compound_expr (tbase_init, loop);\n+  loop = build_compound_expr (input_location, tbase_init, loop);\n \n  no_destructor:\n   /* If the delete flag is one, or anything else with the low bit set,\n@@ -2520,7 +2523,7 @@ build_vec_delete_1 (tree base, tree maxindex, tree type,\n   else if (!body)\n     body = deallocate_expr;\n   else\n-    body = build_compound_expr (body, deallocate_expr);\n+    body = build_compound_expr (input_location, body, deallocate_expr);\n \n   if (!body)\n     body = integer_zero_node;\n@@ -2553,11 +2556,11 @@ create_temporary_var (tree type)\n {\n   tree decl;\n \n-  decl = build_decl (VAR_DECL, NULL_TREE, type);\n+  decl = build_decl (input_location,\n+\t\t     VAR_DECL, NULL_TREE, type);\n   TREE_USED (decl) = 1;\n   DECL_ARTIFICIAL (decl) = 1;\n   DECL_IGNORED_P (decl) = 1;\n-  DECL_SOURCE_LOCATION (decl) = input_location;\n   DECL_CONTEXT (decl) = current_function_decl;\n \n   return decl;"}, {"sha": "bf507411d6ff50fb7b8735f23d61c019717c549a", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -454,7 +454,8 @@ unqualified_name_lookup_error (tree name)\n       if (current_function_decl)\n \t{\n \t  tree decl;\n-\t  decl = build_decl (VAR_DECL, name, error_mark_node);\n+\t  decl = build_decl (input_location,\n+\t\t\t     VAR_DECL, name, error_mark_node);\n \t  DECL_CONTEXT (decl) = current_function_decl;\n \t  push_local_binding (name, decl, 0);\n \t  /* Mark the variable as used so that we do not get warnings\n@@ -511,7 +512,8 @@ build_lang_decl (enum tree_code code, tree name, tree type)\n {\n   tree t;\n \n-  t = build_decl (code, name, type);\n+  t = build_decl (input_location,\n+\t\t  code, name, type);\n   retrofit_lang_decl (t);\n \n   /* All nesting of C++ functions is lexical; there is never a \"static"}, {"sha": "0ceff668cd73ddb80b5c22ee8f9b23b7577e8aa8", "filename": "gcc/cp/method.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -126,7 +126,8 @@ make_thunk (tree function, bool this_adjusting,\n   gcc_assert (TYPE_SIZE (DECL_CONTEXT (function))\n \t      && TYPE_BEING_DEFINED (DECL_CONTEXT (function)));\n \n-  thunk = build_decl (FUNCTION_DECL, NULL_TREE, TREE_TYPE (function));\n+  thunk = build_decl (DECL_SOURCE_LOCATION (function),\n+\t\t      FUNCTION_DECL, NULL_TREE, TREE_TYPE (function));\n   DECL_LANG_SPECIFIC (thunk) = DECL_LANG_SPECIFIC (function);\n   cxx_dup_lang_specific_decl (thunk);\n   DECL_THUNKS (thunk) = NULL_TREE;\n@@ -262,7 +263,8 @@ static GTY (()) int thunk_labelno;\n tree\n make_alias_for (tree function, tree newid)\n {\n-  tree alias = build_decl (FUNCTION_DECL, newid, TREE_TYPE (function));\n+  tree alias = build_decl (DECL_SOURCE_LOCATION (function),\n+\t\t\t   FUNCTION_DECL, newid, TREE_TYPE (function));\n   DECL_LANG_SPECIFIC (alias) = DECL_LANG_SPECIFIC (function);\n   cxx_dup_lang_specific_decl (alias);\n   DECL_CONTEXT (alias) = NULL;\n@@ -428,7 +430,8 @@ use_thunk (tree thunk_fndecl, bool emit_p)\n       \n       current_function_decl = thunk_fndecl;\n       DECL_RESULT (thunk_fndecl)\n-\t= build_decl (RESULT_DECL, 0, integer_type_node);\n+\t= build_decl (DECL_SOURCE_LOCATION (thunk_fndecl),\n+\t\t      RESULT_DECL, 0, integer_type_node);\n       fnname = IDENTIFIER_POINTER (DECL_NAME (thunk_fndecl));\n       /* The back end expects DECL_INITIAL to contain a BLOCK, so we\n \t create one.  */"}, {"sha": "f6b22bb679371a2c481fd50809e26b486697f0cc", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -3491,7 +3491,7 @@ do_using_directive (tree name_space)\n   gcc_assert (TREE_CODE (name_space) == NAMESPACE_DECL);\n \n   if (building_stmt_tree ())\n-    add_stmt (build_stmt (USING_STMT, name_space));\n+    add_stmt (build_stmt (input_location, USING_STMT, name_space));\n   name_space = ORIGINAL_NAMESPACE (name_space);\n \n   if (!toplevel_bindings_p ())\n@@ -5415,7 +5415,7 @@ cp_emit_debug_info_for_using (tree t, tree context)\n     if (TREE_CODE (t) != TEMPLATE_DECL)\n       {\n \tif (building_stmt_tree ())\n-\t  add_stmt (build_stmt (USING_STMT, t));\n+\t  add_stmt (build_stmt (input_location, USING_STMT, t));\n \telse\n \t  (*debug_hooks->imported_module_or_decl) (t, NULL_TREE, context, false);\n       }"}, {"sha": "07f0375e26e318ba8ec123b4c18dfd897cc3bbf0", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 38, "deletions": 26, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -6135,7 +6135,7 @@ cp_parser_cast_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t    return error_mark_node;\n \n \t  /* Perform the cast.  */\n-\t  expr = build_c_cast (type, expr);\n+\t  expr = build_c_cast (input_location, type, expr);\n \t  return expr;\n \t}\n       else \n@@ -7093,7 +7093,7 @@ cp_parser_label_for_labeled_statement (cp_parser* parser)\n \t  expr_hi = NULL_TREE;\n \n \tif (parser->in_switch_statement_p)\n-\t  finish_case_label (expr, expr_hi);\n+\t  finish_case_label (token->location, expr, expr_hi);\n \telse\n \t  error (\"%Hcase label %qE not within a switch statement\",\n \t\t &token->location, expr);\n@@ -7105,7 +7105,7 @@ cp_parser_label_for_labeled_statement (cp_parser* parser)\n       cp_lexer_consume_token (parser->lexer);\n \n       if (parser->in_switch_statement_p)\n-\tfinish_case_label (NULL_TREE, NULL_TREE);\n+\tfinish_case_label (token->location, NULL_TREE, NULL_TREE);\n       else\n \terror (\"%Hcase label not within a switch statement\", &token->location);\n       break;\n@@ -7326,7 +7326,7 @@ cp_parser_selection_statement (cp_parser* parser, bool *if_p)\n \t    if (cp_lexer_next_token_is (parser->lexer, CPP_SEMICOLON))\n \t      {\n \t        location_t loc = cp_lexer_peek_token (parser->lexer)->location;\n-\t\tadd_stmt (build_empty_stmt ());\n+\t\tadd_stmt (build_empty_stmt (loc));\n \t\tcp_lexer_consume_token (parser->lexer);\n \t        if (!cp_lexer_next_token_is_keyword (parser->lexer, RID_ELSE))\n \t\t  warning_at (loc, OPT_Wempty_body, \"suggest braces around \"\n@@ -7349,10 +7349,12 @@ cp_parser_selection_statement (cp_parser* parser, bool *if_p)\n \t\t/* Parse the else-clause.  */\n \t        if (cp_lexer_next_token_is (parser->lexer, CPP_SEMICOLON))\n \t          {\n-\t\t    warning_at (cp_lexer_peek_token (parser->lexer)->location,\n+\t\t    location_t loc;\n+\t\t    loc = cp_lexer_peek_token (parser->lexer)->location;\n+\t\t    warning_at (loc,\n \t\t\t\tOPT_Wempty_body, \"suggest braces around \"\n \t\t\t        \"empty body in an %<else%> statement\");\n-\t\t    add_stmt (build_empty_stmt ());\n+\t\t    add_stmt (build_empty_stmt (loc));\n \t\t    cp_lexer_consume_token (parser->lexer);\n \t\t  }\n \t\telse\n@@ -7860,8 +7862,9 @@ cp_parser_implicitly_scoped_statement (cp_parser* parser, bool *if_p)\n   /* Mark if () ; with a special NOP_EXPR.  */\n   if (cp_lexer_next_token_is (parser->lexer, CPP_SEMICOLON))\n     {\n+      location_t loc = cp_lexer_peek_token (parser->lexer)->location;\n       cp_lexer_consume_token (parser->lexer);\n-      statement = add_stmt (build_empty_stmt ());\n+      statement = add_stmt (build_empty_stmt (loc));\n     }\n   /* if a compound is opened, we simply parse the statement directly.  */\n   else if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE))\n@@ -9680,14 +9683,17 @@ cp_parser_template_parameter_list (cp_parser* parser)\n       tree parameter;\n       bool is_non_type;\n       bool is_parameter_pack;\n+      location_t parm_loc;\n \n       /* Parse the template-parameter.  */\n+      parm_loc = cp_lexer_peek_token (parser->lexer)->location;\n       parameter = cp_parser_template_parameter (parser, \n                                                 &is_non_type,\n                                                 &is_parameter_pack);\n       /* Add it to the list.  */\n       if (parameter != error_mark_node)\n \tparameter_list = process_template_parm (parameter_list,\n+\t\t\t\t\t\tparm_loc,\n \t\t\t\t\t\tparameter,\n \t\t\t\t\t\tis_non_type,\n                                                 is_parameter_pack);\n@@ -15862,7 +15868,8 @@ cp_parser_member_declaration (cp_parser* parser)\n \t\t know it is an anonymous aggregate.  */\n \t      fixup_anonymous_aggr (type);\n \t      /* And make the corresponding data member.  */\n-\t      decl = build_decl (FIELD_DECL, NULL_TREE, type);\n+\t      decl = build_decl (decl_spec_token_start->location,\n+\t\t\t\t FIELD_DECL, NULL_TREE, type);\n \t      /* Add it to the class.  */\n \t      finish_member_declaration (decl);\n \t    }\n@@ -19432,6 +19439,7 @@ cp_parser_objc_selector_expression (cp_parser* parser)\n   tree sel_seq = NULL_TREE;\n   bool maybe_unary_selector_p = true;\n   cp_token *token;\n+  location_t loc = cp_lexer_peek_token (parser->lexer)->location;\n \n   cp_lexer_consume_token (parser->lexer);  /* Eat '@selector'.  */\n   cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\");\n@@ -19483,7 +19491,7 @@ cp_parser_objc_selector_expression (cp_parser* parser)\n  finish_selector:\n   cp_parser_require (parser, CPP_CLOSE_PAREN, \"%<)%>\");\n \n-  return objc_build_selector_expr (sel_seq);\n+  return objc_build_selector_expr (loc, sel_seq);\n }\n \n /* Parse a list of identifiers.\n@@ -20256,6 +20264,7 @@ cp_parser_objc_synchronized_statement (cp_parser *parser) {\n static tree\n cp_parser_objc_throw_statement (cp_parser *parser) {\n   tree expr = NULL_TREE;\n+  location_t loc = cp_lexer_peek_token (parser->lexer)->location;\n \n   cp_parser_require_keyword (parser, RID_AT_THROW, \"%<@throw%>\");\n \n@@ -20264,7 +20273,7 @@ cp_parser_objc_throw_statement (cp_parser *parser) {\n \n   cp_parser_consume_semicolon_at_end_of_statement (parser);\n \n-  return objc_build_throw_stmt (expr);\n+  return objc_build_throw_stmt (loc, expr);\n }\n \n /* Parse an Objective-C statement.  */\n@@ -20418,7 +20427,7 @@ cp_parser_omp_var_list_no_open (cp_parser *parser, enum omp_clause_code kind,\n \tcp_parser_name_lookup_error (parser, name, decl, NULL, token->location);\n       else if (kind != 0)\n \t{\n-\t  tree u = build_omp_clause (kind);\n+\t  tree u = build_omp_clause (token->location, kind);\n \t  OMP_CLAUSE_DECL (u) = decl;\n \t  OMP_CLAUSE_CHAIN (u) = list;\n \t  list = u;\n@@ -20496,7 +20505,7 @@ cp_parser_omp_clause_collapse (cp_parser *parser, tree list, location_t location\n     }\n \n   check_no_duplicate_clause (list, OMP_CLAUSE_COLLAPSE, \"collapse\", location);\n-  c = build_omp_clause (OMP_CLAUSE_COLLAPSE);\n+  c = build_omp_clause (loc, OMP_CLAUSE_COLLAPSE);\n   OMP_CLAUSE_CHAIN (c) = list;\n   OMP_CLAUSE_COLLAPSE_EXPR (c) = num;\n \n@@ -20554,7 +20563,7 @@ cp_parser_omp_clause_default (cp_parser *parser, tree list, location_t location)\n     return list;\n \n   check_no_duplicate_clause (list, OMP_CLAUSE_DEFAULT, \"default\", location);\n-  c = build_omp_clause (OMP_CLAUSE_DEFAULT);\n+  c = build_omp_clause (location, OMP_CLAUSE_DEFAULT);\n   OMP_CLAUSE_CHAIN (c) = list;\n   OMP_CLAUSE_DEFAULT_KIND (c) = kind;\n \n@@ -20582,7 +20591,7 @@ cp_parser_omp_clause_if (cp_parser *parser, tree list, location_t location)\n \n   check_no_duplicate_clause (list, OMP_CLAUSE_IF, \"if\", location);\n \n-  c = build_omp_clause (OMP_CLAUSE_IF);\n+  c = build_omp_clause (location, OMP_CLAUSE_IF);\n   OMP_CLAUSE_IF_EXPR (c) = t;\n   OMP_CLAUSE_CHAIN (c) = list;\n \n@@ -20600,7 +20609,7 @@ cp_parser_omp_clause_nowait (cp_parser *parser ATTRIBUTE_UNUSED,\n \n   check_no_duplicate_clause (list, OMP_CLAUSE_NOWAIT, \"nowait\", location);\n \n-  c = build_omp_clause (OMP_CLAUSE_NOWAIT);\n+  c = build_omp_clause (location, OMP_CLAUSE_NOWAIT);\n   OMP_CLAUSE_CHAIN (c) = list;\n   return c;\n }\n@@ -20628,7 +20637,7 @@ cp_parser_omp_clause_num_threads (cp_parser *parser, tree list,\n   check_no_duplicate_clause (list, OMP_CLAUSE_NUM_THREADS,\n \t\t\t     \"num_threads\", location);\n \n-  c = build_omp_clause (OMP_CLAUSE_NUM_THREADS);\n+  c = build_omp_clause (location, OMP_CLAUSE_NUM_THREADS);\n   OMP_CLAUSE_NUM_THREADS_EXPR (c) = t;\n   OMP_CLAUSE_CHAIN (c) = list;\n \n@@ -20647,7 +20656,7 @@ cp_parser_omp_clause_ordered (cp_parser *parser ATTRIBUTE_UNUSED,\n   check_no_duplicate_clause (list, OMP_CLAUSE_ORDERED,\n \t\t\t     \"ordered\", location);\n \n-  c = build_omp_clause (OMP_CLAUSE_ORDERED);\n+  c = build_omp_clause (location, OMP_CLAUSE_ORDERED);\n   OMP_CLAUSE_CHAIN (c) = list;\n   return c;\n }\n@@ -20729,7 +20738,7 @@ cp_parser_omp_clause_schedule (cp_parser *parser, tree list, location_t location\n   if (!cp_parser_require (parser, CPP_OPEN_PAREN, \"%<(%>\"))\n     return list;\n \n-  c = build_omp_clause (OMP_CLAUSE_SCHEDULE);\n+  c = build_omp_clause (location, OMP_CLAUSE_SCHEDULE);\n \n   if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n     {\n@@ -20817,7 +20826,7 @@ cp_parser_omp_clause_untied (cp_parser *parser ATTRIBUTE_UNUSED,\n \n   check_no_duplicate_clause (list, OMP_CLAUSE_UNTIED, \"untied\", location);\n \n-  c = build_omp_clause (OMP_CLAUSE_UNTIED);\n+  c = build_omp_clause (location, OMP_CLAUSE_UNTIED);\n   OMP_CLAUSE_CHAIN (c) = list;\n   return c;\n }\n@@ -21110,7 +21119,7 @@ cp_parser_omp_critical (cp_parser *parser, cp_token *pragma_tok)\n   cp_parser_require_pragma_eol (parser, pragma_tok);\n \n   stmt = cp_parser_omp_structured_block (parser);\n-  return c_finish_omp_critical (stmt, name);\n+  return c_finish_omp_critical (input_location, stmt, name);\n }\n \n /* OpenMP 2.5:\n@@ -21487,7 +21496,7 @@ cp_parser_omp_for_loop (cp_parser *parser, tree clauses, tree *par_clauses)\n \t      {\n \t\t/* Add lastprivate (decl) clause to OMP_FOR_CLAUSES,\n \t\t   change it to shared (decl) in OMP_PARALLEL_CLAUSES.  */\n-\t\ttree l = build_omp_clause (OMP_CLAUSE_LASTPRIVATE);\n+\t\ttree l = build_omp_clause (loc, OMP_CLAUSE_LASTPRIVATE);\n \t\tOMP_CLAUSE_DECL (l) = real_decl;\n \t\tOMP_CLAUSE_CHAIN (l) = clauses;\n \t\tCP_OMP_CLAUSE_INFO (l) = CP_OMP_CLAUSE_INFO (*c);\n@@ -21525,7 +21534,7 @@ cp_parser_omp_for_loop (cp_parser *parser, tree clauses, tree *par_clauses)\n \t    }\n \t  if (c == NULL)\n \t    {\n-\t      c = build_omp_clause (OMP_CLAUSE_PRIVATE);\n+\t      c = build_omp_clause (loc, OMP_CLAUSE_PRIVATE);\n \t      OMP_CLAUSE_DECL (c) = decl;\n \t      c = finish_omp_clauses (c);\n \t      if (c)\n@@ -21692,7 +21701,8 @@ static tree\n cp_parser_omp_master (cp_parser *parser, cp_token *pragma_tok)\n {\n   cp_parser_require_pragma_eol (parser, pragma_tok);\n-  return c_finish_omp_master (cp_parser_omp_structured_block (parser));\n+  return c_finish_omp_master (input_location,\n+\t\t\t      cp_parser_omp_structured_block (parser));\n }\n \n /* OpenMP 2.5:\n@@ -21702,8 +21712,9 @@ cp_parser_omp_master (cp_parser *parser, cp_token *pragma_tok)\n static tree\n cp_parser_omp_ordered (cp_parser *parser, cp_token *pragma_tok)\n {\n+  location_t loc = cp_lexer_peek_token (parser->lexer)->location;\n   cp_parser_require_pragma_eol (parser, pragma_tok);\n-  return c_finish_omp_ordered (cp_parser_omp_structured_block (parser));\n+  return c_finish_omp_ordered (loc, cp_parser_omp_structured_block (parser));\n }\n \n /* OpenMP 2.5:\n@@ -21838,6 +21849,7 @@ cp_parser_omp_parallel (cp_parser *parser, cp_token *pragma_tok)\n   tree stmt, clauses, par_clause, ws_clause, block;\n   unsigned int mask = OMP_PARALLEL_CLAUSE_MASK;\n   unsigned int save;\n+  location_t loc = cp_lexer_peek_token (parser->lexer)->location;\n \n   if (cp_lexer_next_token_is_keyword (parser->lexer, RID_FOR))\n     {\n@@ -21873,12 +21885,12 @@ cp_parser_omp_parallel (cp_parser *parser, cp_token *pragma_tok)\n       break;\n \n     case PRAGMA_OMP_PARALLEL_FOR:\n-      c_split_parallel_clauses (clauses, &par_clause, &ws_clause);\n+      c_split_parallel_clauses (loc, clauses, &par_clause, &ws_clause);\n       cp_parser_omp_for_loop (parser, ws_clause, &par_clause);\n       break;\n \n     case PRAGMA_OMP_PARALLEL_SECTIONS:\n-      c_split_parallel_clauses (clauses, &par_clause, &ws_clause);\n+      c_split_parallel_clauses (loc, clauses, &par_clause, &ws_clause);\n       stmt = cp_parser_omp_sections_scope (parser);\n       if (stmt)\n \tOMP_SECTIONS_CLAUSES (stmt) = ws_clause;"}, {"sha": "7fe40122566079f1b224ec97c185d5fde05b2433", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -383,7 +383,8 @@ push_inline_template_parms_recursive (tree parmlist, int levels)\n \t       It is ugly that we recreate this here; the original\n \t       version built in process_template_parm is no longer\n \t       available.  */\n-\t    tree decl = build_decl (CONST_DECL, DECL_NAME (parm),\n+\t    tree decl = build_decl (DECL_SOURCE_LOCATION (parm),\n+\t\t\t\t    CONST_DECL, DECL_NAME (parm),\n \t\t\t\t    TREE_TYPE (parm));\n \t    DECL_ARTIFICIAL (decl) = 1;\n \t    TREE_CONSTANT (decl) = 1;\n@@ -2931,7 +2932,8 @@ reduce_template_parm_level (tree index, tree type, int levels, tree args,\n       tree orig_decl = TEMPLATE_PARM_DECL (index);\n       tree decl, t;\n \n-      decl = build_decl (TREE_CODE (orig_decl), DECL_NAME (orig_decl), type);\n+      decl = build_decl (DECL_SOURCE_LOCATION (orig_decl),\n+\t\t\t TREE_CODE (orig_decl), DECL_NAME (orig_decl), type);\n       TREE_CONSTANT (decl) = TREE_CONSTANT (orig_decl);\n       TREE_READONLY (decl) = TREE_READONLY (orig_decl);\n       DECL_ARTIFICIAL (decl) = 1;\n@@ -2958,10 +2960,11 @@ reduce_template_parm_level (tree index, tree type, int levels, tree args,\n /* Process information from new template parameter PARM and append it to the\n    LIST being built.  This new parameter is a non-type parameter iff\n    IS_NON_TYPE is true. This new parameter is a parameter\n-   pack iff IS_PARAMETER_PACK is true.  */\n+   pack iff IS_PARAMETER_PACK is true.  The location of PARM is in \n+   PARM_LOC.  */\n \n tree\n-process_template_parm (tree list, tree parm, bool is_non_type, \n+process_template_parm (tree list, location_t parm_loc, tree parm, bool is_non_type, \n                        bool is_parameter_pack)\n {\n   tree decl = 0;\n@@ -3030,7 +3033,8 @@ process_template_parm (tree list, tree parm, bool is_non_type,\n       /* A template parameter is not modifiable.  */\n       TREE_CONSTANT (parm) = 1;\n       TREE_READONLY (parm) = 1;\n-      decl = build_decl (CONST_DECL, DECL_NAME (parm), TREE_TYPE (parm));\n+      decl = build_decl (parm_loc,\n+\t\t\t CONST_DECL, DECL_NAME (parm), TREE_TYPE (parm));\n       TREE_CONSTANT (decl) = 1;\n       TREE_READONLY (decl) = 1;\n       DECL_INITIAL (parm) = DECL_INITIAL (decl)\n@@ -3059,7 +3063,8 @@ process_template_parm (tree list, tree parm, bool is_non_type,\n \t{\n \t  t = cxx_make_type (TEMPLATE_TYPE_PARM);\n \t  /* parm is either IDENTIFIER_NODE or NULL_TREE.  */\n-\t  decl = build_decl (TYPE_DECL, parm, t);\n+\t  decl = build_decl (parm_loc,\n+\t\t\t     TYPE_DECL, parm, t);\n \t}\n \n       TYPE_NAME (t) = decl;\n@@ -8112,7 +8117,8 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t    TREE_CHAIN (r) = NULL_TREE;\n \t    TREE_TYPE (r) = new_type;\n \t    DECL_TEMPLATE_RESULT (r)\n-\t      = build_decl (TYPE_DECL, DECL_NAME (decl), new_type);\n+\t      = build_decl (DECL_SOURCE_LOCATION (decl),\n+\t\t\t    TYPE_DECL, DECL_NAME (decl), new_type);\n \t    DECL_TEMPLATE_PARMS (r)\n \t      = tsubst_template_parms (DECL_TEMPLATE_PARMS (t), args,\n \t\t\t\t       complain);\n@@ -10605,7 +10611,7 @@ tsubst_omp_for_iterator (tree t, int i, tree declv, tree initv,\n \t}\n       if (c == NULL)\n \t{\n-\t  c = build_omp_clause (OMP_CLAUSE_PRIVATE);\n+\t  c = build_omp_clause (input_location, OMP_CLAUSE_PRIVATE);\n \t  OMP_CLAUSE_DECL (c) = decl;\n \t  c = finish_omp_clauses (c);\n \t  if (c)\n@@ -10890,7 +10896,8 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n       break;\n \n     case CASE_LABEL_EXPR:\n-      finish_case_label (RECUR (CASE_LOW (t)),\n+      finish_case_label (EXPR_LOCATION (t),\n+\t\t\t RECUR (CASE_LOW (t)),\n \t\t\t RECUR (CASE_HIGH (t)));\n       break;\n \n@@ -17150,7 +17157,8 @@ make_auto (void)\n \n   /* ??? Is it worth caching this for multiple autos at the same level?  */\n   au = cxx_make_type (TEMPLATE_TYPE_PARM);\n-  TYPE_NAME (au) = build_decl (TYPE_DECL, get_identifier (\"auto\"), au);\n+  TYPE_NAME (au) = build_decl (BUILTINS_LOCATION,\n+\t\t\t       TYPE_DECL, get_identifier (\"auto\"), au);\n   TYPE_STUB_DECL (au) = TYPE_NAME (au);\n   TEMPLATE_TYPE_PARM_INDEX (au) = build_template_parm_index\n     (0, processing_template_decl + 1, processing_template_decl + 1,"}, {"sha": "c26caa9cb3dcdcc4e303b4a0c59d2c2bf50691a8", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 28, "deletions": 14, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -1161,7 +1161,8 @@ create_pseudo_type_info (int tk, const char *real_name, ...)\n     sprintf (pseudo_name + strlen (pseudo_name), \"%d\", tk - TK_FIXED);\n \n   /* First field is the pseudo type_info base class.  */\n-  fields = build_decl (FIELD_DECL, NULL_TREE,\n+  fields = build_decl (input_location,\n+\t\t       FIELD_DECL, NULL_TREE,\n \t\t       VEC_index (tinfo_s, tinfo_descs,\n \t\t\t\t  TK_TYPE_INFO_TYPE)->type);\n \n@@ -1290,9 +1291,12 @@ get_pseudo_ti_index (tree type)\n \t      push_abi_namespace ();\n \t      create_pseudo_type_info\n \t\t(ix, \"__vmi_class_type_info\",\n-\t\t build_decl (FIELD_DECL, NULL_TREE, integer_type_node),\n-\t\t build_decl (FIELD_DECL, NULL_TREE, integer_type_node),\n-\t\t build_decl (FIELD_DECL, NULL_TREE, base_array),\n+\t\t build_decl (input_location,\n+\t\t\t     FIELD_DECL, NULL_TREE, integer_type_node),\n+\t\t build_decl (input_location,\n+\t\t\t     FIELD_DECL, NULL_TREE, integer_type_node),\n+\t\t build_decl (input_location,\n+\t\t\t     FIELD_DECL, NULL_TREE, base_array),\n \t\t NULL);\n \t      pop_abi_namespace ();\n \t      break;\n@@ -1324,10 +1328,12 @@ create_tinfo_types (void)\n   {\n     tree field, fields;\n \n-    field = build_decl (FIELD_DECL, NULL_TREE, const_ptr_type_node);\n+    field = build_decl (BUILTINS_LOCATION,\n+\t\t\tFIELD_DECL, NULL_TREE, const_ptr_type_node);\n     fields = field;\n \n-    field = build_decl (FIELD_DECL, NULL_TREE, const_string_type_node);\n+    field = build_decl (BUILTINS_LOCATION,\n+\t\t\tFIELD_DECL, NULL_TREE, const_string_type_node);\n     TREE_CHAIN (field) = fields;\n     fields = field;\n \n@@ -1353,18 +1359,21 @@ create_tinfo_types (void)\n   /* Single public non-virtual base class. Add pointer to base class.\n      This is really a descendant of __class_type_info.  */\n   create_pseudo_type_info (TK_SI_CLASS_TYPE, \"__si_class_type_info\",\n-\t    build_decl (FIELD_DECL, NULL_TREE, type_info_ptr_type),\n+\t    build_decl (BUILTINS_LOCATION,\n+\t\t\tFIELD_DECL, NULL_TREE, type_info_ptr_type),\n \t    NULL);\n \n   /* Base class internal helper. Pointer to base type, offset to base,\n      flags.  */\n   {\n     tree field, fields;\n \n-    field = build_decl (FIELD_DECL, NULL_TREE, type_info_ptr_type);\n+    field = build_decl (BUILTINS_LOCATION,\n+\t\t\tFIELD_DECL, NULL_TREE, type_info_ptr_type);\n     fields = field;\n \n-    field = build_decl (FIELD_DECL, NULL_TREE, integer_types[itk_long]);\n+    field = build_decl (BUILTINS_LOCATION,\n+\t\t\tFIELD_DECL, NULL_TREE, integer_types[itk_long]);\n     TREE_CHAIN (field) = fields;\n     fields = field;\n \n@@ -1381,18 +1390,23 @@ create_tinfo_types (void)\n      and pointer to the pointed to type.  This is really a descendant of\n      __pbase_type_info.  */\n   create_pseudo_type_info (TK_POINTER_TYPE, \"__pointer_type_info\",\n-       build_decl (FIELD_DECL, NULL_TREE, integer_type_node),\n-       build_decl (FIELD_DECL, NULL_TREE, type_info_ptr_type),\n+       build_decl (BUILTINS_LOCATION, \n+\t\t   FIELD_DECL, NULL_TREE, integer_type_node),\n+       build_decl (BUILTINS_LOCATION,\n+\t\t   FIELD_DECL, NULL_TREE, type_info_ptr_type),\n        NULL);\n \n   /* Pointer to member data type_info.  Add qualifications flags,\n      pointer to the member's type info and pointer to the class.\n      This is really a descendant of __pbase_type_info.  */\n   create_pseudo_type_info (TK_POINTER_MEMBER_TYPE,\n        \"__pointer_to_member_type_info\",\n-\tbuild_decl (FIELD_DECL, NULL_TREE, integer_type_node),\n-\tbuild_decl (FIELD_DECL, NULL_TREE, type_info_ptr_type),\n-\tbuild_decl (FIELD_DECL, NULL_TREE, type_info_ptr_type),\n+\tbuild_decl (BUILTINS_LOCATION,\n+\t\t    FIELD_DECL, NULL_TREE, integer_type_node),\n+\tbuild_decl (BUILTINS_LOCATION,\n+\t\t    FIELD_DECL, NULL_TREE, type_info_ptr_type),\n+\tbuild_decl (BUILTINS_LOCATION,\n+\t\t    FIELD_DECL, NULL_TREE, type_info_ptr_type),\n \tNULL);\n \n   pop_abi_namespace ();"}, {"sha": "bacb09a12621bbc7f6807cf5a78db2cf4faf3278", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -420,7 +420,7 @@ maybe_cleanup_point_expr_void (tree expr)\n void\n add_decl_expr (tree decl)\n {\n-  tree r = build_stmt (DECL_EXPR, decl);\n+  tree r = build_stmt (input_location, DECL_EXPR, decl);\n   if (DECL_INITIAL (decl)\n       || (DECL_SIZE (decl) && TREE_SIDE_EFFECTS (DECL_SIZE (decl))))\n     r = maybe_cleanup_point_expr_void (r);\n@@ -441,7 +441,7 @@ do_poplevel (tree stmt_list)\n \n   if (!processing_template_decl)\n     {\n-      stmt_list = c_build_bind_expr (block, stmt_list);\n+      stmt_list = c_build_bind_expr (input_location, block, stmt_list);\n       /* ??? See c_end_compound_stmt re statement expressions.  */\n     }\n \n@@ -466,7 +466,7 @@ do_pushlevel (scope_kind sk)\n void\n push_cleanup (tree decl, tree cleanup, bool eh_only)\n {\n-  tree stmt = build_stmt (CLEANUP_STMT, NULL, cleanup, decl);\n+  tree stmt = build_stmt (input_location, CLEANUP_STMT, NULL, cleanup, decl);\n   CLEANUP_EH_ONLY (stmt) = eh_only;\n   add_stmt (stmt);\n   CLEANUP_BODY (stmt) = push_stmt_list ();\n@@ -561,7 +561,7 @@ finish_goto_stmt (tree destination)\n \n   check_goto (destination);\n \n-  return add_stmt (build_stmt (GOTO_EXPR, destination));\n+  return add_stmt (build_stmt (input_location, GOTO_EXPR, destination));\n }\n \n /* COND is the condition-expression for an if, while, etc.,\n@@ -624,7 +624,7 @@ finish_expr_stmt (tree expr)\n       if (TREE_CODE (expr) != CLEANUP_POINT_EXPR)\n \t{\n \t  if (TREE_CODE (expr) != EXPR_STMT)\n-\t    expr = build_stmt (EXPR_STMT, expr);\n+\t    expr = build_stmt (input_location, EXPR_STMT, expr);\n \t  expr = maybe_cleanup_point_expr_void (expr);\n \t}\n \n@@ -645,7 +645,7 @@ begin_if_stmt (void)\n {\n   tree r, scope;\n   scope = do_pushlevel (sk_block);\n-  r = build_stmt (IF_STMT, NULL_TREE, NULL_TREE, NULL_TREE);\n+  r = build_stmt (input_location, IF_STMT, NULL_TREE, NULL_TREE, NULL_TREE);\n   TREE_CHAIN (r) = scope;\n   begin_cond (&IF_COND (r));\n   return r;\n@@ -707,7 +707,7 @@ tree\n begin_while_stmt (void)\n {\n   tree r;\n-  r = build_stmt (WHILE_STMT, NULL_TREE, NULL_TREE);\n+  r = build_stmt (input_location, WHILE_STMT, NULL_TREE, NULL_TREE);\n   add_stmt (r);\n   WHILE_BODY (r) = do_pushlevel (sk_block);\n   begin_cond (&WHILE_COND (r));\n@@ -739,7 +739,7 @@ finish_while_stmt (tree while_stmt)\n tree\n begin_do_stmt (void)\n {\n-  tree r = build_stmt (DO_STMT, NULL_TREE, NULL_TREE);\n+  tree r = build_stmt (input_location, DO_STMT, NULL_TREE, NULL_TREE);\n   add_stmt (r);\n   DO_BODY (r) = push_stmt_list ();\n   return r;\n@@ -801,7 +801,7 @@ finish_return_stmt (tree expr)\n \t}\n     }\n \n-  r = build_stmt (RETURN_EXPR, expr);\n+  r = build_stmt (input_location, RETURN_EXPR, expr);\n   TREE_NO_WARNING (r) |= no_warning;\n   r = maybe_cleanup_point_expr_void (r);\n   r = add_stmt (r);\n@@ -817,7 +817,7 @@ begin_for_stmt (void)\n {\n   tree r;\n \n-  r = build_stmt (FOR_STMT, NULL_TREE, NULL_TREE,\n+  r = build_stmt (input_location, FOR_STMT, NULL_TREE, NULL_TREE,\n \t\t  NULL_TREE, NULL_TREE);\n \n   if (flag_new_for_scope > 0)\n@@ -908,15 +908,15 @@ finish_for_stmt (tree for_stmt)\n tree\n finish_break_stmt (void)\n {\n-  return add_stmt (build_stmt (BREAK_STMT));\n+  return add_stmt (build_stmt (input_location, BREAK_STMT));\n }\n \n /* Finish a continue-statement.  */\n \n tree\n finish_continue_stmt (void)\n {\n-  return add_stmt (build_stmt (CONTINUE_STMT));\n+  return add_stmt (build_stmt (input_location, CONTINUE_STMT));\n }\n \n /* Begin a switch-statement.  Returns a new SWITCH_STMT if\n@@ -927,7 +927,7 @@ begin_switch_stmt (void)\n {\n   tree r, scope;\n \n-  r = build_stmt (SWITCH_STMT, NULL_TREE, NULL_TREE, NULL_TREE);\n+  r = build_stmt (input_location, SWITCH_STMT, NULL_TREE, NULL_TREE, NULL_TREE);\n \n   scope = do_pushlevel (sk_block);\n   TREE_CHAIN (r) = scope;\n@@ -997,7 +997,7 @@ finish_switch_stmt (tree switch_stmt)\n tree\n begin_try_block (void)\n {\n-  tree r = build_stmt (TRY_BLOCK, NULL_TREE, NULL_TREE);\n+  tree r = build_stmt (input_location, TRY_BLOCK, NULL_TREE, NULL_TREE);\n   add_stmt (r);\n   TRY_STMTS (r) = push_stmt_list ();\n   return r;\n@@ -1087,7 +1087,7 @@ begin_handler (void)\n {\n   tree r;\n \n-  r = build_stmt (HANDLER, NULL_TREE, NULL_TREE);\n+  r = build_stmt (input_location, HANDLER, NULL_TREE, NULL_TREE);\n   add_stmt (r);\n \n   /* Create a binding level for the eh_info and the exception object\n@@ -1307,7 +1307,7 @@ finish_asm_stmt (int volatile_p, tree string, tree output_operands,\n \t}\n     }\n \n-  r = build_stmt (ASM_EXPR, string,\n+  r = build_stmt (input_location, ASM_EXPR, string,\n \t\t  output_operands, input_operands,\n \t\t  clobbers);\n   ASM_VOLATILE_P (r) = volatile_p || noutputs == 0;\n@@ -1325,7 +1325,7 @@ finish_label_stmt (tree name)\n   if (decl == error_mark_node)\n     return error_mark_node;\n \n-  add_stmt (build_stmt (LABEL_EXPR, decl));\n+  add_stmt (build_stmt (input_location, LABEL_EXPR, decl));\n \n   return decl;\n }\n@@ -1718,7 +1718,7 @@ finish_stmt_expr_expr (tree expr, tree stmt_expr)\n \n       if (processing_template_decl)\n \t{\n-\t  expr = build_stmt (EXPR_STMT, expr);\n+\t  expr = build_stmt (input_location, EXPR_STMT, expr);\n \t  expr = add_stmt (expr);\n \t  /* Mark the last statement so that we can recognize it as such at\n \t     template-instantiation time.  */\n@@ -1990,7 +1990,7 @@ finish_call_expr (tree fn, VEC(tree,gc) **args, bool disallow_virtual,\n       if (TREE_CODE (fn) == FUNCTION_DECL\n \t  && (DECL_BUILT_IN_CLASS (fn) == BUILT_IN_NORMAL\n \t      || DECL_BUILT_IN_CLASS (fn) == BUILT_IN_MD))\n-\tresult = resolve_overloaded_builtin (fn, *args);\n+\tresult = resolve_overloaded_builtin (input_location, fn, *args);\n \n       if (!result)\n \t/* A call to a namespace-scope function.  */\n@@ -2137,7 +2137,7 @@ finish_unary_op_expr (enum tree_code code, tree expr)\n       TREE_NEGATED_INT (result) = 1;\n     }\n   if (TREE_OVERFLOW_P (result) && !TREE_OVERFLOW_P (expr))\n-    overflow_warning (result);\n+    overflow_warning (input_location, result);\n \n   return result;\n }\n@@ -2250,7 +2250,8 @@ finish_template_type_parm (tree aggr, tree identifier)\n tree\n finish_template_template_parm (tree aggr, tree identifier)\n {\n-  tree decl = build_decl (TYPE_DECL, identifier, NULL_TREE);\n+  tree decl = build_decl (input_location,\n+\t\t\t  TYPE_DECL, identifier, NULL_TREE);\n   tree tmpl = build_lang_decl (TEMPLATE_DECL, identifier, NULL_TREE);\n   DECL_TEMPLATE_PARMS (tmpl) = current_template_parms;\n   DECL_TEMPLATE_RESULT (tmpl) = decl;\n@@ -3330,7 +3331,7 @@ finalize_nrv_r (tree* tp, int* walk_subtrees, void* data)\n \tinit = build2 (INIT_EXPR, void_type_node, dp->result,\n \t\t       DECL_INITIAL (dp->var));\n       else\n-\tinit = build_empty_stmt ();\n+\tinit = build_empty_stmt (EXPR_LOCATION (*tp));\n       DECL_INITIAL (dp->var) = NULL_TREE;\n       SET_EXPR_LOCUS (init, EXPR_LOCUS (*tp));\n       *tp = init;\n@@ -4136,7 +4137,7 @@ handle_omp_for_class_iterator (int i, location_t locus, tree declv, tree initv,\n \t\t\t     TREE_CODE (cond), decl, diff,\n \t\t\t     tf_warning_or_error);\n   incr = build_modify_expr (elocus, decl, NULL_TREE, PLUS_EXPR,\n-\t\t\t    incr, NULL_TREE);\n+\t\t\t    elocus, incr, NULL_TREE);\n \n   orig_body = *body;\n   *body = push_stmt_list ();\n@@ -4427,7 +4428,7 @@ finish_omp_atomic (enum tree_code code, tree lhs, tree rhs)\n     }\n   if (!dependent_p)\n     {\n-      stmt = c_finish_omp_atomic (code, lhs, rhs);\n+      stmt = c_finish_omp_atomic (input_location, code, lhs, rhs);\n       if (stmt == error_mark_node)\n \treturn;\n     }"}, {"sha": "7c48a3257b33b51f19ae483c2b64b5bc448fa9b6", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -302,7 +302,8 @@ build_target_expr (tree decl, tree value)\n static tree\n build_local_temp (tree type)\n {\n-  tree slot = build_decl (VAR_DECL, NULL_TREE, type);\n+  tree slot = build_decl (input_location,\n+\t\t\t  VAR_DECL, NULL_TREE, type);\n   DECL_ARTIFICIAL (slot) = 1;\n   DECL_IGNORED_P (slot) = 1;\n   DECL_CONTEXT (slot) = current_function_decl;\n@@ -1421,7 +1422,8 @@ bind_template_template_parm (tree t, tree newargs)\n   tree t2;\n \n   t2 = cxx_make_type (BOUND_TEMPLATE_TEMPLATE_PARM);\n-  decl = build_decl (TYPE_DECL, DECL_NAME (decl), NULL_TREE);\n+  decl = build_decl (input_location,\n+\t\t     TYPE_DECL, DECL_NAME (decl), NULL_TREE);\n \n   /* These nodes have to be created to reflect new TYPE_DECL and template\n      arguments.  */"}, {"sha": "1ad75065d6e7da2bddf11858bc3a71cb13bbd3ad", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -1349,7 +1349,7 @@ cxx_sizeof_or_alignof_type (tree type, enum tree_code op, bool complain)\n       return value;\n     }\n \n-  return c_sizeof_or_alignof_type (complete_type (type),\n+  return c_sizeof_or_alignof_type (input_location, complete_type (type),\n \t\t\t\t   op == SIZEOF_EXPR,\n \t\t\t\t   complain);\n }\n@@ -2573,7 +2573,7 @@ cp_build_indirect_ref (tree ptr, const char *errorstring,\n    LOC is the location to use in building the array reference.  */\n \n tree\n-build_array_ref (tree array, tree idx, location_t loc)\n+build_array_ref (location_t loc, tree array, tree idx)\n {\n   tree ret;\n \n@@ -2593,7 +2593,7 @@ build_array_ref (tree array, tree idx, location_t loc)\n     {\n     case COMPOUND_EXPR:\n       {\n-\ttree value = build_array_ref (TREE_OPERAND (array, 1), idx, loc);\n+\ttree value = build_array_ref (loc, TREE_OPERAND (array, 1), idx);\n \tret = build2 (COMPOUND_EXPR, TREE_TYPE (value),\n \t\t      TREE_OPERAND (array, 0), value);\n \tSET_EXPR_LOCATION (ret, loc);\n@@ -2603,9 +2603,9 @@ build_array_ref (tree array, tree idx, location_t loc)\n     case COND_EXPR:\n       ret = build_conditional_expr\n \t      (TREE_OPERAND (array, 0),\n-\t      build_array_ref (TREE_OPERAND (array, 1), idx, loc),\n-\t      build_array_ref (TREE_OPERAND (array, 2), idx, loc),\n-\t      tf_warning_or_error);\n+\t       build_array_ref (loc, TREE_OPERAND (array, 1), idx),\n+\t       build_array_ref (loc, TREE_OPERAND (array, 2), idx),\n+\t       tf_warning_or_error);\n       protected_set_expr_location (ret, loc);\n       return ret;\n \n@@ -2864,14 +2864,16 @@ get_member_function_from_ptrfunc (tree *instance_ptrptr, tree function)\n \n /* Used by the C-common bits.  */\n tree\n-build_function_call (tree function, tree params)\n+build_function_call (location_t loc ATTRIBUTE_UNUSED, \n+\t\t     tree function, tree params)\n {\n   return cp_build_function_call (function, params, tf_warning_or_error);\n }\n \n /* Used by the C-common bits.  */\n tree\n-build_function_call_vec (tree function, VEC(tree,gc) *params,\n+build_function_call_vec (location_t loc ATTRIBUTE_UNUSED,\n+\t\t\t tree function, VEC(tree,gc) *params,\n \t\t\t VEC(tree,gc) *origtypes ATTRIBUTE_UNUSED)\n {\n   VEC(tree,gc) *orig_params = params;\n@@ -4067,7 +4069,7 @@ cp_build_binary_op (location_t location,\n   if (TREE_OVERFLOW_P (result) \n       && !TREE_OVERFLOW_P (op0) \n       && !TREE_OVERFLOW_P (op1))\n-    overflow_warning (result);\n+    overflow_warning (location, result);\n \n   return result;\n }\n@@ -5079,7 +5081,7 @@ build_x_compound_expr (tree op1, tree op2, tsubst_flags_t complain)\n /* Like cp_build_compound_expr, but for the c-common bits.  */\n \n tree\n-build_compound_expr (tree lhs, tree rhs)\n+build_compound_expr (location_t loc ATTRIBUTE_UNUSED, tree lhs, tree rhs)\n {\n   return cp_build_compound_expr (lhs, rhs, tf_warning_or_error);\n }\n@@ -5836,7 +5838,7 @@ build_const_cast (tree type, tree expr, tsubst_flags_t complain)\n /* Like cp_build_c_cast, but for the c-common bits.  */\n \n tree\n-build_c_cast (tree type, tree expr)\n+build_c_cast (location_t loc ATTRIBUTE_UNUSED, tree type, tree expr)\n {\n   return cp_build_c_cast (type, expr, tf_warning_or_error);\n }\n@@ -5953,7 +5955,8 @@ cp_build_c_cast (tree type, tree expr, tsubst_flags_t complain)\n tree\n build_modify_expr (location_t location ATTRIBUTE_UNUSED,\n \t\t   tree lhs, tree lhs_origtype ATTRIBUTE_UNUSED,\n-\t\t   enum tree_code modifycode, tree rhs,\n+\t\t   enum tree_code modifycode, \n+\t\t   location_t rhs_location ATTRIBUTE_UNUSED, tree rhs,\n \t\t   tree rhs_origtype ATTRIBUTE_UNUSED)\n {\n   return cp_build_modify_expr (lhs, modifycode, rhs, tf_warning_or_error);\n@@ -6501,7 +6504,7 @@ build_ptrmemfunc (tree type, tree pfn, int force, bool c_cast_p)\n   /* Handle null pointer to member function conversions.  */\n   if (integer_zerop (pfn))\n     {\n-      pfn = build_c_cast (type, integer_zero_node);\n+      pfn = build_c_cast (input_location, type, integer_zero_node);\n       return build_ptrmemfunc1 (to_type,\n \t\t\t\tinteger_zero_node,\n \t\t\t\tpfn);"}, {"sha": "8bec2217189e40b8873ffbc377db0aec3f79da5f", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -516,7 +516,7 @@ split_nonconstant_init_1 (tree dest, tree init)\n \t\t\t      NULL_TREE);\n \n \t      code = build2 (INIT_EXPR, inner_type, sub, value);\n-\t      code = build_stmt (EXPR_STMT, code);\n+\t      code = build_stmt (input_location, EXPR_STMT, code);\n \t      add_stmt (code);\n \t      continue;\n \t    }\n@@ -530,7 +530,7 @@ split_nonconstant_init_1 (tree dest, tree init)\n \t  tree cons = copy_node (init);\n \t  CONSTRUCTOR_ELTS (init) = NULL;\n \t  code = build2 (MODIFY_EXPR, type, dest, cons);\n-\t  code = build_stmt (EXPR_STMT, code);\n+\t  code = build_stmt (input_location, EXPR_STMT, code);\n \t  add_stmt (code);\n \t}\n       break;"}, {"sha": "fcd87185018b046cc311574f427cd9e3c1f27dcb", "filename": "gcc/dwarf2asm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fdwarf2asm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fdwarf2asm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2asm.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -871,7 +871,7 @@ dw2_output_indirect_constant_1 (splay_tree_node node,\n   sym = (const char *) node->key;\n   id = (tree) node->value;\n \n-  decl = build_decl (VAR_DECL, id, ptr_type_node);\n+  decl = build_decl (UNKNOWN_LOCATION, VAR_DECL, id, ptr_type_node);\n   DECL_ARTIFICIAL (decl) = 1;\n   DECL_IGNORED_P (decl) = 1;\n   DECL_INITIAL (decl) = decl;"}, {"sha": "e452c28c2a5f606281df0cf97c962eec3af0ae39", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -2242,7 +2242,8 @@ get_spill_slot_decl (bool force_build_p)\n   if (d || !force_build_p)\n     return d;\n \n-  d = build_decl (VAR_DECL, get_identifier (\"%sfp\"), void_type_node);\n+  d = build_decl (DECL_SOURCE_LOCATION (current_function_decl),\n+\t\t  VAR_DECL, get_identifier (\"%sfp\"), void_type_node);\n   DECL_ARTIFICIAL (d) = 1;\n   DECL_IGNORED_P (d) = 1;\n   TREE_USED (d) = 1;"}, {"sha": "8ec252bbab33022174c535a24ccbd17d5d22cc3c", "filename": "gcc/except.c", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -221,26 +221,31 @@ init_eh (void)\n \n       sjlj_fc_type_node = lang_hooks.types.make_type (RECORD_TYPE);\n \n-      f_prev = build_decl (FIELD_DECL, get_identifier (\"__prev\"),\n+      f_prev = build_decl (DECL_SOURCE_LOCATION (current_function_decl),\n+\t\t\t   FIELD_DECL, get_identifier (\"__prev\"),\n \t\t\t   build_pointer_type (sjlj_fc_type_node));\n       DECL_FIELD_CONTEXT (f_prev) = sjlj_fc_type_node;\n \n-      f_cs = build_decl (FIELD_DECL, get_identifier (\"__call_site\"),\n+      f_cs = build_decl (DECL_SOURCE_LOCATION (current_function_decl),\n+\t\t\t FIELD_DECL, get_identifier (\"__call_site\"),\n \t\t\t integer_type_node);\n       DECL_FIELD_CONTEXT (f_cs) = sjlj_fc_type_node;\n \n       tmp = build_index_type (build_int_cst (NULL_TREE, 4 - 1));\n       tmp = build_array_type (lang_hooks.types.type_for_mode\n \t\t\t\t(targetm.unwind_word_mode (), 1),\n \t\t\t      tmp);\n-      f_data = build_decl (FIELD_DECL, get_identifier (\"__data\"), tmp);\n+      f_data = build_decl (DECL_SOURCE_LOCATION (current_function_decl),\n+\t\t\t   FIELD_DECL, get_identifier (\"__data\"), tmp);\n       DECL_FIELD_CONTEXT (f_data) = sjlj_fc_type_node;\n \n-      f_per = build_decl (FIELD_DECL, get_identifier (\"__personality\"),\n+      f_per = build_decl (DECL_SOURCE_LOCATION (current_function_decl),\n+\t\t\t  FIELD_DECL, get_identifier (\"__personality\"),\n \t\t\t  ptr_type_node);\n       DECL_FIELD_CONTEXT (f_per) = sjlj_fc_type_node;\n \n-      f_lsda = build_decl (FIELD_DECL, get_identifier (\"__lsda\"),\n+      f_lsda = build_decl (DECL_SOURCE_LOCATION (current_function_decl),\n+\t\t\t   FIELD_DECL, get_identifier (\"__lsda\"),\n \t\t\t   ptr_type_node);\n       DECL_FIELD_CONTEXT (f_lsda) = sjlj_fc_type_node;\n \n@@ -260,7 +265,8 @@ init_eh (void)\n #endif\n       tmp = build_index_type (tmp);\n       tmp = build_array_type (ptr_type_node, tmp);\n-      f_jbuf = build_decl (FIELD_DECL, get_identifier (\"__jbuf\"), tmp);\n+      f_jbuf = build_decl (DECL_SOURCE_LOCATION (current_function_decl),\n+\t\t\t   FIELD_DECL, get_identifier (\"__jbuf\"), tmp);\n #ifdef DONT_USE_BUILTIN_SETJMP\n       /* We don't know what the alignment requirements of the\n \t runtime's jmp_buf has.  Overestimate.  */"}, {"sha": "321d5f6918d094b051d48d9cb3ddc77cfc6e1f90", "filename": "gcc/expmed.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -5076,7 +5076,7 @@ make_tree (tree type, rtx x)\n       /* else fall through.  */\n \n     default:\n-      t = build_decl (VAR_DECL, NULL_TREE, type);\n+      t = build_decl (RTL_LOCATION (x), VAR_DECL, NULL_TREE, type);\n \n       /* If TYPE is a POINTER_TYPE, X might be Pmode with TYPE_MODE being\n \t ptr_mode.  So convert.  */"}, {"sha": "ec1800e63a20192f4521f259d4135d8910e9a68f", "filename": "gcc/expr.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -1424,7 +1424,7 @@ init_block_move_fn (const char *asmspec)\n \t\t\t\t       const_ptr_type_node, sizetype,\n \t\t\t\t       NULL_TREE);\n \n-      fn = build_decl (FUNCTION_DECL, fn, args);\n+      fn = build_decl (UNKNOWN_LOCATION, FUNCTION_DECL, fn, args);\n       DECL_EXTERNAL (fn) = 1;\n       TREE_PUBLIC (fn) = 1;\n       DECL_ARTIFICIAL (fn) = 1;\n@@ -2714,7 +2714,7 @@ init_block_clear_fn (const char *asmspec)\n \t\t\t\t       integer_type_node, sizetype,\n \t\t\t\t       NULL_TREE);\n \n-      fn = build_decl (FUNCTION_DECL, fn, args);\n+      fn = build_decl (UNKNOWN_LOCATION, FUNCTION_DECL, fn, args);\n       DECL_EXTERNAL (fn) = 1;\n       TREE_PUBLIC (fn) = 1;\n       DECL_ARTIFICIAL (fn) = 1;\n@@ -5498,7 +5498,8 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t\t    expand_normal (hi_index);\n \t\t    unsignedp = TYPE_UNSIGNED (domain);\n \n-\t\t    index = build_decl (VAR_DECL, NULL_TREE, domain);\n+\t\t    index = build_decl (EXPR_LOCATION (exp),\n+\t\t\t\t\tVAR_DECL, NULL_TREE, domain);\n \n \t\t    index_r\n \t\t      = gen_reg_rtx (promote_mode (domain, DECL_MODE (index),\n@@ -7537,7 +7538,8 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t       with non-BLKmode values.  */\n \t    gcc_assert (GET_MODE (ret) != BLKmode);\n \n-\t    val = build_decl (VAR_DECL, NULL, TREE_TYPE (exp));\n+\t    val = build_decl (EXPR_LOCATION (exp),\n+\t\t\t      VAR_DECL, NULL, TREE_TYPE (exp));\n \t    DECL_ARTIFICIAL (val) = 1;\n \t    DECL_IGNORED_P (val) = 1;\n \t    TREE_OPERAND (exp, 0) = val;"}, {"sha": "ea0de36e862076cb15bf689db23b19c47bae9d4f", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -1,3 +1,59 @@\n+2009-06-12  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* trans-array.c (gfc_trans_allocate_array_storage): Pass\n+\tlocation on down.\n+\t(gfc_trans_array_constructor_value): Same.\n+\t(gfc_trans_scalarized_loop_end): Same.\n+\t(gfc_conv_ss_startstride): Same.\n+\t(gfc_trans_g77_array): Same.\n+\t(gfc_trans_dummy_array_bias): Same.\n+\t(gfc_conv_array_parameter): Same.\n+\t(structure_alloc_comps): Same.\n+\t* trans-expr.c (gfc_conv_function_call): Same.\n+\t(fill_with_spaces): Same.\n+\t(gfc_trans_string_copy): Same.\n+\t(gfc_trans_scalar_assign): Same.\n+\t* trans-stmt.c (gfc_trans_goto): Same.\n+\t(gfc_trans_if_1): Same.\n+\t(gfc_trans_simple_do): Same.\n+\t(gfc_trans_do): Same.\n+\t(gfc_trans_do_while): Same.\n+\t(gfc_trans_logical_select): Same.\n+\t(gfc_trans_select): Same.\n+\t(gfc_trans_forall_loop): Same.\n+\t(gfc_trans_nested_forall_loop): Same.\n+\t(generate_loop_for_temp_to_lhs): Same.\n+\t(generate_loop_for_rhs_to_temp): Same.\n+\t(gfc_trans_forall_1): Same.\n+\t(gfc_trans_where_assign): Same.\n+\t(gfc_trans_where_3): Same.\n+\t(gfc_trans_allocate): Same.\n+\t* trans.c (gfc_finish_block): Same.\n+\t(gfc_trans_runtime_check): Same.\n+\t(gfc_call_malloc): Same.\n+\t(gfc_allocate_with_status): Same.\n+\t(gfc_call_free): Same.\n+\t(gfc_deallocate_with_status): Same.\n+\t(gfc_call_realloc): Same.\n+\t(gfc_trans_code): Same.\n+\t* trans-decl.c (gfc_init_default_dt): Same.\n+\t(gfc_generate_constructors): Same.\n+\t* trans-io.c (gfc_trans_io_runtime_check): Same.\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_ctime): Same.\n+\t(gfc_conv_intrinsic_fdate): Same.\n+\t(gfc_conv_intrinsic_ttynam): Same.\n+\t(gfc_conv_intrinsic_minmax): Same.\n+\t(gfc_conv_intrinsic_minmax_char): Same.\n+\t(gfc_conv_intrinsic_anyall): Same.\n+\t(gfc_conv_intrinsic_count): Same.\n+\t(gfc_conv_intrinsic_arith): Same.\n+\t(gfc_conv_intrinsic_minmaxloc): Same.\n+\t(gfc_conv_intrinsic_minmaxval): Same.\n+\t(gfc_conv_intrinsic_rrspacing): Same.\n+\t(gfc_conv_intrinsic_array_transfer): Same.\n+\t(gfc_conv_intrinsic_trim): Same.\n+\t(gfc_conv_intrinsic_repeat): Same.\n+\t\n 2009-06-12  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/40176"}, {"sha": "cf38fc371beedb4e82d8dcc7d7e05721c6217603", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -635,7 +635,8 @@ gfc_trans_allocate_array_storage (stmtblock_t * pre, stmtblock_t * post,\n \t      was_packed = fold_build2 (EQ_EXPR, boolean_type_node,\n \t\t\t\t\tpacked, source_data);\n \t      tmp = gfc_finish_block (&do_copying);\n-\t      tmp = build3_v (COND_EXPR, was_packed, tmp, build_empty_stmt ());\n+\t      tmp = build3_v (COND_EXPR, was_packed, tmp,\n+\t\t\t      build_empty_stmt (input_location));\n \t      gfc_add_expr_to_block (pre, tmp);\n \n \t      tmp = fold_convert (pvoid_type_node, packed);\n@@ -1442,7 +1443,8 @@ gfc_trans_array_constructor_value (stmtblock_t * pblock, tree type,\n \t\t\t\t\t   shadow_loopvar, end));\n \t  tmp = build1_v (GOTO_EXPR, exit_label);\n \t  TREE_USED (exit_label) = 1;\n-\t  tmp = build3_v (COND_EXPR, cond, tmp, build_empty_stmt ());\n+\t  tmp = build3_v (COND_EXPR, cond, tmp,\n+\t\t\t  build_empty_stmt (input_location));\n \t  gfc_add_expr_to_block (&body, tmp);\n \n \t  /* The main loop body.  */\n@@ -2776,12 +2778,13 @@ gfc_trans_scalarized_loop_end (gfc_loopinfo * loop, int n,\n       TREE_TYPE (stmt) = void_type_node;\n       OMP_FOR_BODY (stmt) = loopbody = gfc_finish_block (pbody);\n \n-      OMP_FOR_CLAUSES (stmt) = build_omp_clause (OMP_CLAUSE_SCHEDULE);\n+      OMP_FOR_CLAUSES (stmt) = build_omp_clause (input_location,\n+\t\t\t\t\t\t OMP_CLAUSE_SCHEDULE);\n       OMP_CLAUSE_SCHEDULE_KIND (OMP_FOR_CLAUSES (stmt))\n \t= OMP_CLAUSE_SCHEDULE_STATIC;\n       if (ompws_flags & OMPWS_NOWAIT)\n \tOMP_CLAUSE_CHAIN (OMP_FOR_CLAUSES (stmt))\n-\t  = build_omp_clause (OMP_CLAUSE_NOWAIT);\n+\t  = build_omp_clause (input_location, OMP_CLAUSE_NOWAIT);\n \n       /* Initialize the loopvar.  */\n       TREE_VEC_ELT (init, 0) = build2_v (MODIFY_EXPR, loop->loopvar[n],\n@@ -2818,7 +2821,7 @@ gfc_trans_scalarized_loop_end (gfc_loopinfo * loop, int n,\n \t\t\t loop->loopvar[n], loop->to[n]);\n       tmp = build1_v (GOTO_EXPR, exit_label);\n       TREE_USED (exit_label) = 1;\n-      tmp = build3_v (COND_EXPR, cond, tmp, build_empty_stmt ());\n+      tmp = build3_v (COND_EXPR, cond, tmp, build_empty_stmt (input_location));\n       gfc_add_expr_to_block (&block, tmp);\n \n       /* The main body.  */\n@@ -3337,7 +3340,7 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t      || ss->expr->symtree->n.sym->attr.not_always_present)\n \t    tmp = build3_v (COND_EXPR,\n \t\t\t    gfc_conv_expr_present (ss->expr->symtree->n.sym),\n-\t\t\t    tmp, build_empty_stmt ());\n+\t\t\t    tmp, build_empty_stmt (input_location));\n \n \t  gfc_add_expr_to_block (&block, tmp);\n \n@@ -4391,7 +4394,7 @@ gfc_trans_g77_array (gfc_symbol * sym, tree body)\n   if (sym->attr.optional || sym->attr.not_always_present)\n     {\n       tmp = gfc_conv_expr_present (sym);\n-      stmt = build3_v (COND_EXPR, tmp, stmt, build_empty_stmt ());\n+      stmt = build3_v (COND_EXPR, tmp, stmt, build_empty_stmt (input_location));\n     }\n   \n   gfc_add_expr_to_block (&block, stmt);\n@@ -4675,7 +4678,7 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc, tree body)\n   if (optional_arg)\n     {\n       tmp = gfc_conv_expr_present (sym);\n-      stmt = build3_v (COND_EXPR, tmp, stmt, build_empty_stmt ());\n+      stmt = build3_v (COND_EXPR, tmp, stmt, build_empty_stmt (input_location));\n     }\n   gfc_add_expr_to_block (&block, stmt);\n \n@@ -4704,12 +4707,13 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc, tree body)\n       tmp = build_fold_indirect_ref (dumdesc);\n       tmp = gfc_conv_descriptor_data_get (tmp);\n       tmp = fold_build2 (NE_EXPR, boolean_type_node, tmp, tmpdesc);\n-      stmt = build3_v (COND_EXPR, tmp, stmt, build_empty_stmt ());\n+      stmt = build3_v (COND_EXPR, tmp, stmt, build_empty_stmt (input_location));\n \n       if (optional_arg)\n         {\n           tmp = gfc_conv_expr_present (sym);\n-          stmt = build3_v (COND_EXPR, tmp, stmt, build_empty_stmt ());\n+          stmt = build3_v (COND_EXPR, tmp, stmt,\n+\t\t\t   build_empty_stmt (input_location));\n         }\n       gfc_add_expr_to_block (&block, stmt);\n     }\n@@ -5603,7 +5607,7 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, gfc_ss * ss, int g77,\n \ttmp = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n \t\t\t   gfc_conv_expr_present (sym), tmp);\n \n-      tmp = build3_v (COND_EXPR, tmp, stmt, build_empty_stmt ());\n+      tmp = build3_v (COND_EXPR, tmp, stmt, build_empty_stmt (input_location));\n \n       gfc_add_expr_to_block (&block, tmp);\n       gfc_add_block_to_block (&block, &se->post);\n@@ -5807,7 +5811,8 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \n       tmp = gfc_finish_block (&fnblock);\n       if (null_cond != NULL_TREE)\n-\ttmp = build3_v (COND_EXPR, null_cond, tmp, build_empty_stmt ());\n+\ttmp = build3_v (COND_EXPR, null_cond, tmp,\n+\t\t\tbuild_empty_stmt (input_location));\n \n       return tmp;\n     }"}, {"sha": "f4bbb467bc973506233843383012dd2168fc2b65", "filename": "gcc/fortran/trans-common.c", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ffortran%2Ftrans-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ffortran%2Ftrans-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-common.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -278,8 +278,8 @@ build_field (segment_info *h, tree union_type, record_layout_info rli)\n   unsigned HOST_WIDE_INT desired_align, known_align;\n \n   name = get_identifier (h->sym->name);\n-  field = build_decl (FIELD_DECL, name, h->field);\n-  gfc_set_decl_location (field, &h->sym->declared_at);\n+  field = build_decl (h->sym->declared_at.lb->location,\n+\t\t      FIELD_DECL, name, h->field);\n   known_align = (offset & -offset) * BITS_PER_UNIT;\n   if (known_align == 0 || known_align > BIGGEST_ALIGNMENT)\n     known_align = BIGGEST_ALIGNMENT;\n@@ -349,7 +349,8 @@ build_equiv_decl (tree union_type, bool is_init, bool is_saved)\n     }\n \n   snprintf (name, sizeof (name), \"equiv.%d\", serial++);\n-  decl = build_decl (VAR_DECL, get_identifier (name), union_type);\n+  decl = build_decl (input_location,\n+\t\t     VAR_DECL, get_identifier (name), union_type);\n   DECL_ARTIFICIAL (decl) = 1;\n   DECL_IGNORED_P (decl) = 1;\n \n@@ -412,7 +413,8 @@ build_common_decl (gfc_common_head *com, tree union_type, bool is_init)\n   /* If there is no backend_decl for the common block, build it.  */\n   if (decl == NULL_TREE)\n     {\n-      decl = build_decl (VAR_DECL, get_identifier (com->name), union_type);\n+      decl = build_decl (input_location,\n+\t\t\t VAR_DECL, get_identifier (com->name), union_type);\n       SET_DECL_ASSEMBLER_NAME (decl, gfc_sym_mangled_common_id (com));\n       TREE_PUBLIC (decl) = 1;\n       TREE_STATIC (decl) = 1;\n@@ -527,8 +529,8 @@ get_init_field (segment_info *head, tree union_type, tree *field_init,\n   tmp = build_range_type (gfc_array_index_type,\n \t\t\t  gfc_index_zero_node, tmp);\n   tmp = build_array_type (type, tmp);\n-  field = build_decl (FIELD_DECL, NULL_TREE, tmp);\n-  gfc_set_decl_location (field, &gfc_current_locus);\n+  field = build_decl (gfc_current_locus.lb->location,\n+\t\t      FIELD_DECL, NULL_TREE, tmp);\n \n   known_align = BIGGEST_ALIGNMENT;\n \n@@ -675,9 +677,9 @@ create_common (gfc_common_head *com, segment_info *head, bool saw_equiv)\n     {\n       tree var_decl;\n \n-      var_decl = build_decl (VAR_DECL, DECL_NAME (s->field),\n+      var_decl = build_decl (s->sym->declared_at.lb->location,\n+\t\t\t     VAR_DECL, DECL_NAME (s->field),\n \t\t\t     TREE_TYPE (s->field));\n-      gfc_set_decl_location (var_decl, &s->sym->declared_at);\n       TREE_PUBLIC (var_decl) = TREE_PUBLIC (decl);\n       TREE_STATIC (var_decl) = TREE_STATIC (decl);\n       TREE_USED (var_decl) = TREE_USED (decl);"}, {"sha": "c647e92a3727479a8f000eb0f676767c601dd921", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 64, "deletions": 37, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -203,7 +203,8 @@ gfc_build_label_decl (tree label_id)\n     label_name = NULL;\n \n   /* Build the LABEL_DECL node. Labels have no type.  */\n-  label_decl = build_decl (LABEL_DECL, label_id, void_type_node);\n+  label_decl = build_decl (input_location,\n+\t\t\t   LABEL_DECL, label_id, void_type_node);\n   DECL_CONTEXT (label_decl) = current_function_decl;\n   DECL_MODE (label_decl) = VOIDmode;\n \n@@ -750,7 +751,8 @@ gfc_build_qualified_array (tree decl, gfc_symbol * sym)\n \t\tDECL_IGNORED_P (GFC_TYPE_ARRAY_UBOUND (type, dim)) = 0;\n \t    }\n \t}\n-      TYPE_NAME (type) = type_decl = build_decl (TYPE_DECL, NULL, gtype);\n+      TYPE_NAME (type) = type_decl = build_decl (input_location,\n+\t\t\t\t\t\t TYPE_DECL, NULL, gtype);\n       DECL_ORIGINAL_TYPE (type_decl) = gtype;\n     }\n }\n@@ -842,7 +844,8 @@ gfc_build_dummy_array_decl (gfc_symbol * sym, tree dummy)\n     }\n \n   ASM_FORMAT_PRIVATE_NAME (name, IDENTIFIER_POINTER (DECL_NAME (dummy)), 0);\n-  decl = build_decl (VAR_DECL, get_identifier (name), type);\n+  decl = build_decl (input_location,\n+\t\t     VAR_DECL, get_identifier (name), type);\n \n   DECL_ARTIFICIAL (decl) = 1;\n   TREE_PUBLIC (decl) = 0;\n@@ -892,7 +895,7 @@ gfc_nonlocal_dummy_array_decl (gfc_symbol *sym)\n     return;\n \n   dummy = GFC_DECL_SAVED_DESCRIPTOR (sym->backend_decl);\n-  decl = build_decl (VAR_DECL, DECL_NAME (dummy),\n+  decl = build_decl (input_location, VAR_DECL, DECL_NAME (dummy),\n \t\t     TREE_TYPE (sym->backend_decl));\n   DECL_ARTIFICIAL (decl) = 0;\n   TREE_USED (decl) = 1;\n@@ -926,7 +929,8 @@ gfc_create_string_length (gfc_symbol * sym)\n       /* Also prefix the mangled name.  */\n       strcpy (&name[1], sym->name);\n       name[0] = '.';\n-      length = build_decl (VAR_DECL, get_identifier (name),\n+      length = build_decl (input_location,\n+\t\t\t   VAR_DECL, get_identifier (name),\n \t\t\t   gfc_charlen_type_node);\n       DECL_ARTIFICIAL (length) = 1;\n       TREE_USED (length) = 1;\n@@ -955,9 +959,11 @@ gfc_add_assign_aux_vars (gfc_symbol * sym)\n   decl = sym->backend_decl;\n   gfc_allocate_lang_decl (decl);\n   GFC_DECL_ASSIGN (decl) = 1;\n-  length = build_decl (VAR_DECL, create_tmp_var_name (sym->name),\n+  length = build_decl (input_location,\n+\t\t       VAR_DECL, create_tmp_var_name (sym->name),\n \t\t       gfc_charlen_type_node);\n-  addr = build_decl (VAR_DECL, create_tmp_var_name (sym->name),\n+  addr = build_decl (input_location,\n+\t\t     VAR_DECL, create_tmp_var_name (sym->name),\n \t\t     pvoid_type_node);\n   gfc_finish_var_decl (length, sym);\n   gfc_finish_var_decl (addr, sym);\n@@ -1079,9 +1085,8 @@ gfc_get_symbol_decl (gfc_symbol * sym)\n     length = gfc_create_string_length (sym);\n \n   /* Create the decl for the variable.  */\n-  decl = build_decl (VAR_DECL, gfc_sym_identifier (sym), gfc_sym_type (sym));\n-\n-  gfc_set_decl_location (decl, &sym->declared_at);\n+  decl = build_decl (sym->declared_at.lb->location,\n+\t\t     VAR_DECL, gfc_sym_identifier (sym), gfc_sym_type (sym));\n \n   /* Symbols from modules should have their assembler names mangled.\n      This is done here rather than in gfc_finish_var_decl because it\n@@ -1150,7 +1155,8 @@ gfc_get_symbol_decl (gfc_symbol * sym)\n     {\n       tree span;\n       GFC_DECL_SUBREF_ARRAY_P (decl) = 1;\n-      span = build_decl (VAR_DECL, create_tmp_var_name (\"span\"),\n+      span = build_decl (input_location,\n+\t\t\t VAR_DECL, create_tmp_var_name (\"span\"),\n \t\t\t gfc_array_index_type);\n       gfc_finish_var_decl (span, sym);\n       TREE_STATIC (span) = TREE_STATIC (decl);\n@@ -1222,7 +1228,8 @@ get_proc_pointer_decl (gfc_symbol *sym)\n   if (decl)\n     return decl;\n \n-  decl = build_decl (VAR_DECL, get_identifier (sym->name),\n+  decl = build_decl (input_location,\n+\t\t     VAR_DECL, get_identifier (sym->name),\n \t\t     build_pointer_type (gfc_get_function_type (sym)));\n \n   if ((sym->ns->proc_name\n@@ -1380,7 +1387,8 @@ gfc_get_extern_function_decl (gfc_symbol * sym)\n     }\n \n   type = gfc_get_function_type (sym);\n-  fndecl = build_decl (FUNCTION_DECL, name, type);\n+  fndecl = build_decl (input_location,\n+\t\t       FUNCTION_DECL, name, type);\n \n   SET_DECL_ASSEMBLER_NAME (fndecl, mangled_name);\n   /* If the return type is a pointer, avoid alias issues by setting\n@@ -1461,7 +1469,8 @@ build_function_decl (gfc_symbol * sym)\n \t\t == NAMESPACE_DECL);\n \n   type = gfc_get_function_type (sym);\n-  fndecl = build_decl (FUNCTION_DECL, gfc_sym_identifier (sym), type);\n+  fndecl = build_decl (input_location,\n+\t\t       FUNCTION_DECL, gfc_sym_identifier (sym), type);\n \n   /* Perform name mangling if this is a top level or module procedure.  */\n   if (current_function_decl == NULL_TREE)\n@@ -1505,7 +1514,8 @@ build_function_decl (gfc_symbol * sym)\n \ttype = void_type_node;\n     }\n \n-  result_decl = build_decl (RESULT_DECL, result_decl, type);\n+  result_decl = build_decl (input_location,\n+\t\t\t    RESULT_DECL, result_decl, type);\n   DECL_ARTIFICIAL (result_decl) = 1;\n   DECL_IGNORED_P (result_decl) = 1;\n   DECL_CONTEXT (result_decl) = fndecl;\n@@ -1578,7 +1588,8 @@ create_function_arglist (gfc_symbol * sym)\n   if (sym->attr.entry_master)\n     {\n       type = TREE_VALUE (typelist);\n-      parm = build_decl (PARM_DECL, get_identifier (\"__entry\"), type);\n+      parm = build_decl (input_location,\n+\t\t\t PARM_DECL, get_identifier (\"__entry\"), type);\n       \n       DECL_CONTEXT (parm) = fndecl;\n       DECL_ARG_TYPE (parm) = type;\n@@ -1600,7 +1611,8 @@ create_function_arglist (gfc_symbol * sym)\n \t  tree len_type = TREE_VALUE (TREE_CHAIN (typelist));\n \t  gcc_assert (len_type == gfc_charlen_type_node);\n \n-\t  length = build_decl (PARM_DECL,\n+\t  length = build_decl (input_location,\n+\t\t\t       PARM_DECL,\n \t\t\t       get_identifier (\".__result\"),\n \t\t\t       len_type);\n \t  if (!sym->ts.cl->length)\n@@ -1622,7 +1634,8 @@ create_function_arglist (gfc_symbol * sym)\n \n \t      if (sym->ts.cl->backend_decl == NULL)\n \t\t{\n-\t\t  tree len = build_decl (VAR_DECL,\n+\t\t  tree len = build_decl (input_location,\n+\t\t\t\t\t VAR_DECL,\n \t\t\t\t\t get_identifier (\"..__result\"),\n \t\t\t\t\t gfc_charlen_type_node);\n \t\t  DECL_ARTIFICIAL (len) = 1;\n@@ -1642,7 +1655,8 @@ create_function_arglist (gfc_symbol * sym)\n \t    }\n \t}\n \n-      parm = build_decl (PARM_DECL, get_identifier (\"__result\"), type);\n+      parm = build_decl (input_location,\n+\t\t\t PARM_DECL, get_identifier (\"__result\"), type);\n \n       DECL_CONTEXT (parm) = fndecl;\n       DECL_ARG_TYPE (parm) = TREE_VALUE (typelist);\n@@ -1684,7 +1698,8 @@ create_function_arglist (gfc_symbol * sym)\n \n \t  strcpy (&name[1], f->sym->name);\n \t  name[0] = '_';\n-\t  length = build_decl (PARM_DECL, get_identifier (name), len_type);\n+\t  length = build_decl (input_location,\n+\t\t\t       PARM_DECL, get_identifier (name), len_type);\n \n \t  hidden_arglist = chainon (hidden_arglist, length);\n \t  DECL_CONTEXT (length) = fndecl;\n@@ -1739,7 +1754,8 @@ create_function_arglist (gfc_symbol * sym)\n         type = build_pointer_type (type);\n \n       /* Build the argument declaration.  */\n-      parm = build_decl (PARM_DECL, gfc_sym_identifier (f->sym), type);\n+      parm = build_decl (input_location,\n+\t\t\t PARM_DECL, gfc_sym_identifier (f->sym), type);\n \n       /* Fill in arg stuff.  */\n       DECL_CONTEXT (parm) = fndecl;\n@@ -1929,7 +1945,8 @@ build_entry_thunks (gfc_namespace * ns)\n \t  tree union_decl, field;\n \t  tree master_type = TREE_TYPE (ns->proc_name->backend_decl);\n \n-\t  union_decl = build_decl (VAR_DECL, get_identifier (\"__result\"),\n+\t  union_decl = build_decl (input_location,\n+\t\t\t\t   VAR_DECL, get_identifier (\"__result\"),\n \t\t\t\t   TREE_TYPE (master_type));\n \t  DECL_ARTIFICIAL (union_decl) = 1;\n \t  DECL_EXTERNAL (union_decl) = 0;\n@@ -2144,10 +2161,12 @@ gfc_get_fake_result_decl (gfc_symbol * sym, int parent_flag)\n \t       IDENTIFIER_POINTER (DECL_NAME (this_function_decl)));\n \n       if (!sym->attr.mixed_entry_master && sym->attr.function)\n-\tdecl = build_decl (VAR_DECL, get_identifier (name),\n+\tdecl = build_decl (input_location,\n+\t\t\t   VAR_DECL, get_identifier (name),\n \t\t\t   gfc_sym_type (sym));\n       else\n-\tdecl = build_decl (VAR_DECL, get_identifier (name),\n+\tdecl = build_decl (input_location,\n+\t\t\t   VAR_DECL, get_identifier (name),\n \t\t\t   TREE_TYPE (TREE_TYPE (this_function_decl)));\n       DECL_ARTIFICIAL (decl) = 1;\n       DECL_EXTERNAL (decl) = 0;\n@@ -2207,7 +2226,8 @@ gfc_build_library_function_decl (tree name, tree rettype, int nargs, ...)\n \n   /* Build the function type and decl.  */\n   fntype = build_function_type (rettype, arglist);\n-  fndecl = build_decl (FUNCTION_DECL, name, fntype);\n+  fndecl = build_decl (input_location,\n+\t\t       FUNCTION_DECL, name, fntype);\n \n   /* Mark this decl as external.  */\n   DECL_EXTERNAL (fndecl) = 1;\n@@ -2888,7 +2908,7 @@ gfc_init_default_dt (gfc_symbol * sym, tree body)\n     {\n       present = gfc_conv_expr_present (sym);\n       tmp = build3 (COND_EXPR, TREE_TYPE (tmp), present,\n-\t\t    tmp, build_empty_stmt ());\n+\t\t    tmp, build_empty_stmt (input_location));\n     }\n   gfc_add_expr_to_block (&fnblock, tmp);\n   gfc_free_expr (e);\n@@ -2923,7 +2943,7 @@ init_intent_out_dt (gfc_symbol * proc_sym, tree body)\n \n \t    present = gfc_conv_expr_present (f->sym);\n \t    tmp = build3 (COND_EXPR, TREE_TYPE (tmp), present,\n-\t\t\t  tmp, build_empty_stmt ());\n+\t\t\t  tmp, build_empty_stmt (input_location));\n \n \t    gfc_add_expr_to_block (&fnblock, tmp);\n \t  }\n@@ -3311,7 +3331,8 @@ gfc_trans_use_stmts (gfc_namespace * ns)\n       if (entry->namespace_decl == NULL)\n \t{\n \t  entry->namespace_decl\n-\t    = build_decl (NAMESPACE_DECL,\n+\t    = build_decl (input_location,\n+\t\t\t  NAMESPACE_DECL,\n \t\t\t  get_identifier (use_stmt->module_name),\n \t\t\t  void_type_node);\n \t  DECL_EXTERNAL (entry->namespace_decl) = 1;\n@@ -3488,7 +3509,8 @@ gfc_emit_parameter_debug_info (gfc_symbol *sym)\n     return;\n \n   /* Create the decl for the variable or constant.  */\n-  decl = build_decl (sym->attr.flavor == FL_PARAMETER ? CONST_DECL : VAR_DECL,\n+  decl = build_decl (input_location,\n+\t\t     sym->attr.flavor == FL_PARAMETER ? CONST_DECL : VAR_DECL,\n \t\t     gfc_sym_identifier (sym), gfc_sym_type (sym));\n   if (sym->attr.flavor == FL_PARAMETER)\n     TREE_READONLY (decl) = 1;\n@@ -3875,15 +3897,17 @@ create_main_function (tree fndecl)\n \t\t\t\t   build_pointer_type (pchar_type_node),\n \t\t\t\t   NULL_TREE);\n   main_identifier_node = get_identifier (\"main\");\n-  ftn_main = build_decl (FUNCTION_DECL, main_identifier_node, tmp);\n+  ftn_main = build_decl (input_location, FUNCTION_DECL,\n+      \t\t\t main_identifier_node, tmp);\n   DECL_EXTERNAL (ftn_main) = 0;\n   TREE_PUBLIC (ftn_main) = 1;\n   TREE_STATIC (ftn_main) = 1;\n   DECL_ATTRIBUTES (ftn_main)\n       = tree_cons (get_identifier(\"externally_visible\"), NULL_TREE, NULL_TREE);\n \n   /* Setup the result declaration (for \"return 0\").  */\n-  result_decl = build_decl (RESULT_DECL, NULL_TREE, integer_type_node);\n+  result_decl = build_decl (input_location,\n+\t\t\t    RESULT_DECL, NULL_TREE, integer_type_node);\n   DECL_ARTIFICIAL (result_decl) = 1;\n   DECL_IGNORED_P (result_decl) = 1;\n   DECL_CONTEXT (result_decl) = ftn_main;\n@@ -3897,7 +3921,7 @@ create_main_function (tree fndecl)\n   typelist = TYPE_ARG_TYPES (TREE_TYPE (ftn_main));\n \n   tmp = TREE_VALUE (typelist);\n-  argc = build_decl (PARM_DECL, get_identifier (\"argc\"), tmp);\n+  argc = build_decl (input_location, PARM_DECL, get_identifier (\"argc\"), tmp);\n   DECL_CONTEXT (argc) = ftn_main;\n   DECL_ARG_TYPE (argc) = TREE_VALUE (typelist);\n   TREE_READONLY (argc) = 1;\n@@ -3906,7 +3930,7 @@ create_main_function (tree fndecl)\n \n   typelist = TREE_CHAIN (typelist);\n   tmp = TREE_VALUE (typelist);\n-  argv = build_decl (PARM_DECL, get_identifier (\"argv\"), tmp);\n+  argv = build_decl (input_location, PARM_DECL, get_identifier (\"argv\"), tmp);\n   DECL_CONTEXT (argv) = ftn_main;\n   DECL_ARG_TYPE (argv) = TREE_VALUE (typelist);\n   TREE_READONLY (argv) = 1;\n@@ -4354,10 +4378,12 @@ gfc_generate_constructors (void)\n   type = build_function_type (void_type_node,\n \t\t\t      gfc_chainon_list (NULL_TREE, void_type_node));\n \n-  fndecl = build_decl (FUNCTION_DECL, fnname, type);\n+  fndecl = build_decl (input_location,\n+\t\t       FUNCTION_DECL, fnname, type);\n   TREE_PUBLIC (fndecl) = 1;\n \n-  decl = build_decl (RESULT_DECL, NULL_TREE, void_type_node);\n+  decl = build_decl (input_location,\n+\t\t     RESULT_DECL, NULL_TREE, void_type_node);\n   DECL_ARTIFICIAL (decl) = 1;\n   DECL_IGNORED_P (decl) = 1;\n   DECL_CONTEXT (decl) = fndecl;\n@@ -4378,7 +4404,7 @@ gfc_generate_constructors (void)\n   for (; gfc_static_ctors; gfc_static_ctors = TREE_CHAIN (gfc_static_ctors))\n     {\n       tmp = build_call_expr (TREE_VALUE (gfc_static_ctors), 0);\n-      DECL_SAVED_TREE (fndecl) = build_stmt (EXPR_STMT, tmp);\n+      DECL_SAVED_TREE (fndecl) = build_stmt (input_location, EXPR_STMT, tmp);\n     }\n \n   decl = getdecls ();\n@@ -4426,7 +4452,8 @@ gfc_generate_block_data (gfc_namespace * ns)\n   else\n     id = get_identifier (\"__BLOCK_DATA__\");\n \n-  decl = build_decl (VAR_DECL, id, gfc_array_index_type);\n+  decl = build_decl (input_location,\n+\t\t     VAR_DECL, id, gfc_array_index_type);\n   TREE_PUBLIC (decl) = 1;\n   TREE_STATIC (decl) = 1;\n   DECL_IGNORED_P (decl) = 1;"}, {"sha": "a4d00df7fa711121c2f4f72fe8d2a518792fd1b7", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -3052,7 +3052,8 @@ fill_with_spaces (tree start, tree type, tree size)\n   cond = fold_build2 (LE_EXPR, boolean_type_node, i,\n \t\t      fold_convert (sizetype, integer_zero_node));\n   tmp = build1_v (GOTO_EXPR, exit_label);\n-  tmp = fold_build3 (COND_EXPR, void_type_node, cond, tmp, build_empty_stmt ());\n+  tmp = fold_build3 (COND_EXPR, void_type_node, cond, tmp,\n+\t\t     build_empty_stmt (input_location));\n   gfc_add_expr_to_block (&loop, tmp);\n \n   /* Assignment.  */\n@@ -3205,7 +3206,8 @@ gfc_trans_string_copy (stmtblock_t * block, tree dlength, tree dest,\n \n   /* The whole copy_string function is there.  */\n   tmp = fold_build3 (COND_EXPR, void_type_node, cond2, tmp2, tmp3);\n-  tmp = fold_build3 (COND_EXPR, void_type_node, cond, tmp, build_empty_stmt ());\n+  tmp = fold_build3 (COND_EXPR, void_type_node, cond, tmp,\n+\t\t     build_empty_stmt (input_location));\n   gfc_add_expr_to_block (block, tmp);\n }\n \n@@ -3999,7 +4001,8 @@ gfc_conv_expr_reference (gfc_se * se, gfc_expr * expr)\n     {\n       tree tmp = se->expr;\n       STRIP_TYPE_NOPS (tmp);\n-      var = build_decl (CONST_DECL, NULL, TREE_TYPE (tmp));\n+      var = build_decl (input_location,\n+\t\t\tCONST_DECL, NULL, TREE_TYPE (tmp));\n       DECL_INITIAL (var) = tmp;\n       TREE_STATIC (var) = 1;\n       pushdecl (var);\n@@ -4246,7 +4249,8 @@ gfc_trans_scalar_assign (gfc_se * lse, gfc_se * rse, gfc_typespec ts,\n \t  tmp = gfc_evaluate_now (lse->expr, &lse->pre);\n \t  tmp = gfc_deallocate_alloc_comp (ts.derived, tmp, 0);\n \t  if (r_is_var)\n-\t    tmp = build3_v (COND_EXPR, cond, build_empty_stmt (), tmp);\n+\t    tmp = build3_v (COND_EXPR, cond, build_empty_stmt (input_location),\n+\t\t\t    tmp);\n \t  gfc_add_expr_to_block (&lse->post, tmp);\n \t}\n \n@@ -4261,7 +4265,8 @@ gfc_trans_scalar_assign (gfc_se * lse, gfc_se * rse, gfc_typespec ts,\n       if (r_is_var)\n \t{\n \t  tmp = gfc_copy_alloc_comp (ts.derived, rse->expr, lse->expr, 0);\n-\t  tmp = build3_v (COND_EXPR, cond, build_empty_stmt (), tmp);\n+\t  tmp = build3_v (COND_EXPR, cond, build_empty_stmt (input_location),\n+\t\t\t  tmp);\n \t  gfc_add_expr_to_block (&block, tmp);\n \t}\n     }"}, {"sha": "21694e41b36fb71dc428b7a2db44f08b0832b849", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 30, "deletions": 20, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -693,7 +693,8 @@ gfc_get_intrinsic_lib_fndecl (gfc_intrinsic_map_t * m, gfc_expr * expr)\n     }\n   argtypes = gfc_chainon_list (argtypes, void_type_node);\n   type = build_function_type (gfc_typenode_for_spec (ts), argtypes);\n-  fndecl = build_decl (FUNCTION_DECL, get_identifier (name), type);\n+  fndecl = build_decl (input_location,\n+\t\t       FUNCTION_DECL, get_identifier (name), type);\n \n   /* Mark the decl as external.  */\n   DECL_EXTERNAL (fndecl) = 1;\n@@ -1388,7 +1389,7 @@ gfc_conv_intrinsic_ctime (gfc_se * se, gfc_expr * expr)\n   cond = fold_build2 (GT_EXPR, boolean_type_node,\n \t\t      len, build_int_cst (TREE_TYPE (len), 0));\n   tmp = gfc_call_free (var);\n-  tmp = build3_v (COND_EXPR, cond, tmp, build_empty_stmt ());\n+  tmp = build3_v (COND_EXPR, cond, tmp, build_empty_stmt (input_location));\n   gfc_add_expr_to_block (&se->post, tmp);\n \n   se->expr = var;\n@@ -1426,7 +1427,7 @@ gfc_conv_intrinsic_fdate (gfc_se * se, gfc_expr * expr)\n   cond = fold_build2 (GT_EXPR, boolean_type_node,\n \t\t      len, build_int_cst (TREE_TYPE (len), 0));\n   tmp = gfc_call_free (var);\n-  tmp = build3_v (COND_EXPR, cond, tmp, build_empty_stmt ());\n+  tmp = build3_v (COND_EXPR, cond, tmp, build_empty_stmt (input_location));\n   gfc_add_expr_to_block (&se->post, tmp);\n \n   se->expr = var;\n@@ -1466,7 +1467,7 @@ gfc_conv_intrinsic_ttynam (gfc_se * se, gfc_expr * expr)\n   cond = fold_build2 (GT_EXPR, boolean_type_node,\n \t\t      len, build_int_cst (TREE_TYPE (len), 0));\n   tmp = gfc_call_free (var);\n-  tmp = build3_v (COND_EXPR, cond, tmp, build_empty_stmt ());\n+  tmp = build3_v (COND_EXPR, cond, tmp, build_empty_stmt (input_location));\n   gfc_add_expr_to_block (&se->post, tmp);\n \n   se->expr = var;\n@@ -1551,10 +1552,12 @@ gfc_conv_intrinsic_minmax (gfc_se * se, gfc_expr * expr, enum tree_code op)\n \t  tmp = fold_build2 (TRUTH_OR_EXPR, boolean_type_node, tmp,\n \t\t\t     fold_convert (boolean_type_node, isnan));\n \t}\n-      tmp = build3_v (COND_EXPR, tmp, thencase, build_empty_stmt ());\n+      tmp = build3_v (COND_EXPR, tmp, thencase,\n+\t\t      build_empty_stmt (input_location));\n \n       if (cond != NULL_TREE)\n-\ttmp = build3_v (COND_EXPR, cond, tmp, build_empty_stmt ());\n+\ttmp = build3_v (COND_EXPR, cond, tmp,\n+\t\t\tbuild_empty_stmt (input_location));\n \n       gfc_add_expr_to_block (&se->pre, tmp);\n       argexpr = argexpr->next;\n@@ -1601,7 +1604,7 @@ gfc_conv_intrinsic_minmax_char (gfc_se * se, gfc_expr * expr, int op)\n   cond = fold_build2 (GT_EXPR, boolean_type_node,\n \t\t      len, build_int_cst (TREE_TYPE (len), 0));\n   tmp = gfc_call_free (var);\n-  tmp = build3_v (COND_EXPR, cond, tmp, build_empty_stmt ());\n+  tmp = build3_v (COND_EXPR, cond, tmp, build_empty_stmt (input_location));\n   gfc_add_expr_to_block (&se->post, tmp);\n \n   se->expr = var;\n@@ -1798,7 +1801,7 @@ gfc_conv_intrinsic_anyall (gfc_se * se, gfc_expr * expr, enum tree_code op)\n   gfc_add_block_to_block (&body, &arrayse.pre);\n   tmp = fold_build2 (op, boolean_type_node, arrayse.expr,\n \t\t     build_int_cst (TREE_TYPE (arrayse.expr), 0));\n-  tmp = build3_v (COND_EXPR, tmp, found, build_empty_stmt ());\n+  tmp = build3_v (COND_EXPR, tmp, found, build_empty_stmt (input_location));\n   gfc_add_expr_to_block (&body, tmp);\n   gfc_add_block_to_block (&body, &arrayse.post);\n \n@@ -1865,7 +1868,8 @@ gfc_conv_intrinsic_count (gfc_se * se, gfc_expr * expr)\n   gfc_copy_loopinfo_to_se (&arrayse, &loop);\n   arrayse.ss = arrayss;\n   gfc_conv_expr_val (&arrayse, actual->expr);\n-  tmp = build3_v (COND_EXPR, arrayse.expr, tmp, build_empty_stmt ());\n+  tmp = build3_v (COND_EXPR, arrayse.expr, tmp,\n+\t\t  build_empty_stmt (input_location));\n \n   gfc_add_block_to_block (&body, &arrayse.pre);\n   gfc_add_expr_to_block (&body, tmp);\n@@ -1977,7 +1981,8 @@ gfc_conv_intrinsic_arith (gfc_se * se, gfc_expr * expr, enum tree_code op)\n       /* We enclose the above in if (mask) {...} .  */\n       tmp = gfc_finish_block (&block);\n \n-      tmp = build3_v (COND_EXPR, maskse.expr, tmp, build_empty_stmt ());\n+      tmp = build3_v (COND_EXPR, maskse.expr, tmp,\n+\t\t      build_empty_stmt (input_location));\n     }\n   else\n     tmp = gfc_finish_block (&block);\n@@ -1995,7 +2000,8 @@ gfc_conv_intrinsic_arith (gfc_se * se, gfc_expr * expr, enum tree_code op)\n       gfc_add_block_to_block (&block, &loop.post);\n       tmp = gfc_finish_block (&block);\n \n-      tmp = build3_v (COND_EXPR, maskse.expr, tmp, build_empty_stmt ());\n+      tmp = build3_v (COND_EXPR, maskse.expr, tmp,\n+\t\t      build_empty_stmt (input_location));\n       gfc_add_expr_to_block (&block, tmp);\n       gfc_add_block_to_block (&se->pre, &block);\n     }\n@@ -2266,15 +2272,16 @@ gfc_conv_intrinsic_minmaxloc (gfc_se * se, gfc_expr * expr, enum tree_code op)\n   tmp = fold_build2 (TRUTH_OR_EXPR, boolean_type_node,\n \t\t     fold_build2 (op, boolean_type_node,\n \t\t\t\t  arrayse.expr, limit), tmp);\n-  tmp = build3_v (COND_EXPR, tmp, ifbody, build_empty_stmt ());\n+  tmp = build3_v (COND_EXPR, tmp, ifbody, build_empty_stmt (input_location));\n   gfc_add_expr_to_block (&block, tmp);\n \n   if (maskss)\n     {\n       /* We enclose the above in if (mask) {...}.  */\n       tmp = gfc_finish_block (&block);\n \n-      tmp = build3_v (COND_EXPR, maskse.expr, tmp, build_empty_stmt ());\n+      tmp = build3_v (COND_EXPR, maskse.expr, tmp,\n+\t\t      build_empty_stmt (input_location));\n     }\n   else\n     tmp = gfc_finish_block (&block);\n@@ -2428,14 +2435,15 @@ gfc_conv_intrinsic_minmaxval (gfc_se * se, gfc_expr * expr, enum tree_code op)\n \n   /* If it is a more extreme value.  */\n   tmp = fold_build2 (op, boolean_type_node, arrayse.expr, limit);\n-  tmp = build3_v (COND_EXPR, tmp, ifbody, build_empty_stmt ());\n+  tmp = build3_v (COND_EXPR, tmp, ifbody, build_empty_stmt (input_location));\n   gfc_add_expr_to_block (&block, tmp);\n   gfc_add_block_to_block (&block, &arrayse.post);\n \n   tmp = gfc_finish_block (&block);\n   if (maskss)\n     /* We enclose the above in if (mask) {...}.  */\n-    tmp = build3_v (COND_EXPR, maskse.expr, tmp, build_empty_stmt ());\n+    tmp = build3_v (COND_EXPR, maskse.expr, tmp,\n+\t\t    build_empty_stmt (input_location));\n   gfc_add_expr_to_block (&body, tmp);\n \n   gfc_trans_scalarizing_loops (&loop, &body);\n@@ -2450,7 +2458,8 @@ gfc_conv_intrinsic_minmaxval (gfc_se * se, gfc_expr * expr, enum tree_code op)\n       gfc_add_block_to_block (&block, &loop.post);\n       tmp = gfc_finish_block (&block);\n \n-      tmp = build3_v (COND_EXPR, maskse.expr, tmp, build_empty_stmt ());\n+      tmp = build3_v (COND_EXPR, maskse.expr, tmp,\n+\t\t      build_empty_stmt (input_location));\n       gfc_add_expr_to_block (&block, tmp);\n       gfc_add_block_to_block (&se->pre, &block);\n     }\n@@ -3320,7 +3329,7 @@ gfc_conv_intrinsic_rrspacing (gfc_se * se, gfc_expr * expr)\n \n   cond = fold_build2 (NE_EXPR, boolean_type_node, x,\n \t\t      build_real_from_int_cst (type, integer_zero_node));\n-  tmp = build3_v (COND_EXPR, cond, stmt, build_empty_stmt ());\n+  tmp = build3_v (COND_EXPR, cond, stmt, build_empty_stmt (input_location));\n   gfc_add_expr_to_block (&se->pre, tmp);\n \n   se->expr = fold_convert (type, x);\n@@ -3730,7 +3739,8 @@ gfc_conv_intrinsic_transfer (gfc_se * se, gfc_expr * expr)\n \t  gfc_init_block (&block);\n \t  tmp = gfc_conv_array_data (argse.expr);\n \t  tmp = fold_build2 (NE_EXPR, boolean_type_node, source, tmp);\n-\t  tmp = build3_v (COND_EXPR, tmp, stmt, build_empty_stmt ());\n+\t  tmp = build3_v (COND_EXPR, tmp, stmt,\n+\t\t\t  build_empty_stmt (input_location));\n \t  gfc_add_expr_to_block (&block, tmp);\n \t  gfc_add_block_to_block (&block, &se->post);\n \t  gfc_init_block (&se->post);\n@@ -4221,7 +4231,7 @@ gfc_conv_intrinsic_trim (gfc_se * se, gfc_expr * expr)\n   cond = fold_build2 (GT_EXPR, boolean_type_node,\n \t\t      len, build_int_cst (TREE_TYPE (len), 0));\n   tmp = gfc_call_free (var);\n-  tmp = build3_v (COND_EXPR, cond, tmp, build_empty_stmt ());\n+  tmp = build3_v (COND_EXPR, cond, tmp, build_empty_stmt (input_location));\n   gfc_add_expr_to_block (&se->post, tmp);\n \n   se->expr = var;\n@@ -4312,7 +4322,7 @@ gfc_conv_intrinsic_repeat (gfc_se * se, gfc_expr * expr)\n   tmp = build1_v (GOTO_EXPR, exit_label);\n   TREE_USED (exit_label) = 1;\n   tmp = fold_build3 (COND_EXPR, void_type_node, cond, tmp,\n-\t\t     build_empty_stmt ());\n+\t\t     build_empty_stmt (input_location));\n   gfc_add_expr_to_block (&body, tmp);\n \n   /* Call memmove (dest + (i*slen*size), src, slen*size).  */"}, {"sha": "f8b943d7c0bf52c9c43146df52996cfee90604a2", "filename": "gcc/fortran/trans-io.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -264,7 +264,7 @@ gfc_trans_io_runtime_check (tree cond, tree var, int error_code,\n       cond = build_call_expr (built_in_decls[BUILT_IN_EXPECT], 2, cond, tmp);\n       cond = fold_convert (boolean_type_node, cond);\n \n-      tmp = build3_v (COND_EXPR, cond, body, build_empty_stmt ());\n+      tmp = build3_v (COND_EXPR, cond, body, build_empty_stmt (input_location));\n       gfc_add_expr_to_block (pblock, tmp);\n     }\n }"}, {"sha": "a476487a0a225144619da23fa1a9dcbef8e91fed", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -436,7 +436,7 @@ gfc_trans_omp_variable_list (enum omp_clause_code code, gfc_namelist *namelist,\n \ttree t = gfc_trans_omp_variable (namelist->sym);\n \tif (t != error_mark_node)\n \t  {\n-\t    tree node = build_omp_clause (code);\n+\t    tree node = build_omp_clause (input_location, code);\n \t    OMP_CLAUSE_DECL (node) = t;\n \t    list = gfc_trans_add_clause (node, list);\n \t  }\n@@ -682,7 +682,8 @@ gfc_trans_omp_reduction_list (gfc_namelist *namelist, tree list,\n \ttree t = gfc_trans_omp_variable (namelist->sym);\n \tif (t != error_mark_node)\n \t  {\n-\t    tree node = build_omp_clause (OMP_CLAUSE_REDUCTION);\n+\t    tree node = build_omp_clause (where.lb->location,\n+\t\t\t\t\t  OMP_CLAUSE_REDUCTION);\n \t    OMP_CLAUSE_DECL (node) = t;\n \t    OMP_CLAUSE_REDUCTION_CODE (node) = reduction_code;\n \t    if (namelist->sym->attr.dimension)\n@@ -801,7 +802,7 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n       if_var = gfc_evaluate_now (se.expr, block);\n       gfc_add_block_to_block (block, &se.post);\n \n-      c = build_omp_clause (OMP_CLAUSE_IF);\n+      c = build_omp_clause (where.lb->location, OMP_CLAUSE_IF);\n       OMP_CLAUSE_IF_EXPR (c) = if_var;\n       omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n     }\n@@ -816,7 +817,7 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n       num_threads = gfc_evaluate_now (se.expr, block);\n       gfc_add_block_to_block (block, &se.post);\n \n-      c = build_omp_clause (OMP_CLAUSE_NUM_THREADS);\n+      c = build_omp_clause (where.lb->location, OMP_CLAUSE_NUM_THREADS);\n       OMP_CLAUSE_NUM_THREADS_EXPR (c) = num_threads;\n       omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n     }\n@@ -833,7 +834,7 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \n   if (clauses->sched_kind != OMP_SCHED_NONE)\n     {\n-      c = build_omp_clause (OMP_CLAUSE_SCHEDULE);\n+      c = build_omp_clause (where.lb->location, OMP_CLAUSE_SCHEDULE);\n       OMP_CLAUSE_SCHEDULE_CHUNK_EXPR (c) = chunk_size;\n       switch (clauses->sched_kind)\n \t{\n@@ -860,7 +861,7 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \n   if (clauses->default_sharing != OMP_DEFAULT_UNKNOWN)\n     {\n-      c = build_omp_clause (OMP_CLAUSE_DEFAULT);\n+      c = build_omp_clause (where.lb->location, OMP_CLAUSE_DEFAULT);\n       switch (clauses->default_sharing)\n \t{\n \tcase OMP_DEFAULT_NONE:\n@@ -883,25 +884,25 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \n   if (clauses->nowait)\n     {\n-      c = build_omp_clause (OMP_CLAUSE_NOWAIT);\n+      c = build_omp_clause (where.lb->location, OMP_CLAUSE_NOWAIT);\n       omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n     }\n \n   if (clauses->ordered)\n     {\n-      c = build_omp_clause (OMP_CLAUSE_ORDERED);\n+      c = build_omp_clause (where.lb->location, OMP_CLAUSE_ORDERED);\n       omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n     }\n \n   if (clauses->untied)\n     {\n-      c = build_omp_clause (OMP_CLAUSE_UNTIED);\n+      c = build_omp_clause (where.lb->location, OMP_CLAUSE_UNTIED);\n       omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n     }\n \n   if (clauses->collapse)\n     {\n-      c = build_omp_clause (OMP_CLAUSE_COLLAPSE);\n+      c = build_omp_clause (where.lb->location, OMP_CLAUSE_COLLAPSE);\n       OMP_CLAUSE_COLLAPSE_EXPR (c) = build_int_cst (NULL, clauses->collapse);\n       omp_clauses = gfc_trans_add_clause (c, omp_clauses);\n     }\n@@ -1244,7 +1245,7 @@ gfc_trans_omp_do (gfc_code *code, stmtblock_t *pblock,\n \n       if (!dovar_found)\n \t{\n-\t  tmp = build_omp_clause (OMP_CLAUSE_PRIVATE);\n+\t  tmp = build_omp_clause (input_location, OMP_CLAUSE_PRIVATE);\n \t  OMP_CLAUSE_DECL (tmp) = dovar;\n \t  omp_clauses = gfc_trans_add_clause (tmp, omp_clauses);\n \t}\n@@ -1277,7 +1278,8 @@ gfc_trans_omp_do (gfc_code *code, stmtblock_t *pblock,\n \t\tif (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LASTPRIVATE\n \t\t    && OMP_CLAUSE_DECL (c) == dovar)\n \t\t  {\n-\t\t    tree l = build_omp_clause (OMP_CLAUSE_LASTPRIVATE);\n+\t\t    tree l = build_omp_clause (input_location,\n+\t\t\t\t\t       OMP_CLAUSE_LASTPRIVATE);\n \t\t    OMP_CLAUSE_DECL (l) = dovar;\n \t\t    OMP_CLAUSE_CHAIN (l) = omp_clauses;\n \t\t    OMP_CLAUSE_LASTPRIVATE_STMT (l) = tmp;\n@@ -1290,7 +1292,7 @@ gfc_trans_omp_do (gfc_code *code, stmtblock_t *pblock,\n \t}\n       if (!simple)\n \t{\n-\t  tmp = build_omp_clause (OMP_CLAUSE_PRIVATE);\n+\t  tmp = build_omp_clause (input_location, OMP_CLAUSE_PRIVATE);\n \t  OMP_CLAUSE_DECL (tmp) = count;\n \t  omp_clauses = gfc_trans_add_clause (tmp, omp_clauses);\n \t}\n@@ -1558,7 +1560,7 @@ gfc_trans_omp_workshare (gfc_code *code, gfc_omp_clauses *clauses)\n   pushlevel (0);\n \n   if (!code)\n-    return build_empty_stmt ();\n+    return build_empty_stmt (input_location);\n \n   gfc_start_block (&block);\n   pblock = &block;\n@@ -1681,7 +1683,8 @@ gfc_trans_omp_workshare (gfc_code *code, gfc_omp_clauses *clauses)\n       tmp = gfc_finish_block (&singleblock);\n       tmp = build2 (OMP_SINGLE, void_type_node, tmp,\n \t\t    clauses->nowait\n-\t\t    ? build_omp_clause (OMP_CLAUSE_NOWAIT) : NULL_TREE);\n+\t\t    ? build_omp_clause (input_location, OMP_CLAUSE_NOWAIT)\n+\t\t    : NULL_TREE);\n       gfc_add_expr_to_block (pblock, tmp);\n     }\n "}, {"sha": "0e8ce67c443c485ca0c3e5d3de98594d8b54fbd0", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 27, "deletions": 24, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -175,7 +175,7 @@ gfc_trans_goto (gfc_code * code)\n       tmp = fold_build2 (EQ_EXPR, boolean_type_node, tmp, assigned_goto);\n       tmp = build3_v (COND_EXPR, tmp,\n \t\t      fold_build1 (GOTO_EXPR, void_type_node, target),\n-\t\t      build_empty_stmt ());\n+\t\t      build_empty_stmt (input_location));\n       gfc_add_expr_to_block (&se.pre, tmp);\n       code = code->block;\n     }\n@@ -453,7 +453,7 @@ gfc_trans_call (gfc_code * code, bool dependency_check,\n       if (mask && count1)\n \t{\n \t  tmp = build3_v (COND_EXPR, maskexpr, loopse.expr,\n-\t\t\t  build_empty_stmt ());\n+\t\t\t  build_empty_stmt (input_location));\n \t  gfc_add_expr_to_block (&loopse.pre, tmp);\n \t  tmp = fold_build2 (PLUS_EXPR, gfc_array_index_type,\n \t\t\t     count1, gfc_index_one_node);\n@@ -655,7 +655,7 @@ gfc_trans_if_1 (gfc_code * code)\n   if (code->block)\n     elsestmt = gfc_trans_if_1 (code->block);\n   else\n-    elsestmt = build_empty_stmt ();\n+    elsestmt = build_empty_stmt (input_location);\n \n   /* Build the condition expression and add it to the condition block.  */\n   stmt = fold_build3 (COND_EXPR, void_type_node, if_se.expr, stmt, elsestmt);\n@@ -849,7 +849,7 @@ gfc_trans_simple_do (gfc_code * code, stmtblock_t *pblock, tree dovar,\n   tmp = build1_v (GOTO_EXPR, exit_label);\n   TREE_USED (exit_label) = 1;\n   tmp = fold_build3 (COND_EXPR, void_type_node,\n-\t\t     cond, tmp, build_empty_stmt ());\n+\t\t     cond, tmp, build_empty_stmt (input_location));\n   gfc_add_expr_to_block (&body, tmp);\n \n   /* Finish the loop body.  */\n@@ -862,7 +862,7 @@ gfc_trans_simple_do (gfc_code * code, stmtblock_t *pblock, tree dovar,\n   else\n     cond = fold_build2 (GE_EXPR, boolean_type_node, dovar, to);\n   tmp = fold_build3 (COND_EXPR, void_type_node,\n-\t\t     cond, tmp, build_empty_stmt ());\n+\t\t     cond, tmp, build_empty_stmt (input_location));\n   gfc_add_expr_to_block (pblock, tmp);\n \n   /* Add the exit label.  */\n@@ -1007,7 +1007,7 @@ gfc_trans_do (gfc_code * code)\n       tmp = fold_build2 (LT_EXPR, boolean_type_node, to, from);\n       pos = fold_build3 (COND_EXPR, void_type_node, tmp,\n \t\t\t build1_v (GOTO_EXPR, exit_label),\n-\t\t\t build_empty_stmt ());\n+\t\t\t build_empty_stmt (input_location));\n       tmp = fold_build2 (MINUS_EXPR, type, to, from);\n       tmp = fold_convert (utype, tmp);\n       tmp = fold_build2 (TRUNC_DIV_EXPR, utype, tmp,\n@@ -1018,7 +1018,7 @@ gfc_trans_do (gfc_code * code)\n       tmp = fold_build2 (GT_EXPR, boolean_type_node, to, from);\n       neg = fold_build3 (COND_EXPR, void_type_node, tmp,\n \t\t\t build1_v (GOTO_EXPR, exit_label),\n-\t\t\t build_empty_stmt ());\n+\t\t\t build_empty_stmt (input_location));\n       tmp = fold_build2 (MINUS_EXPR, type, from, to);\n       tmp = fold_convert (utype, tmp);\n       tmp = fold_build2 (TRUNC_DIV_EXPR, utype, tmp,\n@@ -1049,7 +1049,7 @@ gfc_trans_do (gfc_code * code)\n       /* If the loop is empty, go directly to the exit label.  */\n       tmp = fold_build3 (COND_EXPR, void_type_node, tmp,\n \t\t\t build1_v (GOTO_EXPR, exit_label),\n-\t\t\t build_empty_stmt ());\n+\t\t\t build_empty_stmt (input_location));\n       gfc_add_expr_to_block (&block, tmp);\n     }\n \n@@ -1094,7 +1094,7 @@ gfc_trans_do (gfc_code * code)\n \t\t      build_int_cst (utype, 0));\n   tmp = build1_v (GOTO_EXPR, exit_label);\n   tmp = fold_build3 (COND_EXPR, void_type_node,\n-\t\t     cond, tmp, build_empty_stmt ());\n+\t\t     cond, tmp, build_empty_stmt (input_location));\n   gfc_add_expr_to_block (&body, tmp);\n \n   /* Decrement the loop count.  */\n@@ -1168,7 +1168,7 @@ gfc_trans_do_while (gfc_code * code)\n   tmp = build1_v (GOTO_EXPR, exit_label);\n   TREE_USED (exit_label) = 1;\n   tmp = fold_build3 (COND_EXPR, void_type_node,\n-\t\t     cond.expr, tmp, build_empty_stmt ());\n+\t\t     cond.expr, tmp, build_empty_stmt (input_location));\n   gfc_add_expr_to_block (&block, tmp);\n \n   /* The main body of the loop.  */\n@@ -1413,8 +1413,8 @@ gfc_trans_logical_select (gfc_code * code)\n     {\n       tree true_tree, false_tree, stmt;\n \n-      true_tree = build_empty_stmt ();\n-      false_tree = build_empty_stmt ();\n+      true_tree = build_empty_stmt (input_location);\n+      false_tree = build_empty_stmt (input_location);\n \n       /* If we have a case for .TRUE. and for .FALSE., discard the default case.\n           Otherwise, if .TRUE. or .FALSE. is missing and there is a default case,\n@@ -1653,7 +1653,7 @@ gfc_trans_select (gfc_code * code)\n \n   /* Empty SELECT constructs are legal.  */\n   if (code->block == NULL)\n-    return build_empty_stmt ();\n+    return build_empty_stmt (input_location);\n \n   /* Select the correct translation function.  */\n   switch (code->expr1->ts.type)\n@@ -1928,7 +1928,7 @@ gfc_trans_forall_loop (forall_info *forall_tmp, tree body,\n \t\t\t  count, build_int_cst (TREE_TYPE (count), 0));\n       tmp = build1_v (GOTO_EXPR, exit_label);\n       tmp = fold_build3 (COND_EXPR, void_type_node,\n-\t\t\t cond, tmp, build_empty_stmt ());\n+\t\t\t cond, tmp, build_empty_stmt (input_location));\n       gfc_add_expr_to_block (&block, tmp);\n \n       /* The main loop body.  */\n@@ -2010,7 +2010,8 @@ gfc_trans_nested_forall_loop (forall_info * nested_forall_info, tree body,\n           if (mask)\n             {\n               tmp = gfc_build_array_ref (mask, maskindex, NULL);\n-              body = build3_v (COND_EXPR, tmp, body, build_empty_stmt ());\n+              body = build3_v (COND_EXPR, tmp, body,\n+\t\t\t       build_empty_stmt (input_location));\n             }\n         }\n       body = gfc_trans_forall_loop (forall_tmp, body, mask_flag, &header);\n@@ -2146,7 +2147,8 @@ generate_loop_for_temp_to_lhs (gfc_expr *expr, tree tmp1, tree count3,\n \t\t\t\t\t TREE_TYPE (wheremaskexpr),\n \t\t\t\t\t wheremaskexpr);\n \t  tmp = fold_build3 (COND_EXPR, void_type_node,\n-\t\t\t     wheremaskexpr, tmp, build_empty_stmt ());\n+\t\t\t     wheremaskexpr, tmp,\n+\t\t\t     build_empty_stmt (input_location));\n        }\n \n       gfc_add_expr_to_block (&body, tmp);\n@@ -2243,7 +2245,7 @@ generate_loop_for_rhs_to_temp (gfc_expr *expr2, tree tmp1, tree count3,\n \t\t\t\t     TREE_TYPE (wheremaskexpr),\n \t\t\t\t     wheremaskexpr);\n       tmp = fold_build3 (COND_EXPR, void_type_node,\n-\t\t\t wheremaskexpr, tmp, build_empty_stmt ());\n+\t\t\t wheremaskexpr, tmp, build_empty_stmt (input_location));\n     }\n \n   gfc_add_expr_to_block (&body1, tmp);\n@@ -2815,7 +2817,7 @@ gfc_trans_forall_1 (gfc_code * code, forall_info * nested_forall_info)\n   if (code->expr1\n       && code->expr1->expr_type == EXPR_CONSTANT\n       && !code->expr1->value.logical)\n-    return build_empty_stmt ();\n+    return build_empty_stmt (input_location);\n \n   n = 0;\n   /* Count the FORALL index number.  */\n@@ -3372,7 +3374,7 @@ gfc_trans_where_assign (gfc_expr *expr1, gfc_expr *expr2,\n   tmp = gfc_trans_scalar_assign (&lse, &rse, expr1->ts,\n \t\t\t\t loop.temp_ss != NULL, false);\n \n-  tmp = build3_v (COND_EXPR, maskexpr, tmp, build_empty_stmt ());\n+  tmp = build3_v (COND_EXPR, maskexpr, tmp, build_empty_stmt (input_location));\n \n   gfc_add_expr_to_block (&body, tmp);\n \n@@ -3425,7 +3427,8 @@ gfc_trans_where_assign (gfc_expr *expr1, gfc_expr *expr2,\n \n           /* Use the scalar assignment as is.  */\n           tmp = gfc_trans_scalar_assign (&lse, &rse, expr1->ts, false, false);\n-          tmp = build3_v (COND_EXPR, maskexpr, tmp, build_empty_stmt ());\n+          tmp = build3_v (COND_EXPR, maskexpr, tmp,\n+\t\t\t  build_empty_stmt (input_location));\n           gfc_add_expr_to_block (&body, tmp);\n \n           /* Increment count2.  */\n@@ -3832,7 +3835,7 @@ gfc_trans_where_3 (gfc_code * cblock, gfc_code * eblock)\n \n   tstmt = gfc_trans_scalar_assign (&tdse, &tsse, tdst->ts, false, false);\n   estmt = eblock ? gfc_trans_scalar_assign (&edse, &esse, edst->ts, false, false)\n-\t\t : build_empty_stmt ();\n+\t\t : build_empty_stmt (input_location);\n   tmp = build3_v (COND_EXPR, cexpr, tstmt, estmt);\n   gfc_add_expr_to_block (&body, tmp);\n   gfc_add_block_to_block (&body, &cse.post);\n@@ -4011,7 +4014,7 @@ gfc_trans_allocate (gfc_code * code)\n \t      parm = fold_build2 (NE_EXPR, boolean_type_node,\n \t\t\t\t  stat, build_int_cst (TREE_TYPE (stat), 0));\n \t      tmp = fold_build3 (COND_EXPR, void_type_node,\n-\t\t\t\t parm, tmp, build_empty_stmt ());\n+\t\t\t\t parm, tmp, build_empty_stmt (input_location));\n \t      gfc_add_expr_to_block (&se.pre, tmp);\n \t    }\n \n@@ -4066,7 +4069,7 @@ gfc_trans_allocate (gfc_code * code)\n       tmp = fold_build2 (NE_EXPR, boolean_type_node, stat,\n \t\t\t build_int_cst (TREE_TYPE (stat), 0));\n \n-      tmp = build3_v (COND_EXPR, tmp, dlen, build_empty_stmt ());\n+      tmp = build3_v (COND_EXPR, tmp, dlen, build_empty_stmt (input_location));\n \n       gfc_add_expr_to_block (&block, tmp);\n     }\n@@ -4200,7 +4203,7 @@ gfc_trans_deallocate (gfc_code *code)\n       tmp = fold_build2 (NE_EXPR, boolean_type_node, astat,\n \t\t\t build_int_cst (TREE_TYPE (astat), 0));\n \n-      tmp = build3_v (COND_EXPR, tmp, dlen, build_empty_stmt ());\n+      tmp = build3_v (COND_EXPR, tmp, dlen, build_empty_stmt (input_location));\n \n       gfc_add_expr_to_block (&block, tmp);\n     }"}, {"sha": "1785908f8119aa843be1665663479a45d10d6315", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 25, "deletions": 13, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -803,7 +803,8 @@ gfc_init_types (void)\n \n   /* Create and name the types.  */\n #define PUSH_TYPE(name, node) \\\n-  pushdecl (build_decl (TYPE_DECL, get_identifier (name), node))\n+  pushdecl (build_decl (input_location, \\\n+\t\t\tTYPE_DECL, get_identifier (name), node))\n \n   for (index = 0; gfc_integer_kinds[index].kind != 0; ++index)\n     {\n@@ -1241,19 +1242,22 @@ gfc_get_desc_dim_type (void)\n   TYPE_PACKED (type) = 1;\n \n   /* Consists of the stride, lbound and ubound members.  */\n-  decl = build_decl (FIELD_DECL,\n+  decl = build_decl (input_location,\n+\t\t     FIELD_DECL,\n \t\t     get_identifier (\"stride\"), gfc_array_index_type);\n   DECL_CONTEXT (decl) = type;\n   TREE_NO_WARNING (decl) = 1;\n   fieldlist = decl;\n \n-  decl = build_decl (FIELD_DECL,\n+  decl = build_decl (input_location,\n+\t\t     FIELD_DECL,\n \t\t     get_identifier (\"lbound\"), gfc_array_index_type);\n   DECL_CONTEXT (decl) = type;\n   TREE_NO_WARNING (decl) = 1;\n   fieldlist = chainon (fieldlist, decl);\n \n-  decl = build_decl (FIELD_DECL,\n+  decl = build_decl (input_location,\n+\t\t     FIELD_DECL,\n \t\t     get_identifier (\"ubound\"), gfc_array_index_type);\n   DECL_CONTEXT (decl) = type;\n   TREE_NO_WARNING (decl) = 1;\n@@ -1505,7 +1509,8 @@ gfc_get_nodesc_array_type (tree etype, gfc_array_spec * as, gfc_packed packed)\n \t\t\t\t    GFC_TYPE_ARRAY_UBOUND (type, n));\n \t  gtype = build_array_type (gtype, rtype);\n \t}\n-      TYPE_NAME (type) = type_decl = build_decl (TYPE_DECL, NULL, gtype);\n+      TYPE_NAME (type) = type_decl = build_decl (input_location,\n+\t\t\t\t\t\t TYPE_DECL, NULL, gtype);\n       DECL_ORIGINAL_TYPE (type_decl) = gtype;\n     }\n \n@@ -1539,20 +1544,23 @@ gfc_get_array_descriptor_base (int dimen)\n   TYPE_NAME (fat_type) = get_identifier (name);\n \n   /* Add the data member as the first element of the descriptor.  */\n-  decl = build_decl (FIELD_DECL, get_identifier (\"data\"), ptr_type_node);\n+  decl = build_decl (input_location,\n+\t\t     FIELD_DECL, get_identifier (\"data\"), ptr_type_node);\n \n   DECL_CONTEXT (decl) = fat_type;\n   fieldlist = decl;\n \n   /* Add the base component.  */\n-  decl = build_decl (FIELD_DECL, get_identifier (\"offset\"),\n+  decl = build_decl (input_location,\n+\t\t     FIELD_DECL, get_identifier (\"offset\"),\n \t\t     gfc_array_index_type);\n   DECL_CONTEXT (decl) = fat_type;\n   TREE_NO_WARNING (decl) = 1;\n   fieldlist = chainon (fieldlist, decl);\n \n   /* Add the dtype component.  */\n-  decl = build_decl (FIELD_DECL, get_identifier (\"dtype\"),\n+  decl = build_decl (input_location,\n+\t\t     FIELD_DECL, get_identifier (\"dtype\"),\n \t\t     gfc_array_index_type);\n   DECL_CONTEXT (decl) = fat_type;\n   TREE_NO_WARNING (decl) = 1;\n@@ -1565,7 +1573,8 @@ gfc_get_array_descriptor_base (int dimen)\n \t\t\t\t\tgfc_index_zero_node,\n \t\t\t\t\tgfc_rank_cst[dimen - 1]));\n \n-  decl = build_decl (FIELD_DECL, get_identifier (\"dim\"), arraytype);\n+  decl = build_decl (input_location,\n+\t\t     FIELD_DECL, get_identifier (\"dim\"), arraytype);\n   DECL_CONTEXT (decl) = fat_type;\n   TREE_NO_WARNING (decl) = 1;\n   fieldlist = chainon (fieldlist, decl);\n@@ -1803,7 +1812,8 @@ gfc_finish_type (tree type)\n {\n   tree decl;\n \n-  decl = build_decl (TYPE_DECL, NULL_TREE, type);\n+  decl = build_decl (input_location,\n+\t\t     TYPE_DECL, NULL_TREE, type);\n   TYPE_STUB_DECL (type) = decl;\n   layout_type (type);\n   rest_of_type_compilation (type, 1);\n@@ -1822,7 +1832,8 @@ gfc_add_field_to_struct (tree *fieldlist, tree context,\n {\n   tree decl;\n \n-  decl = build_decl (FIELD_DECL, name, type);\n+  decl = build_decl (input_location,\n+\t\t     FIELD_DECL, name, type);\n \n   DECL_CONTEXT (decl) = context;\n   DECL_INITIAL (decl) = 0;\n@@ -2124,7 +2135,8 @@ gfc_get_mixed_entry_union (gfc_namespace *ns)\n \n       if (el == el2)\n \t{\n-\t  decl = build_decl (FIELD_DECL,\n+\t  decl = build_decl (input_location,\n+\t\t\t     FIELD_DECL,\n \t\t\t     get_identifier (el->sym->result->name),\n \t\t\t     gfc_sym_type (el->sym->result));\n \t  DECL_CONTEXT (decl) = type;\n@@ -2411,7 +2423,7 @@ gfc_get_array_descr_info (const_tree type, struct array_descr_info *info)\n   base_decl = GFC_TYPE_ARRAY_BASE_DECL (type, indirect);\n   if (!base_decl)\n     {\n-      base_decl = build_decl (VAR_DECL, NULL_TREE,\n+      base_decl = build_decl (input_location, VAR_DECL, NULL_TREE,\n \t\t\t      indirect ? build_pointer_type (ptype) : ptype);\n       GFC_TYPE_ARRAY_BASE_DECL (type, indirect) = base_decl;\n     }"}, {"sha": "319ae69edcc2d1e804186169105bcce9ac278795", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -238,7 +238,7 @@ gfc_finish_block (stmtblock_t * stmtblock)\n \n   expr = stmtblock->head;\n   if (!expr)\n-    expr = build_empty_stmt ();\n+    expr = build_empty_stmt (input_location);\n \n   stmtblock->head = NULL_TREE;\n \n@@ -485,7 +485,7 @@ gfc_trans_runtime_check (bool error, bool once, tree cond, stmtblock_t * pblock,\n       cond = build_call_expr (built_in_decls[BUILT_IN_EXPECT], 2, cond, tmp);\n       cond = fold_convert (boolean_type_node, cond);\n \n-      tmp = build3_v (COND_EXPR, cond, body, build_empty_stmt ());\n+      tmp = build3_v (COND_EXPR, cond, body, build_empty_stmt (input_location));\n       gfc_add_expr_to_block (pblock, tmp);\n     }\n }\n@@ -516,7 +516,7 @@ gfc_call_malloc (stmtblock_t * block, tree type, tree size)\n       (\"Attempt to allocate a negative amount of memory.\"));\n   tmp = fold_build3 (COND_EXPR, void_type_node, negative,\n \t\t     build_call_expr (gfor_fndecl_runtime_error, 1, msg),\n-\t\t     build_empty_stmt ());\n+\t\t     build_empty_stmt (input_location));\n   gfc_add_expr_to_block (block, tmp);\n \n   /* Call malloc and check the result.  */\n@@ -534,7 +534,7 @@ gfc_call_malloc (stmtblock_t * block, tree type, tree size)\n       (\"Memory allocation failed\"));\n   tmp = fold_build3 (COND_EXPR, void_type_node, null_result,\n \t\t     build_call_expr (gfor_fndecl_os_error, 1, msg),\n-\t\t     build_empty_stmt ());\n+\t\t     build_empty_stmt (input_location));\n   gfc_add_expr_to_block (&block2, tmp);\n   malloc_result = gfc_finish_block (&block2);\n \n@@ -607,7 +607,7 @@ gfc_allocate_with_status (stmtblock_t * block, tree size, tree status)\n       tmp = fold_build3 (COND_EXPR, void_type_node,\n \t\t\t fold_build2 (NE_EXPR, boolean_type_node, status,\n \t\t\t\t      build_int_cst (TREE_TYPE (status), 0)),\n-\t\t\t tmp, build_empty_stmt ());\n+\t\t\t tmp, build_empty_stmt (input_location));\n       gfc_add_expr_to_block (block, tmp);\n     }\n \n@@ -664,7 +664,7 @@ gfc_allocate_with_status (stmtblock_t * block, tree size, tree status)\n   tmp = fold_build3 (COND_EXPR, void_type_node,\n \t\t     fold_build2 (EQ_EXPR, boolean_type_node, res,\n \t\t\t\t  build_int_cst (pvoid_type_node, 0)),\n-\t\t     tmp, build_empty_stmt ());\n+\t\t     tmp, build_empty_stmt (input_location));\n   gfc_add_expr_to_block (&alloc_block, tmp);\n \n   cond = fold_build2 (LT_EXPR, boolean_type_node, size,\n@@ -790,7 +790,7 @@ gfc_call_free (tree var)\n \t\t      build_int_cst (pvoid_type_node, 0));\n   call = build_call_expr (built_in_decls[BUILT_IN_FREE], 1, var);\n   tmp = fold_build3 (COND_EXPR, void_type_node, cond, call,\n-\t\t     build_empty_stmt ());\n+\t\t     build_empty_stmt (input_location));\n   gfc_add_expr_to_block (&block, tmp);\n \n   return gfc_finish_block (&block);\n@@ -854,7 +854,7 @@ gfc_deallocate_with_status (tree pointer, tree status, bool can_fail,\n \t\t\t\t       varname);\n     }\n   else\n-    error = build_empty_stmt ();\n+    error = build_empty_stmt (input_location);\n \n   if (status != NULL_TREE && !integer_zerop (status))\n     {\n@@ -889,7 +889,7 @@ gfc_deallocate_with_status (tree pointer, tree status, bool can_fail,\n \t\t\t fold_build1 (INDIRECT_REF, status_type, status),\n \t\t\t build_int_cst (status_type, 0));\n       tmp = fold_build3 (COND_EXPR, void_type_node, cond2, tmp,\n-\t\t\t build_empty_stmt ());\n+\t\t\t build_empty_stmt (input_location));\n       gfc_add_expr_to_block (&non_null, tmp);\n     }\n \n@@ -936,7 +936,7 @@ gfc_call_realloc (stmtblock_t * block, tree mem, tree size)\n       (\"Attempt to allocate a negative amount of memory.\"));\n   tmp = fold_build3 (COND_EXPR, void_type_node, negative,\n \t\t     build_call_expr (gfor_fndecl_runtime_error, 1, msg),\n-\t\t     build_empty_stmt ());\n+\t\t     build_empty_stmt (input_location));\n   gfc_add_expr_to_block (block, tmp);\n \n   /* Call realloc and check the result.  */\n@@ -953,14 +953,14 @@ gfc_call_realloc (stmtblock_t * block, tree mem, tree size)\n \t\t\t\t\t\t(\"Out of memory\"));\n   tmp = fold_build3 (COND_EXPR, void_type_node, null_result,\n \t\t     build_call_expr (gfor_fndecl_os_error, 1, msg),\n-\t\t     build_empty_stmt ());\n+\t\t     build_empty_stmt (input_location));\n   gfc_add_expr_to_block (block, tmp);\n \n   /* if (size == 0) then the result is NULL.  */\n   tmp = fold_build2 (MODIFY_EXPR, type, res, build_int_cst (type, 0));\n   zero = fold_build1 (TRUTH_NOT_EXPR, boolean_type_node, nonzero);\n   tmp = fold_build3 (COND_EXPR, void_type_node, zero, tmp,\n-\t\t     build_empty_stmt ());\n+\t\t     build_empty_stmt (input_location));\n   gfc_add_expr_to_block (block, tmp);\n \n   return res;\n@@ -1038,7 +1038,7 @@ gfc_trans_code (gfc_code * code)\n   tree res;\n \n   if (!code)\n-    return build_empty_stmt ();\n+    return build_empty_stmt (input_location);\n \n   gfc_start_block (&block);\n \n@@ -1289,10 +1289,9 @@ gfc_generate_module_code (gfc_namespace * ns)\n \n   gcc_assert (ns->proc_name->backend_decl == NULL);\n   ns->proc_name->backend_decl\n-    = build_decl (NAMESPACE_DECL, get_identifier (ns->proc_name->name),\n+    = build_decl (ns->proc_name->declared_at.lb->location,\n+\t\t  NAMESPACE_DECL, get_identifier (ns->proc_name->name),\n \t\t  void_type_node);\n-  gfc_set_decl_location (ns->proc_name->backend_decl,\n-\t\t\t &ns->proc_name->declared_at);\n   entry = gfc_find_module (ns->proc_name->name);\n   if (entry->namespace_decl)\n     /* Buggy sourcecode, using a module before defining it?  */"}, {"sha": "20d7421ccd2f953378e6997de8142ede64cca21a", "filename": "gcc/function.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -2100,7 +2100,8 @@ split_complex_args (tree args)\n \t  layout_decl (p, 0);\n \n \t  /* Build a second synthetic decl.  */\n-\t  decl = build_decl (PARM_DECL, NULL_TREE, subtype);\n+\t  decl = build_decl (EXPR_LOCATION (p),\n+\t\t\t     PARM_DECL, NULL_TREE, subtype);\n \t  DECL_ARG_TYPE (decl) = DECL_ARG_TYPE (p);\n \t  DECL_ARTIFICIAL (decl) = addressable;\n \t  DECL_IGNORED_P (decl) = addressable;\n@@ -2135,7 +2136,8 @@ assign_parms_augmented_arg_list (struct assign_parm_data_all *all)\n       tree type = build_pointer_type (TREE_TYPE (fntype));\n       tree decl;\n \n-      decl = build_decl (PARM_DECL, NULL_TREE, type);\n+      decl = build_decl (DECL_SOURCE_LOCATION (fndecl),\n+\t\t\t PARM_DECL, NULL_TREE, type);\n       DECL_ARG_TYPE (decl) = type;\n       DECL_ARTIFICIAL (decl) = 1;\n       DECL_IGNORED_P (decl) = 1;"}, {"sha": "e096c00dd21d0e383f6017970c4638ac2bc326c0", "filename": "gcc/gimple-low.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fgimple-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fgimple-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-low.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -169,7 +169,7 @@ lower_function_body (void)\n       tree disp_label, disp_var, arg;\n \n       /* Build 'DISP_LABEL:' and insert.  */\n-      disp_label = create_artificial_label ();\n+      disp_label = create_artificial_label (cfun->function_end_locus);\n       /* This mark will create forward edges from every call site.  */\n       DECL_NONLOCAL (disp_label) = 1;\n       cfun->has_nonlocal_label = 1;\n@@ -727,7 +727,7 @@ lower_gimple_return (gimple_stmt_iterator *gsi, struct lower_data *data)\n     }\n \n   /* Not found.  Create a new label and record the return statement.  */\n-  tmp_rs.label = create_artificial_label ();\n+  tmp_rs.label = create_artificial_label (cfun->function_end_locus);\n   tmp_rs.stmt = stmt;\n   VEC_safe_push (return_statements_t, heap, data->return_statements, &tmp_rs);\n \n@@ -797,8 +797,9 @@ static void\n lower_builtin_setjmp (gimple_stmt_iterator *gsi)\n {\n   gimple stmt = gsi_stmt (*gsi);\n-  tree cont_label = create_artificial_label ();\n-  tree next_label = create_artificial_label ();\n+  location_t loc = gimple_location (stmt);\n+  tree cont_label = create_artificial_label (loc);\n+  tree next_label = create_artificial_label (loc);\n   tree dest, t, arg;\n   gimple g;\n "}, {"sha": "84531789f22e49e8f83f527a56284b99b9d0b48f", "filename": "gcc/gimple-pretty-print.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fgimple-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fgimple-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -1379,6 +1379,8 @@ dump_gimple_stmt (pretty_printer *buffer, gimple gs, int spc, int flags)\n \t  pp_string (buffer, \" : \");\n \t}\n       pp_decimal_int (buffer, xloc.line);\n+      pp_string (buffer, \":\");\n+      pp_decimal_int (buffer, xloc.column);\n       pp_string (buffer, \"] \");\n     }\n \n@@ -1730,6 +1732,8 @@ dump_implicit_edges (pretty_printer *buffer, basic_block bb, int indent,\n \t      pp_string (buffer, \" : \");\n \t    }\n \t  pp_decimal_int (buffer, goto_xloc.line);\n+\t  pp_string (buffer, \" : \");\n+\t  pp_decimal_int (buffer, goto_xloc.column);\n \t  pp_string (buffer, \"] \");\n \t}\n "}, {"sha": "15005c379bd59264e57810587f61e8ece96398e6", "filename": "gcc/gimplify.c", "status": "modified", "additions": 33, "deletions": 25, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -516,7 +516,8 @@ create_tmp_var_raw (tree type, const char *prefix)\n   new_type = build_type_variant (type, 0, 0);\n   TYPE_ATTRIBUTES (new_type) = TYPE_ATTRIBUTES (type);\n \n-  tmp_var = build_decl (VAR_DECL, prefix ? create_tmp_var_name (prefix) : NULL,\n+  tmp_var = build_decl (input_location,\n+\t\t\tVAR_DECL, prefix ? create_tmp_var_name (prefix) : NULL,\n \t\t\ttype);\n \n   /* The variable was declared by the compiler.  */\n@@ -1464,7 +1465,7 @@ static enum gimplify_status\n gimplify_loop_expr (tree *expr_p, gimple_seq *pre_p)\n {\n   tree saved_label = gimplify_ctxp->exit_label;\n-  tree start_label = create_artificial_label ();\n+  tree start_label = create_artificial_label (UNKNOWN_LOCATION);\n \n   gimplify_seq_add_stmt (pre_p, gimple_build_label (start_label));\n \n@@ -1654,9 +1655,10 @@ gimplify_switch_expr (tree *expr_p, gimple_seq *pre_p)\n \t    {\n \t      gimple new_default;\n \n-\t      default_case = build3 (CASE_LABEL_EXPR, void_type_node,\n-\t\t\t\t     NULL_TREE, NULL_TREE,\n-\t\t\t\t     create_artificial_label ());\n+\t      default_case\n+\t\t= build3 (CASE_LABEL_EXPR, void_type_node,\n+\t\t\t  NULL_TREE, NULL_TREE,\n+\t\t\t  create_artificial_label (UNKNOWN_LOCATION));\n \t      new_default = gimple_build_label (CASE_LABEL (default_case));\n \t      gimplify_seq_add_stmt (&switch_body_seq, new_default);\n \t    }\n@@ -1707,7 +1709,7 @@ build_and_jump (tree *label_p)\n \n   if (*label_p == NULL_TREE)\n     {\n-      tree label = create_artificial_label ();\n+      tree label = create_artificial_label (UNKNOWN_LOCATION);\n       *label_p = label;\n     }\n \n@@ -1853,7 +1855,7 @@ gimplify_conversion (tree *expr_p)\n {\n   tree tem;\n   gcc_assert (CONVERT_EXPR_P (*expr_p));\n-  \n+\n   /* Then strip away all but the outermost conversion.  */\n   STRIP_SIGN_NOPS (TREE_OPERAND (*expr_p, 0));\n \n@@ -1868,8 +1870,8 @@ gimplify_conversion (tree *expr_p)\n       && POINTER_TYPE_P (TREE_TYPE (*expr_p))\n       && POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (*expr_p, 0)))\n       && (tem = maybe_fold_offset_to_address\n-\t\t  (TREE_OPERAND (*expr_p, 0),\n-\t\t   integer_zero_node, TREE_TYPE (*expr_p))) != NULL_TREE)\n+\t  (EXPR_LOCATION (*expr_p), TREE_OPERAND (*expr_p, 0),\n+\t   integer_zero_node, TREE_TYPE (*expr_p))) != NULL_TREE)\n     *expr_p = tem;\n \n   /* If we still have a conversion at the toplevel,\n@@ -2310,6 +2312,7 @@ gimplify_arg (tree *arg_p, gimple_seq *pre_p, location_t call_location)\n   /* If this is a variable sized type, we must remember the size.  */\n   maybe_with_size_expr (arg_p);\n \n+  /* FIXME diagnostics: This will mess up gcc.dg/Warray-bounds.c.  */\n   /* Make sure arguments have the same location as the function call\n      itself.  */\n   protected_set_expr_location (*arg_p, call_location);\n@@ -2374,13 +2377,13 @@ gimplify_call_expr (tree *expr_p, gimple_seq *pre_p, bool want_value)\n \t  if (call_expr_nargs (*expr_p) < 2)\n \t    {\n \t      error (\"too few arguments to function %<va_start%>\");\n-\t      *expr_p = build_empty_stmt ();\n+\t      *expr_p = build_empty_stmt (EXPR_LOCATION (*expr_p));\n \t      return GS_OK;\n \t    }\n \t  \n \t  if (fold_builtin_next_arg (*expr_p, true))\n \t    {\n-\t      *expr_p = build_empty_stmt ();\n+\t      *expr_p = build_empty_stmt (EXPR_LOCATION (*expr_p));\n \t      return GS_OK;\n \t    }\n \t}\n@@ -3048,7 +3051,7 @@ gimplify_cond_expr (tree *expr_p, gimple_seq *pre_p, fallback_t fallback)\n       have_then_clause_p = true;\n     }\n   else\n-    label_true = create_artificial_label ();\n+    label_true = create_artificial_label (UNKNOWN_LOCATION);\n   if (TREE_OPERAND (expr, 2) != NULL\n       && TREE_CODE (TREE_OPERAND (expr, 2)) == GOTO_EXPR\n       && TREE_CODE (GOTO_DESTINATION (TREE_OPERAND (expr, 2))) == LABEL_DECL\n@@ -3066,7 +3069,7 @@ gimplify_cond_expr (tree *expr_p, gimple_seq *pre_p, fallback_t fallback)\n       have_else_clause_p = true;\n     }\n   else\n-    label_false = create_artificial_label ();\n+    label_false = create_artificial_label (UNKNOWN_LOCATION);\n \n   gimple_cond_get_ops_from_tree (COND_EXPR_COND (expr), &pred_code, &arm1,\n \t\t\t\t &arm2);\n@@ -3097,7 +3100,7 @@ gimplify_cond_expr (tree *expr_p, gimple_seq *pre_p, fallback_t fallback)\n \t      && gimple_seq_may_fallthru (seq))\n \t    {\n \t      gimple g;\n-\t      label_cont = create_artificial_label ();\n+\t      label_cont = create_artificial_label (UNKNOWN_LOCATION);\n \n \t      g = gimple_build_goto (label_cont);\n \n@@ -3380,9 +3383,9 @@ gimplify_init_ctor_eval_range (tree object, tree lower, tree upper,\n   tree loop_entry_label, loop_exit_label, fall_thru_label;\n   tree var, var_type, cref, tmp;\n \n-  loop_entry_label = create_artificial_label ();\n-  loop_exit_label = create_artificial_label ();\n-  fall_thru_label = create_artificial_label ();\n+  loop_entry_label = create_artificial_label (UNKNOWN_LOCATION);\n+  loop_exit_label = create_artificial_label (UNKNOWN_LOCATION);\n+  fall_thru_label = create_artificial_label (UNKNOWN_LOCATION);\n \n   /* Create and initialize the index variable.  */\n   var_type = TREE_TYPE (upper);\n@@ -4479,7 +4482,10 @@ gimplify_modify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n       gimple_call_set_lhs (assign, *to_p);\n     }\n   else\n-    assign = gimple_build_assign (*to_p, *from_p);\n+    {\n+      assign = gimple_build_assign (*to_p, *from_p);\n+      gimple_set_location (assign, EXPR_LOCATION (*expr_p));\n+    }\n \n   gimplify_seq_add_stmt (pre_p, assign);\n \n@@ -5819,7 +5825,7 @@ gimplify_adjust_omp_clauses_1 (splay_tree_node n, void *data)\n   else\n     gcc_unreachable ();\n \n-  clause = build_omp_clause (code);\n+  clause = build_omp_clause (input_location, code);\n   OMP_CLAUSE_DECL (clause) = decl;\n   OMP_CLAUSE_CHAIN (clause) = *list_p;\n   if (private_debug)\n@@ -6969,8 +6975,9 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t   */\n \t  if (TREE_CODE (TREE_OPERAND (*expr_p, 1)) == INTEGER_CST\n \t      && (tmp = maybe_fold_offset_to_address\n-\t\t\t (TREE_OPERAND (*expr_p, 0), TREE_OPERAND (*expr_p, 1),\n-\t\t   \t  TREE_TYPE (*expr_p))))\n+\t\t  (EXPR_LOCATION (*expr_p),\n+\t\t   TREE_OPERAND (*expr_p, 0), TREE_OPERAND (*expr_p, 1),\n+\t\t   TREE_TYPE (*expr_p))))\n \t    {\n \t      *expr_p = tmp;\n \t      break;\n@@ -6981,10 +6988,11 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t      && POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (TREE_OPERAND (*expr_p,\n \t\t\t\t\t\t\t\t\t0),0)))\n \t      && (tmp = maybe_fold_offset_to_address\n-\t\t\t (TREE_OPERAND (TREE_OPERAND (*expr_p, 0), 0),\n-\t\t\t  TREE_OPERAND (*expr_p, 1),\n-\t\t   \t  TREE_TYPE (TREE_OPERAND (TREE_OPERAND (*expr_p, 0),\n-\t\t\t\t\t\t   0)))))\n+\t\t  (EXPR_LOCATION (*expr_p),\n+\t\t   TREE_OPERAND (TREE_OPERAND (*expr_p, 0), 0),\n+\t\t   TREE_OPERAND (*expr_p, 1),\n+\t\t   TREE_TYPE (TREE_OPERAND (TREE_OPERAND (*expr_p, 0),\n+\t\t\t\t\t    0)))))\n \t     {\n                *expr_p = fold_convert (TREE_TYPE (*expr_p), tmp);\n \t       break;"}, {"sha": "199c5855e2eb9664ec05516f2acaaf0be8fbca8c", "filename": "gcc/ipa-struct-reorg.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fipa-struct-reorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fipa-struct-reorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-struct-reorg.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -2178,7 +2178,8 @@ create_new_var_1 (tree orig_decl, d_str str, new_var node)\n       type = gen_struct_type (orig_decl, type); \n \n       if (is_global_var (orig_decl))\n-\tnew_decl = build_decl (VAR_DECL, new_name, type); \n+\tnew_decl = build_decl (DECL_SOURCE_LOCATION (orig_decl),\n+\t\t\t       VAR_DECL, new_name, type); \n       else\n \t{\n \t  const char *name = new_name ? IDENTIFIER_POINTER (new_name) : NULL;"}, {"sha": "b3daaa8e1895a86cdf9473ac7720d32f3422dce5", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -1,3 +1,19 @@\n+2009-06-12  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* java-gimplify.c (java_gimplify_block): New argument to\n+\tbuild_empty_stmt.\n+\t* expr.c (force_evaluation_order): Same.\n+\t* typeck.c: Add location to build_decl or PUSH_FIELD calls.\n+\t* class.c: Same.\n+\t* decl.c: Same.\n+\t* jcf-parse.c: Same.\n+\t* constants.c: Same.\n+\t* resource.c: Same.\n+\t* except.c: Same.\n+\t* builtins.c: Same.\n+\t* expr.c: Same.\n+\t* java-tree.h (PUSH_FIELD): Add location field.\n+\t\n 2009-06-09  Ian Lance Taylor  <iant@google.com>\n \n \t* verify.h: Remove extern \"C\"."}, {"sha": "0f7b197f78c8ba5bdbfd1257058ea57a31f1f902", "filename": "gcc/java/builtins.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fjava%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fjava%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fbuiltins.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -411,7 +411,7 @@ getVolatile_builtin (tree method_return_type ATTRIBUTE_UNUSED,\n   \n   stmt = build_call_expr (built_in_decls[BUILT_IN_SYNCHRONIZE], 0);\n   \n-  tmp = build_decl (VAR_DECL, NULL, method_return_type);\n+  tmp = build_decl (BUILTINS_LOCATION, VAR_DECL, NULL, method_return_type);\n   DECL_IGNORED_P (tmp) = 1;\n   DECL_ARTIFICIAL (tmp) = 1;\n   pushdecl (tmp);\n@@ -453,7 +453,8 @@ define_builtin (enum built_in_function val,\n {\n   tree decl;\n \n-  decl = build_decl (FUNCTION_DECL, get_identifier (name), type);\n+  decl = build_decl (BUILTINS_LOCATION,\n+\t\t     FUNCTION_DECL, get_identifier (name), type);\n   DECL_EXTERNAL (decl) = 1;\n   TREE_PUBLIC (decl) = 1;\n   SET_DECL_ASSEMBLER_NAME (decl, get_identifier (libname));"}, {"sha": "1b594e5ca84b80fea41e4588053bb4186dc5f4e9", "filename": "gcc/java/class.c", "status": "modified", "additions": 63, "deletions": 38, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -420,7 +420,7 @@ do\t\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n   sprintf (buf, #NAME \"_%s\", type_name);\t\t\t\t\\\n   TYPE_## TABLE ##_DECL (type) = decl =\t\t\t\t\t\\\n-    build_decl (VAR_DECL, get_identifier (buf), TABLE_TYPE);\t\t\\\n+    build_decl (input_location, VAR_DECL, get_identifier (buf), TABLE_TYPE); \\\n   DECL_EXTERNAL (decl) = 1;\t\t\t\t\t\t\\\n   TREE_STATIC (decl) = 1;\t\t\t\t\t\t\\\n   TREE_READONLY (decl) = 1;\t\t\t\t\t\t\\\n@@ -432,7 +432,7 @@ do\t\t\t\t\t\t\t\t\t\\\n   DECL_OWNER (decl) = TYPE;\t\t\t\t\t\t\\\n   sprintf (buf, #NAME \"_syms_%s\", type_name);\t\t\t\t\\\n   TYPE_## TABLE ##_SYMS_DECL (TYPE) =\t\t\t\t\t\\\n-    build_decl (VAR_DECL, get_identifier (buf), symbols_array_type);\t\\\n+    build_decl (input_location, VAR_DECL, get_identifier (buf), symbols_array_type); \\\n   TREE_STATIC (TYPE_## TABLE ##_SYMS_DECL (TYPE)) = 1;\t\t\t\\\n   TREE_CONSTANT (TYPE_## TABLE ##_SYMS_DECL (TYPE)) = 1;\t\t\\\n   DECL_IGNORED_P (TYPE_## TABLE ##_SYMS_DECL (TYPE)) = 1;\t\t\\\n@@ -452,12 +452,14 @@ gen_indirect_dispatch_tables (tree type)\n     tree catch_class_type = make_node (RECORD_TYPE);\n \n     sprintf (buf, \"_catch_classes_%s\", type_name);\n-    PUSH_FIELD (catch_class_type, field, \"address\", utf8const_ptr_type);\n-    PUSH_FIELD (catch_class_type, field, \"classname\", ptr_type_node);\n+    PUSH_FIELD (input_location,\n+\t\tcatch_class_type, field, \"address\", utf8const_ptr_type);\n+    PUSH_FIELD (input_location,\n+\t\tcatch_class_type, field, \"classname\", ptr_type_node);\n     FINISH_RECORD (catch_class_type);\n     \n     TYPE_CTABLE_DECL (type) \n-      = build_decl (VAR_DECL, get_identifier (buf),\n+      = build_decl (input_location, VAR_DECL, get_identifier (buf),\n \t\t    build_array_type (catch_class_type, 0));\n     DECL_EXTERNAL (TYPE_CTABLE_DECL (type)) = 1;\n     TREE_STATIC (TYPE_CTABLE_DECL (type)) = 1;\n@@ -483,7 +485,7 @@ push_class (tree class_type, tree class_name)\n   tree decl, signature;\n   location_t saved_loc = input_location;\n   CLASS_P (class_type) = 1;\n-  decl = build_decl (TYPE_DECL, class_name, class_type);\n+  decl = build_decl (input_location, TYPE_DECL, class_name, class_type);\n   TYPE_DECL_SUPPRESS_DEBUG (decl) = 1;\n \n   /* dbxout needs a DECL_SIZE if in gstabs mode */\n@@ -758,7 +760,7 @@ add_method_1 (tree this_class, int access_flags, tree name, tree function_type)\n   method_type = build_java_method_type (function_type,\n \t\t\t\t\tthis_class, access_flags);\n \n-  fndecl = build_decl (FUNCTION_DECL, name, method_type);\n+  fndecl = build_decl (input_location, FUNCTION_DECL, name, method_type);\n   DECL_CONTEXT (fndecl) = this_class;\n \n   DECL_LANG_SPECIFIC (fndecl)\n@@ -844,7 +846,8 @@ add_field (tree klass, tree name, tree field_type, int flags)\n {\n   int is_static = (flags & ACC_STATIC) != 0;\n   tree field;\n-  field = build_decl (is_static ? VAR_DECL : FIELD_DECL, name, field_type);\n+  field = build_decl (input_location,\n+\t\t      is_static ? VAR_DECL : FIELD_DECL, name, field_type);\n   TREE_CHAIN (field) = TYPE_FIELDS (klass);\n   TYPE_FIELDS (klass) = field;\n   DECL_CONTEXT (field) = klass;\n@@ -948,9 +951,10 @@ build_utf8_ref (tree name)\n \t     - (name_len & (TYPE_ALIGN_UNIT (utf8const_type) - 1));\n   str_type = build_prim_array_type (unsigned_byte_type_node,\n \t\t\t\t    name_len + name_pad);\n-  PUSH_FIELD (ctype, field, \"hash\", unsigned_short_type_node);\n-  PUSH_FIELD (ctype, field, \"length\", unsigned_short_type_node);\n-  PUSH_FIELD (ctype, field, \"data\", str_type);\n+  PUSH_FIELD (input_location, ctype, field, \"hash\", unsigned_short_type_node);\n+  PUSH_FIELD (input_location,\n+\t      ctype, field, \"length\", unsigned_short_type_node);\n+  PUSH_FIELD (input_location, ctype, field, \"data\", str_type);\n   FINISH_RECORD (ctype);\n   START_RECORD_CONSTRUCTOR (cinit, ctype);\n   name_hash = hashUtf8String (name_ptr, name_len) & 0xFFFF;\n@@ -965,7 +969,8 @@ build_utf8_ref (tree name)\n   /* Generate a unique-enough identifier.  */\n   sprintf(buf, \"_Utf%d\", ++utf8_count);\n \n-  decl = build_decl (VAR_DECL, get_identifier (buf), utf8const_type);\n+  decl = build_decl (input_location,\n+\t\t     VAR_DECL, get_identifier (buf), utf8const_type);\n   TREE_STATIC (decl) = 1;\n   DECL_ARTIFICIAL (decl) = 1;\n   DECL_IGNORED_P (decl) = 1;\n@@ -1027,7 +1032,7 @@ build_static_class_ref (tree type)\n   decl = IDENTIFIER_GLOBAL_VALUE (decl_name);\n   if (decl == NULL_TREE)\n     {\n-      decl = build_decl (VAR_DECL, decl_name, class_type_node);\n+      decl = build_decl (input_location, VAR_DECL, decl_name, class_type_node);\n       TREE_STATIC (decl) = 1;\n       if (! flag_indirect_classes)\n \t{\n@@ -1062,7 +1067,8 @@ build_classdollar_field (tree type)\n   if (decl == NULL_TREE)\n     {\n       decl \n-\t= build_decl (VAR_DECL, decl_name, \n+\t= build_decl (input_location,\n+\t\t      VAR_DECL, decl_name, \n \t\t      (build_type_variant \n \t\t       (build_pointer_type \n \t\t\t(build_type_variant (class_type_node, \n@@ -1097,7 +1103,8 @@ cache_this_class_ref (tree fndecl)\n       else\n \tclassdollar_field = build_static_class_ref (output_class);\n \n-      this_classdollar = build_decl (VAR_DECL, NULL_TREE, \n+      this_classdollar = build_decl (input_location,\n+\t\t\t\t     VAR_DECL, NULL_TREE, \n \t\t\t\t     TREE_TYPE (classdollar_field));\n       \n       java_add_local_var (this_classdollar);\n@@ -1175,7 +1182,8 @@ build_class_ref (tree type)\n \t  decl = IDENTIFIER_GLOBAL_VALUE (decl_name);\n \t  if (decl == NULL_TREE)\n \t    {\n-\t      decl = build_decl (VAR_DECL, decl_name, class_type_node);\n+\t      decl = build_decl (input_location,\n+\t\t\t\t VAR_DECL, decl_name, class_type_node);\n \t      TREE_STATIC (decl) = 1;\n \t      TREE_PUBLIC (decl) = 1;\n \t      DECL_EXTERNAL (decl) = 1;\n@@ -1205,7 +1213,8 @@ build_fieldref_cache_entry (int index, tree fdecl ATTRIBUTE_UNUSED)\n   decl = IDENTIFIER_GLOBAL_VALUE (decl_name);\n   if (decl == NULL_TREE)\n     {\n-      decl = build_decl (VAR_DECL, decl_name, ptr_type_node);\n+      decl = build_decl (input_location,\n+\t\t\t VAR_DECL, decl_name, ptr_type_node);\n       TREE_STATIC (decl) = 1;\n       TREE_PUBLIC (decl) = 0;\n       DECL_EXTERNAL (decl) = 0;\n@@ -1386,7 +1395,8 @@ make_local_function_alias (tree method)\n   strcpy (name + 1, method_name);\n \n   ASM_GENERATE_INTERNAL_LABEL (buf, name, alias_labelno++);  \n-  alias = build_decl (FUNCTION_DECL, get_identifier (buf),\n+  alias = build_decl (input_location,\n+\t\t      FUNCTION_DECL, get_identifier (buf),\n \t\t      TREE_TYPE (method));\n   DECL_CONTEXT (alias) = NULL;\n   TREE_READONLY (alias) = TREE_READONLY (method);\n@@ -1530,7 +1540,8 @@ make_method_value (tree mdecl)\n \ttable = build_constructor_from_list (type, table);\n \t/* Compute something unique enough.  */\n \tsprintf (buf, \"_methods%d\", method_name_count++);\n-\tarray = build_decl (VAR_DECL, get_identifier (buf), type);\n+\tarray = build_decl (input_location,\n+\t\t\t    VAR_DECL, get_identifier (buf), type);\n \tDECL_INITIAL (array) = table;\n \tTREE_STATIC (array) = 1;\n \tDECL_ARTIFICIAL (array) = 1;\n@@ -1862,7 +1873,8 @@ make_class_data (tree type)\n       instance_fields = nreverse (instance_fields);\n       static_fields = chainon (static_fields, instance_fields);\n       field_array_type = build_prim_array_type (field_type_node, field_count);\n-      fields_decl = build_decl (VAR_DECL, mangled_classname (\"_FL_\", type),\n+      fields_decl = build_decl (input_location,\n+\t\t\t\tVAR_DECL, mangled_classname (\"_FL_\", type),\n \t\t\t\tfield_array_type);\n       DECL_INITIAL (fields_decl) = build_constructor_from_list\n \t\t\t\t    (field_array_type, static_fields);\n@@ -1918,7 +1930,8 @@ make_class_data (tree type)\n         }\n     }\n   method_array_type = build_prim_array_type (method_type_node, method_count);\n-  methods_decl = build_decl (VAR_DECL, mangled_classname (\"_MT_\", type),\n+  methods_decl = build_decl (input_location,\n+\t\t\t     VAR_DECL, mangled_classname (\"_MT_\", type),\n \t\t\t     method_array_type);\n   DECL_INITIAL (methods_decl) = build_constructor_from_list\n \t\t\t\t (method_array_type, nreverse (methods));\n@@ -1964,7 +1977,8 @@ make_class_data (tree type)\n       tree interface_array_type, idecl;\n       interface_array_type\n \t= build_prim_array_type (class_ptr_type, interface_len);\n-      idecl = build_decl (VAR_DECL, mangled_classname (\"_IF_\", type),\n+      idecl = build_decl (input_location,\n+\t\t\t  VAR_DECL, mangled_classname (\"_IF_\", type),\n \t\t\t  interface_array_type);\n       \n       for (i = interface_len;  i > 0; i--)\n@@ -2168,7 +2182,8 @@ make_class_data (tree type)\n       static int reflection_data_count;\n \n       sprintf (buf, \"_reflection_data_%d\", reflection_data_count++);\n-      array = build_decl (VAR_DECL, get_identifier (buf), type);\n+      array = build_decl (input_location,\n+\t\t\t  VAR_DECL, get_identifier (buf), type);\n \n       rewrite_reflection_indexes (field_indexes);\n \n@@ -2298,23 +2313,25 @@ build_dtable_decl (tree type)\n \n       dtype = make_node (RECORD_TYPE);\n \n-      PUSH_FIELD (dtype, dummy, \"top_offset\", ptr_type_node);\n-      PUSH_FIELD (dtype, dummy, \"type_info\", ptr_type_node);\n+      PUSH_FIELD (input_location, dtype, dummy, \"top_offset\", ptr_type_node);\n+      PUSH_FIELD (input_location, dtype, dummy, \"type_info\", ptr_type_node);\n \n-      PUSH_FIELD (dtype, dummy, \"class\", class_ptr_type);\n+      PUSH_FIELD (input_location, dtype, dummy, \"class\", class_ptr_type);\n       for (n = 1; n < TARGET_VTABLE_USES_DESCRIPTORS; ++n)\n \t{\n-\t  tree tmp_field = build_decl (FIELD_DECL, NULL_TREE, ptr_type_node);\n+\t  tree tmp_field = build_decl (input_location,\n+\t\t\t\t       FIELD_DECL, NULL_TREE, ptr_type_node);\n \t  TREE_CHAIN (dummy) = tmp_field;\n \t  DECL_CONTEXT (tmp_field) = dtype;\n \t  DECL_ARTIFICIAL (tmp_field) = 1;\n \t  dummy = tmp_field;\n \t}\n \n-      PUSH_FIELD (dtype, dummy, \"gc_descr\", ptr_type_node);\n+      PUSH_FIELD (input_location, dtype, dummy, \"gc_descr\", ptr_type_node);\n       for (n = 1; n < TARGET_VTABLE_USES_DESCRIPTORS; ++n)\n \t{\n-\t  tree tmp_field = build_decl (FIELD_DECL, NULL_TREE, ptr_type_node);\n+\t  tree tmp_field = build_decl (input_location,\n+\t\t\t\t       FIELD_DECL, NULL_TREE, ptr_type_node);\n \t  TREE_CHAIN (dummy) = tmp_field;\n \t  DECL_CONTEXT (tmp_field) = dtype;\n \t  DECL_ARTIFICIAL (tmp_field) = 1;\n@@ -2325,14 +2342,15 @@ build_dtable_decl (tree type)\n       if (TARGET_VTABLE_USES_DESCRIPTORS)\n \tn *= TARGET_VTABLE_USES_DESCRIPTORS;\n \n-      PUSH_FIELD (dtype, dummy, \"methods\",\n+      PUSH_FIELD (input_location, dtype, dummy, \"methods\",\n \t\t  build_prim_array_type (nativecode_ptr_type_node, n));\n       layout_type (dtype);\n     }\n   else\n     dtype = dtable_type;\n \n-  decl = build_decl (VAR_DECL, get_identifier (\"vt$\"), dtype);\n+  decl = build_decl (input_location,\n+\t\t     VAR_DECL, get_identifier (\"vt$\"), dtype);\n   DECL_CONTEXT (decl) = type;\n   MAYBE_CREATE_VAR_LANG_DECL_SPECIFIC (decl);\n   DECL_VTABLE_P (decl) = 1;\n@@ -2350,7 +2368,8 @@ push_super_field (tree this_class, tree super_class)\n   /* Don't insert the field if we're just re-laying the class out. */ \n   if (TYPE_FIELDS (this_class) && !DECL_NAME (TYPE_FIELDS (this_class)))\n     return;\n-  base_decl = build_decl (FIELD_DECL, NULL_TREE, super_class);\n+  base_decl = build_decl (input_location,\n+\t\t\t  FIELD_DECL, NULL_TREE, super_class);\n   DECL_IGNORED_P (base_decl) = 1;\n   TREE_CHAIN (base_decl) = TYPE_FIELDS (this_class);\n   TYPE_FIELDS (this_class) = base_decl;\n@@ -2719,7 +2738,8 @@ emit_indirect_register_classes (tree *list_p)\n   int size = VEC_length (tree, registered_class) * 2 + 1;\n   tree class_array_type\n     = build_prim_array_type (ptr_type_node, size);\n-  tree cdecl = build_decl (VAR_DECL, get_identifier (\"_Jv_CLS\"),\n+  tree cdecl = build_decl (input_location,\n+\t\t\t   VAR_DECL, get_identifier (\"_Jv_CLS\"),\n \t\t\t   class_array_type);\n   tree reg_class_list;\n   for (i = 0; VEC_iterate (tree, registered_class, i, klass); ++i)\n@@ -2747,7 +2767,8 @@ emit_indirect_register_classes (tree *list_p)\n \n   t = build_function_type_list (void_type_node, \n \t\t\t\tbuild_pointer_type (ptr_type_node), NULL);\n-  t = build_decl (FUNCTION_DECL, \n+  t = build_decl (input_location,\n+\t\t  FUNCTION_DECL, \n \t\t  get_identifier (\"_Jv_RegisterNewClasses\"), t);\n   TREE_PUBLIC (t) = 1;\n   DECL_EXTERNAL (t) = 1;\n@@ -2809,7 +2830,8 @@ emit_register_classes (tree *list_p)\n       int i;\n \n       t = build_function_type_list (void_type_node, class_ptr_type, NULL);\n-      t = build_decl (FUNCTION_DECL, get_identifier (\"_Jv_RegisterClass\"), t);\n+      t = build_decl (input_location,\n+\t\t      FUNCTION_DECL, get_identifier (\"_Jv_RegisterClass\"), t);\n       TREE_PUBLIC (t) = 1;\n       DECL_EXTERNAL (t) = 1;\n       register_class_fn = t;\n@@ -2915,7 +2937,8 @@ emit_symbol_table (tree name, tree the_table, tree decl_list,\n   table_size \n     = build_index_type (build_int_cst (NULL_TREE, index * element_size + 1));\n   the_array_type = build_array_type (the_array_element_type, table_size);\n-  the_table = build_decl (VAR_DECL, name, the_array_type);\n+  the_table = build_decl (input_location,\n+\t\t\t  VAR_DECL, name, the_array_type);\n   TREE_STATIC (the_table) = 1;\n   TREE_READONLY (the_table) = 1;  \n   rest_of_decl_compilation (the_table, 1, 0);\n@@ -2959,7 +2982,8 @@ emit_catch_table (tree this_class)\n     = build_array_type (TREE_TYPE (TREE_TYPE (TYPE_CTABLE_DECL (this_class))),\n \t\t\ttable_size);\n   table = \n-    build_decl (VAR_DECL, DECL_NAME (TYPE_CTABLE_DECL (this_class)), array_type);\n+    build_decl (input_location,\n+\t\tVAR_DECL, DECL_NAME (TYPE_CTABLE_DECL (this_class)), array_type);\n   DECL_INITIAL (table) = \n     build_constructor_from_list (array_type, TYPE_CATCH_CLASSES (this_class));\n   TREE_STATIC (table) = 1;\n@@ -3043,7 +3067,8 @@ emit_assertion_table (tree klass)\n   list = nreverse (list);\n   ctor = build_constructor_from_list (assertion_table_type, list);\n \n-  table_decl = build_decl (VAR_DECL, mangled_classname (\"_type_assert_\", klass),\n+  table_decl = build_decl (input_location,\n+\t\t\t   VAR_DECL, mangled_classname (\"_type_assert_\", klass),\n \t\t\t   assertion_table_type);\n \n   TREE_STATIC (table_decl) = 1;"}, {"sha": "541e78d2cb56307d65aedd69ceae2f084111ab83", "filename": "gcc/java/constants.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fjava%2Fconstants.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fjava%2Fconstants.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fconstants.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -463,7 +463,7 @@ build_constant_data_ref (bool indirect)\n \t     thinks the type is incomplete.  */\n \t  layout_type (type);\n \n-\t  decl = build_decl (VAR_DECL, decl_name, type);\n+\t  decl = build_decl (input_location, VAR_DECL, decl_name, type);\n \t  TREE_STATIC (decl) = 1;\n \t  IDENTIFIER_GLOBAL_VALUE (decl_name) = decl;\n \t}\n@@ -581,7 +581,8 @@ build_constants_constructor (void)\n       data_value = build_address_of (data_decl);\n \n       tags_type = build_array_type (unsigned_byte_type_node, index_type);\n-      tags_decl = build_decl (VAR_DECL, mangled_classname (\"_CT_\", \n+      tags_decl = build_decl (input_location, \n+      \t\t\t      VAR_DECL, mangled_classname (\"_CT_\", \n \t\t\t\t\t\t\t   current_class),\n \t\t\t      tags_type);\n       TREE_STATIC (tags_decl) = 1;"}, {"sha": "3c1e7eaef9cd62907043c56689694f2302da7efe", "filename": "gcc/java/decl.c", "status": "modified", "additions": 180, "deletions": 98, "changes": 278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -274,7 +274,7 @@ find_local_variable (int index, tree type, int pc ATTRIBUTE_UNUSED)\n       tree name;\n       sprintf (buf, \"#slot#%d#%d\", index, uniq++);\n       name = get_identifier (buf);\n-      decl = build_decl (VAR_DECL, name, type);\n+      decl = build_decl (input_location, VAR_DECL, name, type);\n       DECL_IGNORED_P (decl) = 1;\n       DECL_ARTIFICIAL (decl) = 1;\n       decl = push_jvm_slot (index, decl);\n@@ -297,7 +297,7 @@ find_local_variable (int index, tree type, int pc ATTRIBUTE_UNUSED)\n       name = get_identifier (buf);\n       base_decl\n \t= TREE_VEC_ELT (base_decl_map, index)\n-\t= build_decl (VAR_DECL, name, ptr_type_node);\n+\t= build_decl (input_location, VAR_DECL, name, ptr_type_node);\n       pushdecl_function_level (base_decl);\n       DECL_IGNORED_P (base_decl) = 1;\n       DECL_ARTIFICIAL (base_decl) = 1;\n@@ -450,7 +450,8 @@ push_promoted_type (const char *name, tree actual_type)\n   TYPE_PRECISION (type) = TYPE_PRECISION (int_type_node);\n   TYPE_STRING_FLAG (type) = TYPE_STRING_FLAG (actual_type);\n   layout_type (type);\n-  pushdecl (build_decl (TYPE_DECL, get_identifier (name), type));\n+  pushdecl (build_decl (input_location,\n+\t\t\tTYPE_DECL, get_identifier (name), type));\n   return type;\n }\n \n@@ -462,7 +463,8 @@ create_primitive_vtable (const char *name)\n   char buf[50];\n \n   sprintf (buf, \"_Jv_%sVTable\", name);\n-  r = build_decl (VAR_DECL, get_identifier (buf), ptr_type_node);\n+  r = build_decl (input_location,\n+\t\t  VAR_DECL, get_identifier (buf), ptr_type_node);\n   DECL_EXTERNAL (r) = 1;\n   return r;\n }\n@@ -545,25 +547,33 @@ java_init_decl_processing (void)\n   initialize_sizetypes (false);\n \n   byte_type_node = make_signed_type (8);\n-  pushdecl (build_decl (TYPE_DECL, get_identifier (\"byte\"), byte_type_node));\n+  pushdecl (build_decl (BUILTINS_LOCATION,\n+\t\t\tTYPE_DECL, get_identifier (\"byte\"), byte_type_node));\n   short_type_node = make_signed_type (16);\n-  pushdecl (build_decl (TYPE_DECL, get_identifier (\"short\"), short_type_node));\n+  pushdecl (build_decl (BUILTINS_LOCATION,\n+\t\t\tTYPE_DECL, get_identifier (\"short\"), short_type_node));\n   int_type_node = make_signed_type (32);\n-  pushdecl (build_decl (TYPE_DECL, get_identifier (\"int\"), int_type_node));\n+  pushdecl (build_decl (BUILTINS_LOCATION,\n+\t\t\tTYPE_DECL, get_identifier (\"int\"), int_type_node));\n   long_type_node = make_signed_type (64);\n-  pushdecl (build_decl (TYPE_DECL, get_identifier (\"long\"), long_type_node));\n+  pushdecl (build_decl (BUILTINS_LOCATION,\n+\t\t\tTYPE_DECL, get_identifier (\"long\"), long_type_node));\n \n   unsigned_byte_type_node = make_unsigned_type (8);\n-  pushdecl (build_decl (TYPE_DECL, get_identifier (\"unsigned byte\"),\n+  pushdecl (build_decl (BUILTINS_LOCATION,\n+\t\t\tTYPE_DECL, get_identifier (\"unsigned byte\"),\n \t\t\tunsigned_byte_type_node));\n   unsigned_short_type_node = make_unsigned_type (16);\n-  pushdecl (build_decl (TYPE_DECL, get_identifier (\"unsigned short\"),\n+  pushdecl (build_decl (BUILTINS_LOCATION,\n+\t\t\tTYPE_DECL, get_identifier (\"unsigned short\"),\n \t\t\tunsigned_short_type_node));\n   unsigned_int_type_node = make_unsigned_type (32);\n-  pushdecl (build_decl (TYPE_DECL, get_identifier (\"unsigned int\"),\n+  pushdecl (build_decl (BUILTINS_LOCATION,\n+\t\t\tTYPE_DECL, get_identifier (\"unsigned int\"),\n \t\t\tunsigned_int_type_node));\n   unsigned_long_type_node = make_unsigned_type (64);\n-  pushdecl (build_decl (TYPE_DECL, get_identifier (\"unsigned long\"),\n+  pushdecl (build_decl (BUILTINS_LOCATION,\n+\t\t\tTYPE_DECL, get_identifier (\"unsigned long\"),\n \t\t\tunsigned_long_type_node));\n \n   /* This is not a java type, however tree-dfa requires a definition for\n@@ -600,7 +610,8 @@ java_init_decl_processing (void)\n   long_zero_node = build_int_cst (long_type_node, 0);\n \n   void_type_node = make_node (VOID_TYPE);\n-  pushdecl (build_decl (TYPE_DECL, get_identifier (\"void\"), void_type_node));\n+  pushdecl (build_decl (BUILTINS_LOCATION,\n+\t\t\tTYPE_DECL, get_identifier (\"void\"), void_type_node));\n   layout_type (void_type_node);\t/* Uses size_zero_node */\n \n   ptr_type_node = build_pointer_type (void_type_node);\n@@ -617,12 +628,14 @@ java_init_decl_processing (void)\n   TYPE_STRING_FLAG (char_type_node) = 1;\n   TYPE_PRECISION (char_type_node) = 16;\n   fixup_unsigned_type (char_type_node);\n-  pushdecl (build_decl (TYPE_DECL, get_identifier (\"char\"), char_type_node));\n+  pushdecl (build_decl (BUILTINS_LOCATION,\n+\t\t\tTYPE_DECL, get_identifier (\"char\"), char_type_node));\n \n   boolean_type_node = make_node (BOOLEAN_TYPE);\n   TYPE_PRECISION (boolean_type_node) = 1;\n   fixup_unsigned_type (boolean_type_node);\n-  pushdecl (build_decl (TYPE_DECL, get_identifier (\"boolean\"),\n+  pushdecl (build_decl (BUILTINS_LOCATION,\n+\t\t\tTYPE_DECL, get_identifier (\"boolean\"),\n \t\t\tboolean_type_node));\n   boolean_false_node = TYPE_MIN_VALUE (boolean_type_node);\n   boolean_true_node = TYPE_MAX_VALUE (boolean_type_node);\n@@ -638,13 +651,15 @@ java_init_decl_processing (void)\n \n   float_type_node = make_node (REAL_TYPE);\n   TYPE_PRECISION (float_type_node) = 32;\n-  pushdecl (build_decl (TYPE_DECL, get_identifier (\"float\"),\n+  pushdecl (build_decl (BUILTINS_LOCATION,\n+\t\t\tTYPE_DECL, get_identifier (\"float\"),\n                         float_type_node));\n   layout_type (float_type_node);\n \n   double_type_node = make_node (REAL_TYPE);\n   TYPE_PRECISION (double_type_node) = 64;\n-  pushdecl (build_decl (TYPE_DECL, get_identifier (\"double\"),\n+  pushdecl (build_decl (BUILTINS_LOCATION,\n+\t\t\tTYPE_DECL, get_identifier (\"double\"),\n                         double_type_node));\n   layout_type (double_type_node);\n \n@@ -663,8 +678,10 @@ java_init_decl_processing (void)\n \n   one_elt_array_domain_type = build_index_type (integer_one_node);\n   utf8const_type = make_node (RECORD_TYPE);\n-  PUSH_FIELD (utf8const_type, field, \"hash\", unsigned_short_type_node);\n-  PUSH_FIELD (utf8const_type, field, \"length\", unsigned_short_type_node);\n+  PUSH_FIELD (input_location,\n+\t      utf8const_type, field, \"hash\", unsigned_short_type_node);\n+  PUSH_FIELD (input_location,\n+\t      utf8const_type, field, \"length\", unsigned_short_type_node);\n   FINISH_RECORD (utf8const_type);\n   utf8const_ptr_type = build_pointer_type (utf8const_type);\n \n@@ -679,19 +696,24 @@ java_init_decl_processing (void)\n   itable_ptr_type = build_pointer_type (itable_type);\n \n   symbol_type = make_node (RECORD_TYPE);\n-  PUSH_FIELD (symbol_type, field, \"clname\", utf8const_ptr_type);\n-  PUSH_FIELD (symbol_type, field, \"name\", utf8const_ptr_type);\n-  PUSH_FIELD (symbol_type, field, \"signature\", utf8const_ptr_type);\n+  PUSH_FIELD (input_location,\n+\t      symbol_type, field, \"clname\", utf8const_ptr_type);\n+  PUSH_FIELD (input_location, symbol_type, field, \"name\", utf8const_ptr_type);\n+  PUSH_FIELD (input_location,\n+\t      symbol_type, field, \"signature\", utf8const_ptr_type);\n   FINISH_RECORD (symbol_type);\n \n   symbols_array_type = build_array_type (symbol_type, \n \t\t\t\t\t one_elt_array_domain_type);\n   symbols_array_ptr_type = build_pointer_type (symbols_array_type);\n \n   assertion_entry_type = make_node (RECORD_TYPE);\n-  PUSH_FIELD (assertion_entry_type, field, \"assertion_code\", integer_type_node);\n-  PUSH_FIELD (assertion_entry_type, field, \"op1\", utf8const_ptr_type);\n-  PUSH_FIELD (assertion_entry_type, field, \"op2\", utf8const_ptr_type);\n+  PUSH_FIELD (input_location,\n+\t      assertion_entry_type, field, \"assertion_code\", integer_type_node);\n+  PUSH_FIELD (input_location,\n+\t      assertion_entry_type, field, \"op1\", utf8const_ptr_type);\n+  PUSH_FIELD (input_location,\n+\t      assertion_entry_type, field, \"op2\", utf8const_ptr_type);\n   FINISH_RECORD (assertion_entry_type);\n   \n   assertion_table_type = build_array_type (assertion_entry_type,\n@@ -729,7 +751,8 @@ java_init_decl_processing (void)\n \n   methodtable_type = make_node (RECORD_TYPE);\n   layout_type (methodtable_type);\n-  build_decl (TYPE_DECL, get_identifier (\"methodtable\"), methodtable_type);\n+  build_decl (BUILTINS_LOCATION,\n+\t      TYPE_DECL, get_identifier (\"methodtable\"), methodtable_type);\n   methodtable_ptr_type = build_pointer_type (methodtable_type);\n \n   TYPE_identifier_node = get_identifier (\"TYPE\");\n@@ -747,12 +770,16 @@ java_init_decl_processing (void)\n   init_expr_processing();\n \n   constants_type_node = make_node (RECORD_TYPE);\n-  PUSH_FIELD (constants_type_node, field, \"size\", unsigned_int_type_node);\n-  PUSH_FIELD (constants_type_node, field, \"tags\", ptr_type_node);\n-  PUSH_FIELD (constants_type_node, field, \"data\", ptr_type_node);\n+  PUSH_FIELD (input_location,\n+\t      constants_type_node, field, \"size\", unsigned_int_type_node);\n+  PUSH_FIELD (input_location,\n+\t      constants_type_node, field, \"tags\", ptr_type_node);\n+  PUSH_FIELD (input_location,\n+\t      constants_type_node, field, \"data\", ptr_type_node);\n   constants_data_field_decl_node = field;\n   FINISH_RECORD (constants_type_node);\n-  build_decl (TYPE_DECL, get_identifier (\"constants\"), constants_type_node);\n+  build_decl (BUILTINS_LOCATION,\n+\t      TYPE_DECL, get_identifier (\"constants\"), constants_type_node);\n \n   access_flags_type_node = unsigned_short_type_node;\n \n@@ -764,15 +791,16 @@ java_init_decl_processing (void)\n   TYPE_NONALIASED_COMPONENT (otable_type) = 1;\n   otable_ptr_type = build_pointer_type (otable_type);\n \n-  PUSH_FIELD (object_type_node, field, \"vtable\", dtable_ptr_type);\n+  PUSH_FIELD (input_location,\n+\t      object_type_node, field, \"vtable\", dtable_ptr_type);\n   DECL_FCONTEXT (field) = object_type_node;\n   TYPE_VFIELD (object_type_node) = field;\n \n   /* This isn't exactly true, but it is what we have in the source.\n      There is an unresolved issue here, which is whether the vtable\n      should be marked by the GC.  */\n   if (! flag_hash_synchronization)\n-    PUSH_FIELD (object_type_node, field, \"sync_info\",\n+    PUSH_FIELD (input_location, object_type_node, field, \"sync_info\",\n \t\tbuild_pointer_type (object_type_node));\n   for (t = TYPE_FIELDS (object_type_node); t != NULL_TREE; t = TREE_CHAIN (t))\n     FIELD_PRIVATE (t) = 1;\n@@ -787,101 +815,154 @@ java_init_decl_processing (void)\n   set_super_info (0, string_type_node, object_type_node, 0);\n   class_ptr_type = build_pointer_type (class_type_node);\n \n-  PUSH_FIELD (class_type_node, field, \"next_or_version\", class_ptr_type);\n-  PUSH_FIELD (class_type_node, field, \"name\", utf8const_ptr_type);\n-  PUSH_FIELD (class_type_node, field, \"accflags\", access_flags_type_node);\n-  PUSH_FIELD (class_type_node, field, \"superclass\", class_ptr_type);\n-  PUSH_FIELD (class_type_node, field, \"constants\", constants_type_node);\n+  PUSH_FIELD (input_location,\n+\t      class_type_node, field, \"next_or_version\", class_ptr_type);\n+  PUSH_FIELD (input_location,\n+\t      class_type_node, field, \"name\", utf8const_ptr_type);\n+  PUSH_FIELD (input_location,\n+\t      class_type_node, field, \"accflags\", access_flags_type_node);\n+  PUSH_FIELD (input_location,\n+\t      class_type_node, field, \"superclass\", class_ptr_type);\n+  PUSH_FIELD (input_location,\n+\t      class_type_node, field, \"constants\", constants_type_node);\n   constants_field_decl_node = field;\n-  PUSH_FIELD (class_type_node, field, \"methods\", method_ptr_type_node);\n-  PUSH_FIELD (class_type_node, field, \"method_count\", short_type_node);\n-  PUSH_FIELD (class_type_node, field, \"vtable_method_count\", short_type_node);\n-  PUSH_FIELD (class_type_node, field, \"fields\", field_ptr_type_node);\n-  PUSH_FIELD (class_type_node, field, \"size_in_bytes\", int_type_node);\n-  PUSH_FIELD (class_type_node, field, \"field_count\", short_type_node);\n-  PUSH_FIELD (class_type_node, field, \"static_field_count\", short_type_node);\n-  PUSH_FIELD (class_type_node, field, \"vtable\", dtable_ptr_type);\n-  PUSH_FIELD (class_type_node, field, \"otable\", otable_ptr_type);\n-  PUSH_FIELD (class_type_node, field, \"otable_syms\", \n+  PUSH_FIELD (input_location,\n+\t      class_type_node, field, \"methods\", method_ptr_type_node);\n+  PUSH_FIELD (input_location,\n+\t      class_type_node, field, \"method_count\", short_type_node);\n+  PUSH_FIELD (input_location,\n+\t      class_type_node, field, \"vtable_method_count\", short_type_node);\n+  PUSH_FIELD (input_location,\n+\t      class_type_node, field, \"fields\", field_ptr_type_node);\n+  PUSH_FIELD (input_location,\n+\t      class_type_node, field, \"size_in_bytes\", int_type_node);\n+  PUSH_FIELD (input_location,\n+\t      class_type_node, field, \"field_count\", short_type_node);\n+  PUSH_FIELD (input_location,\n+\t      class_type_node, field, \"static_field_count\", short_type_node);\n+  PUSH_FIELD (input_location,\n+\t      class_type_node, field, \"vtable\", dtable_ptr_type);\n+  PUSH_FIELD (input_location,\n+\t      class_type_node, field, \"otable\", otable_ptr_type);\n+  PUSH_FIELD (input_location,\n+\t      class_type_node, field, \"otable_syms\", \n   \t      symbols_array_ptr_type);\n-  PUSH_FIELD (class_type_node, field, \"atable\", atable_ptr_type);\n-  PUSH_FIELD (class_type_node, field, \"atable_syms\", \n+  PUSH_FIELD (input_location,\n+\t      class_type_node, field, \"atable\", atable_ptr_type);\n+  PUSH_FIELD (input_location,\n+\t      class_type_node, field, \"atable_syms\", \n   \t      symbols_array_ptr_type);\n-  PUSH_FIELD (class_type_node, field, \"itable\", itable_ptr_type);\n-  PUSH_FIELD (class_type_node, field, \"itable_syms\", \n+  PUSH_FIELD (input_location,\n+\t      class_type_node, field, \"itable\", itable_ptr_type);\n+  PUSH_FIELD (input_location, class_type_node, field, \"itable_syms\", \n   \t      symbols_array_ptr_type);\n-  PUSH_FIELD (class_type_node, field, \"catch_classes\", ptr_type_node);\n-  PUSH_FIELD (class_type_node, field, \"interfaces\",\n+  PUSH_FIELD (input_location,\n+\t      class_type_node, field, \"catch_classes\", ptr_type_node);\n+  PUSH_FIELD (input_location, class_type_node, field, \"interfaces\",\n \t      build_pointer_type (class_ptr_type));\n-  PUSH_FIELD (class_type_node, field, \"loader\", ptr_type_node);\n-  PUSH_FIELD (class_type_node, field, \"interface_count\", short_type_node);\n-  PUSH_FIELD (class_type_node, field, \"state\", byte_type_node);\n-  PUSH_FIELD (class_type_node, field, \"thread\", ptr_type_node);\n-  PUSH_FIELD (class_type_node, field, \"depth\", short_type_node);\n-  PUSH_FIELD (class_type_node, field, \"ancestors\", ptr_type_node);\n-  PUSH_FIELD (class_type_node, field, \"idt\", ptr_type_node);  \n-  PUSH_FIELD (class_type_node, field, \"arrayclass\", ptr_type_node);  \n-  PUSH_FIELD (class_type_node, field, \"protectionDomain\", ptr_type_node);\n-  PUSH_FIELD (class_type_node, field, \"assertion_table\", ptr_type_node);\n-  PUSH_FIELD (class_type_node, field, \"hack_signers\", ptr_type_node);\n-  PUSH_FIELD (class_type_node, field, \"chain\", ptr_type_node);\n-  PUSH_FIELD (class_type_node, field, \"aux_info\", ptr_type_node);\n-  PUSH_FIELD (class_type_node, field, \"engine\", ptr_type_node);\n-  PUSH_FIELD (class_type_node, field, \"reflection_data\", ptr_type_node);\n+  PUSH_FIELD (input_location, class_type_node, field, \"loader\", ptr_type_node);\n+  PUSH_FIELD (input_location,\n+\t      class_type_node, field, \"interface_count\", short_type_node);\n+  PUSH_FIELD (input_location, class_type_node, field, \"state\", byte_type_node);\n+  PUSH_FIELD (input_location, class_type_node, field, \"thread\", ptr_type_node);\n+  PUSH_FIELD (input_location,\n+\t      class_type_node, field, \"depth\", short_type_node);\n+  PUSH_FIELD (input_location,\n+\t      class_type_node, field, \"ancestors\", ptr_type_node);\n+  PUSH_FIELD (input_location, class_type_node, field, \"idt\", ptr_type_node);  \n+  PUSH_FIELD (input_location,\n+\t      class_type_node, field, \"arrayclass\", ptr_type_node);  \n+  PUSH_FIELD (input_location,\n+\t      class_type_node, field, \"protectionDomain\", ptr_type_node);\n+  PUSH_FIELD (input_location,\n+\t      class_type_node, field, \"assertion_table\", ptr_type_node);\n+  PUSH_FIELD (input_location,\n+\t      class_type_node, field, \"hack_signers\", ptr_type_node);\n+  PUSH_FIELD (input_location, class_type_node, field, \"chain\", ptr_type_node);\n+  PUSH_FIELD (input_location,\n+\t      class_type_node, field, \"aux_info\", ptr_type_node);\n+  PUSH_FIELD (input_location, class_type_node, field, \"engine\", ptr_type_node);\n+  PUSH_FIELD (input_location,\n+\t      class_type_node, field, \"reflection_data\", ptr_type_node);\n   for (t = TYPE_FIELDS (class_type_node);  t != NULL_TREE;  t = TREE_CHAIN (t))\n     FIELD_PRIVATE (t) = 1;\n   push_super_field (class_type_node, object_type_node);\n \n   FINISH_RECORD (class_type_node);\n-  build_decl (TYPE_DECL, get_identifier (\"Class\"), class_type_node);\n+  build_decl (BUILTINS_LOCATION,\n+\t      TYPE_DECL, get_identifier (\"Class\"), class_type_node);\n \n   field_info_union_node = make_node (UNION_TYPE);\n-  PUSH_FIELD (field_info_union_node, field, \"boffset\", int_type_node);\n-  PUSH_FIELD (field_info_union_node, field, \"addr\", ptr_type_node);\n+  PUSH_FIELD (input_location,\n+\t      field_info_union_node, field, \"boffset\", int_type_node);\n+  PUSH_FIELD (input_location,\n+\t      field_info_union_node, field, \"addr\", ptr_type_node);\n   layout_type (field_info_union_node);\n \n-  PUSH_FIELD (field_type_node, field, \"name\", utf8const_ptr_type);\n-  PUSH_FIELD (field_type_node, field, \"type\", class_ptr_type);\n-  PUSH_FIELD (field_type_node, field, \"accflags\", access_flags_type_node);\n-  PUSH_FIELD (field_type_node, field, \"bsize\", unsigned_short_type_node);\n-  PUSH_FIELD (field_type_node, field, \"info\", field_info_union_node);\n+  PUSH_FIELD (input_location,\n+\t      field_type_node, field, \"name\", utf8const_ptr_type);\n+  PUSH_FIELD (input_location, field_type_node, field, \"type\", class_ptr_type);\n+  PUSH_FIELD (input_location,\n+\t      field_type_node, field, \"accflags\", access_flags_type_node);\n+  PUSH_FIELD (input_location,\n+\t      field_type_node, field, \"bsize\", unsigned_short_type_node);\n+  PUSH_FIELD (input_location,\n+\t      field_type_node, field, \"info\", field_info_union_node);\n   FINISH_RECORD (field_type_node);\n-  build_decl (TYPE_DECL, get_identifier (\"Field\"), field_type_node);\n+  build_decl (BUILTINS_LOCATION,\n+\t      TYPE_DECL, get_identifier (\"Field\"), field_type_node);\n \n   nativecode_ptr_array_type_node\n     = build_array_type (nativecode_ptr_type_node, one_elt_array_domain_type);\n \n-  PUSH_FIELD (dtable_type, field, \"class\", class_ptr_type);\n-  PUSH_FIELD (dtable_type, field, \"methods\", nativecode_ptr_array_type_node);\n+  PUSH_FIELD (input_location,\n+\t      dtable_type, field, \"class\", class_ptr_type);\n+  PUSH_FIELD (input_location,\n+\t      dtable_type, field, \"methods\", nativecode_ptr_array_type_node);\n   FINISH_RECORD (dtable_type);\n-  build_decl (TYPE_DECL, get_identifier (\"dispatchTable\"), dtable_type);\n+  build_decl (BUILTINS_LOCATION,\n+\t      TYPE_DECL, get_identifier (\"dispatchTable\"), dtable_type);\n \n   jexception_type = make_node (RECORD_TYPE);\n-  PUSH_FIELD (jexception_type, field, \"start_pc\", ptr_type_node);\n-  PUSH_FIELD (jexception_type, field, \"end_pc\", ptr_type_node);\n-  PUSH_FIELD (jexception_type, field, \"handler_pc\", ptr_type_node);\n-  PUSH_FIELD (jexception_type, field, \"catch_type\", class_ptr_type);\n+  PUSH_FIELD (input_location,\n+\t      jexception_type, field, \"start_pc\", ptr_type_node);\n+  PUSH_FIELD (input_location, jexception_type, field, \"end_pc\", ptr_type_node);\n+  PUSH_FIELD (input_location,\n+\t      jexception_type, field, \"handler_pc\", ptr_type_node);\n+  PUSH_FIELD (input_location,\n+\t      jexception_type, field, \"catch_type\", class_ptr_type);\n   FINISH_RECORD (jexception_type);\n-  build_decl (TYPE_DECL, get_identifier (\"jexception\"), field_type_node);\n+  build_decl (BUILTINS_LOCATION,\n+\t      TYPE_DECL, get_identifier (\"jexception\"), field_type_node);\n   jexception_ptr_type = build_pointer_type (jexception_type);\n \n   lineNumberEntry_type = make_node (RECORD_TYPE);\n-  PUSH_FIELD (lineNumberEntry_type, field, \"line_nr\", unsigned_short_type_node);\n-  PUSH_FIELD (lineNumberEntry_type, field, \"start_pc\", ptr_type_node);\n+  PUSH_FIELD (input_location,\n+\t      lineNumberEntry_type, field, \"line_nr\", unsigned_short_type_node);\n+  PUSH_FIELD (input_location,\n+\t      lineNumberEntry_type, field, \"start_pc\", ptr_type_node);\n   FINISH_RECORD (lineNumberEntry_type);\n \n   lineNumbers_type = make_node (RECORD_TYPE);\n-  PUSH_FIELD (lineNumbers_type, field, \"length\", unsigned_int_type_node);\n+  PUSH_FIELD (input_location,\n+\t      lineNumbers_type, field, \"length\", unsigned_int_type_node);\n   FINISH_RECORD (lineNumbers_type);\n \n-  PUSH_FIELD (method_type_node, field, \"name\", utf8const_ptr_type);\n-  PUSH_FIELD (method_type_node, field, \"signature\", utf8const_ptr_type);\n-  PUSH_FIELD (method_type_node, field, \"accflags\", access_flags_type_node);\n-  PUSH_FIELD (method_type_node, field, \"index\", unsigned_short_type_node);\n-  PUSH_FIELD (method_type_node, field, \"ncode\", nativecode_ptr_type_node);\n-  PUSH_FIELD (method_type_node, field, \"throws\", ptr_type_node);\n+  PUSH_FIELD (input_location,\n+\t      method_type_node, field, \"name\", utf8const_ptr_type);\n+  PUSH_FIELD (input_location,\n+\t      method_type_node, field, \"signature\", utf8const_ptr_type);\n+  PUSH_FIELD (input_location,\n+\t      method_type_node, field, \"accflags\", access_flags_type_node);\n+  PUSH_FIELD (input_location,\n+\t      method_type_node, field, \"index\", unsigned_short_type_node);\n+  PUSH_FIELD (input_location,\n+\t      method_type_node, field, \"ncode\", nativecode_ptr_type_node);\n+  PUSH_FIELD (input_location,\n+\t      method_type_node, field, \"throws\", ptr_type_node);\n   FINISH_RECORD (method_type_node);\n-  build_decl (TYPE_DECL, get_identifier (\"Method\"), method_type_node);\n+  build_decl (BUILTINS_LOCATION,\n+\t      TYPE_DECL, get_identifier (\"Method\"), method_type_node);\n \n   endlink = end_params_node = tree_cons (NULL_TREE, void_type_node, NULL_TREE);\n \n@@ -1632,7 +1713,7 @@ give_name_to_locals (JCF *jcf)\n \t{\n \t  tree *ptr;\n \t  int end_pc = start_pc + length;\n-\t  tree decl = build_decl (VAR_DECL, name, type);\n+\t  tree decl = build_decl (input_location, VAR_DECL, name, type);\n \t  if (end_pc > DECL_CODE_LENGTH (current_function_decl))\n \t    {\n \t      warning (0, \"bad PC range for debug info for local %q+D\",\n@@ -1694,7 +1775,8 @@ build_result_decl (tree fndecl)\n   tree result = DECL_RESULT (fndecl);\n   if (! result)\n     {\n-      result = build_decl (RESULT_DECL, NULL_TREE, restype);\n+      result = build_decl (DECL_SOURCE_LOCATION (fndecl),\n+\t\t\t   RESULT_DECL, NULL_TREE, restype);\n       DECL_ARTIFICIAL (result) = 1;\n       DECL_IGNORED_P (result) = 1;\n       DECL_CONTEXT (result) = fndecl;\n@@ -1733,7 +1815,7 @@ start_java_method (tree fndecl)\n       tree parm_type = TREE_VALUE (tem);\n       gcc_assert (i < DECL_MAX_LOCALS (fndecl));\n \n-      parm_decl = build_decl (PARM_DECL, parm_name, parm_type);\n+      parm_decl = build_decl (input_location, PARM_DECL, parm_name, parm_type);\n       DECL_CONTEXT (parm_decl) = fndecl;\n       if (targetm.calls.promote_prototypes (parm_type)\n \t  && TYPE_PRECISION (parm_type) < TYPE_PRECISION (integer_type_node)"}, {"sha": "e97ed7755d9298b5fc5971b1e2921ad6a59075d3", "filename": "gcc/java/except.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fjava%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fjava%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexcept.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -393,7 +393,8 @@ prepare_eh_table_type (tree type)\n       name = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type)));\n       buf = (char *) alloca (strlen (name) + 5);\n       sprintf (buf, \"%s_ref\", name);\n-      decl = build_decl (VAR_DECL, get_identifier (buf), ptr_type_node);\n+      decl = build_decl (input_location,\n+\t\t\t VAR_DECL, get_identifier (buf), ptr_type_node);\n       TREE_STATIC (decl) = 1;\n       DECL_ARTIFICIAL (decl) = 1;\n       DECL_IGNORED_P (decl) = 1;\n@@ -410,7 +411,8 @@ prepare_eh_table_type (tree type)\n       name = IDENTIFIER_POINTER (DECL_NAME (TREE_OPERAND (utf8_ref, 0)));\n       buf = (char *) alloca (strlen (name) + 5);\n       sprintf (buf, \"%s_ref\", name);\n-      decl = build_decl (VAR_DECL, get_identifier (buf), utf8const_ptr_type);\n+      decl = build_decl (input_location,\n+\t\t\t VAR_DECL, get_identifier (buf), utf8const_ptr_type);\n       TREE_STATIC (decl) = 1;\n       DECL_ARTIFICIAL (decl) = 1;\n       DECL_IGNORED_P (decl) = 1;"}, {"sha": "72ca77303ec3bdc7b3e841d156de97fff344c8f9", "filename": "gcc/java/expr.c", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -669,7 +669,7 @@ java_stack_swap (void)\n   flush_quick_stack ();\n   decl1 = find_stack_slot (stack_pointer - 1, type1);\n   decl2 = find_stack_slot (stack_pointer - 2, type2);\n-  temp = build_decl (VAR_DECL, NULL_TREE, type1);\n+  temp = build_decl (input_location, VAR_DECL, NULL_TREE, type1);\n   java_add_local_var (temp);\n   java_add_stmt (build2 (MODIFY_EXPR, type1, temp, decl1));\n   java_add_stmt (build2 (MODIFY_EXPR, type2, \n@@ -1192,7 +1192,7 @@ expand_java_arraystore (tree rhs_type_node)\n      MODIFY_EXPR to set the array element.  */\n \n   access = build_java_arrayaccess (array, rhs_type_node, index);\n-  temp = build_decl (VAR_DECL, NULL_TREE, \n+  temp = build_decl (input_location, VAR_DECL, NULL_TREE, \n \t\t     build_pointer_type (TREE_TYPE (access)));\n   java_add_local_var (temp);\n   java_add_stmt (build2 (MODIFY_EXPR, TREE_TYPE (temp),\n@@ -1332,7 +1332,7 @@ expand_load_internal (int index, tree type, int pc)\n      generated.  To avoid this we create a new local and copy our\n      value into it.  Then we push this new local on the stack.\n      Hopefully this all gets optimized out.  */\n-  copy = build_decl (VAR_DECL, NULL_TREE, type);\n+  copy = build_decl (input_location, VAR_DECL, NULL_TREE, type);\n   if ((INTEGRAL_TYPE_P (type) || POINTER_TYPE_P (type))\n       && TREE_TYPE (copy) != TREE_TYPE (var))\n     var = convert (type, var);\n@@ -1824,7 +1824,7 @@ tree\n create_label_decl (tree name)\n {\n   tree decl;\n-  decl = build_decl (LABEL_DECL, name, \n+  decl = build_decl (input_location, LABEL_DECL, name, \n \t\t     TREE_TYPE (return_address_type_node));\n   DECL_CONTEXT (decl) = current_function_decl;\n   DECL_IGNORED_P (decl) = 1;\n@@ -1907,7 +1907,7 @@ expand_java_switch (tree selector, int default_pc)\n   java_add_stmt (switch_expr);\n \n   x = build3 (CASE_LABEL_EXPR, void_type_node, NULL_TREE, NULL_TREE,\n-\t      create_artificial_label ());\n+\t      create_artificial_label (input_location));\n   append_to_statement_list (x, &SWITCH_BODY (switch_expr));\n \n   x = build1 (GOTO_EXPR, void_type_node, lookup_label (default_pc));\n@@ -1924,7 +1924,7 @@ expand_java_add_case (tree switch_expr, int match, int target_pc)\n   value = build_int_cst (TREE_TYPE (switch_expr), match);\n   \n   x = build3 (CASE_LABEL_EXPR, void_type_node, value, NULL_TREE,\n-\t      create_artificial_label ());\n+\t      create_artificial_label (input_location));\n   append_to_statement_list (x, &SWITCH_BODY (switch_expr));\n \n   x = build1 (GOTO_EXPR, void_type_node, lookup_label (target_pc));\n@@ -2026,7 +2026,7 @@ build_class_init (tree clas, tree expr)\n \t{\n \t  /* Build a declaration and mark it as a flag used to track\n \t     static class initializations. */\n-\t  decl = build_decl (VAR_DECL, NULL_TREE,\n+\t  decl = build_decl (input_location, VAR_DECL, NULL_TREE,\n \t\t\t     boolean_type_node);\n \t  MAYBE_CREATE_VAR_LANG_DECL_SPECIFIC (decl);\n \t  DECL_CONTEXT (decl) = current_function_decl;\n@@ -2666,12 +2666,13 @@ build_jni_stub (tree method)\n   DECL_ARTIFICIAL (method) = 1;\n   DECL_EXTERNAL (method) = 0;\n \n-  env_var = build_decl (VAR_DECL, get_identifier (\"env\"), ptr_type_node);\n+  env_var = build_decl (input_location,\n+\t\t\tVAR_DECL, get_identifier (\"env\"), ptr_type_node);\n   DECL_CONTEXT (env_var) = method;\n \n   if (TREE_TYPE (TREE_TYPE (method)) != void_type_node)\n     {\n-      res_var = build_decl (VAR_DECL, get_identifier (\"res\"),\n+      res_var = build_decl (input_location, VAR_DECL, get_identifier (\"res\"),\n \t\t\t    TREE_TYPE (TREE_TYPE (method)));\n       DECL_CONTEXT (res_var) = method;\n       TREE_CHAIN (env_var) = res_var;\n@@ -2745,7 +2746,8 @@ build_jni_stub (tree method)\n      garbage-collected.  If it is, we end up using canonical types\n      with different uids for equivalent function types, and this in\n      turn causes utf8 identifiers and output order to vary.  */\n-  meth_var = build_decl (VAR_DECL, get_identifier (\"meth\"), jni_func_type);\n+  meth_var = build_decl (input_location,\n+\t\t\t VAR_DECL, get_identifier (\"meth\"), jni_func_type);\n   TREE_STATIC (meth_var) = 1;\n   TREE_PUBLIC (meth_var) = 0;\n   DECL_EXTERNAL (meth_var) = 0;\n@@ -2971,7 +2973,8 @@ expand_java_field_op (int is_static, int is_putting, int field_ref_index)\n     }\n   else\n     {\n-      tree temp = build_decl (VAR_DECL, NULL_TREE, TREE_TYPE (field_ref));\n+      tree temp = build_decl (input_location,\n+\t\t\t      VAR_DECL, NULL_TREE, TREE_TYPE (field_ref));\n       java_add_local_var (temp);\n \n       if (TREE_THIS_VOLATILE (field_decl))\n@@ -3795,7 +3798,7 @@ force_evaluation_order (tree node)\n tree\n build_java_empty_stmt (void)\n {\n-  tree t = build_empty_stmt ();\n+  tree t = build_empty_stmt (input_location);\n   return t;\n }\n \n@@ -3832,7 +3835,7 @@ cache_cpool_data_ref (void)\n     {\n       tree cpool;\n       tree d = build_constant_data_ref (flag_indirect_classes);\n-      tree cpool_ptr = build_decl (VAR_DECL, NULL_TREE, \n+      tree cpool_ptr = build_decl (input_location, VAR_DECL, NULL_TREE, \n \t\t\t\t   build_pointer_type (TREE_TYPE (d)));\n       java_add_local_var (cpool_ptr);\n       TREE_CONSTANT (cpool_ptr) = 1;"}, {"sha": "c460e5b094187157bcd8fa197f1ad3f55c8fae86", "filename": "gcc/java/java-gimplify.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fjava%2Fjava-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fjava%2Fjava-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-gimplify.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -163,7 +163,7 @@ java_gimplify_block (tree java_block)\n \n   /* Don't bother with empty blocks.  */\n   if (! body)\n-    return build_empty_stmt ();\n+    return build_empty_stmt (input_location);\n \n   if (IS_EMPTY_STMT (body))\n     return body;"}, {"sha": "98352a2eaf2bfc461e636678a8dd923ebd48d514", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -1435,15 +1435,15 @@ extern tree *type_map;\n #define DECL_INNER_CLASS_LIST(NODE) DECL_INITIAL (TYPE_DECL_CHECK (NODE))\n \n /* Add a FIELD_DECL to RECORD_TYPE RTYPE.\n-   The field has name NAME (a char*), and type FTYPE.\n+   The field has name NAME (a char*), a type FTYPE, and a location of LOC.\n    Unless this is the first field, FIELD most hold the previous field.\n    FIELD is set to the newly created FIELD_DECL.\n \n    We set DECL_ARTIFICIAL so these fields get skipped by make_class_data\n    if compiling java.lang.Object or java.lang.Class. */\n \n-#define PUSH_FIELD(RTYPE, FIELD, NAME, FTYPE) \\\n-{ tree _field = build_decl (FIELD_DECL, get_identifier ((NAME)), (FTYPE)); \\\n+#define PUSH_FIELD(LOC, RTYPE, FIELD, NAME, FTYPE) \\\n+{ tree _field = build_decl (LOC, FIELD_DECL, get_identifier ((NAME)), (FTYPE)); \\\n   if (TYPE_FIELDS (RTYPE) == NULL_TREE)\t\\\n     TYPE_FIELDS (RTYPE) = _field; \t\\\n   else\t\t\t\t\t\\"}, {"sha": "98c98c8bd90769986db424d3231fa323a9ceacb7", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -1703,10 +1703,11 @@ java_emit_static_constructor (void)\n       tree name = get_identifier (\"_Jv_global_static_constructor\");\n \n       tree decl \n-\t= build_decl (FUNCTION_DECL, name,\n+\t= build_decl (input_location, FUNCTION_DECL, name,\n \t\t      build_function_type (void_type_node, void_list_node));\n \n-      tree resdecl = build_decl (RESULT_DECL, NULL_TREE, void_type_node);\n+      tree resdecl = build_decl (input_location,\n+\t\t\t\t RESULT_DECL, NULL_TREE, void_type_node);\n       DECL_ARTIFICIAL (resdecl) = 1;\n       DECL_RESULT (decl) = resdecl;\n       current_function_decl = decl;\n@@ -1835,7 +1836,8 @@ java_parse_file (int set_yydebug ATTRIBUTE_UNUSED)\n \t    duplicate_class_warning (IDENTIFIER_POINTER (node));\n \t  else\n \t    {\n-\t      tree file_decl = build_decl (TRANSLATION_UNIT_DECL, node, NULL);\n+\t      tree file_decl = build_decl (input_location,\n+\t\t\t\t\t   TRANSLATION_UNIT_DECL, node, NULL);\n \t      TREE_CHAIN (file_decl) = current_file_list;\n \t      current_file_list = file_decl;\n \t      IS_A_COMMAND_LINE_FILENAME_P (node) = 1;"}, {"sha": "550e1d505d8d11185eb52de1cfcfab95dcd87107", "filename": "gcc/java/resource.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fjava%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fjava%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fresource.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -59,9 +59,11 @@ compile_resource_data (const char *name, const char *buffer, int length)\n   data_type = build_prim_array_type (unsigned_byte_type_node,\n \t\t\t\t     strlen (name) + length);\n   rtype = make_node (RECORD_TYPE);\n-  PUSH_FIELD (rtype, field, \"name_length\", unsigned_int_type_node);\n-  PUSH_FIELD (rtype, field, \"resource_length\", unsigned_int_type_node);\n-  PUSH_FIELD (rtype, field, \"data\", data_type);\n+  PUSH_FIELD (input_location,\n+\t      rtype, field, \"name_length\", unsigned_int_type_node);\n+  PUSH_FIELD (input_location,\n+\t      rtype, field, \"resource_length\", unsigned_int_type_node);\n+  PUSH_FIELD (input_location, rtype, field, \"data\", data_type);\n   FINISH_RECORD (rtype);\n   START_RECORD_CONSTRUCTOR (rinit, rtype);\n   PUSH_FIELD_VALUE (rinit, \"name_length\", \n@@ -74,7 +76,8 @@ compile_resource_data (const char *name, const char *buffer, int length)\n   FINISH_RECORD_CONSTRUCTOR (rinit);\n   TREE_CONSTANT (rinit) = 1;\n \n-  decl = build_decl (VAR_DECL, java_mangle_resource_name (name), rtype);\n+  decl = build_decl (input_location,\n+\t\t     VAR_DECL, java_mangle_resource_name (name), rtype);\n   TREE_STATIC (decl) = 1;\n   TREE_PUBLIC (decl) = 1;\n   java_hide_decl (decl);\n@@ -100,7 +103,8 @@ write_resource_constructor (tree *list_p)\n     return;\n \n   t = build_function_type_list (void_type_node, ptr_type_node, NULL);\n-  t = build_decl (FUNCTION_DECL, get_identifier (\"_Jv_RegisterResource\"), t);\n+  t = build_decl (input_location,\n+\t\t  FUNCTION_DECL, get_identifier (\"_Jv_RegisterResource\"), t);\n   TREE_PUBLIC (t) = 1;\n   DECL_EXTERNAL (t) = 1;\n   register_resource_fn = t;"}, {"sha": "c16976ca3b0a8a772234bc8430aabfa5a4ed1950", "filename": "gcc/java/typeck.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fjava%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fjava%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Ftypeck.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -347,7 +347,7 @@ build_java_array_type (tree element_type, HOST_WIDE_INT length)\n       strcpy (suffix, \"[]\");\n     TYPE_NAME (t) \n       = TYPE_STUB_DECL (t)\n-      = build_decl (TYPE_DECL,\n+      = build_decl (input_location, TYPE_DECL,\n \t\t    identifier_subst (el_name, \"\", '.', '.', suffix),\n                              t);\n     TYPE_DECL_SUPPRESS_DEBUG (TYPE_STUB_DECL (t)) = true;\n@@ -360,15 +360,17 @@ build_java_array_type (tree element_type, HOST_WIDE_INT length)\n   TYPE_ARRAY_ELEMENT (t) = element_type;\n \n   /* Add length pseudo-field. */\n-  fld = build_decl (FIELD_DECL, get_identifier (\"length\"), int_type_node);\n+  fld = build_decl (input_location,\n+\t\t    FIELD_DECL, get_identifier (\"length\"), int_type_node);\n   TYPE_FIELDS (t) = fld;\n   DECL_CONTEXT (fld) = t;\n   FIELD_PUBLIC (fld) = 1;\n   FIELD_FINAL (fld) = 1;\n   TREE_READONLY (fld) = 1;\n \n   atype = build_prim_array_type (element_type, length);\n-  arfld = build_decl (FIELD_DECL, get_identifier (\"data\"), atype);\n+  arfld = build_decl (input_location,\n+\t\t      FIELD_DECL, get_identifier (\"data\"), atype);\n   DECL_CONTEXT (arfld) = t;\n   TREE_CHAIN (fld) = arfld;\n   DECL_ALIGN (arfld) = TYPE_ALIGN (element_type);"}, {"sha": "85d77a8856c3e4430244713cdb68dd0c6e5f0660", "filename": "gcc/langhooks.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Flanghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Flanghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -432,7 +432,7 @@ lhd_print_error_function (diagnostic_context *context, const char *file,\n \t\t  pp_newline (context->printer);\n \t\t  if (s.file != NULL)\n \t\t    {\n-\t\t      if (flag_show_column && s.column != 0)\n+\t\t      if (flag_show_column)\n \t\t\tpp_printf (context->printer,\n \t\t\t\t   _(\"    inlined from %qs at %s:%d:%d\"),\n \t\t\t\t   identifier_to_locale (lang_hooks.decl_printable_name (fndecl, 2)),\n@@ -524,7 +524,7 @@ add_builtin_function_common (const char *name,\n \t\t\t     tree (*hook) (tree))\n {\n   tree   id = get_identifier (name);\n-  tree decl = build_decl (FUNCTION_DECL, id, type);\n+  tree decl = build_decl (BUILTINS_LOCATION, FUNCTION_DECL, id, type);\n \n   TREE_PUBLIC (decl)         = 1;\n   DECL_EXTERNAL (decl)       = 1;"}, {"sha": "5aaa3b747223159bb8ccdbebc6e98d7a8f3e5980", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -1,3 +1,31 @@\n+2009-06-12  Aldy Hernandez  <aldyh@redhat.com>\n+\t\n+\t* objc-act.c (finish_var_decl): Pass location to finish_decl.\n+\t(objc_get_parm_info): Same.\n+\t(get_super_receiver): Same.\n+\t* objc-act.c (objc_build_component_ref): Pass location to\n+\tbuild_compound_ref.\n+\t(build_module_initializer_routine): Pass location to\n+\tc_end_compound_stmt.\n+\t(objc_generate_static_init_call): Pass location to build_stmt.\n+\t(build_typed_selector_reference): New location argument.\n+\t(build_selector_reference): Same.\n+\t(objc_substitute_decl): Pass location to build_array_ref.\n+\t(next_sjlj_build_try_catch_finally): Pass location to build_stmt.\n+\t(objc_begin_catch_clause): Same.\n+\t(objc_finish_try_stmt): Same.\n+\t(objc_finish_catch_clause): Pass location to c_end_compound_stmt.\n+\t(objc_build_throw_stmt): New argument.\n+\t(generate_shared_structures): Pass location to build_c_cast.\n+\t(objc_build_message_expr): Use local location.\n+\t(objc_finish_message_expr): Use input_location.\n+\t(build_objc_method_call): New argument.\n+\t(objc_build_selector_expr): Same.\n+\t(get_super_receiver): Pass location to build_c_cast,\n+\tbuild_modify_expr, build_compound_expr.\n+\t* objc-act.c: Add location to all calls to start_struct, build_decl,\n+\tfinish_struct.\n+\t\n 2009-06-09  Ian Lance Taylor  <iant@google.com>\n \n \t* objc-act.c (objc_gimplify_expr): Change return type to int."}, {"sha": "0c91faa53634f9b0f475aa8757cc281798cbaf66", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 156, "deletions": 97, "changes": 253, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -151,7 +151,7 @@ static void finish_objc (void);\n /* Code generation.  */\n \n static tree objc_build_constructor (tree, tree);\n-static tree build_objc_method_call (int, tree, tree, tree, tree);\n+static tree build_objc_method_call (location_t, int, tree, tree, tree, tree);\n static tree get_proto_encoding (tree);\n static tree lookup_interface (tree);\n static tree objc_add_static_instance (tree, tree);\n@@ -430,8 +430,8 @@ objc_start_struct (tree name)\n {\n   gcc_assert (!objc_building_struct);\n   objc_building_struct = true;\n-  return start_struct (RECORD_TYPE, name, &objc_in_struct, &objc_struct_types,\n-\t\t       UNKNOWN_LOCATION);\n+  return start_struct (input_location, RECORD_TYPE, \n+\t\t       name, &objc_in_struct, &objc_struct_types);\n }\n \n /* Finish building a struct for objc.  */\n@@ -441,8 +441,8 @@ objc_finish_struct (tree type, tree fieldlist)\n {\n   gcc_assert (objc_building_struct);\n   objc_building_struct = false;\n-  return finish_struct (type, fieldlist, NULL_TREE, objc_in_struct,\n-\t\t\tobjc_struct_types);\n+  return finish_struct (input_location, type, fieldlist, NULL_TREE,\n+\t\t\tobjc_in_struct, objc_struct_types);\n }\n \n /* Some platforms pass small structures through registers versus\n@@ -826,7 +826,8 @@ objc_build_struct (tree klass, tree fields, tree super_name)\n     {\n       /* Prepend a packed variant of the base class into the layout.  This\n \t is necessary to preserve ObjC ABI compatibility.  */\n-      tree base = build_decl (FIELD_DECL, NULL_TREE, super);\n+      tree base = build_decl (input_location,\n+\t\t\t      FIELD_DECL, NULL_TREE, super);\n       tree field = TYPE_FIELDS (super);\n \n       while (field && TREE_CHAIN (field)\n@@ -1287,7 +1288,7 @@ objc_build_component_ref (tree datum, tree component)\n   return finish_class_member_access_expr (datum, component, false,\n                                           tf_warning_or_error);\n #else\n-  return build_component_ref (datum, component);\n+  return build_component_ref (input_location, datum, component);\n #endif\n }\n \n@@ -1482,7 +1483,8 @@ lookup_and_install_protocols (tree protocols)\n static tree\n create_field_decl (tree type, const char *name)\n {\n-  return build_decl (FIELD_DECL, get_identifier (name), type);\n+  return build_decl (input_location,\n+\t\t     FIELD_DECL, get_identifier (name), type);\n }\n \n /* Create a global, static declaration for variable NAME of a given TYPE.  The\n@@ -1491,7 +1493,8 @@ create_field_decl (tree type, const char *name)\n static tree\n start_var_decl (tree type, const char *name)\n {\n-  tree var = build_decl (VAR_DECL, get_identifier (name), type);\n+  tree var = build_decl (input_location,\n+\t\t\t VAR_DECL, get_identifier (name), type);\n \n   TREE_STATIC (var) = 1;\n   DECL_INITIAL (var) = error_mark_node;  /* A real initializer is coming... */\n@@ -1510,7 +1513,7 @@ start_var_decl (tree type, const char *name)\n static void\n finish_var_decl (tree var, tree initializer)\n {\n-  finish_decl (var, initializer, NULL_TREE, NULL_TREE);\n+  finish_decl (var, input_location, initializer, NULL_TREE, NULL_TREE);\n   /* Ensure that the variable actually gets output.  */\n   mark_decl_referenced (var);\n   /* Mark the decl to avoid \"defined but not used\" warning.  */\n@@ -1581,11 +1584,13 @@ synth_module_prologue (void)\n \n   /* Declare the 'id' and 'Class' typedefs.  */\n \n-  type = lang_hooks.decls.pushdecl (build_decl (TYPE_DECL,\n+  type = lang_hooks.decls.pushdecl (build_decl (input_location,\n+\t\t\t\t\t\tTYPE_DECL,\n \t\t\t\t\t\tobjc_object_name,\n \t\t\t\t\t\tobjc_object_type));\n   TREE_NO_WARNING (type) = 1;\n-  type = lang_hooks.decls.pushdecl (build_decl (TYPE_DECL,\n+  type = lang_hooks.decls.pushdecl (build_decl (input_location,\n+\t\t\t\t\t\tTYPE_DECL,\n \t\t\t\t\t\tobjc_class_name,\n \t\t\t\t\t\tobjc_class_type));\n   TREE_NO_WARNING (type) = 1;\n@@ -1843,11 +1848,14 @@ static tree\n objc_build_internal_const_str_type (void)\n {\n   tree type = (*lang_hooks.types.make_type) (RECORD_TYPE);\n-  tree fields = build_decl (FIELD_DECL, NULL_TREE, ptr_type_node);\n-  tree field = build_decl (FIELD_DECL, NULL_TREE, ptr_type_node);\n+  tree fields = build_decl (input_location,\n+\t\t\t    FIELD_DECL, NULL_TREE, ptr_type_node);\n+  tree field = build_decl (input_location,\n+\t\t\t   FIELD_DECL, NULL_TREE, ptr_type_node);\n \n   TREE_CHAIN (field) = fields; fields = field;\n-  field = build_decl (FIELD_DECL, NULL_TREE, unsigned_type_node);\n+  field = build_decl (input_location,\n+\t\t      FIELD_DECL, NULL_TREE, unsigned_type_node);\n   TREE_CHAIN (field) = fields; fields = field;\n   /* NB: The finish_builtin_struct() routine expects FIELD_DECLs in\n      reverse order!  */\n@@ -1990,7 +1998,8 @@ objc_build_string_object (tree string)\n \t  = objc_add_static_instance (constructor, constant_string_type);\n       else\n         {\n-\t  var = build_decl (CONST_DECL, NULL, TREE_TYPE (constructor));\n+\t  var = build_decl (input_location,\n+\t\t\t    CONST_DECL, NULL, TREE_TYPE (constructor));\n \t  DECL_INITIAL (var) = constructor;\n \t  TREE_STATIC (var) = 1;\n \t  pushdecl_top_level (var);\n@@ -2028,7 +2037,8 @@ objc_add_static_instance (tree constructor, tree class_decl)\n     }\n \n   sprintf (buf, \"_OBJC_INSTANCE_%d\", num_static_inst++);\n-  decl = build_decl (VAR_DECL, get_identifier (buf), class_decl);\n+  decl = build_decl (input_location,\n+\t\t     VAR_DECL, get_identifier (buf), class_decl);\n   DECL_COMMON (decl) = 1;\n   TREE_STATIC (decl) = 1;\n   DECL_ARTIFICIAL (decl) = 1;\n@@ -2371,20 +2381,22 @@ build_module_initializer_routine (void)\n   push_lang_context (lang_name_c); /* extern \"C\" */\n #endif\n \n-  objc_push_parm (build_decl (PARM_DECL, NULL_TREE, void_type_node));\n+  objc_push_parm (build_decl (input_location,\n+\t\t\t      PARM_DECL, NULL_TREE, void_type_node));\n   objc_start_function (get_identifier (TAG_GNUINIT),\n \t\t       build_function_type (void_type_node,\n \t\t\t\t\t    OBJC_VOID_AT_END),\n \t\t       NULL_TREE, objc_get_parm_info (0));\n \n   body = c_begin_compound_stmt (true);\n   add_stmt (build_function_call\n-\t    (execclass_decl,\n+\t    (input_location,\n+\t     execclass_decl,\n \t     build_tree_list\n \t     (NULL_TREE,\n \t      build_unary_op (input_location, ADDR_EXPR,\n \t\t\t      UOBJC_MODULES_decl, 0))));\n-  add_stmt (c_end_compound_stmt (body, true));\n+  add_stmt (c_end_compound_stmt (input_location, body, true));\n \n   TREE_PUBLIC (current_function_decl) = 0;\n \n@@ -2417,8 +2429,9 @@ objc_static_init_needed_p (void)\n tree\n objc_generate_static_init_call (tree ctors ATTRIBUTE_UNUSED)\n {\n-  add_stmt (build_stmt (EXPR_STMT,\n-\t\t\tbuild_function_call (GNU_INIT_decl, NULL_TREE)));\n+  add_stmt (build_stmt (input_location, EXPR_STMT,\n+\t\t\tbuild_function_call (input_location,\n+\t\t\t\t\t     GNU_INIT_decl, NULL_TREE)));\n \n   return ctors;\n }\n@@ -2647,10 +2660,11 @@ get_proto_encoding (tree proto)\n }\n \n /* sel_ref_chain is a list whose \"value\" fields will be instances of\n-   identifier_node that represent the selector.  */\n+   identifier_node that represent the selector.  LOC is the location of\n+   the @selector.  */\n \n static tree\n-build_typed_selector_reference (tree ident, tree prototype)\n+build_typed_selector_reference (location_t loc, tree ident, tree prototype)\n {\n   tree *chain = &sel_ref_chain;\n   tree expr;\n@@ -2668,16 +2682,15 @@ build_typed_selector_reference (tree ident, tree prototype)\n   *chain = tree_cons (prototype, ident, NULL_TREE);\n \n  return_at_index:\n-  expr = build_unary_op (input_location, ADDR_EXPR,\n-\t\t\t build_array_ref (UOBJC_SELECTOR_TABLE_decl,\n-\t\t\t\t\t  build_int_cst (NULL_TREE, index),\n-\t\t\t\t\t  input_location),\n+  expr = build_unary_op (loc, ADDR_EXPR,\n+\t\t\t build_array_ref (loc, UOBJC_SELECTOR_TABLE_decl,\n+\t\t\t\t\t  build_int_cst (NULL_TREE, index)),\n \t\t\t 1);\n   return convert (objc_selector_type, expr);\n }\n \n static tree\n-build_selector_reference (tree ident)\n+build_selector_reference (location_t loc, tree ident)\n {\n   tree *chain = &sel_ref_chain;\n   tree expr;\n@@ -2688,9 +2701,8 @@ build_selector_reference (tree ident)\n       if (TREE_VALUE (*chain) == ident)\n \treturn (flag_next_runtime\n \t\t? TREE_PURPOSE (*chain)\n-\t\t: build_array_ref (UOBJC_SELECTOR_TABLE_decl,\n-\t\t\t\t   build_int_cst (NULL_TREE, index),\n-\t\t\t\t   input_location));\n+\t\t: build_array_ref (loc, UOBJC_SELECTOR_TABLE_decl,\n+\t\t\t\t   build_int_cst (NULL_TREE, index)));\n \n       index++;\n       chain = &TREE_CHAIN (*chain);\n@@ -2702,9 +2714,8 @@ build_selector_reference (tree ident)\n \n   return (flag_next_runtime\n \t  ? expr\n-\t  : build_array_ref (UOBJC_SELECTOR_TABLE_decl,\n-\t\t\t     build_int_cst (NULL_TREE, index),\n-\t\t\t     input_location));\n+\t  : build_array_ref (loc, UOBJC_SELECTOR_TABLE_decl,\n+\t\t\t     build_int_cst (NULL_TREE, index)));\n }\n \n static GTY(()) int class_reference_idx;\n@@ -2816,7 +2827,7 @@ objc_get_class_reference (tree ident)\n \t\t\t\t IDENTIFIER_POINTER (ident)));\n \n       assemble_external (objc_get_class_decl);\n-      return build_function_call (objc_get_class_decl, params);\n+      return build_function_call (input_location, objc_get_class_decl, params);\n     }\n }\n \n@@ -2884,7 +2895,8 @@ build_objc_string_decl (enum string_section section)\n \n   ident = get_identifier (buf);\n \n-  decl = build_decl (VAR_DECL, ident, build_array_type (char_type_node, 0));\n+  decl = build_decl (input_location,\n+\t\t     VAR_DECL, ident, build_array_type (char_type_node, 0));\n   DECL_EXTERNAL (decl) = 1;\n   TREE_PUBLIC (decl) = 0;\n   TREE_USED (decl) = 1;\n@@ -2924,7 +2936,8 @@ objc_declare_alias (tree alias_ident, tree class_ident)\n       push_lang_context (lang_name_c); /* extern \"C\" */\n #endif\n       lang_hooks.decls.pushdecl (build_decl\n-\t\t\t\t (TYPE_DECL,\n+\t\t\t\t (input_location,\n+\t\t\t\t  TYPE_DECL,\n \t\t\t\t  alias_ident,\n \t\t\t\t  xref_tag (RECORD_TYPE, underlying_class)));\n #ifdef OBJCPLUS\n@@ -3088,11 +3101,11 @@ objc_substitute_decl (tree expr, tree oldexpr, tree newexpr)\n \t\t\t\t    newexpr),\n \t      DECL_NAME (TREE_OPERAND (expr, 1)));\n     case ARRAY_REF:\n-      return build_array_ref (objc_substitute_decl (TREE_OPERAND (expr, 0),\n+      return build_array_ref (input_location,\n+\t\t\t      objc_substitute_decl (TREE_OPERAND (expr, 0),\n \t\t\t\t\t\t    oldexpr,\n \t\t\t\t\t\t    newexpr),\n-\t\t\t      TREE_OPERAND (expr, 1),\n-\t\t\t      input_location);\n+\t\t\t      TREE_OPERAND (expr, 1));\n     case INDIRECT_REF:\n       return build_indirect_ref (input_location,\n \t\t\t\t objc_substitute_decl (TREE_OPERAND (expr, 0),\n@@ -3129,7 +3142,7 @@ objc_build_ivar_assignment (tree outervar, tree lhs, tree rhs)\n \t\t    NULL_TREE)));\n \n   assemble_external (func);\n-  return build_function_call (func, func_params);\n+  return build_function_call (input_location, func, func_params);\n }\n \n static tree\n@@ -3142,7 +3155,8 @@ objc_build_global_assignment (tree lhs, tree rhs)\n \t\t    NULL_TREE));\n \n   assemble_external (objc_assign_global_decl);\n-  return build_function_call (objc_assign_global_decl, func_params);\n+  return build_function_call (input_location, \n+\t\t\t      objc_assign_global_decl, func_params);\n }\n \n static tree\n@@ -3155,7 +3169,8 @@ objc_build_strong_cast_assignment (tree lhs, tree rhs)\n \t\t    NULL_TREE));\n \n   assemble_external (objc_assign_strong_cast_decl);\n-  return build_function_call (objc_assign_strong_cast_decl, func_params);\n+  return build_function_call (input_location,\n+\t\t\t      objc_assign_strong_cast_decl, func_params);\n }\n \n static int\n@@ -3422,7 +3437,8 @@ objc_create_temporary_var (tree type)\n {\n   tree decl;\n \n-  decl = build_decl (VAR_DECL, NULL_TREE, type);\n+  decl = build_decl (input_location,\n+\t\t     VAR_DECL, NULL_TREE, type);\n   TREE_USED (decl) = 1;\n   DECL_ARTIFICIAL (decl) = 1;\n   DECL_IGNORED_P (decl) = 1;\n@@ -3542,7 +3558,8 @@ next_sjlj_build_try_exit (void)\n   tree t;\n   t = build_fold_addr_expr (cur_try_context->stack_decl);\n   t = tree_cons (NULL, t, NULL);\n-  t = build_function_call (objc_exception_try_exit_decl, t);\n+  t = build_function_call (input_location,\n+\t\t\t   objc_exception_try_exit_decl, t);\n   return t;\n }\n \n@@ -3562,7 +3579,8 @@ next_sjlj_build_enter_and_setjmp (void)\n \n   t = build_fold_addr_expr (cur_try_context->stack_decl);\n   t = tree_cons (NULL, t, NULL);\n-  enter = build_function_call (objc_exception_try_enter_decl, t);\n+  enter = build_function_call (input_location,\n+\t\t\t       objc_exception_try_enter_decl, t);\n \n   t = objc_build_component_ref (cur_try_context->stack_decl,\n \t\t\t\tget_identifier (\"buf\"));\n@@ -3577,7 +3595,8 @@ next_sjlj_build_enter_and_setjmp (void)\n   t = convert (ptr_type_node, t);\n #endif\n   t = tree_cons (NULL, t, NULL);\n-  sj = build_function_call (objc_setjmp_decl, t);\n+  sj = build_function_call (input_location,\n+\t\t\t    objc_setjmp_decl, t);\n \n   cond = build2 (COMPOUND_EXPR, TREE_TYPE (sj), enter, sj);\n   cond = c_common_truthvalue_conversion (input_location, cond);\n@@ -3596,7 +3615,8 @@ next_sjlj_build_exc_extract (tree decl)\n \n   t = build_fold_addr_expr (cur_try_context->stack_decl);\n   t = tree_cons (NULL, t, NULL);\n-  t = build_function_call (objc_exception_extract_decl, t);\n+  t = build_function_call (input_location,\n+\t\t\t   objc_exception_extract_decl, t);\n   t = convert (TREE_TYPE (decl), t);\n   t = build2 (MODIFY_EXPR, void_type_node, decl, t);\n \n@@ -3646,7 +3666,8 @@ next_sjlj_build_catch_list (void)\n \t      args = tree_cons (NULL, cur_try_context->caught_decl, NULL);\n \t      t = objc_get_class_reference (OBJC_TYPE_NAME (TREE_TYPE (type)));\n \t      args = tree_cons (NULL, t, args);\n-\t      t = build_function_call (objc_exception_match_decl, args);\n+\t      t = build_function_call (input_location,\n+\t\t\t\t       objc_exception_match_decl, args);\n \t      cond = c_common_truthvalue_conversion (input_location, t);\n \t    }\n \t  t = build3 (COND_EXPR, void_type_node, cond, body, NULL);\n@@ -3744,7 +3765,7 @@ next_sjlj_build_try_catch_finally (void)\n   if (cur_try_context->catch_list)\n     {\n       tree caught_decl = objc_build_exc_ptr ();\n-      catch_seq = build_stmt (BIND_EXPR, caught_decl, NULL, NULL);\n+      catch_seq = build_stmt (input_location, BIND_EXPR, caught_decl, NULL, NULL);\n       TREE_SIDE_EFFECTS (catch_seq) = 1;\n \n       t = next_sjlj_build_exc_extract (caught_decl);\n@@ -3768,7 +3789,7 @@ next_sjlj_build_try_catch_finally (void)\n \n   /* Build the complete FINALLY statement list.  */\n   t = next_sjlj_build_try_exit ();\n-  t = build_stmt (COND_EXPR,\n+  t = build_stmt (input_location, COND_EXPR,\n \t\t  c_common_truthvalue_conversion \n \t\t    (input_location, rethrow_decl),\n \t\t  NULL, t);\n@@ -3779,8 +3800,9 @@ next_sjlj_build_try_catch_finally (void)\n \t\t\t    &TREE_OPERAND (try_fin, 1));\n \n   t = tree_cons (NULL, rethrow_decl, NULL);\n-  t = build_function_call (objc_exception_throw_decl, t);\n-  t = build_stmt (COND_EXPR,\n+  t = build_function_call (input_location,\n+\t\t\t   objc_exception_throw_decl, t);\n+  t = build_stmt (input_location, COND_EXPR,\n \t\t  c_common_truthvalue_conversion (input_location, \n \t\t\t\t\t\t  rethrow_decl),\n \t\t  t, NULL);\n@@ -3822,7 +3844,8 @@ objc_begin_catch_clause (tree decl)\n   compound = c_begin_compound_stmt (true);\n \n   /* The parser passed in a PARM_DECL, but what we really want is a VAR_DECL.  */\n-  decl = build_decl (VAR_DECL, DECL_NAME (decl), TREE_TYPE (decl));\n+  decl = build_decl (input_location,\n+\t\t     VAR_DECL, DECL_NAME (decl), TREE_TYPE (decl));\n   lang_hooks.decls.pushdecl (decl);\n \n   /* Since a decl is required here by syntax, don't warn if its unused.  */\n@@ -3865,7 +3888,7 @@ objc_begin_catch_clause (tree decl)\n \n   /* Record the data for the catch in the try context so that we can\n      finalize it later.  */\n-  t = build_stmt (CATCH_EXPR, type, compound);\n+  t = build_stmt (input_location, CATCH_EXPR, type, compound);\n   cur_try_context->current_catch = t;\n \n   /* Initialize the decl from the EXC_PTR_EXPR we get from the runtime.  */\n@@ -3885,7 +3908,7 @@ objc_finish_catch_clause (void)\n   cur_try_context->current_catch = NULL;\n   cur_try_context->end_catch_locus = input_location;\n \n-  CATCH_BODY (c) = c_end_compound_stmt (CATCH_BODY (c), 1);\n+  CATCH_BODY (c) = c_end_compound_stmt (input_location, CATCH_BODY (c), 1);\n   append_to_statement_list (c, &cur_try_context->catch_list);\n }\n \n@@ -3930,12 +3953,12 @@ objc_finish_try_stmt (void)\n       stmt = c->try_body;\n       if (c->catch_list)\n \t{\n-          stmt = build_stmt (TRY_CATCH_EXPR, stmt, c->catch_list);\n+          stmt = build_stmt (input_location, TRY_CATCH_EXPR, stmt, c->catch_list);\n \t  SET_EXPR_LOCATION (stmt, cur_try_context->try_locus);\n \t}\n       if (c->finally_body)\n \t{\n-\t  stmt = build_stmt (TRY_FINALLY_EXPR, stmt, c->finally_body);\n+\t  stmt = build_stmt (input_location, TRY_FINALLY_EXPR, stmt, c->finally_body);\n \t  SET_EXPR_LOCATION (stmt, cur_try_context->try_locus);\n \t}\n     }\n@@ -3947,7 +3970,7 @@ objc_finish_try_stmt (void)\n }\n \n tree\n-objc_build_throw_stmt (tree throw_expr)\n+objc_build_throw_stmt (location_t loc, tree throw_expr)\n {\n   tree args;\n \n@@ -3960,7 +3983,7 @@ objc_build_throw_stmt (tree throw_expr)\n       if (cur_try_context == NULL\n           || cur_try_context->current_catch == NULL)\n \t{\n-\t  error (\"%<@throw%> (rethrow) used outside of a @catch block\");\n+\t  error_at (loc, \"%<@throw%> (rethrow) used outside of a @catch block\");\n \t  return NULL_TREE;\n \t}\n \n@@ -3972,7 +3995,8 @@ objc_build_throw_stmt (tree throw_expr)\n   /* A throw is just a call to the runtime throw function with the\n      object as a parameter.  */\n   args = tree_cons (NULL, throw_expr, NULL);\n-  return add_stmt (build_function_call (objc_exception_throw_decl, args));\n+  return add_stmt (build_function_call (loc,\n+\t\t\t\t\tobjc_exception_throw_decl, args));\n }\n \n tree\n@@ -3983,13 +4007,15 @@ objc_build_synchronized (location_t start_locus, tree mutex, tree body)\n   /* First lock the mutex.  */\n   mutex = save_expr (mutex);\n   args = tree_cons (NULL, mutex, NULL);\n-  call = build_function_call (objc_sync_enter_decl, args);\n+  call = build_function_call (input_location,\n+\t\t\t      objc_sync_enter_decl, args);\n   SET_EXPR_LOCATION (call, start_locus);\n   add_stmt (call);\n \n   /* Build the mutex unlock.  */\n   args = tree_cons (NULL, mutex, NULL);\n-  call = build_function_call (objc_sync_exit_decl, args);\n+  call = build_function_call (input_location,\n+\t\t\t      objc_sync_exit_decl, args);\n   SET_EXPR_LOCATION (call, input_location);\n \n   /* Put the that and the body in a TRY_FINALLY.  */\n@@ -5792,13 +5818,14 @@ generate_shared_structures (int cls_flags)\n   if (my_super_id)\n     {\n       super_expr = add_objc_string (my_super_id, class_names);\n-      super_expr = build_c_cast (cast_type, super_expr); /* cast! */\n+      super_expr = build_c_cast (input_location,\n+\t\t\t\t cast_type, super_expr); /* cast! */\n     }\n   else\n     super_expr = build_int_cst (NULL_TREE, 0);\n \n   root_expr = add_objc_string (my_root_id, class_names);\n-  root_expr = build_c_cast (cast_type, root_expr); /* cast! */\n+  root_expr = build_c_cast (input_location, cast_type, root_expr); /* cast! */\n \n   if (CLASS_PROTOCOL_LIST (implementation_template))\n     {\n@@ -6234,6 +6261,7 @@ tree\n objc_build_message_expr (tree mess)\n {\n   tree receiver = TREE_PURPOSE (mess);\n+  location_t loc;\n   tree sel_name;\n #ifdef OBJCPLUS\n   tree args = TREE_PURPOSE (TREE_VALUE (mess));\n@@ -6245,6 +6273,11 @@ objc_build_message_expr (tree mess)\n   if (TREE_CODE (receiver) == ERROR_MARK)\n     return error_mark_node;\n \n+  if (CAN_HAVE_LOCATION_P (receiver))\n+    loc = EXPR_LOCATION (receiver);\n+  else\n+    loc = input_location;\n+\n   /* Obtain the full selector name.  */\n   if (TREE_CODE (args) == IDENTIFIER_NODE)\n     /* A unary selector.  */\n@@ -6501,9 +6534,12 @@ objc_finish_message_expr (tree receiver, tree sel_name, tree method_params)\n \n       if (!warn_missing_methods)\n \t{\n-\t  warning (0, \"(Messages without a matching method signature\");\n-\t  warning (0, \"will be assumed to return %<id%> and accept\");\n-\t  warning (0, \"%<...%> as arguments.)\");\n+\t  warning_at (input_location, \n+\t\t      0, \"(Messages without a matching method signature\");\n+\t  warning_at (input_location, \n+\t\t      0, \"will be assumed to return %<id%> and accept\");\n+\t  warning_at (input_location, \n+\t\t      0, \"%<...%> as arguments.)\");\n \t  warn_missing_methods = true;\n \t}\n     }\n@@ -6515,11 +6551,12 @@ objc_finish_message_expr (tree receiver, tree sel_name, tree method_params)\n      These are the object itself and the selector.  */\n \n   if (flag_typed_selectors)\n-    selector = build_typed_selector_reference (sel_name, method_prototype);\n+    selector = build_typed_selector_reference (input_location,\n+\t\t\t\t\t       sel_name, method_prototype);\n   else\n-    selector = build_selector_reference (sel_name);\n+    selector = build_selector_reference (input_location, sel_name);\n \n-  retval = build_objc_method_call (super, method_prototype,\n+  retval = build_objc_method_call (input_location, super, method_prototype,\n \t\t\t\t   receiver,\n \t\t\t\t   selector, method_params);\n \n@@ -6532,11 +6569,12 @@ objc_finish_message_expr (tree receiver, tree sel_name, tree method_params)\n    looking up the method on object LOOKUP_OBJECT (often same as OBJECT),\n    assuming the method has prototype METHOD_PROTOTYPE.\n    (That is an INSTANCE_METHOD_DECL or CLASS_METHOD_DECL.)\n+   LOC is the location of the expression to build.\n    Use METHOD_PARAMS as list of args to pass to the method.\n    If SUPER_FLAG is nonzero, we look up the superclass's method.  */\n \n static tree\n-build_objc_method_call (int super_flag, tree method_prototype,\n+build_objc_method_call (location_t loc, int super_flag, tree method_prototype,\n \t\t\ttree lookup_object, tree selector,\n \t\t\ttree method_params)\n {\n@@ -6563,7 +6601,7 @@ build_objc_method_call (int super_flag, tree method_prototype,\n \t(method_prototype, METHOD_REF, super_flag)));\n   tree method, t;\n \n-  lookup_object = build_c_cast (rcv_p, lookup_object);\n+  lookup_object = build_c_cast (loc, rcv_p, lookup_object);\n \n   /* Use SAVE_EXPR to avoid evaluating the receiver twice.  */\n   lookup_object = save_expr (lookup_object);\n@@ -6599,7 +6637,8 @@ build_objc_method_call (int super_flag, tree method_prototype,\n \n       t = tree_cons (NULL_TREE, selector, NULL_TREE);\n       t = tree_cons (NULL_TREE, lookup_object, t);\n-      method = build_function_call (sender, t);\n+      method = build_function_call (loc,\n+\t\t\t\t    sender, t);\n \n       /* Pass the object to the method.  */\n       method_params = tree_cons (NULL_TREE, object,\n@@ -6610,7 +6649,8 @@ build_objc_method_call (int super_flag, tree method_prototype,\n   /* ??? Selector is not at this point something we can use inside\n      the compiler itself.  Set it to garbage for the nonce.  */\n   t = build3 (OBJ_TYPE_REF, sender_cast, method, lookup_object, size_zero_node);\n-  return build_function_call (t, method_params);\n+  return build_function_call (loc,\n+\t\t\t      t, method_params);\n }\n \f\n static void\n@@ -6701,9 +6741,10 @@ objc_build_protocol_expr (tree protoname)\n \n /* This function is called by the parser when a @selector() expression\n    is found, in order to compile it.  It is only called by the parser\n-   and only to compile a @selector().  */\n+   and only to compile a @selector().  LOC is the location of the\n+   @selector.  */\n tree\n-objc_build_selector_expr (tree selnamelist)\n+objc_build_selector_expr (location_t loc, tree selnamelist)\n {\n   tree selname;\n \n@@ -6743,9 +6784,9 @@ objc_build_selector_expr (tree selnamelist)\n \n \n   if (flag_typed_selectors)\n-    return build_typed_selector_reference (selname, 0);\n+    return build_typed_selector_reference (loc, selname, 0);\n   else\n-    return build_selector_reference (selname);\n+    return build_selector_reference (loc, selname);\n }\n \n tree\n@@ -8363,7 +8404,7 @@ objc_get_parm_info (int have_ellipsis)\n \n       TREE_CHAIN (parm_info) = NULL_TREE;\n       parm_info = pushdecl (parm_info);\n-      finish_decl (parm_info, NULL_TREE, NULL_TREE, NULL_TREE);\n+      finish_decl (parm_info, input_location, NULL_TREE, NULL_TREE, NULL_TREE);\n       parm_info = next;\n     }\n   arg_info = get_parm_info (have_ellipsis);\n@@ -8391,10 +8432,12 @@ synth_self_and_ucmd_args (void)\n     self_type = objc_object_type;\n \n   /* id self; */\n-  objc_push_parm (build_decl (PARM_DECL, self_id, self_type));\n+  objc_push_parm (build_decl (input_location,\n+\t\t\t      PARM_DECL, self_id, self_type));\n \n   /* SEL _cmd; */\n-  objc_push_parm (build_decl (PARM_DECL, ucmd_id, objc_selector_type));\n+  objc_push_parm (build_decl (input_location,\n+\t\t\t      PARM_DECL, ucmd_id, objc_selector_type));\n }\n \n /* Transform an Objective-C method definition into a static C function\n@@ -8434,7 +8477,8 @@ start_method_def (tree method)\n     {\n       tree type = TREE_VALUE (TREE_TYPE (parmlist)), parm;\n \n-      parm = build_decl (PARM_DECL, KEYWORD_ARG_NAME (parmlist), type);\n+      parm = build_decl (input_location,\n+\t\t\t PARM_DECL, KEYWORD_ARG_NAME (parmlist), type);\n       objc_push_parm (parm);\n       parmlist = TREE_CHAIN (parmlist);\n     }\n@@ -8576,7 +8620,8 @@ objc_start_function (tree name, tree type, tree attrs,\n #endif\n \t\t     )\n {\n-  tree fndecl = build_decl (FUNCTION_DECL, name, type);\n+  tree fndecl = build_decl (input_location,\n+\t\t\t    FUNCTION_DECL, name, type);\n \n #ifdef OBJCPLUS\n   DECL_ARGUMENTS (fndecl) = params;\n@@ -8612,7 +8657,8 @@ objc_start_function (tree name, tree type, tree attrs,\n   push_scope ();\n   declare_parm_level ();\n   DECL_RESULT (current_function_decl)\n-    = build_decl (RESULT_DECL, NULL_TREE,\n+    = build_decl (input_location,\n+\t\t  RESULT_DECL, NULL_TREE,\n \t\t  TREE_TYPE (TREE_TYPE (current_function_decl)));\n   DECL_ARTIFICIAL (DECL_RESULT (current_function_decl)) = 1;\n   DECL_IGNORED_P (DECL_RESULT (current_function_decl)) = 1;\n@@ -8749,19 +8795,22 @@ get_super_receiver (void)\n \n       if (!UOBJC_SUPER_decl)\n       {\n-\tUOBJC_SUPER_decl = build_decl (VAR_DECL, get_identifier (TAG_SUPER),\n+\tUOBJC_SUPER_decl = build_decl (input_location,\n+\t\t\t\t       VAR_DECL, get_identifier (TAG_SUPER),\n \t\t\t\t       objc_super_template);\n \t/* This prevents `unused variable' warnings when compiling with -Wall.  */\n \tTREE_USED (UOBJC_SUPER_decl) = 1;\n \tlang_hooks.decls.pushdecl (UOBJC_SUPER_decl);\n-        finish_decl (UOBJC_SUPER_decl, NULL_TREE, NULL_TREE, NULL_TREE);\n+        finish_decl (UOBJC_SUPER_decl, input_location, NULL_TREE, NULL_TREE,\n+\t    \t     NULL_TREE);\n \tUOBJC_SUPER_scope = objc_get_current_scope ();\n       }\n \n       /* Set receiver to self.  */\n       super_expr = objc_build_component_ref (UOBJC_SUPER_decl, self_id);\n       super_expr = build_modify_expr (input_location, super_expr, NULL_TREE,\n-\t\t\t\t      NOP_EXPR, self_decl, NULL_TREE);\n+\t\t\t\t      NOP_EXPR, input_location, self_decl,\n+\t\t\t\t      NULL_TREE);\n       super_expr_list = super_expr;\n \n       /* Set class to begin searching.  */\n@@ -8775,6 +8824,7 @@ get_super_receiver (void)\n \n \t  super_expr = build_modify_expr (input_location, super_expr,\n \t\t\t\t\t  NULL_TREE, NOP_EXPR,\n+\t\t\t\t\t  input_location,\n \t\t\t\t\t  ((TREE_CODE (objc_method_context)\n \t\t\t\t\t    == INSTANCE_METHOD_DECL)\n \t\t\t\t\t   ? ucls_super_ref\n@@ -8807,7 +8857,8 @@ get_super_receiver (void)\n \t\tsuper_class\n \t\t  = build_indirect_ref\n \t\t      (input_location,\n-\t\t       build_c_cast (build_pointer_type (objc_class_type),\n+\t\t       build_c_cast (input_location,\n+\t\t\t\t     build_pointer_type (objc_class_type),\n \t\t\t\t     super_class), \"unary *\");\n \t    }\n \t  else\n@@ -8818,7 +8869,8 @@ get_super_receiver (void)\n \t      assemble_external (super_class);\n \t      super_class\n \t\t= build_function_call\n-\t\t  (super_class,\n+\t\t  (input_location,\n+\t\t   super_class,\n \t\t   build_tree_list\n \t\t   (NULL_TREE,\n \t\t    my_build_string_pointer\n@@ -8829,16 +8881,20 @@ get_super_receiver (void)\n \t  super_expr\n \t    = build_modify_expr (input_location, super_expr, NULL_TREE,\n \t\t\t\t NOP_EXPR,\n-\t\t\t\t build_c_cast (TREE_TYPE (super_expr),\n+\t\t\t\t input_location,\n+\t\t\t\t build_c_cast (input_location, \n+\t\t\t\t\t       TREE_TYPE (super_expr),\n \t\t\t\t\t       super_class),\n \t\t\t\t NULL_TREE);\n \t}\n \n-      super_expr_list = build_compound_expr (super_expr_list, super_expr);\n+      super_expr_list = build_compound_expr (input_location, \n+\t\t\t\t\t     super_expr_list, super_expr);\n \n       super_expr = build_unary_op (input_location, \n \t\t\t\t   ADDR_EXPR, UOBJC_SUPER_decl, 0);\n-      super_expr_list = build_compound_expr (super_expr_list, super_expr);\n+      super_expr_list = build_compound_expr (input_location,\n+\t\t\t\t\t     super_expr_list, super_expr);\n \n       return super_expr_list;\n     }\n@@ -9350,7 +9406,8 @@ handle_class_ref (tree chain)\n #endif\n \n   /* Make a decl for this name, so we can use its address in a tree.  */\n-  decl = build_decl (VAR_DECL, get_identifier (string), char_type_node);\n+  decl = build_decl (input_location,\n+\t\t     VAR_DECL, get_identifier (string), char_type_node);\n   DECL_EXTERNAL (decl) = 1;\n   TREE_PUBLIC (decl) = 1;\n \n@@ -9361,7 +9418,8 @@ handle_class_ref (tree chain)\n   sprintf (string, \"%sobjc_class_ref_%s\",\n \t   (flag_next_runtime ? \".\" : \"__\"), name);\n   exp = build1 (ADDR_EXPR, string_type_node, decl);\n-  decl = build_decl (VAR_DECL, get_identifier (string), string_type_node);\n+  decl = build_decl (input_location,\n+\t\t     VAR_DECL, get_identifier (string), string_type_node);\n   DECL_INITIAL (decl) = exp;\n   TREE_STATIC (decl) = 1;\n   TREE_USED (decl) = 1;\n@@ -9421,7 +9479,8 @@ handle_impent (struct imp_entry *impent)\n       tree decl, init;\n \n       init = build_int_cst (c_common_type_for_size (BITS_PER_WORD, 1), 0);\n-      decl = build_decl (VAR_DECL, get_identifier (string), TREE_TYPE (init));\n+      decl = build_decl (input_location,\n+\t\t\t VAR_DECL, get_identifier (string), TREE_TYPE (init));\n       TREE_PUBLIC (decl) = 1;\n       TREE_READONLY (decl) = 1;\n       TREE_USED (decl) = 1;"}, {"sha": "fcb4a6419bec70236116476e6f39b1854da47c98", "filename": "gcc/objcp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fobjcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fobjcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjcp%2FChangeLog?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -1,3 +1,9 @@\n+2009-06-12  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* objcp-decl.h (c_end_compound_stmt): New argument.\n+\t* objcp-decl.c (objcp_start_struct): Add argument.\n+\t(objcp_finish_struct): Same.\n+\n 2009-06-03  Ian Lance Taylor  <iant@google.com>\n \n \t* Make-lang.in (cc1objplus-checksum.o): Depend upon $(CONFIG_H)"}, {"sha": "379a69c2bb4a99fde9c1b98a096bec203d54fc20", "filename": "gcc/objcp/objcp-decl.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fobjcp%2Fobjcp-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fobjcp%2Fobjcp-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjcp%2Fobjcp-decl.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -44,7 +44,8 @@ along with GCC; see the file COPYING3.  If not see\n /* Hacks to simulate start_struct() and finish_struct(). */\n \n tree \n-objcp_start_struct (enum tree_code code ATTRIBUTE_UNUSED, tree name)\n+objcp_start_struct (location_t loc ATTRIBUTE_UNUSED,\n+\t\t    enum tree_code code ATTRIBUTE_UNUSED, tree name)\n {\n   tree s;\n   /* The idea here is to mimic the actions that the C++ parser takes when\n@@ -62,7 +63,8 @@ objcp_start_struct (enum tree_code code ATTRIBUTE_UNUSED, tree name)\n }\n \n tree \n-objcp_finish_struct (tree t, tree fieldlist, tree attributes)\n+objcp_finish_struct (location_t loc ATTRIBUTE_UNUSED,\n+\t\t     tree t, tree fieldlist, tree attributes)\n {\n   tree field, next_field;\n "}, {"sha": "e335149e0e596801182f1e069ef957ac397c3c35", "filename": "gcc/objcp/objcp-decl.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fobjcp%2Fobjcp-decl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fobjcp%2Fobjcp-decl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjcp%2Fobjcp-decl.h?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -23,8 +23,8 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_OBJCP_DECL_H\n #define GCC_OBJCP_DECL_H\n \n-extern tree objcp_start_struct (enum tree_code, tree);\n-extern tree objcp_finish_struct (tree, tree, tree);\n+extern tree objcp_start_struct (location_t, enum tree_code, tree);\n+extern tree objcp_finish_struct (location_t, tree, tree, tree);\n extern void objcp_finish_function (void);\n extern tree objcp_build_function_call (tree, tree);\n extern tree objcp_xref_tag (enum tree_code, tree);\n@@ -49,7 +49,7 @@ extern tree objcp_end_compound_stmt (tree, int);\n \tobjcp_comptypes (type1, type2)\n #define c_begin_compound_stmt(flags) \\\n \tobjcp_begin_compound_stmt (flags)\n-#define c_end_compound_stmt(stmt, flags) \\\n+#define c_end_compound_stmt(loc, stmt, flags)\t\\\n \tobjcp_end_compound_stmt (stmt, flags)\n \n #undef OBJC_TYPE_NAME"}, {"sha": "e8b2b4dd52e4efb41714ee0d0350fa30b9e800a0", "filename": "gcc/omp-low.c", "status": "modified", "additions": 37, "deletions": 24, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -807,15 +807,14 @@ use_pointer_for_field (tree decl, omp_context *shared_ctx)\n tree\n copy_var_decl (tree var, tree name, tree type)\n {\n-  tree copy = build_decl (VAR_DECL, name, type);\n+  tree copy = build_decl (DECL_SOURCE_LOCATION (var), VAR_DECL, name, type);\n \n   TREE_ADDRESSABLE (copy) = TREE_ADDRESSABLE (var);\n   TREE_THIS_VOLATILE (copy) = TREE_THIS_VOLATILE (var);\n   DECL_GIMPLE_REG_P (copy) = DECL_GIMPLE_REG_P (var);\n   DECL_ARTIFICIAL (copy) = DECL_ARTIFICIAL (var);\n   DECL_IGNORED_P (copy) = DECL_IGNORED_P (var);\n   DECL_CONTEXT (copy) = DECL_CONTEXT (var);\n-  DECL_SOURCE_LOCATION (copy) = DECL_SOURCE_LOCATION (var);\n   TREE_USED (copy) = 1;\n   DECL_SEEN_IN_BIND_EXPR_P (copy) = 1;\n \n@@ -928,7 +927,8 @@ install_var_field (tree var, bool by_ref, int mask, omp_context *ctx)\n   else if ((mask & 3) == 1 && is_reference (var))\n     type = TREE_TYPE (type);\n \n-  field = build_decl (FIELD_DECL, DECL_NAME (var), type);\n+  field = build_decl (DECL_SOURCE_LOCATION (var),\n+\t\t      FIELD_DECL, DECL_NAME (var), type);\n \n   /* Remember what variable this field was created for.  This does have a\n      side effect of making dwarf2out ignore this member, so for helpful\n@@ -948,7 +948,8 @@ install_var_field (tree var, bool by_ref, int mask, omp_context *ctx)\n       insert_field_into_struct (ctx->record_type, field);\n       if (ctx->srecord_type)\n \t{\n-\t  sfield = build_decl (FIELD_DECL, DECL_NAME (var), type);\n+\t  sfield = build_decl (DECL_SOURCE_LOCATION (var),\n+\t\t\t       FIELD_DECL, DECL_NAME (var), type);\n \t  DECL_ABSTRACT_ORIGIN (sfield) = var;\n \t  DECL_ALIGN (sfield) = DECL_ALIGN (field);\n \t  DECL_USER_ALIGN (sfield) = DECL_USER_ALIGN (field);\n@@ -966,7 +967,8 @@ install_var_field (tree var, bool by_ref, int mask, omp_context *ctx)\n \t  ctx->sfield_map = splay_tree_new (splay_tree_compare_pointers, 0, 0);\n \t  for (t = TYPE_FIELDS (ctx->record_type); t ; t = TREE_CHAIN (t))\n \t    {\n-\t      sfield = build_decl (FIELD_DECL, DECL_NAME (t), TREE_TYPE (t));\n+\t      sfield = build_decl (DECL_SOURCE_LOCATION (var),\n+\t\t\t\t   FIELD_DECL, DECL_NAME (t), TREE_TYPE (t));\n \t      DECL_ABSTRACT_ORIGIN (sfield) = DECL_ABSTRACT_ORIGIN (t);\n \t      insert_field_into_struct (ctx->srecord_type, sfield);\n \t      splay_tree_insert (ctx->sfield_map,\n@@ -1043,7 +1045,7 @@ omp_copy_decl (tree var, copy_body_data *cb)\n \n   if (TREE_CODE (var) == LABEL_DECL)\n     {\n-      new_var = create_artificial_label ();\n+      new_var = create_artificial_label (DECL_SOURCE_LOCATION (var));\n       DECL_CONTEXT (new_var) = current_function_decl;\n       insert_decl_map (&ctx->cb, var, new_var);\n       return new_var;\n@@ -1309,7 +1311,8 @@ fixup_child_record_type (omp_context *ctx)\n \n       type = lang_hooks.types.make_type (RECORD_TYPE);\n       name = DECL_NAME (TYPE_NAME (ctx->record_type));\n-      name = build_decl (TYPE_DECL, name, type);\n+      name = build_decl (DECL_SOURCE_LOCATION (ctx->receiver_decl),\n+\t\t\t TYPE_DECL, name, type);\n       TYPE_NAME (type) = name;\n \n       for (f = TYPE_FIELDS (ctx->record_type); f ; f = TREE_CHAIN (f))\n@@ -1555,7 +1558,8 @@ create_omp_child_function (omp_context *ctx, bool task_copy)\n   else\n     type = build_function_type_list (void_type_node, ptr_type_node, NULL_TREE);\n \n-  decl = build_decl (FUNCTION_DECL, name, type);\n+  decl = build_decl (gimple_location (ctx->stmt),\n+\t\t     FUNCTION_DECL, name, type);\n   decl = lang_hooks.decls.pushdecl (decl);\n \n   if (!task_copy)\n@@ -1573,13 +1577,15 @@ create_omp_child_function (omp_context *ctx, bool task_copy)\n   DECL_CONTEXT (decl) = NULL_TREE;\n   DECL_INITIAL (decl) = make_node (BLOCK);\n \n-  t = build_decl (RESULT_DECL, NULL_TREE, void_type_node);\n+  t = build_decl (DECL_SOURCE_LOCATION (decl),\n+\t\t  RESULT_DECL, NULL_TREE, void_type_node);\n   DECL_ARTIFICIAL (t) = 1;\n   DECL_IGNORED_P (t) = 1;\n   DECL_CONTEXT (t) = decl;\n   DECL_RESULT (decl) = t;\n \n-  t = build_decl (PARM_DECL, get_identifier (\".omp_data_i\"), ptr_type_node);\n+  t = build_decl (DECL_SOURCE_LOCATION (decl),\n+\t\t  PARM_DECL, get_identifier (\".omp_data_i\"), ptr_type_node);\n   DECL_ARTIFICIAL (t) = 1;\n   DECL_ARG_TYPE (t) = ptr_type_node;\n   DECL_CONTEXT (t) = current_function_decl;\n@@ -1589,7 +1595,8 @@ create_omp_child_function (omp_context *ctx, bool task_copy)\n     ctx->receiver_decl = t;\n   else\n     {\n-      t = build_decl (PARM_DECL, get_identifier (\".omp_data_o\"),\n+      t = build_decl (DECL_SOURCE_LOCATION (decl),\n+\t\t      PARM_DECL, get_identifier (\".omp_data_o\"),\n \t\t      ptr_type_node);\n       DECL_ARTIFICIAL (t) = 1;\n       DECL_ARG_TYPE (t) = ptr_type_node;\n@@ -1604,7 +1611,6 @@ create_omp_child_function (omp_context *ctx, bool task_copy)\n      allocate_struct_function clobbers CFUN, so we need to restore\n      it afterward.  */\n   push_struct_function (decl);\n-  DECL_SOURCE_LOCATION (decl) = gimple_location (ctx->stmt);\n   cfun->function_end_locus = gimple_location (ctx->stmt);\n   pop_cfun ();\n }\n@@ -1637,7 +1643,8 @@ scan_omp_parallel (gimple_stmt_iterator *gsi, omp_context *outer_ctx)\n   ctx->default_kind = OMP_CLAUSE_DEFAULT_SHARED;\n   ctx->record_type = lang_hooks.types.make_type (RECORD_TYPE);\n   name = create_tmp_var_name (\".omp_data_s\");\n-  name = build_decl (TYPE_DECL, name, ctx->record_type);\n+  name = build_decl (gimple_location (stmt),\n+\t\t     TYPE_DECL, name, ctx->record_type);\n   TYPE_NAME (ctx->record_type) = name;\n   create_omp_child_function (ctx, false);\n   gimple_omp_parallel_set_child_fn (stmt, ctx->cb.dst_fn);\n@@ -1678,7 +1685,8 @@ scan_omp_task (gimple_stmt_iterator *gsi, omp_context *outer_ctx)\n   ctx->default_kind = OMP_CLAUSE_DEFAULT_SHARED;\n   ctx->record_type = lang_hooks.types.make_type (RECORD_TYPE);\n   name = create_tmp_var_name (\".omp_data_s\");\n-  name = build_decl (TYPE_DECL, name, ctx->record_type);\n+  name = build_decl (gimple_location (stmt),\n+\t\t     TYPE_DECL, name, ctx->record_type);\n   TYPE_NAME (ctx->record_type) = name;\n   create_omp_child_function (ctx, false);\n   gimple_omp_task_set_child_fn (stmt, ctx->cb.dst_fn);\n@@ -1688,7 +1696,8 @@ scan_omp_task (gimple_stmt_iterator *gsi, omp_context *outer_ctx)\n   if (ctx->srecord_type)\n     {\n       name = create_tmp_var_name (\".omp_data_a\");\n-      name = build_decl (TYPE_DECL, name, ctx->srecord_type);\n+      name = build_decl (gimple_location (stmt),\n+\t\t\t TYPE_DECL, name, ctx->srecord_type);\n       TYPE_NAME (ctx->srecord_type) = name;\n       create_omp_child_function (ctx, true);\n     }\n@@ -1781,7 +1790,8 @@ scan_omp_single (gimple stmt, omp_context *outer_ctx)\n   ctx->field_map = splay_tree_new (splay_tree_compare_pointers, 0, 0);\n   ctx->record_type = lang_hooks.types.make_type (RECORD_TYPE);\n   name = create_tmp_var_name (\".omp_copy_s\");\n-  name = build_decl (TYPE_DECL, name, ctx->record_type);\n+  name = build_decl (gimple_location (stmt),\n+\t\t     TYPE_DECL, name, ctx->record_type);\n   TYPE_NAME (ctx->record_type) = name;\n \n   scan_sharing_clauses (gimple_omp_single_clauses (stmt), ctx);\n@@ -2518,8 +2528,8 @@ lower_lastprivate_clauses (tree clauses, tree predicate, gimple_seq *stmt_list,\n       gimple stmt;\n       tree label_true, arm1, arm2;\n \n-      label = create_artificial_label ();\n-      label_true = create_artificial_label ();\n+      label = create_artificial_label (UNKNOWN_LOCATION);\n+      label_true = create_artificial_label (UNKNOWN_LOCATION);\n       arm1 = TREE_OPERAND (predicate, 0);\n       arm2 = TREE_OPERAND (predicate, 1);\n       gimplify_expr (&arm1, stmt_list, NULL, is_gimple_val, fb_rvalue);\n@@ -5595,8 +5605,9 @@ lower_omp_sections (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n static void\n lower_omp_single_simple (gimple single_stmt, gimple_seq *pre_p)\n {\n-  tree tlabel = create_artificial_label ();\n-  tree flabel = create_artificial_label ();\n+  location_t loc = gimple_location (single_stmt);\n+  tree tlabel = create_artificial_label (loc);\n+  tree flabel = create_artificial_label (loc);\n   gimple call, cond;\n   tree lhs, decl;\n \n@@ -5650,15 +5661,16 @@ lower_omp_single_copy (gimple single_stmt, gimple_seq *pre_p, omp_context *ctx)\n {\n   tree ptr_type, t, l0, l1, l2;\n   gimple_seq copyin_seq;\n+  location_t loc = gimple_location (single_stmt);\n \n   ctx->sender_decl = create_tmp_var (ctx->record_type, \".omp_copy_o\");\n \n   ptr_type = build_pointer_type (ctx->record_type);\n   ctx->receiver_decl = create_tmp_var (ptr_type, \".omp_copy_i\");\n \n-  l0 = create_artificial_label ();\n-  l1 = create_artificial_label ();\n-  l2 = create_artificial_label ();\n+  l0 = create_artificial_label (loc);\n+  l1 = create_artificial_label (loc);\n+  l2 = create_artificial_label (loc);\n \n   t = build_call_expr (built_in_decls[BUILT_IN_GOMP_SINGLE_COPY_START], 0);\n   t = fold_convert (ptr_type, t);\n@@ -6106,7 +6118,8 @@ task_copyfn_remap_type (struct omp_taskcopy_context *tcctx, tree orig_type)\n \n   type = lang_hooks.types.make_type (RECORD_TYPE);\n   name = DECL_NAME (TYPE_NAME (orig_type));\n-  name = build_decl (TYPE_DECL, name, type);\n+  name = build_decl (gimple_location (tcctx->ctx->stmt),\n+\t\t     TYPE_DECL, name, type);\n   TYPE_NAME (type) = name;\n \n   for (f = TYPE_FIELDS (orig_type); f ; f = TREE_CHAIN (f))"}, {"sha": "99da304b5c16689af046f941c2bce4458860d6d8", "filename": "gcc/optabs.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -6044,7 +6044,8 @@ init_one_libfunc (const char *name)\n \t targetm.encode_section_info.  */\n       /* ??? We don't have any type information except for this is\n \t a function.  Pretend this is \"int foo()\".  */\n-      decl = build_decl (FUNCTION_DECL, get_identifier (name),\n+      decl = build_decl (UNKNOWN_LOCATION,\n+\t\t\t FUNCTION_DECL, get_identifier (name),\n \t\t\t build_function_type (integer_type_node, NULL_TREE));\n       DECL_ARTIFICIAL (decl) = 1;\n       DECL_EXTERNAL (decl) = 1;"}, {"sha": "de9d9a80753d16b148b30997185e8745bfe171f3", "filename": "gcc/rtl.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -750,6 +750,12 @@ extern void rtl_check_failed_flag (const char *, const_rtx, const char *,\n \n #define BLOCK_FOR_INSN(INSN) XBBDEF (INSN, 3)\n #define INSN_LOCATOR(INSN) XINT (INSN, 4)\n+/* LOCATION of an RTX if relevant.  */\n+#define RTL_LOCATION(X) (INSN_P (X) ? \\\n+\t\t\t locator_location (INSN_LOCATOR (x)) \\\n+\t\t\t : UNKNOWN_LOCATION)\n+/* LOCATION of current INSN.  */\n+#define CURR_INSN_LOCATION (locator_location (curr_insn_locator ()))\n /* The body of an insn.  */\n #define PATTERN(INSN)\tXEXP (INSN, 5)\n "}, {"sha": "31b0b7d8365f20db9f5837546daf411159e8feac", "filename": "gcc/stmt.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -2905,7 +2905,9 @@ emit_case_nodes (rtx index, case_node_ptr node, rtx default_label,\n \t      /* Neither node is bounded.  First distinguish the two sides;\n \t\t then emit the code for one side at a time.  */\n \n-\t      tree test_label = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n+\t      tree test_label\n+\t\t= build_decl (CURR_INSN_LOCATION,\n+\t\t\t      LABEL_DECL, NULL_TREE, NULL_TREE);\n \n \t      /* See if the value is on the right.  */\n \t      emit_cmp_and_jump_insns (index,\n@@ -3028,7 +3030,8 @@ emit_case_nodes (rtx index, case_node_ptr node, rtx default_label,\n \t      /* Right hand node requires testing.\n \t\t Branch to a label where we will handle it later.  */\n \n-\t      test_label = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n+\t      test_label = build_decl (CURR_INSN_LOCATION,\n+\t\t\t\t       LABEL_DECL, NULL_TREE, NULL_TREE);\n \t      emit_cmp_and_jump_insns (index,\n \t\t\t\t       convert_modes\n \t\t\t\t       (mode, imode,"}, {"sha": "d65452bc710a729199507e883761172bdc3af9d0", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -1547,7 +1547,8 @@ finish_builtin_struct (tree type, const char *name, tree fields,\n #if 0 /* not yet, should get fixed properly later */\n   TYPE_NAME (type) = make_type_decl (get_identifier (name), type);\n #else\n-  TYPE_NAME (type) = build_decl (TYPE_DECL, get_identifier (name), type);\n+  TYPE_NAME (type) = build_decl (BUILTINS_LOCATION,\n+\t\t\t\t TYPE_DECL, get_identifier (name), type);\n #endif\n   TYPE_STUB_DECL (type) = TYPE_NAME (type);\n   layout_decl (TYPE_NAME (type), 0);"}, {"sha": "fc3d4169f0a69041464e44a339339c51c742f64b", "filename": "gcc/stub-objc.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fstub-objc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fstub-objc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstub-objc.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -224,7 +224,7 @@ objc_build_protocol_expr (tree ARG_UNUSED (expr))\n }\n \n tree\n-objc_build_selector_expr (tree ARG_UNUSED (expr))\n+objc_build_selector_expr (location_t ARG_UNUSED (loc), tree ARG_UNUSED (expr))\n {\n   return 0;\n }\n@@ -279,7 +279,7 @@ objc_get_class_ivars (tree ARG_UNUSED (name))\n }\n \n tree\n-objc_build_throw_stmt (tree ARG_UNUSED (expr))\n+objc_build_throw_stmt (location_t ARG_UNUSED (loc), tree ARG_UNUSED (expr))\n {\n   return 0;\n }"}, {"sha": "bbc6cd8769976a066d2524f3df13ce240206e7ff", "filename": "gcc/target.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -564,7 +564,8 @@ struct gcc_target\n      complete expression that implements the operation.  PARAMS really\n      has type VEC(tree,gc)*, but we don't want to include tree.h\n      here.  */\n-  tree (*resolve_overloaded_builtin) (tree decl, void *params);\n+  tree (*resolve_overloaded_builtin) (unsigned int /*location_t*/,\n+      \t\t\t\t      tree decl, void *params);\n \n   /* Fold a target-specific builtin.  */\n   tree (* fold_builtin) (tree fndecl, tree arglist, bool ignore);"}, {"sha": "4d799c5d73d7d6f9b69a7b51ceb7c441e4f1d24d", "filename": "gcc/targhooks.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -477,7 +477,8 @@ default_stack_protect_guard (void)\n \n   if (t == NULL)\n     {\n-      t = build_decl (VAR_DECL, get_identifier (\"__stack_chk_guard\"),\n+      t = build_decl (UNKNOWN_LOCATION,\n+\t\t      VAR_DECL, get_identifier (\"__stack_chk_guard\"),\n \t\t      ptr_type_node);\n       TREE_STATIC (t) = 1;\n       TREE_PUBLIC (t) = 1;\n@@ -503,7 +504,8 @@ default_external_stack_protect_fail (void)\n   if (t == NULL_TREE)\n     {\n       t = build_function_type_list (void_type_node, NULL_TREE);\n-      t = build_decl (FUNCTION_DECL, get_identifier (\"__stack_chk_fail\"), t);\n+      t = build_decl (UNKNOWN_LOCATION,\n+\t\t      FUNCTION_DECL, get_identifier (\"__stack_chk_fail\"), t);\n       TREE_STATIC (t) = 1;\n       TREE_PUBLIC (t) = 1;\n       DECL_EXTERNAL (t) = 1;\n@@ -535,7 +537,7 @@ default_hidden_stack_protect_fail (void)\n   if (t == NULL_TREE)\n     {\n       t = build_function_type_list (void_type_node, NULL_TREE);\n-      t = build_decl (FUNCTION_DECL,\n+      t = build_decl (UNKNOWN_LOCATION, FUNCTION_DECL,\n \t\t      get_identifier (\"__stack_chk_fail_local\"), t);\n       TREE_STATIC (t) = 1;\n       TREE_PUBLIC (t) = 1;"}, {"sha": "62b77f61e49af6b9dca1c0ec2cb54dfa947d8d6c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -1,3 +1,45 @@\n+2009-06-12  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* gcc.dg/old-style-prom-3.c: Add column info.\n+\t* gcc.dg/overflow-warn-1.c\n+\t* gcc.dg/gomp/pr27415.c\n+\t* gcc.dg/gomp/for-1.c: Same.\n+\t* gcc.dg/enum-compat-1.c: Same.\n+\t* gcc.dg/c99-tag-3.c: Same.\n+\t* gcc.dg/Wredundant-decls-2.c: Same.\n+\t* gcc.dg/func-ptr-conv-1.c: Same.\n+\t* gcc.dg/asm-wide-1.c: Same.\n+\t* gcc.dg/nofixed-point-2.c: Same.\n+\t* gcc.dg/cpp/line3.c: Same.\n+\t* gcc.dg/array-10.c: Same.\n+\t* gcc.dg/c99-vla-jump-1.c: Same.\n+\t* gcc.dg/pr20368-1.c: Same.\n+\t* gcc.dg/Wshadow-3.c: Same.\n+\t* gcc.dg/c90-const-expr-8.c: Same.\n+\t* gcc.dg/label-decl-2.c: Same.\n+\t* gcc.dg/dremf-type-compat-2.c: Same.\n+\t* gcc.dg/c90-const-expr-5.c: Same.\n+\t* gcc.dg/builtins-30.c: Same.\n+\t* gcc.dg/Warray-bounds.c: Same.\n+\t* gcc.dg/Wcxx-compat-2.c: Same.\n+\t* gcc.dg/tree-ssa/col-1.c: Same.\n+\t* gcc.dg/old-style-prom-2.c: Same.\n+\t* gcc.dg/cast-function-1.c: Same.\n+\t* gcc.dg/pr15698-1.c: Same.\n+\t* gcc.dg/dremf-type-compat-3.c: Same.\n+\t* gcc.dg/vla-8.c: Same.\n+\t* gcc.dg/gomp/pr27415.c: Move firstprivate diagnostics to correct\n+\tline.\n+\t* gcc.dg/label-decl-2.c: Move label diagnostic to correct line.\n+\t* gcc.dg/old-style-prom-3.c: Check for error on the correct line.\n+\t* gcc.dg/enum-compat-1.c: Same.\n+\t* gcc.dg/dremf-type-compat-2.c: Same.\n+\t* gcc.dg/old-style-prom-2.c: Same.\n+\t* gcc.dg/pr15698-1.c: Same.\n+\t* gcc.dg/pr20368-1.c: Same.\n+\t* gcc.dg/dremf-type-compat-3.c: Same.\n+\t* gcc.dg/builtins-30.c: Same.  Test for columns.\n+\t\n 2009-06-12  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/40176"}, {"sha": "44120392c73b79b4eb28409cf853874ca27c5113", "filename": "gcc/testsuite/gcc.dg/Warray-bounds.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -18,40 +18,40 @@ int* f(void) {\n        int c[10];\n     } c;\n \n-    a[-1] = 0;             /* { dg-warning \"array subscript\" } */\n+    a[-1] = 0;             /* { dg-warning \"6:array subscript\" } */\n     a[ 0] = 0;\n     a[ 1] = 0;\n \n \n     a[ 9] = 0;\n-    a[10] = 0;             /* { dg-warning \"array subscript\" } */\n-    a[11] = 0;             /* { dg-warning \"array subscript\" } */\n-    a[2 * n() - 11] = 1;    /* { dg-warning \"array subscript\" } */\n+    a[10] = 0;             /* { dg-warning \"6:array subscript\" } */\n+    a[11] = 0;             /* { dg-warning \"6:array subscript\" } */\n+    a[2 * n() - 11] = 1;    /* { dg-warning \"6:array subscript\" } */\n     a[2 * n() - 10] = 1;\n     a[2 * n() -  1] = 1;\n-    a[2 * n() -  0] = 1;    /* { dg-warning \"array subscript\" } */\n+    a[2 * n() -  0] = 1;    /* { dg-warning \"6:array subscript\" } */\n \n-    b[-1] = 0;             /* { dg-warning \"array subscript\" } */\n+    b[-1] = 0;             /* { dg-warning \"6:array subscript\" } */\n     b[ 0] = 0;\n     b[ 1] = 0;\n     b[ 9] = 0;\n-    b[10] = 0;             /* { dg-warning \"array subscript\" } */\n-    b[11] = 0;             /* { dg-warning \"array subscript\" } */\n-    b[2 * n() - 11] = 1;    /* { dg-warning \"array subscript\" } */\n+    b[10] = 0;             /* { dg-warning \"6:array subscript\" } */\n+    b[11] = 0;             /* { dg-warning \"6:array subscript\" } */\n+    b[2 * n() - 11] = 1;    /* { dg-warning \"6:array subscript\" } */\n     b[2 * n() - 10] = 1;\n     b[2 * n() -  1] = 1;\n     b[2 * n() -  0] = 1;    /* { dg-warning \"array subscript\" } */\n \n-    c.c[-1] = 0;           /* { dg-warning \"array subscript\" } */\n+    c.c[-1] = 0;           /* { dg-warning \"8:array subscript\" } */\n     c.c[ 0] = 0;\n     c.c[ 1] = 0;\n     c.c[ 9] = 0;\n-    c.c[10] = 0;           /* { dg-warning \"array subscript\" } */\n-    c.c[11] = 0;           /* { dg-warning \"array subscript\" } */\n-    c.c[2 * n() - 11] = 1;  /* { dg-warning \"array subscript\" } */\n+    c.c[10] = 0;           /* { dg-warning \"8:array subscript\" } */\n+    c.c[11] = 0;           /* { dg-warning \"8:array subscript\" } */\n+    c.c[2 * n() - 11] = 1;  /* { dg-warning \"8:array subscript\" } */\n     c.c[2 * n() - 10] = 1;\n     c.c[2 * n() -  1] = 1;\n-    c.c[2 * n() -  0] = 1;  /* { dg-warning \"array subscript\" } */\n+    c.c[2 * n() -  0] = 1;  /* { dg-warning \"8:array subscript\" } */\n \n     g(&a[8]);\n     g(&a[9]);\n@@ -86,7 +86,7 @@ int* f(void) {\n        c.c[-1] = 0;\n \n     for (i = 20; i < 30; ++i)\n-             a[i] = 1;       /* { dg-warning \"array subscript\" } */\n+             a[i] = 1;       /* { dg-warning \"15:array subscript\" } */\n \n     return a;\n }"}, {"sha": "14edc1a4215ba53a1023b0721d646486ef7a840b", "filename": "gcc/testsuite/gcc.dg/Wcxx-compat-2.c", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftestsuite%2Fgcc.dg%2FWcxx-compat-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftestsuite%2Fgcc.dg%2FWcxx-compat-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWcxx-compat-2.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -1,36 +1,36 @@\n /* { dg-options \"-Wc++-compat\" } */\n \n _Bool foo;\t\t\t/* This is okay.  */\n-int bool;\t\t\t/* { dg-warning \"keyword\" } */\n-int catch;\t\t\t/* { dg-warning \"keyword\" } */\n-int char16_t;\t\t\t/* { dg-warning \"keyword\" } */\n-int char32_t;\t\t\t/* { dg-warning \"keyword\" } */\n-int class;\t\t\t/* { dg-warning \"keyword\" } */\n-int const_cast;\t\t\t/* { dg-warning \"keyword\" } */\n-int decltype;\t\t\t/* { dg-warning \"keyword\" } */\n-int delete;\t\t\t/* { dg-warning \"keyword\" } */\n-int dynamic_cast;\t\t/* { dg-warning \"keyword\" } */\n-int explicit;\t\t\t/* { dg-warning \"keyword\" } */\n-int export;\t\t\t/* { dg-warning \"keyword\" } */\n-int false;\t\t\t/* { dg-warning \"keyword\" } */\n-int friend;\t\t\t/* { dg-warning \"keyword\" } */\n-int mutable;\t\t\t/* { dg-warning \"keyword\" } */\n-int namespace;\t\t\t/* { dg-warning \"keyword\" } */\n-int new;\t\t\t/* { dg-warning \"keyword\" } */\n-int operator;\t\t\t/* { dg-warning \"keyword\" } */\n-int private;\t\t\t/* { dg-warning \"keyword\" } */\n-int protected;\t\t\t/* { dg-warning \"keyword\" } */\n-int public;\t\t\t/* { dg-warning \"keyword\" } */\n-int reinterpret_cast;\t\t/* { dg-warning \"keyword\" } */\n-int static_assert;\t\t/* { dg-warning \"keyword\" } */\n-int static_cast;\t\t/* { dg-warning \"keyword\" } */\n-int template;\t\t\t/* { dg-warning \"keyword\" } */\n-int this;\t\t\t/* { dg-warning \"keyword\" } */\n-int throw;\t\t\t/* { dg-warning \"keyword\" } */\n-int true;\t\t\t/* { dg-warning \"keyword\" } */\n-int try;\t\t\t/* { dg-warning \"keyword\" } */\n-int typename;\t\t\t/* { dg-warning \"keyword\" } */\n-int typeid;\t\t\t/* { dg-warning \"keyword\" } */\n-int using;\t\t\t/* { dg-warning \"keyword\" } */\n-int virtual;\t\t\t/* { dg-warning \"keyword\" } */\n+int bool;\t\t\t/* { dg-warning \"5:keyword\" } */\n+int catch;\t\t\t/* { dg-warning \"5:keyword\" } */\n+int char16_t;\t\t\t/* { dg-warning \"5:keyword\" } */\n+int char32_t;\t\t\t/* { dg-warning \"5:keyword\" } */\n+int class;\t\t\t/* { dg-warning \"5:keyword\" } */\n+int const_cast;\t\t\t/* { dg-warning \"5:keyword\" } */\n+int decltype;\t\t\t/* { dg-warning \"5:keyword\" } */\n+int delete;\t\t\t/* { dg-warning \"5:keyword\" } */\n+int dynamic_cast;\t\t/* { dg-warning \"5:keyword\" } */\n+int explicit;\t\t\t/* { dg-warning \"5:keyword\" } */\n+int export;\t\t\t/* { dg-warning \"5:keyword\" } */\n+int false;\t\t\t/* { dg-warning \"5:keyword\" } */\n+int friend;\t\t\t/* { dg-warning \"5:keyword\" } */\n+int mutable;\t\t\t/* { dg-warning \"5:keyword\" } */\n+int namespace;\t\t\t/* { dg-warning \"5:keyword\" } */\n+int new;\t\t\t/* { dg-warning \"5:keyword\" } */\n+int operator;\t\t\t/* { dg-warning \"5:keyword\" } */\n+int private;\t\t\t/* { dg-warning \"5:keyword\" } */\n+int protected;\t\t\t/* { dg-warning \"5:keyword\" } */\n+int public;\t\t\t/* { dg-warning \"5:keyword\" } */\n+int reinterpret_cast;\t\t/* { dg-warning \"5:keyword\" } */\n+int static_assert;\t\t/* { dg-warning \"5:keyword\" } */\n+int static_cast;\t\t/* { dg-warning \"5:keyword\" } */\n+int template;\t\t\t/* { dg-warning \"5:keyword\" } */\n+int this;\t\t\t/* { dg-warning \"5:keyword\" } */\n+int throw;\t\t\t/* { dg-warning \"5:keyword\" } */\n+int true;\t\t\t/* { dg-warning \"5:keyword\" } */\n+int try;\t\t\t/* { dg-warning \"5:keyword\" } */\n+int typename;\t\t\t/* { dg-warning \"5:keyword\" } */\n+int typeid;\t\t\t/* { dg-warning \"5:keyword\" } */\n+int using;\t\t\t/* { dg-warning \"5:keyword\" } */\n+int virtual;\t\t\t/* { dg-warning \"5:keyword\" } */\n int wchar_t;"}, {"sha": "27c8e5d9f7d616f38827ddf9bc01a5d5b68facbf", "filename": "gcc/testsuite/gcc.dg/Wredundant-decls-2.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftestsuite%2Fgcc.dg%2FWredundant-decls-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftestsuite%2Fgcc.dg%2FWredundant-decls-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWredundant-decls-2.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -2,22 +2,22 @@\n /* { dg-do compile } */\n /* { dg-options \"-Wredundant-decls\" } */\n \n-int j = 5; /* { dg-message \"note: previous\" } */\n-int j;     /* { dg-warning \"redundant\" } */\n+int j = 5; /* { dg-message \"5:note: previous\" } */\n+int j;     /* { dg-warning \"5:redundant\" } */\n \n static int k;\n-static int k = 5; /* { dg-message \"note: previous\" } */\n-static int k;     /* { dg-warning \"redundant\" } */\n+static int k = 5; /* { dg-message \"12:note: previous\" } */\n+static int k;     /* { dg-warning \"12:redundant\" } */\n \n-static int l = 5; /* { dg-message \"note: previous\" } */\n-static int l;     /* { dg-warning \"redundant\" } */\n+static int l = 5; /* { dg-message \"12:note: previous\" } */\n+static int l;     /* { dg-warning \"12:redundant\" } */\n \n-static int m;     /* { dg-message \"note: previous\" } */\n-static int m;     /* { dg-warning \"redundant\" } */\n+static int m;     /* { dg-message \"12:note: previous\" } */\n+static int m;     /* { dg-warning \"12:redundant\" } */\n static int m = 5;\n \n-int n;           /* { dg-message \"note: previous\" } */\n-int n;           /* { dg-warning \"redundant\" } */\n+int n;           /* { dg-message \"5:note: previous\" } */\n+int n;           /* { dg-warning \"5:redundant\" } */\n int n = 5; \n \n static int o;"}, {"sha": "b6d78b1d38bcff783889eee5ee869fa27ddfac6b", "filename": "gcc/testsuite/gcc.dg/Wshadow-3.c", "status": "modified", "additions": 60, "deletions": 20, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftestsuite%2Fgcc.dg%2FWshadow-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftestsuite%2Fgcc.dg%2FWshadow-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWshadow-3.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -1,21 +1,61 @@\n-/* Test warnings for shadowing in function prototype scope: generally\n-   useless but of use if the parameter is used within the scope.  Bug\n-   529.  */\n-/* Origin: Joseph Myers <joseph@codesourcery.com> */\n+/* PR middle-end/36902 Array bound warning with dead code after optimization */\n /* { dg-do compile } */\n-/* { dg-options \"-std=gnu89 -Wshadow\" } */\n-\n-int v; /* { dg-warning \"shadowed declaration\" } */\n-int f1(int v);\n-int f2(int v, int x[v]); /* { dg-warning \"declaration of 'v' shadows a global declaration\" } */\n-int f3(int v, int y[sizeof(v)]); /* { dg-warning \"declaration of 'v' shadows a global declaration\" } */\n-int f4(int v) { return 0; } /* { dg-warning \"declaration of 'v' shadows a global declaration\" } */\n-int f5(int v, int x[v]) { return 0; } /* { dg-warning \"declaration of 'v' shadows a global declaration\" } */\n-int f6(int x) { return 0; }\n-int f7(v) int v; { return 0; } /* { dg-warning \"declaration of 'v' shadows a global declaration\" } */\n-int f8(v, w) int v; int w[v]; { return 0; } /* { dg-warning \"declaration of 'v' shadows a global declaration\" } */\n-int f9(x) int x; { return 0; }\n-int f10(v) { return 0; } /* { dg-warning \"declaration of 'v' shadows a global declaration\" } */\n-int f11(int a, int b(int a));\n-int f12(int a, int b(int a, int x[a])); /* { dg-warning \"declaration of 'a' shadows a parameter\" } */\n-/* { dg-warning \"shadowed declaration\" \"outer parm\" { target *-*-* } 20 } */\n+/* { dg-options \"-O2 -Warray-bounds -Wall -Wextra\" } */\n+typedef unsigned char __u8;\n+typedef unsigned short __u16;\n+\n+static inline unsigned char *\n+foo(unsigned char * to, const unsigned char * from, int n)\n+{\n+  switch ( n )\n+    {\n+    case 3:\n+      *to = *from;\n+      break;\n+    case 5:\n+      to[4] = from [4];\n+      break;\n+    }\n+  return to;\n+}\n+\n+struct {\n+  int    size_of_select;\n+  unsigned char pcr_select[4];\n+} sel;\n+\n+int bar(void)\n+{\n+  static unsigned char buf[64];\n+\n+  sel.size_of_select = 3;\n+  foo(buf, sel.pcr_select, sel.size_of_select);\n+\n+  return 1;\n+}\n+\n+\n+static inline unsigned char *\n+foo2(unsigned char * to, const unsigned char * from, int n)\n+{\n+  switch ( n )\n+    {\n+    case 3:\n+      *to = *from;\n+      break;\n+    case 5:\n+      to[63] = from [111]; /* { dg-warning \"array subscript is above array bounds\" } */\n+      break;\n+    }\n+  return to;\n+}\n+\n+int baz(void)\n+{\n+  static unsigned char buf[64];\n+\n+  sel.size_of_select = 5;\n+  foo2(buf, sel.pcr_select, sel.size_of_select);\n+\n+  return 1;\n+}"}, {"sha": "3b4d512ba5a4bb6f06035e07f12ec21fe2ab89a5", "filename": "gcc/testsuite/gcc.dg/array-10.c", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftestsuite%2Fgcc.dg%2Farray-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftestsuite%2Fgcc.dg%2Farray-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Farray-10.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -6,28 +6,28 @@\n \n int a;\n \n-int b0[a]; /* { dg-error \"at file scope\" } */\n-int (*b1)[a]; /* { dg-error \"at file scope\" } */\n+int b0[a]; /* { dg-error \"5:at file scope\" } */\n+int (*b1)[a]; /* { dg-error \"7:at file scope\" } */\n int (*b2())[a]; /* { dg-error \"at file scope\" } */\n-struct b3 { int x[a]; }; /* { dg-error \"at file scope\" } */\n-struct b4 { int (*x)[a]; }; /* { dg-error \"at file scope\" } */\n+struct b3 { int x[a]; }; /* { dg-error \"17:at file scope\" } */\n+struct b4 { int (*x)[a]; }; /* { dg-error \"19:at file scope\" } */\n typeof (int [a]) b5; /* { dg-error \"at file scope|outside of any function\" } */\n \n-int c0[(__SIZE_TYPE__)&a]; /* { dg-error \"at file scope\" } */\n-int (*c1)[(__SIZE_TYPE__)&a]; /* { dg-error \"at file scope\" } */\n-int (*c2())[(__SIZE_TYPE__)&a]; /* { dg-error \"at file scope\" } */\n-struct c3 { int x[(__SIZE_TYPE__)&a]; }; /* { dg-error \"at file scope\" } */\n-struct c4 { int (*x)[(__SIZE_TYPE__)&a]; }; /* { dg-error \"at file scope\" } */\n-typeof (int [(__SIZE_TYPE__)&a]) c5; /* { dg-error \"at file scope\" } */\n+int c0[(__SIZE_TYPE__)&a]; /* { dg-error \"5:at file scope\" } */\n+int (*c1)[(__SIZE_TYPE__)&a]; /* { dg-error \"7:at file scope\" } */\n+int (*c2())[(__SIZE_TYPE__)&a]; /* { dg-error \"7:at file scope\" } */\n+struct c3 { int x[(__SIZE_TYPE__)&a]; }; /* { dg-error \"17:at file scope\" } */\n+struct c4 { int (*x)[(__SIZE_TYPE__)&a]; }; /* { dg-error \"19:at file scope\" } */\n+typeof (int [(__SIZE_TYPE__)&a]) c5; /* { dg-error \"34:at file scope\" } */\n \n-int d0[1/0]; /* { dg-error \"at file scope\" } */\n-/* { dg-warning \"division by zero\" \"\" { target *-*-* } 23 } */\n-int (*d1)[1/0]; /* { dg-error \"at file scope\" } */\n-/* { dg-warning \"division by zero\" \"\" { target *-*-* } 25 } */\n-int (*d2())[1/0]; /* { dg-error \"at file scope\" } */\n-/* { dg-warning \"division by zero\" \"\" { target *-*-* } 27 } */\n-struct d3 { int x[1/0]; }; /* { dg-error \"at file scope\" } */\n-/* { dg-warning \"division by zero\" \"\" { target *-*-* } 29 } */\n-struct d4 { int (*x)[1/0]; }; /* { dg-error \"at file scope\" } */\n-/* { dg-warning \"division by zero\" \"\" { target *-*-* } 31 } */\n-typeof (int [1/0]) d5; /* { dg-error \"at file scope\" } */\n+int d0[1/0]; /* { dg-error \"5:at file scope\" } */\n+/* { dg-warning \"9:division by zero\" \"\" { target *-*-* } 23 } */\n+int (*d1)[1/0]; /* { dg-error \"7:at file scope\" } */\n+/* { dg-warning \"12:division by zero\" \"\" { target *-*-* } 25 } */\n+int (*d2())[1/0]; /* { dg-error \"7:at file scope\" } */\n+/* { dg-warning \"14:division by zero\" \"\" { target *-*-* } 27 } */\n+struct d3 { int x[1/0]; }; /* { dg-error \"17:at file scope\" } */\n+/* { dg-warning \"20:division by zero\" \"\" { target *-*-* } 29 } */\n+struct d4 { int (*x)[1/0]; }; /* { dg-error \"19:at file scope\" } */\n+/* { dg-warning \"23:division by zero\" \"\" { target *-*-* } 31 } */\n+typeof (int [1/0]) d5; /* { dg-error \"20:at file scope\" } */"}, {"sha": "c14b19d3479598a4580f9f3b297b81076601a5f6", "filename": "gcc/testsuite/gcc.dg/asm-wide-1.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftestsuite%2Fgcc.dg%2Fasm-wide-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftestsuite%2Fgcc.dg%2Fasm-wide-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fasm-wide-1.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -3,27 +3,27 @@\n /* { dg-do compile } */\n /* { dg-options \"\" } */\n \n-int foo asm (L\"bar\"); /* { dg-error \"wide string literal in 'asm'\" } */\n+int foo asm (L\"bar\"); /* { dg-error \"14:wide string literal in 'asm'\" } */\n \n-asm (L\"foo\"); /* { dg-error \"wide string literal in 'asm'\" } */\n+asm (L\"foo\"); /* { dg-error \"6:wide string literal in 'asm'\" } */\n \n void\n f (void)\n {\n   int x = 1;\n-  asm (L\"foo\"); /* { dg-error \"wide string literal in 'asm'\" } */\n+  asm (L\"foo\"); /* { dg-error \"8:wide string literal in 'asm'\" } */\n   asm (\"foo\" :\n-       L\"=g\" (x)); /* { dg-error \"wide string literal in 'asm'\" } */\n+       L\"=g\" (x)); /* { dg-error \"8:wide string literal in 'asm'\" } */\n   asm (\"foo\" : [x]\n-       L\"=g\" (x)); /* { dg-error \"wide string literal in 'asm'\" } */\n+       L\"=g\" (x)); /* { dg-error \"8:wide string literal in 'asm'\" } */\n   asm (\"foo\" : [x] \"=g\" (x),\n-       L\"=g\" (x)); /* { dg-error \"wide string literal in 'asm'\" } */\n+       L\"=g\" (x)); /* { dg-error \"8:wide string literal in 'asm'\" } */\n   asm (\"foo\" : :\n-       L\"g\" (x)); /* { dg-error \"wide string literal in 'asm'\" } */\n+       L\"g\" (x)); /* { dg-error \"8:wide string literal in 'asm'\" } */\n   asm (\"foo\" : : :\n-       L\"memory\"); /* { dg-error \"wide string literal in 'asm'\" } */\n+       L\"memory\"); /* { dg-error \"8:wide string literal in 'asm'\" } */\n   asm (\"foo\" : : : \"memory\",\n-       L\"memory\"); /* { dg-error \"wide string literal in 'asm'\" } */\n+       L\"memory\"); /* { dg-error \"8:wide string literal in 'asm'\" } */\n }\n \n /* Extra errors from the substitution of \"\" for wide strings: */"}, {"sha": "37e5dba2db652bcf45b4e86ae8d95b5170f6da33", "filename": "gcc/testsuite/gcc.dg/builtins-30.c", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-30.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-30.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-30.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -1,29 +1,27 @@\n /* { dg-do compile } */\n-/* { dg-options \"-Wall -Wshadow\" } */\n+/* { dg-options \"-Wall -Wshadow -fshow-column\" } */\n \n extern double strtod (const char *, char **);\n #define UNUSED __attribute__ ((unused))\n \n /* A built-in function may be overridden by an old-style definition\n    specifying too few arguments... */\n-double cos ()  /* { dg-warning \"shadows a built-in\" } */\n+double cos ()  /* { dg-warning \"shadows a built-in|number of arguments\" } */ \n {\n-  /* { dg-warning \"number of arguments doesn't match built-in prototype\" \"built-in\" { target *-*-* } 10 } */\n   return strtod (\"nan\", 0);\n }\n \n /* the right number, but the wrong type, arguments... */\n-double sin (foo)  /* { dg-warning \"shadows a built-in\" } */\n-     int foo UNUSED;\n-{  /* { dg-warning \"argument 'foo' doesn't match built-in prototype\" } */\n+double sin (foo)  /* { dg-warning \"8:shadows a built-in\" } */\n+     int foo UNUSED; /* { dg-warning \"10:argument 'foo' doesn't match built-in prototype\" } */\n+{\n   return strtod (\"nan\", 0);\n }\n \n /* or too many arguments.  */\n-long double cosl (foo, bar)  /* { dg-warning \"shadows a built-in\" } */\n-     const char *foo UNUSED;\n+long double cosl (foo, bar)  /* { dg-warning \"shadows a built-in|number of arguments\" } */\n+     const char *foo UNUSED; /* { dg-warning \"18:argument 'foo' doesn't match\" } */\n      int bar UNUSED;\n-{  /* { dg-warning \"number of arguments doesn't match built-in prototype\" } */\n-  /* { dg-warning \"argument 'foo' doesn't match built-in prototype\" \"foo\" { target *-*-* } 26 } */\n+{\n   return strtod (\"nan\", 0);\n }"}, {"sha": "9f5cdef83994890162add3cc3c524c2fca5eb6f1", "filename": "gcc/testsuite/gcc.dg/c90-const-expr-5.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-const-expr-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-const-expr-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-const-expr-5.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -2,7 +2,7 @@\n    qualified void.  */\n /* Origin: Joseph Myers <joseph@codesourcery.com> */\n /* { dg-do compile } */\n-/* { dg-options \"-std=iso9899:1990 -pedantic-errors -fshow-column\" } */\n+/* { dg-options \"-std=iso9899:1990 -pedantic-errors\" } */\n \n typedef void V;\n int *p;\n@@ -15,14 +15,14 @@ f (void)\n {\n   /* (V *)0 is a null pointer constant, so the assignment should be\n      diagnosed.  */\n-  q = (j ? p : (V *)0); /* { dg-error \"3:assignment from incompatible pointer type\" } */\n-  q = (j ? p : (void *)0); /* { dg-error \"3:assignment from incompatible pointer type\" } */\n+  q = (j ? p : (V *)0); /* { dg-error \"5:assignment from incompatible pointer type\" } */\n+  q = (j ? p : (void *)0); /* { dg-error \"5:assignment from incompatible pointer type\" } */\n   /* And this conversion should be valid.  */\n   (void (*)(void))(V *)0;\n   (void (*)(void))(void *)0;\n   /* Pointers to qualified void are not valid null pointer\n      constants.  */\n-  fp = (const void *)0; /* { dg-error \"3:ISO C forbids assignment between function pointer and 'void \\\\*'\" } */\n+  fp = (const void *)0; /* { dg-error \"6:ISO C forbids assignment between function pointer and 'void \\\\*'\" } */\n   fp = (void *)0;\n   fp = (V *)0;\n   fp = 0;"}, {"sha": "b00bb9718f85cc0386dada5f7e9b2608894d40f3", "filename": "gcc/testsuite/gcc.dg/c90-const-expr-8.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-const-expr-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-const-expr-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-const-expr-8.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -9,19 +9,19 @@\n #include <limits.h>\n \n enum e {\n-  E0 = 0 * (INT_MAX + 1), /* { dg-warning \"integer overflow in expression\" } */\n-  /* { dg-error \"overflow in constant expression\" \"constant\" { target *-*-* } 12 } */\n-  E1 = 0 * (INT_MIN / -1), /* { dg-warning \"integer overflow in expression\" } */\n-  /* { dg-error \"overflow in constant expression\" \"constant\" { target *-*-* } 14 } */\n-  E2 = 0 * (INT_MAX * INT_MAX), /* { dg-warning \"integer overflow in expression\" } */\n-  /* { dg-error \"overflow in constant expression\" \"constant\" { target *-*-* } 16 } */\n-  E3 = 0 * (INT_MIN - 1), /* { dg-warning \"integer overflow in expression\" } */\n-  /* { dg-error \"overflow in constant expression\" \"constant\" { target *-*-* } 18 } */\n-  E4 = 0 * (unsigned)(INT_MIN - 1), /* { dg-warning \"integer overflow in expression\" } */\n-  /* { dg-error \"overflow in constant expression\" \"constant\" { target *-*-* } 20 } */\n-  E5 = 0 * -INT_MIN, /* { dg-warning \"integer overflow in expression\" } */\n-  /* { dg-error \"overflow in constant expression\" \"constant\" { target *-*-* } 22 } */\n-  E6 = 0 * !-INT_MIN, /* { dg-warning \"integer overflow in expression\" } */\n-  /* { dg-error \"not an integer constant\" \"constant\" { target *-*-* } 24 } */\n+  E0 = 0 * (INT_MAX + 1), /* { dg-warning \"21:integer overflow in expression\" } */\n+  /* { dg-error \"3:overflow in constant expression\" \"constant\" { target *-*-* } 12 } */\n+  E1 = 0 * (INT_MIN / -1), /* { dg-warning \"21:integer overflow in expression\" } */\n+  /* { dg-error \"3:overflow in constant expression\" \"constant\" { target *-*-* } 14 } */\n+  E2 = 0 * (INT_MAX * INT_MAX), /* { dg-warning \"21:integer overflow in expression\" } */\n+  /* { dg-error \"3:overflow in constant expression\" \"constant\" { target *-*-* } 16 } */\n+  E3 = 0 * (INT_MIN - 1), /* { dg-warning \"21:integer overflow in expression\" } */\n+  /* { dg-error \"3:overflow in constant expression\" \"constant\" { target *-*-* } 18 } */\n+  E4 = 0 * (unsigned)(INT_MIN - 1), /* { dg-warning \"31:integer overflow in expression\" } */\n+  /* { dg-error \"3:overflow in constant expression\" \"constant\" { target *-*-* } 20 } */\n+  E5 = 0 * -INT_MIN, /* { dg-warning \"12:integer overflow in expression\" } */\n+  /* { dg-error \"3:overflow in constant expression\" \"constant\" { target *-*-* } 22 } */\n+  E6 = 0 * !-INT_MIN, /* { dg-warning \"13:integer overflow in expression\" } */\n+  /* { dg-error \"3:not an integer constant\" \"constant\" { target *-*-* } 24 } */\n   E7 = INT_MIN % -1 /* Not an overflow.  */\n };"}, {"sha": "a492037b07ae4858ac79cc37d28d8e5bd2b794d3", "filename": "gcc/testsuite/gcc.dg/c99-tag-3.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-tag-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-tag-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-tag-3.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -13,10 +13,10 @@ void f (void) { struct s0; }\n \n /* A declaration with a qualifier or storage class specifier declares\n    the tag if no other declaration of it is visible.  */\n-const union u0; /* { dg-warning \"useless type qualifier in empty declaration\" } */\n+const union u0; /* { dg-warning \"13:useless type qualifier in empty declaration\" } */\n union u0 { long b; };\n \n-extern struct s1; /* { dg-warning \"useless storage class specifier in empty declaration\" } */\n+extern struct s1; /* { dg-warning \"15:useless storage class specifier in empty declaration\" } */\n \n /* But if a declaration of the tag is visible, whether at the same\n    scope or an outer scope, the declaration specifies the same type as\n@@ -25,35 +25,35 @@ extern struct s1; /* { dg-warning \"useless storage class specifier in empty decl\n    the members of an enumeration, it is a constraint violation.  */\n \n struct s2 { char x; };\n-const struct s2; /* { dg-error \"empty declaration with type qualifier does not redeclare tag\" } */\n+const struct s2; /* { dg-error \"14:empty declaration with type qualifier does not redeclare tag\" } */\n \n union u1;\n-extern union u1; /* { dg-error \"empty declaration with storage class specifier does not redeclare tag\" } */\n+extern union u1; /* { dg-error \"14:empty declaration with storage class specifier does not redeclare tag\" } */\n \n union u2 { long b; };\n-void g(void) { const union u2; } /* { dg-error \"empty declaration with type qualifier does not redeclare tag\" } */\n+void g(void) { const union u2; } /* { dg-error \"28:empty declaration with type qualifier does not redeclare tag\" } */\n \n /* And it does not redeclare the tag either if the outer tag is the\n    wrong kind of tag.  This also yields an error for the reference to\n    the wrong kind of tag in addition to the pedwarn for the empty\n    declaration.  */\n \n union u3 { float v; };\n-void h(void) { const struct u3; } /* { dg-error \"'u3' defined as wrong kind of tag\" } */\n-/* { dg-error \"empty declaration with type qualifier does not redeclare tag\" \"wrong tag empty\" { target *-*-* } 42 } */\n+void h(void) { const struct u3; } /* { dg-error \"29:'u3' defined as wrong kind of tag\" } */\n+/* { dg-error \"29:empty declaration with type qualifier does not redeclare tag\" \"wrong tag empty\" { target *-*-* } 42 } */\n \n /* However, such useless specifiers are OK if the contents of the tag\n    are being defined, or shadowed in an inner scope with the contents\n    included in the shadowing.  */\n \n struct s3;\n-const struct s3 { int a; }; /* { dg-warning \"useless type qualifier in empty declaration\" } */\n+const struct s3 { int a; }; /* { dg-warning \"14:useless type qualifier in empty declaration\" } */\n \n union u4;\n-extern union u4 { int z; }; /* { dg-warning \"useless storage class specifier in empty declaration\" } */\n+extern union u4 { int z; }; /* { dg-warning \"14:useless storage class specifier in empty declaration\" } */\n \n enum e0 { E0 };\n-void i(void) { const enum e0 { E1 }; } /* { dg-warning \"useless type qualifier in empty declaration\" } */\n+void i(void) { const enum e0 { E1 }; } /* { dg-warning \"32:useless type qualifier in empty declaration\" } */\n \n union u5 { int p; };\n-void j(void) { extern struct u5 { int q; }; } /* { dg-warning \"useless storage class specifier in empty declaration\" } */\n+void j(void) { extern struct u5 { int q; }; } /* { dg-warning \"30:useless storage class specifier in empty declaration\" } */"}, {"sha": "3cfa384d1ca8ac632b87a63d1c94058ad6a90f1b", "filename": "gcc/testsuite/gcc.dg/c99-vla-jump-1.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-vla-jump-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-vla-jump-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-vla-jump-1.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -15,11 +15,11 @@\n /* { dg-options \"-std=iso9899:1999 -pedantic-errors\" } */\n \n void fa0 (int n) {  goto a; a:{ int b[n]; { int c[n]; 0;} { int d[n]; 0;} ; int e[n]; 0;}; { int f[n]; { int g[n]; 0;}; { int h[n]; 0;}; ; int i[n]; 0;}; ; int j[n]; 0; }\n-void fa1 (int n) {  goto a; { int b[n]; a:{ int c[n]; 0;} { int d[n]; 0;} ; int e[n]; 0;}; { int f[n]; { int g[n]; 0;}; { int h[n]; 0;}; ; int i[n]; 0;}; ; int j[n]; 0; } /* { dg-error \"jump into scope of identifier with variably modified type\" } */\n-void fa2 (int n) {  goto a; { int b[n]; { int c[n]; a:0;} { int d[n]; 0;} ; int e[n]; 0;}; { int f[n]; { int g[n]; 0;}; { int h[n]; 0;}; ; int i[n]; 0;}; ; int j[n]; 0; } /* { dg-error \"jump into scope of identifier with variably modified type\" } */\n-void fa3 (int n) {  goto a; { int b[n]; { int c[n]; 0;} a:{ int d[n]; 0;} ; int e[n]; 0;}; { int f[n]; { int g[n]; 0;}; { int h[n]; 0;}; ; int i[n]; 0;}; ; int j[n]; 0; } /* { dg-error \"jump into scope of identifier with variably modified type\" } */\n-void fa4 (int n) {  goto a; { int b[n]; { int c[n]; 0;} { int d[n]; a:0;} ; int e[n]; 0;}; { int f[n]; { int g[n]; 0;}; { int h[n]; 0;}; ; int i[n]; 0;}; ; int j[n]; 0; } /* { dg-error \"jump into scope of identifier with variably modified type\" } */\n-void fa5 (int n) {  goto a; { int b[n]; { int c[n]; 0;} { int d[n]; 0;} a:; int e[n]; 0;}; { int f[n]; { int g[n]; 0;}; { int h[n]; 0;}; ; int i[n]; 0;}; ; int j[n]; 0; } /* { dg-error \"jump into scope of identifier with variably modified type\" } */\n+void fa1 (int n) {  goto a; { int b[n]; a:{ int c[n]; 0;} { int d[n]; 0;} ; int e[n]; 0;}; { int f[n]; { int g[n]; 0;}; { int h[n]; 0;}; ; int i[n]; 0;}; ; int j[n]; 0; } /* { dg-error \"41:jump into scope of identifier with variably modified type\" } */\n+void fa2 (int n) {  goto a; { int b[n]; { int c[n]; a:0;} { int d[n]; 0;} ; int e[n]; 0;}; { int f[n]; { int g[n]; 0;}; { int h[n]; 0;}; ; int i[n]; 0;}; ; int j[n]; 0; } /* { dg-error \"53:jump into scope of identifier with variably modified type\" } */\n+void fa3 (int n) {  goto a; { int b[n]; { int c[n]; 0;} a:{ int d[n]; 0;} ; int e[n]; 0;}; { int f[n]; { int g[n]; 0;}; { int h[n]; 0;}; ; int i[n]; 0;}; ; int j[n]; 0; } /* { dg-error \"57:jump into scope of identifier with variably modified type\" } */\n+void fa4 (int n) {  goto a; { int b[n]; { int c[n]; 0;} { int d[n]; a:0;} ; int e[n]; 0;}; { int f[n]; { int g[n]; 0;}; { int h[n]; 0;}; ; int i[n]; 0;}; ; int j[n]; 0; } /* { dg-error \"69:jump into scope of identifier with variably modified type\" } */\n+void fa5 (int n) {  goto a; { int b[n]; { int c[n]; 0;} { int d[n]; 0;} a:; int e[n]; 0;}; { int f[n]; { int g[n]; 0;}; { int h[n]; 0;}; ; int i[n]; 0;}; ; int j[n]; 0; } /* { dg-error \"73:jump into scope of identifier with variably modified type\" } */\n void fa6 (int n) {  goto a; { int b[n]; { int c[n]; 0;} { int d[n]; 0;} ; int e[n]; a:0;}; { int f[n]; { int g[n]; 0;}; { int h[n]; 0;}; ; int i[n]; 0;}; ; int j[n]; 0; } /* { dg-error \"jump into scope of identifier with variably modified type\" } */\n void fa7 (int n) {  goto a; { int b[n]; { int c[n]; 0;} { int d[n]; 0;} ; int e[n]; 0;}; a:{ int f[n]; { int g[n]; 0;}; { int h[n]; 0;}; ; int i[n]; 0;}; ; int j[n]; 0; }\n void fa8 (int n) {  goto a; { int b[n]; { int c[n]; 0;} { int d[n]; 0;} ; int e[n]; 0;}; { int f[n]; a:{ int g[n]; 0;}; { int h[n]; 0;}; ; int i[n]; 0;}; ; int j[n]; 0; } /* { dg-error \"jump into scope of identifier with variably modified type\" } */"}, {"sha": "781d0e221911821144794c76f749c747ca46f703", "filename": "gcc/testsuite/gcc.dg/cast-function-1.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftestsuite%2Fgcc.dg%2Fcast-function-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftestsuite%2Fgcc.dg%2Fcast-function-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcast-function-1.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -22,14 +22,14 @@ void bar(void)\n   int i;\n   str_t s;\n \n-  d = ((double (*) (int)) foo1) (i);  /* { dg-warning \"non-compatible|abort\" } */\n-  i = ((int (*) (double)) foo1) (d);  /* { dg-warning \"non-compatible|abort\" } */\n-  s = ((str_t (*) (int)) foo1) (i);   /* { dg-warning \"non-compatible|abort\" } */\n+  d = ((double (*) (int)) foo1) (i);  /* { dg-warning \"33:non-compatible|abort\" } */\n+  i = ((int (*) (double)) foo1) (d);  /* { dg-warning \"33:non-compatible|abort\" } */\n+  s = ((str_t (*) (int)) foo1) (i);   /* { dg-warning \"32:non-compatible|abort\" } */\n   ((void (*) (int)) foo1) (d);        /* { dg-warning \"non-compatible|abort\" } */\n   i = ((int (*) (int)) foo1) (i);     /* { dg-bogus \"non-compatible|abort\" } */\n   (void) foo1 (i);                    /* { dg-bogus \"non-compatible|abort\" } */\n \n-  d = ((double (*) (int)) foo2) (i);  /* { dg-warning \"non-compatible|abort\" } */\n+  d = ((double (*) (int)) foo2) (i);  /* { dg-warning \"33:non-compatible|abort\" } */\n   i = ((int (*) (double)) foo2) (d);  /* { dg-bogus \"non-compatible|abort\" } */\n   s = ((str_t (*) (int)) foo2) (i);   /* { dg-warning \"non-compatible|abort\" } */\n   ((void (*) (int)) foo2) (d);        /* { dg-warning \"non-compatible|abort\" } */"}, {"sha": "7a1061478d412b054f8b8ea1e00ffcd33e54fa90", "filename": "gcc/testsuite/gcc.dg/cpp/line3.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fline3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fline3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fline3.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -14,15 +14,15 @@ main(void)\n   char *A;\n \n   A = \"text\";\t\t/* { dg-warning \"discards qualifiers\" \"case zero\" } */\n-  A = one(\"text\"\n+  A = one(\"text\"\t/* { dg-warning \"discards qualifiers\" \"case one\" } */\n \t  \"text\")\n-\t;\t\t/* { dg-warning \"discards qualifiers\" \"case one\" } */\n-  A = two(\"text\"\n+\t;\n+  A = two(\"text\"\t/* { dg-warning \"discards qualifiers\" \"case two\" } */\n \t  \"text\")\n-\t;\t\t/* { dg-warning \"discards qualifiers\" \"case two\" } */\n-  A = four(\"text\"\n+\t;\n+  A = four(\"text\"\t/* { dg-warning \"discards qualifiers\" \"case four\" } */\n \t   \"text\")\n-\t;\t\t/* { dg-warning \"discards qualifiers\" \"case four\" } */\n+\t;\n \n   return 0;\n }"}, {"sha": "980ead187e7310426c2398ea0dced35fabe1d5ac", "filename": "gcc/testsuite/gcc.dg/dremf-type-compat-2.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftestsuite%2Fgcc.dg%2Fdremf-type-compat-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftestsuite%2Fgcc.dg%2Fdremf-type-compat-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdremf-type-compat-2.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -11,8 +11,8 @@ float dremf (float, float); /* { dg-warning \"prototype declaration\" } */\n \n float\n dremf (x, y)\n-     float x;\n-     float y;\n-{ /* { dg-warning \"promoted argument '.' doesn't match prototype\" } */\n+     float x; /* { dg-warning \"promoted argument 'x' doesn't match prototype\" } */\n+     float y; /* { dg-warning \"promoted argument 'y' doesn't match prototype\" } */\n+{\n   return x + y;\n }"}, {"sha": "3934a64e19f261f77e57b2335ccd59ba872200a3", "filename": "gcc/testsuite/gcc.dg/dremf-type-compat-3.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftestsuite%2Fgcc.dg%2Fdremf-type-compat-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftestsuite%2Fgcc.dg%2Fdremf-type-compat-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdremf-type-compat-3.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -11,8 +11,8 @@ float dremf (float, float); /* { dg-error \"prototype declaration\" } */\n \n float\n dremf (x, y)\n-     float x;\n-     float y;\n-{ /* { dg-error \"promoted argument '.' doesn't match prototype\" } */\n+     float x; /* { dg-error \"promoted argument 'x' doesn't match prototype\" } */\n+     float y; /* { dg-error \"promoted argument 'y' doesn't match prototype\" } */\n+{\n   return x + y;\n }"}, {"sha": "5fb150cee7986348878390dae12333017f38a2d7", "filename": "gcc/testsuite/gcc.dg/enum-compat-1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftestsuite%2Fgcc.dg%2Fenum-compat-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftestsuite%2Fgcc.dg%2Fenum-compat-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fenum-compat-1.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -12,8 +12,8 @@ enum e2 {c, d};\n void f(enum e1); /* { dg-error \"prototype\" \"error at decl\" } */\n \n void f(x)\n-     enum e2 x;\n-{ /* { dg-error \"doesn't match prototype\" \"error at defn\" } */\n+     enum e2 x; /* { dg-error \"doesn't match prototype\" } */\n+{\n   return;\n }\n "}, {"sha": "c331fbc88fc88f8a3cd72044ffb02f8b8b33b9f8", "filename": "gcc/testsuite/gcc.dg/func-ptr-conv-1.c", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftestsuite%2Fgcc.dg%2Ffunc-ptr-conv-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftestsuite%2Fgcc.dg%2Ffunc-ptr-conv-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ffunc-ptr-conv-1.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -9,36 +9,36 @@\n \n void f(void);\n \n-void *v1 = f; /* { dg-warning \"pointer\" \"bad conversion\" } */\n-void *v2 = &f; /* { dg-warning \"pointer\" \"bad conversion\" } */\n-void *v3 = (void *)f; /* { dg-warning \"pointer\" \"bad conversion\" } */\n-void *v4 = (void *)&f; /* { dg-warning \"pointer\" \"bad conversion\" } */\n+void *v1 = f; /* { dg-warning \"12:pointer\" \"bad conversion\" } */\n+void *v2 = &f; /* { dg-warning \"12:pointer\" \"bad conversion\" } */\n+void *v3 = (void *)f; /* { dg-warning \"12:pointer\" \"bad conversion\" } */\n+void *v4 = (void *)&f; /* { dg-warning \"12:pointer\" \"bad conversion\" } */\n void *v5;\n-char *c1 = f; /* { dg-warning \"pointer\" \"bad conversion\" } */\n-char *c2 = &f; /* { dg-warning \"pointer\" \"bad conversion\" } */\n-char *c3 = (char *)f; /* { dg-warning \"pointer\" \"bad conversion\" } */\n-char *c4 = (char *)&f; /* { dg-warning \"pointer\" \"bad conversion\" } */\n+char *c1 = f; /* { dg-warning \"12:pointer\" \"bad conversion\" } */\n+char *c2 = &f; /* { dg-warning \"12:pointer\" \"bad conversion\" } */\n+char *c3 = (char *)f; /* { dg-warning \"12:pointer\" \"bad conversion\" } */\n+char *c4 = (char *)&f; /* { dg-warning \"12:pointer\" \"bad conversion\" } */\n char *c5;\n void (*fp)(void);\n int a;\n \n void\n g(void)\n {\n-  v5 = f; /* { dg-warning \"pointer\" \"bad conversion\" } */\n-  v5 = &f; /* { dg-warning \"pointer\" \"bad conversion\" } */\n-  v5 = (void *)f; /* { dg-warning \"pointer\" \"bad conversion\" } */\n-  v5 = (void *)&f; /* { dg-warning \"pointer\" \"bad conversion\" } */\n-  c5 = f; /* { dg-warning \"pointer\" \"bad conversion\" } */\n-  c5 = &f; /* { dg-warning \"pointer\" \"bad conversion\" } */\n-  c5 = (char *)f; /* { dg-warning \"pointer\" \"bad conversion\" } */\n-  c5 = (char *)&f; /* { dg-warning \"pointer\" \"bad conversion\" } */\n-  fp = v5; /* { dg-warning \"pointer\" \"bad conversion\" } */\n-  fp = c5; /* { dg-warning \"pointer\" \"bad conversion\" } */\n-  fp = (void (*)(void))v5; /* { dg-warning \"pointer\" \"bad conversion\" } */\n-  fp = (void (*)(void))c5; /* { dg-warning \"pointer\" \"bad conversion\" } */\n-  (a ? f : v3); /* { dg-warning \"pointer\" \"bad conversion\" } */\n-  (a ? v2 : fp); /* { dg-warning \"pointer\" \"bad conversion\" } */\n+  v5 = f; /* { dg-warning \"6:pointer\" \"bad conversion\" } */\n+  v5 = &f; /* { dg-warning \"6:pointer\" \"bad conversion\" } */\n+  v5 = (void *)f; /* { dg-warning \"8:pointer\" \"bad conversion\" } */\n+  v5 = (void *)&f; /* { dg-warning \"8:pointer\" \"bad conversion\" } */\n+  c5 = f; /* { dg-warning \"6:pointer\" \"bad conversion\" } */\n+  c5 = &f; /* { dg-warning \"6:pointer\" \"bad conversion\" } */\n+  c5 = (char *)f; /* { dg-warning \"8:pointer\" \"bad conversion\" } */\n+  c5 = (char *)&f; /* { dg-warning \"8:pointer\" \"bad conversion\" } */\n+  fp = v5; /* { dg-warning \"6:pointer\" \"bad conversion\" } */\n+  fp = c5; /* { dg-warning \"6:pointer\" \"bad conversion\" } */\n+  fp = (void (*)(void))v5; /* { dg-warning \"8:pointer\" \"bad conversion\" } */\n+  fp = (void (*)(void))c5; /* { dg-warning \"8:pointer\" \"bad conversion\" } */\n+  (a ? f : v3); /* { dg-warning \"6:pointer\" \"bad conversion\" } */\n+  (a ? v2 : fp); /* { dg-warning \"6:pointer\" \"bad conversion\" } */\n   /* The following are OK.  */\n   fp = 0;\n   fp = (void *)0;"}, {"sha": "384293e82756d5db049ce30ddbb02d7679294af0", "filename": "gcc/testsuite/gcc.dg/gomp/for-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ffor-1.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -44,6 +44,6 @@ void foo (int j, int k)\n     baz (i);\n \n   #pragma omp for\n-  for (i = 0; i < 10; i-=3, j+=2)\t/* { dg-error \"23:invalid increment expression\" } */\n+  for (i = 0; i < 10; i-=3, j+=2)\t/* { dg-error \"27:invalid increment expression\" } */\n     baz (i);\n }"}, {"sha": "010a6c3e4dd1281ce738d313eaf131b011327fbd", "filename": "gcc/testsuite/gcc.dg/gomp/pr27415.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fpr27415.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fpr27415.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fpr27415.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -15,8 +15,8 @@ void\n test2 (void)\n {\n   int i = 0;\n-#pragma omp parallel for firstprivate (i)\n-  for (i = 0; i < 10; i++)\t\t\t/* { dg-error \"should not be firstprivate\" } */\n+#pragma omp parallel for firstprivate (i)\t/* { dg-error \"should not be firstprivate\" } */\n+  for (i = 0; i < 10; i++)\n     ;\n }\n \n@@ -34,8 +34,8 @@ void\n test4 (void)\n {\n   int i = 0;\n-#pragma omp parallel for reduction (*:i)\n-  for (i = 0; i < 10; i++)\t\t\t/* { dg-error \"should not be reduction\" } */\n+#pragma omp parallel for reduction (*:i)\t/* { dg-error \"should not be reduction\" } */\n+  for (i = 0; i < 10; i++)\n     ;\n }\n "}, {"sha": "6706a706bfe9c3173c23159afcb95bef5365f1c0", "filename": "gcc/testsuite/gcc.dg/label-decl-2.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftestsuite%2Fgcc.dg%2Flabel-decl-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftestsuite%2Fgcc.dg%2Flabel-decl-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flabel-decl-2.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -8,9 +8,8 @@ typedef int b;\n void\n f (void)\n {\n-  __label__ a, b, c, d;\n+  __label__ a, b, c, d; /* { dg-warning \"ISO C forbids label declarations\" \"label decls\" { target *-*-* } 11 } */\n   __extension__ (void)&&d; /* { dg-error \"label 'd' used but not defined\" } */\n-  /* { dg-warning \"ISO C forbids label declarations\" \"label decls\" { target *-*-* } 11 } */\n   goto c; /* { dg-error \"label 'c' used but not defined\" } */\n  a: (void)0;\n  b: (void)0;"}, {"sha": "5820ded922ea7d6f345d44ec542e5d48ab8fe4d3", "filename": "gcc/testsuite/gcc.dg/nofixed-point-2.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftestsuite%2Fgcc.dg%2Fnofixed-point-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftestsuite%2Fgcc.dg%2Fnofixed-point-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fnofixed-point-2.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -9,7 +9,7 @@ f1 (void)\n }\n \n __typeof (0r)\t\t       /* { dg-error \"not supported\" \"reject fixed-point\" } */\n-b2 (void)\n+b2 (void)\t\t       /* { dg-warning \"defaults to\" } */\n {\n   return 0r;\t\t       /* { dg-error \"not supported\" \"reject fixed-point\" } */\n }\n@@ -26,5 +26,4 @@ f4 (void)\t\t\t/* { dg-error \"not supported\" \"reject fixed-point\" } */\n   return 0k;\t\t\t/* { dg-error \"not supported\" \"reject fixed-point\" } */\n }\n \n-/* { dg-warning \"defaults to\" \"\" { target *-*-* } 13 } */\n /* { dg-error \"is used without\" \"\" { target *-*-* } 24 } */"}, {"sha": "e7e690e141751768a026c5250f84937207032e1a", "filename": "gcc/testsuite/gcc.dg/old-style-prom-2.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftestsuite%2Fgcc.dg%2Fold-style-prom-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftestsuite%2Fgcc.dg%2Fold-style-prom-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fold-style-prom-2.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -7,8 +7,8 @@ float f (float, float); /* { dg-warning \"prototype declaration\" } */\n \n float\n f (x, y)\n-     float x;\n-     float y;\n-{ /* { dg-warning \"promoted argument '.' doesn't match prototype\" } */\n+     float x; /* { dg-warning \"promoted argument 'x' doesn't match prototype\" } */\n+     float y; /* { dg-warning \"promoted argument 'y' doesn't match prototype\" } */\n+{\n   return x + y;\n }"}, {"sha": "720367f2e3303959f3bad0c65bdb9e5ab6fbb4a0", "filename": "gcc/testsuite/gcc.dg/old-style-prom-3.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftestsuite%2Fgcc.dg%2Fold-style-prom-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftestsuite%2Fgcc.dg%2Fold-style-prom-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fold-style-prom-3.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -7,8 +7,8 @@ float f (float, float); /* { dg-error \"prototype declaration\" } */\n \n float\n f (x, y)\n-     float x;\n-     float y;\n-{ /* { dg-error \"promoted argument '.' doesn't match prototype\" } */\n+     float x; /* { dg-error \"promoted argument 'x' doesn't match prototype\" } */\n+     float y; /* { dg-error \"promoted argument 'y' doesn't match prototype\" } */\n+{\n   return x + y;\n }"}, {"sha": "78909df368b5923f15155222c4cef5b467366ace", "filename": "gcc/testsuite/gcc.dg/overflow-warn-1.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftestsuite%2Fgcc.dg%2Foverflow-warn-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftestsuite%2Fgcc.dg%2Foverflow-warn-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Foverflow-warn-1.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -12,23 +12,23 @@ enum e {\n   /* Overflow in an unevaluated part of an expression is OK (example\n      in the standard).  */\n   E2 = 2 || 1 / 0,\n-  E3 = 1 / 0, /* { dg-warning \"division by zero\" } */\n-  /* { dg-error \"enumerator value for 'E3' is not an integer constant\" \"enum error\" { target *-*-* } 15 } */\n+  E3 = 1 / 0, /* { dg-warning \"10:division by zero\" } */\n+  /* { dg-error \"3:enumerator value for 'E3' is not an integer constant\" \"enum error\" { target *-*-* } 15 } */\n   /* But as in DR#031, the 1/0 in an evaluated subexpression means the\n      whole expression violates the constraints.  */\n-  E4 = 0 * (1 / 0), /* { dg-warning \"division by zero\" } */\n+  E4 = 0 * (1 / 0), /* { dg-warning \"15:division by zero\" } */\n   /* { dg-error \"enumerator value for 'E4' is not an integer constant\" \"enum error\" { target *-*-* } 19 } */\n-  E5 = INT_MAX + 1, /* { dg-warning \"integer overflow in expression\" } */\n+  E5 = INT_MAX + 1, /* { dg-warning \"16:integer overflow in expression\" } */\n   /* Again, overflow in evaluated subexpression.  */\n-  E6 = 0 * (INT_MAX + 1), /* { dg-warning \"integer overflow in expression\" } */\n+  E6 = 0 * (INT_MAX + 1), /* { dg-warning \"21:integer overflow in expression\" } */\n   /* A cast does not constitute overflow in conversion.  */\n   E7 = (char) INT_MAX\n };\n \n struct s {\n   int a;\n-  int : 0 * (1 / 0); /* { dg-warning \"division by zero\" } */\n-  /* { dg-error \"not an integer constant\" \"integer constant\" { target *-*-* } 30 } */\n+  int : 0 * (1 / 0); /* { dg-warning \"16:division by zero\" } */\n+  /* { dg-error \"not an integer constant\" \"22:integer constant\" { target *-*-* } 30 } */\n   int : 0 * (INT_MAX + 1); /* { dg-warning \"integer overflow in expression\" } */\n };\n \n@@ -37,11 +37,11 @@ f (void)\n {\n   /* This expression is not required to be a constant expression, so\n      it should just involve undefined behavior at runtime.  */\n-  int c = INT_MAX + 1; /* { dg-warning \"integer overflow in expression\" } */\n+  int c = INT_MAX + 1; /* { dg-warning \"19:integer overflow in expression\" } */\n }\n \n /* But this expression does need to be constant.  */\n-static int sc = INT_MAX + 1; /* { dg-warning \"integer overflow in expression\" } */\n+static int sc = INT_MAX + 1; /* { dg-warning \"25:integer overflow in expression\" } */\n \n /* The first two of these involve overflow, so are not null pointer\n    constants.  The third has the overflow in an unevaluated"}, {"sha": "5a75a10733f81e11339ea425fdcd17f4237d398a", "filename": "gcc/testsuite/gcc.dg/pr15698-1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftestsuite%2Fgcc.dg%2Fpr15698-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftestsuite%2Fgcc.dg%2Fpr15698-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr15698-1.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -17,7 +17,7 @@ int foobar ()\n }\n \n char *rindex(a, b)\n-     register char *a, b;\n-{ /* { dg-warning \"argument 'a' doesn't match built-in prototype\" } */\n+     register char *a, b; /* { dg-warning \"argument 'a' doesn't match built-in prototype\" } */\n+{\n   return 0;\n }"}, {"sha": "4140397c1427d54491d3bbaf64951733ab67419e", "filename": "gcc/testsuite/gcc.dg/pr20368-1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftestsuite%2Fgcc.dg%2Fpr20368-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftestsuite%2Fgcc.dg%2Fpr20368-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr20368-1.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -6,7 +6,7 @@\n extern __typeof (f) g; /* { dg-error \"'f' undeclared here \\\\(not in a function\\\\)\" } */\n \n int\n-f (x)\n-     float x; /* { dg-warning \"function declaration isn't a prototype\" } */\n+f (x) /* { dg-warning \"function declaration isn't a prototype\" } */\n+     float x;\n {\n }"}, {"sha": "5838134ad2110cf8ee40d163cf39e3c244d7703d", "filename": "gcc/testsuite/gcc.dg/tree-ssa/col-1.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcol-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcol-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcol-1.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fdump-tree-gimple-details-lineno\" } */\n+\n+void foo (int, int);\n+\n+int\n+m(int x)\n+{\n+ int c, a;\n+ a = (c = 5) + 16 + x * 2 ;\n+ foo (c, a);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"10:9.*c = 5\" 1 \"gimple\" } } */\n+/* { dg-final { scan-tree-dump-times \"10:14.*c . 16\" 1 \"gimple\" } } */\n+/* { dg-final { scan-tree-dump-times \"10:4.*a =\" 1 \"gimple\" } } */\n+/* { dg-final { cleanup-tree-dump \"gimple\" } } */"}, {"sha": "1d31876b9b45c53febee726bccc7c36c6aff24fc", "filename": "gcc/testsuite/gcc.dg/vla-8.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftestsuite%2Fgcc.dg%2Fvla-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftestsuite%2Fgcc.dg%2Fvla-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvla-8.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -23,8 +23,8 @@ void foo1(int n) {\n }\n \n void foo2(int n) {\n-  goto A;\t\t/* { dg-error \"jump into scope of identifier with variably modified type\" } */\n+  goto A;\n   int (*(*bar2)(void))[n];\n- A:\n+ A:\t/* { dg-error \"jump into scope of identifier with variably modified type\" } */\n   ;\n }"}, {"sha": "b71978016c51856d4752a6e716c513fb61ed57a8", "filename": "gcc/tree-call-cdce.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftree-call-cdce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftree-call-cdce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-call-cdce.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -779,7 +779,7 @@ shrink_wrap_one_built_in_call (gimple bi_call)\n   gcc_assert (cond_expr && gimple_code (cond_expr) == GIMPLE_COND);\n \n   /* Now the label.  */\n-  bi_call_label_decl = create_artificial_label ();\n+  bi_call_label_decl = create_artificial_label (gimple_location (bi_call));\n   bi_call_label = gimple_build_label (bi_call_label_decl);\n   gsi_insert_before (&bi_call_bsi, bi_call_label, GSI_SAME_STMT);\n "}, {"sha": "8470d765681ebcffe5778c4e55b4c9d68dda3a7d", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -329,7 +329,7 @@ factor_computed_gotos (void)\n \n \t      /* Build a label for the new block which will contain the\n \t\t factored computed goto.  */\n-\t      factored_label_decl = create_artificial_label ();\n+\t      factored_label_decl = create_artificial_label (UNKNOWN_LOCATION);\n \t      factored_computed_goto_label\n \t\t= gimple_build_label (factored_label_decl);\n \t      gsi_insert_after (&new_gsi, factored_computed_goto_label,\n@@ -4268,7 +4268,7 @@ verify_stmt (gimple_stmt_iterator *gsi)\n   if (addr)\n     {\n       debug_generic_expr (addr);\n-      inform (input_location, \"in statement\");\n+      inform (gimple_location (gsi_stmt (*gsi)), \"in statement\");\n       debug_gimple_stmt (stmt);\n       return true;\n     }\n@@ -4874,7 +4874,7 @@ gimple_block_label (basic_block bb)\n \t}\n     }\n \n-  label = create_artificial_label ();\n+  label = create_artificial_label (UNKNOWN_LOCATION);\n   stmt = gimple_build_label (label);\n   gsi_insert_before (&s, stmt, GSI_NEW_STMT);\n   return label;\n@@ -6033,7 +6033,7 @@ new_label_mapper (tree decl, void *data)\n   m = XNEW (struct tree_map);\n   m->hash = DECL_UID (decl);\n   m->base.from = decl;\n-  m->to = create_artificial_label ();\n+  m->to = create_artificial_label (UNKNOWN_LOCATION);\n   LABEL_DECL_UID (m->to) = LABEL_DECL_UID (decl);\n   if (LABEL_DECL_UID (m->to) >= cfun->cfg->last_label_uid)\n     cfun->cfg->last_label_uid = LABEL_DECL_UID (m->to) + 1;"}, {"sha": "e38b1bd8160c5cf25b02d7c2b9f5161b5e29f412", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 34, "deletions": 16, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -486,6 +486,7 @@ replace_goto_queue_cond_clause (tree *tp, struct leh_tf_state *tf,\n   tree label;\n   gimple_seq new_seq;\n   treemple temp;\n+  location_t loc = gimple_location (gsi_stmt (*gsi));\n \n   temp.tp = tp;\n   new_seq = find_goto_replacement (tf, temp);\n@@ -499,7 +500,7 @@ replace_goto_queue_cond_clause (tree *tp, struct leh_tf_state *tf,\n       return;\n     }\n \n-  label = create_artificial_label ();\n+  label = create_artificial_label (loc);\n   /* Set the new label for the GIMPLE_COND */\n   *tp = label;\n \n@@ -832,14 +833,15 @@ frob_into_branch_around (gimple tp, tree lab, tree over)\n {\n   gimple x;\n   gimple_seq cleanup, result;\n+  location_t loc = gimple_location (tp);\n \n   cleanup = gimple_try_cleanup (tp);\n   result = gimple_try_eval (tp);\n \n   if (gimple_seq_may_fallthru (result))\n     {\n       if (!over)\n-\tover = create_artificial_label ();\n+\tover = create_artificial_label (loc);\n       x = gimple_build_goto (over);\n       gimple_seq_add_stmt (&result, x);\n     }\n@@ -890,7 +892,7 @@ lower_try_finally_fallthru_label (struct leh_tf_state *tf)\n \n   if (!label)\n     {\n-      label = create_artificial_label ();\n+      label = create_artificial_label (gimple_location (tf->try_finally_expr));\n       tf->fallthru_label = label;\n       if (tf->outer->tf)\n         {\n@@ -1082,7 +1084,7 @@ lower_try_finally_nofallthru (struct leh_state *state,\n   if (tf->may_throw)\n     lab = tf->eh_label;\n   else\n-    lab = create_artificial_label ();\n+    lab = create_artificial_label (gimple_location (tf->try_finally_expr));\n \n   /* We expect that tf->top_p is a GIMPLE_TRY. */\n   finally = gimple_try_cleanup (tf->top_p);\n@@ -1117,6 +1119,7 @@ lower_try_finally_onedest (struct leh_state *state, struct leh_tf_state *tf)\n   gimple x;\n   gimple_seq finally;\n   tree finally_label;\n+  location_t loc = gimple_location (tf->try_finally_expr);\n \n   finally = gimple_try_cleanup (tf->top_p);\n   tf->top_p_seq = gimple_try_eval (tf->top_p);\n@@ -1148,7 +1151,7 @@ lower_try_finally_onedest (struct leh_state *state, struct leh_tf_state *tf)\n       return;\n     }\n \n-  finally_label = create_artificial_label ();\n+  finally_label = create_artificial_label (loc);\n   x = gimple_build_label (finally_label);\n   gimple_seq_add_stmt (&tf->top_p_seq, x);\n \n@@ -1201,6 +1204,7 @@ lower_try_finally_copy (struct leh_state *state, struct leh_tf_state *tf)\n   gimple_seq seq;\n   gimple x;\n   tree tmp;\n+  location_t tf_loc = gimple_location (tf->try_finally_expr);\n \n   finally = gimple_try_cleanup (tf->top_p);\n   tf->top_p_seq = gimple_try_eval (tf->top_p);\n@@ -1262,7 +1266,8 @@ lower_try_finally_copy (struct leh_state *state, struct leh_tf_state *tf)\n \t  if (! q)\n \t    continue;\n \n-\t  lab = labels[index].label = create_artificial_label ();\n+\t  lab = labels[index].label\n+\t    = create_artificial_label (tf_loc);\n \n \t  if (index == return_index)\n \t    do_return_redirection (q, lab, NULL, &return_val);\n@@ -1327,13 +1332,23 @@ lower_try_finally_switch (struct leh_state *state, struct leh_tf_state *tf)\n   gimple switch_stmt;\n   gimple_seq finally;\n   struct pointer_map_t *cont_map = NULL;\n+  /* The location of the TRY_FINALLY stmt.  */\n+  location_t tf_loc;\n+  /* The location of the finally block.  */\n+  location_t finally_loc;\n \n   switch_body = gimple_seq_alloc ();\n \n   /* Mash the TRY block to the head of the chain.  */\n   finally = gimple_try_cleanup (tf->top_p);\n   tf->top_p_seq = gimple_try_eval (tf->top_p);\n \n+  /* The location of the finally is either the last stmt in the finally\n+     block or the location of the TRY_FINALLY itself.  */\n+  finally_loc = gimple_seq_last_stmt (tf->top_p_seq) != NULL ?\n+    gimple_location (gimple_seq_last_stmt (tf->top_p_seq))\n+    : tf_loc;\n+\n   /* Lower the finally block itself.  */\n   lower_eh_constructs_1 (state, finally);\n \n@@ -1345,7 +1360,7 @@ lower_try_finally_switch (struct leh_state *state, struct leh_tf_state *tf)\n   ndests = fallthru_index + tf->may_fallthru;\n \n   finally_tmp = create_tmp_var (integer_type_node, \"finally_tmp\");\n-  finally_label = create_artificial_label ();\n+  finally_label = create_artificial_label (finally_loc);\n \n   /* We use VEC_quick_push on case_label_vec throughout this function,\n      since we know the size in advance and allocate precisely as muce\n@@ -1373,7 +1388,7 @@ lower_try_finally_switch (struct leh_state *state, struct leh_tf_state *tf)\n \n       last_case = build3 (CASE_LABEL_EXPR, void_type_node,\n \t\t\t  build_int_cst (NULL_TREE, fallthru_index), NULL,\n-\t\t\t  create_artificial_label ());\n+\t\t\t  create_artificial_label (tf_loc));\n       VEC_quick_push (tree, case_label_vec, last_case);\n       last_case_index++;\n \n@@ -1396,7 +1411,7 @@ lower_try_finally_switch (struct leh_state *state, struct leh_tf_state *tf)\n \n       last_case = build3 (CASE_LABEL_EXPR, void_type_node,\n \t\t\t  build_int_cst (NULL_TREE, eh_index), NULL,\n-\t\t\t  create_artificial_label ());\n+\t\t\t  create_artificial_label (tf_loc));\n       VEC_quick_push (tree, case_label_vec, last_case);\n       last_case_index++;\n \n@@ -1480,7 +1495,7 @@ lower_try_finally_switch (struct leh_state *state, struct leh_tf_state *tf)\n       gcc_assert (slot);\n       cont_stmt = *(gimple *) slot;\n \n-      label = create_artificial_label ();\n+      label = create_artificial_label (tf_loc);\n       CASE_LABEL (last_case) = label;\n \n       x = gimple_build_label (label);\n@@ -1502,6 +1517,7 @@ lower_try_finally_switch (struct leh_state *state, struct leh_tf_state *tf)\n      label.  */\n   switch_stmt = gimple_build_switch_vec (finally_tmp, last_case,\n                                          case_label_vec);\n+  gimple_set_location (switch_stmt, finally_loc);\n \n   /* Need to link SWITCH_STMT after running replace_goto_queue\n      due to not wanting to process the same goto stmts twice.  */\n@@ -1561,6 +1577,7 @@ lower_try_finally (struct leh_state *state, gimple tp)\n   struct leh_tf_state this_tf;\n   struct leh_state this_state;\n   int ndests;\n+  location_t tf_loc = gimple_location (tp);\n \n   /* Process the try block.  */\n \n@@ -1587,7 +1604,7 @@ lower_try_finally (struct leh_state *state, gimple tp)\n     this_tf.may_throw = get_eh_region_may_contain_throw (this_tf.region);\n   if (this_tf.may_throw)\n     {\n-      this_tf.eh_label = create_artificial_label ();\n+      this_tf.eh_label = create_artificial_label (tf_loc);\n       set_eh_region_tree_label (this_tf.region, this_tf.eh_label);\n       honor_protect_cleanup_actions (state, &this_state, &this_tf);\n     }\n@@ -1650,6 +1667,7 @@ lower_catch (struct leh_state *state, gimple tp)\n   struct leh_state this_state;\n   gimple_stmt_iterator gsi;\n   tree out_label;\n+  location_t try_catch_loc = gimple_location (tp);\n \n   try_region = gen_eh_region_try (state->cur_region);\n   this_state.cur_region = try_region;\n@@ -1676,7 +1694,7 @@ lower_catch (struct leh_state *state, gimple tp)\n       this_state.cur_region = catch_region;\n       lower_eh_constructs_1 (&this_state, gimple_catch_handler (gcatch));\n \n-      eh_label = create_artificial_label ();\n+      eh_label = create_artificial_label (try_catch_loc);\n       set_eh_region_tree_label (catch_region, eh_label);\n \n       x = gimple_build_label (eh_label);\n@@ -1685,7 +1703,7 @@ lower_catch (struct leh_state *state, gimple tp)\n       if (gimple_seq_may_fallthru (gimple_catch_handler (gcatch)))\n \t{\n \t  if (!out_label)\n-\t    out_label = create_artificial_label ();\n+\t    out_label = create_artificial_label (try_catch_loc);\n \n \t  x = gimple_build_goto (out_label);\n \t  gimple_seq_add_stmt (gimple_catch_handler_ptr (gcatch), x);\n@@ -1731,7 +1749,7 @@ lower_eh_filter (struct leh_state *state, gimple tp)\n   lower_eh_constructs_1 (state, gimple_eh_filter_failure (inner));\n   gimple_try_set_cleanup (tp, gimple_eh_filter_failure (inner));\n \n-  eh_label = create_artificial_label ();\n+  eh_label = create_artificial_label (gimple_location (inner));\n   set_eh_region_tree_label (this_region, eh_label);\n \n   return frob_into_branch_around (tp, eh_label, NULL);\n@@ -1770,13 +1788,13 @@ lower_cleanup (struct leh_state *state, gimple tp)\n   /* Build enough of a try-finally state so that we can reuse\n      honor_protect_cleanup_actions.  */\n   memset (&fake_tf, 0, sizeof (fake_tf));\n-  fake_tf.top_p = tp;\n+  fake_tf.top_p = fake_tf.try_finally_expr = tp;\n   fake_tf.outer = state;\n   fake_tf.region = this_region;\n   fake_tf.may_fallthru = gimple_seq_may_fallthru (gimple_try_eval (tp));\n   fake_tf.may_throw = true;\n \n-  fake_tf.eh_label = create_artificial_label ();\n+  fake_tf.eh_label = create_artificial_label (gimple_location (tp));\n   set_eh_region_tree_label (this_region, fake_tf.eh_label);\n \n   honor_protect_cleanup_actions (state, NULL, &fake_tf);"}, {"sha": "052d3412869ee6a743ff2141fc9abc9a4477233f", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -974,7 +974,7 @@ copy_tree_body_r (tree *tp, int *walk_subtrees, void *data)\n \t      STRIP_TYPE_NOPS (value);\n \t      if (TREE_CONSTANT (value) || TREE_READONLY (value))\n \t\t{\n-\t\t  *tp = build_empty_stmt ();\n+\t\t  *tp = build_empty_stmt (EXPR_LOCATION (*tp));\n \t\t  return copy_tree_body_r (tp, walk_subtrees, data);\n \t\t}\n \t    }\n@@ -2648,7 +2648,6 @@ inline_forbidden_p_2 (tree *nodep, int *walk_subtrees,\n static bool\n inline_forbidden_p (tree fndecl)\n {\n-  location_t saved_loc = input_location;\n   struct function *fun = DECL_STRUCT_FUNCTION (fndecl);\n   tree step;\n   struct walk_stmt_info wi;\n@@ -2691,7 +2690,6 @@ inline_forbidden_p (tree fndecl)\n \n egress:\n   pointer_set_destroy (visited_nodes);\n-  input_location = saved_loc;\n   return forbidden_p;\n }\n \n@@ -4183,7 +4181,8 @@ copy_decl_to_var (tree decl, copy_body_data *id)\n \n   type = TREE_TYPE (decl);\n \n-  copy = build_decl (VAR_DECL, DECL_NAME (decl), type);\n+  copy = build_decl (DECL_SOURCE_LOCATION (id->dst_fn),\n+\t\t     VAR_DECL, DECL_NAME (decl), type);\n   TREE_ADDRESSABLE (copy) = TREE_ADDRESSABLE (decl);\n   TREE_READONLY (copy) = TREE_READONLY (decl);\n   TREE_THIS_VOLATILE (copy) = TREE_THIS_VOLATILE (decl);\n@@ -4207,7 +4206,8 @@ copy_result_decl_to_var (tree decl, copy_body_data *id)\n   if (DECL_BY_REFERENCE (decl))\n     type = TREE_TYPE (type);\n \n-  copy = build_decl (VAR_DECL, DECL_NAME (decl), type);\n+  copy = build_decl (DECL_SOURCE_LOCATION (id->dst_fn),\n+\t\t     VAR_DECL, DECL_NAME (decl), type);\n   TREE_READONLY (copy) = TREE_READONLY (decl);\n   TREE_THIS_VOLATILE (copy) = TREE_THIS_VOLATILE (decl);\n   if (!DECL_BY_REFERENCE (decl))"}, {"sha": "cfba33d9c665a253f1b81a78b21560192f98d6ec", "filename": "gcc/tree-mudflap.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftree-mudflap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftree-mudflap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-mudflap.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -295,7 +295,8 @@ static GTY (()) tree mf_set_options_fndecl;\n static inline tree\n mf_make_builtin (enum tree_code category, const char *name, tree type)\n {\n-  tree decl = mf_mark (build_decl (category, get_identifier (name), type));\n+  tree decl = mf_mark (build_decl (UNKNOWN_LOCATION,\n+\t\t\t\t   category, get_identifier (name), type));\n   TREE_PUBLIC (decl) = 1;\n   DECL_EXTERNAL (decl) = 1;\n   lang_hooks.decls.pushdecl (decl);\n@@ -315,8 +316,10 @@ mf_make_mf_cache_struct_type (tree field_type)\n   /* There is, abominably, no language-independent way to construct a\n      RECORD_TYPE.  So we have to call the basic type construction\n      primitives by hand.  */\n-  tree fieldlo = build_decl (FIELD_DECL, get_identifier (\"low\"), field_type);\n-  tree fieldhi = build_decl (FIELD_DECL, get_identifier (\"high\"), field_type);\n+  tree fieldlo = build_decl (UNKNOWN_LOCATION,\n+\t\t\t     FIELD_DECL, get_identifier (\"low\"), field_type);\n+  tree fieldhi = build_decl (UNKNOWN_LOCATION,\n+\t\t\t     FIELD_DECL, get_identifier (\"high\"), field_type);\n \n   tree struct_type = make_node (RECORD_TYPE);\n   DECL_CONTEXT (fieldlo) = struct_type;"}, {"sha": "80041ec66a7b248018ee4f866a914241da9fa127", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -314,7 +314,8 @@ get_chain_decl (struct nesting_info *info)\n \t Note also that it's represented as a parameter.  This is more\n \t close to the truth, since the initial value does come from \n \t the caller.  */\n-      decl = build_decl (PARM_DECL, create_tmp_var_name (\"CHAIN\"), type);\n+      decl = build_decl (DECL_SOURCE_LOCATION (info->context),\n+\t\t\t PARM_DECL, create_tmp_var_name (\"CHAIN\"), type);\n       DECL_ARTIFICIAL (decl) = 1;\n       DECL_IGNORED_P (decl) = 1;\n       TREE_USED (decl) = 1;\n@@ -427,7 +428,7 @@ save_tmp_var (struct nesting_info *info, tree exp, gimple_stmt_iterator *gsi)\n static GTY(()) tree trampoline_type;\n \n static tree\n-get_trampoline_type (void)\n+get_trampoline_type (struct nesting_info *info)\n {\n   unsigned align, size;\n   tree t;\n@@ -448,7 +449,8 @@ get_trampoline_type (void)\n \n   t = build_index_type (build_int_cst (NULL_TREE, size - 1));\n   t = build_array_type (char_type_node, t);\n-  t = build_decl (FIELD_DECL, get_identifier (\"__data\"), t);\n+  t = build_decl (DECL_SOURCE_LOCATION (info->context),\n+\t\t  FIELD_DECL, get_identifier (\"__data\"), t);\n   DECL_ALIGN (t) = align;\n   DECL_USER_ALIGN (t) = 1;\n \n@@ -481,7 +483,7 @@ lookup_tramp_for_decl (struct nesting_info *info, tree decl,\n     {\n       tree field = make_node (FIELD_DECL);\n       DECL_NAME (field) = DECL_NAME (decl);\n-      TREE_TYPE (field) = get_trampoline_type ();\n+      TREE_TYPE (field) = get_trampoline_type (info);\n       TREE_ADDRESSABLE (field) = 1;\n \n       insert_field_into_struct (get_frame_type (info), field);\n@@ -818,9 +820,9 @@ get_nonlocal_debug_decl (struct nesting_info *info, tree decl)\n     x = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (x)), x);\n \n   /* ??? We should be remapping types as well, surely.  */\n-  new_decl = build_decl (VAR_DECL, DECL_NAME (decl), TREE_TYPE (decl));\n+  new_decl = build_decl (DECL_SOURCE_LOCATION (decl),\n+\t\t\t VAR_DECL, DECL_NAME (decl), TREE_TYPE (decl));\n   DECL_CONTEXT (new_decl) = info->context;\n-  DECL_SOURCE_LOCATION (new_decl) = DECL_SOURCE_LOCATION (decl);\n   DECL_ARTIFICIAL (new_decl) = DECL_ARTIFICIAL (decl);\n   DECL_IGNORED_P (new_decl) = DECL_IGNORED_P (decl);\n   TREE_THIS_VOLATILE (new_decl) = TREE_THIS_VOLATILE (decl);\n@@ -1209,7 +1211,8 @@ convert_nonlocal_reference_stmt (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n \t{\n \t  tree c, decl;\n \t  decl = get_chain_decl (info);\n-\t  c = build_omp_clause (OMP_CLAUSE_FIRSTPRIVATE);\n+\t  c = build_omp_clause (gimple_location (stmt),\n+\t\t\t\tOMP_CLAUSE_FIRSTPRIVATE);\n \t  OMP_CLAUSE_DECL (c) = decl;\n \t  OMP_CLAUSE_CHAIN (c) = gimple_omp_taskreg_clauses (stmt);\n \t  gimple_omp_taskreg_set_clauses (stmt, c);\n@@ -1302,9 +1305,9 @@ get_local_debug_decl (struct nesting_info *info, tree decl, tree field)\n   x = info->frame_decl;\n   x = build3 (COMPONENT_REF, TREE_TYPE (field), x, field, NULL_TREE);\n \n-  new_decl = build_decl (VAR_DECL, DECL_NAME (decl), TREE_TYPE (decl));\n+  new_decl = build_decl (DECL_SOURCE_LOCATION (decl),\n+\t\t\t VAR_DECL, DECL_NAME (decl), TREE_TYPE (decl));\n   DECL_CONTEXT (new_decl) = info->context;\n-  DECL_SOURCE_LOCATION (new_decl) = DECL_SOURCE_LOCATION (decl);\n   DECL_ARTIFICIAL (new_decl) = DECL_ARTIFICIAL (decl);\n   DECL_IGNORED_P (new_decl) = DECL_IGNORED_P (decl);\n   TREE_THIS_VOLATILE (new_decl) = TREE_THIS_VOLATILE (decl);\n@@ -1616,7 +1619,8 @@ convert_local_reference_stmt (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n \t{\n \t  tree c;\n \t  (void) get_frame_type (info);\n-\t  c = build_omp_clause (OMP_CLAUSE_SHARED);\n+\t  c = build_omp_clause (gimple_location (stmt),\n+\t\t\t\tOMP_CLAUSE_SHARED);\n \t  OMP_CLAUSE_DECL (c) = info->frame_decl;\n \t  OMP_CLAUSE_CHAIN (c) = gimple_omp_taskreg_clauses (stmt);\n \t  gimple_omp_taskreg_set_clauses (stmt, c);\n@@ -1728,7 +1732,7 @@ convert_nl_goto_reference (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n   slot = pointer_map_insert (i->var_map, label);\n   if (*slot == NULL)\n     {\n-      new_label = create_artificial_label ();\n+      new_label = create_artificial_label (UNKNOWN_LOCATION);\n       DECL_NONLOCAL (new_label) = 1;\n       *slot = new_label;\n     }\n@@ -1960,8 +1964,9 @@ convert_gimple_call (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n \t      break;\n \t  if (c == NULL)\n \t    {\n-\t      c = build_omp_clause (i ? OMP_CLAUSE_FIRSTPRIVATE\n-\t\t\t\t      : OMP_CLAUSE_SHARED);\n+\t      c = build_omp_clause (gimple_location (stmt),\n+\t\t\t\t    i ? OMP_CLAUSE_FIRSTPRIVATE\n+\t\t\t\t    : OMP_CLAUSE_SHARED);\n \t      OMP_CLAUSE_DECL (c) = decl;\n \t      OMP_CLAUSE_CHAIN (c) = gimple_omp_taskreg_clauses (stmt);\n \t      gimple_omp_taskreg_set_clauses (stmt, c);"}, {"sha": "fb4d1df7cdb4713e150df4d042aff31d1509cf20", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -545,7 +545,8 @@ initialize_reductions (void **slot, void *data)\n   bvar = create_tmp_var (type, \"reduction\");\n   add_referenced_var (bvar);\n \n-  c = build_omp_clause (OMP_CLAUSE_REDUCTION);\n+  c = build_omp_clause (gimple_location (reduc->reduc_stmt),\n+\t\t\tOMP_CLAUSE_REDUCTION);\n   OMP_CLAUSE_REDUCTION_CODE (c) = reduc->reduction_code;\n   OMP_CLAUSE_DECL (c) = SSA_NAME_VAR (gimple_assign_lhs (reduc->reduc_stmt));\n \n@@ -852,7 +853,8 @@ add_field_for_reduction (void **slot, void *data)\n   struct reduction_info *const red = (struct reduction_info *) *slot;\n   tree const type = (tree) data;\n   tree var = SSA_NAME_VAR (gimple_assign_lhs (red->reduc_stmt));\n-  tree field = build_decl (FIELD_DECL, DECL_NAME (var), TREE_TYPE (var));\n+  tree field = build_decl (gimple_location (red->reduc_stmt),\n+\t\t\t   FIELD_DECL, DECL_NAME (var), TREE_TYPE (var));\n \n   insert_field_into_struct (type, field);\n \n@@ -871,7 +873,8 @@ add_field_for_name (void **slot, void *data)\n   tree type = (tree) data;\n   tree name = ssa_name (elt->version);\n   tree var = SSA_NAME_VAR (name);\n-  tree field = build_decl (FIELD_DECL, DECL_NAME (var), TREE_TYPE (var));\n+  tree field = build_decl (DECL_SOURCE_LOCATION (var),\n+\t\t\t   FIELD_DECL, DECL_NAME (var), TREE_TYPE (var));\n \n   insert_field_into_struct (type, field);\n   elt->field = field;\n@@ -1204,7 +1207,8 @@ separate_decls_in_region (edge entry, edge exit, htab_t reduction_list,\n     {\n       /* Create the type for the structure to store the ssa names to.  */\n       type = lang_hooks.types.make_type (RECORD_TYPE);\n-      type_name = build_decl (TYPE_DECL, create_tmp_var_name (\".paral_data\"),\n+      type_name = build_decl (BUILTINS_LOCATION,\n+\t\t\t      TYPE_DECL, create_tmp_var_name (\".paral_data\"),\n \t\t\t      type);\n       TYPE_NAME (type) = type_name;\n \n@@ -1284,7 +1288,8 @@ create_loop_fn (void)\n   name = get_identifier (tname);\n   type = build_function_type_list (void_type_node, ptr_type_node, NULL_TREE);\n \n-  decl = build_decl (FUNCTION_DECL, name, type);\n+  decl = build_decl (BUILTINS_LOCATION,\n+\t\t     FUNCTION_DECL, name, type);\n   if (!parallelized_functions)\n     parallelized_functions = BITMAP_GGC_ALLOC ();\n   bitmap_set_bit (parallelized_functions, DECL_UID (decl));\n@@ -1299,12 +1304,14 @@ create_loop_fn (void)\n   DECL_CONTEXT (decl) = NULL_TREE;\n   DECL_INITIAL (decl) = make_node (BLOCK);\n \n-  t = build_decl (RESULT_DECL, NULL_TREE, void_type_node);\n+  t = build_decl (BUILTINS_LOCATION,\n+\t\t  RESULT_DECL, NULL_TREE, void_type_node);\n   DECL_ARTIFICIAL (t) = 1;\n   DECL_IGNORED_P (t) = 1;\n   DECL_RESULT (decl) = t;\n \n-  t = build_decl (PARM_DECL, get_identifier (\".paral_data_param\"),\n+  t = build_decl (BUILTINS_LOCATION,\n+\t\t  PARM_DECL, get_identifier (\".paral_data_param\"),\n \t\t  ptr_type_node);\n   DECL_ARTIFICIAL (t) = 1;\n   DECL_ARG_TYPE (t) = ptr_type_node;\n@@ -1566,7 +1573,7 @@ create_parallel_loop (struct loop *loop, tree loop_fn, tree data,\n   paral_bb = single_pred (bb);\n   gsi = gsi_last_bb (paral_bb);\n \n-  t = build_omp_clause (OMP_CLAUSE_NUM_THREADS);\n+  t = build_omp_clause (BUILTINS_LOCATION, OMP_CLAUSE_NUM_THREADS);\n   OMP_CLAUSE_NUM_THREADS_EXPR (t)\n     = build_int_cst (integer_type_node, n_threads);\n   stmt = gimple_build_omp_parallel (NULL, t, loop_fn, data);\n@@ -1637,7 +1644,7 @@ create_parallel_loop (struct loop *loop, tree loop_fn, tree data,\n   /* Emit GIMPLE_OMP_FOR.  */\n   gimple_cond_set_lhs (cond_stmt, cvar_base);\n   type = TREE_TYPE (cvar);\n-  t = build_omp_clause (OMP_CLAUSE_SCHEDULE);\n+  t = build_omp_clause (BUILTINS_LOCATION, OMP_CLAUSE_SCHEDULE);\n   OMP_CLAUSE_SCHEDULE_KIND (t) = OMP_CLAUSE_SCHEDULE_STATIC;\n \n   for_stmt = gimple_build_omp_for (NULL, t, 1, NULL);"}, {"sha": "95ab49a75438d074bfa71ec4e0e4582315e42a4f", "filename": "gcc/tree-profile.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftree-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftree-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-profile.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -75,7 +75,7 @@ tree_init_ic_make_global_vars (void)\n   ptr_void = build_pointer_type (void_type_node);\n   \n   ic_void_ptr_var \n-    = build_decl (VAR_DECL, \n+    = build_decl (UNKNOWN_LOCATION, VAR_DECL, \n \t\t  get_identifier (\"__gcov_indirect_call_callee\"), \n \t\t  ptr_void);\n   TREE_STATIC (ic_void_ptr_var) = 1;\n@@ -86,7 +86,7 @@ tree_init_ic_make_global_vars (void)\n \n   gcov_type_ptr = build_pointer_type (get_gcov_type ());\n   ic_gcov_type_ptr_var \n-    = build_decl (VAR_DECL, \n+    = build_decl (UNKNOWN_LOCATION, VAR_DECL, \n \t\t  get_identifier (\"__gcov_indirect_call_counters\"), \n \t\t  gcov_type_ptr);\n   TREE_STATIC (ic_gcov_type_ptr_var) = 1;"}, {"sha": "3c88766a998c4635438ed806d99f0a9f4b5a2001", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 65, "deletions": 29, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -1048,7 +1048,8 @@ ccp_fold (gimple stmt)\n \t\t  if (!useless_type_conversion_p (TREE_TYPE (lhs),\n \t\t\t\t\t\t  TREE_TYPE (op0))\n \t\t      && ((tem = maybe_fold_offset_to_address\n-\t\t\t\t   (op0, integer_zero_node, TREE_TYPE (lhs)))\n+\t\t\t   (gimple_location (stmt),\n+\t\t\t    op0, integer_zero_node, TREE_TYPE (lhs)))\n \t\t\t  != NULL_TREE))\n \t\t    return tem;\n \t\t  return op0;\n@@ -1085,8 +1086,8 @@ ccp_fold (gimple stmt)\n \t\t  && TREE_CODE (op1) == INTEGER_CST)\n \t\t{\n \t\t  tree lhs = gimple_assign_lhs (stmt);\n-\t\t  tree tem = maybe_fold_offset_to_address (op0, op1,\n-\t\t\t\t\t\t\t   TREE_TYPE (lhs));\n+\t\t  tree tem = maybe_fold_offset_to_address\n+\t\t    (gimple_location (stmt), op0, op1, TREE_TYPE (lhs));\n \t\t  if (tem != NULL_TREE)\n \t\t    return tem;\n \t\t}\n@@ -1644,10 +1645,13 @@ struct gimple_opt_pass pass_ccp =\n \n /* A subroutine of fold_stmt.  Attempts to fold *(A+O) to A[X].\n    BASE is an array type.  OFFSET is a byte displacement.  ORIG_TYPE\n-   is the desired result type.  */\n+   is the desired result type.\n+\n+   LOC is the location of the original expression.  */\n \n static tree\n-maybe_fold_offset_to_array_ref (tree base, tree offset, tree orig_type,\n+maybe_fold_offset_to_array_ref (location_t loc, tree base, tree offset,\n+\t\t\t\ttree orig_type,\n \t\t\t\tbool allow_negative_idx)\n {\n   tree min_idx, idx, idx_type, elt_offset = integer_zero_node;\n@@ -1780,16 +1784,23 @@ maybe_fold_offset_to_array_ref (tree base, tree offset, tree orig_type,\n \t   && compare_tree_int (idx, 0) < 0)\n     return NULL_TREE;\n \n-  return build4 (ARRAY_REF, elt_type, base, idx, NULL_TREE, NULL_TREE);\n+  {\n+    tree t = build4 (ARRAY_REF, elt_type, base, idx, NULL_TREE, NULL_TREE);\n+    SET_EXPR_LOCATION (t, loc);\n+    return t;\n+  }\n }\n \n \n /* Attempt to fold *(S+O) to S.X.\n    BASE is a record type.  OFFSET is a byte displacement.  ORIG_TYPE\n-   is the desired result type.  */\n+   is the desired result type.\n+\n+   LOC is the location of the original expression.  */\n \n static tree\n-maybe_fold_offset_to_component_ref (tree record_type, tree base, tree offset,\n+maybe_fold_offset_to_component_ref (location_t loc, tree record_type,\n+\t\t\t\t    tree base, tree offset,\n \t\t\t\t    tree orig_type, bool base_is_ptr)\n {\n   tree f, t, field_type, tail_array_field, field_offset;\n@@ -1872,14 +1883,16 @@ maybe_fold_offset_to_component_ref (tree record_type, tree base, tree offset,\n \tnew_base = build1 (INDIRECT_REF, record_type, base);\n       else\n \tnew_base = base;\n+      protected_set_expr_location (new_base, loc);\n       new_base = build3 (COMPONENT_REF, field_type, new_base, f, NULL_TREE);\n+      protected_set_expr_location (new_base, loc);\n \n       /* Recurse to possibly find the match.  */\n-      ret = maybe_fold_offset_to_array_ref (new_base, t, orig_type,\n+      ret = maybe_fold_offset_to_array_ref (loc, new_base, t, orig_type,\n \t\t\t\t\t    f == TYPE_FIELDS (record_type));\n       if (ret)\n \treturn ret;\n-      ret = maybe_fold_offset_to_component_ref (field_type, new_base, t,\n+      ret = maybe_fold_offset_to_component_ref (loc, field_type, new_base, t,\n \t\t\t\t\t\torig_type, false);\n       if (ret)\n \treturn ret;\n@@ -1895,25 +1908,32 @@ maybe_fold_offset_to_component_ref (tree record_type, tree base, tree offset,\n   /* If we get here, we've got an aggregate field, and a possibly \n      nonzero offset into them.  Recurse and hope for a valid match.  */\n   if (base_is_ptr)\n-    base = build1 (INDIRECT_REF, record_type, base);\n+    {\n+      base = build1 (INDIRECT_REF, record_type, base);\n+      SET_EXPR_LOCATION (base, loc);\n+    }\n   base = build3 (COMPONENT_REF, field_type, base, f, NULL_TREE);\n+  SET_EXPR_LOCATION (base, loc);\n \n-  t = maybe_fold_offset_to_array_ref (base, offset, orig_type,\n+  t = maybe_fold_offset_to_array_ref (loc, base, offset, orig_type,\n \t\t\t\t      f == TYPE_FIELDS (record_type));\n   if (t)\n     return t;\n-  return maybe_fold_offset_to_component_ref (field_type, base, offset,\n+  return maybe_fold_offset_to_component_ref (loc, field_type, base, offset,\n \t\t\t\t\t     orig_type, false);\n }\n \n /* Attempt to express (ORIG_TYPE)BASE+OFFSET as BASE->field_of_orig_type\n-   or BASE[index] or by combination of those. \n+   or BASE[index] or by combination of those.\n+\n+   LOC is the location of original expression.\n \n    Before attempting the conversion strip off existing ADDR_EXPRs and\n    handled component refs.  */\n \n tree\n-maybe_fold_offset_to_reference (tree base, tree offset, tree orig_type)\n+maybe_fold_offset_to_reference (location_t loc, tree base, tree offset,\n+\t\t\t\ttree orig_type)\n {\n   tree ret;\n   tree type;\n@@ -1960,31 +1980,39 @@ maybe_fold_offset_to_reference (tree base, tree offset, tree orig_type)\n \treturn NULL_TREE;\n       type = TREE_TYPE (TREE_TYPE (base));\n     }\n-  ret = maybe_fold_offset_to_component_ref (type, base, offset,\n+  ret = maybe_fold_offset_to_component_ref (loc, type, base, offset,\n \t\t\t\t\t    orig_type, base_is_ptr);\n   if (!ret)\n     {\n       if (base_is_ptr)\n-\tbase = build1 (INDIRECT_REF, type, base);\n-      ret = maybe_fold_offset_to_array_ref (base, offset, orig_type, true);\n+\t{\n+\t  base = build1 (INDIRECT_REF, type, base);\n+\t  SET_EXPR_LOCATION (base, loc);\n+\t}\n+      ret = maybe_fold_offset_to_array_ref (loc,\n+\t\t\t\t\t    base, offset, orig_type, true);\n     }\n   return ret;\n }\n \n /* Attempt to express (ORIG_TYPE)&BASE+OFFSET as &BASE->field_of_orig_type\n    or &BASE[index] or by combination of those.\n \n+   LOC is the location of the original expression.\n+\n    Before attempting the conversion strip off existing component refs.  */\n \n tree\n-maybe_fold_offset_to_address (tree addr, tree offset, tree orig_type)\n+maybe_fold_offset_to_address (location_t loc, tree addr, tree offset,\n+\t\t\t      tree orig_type)\n {\n   tree t;\n \n   gcc_assert (POINTER_TYPE_P (TREE_TYPE (addr))\n \t      && POINTER_TYPE_P (orig_type));\n \n-  t = maybe_fold_offset_to_reference (addr, offset, TREE_TYPE (orig_type));\n+  t = maybe_fold_offset_to_reference (loc, addr, offset,\n+\t\t\t\t      TREE_TYPE (orig_type));\n   if (t != NULL_TREE)\n     {\n       tree orig = addr;\n@@ -2021,7 +2049,9 @@ maybe_fold_offset_to_address (tree addr, tree offset, tree orig_type)\n       ptr_type = build_pointer_type (TREE_TYPE (t));\n       if (!useless_type_conversion_p (orig_type, ptr_type))\n \treturn NULL_TREE;\n-      return build_fold_addr_expr_with_type (t, ptr_type);\n+      t = build_fold_addr_expr_with_type (t, ptr_type);\n+      protected_set_expr_location (t, loc);\n+      return t;\n     }\n \n   return NULL_TREE;\n@@ -2035,6 +2065,7 @@ maybe_fold_stmt_indirect (tree expr, tree base, tree offset)\n {\n   tree t;\n   bool volatile_p = TREE_THIS_VOLATILE (expr);\n+  location_t loc = EXPR_LOCATION (expr);\n \n   /* We may well have constructed a double-nested PLUS_EXPR via multiple\n      substitutions.  Fold that down to one.  Remove NON_LVALUE_EXPRs that\n@@ -2075,7 +2106,7 @@ maybe_fold_stmt_indirect (tree expr, tree base, tree offset)\n \treturn DECL_INITIAL (base);\n \n       /* Try folding *(&B+O) to B.X.  */\n-      t = maybe_fold_offset_to_reference (base_addr, offset,\n+      t = maybe_fold_offset_to_reference (loc, base_addr, offset,\n \t\t\t\t\t  TREE_TYPE (expr));\n       if (t)\n \t{\n@@ -2114,7 +2145,7 @@ maybe_fold_stmt_indirect (tree expr, tree base, tree offset)\n       /* Try folding *(B+O) to B->X.  Still an improvement.  */\n       if (POINTER_TYPE_P (TREE_TYPE (base)))\n \t{\n-          t = maybe_fold_offset_to_reference (base, offset,\n+          t = maybe_fold_offset_to_reference (loc, base, offset,\n \t\t\t\t              TREE_TYPE (expr));\n \t  if (t)\n \t    return t;\n@@ -2139,7 +2170,7 @@ maybe_fold_stmt_indirect (tree expr, tree base, tree offset)\n    which may be able to propagate further.  */\n \n tree\n-maybe_fold_stmt_addition (tree res_type, tree op0, tree op1)\n+maybe_fold_stmt_addition (location_t loc, tree res_type, tree op0, tree op1)\n {\n   tree ptd_type;\n   tree t;\n@@ -2236,12 +2267,15 @@ maybe_fold_stmt_addition (tree res_type, tree op0, tree op1)\n     ptd_type = TREE_TYPE (TREE_TYPE (op0));\n \n   /* At which point we can try some of the same things as for indirects.  */\n-  t = maybe_fold_offset_to_array_ref (op0, op1, ptd_type, true);\n+  t = maybe_fold_offset_to_array_ref (loc, op0, op1, ptd_type, true);\n   if (!t)\n-    t = maybe_fold_offset_to_component_ref (TREE_TYPE (op0), op0, op1,\n+    t = maybe_fold_offset_to_component_ref (loc, TREE_TYPE (op0), op0, op1,\n \t\t\t\t\t    ptd_type, false);\n   if (t)\n-    t = build1 (ADDR_EXPR, res_type, t);\n+    {\n+      t = build1 (ADDR_EXPR, res_type, t);\n+      SET_EXPR_LOCATION (t, loc);\n+    }\n \n   return t;\n }\n@@ -2740,7 +2774,8 @@ fold_gimple_assign (gimple_stmt_iterator *si)\n \t\t && POINTER_TYPE_P (TREE_TYPE (gimple_assign_rhs1 (stmt))))\n \t  {\n \t    tree type = gimple_expr_type (stmt);\n-\t    tree t = maybe_fold_offset_to_address (gimple_assign_rhs1 (stmt),\n+\t    tree t = maybe_fold_offset_to_address (gimple_location (stmt),\n+\t\t\t\t\t\t   gimple_assign_rhs1 (stmt),\n \t\t\t\t\t\t   integer_zero_node, type);\n \t    if (t)\n \t      return t;\n@@ -2760,7 +2795,8 @@ fold_gimple_assign (gimple_stmt_iterator *si)\n \t\t    (TREE_TYPE (gimple_assign_lhs (stmt)), type))\n \t\ttype = TREE_TYPE (gimple_assign_rhs1 (stmt));\n \t    }\n-\t  result = maybe_fold_stmt_addition (type,\n+\t  result = maybe_fold_stmt_addition (gimple_location (stmt),\n+\t\t\t\t\t     type,\n \t\t\t\t\t     gimple_assign_rhs1 (stmt),\n \t\t\t\t\t     gimple_assign_rhs2 (stmt));\n \t}"}, {"sha": "bbce3304c4eca1987670c6da582e63c15bdd2c72", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -874,7 +874,8 @@ forward_propagate_addr_expr_1 (tree name, tree def_rhs,\n      of the elements in X into &x[C1 + C2/element size].  */\n   if (TREE_CODE (rhs2) == INTEGER_CST)\n     {\n-      tree new_rhs = maybe_fold_stmt_addition (TREE_TYPE (def_rhs),\n+      tree new_rhs = maybe_fold_stmt_addition (gimple_location (use_stmt),\n+\t  \t\t\t\t       TREE_TYPE (def_rhs),\n \t\t\t\t\t       def_rhs, rhs2);\n       if (new_rhs)\n \t{"}, {"sha": "b12f5c17826ebefb19c74e10ddf85d486296d1cc", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -185,7 +185,8 @@ create_vop_var (void)\n \n   gcc_assert (cfun->gimple_df->vop == NULL_TREE);\n \n-  global_var = build_decl (VAR_DECL, get_identifier (\".MEM\"),\n+  global_var = build_decl (BUILTINS_LOCATION, VAR_DECL,\n+\t\t\t   get_identifier (\".MEM\"),\n \t\t\t   void_type_node);\n   DECL_ARTIFICIAL (global_var) = 1;\n   TREE_READONLY (global_var) = 0;"}, {"sha": "ada47e16c08195ff8b1b3ef1f9b33b5c0a54c4d4", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -1258,7 +1258,7 @@ warn_uninit (tree t, const char *gmsgid, void *data)\n       if (xloc.file != floc.file\n \t  || xloc.line < floc.line\n \t  || xloc.line > LOCATION_LINE (cfun->function_end_locus))\n-\tinform (input_location, \"%J%qD was declared here\", var, var);\n+\tinform (location, \"%J%qD was declared here\", var, var);\n     }\n }\n "}, {"sha": "292c49cd126a3c38f530a9921bdf3aeeba0a62e8", "filename": "gcc/tree-switch-conversion.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftree-switch-conversion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftree-switch-conversion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-switch-conversion.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -499,6 +499,7 @@ build_one_array (gimple swtch, int num, tree arr_index_type, gimple phi,\n   tree name, cst;\n   gimple load;\n   gimple_stmt_iterator gsi = gsi_for_stmt (swtch);\n+  location_t loc = gimple_location (swtch);\n \n   gcc_assert (info.default_values[num]);\n \n@@ -517,7 +518,7 @@ build_one_array (gimple swtch, int num, tree arr_index_type, gimple phi,\n       ctor = build_constructor (array_type, info.constructors[num]);\n       TREE_CONSTANT (ctor) = true;\n \n-      decl = build_decl (VAR_DECL, NULL_TREE, array_type);\n+      decl = build_decl (loc, VAR_DECL, NULL_TREE, array_type);\n       TREE_STATIC (decl) = 1;\n       DECL_INITIAL (decl) = ctor;\n \n@@ -665,9 +666,9 @@ fix_phi_nodes (edge e1f, edge e2f, basic_block bbf)\n static void\n gen_inbound_check (gimple swtch)\n {\n-  tree label_decl1 = create_artificial_label ();\n-  tree label_decl2 = create_artificial_label ();\n-  tree label_decl3 = create_artificial_label ();\n+  tree label_decl1 = create_artificial_label (UNKNOWN_LOCATION);\n+  tree label_decl2 = create_artificial_label (UNKNOWN_LOCATION);\n+  tree label_decl3 = create_artificial_label (UNKNOWN_LOCATION);\n   gimple label1, label2, label3;\n \n   tree utype;"}, {"sha": "41a1beb2f2f40935363c31b1a27f9a1faf46609c", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -4971,7 +4971,7 @@ insert_range_assertions (void)\n    IGNORE_OFF_BY_ONE is true if the ARRAY_REF is inside a ADDR_EXPR.  */\n \n static void\n-check_array_ref (tree ref, location_t location, bool ignore_off_by_one)\n+check_array_ref (location_t location, tree ref, bool ignore_off_by_one)\n {\n   value_range_t* vr = NULL;\n   tree low_sub, up_sub;\n@@ -5067,7 +5067,7 @@ search_for_addr_array (tree t, location_t location)\n   do \n     {\n       if (TREE_CODE (t) == ARRAY_REF)\n-\tcheck_array_ref (t, location, true /*ignore_off_by_one*/);\n+\tcheck_array_ref (location, t, true /*ignore_off_by_one*/);\n \n       t = TREE_OPERAND (t, 0);\n     }\n@@ -5085,16 +5085,24 @@ check_array_bounds (tree *tp, int *walk_subtree, void *data)\n {\n   tree t = *tp;\n   struct walk_stmt_info *wi = (struct walk_stmt_info *) data;\n-  const location_t *location = (const location_t *) wi->info;\n+  location_t location;\n+\n+  if (EXPR_HAS_LOCATION (t))\n+    location = EXPR_LOCATION (t);\n+  else\n+    {\n+      location_t *locp = (location_t *) wi->info;\n+      location = *locp;\n+    }\n \n   *walk_subtree = TRUE;\n \n   if (TREE_CODE (t) == ARRAY_REF)\n-    check_array_ref (t, *location, false /*ignore_off_by_one*/);\n+    check_array_ref (location, t, false /*ignore_off_by_one*/);\n \n   if (TREE_CODE (t) == INDIRECT_REF\n       || (TREE_CODE (t) == RETURN_EXPR && TREE_OPERAND (t, 0)))\n-    search_for_addr_array (TREE_OPERAND (t, 0), *location);\n+    search_for_addr_array (TREE_OPERAND (t, 0), location);\n \n   if (TREE_CODE (t) == ADDR_EXPR)\n     *walk_subtree = FALSE;"}, {"sha": "eb1ad157cfa64cbc78cad42a48005f766e7b812f", "filename": "gcc/tree.c", "status": "modified", "additions": 26, "deletions": 13, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -2352,6 +2352,7 @@ save_expr (tree expr)\n     return t;\n \n   t = build1 (SAVE_EXPR, TREE_TYPE (expr), t);\n+  SET_EXPR_LOCATION (t, EXPR_LOCATION (expr));\n \n   /* This expression might be placed ahead of a jump to ensure that the\n      value was computed on both sides of the jump.  So make sure it isn't\n@@ -3537,15 +3538,19 @@ build_nt_call_vec (tree fn, VEC(tree,gc) *args)\n /* Create a DECL_... node of code CODE, name NAME and data type TYPE.\n    We do NOT enter this node in any sort of symbol table.\n \n+   LOC is the location of the decl.\n+\n    layout_decl is used to set up the decl's storage layout.\n    Other slots are initialized to 0 or null pointers.  */\n \n tree\n-build_decl_stat (enum tree_code code, tree name, tree type MEM_STAT_DECL)\n+build_decl_stat (location_t loc, enum tree_code code, tree name,\n+    \t\t tree type MEM_STAT_DECL)\n {\n   tree t;\n \n   t = make_node_stat (code PASS_MEM_STAT);\n+  DECL_SOURCE_LOCATION (t) = loc;\n \n /*  if (type == error_mark_node)\n     type = integer_type_node; */\n@@ -3567,7 +3572,7 @@ tree\n build_fn_decl (const char *name, tree type)\n {\n   tree id = get_identifier (name);\n-  tree decl = build_decl (FUNCTION_DECL, id, type);\n+  tree decl = build_decl (input_location, FUNCTION_DECL, id, type);\n \n   DECL_EXTERNAL (decl) = 1;\n   TREE_PUBLIC (decl) = 1;\n@@ -6336,7 +6341,8 @@ build_complex_type (tree component_type)\n \tname = 0;\n \n       if (name != 0)\n-\tTYPE_NAME (t) = build_decl (TYPE_DECL, get_identifier (name), t);\n+\tTYPE_NAME (t) = build_decl (UNKNOWN_LOCATION, TYPE_DECL,\n+\t    \t\t\t    get_identifier (name), t);\n     }\n \n   return build_qualified_type (t, TYPE_QUALS (component_type));\n@@ -7451,7 +7457,8 @@ make_vector_type (tree innertype, int nunits, enum machine_mode mode)\n \t\t\t\t   build_index_type (index));\n     tree rt = make_node (RECORD_TYPE);\n \n-    TYPE_FIELDS (rt) = build_decl (FIELD_DECL, get_identifier (\"f\"), array);\n+    TYPE_FIELDS (rt) = build_decl (UNKNOWN_LOCATION, FIELD_DECL,\n+\t\t\t\t   get_identifier (\"f\"), array);\n     DECL_CONTEXT (TYPE_FIELDS (rt)) = rt;\n     layout_type (rt);\n     TYPE_DEBUG_REPRESENTATION_TYPE (t) = rt;\n@@ -8139,19 +8146,22 @@ initializer_zerop (const_tree init)\n     }\n }\n \n-/* Build an empty statement.  */\n+/* Build an empty statement at location LOC.  */\n \n tree\n-build_empty_stmt (void)\n+build_empty_stmt (location_t loc)\n {\n-  return build1 (NOP_EXPR, void_type_node, size_zero_node);\n+  tree t = build1 (NOP_EXPR, void_type_node, size_zero_node);\n+  SET_EXPR_LOCATION (t, loc);\n+  return t;\n }\n \n \n-/* Build an OpenMP clause with code CODE.  */\n+/* Build an OpenMP clause with code CODE.  LOC is the location of the\n+   clause.  */\n \n tree\n-build_omp_clause (enum omp_clause_code code)\n+build_omp_clause (location_t loc, enum omp_clause_code code)\n {\n   tree t;\n   int size, length;\n@@ -8163,6 +8173,7 @@ build_omp_clause (enum omp_clause_code code)\n   memset (t, 0, size);\n   TREE_SET_CODE (t, OMP_CLAUSE);\n   OMP_CLAUSE_SET_CODE (t, code);\n+  OMP_CLAUSE_LOCATION (t) = loc;\n \n #ifdef GATHER_STATISTICS\n   tree_node_counts[(int) omp_clause_kind]++;\n@@ -9108,13 +9119,15 @@ call_expr_arglist (tree exp)\n }\n \n \n-/* Create a nameless artificial label and put it in the current function\n-   context.  Returns the newly created label.  */\n+/* Create a nameless artificial label and put it in the current\n+   function context.  The label has a location of LOC.  Returns the\n+   newly created label.  */\n \n tree\n-create_artificial_label (void)\n+create_artificial_label (location_t loc)\n {\n-  tree lab = build_decl (LABEL_DECL, NULL_TREE, void_type_node);\n+  tree lab = build_decl (loc,\n+      \t\t\t LABEL_DECL, NULL_TREE, void_type_node);\n \n   DECL_ARTIFICIAL (lab) = 1;\n   DECL_IGNORED_P (lab) = 1;"}, {"sha": "f490af402baea99370cb121c30ff5e5fc624c6f6", "filename": "gcc/tree.h", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -1563,7 +1563,7 @@ struct GTY(()) tree_constructor {\n \n /* True if a tree is an expression or statement that can have a\n    location.  */\n-#define CAN_HAVE_LOCATION_P(NODE) (EXPR_P (NODE))\n+#define CAN_HAVE_LOCATION_P(NODE) ((NODE) && EXPR_P (NODE))\n \n extern void protected_set_expr_location (tree, location_t);\n \n@@ -1725,6 +1725,9 @@ extern void protected_set_expr_location (tree, location_t);\n   OMP_CLAUSE_OPERAND (OMP_CLAUSE_RANGE_CHECK (OMP_CLAUSE_CHECK (NODE),\t\\\n \t\t\t\t\t      OMP_CLAUSE_PRIVATE,\t\\\n \t                                      OMP_CLAUSE_COPYPRIVATE), 0)\n+#define OMP_CLAUSE_HAS_LOCATION(NODE) \\\n+  ((OMP_CLAUSE_CHECK (NODE))->omp_clause.locus != UNKNOWN_LOCATION)\n+#define OMP_CLAUSE_LOCATION(NODE)  (OMP_CLAUSE_CHECK (NODE))->omp_clause.locus\n \n /* True on an OMP_SECTION statement that was the last lexical member.\n    This status is meaningful in the implementation of lastprivate.  */\n@@ -1919,6 +1922,7 @@ struct GTY(()) phi_arg_d {\n \n struct GTY(()) tree_omp_clause {\n   struct tree_common common;\n+  location_t locus;\n   enum omp_clause_code code;\n   union omp_clause_subcode {\n     enum omp_clause_default_kind  default_kind;\n@@ -3862,12 +3866,13 @@ extern tree build_tree_list_stat (tree, tree MEM_STAT_DECL);\n #define build_tree_list(t,q) build_tree_list_stat(t,q MEM_STAT_INFO)\n extern tree build_tree_list_vec_stat (const VEC(tree,gc) * MEM_STAT_DECL);\n #define build_tree_list_vec(v) build_tree_list_vec_stat (v MEM_STAT_INFO)\n-extern tree build_decl_stat (enum tree_code, tree, tree MEM_STAT_DECL);\n+extern tree build_decl_stat (location_t, enum tree_code,\n+\t\t\t     tree, tree MEM_STAT_DECL);\n extern tree build_fn_decl (const char *, tree);\n-#define build_decl(c,t,q) build_decl_stat (c,t,q MEM_STAT_INFO)\n+#define build_decl(l,c,t,q) build_decl_stat (l,c,t,q MEM_STAT_INFO)\n extern tree build_block (tree, tree, tree, tree);\n-extern tree build_empty_stmt (void);\n-extern tree build_omp_clause (enum omp_clause_code);\n+extern tree build_empty_stmt (location_t);\n+extern tree build_omp_clause (location_t, enum omp_clause_code);\n \n extern tree build_vl_exp_stat (enum tree_code, int MEM_STAT_DECL);\n #define build_vl_exp(c,n) build_vl_exp_stat (c,n MEM_STAT_INFO)\n@@ -4619,7 +4624,7 @@ extern int operand_equal_for_phi_arg_p (const_tree, const_tree);\n extern tree call_expr_arg (tree, int);\n extern tree *call_expr_argp (tree, int);\n extern tree call_expr_arglist (tree);\n-extern tree create_artificial_label (void);\n+extern tree create_artificial_label (location_t);\n extern const char *get_name (tree);\n extern bool stdarg_p (tree);\n extern bool prototype_p (tree);\n@@ -5169,9 +5174,9 @@ struct GTY(()) tree_priority_map {\n #define tree_priority_map_marked_p tree_map_base_marked_p\n \n /* In tree-ssa-ccp.c */\n-extern tree maybe_fold_offset_to_reference (tree, tree, tree);\n-extern tree maybe_fold_offset_to_address (tree, tree, tree);\n-extern tree maybe_fold_stmt_addition (tree, tree, tree);\n+extern tree maybe_fold_offset_to_reference (location_t, tree, tree, tree);\n+extern tree maybe_fold_offset_to_address (location_t, tree, tree, tree);\n+extern tree maybe_fold_stmt_addition (location_t, tree, tree, tree);\n \n /* In tree-ssa-address.c.  */\n extern tree tree_mem_ref_addr (tree, tree);"}, {"sha": "40a47fada99365d4b3bae8647bfbd3c99ec2f077", "filename": "gcc/varasm.c", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2255bc4884a7624b32185e188fdb94a4167a35c/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=c2255bc4884a7624b32185e188fdb94a4167a35c", "patch": "@@ -239,24 +239,28 @@ default_emutls_var_fields (tree type, tree *name ATTRIBUTE_UNUSED)\n {\n   tree word_type_node, field, next_field;\n   \n-  field = build_decl (FIELD_DECL, get_identifier (\"__templ\"), ptr_type_node);\n+  field = build_decl (UNKNOWN_LOCATION,\n+\t\t      FIELD_DECL, get_identifier (\"__templ\"), ptr_type_node);\n   DECL_CONTEXT (field) = type;\n   next_field = field;\n     \n-  field = build_decl (FIELD_DECL, get_identifier (\"__offset\"),\n+  field = build_decl (UNKNOWN_LOCATION,\n+\t\t      FIELD_DECL, get_identifier (\"__offset\"),\n \t\t      ptr_type_node);\n   DECL_CONTEXT (field) = type;\n   TREE_CHAIN (field) = next_field;\n   next_field = field;\n   \n   word_type_node = lang_hooks.types.type_for_mode (word_mode, 1);\n-  field = build_decl (FIELD_DECL, get_identifier (\"__align\"),\n+  field = build_decl (UNKNOWN_LOCATION,\n+\t\t      FIELD_DECL, get_identifier (\"__align\"),\n \t\t      word_type_node);\n   DECL_CONTEXT (field) = type;\n   TREE_CHAIN (field) = next_field;\n   next_field = field;\n   \n-  field = build_decl (FIELD_DECL, get_identifier (\"__size\"), word_type_node);\n+  field = build_decl (UNKNOWN_LOCATION,\n+\t\t      FIELD_DECL, get_identifier (\"__size\"), word_type_node);\n   DECL_CONTEXT (field) = type;\n   TREE_CHAIN (field) = next_field;\n \n@@ -280,7 +284,8 @@ get_emutls_object_type (void)\n   field = targetm.emutls.var_fields (type, &type_name);\n   if (!type_name)\n     type_name = get_identifier (\"__emutls_object\");\n-  type_name = build_decl (TYPE_DECL, type_name, type);\n+  type_name = build_decl (UNKNOWN_LOCATION,\n+\t\t\t  TYPE_DECL, type_name, type);\n   TYPE_NAME (type) = type_name;\n   TYPE_FIELDS (type) = field;\n   layout_type (type);\n@@ -309,7 +314,8 @@ get_emutls_init_templ_addr (tree decl)\n       name = prefix_name (prefix, name);\n     }\n \n-  to = build_decl (VAR_DECL, name, TREE_TYPE (decl));\n+  to = build_decl (DECL_SOURCE_LOCATION (decl),\n+\t\t   VAR_DECL, name, TREE_TYPE (decl));\n   SET_DECL_ASSEMBLER_NAME (to, DECL_NAME (to));\n   DECL_TLS_MODEL (to) = TLS_MODEL_EMULATED;\n   DECL_ARTIFICIAL (to) = 1;\n@@ -369,7 +375,8 @@ emutls_decl (tree decl)\n     to = h->to;\n   else\n     {\n-      to = build_decl (VAR_DECL, get_emutls_object_name (name),\n+      to = build_decl (DECL_SOURCE_LOCATION (decl),\n+\t\t       VAR_DECL, get_emutls_object_name (name),\n \t\t       get_emutls_object_type ());\n \n       h = GGC_NEW (struct tree_map);\n@@ -5269,7 +5276,8 @@ weak_finish (void)\n \n \t  if (! decl)\n \t    {\n-\t      decl = build_decl (TREE_CODE (alias_decl), target,\n+\t      decl = build_decl (DECL_SOURCE_LOCATION (alias_decl),\n+\t\t\t\t TREE_CODE (alias_decl), target,\n \t\t\t\t TREE_TYPE (alias_decl));\n \n \t      DECL_EXTERNAL (decl) = 1;"}]}