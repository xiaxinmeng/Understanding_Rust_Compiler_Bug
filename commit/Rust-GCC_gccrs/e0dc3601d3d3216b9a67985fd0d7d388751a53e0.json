{"sha": "e0dc3601d3d3216b9a67985fd0d7d388751a53e0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTBkYzM2MDFkM2QzMjE2YjlhNjc5ODVmZDBkN2QzODg3NTFhNTNlMA==", "commit": {"author": {"name": "Paul Brook", "email": "paul@codesourcery.com", "date": "2009-11-09T13:50:38Z"}, "committer": {"name": "Paul Brook", "email": "pbrook@gcc.gnu.org", "date": "2009-11-09T13:50:38Z"}, "message": "extend.texi (Half-Precision): Update wording to reflect that there are now multiple -mfpu options that enable...\n\n2009-11-09  Paul Brook  <paul@codesourcery.com>\n\tDaniel Jacobowitz  <dan@codesourcery.com>\n\tSandra Loosemore  <sandra@codesourcery.com>\n\n\tgcc/\n\t* doc/extend.texi (Half-Precision): Update wording to reflect\n\tthat there are now multiple -mfpu options that enable fp16\n\thardware support.\n\t* doc/invoke.texi: Update list of ARM -mfpu= options.\n\t* config.gcc: Update ARM --with-fpu option list.\n\t* config/arm/arm.c (all_fpus): Add vfpv3-fp16, vfpv3-d16-fp16,\n\tvfpv3xd and vfpv3xd-fp16.\n\t(use_vfp_abi): New function.\n\t(aapcs_vfp_is_call_or_return_candidate): Avoid double precision regs\n\twhen undesirable.\n\t(aapcs_vfp_is_return_candidate, aapcs_vfp_is_call_candidate,\n\taapcs_vfp_allocate_return_reg): Use use_vfp_abi.\n        (arm_rtx_costs_1, arm_size_rtx_costs, arm_fastmul_rtx_costs,\n        arm_9e_rtx_costs): Only expect double-precision operations if the FPU\n        provides them.\n\t(coproc_secondary_reload_class): Reload HFmode via GENERAL_REGS if no\n\tNEON.\n\t(arm_print_operand): Handle 'p' modifier.\n\t(arm_hard_regno_mode_ok): : Allow HFmode in VFP registers if\n\tTARGET_FP16.\n\t* config/arm/arm.h (TARGET_VFP_SINGLE, TARGET_VFP_DOUBLE): Define.\n\t(TARGET_FP16): Define.\n\t* config/arm/vfp.md: Disable double-precision patterns if the FPU\n\tdoes not provide them.\n\t(arm_movdi_vfp, thumb2_movdi_vfp): Use fcpys to move\n\tdouble-precision values on a single-precision FPU.\n        (movdf_vfp, thumb2_movdf_vfp): Likewise.  Use \"Dy\" for\n        double-precision constants.\n\t(movhf_vfp_neon): New pattern (was movhf_vfp).\n\t(movhf_vfp): Remove NEON instructions.\n\t* config/arm/constraints.md: Add new \"Dy\" constraint for\n\tdouble-precision constants.  Update description of \"Dv\".\n\t* config/arm/arm.md: Disable double-precision patterns if the FPU\n\tdoes not provide them\n\n\nCo-Authored-By: Daniel Jacobowitz <dan@codesourcery.com>\nCo-Authored-By: Sandra Loosemore <sandra@codesourcery.com>\n\nFrom-SVN: r154034", "tree": {"sha": "0681be105c1ce47f28a10d1445cf14a8a70ff9b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0681be105c1ce47f28a10d1445cf14a8a70ff9b9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e0dc3601d3d3216b9a67985fd0d7d388751a53e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0dc3601d3d3216b9a67985fd0d7d388751a53e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0dc3601d3d3216b9a67985fd0d7d388751a53e0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0dc3601d3d3216b9a67985fd0d7d388751a53e0/comments", "author": null, "committer": null, "parents": [{"sha": "2bf1730836d8cd41cf7cb7ea0434ead847cd0298", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bf1730836d8cd41cf7cb7ea0434ead847cd0298", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2bf1730836d8cd41cf7cb7ea0434ead847cd0298"}], "stats": {"total": 425, "additions": 319, "deletions": 106}, "files": [{"sha": "b6d48d85e19040de679cb896defc54ddb084bd55", "filename": "gcc/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0dc3601d3d3216b9a67985fd0d7d388751a53e0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0dc3601d3d3216b9a67985fd0d7d388751a53e0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e0dc3601d3d3216b9a67985fd0d7d388751a53e0", "patch": "@@ -1,3 +1,42 @@\n+2009-11-09  Paul Brook  <paul@codesourcery.com>\n+\tDaniel Jacobowitz  <dan@codesourcery.com>\n+\tSandra Loosemore  <sandra@codesourcery.com>\n+\n+\t* doc/extend.texi (Half-Precision): Update wording to reflect\n+\tthat there are now multiple -mfpu options that enable fp16\n+\thardware support.\n+\t* doc/invoke.texi: Update list of ARM -mfpu= options.\n+\t* config.gcc: Update ARM --with-fpu option list.\n+\t* config/arm/arm.c (all_fpus): Add vfpv3-fp16, vfpv3-d16-fp16,\n+\tvfpv3xd and vfpv3xd-fp16.\n+\t(use_vfp_abi): New function.\n+\t(aapcs_vfp_is_call_or_return_candidate): Avoid double precision regs\n+\twhen undesirable.\n+\t(aapcs_vfp_is_return_candidate, aapcs_vfp_is_call_candidate,\n+\taapcs_vfp_allocate_return_reg): Use use_vfp_abi.\n+        (arm_rtx_costs_1, arm_size_rtx_costs, arm_fastmul_rtx_costs,\n+        arm_9e_rtx_costs): Only expect double-precision operations if the FPU\n+        provides them.\n+\t(coproc_secondary_reload_class): Reload HFmode via GENERAL_REGS if no\n+\tNEON.\n+\t(arm_print_operand): Handle 'p' modifier.\n+\t(arm_hard_regno_mode_ok): : Allow HFmode in VFP registers if\n+\tTARGET_FP16.\n+\t* config/arm/arm.h (TARGET_VFP_SINGLE, TARGET_VFP_DOUBLE): Define.\n+\t(TARGET_FP16): Define.\n+\t* config/arm/vfp.md: Disable double-precision patterns if the FPU\n+\tdoes not provide them.\n+\t(arm_movdi_vfp, thumb2_movdi_vfp): Use fcpys to move\n+\tdouble-precision values on a single-precision FPU.\n+        (movdf_vfp, thumb2_movdf_vfp): Likewise.  Use \"Dy\" for\n+        double-precision constants.\n+\t(movhf_vfp_neon): New pattern (was movhf_vfp).\n+\t(movhf_vfp): Remove NEON instructions.\n+\t* config/arm/constraints.md: Add new \"Dy\" constraint for\n+\tdouble-precision constants.  Update description of \"Dv\".\n+\t* config/arm/arm.md: Disable double-precision patterns if the FPU\n+\tdoes not provide them\n+\n 2009-11-09  Jakub Jelinek  <jakub@redhat.com>\n \n \t* config/i386/i386.c (print_operand) <case 'D'>: Fix formatting."}, {"sha": "999ba218016753ca6ecdae43ca0963f9d4a21d75", "filename": "gcc/config.gcc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0dc3601d3d3216b9a67985fd0d7d388751a53e0/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0dc3601d3d3216b9a67985fd0d7d388751a53e0/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=e0dc3601d3d3216b9a67985fd0d7d388751a53e0", "patch": "@@ -2817,7 +2817,7 @@ case \"${target}\" in\n \n \t\tcase \"$with_fpu\" in\n \t\t\"\" \\\n-\t\t| fpa | fpe2 | fpe3 | maverick | vfp | vfp3 | neon )\n+\t\t| fpa | fpe2 | fpe3 | maverick | vfp | vfp3 | vfpv3 | vfpv3-fp16 | vfpv3-d16 | vfpv3-d16-fp16 | vfpv3xd | vfpv3xd-fp16 | neon | neon-fp16 )\n \t\t\t# OK\n \t\t\t;;\n \t\t*)"}, {"sha": "205bff22008b212242c20ab88d4e91da1b9aa114", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 105, "deletions": 42, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0dc3601d3d3216b9a67985fd0d7d388751a53e0/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0dc3601d3d3216b9a67985fd0d7d388751a53e0/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=e0dc3601d3d3216b9a67985fd0d7d388751a53e0", "patch": "@@ -816,7 +816,11 @@ static const struct arm_fpu_desc all_fpus[] =\n   {\"maverick\",\t\tARM_FP_MODEL_MAVERICK, 0, 0, false, false},\n   {\"vfp\",\t\tARM_FP_MODEL_VFP, 2, VFP_REG_D16, false, false},\n   {\"vfpv3\",\t\tARM_FP_MODEL_VFP, 3, VFP_REG_D32, false, false},\n+  {\"vfpv3-fp16\",\tARM_FP_MODEL_VFP, 3, VFP_REG_D32, false, true},\n   {\"vfpv3-d16\",\t\tARM_FP_MODEL_VFP, 3, VFP_REG_D16, false, false},\n+  {\"vfpv3-d16-fp16\",\tARM_FP_MODEL_VFP, 3, VFP_REG_D16, false, true},\n+  {\"vfpv3xd\",\t\tARM_FP_MODEL_VFP, 3, VFP_REG_SINGLE, false, false},\n+  {\"vfpv3xd-fp16\",\tARM_FP_MODEL_VFP, 3, VFP_REG_SINGLE, false, true},\n   {\"neon\",\t\tARM_FP_MODEL_VFP, 3, VFP_REG_D32, true , false},\n   {\"neon-fp16\",\t\tARM_FP_MODEL_VFP, 3, VFP_REG_D32, true , true },\n   /* Compatibility aliases.  */\n@@ -3817,38 +3821,57 @@ aapcs_vfp_sub_candidate (const_tree type, enum machine_mode *modep)\n   return -1;\n }\n \n+/* Return true if PCS_VARIANT should use VFP registers.  */\n static bool\n-aapcs_vfp_is_call_or_return_candidate (enum machine_mode mode, const_tree type,\n-\t\t\t\t       enum machine_mode *base_mode,\n-\t\t\t\t       int *count)\n+use_vfp_abi (enum arm_pcs pcs_variant, bool is_double)\n {\n+  if (pcs_variant == ARM_PCS_AAPCS_VFP)\n+    return true;\n+\n+  if (pcs_variant != ARM_PCS_AAPCS_LOCAL)\n+    return false;\n+\n+  return (TARGET_32BIT && TARGET_VFP && TARGET_HARD_FLOAT &&\n+\t  (TARGET_VFP_DOUBLE || !is_double));\n+}\n+\n+static bool\n+aapcs_vfp_is_call_or_return_candidate (enum arm_pcs pcs_variant,\n+\t\t\t\t       enum machine_mode mode, const_tree type,\n+\t\t\t\t       int *base_mode, int *count)\n+{\n+  enum machine_mode new_mode = VOIDmode;\n+\n   if (GET_MODE_CLASS (mode) == MODE_FLOAT\n       || GET_MODE_CLASS (mode) == MODE_VECTOR_INT\n       || GET_MODE_CLASS (mode) == MODE_VECTOR_FLOAT)\n     {\n       *count = 1;\n-      *base_mode = mode;\n-      return true;\n+      new_mode = mode;\n     }\n   else if (GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT)\n     {\n       *count = 2;\n-      *base_mode = (mode == DCmode ? DFmode : SFmode);\n-      return true;\n+      new_mode = (mode == DCmode ? DFmode : SFmode);\n     }\n   else if (type && (mode == BLKmode || TREE_CODE (type) == VECTOR_TYPE))\n     {\n-      enum machine_mode aggregate_mode = VOIDmode;\n-      int ag_count = aapcs_vfp_sub_candidate (type, &aggregate_mode);\n+      int ag_count = aapcs_vfp_sub_candidate (type, &new_mode);\n \n       if (ag_count > 0 && ag_count <= 4)\n-\t{\n-\t  *count = ag_count;\n-\t  *base_mode = aggregate_mode;\n-\t  return true;\n-\t}\n+\t*count = ag_count;\n+      else\n+\treturn false;\n     }\n-  return false;\n+  else\n+    return false;\n+\n+\n+  if (!use_vfp_abi (pcs_variant, ARM_NUM_REGS (new_mode) > 1))\n+    return false;\n+\n+  *base_mode = new_mode;\n+  return true;\n }\n \n static bool\n@@ -3858,22 +3881,20 @@ aapcs_vfp_is_return_candidate (enum arm_pcs pcs_variant,\n   int count ATTRIBUTE_UNUSED;\n   enum machine_mode ag_mode ATTRIBUTE_UNUSED;\n \n-  if (!(pcs_variant == ARM_PCS_AAPCS_VFP\n-\t|| (pcs_variant == ARM_PCS_AAPCS_LOCAL\n-\t    && TARGET_32BIT && TARGET_VFP && TARGET_HARD_FLOAT)))\n+  if (!use_vfp_abi (pcs_variant, false))\n     return false;\n-  return aapcs_vfp_is_call_or_return_candidate (mode, type, &ag_mode, &count);\n+  return aapcs_vfp_is_call_or_return_candidate (pcs_variant, mode, type,\n+\t\t\t\t\t\t&ag_mode, &count);\n }\n \n static bool\n aapcs_vfp_is_call_candidate (CUMULATIVE_ARGS *pcum, enum machine_mode mode, \n \t\t\t     const_tree type)\n {\n-  if (!(pcum->pcs_variant == ARM_PCS_AAPCS_VFP\n-\t|| (pcum->pcs_variant == ARM_PCS_AAPCS_LOCAL\n-\t    && TARGET_32BIT && TARGET_VFP && TARGET_HARD_FLOAT)))\n+  if (!use_vfp_abi (pcum->pcs_variant, false))\n     return false;\n-  return aapcs_vfp_is_call_or_return_candidate (mode, type,\n+\n+  return aapcs_vfp_is_call_or_return_candidate (pcum->pcs_variant, mode, type,\n \t\t\t\t\t\t&pcum->aapcs_vfp_rmode,\n \t\t\t\t\t\t&pcum->aapcs_vfp_rcount);\n }\n@@ -3934,10 +3955,9 @@ aapcs_vfp_allocate_return_reg (enum arm_pcs pcs_variant ATTRIBUTE_UNUSED,\n \t\t\t       enum machine_mode mode,\n \t\t\t       const_tree type ATTRIBUTE_UNUSED)\n {\n-  if (!(pcs_variant == ARM_PCS_AAPCS_VFP\n-\t|| (pcs_variant == ARM_PCS_AAPCS_LOCAL\n-\t    && TARGET_32BIT && TARGET_VFP && TARGET_HARD_FLOAT)))\n+  if (!use_vfp_abi (pcs_variant, false))\n     return false;\n+\n   if (mode == BLKmode || (mode == TImode && !TARGET_NEON))\n     {\n       int count;\n@@ -3946,7 +3966,8 @@ aapcs_vfp_allocate_return_reg (enum arm_pcs pcs_variant ATTRIBUTE_UNUSED,\n       rtx par;\n       int shift;\n       \n-      aapcs_vfp_is_call_or_return_candidate (mode, type, &ag_mode, &count);\n+      aapcs_vfp_is_call_or_return_candidate (pcs_variant, mode, type,\n+\t\t\t\t\t     &ag_mode, &count);\n \n       if (!TARGET_NEON)\n \t{\n@@ -6316,7 +6337,7 @@ arm_rtx_costs_1 (rtx x, enum rtx_code outer, int* total, bool speed)\n     case UMOD:\n       if (TARGET_HARD_FLOAT && mode == SFmode)\n \t*total = COSTS_N_INSNS (2);\n-      else if (TARGET_HARD_FLOAT && mode == DFmode)\n+      else if (TARGET_HARD_FLOAT && mode == DFmode && !TARGET_VFP_SINGLE)\n \t*total = COSTS_N_INSNS (4);\n       else\n \t*total = COSTS_N_INSNS (20);\n@@ -6394,7 +6415,9 @@ arm_rtx_costs_1 (rtx x, enum rtx_code outer, int* total, bool speed)\n \n       if (GET_MODE_CLASS (mode) == MODE_FLOAT)\n \t{\n-\t  if (TARGET_HARD_FLOAT && (mode == SFmode || mode == DFmode))\n+\t  if (TARGET_HARD_FLOAT\n+\t      && (mode == SFmode\n+\t\t  || (mode == DFmode && !TARGET_VFP_SINGLE)))\n \t    {\n \t      *total = COSTS_N_INSNS (1);\n \t      if (GET_CODE (XEXP (x, 0)) == CONST_DOUBLE\n@@ -6489,7 +6512,9 @@ arm_rtx_costs_1 (rtx x, enum rtx_code outer, int* total, bool speed)\n \n       if (GET_MODE_CLASS (mode) == MODE_FLOAT)\n \t{\n-\t  if (TARGET_HARD_FLOAT && (mode == SFmode || mode == DFmode))\n+\t  if (TARGET_HARD_FLOAT\n+\t      && (mode == SFmode\n+\t\t  || (mode == DFmode && !TARGET_VFP_SINGLE)))\n \t    {\n \t      *total = COSTS_N_INSNS (1);\n \t      if (GET_CODE (XEXP (x, 1)) == CONST_DOUBLE\n@@ -6602,7 +6627,9 @@ arm_rtx_costs_1 (rtx x, enum rtx_code outer, int* total, bool speed)\n     case NEG:\n       if (GET_MODE_CLASS (mode) == MODE_FLOAT)\n \t{\n-\t  if (TARGET_HARD_FLOAT && (mode == SFmode || mode == DFmode))\n+\t  if (TARGET_HARD_FLOAT\n+\t      && (mode == SFmode\n+\t\t  || (mode == DFmode && !TARGET_VFP_SINGLE)))\n \t    {\n \t      *total = COSTS_N_INSNS (1);\n \t      return false;\n@@ -6751,7 +6778,9 @@ arm_rtx_costs_1 (rtx x, enum rtx_code outer, int* total, bool speed)\n     case ABS:\n       if (GET_MODE_CLASS (mode) == MODE_FLOAT)\n \t{\n-\t  if (TARGET_HARD_FLOAT && (mode == SFmode || mode == DFmode))\n+\t  if (TARGET_HARD_FLOAT\n+\t      && (mode == SFmode\n+\t\t  || (mode == DFmode && !TARGET_VFP_SINGLE)))\n \t    {\n \t      *total = COSTS_N_INSNS (1);\n \t      return false;\n@@ -6854,7 +6883,8 @@ arm_rtx_costs_1 (rtx x, enum rtx_code outer, int* total, bool speed)\n       return true;\n \n     case CONST_DOUBLE:\n-      if (TARGET_HARD_FLOAT && vfp3_const_double_rtx (x))\n+      if (TARGET_HARD_FLOAT && vfp3_const_double_rtx (x)\n+\t  && (mode == SFmode || !TARGET_VFP_SINGLE))\n \t*total = COSTS_N_INSNS (1);\n       else\n \t*total = COSTS_N_INSNS (4);\n@@ -6929,7 +6959,8 @@ arm_size_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n       return false;\n \n     case MINUS:\n-      if (TARGET_HARD_FLOAT && GET_MODE_CLASS (mode) == MODE_FLOAT)\n+      if (TARGET_HARD_FLOAT && GET_MODE_CLASS (mode) == MODE_FLOAT\n+\t  && (mode == SFmode || !TARGET_VFP_SINGLE))\n \t{\n \t  *total = COSTS_N_INSNS (1);\n \t  return false;\n@@ -6959,7 +6990,8 @@ arm_size_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n       return false;\n \n     case PLUS:\n-      if (TARGET_HARD_FLOAT && GET_MODE_CLASS (mode) == MODE_FLOAT)\n+      if (TARGET_HARD_FLOAT && GET_MODE_CLASS (mode) == MODE_FLOAT\n+\t  && (mode == SFmode || !TARGET_VFP_SINGLE))\n \t{\n \t  *total = COSTS_N_INSNS (1);\n \t  return false;\n@@ -6999,7 +7031,8 @@ arm_size_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n       return false;\n \n     case NEG:\n-      if (TARGET_HARD_FLOAT && GET_MODE_CLASS (mode) == MODE_FLOAT)\n+      if (TARGET_HARD_FLOAT && GET_MODE_CLASS (mode) == MODE_FLOAT\n+\t  && (mode == SFmode || !TARGET_VFP_SINGLE))\n \t{\n \t  *total = COSTS_N_INSNS (1);\n \t  return false;\n@@ -7023,7 +7056,8 @@ arm_size_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n       return false;\n \n     case ABS:\n-      if (TARGET_HARD_FLOAT && GET_MODE_CLASS (mode) == MODE_FLOAT)\n+      if (TARGET_HARD_FLOAT && GET_MODE_CLASS (mode) == MODE_FLOAT\n+\t  && (mode == SFmode || !TARGET_VFP_SINGLE))\n \t*total = COSTS_N_INSNS (1);\n       else\n \t*total = COSTS_N_INSNS (1 + ARM_NUM_REGS (mode));\n@@ -7245,7 +7279,9 @@ arm_fastmul_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \n       if (GET_MODE_CLASS (mode) == MODE_FLOAT)\n \t{\n-\t  if (TARGET_HARD_FLOAT && (mode == SFmode || mode == DFmode))\n+\t  if (TARGET_HARD_FLOAT\n+\t      && (mode == SFmode\n+\t\t  || (mode == DFmode && !TARGET_VFP_SINGLE)))\n \t    {\n \t      *total = COSTS_N_INSNS (1);\n \t      return false;\n@@ -7402,7 +7438,9 @@ arm_9e_rtx_costs (rtx x, enum rtx_code code, enum rtx_code outer_code,\n \n       if (GET_MODE_CLASS (mode) == MODE_FLOAT)\n \t{\n-\t  if (TARGET_HARD_FLOAT && (mode == SFmode || mode == DFmode))\n+\t  if (TARGET_HARD_FLOAT\n+\t      && (mode == SFmode\n+\t\t  || (mode == DFmode && !TARGET_VFP_SINGLE)))\n \t    {\n \t      *total = COSTS_N_INSNS (1);\n \t      return false;\n@@ -8341,6 +8379,8 @@ coproc_secondary_reload_class (enum machine_mode mode, rtx x, bool wb)\n {\n   if (mode == HFmode)\n     {\n+      if (!TARGET_NEON_FP16)\n+\treturn GENERAL_REGS;\n       if (s_register_operand (x, mode) || neon_vector_mem_operand (x, 2))\n \treturn NO_REGS;\n       return GENERAL_REGS;\n@@ -15055,6 +15095,30 @@ arm_print_operand (FILE *stream, rtx x, int code)\n \t}\n       return;\n \n+    /* Print the high single-precision register of a VFP double-precision\n+       register.  */\n+    case 'p':\n+      {\n+        int mode = GET_MODE (x);\n+        int regno;\n+\n+        if (GET_MODE_SIZE (mode) != 8 || GET_CODE (x) != REG)\n+          {\n+\t    output_operand_lossage (\"invalid operand for code '%c'\", code);\n+\t    return;\n+          }\n+\n+        regno = REGNO (x);\n+        if (!VFP_REGNO_OK_FOR_DOUBLE (regno))\n+          {\n+\t    output_operand_lossage (\"invalid operand for code '%c'\", code);\n+\t    return;\n+          }\n+\n+\tfprintf (stream, \"s%d\", regno - FIRST_VFP_REGNUM + 1);\n+      }\n+      return;\n+\n     /* Print a VFP/Neon double precision or quad precision register name.  */\n     case 'P':\n     case 'q':\n@@ -15973,10 +16037,9 @@ arm_hard_regno_mode_ok (unsigned int regno, enum machine_mode mode)\n \treturn VFP_REGNO_OK_FOR_DOUBLE (regno);\n \n       /* VFP registers can hold HFmode values, but there is no point in\n-\t putting them there unless we have the NEON extensions for\n-\t loading/storing them, too.  */\n+\t putting them there unless we have hardware conversion insns. */\n       if (mode == HFmode)\n-\treturn TARGET_NEON_FP16 && VFP_REGNO_OK_FOR_SINGLE (regno);\n+\treturn TARGET_FP16 && VFP_REGNO_OK_FOR_SINGLE (regno);\n \n       if (TARGET_NEON)\n         return (VALID_NEON_DREG_MODE (mode) && VFP_REGNO_OK_FOR_DOUBLE (regno))"}, {"sha": "65d6708b04b420370b6284f19af47561bb81b4b2", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0dc3601d3d3216b9a67985fd0d7d388751a53e0/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0dc3601d3d3216b9a67985fd0d7d388751a53e0/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=e0dc3601d3d3216b9a67985fd0d7d388751a53e0", "patch": "@@ -230,10 +230,19 @@ extern void (*arm_lang_output_object_attributes_hook)(void);\n /* FPU supports VFPv3 instructions.  */\n #define TARGET_VFP3 (TARGET_VFP && arm_fpu_desc->rev >= 3)\n \n-/* FPU supports NEON/VFP half-precision floating-point.  */\n+/* FPU only supports VFP single-precision instructions.  */\n+#define TARGET_VFP_SINGLE (TARGET_VFP && arm_fpu_desc->regs == VFP_REG_SINGLE)\n+\n+/* FPU supports VFP double-precision instructions.  */\n+#define TARGET_VFP_DOUBLE (TARGET_VFP && arm_fpu_desc->regs != VFP_REG_SINGLE)\n+\n+/* FPU supports half-precision floating-point with NEON element load/store.  */\n #define TARGET_NEON_FP16 \\\n   (TARGET_VFP && arm_fpu_desc->neon && arm_fpu_desc->fp16)\n \n+/* FPU supports VFP half-precision floating-point.  */\n+#define TARGET_FP16 (TARGET_VFP && arm_fpu_desc->fp16)\n+\n /* FPU supports Neon instructions.  The setting of this macro gets\n    revealed via __ARM_NEON__ so we add extra guards upon TARGET_32BIT\n    and TARGET_HARD_FLOAT to ensure that NEON instructions are"}, {"sha": "691bd5568d7d8e3a556838919f9601402219a600", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0dc3601d3d3216b9a67985fd0d7d388751a53e0/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0dc3601d3d3216b9a67985fd0d7d388751a53e0/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=e0dc3601d3d3216b9a67985fd0d7d388751a53e0", "patch": "@@ -958,7 +958,7 @@\n   [(set (match_operand:DF          0 \"s_register_operand\" \"\")\n \t(plus:DF (match_operand:DF 1 \"s_register_operand\" \"\")\n \t\t (match_operand:DF 2 \"arm_float_add_operand\" \"\")))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT && !TARGET_VFP_SINGLE\"\n   \"\n   if (TARGET_MAVERICK\n       && !cirrus_fp_register (operands[2], DFmode))\n@@ -1196,7 +1196,7 @@\n   [(set (match_operand:DF           0 \"s_register_operand\" \"\")\n \t(minus:DF (match_operand:DF 1 \"arm_float_rhs_operand\" \"\")\n \t\t  (match_operand:DF 2 \"arm_float_rhs_operand\" \"\")))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT && !TARGET_VFP_SINGLE\"\n   \"\n   if (TARGET_MAVERICK)\n     {\n@@ -1733,7 +1733,7 @@\n   [(set (match_operand:DF          0 \"s_register_operand\" \"\")\n \t(mult:DF (match_operand:DF 1 \"s_register_operand\" \"\")\n \t\t (match_operand:DF 2 \"arm_float_rhs_operand\" \"\")))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT && !TARGET_VFP_SINGLE\"\n   \"\n   if (TARGET_MAVERICK\n       && !cirrus_fp_register (operands[2], DFmode))\n@@ -1753,7 +1753,7 @@\n   [(set (match_operand:DF 0 \"s_register_operand\" \"\")\n \t(div:DF (match_operand:DF 1 \"arm_float_rhs_operand\" \"\")\n \t\t(match_operand:DF 2 \"arm_float_rhs_operand\" \"\")))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP)\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP_DOUBLE)\"\n   \"\")\n \f\n ;; Modulo insns\n@@ -3605,7 +3605,7 @@\n (define_expand \"negdf2\"\n   [(set (match_operand:DF         0 \"s_register_operand\" \"\")\n \t(neg:DF (match_operand:DF 1 \"s_register_operand\" \"\")))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP)\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP_DOUBLE)\"\n   \"\")\n \n ;; abssi2 doesn't really clobber the condition codes if a different register\n@@ -3691,7 +3691,7 @@\n (define_expand \"absdf2\"\n   [(set (match_operand:DF         0 \"s_register_operand\" \"\")\n \t(abs:DF (match_operand:DF 1 \"s_register_operand\" \"\")))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT && !TARGET_VFP_SINGLE\"\n   \"\")\n \n (define_expand \"sqrtsf2\"\n@@ -3703,7 +3703,7 @@\n (define_expand \"sqrtdf2\"\n   [(set (match_operand:DF 0 \"s_register_operand\" \"\")\n \t(sqrt:DF (match_operand:DF 1 \"s_register_operand\" \"\")))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP)\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP_DOUBLE)\"\n   \"\")\n \n (define_insn_and_split \"one_cmpldi2\"\n@@ -3814,7 +3814,7 @@\n (define_expand \"floatsidf2\"\n   [(set (match_operand:DF           0 \"s_register_operand\" \"\")\n \t(float:DF (match_operand:SI 1 \"s_register_operand\" \"\")))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT && !TARGET_VFP_SINGLE\"\n   \"\n   if (TARGET_MAVERICK)\n     {\n@@ -3866,7 +3866,7 @@\n (define_expand \"fix_truncdfsi2\"\n   [(set (match_operand:SI         0 \"s_register_operand\" \"\")\n \t(fix:SI (fix:DF (match_operand:DF 1 \"s_register_operand\"  \"\"))))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT && !TARGET_VFP_SINGLE\"\n   \"\n   if (TARGET_MAVERICK)\n     {\n@@ -3883,7 +3883,7 @@\n   [(set (match_operand:SF  0 \"s_register_operand\" \"\")\n \t(float_truncate:SF\n  \t (match_operand:DF 1 \"s_register_operand\" \"\")))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT && !TARGET_VFP_SINGLE\"\n   \"\"\n )\n \n@@ -4784,7 +4784,7 @@\n (define_expand \"extendsfdf2\"\n   [(set (match_operand:DF                  0 \"s_register_operand\" \"\")\n \t(float_extend:DF (match_operand:SF 1 \"s_register_operand\"  \"\")))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT && !TARGET_VFP_SINGLE\"\n   \"\"\n )\n \n@@ -5971,7 +5971,7 @@\n (define_insn \"*arm32_movhf\"\n   [(set (match_operand:HF 0 \"nonimmediate_operand\" \"=r,m,r,r\")\n \t(match_operand:HF 1 \"general_operand\"\t   \" m,r,r,F\"))]\n-  \"TARGET_32BIT && !(TARGET_HARD_FLOAT && TARGET_NEON_FP16)\n+  \"TARGET_32BIT && !(TARGET_HARD_FLOAT && TARGET_FP16)\n    && (\t  s_register_operand (operands[0], HFmode)\n        || s_register_operand (operands[1], HFmode))\"\n   \"*\n@@ -6682,7 +6682,7 @@\n \t        (match_operand:DF 2 \"arm_float_compare_operand\" \"\")])\n \t      (label_ref (match_operand 3 \"\" \"\"))\n \t      (pc)))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT && !TARGET_VFP_SINGLE\"\n   \"emit_jump_insn (gen_cbranch_cc (operands[0], operands[1], operands[2],\n \t\t\t\t   operands[3])); DONE;\"\n )\n@@ -8296,7 +8296,7 @@\n \t(if_then_else:DF (match_operand 1 \"arm_comparison_operator\" \"\")\n \t\t\t (match_operand:DF 2 \"s_register_operand\" \"\")\n \t\t\t (match_operand:DF 3 \"arm_float_add_operand\" \"\")))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP)\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP_DOUBLE)\"\n   \"\n   {\n     enum rtx_code code = GET_CODE (operands[1]);"}, {"sha": "c40d695f0d8b31dc9cbcf4b4a7dc44a8d276cff3", "filename": "gcc/config/arm/constraints.md", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0dc3601d3d3216b9a67985fd0d7d388751a53e0/gcc%2Fconfig%2Farm%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0dc3601d3d3216b9a67985fd0d7d388751a53e0/gcc%2Fconfig%2Farm%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fconstraints.md?ref=e0dc3601d3d3216b9a67985fd0d7d388751a53e0", "patch": "@@ -29,7 +29,7 @@\n ;; in Thumb-1 state: I, J, K, L, M, N, O\n \n ;; The following multi-letter normal constraints have been used:\n-;; in ARM/Thumb-2 state: Da, Db, Dc, Dn, Dl, DL, Dv\n+;; in ARM/Thumb-2 state: Da, Db, Dc, Dn, Dl, DL, Dv, Dy\n ;; in Thumb-1 state: Pa, Pb\n \n ;; The following memory constraints have been used:\n@@ -207,10 +207,17 @@\n (define_constraint \"Dv\"\n  \"@internal\n   In ARM/Thumb-2 state a const_double which can be used with a VFP fconsts\n-  or fconstd instruction.\"\n+  instruction.\"\n  (and (match_code \"const_double\")\n       (match_test \"TARGET_32BIT && vfp3_const_double_rtx (op)\")))\n \n+(define_constraint \"Dy\"\n+ \"@internal\n+  In ARM/Thumb-2 state a const_double which can be used with a VFP fconstd\n+  instruction.\"\n+ (and (match_code \"const_double\")\n+      (match_test \"TARGET_32BIT && TARGET_VFP_DOUBLE && vfp3_const_double_rtx (op)\")))\n+\n (define_memory_constraint \"Ut\"\n  \"@internal\n   In ARM/Thumb-2 state an address valid for loading/storing opaque structure"}, {"sha": "57c2192d1e983a6002607324259b3803d0409a00", "filename": "gcc/config/arm/vfp.md", "status": "modified", "additions": 132, "deletions": 40, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0dc3601d3d3216b9a67985fd0d7d388751a53e0/gcc%2Fconfig%2Farm%2Fvfp.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0dc3601d3d3216b9a67985fd0d7d388751a53e0/gcc%2Fconfig%2Farm%2Fvfp.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fvfp.md?ref=e0dc3601d3d3216b9a67985fd0d7d388751a53e0", "patch": "@@ -145,15 +145,25 @@\n     case 4:\n       return \\\"fmrrd%?\\\\t%Q0, %R0, %P1\\\\t%@ int\\\";\n     case 5:\n-      return \\\"fcpyd%?\\\\t%P0, %P1\\\\t%@ int\\\";\n+      if (TARGET_VFP_SINGLE)\n+\treturn \\\"fcpys%?\\\\t%0, %1\\\\t%@ int\\;fcpys%?\\\\t%p0, %p1\\\\t%@ int\\\";\n+      else\n+\treturn \\\"fcpyd%?\\\\t%P0, %P1\\\\t%@ int\\\";\n     case 6: case 7:\n       return output_move_vfp (operands);\n     default:\n       gcc_unreachable ();\n     }\n   \"\n   [(set_attr \"type\" \"*,load2,store2,r_2_f,f_2_r,ffarithd,f_loadd,f_stored\")\n-   (set_attr \"length\" \"8,8,8,4,4,4,4,4\")\n+   (set (attr \"length\") (cond [(eq_attr \"alternative\" \"0,1,2\") (const_int 8)\n+\t\t\t       (eq_attr \"alternative\" \"5\")\n+\t\t\t\t(if_then_else\n+\t\t\t\t (eq (symbol_ref \"TARGET_VFP_SINGLE\")\n+\t\t\t\t     (const_int 1))\n+\t\t\t\t (const_int 8)\n+\t\t\t\t (const_int 4))]\n+\t\t\t      (const_int 4)))\n    (set_attr \"predicable\"    \"yes\")\n    (set_attr \"pool_range\"     \"*,1020,*,*,*,*,1020,*\")\n    (set_attr \"neg_pool_range\" \"*,1008,*,*,*,*,1008,*\")]\n@@ -173,21 +183,31 @@\n     case 4:\n       return \\\"fmrrd%?\\\\t%Q0, %R0, %P1\\\\t%@ int\\\";\n     case 5:\n-      return \\\"fcpyd%?\\\\t%P0, %P1\\\\t%@ int\\\";\n+      if (TARGET_VFP_SINGLE)\n+\treturn \\\"fcpys%?\\\\t%0, %1\\\\t%@ int\\;fcpys%?\\\\t%p0, %p1\\\\t%@ int\\\";\n+      else\n+\treturn \\\"fcpyd%?\\\\t%P0, %P1\\\\t%@ int\\\";\n     case 6: case 7:\n       return output_move_vfp (operands);\n     default:\n       abort ();\n     }\n   \"\n   [(set_attr \"type\" \"*,load2,store2,r_2_f,f_2_r,ffarithd,f_load,f_store\")\n-   (set_attr \"length\" \"8,8,8,4,4,4,4,4\")\n+   (set (attr \"length\") (cond [(eq_attr \"alternative\" \"0,1,2\") (const_int 8)\n+\t\t\t       (eq_attr \"alternative\" \"5\")\n+\t\t\t\t(if_then_else\n+\t\t\t\t (eq (symbol_ref \"TARGET_VFP_SINGLE\")\n+\t\t\t\t     (const_int 1))\n+\t\t\t\t (const_int 8)\n+\t\t\t\t (const_int 4))]\n+\t\t\t      (const_int 4)))\n    (set_attr \"pool_range\"     \"*,4096,*,*,*,*,1020,*\")\n    (set_attr \"neg_pool_range\" \"*,   0,*,*,*,*,1008,*\")]\n )\n \n ;; HFmode moves\n-(define_insn \"*movhf_vfp\"\n+(define_insn \"*movhf_vfp_neon\"\n   [(set (match_operand:HF 0 \"nonimmediate_operand\" \"= t,Um,r,m,t,r,t,r,r\")\n \t(match_operand:HF 1 \"general_operand\"\t   \" Um, t,m,r,t,r,r,t,F\"))]\n   \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_NEON_FP16\n@@ -241,6 +261,56 @@\n    (set_attr \"length\" \"4,4,4,4,4,4,4,4,8\")]\n )\n \n+;; FP16 without element load/store instructions.\n+(define_insn \"*movhf_vfp\"\n+  [(set (match_operand:HF 0 \"nonimmediate_operand\" \"=r,m,t,r,t,r,r\")\n+\t(match_operand:HF 1 \"general_operand\"\t   \" m,r,t,r,r,t,F\"))]\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_FP16 && !TARGET_NEON_FP16\n+   && (   s_register_operand (operands[0], HFmode)\n+       || s_register_operand (operands[1], HFmode))\"\n+  \"*\n+  switch (which_alternative)\n+    {\n+    case 0:     /* ARM register from memory */\n+      return \\\"ldrh\\\\t%0, %1\\\\t%@ __fp16\\\";\n+    case 1:     /* memory from ARM register */\n+      return \\\"strh\\\\t%1, %0\\\\t%@ __fp16\\\";\n+    case 2:\t/* S register from S register */\n+      return \\\"fcpys\\\\t%0, %1\\\";\n+    case 3:\t/* ARM register from ARM register */\n+      return \\\"mov\\\\t%0, %1\\\\t%@ __fp16\\\";\n+    case 4:\t/* S register from ARM register */\n+      return \\\"fmsr\\\\t%0, %1\\\";\n+    case 5:\t/* ARM register from S register */\n+      return \\\"fmrs\\\\t%0, %1\\\";\n+    case 6:\t/* ARM register from constant */\n+      {\n+        REAL_VALUE_TYPE r;\n+\tlong bits;\n+\trtx ops[4];\n+\n+        REAL_VALUE_FROM_CONST_DOUBLE (r, operands[1]);\n+\tbits = real_to_target (NULL, &r, HFmode);\n+\tops[0] = operands[0];\n+\tops[1] = GEN_INT (bits);\n+\tops[2] = GEN_INT (bits & 0xff00);\n+\tops[3] = GEN_INT (bits & 0x00ff);\n+\n+\tif (arm_arch_thumb2)\n+\t  output_asm_insn (\\\"movw\\\\t%0, %1\\\", ops);\n+\telse\n+\t  output_asm_insn (\\\"mov\\\\t%0, %2\\;orr\\\\t%0, %0, %3\\\", ops);\n+\treturn \\\"\\\";\n+       }\n+    default:\n+      gcc_unreachable ();\n+    }\n+  \"\n+  [(set_attr \"conds\" \"unconditional\")\n+   (set_attr \"type\" \"load1,store1,fcpys,*,r_2_f,f_2_r,*\")\n+   (set_attr \"length\" \"4,4,4,4,4,4,8\")]\n+)\n+\n \n ;; SFmode moves\n ;; Disparage the w<->r cases because reloading an invalid address is\n@@ -323,7 +393,7 @@\n \n (define_insn \"*movdf_vfp\"\n   [(set (match_operand:DF 0 \"nonimmediate_soft_df_operand\" \"=w,?r,w ,r, m,w  ,Uv,w,r\")\n-\t(match_operand:DF 1 \"soft_df_operand\"\t\t   \" ?r,w,Dv,mF,r,UvF,w, w,r\"))]\n+\t(match_operand:DF 1 \"soft_df_operand\"\t\t   \" ?r,w,Dy,mF,r,UvF,w, w,r\"))]\n   \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\n    && (   register_operand (operands[0], DFmode)\n        || register_operand (operands[1], DFmode))\"\n@@ -336,13 +406,17 @@\n       case 1:\n \treturn \\\"fmrrd%?\\\\t%Q0, %R0, %P1\\\";\n       case 2:\n+\tgcc_assert (TARGET_VFP_DOUBLE);\n         return \\\"fconstd%?\\\\t%P0, #%G1\\\";\n       case 3: case 4:\n \treturn output_move_double (operands);\n       case 5: case 6:\n \treturn output_move_vfp (operands);\n       case 7:\n-\treturn \\\"fcpyd%?\\\\t%P0, %P1\\\";\n+\tif (TARGET_VFP_SINGLE)\n+\t  return \\\"fcpys%?\\\\t%0, %1\\;fcpys%?\\\\t%p0, %p1\\\";\n+\telse\n+\t  return \\\"fcpyd%?\\\\t%P0, %P1\\\";\n       case 8:\n         return \\\"#\\\";\n       default:\n@@ -352,15 +426,22 @@\n   \"\n   [(set_attr \"type\"\n      \"r_2_f,f_2_r,fconstd,f_loadd,f_stored,load2,store2,ffarithd,*\")\n-   (set_attr \"length\" \"4,4,4,8,8,4,4,4,8\")\n+   (set (attr \"length\") (cond [(eq_attr \"alternative\" \"3,4,8\") (const_int 8)\n+\t\t\t       (eq_attr \"alternative\" \"7\")\n+\t\t\t\t(if_then_else\n+\t\t\t\t (eq (symbol_ref \"TARGET_VFP_SINGLE\")\n+\t\t\t\t     (const_int 1))\n+\t\t\t\t (const_int 8)\n+\t\t\t\t (const_int 4))]\n+\t\t\t      (const_int 4)))\n    (set_attr \"predicable\" \"yes\")\n    (set_attr \"pool_range\" \"*,*,*,1020,*,1020,*,*,*\")\n    (set_attr \"neg_pool_range\" \"*,*,*,1008,*,1008,*,*,*\")]\n )\n \n (define_insn \"*thumb2_movdf_vfp\"\n   [(set (match_operand:DF 0 \"nonimmediate_soft_df_operand\" \"=w,?r,w ,r, m,w  ,Uv,w,r\")\n-\t(match_operand:DF 1 \"soft_df_operand\"\t\t   \" ?r,w,Dv,mF,r,UvF,w, w,r\"))]\n+\t(match_operand:DF 1 \"soft_df_operand\"\t\t   \" ?r,w,Dy,mF,r,UvF,w, w,r\"))]\n   \"TARGET_THUMB2 && TARGET_HARD_FLOAT && TARGET_VFP\"\n   \"*\n   {\n@@ -371,21 +452,32 @@\n       case 1:\n \treturn \\\"fmrrd%?\\\\t%Q0, %R0, %P1\\\";\n       case 2:\n+\tgcc_assert (TARGET_VFP_DOUBLE);\n \treturn \\\"fconstd%?\\\\t%P0, #%G1\\\";\n       case 3: case 4: case 8:\n \treturn output_move_double (operands);\n       case 5: case 6:\n \treturn output_move_vfp (operands);\n       case 7:\n-\treturn \\\"fcpyd%?\\\\t%P0, %P1\\\";\n+\tif (TARGET_VFP_SINGLE)\n+\t  return \\\"fcpys%?\\\\t%0, %1\\;fcpys%?\\\\t%p0, %p1\\\";\n+\telse\n+\t  return \\\"fcpyd%?\\\\t%P0, %P1\\\";\n       default:\n \tabort ();\n       }\n     }\n   \"\n   [(set_attr \"type\"\n      \"r_2_f,f_2_r,fconstd,load2,store2,f_load,f_store,ffarithd,*\")\n-   (set_attr \"length\" \"4,4,4,8,8,4,4,4,8\")\n+   (set (attr \"length\") (cond [(eq_attr \"alternative\" \"3,4,8\") (const_int 8)\n+\t\t\t       (eq_attr \"alternative\" \"7\")\n+\t\t\t\t(if_then_else\n+\t\t\t\t (eq (symbol_ref \"TARGET_VFP_SINGLE\")\n+\t\t\t\t     (const_int 1))\n+\t\t\t\t (const_int 8)\n+\t\t\t\t (const_int 4))]\n+\t\t\t      (const_int 4)))\n    (set_attr \"pool_range\" \"*,*,*,4096,*,1020,*,*,*\")\n    (set_attr \"neg_pool_range\" \"*,*,*,0,*,1008,*,*,*\")]\n )\n@@ -446,7 +538,7 @@\n \t    [(match_operand 4 \"cc_register\" \"\") (const_int 0)])\n \t  (match_operand:DF 1 \"s_register_operand\" \"0,w,w,0,?r,?r,0,w,w\")\n \t  (match_operand:DF 2 \"s_register_operand\" \"w,0,w,?r,0,?r,w,0,w\")))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE\"\n   \"@\n    fcpyd%D3\\\\t%P0, %P2\n    fcpyd%d3\\\\t%P0, %P1\n@@ -469,7 +561,7 @@\n \t    [(match_operand 4 \"cc_register\" \"\") (const_int 0)])\n \t  (match_operand:DF 1 \"s_register_operand\" \"0,w,w,0,?r,?r,0,w,w\")\n \t  (match_operand:DF 2 \"s_register_operand\" \"w,0,w,?r,0,?r,w,0,w\")))]\n-  \"TARGET_THUMB2 && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"TARGET_THUMB2 && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE\"\n   \"@\n    it\\\\t%D3\\;fcpyd%D3\\\\t%P0, %P2\n    it\\\\t%d3\\;fcpyd%d3\\\\t%P0, %P1\n@@ -500,7 +592,7 @@\n (define_insn \"*absdf2_vfp\"\n   [(set (match_operand:DF\t  0 \"s_register_operand\" \"=w\")\n \t(abs:DF (match_operand:DF 1 \"s_register_operand\" \"w\")))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE\"\n   \"fabsd%?\\\\t%P0, %P1\"\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"type\" \"ffarithd\")]\n@@ -520,12 +612,12 @@\n (define_insn_and_split \"*negdf2_vfp\"\n   [(set (match_operand:DF\t  0 \"s_register_operand\" \"=w,?r,?r\")\n \t(neg:DF (match_operand:DF 1 \"s_register_operand\" \"w,0,r\")))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE\"\n   \"@\n    fnegd%?\\\\t%P0, %P1\n    #\n    #\"\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP && reload_completed\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE && reload_completed\n    && arm_general_register_operand (operands[0], DFmode)\"\n   [(set (match_dup 0) (match_dup 1))]\n   \"\n@@ -580,7 +672,7 @@\n   [(set (match_operand:DF\t   0 \"s_register_operand\" \"=w\")\n \t(plus:DF (match_operand:DF 1 \"s_register_operand\" \"w\")\n \t\t (match_operand:DF 2 \"s_register_operand\" \"w\")))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE\"\n   \"faddd%?\\\\t%P0, %P1, %P2\"\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"type\" \"faddd\")]\n@@ -601,7 +693,7 @@\n   [(set (match_operand:DF\t    0 \"s_register_operand\" \"=w\")\n \t(minus:DF (match_operand:DF 1 \"s_register_operand\" \"w\")\n \t\t  (match_operand:DF 2 \"s_register_operand\" \"w\")))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE\"\n   \"fsubd%?\\\\t%P0, %P1, %P2\"\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"type\" \"faddd\")]\n@@ -624,7 +716,7 @@\n   [(set (match_operand:DF\t  0 \"s_register_operand\" \"+w\")\n \t(div:DF (match_operand:DF 1 \"s_register_operand\" \"w\")\n \t\t(match_operand:DF 2 \"s_register_operand\" \"w\")))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE\"\n   \"fdivd%?\\\\t%P0, %P1, %P2\"\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"type\" \"fdivd\")]\n@@ -647,7 +739,7 @@\n   [(set (match_operand:DF\t   0 \"s_register_operand\" \"+w\")\n \t(mult:DF (match_operand:DF 1 \"s_register_operand\" \"w\")\n \t\t (match_operand:DF 2 \"s_register_operand\" \"w\")))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE\"\n   \"fmuld%?\\\\t%P0, %P1, %P2\"\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"type\" \"fmuld\")]\n@@ -668,7 +760,7 @@\n   [(set (match_operand:DF\t\t   0 \"s_register_operand\" \"+w\")\n \t(mult:DF (neg:DF (match_operand:DF 1 \"s_register_operand\" \"w\"))\n \t\t (match_operand:DF\t   2 \"s_register_operand\" \"w\")))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE\"\n   \"fnmuld%?\\\\t%P0, %P1, %P2\"\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"type\" \"fmuld\")]\n@@ -694,7 +786,7 @@\n \t(plus:DF (mult:DF (match_operand:DF 2 \"s_register_operand\" \"w\")\n \t\t\t  (match_operand:DF 3 \"s_register_operand\" \"w\"))\n \t\t (match_operand:DF\t    1 \"s_register_operand\" \"0\")))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE\"\n   \"fmacd%?\\\\t%P0, %P2, %P3\"\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"type\" \"fmacd\")]\n@@ -717,7 +809,7 @@\n \t(minus:DF (mult:DF (match_operand:DF 2 \"s_register_operand\" \"w\")\n \t\t\t   (match_operand:DF 3 \"s_register_operand\" \"w\"))\n \t\t  (match_operand:DF\t     1 \"s_register_operand\" \"0\")))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE\"\n   \"fmscd%?\\\\t%P0, %P2, %P3\"\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"type\" \"fmacd\")]\n@@ -740,7 +832,7 @@\n \t(minus:DF (match_operand:DF\t     1 \"s_register_operand\" \"0\")\n \t\t  (mult:DF (match_operand:DF 2 \"s_register_operand\" \"w\")\n \t\t\t   (match_operand:DF 3 \"s_register_operand\" \"w\"))))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE\"\n   \"fnmacd%?\\\\t%P0, %P2, %P3\"\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"type\" \"fmacd\")]\n@@ -766,7 +858,7 @@\n \t\t    (neg:DF (match_operand:DF 2 \"s_register_operand\" \"w\"))\n \t\t    (match_operand:DF\t      3 \"s_register_operand\" \"w\"))\n \t\t  (match_operand:DF\t      1 \"s_register_operand\" \"0\")))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE\"\n   \"fnmscd%?\\\\t%P0, %P2, %P3\"\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"type\" \"fmacd\")]\n@@ -778,7 +870,7 @@\n (define_insn \"*extendsfdf2_vfp\"\n   [(set (match_operand:DF\t\t   0 \"s_register_operand\" \"=w\")\n \t(float_extend:DF (match_operand:SF 1 \"s_register_operand\" \"t\")))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE\"\n   \"fcvtds%?\\\\t%P0, %1\"\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"type\" \"f_cvt\")]\n@@ -787,7 +879,7 @@\n (define_insn \"*truncdfsf2_vfp\"\n   [(set (match_operand:SF\t\t   0 \"s_register_operand\" \"=t\")\n \t(float_truncate:SF (match_operand:DF 1 \"s_register_operand\" \"w\")))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE\"\n   \"fcvtsd%?\\\\t%0, %P1\"\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"type\" \"f_cvt\")]\n@@ -796,7 +888,7 @@\n (define_insn \"extendhfsf2\"\n   [(set (match_operand:SF\t\t   0 \"s_register_operand\" \"=t\")\n \t(float_extend:SF (match_operand:HF 1 \"s_register_operand\" \"t\")))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_NEON_FP16\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_FP16\"\n   \"vcvtb%?.f32.f16\\\\t%0, %1\"\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"type\" \"f_cvt\")]\n@@ -805,7 +897,7 @@\n (define_insn \"truncsfhf2\"\n   [(set (match_operand:HF\t\t   0 \"s_register_operand\" \"=t\")\n \t(float_truncate:HF (match_operand:SF 1 \"s_register_operand\" \"t\")))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_NEON_FP16\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_FP16\"\n   \"vcvtb%?.f16.f32\\\\t%0, %1\"\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"type\" \"f_cvt\")]\n@@ -823,7 +915,7 @@\n (define_insn \"*truncsidf2_vfp\"\n   [(set (match_operand:SI\t\t  0 \"s_register_operand\" \"=t\")\n \t(fix:SI (fix:DF (match_operand:DF 1 \"s_register_operand\" \"w\"))))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE\"\n   \"ftosizd%?\\\\t%0, %P1\"\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"type\" \"f_cvt\")]\n@@ -842,7 +934,7 @@\n (define_insn \"fixuns_truncdfsi2\"\n   [(set (match_operand:SI\t\t  0 \"s_register_operand\" \"=t\")\n \t(unsigned_fix:SI (fix:DF (match_operand:DF 1 \"s_register_operand\" \"t\"))))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE\"\n   \"ftouizd%?\\\\t%0, %P1\"\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"type\" \"f_cvt\")]\n@@ -861,7 +953,7 @@\n (define_insn \"*floatsidf2_vfp\"\n   [(set (match_operand:DF\t    0 \"s_register_operand\" \"=w\")\n \t(float:DF (match_operand:SI 1 \"s_register_operand\" \"t\")))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE\"\n   \"fsitod%?\\\\t%P0, %1\"\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"type\" \"f_cvt\")]\n@@ -880,7 +972,7 @@\n (define_insn \"floatunssidf2\"\n   [(set (match_operand:DF\t    0 \"s_register_operand\" \"=w\")\n \t(unsigned_float:DF (match_operand:SI 1 \"s_register_operand\" \"t\")))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE\"\n   \"fuitod%?\\\\t%P0, %1\"\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"type\" \"f_cvt\")]\n@@ -901,7 +993,7 @@\n (define_insn \"*sqrtdf2_vfp\"\n   [(set (match_operand:DF\t   0 \"s_register_operand\" \"=w\")\n \t(sqrt:DF (match_operand:DF 1 \"s_register_operand\" \"w\")))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE\"\n   \"fsqrtd%?\\\\t%P0, %P1\"\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"type\" \"fdivd\")]\n@@ -953,9 +1045,9 @@\n   [(set (reg:CCFP CC_REGNUM)\n \t(compare:CCFP (match_operand:DF 0 \"s_register_operand\"  \"w\")\n \t\t      (match_operand:DF 1 \"vfp_compare_operand\" \"wG\")))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE\"\n   \"#\"\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE\"\n   [(set (reg:CCFP VFPCC_REGNUM)\n \t(compare:CCFP (match_dup 0)\n \t\t       (match_dup 1)))\n@@ -968,9 +1060,9 @@\n   [(set (reg:CCFPE CC_REGNUM)\n \t(compare:CCFPE (match_operand:DF 0 \"s_register_operand\"  \"w\")\n \t\t       (match_operand:DF 1 \"vfp_compare_operand\" \"wG\")))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE\"\n   \"#\"\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE\"\n   [(set (reg:CCFPE VFPCC_REGNUM)\n \t(compare:CCFPE (match_dup 0)\n \t\t       (match_dup 1)))\n@@ -1010,7 +1102,7 @@\n   [(set (reg:CCFP VFPCC_REGNUM)\n \t(compare:CCFP (match_operand:DF 0 \"s_register_operand\"  \"w,w\")\n \t\t      (match_operand:DF 1 \"vfp_compare_operand\" \"w,G\")))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE\"\n   \"@\n    fcmpd%?\\\\t%P0, %P1\n    fcmpzd%?\\\\t%P0\"\n@@ -1022,7 +1114,7 @@\n   [(set (reg:CCFPE VFPCC_REGNUM)\n \t(compare:CCFPE (match_operand:DF 0 \"s_register_operand\"  \"w,w\")\n \t\t       (match_operand:DF 1 \"vfp_compare_operand\" \"w,G\")))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE\"\n   \"@\n    fcmped%?\\\\t%P0, %P1\n    fcmpezd%?\\\\t%P0\""}, {"sha": "c9c759d57695ba84f8a40550d7f37b915ddc158a", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0dc3601d3d3216b9a67985fd0d7d388751a53e0/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0dc3601d3d3216b9a67985fd0d7d388751a53e0/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=e0dc3601d3d3216b9a67985fd0d7d388751a53e0", "patch": "@@ -960,8 +960,9 @@ direct conversion.\n ARM provides hardware support for conversions between \n @code{__fp16} and @code{float} values\n as an extension to VFP and NEON (Advanced SIMD).  GCC generates\n-code using the instructions provided by this extension if you compile\n-with the options @option{-mfpu=neon-fp16 -mfloat-abi=softfp},\n+code using these hardware instructions if you compile with\n+options to select an FPU that provides them; \n+for example, @option{-mfpu=neon-fp16 -mfloat-abi=softfp},\n in addition to the @option{-mfp16-format} option to select\n a half-precision format.  \n "}, {"sha": "3b49707fd1f5351492c73b48e38754cecd6f36fc", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0dc3601d3d3216b9a67985fd0d7d388751a53e0/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0dc3601d3d3216b9a67985fd0d7d388751a53e0/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=e0dc3601d3d3216b9a67985fd0d7d388751a53e0", "patch": "@@ -9788,10 +9788,12 @@ of the @option{-mcpu=} option.  Permissible names are: @samp{armv2},\n @opindex mfp\n This specifies what floating point hardware (or hardware emulation) is\n available on the target.  Permissible names are: @samp{fpa}, @samp{fpe2},\n-@samp{fpe3}, @samp{maverick}, @samp{vfp}, @samp{vfpv3}, @samp{vfpv3-d16},\n-@samp{neon}, and @samp{neon-fp16}.  @option{-mfp} and @option{-mfpe}\n-are synonyms for @option{-mfpu}=@samp{fpe}@var{number}, for compatibility\n-with older versions of GCC@.\n+@samp{fpe3}, @samp{maverick}, @samp{vfp}, @samp{vfpv3}, @samp{vfpv3-fp16},\n+@samp{vfpv3-d16}, @samp{vfpv3-d16-fp16}, @samp{vfpv3xd}, @samp{vfpv3xd-fp16},\n+@samp{neon}, and @samp{neon-fp16}.\n+@option{-mfp} and @option{-mfpe} are synonyms for\n+@option{-mfpu}=@samp{fpe}@var{number}, for compatibility with older versions\n+of GCC@.\n \n If @option{-msoft-float} is specified this specifies the format of\n floating point values."}]}