{"sha": "5c0caeb37ff72cfd9153e164e9fd9eec7d56e969", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWMwY2FlYjM3ZmY3MmNmZDkxNTNlMTY0ZTlmZDllZWM3ZDU2ZTk2OQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-03T21:43:02Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-03T21:43:02Z"}, "message": "Add support for MODE_VECTOR_BOOL\n\nThis patch adds a new mode class to represent vectors of booleans.\nGET_MODE_BITSIZE (m) / GET_MODE_NUNITS (m) determines the number\nof bits that are used to represent each boolean; this can be 1\nfor a fully-packed representation or greater than 1 for an unpacked\nrepresentation.  In the latter case, the value of bits other than\nthe lowest is not significant.\n\nThese are used by the SVE port to represent predicates.\n\n2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* mode-classes.def (MODE_VECTOR_BOOL): New mode class.\n\t* machmode.h (INTEGRAL_MODE_P, VECTOR_MODE_P): Return true\n\tfor MODE_VECTOR_BOOL.\n\t* machmode.def (VECTOR_BOOL_MODE): Document.\n\t* genmodes.c (VECTOR_BOOL_MODE): New macro.\n\t(make_vector_bool_mode): New function.\n\t(complete_mode, emit_mode_wider, emit_mode_adjustments): Handle\n\tMODE_VECTOR_BOOL.\n\t* lto-streamer-in.c (lto_input_mode_table): Likewise.\n\t* rtx-vector-builder.c (rtx_vector_builder::find_cached_value):\n\tLikewise.\n\t* stor-layout.c (int_mode_for_mode): Likewise.\n\t* tree.c (build_vector_type_for_mode): Likewise.\n\t* varasm.c (output_constant_pool_2): Likewise.\n\t* emit-rtl.c (init_emit_once): Make sure that CONST1_RTX (BImode) and\n\tCONSTM1_RTX (BImode) are the same thing.  Initialize const_tiny_rtx\n\tfor MODE_VECTOR_BOOL.\n\t* expr.c (expand_expr_real_1): Use VECTOR_MODE_P instead of a list\n\tof mode class checks.\n\t* tree-vect-generic.c (expand_vector_operation): Use VECTOR_MODE_P\n\tinstead of a list of mode class checks.\n\t(expand_vector_scalar_condition): Likewise.\n\t(type_for_widest_vector_mode): Handle BImode as an inner mode.\n\ngcc/c-family/\n\t* c-common.c (c_common_type_for_mode): Handle MODE_VECTOR_BOOL.\n\ngcc/fortran/\n\t* trans-types.c (gfc_type_for_mode): Handle MODE_VECTOR_BOOL.\n\ngcc/go/\n\t* go-lang.c (go_langhook_type_for_mode): Handle MODE_VECTOR_BOOL.\n\ngcc/lto/\n\t* lto-lang.c (lto_type_for_mode): Handle MODE_VECTOR_BOOL.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r256202", "tree": {"sha": "99f960801c55a722346016899054db7e08ba7b13", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/99f960801c55a722346016899054db7e08ba7b13"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5c0caeb37ff72cfd9153e164e9fd9eec7d56e969", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c0caeb37ff72cfd9153e164e9fd9eec7d56e969", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c0caeb37ff72cfd9153e164e9fd9eec7d56e969", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c0caeb37ff72cfd9153e164e9fd9eec7d56e969/comments", "author": null, "committer": null, "parents": [{"sha": "cf098191e47535b89373dccb9a2d3cc4a4ebaef7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf098191e47535b89373dccb9a2d3cc4a4ebaef7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf098191e47535b89373dccb9a2d3cc4a4ebaef7"}], "stats": {"total": 223, "additions": 195, "deletions": 28}, "files": [{"sha": "28b1d4ef280dacdbb6f3b8da22c478b770013daa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c0caeb37ff72cfd9153e164e9fd9eec7d56e969/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c0caeb37ff72cfd9153e164e9fd9eec7d56e969/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5c0caeb37ff72cfd9153e164e9fd9eec7d56e969", "patch": "@@ -1,3 +1,31 @@\n+2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* mode-classes.def (MODE_VECTOR_BOOL): New mode class.\n+\t* machmode.h (INTEGRAL_MODE_P, VECTOR_MODE_P): Return true\n+\tfor MODE_VECTOR_BOOL.\n+\t* machmode.def (VECTOR_BOOL_MODE): Document.\n+\t* genmodes.c (VECTOR_BOOL_MODE): New macro.\n+\t(make_vector_bool_mode): New function.\n+\t(complete_mode, emit_mode_wider, emit_mode_adjustments): Handle\n+\tMODE_VECTOR_BOOL.\n+\t* lto-streamer-in.c (lto_input_mode_table): Likewise.\n+\t* rtx-vector-builder.c (rtx_vector_builder::find_cached_value):\n+\tLikewise.\n+\t* stor-layout.c (int_mode_for_mode): Likewise.\n+\t* tree.c (build_vector_type_for_mode): Likewise.\n+\t* varasm.c (output_constant_pool_2): Likewise.\n+\t* emit-rtl.c (init_emit_once): Make sure that CONST1_RTX (BImode) and\n+\tCONSTM1_RTX (BImode) are the same thing.  Initialize const_tiny_rtx\n+\tfor MODE_VECTOR_BOOL.\n+\t* expr.c (expand_expr_real_1): Use VECTOR_MODE_P instead of a list\n+\tof mode class checks.\n+\t* tree-vect-generic.c (expand_vector_operation): Use VECTOR_MODE_P\n+\tinstead of a list of mode class checks.\n+\t(expand_vector_scalar_condition): Likewise.\n+\t(type_for_widest_vector_mode): Handle BImode as an inner mode.\n+\n 2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "e79d9858ac06c7ddc0fe4dd4ac97620dcb566069", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c0caeb37ff72cfd9153e164e9fd9eec7d56e969/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c0caeb37ff72cfd9153e164e9fd9eec7d56e969/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=5c0caeb37ff72cfd9153e164e9fd9eec7d56e969", "patch": "@@ -1,3 +1,9 @@\n+2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* c-common.c (c_common_type_for_mode): Handle MODE_VECTOR_BOOL.\n+\n 2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "87bd326b5e41fec20615a2891648c71d00a9c648", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c0caeb37ff72cfd9153e164e9fd9eec7d56e969/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c0caeb37ff72cfd9153e164e9fd9eec7d56e969/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=5c0caeb37ff72cfd9153e164e9fd9eec7d56e969", "patch": "@@ -2279,6 +2279,14 @@ c_common_type_for_mode (machine_mode mode, int unsignedp)\n       if (inner_type != NULL_TREE)\n \treturn build_complex_type (inner_type);\n     }\n+  else if (GET_MODE_CLASS (mode) == MODE_VECTOR_BOOL\n+\t   && valid_vector_subparts_p (GET_MODE_NUNITS (mode)))\n+    {\n+      unsigned int elem_bits = vector_element_size (GET_MODE_BITSIZE (mode),\n+\t\t\t\t\t\t    GET_MODE_NUNITS (mode));\n+      tree bool_type = build_nonstandard_boolean_type (elem_bits);\n+      return build_vector_type_for_mode (bool_type, mode);\n+    }\n   else if (VECTOR_MODE_P (mode)\n \t   && valid_vector_subparts_p (GET_MODE_NUNITS (mode)))\n     {"}, {"sha": "c6ce35889b170584cca5f59edb20a1367c9561ae", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c0caeb37ff72cfd9153e164e9fd9eec7d56e969/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c0caeb37ff72cfd9153e164e9fd9eec7d56e969/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=5c0caeb37ff72cfd9153e164e9fd9eec7d56e969", "patch": "@@ -6268,6 +6268,12 @@ init_emit_once (void)\n   FOR_EACH_MODE_IN_CLASS (mode, MODE_INT)\n     const_tiny_rtx[3][(int) mode] = constm1_rtx;\n \n+  /* For BImode, 1 and -1 are unsigned and signed interpretations\n+     of the same value.  */\n+  const_tiny_rtx[0][(int) BImode] = const0_rtx;\n+  const_tiny_rtx[1][(int) BImode] = const_true_rtx;\n+  const_tiny_rtx[3][(int) BImode] = const_true_rtx;\n+\n   for (mode = MIN_MODE_PARTIAL_INT;\n        mode <= MAX_MODE_PARTIAL_INT;\n        mode = (machine_mode)((int)(mode) + 1))\n@@ -6285,6 +6291,15 @@ init_emit_once (void)\n       const_tiny_rtx[0][(int) mode] = gen_rtx_CONCAT (mode, inner, inner);\n     }\n \n+  /* As for BImode, \"all 1\" and \"all -1\" are unsigned and signed\n+     interpretations of the same value.  */\n+  FOR_EACH_MODE_IN_CLASS (mode, MODE_VECTOR_BOOL)\n+    {\n+      const_tiny_rtx[0][(int) mode] = gen_const_vector (mode, 0);\n+      const_tiny_rtx[3][(int) mode] = gen_const_vector (mode, 3);\n+      const_tiny_rtx[1][(int) mode] = const_tiny_rtx[3][(int) mode];\n+    }\n+\n   FOR_EACH_MODE_IN_CLASS (mode, MODE_VECTOR_INT)\n     {\n       const_tiny_rtx[0][(int) mode] = gen_const_vector (mode, 0);\n@@ -6386,10 +6401,6 @@ init_emit_once (void)\n     if (GET_MODE_CLASS ((machine_mode) i) == MODE_CC)\n       const_tiny_rtx[0][i] = const0_rtx;\n \n-  const_tiny_rtx[0][(int) BImode] = const0_rtx;\n-  if (STORE_FLAG_VALUE == 1)\n-    const_tiny_rtx[1][(int) BImode] = const1_rtx;\n-\n   FOR_EACH_MODE_IN_CLASS (smode_iter, MODE_POINTER_BOUNDS)\n     {\n       scalar_mode smode = smode_iter.require ();"}, {"sha": "cd1e57d0eecd524f2e0a5bb8530e08478787b7e6", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c0caeb37ff72cfd9153e164e9fd9eec7d56e969/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c0caeb37ff72cfd9153e164e9fd9eec7d56e969/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=5c0caeb37ff72cfd9153e164e9fd9eec7d56e969", "patch": "@@ -10082,12 +10082,7 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n     case VECTOR_CST:\n       {\n \ttree tmp = NULL_TREE;\n-\tif (GET_MODE_CLASS (mode) == MODE_VECTOR_INT\n-\t    || GET_MODE_CLASS (mode) == MODE_VECTOR_FLOAT\n-\t    || GET_MODE_CLASS (mode) == MODE_VECTOR_FRACT\n-\t    || GET_MODE_CLASS (mode) == MODE_VECTOR_UFRACT\n-\t    || GET_MODE_CLASS (mode) == MODE_VECTOR_ACCUM\n-\t    || GET_MODE_CLASS (mode) == MODE_VECTOR_UACCUM)\n+\tif (VECTOR_MODE_P (mode))\n \t  return const_vector_from_tree (exp);\n \tscalar_int_mode int_mode;\n \tif (is_int_mode (mode, &int_mode))"}, {"sha": "480f36a02548954035adf964a38d38c86fe3ff53", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c0caeb37ff72cfd9153e164e9fd9eec7d56e969/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c0caeb37ff72cfd9153e164e9fd9eec7d56e969/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=5c0caeb37ff72cfd9153e164e9fd9eec7d56e969", "patch": "@@ -1,3 +1,9 @@\n+2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* trans-types.c (gfc_type_for_mode): Handle MODE_VECTOR_BOOL.\n+\n 2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "16d851e49daa4adf928b0690de3e5f36cebd9a0c", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c0caeb37ff72cfd9153e164e9fd9eec7d56e969/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c0caeb37ff72cfd9153e164e9fd9eec7d56e969/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=5c0caeb37ff72cfd9153e164e9fd9eec7d56e969", "patch": "@@ -3185,6 +3185,14 @@ gfc_type_for_mode (machine_mode mode, int unsignedp)\n       tree type = gfc_type_for_size (GET_MODE_PRECISION (int_mode), unsignedp);\n       return type != NULL_TREE && mode == TYPE_MODE (type) ? type : NULL_TREE;\n     }\n+  else if (GET_MODE_CLASS (mode) == MODE_VECTOR_BOOL\n+\t   && valid_vector_subparts_p (GET_MODE_NUNITS (mode)))\n+    {\n+      unsigned int elem_bits = vector_element_size (GET_MODE_BITSIZE (mode),\n+\t\t\t\t\t\t    GET_MODE_NUNITS (mode));\n+      tree bool_type = build_nonstandard_boolean_type (elem_bits);\n+      return build_vector_type_for_mode (bool_type, mode);\n+    }\n   else if (VECTOR_MODE_P (mode)\n \t   && valid_vector_subparts_p (GET_MODE_NUNITS (mode)))\n     {"}, {"sha": "9e37d65997eeafd553b0a015fd5f473ab9f40fa9", "filename": "gcc/genmodes.c", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c0caeb37ff72cfd9153e164e9fd9eec7d56e969/gcc%2Fgenmodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c0caeb37ff72cfd9153e164e9fd9eec7d56e969/gcc%2Fgenmodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmodes.c?ref=5c0caeb37ff72cfd9153e164e9fd9eec7d56e969", "patch": "@@ -375,6 +375,10 @@ complete_mode (struct mode_data *m)\n       m->bytesize = 2 * m->component->bytesize;\n       break;\n \n+    case MODE_VECTOR_BOOL:\n+      validate_mode (m, UNSET, SET, SET, SET, UNSET);\n+      break;\n+\n     case MODE_VECTOR_INT:\n     case MODE_VECTOR_FLOAT:\n     case MODE_VECTOR_FRACT:\n@@ -526,6 +530,28 @@ make_vector_modes (enum mode_class cl, unsigned int width,\n     }\n }\n \n+/* Create a vector of booleans called NAME with COUNT elements and\n+   BYTESIZE bytes in total.  */\n+#define VECTOR_BOOL_MODE(NAME, COUNT, BYTESIZE) \\\n+  make_vector_bool_mode (#NAME, COUNT, BYTESIZE, __FILE__, __LINE__)\n+static void ATTRIBUTE_UNUSED\n+make_vector_bool_mode (const char *name, unsigned int count,\n+\t\t       unsigned int bytesize, const char *file,\n+\t\t       unsigned int line)\n+{\n+  struct mode_data *m = find_mode (\"BI\");\n+  if (!m)\n+    {\n+      error (\"%s:%d: no mode \\\"BI\\\"\", file, line);\n+      return;\n+    }\n+\n+  struct mode_data *v = new_mode (MODE_VECTOR_BOOL, name, file, line);\n+  v->component = m;\n+  v->ncomponents = count;\n+  v->bytesize = bytesize;\n+}\n+\n /* Input.  */\n \n #define _SPECIAL_MODE(C, N) \\\n@@ -1438,7 +1464,8 @@ emit_mode_wider (void)\n \n \t  /* For vectors we want twice the number of components,\n \t     with the same element type.  */\n-\t  if (m->cl == MODE_VECTOR_INT\n+\t  if (m->cl == MODE_VECTOR_BOOL\n+\t      || m->cl == MODE_VECTOR_INT\n \t      || m->cl == MODE_VECTOR_FLOAT\n \t      || m->cl == MODE_VECTOR_FRACT\n \t      || m->cl == MODE_VECTOR_UFRACT\n@@ -1657,6 +1684,7 @@ emit_mode_adjustments (void)\n       printf (\"\\n  /* %s:%d */\\n\", a->file, a->line);\n       switch (a->mode->cl)\n \t{\n+\tcase MODE_VECTOR_BOOL:\n \tcase MODE_VECTOR_INT:\n \tcase MODE_VECTOR_FLOAT:\n \tcase MODE_VECTOR_FRACT:\n@@ -1688,6 +1716,10 @@ emit_mode_adjustments (void)\n \t\t      m->name);\n \t      break;\n \n+\t    case MODE_VECTOR_BOOL:\n+\t      /* Changes to BImode should not affect vector booleans.  */\n+\t      break;\n+\n \t    case MODE_VECTOR_INT:\n \t    case MODE_VECTOR_FLOAT:\n \t    case MODE_VECTOR_FRACT:\n@@ -1728,6 +1760,10 @@ emit_mode_adjustments (void)\n \t      printf (\"  mode_base_align[E_%smode] = s;\\n\", m->name);\n \t      break;\n \n+\t    case MODE_VECTOR_BOOL:\n+\t      /* Changes to BImode should not affect vector booleans.  */\n+\t      break;\n+\n \t    case MODE_VECTOR_INT:\n \t    case MODE_VECTOR_FLOAT:\n \t    case MODE_VECTOR_FRACT:"}, {"sha": "cf7586ecd9077320b3b68a02cf4b600896d15bcf", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c0caeb37ff72cfd9153e164e9fd9eec7d56e969/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c0caeb37ff72cfd9153e164e9fd9eec7d56e969/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=5c0caeb37ff72cfd9153e164e9fd9eec7d56e969", "patch": "@@ -1,3 +1,9 @@\n+2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* go-lang.c (go_langhook_type_for_mode): Handle MODE_VECTOR_BOOL.\n+\n 2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "e47036f608147d3e0c9ce2da3419fc27ec6b71e7", "filename": "gcc/go/go-lang.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c0caeb37ff72cfd9153e164e9fd9eec7d56e969/gcc%2Fgo%2Fgo-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c0caeb37ff72cfd9153e164e9fd9eec7d56e969/gcc%2Fgo%2Fgo-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-lang.c?ref=5c0caeb37ff72cfd9153e164e9fd9eec7d56e969", "patch": "@@ -377,8 +377,16 @@ go_langhook_type_for_mode (machine_mode mode, int unsignedp)\n      make sense for the middle-end to ask the frontend for a type\n      which the frontend does not support.  However, at least for now\n      it is required.  See PR 46805.  */\n-  if (VECTOR_MODE_P (mode)\n+  if (GET_MODE_CLASS (mode) == MODE_VECTOR_BOOL\n       && valid_vector_subparts_p (GET_MODE_NUNITS (mode)))\n+    {\n+      unsigned int elem_bits = vector_element_size (GET_MODE_BITSIZE (mode),\n+\t\t\t\t\t\t    GET_MODE_NUNITS (mode));\n+      tree bool_type = build_nonstandard_boolean_type (elem_bits);\n+      return build_vector_type_for_mode (bool_type, mode);\n+    }\n+  else if (VECTOR_MODE_P (mode)\n+\t   && valid_vector_subparts_p (GET_MODE_NUNITS (mode)))\n     {\n       tree inner;\n "}, {"sha": "8529c82376b8f1230053c710d014405d7d1cf634", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c0caeb37ff72cfd9153e164e9fd9eec7d56e969/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c0caeb37ff72cfd9153e164e9fd9eec7d56e969/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=5c0caeb37ff72cfd9153e164e9fd9eec7d56e969", "patch": "@@ -1675,6 +1675,7 @@ lto_input_mode_table (struct lto_file_decl_data *file_data)\n \t{\n \t  switch (mclass)\n \t    {\n+\t    case MODE_VECTOR_BOOL:\n \t    case MODE_VECTOR_INT:\n \t    case MODE_VECTOR_FLOAT:\n \t    case MODE_VECTOR_FRACT:"}, {"sha": "9c5f292fe5fe26b805c445e063b634f16904ff58", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c0caeb37ff72cfd9153e164e9fd9eec7d56e969/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c0caeb37ff72cfd9153e164e9fd9eec7d56e969/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=5c0caeb37ff72cfd9153e164e9fd9eec7d56e969", "patch": "@@ -1,3 +1,9 @@\n+2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* lto-lang.c (lto_type_for_mode): Handle MODE_VECTOR_BOOL.\n+\n 2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "a310d699a1949c3e7d2f8cddec9412b800d54d01", "filename": "gcc/lto/lto-lang.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c0caeb37ff72cfd9153e164e9fd9eec7d56e969/gcc%2Flto%2Flto-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c0caeb37ff72cfd9153e164e9fd9eec7d56e969/gcc%2Flto%2Flto-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-lang.c?ref=5c0caeb37ff72cfd9153e164e9fd9eec7d56e969", "patch": "@@ -1012,6 +1012,14 @@ lto_type_for_mode (machine_mode mode, int unsigned_p)\n       if (inner_type != NULL_TREE)\n \treturn build_complex_type (inner_type);\n     }\n+  else if (GET_MODE_CLASS (mode) == MODE_VECTOR_BOOL\n+\t   && valid_vector_subparts_p (GET_MODE_NUNITS (mode)))\n+    {\n+      unsigned int elem_bits = vector_element_size (GET_MODE_BITSIZE (mode),\n+\t\t\t\t\t\t    GET_MODE_NUNITS (mode));\n+      tree bool_type = build_nonstandard_boolean_type (elem_bits);\n+      return build_vector_type_for_mode (bool_type, mode);\n+    }\n   else if (VECTOR_MODE_P (mode)\n \t   && valid_vector_subparts_p (GET_MODE_NUNITS (mode)))\n     {"}, {"sha": "9a92b580b2f28d061bd2e2e8a996e48b9ce79584", "filename": "gcc/machmode.def", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c0caeb37ff72cfd9153e164e9fd9eec7d56e969/gcc%2Fmachmode.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c0caeb37ff72cfd9153e164e9fd9eec7d56e969/gcc%2Fmachmode.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.def?ref=5c0caeb37ff72cfd9153e164e9fd9eec7d56e969", "patch": "@@ -142,6 +142,13 @@ along with GCC; see the file COPYING3.  If not see\n \tthan two bytes (if CLASS is FLOAT).  CLASS must be INT or\n \tFLOAT.  The names follow the same rule as VECTOR_MODE uses.\n \n+     VECTOR_BOOL_MODE (NAME, COUNT, BYTESIZE)\n+        Create a vector mode called NAME that contains COUNT boolean\n+        elements and occupies BYTESIZE bytes in total.  Each boolean\n+        element occupies (COUNT * BITS_PER_UNIT) / BYTESIZE bits, with\n+        the element at index 0 occupying the lsb of the first byte in\n+        memory.  Only the lowest bit of each element is significant.\n+\n      COMPLEX_MODES (CLASS);\n         For all modes presently declared in class CLASS, construct\n \tcorresponding complex modes.  Modes smaller than one byte"}, {"sha": "5eaa868527dfa46df36ac0f903071092a66eac27", "filename": "gcc/machmode.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c0caeb37ff72cfd9153e164e9fd9eec7d56e969/gcc%2Fmachmode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c0caeb37ff72cfd9153e164e9fd9eec7d56e969/gcc%2Fmachmode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.h?ref=5c0caeb37ff72cfd9153e164e9fd9eec7d56e969", "patch": "@@ -108,6 +108,7 @@ extern const unsigned char mode_class[NUM_MACHINE_MODES];\n   (GET_MODE_CLASS (MODE) == MODE_INT\t\t\\\n    || GET_MODE_CLASS (MODE) == MODE_PARTIAL_INT \\\n    || GET_MODE_CLASS (MODE) == MODE_COMPLEX_INT \\\n+   || GET_MODE_CLASS (MODE) == MODE_VECTOR_BOOL \\\n    || GET_MODE_CLASS (MODE) == MODE_VECTOR_INT)\n \n /* Nonzero if MODE is a floating-point mode.  */\n@@ -123,8 +124,9 @@ extern const unsigned char mode_class[NUM_MACHINE_MODES];\n    || GET_MODE_CLASS (MODE) == MODE_COMPLEX_FLOAT)\n \n /* Nonzero if MODE is a vector mode.  */\n-#define VECTOR_MODE_P(MODE)\t\t\t\\\n-  (GET_MODE_CLASS (MODE) == MODE_VECTOR_INT\t\\\n+#define VECTOR_MODE_P(MODE)\t\t\t\t\\\n+  (GET_MODE_CLASS (MODE) == MODE_VECTOR_BOOL\t\t\\\n+   || GET_MODE_CLASS (MODE) == MODE_VECTOR_INT\t\t\\\n    || GET_MODE_CLASS (MODE) == MODE_VECTOR_FLOAT\t\\\n    || GET_MODE_CLASS (MODE) == MODE_VECTOR_FRACT\t\\\n    || GET_MODE_CLASS (MODE) == MODE_VECTOR_UFRACT\t\\"}, {"sha": "522e446c7ba6a10c4dd695dcd52ffa1356e9530d", "filename": "gcc/mode-classes.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c0caeb37ff72cfd9153e164e9fd9eec7d56e969/gcc%2Fmode-classes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c0caeb37ff72cfd9153e164e9fd9eec7d56e969/gcc%2Fmode-classes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmode-classes.def?ref=5c0caeb37ff72cfd9153e164e9fd9eec7d56e969", "patch": "@@ -31,6 +31,7 @@ along with GCC; see the file COPYING3.  If not see\n   DEF_MODE_CLASS (MODE_DECIMAL_FLOAT),\t/* decimal floating point */\t   \\\n   DEF_MODE_CLASS (MODE_COMPLEX_INT), \t/* complex numbers */\t\t   \\\n   DEF_MODE_CLASS (MODE_COMPLEX_FLOAT),\t\t\t\t\t   \\\n+  DEF_MODE_CLASS (MODE_VECTOR_BOOL),\t/* vectors of single bits */\t   \\\n   DEF_MODE_CLASS (MODE_VECTOR_INT),\t/* SIMD vectors */\t\t   \\\n   DEF_MODE_CLASS (MODE_VECTOR_FRACT),\t/* SIMD vectors */\t\t   \\\n   DEF_MODE_CLASS (MODE_VECTOR_UFRACT),\t/* SIMD vectors */\t\t   \\"}, {"sha": "c58760a7aaf3a31170aab5ad34237301b2274288", "filename": "gcc/rtx-vector-builder.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c0caeb37ff72cfd9153e164e9fd9eec7d56e969/gcc%2Frtx-vector-builder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c0caeb37ff72cfd9153e164e9fd9eec7d56e969/gcc%2Frtx-vector-builder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtx-vector-builder.c?ref=5c0caeb37ff72cfd9153e164e9fd9eec7d56e969", "patch": "@@ -88,6 +88,16 @@ rtx_vector_builder::find_cached_value ()\n \n   rtx elt = (*this)[0];\n \n+  if (GET_MODE_CLASS (m_mode) == MODE_VECTOR_BOOL)\n+    {\n+      if (elt == const1_rtx || elt == constm1_rtx)\n+\treturn CONST1_RTX (m_mode);\n+      else if (elt == const0_rtx)\n+\treturn CONST0_RTX (m_mode);\n+      else\n+\tgcc_unreachable ();\n+    }\n+\n   /* We can be called before the global vector constants are set up,\n      but in that case we'll just return null.  */\n   scalar_mode inner_mode = GET_MODE_INNER (m_mode);"}, {"sha": "58ebd6cfcfcf9716c942e7dedc81d721cc74f022", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c0caeb37ff72cfd9153e164e9fd9eec7d56e969/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c0caeb37ff72cfd9153e164e9fd9eec7d56e969/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=5c0caeb37ff72cfd9153e164e9fd9eec7d56e969", "patch": "@@ -379,12 +379,13 @@ int_mode_for_mode (machine_mode mode)\n     case MODE_COMPLEX_FLOAT:\n     case MODE_FLOAT:\n     case MODE_DECIMAL_FLOAT:\n-    case MODE_VECTOR_INT:\n-    case MODE_VECTOR_FLOAT:\n     case MODE_FRACT:\n     case MODE_ACCUM:\n     case MODE_UFRACT:\n     case MODE_UACCUM:\n+    case MODE_VECTOR_BOOL:\n+    case MODE_VECTOR_INT:\n+    case MODE_VECTOR_FLOAT:\n     case MODE_VECTOR_FRACT:\n     case MODE_VECTOR_ACCUM:\n     case MODE_VECTOR_UFRACT:"}, {"sha": "3dcbdeba9592c0be2de5d15ac25d81fba49aa5b4", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c0caeb37ff72cfd9153e164e9fd9eec7d56e969/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c0caeb37ff72cfd9153e164e9fd9eec7d56e969/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=5c0caeb37ff72cfd9153e164e9fd9eec7d56e969", "patch": "@@ -981,12 +981,7 @@ expand_vector_operation (gimple_stmt_iterator *gsi, tree type, tree compute_type\n   /* If the compute mode is not a vector mode (hence we are not decomposing\n      a BLKmode vector to smaller, hardware-supported vectors), we may want\n      to expand the operations in parallel.  */\n-  if (GET_MODE_CLASS (compute_mode) != MODE_VECTOR_INT\n-      && GET_MODE_CLASS (compute_mode) != MODE_VECTOR_FLOAT\n-      && GET_MODE_CLASS (compute_mode) != MODE_VECTOR_FRACT\n-      && GET_MODE_CLASS (compute_mode) != MODE_VECTOR_UFRACT\n-      && GET_MODE_CLASS (compute_mode) != MODE_VECTOR_ACCUM\n-      && GET_MODE_CLASS (compute_mode) != MODE_VECTOR_UACCUM)\n+  if (!VECTOR_MODE_P (compute_mode))\n     switch (code)\n       {\n       case PLUS_EXPR:\n@@ -1175,6 +1170,8 @@ type_for_widest_vector_mode (tree type, optab op)\n     mode = MIN_MODE_VECTOR_ACCUM;\n   else if (SCALAR_UACCUM_MODE_P (inner_mode))\n     mode = MIN_MODE_VECTOR_UACCUM;\n+  else if (inner_mode == BImode)\n+    mode = MIN_MODE_VECTOR_BOOL;\n   else\n     mode = MIN_MODE_VECTOR_INT;\n \n@@ -1537,12 +1534,7 @@ expand_vector_scalar_condition (gimple_stmt_iterator *gsi)\n   /* If the compute mode is not a vector mode (hence we are not decomposing\n      a BLKmode vector to smaller, hardware-supported vectors), we may want\n      to expand the operations in parallel.  */\n-  if (GET_MODE_CLASS (compute_mode) != MODE_VECTOR_INT\n-      && GET_MODE_CLASS (compute_mode) != MODE_VECTOR_FLOAT\n-      && GET_MODE_CLASS (compute_mode) != MODE_VECTOR_FRACT\n-      && GET_MODE_CLASS (compute_mode) != MODE_VECTOR_UFRACT\n-      && GET_MODE_CLASS (compute_mode) != MODE_VECTOR_ACCUM\n-      && GET_MODE_CLASS (compute_mode) != MODE_VECTOR_UACCUM)\n+  if (!VECTOR_MODE_P (compute_mode))\n     new_rhs = expand_vector_parallel (gsi, do_cond, type, rhs2, rhs3,\n \t\t\t\t      COND_EXPR);\n   else"}, {"sha": "63084ac2d4f8e14c1d7759f9ea91ffd7c7a7a169", "filename": "gcc/tree.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c0caeb37ff72cfd9153e164e9fd9eec7d56e969/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c0caeb37ff72cfd9153e164e9fd9eec7d56e969/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=5c0caeb37ff72cfd9153e164e9fd9eec7d56e969", "patch": "@@ -10509,6 +10509,7 @@ build_vector_type_for_mode (tree innertype, machine_mode mode)\n \n   switch (GET_MODE_CLASS (mode))\n     {\n+    case MODE_VECTOR_BOOL:\n     case MODE_VECTOR_INT:\n     case MODE_VECTOR_FLOAT:\n     case MODE_VECTOR_FRACT:"}, {"sha": "ea79893a547e746615b10c80948ea60444d4f013", "filename": "gcc/varasm.c", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c0caeb37ff72cfd9153e164e9fd9eec7d56e969/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c0caeb37ff72cfd9153e164e9fd9eec7d56e969/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=5c0caeb37ff72cfd9153e164e9fd9eec7d56e969", "patch": "@@ -3918,6 +3918,32 @@ output_constant_pool_2 (fixed_size_mode mode, rtx x, unsigned int align)\n       assemble_integer (x, GET_MODE_SIZE (mode), align, 1);\n       break;\n \n+    case MODE_VECTOR_BOOL:\n+      {\n+\tgcc_assert (GET_CODE (x) == CONST_VECTOR);\n+\n+\t/* Pick the smallest integer mode that contains at least one\n+\t   whole element.  Often this is byte_mode and contains more\n+\t   than one element.  */\n+\tunsigned int nelts = GET_MODE_NUNITS (mode);\n+\tunsigned int elt_bits = GET_MODE_BITSIZE (mode) / nelts;\n+\tunsigned int int_bits = MAX (elt_bits, BITS_PER_UNIT);\n+\tscalar_int_mode int_mode = int_mode_for_size (int_bits, 0).require ();\n+\n+\t/* Build the constant up one integer at a time.  */\n+\tunsigned int elts_per_int = int_bits / elt_bits;\n+\tfor (unsigned int i = 0; i < nelts; i += elts_per_int)\n+\t  {\n+\t    unsigned HOST_WIDE_INT value = 0;\n+\t    unsigned int limit = MIN (nelts - i, elts_per_int);\n+\t    for (unsigned int j = 0; j < limit; ++j)\n+\t      if (INTVAL (CONST_VECTOR_ELT (x, i + j)) != 0)\n+\t\tvalue |= 1 << (j * elt_bits);\n+\t    output_constant_pool_2 (int_mode, gen_int_mode (value, int_mode),\n+\t\t\t\t    i != 0 ? MIN (align, int_bits) : align);\n+\t  }\n+\tbreak;\n+      }\n     case MODE_VECTOR_FLOAT:\n     case MODE_VECTOR_INT:\n     case MODE_VECTOR_FRACT:"}]}