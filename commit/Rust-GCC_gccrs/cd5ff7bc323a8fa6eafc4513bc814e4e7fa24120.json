{"sha": "cd5ff7bc323a8fa6eafc4513bc814e4e7fa24120", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2Q1ZmY3YmMzMjNhOGZhNmVhZmM0NTEzYmM4MTRlNGU3ZmEyNDEyMA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-02T18:28:14Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-02T18:28:14Z"}, "message": "Make CONST_VECTOR_ELT handle implicitly-encoded elements\n\nThis patch makes CONST_VECTOR_ELT handle implicitly-encoded elements,\nin a similar way to VECTOR_CST_ELT.\n\n2018-01-02  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* rtl.h (CONST_VECTOR_ELT): Redefine to const_vector_elt.\n\t(const_vector_encoded_nelts): New function.\n\t(CONST_VECTOR_NUNITS): Redefine to use GET_MODE_NUNITS.\n\t(const_vector_int_elt, const_vector_elt): Declare.\n\t* emit-rtl.c (const_vector_int_elt_1): New function.\n\t(const_vector_elt): Likewise.\n\t* simplify-rtx.c (simplify_immed_subreg): Avoid taking the address\n\tof CONST_VECTOR_ELT.\n\nFrom-SVN: r256104", "tree": {"sha": "4a69a3ee23bde8480b983e60720932a0219c7a95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4a69a3ee23bde8480b983e60720932a0219c7a95"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cd5ff7bc323a8fa6eafc4513bc814e4e7fa24120", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd5ff7bc323a8fa6eafc4513bc814e4e7fa24120", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd5ff7bc323a8fa6eafc4513bc814e4e7fa24120", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd5ff7bc323a8fa6eafc4513bc814e4e7fa24120/comments", "author": null, "committer": null, "parents": [{"sha": "3d8ca53dd9b4c42b07ef974f92c3c4553cce3a79", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d8ca53dd9b4c42b07ef974f92c3c4553cce3a79", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d8ca53dd9b4c42b07ef974f92c3c4553cce3a79"}], "stats": {"total": 87, "additions": 82, "deletions": 5}, "files": [{"sha": "c6d87f41c3df5be84377e0446f34f3665337e543", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd5ff7bc323a8fa6eafc4513bc814e4e7fa24120/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd5ff7bc323a8fa6eafc4513bc814e4e7fa24120/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cd5ff7bc323a8fa6eafc4513bc814e4e7fa24120", "patch": "@@ -1,3 +1,14 @@\n+2018-01-02  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* rtl.h (CONST_VECTOR_ELT): Redefine to const_vector_elt.\n+\t(const_vector_encoded_nelts): New function.\n+\t(CONST_VECTOR_NUNITS): Redefine to use GET_MODE_NUNITS.\n+\t(const_vector_int_elt, const_vector_elt): Declare.\n+\t* emit-rtl.c (const_vector_int_elt_1): New function.\n+\t(const_vector_elt): Likewise.\n+\t* simplify-rtx.c (simplify_immed_subreg): Avoid taking the address\n+\tof CONST_VECTOR_ELT.\n+\n 2018-01-02  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* expr.c: Include rtx-vector-builder.h."}, {"sha": "e282b3d13cdc730cd587b7207046c32f77e15dd3", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd5ff7bc323a8fa6eafc4513bc814e4e7fa24120/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd5ff7bc323a8fa6eafc4513bc814e4e7fa24120/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=cd5ff7bc323a8fa6eafc4513bc814e4e7fa24120", "patch": "@@ -5862,6 +5862,62 @@ init_emit (void)\n #endif\n }\n \n+/* Return the value of element I of CONST_VECTOR X as a wide_int.  */\n+\n+wide_int\n+const_vector_int_elt (const_rtx x, unsigned int i)\n+{\n+  /* First handle elements that are directly encoded.  */\n+  machine_mode elt_mode = GET_MODE_INNER (GET_MODE (x));\n+  if (i < (unsigned int) XVECLEN (x, 0))\n+    return rtx_mode_t (CONST_VECTOR_ENCODED_ELT (x, i), elt_mode);\n+\n+  /* Identify the pattern that contains element I and work out the index of\n+     the last encoded element for that pattern.  */\n+  unsigned int encoded_nelts = const_vector_encoded_nelts (x);\n+  unsigned int npatterns = CONST_VECTOR_NPATTERNS (x);\n+  unsigned int count = i / npatterns;\n+  unsigned int pattern = i % npatterns;\n+  unsigned int final_i = encoded_nelts - npatterns + pattern;\n+\n+  /* If there are no steps, the final encoded value is the right one.  */\n+  if (!CONST_VECTOR_STEPPED_P (x))\n+    return rtx_mode_t (CONST_VECTOR_ENCODED_ELT (x, final_i), elt_mode);\n+\n+  /* Otherwise work out the value from the last two encoded elements.  */\n+  rtx v1 = CONST_VECTOR_ENCODED_ELT (x, final_i - npatterns);\n+  rtx v2 = CONST_VECTOR_ENCODED_ELT (x, final_i);\n+  wide_int diff = wi::sub (rtx_mode_t (v2, elt_mode),\n+\t\t\t   rtx_mode_t (v1, elt_mode));\n+  return wi::add (rtx_mode_t (v2, elt_mode), (count - 2) * diff);\n+}\n+\n+/* Return the value of element I of CONST_VECTOR X.  */\n+\n+rtx\n+const_vector_elt (const_rtx x, unsigned int i)\n+{\n+  /* First handle elements that are directly encoded.  */\n+  if (i < (unsigned int) XVECLEN (x, 0))\n+    return CONST_VECTOR_ENCODED_ELT (x, i);\n+\n+  /* If there are no steps, the final encoded value is the right one.  */\n+  if (!CONST_VECTOR_STEPPED_P (x))\n+    {\n+      /* Identify the pattern that contains element I and work out the index of\n+\t the last encoded element for that pattern.  */\n+      unsigned int encoded_nelts = const_vector_encoded_nelts (x);\n+      unsigned int npatterns = CONST_VECTOR_NPATTERNS (x);\n+      unsigned int pattern = i % npatterns;\n+      unsigned int final_i = encoded_nelts - npatterns + pattern;\n+      return CONST_VECTOR_ENCODED_ELT (x, final_i);\n+    }\n+\n+  /* Otherwise work out the value from the last two encoded elements.  */\n+  return immed_wide_int_const (const_vector_int_elt (x, i),\n+\t\t\t       GET_MODE_INNER (GET_MODE (x)));\n+}\n+\n /* Return true if X is a valid element for a CONST_VECTOR of the given\n   mode.  */\n "}, {"sha": "ee0ce22e8e705b68473c65c8f7645173ac119f59", "filename": "gcc/rtl.h", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd5ff7bc323a8fa6eafc4513bc814e4e7fa24120/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd5ff7bc323a8fa6eafc4513bc814e4e7fa24120/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=cd5ff7bc323a8fa6eafc4513bc814e4e7fa24120", "patch": "@@ -1969,7 +1969,7 @@ set_regno_raw (rtx x, unsigned int regno, unsigned int nregs)\n   ((HOST_WIDE_INT) (CONST_FIXED_VALUE (r)->data.low))\n \n /* For a CONST_VECTOR, return element #n.  */\n-#define CONST_VECTOR_ELT(RTX, N) XCVECEXP (RTX, 0, N, CONST_VECTOR)\n+#define CONST_VECTOR_ELT(RTX, N) const_vector_elt (RTX, N)\n \n /* See rtl.texi for a description of these macros.  */\n #define CONST_VECTOR_NPATTERNS(RTX) \\\n@@ -1988,8 +1988,16 @@ set_regno_raw (rtx x, unsigned int regno, unsigned int nregs)\n \n #define CONST_VECTOR_ENCODED_ELT(RTX, N) XCVECEXP (RTX, 0, N, CONST_VECTOR)\n \n+/* Return the number of elements encoded directly in a CONST_VECTOR.  */\n+\n+inline unsigned int\n+const_vector_encoded_nelts (const_rtx x)\n+{\n+  return CONST_VECTOR_NPATTERNS (x) * CONST_VECTOR_NELTS_PER_PATTERN (x);\n+}\n+\n /* For a CONST_VECTOR, return the number of elements in a vector.  */\n-#define CONST_VECTOR_NUNITS(RTX) XCVECLEN (RTX, 0, CONST_VECTOR)\n+#define CONST_VECTOR_NUNITS(RTX) GET_MODE_NUNITS (GET_MODE (RTX))\n \n /* For a SUBREG rtx, SUBREG_REG extracts the value we want a subreg of.\n    SUBREG_BYTE extracts the byte-number.  */\n@@ -3001,6 +3009,8 @@ unwrap_const_vec_duplicate (T x)\n }\n \n /* In emit-rtl.c.  */\n+extern wide_int const_vector_int_elt (const_rtx, unsigned int);\n+extern rtx const_vector_elt (const_rtx, unsigned int);\n extern bool const_vec_series_p_1 (const_rtx, rtx *, rtx *);\n \n /* Return true if X is an integer constant vector that contains a linear"}, {"sha": "22cabc5e534a026758bcdeefbe6f9119db5c4e76", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd5ff7bc323a8fa6eafc4513bc814e4e7fa24120/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd5ff7bc323a8fa6eafc4513bc814e4e7fa24120/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=cd5ff7bc323a8fa6eafc4513bc814e4e7fa24120", "patch": "@@ -5991,13 +5991,11 @@ simplify_immed_subreg (fixed_size_mode outermode, rtx op,\n   if (GET_CODE (op) == CONST_VECTOR)\n     {\n       num_elem = CONST_VECTOR_NUNITS (op);\n-      elems = &CONST_VECTOR_ELT (op, 0);\n       elem_bitsize = GET_MODE_UNIT_BITSIZE (innermode);\n     }\n   else\n     {\n       num_elem = 1;\n-      elems = &op;\n       elem_bitsize = max_bitsize;\n     }\n   /* If this asserts, it is too complicated; reducing value_bit may help.  */\n@@ -6008,7 +6006,9 @@ simplify_immed_subreg (fixed_size_mode outermode, rtx op,\n   for (elem = 0; elem < num_elem; elem++)\n     {\n       unsigned char * vp;\n-      rtx el = elems[elem];\n+      rtx el = (GET_CODE (op) == CONST_VECTOR\n+\t\t? CONST_VECTOR_ELT (op, elem)\n+\t\t: op);\n \n       /* Vectors are kept in target memory order.  (This is probably\n \t a mistake.)  */"}]}