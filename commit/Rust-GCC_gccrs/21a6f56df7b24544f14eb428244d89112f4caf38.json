{"sha": "21a6f56df7b24544f14eb428244d89112f4caf38", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjFhNmY1NmRmN2IyNDU0NGYxNGViNDI4MjQ0ZDg5MTEyZjRjYWYzOA==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "1999-04-07T08:01:35Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "1999-04-07T08:01:35Z"}, "message": "Initial revision\n\nFrom-SVN: r26250", "tree": {"sha": "3d570532df5d48e17215de3a013d285a0fd44e3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3d570532df5d48e17215de3a013d285a0fd44e3e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/21a6f56df7b24544f14eb428244d89112f4caf38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21a6f56df7b24544f14eb428244d89112f4caf38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21a6f56df7b24544f14eb428244d89112f4caf38", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21a6f56df7b24544f14eb428244d89112f4caf38/comments", "author": null, "committer": null, "parents": [{"sha": "b6009c6ed66b04821d17bd550d875e291e9721a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6009c6ed66b04821d17bd550d875e291e9721a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6009c6ed66b04821d17bd550d875e291e9721a2"}], "stats": {"total": 791, "additions": 791, "deletions": 0}, "files": [{"sha": "0785a6e92ced0e6aa68a50903f9d162853f4f203", "filename": "boehm-gc/dyn_load.c", "status": "added", "additions": 791, "deletions": 0, "changes": 791, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21a6f56df7b24544f14eb428244d89112f4caf38/boehm-gc%2Fdyn_load.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21a6f56df7b24544f14eb428244d89112f4caf38/boehm-gc%2Fdyn_load.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdyn_load.c?ref=21a6f56df7b24544f14eb428244d89112f4caf38", "patch": "@@ -0,0 +1,791 @@\n+/*\n+ * Copyright (c) 1991-1994 by Xerox Corporation.  All rights reserved.\n+ * Copyright (c) 1997 by Silicon Graphics.  All rights reserved.\n+ *\n+ * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+ * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+ *\n+ * Permission is hereby granted to use or copy this program\n+ * for any purpose,  provided the above notices are retained on all copies.\n+ * Permission to modify the code and to distribute modified code is granted,\n+ * provided the above notices are retained, and a notice that the code was\n+ * modified is included with the above copyright notice.\n+ *\n+ * Original author: Bill Janssen\n+ * Heavily modified by Hans Boehm and others\n+ */\n+\n+/*\n+ * This is incredibly OS specific code for tracking down data sections in\n+ * dynamic libraries.  There appears to be no way of doing this quickly\n+ * without groveling through undocumented data structures.  We would argue\n+ * that this is a bug in the design of the dlopen interface.  THIS CODE\n+ * MAY BREAK IN FUTURE OS RELEASES.  If this matters to you, don't hesitate\n+ * to let your vendor know ...\n+ *\n+ * None of this is safe with dlclose and incremental collection.\n+ * But then not much of anything is safe in the presence of dlclose.\n+ */\n+#ifndef MACOS\n+#  include <sys/types.h>\n+#endif\n+#include \"gc_priv.h\"\n+\n+/* BTL: avoid circular redefinition of dlopen if SOLARIS_THREADS defined */\n+# if defined(SOLARIS_THREADS) && defined(dlopen)\n+    /* To support threads in Solaris, gc.h interposes on dlopen by       */\n+    /* defining \"dlopen\" to be \"GC_dlopen\", which is implemented below.  */\n+    /* However, both GC_FirstDLOpenedLinkMap() and GC_dlopen() use the   */\n+    /* real system dlopen() in their implementation. We first remove     */\n+    /* gc.h's dlopen definition and restore it later, after GC_dlopen(). */\n+#   undef dlopen\n+#   define GC_must_restore_redefined_dlopen\n+# else\n+#   undef GC_must_restore_redefined_dlopen\n+# endif\n+\n+#if (defined(DYNAMIC_LOADING) || defined(MSWIN32)) && !defined(PCR)\n+#if !defined(SUNOS4) && !defined(SUNOS5DL) && !defined(IRIX5) && \\\n+    !defined(MSWIN32) && !(defined(ALPHA) && defined(OSF1)) && \\\n+    !defined(HP_PA) && (!defined(LINUX) && !defined(__ELF__)) && \\\n+    !defined(RS6000) && !defined(SCO_ELF)\n+ --> We only know how to find data segments of dynamic libraries for the\n+ --> above.  Additional SVR4 variants might not be too\n+ --> hard to add.\n+#endif\n+\n+#include <stdio.h>\n+#ifdef SUNOS5DL\n+#   include <sys/elf.h>\n+#   include <dlfcn.h>\n+#   include <link.h>\n+#endif\n+#ifdef SUNOS4\n+#   include <dlfcn.h>\n+#   include <link.h>\n+#   include <a.out.h>\n+  /* struct link_map field overrides */\n+#   define l_next\tlm_next\n+#   define l_addr\tlm_addr\n+#   define l_name\tlm_name\n+#endif\n+\n+\n+#if defined(SUNOS5DL) && !defined(USE_PROC_FOR_LIBRARIES)\n+\n+#ifdef LINT\n+    Elf32_Dyn _DYNAMIC;\n+#endif\n+\n+static struct link_map *\n+GC_FirstDLOpenedLinkMap()\n+{\n+    extern Elf32_Dyn _DYNAMIC;\n+    Elf32_Dyn *dp;\n+    struct r_debug *r;\n+    static struct link_map * cachedResult = 0;\n+    static Elf32_Dyn *dynStructureAddr = 0;\n+    \t\t\t/* BTL: added to avoid Solaris 5.3 ld.so _DYNAMIC bug */\n+\n+#   ifdef SUNOS53_SHARED_LIB\n+\t/* BTL: Avoid the Solaris 5.3 bug that _DYNAMIC isn't being set\t*/\n+\t/* up properly in dynamically linked .so's. This means we have\t*/\n+\t/* to use its value in the set of original object files loaded\t*/\n+\t/* at program startup.\t\t\t\t\t\t*/\n+\tif( dynStructureAddr == 0 ) {\n+\t  void* startupSyms = dlopen(0, RTLD_LAZY);\n+\t  dynStructureAddr = (Elf32_Dyn*)dlsym(startupSyms, \"_DYNAMIC\");\n+\t\t}\n+#   else\n+\tdynStructureAddr = &_DYNAMIC;\n+#   endif\n+\n+    if( dynStructureAddr == 0) {\n+        return(0);\n+    }\n+    if( cachedResult == 0 ) {\n+        int tag;\n+        for( dp = ((Elf32_Dyn *)(&_DYNAMIC)); (tag = dp->d_tag) != 0; dp++ ) {\n+            if( tag == DT_DEBUG ) {\n+                struct link_map *lm\n+                        = ((struct r_debug *)(dp->d_un.d_ptr))->r_map;\n+                if( lm != 0 ) cachedResult = lm->l_next; /* might be NIL */\n+                break;\n+            }\n+        }\n+    }\n+    return cachedResult;\n+}\n+\n+#endif /* SUNOS5DL ... */\n+\n+#if defined(SUNOS4) && !defined(USE_PROC_FOR_LIBRARIES)\n+\n+#ifdef LINT\n+    struct link_dynamic _DYNAMIC;\n+#endif\n+\n+static struct link_map *\n+GC_FirstDLOpenedLinkMap()\n+{\n+    extern struct link_dynamic _DYNAMIC;\n+\n+    if( &_DYNAMIC == 0) {\n+        return(0);\n+    }\n+    return(_DYNAMIC.ld_un.ld_1->ld_loaded);\n+}\n+\n+/* Return the address of the ld.so allocated common symbol\t*/\n+/* with the least address, or 0 if none.\t\t\t*/\n+static ptr_t GC_first_common()\n+{\n+    ptr_t result = 0;\n+    extern struct link_dynamic _DYNAMIC;\n+    struct rtc_symb * curr_symbol;\n+    \n+    if( &_DYNAMIC == 0) {\n+        return(0);\n+    }\n+    curr_symbol = _DYNAMIC.ldd -> ldd_cp;\n+    for (; curr_symbol != 0; curr_symbol = curr_symbol -> rtc_next) {\n+        if (result == 0\n+            || (ptr_t)(curr_symbol -> rtc_sp -> n_value) < result) {\n+            result = (ptr_t)(curr_symbol -> rtc_sp -> n_value);\n+        }\n+    }\n+    return(result);\n+}\n+\n+#endif  /* SUNOS4 ... */\n+\n+# if defined(SUNOS4) || defined(SUNOS5DL)\n+/* Add dynamic library data sections to the root set.\t\t*/\n+# if !defined(PCR) && !defined(SOLARIS_THREADS) && defined(THREADS)\n+#   ifndef SRC_M3\n+\t--> fix mutual exclusion with dlopen\n+#   endif  /* We assume M3 programs don't call dlopen for now */\n+# endif\n+\n+# ifdef SOLARIS_THREADS\n+  /* Redefine dlopen to guarantee mutual exclusion with\t*/\n+  /* GC_register_dynamic_libraries.\t\t\t*/\n+  /* assumes that dlopen doesn't need to call GC_malloc\t*/\n+  /* and friends.\t\t\t\t\t*/\n+# include <thread.h>\n+# include <synch.h>\n+\n+void * GC_dlopen(const char *path, int mode)\n+{\n+    void * result;\n+    \n+#   ifndef USE_PROC_FOR_LIBRARIES\n+      mutex_lock(&GC_allocate_ml);\n+#   endif\n+    result = dlopen(path, mode);\n+#   ifndef USE_PROC_FOR_LIBRARIES\n+      mutex_unlock(&GC_allocate_ml);\n+#   endif\n+    return(result);\n+}\n+# endif  /* SOLARIS_THREADS */\n+\n+/* BTL: added to fix circular dlopen definition if SOLARIS_THREADS defined */\n+# if defined(GC_must_restore_redefined_dlopen)\n+#   define dlopen GC_dlopen\n+# endif\n+\n+# ifndef USE_PROC_FOR_LIBRARIES\n+void GC_register_dynamic_libraries()\n+{\n+  struct link_map *lm = GC_FirstDLOpenedLinkMap();\n+  \n+\n+  for (lm = GC_FirstDLOpenedLinkMap();\n+       lm != (struct link_map *) 0;  lm = lm->l_next)\n+    {\n+#     ifdef SUNOS4\n+\tstruct exec *e;\n+\t \n+        e = (struct exec *) lm->lm_addr;\n+        GC_add_roots_inner(\n+      \t\t    ((char *) (N_DATOFF(*e) + lm->lm_addr)),\n+\t\t    ((char *) (N_BSSADDR(*e) + e->a_bss + lm->lm_addr)),\n+\t\t    TRUE);\n+#     endif\n+#     ifdef SUNOS5DL\n+\tElf32_Ehdr * e;\n+        Elf32_Phdr * p;\n+        unsigned long offset;\n+        char * start;\n+        register int i;\n+        \n+\te = (Elf32_Ehdr *) lm->l_addr;\n+        p = ((Elf32_Phdr *)(((char *)(e)) + e->e_phoff));\n+        offset = ((unsigned long)(lm->l_addr));\n+        for( i = 0; i < (int)(e->e_phnum); ((i++),(p++)) ) {\n+          switch( p->p_type ) {\n+            case PT_LOAD:\n+              {\n+                if( !(p->p_flags & PF_W) ) break;\n+                start = ((char *)(p->p_vaddr)) + offset;\n+                GC_add_roots_inner(\n+                  start,\n+                  start + p->p_memsz,\n+                  TRUE\n+                );\n+              }\n+              break;\n+            default:\n+              break;\n+          }\n+\t}\n+#     endif\n+    }\n+#   ifdef SUNOS4\n+      {\n+      \tstatic ptr_t common_start = 0;\n+      \tptr_t common_end;\n+      \textern ptr_t GC_find_limit();\n+      \t\n+      \tif (common_start == 0) common_start = GC_first_common();\n+      \tif (common_start != 0) {\n+      \t    common_end = GC_find_limit(common_start, TRUE);\n+      \t    GC_add_roots_inner((char *)common_start, (char *)common_end, TRUE);\n+      \t}\n+      }\n+#   endif\n+}\n+\n+# endif /* !USE_PROC ... */\n+# endif /* SUNOS */\n+\n+#if defined(LINUX) && defined(__ELF__) || defined(SCO_ELF)\n+\n+/* Dynamic loading code for Linux running ELF. Somewhat tested on\n+ * Linux/x86, untested but hopefully should work on Linux/Alpha. \n+ * This code was derived from the Solaris/ELF support. Thanks to\n+ * whatever kind soul wrote that.  - Patrick Bridges */\n+\n+#include <elf.h>\n+#include <link.h>\n+\n+/* Newer versions of Linux/Alpha and Linux/x86 define this macro.  We\n+ * define it for those older versions that don't.  */\n+#  ifndef ElfW\n+#    if !defined(ELF_CLASS) || ELF_CLASS == ELFCLASS32\n+#      define ElfW(type) Elf32_##type\n+#    else\n+#      define ElfW(type) Elf64_##type\n+#    endif\n+#  endif\n+\n+static struct link_map *\n+GC_FirstDLOpenedLinkMap()\n+{\n+    extern ElfW(Dyn) _DYNAMIC[];\n+    ElfW(Dyn) *dp;\n+    struct r_debug *r;\n+    static struct link_map *cachedResult = 0;\n+\n+    if( _DYNAMIC == 0) {\n+        return(0);\n+    }\n+    if( cachedResult == 0 ) {\n+        int tag;\n+        for( dp = _DYNAMIC; (tag = dp->d_tag) != 0; dp++ ) {\n+            if( tag == DT_DEBUG ) {\n+                struct link_map *lm\n+                        = ((struct r_debug *)(dp->d_un.d_ptr))->r_map;\n+                if( lm != 0 ) cachedResult = lm->l_next; /* might be NIL */\n+                break;\n+            }\n+        }\n+    }\n+    return cachedResult;\n+}\n+\n+\n+void GC_register_dynamic_libraries()\n+{\n+  struct link_map *lm = GC_FirstDLOpenedLinkMap();\n+  \n+\n+  for (lm = GC_FirstDLOpenedLinkMap();\n+       lm != (struct link_map *) 0;  lm = lm->l_next)\n+    {\n+\tElfW(Ehdr) * e;\n+        ElfW(Phdr) * p;\n+        unsigned long offset;\n+        char * start;\n+        register int i;\n+        \n+\te = (ElfW(Ehdr) *) lm->l_addr;\n+        p = ((ElfW(Phdr) *)(((char *)(e)) + e->e_phoff));\n+        offset = ((unsigned long)(lm->l_addr));\n+        for( i = 0; i < (int)(e->e_phnum); ((i++),(p++)) ) {\n+          switch( p->p_type ) {\n+            case PT_LOAD:\n+              {\n+                if( !(p->p_flags & PF_W) ) break;\n+                start = ((char *)(p->p_vaddr)) + offset;\n+                GC_add_roots_inner(start, start + p->p_memsz, TRUE);\n+              }\n+              break;\n+            default:\n+              break;\n+          }\n+\t}\n+    }\n+}\n+\n+#endif\n+\n+#if defined(IRIX5) || defined(USE_PROC_FOR_LIBRARIES)\n+\n+#include <sys/procfs.h>\n+#include <sys/stat.h>\n+#include <fcntl.h>\n+#include <elf.h>\n+#include <errno.h>\n+\n+extern void * GC_roots_present();\n+\n+extern ptr_t GC_scratch_last_end_ptr; /* End of GC_scratch_alloc arena\t*/\n+\n+/* We use /proc to track down all parts of the address space that are\t*/\n+/* mapped by the process, and throw out regions we know we shouldn't\t*/\n+/* worry about.  This may also work under other SVR4 variants.\t\t*/\n+void GC_register_dynamic_libraries()\n+{\n+    static int fd = -1;\n+    char buf[30];\n+    static prmap_t * addr_map = 0;\n+    static int current_sz = 0;\t/* Number of records currently in addr_map */\n+    static int needed_sz;\t/* Required size of addr_map\t\t*/\n+    register int i;\n+    register long flags;\n+    register ptr_t start;\n+    register ptr_t limit;\n+    ptr_t heap_start = (ptr_t)HEAP_START;\n+    ptr_t heap_end = heap_start;\n+\n+#   ifdef SUNOS5DL\n+#     define MA_PHYS 0\n+#   endif /* SUNOS5DL */\n+\n+    if (fd < 0) {\n+      sprintf(buf, \"/proc/%d\", getpid());\n+      fd = open(buf, O_RDONLY);\n+      if (fd < 0) {\n+    \tABORT(\"/proc open failed\");\n+      }\n+    }\n+    if (ioctl(fd, PIOCNMAP, &needed_sz) < 0) {\n+\tGC_err_printf2(\"fd = %d, errno = %d\\n\", fd, errno);\n+    \tABORT(\"/proc PIOCNMAP ioctl failed\");\n+    }\n+    if (needed_sz >= current_sz) {\n+        current_sz = needed_sz * 2 + 1;\n+        \t\t/* Expansion, plus room for 0 record */\n+        addr_map = (prmap_t *)GC_scratch_alloc(current_sz * sizeof(prmap_t));\n+    }\n+    if (ioctl(fd, PIOCMAP, addr_map) < 0) {\n+        GC_err_printf4(\"fd = %d, errno = %d, needed_sz = %d, addr_map = 0x%X\\n\",\n+                        fd, errno, needed_sz, addr_map);\n+    \tABORT(\"/proc PIOCMAP ioctl failed\");\n+    };\n+    if (GC_n_heap_sects > 0) {\n+    \theap_end = GC_heap_sects[GC_n_heap_sects-1].hs_start\n+    \t\t\t+ GC_heap_sects[GC_n_heap_sects-1].hs_bytes;\n+    \tif (heap_end < GC_scratch_last_end_ptr) heap_end = GC_scratch_last_end_ptr; \n+    }\n+    for (i = 0; i < needed_sz; i++) {\n+        flags = addr_map[i].pr_mflags;\n+        if ((flags & (MA_BREAK | MA_STACK | MA_PHYS)) != 0) goto irrelevant;\n+        if ((flags & (MA_READ | MA_WRITE)) != (MA_READ | MA_WRITE))\n+            goto irrelevant;\n+          /* The latter test is empirically useless.  Other than the\t*/\n+          /* main data and stack segments, everything appears to be\t*/\n+          /* mapped readable, writable, executable, and shared(!!).\t*/\n+          /* This makes no sense to me.\t- HB\t\t\t\t*/\n+        start = (ptr_t)(addr_map[i].pr_vaddr);\n+        if (GC_roots_present(start)) goto irrelevant;\n+        if (start < heap_end && start >= heap_start)\n+        \tgoto irrelevant;\n+#\tifdef MMAP_STACKS\n+\t  if (GC_is_thread_stack(start)) goto irrelevant;\n+#\tendif /* MMAP_STACKS */\n+\n+        limit = start + addr_map[i].pr_size;\n+\tif (addr_map[i].pr_off == 0 && strncmp(start, ELFMAG, 4) == 0) {\n+\t    /* Discard text segments, i.e. 0-offset mappings against\t*/\n+\t    /* executable files which appear to have ELF headers.\t*/\n+\t    caddr_t arg;\n+\t    int obj;\n+#\t    define MAP_IRR_SZ 10\n+\t    static ptr_t map_irr[MAP_IRR_SZ];\n+\t    \t\t\t\t/* Known irrelevant map entries\t*/\n+\t    static int n_irr = 0;\n+\t    struct stat buf;\n+\t    register int i;\n+\t    \n+\t    for (i = 0; i < n_irr; i++) {\n+\t        if (map_irr[i] == start) goto irrelevant;\n+\t    }\n+\t    arg = (caddr_t)start;\n+\t    obj = ioctl(fd, PIOCOPENM, &arg);\n+\t    if (obj >= 0) {\n+\t        fstat(obj, &buf);\n+\t        close(obj);\n+\t        if ((buf.st_mode & 0111) != 0) {\n+\t            if (n_irr < MAP_IRR_SZ) {\n+\t                map_irr[n_irr++] = start;\n+\t            }\n+\t            goto irrelevant;\n+\t        }\n+\t    }\n+\t}\n+        GC_add_roots_inner(start, limit, TRUE);\n+      irrelevant: ;\n+    }\n+    /* Dont keep cached descriptor, for now.  Some kernels don't like us */\n+    /* to keep a /proc file descriptor around during kill -9.\t\t */\n+    \tif (close(fd) < 0) ABORT(\"Couldnt close /proc file\");\n+\tfd = -1;\n+}\n+\n+# endif /* USE_PROC || IRIX5 */\n+\n+# ifdef MSWIN32\n+\n+# define WIN32_LEAN_AND_MEAN\n+# define NOSERVICE\n+# include <windows.h>\n+# include <stdlib.h>\n+\n+  /* We traverse the entire address space and register all segments \t*/\n+  /* that could possibly have been written to.\t\t\t\t*/\n+  DWORD GC_allocation_granularity;\n+  \n+  extern GC_bool GC_is_heap_base (ptr_t p);\n+\n+# ifdef WIN32_THREADS\n+    extern void GC_get_next_stack(char *start, char **lo, char **hi);\n+# endif\n+  \n+  void GC_cond_add_roots(char *base, char * limit)\n+  {\n+    char dummy;\n+    char * stack_top\n+           = (char *) ((word)(&dummy) & ~(GC_allocation_granularity-1));\n+    if (base == limit) return;\n+#   ifdef WIN32_THREADS\n+    {\n+        char * curr_base = base;\n+\tchar * next_stack_lo;\n+\tchar * next_stack_hi;\n+\t\n+\tfor(;;) {\n+\t    GC_get_next_stack(curr_base, &next_stack_lo, &next_stack_hi);\n+\t    if (next_stack_lo >= limit) break;\n+\t    GC_add_roots_inner(curr_base, next_stack_lo, TRUE);\n+\t    curr_base = next_stack_hi;\n+\t}\n+\tif (curr_base < limit) GC_add_roots_inner(curr_base, limit, TRUE);\n+    }\n+#   else\n+        if (limit > stack_top && base < GC_stackbottom) {\n+    \t    /* Part of the stack; ignore it. */\n+    \t    return;\n+        }\n+        GC_add_roots_inner(base, limit, TRUE);\n+#   endif\n+  }\n+  \n+  extern GC_bool GC_win32s;\n+  \n+  void GC_register_dynamic_libraries()\n+  {\n+    MEMORY_BASIC_INFORMATION buf;\n+    SYSTEM_INFO sysinfo;\n+    DWORD result;\n+    DWORD protect;\n+    LPVOID p;\n+    char * base;\n+    char * limit, * new_limit;\n+    \n+    if (GC_win32s) return;\n+    GetSystemInfo(&sysinfo);\n+    base = limit = p = sysinfo.lpMinimumApplicationAddress;\n+    GC_allocation_granularity = sysinfo.dwAllocationGranularity;\n+    while (p < sysinfo.lpMaximumApplicationAddress) {\n+        result = VirtualQuery(p, &buf, sizeof(buf));\n+        if (result != sizeof(buf)) {\n+            ABORT(\"Weird VirtualQuery result\");\n+        }\n+        new_limit = (char *)p + buf.RegionSize;\n+        protect = buf.Protect;\n+        if (buf.State == MEM_COMMIT\n+            && (protect == PAGE_EXECUTE_READWRITE\n+                || protect == PAGE_READWRITE)\n+            && !GC_is_heap_base(buf.AllocationBase)) {\n+            if ((char *)p == limit) {\n+                limit = new_limit;\n+            } else {\n+                GC_cond_add_roots(base, limit);\n+                base = p;\n+                limit = new_limit;\n+            }\n+        }\n+        if (p > (LPVOID)new_limit /* overflow */) break;\n+        p = (LPVOID)new_limit;\n+    }\n+    GC_cond_add_roots(base, limit);\n+  }\n+\n+#endif /* MSWIN32 */\n+\n+#if defined(ALPHA) && defined(OSF1)\n+\n+#include <loader.h>\n+\n+void GC_register_dynamic_libraries()\n+{\n+  int status;\n+  ldr_process_t mypid;\n+\n+  /* module */\n+    ldr_module_t moduleid = LDR_NULL_MODULE;\n+    ldr_module_info_t moduleinfo;\n+    size_t moduleinfosize = sizeof(moduleinfo);\n+    size_t modulereturnsize;    \n+\n+  /* region */\n+    ldr_region_t region; \n+    ldr_region_info_t regioninfo;\n+    size_t regioninfosize = sizeof(regioninfo);\n+    size_t regionreturnsize;\n+\n+  /* Obtain id of this process */\n+    mypid = ldr_my_process();\n+  \n+  /* For each module */\n+    while (TRUE) {\n+\n+      /* Get the next (first) module */\n+        status = ldr_next_module(mypid, &moduleid);\n+\n+      /* Any more modules? */\n+        if (moduleid == LDR_NULL_MODULE)\n+            break;    /* No more modules */\n+\n+      /* Check status AFTER checking moduleid because */\n+      /* of a bug in the non-shared ldr_next_module stub */\n+        if (status != 0 ) {\n+            GC_printf1(\"dynamic_load: status = %ld\\n\", (long)status);\n+            {\n+                extern char *sys_errlist[];\n+                extern int sys_nerr;\n+                extern int errno;\n+                if (errno <= sys_nerr) {\n+                    GC_printf1(\"dynamic_load: %s\\n\", (long)sys_errlist[errno]);\n+               } else {\n+                    GC_printf1(\"dynamic_load: %d\\n\", (long)errno);\n+                }\n+        }\n+            ABORT(\"ldr_next_module failed\");\n+         }\n+\n+      /* Get the module information */\n+        status = ldr_inq_module(mypid, moduleid, &moduleinfo,\n+                                moduleinfosize, &modulereturnsize); \n+        if (status != 0 )\n+            ABORT(\"ldr_inq_module failed\");\n+\n+      /* is module for the main program (i.e. nonshared portion)? */\n+          if (moduleinfo.lmi_flags & LDR_MAIN)\n+              continue;    /* skip the main module */\n+\n+#     ifdef VERBOSE\n+          GC_printf(\"---Module---\\n\");\n+          GC_printf(\"Module ID            = %16ld\\n\", moduleinfo.lmi_modid);\n+          GC_printf(\"Count of regions     = %16d\\n\", moduleinfo.lmi_nregion);\n+          GC_printf(\"flags for module     = %16lx\\n\", moduleinfo.lmi_flags); \n+          GC_printf(\"pathname of module   = \\\"%s\\\"\\n\", moduleinfo.lmi_name);\n+#     endif\n+\n+      /* For each region in this module */\n+        for (region = 0; region < moduleinfo.lmi_nregion; region++) {\n+\n+          /* Get the region information */\n+            status = ldr_inq_region(mypid, moduleid, region, &regioninfo,\n+                                    regioninfosize, &regionreturnsize);\n+            if (status != 0 )\n+                ABORT(\"ldr_inq_region failed\");\n+\n+          /* only process writable (data) regions */\n+            if (! (regioninfo.lri_prot & LDR_W))\n+                continue;\n+\n+#         ifdef VERBOSE\n+              GC_printf(\"--- Region ---\\n\");\n+              GC_printf(\"Region number    = %16ld\\n\",\n+              \t        regioninfo.lri_region_no);\n+              GC_printf(\"Protection flags = %016x\\n\",  regioninfo.lri_prot);\n+              GC_printf(\"Virtual address  = %16p\\n\",   regioninfo.lri_vaddr);\n+              GC_printf(\"Mapped address   = %16p\\n\",   regioninfo.lri_mapaddr);\n+              GC_printf(\"Region size      = %16ld\\n\",  regioninfo.lri_size);\n+              GC_printf(\"Region name      = \\\"%s\\\"\\n\", regioninfo.lri_name);\n+#         endif\n+\n+          /* register region as a garbage collection root */\n+            GC_add_roots_inner (\n+                (char *)regioninfo.lri_mapaddr,\n+                (char *)regioninfo.lri_mapaddr + regioninfo.lri_size,\n+                TRUE);\n+\n+        }\n+    }\n+}\n+#endif\n+\n+#if defined(HP_PA)\n+\n+#include <errno.h>\n+#include <dl.h>\n+\n+extern int errno;\n+extern char *sys_errlist[];\n+extern int sys_nerr;\n+\n+void GC_register_dynamic_libraries()\n+{\n+  int status;\n+  int index = 1; /* Ordinal position in shared library search list */\n+  struct shl_descriptor *shl_desc; /* Shared library info, see dl.h */\n+\n+  /* For each dynamic library loaded */\n+    while (TRUE) {\n+\n+      /* Get info about next shared library */\n+        status = shl_get(index, &shl_desc);\n+\n+      /* Check if this is the end of the list or if some error occured */\n+        if (status != 0) {\n+          if (errno == EINVAL) {\n+              break; /* Moved past end of shared library list --> finished */\n+          } else {\n+              if (errno <= sys_nerr) {\n+                    GC_printf1(\"dynamic_load: %s\\n\", (long) sys_errlist[errno]);\n+              } else {\n+                    GC_printf1(\"dynamic_load: %d\\n\", (long) errno);\n+\t      }\n+              ABORT(\"shl_get failed\");\n+          }\n+        }\n+\n+#     ifdef VERBOSE\n+          GC_printf0(\"---Shared library---\\n\");\n+          GC_printf1(\"\\tfilename        = \\\"%s\\\"\\n\", shl_desc->filename);\n+          GC_printf1(\"\\tindex           = %d\\n\", index);\n+          GC_printf1(\"\\thandle          = %08x\\n\",\n+\t\t\t\t\t(unsigned long) shl_desc->handle);\n+          GC_printf1(\"\\ttext seg. start = %08x\\n\", shl_desc->tstart);\n+          GC_printf1(\"\\ttext seg. end   = %08x\\n\", shl_desc->tend);\n+          GC_printf1(\"\\tdata seg. start = %08x\\n\", shl_desc->dstart);\n+          GC_printf1(\"\\tdata seg. end   = %08x\\n\", shl_desc->dend);\n+          GC_printf1(\"\\tref. count      = %lu\\n\", shl_desc->ref_count);\n+#     endif\n+\n+      /* register shared library's data segment as a garbage collection root */\n+        GC_add_roots_inner((char *) shl_desc->dstart,\n+\t\t\t   (char *) shl_desc->dend, TRUE);\n+\n+        index++;\n+    }\n+}\n+#endif /* HP_PA */\n+\n+#ifdef RS6000\n+#pragma alloca\n+#include <sys/ldr.h>\n+#include <sys/errno.h>\n+void GC_register_dynamic_libraries()\n+{\n+\tint len;\n+\tchar *ldibuf;\n+\tint ldibuflen;\n+\tstruct ld_info *ldi;\n+\n+\tldibuf = alloca(ldibuflen = 8192);\n+\n+\twhile ( (len = loadquery(L_GETINFO,ldibuf,ldibuflen)) < 0) {\n+\t\tif (errno != ENOMEM) {\n+\t\t\tABORT(\"loadquery failed\");\n+\t\t}\n+\t\tldibuf = alloca(ldibuflen *= 2);\n+\t}\n+\n+\tldi = (struct ld_info *)ldibuf;\n+\twhile (ldi) {\n+\t\tlen = ldi->ldinfo_next;\n+\t\tGC_add_roots_inner(\n+\t\t\t\tldi->ldinfo_dataorg,\n+\t\t\t\t(unsigned long)ldi->ldinfo_dataorg\n+\t\t\t        + ldi->ldinfo_datasize,\n+\t\t\t\tTRUE);\n+\t\tldi = len ? (struct ld_info *)((char *)ldi + len) : 0;\n+\t}\n+}\n+#endif /* RS6000 */\n+\n+\n+\n+#else /* !DYNAMIC_LOADING */\n+\n+#ifdef PCR\n+\n+#   include \"il/PCR_IL.h\"\n+#   include \"th/PCR_ThCtl.h\"\n+#   include \"mm/PCR_MM.h\"\n+\n+void GC_register_dynamic_libraries()\n+{\n+    /* Add new static data areas of dynamically loaded modules.\t*/\n+        {\n+          PCR_IL_LoadedFile * p = PCR_IL_GetLastLoadedFile();\n+          PCR_IL_LoadedSegment * q;\n+          \n+          /* Skip uncommited files */\n+          while (p != NIL && !(p -> lf_commitPoint)) {\n+              /* The loading of this file has not yet been committed\t*/\n+              /* Hence its description could be inconsistent.  \t\t*/\n+              /* Furthermore, it hasn't yet been run.  Hence its data\t*/\n+              /* segments can't possibly reference heap allocated\t*/\n+              /* objects.\t\t\t\t\t\t*/\n+              p = p -> lf_prev;\n+          }\n+          for (; p != NIL; p = p -> lf_prev) {\n+            for (q = p -> lf_ls; q != NIL; q = q -> ls_next) {\n+              if ((q -> ls_flags & PCR_IL_SegFlags_Traced_MASK)\n+                  == PCR_IL_SegFlags_Traced_on) {\n+                GC_add_roots_inner\n+                \t((char *)(q -> ls_addr), \n+                \t (char *)(q -> ls_addr) + q -> ls_bytes,\n+                \t TRUE);\n+              }\n+            }\n+          }\n+        }\n+}\n+\n+\n+#else /* !PCR */\n+\n+void GC_register_dynamic_libraries(){}\n+\n+int GC_no_dynamic_loading;\n+\n+#endif /* !PCR */\n+#endif /* !DYNAMIC_LOADING */"}]}