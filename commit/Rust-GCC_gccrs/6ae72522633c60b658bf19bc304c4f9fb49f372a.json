{"sha": "6ae72522633c60b658bf19bc304c4f9fb49f372a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmFlNzI1MjI2MzNjNjBiNjU4YmYxOWJjMzA0YzRmOWZiNDlmMzcyYQ==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2006-09-27T07:08:13Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2006-09-27T07:08:13Z"}, "message": "re PR libstdc++/29217 (locale confusion with time/collate categories)\n\n2006-09-27  Paolo Carlini  <pcarlini@suse.de>\n\n\tPR libstdc++/29217\n\t* src/localename.cc (locale::_Impl::_M_replace_categories)):\n\tCompensate for the inconsistent numerical encodings of the\n\tcollate and time categories vs the corresponding names.\n\t* testsuite/22_locale/locale/cons/29217.cc: New.\n\n\t* testsuite/22_locale/locale/cons/2.cc: Enable and split\n\tout the few ENC_TRAITS bits to...\n\t* testsuite/22_locale/locale/cons/unicode/1.cc... here.\n\nFrom-SVN: r117247", "tree": {"sha": "79679cf8ed123d71683f6ad60841eb52eab0d5cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/79679cf8ed123d71683f6ad60841eb52eab0d5cd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6ae72522633c60b658bf19bc304c4f9fb49f372a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ae72522633c60b658bf19bc304c4f9fb49f372a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ae72522633c60b658bf19bc304c4f9fb49f372a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ae72522633c60b658bf19bc304c4f9fb49f372a/comments", "author": null, "committer": null, "parents": [{"sha": "2b655a0a4fd99d2221a05f5cb96740e78e4efdeb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b655a0a4fd99d2221a05f5cb96740e78e4efdeb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b655a0a4fd99d2221a05f5cb96740e78e4efdeb"}], "stats": {"total": 461, "additions": 296, "deletions": 165}, "files": [{"sha": "3964451e87d0213d82d879c4c220943825c54c67", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ae72522633c60b658bf19bc304c4f9fb49f372a/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ae72522633c60b658bf19bc304c4f9fb49f372a/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=6ae72522633c60b658bf19bc304c4f9fb49f372a", "patch": "@@ -1,3 +1,15 @@\n+2006-09-27  Paolo Carlini  <pcarlini@suse.de>\n+\n+\tPR libstdc++/29217\n+\t* src/localename.cc (locale::_Impl::_M_replace_categories)):\n+\tCompensate for the inconsistent numerical encodings of the\n+\tcollate and time categories vs the corresponding names.\n+\t* testsuite/22_locale/locale/cons/29217.cc: New.\n+\n+\t* testsuite/22_locale/locale/cons/2.cc: Enable and split\n+\tout the few ENC_TRAITS bits to...\n+\t* testsuite/22_locale/locale/cons/unicode/1.cc... here.\n+\n 2006-09-25  Howard Hinnant  <hhinnant@apple.com>\n \n \tPR libstdc++/29224"}, {"sha": "ff8c369ce118017d04ac9300b3e46380dfd9194b", "filename": "libstdc++-v3/src/localename.cc", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ae72522633c60b658bf19bc304c4f9fb49f372a/libstdc%2B%2B-v3%2Fsrc%2Flocalename.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ae72522633c60b658bf19bc304c4f9fb49f372a/libstdc%2B%2B-v3%2Fsrc%2Flocalename.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Flocalename.cc?ref=6ae72522633c60b658bf19bc304c4f9fb49f372a", "patch": "@@ -1,4 +1,4 @@\n-// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005\n+// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006\n // Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n@@ -288,13 +288,23 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t\t\tstd::memcpy(_M_names[__i], _M_names[0], __len);\n \t\t      }\n \t\t  }\n-\t\tchar* __src = __imp->_M_names[__ix] ? __imp->_M_names[__ix]\n-\t\t                                    : __imp->_M_names[0];\n+\n+\t\t// FIXME: Hack for libstdc++/29217: the numerical encodings\n+\t\t// of the time and collate categories are swapped vs the\n+\t\t// order of the names in locale::_S_categories.  We'd like to\n+\t\t// adjust the former (the latter is dictated by compatibility\n+\t\t// with glibc) but we can't for binary compatibility.\n+\t\tsize_t __ix_name = __ix;\n+\t\tif (__ix == 2 || __ix == 3)\n+\t\t  __ix_name = 5 - __ix;\n+\n+\t\tchar* __src = __imp->_M_names[__ix_name] ?\n+\t\t              __imp->_M_names[__ix_name] : __imp->_M_names[0];\n \t\tconst size_t __len = std::strlen(__src) + 1;\n \t\tchar* __new = new char[__len];\n \t\tstd::memcpy(__new, __src, __len);\n-\t\tdelete [] _M_names[__ix];\n-\t\t_M_names[__ix] = __new;\n+\t\tdelete [] _M_names[__ix_name];\n+\t\t_M_names[__ix_name] = __new;\n \t      }\n \t  }\n       }"}, {"sha": "9b2acb3645f00e792b254815b9092b0b243518c3", "filename": "libstdc++-v3/testsuite/22_locale/locale/cons/2.cc", "status": "modified", "additions": 73, "deletions": 160, "changes": 233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ae72522633c60b658bf19bc304c4f9fb49f372a/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Flocale%2Fcons%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ae72522633c60b658bf19bc304c4f9fb49f372a/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Flocale%2Fcons%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Flocale%2Fcons%2F2.cc?ref=6ae72522633c60b658bf19bc304c4f9fb49f372a", "patch": "@@ -2,7 +2,8 @@\n \n // 2000-09-13 Benjamin Kosnik <bkoz@redhat.com>\n \n-// Copyright (C) 2000, 2001, 2002, 2003, 2005 Free Software Foundation\n+// Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006\n+// Free Software Foundation\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -27,11 +28,11 @@\n #include <stdexcept>\n #include <testsuite_hooks.h>\n \n-#if _GLIBCXX_USE___ENC_TRAITS\n typedef std::codecvt<char, char, std::mbstate_t> \t      c_codecvt;\n-typedef std::codecvt_byname<char, char, std::mbstate_t>       c_codecvt_byname;\n+\n+#ifdef _GLIBCXX_USE_WCHAR_T\n typedef std::codecvt<wchar_t, char, std::mbstate_t>\t      w_codecvt;\n-typedef std::codecvt_byname<wchar_t, char, std::mbstate_t>    w_codecvt_byname;\n+#endif\n \n class gnu_codecvt: public c_codecvt { }; \n \n@@ -43,77 +44,10 @@ class gnu_facet: public std::locale::facet\n \n std::locale::id gnu_facet::id;\n \n-// Need some char_traits specializations for this to work.\n-typedef unsigned short\t\t\tunicode_t;\n-\n-namespace std\n-{\n-  template<>\n-    struct char_traits<unicode_t>\n-    {\n-      typedef unicode_t \tchar_type;\n-      // Unsigned as wint_t is unsigned.\n-      typedef unsigned long  \tint_type;\n-      typedef streampos \tpos_type;\n-      typedef streamoff \toff_type;\n-      typedef mbstate_t \tstate_type;\n-      \n-      static void \n-      assign(char_type& __c1, const char_type& __c2);\n-\n-      static bool \n-      eq(const char_type& __c1, const char_type& __c2);\n-\n-      static bool \n-      lt(const char_type& __c1, const char_type& __c2);\n-\n-      static int \n-      compare(const char_type* __s1, const char_type* __s2, size_t __n)\n-      { return memcmp(__s1, __s2, __n); }\n-\n-      static size_t\n-      length(const char_type* __s);\n-\n-      static const char_type* \n-      find(const char_type* __s, size_t __n, const char_type& __a);\n-\n-      static char_type* \n-      move(char_type* __s1, const char_type* __s2, size_t __n);\n-\n-      static char_type* \n-      copy(char_type* __s1, const char_type* __s2, size_t __n)\n-      { return static_cast<char_type*>(memcpy(__s1, __s2, __n)); }\n-\n-      static char_type* \n-      assign(char_type* __s, size_t __n, char_type __a);\n-\n-      static char_type \n-      to_char_type(const int_type& __c);\n-\n-      static int_type \n-      to_int_type(const char_type& __c);\n-\n-      static bool \n-      eq_int_type(const int_type& __c1, const int_type& __c2);\n-\n-      static int_type \n-      eof(); \n-\n-      static int_type \n-      not_eof(const int_type& __c);\n-    };\n-}\n-\n void test01()\n {\n   using namespace std;\n-  typedef unicode_t\t\t\t\tint_type;\n-  typedef char\t\t\t\t\text_type;\n-  typedef __enc_traits\t\t\t\tenc_type;\n-  typedef codecvt<int_type, ext_type, enc_type>\tunicode_codecvt;\n-\n   bool test __attribute__((unused)) = true;\n-  string str1, str2;\n \n   // construct a locale object with the C facet\n   const locale\tloc01 = locale::classic();\n@@ -122,13 +56,15 @@ void test01()\n   // template <class Facet> locale(const locale& other, Facet* f)\n   // construct a locale object with the specialized facet.\n   locale loc02(locale::classic(), new gnu_codecvt);\n-  VERIFY (loc01 != loc02);\n-  VERIFY (loc02.name() == \"*\");\n+  VERIFY( loc01 != loc02 );\n+  VERIFY( loc02.name() == \"*\" );\n   try\n     {\n-      VERIFY (has_facet<gnu_codecvt>(loc02));\n-      VERIFY (has_facet<c_codecvt>(loc02));\n-      VERIFY (has_facet<w_codecvt>(loc02));\n+      VERIFY( has_facet<gnu_codecvt>(loc02) );\n+      VERIFY( has_facet<c_codecvt>(loc02) );\n+#ifdef _GLIBCXX_USE_WCHAR_T\n+      VERIFY( has_facet<w_codecvt>(loc02) );\n+#endif\n     }\n   catch(...)\n     { VERIFY( false ); }\n@@ -140,161 +76,138 @@ void test01()\n   catch(...)\n     { VERIFY( false ); }\n \n-  // unicode_codecvt\n-  locale loc13(locale::classic(), new unicode_codecvt);  \n-  VERIFY (loc01 != loc13);\n-  VERIFY (loc13.name() == \"*\");\n-  try \n-    {\n-      VERIFY (has_facet<c_codecvt>(loc13));\n-      VERIFY (has_facet<w_codecvt>(loc13));\n-      VERIFY (has_facet<unicode_codecvt>(loc13));\n-    }\n-  catch(...)\n-    { VERIFY( false ); }\n-\n-  try \n-    { use_facet<gnu_facet>(loc13); }\n-  catch(bad_cast& obj)\n-    { VERIFY( true ); }\n-  catch(...)\n-    { VERIFY( false ); }\n-\n   // 2\n   // locale() throw()\n   locale loc03;\n-  VERIFY (loc03 == loc01);\n-  VERIFY (loc03.name() == \"C\");\n+  VERIFY( loc03 == loc01 );\n+  VERIFY( loc03.name() == \"C\" );\n   locale loc04 = locale::global(loc02);\n   locale loc05;\n-  VERIFY (loc05 != loc03);\n-  VERIFY (loc05 == loc02);\n+  VERIFY( loc05 != loc03 );\n+  VERIFY( loc05 == loc02 );\n \n   // 3\n   // explicit locale(const char* std_name)\n   locale loc06 = locale(\"fr_FR\");\n-  VERIFY (loc06 != loc01);  \n-  VERIFY (loc06 != loc02);  \n-  VERIFY (loc06.name() == \"fr_FR\");\n+  VERIFY( loc06 != loc01 );  \n+  VERIFY( loc06 != loc02 );  \n+  VERIFY( loc06.name() == \"fr_FR\");\n   locale loc07(\"\");\n-  VERIFY (loc07 != loc02);  \n-  VERIFY (loc07.name() != \"\");\n+  VERIFY( loc07 != loc02 );  \n+  VERIFY( loc07.name() != \"\" );\n   try\n     { locale loc08(static_cast<const char*>(NULL)); }\n   catch(runtime_error& obj)\n-    { VERIFY (true); }\n+    { VERIFY( true ); }\n   catch(...)\n-    { VERIFY (false); }\n+    { VERIFY( false ); }\n \n   try\n     { locale loc08(\"saturn_SUN*RA\"); }\n   catch(runtime_error& obj)\n-    { VERIFY (true); }\n+    { VERIFY( true ); }\n   catch(...)\n-    { VERIFY (false); }\n+    { VERIFY( false ); }\n \n   // 4\n   // locale(const locale& other, const char* std_name, category)\n   {\n     // This is the same as 5 only use \"C\" for loc(\"C\")\n     locale loc09(loc06, \"C\", locale::ctype);\n-    VERIFY (loc09.name() != \"fr_FR\");\n-    VERIFY (loc09.name() != \"C\");\n-    VERIFY (loc09.name() != \"*\");\n-    VERIFY (loc09 != loc01);  \n-    VERIFY (loc09 != loc06);  \n+    VERIFY( loc09.name() != \"fr_FR\" );\n+    VERIFY( loc09.name() != \"C\" );\n+    VERIFY( loc09.name() != \"*\" );\n+    VERIFY( loc09 != loc01 );  \n+    VERIFY( loc09 != loc06 );\n \n     locale loc10(loc02, \"C\", locale::ctype);\n-    VERIFY (loc10.name() == \"*\");\n-    VERIFY (loc10 != loc01);   // As not named, even tho facets same...\n-    VERIFY (loc10 != loc02);  \n+    VERIFY( loc10.name() == \"*\" );\n+    VERIFY( loc10 != loc01 );   // As not named, even tho facets same...\n+    VERIFY( loc10 != loc02 );\n \n     locale loc11(loc01, \"C\", locale::ctype);\n-    VERIFY (loc11.name() == \"C\");\n-    VERIFY (loc11 == loc01);  \n+    VERIFY( loc11.name() == \"C\" );\n+    VERIFY( loc11 == loc01 );  \n \n     try\n       { locale loc12(loc01, static_cast<const char*>(NULL), locale::ctype); }\n     catch(runtime_error& obj)\n-      { VERIFY (true); }\n+      { VERIFY( true ); }\n     catch(...)\n-      { VERIFY (false); }\n+      { VERIFY( false ); }\n \n     try\n       { locale loc13(loc01, \"localized by the wu-tang clan\", locale::ctype); }\n     catch(runtime_error& obj)\n-      { VERIFY (true); }\n+      { VERIFY( true ); }\n     catch(...)\n-      { VERIFY (false); }\n+      { VERIFY( false ); }\n \n     locale loc14(loc06, \"C\", locale::none);\n-    VERIFY (loc14.name() == \"fr_FR\");\n-    VERIFY (loc14 == loc06);  \n-\n-    locale loc15(loc06, \"C\", locale::collate);\n-    VERIFY (loc15.name() != \"fr_FR\");\n-    VERIFY (loc15.name() != \"C\");\n-    VERIFY (loc15.name() != \"*\");\n-    VERIFY (loc15.name() != loc09.name());\n-    VERIFY (loc15 != loc01);  \n-    VERIFY (loc15 != loc06);  \n-    VERIFY (loc15 != loc09);  \n+    VERIFY( loc14.name() == \"fr_FR\" );\n+    VERIFY( loc14 == loc06 );\n+\n+    locale loc15(loc06, \"C\", locale::collate );\n+    VERIFY( loc15.name() != \"fr_FR\" );\n+    VERIFY( loc15.name() != \"C\" );\n+    VERIFY( loc15.name() != \"*\" );\n+    VERIFY( loc15.name() != loc09.name() );\n+    VERIFY( loc15 != loc01 );  \n+    VERIFY( loc15 != loc06 );  \n+    VERIFY( loc15 != loc09 );  \n   }\n \n   // 5\n   // locale(const locale& other, const locale& one, category)\n   {\n     // This is the exact same as 4, with locale(\"C\") for \"C\"\n     locale loc09(loc06, loc01, locale::ctype);\n-    VERIFY (loc09.name() != \"fr_FR\");\n-    VERIFY (loc09.name() != \"C\");\n-    VERIFY (loc09.name() != \"*\");\n-    VERIFY (loc09 != loc01);  \n-    VERIFY (loc09 != loc06);  \n+    VERIFY( loc09.name() != \"fr_FR\" );\n+    VERIFY( loc09.name() != \"C\" );\n+    VERIFY( loc09.name() != \"*\" );\n+    VERIFY( loc09 != loc01 );\n+    VERIFY( loc09 != loc06 );\n \n     locale loc10(loc02, loc01, locale::ctype);\n-    VERIFY (loc10.name() == \"*\");\n-    VERIFY (loc10 != loc01);   // As not named, even tho facets same...\n-    VERIFY (loc10 != loc02);  \n+    VERIFY( loc10.name() == \"*\" );\n+    VERIFY( loc10 != loc01 );   // As not named, even tho facets same...\n+    VERIFY( loc10 != loc02 );  \n \n     locale loc11(loc01, loc01, locale::ctype);\n-    VERIFY (loc11.name() == \"C\");\n-    VERIFY (loc11 == loc01);  \n+    VERIFY( loc11.name() == \"C\" );\n+    VERIFY( loc11 == loc01 );\n \n     try\n       { locale loc12(loc01, static_cast<const char*>(NULL), locale::ctype); }\n     catch(runtime_error& obj)\n-      { VERIFY (true); }\n+      { VERIFY( true ); }\n     catch(...)\n-      { VERIFY (false); }\n+      { VERIFY( false ); }\n \n     try\n       { locale loc13(loc01, locale(\"wu-tang clan\"), locale::ctype); }\n     catch(runtime_error& obj)\n-      { VERIFY (true); }\n+      { VERIFY( true ); }\n     catch(...)\n-      { VERIFY (false); }\n+      { VERIFY( false ); }\n \n     locale loc14(loc06, loc01, locale::none);\n-    VERIFY (loc14.name() == \"fr_FR\");\n-    VERIFY (loc14 == loc06);  \n+    VERIFY( loc14.name() == \"fr_FR\" );\n+    VERIFY( loc14 == loc06 );\n \n     locale loc15(loc06, loc01, locale::collate);\n-    VERIFY (loc15.name() != \"fr_FR\");\n-    VERIFY (loc15.name() != \"C\");\n-    VERIFY (loc15.name() != \"*\");\n-    VERIFY (loc15.name() != loc09.name());\n-    VERIFY (loc15 != loc01);  \n-    VERIFY (loc15 != loc06);  \n-    VERIFY (loc15 != loc09);  \n+    VERIFY( loc15.name() != \"fr_FR\" );\n+    VERIFY( loc15.name() != \"C\" );\n+    VERIFY( loc15.name() != \"*\" );\n+    VERIFY( loc15.name() != loc09.name() );\n+    VERIFY( loc15 != loc01 );\n+    VERIFY( loc15 != loc06 );  \n+    VERIFY( loc15 != loc09 );  \n   }\n }\n-#endif // _GLIBCXX_USE___ENC_TRAITS\n \n int main()\n {\n-#if _GLIBCXX_USE___ENC_TRAITS\n   test01();\n-#endif \n   return 0;\n }"}, {"sha": "182080f3a0987845b4ec6e350b0f3a4206bfd41c", "filename": "libstdc++-v3/testsuite/22_locale/locale/cons/29217.cc", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ae72522633c60b658bf19bc304c4f9fb49f372a/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Flocale%2Fcons%2F29217.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ae72522633c60b658bf19bc304c4f9fb49f372a/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Flocale%2Fcons%2F29217.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Flocale%2Fcons%2F29217.cc?ref=6ae72522633c60b658bf19bc304c4f9fb49f372a", "patch": "@@ -0,0 +1,54 @@\n+// { dg-require-namedlocale \"\" }\n+\n+// Copyright (C) 2006 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 22.1.1.2 locale constructors and destructors [lib.locale.cons]\n+\n+#include <locale>\n+#include <testsuite_hooks.h>\n+\n+// libstdc++/29217\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using namespace std;\n+\n+  locale::global(locale(locale(), \"en_US.UTF-8\",\n+\t\t\tlocale::collate | locale::ctype));\n+\n+  VERIFY( locale().name() == \"LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;\"\n+\t  \"LC_TIME=C;LC_COLLATE=en_US.UTF-8;LC_MONETARY=C;LC_MESSAGES=C;\"\n+\t  \"LC_PAPER=C;LC_NAME=C;LC_ADDRESS=C;LC_TELEPHONE=C;\"\n+\t  \"LC_MEASUREMENT=C;LC_IDENTIFICATION=C\" );\n+\n+  VERIFY( locale().name() == setlocale(LC_ALL, NULL) );\n+\n+  locale loc1 = locale(locale::classic(), \"en_US.UTF-8\", locale::time);\n+\n+  VERIFY( loc1.name() == \"LC_CTYPE=C;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;\"\n+\t  \"LC_COLLATE=C;LC_MONETARY=C;LC_MESSAGES=C;LC_PAPER=C;LC_NAME=C;\"\n+\t  \"LC_ADDRESS=C;LC_TELEPHONE=C;LC_MEASUREMENT=C;\"\n+\t  \"LC_IDENTIFICATION=C\" );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "02ef036a282c82cc0e71224dcb489a7f2aac185c", "filename": "libstdc++-v3/testsuite/22_locale/locale/cons/unicode/1.cc", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ae72522633c60b658bf19bc304c4f9fb49f372a/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Flocale%2Fcons%2Funicode%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ae72522633c60b658bf19bc304c4f9fb49f372a/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Flocale%2Fcons%2Funicode%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Flocale%2Fcons%2Funicode%2F1.cc?ref=6ae72522633c60b658bf19bc304c4f9fb49f372a", "patch": "@@ -0,0 +1,142 @@\n+// Copyright (C) 2006 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 22.1.1.2 locale constructors and destructors [lib.locale.cons]\n+\n+#include <cwchar> // for mbstate_t\n+#include <locale>\n+#include <stdexcept>\n+#include <testsuite_hooks.h>\n+\n+#if _GLIBCXX_USE___ENC_TRAITS\n+typedef std::codecvt<char, char, std::mbstate_t> \t      c_codecvt;\n+\n+#ifdef _GLIBCXX_USE_WCHAR_T\n+typedef std::codecvt<wchar_t, char, std::mbstate_t>\t      w_codecvt;\n+#endif\n+\n+class gnu_facet: public std::locale::facet\n+{\n+public:\n+  static std::locale::id id;\n+};\n+\n+std::locale::id gnu_facet::id;\n+\n+// Need some char_traits specializations for this to work.\n+typedef unsigned short\t\t\tunicode_t;\n+\n+namespace std\n+{\n+  template<>\n+    struct char_traits<unicode_t>\n+    {\n+      typedef unicode_t \tchar_type;\n+      // Unsigned as wint_t is unsigned.\n+      typedef unsigned long  \tint_type;\n+      typedef streampos \tpos_type;\n+      typedef streamoff \toff_type;\n+      typedef mbstate_t \tstate_type;\n+      \n+      static void \n+      assign(char_type& __c1, const char_type& __c2);\n+\n+      static bool \n+      eq(const char_type& __c1, const char_type& __c2);\n+\n+      static bool \n+      lt(const char_type& __c1, const char_type& __c2);\n+\n+      static int \n+      compare(const char_type* __s1, const char_type* __s2, size_t __n)\n+      { return memcmp(__s1, __s2, __n); }\n+\n+      static size_t\n+      length(const char_type* __s);\n+\n+      static const char_type* \n+      find(const char_type* __s, size_t __n, const char_type& __a);\n+\n+      static char_type* \n+      move(char_type* __s1, const char_type* __s2, size_t __n);\n+\n+      static char_type* \n+      copy(char_type* __s1, const char_type* __s2, size_t __n)\n+      { return static_cast<char_type*>(memcpy(__s1, __s2, __n)); }\n+\n+      static char_type* \n+      assign(char_type* __s, size_t __n, char_type __a);\n+\n+      static char_type \n+      to_char_type(const int_type& __c);\n+\n+      static int_type \n+      to_int_type(const char_type& __c);\n+\n+      static bool \n+      eq_int_type(const int_type& __c1, const int_type& __c2);\n+\n+      static int_type \n+      eof(); \n+\n+      static int_type \n+      not_eof(const int_type& __c);\n+    };\n+}\n+\n+void test01()\n+{\n+  using namespace std;\n+  typedef unicode_t\t\t\t\tint_type;\n+  typedef char\t\t\t\t\text_type;\n+  typedef __enc_traits\t\t\t\tenc_type;\n+  typedef codecvt<int_type, ext_type, enc_type>\tunicode_codecvt;\n+\n+  bool test __attribute__((unused)) = true;\n+\n+  // unicode_codecvt\n+  locale loc13(locale::classic(), new unicode_codecvt);  \n+  VERIFY( loc01 != loc13 );\n+  VERIFY( loc13.name() == \"*\" );\n+  try \n+    {\n+      VERIFY( has_facet<c_codecvt>(loc13) );\n+#ifdef _GLIBCXX_USE_WCHAR_T\n+      VERIFY( has_facet<w_codecvt>(loc13) );\n+#endif\n+      VERIFY( has_facet<unicode_codecvt>(loc13) );\n+    }\n+  catch(...)\n+    { VERIFY( false ); }\n+\n+  try \n+    { use_facet<gnu_facet>(loc13); }\n+  catch(bad_cast& obj)\n+    { VERIFY( true ); }\n+  catch(...)\n+    { VERIFY( false ); }\n+}\n+#endif // _GLIBCXX_USE___ENC_TRAITS\n+\n+int main()\n+{\n+#if _GLIBCXX_USE___ENC_TRAITS\n+  test01();\n+#endif \n+  return 0;\n+}"}]}