{"sha": "e02c8dffe35f2763ec42a4ca5b2cf1af11f8e5d6", "node_id": "C_kwDOANBUbNoAKGUwMmM4ZGZmZTM1ZjI3NjNlYzQyYTRjYTViMmNmMWFmMTFmOGU1ZDY", "commit": {"author": {"name": "Steve Baird", "email": "baird@adacore.com", "date": "2021-08-12T23:55:36Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-10-01T06:13:39Z"}, "message": "[Ada] Improved checking for invalid index values when accessing array elements\n\ngcc/ada/\n\n\t* checks.ads: Define a type Dimension_Set. Add an out-mode\n\tparameter of this new type to Generate_Index_Checks so that\n\tcallers can know for which dimensions a check was generated. Add\n\tan in-mode parameter of this new type to\n\tApply_Subscript_Validity_Checks so that callers can indicate\n\tthat no check is needed for certain dimensions.\n\t* checks.adb (Generate_Index_Checks): Implement new\n\tChecks_Generated parameter.\n\t(Apply_Subscript_Validity_Checks): Implement new No_Check_Needed\n\tparameter.\n\t* exp_ch4.adb (Expand_N_Indexed_Component): Call\n\tApply_Subscript_Validity_Checks in more cases than before. This\n\tincludes declaring two new local functions,\n\t(Is_Renamed_Variable_Name,\n\tType_Requires_Subscript_Validity_Checks_For_Reads): To help in\n\tdeciding whether to call Apply_Subscript_Validity_Checks.\n\tAdjust to parameter profile changes in Generate_Index_Checks and\n\tApply_Subscript_Validity_Checks.", "tree": {"sha": "209c121d9f5ff39ec2a959de3bba42f8f63402dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/209c121d9f5ff39ec2a959de3bba42f8f63402dd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e02c8dffe35f2763ec42a4ca5b2cf1af11f8e5d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e02c8dffe35f2763ec42a4ca5b2cf1af11f8e5d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e02c8dffe35f2763ec42a4ca5b2cf1af11f8e5d6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e02c8dffe35f2763ec42a4ca5b2cf1af11f8e5d6/comments", "author": {"login": "swbaird", "id": 50751052, "node_id": "MDQ6VXNlcjUwNzUxMDUy", "avatar_url": "https://avatars.githubusercontent.com/u/50751052?v=4", "gravatar_id": "", "url": "https://api.github.com/users/swbaird", "html_url": "https://github.com/swbaird", "followers_url": "https://api.github.com/users/swbaird/followers", "following_url": "https://api.github.com/users/swbaird/following{/other_user}", "gists_url": "https://api.github.com/users/swbaird/gists{/gist_id}", "starred_url": "https://api.github.com/users/swbaird/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/swbaird/subscriptions", "organizations_url": "https://api.github.com/users/swbaird/orgs", "repos_url": "https://api.github.com/users/swbaird/repos", "events_url": "https://api.github.com/users/swbaird/events{/privacy}", "received_events_url": "https://api.github.com/users/swbaird/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f5d4b3fbf62a4c49d5951fc7848127af32876b78", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5d4b3fbf62a4c49d5951fc7848127af32876b78", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5d4b3fbf62a4c49d5951fc7848127af32876b78"}], "stats": {"total": 200, "additions": 189, "deletions": 11}, "files": [{"sha": "3b61208270d5388cfee2ffd0e47038ac6d9f89f6", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e02c8dffe35f2763ec42a4ca5b2cf1af11f8e5d6/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e02c8dffe35f2763ec42a4ca5b2cf1af11f8e5d6/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=e02c8dffe35f2763ec42a4ca5b2cf1af11f8e5d6", "patch": "@@ -3552,9 +3552,12 @@ package body Checks is\n    -- Apply_Subscript_Validity_Checks --\n    -------------------------------------\n \n-   procedure Apply_Subscript_Validity_Checks (Expr : Node_Id) is\n+   procedure Apply_Subscript_Validity_Checks\n+     (Expr            : Node_Id;\n+      No_Check_Needed : Dimension_Set := Empty_Dimension_Set) is\n       Sub : Node_Id;\n \n+      Dimension : Pos := 1;\n    begin\n       pragma Assert (Nkind (Expr) = N_Indexed_Component);\n \n@@ -3568,11 +3571,16 @@ package body Checks is\n          --  for the subscript, and that convert will do the necessary validity\n          --  check.\n \n-         Ensure_Valid (Sub, Holes_OK => True);\n+         if (No_Check_Needed = Empty_Dimension_Set)\n+           or else not No_Check_Needed.Elements (Dimension)\n+         then\n+            Ensure_Valid (Sub, Holes_OK => True);\n+         end if;\n \n          --  Move to next subscript\n \n          Next (Sub);\n+         Dimension := Dimension + 1;\n       end loop;\n    end Apply_Subscript_Validity_Checks;\n \n@@ -7233,7 +7241,10 @@ package body Checks is\n    -- Generate_Index_Checks --\n    ---------------------------\n \n-   procedure Generate_Index_Checks (N : Node_Id) is\n+   procedure Generate_Index_Checks\n+     (N                : Node_Id;\n+      Checks_Generated : out Dimension_Set)\n+   is\n \n       function Entity_Of_Prefix return Entity_Id;\n       --  Returns the entity of the prefix of N (or Empty if not found)\n@@ -7268,6 +7279,8 @@ package body Checks is\n    --  Start of processing for Generate_Index_Checks\n \n    begin\n+      Checks_Generated.Elements := (others => False);\n+\n       --  Ignore call if the prefix is not an array since we have a serious\n       --  error in the sources. Ignore it also if index checks are suppressed\n       --  for array object or type.\n@@ -7330,6 +7343,8 @@ package body Checks is\n                          Prefix         => New_Occurrence_Of (Etype (A), Loc),\n                          Attribute_Name => Name_Range)),\n                 Reason => CE_Index_Check_Failed));\n+\n+            Checks_Generated.Elements (1) := True;\n          end if;\n \n       --  General case\n@@ -7416,6 +7431,8 @@ package body Checks is\n                                Duplicate_Subexpr_Move_Checks (Sub)),\n                            Right_Opnd => Range_N),\n                       Reason => CE_Index_Check_Failed));\n+\n+                  Checks_Generated.Elements (Ind) := True;\n                end if;\n \n                Next_Index (A_Idx);"}, {"sha": "6df752ffc148c77e34eeaa4c7602257ed621cdfc", "filename": "gcc/ada/checks.ads", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e02c8dffe35f2763ec42a4ca5b2cf1af11f8e5d6/gcc%2Fada%2Fchecks.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e02c8dffe35f2763ec42a4ca5b2cf1af11f8e5d6/gcc%2Fada%2Fchecks.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.ads?ref=e02c8dffe35f2763ec42a4ca5b2cf1af11f8e5d6", "patch": "@@ -44,6 +44,14 @@ with Urealp; use Urealp;\n \n package Checks is\n \n+   type Bit_Vector is array (Pos range <>) of Boolean;\n+   type Dimension_Set (Dimensions : Nat) is\n+      record\n+         Elements : Bit_Vector (1 .. Dimensions);\n+      end record;\n+   Empty_Dimension_Set : constant Dimension_Set\n+     := (Dimensions => 0, Elements => (others => <>));\n+\n    procedure Initialize;\n    --  Called for each new main source program, to initialize internal\n    --  variables used in the package body of the Checks unit.\n@@ -721,11 +729,16 @@ package Checks is\n    --  Do_Range_Check flag, and if it is set, this routine is called, which\n    --  turns the flag off in code-generation mode.\n \n-   procedure Generate_Index_Checks (N : Node_Id);\n+   procedure Generate_Index_Checks\n+     (N                : Node_Id;\n+      Checks_Generated : out Dimension_Set);\n    --  This procedure is called to generate index checks on the subscripts for\n    --  the indexed component node N. Each subscript expression is examined, and\n    --  if the Do_Range_Check flag is set, an appropriate index check is\n    --  generated and the flag is reset.\n+   --  The out-mode parameter Checks_Generated indicates the dimensions for\n+   --  which checks were generated. Checks_Generated.Dimensions must match\n+   --  the number of dimensions of the array type.\n \n    --  Similarly, we set the flag Do_Discriminant_Check in the semantic\n    --  analysis to indicate that a discriminant check is required for selected\n@@ -858,10 +871,14 @@ package Checks is\n \n    --  The following procedures are used in handling validity checking\n \n-   procedure Apply_Subscript_Validity_Checks (Expr : Node_Id);\n+   procedure Apply_Subscript_Validity_Checks\n+     (Expr            : Node_Id;\n+      No_Check_Needed : Dimension_Set := Empty_Dimension_Set);\n    --  Expr is the node for an indexed component. If validity checking and\n-   --  range checking are enabled, all subscripts for this indexed component\n-   --  are checked for validity.\n+   --  range checking are enabled, each subscript for this indexed component\n+   --  whose dimension does not belong to the No_Check_Needed set is checked\n+   --  for validity. No_Check_Needed.Dimensions must match the number of\n+   --  dimensions of the array type or be zero.\n \n    procedure Check_Valid_Lvalue_Subscripts (Expr : Node_Id);\n    --  Expr is a lvalue, i.e. an expression representing the target of an"}, {"sha": "b899c2c7abb73496228934e2a1ef0c7e23444014", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 148, "deletions": 4, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e02c8dffe35f2763ec42a4ca5b2cf1af11f8e5d6/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e02c8dffe35f2763ec42a4ca5b2cf1af11f8e5d6/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=e02c8dffe35f2763ec42a4ca5b2cf1af11f8e5d6", "patch": "@@ -23,6 +23,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Aspects;        use Aspects;\n with Atree;          use Atree;\n with Checks;         use Checks;\n with Debug;          use Debug;\n@@ -7087,11 +7088,123 @@ package body Exp_Ch4 is\n    --------------------------------\n \n    procedure Expand_N_Indexed_Component (N : Node_Id) is\n+\n+      Wild_Reads_May_Have_Bad_Side_Effects : Boolean\n+        renames Validity_Check_Subscripts;\n+      --  This Boolean needs to be True if reading from a bad address can\n+      --  have a bad side effect (e.g., a segmentation fault that is not\n+      --  transformed into a Storage_Error exception, or interactions with\n+      --  memory-mapped I/O) that needs to be prevented. This refers to the\n+      --  act of reading itself, not to any damage that might be caused later\n+      --  by making use of whatever value was read. We assume here that\n+      --  Validity_Check_Subscripts meets this requirement, but introduce\n+      --  this declaration in order to document this assumption.\n+\n+      function Is_Renamed_Variable_Name (N : Node_Id) return Boolean;\n+      --  Returns True if the given name occurs as part of the renaming\n+      --  of a variable. In this case, the indexing operation should be\n+      --  treated as a write, rather than a read, with respect to validity\n+      --  checking. This is because the renamed variable can later be\n+      --  written to.\n+\n+      function Type_Requires_Subscript_Validity_Checks_For_Reads\n+        (Typ : Entity_Id) return Boolean;\n+      --  If Wild_Reads_May_Have_Bad_Side_Effects is False and we are indexing\n+      --  into an array of characters in order to read an element, it is ok\n+      --  if an invalid index value goes undetected. But if it is an array of\n+      --  pointers or an array of tasks, the consequences of such a read are\n+      --  potentially more severe and so we want to detect an invalid index\n+      --  value. This function captures that distinction; this is intended to\n+      --  be consistent with the \"but does not by itself lead to erroneous\n+      --  ... execution\" rule of RM 13.9.1(11).\n+\n+      ------------------------------\n+      -- Is_Renamed_Variable_Name --\n+      ------------------------------\n+\n+      function Is_Renamed_Variable_Name (N : Node_Id) return Boolean is\n+         Rover : Node_Id := N;\n+      begin\n+         if Is_Variable (N) then\n+            loop\n+               declare\n+                  Rover_Parent : constant Node_Id := Parent (Rover);\n+               begin\n+                  case Nkind (Rover_Parent) is\n+                     when N_Object_Renaming_Declaration =>\n+                        return Rover = Name (Rover_Parent);\n+\n+                     when N_Indexed_Component\n+                        | N_Slice\n+                        | N_Selected_Component\n+                     =>\n+                        exit when Rover /= Prefix (Rover_Parent);\n+                        Rover := Rover_Parent;\n+\n+                     --  No need to check for qualified expressions or type\n+                     --  conversions here, mostly because of the Is_Variable\n+                     --  test. It is possible to have a view conversion for\n+                     --  which Is_Variable yields True and which occurs as\n+                     --  part of an object renaming, but only if the type is\n+                     --  tagged; in that case this function will not be called.\n+\n+                     when others =>\n+                        exit;\n+                  end case;\n+               end;\n+            end loop;\n+         end if;\n+         return False;\n+      end Is_Renamed_Variable_Name;\n+\n+      -------------------------------------------------------\n+      -- Type_Requires_Subscript_Validity_Checks_For_Reads --\n+      -------------------------------------------------------\n+\n+      function Type_Requires_Subscript_Validity_Checks_For_Reads\n+        (Typ : Entity_Id) return Boolean\n+      is\n+         --  a shorter name for recursive calls\n+         function Needs_Check (Typ : Entity_Id) return Boolean renames\n+           Type_Requires_Subscript_Validity_Checks_For_Reads;\n+      begin\n+         if Is_Access_Type (Typ)\n+           or else Is_Tagged_Type (Typ)\n+           or else Is_Concurrent_Type (Typ)\n+           or else (Is_Array_Type (Typ)\n+                     and then Needs_Check (Component_Type (Typ)))\n+           or else (Is_Scalar_Type (Typ)\n+                     and then Has_Aspect (Typ, Aspect_Default_Value))\n+         then\n+            return True;\n+         end if;\n+\n+         if Is_Record_Type (Typ) then\n+            declare\n+               Comp : Entity_Id := First_Component_Or_Discriminant (Typ);\n+            begin\n+               while Present (Comp) loop\n+                  if Needs_Check (Etype (Comp)) then\n+                     return True;\n+                  end if;\n+\n+                  Next_Component_Or_Discriminant (Comp);\n+               end loop;\n+            end;\n+         end if;\n+\n+         return False;\n+      end Type_Requires_Subscript_Validity_Checks_For_Reads;\n+\n+      --  Local constants\n+\n       Loc : constant Source_Ptr := Sloc (N);\n       Typ : constant Entity_Id  := Etype (N);\n       P   : constant Node_Id    := Prefix (N);\n       T   : constant Entity_Id  := Etype (P);\n \n+   --  Start of processing for Expand_N_Indexed_Component\n+\n    begin\n       --  A special optimization, if we have an indexed component that is\n       --  selecting from a slice, then we can eliminate the slice, since, for\n@@ -7141,11 +7254,42 @@ package body Exp_Ch4 is\n \n       --  Generate index and validity checks\n \n-      Generate_Index_Checks (N);\n+      declare\n+         Dims_Checked : Dimension_Set (Dimensions => Number_Dimensions (T));\n+         --  Dims_Checked is used to avoid generating two checks (one in\n+         --  Generate_Index_Checks, one in Apply_Subscript_Validity_Checks)\n+         --  for the same index value in cases where the index check eliminates\n+         --  the need for the validity check.\n \n-      if Validity_Checks_On and then Validity_Check_Subscripts then\n-         Apply_Subscript_Validity_Checks (N);\n-      end if;\n+      begin\n+         Generate_Index_Checks (N, Checks_Generated => Dims_Checked);\n+\n+         if Validity_Checks_On\n+           and then (Validity_Check_Subscripts\n+                      or else Wild_Reads_May_Have_Bad_Side_Effects\n+                      or else Type_Requires_Subscript_Validity_Checks_For_Reads\n+                                (Typ)\n+                      or else Is_Renamed_Variable_Name (N))\n+         then\n+            if Validity_Check_Subscripts then\n+               --  If we index into an array with an uninitialized variable\n+               --  and we generate an index check that passes at run time,\n+               --  passing that check does not ensure that the variable is\n+               --  valid (although it does in the common case where the\n+               --  object's subtype matches the index subtype).\n+               --  Consider an uninitialized variable with subtype 1 .. 10\n+               --  used to index into an array with bounds 1 .. 20 when the\n+               --  value of the uninitialized variable happens to be 15.\n+               --  The index check will succeed but the variable is invalid.\n+               --  If Validity_Check_Subscripts is True then we need to\n+               --  ensure validity, so we adjust Dims_Checked accordingly.\n+               Dims_Checked.Elements := (others => False);\n+            end if;\n+\n+            Apply_Subscript_Validity_Checks\n+              (N, No_Check_Needed => Dims_Checked);\n+         end if;\n+      end;\n \n       --  If selecting from an array with atomic components, and atomic sync\n       --  is not suppressed for this array type, set atomic sync flag."}]}