{"sha": "93e79ed391b9c636f087e6eb7e70f14963cd10ad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTNlNzllZDM5MWI5YzYzNmYwODdlNmViN2U3MGYxNDk2M2NkMTBhZA==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-11-03T18:44:32Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-11-03T18:44:49Z"}, "message": "libstdc++: Rewrite std::call_once to use futexes [PR 66146]\n\nThe current implementation of std::call_once uses pthread_once, which\nonly meets the C++ requirements when compiled with support for\nexceptions. For most glibc targets and all non-glibc targets,\npthread_once does not work correctly if the init_routine exits via an\nexception. The pthread_once_t object is left in the \"active\" state, and\nany later attempts to run another init_routine will block forever.\n\nThis change makes std::call_once work correctly for Linux targets, by\nreplacing the use of pthread_once with a futex, based on the code from\n__cxa_guard_acquire. For both glibc and musl, the Linux implementation\nof pthread_once is already based on futexes, and pthread_once_t is just\na typedef for int, so this change does not alter the layout of\nstd::once_flag. By choosing the values for the int appropriately, the\nnew code is even ABI compatible. Code that calls the old implementation\nof std::call_once will use pthread_once to manipulate the int, while new\ncode will use the new std::once_flag members to manipulate it, but they\nshould interoperate correctly. In both cases, the int is initially zero,\nhas the lowest bit set when there is an active execution, and equals 2\nafter a successful returning execution. The difference with the new code\nis that exceptional exceptions are correctly detected and the int is\nreset to zero.\n\nThe __cxa_guard_acquire code (and musl's pthread_once) use an additional\nstate to say there are other threads waiting. This allows the futex wake\nsyscall to be skipped if there is no contention. Glibc doesn't use a\nwaiter bit, so we have to unconditionally issue the wake in order to be\ncompatible with code calling the old std::call_once that uses Glibc's\npthread_once. If we know that we're using musl (and musl's pthread_once\ndoesn't change) it would be possible to set a waiting state and check\nfor it in std::once_flag::_M_finish(bool), but this patch doesn't do\nthat.\n\nThis doesn't fix the bug for non-linux targets. A similar approach could\nbe used for targets where we know the definition of pthread_once_t is a\nmutex and an integer. We could make once_flag._M_activate() use\npthread_mutex_lock on the mutex member within the pthread_once_t, and\nthen only set the integer if the execution finishes, and then unlock the\nmutex. That would require careful study of each target's pthread_once\nimplementation and that work is left for a later date.\n\nThis also fixes PR 55394 because pthread_once is no longer needed, and\nPR 84323 because the fast path is now just an atomic load.\n\nAs a consequence of the new implementation that doesn't use\npthread_once, we can also make std::call_once work for targets with no\ngthreads support. The code for the single-threaded implementation\nfollows the same methods as on Linux, but with no need for atomics or\nfutexes.\n\nlibstdc++-v3/ChangeLog:\n\n\tPR libstdc++/55394\n\tPR libstdc++/66146\n\tPR libstdc++/84323\n\t* config/abi/pre/gnu.ver (GLIBCXX_3.4.29): Add new symbols.\n\t* include/std/mutex [!_GLIBCXX_HAS_GTHREADS] (once_flag): Define\n\teven when gthreads is not supported.\n\t(once_flag::_M_once) [_GLIBCXX_HAVE_LINUX_FUTEX]: Change type\n\tfrom __gthread_once_t to int.\n\t(once_flag::_M_passive(), once_flag::_M_activate())\n\t(once_flag::_M_finish(bool), once_flag::_Active_execution):\n\tDefine new members for futex and non-threaded implementation.\n\t[_GLIBCXX_HAS_GTHREADS] (once_flag::_Prepare_execution): New\n\tRAII helper type.\n\t(call_once): Use new members of once_flag.\n\t* src/c++11/mutex.cc (std::once_flag::_M_activate): Define.\n\t(std::once_flag::_M_finish): Define.\n\t* testsuite/30_threads/call_once/39909.cc: Do not require\n\tgthreads.\n\t* testsuite/30_threads/call_once/49668.cc: Likewise.\n\t* testsuite/30_threads/call_once/60497.cc: Likewise.\n\t* testsuite/30_threads/call_once/call_once1.cc: Likewise.\n\t* testsuite/30_threads/call_once/dr2442.cc: Likewise.\n\t* testsuite/30_threads/call_once/once_flag.cc: Add test for\n\tconstexpr constructor.\n\t* testsuite/30_threads/call_once/66146.cc: New test.\n\t* testsuite/30_threads/call_once/constexpr.cc: Removed.\n\t* testsuite/30_threads/once_flag/cons/constexpr.cc: Removed.", "tree": {"sha": "0fa5e6acd613c68c2c0b7d7e164e3d050bbba0be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0fa5e6acd613c68c2c0b7d7e164e3d050bbba0be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/93e79ed391b9c636f087e6eb7e70f14963cd10ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93e79ed391b9c636f087e6eb7e70f14963cd10ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93e79ed391b9c636f087e6eb7e70f14963cd10ad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93e79ed391b9c636f087e6eb7e70f14963cd10ad/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a52bf016433154c61d1cab3fd3d9e17b1bb330f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a52bf016433154c61d1cab3fd3d9e17b1bb330f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a52bf016433154c61d1cab3fd3d9e17b1bb330f0"}], "stats": {"total": 364, "additions": 274, "deletions": 90}, "files": [{"sha": "707539a17c3a3b151fd8858e28f87b5aaca5aee1", "filename": "libstdc++-v3/config/abi/pre/gnu.ver", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93e79ed391b9c636f087e6eb7e70f14963cd10ad/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93e79ed391b9c636f087e6eb7e70f14963cd10ad/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver?ref=93e79ed391b9c636f087e6eb7e70f14963cd10ad", "patch": "@@ -2371,6 +2371,11 @@ GLIBCXX_3.4.29 {\n     # basic_stringstream::view()\n     _ZNKSt7__cxx1118basic_stringstreamI[cw]St11char_traitsI[cw]ESaI[cw]EE4viewEv;\n \n+    # std::once_flag::_M_activate()\n+    _ZNSt9once_flag11_M_activateEv;\n+    # std::once_flag::_M_finish(bool)\n+    _ZNSt9once_flag9_M_finishEb;\n+\n } GLIBCXX_3.4.28;\n \n # Symbols in the support library (libsupc++) have their own tag."}, {"sha": "92ad7b7b6622218dd9854ea47b1ff01e1bb248eb", "filename": "libstdc++-v3/include/std/mutex", "status": "modified", "additions": 164, "deletions": 36, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93e79ed391b9c636f087e6eb7e70f14963cd10ad/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmutex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93e79ed391b9c636f087e6eb7e70f14963cd10ad/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmutex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmutex?ref=93e79ed391b9c636f087e6eb7e70f14963cd10ad", "patch": "@@ -46,8 +46,10 @@\n # include <condition_variable>\n # include <thread>\n #endif\n-#ifndef _GLIBCXX_HAVE_TLS\n-# include <bits/std_function.h>\n+#include <ext/atomicity.h>     // __gnu_cxx::__is_single_threaded\n+\n+#if defined _GLIBCXX_HAS_GTHREADS && ! defined _GLIBCXX_HAVE_TLS\n+# include <bits/std_function.h>  // std::function\n #endif\n \n namespace std _GLIBCXX_VISIBILITY(default)\n@@ -667,82 +669,208 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     };\n #endif // C++17\n \n-#ifdef _GLIBCXX_HAS_GTHREADS\n   /// Flag type used by std::call_once\n   struct once_flag\n   {\n-  private:\n-    typedef __gthread_once_t __native_type;\n-    __native_type  _M_once = __GTHREAD_ONCE_INIT;\n-\n-  public:\n-    /// Constructor\n     constexpr once_flag() noexcept = default;\n \n     /// Deleted copy constructor\n     once_flag(const once_flag&) = delete;\n     /// Deleted assignment operator\n     once_flag& operator=(const once_flag&) = delete;\n \n+  private:\n+    // There are two different std::once_flag interfaces, abstracting four\n+    // different implementations.\n+    // The preferred interface uses the _M_activate() and _M_finish(bool)\n+    // member functions (introduced in GCC 11), which start and finish an\n+    // active execution respectively. See [thread.once.callonce] in C++11\n+    // for the definition of active/passive/returning/exceptional executions.\n+    // This interface is supported for Linux (using atomics and futexes) and\n+    // for single-threaded targets with no gthreads support.\n+    // For other targets a pthread_once_t is used with pthread_once, but that\n+    // doesn't work correctly for exceptional executions. That interface\n+    // uses an object of type _Prepare_execution and a lambda expression.\n+#if defined _GLIBCXX_HAVE_LINUX_FUTEX || ! defined _GLIBCXX_HAS_GTHREADS\n+    enum _Bits : int { _Init = 0, _Active = 1, _Done = 2 };\n+\n+    int _M_once = _Bits::_Init;\n+\n+    // Non-blocking check to see if all executions will be passive now.\n+    bool\n+    _M_passive() const noexcept;\n+\n+    // Attempts to begin an active execution. Blocks until it either:\n+    // - returns true if an active execution has started on this thread, or\n+    // - returns false if a returning execution happens on another thread.\n+    bool _M_activate();\n+\n+    // Must be called to complete an active execution.\n+    void _M_finish(bool __returning) noexcept;\n+\n+    // RAII helper to call _M_finish.\n+    struct _Active_execution\n+    {\n+      explicit _Active_execution(once_flag& __flag) : _M_flag(__flag) { }\n+\n+      ~_Active_execution() { _M_flag._M_finish(_M_returning); }\n+\n+      _Active_execution(const _Active_execution&) = delete;\n+      _Active_execution& operator=(const _Active_execution&) = delete;\n+\n+      once_flag& _M_flag;\n+      bool _M_returning = false;\n+    };\n+#else\n+    __gthread_once_t _M_once = __GTHREAD_ONCE_INIT;\n+\n+    struct _Prepare_execution;\n+#endif // ! GTHREADS\n+\n     template<typename _Callable, typename... _Args>\n       friend void\n       call_once(once_flag& __once, _Callable&& __f, _Args&&... __args);\n   };\n \n+#if ! defined _GLIBCXX_HAS_GTHREADS\n+  // Inline definitions of std::once_flag members for single-threaded targets.\n+\n+  inline bool\n+  once_flag::_M_passive() const noexcept\n+  { return _M_once == _Bits::_Done; }\n+\n+  inline bool\n+  once_flag::_M_activate()\n+  {\n+    if (_M_once == _Bits::_Init)\n+      {\n+\t_M_once = _Bits::_Active;\n+\treturn true;\n+      }\n+    else if (!_M_passive())\n+      __throw_system_error(EDEADLK);\n+  }\n+\n+  inline void\n+  once_flag::_M_finish(bool returning) noexcept\n+  { _M_once = returning ? _Bits::_Done : _Bits::_Init; }\n+\n+#elif defined _GLIBCXX_HAVE_LINUX_FUTEX\n+\n+  // Define this inline to make passive executions fast.\n+  inline bool\n+  once_flag::_M_passive() const noexcept\n+  {\n+    if (__gnu_cxx::__is_single_threaded())\n+      return _M_once == _Bits::_Done;\n+    else\n+      return __atomic_load_n(&_M_once, __ATOMIC_ACQUIRE) == _Bits::_Done;\n+  }\n+\n+#else // GTHREADS && ! FUTEX\n+\n   /// @cond undocumented\n-#ifdef _GLIBCXX_HAVE_TLS\n+# ifdef _GLIBCXX_HAVE_TLS\n+  // If TLS is available use thread-local state for the type-erased callable\n+  // that is being run by std::call_once in the current thread.\n   extern __thread void* __once_callable;\n   extern __thread void (*__once_call)();\n-#else\n+# else\n+  // Without TLS use a global std::mutex and store the callable in a\n+  // global std::function.\n   extern function<void()> __once_functor;\n \n   extern void\n   __set_once_functor_lock_ptr(unique_lock<mutex>*);\n \n   extern mutex&\n   __get_once_mutex();\n-#endif\n+# endif\n \n+  // This function is passed to pthread_once by std::call_once.\n+  // It runs __once_call() or __once_functor().\n   extern \"C\" void __once_proxy(void);\n+\n+  // RAII type to set up state for pthread_once call.\n+  struct once_flag::_Prepare_execution\n+  {\n+#ifdef _GLIBCXX_HAVE_TLS\n+    template<typename _Callable>\n+      explicit\n+      _Prepare_execution(_Callable& __c)\n+      {\n+\t// Store address in thread-local pointer:\n+\t__once_callable = std::__addressof(__c);\n+\t// Trampoline function to invoke the closure via thread-local pointer:\n+\t__once_call = [] { (*static_cast<_Callable*>(__once_callable))(); };\n+      }\n+\n+    ~_Prepare_execution()\n+    {\n+      // PR libstdc++/82481\n+      __once_callable = nullptr;\n+      __once_call = nullptr;\n+    }\n+#else // ! TLS\n+    template<typename _Callable>\n+      explicit\n+      _Prepare_execution(_Callable& __c)\n+      {\n+\t// Store the callable in the global std::function\n+\t__once_functor = __c;\n+\t__set_once_functor_lock_ptr(&_M_functor_lock);\n+      }\n+\n+    ~_Prepare_execution()\n+    {\n+      if (_M_functor_lock)\n+\t__set_once_functor_lock_ptr(nullptr);\n+    }\n+\n+  private:\n+    unique_lock<mutex> _M_functor_lock{__get_once_mutex()};\n+#endif // ! TLS\n+\n+    _Prepare_execution(const _Prepare_execution&) = delete;\n+    _Prepare_execution& operator=(const _Prepare_execution&) = delete;\n+  };\n   /// @endcond\n+#endif\n \n   /// Invoke a callable and synchronize with other calls using the same flag\n   template<typename _Callable, typename... _Args>\n     void\n     call_once(once_flag& __once, _Callable&& __f, _Args&&... __args)\n     {\n-      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n-      // 2442. call_once() shouldn't DECAY_COPY()\n+#if defined _GLIBCXX_HAVE_LINUX_FUTEX || ! defined _GLIBCXX_HAS_GTHREADS\n+      if (__once._M_passive())\n+\treturn;\n+      else if (__once._M_activate())\n+\t{\n+\t  once_flag::_Active_execution __exec(__once);\n+\n+\t  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+\t  // 2442. call_once() shouldn't DECAY_COPY()\n+\t  std::__invoke(std::forward<_Callable>(__f),\n+\t\t\tstd::forward<_Args>(__args)...);\n+\n+\t  // __f(__args...) did not throw\n+\t  __exec._M_returning = true;\n+\t}\n+#else\n+      // Closure type that runs the function\n       auto __callable = [&] {\n \t  std::__invoke(std::forward<_Callable>(__f),\n \t\t\tstd::forward<_Args>(__args)...);\n       };\n-#ifdef _GLIBCXX_HAVE_TLS\n-      __once_callable = std::__addressof(__callable);\n-      __once_call = []{ (*(decltype(__callable)*)__once_callable)(); };\n-#else\n-      unique_lock<mutex> __functor_lock(__get_once_mutex());\n-      __once_functor = __callable;\n-      __set_once_functor_lock_ptr(&__functor_lock);\n-#endif\n-\n-      int __e = __gthread_once(&__once._M_once, &__once_proxy);\n \n-#ifndef _GLIBCXX_HAVE_TLS\n-      if (__functor_lock)\n-        __set_once_functor_lock_ptr(0);\n-#endif\n+      once_flag::_Prepare_execution __exec(__callable);\n \n-#ifdef __clang_analyzer__\n-      // PR libstdc++/82481\n-      __once_callable = nullptr;\n-      __once_call = nullptr;\n-#endif\n-\n-      if (__e)\n+      // XXX pthread_once does not reset the flag if an exception is thrown.\n+      if (int __e = __gthread_once(&__once._M_once, &__once_proxy))\n \t__throw_system_error(__e);\n+#endif\n     }\n-#endif // _GLIBCXX_HAS_GTHREADS\n \n   // @} group mutexes\n _GLIBCXX_END_NAMESPACE_VERSION"}, {"sha": "286f77f9a4544d169d93041911b4617e7fafbfb3", "filename": "libstdc++-v3/src/c++11/mutex.cc", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93e79ed391b9c636f087e6eb7e70f14963cd10ad/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fmutex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93e79ed391b9c636f087e6eb7e70f14963cd10ad/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fmutex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fmutex.cc?ref=93e79ed391b9c636f087e6eb7e70f14963cd10ad", "patch": "@@ -25,6 +25,65 @@\n #include <mutex>\n \n #ifdef _GLIBCXX_HAS_GTHREADS\n+\n+#ifdef _GLIBCXX_HAVE_LINUX_FUTEX\n+#include <syscall.h>\n+#include <unistd.h>\n+#include <limits.h>\n+\n+bool\n+std::once_flag::_M_activate()\n+{\n+  if (__gnu_cxx::__is_single_threaded())\n+    {\n+      if (_M_once == _Bits::_Done)\n+\treturn false;\n+      _M_once = _Bits::_Active;\n+      return true;\n+    }\n+\n+  while (true)\n+    {\n+      int expected = _Bits::_Init;\n+      constexpr int active = _Bits::_Active;\n+      if (__atomic_compare_exchange_n(&_M_once, &expected, active, false,\n+\t\t\t\t\t    __ATOMIC_ACQ_REL,\n+\t\t\t\t\t    __ATOMIC_ACQUIRE))\n+\t{\n+\t  // This thread is now doing an active execution.\n+\t  return true;\n+\t}\n+\n+      if (expected == _Bits::_Done)\n+\treturn false; // A returning execution happened, this is passive.\n+\n+      // Otherwise, an active execution is happening. Wait for it to finish.\n+      constexpr int futex_wait = 128; // FUTEX_WAIT_PRIVATE\n+      syscall (SYS_futex, &_M_once, futex_wait, expected, 0);\n+    }\n+}\n+\n+void\n+std::once_flag::_M_finish(bool returning) noexcept\n+{\n+  const int newval = returning ? _Bits::_Done : _Bits::_Init;\n+  if (__gnu_cxx::__is_single_threaded())\n+    {\n+      __glibcxx_assert(_M_once == _Bits::_Active);\n+      _M_once = newval;\n+    }\n+  else\n+    {\n+      int prev = __atomic_exchange_n(&_M_once, newval, __ATOMIC_RELEASE);\n+      __glibcxx_assert(prev & _Bits::_Active);\n+      // Wake any other threads waiting for this execution to finish.\n+      constexpr int futex_wake = 129; // FUTEX_WAKE_PRIVATE\n+      syscall (SYS_futex, &_M_once, futex_wake, INT_MAX);\n+    }\n+}\n+\n+#endif // ! FUTEX\n+\n #ifndef _GLIBCXX_HAVE_TLS\n namespace\n {"}, {"sha": "56568ebd154adc665eb7d720f6ab3b8126a64365", "filename": "libstdc++-v3/testsuite/30_threads/call_once/39909.cc", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93e79ed391b9c636f087e6eb7e70f14963cd10ad/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fcall_once%2F39909.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93e79ed391b9c636f087e6eb7e70f14963cd10ad/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fcall_once%2F39909.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fcall_once%2F39909.cc?ref=93e79ed391b9c636f087e6eb7e70f14963cd10ad", "patch": "@@ -1,6 +1,5 @@\n-// { dg-do run }\n+// { dg-do run { target c++11 } }\n // { dg-additional-options \"-pthread\" { target pthread } }\n-// { dg-require-effective-target c++11 }\n // { dg-require-gthreads \"\" }\n \n // Copyright (C) 2009-2020 Free Software Foundation, Inc."}, {"sha": "8fab7c2258617424e0c3e78492b06e8f31feffd9", "filename": "libstdc++-v3/testsuite/30_threads/call_once/49668.cc", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93e79ed391b9c636f087e6eb7e70f14963cd10ad/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fcall_once%2F49668.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93e79ed391b9c636f087e6eb7e70f14963cd10ad/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fcall_once%2F49668.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fcall_once%2F49668.cc?ref=93e79ed391b9c636f087e6eb7e70f14963cd10ad", "patch": "@@ -1,7 +1,5 @@\n-// { dg-do run }\n+// { dg-do run { target c++11 } }\n // { dg-additional-options \"-pthread\" { target pthread } }\n-// { dg-require-effective-target c++11 }\n-// { dg-require-gthreads \"\" }\n \n // Copyright (C) 2011-2020 Free Software Foundation, Inc.\n //"}, {"sha": "a2c7567b5059195e34ecacaac48eba9d0cf5211f", "filename": "libstdc++-v3/testsuite/30_threads/call_once/60497.cc", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93e79ed391b9c636f087e6eb7e70f14963cd10ad/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fcall_once%2F60497.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93e79ed391b9c636f087e6eb7e70f14963cd10ad/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fcall_once%2F60497.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fcall_once%2F60497.cc?ref=93e79ed391b9c636f087e6eb7e70f14963cd10ad", "patch": "@@ -1,7 +1,5 @@\n-// { dg-do compile }\n+// { dg-do compile { target c++11 } }\n // { dg-additional-options \"-pthread\" { target pthread } }\n-// { dg-require-effective-target c++11 }\n-// { dg-require-gthreads \"\" }\n \n // Copyright (C) 2014-2020 Free Software Foundation, Inc.\n //"}, {"sha": "b1ca0eb6fe8f2f89ed1a451888f84dd58fb66f7f", "filename": "libstdc++-v3/testsuite/30_threads/call_once/66146.cc", "status": "renamed", "additions": 31, "deletions": 9, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93e79ed391b9c636f087e6eb7e70f14963cd10ad/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fcall_once%2F66146.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93e79ed391b9c636f087e6eb7e70f14963cd10ad/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fcall_once%2F66146.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fcall_once%2F66146.cc?ref=93e79ed391b9c636f087e6eb7e70f14963cd10ad", "patch": "@@ -1,7 +1,4 @@\n-// { dg-do compile { target c++11 } }\n-// { dg-require-gthreads \"\" }\n-\n-// Copyright (C) 2010-2020 Free Software Foundation, Inc.\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -18,12 +15,37 @@\n // with this library; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n+// { dg-do run { target c++11 } }\n+// { dg-skip-if \"\" { pthread && { ! *-*-*linux* } } }\n+// { dg-additional-options \"-pthread\" { target pthread } }\n+\n #include <mutex>\n-#include <testsuite_common_types.h>\n+#include <cstdlib>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  std::once_flag once;\n+  int counter = 0;\n+  for (int i = 0; i < 10; ++i)\n+  {\n+    try\n+    {\n+      std::call_once(once, [&]{ if (i < 3) throw i; ++counter; });\n+      VERIFY(i >= 3);\n+    }\n+    catch (int ex)\n+    {\n+      VERIFY(i < 3);\n+    }\n+  }\n+ VERIFY(counter == 1);\n+ std::call_once(once, []{ std::abort(); });\n+}\n \n-int main()\n+int\n+main()\n {\n-  __gnu_test::constexpr_default_constructible test;\n-  test.operator()<std::mutex>();\n-  return 0;\n+  test01();\n }", "previous_filename": "libstdc++-v3/testsuite/30_threads/call_once/constexpr.cc"}, {"sha": "d9b6729f6b6b8302c82c010a86883a53c7e276a9", "filename": "libstdc++-v3/testsuite/30_threads/call_once/call_once1.cc", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93e79ed391b9c636f087e6eb7e70f14963cd10ad/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fcall_once%2Fcall_once1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93e79ed391b9c636f087e6eb7e70f14963cd10ad/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fcall_once%2Fcall_once1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fcall_once%2Fcall_once1.cc?ref=93e79ed391b9c636f087e6eb7e70f14963cd10ad", "patch": "@@ -1,7 +1,5 @@\n-// { dg-do run }\n+// { dg-do run { target c++11 } }\n // { dg-additional-options \"-pthread\" { target pthread } }\n-// { dg-require-effective-target c++11 }\n-// { dg-require-gthreads \"\" }\n \n // Copyright (C) 2008-2020 Free Software Foundation, Inc.\n //\n@@ -35,7 +33,7 @@ void add_to_value(int i)\n \n int main()\n {\n-  try \n+  try\n     {\n       std::call_once(value_flag, add_to_value, 2);\n       std::call_once(value_flag, add_to_value, 2);"}, {"sha": "61f5cc09ba84ce40b8824c412b542c336e5e70a4", "filename": "libstdc++-v3/testsuite/30_threads/call_once/dr2442.cc", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93e79ed391b9c636f087e6eb7e70f14963cd10ad/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fcall_once%2Fdr2442.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93e79ed391b9c636f087e6eb7e70f14963cd10ad/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fcall_once%2Fdr2442.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fcall_once%2Fdr2442.cc?ref=93e79ed391b9c636f087e6eb7e70f14963cd10ad", "patch": "@@ -1,7 +1,5 @@\n-// { dg-do run }\n+// { dg-do run { target c++11 } }\n // { dg-additional-options \"-pthread\" { target pthread } }\n-// { dg-require-effective-target c++11 }\n-// { dg-require-gthreads \"\" }\n \n // Copyright (C) 2016-2020 Free Software Foundation, Inc.\n //"}, {"sha": "f6e1607276f4f2a4371d553b1292514d175b4998", "filename": "libstdc++-v3/testsuite/30_threads/call_once/once_flag.cc", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93e79ed391b9c636f087e6eb7e70f14963cd10ad/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fcall_once%2Fonce_flag.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93e79ed391b9c636f087e6eb7e70f14963cd10ad/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fcall_once%2Fonce_flag.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fcall_once%2Fonce_flag.cc?ref=93e79ed391b9c636f087e6eb7e70f14963cd10ad", "patch": "@@ -1,5 +1,4 @@\n // { dg-do compile { target c++11 } }\n-// { dg-require-gthreads \"\" }\n \n // Copyright (C) 2008-2020 Free Software Foundation, Inc.\n //\n@@ -20,8 +19,17 @@\n \n \n #include <mutex>\n+#include <testsuite_common_types.h>\n \n void test01()\n {\n+  static_assert( std::is_default_constructible<std::once_flag>::value, \"\");\n+\n   std::once_flag once_flag;\n }\n+\n+void test02()\n+{\n+  __gnu_test::constexpr_default_constructible test;\n+  test.operator()<std::once_flag>();\n+}"}, {"sha": "a356e8c58bc231f0f7ab07123ed6b2135bfb43b0", "filename": "libstdc++-v3/testsuite/30_threads/once_flag/cons/constexpr.cc", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a52bf016433154c61d1cab3fd3d9e17b1bb330f0/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fonce_flag%2Fcons%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a52bf016433154c61d1cab3fd3d9e17b1bb330f0/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fonce_flag%2Fcons%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fonce_flag%2Fcons%2Fconstexpr.cc?ref=a52bf016433154c61d1cab3fd3d9e17b1bb330f0", "patch": "@@ -1,29 +0,0 @@\n-// { dg-do compile { target c++11 } }\n-// { dg-require-gthreads \"\" }\n-\n-// Copyright (C) 2010-2020 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 3, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING3.  If not see\n-// <http://www.gnu.org/licenses/>.\n-\n-#include <mutex>\n-#include <testsuite_common_types.h>\n-\n-int main()\n-{\n-  __gnu_test::constexpr_default_constructible test;\n-  test.operator()<std::once_flag>();\n-  return 0;\n-}"}]}