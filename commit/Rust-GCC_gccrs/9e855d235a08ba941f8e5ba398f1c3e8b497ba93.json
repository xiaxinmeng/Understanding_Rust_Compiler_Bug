{"sha": "9e855d235a08ba941f8e5ba398f1c3e8b497ba93", "node_id": "C_kwDOANBUbNoAKDllODU1ZDIzNWEwOGJhOTQxZjhlNWJhMzk4ZjFjM2U4YjQ5N2JhOTM", "commit": {"author": {"name": "Bill Schmidt", "email": "wschmidt@linux.ibm.com", "date": "2021-12-14T19:30:22Z"}, "committer": {"name": "Bill Schmidt", "email": "wschmidt@linux.ibm.com", "date": "2021-12-14T21:41:57Z"}, "message": "rs6000: Remove rs6000-builtin.def and associated data and functions\n\n2021-12-02  Bill Schmidt  <wschmidt@linux.ibm.com>\n\ngcc/\n\t* config/rs6000/rs6000-builtin.def: Delete.\n\t* config/rs6000/rs6000-call.c (builtin_compatibility): Delete.\n\t(builtin_description): Delete.\n\t(builtin_hash_struct): Delete.\n\t(builtin_hasher): Delete.\n\t(builtin_hash_table): Delete.\n\t(builtin_hasher::hash): Delete.\n\t(builtin_hasher::equal): Delete.\n\t(rs6000_builtin_info_type): Delete.\n\t(rs6000_builtin_info): Delete.\n\t(bdesc_compat): Delete.\n\t(bdesc_3arg): Delete.\n\t(bdesc_4arg): Delete.\n\t(bdesc_dst): Delete.\n\t(bdesc_2arg): Delete.\n\t(bdesc_altivec_preds): Delete.\n\t(bdesc_abs): Delete.\n\t(bdesc_1arg): Delete.\n\t(bdesc_0arg): Delete.\n\t(bdesc_htm): Delete.\n\t(bdesc_mma): Delete.\n\t(rs6000_overloaded_builtin_p): Delete.\n\t(rs6000_overloaded_builtin_name): Delete.\n\t(htm_spr_num): Delete.\n\t(rs6000_builtin_is_supported_p): Delete.\n\t(rs6000_gimple_fold_mma_builtin): Delete.\n\t(gt-rs6000-call.h): Remove include directive.\n\t* config/rs6000/rs6000-protos.h (rs6000_overloaded_builtin_p): Delete.\n\t(rs6000_builtin_is_supported_p): Delete.\n\t(rs6000_overloaded_builtin_name): Delete.\n\t* config/rs6000/rs6000.c (rs6000_builtin_decls): Delete.\n\t(rs6000_debug_reg_global): Remove reference to RS6000_BUILTIN_COUNT.\n\t* config/rs6000/rs6000.h (rs6000_builtins): Delete.\n\t(altivec_builtin_types): Delete.\n\t(rs6000_builtin_decls): Delete.\n\t* config/rs6000/t-rs6000 (TM_H): Don't add rs6000-builtin.def.", "tree": {"sha": "62ce251f6e71a7d0ad218912958b1601fd569160", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/62ce251f6e71a7d0ad218912958b1601fd569160"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9e855d235a08ba941f8e5ba398f1c3e8b497ba93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e855d235a08ba941f8e5ba398f1c3e8b497ba93", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e855d235a08ba941f8e5ba398f1c3e8b497ba93", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e855d235a08ba941f8e5ba398f1c3e8b497ba93/comments", "author": null, "committer": null, "parents": [{"sha": "97912187624f711e905e1b9c4c353b4ae9ddd4d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97912187624f711e905e1b9c4c353b4ae9ddd4d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97912187624f711e905e1b9c4c353b4ae9ddd4d7"}], "stats": {"total": 4126, "additions": 0, "deletions": 4126}, "files": [{"sha": "9dbf16f48c40afcb65aafb99d25ef1073caac06d", "filename": "gcc/config/rs6000/rs6000-builtin.def", "status": "removed", "additions": 0, "deletions": 3350, "changes": 3350, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97912187624f711e905e1b9c4c353b4ae9ddd4d7/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97912187624f711e905e1b9c4c353b4ae9ddd4d7/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def?ref=97912187624f711e905e1b9c4c353b4ae9ddd4d7"}, {"sha": "594d09eef358dc648a86a86d7faf7f1a05e3d1b1", "filename": "gcc/config/rs6000/rs6000-call.c", "status": "modified", "additions": 0, "deletions": 712, "changes": 712, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e855d235a08ba941f8e5ba398f1c3e8b497ba93/gcc%2Fconfig%2Frs6000%2Frs6000-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e855d235a08ba941f8e5ba398f1c3e8b497ba93/gcc%2Fconfig%2Frs6000%2Frs6000-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-call.c?ref=9e855d235a08ba941f8e5ba398f1c3e8b497ba93", "patch": "@@ -89,20 +89,6 @@\n #define TARGET_NO_PROTOTYPE 0\n #endif\n \n-struct builtin_compatibility\n-{\n-  const enum rs6000_builtins code;\n-  const char *const name;\n-};\n-\n-struct builtin_description\n-{\n-  const HOST_WIDE_INT mask;\n-  const enum insn_code icode;\n-  const char *const name;\n-  const enum rs6000_builtins code;\n-};\n-\n /* Used by __builtin_cpu_is(), mapping from PLATFORM names to values.  */\n static const struct\n {\n@@ -184,127 +170,6 @@ static const struct\n \n static rtx rs6000_expand_new_builtin (tree, rtx, rtx, machine_mode, int);\n static bool rs6000_gimple_fold_new_builtin (gimple_stmt_iterator *gsi);\n-\n-\n-/* Hash table to keep track of the argument types for builtin functions.  */\n-\n-struct GTY((for_user)) builtin_hash_struct\n-{\n-  tree type;\n-  machine_mode mode[4];\t/* return value + 3 arguments.  */\n-  unsigned char uns_p[4];\t/* and whether the types are unsigned.  */\n-};\n-\n-struct builtin_hasher : ggc_ptr_hash<builtin_hash_struct>\n-{\n-  static hashval_t hash (builtin_hash_struct *);\n-  static bool equal (builtin_hash_struct *, builtin_hash_struct *);\n-};\n-\n-static GTY (()) hash_table<builtin_hasher> *builtin_hash_table;\n-\n-/* Hash function for builtin functions with up to 3 arguments and a return\n-   type.  */\n-hashval_t\n-builtin_hasher::hash (builtin_hash_struct *bh)\n-{\n-  unsigned ret = 0;\n-  int i;\n-\n-  for (i = 0; i < 4; i++)\n-    {\n-      ret = (ret * (unsigned)MAX_MACHINE_MODE) + ((unsigned)bh->mode[i]);\n-      ret = (ret * 2) + bh->uns_p[i];\n-    }\n-\n-  return ret;\n-}\n-\n-/* Compare builtin hash entries H1 and H2 for equivalence.  */\n-bool\n-builtin_hasher::equal (builtin_hash_struct *p1, builtin_hash_struct *p2)\n-{\n-  return ((p1->mode[0] == p2->mode[0])\n-\t  && (p1->mode[1] == p2->mode[1])\n-\t  && (p1->mode[2] == p2->mode[2])\n-\t  && (p1->mode[3] == p2->mode[3])\n-\t  && (p1->uns_p[0] == p2->uns_p[0])\n-\t  && (p1->uns_p[1] == p2->uns_p[1])\n-\t  && (p1->uns_p[2] == p2->uns_p[2])\n-\t  && (p1->uns_p[3] == p2->uns_p[3]));\n-}\n-\n-\f\n-/* Table that classifies rs6000 builtin functions (pure, const, etc.).  */\n-#undef RS6000_BUILTIN_0\n-#undef RS6000_BUILTIN_1\n-#undef RS6000_BUILTIN_2\n-#undef RS6000_BUILTIN_3\n-#undef RS6000_BUILTIN_4\n-#undef RS6000_BUILTIN_A\n-#undef RS6000_BUILTIN_D\n-#undef RS6000_BUILTIN_H\n-#undef RS6000_BUILTIN_M\n-#undef RS6000_BUILTIN_P\n-#undef RS6000_BUILTIN_X\n-\n-#define RS6000_BUILTIN_0(ENUM, NAME, MASK, ATTR, ICODE) \\\n-  { NAME, ICODE, MASK, ATTR },\n-\n-#define RS6000_BUILTIN_1(ENUM, NAME, MASK, ATTR, ICODE) \\\n-  { NAME, ICODE, MASK, ATTR },\n-\n-#define RS6000_BUILTIN_2(ENUM, NAME, MASK, ATTR, ICODE)  \\\n-  { NAME, ICODE, MASK, ATTR },\n-\n-#define RS6000_BUILTIN_3(ENUM, NAME, MASK, ATTR, ICODE)  \\\n-  { NAME, ICODE, MASK, ATTR },\n-\n-#define RS6000_BUILTIN_4(ENUM, NAME, MASK, ATTR, ICODE)  \\\n-  { NAME, ICODE, MASK, ATTR },\n-\n-#define RS6000_BUILTIN_A(ENUM, NAME, MASK, ATTR, ICODE)  \\\n-  { NAME, ICODE, MASK, ATTR },\n-\n-#define RS6000_BUILTIN_D(ENUM, NAME, MASK, ATTR, ICODE)  \\\n-  { NAME, ICODE, MASK, ATTR },\n-\n-#define RS6000_BUILTIN_H(ENUM, NAME, MASK, ATTR, ICODE)  \\\n-  { NAME, ICODE, MASK, ATTR },\n-\n-#define RS6000_BUILTIN_M(ENUM, NAME, MASK, ATTR, ICODE)  \\\n-  { NAME, ICODE, MASK, ATTR },\n-\n-#define RS6000_BUILTIN_P(ENUM, NAME, MASK, ATTR, ICODE)  \\\n-  { NAME, ICODE, MASK, ATTR },\n-\n-#define RS6000_BUILTIN_X(ENUM, NAME, MASK, ATTR, ICODE)  \\\n-  { NAME, ICODE, MASK, ATTR },\n-\n-struct rs6000_builtin_info_type {\n-  const char *name;\n-  const enum insn_code icode;\n-  const HOST_WIDE_INT mask;\n-  const unsigned attr;\n-};\n-\n-static const struct rs6000_builtin_info_type rs6000_builtin_info[] =\n-{\n-#include \"rs6000-builtin.def\"\n-};\n-\n-#undef RS6000_BUILTIN_0\n-#undef RS6000_BUILTIN_1\n-#undef RS6000_BUILTIN_2\n-#undef RS6000_BUILTIN_3\n-#undef RS6000_BUILTIN_4\n-#undef RS6000_BUILTIN_A\n-#undef RS6000_BUILTIN_D\n-#undef RS6000_BUILTIN_H\n-#undef RS6000_BUILTIN_M\n-#undef RS6000_BUILTIN_P\n-#undef RS6000_BUILTIN_X\n-\n \f\n /* Nonzero if we can use a floating-point register to pass this arg.  */\n #define USE_FP_FOR_ARG_P(CUM,MODE)\t\t\\\n@@ -3130,367 +2995,6 @@ const char *rs6000_type_string (tree type_node)\n   return \"unknown\";\n }\n \n-static const struct builtin_compatibility bdesc_compat[] =\n-{\n-#define RS6000_BUILTIN_COMPAT\n-#include \"rs6000-builtin.def\"\n-};\n-#undef RS6000_BUILTIN_COMPAT\n-\n-/* Simple ternary operations: VECd = foo (VECa, VECb, VECc).  */\n-\n-#undef RS6000_BUILTIN_0\n-#undef RS6000_BUILTIN_1\n-#undef RS6000_BUILTIN_2\n-#undef RS6000_BUILTIN_3\n-#undef RS6000_BUILTIN_4\n-#undef RS6000_BUILTIN_A\n-#undef RS6000_BUILTIN_D\n-#undef RS6000_BUILTIN_H\n-#undef RS6000_BUILTIN_M\n-#undef RS6000_BUILTIN_P\n-#undef RS6000_BUILTIN_X\n-\n-#define RS6000_BUILTIN_0(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_1(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_2(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_3(ENUM, NAME, MASK, ATTR, ICODE) \\\n-  { MASK, ICODE, NAME, ENUM },\n-\n-#define RS6000_BUILTIN_4(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_A(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_D(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_H(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_M(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_P(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_X(ENUM, NAME, MASK, ATTR, ICODE)\n-\n-static const struct builtin_description bdesc_3arg[] =\n-{\n-#include \"rs6000-builtin.def\"\n-};\n-\n-/* Simple quaternary operations: VECd = foo (VECa, VECb, VECc, VECd).  */\n-\n-#undef RS6000_BUILTIN_0\n-#undef RS6000_BUILTIN_1\n-#undef RS6000_BUILTIN_2\n-#undef RS6000_BUILTIN_3\n-#undef RS6000_BUILTIN_4\n-#undef RS6000_BUILTIN_A\n-#undef RS6000_BUILTIN_D\n-#undef RS6000_BUILTIN_H\n-#undef RS6000_BUILTIN_M\n-#undef RS6000_BUILTIN_P\n-#undef RS6000_BUILTIN_X\n-\n-#define RS6000_BUILTIN_0(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_1(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_2(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_3(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_4(ENUM, NAME, MASK, ATTR, ICODE) \\\n-  { MASK, ICODE, NAME, ENUM },\n-\n-#define RS6000_BUILTIN_A(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_D(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_H(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_M(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_P(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_X(ENUM, NAME, MASK, ATTR, ICODE)\n-\n-static const struct builtin_description bdesc_4arg[] =\n-{\n-#include \"rs6000-builtin.def\"\n-};\n-\n-/* DST operations: void foo (void *, const int, const char).  */\n-\n-#undef RS6000_BUILTIN_0\n-#undef RS6000_BUILTIN_1\n-#undef RS6000_BUILTIN_2\n-#undef RS6000_BUILTIN_3\n-#undef RS6000_BUILTIN_4\n-#undef RS6000_BUILTIN_A\n-#undef RS6000_BUILTIN_D\n-#undef RS6000_BUILTIN_H\n-#undef RS6000_BUILTIN_M\n-#undef RS6000_BUILTIN_P\n-#undef RS6000_BUILTIN_X\n-\n-#define RS6000_BUILTIN_0(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_1(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_2(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_3(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_4(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_A(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_D(ENUM, NAME, MASK, ATTR, ICODE) \\\n-  { MASK, ICODE, NAME, ENUM },\n-\n-#define RS6000_BUILTIN_H(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_M(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_P(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_X(ENUM, NAME, MASK, ATTR, ICODE)\n-\n-static const struct builtin_description bdesc_dst[] =\n-{\n-#include \"rs6000-builtin.def\"\n-};\n-\n-/* Simple binary operations: VECc = foo (VECa, VECb).  */\n-\n-#undef RS6000_BUILTIN_0\n-#undef RS6000_BUILTIN_1\n-#undef RS6000_BUILTIN_2\n-#undef RS6000_BUILTIN_3\n-#undef RS6000_BUILTIN_4\n-#undef RS6000_BUILTIN_A\n-#undef RS6000_BUILTIN_D\n-#undef RS6000_BUILTIN_H\n-#undef RS6000_BUILTIN_M\n-#undef RS6000_BUILTIN_P\n-#undef RS6000_BUILTIN_X\n-\n-#define RS6000_BUILTIN_0(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_1(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_2(ENUM, NAME, MASK, ATTR, ICODE) \\\n-  { MASK, ICODE, NAME, ENUM },\n-\n-#define RS6000_BUILTIN_3(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_4(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_A(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_D(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_H(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_M(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_P(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_X(ENUM, NAME, MASK, ATTR, ICODE)\n-\n-static const struct builtin_description bdesc_2arg[] =\n-{\n-#include \"rs6000-builtin.def\"\n-};\n-\n-#undef RS6000_BUILTIN_0\n-#undef RS6000_BUILTIN_1\n-#undef RS6000_BUILTIN_2\n-#undef RS6000_BUILTIN_3\n-#undef RS6000_BUILTIN_4\n-#undef RS6000_BUILTIN_A\n-#undef RS6000_BUILTIN_D\n-#undef RS6000_BUILTIN_H\n-#undef RS6000_BUILTIN_M\n-#undef RS6000_BUILTIN_P\n-#undef RS6000_BUILTIN_X\n-\n-#define RS6000_BUILTIN_0(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_1(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_2(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_3(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_4(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_A(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_D(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_H(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_M(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_P(ENUM, NAME, MASK, ATTR, ICODE) \\\n-  { MASK, ICODE, NAME, ENUM },\n-\n-#define RS6000_BUILTIN_X(ENUM, NAME, MASK, ATTR, ICODE)\n-\n-/* AltiVec predicates.  */\n-\n-static const struct builtin_description bdesc_altivec_preds[] =\n-{\n-#include \"rs6000-builtin.def\"\n-};\n-\n-/* ABS* operations.  */\n-\n-#undef RS6000_BUILTIN_0\n-#undef RS6000_BUILTIN_1\n-#undef RS6000_BUILTIN_2\n-#undef RS6000_BUILTIN_3\n-#undef RS6000_BUILTIN_4\n-#undef RS6000_BUILTIN_A\n-#undef RS6000_BUILTIN_D\n-#undef RS6000_BUILTIN_H\n-#undef RS6000_BUILTIN_M\n-#undef RS6000_BUILTIN_P\n-#undef RS6000_BUILTIN_X\n-\n-#define RS6000_BUILTIN_0(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_1(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_2(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_3(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_4(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_A(ENUM, NAME, MASK, ATTR, ICODE) \\\n-  { MASK, ICODE, NAME, ENUM },\n-\n-#define RS6000_BUILTIN_D(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_H(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_M(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_P(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_X(ENUM, NAME, MASK, ATTR, ICODE)\n-\n-static const struct builtin_description bdesc_abs[] =\n-{\n-#include \"rs6000-builtin.def\"\n-};\n-\n-/* Simple unary operations: VECb = foo (unsigned literal) or VECb =\n-   foo (VECa).  */\n-\n-#undef RS6000_BUILTIN_0\n-#undef RS6000_BUILTIN_1\n-#undef RS6000_BUILTIN_2\n-#undef RS6000_BUILTIN_3\n-#undef RS6000_BUILTIN_4\n-#undef RS6000_BUILTIN_A\n-#undef RS6000_BUILTIN_D\n-#undef RS6000_BUILTIN_H\n-#undef RS6000_BUILTIN_M\n-#undef RS6000_BUILTIN_P\n-#undef RS6000_BUILTIN_X\n-\n-#define RS6000_BUILTIN_0(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_1(ENUM, NAME, MASK, ATTR, ICODE) \\\n-  { MASK, ICODE, NAME, ENUM },\n-\n-#define RS6000_BUILTIN_2(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_3(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_4(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_A(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_D(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_H(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_M(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_P(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_X(ENUM, NAME, MASK, ATTR, ICODE)\n-\n-static const struct builtin_description bdesc_1arg[] =\n-{\n-#include \"rs6000-builtin.def\"\n-};\n-\n-/* Simple no-argument operations: result = __builtin_darn_32 () */\n-\n-#undef RS6000_BUILTIN_0\n-#undef RS6000_BUILTIN_1\n-#undef RS6000_BUILTIN_2\n-#undef RS6000_BUILTIN_3\n-#undef RS6000_BUILTIN_4\n-#undef RS6000_BUILTIN_A\n-#undef RS6000_BUILTIN_D\n-#undef RS6000_BUILTIN_H\n-#undef RS6000_BUILTIN_M\n-#undef RS6000_BUILTIN_P\n-#undef RS6000_BUILTIN_X\n-\n-#define RS6000_BUILTIN_0(ENUM, NAME, MASK, ATTR, ICODE) \\\n-  { MASK, ICODE, NAME, ENUM },\n-\n-#define RS6000_BUILTIN_1(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_2(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_3(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_4(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_A(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_D(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_H(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_M(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_P(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_X(ENUM, NAME, MASK, ATTR, ICODE)\n-\n-static const struct builtin_description bdesc_0arg[] =\n-{\n-#include \"rs6000-builtin.def\"\n-};\n-\n-/* HTM builtins.  */\n-#undef RS6000_BUILTIN_0\n-#undef RS6000_BUILTIN_1\n-#undef RS6000_BUILTIN_2\n-#undef RS6000_BUILTIN_3\n-#undef RS6000_BUILTIN_4\n-#undef RS6000_BUILTIN_A\n-#undef RS6000_BUILTIN_D\n-#undef RS6000_BUILTIN_H\n-#undef RS6000_BUILTIN_M\n-#undef RS6000_BUILTIN_P\n-#undef RS6000_BUILTIN_X\n-\n-#define RS6000_BUILTIN_0(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_1(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_2(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_3(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_4(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_A(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_D(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_H(ENUM, NAME, MASK, ATTR, ICODE) \\\n-  { MASK, ICODE, NAME, ENUM },\n-\n-#define RS6000_BUILTIN_M(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_P(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_X(ENUM, NAME, MASK, ATTR, ICODE)\n-\n-static const struct builtin_description bdesc_htm[] =\n-{\n-#include \"rs6000-builtin.def\"\n-};\n-\n-/* MMA builtins.  */\n-#undef RS6000_BUILTIN_0\n-#undef RS6000_BUILTIN_1\n-#undef RS6000_BUILTIN_2\n-#undef RS6000_BUILTIN_3\n-#undef RS6000_BUILTIN_4\n-#undef RS6000_BUILTIN_A\n-#undef RS6000_BUILTIN_D\n-#undef RS6000_BUILTIN_H\n-#undef RS6000_BUILTIN_M\n-#undef RS6000_BUILTIN_P\n-#undef RS6000_BUILTIN_X\n-\n-#define RS6000_BUILTIN_0(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_1(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_2(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_3(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_4(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_A(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_D(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_H(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_M(ENUM, NAME, MASK, ATTR, ICODE) \\\n-  { MASK, ICODE, NAME, ENUM },\n-\n-#define RS6000_BUILTIN_P(ENUM, NAME, MASK, ATTR, ICODE)\n-#define RS6000_BUILTIN_X(ENUM, NAME, MASK, ATTR, ICODE)\n-\n-static const struct builtin_description bdesc_mma[] =\n-{\n-#include \"rs6000-builtin.def\"\n-};\n-\n-#undef RS6000_BUILTIN_0\n-#undef RS6000_BUILTIN_1\n-#undef RS6000_BUILTIN_2\n-#undef RS6000_BUILTIN_3\n-#undef RS6000_BUILTIN_4\n-#undef RS6000_BUILTIN_A\n-#undef RS6000_BUILTIN_D\n-#undef RS6000_BUILTIN_H\n-#undef RS6000_BUILTIN_M\n-#undef RS6000_BUILTIN_P\n-#undef RS6000_BUILTIN_X\n-\n-/* Return true if a builtin function is overloaded.  */\n-bool\n-rs6000_overloaded_builtin_p (enum rs6000_builtins fncode)\n-{\n-  return (rs6000_builtin_info[(int)fncode].attr & RS6000_BTC_OVERLOADED) != 0;\n-}\n-\n-const char *\n-rs6000_overloaded_builtin_name (enum rs6000_builtins fncode)\n-{\n-  return rs6000_builtin_info[(int)fncode].name;\n-}\n-\n static rtx\n altivec_expand_predicate_builtin (enum insn_code icode, tree exp, rtx target)\n {\n@@ -3611,24 +3115,6 @@ swap_endian_selector_for_mode (machine_mode mode)\n \t\t\t\t\t\t     gen_rtvec_v (16, perm)));\n }\n \n-/* Return the appropriate SPR number associated with the given builtin.  */\n-static inline HOST_WIDE_INT\n-htm_spr_num (enum rs6000_builtins code)\n-{\n-  if (code == HTM_BUILTIN_GET_TFHAR\n-      || code == HTM_BUILTIN_SET_TFHAR)\n-    return TFHAR_SPR;\n-  else if (code == HTM_BUILTIN_GET_TFIAR\n-\t   || code == HTM_BUILTIN_SET_TFIAR)\n-    return TFIAR_SPR;\n-  else if (code == HTM_BUILTIN_GET_TEXASR\n-\t   || code == HTM_BUILTIN_SET_TEXASR)\n-    return TEXASR_SPR;\n-  gcc_assert (code == HTM_BUILTIN_GET_TEXASRU\n-\t      || code == HTM_BUILTIN_SET_TEXASRU);\n-  return TEXASRU_SPR;\n-}\n-\n /* Return the correct ICODE value depending on whether we are\n    setting or reading the HTM SPRs.  */\n static inline enum insn_code\n@@ -3768,18 +3254,6 @@ altivec_expand_vec_ext_builtin (tree exp, rtx target)\n   return target;\n }\n \n-/* Check whether a builtin function is supported in this target\n-   configuration.  */\n-bool\n-rs6000_builtin_is_supported_p (enum rs6000_builtins fncode)\n-{\n-  HOST_WIDE_INT fnmask = rs6000_builtin_info[fncode].mask;\n-  if ((fnmask & rs6000_builtin_mask) != fnmask)\n-    return false;\n-  else\n-    return true;\n-}\n-\n /* Raise an error message for a builtin function that is called without the\n    appropriate target options being set.  */\n \n@@ -4005,190 +3479,6 @@ fold_mergeeo_helper (gimple_stmt_iterator *gsi, gimple *stmt, int use_odd)\n   gsi_replace (gsi, g, true);\n }\n \n-/* Expand the MMA built-ins early, so that we can convert the pass-by-reference\n-   __vector_quad arguments into pass-by-value arguments, leading to more\n-   efficient code generation.  */\n-\n-bool\n-rs6000_gimple_fold_mma_builtin (gimple_stmt_iterator *gsi)\n-{\n-  gimple *stmt = gsi_stmt (*gsi);\n-  tree fndecl = gimple_call_fndecl (stmt);\n-  enum rs6000_builtins fncode\n-    = (enum rs6000_builtins) DECL_MD_FUNCTION_CODE (fndecl);\n-  unsigned attr = rs6000_builtin_info[fncode].attr;\n-\n-  if ((attr & RS6000_BTC_GIMPLE) == 0)\n-    return false;\n-\n-  unsigned nopnds = (attr & RS6000_BTC_OPND_MASK);\n-  gimple_seq new_seq = NULL;\n-  gimple *new_call;\n-  tree new_decl;\n-\n-  if (fncode == MMA_BUILTIN_DISASSEMBLE_ACC\n-      || fncode == VSX_BUILTIN_DISASSEMBLE_PAIR)\n-    {\n-      /* This is an MMA disassemble built-in function.  */\n-      push_gimplify_context (true);\n-      unsigned nvec = (fncode == MMA_BUILTIN_DISASSEMBLE_ACC) ? 4 : 2;\n-      tree dst_ptr = gimple_call_arg (stmt, 0);\n-      tree src_ptr = gimple_call_arg (stmt, 1);\n-      tree src_type = TREE_TYPE (src_ptr);\n-      tree src = create_tmp_reg_or_ssa_name (TREE_TYPE (src_type));\n-      gimplify_assign (src, build_simple_mem_ref (src_ptr), &new_seq);\n-\n-      /* If we are not disassembling an accumulator/pair or our destination is\n-\t another accumulator/pair, then just copy the entire thing as is.  */\n-      if ((fncode == MMA_BUILTIN_DISASSEMBLE_ACC\n-\t   && TREE_TYPE (TREE_TYPE (dst_ptr)) == vector_quad_type_node)\n-\t  || (fncode == VSX_BUILTIN_DISASSEMBLE_PAIR\n-\t      && TREE_TYPE (TREE_TYPE (dst_ptr)) == vector_pair_type_node))\n-\t{\n-\t  tree dst = build_simple_mem_ref (build1 (VIEW_CONVERT_EXPR,\n-\t\t\t\t\t\t   src_type, dst_ptr));\n-\t  gimplify_assign (dst, src, &new_seq);\n-\t  pop_gimplify_context (NULL);\n-\t  gsi_replace_with_seq (gsi, new_seq, true);\n-\t  return true;\n-\t}\n-\n-      /* If we're disassembling an accumulator into a different type, we need\n-\t to emit a xxmfacc instruction now, since we cannot do it later.  */\n-      if (fncode == MMA_BUILTIN_DISASSEMBLE_ACC)\n-\t{\n-\t  new_decl = rs6000_builtin_decls[MMA_BUILTIN_XXMFACC_INTERNAL];\n-\t  new_call = gimple_build_call (new_decl, 1, src);\n-\t  src = create_tmp_reg_or_ssa_name (vector_quad_type_node);\n-\t  gimple_call_set_lhs (new_call, src);\n-\t  gimple_seq_add_stmt (&new_seq, new_call);\n-\t}\n-\n-      /* Copy the accumulator/pair vector by vector.  */\n-      new_decl = rs6000_builtin_decls[fncode + 1];\n-      tree dst_type = build_pointer_type_for_mode (unsigned_V16QI_type_node,\n-\t\t\t\t\t\t   ptr_mode, true);\n-      tree dst_base = build1 (VIEW_CONVERT_EXPR, dst_type, dst_ptr);\n-      for (unsigned i = 0; i < nvec; i++)\n-\t{\n-\t  unsigned index = WORDS_BIG_ENDIAN ? i : nvec - 1 - i;\n-\t  tree dst = build2 (MEM_REF, unsigned_V16QI_type_node, dst_base,\n-\t\t\t     build_int_cst (dst_type, index * 16));\n-\t  tree dstssa = create_tmp_reg_or_ssa_name (unsigned_V16QI_type_node);\n-\t  new_call = gimple_build_call (new_decl, 2, src,\n-\t\t\t\t\tbuild_int_cstu (uint16_type_node, i));\n-\t  gimple_call_set_lhs (new_call, dstssa);\n-\t  gimple_seq_add_stmt (&new_seq, new_call);\n-\t  gimplify_assign (dst, dstssa, &new_seq);\n-\t}\n-      pop_gimplify_context (NULL);\n-      gsi_replace_with_seq (gsi, new_seq, true);\n-      return true;\n-    }\n-  else if (fncode == VSX_BUILTIN_LXVP)\n-    {\n-      push_gimplify_context (true);\n-      tree offset = gimple_call_arg (stmt, 0);\n-      tree ptr = gimple_call_arg (stmt, 1);\n-      tree lhs = gimple_call_lhs (stmt);\n-      if (TREE_TYPE (TREE_TYPE (ptr)) != vector_pair_type_node)\n-\tptr = build1 (VIEW_CONVERT_EXPR,\n-\t\t      build_pointer_type (vector_pair_type_node), ptr);\n-      tree mem = build_simple_mem_ref (build2 (POINTER_PLUS_EXPR,\n-\t\t\t\t\t       TREE_TYPE (ptr), ptr, offset));\n-      gimplify_assign (lhs, mem, &new_seq);\n-      pop_gimplify_context (NULL);\n-      gsi_replace_with_seq (gsi, new_seq, true);\n-      return true;\n-    }\n-  else if (fncode == VSX_BUILTIN_STXVP)\n-    {\n-      push_gimplify_context (true);\n-      tree src = gimple_call_arg (stmt, 0);\n-      tree offset = gimple_call_arg (stmt, 1);\n-      tree ptr = gimple_call_arg (stmt, 2);\n-      if (TREE_TYPE (TREE_TYPE (ptr)) != vector_pair_type_node)\n-\tptr = build1 (VIEW_CONVERT_EXPR,\n-\t\t      build_pointer_type (vector_pair_type_node), ptr);\n-      tree mem = build_simple_mem_ref (build2 (POINTER_PLUS_EXPR,\n-\t\t\t\t\t       TREE_TYPE (ptr), ptr, offset));\n-      gimplify_assign (mem, src, &new_seq);\n-      pop_gimplify_context (NULL);\n-      gsi_replace_with_seq (gsi, new_seq, true);\n-      return true;\n-    }\n-\n-  /* Convert this built-in into an internal version that uses pass-by-value\n-     arguments.  The internal built-in follows immediately after this one.  */\n-  new_decl = rs6000_builtin_decls[fncode + 1];\n-  tree lhs, op[MAX_MMA_OPERANDS];\n-  tree acc = gimple_call_arg (stmt, 0);\n-  push_gimplify_context (true);\n-\n-  if ((attr & RS6000_BTC_QUAD) != 0)\n-    {\n-      /* This built-in has a pass-by-reference accumulator input, so load it\n-\t into a temporary accumulator for use as a pass-by-value input.  */\n-      op[0] = create_tmp_reg_or_ssa_name (vector_quad_type_node);\n-      for (unsigned i = 1; i < nopnds; i++)\n-\top[i] = gimple_call_arg (stmt, i);\n-      gimplify_assign (op[0], build_simple_mem_ref (acc), &new_seq);\n-    }\n-  else\n-    {\n-      /* This built-in does not use its pass-by-reference accumulator argument\n-\t as an input argument, so remove it from the input list.  */\n-      nopnds--;\n-      for (unsigned i = 0; i < nopnds; i++)\n-\top[i] = gimple_call_arg (stmt, i + 1);\n-    }\n-\n-  switch (nopnds)\n-    {\n-    case 0:\n-      new_call = gimple_build_call (new_decl, 0);\n-      break;\n-    case 1:\n-      new_call = gimple_build_call (new_decl, 1, op[0]);\n-      break;\n-    case 2:\n-      new_call = gimple_build_call (new_decl, 2, op[0], op[1]);\n-      break;\n-    case 3:\n-      new_call = gimple_build_call (new_decl, 3, op[0], op[1], op[2]);\n-      break;\n-    case 4:\n-      new_call = gimple_build_call (new_decl, 4, op[0], op[1], op[2], op[3]);\n-      break;\n-    case 5:\n-      new_call = gimple_build_call (new_decl, 5, op[0], op[1], op[2], op[3],\n-\t\t\t\t    op[4]);\n-      break;\n-    case 6:\n-      new_call = gimple_build_call (new_decl, 6, op[0], op[1], op[2], op[3],\n-\t\t\t\t    op[4], op[5]);\n-      break;\n-    case 7:\n-      new_call = gimple_build_call (new_decl, 7, op[0], op[1], op[2], op[3],\n-\t\t\t\t    op[4], op[5], op[6]);\n-      break;\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  if (fncode == VSX_BUILTIN_BUILD_PAIR || fncode == VSX_BUILTIN_ASSEMBLE_PAIR)\n-    lhs = create_tmp_reg_or_ssa_name (vector_pair_type_node);\n-  else\n-    lhs = create_tmp_reg_or_ssa_name (vector_quad_type_node);\n-  gimple_call_set_lhs (new_call, lhs);\n-  gimple_seq_add_stmt (&new_seq, new_call);\n-  gimplify_assign (build_simple_mem_ref (acc), lhs, &new_seq);\n-  pop_gimplify_context (NULL);\n-  gsi_replace_with_seq (gsi, new_seq, true);\n-\n-  return true;\n-}\n-\n /* Fold a machine-dependent built-in in GIMPLE.  (For folding into\n    a constant, use rs6000_fold_builtin.)  */\n \n@@ -7262,5 +6552,3 @@ rs6000_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n   reload_completed = 0;\n   epilogue_completed = 0;\n }\n-\n-#include \"gt-rs6000-call.h\""}, {"sha": "c01ae005d0bef91cf10ee655bdc0cbb2cfbc413f", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e855d235a08ba941f8e5ba398f1c3e8b497ba93/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e855d235a08ba941f8e5ba398f1c3e8b497ba93/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=9e855d235a08ba941f8e5ba398f1c3e8b497ba93", "patch": "@@ -272,9 +272,6 @@ extern void rs6000_call_darwin (rtx, rtx, rtx, rtx);\n extern void rs6000_sibcall_darwin (rtx, rtx, rtx, rtx);\n extern void rs6000_aix_asm_output_dwarf_table_ref (char *);\n extern void get_ppc476_thunk_name (char name[32]);\n-extern bool rs6000_overloaded_builtin_p (enum rs6000_builtins);\n-extern bool rs6000_builtin_is_supported_p (enum rs6000_builtins);\n-extern const char *rs6000_overloaded_builtin_name (enum rs6000_builtins);\n extern int rs6000_store_data_bypass_p (rtx_insn *, rtx_insn *);\n extern HOST_WIDE_INT rs6000_builtin_mask_calculate (void);\n extern void rs6000_asm_output_dwarf_pcrel (FILE *file, int size,"}, {"sha": "5c077cd101e392912b94e78870ff4263da5c6d03", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e855d235a08ba941f8e5ba398f1c3e8b497ba93/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e855d235a08ba941f8e5ba398f1c3e8b497ba93/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=9e855d235a08ba941f8e5ba398f1c3e8b497ba93", "patch": "@@ -171,7 +171,6 @@ static int dbg_cost_ctrl;\n \n /* Built in types.  */\n tree rs6000_builtin_types[RS6000_BTI_MAX];\n-tree rs6000_builtin_decls[RS6000_BUILTIN_COUNT];\n \n /* Flag to say the TOC is initialized */\n int toc_initialized, need_toc_init;\n@@ -2585,8 +2584,6 @@ rs6000_debug_reg_global (void)\n \t   (int)rs6000_sched_restricted_insns_priority);\n   fprintf (stderr, DEBUG_FMT_D, \"Number of standard builtins\",\n \t   (int)END_BUILTINS);\n-  fprintf (stderr, DEBUG_FMT_D, \"Number of rs6000 builtins\",\n-\t   (int)RS6000_BUILTIN_COUNT);\n \n   fprintf (stderr, DEBUG_FMT_D, \"Enable float128 on VSX\",\n \t   (int)TARGET_FLOAT128_ENABLE_TYPE);"}, {"sha": "4d2f88d42182260f32e8983931160925aba19ea8", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e855d235a08ba941f8e5ba398f1c3e8b497ba93/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e855d235a08ba941f8e5ba398f1c3e8b497ba93/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=9e855d235a08ba941f8e5ba398f1c3e8b497ba93", "patch": "@@ -2344,62 +2344,6 @@ extern int frame_pointer_needed;\n \t\t\t\t | RS6000_BTM_MMA\t\t\t\\\n \t\t\t\t | RS6000_BTM_P10)\n \n-/* Define builtin enum index.  */\n-\n-#undef RS6000_BUILTIN_0\n-#undef RS6000_BUILTIN_1\n-#undef RS6000_BUILTIN_2\n-#undef RS6000_BUILTIN_3\n-#undef RS6000_BUILTIN_4\n-#undef RS6000_BUILTIN_A\n-#undef RS6000_BUILTIN_D\n-#undef RS6000_BUILTIN_H\n-#undef RS6000_BUILTIN_M\n-#undef RS6000_BUILTIN_P\n-#undef RS6000_BUILTIN_X\n-\n-#define RS6000_BUILTIN_0(ENUM, NAME, MASK, ATTR, ICODE) ENUM,\n-#define RS6000_BUILTIN_1(ENUM, NAME, MASK, ATTR, ICODE) ENUM,\n-#define RS6000_BUILTIN_2(ENUM, NAME, MASK, ATTR, ICODE) ENUM,\n-#define RS6000_BUILTIN_3(ENUM, NAME, MASK, ATTR, ICODE) ENUM,\n-#define RS6000_BUILTIN_4(ENUM, NAME, MASK, ATTR, ICODE) ENUM,\n-#define RS6000_BUILTIN_A(ENUM, NAME, MASK, ATTR, ICODE) ENUM,\n-#define RS6000_BUILTIN_D(ENUM, NAME, MASK, ATTR, ICODE) ENUM,\n-#define RS6000_BUILTIN_H(ENUM, NAME, MASK, ATTR, ICODE) ENUM,\n-#define RS6000_BUILTIN_M(ENUM, NAME, MASK, ATTR, ICODE) ENUM,\n-#define RS6000_BUILTIN_P(ENUM, NAME, MASK, ATTR, ICODE) ENUM,\n-#define RS6000_BUILTIN_X(ENUM, NAME, MASK, ATTR, ICODE) ENUM,\n-\n-enum rs6000_builtins\n-{\n-#include \"rs6000-builtin.def\"\n-\n-  RS6000_BUILTIN_COUNT\n-};\n-\n-#undef RS6000_BUILTIN_0\n-#undef RS6000_BUILTIN_1\n-#undef RS6000_BUILTIN_2\n-#undef RS6000_BUILTIN_3\n-#undef RS6000_BUILTIN_4\n-#undef RS6000_BUILTIN_A\n-#undef RS6000_BUILTIN_D\n-#undef RS6000_BUILTIN_H\n-#undef RS6000_BUILTIN_M\n-#undef RS6000_BUILTIN_P\n-#undef RS6000_BUILTIN_X\n-\n-/* Mappings for overloaded builtins.  */\n-struct altivec_builtin_types\n-{\n-  enum rs6000_builtins code;\n-  enum rs6000_builtins overloaded_code;\n-  signed char ret_type;\n-  signed char op1;\n-  signed char op2;\n-  signed char op3;\n-};\n-\n enum rs6000_builtin_type_index\n {\n   RS6000_BTI_NOT_OPAQUE,\n@@ -2600,7 +2544,6 @@ enum rs6000_builtin_type_index\n #define ptr_long_long_unsigned_type_node (rs6000_builtin_types[RS6000_BTI_ptr_long_long_unsigned])\n \n extern GTY(()) tree rs6000_builtin_types[RS6000_BTI_MAX];\n-extern GTY(()) tree rs6000_builtin_decls[RS6000_BUILTIN_COUNT];\n \n #ifndef USED_FOR_TARGET\n extern GTY(()) tree builtin_mode_to_type[MAX_MACHINE_MODE][2];"}, {"sha": "98ddd977f964014dd262c384c8314fe4c03ed8df", "filename": "gcc/config/rs6000/t-rs6000", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e855d235a08ba941f8e5ba398f1c3e8b497ba93/gcc%2Fconfig%2Frs6000%2Ft-rs6000", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e855d235a08ba941f8e5ba398f1c3e8b497ba93/gcc%2Fconfig%2Frs6000%2Ft-rs6000", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Ft-rs6000?ref=9e855d235a08ba941f8e5ba398f1c3e8b497ba93", "patch": "@@ -18,7 +18,6 @@\n # along with GCC; see the file COPYING3.  If not see\n # <http://www.gnu.org/licenses/>.\n \n-TM_H += $(srcdir)/config/rs6000/rs6000-builtin.def\n TM_H += $(srcdir)/config/rs6000/rs6000-cpus.def\n TM_H += $(srcdir)/config/rs6000/rs6000-modes.h\n PASSES_EXTRA += $(srcdir)/config/rs6000/rs6000-passes.def"}]}