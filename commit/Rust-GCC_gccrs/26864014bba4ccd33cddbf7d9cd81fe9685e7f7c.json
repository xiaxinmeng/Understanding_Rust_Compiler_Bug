{"sha": "26864014bba4ccd33cddbf7d9cd81fe9685e7f7c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjY4NjQwMTRiYmE0Y2NkMzNjZGRiZjdkOWNkODFmZTk2ODVlN2Y3Yw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-09-14T09:03:05Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-09-14T09:04:07Z"}, "message": "Fix internal error on broken import of vector intrinsics\n\nThe change also makes small adjustments to warning messages for intrinsics.\n\ngcc/ada/\n\t* gcc-interface/decl.c (gnat_to_gnu_subprog_type): Turn variable\n\tinto constant.  Capitalize GCC in warning message.\n\t(intrin_arglists_compatible_p): Change parameter to pointer-to-const\n\tAdjust warning messages.  Turn warning into error for vector types.\n\t(intrin_return_compatible_p): Likewise.\n\t(intrin_profiles_compatible_p): Change parameter to pointer-to-const", "tree": {"sha": "87a94a7cdcc8d48e8576721214c88449695c90ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/87a94a7cdcc8d48e8576721214c88449695c90ee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/26864014bba4ccd33cddbf7d9cd81fe9685e7f7c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26864014bba4ccd33cddbf7d9cd81fe9685e7f7c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26864014bba4ccd33cddbf7d9cd81fe9685e7f7c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26864014bba4ccd33cddbf7d9cd81fe9685e7f7c/comments", "author": null, "committer": null, "parents": [{"sha": "fad540552ffa23dae2874aaf93916175d2577b8e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fad540552ffa23dae2874aaf93916175d2577b8e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fad540552ffa23dae2874aaf93916175d2577b8e"}], "stats": {"total": 46, "additions": 27, "deletions": 19}, "files": [{"sha": "9202184266066fe362a8e0d6c1736f6b2e77ecb4", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 27, "deletions": 19, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26864014bba4ccd33cddbf7d9cd81fe9685e7f7c/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26864014bba4ccd33cddbf7d9cd81fe9685e7f7c/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=26864014bba4ccd33cddbf7d9cd81fe9685e7f7c", "patch": "@@ -262,7 +262,7 @@ typedef struct {\n   tree btin_fntype;       /* The GCC builtin function type node.  */\n } intrin_binding_t;\n \n-static bool intrin_profiles_compatible_p (intrin_binding_t *);\n+static bool intrin_profiles_compatible_p (const intrin_binding_t *);\n \n /* Given GNAT_ENTITY, a GNAT defining identifier node, which denotes some Ada\n    entity, return the equivalent GCC tree for that entity (a ..._DECL node)\n@@ -6297,14 +6297,13 @@ gnat_to_gnu_subprog_type (Entity_Id gnat_subprog, bool definition,\n \t     the checker is expected to post diagnostics in this case.  */\n \t  if (gnu_builtin_decl)\n \t    {\n-\t      intrin_binding_t inb\n+\t      const intrin_binding_t inb\n \t\t= { gnat_subprog, gnu_type, TREE_TYPE (gnu_builtin_decl) };\n \n \t      if (!intrin_profiles_compatible_p (&inb))\n \t\tpost_error\n \t\t  (\"??profile of& doesn''t match the builtin it binds!\",\n \t\t   gnat_subprog);\n-\n \t      return gnu_builtin_decl;\n \t    }\n \n@@ -6315,7 +6314,7 @@ gnat_to_gnu_subprog_type (Entity_Id gnat_subprog, bool definition,\n \t     on demand without risking false positives with common default sets\n \t     of options.  */\n \t  if (warn_shadow)\n-\t    post_error (\"??gcc intrinsic not found for&!\", gnat_subprog);\n+\t    post_error (\"'G'C'C intrinsic not found for&!??\", gnat_subprog);\n \t}\n     }\n \n@@ -9497,7 +9496,7 @@ check_ok_for_atomic_type (tree type, Entity_Id gnat_entity, bool component_p)\n    on the Ada/builtin argument lists for the INB binding.  */\n \n static bool\n-intrin_arglists_compatible_p (intrin_binding_t * inb)\n+intrin_arglists_compatible_p (const intrin_binding_t *inb)\n {\n   function_args_iterator ada_iter, btin_iter;\n \n@@ -9522,17 +9521,15 @@ intrin_arglists_compatible_p (intrin_binding_t * inb)\n \n       /* If we're done with the Ada args and not with the internal builtin\n \t args, or the other way around, complain.  */\n-      if (ada_type == void_type_node\n-\t  && btin_type != void_type_node)\n+      if (ada_type == void_type_node && btin_type != void_type_node)\n \t{\n-\t  post_error (\"??Ada arguments list too short!\", inb->gnat_entity);\n+\t  post_error (\"??Ada parameter list too short!\", inb->gnat_entity);\n \t  return false;\n \t}\n \n-      if (btin_type == void_type_node\n-\t  && ada_type != void_type_node)\n+      if (btin_type == void_type_node && ada_type != void_type_node)\n \t{\n-\t  post_error_ne_num (\"??Ada arguments list too long ('> ^)!\",\n+\t  post_error_ne_num (\"??Ada parameter list too long ('> ^)!\",\n \t\t\t     inb->gnat_entity, inb->gnat_entity, argpos);\n \t  return false;\n \t}\n@@ -9541,8 +9538,15 @@ intrin_arglists_compatible_p (intrin_binding_t * inb)\n       argpos++;\n       if (!types_compatible_p (ada_type, btin_type))\n \t{\n-\t  post_error_ne_num (\"??intrinsic binding type mismatch on argument ^!\",\n-\t\t\t     inb->gnat_entity, inb->gnat_entity, argpos);\n+\t  /* For vector builtins, issue an error to avoid an ICE.  */\n+\t  if (VECTOR_TYPE_P (btin_type))\n+\t    post_error_ne_num\n+\t      (\"intrinsic binding type mismatch on parameter ^\",\n+\t       inb->gnat_entity, inb->gnat_entity, argpos);\n+\t  else\n+\t    post_error_ne_num\n+\t      (\"??intrinsic binding type mismatch on parameter ^!\",\n+\t       inb->gnat_entity, inb->gnat_entity, argpos);\n \t  return false;\n \t}\n \n@@ -9558,22 +9562,26 @@ intrin_arglists_compatible_p (intrin_binding_t * inb)\n    on the Ada/builtin return values for the INB binding.  */\n \n static bool\n-intrin_return_compatible_p (intrin_binding_t * inb)\n+intrin_return_compatible_p (const intrin_binding_t *inb)\n {\n   tree ada_return_type = TREE_TYPE (inb->ada_fntype);\n   tree btin_return_type = TREE_TYPE (inb->btin_fntype);\n \n   /* Accept function imported as procedure, common and convenient.  */\n-  if (VOID_TYPE_P (ada_return_type)\n-      && !VOID_TYPE_P (btin_return_type))\n+  if (VOID_TYPE_P (ada_return_type) && !VOID_TYPE_P (btin_return_type))\n     return true;\n \n   /* Check return types compatibility otherwise.  Note that this\n      handles void/void as well.  */\n   if (!types_compatible_p (btin_return_type, ada_return_type))\n     {\n-      post_error (\"??intrinsic binding type mismatch on return value!\",\n-\t\t  inb->gnat_entity);\n+      /* For vector builtins, issue an error to avoid an ICE.  */\n+      if (VECTOR_TYPE_P (btin_return_type))\n+\tpost_error (\"intrinsic binding type mismatch on result\",\n+\t\t    inb->gnat_entity);\n+      else\n+\tpost_error (\"??intrinsic binding type mismatch on result\",\n+\t\t    inb->gnat_entity);\n       return false;\n     }\n \n@@ -9589,7 +9597,7 @@ intrin_return_compatible_p (intrin_binding_t * inb)\n    especially when binding straight to a compiler internal.  */\n \n static bool\n-intrin_profiles_compatible_p (intrin_binding_t * inb)\n+intrin_profiles_compatible_p (const intrin_binding_t *inb)\n {\n   /* Check compatibility on return values and argument lists, each responsible\n      for posting warnings as appropriate.  Ensure use of the proper sloc for"}]}