{"sha": "b07fc91cc47769f1fdabf31a3c8f942caf49d873", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjA3ZmM5MWNjNDc3NjlmMWZkYWJmMzFhM2M4Zjk0MmNhZjQ5ZDg3Mw==", "commit": {"author": {"name": "Szabolcs Nagy", "email": "szabolcs.nagy@arm.com", "date": "2019-06-03T13:50:53Z"}, "committer": {"name": "Szabolcs Nagy", "email": "nsz@gcc.gnu.org", "date": "2019-06-03T13:50:53Z"}, "message": "aarch64: emit .variant_pcs for aarch64_vector_pcs symbol references\n\nA dynamic linker with lazy binding support may need to handle vector PCS\nfunction symbols specially, so an ELF symbol table marking was\nintroduced for such symbols.\n\nFunction symbol references and definitions that follow the vector PCS\nare marked in the generated assembly with .variant_pcs and then the\nSTO_AARCH64_VARIANT_PCS st_other flag is set on the symbol in the object\nfile.  The marking is propagated to the dynamic symbol table by the\nstatic linker so a dynamic linker can handle such symbols specially.\n\nFor this to work, the assembler, the static linker and the dynamic\nlinker has to be updated on a system.  Old assembler does not support\nthe new .variant_pcs directive, so a toolchain with old binutils won't\nbe able to compile code that references vector PCS symbols.\n\ngcc/ChangeLog:\n\n\t* config/aarch64/aarch64-protos.h (aarch64_asm_output_alias): Declare.\n\t(aarch64_asm_output_external): Declare.\n\t* config/aarch64/aarch64.c (aarch64_asm_output_variant_pcs): New.\n\t(aarch64_declare_function_name): Call aarch64_asm_output_variant_pcs.\n\t(aarch64_asm_output_alias): New.\n\t(aarch64_asm_output_external): New.\n\t* config/aarch64/aarch64.h (ASM_OUTPUT_DEF_FROM_DECLS): Define.\n\t(ASM_OUTPUT_EXTERNAL): Define.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/aarch64/pcs_attribute-2.c: New test.\n\t* gcc.target/aarch64/torture/simd-abi-4.c: Check .variant_pcs support.\n\t* lib/target-supports.exp (check_effective_target_aarch64_variant_pcs):\n\tNew.\n\nFrom-SVN: r271869", "tree": {"sha": "d2e8c1b20e35eb49d15f47cbea6df83c80483f66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d2e8c1b20e35eb49d15f47cbea6df83c80483f66"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b07fc91cc47769f1fdabf31a3c8f942caf49d873", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b07fc91cc47769f1fdabf31a3c8f942caf49d873", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b07fc91cc47769f1fdabf31a3c8f942caf49d873", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b07fc91cc47769f1fdabf31a3c8f942caf49d873/comments", "author": {"login": "nsz-arm", "id": 30925343, "node_id": "MDQ6VXNlcjMwOTI1MzQz", "avatar_url": "https://avatars.githubusercontent.com/u/30925343?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nsz-arm", "html_url": "https://github.com/nsz-arm", "followers_url": "https://api.github.com/users/nsz-arm/followers", "following_url": "https://api.github.com/users/nsz-arm/following{/other_user}", "gists_url": "https://api.github.com/users/nsz-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/nsz-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nsz-arm/subscriptions", "organizations_url": "https://api.github.com/users/nsz-arm/orgs", "repos_url": "https://api.github.com/users/nsz-arm/repos", "events_url": "https://api.github.com/users/nsz-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/nsz-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bf5824f9282b88c2f94d76b2999a790252d0df9d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf5824f9282b88c2f94d76b2999a790252d0df9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf5824f9282b88c2f94d76b2999a790252d0df9d"}], "stats": {"total": 192, "additions": 191, "deletions": 1}, "files": [{"sha": "5833d7fc8ff1151dac85c0551666f62eae024dfa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b07fc91cc47769f1fdabf31a3c8f942caf49d873/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b07fc91cc47769f1fdabf31a3c8f942caf49d873/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b07fc91cc47769f1fdabf31a3c8f942caf49d873", "patch": "@@ -1,3 +1,14 @@\n+2019-06-03  Szabolcs Nagy  <szabolcs.nagy@arm.com>\n+\n+\t* config/aarch64/aarch64-protos.h (aarch64_asm_output_alias): Declare.\n+\t(aarch64_asm_output_external): Declare.\n+\t* config/aarch64/aarch64.c (aarch64_asm_output_variant_pcs): New.\n+\t(aarch64_declare_function_name): Call aarch64_asm_output_variant_pcs.\n+\t(aarch64_asm_output_alias): New.\n+\t(aarch64_asm_output_external): New.\n+\t* config/aarch64/aarch64.h (ASM_OUTPUT_DEF_FROM_DECLS): Define.\n+\t(ASM_OUTPUT_EXTERNAL): Define.\n+\n 2019-06-03  Aldy Hernandez  <aldyh@redhat.com>\n \t* tree-vrp.h (value_range_base::nonzero_p): New.\n \t(value_range_base::set_nonnull): Rename to..."}, {"sha": "6dccabc8cf79dfa000c062a5c6a2ad141615efa9", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b07fc91cc47769f1fdabf31a3c8f942caf49d873/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b07fc91cc47769f1fdabf31a3c8f942caf49d873/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=b07fc91cc47769f1fdabf31a3c8f942caf49d873", "patch": "@@ -436,6 +436,8 @@ bool aarch64_is_long_call_p (rtx);\n bool aarch64_is_noplt_call_p (rtx);\n bool aarch64_label_mentioned_p (rtx);\n void aarch64_declare_function_name (FILE *, const char*, tree);\n+void aarch64_asm_output_alias (FILE *, const tree, const tree);\n+void aarch64_asm_output_external (FILE *, const tree, const char*);\n bool aarch64_legitimate_pic_operand_p (rtx);\n bool aarch64_mask_and_shift_for_ubfiz_p (scalar_int_mode, rtx, rtx);\n bool aarch64_masks_and_shift_for_bfi_p (scalar_int_mode, unsigned HOST_WIDE_INT,"}, {"sha": "263ed21442c4e028f2b6c77950dbc726cb380cd4", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b07fc91cc47769f1fdabf31a3c8f942caf49d873/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b07fc91cc47769f1fdabf31a3c8f942caf49d873/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=b07fc91cc47769f1fdabf31a3c8f942caf49d873", "patch": "@@ -15566,6 +15566,19 @@ aarch64_asm_preferred_eh_data_format (int code ATTRIBUTE_UNUSED, int global)\n    return (global ? DW_EH_PE_indirect : 0) | DW_EH_PE_pcrel | type;\n }\n \n+/* Output .variant_pcs for aarch64_vector_pcs function symbols.  */\n+\n+static void\n+aarch64_asm_output_variant_pcs (FILE *stream, const tree decl, const char* name)\n+{\n+  if (aarch64_simd_decl_p (decl))\n+    {\n+      fprintf (stream, \"\\t.variant_pcs\\t\");\n+      assemble_name (stream, name);\n+      fprintf (stream, \"\\n\");\n+    }\n+}\n+\n /* The last .arch and .tune assembly strings that we printed.  */\n static std::string aarch64_last_printed_arch_string;\n static std::string aarch64_last_printed_tune_string;\n@@ -15615,11 +15628,33 @@ aarch64_declare_function_name (FILE *stream, const char* name,\n       aarch64_last_printed_tune_string = this_tune->name;\n     }\n \n+  aarch64_asm_output_variant_pcs (stream, fndecl, name);\n+\n   /* Don't forget the type directive for ELF.  */\n   ASM_OUTPUT_TYPE_DIRECTIVE (stream, name, \"function\");\n   ASM_OUTPUT_LABEL (stream, name);\n }\n \n+/* Implement ASM_OUTPUT_DEF_FROM_DECLS.  Output .variant_pcs for aliases.  */\n+\n+void\n+aarch64_asm_output_alias (FILE *stream, const tree decl, const tree target)\n+{\n+  const char *name = XSTR (XEXP (DECL_RTL (decl), 0), 0);\n+  const char *value = IDENTIFIER_POINTER (target);\n+  aarch64_asm_output_variant_pcs (stream, decl, name);\n+  ASM_OUTPUT_DEF (stream, name, value);\n+}\n+\n+/* Implement ASM_OUTPUT_EXTERNAL.  Output .variant_pcs for undefined\n+   function symbol references.  */\n+\n+void\n+aarch64_asm_output_external (FILE *stream, const tree decl, const char* name)\n+{\n+  aarch64_asm_output_variant_pcs (stream, decl, name);\n+}\n+\n /* Triggered after a .cfi_startproc directive is emitted into the assembly file.\n    Used to output the .cfi_b_key_frame directive when signing the current\n    function with the B key.  */"}, {"sha": "bf06caa06ee65c5216493deb030784630b7ed2db", "filename": "gcc/config/aarch64/aarch64.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b07fc91cc47769f1fdabf31a3c8f942caf49d873/gcc%2Fconfig%2Faarch64%2Faarch64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b07fc91cc47769f1fdabf31a3c8f942caf49d873/gcc%2Fconfig%2Faarch64%2Faarch64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.h?ref=b07fc91cc47769f1fdabf31a3c8f942caf49d873", "patch": "@@ -516,6 +516,15 @@ extern unsigned aarch64_architecture_version;\n #define ASM_DECLARE_FUNCTION_NAME(STR, NAME, DECL)\t\\\n   aarch64_declare_function_name (STR, NAME, DECL)\n \n+/* Output assembly strings for alias definition.  */\n+#define ASM_OUTPUT_DEF_FROM_DECLS(STR, DECL, TARGET) \\\n+  aarch64_asm_output_alias (STR, DECL, TARGET)\n+\n+/* Output assembly strings for undefined extern symbols.  */\n+#undef ASM_OUTPUT_EXTERNAL\n+#define ASM_OUTPUT_EXTERNAL(STR, DECL, NAME) \\\n+  aarch64_asm_output_external (STR, DECL, NAME)\n+\n /* Output assembly strings after .cfi_startproc is emitted.  */\n #define ASM_POST_CFI_STARTPROC  aarch64_post_cfi_startproc\n "}, {"sha": "6ed70b44cd501190def399af8934e4413e2d696f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b07fc91cc47769f1fdabf31a3c8f942caf49d873/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b07fc91cc47769f1fdabf31a3c8f942caf49d873/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b07fc91cc47769f1fdabf31a3c8f942caf49d873", "patch": "@@ -1,3 +1,10 @@\n+2019-06-03  Szabolcs Nagy  <szabolcs.nagy@arm.com>\n+\n+\t* gcc.target/aarch64/pcs_attribute-2.c: New test.\n+\t* gcc.target/aarch64/torture/simd-abi-4.c: Check .variant_pcs support.\n+\t* lib/target-supports.exp (check_effective_target_aarch64_variant_pcs):\n+\tNew.\n+\n 2019-06-03  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* gcc.target/aarch64/ssadv16qi.c: Add +nodotprod to pragma."}, {"sha": "d997f52921c0afc5db348ba4dd0a8d9560b87c39", "filename": "gcc/testsuite/gcc.target/aarch64/pcs_attribute-2.c", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b07fc91cc47769f1fdabf31a3c8f942caf49d873/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fpcs_attribute-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b07fc91cc47769f1fdabf31a3c8f942caf49d873/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fpcs_attribute-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fpcs_attribute-2.c?ref=b07fc91cc47769f1fdabf31a3c8f942caf49d873", "patch": "@@ -0,0 +1,114 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target aarch64_variant_pcs } */\n+\n+/* Test that .variant_pcs is emitted for vector PCS symbol references.  */\n+\n+#define ATTR __attribute__ ((aarch64_vector_pcs))\n+\n+void f_undef_basepcs (void);\n+\n+void f_def_basepcs (void)\n+{\n+}\n+\n+ATTR void f_undef_vpcs (void);\n+\n+ATTR void f_def_vpcs (void)\n+{\n+}\n+\n+__attribute__ ((alias (\"f_def_vpcs\")))\n+ATTR void f_alias_vpcs (void);\n+\n+__attribute__ ((weak, alias (\"f_def_vpcs\")))\n+ATTR void f_weak_alias_vpcs (void);\n+\n+__attribute__ ((weak))\n+ATTR void f_weak_undef_vpcs (void);\n+\n+__attribute__ ((visibility (\"protected\")))\n+ATTR void f_protected_vpcs (void)\n+{\n+}\n+\n+__attribute__ ((visibility (\"hidden\")))\n+ATTR void f_hidden_vpcs (void)\n+{\n+}\n+\n+ATTR static void f_local_vpcs (void)\n+{\n+}\n+\n+__attribute__((weakref (\"f_undef_vpcs\")))\n+ATTR static void f_local_weakref_undef_vpcs (void);\n+\n+__attribute__((weakref (\"f_hidden_vpcs\")))\n+ATTR static void f_local_weakref_def_vpcs (void);\n+\n+ATTR void bar_undef_vpcs (void) __asm__ (\"f_undef_renamed_vpcs\");\n+\n+ATTR void bar_def_vpcs (void) __asm__ (\"f_def_renamed_vpcs\");\n+ATTR void bar_def_vpcs (void)\n+{\n+}\n+\n+static void (*f_ifunc_resolver ()) (void)\n+{\n+  return (void (*)(void))f_local_vpcs;\n+}\n+\n+__attribute__ ((ifunc (\"f_ifunc_resolver\")))\n+ATTR void f_ifunc_vpcs (void);\n+\n+__attribute__ ((visibility (\"hidden\")))\n+__attribute__ ((ifunc (\"f_ifunc_resolver\")))\n+ATTR void f_hidden_ifunc_vpcs (void);\n+\n+__attribute__ ((ifunc (\"f_ifunc_resolver\")))\n+ATTR static void f_local_ifunc_vpcs (void);\n+\n+void (*refs_basepcs[]) (void) = {\n+\tf_undef_basepcs,\n+\tf_def_basepcs,\n+};\n+\n+void (*ATTR refs_vpcs[]) (void) = {\n+\tf_undef_vpcs,\n+\tf_def_vpcs,\n+\tf_alias_vpcs,\n+\tf_weak_alias_vpcs,\n+\tf_weak_undef_vpcs,\n+\tf_protected_vpcs,\n+\tf_hidden_vpcs,\n+\tf_local_vpcs,\n+\tf_local_weakref_undef_vpcs,\n+\tf_local_weakref_def_vpcs,\n+\tbar_undef_vpcs,\n+\tbar_def_vpcs,\n+\tf_ifunc_vpcs,\n+\tf_hidden_ifunc_vpcs,\n+\tf_local_ifunc_vpcs,\n+};\n+\n+/* Note: local symbols don't need .variant_pcs, but gcc generates it, so\n+   we check them here.  An undefined weakref does not show up in the\n+   symbol table, only the target symbol, so it does not need .variant_pcs.  */\n+\n+/* { dg-final { scan-assembler-not {\\.variant_pcs\\tf_undef_basepcs} } } */\n+/* { dg-final { scan-assembler-not {\\.variant_pcs\\tf_def_basepcs} } } */\n+/* { dg-final { scan-assembler-times {\\.variant_pcs\\tf_undef_vpcs} 1 } } */\n+/* { dg-final { scan-assembler-times {\\.variant_pcs\\tf_def_vpcs} 1 } } */\n+/* { dg-final { scan-assembler-times {\\.variant_pcs\\tf_alias_vpcs} 1 } } */\n+/* { dg-final { scan-assembler-times {\\.variant_pcs\\tf_weak_alias_vpcs} 1 } } */\n+/* { dg-final { scan-assembler-times {\\.variant_pcs\\tf_weak_undef_vpcs} 1 } } */\n+/* { dg-final { scan-assembler-times {\\.variant_pcs\\tf_protected_vpcs} 1 } } */\n+/* { dg-final { scan-assembler-times {\\.variant_pcs\\tf_hidden_vpcs} 1 } } */\n+/* { dg-final { scan-assembler-times {\\.variant_pcs\\tf_local_vpcs} 1 } } */\n+/* { dg-final { scan-assembler-not {\\.variant_pcs\\tf_local_weakref_undef_vpcs} } } */\n+/* { dg-final { scan-assembler-times {\\.variant_pcs\\tf_local_weakref_def_vpcs} 1 } } */\n+/* { dg-final { scan-assembler-times {\\.variant_pcs\\tf_undef_renamed_vpcs} 1 } } */\n+/* { dg-final { scan-assembler-times {\\.variant_pcs\\tf_def_renamed_vpcs} 1 } } */\n+/* { dg-final { scan-assembler-times {\\.variant_pcs\\tf_ifunc_vpcs} 1 } } */\n+/* { dg-final { scan-assembler-times {\\.variant_pcs\\tf_hidden_ifunc_vpcs} 1 } } */\n+/* { dg-final { scan-assembler-times {\\.variant_pcs\\tf_local_ifunc_vpcs} 1 } } */"}, {"sha": "b8d7ce09b74f08940ae0cdb687313c7921536542", "filename": "gcc/testsuite/gcc.target/aarch64/torture/simd-abi-4.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b07fc91cc47769f1fdabf31a3c8f942caf49d873/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Ftorture%2Fsimd-abi-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b07fc91cc47769f1fdabf31a3c8f942caf49d873/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Ftorture%2Fsimd-abi-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Ftorture%2Fsimd-abi-4.c?ref=b07fc91cc47769f1fdabf31a3c8f942caf49d873", "patch": "@@ -1,4 +1,5 @@\n-/* dg-do run */\n+/* { dg-do run } */\n+/* { dg-require-effective-target aarch64_variant_pcs } */\n /* { dg-additional-options \"-std=c99\" }  */\n \n "}, {"sha": "916be2b607a328d60518df575d297df869082a10", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b07fc91cc47769f1fdabf31a3c8f942caf49d873/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b07fc91cc47769f1fdabf31a3c8f942caf49d873/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=b07fc91cc47769f1fdabf31a3c8f942caf49d873", "patch": "@@ -8669,6 +8669,17 @@ proc check_effective_target_aarch64_large { } {\n     }\n }\n \n+# Return 1 if the assembler accepts the aarch64 .variant_pcs directive.\n+\n+proc check_effective_target_aarch64_variant_pcs { } {\n+    if { [istarget aarch64*-*-*] } {\n+\treturn [check_no_compiler_messages aarch64_variant_pcs object {\n+\t    __asm__ (\".variant_pcs foo\");\n+\t}]\n+    } else {\n+\treturn 0\n+    }\n+}\n \n # Return 1 if this is a reduced AVR Tiny core.  Such cores have different\n # register set, instruction set, addressing capabilities and ABI."}]}