{"sha": "967a322edecf6d8ef8ab58ff7a50cf58c26e7de6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTY3YTMyMmVkZWNmNmQ4ZWY4YWI1OGZmN2E1MGNmNThjMjZlN2RlNg==", "commit": {"author": {"name": "Alexandre Oliva", "email": "oliva@adacore.com", "date": "2019-08-16T03:38:49Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2019-08-16T03:38:49Z"}, "message": "i386/asm-4 test: use amd64's natural addressing mode on all OSs\n\ngcc.target/i386/asm-4.c uses amd64's natural PC-relative addressing\nmode on a single platform, using the 32-bit absolute addressing mode\nelsewhere.  There's no point in giving up amd64's natural addressing\nmode and insisting on the 32-bit one when we're targeting amd64, and\nhaving to make explicit exceptions for systems where that's found not\nto work for whatever reason.  If we just use the best-suited way to\ntake the address of a function behind the compiler's back on each\ntarget variant, we're less likely to hit unexpected failures.\n\n\nfor  gcc/testsuite/ChangeLog\n\n\t* gcc.target/i386/asm-4.c: Use amd64 natural addressing mode\n\ton all __LP64__ targets.\n\nFrom-SVN: r274559", "tree": {"sha": "cc70600eb024f8ddd5773eb3f28903ad234557d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cc70600eb024f8ddd5773eb3f28903ad234557d6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/967a322edecf6d8ef8ab58ff7a50cf58c26e7de6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/967a322edecf6d8ef8ab58ff7a50cf58c26e7de6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/967a322edecf6d8ef8ab58ff7a50cf58c26e7de6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/967a322edecf6d8ef8ab58ff7a50cf58c26e7de6/comments", "author": null, "committer": null, "parents": [{"sha": "1ce521ece9a514dd8c5a3baa6e66bab928fd5e7c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ce521ece9a514dd8c5a3baa6e66bab928fd5e7c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ce521ece9a514dd8c5a3baa6e66bab928fd5e7c"}], "stats": {"total": 5, "additions": 4, "deletions": 1}, "files": [{"sha": "d75c646ba34791c9eae8568c08ff8645cfc63065", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/967a322edecf6d8ef8ab58ff7a50cf58c26e7de6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/967a322edecf6d8ef8ab58ff7a50cf58c26e7de6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=967a322edecf6d8ef8ab58ff7a50cf58c26e7de6", "patch": "@@ -1,5 +1,8 @@\n 2019-08-16  Alexandre Oliva <oliva@adacore.com>\n \n+\t* gcc.target/i386/asm-4.c: Use amd64 natural addressing mode\n+\ton all __LP64__ targets.\n+\n \t* gcc.target/arc/interrupt-6.c: Use __builtin_alloca, require\n \teffective target support for alloca, drop include of alloca.h.\n \t* gcc.target/i386/pr80969-3.c: Likewise."}, {"sha": "69dd1d3df0bf904265ac1bf4ff51d234b24cfb7a", "filename": "gcc/testsuite/gcc.target/i386/asm-4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/967a322edecf6d8ef8ab58ff7a50cf58c26e7de6/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fasm-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/967a322edecf6d8ef8ab58ff7a50cf58c26e7de6/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fasm-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fasm-4.c?ref=967a322edecf6d8ef8ab58ff7a50cf58c26e7de6", "patch": "@@ -29,7 +29,7 @@ baz (void)\n {\n   /* Darwin loads 64-bit regions above the 4GB boundary so\n      we need to use this instead.  */\n-#if defined (__LP64__) && defined (__MACH__)\n+#if defined (__LP64__)\n   __asm (\"leaq foo(%%rip), %0\" : \"=r\" (fn));\n #else\n   __asm (\"movl $foo, %k0\" : \"=r\" (fn));"}]}