{"sha": "c73964b2fbce812d4ef49cdcb82b57a1550cfffa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzczOTY0YjJmYmNlODEyZDRlZjQ5Y2RjYjgyYjU3YTE1NTBjZmZmYQ==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-08-08T22:54:56Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-08-08T22:54:56Z"}, "message": "87th Cygnus<->FSF quick merge\n\nFrom-SVN: r12606", "tree": {"sha": "52ddcb80dfa8e9c159b836a1a31024a019afd0e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/52ddcb80dfa8e9c159b836a1a31024a019afd0e4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c73964b2fbce812d4ef49cdcb82b57a1550cfffa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c73964b2fbce812d4ef49cdcb82b57a1550cfffa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c73964b2fbce812d4ef49cdcb82b57a1550cfffa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c73964b2fbce812d4ef49cdcb82b57a1550cfffa/comments", "author": null, "committer": null, "parents": [{"sha": "581bc4de55b720e9d4b53d7ca6297d0f07b622ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/581bc4de55b720e9d4b53d7ca6297d0f07b622ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/581bc4de55b720e9d4b53d7ca6297d0f07b622ca"}], "stats": {"total": 5772, "additions": 3152, "deletions": 2620}, "files": [{"sha": "f65965add97c51ff3d420ff081c9e3a5479d3207", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c73964b2fbce812d4ef49cdcb82b57a1550cfffa/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c73964b2fbce812d4ef49cdcb82b57a1550cfffa/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=c73964b2fbce812d4ef49cdcb82b57a1550cfffa", "patch": "@@ -3,8 +3,173 @@ Thu Aug  8 17:48:16 1996  Michael Meissner  <meissner@tiktok.cygnus.com>\n \t* decl2.c (import_export_vtable): Delete code that disabled vtable\n  \theuristic on systems with ASM_OUTPUT_EXTERNAL.\n \n+Wed Aug  7 12:44:11 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* typeck.c (build_x_function_call): Handle static call context\n+\tbetter.\n+\n+\t* decl.c (finish_function): Set the DECL_CONTEXT of the result to\n+ \tthe function, not its outer block.\n+\n+\t* call.c (build_field_call): Pass fields on to build_opfncall\n+ \tregardless of TYPE_OVERLOADS_CALL_EXPR.\n+\t(build_method_call): Pass on to build_new_method_call sooner.\n+\n+\t* typeck.c (build_ptrmemfunc): Just return what instantiate_type\n+\tgives us.\n+\t* class.c (instantiate_type): Don't put a POINTER_TYPE to\n+ \tMETHOD_TYPE on an expression.  Also make a copy of rhs instead of\n+\tmodifying it.\n+\n+Tue Aug  6 12:58:46 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* call.c (compare_ics): Handle qual_conv after lvalue_conv.\n+\t(add_builtin_candidate): Don't take enums for ++.\n+\t(build_new_method_call): Handle non-aggregates and field calls.\n+\tMove new overloading code from...\n+\t* cvt.c: Here.\n+\n+\t* decl.c (grokparms): Don't check default args in templates.\n+\n+Mon Aug  5 17:17:06 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* cvt.c (build_new_op): Fix args to build_unary_op.\n+\t(add_builtin_candidates): Don't call type_promotes_to on float.\n+\n+\t* decl.c (grokparms): Check the type of the default arg.\n+\n+\t* cvt.c (build_new_op): Pass non-overloaded cases on rather than\n+\treturning NULL_TREE.\n+\n+\t* typeck.c (build_x_binary_op): Avoid doing extra work.\n+\t(build_x_unary_op): Ditto.\n+\t(build_x_conditional_expr): Ditto.\n+\t* cvt.c (build_over_call): Return.\n+\t(add_builtin_candidate): Fix MEMBER_REF.\n+\t(build_new_op): Ditto.\n+\n+Mon Aug  5 17:07:47 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* method.c (build_overload_name): Put bug fix into code but leave\n+ \tdisabled for now so we can be bug compatible with older releases\n+ \tthat do repeats incorrectly.  In the future, we can enable it.\n+\n+Mon Aug  5 13:46:28 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* cvt.c (convert_like): Don't call build_cplus_new twice.\n+\n+\t* call.c, cp-tree.h, cvt.c, decl2.c, init.c, method.c, pt.c, typeck.c:\n+\tControl new overloading code with -fansi-overloading.\n+\n+Sun Aug  4 15:29:11 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* cvt.c (build_over_call): Call build_cplus_new.\n+\t* call.c (build_method_call): Ditto.\n+\t* typeck.c (build_function_call_real): Ditto.\n+\t(build_conditional_expr): If both operands are TARGET_EXPRs, wrap\n+\tthe COND_EXPR in a TARGET_EXPR so they use the same slot.\n+\n+\t* cvt.c (build_up_reference): Propagate INDIRECT_BIND to \n+\trecursive calls.\n+\t* typeck.c (complete_type): Propagate\n+ \tTYPE_NEEDS_{CONSTRUCTING,DESTRUCTOR}.\n+\n+Sat Aug  3 14:05:07 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* cvt.c (joust): More ?: kludging.  Sigh.\n+\t(build_over_call): Don't try to synthesize global fns.\n+\n+\t* search.c (lookup_conversions): Use binfo marking.\n+\n+Sat Aug  3 12:33:42 1996  Bob Manson  <manson@charmed.cygnus.com>\n+\n+\t* search.c (build_mi_matrix): Use the correct value of cid\n+\twhen determining the new mi_size.\n+\n+Sat Aug  3 01:27:41 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* cvt.c (add_builtin_candidates): Do consider type conversion ops\n+\tfor the first parms of += et al.\n+\t(strip_top_quals): New fn.\n+\t(reference_binding): Use it instead of TYPE_MAIN_VARIANT.\n+\t(implicit_conversion): Ditto.\n+\t(add_builtin_candidates): Be careful about arrays.\n+\t(build_new_method_call): Handle vtable optimization.\n+\n+Fri Aug  2 01:26:59 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* cp-tree.h (LOOKUP_NO_TEMP_BIND): New flag.\n+\t* cvt.c (reference_binding): Use it.\n+\t(implicit_conversion): Use it.\n+\t(add_builtin_candidate, COND_EXPR): Use it.\n+\n+\t* cvt.c (build_new_function_call): Check for error args.\n+\n+\t* typeck.c (comptypes): Just check DERIVED_FROM_P, not UNIQUELY.\n+\n+\t* gxx.gperf: Add __null.\n+\t* hash.h: Regenerate.\n+\t* lex.h: Add RID_NULL.\n+\t* lex.c (init_lex): Create null_pointer_node here, stick it in\n+ \tRID_NULL.\n+\t* decl.c (init_decl_processing): Still set its type here.\n+\t* cvt.c (cp_convert_to_pointer): Don't produce null_pointer_node.\n+\t(convert_to_pointer_force): Ditto.\n+\t(null_ptr_cst_p): Check for null_pointer_node; only accept (void*)0\n+\tif (! pedantic).\n+\t* call.c (convert_harshness): Use null_ptr_cst_p.\n+\t* typeck.c (convert_for_assignment): Ditto.  Don't produce\n+\tnull_pointer_node.\n+\n+\t* error.c (args_as_string): Handle lists of actual args, too.\n+\t* cvt.c (null_ptr_cst): Support (void*)0 for now.\n+\t(build_user_type_conversion_1): Improve diagnostics.\n+\t(build_new_function_call): Likewise.\n+\t(build_object_call): Likewise.\n+\t(build_new_method_call): Likewise.  Move call before def diagnostic...\n+\t(build_over_call): Here.\n+\n+\t* cvt.c (build_new_method_call): Don't complain about no match if\n+ \tLOOKUP_SPECULATIVELY.\n+\t(build_over_call): Fix 'this' for virtual fn.\n+\t(build_new_method_call): Add diagnostic.\n+\n+Thu Aug  1 16:45:09 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* cvt.c (add_function_candidate): Expect 'this' and 'in_chrg' for\n+ \tconstructors to be passed in.\n+\t(build_over_call): Likewise.\n+\t(build_user_type_conversion_1): Pass them in.\n+\t(convert_like): Likewise.\n+\t(build_object_call): Handle overloaded conversions.\n+\t(build_over_call): Pass the right args to build_vfn_ref.\n+\t(standard_conversion): Fix pmf convs.\n+\t(joust): Handle comparing statics and non-statics.\n+\t(build_new_method_call): New fn.\n+\t* call.c (build_method_call): Call it if NEW_OVER.\n+\n+Thu Aug  1 16:06:14 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* lex.c (do_identifier): Don't use %O on IDENTIFIER_OPNAME_Ps, use\n+ \t%D instead.\n+\n+Thu Aug  1 15:24:02 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* except.c (expand_throw): Use maybe_build_cleanup_and_delete\n+ \tinstead of just maybe_build_cleanup so that we deallocate the\n+ \tthrown object.\n+\n+Thu Aug  1 15:18:00 1996  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* decl2.c (finish_prevtable_vardecl): Make non-static for pt.c's use.\n+\t* cp-tree.h (finish_prevtable_vardecl): Add decl.\n+\n Thu Aug  1 11:53:51 1996  Bob Manson  <manson@charmed.cygnus.com>\n \n+\t* pt.c (instantiate_class_template): Call complete_type. Also, if\n+ \twe're at the end of the file and we just instantiated a template\n+ \tclass with a vtable, call finish_prevtable_vardecl.\n+\n \t* error.c (dump_decl): Don't explode (or explode more gracefully\n  \tas appropriate) if the object being dumped has a null type.\n \t(dump_expr): Ditto."}, {"sha": "b81f35f21b3ffc333989a75ec3929060c49cd997", "filename": "gcc/cp/call.c", "status": "modified", "additions": 2668, "deletions": 3, "changes": 2671, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c73964b2fbce812d4ef49cdcb82b57a1550cfffa/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c73964b2fbce812d4ef49cdcb82b57a1550cfffa/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=c73964b2fbce812d4ef49cdcb82b57a1550cfffa", "patch": "@@ -508,7 +508,7 @@ convert_harshness (type, parmtype, parm)\n \n #if 1\n       if (TREE_CODE (ttl) != VOID_TYPE\n-\t  && (TREE_CODE (ttr) != VOID_TYPE || !parm || !integer_zerop (parm)))\n+\t  && (TREE_CODE (ttr) != VOID_TYPE || !parm || !null_ptr_cst_p (parm)))\n \t{\n \t  if (comp_target_types (type, parmtype, 1) <= 0)\n \t    return EVIL_RETURN (h);\n@@ -1214,7 +1214,8 @@ build_field_call (basetype_path, instance_ptr, name, parms)\n \t    return error_mark_node;\n \n \t  if (TYPE_LANG_SPECIFIC (TREE_TYPE (instance))\n-\t      && TYPE_OVERLOADS_CALL_EXPR (TREE_TYPE (instance)))\n+\t      && (TYPE_OVERLOADS_CALL_EXPR (TREE_TYPE (instance))\n+\t\t  || flag_ansi_overloading))\n \t    return build_opfncall (CALL_EXPR, LOOKUP_NORMAL, instance, parms, NULL_TREE);\n \n \t  if (TREE_CODE (TREE_TYPE (instance)) == POINTER_TYPE)\n@@ -1245,7 +1246,8 @@ build_field_call (basetype_path, instance_ptr, name, parms)\n       if (TREE_CODE (ftype) == REFERENCE_TYPE)\n \tftype = TREE_TYPE (ftype);\n \n-      if (TYPE_LANG_SPECIFIC (ftype) && TYPE_OVERLOADS_CALL_EXPR (ftype))\n+      if (TYPE_LANG_SPECIFIC (ftype)\n+\t  && (TYPE_OVERLOADS_CALL_EXPR (ftype) || flag_ansi_overloading))\n \t{\n \t  /* Make the next search for this field very short.  */\n \t  basetype = DECL_FIELD_CONTEXT (field);\n@@ -1759,6 +1761,9 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t\t\t   LOOKUP_NORMAL|LOOKUP_DESTRUCTOR, 0);\n     }\n \n+  if (flag_ansi_overloading)\n+    return build_new_method_call (instance, name, parms, basetype_path, flags);\n+\n   {\n     char *xref_name;\n     \n@@ -2621,6 +2626,8 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t\t   IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (function)));\n \n   result = build_call (function, value_type, parms);\n+  if (IS_AGGR_TYPE (value_type))\n+    result = build_cplus_new (value_type, result);\n   result = convert_from_reference (result);\n   return result;\n }\n@@ -2903,3 +2910,2661 @@ build_overload_call (fnname, parms, flags)\n {\n   return build_overload_call_real (fnname, parms, flags, (struct candidate *)0, 1);\n }\n+\n+/* New overloading code.  */\n+\n+struct z_candidate {\n+  tree fn;\n+  tree convs;\n+  tree second_conv;\n+  int viable;\n+  tree basetype_path;\n+  tree template;\n+  struct z_candidate *next;\n+};\n+\n+#define IDENTITY_RANK 0\n+#define EXACT_RANK 1\n+#define PROMO_RANK 2\n+#define STD_RANK 3\n+#define PBOOL_RANK 4\n+#define USER_RANK 5\n+#define ELLIPSIS_RANK 6\n+\n+#define ICS_RANK(NODE)\t\t\t\t\\\n+  (ICS_ELLIPSIS_FLAG (NODE) ? ELLIPSIS_RANK\t\\\n+   : ICS_USER_FLAG (NODE) ? USER_RANK\t\t\\\n+   : ICS_STD_RANK (NODE))\n+\n+#define ICS_STD_RANK(NODE) TREE_COMPLEXITY (NODE)\n+\n+#define ICS_USER_FLAG(NODE) TREE_LANG_FLAG_0 (NODE)\n+#define ICS_ELLIPSIS_FLAG(NODE) TREE_LANG_FLAG_1 (NODE)\n+\n+#define USER_CONV_FN(NODE) TREE_OPERAND (NODE, 1)\n+\n+static struct z_candidate * build_user_type_conversion_1 ();\n+static tree convert_like ();\n+static tree build_over_call ();\n+static struct z_candidate * tourney ();\n+static void enforce_access ();\n+\n+int\n+null_ptr_cst_p (t)\n+     tree t;\n+{\n+  if (t == null_pointer_node\n+      || integer_zerop (t) && INTEGRAL_TYPE_P (TREE_TYPE (t)))\n+    return 1;\n+  /* Remove this eventually.  */\n+  if (! pedantic && TREE_TYPE (t) == ptr_type_node && integer_zerop (t))\n+    return 1;\n+  return 0;\n+}\n+\n+tree\n+build_conv (code, type, from)\n+     enum tree_code code;\n+     tree type, from;\n+{\n+  tree t = build1 (code, type, from);\n+  int rank = ICS_STD_RANK (from);\n+  switch (code)\n+    {\n+    case PTR_CONV:\n+    case PMEM_CONV:\n+    case BASE_CONV:\n+    case STD_CONV:\n+      if (rank < STD_RANK)\n+\trank = STD_RANK;\n+      break;\n+\n+    case LVALUE_CONV:\n+    case QUAL_CONV:\n+    case RVALUE_CONV:\n+      if (rank < EXACT_RANK)\n+\trank = EXACT_RANK;\n+\n+    default:\n+      break;\n+    }\n+  ICS_STD_RANK (t) = rank;\n+  ICS_USER_FLAG (t) = ICS_USER_FLAG (from);\n+  return t;\n+}\n+\n+tree\n+non_reference (t)\n+     tree t;\n+{\n+  if (TREE_CODE (t) == REFERENCE_TYPE)\n+    t = TREE_TYPE (t);\n+  return t;\n+}\n+\n+/* Returns the standard conversion path (see [conv]) from type FROM to type\n+   TO, if any.  For proper handling of null pointer constants, you must\n+   also pass the expression EXPR to convert from.  */\n+\n+tree\n+standard_conversion (to, from, expr)\n+     tree to, from, expr;\n+{\n+  enum tree_code fcode, tcode;\n+  tree conv;\n+\n+  fcode = TREE_CODE (from);\n+  tcode = TREE_CODE (to);\n+\n+  conv = build1 (IDENTITY_CONV, from, expr);\n+\n+  if (from == to)\n+    return conv;\n+\n+  if (fcode == FUNCTION_TYPE)\n+    {\n+      from = build_pointer_type (from);\n+      fcode = TREE_CODE (from);\n+      conv = build_conv (LVALUE_CONV, from, conv);\n+    }\n+  else if (fcode == ARRAY_TYPE)\n+    {\n+      from = build_pointer_type (TREE_TYPE (from));\n+      fcode = TREE_CODE (from);\n+      conv = build_conv (LVALUE_CONV, from, conv);\n+    }\n+\n+  if ((tcode == POINTER_TYPE || TYPE_PTRMEMFUNC_P (to))\n+      && expr && null_ptr_cst_p (expr))\n+    {\n+      conv = build_conv (STD_CONV, to, conv);\n+    }\n+  else if (tcode == POINTER_TYPE && fcode == POINTER_TYPE)\n+    {\n+      enum tree_code ufcode = TREE_CODE (TREE_TYPE (from));\n+      enum tree_code utcode = TREE_CODE (TREE_TYPE (to));\n+\n+      if (comptypes (TYPE_MAIN_VARIANT (TREE_TYPE (from)),\n+\t\t     TYPE_MAIN_VARIANT (TREE_TYPE (to)), 1))\n+\t/* OK for now */;\n+      else if (utcode == VOID_TYPE && ufcode != OFFSET_TYPE\n+\t       && ufcode != FUNCTION_TYPE)\n+\t{\n+\t  from = build_pointer_type\n+\t    (cp_build_type_variant (void_type_node,\n+\t\t\t\t    TYPE_READONLY (TREE_TYPE (from)),\n+\t\t\t\t    TYPE_VOLATILE (TREE_TYPE (from))));\n+\t  conv = build_conv (PTR_CONV, from, conv);\n+\t}\n+      else if (ufcode == OFFSET_TYPE && utcode == OFFSET_TYPE)\n+\t{\n+\t  tree fbase = TYPE_OFFSET_BASETYPE (TREE_TYPE (from));\n+\t  tree tbase = TYPE_OFFSET_BASETYPE (TREE_TYPE (to));\n+\n+\t  if (DERIVED_FROM_P (fbase, tbase)\n+\t      && (comptypes (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (from))),\n+\t\t\t     TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (to))),\n+\t\t\t     1)))\n+\t    {\n+\t      from = build_offset_type (tbase, TREE_TYPE (TREE_TYPE (from)));\n+\t      from = build_pointer_type (from);\n+\t      conv = build_conv (PMEM_CONV, from, conv);\n+\t    }\n+\t  else\n+\t    return 0;\n+\t}\n+      else if (IS_AGGR_TYPE (TREE_TYPE (from))\n+\t       && IS_AGGR_TYPE (TREE_TYPE (to)))\n+\t{\n+\t  if (DERIVED_FROM_P (TREE_TYPE (to), TREE_TYPE (from)))\n+\t    {\n+\t      from = cp_build_type_variant (TREE_TYPE (to),\n+\t\t\t\t\t    TYPE_READONLY (TREE_TYPE (from)),\n+\t\t\t\t\t    TYPE_VOLATILE (TREE_TYPE (from)));\n+\t      from = build_pointer_type (from);\n+\t      conv = build_conv (PTR_CONV, from, conv);\n+\t    }\n+\t  else\n+\t    return 0;\n+\t}\n+      else\n+\treturn 0;\n+\n+      if (! comptypes (from, to, 1))\n+\t{\n+\t  if (! comp_ptr_ttypes (TREE_TYPE (to), TREE_TYPE (from)))\n+\t    return 0;\n+\n+\t  from = to;\n+\t  conv = build_conv (QUAL_CONV, from, conv);\n+\t}\n+    }\n+  else if (TYPE_PTRMEMFUNC_P (to) && TYPE_PTRMEMFUNC_P (from))\n+    {\n+      tree fromfn = TREE_TYPE (TYPE_PTRMEMFUNC_FN_TYPE (from));\n+      tree tofn = TREE_TYPE (TYPE_PTRMEMFUNC_FN_TYPE (to));\n+      tree fbase = TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (fromfn)));\n+      tree tbase = TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (tofn)));\n+\n+      if (! DERIVED_FROM_P (fbase, tbase)\n+\t  || ! comptypes (TREE_TYPE (fromfn), TREE_TYPE (tofn), 1)\n+\t  || ! compparms (TREE_CHAIN (TYPE_ARG_TYPES (fromfn)),\n+\t\t\t  TREE_CHAIN (TYPE_ARG_TYPES (tofn)), 1)\n+\t  || TYPE_READONLY (fbase) != TYPE_READONLY (tbase)\n+\t  || TYPE_VOLATILE (fbase) != TYPE_VOLATILE (tbase))\n+\treturn 0;\n+\n+      from = cp_build_type_variant (tbase, TYPE_READONLY (fbase),\n+\t\t\t\t    TYPE_VOLATILE (fbase));\n+      from = build_cplus_method_type (from, TREE_TYPE (fromfn),\n+\t\t\t\t      TREE_CHAIN (TYPE_ARG_TYPES (fromfn)));\n+      from = build_ptrmemfunc_type (build_pointer_type (from));\n+      conv = build_conv (PMEM_CONV, from, conv);\n+    }\n+  else if (tcode == BOOLEAN_TYPE)\n+    {\n+      if (! (INTEGRAL_CODE_P (fcode) || fcode == REAL_TYPE\n+\t     || fcode == POINTER_TYPE || TYPE_PTRMEMFUNC_P (from)))\n+\treturn 0;\n+\n+      conv = build_conv (STD_CONV, to, conv);\n+      if (fcode == POINTER_TYPE || TYPE_PTRMEMFUNC_P (from)\n+\t  && ICS_STD_RANK (conv) < PBOOL_RANK)\n+\tICS_STD_RANK (conv) = PBOOL_RANK;\n+    }\n+  /* We don't check for ENUMERAL_TYPE here because there are no standard\n+     conversions to enum type.  */\n+  else if (tcode == INTEGER_TYPE || tcode == BOOLEAN_TYPE\n+\t   || tcode == REAL_TYPE)\n+    {\n+      if (! (INTEGRAL_CODE_P (fcode) || fcode == REAL_TYPE))\n+\treturn 0;\n+      conv = build_conv (STD_CONV, to, conv);\n+\n+      /* Give this a better rank if it's a promotion.  */\n+      if (to == type_promotes_to (from)\n+\t  && ICS_STD_RANK (TREE_OPERAND (conv, 0)) <= PROMO_RANK)\n+\tICS_STD_RANK (conv) = PROMO_RANK;\n+    }\n+  else if (IS_AGGR_TYPE (to) && IS_AGGR_TYPE (from)\n+\t   && DERIVED_FROM_P (to, from))\n+    conv = build_conv (BASE_CONV, to, conv);\n+  else\n+    return 0;\n+\n+  return conv;\n+}\n+\n+tree\n+strip_top_quals (t)\n+     tree t;\n+{\n+  if (TREE_CODE (t) == ARRAY_TYPE)\n+    return t;\n+  return TYPE_MAIN_VARIANT (t);\n+}\n+\n+/* Returns the conversion path from type FROM to reference type TO for\n+   purposes of reference binding.  For lvalue binding, either pass a\n+   reference type to FROM or an lvalue expression to EXPR.\n+\n+   Currently does not distinguish in the generated trees between binding to\n+   an lvalue and a temporary.  Should it?  */\n+\n+tree\n+reference_binding (rto, from, expr, flags)\n+     tree rto, from, expr;\n+     int flags;\n+{\n+  tree conv;\n+  int lvalue = 1;\n+  tree to = TREE_TYPE (rto);\n+\n+  if (TREE_CODE (from) == REFERENCE_TYPE)\n+    from = TREE_TYPE (from);\n+  else if (! expr || ! real_lvalue_p (expr))\n+    lvalue = 0;\n+\n+  if (lvalue\n+      && TYPE_READONLY (to) >= TYPE_READONLY (from)\n+      && TYPE_VOLATILE (to) >= TYPE_VOLATILE (from))\n+    {\n+      conv = build1 (IDENTITY_CONV, from, expr);\n+\n+      if (TYPE_MAIN_VARIANT (to) == TYPE_MAIN_VARIANT (from))\n+\tconv = build_conv (REF_BIND, rto, conv);\n+      else if (IS_AGGR_TYPE (to) && IS_AGGR_TYPE (from)\n+\t       && DERIVED_FROM_P (to, from))\n+\t{\n+\t  conv = build_conv (REF_BIND, rto, conv);\n+\t  ICS_STD_RANK (conv) = STD_RANK;\n+\t}\n+      else\n+\tconv = NULL_TREE;\n+    }\n+  else\n+    conv = NULL_TREE;\n+\n+  if (! conv && TYPE_READONLY (to) && ! TYPE_VOLATILE (to)\n+      && (flags & LOOKUP_NO_TEMP_BIND) == 0)\n+    {\n+      conv = standard_conversion\n+\t(TYPE_MAIN_VARIANT (to), strip_top_quals (from), expr);\n+      if (conv)\n+\t{\n+\t  conv = build_conv (REF_BIND, rto, conv);\n+\n+\t  /* Bind directly to a base subobject of a class rvalue.  */\n+\t  if (TREE_CODE (TREE_OPERAND (conv, 0)) == BASE_CONV)\n+\t    TREE_OPERAND (conv, 0) = TREE_OPERAND (TREE_OPERAND (conv, 0), 0);\n+\t}\n+    }\n+\n+  return conv;\n+}\n+\n+/* Returns the implicit conversion sequence (see [over.ics]) from type FROM\n+   to type TO.  The optional expression EXPR may affect the conversion.\n+   FLAGS are the usual overloading flags.  Only LOOKUP_NO_CONVERSION is\n+   significant.  */\n+\n+tree\n+implicit_conversion (to, from, expr, flags)\n+     tree to, from, expr;\n+     int flags;\n+{\n+  tree conv;\n+  struct z_candidate *cand;\n+\n+  if (expr && type_unknown_p (expr))\n+    {\n+      expr = instantiate_type (to, expr, 0);\n+      if (expr == error_mark_node)\n+\treturn 0;\n+      from = TREE_TYPE (expr);\n+    }\n+\n+  if (TREE_CODE (to) == REFERENCE_TYPE)\n+    conv = reference_binding (to, from, expr, flags);\n+  else\n+    conv = standard_conversion\n+      (TYPE_MAIN_VARIANT (non_reference (to)),\n+       strip_top_quals (non_reference (from)), expr);\n+\n+  if (conv)\n+    {\n+      if (TREE_CODE (conv) == IDENTITY_CONV && IS_AGGR_TYPE (to)\n+\t  && (TREE_CODE (from) == REFERENCE_TYPE || (expr && real_lvalue_p (expr))))\n+\tconv = build_conv (RVALUE_CONV, to, conv);\n+    }\n+  else if ((IS_AGGR_TYPE (non_reference (from))\n+\t    || IS_AGGR_TYPE (non_reference (to)))\n+\t   && (flags & LOOKUP_NO_CONVERSION) == 0)\n+    {\n+      if (TREE_CODE (to) == REFERENCE_TYPE\n+\t  && TYPE_READONLY (TREE_TYPE (to))\n+\t  && ! TYPE_VOLATILE (TREE_TYPE (to))\n+\t  && (flags & LOOKUP_NO_TEMP_BIND) == 0)\n+\t{\n+\t  cand = build_user_type_conversion_1\n+\t    (TYPE_MAIN_VARIANT (TREE_TYPE (to)), expr, LOOKUP_ONLYCONVERTING);\n+\t  if (cand)\n+\t    conv = build_conv (REF_BIND, to, cand->second_conv);\n+\t}\n+      else\n+\t{\n+\t  cand = build_user_type_conversion_1\n+\t    (to, expr, LOOKUP_ONLYCONVERTING);\n+\t  if (cand)\n+\t    conv = cand->second_conv;\n+\t}\n+    }\n+\n+  return conv;\n+}\n+\n+/* Create an overload candidate for the function or method FN called with\n+   the argument list ARGLIST and add it to CANDIDATES.  FLAGS is passed on\n+   to implicit_conversion.  */\n+\n+static struct z_candidate *\n+add_function_candidate (candidates, fn, arglist, flags)\n+     struct z_candidate *candidates;\n+     tree fn, arglist;\n+     int flags;\n+{\n+  tree parmlist = TYPE_ARG_TYPES (TREE_TYPE (fn));\n+  int i, len;\n+  tree convs;\n+  tree parmnode = parmlist;\n+  tree argnode = arglist;\n+  int viable = 1;\n+  struct z_candidate *cand;\n+\n+  /* The `this' and `in_chrg' arguments to constructors are not considered\n+     in overload resolution.  */\n+  if (DECL_CONSTRUCTOR_P (fn))\n+    {\n+      parmnode = TREE_CHAIN (parmnode);\n+      argnode = TREE_CHAIN (argnode);\n+      if (TYPE_USES_VIRTUAL_BASECLASSES (DECL_CONTEXT (fn)))\n+\t{\n+\t  parmnode = TREE_CHAIN (parmnode);\n+\t  argnode = TREE_CHAIN (argnode);\n+\t}\n+    }\n+\n+  len = list_length (argnode);\n+  convs = make_tree_vec (len);\n+\n+  for (i = 0; i < len; ++i)\n+    {\n+      tree arg = TREE_VALUE (argnode);\n+      tree argtype = TREE_TYPE (arg);\n+      tree t;\n+\n+      argtype = cp_build_type_variant\n+\t(argtype, TREE_READONLY (arg), TREE_THIS_VOLATILE (arg));\n+\n+      if (parmnode == void_list_node)\n+\tbreak;\n+      else if (parmnode)\n+\tt = implicit_conversion (TREE_VALUE (parmnode), argtype, arg, flags);\n+      else\n+\t{\n+\t  t = build1 (IDENTITY_CONV, argtype, arg);\n+\t  ICS_ELLIPSIS_FLAG (t) = 1;\n+\t}\n+\n+      TREE_VEC_ELT (convs, i) = t;\n+      if (! t)\n+\tbreak;\n+\n+      if (parmnode)\n+\tparmnode = TREE_CHAIN (parmnode);\n+      argnode = TREE_CHAIN (argnode);\n+    }\n+\n+  if (i < len)\n+    viable = 0;\n+\n+  /* Make sure there are default args for the rest of the parms.  */\n+  for (; parmnode && parmnode != void_list_node;\n+       parmnode = TREE_CHAIN (parmnode))\n+    if (! TREE_PURPOSE (parmnode))\n+      {\n+\tviable = 0;\n+\tbreak;\n+      }\n+\n+  cand = (struct z_candidate *) oballoc (sizeof (struct z_candidate));\n+\n+  cand->fn = fn;\n+  cand->convs = convs;\n+  cand->second_conv = NULL_TREE;\n+  cand->viable = viable;\n+  cand->basetype_path = NULL_TREE;\n+  cand->template = NULL_TREE;\n+  cand->next = candidates;\n+\n+  return cand;\n+}\n+\n+/* Create an overload candidate for the conversion function FN which will\n+   be invoked for expression OBJ, producing a pointer-to-function which\n+   will in turn be called with the argument list ARGLIST, and add it to\n+   CANDIDATES.  FLAGS is passed on to implicit_conversion.  */\n+\n+static struct z_candidate *\n+add_conv_candidate (candidates, fn, obj, arglist)\n+     struct z_candidate *candidates;\n+     tree fn, obj, arglist;\n+{\n+  tree totype = TREE_TYPE (TREE_TYPE (fn));\n+  tree parmlist = TYPE_ARG_TYPES (TREE_TYPE (totype));\n+  int i, len = list_length (arglist) + 1;\n+  tree convs = make_tree_vec (len);\n+  tree parmnode = parmlist;\n+  tree argnode = arglist;\n+  int viable = 1;\n+  struct z_candidate *cand;\n+  int flags = LOOKUP_NORMAL;\n+\n+  for (i = 0; i < len; ++i)\n+    {\n+      tree arg = i == 0 ? obj : TREE_VALUE (argnode);\n+      tree argtype = TREE_TYPE (arg);\n+      tree t;\n+\n+      argtype = cp_build_type_variant\n+\t(argtype, TREE_READONLY (arg), TREE_THIS_VOLATILE (arg));\n+\n+      if (i == 0)\n+\tt = implicit_conversion (totype, argtype, arg, flags);\n+      else if (parmnode == void_list_node)\n+\tbreak;\n+      else if (parmnode)\n+\tt = implicit_conversion (TREE_VALUE (parmnode), argtype, arg, flags);\n+      else\n+\t{\n+\t  t = build1 (IDENTITY_CONV, argtype, arg);\n+\t  ICS_ELLIPSIS_FLAG (t) = 1;\n+\t}\n+\n+      TREE_VEC_ELT (convs, i) = t;\n+      if (! t)\n+\tbreak;\n+\n+      if (i == 0)\n+\tcontinue;\n+\n+      if (parmnode)\n+\tparmnode = TREE_CHAIN (parmnode);\n+      argnode = TREE_CHAIN (argnode);\n+    }\n+\n+  if (i < len)\n+    viable = 0;\n+\n+  for (; parmnode && parmnode != void_list_node;\n+       parmnode = TREE_CHAIN (parmnode))\n+    if (! TREE_PURPOSE (parmnode))\n+      {\n+\tviable = 0;\n+\tbreak;\n+      }\n+\n+  cand = (struct z_candidate *) oballoc (sizeof (struct z_candidate));\n+\n+  cand->fn = fn;\n+  cand->convs = convs;\n+  cand->second_conv = NULL_TREE;\n+  cand->viable = viable;\n+  cand->basetype_path = NULL_TREE;\n+  cand->template = NULL_TREE;\n+  cand->next = candidates;\n+\n+  return cand;\n+}\n+\n+int\n+ptr_complete_ob (t)\n+     tree t;\n+{\n+  return (TREE_CODE (t) == POINTER_TYPE\n+\t  && TREE_CODE (TREE_TYPE (t)) != OFFSET_TYPE\n+\t  && TREE_CODE (TREE_TYPE (t)) != FUNCTION_TYPE\n+\t  && TREE_CODE (TREE_TYPE (t)) != VOID_TYPE\n+\t  && TYPE_SIZE (complete_type (TREE_TYPE (t))) != NULL_TREE);\n+}\n+\n+#define TYPE_PTRMEM_P(NODE)\t\t\t\t\t\\\n+  (TREE_CODE (NODE) == POINTER_TYPE\t\t\t\t\\\n+   && TREE_CODE (TREE_TYPE (NODE)) == OFFSET_TYPE)\n+#define TYPE_PTR_P(NODE)\t\t\t\t\\\n+  (TREE_CODE (NODE) == POINTER_TYPE\t\t\t\\\n+   && TREE_CODE (TREE_TYPE (NODE)) != OFFSET_TYPE)\n+#define TYPE_PTROB_P(NODE)\t\t\t\t\t\t\\\n+  (TYPE_PTR_P (NODE) && TREE_CODE (TREE_TYPE (NODE)) != FUNCTION_TYPE\t\\\n+   && TREE_CODE (TREE_TYPE (NODE)) != VOID_TYPE)\n+\n+static struct z_candidate *\n+build_builtin_candidate (candidates, fnname, type1, type2,\n+\t\t\t args, argtypes, flags)\n+     struct z_candidate *candidates;\n+     tree fnname, type1, type2, *args, *argtypes;\n+     int flags;\n+\n+{\n+  tree t, convs;\n+  int viable = 1, i;\n+  struct z_candidate *cand;\n+  tree types[2];\n+\n+  types[0] = type1;\n+  types[1] = type2;\n+\n+  convs = make_tree_vec (args[2] ? 3 : (args[1] ? 2 : 1));\n+\n+  for (i = 0; i < 2; ++i)\n+    {\n+      if (! args[i])\n+\tbreak;\n+\n+      t = implicit_conversion (types[i], argtypes[i], args[i], flags);\n+      if (! t)\n+\t{\n+\t  viable = 0;\n+\t  /* We need something for printing the candidate.  */\n+\t  t = build1 (IDENTITY_CONV, types[i], NULL_TREE);\n+\t}\n+      TREE_VEC_ELT (convs, i) = t;\n+    }\n+\n+  /* For COND_EXPR we rearranged the arguments; undo that now.  */\n+  if (args[2])\n+    {\n+      TREE_VEC_ELT (convs, 2) = TREE_VEC_ELT (convs, 1);\n+      TREE_VEC_ELT (convs, 1) = TREE_VEC_ELT (convs, 0);\n+      t = implicit_conversion (boolean_type_node, argtypes[2], args[2], flags);\n+      if (t)\n+\tTREE_VEC_ELT (convs, 0) = t;\n+      else\n+\tviable = 0;\n+    }      \n+\n+  cand = (struct z_candidate *) oballoc (sizeof (struct z_candidate));\n+\n+  cand->fn = fnname;\n+  cand->convs = convs;\n+  cand->second_conv = NULL_TREE;\n+  cand->viable = viable;\n+  cand->basetype_path = NULL_TREE;\n+  cand->template = NULL_TREE;\n+  cand->next = candidates;\n+\n+  return cand;\n+}\n+\n+int\n+is_complete (t)\n+     tree t;\n+{\n+  return TYPE_SIZE (complete_type (t)) != NULL_TREE;\n+}\n+\n+/* Create any builtin operator overload candidates for the operator in\n+   question given the converted operand types TYPE1 and TYPE2.  The other\n+   args are passed through from add_builtin_candidates to\n+   build_builtin_candidate.  */\n+\n+static struct z_candidate *\n+add_builtin_candidate (candidates, code, code2, fnname, type1, type2,\n+\t\t       args, argtypes, flags)\n+     struct z_candidate *candidates;\n+     enum tree_code code, code2;\n+     tree fnname, type1, type2, *args, *argtypes;\n+     int flags;\n+{\n+  switch (code)\n+    {\n+    case POSTINCREMENT_EXPR:\n+    case POSTDECREMENT_EXPR:\n+      args[1] = integer_zero_node;\n+      type2 = integer_type_node;\n+    }\n+\n+  switch (code)\n+    {\n+\n+/* 4 For every pair T, VQ), where T is an arithmetic or  enumeration  type,\n+     and  VQ  is  either  volatile or empty, there exist candidate operator\n+     functions of the form\n+\t     VQ T&   operator++(VQ T&);\n+\t     T       operator++(VQ T&, int);\n+   5 For every pair T, VQ), where T is an enumeration type or an arithmetic\n+     type  other than bool, and VQ is either volatile or empty, there exist\n+     candidate operator functions of the form\n+\t     VQ T&   operator--(VQ T&);\n+\t     T       operator--(VQ T&, int);\n+   6 For every pair T, VQ), where T is  a  cv-qualified  or  cv-unqualified\n+     complete  object type, and VQ is either volatile or empty, there exist\n+     candidate operator functions of the form\n+\t     T*VQ&   operator++(T*VQ&);\n+\t     T*VQ&   operator--(T*VQ&);\n+\t     T*      operator++(T*VQ&, int);\n+\t     T*      operator--(T*VQ&, int);  */\n+\n+    case POSTDECREMENT_EXPR:\n+    case PREDECREMENT_EXPR:\n+      if (TREE_CODE (type1) == BOOLEAN_TYPE)\n+\treturn candidates;\n+    case POSTINCREMENT_EXPR:\n+    case PREINCREMENT_EXPR:\n+      if ((ARITHMETIC_TYPE_P (type1) && TREE_CODE (type1) != ENUMERAL_TYPE)\n+\t  || ptr_complete_ob (type1))\n+\t{\n+\t  type1 = build_reference_type (type1);\n+\t  break;\n+\t}\n+      return candidates;\n+\n+/* 7 For every cv-qualified or cv-unqualified complete object type T, there\n+     exist candidate operator functions of the form\n+\n+\t     T&      operator*(T*);\n+\n+   8 For every function type T, there exist candidate operator functions of\n+     the form\n+\t     T&      operator*(T*);  */\n+\n+    case INDIRECT_REF:\n+      if (TREE_CODE (type1) == POINTER_TYPE\n+\t  && (ptr_complete_ob (type1)\n+\t      || TREE_CODE (TREE_TYPE (type1)) == FUNCTION_TYPE))\n+\tbreak;\n+      return candidates;\n+\n+/* 9 For every type T, there exist candidate operator functions of the form\n+\t     T*      operator+(T*);\n+\n+   10For  every  promoted arithmetic type T, there exist candidate operator\n+     functions of the form\n+\t     T       operator+(T);\n+\t     T       operator-(T);  */\n+\n+    case CONVERT_EXPR: /* unary + */\n+      if (TREE_CODE (type1) == POINTER_TYPE\n+\t  && TREE_CODE (TREE_TYPE (type1)) != OFFSET_TYPE)\n+\tbreak;\n+    case NEGATE_EXPR:\n+      if (ARITHMETIC_TYPE_P (type1))\n+\tbreak;\n+      return candidates;\n+\n+/* 11For every promoted integral type T,  there  exist  candidate  operator\n+     functions of the form\n+\t     T       operator~(T);  */\n+\n+    case BIT_NOT_EXPR:\n+      if (INTEGRAL_TYPE_P (type1))\n+\tbreak;\n+      return candidates;\n+\n+/* 12For every quintuple C1, C2, T, CV1, CV2), where C2 is a class type, C1\n+     is the same type as C2 or is a derived class of C2, T  is  a  complete\n+     object type or a function type, and CV1 and CV2 are cv-qualifier-seqs,\n+     there exist candidate operator functions of the form\n+\t     CV12 T& operator->*(CV1 C1*, CV2 T C2::*);\n+     where CV12 is the union of CV1 and CV2.  */\n+\n+    case MEMBER_REF:\n+      if (TREE_CODE (type1) == POINTER_TYPE\n+\t  && (TYPE_PTRMEMFUNC_P (type2) || TYPE_PTRMEM_P (type2)))\n+\t{\n+\t  tree c1 = TREE_TYPE (type1);\n+\t  tree c2 = (TYPE_PTRMEMFUNC_P (type2)\n+\t\t     ? TYPE_METHOD_BASETYPE (TYPE_PTRMEMFUNC_FN_TYPE (type2))\n+\t\t     : TYPE_OFFSET_BASETYPE (TREE_TYPE (type2)));\n+\n+\t  if (IS_AGGR_TYPE (c1) && DERIVED_FROM_P (c2, c1)\n+\t      && (TYPE_PTRMEMFUNC_P (type2)\n+\t\t  || is_complete (TREE_TYPE (TREE_TYPE (type2)))))\n+\t    break;\n+\t}\n+      return candidates;\n+\n+/* 13For every pair of promoted arithmetic types L and R, there exist  can-\n+     didate operator functions of the form\n+\t     LR      operator*(L, R);\n+\t     LR      operator/(L, R);\n+\t     LR      operator+(L, R);\n+\t     LR      operator-(L, R);\n+\t     bool    operator<(L, R);\n+\t     bool    operator>(L, R);\n+\t     bool    operator<=(L, R);\n+\t     bool    operator>=(L, R);\n+\t     bool    operator==(L, R);\n+\t     bool    operator!=(L, R);\n+     where  LR  is  the  result of the usual arithmetic conversions between\n+     types L and R.\n+\n+   14For every pair of types T and I, where T  is  a  cv-qualified  or  cv-\n+     unqualified  complete  object  type and I is a promoted integral type,\n+     there exist candidate operator functions of the form\n+\t     T*      operator+(T*, I);\n+\t     T&      operator[](T*, I);\n+\t     T*      operator-(T*, I);\n+\t     T*      operator+(I, T*);\n+\t     T&      operator[](I, T*);\n+\n+   15For every T, where T is a pointer to complete object type, there exist\n+     candidate operator functions of the form112)\n+\t     ptrdiff_t operator-(T, T);\n+\n+   16For  every pointer type T, there exist candidate operator functions of\n+     the form\n+\t     bool    operator<(T, T);\n+\t     bool    operator>(T, T);\n+\t     bool    operator<=(T, T);\n+\t     bool    operator>=(T, T);\n+\t     bool    operator==(T, T);\n+\t     bool    operator!=(T, T);\n+\n+   17For every pointer to member type T,  there  exist  candidate  operator\n+     functions of the form\n+\t     bool    operator==(T, T);\n+\t     bool    operator!=(T, T);  */\n+\n+    case MINUS_EXPR:\n+      if (ptr_complete_ob (type1) && ptr_complete_ob (type2))\n+\tbreak;\n+      if (ptr_complete_ob (type1) && INTEGRAL_TYPE_P (type2))\n+\t{\n+\t  type2 = ptrdiff_type_node;\n+\t  break;\n+\t}\n+    case MULT_EXPR:\n+    case TRUNC_DIV_EXPR:\n+      if (ARITHMETIC_TYPE_P (type1) && ARITHMETIC_TYPE_P (type2))\n+\tbreak;\n+      return candidates;\n+\n+    case EQ_EXPR:\n+    case NE_EXPR:\n+      if (TYPE_PTRMEMFUNC_P (type1) && TYPE_PTRMEMFUNC_P (type2)\n+\t  || TYPE_PTRMEM_P (type1) && TYPE_PTRMEM_P (type2))\n+\tbreak;\n+      if ((TYPE_PTRMEMFUNC_P (type1) || TYPE_PTRMEM_P (type1))\n+\t  && null_ptr_cst_p (args[1]))\n+\t{\n+\t  type2 = type1;\n+\t  break;\n+\t}\n+      if ((TYPE_PTRMEMFUNC_P (type2) || TYPE_PTRMEM_P (type2))\n+\t  && null_ptr_cst_p (args[0]))\n+\t{\n+\t  type1 = type2;\n+\t  break;\n+\t}\n+    case LT_EXPR:\n+    case GT_EXPR:\n+    case LE_EXPR:\n+    case GE_EXPR:\n+    case MAX_EXPR:\n+    case MIN_EXPR:\n+      if (ARITHMETIC_TYPE_P (type1) && ARITHMETIC_TYPE_P (type2)\n+\t  || TYPE_PTR_P (type1) && TYPE_PTR_P (type2))\n+\tbreak;\n+      if (TYPE_PTR_P (type1) && null_ptr_cst_p (args[1]))\n+\t{\n+\t  type2 = type1;\n+\t  break;\n+\t}\n+      if (null_ptr_cst_p (args[0]) && TYPE_PTR_P (type2))\n+\t{\n+\t  type1 = type2;\n+\t  break;\n+\t}\n+      return candidates;\n+\n+    case PLUS_EXPR:\n+      if (ARITHMETIC_TYPE_P (type1) && ARITHMETIC_TYPE_P (type2))\n+\tbreak;\n+    case ARRAY_REF:\n+      if (INTEGRAL_TYPE_P (type1) && ptr_complete_ob (type2))\n+\t{\n+\t  type1 = ptrdiff_type_node;\n+\t  break;\n+\t}\n+      if (ptr_complete_ob (type1) && INTEGRAL_TYPE_P (type2))\n+\t{\n+\t  type2 = ptrdiff_type_node;\n+\t  break;\n+\t}\n+      return candidates;\n+\n+/* 18For  every pair of promoted integral types L and R, there exist candi-\n+     date operator functions of the form\n+\t     LR      operator%(L, R);\n+\t     LR      operator&(L, R);\n+\t     LR      operator^(L, R);\n+\t     LR      operator|(L, R);\n+\t     L       operator<<(L, R);\n+\t     L       operator>>(L, R);\n+     where LR is the result of the  usual  arithmetic  conversions  between\n+     types L and R.  */\n+\n+    case TRUNC_MOD_EXPR:\n+    case BIT_AND_EXPR:\n+    case BIT_IOR_EXPR:\n+    case BIT_XOR_EXPR:\n+    case LSHIFT_EXPR:\n+    case RSHIFT_EXPR:\n+      if (INTEGRAL_TYPE_P (type1) && INTEGRAL_TYPE_P (type2))\n+\tbreak;\n+      return candidates;\n+\n+/* 19For  every  triple  L, VQ, R), where L is an arithmetic or enumeration\n+     type, VQ is either volatile or empty, and R is a  promoted  arithmetic\n+     type, there exist candidate operator functions of the form\n+\t     VQ L&   operator=(VQ L&, R);\n+\t     VQ L&   operator*=(VQ L&, R);\n+\t     VQ L&   operator/=(VQ L&, R);\n+\t     VQ L&   operator+=(VQ L&, R);\n+\t     VQ L&   operator-=(VQ L&, R);\n+\n+   20For  every  pair T, VQ), where T is any type and VQ is either volatile\n+     or empty, there exist candidate operator functions of the form\n+\t     T*VQ&   operator=(T*VQ&, T*);\n+\n+   21For every pair T, VQ), where T is a pointer to member type and  VQ  is\n+     either  volatile or empty, there exist candidate operator functions of\n+     the form\n+\t     VQ T&   operator=(VQ T&, T);\n+\n+   22For every triple  T,  VQ,  I),  where  T  is  a  cv-qualified  or  cv-\n+     unqualified  complete object type, VQ is either volatile or empty, and\n+     I is a promoted integral type, there exist  candidate  operator  func-\n+     tions of the form\n+\t     T*VQ&   operator+=(T*VQ&, I);\n+\t     T*VQ&   operator-=(T*VQ&, I);\n+\n+   23For  every  triple  L,  VQ,  R), where L is an integral or enumeration\n+     type, VQ is either volatile or empty, and R  is  a  promoted  integral\n+     type, there exist candidate operator functions of the form\n+\n+\t     VQ L&   operator%=(VQ L&, R);\n+\t     VQ L&   operator<<=(VQ L&, R);\n+\t     VQ L&   operator>>=(VQ L&, R);\n+\t     VQ L&   operator&=(VQ L&, R);\n+\t     VQ L&   operator^=(VQ L&, R);\n+\t     VQ L&   operator|=(VQ L&, R);  */\n+\n+    case MODIFY_EXPR:\n+      switch (code2)\n+\t{\n+\tcase PLUS_EXPR:\n+\tcase MINUS_EXPR:\n+\t  if (ptr_complete_ob (type1) && INTEGRAL_TYPE_P (type2))\n+\t    {\n+\t      type2 = ptrdiff_type_node;\n+\t      break;\n+\t    }\n+\tcase MULT_EXPR:\n+\tcase TRUNC_DIV_EXPR:\n+\t  if (ARITHMETIC_TYPE_P (type1) && ARITHMETIC_TYPE_P (type2))\n+\t    break;\n+\t  return candidates;\n+\n+\tcase TRUNC_MOD_EXPR:\n+\tcase BIT_AND_EXPR:\n+\tcase BIT_IOR_EXPR:\n+\tcase BIT_XOR_EXPR:\n+\tcase LSHIFT_EXPR:\n+\tcase RSHIFT_EXPR:\n+\t  if (INTEGRAL_TYPE_P (type1) && INTEGRAL_TYPE_P (type2))\n+\t    break;\n+\t  return candidates;\n+\n+\tcase NOP_EXPR:\n+\t  if (ARITHMETIC_TYPE_P (type1) && ARITHMETIC_TYPE_P (type2))\n+\t    break;\n+\t  if ((TYPE_PTRMEMFUNC_P (type1) && TYPE_PTRMEMFUNC_P (type2))\n+\t      || (TYPE_PTR_P (type1) && TYPE_PTR_P (type2))\n+\t      || (TYPE_PTRMEM_P (type1) && TYPE_PTRMEM_P (type2))\n+\t      || ((TYPE_PTRMEMFUNC_P (type1)\n+\t\t   || TREE_CODE (type1) == POINTER_TYPE)\n+\t\t  && null_ptr_cst_p (args[1])))\n+\t    {\n+\t      type2 = type1;\n+\t      break;\n+\t    }\n+\t  return candidates;\n+\n+\tdefault:\n+\t  my_friendly_abort (367);\n+\t}\n+      type1 = build_reference_type (type1);\n+      break;\n+\n+    case COND_EXPR:\n+      /* Kludge around broken overloading rules whereby\n+\t bool ? const char& : enum is ambiguous.  */\n+      flags |= LOOKUP_NO_TEMP_BIND;\n+      if (TREE_CODE (type1) == ENUMERAL_TYPE && type1 == type2)\n+\tbreak;\n+      else if (TREE_CODE (type1) == ENUMERAL_TYPE\n+\t       || TREE_CODE (type2) == ENUMERAL_TYPE)\n+\treturn candidates;\n+      if (ARITHMETIC_TYPE_P (type1) && ARITHMETIC_TYPE_P (type2))\n+\tbreak;\n+      if (TREE_CODE (type1) == TREE_CODE (type2)\n+\t  && (TREE_CODE (type1) == REFERENCE_TYPE\n+\t      || TREE_CODE (type1) == POINTER_TYPE\n+\t      || TYPE_PTRMEMFUNC_P (type1)\n+\t      || IS_AGGR_TYPE (type1)))\n+\tbreak;\n+      if (TREE_CODE (type1) == REFERENCE_TYPE\n+\t  || TREE_CODE (type2) == REFERENCE_TYPE)\n+\treturn candidates;\n+      if (((TYPE_PTRMEMFUNC_P (type1) || TREE_CODE (type1) == POINTER_TYPE)\n+\t   && null_ptr_cst_p (args[1]))\n+\t  || IS_AGGR_TYPE (type1))\n+\t{\n+\t  type2 = type1;\n+\t  break;\n+\t}\n+      if (((TYPE_PTRMEMFUNC_P (type2) || TREE_CODE (type2) == POINTER_TYPE)\n+\t   && null_ptr_cst_p (args[0]))\n+\t  || IS_AGGR_TYPE (type2))\n+\t{\n+\t  type1 = type2;\n+\t  break;\n+\t}\n+      return candidates;\n+\n+    default:\n+      my_friendly_abort (367);\n+    }\n+\n+  /* If we're dealing with two pointer types, we need candidates\n+     for both of them.  */\n+  if (type2 && type1 != type2\n+      && TREE_CODE (type1) == TREE_CODE (type2)\n+      && (TREE_CODE (type1) == REFERENCE_TYPE\n+\t  || (TREE_CODE (type1) == POINTER_TYPE\n+\t      && TYPE_PTRMEM_P (type1) == TYPE_PTRMEM_P (type2))\n+\t  || TYPE_PTRMEMFUNC_P (type1)\n+\t  || IS_AGGR_TYPE (type1)))\n+    {\n+      candidates = build_builtin_candidate\n+\t(candidates, fnname, type1, type1, args, argtypes, flags);\n+      return build_builtin_candidate\n+\t(candidates, fnname, type2, type2, args, argtypes, flags);\n+    }\n+\n+  return build_builtin_candidate\n+    (candidates, fnname, type1, type2, args, argtypes, flags);\n+}\n+\n+tree\n+type_decays_to (type)\n+     tree type;\n+{\n+  if (TREE_CODE (type) == ARRAY_TYPE)\n+    return build_pointer_type (TREE_TYPE (type));\n+  if (TREE_CODE (type) == FUNCTION_TYPE)\n+    return build_pointer_type (type);\n+  return type;\n+}\n+\n+/* There are three conditions of builtin candidates:\n+\n+   1) bool-taking candidates.  These are the same regardless of the input.\n+   2) pointer-pair taking candidates.  These are generated for each type\n+      one of the input types converts to.\n+   3) arithmetic candidates.  According to the WP, we should generate\n+      all of these, but I'm trying not to... */\n+\n+static struct z_candidate *\n+add_builtin_candidates (candidates, code, code2, fnname, args, flags)\n+     struct z_candidate *candidates;\n+     enum tree_code code, code2;\n+     tree fnname, *args;\n+     int flags;\n+{\n+  int ref1, i;\n+  tree type, argtypes[3], types[2];\n+\n+  for (i = 0; i < 3; ++i)\n+    {\n+      if (args[i])\n+\targtypes[i]  = cp_build_type_variant\n+\t  (TREE_TYPE (args[i]), TREE_READONLY (args[i]),\n+\t   TREE_THIS_VOLATILE (args[i]));\n+      else\n+\targtypes[i] = NULL_TREE;\n+    }\n+\n+  switch (code)\n+    {\n+/* 4 For every pair T, VQ), where T is an arithmetic or  enumeration  type,\n+     and  VQ  is  either  volatile or empty, there exist candidate operator\n+     functions of the form\n+\t\t VQ T&   operator++(VQ T&);  */\n+\n+    case POSTINCREMENT_EXPR:\n+    case PREINCREMENT_EXPR:\n+    case POSTDECREMENT_EXPR:\n+    case PREDECREMENT_EXPR:\n+    case MODIFY_EXPR:\n+      ref1 = 1;\n+      break;\n+\n+/* 24There also exist candidate operator functions of the form\n+\t     bool    operator!(bool);\n+\t     bool    operator&&(bool, bool);\n+\t     bool    operator||(bool, bool);  */\n+\n+    case TRUTH_NOT_EXPR:\n+      return build_builtin_candidate\n+\t(candidates, fnname, boolean_type_node,\n+\t NULL_TREE, args, argtypes, flags);\n+\n+    case TRUTH_ORIF_EXPR:\n+    case TRUTH_ANDIF_EXPR:\n+      return build_builtin_candidate\n+\t(candidates, fnname, boolean_type_node,\n+\t boolean_type_node, args, argtypes, flags);\n+\n+    case ADDR_EXPR:\n+    case COMPOUND_EXPR:\n+    case COMPONENT_REF:\n+      return candidates;\n+\n+    default:\n+      ref1 = 0;\n+    }\n+\n+  types[0] = types[1] = NULL_TREE;\n+\n+  for (i = 0; i < 2; ++i)\n+    {\n+      if (! args[i])\n+\t;\n+      else if (IS_AGGR_TYPE (argtypes[i]))\n+\t{\n+\t  tree convs = lookup_conversions (argtypes[i]);\n+\n+\t  if (code == COND_EXPR)\n+\t    {\n+\t      if (real_lvalue_p (args[i]))\n+\t\ttypes[i] = tree_cons\n+\t\t  (NULL_TREE, build_reference_type (argtypes[i]), types[i]);\n+\n+\t      types[i] = tree_cons\n+\t\t(NULL_TREE, TYPE_MAIN_VARIANT (argtypes[i]), types[i]);\n+\t    }\n+\t\t\n+\t  else if (! convs || (i == 0 && code == MODIFY_EXPR\n+\t\t\t       && code2 == NOP_EXPR))\n+\t    return candidates;\n+\n+\t  for (; convs; convs = TREE_CHAIN (convs))\n+\t    {\n+\t      type = TREE_TYPE (TREE_TYPE (TREE_VALUE (convs)));\n+\n+\t      if (i == 0 && ref1\n+\t\t  && (TREE_CODE (type) != REFERENCE_TYPE\n+\t\t      || TYPE_READONLY (TREE_TYPE (type))))\n+\t\tcontinue;\n+\n+\t      if (code == COND_EXPR && TREE_CODE (type) == REFERENCE_TYPE)\n+\t\ttypes[i] = tree_cons (NULL_TREE, type, types[i]);\n+\n+\t      type = non_reference (type);\n+\t      if (i != 0 || ! ref1)\n+\t\t{\n+\t\t  type = TYPE_MAIN_VARIANT (type_decays_to (type));\n+\t\t  if (code == COND_EXPR && TREE_CODE (type) == ENUMERAL_TYPE)\n+\t\t    types[i] = tree_cons (NULL_TREE, type, types[i]);\n+\t\t  if (INTEGRAL_TYPE_P (type))\n+\t\t    type = type_promotes_to (type);\n+\t\t}\n+\n+\t      if (! value_member (type, types[i]))\n+\t\ttypes[i] = tree_cons (NULL_TREE, type, types[i]);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  if (code == COND_EXPR && real_lvalue_p (args[i]))\n+\t    types[i] = tree_cons\n+\t      (NULL_TREE, build_reference_type (argtypes[i]), types[i]);\n+\t  type = non_reference (argtypes[i]);\n+\t  if (i != 0 || ! ref1)\n+\t    {\n+\t      type = TYPE_MAIN_VARIANT (type_decays_to (type));\n+\t      if (code == COND_EXPR && TREE_CODE (type) == ENUMERAL_TYPE)\n+\t\ttypes[i] = tree_cons (NULL_TREE, type, types[i]);\n+\t      if (INTEGRAL_TYPE_P (type))\n+\t\ttype = type_promotes_to (type);\n+\t    }\n+\t  types[i] = tree_cons (NULL_TREE, type, types[i]);\n+\t}\n+    }\n+\n+  for (; types[0]; types[0] = TREE_CHAIN (types[0]))\n+    {\n+      if (types[1])\n+\tfor (type = types[1]; type; type = TREE_CHAIN (type))\n+\t  candidates = add_builtin_candidate\n+\t    (candidates, code, code2, fnname, TREE_VALUE (types[0]),\n+\t     TREE_VALUE (type), args, argtypes, flags);\n+      else\n+\tcandidates = add_builtin_candidate\n+\t  (candidates, code, code2, fnname, TREE_VALUE (types[0]),\n+\t   NULL_TREE, args, argtypes, flags);\n+    }\n+\n+  return candidates;\n+}\n+\n+static struct z_candidate *\n+add_template_candidate (candidates, tmpl, arglist, flags)\n+     struct z_candidate *candidates;\n+     tree tmpl, arglist;\n+     int flags;\n+{\n+  int ntparms = TREE_VEC_LENGTH (DECL_TEMPLATE_PARMS (tmpl));\n+  tree *targs = (tree *) alloca (sizeof (tree) * ntparms);\n+  struct z_candidate *cand;\n+  int i, dummy; \n+  tree fn;\n+\n+  i = type_unification (DECL_TEMPLATE_PARMS (tmpl), targs,\n+\t\t\tTYPE_ARG_TYPES (TREE_TYPE (tmpl)),\n+\t\t\targlist, &dummy, 0, 0);\n+  if (i != 0)\n+    return candidates;\n+\n+  fn = instantiate_template (tmpl, targs);\n+  if (fn == error_mark_node)\n+    return candidates;\n+\n+  cand = add_function_candidate (candidates, fn, arglist, flags);\n+  cand->template = DECL_TEMPLATE_INFO (fn);\n+  return cand;\n+}\n+\n+static int\n+any_viable (cands)\n+     struct z_candidate *cands;\n+{\n+  for (; cands; cands = cands->next)\n+    if (cands->viable)\n+      return 1;\n+  return 0;\n+}\n+\n+static struct z_candidate *\n+splice_viable (cands)\n+     struct z_candidate *cands;\n+{\n+  struct z_candidate **p = &cands;\n+\n+  for (; *p; )\n+    {\n+      if ((*p)->viable)\n+\tp = &((*p)->next);\n+      else\n+\t*p = (*p)->next;\n+    }\n+\n+  return cands;\n+}\n+\n+tree\n+build_this (obj)\n+     tree obj;\n+{\n+  /* Fix this to work on non-lvalues.  */\n+  return build_unary_op (ADDR_EXPR, obj, 0);\n+}\n+\n+static void\n+print_z_candidates (candidates)\n+     struct z_candidate *candidates;\n+{\n+  if (! candidates)\n+    return;\n+\n+  if (TREE_CODE (candidates->fn) == IDENTIFIER_NODE)\n+    {\n+      if (candidates->fn == ansi_opname [COND_EXPR])\n+\tcp_error (\"candidates are: %D(%T, %T, %T) <builtin>\", candidates->fn,\n+\t\t  TREE_TYPE (TREE_VEC_ELT (candidates->convs, 0)),\n+\t\t  TREE_TYPE (TREE_VEC_ELT (candidates->convs, 1)),\n+\t\t  TREE_TYPE (TREE_VEC_ELT (candidates->convs, 2)));\n+      else if (TREE_VEC_LENGTH (candidates->convs) == 2)\n+\tcp_error (\"candidates are: %D(%T, %T) <builtin>\", candidates->fn,\n+\t\t  TREE_TYPE (TREE_VEC_ELT (candidates->convs, 0)),\n+\t\t  TREE_TYPE (TREE_VEC_ELT (candidates->convs, 1)));\n+      else\n+\tcp_error (\"candidates are: %D(%T) <builtin>\", candidates->fn,\n+\t\t  TREE_TYPE (TREE_VEC_ELT (candidates->convs, 0)));\n+    }\n+  else\n+    cp_error_at (\"candidates are: %D\", candidates->fn);\n+  candidates = candidates->next;\n+\n+  for (; candidates; candidates = candidates->next)\n+    {\n+      if (TREE_CODE (candidates->fn) == IDENTIFIER_NODE)\n+\t{\n+\t  if (candidates->fn == ansi_opname [COND_EXPR])\n+\t    cp_error (\"                %D(%T, %T, %T) <builtin>\",\n+\t\t      candidates->fn,\n+\t\t      TREE_TYPE (TREE_VEC_ELT (candidates->convs, 0)),\n+\t\t      TREE_TYPE (TREE_VEC_ELT (candidates->convs, 1)),\n+\t\t      TREE_TYPE (TREE_VEC_ELT (candidates->convs, 2)));\n+\t  else if (TREE_VEC_LENGTH (candidates->convs) == 2)\n+\t    cp_error (\"                %D(%T, %T) <builtin>\", candidates->fn,\n+\t\t      TREE_TYPE (TREE_VEC_ELT (candidates->convs, 0)),\n+\t\t      TREE_TYPE (TREE_VEC_ELT (candidates->convs, 1)));\n+\t  else\n+\t    cp_error (\"                %D(%T) <builtin>\", candidates->fn,\n+\t\t      TREE_TYPE (TREE_VEC_ELT (candidates->convs, 0)));\n+\t}\n+      else\n+\tcp_error_at (\"                %D\", candidates->fn);\n+    }\n+}\n+\n+/* Returns the best overload candidate to perform the requested\n+   conversion.  */\n+\n+static struct z_candidate *\n+build_user_type_conversion_1 (totype, expr, flags)\n+     tree totype, expr;\n+     int flags;\n+{\n+  struct z_candidate *candidates, *cand;\n+  tree fromtype = TREE_TYPE (expr);\n+  tree ctors = NULL_TREE, convs = NULL_TREE, *p;\n+  tree args;\n+\n+  if (IS_AGGR_TYPE (totype))\n+    ctors = lookup_fnfields (TYPE_BINFO (totype), ctor_identifier, 0);\n+  if (IS_AGGR_TYPE (fromtype)\n+      && (! IS_AGGR_TYPE (totype) || ! DERIVED_FROM_P (totype, fromtype)))\n+    convs = lookup_conversions (fromtype);\n+\n+  candidates = 0;\n+  flags |= LOOKUP_NO_CONVERSION;\n+\n+  if (ctors)\n+    {\n+      tree t = build_int_2 (0, 0);\n+      TREE_TYPE (t) = build_pointer_type (totype);\n+      args = build_tree_list (NULL_TREE, expr);\n+      if (TYPE_USES_VIRTUAL_BASECLASSES (totype))\n+\targs = tree_cons (NULL_TREE, integer_one_node, args);\n+      args = tree_cons (NULL_TREE, t, args);\n+\n+      ctors = TREE_VALUE (ctors);\n+    }\n+  for (; ctors; ctors = DECL_CHAIN (ctors))\n+    {\n+      if ((flags & LOOKUP_ONLYCONVERTING) && DECL_NONCONVERTING_P (ctors))\n+\tcontinue;\n+\n+      candidates = add_function_candidate (candidates, ctors, args, flags);\n+      candidates->second_conv = build1 (IDENTITY_CONV, totype, NULL_TREE);\n+      candidates->basetype_path = TYPE_BINFO (totype);\n+    }\n+\n+  if (convs)\n+    args = build_tree_list (NULL_TREE, build_this (expr));\n+\n+  for (; convs; convs = TREE_CHAIN (convs))\n+    {\n+      tree fn = TREE_VALUE (convs);\n+      tree ics = implicit_conversion\n+\t(totype, TREE_TYPE (TREE_TYPE (fn)), 0, LOOKUP_NO_CONVERSION);\n+      if (ics)\n+\tfor (; fn; fn = DECL_CHAIN (fn))\n+\t  {\n+\t    candidates = add_function_candidate (candidates, fn, args, flags);\n+\t    candidates->second_conv = ics;\n+\t    candidates->basetype_path = TREE_PURPOSE (convs);\n+\t  }\n+    }\n+\n+  if (! any_viable (candidates))\n+    {\n+#if 0\n+      if (flags & LOOKUP_COMPLAIN)\n+\t{\n+\t  if (candidates && ! candidates->next)\n+\t    /* say why this one won't work or try to be loose */;\n+\t  else\n+\t    cp_error (\"no viable candidates\");\n+\t}\n+#endif\n+\n+      return 0;\n+    }\n+\n+  candidates = splice_viable (candidates);\n+  cand = tourney (candidates, totype);\n+\n+  if (cand == 0)\n+    {\n+      if (flags & LOOKUP_COMPLAIN)\n+\t{\n+\t  cp_error (\"conversion from `%T' to `%T' is ambiguous\",\n+\t\t    fromtype, totype);\n+\t  print_z_candidates (candidates);\n+\t}\n+\n+      cand = candidates;\t/* any one will do */\n+      cand->second_conv = build1 (AMBIG_CONV, totype, expr);\n+      ICS_USER_FLAG (cand->second_conv) = 1;\n+\n+      return cand;\n+    }\n+\n+  for (p = &(cand->second_conv); TREE_CODE (*p) != IDENTITY_CONV; )\n+    p = &(TREE_OPERAND (*p, 0));\n+\n+  *p = build\n+    (USER_CONV,\n+     (DECL_CONSTRUCTOR_P (cand->fn)\n+      ? totype : non_reference (TREE_TYPE (TREE_TYPE (cand->fn)))),\n+     NULL_TREE, cand->fn, cand->convs, cand->basetype_path);\n+  ICS_USER_FLAG (cand->second_conv) = 1;\n+\n+  return cand;\n+}\n+\n+tree\n+build_user_type_conversion (totype, expr, flags)\n+     tree totype, expr, flags;\n+{\n+  struct z_candidate *cand\n+    = build_user_type_conversion_1 (totype, expr, flags);\n+\n+  if (cand)\n+    {\n+      if (TREE_CODE (cand->second_conv) == AMBIG_CONV)\n+\treturn error_mark_node;\n+      return convert_from_reference (convert_like (cand->second_conv, expr));\n+    }\n+  return NULL_TREE;\n+}\n+\n+tree\n+build_new_function_call (fn, args, obj)\n+     tree fn, args, obj;\n+{\n+  struct z_candidate *candidates = 0, *cand;\n+ \n+  if (obj == NULL_TREE && TREE_CODE (fn) == TREE_LIST)\n+    {\n+      tree t;\n+\n+      for (t = args; t; t = TREE_CHAIN (t))\n+\tif (TREE_VALUE (t) == error_mark_node)\n+\t  return error_mark_node;\n+\t\n+      for (t = TREE_VALUE (fn); t; t = DECL_CHAIN (t))\n+\t{\n+\t  if (TREE_CODE (t) == TEMPLATE_DECL)\n+\t    candidates = add_template_candidate\n+\t      (candidates, t, args, LOOKUP_NORMAL);\n+\t  else\n+\t    candidates = add_function_candidate\n+\t      (candidates, t, args, LOOKUP_NORMAL);\n+\t}\n+\n+      if (! any_viable (candidates))\n+\t{\n+\t  if (candidates && ! candidates->next)\n+\t    return build_function_call (candidates->fn, args);\n+\t  else\n+\t    cp_error (\"no matching function for call to `%D (%A)'\",\n+\t\t      TREE_PURPOSE (fn), args);\n+\t  return error_mark_node;\n+\t}\n+      candidates = splice_viable (candidates);\n+      cand = tourney (candidates, NULL_TREE);\n+\n+      if (cand == 0)\n+\t{\n+\t  cp_error (\"call of overloaded `%D (%A)' is ambiguous\",\n+\t\t    TREE_PURPOSE (fn), args);\n+\t  print_z_candidates (candidates);\n+\t  return error_mark_node;\n+\t}\n+\n+      return build_over_call (cand->fn, cand->convs, args, LOOKUP_NORMAL);\n+    }\n+\n+  return build_function_call (fn, args);\n+}\n+\n+tree\n+build_object_call (obj, args)\n+     tree obj, args;\n+{\n+  struct z_candidate *candidates = 0, *cand;\n+  tree fns, convs, mem_args, *p;\n+  enum tree_code code2 = NOP_EXPR;\n+  tree type = TREE_TYPE (obj);\n+\n+  fns = lookup_fnfields (TYPE_BINFO (type), ansi_opname [CALL_EXPR], 0);\n+\n+  if (fns)\n+    {\n+      tree fn = TREE_VALUE (fns);\n+      mem_args = tree_cons (NULL_TREE, build_this (obj), args);\n+\n+      for (; fn; fn = DECL_CHAIN (fn))\n+\t{\n+\t  candidates = add_function_candidate\n+\t    (candidates, fn, mem_args, LOOKUP_NORMAL);\n+\t  candidates->basetype_path = TREE_PURPOSE (fns);\n+\t}\n+    }\n+\n+  convs = lookup_conversions (type);\n+\n+  for (; convs; convs = TREE_CHAIN (convs))\n+    {\n+      tree fn = TREE_VALUE (convs);\n+      tree totype = TREE_TYPE (TREE_TYPE (fn));\n+\n+      if (TREE_CODE (totype) == POINTER_TYPE\n+\t  && TREE_CODE (TREE_TYPE (totype)) == FUNCTION_TYPE)\n+\tfor (; fn; fn = DECL_CHAIN (fn))\n+\t  {\n+\t    candidates = add_conv_candidate (candidates, fn, obj, args);\n+\t    candidates->basetype_path = TREE_PURPOSE (convs);\n+\t  }\n+    }\n+\n+  if (! any_viable (candidates))\n+    {\n+      cp_error (\"no match for call to `(%T) (%A)\", TREE_TYPE (obj), args);\n+      print_z_candidates (candidates);\n+      return error_mark_node;\n+    }\n+\n+  candidates = splice_viable (candidates);\n+  cand = tourney (candidates, NULL_TREE);\n+\n+  if (cand == 0)\n+    {\n+      cp_error (\"call of `(%T) (%A)' is ambiguous\", TREE_TYPE (obj), args);\n+      print_z_candidates (candidates);\n+      return error_mark_node;\n+    }\n+\n+  if (DECL_NAME (cand->fn) == ansi_opname [CALL_EXPR])\n+    return build_over_call (cand->fn, cand->convs, mem_args, LOOKUP_NORMAL);\n+\n+  obj = convert_like (TREE_VEC_ELT (cand->convs, 0), obj);\n+\n+  /* FIXME */\n+  return build_function_call (obj, args);\n+}\n+\n+static void\n+op_error (code, code2, arg1, arg2, arg3, problem)\n+     enum tree_code code, code2;\n+     tree arg1, arg2, arg3;\n+     char *problem;\n+{\n+  char * opname\n+    = (code == MODIFY_EXPR ? assignop_tab [code2] : opname_tab [code]);\n+\n+  switch (code)\n+    {\n+    case COND_EXPR:\n+      cp_error (\"%s for `%T ? %T : %T'\", problem,\n+\t\tTREE_TYPE (arg1), TREE_TYPE (arg2), TREE_TYPE (arg3));\n+      break;\n+    case POSTINCREMENT_EXPR:\n+    case POSTDECREMENT_EXPR:\n+      cp_error (\"%s for `%T%s'\", problem, TREE_TYPE (arg1), opname);\n+      break;\n+    case ARRAY_REF:\n+      cp_error (\"%s for `%T[%T]'\", problem,\n+\t\tTREE_TYPE (arg1), TREE_TYPE (arg2));\n+      break;\n+    default:\n+      if (arg2)\n+\tcp_error (\"%s for `%T %s %T'\", problem,\n+\t\t  TREE_TYPE (arg1), opname, TREE_TYPE (arg2));\n+      else\n+\tcp_error (\"%s for `%s%T'\", problem, opname, TREE_TYPE (arg1));\n+    }\n+}\n+\n+tree\n+build_new_op (code, flags, arg1, arg2, arg3)\n+     enum tree_code code;\n+     int flags;\n+     tree arg1, arg2, arg3;\n+{\n+  struct z_candidate *candidates = 0, *cand;\n+  tree fns, mem_arglist, arglist, fnname, *p;\n+  enum tree_code code2 = NOP_EXPR;\n+\n+  if (arg1 == error_mark_node)\n+    return error_mark_node;\n+\n+  if (code == MODIFY_EXPR)\n+    {\n+      code2 = TREE_CODE (arg3);\n+      arg3 = NULL_TREE;\n+      fnname = ansi_assopname[code2];\n+    }\n+  else\n+    fnname = ansi_opname[code];\n+\n+  switch (code)\n+    {\n+    case NEW_EXPR:\n+    case VEC_NEW_EXPR:\n+      {\n+\ttree rval;\n+\n+\targlist = tree_cons (NULL_TREE, arg2, arg3);\n+\tif (flags & LOOKUP_GLOBAL)\n+\t  return build_new_function_call\n+\t    (lookup_name_nonclass (fnname), arglist, NULL_TREE);\n+\n+\t/* FIXME */\n+\trval = build_method_call\n+\t  (build_indirect_ref (build1 (NOP_EXPR, arg1, error_mark_node),\n+\t\t\t       \"new\"),\n+\t   fnname, arglist, NULL_TREE, flags);\n+\tif (rval == error_mark_node)\n+\t  /* User might declare fancy operator new, but invoke it\n+\t     like standard one.  */\n+\t  return rval;\n+\n+\tTREE_TYPE (rval) = arg1;\n+\tTREE_CALLS_NEW (rval) = 1;\n+\treturn rval;\n+      }\n+\n+    case VEC_DELETE_EXPR:\n+    case DELETE_EXPR:\n+      {\n+\ttree rval;\n+\n+\tif (flags & LOOKUP_GLOBAL)\n+\t  return build_new_function_call\n+\t    (lookup_name_nonclass (fnname),\n+\t     build_tree_list (NULL_TREE, arg1), NULL_TREE);\n+\n+\targlist = tree_cons (NULL_TREE, arg1, build_tree_list (NULL_TREE, arg2));\n+\n+\targ1 = TREE_TYPE (arg1);\n+\n+\t/* This handles the case where we're trying to delete\n+\t   X (*a)[10];\n+\t   a=new X[5][10];\n+\t   delete[] a; */\n+\t   \n+\tif (TREE_CODE (TREE_TYPE (arg1)) == ARRAY_TYPE)\n+\t  {\n+\t    /* Strip off the pointer and the array.  */\n+\t    arg1 = TREE_TYPE (TREE_TYPE (arg1));\n+\n+\t    while (TREE_CODE (arg1) == ARRAY_TYPE)\n+\t\targ1 = (TREE_TYPE (arg1));\n+\n+\t    arg1 = build_pointer_type (arg1);\n+\t  }\n+\n+\t/* FIXME */\n+\trval = build_method_call\n+\t  (build_indirect_ref (build1 (NOP_EXPR, arg1,\n+\t\t\t\t       error_mark_node),\n+\t\t\t       NULL_PTR),\n+\t   fnname, arglist, NULL_TREE, flags);\n+#if 0\n+\t/* This can happen when operator delete is protected.  */\n+\tmy_friendly_assert (rval != error_mark_node, 250);\n+\tTREE_TYPE (rval) = void_type_node;\n+#endif\n+\treturn rval;\n+      }\n+\n+    case CALL_EXPR:\n+      return build_object_call (arg1, arg2);\n+    }\n+\n+  /* The comma operator can have void args.  */\n+  if (TREE_CODE (arg1) == OFFSET_REF)\n+    arg1 = resolve_offset_ref (arg1);\n+  if (arg2 && TREE_CODE (arg2) == OFFSET_REF)\n+    arg2 = resolve_offset_ref (arg2);\n+  if (arg3 && TREE_CODE (arg3) == OFFSET_REF)\n+    arg3 = resolve_offset_ref (arg3);\n+\n+  if (! IS_OVERLOAD_TYPE (TREE_TYPE (arg1))\n+      && (! arg2 || ! IS_OVERLOAD_TYPE (TREE_TYPE (arg2)))\n+      && (! arg3 || ! IS_OVERLOAD_TYPE (TREE_TYPE (arg3))))\n+    goto builtin;\n+\n+  if (code == POSTINCREMENT_EXPR || code == POSTDECREMENT_EXPR)\n+    arg2 = integer_zero_node;\n+\n+  fns = lookup_name_nonclass (fnname);\n+  /* + Koenig lookup */\n+\n+  if (arg2 && arg3)\n+    arglist = tree_cons (NULL_TREE, arg1, tree_cons\n+\t\t      (NULL_TREE, arg2, build_tree_list (NULL_TREE, arg3)));\n+  else if (arg2)\n+    arglist = tree_cons (NULL_TREE, arg1, build_tree_list (NULL_TREE, arg2));\n+  else\n+    arglist = build_tree_list (NULL_TREE, arg1);\n+\n+  if (fns && TREE_CODE (fns) == TREE_LIST)\n+    fns = TREE_VALUE (fns);\n+  for (; fns; fns = DECL_CHAIN (fns))\n+    {\n+      if (TREE_CODE (fns) == TEMPLATE_DECL)\n+\tcandidates = add_template_candidate (candidates, fns, arglist, flags);\n+      else\n+\tcandidates = add_function_candidate (candidates, fns, arglist, flags);\n+    }\n+\n+  if (IS_AGGR_TYPE (TREE_TYPE (arg1)))\n+    fns = lookup_fnfields (TYPE_BINFO (TREE_TYPE (arg1)), fnname, 0);\n+  else\n+    fns = NULL_TREE;\n+\n+  if (fns)\n+    {\n+      tree fn = TREE_VALUE (fns);\n+      mem_arglist = tree_cons (NULL_TREE, build_this (arg1), TREE_CHAIN (arglist));\n+      for (; fn; fn = DECL_CHAIN (fn))\n+\t{\n+\t  if (TREE_CODE (TREE_TYPE (fn)) == METHOD_TYPE)\n+\t    candidates = add_function_candidate\n+\t      (candidates, fn, mem_arglist, flags);\n+\t  else\n+\t    candidates = add_function_candidate (candidates, fn, arglist, flags);\n+\t  \n+\t  candidates->basetype_path = TREE_PURPOSE (fns);\n+\t}\n+    }\n+\n+  {\n+    tree args[3];\n+\n+    /* Rearrange the arguments for ?: so that add_builtin_candidate only has\n+       to know about two args; a builtin candidate will always have a first\n+       parameter of type bool.  We'll handle that in\n+       build_builtin_candidate.  */\n+    if (code == COND_EXPR)\n+      {\n+\targs[0] = arg2;\n+\targs[1] = arg3;\n+\targs[2] = arg1;\n+      }\n+    else\n+      {\n+\targs[0] = arg1;\n+\targs[1] = arg2;\n+\targs[2] = NULL_TREE;\n+      }\n+\n+    candidates = add_builtin_candidates\n+      (candidates, code, code2, fnname, args, flags);\n+  }\n+\n+  if (! any_viable (candidates))\n+    {\n+      switch (code)\n+\t{\n+\tcase POSTINCREMENT_EXPR:\n+\tcase POSTDECREMENT_EXPR:\n+\t  /* Look for an `operator++ (int)'.  If they didn't have\n+\t     one, then we fall back to the old way of doing things.  */\n+\t  if (flags & LOOKUP_COMPLAIN)\n+\t    cp_pedwarn (\"no `%D (int)' declared for postfix `%s', trying prefix operator instead\",\n+\t\t\tfnname, opname_tab [code]);\n+\t  if (code == POSTINCREMENT_EXPR)\n+\t    code = PREINCREMENT_EXPR;\n+\t  else\n+\t    code = PREDECREMENT_EXPR;\t\n+\t  return build_new_op (code, flags, arg1, NULL_TREE, NULL_TREE);\n+\t  \n+\t  /* The caller will deal with these.  */\n+\tcase ADDR_EXPR:\n+\tcase COMPOUND_EXPR:\n+\tcase COMPONENT_REF:\n+\t  return NULL_TREE;\n+\t}\n+      if (flags & LOOKUP_COMPLAIN)\n+\t{\n+\t  op_error (code, code2, arg1, arg2, arg3, \"no match\");\n+\t  print_z_candidates (candidates);\n+\t}\n+      return error_mark_node;\n+    }\n+  candidates = splice_viable (candidates);\n+  cand = tourney (candidates, NULL_TREE);\n+\n+  if (cand == 0)\n+    {\n+      if (flags & LOOKUP_COMPLAIN)\n+\t{\n+\t  op_error (code, code2, arg1, arg2, arg3, \"ambiguous overload\");\n+\t  print_z_candidates (candidates);\n+\t}\n+      return error_mark_node;\n+    }\n+\n+  if (TREE_CODE (cand->fn) == FUNCTION_DECL)\n+    {\n+      extern int warn_synth;\n+      if (warn_synth\n+\t  && fnname == ansi_opname[MODIFY_EXPR]\n+\t  && DECL_ARTIFICIAL (cand->fn)\n+\t  && candidates->next\n+\t  && ! candidates->next->next)\n+\t{\n+\t  cp_warning (\"using synthesized `%#D' for copy assignment\",\n+\t\t      cand->fn);\n+\t  cp_warning_at (\"  where cfront would use `%#D'\",\n+\t\t\t cand == candidates\n+\t\t\t ? candidates->next->fn\n+\t\t\t : candidates->fn);\n+\t}\n+\n+      if (DECL_FUNCTION_MEMBER_P (cand->fn))\n+\tenforce_access (cand->basetype_path, cand->fn);\n+\n+      return build_over_call\n+\t(cand->fn, cand->convs,\n+\t TREE_CODE (TREE_TYPE (cand->fn)) == METHOD_TYPE\n+\t ? mem_arglist : arglist,\n+\t LOOKUP_NORMAL);\n+    }\n+\n+  arg1 = convert_from_reference\n+    (convert_like (TREE_VEC_ELT (cand->convs, 0), arg1));\n+  if (arg2)\n+    arg2 = convert_like (TREE_VEC_ELT (cand->convs, 1), arg2);\n+  if (arg3)\n+    arg3 = convert_like (TREE_VEC_ELT (cand->convs, 2), arg3);\n+\n+builtin:\n+  switch (code)\n+    {\n+    case MODIFY_EXPR:\n+      return build_modify_expr (arg1, code2, arg2);\n+\n+    case INDIRECT_REF:\n+      return build_indirect_ref (arg1, \"unary *\");\n+\n+    case PLUS_EXPR:\n+    case MINUS_EXPR:\n+    case MULT_EXPR:\n+    case TRUNC_DIV_EXPR:\n+    case GT_EXPR:\n+    case LT_EXPR:\n+    case GE_EXPR:\n+    case LE_EXPR:\n+    case EQ_EXPR:\n+    case NE_EXPR:\n+    case MAX_EXPR:\n+    case MIN_EXPR:\n+    case LSHIFT_EXPR:\n+    case RSHIFT_EXPR:\n+    case TRUNC_MOD_EXPR:\n+    case BIT_AND_EXPR:\n+    case BIT_IOR_EXPR:\n+    case BIT_XOR_EXPR:\n+    case TRUTH_ANDIF_EXPR:\n+    case TRUTH_ORIF_EXPR:\n+      return build_binary_op_nodefault (code, arg1, arg2, code);\n+\n+    case CONVERT_EXPR:\n+    case NEGATE_EXPR:\n+    case BIT_NOT_EXPR:\n+    case TRUTH_NOT_EXPR:\n+    case PREINCREMENT_EXPR:\n+    case POSTINCREMENT_EXPR:\n+    case PREDECREMENT_EXPR:\n+    case POSTDECREMENT_EXPR:\n+      return build_unary_op (code, arg1, candidates != 0);\n+\n+    case ARRAY_REF:\n+      return build_array_ref (arg1, arg2);\n+\n+    case COND_EXPR:\n+      return build_conditional_expr (arg1, arg2, arg3);\n+\n+    case MEMBER_REF:\n+      return build_m_component_ref\n+\t(build_indirect_ref (arg1, NULL_PTR), arg2);\n+\n+      /* The caller will deal with these.  */\n+    case ADDR_EXPR:\n+    case COMPONENT_REF:\n+    case COMPOUND_EXPR:\n+      return NULL_TREE;\n+\n+    default:\n+      my_friendly_abort (367);\n+    }\n+}\n+\n+void\n+enforce_access (basetype_path, function)\n+     tree basetype_path, function;\n+{\n+  tree access = compute_access (basetype_path, function);\n+\n+  if (access == access_private_node)\n+    {\n+      cp_error_at (\"`%+#D' is %s\", function, \n+\t\t   TREE_PRIVATE (function) ? \"private\"\n+\t\t   : \"from private base class\");\n+      error (\"within this context\");\n+    }\n+  else if (access == access_protected_node)\n+    {\n+      cp_error_at (\"`%+#D' %s\", function,\n+\t\t   TREE_PROTECTED (function) ? \"is protected\"\n+\t\t   : \"has protected accessibility\");\n+      error (\"within this context\");\n+    }\n+}\n+\n+/* Perform the conversions in CONVS on the expression EXPR.  */\n+\n+static tree\n+convert_like (convs, expr)\n+     tree convs, expr;\n+{\n+  switch (TREE_CODE (convs))\n+    {\n+    case USER_CONV:\n+      {\n+\ttree fn = TREE_OPERAND (convs, 1);\n+\ttree args;\n+\tenforce_access (TREE_OPERAND (convs, 3), fn);\n+\n+\tif (DECL_CONSTRUCTOR_P (fn))\n+\t  {\n+\t    tree t = build_int_2 (0, 0);\n+\t    TREE_TYPE (t) = build_pointer_type (DECL_CONTEXT (fn));\n+\n+\t    args = build_tree_list (NULL_TREE, expr);\n+\t    if (TYPE_USES_VIRTUAL_BASECLASSES (DECL_CONTEXT (fn)))\n+\t      args = tree_cons (NULL_TREE, integer_one_node, args);\n+\t    args = tree_cons (NULL_TREE, t, args);\n+\t  }\n+\telse\n+\t  args = build_this (expr);\n+\texpr = build_over_call\n+\t  (TREE_OPERAND (convs, 1), TREE_OPERAND (convs, 2),\n+\t   args, LOOKUP_NORMAL);\n+\n+\t/* If this is a constructor or a function returning an aggr type,\n+\t   we need to build up a TARGET_EXPR.  */\n+\tif (DECL_CONSTRUCTOR_P (fn))\n+\t  expr = build_cplus_new (TREE_TYPE (convs), expr);\n+\n+\treturn expr;\n+      }\n+    case IDENTITY_CONV:\n+      if (type_unknown_p (expr))\n+\texpr = instantiate_type (TREE_TYPE (convs), expr, 1);\n+      return expr;\n+    case AMBIG_CONV:\n+      /* Call build_user_type_conversion again for the error.  */\n+      return build_user_type_conversion\n+\t(TREE_TYPE (convs), TREE_OPERAND (convs, 0), LOOKUP_NORMAL);\n+    };\n+\n+  expr = convert_like (TREE_OPERAND (convs, 0), expr);\n+  if (expr == error_mark_node)\n+    return error_mark_node;\n+\n+  switch (TREE_CODE (convs))\n+    {\n+    case BASE_CONV:\n+    case RVALUE_CONV:\n+      return build_user_type_conversion\n+\t(TREE_TYPE (convs), expr, LOOKUP_NORMAL);\n+    case REF_BIND:\n+      return convert_to_reference\n+\t(TREE_TYPE (convs), expr,\n+\t CONV_IMPLICIT, LOOKUP_NORMAL|LOOKUP_NO_CONVERSION|INDIRECT_BIND,\n+\t error_mark_node);\n+    case LVALUE_CONV:\n+      return decay_conversion (expr);\n+    }\n+  return cp_convert (TREE_TYPE (convs), expr, CONV_IMPLICIT,\n+\t\t     LOOKUP_NORMAL|LOOKUP_NO_CONVERSION);\n+}\n+\n+static tree\n+convert_default_arg (type, arg)\n+     tree type, arg;\n+{\n+  arg = break_out_target_exprs (arg);\n+\n+  if (TREE_CODE (arg) == CONSTRUCTOR)\n+    {\n+      arg = digest_init (type, arg, 0);\n+      arg = convert_for_initialization (0, type, arg, LOOKUP_NORMAL,\n+\t\t\t\t\t\"default argument\", 0, 0);\n+    }\n+  else\n+    {\n+      /* This could get clobbered by the following call.  */\n+      if (TREE_HAS_CONSTRUCTOR (arg))\n+\targ = copy_node (arg);\n+\n+      arg = convert_for_initialization (0, type, arg, LOOKUP_NORMAL,\n+\t\t\t\t\t\"default argument\", 0, 0);\n+#ifdef PROMOTE_PROTOTYPES\n+      if ((TREE_CODE (type) == INTEGER_TYPE\n+\t   || TREE_CODE (type) == ENUMERAL_TYPE)\n+\t  && (TYPE_PRECISION (type) < TYPE_PRECISION (integer_type_node)))\n+\targ = default_conversion (arg);\n+#endif\n+    }\n+\n+  return arg;\n+}\n+\n+static tree\n+build_over_call (fn, convs, args, flags)\n+     tree fn, convs, args;\n+     int flags;\n+{\n+  tree converted_args = NULL_TREE;\n+  tree parm = TYPE_ARG_TYPES (TREE_TYPE (fn));\n+  tree conv, arg, val;\n+  int i = 0;\n+\n+  if (args && TREE_CODE (args) != TREE_LIST)\n+    args = build_tree_list (NULL_TREE, args);\n+  arg = args;\n+\n+  /* The implicit parameters to a constructor are not considered by overload\n+     resolution, and must be of the proper type.  */\n+  if (DECL_CONSTRUCTOR_P (fn))\n+    {\n+      converted_args = tree_cons (NULL_TREE, TREE_VALUE (arg), converted_args);\n+      arg = TREE_CHAIN (arg);\n+      parm = TREE_CHAIN (parm);\n+      if (TYPE_USES_VIRTUAL_BASECLASSES (DECL_CONTEXT (fn)))\n+\t{\n+\t  converted_args = tree_cons\n+\t    (NULL_TREE, TREE_VALUE (arg), converted_args);\n+\t  arg = TREE_CHAIN (arg);\n+\t  parm = TREE_CHAIN (parm);\n+\t}\n+    }      \n+  /* Bypass access control for 'this' parameter.  */\n+  else if (TREE_CODE (TREE_TYPE (fn)) == METHOD_TYPE)\n+    {\n+      converted_args = tree_cons\n+\t(NULL_TREE, convert_force (TREE_VALUE (parm), TREE_VALUE (arg), CONV_C_CAST),\n+\t converted_args);\n+      parm = TREE_CHAIN (parm);\n+      arg = TREE_CHAIN (arg);\n+      ++i;\n+    }\n+\n+  for (; conv = TREE_VEC_ELT (convs, i), arg && parm;\n+       parm = TREE_CHAIN (parm), arg = TREE_CHAIN (arg), ++i)\n+    {\n+      tree type = TREE_VALUE (parm);\n+      val = convert_like (conv, TREE_VALUE (arg));\n+\n+#ifdef PROMOTE_PROTOTYPES\n+      if ((TREE_CODE (type) == INTEGER_TYPE\n+\t   || TREE_CODE (type) == ENUMERAL_TYPE)\n+\t  && (TYPE_PRECISION (type) < TYPE_PRECISION (integer_type_node)))\n+\tval = default_conversion (val);\n+#endif\n+      converted_args = tree_cons (NULL_TREE, val, converted_args);\n+    }\n+\n+  /* Default arguments */\n+  for (; parm && parm != void_list_node; parm = TREE_CHAIN (parm))\n+    converted_args = tree_cons\n+      (NULL_TREE,\n+       convert_default_arg (TREE_VALUE (parm), TREE_PURPOSE (parm)),\n+       converted_args);\n+\n+  /* Ellipsis */\n+  for (; arg; arg = TREE_CHAIN (arg))\n+    {\n+      val = TREE_VALUE (arg);\n+\n+      if (TREE_CODE (TREE_TYPE (val)) == REAL_TYPE\n+\t  && (TYPE_PRECISION (TREE_TYPE (val))\n+\t      < TYPE_PRECISION (double_type_node)))\n+\t/* Convert `float' to `double'.  */\n+\tval = convert (double_type_node, val);\n+      else if (TYPE_LANG_SPECIFIC (TREE_TYPE (val))\n+\t       && ! TYPE_HAS_TRIVIAL_INIT_REF (TREE_TYPE (val)))\n+\tcp_warning (\"cannot pass objects of type `%T' through `...'\",\n+\t\t    TREE_TYPE (val));\n+      else\n+\t/* Convert `short' and `char' to full-size `int'.  */\n+\tval = default_conversion (val);\n+\n+      converted_args = tree_cons (NULL_TREE, val, converted_args);\n+    }\n+\n+  converted_args = nreverse (converted_args);\n+\n+  mark_used (fn);\n+  /* Is it a synthesized method that needs to be synthesized?  */\n+  if (DECL_ARTIFICIAL (fn) && ! DECL_INITIAL (fn)\n+      && DECL_CLASS_CONTEXT (fn)\n+      /* Kludge: don't synthesize for default args.  */\n+      && current_function_decl)\n+    synthesize_method (fn);\n+\n+  if (pedantic && DECL_THIS_INLINE (fn) && ! DECL_ARTIFICIAL (fn)\n+      && ! DECL_INITIAL (fn) && ! DECL_PENDING_INLINE_INFO (fn)\n+      && ! (DECL_TEMPLATE_INFO (fn)\n+\t    && TREE_LANG_FLAG_0 (DECL_TEMPLATE_INFO (fn))))\n+    cp_warning (\"inline function `%#D' called before definition\", fn);\n+\n+  if (DECL_VINDEX (fn) && (flags & LOOKUP_NONVIRTUAL) == 0)\n+    {\n+      tree t, *p = &TREE_VALUE (converted_args);\n+      tree binfo = get_binfo\n+\t(DECL_CONTEXT (fn), TREE_TYPE (TREE_TYPE (*p)), 0);\n+      *p = convert_pointer_to_real (binfo, *p);\n+      if (TREE_SIDE_EFFECTS (*p))\n+\t*p = save_expr (*p);\n+      t = build_pointer_type (TREE_TYPE (fn));\n+      fn = build_vfn_ref (p, build_indirect_ref (*p, 0), DECL_VINDEX (fn));\n+      TREE_TYPE (fn) = t;\n+    }\n+  else if (DECL_INLINE (fn))\n+    fn = inline_conversion (fn);\n+  else\n+    fn = build_addr_func (fn);\n+\n+  fn = build_call (fn, TREE_TYPE (TREE_TYPE (TREE_TYPE (fn))), converted_args);\n+  if (TREE_TYPE (fn) == void_type_node)\n+    return fn;\n+  if (IS_AGGR_TYPE (TREE_TYPE (fn)))\n+    fn = build_cplus_new (TREE_TYPE (fn), fn);\n+  return convert_from_reference (require_complete_type (fn));\n+}\n+\n+tree\n+build_new_method_call (instance, name, args, basetype_path, flags)\n+     tree instance, name, args, basetype_path;\n+     int flags;\n+{\n+  struct z_candidate *candidates = 0, *cand;\n+  tree basetype, mem_args, fns, instance_ptr;\n+  tree pretty_name;\n+\n+  if (instance == NULL_TREE)\n+    basetype = BINFO_TYPE (basetype_path);\n+  else\n+    {\n+      if (TREE_CODE (instance) == OFFSET_REF)\n+\tinstance = resolve_offset_ref (instance);\n+      if (TREE_CODE (TREE_TYPE (instance)) == REFERENCE_TYPE)\n+\tinstance = convert_from_reference (instance);\n+      basetype = TREE_TYPE (instance);\n+\n+      /* XXX this should be handled before we get here.  */\n+      if (! IS_AGGR_TYPE (basetype))\n+\t{\n+\t  if ((flags & LOOKUP_COMPLAIN) && basetype != error_mark_node)\n+\t    cp_error (\"request for member `%D' in `%E', which is of non-aggregate type `%T'\",\n+\t\t      name, instance, basetype);\n+\n+\t  return error_mark_node;\n+\t}\n+    }\n+\n+  if (basetype_path == NULL_TREE)\n+    basetype_path = TYPE_BINFO (basetype);\n+\n+  if (instance)\n+    {\n+      instance_ptr = build_this (instance);\n+\n+      /* XXX this should be handled before we get here.  */\n+      fns = build_field_call (basetype_path, instance_ptr, name, args);\n+      if (fns)\n+\treturn fns;\n+    }\n+  else\n+    {\n+      instance_ptr = build_int_2 (0, 0);\n+      TREE_TYPE (instance_ptr) = build_pointer_type (basetype);\n+    }\n+\n+  pretty_name =\n+    (name == ctor_identifier ? constructor_name_full (basetype) : name);\n+\n+  fns = lookup_fnfields (basetype_path, name, 1);\n+\n+  if (fns == error_mark_node)\n+    return error_mark_node;\n+  if (fns)\n+    {\n+      tree t = TREE_VALUE (fns);\n+      if (name == ctor_identifier && TYPE_USES_VIRTUAL_BASECLASSES (basetype)\n+\t  && ! (flags & LOOKUP_HAS_IN_CHARGE))\n+\t{\n+\t  flags |= LOOKUP_HAS_IN_CHARGE;\n+\t  args = tree_cons (NULL_TREE, integer_one_node, args);\n+\t}\n+      mem_args = tree_cons (NULL_TREE, instance_ptr, args);\n+      for (; t; t = DECL_CHAIN (t))\n+\t{\n+\t  /* XXX copy-init should go through build_user_type_conversion.  */\n+\t  if (name == ctor_identifier\n+\t      && (flags & LOOKUP_ONLYCONVERTING)\n+\t      && DECL_NONCONVERTING_P (t))\n+\t    continue;\n+\t  if (TREE_CODE (TREE_TYPE (t)) == METHOD_TYPE)\n+\t    candidates = add_function_candidate\n+\t      (candidates, t, mem_args, flags);\n+\t  else\n+\t    candidates = add_function_candidate (candidates, t, args, flags);\n+\t  candidates->basetype_path = TREE_PURPOSE (fns);\n+\t}\n+    }\n+\n+  if (! any_viable (candidates))\n+    {\n+      /* XXX will LOOKUP_SPECULATIVELY be needed when this is done?  */\n+      if (flags & LOOKUP_SPECULATIVELY)\n+\treturn NULL_TREE;\n+      cp_error (\"no matching function for call to `%T::%D (%A)%V'\", basetype,\n+\t\tpretty_name, args, TREE_TYPE (TREE_TYPE (instance_ptr)));\n+      print_z_candidates (candidates);\n+      return error_mark_node;\n+    }\n+  candidates = splice_viable (candidates);\n+  cand = tourney (candidates, NULL_TREE);\n+\n+  if (cand == 0)\n+    {\n+      cp_error (\"call of overloaded `%D(%A)' is ambiguous\");\n+      print_z_candidates (candidates);\n+      return error_mark_node;\n+    }\n+\n+  enforce_access (cand->basetype_path, cand->fn);\n+  if (DECL_ABSTRACT_VIRTUAL_P (cand->fn)\n+      && instance == current_class_ref\n+      && DECL_CONSTRUCTOR_P (current_function_decl)\n+      && ! (flags & LOOKUP_NONVIRTUAL)\n+      && value_member (cand->fn, get_abstract_virtuals (basetype)))\n+    cp_error (\"abstract virtual `%#D' called from constructor\", cand->fn);\n+  if (TREE_CODE (TREE_TYPE (cand->fn)) == METHOD_TYPE\n+      && TREE_CODE (instance_ptr) == NOP_EXPR\n+      && TREE_OPERAND (instance_ptr, 0) == error_mark_node)\n+    cp_error (\"cannot call member function `%D' without object\", cand->fn);\n+\n+  if (DECL_VINDEX (cand->fn) && ! (flags & LOOKUP_NONVIRTUAL)\n+      && ((instance == current_class_ref && (dtor_label || ctor_label))\n+\t  || resolves_to_fixed_type_p (instance, 0)))\n+    flags |= LOOKUP_NONVIRTUAL;\n+\n+  return build_over_call\n+    (cand->fn, cand->convs,\n+     TREE_CODE (TREE_TYPE (cand->fn)) == METHOD_TYPE ? mem_args : args,\n+     flags);\n+}\n+\n+/* Compare two implicit conversion sequences that differ only in their\n+   qualification conversion.  Subroutine of compare_ics.  */\n+\n+static int\n+compare_qual (ics1, ics2)\n+     tree ics1, ics2;\n+{\n+  tree to1 = TREE_TYPE (ics1);\n+  tree to2 = TREE_TYPE (ics2);\n+\n+  to1 = TREE_TYPE (to1);\n+  to2 = TREE_TYPE (to2);\n+\n+  if (TREE_CODE (to1) == OFFSET_TYPE)\n+    {\n+      to1 = TREE_TYPE (to1);\n+      to2 = TREE_TYPE (to2);\n+    }\n+\n+  if (TYPE_READONLY (to1) >= TYPE_READONLY (to2)\n+      && TYPE_VOLATILE (to1) > TYPE_VOLATILE (to2))\n+    return -1;\n+  else if (TYPE_READONLY (to1) > TYPE_READONLY (to2)\n+\t   && TYPE_VOLATILE (to1) == TYPE_VOLATILE (to2))\n+    return -1;\n+  else if (TYPE_READONLY (to1) <= TYPE_READONLY (to2)\n+\t   && TYPE_VOLATILE (to1) < TYPE_VOLATILE (to2))\n+    return 1;\n+  else if (TYPE_READONLY (to1) < TYPE_READONLY (to2)\n+\t   && TYPE_VOLATILE (to1) == TYPE_VOLATILE (to2))\n+    return 1;\n+  return 0;\n+}\n+\n+/* Compare two implicit conversion sequences according to the rules set out in\n+   [over.ics.rank].  Return values:\n+\n+      1: ics1 is better than ics2\n+     -1: ics2 is better than ics1\n+      0: ics1 and ics2 are indistinguishable */\n+\n+static int\n+compare_ics (ics1, ics2)\n+     tree ics1, ics2;\n+{\n+  tree main1, main2;\n+\n+  if (ICS_RANK (ics1) > ICS_RANK (ics2))\n+    return -1;\n+  else if (ICS_RANK (ics1) < ICS_RANK (ics2))\n+    return 1;\n+\n+  /* User-defined  conversion sequence U1 is a better conversion sequence\n+     than another user-defined conversion sequence U2 if they contain the\n+     same user-defined conversion operator or constructor and if the sec-\n+     ond standard conversion sequence of U1 is  better  than  the  second\n+     standard conversion sequence of U2.  */\n+\n+  if (ICS_RANK (ics1) == USER_RANK)\n+    {\n+      tree t1, t2;\n+\n+      for (t1 = ics1; TREE_CODE (t1) != USER_CONV; t1 = TREE_OPERAND (t1, 0))\n+\tif (TREE_CODE (t1) == AMBIG_CONV)\n+\t  return 0;\n+      for (t2 = ics2; TREE_CODE (t2) != USER_CONV; t2 = TREE_OPERAND (t2, 0))\n+\tif (TREE_CODE (t2) == AMBIG_CONV)\n+\t  return 0;\n+\n+      if (USER_CONV_FN (t1) != USER_CONV_FN (t2))\n+\treturn 0;\n+      else if (ICS_STD_RANK (ics1) > ICS_STD_RANK (ics2))\n+\treturn -1;\n+      else if (ICS_STD_RANK (ics1) < ICS_STD_RANK (ics2))\n+\treturn 1;\n+\n+      /* else fall through */\n+    }\n+\n+#if 0 /* Handled by ranking */\n+  /* A conversion that is not a conversion of a pointer,  or  pointer  to\n+     member,  to  bool  is  better than another conversion that is such a\n+     conversion.  */\n+#endif\n+\n+  if (TREE_CODE (ics1) == QUAL_CONV)\n+    main1 = TREE_OPERAND (ics1, 0);\n+  else\n+    main1 = ics1;\n+\n+  if (TREE_CODE (ics2) == QUAL_CONV)\n+    main2 = TREE_OPERAND (ics2, 0);\n+  else\n+    main2 = ics2;\n+\n+  if (TREE_CODE (main1) != TREE_CODE (main2))\n+    return 0;\n+\n+  if (TREE_CODE (main1) == PTR_CONV || TREE_CODE (main1) == PMEM_CONV\n+      || TREE_CODE (main1) == REF_BIND || TREE_CODE (main1) == BASE_CONV)\n+    {\n+      tree to1 = TREE_TYPE (main1);\n+      tree from1 = TREE_TYPE (TREE_OPERAND (main1, 0));\n+      tree to2 = TREE_TYPE (main2);\n+      tree from2 = TREE_TYPE (TREE_OPERAND (main2, 0));\n+      int distf, distt;\n+\n+      /* Standard conversion sequence S1 is a better conversion sequence than\n+\t standard conversion sequence S2 if...\n+\n+\t S1 and S2 differ only in their qualification conversion  and  they\n+\t yield types identical except for cv-qualifiers and S2 adds all the\n+\t qualifiers that S1 adds (and in the same places) and S2  adds  yet\n+\t more  cv-qualifiers  than  S1,  or the similar case with reference\n+\t binding15).  */\n+      if (TREE_CODE (main1) == REF_BIND)\n+\t{\n+\t  if (TYPE_MAIN_VARIANT (TREE_TYPE (to1))\n+\t      == TYPE_MAIN_VARIANT (TREE_TYPE (to2)))\n+\t    return compare_qual (ics1, ics2);\n+\t}\n+      else if (TREE_CODE (main1) != BASE_CONV && from1 == from2 && to1 == to2)\n+\treturn compare_qual (ics1, ics2);\n+\t\n+      if (TYPE_PTRMEMFUNC_P (to1))\n+\t{\n+\t  to1 = TYPE_METHOD_BASETYPE (TYPE_PTRMEMFUNC_FN_TYPE (to1));\n+\t  from1 = TYPE_METHOD_BASETYPE (TYPE_PTRMEMFUNC_FN_TYPE (from1));\n+\t}\n+      else if (TREE_CODE (main1) != BASE_CONV)\n+\t{\n+\t  to1 = TREE_TYPE (to1);\n+\t  if (TREE_CODE (main1) != REF_BIND)\n+\t    from1 = TREE_TYPE (from1);\n+\n+\t  if (TREE_CODE (to1) == OFFSET_TYPE)\n+\t    {\n+\t      to1 = TYPE_OFFSET_BASETYPE (to1);\n+\t      from1 = TYPE_OFFSET_BASETYPE (from1);\n+\t    }\n+\t}\n+\n+      if (TYPE_PTRMEMFUNC_P (to2))\n+\t{\n+\t  to2 = TYPE_METHOD_BASETYPE (TYPE_PTRMEMFUNC_FN_TYPE (to2));\n+\t  from2 = TYPE_METHOD_BASETYPE (TYPE_PTRMEMFUNC_FN_TYPE (from2));\n+\t}\n+      else if (TREE_CODE (main1) != BASE_CONV)\n+\t{\n+\t  to2 = TREE_TYPE (to2);\n+\t  if (TREE_CODE (main1) != REF_BIND)\n+\t    from2 = TREE_TYPE (from2);\n+\n+\t  if (TREE_CODE (to2) == OFFSET_TYPE)\n+\t    {\n+\t      to2 = TYPE_OFFSET_BASETYPE (to2);\n+\t      from2 = TYPE_OFFSET_BASETYPE (from2);\n+\t    }\n+\t}\n+\n+      if (! (IS_AGGR_TYPE (from1) && IS_AGGR_TYPE (from2)))\n+\treturn 0;\n+\n+      /* The sense of pmem conversions is reversed from that of the other\n+\t conversions.  */\n+      if (TREE_CODE (main1) == PMEM_CONV)\n+\t{\n+\t  tree t = from1; from1 = from2; from2 = t;\n+\t  t = to1; to1 = to2; to2 = t;\n+\t}\n+\n+      distf = get_base_distance (from1, from2, 0, 0);\n+      if (distf == -1)\n+\t{\n+\t  distf = -get_base_distance (from2, from1, 0, 0);\n+\t  if (distf == 1)\n+\t    return 0;\n+\t}\n+\n+      /* If class B is derived directly or indirectly from class A,\n+\t conver- sion of B* to A* is better than conversion of B* to\n+\t void*, and conversion of A* to void* is better than\n+\t conversion of B* to void*.  */\n+\n+      if (TREE_CODE (to1) == VOID_TYPE && TREE_CODE (to2) == VOID_TYPE)\n+\t{\n+\t  if (distf > 0)\n+\t    return 1;\n+\t  else if (distf < 0)\n+\t    return -1;\n+\t}\n+      else if (TREE_CODE (to2) == VOID_TYPE && IS_AGGR_TYPE (to1)\n+\t       && get_base_distance (to1, from1, 0, 0) != -1)\n+\treturn 1;\n+      else if (TREE_CODE (to1) == VOID_TYPE && IS_AGGR_TYPE (to2)\n+\t       && get_base_distance (to2, from2, 0, 0) != -1)\n+\treturn -1;\n+\n+      if (! (IS_AGGR_TYPE (to1) && IS_AGGR_TYPE (to2)))\n+\treturn 0;\n+\n+      /* If  class B is derived directly or indirectly from class A and class\n+\t C is derived directly or indirectly from B */\n+\n+      distt = get_base_distance (to1, to2, 0, 0);\n+      if (distt == -1)\n+\t{\n+\t  distt = -get_base_distance (to2, to1, 0, 0);\n+\t  if (distt == 1)\n+\t    return 0;\n+\t}\n+\n+      /* --conversion of C* to B* is better than conversion of C* to A*, */\n+      if (distf == 0)\n+\t{\n+\t  if (distt > 0)\n+\t    return -1;\n+\t  else if (distt < 0)\n+\t    return 1;\n+\t}\n+      /* --conversion of B* to A* is better than conversion of C* to A*, */\n+      else if (distt == 0)\n+\t{\n+\t  if (distf > 0)\n+\t    return 1;\n+\t  else if (distf < 0)\n+\t    return -1;\n+\t}\n+    }\n+  else if (TREE_CODE (TREE_TYPE (main1)) == POINTER_TYPE\n+\t   || TYPE_PTRMEMFUNC_P (TREE_TYPE (main1)))\n+    {\n+      if (TREE_TYPE (main1) == TREE_TYPE (main2))\n+\treturn compare_qual (ics1, ics2);\n+\n+#if 0 /* This is now handled by making identity better than anything else.  */\n+      /* existing practice, not WP-endorsed: const char * -> const char *\n+\t is better than char * -> const char *.  (jason 6/29/96) */\n+      if (TREE_TYPE (ics1) == TREE_TYPE (ics2))\n+\treturn -compare_qual (main1, main2);\n+#endif\n+    }\n+\n+  return 0;\n+}\n+\n+/* Compare two candidates for overloading as described in\n+   [over.match.best].  Return values:\n+\n+      1: cand1 is better than cand2\n+     -1: cand2 is better than cand1\n+      0: cand1 and cand2 are indistinguishable */\n+\n+static int\n+joust (cand1, cand2)\n+     struct z_candidate *cand1, *cand2;\n+{\n+  int winner = 0;\n+  int i, off1 = 0, off2 = 0, len;\n+\n+  /* a viable function F1\n+     is defined to be a better function than another viable function F2  if\n+     for  all arguments i, ICSi(F1) is not a worse conversion sequence than\n+     ICSi(F2), and then */\n+\n+  /* for some argument j, ICSj(F1) is a better conversion  sequence  than\n+     ICSj(F2) */\n+\n+  /* For comparing static and non-static member functions, we ignore the\n+     implicit object parameter of the non-static function.  The WP says to\n+     pretend that the static function has an object parm, but that won't\n+     work with operator overloading.  */\n+  len = TREE_VEC_LENGTH (cand1->convs);\n+  if (len != TREE_VEC_LENGTH (cand2->convs))\n+    {\n+      if (DECL_STATIC_FUNCTION_P (cand1->fn)\n+\t  && ! DECL_STATIC_FUNCTION_P (cand2->fn))\n+\toff2 = 1;\n+      else if (! DECL_STATIC_FUNCTION_P (cand1->fn)\n+\t       && DECL_STATIC_FUNCTION_P (cand2->fn))\n+\t{\n+\t  off1 = 1;\n+\t  --len;\n+\t}\n+      else\n+\tmy_friendly_abort (42);\n+    }\n+\n+  for (i = 0; i < len; ++i)\n+    {\n+      int comp = compare_ics (TREE_VEC_ELT (cand1->convs, i+off1),\n+\t\t\t      TREE_VEC_ELT (cand2->convs, i+off2));\n+\n+      if (comp != 0)\n+\t{\n+\t  if (winner && comp != winner)\n+\t    return 0;\n+\t  winner = comp;\n+\t}\n+    }\n+\n+  if (winner)\n+    return winner;\n+\n+  /* or, if not that,\n+     F1 is a non-template function and F2 is a template function */\n+\n+  if (! cand1->template && cand2->template)\n+    return 1;\n+  else if (cand1->template && ! cand2->template)\n+    return -1;\n+  else if (cand1->template && cand2->template)\n+    winner = more_specialized\n+      (TI_TEMPLATE (cand1->template), TI_TEMPLATE (cand2->template));\n+\n+  /* or, if not that,\n+     the  context  is  an  initialization by user-defined conversion (see\n+     _dcl.init_  and  _over.match.user_)  and  the  standard   conversion\n+     sequence  from  the return type of F1 to the destination type (i.e.,\n+     the type of the entity being initialized)  is  a  better  conversion\n+     sequence  than the standard conversion sequence from the return type\n+     of F2 to the destination type.  */\n+\n+  if (! winner && cand1->second_conv)\n+    winner = compare_ics (cand1->second_conv, cand2->second_conv);\n+\n+  /* If the built-in candidates are the same, arbitrarily pick one.  */\n+  if (! winner && cand1->fn == cand2->fn\n+      && TREE_CODE (cand1->fn) == IDENTIFIER_NODE)\n+    {\n+      for (i = 0; i < TREE_VEC_LENGTH (cand1->convs); ++i)\n+\tif (! comptypes (TREE_TYPE (TREE_VEC_ELT (cand1->convs, i)),\n+\t\t\t TREE_TYPE (TREE_VEC_ELT (cand2->convs, i)), 1))\n+\t  break;\n+      if (i == TREE_VEC_LENGTH (cand1->convs))\n+\treturn 1;\n+      /* Kludge around broken overloading rules whereby\n+\t bool ? void *const & : void *const & is ambiguous.  */\n+      if (cand1->fn == ansi_opname[COND_EXPR])\n+\t{\n+\t  tree c1 = TREE_VEC_ELT (cand1->convs, 1);\n+\t  tree c2 = TREE_VEC_ELT (cand2->convs, 1);\n+\t  tree t1 = strip_top_quals (non_reference (TREE_TYPE (c1)));\n+\t  tree t2 = strip_top_quals (non_reference (TREE_TYPE (c2)));\n+\n+\t  if (comptypes (t1, t2, 1))\n+\t    {\n+\t      if (TREE_CODE (c1) == REF_BIND && TREE_CODE (c2) != REF_BIND)\n+\t\treturn 1;\n+\t      if (TREE_CODE (c1) != REF_BIND && TREE_CODE (c2) == REF_BIND)\n+\t\treturn -1;\n+\t    }\n+\t}\n+    }\n+\n+  return winner;\n+}\n+\n+/* Given a list of candidates for overloading, find the best one, if any.\n+   This algorithm has a worst case of O(2n) (winner is last), and a best\n+   case of O(n/2) (totally ambiguous); much better than a sorting\n+   algorithm.  */\n+\n+static struct z_candidate *\n+tourney (candidates)\n+     struct z_candidate *candidates;\n+{\n+  struct z_candidate *champ = candidates, *challenger;\n+  int fate;\n+\n+  /* Walk through the list once, comparing each current champ to the next\n+     candidate, knocking out a candidate or two with each comparison.  */\n+\n+  for (challenger = champ->next; challenger; )\n+    {\n+      fate = joust (champ, challenger);\n+      if (fate == 1)\n+\tchallenger = challenger->next;\n+      else\n+\t{\n+\t  if (fate == 0)\n+\t    {\n+\t      champ = challenger->next;\n+\t      if (champ == 0)\n+\t\treturn 0;\n+\t    }\n+\t  else\n+\t    champ = challenger;\n+\n+\t  challenger = champ->next;\n+\t}\n+    }\n+\n+  /* Make sure the champ is better than all the candidates it hasn't yet\n+     been compared to.  This may do one more comparison than necessary.  Oh\n+     well.  */\n+\n+  for (challenger = candidates; challenger != champ;\n+       challenger = challenger->next)\n+    {\n+      fate = joust (champ, challenger);\n+      if (fate != 1)\n+\treturn 0;\n+    }\n+\n+  return champ;\n+}"}, {"sha": "676b13633267f06bc0b7024ad275d4987c77497e", "filename": "gcc/cp/class.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c73964b2fbce812d4ef49cdcb82b57a1550cfffa/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c73964b2fbce812d4ef49cdcb82b57a1550cfffa/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=c73964b2fbce812d4ef49cdcb82b57a1550cfffa", "patch": "@@ -4841,6 +4841,8 @@ instantiate_type (lhstype, rhs, complain)\n   if (TREE_TYPE (rhs) != NULL_TREE && ! (type_unknown_p (rhs)))\n     return rhs;\n \n+  rhs = copy_node (rhs);\n+\n   /* This should really only be used when attempting to distinguish\n      what sort of a pointer to function we have.  For now, any\n      arithmetic operation which is not supported on pointers\n@@ -5246,6 +5248,12 @@ instantiate_type (lhstype, rhs, complain)\n \tTREE_TYPE (rhs) = lhstype;\n \tTREE_OPERAND (rhs, 0) = fn;\n \tTREE_CONSTANT (rhs) = staticp (fn);\n+\tif (TREE_CODE (lhstype) == POINTER_TYPE &&\n+\t    TREE_CODE (TREE_TYPE (lhstype)) == METHOD_TYPE)\n+\t  {\n+\t    build_ptrmemfunc_type (lhstype);\n+\t    rhs = build_ptrmemfunc (lhstype, rhs, 0);\n+\t  }\n       }\n       return rhs;\n "}, {"sha": "19d98689091839a1521a02db5d13d5fedfed9fad", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c73964b2fbce812d4ef49cdcb82b57a1550cfffa/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c73964b2fbce812d4ef49cdcb82b57a1550cfffa/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=c73964b2fbce812d4ef49cdcb82b57a1550cfffa", "patch": "@@ -295,6 +295,11 @@ extern int flag_elide_constructors;\n \n extern int flag_ansi;\n \n+/* Nonzero means do argument matching for overloading according to the\n+   ANSI rules, rather than what g++ used to believe to be correct.  */\n+\n+extern int flag_ansi_overloading;\n+\n /* Nonzero means recognize and handle signature language constructs.  */\n \n extern int flag_handle_signatures;\n@@ -1841,7 +1846,8 @@ extern tree current_class_type;\t/* _TYPE: the type of the current class */\n      before LOOKUP_SPECULATIVELY is checked.\n    LOOKUP_NO_CONVERSION means that user-defined conversions are not\n      permitted.  Built-in conversions are permitted.\n-   LOOKUP_DESTRUCTOR means explicit call to destructor.  */\n+   LOOKUP_DESTRUCTOR means explicit call to destructor.\n+   LOOKUP_NO_TEMP_BIND means temporaries will not be bound to references.  */\n \n #define LOOKUP_PROTECT (1)\n #define LOOKUP_COMPLAIN (2)\n@@ -1855,6 +1861,7 @@ extern tree current_class_type;\t/* _TYPE: the type of the current class */\n #define INDIRECT_BIND (256)\n #define LOOKUP_NO_CONVERSION (512)\n #define LOOKUP_DESTRUCTOR (512)\n+#define LOOKUP_NO_TEMP_BIND (1024)\n \n /* These flags are used by the conversion code.\n    CONV_IMPLICIT   :  Perform implicit conversions (standard and user-defined).\n@@ -1935,6 +1942,9 @@ extern tree build_scoped_method_call\t\tPROTO((tree, tree, tree, tree));\n extern tree build_method_call\t\t\tPROTO((tree, tree, tree, tree, int));\n extern tree build_overload_call_real\t\tPROTO((tree, tree, int, struct candidate *, int));\n extern tree build_overload_call\t\t\tPROTO((tree, tree, int));\n+extern tree build_new_method_call\t\tPROTO((tree, tree, tree, tree, int));\n+extern tree build_new_function_call\t\tPROTO((tree, tree, tree));\n+extern tree build_new_op\t\t\tPROTO((enum tree_code, int, tree, tree, tree));\n \n /* in class.c */\n extern tree build_vbase_pointer\t\t\tPROTO((tree, tree));\n@@ -2057,6 +2067,7 @@ extern tree start_method\t\t\tPROTO((tree, tree, tree));\n extern tree finish_method\t\t\tPROTO((tree));\n extern void hack_incomplete_structures\t\tPROTO((tree));\n extern tree maybe_build_cleanup\t\t\tPROTO((tree));\n+extern tree maybe_build_cleanup_and_delete\tPROTO((tree));\n extern void cplus_expand_expr_stmt\t\tPROTO((tree));\n extern void finish_stmt\t\t\t\tPROTO((void));\n extern void pop_implicit_try_blocks\t\tPROTO((tree));\n@@ -2096,6 +2107,7 @@ extern void finish_builtin_type\t\t\tPROTO((tree, char *, tree *, int, tree));\n extern tree coerce_new_type\t\t\tPROTO((tree));\n extern tree coerce_delete_type\t\t\tPROTO((tree));\n extern void import_export_vtable\t\tPROTO((tree, tree, int));\n+extern int finish_prevtable_vardecl\t\tPROTO((tree, tree));\n extern int walk_vtables\t\t\t\tPROTO((void (*)(), int (*)()));\n extern void walk_sigtables\t\t\tPROTO((void (*)(), void (*)()));\n extern void finish_file\t\t\t\tPROTO((void));\n@@ -2330,6 +2342,7 @@ extern void init_search_processing\t\tPROTO((void));\n extern void reinit_search_statistics\t\tPROTO((void));\n extern tree current_scope\t\t\tPROTO((void));\n extern tree lookup_conversions\t\t\tPROTO((tree));\n+extern tree get_template_base\t\t\tPROTO((tree, tree));\n \n /* in sig.c */\n extern tree build_signature_pointer_type\tPROTO((tree, int, int));"}, {"sha": "f92eb1de9eb6298dc1da4a6b889f311df97985a0", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 17, "deletions": 2448, "changes": 2465, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c73964b2fbce812d4ef49cdcb82b57a1550cfffa/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c73964b2fbce812d4ef49cdcb82b57a1550cfffa/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=c73964b2fbce812d4ef49cdcb82b57a1550cfffa", "patch": "@@ -231,8 +231,6 @@ cp_convert_to_pointer (type, expr)\n \n   if (integer_zerop (expr))\n     {\n-      if (type == TREE_TYPE (null_pointer_node))\n-\treturn null_pointer_node;\n       expr = build_int_2 (0, 0);\n       TREE_TYPE (expr) = type;\n       return expr;\n@@ -270,8 +268,6 @@ convert_to_pointer_force (type, expr)\n   \n   if (integer_zerop (expr))\n     {\n-      if (type == TREE_TYPE (null_pointer_node))\n-\treturn null_pointer_node;\n       expr = build_int_2 (0, 0);\n       TREE_TYPE (expr) = type;\n       return expr;\n@@ -549,7 +545,7 @@ build_up_reference (type, arg, flags, checkconst)\n     case COMPOUND_EXPR:\n       {\n \ttree real_reference = build_up_reference (type, TREE_OPERAND (targ, 1),\n-\t\t\t\t\t\t  LOOKUP_PROTECT, checkconst);\n+\t\t\t\t\t\t  flags, checkconst);\n \trval = build (COMPOUND_EXPR, type, TREE_OPERAND (targ, 0), real_reference);\n \tTREE_CONSTANT (rval) = staticp (TREE_OPERAND (targ, 1));\n \treturn rval;\n@@ -561,7 +557,7 @@ build_up_reference (type, arg, flags, checkconst)\n     case INIT_EXPR:\n       {\n \ttree real_reference = build_up_reference (type, TREE_OPERAND (targ, 0),\n-\t\t\t\t\t\t  LOOKUP_PROTECT, checkconst);\n+\t\t\t\t\t\t  flags, checkconst);\n \trval = build (COMPOUND_EXPR, type, arg, real_reference);\n \tTREE_CONSTANT (rval) = staticp (TREE_OPERAND (targ, 0));\n \treturn rval;\n@@ -571,9 +567,9 @@ build_up_reference (type, arg, flags, checkconst)\n       return build (COND_EXPR, type,\n \t\t    TREE_OPERAND (targ, 0),\n \t\t    build_up_reference (type, TREE_OPERAND (targ, 1),\n-\t\t\t\t\tLOOKUP_PROTECT, checkconst),\n+\t\t\t\t\tflags, checkconst),\n \t\t    build_up_reference (type, TREE_OPERAND (targ, 2),\n-\t\t\t\t\tLOOKUP_PROTECT, checkconst));\n+\t\t\t\t\tflags, checkconst));\n \n       /* Undo the folding...  */\n     case MIN_EXPR:\n@@ -583,9 +579,9 @@ build_up_reference (type, arg, flags, checkconst)\n \t\t\t   boolean_type_node, TREE_OPERAND (targ, 0),\n \t\t\t   TREE_OPERAND (targ, 1)),\n \t\t    build_up_reference (type, TREE_OPERAND (targ, 0),\n-\t\t\t\t\tLOOKUP_PROTECT, checkconst),\n+\t\t\t\t\tflags, checkconst),\n \t\t    build_up_reference (type, TREE_OPERAND (targ, 1),\n-\t\t\t\t\tLOOKUP_PROTECT, checkconst));\n+\t\t\t\t\tflags, checkconst));\n \n     case BIND_EXPR:\n       arg = TREE_OPERAND (targ, 1);\n@@ -716,12 +712,11 @@ convert_to_reference (reftype, expr, convtype, flags, decl)\n     {\n       /* Look for a user-defined conversion to lvalue that we can use.  */\n \n-#ifdef NEW_OVER\n-      rval_as_conversion\n-\t= build_type_conversion (CONVERT_EXPR, reftype, expr, 1);\n-#else\n-      rval_as_conversion = build_type_conversion (CONVERT_EXPR, type, expr, 1);\n-#endif\n+      if (flag_ansi_overloading)\n+\trval_as_conversion\n+\t  = build_type_conversion (CONVERT_EXPR, reftype, expr, 1);\n+      else\n+\trval_as_conversion = build_type_conversion (CONVERT_EXPR, type, expr, 1);\n \n       if (rval_as_conversion && rval_as_conversion != error_mark_node\n \t  && real_lvalue_p (rval_as_conversion))\n@@ -1340,11 +1335,8 @@ cp_convert (type, expr, convtype, flags)\n \t  return conversion;\n \t}\n \n-#ifndef NEW_OVER\n-      if (TYPE_HAS_CONSTRUCTOR (complete_type (type)))\n-#else\n-      if (TYPE_HAS_CONSTRUCTOR (complete_type (type)) && ! conversion)\n-#endif\n+      if (TYPE_HAS_CONSTRUCTOR (complete_type (type))\n+\t  && (! flag_ansi_overloading || ! conversion))\n \tctor = build_method_call (NULL_TREE, ctor_identifier,\n \t\t\t\t  build_tree_list (NULL_TREE, e),\n \t\t\t\t  TYPE_BINFO (type),\n@@ -1504,16 +1496,16 @@ build_type_conversion (code, xtype, expr, for_sure)\n      tree xtype, expr;\n      int for_sure;\n {\n-#ifdef NEW_OVER\n-  return build_user_type_conversion\n-    (xtype, expr, for_sure ? LOOKUP_NORMAL : 0);\n-#else\n   /* C++: check to see if we can convert this aggregate type\n      into the required type.  */\n   tree basetype;\n   tree conv;\n   tree winner = NULL_TREE;\n \n+  if (flag_ansi_overloading)\n+    return build_user_type_conversion\n+      (xtype, expr, for_sure ? LOOKUP_NORMAL : 0);\n+\n   if (expr == error_mark_node)\n     return error_mark_node;\n \n@@ -1564,7 +1556,6 @@ build_type_conversion (code, xtype, expr, for_sure)\n \t\t\t\t    DECL_NAME (winner), for_sure);\n \n   return NULL_TREE;\n-#endif\n }\n \n /* Convert the given EXPR to one of a group of types suitable for use in an\n@@ -1852,2425 +1843,3 @@ type_promotes_to (type)\n \n   return cp_build_type_variant (type, constp, volatilep);\n }\n-\n-/* Work in progress.  Ask jason before removing.  */\n-\n-struct z_candidate {\n-  tree fn;\n-  tree convs;\n-  tree second_conv;\n-  int viable;\n-  tree basetype_path;\n-  tree template;\n-  struct z_candidate *next;\n-};\n-\n-#define IDENTITY_RANK 0\n-#define EXACT_RANK 1\n-#define PROMO_RANK 2\n-#define STD_RANK 3\n-#define PBOOL_RANK 4\n-#define USER_RANK 5\n-#define ELLIPSIS_RANK 6\n-\n-#define ICS_RANK(NODE)\t\t\t\t\\\n-  (ICS_ELLIPSIS_FLAG (NODE) ? ELLIPSIS_RANK\t\\\n-   : ICS_USER_FLAG (NODE) ? USER_RANK\t\t\\\n-   : ICS_STD_RANK (NODE))\n-\n-#define ICS_STD_RANK(NODE) TREE_COMPLEXITY (NODE)\n-\n-#define ICS_USER_FLAG(NODE) TREE_LANG_FLAG_0 (NODE)\n-#define ICS_ELLIPSIS_FLAG(NODE) TREE_LANG_FLAG_1 (NODE)\n-\n-#define USER_CONV_FN(NODE) TREE_OPERAND (NODE, 1)\n-\n-static struct z_candidate * build_user_type_conversion_1 ();\n-static tree convert_like ();\n-static tree build_over_call ();\n-static struct z_candidate * tourney ();\n-static void enforce_access ();\n-\n-int\n-null_ptr_cst (t)\n-     tree t;\n-{\n-  return (INTEGRAL_TYPE_P (TREE_TYPE (t)) && integer_zerop (t));\n-}\n-\n-tree\n-build_conv (code, type, from)\n-     enum tree_code code;\n-     tree type, from;\n-{\n-  tree t = build1 (code, type, from);\n-  int rank = ICS_STD_RANK (from);\n-  switch (code)\n-    {\n-    case PTR_CONV:\n-    case PMEM_CONV:\n-    case BASE_CONV:\n-    case STD_CONV:\n-      if (rank < STD_RANK)\n-\trank = STD_RANK;\n-      break;\n-\n-    case LVALUE_CONV:\n-    case QUAL_CONV:\n-    case RVALUE_CONV:\n-      if (rank < EXACT_RANK)\n-\trank = EXACT_RANK;\n-\n-    default:\n-      break;\n-    }\n-  ICS_STD_RANK (t) = rank;\n-  ICS_USER_FLAG (t) = ICS_USER_FLAG (from);\n-  return t;\n-}\n-\n-tree\n-non_reference (t)\n-     tree t;\n-{\n-  if (TREE_CODE (t) == REFERENCE_TYPE)\n-    t = TREE_TYPE (t);\n-  return t;\n-}\n-\n-/* Returns the standard conversion path (see [conv]) from type FROM to type\n-   TO, if any.  For proper handling of null pointer constants, you must\n-   also pass the expression EXPR to convert from.  */\n-\n-tree\n-standard_conversion (to, from, expr)\n-     tree to, from, expr;\n-{\n-  enum tree_code fcode, tcode;\n-  tree conv;\n-\n-  fcode = TREE_CODE (from);\n-  tcode = TREE_CODE (to);\n-\n-  conv = build1 (IDENTITY_CONV, from, expr);\n-\n-  if (from == to)\n-    return conv;\n-\n-  if (fcode == FUNCTION_TYPE)\n-    {\n-      from = build_pointer_type (from);\n-      fcode = TREE_CODE (from);\n-      conv = build_conv (LVALUE_CONV, from, conv);\n-    }\n-  else if (fcode == ARRAY_TYPE)\n-    {\n-      from = build_pointer_type (TREE_TYPE (from));\n-      fcode = TREE_CODE (from);\n-      conv = build_conv (LVALUE_CONV, from, conv);\n-    }\n-\n-  if ((tcode == POINTER_TYPE || TYPE_PTRMEMFUNC_P (to))\n-      && expr && null_ptr_cst (expr))\n-    {\n-      conv = build_conv (STD_CONV, to, conv);\n-    }\n-  else if (tcode == POINTER_TYPE && fcode == POINTER_TYPE)\n-    {\n-      enum tree_code ufcode = TREE_CODE (TREE_TYPE (from));\n-      enum tree_code utcode = TREE_CODE (TREE_TYPE (to));\n-\n-      if (comptypes (TYPE_MAIN_VARIANT (TREE_TYPE (from)),\n-\t\t     TYPE_MAIN_VARIANT (TREE_TYPE (to)), 1))\n-\t/* OK for now */;\n-      else if (utcode == VOID_TYPE && ufcode != OFFSET_TYPE\n-\t       && ufcode != FUNCTION_TYPE)\n-\t{\n-\t  from = build_pointer_type\n-\t    (cp_build_type_variant (void_type_node,\n-\t\t\t\t    TYPE_READONLY (TREE_TYPE (from)),\n-\t\t\t\t    TYPE_VOLATILE (TREE_TYPE (from))));\n-\t  conv = build_conv (PTR_CONV, from, conv);\n-\t}\n-      else if (ufcode == OFFSET_TYPE && utcode == OFFSET_TYPE)\n-\t{\n-\t  tree fbase = TYPE_OFFSET_BASETYPE (TREE_TYPE (from));\n-\t  tree tbase = TYPE_OFFSET_BASETYPE (TREE_TYPE (to));\n-\n-\t  if (DERIVED_FROM_P (fbase, tbase)\n-\t      && (comptypes (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (from))),\n-\t\t\t     TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (to))),\n-\t\t\t     1)))\n-\t    {\n-\t      from = build_offset_type (tbase, TREE_TYPE (TREE_TYPE (from)));\n-\t      from = build_pointer_type (from);\n-\t      conv = build_conv (PMEM_CONV, from, conv);\n-\t    }\n-\t  else\n-\t    return 0;\n-\t}\n-      else if (IS_AGGR_TYPE (TREE_TYPE (from))\n-\t       && IS_AGGR_TYPE (TREE_TYPE (to)))\n-\t{\n-\t  if (DERIVED_FROM_P (TREE_TYPE (to), TREE_TYPE (from)))\n-\t    {\n-\t      from = cp_build_type_variant (TREE_TYPE (to),\n-\t\t\t\t\t    TYPE_READONLY (TREE_TYPE (from)),\n-\t\t\t\t\t    TYPE_VOLATILE (TREE_TYPE (from)));\n-\t      from = build_pointer_type (from);\n-\t      conv = build_conv (PTR_CONV, from, conv);\n-\t    }\n-\t  else\n-\t    return 0;\n-\t}\n-      else\n-\treturn 0;\n-\n-      if (! comptypes (from, to, 1))\n-\t{\n-\t  if (! comp_ptr_ttypes (TREE_TYPE (to), TREE_TYPE (from)))\n-\t    return 0;\n-\n-\t  from = to;\n-\t  conv = build_conv (QUAL_CONV, from, conv);\n-\t}\n-    }\n-  else if (TYPE_PTRMEMFUNC_P (to) && TYPE_PTRMEMFUNC_P (from))\n-    {\n-      tree fromfn = TREE_TYPE (TYPE_PTRMEMFUNC_FN_TYPE (from));\n-      tree tofn = TREE_TYPE (TYPE_PTRMEMFUNC_FN_TYPE (to));\n-      tree fbase = TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (fromfn)));\n-      tree tbase = TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (tofn)));\n-\n-      if (! DERIVED_FROM_P (fbase, tbase)\n-\t  || ! comptypes (TREE_TYPE (fromfn), TREE_TYPE (tofn), 1)\n-\t  || ! compparms (TREE_CHAIN (TYPE_ARG_TYPES (fromfn)),\n-\t\t\t  TREE_CHAIN (TYPE_ARG_TYPES (tofn)), 1)\n-\t  || TYPE_READONLY (fbase) != TYPE_READONLY (tbase)\n-\t  || TYPE_VOLATILE (fbase) != TYPE_VOLATILE (tbase))\n-\treturn 0;\n-\n-      from = cp_build_type_variant (tbase, TYPE_READONLY (fbase),\n-\t\t\t\t    TYPE_VOLATILE (fbase));\n-      from = build_cplus_method_type (from, TREE_TYPE (fromfn),\n-\t\t\t\t      TREE_CHAIN (TYPE_ARG_TYPES (fromfn)));\n-      conv = build_conv (PMEM_CONV, from, conv);\n-    }\n-  else if (tcode == BOOLEAN_TYPE)\n-    {\n-      if (! (INTEGRAL_CODE_P (fcode) || fcode == REAL_TYPE\n-\t     || fcode == POINTER_TYPE || TYPE_PTRMEMFUNC_P (from)))\n-\treturn 0;\n-\n-      conv = build_conv (STD_CONV, to, conv);\n-      if (fcode == POINTER_TYPE || TYPE_PTRMEMFUNC_P (from)\n-\t  && ICS_STD_RANK (conv) < PBOOL_RANK)\n-\tICS_STD_RANK (conv) = PBOOL_RANK;\n-    }\n-  /* We don't check for ENUMERAL_TYPE here because there are no standard\n-     conversions to enum type.  */\n-  else if (tcode == INTEGER_TYPE || tcode == BOOLEAN_TYPE\n-\t   || tcode == REAL_TYPE)\n-    {\n-      if (! (INTEGRAL_CODE_P (fcode) || fcode == REAL_TYPE))\n-\treturn 0;\n-      conv = build_conv (STD_CONV, to, conv);\n-\n-      /* Give this a better rank if it's a promotion.  */\n-      if (to == type_promotes_to (from)\n-\t  && ICS_STD_RANK (TREE_OPERAND (conv, 0)) <= PROMO_RANK)\n-\tICS_STD_RANK (conv) = PROMO_RANK;\n-    }\n-  else if (IS_AGGR_TYPE (to) && IS_AGGR_TYPE (from)\n-\t   && DERIVED_FROM_P (to, from))\n-    conv = build_conv (BASE_CONV, to, conv);\n-  else\n-    return 0;\n-\n-  return conv;\n-}\n-\n-/* Returns the conversion path from type FROM to reference type TO for\n-   purposes of reference binding.  For lvalue binding, either pass a\n-   reference type to FROM or an lvalue expression to EXPR.\n-\n-   Currently does not distinguish in the generated trees between binding to\n-   an lvalue and a temporary.  Should it?  */\n-\n-tree\n-reference_binding (rto, from, expr)\n-     tree rto, from, expr;\n-{\n-  tree conv;\n-  int lvalue = 1;\n-  tree to = TREE_TYPE (rto);\n-\n-  if (TREE_CODE (from) == REFERENCE_TYPE)\n-    from = TREE_TYPE (from);\n-  else if (! expr || ! real_lvalue_p (expr))\n-    lvalue = 0;\n-\n-  if (lvalue\n-      && TYPE_READONLY (to) >= TYPE_READONLY (from)\n-      && TYPE_VOLATILE (to) >= TYPE_VOLATILE (from))\n-    {\n-      conv = build1 (IDENTITY_CONV, from, expr);\n-\n-      if (TYPE_MAIN_VARIANT (to) == TYPE_MAIN_VARIANT (from))\n-\tconv = build_conv (REF_BIND, rto, conv);\n-      else if (IS_AGGR_TYPE (to) && IS_AGGR_TYPE (from)\n-\t       && DERIVED_FROM_P (to, from))\n-\t{\n-\t  conv = build_conv (REF_BIND, rto, conv);\n-\t  ICS_STD_RANK (conv) = STD_RANK;\n-\t}\n-      else\n-\tconv = NULL_TREE;\n-    }\n-  else\n-    conv = NULL_TREE;\n-\n-  if (! conv && TYPE_READONLY (to) && ! TYPE_VOLATILE (to))\n-    {\n-      conv = standard_conversion\n-\t(TYPE_MAIN_VARIANT (to), TYPE_MAIN_VARIANT (from), expr);\n-      if (conv)\n-\t{\n-\t  conv = build_conv (REF_BIND, rto, conv);\n-\n-\t  /* Bind directly to a base subobject of a class rvalue.  */\n-\t  if (TREE_CODE (TREE_OPERAND (conv, 0)) == BASE_CONV)\n-\t    TREE_OPERAND (conv, 0) = TREE_OPERAND (TREE_OPERAND (conv, 0), 0);\n-\t}\n-    }\n-\n-  return conv;\n-}\n-\n-/* Returns the implicit conversion sequence (see [over.ics]) from type FROM\n-   to type TO.  The optional expression EXPR may affect the conversion.\n-   FLAGS are the usual overloading flags.  Only LOOKUP_NO_CONVERSION is\n-   significant.  */\n-\n-tree\n-implicit_conversion (to, from, expr, flags)\n-     tree to, from, expr;\n-     int flags;\n-{\n-  tree conv;\n-  struct z_candidate *cand;\n-\n-  if (expr && type_unknown_p (expr))\n-    {\n-      expr = instantiate_type (to, expr, 0);\n-      if (expr == error_mark_node)\n-\treturn 0;\n-      from = TREE_TYPE (expr);\n-    }\n-\n-  if (TREE_CODE (to) == REFERENCE_TYPE)\n-    conv = reference_binding (to, from, expr);\n-  else\n-    conv = standard_conversion\n-      (TYPE_MAIN_VARIANT (non_reference (to)),\n-       TYPE_MAIN_VARIANT (non_reference (from)), expr);\n-\n-  if (conv)\n-    {\n-      if (TREE_CODE (conv) == IDENTITY_CONV && IS_AGGR_TYPE (to)\n-\t  && (TREE_CODE (from) == REFERENCE_TYPE || (expr && real_lvalue_p (expr))))\n-\tconv = build_conv (RVALUE_CONV, to, conv);\n-    }\n-  else if ((IS_AGGR_TYPE (non_reference (from))\n-\t    || IS_AGGR_TYPE (non_reference (to)))\n-\t   && (flags & LOOKUP_NO_CONVERSION) == 0)\n-    {\n-      if (TREE_CODE (to) == REFERENCE_TYPE\n-\t  && TYPE_READONLY (TREE_TYPE (to))\n-\t  && ! TYPE_VOLATILE (TREE_TYPE (to)))\n-\t{\n-\t  cand = build_user_type_conversion_1\n-\t    (TYPE_MAIN_VARIANT (TREE_TYPE (to)), expr, LOOKUP_ONLYCONVERTING);\n-\t  if (cand)\n-\t    conv = build_conv (REF_BIND, to, cand->second_conv);\n-\t}\n-      else\n-\t{\n-\t  cand = build_user_type_conversion_1\n-\t    (to, expr, LOOKUP_ONLYCONVERTING);\n-\t  if (cand)\n-\t    conv = cand->second_conv;\n-\t}\n-    }\n-\n-  return conv;\n-}\n-\n-/* Create an overload candidate for the function or method FN called with\n-   the argument list ARGLIST and add it to CANDIDATES.  FLAGS is passed on\n-   to implicit_conversion.  */\n-\n-static struct z_candidate *\n-add_function_candidate (candidates, fn, arglist, flags)\n-     struct z_candidate *candidates;\n-     tree fn, arglist;\n-     int flags;\n-{\n-  tree parmlist = TYPE_ARG_TYPES (TREE_TYPE (fn));\n-  int i, len = list_length (arglist);\n-  tree convs = make_tree_vec (len);\n-  tree parmnode = parmlist;\n-  tree argnode = arglist;\n-  int viable = 1;\n-  struct z_candidate *cand;\n-\n-  /* The `this' and `in_chrg' arguments to constructors are not considered\n-     in overload resolution.  */\n-  if (DECL_CONSTRUCTOR_P (fn))\n-    {\n-      parmnode = TREE_CHAIN (parmnode);\n-      if (TYPE_USES_VIRTUAL_BASECLASSES (DECL_CONTEXT (fn)))\n-\tparmnode = TREE_CHAIN (parmnode);\n-    }\n-\n-  for (i = 0; i < len; ++i)\n-    {\n-      tree arg = TREE_VALUE (argnode);\n-      tree argtype = TREE_TYPE (arg);\n-      tree t;\n-\n-      argtype = cp_build_type_variant\n-\t(argtype, TREE_READONLY (arg), TREE_THIS_VOLATILE (arg));\n-\n-      if (parmnode == void_list_node)\n-\tbreak;\n-      else if (parmnode)\n-\tt = implicit_conversion (TREE_VALUE (parmnode), argtype, arg, flags);\n-      else\n-\t{\n-\t  t = build1 (IDENTITY_CONV, argtype, arg);\n-\t  ICS_ELLIPSIS_FLAG (t) = 1;\n-\t}\n-\n-      TREE_VEC_ELT (convs, i) = t;\n-      if (! t)\n-\tbreak;\n-\n-      if (parmnode)\n-\tparmnode = TREE_CHAIN (parmnode);\n-      argnode = TREE_CHAIN (argnode);\n-    }\n-\n-  if (i < len)\n-    viable = 0;\n-\n-  /* Make sure there are default args for the rest of the parms.  */\n-  for (; parmnode && parmnode != void_list_node;\n-       parmnode = TREE_CHAIN (parmnode))\n-    if (! TREE_PURPOSE (parmnode))\n-      {\n-\tviable = 0;\n-\tbreak;\n-      }\n-\n-  cand = (struct z_candidate *) oballoc (sizeof (struct z_candidate));\n-\n-  cand->fn = fn;\n-  cand->convs = convs;\n-  cand->second_conv = NULL_TREE;\n-  cand->viable = viable;\n-  cand->basetype_path = NULL_TREE;\n-  cand->template = NULL_TREE;\n-  cand->next = candidates;\n-\n-  return cand;\n-}\n-\n-/* Create an overload candidate for the conversion function FN which will\n-   be invoked for expression OBJ, producing a pointer-to-function which\n-   will in turn be called with the argument list ARGLIST, and add it to\n-   CANDIDATES.  FLAGS is passed on to implicit_conversion.  */\n-\n-static struct z_candidate *\n-add_conv_candidate (candidates, fn, obj, arglist)\n-     struct z_candidate *candidates;\n-     tree fn, obj, arglist;\n-{\n-  tree totype = TREE_TYPE (TREE_TYPE (fn));\n-  tree parmlist = TYPE_ARG_TYPES (TREE_TYPE (totype));\n-  int i, len = list_length (arglist) + 1;\n-  tree convs = make_tree_vec (len);\n-  tree parmnode = parmlist;\n-  tree argnode = arglist;\n-  int viable = 1;\n-  struct z_candidate *cand;\n-  int flags = LOOKUP_NORMAL;\n-\n-  for (i = 0; i < len; ++i)\n-    {\n-      tree arg = i == 0 ? obj : TREE_VALUE (argnode);\n-      tree argtype = TREE_TYPE (arg);\n-      tree t;\n-\n-      argtype = cp_build_type_variant\n-\t(argtype, TREE_READONLY (arg), TREE_THIS_VOLATILE (arg));\n-\n-      if (i == 0)\n-\tt = implicit_conversion (totype, argtype, arg, flags);\n-      else if (parmnode == void_list_node)\n-\tbreak;\n-      else if (parmnode)\n-\tt = implicit_conversion (TREE_VALUE (parmnode), argtype, arg, flags);\n-      else\n-\t{\n-\t  t = build1 (IDENTITY_CONV, argtype, arg);\n-\t  ICS_ELLIPSIS_FLAG (t) = 1;\n-\t}\n-\n-      TREE_VEC_ELT (convs, i) = t;\n-      if (! t)\n-\tbreak;\n-\n-      if (i == 0)\n-\tcontinue;\n-\n-      if (parmnode)\n-\tparmnode = TREE_CHAIN (parmnode);\n-      argnode = TREE_CHAIN (argnode);\n-    }\n-\n-  if (i < len)\n-    viable = 0;\n-\n-  for (; parmnode && parmnode != void_list_node;\n-       parmnode = TREE_CHAIN (parmnode))\n-    if (! TREE_PURPOSE (parmnode))\n-      {\n-\tviable = 0;\n-\tbreak;\n-      }\n-\n-  cand = (struct z_candidate *) oballoc (sizeof (struct z_candidate));\n-\n-  cand->fn = fn;\n-  cand->convs = convs;\n-  cand->second_conv = NULL_TREE;\n-  cand->viable = viable;\n-  cand->basetype_path = NULL_TREE;\n-  cand->template = NULL_TREE;\n-  cand->next = candidates;\n-\n-  return cand;\n-}\n-\n-int\n-ptr_complete_ob (t)\n-     tree t;\n-{\n-  return (TREE_CODE (t) == POINTER_TYPE\n-\t  && TREE_CODE (TREE_TYPE (t)) != OFFSET_TYPE\n-\t  && TREE_CODE (TREE_TYPE (t)) != FUNCTION_TYPE\n-\t  && TREE_CODE (TREE_TYPE (t)) != VOID_TYPE\n-\t  && TYPE_SIZE (complete_type (TREE_TYPE (t))) != NULL_TREE);\n-}\n-\n-#define TYPE_PTRMEM_P(NODE)\t\t\t\t\t\\\n-  (TREE_CODE (NODE) == POINTER_TYPE\t\t\t\t\\\n-   && TREE_CODE (TREE_TYPE (NODE)) == OFFSET_TYPE)\n-#define TYPE_PTR_P(NODE)\t\t\t\t\\\n-  (TREE_CODE (NODE) == POINTER_TYPE\t\t\t\\\n-   && TREE_CODE (TREE_TYPE (NODE)) != OFFSET_TYPE)\n-#define TYPE_PTROB_P(NODE)\t\t\t\t\t\t\\\n-  (TYPE_PTR_P (NODE) && TREE_CODE (TREE_TYPE (NODE)) != FUNCTION_TYPE\t\\\n-   && TREE_CODE (TREE_TYPE (NODE)) != VOID_TYPE)\n-\n-static struct z_candidate *\n-build_builtin_candidate (candidates, fnname, type1, type2,\n-\t\t\t args, argtypes, flags)\n-     struct z_candidate *candidates;\n-     tree fnname, type1, type2, *args, *argtypes;\n-     int flags;\n-\n-{\n-  tree t, convs;\n-  int viable = 1, i;\n-  struct z_candidate *cand;\n-  tree types[2];\n-\n-  types[0] = type1;\n-  types[1] = type2;\n-\n-  convs = make_tree_vec (args[2] ? 3 : (args[1] ? 2 : 1));\n-\n-  for (i = 0; i < 2; ++i)\n-    {\n-      if (! args[i])\n-\tbreak;\n-\n-      t = implicit_conversion (types[i], argtypes[i], args[i], flags);\n-      if (! t)\n-\t{\n-\t  viable = 0;\n-\t  /* We need something for printing the candidate.  */\n-\t  t = build1 (IDENTITY_CONV, types[i], NULL_TREE);\n-\t}\n-      TREE_VEC_ELT (convs, i) = t;\n-    }\n-\n-  /* For COND_EXPR we rearranged the arguments; undo that now.  */\n-  if (args[2])\n-    {\n-      TREE_VEC_ELT (convs, 2) = TREE_VEC_ELT (convs, 1);\n-      TREE_VEC_ELT (convs, 1) = TREE_VEC_ELT (convs, 0);\n-      t = implicit_conversion (boolean_type_node, argtypes[2], args[2], flags);\n-      if (t)\n-\tTREE_VEC_ELT (convs, 0) = t;\n-      else\n-\tviable = 0;\n-    }      \n-\n-  cand = (struct z_candidate *) oballoc (sizeof (struct z_candidate));\n-\n-  cand->fn = fnname;\n-  cand->convs = convs;\n-  cand->second_conv = NULL_TREE;\n-  cand->viable = viable;\n-  cand->basetype_path = NULL_TREE;\n-  cand->template = NULL_TREE;\n-  cand->next = candidates;\n-\n-  return cand;\n-}\n-\n-int\n-is_complete (t)\n-     tree t;\n-{\n-  return TYPE_SIZE (complete_type (t)) != NULL_TREE;\n-}\n-\n-/* Create any builtin operator overload candidates for the operator in\n-   question given the converted operand types TYPE1 and TYPE2.  The other\n-   args are passed through from add_builtin_candidates to\n-   build_builtin_candidate.  */\n-\n-static struct z_candidate *\n-add_builtin_candidate (candidates, code, code2, fnname, type1, type2,\n-\t\t       args, argtypes, flags)\n-     struct z_candidate *candidates;\n-     enum tree_code code, code2;\n-     tree fnname, type1, type2, *args, *argtypes;\n-     int flags;\n-{\n-  switch (code)\n-    {\n-    case POSTINCREMENT_EXPR:\n-    case POSTDECREMENT_EXPR:\n-      args[1] = integer_zero_node;\n-      type2 = integer_type_node;\n-    }\n-\n-  switch (code)\n-    {\n-\n-/* 4 For every pair T, VQ), where T is an arithmetic or  enumeration  type,\n-     and  VQ  is  either  volatile or empty, there exist candidate operator\n-     functions of the form\n-\t     VQ T&   operator++(VQ T&);\n-\t     T       operator++(VQ T&, int);\n-   5 For every pair T, VQ), where T is an enumeration type or an arithmetic\n-     type  other than bool, and VQ is either volatile or empty, there exist\n-     candidate operator functions of the form\n-\t     VQ T&   operator--(VQ T&);\n-\t     T       operator--(VQ T&, int);\n-   6 For every pair T, VQ), where T is  a  cv-qualified  or  cv-unqualified\n-     complete  object type, and VQ is either volatile or empty, there exist\n-     candidate operator functions of the form\n-\t     T*VQ&   operator++(T*VQ&);\n-\t     T*VQ&   operator--(T*VQ&);\n-\t     T*      operator++(T*VQ&, int);\n-\t     T*      operator--(T*VQ&, int);  */\n-\n-    case POSTDECREMENT_EXPR:\n-    case PREDECREMENT_EXPR:\n-      if (TREE_CODE (type1) == BOOLEAN_TYPE)\n-\treturn candidates;\n-    case POSTINCREMENT_EXPR:\n-    case PREINCREMENT_EXPR:\n-      if (ARITHMETIC_TYPE_P (type1) || ptr_complete_ob (type1))\n-\t{\n-\t  type1 = build_reference_type (type1);\n-\t  break;\n-\t}\n-      return candidates;\n-\n-/* 7 For every cv-qualified or cv-unqualified complete object type T, there\n-     exist candidate operator functions of the form\n-\n-\t     T&      operator*(T*);\n-\n-   8 For every function type T, there exist candidate operator functions of\n-     the form\n-\t     T&      operator*(T*);  */\n-\n-    case INDIRECT_REF:\n-      if (TREE_CODE (type1) == POINTER_TYPE\n-\t  && (ptr_complete_ob (type1)\n-\t      || TREE_CODE (TREE_TYPE (type1)) == FUNCTION_TYPE))\n-\tbreak;\n-      return candidates;\n-\n-/* 9 For every type T, there exist candidate operator functions of the form\n-\t     T*      operator+(T*);\n-\n-   10For  every  promoted arithmetic type T, there exist candidate operator\n-     functions of the form\n-\t     T       operator+(T);\n-\t     T       operator-(T);  */\n-\n-    case CONVERT_EXPR: /* unary + */\n-      if (TREE_CODE (type1) == POINTER_TYPE\n-\t  && TREE_CODE (TREE_TYPE (type1)) != OFFSET_TYPE)\n-\tbreak;\n-    case NEGATE_EXPR:\n-      if (ARITHMETIC_TYPE_P (type1))\n-\tbreak;\n-      return candidates;\n-\n-/* 11For every promoted integral type T,  there  exist  candidate  operator\n-     functions of the form\n-\t     T       operator~(T);  */\n-\n-    case BIT_NOT_EXPR:\n-      if (INTEGRAL_TYPE_P (type1))\n-\tbreak;\n-      return candidates;\n-\n-/* 12For every quintuple C1, C2, T, CV1, CV2), where C2 is a class type, C1\n-     is the same type as C2 or is a derived class of C2, T  is  a  complete\n-     object type or a function type, and CV1 and CV2 are cv-qualifier-seqs,\n-     there exist candidate operator functions of the form\n-\t     CV12 T& operator->*(CV1 C1*, CV2 T C2::*);\n-     where CV12 is the union of CV1 and CV2.  */\n-\n-    case MEMBER_REF:\n-      if (TREE_CODE (type1) == POINTER_TYPE\n-\t  && (TYPE_PTRMEMFUNC_P (type2) || TYPE_PTRMEM_P (type2)))\n-\t{\n-\t  tree c1 = TREE_TYPE (type1);\n-\t  tree c2 = (TYPE_PTRMEMFUNC_P (type2)\n-\t\t     ? TYPE_METHOD_BASETYPE (TYPE_PTRMEMFUNC_FN_TYPE (type2))\n-\t\t     : TYPE_OFFSET_BASETYPE (TREE_TYPE (type2)));\n-\n-\t  if (IS_AGGR_TYPE (c1) && DERIVED_FROM_P (c2, c1)\n-\t      && (TYPE_PTRMEMFUNC_P (type2)\n-\t\t  || is_complete (TREE_TYPE (TREE_TYPE (type2)))))\n-\t    break;\n-\t}\n-      return candidates;\n-\n-/* 13For every pair of promoted arithmetic types L and R, there exist  can-\n-     didate operator functions of the form\n-\t     LR      operator*(L, R);\n-\t     LR      operator/(L, R);\n-\t     LR      operator+(L, R);\n-\t     LR      operator-(L, R);\n-\t     bool    operator<(L, R);\n-\t     bool    operator>(L, R);\n-\t     bool    operator<=(L, R);\n-\t     bool    operator>=(L, R);\n-\t     bool    operator==(L, R);\n-\t     bool    operator!=(L, R);\n-     where  LR  is  the  result of the usual arithmetic conversions between\n-     types L and R.\n-\n-   14For every pair of types T and I, where T  is  a  cv-qualified  or  cv-\n-     unqualified  complete  object  type and I is a promoted integral type,\n-     there exist candidate operator functions of the form\n-\t     T*      operator+(T*, I);\n-\t     T&      operator[](T*, I);\n-\t     T*      operator-(T*, I);\n-\t     T*      operator+(I, T*);\n-\t     T&      operator[](I, T*);\n-\n-   15For every T, where T is a pointer to complete object type, there exist\n-     candidate operator functions of the form112)\n-\t     ptrdiff_t operator-(T, T);\n-\n-   16For  every pointer type T, there exist candidate operator functions of\n-     the form\n-\t     bool    operator<(T, T);\n-\t     bool    operator>(T, T);\n-\t     bool    operator<=(T, T);\n-\t     bool    operator>=(T, T);\n-\t     bool    operator==(T, T);\n-\t     bool    operator!=(T, T);\n-\n-   17For every pointer to member type T,  there  exist  candidate  operator\n-     functions of the form\n-\t     bool    operator==(T, T);\n-\t     bool    operator!=(T, T);  */\n-\n-    case MINUS_EXPR:\n-      if (ptr_complete_ob (type1) && ptr_complete_ob (type2))\n-\tbreak;\n-      if (ptr_complete_ob (type1) && INTEGRAL_TYPE_P (type2))\n-\t{\n-\t  type2 = ptrdiff_type_node;\n-\t  break;\n-\t}\n-    case MULT_EXPR:\n-    case TRUNC_DIV_EXPR:\n-      if (ARITHMETIC_TYPE_P (type1) && ARITHMETIC_TYPE_P (type2))\n-\tbreak;\n-      return candidates;\n-\n-    case EQ_EXPR:\n-    case NE_EXPR:\n-      if (TYPE_PTRMEMFUNC_P (type1) && TYPE_PTRMEMFUNC_P (type2)\n-\t  || TYPE_PTRMEM_P (type1) && TYPE_PTRMEM_P (type2))\n-\tbreak;\n-      if ((TYPE_PTRMEMFUNC_P (type1) || TYPE_PTRMEM_P (type1))\n-\t  && null_ptr_cst (args[1]))\n-\t{\n-\t  type2 = type1;\n-\t  break;\n-\t}\n-      if ((TYPE_PTRMEMFUNC_P (type2) || TYPE_PTRMEM_P (type2))\n-\t  && null_ptr_cst (args[0]))\n-\t{\n-\t  type1 = type2;\n-\t  break;\n-\t}\n-    case LT_EXPR:\n-    case GT_EXPR:\n-    case LE_EXPR:\n-    case GE_EXPR:\n-    case MAX_EXPR:\n-    case MIN_EXPR:\n-      if (ARITHMETIC_TYPE_P (type1) && ARITHMETIC_TYPE_P (type2)\n-\t  || TYPE_PTR_P (type1) && TYPE_PTR_P (type2))\n-\tbreak;\n-      if (TYPE_PTR_P (type1) && null_ptr_cst (args[1]))\n-\t{\n-\t  type2 = type1;\n-\t  break;\n-\t}\n-      if (null_ptr_cst (args[0]) && TYPE_PTR_P (type2))\n-\t{\n-\t  type1 = type2;\n-\t  break;\n-\t}\n-      return candidates;\n-\n-    case PLUS_EXPR:\n-      if (ARITHMETIC_TYPE_P (type1) && ARITHMETIC_TYPE_P (type2))\n-\tbreak;\n-    case ARRAY_REF:\n-      if (INTEGRAL_TYPE_P (type1) && ptr_complete_ob (type2))\n-\t{\n-\t  type1 = ptrdiff_type_node;\n-\t  break;\n-\t}\n-      if (ptr_complete_ob (type1) && INTEGRAL_TYPE_P (type2))\n-\t{\n-\t  type2 = ptrdiff_type_node;\n-\t  break;\n-\t}\n-      return candidates;\n-\n-/* 18For  every pair of promoted integral types L and R, there exist candi-\n-     date operator functions of the form\n-\t     LR      operator%(L, R);\n-\t     LR      operator&(L, R);\n-\t     LR      operator^(L, R);\n-\t     LR      operator|(L, R);\n-\t     L       operator<<(L, R);\n-\t     L       operator>>(L, R);\n-     where LR is the result of the  usual  arithmetic  conversions  between\n-     types L and R.  */\n-\n-    case TRUNC_MOD_EXPR:\n-    case BIT_AND_EXPR:\n-    case BIT_IOR_EXPR:\n-    case BIT_XOR_EXPR:\n-    case LSHIFT_EXPR:\n-    case RSHIFT_EXPR:\n-      if (INTEGRAL_TYPE_P (type1) && INTEGRAL_TYPE_P (type2))\n-\tbreak;\n-      return candidates;\n-\n-/* 19For  every  triple  L, VQ, R), where L is an arithmetic or enumeration\n-     type, VQ is either volatile or empty, and R is a  promoted  arithmetic\n-     type, there exist candidate operator functions of the form\n-\t     VQ L&   operator=(VQ L&, R);\n-\t     VQ L&   operator*=(VQ L&, R);\n-\t     VQ L&   operator/=(VQ L&, R);\n-\t     VQ L&   operator+=(VQ L&, R);\n-\t     VQ L&   operator-=(VQ L&, R);\n-\n-   20For  every  pair T, VQ), where T is any type and VQ is either volatile\n-     or empty, there exist candidate operator functions of the form\n-\t     T*VQ&   operator=(T*VQ&, T*);\n-\n-   21For every pair T, VQ), where T is a pointer to member type and  VQ  is\n-     either  volatile or empty, there exist candidate operator functions of\n-     the form\n-\t     VQ T&   operator=(VQ T&, T);\n-\n-   22For every triple  T,  VQ,  I),  where  T  is  a  cv-qualified  or  cv-\n-     unqualified  complete object type, VQ is either volatile or empty, and\n-     I is a promoted integral type, there exist  candidate  operator  func-\n-     tions of the form\n-\t     T*VQ&   operator+=(T*VQ&, I);\n-\t     T*VQ&   operator-=(T*VQ&, I);\n-\n-   23For  every  triple  L,  VQ,  R), where L is an integral or enumeration\n-     type, VQ is either volatile or empty, and R  is  a  promoted  integral\n-     type, there exist candidate operator functions of the form\n-\n-\t     VQ L&   operator%=(VQ L&, R);\n-\t     VQ L&   operator<<=(VQ L&, R);\n-\t     VQ L&   operator>>=(VQ L&, R);\n-\t     VQ L&   operator&=(VQ L&, R);\n-\t     VQ L&   operator^=(VQ L&, R);\n-\t     VQ L&   operator|=(VQ L&, R);  */\n-\n-    case MODIFY_EXPR:\n-      switch (code2)\n-\t{\n-\tcase PLUS_EXPR:\n-\tcase MINUS_EXPR:\n-\t  if (ptr_complete_ob (type1) && INTEGRAL_TYPE_P (type2))\n-\t    {\n-\t      type2 = ptrdiff_type_node;\n-\t      break;\n-\t    }\n-\tcase MULT_EXPR:\n-\tcase TRUNC_DIV_EXPR:\n-\t  if (ARITHMETIC_TYPE_P (type1) && ARITHMETIC_TYPE_P (type2))\n-\t    break;\n-\t  return candidates;\n-\n-\tcase TRUNC_MOD_EXPR:\n-\tcase BIT_AND_EXPR:\n-\tcase BIT_IOR_EXPR:\n-\tcase BIT_XOR_EXPR:\n-\tcase LSHIFT_EXPR:\n-\tcase RSHIFT_EXPR:\n-\t  if (INTEGRAL_TYPE_P (type1) && INTEGRAL_TYPE_P (type2))\n-\t    break;\n-\t  return candidates;\n-\n-\tcase NOP_EXPR:\n-\t  if (ARITHMETIC_TYPE_P (type1) && ARITHMETIC_TYPE_P (type2))\n-\t    break;\n-\t  if ((TYPE_PTRMEMFUNC_P (type1) && TYPE_PTRMEMFUNC_P (type2))\n-\t      || (TYPE_PTR_P (type1) && TYPE_PTR_P (type2))\n-\t      || (TYPE_PTRMEM_P (type1) && TYPE_PTRMEM_P (type2))\n-\t      || ((TYPE_PTRMEMFUNC_P (type1)\n-\t\t   || TREE_CODE (type1) == POINTER_TYPE)\n-\t\t  && null_ptr_cst (args[1])))\n-\t    {\n-\t      type2 = type1;\n-\t      break;\n-\t    }\n-\t  return candidates;\n-\n-\tdefault:\n-\t  my_friendly_abort (367);\n-\t}\n-      type1 = build_reference_type (type1);\n-      break;\n-\n-    case COND_EXPR:\n-      if (TREE_CODE (type1) == ENUMERAL_TYPE && type1 == type2)\n-\tbreak;\n-      else if (TREE_CODE (type1) == ENUMERAL_TYPE\n-\t       || TREE_CODE (type2) == ENUMERAL_TYPE)\n-\treturn candidates;\n-      if (ARITHMETIC_TYPE_P (type1) && ARITHMETIC_TYPE_P (type2))\n-\tbreak;\n-      if (TREE_CODE (type1) == TREE_CODE (type2)\n-\t  && (TREE_CODE (type1) == REFERENCE_TYPE\n-\t      || TREE_CODE (type1) == POINTER_TYPE\n-\t      || TYPE_PTRMEMFUNC_P (type1)\n-\t      || IS_AGGR_TYPE (type1)))\n-\tbreak;\n-      if (TREE_CODE (type1) == REFERENCE_TYPE\n-\t  || TREE_CODE (type2) == REFERENCE_TYPE)\n-\treturn candidates;\n-      if (((TYPE_PTRMEMFUNC_P (type1) || TREE_CODE (type1) == POINTER_TYPE)\n-\t   && null_ptr_cst (args[1]))\n-\t  || IS_AGGR_TYPE (type1))\n-\t{\n-\t  type2 = type1;\n-\t  break;\n-\t}\n-      if (((TYPE_PTRMEMFUNC_P (type2) || TREE_CODE (type2) == POINTER_TYPE)\n-\t   && null_ptr_cst (args[0]))\n-\t  || IS_AGGR_TYPE (type2))\n-\t{\n-\t  type1 = type2;\n-\t  break;\n-\t}\n-      return candidates;\n-\n-    default:\n-      my_friendly_abort (367);\n-    }\n-\n-  /* If we're dealing with two pointer types, we need candidates\n-     for both of them.  */\n-  if (type2 && type1 != type2\n-      && TREE_CODE (type1) == TREE_CODE (type2)\n-      && (TREE_CODE (type1) == REFERENCE_TYPE\n-\t  || TREE_CODE (type1) == POINTER_TYPE\n-\t  || TYPE_PTRMEMFUNC_P (type1)\n-\t  || IS_AGGR_TYPE (type1)))\n-    {\n-      candidates = build_builtin_candidate\n-\t(candidates, fnname, type1, type1, args, argtypes, flags);\n-      return build_builtin_candidate\n-\t(candidates, fnname, type2, type2, args, argtypes, flags);\n-    }\n-\n-  return build_builtin_candidate\n-    (candidates, fnname, type1, type2, args, argtypes, flags);\n-}\n-\n-tree\n-type_decays_to (type)\n-     tree type;\n-{\n-  if (TREE_CODE (type) == ARRAY_TYPE)\n-    return build_pointer_type (TREE_TYPE (type));\n-  if (TREE_CODE (type) == FUNCTION_TYPE)\n-    return build_pointer_type (type);\n-  return type;\n-}\n-\n-/* There are three conditions of builtin candidates:\n-\n-   1) bool-taking candidates.  These are the same regardless of the input.\n-   2) pointer-pair taking candidates.  These are generated for each type\n-      one of the input types converts to.\n-   3) arithmetic candidates.  According to the WP, we should generate\n-      all of these, but I'm trying not to... */\n-\n-static struct z_candidate *\n-add_builtin_candidates (candidates, code, code2, fnname, args, flags)\n-     struct z_candidate *candidates;\n-     enum tree_code code, code2;\n-     tree fnname, *args;\n-     int flags;\n-{\n-  int ref1, i;\n-  tree type, argtypes[3], types[2];\n-\n-  for (i = 0; i < 3; ++i)\n-    {\n-      if (args[i])\n-\targtypes[i]  = cp_build_type_variant\n-\t  (TREE_TYPE (args[i]), TREE_READONLY (args[i]),\n-\t   TREE_THIS_VOLATILE (args[i]));\n-      else\n-\targtypes[i] = NULL_TREE;\n-    }\n-\n-  switch (code)\n-    {\n-/* 4 For every pair T, VQ), where T is an arithmetic or  enumeration  type,\n-     and  VQ  is  either  volatile or empty, there exist candidate operator\n-     functions of the form\n-\t\t VQ T&   operator++(VQ T&);  */\n-\n-    case POSTINCREMENT_EXPR:\n-    case PREINCREMENT_EXPR:\n-    case POSTDECREMENT_EXPR:\n-    case PREDECREMENT_EXPR:\n-    case MODIFY_EXPR:\n-      ref1 = 1;\n-      break;\n-\n-/* 24There also exist candidate operator functions of the form\n-\t     bool    operator!(bool);\n-\t     bool    operator&&(bool, bool);\n-\t     bool    operator||(bool, bool);  */\n-\n-    case TRUTH_NOT_EXPR:\n-      return build_builtin_candidate\n-\t(candidates, fnname, boolean_type_node,\n-\t NULL_TREE, args, argtypes, flags);\n-\n-    case TRUTH_ORIF_EXPR:\n-    case TRUTH_ANDIF_EXPR:\n-      return build_builtin_candidate\n-\t(candidates, fnname, boolean_type_node,\n-\t boolean_type_node, args, argtypes, flags);\n-\n-    case ADDR_EXPR:\n-    case COMPOUND_EXPR:\n-    case COMPONENT_REF:\n-      return candidates;\n-\n-    default:\n-      ref1 = 0;\n-    }\n-\n-  types[0] = types[1] = NULL_TREE;\n-\n-  for (i = 0; i < 2; ++i)\n-    {\n-      if (! args[i])\n-\t;\n-      else if (IS_AGGR_TYPE (argtypes[i]))\n-\t{\n-\t  tree convs = lookup_conversions (argtypes[i]);\n-\n-\t  if (code == COND_EXPR)\n-\t    {\n-\t      if (real_lvalue_p (args[i]))\n-\t\ttypes[i] = tree_cons\n-\t\t  (NULL_TREE, build_reference_type (argtypes[i]), types[i]);\n-\n-\t      types[i] = tree_cons\n-\t\t(NULL_TREE, TYPE_MAIN_VARIANT (argtypes[i]), types[i]);\n-\t    }\n-\t\t\n-\t  else if (! convs || (i == 0 && code == MODIFY_EXPR))\n-\t    return candidates;\n-\n-\t  for (; convs; convs = TREE_CHAIN (convs))\n-\t    {\n-\t      type = TREE_TYPE (TREE_TYPE (TREE_VALUE (convs)));\n-\n-\t      if (i == 0 && ref1\n-\t\t  && (TREE_CODE (type) != REFERENCE_TYPE\n-\t\t      || TYPE_READONLY (TREE_TYPE (type))))\n-\t\tcontinue;\n-\n-\t      if (code == COND_EXPR && TREE_CODE (type) == REFERENCE_TYPE)\n-\t\ttypes[i] = tree_cons (NULL_TREE, type, types[i]);\n-\n-\t      type = non_reference (type);\n-\t      if (i != 0 || ! ref1)\n-\t\t{\n-\t\t  type = type_decays_to (TYPE_MAIN_VARIANT (type));\n-\t\t  if (code == COND_EXPR && TREE_CODE (type) == ENUMERAL_TYPE)\n-\t\t    types[i] = tree_cons (NULL_TREE, type, types[i]);\n-\t\t  type = type_promotes_to (type);\n-\t\t}\n-\n-\t      if (! value_member (type, types[i]))\n-\t\ttypes[i] = tree_cons (NULL_TREE, type, types[i]);\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  if (code == COND_EXPR && real_lvalue_p (args[i]))\n-\t    types[i] = tree_cons\n-\t      (NULL_TREE, build_reference_type (argtypes[i]), types[i]);\n-\t  type = non_reference (argtypes[i]);\n-\t  if (i != 0 || ! ref1)\n-\t    {\n-\t      type = type_decays_to (TYPE_MAIN_VARIANT (type));\n-\t      if (code == COND_EXPR && TREE_CODE (type) == ENUMERAL_TYPE)\n-\t\ttypes[i] = tree_cons (NULL_TREE, type, types[i]);\n-\t      type = type_promotes_to (type);\n-\t    }\n-\t  types[i] = tree_cons (NULL_TREE, type, types[i]);\n-\t}\n-    }\n-\n-  for (; types[0]; types[0] = TREE_CHAIN (types[0]))\n-    {\n-      if (types[1])\n-\tfor (type = types[1]; type; type = TREE_CHAIN (type))\n-\t  candidates = add_builtin_candidate\n-\t    (candidates, code, code2, fnname, TREE_VALUE (types[0]),\n-\t     TREE_VALUE (type), args, argtypes, flags);\n-      else\n-\tcandidates = add_builtin_candidate\n-\t  (candidates, code, code2, fnname, TREE_VALUE (types[0]),\n-\t   NULL_TREE, args, argtypes, flags);\n-    }\n-\n-  return candidates;\n-}\n-\n-static struct z_candidate *\n-add_template_candidate (candidates, tmpl, arglist, flags)\n-     struct z_candidate *candidates;\n-     tree tmpl, arglist;\n-     int flags;\n-{\n-  int ntparms = TREE_VEC_LENGTH (DECL_TEMPLATE_PARMS (tmpl));\n-  tree *targs = (tree *) alloca (sizeof (tree) * ntparms);\n-  struct z_candidate *cand;\n-  int i, dummy; \n-  tree fn;\n-\n-  i = type_unification (DECL_TEMPLATE_PARMS (tmpl), targs,\n-\t\t\tTYPE_ARG_TYPES (TREE_TYPE (tmpl)),\n-\t\t\targlist, &dummy, 0, 0);\n-  if (i != 0)\n-    return candidates;\n-\n-  fn = instantiate_template (tmpl, targs);\n-  if (fn == error_mark_node)\n-    return candidates;\n-\n-  cand = add_function_candidate (candidates, fn, arglist, flags);\n-  cand->template = DECL_TEMPLATE_INFO (fn);\n-  return cand;\n-}\n-\n-static int\n-any_viable (cands)\n-     struct z_candidate *cands;\n-{\n-  for (; cands; cands = cands->next)\n-    if (cands->viable)\n-      return 1;\n-  return 0;\n-}\n-\n-static struct z_candidate *\n-splice_viable (cands)\n-     struct z_candidate *cands;\n-{\n-  struct z_candidate **p = &cands;\n-\n-  for (; *p; )\n-    {\n-      if ((*p)->viable)\n-\tp = &((*p)->next);\n-      else\n-\t*p = (*p)->next;\n-    }\n-\n-  return cands;\n-}\n-\n-tree\n-build_this (obj)\n-     tree obj;\n-{\n-  /* Fix this to work on non-lvalues.  */\n-  return build_unary_op (ADDR_EXPR, obj, 0);\n-}\n-\n-static void\n-print_z_candidates (candidates)\n-     struct z_candidate *candidates;\n-{\n-  if (! candidates)\n-    return;\n-\n-  if (TREE_CODE (candidates->fn) == IDENTIFIER_NODE)\n-    {\n-      if (candidates->fn == ansi_opname [COND_EXPR])\n-\tcp_error (\"candidates are: %D(%T, %T, %T) <builtin>\", candidates->fn,\n-\t\t  TREE_TYPE (TREE_VEC_ELT (candidates->convs, 0)),\n-\t\t  TREE_TYPE (TREE_VEC_ELT (candidates->convs, 1)),\n-\t\t  TREE_TYPE (TREE_VEC_ELT (candidates->convs, 2)));\n-      else if (TREE_VEC_LENGTH (candidates->convs) == 2)\n-\tcp_error (\"candidates are: %D(%T, %T) <builtin>\", candidates->fn,\n-\t\t  TREE_TYPE (TREE_VEC_ELT (candidates->convs, 0)),\n-\t\t  TREE_TYPE (TREE_VEC_ELT (candidates->convs, 1)));\n-      else\n-\tcp_error (\"candidates are: %D(%T) <builtin>\", candidates->fn,\n-\t\t  TREE_TYPE (TREE_VEC_ELT (candidates->convs, 0)));\n-    }\n-  else\n-    cp_error_at (\"candidates are: %D\", candidates->fn);\n-  candidates = candidates->next;\n-\n-  for (; candidates; candidates = candidates->next)\n-    {\n-      if (TREE_CODE (candidates->fn) == IDENTIFIER_NODE)\n-\t{\n-\t  if (candidates->fn == ansi_opname [COND_EXPR])\n-\t    cp_error (\"                %D(%T, %T, %T) <builtin>\",\n-\t\t      candidates->fn,\n-\t\t      TREE_TYPE (TREE_VEC_ELT (candidates->convs, 0)),\n-\t\t      TREE_TYPE (TREE_VEC_ELT (candidates->convs, 1)),\n-\t\t      TREE_TYPE (TREE_VEC_ELT (candidates->convs, 2)));\n-\t  else if (TREE_VEC_LENGTH (candidates->convs) == 2)\n-\t    cp_error (\"                %D(%T, %T) <builtin>\", candidates->fn,\n-\t\t      TREE_TYPE (TREE_VEC_ELT (candidates->convs, 0)),\n-\t\t      TREE_TYPE (TREE_VEC_ELT (candidates->convs, 1)));\n-\t  else\n-\t    cp_error (\"                %D(%T) <builtin>\", candidates->fn,\n-\t\t      TREE_TYPE (TREE_VEC_ELT (candidates->convs, 0)));\n-\t}\n-      else\n-\tcp_error_at (\"                %D\", candidates->fn);\n-    }\n-}\n-\n-/* Returns the best overload candidate to perform the requested\n-   conversion.  */\n-\n-static struct z_candidate *\n-build_user_type_conversion_1 (totype, expr, flags)\n-     tree totype, expr;\n-     int flags;\n-{\n-  struct z_candidate *candidates, *cand;\n-  tree fromtype = TREE_TYPE (expr);\n-  tree ctors = NULL_TREE, convs = NULL_TREE, *p;\n-  tree args;\n-\n-  if (IS_AGGR_TYPE (totype))\n-    ctors = lookup_fnfields (TYPE_BINFO (totype), ctor_identifier, 0);\n-  if (IS_AGGR_TYPE (fromtype)\n-      && (! IS_AGGR_TYPE (totype) || ! DERIVED_FROM_P (totype, fromtype)))\n-    convs = lookup_conversions (fromtype);\n-\n-  candidates = 0;\n-  flags |= LOOKUP_NO_CONVERSION;\n-\n-  if (ctors)\n-    {\n-      ctors = TREE_VALUE (ctors);\n-      args = build_tree_list (NULL_TREE, expr);\n-    }\n-  for (; ctors; ctors = DECL_CHAIN (ctors))\n-    {\n-      if ((flags & LOOKUP_ONLYCONVERTING) && DECL_NONCONVERTING_P (ctors))\n-\tcontinue;\n-\n-      candidates = add_function_candidate (candidates, ctors, args, flags);\n-      candidates->second_conv = build1 (IDENTITY_CONV, totype, NULL_TREE);\n-      candidates->basetype_path = TYPE_BINFO (totype);\n-    }\n-\n-  if (convs)\n-    args = build_tree_list (NULL_TREE, build_this (expr));\n-\n-  for (; convs; convs = TREE_CHAIN (convs))\n-    {\n-      tree fn = TREE_VALUE (convs);\n-      tree ics = implicit_conversion\n-\t(totype, TREE_TYPE (TREE_TYPE (fn)), 0, LOOKUP_NO_CONVERSION);\n-      if (ics)\n-\tfor (; fn; fn = DECL_CHAIN (fn))\n-\t  {\n-\t    candidates = add_function_candidate (candidates, fn, args, flags);\n-\t    candidates->second_conv = ics;\n-\t    candidates->basetype_path = TREE_PURPOSE (convs);\n-\t  }\n-    }\n-\n-  if (! any_viable (candidates))\n-    {\n-#if 0\n-      if (flags & LOOKUP_COMPLAIN)\n-\t{\n-\t  if (candidates && ! candidates->next)\n-\t    /* say why this one won't work or try to be loose */;\n-\t  else\n-\t    cp_error (\"no viable candidates\");\n-\t}\n-#endif\n-\n-      return 0;\n-    }\n-\n-  candidates = splice_viable (candidates);\n-  cand = tourney (candidates, totype);\n-\n-  if (cand == 0)\n-    {\n-      if (flags & LOOKUP_COMPLAIN)\n-\t{\n-\t  cp_error (\"ambiguous user-defined type conversion\");\n-\t  print_z_candidates (candidates);\n-\t}\n-\n-      cand = candidates;\t/* any one will do */\n-      cand->second_conv = build1 (AMBIG_CONV, totype, expr);\n-      ICS_USER_FLAG (cand->second_conv) = 1;\n-\n-      return cand;\n-    }\n-\n-  for (p = &(cand->second_conv); TREE_CODE (*p) != IDENTITY_CONV; )\n-    p = &(TREE_OPERAND (*p, 0));\n-\n-  *p = build\n-    (USER_CONV,\n-     (DECL_CONSTRUCTOR_P (cand->fn)\n-      ? totype : non_reference (TREE_TYPE (TREE_TYPE (cand->fn)))),\n-     NULL_TREE, cand->fn, cand->convs, cand->basetype_path);\n-  ICS_USER_FLAG (cand->second_conv) = 1;\n-\n-  return cand;\n-}\n-\n-tree\n-build_user_type_conversion (totype, expr, flags)\n-     tree totype, expr, flags;\n-{\n-  struct z_candidate *cand\n-    = build_user_type_conversion_1 (totype, expr, flags);\n-\n-  if (cand)\n-    {\n-      if (TREE_CODE (cand->second_conv) == AMBIG_CONV)\n-\treturn error_mark_node;\n-      return convert_from_reference (convert_like (cand->second_conv, expr));\n-    }\n-  return NULL_TREE;\n-}\n-\n-tree\n-build_new_function_call (fn, args, obj)\n-     tree fn, args, obj;\n-{\n-  struct z_candidate *candidates = 0, *cand;\n- \n-  if (obj == NULL_TREE && TREE_CODE (fn) == TREE_LIST)\n-    {\n-      tree t = TREE_VALUE (fn);\n-\n-      for (; t; t = DECL_CHAIN (t))\n-\t{\n-\t  if (TREE_CODE (t) == TEMPLATE_DECL)\n-\t    candidates = add_template_candidate\n-\t      (candidates, t, args, LOOKUP_NORMAL);\n-\t  else\n-\t    candidates = add_function_candidate\n-\t      (candidates, t, args, LOOKUP_NORMAL);\n-\t}\n-\n-      if (! any_viable (candidates))\n-\t{\n-\t  if (candidates && ! candidates->next)\n-\t    return build_function_call (candidates->fn, args);\n-\t  else\n-\t    cp_error (\"no viable candidates\");\n-\t  return error_mark_node;\n-\t}\n-      candidates = splice_viable (candidates);\n-      cand = tourney (candidates, NULL_TREE);\n-\n-      if (cand == 0)\n-\t{\n-\t  cp_error (\"ambiguous function call\");\n-\t  print_z_candidates (candidates);\n-\t  return error_mark_node;\n-\t}\n-\n-      return build_over_call (cand->fn, cand->convs, args, LOOKUP_NORMAL);\n-    }\n-\n-  return build_function_call (fn, args);\n-}\n-\n-tree\n-build_object_call (obj, args)\n-     tree obj, args;\n-{\n-  struct z_candidate *candidates = 0, *cand;\n-  tree fns, convs, mem_args, *p;\n-  enum tree_code code2 = NOP_EXPR;\n-  tree type = TREE_TYPE (obj);\n-\n-  fns = lookup_fnfields (TYPE_BINFO (type), ansi_opname [CALL_EXPR], 0);\n-\n-  if (fns)\n-    {\n-      tree fn = TREE_VALUE (fns);\n-      mem_args = tree_cons (NULL_TREE, build_this (obj), args);\n-\n-      for (; fn; fn = DECL_CHAIN (fn))\n-\t{\n-\t  candidates = add_function_candidate\n-\t    (candidates, fn, mem_args, LOOKUP_NORMAL);\n-\t  candidates->basetype_path = TREE_PURPOSE (fns);\n-\t}\n-    }\n-\n-  convs = lookup_conversions (type);\n-\n-  for (; convs; convs = TREE_CHAIN (convs))\n-    {\n-      tree fn = TREE_VALUE (convs);\n-      tree totype = TREE_TYPE (TREE_TYPE (fn));\n-\n-      if (TREE_CODE (totype) == POINTER_TYPE\n-\t  && TREE_CODE (TREE_TYPE (totype)) == FUNCTION_TYPE)\n-\t{\n-\t  candidates = add_conv_candidate (candidates, fn, obj, args);\n-\t  candidates->basetype_path = TREE_PURPOSE (convs);\n-\t}\n-    }\n-\n-  if (! any_viable (candidates))\n-    {\n-      cp_error (\"no viable candidates\");\n-      print_z_candidates (candidates);\n-      return error_mark_node;\n-    }\n-\n-  candidates = splice_viable (candidates);\n-  cand = tourney (candidates, NULL_TREE);\n-\n-  if (cand == 0)\n-    {\n-      cp_error (\"ambiguous object call\");\n-      print_z_candidates (candidates);\n-      return error_mark_node;\n-    }\n-\n-  if (DECL_NAME (cand->fn) == ansi_opname [CALL_EXPR])\n-    return build_over_call (cand->fn, cand->convs, mem_args, LOOKUP_NORMAL);\n-\n-  obj = convert_like (TREE_VEC_ELT (cand->convs, 0), obj);\n-\n-  /* FIXME */\n-  return build_function_call (obj, args);\n-}\n-\n-static void\n-op_error (code, code2, arg1, arg2, arg3, problem)\n-     enum tree_code code, code2;\n-     tree arg1, arg2, arg3;\n-     char *problem;\n-{\n-  char * opname\n-    = (code == MODIFY_EXPR ? assignop_tab [code2] : opname_tab [code]);\n-\n-  switch (code)\n-    {\n-    case COND_EXPR:\n-      cp_error (\"%s for `%T ? %T : %T'\", problem,\n-\t\tTREE_TYPE (arg1), TREE_TYPE (arg2), TREE_TYPE (arg3));\n-      break;\n-    case POSTINCREMENT_EXPR:\n-    case POSTDECREMENT_EXPR:\n-      cp_error (\"%s for `%T%s'\", problem, TREE_TYPE (arg1), opname);\n-      break;\n-    case ARRAY_REF:\n-      cp_error (\"%s for `%T[%T]'\", problem,\n-\t\tTREE_TYPE (arg1), TREE_TYPE (arg2));\n-      break;\n-    default:\n-      if (arg2)\n-\tcp_error (\"%s for `%T %s %T'\", problem,\n-\t\t  TREE_TYPE (arg1), opname, TREE_TYPE (arg2));\n-      else\n-\tcp_error (\"%s for `%s%T'\", problem, opname, TREE_TYPE (arg1));\n-    }\n-}\n-\n-tree\n-build_new_op (code, flags, arg1, arg2, arg3)\n-     enum tree_code code;\n-     int flags;\n-     tree arg1, arg2, arg3;\n-{\n-  struct z_candidate *candidates = 0, *cand;\n-  tree fns, mem_arglist, arglist, fnname, *p;\n-  enum tree_code code2 = NOP_EXPR;\n-\n-  if (arg1 == error_mark_node)\n-    return error_mark_node;\n-\n-  if (code == MODIFY_EXPR)\n-    {\n-      code2 = TREE_CODE (arg3);\n-      arg3 = NULL_TREE;\n-      fnname = ansi_assopname[code2];\n-    }\n-  else\n-    fnname = ansi_opname[code];\n-\n-  switch (code)\n-    {\n-    case NEW_EXPR:\n-    case VEC_NEW_EXPR:\n-      {\n-\ttree rval;\n-\n-\targlist = tree_cons (NULL_TREE, arg2, arg3);\n-\tif (flags & LOOKUP_GLOBAL)\n-\t  return build_new_function_call\n-\t    (lookup_name_nonclass (fnname), arglist, NULL_TREE);\n-\n-\t/* FIXME */\n-\trval = build_method_call\n-\t  (build_indirect_ref (build1 (NOP_EXPR, arg1, error_mark_node),\n-\t\t\t       \"new\"),\n-\t   fnname, arglist, NULL_TREE, flags);\n-\tif (rval == error_mark_node)\n-\t  /* User might declare fancy operator new, but invoke it\n-\t     like standard one.  */\n-\t  return rval;\n-\n-\tTREE_TYPE (rval) = arg1;\n-\tTREE_CALLS_NEW (rval) = 1;\n-\treturn rval;\n-      }\n-\n-    case VEC_DELETE_EXPR:\n-    case DELETE_EXPR:\n-      {\n-\ttree rval;\n-\n-\tif (flags & LOOKUP_GLOBAL)\n-\t  return build_new_function_call\n-\t    (lookup_name_nonclass (fnname),\n-\t     build_tree_list (NULL_TREE, arg1), NULL_TREE);\n-\n-\targlist = tree_cons (NULL_TREE, arg1, build_tree_list (NULL_TREE, arg2));\n-\n-\targ1 = TREE_TYPE (arg1);\n-\n-\t/* This handles the case where we're trying to delete\n-\t   X (*a)[10];\n-\t   a=new X[5][10];\n-\t   delete[] a; */\n-\t   \n-\tif (TREE_CODE (TREE_TYPE (arg1)) == ARRAY_TYPE)\n-\t  {\n-\t    /* Strip off the pointer and the array.  */\n-\t    arg1 = TREE_TYPE (TREE_TYPE (arg1));\n-\n-\t    while (TREE_CODE (arg1) == ARRAY_TYPE)\n-\t\targ1 = (TREE_TYPE (arg1));\n-\n-\t    arg1 = build_pointer_type (arg1);\n-\t  }\n-\n-\t/* FIXME */\n-\trval = build_method_call\n-\t  (build_indirect_ref (build1 (NOP_EXPR, arg1,\n-\t\t\t\t       error_mark_node),\n-\t\t\t       NULL_PTR),\n-\t   fnname, arglist, NULL_TREE, flags);\n-#if 0\n-\t/* This can happen when operator delete is protected.  */\n-\tmy_friendly_assert (rval != error_mark_node, 250);\n-\tTREE_TYPE (rval) = void_type_node;\n-#endif\n-\treturn rval;\n-      }\n-\n-    case CALL_EXPR:\n-      return build_object_call (arg1, arg2);\n-    }\n-\n-  /* The comma operator can have void args.  */\n-  if (TREE_CODE (arg1) == OFFSET_REF)\n-    arg1 = resolve_offset_ref (arg1);\n-  if (arg2 && TREE_CODE (arg2) == OFFSET_REF)\n-    arg2 = resolve_offset_ref (arg2);\n-  if (arg3 && TREE_CODE (arg3) == OFFSET_REF)\n-    arg3 = resolve_offset_ref (arg3);\n-\n-  if (! IS_OVERLOAD_TYPE (TREE_TYPE (arg1))\n-      && (! arg2 || ! IS_OVERLOAD_TYPE (TREE_TYPE (arg2)))\n-      && (! arg3 || ! IS_OVERLOAD_TYPE (TREE_TYPE (arg3))))\n-    return NULL_TREE;\n-\n-  if (code == POSTINCREMENT_EXPR || code == POSTDECREMENT_EXPR)\n-    arg2 = integer_zero_node;\n-\n-  fns = lookup_name_nonclass (fnname);\n-  /* + Koenig lookup */\n-\n-  if (arg2 && arg3)\n-    arglist = tree_cons (NULL_TREE, arg1, tree_cons\n-\t\t      (NULL_TREE, arg2, build_tree_list (NULL_TREE, arg3)));\n-  else if (arg2)\n-    arglist = tree_cons (NULL_TREE, arg1, build_tree_list (NULL_TREE, arg2));\n-  else\n-    arglist = build_tree_list (NULL_TREE, arg1);\n-\n-  if (fns && TREE_CODE (fns) == TREE_LIST)\n-    fns = TREE_VALUE (fns);\n-  for (; fns; fns = DECL_CHAIN (fns))\n-    {\n-      if (TREE_CODE (fns) == TEMPLATE_DECL)\n-\tcandidates = add_template_candidate (candidates, fns, arglist, flags);\n-      else\n-\tcandidates = add_function_candidate (candidates, fns, arglist, flags);\n-    }\n-\n-  if (IS_AGGR_TYPE (TREE_TYPE (arg1)))\n-    fns = lookup_fnfields (TYPE_BINFO (TREE_TYPE (arg1)), fnname, 0);\n-  else\n-    fns = NULL_TREE;\n-\n-  if (fns)\n-    {\n-      tree fn = TREE_VALUE (fns);\n-      mem_arglist = tree_cons (NULL_TREE, build_this (arg1), TREE_CHAIN (arglist));\n-      for (; fn; fn = DECL_CHAIN (fn))\n-\t{\n-\t  if (TREE_CODE (TREE_TYPE (fn)) == METHOD_TYPE)\n-\t    candidates = add_function_candidate\n-\t      (candidates, fn, mem_arglist, flags);\n-\t  else\n-\t    candidates = add_function_candidate (candidates, fn, arglist, flags);\n-\t  \n-\t  candidates->basetype_path = TREE_PURPOSE (fns);\n-\t}\n-    }\n-\n-#if 0 /* Don't handle builtin COND_EXPR for now */\n-  if (code != COND_EXPR)\n-#endif\n-    {\n-      tree args[3];\n-\n-      /* Rearrange the arguments for ?: so that add_builtin_candidate only has\n-\t to know about two args; a builtin candidate will always have a first\n-\t parameter of type bool.  We'll handle that in\n-\t build_builtin_candidate.  */\n-      if (code == COND_EXPR)\n-\t{\n-\t  args[0] = arg2;\n-\t  args[1] = arg3;\n-\t  args[2] = arg1;\n-\t}\n-      else\n-\t{\n-\t  args[0] = arg1;\n-\t  args[1] = arg2;\n-\t  args[2] = NULL_TREE;\n-\t}\n-\n-      candidates = add_builtin_candidates\n-\t(candidates, code, code2, fnname, args, flags);\n-    }\n-\n-  if (! any_viable (candidates))\n-    {\n-      switch (code)\n-\t{\n-\tcase POSTINCREMENT_EXPR:\n-\tcase POSTDECREMENT_EXPR:\n-\t  /* Look for an `operator++ (int)'.  If they didn't have\n-\t     one, then we fall back to the old way of doing things.  */\n-\t  if (flags & LOOKUP_COMPLAIN)\n-\t    cp_pedwarn (\"no `%D (int)' declared for postfix `%s', trying prefix operator instead\",\n-\t\t\tfnname, opname_tab [code]);\n-\t  if (code == POSTINCREMENT_EXPR)\n-\t    code = PREINCREMENT_EXPR;\n-\t  else\n-\t    code = PREDECREMENT_EXPR;\t\n-\t  return build_new_op (code, flags, arg1, NULL_TREE, NULL_TREE);\n-\t  \n-\t  /* FIXME */\n-\tcase ADDR_EXPR:\n-\t  /*return build_unary_op (code, arg1, 1);*/\n-\tcase COMPOUND_EXPR:\n-\t  /*return build (COMPOUND_EXPR, TREE_TYPE (arg2),\n-\t\t\tbreak_out_cleanups (arg1), arg2);*/\n-\tcase COMPONENT_REF:\n-\t  /*return build_x_arrow (arg1);*/\n-#if 0 /* Don't handle builtin COND_EXPR for now */\n-\tcase COND_EXPR:\n-#endif\n-\t  return NULL_TREE;\n-\t}\n-      if (flags & LOOKUP_COMPLAIN)\n-\t{\n-\t  op_error (code, code2, arg1, arg2, arg3, \"no match\");\n-\t  print_z_candidates (candidates);\n-\t}\n-      return error_mark_node;\n-    }\n-  candidates = splice_viable (candidates);\n-  cand = tourney (candidates, NULL_TREE);\n-\n-  if (cand == 0)\n-    {\n-      if (flags & LOOKUP_COMPLAIN)\n-\t{\n-\t  op_error (code, code2, arg1, arg2, arg3, \"ambiguous overload\");\n-\t  print_z_candidates (candidates);\n-\t}\n-      return error_mark_node;\n-    }\n-\n-  if (TREE_CODE (cand->fn) == FUNCTION_DECL)\n-    {\n-      extern int warn_synth;\n-      if (warn_synth\n-\t  && fnname == ansi_opname[MODIFY_EXPR]\n-\t  && DECL_ARTIFICIAL (cand->fn)\n-\t  && candidates->next\n-\t  && ! candidates->next->next)\n-\t{\n-\t  cp_warning (\"using synthesized `%#D' for copy assignment\",\n-\t\t      cand->fn);\n-\t  cp_warning_at (\"  where cfront would use `%#D'\",\n-\t\t\t cand == candidates\n-\t\t\t ? candidates->next->fn\n-\t\t\t : candidates->fn);\n-\t}\n-\n-      if (DECL_FUNCTION_MEMBER_P (cand->fn))\n-\tenforce_access (cand->basetype_path, cand->fn);\n-\n-      return build_over_call\n-\t(cand->fn, cand->convs,\n-\t TREE_CODE (TREE_TYPE (cand->fn)) == METHOD_TYPE\n-\t ? mem_arglist : arglist,\n-\t LOOKUP_NORMAL);\n-    }\n-\n-  arg1 = convert_from_reference\n-    (convert_like (TREE_VEC_ELT (cand->convs, 0), arg1));\n-  if (arg2)\n-    arg2 = convert_like (TREE_VEC_ELT (cand->convs, 1), arg2);\n-  if (arg3)\n-    arg3 = convert_like (TREE_VEC_ELT (cand->convs, 2), arg3);\n-\n-  switch (code)\n-    {\n-    case MODIFY_EXPR:\n-      return build_modify_expr (arg1, code2, arg2);\n-\n-    case INDIRECT_REF:\n-      return build_indirect_ref (arg1, \"unary *\");\n-\n-    case PLUS_EXPR:\n-    case MINUS_EXPR:\n-    case MULT_EXPR:\n-    case TRUNC_DIV_EXPR:\n-    case GT_EXPR:\n-    case LT_EXPR:\n-    case GE_EXPR:\n-    case LE_EXPR:\n-    case EQ_EXPR:\n-    case NE_EXPR:\n-    case MAX_EXPR:\n-    case MIN_EXPR:\n-    case LSHIFT_EXPR:\n-    case RSHIFT_EXPR:\n-    case TRUNC_MOD_EXPR:\n-    case BIT_AND_EXPR:\n-    case BIT_IOR_EXPR:\n-    case BIT_XOR_EXPR:\n-    case TRUTH_ANDIF_EXPR:\n-    case TRUTH_ORIF_EXPR:\n-      return build_binary_op_nodefault (code, arg1, arg2, code);\n-\n-    case CONVERT_EXPR:\n-    case NEGATE_EXPR:\n-    case BIT_NOT_EXPR:\n-    case TRUTH_NOT_EXPR:\n-    case PREINCREMENT_EXPR:\n-    case POSTINCREMENT_EXPR:\n-    case PREDECREMENT_EXPR:\n-    case POSTDECREMENT_EXPR:\n-      return build_unary_op (code, arg1, 1);\n-\n-    case ARRAY_REF:\n-      return build_array_ref (arg1, arg2);\n-\n-    case COND_EXPR:\n-      return build_conditional_expr (arg1, arg2, arg3);\n-\n-    default:\n-      my_friendly_abort (367);\n-    }\n-}\n-\n-void\n-enforce_access (basetype_path, function)\n-     tree basetype_path, function;\n-{\n-  tree access = compute_access (basetype_path, function);\n-\n-  if (access == access_private_node)\n-    {\n-      cp_error_at (\"`%+#D' is %s\", function, \n-\t\t   TREE_PRIVATE (function) ? \"private\"\n-\t\t   : \"from private base class\");\n-      error (\"within this context\");\n-    }\n-  else if (access == access_protected_node)\n-    {\n-      cp_error_at (\"`%+#D' %s\", function,\n-\t\t   TREE_PROTECTED (function) ? \"is protected\"\n-\t\t   : \"has protected accessibility\");\n-      error (\"within this context\");\n-    }\n-}\n-\n-/* Perform the conversions in CONVS on the expression EXPR.  */\n-\n-static tree\n-convert_like (convs, expr)\n-     tree convs, expr;\n-{\n-  switch (TREE_CODE (convs))\n-    {\n-    case USER_CONV:\n-      {\n-\ttree fn = TREE_OPERAND (convs, 1);\n-\tenforce_access (TREE_OPERAND (convs, 3), fn);\n-\texpr = build_over_call\n-\t  (TREE_OPERAND (convs, 1), TREE_OPERAND (convs, 2),\n-\t   DECL_CONSTRUCTOR_P (fn) ? expr : build_this (expr), LOOKUP_NORMAL);\n-\n-\t/* If this is a constructor or a function returning an aggr type,\n-\t   we need to build up a TARGET_EXPR.  */\n-\tif (DECL_CONSTRUCTOR_P (fn)\n-\t    || IS_AGGR_TYPE (TREE_TYPE (TREE_TYPE (fn))))\n-\t  expr = build_cplus_new (TREE_TYPE (convs), expr);\n-\n-\treturn expr;\n-      }\n-    case IDENTITY_CONV:\n-      if (type_unknown_p (expr))\n-\texpr = instantiate_type (TREE_TYPE (convs), expr, 1);\n-      return expr;\n-    case AMBIG_CONV:\n-      /* Call build_user_type_conversion again for the error.  */\n-      return build_user_type_conversion\n-\t(TREE_TYPE (convs), TREE_OPERAND (convs, 0), LOOKUP_NORMAL);\n-    };\n-\n-  expr = convert_like (TREE_OPERAND (convs, 0), expr);\n-  if (expr == error_mark_node)\n-    return error_mark_node;\n-\n-  switch (TREE_CODE (convs))\n-    {\n-    case BASE_CONV:\n-    case RVALUE_CONV:\n-      return build_user_type_conversion\n-\t(TREE_TYPE (convs), expr, LOOKUP_NORMAL);\n-    case REF_BIND:\n-      return convert_to_reference\n-\t(TREE_TYPE (convs), expr,\n-\t CONV_IMPLICIT, LOOKUP_NORMAL|LOOKUP_NO_CONVERSION|INDIRECT_BIND,\n-\t error_mark_node);\n-    case LVALUE_CONV:\n-      return decay_conversion (expr);\n-    }\n-  return cp_convert (TREE_TYPE (convs), expr, CONV_IMPLICIT,\n-\t\t     LOOKUP_NORMAL|LOOKUP_NO_CONVERSION);\n-}\n-\n-static tree\n-convert_default_arg (type, arg)\n-     tree type, arg;\n-{\n-  arg = break_out_target_exprs (arg);\n-\n-  if (TREE_CODE (arg) == CONSTRUCTOR)\n-    {\n-      arg = digest_init (type, arg, 0);\n-      arg = convert_for_initialization (0, type, arg, LOOKUP_NORMAL,\n-\t\t\t\t\t\"default argument\", 0, 0);\n-    }\n-  else\n-    {\n-      /* This could get clobbered by the following call.  */\n-      if (TREE_HAS_CONSTRUCTOR (arg))\n-\targ = copy_node (arg);\n-\n-      arg = convert_for_initialization (0, type, arg, LOOKUP_NORMAL,\n-\t\t\t\t\t\"default argument\", 0, 0);\n-#ifdef PROMOTE_PROTOTYPES\n-      if ((TREE_CODE (type) == INTEGER_TYPE\n-\t   || TREE_CODE (type) == ENUMERAL_TYPE)\n-\t  && (TYPE_PRECISION (type) < TYPE_PRECISION (integer_type_node)))\n-\targ = default_conversion (arg);\n-#endif\n-    }\n-\n-  return arg;\n-}\n-\n-static tree\n-build_over_call (fn, convs, args, flags)\n-     tree fn, convs, args;\n-     int flags;\n-{\n-  tree converted_args = NULL_TREE;\n-  tree parm = TYPE_ARG_TYPES (TREE_TYPE (fn));\n-  tree conv, arg, val;\n-  int i = 0;\n-\n-  if (args && TREE_CODE (args) != TREE_LIST)\n-    args = build_tree_list (NULL_TREE, args);\n-  arg = args;\n-\n-  if (DECL_CONSTRUCTOR_P (fn))\n-    {\n-      tree t = build_int_2 (0, 0);\n-      TREE_TYPE (t) = build_pointer_type (DECL_CONTEXT (fn));\n-      converted_args = tree_cons (NULL_TREE, t, converted_args);\n-      parm = TREE_CHAIN (parm);\n-\n-      if (TYPE_USES_VIRTUAL_BASECLASSES (DECL_CONTEXT (fn)))\n-\t{\n-\t  converted_args = tree_cons\n-\t    (NULL_TREE, integer_one_node, converted_args);\n-\t  parm = TREE_CHAIN (parm);\n-\t}\n-    }\n-  /* Bypass access control for 'this' parameter.  */\n-  else if (TREE_CODE (TREE_TYPE (fn)) == METHOD_TYPE)\n-    {\n-      converted_args = tree_cons\n-\t(NULL_TREE, convert_force (TREE_VALUE (parm), TREE_VALUE (arg), CONV_C_CAST),\n-\t converted_args);\n-      parm = TREE_CHAIN (parm);\n-      arg = TREE_CHAIN (arg);\n-      ++i;\n-    }\n-\n-  for (; conv = TREE_VEC_ELT (convs, i), arg && parm;\n-       parm = TREE_CHAIN (parm), arg = TREE_CHAIN (arg), ++i)\n-    {\n-      tree type = TREE_VALUE (parm);\n-      val = convert_like (conv, TREE_VALUE (arg));\n-\n-#ifdef PROMOTE_PROTOTYPES\n-      if ((TREE_CODE (type) == INTEGER_TYPE\n-\t   || TREE_CODE (type) == ENUMERAL_TYPE)\n-\t  && (TYPE_PRECISION (type) < TYPE_PRECISION (integer_type_node)))\n-\tval = default_conversion (val);\n-#endif\n-      converted_args = tree_cons (NULL_TREE, val, converted_args);\n-    }\n-\n-  /* Default arguments */\n-  for (; parm && parm != void_list_node; parm = TREE_CHAIN (parm))\n-    converted_args = tree_cons\n-      (NULL_TREE,\n-       convert_default_arg (TREE_VALUE (parm), TREE_PURPOSE (parm)),\n-       converted_args);\n-\n-  /* Ellipsis */\n-  for (; arg; arg = TREE_CHAIN (arg))\n-    {\n-      val = TREE_VALUE (arg);\n-\n-      if (TREE_CODE (TREE_TYPE (val)) == REAL_TYPE\n-\t  && (TYPE_PRECISION (TREE_TYPE (val))\n-\t      < TYPE_PRECISION (double_type_node)))\n-\t/* Convert `float' to `double'.  */\n-\tval = convert (double_type_node, val);\n-      else if (TYPE_LANG_SPECIFIC (TREE_TYPE (val))\n-\t       && ! TYPE_HAS_TRIVIAL_INIT_REF (TREE_TYPE (val)))\n-\tcp_warning (\"cannot pass objects of type `%T' through `...'\",\n-\t\t    TREE_TYPE (val));\n-      else\n-\t/* Convert `short' and `char' to full-size `int'.  */\n-\tval = default_conversion (val);\n-\n-      converted_args = tree_cons (NULL_TREE, val, converted_args);\n-    }\n-\n-  converted_args = nreverse (converted_args);\n-\n-  mark_used (fn);\n-  /* Is it a synthesized method that needs to be synthesized?  */\n-  if (DECL_ARTIFICIAL (fn) && ! DECL_INITIAL (fn)\n-      /* Kludge: don't synthesize for default args.  */\n-      && current_function_decl)\n-    synthesize_method (fn);\n-\n-  if (DECL_VINDEX (fn) && (flags & LOOKUP_NONVIRTUAL) == 0)\n-    {\n-      tree t = build_pointer_type (TREE_TYPE (fn));\n-      fn = build_vfn_ref (&TREE_VALUE (converted_args),\n-\t\t\t  build_indirect_ref (TREE_VALUE (args), 0),\n-\t\t\t  DECL_VINDEX (fn));\n-      TREE_TYPE (fn) = t;\n-    }\n-  else if (DECL_INLINE (fn))\n-    fn = inline_conversion (fn);\n-  else\n-    fn = build_addr_func (fn);\n-\n-  fn = build_call (fn, TREE_TYPE (TREE_TYPE (TREE_TYPE (fn))), converted_args);\n-  if (TREE_TYPE (fn) == void_type_node)\n-    return fn;\n-  return convert_from_reference (require_complete_type (fn));\n-}\n-\n-/* Compare two implicit conversion sequences that differ only in their\n-   qualification conversion.  Subroutine of compare_ics.  */\n-\n-static int\n-compare_qual (ics1, ics2)\n-     tree ics1, ics2;\n-{\n-  tree to1 = TREE_TYPE (ics1);\n-  tree to2 = TREE_TYPE (ics2);\n-\n-  to1 = TREE_TYPE (to1);\n-  to2 = TREE_TYPE (to2);\n-\n-  if (TREE_CODE (to1) == OFFSET_TYPE)\n-    {\n-      to1 = TREE_TYPE (to1);\n-      to2 = TREE_TYPE (to2);\n-    }\n-\n-  if (TYPE_READONLY (to1) >= TYPE_READONLY (to2)\n-      && TYPE_VOLATILE (to1) > TYPE_VOLATILE (to2))\n-    return -1;\n-  else if (TYPE_READONLY (to1) > TYPE_READONLY (to2)\n-\t   && TYPE_VOLATILE (to1) == TYPE_VOLATILE (to2))\n-    return -1;\n-  else if (TYPE_READONLY (to1) <= TYPE_READONLY (to2)\n-\t   && TYPE_VOLATILE (to1) < TYPE_VOLATILE (to2))\n-    return 1;\n-  else if (TYPE_READONLY (to1) < TYPE_READONLY (to2)\n-\t   && TYPE_VOLATILE (to1) == TYPE_VOLATILE (to2))\n-    return 1;\n-  return 0;\n-}\n-\n-/* Compare two implicit conversion sequences according to the rules set out in\n-   [over.ics.rank].  Return values:\n-\n-      1: ics1 is better than ics2\n-     -1: ics2 is better than ics1\n-      0: ics1 and ics2 are indistinguishable */\n-\n-static int\n-compare_ics (ics1, ics2)\n-     tree ics1, ics2;\n-{\n-  tree main1, main2;\n-\n-  if (ICS_RANK (ics1) > ICS_RANK (ics2))\n-    return -1;\n-  else if (ICS_RANK (ics1) < ICS_RANK (ics2))\n-    return 1;\n-\n-  /* User-defined  conversion sequence U1 is a better conversion sequence\n-     than another user-defined conversion sequence U2 if they contain the\n-     same user-defined conversion operator or constructor and if the sec-\n-     ond standard conversion sequence of U1 is  better  than  the  second\n-     standard conversion sequence of U2.  */\n-\n-  if (ICS_RANK (ics1) == USER_RANK)\n-    {\n-      tree t1, t2;\n-\n-      for (t1 = ics1; TREE_CODE (t1) != USER_CONV; t1 = TREE_OPERAND (t1, 0))\n-\tif (TREE_CODE (t1) == AMBIG_CONV)\n-\t  return 0;\n-      for (t2 = ics2; TREE_CODE (t2) != USER_CONV; t2 = TREE_OPERAND (t2, 0))\n-\tif (TREE_CODE (t2) == AMBIG_CONV)\n-\t  return 0;\n-\n-      if (USER_CONV_FN (t1) != USER_CONV_FN (t2))\n-\treturn 0;\n-      else if (ICS_STD_RANK (ics1) > ICS_STD_RANK (ics2))\n-\treturn -1;\n-      else if (ICS_STD_RANK (ics1) < ICS_STD_RANK (ics2))\n-\treturn 1;\n-\n-      /* else fall through */\n-    }\n-\n-#if 0 /* Handled by ranking */\n-  /* A conversion that is not a conversion of a pointer,  or  pointer  to\n-     member,  to  bool  is  better than another conversion that is such a\n-     conversion.  */\n-#endif\n-\n-  if (TREE_CODE (ics1) == QUAL_CONV)\n-    main1 = TREE_OPERAND (ics1, 0);\n-  else\n-    main1 = ics1;\n-\n-  if (TREE_CODE (ics2) == QUAL_CONV)\n-    main2 = TREE_OPERAND (ics2, 0);\n-  else\n-    main2 = ics2;\n-\n-  if (TREE_CODE (main1) != TREE_CODE (main2))\n-    return 0;\n-\n-  if (TREE_CODE (main1) == IDENTITY_CONV\n-      && (TREE_CODE (TREE_TYPE (main1)) == POINTER_TYPE\n-\t  || TYPE_PTRMEMFUNC_P (TREE_TYPE (main1))))\n-    {\n-      if (TREE_TYPE (main1) == TREE_TYPE (main2))\n-\treturn compare_qual (ics1, ics2);\n-\n-#if 0 /* This is now handled by making identity better than anything else.  */\n-      /* existing practice, not WP-endorsed: const char * -> const char *\n-\t is better than char * -> const char *.  (jason 6/29/96) */\n-      if (TREE_TYPE (ics1) == TREE_TYPE (ics2))\n-\treturn -compare_qual (main1, main2);\n-#endif\n-    }\n-\n-  if (TREE_CODE (main1) == PTR_CONV || TREE_CODE (main1) == PMEM_CONV\n-      || TREE_CODE (main1) == REF_BIND || TREE_CODE (main1) == BASE_CONV)\n-    {\n-      tree to1 = TREE_TYPE (main1);\n-      tree from1 = TREE_TYPE (TREE_OPERAND (main1, 0));\n-      tree to2 = TREE_TYPE (main2);\n-      tree from2 = TREE_TYPE (TREE_OPERAND (main2, 0));\n-      int distf, distt;\n-\n-      /* Standard conversion sequence S1 is a better conversion sequence than\n-\t standard conversion sequence S2 if...\n-\n-\t S1 and S2 differ only in their qualification conversion  and  they\n-\t yield types identical except for cv-qualifiers and S2 adds all the\n-\t qualifiers that S1 adds (and in the same places) and S2  adds  yet\n-\t more  cv-qualifiers  than  S1,  or the similar case with reference\n-\t binding15).  */\n-      if (TREE_CODE (main1) == REF_BIND)\n-\t{\n-\t  if (TYPE_MAIN_VARIANT (TREE_TYPE (to1))\n-\t      == TYPE_MAIN_VARIANT (TREE_TYPE (to2)))\n-\t    return compare_qual (ics1, ics2);\n-\t}\n-      else if (TREE_CODE (main1) != BASE_CONV && from1 == from2 && to1 == to2)\n-\treturn compare_qual (ics1, ics2);\n-\t\n-      if (TYPE_PTRMEMFUNC_P (to1))\n-\t{\n-\t  to1 = TYPE_METHOD_BASETYPE (TYPE_PTRMEMFUNC_FN_TYPE (to1));\n-\t  from1 = TYPE_METHOD_BASETYPE (TYPE_PTRMEMFUNC_FN_TYPE (from1));\n-\t}\n-      else if (TREE_CODE (main1) != BASE_CONV)\n-\t{\n-\t  to1 = TREE_TYPE (to1);\n-\t  if (TREE_CODE (main1) != REF_BIND)\n-\t    from1 = TREE_TYPE (from1);\n-\n-\t  if (TREE_CODE (to1) == OFFSET_TYPE)\n-\t    {\n-\t      to1 = TYPE_OFFSET_BASETYPE (to1);\n-\t      from1 = TYPE_OFFSET_BASETYPE (from1);\n-\t    }\n-\t}\n-\n-      if (TYPE_PTRMEMFUNC_P (to2))\n-\t{\n-\t  to2 = TYPE_METHOD_BASETYPE (TYPE_PTRMEMFUNC_FN_TYPE (to2));\n-\t  from2 = TYPE_METHOD_BASETYPE (TYPE_PTRMEMFUNC_FN_TYPE (from2));\n-\t}\n-      else if (TREE_CODE (main1) != BASE_CONV)\n-\t{\n-\t  to2 = TREE_TYPE (to2);\n-\t  if (TREE_CODE (main1) != REF_BIND)\n-\t    from2 = TREE_TYPE (from2);\n-\n-\t  if (TREE_CODE (to2) == OFFSET_TYPE)\n-\t    {\n-\t      to2 = TYPE_OFFSET_BASETYPE (to2);\n-\t      from2 = TYPE_OFFSET_BASETYPE (from2);\n-\t    }\n-\t}\n-\n-      if (! (IS_AGGR_TYPE (from1) && IS_AGGR_TYPE (from2)))\n-\treturn 0;\n-\n-      /* The sense of pmem conversions is reversed from that of the other\n-\t conversions.  */\n-      if (TREE_CODE (main1) == PMEM_CONV)\n-\t{\n-\t  tree t = from1; from1 = from2; from2 = t;\n-\t  t = to1; to1 = to2; to2 = t;\n-\t}\n-\n-      distf = get_base_distance (from1, from2, 0, 0);\n-      if (distf == -1)\n-\t{\n-\t  distf = -get_base_distance (from2, from1, 0, 0);\n-\t  if (distf == 1)\n-\t    return 0;\n-\t}\n-\n-      /* If class B is derived directly or indirectly from class A,\n-\t conver- sion of B* to A* is better than conversion of B* to\n-\t void*, and conversion of A* to void* is better than\n-\t conversion of B* to void*.  */\n-\n-      if (TREE_CODE (to1) == VOID_TYPE && TREE_CODE (to2) == VOID_TYPE)\n-\t{\n-\t  if (distf > 0)\n-\t    return 1;\n-\t  else if (distf < 0)\n-\t    return -1;\n-\t}\n-      else if (TREE_CODE (to2) == VOID_TYPE && IS_AGGR_TYPE (to1)\n-\t       && get_base_distance (to1, from1, 0, 0) != -1)\n-\treturn 1;\n-      else if (TREE_CODE (to1) == VOID_TYPE && IS_AGGR_TYPE (to2)\n-\t       && get_base_distance (to2, from2, 0, 0) != -1)\n-\treturn -1;\n-\n-      if (! (IS_AGGR_TYPE (to1) && IS_AGGR_TYPE (to2)))\n-\treturn 0;\n-\n-      /* If  class B is derived directly or indirectly from class A and class\n-\t C is derived directly or indirectly from B */\n-\n-      distt = get_base_distance (to1, to2, 0, 0);\n-      if (distt == -1)\n-\t{\n-\t  distt = -get_base_distance (to2, to1, 0, 0);\n-\t  if (distt == 1)\n-\t    return 0;\n-\t}\n-\n-      /* --conversion of C* to B* is better than conversion of C* to A*, */\n-      if (distf == 0)\n-\t{\n-\t  if (distt > 0)\n-\t    return -1;\n-\t  else if (distt < 0)\n-\t    return 1;\n-\t}\n-      /* --conversion of B* to A* is better than conversion of C* to A*, */\n-      else if (distt == 0)\n-\t{\n-\t  if (distf > 0)\n-\t    return 1;\n-\t  else if (distf < 0)\n-\t    return -1;\n-\t}\n-    }\n-  return 0;\n-}\n-\n-/* Compare two candidates for overloading as described in\n-   [over.match.best].  Return values:\n-\n-      1: cand1 is better than cand2\n-     -1: cand2 is better than cand1\n-      0: cand1 and cand2 are indistinguishable */\n-\n-static int\n-joust (cand1, cand2)\n-     struct z_candidate *cand1, *cand2;\n-{\n-  int winner = 0;\n-  int i;\n-\n-  /* a viable function F1\n-     is defined to be a better function than another viable function F2  if\n-     for  all arguments i, ICSi(F1) is not a worse conversion sequence than\n-     ICSi(F2), and then */\n-\n-  /* for some argument j, ICSj(F1) is a better conversion  sequence  than\n-     ICSj(F2) */\n-\n-  for (i = 0; i < TREE_VEC_LENGTH (cand1->convs); ++i)\n-    {\n-      int comp = compare_ics (TREE_VEC_ELT (cand1->convs, i),\n-\t\t\t      TREE_VEC_ELT (cand2->convs, i));\n-\n-      if (comp != 0)\n-\t{\n-\t  if (winner && comp != winner)\n-\t    return 0;\n-\t  winner = comp;\n-\t}\n-    }\n-\n-  if (winner)\n-    return winner;\n-\n-  /* or, if not that,\n-     F1 is a non-template function and F2 is a template function */\n-\n-  if (! cand1->template && cand2->template)\n-    return 1;\n-  else if (cand1->template && ! cand2->template)\n-    return -1;\n-  else if (cand1->template && cand2->template)\n-    winner = more_specialized\n-      (TI_TEMPLATE (cand1->template), TI_TEMPLATE (cand2->template));\n-\n-  /* or, if not that,\n-     the  context  is  an  initialization by user-defined conversion (see\n-     _dcl.init_  and  _over.match.user_)  and  the  standard   conversion\n-     sequence  from  the return type of F1 to the destination type (i.e.,\n-     the type of the entity being initialized)  is  a  better  conversion\n-     sequence  than the standard conversion sequence from the return type\n-     of F2 to the destination type.  */\n-\n-  if (! winner && cand1->second_conv)\n-    winner = compare_ics (cand1->second_conv, cand2->second_conv);\n-\n-  /* If the built-in candidates are the same, arbitrarily pick one.  */\n-  if (! winner && cand1->fn == cand2->fn\n-      && TREE_CODE (cand1->fn) == IDENTIFIER_NODE)\n-    {\n-      for (i = 0; i < TREE_VEC_LENGTH (cand1->convs); ++i)\n-\tif (! comptypes (TREE_TYPE (TREE_VEC_ELT (cand1->convs, i)),\n-\t\t\t TREE_TYPE (TREE_VEC_ELT (cand2->convs, i)), 1))\n-\t  break;\n-      if (i == TREE_VEC_LENGTH (cand1->convs))\n-\treturn 1;\n-    }\n-\n-  return winner;\n-}\n-\n-/* Given a list of candidates for overloading, find the best one, if any.\n-   This algorithm has a worst case of O(2n) (winner is last), and a best\n-   case of O(n/2) (totally ambiguous); much better than a sorting\n-   algorithm.  */\n-\n-static struct z_candidate *\n-tourney (candidates)\n-     struct z_candidate *candidates;\n-{\n-  struct z_candidate *champ = candidates, *challenger;\n-  int fate;\n-\n-  /* Walk through the list once, comparing each current champ to the next\n-     candidate, knocking out a candidate or two with each comparison.  */\n-\n-  for (challenger = champ->next; challenger; )\n-    {\n-      fate = joust (champ, challenger);\n-      if (fate == 1)\n-\tchallenger = challenger->next;\n-      else\n-\t{\n-\t  if (fate == 0)\n-\t    {\n-\t      champ = challenger->next;\n-\t      if (champ == 0)\n-\t\treturn 0;\n-\t    }\n-\t  else\n-\t    champ = challenger;\n-\n-\t  challenger = champ->next;\n-\t}\n-    }\n-\n-  /* Make sure the champ is better than all the candidates it hasn't yet\n-     been compared to.  This may do one more comparison than necessary.  Oh\n-     well.  */\n-\n-  for (challenger = candidates; challenger != champ;\n-       challenger = challenger->next)\n-    {\n-      fate = joust (champ, challenger);\n-      if (fate != 1)\n-\treturn 0;\n-    }\n-\n-  return champ;\n-}"}, {"sha": "98d3f14f8eca38f4c9e9dd4d920338b4a0f70877", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 30, "deletions": 9, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c73964b2fbce812d4ef49cdcb82b57a1550cfffa/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c73964b2fbce812d4ef49cdcb82b57a1550cfffa/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=c73964b2fbce812d4ef49cdcb82b57a1550cfffa", "patch": "@@ -4912,9 +4912,7 @@ init_decl_processing ()\n   void_list_node = build_tree_list (NULL_TREE, void_type_node);\n   TREE_PARMLIST (void_list_node) = 1;\n \n-  null_pointer_node = build_int_2 (0, 0);\n   TREE_TYPE (null_pointer_node) = build_pointer_type (void_type_node);\n-  layout_type (TREE_TYPE (null_pointer_node));\n \n   /* Used for expressions that do nothing, but are not errors.  */\n   void_zero_node = build_int_2 (0, 0);\n@@ -9864,6 +9862,10 @@ grokparms (first_parm, funcdef_flag)\n \t\t\t}\n \t\t      else\n \t\t\tinit = require_instantiated_type (type, init, integer_zero_node);\n+\t\t      if (! current_template_parms\n+\t\t\t  && ! implicit_conversion (type, TREE_TYPE (init), init, LOOKUP_NORMAL))\n+\t\t\tcp_pedwarn (\"invalid type `%T' for default argument to `%#D'\",\n+\t\t\t\t    TREE_TYPE (init), decl);\n \t\t    }\n \t\t}\n \t      else\n@@ -11962,7 +11964,7 @@ finish_function (lineno, call_poplevel, nested)\n     pop_memoized_context (1);\n \n   /* Must mark the RESULT_DECL as being in this function.  */\n-  DECL_CONTEXT (DECL_RESULT (fndecl)) = DECL_INITIAL (fndecl);\n+  DECL_CONTEXT (DECL_RESULT (fndecl)) = fndecl;\n \n   /* Obey `register' declarations if `setjmp' is called in this fn.  */\n   if (flag_traditional && current_function_calls_setjmp)\n@@ -12303,15 +12305,14 @@ hack_incomplete_structures (type)\n }\n \n /* If DECL is of a type which needs a cleanup, build that cleanup here.\n-   We don't build cleanups if just going for syntax checking, since\n-   fixup_cleanups does not know how to not handle them.\n+   See build_delete for information about AUTO_DELETE.\n \n    Don't build these on the momentary obstack; they must live\n    the life of the binding contour.  */\n \n-tree\n-maybe_build_cleanup (decl)\n-     tree decl;\n+static tree\n+maybe_build_cleanup_1 (decl, auto_delete)\n+     tree decl, auto_delete;\n {\n   tree type = TREE_TYPE (decl);\n   if (TYPE_NEEDS_DESTRUCTOR (type))\n@@ -12335,7 +12336,7 @@ maybe_build_cleanup (decl)\n \t  || flag_expensive_optimizations)\n \tflags |= LOOKUP_NONVIRTUAL;\n \n-      rval = build_delete (TREE_TYPE (rval), rval, integer_two_node, flags, 0);\n+      rval = build_delete (TREE_TYPE (rval), rval, auto_delete, flags, 0);\n \n       if (TYPE_USES_VIRTUAL_BASECLASSES (type)\n \t  && ! TYPE_HAS_DESTRUCTOR (type))\n@@ -12352,6 +12353,26 @@ maybe_build_cleanup (decl)\n     }\n   return 0;\n }\n+\n+/* If DECL is of a type which needs a cleanup, build that cleanup\n+   here.  The cleanup does free the storage with a call to delete.  */\n+\n+tree\n+maybe_build_cleanup_and_delete (decl)\n+     tree decl;\n+{\n+  return maybe_build_cleanup_1 (decl, integer_three_node);\n+}\n+\n+/* If DECL is of a type which needs a cleanup, build that cleanup\n+   here.  The cleanup does not free the storage with a call a delete.  */\n+\n+tree\n+maybe_build_cleanup (decl)\n+     tree decl;\n+{\n+  return maybe_build_cleanup_1 (decl, integer_two_node);\n+}\n \f\n /* Expand a C++ expression at the statement level.\n    This is needed to ferret out nodes which have UNKNOWN_TYPE."}, {"sha": "b4de01b9e3de6f0d11263002f9d099c4260b20ab", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c73964b2fbce812d4ef49cdcb82b57a1550cfffa/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c73964b2fbce812d4ef49cdcb82b57a1550cfffa/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=c73964b2fbce812d4ef49cdcb82b57a1550cfffa", "patch": "@@ -125,6 +125,15 @@ int flag_no_ident;\n \n int flag_ansi;\n \n+/* Nonzero means do argument matching for overloading according to the\n+   ANSI rules, rather than what g++ used to believe to be correct.  */\n+\n+#ifdef NEW_OVER\n+int flag_ansi_overloading = 1;\n+#else\n+int flag_ansi_overloading;\n+#endif\n+\n /* Nonzero means do emit exported implementations of functions even if\n    they can be inlined.  */\n \n@@ -157,7 +166,11 @@ int warn_ctor_dtor_privacy = 1;\n /* True if we want to implement vtables using \"thunks\".\n    The default is off.  */\n \n+#if defined(NEW_OVER) && defined (__i386__)\n+int flag_vtable_thunks = 1;\n+#else\n int flag_vtable_thunks;\n+#endif\n \n /* True if we want to deal with repository information.  */\n \n@@ -410,6 +423,7 @@ static struct { char *string; int *variable; int on_value;} lang_f_options[] =\n   {\"implement-inlines\", &flag_implement_inlines, 1},\n   {\"external-templates\", &flag_external_templates, 1},\n   {\"implicit-templates\", &flag_implicit_templates, 1},\n+  {\"ansi-overloading\", &flag_ansi_overloading, 1},\n   {\"huge-objects\", &flag_huge_objects, 1},\n   {\"conserve-space\", &flag_conserve_space, 1},\n   {\"vtable-thunks\", &flag_vtable_thunks, 1},\n@@ -2562,7 +2576,7 @@ import_export_template (type)\n     }\n }\n     \n-static int\n+int\n finish_prevtable_vardecl (prev, vars)\n      tree prev, vars;\n {"}, {"sha": "964f8c05ce7dec0fa5c8dc693d4ed9ae5d29634d", "filename": "gcc/cp/error.c", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c73964b2fbce812d4ef49cdcb82b57a1550cfffa/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c73964b2fbce812d4ef49cdcb82b57a1550cfffa/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=c73964b2fbce812d4ef49cdcb82b57a1550cfffa", "patch": "@@ -1539,9 +1539,20 @@ args_as_string (p, v)\n      int v;\n {\n   if (p == NULL_TREE)\n-    return \"...\";\n+    return \"\";\n \n-  return type_as_string (p, v);\n+  if (TREE_CODE_CLASS (TREE_CODE (TREE_VALUE (p))) == 't')\n+    return type_as_string (p, v);\n+\n+  OB_INIT ();\n+  for (; p; p = TREE_CHAIN (p))\n+    {\n+      dump_type (TREE_TYPE (TREE_VALUE (p)), v);\n+      if (TREE_CHAIN (p))\n+\tOB_PUTS (\", \");\n+    }\n+  OB_FINISH ();\n+  return (char *)obstack_base (&scratch_obstack);\n }\n \n char *"}, {"sha": "257ec113a124d910286a11950a9d97d9308ff4d4", "filename": "gcc/cp/except.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c73964b2fbce812d4ef49cdcb82b57a1550cfffa/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c73964b2fbce812d4ef49cdcb82b57a1550cfffa/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=c73964b2fbce812d4ef49cdcb82b57a1550cfffa", "patch": "@@ -1079,7 +1079,7 @@ expand_throw (exp)\n \t  start_sequence ();\n \t  object = build_reinterpret_cast (TREE_TYPE (exp), saved_throw_value);\n \t  object = build_indirect_ref (object, NULL_PTR);\n-\t  cleanup = maybe_build_cleanup (object);\n+\t  cleanup = maybe_build_cleanup_and_delete (object);\n \t  if (cleanup)\n \t    expand_expr (cleanup, const0_rtx, VOIDmode, 0);\n \t  cleanup_insns = get_insns ();\n@@ -1089,7 +1089,8 @@ expand_throw (exp)\n \t    {\n \t      cleanup = start_anon_func ();\n \n-\t      expand_expr (maybe_build_cleanup (object), const0_rtx, VOIDmode, 0);\n+\t      expand_expr (maybe_build_cleanup_and_delete (object),\n+\t\t\t   const0_rtx, VOIDmode, 0);\n \n \t      end_anon_func ();\n "}, {"sha": "f846f5ce508e9cb0f93e2df435008a4eed8353ba", "filename": "gcc/cp/gxx.gperf", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c73964b2fbce812d4ef49cdcb82b57a1550cfffa/gcc%2Fcp%2Fgxx.gperf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c73964b2fbce812d4ef49cdcb82b57a1550cfffa/gcc%2Fcp%2Fgxx.gperf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fgxx.gperf?ref=c73964b2fbce812d4ef49cdcb82b57a1550cfffa", "patch": "@@ -15,6 +15,7 @@ __extension__, EXTENSION, NORID\n __inline, SCSPEC, RID_INLINE\n __inline__, SCSPEC, RID_INLINE\n __label__, LABEL, NORID\n+__null, CONSTANT, RID_NULL\n __signature__, AGGR, RID_SIGNATURE\t/* Extension */,\n __signed, TYPESPEC, RID_SIGNED\n __signed__, TYPESPEC, RID_SIGNED"}, {"sha": "d8bdc06ee2b84e0ac187a432e4bde62f1dd57c48", "filename": "gcc/cp/hash.h", "status": "modified", "additions": 124, "deletions": 116, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c73964b2fbce812d4ef49cdcb82b57a1550cfffa/gcc%2Fcp%2Fhash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c73964b2fbce812d4ef49cdcb82b57a1550cfffa/gcc%2Fcp%2Fhash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fhash.h?ref=c73964b2fbce812d4ef49cdcb82b57a1550cfffa", "patch": "@@ -1,14 +1,14 @@\n /* C code produced by gperf version 2.5 (GNU C++ version) */\n-/* Command-line: gperf -p -j1 -g -o -t -N is_reserved_word -k1,4,7,$ ../../../devo/gcc/cp/gxx.gperf  */\n+/* Command-line: gperf -p -j1 -g -o -t -N is_reserved_word -k1,4,7,$ /yorick/splunge/jason/g++/small/devo/gcc/cp/gxx.gperf  */\n /* Command-line: gperf -p -j1 -g -o -t -N is_reserved_word -k1,4,$,7 gplus.gperf  */\n struct resword { char *name; short token; enum rid rid;};\n \n-#define TOTAL_KEYWORDS 97\n+#define TOTAL_KEYWORDS 98\n #define MIN_WORD_LENGTH 2\n #define MAX_WORD_LENGTH 16\n #define MIN_HASH_VALUE 4\n-#define MAX_HASH_VALUE 219\n-/* maximum key range = 216, duplicates = 0 */\n+#define MAX_HASH_VALUE 258\n+/* maximum key range = 255, duplicates = 0 */\n \n #ifdef __GNUC__\n inline\n@@ -18,21 +18,21 @@ hash (str, len)\n      register char *str;\n      register int unsigned len;\n {\n-  static unsigned char asso_values[] =\n+  static unsigned short asso_values[] =\n     {\n-     220, 220, 220, 220, 220, 220, 220, 220, 220, 220,\n-     220, 220, 220, 220, 220, 220, 220, 220, 220, 220,\n-     220, 220, 220, 220, 220, 220, 220, 220, 220, 220,\n-     220, 220, 220, 220, 220, 220, 220, 220, 220, 220,\n-     220, 220, 220, 220, 220, 220, 220, 220, 220, 220,\n-     220, 220, 220, 220, 220, 220, 220, 220, 220, 220,\n-     220, 220, 220, 220, 220, 220, 220, 220, 220, 220,\n-     220, 220, 220, 220, 220, 220, 220, 220, 220, 220,\n-     220, 220, 220, 220, 220, 220, 220, 220, 220, 220,\n-     220, 220, 220, 220, 220,   0, 220,  88,  16,  19,\n-      52,   0,   9,  72,   1,  77, 220,   0,   0,  38,\n-      13,  44,  38,  30,  27,  57,   1,  14,   0,   2,\n-       2,   7, 220, 220, 220, 220, 220, 220,\n+     259, 259, 259, 259, 259, 259, 259, 259, 259, 259,\n+     259, 259, 259, 259, 259, 259, 259, 259, 259, 259,\n+     259, 259, 259, 259, 259, 259, 259, 259, 259, 259,\n+     259, 259, 259, 259, 259, 259, 259, 259, 259, 259,\n+     259, 259, 259, 259, 259, 259, 259, 259, 259, 259,\n+     259, 259, 259, 259, 259, 259, 259, 259, 259, 259,\n+     259, 259, 259, 259, 259, 259, 259, 259, 259, 259,\n+     259, 259, 259, 259, 259, 259, 259, 259, 259, 259,\n+     259, 259, 259, 259, 259, 259, 259, 259, 259, 259,\n+     259, 259, 259, 259, 259,   0, 259,  27,  17,  20,\n+      40,   0,  64,   6,  10,  89, 259,   2, 110,  44,\n+      13, 107,  40,  10,  18,  55,   1,   3,   5,  17,\n+       2,   4, 259, 259, 259, 259, 259, 259,\n     };\n   register int hval = len;\n \n@@ -49,6 +49,7 @@ hash (str, len)\n       case 2:\n       case 1:\n         hval += asso_values[str[0]];\n+        break;\n     }\n   return hval + asso_values[str[len - 1]];\n }\n@@ -66,143 +67,150 @@ is_reserved_word (str, len)\n       {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n       {\"else\",  ELSE, NORID,},\n       {\"true\",  CXX_TRUE, NORID,},\n-      {\"\",}, \n-      {\"while\",  WHILE, NORID,},\n-      {\"virtual\",  SCSPEC, RID_VIRTUAL,},\n       {\"\",}, {\"\",}, \n       {\"try\",  TRY, NORID,},\n-      {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n-      {\"typeof\",  TYPEOF, NORID,},\n+      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n       {\"not\",  '!', NORID,},\n-      {\"new\",  NEW, NORID,},\n+      {\"xor_eq\",  ASSIGN, NORID,},\n       {\"extern\",  SCSPEC, RID_EXTERN,},\n-      {\"bool\",  TYPESPEC, RID_BOOL,},\n-      {\"\",}, {\"\",}, \n+      {\"\",}, {\"\",}, {\"\",}, \n+      {\"xor\",  '^', NORID,},\n       {\"case\",  CASE, NORID,},\n-      {\"__alignof__\",  ALIGNOF, NORID},\n-      {\"\",}, \n-      {\"typedef\",  SCSPEC, RID_TYPEDEF,},\n-      {\"\",}, \n+      {\"\",}, {\"\",}, \n+      {\"using\",  USING, NORID,},\n       {\"__extension__\",  EXTENSION, NORID},\n+      {\"not_eq\",  EQCOMPARE, NORID,},\n       {\"\",}, {\"\",}, \n-      {\"__alignof\",  ALIGNOF, NORID},\n-      {\"xor\",  '^', NORID,},\n-      {\"\",}, \n+      {\"continue\",  CONTINUE, NORID,},\n+      {\"new\",  NEW, NORID,},\n       {\"__inline\",  SCSPEC, RID_INLINE},\n       {\"\",}, \n       {\"__inline__\",  SCSPEC, RID_INLINE},\n-      {\"\",}, \n-      {\"xor_eq\",  ASSIGN, NORID,},\n-      {\"for\",  FOR, NORID,},\n+      {\"\",}, {\"\",}, {\"\",}, \n+      {\"return\",  RETURN, NORID,},\n       {\"\",}, {\"\",}, \n-      {\"continue\",  CONTINUE, NORID,},\n-      {\"\",}, \n-      {\"catch\",  CATCH, NORID,},\n-      {\"private\",  VISSPEC, RID_PRIVATE,},\n-      {\"\",}, \n-      {\"typename\",  TYPENAME_KEYWORD, NORID,},\n-      {\"template\",  TEMPLATE, RID_TEMPLATE,},\n-      {\"not_eq\",  EQCOMPARE, NORID,},\n+      {\"and_eq\",  ASSIGN, NORID,},\n       {\"\",}, {\"\",}, \n-      {\"throw\",  THROW, NORID,},\n-      {\"__const\",  TYPE_QUAL, RID_CONST},\n-      {\"__const__\",  TYPE_QUAL, RID_CONST},\n-      {\"__volatile\",  TYPE_QUAL, RID_VOLATILE},\n-      {\"__wchar_t\",  TYPESPEC, RID_WCHAR  /* Unique to ANSI C++ */,},\n-      {\"__volatile__\",  TYPE_QUAL, RID_VOLATILE},\n       {\"delete\",  DELETE, NORID,},\n       {\"typeid\",  TYPEID, NORID,},\n-      {\"return\",  RETURN, NORID,},\n-      {\"__typeof__\",  TYPEOF, NORID},\n-      {\"compl\",  '~', NORID,},\n-      {\"public\",  VISSPEC, RID_PUBLIC,},\n-      {\"__asm__\",  GCC_ASM_KEYWORD, NORID},\n-      {\"switch\",  SWITCH, NORID,},\n+      {\"__wchar_t\",  TYPESPEC, RID_WCHAR  /* Unique to ANSI C++ */,},\n+      {\"namespace\",  NAMESPACE, NORID,},\n+      {\"template\",  TEMPLATE, RID_TEMPLATE,},\n+      {\"break\",  BREAK, NORID,},\n+      {\"private\",  VISSPEC, RID_PRIVATE,},\n+      {\"typename\",  TYPENAME_KEYWORD, NORID,},\n       {\"\",}, \n-      {\"friend\",  SCSPEC, RID_FRIEND,},\n-      {\"__typeof\",  TYPEOF, NORID},\n+      {\"catch\",  CATCH, NORID,},\n+      {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"char\",  TYPESPEC, RID_CHAR,},\n       {\"\",}, \n-      {\"static_cast\",  STATIC_CAST, NORID,},\n-      {\"false\",  CXX_FALSE, NORID,},\n-      {\"sizeof\",  SIZEOF, NORID,},\n-      {\"or\",  OROR, NORID,},\n+      {\"__asm__\",  GCC_ASM_KEYWORD, NORID},\n       {\"double\",  TYPESPEC, RID_DOUBLE,},\n       {\"\",}, \n-      {\"union\",  AGGR, RID_UNION,},\n-      {\"char\",  TYPESPEC, RID_CHAR,},\n       {\"struct\",  AGGR, RID_RECORD,},\n-      {\"or_eq\",  ASSIGN, NORID,},\n-      {\"enum\",  ENUM, NORID,},\n-      {\"int\",  TYPESPEC, RID_INT,},\n-      {\"const\",  TYPE_QUAL, RID_CONST,},\n-      {\"static\",  SCSPEC, RID_STATIC,},\n       {\"reinterpret_cast\",  REINTERPRET_CAST, NORID,},\n       {\"\",}, \n-      {\"explicit\",  SCSPEC, RID_EXPLICIT,},\n-      {\"__signed__\",  TYPESPEC, RID_SIGNED},\n-      {\"if\",  IF, NORID,},\n-      {\"__attribute\",  ATTRIBUTE, NORID},\n+      {\"static_cast\",  STATIC_CAST, NORID,},\n+      {\"\",}, \n+      {\"and\",  ANDAND, NORID,},\n+      {\"typeof\",  TYPEOF, NORID,},\n+      {\"switch\",  SWITCH, NORID,},\n+      {\"\",}, \n+      {\"asm\",  ASM_KEYWORD, NORID,},\n+      {\"\",}, \n+      {\"default\",  DEFAULT, NORID,},\n+      {\"\",}, \n+      {\"mutable\",  SCSPEC, RID_MUTABLE,},\n       {\"short\",  TYPESPEC, RID_SHORT,},\n-      {\"__attribute__\",  ATTRIBUTE, NORID},\n-      {\"bitor\",  '|', NORID,},\n       {\"signature\",  AGGR, RID_SIGNATURE\t/* Extension */,},\n+      {\"const\",  TYPE_QUAL, RID_CONST,},\n+      {\"static\",  SCSPEC, RID_STATIC,},\n+      {\"\",}, {\"\",}, \n+      {\"for\",  FOR, NORID,},\n+      {\"\",}, {\"\",}, {\"\",}, \n+      {\"void\",  TYPESPEC, RID_VOID,},\n+      {\"bitand\",  '&', NORID,},\n+      {\"protected\",  VISSPEC, RID_PROTECTED,},\n+      {\"enum\",  ENUM, NORID,},\n+      {\"int\",  TYPESPEC, RID_INT,},\n+      {\"\",}, {\"\",}, {\"\",}, \n+      {\"float\",  TYPESPEC, RID_FLOAT,},\n       {\"\",}, \n-      {\"__sigof__\",  SIGOF, NORID\t\t/* Extension */,},\n-      {\"volatile\",  TYPE_QUAL, RID_VOLATILE,},\n-      {\"__label__\",  LABEL, NORID},\n-      {\"do\",  DO, NORID,},\n+      {\"__signed__\",  TYPESPEC, RID_SIGNED},\n+      {\"dynamic_cast\",  DYNAMIC_CAST, NORID,},\n+      {\"__attribute\",  ATTRIBUTE, NORID},\n       {\"\",}, \n+      {\"__attribute__\",  ATTRIBUTE, NORID},\n       {\"__asm\",  GCC_ASM_KEYWORD, NORID},\n-      {\"protected\",  VISSPEC, RID_PROTECTED,},\n-      {\"\",}, \n-      {\"float\",  TYPESPEC, RID_FLOAT,},\n-      {\"using\",  USING, NORID,},\n       {\"\",}, \n       {\"const_cast\",  CONST_CAST, NORID,},\n-      {\"\",}, \n-      {\"void\",  TYPESPEC, RID_VOID,},\n-      {\"break\",  BREAK, NORID,},\n-      {\"namespace\",  NAMESPACE, NORID,},\n-      {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n-      {\"sigof\",  SIGOF, NORID\t\t/* Extension */,},\n       {\"\",}, {\"\",}, {\"\",}, \n-      {\"this\",  THIS, NORID,},\n-      {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n-      {\"and_eq\",  ASSIGN, NORID,},\n+      {\"friend\",  SCSPEC, RID_FRIEND,},\n       {\"\",}, {\"\",}, {\"\",}, \n       {\"signed\",  TYPESPEC, RID_SIGNED,},\n-      {\"asm\",  ASM_KEYWORD, NORID,},\n-      {\"\",}, {\"\",}, {\"\",}, \n-      {\"mutable\",  SCSPEC, RID_MUTABLE,},\n-      {\"\",}, {\"\",}, {\"\",}, \n-      {\"__signed\",  TYPESPEC, RID_SIGNED},\n-      {\"class\",  AGGR, RID_CLASS,},\n-      {\"register\",  SCSPEC, RID_REGISTER,},\n-      {\"\",}, {\"\",}, {\"\",}, \n-      {\"and\",  ANDAND, NORID,},\n-      {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n-      {\"long\",  TYPESPEC, RID_LONG,},\n-      {\"default\",  DEFAULT, NORID,},\n-      {\"operator\",  OPERATOR, NORID,},\n-      {\"unsigned\",  TYPESPEC, RID_UNSIGNED,},\n-      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n-      {\"inline\",  SCSPEC, RID_INLINE,},\n+      {\"this\",  THIS, NORID,},\n+      {\"__const\",  TYPE_QUAL, RID_CONST},\n+      {\"__const__\",  TYPE_QUAL, RID_CONST},\n+      {\"__volatile\",  TYPE_QUAL, RID_VOLATILE},\n+      {\"__null\",  CONSTANT, RID_NULL},\n+      {\"__volatile__\",  TYPE_QUAL, RID_VOLATILE},\n+      {\"__typeof__\",  TYPEOF, NORID},\n+      {\"or_eq\",  ASSIGN, NORID,},\n       {\"\",}, \n-      {\"bitand\",  '&', NORID,},\n+      {\"false\",  CXX_FALSE, NORID,},\n+      {\"sizeof\",  SIZEOF, NORID,},\n+      {\"long\",  TYPESPEC, RID_LONG,},\n+      {\"or\",  OROR, NORID,},\n+      {\"union\",  AGGR, RID_UNION,},\n+      {\"__signature__\",  AGGR, RID_SIGNATURE\t/* Extension */,},\n+      {\"throw\",  THROW, NORID,},\n       {\"\",}, \n-      {\"goto\",  GOTO, NORID,},\n-      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n-      {\"dynamic_cast\",  DYNAMIC_CAST, NORID,},\n+      {\"while\",  WHILE, NORID,},\n+      {\"register\",  SCSPEC, RID_REGISTER,},\n+      {\"__alignof__\",  ALIGNOF, NORID},\n+      {\"class\",  AGGR, RID_CLASS,},\n+      {\"typedef\",  SCSPEC, RID_TYPEDEF,},\n+      {\"__signed\",  TYPESPEC, RID_SIGNED},\n+      {\"\",}, {\"\",}, \n+      {\"unsigned\",  TYPESPEC, RID_UNSIGNED,},\n       {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n-      {\"__signature__\",  AGGR, RID_SIGNATURE\t/* Extension */,},\n+      {\"__label__\",  LABEL, NORID},\n+      {\"bitor\",  '|', NORID,},\n       {\"\",}, \n-      {\"auto\",  SCSPEC, RID_AUTO,},\n-      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n-      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"do\",  DO, NORID,},\n+      {\"volatile\",  TYPE_QUAL, RID_VOLATILE,},\n+      {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"if\",  IF, NORID,},\n+      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"__sigof__\",  SIGOF, NORID\t\t/* Extension */,},\n       {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"\",}, {\"\",}, {\"\",}, \n+      {\"compl\",  '~', NORID,},\n+      {\"public\",  VISSPEC, RID_PUBLIC,},\n+      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"__typeof\",  TYPEOF, NORID},\n+      {\"inline\",  SCSPEC, RID_INLINE,},\n       {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n       {\"\",}, {\"\",}, \n+      {\"__alignof\",  ALIGNOF, NORID},\n+      {\"\",}, {\"\",}, {\"\",}, \n       {\"overload\",  OVERLOAD, NORID,},\n+      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"explicit\",  SCSPEC, RID_EXPLICIT,},\n+      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"goto\",  GOTO, NORID,},\n+      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"sigof\",  SIGOF, NORID\t\t/* Extension */,},\n+      {\"\",}, \n+      {\"virtual\",  SCSPEC, RID_VIRTUAL,},\n+      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"bool\",  TYPESPEC, RID_BOOL,},\n+      {\"\",}, {\"\",}, {\"\",}, \n+      {\"auto\",  SCSPEC, RID_AUTO,},\n+      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+      {\"\",}, {\"\",}, {\"\",}, \n+      {\"operator\",  OPERATOR, NORID,},\n     };\n \n   if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)"}, {"sha": "1d49c409beaf43e56560d276267288810a9ca508", "filename": "gcc/cp/init.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c73964b2fbce812d4ef49cdcb82b57a1550cfffa/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c73964b2fbce812d4ef49cdcb82b57a1550cfffa/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=c73964b2fbce812d4ef49cdcb82b57a1550cfffa", "patch": "@@ -1541,9 +1541,14 @@ expand_aggr_init_1 (binfo, true_exp, exp, init, alias_this, flags)\n \t    {\n \t      tree rval = build_type_conversion (CONVERT_EXPR, type, init, 1);\n \n-\t      if (rval)\n+\t      if (flag_ansi_overloading && rval)\n+\t\t{\n+\t\t  if (rval != error_mark_node)\n+\t\t    expand_aggr_init_1 (binfo, true_exp, exp, rval, alias_this, flags);\n+\t\t  return;\n+\t\t}\n+\t      else if (rval)\n \t\t{\n-#ifndef NEW_OVER\n \t\t  /* See if there is a constructor for``type'' that takes a\n \t\t     ``ttype''-typed object.  */\n \t\t  tree parms = build_tree_list (NULL_TREE, init);\n@@ -1557,9 +1562,8 @@ expand_aggr_init_1 (binfo, true_exp, exp, init, alias_this, flags)\n \t\t    cp_error (\"ambiguity between conversion to `%T' and constructor\",\n \t\t\t      type);\n \t\t  else\n-#endif\n-\t\t  if (rval != error_mark_node)\n-\t\t    expand_aggr_init_1 (binfo, true_exp, exp, rval, alias_this, flags);\n+\t\t    if (rval != error_mark_node)\n+\t\t      expand_aggr_init_1 (binfo, true_exp, exp, rval, alias_this, flags);\n \t\t  return;\n \t\t}\n \t    }"}, {"sha": "66e00463e320f5e4a640079c65f14f43ac26834c", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c73964b2fbce812d4ef49cdcb82b57a1550cfffa/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c73964b2fbce812d4ef49cdcb82b57a1550cfffa/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=c73964b2fbce812d4ef49cdcb82b57a1550cfffa", "patch": "@@ -673,6 +673,9 @@ init_lex ()\n   TREE_TYPE (signature_type_node) = signature_type_node;\n   ridpointers[(int) RID_SIGNATURE] = signature_type_node;\n \n+  null_pointer_node = build_int_2 (0, 0);\n+  ridpointers[RID_NULL] = null_pointer_node;\n+\n   opname_tab[(int) COMPONENT_REF] = \"->\";\n   opname_tab[(int) MEMBER_REF] = \"->*\";\n   opname_tab[(int) METHOD_CALL_EXPR] = \"->()\";\n@@ -2561,7 +2564,7 @@ do_identifier (token, parsing)\n       else if (IDENTIFIER_OPNAME_P (token))\n \t{\n \t  if (token != ansi_opname[ERROR_MARK])\n-\t    cp_error (\"operator %O not defined\", token);\n+\t    cp_error (\"`%D' not defined\", token);\n \t  id = error_mark_node;\n \t}\n       else if (parsing && (yychar == '(' || yychar == LEFT_RIGHT))"}, {"sha": "4a2c7d133d244865d67205470c782ca04b0c586a", "filename": "gcc/cp/lex.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c73964b2fbce812d4ef49cdcb82b57a1550cfffa/gcc%2Fcp%2Flex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c73964b2fbce812d4ef49cdcb82b57a1550cfffa/gcc%2Fcp%2Flex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.h?ref=c73964b2fbce812d4ef49cdcb82b57a1550cfffa", "patch": "@@ -72,6 +72,7 @@ enum rid\n   RID_EXCEPTION,\n   RID_TEMPLATE,\n   RID_SIGNATURE,\n+  RID_NULL,\n   /* Before adding enough to get up to 64, the RIDBIT_* macros\n      will have to be changed a little.  */\n   RID_MAX"}, {"sha": "64563438e7e772bac25f8261cac3814943cac4f0", "filename": "gcc/cp/method.c", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c73964b2fbce812d4ef49cdcb82b57a1550cfffa/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c73964b2fbce812d4ef49cdcb82b57a1550cfffa/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=c73964b2fbce812d4ef49cdcb82b57a1550cfffa", "patch": "@@ -674,7 +674,14 @@ build_overload_name (parmtypes, begin, end)\n \n \t  if (TREE_USED (parmtype))\n \t    {\n+#if 0\n+\t      /* We can turn this on at some point when we want\n+\t\t improved symbol mangling.  */\n+\t      nrepeats++;\n+#else\n+\t      /* This is bug compatible with 2.7.x  */\n \t      flush_repeats (parmtype);\n+#endif\n \t      goto next;\n \t    }\n \n@@ -1193,9 +1200,8 @@ build_opfncall (code, flags, xarg1, xarg2, arg3)\n   int try_second;\n   int binary_is_unary;\n \n-#ifdef NEW_OVER\n-  return build_new_op (code, flags, xarg1, xarg2, arg3);\n-#endif\n+  if (flag_ansi_overloading)\n+    return build_new_op (code, flags, xarg1, xarg2, arg3);\n \n   if (xarg1 == error_mark_node)\n     return error_mark_node;"}, {"sha": "40a4582332e49962c56507c02e2d5dbbde029623", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c73964b2fbce812d4ef49cdcb82b57a1550cfffa/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c73964b2fbce812d4ef49cdcb82b57a1550cfffa/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=c73964b2fbce812d4ef49cdcb82b57a1550cfffa", "patch": "@@ -1189,10 +1189,15 @@ instantiate_class_template (type)\n       tree tmp;\n       for (tmp = TYPE_FIELDS (type); tmp; tmp = TREE_CHAIN (tmp))\n \tif (TREE_CODE (tmp) == FIELD_DECL)\n-\t  require_complete_type (tmp);\n+\t  {\n+\t    TREE_TYPE (tmp) = complete_type (TREE_TYPE (tmp));\n+\t    require_complete_type (tmp);\n+\t  }\n \n       type = finish_struct_1 (type, 0);\n       CLASSTYPE_GOT_SEMICOLON (type) = 1;\n+      if (at_eof && TYPE_BINFO_VTABLE (type) != NULL_TREE)\n+\tfinish_prevtable_vardecl (NULL, TYPE_BINFO_VTABLE (type));\n \n       repo_template_used (type);\n     }\n@@ -2707,13 +2712,11 @@ unify (tparms, targs, ntparms, parm, arg, nsubsts, strict)\n       if (CLASSTYPE_TEMPLATE_INFO (parm) && uses_template_parms (parm))\n \t{\n \t  tree t = NULL_TREE;\n-#ifdef NEW_OVER\n-\t  if (! strict)\n+\t  if (flag_ansi_overloading && ! strict)\n \t    t = get_template_base (CLASSTYPE_TI_TEMPLATE (parm), arg);\n-\t  else\n-#endif\n-\t  if (CLASSTYPE_TEMPLATE_INFO (arg)\n-\t      && CLASSTYPE_TI_TEMPLATE (parm) == CLASSTYPE_TI_TEMPLATE (arg))\n+\t  else if\n+\t    (CLASSTYPE_TEMPLATE_INFO (arg)\n+\t     && CLASSTYPE_TI_TEMPLATE (parm) == CLASSTYPE_TI_TEMPLATE (arg))\n \t    t = arg;\n \t  if (! t || t == error_mark_node)\n \t    return 1;"}, {"sha": "ebb692ddef70267d43abc9f5eeb18952d48b5cec", "filename": "gcc/cp/search.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c73964b2fbce812d4ef49cdcb82b57a1550cfffa/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c73964b2fbce812d4ef49cdcb82b57a1550cfffa/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=c73964b2fbce812d4ef49cdcb82b57a1550cfffa", "patch": "@@ -3087,8 +3087,8 @@ build_mi_matrix (type)\n   dfs_walk (binfo, dfs_number, unnumberedp);\n \n   mi_size = CLASSTYPE_N_SUPERCLASSES (type) + CLASSTYPE_N_VBASECLASSES (type);\n-  if (mi_size < cid)\n-    mi_size = cid;\n+  if (mi_size < (cid-1))\n+    mi_size = cid-1;\n   mi_matrix = (char *)xmalloc ((mi_size + 1) * (mi_size + 1));\n   mi_type = type;\n   bzero (mi_matrix, (mi_size + 1) * (mi_size + 1));\n@@ -3551,6 +3551,7 @@ add_conversions (binfo)\n \tbreak;\n       conversions = tree_cons (binfo, tmp, conversions);\n     }\n+  SET_BINFO_MARKED (binfo);\n }\n \n tree\n@@ -3559,7 +3560,10 @@ lookup_conversions (type)\n {\n   conversions = NULL_TREE;\n   if (TYPE_SIZE (type))\n-    dfs_walk (TYPE_BINFO (type), add_conversions, 0);\n+    {\n+      dfs_walk (TYPE_BINFO (type), add_conversions, unmarkedp);\n+      dfs_walk (TYPE_BINFO (type), dfs_unmark, markedp);\n+    }\n   return conversions;\n }\n "}, {"sha": "a43443bd7fe370f13ab17e12e2bc954aeb970e6a", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 54, "deletions": 19, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c73964b2fbce812d4ef49cdcb82b57a1550cfffa/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c73964b2fbce812d4ef49cdcb82b57a1550cfffa/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=c73964b2fbce812d4ef49cdcb82b57a1550cfffa", "patch": "@@ -135,6 +135,10 @@ complete_type (type)\n       if (TYPE_SIZE (t) != NULL_TREE\n \t  && current_template_parms == NULL_TREE)\n \tlayout_type (type);\n+      TYPE_NEEDS_CONSTRUCTING (type)\n+\t= TYPE_NEEDS_CONSTRUCTING (TYPE_MAIN_VARIANT (t));\n+      TYPE_NEEDS_DESTRUCTOR (type)\n+\t= TYPE_NEEDS_DESTRUCTOR (TYPE_MAIN_VARIANT (t));\n     }\n   else if (IS_AGGR_TYPE (type) && CLASSTYPE_TEMPLATE_INSTANTIATION (type))\n     instantiate_class_template (TYPE_MAIN_VARIANT (type));\n@@ -771,7 +775,7 @@ comptypes (type1, type2, strict)\n \t    {\n \t      int rval;\n \t    look_hard:\n-\t      rval = t1 == t2 || UNIQUELY_DERIVED_FROM_P (t1, t2);\n+\t      rval = t1 == t2 || DERIVED_FROM_P (t1, t2);\n \n \t      if (rval)\n \t\t{\n@@ -780,7 +784,7 @@ comptypes (type1, type2, strict)\n \t\t}\n \t      if (strict < 0)\n \t\t{\n-\t\t  val = UNIQUELY_DERIVED_FROM_P (t2, t1);\n+\t\t  val = DERIVED_FROM_P (t2, t1);\n \t\t  break;\n \t\t}\n \t    }\n@@ -2239,8 +2243,12 @@ build_x_function_call (function, params, decl)\n   /* Handle methods, friends, and overloaded functions, respectively.  */\n   if (is_method)\n     {\n+      tree basetype = NULL_TREE;\n+\n       if (TREE_CODE (function) == FUNCTION_DECL)\n \t{\n+\t  basetype = DECL_CLASS_CONTEXT (function);\n+\n \t  if (DECL_NAME (function))\n \t    function = DECL_NAME (function);\n \t  else\n@@ -2249,6 +2257,7 @@ build_x_function_call (function, params, decl)\n       else if (TREE_CODE (function) == TREE_LIST)\n \t{\n \t  my_friendly_assert (TREE_CODE (TREE_VALUE (function)) == FUNCTION_DECL, 312);\n+\t  basetype = DECL_CLASS_CONTEXT (TREE_VALUE (function));\n \t  function = TREE_PURPOSE (function);\n \t}\n       else if (TREE_CODE (function) != IDENTIFIER_NODE)\n@@ -2276,6 +2285,10 @@ build_x_function_call (function, params, decl)\n          must go through here in case it is a virtual function.\n \t @@ Perhaps this could be optimized.  */\n \n+      if (basetype && (! current_class_type\n+\t\t       || ! DERIVED_FROM_P (basetype, current_class_type)))\n+\treturn build_member_call (basetype, function, params);\n+\n       if (decl == NULL_TREE)\n \t{\n \t  if (current_class_type == NULL_TREE)\n@@ -2315,11 +2328,11 @@ build_x_function_call (function, params, decl)\n \t}\n       else\n \t{\n-#ifdef NEW_OVER\n-\t  return build_new_function_call (function, params, NULL_TREE);\n-#else\n \t  tree val = TREE_VALUE (function);\n \n+\t  if (flag_ansi_overloading)\n+\t    return build_new_function_call (function, params, NULL_TREE);\n+\n \t  if (TREE_CODE (val) == TEMPLATE_DECL)\n \t    return build_overload_call_real\n \t      (function, params, LOOKUP_COMPLAIN, (struct candidate *)0, 0);\n@@ -2328,7 +2341,6 @@ build_x_function_call (function, params, decl)\n \t      (function, params, LOOKUP_COMPLAIN);\n \t  else\n \t    my_friendly_abort (360);\n-#endif\n \t}\n     }\n \n@@ -2628,6 +2640,8 @@ build_function_call_real (function, params, require_complete, flags)\n \t  return result;\n \tresult = require_complete_type (result);\n       }\n+    if (IS_AGGR_TYPE (value_type))\n+      result = build_cplus_new (value_type, result);\n     return convert_from_reference (result);\n   }\n }\n@@ -2899,6 +2913,9 @@ build_x_binary_op (code, arg1, arg2)\n   if (current_template_parms)\n     return build_min_nt (code, arg1, arg2);\n \n+  if (flag_ansi_overloading)\n+    return build_new_op (code, LOOKUP_NORMAL, arg1, arg2, NULL_TREE);\n+\n   rval = build_opfncall (code, LOOKUP_SPECULATIVELY,\n \t\t\t arg1, arg2, NULL_TREE);\n   if (rval)\n@@ -3955,11 +3972,23 @@ build_x_unary_op (code, xarg)\n     /* don't look for a function */;\n   else\n     {\n-      tree rval = build_opfncall (code, LOOKUP_SPECULATIVELY, xarg,\n-\t\t\t\t  NULL_TREE, NULL_TREE);\n-      if (rval)\n-\treturn build_opfncall (code, LOOKUP_NORMAL, xarg,\n+      tree rval;\n+\n+      if (flag_ansi_overloading)\n+\t{\n+\t  rval = build_new_op (code, LOOKUP_NORMAL, xarg,\n \t\t\t       NULL_TREE, NULL_TREE);\n+\t  if (rval || code != ADDR_EXPR)\n+\t    return rval;\n+\t}\n+      else\n+\t{\n+\t  rval = build_opfncall (code, LOOKUP_SPECULATIVELY, xarg,\n+\t\t\t\t NULL_TREE, NULL_TREE);\n+\t  if (rval)\n+\t    return build_opfncall (code, LOOKUP_NORMAL, xarg,\n+\t\t\t\t   NULL_TREE, NULL_TREE);\n+\t}\n     }\n \n   if (code == ADDR_EXPR)\n@@ -4629,6 +4658,9 @@ build_x_conditional_expr (ifexp, op1, op2)\n   if (current_template_parms)\n     return build_min_nt (COND_EXPR, ifexp, op1, op2);\n \n+  if (flag_ansi_overloading)\n+    return build_new_op (COND_EXPR, LOOKUP_NORMAL, ifexp, op1, op2);\n+\n   /* See comments in `build_x_binary_op'.  */\n   if (op1 != 0)\n     rval = build_opfncall (COND_EXPR, LOOKUP_SPECULATIVELY, ifexp, op1, op2);\n@@ -4723,6 +4755,15 @@ build_conditional_expr (ifexp, op1, op2)\n       result = fold (build (COND_EXPR, type1, ifexp, op1, op2));\n       if (TREE_TYPE (result) != type1)\n \tresult = build1 (NOP_EXPR, type1, result);\n+      /* Expand both sides into the same slot,\n+\t hopefully the target of the ?: expression.  */\n+      if (TREE_CODE (op1) == TARGET_EXPR && TREE_CODE (op2) == TARGET_EXPR)\n+\t{\n+\t  tree slot = build (VAR_DECL, TREE_TYPE (result));\n+\t  layout_decl (slot, 0);\n+\t  result = build (TARGET_EXPR, TREE_TYPE (result),\n+\t\t\t  slot, result, NULL_TREE, NULL_TREE);\n+\t}\n       return result;\n     }\n \n@@ -6093,12 +6134,7 @@ build_ptrmemfunc (type, pfn, force)\n   if (TREE_CODE (pfn) == TREE_LIST\n       || (TREE_CODE (pfn) == ADDR_EXPR\n \t  && TREE_CODE (TREE_OPERAND (pfn, 0)) == TREE_LIST))\n-    {\n-      pfn = instantiate_type (type, pfn, 1);\n-      if (pfn == error_mark_node)\n-\treturn error_mark_node;\n-      pfn = build_addr_func (pfn);\n-    }\n+    return instantiate_type (type, pfn, 1);\n \n   /* Allow pointer to member conversions here.  */\n   delta = get_delta_difference (TYPE_METHOD_BASETYPE (TREE_TYPE (TREE_TYPE (pfn))),\n@@ -6354,7 +6390,7 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n \n \t  if (TYPE_MAIN_VARIANT (ttl) != void_type_node\n \t      && TYPE_MAIN_VARIANT (ttr) == void_type_node\n-\t      && rhs != null_pointer_node)\n+\t      && ! null_ptr_cst_p (rhs))\n \t    {\n \t      if (coder == RECORD_TYPE)\n \t\tcp_pedwarn (\"implicit conversion of signature pointer to type `%T'\",\n@@ -6545,9 +6581,8 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n \t  else\n \t    cp_pedwarn (\"%s to `%T' from `%T' lacks a cast\",\n \t\t\terrtype, type, rhstype);\n-\t  return convert (type, rhs);\n \t}\n-      return null_pointer_node;\n+      return convert (type, rhs);\n     }\n   else if (codel == INTEGER_TYPE\n \t   && (coder == POINTER_TYPE"}]}