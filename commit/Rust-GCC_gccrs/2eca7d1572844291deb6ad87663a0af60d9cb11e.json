{"sha": "2eca7d1572844291deb6ad87663a0af60d9cb11e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmVjYTdkMTU3Mjg0NDI5MWRlYjZhZDg3NjYzYTBhZjYwZDljYjExZQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2005-09-25T05:28:01Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-09-25T05:28:01Z"}, "message": "ipa-type-escape.c (discover_unique_type): Remove dead code at end of function.\n\n        * ipa-type-escape.c (discover_unique_type): Remove dead code at\n        end of function.  Reindent.\n\nFrom-SVN: r104619", "tree": {"sha": "77c7e00f6a87960819cbeef1a79252ed9a01decd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/77c7e00f6a87960819cbeef1a79252ed9a01decd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2eca7d1572844291deb6ad87663a0af60d9cb11e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2eca7d1572844291deb6ad87663a0af60d9cb11e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2eca7d1572844291deb6ad87663a0af60d9cb11e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2eca7d1572844291deb6ad87663a0af60d9cb11e/comments", "author": null, "committer": null, "parents": [{"sha": "1f6f3d15c62ea39da28c60064ffd61e0eb87abc5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f6f3d15c62ea39da28c60064ffd61e0eb87abc5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f6f3d15c62ea39da28c60064ffd61e0eb87abc5"}], "stats": {"total": 101, "additions": 53, "deletions": 48}, "files": [{"sha": "dd5d399f9862bf333eedc2f7bed9aadccfbdf850", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eca7d1572844291deb6ad87663a0af60d9cb11e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eca7d1572844291deb6ad87663a0af60d9cb11e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2eca7d1572844291deb6ad87663a0af60d9cb11e", "patch": "@@ -1,3 +1,8 @@\n+2005-09-24  Richard Henderson  <rth@redhat.com>\n+\n+\t* ipa-type-escape.c (discover_unique_type): Remove dead code at\n+\tend of function.  Reindent.\n+\n 2005-09-24  Ian Lance Taylor  <ian@airs.com>\n \n \t* convert.c (convert_to_integer): Don't test for ENUMERAL_TYPE in"}, {"sha": "a06bb1d4040a2c9d626bacf106c3fb7ffd98f48f", "filename": "gcc/ipa-type-escape.c", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eca7d1572844291deb6ad87663a0af60d9cb11e/gcc%2Fipa-type-escape.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eca7d1572844291deb6ad87663a0af60d9cb11e/gcc%2Fipa-type-escape.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-type-escape.c?ref=2eca7d1572844291deb6ad87663a0af60d9cb11e", "patch": "@@ -200,57 +200,57 @@ compare_type_brand (splay_tree_key sk1, splay_tree_key sk2)\n static tree\n discover_unique_type (tree type)\n {\n-  struct type_brand_s * brand = xmalloc(sizeof(struct type_brand_s));\n+  struct type_brand_s * brand = xmalloc (sizeof (struct type_brand_s));\n   int i = 0;\n   splay_tree_node result;\n-  \n+\n+  brand->name = get_name_of_type (type);\n+\n   while (1)\n-  {\n-    brand->name = get_name_of_type (type);\n-    brand->seq = i;\n-    result = splay_tree_lookup (all_canon_types, (splay_tree_key) brand);\n-    if (result)\n-      {\n-\t/* Create an alias since this is just the same as\n-\t   other_type.  */\n-\ttree other_type = (tree) result->value;\n-\tif (lang_hooks.types_compatible_p (type, other_type) == 1)\n-\t  {\n-\t    free (brand);\n-\t    /* Insert this new type as an alias for other_type.  */\n-\t    splay_tree_insert (type_to_canon_type, \n-\t\t\t       (splay_tree_key) type,\n-\t\t\t       (splay_tree_value) other_type);\n-\t    return other_type;\n-\t  }\n-\t/* Not compatible, look for next instance with same name.  */\n-      }\n-    else \n-      {\n-\t/* No more instances, create new one since this is the first\n-\t   time we saw this type.  */\n-\tbrand->seq = i++;\n-\t/* Insert the new brand.  */\n-\tsplay_tree_insert (all_canon_types, \n-\t\t\t   (splay_tree_key) brand,\n-\t\t\t   (splay_tree_value) type);\t  \n-\t\n-\t/* Insert this new type as an alias for itself.  */\n-\tsplay_tree_insert (type_to_canon_type, \n-\t\t\t   (splay_tree_key) type,\n-\t\t\t   (splay_tree_value) type);\n-\n-\t/* Insert the uid for reverse lookup; */\n-\tsplay_tree_insert (uid_to_canon_type, \n-\t\t\t   (splay_tree_key) TYPE_UID (type),\n-\t\t\t   (splay_tree_value) type);\t  \n-\n-\tbitmap_set_bit (global_types_seen, TYPE_UID (type));\n-\treturn type;\n-      }\n-    i++;\n-  } \n-  free (brand);\n+    {\n+      brand->seq = i++;\n+      result = splay_tree_lookup (all_canon_types, (splay_tree_key) brand);\n+\n+      if (result)\n+\t{\n+\t  /* Create an alias since this is just the same as\n+\t     other_type.  */\n+\t  tree other_type = (tree) result->value;\n+\t  if (lang_hooks.types_compatible_p (type, other_type) == 1)\n+\t    {\n+\t      free (brand);\n+\t      /* Insert this new type as an alias for other_type.  */\n+\t      splay_tree_insert (type_to_canon_type,\n+\t\t\t\t (splay_tree_key) type,\n+\t\t\t\t (splay_tree_value) other_type);\n+\t      return other_type;\n+\t    }\n+\t  /* Not compatible, look for next instance with same name.  */\n+\t}\n+      else\n+\t{\n+\t  /* No more instances, create new one since this is the first\n+\t     time we saw this type.  */\n+\t  brand->seq = i++;\n+\t  /* Insert the new brand.  */\n+\t  splay_tree_insert (all_canon_types,\n+\t\t\t     (splay_tree_key) brand,\n+\t\t\t     (splay_tree_value) type);\n+\n+\t  /* Insert this new type as an alias for itself.  */\n+\t  splay_tree_insert (type_to_canon_type,\n+\t\t\t     (splay_tree_key) type,\n+\t\t\t     (splay_tree_value) type);\n+\n+\t  /* Insert the uid for reverse lookup; */\n+\t  splay_tree_insert (uid_to_canon_type,\n+\t\t\t     (splay_tree_key) TYPE_UID (type),\n+\t\t\t     (splay_tree_value) type);\n+\n+\t  bitmap_set_bit (global_types_seen, TYPE_UID (type));\n+\t  return type;\n+\t}\n+    }\n }\n \n /* Return true if TYPE is one of the type classes that we are willing"}]}