{"sha": "2c3199bc4a271157f3cdfb71b3de714004c21ee1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmMzMTk5YmM0YTI3MTE1N2YzY2RmYjcxYjNkZTcxNDAwNGMyMWVlMQ==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1999-03-15T13:09:44Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1999-03-15T13:09:44Z"}, "message": "class.c (make_class): Don't set CLASS_P here (because this function is also called by...\n\nd\n\t* class.c (make_class):  Don't set CLASS_P here (because\n\tthis function is also called by build_java_array_type).\n\t(push_class):  Set CLASS_P here instead.\n\t* parse.h (TYPE_CLASS_P):  Check for TYPE_ARRAY_P is redundant.\n\t* jcf-dump.c (print_access_flags):  Take extra parameter to indicate\n\tcontext.  If the context is class, perfer \"super\" over \"synchronized\".\n\t* jcf-write.c (generate_classfile):  Don't add ACC_SUPER if interface.\n\t* parse.y (create_class):  Don't call parser_check_super here;\n\tit is not robust.  Always wait until later.\n\t* parse.y (method_header):  For interfaces, set ACC_ABSTRACT (to\n\tmatch what JDK 1.2 does), but don't set ACC_PUBLIC.\n\nFrom-SVN: r25784", "tree": {"sha": "1e599bb20fca228f28e09640dffe0689ba351ff6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1e599bb20fca228f28e09640dffe0689ba351ff6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c3199bc4a271157f3cdfb71b3de714004c21ee1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c3199bc4a271157f3cdfb71b3de714004c21ee1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c3199bc4a271157f3cdfb71b3de714004c21ee1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c3199bc4a271157f3cdfb71b3de714004c21ee1/comments", "author": null, "committer": null, "parents": [{"sha": "2728f622015ae0cfdf0461cdc894e6b8745fa708", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2728f622015ae0cfdf0461cdc894e6b8745fa708", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2728f622015ae0cfdf0461cdc894e6b8745fa708"}], "stats": {"total": 53, "additions": 21, "deletions": 32}, "files": [{"sha": "eaf07cdc91f058371f3f1c0a6161d00b491acca3", "filename": "gcc/java/jcf-dump.c", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c3199bc4a271157f3cdfb71b3de714004c21ee1/gcc%2Fjava%2Fjcf-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c3199bc4a271157f3cdfb71b3de714004c21ee1/gcc%2Fjava%2Fjcf-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-dump.c?ref=2c3199bc4a271157f3cdfb71b3de714004c21ee1", "patch": "@@ -77,7 +77,7 @@ int class_access_flags = 0;\n /* Print in format similar to javap.  VERY IMCOMPLETE. */\n int flag_javap_compatible = 0;\n \n-static int print_access_flags PROTO ((FILE *, uint16));\n+static int print_access_flags PROTO ((FILE *, uint16, char));\n static void print_constant_terse PROTO ((FILE*, JCF*, int, int));\n static void print_constant PROTO ((FILE *, JCF *, int, int));\n static void print_constant_ref PROTO ((FILE *, JCF *, int));\n@@ -127,7 +127,7 @@ DEFUN(utf8_equal_string, (jcf, index, value),\n   class_access_flags = ACCESS_FLAGS; \\\n   if (flag_print_class_info) \\\n     { fprintf (out, \"\\nAccess flags: 0x%x\", ACCESS_FLAGS); \\\n-      print_access_flags (out, ACCESS_FLAGS); \\\n+      print_access_flags (out, ACCESS_FLAGS, 'c'); \\\n       fputc ('\\n', out); \\\n       fprintf (out, \"This class: \"); \\\n       if (flag_print_constant_pool) \\\n@@ -163,7 +163,7 @@ DEFUN(utf8_equal_string, (jcf, index, value),\n   if (flag_print_fields) \\\n     { fprintf (out, \"Field name:\"); \\\n       print_constant_terse (out, jcf, NAME, CONSTANT_Utf8); \\\n-      print_access_flags (out, ACCESS_FLAGS); \\\n+      print_access_flags (out, ACCESS_FLAGS, 'f'); \\\n       fprintf (out, \" Signature: \"); \\\n       if (flag_print_constant_pool) \\\n         fprintf (out, \"%d=\", SIGNATURE); \\\n@@ -194,7 +194,7 @@ DEFUN(utf8_equal_string, (jcf, index, value),\n       if (flag_javap_compatible) \\\n         { \\\n \t  fprintf (out, \"    \"); \\\n-\t  print_access_flags (out, ACCESS_FLAGS); \\\n+\t  print_access_flags (out, ACCESS_FLAGS, 'm'); \\\n \t  fputc (' ', out); \\\n \t  print_signature (out, jcf, SIGNATURE, PRINT_SIGNATURE_RESULT_ONLY); \\\n \t  fputc (' ', out); \\\n@@ -206,7 +206,7 @@ DEFUN(utf8_equal_string, (jcf, index, value),\n \t{ \\\n \t  fprintf (out, \"\\nMethod name:\"); \\\n \t  print_constant_terse (out, jcf, NAME, CONSTANT_Utf8); \\\n-\t  print_access_flags (out, ACCESS_FLAGS); \\\n+\t  print_access_flags (out, ACCESS_FLAGS, 'm'); \\\n \t  fprintf (out, \" Signature: \"); \\\n \t  if (flag_print_constant_pool) \\\n \t    fprintf (out, \"%d=\", SIGNATURE); \\\n@@ -305,16 +305,24 @@ DEFUN(print_constant_ref, (stream, jcf, index),\n   fprintf (stream, \">\");\n }\n \n+/* Print the access flags given by FLAGS.\n+   The CONTEXT is one of 'c' (class flags), 'f' (field flags),\n+   or 'm' (method flags). */\n+\n static int\n-DEFUN (print_access_flags, (stream, flags),\n-       FILE *stream AND uint16 flags)\n+DEFUN (print_access_flags, (stream, flags, context),\n+       FILE *stream AND uint16 flags AND char context)\n {\n   if (flags & ACC_PUBLIC) fprintf (stream, \" public\");\n   if (flags & ACC_PRIVATE) fprintf (stream, \" private\");\n   if (flags & ACC_PROTECTED) fprintf (stream, \" protected\");\n   if (flags & ACC_STATIC) fprintf (stream, \" static\");\n   if (flags & ACC_FINAL) fprintf (stream, \" final\");\n-  if (flags & ACC_SYNCHRONIZED) fprintf (stream, \" synchronized\");\n+  if (flags & ACC_SYNCHRONIZED)\n+    if (context == 'c')\n+      fprintf (stream, \" super\");\n+    else\n+      fprintf (stream, \" synchronized\");\n   if (flags & ACC_VOLATILE) fprintf (stream, \" volatile\");\n   if (flags & ACC_TRANSIENT) fprintf (stream, \" transient\");\n   if (flags & ACC_NATIVE) fprintf (stream, \" native\");"}, {"sha": "63e666202ac93a8bc179c5bf05b1570ee3d0acc9", "filename": "gcc/java/parse.c", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c3199bc4a271157f3cdfb71b3de714004c21ee1/gcc%2Fjava%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c3199bc4a271157f3cdfb71b3de714004c21ee1/gcc%2Fjava%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.c?ref=2c3199bc4a271157f3cdfb71b3de714004c21ee1", "patch": "@@ -5593,17 +5593,8 @@ create_class (flags, id, super, interfaces)\n \t  return NULL_TREE;\n \t}\n \n-      /* The class is known and exists if there is a decl. Otherwise,\n-         postpone the operation and do it later. */\n-      super_decl = IDENTIFIER_CLASS_VALUE (EXPR_WFL_NODE (super));\n-      if (super_decl)\n-\t{\n-\t  parser_check_super (super_decl, decl, id);\n-\t  super_decl_type = TREE_TYPE (super_decl);\n-\t}\n-      else\n-\tsuper_decl_type = \n-\t  register_incomplete_type (JDEP_SUPER, super, decl, NULL_TREE);\n+      super_decl_type = \n+\tregister_incomplete_type (JDEP_SUPER, super, decl, NULL_TREE);\n     }\n   else if (TREE_TYPE (decl) != object_type_node)\n     super_decl_type = object_type_node;"}, {"sha": "f59c4ca4b420866f3304119a9ead080c614d6a44", "filename": "gcc/java/parse.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c3199bc4a271157f3cdfb71b3de714004c21ee1/gcc%2Fjava%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c3199bc4a271157f3cdfb71b3de714004c21ee1/gcc%2Fjava%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.h?ref=2c3199bc4a271157f3cdfb71b3de714004c21ee1", "patch": "@@ -208,8 +208,7 @@ extern tree stabilize_reference PROTO ((tree));\n   (CLASS_P (TYPE) && CLASS_INTERFACE (TYPE_NAME (TYPE)))\n \n #define TYPE_CLASS_P(TYPE) (CLASS_P (TYPE) \t\t\t\t\\\n-\t\t\t    && !CLASS_INTERFACE (TYPE_NAME (TYPE))\t\\\n-\t\t\t    && !TYPE_ARRAY_P (TYPE))\n+\t\t\t    && !CLASS_INTERFACE (TYPE_NAME (TYPE)))\n \n /* Standard error messages */\n #define ERROR_CANT_CONVERT_TO_BOOLEAN(OPERATOR, NODE, TYPE)\t\t\\"}, {"sha": "75ffbc3cc6170092e0f778abb617b4a8c73d8a50", "filename": "gcc/java/parse.y", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c3199bc4a271157f3cdfb71b3de714004c21ee1/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c3199bc4a271157f3cdfb71b3de714004c21ee1/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=2c3199bc4a271157f3cdfb71b3de714004c21ee1", "patch": "@@ -2991,17 +2991,8 @@ create_class (flags, id, super, interfaces)\n \t  return NULL_TREE;\n \t}\n \n-      /* The class is known and exists if there is a decl. Otherwise,\n-         postpone the operation and do it later. */\n-      super_decl = IDENTIFIER_CLASS_VALUE (EXPR_WFL_NODE (super));\n-      if (super_decl)\n-\t{\n-\t  parser_check_super (super_decl, decl, id);\n-\t  super_decl_type = TREE_TYPE (super_decl);\n-\t}\n-      else\n-\tsuper_decl_type = \n-\t  register_incomplete_type (JDEP_SUPER, super, decl, NULL_TREE);\n+      super_decl_type = \n+\tregister_incomplete_type (JDEP_SUPER, super, decl, NULL_TREE);\n     }\n   else if (TREE_TYPE (decl) != object_type_node)\n     super_decl_type = object_type_node;"}]}