{"sha": "1bf296437b0a3361c2b005c03204c16b3f0de234", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWJmMjk2NDM3YjBhMzM2MWMyYjAwNWMwMzIwNGMxNmIzZjBkZTIzNA==", "commit": {"author": {"name": "Andy Hutchinson", "email": "hutchinsonandy@aim.com", "date": "2008-06-02T22:08:25Z"}, "committer": {"name": "Andy Hutchinson", "email": "hutchinsonandy@gcc.gnu.org", "date": "2008-06-02T22:08:25Z"}, "message": "re PR target/34879 (__builtin_setjmp / __builtin_longjmp fails stack frame address with O2, O3 and Os)\n\nPR target/34879\n* config/avr/avr.c (TARGET_BUILTIN_SETJMP_FRAME_VALUE): Redefine.\n(avr_builtin_setjmp_frame_value): New function.\n* config/avr/avr.md (nonlocal_goto_receiver): Define.\n(nonlocal_goto): Define.\n\nFrom-SVN: r136297", "tree": {"sha": "ec060fe0e4e74cf60d9c621edb36eea9bcc9c23c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ec060fe0e4e74cf60d9c621edb36eea9bcc9c23c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1bf296437b0a3361c2b005c03204c16b3f0de234", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1bf296437b0a3361c2b005c03204c16b3f0de234", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1bf296437b0a3361c2b005c03204c16b3f0de234", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1bf296437b0a3361c2b005c03204c16b3f0de234/comments", "author": null, "committer": null, "parents": [{"sha": "e62532afd777edea4d3eeb1963060f75952319ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e62532afd777edea4d3eeb1963060f75952319ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e62532afd777edea4d3eeb1963060f75952319ca"}], "stats": {"total": 84, "additions": 83, "deletions": 1}, "files": [{"sha": "56b6ddbb7aac2756e03908dc956cb4561f1f7a27", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bf296437b0a3361c2b005c03204c16b3f0de234/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bf296437b0a3361c2b005c03204c16b3f0de234/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1bf296437b0a3361c2b005c03204c16b3f0de234", "patch": "@@ -1,3 +1,11 @@\n+2008-06-02  Andy Hutchinson  <hutchinsonandy@aim.com> \n+\n+\tPR target/34879\n+\t* config/avr/avr.c (TARGET_BUILTIN_SETJMP_FRAME_VALUE): Redefine.\n+\t(avr_builtin_setjmp_frame_value): New function.\n+\t* config/avr/avr.md (nonlocal_goto_receiver): Define.\n+\t(nonlocal_goto): Define.\n+\n 2008-06-02  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* config/mips/mips.c (mips_emit_loadgp): Return early if"}, {"sha": "405f42f76328b497ca3ab53d492b7ca5b14c91b5", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bf296437b0a3361c2b005c03204c16b3f0de234/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bf296437b0a3361c2b005c03204c16b3f0de234/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=1bf296437b0a3361c2b005c03204c16b3f0de234", "patch": "@@ -83,6 +83,8 @@ static bool avr_rtx_costs (rtx, int, int, int *);\n static int avr_address_cost (rtx);\n static bool avr_return_in_memory (const_tree, const_tree);\n static struct machine_function * avr_init_machine_status (void);\n+static rtx avr_builtin_setjmp_frame_value (void);\n+\n /* Allocate registers from r25 to r8 for parameters for function calls.  */\n #define FIRST_CUM_REG 26\n \n@@ -323,6 +325,9 @@ int avr_case_values_threshold = 30000;\n #undef TARGET_STRICT_ARGUMENT_NAMING\n #define TARGET_STRICT_ARGUMENT_NAMING hook_bool_CUMULATIVE_ARGS_true\n \n+#undef TARGET_BUILTIN_SETJMP_FRAME_VALUE\n+#define TARGET_BUILTIN_SETJMP_FRAME_VALUE avr_builtin_setjmp_frame_value\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n void\n@@ -523,6 +528,17 @@ initial_elimination_offset (int from, int to)\n     }\n }\n \n+/* Actual start of frame is virtual_stack_vars_rtx this is offset from \n+   frame pointer by +STARTING_FRAME_OFFSET.\n+   Using saved frame = virtual_stack_vars_rtx - STARTING_FRAME_OFFSET\n+   avoids creating add/sub of offset in nonlocal goto and setjmp.  */\n+\n+rtx avr_builtin_setjmp_frame_value (void)\n+{\n+  return gen_rtx_MINUS (Pmode, virtual_stack_vars_rtx, \n+\t\t\t gen_int_mode (STARTING_FRAME_OFFSET, Pmode));\n+}\n+\n /* Return 1 if the function epilogue is just a single \"ret\".  */\n \n int"}, {"sha": "0fd371282cc928212aebe86ca8fc73ef69d7b1b0", "filename": "gcc/config/avr/avr.md", "status": "modified", "additions": 59, "deletions": 1, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bf296437b0a3361c2b005c03204c16b3f0de234/gcc%2Fconfig%2Favr%2Favr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bf296437b0a3361c2b005c03204c16b3f0de234/gcc%2Fconfig%2Favr%2Favr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.md?ref=1bf296437b0a3361c2b005c03204c16b3f0de234", "patch": "@@ -58,7 +58,8 @@\n    (UNSPECV_PROLOGUE_SAVES\t0)\n    (UNSPECV_EPILOGUE_RESTORES\t1)\n    (UNSPECV_WRITE_SP_IRQ_ON\t2)\n-   (UNSPECV_WRITE_SP_IRQ_OFF\t3)])\n+   (UNSPECV_WRITE_SP_IRQ_OFF\t3)\n+   (UNSPECV_GOTO_RECEIVER\t4)])\n \n (include \"predicates.md\")\n (include \"constraints.md\")\n@@ -115,6 +116,63 @@\n \t\t       (const_int 2))]\n         (const_int 2)))\n \n+;;========================================================================\n+;; The following is used by nonlocal_goto and setjmp.\n+;; The receiver pattern will create no instructions since internally\n+;; virtual_stack_vars = hard_frame_pointer + 1 so the RTL become R28=R28\n+;; This avoids creating add/sub offsets in frame_pointer save/resore.\n+;; The 'null' receiver also avoids  problems with optimisation\n+;; not recognising incoming jmp and removing code that resets frame_pointer.\n+;; The code derived from builtins.c.\n+\n+(define_expand \"nonlocal_goto_receiver\"\n+  [(set (reg:HI REG_Y) \n+\t(unspec_volatile:HI [(const_int 0)] UNSPECV_GOTO_RECEIVER))]\n+  \"\"\n+  {\n+    emit_move_insn (virtual_stack_vars_rtx, \n+\t\t    gen_rtx_PLUS (Pmode, hard_frame_pointer_rtx, \n+\t\t\t\t  gen_int_mode (STARTING_FRAME_OFFSET,\n+\t\t\t\t\t\tPmode)));\n+  /* This might change the hard frame pointer in ways that aren't\n+    apparent to early optimization passes, so force a clobber.  */\n+    emit_clobber (hard_frame_pointer_rtx);\n+    DONE;\n+  })\n+  \n+\n+;; Defining nonlocal_goto_receiver means we must also define this.\n+;; even though its function is identical to that in builtins.c\n+\n+(define_expand \"nonlocal_goto\"\n+  [\n+  (use (match_operand 0 \"general_operand\"))\n+  (use (match_operand 1 \"general_operand\"))\n+  (use (match_operand 2 \"general_operand\"))\n+  (use (match_operand 3 \"general_operand\"))\n+  ]\n+  \"\"\n+{\n+  rtx r_label = copy_to_reg (operands[1]);\n+  rtx r_fp = operands[3];\n+  rtx r_sp = operands[2];\n+\n+  emit_clobber (gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (VOIDmode)));\n+\n+  emit_clobber (gen_rtx_MEM (BLKmode, hard_frame_pointer_rtx));\n+\n+  emit_move_insn (hard_frame_pointer_rtx, r_fp);\n+  emit_stack_restore (SAVE_NONLOCAL, r_sp, NULL_RTX);\n+\n+  emit_use (hard_frame_pointer_rtx);\n+  emit_use (stack_pointer_rtx);\n+\n+  emit_indirect_jump (r_label);\n+ \n+  DONE;\n+})\n+\n+\n (define_insn \"*pushqi\"\n   [(set (mem:QI (post_dec (reg:HI REG_SP)))\n         (match_operand:QI 0 \"reg_or_0_operand\" \"r,L\"))]"}]}