{"sha": "10dd6dea95c5fc41c789c6506338e101e0590a02", "node_id": "C_kwDOANBUbNoAKDEwZGQ2ZGVhOTVjNWZjNDFjNzg5YzY1MDYzMzhlMTAxZTA1OTBhMDI", "commit": {"author": {"name": "Dimitar Dimitrov", "email": "dimitar@dinux.eu", "date": "2022-08-14T15:50:18Z"}, "committer": {"name": "Dimitar Dimitrov", "email": "dimitar@dinux.eu", "date": "2022-08-22T19:28:58Z"}, "message": "PR target/106564: pru: Optimize 64-bit sign- and zero-extend\n\nAdd new patterns to optimize 64-bit sign- and zero-extend operations for\nthe PRU target.\n\nThe new 64-bit zero-extend patterns are straightforward define_insns.\n\nThe old 16/32-bit sign-extend pattern has been rewritten from scratch\nin order to add 64-bit support.  The new pattern expands into several\noptimized insns for filling bytes with zeros or ones, and for\nconditional branching on bit-test.  The bulk of this patch is to\nimplement the patterns for those new optimized insns.\n\n\tPR target/106564\n\ngcc/ChangeLog:\n\n\t* config/pru/constraints.md (Um): New constraint for -1.\n\t(Uf): New constraint for IOR fill-bytes constants.\n\t(Uz): New constraint for AND zero-bytes constants.\n\t* config/pru/predicates.md (const_fillbytes_operand): New\n\tpredicate for IOR fill-bytes constants.\n\t(const_zerobytes_operand): New predicate for AND zero-bytes\n\tconstants.\n\t* config/pru/pru-protos.h (pru_output_sign_extend): Remove.\n\t(struct pru_byterange): New struct to describe a byte range.\n\t(pru_calc_byterange): New declaration.\n\t* config/pru/pru.cc (pru_rtx_costs): Add penalty for\n\t64-bit zero-extend.\n\t(pru_output_sign_extend): Remove.\n\t(pru_calc_byterange): New helper function to extract byte\n\trange info from a constant.\n\t(pru_print_operand): Remove 'y' and 'z' print modifiers.\n\t* config/pru/pru.md (zero_extendqidi2): New pattern.\n\t(zero_extendhidi2): New pattern.\n\t(zero_extendsidi2): New pattern.\n\t(extend<EQS0:mode><EQD:mode>2): Rewrite as an expand.\n\t(@pru_ior_fillbytes<mode>): New pattern.\n\t(@pru_and_zerobytes<mode>): New pattern.\n\t(<code>di3): Rewrite as an expand and handle ZERO and FILL\n\tspecial cases.\n\t(pru_<code>di3): New name for <code>di3.\n\t(@cbranch_qbbx_const_<BIT_TEST:code><HIDI:mode>): New pattern to\n\thandle bit-test for 64-bit registers.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/pru/pr106564-1.c: New test.\n\t* gcc.target/pru/pr106564-2.c: New test.\n\t* gcc.target/pru/pr106564-3.c: New test.\n\t* gcc.target/pru/pr106564-4.c: New test.\n\nSigned-off-by: Dimitar Dimitrov <dimitar@dinux.eu>", "tree": {"sha": "0b3ae70673e55ab658628ad13e8fb6b3c7eb6ac1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0b3ae70673e55ab658628ad13e8fb6b3c7eb6ac1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10dd6dea95c5fc41c789c6506338e101e0590a02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10dd6dea95c5fc41c789c6506338e101e0590a02", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10dd6dea95c5fc41c789c6506338e101e0590a02", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10dd6dea95c5fc41c789c6506338e101e0590a02/comments", "author": null, "committer": null, "parents": [{"sha": "7e51df048ae849115e12bf12702bdf1b65893be7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e51df048ae849115e12bf12702bdf1b65893be7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e51df048ae849115e12bf12702bdf1b65893be7"}], "stats": {"total": 400, "additions": 338, "deletions": 62}, "files": [{"sha": "99cf39904b440871e2fa89327caa68d929cfac01", "filename": "gcc/config/pru/constraints.md", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10dd6dea95c5fc41c789c6506338e101e0590a02/gcc%2Fconfig%2Fpru%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10dd6dea95c5fc41c789c6506338e101e0590a02/gcc%2Fconfig%2Fpru%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpru%2Fconstraints.md?ref=10dd6dea95c5fc41c789c6506338e101e0590a02", "patch": "@@ -39,6 +39,11 @@\n ;;  N: -32768 to 32767 (16-bit signed integer).\n ;;  O: -128 to 127 (8-bit signed integer).\n ;;  P: 1\n+;;  Um: -1 constant.\n+;;  Uf: A constant with a single consecutive range of 0xff bytes.  Rest\n+;;      of bytes are zeros.\n+;;  Uz: A constant with a single consecutive range of 0x00 bytes.  Rest\n+;;      of bytes are 0xff.\n \n ;; Register constraints.\n \n@@ -111,3 +116,21 @@\n   \"An integer constant zero.\"\n   (and (match_code \"const_int\")\n        (match_test \"ival == 0\")))\n+\n+(define_constraint \"Um\"\n+  \"@internal\n+  A constant -1.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival == -1\")))\n+\n+(define_constraint \"Uf\"\n+  \"@internal\n+  An integer constant with a consecutive range of 0xff bytes.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"const_fillbytes_operand (op, DImode)\")))\n+\n+(define_constraint \"Uz\"\n+  \"@internal\n+  An integer constant with a consecutive range of 0x00 bytes.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"const_zerobytes_operand (op, DImode)\")))"}, {"sha": "a138f70a360c4ea7671a9118146b0e2936626871", "filename": "gcc/config/pru/predicates.md", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10dd6dea95c5fc41c789c6506338e101e0590a02/gcc%2Fconfig%2Fpru%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10dd6dea95c5fc41c789c6506338e101e0590a02/gcc%2Fconfig%2Fpru%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpru%2Fpredicates.md?ref=10dd6dea95c5fc41c789c6506338e101e0590a02", "patch": "@@ -304,3 +304,25 @@\n     }\n   return true;\n })\n+\n+;; Return true if OP is a constant integer with one single consecutive\n+;; range of bytes with value 0xff, and the rest of the bytes are 0x00.\n+(define_predicate \"const_fillbytes_operand\"\n+  (match_code \"const_int\")\n+{\n+  gcc_assert (mode != VOIDmode);\n+\n+  pru_byterange r = pru_calc_byterange (INTVAL (op), mode);\n+  return r.start >=0 && r.nbytes > 0;\n+})\n+\n+;; Return true if OP is a constant integer with one single consecutive\n+;; range of bytes with value 0x00, and the rest of the bytes are 0xff.\n+(define_predicate \"const_zerobytes_operand\"\n+  (match_code \"const_int\")\n+{\n+  gcc_assert (mode != VOIDmode);\n+\n+  pru_byterange r = pru_calc_byterange (~INTVAL (op), mode);\n+  return r.start >=0 && r.nbytes > 0;\n+})"}, {"sha": "4b190c98206481c7e51aaff35a35516233d8c25b", "filename": "gcc/config/pru/pru-protos.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10dd6dea95c5fc41c789c6506338e101e0590a02/gcc%2Fconfig%2Fpru%2Fpru-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10dd6dea95c5fc41c789c6506338e101e0590a02/gcc%2Fconfig%2Fpru%2Fpru-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpru%2Fpru-protos.h?ref=10dd6dea95c5fc41c789c6506338e101e0590a02", "patch": "@@ -40,7 +40,14 @@ void pru_register_pragmas (void);\n extern rtx pru_get_return_address (int);\n extern int pru_hard_regno_rename_ok (unsigned int, unsigned int);\n \n-extern const char *pru_output_sign_extend (rtx *);\n+struct pru_byterange {\n+    int start;\t\t/* Starting byte number.  */\n+    int nbytes;\t\t/* Number of consecutive bytes.  */\n+};\n+\n+extern pru_byterange pru_calc_byterange (HOST_WIDE_INT cval,\n+\t\t\t\t\t      machine_mode mode);\n+\n extern const char *pru_output_signed_cbranch (rtx *, bool);\n extern const char *pru_output_signed_cbranch_ubyteop2 (rtx *, bool);\n extern const char *pru_output_signed_cbranch_zeroop2 (rtx *, bool);"}, {"sha": "04eca90b255cdd96940233a004c8473946feaba9", "filename": "gcc/config/pru/pru.cc", "status": "modified", "additions": 49, "deletions": 51, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10dd6dea95c5fc41c789c6506338e101e0590a02/gcc%2Fconfig%2Fpru%2Fpru.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10dd6dea95c5fc41c789c6506338e101e0590a02/gcc%2Fconfig%2Fpru%2Fpru.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpru%2Fpru.cc?ref=10dd6dea95c5fc41c789c6506338e101e0590a02", "patch": "@@ -766,7 +766,11 @@ pru_rtx_costs (rtx x, machine_mode mode,\n       }\n     case ZERO_EXTEND:\n       {\n-\t*total = COSTS_N_INSNS (0);\n+\t/* 64-bit zero extensions actually have a cost because they\n+\t   require setting a register to zero.\n+\t   32-bit and smaller are free.  */\n+\tint factor = (GET_MODE_SIZE (mode) <= GET_MODE_SIZE (SImode)) ? 0 : 1;\n+\t*total = factor * COSTS_N_INSNS (1);\n \treturn false;\n       }\n \n@@ -970,39 +974,55 @@ sign_bit_position (const rtx op)\n   return sz * 8 - 1;\n }\n \n-/* Output asm code for sign_extend operation.  */\n-const char *\n-pru_output_sign_extend (rtx *operands)\n-{\n-  static char buf[512];\n-  int bufi;\n-  const int dst_sz = GET_MODE_SIZE (GET_MODE (operands[0]));\n-  const int src_sz = GET_MODE_SIZE (GET_MODE (operands[1]));\n-  char ext_start;\n+/* Parse the given CVAL integer value, and extract the \"filling\" byte\n+   range of consecutive 0xff byte values.  Rest of bytes must be 0x00.\n+   There must be only one range in the given value.  This range would\n+   typically be used to calculate the parameters of\n+   PRU instructions ZERO and FILL.\n \n-  switch (src_sz)\n-    {\n-    case 1: ext_start = 'y'; break;\n-    case 2: ext_start = 'z'; break;\n-    default: gcc_unreachable ();\n-    }\n+   The parameter MODE determines the maximum byte range to consider\n+   in the given input constant.\n \n-  gcc_assert (dst_sz > src_sz);\n+   Example input:\n+     cval = 0xffffffffffffff00 = -256\n+     mode = SImode\n+   Return value:\n+     start = 1\n+     nbytes = 3\n \n-  /* Note that src and dst can be different parts of the same\n-     register, e.g. \"r7, r7.w1\".  */\n-  bufi = snprintf (buf, sizeof (buf),\n-\t  \"mov\\t%%0, %%1\\n\\t\"\t\t      /* Copy AND make positive.  */\n-\t  \"qbbc\\t.+8, %%0, %d\\n\\t\"\t      /* Check sign bit.  */\n-\t  \"fill\\t%%%c0, %d\",\t\t      /* Make negative.  */\n-\t  sign_bit_position (operands[1]),\n-\t  ext_start,\n-\t  dst_sz - src_sz);\n+   On error, return a range with -1 for START and NBYTES.  */\n+pru_byterange\n+pru_calc_byterange (HOST_WIDE_INT cval, machine_mode mode)\n+{\n+  const pru_byterange invalid_range = { -1, -1 };\n+  pru_byterange r = invalid_range;\n+  enum { ST_FFS, ST_INRANGE, ST_TRAILING_ZEROS } st = ST_FFS;\n+  int i;\n \n-  gcc_assert (bufi > 0);\n-  gcc_assert ((unsigned int) bufi < sizeof (buf));\n+  for (i = 0; i < GET_MODE_SIZE (mode); i++)\n+    {\n+      const int b = cval & ((1U << BITS_PER_UNIT) - 1);\n+      cval >>= BITS_PER_UNIT;\n+\n+      if (b == 0x00 && (st == ST_FFS || st == ST_TRAILING_ZEROS))\n+\t/* No action.  */;\n+      else if (b == 0x00 && st == ST_INRANGE)\n+\tst = ST_TRAILING_ZEROS;\n+      else if (b == 0xff && st == ST_FFS)\n+\t{\n+\t  st = ST_INRANGE;\n+\t  r.start = i;\n+\t  r.nbytes = 1;\n+\t}\n+      else if (b == 0xff && st == ST_INRANGE)\n+\tr.nbytes++;\n+      else\n+\treturn invalid_range;\n+    }\n \n-  return buf;\n+  if (st != ST_TRAILING_ZEROS && st != ST_INRANGE)\n+    return invalid_range;\n+  return r;\n }\n \f\n /* Branches and compares.  */\n@@ -1619,8 +1639,6 @@ pru_asm_regname (rtx op)\n      V: print exact_log2 () of negated const_int operands.\n      w: Lower 32-bits of a const_int operand.\n      W: Upper 32-bits of a const_int operand.\n-     y: print the next 8-bit register (regardless of op size).\n-     z: print the second next 8-bit register (regardless of op size).\n */\n static void\n pru_print_operand (FILE *file, rtx op, int letter)\n@@ -1693,26 +1711,6 @@ pru_print_operand (FILE *file, rtx op, int letter)\n \t  fprintf (file, \"r%d\", REGNO (op) / 4 + (letter == 'N' ? 1 : 0));\n \t  return;\n \t}\n-      else if (letter == 'y')\n-\t{\n-\t  if (REGNO (op) > LAST_NONIO_GP_REGNUM - 1)\n-\t    {\n-\t      output_operand_lossage (\"invalid operand for '%%%c'\", letter);\n-\t      return;\n-\t    }\n-\t  fprintf (file, \"%s\", reg_names[REGNO (op) + 1]);\n-\t  return;\n-\t}\n-      else if (letter == 'z')\n-\t{\n-\t  if (REGNO (op) > LAST_NONIO_GP_REGNUM - 2)\n-\t    {\n-\t      output_operand_lossage (\"invalid operand for '%%%c'\", letter);\n-\t      return;\n-\t    }\n-\t  fprintf (file, \"%s\", reg_names[REGNO (op) + 2]);\n-\t  return;\n-\t}\n       break;\n \n     case CONST_INT:"}, {"sha": "031109236d6575371e73070bdafea767e9214f9f", "filename": "gcc/config/pru/pru.md", "status": "modified", "additions": 200, "deletions": 10, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10dd6dea95c5fc41c789c6506338e101e0590a02/gcc%2Fconfig%2Fpru%2Fpru.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10dd6dea95c5fc41c789c6506338e101e0590a02/gcc%2Fconfig%2Fpru%2Fpru.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpru%2Fpru.md?ref=10dd6dea95c5fc41c789c6506338e101e0590a02", "patch": "@@ -112,12 +112,14 @@\n (define_mode_iterator MOV64 [DI DF DD DQ UDQ])\n (define_mode_iterator QISI [QI HI SI])\n (define_mode_iterator HISI [HI SI])\n+(define_mode_iterator HIDI [HI SI DI])\n (define_mode_iterator SFDF [SF DF])\n \n ;; EQS0/1 for extension source 0/1 and EQD for extension destination patterns.\n (define_mode_iterator EQS0 [QI HI SI])\n (define_mode_iterator EQS1 [QI HI SI])\n (define_mode_iterator EQD [QI HI SI])\n+(define_mode_iterator EQDHIDI [HI SI DI])\n \n ;; GCC sign-extends its integer constants.  Hence 0x80 will be represented\n ;; as -128 for QI mode and 128 for HI and SI modes.  To cope with this,\n@@ -415,18 +417,68 @@\n   \"mov\\\\t%0, %1\"\n   [(set_attr \"type\"     \"alu\")])\n \n-;; Sign extension patterns.  We have to emulate them due to lack of\n+(define_insn \"zero_extendqidi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n+\t(zero_extend:DI (match_operand:QI 1 \"register_operand\" \"0,r\")))]\n+  \"\"\n+  \"@\n+    zero\\\\t%F0.b1, 7\n+    mov\\\\t%F0.b0, %1\\;zero\\\\t%F0.b1, 7\"\n+  [(set_attr \"type\" \"alu,alu\")\n+   (set_attr \"length\" \"4,8\")])\n+\n+(define_insn \"zero_extendhidi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n+\t(zero_extend:DI (match_operand:HI 1 \"register_operand\" \"0,r\")))]\n+  \"\"\n+  \"@\n+    zero\\\\t%F0.b2, 6\n+    mov\\\\t%F0.w0, %1\\;zero\\\\t%F0.b2, 6\"\n+  [(set_attr \"type\" \"alu,alu\")\n+   (set_attr \"length\" \"4,8\")])\n+\n+(define_insn \"zero_extendsidi2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n+\t(zero_extend:DI (match_operand:SI 1 \"register_operand\" \"0,r\")))]\n+  \"\"\n+  \"@\n+    zero\\\\t%N0, 4\n+    mov\\\\t%F0, %1\\;zero\\\\t%N0, 4\"\n+  [(set_attr \"type\" \"alu,alu\")\n+   (set_attr \"length\" \"4,8\")])\n+\n+;; Sign extension pattern.  We have to emulate it due to lack of\n ;; signed operations in PRU's ALU.\n \n-(define_insn \"extend<EQS0:mode><EQD:mode>2\"\n-  [(set (match_operand:EQD 0 \"register_operand\"\t\t\t  \"=r\")\n-\t(sign_extend:EQD (match_operand:EQS0 1 \"register_operand\"  \"r\")))]\n+(define_expand \"extend<EQS0:mode><EQDHIDI:mode>2\"\n+  [(set (match_operand:EQDHIDI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:EQDHIDI (match_operand:EQS0 1 \"register_operand\" \"r\")))]\n   \"\"\n {\n-  return pru_output_sign_extend (operands);\n-}\n-  [(set_attr \"type\" \"complex\")\n-   (set_attr \"length\" \"12\")])\n+  rtx_code_label *skip_hiset_label;\n+\n+  /* Clear the higher bits to temporarily make the value positive.  */\n+  emit_insn (gen_rtx_SET (operands[0],\n+\t\t\t  gen_rtx_ZERO_EXTEND (<EQDHIDI:MODE>mode,\n+\t\t\t\t\t       operands[1])));\n+\n+  /* Now check if the result must be made negative.  */\n+  skip_hiset_label = gen_label_rtx ();\n+  const int op1_size = GET_MODE_SIZE (<EQS0:MODE>mode);\n+  const int op1_sign_bit = op1_size * BITS_PER_UNIT - 1;\n+  emit_jump_insn (gen_cbranch_qbbx_const (EQ,\n+\t\t\t\t\t  <EQDHIDI:MODE>mode,\n+\t\t\t\t\t  operands[0],\n+\t\t\t\t\t  GEN_INT (op1_sign_bit),\n+\t\t\t\t\t  skip_hiset_label));\n+  emit_insn (gen_ior<EQDHIDI:mode>3 (\n+\t\t\t operands[0],\n+\t\t\t operands[0],\n+\t\t\t GEN_INT (~GET_MODE_MASK (<EQS0:MODE>mode))));\n+  emit_label (skip_hiset_label);\n+\n+  DONE;\n+})\n \f\n ;; Bit extraction\n ;; We define it solely to allow combine to choose SImode\n@@ -518,6 +570,51 @@\n   \"\"\n   \"\")\n \n+;; Specialised IOR pattern, which can emit an efficient FILL instruction.\n+(define_insn \"@pru_ior_fillbytes<mode>\"\n+  [(set (match_operand:HIDI 0 \"register_operand\" \"=r\")\n+\t(ior:HIDI\n+\t   (match_operand:HIDI 1 \"register_operand\" \"0\")\n+\t   (match_operand:HIDI 2 \"const_fillbytes_operand\" \"Uf\")))]\n+  \"\"\n+{\n+  static char line[64];\n+  pru_byterange r;\n+\n+  r = pru_calc_byterange (INTVAL (operands[2]), <MODE>mode);\n+  gcc_assert (r.start >=0 && r.nbytes > 0);\n+  gcc_assert ((r.start + r.nbytes) <= GET_MODE_SIZE (<MODE>mode));\n+\n+  const int regno = REGNO (operands[0]) + r.start;\n+\n+  sprintf (line, \"fill\\\\tr%d.b%d, %d\", regno / 4, regno % 4, r.nbytes);\n+  return line;\n+}\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"length\" \"4\")])\n+\n+;; Specialised AND pattern, which can emit an efficient ZERO instruction.\n+(define_insn \"@pru_and_zerobytes<mode>\"\n+  [(set (match_operand:HIDI 0 \"register_operand\" \"=r\")\n+\t(and:HIDI\n+\t   (match_operand:HIDI 1 \"register_operand\" \"0\")\n+\t   (match_operand:HIDI 2 \"const_zerobytes_operand\" \"Uz\")))]\n+  \"\"\n+{\n+  static char line[64];\n+  pru_byterange r;\n+\n+  r = pru_calc_byterange (~INTVAL (operands[2]), <MODE>mode);\n+  gcc_assert (r.start >=0 && r.nbytes > 0);\n+  gcc_assert ((r.start + r.nbytes) <= GET_MODE_SIZE (<MODE>mode));\n+\n+  const int regno = REGNO (operands[0]) + r.start;\n+\n+  sprintf (line, \"zero\\\\tr%d.b%d, %d\", regno / 4, regno % 4, r.nbytes);\n+  return line;\n+}\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"length\" \"4\")])\n \f\n ;;  Shift instructions\n \n@@ -641,7 +738,52 @@\n ;; DI logical ops could be automatically split into WORD-mode ops in\n ;; expand_binop().  But then we'll miss an opportunity to use SI mode\n ;; operations, since WORD mode for PRU is QI.\n-(define_insn \"<code>di3\"\n+(define_expand \"<code>di3\"\n+  [(set (match_operand:DI 0 \"register_operand\")\n+\t  (LOGICAL_BITOP:DI\n+\t    (match_operand:DI 1 \"register_operand\")\n+\t    (match_operand:DI 2 \"reg_or_const_int_operand\")))]\n+  \"\"\n+{\n+  /* Try with the more efficient zero/fill patterns first.  */\n+  if (<LOGICAL_BITOP:CODE> == IOR\n+      && CONST_INT_P (operands[2])\n+      && const_fillbytes_operand (operands[2], DImode))\n+    {\n+      rtx insn = maybe_gen_pru_ior_fillbytes (DImode,\n+\t\t\t\t\t      operands[0],\n+\t\t\t\t\t      operands[0],\n+\t\t\t\t\t      operands[2]);\n+      if (insn != nullptr)\n+\t{\n+\t  if (REGNO (operands[0]) != REGNO (operands[1]))\n+\t    emit_move_insn (operands[0], operands[1]);\n+\t  emit_insn (insn);\n+\t  DONE;\n+\t}\n+    }\n+  if (<LOGICAL_BITOP:CODE> == AND\n+      && CONST_INT_P (operands[2])\n+      && const_zerobytes_operand (operands[2], DImode))\n+    {\n+      rtx insn = maybe_gen_pru_and_zerobytes (DImode,\n+\t\t\t\t\t      operands[0],\n+\t\t\t\t\t      operands[0],\n+\t\t\t\t\t      operands[2]);\n+      if (insn != nullptr)\n+\t{\n+\t  if (REGNO (operands[0]) != REGNO (operands[1]))\n+\t    emit_move_insn (operands[0], operands[1]);\n+\t  emit_insn (insn);\n+\t  DONE;\n+\t}\n+    }\n+  /* No optimized case found.  Rely on the two-instruction pattern below.  */\n+  if (!reg_or_ubyte_operand (operands[2], DImode))\n+    operands[2] = force_reg (DImode, operands[2]);\n+})\n+\n+(define_insn \"pru_<code>di3\"\n   [(set (match_operand:DI 0 \"register_operand\"\t\t\"=&r,&r\")\n \t  (LOGICAL_BITOP:DI\n \t    (match_operand:DI 1 \"register_operand\"\t\"%r,r\")\n@@ -653,7 +795,6 @@\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"length\" \"8\")])\n \n-\n (define_insn \"one_cmpldi2\"\n   [(set (match_operand:DI 0 \"register_operand\"\t\t\"=r\")\n \t(not:DI (match_operand:DI 1 \"register_operand\"\t\"r\")))]\n@@ -975,6 +1116,55 @@\n \t       (le (minus (match_dup 2) (pc)) (const_int 2044)))\n \t  (const_int 4)\n \t  (const_int 8)))])\n+\n+;; Bit test conditional branch, but only for constant bit positions.\n+;; This restriction allows an efficient code for DImode operands.\n+;;\n+;; QImode is already handled by the pattern variant above.\n+(define_insn \"@cbranch_qbbx_const_<BIT_TEST:code><HIDI:mode>\"\n+ [(set (pc)\n+   (if_then_else\n+    (BIT_TEST (zero_extract:HIDI\n+\t (match_operand:HIDI 0 \"register_operand\" \"r\")\n+\t (const_int 1)\n+\t (match_operand:VOID 1 \"const_int_operand\" \"i\"))\n+     (const_int 0))\n+    (label_ref (match_operand 2))\n+    (pc)))]\n+  \"\"\n+{\n+  const int length = (get_attr_length (insn));\n+  const bool is_near = (length == 4);\n+\n+  if (<HIDI:MODE>mode == DImode && INTVAL (operands[1]) <= 31)\n+    {\n+      if (is_near)\n+\treturn \"<BIT_TEST:qbbx_op>\\\\t%l2, %F0, %1\";\n+      else\n+\treturn \"<BIT_TEST:qbbx_negop>\\\\t.+8, %F0, %1\\;jmp\\\\t%%label(%l2)\";\n+    }\n+  else if (<HIDI:MODE>mode == DImode)\n+    {\n+      if (is_near)\n+\treturn \"<BIT_TEST:qbbx_op>\\\\t%l2, %N0, %1 - 32\";\n+      else\n+\treturn \"<BIT_TEST:qbbx_negop>\\\\t.+8, %N0, %1 - 32\\;jmp\\\\t%%label(%l2)\";\n+    }\n+  else\n+    {\n+      if (is_near)\n+\treturn \"<BIT_TEST:qbbx_op>\\\\t%l2, %0, %1\";\n+      else\n+\treturn \"<BIT_TEST:qbbx_negop>\\\\t.+8, %0, %1\\;jmp\\\\t%%label(%l2)\";\n+    }\n+}\n+  [(set_attr \"type\" \"control\")\n+   (set (attr \"length\")\n+      (if_then_else\n+\t  (and (ge (minus (match_dup 2) (pc)) (const_int -2048))\n+\t       (le (minus (match_dup 2) (pc)) (const_int 2044)))\n+\t  (const_int 4)\n+\t  (const_int 8)))])\n \f\n ;; ::::::::::::::::::::\n ;; ::"}, {"sha": "26fe2f32478338a142cffb62e73da90d880e2a0f", "filename": "gcc/testsuite/gcc.target/pru/pr106564-1.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10dd6dea95c5fc41c789c6506338e101e0590a02/gcc%2Ftestsuite%2Fgcc.target%2Fpru%2Fpr106564-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10dd6dea95c5fc41c789c6506338e101e0590a02/gcc%2Ftestsuite%2Fgcc.target%2Fpru%2Fpr106564-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpru%2Fpr106564-1.c?ref=10dd6dea95c5fc41c789c6506338e101e0590a02", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do assemble } */\n+/* { dg-options \"-Os\" } */\n+/* { dg-final { object-size text <= 8 } } */\n+\n+\n+unsigned long long test(unsigned char a)\n+{\n+        return a;\n+}"}, {"sha": "297c2ac1ac3b0685cd4c723c7f359c8f04c69af5", "filename": "gcc/testsuite/gcc.target/pru/pr106564-2.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10dd6dea95c5fc41c789c6506338e101e0590a02/gcc%2Ftestsuite%2Fgcc.target%2Fpru%2Fpr106564-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10dd6dea95c5fc41c789c6506338e101e0590a02/gcc%2Ftestsuite%2Fgcc.target%2Fpru%2Fpr106564-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpru%2Fpr106564-2.c?ref=10dd6dea95c5fc41c789c6506338e101e0590a02", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do assemble } */\n+/* { dg-options \"-Os\" } */\n+/* { dg-final { object-size text <= 8 } } */\n+\n+\n+unsigned long long test(unsigned int a)\n+{\n+        return a;\n+}"}, {"sha": "9d71114444e6bc41f79d610cb5a4f306d2557673", "filename": "gcc/testsuite/gcc.target/pru/pr106564-3.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10dd6dea95c5fc41c789c6506338e101e0590a02/gcc%2Ftestsuite%2Fgcc.target%2Fpru%2Fpr106564-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10dd6dea95c5fc41c789c6506338e101e0590a02/gcc%2Ftestsuite%2Fgcc.target%2Fpru%2Fpr106564-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpru%2Fpr106564-3.c?ref=10dd6dea95c5fc41c789c6506338e101e0590a02", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do assemble } */\n+/* { dg-options \"-Os\" } */\n+/* { dg-final { object-size text <= 16 } } */\n+\n+\n+long long test(signed char a)\n+{\n+        return a;\n+}"}, {"sha": "6c1e4fbf964d105b55f9a26e5dbd8abad27d463a", "filename": "gcc/testsuite/gcc.target/pru/pr106564-4.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10dd6dea95c5fc41c789c6506338e101e0590a02/gcc%2Ftestsuite%2Fgcc.target%2Fpru%2Fpr106564-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10dd6dea95c5fc41c789c6506338e101e0590a02/gcc%2Ftestsuite%2Fgcc.target%2Fpru%2Fpr106564-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpru%2Fpr106564-4.c?ref=10dd6dea95c5fc41c789c6506338e101e0590a02", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do assemble } */\n+/* { dg-options \"-Os\" } */\n+/* { dg-final { object-size text <= 16 } } */\n+\n+\n+long long test(int a)\n+{\n+        return a;\n+}"}]}