{"sha": "48f91b442f810e5bae8cd52bf2f84e9c0f43b948", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDhmOTFiNDQyZjgxMGU1YmFlOGNkNTJiZjJmODRlOWMwZjQzYjk0OA==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2010-10-21T10:43:12Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-21T10:43:12Z"}, "message": "einfo.ads, einfo.adb: Add handling of predicates.\n\n2010-10-21  Robert Dewar  <dewar@adacore.com>\n\n\t* einfo.ads, einfo.adb: Add handling of predicates.\n\tRework handling of invariants.\n\t* exp_ch3.adb, exp_ch4.adb, exp_util.adb, sem_ch6.adb: Minor changes to\n\thanding of invariants.\n\t* par-prag.adb: Add dummy entry for pragma Predicate\n\t* sem_ch13.adb (Analyze_Aspect_Specifications): Add processing for\n\tPredicate aspects.\n\t* sem_prag.adb: Add implementation of pragma Predicate.\n\t* snames.ads-tmpl: Add entries for pragma Predicate.\n\n2010-10-21  Robert Dewar  <dewar@adacore.com>\n\n\t* elists.adb: Minor reformatting.\n\nFrom-SVN: r165766", "tree": {"sha": "5512eeac4733915f94ed802b8a68aba0956a37c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5512eeac4733915f94ed802b8a68aba0956a37c7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/48f91b442f810e5bae8cd52bf2f84e9c0f43b948", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48f91b442f810e5bae8cd52bf2f84e9c0f43b948", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48f91b442f810e5bae8cd52bf2f84e9c0f43b948", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48f91b442f810e5bae8cd52bf2f84e9c0f43b948/comments", "author": null, "committer": null, "parents": [{"sha": "c9a410f028b175a6d585bfe103d64a880140148a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9a410f028b175a6d585bfe103d64a880140148a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9a410f028b175a6d585bfe103d64a880140148a"}], "stats": {"total": 808, "additions": 432, "deletions": 376}, "files": [{"sha": "52dc9f27ecfeff57d9f7850dbf7f67c2e8f2abb6", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48f91b442f810e5bae8cd52bf2f84e9c0f43b948/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48f91b442f810e5bae8cd52bf2f84e9c0f43b948/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=48f91b442f810e5bae8cd52bf2f84e9c0f43b948", "patch": "@@ -1,3 +1,25 @@\n+2010-10-21  Robert Dewar  <dewar@adacore.com>\n+\n+\t* checks.ads, checks.adb (Apply_Predicate_Check): New procedure\n+\tMinor code reorganization.\n+\t* einfo.adb (Has_Predicates): Fix assertion.\n+\t* exp_ch13.adb (Build_Predicate_Function): Move from Sem_Ch13 spec to\n+\tExp_Ch13 body.\n+\t(Expand_N_Freeze_Entity): Call build predicate function.\n+\t* exp_ch4.adb (Expand_N_Type_Conversion): Add predicate check.\n+\t* exp_ch5.adb (Expand_N_Assignment_Statement): Add predicate check.\n+\t* exp_prag.adb (Expand_Pragma_Check): Use all lower case for name of\n+\tcheck.\n+\t* freeze.adb (Freeze_Entity): Move building of predicate function to\n+\tExp_Ch13.\n+\t* sem_ch13.adb (Build_Predicate_Function): Move from Sem_Ch13 to\n+\tExp_Ch13.\n+\t* sem_ch13.ads (Build_Predicate_Function): Move from Sem_Ch13 to\n+\tExp_Ch13.\n+\t* sem_ch3.adb (Analyze_Declarations): Remove call to build predicate\n+\tfunction.\n+\t* sem_res.adb (Resolve_Actuals): Apply predicate check.\n+\n 2010-10-21  Robert Dewar  <dewar@adacore.com>\n \n \t* einfo.ads, einfo.adb: Replace Predicate_Procedure by"}, {"sha": "0b783fa6b8262fe21685375a0f81115ecf2aed6f", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48f91b442f810e5bae8cd52bf2f84e9c0f43b948/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48f91b442f810e5bae8cd52bf2f84e9c0f43b948/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=48f91b442f810e5bae8cd52bf2f84e9c0f43b948", "patch": "@@ -997,10 +997,15 @@ package body Checks is\n       Desig_Typ : Entity_Id;\n \n    begin\n+      --  No checks inside a generic (check the instantiations)\n+\n       if Inside_A_Generic then\n          return;\n+      end if;\n+\n+      --  Apply required constaint checks\n \n-      elsif Is_Scalar_Type (Typ) then\n+      if Is_Scalar_Type (Typ) then\n          Apply_Scalar_Range_Check (N, Typ);\n \n       elsif Is_Array_Type (Typ) then\n@@ -1748,6 +1753,20 @@ package body Checks is\n         (Ck_Node, Target_Typ, Source_Typ, Do_Static => False);\n    end Apply_Length_Check;\n \n+   ---------------------------\n+   -- Apply_Predicate_Check --\n+   ---------------------------\n+\n+   procedure Apply_Predicate_Check (N : Node_Id; Typ : Entity_Id) is\n+   begin\n+      if Etype (N) /= Typ\n+        and then Present (Predicate_Function (Typ))\n+      then\n+         Insert_Action (N,\n+           Make_Predicate_Check (Typ, Duplicate_Subexpr (N)));\n+      end if;\n+   end Apply_Predicate_Check;\n+\n    -----------------------\n    -- Apply_Range_Check --\n    -----------------------"}, {"sha": "c544cfe60647849ecc6e79c6929fece6ef04699a", "filename": "gcc/ada/checks.ads", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48f91b442f810e5bae8cd52bf2f84e9c0f43b948/gcc%2Fada%2Fchecks.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48f91b442f810e5bae8cd52bf2f84e9c0f43b948/gcc%2Fada%2Fchecks.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.ads?ref=48f91b442f810e5bae8cd52bf2f84e9c0f43b948", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -134,10 +134,10 @@ package Checks is\n      (N          : Node_Id;\n       Typ        : Entity_Id;\n       No_Sliding : Boolean := False);\n-   --  Top-level procedure, calls all the others depending on the class of Typ.\n-   --  Checks that expression N satisfies the constraint of type Typ.\n-   --  No_Sliding is only relevant for constrained array types, if set to True,\n-   --  it checks that indexes are in range.\n+   --  Top-level procedure, calls all the others depending on the class of\n+   --  Typ. Checks that expression N satisfies the constraint of type Typ.\n+   --  No_Sliding is only relevant for constrained array types, if set to\n+   --  True, it checks that indexes are in range.\n \n    procedure Apply_Discriminant_Check\n      (N   : Node_Id;\n@@ -153,6 +153,11 @@ package Checks is\n    --  formals, the check is peformed only if the corresponding actual is\n    --  constrained, i.e., whether Lhs'Constrained is True.\n \n+   procedure Apply_Predicate_Check (N : Node_Id; Typ : Entity_Id);\n+   --  N is an expression to which a predicate check may need to be applied\n+   --  for Typ, if Typ has a predicate function. The check is applied only\n+   --  if the type of N does not match Typ.\n+\n    function Build_Discriminant_Checks\n      (N     : Node_Id;\n       T_Typ : Entity_Id)"}, {"sha": "96f1e52fe7c3a5b96c173c550f3e48ce8e6cf6dd", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48f91b442f810e5bae8cd52bf2f84e9c0f43b948/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48f91b442f810e5bae8cd52bf2f84e9c0f43b948/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=48f91b442f810e5bae8cd52bf2f84e9c0f43b948", "patch": "@@ -1411,7 +1411,7 @@ package body Einfo is\n \n    function Has_Predicates (Id : E) return B is\n    begin\n-      pragma Assert (Is_Type (Id) or else Ekind (Id) = E_Function);\n+      pragma Assert (Is_Type (Id) or else Is_Subprogram (Id));\n       return Flag250 (Id);\n    end Has_Predicates;\n "}, {"sha": "bee33254b907741850456982125123c5caba7167", "filename": "gcc/ada/exp_ch13.adb", "status": "modified", "additions": 325, "deletions": 0, "changes": 325, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48f91b442f810e5bae8cd52bf2f84e9c0f43b948/gcc%2Fada%2Fexp_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48f91b442f810e5bae8cd52bf2f84e9c0f43b948/gcc%2Fada%2Fexp_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch13.adb?ref=48f91b442f810e5bae8cd52bf2f84e9c0f43b948", "patch": "@@ -26,6 +26,7 @@\n with Atree;    use Atree;\n with Checks;   use Checks;\n with Einfo;    use Einfo;\n+with Elists;   use Elists;\n with Exp_Ch3;  use Exp_Ch3;\n with Exp_Ch6;  use Exp_Ch6;\n with Exp_Imgv; use Exp_Imgv;\n@@ -37,6 +38,8 @@ with Nmake;    use Nmake;\n with Opt;      use Opt;\n with Rtsfind;  use Rtsfind;\n with Sem;      use Sem;\n+with Sem_Aux;  use Sem_Aux;\n+with Sem_Ch3;  use Sem_Ch3;\n with Sem_Ch7;  use Sem_Ch7;\n with Sem_Ch8;  use Sem_Ch8;\n with Sem_Eval; use Sem_Eval;\n@@ -50,6 +53,308 @@ with Validsw;  use Validsw;\n \n package body Exp_Ch13 is\n \n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   procedure Build_Predicate_Function\n+     (Typ   : Entity_Id;\n+      FDecl : out Node_Id;\n+      FBody : out Node_Id);\n+   --  If Typ has predicates (indicated by Has_Predicates being set for Typ,\n+   --  then either there are pragma Invariant entries on the rep chain for the\n+   --  type (note that Predicate aspects are converted to pragam Predicate), or\n+   --  there are inherited aspects from a parent type, or ancestor subtypes,\n+   --  or interfaces. This procedure builds the spec and body for the Predicate\n+   --  function that tests these predicates, returning them in PDecl and Pbody\n+   --  and setting Predicate_Procedure for Typ. In some error situations no\n+   --  procedure is built, in which case PDecl/PBody are empty on return.\n+\n+   ------------------------------\n+   -- Build_Predicate_Function --\n+   ------------------------------\n+\n+   --  The procedure that is constructed here has the form\n+\n+   --  function typPredicate (Ixxx : typ) return Boolean is\n+   --  begin\n+   --     return\n+   --        exp1 and then exp2 and then ...\n+   --        and then typ1Predicate (typ1 (Ixxx))\n+   --        and then typ2Predicate (typ2 (Ixxx))\n+   --        and then ...;\n+   --  end typPredicate;\n+\n+   --  Here exp1, and exp2 are expressions from Predicate pragmas. Note that\n+   --  this is the point at which these expressions get analyzed, providing the\n+   --  required delay, and typ1, typ2, are entities from which predicates are\n+   --  inherited. Note that we do NOT generate Check pragmas, that's because we\n+   --  use this function even if checks are off, e.g. for membership tests.\n+\n+   procedure Build_Predicate_Function\n+     (Typ   : Entity_Id;\n+      FDecl : out Node_Id;\n+      FBody : out Node_Id)\n+   is\n+      Loc  : constant Source_Ptr := Sloc (Typ);\n+      Spec : Node_Id;\n+      SId  : Entity_Id;\n+\n+      Expr : Node_Id;\n+      --  This is the expression for the return statement in the function. It\n+      --  is build by connecting the component predicates with AND THEN.\n+\n+      procedure Add_Call (T : Entity_Id);\n+      --  Includes a call statement to the predicate function for type T in\n+      --  Expr if T has predicates and Predicate_Function (T) is non-empty.\n+\n+      procedure Add_Predicates;\n+      --  Appends expressions for any Predicate pragmas in the rep item chain\n+      --  Typ to Expr. Note that we look only at items for this exact entity.\n+      --  Inheritance of predicates for the parent type is done by calling the\n+      --  Predicate_Function of the parent type, using Add_Call above.\n+\n+      Object_Name : constant Name_Id := New_Internal_Name ('I');\n+      --  Name for argument of Predicate procedure\n+\n+      --------------\n+      -- Add_Call --\n+      --------------\n+\n+      procedure Add_Call (T : Entity_Id) is\n+         Exp : Node_Id;\n+\n+      begin\n+         if Present (T)\n+           and then Present (Predicate_Function (T))\n+         then\n+            Exp :=\n+              Make_Predicate_Call\n+                (T,\n+                 Convert_To (T,\n+                   Make_Identifier (Loc,\n+                     Chars => Object_Name)));\n+\n+            if No (Expr) then\n+               Expr := Exp;\n+            else\n+               Expr :=\n+                 Make_And_Then (Loc,\n+                   Left_Opnd  => Relocate_Node (Expr),\n+                   Right_Opnd => Exp);\n+            end if;\n+         end if;\n+      end Add_Call;\n+\n+      --------------------\n+      -- Add_Predicates --\n+      --------------------\n+\n+      procedure Add_Predicates is\n+         Ritem : Node_Id;\n+         Arg1  : Node_Id;\n+         Arg2  : Node_Id;\n+\n+         function Replace_Node (N : Node_Id) return Traverse_Result;\n+         --  Process single node for traversal to replace type references\n+\n+         procedure Replace_Type is new Traverse_Proc (Replace_Node);\n+         --  Traverse an expression changing every occurrence of an entity\n+         --  reference to type T with a reference to the object argument.\n+\n+         ------------------\n+         -- Replace_Node --\n+         ------------------\n+\n+         function Replace_Node (N : Node_Id) return Traverse_Result is\n+         begin\n+            --  Case of entity name referencing the type\n+\n+            if Is_Entity_Name (N)\n+              and then Entity (N) = Typ\n+            then\n+               --  Replace with object\n+\n+               Rewrite (N,\n+                 Make_Identifier (Loc,\n+                   Chars => Object_Name));\n+\n+               --  All done with this node\n+\n+               return Skip;\n+\n+            --  Not an instance of the type entity, keep going\n+\n+            else\n+               return OK;\n+            end if;\n+         end Replace_Node;\n+\n+      begin\n+         Ritem := First_Rep_Item (Typ);\n+         while Present (Ritem) loop\n+            if Nkind (Ritem) = N_Pragma\n+              and then Pragma_Name (Ritem) = Name_Predicate\n+            then\n+               Arg1 := First (Pragma_Argument_Associations (Ritem));\n+               Arg2 := Next (Arg1);\n+\n+               Arg1 := Get_Pragma_Arg (Arg1);\n+               Arg2 := Get_Pragma_Arg (Arg2);\n+\n+               --  We need to replace any occurrences of the name of the type\n+               --  with references to the object. We do this by first doing a\n+               --  preanalysis, to identify all the entities, then we traverse\n+               --  looking for the type entity, doing the needed substitution.\n+               --  The preanalysis is done with the special OK_To_Reference\n+               --  flag set on the type, so that if we get an occurrence of\n+               --  this type, it will be reognized as legitimate.\n+\n+               Set_OK_To_Reference (Typ, True);\n+               Preanalyze_Spec_Expression (Arg2, Standard_Boolean);\n+               Set_OK_To_Reference (Typ, False);\n+               Replace_Type (Arg2);\n+\n+               --  See if this predicate pragma is for the current type\n+\n+               if Entity (Arg1) = Typ then\n+\n+                  --  We have a match, add the expression\n+\n+                  if No (Expr) then\n+                     Expr := Relocate_Node (Arg2);\n+                  else\n+                     Expr :=\n+                       Make_And_Then (Loc,\n+                         Left_Opnd  => Relocate_Node (Expr),\n+                         Right_Opnd => Relocate_Node (Arg2));\n+                  end if;\n+               end if;\n+            end if;\n+\n+            Next_Rep_Item (Ritem);\n+         end loop;\n+      end Add_Predicates;\n+\n+   --  Start of processing for Build_Predicate_Function\n+\n+   begin\n+      --  Initialize for construction of statement list\n+\n+      Expr := Empty;\n+      FDecl := Empty;\n+      FBody := Empty;\n+\n+      --  Return if already built or if type does not have predicates\n+\n+      if not Has_Predicates (Typ)\n+        or else Present (Predicate_Function (Typ))\n+      then\n+         return;\n+      end if;\n+\n+      --  Add Predicates for the current type\n+\n+      Add_Predicates;\n+\n+      --  Deal with ancestor subtype and parent type\n+\n+      declare\n+         Atyp : constant Entity_Id := Ancestor_Subtype (Typ);\n+\n+      begin\n+         --  If ancestor subtype present, add its predicates\n+\n+         if Present (Atyp) then\n+            Add_Call (Atyp);\n+\n+         --  Else if this is derived, add predicates of parent type\n+\n+         elsif Is_Derived_Type (Typ) then\n+            Add_Call (Etype (Base_Type (Typ)));\n+         end if;\n+      end;\n+\n+      --  Add predicates of any interfaces of a tagged type\n+\n+      if Is_Tagged_Type (Typ) then\n+         declare\n+            Iface_List : Elist_Id;\n+            Elmt       : Elmt_Id;\n+\n+         begin\n+            Collect_Interfaces (Typ, Iface_List);\n+\n+            if Present (Iface_List) then\n+               loop\n+                  Elmt := First_Elmt (Iface_List);\n+                  exit when No (Elmt);\n+                  Add_Call (Node (Elmt));\n+                  Remove_Elmt (Iface_List, Elmt);\n+               end loop;\n+            end if;\n+         end;\n+      end if;\n+\n+      if Present (Expr) then\n+\n+         --  Build function declaration\n+\n+         pragma Assert (Has_Predicates (Typ));\n+         SId :=\n+           Make_Defining_Identifier (Loc,\n+             Chars => New_External_Name (Chars (Typ), \"Predicate\"));\n+         Set_Has_Predicates (SId);\n+         Set_Predicate_Function (Typ, SId);\n+\n+         Spec :=\n+           Make_Function_Specification (Loc,\n+             Defining_Unit_Name       => SId,\n+             Parameter_Specifications => New_List (\n+               Make_Parameter_Specification (Loc,\n+                 Defining_Identifier =>\n+                   Make_Defining_Identifier (Loc,\n+                     Chars => Object_Name),\n+                 Parameter_Type =>\n+                   New_Occurrence_Of (Typ, Loc))),\n+             Result_Definition        =>\n+               New_Occurrence_Of (Standard_Boolean, Loc));\n+\n+         FDecl :=\n+           Make_Subprogram_Declaration (Loc,\n+             Specification => Spec);\n+\n+         --  Build function body\n+\n+         SId :=\n+           Make_Defining_Identifier (Loc,\n+             Chars => New_External_Name (Chars (Typ), \"Predicate\"));\n+\n+         Spec :=\n+           Make_Function_Specification (Loc,\n+             Defining_Unit_Name       => SId,\n+             Parameter_Specifications => New_List (\n+               Make_Parameter_Specification (Loc,\n+                 Defining_Identifier =>\n+                   Make_Defining_Identifier (Loc,\n+                     Chars => Object_Name),\n+                 Parameter_Type =>\n+                   New_Occurrence_Of (Typ, Loc))),\n+             Result_Definition        =>\n+               New_Occurrence_Of (Standard_Boolean, Loc));\n+\n+         FBody :=\n+           Make_Subprogram_Body (Loc,\n+             Specification              => Spec,\n+             Declarations               => Empty_List,\n+             Handled_Statement_Sequence =>\n+               Make_Handled_Sequence_Of_Statements (Loc,\n+                 Statements => New_List (\n+                   Make_Simple_Return_Statement (Loc,\n+                     Expression => Expr))));\n+      end if;\n+   end Build_Predicate_Function;\n+\n    ------------------------------------------\n    -- Expand_N_Attribute_Definition_Clause --\n    ------------------------------------------\n@@ -414,6 +719,26 @@ package body Exp_Ch13 is\n          Rewrite (N, Make_Null_Statement (Sloc (N)));\n       end if;\n \n+      --  If freezing a type entity which has predicates, this is where we\n+      --  build and insert the predicate function for the type.\n+\n+      if Is_Type (E) and then Has_Predicates (E) then\n+         declare\n+            FDecl : Node_Id;\n+            FBody : Node_Id;\n+\n+         begin\n+            Build_Predicate_Function (E, FDecl, FBody);\n+\n+            if Present (FDecl) then\n+               Insert_After (N, FBody);\n+               Insert_After (N, FDecl);\n+            end if;\n+         end;\n+      end if;\n+\n+      --  Pop scope if we intalled one for the analysis\n+\n       if In_Other_Scope then\n          if Ekind (Current_Scope) = E_Package then\n             End_Package_Scope (E_Scope);"}, {"sha": "613e9c831b67c76aaf14dadeff1b7058900a076a", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48f91b442f810e5bae8cd52bf2f84e9c0f43b948/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48f91b442f810e5bae8cd52bf2f84e9c0f43b948/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=48f91b442f810e5bae8cd52bf2f84e9c0f43b948", "patch": "@@ -8767,7 +8767,6 @@ package body Exp_Ch4 is\n       --  this case, see Handle_Changed_Representation.\n \n       elsif Is_Array_Type (Target_Type) then\n-\n          if Is_Constrained (Target_Type) then\n             Apply_Length_Check (Operand, Target_Type);\n          else\n@@ -8933,8 +8932,20 @@ package body Exp_Ch4 is\n \n       --  Here at end of processing\n \n-      <<Done>>\n-         null;\n+   <<Done>>\n+      --  Apply predicate check if required. Note that we can't just call\n+      --  Apply_Predicate_Check here, because the type looks right after\n+      --  the conversion and it would omit the check. The Comes_From_Source\n+      --  guard is necessary to prevent infinite recursions when we generate\n+      --  internal conversions for the purpose of checking predicates.\n+\n+      if Present (Predicate_Function (Target_Type))\n+        and then Target_Type /= Operand_Type\n+        and then Comes_From_Source (N)\n+      then\n+         Insert_Action (N,\n+           Make_Predicate_Check (Target_Type, Duplicate_Subexpr (N)));\n+      end if;\n    end Expand_N_Type_Conversion;\n \n    -----------------------------------"}, {"sha": "6694fdfbfd4b3881ac45c8a4dd2f1fa6679acb3b", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48f91b442f810e5bae8cd52bf2f84e9c0f43b948/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48f91b442f810e5bae8cd52bf2f84e9c0f43b948/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=48f91b442f810e5bae8cd52bf2f84e9c0f43b948", "patch": "@@ -1626,6 +1626,10 @@ package body Exp_Ch5 is\n          Generate_Range_Check (Rhs, Typ, CE_Range_Check_Failed);\n       end if;\n \n+      --  Generate predicate check if required\n+\n+      Apply_Predicate_Check (Rhs, Typ);\n+\n       --  Check for a special case where a high level transformation is\n       --  required. If we have either of:\n "}, {"sha": "1717ba77c941cf8bc5dcad14d66e797bf3ae232d", "filename": "gcc/ada/exp_prag.adb", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48f91b442f810e5bae8cd52bf2f84e9c0f43b948/gcc%2Fada%2Fexp_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48f91b442f810e5bae8cd52bf2f84e9c0f43b948/gcc%2Fada%2Fexp_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_prag.adb?ref=48f91b442f810e5bae8cd52bf2f84e9c0f43b948", "patch": "@@ -294,7 +294,7 @@ package body Exp_Prag is\n       --  where Str is the message if one is present, or the default of\n       --  name failed at file:line if no message is given (the \"name failed\n       --  at\" is omitted for name = Assertion, since it is redundant, given\n-      --  that the name of the exception is Assert_Failure.\n+      --  that the name of the exception is Assert_Failure.)\n \n       --  An alternative expansion is used when the No_Exception_Propagation\n       --  restriction is active and there is a local Assert_Failure handler.\n@@ -353,33 +353,40 @@ package body Exp_Prag is\n                Msg_Loc : constant String := Build_Location_String (Loc);\n \n             begin\n+               Name_Len := 0;\n+\n                --  For Assert, we just use the location\n \n                if Nam = Name_Assertion then\n-                  Name_Len := 0;\n+                  null;\n \n-                  --  For any check except Precondition/Postcondition, the\n-                  --  string is \"xxx failed at yyy\" where xxx is the name of\n-                  --  the check with current source file casing.\n+               --  For predicate, we generate the string \"predicate failed\n+               --  at yyy\". We prefer all lower case for predicate.\n \n-               elsif Nam /= Name_Precondition\n-                       and then\n-                     Nam /= Name_Postcondition\n-               then\n-                  Get_Name_String (Nam);\n-                  Set_Casing (Identifier_Casing (Current_Source_File));\n-                  Add_Str_To_Name_Buffer (\" failed at \");\n+               elsif Nam = Name_Predicate then\n+                  Add_Str_To_Name_Buffer (\"predicate failed at \");\n \n                --  For special case of Precondition/Postcondition the string is\n                --  \"failed xx from yy\" where xx is precondition/postcondition\n                --  in all lower case. The reason for this different wording is\n                --  that the failure is not at the point of occurrence of the\n                --  pragma, unlike the other Check cases.\n \n-               else\n+               elsif Nam = Name_Precondition\n+                       or else\n+                     Nam = Name_Postcondition\n+               then\n                   Get_Name_String (Nam);\n                   Insert_Str_In_Name_Buffer (\"failed \", 1);\n                   Add_Str_To_Name_Buffer (\" from \");\n+\n+               --  For all other checks, the string is \"xxx failed at yyy\"\n+               --  where xxx is the check name with current source file casing.\n+\n+               else\n+                  Get_Name_String (Nam);\n+                  Set_Casing (Identifier_Casing (Current_Source_File));\n+                  Add_Str_To_Name_Buffer (\" failed at \");\n                end if;\n \n                --  In all cases, add location string"}, {"sha": "5bbcab0134c6bc0a2dcf87443111ce48b06ca393", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48f91b442f810e5bae8cd52bf2f84e9c0f43b948/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48f91b442f810e5bae8cd52bf2f84e9c0f43b948/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=48f91b442f810e5bae8cd52bf2f84e9c0f43b948", "patch": "@@ -3787,28 +3787,6 @@ package body Freeze is\n             end if;\n          end if;\n \n-         --  If we have predicates, then this is where we build the predicate\n-         --  function, and return the spec and body as freeze actions.\n-\n-         if Has_Predicates (E) then\n-            declare\n-               FDecl : Node_Id;\n-               FBody : Node_Id;\n-\n-            begin\n-               Build_Predicate_Function (E, FDecl, FBody);\n-\n-               if Present (FDecl) then\n-                  if No (Result) then\n-                     Result := Empty_List;\n-                  end if;\n-\n-                  Append_To (Result, FDecl);\n-                  Append_To (Result, FBody);\n-               end if;\n-            end;\n-         end if;\n-\n          --  Generic types are never seen by the back-end, and are also not\n          --  processed by the expander (since the expander is turned off for\n          --  generic processing), so we never need freeze nodes for them."}, {"sha": "b1f619c90e7754d2ebbfa521ce286871bab17476", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 0, "deletions": 285, "changes": 285, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48f91b442f810e5bae8cd52bf2f84e9c0f43b948/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48f91b442f810e5bae8cd52bf2f84e9c0f43b948/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=48f91b442f810e5bae8cd52bf2f84e9c0f43b948", "patch": "@@ -3756,291 +3756,6 @@ package body Sem_Ch13 is\n       end if;\n    end Build_Invariant_Procedure;\n \n-   ------------------------------\n-   -- Build_Predicate_Function --\n-   ------------------------------\n-\n-   --  The procedure that is constructed here has the form\n-\n-   --  function typPredicate (Ixxx : typ) return Boolean is\n-   --  begin\n-   --     return\n-   --        exp1 and then exp2 and then ...\n-   --        and then typ1Predicate (typ1 (Ixxx))\n-   --        and then typ2Predicate (typ2 (Ixxx))\n-   --        and then ...;\n-   --  end typPredicate;\n-\n-   --  Here exp1, and exp2 are expressions from Predicate pragmas. Note that\n-   --  this is the point at which these expressions get analyzed, providing the\n-   --  required delay, and typ1, typ2, are entities from which predicates are\n-   --  inherited. Note that we do NOT generate Check pragmas, that's because we\n-   --  use this function even if checks are off, e.g. for membership tests.\n-\n-   procedure Build_Predicate_Function\n-     (Typ   : Entity_Id;\n-      FDecl : out Node_Id;\n-      FBody : out Node_Id)\n-   is\n-      Loc  : constant Source_Ptr := Sloc (Typ);\n-      Spec : Node_Id;\n-      SId  : Entity_Id;\n-\n-      Expr : Node_Id;\n-      --  This is the expression for the return statement in the function. It\n-      --  is build by connecting the component predicates with AND THEN.\n-\n-      procedure Add_Call (T : Entity_Id);\n-      --  Includes a call statement to the predicate function for type T in\n-      --  Expr if T has predicates and Predicate_Function (T) is non-empty.\n-\n-      procedure Add_Predicates;\n-      --  Appends expressions for any Predicate pragmas in the rep item chain\n-      --  Typ to Expr. Note that we look only at items for this exact entity.\n-      --  Inheritance of predicates for the parent type is done by calling the\n-      --  Predicate_Function of the parent type, using Add_Call above.\n-\n-      Object_Name : constant Name_Id := New_Internal_Name ('I');\n-      --  Name for argument of Predicate procedure\n-\n-      --------------\n-      -- Add_Call --\n-      --------------\n-\n-      procedure Add_Call (T : Entity_Id) is\n-         Exp : Node_Id;\n-\n-      begin\n-         if Present (T)\n-           and then Present (Predicate_Function (T))\n-         then\n-            Exp :=\n-              Make_Predicate_Call\n-                (T,\n-                 Convert_To (T,\n-                   Make_Identifier (Loc,\n-                     Chars => Object_Name)));\n-\n-            if No (Expr) then\n-               Expr := Exp;\n-            else\n-               Expr :=\n-                 Make_And_Then (Loc,\n-                   Left_Opnd  => Relocate_Node (Expr),\n-                   Right_Opnd => Exp);\n-            end if;\n-         end if;\n-      end Add_Call;\n-\n-      --------------------\n-      -- Add_Predicates --\n-      --------------------\n-\n-      procedure Add_Predicates is\n-         Ritem : Node_Id;\n-         Arg1  : Node_Id;\n-         Arg2  : Node_Id;\n-\n-         function Replace_Node (N : Node_Id) return Traverse_Result;\n-         --  Process single node for traversal to replace type references\n-\n-         procedure Replace_Type is new Traverse_Proc (Replace_Node);\n-         --  Traverse an expression changing every occurrence of an entity\n-         --  reference to type T with a reference to the object argument.\n-\n-         ------------------\n-         -- Replace_Node --\n-         ------------------\n-\n-         function Replace_Node (N : Node_Id) return Traverse_Result is\n-         begin\n-            --  Case of entity name referencing the type\n-\n-            if Is_Entity_Name (N)\n-              and then Entity (N) = Typ\n-            then\n-               --  Replace with object\n-\n-               Rewrite (N,\n-                 Make_Identifier (Loc,\n-                   Chars => Object_Name));\n-\n-               --  All done with this node\n-\n-               return Skip;\n-\n-            --  Not an instance of the type entity, keep going\n-\n-            else\n-               return OK;\n-            end if;\n-         end Replace_Node;\n-\n-      begin\n-         Ritem := First_Rep_Item (Typ);\n-         while Present (Ritem) loop\n-            if Nkind (Ritem) = N_Pragma\n-              and then Pragma_Name (Ritem) = Name_Predicate\n-            then\n-               Arg1 := First (Pragma_Argument_Associations (Ritem));\n-               Arg2 := Next (Arg1);\n-\n-               Arg1 := Get_Pragma_Arg (Arg1);\n-               Arg2 := Get_Pragma_Arg (Arg2);\n-\n-               --  We need to replace any occurrences of the name of the type\n-               --  with references to the object. We do this by first doing a\n-               --  preanalysis, to identify all the entities, then we traverse\n-               --  looking for the type entity, doing the needed substitution.\n-               --  The preanalysis is done with the special OK_To_Reference\n-               --  flag set on the type, so that if we get an occurrence of\n-               --  this type, it will be reognized as legitimate.\n-\n-               Set_OK_To_Reference (Typ, True);\n-               Preanalyze_Spec_Expression (Arg2, Standard_Boolean);\n-               Set_OK_To_Reference (Typ, False);\n-               Replace_Type (Arg2);\n-\n-               --  See if this predicate pragma is for the current type\n-\n-               if Entity (Arg1) = Typ then\n-\n-                  --  We have a match, add the expression\n-\n-                  if No (Expr) then\n-                     Expr := Relocate_Node (Arg2);\n-                  else\n-                     Expr :=\n-                       Make_And_Then (Loc,\n-                         Left_Opnd  => Relocate_Node (Expr),\n-                         Right_Opnd => Relocate_Node (Arg2));\n-                  end if;\n-               end if;\n-            end if;\n-\n-            Next_Rep_Item (Ritem);\n-         end loop;\n-      end Add_Predicates;\n-\n-   --  Start of processing for Build_Predicate_Function\n-\n-   begin\n-      --  Initialize for construction of statement list\n-\n-      Expr := Empty;\n-      FDecl := Empty;\n-      FBody := Empty;\n-\n-      --  Return if already built or if type does not have predicates\n-\n-      if not Has_Predicates (Typ)\n-        or else Present (Predicate_Function (Typ))\n-      then\n-         return;\n-      end if;\n-\n-      --  Add Predicates for the current type\n-\n-      Add_Predicates;\n-\n-      --  Deal with ancestor subtype and parent type\n-\n-      declare\n-         Atyp : constant Entity_Id := Ancestor_Subtype (Typ);\n-\n-      begin\n-         --  If ancestor subtype present, add its predicates\n-\n-         if Present (Atyp) then\n-            Add_Call (Atyp);\n-\n-         --  Else if this is derived, add predicates of parent type\n-\n-         elsif Is_Derived_Type (Typ) then\n-            Add_Call (Etype (Base_Type (Typ)));\n-         end if;\n-      end;\n-\n-      --  Add predicates of any interfaces of a tagged type\n-\n-      if Is_Tagged_Type (Typ) then\n-         declare\n-            Iface_List : Elist_Id;\n-            Elmt       : Elmt_Id;\n-\n-         begin\n-            Collect_Interfaces (Typ, Iface_List);\n-\n-            if Present (Iface_List) then\n-               loop\n-                  Elmt := First_Elmt (Iface_List);\n-                  exit when No (Elmt);\n-                  Add_Call (Node (Elmt));\n-                  Remove_Elmt (Iface_List, Elmt);\n-               end loop;\n-            end if;\n-         end;\n-      end if;\n-\n-      if Present (Expr) then\n-\n-         --  Build function declaration\n-\n-         pragma Assert (Has_Predicates (Typ));\n-         SId :=\n-           Make_Defining_Identifier (Loc,\n-             Chars => New_External_Name (Chars (Typ), \"Predicate\"));\n-         Set_Has_Predicates (SId);\n-         Set_Predicate_Function (Typ, SId);\n-\n-         Spec :=\n-           Make_Function_Specification (Loc,\n-             Defining_Unit_Name       => SId,\n-             Parameter_Specifications => New_List (\n-               Make_Parameter_Specification (Loc,\n-                 Defining_Identifier =>\n-                   Make_Defining_Identifier (Loc,\n-                     Chars => Object_Name),\n-                 Parameter_Type =>\n-                   New_Occurrence_Of (Typ, Loc))),\n-             Result_Definition        =>\n-               New_Occurrence_Of (Standard_Boolean, Loc));\n-\n-         FDecl :=\n-           Make_Subprogram_Declaration (Loc,\n-             Specification => Spec);\n-\n-         --  Build function body\n-\n-         SId :=\n-           Make_Defining_Identifier (Loc,\n-             Chars => New_External_Name (Chars (Typ), \"Predicate\"));\n-\n-         Spec :=\n-           Make_Function_Specification (Loc,\n-             Defining_Unit_Name       => SId,\n-             Parameter_Specifications => New_List (\n-               Make_Parameter_Specification (Loc,\n-                 Defining_Identifier =>\n-                   Make_Defining_Identifier (Loc,\n-                     Chars => Object_Name),\n-                 Parameter_Type =>\n-                   New_Occurrence_Of (Typ, Loc))),\n-             Result_Definition        =>\n-               New_Occurrence_Of (Standard_Boolean, Loc));\n-\n-         FBody :=\n-           Make_Subprogram_Body (Loc,\n-             Specification              => Spec,\n-             Declarations               => Empty_List,\n-             Handled_Statement_Sequence =>\n-               Make_Handled_Sequence_Of_Statements (Loc,\n-                 Statements => New_List (\n-                   Make_Simple_Return_Statement (Loc,\n-                     Expression => Expr))));\n-      end if;\n-   end Build_Predicate_Function;\n-\n    -----------------------------------\n    -- Check_Constant_Address_Clause --\n    -----------------------------------"}, {"sha": "8d0245d088b654a893999906c5e55c7c84f07d35", "filename": "gcc/ada/sem_ch13.ads", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48f91b442f810e5bae8cd52bf2f84e9c0f43b948/gcc%2Fada%2Fsem_ch13.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48f91b442f810e5bae8cd52bf2f84e9c0f43b948/gcc%2Fada%2Fsem_ch13.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.ads?ref=48f91b442f810e5bae8cd52bf2f84e9c0f43b948", "patch": "@@ -64,19 +64,6 @@ package Sem_Ch13 is\n    --  set for Typ. In some error situations no procedure is built, in which\n    --  case PDecl/PBody are empty on return.\n \n-   procedure Build_Predicate_Function\n-     (Typ   : Entity_Id;\n-      FDecl : out Node_Id;\n-      FBody : out Node_Id);\n-   --  If Typ has predicates (indicated by Has_Predicates being set for Typ,\n-   --  then either there are pragma Invariant entries on the rep chain for the\n-   --  type (note that Predicate aspects are converted to pragam Predicate), or\n-   --  there are inherited aspects from a parent type, or ancestor subtypes,\n-   --  or interfaces. This procedure builds the spec and body for the Predicate\n-   --  function that tests these predicates, returning them in PDecl and Pbody\n-   --  and setting Predicate_Procedure for Typ. In some error situations no\n-   --  procedure is built, in which case PDecl/PBody are empty on return.\n-\n    procedure Check_Record_Representation_Clause (N : Node_Id);\n    --  This procedure completes the analysis of a record representation clause\n    --  N. It is called at freeze time after adjustment of component clause bit"}, {"sha": "f453bcc61ddf77d4b16b9f7b920e0b0f69dbe0c6", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 3, "deletions": 33, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48f91b442f810e5bae8cd52bf2f84e9c0f43b948/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48f91b442f810e5bae8cd52bf2f84e9c0f43b948/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=48f91b442f810e5bae8cd52bf2f84e9c0f43b948", "patch": "@@ -17205,41 +17205,11 @@ package body Sem_Ch3 is\n          end;\n       end if;\n \n-      --  Propagate predicates to full type, and also build the predicate\n-      --  procedure at this time, in the same way as we did for invariants.\n+      --  Propagate predicates to full type\n \n       if Has_Predicates (Priv_T) then\n-         declare\n-            FDecl : Entity_Id;\n-            FBody : Entity_Id;\n-            Packg : constant Node_Id := Declaration_Node (Scope (Priv_T));\n-\n-         begin\n-            Build_Predicate_Function (Full_T, FDecl, FBody);\n-\n-            --  Error defense, normally this should be set\n-\n-            if Present (FDecl) then\n-\n-               --  Spec goes at the end of the public part of the package.\n-               --  That's behind us, so we have to manually analyze the\n-               --  inserted spec.\n-\n-               Append_To (Visible_Declarations (Packg), FDecl);\n-               Analyze (FDecl);\n-\n-               --  Body goes at the end of the private part of the package.\n-               --  That's ahead of us so it will get analyzed later on when\n-               --  we come to it.\n-\n-               Append_To (Private_Declarations (Packg), FBody);\n-\n-               --  Copy Predicate procedure to private declaration\n-\n-               Set_Predicate_Function (Priv_T, Predicate_Function (Full_T));\n-               Set_Has_Predicates (Priv_T);\n-            end if;\n-         end;\n+         Set_Predicate_Function (Priv_T, Predicate_Function (Full_T));\n+         Set_Has_Predicates (Priv_T);\n       end if;\n    end Process_Full_View;\n "}, {"sha": "03c817138deb663e6c953ebe06df06f0578fd500", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48f91b442f810e5bae8cd52bf2f84e9c0f43b948/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48f91b442f810e5bae8cd52bf2f84e9c0f43b948/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=48f91b442f810e5bae8cd52bf2f84e9c0f43b948", "patch": "@@ -3648,6 +3648,19 @@ package body Sem_Res is\n             --  any analysis. More thought required about this ???\n \n             if Ekind_In (F, E_In_Parameter, E_In_Out_Parameter) then\n+\n+               --  Apply predicate checks, unless this is a call to the\n+               --  predicate check function itself, which would cause an\n+               --  infinite recursion.\n+\n+               if not (Ekind (Nam) = E_Function\n+                        and then Has_Predicates (Nam))\n+               then\n+                  Apply_Predicate_Check (A, F_Typ);\n+               end if;\n+\n+               --  Apply required constraint checks\n+\n                if Is_Scalar_Type (Etype (A)) then\n                   Apply_Scalar_Range_Check (A, F_Typ);\n "}]}