{"sha": "30ea859e70a20f65b8abfb28269cd31bcab54941", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzBlYTg1OWU3MGEyMGY2NWI4YWJmYjI4MjY5Y2QzMWJjYWI1NDk0MQ==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2008-11-25T22:52:37Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2008-11-25T22:52:37Z"}, "message": "invoke.texi (ira-max-loops-num): Change semantics.\n\n2008-11-25  Vladimir Makarov  <vmakarov@redhat.com>\n\n\t* doc/invoke.texi (ira-max-loops-num): Change semantics.\n\n\t* ira-int.h (struct ira_loop_tree_node): New member to_remove_p.\n\n\t* ira-color.c (allocno_spill_priority): New function.\n\t(remove_allocno_from_bucket_and_push, push_allocno_to_spill):\n\tPrint more info about the spilled allocno.\n\t(push_allocnos_to_stack): Use allocno_spill_priority.  Add more\n\tchecks on bad spill.\n\n\t* ira-build.c (loop_node_to_be_removed_p): Remove.\n\t(loop_compare_func, mark_loops_for_removal): New functions.\n\t(remove_uneccesary_loop_nodes_from_loop_t): Use member\n\tto_remove_p.\n\t(remove_unnecessary_allocnos): Call mark_loops_for_removal.\n\n\t* ira.c (ira): Don't change flag_ira_algorithm.\n\n\t* params.def (ira-max-loops-num): Change the value.\n\nFrom-SVN: r142207", "tree": {"sha": "570532edd558acfd1cd74a139d8cf1f249d28173", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/570532edd558acfd1cd74a139d8cf1f249d28173"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/30ea859e70a20f65b8abfb28269cd31bcab54941", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30ea859e70a20f65b8abfb28269cd31bcab54941", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30ea859e70a20f65b8abfb28269cd31bcab54941", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30ea859e70a20f65b8abfb28269cd31bcab54941/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5a1c3c109550ee678d41873ab74cb723923c7796", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a1c3c109550ee678d41873ab74cb723923c7796", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a1c3c109550ee678d41873ab74cb723923c7796"}], "stats": {"total": 173, "additions": 134, "deletions": 39}, "files": [{"sha": "77110a396286a07b405887d0dbbfe6eaa3a7873d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30ea859e70a20f65b8abfb28269cd31bcab54941/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30ea859e70a20f65b8abfb28269cd31bcab54941/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=30ea859e70a20f65b8abfb28269cd31bcab54941", "patch": "@@ -1,3 +1,25 @@\n+2008-11-25  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* doc/invoke.texi (ira-max-loops-num): Change semantics.\n+\n+\t* ira-int.h (struct ira_loop_tree_node): New member to_remove_p.\n+\n+\t* ira-color.c (allocno_spill_priority): New function.\n+\t(remove_allocno_from_bucket_and_push, push_allocno_to_spill):\n+\tPrint more info about the spilled allocno.\n+\t(push_allocnos_to_stack): Use allocno_spill_priority.  Add more\n+\tchecks on bad spill.\n+\n+\t* ira-build.c (loop_node_to_be_removed_p): Remove.\n+\t(loop_compare_func, mark_loops_for_removal): New functions.\n+\t(remove_uneccesary_loop_nodes_from_loop_t): Use member\n+\tto_remove_p.\n+\t(remove_unnecessary_allocnos): Call mark_loops_for_removal.\n+\n+\t* ira.c (ira): Don't change flag_ira_algorithm.\n+\n+\t* params.def (ira-max-loops-num): Change the value.\n+\n 2008-11-25  Maxim Kuvyrkov  <maxim@codesourcery.com>\n \n \t* config/m68k/m68k.md (extendsidi2, extendsidi2_mem): Merge, clean up."}, {"sha": "a25f469867af0591bd7ad1df77d9009813eaac68", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30ea859e70a20f65b8abfb28269cd31bcab54941/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30ea859e70a20f65b8abfb28269cd31bcab54941/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=30ea859e70a20f65b8abfb28269cd31bcab54941", "patch": "@@ -7603,10 +7603,10 @@ be disabled.  The default maximum SCC size is 10000.\n \n @item ira-max-loops-num\n IRA uses a regional register allocation by default.  If a function\n-contains loops more than number given by the parameter, non-regional\n-register allocator will be used even when option\n-@option{-fira-algorithm} is given.  The default value of the parameter\n-is 20.\n+contains loops more than number given by the parameter, only at most\n+given number of the most frequently executed loops will form regions\n+for the regional register allocation.  The default value of the\n+parameter is 100.\n \n @end table\n @end table"}, {"sha": "65e4ad76dbb0a6659728b7397b2627b1d1536efb", "filename": "gcc/ira-build.c", "status": "modified", "additions": 76, "deletions": 14, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30ea859e70a20f65b8abfb28269cd31bcab54941/gcc%2Fira-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30ea859e70a20f65b8abfb28269cd31bcab54941/gcc%2Fira-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-build.c?ref=30ea859e70a20f65b8abfb28269cd31bcab54941", "patch": "@@ -1677,20 +1677,81 @@ low_pressure_loop_node_p (ira_loop_tree_node_t node)\n   return true;\n }\n \n-/* Return TRUE if NODE represents a loop with should be removed from\n-   regional allocation.  We remove a loop with low register pressure\n-   inside another loop with register pressure.  In this case a\n-   separate allocation of the loop hardly helps (for irregular\n-   register file architecture it could help by choosing a better hard\n-   register in the loop but we prefer faster allocation even in this\n-   case).  */\n-static bool\n-loop_node_to_be_removed_p (ira_loop_tree_node_t node)\n+/* Sort loops for marking them for removal.  We put already marked\n+   loops first, then less frequent loops next, and then outer loops\n+   next.  */\n+static int\n+loop_compare_func (const void *v1p, const void *v2p)\n+{\n+  int diff;\n+  ira_loop_tree_node_t l1 = *(const ira_loop_tree_node_t *) v1p;\n+  ira_loop_tree_node_t l2 = *(const ira_loop_tree_node_t *) v2p;\n+\n+  ira_assert (l1->parent != NULL && l2->parent != NULL);\n+  if (l1->to_remove_p && ! l2->to_remove_p)\n+    return -1;\n+  if (! l1->to_remove_p && l2->to_remove_p)\n+    return 1;\n+  if ((diff = l1->loop->header->frequency - l2->loop->header->frequency) != 0)\n+    return diff;\n+  if ((diff = (int) loop_depth (l1->loop) - (int) loop_depth (l2->loop)) != 0)\n+    return diff;\n+  /* Make sorting stable.  */\n+  return l1->loop->num - l2->loop->num;\n+}\n+\n+\n+/* Mark loops which should be removed from regional allocation.  We\n+   remove a loop with low register pressure inside another loop with\n+   register pressure.  In this case a separate allocation of the loop\n+   hardly helps (for irregular register file architecture it could\n+   help by choosing a better hard register in the loop but we prefer\n+   faster allocation even in this case).  We also remove cheap loops\n+   if there are more than IRA_MAX_LOOPS_NUM of them.  */\n+static void\n+mark_loops_for_removal (void)\n {\n-  return (node->parent != NULL && low_pressure_loop_node_p (node->parent)\n-\t  && low_pressure_loop_node_p (node));\n+  int i, n;\n+  ira_loop_tree_node_t *sorted_loops;\n+  loop_p loop;\n+\n+  sorted_loops\n+    = (ira_loop_tree_node_t *) ira_allocate (sizeof (ira_loop_tree_node_t)\n+\t\t\t\t\t     * VEC_length (loop_p,\n+\t\t\t\t\t\t\t   ira_loops.larray));\n+  for (n = i = 0; VEC_iterate (loop_p, ira_loops.larray, i, loop); i++)\n+    if (ira_loop_nodes[i].regno_allocno_map != NULL)\n+      {\n+\tif (ira_loop_nodes[i].parent == NULL)\n+\t  {\n+\t    /* Don't remove the root.  */\n+\t    ira_loop_nodes[i].to_remove_p = false;\n+\t    continue;\n+\t  }\n+\tsorted_loops[n++] = &ira_loop_nodes[i];\n+\tira_loop_nodes[i].to_remove_p\n+\t  = (low_pressure_loop_node_p (ira_loop_nodes[i].parent)\n+\t     && low_pressure_loop_node_p (&ira_loop_nodes[i]));\n+      }\n+  qsort (sorted_loops, n, sizeof (ira_loop_tree_node_t), loop_compare_func);\n+  for (i = 0; n - i + 1 > IRA_MAX_LOOPS_NUM; i++)\n+    {\n+      sorted_loops[i]->to_remove_p = true;\n+      if (internal_flag_ira_verbose > 1 && ira_dump_file != NULL)\n+\tfprintf\n+\t  (ira_dump_file,\n+\t   \"  Mark loop %d (header %d, freq %d, depth %d) for removal (%s)\\n\",\n+\t   sorted_loops[i]->loop->num, sorted_loops[i]->loop->header->index,\n+\t   sorted_loops[i]->loop->header->frequency,\n+\t   loop_depth (sorted_loops[i]->loop),\n+\t   low_pressure_loop_node_p (sorted_loops[i]->parent)\n+\t   && low_pressure_loop_node_p (sorted_loops[i])\n+\t   ? \"low pressure\" : \"cheap loop\");\n+    }\n+  ira_free (sorted_loops);\n }\n \n+\n /* Definition of vector of loop tree nodes.  */\n DEF_VEC_P(ira_loop_tree_node_t);\n DEF_VEC_ALLOC_P(ira_loop_tree_node_t, heap);\n@@ -1710,7 +1771,7 @@ remove_uneccesary_loop_nodes_from_loop_tree (ira_loop_tree_node_t node)\n   bool remove_p;\n   ira_loop_tree_node_t subnode;\n \n-  remove_p = loop_node_to_be_removed_p (node);\n+  remove_p = node->to_remove_p;\n   if (! remove_p)\n     VEC_safe_push (ira_loop_tree_node_t, heap, children_vec, node);\n   start = VEC_length (ira_loop_tree_node_t, children_vec);\n@@ -1759,13 +1820,13 @@ remove_unnecessary_allocnos (void)\n       {\n \tnext_a = ALLOCNO_NEXT_REGNO_ALLOCNO (a);\n \ta_node = ALLOCNO_LOOP_TREE_NODE (a);\n-\tif (! loop_node_to_be_removed_p (a_node))\n+\tif (! a_node->to_remove_p)\n \t  prev_a = a;\n \telse\n \t  {\n \t    for (parent = a_node->parent;\n \t\t (parent_a = parent->regno_allocno_map[regno]) == NULL\n-\t\t   && loop_node_to_be_removed_p (parent);\n+\t\t   && parent->to_remove_p;\n \t\t parent = parent->parent)\n \t      ;\n \t    if (parent_a == NULL)\n@@ -1843,6 +1904,7 @@ remove_unnecessary_allocnos (void)\n static void\n remove_unnecessary_regions (void)\n {\n+  mark_loops_for_removal ();\n   children_vec\n     = VEC_alloc (ira_loop_tree_node_t, heap,\n \t\t last_basic_block + VEC_length (loop_p, ira_loops.larray));"}, {"sha": "4b9909194d6e9817d580b2dc8112aab777528ee3", "filename": "gcc/ira-color.c", "status": "modified", "additions": 27, "deletions": 14, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30ea859e70a20f65b8abfb28269cd31bcab54941/gcc%2Fira-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30ea859e70a20f65b8abfb28269cd31bcab54941/gcc%2Fira-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-color.c?ref=30ea859e70a20f65b8abfb28269cd31bcab54941", "patch": "@@ -655,6 +655,17 @@ static ira_allocno_t uncolorable_allocno_bucket;\n    of given *cover* class in the uncolorable_bucket.  */\n static int uncolorable_allocnos_num[N_REG_CLASSES];\n \n+/* Return the current spill priority of allocno A.  The less the\n+   number, the more preferable the allocno for spilling.  */\n+static int\n+allocno_spill_priority (ira_allocno_t a)\n+{\n+  return (ALLOCNO_TEMP (a)\n+\t  / (ALLOCNO_LEFT_CONFLICTS_NUM (a)\n+\t     * ira_reg_class_nregs[ALLOCNO_COVER_CLASS (a)][ALLOCNO_MODE (a)]\n+\t     + 1));\n+}\n+\n /* Add ALLOCNO to bucket *BUCKET_PTR.  ALLOCNO should be not in a bucket\n    before the call.  */\n static void\n@@ -925,7 +936,12 @@ remove_allocno_from_bucket_and_push (ira_allocno_t allocno, bool colorable_p)\n     {\n       fprintf (ira_dump_file, \"      Pushing\");\n       print_coalesced_allocno (allocno);\n-      fprintf (ira_dump_file, \"%s\\n\", colorable_p ? \"\" : \"(potential spill)\");\n+      if (colorable_p)\n+\tfprintf (ira_dump_file, \"\\n\");\n+      else\n+\tfprintf (ira_dump_file, \"(potential spill: %spri=%d, cost=%d)\\n\",\n+\t\t ALLOCNO_BAD_SPILL_P (allocno) ? \"bad spill, \" : \"\",\n+\t\t allocno_spill_priority (allocno), ALLOCNO_TEMP (allocno));\n     }\n   cover_class = ALLOCNO_COVER_CLASS (allocno);\n   ira_assert ((colorable_p\n@@ -959,7 +975,7 @@ push_allocno_to_spill (ira_allocno_t allocno)\n   delete_allocno_from_bucket (allocno, &uncolorable_allocno_bucket);\n   ALLOCNO_MAY_BE_SPILLED_P (allocno) = true;\n   if (internal_flag_ira_verbose > 3 && ira_dump_file != NULL)\n-    fprintf (ira_dump_file, \"      Pushing p%d(%d) (potential spill)\\n\",\n+    fprintf (ira_dump_file, \"      Pushing p%d(%d) (spill for NO_REGS)\\n\",\n \t     ALLOCNO_NUM (allocno), ALLOCNO_REGNO (allocno));\n   push_allocno_to_stack (allocno);\n }\n@@ -1224,21 +1240,18 @@ push_allocnos_to_stack (void)\n \t\t  i++;\n \t\t  ira_assert (ALLOCNO_TEMP (i_allocno) != INT_MAX);\n \t\t  i_allocno_cost = ALLOCNO_TEMP (i_allocno);\n-\t\t  i_allocno_pri\n-\t\t    = (i_allocno_cost\n-\t\t       / (ALLOCNO_LEFT_CONFLICTS_NUM (i_allocno)\n-\t\t\t  * ira_reg_class_nregs[ALLOCNO_COVER_CLASS\n-\t\t\t\t\t\t(i_allocno)]\n-\t\t\t  [ALLOCNO_MODE (i_allocno)] + 1));\n+\t\t  i_allocno_pri = allocno_spill_priority (i_allocno);\n \t\t  if (allocno == NULL\n \t\t      || (! ALLOCNO_BAD_SPILL_P (i_allocno)\n \t\t\t  && ALLOCNO_BAD_SPILL_P (allocno))\n-\t\t      || allocno_pri > i_allocno_pri\n-\t\t      || (allocno_pri == i_allocno_pri\n-\t\t\t  && (allocno_cost > i_allocno_cost\n-\t\t\t      || (allocno_cost == i_allocno_cost \n-\t\t\t\t  && (ALLOCNO_NUM (allocno)\n-\t\t\t\t      > ALLOCNO_NUM (i_allocno))))))\n+\t\t      || (! (ALLOCNO_BAD_SPILL_P (i_allocno)\n+\t\t\t     && ! ALLOCNO_BAD_SPILL_P (allocno))\n+\t\t\t  && (allocno_pri > i_allocno_pri\n+\t\t\t      || (allocno_pri == i_allocno_pri\n+\t\t\t\t  && (allocno_cost > i_allocno_cost\n+\t\t\t\t      || (allocno_cost == i_allocno_cost \n+\t\t\t\t\t  && (ALLOCNO_NUM (allocno)\n+\t\t\t\t\t      > ALLOCNO_NUM (i_allocno))))))))\n \t\t    {\n \t\t      allocno = i_allocno;\n \t\t      allocno_cost = i_allocno_cost;"}, {"sha": "5c6b355ecc8ac9626b717467a01d7a7dd6a6f08a", "filename": "gcc/ira-int.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30ea859e70a20f65b8abfb28269cd31bcab54941/gcc%2Fira-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30ea859e70a20f65b8abfb28269cd31bcab54941/gcc%2Fira-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-int.h?ref=30ea859e70a20f65b8abfb28269cd31bcab54941", "patch": "@@ -98,6 +98,10 @@ struct ira_loop_tree_node\n   /* All the following members are defined only for nodes representing\n      loops.  */\n \n+  /* True if the loop was marked for removal from the register\n+     allocation.  */\n+  bool to_remove_p;\n+\n   /* Allocnos in the loop corresponding to their regnos.  If it is\n      NULL the loop does not form a separate register allocation region\n      (e.g. because it has abnormal enter/exit edges and we can not put"}, {"sha": "4b6854272f165b5da8ac6e5fd63022697d8afa87", "filename": "gcc/ira.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30ea859e70a20f65b8abfb28269cd31bcab54941/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30ea859e70a20f65b8abfb28269cd31bcab54941/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=30ea859e70a20f65b8abfb28269cd31bcab54941", "patch": "@@ -1725,7 +1725,6 @@ ira (FILE *f)\n   bool loops_p;\n   int max_regno_before_ira, ira_max_point_before_emit;\n   int rebuild_p;\n-  int saved_flag_ira_algorithm;\n   int saved_flag_ira_share_spill_slots;\n   basic_block bb;\n \n@@ -1801,9 +1800,6 @@ ira (FILE *f)\n   ira_assert (current_loops == NULL);\n   flow_loops_find (&ira_loops);\n   current_loops = &ira_loops;\n-  saved_flag_ira_algorithm = flag_ira_algorithm;\n-  if (optimize && number_of_loops () > (unsigned) IRA_MAX_LOOPS_NUM)\n-    flag_ira_algorithm = IRA_ALGORITHM_CB;\n       \n   if (internal_flag_ira_verbose > 0 && ira_dump_file != NULL)\n     fprintf (ira_dump_file, \"Building IRA IR\\n\");\n@@ -1935,8 +1931,6 @@ ira (FILE *f)\n     bb->loop_father = NULL;\n   current_loops = NULL;\n \n-  flag_ira_algorithm = saved_flag_ira_algorithm;\n-\n   regstat_free_ri ();\n   regstat_free_n_sets_and_refs ();\n       "}, {"sha": "50a71339c7f678976f797907d266a31ea515c636", "filename": "gcc/params.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30ea859e70a20f65b8abfb28269cd31bcab54941/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30ea859e70a20f65b8abfb28269cd31bcab54941/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=30ea859e70a20f65b8abfb28269cd31bcab54941", "patch": "@@ -754,7 +754,7 @@ DEFPARAM (PARAM_DF_DOUBLE_QUEUE_THRESHOLD_FACTOR,\n DEFPARAM (PARAM_IRA_MAX_LOOPS_NUM,\n \t  \"ira-max-loops-num\",\n \t  \"max loops number for regional RA\",\n-\t  50, 0, 0)\n+\t  100, 0, 0)\n \n /* Switch initialization conversion will refuse to create arrays that are\n    bigger than this parameter times the number of switch branches.  */"}]}