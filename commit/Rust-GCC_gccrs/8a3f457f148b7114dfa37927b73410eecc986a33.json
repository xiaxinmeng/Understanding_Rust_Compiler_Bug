{"sha": "8a3f457f148b7114dfa37927b73410eecc986a33", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGEzZjQ1N2YxNDhiNzExNGRmYTM3OTI3YjczNDEwZWVjYzk4NmEzMw==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2017-10-31T11:59:32Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2017-10-31T11:59:32Z"}, "message": "GCOV: std::vector refactoring III\n\n2017-10-31  Martin Liska  <mliska@suse.cz>\n\n\t* gcov.c (struct name_map): do not use typedef.\n\tDefine operator== and operator<.\n\t(name_search): Remove.\n\t(name_sort): Remove.\n\t(main): Do not allocate names.\n\t(process_file): Add vertical space.\n\t(generate_results): Use std::find.\n\t(release_structures): Do not release memory.\n\t(find_source): Use std::find.\n\nFrom-SVN: r254262", "tree": {"sha": "3d8aca15b3238bb60c59e16343ceeb05facdff1e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3d8aca15b3238bb60c59e16343ceeb05facdff1e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8a3f457f148b7114dfa37927b73410eecc986a33", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a3f457f148b7114dfa37927b73410eecc986a33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a3f457f148b7114dfa37927b73410eecc986a33", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a3f457f148b7114dfa37927b73410eecc986a33/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4695d816a37abffa3fae55cbb1c874ec1e62446d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4695d816a37abffa3fae55cbb1c874ec1e62446d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4695d816a37abffa3fae55cbb1c874ec1e62446d"}], "stats": {"total": 145, "additions": 70, "deletions": 75}, "files": [{"sha": "aed3c9410166a796feb6c933577d8914fa9b5120", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a3f457f148b7114dfa37927b73410eecc986a33/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a3f457f148b7114dfa37927b73410eecc986a33/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8a3f457f148b7114dfa37927b73410eecc986a33", "patch": "@@ -1,3 +1,15 @@\n+2017-10-31  Martin Liska  <mliska@suse.cz>\n+\n+\t* gcov.c (struct name_map): do not use typedef.\n+\tDefine operator== and operator<.\n+\t(name_search): Remove.\n+\t(name_sort): Remove.\n+\t(main): Do not allocate names.\n+\t(process_file): Add vertical space.\n+\t(generate_results): Use std::find.\n+\t(release_structures): Do not release memory.\n+\t(find_source): Use std::find.\n+\n 2017-10-31  Martin Liska  <mliska@suse.cz>\n \n \t* gcov.c (struct line_info): Remove it's typedef."}, {"sha": "f1e7777cf94784441bca762ec7f6f8fb9a9518d2", "filename": "gcc/gcov.c", "status": "modified", "additions": 58, "deletions": 75, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a3f457f148b7114dfa37927b73410eecc986a33/gcc%2Fgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a3f457f148b7114dfa37927b73410eecc986a33/gcc%2Fgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov.c?ref=8a3f457f148b7114dfa37927b73410eecc986a33", "patch": "@@ -302,11 +302,38 @@ source_info::source_info (): name (NULL), file_time (), lines (),\n {\n }\n \n-typedef struct name_map\n+class name_map\n {\n-  char *name;  /* Source file name */\n+public:\n+  name_map ()\n+  {\n+  }\n+\n+  name_map (char *_name, unsigned _src): name (_name), src (_src)\n+  {\n+  }\n+\n+  bool operator== (const name_map &rhs) const\n+  {\n+#if HAVE_DOS_BASED_FILE_SYSTEM\n+    return strcasecmp (this->name, rhs.name) == 0;\n+#else\n+    return strcmp (this->name, rhs.name) == 0;\n+#endif\n+  }\n+\n+  bool operator< (const name_map &rhs) const\n+  {\n+#if HAVE_DOS_BASED_FILE_SYSTEM\n+    return strcasecmp (this->name, rhs.name) < 0;\n+#else\n+    return strcmp (this->name, rhs.name) < 0;\n+#endif\n+  }\n+\n+  const char *name;  /* Source file name */\n   unsigned src;  /* Source file */\n-} name_map_t;\n+};\n \n /* Holds a list of function basic block graphs.  */\n \n@@ -316,9 +343,8 @@ static function_t **fn_end = &functions;\n /* Vector of source files.  */\n static vector<source_info> sources;\n \n-static name_map_t *names;   /* Mapping of file names to sources */\n-static unsigned n_names;    /* Number of names */\n-static unsigned a_names;    /* Allocated names */\n+/* Mapping of file names to sources */\n+static vector<name_map> names;\n \n /* This holds data summary information.  */\n \n@@ -443,8 +469,6 @@ static void print_version (void) ATTRIBUTE_NORETURN;\n static void process_file (const char *);\n static void generate_results (const char *);\n static void create_file_names (const char *);\n-static int name_search (const void *, const void *);\n-static int name_sort (const void *, const void *);\n static char *canonicalize_name (const char *);\n static unsigned find_source (const char *);\n static function_t *read_graph_file (void);\n@@ -675,9 +699,6 @@ main (int argc, char **argv)\n   /* Handle response files.  */\n   expandargv (&argc, &argv);\n \n-  a_names = 10;\n-  names = XNEWVEC (name_map_t, a_names);\n-\n   argno = process_args (argc, argv);\n   if (optind == argc)\n     print_usage (true);\n@@ -941,7 +962,7 @@ process_file (const char *file_name)\n \t  unsigned line = fn->line;\n \t  unsigned block_no;\n \t  function_t *probe, **prev;\n-\t  \n+\n \t  /* Now insert it into the source file's list of\n \t     functions. Normally functions will be encountered in\n \t     ascending order, so a simple scan is quick.  Note we're\n@@ -1038,12 +1059,15 @@ generate_results (const char *file_name)\n \t}\n     }\n \n+  name_map needle;\n+\n   if (file_name)\n     {\n-      name_map_t *name_map = (name_map_t *)bsearch\n-\t(file_name, names, n_names, sizeof (*names), name_search);\n-      if (name_map)\n-\tfile_name = sources[name_map->src].coverage.name;\n+      needle.name = file_name;\n+      vector<name_map>::iterator it = std::find (names.begin (), names.end (),\n+\t\t\t\t\t\t needle);\n+      if (it != names.end ())\n+\tfile_name = sources[it->src].coverage.name;\n       else\n \tfile_name = canonicalize_name (file_name);\n     }\n@@ -1086,13 +1110,8 @@ generate_results (const char *file_name)\n static void\n release_structures (void)\n {\n-  unsigned ix;\n   function_t *fn;\n \n-  for (ix = n_names; ix--;)\n-    free (names[ix].name);\n-  free (names);\n-\n   while ((fn = functions))\n     {\n       functions = fn->next;\n@@ -1168,77 +1187,42 @@ create_file_names (const char *file_name)\n   return;\n }\n \n-/* A is a string and B is a pointer to name_map_t.  Compare for file\n-   name orderability.  */\n-\n-static int\n-name_search (const void *a_, const void *b_)\n-{\n-  const char *a = (const char *)a_;\n-  const name_map_t *b = (const name_map_t *)b_;\n-\n-#if HAVE_DOS_BASED_FILE_SYSTEM\n-  return strcasecmp (a, b->name);\n-#else\n-  return strcmp (a, b->name);\n-#endif\n-}\n-\n-/* A and B are a pointer to name_map_t.  Compare for file name\n-   orderability.  */\n-\n-static int\n-name_sort (const void *a_, const void *b_)\n-{\n-  const name_map_t *a = (const name_map_t *)a_;\n-  return name_search (a->name, b_);\n-}\n-\n /* Find or create a source file structure for FILE_NAME. Copies\n    FILE_NAME on creation */\n \n static unsigned\n find_source (const char *file_name)\n {\n-  name_map_t *name_map;\n   char *canon;\n   unsigned idx;\n   struct stat status;\n \n   if (!file_name)\n     file_name = \"<unknown>\";\n-  name_map = (name_map_t *)bsearch\n-    (file_name, names, n_names, sizeof (*names), name_search);\n-  if (name_map)\n-    {\n-      idx = name_map->src;\n-      goto check_date;\n-    }\n \n-  if (n_names + 2 > a_names)\n+  name_map needle;\n+  needle.name = file_name;\n+\n+  vector<name_map>::iterator it = std::find (names.begin (), names.end (),\n+\t\t\t\t\t     needle);\n+  if (it != names.end ())\n     {\n-      /* Extend the name map array -- we'll be inserting one or two\n-\t entries.  */\n-      a_names *= 2;\n-      name_map = XNEWVEC (name_map_t, a_names);\n-      memcpy (name_map, names, n_names * sizeof (*names));\n-      free (names);\n-      names = name_map;\n+      idx = it->src;\n+      goto check_date;\n     }\n \n   /* Not found, try the canonical name. */\n   canon = canonicalize_name (file_name);\n-  name_map = (name_map_t *) bsearch (canon, names, n_names, sizeof (*names),\n-\t\t\t\t     name_search);\n-  if (!name_map)\n+  needle.name = canon;\n+  it = std::find (names.begin (), names.end (), needle);\n+  if (it == names.end ())\n     {\n       /* Not found with canonical name, create a new source.  */\n       source_info *src;\n \n       idx = sources.size ();\n-      name_map = &names[n_names++];\n-      name_map->name = canon;\n-      name_map->src = idx;\n+      needle = name_map (canon, idx);\n+      names.push_back (needle);\n \n       sources.push_back (source_info ());\n       src = &sources.back ();\n@@ -1258,18 +1242,17 @@ find_source (const char *file_name)\n \tsrc->file_time = status.st_mtime;\n     }\n   else\n-    idx = name_map->src;\n+    idx = it->src;\n \n-  if (name_search (file_name, name_map))\n+  needle.name = file_name;\n+  if (std::find (names.begin (), names.end (), needle) == names.end ())\n     {\n       /* Append the non-canonical name.  */\n-      name_map = &names[n_names++];\n-      name_map->name = xstrdup (file_name);\n-      name_map->src = idx;\n+      names.push_back (name_map (xstrdup (file_name), idx));\n     }\n \n   /* Resort the name map.  */\n-  qsort (names, n_names, sizeof (*names), name_sort);\n+  std::sort (names.begin (), names.end ());\n \n  check_date:\n   if (sources[idx].file_time > bbg_file_time)"}]}