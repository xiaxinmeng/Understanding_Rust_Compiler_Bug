{"sha": "0b41abe6683830ae22978f43f085a59094f5b062", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGI0MWFiZTY2ODM4MzBhZTIyOTc4ZjQzZjA4NWE1OTA5NGY1YjA2Mg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1998-04-02T17:05:40Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-04-02T17:05:40Z"}, "message": "cp-tree.h: Lose CLASSTYPE_VBASE_SIZE, some unused stuff.\n\n\t* cp-tree.h: Lose CLASSTYPE_VBASE_SIZE, some unused stuff.\n\t* decl.c, decl2.c, pt.c, ptree.c, lex.c: Likewise.\n\t* class.c (duplicate_tag_error): Likewise.\n\t(finish_struct_1): Set CLASSTYPE_SIZE, CLASSTYPE_MODE, CLASSTYPE_ALIGN.\n\t* tree.c (layout_vbasetypes): Update from layout_record, remove\n\tvar_size support, use CLASSTYPE_SIZE instead of CLASSTYPE_VBASE_SIZE.\n\t(layout_basetypes): Likewise.\n\nFrom-SVN: r18965", "tree": {"sha": "f67814ae050184ae320900c9fcd616df3f0aede9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f67814ae050184ae320900c9fcd616df3f0aede9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0b41abe6683830ae22978f43f085a59094f5b062", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b41abe6683830ae22978f43f085a59094f5b062", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b41abe6683830ae22978f43f085a59094f5b062", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b41abe6683830ae22978f43f085a59094f5b062/comments", "author": null, "committer": null, "parents": [{"sha": "c098677bed45c310170a0bc8b6056b78c6cc6b9b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c098677bed45c310170a0bc8b6056b78c6cc6b9b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c098677bed45c310170a0bc8b6056b78c6cc6b9b"}], "stats": {"total": 285, "additions": 90, "deletions": 195}, "files": [{"sha": "3de389d3c4e6173c734b0961eaa797eae5d0a57c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b41abe6683830ae22978f43f085a59094f5b062/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b41abe6683830ae22978f43f085a59094f5b062/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=0b41abe6683830ae22978f43f085a59094f5b062", "patch": "@@ -1,3 +1,13 @@\n+Thu Apr  2 14:25:13 1998  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* cp-tree.h: Lose CLASSTYPE_VBASE_SIZE, some unused stuff.\n+\t* decl.c, decl2.c, pt.c, ptree.c, lex.c: Likewise.\n+\t* class.c (duplicate_tag_error): Likewise.\n+\t(finish_struct_1): Set CLASSTYPE_SIZE, CLASSTYPE_MODE, CLASSTYPE_ALIGN.\n+\t* tree.c (layout_vbasetypes): Update from layout_record, remove\n+\tvar_size support, use CLASSTYPE_SIZE instead of CLASSTYPE_VBASE_SIZE.\n+\t(layout_basetypes): Likewise.\n+\n Wed Apr  1 18:22:25 1998  Jeffrey A Law  (law@cygnus.com)\n \n \t* class.c, Make sure system.h is included just after config.h."}, {"sha": "3559c04221ebed07f0f2ee0bdb2fa1cc20116e08", "filename": "gcc/cp/class.c", "status": "modified", "additions": 7, "deletions": 19, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b41abe6683830ae22978f43f085a59094f5b062/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b41abe6683830ae22978f43f085a59094f5b062/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=0b41abe6683830ae22978f43f085a59094f5b062", "patch": "@@ -1846,12 +1846,7 @@ finish_struct_bits (t, max_has_virtual)\n \t{\n \t  basetype = BINFO_TYPE (TREE_VEC_ELT (binfos, i));\n \n-\t  if (TYPE_HAS_CONVERSION (basetype))\n-\t    {\n-\t      TYPE_HAS_CONVERSION (t) = 1;\n-\t      TYPE_HAS_INT_CONVERSION (t) |= TYPE_HAS_INT_CONVERSION (basetype);\n-\t      TYPE_HAS_REAL_CONVERSION (t) |= TYPE_HAS_REAL_CONVERSION (basetype);\n-\t    }\n+\t  TYPE_HAS_CONVERSION (t) |= TYPE_HAS_CONVERSION (basetype);\n \t  if (CLASSTYPE_MAX_DEPTH (basetype) >= CLASSTYPE_MAX_DEPTH (t))\n \t    CLASSTYPE_MAX_DEPTH (t) = CLASSTYPE_MAX_DEPTH (basetype) + 1;\n \t}\n@@ -2005,18 +2000,7 @@ finish_struct_methods (t, fn_fields, nonprivate_method)\n \t    }\n  \t}\n       else if (IDENTIFIER_TYPENAME_P (fn_name))\n-\t{\n-\t  tree return_type = TREE_TYPE (TREE_TYPE (fn_fields));\n-\n-\t  if (typecode_p (return_type, INTEGER_TYPE)\n-\t      || typecode_p (return_type, BOOLEAN_TYPE)\n-\t      || typecode_p (return_type, ENUMERAL_TYPE))\n-\t    TYPE_HAS_INT_CONVERSION (t) = 1;\n-\t  else if (typecode_p (return_type, REAL_TYPE))\n-\t    TYPE_HAS_REAL_CONVERSION (t) = 1;\n-\n-\t  grow_method (fn_fields, &method_vec);\n-\t}\n+\tgrow_method (fn_fields, &method_vec);\n     }\n \n   fn_fields = save_fn_fields;\n@@ -2159,7 +2143,6 @@ duplicate_tag_error (t)\n       CLASSTYPE_BINFO_AS_LIST (t) = binfo_as_list;\n       CLASSTYPE_INTERFACE_ONLY (t) = interface_only;\n       SET_CLASSTYPE_INTERFACE_UNKNOWN_X (t, interface_unknown);\n-      CLASSTYPE_VBASE_SIZE (t) = integer_zero_node;\n       TYPE_REDEFINED (t) = 1;\n     }\n   TYPE_SIZE (t) = NULL_TREE;\n@@ -3931,6 +3914,11 @@ finish_struct_1 (t, warn_anon)\n \n   layout_type (t);\n \n+  /* Remember the size, mode and alignment of the class before adding\n+     the virtual bases.  */\n+  CLASSTYPE_SIZE (t) = TYPE_SIZE (t);\n+  CLASSTYPE_ALIGN (t) = TYPE_ALIGN (t);\n+\n   finish_struct_anon (t);\n \n   if (n_baseclasses || empty)"}, {"sha": "25749d3625f19368d1fc0c1cd7724139f3d00b96", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 28, "deletions": 62, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b41abe6683830ae22978f43f085a59094f5b062/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b41abe6683830ae22978f43f085a59094f5b062/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=0b41abe6683830ae22978f43f085a59094f5b062", "patch": "@@ -420,103 +420,87 @@ struct lang_type\n   struct\n     {\n       unsigned has_type_conversion : 1;\n-      unsigned has_int_conversion : 1;\n-      unsigned has_float_conversion : 1;\n       unsigned has_init_ref : 1;\n-      unsigned gets_init_aggr : 1;\n       unsigned has_assignment : 1;\n       unsigned has_default_ctor : 1;\n       unsigned uses_multiple_inheritance : 1;\n-\n-      unsigned has_nonpublic_ctor : 2;\n-      unsigned has_nonpublic_assign_ref : 2;\n       unsigned const_needs_init : 1;\n       unsigned ref_needs_init : 1;\n       unsigned has_const_assign_ref : 1;\n-      unsigned vtable_needs_writing : 1;\n \n+      unsigned has_nonpublic_ctor : 2;\n+      unsigned has_nonpublic_assign_ref : 2;\n+      unsigned vtable_needs_writing : 1;\n       unsigned has_assign_ref : 1;\n       unsigned gets_new : 2;\n+\n       unsigned gets_delete : 2;\n       unsigned has_call_overloaded : 1;\n       unsigned has_array_ref_overloaded : 1;\n       unsigned has_arrow_overloaded : 1;\n-\n       unsigned local_typedecls : 1;\n       unsigned interface_only : 1;\n       unsigned interface_unknown : 1;\n+\n       unsigned needs_virtual_reinit : 1;\n       unsigned vec_delete_takes_size : 1;\n       unsigned declared_class : 1;\n       unsigned being_defined : 1;\n       unsigned redefined : 1;\n-\n-      unsigned no_globalize : 1;\n       unsigned marked : 1;\n       unsigned marked2 : 1;\n       unsigned marked3 : 1;\n+\n       unsigned marked4 : 1;\n       unsigned marked5 : 1;\n       unsigned marked6 : 1;\n       unsigned debug_requested : 1;\n-\n       unsigned use_template : 2;\n-      unsigned has_method_call_overloaded : 1;\n-      unsigned private_attr : 1;\n       unsigned got_semicolon : 1;\n       unsigned ptrmemfunc_flag : 1;\n+\n       unsigned is_signature : 1;\n       unsigned is_signature_pointer : 1;\n-\n       unsigned is_signature_reference : 1;\n       unsigned has_opaque_typedecls : 1;\n       unsigned sigtable_has_been_generated : 1;\n       unsigned was_anonymous : 1;\n       unsigned has_real_assignment : 1;\n       unsigned has_real_assign_ref : 1;\n+\n       unsigned has_const_init_ref : 1;\n       unsigned has_complex_init_ref : 1;\n-\n       unsigned has_complex_assign_ref : 1;\n       unsigned has_abstract_assign_ref : 1;\n       unsigned non_aggregate : 1;\n \n       /* The MIPS compiler gets it wrong if this struct also\n \t does not fill out to a multiple of 4 bytes.  Add a\n \t member `dummy' with new bits if you go over the edge.  */\n-      unsigned dummy : 21;\n-\n-      unsigned n_vancestors : 16;\n+      unsigned dummy : 11;\n     } type_flags;\n \n+#ifdef MI_MATRIX\n   int cid;\n+#endif\n   int n_ancestors;\n+  int n_vancestors;\n   int vsize;\n   int max_depth;\n   int vfield_parent;\n \n-  union tree_node *vbinfo[2];\n   union tree_node *baselink_vec;\n   union tree_node *vfields;\n   union tree_node *vbases;\n-  union tree_node *vbase_size;\n \n   union tree_node *tags;\n   char *memoized_table_entry;\n \n   union tree_node *search_slot;\n \n-#ifdef ONLY_INT_FIELDS\n-  unsigned int mode : 8;\n-#else\n-  enum machine_mode mode : 8;\n-#endif\n-\n-  unsigned char size_unit;\n   unsigned char align;\n-  unsigned char sep_unit;\n+  /* Room for another three unsigned chars.  */\n \n-  union tree_node *sep;\n   union tree_node *size;\n \n   union tree_node *base_init_list;\n@@ -526,7 +510,9 @@ struct lang_type\n   union tree_node *binfo_as_list;\n   union tree_node *friend_classes;\n \n+#ifdef MI_MATRIX\n   char *mi_matrix;\n+#endif\n \n   union tree_node *rtti;\n \n@@ -580,21 +566,10 @@ struct lang_type\n /* Nonzero for TREE_LIST or _TYPE node means that this node is class-local.  */\n #define TREE_NONLOCAL_FLAG(NODE) (TREE_LANG_FLAG_0 (NODE))\n \n-/* Nonzero for a _CLASSTYPE node which we know to be private.  */\n-#define TYPE_PRIVATE_P(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.private_attr)\n-\n /* Nonzero means that this _CLASSTYPE node defines ways of converting\n    itself to other types.  */\n #define TYPE_HAS_CONVERSION(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_type_conversion)\n \n-/* Nonzero means that this _CLASSTYPE node can convert itself to an\n-   INTEGER_TYPE.  */\n-#define TYPE_HAS_INT_CONVERSION(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_int_conversion)\n-\n-/* Nonzero means that this _CLASSTYPE node can convert itself to an\n-   REAL_TYPE.  */\n-#define TYPE_HAS_REAL_CONVERSION(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_float_conversion)\n-\n /* Nonzero means that this _CLASSTYPE node overloads operator=(X&).  */\n #define TYPE_HAS_ASSIGN_REF(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_assign_ref)\n #define TYPE_HAS_CONST_ASSIGN_REF(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_const_assign_ref)\n@@ -603,11 +578,6 @@ struct lang_type\n #define TYPE_HAS_INIT_REF(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_init_ref)\n #define TYPE_HAS_CONST_INIT_REF(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_const_init_ref)\n \n-/* Nonzero means that this _CLASSTYPE node has an X(X ...) constructor.\n-   Note that there must be other arguments, or this constructor is flagged\n-   as being erroneous.  */\n-#define TYPE_GETS_INIT_AGGR(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.gets_init_aggr)\n-\n /* Nonzero means that this type is being defined.  I.e., the left brace\n    starting the definition of this type has been seen.  */\n #define TYPE_BEING_DEFINED(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.being_defined)\n@@ -742,7 +712,7 @@ struct lang_type\n    large a multiple-inheritance matrix we need to build to find\n    derivation information.  */\n #define CLASSTYPE_N_SUPERCLASSES(NODE) (TYPE_LANG_SPECIFIC(NODE)->n_ancestors)\n-#define CLASSTYPE_N_VBASECLASSES(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.n_vancestors)\n+#define CLASSTYPE_N_VBASECLASSES(NODE) (TYPE_LANG_SPECIFIC(NODE)->n_vancestors)\n \n /* Record how deep the inheritance is for this class so `void*' conversions\n    are less favorable than a conversion to the most base type.  */\n@@ -757,20 +727,17 @@ struct lang_type\n    it can mean almost anything.  */\n #define CLASSTYPE_MTABLE_ENTRY(NODE) (TYPE_LANG_SPECIFIC(NODE)->memoized_table_entry)\n \n-/* This is the total size of the baseclasses defined for this type.\n-   Needed because it is desirable to layout such information\n-   before beginning to process the class itself, and we\n-   don't want to compute it second time when actually laying\n-   out the type for real.  */\n+/* These are the size, mode and alignment of the type without its\n+   virtual base classes, for when we use this type as a base itself.\n+\n+   CLASSTYPE_SIZE is also used during finish_struct_1 to remember the total\n+   size of the baseclasses defined for the type.  We do this because it is\n+   desirable to layout such information before beginning to process the\n+   class itself, and we don't want to compute it second time when actually\n+   laying out the type for real.  */\n #define CLASSTYPE_SIZE(NODE) (TYPE_LANG_SPECIFIC(NODE)->size)\n-#define CLASSTYPE_SIZE_UNIT(NODE) (TYPE_LANG_SPECIFIC(NODE)->size_unit)\n-#define CLASSTYPE_MODE(NODE) (TYPE_LANG_SPECIFIC(NODE)->mode)\n #define CLASSTYPE_ALIGN(NODE) (TYPE_LANG_SPECIFIC(NODE)->align)\n \n-/* This is the space needed for virtual base classes.  NULL if\n-   there are no virtual basetypes.  */\n-#define CLASSTYPE_VBASE_SIZE(NODE) (TYPE_LANG_SPECIFIC(NODE)->vbase_size)\n-\n /* A cons list of structure elements which either have constructors\n    to be called, or virtual function table pointers which\n    need initializing.  Depending on what is being initialized,\n@@ -827,14 +794,14 @@ struct lang_type\n /* A list of class types with which this type is a friend.  */\n #define CLASSTYPE_FRIEND_CLASSES(NODE) (TYPE_LANG_SPECIFIC(NODE)->friend_classes)\n \n+#ifdef MI_MATRIX\n /* Keep an inheritance lattice around so we can quickly tell whether\n    a type is derived from another or not.  */\n #define CLASSTYPE_MI_MATRIX(NODE) (TYPE_LANG_SPECIFIC(NODE)->mi_matrix)\n+#endif\n \n /* Say whether this node was declared as a \"class\" or a \"struct\".  */\n #define CLASSTYPE_DECLARED_CLASS(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.declared_class)\n-/* whether this can be globalized.  */\n-#define CLASSTYPE_NO_GLOBALIZE(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.no_globalize)\n \n /* Nonzero if this class has const members which have no specified initialization.  */\n #define CLASSTYPE_READONLY_FIELDS_NEED_INIT(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.const_needs_init)\n@@ -858,18 +825,17 @@ struct lang_type\n \f\n /* Additional macros for inheritance information.  */\n \n-#define CLASSTYPE_VBINFO(NODE,VIA_PUBLIC) \\\n-  (TYPE_LANG_SPECIFIC (NODE)->vbinfo[VIA_PUBLIC])\n-\n /* When following an binfo-specific chain, this is the cumulative\n    via-public flag.  */\n #define BINFO_VIA_PUBLIC(NODE) TREE_LANG_FLAG_5 (NODE)\n \n+#ifdef MI_MATRIX\n /* When building a matrix to determine by a single lookup\n    whether one class is derived from another or not,\n    this field is the index of the class in the table.  */\n #define CLASSTYPE_CID(NODE) (TYPE_LANG_SPECIFIC(NODE)->cid)\n #define BINFO_CID(NODE) CLASSTYPE_CID(BINFO_TYPE(NODE))\n+#endif\n \n /* Nonzero means marked by DFS or BFS search, including searches\n    by `get_binfo' and `get_base_distance'.  */"}, {"sha": "3a75da766bc1c3bf2de4456b0dff35093958808c", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 14, "deletions": 23, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b41abe6683830ae22978f43f085a59094f5b062/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b41abe6683830ae22978f43f085a59094f5b062/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=0b41abe6683830ae22978f43f085a59094f5b062", "patch": "@@ -10372,32 +10372,23 @@ grok_ctor_properties (ctype, decl)\n     }\n \n   if (TREE_CODE (parmtype) == REFERENCE_TYPE\n-      && TYPE_MAIN_VARIANT (TREE_TYPE (parmtype)) == ctype)\n-    {\n-      if (TREE_CHAIN (parmtypes) == NULL_TREE\n+      && TYPE_MAIN_VARIANT (TREE_TYPE (parmtype)) == ctype\n+      && (TREE_CHAIN (parmtypes) == NULL_TREE\n \t  || TREE_CHAIN (parmtypes) == void_list_node\n-\t  || TREE_PURPOSE (TREE_CHAIN (parmtypes)))\n-\t{\n-\t  TYPE_HAS_INIT_REF (ctype) = 1;\n-\t  if (TYPE_READONLY (TREE_TYPE (parmtype)))\n-\t    TYPE_HAS_CONST_INIT_REF (ctype) = 1;\n-\t}\n-      else\n-\tTYPE_GETS_INIT_AGGR (ctype) = 1;\n+\t  || TREE_PURPOSE (TREE_CHAIN (parmtypes))))\n+    {\n+      TYPE_HAS_INIT_REF (ctype) = 1;\n+      if (TYPE_READONLY (TREE_TYPE (parmtype)))\n+\tTYPE_HAS_CONST_INIT_REF (ctype) = 1;\n     }\n-  else if (TYPE_MAIN_VARIANT (parmtype) == ctype)\n+  else if (TYPE_MAIN_VARIANT (parmtype) == ctype\n+\t   && TREE_CHAIN (parmtypes) != NULL_TREE\n+\t   && TREE_CHAIN (parmtypes) == void_list_node)\n     {\n-      if (TREE_CHAIN (parmtypes) != NULL_TREE\n-\t  && TREE_CHAIN (parmtypes) == void_list_node)\n-\t{\n-\t  cp_error (\"invalid constructor; you probably meant `%T (const %T&)'\",\n-\t\t    ctype, ctype);\n-\t  SET_IDENTIFIER_ERROR_LOCUS (DECL_NAME (decl), ctype);\n-\n-\t  return 0;\n-\t}\n-      else\n-\tTYPE_GETS_INIT_AGGR (ctype) = 1;\n+      cp_error (\"invalid constructor; you probably meant `%T (const %T&)'\",\n+\t\tctype, ctype);\n+      SET_IDENTIFIER_ERROR_LOCUS (DECL_NAME (decl), ctype);\n+      return 0;\n     }\n   else if (TREE_CODE (parmtype) == VOID_TYPE\n \t   || TREE_PURPOSE (parmtypes) != NULL_TREE)"}, {"sha": "8340f095ba25b70996c78a3e1676c5dcb4ff909c", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b41abe6683830ae22978f43f085a59094f5b062/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b41abe6683830ae22978f43f085a59094f5b062/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=0b41abe6683830ae22978f43f085a59094f5b062", "patch": "@@ -853,8 +853,6 @@ grok_x_components (specs, components)\n \t    tcode = signature_type_node;\n \t  \n \t  t = xref_tag (tcode, TYPE_IDENTIFIER (t), NULL_TREE, 0);\n-\t  if (TYPE_CONTEXT (t))\n-\t    CLASSTYPE_NO_GLOBALIZE (t) = 1;\n \t  return NULL_TREE;\n \t  break;\n \n@@ -866,8 +864,6 @@ grok_x_components (specs, components)\n \t    tcode = enum_type_node;\n \n \t  t = xref_tag (tcode, TYPE_IDENTIFIER (t), NULL_TREE, 0);\n-\t  if (TREE_CODE (t) == UNION_TYPE && TYPE_CONTEXT (t))\n-\t    CLASSTYPE_NO_GLOBALIZE (t) = 1;\n \t  if (TREE_CODE (t) == UNION_TYPE\n \t      && ANON_AGGRNAME_P (TYPE_IDENTIFIER (t)))\n \t    {"}, {"sha": "9d724a535ff7f91a1d528c4d9a8a5ab0a09c36fe", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b41abe6683830ae22978f43f085a59094f5b062/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b41abe6683830ae22978f43f085a59094f5b062/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=0b41abe6683830ae22978f43f085a59094f5b062", "patch": "@@ -4442,7 +4442,6 @@ make_lang_type (code)\n   CLASSTYPE_AS_LIST (t) = build_expr_list (NULL_TREE, t);\n   SET_CLASSTYPE_INTERFACE_UNKNOWN_X (t, interface_unknown);\n   CLASSTYPE_INTERFACE_ONLY (t) = interface_only;\n-  CLASSTYPE_VBASE_SIZE (t) = integer_zero_node;\n   TYPE_BINFO (t) = make_binfo (integer_zero_node, t, NULL_TREE, NULL_TREE,\n \t\t\t       NULL_TREE);\n   CLASSTYPE_BINFO_AS_LIST (t) = build_tree_list (NULL_TREE, TYPE_BINFO (t));"}, {"sha": "1c632f73547c6a166582a3201c48f3f8d1675f56", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b41abe6683830ae22978f43f085a59094f5b062/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b41abe6683830ae22978f43f085a59094f5b062/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=0b41abe6683830ae22978f43f085a59094f5b062", "patch": "@@ -3432,7 +3432,6 @@ instantiate_class_template (type)\n   TYPE_HAS_ABSTRACT_ASSIGN_REF (type) = TYPE_HAS_ABSTRACT_ASSIGN_REF (pattern);\n   TYPE_HAS_INIT_REF (type) = TYPE_HAS_INIT_REF (pattern);\n   TYPE_HAS_CONST_INIT_REF (type) = TYPE_HAS_CONST_INIT_REF (pattern);\n-  TYPE_GETS_INIT_AGGR (type) = TYPE_GETS_INIT_AGGR (pattern);\n   TYPE_HAS_DEFAULT_CONSTRUCTOR (type) = TYPE_HAS_DEFAULT_CONSTRUCTOR (pattern);\n   TYPE_HAS_CONVERSION (type) = TYPE_HAS_CONVERSION (pattern);\n   TYPE_USES_COMPLEX_INHERITANCE (type)"}, {"sha": "fffcdddbf774b85121342ec0b11843c04571f7b8", "filename": "gcc/cp/ptree.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b41abe6683830ae22978f43f085a59094f5b062/gcc%2Fcp%2Fptree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b41abe6683830ae22978f43f085a59094f5b062/gcc%2Fcp%2Fptree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fptree.c?ref=0b41abe6683830ae22978f43f085a59094f5b062", "patch": "@@ -95,10 +95,6 @@ print_lang_type (file, node, indent)\n     fputs (\" X()\", file);\n   if (TYPE_HAS_CONVERSION (node))\n     fputs (\" has-type-conversion\", file);\n-  if (TYPE_HAS_INT_CONVERSION (node))\n-    fputs (\" has-int-conversion\", file);\n-  if (TYPE_HAS_REAL_CONVERSION (node))\n-    fputs (\" has-float-conversion\", file);\n   if (TYPE_HAS_INIT_REF (node))\n     {\n       if (TYPE_HAS_CONST_INIT_REF (node))\n@@ -118,8 +114,6 @@ print_lang_type (file, node, indent)\n     fputs (\" has=\", file);\n   if (TYPE_HAS_ASSIGN_REF (node))\n     fputs (\" this=(X&)\", file);\n-  if (TYPE_GETS_INIT_AGGR (node))\n-    fputs (\" gets X(X, ...)\", file);\n   if (TYPE_OVERLOADS_CALL_EXPR (node))\n     fputs (\" op()\", file);\n   if (TYPE_OVERLOADS_ARRAY_REF (node))"}, {"sha": "2f6dbe623bcbe76216901c5691b560d7b2fb71af", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 31, "deletions": 79, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b41abe6683830ae22978f43f085a59094f5b062/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b41abe6683830ae22978f43f085a59094f5b062/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=0b41abe6683830ae22978f43f085a59094f5b062", "patch": "@@ -639,28 +639,23 @@ layout_vbasetypes (rec, max)\n      The TREE_VALUE slot holds the virtual baseclass type.  */\n   tree vbase_types = get_vbase_types (rec);\n \n-#ifdef STRUCTURE_SIZE_BOUNDARY\n-  unsigned int record_align = MAX (STRUCTURE_SIZE_BOUNDARY, TYPE_ALIGN (rec));\n-#else\n   unsigned int record_align = MAX (BITS_PER_UNIT, TYPE_ALIGN (rec));\n-#endif\n   unsigned int desired_align;\n \n-  /* Record size so far is CONST_SIZE + VAR_SIZE bits,\n-     where CONST_SIZE is an integer\n-     and VAR_SIZE is a tree expression.\n-     If VAR_SIZE is null, the size is just CONST_SIZE.\n-     Naturally we try to avoid using VAR_SIZE.  */\n+  /* Record size so far is CONST_SIZE bits, where CONST_SIZE is an integer.  */\n   register unsigned int const_size = 0;\n-  register tree var_size = 0;\n   unsigned int nonvirtual_const_size;\n \n+#ifdef STRUCTURE_SIZE_BOUNDARY\n+  /* Packed structures don't need to have minimum size.  */\n+  if (! TYPE_PACKED (rec))\n+    record_align = MAX (record_align, STRUCTURE_SIZE_BOUNDARY);\n+#endif\n+\n   CLASSTYPE_VBASECLASSES (rec) = vbase_types;\n \n-  if (TREE_CODE (TYPE_SIZE (rec)) == INTEGER_CST)\n-    const_size = TREE_INT_CST_LOW (TYPE_SIZE (rec));\n-  else\n-    var_size = TYPE_SIZE (rec);\n+  my_friendly_assert (TREE_CODE (TYPE_SIZE (rec)) == INTEGER_CST, 19970302);\n+  const_size = TREE_INT_CST_LOW (TYPE_SIZE (rec));\n \n   nonvirtual_const_size = const_size;\n \n@@ -686,18 +681,10 @@ layout_vbasetypes (rec, max)\n \tmax = CLASSTYPE_VSIZE (basetype);\n       BINFO_OFFSET (vbase_types) = offset;\n \n-      if (TREE_CODE (TYPE_SIZE (basetype)) == INTEGER_CST)\n-\t{\n-\t  /* Every virtual baseclass takes a least a UNIT, so that we can\n-\t     take it's address and get something different for each base.  */\n-\t  const_size += MAX (BITS_PER_UNIT,\n-\t\t\t     TREE_INT_CST_LOW (TYPE_SIZE (basetype))\n-\t\t\t     - TREE_INT_CST_LOW (CLASSTYPE_VBASE_SIZE (basetype)));\n-\t}\n-      else if (var_size == 0)\n-\tvar_size = TYPE_SIZE (basetype);\n-      else\n-\tvar_size = size_binop (PLUS_EXPR, var_size, TYPE_SIZE (basetype));\n+      /* Every virtual baseclass takes a least a UNIT, so that we can\n+\t take it's address and get something different for each base.  */\n+      const_size += MAX (BITS_PER_UNIT,\n+\t\t\t TREE_INT_CST_LOW (CLASSTYPE_SIZE (basetype)));\n \n       vbase_types = TREE_CHAIN (vbase_types);\n     }\n@@ -715,11 +702,7 @@ layout_vbasetypes (rec, max)\n    here, as that is for this class, without any virtual base classes.  */\n   TYPE_ALIGN (rec) = record_align;\n   if (const_size != nonvirtual_const_size)\n-    {\n-      CLASSTYPE_VBASE_SIZE (rec)\n-\t= size_int (const_size - nonvirtual_const_size);\n-      TYPE_SIZE (rec) = size_int (const_size);\n-    }\n+    TYPE_SIZE (rec) = size_int (const_size);\n \n   /* Now propagate offset information throughout the lattice\n      under the vbase type.  */\n@@ -769,7 +752,7 @@ layout_vbasetypes (rec, max)\n    TYPE_BINFO (REC) should be NULL_TREE on entry, and this routine\n    creates a list of base_binfos in TYPE_BINFO (REC) from BINFOS.\n \n-   Returns list of virtual base classes in a FIELD_DECL chain.  */\n+   Returns list of virtual base class pointers in a FIELD_DECL chain.  */\n \n tree\n layout_basetypes (rec, binfos)\n@@ -778,57 +761,33 @@ layout_basetypes (rec, binfos)\n   /* Chain to hold all the new FIELD_DECLs which point at virtual\n      base classes.  */\n   tree vbase_decls = NULL_TREE;\n-\n-#ifdef STRUCTURE_SIZE_BOUNDARY\n-  unsigned record_align = MAX (STRUCTURE_SIZE_BOUNDARY, TYPE_ALIGN (rec));\n-#else\n   unsigned record_align = MAX (BITS_PER_UNIT, TYPE_ALIGN (rec));\n-#endif\n-\n-  /* Record size so far is CONST_SIZE + VAR_SIZE bits, where CONST_SIZE is\n-     an integer and VAR_SIZE is a tree expression.  If VAR_SIZE is null,\n-     the size is just CONST_SIZE.  Naturally we try to avoid using\n-     VAR_SIZE.  And so far, we've been successful.  */\n-#if 0\n-  register tree var_size = 0;\n-#endif\n \n+  /* Record size so far is CONST_SIZE bits, where CONST_SIZE is an integer.  */\n   register unsigned const_size = 0;\n   int i, n_baseclasses = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n \n+#ifdef STRUCTURE_SIZE_BOUNDARY\n+  /* Packed structures don't need to have minimum size.  */\n+  if (! TYPE_PACKED (rec))\n+    record_align = MAX (record_align, STRUCTURE_SIZE_BOUNDARY);\n+#endif\n+\n   /* Handle basetypes almost like fields, but record their\n      offsets differently.  */\n \n   for (i = 0; i < n_baseclasses; i++)\n     {\n-      int inc, int_vbase_size;\n+      int inc;\n       unsigned int desired_align;\n       register tree base_binfo = TREE_VEC_ELT (binfos, i);\n       register tree basetype = BINFO_TYPE (base_binfo);\n       tree decl, offset;\n \n       if (TYPE_SIZE (basetype) == 0)\n-\t{\n-#if 0\n-\t  /* This error is now reported in xref_tag, thus giving better\n-\t     location information.  */\n-\t  error_with_aggr_type (base_binfo,\n-\t\t\t\t\"base class `%s' has incomplete type\");\n-\n-\t  TREE_VIA_PUBLIC (base_binfo) = 1;\n-\t  TREE_VIA_PROTECTED (base_binfo) = 0;\n-\t  TREE_VIA_VIRTUAL (base_binfo) = 0;\n-\n-\t  /* Should handle this better so that\n-\n-\t     class A;\n-\t     class B: private A { virtual void F(); };\n-\n-\t     does not dump core when compiled.  */\n-\t  my_friendly_abort (121);\n-#endif\n-\t  continue;\n-\t}\n+\t/* This error is now reported in xref_tag, thus giving better\n+\t   location information.  */\n+\tcontinue;\n \n       /* All basetypes are recorded in the association list of the\n \t derived type.  */\n@@ -906,20 +865,13 @@ layout_basetypes (rec, binfos)\n \n       /* Add only the amount of storage not present in\n \t the virtual baseclasses.  */\n+      inc = MAX (record_align, TREE_INT_CST_LOW (CLASSTYPE_SIZE (basetype)));\n \n-      int_vbase_size = TREE_INT_CST_LOW (CLASSTYPE_VBASE_SIZE (basetype));\n-      if (TREE_INT_CST_LOW (TYPE_SIZE (basetype)) > int_vbase_size)\n-\t{\n-\t  inc = MAX (record_align,\n-\t\t     (TREE_INT_CST_LOW (TYPE_SIZE (basetype))\n-\t\t      - int_vbase_size));\n-\n-\t  /* Record must have at least as much alignment as any field.  */\n-\t  desired_align = TYPE_ALIGN (basetype);\n-\t  record_align = MAX (record_align, desired_align);\n+      /* Record must have at least as much alignment as any field.  */\n+      desired_align = TYPE_ALIGN (basetype);\n+      record_align = MAX (record_align, desired_align);\n \n-\t  const_size += inc;\n-\t}\n+      const_size += inc;\n     }\n \n   if (const_size)"}]}