{"sha": "1ca09b48783dfa5f4e4037b2c95681ea7c33626f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWNhMDliNDg3ODNkZmE1ZjRlNDAzN2IyYzk1NjgxZWE3YzMzNjI2Zg==", "commit": {"author": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "2001-08-29T02:22:52Z"}, "committer": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "2001-08-29T02:22:52Z"}, "message": "re PR java/4141 (GCJ compiles illegal code without complaining.)\n\n2001-08-27  Alexandre Petit-Bianco  <apbianco@redhat.com>\n\n\t* parse.y (resolve_qualified_expression_name): Handle unresolved\n\tqualified expressions, prevent numerical qualifiers, fixed typo.\n\tFixes PR java/4141\n\n(http://gcc.gnu.org/ml/gcc-patches/2001-08/msg01644.html)\n\nFrom-SVN: r45251", "tree": {"sha": "be3df2886b88b26f2cbf870c1b1bebef06195643", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/be3df2886b88b26f2cbf870c1b1bebef06195643"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1ca09b48783dfa5f4e4037b2c95681ea7c33626f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ca09b48783dfa5f4e4037b2c95681ea7c33626f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ca09b48783dfa5f4e4037b2c95681ea7c33626f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ca09b48783dfa5f4e4037b2c95681ea7c33626f/comments", "author": null, "committer": null, "parents": [{"sha": "51a25585ff13a61c901698e314cbfc2150028f74", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51a25585ff13a61c901698e314cbfc2150028f74", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51a25585ff13a61c901698e314cbfc2150028f74"}], "stats": {"total": 25, "additions": 21, "deletions": 4}, "files": [{"sha": "d535776b055bbb1a706286392b1f89bb6d1aab20", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ca09b48783dfa5f4e4037b2c95681ea7c33626f/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ca09b48783dfa5f4e4037b2c95681ea7c33626f/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=1ca09b48783dfa5f4e4037b2c95681ea7c33626f", "patch": "@@ -8,6 +8,12 @@\n \t* jcf-write.c (generate_bytecode_insns): Generate an integer to\n \treal conversion for increments and decrements of reals.\n \n+2001-08-27  Alexandre Petit-Bianco  <apbianco@redhat.com>\n+\n+\t* parse.y (resolve_qualified_expression_name): Handle unresolved\n+\tqualified expressions, prevent numerical qualifiers, fixed typo.\n+\tFixes PR java/4141\n+\n 2001-08-24  Alexandre Petit-Bianco  <apbianco@redhat.com>\n \n \t* parse.y (check_deprecation): Handle TYPE_DECL in a special case,\n@@ -37,6 +43,7 @@\n \tdescriptor.\n \t* class.c (make_method_value): Compute `throws' field for method.\n \n+>>>>>>> 1.790\n 2001-08-22  Alexandre Petit-Bianco  <apbianco@redhat.com>\n \n \t* parse.y (resolve_inner_class): Keep local_enclosing to NULL if\n@@ -62,6 +69,7 @@\n \tsuperclass if necessary.\n \tFixes PR java/4007\n \n+>>>>>>> 1.785\n 2001-08-16  Tom Tromey  <tromey@redhat.com>\n \n \t* jcf-dump.c (main): Updated for change to jcf_path_seal."}, {"sha": "7567c3d2080264dbe340e74b3381d3bd67005034", "filename": "gcc/java/parse.y", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ca09b48783dfa5f4e4037b2c95681ea7c33626f/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ca09b48783dfa5f4e4037b2c95681ea7c33626f/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=1ca09b48783dfa5f4e4037b2c95681ea7c33626f", "patch": "@@ -9617,10 +9617,9 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n \n       /* We have a type name. It's been already resolved when the\n \t expression was qualified. */\n-      else if (RESOLVE_TYPE_NAME_P (qual_wfl))\n+      else if (RESOLVE_TYPE_NAME_P (qual_wfl) && QUAL_RESOLUTION (q))\n \t{\n-\t  if (!(decl = QUAL_RESOLUTION (q)))\n-\t    return 1;\t\t/* Error reported already */\n+\t  decl = QUAL_RESOLUTION (q);\n \n \t  /* Sneak preview. If next we see a `new', we're facing a\n \t     qualification with resulted in a type being selected\n@@ -9648,7 +9647,7 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n \t  type = TREE_TYPE (decl);\n \t  from_type = 1;\n \t}\n-      /* We resolve and expression name */\n+      /* We resolve an expression name */\n       else \n \t{\n \t  tree field_decl = NULL_TREE;\n@@ -9684,6 +9683,16 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n \t\t}\n \t    }\n \n+\t  /* Report and error if we're using a numerical litteral as a\n+             qualifier. It can only be an INTEGER_CST. */\n+\t  else if (TREE_CODE (qual_wfl) == INTEGER_CST)\n+\t    {\n+\t      parse_error_context\n+\t\t(wfl, \"Can't use type `%s' as a qualifier\",\n+\t\t lang_printable_name (TREE_TYPE (qual_wfl), 0));\n+\t      return 1;\n+\t    }\n+\n \t  /* We have to search for a field, knowing the type of its\n              container. The flag FROM_TYPE indicates that we resolved\n              the last member of the expression as a type name, which"}]}