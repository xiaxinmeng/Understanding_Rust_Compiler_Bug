{"sha": "1eff5289b273041c9d71a4829c2600d283186ab6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWVmZjUyODliMjczMDQxYzlkNzFhNDgyOWMyNjAwZDI4MzE4NmFiNg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-06-03T11:29:32Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-06-03T11:32:08Z"}, "message": "Fix miscompilation of predicate on bit-packed array types\n\nThis is a regression present on the mainline and 11 branch in the form of a\nmiscompilation by the new mod/ref IPA pass of code that passes constrained\nbit-packed array objets in a call to a subprograms taking unconstrained\nbit-packed array parameters, which occurs for predicate on bit-packed array\ntypes for example.\n\ngcc/ada/\n\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Array_Type>: Add PAT\n\tlocal constant and use it throughout.  If it is set, use a ref-all\n\tpointer type for the pointer-to-array field of the fat pointer type.\n\t<E_Array_Subtype>: Add PAT local constant and use it throughout.\ngcc/testsuite/\n\t* gnat.dg/bit_packed_array6.adb: New test.\n\t* gnat.dg/bit_packed_array6_pkg.ads: New helper.", "tree": {"sha": "53475464d16a5ccbeed81abf2cd3769041b4aa9b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/53475464d16a5ccbeed81abf2cd3769041b4aa9b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1eff5289b273041c9d71a4829c2600d283186ab6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1eff5289b273041c9d71a4829c2600d283186ab6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1eff5289b273041c9d71a4829c2600d283186ab6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1eff5289b273041c9d71a4829c2600d283186ab6/comments", "author": null, "committer": null, "parents": [{"sha": "592ed7db12ed0d6c71bca0cbfef6dcdf383bc24f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/592ed7db12ed0d6c71bca0cbfef6dcdf383bc24f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/592ed7db12ed0d6c71bca0cbfef6dcdf383bc24f"}], "stats": {"total": 60, "additions": 45, "deletions": 15}, "files": [{"sha": "6fc94dda83b1746395b6a51cf0724c06a147cd0d", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eff5289b273041c9d71a4829c2600d283186ab6/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eff5289b273041c9d71a4829c2600d283186ab6/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=1eff5289b273041c9d71a4829c2600d283186ab6", "patch": "@@ -2100,6 +2100,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \n     case E_Array_Type:\n       {\n+\tconst Entity_Id PAT = Packed_Array_Impl_Type (gnat_entity);\n \tconst bool convention_fortran_p\n \t  = (Convention (gnat_entity) == Convention_Fortran);\n \tconst int ndim = Number_Dimensions (gnat_entity);\n@@ -2203,16 +2204,16 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t  }\n \n \t/* If the GNAT encodings are used, give the fat pointer type a name.\n-\t   If this is a packed array, tell the debugger how to interpret the\n-\t   underlying bits by fetching that of the implementation type.  But\n-\t   in any case, mark it as artificial so the debugger can skip it.  */\n+\t   If this is a packed type implemented specially, tell the debugger\n+\t   how to interpret the underlying bits by fetching the name of the\n+\t   implementation type.  But, in any case, mark it as artificial so\n+\t   the debugger can skip it.  */\n \tconst Entity_Id gnat_name\n-\t  = (Present (Packed_Array_Impl_Type (gnat_entity))\n-\t     && gnat_encodings != DWARF_GNAT_ENCODINGS_MINIMAL)\n-\t    ? Packed_Array_Impl_Type (gnat_entity)\n+\t  = Present (PAT) && gnat_encodings != DWARF_GNAT_ENCODINGS_MINIMAL\n+\t    ? PAT\n \t    : gnat_entity;\n \ttree xup_name\n-\t  = (gnat_encodings != DWARF_GNAT_ENCODINGS_MINIMAL)\n+\t  = gnat_encodings != DWARF_GNAT_ENCODINGS_MINIMAL\n \t    ? create_concat_name (gnat_name, \"XUP\")\n \t    : gnu_entity_name;\n \tcreate_type_decl (xup_name, gnu_fat_type, true, debug_info_p,\n@@ -2347,9 +2348,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \n \t/* If this is a packed type implemented specially, then process the\n \t   implementation type so it is elaborated in the proper scope.  */\n-\tif (Present (Packed_Array_Impl_Type (gnat_entity)))\n-\t  gnat_to_gnu_entity (Packed_Array_Impl_Type (gnat_entity), NULL_TREE,\n-\t\t\t      false);\n+\tif (Present (PAT))\n+\t  gnat_to_gnu_entity (PAT, NULL_TREE, false);\n \n \t/* Otherwise, if an alignment is specified, use it if valid and, if\n \t   the alignment was requested with an explicit clause, state so.  */\n@@ -2374,8 +2374,15 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t  tem = change_qualified_type (tem, TYPE_QUAL_VOLATILE);\n \n \t/* Adjust the type of the pointer-to-array field of the fat pointer\n-\t   and record the aliasing relationships if necessary.  */\n-\tTREE_TYPE (TYPE_FIELDS (gnu_fat_type)) = build_pointer_type (tem);\n+\t   and record the aliasing relationships if necessary.  If this is\n+\t   a packed type implemented specially, then use a ref-all pointer\n+\t   type since the implementation type may vary between constrained\n+\t   subtypes and unconstrained base type.  */\n+\tif (Present (PAT))\n+\t  TREE_TYPE (TYPE_FIELDS (gnu_fat_type))\n+\t    = build_pointer_type_for_mode (tem, ptr_mode, true);\n+\telse\n+\t  TREE_TYPE (TYPE_FIELDS (gnu_fat_type)) = build_pointer_type (tem);\n \tif (TYPE_ALIAS_SET_KNOWN_P (gnu_fat_type))\n \t  record_component_aliases (gnu_fat_type);\n \n@@ -2439,6 +2446,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t;\n       else\n \t{\n+\t  const Entity_Id PAT = Packed_Array_Impl_Type (gnat_entity);\n \t  Entity_Id gnat_index, gnat_base_index;\n \t  const bool convention_fortran_p\n \t    = (Convention (gnat_entity) == Convention_Fortran);\n@@ -2844,7 +2852,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \n \t  /* If this is a packed type implemented specially, then replace our\n \t     type with the implementation type.  */\n-\t  if (Present (Packed_Array_Impl_Type (gnat_entity)))\n+\t  if (Present (PAT))\n \t    {\n \t      /* First finish the type we had been making so that we output\n \t\t debugging information for it.  */\n@@ -2869,8 +2877,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t\t this type again.  */\n \t      save_gnu_tree (gnat_entity, gnu_tmp_decl, false);\n \n-\t      gnu_type\n-\t\t= gnat_to_gnu_type (Packed_Array_Impl_Type (gnat_entity));\n+\t      gnu_type = gnat_to_gnu_type (PAT);\n \t      save_gnu_tree (gnat_entity, NULL_TREE, false);\n \n \t      /* Set the ___XP suffix for GNAT encodings.  */"}, {"sha": "84f7a4ba4a1eb0486d5f8d93c9ae41ee46e11bf8", "filename": "gcc/testsuite/gnat.dg/bit_packed_array6.adb", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eff5289b273041c9d71a4829c2600d283186ab6/gcc%2Ftestsuite%2Fgnat.dg%2Fbit_packed_array6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eff5289b273041c9d71a4829c2600d283186ab6/gcc%2Ftestsuite%2Fgnat.dg%2Fbit_packed_array6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fbit_packed_array6.adb?ref=1eff5289b273041c9d71a4829c2600d283186ab6", "patch": "@@ -0,0 +1,10 @@\n+-- { dg-do run }\n+-- { dg-options \"-O2 -gnata -gnatVa\" }\n+\n+with Bit_Packed_Array6_Pkg; use Bit_Packed_Array6_Pkg;\n+\n+procedure Bit_Packed_Array6 is\n+  B : constant Boolean := Everywhere (K_Configuration);\n+begin\n+  null;\n+end;"}, {"sha": "4eb1516a47212a13c5e61765607fcbc5550d5da8", "filename": "gcc/testsuite/gnat.dg/bit_packed_array6_pkg.ads", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eff5289b273041c9d71a4829c2600d283186ab6/gcc%2Ftestsuite%2Fgnat.dg%2Fbit_packed_array6_pkg.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eff5289b273041c9d71a4829c2600d283186ab6/gcc%2Ftestsuite%2Fgnat.dg%2Fbit_packed_array6_pkg.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fbit_packed_array6_pkg.ads?ref=1eff5289b273041c9d71a4829c2600d283186ab6", "patch": "@@ -0,0 +1,13 @@\n+package Bit_Packed_Array6_Pkg is\n+\n+   type Project_Kind is\n+     (K_Configuration, K_Abstract,\n+      K_Standard, K_Library, K_Aggregate, K_Aggregate_Library);\n+\n+   type Projects_Kind is array (Project_Kind) of Boolean\n+     with Pack,\n+          Dynamic_Predicate => Projects_Kind /= (Project_Kind => False);\n+\n+   Everywhere : constant Projects_Kind := (others => True);\n+\n+end Bit_Packed_Array6_Pkg;"}]}