{"sha": "ad7ee6f8d5a0fda91de731835f909a3c330db24d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWQ3ZWU2ZjhkNWEwZmRhOTFkZTczMTgzNWY5MDlhM2MzMzBkYjI0ZA==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2008-05-03T15:11:33Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2008-05-03T15:11:33Z"}, "message": "re PR fortran/33268 (read ('(f3.3)'), a  rejected due to the extra (...))\n\n2008-05-03  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n\tPR fortran/33268\n\t* gfortran.h: Add extra_comma pointer to gfc_dt structure. Add iokind to\n\tgfc_expr value union. Add io_kind enum to here from io.c.\n\t* io.c (gfc_free_dt): Free extra_comma.\n\t(gfc_resolve_dt): If an extra comma was encountered and io_unit is type\n\tBT_CHARACTER, resolve to format_expr and set default unit.  Error if\n\tio_kind is M_WRITE. (match_io):  Match the extra comma and set new\n\tpointer, extra_comma.\n\nFrom-SVN: r134900", "tree": {"sha": "3a2e67ce85966590b4fb8f93a08d35134b0a8ba0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3a2e67ce85966590b4fb8f93a08d35134b0a8ba0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ad7ee6f8d5a0fda91de731835f909a3c330db24d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad7ee6f8d5a0fda91de731835f909a3c330db24d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad7ee6f8d5a0fda91de731835f909a3c330db24d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad7ee6f8d5a0fda91de731835f909a3c330db24d/comments", "author": null, "committer": null, "parents": [{"sha": "1183512494cf8f3ca0b5460808d563ec0f8f14ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1183512494cf8f3ca0b5460808d563ec0f8f14ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1183512494cf8f3ca0b5460808d563ec0f8f14ec"}], "stats": {"total": 92, "additions": 77, "deletions": 15}, "files": [{"sha": "9029fc0e622a3df2d903a0338de0946ce1fdceb6", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad7ee6f8d5a0fda91de731835f909a3c330db24d/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad7ee6f8d5a0fda91de731835f909a3c330db24d/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=ad7ee6f8d5a0fda91de731835f909a3c330db24d", "patch": "@@ -1,3 +1,14 @@\n+2008-05-03  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR fortran/33268\n+\t* gfortran.h: Add extra_comma pointer to gfc_dt structure. Add iokind to\n+\tgfc_expr value union. Add io_kind enum to here from io.c.\n+\t* io.c (gfc_free_dt): Free extra_comma.\n+\t(gfc_resolve_dt): If an extra comma was encountered and io_unit is type\n+\tBT_CHARACTER, resolve to format_expr and set default unit.  Error if\n+\tio_kind is M_WRITE. (match_io):  Match the extra comma and set new\n+\tpointer, extra_comma.\n+\n 2008-05-01  Bud Davis  <bdavis9659@sbcglobal.net>\n \n \tPR35940/Fortran"}, {"sha": "f6a7c54123b8f8ef19dc492b4c352e8bbc072373", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad7ee6f8d5a0fda91de731835f909a3c330db24d/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad7ee6f8d5a0fda91de731835f909a3c330db24d/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=ad7ee6f8d5a0fda91de731835f909a3c330db24d", "patch": "@@ -103,6 +103,12 @@ mstring;\n \n /*************************** Enums *****************************/\n \n+/* Used when matching and resolving data I/O transfer statements.  */\n+\n+typedef enum\n+{ M_READ, M_WRITE, M_PRINT, M_INQUIRE }\n+io_kind;\n+\n /* The author remains confused to this day about the convention of\n    returning '0' for 'SUCCESS'... or was it the other way around?  The\n    following enum makes things much more readable.  We also start\n@@ -1444,6 +1450,8 @@ typedef struct gfc_expr\n   {\n     int logical;\n \n+    io_kind iokind;\n+\n     mpz_t integer;\n \n     mpfr_t real;\n@@ -1684,7 +1692,7 @@ typedef struct\n {\n   gfc_expr *io_unit, *format_expr, *rec, *advance, *iostat, *size, *iomsg,\n \t   *id, *pos, *asynchronous, *blank, *decimal, *delim, *pad, *round,\n-\t   *sign;\n+\t   *sign, *extra_comma;\n \n   gfc_symbol *namelist;\n   /* A format_label of `format_asterisk' indicates the \"*\" format */"}, {"sha": "4eb76309ede169f173cb896385b307f51134934a", "filename": "gcc/fortran/io.c", "status": "modified", "additions": 57, "deletions": 14, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad7ee6f8d5a0fda91de731835f909a3c330db24d/gcc%2Ffortran%2Fio.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad7ee6f8d5a0fda91de731835f909a3c330db24d/gcc%2Ffortran%2Fio.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fio.c?ref=ad7ee6f8d5a0fda91de731835f909a3c330db24d", "patch": "@@ -2143,11 +2143,6 @@ gfc_match_flush (void)\n \n /******************** Data Transfer Statements *********************/\n \n-typedef enum\n-{ M_READ, M_WRITE, M_PRINT, M_INQUIRE }\n-io_kind;\n-\n-\n /* Return a default unit number.  */\n \n static gfc_expr *\n@@ -2421,6 +2416,7 @@ gfc_free_dt (gfc_dt *dt)\n   gfc_free_expr (dt->round);\n   gfc_free_expr (dt->blank);\n   gfc_free_expr (dt->decimal);\n+  gfc_free_expr (dt->extra_comma);\n   gfc_free (dt);\n }\n \n@@ -2451,9 +2447,40 @@ gfc_resolve_dt (gfc_dt *dt)\n       && (e->ts.type != BT_INTEGER\n \t  && (e->ts.type != BT_CHARACTER || e->expr_type != EXPR_VARIABLE)))\n     {\n-      gfc_error (\"UNIT specification at %L must be an INTEGER expression \"\n-\t\t \"or a CHARACTER variable\", &e->where);\n-      return FAILURE;\n+      /* If there is no extra comma signifying the \"format\" form of the IO\n+\t statement, then this must be an error.  */\n+      if (!dt->extra_comma)\n+\t{\n+\t  gfc_error (\"UNIT specification at %L must be an INTEGER expression \"\n+\t\t     \"or a CHARACTER variable\", &e->where);\n+\t  return FAILURE;\n+\t}\n+      else\n+\t{\n+\t  /* At this point, we have an extra comma.  If io_unit has arrived as\n+\t     type chracter, we assume its really the \"format\" form of the I/O\n+\t     statement.  We set the io_unit to the default unit and format to\n+\t     the chracter expression.  See F95 Standard section 9.4.  */\n+\t  io_kind k;\n+\t  k = dt->extra_comma->value.iokind;\n+\t  if (e->ts.type == BT_CHARACTER && (k == M_READ || k == M_PRINT))\n+\t    {\n+\t      dt->format_expr = dt->io_unit;\n+\t      dt->io_unit = default_unit (k);\n+\n+\t      /* Free this pointer now so that a warning/error is not triggered\n+\t\t below for the \"Extension\".  */\n+\t      gfc_free_expr (dt->extra_comma);\n+\t      dt->extra_comma = NULL;\n+\t    }\n+\n+\t  if (k == M_WRITE)\n+\t    {\n+\t      gfc_error (\"Invalid form of WRITE statement at %L, UNIT required\",\n+\t\t\t &dt->extra_comma->where);\n+\t      return FAILURE;\n+\t    }\n+\t}\n     }\n \n   if (e->ts.type == BT_CHARACTER)\n@@ -2471,6 +2498,11 @@ gfc_resolve_dt (gfc_dt *dt)\n       return FAILURE;\n     }\n \n+  if (dt->extra_comma\n+      && gfc_notify_std (GFC_STD_GNU, \"Extension: Comma before i/o \"\n+\t\t\t \"item list at %L\", &dt->extra_comma->where) == FAILURE)\n+    return FAILURE;\n+\n   if (dt->err)\n     {\n       if (gfc_reference_st_label (dt->err, ST_LABEL_TARGET) == FAILURE)\n@@ -3306,12 +3338,23 @@ match_io (io_kind k)\n   /* Used in check_io_constraints, where no locus is available.  */\n   spec_end = gfc_current_locus;\n \n-  /* Optional leading comma (non-standard).  */\n-  if (!comma_flag\n-      && gfc_match_char (',') == MATCH_YES\n-      && gfc_notify_std (GFC_STD_GNU, \"Extension: Comma before i/o \"\n-\t\t\t \"item list at %C\") == FAILURE)\n-    return MATCH_ERROR;\n+  /* Optional leading comma (non-standard).  We use a gfc_expr structure here\n+     to save the locus.  This is used later when resolving transfer statements\n+     that might have a format expression without unit number.  */\n+  if (!comma_flag && gfc_match_char (',') == MATCH_YES)\n+    {\n+      dt->extra_comma = gfc_get_expr ();\n+\n+      /* Set the types to something compatible with iokind. This is needed to\n+\t get through gfc_free_expr later since iokind really has no Basic Type,\n+\t BT, of its own.  */\n+      dt->extra_comma->expr_type = EXPR_CONSTANT;\n+      dt->extra_comma->ts.type = BT_LOGICAL;\n+\n+      /* Save the iokind and locus for later use in resolution.  */\n+      dt->extra_comma->value.iokind = k;\n+      dt->extra_comma->where = gfc_current_locus;\n+    }\n \n   io_code = NULL;\n   if (gfc_match_eos () != MATCH_YES)"}]}