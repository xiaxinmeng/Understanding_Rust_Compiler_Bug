{"sha": "19d987e26debef697307a3ed7c6827d4769d640e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTlkOTg3ZTI2ZGViZWY2OTczMDdhM2VkN2M2ODI3ZDQ3NjlkNjQwZQ==", "commit": {"author": {"name": "Craig Burley", "email": "craig@jcb-sc.com", "date": "1999-02-19T14:05:51Z"}, "committer": {"name": "Craig Burley", "email": "burley@gcc.gnu.org", "date": "1999-02-19T14:05:51Z"}, "message": "improve global/filewide semantic checking\n\nFrom-SVN: r25319", "tree": {"sha": "374fc30006590c59f791364d2d43a7c9f0a4347f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/374fc30006590c59f791364d2d43a7c9f0a4347f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/19d987e26debef697307a3ed7c6827d4769d640e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19d987e26debef697307a3ed7c6827d4769d640e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19d987e26debef697307a3ed7c6827d4769d640e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19d987e26debef697307a3ed7c6827d4769d640e/comments", "author": null, "committer": null, "parents": [{"sha": "fad22e3b2199fdbb87bbafcf236f2475d862efcc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fad22e3b2199fdbb87bbafcf236f2475d862efcc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fad22e3b2199fdbb87bbafcf236f2475d862efcc"}], "stats": {"total": 164, "additions": 117, "deletions": 47}, "files": [{"sha": "c2c6d84aabf11d1848d6bf3e01fdab031e46c037", "filename": "gcc/f/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19d987e26debef697307a3ed7c6827d4769d640e/gcc%2Ff%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19d987e26debef697307a3ed7c6827d4769d640e/gcc%2Ff%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2FChangeLog?ref=19d987e26debef697307a3ed7c6827d4769d640e", "patch": "@@ -1,3 +1,11 @@\n+1999-02-19  Craig Burley  <craig@jcb-sc.com>\n+\n+\t* global.c (ffeglobal_ref_progunit_): Warn about a function\n+\tdefinition that disagrees with the type of a previous reference.\n+\tImprove commentary.  Fix a couple of minor bugs.  Clean up\n+\tsome code.\n+\t* news.texi: Spread the joy.\n+\n 1999-02-18  Craig Burley  <craig@jcb-sc.com>\n \n \t* expr.c (ffeexpr_finished_): Disallow non-default INTEGER"}, {"sha": "3f7769ade9965692cf9bb1705a32c1b64c1ea8b3", "filename": "gcc/f/global.c", "status": "modified", "additions": 103, "deletions": 46, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19d987e26debef697307a3ed7c6827d4769d640e/gcc%2Ff%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19d987e26debef697307a3ed7c6827d4769d640e/gcc%2Ff%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fglobal.c?ref=19d987e26debef697307a3ed7c6827d4769d640e", "patch": "@@ -181,6 +181,7 @@ ffeglobal_init_common (ffesymbol s, ffelexToken t)\n     {\n       if (g->u.common.blank)\n \t{\n+\t  /* Not supposed to initialize blank common, though it works.  */\n \t  ffebad_start (FFEBAD_COMMON_BLANK_INIT);\n \t  ffebad_here (0, ffelex_token_where_line (t), ffelex_token_where_column (t));\n \t  ffebad_finish ();\n@@ -229,10 +230,13 @@ ffeglobal_new_common (ffesymbol s, ffelexToken t, bool blank)\n     {\n       if (g->type == FFEGLOBAL_typeCOMMON)\n \t{\n+\t  /* The names match, so the \"blankness\" should match too!  */\n \t  assert (g->u.common.blank == blank);\n \t}\n       else\n \t{\n+\t  /* This global name has already been established,\n+\t     but as something other than a common block.  */\n \t  if (ffe_is_globals () || ffe_is_warn_globals ())\n \t    {\n \t      ffebad_start (ffe_is_globals ()\n@@ -258,6 +262,10 @@ ffeglobal_new_common (ffesymbol s, ffelexToken t, bool blank)\n \t       && !g->explicit_intrinsic\n \t       && ffe_is_warn_globals ())\n \t{\n+\t  /* Common name previously used as intrinsic.  Though it works,\n+\t     warn, because the intrinsic reference might have been intended\n+\t     as a ref to an external procedure, but g77's vast list of\n+\t     intrinsics happened to snarf the name.  */\n \t  ffebad_start (FFEBAD_INTRINSIC_GLOBAL);\n \t  ffebad_string (ffelex_token_text (t));\n \t  ffebad_string (\"common block\");\n@@ -308,6 +316,7 @@ ffeglobal_new_progunit_ (ffesymbol s, ffelexToken t, ffeglobalType type)\n \t  || (g->type == FFEGLOBAL_typeBDATA))\n       && g->u.proc.defined)\n     {\n+      /* This program unit has already been defined.  */\n       if (ffe_is_globals () || ffe_is_warn_globals ())\n \t{\n \t  ffebad_start (ffe_is_globals ()\n@@ -327,6 +336,13 @@ ffeglobal_new_progunit_ (ffesymbol s, ffelexToken t, ffeglobalType type)\n \t   && (g->type != FFEGLOBAL_typeEXT)\n \t   && (g->type != type))\n     {\n+      /* A reference to this program unit has been seen, but its\n+\t context disagrees about the new definition regarding\n+\t what kind of program unit it is.  (E.g. `call foo' followed\n+\t by `function foo'.)  But `external foo' alone doesn't mean\n+\t disagreement with either a function or subroutine, though\n+\t g77 normally interprets it as a request to force-load\n+\t a block data program unit by that name (to cope with libs).  */\n       if (ffe_is_globals () || ffe_is_warn_globals ())\n \t{\n \t  ffebad_start (ffe_is_globals ()\n@@ -353,11 +369,16 @@ ffeglobal_new_progunit_ (ffesymbol s, ffelexToken t, ffeglobalType type)\n \t  g->u.proc.other_t = NULL;\n \t}\n       else if ((ffesymbol_basictype (s) != FFEINFO_basictypeNONE)\n+\t       && (g->type == FFEGLOBAL_typeFUNC)\n \t       && ((ffesymbol_basictype (s) != g->u.proc.bt)\n \t\t   || (ffesymbol_kindtype (s) != g->u.proc.kt)\n \t\t   || ((ffesymbol_size (s) != FFETARGET_charactersizeNONE)\n \t\t       && (ffesymbol_size (s) != g->u.proc.sz))))\n \t{\n+\t  /* The previous reference and this new function definition\n+\t     disagree about the type of the function.  I (Burley) think\n+\t     this rarely occurs, because when this code is reached,\n+\t     the type info doesn't appear to be filled in yet.  */\n \t  if (ffe_is_globals () || ffe_is_warn_globals ())\n \t    {\n \t      ffebad_start (ffe_is_globals ()\n@@ -377,6 +398,10 @@ ffeglobal_new_progunit_ (ffesymbol s, ffelexToken t, ffeglobalType type)\n \t  && !g->explicit_intrinsic\n \t  && ffe_is_warn_globals ())\n \t{\n+\t  /* This name, previously used as an intrinsic, now is known\n+\t     to also be a global procedure name.  Warn, since the previous\n+\t     use as an intrinsic might have been intended to refer to\n+\t     this procedure.  */\n \t  ffebad_start (FFEBAD_INTRINSIC_GLOBAL);\n \t  ffebad_string (ffelex_token_text (t));\n \t  ffebad_string (\"global\");\n@@ -395,10 +420,12 @@ ffeglobal_new_progunit_ (ffesymbol s, ffelexToken t, ffeglobalType type)\n \t  g->u.proc.kt = ffesymbol_kindtype (s);\n \t  g->u.proc.sz = ffesymbol_size (s);\n \t}\n-      g->tick = ffe_count_2;\n+      /* If there's a known disagreement about the kind of program\n+\t unit, then don't even bother tracking arglist argreement.  */\n       if ((g->tick != 0)\n \t  && (g->type != type))\n \tg->u.proc.n_args = -1;\n+      g->tick = ffe_count_2;\n       g->type = type;\n       g->u.proc.defined = TRUE;\n     }\n@@ -1160,6 +1187,10 @@ ffeglobal_ref_intrinsic (ffesymbol s, ffelexToken t, bool explicit)\n \t  && ! g->intrinsic\n \t  && ffe_is_warn_globals ())\n \t{\n+\t  /* This name, previously used as a global, now is used\n+\t     for an intrinsic.  Warn, since this new use as an\n+\t     intrinsic might have been intended to refer to\n+\t     the global procedure.  */\n \t  ffebad_start (FFEBAD_INTRINSIC_GLOBAL);\n \t  ffebad_string (ffelex_token_text (t));\n \t  ffebad_string (\"intrinsic\");\n@@ -1186,6 +1217,11 @@ ffeglobal_ref_intrinsic (ffesymbol s, ffelexToken t, bool explicit)\n \t       && (g->tick != ffe_count_2)\n \t       && ffe_is_warn_globals ())\n \t{\n+\t  /* An earlier reference to this intrinsic disagrees with\n+\t     this reference vis-a-vis explicit `intrinsic foo',\n+\t     which suggests that the one relying on implicit\n+\t     intrinsicacity might have actually intended to refer\n+\t     to a global of the same name.  */\n \t  ffebad_start (FFEBAD_INTRINSIC_EXPIMP);\n \t  ffebad_string (ffelex_token_text (t));\n \t  ffebad_string (explicit ? \"explicit\" : \"implicit\");\n@@ -1235,10 +1271,13 @@ ffeglobal_ref_progunit_ (ffesymbol s, ffelexToken t, ffeglobalType type)\n \n   if ((g != NULL)\n       && (g->type != FFEGLOBAL_typeNONE)\n-      && (g->type != type)\n       && (g->type != FFEGLOBAL_typeEXT)\n+      && (g->type != type)\n       && (type != FFEGLOBAL_typeEXT))\n     {\n+      /* Disagreement about (fully refined) class of program unit\n+\t (main, subroutine, function, block data).  Treat EXTERNAL/\n+\t COMMON disagreements distinctly.  */\n       if ((((type == FFEGLOBAL_typeBDATA)\n \t    && (g->type != FFEGLOBAL_typeCOMMON))\n \t   || ((g->type == FFEGLOBAL_typeBDATA)\n@@ -1248,6 +1287,7 @@ ffeglobal_ref_progunit_ (ffesymbol s, ffelexToken t, ffeglobalType type)\n #if 0\t/* This is likely to just annoy people. */\n \t  if (ffe_is_warn_globals ())\n \t    {\n+\t      /* Warn about EXTERNAL of a COMMON name, though it works.  */\n \t      ffebad_start (FFEBAD_FILEWIDE_TIFF);\n \t      ffebad_string (ffelex_token_text (t));\n \t      ffebad_string (ffeglobal_type_string_[type]);\n@@ -1260,23 +1300,11 @@ ffeglobal_ref_progunit_ (ffesymbol s, ffelexToken t, ffeglobalType type)\n \t    }\n #endif\n \t}\n-      else if (ffe_is_globals ())\n+      else if (ffe_is_globals () || ffe_is_warn_globals ())\n \t{\n-\t  ffebad_start (FFEBAD_FILEWIDE_DISAGREEMENT);\n-\t  ffebad_string (ffelex_token_text (t));\n-\t  ffebad_string (ffeglobal_type_string_[type]);\n-\t  ffebad_string (ffeglobal_type_string_[g->type]);\n-\t  ffebad_here (0, ffelex_token_where_line (t),\n-\t\t       ffelex_token_where_column (t));\n-\t  ffebad_here (1, ffelex_token_where_line (g->t),\n-\t\t       ffelex_token_where_column (g->t));\n-\t  ffebad_finish ();\n-\t  g->type = FFEGLOBAL_typeANY;\n-\t  return FALSE;\n-\t}\n-      else if (ffe_is_warn_globals ())\n-\t{\n-\t  ffebad_start (FFEBAD_FILEWIDE_DISAGREEMENT_W);\n+\t  ffebad_start (ffe_is_globals ()\n+\t\t\t? FFEBAD_FILEWIDE_DISAGREEMENT\n+\t\t\t: FFEBAD_FILEWIDE_DISAGREEMENT_W);\n \t  ffebad_string (ffelex_token_text (t));\n \t  ffebad_string (ffeglobal_type_string_[type]);\n \t  ffebad_string (ffeglobal_type_string_[g->type]);\n@@ -1286,7 +1314,7 @@ ffeglobal_ref_progunit_ (ffesymbol s, ffelexToken t, ffeglobalType type)\n \t\t       ffelex_token_where_column (g->t));\n \t  ffebad_finish ();\n \t  g->type = FFEGLOBAL_typeANY;\n-\t  return TRUE;\n+\t  return (! ffe_is_globals ());\n \t}\n     }\n \n@@ -1302,39 +1330,65 @@ ffeglobal_ref_progunit_ (ffesymbol s, ffelexToken t, ffeglobalType type)\n \t  g->u.proc.kt = ffesymbol_kindtype (s);\n \t  g->u.proc.sz = ffesymbol_size (s);\n \t}\n-      /* Else, make sure there is type agreement.  */\n-      else if ((g->u.proc.bt != FFEINFO_basictypeNONE)\n-\t       && (ffesymbol_basictype (s) != FFEINFO_basictypeNONE)\n-\t       && ((ffesymbol_basictype (s) != g->u.proc.bt)\n-\t\t   || (ffesymbol_kindtype (s) != g->u.proc.kt)\n-\t\t   || ((ffesymbol_size (s) != g->u.proc.sz)\n-\t\t       && g->u.proc.defined\n-\t\t       && (g->u.proc.sz != FFETARGET_charactersizeNONE))))\n+      /* Make sure there is type agreement.  */\n+      if (g->type == FFEGLOBAL_typeFUNC\n+\t  && g->u.proc.bt != FFEINFO_basictypeNONE\n+\t  && ffesymbol_basictype (s) != FFEINFO_basictypeNONE\n+\t  && (ffesymbol_basictype (s) != g->u.proc.bt\n+\t      || ffesymbol_kindtype (s) != g->u.proc.kt\n+\t      /* CHARACTER*n disagreements matter only once a\n+\t\t definition is involved, since the definition might\n+\t\t be CHARACTER*(*), which accepts all references.  */\n+\t      || (g->u.proc.defined\n+\t\t  && ffesymbol_size (s) != g->u.proc.sz\n+\t\t  && ffesymbol_size (s) != FFETARGET_charactersizeNONE\n+\t\t  && g->u.proc.sz != FFETARGET_charactersizeNONE)))\n \t{\n-\t  if (ffe_is_globals ())\n+\t  int error;\n+\n+\t  /* Type mismatch between function reference/definition and\n+\t     this subsequent reference (which might just be the filling-in\n+\t     of type info for the definition, but we can't reach here\n+\t     if that's the case and there was a previous definition).\n+\n+\t     It's an error given a previous definition, since that\n+\t     implies inlining can crash the compiler, unless the user\n+\t     asked for no such inlining.  */\n+\t  error = (g->tick != ffe_count_2\n+\t\t   && g->u.proc.defined\n+\t\t   && ffe_is_globals ());\n+\t  if (error || ffe_is_warn_globals ())\n \t    {\n-\t      ffebad_start (FFEBAD_FILEWIDE_TYPE_MISMATCH);\n+\t      ffebad_start (error\n+\t\t\t    ? FFEBAD_FILEWIDE_TYPE_MISMATCH\n+\t\t\t    : FFEBAD_FILEWIDE_TYPE_MISMATCH_W);\n \t      ffebad_string (ffelex_token_text (t));\n-\t      ffebad_here (0, ffelex_token_where_line (t),\n-\t\t\t   ffelex_token_where_column (t));\n-\t      ffebad_here (1, ffelex_token_where_line (g->t),\n-\t\t\t   ffelex_token_where_column (g->t));\n+\t      if (g->tick == ffe_count_2)\n+\t\t{\n+\t\t  /* Current reference fills in type info for definition.\n+\t\t     The current token doesn't necessarily point to the actual\n+\t\t     definition of the function, so use the definition pointer\n+\t\t     and the pointer to the pre-definition type info.  */\n+\t\t  ffebad_here (0, ffelex_token_where_line (g->t),\n+\t\t\t       ffelex_token_where_column (g->t));\n+\t\t  ffebad_here (1, ffelex_token_where_line (g->u.proc.other_t),\n+\t\t\t       ffelex_token_where_column (g->u.proc.other_t));\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* Current reference is not a filling-in of a current\n+\t\t     definition.  The current token is fine, as is\n+\t\t     the previous-mention token.  */\n+\t\t  ffebad_here (0, ffelex_token_where_line (t),\n+\t\t\t       ffelex_token_where_column (t));\n+\t\t  ffebad_here (1, ffelex_token_where_line (g->t),\n+\t\t\t       ffelex_token_where_column (g->t));\n+\t\t}\n \t      ffebad_finish ();\n-\t      g->type = FFEGLOBAL_typeANY;\n+\t      if (error)\n+\t\tg->type = FFEGLOBAL_typeANY;\n \t      return FALSE;\n \t    }\n-\t  if (ffe_is_warn_globals ())\n-\t    {\n-\t      ffebad_start (FFEBAD_FILEWIDE_TYPE_MISMATCH_W);\n-\t      ffebad_string (ffelex_token_text (t));\n-\t      ffebad_here (0, ffelex_token_where_line (t),\n-\t\t\t   ffelex_token_where_column (t));\n-\t      ffebad_here (1, ffelex_token_where_line (g->t),\n-\t\t\t   ffelex_token_where_column (g->t));\n-\t      ffebad_finish ();\n-\t    }\n-\t  g->type = FFEGLOBAL_typeANY;\n-\t  return TRUE;\n \t}\n     }\n \n@@ -1357,6 +1411,9 @@ ffeglobal_ref_progunit_ (ffesymbol s, ffelexToken t, ffeglobalType type)\n \t   && (g->tick != ffe_count_2)\n \t   && ffe_is_warn_globals ())\n     {\n+      /* Now known as a global, this name previously was seen as an\n+\t intrinsic.  Warn, in case the previous reference was intended\n+\t for the same global.  */\n       ffebad_start (FFEBAD_INTRINSIC_GLOBAL);\n       ffebad_string (ffelex_token_text (t));\n       ffebad_string (\"global\");"}, {"sha": "5df7735d5cf49294111f61eac947f358e75695ab", "filename": "gcc/f/news.texi", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19d987e26debef697307a3ed7c6827d4769d640e/gcc%2Ff%2Fnews.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19d987e26debef697307a3ed7c6827d4769d640e/gcc%2Ff%2Fnews.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fnews.texi?ref=19d987e26debef697307a3ed7c6827d4769d640e", "patch": "@@ -72,6 +72,11 @@ Source file names with the suffixes @samp{.FOR} and @samp{.FPP}\n now are recognized by @code{g77}\n as if they ended in @samp{.for} and @samp{.fpp}, respectively.\n \n+@item\n+@code{g77} now warns about a reference to a function\n+when the corresponding @emph{subsequent} function program unit\n+disagrees with the reference concerning the type of the function.\n+\n @item\n Improve documentation and indexing,\n including information on Year 2000 (Y2K) compliance."}, {"sha": "24c6c68ddb337c2e73b1c6b99ec34a1ae0c5f167", "filename": "gcc/f/version.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19d987e26debef697307a3ed7c6827d4769d640e/gcc%2Ff%2Fversion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19d987e26debef697307a3ed7c6827d4769d640e/gcc%2Ff%2Fversion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fversion.c?ref=19d987e26debef697307a3ed7c6827d4769d640e", "patch": "@@ -1 +1 @@\n-char *ffe_version_string = \"0.5.24-19990218\";\n+char *ffe_version_string = \"0.5.24-19990219\";"}]}