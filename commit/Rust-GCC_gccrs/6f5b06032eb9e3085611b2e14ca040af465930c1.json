{"sha": "6f5b06032eb9e3085611b2e14ca040af465930c1", "node_id": "C_kwDOANBUbNoAKDZmNWIwNjAzMmViOWUzMDg1NjExYjJlMTRjYTA0MGFmNDY1OTMwYzE", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-05-16T10:39:30Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-05-16T11:39:26Z"}, "message": "Finish gimple_build API enhancement\n\nThis finishes the remaining parts of the gimple_build API enhancement,\nconverting the remaining workers to receive a gimple_stmt_iterator,\ndirection and update argument.  It also moves the code_helper\nreceiving functions from gimple-match.h to gimple-fold.h.\n\n2022-05-16  Richard Biener  <rguenther@suse.de>\n\n\t* gimple-match.h (gimple_build): Move code_helper overloads ...\n\t* gimple-fold.h (gimple_build): ... here.\n\t(gimple_build): Transition to new worker API.  Provide\n\toverloads from sequence-based API.\n\t(gimple_convert): Likewise.\n\t(gimple_convert_to_ptrofftype): Likewise.\n\t(gimple_build_vector_from_val): Likewise.\n\t(gimple_build_vector): Likewise.\n\t(gimple_build_round_up): Likewise.\n\t* gimple-fold.cc (gimple_build_insert_seq): New helper.\n\t(gimple_build): Use it.  Transition combined_fn and code_helper\n\tAPI parts.\n\t(gimple_convert): Transition to new worker API.\n\t(gimple_convert_to_ptrofftype): Likewise.\n\t(gimple_build_vector_from_val): Likewise.\n\t(gimple_build_vector): Likewise.\n\t(gimple_build_round_up): Likewise.", "tree": {"sha": "17b17cb65e21c8ed73269e563b54d16e1978ee8a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/17b17cb65e21c8ed73269e563b54d16e1978ee8a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6f5b06032eb9e3085611b2e14ca040af465930c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f5b06032eb9e3085611b2e14ca040af465930c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f5b06032eb9e3085611b2e14ca040af465930c1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f5b06032eb9e3085611b2e14ca040af465930c1/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "adace78911705f25a06b48a0559612402065530e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/adace78911705f25a06b48a0559612402065530e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/adace78911705f25a06b48a0559612402065530e"}], "stats": {"total": 403, "additions": 254, "deletions": 149}, "files": [{"sha": "8555a2bca897d2cb08434ee33cdd6a2a8e10e31b", "filename": "gcc/gimple-fold.cc", "status": "modified", "additions": 128, "deletions": 104, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5b06032eb9e3085611b2e14ca040af465930c1/gcc%2Fgimple-fold.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5b06032eb9e3085611b2e14ca040af465930c1/gcc%2Fgimple-fold.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.cc?ref=6f5b06032eb9e3085611b2e14ca040af465930c1", "patch": "@@ -8667,6 +8667,29 @@ gimple_build_valueize (tree op)\n   return NULL_TREE;\n }\n \n+/* Helper for gimple_build to perform the final insertion of stmts on SEQ.  */\n+\n+static inline void\n+gimple_build_insert_seq (gimple_stmt_iterator *gsi,\n+\t\t\t bool before, gsi_iterator_update update,\n+\t\t\t gimple_seq seq)\n+{\n+  if (before)\n+    {\n+      if (gsi->bb)\n+\tgsi_insert_seq_before (gsi, seq, update);\n+      else\n+\tgsi_insert_seq_before_without_update (gsi, seq, update);\n+    }\n+  else\n+    {\n+      if (gsi->bb)\n+\tgsi_insert_seq_after (gsi, seq, update);\n+      else\n+\tgsi_insert_seq_after_without_update (gsi, seq, update);\n+    }\n+}\n+\n /* Build the expression CODE OP0 of type TYPE with location LOC,\n    simplifying it first if possible.  Returns the built\n    expression value and inserts statements possibly defining it\n@@ -8699,27 +8722,14 @@ gimple_build (gimple_stmt_iterator *gsi,\n       gimple_set_location (stmt, loc);\n       gimple_seq_add_stmt_without_update (&seq, stmt);\n     }\n-  if (before)\n-    {\n-      if (gsi->bb)\n-\tgsi_insert_seq_before (gsi, seq, update);\n-      else\n-\tgsi_insert_seq_before_without_update (gsi, seq, update);\n-    }\n-  else\n-    {\n-      if (gsi->bb)\n-\tgsi_insert_seq_after (gsi, seq, update);\n-      else\n-\tgsi_insert_seq_after_without_update (gsi, seq, update);\n-    }\n+  gimple_build_insert_seq (gsi, before, update, seq);\n   return res;\n }\n \n /* Build the expression OP0 CODE OP1 of type TYPE with location LOC,\n    simplifying it first if possible.  Returns the built\n-   expression value and appends statements possibly defining it\n-   to SEQ.  */\n+   expression value inserting any new statements at GSI honoring BEFORE\n+   and UPDATE.  */\n \n tree\n gimple_build (gimple_stmt_iterator *gsi,\n@@ -8738,27 +8748,14 @@ gimple_build (gimple_stmt_iterator *gsi,\n       gimple_set_location (stmt, loc);\n       gimple_seq_add_stmt_without_update (&seq, stmt);\n     }\n-  if (before)\n-    {\n-      if (gsi->bb)\n-\tgsi_insert_seq_before (gsi, seq, update);\n-      else\n-\tgsi_insert_seq_before_without_update (gsi, seq, update);\n-    }\n-  else\n-    {\n-      if (gsi->bb)\n-\tgsi_insert_seq_after (gsi, seq, update);\n-      else\n-\tgsi_insert_seq_after_without_update (gsi, seq, update);\n-    }\n+  gimple_build_insert_seq (gsi, before, update, seq);\n   return res;\n }\n \n /* Build the expression (CODE OP0 OP1 OP2) of type TYPE with location LOC,\n    simplifying it first if possible.  Returns the built\n-   expression value and appends statements possibly defining it\n-   to SEQ.  */\n+   expression value inserting any new statements at GSI honoring BEFORE\n+   and UPDATE.  */\n \n tree\n gimple_build (gimple_stmt_iterator *gsi,\n@@ -8783,31 +8780,22 @@ gimple_build (gimple_stmt_iterator *gsi,\n       gimple_set_location (stmt, loc);\n       gimple_seq_add_stmt_without_update (&seq, stmt);\n     }\n-  if (before)\n-    {\n-      if (gsi->bb)\n-\tgsi_insert_seq_before (gsi, seq, update);\n-      else\n-\tgsi_insert_seq_before_without_update (gsi, seq, update);\n-    }\n-  else\n-    {\n-      if (gsi->bb)\n-\tgsi_insert_seq_after (gsi, seq, update);\n-      else\n-\tgsi_insert_seq_after_without_update (gsi, seq, update);\n-    }\n+  gimple_build_insert_seq (gsi, before, update, seq);\n   return res;\n }\n \n /* Build the call FN () with a result of type TYPE (or no result if TYPE is\n    void) with a location LOC.  Returns the built expression value (or NULL_TREE\n-   if TYPE is void) and appends statements possibly defining it to SEQ.  */\n+   if TYPE is void) inserting any new statements at GSI honoring BEFORE\n+   and UPDATE.  */\n \n tree\n-gimple_build (gimple_seq *seq, location_t loc, combined_fn fn, tree type)\n+gimple_build (gimple_stmt_iterator *gsi,\n+\t      bool before, gsi_iterator_update update,\n+\t      location_t loc, combined_fn fn, tree type)\n {\n   tree res = NULL_TREE;\n+  gimple_seq seq = NULL;\n   gcall *stmt;\n   if (internal_fn_p (fn))\n     stmt = gimple_build_call_internal (as_internal_fn (fn), 0);\n@@ -8822,21 +8810,25 @@ gimple_build (gimple_seq *seq, location_t loc, combined_fn fn, tree type)\n       gimple_call_set_lhs (stmt, res);\n     }\n   gimple_set_location (stmt, loc);\n-  gimple_seq_add_stmt_without_update (seq, stmt);\n+  gimple_seq_add_stmt_without_update (&seq, stmt);\n+  gimple_build_insert_seq (gsi, before, update, seq);\n   return res;\n }\n \n /* Build the call FN (ARG0) with a result of type TYPE\n    (or no result if TYPE is void) with location LOC,\n    simplifying it first if possible.  Returns the built\n-   expression value (or NULL_TREE if TYPE is void) and appends\n-   statements possibly defining it to SEQ.  */\n+   expression value (or NULL_TREE if TYPE is void) inserting any new\n+   statements at GSI honoring BEFORE and UPDATE.  */\n \n tree\n-gimple_build (gimple_seq *seq, location_t loc, combined_fn fn,\n+gimple_build (gimple_stmt_iterator *gsi,\n+\t      bool before, gsi_iterator_update update,\n+\t      location_t loc, combined_fn fn,\n \t      tree type, tree arg0)\n {\n-  tree res = gimple_simplify (fn, type, arg0, seq, gimple_build_valueize);\n+  gimple_seq seq = NULL;\n+  tree res = gimple_simplify (fn, type, arg0, &seq, gimple_build_valueize);\n   if (!res)\n     {\n       gcall *stmt;\n@@ -8853,22 +8845,27 @@ gimple_build (gimple_seq *seq, location_t loc, combined_fn fn,\n \t  gimple_call_set_lhs (stmt, res);\n \t}\n       gimple_set_location (stmt, loc);\n-      gimple_seq_add_stmt_without_update (seq, stmt);\n+      gimple_seq_add_stmt_without_update (&seq, stmt);\n     }\n+  gimple_build_insert_seq  (gsi, before, update, seq);\n   return res;\n }\n \n /* Build the call FN (ARG0, ARG1) with a result of type TYPE\n    (or no result if TYPE is void) with location LOC,\n    simplifying it first if possible.  Returns the built\n-   expression value (or NULL_TREE if TYPE is void) and appends\n-   statements possibly defining it to SEQ.  */\n+   expression value (or NULL_TREE if TYPE is void) inserting any new\n+   statements at GSI honoring BEFORE and UPDATE.  */\n \n tree\n-gimple_build (gimple_seq *seq, location_t loc, combined_fn fn,\n+gimple_build (gimple_stmt_iterator *gsi,\n+\t      bool before, gsi_iterator_update update,\n+\t      location_t loc, combined_fn fn,\n \t      tree type, tree arg0, tree arg1)\n {\n-  tree res = gimple_simplify (fn, type, arg0, arg1, seq, gimple_build_valueize);\n+  gimple_seq seq = NULL;\n+  tree res = gimple_simplify (fn, type, arg0, arg1, &seq,\n+\t\t\t      gimple_build_valueize);\n   if (!res)\n     {\n       gcall *stmt;\n@@ -8885,23 +8882,27 @@ gimple_build (gimple_seq *seq, location_t loc, combined_fn fn,\n \t  gimple_call_set_lhs (stmt, res);\n \t}\n       gimple_set_location (stmt, loc);\n-      gimple_seq_add_stmt_without_update (seq, stmt);\n+      gimple_seq_add_stmt_without_update (&seq, stmt);\n     }\n+  gimple_build_insert_seq (gsi, before, update, seq);\n   return res;\n }\n \n /* Build the call FN (ARG0, ARG1, ARG2) with a result of type TYPE\n    (or no result if TYPE is void) with location LOC,\n    simplifying it first if possible.  Returns the built\n-   expression value (or NULL_TREE if TYPE is void) and appends\n-   statements possibly defining it to SEQ.  */\n+   expression value (or NULL_TREE if TYPE is void) inserting any new\n+   statements at GSI honoring BEFORE and UPDATE.  */\n \n tree\n-gimple_build (gimple_seq *seq, location_t loc, combined_fn fn,\n+gimple_build (gimple_stmt_iterator *gsi,\n+\t      bool before, gsi_iterator_update update,\n+\t      location_t loc, combined_fn fn,\n \t      tree type, tree arg0, tree arg1, tree arg2)\n {\n+  gimple_seq seq = NULL;\n   tree res = gimple_simplify (fn, type, arg0, arg1, arg2,\n-\t\t\t      seq, gimple_build_valueize);\n+\t\t\t      &seq, gimple_build_valueize);\n   if (!res)\n     {\n       gcall *stmt;\n@@ -8919,92 +8920,107 @@ gimple_build (gimple_seq *seq, location_t loc, combined_fn fn,\n \t  gimple_call_set_lhs (stmt, res);\n \t}\n       gimple_set_location (stmt, loc);\n-      gimple_seq_add_stmt_without_update (seq, stmt);\n+      gimple_seq_add_stmt_without_update (&seq, stmt);\n     }\n+  gimple_build_insert_seq (gsi, before, update, seq);\n   return res;\n }\n \n /* Build CODE (OP0) with a result of type TYPE (or no result if TYPE is\n    void) with location LOC, simplifying it first if possible.  Returns the\n-   built expression value (or NULL_TREE if TYPE is void) and appends\n-   statements possibly defining it to SEQ.  */\n+   built expression value (or NULL_TREE if TYPE is void) inserting any new\n+   statements at GSI honoring BEFORE and UPDATE.  */\n \n tree\n-gimple_build (gimple_seq *seq, location_t loc, code_helper code,\n-\t      tree type, tree op0)\n+gimple_build (gimple_stmt_iterator *gsi,\n+\t      bool before, gsi_iterator_update update,\n+\t      location_t loc, code_helper code, tree type, tree op0)\n {\n   if (code.is_tree_code ())\n-    return gimple_build (seq, loc, tree_code (code), type, op0);\n-  return gimple_build (seq, loc, combined_fn (code), type, op0);\n+    return gimple_build (gsi, before, update, loc, tree_code (code), type, op0);\n+  return gimple_build (gsi, before, update, loc, combined_fn (code), type, op0);\n }\n \n /* Build CODE (OP0, OP1) with a result of type TYPE (or no result if TYPE is\n    void) with location LOC, simplifying it first if possible.  Returns the\n-   built expression value (or NULL_TREE if TYPE is void) and appends\n-   statements possibly defining it to SEQ.  */\n+   built expression value (or NULL_TREE if TYPE is void) inserting any new\n+   statements at GSI honoring BEFORE and UPDATE.  */\n \n tree\n-gimple_build (gimple_seq *seq, location_t loc, code_helper code,\n-\t      tree type, tree op0, tree op1)\n+gimple_build (gimple_stmt_iterator *gsi,\n+\t      bool before, gsi_iterator_update update,\n+\t      location_t loc, code_helper code, tree type, tree op0, tree op1)\n {\n   if (code.is_tree_code ())\n-    return gimple_build (seq, loc, tree_code (code), type, op0, op1);\n-  return gimple_build (seq, loc, combined_fn (code), type, op0, op1);\n+    return gimple_build (gsi, before, update,\n+\t\t\t loc, tree_code (code), type, op0, op1);\n+  return gimple_build (gsi, before, update,\n+\t\t       loc, combined_fn (code), type, op0, op1);\n }\n \n /* Build CODE (OP0, OP1, OP2) with a result of type TYPE (or no result if TYPE\n    is void) with location LOC, simplifying it first if possible.  Returns the\n-   built expression value (or NULL_TREE if TYPE is void) and appends statements\n-   possibly defining it to SEQ.  */\n+   built expression value (or NULL_TREE if TYPE is void) inserting any new\n+   statements at GSI honoring BEFORE and UPDATE.  */\n \n tree\n-gimple_build (gimple_seq *seq, location_t loc, code_helper code,\n+gimple_build (gimple_stmt_iterator *gsi,\n+\t      bool before, gsi_iterator_update update,\n+\t      location_t loc, code_helper code,\n \t      tree type, tree op0, tree op1, tree op2)\n {\n   if (code.is_tree_code ())\n-    return gimple_build (seq, loc, tree_code (code), type, op0, op1, op2);\n-  return gimple_build (seq, loc, combined_fn (code), type, op0, op1, op2);\n+    return gimple_build (gsi, before, update,\n+\t\t\t loc, tree_code (code), type, op0, op1, op2);\n+  return gimple_build (gsi, before, update,\n+\t\t       loc, combined_fn (code), type, op0, op1, op2);\n }\n \n /* Build the conversion (TYPE) OP with a result of type TYPE\n    with location LOC if such conversion is neccesary in GIMPLE,\n    simplifying it first.\n-   Returns the built expression value and appends\n-   statements possibly defining it to SEQ.  */\n+   Returns the built expression inserting any new statements\n+   at GSI honoring BEFORE and UPDATE.  */\n \n tree\n-gimple_convert (gimple_seq *seq, location_t loc, tree type, tree op)\n+gimple_convert (gimple_stmt_iterator *gsi,\n+\t\tbool before, gsi_iterator_update update,\n+\t\tlocation_t loc, tree type, tree op)\n {\n   if (useless_type_conversion_p (type, TREE_TYPE (op)))\n     return op;\n-  return gimple_build (seq, loc, NOP_EXPR, type, op);\n+  return gimple_build (gsi, before, update, loc, NOP_EXPR, type, op);\n }\n \n /* Build the conversion (ptrofftype) OP with a result of a type\n    compatible with ptrofftype with location LOC if such conversion\n    is neccesary in GIMPLE, simplifying it first.\n-   Returns the built expression value and appends\n-   statements possibly defining it to SEQ.  */\n+   Returns the built expression value inserting any new statements\n+   at GSI honoring BEFORE and UPDATE.  */\n \n tree\n-gimple_convert_to_ptrofftype (gimple_seq *seq, location_t loc, tree op)\n+gimple_convert_to_ptrofftype (gimple_stmt_iterator *gsi,\n+\t\t\t      bool before, gsi_iterator_update update,\n+\t\t\t      location_t loc, tree op)\n {\n   if (ptrofftype_p (TREE_TYPE (op)))\n     return op;\n-  return gimple_convert (seq, loc, sizetype, op);\n+  return gimple_convert (gsi, before, update, loc, sizetype, op);\n }\n \n /* Build a vector of type TYPE in which each element has the value OP.\n-   Return a gimple value for the result, appending any new statements\n-   to SEQ.  */\n+   Return a gimple value for the result, inserting any new statements\n+   at GSI honoring BEFORE and UPDATE.  */\n \n tree\n-gimple_build_vector_from_val (gimple_seq *seq, location_t loc, tree type,\n-\t\t\t      tree op)\n+gimple_build_vector_from_val (gimple_stmt_iterator *gsi,\n+\t\t\t      bool before, gsi_iterator_update update,\n+\t\t\t      location_t loc, tree type, tree op)\n {\n   if (!TYPE_VECTOR_SUBPARTS (type).is_constant ()\n       && !CONSTANT_CLASS_P (op))\n-    return gimple_build (seq, loc, VEC_DUPLICATE_EXPR, type, op);\n+    return gimple_build (gsi, before, update,\n+\t\t\t loc, VEC_DUPLICATE_EXPR, type, op);\n \n   tree res, vec = build_vector_from_val (type, op);\n   if (is_gimple_val (vec))\n@@ -9013,30 +9029,34 @@ gimple_build_vector_from_val (gimple_seq *seq, location_t loc, tree type,\n     res = make_ssa_name (type);\n   else\n     res = create_tmp_reg (type);\n+  gimple_seq seq = NULL;\n   gimple *stmt = gimple_build_assign (res, vec);\n   gimple_set_location (stmt, loc);\n-  gimple_seq_add_stmt_without_update (seq, stmt);\n+  gimple_seq_add_stmt_without_update (&seq, stmt);\n+  gimple_build_insert_seq (gsi, before, update, seq);\n   return res;\n }\n \n /* Build a vector from BUILDER, handling the case in which some elements\n-   are non-constant.  Return a gimple value for the result, appending any\n-   new instructions to SEQ.\n+   are non-constant.  Return a gimple value for the result, inserting\n+   any new instructions to GSI honoring BEFORE and UPDATE.\n \n    BUILDER must not have a stepped encoding on entry.  This is because\n    the function is not geared up to handle the arithmetic that would\n    be needed in the variable case, and any code building a vector that\n    is known to be constant should use BUILDER->build () directly.  */\n \n tree\n-gimple_build_vector (gimple_seq *seq, location_t loc,\n-\t\t     tree_vector_builder *builder)\n+gimple_build_vector (gimple_stmt_iterator *gsi,\n+\t\t     bool before, gsi_iterator_update update,\n+\t\t     location_t loc, tree_vector_builder *builder)\n {\n   gcc_assert (builder->nelts_per_pattern () <= 2);\n   unsigned int encoded_nelts = builder->encoded_nelts ();\n   for (unsigned int i = 0; i < encoded_nelts; ++i)\n     if (!CONSTANT_CLASS_P ((*builder)[i]))\n       {\n+\tgimple_seq seq = NULL;\n \ttree type = builder->type ();\n \tunsigned int nelts = TYPE_VECTOR_SUBPARTS (type).to_constant ();\n \tvec<constructor_elt, va_gc> *v;\n@@ -9051,7 +9071,8 @@ gimple_build_vector (gimple_seq *seq, location_t loc,\n \t  res = create_tmp_reg (type);\n \tgimple *stmt = gimple_build_assign (res, build_constructor (type, v));\n \tgimple_set_location (stmt, loc);\n-\tgimple_seq_add_stmt_without_update (seq, stmt);\n+\tgimple_seq_add_stmt_without_update (&seq, stmt);\n+\tgimple_build_insert_seq (gsi, before, update, seq);\n \treturn res;\n       }\n   return builder->build ();\n@@ -9063,18 +9084,21 @@ gimple_build_vector (gimple_seq *seq, location_t loc,\n    Return the tree node representing this size, it is of TREE_TYPE TYPE.  */\n \n tree\n-gimple_build_round_up (gimple_seq *seq, location_t loc, tree type,\n+gimple_build_round_up (gimple_stmt_iterator *gsi,\n+\t\t       bool before, gsi_iterator_update update,\n+\t\t       location_t loc, tree type,\n \t\t       tree old_size, unsigned HOST_WIDE_INT align)\n {\n   unsigned HOST_WIDE_INT tg_mask = align - 1;\n   /* tree new_size = (old_size + tg_mask) & ~tg_mask;  */\n   gcc_assert (INTEGRAL_TYPE_P (type));\n   tree tree_mask = build_int_cst (type, tg_mask);\n-  tree oversize = gimple_build (seq, loc, PLUS_EXPR, type, old_size,\n-\t\t\t\ttree_mask);\n+  tree oversize = gimple_build (gsi, before, update,\n+\t\t\t\tloc, PLUS_EXPR, type, old_size, tree_mask);\n \n   tree mask = build_int_cst (type, -align);\n-  return gimple_build (seq, loc, BIT_AND_EXPR, type, oversize, mask);\n+  return gimple_build (gsi, before, update,\n+\t\t       loc, BIT_AND_EXPR, type, oversize, mask);\n }\n \n /* Return true if the result of assignment STMT is known to be non-negative."}, {"sha": "7d29ee9a9a43e5e2f6f77fe65b458a097948f13a", "filename": "gcc/gimple-fold.h", "status": "modified", "additions": 126, "deletions": 19, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5b06032eb9e3085611b2e14ca040af465930c1/gcc%2Fgimple-fold.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5b06032eb9e3085611b2e14ca040af465930c1/gcc%2Fgimple-fold.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.h?ref=6f5b06032eb9e3085611b2e14ca040af465930c1", "patch": "@@ -98,59 +98,166 @@ gimple_build (gimple_seq *seq, enum tree_code code, tree type, Args ...ops)\n \t\t       UNKNOWN_LOCATION, code, type, ops...);\n }\n \n-extern tree gimple_build (gimple_seq *, location_t, combined_fn, tree);\n-extern tree gimple_build (gimple_seq *, location_t, combined_fn, tree, tree);\n-extern tree gimple_build (gimple_seq *, location_t, combined_fn,\n-\t\t\t  tree, tree, tree);\n-extern tree gimple_build (gimple_seq *, location_t, combined_fn,\n-\t\t\t  tree, tree, tree, tree);\n+extern tree gimple_build (gimple_stmt_iterator *, bool,\n+\t\t\t  enum gsi_iterator_update,\n+\t\t\t  location_t, combined_fn, tree);\n+extern tree gimple_build (gimple_stmt_iterator *, bool,\n+\t\t\t  enum gsi_iterator_update,\n+\t\t\t  location_t, combined_fn, tree, tree);\n+extern tree gimple_build (gimple_stmt_iterator *, bool,\n+\t\t\t  enum gsi_iterator_update,\n+\t\t\t  location_t, combined_fn, tree, tree, tree);\n+extern tree gimple_build (gimple_stmt_iterator *, bool,\n+\t\t\t  enum gsi_iterator_update,\n+\t\t\t  location_t, combined_fn, tree, tree, tree, tree);\n+template<class ...Args>\n+inline tree\n+gimple_build (gimple_seq *seq, location_t loc,\n+\t      combined_fn fn, tree type, Args ...args)\n+{\n+  static_assert (sizeof...(args) < 4,\n+\t\t \"Number of arguments must be less than four\");\n+  gimple_stmt_iterator gsi = gsi_last (*seq);\n+  return gimple_build (&gsi, false, GSI_CONTINUE_LINKING,\n+\t\t       loc, fn, type, args...);\n+}\n template<class ...Args>\n inline tree\n gimple_build (gimple_seq *seq, combined_fn fn, tree type, Args ...args)\n {\n   static_assert (sizeof...(args) < 4,\n \t\t \"Number of arguments must be less than four\");\n-  return gimple_build (seq, UNKNOWN_LOCATION, fn, type, args...);\n+  gimple_stmt_iterator gsi = gsi_last (*seq);\n+  return gimple_build (&gsi, false, GSI_CONTINUE_LINKING,\n+\t\t       UNKNOWN_LOCATION, fn, type, args...);\n }\n \n-extern tree gimple_convert (gimple_seq *, location_t, tree, tree);\n+extern tree gimple_build (gimple_stmt_iterator *, bool,\n+\t\t\t  enum gsi_iterator_update,\n+\t\t\t  location_t, code_helper, tree, tree);\n+extern tree gimple_build (gimple_stmt_iterator *, bool,\n+\t\t\t  enum gsi_iterator_update,\n+\t\t\t  location_t, code_helper, tree, tree, tree);\n+extern tree gimple_build (gimple_stmt_iterator *, bool,\n+\t\t\t  enum gsi_iterator_update,\n+\t\t\t  location_t, code_helper, tree, tree, tree, tree);\n+\n+template<class ...Args>\n+inline tree\n+gimple_build (gimple_seq *seq, location_t loc,\n+\t      code_helper code, tree type, Args ...ops)\n+{\n+  static_assert (sizeof...(ops) < 4,\n+\t\t \"Number of operands must be less than four\");\n+  gimple_stmt_iterator gsi = gsi_last (*seq);\n+  return gimple_build (&gsi, false, GSI_CONTINUE_LINKING,\n+\t\t       loc, code, type, ops...);\n+}\n+template<class ...Args>\n+inline tree\n+gimple_build (gimple_seq *seq,\n+\t      code_helper code, tree type, Args ...ops)\n+{\n+  static_assert (sizeof...(ops) < 4,\n+\t\t \"Number of operands must be less than four\");\n+  gimple_stmt_iterator gsi = gsi_last (*seq);\n+  return gimple_build (&gsi, false, GSI_CONTINUE_LINKING,\n+\t\t       UNKNOWN_LOCATION, code, type, ops...);\n+}\n+\n+extern tree gimple_convert (gimple_stmt_iterator *, bool,\n+\t\t\t    enum gsi_iterator_update,\n+\t\t\t    location_t, tree, tree);\n+inline tree\n+gimple_convert (gimple_seq *seq, location_t loc, tree type, tree op)\n+{\n+  gimple_stmt_iterator gsi = gsi_last (*seq);\n+  return gimple_convert (&gsi, false, GSI_CONTINUE_LINKING, loc, type, op);\n+}\n inline tree\n gimple_convert (gimple_seq *seq, tree type, tree op)\n {\n-  return gimple_convert (seq, UNKNOWN_LOCATION, type, op);\n+  gimple_stmt_iterator gsi = gsi_last (*seq);\n+  return gimple_convert (&gsi, false, GSI_CONTINUE_LINKING,\n+\t\t\t UNKNOWN_LOCATION, type, op);\n }\n \n-extern tree gimple_convert_to_ptrofftype (gimple_seq *, location_t, tree);\n+extern tree gimple_convert_to_ptrofftype (gimple_stmt_iterator *, bool,\n+\t\t\t\t\t  enum gsi_iterator_update,\n+\t\t\t\t\t  location_t, tree);\n+inline tree\n+gimple_convert_to_ptrofftype (gimple_seq *seq, location_t loc, tree op)\n+{\n+  gimple_stmt_iterator gsi = gsi_last (*seq);\n+  return gimple_convert_to_ptrofftype (&gsi, false, GSI_CONTINUE_LINKING,\n+\t\t\t\t       loc, op);\n+}\n inline tree\n gimple_convert_to_ptrofftype (gimple_seq *seq, tree op)\n {\n-  return gimple_convert_to_ptrofftype (seq, UNKNOWN_LOCATION, op);\n+  gimple_stmt_iterator gsi = gsi_last (*seq);\n+  return gimple_convert_to_ptrofftype (&gsi, false, GSI_CONTINUE_LINKING,\n+\t\t\t\t       UNKNOWN_LOCATION, op);\n }\n \n-extern tree gimple_build_vector_from_val (gimple_seq *, location_t, tree,\n-\t\t\t\t\t  tree);\n+extern tree gimple_build_vector_from_val (gimple_stmt_iterator *, bool,\n+\t\t\t\t\t  enum gsi_iterator_update,\n+\t\t\t\t\t  location_t, tree, tree);\n+inline tree\n+gimple_build_vector_from_val (gimple_seq *seq, location_t loc,\n+\t\t\t      tree type, tree op)\n+{\n+  gimple_stmt_iterator gsi = gsi_last (*seq);\n+  return gimple_build_vector_from_val (&gsi, false, GSI_CONTINUE_LINKING,\n+\t\t\t\t       loc, type, op);\n+}\n inline tree\n gimple_build_vector_from_val (gimple_seq *seq, tree type, tree op)\n {\n-  return gimple_build_vector_from_val (seq, UNKNOWN_LOCATION, type, op);\n+  gimple_stmt_iterator gsi = gsi_last (*seq);\n+  return gimple_build_vector_from_val (&gsi, false, GSI_CONTINUE_LINKING,\n+\t\t\t\t       UNKNOWN_LOCATION, type, op);\n }\n \n class tree_vector_builder;\n-extern tree gimple_build_vector (gimple_seq *, location_t,\n-\t\t\t\t tree_vector_builder *);\n+extern tree gimple_build_vector (gimple_stmt_iterator *, bool,\n+\t\t\t\t enum gsi_iterator_update,\n+\t\t\t\t location_t, tree_vector_builder *);\n+inline tree\n+gimple_build_vector (gimple_seq *seq, location_t loc,\n+\t\t     tree_vector_builder *builder)\n+{\n+  gimple_stmt_iterator gsi = gsi_last (*seq);\n+  return gimple_build_vector (&gsi, false, GSI_CONTINUE_LINKING,\n+\t\t\t      loc, builder);\n+}\n inline tree\n gimple_build_vector (gimple_seq *seq, tree_vector_builder *builder)\n {\n-  return gimple_build_vector (seq, UNKNOWN_LOCATION, builder);\n+  gimple_stmt_iterator gsi = gsi_last (*seq);\n+  return gimple_build_vector (&gsi, false, GSI_CONTINUE_LINKING,\n+\t\t\t      UNKNOWN_LOCATION, builder);\n }\n \n-extern tree gimple_build_round_up (gimple_seq *, location_t, tree, tree,\n+extern tree gimple_build_round_up (gimple_stmt_iterator *, bool,\n+\t\t\t\t   enum gsi_iterator_update,\n+\t\t\t\t   location_t, tree, tree,\n \t\t\t\t   unsigned HOST_WIDE_INT);\n inline tree\n+gimple_build_round_up (gimple_seq *seq, location_t loc,\n+\t\t       tree type, tree old_size, unsigned HOST_WIDE_INT align)\n+{\n+  gimple_stmt_iterator gsi = gsi_last (*seq);\n+  return gimple_build_round_up (&gsi, false, GSI_CONTINUE_LINKING,\n+\t\t\t\tloc, type, old_size, align);\n+}\n+inline tree\n gimple_build_round_up (gimple_seq *seq, tree type, tree old_size,\n \t\t       unsigned HOST_WIDE_INT align)\n {\n-  return gimple_build_round_up (seq, UNKNOWN_LOCATION, type, old_size, align);\n+  gimple_stmt_iterator gsi = gsi_last (*seq);\n+  return gimple_build_round_up (&gsi, false, GSI_CONTINUE_LINKING,\n+\t\t\t\tUNKNOWN_LOCATION, type, old_size, align);\n }\n \n extern bool gimple_stmt_nonnegative_warnv_p (gimple *, bool *, int = 0);"}, {"sha": "d03789b6902c26a045c785345e5c5bdbb9bfcf13", "filename": "gcc/gimple-match.h", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f5b06032eb9e3085611b2e14ca040af465930c1/gcc%2Fgimple-match.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f5b06032eb9e3085611b2e14ca040af465930c1/gcc%2Fgimple-match.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-match.h?ref=6f5b06032eb9e3085611b2e14ca040af465930c1", "patch": "@@ -335,30 +335,4 @@ bool directly_supported_p (code_helper, tree, optab_subtype = optab_default);\n \n internal_fn get_conditional_internal_fn (code_helper, tree);\n \n-extern tree gimple_build (gimple_seq *, location_t,\n-\t\t\t  code_helper, tree, tree);\n-inline tree\n-gimple_build (gimple_seq *seq, code_helper code, tree type, tree op0)\n-{\n-  return gimple_build (seq, UNKNOWN_LOCATION, code, type, op0);\n-}\n-\n-extern tree gimple_build (gimple_seq *, location_t,\n-\t\t\t  code_helper, tree, tree, tree);\n-inline tree\n-gimple_build (gimple_seq *seq, code_helper code, tree type, tree op0,\n-\t      tree op1)\n-{\n-  return gimple_build (seq, UNKNOWN_LOCATION, code, type, op0, op1);\n-}\n-\n-extern tree gimple_build (gimple_seq *, location_t,\n-\t\t\t  code_helper, tree, tree, tree, tree);\n-inline tree\n-gimple_build (gimple_seq *seq, code_helper code, tree type, tree op0,\n-\t      tree op1, tree op2)\n-{\n-  return gimple_build (seq, UNKNOWN_LOCATION, code, type, op0, op1, op2);\n-}\n-\n #endif  /* GCC_GIMPLE_MATCH_H */"}]}