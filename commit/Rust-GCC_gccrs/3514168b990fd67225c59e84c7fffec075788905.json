{"sha": "3514168b990fd67225c59e84c7fffec075788905", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzUxNDE2OGI5OTBmZDY3MjI1YzU5ZTg0YzdmZmZlYzA3NTc4ODkwNQ==", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2020-12-10T17:44:33Z"}, "committer": {"name": "Philip Herron", "email": "herron.philip@googlemail.com", "date": "2020-12-17T17:23:46Z"}, "message": "Introduce HIR Mapping\n\nThis is the start of a bigger refactor of the compiler to follow the\nrustc internals. This introduces a mapping system for.\n\n - HirId which maps to any Hir Node within the current crate\n - LocalDefId any toplevel Hir Node HIR::Item within current crate\n - NodeId maps any AST node akin to HirId such that they can map back\n - DefId Cratea and localDefId combination", "tree": {"sha": "937dc0fbfe0a754e502f1947a01fdb4e20ad5698", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/937dc0fbfe0a754e502f1947a01fdb4e20ad5698"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3514168b990fd67225c59e84c7fffec075788905", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3514168b990fd67225c59e84c7fffec075788905", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3514168b990fd67225c59e84c7fffec075788905", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3514168b990fd67225c59e84c7fffec075788905/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "29fb9e4d937f2d98734330f46f539514e2518cc3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29fb9e4d937f2d98734330f46f539514e2518cc3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29fb9e4d937f2d98734330f46f539514e2518cc3"}], "stats": {"total": 584, "additions": 582, "deletions": 2}, "files": [{"sha": "715972523fc83b13fdb6e401b0f04d1e08afdacc", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3514168b990fd67225c59e84c7fffec075788905/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3514168b990fd67225c59e84c7fffec075788905/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=3514168b990fd67225c59e84c7fffec075788905", "patch": "@@ -74,6 +74,7 @@ GRS_OBJS = \\\n     rust/rust-scan.o \\\n     rust/rust-compile.o \\\n     rust/rust-macro-expand.o \\\n+    rust/rust-hir-map.o \\\n     $(END)\n # removed object files from here\n \n@@ -217,7 +218,7 @@ CFLAGS-rust/rust-lang.o += -DDEFAULT_TARGET_VERSION=\\\"$(version)\\\" \\\n \t-DDEFAULT_TARGET_MACHINE=\\\"$(target_noncanonical)\\\"\n \n # cross-folder includes - add new folders later\n-RUST_INCLUDES = -I $(srcdir)/rust -I $(srcdir)/rust/lex -I $(srcdir)/rust/parse -I $(srcdir)/rust/ast -I $(srcdir)/rust/analysis -I $(srcdir)/rust/backend -I $(srcdir)/rust/expand\n+RUST_INCLUDES = -I $(srcdir)/rust -I $(srcdir)/rust/lex -I $(srcdir)/rust/parse -I $(srcdir)/rust/ast -I $(srcdir)/rust/analysis -I $(srcdir)/rust/backend -I $(srcdir)/rust/expand -I $(srcdir)/rust/util\n \n # add files that require cross-folder includes - currently rust-lang.o, rust-lex.o\n CFLAGS-rust/rust-lang.o += $(RUST_INCLUDES)"}, {"sha": "ff3e548ce4bbd33f43bd7b8d259b981fd6a4e9c5", "filename": "gcc/rust/util/rust-hir-map.cc", "status": "added", "additions": 312, "deletions": 0, "changes": 312, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3514168b990fd67225c59e84c7fffec075788905/gcc%2Frust%2Futil%2Frust-hir-map.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3514168b990fd67225c59e84c7fffec075788905/gcc%2Frust%2Futil%2Frust-hir-map.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-hir-map.cc?ref=3514168b990fd67225c59e84c7fffec075788905", "patch": "@@ -0,0 +1,312 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-hir-map.h\"\n+#include \"rust-ast-full.h\"\n+#include \"rust-hir-full.h\"\n+\n+namespace Rust {\n+namespace Analysis {\n+\n+NodeMapping::NodeMapping (CrateNum crateNum, NodeId nodeId, HirId hirId,\n+\t\t\t  LocalDefId localDefId)\n+  : crateNum (crateNum), nodeId (nodeId), hirId (hirId), localDefId (localDefId)\n+{}\n+\n+NodeMapping::~NodeMapping () {}\n+\n+NodeMapping\n+NodeMapping::get_error ()\n+{\n+  return NodeMapping (UNKNOWN_CREATENUM, UNKNOWN_NODEID, UNKNOWN_HIRID,\n+\t\t      UNKNOWN_LOCAL_DEFID);\n+}\n+\n+CrateNum\n+NodeMapping::get_crate_num () const\n+{\n+  return crateNum;\n+}\n+\n+NodeId\n+NodeMapping::get_nodeid () const\n+{\n+  return nodeId;\n+}\n+\n+HirId\n+NodeMapping::get_hirid () const\n+{\n+  return hirId;\n+}\n+\n+LocalDefId\n+NodeMapping::get_local_defid () const\n+{\n+  return localDefId;\n+}\n+\n+DefId\n+NodeMapping::get_defid () const\n+{\n+  DefId val = 0;\n+  val |= get_crate_num ();\n+  val = val << sizeof (uint32_t);\n+  val |= get_local_defid ();\n+  return val;\n+}\n+\n+std::string\n+NodeMapping::as_string () const\n+{\n+  std::ostringstream ss;\n+  ss << \"[\"\n+     << \"C: \" << get_crate_num ();\n+  if (get_nodeid () != UNKNOWN_NODEID)\n+    ss << \" Nid: \" << get_nodeid ();\n+\n+  if (get_hirid () != UNKNOWN_HIRID)\n+    ss << \" Hid: \" << get_hirid ();\n+\n+  if (get_local_defid () != UNKNOWN_LOCAL_DEFID)\n+    ss << \" Lid: \" << get_local_defid ();\n+\n+  ss << \"]\";\n+  return ss.str ();\n+}\n+\n+// Mappings Class now\n+\n+Mappings::Mappings () {}\n+\n+Mappings::~Mappings () {}\n+\n+Mappings *\n+Mappings::get ()\n+{\n+  static std::unique_ptr<Mappings> instance;\n+  if (!instance)\n+    instance = std::move (std::unique_ptr<Mappings> (new Mappings ()));\n+\n+  return instance.get ();\n+}\n+\n+CrateNum\n+Mappings::get_next_crate_num ()\n+{\n+  return crateNumItr++;\n+}\n+\n+void\n+Mappings::set_current_crate (CrateNum crateNum)\n+{\n+  currentCrateNum = crateNum;\n+}\n+\n+CrateNum\n+Mappings::get_current_crate ()\n+{\n+  // HACK\n+  if (hirIdIter.find (currentCrateNum) == hirIdIter.end ())\n+    {\n+      hirIdIter[currentCrateNum] = UNKNOWN_HIRID;\n+      nodeIdIter[currentCrateNum] = UNKNOWN_NODEID;\n+      localIdIter[currentCrateNum] = UNKNOWN_LOCAL_DEFID;\n+    }\n+\n+  return currentCrateNum;\n+}\n+\n+NodeId\n+Mappings::get_next_node_id (CrateNum crateNum)\n+{\n+  auto it = nodeIdIter.find (crateNum);\n+  rust_assert (it != nodeIdIter.end ());\n+\n+  auto id = it->second + 1;\n+  nodeIdIter[crateNum] = id;\n+  return id;\n+}\n+\n+HirId\n+Mappings::get_next_hir_id (CrateNum crateNum)\n+{\n+  auto it = hirIdIter.find (crateNum);\n+  rust_assert (it != hirIdIter.end ());\n+\n+  auto id = it->second + 1;\n+  hirIdIter[crateNum] = id;\n+  return id++;\n+}\n+\n+LocalDefId\n+Mappings::get_next_localdef_id (CrateNum crateNum)\n+{\n+  auto it = localIdIter.find (crateNum);\n+  rust_assert (it != localIdIter.end ());\n+\n+  auto id = it->second + 1;\n+  localIdIter[crateNum] = id;\n+  return id;\n+}\n+\n+AST::Crate *\n+Mappings::get_ast_crate (CrateNum crateNum)\n+{\n+  auto it = astCrateMappings.find (crateNum);\n+  if (it == astCrateMappings.end ())\n+    return nullptr;\n+\n+  return it->second;\n+}\n+\n+void\n+Mappings::insert_ast_crate (AST::Crate *crate)\n+{\n+  CrateNum crateNum = get_current_crate ();\n+  rust_assert (get_ast_crate (crateNum) == nullptr);\n+\n+  astCrateMappings[crateNum] = crate;\n+}\n+\n+HIR::Crate *\n+Mappings::get_hir_crate (CrateNum crateNum)\n+{\n+  auto it = hirCrateMappings.find (crateNum);\n+  if (it == hirCrateMappings.end ())\n+    return nullptr;\n+\n+  return it->second;\n+}\n+\n+void\n+Mappings::insert_hir_crate (HIR::Crate *crate)\n+{\n+  CrateNum crateNum = crate->get_mappings ().get_crate_num ();\n+  rust_assert (get_hir_crate (crateNum) == nullptr);\n+\n+  hirCrateMappings[crateNum] = crate;\n+}\n+\n+void\n+Mappings::insert_defid_mapping (DefId id, HIR::Item *item)\n+{\n+  CrateNum crateNum = (id & DEF_ID_CRATE_MASK) >> sizeof (uint32_t);\n+  LocalDefId localDefId = id & DEF_ID_LOCAL_DEF_MASK;\n+\n+  rust_assert (lookup_defid (id) == nullptr);\n+  rust_assert (lookup_local_defid (crateNum, localDefId) == nullptr);\n+\n+  defIdMappings[id] = item;\n+  insert_local_defid_mapping (crateNum, localDefId, item);\n+}\n+\n+HIR::Item *\n+Mappings::lookup_defid (DefId id)\n+{\n+  auto it = defIdMappings.find (id);\n+  if (it == defIdMappings.end ())\n+    return nullptr;\n+\n+  return it->second;\n+}\n+\n+void\n+Mappings::insert_hir_item (CrateNum crateNum, HirId id, HIR::Item *item)\n+{\n+  rust_assert (lookup_hir_item (crateNum, id) == nullptr);\n+\n+  hirItemMappings[crateNum][id] = item;\n+}\n+\n+HIR::Item *\n+Mappings::lookup_hir_item (CrateNum crateNum, HirId id)\n+{\n+  auto it = hirItemMappings.find (crateNum);\n+  if (it == hirItemMappings.end ())\n+    return nullptr;\n+\n+  auto iy = it->second.find (id);\n+  if (iy == it->second.end ())\n+    return nullptr;\n+\n+  return iy->second;\n+}\n+\n+void\n+Mappings::insert_hir_expr (CrateNum crateNum, HirId id, HIR::Expr *expr)\n+{\n+  rust_assert (lookup_hir_expr (crateNum, id) == nullptr);\n+\n+  hirExprMappings[crateNum][id] = expr;\n+}\n+\n+HIR::Expr *\n+Mappings::lookup_hir_expr (CrateNum crateNum, HirId id)\n+{\n+  auto it = hirExprMappings.find (crateNum);\n+  if (it == hirExprMappings.end ())\n+    return nullptr;\n+\n+  auto iy = it->second.find (id);\n+  if (iy == it->second.end ())\n+    return nullptr;\n+\n+  return iy->second;\n+}\n+\n+void\n+Mappings::insert_local_defid_mapping (CrateNum crateNum, LocalDefId id,\n+\t\t\t\t      HIR::Item *item)\n+{\n+  rust_assert (lookup_local_defid (crateNum, id) == nullptr);\n+\n+  localDefIdMappings[crateNum][id] = item;\n+}\n+\n+HIR::Item *\n+Mappings::lookup_local_defid (CrateNum crateNum, LocalDefId id)\n+{\n+  auto it = localDefIdMappings.find (crateNum);\n+  if (it == localDefIdMappings.end ())\n+    return nullptr;\n+\n+  auto iy = it->second.find (id);\n+  if (iy == it->second.end ())\n+    return nullptr;\n+\n+  return iy->second;\n+}\n+\n+void\n+Mappings::walk_local_defids_for_crate (CrateNum crateNum,\n+\t\t\t\t       std::function<bool (HIR::Item *)> cb)\n+{\n+  auto it = localDefIdMappings.find (crateNum);\n+  if (it == localDefIdMappings.end ())\n+    return;\n+\n+  for (auto iy = it->second.begin (); iy != it->second.end (); iy++)\n+    {\n+      if (!cb (iy->second))\n+\treturn;\n+    }\n+}\n+\n+} // namespace Analysis\n+} // namespace Rust"}, {"sha": "cbe22a5b3e8ef9ad6d325c5ca494f8dd2d4e795b", "filename": "gcc/rust/util/rust-hir-map.h", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3514168b990fd67225c59e84c7fffec075788905/gcc%2Frust%2Futil%2Frust-hir-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3514168b990fd67225c59e84c7fffec075788905/gcc%2Frust%2Futil%2Frust-hir-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-hir-map.h?ref=3514168b990fd67225c59e84c7fffec075788905", "patch": "@@ -0,0 +1,134 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_MAP_H\n+#define RUST_HIR_MAP_H\n+\n+#include \"rust-system.h\"\n+\n+#include \"rust-ast-full-decls.h\"\n+#include \"rust-hir-full-decls.h\"\n+\n+namespace Rust {\n+\n+// refers to a Crate\n+typedef uint32_t CrateNum;\n+// refers to any node in the AST in current Crate\n+typedef uint32_t NodeId;\n+// refers to any node in the HIR for the current crate\n+typedef uint32_t HirId;\n+// refers to any top-level decl in HIR\n+typedef uint32_t LocalDefId;\n+// refers to <Crate><DefId>\n+typedef uint64_t DefId;\n+\n+#define DEF_ID_CRATE_MASK 0xFFFFFFFF00000000\n+#define DEF_ID_LOCAL_DEF_MASK 0x00000000FFFFFFFF\n+\n+#define UNKNOWN_CREATENUM ((uint32_t) (-1))\n+#define UNKNOWN_NODEID ((uint32_t) (-1))\n+#define UNKNOWN_HIRID ((uint32_t) (-1))\n+#define UNKNOWN_LOCAL_DEFID ((uint32_t) (-1))\n+#define UNKNOWN_DEFID ((uint64_t) (-1))\n+\n+namespace Analysis {\n+\n+class NodeMapping\n+{\n+public:\n+  NodeMapping (CrateNum crateNum, NodeId nodeId, HirId hirId,\n+\t       LocalDefId localDefId);\n+  ~NodeMapping ();\n+\n+  static NodeMapping get_error ();\n+\n+  CrateNum get_crate_num () const;\n+  NodeId get_nodeid () const;\n+  HirId get_hirid () const;\n+  LocalDefId get_local_defid () const;\n+  DefId get_defid () const;\n+\n+  std::string as_string () const;\n+\n+private:\n+  CrateNum crateNum;\n+  NodeId nodeId;\n+  HirId hirId;\n+  LocalDefId localDefId;\n+};\n+\n+class Mappings\n+{\n+public:\n+  static Mappings *get ();\n+  ~Mappings ();\n+\n+  CrateNum get_next_crate_num ();\n+  void set_current_crate (CrateNum crateNum);\n+  CrateNum get_current_crate ();\n+\n+  NodeId get_next_node_id () { return get_next_node_id (get_current_crate ()); }\n+  NodeId get_next_node_id (CrateNum crateNum);\n+  HirId get_next_hir_id (CrateNum crateNum);\n+  LocalDefId get_next_localdef_id (CrateNum crateNum);\n+\n+  AST::Crate *get_ast_crate (CrateNum crateNum);\n+  void insert_ast_crate (AST::Crate *crate);\n+\n+  HIR::Crate *get_hir_crate (CrateNum crateNum);\n+  void insert_hir_crate (HIR::Crate *crate);\n+\n+  void insert_defid_mapping (DefId id, HIR::Item *item);\n+  HIR::Item *lookup_defid (DefId id);\n+\n+  void insert_local_defid_mapping (CrateNum crateNum, LocalDefId id,\n+\t\t\t\t   HIR::Item *item);\n+  HIR::Item *lookup_local_defid (CrateNum crateNum, LocalDefId id);\n+\n+  void insert_hir_item (CrateNum crateNum, HirId id, HIR::Item *item);\n+  HIR::Item *lookup_hir_item (CrateNum crateNum, HirId id);\n+\n+  void insert_hir_expr (CrateNum crateNum, HirId id, HIR::Expr *expr);\n+  HIR::Expr *lookup_hir_expr (CrateNum crateNum, HirId id);\n+\n+  void walk_local_defids_for_crate (CrateNum crateNum,\n+\t\t\t\t    std::function<bool (HIR::Item *)> cb);\n+\n+private:\n+  Mappings ();\n+\n+  CrateNum crateNumItr;\n+  CrateNum currentCrateNum;\n+\n+  std::map<CrateNum, HirId> hirIdIter;\n+  std::map<CrateNum, NodeId> nodeIdIter;\n+  std::map<CrateNum, LocalDefId> localIdIter;\n+\n+  std::map<CrateNum, AST::Crate *> astCrateMappings;\n+  std::map<CrateNum, HIR::Crate *> hirCrateMappings;\n+\n+  std::map<DefId, HIR::Item *> defIdMappings;\n+  std::map<CrateNum, std::map<LocalDefId, HIR::Item *> > localDefIdMappings;\n+  std::map<CrateNum, std::map<HirId, HIR::Item *> > hirItemMappings;\n+  std::map<CrateNum, std::map<HirId, HIR::Expr *> > hirExprMappings;\n+};\n+\n+} // namespace Analysis\n+} // namespace Rust\n+\n+#endif // RUST_HIR_MAP_H"}, {"sha": "87decd5482ce4e2aa9fe071b6bd4d5c1c6776de1", "filename": "gcc/rust/util/rust-inference-var.h", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3514168b990fd67225c59e84c7fffec075788905/gcc%2Frust%2Futil%2Frust-inference-var.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3514168b990fd67225c59e84c7fffec075788905/gcc%2Frust%2Futil%2Frust-inference-var.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-inference-var.h?ref=3514168b990fd67225c59e84c7fffec075788905", "patch": "@@ -0,0 +1,112 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_INFERENCE_VAR\n+#define RUST_HIR_INFERENCE_VAR\n+\n+#include \"rust-system.h\"\n+#include \"rust-hir-full-decls.h\"\n+\n+namespace Rust {\n+namespace HIR {\n+\n+class GeneralInferenceVariable;\n+class IntegralInferenceVariable;\n+class FloatInferenceVariable;\n+class InferenceVarVisitor\n+{\n+public:\n+  virtual void visit (GeneralInferenceVariable &v) {}\n+  virtual void visit (IntegralInferenceVariable &v) {}\n+  virtual void visit (FloatInferenceVariable &v) {}\n+};\n+\n+// Base\n+class InferenceVariable\n+{\n+public:\n+  virtual ~InferenceVariable () {}\n+\n+  virtual std::string as_string () const = 0;\n+\n+  HIR::Type *get_type () { return resolved; }\n+\n+  void set_type (HIR::Type *type) { resolved = type; }\n+\n+  bool was_resolved () { return resolved != nullptr; }\n+\n+  virtual void accept_vis (InferenceVarVisitor &vis) = 0;\n+\n+protected:\n+  InferenceVariable () : resolved (nullptr) {}\n+\n+  HIR::Type *resolved;\n+};\n+\n+class GeneralInferenceVariable : public InferenceVariable\n+{\n+public:\n+  GeneralInferenceVariable () : InferenceVariable () {}\n+\n+  void accept_vis (InferenceVarVisitor &vis) { vis.visit (*this); };\n+\n+  std::string as_string () const override\n+  {\n+    if (resolved)\n+      return resolved->as_string ();\n+\n+    return \"[G::?T]\";\n+  }\n+};\n+\n+class IntegralInferenceVariable : public InferenceVariable\n+{\n+public:\n+  IntegralInferenceVariable () : InferenceVariable () {}\n+\n+  void accept_vis (InferenceVarVisitor &vis) { vis.visit (*this); };\n+\n+  std::string as_string () const override\n+  {\n+    if (resolved)\n+      return resolved->as_string ();\n+\n+    return \"[I::?T]\";\n+  }\n+};\n+\n+class FloatInferenceVariable : public InferenceVariable\n+{\n+public:\n+  FloatInferenceVariable () : InferenceVariable () {}\n+\n+  void accept_vis (InferenceVarVisitor &vis) { vis.visit (*this); };\n+\n+  std::string as_string () const override\n+  {\n+    if (resolved)\n+      return resolved->as_string ();\n+\n+    return \"[F::?T]\";\n+  }\n+};\n+\n+} // namespace HIR\n+} // namespace Rust\n+\n+#endif // RUST_HIR_INFERENCE_VAR"}, {"sha": "6e853c3d0d5ce40981267ff4bf53598975e00d7d", "filename": "gcc/rust/util/scope.h", "status": "renamed", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3514168b990fd67225c59e84c7fffec075788905/gcc%2Frust%2Futil%2Fscope.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3514168b990fd67225c59e84c7fffec075788905/gcc%2Frust%2Futil%2Fscope.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Fscope.h?ref=3514168b990fd67225c59e84c7fffec075788905", "patch": "@@ -1,4 +1,23 @@\n-#pragma once\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_SCOPE_H\n+#define RUST_SCOPE_H\n \n #include \"rust-system.h\"\n #include \"rust-ast-full.h\"\n@@ -55,3 +74,5 @@ template <class T> class Scope\n \n } // namespace Analysis\n } // namespace Rust\n+\n+#endif // RUST_SCOPE_H", "previous_filename": "gcc/rust/analysis/scope.h"}]}