{"sha": "991d3e71ced0bb2e4c70807831d4c95a59edde51", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTkxZDNlNzFjZWQwYmIyZTRjNzA4MDc4MzFkNGM5NWE1OWVkZGU1MQ==", "commit": {"author": {"name": "Kresten Krab Thorup", "email": "krab@gcc.gnu.org", "date": "1993-05-05T08:13:15Z"}, "committer": {"name": "Kresten Krab Thorup", "email": "krab@gcc.gnu.org", "date": "1993-05-05T08:13:15Z"}, "message": "Headerfiles reorganized\n\nFrom-SVN: r4329", "tree": {"sha": "4d203aa1e9ae06ac3a0614c7889a5772a50214bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4d203aa1e9ae06ac3a0614c7889a5772a50214bd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/991d3e71ced0bb2e4c70807831d4c95a59edde51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/991d3e71ced0bb2e4c70807831d4c95a59edde51", "html_url": "https://github.com/Rust-GCC/gccrs/commit/991d3e71ced0bb2e4c70807831d4c95a59edde51", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/991d3e71ced0bb2e4c70807831d4c95a59edde51/comments", "author": null, "committer": null, "parents": [{"sha": "84db222add1bde080bbcd48e53a8e8009296eb48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84db222add1bde080bbcd48e53a8e8009296eb48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84db222add1bde080bbcd48e53a8e8009296eb48"}], "stats": {"total": 1026, "additions": 313, "deletions": 713}, "files": [{"sha": "66c2029ea878812eb3234a2484ba852cc008c397", "filename": "gcc/objc/Makefile.in", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/991d3e71ced0bb2e4c70807831d4c95a59edde51/gcc%2Fobjc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/991d3e71ced0bb2e4c70807831d4c95a59edde51/gcc%2Fobjc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FMakefile.in?ref=991d3e71ced0bb2e4c70807831d4c95a59edde51", "patch": "@@ -43,7 +43,7 @@ SUBDIR_INCLUDES = -I. -I.. -I$(srcdir) -I$(srcdir)/config\n \t\t-c $(GCC_CFLAGS) $(SUBDIR_INCLUDES) $<\n \n .m.o:\n-\t$(GCC_FOR_TARGET) $(OPTIMIZE)  -fgnu-runtime \\\n+\t$(GCC_FOR_TARGET) $(OPTIMIZE) -fgnu-runtime \\\n \t\t-c $(GCC_CFLAGS) $(SUBDIR_INCLUDES) $<\n \n # If we were not invoked from the parent dir,\n@@ -61,11 +61,12 @@ libobjc.a: $(OBJC_O)\n # ranlib is run in the parent directory's makefile.\n \n OBJC_H = hash.h list.h sarray.h objc.h \\\n-         objc-api.h cache.h \\\n-\t Object.h Protocol.h mutex.h\n+         objc-api.h \\\n+\t Object.h Protocol.h mutex.h \\\n+\t typedstream.h\n \n # copy objc headers to installation include directory\n-copy-headers: $(OBJC_H)\n+copy-headers: \n \t-rm -fr $(incinstalldir)/objc\n \t-mkdir $(incinstalldir)/objc\n \tfor file in $(OBJC_H); do \\\n@@ -75,7 +76,7 @@ copy-headers: $(OBJC_H)\n \tdone\n \n sendmsg.o: sendmsg.c fflags\n-\t$(GCC_FOR_TARGET) `cat fflags` -c $(GCC_CFLAGS) $(SUBDIR_INCLUDES) $(srcdir)/objc/sendmsg.c\n+\t$(GCC_FOR_TARGET) `cat fflags` -c  $(GCC_CFLAGS) $(SUBDIR_INCLUDES) $(srcdir)/objc/sendmsg.c\n \n ## Next to are for heuristics on forwarding mechanism... \n xforward: xforward.c"}, {"sha": "917fed55a877310754571eec8cffefa4d573a8b6", "filename": "gcc/objc/Object.h", "status": "modified", "additions": 2, "deletions": 29, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/991d3e71ced0bb2e4c70807831d4c95a59edde51/gcc%2Fobjc%2FObject.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/991d3e71ced0bb2e4c70807831d4c95a59edde51/gcc%2Fobjc%2FObject.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FObject.h?ref=991d3e71ced0bb2e4c70807831d4c95a59edde51", "patch": "@@ -26,35 +26,8 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #ifndef __object_INCLUDE_GNU\n #define __object_INCLUDE_GNU\n \n-#ifndef __objc_INCLUDE_GNU\n-\n-/* This is the minimal set of definitions, which may be sufficient \n-   for simple programs not interacting heavily with the runtime */\n-\n-typedef char  BOOL;\n-#define YES   (BOOL)1\n-#define NO    (BOOL)0\n-\n-typedef void* SEL;\n-\n-typedef struct objc_object {\n-  struct objc_class*  class_pointer;\n-} *id;\n-\n-typedef id (*IMP)(id, SEL, ...); \n-\n-typedef struct objc_class Class;\n-typedef struct objc_class MetaClass;\n-\n-#define nil (id)0                               /* id of Nil instance */\n-#define Nil (Class*)0                          /* id of Nil class */\n-typedef char *STR;                              /* String alias */\n-\n-@class Protocol;\n-typedef struct objc_typed_stream TypedStream;\n-typedef void* arglist_t;\n-\n-#endif /* not __objc_INCLUDE_GNU */\n+#include <objc/objc.h>\n+#include <objc/typedstream.h>\n \n /*\n  * All classes are derived from Object.  As such,"}, {"sha": "79bbdd8d72518a352a6c5ca8d7d0a98f3afb3cde", "filename": "gcc/objc/Object.m", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/991d3e71ced0bb2e4c70807831d4c95a59edde51/gcc%2Fobjc%2FObject.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/991d3e71ced0bb2e4c70807831d4c95a59edde51/gcc%2Fobjc%2FObject.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FObject.m?ref=991d3e71ced0bb2e4c70807831d4c95a59edde51", "patch": "@@ -197,7 +197,10 @@ - (BOOL) conformsTo: (Protocol*)aProtocol\n       }\n     }\n \n-  return NO;\n+  if ([self superClass])\n+    return [[self superClass] conformsTo: aProtocol];\n+  else\n+    return NO;\n }\n \n - (IMP)methodFor:(SEL)aSel"}, {"sha": "867b74977f3bbd5719869d84087c07c5eda4e846", "filename": "gcc/objc/archive.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/991d3e71ced0bb2e4c70807831d4c95a59edde51/gcc%2Fobjc%2Farchive.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/991d3e71ced0bb2e4c70807831d4c95a59edde51/gcc%2Fobjc%2Farchive.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Farchive.c?ref=991d3e71ced0bb2e4c70807831d4c95a59edde51", "patch": "@@ -31,6 +31,7 @@ You should have received a copy of the GNU General Public License along with\n #ifndef __alpha__\n \n #include \"runtime.h\"\n+#include \"typedstream.h\"\n \n #define __objc_fatal(format, args...) \\\n  { fprintf(stderr, \"archining: \"); \\\n@@ -606,7 +607,7 @@ objc_read_string (struct objc_typed_stream* stream,\n       case _B_SSTR:\n \t{\n \t  int length = buf[0]&_B_VALUE;\n-\t  (*string) = (char*)malloc(length+1);\n+\t  (*string) = (char*)__objc_xmalloc(length+1);\n \t  if (key)\n \t    hash_add (&stream->stream_table, (void*)key, *string);\n \t  len = (*stream->read)(stream->physical, *string, length);\n@@ -626,7 +627,7 @@ objc_read_string (struct objc_typed_stream* stream,\n \t  unsigned int nbytes = buf[0]&_B_VALUE;\n \t  len = __objc_read_nbyte_uint(stream, nbytes, &nbytes);\n \t  if (len) {\n-\t    (*string) = (char*)malloc(nbytes);\n+\t    (*string) = (char*)__objc_xmalloc(nbytes);\n \t    if (key)\n \t      hash_add (&stream->stream_table, (void*)key, *string);\n \t    len = (*stream->read)(stream->physical, *string, buf[0]&_B_VALUE);\n@@ -1377,7 +1378,7 @@ objc_open_typed_stream (FILE* physical, int mode)\n {\n   int fflush(FILE*);\n \n-  TypedStream* s = (TypedStream*)malloc(sizeof(TypedStream));\n+  TypedStream* s = (TypedStream*)__objc_xmalloc(sizeof(TypedStream));\n \n   s->mode = mode;\n   s->physical = physical;"}, {"sha": "97e108e8015240eaf9b48c83639acd40439b1374", "filename": "gcc/objc/class.c", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/991d3e71ced0bb2e4c70807831d4c95a59edde51/gcc%2Fobjc%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/991d3e71ced0bb2e4c70807831d4c95a59edde51/gcc%2Fobjc%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fclass.c?ref=991d3e71ced0bb2e4c70807831d4c95a59edde51", "patch": "@@ -253,11 +253,7 @@ class_pose_as (Class* impostor, Class* super_class)\n   new_class->instance_size = super_class->instance_size;\n   new_class->ivars = super_class->ivars;\n   new_class->methods = impostor->methods;\n-#ifdef OBJC_SPARSE_LOOKUP\n   new_class->dtable = impostor->dtable;\n-#else\n-  new_class->cache = impostor->cache;\n-#endif\n \n   /* Create the impostor meta class.  */\n   new_meta_class->class_pointer = super_class->class_pointer->class_pointer;\n@@ -268,11 +264,7 @@ class_pose_as (Class* impostor, Class* super_class)\n   new_meta_class->instance_size = super_class->class_pointer->instance_size;\n   new_meta_class->ivars = super_class->class_pointer->ivars;\n   new_meta_class->methods = impostor->class_pointer->methods;\n-#ifdef OBJC_SPARSE_LOOKUP\n   new_meta_class->dtable = impostor->class_pointer->dtable;\n-#else\n-  new_meta_class->cache = impostor->class_pointer->cache;\n-#endif\n \n   /* Now change super/subclass links of all related classes.  This is rather\n      complex, since we have both super_class link, and subclass_list for the\n@@ -356,21 +348,3 @@ class_pose_as (Class* impostor, Class* super_class)\n   return new_class;\n }\n \n-#ifdef OBJC_HASH_LOOKUP\n-__objc_class_hash_tables_size ()\n-{\n-  node_ptr node;\n-  Class* class1;\n-  int total = 0;\n-\n-  for (node = hash_next (__objc_class_hash, NULL); node;\n-       node = hash_next (__objc_class_hash, node))\n-    {\n-      Class* class1 = node->value;\n-      total += (class1->cache->mask)*sizeof(struct objc_bucket);\n-      total += sizeof(struct objc_cache);\n-    }\n-\n-  return total;\n-}\n-#endif"}, {"sha": "824dcd849266c663f2cf8244f44cb719f9b5993a", "filename": "gcc/objc/hash.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/991d3e71ced0bb2e4c70807831d4c95a59edde51/gcc%2Fobjc%2Fhash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/991d3e71ced0bb2e4c70807831d4c95a59edde51/gcc%2Fobjc%2Fhash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fhash.h?ref=991d3e71ced0bb2e4c70807831d4c95a59edde51", "patch": "@@ -27,11 +27,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #ifndef __hash_INCLUDE_GNU\n #define __hash_INCLUDE_GNU\n \n-#ifdef IN_GCC\n-#include \"gstddef.h\"\n-#else\n #include <stddef.h>\n-#endif\n \n /*\n  * This data structure is used to hold items"}, {"sha": "6b6b3429822586cfc408b0ccced9cd34bb3e1ddc", "filename": "gcc/objc/misc.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/991d3e71ced0bb2e4c70807831d4c95a59edde51/gcc%2Fobjc%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/991d3e71ced0bb2e4c70807831d4c95a59edde51/gcc%2Fobjc%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fmisc.c?ref=991d3e71ced0bb2e4c70807831d4c95a59edde51", "patch": "@@ -29,9 +29,6 @@ You should have received a copy of the GNU General Public License along with\n void objc_error(id object, const char* fmt, va_list);\n \n void (*_objc_error)(id, const char*, va_list) = objc_error;\n-/* id (*_objc_object_alloc)(Class*) = 0; */\n-/* id (*_objc_object_dispose)(id)    = 0; */\n-/* id (*_objc_object_copy)(id)       = 0; */\n \n void\n objc_error(id object, const char* fmt, va_list ap)"}, {"sha": "1a5756d6d14c30449fe90d0a9aac0799dbd37307", "filename": "gcc/objc/objc-api.h", "status": "modified", "additions": 252, "deletions": 140, "changes": 392, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/991d3e71ced0bb2e4c70807831d4c95a59edde51/gcc%2Fobjc%2Fobjc-api.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/991d3e71ced0bb2e4c70807831d4c95a59edde51/gcc%2Fobjc%2Fobjc-api.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-api.h?ref=991d3e71ced0bb2e4c70807831d4c95a59edde51", "patch": "@@ -30,6 +30,254 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"objc/hash.h\"\n #include <stdio.h>\n \n+/* For functions which return Method_t */\n+#define METHOD_NULL\t(Method_t)0\n+                                                /* Boolean typedefs */\n+/*\n+** Method descriptor returned by introspective Object methods.\n+** This is really just the first part of the more complete objc_method\n+** structure defined below and used internally by the runtime.\n+*/\n+struct objc_method_description\n+{\n+    SEL name;\t\t\t/* this is a selector, not a string */\n+    char *types;\t\t/* type encoding */\n+};\n+\n+\n+\n+/* Filer types used to describe Ivars and Methods.  */\n+#define _C_ID       '@'\n+#define _C_CLASS    '#'\n+#define _C_SEL      ':'\n+#define _C_CHR      'c'\n+#define _C_UCHR     'C'\n+#define _C_SHT      's'\n+#define _C_USHT     'S'\n+#define _C_INT      'i'\n+#define _C_UINT     'I'\n+#define _C_LNG      'l'\n+#define _C_ULNG     'L'\n+#define _C_FLT      'f'\n+#define _C_DBL      'd'\n+#define _C_BFLD     'b'\n+#define _C_VOID     'v'\n+#define _C_UNDEF    '?'\n+#define _C_PTR      '^'\n+#define _C_CHARPTR  '*'\n+#define _C_ATOM     '%'\n+#define _C_ARY_B    '['\n+#define _C_ARY_E    ']'\n+#define _C_UNION_B  '('\n+#define _C_UNION_E  ')'\n+#define _C_STRUCT_B '{'\n+#define _C_STRUCT_E '}'\n+\n+\n+\n+/*\n+** Set this variable nonzero to print a line describing each\n+** message that is sent.  (this is currently disabled)\n+*/\n+extern BOOL objc_trace;\n+\n+\n+/*\n+** Whereas a Module (defined further down) is the root (typically) of a file,\n+** a Symtab is the root of the class and category definitions within the\n+** module.  \n+** \n+** A Symtab contains a variable length array of pointers to classes and\n+** categories  defined in the module. \n+*/\n+typedef struct objc_symtab {\n+  unsigned long sel_ref_cnt;                     /* Unknown. */\n+  SEL       *refs;                              /* Unknown. */\n+  unsigned short cls_def_cnt;                   /* Number of classes compiled\n+                                                  (defined) in the module. */\n+  unsigned short cat_def_cnt;                   /* Number of categories \n+                                                  compiled (defined) in the \n+                                                  module. */\n+  void      *defs[1];                           /* Variable array of pointers.\n+                                                  cls_def_cnt of type Class* \n+                                                  followed by cat_def_cnt of\n+                                                  type Category_t. */\n+} Symtab,   *Symtab_t;\n+\n+\n+/*\n+** The compiler generates one of these structures for each module that\n+** composes the executable (eg main.m).  \n+** \n+** This data structure is the root of the definition tree for the module.  \n+** \n+** A collect program runs between ld stages and creates a ObjC ctor array. \n+** That array holds a pointer to each module structure of the executable. \n+*/\n+typedef struct objc_module {\n+  unsigned long version;                        /* Compiler revision. */\n+  unsigned long size;                           /* sizeof(Module). */\n+  const char* name;                             /* Name of the file where the \n+                                                  module was generated.   The \n+                                                  name includes the path. */\n+  Symtab_t    symtab;                           /* Pointer to the Symtab of\n+                                                  the module.  The Symtab\n+                                                  holds an array of pointers to \n+                                                  the classes and categories \n+                                                  defined in the module. */\n+} Module, *Module_t;\n+\n+\n+/*\n+** The compiler generates one of these structures for a class that has\n+** instance variables defined in its specification. \n+*/\n+typedef struct objc_ivar* Ivar_t;\n+typedef struct objc_ivar_list {\n+  int   ivar_count;                             /* Number of structures (Ivar) \n+                                                  contained in the list.  One\n+                                                  structure per instance \n+                                                  variable defined in the\n+                                                  class. */\n+  struct objc_ivar {\n+    const char* ivar_name;                      /* Name of the instance\n+                                                  variable as entered in the\n+                                                  class definition. */\n+    const char* ivar_type;                      /* Description of the Ivar's\n+                                                  type.  Useful for \n+                                                  debuggers. */\n+    int         ivar_offset;                    /* Byte offset from the base \n+                                                  address of the instance \n+                                                  structure to the variable. */\n+\n+  } ivar_list[1];                               /* Variable length \n+                                                  structure. */\n+} IvarList, *IvarList_t;\n+\n+\n+/*\n+** The compiler generates one (or more) of these structures for a class that\n+** has methods defined in its specification. \n+** \n+** The implementation of a class can be broken into separate pieces in a file\n+** and categories can break them across modules. To handle this problem is a\n+** singly linked list of methods. \n+*/\n+typedef struct objc_method Method;\n+typedef Method* Method_t;\n+typedef struct objc_method_list {\n+  struct objc_method_list*  method_next;      /* This variable is used to link \n+                                                a method list to another.  It \n+                                                is a singly linked list. */\n+  int             method_count;               /* Number of methods defined in \n+                                                this structure. */\n+  struct objc_method {\n+    SEL         method_name;                  /* This variable is the method's \n+                                                name.  It is a char*. \n+                                                  The unique integer passed to \n+                                                objc_msg_send is a char* too.  \n+                                                It is compared against \n+                                                method_name using strcmp. */\n+    const char* method_types;                 /* Description of the method's\n+                                                parameter list.  Useful for\n+                                                debuggers. */\n+    IMP         method_imp;                   /* Address of the method in the \n+                                                executable. */\n+  } method_list[1];                           /* Variable length \n+                                                structure. */\n+} MethodList, *MethodList_t;\n+\n+struct objc_protocol_list {\n+  struct objc_protocol_list *next;\n+  int count;\n+  Protocol *list[1];\n+};\n+\n+/*\n+** This is used to assure consistent access to the info field of \n+** classes\n+*/\n+#ifndef HOST_BITS_PER_LONG\n+#define HOST_BITS_PER_LONG  (sizeof(long)*8)\n+#endif \n+\n+#define __CLS_INFO(cls) ((cls)->info)\n+#define __CLS_ISINFO(cls, mask) ((__CLS_INFO(cls)&mask)==mask)\n+#define __CLS_SETINFO(cls, mask) (__CLS_INFO(cls) |= mask)\n+\n+/* The structure is of type MetaClass* */\n+#define _CLS_META 0x2L\n+#define CLS_ISMETA(cls) ((cls)&&__CLS_ISINFO(cls, _CLS_META))\n+\n+\n+/* The structure is of type Class* */\n+#define _CLS_CLASS 0x1L\n+#define CLS_ISCLASS(cls) ((cls)&&__CLS_ISINFO(cls, _CLS_CLASS))\n+\n+/*\n+** The class is initialized within the runtime.  This means that \n+** it has had correct super and sublinks assigned\n+*/\n+#define _CLS_RESOLV 0x8L\n+#define CLS_ISRESOLV(cls) __CLS_ISINFO(cls, _CLS_RESOLV)\n+#define CLS_SETRESOLV(cls) __CLS_SETINFO(cls, _CLS_RESOLV)\n+\n+/*\n+** The class has been send a +initialize message or a such is not \n+** defined for this class\n+*/\n+#define _CLS_INITIALIZED 0x04L\n+#define CLS_ISINITIALIZED(cls) __CLS_ISINFO(cls, _CLS_INITIALIZED)\n+#define CLS_SETINITIALIZED(cls) __CLS_SETINFO(cls, _CLS_INITIALIZED)\n+\n+/*\n+** The class number of this class.  This must be the same for both the \n+** class and it's meta class object\n+*/\n+#define CLS_GETNUMBER(cls) (__CLS_INFO(cls) >> (HOST_BITS_PER_LONG/2))\n+#define CLS_SETNUMBER(cls, num) \\\n+  ({ assert(CLS_GETNUMBER(cls)==0); \\\n+     __CLS_SETINFO(cls, (((unsigned long)num) << (HOST_BITS_PER_LONG/2))); })\n+\n+/*\n+** The compiler generates one of these structures for each category.  A class\n+** may have many categories and contain both instance and factory methods.  \n+*/\n+typedef struct objc_category {\n+  const char*   category_name;                /* Name of the category.  Name\n+                                                contained in the () of the\n+                                                category definition. */\n+  const char*   class_name;                   /* Name of the class to which\n+                                                the category belongs. */\n+  MethodList_t  instance_methods;             /* Linked list of instance\n+                                                methods defined in the \n+                                                category. NULL indicates no\n+                                                instance methods defined. */\n+  MethodList_t  class_methods;                /* Linked list of factory \n+                                                methods defined in the\n+                                                category.  NULL indicates no\n+                                                class methods defined. */\n+  struct objc_protocol_list *protocols;\t      /* List of Protocols \n+\t\t\t\t\t         conformed to */\n+} Category, *Category_t;\n+\n+/*\n+** Structure used when a message is send to a class's super class.  The\n+** compiler generates one of these structures and passes it to\n+** objc_msg_super.\n+*/\n+typedef struct objc_super {\n+  id      self;                           /* Id of the object sending\n+                                                the message. */\n+  Class* class;                              /* Object's super class. */\n+} Super, *Super_t;\n+\n+IMP objc_msg_lookup_super(Super_t super, SEL sel);\n+\n+retval_t objc_msg_sendv(id, SEL, size_t, arglist_t);\n+\n+\n+\n static const ARGSIZE = 96;\t\t/* for `method_get_argsize()' */\n \n /*\n@@ -64,18 +312,7 @@ SEL sel_register_name(const char *name);\n \n BOOL sel_is_mapped (SEL aSel);\n \n-extern inline id\n-class_create_instance(Class* class)\n-{\n-  id new = nil;\n-  if (CLS_ISCLASS(class))\n-    new = (_objc_object_alloc\n-           ?(*_objc_object_alloc)(class)\n-           :(id)malloc(class->instance_size));\n-  if (new!=nil)\n-    new->class_pointer = class;\n-  return new;\n-}\n+extern id class_create_instance(Class* class);\n \n static inline const char *\n class_get_class_name(Class* class)\n@@ -141,36 +378,9 @@ method_get_imp(Method_t method)\n \n IMP get_imp (Class* class, SEL sel);\n \n-extern inline id\n-object_copy(id object)\n-{\n-  if ((object!=nil)&&CLS_ISCLASS(object->class_pointer))\n-    {\n-      if (_objc_object_copy)\n-        return (*_objc_object_copy)(object);\n-      else\n-        {\n-          id copy = class_create_instance(object->class_pointer);\n-          if (copy!=nil)\n-            memcpy(copy, object, (size_t)object->class_pointer->instance_size);\n-          return copy;\n-        }\n-      return nil;\n-    }\n-}\n+id object_copy(id object);\n \n-extern inline id\n-object_dispose(id object)\n-{\n-  if ((object!=nil)&&CLS_ISCLASS(object->class_pointer))\n-    {\n-      if (_objc_object_dispose)\n-        (*_objc_object_dispose)(object);\n-      else\n-        free(object);\n-    }\n-  return nil;\n-}\n+id object_dispose(id object);\n \n static inline Class*\n object_get_class(id object)\n@@ -234,105 +444,7 @@ object_is_meta_class(id object)\n   return CLS_ISMETA((Class*)object);\n }\n \n+#endif /* not __objc_api_INCLUDE_GNU */\n \n-/* Archiving stuff */\n-\n-#ifndef __alpha__\n-\n-typedef int (*objc_typed_read_func)(void*, char*, int);\n-typedef int (*objc_typed_write_func)(void*, const char*, int);\n-typedef int (*objc_typed_flush_func)(void*);\n-typedef int (*objc_typed_eof_func)(void*);\n-\n-#define OBJC_READONLY   0x01\n-#define OBJC_WRITEONLY  0x02\n-\n-#define OBJC_MANAGED_STREAM  0x01\n-#define OBJC_FILE_STREAM     0x02\n-#define OBJC_MEMORY_STREAM   0x04\n-\n-#define OBJC_TYPED_STREAM_VERSION 0x01\n-\n-struct objc_typed_stream {\n-  void* physical;\n-  cache_ptr object_table;\t/* read/written objects */\n-  cache_ptr stream_table;\t/* other read/written but shared things.. */\n-  cache_ptr class_table;\t/* class version mapping */\n-  cache_ptr object_refs;\t/* forward references */\n-  int mode;\t\t\t/* OBJC_READONLY or OBJC_WRITEONLY */\n-  int type;\t\t\t/* MANAGED, FILE, MEMORY etc bit string */\n-  int version;\t\t\t/* version used when writing */\n-  int writing_root_p;\n-  objc_typed_read_func read;\n-  objc_typed_write_func write;\n-  objc_typed_eof_func eof;\n-  objc_typed_flush_func flush;\n-};\n-\n-/* opcode masks */\n-#define _B_VALUE   0x1fU\n-#define _B_CODE    0xe0U\n-#define _B_SIGN    0x10U\n-#define _B_NUMBER  0x0fU\n-\n-/* standard opcodes */\n-#define _B_INVALID 0x00U\n-#define _B_SINT    0x20U\n-#define _B_NINT    0x40U\n-#define _B_SSTR    0x60U\n-#define _B_NSTR    0x80U\n-#define _B_RCOMM   0xa0U\n-#define _B_UCOMM   0xc0U\n-#define _B_EXT     0xe0U\n-\n-/* eXtension opcodes */\n-#define _BX_OBJECT  0x00U\n-#define _BX_CLASS   0x01U\n-#define _BX_SEL     0x02U\n-#define _BX_OBJREF  0x03U\n-#define _BX_OBJROOT 0x04U\n-#define _BX_EXT     0x1fU\n-\n-/*\n-** Read and write objects as specified by TYPE.  All the `last'\n-** arguments are pointers to the objects to read/write.  \n-*/\n-\n-int objc_write_type (TypedStream* stream, const char* type, const void* data);\n-int objc_read_type (TypedStream* stream, const char* type, void* data);\n-\n-int objc_write_types (TypedStream* stream, const char* type, ...);\n-int objc_read_types (TypedStream* stream, const char* type, ...);\n-\n-int objc_write_object_reference (TypedStream* stream, id object);\n-int objc_write_root_object (TypedStream* stream, id object);\n-\n-int objc_get_stream_class_version (TypedStream* stream, Class* class);\n-\n-\n-/*\n-** Convenience funtions\n-*/\n-\n-int objc_write_array (TypedStream* stream, const char* type,\n-\t\t      int count, const void* data);\n-int objc_read_array (TypedStream* stream, const char* type,\n-\t\t     int count, void* data);\n-\n-int objc_write_object (TypedStream* stream, id object);\n-\n-/*\n-** Open a typed stream for reading or writing.  MODE may be either of\n-** OBJC_READONLY or OBJC_WRITEONLY.  \n-*/\n-\n-TypedStream* objc_open_typed_stream (FILE* physical, int mode);\n-TypedStream* objc_open_typed_stream_for_file (const char* file_name, int mode);\n-\n-void objc_close_typed_stream (TypedStream* stream);\n \n-BOOL objc_end_of_typed_stream (TypedStream* stream);\n-void objc_flush_typed_stream (TypedStream* stream);\n \n-#endif /* __alpha__ */\n-#endif /* not __objc_api_INCLUDE_GNU */"}, {"sha": "e245a02cbc0f9e1f39471227b06da49234f08bd3", "filename": "gcc/objc/objc.h", "status": "modified", "additions": 22, "deletions": 350, "changes": 372, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/991d3e71ced0bb2e4c70807831d4c95a59edde51/gcc%2Fobjc%2Fobjc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/991d3e71ced0bb2e4c70807831d4c95a59edde51/gcc%2Fobjc%2Fobjc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc.h?ref=991d3e71ced0bb2e4c70807831d4c95a59edde51", "patch": "@@ -26,35 +26,15 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #ifndef __objc_INCLUDE_GNU\n #define __objc_INCLUDE_GNU\n \n-#ifdef IN_GCC\n-#include \"config.h\"\n-#include \"gstddef.h\"\n-#else\n-#include <stddef.h>\n+#ifdef __cplusplus\n+extern \"C\" {\n #endif\n \n-extern size_t strlen(char*);\n-extern void* malloc(size_t);\n-extern void* calloc(size_t, size_t);\n-extern void* realloc(const void*, size_t);\n-extern void free(const void*);\n+#include <stddef.h>\n \n /*\n-** Hash-cache or sparse arrays?\n-*/ \n-#define OBJC_SPARSE_LOOKUP \t/* use sparse-arrays for lookup */\n-/* #define OBJC_HASH_LOOKUP */ /* use hash-cache for lookup */\n-\n-#ifdef OBJC_SPARSE_LOOKUP\n-extern const char* __objc_sparse_lookup_id;\n-#endif\n-\n-#ifdef OBJC_HASH_LOOKUP\n-extern const char* __objc_hash_lookup_id;\n-#endif\n-\n-#ifndef __object_INCLUDE_GNU\n-\n+** Definition of the boolean type.  \n+*/\n typedef char  BOOL;\n #define YES   (BOOL)1\n #define NO    (BOOL)0\n@@ -74,209 +54,19 @@ typedef struct objc_object {\n   struct objc_class*  class_pointer;\n } *id;\n \n+/*\n+** Definition of method type.  When retrieving the implementation of a\n+** method, this is type of the pointer returned\n+*/\n typedef id (*IMP)(id, SEL, ...); \n \n /*\n-** The compiler generates one of these structures for each class.  \n-**\n-** This structure is the definition for meta classes. By definition a meta\n-** class is the class's class.  Its most relevant contribution is that its\n-** method list contain the class's factory methods. \n-**\n-** This structure is generated by the compiler in the executable and used by\n-** the run-time during normal messaging operations.  Therefore some members\n-** change type. The compiler generates \"char* const\" and places a string in\n-** the following member variables:  class_pointer and super_class. \n+** More simple types...\n */\n-typedef struct objc_class MetaClass;\n-typedef struct objc_class Class;\n-\n #define nil (id)0                               /* id of Nil instance */\n #define Nil (Class*)0                          /* id of Nil class */\n typedef char *STR;                              /* String alias */\n \n-#endif /* __object_INCLUDE_GNU */\n-\n-/* For functions which return Method_t */\n-#define METHOD_NULL\t(Method_t)0\n-                                                /* Boolean typedefs */\n-/*\n-** Method descriptor returned by introspective Object methods.\n-** This is really just the first part of the more complete objc_method\n-** structure defined below and used internally by the runtime.\n-*/\n-struct objc_method_description\n-{\n-    SEL name;\t\t\t/* this is a selector, not a string */\n-    char *types;\t\t/* type encoding */\n-};\n-\n-\n-\n-/* Filer types used to describe Ivars and Methods.  */\n-#define _C_ID       '@'\n-#define _C_CLASS    '#'\n-#define _C_SEL      ':'\n-#define _C_CHR      'c'\n-#define _C_UCHR     'C'\n-#define _C_SHT      's'\n-#define _C_USHT     'S'\n-#define _C_INT      'i'\n-#define _C_UINT     'I'\n-#define _C_LNG      'l'\n-#define _C_ULNG     'L'\n-#define _C_FLT      'f'\n-#define _C_DBL      'd'\n-#define _C_BFLD     'b'\n-#define _C_VOID     'v'\n-#define _C_UNDEF    '?'\n-#define _C_PTR      '^'\n-#define _C_CHARPTR  '*'\n-#define _C_ATOM     '%'\n-#define _C_ARY_B    '['\n-#define _C_ARY_E    ']'\n-#define _C_UNION_B  '('\n-#define _C_UNION_E  ')'\n-#define _C_STRUCT_B '{'\n-#define _C_STRUCT_E '}'\n-\n-\n-\n-/*\n-** Set this variable nonzero to print a line describing each\n-** message that is sent.\n-*/\n-extern BOOL objc_trace;\n-\n-\n-/*\n-** Whereas a Module (defined further down) is the root (typically) of a file,\n-** a Symtab is the root of the class and category definitions within the\n-** module.  \n-** \n-** A Symtab contains a variable length array of pointers to classes and\n-** categories  defined in the module. \n-*/\n-typedef struct objc_symtab {\n-  unsigned long sel_ref_cnt;                     /* Unknown. */\n-  SEL       *refs;                              /* Unknown. */\n-  unsigned short cls_def_cnt;                   /* Number of classes compiled\n-                                                  (defined) in the module. */\n-  unsigned short cat_def_cnt;                   /* Number of categories \n-                                                  compiled (defined) in the \n-                                                  module. */\n-  void      *defs[1];                           /* Variable array of pointers.\n-                                                  cls_def_cnt of type Class* \n-                                                  followed by cat_def_cnt of\n-                                                  type Category_t. */\n-} Symtab,   *Symtab_t;\n-\n-\n-/*\n-** The compiler generates one of these structures for each module that\n-** composes the executable (eg main.m).  \n-** \n-** This data structure is the root of the definition tree for the module.  \n-** \n-** A collect program runs between ld stages and creates a ObjC ctor array. \n-** That array holds a pointer to each module structure of the executable. \n-*/\n-typedef struct objc_module {\n-  unsigned long version;                        /* Compiler revision. */\n-  unsigned long size;                           /* sizeof(Module). */\n-  const char* name;                             /* Name of the file where the \n-                                                  module was generated.   The \n-                                                  name includes the path. */\n-  Symtab_t    symtab;                           /* Pointer to the Symtab of\n-                                                  the module.  The Symtab\n-                                                  holds an array of pointers to \n-                                                  the classes and categories \n-                                                  defined in the module. */\n-} Module, *Module_t;\n-\n-\n-/*\n-** The compiler generates one of these structures for a class that has\n-** instance variables defined in its specification. \n-*/\n-typedef struct objc_ivar* Ivar_t;\n-typedef struct objc_ivar_list {\n-  int   ivar_count;                             /* Number of structures (Ivar) \n-                                                  contained in the list.  One\n-                                                  structure per instance \n-                                                  variable defined in the\n-                                                  class. */\n-  struct objc_ivar {\n-    const char* ivar_name;                      /* Name of the instance\n-                                                  variable as entered in the\n-                                                  class definition. */\n-    const char* ivar_type;                      /* Description of the Ivar's\n-                                                  type.  Useful for \n-                                                  debuggers. */\n-    int         ivar_offset;                    /* Byte offset from the base \n-                                                  address of the instance \n-                                                  structure to the variable. */\n-\n-  } ivar_list[1];                               /* Variable length \n-                                                  structure. */\n-} IvarList, *IvarList_t;\n-\n-\n-/*\n-** The compiler generates one (or more) of these structures for a class that\n-** has methods defined in its specification. \n-** \n-** The implementation of a class can be broken into separate pieces in a file\n-** and categories can break them across modules. To handle this problem is a\n-** singly linked list of methods. \n-*/\n-typedef struct objc_method Method;\n-typedef Method* Method_t;\n-typedef struct objc_method_list {\n-  struct objc_method_list*  method_next;      /* This variable is used to link \n-                                                a method list to another.  It \n-                                                is a singly linked list. */\n-  int             method_count;               /* Number of methods defined in \n-                                                this structure. */\n-  struct objc_method {\n-    SEL         method_name;                  /* This variable is the method's \n-                                                name.  It is a char*. \n-                                                  The unique integer passed to \n-                                                objc_msg_send is a char* too.  \n-                                                It is compared against \n-                                                method_name using strcmp. */\n-    const char* method_types;                 /* Description of the method's\n-                                                parameter list.  Useful for\n-                                                debuggers. */\n-    IMP         method_imp;                   /* Address of the method in the \n-                                                executable. */\n-  } method_list[1];                           /* Variable length \n-                                                structure. */\n-} MethodList, *MethodList_t;\n-\n-\n-#include \"objc/sarray.h\"\n-\n-#ifdef OBJC_HASH_LOOKUP\n-\n-/*\n-** This data structure is used for the hash lookup mechanism.  When\n-** enabled, the runtime keeps a such cache of buckets for each class.\n-*/\n-typedef struct objc_cache* Cache_t;\n-typedef struct objc_bucket* Bucket_t;\n-typedef struct objc_bucket Bucket;\n-struct objc_cache {\n-  unsigned int mask;\t\t/* total = mask+1 */\n-  unsigned int occupied;\n-  struct objc_bucket {\n-    SEL method_selector;\n-    IMP method_imp;\n-  } buckets[1];\n-} Cache;\n-\n-#endif\n-\n /*\n ** The compiler generates one of these structures for each class.  \n ** \n@@ -287,6 +77,8 @@ struct objc_cache {\n ** change type. The compiler generates \"char* const\" and places a string in\n ** the following member variables:  super_class. \n */\n+typedef struct objc_class MetaClass;\n+typedef struct objc_class Class;\n struct objc_class {     \n   MetaClass*         class_pointer;          /* Pointer to the class's\n                                                 meta class. */\n@@ -301,33 +93,24 @@ struct objc_class {\n                                                 The sum of the class definition \n                                                 and all super class \n                                                 definitions. */\n-  IvarList_t          ivars;                  /* Pointer to a structure that\n+  struct objc_ivar_list* ivars;               /* Pointer to a structure that\n                                                 describes the instance \n                                                 variables in the class\n                                                 definition.  NULL indicates\n                                                 no instance variables.  Does\n                                                 not include super class\n                                                 variables. */\n-  MethodList_t        methods;                /* Linked list of instance\n+  struct objc_method_list*  methods;          /* Linked list of instance\n                                                 methods defined for the \n                                                 class. */\n-#ifdef OBJC_HASH_LOOKUP\n-  Cache_t\t     cache;                   /* Pointer to method cache */\n-#else\n   struct sarray *    dtable;                  /* Pointer to instance \n \t\t\t\t\t         method dispatch table. */  \n-#endif\n-\n   struct objc_class* subclass_list;           /* Subclasses */\n   struct objc_class* sibling_class;\n \n   struct objc_protocol_list *protocols;\t      /* Protocols conformed to */\n-\n };\n \n-#ifndef __object_INCLUDE_GNU\n-/* Protocol support */\n-\n #ifndef __OBJC__\n typedef struct objc_protocol {\n   char *protocol_name;\n@@ -340,108 +123,9 @@ typedef struct objc_protocol {\n @class Protocol;\n #endif \n \n-#endif\n-\n-struct objc_protocol_list {\n-  struct objc_protocol_list *next;\n-  int count;\n-  Protocol *list[1];\n-};\n-\n-/*\n-** This is used to assure consistent access to the info field of \n-** classes\n-*/\n-#ifndef HOST_BITS_PER_LONG\n-#define HOST_BITS_PER_LONG  (sizeof(long)*8)\n-#endif \n-\n-#define __CLS_INFO(cls) ((cls)->info)\n-#define __CLS_ISINFO(cls, mask) ((__CLS_INFO(cls)&mask)==mask)\n-#define __CLS_SETINFO(cls, mask) (__CLS_INFO(cls) |= mask)\n-\n-/* The structure is of type MetaClass* */\n-#define _CLS_META 0x2L\n-#define CLS_ISMETA(cls) ((cls)&&__CLS_ISINFO(cls, _CLS_META))\n-\n-\n-/* The structure is of type Class* */\n-#define _CLS_CLASS 0x1L\n-#define CLS_ISCLASS(cls) ((cls)&&__CLS_ISINFO(cls, _CLS_CLASS))\n-\n-/*\n-** The class is initialized within the runtime.  This means that \n-** it has had correct super and sublinks assigned\n-*/\n-#define _CLS_RESOLV 0x8L\n-#define CLS_ISRESOLV(cls) __CLS_ISINFO(cls, _CLS_RESOLV)\n-#define CLS_SETRESOLV(cls) __CLS_SETINFO(cls, _CLS_RESOLV)\n-\n-/*\n-** The class has been send a +initialize message or a such is not \n-** defined for this class\n-*/\n-#define _CLS_INITIALIZED 0x04L\n-#define CLS_ISINITIALIZED(cls) __CLS_ISINFO(cls, _CLS_INITIALIZED)\n-#define CLS_SETINITIALIZED(cls) __CLS_SETINFO(cls, _CLS_INITIALIZED)\n-\n-/*\n-** The class number of this class.  This must be the same for both the \n-** class and it's meta class object\n-*/\n-#define CLS_GETNUMBER(cls) (__CLS_INFO(cls) >> (HOST_BITS_PER_LONG/2))\n-#define CLS_SETNUMBER(cls, num) \\\n-  ({ assert(CLS_GETNUMBER(cls)==0); \\\n-     __CLS_SETINFO(cls, (((unsigned long)num) << (HOST_BITS_PER_LONG/2))); })\n-\n-/*\n-** The compiler generates one of these structures for each category.  A class\n-** may have many categories and contain both instance and factory methods.  \n-*/\n-typedef struct objc_category {\n-  const char*   category_name;                /* Name of the category.  Name\n-                                                contained in the () of the\n-                                                category definition. */\n-  const char*   class_name;                   /* Name of the class to which\n-                                                the category belongs. */\n-  MethodList_t  instance_methods;             /* Linked list of instance\n-                                                methods defined in the \n-                                                category. NULL indicates no\n-                                                instance methods defined. */\n-  MethodList_t  class_methods;                /* Linked list of factory \n-                                                methods defined in the\n-                                                category.  NULL indicates no\n-                                                class methods defined. */\n-  struct objc_protocol_list *protocols;\t      /* List of Protocols \n-\t\t\t\t\t         conformed to */\n-} Category, *Category_t;\n-\n-/*\n-** Well...\n-*/\n-\n-#ifndef __object_INCLUDE_GNU\n-typedef struct objc_typed_stream TypedStream;\n-#endif\n-\n-/*\n-** Structure used when a message is send to a class's super class.  The\n-** compiler generates one of these structures and passes it to\n-** objc_msg_super.\n-*/\n-typedef struct objc_super {\n-  id      self;                           /* Id of the object sending\n-                                                the message. */\n-  Class* class;                              /* Object's super class. */\n-} Super, *Super_t;\n-\n-IMP objc_msg_lookup_super(Super_t super, SEL sel);\n-\n typedef void* retval_t;\t\t/* return value */\n typedef void(*apply_t)(void);\t/* function pointer */\n \n-#ifndef __object_INCLUDE_GNU\n-\n #if defined(REG_ARGS) || defined(STACK_ARGS) \n \n typedef struct {\n@@ -467,29 +151,13 @@ typedef struct {\n typedef void* arglist_t;\n \n #endif\n-#endif /* not __object_INCLUDE_GNU */\n \n-retval_t objc_msg_sendv(id, SEL, size_t, arglist_t);\n+#if defined(__OBJC__) \n \n-#ifdef __OBJC__\n+#include \"objc/sarray.h\"\n \n static id nil_method(id rcv, SEL op, ...) { return rcv; }\n \n-#ifdef OBJC_HASH_LOOKUP\n-\n-#include \"objc/cache.h\"\n-\n-extern __inline__ IMP\n-objc_msg_lookup(id receiver, SEL op)\n-{\n-  if(receiver)\n-    return cache_get(receiver->class_pointer, op);\n-  else\n-    return nil_method;\n-}\n-\n-#else /* not OBJC_HASH_LOOKUP => OBJC_SPARSE_LOOKUP */\n-\n extern __inline__ IMP\n objc_msg_lookup(id receiver, SEL op)\n {\n@@ -498,11 +166,15 @@ objc_msg_lookup(id receiver, SEL op)\n   else\n     return nil_method;\n }\n-#endif /* not OBJC_HASH_LOOKUP */\n \n #else\n- IMP objc_msg_lookup(id, SEL);\n+\n+IMP objc_msg_lookup(id receiver, SEL op);\n+\n #endif\n \n+#ifdef __cplusplus\n+}\n+#endif\n \n #endif /* not __objc_INCLUDE_GNU */"}, {"sha": "7574412cc3b31b339cddbe274925a127b6d34f20", "filename": "gcc/objc/objects.c", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/991d3e71ced0bb2e4c70807831d4c95a59edde51/gcc%2Fobjc%2Fobjects.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/991d3e71ced0bb2e4c70807831d4c95a59edde51/gcc%2Fobjc%2Fobjects.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjects.c?ref=991d3e71ced0bb2e4c70807831d4c95a59edde51", "patch": "@@ -37,21 +37,34 @@ id (*_objc_object_copy)(id)       = __objc_object_copy;\n id\n class_create_instance(Class* class)\n {\n-  id res = (*_objc_object_alloc)(class);\n-  res->class_pointer = class;\n-  return res;\n+  id new = nil;\n+  if (CLS_ISCLASS(class))\n+    new = (*_objc_object_alloc)(class);\n+  if (new!=nil)\n+    new->class_pointer = class;\n+  return new;\n }\n \n-id \n+id\n object_copy(id object)\n {\n-  return (*_objc_object_copy)(object);\n+  if ((object!=nil)&&CLS_ISCLASS(object->class_pointer))\n+    return (*_objc_object_copy)(object);\n+  else\n+    return nil;\n }\n \n-id \n+id\n object_dispose(id object)\n {\n-  return (*_objc_object_dispose)(object);\n+  if ((object!=nil)&&CLS_ISCLASS(object->class_pointer))\n+    {\n+      if (_objc_object_dispose)\n+        (*_objc_object_dispose)(object);\n+      else\n+        free(object);\n+    }\n+  return nil;\n }\n \n id __objc_object_alloc(Class* class)"}, {"sha": "493111796c2afa2edc520f69f21a0033eeb3ef44", "filename": "gcc/objc/runtime.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/991d3e71ced0bb2e4c70807831d4c95a59edde51/gcc%2Fobjc%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/991d3e71ced0bb2e4c70807831d4c95a59edde51/gcc%2Fobjc%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fruntime.h?ref=991d3e71ced0bb2e4c70807831d4c95a59edde51", "patch": "@@ -28,11 +28,10 @@ You should have received a copy of the GNU General Public License along with\n #define __objc_runtime_INCLUDE_GNU\n \n #include <stdio.h>\n-#include <memory.h>\n #include <ctype.h>\n \n-#include \"gstdarg.h\"\t\t/* for varargs and va_list's */\n-#include \"gstddef.h\"\t\t/* so noone else will get system versions */\n+#include \"stdarg.h\"\t\t/* for varargs and va_list's */\n+#include \"stddef.h\"\t\t/* so noone else will get system versions */\n #include \"assert.h\"\n \n #include \"objc/objc.h\"\t\t/* core data types */"}, {"sha": "ad69be97010fce4a7eda212954cc1b873c226aa3", "filename": "gcc/objc/sarray.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/991d3e71ced0bb2e4c70807831d4c95a59edde51/gcc%2Fobjc%2Fsarray.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/991d3e71ced0bb2e4c70807831d4c95a59edde51/gcc%2Fobjc%2Fsarray.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fsarray.c?ref=991d3e71ced0bb2e4c70807831d4c95a59edde51", "patch": "@@ -26,7 +26,6 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"objc/sarray.h\"\n #include <stdio.h>\n #include \"assert.h\"\n-#include <memory.h>\n \n int nbuckets = 0;\n int nindices = 0;"}, {"sha": "4833203a6fd820353d851ad9f2d61420a7779ed4", "filename": "gcc/objc/sarray.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/991d3e71ced0bb2e4c70807831d4c95a59edde51/gcc%2Fobjc%2Fsarray.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/991d3e71ced0bb2e4c70807831d4c95a59edde51/gcc%2Fobjc%2Fsarray.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fsarray.h?ref=991d3e71ced0bb2e4c70807831d4c95a59edde51", "patch": "@@ -39,11 +39,7 @@ extern const char* __objc_sparse2_id;\n extern const char* __objc_sparse3_id;\n #endif\n \n-#ifdef IN_GCC\n-#include \"gstddef.h\"\n-#else\n #include <stddef.h>\n-#endif\n \n extern int nbuckets;\t\t/* for stats */\n extern int nindices;"}, {"sha": "40bc7a338c32381ab296e10906d2cb110f14cc2b", "filename": "gcc/objc/selector.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/991d3e71ced0bb2e4c70807831d4c95a59edde51/gcc%2Fobjc%2Fselector.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/991d3e71ced0bb2e4c70807831d4c95a59edde51/gcc%2Fobjc%2Fselector.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fselector.c?ref=991d3e71ced0bb2e4c70807831d4c95a59edde51", "patch": "@@ -109,10 +109,8 @@ sel_is_mapped (SEL selector)\n   return ((idx > 0) && (idx <= __objc_selector_max_index));\n }\n \n-#ifdef OBJC_SPARSE_LOOKUP\n /* The uninstalled dispatch table */\n extern struct sarray* __objc_uninstalled_dtable;\n-#endif\n \n /* Store the passed selector name in the selector record and return its\n    selector value (value returned by sel_get_uid). */\n@@ -134,9 +132,7 @@ sel_register_name (const char *sel)\n   sarray_at_put_safe (__objc_selector_array, i, (void *) sel);\n   hash_add (&__objc_selector_hash, (void *) sel, (void *) i);\n \n-#ifdef OBJC_SPARSE_LOOKUP\n   sarray_realloc(__objc_uninstalled_dtable, __objc_selector_max_index+1);\n-#endif\n \n   return (SEL) i;\n }"}, {"sha": "3638c79acc18f60bd7787782ea2372d4fbd91c2a", "filename": "gcc/objc/sendmsg.c", "status": "modified", "additions": 1, "deletions": 133, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/991d3e71ced0bb2e4c70807831d4c95a59edde51/gcc%2Fobjc%2Fsendmsg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/991d3e71ced0bb2e4c70807831d4c95a59edde51/gcc%2Fobjc%2Fsendmsg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fsendmsg.c?ref=991d3e71ced0bb2e4c70807831d4c95a59edde51", "patch": "@@ -25,33 +25,18 @@ You should have received a copy of the GNU General Public License along with\n    covered by the GNU General Public License.  */\n \n #include \"runtime.h\"\n+#include \"sarray.h\"\n \n-#ifdef OBJC_SPARSE_LOOKUP\n-const char* __objc_sparse_lookup_id = \"Method lookup uses sparse arrays\";\n-#endif\n-\n-#ifdef OBJC_HASH_LOOKUP\n-const char* __objc_hash_lookup_id = \"Method lookup uses hash caching\";\n-#endif\n-\n-#ifdef OBJC_HASH_LOOKUP\n-#include \"objc/cache.h\"\n-#endif\n-\n-#ifdef OBJC_SPARSE_LOOKUP\n /* The uninstalled dispatch table */\n struct sarray* __objc_uninstalled_dtable = 0;\n-#endif\n \n /* Send +initialize to class */\n static void __objc_send_initialize(Class*);\n \n static void __objc_install_dispatch_table_for_class (Class*);\n \n /* Forward declare some functions */\n-#ifdef OBJC_SPARSE_LOOKUP\n static void __objc_init_install_dtable(id, SEL);\n-#endif\n static id __objc_missing_method(id, SEL, ...);\n static Method_t search_for_method_in_hierarchy (Class* class, SEL sel);\n static Method_t search_for_method_in_list(MethodList_t list, SEL op);\n@@ -67,14 +52,10 @@ nil_method(id receiver, SEL op, ...)\n __inline__ IMP\n get_imp (Class* class, SEL sel)\n {\n-#ifdef OBJC_SPARSE_LOOKUP\n   void* res = sarray_get (class->dtable, (size_t) sel);\n   if(res == __objc_init_install_dtable)\n     __objc_install_dispatch_table_for_class (class);\n   return sarray_get (class->dtable, (size_t) sel);\n-#else\n-  return cache_get (class, sel);\n-#endif\n }\n \n __inline__ BOOL\n@@ -91,11 +72,7 @@ __inline__ IMP\n objc_msg_lookup(id receiver, SEL op)\n {\n   if(receiver)\n-#ifdef OBJC_HASH_LOOKUP\n-    return cache_get(receiver->class_pointer, op);\n-#else\n     return sarray_get(receiver->class_pointer->dtable, (sidx)op);\n-#endif\n   else\n     return nil_method;\n }\n@@ -127,13 +104,10 @@ objc_msg_sendv(id object, SEL op, size_t frame_size, arglist_t arg_frame)\n \n void __objc_init_dispatch_tables()\n {\n-#ifdef OBJC_SPARSE_LOOKUP  \n   __objc_uninstalled_dtable\n     = sarray_new(200, __objc_init_install_dtable);\n-#endif\n }\n \n-#ifdef OBJC_SPARSE_LOOKUP\n /* This one is a bit hairy.  This function is installed in the \n    premature dispatch table, and thus called once for each class,\n    namely when the very first message is send to it.  */\n@@ -187,18 +161,13 @@ static void __objc_init_install_dtable(id receiver, SEL op)\n   __builtin_return (result);\n   \n }\n-#endif\n \n /* Install dummy table for class which causes the first message to\n    that class (or instances hereof) to be initialized properly */\n void __objc_install_premature_dtable(Class* class)\n {\n-#ifdef OBJC_SPARSE_LOOKUP\n   assert(__objc_uninstalled_dtable);\n   class->dtable = __objc_uninstalled_dtable;\n-#else\n-  class->cache = (Cache_t)__objc_xcalloc(1, sizeof(Cache));\n-#endif\n }   \n \n /* Send +initialize to class if not already done */\n@@ -231,7 +200,6 @@ static void __objc_send_initialize(Class* class)\n static void\n __objc_install_dispatch_table_for_class (Class* class)\n {\n-#ifdef OBJC_SPARSE_LOOKUP\n   Class* super;\n   MethodList_t mlist;\n   int counter;\n@@ -267,37 +235,21 @@ __objc_install_dispatch_table_for_class (Class* class)\n           counter -= 1;\n         }\n     }\n-#endif\n }\n \n void __objc_update_dispatch_table_for_class (Class* class)\n {\n   Class* next;\n-#ifdef OBJC_SPARSE_LOOKUP\n   struct sarray* save;\n-#else\n-  Cache_t save;\n-#endif\n \n   /* not yet installed -- skip it */\n-#ifdef OBJC_SPARSE_LOOKUP\n   if (class->dtable == __objc_uninstalled_dtable) \n-#else\n-  if (class->cache->mask == 0)\n-#endif\n     return;\n \n-#ifdef OBJC_SPARSE_LOOKUP\n   save = class->dtable;\n   __objc_install_premature_dtable (class);\n   sarray_free (save);\n \n-#else\n-  save = class->cache;\n-  __objc_install_premature_dtable (class);\n-  free(save);\n-\n-#endif\n \n   if (class->subclass_list)\t/* Traverse subclasses */\n     for (next = class->subclass_list; next; next = next->sibling_class)\n@@ -474,108 +426,24 @@ void __objc_print_dtable_stats()\n {\n   int total = 0;\n   printf(\"memory usage: (%s)\\n\",\n-#ifdef OBJC_SPARSE_LOOKUP\n #ifdef OBJC_SPARSE2\n \t \"2-level sparse arrays\"\n #else\n \t \"3-level sparse arrays\"\n-#endif\n-#else\n-\t \"hash-cache\"\n #endif\n \t );\n \n-#ifdef OBJC_SPARSE_LOOKUP\n   printf(\"arrays: %d = %d bytes\\n\", narrays, narrays*sizeof(struct sarray));\n   total += narrays*sizeof(struct sarray);\n-#ifdef OBJC_SPARSE3\n-  printf(\"indices: %d = %d bytes\\n\", nindices, nindices*sizeof(struct sindex));\n-  total += nindices*sizeof(struct sindex);\n-#endif\n   printf(\"buckets: %d = %d bytes\\n\", nbuckets, nbuckets*sizeof(struct sbucket));\n   total += nbuckets*sizeof(struct sbucket);\n \n   printf(\"idxtables: %d = %d bytes\\n\", idxsize, idxsize*sizeof(void*));\n   total += idxsize*sizeof(void*);\n-#else /* HASH_LOOKUP */\n-  total = __objc_class_hash_tables_size ();\n-#endif\n   printf(\"-----------------------------------\\n\");\n   printf(\"total: %d bytes\\n\", total);\n   printf(\"===================================\\n\");\n }\n \n-#ifdef OBJC_HASH_LOOKUP\n-static Cache_t __objc_cache_insert(Cache_t cache, SEL op, IMP imp);\n-\n-static Cache_t\n-__objc_double_cache(Cache_t cache)\n-{\n-  int i;\n-  Cache_t newc = (Cache_t)__objc_xcalloc(1, sizeof(Cache)\n-\t\t\t\t\t +(sizeof(Cache)*2*(cache->mask+1)));\n-  newc->occupied = cache->occupied;\n-  newc->mask = ((cache->mask)<<1) | 1;\n-  for(i=0; i <= cache->mask; i++)\n-    newc = __objc_cache_insert(newc,\n-\t\t\t       cache->buckets[i].method_selector,\n-\t\t\t       cache->buckets[i].method_imp);\n-  free(cache);\n-  return newc;\n-}\n-\n-\n-static Cache_t\n-__objc_cache_insert(Cache_t cache, SEL op, IMP imp)\n-{\n-  int index = ((size_t)op)&(cache)->mask;\n-\n-  if(op == 0)\n-    return cache;\n-\n-  do\n-    {\n-      if((cache)->buckets[index].method_selector == 0)\n-\t{\n-\t  (cache)->buckets[index].method_selector = op;\n-\t  (cache)->buckets[index].method_imp = imp;\n-\t  (cache)->occupied += 1;\n-\t  return cache;\n-\t}\n-    }\n-  while (--index >= 0);\n-    \n-  cache = __objc_double_cache(cache);\n-  return __objc_cache_insert(cache, op, imp);\n-}\n-\n-void* \n-__objc_cache_miss(Class* class, SEL op) \n-{\n-  Method_t m;\n-  Cache_t cache = class->cache;\n-  \n-  if(!CLS_ISRESOLV(class))\n-    __objc_resolve_class_links();\n-\n-  m = search_for_method_in_hierarchy(class, op);\n-\n-  if(!CLS_ISINITIALIZED(class))\n-    if(CLS_ISMETA(class))\n-      __objc_send_initialize(objc_get_class(class->name));\n-    else\n-      __objc_send_initialize(class);\n-\n-  if(m == NULL)\n-    return __objc_missing_method;\n-\n-  if((cache->occupied+2)*2 > cache->mask)\n-    class->cache = __objc_double_cache(cache);\n-  \n-  class->cache = __objc_cache_insert(class->cache, op, m->method_imp);\n-  return m->method_imp;\n-}\n-\n-#endif\n \n "}]}