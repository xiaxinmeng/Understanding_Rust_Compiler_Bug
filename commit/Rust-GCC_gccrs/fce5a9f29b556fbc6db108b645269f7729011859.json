{"sha": "fce5a9f29b556fbc6db108b645269f7729011859", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmNlNWE5ZjI5YjU1NmZiYzZkYjEwOGI2NDUyNjlmNzcyOTAxMTg1OQ==", "commit": {"author": {"name": "Eric Christopher", "email": "echristo@redhat.com", "date": "2002-06-10T20:00:54Z"}, "committer": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2002-06-10T20:00:54Z"}, "message": "i386.c (ix86_osf_output_function_prologue): Remove prototype and function.\n\n2002-06-10  Eric Christopher  <echristo@redhat.com>\n\n\t* config/i386/i386.c (ix86_osf_output_function_prologue): Remove\n\tprototype and function.\n\t(TARGET_ASM_FUNCTION_PROLOGUE): Remove OSF version.\n\t(call_insn_operand): Remove half pic references.\n\t(legitimate_address_p): Ditto.\n\t* config/i386/i386.h: Remove half pic defines.\n\nFrom-SVN: r54451", "tree": {"sha": "04e0304c0ee695567294eac5c7637f7676a842a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/04e0304c0ee695567294eac5c7637f7676a842a9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fce5a9f29b556fbc6db108b645269f7729011859", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fce5a9f29b556fbc6db108b645269f7729011859", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fce5a9f29b556fbc6db108b645269f7729011859", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fce5a9f29b556fbc6db108b645269f7729011859/comments", "author": {"login": "echristo", "id": 327308, "node_id": "MDQ6VXNlcjMyNzMwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/327308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/echristo", "html_url": "https://github.com/echristo", "followers_url": "https://api.github.com/users/echristo/followers", "following_url": "https://api.github.com/users/echristo/following{/other_user}", "gists_url": "https://api.github.com/users/echristo/gists{/gist_id}", "starred_url": "https://api.github.com/users/echristo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/echristo/subscriptions", "organizations_url": "https://api.github.com/users/echristo/orgs", "repos_url": "https://api.github.com/users/echristo/repos", "events_url": "https://api.github.com/users/echristo/events{/privacy}", "received_events_url": "https://api.github.com/users/echristo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e9f095867aed709d0ce9b6e4ee8067ab86da822f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9f095867aed709d0ce9b6e4ee8067ab86da822f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9f095867aed709d0ce9b6e4ee8067ab86da822f"}], "stats": {"total": 250, "additions": 63, "deletions": 187}, "files": [{"sha": "66b9e1a6d68aff4c4b9f1569e9584e3ea8f5c97f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fce5a9f29b556fbc6db108b645269f7729011859/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fce5a9f29b556fbc6db108b645269f7729011859/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fce5a9f29b556fbc6db108b645269f7729011859", "patch": "@@ -1,3 +1,12 @@\n+2002-06-10  Eric Christopher  <echristo@redhat.com>\n+\n+\t* config/i386/i386.c (ix86_osf_output_function_prologue): Remove\n+\tprototype and function.\n+\t(TARGET_ASM_FUNCTION_PROLOGUE): Remove OSF version.\n+\t(call_insn_operand): Remove half pic references.\n+\t(legitimate_address_p): Ditto.\n+\t* config/i386/i386.h: Remove half pic defines.\n+\n 2002-06-10  Eric Christopher  <echristo@redhat.com>\n \n \t* doc/extend.texi (Return Address): Add note explaining the side-"}, {"sha": "d64521d0684decce9d8e77a78f70c3f4a6813c25", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 29, "deletions": 148, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fce5a9f29b556fbc6db108b645269f7729011859/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fce5a9f29b556fbc6db108b645269f7729011859/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=fce5a9f29b556fbc6db108b645269f7729011859", "patch": "@@ -49,7 +49,7 @@ Boston, MA 02111-1307, USA.  */\n #endif\n \n /* Processor costs (relative to an add) */\n-static const \n+static const\n struct processor_costs size_cost = {\t/* costs for tunning for size */\n   2,\t\t\t\t\t/* cost of an add instruction */\n   3,\t\t\t\t\t/* cost of a lea instruction */\n@@ -86,7 +86,7 @@ struct processor_costs size_cost = {\t/* costs for tunning for size */\n   0,\t\t\t\t\t/* number of parallel prefetches */\n };\n /* Processor costs (relative to an add) */\n-static const \n+static const\n struct processor_costs i386_cost = {\t/* 386 specific costs */\n   1,\t\t\t\t\t/* cost of an add instruction */\n   1,\t\t\t\t\t/* cost of a lea instruction */\n@@ -123,7 +123,7 @@ struct processor_costs i386_cost = {\t/* 386 specific costs */\n   0,\t\t\t\t\t/* number of parallel prefetches */\n };\n \n-static const \n+static const\n struct processor_costs i486_cost = {\t/* 486 specific costs */\n   1,\t\t\t\t\t/* cost of an add instruction */\n   1,\t\t\t\t\t/* cost of a lea instruction */\n@@ -160,7 +160,7 @@ struct processor_costs i486_cost = {\t/* 486 specific costs */\n   0,\t\t\t\t\t/* number of parallel prefetches */\n };\n \n-static const \n+static const\n struct processor_costs pentium_cost = {\n   1,\t\t\t\t\t/* cost of an add instruction */\n   1,\t\t\t\t\t/* cost of a lea instruction */\n@@ -197,7 +197,7 @@ struct processor_costs pentium_cost = {\n   0,\t\t\t\t\t/* number of parallel prefetches */\n };\n \n-static const \n+static const\n struct processor_costs pentiumpro_cost = {\n   1,\t\t\t\t\t/* cost of an add instruction */\n   1,\t\t\t\t\t/* cost of a lea instruction */\n@@ -234,7 +234,7 @@ struct processor_costs pentiumpro_cost = {\n   6,\t\t\t\t\t/* number of parallel prefetches */\n };\n \n-static const \n+static const\n struct processor_costs k6_cost = {\n   1,\t\t\t\t\t/* cost of an add instruction */\n   2,\t\t\t\t\t/* cost of a lea instruction */\n@@ -271,7 +271,7 @@ struct processor_costs k6_cost = {\n   1,\t\t\t\t\t/* number of parallel prefetches */\n };\n \n-static const \n+static const\n struct processor_costs athlon_cost = {\n   1,\t\t\t\t\t/* cost of an add instruction */\n   2,\t\t\t\t\t/* cost of a lea instruction */\n@@ -308,7 +308,7 @@ struct processor_costs athlon_cost = {\n   6,\t\t\t\t\t/* number of parallel prefetches */\n };\n \n-static const \n+static const\n struct processor_costs pentium4_cost = {\n   1,\t\t\t\t\t/* cost of an add instruction */\n   1,\t\t\t\t\t/* cost of a lea instruction */\n@@ -801,12 +801,6 @@ static enum x86_64_reg_class merge_classes PARAMS ((enum x86_64_reg_class,\n #undef TARGET_EXPAND_BUILTIN\n #define TARGET_EXPAND_BUILTIN ix86_expand_builtin\n \n-#if defined (OSF_OS) || defined (TARGET_OSF1ELF)\n-   static void ix86_osf_output_function_prologue PARAMS ((FILE *,\n-\t\t\t\t\t\t\t  HOST_WIDE_INT));\n-#  undef TARGET_ASM_FUNCTION_PROLOGUE\n-#  define TARGET_ASM_FUNCTION_PROLOGUE ix86_osf_output_function_prologue\n-#endif\n #undef TARGET_ASM_FUNCTION_EPILOGUE\n #define TARGET_ASM_FUNCTION_EPILOGUE ix86_output_function_epilogue\n \n@@ -841,7 +835,7 @@ static enum x86_64_reg_class merge_classes PARAMS ((enum x86_64_reg_class,\n #define TARGET_SCHED_INIT ix86_sched_init\n #undef TARGET_SCHED_REORDER\n #define TARGET_SCHED_REORDER ix86_sched_reorder\n-#undef TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE \n+#undef TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE\n #define TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE \\\n   ia32_use_dfa_pipeline_interface\n #undef TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD\n@@ -1040,7 +1034,7 @@ override_options ()\n \n   /* Arrange to set up i386_stack_locals for all functions.  */\n   init_machine_status = ix86_init_machine_status;\n-  \n+\n   /* Validate -mregparm= value.  */\n   if (ix86_regparm_string)\n     {\n@@ -1208,7 +1202,7 @@ override_options ()\n \t  else\n \t    ix86_fpmath = FPMATH_SSE | FPMATH_387;\n \t}\n-      else \n+      else\n \terror (\"bad value (%s) for -mfpmath= switch\", ix86_fpmath_string);\n     }\n \n@@ -1354,105 +1348,6 @@ ix86_handle_regparm_attribute (node, name, args, flags, no_add_attrs)\n   return NULL_TREE;\n }\n \n-#if defined (OSF_OS) || defined (TARGET_OSF1ELF)\n-\n-/* Generate the assembly code for function entry.  FILE is a stdio\n-   stream to output the code to.  SIZE is an int: how many units of\n-   temporary storage to allocate.\n-\n-   Refer to the array `regs_ever_live' to determine which registers to\n-   save; `regs_ever_live[I]' is nonzero if register number I is ever\n-   used in the function.  This function is responsible for knowing\n-   which registers should not be saved even if used.\n-\n-   We override it here to allow for the new profiling code to go before\n-   the prologue and the old mcount code to go after the prologue (and\n-   after %ebx has been set up for ELF shared library support).  */\n-\n-static void\n-ix86_osf_output_function_prologue (file, size)\n-     FILE *file;\n-     HOST_WIDE_INT size;\n-{\n-  const char *prefix = \"\";\n-  const char *const lprefix = LPREFIX;\n-  int labelno = current_function_profile_label_no;\n-\n-#ifdef OSF_OS\n-\n-  if (TARGET_UNDERSCORES)\n-    prefix = \"_\";\n-\n-  if (current_function_profile && OSF_PROFILE_BEFORE_PROLOGUE)\n-    {\n-      if (!flag_pic && !HALF_PIC_P ())\n-\t{\n-\t  fprintf (file, \"\\tmovl $%sP%d,%%edx\\n\", lprefix, labelno);\n-\t  fprintf (file, \"\\tcall *%s_mcount_ptr\\n\", prefix);\n-\t}\n-\n-      else if (HALF_PIC_P ())\n-\t{\n-\t  rtx symref;\n-\n-\t  HALF_PIC_EXTERNAL (\"_mcount_ptr\");\n-\t  symref = HALF_PIC_PTR (gen_rtx_SYMBOL_REF (Pmode,\n-\t\t\t\t\t\t     \"_mcount_ptr\"));\n-\n-\t  fprintf (file, \"\\tmovl $%sP%d,%%edx\\n\", lprefix, labelno);\n-\t  fprintf (file, \"\\tmovl %s%s,%%eax\\n\", prefix,\n-\t\t   XSTR (symref, 0));\n-\t  fprintf (file, \"\\tcall *(%%eax)\\n\");\n-\t}\n-\n-      else\n-\t{\n-\t  static int call_no = 0;\n-\n-\t  fprintf (file, \"\\tcall %sPc%d\\n\", lprefix, call_no);\n-\t  fprintf (file, \"%sPc%d:\\tpopl %%eax\\n\", lprefix, call_no);\n-\t  fprintf (file, \"\\taddl $_GLOBAL_OFFSET_TABLE_+[.-%sPc%d],%%eax\\n\",\n-\t\t   lprefix, call_no++);\n-\t  fprintf (file, \"\\tleal %sP%d@GOTOFF(%%eax),%%edx\\n\",\n-\t\t   lprefix, labelno);\n-\t  fprintf (file, \"\\tmovl %s_mcount_ptr@GOT(%%eax),%%eax\\n\",\n-\t\t   prefix);\n-\t  fprintf (file, \"\\tcall *(%%eax)\\n\");\n-\t}\n-    }\n-\n-#else  /* !OSF_OS */\n-\n-  if (current_function_profile && OSF_PROFILE_BEFORE_PROLOGUE)\n-    {\n-      if (!flag_pic)\n-\t{\n-\t  fprintf (file, \"\\tmovl $%sP%d,%%edx\\n\", lprefix, labelno);\n-\t  fprintf (file, \"\\tcall *%s_mcount_ptr\\n\", prefix);\n-\t}\n-\n-      else\n-\t{\n-\t  static int call_no = 0;\n-\n-\t  fprintf (file, \"\\tcall %sPc%d\\n\", lprefix, call_no);\n-\t  fprintf (file, \"%sPc%d:\\tpopl %%eax\\n\", lprefix, call_no);\n-\t  fprintf (file, \"\\taddl $_GLOBAL_OFFSET_TABLE_+[.-%sPc%d],%%eax\\n\",\n-\t\t   lprefix, call_no++);\n-\t  fprintf (file, \"\\tleal %sP%d@GOTOFF(%%eax),%%edx\\n\",\n-\t\t   lprefix, labelno);\n-\t  fprintf (file, \"\\tmovl %s_mcount_ptr@GOT(%%eax),%%eax\\n\",\n-\t\t   prefix);\n-\t  fprintf (file, \"\\tcall *(%%eax)\\n\");\n-\t}\n-    }\n-#endif /* !OSF_OS */\n-\n-  function_prologue (file, size);\n-}\n-\n-#endif  /* OSF_OS || TARGET_OSF1ELF */\n-\n /* Return 0 if the attributes for two types are incompatible, 1 if they\n    are compatible, and 2 if they are nearly compatible (which causes a\n    warning to be generated).  */\n@@ -2403,9 +2298,9 @@ ix86_build_va_list ()\n   record = (*lang_hooks.types.make_type) (RECORD_TYPE);\n   type_decl = build_decl (TYPE_DECL, get_identifier (\"__va_list_tag\"), record);\n \n-  f_gpr = build_decl (FIELD_DECL, get_identifier (\"gp_offset\"), \n+  f_gpr = build_decl (FIELD_DECL, get_identifier (\"gp_offset\"),\n \t\t      unsigned_type_node);\n-  f_fpr = build_decl (FIELD_DECL, get_identifier (\"fp_offset\"), \n+  f_fpr = build_decl (FIELD_DECL, get_identifier (\"fp_offset\"),\n \t\t      unsigned_type_node);\n   f_ovf = build_decl (FIELD_DECL, get_identifier (\"overflow_arg_area\"),\n \t\t      ptr_type_node);\n@@ -2431,7 +2326,7 @@ ix86_build_va_list ()\n }\n \n /* Perform any needed actions needed for a function that is receiving a\n-   variable number of arguments. \n+   variable number of arguments.\n \n    CUM is as above.\n \n@@ -2999,7 +2894,7 @@ pic_symbolic_operand (op, mode)\n       if (GET_CODE (XEXP (op, 0)) == UNSPEC)\n \treturn 1;\n     }\n-  else \n+  else\n     {\n       if (GET_CODE (op) == UNSPEC)\n \treturn 1;\n@@ -3037,7 +2932,7 @@ local_symbolic_operand (op, mode)\n     return 1;\n \n   /* There is, however, a not insubstantial body of code in the rest of\n-     the compiler that assumes it can just stick the results of \n+     the compiler that assumes it can just stick the results of\n      ASM_GENERATE_INTERNAL_LABEL in a symbol_ref and have done.  */\n   /* ??? This is a hack.  Should update the body of the compiler to\n      always create a DECL an invoke targetm.encode_section_info.  */\n@@ -3139,11 +3034,6 @@ call_insn_operand (op, mode)\n   if (GET_CODE (op) == SYMBOL_REF)\n     return 1;\n \n-  /* Half-pic doesn't allow anything but registers and constants.\n-     We've just taken care of the later.  */\n-  if (HALF_PIC_P ())\n-    return register_operand (op, Pmode);\n-\n   /* Otherwise we can allow any general_operand in the address.  */\n   return general_operand (op, Pmode);\n }\n@@ -4099,7 +3989,7 @@ ix86_select_alt_pic_regnum ()\n \n   return INVALID_REGNUM;\n }\n-  \n+\n /* Return 1 if we need to save REGNO.  */\n static int\n ix86_save_reg (regno, maybe_eh_return)\n@@ -4965,7 +4855,7 @@ constant_address_p (x)\n }\n \n /* Nonzero if the constant value X is a legitimate general operand\n-   when generating PIC code.  It is given that flag_pic is on and \n+   when generating PIC code.  It is given that flag_pic is on and\n    that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n \n bool\n@@ -5080,7 +4970,7 @@ legitimate_pic_address_disp_p (disp)\n \treturn false;\n       return local_dynamic_symbolic_operand (XVECEXP (disp, 0, 0), Pmode);\n     }\n-    \n+\n   return 0;\n }\n \n@@ -5291,15 +5181,6 @@ legitimate_address_p (mode, addr, strict)\n \t     that never results in lea, this seems to be easier and\n \t     correct fix for crash to disable this test.  */\n \t}\n-      else if (HALF_PIC_P ())\n-\t{\n-\t  if (! HALF_PIC_ADDRESS_P (disp)\n-\t      || (base != NULL_RTX || index != NULL_RTX))\n-\t    {\n-\t      reason = \"displacement is an invalid half-pic reference\";\n-\t      goto report_error;\n-\t    }\n-\t}\n       else if (!CONSTANT_ADDRESS_P (disp))\n \t{\n \t  reason = \"displacement is not constant\";\n@@ -5582,7 +5463,7 @@ get_thread_pointer ()\n \n   return tp;\n }\n-  \n+\n /* Try machine-dependent ways of modifying an illegitimate address\n    to be legitimate.  If we find one, return the new, valid address.\n    This macro is used in only one place: `memory_address' in explow.c.\n@@ -6528,7 +6409,7 @@ print_operand (file, x, code)\n \n \t  /* Like above, but reverse condition */\n \tcase 'c':\n-\t  /* Check to see if argument to %c is really a constant \n+\t  /* Check to see if argument to %c is really a constant\n \t     and not a condition code which needs to be reversed.  */\n \t  if (GET_RTX_CLASS (GET_CODE (x)) != '<')\n \t  {\n@@ -7565,7 +7446,7 @@ ix86_expand_vector_move (mode, operands)\n     }\n \n   emit_insn (gen_rtx_SET (VOIDmode, operands[0], operands[1]));\n-}  \n+}\n \n /* Attempt to expand a binary operator.  Make the expansion closer to the\n    actual machine, then just general_operand, which will allow 3 separate\n@@ -8430,7 +8311,7 @@ ix86_expand_branch (code, label)\n \n \tcode = ix86_prepare_fp_compare_args (code, &ix86_compare_op0,\n \t\t\t\t\t     &ix86_compare_op1);\n-\t\n+\n \tix86_fp_comparison_codes (code, &bypass_code, &first_code, &second_code);\n \n \t/* Check whether we will use the natural sequence with one jump.  If\n@@ -10626,7 +10507,7 @@ ix86_expand_call (retval, fnaddr, callarg1, callarg2, pop)\n   if (use)\n     CALL_INSN_FUNCTION_USAGE (call) = use;\n }\n-  \n+\n \f\n /* Clear stack slot assignments remembered from previous functions.\n    This is called from INIT_EXPANDERS once before RTL is emitted for each\n@@ -11214,7 +11095,7 @@ ix86_sched_reorder (dump, sched_verbose, ready, n_readyp, clock_var)\n   int n_ready = *n_readyp;\n   rtx *e_ready = ready + n_ready - 1;\n \n-  /* Make sure to go ahead and initialize key items in \n+  /* Make sure to go ahead and initialize key items in\n      ix86_sched_data if we are not going to bother trying to\n      reorder the ready queue.  */\n   if (n_ready < 2)\n@@ -12689,7 +12570,7 @@ ix86_expand_binop_builtin (icode, arglist, target)\n   return target;\n }\n \n-/* In type_for_mode we restrict the ability to create TImode types \n+/* In type_for_mode we restrict the ability to create TImode types\n    to hosts with 64-bit H_W_I.  So we've defined the SSE logicals\n    to have a V4SFmode signature.  Convert them in-place to TImode.  */\n \n@@ -12819,11 +12700,11 @@ ix86_expand_unop1_builtin (icode, arglist, target)\n \n   if (! (*insn_data[icode].operand[1].predicate) (op0, mode0))\n     op0 = copy_to_mode_reg (mode0, op0);\n-  \n+\n   op1 = op0;\n   if (! (*insn_data[icode].operand[2].predicate) (op1, mode0))\n     op1 = copy_to_mode_reg (mode0, op1);\n-  \n+\n   pat = GEN_FCN (icode) (target, op0, op1);\n   if (! pat)\n     return 0;\n@@ -13820,7 +13701,7 @@ x86_order_regs_for_local_alloc ()\n    if (!TARGET_SSE_MATH)\n      for (i = FIRST_STACK_REG; i <= LAST_STACK_REG; i++)\n        reg_alloc_order [pos++] = i;\n-   \n+\n    /* SSE registers.  */\n    for (i = FIRST_SSE_REG; i <= LAST_SSE_REG; i++)\n      reg_alloc_order [pos++] = i;"}, {"sha": "12e9bc24f287c8dd290de8afc7043fe4317235f5", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 25, "deletions": 39, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fce5a9f29b556fbc6db108b645269f7729011859/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fce5a9f29b556fbc6db108b645269f7729011859/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=fce5a9f29b556fbc6db108b645269f7729011859", "patch": "@@ -34,20 +34,6 @@ Boston, MA 02111-1307, USA.  */\n    ADDR_BEG, ADDR_END, PRINT_IREG, PRINT_SCALE, PRINT_B_I_S, and many\n    that start with ASM_ or end in ASM_OP.  */\n \n-/* Stubs for half-pic support if not OSF/1 reference platform.  */\n-\n-#ifndef HALF_PIC_P\n-#define HALF_PIC_P() 0\n-#define HALF_PIC_NUMBER_PTRS 0\n-#define HALF_PIC_NUMBER_REFS 0\n-#define HALF_PIC_ENCODE(DECL)\n-#define HALF_PIC_DECLARE(NAME)\n-#define HALF_PIC_INIT()\terror (\"half-pic init called on systems that don't support it\")\n-#define HALF_PIC_ADDRESS_P(X) 0\n-#define HALF_PIC_PTR(X) (X)\n-#define HALF_PIC_FINISH(STREAM)\n-#endif\n-\n /* Define the specific costs for a given cpu */\n \n struct processor_costs {\n@@ -140,7 +126,7 @@ extern int target_flags;\n \n /* Compile using ret insn that pops args.\n    This will not work unless you use prototypes at least\n-   for all functions that can take varying numbers of args.  */  \n+   for all functions that can take varying numbers of args.  */\n #define TARGET_RTD (target_flags & MASK_RTD)\n \n /* Align doubles to a two word boundary.  This breaks compatibility with\n@@ -712,7 +698,7 @@ extern int x86_prefetch_sse;\n    and all fundamental data types supported by the hardware\n    might need to be aligned. No data type wants to be aligned\n    rounder than this.\n-   \n+\n    Pentium+ preferrs DFmode values to be aligned to 64 bit boundary\n    and Pentium Pro XFmode values at 128 bit boundaries.  */\n \n@@ -826,7 +812,7 @@ extern int x86_prefetch_sse;\n /* 1 for registers that have pervasive standard uses\n    and are not available for the register allocator.\n    On the 80386, the stack pointer is such, as is the arg pointer.\n- \n+\n    The value is an mask - bit 1 is set for fixed registers\n    for 32bit target, while 2 is set for fixed registers for 64bit.\n    Proper value is computed in the CONDITIONAL_REGISTER_USAGE.\n@@ -844,15 +830,15 @@ extern int x86_prefetch_sse;\n      1,   1,   1,   1,   1,   1,   1,   1,\t\t\t\\\n /*xmm8,xmm9,xmm10,xmm11,xmm12,xmm13,xmm14,xmm15*/\t\t\\\n      1,   1,    1,    1,    1,    1,    1,    1}\n- \n+\n \n /* 1 for registers not available across function calls.\n    These must include the FIXED_REGISTERS and also any\n    registers that can be used without being saved.\n    The latter must include the registers where values are returned\n    and the register where structure-value addresses are passed.\n-   Aside from that, you can include as many other registers as you like. \n- \n+   Aside from that, you can include as many other registers as you like.\n+\n    The value is an mask - bit 1 is set for call used\n    for 32bit target, while 2 is set for call used for 64bit.\n    Proper value is computed in the CONDITIONAL_REGISTER_USAGE.\n@@ -938,7 +924,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n    This is ordinarily the length in words of a value of mode MODE\n    but can be less for certain modes in special long registers.\n \n-   Actually there are no two word move instructions for consecutive \n+   Actually there are no two word move instructions for consecutive\n    registers.  And only registers 0-3 may have mov byte instructions\n    applied to them.\n    */\n@@ -1051,7 +1037,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n #define FIRST_SSE_REG (FRAME_POINTER_REGNUM + 1)\n #define LAST_SSE_REG  (FIRST_SSE_REG + 7)\n- \n+\n #define FIRST_MMX_REG  (LAST_SSE_REG + 1)\n #define LAST_MMX_REG   (FIRST_MMX_REG + 7)\n \n@@ -1087,7 +1073,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n /* Register to hold the addressing base for position independent\n    code access to data items.  We don't use PIC pointer for 64bit\n    mode.  Define the regnum to dummy value to prevent gcc from\n-   pessimizing code dealing with EBX. \n+   pessimizing code dealing with EBX.\n \n    To avoid clobbering a call-saved register unnecessarily, we renumber\n    the pic register when possible.  The change is visible after the\n@@ -1300,7 +1286,7 @@ enum reg_class\n \n #define MMX_REGNO_P(N) ((N) >= FIRST_MMX_REG && (N) <= LAST_MMX_REG)\n #define MMX_REG_P(XOP) (REG_P (XOP) && MMX_REGNO_P (REGNO (XOP)))\n-  \n+\n #define STACK_REG_P(XOP)\t\t\\\n   (REG_P (XOP) &&\t\t       \t\\\n    REGNO (XOP) >= FIRST_STACK_REG &&\t\\\n@@ -1431,7 +1417,7 @@ enum reg_class\n   ix86_secondary_memory_needed ((CLASS1), (CLASS2), (MODE), 1)\n \n /* QImode spills from non-QI registers need a scratch.  This does not\n-   happen often -- the only example so far requires an uninitialized \n+   happen often -- the only example so far requires an uninitialized\n    pseudo.  */\n \n #define SECONDARY_OUTPUT_RELOAD_CLASS(CLASS, MODE, OUT)\t\t\t\\\n@@ -1478,7 +1464,7 @@ enum reg_class\n    || ((CLASS) == DIREG))\n \n /* A C statement that adds to CLOBBERS any hard regs the port wishes\n-   to automatically clobber for all asms. \n+   to automatically clobber for all asms.\n \n    We do this in the new i386 backend to maintain source compatibility\n    with the old cc0-based compiler.  */\n@@ -1516,7 +1502,7 @@ enum reg_class\n    On 386 pushw decrements by exactly 2 no matter what the position was.\n    On the 386 there is no pushb; we use pushw instead, and this\n    has the effect of rounding up to 2.\n- \n+\n    For 64bit ABI we round up to 8 bytes.\n  */\n \n@@ -1737,7 +1723,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n    the stack pointer does not matter.  The value is tested only in\n    functions that have frame pointers.\n    No definition is equivalent to always zero.  */\n-/* Note on the 386 it might be more efficient not to define this since \n+/* Note on the 386 it might be more efficient not to define this since\n    we have to restore it ourselves from the frame pointer, in order to\n    use pop */\n \n@@ -1956,7 +1942,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define REWRITE_ADDRESS(X) rewrite_address (X)\n \n /* Nonzero if the constant value X is a legitimate general operand\n-   when generating PIC code.  It is given that flag_pic is on and \n+   when generating PIC code.  It is given that flag_pic is on and\n    that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n \n #define LEGITIMATE_PIC_OPERAND_P(X) legitimate_pic_operand_p (X)\n@@ -2146,7 +2132,7 @@ enum ix86_builtins\n   IX86_BUILTIN_RSQRTSS,\n   IX86_BUILTIN_SQRTPS,\n   IX86_BUILTIN_SQRTSS,\n-  \n+\n   IX86_BUILTIN_UNPCKHPS,\n   IX86_BUILTIN_UNPCKLPS,\n \n@@ -2519,7 +2505,7 @@ do {\t\t\t\t\t\t\t\\\n    precise value of the constant, which is available for examination\n    in X, and the rtx code of the expression in which it is contained,\n    found in OUTER_CODE.\n-  \n+\n    CODE is the expression code--redundant, since it can be obtained\n    with `GET_CODE (X)'.  */\n \n@@ -2851,8 +2837,8 @@ do {\t\t\t\t\t\t\t\\\n /* Add any extra modes needed to represent the condition code.\n \n    For the i386, we need separate modes when floating-point\n-   equality comparisons are being done. \n-   \n+   equality comparisons are being done.\n+\n    Add CCNO to indicate comparisons against zero that requires\n    Overflow flag to be unset.  Sign bit test is used instead and\n    thus can be used to form \"a&b>0\" type of tests.\n@@ -2911,7 +2897,7 @@ do {\t\t\t\t\t\t\t\\\n    For float regs, the stack top is sometimes referred to as \"%st(0)\"\n    instead of just \"%st\".  PRINT_REG handles this with the \"y\" code.  */\n \n-#undef  HI_REGISTER_NAMES\t\t\t\t\t\t\n+#undef  HI_REGISTER_NAMES\n #define HI_REGISTER_NAMES\t\t\t\t\t\t\\\n {\"ax\",\"dx\",\"cx\",\"bx\",\"si\",\"di\",\"bp\",\"sp\",\t\t\t\t\\\n  \"st\",\"st(1)\",\"st(2)\",\"st(3)\",\"st(4)\",\"st(5)\",\"st(6)\",\"st(7)\",\"\",\t\\\n@@ -2961,7 +2947,7 @@ extern int const svr4_dbx_register_map[FIRST_PSEUDO_REGISTER];\n /* Before the prologue, RA is at 0(%esp).  */\n #define INCOMING_RETURN_ADDR_RTX \\\n   gen_rtx_MEM (VOIDmode, gen_rtx_REG (VOIDmode, STACK_POINTER_REGNUM))\n- \n+\n /* After the prologue, RA is at -4(AP) in the current frame.  */\n #define RETURN_ADDR_RTX(COUNT, FRAME)\t\t\t\t\t   \\\n   ((COUNT) == 0\t\t\t\t\t\t\t\t   \\\n@@ -3034,7 +3020,7 @@ extern int const svr4_dbx_register_map[FIRST_PSEUDO_REGISTER];\n #define JUMP_TABLES_IN_TEXT_SECTION \\\n   (!TARGET_64BIT && flag_pic && !HAVE_AS_GOTOFF_IN_DATA)\n \n-/* A C statement that outputs an address constant appropriate to \n+/* A C statement that outputs an address constant appropriate to\n    for DWARF debugging.  */\n \n #define ASM_OUTPUT_DWARF_ADDR_CONST(FILE, X) \\\n@@ -3291,7 +3277,7 @@ extern const char *ix86_asm_string;\n extern enum asm_dialect ix86_asm_dialect;\n \n extern int ix86_regparm;\n-extern const char *ix86_regparm_string;\t\n+extern const char *ix86_regparm_string;\n \n extern int ix86_preferred_stack_boundary;\n extern const char *ix86_preferred_stack_boundary_string;\n@@ -3319,12 +3305,12 @@ extern rtx ix86_compare_op1;\t/* operand 1 for comparisons */\n    redundant computation of new control word by the mode switching pass.\n    The fldcw instructions are still emitted redundantly, but this is probably\n    not going to be noticeable problem, as most CPUs do have fast path for\n-   the sequence.  \n+   the sequence.\n \n    The machinery is to emit simple truncation instructions and split them\n    before reload to instructions having USEs of two memory locations that\n    are filled by this code to old and new control word.\n- \n+\n    Post-reload pass may be later used to eliminate the redundant fildcw if\n    needed.  */\n "}]}