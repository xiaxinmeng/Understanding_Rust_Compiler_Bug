{"sha": "013680785116b52c4061c45c7b17cbb7d04d9d35", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDEzNjgwNzg1MTE2YjUyYzQwNjFjNDVjN2IxN2NiYjdkMDRkOWQzNQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-04-18T20:37:01Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-04-18T20:37:01Z"}, "message": "(prepare_call_address): New arg REG_PARM_SEEN.\n\nAll callers changed.\n(expand_call): Pre-load args if small reg classes and reg parms.\n\nFrom-SVN: r7073", "tree": {"sha": "7c19049354fff3f4f5649333c4c76cd88a5b05b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7c19049354fff3f4f5649333c4c76cd88a5b05b7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/013680785116b52c4061c45c7b17cbb7d04d9d35", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/013680785116b52c4061c45c7b17cbb7d04d9d35", "html_url": "https://github.com/Rust-GCC/gccrs/commit/013680785116b52c4061c45c7b17cbb7d04d9d35", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/013680785116b52c4061c45c7b17cbb7d04d9d35/comments", "author": null, "committer": null, "parents": [{"sha": "5f61007448569bb7dcca95979ac5fce82cb405d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f61007448569bb7dcca95979ac5fce82cb405d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f61007448569bb7dcca95979ac5fce82cb405d7"}], "stats": {"total": 28, "additions": 22, "deletions": 6}, "files": [{"sha": "1eed04b5b0186eff79952546c60601c9b873d619", "filename": "gcc/calls.c", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/013680785116b52c4061c45c7b17cbb7d04d9d35/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/013680785116b52c4061c45c7b17cbb7d04d9d35/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=013680785116b52c4061c45c7b17cbb7d04d9d35", "patch": "@@ -242,10 +242,11 @@ calls_function_1 (exp, which)\n    register should be added, if required.  */\n \n rtx\n-prepare_call_address (funexp, fndecl, use_insns)\n+prepare_call_address (funexp, fndecl, use_insns, reg_parm_seen)\n      rtx funexp;\n      tree fndecl;\n      rtx *use_insns;\n+     int reg_parm_seen;\n {\n   rtx static_chain_value = 0;\n \n@@ -258,7 +259,14 @@ prepare_call_address (funexp, fndecl, use_insns)\n   /* Make a valid memory address and copy constants thru pseudo-regs,\n      but not for a constant address if -fno-function-cse.  */\n   if (GET_CODE (funexp) != SYMBOL_REF)\n-    funexp = memory_address (FUNCTION_MODE, funexp);\n+    funexp =\n+#ifdef SMALL_REGISTER_CLASSES\n+    /* If we are using registers for parameters, force the\n+\t function address into a register now.  */\n+      reg_parm_seen ? force_not_mem (memory_address (FUNCTION_MODE, funexp))\n+\t\t    :\n+#endif\n+\t\t      memory_address (FUNCTION_MODE, funexp);\n   else\n     {\n #ifndef NO_FUNCTION_CSE\n@@ -1577,14 +1585,22 @@ expand_call (exp, target, ignore)\n \n \t/* If the value is expensive, and we are inside an appropriately \n \t   short loop, put the value into a pseudo and then put the pseudo\n-\t   into the hard reg.  */\n+\t   into the hard reg.\n+\n+\t   For small register classes, also do this if this call uses\n+\t   register parameters.  This is to avoid reload conflicts while\n+\t   loading the parameters registers.  */\n \n \tif ((! (GET_CODE (args[i].value) == REG\n \t\t|| (GET_CODE (args[i].value) == SUBREG\n \t\t    && GET_CODE (SUBREG_REG (args[i].value)) == REG)))\n \t    && args[i].mode != BLKmode\n \t    && rtx_cost (args[i].value, SET) > 2\n+#ifdef SMALL_REGISTER_CLASSES\n+\t    && (reg_parm_seen || preserve_subexpressions_p ()))\n+#else\n \t    && preserve_subexpressions_p ())\n+#endif\n \t  args[i].value = copy_to_mode_reg (args[i].mode, args[i].value);\n       }\n \n@@ -1766,7 +1782,7 @@ expand_call (exp, target, ignore)\n \t}\n     }\n \n-  funexp = prepare_call_address (funexp, fndecl, &use_insns);\n+  funexp = prepare_call_address (funexp, fndecl, &use_insns, reg_parm_seen);\n \n   /* Now do the register loads required for any wholly-register parms or any\n      parms which are passed both on the stack and in a register.  Their\n@@ -2310,7 +2326,7 @@ emit_library_call VPROTO((rtx orgfun, int no_queue, enum machine_mode outmode,\n   argnum = 0;\n #endif\n \n-  fun = prepare_call_address (fun, NULL_TREE, &use_insns);\n+  fun = prepare_call_address (fun, NULL_TREE, &use_insns, 0);\n \n   /* Now load any reg parms into their regs.  */\n \n@@ -2661,7 +2677,7 @@ emit_library_call_value VPROTO((rtx orgfun, rtx value, int no_queue,\n   argnum = 0;\n #endif\n \n-  fun = prepare_call_address (fun, NULL_TREE, &use_insns);\n+  fun = prepare_call_address (fun, NULL_TREE, &use_insns, 0);\n \n   /* Now load any reg parms into their regs.  */\n "}]}