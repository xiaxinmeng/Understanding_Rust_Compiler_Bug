{"sha": "c471e2dadadf0986c0e2d8753a219b6511740b74", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzQ3MWUyZGFkYWRmMDk4NmMwZTJkODc1M2EyMTliNjUxMTc0MGI3NA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-09-16T12:40:23Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-09-16T12:40:23Z"}, "message": "[multiple changes]\n\n2009-09-16  Robert Dewar  <dewar@adacore.com>\n\n\t* prj-nmsc.adb: Minor reformatting\n\n2009-09-16  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_ch4.adb (Expand_N_Conditional_Expression): If the type of the\n\texpression is a by-reference type (tagged or inherently limited)\n\tintroduce an access type to capture references to the values of each\n\tbranch of the conditional.\n\n2009-09-16  Emmanuel Briot  <briot@adacore.com>\n\n\t* prj-proc.adb, prj-part.adb, prj-tree.adb, prj-tree.ads\n\t(Project_Name_And_Node.Display_Name): new field\n\tThe display name of a project (as written in the .gpr file) is now\n\tcomputed when the project file itself is parsed, not when it is\n\tprocessed.\n\nFrom-SVN: r151750", "tree": {"sha": "f7affe5c60760ec7157beca08b57d5e75553236b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f7affe5c60760ec7157beca08b57d5e75553236b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c471e2dadadf0986c0e2d8753a219b6511740b74", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c471e2dadadf0986c0e2d8753a219b6511740b74", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c471e2dadadf0986c0e2d8753a219b6511740b74", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c471e2dadadf0986c0e2d8753a219b6511740b74/comments", "author": null, "committer": null, "parents": [{"sha": "75a648339844b6eeaef9553841766448e43b63fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75a648339844b6eeaef9553841766448e43b63fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75a648339844b6eeaef9553841766448e43b63fd"}], "stats": {"total": 210, "additions": 147, "deletions": 63}, "files": [{"sha": "0c381317cfcba51ecb0d9782ed7df61df27f49b9", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c471e2dadadf0986c0e2d8753a219b6511740b74/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c471e2dadadf0986c0e2d8753a219b6511740b74/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=c471e2dadadf0986c0e2d8753a219b6511740b74", "patch": "@@ -1,3 +1,22 @@\n+2009-09-16  Robert Dewar  <dewar@adacore.com>\n+\n+\t* prj-nmsc.adb: Minor reformatting\n+\n+2009-09-16  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_ch4.adb (Expand_N_Conditional_Expression): If the type of the\n+\texpression is a by-reference type (tagged or inherently limited)\n+\tintroduce an access type to capture references to the values of each\n+\tbranch of the conditional.\n+\n+2009-09-16  Emmanuel Briot  <briot@adacore.com>\n+\n+\t* prj-proc.adb, prj-part.adb, prj-tree.adb, prj-tree.ads\n+\t(Project_Name_And_Node.Display_Name): new field\n+\tThe display name of a project (as written in the .gpr file) is now\n+\tcomputed when the project file itself is parsed, not when it is\n+\tprocessed.\n+\n 2009-09-16  Thomas Quinot  <quinot@adacore.com>\n \n \t* freeze.adb, exp_intr.adb (Expand_Intrinsic_Call): Leave calls to"}, {"sha": "49d23162eb05205a0e84c925c39bfbdeb0b43c4c", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 94, "deletions": 34, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c471e2dadadf0986c0e2d8753a219b6511740b74/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c471e2dadadf0986c0e2d8753a219b6511740b74/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=c471e2dadadf0986c0e2d8753a219b6511740b74", "patch": "@@ -4017,8 +4017,12 @@ package body Exp_Ch4 is\n       Thenx  : constant Node_Id    := Next (Cond);\n       Elsex  : constant Node_Id    := Next (Thenx);\n       Typ    : constant Entity_Id  := Etype (N);\n+\n       Cnn    : Entity_Id;\n+      Decl   : Node_Id;\n       New_If : Node_Id;\n+      New_N  : Node_Id;\n+      P_Decl : Node_Id;\n \n    begin\n       --  If either then or else actions are present, then given:\n@@ -4038,13 +4042,12 @@ package body Exp_Ch4 is\n \n       --  and replace the conditional expression by a reference to Cnn\n \n-      --  ??? Note: this expansion is wrong for limited types, since it does\n-      --  a copy of a limited value. Similarly it's wrong for unconstrained or\n-      --  class-wide types since in neither case can we have an uninitialized\n-      --  object declaration The proper fix would be to do the following\n-      --  expansion:\n+      --  If the type is limited or unconstrained, the above expansion is\n+      --  not legal, because it involves either an uninitialized object\n+      --  or an illegal assignment. Instead, we generate:\n \n-      --      Cnn : access typ;\n+      --      type Ptr is access all Typ;\n+      --      Cnn : Ptr;\n       --      if cond then\n       --         <<then actions>>\n       --         Cnn := then-expr'Unrestricted_Access;\n@@ -4053,59 +4056,116 @@ package body Exp_Ch4 is\n       --         Cnn := else-expr'Unrestricted_Access;\n       --      end if;\n \n-      --  and replace the conditional expresion by a reference to Cnn.all ???\n+      --  and replace the conditional expresion by a reference to Cnn.all.\n \n-      if Present (Then_Actions (N)) or else Present (Else_Actions (N)) then\n+      if Is_By_Reference_Type (Typ) then\n          Cnn := Make_Temporary (Loc, 'C', N);\n \n+         P_Decl :=\n+           Make_Full_Type_Declaration (Loc,\n+             Defining_Identifier =>\n+               Make_Defining_Identifier (Loc, New_Internal_Name ('A')),\n+             Type_Definition =>\n+               Make_Access_To_Object_Definition (Loc,\n+                 All_Present => True,\n+                 Subtype_Indication =>\n+                   New_Reference_To (Typ, Loc)));\n+\n+         Insert_Action (N, P_Decl);\n+\n+         Decl :=\n+            Make_Object_Declaration (Loc,\n+              Defining_Identifier => Cnn,\n+              Object_Definition   =>\n+                   New_Occurrence_Of (Defining_Identifier (P_Decl), Loc));\n+\n          New_If :=\n            Make_Implicit_If_Statement (N,\n              Condition => Relocate_Node (Cond),\n \n              Then_Statements => New_List (\n                Make_Assignment_Statement (Sloc (Thenx),\n                  Name => New_Occurrence_Of (Cnn, Sloc (Thenx)),\n-                 Expression => Relocate_Node (Thenx))),\n+                 Expression =>\n+                   Make_Attribute_Reference (Loc,\n+                     Attribute_Name => Name_Unrestricted_Access,\n+                     Prefix =>  Relocate_Node (Thenx)))),\n \n              Else_Statements => New_List (\n                Make_Assignment_Statement (Sloc (Elsex),\n                  Name => New_Occurrence_Of (Cnn, Sloc (Elsex)),\n-                 Expression => Relocate_Node (Elsex))));\n+                 Expression =>\n+                   Make_Attribute_Reference (Loc,\n+                     Attribute_Name => Name_Unrestricted_Access,\n+                     Prefix => Relocate_Node (Elsex)))));\n \n-         --  Move the SLOC of the parent If statement to the newly created one\n-         --  and change it to the SLOC of the expression which, after\n-         --  expansion, will correspond to what is being evaluated.\n+         New_N :=\n+           Make_Explicit_Dereference (Loc,\n+             Prefix => New_Occurrence_Of (Cnn, Loc));\n \n-         if Present (Parent (N))\n-           and then Nkind (Parent (N)) = N_If_Statement\n-         then\n-            Set_Sloc (New_If, Sloc (Parent (N)));\n-            Set_Sloc (Parent (N), Loc);\n-         end if;\n+      --  For other types, we only need to expand if there are other actions\n+      --  associated with either branch.\n+\n+      elsif Present (Then_Actions (N)) or else Present (Else_Actions (N)) then\n+         Cnn := Make_Temporary (Loc, 'C', N);\n+\n+         Decl :=\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => Cnn,\n+             Object_Definition   => New_Occurrence_Of (Typ, Loc));\n+\n+         New_If :=\n+           Make_Implicit_If_Statement (N,\n+             Condition => Relocate_Node (Cond),\n+\n+             Then_Statements => New_List (\n+               Make_Assignment_Statement (Sloc (Thenx),\n+                 Name => New_Occurrence_Of (Cnn, Sloc (Thenx)),\n+                 Expression => Relocate_Node (Thenx))),\n+\n+             Else_Statements => New_List (\n+               Make_Assignment_Statement (Sloc (Elsex),\n+                 Name => New_Occurrence_Of (Cnn, Sloc (Elsex)),\n+                 Expression => Relocate_Node (Elsex))));\n \n          Set_Assignment_OK (Name (First (Then_Statements (New_If))));\n          Set_Assignment_OK (Name (First (Else_Statements (New_If))));\n \n-         if Present (Then_Actions (N)) then\n-            Insert_List_Before\n-              (First (Then_Statements (New_If)), Then_Actions (N));\n-         end if;\n+         New_N := New_Occurrence_Of (Cnn, Loc);\n \n-         if Present (Else_Actions (N)) then\n-            Insert_List_Before\n-              (First (Else_Statements (New_If)), Else_Actions (N));\n-         end if;\n+      else\n \n-         Rewrite (N, New_Occurrence_Of (Cnn, Loc));\n+         --  No expansion needed, gigi handles it like a C conditional\n+         --  expression.\n \n-         Insert_Action (N,\n-           Make_Object_Declaration (Loc,\n-             Defining_Identifier => Cnn,\n-             Object_Definition   => New_Occurrence_Of (Typ, Loc)));\n+         return;\n+      end if;\n \n-         Insert_Action (N, New_If);\n-         Analyze_And_Resolve (N, Typ);\n+      --  Move the SLOC of the parent If statement to the newly created one\n+      --  and change it to the SLOC of the expression which, after\n+      --  expansion, will correspond to what is being evaluated.\n+\n+      if Present (Parent (N))\n+        and then Nkind (Parent (N)) = N_If_Statement\n+      then\n+         Set_Sloc (New_If, Sloc (Parent (N)));\n+         Set_Sloc (Parent (N), Loc);\n       end if;\n+\n+      if Present (Then_Actions (N)) then\n+         Insert_List_Before\n+           (First (Then_Statements (New_If)), Then_Actions (N));\n+      end if;\n+\n+      if Present (Else_Actions (N)) then\n+         Insert_List_Before\n+           (First (Else_Statements (New_If)), Else_Actions (N));\n+      end if;\n+\n+      Insert_Action (N, Decl);\n+      Insert_Action (N, New_If);\n+      Rewrite (N, New_N);\n+      Analyze_And_Resolve (N, Typ);\n    end Expand_N_Conditional_Expression;\n \n    -----------------------------------"}, {"sha": "cec5e6b0a591ffe90acd21650255326bc96d096a", "filename": "gcc/ada/prj-nmsc.adb", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c471e2dadadf0986c0e2d8753a219b6511740b74/gcc%2Fada%2Fprj-nmsc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c471e2dadadf0986c0e2d8753a219b6511740b74/gcc%2Fada%2Fprj-nmsc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.adb?ref=c471e2dadadf0986c0e2d8753a219b6511740b74", "patch": "@@ -5066,8 +5066,7 @@ package body Prj.Nmsc is\n                      if not Removed then\n \n                         --  As it is an existing directory, we add it to the\n-                        --  list of directories, if it is not already in the\n-                        --  list.\n+                        --  list of directories, if not already in the list.\n \n                         if List = Nil_String then\n                            String_Element_Table.Increment_Last\n@@ -6784,6 +6783,15 @@ package body Prj.Nmsc is\n                Unit                => Unit,\n                Locally_Removed     => Locally_Removed,\n                Path                => (Canonical_Path, Path));\n+\n+            --  If it is a source specified in a list, update the entry in\n+            --  the Source_Names table.\n+\n+            if Name_Loc.Found and then Name_Loc.Source = No_Source then\n+               Name_Loc.Source := Source;\n+               Source_Names_Htable.Set\n+                 (Project.Source_Names, File_Name, Name_Loc);\n+            end if;\n          end if;\n       end if;\n    end Check_File;"}, {"sha": "fc0438ba4f0d9f222632c48cd0e0ff0b4066988f", "filename": "gcc/ada/prj-part.adb", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c471e2dadadf0986c0e2d8753a219b6511740b74/gcc%2Fada%2Fprj-part.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c471e2dadadf0986c0e2d8753a219b6511740b74/gcc%2Fada%2Fprj-part.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-part.adb?ref=c471e2dadadf0986c0e2d8753a219b6511740b74", "patch": "@@ -941,6 +941,7 @@ package body Prj.Part is\n       Name_From_Path  : constant Name_Id :=\n         Project_Name_From (Path_Name, Is_Config_File => Is_Config_File);\n       Name_Of_Project : Name_Id := No_Name;\n+      Display_Name_Of_Project : Name_Id := No_Name;\n \n       Duplicated : Boolean := False;\n \n@@ -1298,9 +1299,6 @@ package body Prj.Part is\n \n          --  To get expected name of the project file, replace dots by dashes\n \n-         Name_Len := Buffer_Last;\n-         Name_Buffer (1 .. Name_Len) := Buffer (1 .. Buffer_Last);\n-\n          for Index in 1 .. Name_Len loop\n             if Name_Buffer (Index) = '.' then\n                Name_Buffer (Index) := '-';\n@@ -1337,6 +1335,19 @@ package body Prj.Part is\n             end if;\n          end;\n \n+         --  Read the original casing of the project name\n+\n+         declare\n+            Loc : Source_Ptr := Location_Of (Project, In_Tree);\n+         begin\n+            for J in 1 .. Name_Len loop\n+               Name_Buffer (J) := Sinput.Source (Loc);\n+               Loc := Loc + 1;\n+            end loop;\n+\n+            Display_Name_Of_Project := Name_Find;\n+         end;\n+\n          declare\n             From_Ext : Extension_Origin := None;\n \n@@ -1700,6 +1711,7 @@ package body Prj.Part is\n            (T => In_Tree.Projects_HT,\n             K => Name_Of_Project,\n             E => (Name           => Name_Of_Project,\n+                  Display_Name   => Display_Name_Of_Project,\n                   Node           => Project,\n                   Canonical_Path => Canonical_Path_Name,\n                   Extended       => Extended,"}, {"sha": "9893cf6129b38bf45cf8ebb1d5a4a1831d6370da", "filename": "gcc/ada/prj-proc.adb", "status": "modified", "additions": 4, "deletions": 24, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c471e2dadadf0986c0e2d8753a219b6511740b74/gcc%2Fada%2Fprj-proc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c471e2dadadf0986c0e2d8753a219b6511740b74/gcc%2Fada%2Fprj-proc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-proc.adb?ref=c471e2dadadf0986c0e2d8753a219b6511740b74", "patch": "@@ -31,7 +31,6 @@ with Prj.Attr; use Prj.Attr;\n with Prj.Err;  use Prj.Err;\n with Prj.Ext;  use Prj.Ext;\n with Prj.Nmsc; use Prj.Nmsc;\n-with Sinput;   use Sinput;\n with Snames;\n \n with GNAT.Case_Util; use GNAT.Case_Util;\n@@ -2425,13 +2424,12 @@ package body Prj.Proc is\n          declare\n             Imported         : Project_List;\n             Declaration_Node : Project_Node_Id  := Empty_Node;\n-            Tref             : Source_Buffer_Ptr;\n             Name             : constant Name_Id :=\n                                  Name_Of\n                                    (From_Project_Node, From_Project_Node_Tree);\n-            Location         : Source_Ptr :=\n-                                 Location_Of\n-                                   (From_Project_Node, From_Project_Node_Tree);\n+            Name_Node     : constant Tree_Private_Part.Project_Name_And_Node :=\n+              Tree_Private_Part.Projects_Htable.Get\n+                (From_Project_Node_Tree.Projects_HT, Name);\n \n          begin\n             Project := Processed_Projects.Get (Name);\n@@ -2458,6 +2456,7 @@ package body Prj.Proc is\n             Processed_Projects.Set (Name, Project);\n \n             Project.Name := Name;\n+            Project.Display_Name := Name_Node.Display_Name;\n             Project.Qualifier :=\n               Project_Qualifier_Of (From_Project_Node, From_Project_Node_Tree);\n \n@@ -2471,26 +2470,7 @@ package body Prj.Proc is\n                          Virtual_Prefix\n             then\n                Project.Virtual := True;\n-               Project.Display_Name := Name;\n-\n-            --  If there is no file, for example when the project node tree is\n-            --  built in memory by GPS, the Display_Name cannot be found in\n-            --  the source, so its value is the same as Name.\n-\n-            elsif Location = No_Location then\n-               Project.Display_Name := Name;\n-\n-            --  Get the spelling of the project name from the project file\n-\n-            else\n-               Tref := Source_Text (Get_Source_File_Index (Location));\n-\n-               for J in 1 .. Name_Len loop\n-                  Name_Buffer (J) := Tref (Location);\n-                  Location := Location + 1;\n-               end loop;\n \n-               Project.Display_Name := Name_Find;\n             end if;\n \n             Project.Path.Display_Name :="}, {"sha": "08e4977c05633ad1ab03ec47eef1d9967ac5a617", "filename": "gcc/ada/prj-tree.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c471e2dadadf0986c0e2d8753a219b6511740b74/gcc%2Fada%2Fprj-tree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c471e2dadadf0986c0e2d8753a219b6511740b74/gcc%2Fada%2Fprj-tree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-tree.adb?ref=c471e2dadadf0986c0e2d8753a219b6511740b74", "patch": "@@ -2854,6 +2854,7 @@ package body Prj.Tree is\n             Name,\n             Prj.Tree.Tree_Private_Part.Project_Name_And_Node'\n               (Name           => Name,\n+               Display_Name   => Name,\n                Canonical_Path => No_Path,\n                Node           => Project,\n                Extended       => False,"}, {"sha": "e587d3705aabe88dd47e52bf1b3ddfb8c75d3f9a", "filename": "gcc/ada/prj-tree.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c471e2dadadf0986c0e2d8753a219b6511740b74/gcc%2Fada%2Fprj-tree.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c471e2dadadf0986c0e2d8753a219b6511740b74/gcc%2Fada%2Fprj-tree.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-tree.ads?ref=c471e2dadadf0986c0e2d8753a219b6511740b74", "patch": "@@ -1332,6 +1332,9 @@ package Prj.Tree is\n          Name : Name_Id;\n          --  Name of the project\n \n+         Display_Name : Name_Id;\n+         --  The name of the project as it appears in the .gpr file\n+\n          Node : Project_Node_Id;\n          --  Node of the project in table Project_Nodes\n \n@@ -1348,6 +1351,7 @@ package Prj.Tree is\n \n       No_Project_Name_And_Node : constant Project_Name_And_Node :=\n         (Name           => No_Name,\n+         Display_Name   => No_Name,\n          Node           => Empty_Node,\n          Canonical_Path => No_Path,\n          Extended       => True,"}]}