{"sha": "13de60fb8e26a874dd58089286a0ea99a90972c8", "node_id": "C_kwDOANBUbNoAKDEzZGU2MGZiOGUyNmE4NzRkZDU4MDg5Mjg2YTBlYTk5YTkwOTcyYzg", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2022-09-24T14:23:43Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2022-09-24T14:23:43Z"}, "message": "Merge remote-tracking branch 'mainline/master' into ibuclaw/targetrustm", "tree": {"sha": "9460ec898d5cedf1ab0ac06073b358cc3b928648", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9460ec898d5cedf1ab0ac06073b358cc3b928648"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/13de60fb8e26a874dd58089286a0ea99a90972c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13de60fb8e26a874dd58089286a0ea99a90972c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13de60fb8e26a874dd58089286a0ea99a90972c8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13de60fb8e26a874dd58089286a0ea99a90972c8/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6da3cab7b0acf5dc363c85069bef716923ddf90c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6da3cab7b0acf5dc363c85069bef716923ddf90c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6da3cab7b0acf5dc363c85069bef716923ddf90c"}, {"sha": "ad2aab5c816a6fd56b46210c0a4a4c6243da1de9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad2aab5c816a6fd56b46210c0a4a4c6243da1de9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad2aab5c816a6fd56b46210c0a4a4c6243da1de9"}], "stats": {"total": 307558, "additions": 168083, "deletions": 139475}, "files": [{"sha": "652b06901128377e3d8effb4815be116c3b04454", "filename": "ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -1,3 +1,30 @@\n+2022-09-23  Paul-Antoine Arras  <pa@codesourcery.com>\n+\n+\t* MAINTAINERS (Write After Approval): Add myself.\n+\n+2022-09-15  Torbj\u00f6rn SVENSSON  <torbjorn.svensson@foss.st.com>\n+\n+\t* MAINTAINERS (Write After Approval): Add myself.\n+\n+2022-09-07  Jeff Law  <jeffreyalaw@gmail.com>\n+\n+\t* MAINTAINERS: Update my email address.\n+\n+2022-09-07  Tom de Vries  <tdevries@suse.de>\n+\n+\t* configure.ac: Set extra_host_libiberty_configure_flags and\n+\textra_host_zlib_configure_flags in separate case statements.\n+\t* configure: Regenerate.\n+\n+2022-09-06  Xianmiao Qu  <cooper.qu@linux.alibaba.com>\n+\n+\t* MAINTAINERS: Update c-sky port maintainers' emails.\n+\n+2022-08-31  Martin Liska  <mliska@suse.cz>\n+\n+\t* configure: Regenerate.\n+\t* configure.ac: Delete hpux9 and hpux10.\n+\n 2022-08-18  Sergei Trofimovich  <siarheit@google.com>\n \n \t* Makefile.def: Drop libelf module and gcc-configure dependency"}, {"sha": "f63de2266093615510148ad741a031974d6f30be", "filename": "MAINTAINERS", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/MAINTAINERS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/MAINTAINERS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/MAINTAINERS?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -30,7 +30,7 @@ Richard Biener\t\t\t\t\t<rguenther@suse.de>\n Richard Earnshaw\t\t\t\t<richard.earnshaw@arm.com>\n Jakub Jelinek\t\t\t\t\t<jakub@redhat.com>\n Richard Kenner\t\t\t\t\t<kenner@nyu.edu>\n-Jeff Law\t\t\t\t\t<jlaw@tachyum.com>\n+Jeff Law\t\t\t\t\t<jeffreyalaw@gmail.com>\n Michael Meissner\t\t\t\t<gnu@the-meissners.org>\n Jason Merrill\t\t\t\t\t<jason@redhat.com>\n David S. Miller\t\t\t\t\t<davem@redhat.com>\n@@ -67,8 +67,8 @@ bfin port\t\tJie Zhang\t\t<jzhang918@gmail.com>\n bpf port\t\tJose E. Marchesi\t<jose.marchesi@oracle.com>\n c6x port\t\tBernd Schmidt\t\t<bernds_cb1@t-online.de>\n cris port\t\tHans-Peter Nilsson\t<hp@axis.com>\n-c-sky port\t\tXianmiao Qu\t\t<xianmiao_qu@c-sky.com>\n-c-sky port\t\tYunhai Shang\t\t<yunhai_shang@c-sky.com>\n+c-sky port\t\tXianmiao Qu\t\t<cooper.qu@linux.alibaba.com>\n+c-sky port\t\tYunhai Shang\t\t<yunhai@linux.alibaba.com>\n epiphany port\t\tJoern Rennecke\t\t<gnu@amylaar.uk>\n fr30 port\t\tNick Clifton\t\t<nickc@redhat.com>\n frv port\t\tNick Clifton\t\t<nickc@redhat.com>\n@@ -316,6 +316,7 @@ from other maintainers or reviewers.\n \n Mark G. Adams\t\t\t\t\t<mark.g.adams@sympatico.ca>\n Pedro Alves\t\t\t\t\t<palves@redhat.com>\n+Paul-Antoine Arras\t\t\t\t<pa@codesourcery.com>\n Raksit Ashok\t\t\t\t\t<raksit@google.com>\n Matt Austern\t\t\t\t\t<austern@google.com>\n David Ayers\t\t\t\t\t<ayers@fsfe.org>\n@@ -641,6 +642,7 @@ YunQiang Su\t\t\t\t\t<yunqiang.su@cipunited.com>\n Robert Suchanek\t\t\t\t\t<rsuchy84@gmail.com>\n Andrew Sutton\t\t\t\t\t<andrew.n.sutton@gmail.com>\n Gabriele Svelto\t\t\t\t\t<gabriele.svelto@st.com>\n+Torbj\u00f6rn Svensson\t\t\t\t<torbjorn.svensson@foss.st.com>\n Toma Tabacu\t\t\t\t\t<toma.tabacu@gmail.com>\n Omar Tahir\t\t\t\t\t<omar.tahir@arm.com>\n Sriraman Tallam\t\t\t\t\t<tmsriram@google.com>"}, {"sha": "b7fd4e7a0b4b52a66ccb5c3416415d6422ec581b", "filename": "config/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/config%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/config%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/config%2FChangeLog?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -1,3 +1,7 @@\n+2022-08-31  Martin Liska  <mliska@suse.cz>\n+\n+\t* mh-pa-hpux10: Removed.\n+\n 2022-08-01  Roger Sayle  <roger@nextmovesoftware.com>\n \t    Arnaud Charlet  <charlet@adacore.com>\n "}, {"sha": "99a2278f2813c6e61e2421d56dc15fc32bc53db2", "filename": "config/mh-pa-hpux10", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6da3cab7b0acf5dc363c85069bef716923ddf90c/config%2Fmh-pa-hpux10", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6da3cab7b0acf5dc363c85069bef716923ddf90c/config%2Fmh-pa-hpux10", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/config%2Fmh-pa-hpux10?ref=6da3cab7b0acf5dc363c85069bef716923ddf90c", "patch": "@@ -1,4 +0,0 @@\n-# The ada virtual array implementation requires that indexing be disabled on\n-# hosts such as hpux that use a segmented memory architecture.  Both the c\n-# and ada files need to be compiled with this option for correct operation.\n-ADA_CFLAGS = -mdisable-indexing -D_X_HPUX10"}, {"sha": "e7604dc6ff08cdf96aefd61a42bdd27e064451e8", "filename": "configure", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/configure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/configure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -3544,11 +3544,6 @@ case \"${target}\" in\n   hppa*64*-*-hpux*)\n     noconfigdirs=\"$noconfigdirs target-libffi\"\n     ;;\n-  hppa*-hp-hpux11*)\n-    ;;\n-  hppa*-*-hpux*)\n-    noconfigdirs=\"$noconfigdirs target-libffi\"\n-    ;;\n   ia64*-*-*vms*)\n     noconfigdirs=\"$noconfigdirs target-libffi\"\n     ;;\n@@ -3855,14 +3850,9 @@ case \"${target}\" in\n   h8500-*-*)\n     noconfigdirs=\"$noconfigdirs target-libgloss\"\n     ;;\n-  hppa1.1-*-osf* | hppa1.1-*-bsd* )\n-    ;;\n   hppa*64*-*-hpux*)\n     noconfigdirs=\"$noconfigdirs gdb\"\n     ;;\n-  hppa*-*-hpux11*)\n-    noconfigdirs=\"$noconfigdirs gdb ld\"\n-    ;;\n   hppa*64*-*-linux*)\n     ;;\n   hppa*-*-linux*)\n@@ -4076,9 +4066,6 @@ fi\n   alpha*-linux*)\n     host_makefile_frag=\"config/mh-alpha-linux\"\n     ;;\n-  hppa*-hp-hpux10*)\n-    host_makefile_frag=\"config/mh-pa-hpux10\"\n-    ;;\n   hppa*-hp-hpux*)\n     host_makefile_frag=\"config/mh-pa\"\n     ;;\n@@ -9201,13 +9188,18 @@ fi\n \n # Sometimes we have special requirements for the host libiberty.\n extra_host_libiberty_configure_flags=\n-extra_host_zlib_configure_flags=\n case \" $configdirs \" in\n   *\" lto-plugin \"* | *\" libcc1 \"* | *\" gdbserver \"*)\n     # When these are to be built as shared libraries, the same applies to\n     # libiberty.\n     extra_host_libiberty_configure_flags=--enable-shared\n     ;;\n+esac\n+\n+\n+# Sometimes we have special requirements for the host zlib.\n+extra_host_zlib_configure_flags=\n+case \" $configdirs \" in\n   *\" bfd \"*)\n     # When bfd is to be built as a shared library, the same applies to\n     # zlib.\n@@ -9218,7 +9210,6 @@ case \" $configdirs \" in\n esac\n \n \n-\n # Produce a warning message for the subdirs we can't configure.\n # This isn't especially interesting in the Cygnus tree, but in the individual\n # FSF releases, it's important to let people know when their machine isn't\n@@ -18324,7 +18315,6 @@ fi\n compare_exclusions=\"gcc/cc*-checksum\\$(objext) | gcc/ada/*tools/*\"\n case \"$target\" in\n   hppa*64*-*-hpux*) ;;\n-  hppa*-*-hpux*) compare_exclusions=\"$compare_exclusions | */libgcc/lib2funcs* | gcc/function-tests.o\" ;;\n   powerpc*-ibm-aix*) compare_exclusions=\"$compare_exclusions | *libgomp*\\$(objext)\" ;;\n esac\n "}, {"sha": "3cfd9b41fcab1f370727356725c8e9a8503ba87a", "filename": "configure.ac", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/configure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/configure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure.ac?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -804,11 +804,6 @@ case \"${target}\" in\n   hppa*64*-*-hpux*)\n     noconfigdirs=\"$noconfigdirs target-libffi\"\n     ;;\n-  hppa*-hp-hpux11*)\n-    ;;\n-  hppa*-*-hpux*)\n-    noconfigdirs=\"$noconfigdirs target-libffi\"\n-    ;;\n   ia64*-*-*vms*)\n     noconfigdirs=\"$noconfigdirs target-libffi\"\n     ;;\n@@ -1112,14 +1107,9 @@ case \"${target}\" in\n   h8500-*-*)\n     noconfigdirs=\"$noconfigdirs target-libgloss\"\n     ;;\n-  hppa1.1-*-osf* | hppa1.1-*-bsd* )\n-    ;;\n   hppa*64*-*-hpux*)\n     noconfigdirs=\"$noconfigdirs gdb\"\n     ;;\n-  hppa*-*-hpux11*)\n-    noconfigdirs=\"$noconfigdirs gdb ld\"\n-    ;;\n   hppa*64*-*-linux*)\n     ;;\n   hppa*-*-linux*)\n@@ -1314,9 +1304,6 @@ case \"${host}\" in\n   alpha*-linux*)\n     host_makefile_frag=\"config/mh-alpha-linux\"\n     ;;\n-  hppa*-hp-hpux10*)\n-    host_makefile_frag=\"config/mh-pa-hpux10\"\n-    ;;\n   hppa*-hp-hpux*)\n     host_makefile_frag=\"config/mh-pa\"\n     ;;\n@@ -2452,13 +2439,18 @@ fi\n \n # Sometimes we have special requirements for the host libiberty.\n extra_host_libiberty_configure_flags=\n-extra_host_zlib_configure_flags=\n case \" $configdirs \" in\n   *\" lto-plugin \"* | *\" libcc1 \"* | *\" gdbserver \"*)\n     # When these are to be built as shared libraries, the same applies to\n     # libiberty.\n     extra_host_libiberty_configure_flags=--enable-shared\n     ;;\n+esac\n+AC_SUBST(extra_host_libiberty_configure_flags)\n+\n+# Sometimes we have special requirements for the host zlib.\n+extra_host_zlib_configure_flags=\n+case \" $configdirs \" in\n   *\" bfd \"*)\n     # When bfd is to be built as a shared library, the same applies to\n     # zlib.\n@@ -2467,7 +2459,6 @@ case \" $configdirs \" in\n     fi\n     ;;\n esac\n-AC_SUBST(extra_host_libiberty_configure_flags)\n AC_SUBST(extra_host_zlib_configure_flags)\n \n # Produce a warning message for the subdirs we can't configure.\n@@ -3780,7 +3771,6 @@ AC_SUBST(stage2_werror_flag)\n compare_exclusions=\"gcc/cc*-checksum\\$(objext) | gcc/ada/*tools/*\"\n case \"$target\" in\n   hppa*64*-*-hpux*) ;;\n-  hppa*-*-hpux*) compare_exclusions=\"$compare_exclusions | */libgcc/lib2funcs* | gcc/function-tests.o\" ;;\n   powerpc*-ibm-aix*) compare_exclusions=\"$compare_exclusions | *libgomp*\\$(objext)\" ;;\n esac\n AC_SUBST(compare_exclusions)"}, {"sha": "c37553007672c4ab8b3b8a31e6a272bc338130a8", "filename": "contrib/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/contrib%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/contrib%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2FChangeLog?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -1,3 +1,30 @@\n+2022-09-20  Martin Liska  <mliska@suse.cz>\n+\n+\t* filter-clang-warnings.py: Skip egrep: warning: egrep is\n+\t  obsolescent; using grep -E.\n+\n+2022-08-31  Martin Liska  <mliska@suse.cz>\n+\n+\t* config-list.mk: Remove deprecated ports.\n+\n+2022-08-30  Ulrich Drepper  <drepper@gmail.com>\n+\n+\t* gcc_update (files_and_dependencies): Add rule for\n+\tgcc/cp/std-name-hint.h.\n+\n+2022-08-30  Martin Liska  <mliska@suse.cz>\n+\n+\t* config-list.mk: Remove the port.\n+\n+2022-08-27  Xi Ruoyao  <xry111@xry111.site>\n+\n+\t* gen_autofdo_event.py: Port to Python 3, and use grep -E\n+\tinstead of egrep.\n+\n+2022-08-26  Martin Liska  <mliska@suse.cz>\n+\n+\t* config-list.mk: Remove cr16.\n+\n 2022-08-19  Stefan Schulze Frielinghaus  <stefansf@linux.ibm.com>\n \n \t* clang-format: Add further FOR_EACH_ macros."}, {"sha": "2056a221ac2c789c4fe673d5f71a188daa118dc7", "filename": "contrib/config-list.mk", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/contrib%2Fconfig-list.mk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/contrib%2Fconfig-list.mk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fconfig-list.mk?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -40,14 +40,13 @@ LIST = aarch64-elf aarch64-linux-gnu aarch64-rtems \\\n   arm-symbianelf avr-elf \\\n   bfin-elf bfin-uclinux bfin-linux-uclibc bfin-rtems bfin-openbsd \\\n   bpf-unknown-none \\\n-  c6x-elf c6x-uclinux cr16-elfOPT-enable-obsolete cris-elf \\\n+  c6x-elf c6x-uclinux cris-elf \\\n   csky-elf csky-linux-gnu \\\n   epiphany-elf epiphany-elfOPT-with-stack-offset=16 fido-elf \\\n   fr30-elf frv-elf frv-linux ft32-elf h8300-elf hppa-linux-gnu \\\n   hppa-linux-gnuOPT-enable-sjlj-exceptions=yes hppa64-linux-gnu \\\n-  hppa2.0-hpux10.1OPT-enable-obsolete hppa64-hpux11.3 \\\n+  hppa64-hpux11.3 \\\n   hppa64-hpux11.0OPT-enable-sjlj-exceptions=yes \\\n-  hppa2.0-hpux11.9OPT-enable-obsolete \\\n   i686-pc-linux-gnu i686-apple-darwin i686-apple-darwin9 i686-apple-darwin10 \\\n   i486-freebsd4 i686-freebsd6 i686-kfreebsd-gnu \\\n   i686-netbsdelf9 \\\n@@ -59,7 +58,7 @@ LIST = aarch64-elf aarch64-linux-gnu aarch64-rtems \\\n   ia64-freebsd6 ia64-linux ia64-hpux ia64-hp-vms iq2000-elf lm32-elf \\\n   lm32-rtems lm32-uclinux \\\n   loongarch64-linux-gnuf64 loongarch64-linux-gnuf32 loongarch64-linux-gnusf \\\n-  m32c-rtems m32c-elf m32r-elf m32rle-elf \\\n+  m32c-elf m32r-elf m32rle-elf \\\n   m68k-elf m68k-netbsdelf \\\n   m68k-uclinux m68k-linux m68k-rtems \\\n   mcore-elf microblaze-linux microblaze-elf \\"}, {"sha": "3c68be028a89b0a64bdb27253744c11b70544899", "filename": "contrib/filter-clang-warnings.py", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/contrib%2Ffilter-clang-warnings.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/contrib%2Ffilter-clang-warnings.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Ffilter-clang-warnings.py?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -39,7 +39,7 @@ def skip_warning(filename, message):\n                  '-Wignored-attributes', '-Wgnu-zero-variadic-macro-arguments',\n                  '-Wformat-security', '-Wundefined-internal',\n                  '-Wunknown-warning-option', '-Wc++20-extensions',\n-                 '-Wbitwise-instead-of-logical'],\n+                 '-Wbitwise-instead-of-logical', 'egrep is obsolescent'],\n             'insn-modes.cc': ['-Wshift-count-overflow'],\n             'insn-emit.cc': ['-Wtautological-compare'],\n             'insn-attrtab.cc': ['-Wparentheses-equality'],\n@@ -57,8 +57,8 @@ def skip_warning(filename, message):\n             'lex.cc': ['-Wc++20-attribute-extensions'],\n     }\n \n-    for name, ignores in ignores.items():\n-        for i in ignores:\n+    for name, ignore in ignores.items():\n+        for i in ignore:\n             if name in filename and i in message:\n                 return True\n     return False"}, {"sha": "dd8b6d0b6bf1c4ce89930cdd56e9850932430f6a", "filename": "contrib/gcc_update", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/contrib%2Fgcc_update", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/contrib%2Fgcc_update", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fgcc_update?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -94,6 +94,7 @@ gcc/config/rs6000/rs6000-tables.opt: gcc/config/rs6000/rs6000-cpus.def gcc/confi\n gcc/config/rs6000/fusion.md: gcc/config/rs6000/genfusion.pl\n # And then, language-specific files\n gcc/cp/cfns.h: gcc/cp/cfns.gperf\n+gcc/cp/std-name-hint.h: gcc/cp/std-name-hint.gperf\n # testsuite\n # Without this, _Pragma3.c can have a false negative.\n gcc/testsuite/gcc.dg/cpp/_Pragma3.c: gcc/testsuite/gcc.dg/cpp/mi1c.h"}, {"sha": "7da2876530d737d25b3eae3a5a06cddd69135b79", "filename": "contrib/gen_autofdo_event.py", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/contrib%2Fgen_autofdo_event.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/contrib%2Fgen_autofdo_event.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fgen_autofdo_event.py?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -1,4 +1,4 @@\n-#!/usr/bin/python\n+#!/usr/bin/python3\n # Generate Intel taken branches Linux perf event script for autofdo profiling.\n \n # Copyright (C) 2016 Free Software Foundation, Inc.\n@@ -26,18 +26,19 @@\n # Requires internet (https) access. This may require setting up a proxy\n # with export https_proxy=...\n #\n-import urllib2\n+import urllib.request\n import sys\n import json\n import argparse\n import collections\n+import os\n \n baseurl = \"https://download.01.org/perfmon\"\n \n-target_events = (u'BR_INST_RETIRED.NEAR_TAKEN',\n-                 u'BR_INST_EXEC.TAKEN',\n-                 u'BR_INST_RETIRED.TAKEN_JCC',\n-                 u'BR_INST_TYPE_RETIRED.COND_TAKEN')\n+target_events = ('BR_INST_RETIRED.NEAR_TAKEN',\n+                 'BR_INST_EXEC.TAKEN',\n+                 'BR_INST_RETIRED.TAKEN_JCC',\n+                 'BR_INST_TYPE_RETIRED.COND_TAKEN')\n \n ap = argparse.ArgumentParser()\n ap.add_argument('--all', '-a', help='Print for all CPUs', action='store_true')\n@@ -71,47 +72,46 @@ def get_cpustr():\n     return \"%s-%d-%X\" % tuple(cpu)[:3]\n \n def find_event(eventurl, model):\n-    print >>sys.stderr, \"Downloading\", eventurl\n-    u = urllib2.urlopen(eventurl)\n+    print(\"Downloading\", eventurl, file = sys.stderr)\n+    u = urllib.request.urlopen(eventurl)\n     events = json.loads(u.read())\n     u.close()\n \n     found = 0\n     for j in events:\n-        if j[u'EventName'] in target_events:\n-            event = \"cpu/event=%s,umask=%s/\" % (j[u'EventCode'], j[u'UMask'])\n-            if u'PEBS' in j and j[u'PEBS'] > 0:\n+        if j['EventName'] in target_events:\n+            event = \"cpu/event=%s,umask=%s/\" % (j['EventCode'], j['UMask'])\n+            if 'PEBS' in j and int(j['PEBS']) > 0:\n                 event += \"p\"\n             if args.script:\n                 eventmap[event].append(model)\n             else:\n-                print j[u'EventName'], \"event for model\", model, \"is\", event\n+                print(j['EventName'], \"event for model\", model, \"is\", event)\n             found += 1\n     return found\n \n if not args.all:\n-    cpu = get_cpu_str()\n+    cpu = get_cpustr()\n     if not cpu:\n         sys.exit(\"Unknown CPU type\")\n \n url = baseurl + \"/mapfile.csv\"\n-print >>sys.stderr, \"Downloading\", url\n-u = urllib2.urlopen(url)\n+print(\"Downloading\", url, file = sys.stderr)\n+u = urllib.request.urlopen(url)\n found = 0\n cpufound = 0\n for j in u:\n-    n = j.rstrip().split(',')\n+    n = j.rstrip().decode().split(',')\n     if len(n) >= 4 and (args.all or n[0] == cpu) and n[3] == \"core\":\n-        if args.all:\n-            components = n[0].split(\"-\")\n-            model = components[2]\n-            model = int(model, 16)\n+        components = n[0].split(\"-\")\n+        model = components[2]\n+        model = int(model, 16)\n         cpufound += 1\n         found += find_event(baseurl + n[2], model)\n u.close()\n \n if args.script:\n-    print '''#!/bin/sh\n+    print('''#!/bin/sh\n # Profile workload for gcc profile feedback (autofdo) using Linux perf.\n # Auto generated. To regenerate for new CPUs run\n # contrib/gen_autofdo_event.py --script --all in gcc source\n@@ -146,27 +146,27 @@ def find_event(eventurl, model):\n   echo >&2 \"Warning: branch profiling may not be functional in VMs\"\n fi\n \n-case `egrep -q \"^cpu family\\s*: 6\" /proc/cpuinfo &&\n-  egrep \"^model\\s*:\" /proc/cpuinfo | head -n1` in'''\n-    for event, mod in eventmap.iteritems():\n+case `grep -E -q \"^cpu family\\s*: 6\" /proc/cpuinfo &&\n+  grep -E \"^model\\s*:\" /proc/cpuinfo | head -n1` in''')\n+    for event, mod in eventmap.items():\n         for m in mod[:-1]:\n-            print \"model*:\\ %s|\\\\\" % m\n-        print 'model*:\\ %s) E=\"%s$FLAGS\" ;;' % (mod[-1], event)\n-    print '''*)\n+            print(\"model*:\\ %s|\\\\\" % m)\n+        print('model*:\\ %s) E=\"%s$FLAGS\" ;;' % (mod[-1], event))\n+    print('''*)\n echo >&2 \"Unknown CPU. Run contrib/gen_autofdo_event.py --all --script to update script.\"\n-\texit 1 ;;'''\n-    print \"esac\"\n-    print \"set -x\"\n-    print 'if ! perf record -e $E -b \"$@\" ; then'\n-    print '  # PEBS may not actually be working even if the processor supports it'\n-    print '  # (e.g., in a virtual machine). Trying to run without /p.'\n-    print '  set +x'\n-    print '  echo >&2 \"Retrying without /p.\"'\n-    print '  E=\"$(echo \"${E}\" | sed -e \\'s/\\/p/\\//\\')\"'\n-    print '  set -x'\n-    print '  exec perf record -e $E -b \"$@\"'\n-    print ' set +x'\n-    print 'fi'\n+\texit 1 ;;''')\n+    print(\"esac\")\n+    print(\"set -x\")\n+    print('if ! perf record -e $E -b \"$@\" ; then')\n+    print('  # PEBS may not actually be working even if the processor supports it')\n+    print('  # (e.g., in a virtual machine). Trying to run without /p.')\n+    print('  set +x')\n+    print('  echo >&2 \"Retrying without /p.\"')\n+    print('  E=\"$(echo \"${E}\" | sed -e \\'s/\\/p/\\//\\')\"')\n+    print('  set -x')\n+    print('  exec perf record -e $E -b \"$@\"')\n+    print(' set +x')\n+    print('fi')\n \n if cpufound == 0 and not args.all:\n     sys.exit('CPU %s not found' % cpu)"}, {"sha": "c8735e1d73e3faebfca4b5f9f866bfd40d8f2171", "filename": "contrib/header-tools/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/contrib%2Fheader-tools%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/contrib%2Fheader-tools%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fheader-tools%2FChangeLog?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -1,3 +1,8 @@\n+2022-08-31  Martin Liska  <mliska@suse.cz>\n+\n+\t* README: Remove deprecated ports.\n+\t* reduce-headers: Likewise.\n+\n 2022-01-17  Martin Liska  <mliska@suse.cz>\n \n \t* README: Rename .c names to .cc."}, {"sha": "48381fe0ba4d1a4bf35d0c845a551e41dac3269c", "filename": "contrib/header-tools/README", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/contrib%2Fheader-tools%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/contrib%2Fheader-tools%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fheader-tools%2FREADME?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -203,7 +203,7 @@ reduce-headers\n   these targets.  They are also known to the tool.  When building targets it\n   will check those targets before the rest.  \n   This coverage can be achieved by building config-list.mk with :\n-  LIST=\"aarch64-linux-gnu arm-netbsdelf c6x-elf epiphany-elf hppa2.0-hpux10.1 i686-mingw32crt i686-pc-msdosdjgpp mipsel-elf powerpc-eabisimaltivec rs6000-ibm-aix5.1.0 sh-superh-elf sparc64-elf\"\n+  LIST=\"aarch64-linux-gnu arm-netbsdelf c6x-elf epiphany-elf i686-mingw32crt i686-pc-msdosdjgpp mipsel-elf powerpc-eabisimaltivec rs6000-ibm-aix5.1.0 sh-superh-elf sparc64-elf\"\n \n   -b specifies the native bootstrapped build root directory\n   -t specifies a target build root directory that config-list.mk was run from"}, {"sha": "7d236e30688bc5ca56c1c0bf7048889036bc9d13", "filename": "contrib/header-tools/reduce-headers", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/contrib%2Fheader-tools%2Freduce-headers", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/contrib%2Fheader-tools%2Freduce-headers", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fheader-tools%2Freduce-headers?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -25,7 +25,6 @@ target_priority = [\n     \"arm-netbsdelf\",\n     \"c6x-elf\",\n     \"epiphany-elf\",\n-    \"hppa2.0-hpux10.1\",\n     \"i686-mingw32crt\",\n     \"i686-pc-msdosdjgpp\",\n     \"mipsel-elf\","}, {"sha": "d67e572f310a20d8b80b41358c875a92747b049c", "filename": "fixincludes/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/fixincludes%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/fixincludes%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/fixincludes%2FChangeLog?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -1,3 +1,16 @@\n+2022-08-31  Martin Liska  <mliska@suse.cz>\n+\n+\t* configure: Regenerate.\n+\n+2022-08-31  Martin Liska  <mliska@suse.cz>\n+\n+\t* configure: Regenerate.\n+\n+2022-08-25  Martin Liska  <mliska@suse.cz>\n+\n+\t* config.h.in: Regenerate.\n+\t* configure: Regenerate.\n+\n 2022-02-27  John David Anglin  <danglin@gcc.gnu.org>\n \n \t* inclhack.def (hpux_math_constexpr): New hack."}, {"sha": "69a67f5f116723b69a58e7959cf75bfaa2a3dbbb", "filename": "fixincludes/config.h.in", "status": "modified", "additions": 0, "deletions": 204, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/fixincludes%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/fixincludes%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/fixincludes%2Fconfig.h.in?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -1,397 +1,211 @@\n /* config.h.in.  Generated from configure.ac by autoheader.  */\n \n /* Defined to the executable file extension on the host system */\n-#ifndef USED_FOR_TARGET\n #undef EXE_EXT\n-#endif\n-\n \n /* Define to 1 if you have the `clearerr_unlocked' function. */\n-#ifndef USED_FOR_TARGET\n #undef HAVE_CLEARERR_UNLOCKED\n-#endif\n-\n \n /* Define to 1 if you have the declaration of `abort', and to 0 if you don't.\n    */\n-#ifndef USED_FOR_TARGET\n #undef HAVE_DECL_ABORT\n-#endif\n-\n \n /* Define to 1 if you have the declaration of `asprintf', and to 0 if you\n    don't. */\n-#ifndef USED_FOR_TARGET\n #undef HAVE_DECL_ASPRINTF\n-#endif\n-\n \n /* Define to 1 if you have the declaration of `basename(char *)', and to 0 if\n    you don't. */\n-#ifndef USED_FOR_TARGET\n #undef HAVE_DECL_BASENAME\n-#endif\n-\n \n /* Define to 1 if you have the declaration of `clearerr_unlocked', and to 0 if\n    you don't. */\n-#ifndef USED_FOR_TARGET\n #undef HAVE_DECL_CLEARERR_UNLOCKED\n-#endif\n-\n \n /* Define to 1 if you have the declaration of `errno', and to 0 if you don't.\n    */\n-#ifndef USED_FOR_TARGET\n #undef HAVE_DECL_ERRNO\n-#endif\n-\n \n /* Define to 1 if you have the declaration of `feof_unlocked', and to 0 if you\n    don't. */\n-#ifndef USED_FOR_TARGET\n #undef HAVE_DECL_FEOF_UNLOCKED\n-#endif\n-\n \n /* Define to 1 if you have the declaration of `ferror_unlocked', and to 0 if\n    you don't. */\n-#ifndef USED_FOR_TARGET\n #undef HAVE_DECL_FERROR_UNLOCKED\n-#endif\n-\n \n /* Define to 1 if you have the declaration of `fflush_unlocked', and to 0 if\n    you don't. */\n-#ifndef USED_FOR_TARGET\n #undef HAVE_DECL_FFLUSH_UNLOCKED\n-#endif\n-\n \n /* Define to 1 if you have the declaration of `fgetc_unlocked', and to 0 if\n    you don't. */\n-#ifndef USED_FOR_TARGET\n #undef HAVE_DECL_FGETC_UNLOCKED\n-#endif\n-\n \n /* Define to 1 if you have the declaration of `fgets_unlocked', and to 0 if\n    you don't. */\n-#ifndef USED_FOR_TARGET\n #undef HAVE_DECL_FGETS_UNLOCKED\n-#endif\n-\n \n /* Define to 1 if you have the declaration of `fileno_unlocked', and to 0 if\n    you don't. */\n-#ifndef USED_FOR_TARGET\n #undef HAVE_DECL_FILENO_UNLOCKED\n-#endif\n-\n \n /* Define to 1 if you have the declaration of `fprintf_unlocked', and to 0 if\n    you don't. */\n-#ifndef USED_FOR_TARGET\n #undef HAVE_DECL_FPRINTF_UNLOCKED\n-#endif\n-\n \n /* Define to 1 if you have the declaration of `fputc_unlocked', and to 0 if\n    you don't. */\n-#ifndef USED_FOR_TARGET\n #undef HAVE_DECL_FPUTC_UNLOCKED\n-#endif\n-\n \n /* Define to 1 if you have the declaration of `fputs_unlocked', and to 0 if\n    you don't. */\n-#ifndef USED_FOR_TARGET\n #undef HAVE_DECL_FPUTS_UNLOCKED\n-#endif\n-\n \n /* Define to 1 if you have the declaration of `fread_unlocked', and to 0 if\n    you don't. */\n-#ifndef USED_FOR_TARGET\n #undef HAVE_DECL_FREAD_UNLOCKED\n-#endif\n-\n \n /* Define to 1 if you have the declaration of `fwrite_unlocked', and to 0 if\n    you don't. */\n-#ifndef USED_FOR_TARGET\n #undef HAVE_DECL_FWRITE_UNLOCKED\n-#endif\n-\n \n /* Define to 1 if you have the declaration of `getchar_unlocked', and to 0 if\n    you don't. */\n-#ifndef USED_FOR_TARGET\n #undef HAVE_DECL_GETCHAR_UNLOCKED\n-#endif\n-\n \n /* Define to 1 if you have the declaration of `getc_unlocked', and to 0 if you\n    don't. */\n-#ifndef USED_FOR_TARGET\n #undef HAVE_DECL_GETC_UNLOCKED\n-#endif\n-\n \n /* Define to 1 if you have the declaration of `putchar_unlocked', and to 0 if\n    you don't. */\n-#ifndef USED_FOR_TARGET\n #undef HAVE_DECL_PUTCHAR_UNLOCKED\n-#endif\n-\n \n /* Define to 1 if you have the declaration of `putc_unlocked', and to 0 if you\n    don't. */\n-#ifndef USED_FOR_TARGET\n #undef HAVE_DECL_PUTC_UNLOCKED\n-#endif\n-\n \n /* Define to 1 if you have the declaration of `vasprintf', and to 0 if you\n    don't. */\n-#ifndef USED_FOR_TARGET\n #undef HAVE_DECL_VASPRINTF\n-#endif\n-\n \n /* Define to 1 if you have the <fcntl.h> header file. */\n-#ifndef USED_FOR_TARGET\n #undef HAVE_FCNTL_H\n-#endif\n-\n \n /* Define to 1 if you have the `feof_unlocked' function. */\n-#ifndef USED_FOR_TARGET\n #undef HAVE_FEOF_UNLOCKED\n-#endif\n-\n \n /* Define to 1 if you have the `ferror_unlocked' function. */\n-#ifndef USED_FOR_TARGET\n #undef HAVE_FERROR_UNLOCKED\n-#endif\n-\n \n /* Define to 1 if you have the `fflush_unlocked' function. */\n-#ifndef USED_FOR_TARGET\n #undef HAVE_FFLUSH_UNLOCKED\n-#endif\n-\n \n /* Define to 1 if you have the `fgetc_unlocked' function. */\n-#ifndef USED_FOR_TARGET\n #undef HAVE_FGETC_UNLOCKED\n-#endif\n-\n \n /* Define to 1 if you have the `fgets_unlocked' function. */\n-#ifndef USED_FOR_TARGET\n #undef HAVE_FGETS_UNLOCKED\n-#endif\n-\n \n /* Define to 1 if you have the `fileno_unlocked' function. */\n-#ifndef USED_FOR_TARGET\n #undef HAVE_FILENO_UNLOCKED\n-#endif\n-\n \n /* Define to 1 if you have the `fprintf_unlocked' function. */\n-#ifndef USED_FOR_TARGET\n #undef HAVE_FPRINTF_UNLOCKED\n-#endif\n-\n \n /* Define to 1 if you have the `fputc_unlocked' function. */\n-#ifndef USED_FOR_TARGET\n #undef HAVE_FPUTC_UNLOCKED\n-#endif\n-\n \n /* Define to 1 if you have the `fputs_unlocked' function. */\n-#ifndef USED_FOR_TARGET\n #undef HAVE_FPUTS_UNLOCKED\n-#endif\n-\n \n /* Define to 1 if you have the `fread_unlocked' function. */\n-#ifndef USED_FOR_TARGET\n #undef HAVE_FREAD_UNLOCKED\n-#endif\n-\n \n /* Define to 1 if you have the `fwrite_unlocked' function. */\n-#ifndef USED_FOR_TARGET\n #undef HAVE_FWRITE_UNLOCKED\n-#endif\n-\n \n /* Define to 1 if you have the `getchar_unlocked' function. */\n-#ifndef USED_FOR_TARGET\n #undef HAVE_GETCHAR_UNLOCKED\n-#endif\n-\n \n /* Define to 1 if you have the `getc_unlocked' function. */\n-#ifndef USED_FOR_TARGET\n #undef HAVE_GETC_UNLOCKED\n-#endif\n-\n \n /* Define to 1 if you have the <inttypes.h> header file. */\n-#ifndef USED_FOR_TARGET\n #undef HAVE_INTTYPES_H\n-#endif\n-\n \n /* Define to 1 if you have the <memory.h> header file. */\n-#ifndef USED_FOR_TARGET\n #undef HAVE_MEMORY_H\n-#endif\n-\n \n /* Define if mmap with MAP_ANON(YMOUS) works. */\n-#ifndef USED_FOR_TARGET\n #undef HAVE_MMAP_ANON\n-#endif\n-\n \n /* Define if mmap of /dev/zero works. */\n-#ifndef USED_FOR_TARGET\n #undef HAVE_MMAP_DEV_ZERO\n-#endif\n-\n \n /* Define if read-only mmap of a plain file works. */\n-#ifndef USED_FOR_TARGET\n #undef HAVE_MMAP_FILE\n-#endif\n-\n \n /* Define to 1 if you have the `putchar_unlocked' function. */\n-#ifndef USED_FOR_TARGET\n #undef HAVE_PUTCHAR_UNLOCKED\n-#endif\n-\n \n /* Define to 1 if you have the `putc_unlocked' function. */\n-#ifndef USED_FOR_TARGET\n #undef HAVE_PUTC_UNLOCKED\n-#endif\n-\n \n /* Define to 1 if you have the <stddef.h> header file. */\n-#ifndef USED_FOR_TARGET\n #undef HAVE_STDDEF_H\n-#endif\n-\n \n /* Define to 1 if you have the <stdint.h> header file. */\n-#ifndef USED_FOR_TARGET\n #undef HAVE_STDINT_H\n-#endif\n-\n \n /* Define to 1 if you have the <stdlib.h> header file. */\n-#ifndef USED_FOR_TARGET\n #undef HAVE_STDLIB_H\n-#endif\n-\n \n /* Define to 1 if you have the <strings.h> header file. */\n-#ifndef USED_FOR_TARGET\n #undef HAVE_STRINGS_H\n-#endif\n-\n \n /* Define to 1 if you have the <string.h> header file. */\n-#ifndef USED_FOR_TARGET\n #undef HAVE_STRING_H\n-#endif\n-\n \n /* Define to 1 if you have the <sys/file.h> header file. */\n-#ifndef USED_FOR_TARGET\n #undef HAVE_SYS_FILE_H\n-#endif\n-\n \n /* Define to 1 if you have the <sys/stat.h> header file. */\n-#ifndef USED_FOR_TARGET\n #undef HAVE_SYS_STAT_H\n-#endif\n-\n \n /* Define to 1 if you have the <sys/types.h> header file. */\n-#ifndef USED_FOR_TARGET\n #undef HAVE_SYS_TYPES_H\n-#endif\n-\n \n /* Define to 1 if you have the <unistd.h> header file. */\n-#ifndef USED_FOR_TARGET\n #undef HAVE_UNISTD_H\n-#endif\n-\n \n /* Define to the address where bug reports for this package should be sent. */\n-#ifndef USED_FOR_TARGET\n #undef PACKAGE_BUGREPORT\n-#endif\n-\n \n /* Define to the full name of this package. */\n-#ifndef USED_FOR_TARGET\n #undef PACKAGE_NAME\n-#endif\n-\n \n /* Define to the full name and version of this package. */\n-#ifndef USED_FOR_TARGET\n #undef PACKAGE_STRING\n-#endif\n-\n \n /* Define to the one symbol short name of this package. */\n-#ifndef USED_FOR_TARGET\n #undef PACKAGE_TARNAME\n-#endif\n-\n \n /* Define to the home page for this package. */\n-#ifndef USED_FOR_TARGET\n #undef PACKAGE_URL\n-#endif\n-\n \n /* Define to the version of this package. */\n-#ifndef USED_FOR_TARGET\n #undef PACKAGE_VERSION\n-#endif\n-\n \n /* Defined to the best working sed program on the host system */\n-#ifndef USED_FOR_TARGET\n #undef SED_PROGRAM\n-#endif\n-\n \n /* Define if testing and fixing are done by separate process */\n-#ifndef USED_FOR_TARGET\n #undef SEPARATE_FIX_PROC\n-#endif\n-\n \n /* Define to 1 if you have the ANSI C header files. */\n-#ifndef USED_FOR_TARGET\n #undef STDC_HEADERS\n-#endif\n-\n \n /* Enable extensions on AIX 3, Interix.  */\n #ifndef _ALL_SOURCE\n@@ -416,38 +230,20 @@\n \n \n /* Define to 1 if on MINIX. */\n-#ifndef USED_FOR_TARGET\n #undef _MINIX\n-#endif\n-\n \n /* Define to 2 if the system does not provide POSIX.1 features except with\n    this defined. */\n-#ifndef USED_FOR_TARGET\n #undef _POSIX_1_SOURCE\n-#endif\n-\n \n /* Define to 1 if you need to in order for `stat' and other things to work. */\n-#ifndef USED_FOR_TARGET\n #undef _POSIX_SOURCE\n-#endif\n-\n \n /* Define to xatexit if the host system does not support atexit */\n-#ifndef USED_FOR_TARGET\n #undef atexit\n-#endif\n-\n \n /* Define to empty if `const' does not conform to ANSI C. */\n-#ifndef USED_FOR_TARGET\n #undef const\n-#endif\n-\n \n /* Define to xexit if the host system does not support atexit */\n-#ifndef USED_FOR_TARGET\n #undef exit\n-#endif\n-"}, {"sha": "b3bca666a4d03ad8681d1fc9fdb4cddcc209de72", "filename": "fixincludes/configure", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/fixincludes%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/fixincludes%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/fixincludes%2Fconfigure?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -2644,7 +2644,7 @@ ac_configure=\"$SHELL $ac_aux_dir/configure\"  # Please don't use this var.\n \n # _LT_DARWIN_LINKER_FEATURES\n # --------------------------\n-# Checks for linker and compiler features on darwin\n+# Checks for linker and compiler features on Darwin / macOS / iOS\n \n \n # _LT_SYS_MODULE_PATH_AIX"}, {"sha": "4ff50c3d2f3a92ed488b07fa6244dca5e350b1ce", "filename": "gcc/ChangeLog", "status": "modified", "additions": 3267, "deletions": 0, "changes": 3267, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "c0c32de03710e5797065be905c0f22f0b229c3dc", "filename": "gcc/DATESTAMP", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2FDATESTAMP", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2FDATESTAMP", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FDATESTAMP?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -1 +1 @@\n-20220823\n+20220924"}, {"sha": "59b67d994415fb7ee5f8f2f8fa61bf30536e4069", "filename": "gcc/Makefile.in", "status": "modified", "additions": 16, "deletions": 20, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -1262,6 +1262,7 @@ ANALYZER_OBJS = \\\n \tanalyzer/engine.o \\\n \tanalyzer/feasible-graph.o \\\n \tanalyzer/function-set.o \\\n+\tanalyzer/known-function-manager.o \\\n \tanalyzer/pending-diagnostic.o \\\n \tanalyzer/program-point.o \\\n \tanalyzer/program-state.o \\\n@@ -1353,7 +1354,6 @@ OBJS = \\\n \tdata-streamer.o \\\n \tdata-streamer-in.o \\\n \tdata-streamer-out.o \\\n-\tdbxout.o \\\n \tdbgcnt.o \\\n \tdce.o \\\n \tddg.o \\\n@@ -1416,6 +1416,7 @@ OBJS = \\\n \tgimple-range-fold.o \\\n \tgimple-range-gori.o \\\n \tgimple-range-infer.o \\\n+\tgimple-range-op.o \\\n \tgimple-range-trace.o \\\n \tgimple-ssa-backprop.o \\\n \tgimple-ssa-isolate-paths.o \\\n@@ -1727,7 +1728,6 @@ OBJS = \\\n \tweb.o \\\n \twide-int.o \\\n \twide-int-print.o \\\n-\txcoffout.o \\\n \t$(out_object_file) \\\n \t$(ANALYZER_OBJS) \\\n \t$(EXTRA_OBJS) \\\n@@ -2676,7 +2676,7 @@ GTFILES = $(CPPLIB_H) $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/reload.h $(srcdir)/caller-save.cc $(srcdir)/symtab.cc \\\n   $(srcdir)/alias.cc $(srcdir)/bitmap.cc $(srcdir)/cselib.cc $(srcdir)/cgraph.cc \\\n   $(srcdir)/ipa-prop.cc $(srcdir)/ipa-cp.cc $(srcdir)/ipa-utils.h \\\n-  $(srcdir)/ipa-param-manipulation.h $(srcdir)/ipa-sra.cc $(srcdir)/dbxout.cc \\\n+  $(srcdir)/ipa-param-manipulation.h $(srcdir)/ipa-sra.cc \\\n   $(srcdir)/ipa-modref.h $(srcdir)/ipa-modref.cc \\\n   $(srcdir)/ipa-modref-tree.h \\\n   $(srcdir)/signop.h \\\n@@ -3166,24 +3166,27 @@ stmp-int-hdrs: $(STMP_FIXINC) $(T_GLIMITS_H) $(T_STDINT_GCC_H) $(USER_H) fixinc_\n \tset -e; for ml in `cat fixinc_list`; do \\\n \t  sysroot_headers_suffix=`echo $${ml} | sed -e 's/;.*$$//'`; \\\n \t  multi_dir=`echo $${ml} | sed -e 's/^[^;]*;//'`; \\\n-\t  fix_dir=include-fixed$${multi_dir}; \\\n+\t  include_dir=include$${multi_dir}; \\\n \t  if $(LIMITS_H_TEST) ; then \\\n \t    cat $(srcdir)/limitx.h $(T_GLIMITS_H) $(srcdir)/limity.h > tmp-xlimits.h; \\\n \t  else \\\n \t    cat $(T_GLIMITS_H) > tmp-xlimits.h; \\\n \t  fi; \\\n-\t  $(mkinstalldirs) $${fix_dir}; \\\n-\t  chmod a+rx $${fix_dir} || true; \\\n+\t  $(mkinstalldirs) $${include_dir}; \\\n+\t  chmod a+rx $${include_dir} || true; \\\n \t  $(SHELL) $(srcdir)/../move-if-change \\\n \t    tmp-xlimits.h  tmp-limits.h; \\\n-\t  rm -f $${fix_dir}/limits.h; \\\n-\t  cp -p tmp-limits.h $${fix_dir}/limits.h; \\\n-\t  chmod a+r $${fix_dir}/limits.h; \\\n+\t  rm -f $${include_dir}/limits.h; \\\n+\t  cp -p tmp-limits.h $${include_dir}/limits.h; \\\n+\t  chmod a+r $${include_dir}/limits.h; \\\n+\t  cp $(srcdir)/gsyslimits.h $${include_dir}/syslimits.h; \\\n \tdone\n # Install the README\n-\trm -f include-fixed/README\n-\tcp $(srcdir)/../fixincludes/README-fixinc include-fixed/README\n-\tchmod a+r include-fixed/README\n+\tif [ x$(STMP_FIXINC) != x ]; then \\\n+\t  rm -f include-fixed/README; \\\n+\t  cp $(srcdir)/../fixincludes/README-fixinc include-fixed/README; \\\n+\t  chmod a+r include-fixed/README; \\\n+\tfi;\n \t$(STAMP) $@\n \n .PHONY: install-gcc-tooldir\n@@ -3268,13 +3271,6 @@ stmp-fixinc: gsyslimits.h macro_list fixinc_list \\\n \t      cd $(build_objdir)/fixincludes && \\\n \t      $(SHELL) ./fixinc.sh \"$${gcc_dir}/$${fix_dir}\" \\\n \t        $(BUILD_SYSTEM_HEADER_DIR) $(OTHER_FIXINCLUDES_DIRS) ); \\\n-\t    rm -f $${fix_dir}/syslimits.h; \\\n-\t    if [ -f $${fix_dir}/limits.h ]; then \\\n-\t      mv $${fix_dir}/limits.h $${fix_dir}/syslimits.h; \\\n-\t    else \\\n-\t      cp $(srcdir)/gsyslimits.h $${fix_dir}/syslimits.h; \\\n-\t    fi; \\\n-\t    chmod a+r $${fix_dir}/syslimits.h; \\\n \t  done; \\\n \tfi\n \t$(STAMP) stmp-fixinc\n@@ -3992,7 +3988,7 @@ install-mkheaders: stmp-int-hdrs install-itoolsdirs \\\n \tset -e; for ml in `cat fixinc_list`; do \\\n \t  multi_dir=`echo $${ml} | sed -e 's/^[^;]*;//'`; \\\n \t  $(mkinstalldirs) $(DESTDIR)$(itoolsdatadir)/include$${multi_dir}; \\\n-\t  $(INSTALL_DATA) include-fixed$${multi_dir}/limits.h $(DESTDIR)$(itoolsdatadir)/include$${multi_dir}/limits.h; \\\n+\t  $(INSTALL_DATA) include$${multi_dir}/limits.h $(DESTDIR)$(itoolsdatadir)/include$${multi_dir}/limits.h; \\\n \tdone\n \t$(INSTALL_SCRIPT) $(srcdir)/../mkinstalldirs \\\n \t\t$(DESTDIR)$(itoolsdir)/mkinstalldirs ; \\"}, {"sha": "fe048b898a4407608fdd3a2b13ee8afb75187e2c", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 1272, "deletions": 0, "changes": 1272, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -1,3 +1,1275 @@\n+2022-09-20  Martin Liska  <mliska@suse.cz>\n+\n+\t* exp_ch6.adb: Replace \"the the\" with \"the\".\n+\t* sem_ch6.adb: Likewise.\n+\t* sem_disp.ads: Likewise.\n+\n+2022-09-15  Richard Biener  <rguenther@suse.de>\n+\n+\t* gcc-interface/trans.cc (gigi): Do not initialize void_list_node.\n+\n+2022-09-12  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.cc (gnat_to_gnu_entity): Relax assertion when\n+\tfront-end unnesting is enabled.\n+\n+2022-09-12  Justin Squirek  <squirek@adacore.com>\n+\n+\t* sem_util.adb\n+\t(Innermost_Master_Scope_Depth): Detect and handle case where scope\n+\tdepth is not set on an enclosing scope.\n+\n+2022-09-12  Steve Baird  <baird@adacore.com>\n+\n+\t* bindgen.adb: When the binder is invoked for the host, generate a\n+\t\"with CUDA.Internal;\" with clause.\n+\n+2022-09-12  Piotr Trojanek  <trojanek@adacore.com>\n+\n+\t* doc/gnat_rm/implementation_defined_pragmas.rst\n+\t(Pragma Unreferenced): Sync description with\n+\tSem_Warn.Has_Junk_Name routine.\n+\t* gnat_rm.texi: Regenerate.\n+\t* gnat_ugn.texi: Regenerate.\n+\n+2022-09-12  Piotr Trojanek  <trojanek@adacore.com>\n+\n+\t* sem_attr.adb (Analyze_Attribute [Valid_Scalars]): Move check for\n+\tunchecked union before checks for private and public types.\n+\n+2022-09-12  Steve Baird  <baird@adacore.com>\n+\n+\t* bindgen.adb: When the binder is invoked for the host, it\n+\tdeclares imported subprograms corresponding to the Adainit and\n+\tAdafinal routines on the device. Declare string constants and\n+\texpression functions for the Ada source names and the link names\n+\tof these routines. Generate these subprogram declarations (and\n+\taccompanying Import pragmas) in Gen_CUDA_Defs. Generate\n+\tCUDA_Execute pragmas to call these subprograms from the host in\n+\tGen_Adafinal and Gen_CUDA_Init. When the binder is invoked for the\n+\tdevice, include a CUDA_Global aspect declaration in the\n+\tdeclarations of Adainit and Adafinal and use the aforementioned\n+\tlink names in the Export pragmas generated for those two routines.\n+\t* debug.adb: Update comments about \"d_c\" and \"d_d\" switches.\n+\t* opt.ads: Declare new Boolean variable,\n+\tEnable_CUDA_Device_Expansion. This complements the existing\n+\tEnable_CUDA_Expansion variable, which is used to enable host-side\n+\tCUDA expansion. The new variable enables device-side CUDA\n+\texpansion. It is currently never set during compilation; it is\n+\tonly set via a binder switch.\n+\t* switch-b.adb\n+\t(scan_debug_switches): Add new use of the \"-d_d\" binder switch.\n+\tThe new switch and the variable Opt.Enabled_CUDA_Device_Expansion\n+\tfollow the existing pattern of the \"-d_c\" switch and the variable\n+\tOpt.Enabled_CUDA_Expansion. Flag error if both \"-d_c\" and \"-d_d\"\n+\tare specified.\n+\n+2022-09-12  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* contracts.adb (uild_Subprogram_Contract_Wrapper): Remove useless\n+\tlocal variable. In the case of a function, replace the extended\n+\treturn statement by a block statement declaring a renaming of the\n+\tcall to the local subprogram after removing side effects manually.\n+\t(Expand_Subprogram_Contract): Adjust description accordingly.\n+\t* exp_ch6.adb (Expand_Ctrl_Function_Call): Rewrite obsolete\n+\tcomment and do not apply the transformation twice.\n+\t* sem_attr.adb (Analyze_Attribute_Old_Result): Now expect a block\n+\tstatement instead of an extended return statement.\n+\n+2022-09-12  Piotr Trojanek  <trojanek@adacore.com>\n+\n+\t* erroutc.adb (Set_Msg_Insertion_Name): Special-case printing with\n+\tacronyms.\n+\n+2022-09-12  Yannick Moy  <moy@adacore.com>\n+\n+\t* libgnat/s-imagei.adb (Image_Integer): Add justification.\n+\n+2022-09-12  Piotr Trojanek  <trojanek@adacore.com>\n+\n+\t* sem_prag.adb (Get_SPARK_Mode_Type): Fix header box; replace\n+\tchained IF with a CASE statement.\n+\n+2022-09-12  Yannick Moy  <moy@adacore.com>\n+\n+\t* sem_prag.adb (Analyze_Pragma): Accept SPARK_Mode=>Auto as\n+\tconfiguration pragma.\n+\t(Get_SPARK_Mode): Make the value for Auto explicit.\n+\t* snames.ads-tmpl (Name_Auto): Add name.\n+\n+2022-09-12  Joffrey Huguet  <huguet@adacore.com>\n+\n+\t* doc/gnat_rm/the_gnat_library.rst: Remove paragraphs about SPARK\n+\tcontainers.\n+\t* gnat_rm.texi, gnat_ugn.texi: Regenerate.\n+\n+2022-09-12  Yannick Moy  <moy@adacore.com>\n+\n+\t* libgnat/s-maccod.ads: Mark package as SPARK_Mode Off.\n+\n+2022-09-12  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* fe.h (Unnest_Subprogram_Mode): Declare.\n+\n+2022-09-12  Steve Baird  <baird@adacore.com>\n+\n+\t* contracts.adb\n+\t(Analyze_Package_Contract): Do not analyze the contract of a\n+\ttemporary package created just to check conformance of an actual\n+\tpackage.\n+\n+2022-09-12  Joffrey Huguet  <huguet@adacore.com>\n+\n+\t* Makefile.rtl: Remove SPARK containers filenames.\n+\t* impunit.adb: Remove SPARK containers packages names.\n+\t* libgnat/a-cfdlli.adb, libgnat/a-cfdlli.ads: Remove content and\n+\tadd pragma Compile_Time_Error with suitable message.\n+\t* libgnat/a-cfhama.adb, libgnat/a-cfhama.ads: Likewise.\n+\t* libgnat/a-cfhase.adb, libgnat/a-cfhase.ads: Likewise.\n+\t* libgnat/a-cfidll.adb, libgnat/a-cfidll.ads: Likewise.\n+\t* libgnat/a-cfinse.adb, libgnat/a-cfinse.ads: Likewise.\n+\t* libgnat/a-cfinve.adb, libgnat/a-cfinve.ads: Likewise.\n+\t* libgnat/a-cforma.adb, libgnat/a-cforma.ads: Likewise.\n+\t* libgnat/a-cforse.adb, libgnat/a-cforse.ads: Likewise.\n+\t* libgnat/a-cofove.adb, libgnat/a-cofove.ads: Likewise.\n+\t* libgnat/a-cofuma.adb, libgnat/a-cofuma.ads: Likewise.\n+\t* libgnat/a-cofuse.adb, libgnat/a-cofuse.ads: Likewise.\n+\t* libgnat/a-cofuve.adb, libgnat/a-cofuve.ads: Likewise.\n+\t* libgnat/a-cofuba.adb, libgnat/a-cofuba.ads: Remove package.\n+\n+2022-09-12  Piotr Trojanek  <trojanek@adacore.com>\n+\n+\t* exp_attr.adb (Expand_N_Attribute_Reference [Attribute_Old]):\n+\tAdapt to object declaration being rewritten into object renaming.\n+\n+2022-09-12  Justin Squirek  <squirek@adacore.com>\n+\n+\t* contracts.adb, contracts.ads\n+\t(Analyze_Pragmas_In_Declarations): Added to aid in the new\n+\texpansion model so that pragmas relating to contracts can get\n+\tprocessed early before the rest of the subprogram containing them.\n+\t(Build_Subprogram_Contract_Wrapper): Created to do the majority of\n+\texpansion for postconditions. It builds a local wrapper with the\n+\tstatements and declarations within a given subprogram.\n+\t(Is_Prologue_Renaming): Moved out from Process_Preconditions to be\n+\tused generally within the contracts package.\n+\t(Build_Entry_Contract_Wrapper): Moved from exp_ch7.\n+\t(Expand_Subprogram_Contract): Add new local variable Decls to\n+\tstore expanded declarations needed for evaluation of contracts.\n+\tCall new wrapper building procedure and modify comments to match\n+\tnew expansion model.\n+\t(Get_Postcond_Enabled): Deleted.\n+\t(Get_Result_Object_For_Postcond): Deleted.\n+\t(Get_Return_Success_For_Postcond): Deleted.\n+\t(Process_Contract_Cases): Add new parameter to store declarations.\n+\t(Process_Postconditions): Add new parameter to store declarations.\n+\t(Process_Preconditions): Add new parameter to store declarations.\n+\tAdd code to move entry-call prologue renamings\n+\t* einfo.ads: Document new field Wrapped_Statements and modify\n+\tcomment for Postconditions_Proc.\n+\t* exp_attr.adb\n+\t(Analyze_Attribute): Modify expansion of the 'Old attribute to\n+\trecognize new expansion model and use Wrapped_Statements instead\n+\tof Postconditions_Proc.\n+\t* exp_ch6.adb\n+\t(Add_Return): Remove special expansion for postconditions.\n+\t(Expand_Call): Modify condition checking for calls to access\n+\tsubprogram wrappers to handle new expansion models.\n+\t(Expand_Call_Helper): Remove special expansion for postconditions.\n+\t(Expand_Non_Function_Return): Remove special expansion for\n+\tpostconditions.\n+\t(Expand_Simple_Function_Return): Remove special expansion for\n+\tpostconditions.\n+\t* exp_ch7.adb\n+\t(Build_Finalizer): Deleted, but replaced by code in\n+\tBuild_Finalizer_Helper\n+\t(Build_Finalizer_Helper): Renamed to Build_Finalizer, and special\n+\thandling of 'Old objects removed.\n+\t* exp_ch9.adb\n+\t(Build_Contract_Wrapper): Renamed and moved to contracts package.\n+\t* exp_prag.adb\n+\t(Expand_Pragma_Contract_Cases): Delay analysis of contracts since\n+\tthey now instead get analyzed as part of the wrapper generation\n+\tinstead of after analysis of their corresponding subprogram's\n+\tbody.\n+\t(Expand_Pragma_Check): Label expanded if-statements which come\n+\tfrom the expansion of assertion statements as\n+\tComes_From_Check_Or_Contract.\n+\t* freeze.adb\n+\t(Freeze_Entity): Add special case to avoid freezing when a freeze\n+\tnode gets generated as part of the expansion of a postcondition\n+\tcheck.\n+\t* gen_il-gen-gen_nodes.adb: Add new flag\n+\tComes_From_Check_Or_Contract.\n+\t* gen_il-fields.ads: Add new field Wrapped_Statements. Add new\n+\tflag Comes_From_Check_Or_Contract.\n+\t* gen_il-gen-gen_entities.adb: Add new field Wrapped_Statements.\n+\t* ghost.adb\n+\t(Is_OK_Declaration): Replace Name_uPostconditions with\n+\tName_uWrapped_Statements.\n+\t(Is_OK_Statement): Simplify condition due to the loss of\n+\tOriginal_Node as a result of the new expansion model of contracts\n+\tand use new flag Comes_From_Check_Or_Contract in its place.\n+\t* inline.adb\n+\t(Declare_Postconditions_Result): Replace Name_uPostconditions with\n+\tName_uWrapped_Statements.\n+\t(Expand_Inlined_Call): Replace Name_uPostconditions with\n+\tName_uWrapped_Statements.\n+\t* lib.adb, lib.ads\n+\t(ipu): Created to aid in debugging.\n+\t* lib-xref.adb\n+\t(Generate_References): Remove special handling for postcondition\n+\tprocedures.\n+\t* sem_attr.adb\n+\t(Analyze_Attribute_Old_Result): Add new context in which 'Old can\n+\tappear due to the changes in expansion. Replace\n+\tName_uPostconditions with Name_uWrapped_Statements.\n+\t(Result): Replace Name_uPostconditions with\n+\tName_uWrapped_Statements.\n+\t* sem_ch11.adb\n+\t(Analyze_Handled_Statements): Remove check to exclude warnings on\n+\tuseless assignments within postcondition procedures since\n+\tpostconditions no longer get isolated into separate subprograms.\n+\t* sem_ch6.adb\n+\t(Analyze_Generic_Subprogram_Body): Modify expansion of generic\n+\tsubprogram bodies so that contracts (and their associated pragmas)\n+\tget analyzed first.\n+\t(Analyze_Subprogram_Body_Helper): Remove global HSS variable due\n+\tto the HSS of the body potentially changing during the expansion\n+\tof contracts. In cases where it was used instead directly call\n+\tHandled_Statement_Sequence. Modify expansion of subprogram bodies\n+\tso that contracts (and their associated pragmas) get analyzed\n+\tfirst.\n+\t(Check_Missing_Return): Create local HSS variable instead of using\n+\ta global one.\n+\t(Move_Pragmas): Use new pragma table instead of an explicit list.\n+\t* sem_elab.adb\n+\t(Is_Postconditions_Proc): Deleted since the new scheme of\n+\texpansion no longer divides postcondition checks to a separate\n+\tsubprogram and so cannot be easily identified (similar to\n+\tpre-condition checks).\n+\t(Info_Call): Remove info printing for _Postconditions subprograms.\n+\t(Is_Assertion_Pragma_Target): Remove check for postconditions\n+\tprocedure\n+\t(Is_Bridge_Target): Remove check for postconditions procedure.\n+\t(Get_Invocation_Attributes): Remove unneeded local variables and\n+\tcheck for postconditions procedure.\n+\t(Output_Call): Remove info printing for _Postconditions\n+\tsubprograms.\n+\t* sem_prag.adb, sem_prag.ads: Add new Pragma table for pragmas\n+\tsignificant to subprograms, along with tech-debt comment.\n+\t(Check_Arg_Is_Local_Name): Modified to recognize the new\n+\t_Wrapped_Statements internal subprogram and the new expansion\n+\tmodel.\n+\t(Relocate_Pragmas_To_Body): Replace Name_uPostconditions with\n+\tName_uWrapped_Statements.\n+\t* sem_res.adb\n+\t(Resolve_Entry_Call): Add conditional to detect both contract\n+\tbased wrappers of entries, but also wrappers generated as part of\n+\tgeneral contract expansion (e.g. local postconditions\n+\tsubprograms).\n+\t* sem_util.adb\n+\t(Accessibility_Level): Verify 'Access is not taken based on a\n+\tcomponent of a function result.\n+\t(Has_Significant_Contracts): Replace Name_uPostconditions with\n+\tName_uWrapped_Statements.\n+\t(Same_Or_Aliased_Subprogram): Add conditional to detect and obtain\n+\tthe original subprogram based on the new concept of\n+\t\"postcondition\" wrappers.\n+\t* sinfo.ads: Add documentation for new flag\n+\tComes_From_Check_Or_Contract.\n+\t* snames.ads-tmpl: Remove Name_uPostconditions and add\n+\tName_uWrapped_Statements\n+\n+2022-09-12  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* exp_unst.adb (Unnest_Subprograms.Search_Subprograms): Skip the\n+\tsubprogram bodies that are not to be unnested.\n+\n+2022-09-12  Steve Baird  <baird@adacore.com>\n+\n+\t* sem_aggr.adb\n+\t(Resolve_Array_Aggregate): Generate an appropriate error message\n+\tin the case where an error in the source code leads to an\n+\tN_Iterated_Element_Association node in a bad context.\n+\n+2022-09-12  Steve Baird  <baird@adacore.com>\n+\n+\t* sem_ch4.adb\n+\t(Analyze_Selected_Component): Initialize the local variable Comp\n+\tto avoid having CodePeer generate an uninitialized variable\n+\twarning.\n+\n+2022-09-12  Steve Baird  <baird@adacore.com>\n+\n+\t* sem_ch4.adb\n+\t(Analyze_Selected_Component): Avoid initializing the local\n+\tvariable Comp if the variable is not going to be subsequently\n+\treferenced. This is a correctness issue because the call to\n+\tFirst_Entity can fail.\n+\n+2022-09-12  Steve Baird  <baird@adacore.com>\n+\n+\t* sem_ch9.adb\n+\t(Satisfies_Lock_Free_Requirements): If Ceiling_Locking locking\n+\tpolicy has been specified, then either return False (if Lock_Free\n+\twas not explicitly specified) or generate a warning that ceiling\n+\tlocking will not be implemented for this protected unit (if\n+\tLock_Free was explicitly specified). Generate an error message (in\n+\taddition to returning False) if an explicit Lock_Free aspect\n+\tspecification is rejected because atomic primitives are not\n+\tsupported on the given target.\n+\t* doc/gnat_rm/implementation_defined_pragmas.rst: Clarify that the\n+\tLock_Free aspect for a protected unit takes precedence over the\n+\tCeiling_Locking locking policy in the case where both apply.\n+\t* gnat_rm.texi: Regenerate.\n+\n+2022-09-12  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* exp_ch9.adb (Build_Protected_Spec): Tidy up and propagate the\n+\tComes_From_Source flag onto the new formal parameters.\n+\t* sem_ch6.adb (Analyze_Subprogram_Body_Helper): Do not check\n+\treferences for subprograms generated for protected subprograms.\n+\n+2022-09-12  Gary Dismukes  <dismukes@adacore.com>\n+\n+\t* sem_res.adb\n+\t(Resolve_Equality_Op): Add handling for equality ops with\n+\tuser-defined literal operands.\n+\t* sem_util.ads\n+\t(Is_User_Defined_Literal): Update spec comment to indicate\n+\tinclusion of named number cases.\n+\t* sem_util.adb\n+\t(Corresponding_Primitive_Op): Rather than following the chain of\n+\tancestor subprograms via Alias and Overridden_Operation links, we\n+\tcheck for matching profiles between primitive subprograms of the\n+\tdescendant type and the ancestor subprogram (by calling a new\n+\tnested function Profile_Matches_Ancestor). This prevents the\n+\tcompiler from hanging due to circular linkages via those fields\n+\tthat can occur between inherited and overriding subprograms\n+\t(which might indicate a latent bug, but one that may be rather\n+\tdelicate to resolve).\n+\t(Profile_Matches_Ancestor): New nested subprogram to compare the\n+\tprofile of a primitive subprogram with the profile of a candidate\n+\tancestor subprogram.\n+\t(Is_User_Defined_Literal): Also return True in cases where the\n+\tnode N denotes a named number (E_Name_Integer and E_Named_Real).\n+\n+2022-09-12  Steve Baird  <baird@adacore.com>\n+\n+\t* debug.adb: remove a comment.\n+\n+2022-09-12  Bob Duff  <duff@adacore.com>\n+\n+\t* checks.adb\n+\t(Selected_Length_Checks): In the message for an aggregate that has\n+\ttoo few or too many elements, add \"!!\" to make sure the warning\n+\tgets printed in with'ed units. Note that we have to put \"!!\"\n+\tbefore the \"??\", because Compile_Time_Constraint_Error detects\n+\twarnings by comparing the last character of the message with '?'\n+\t(which is bit dubious, but we're not changing that here).\n+\t(Length_Mismatch_Info_Message): Use Unat for some things that\n+\tcan't be negative. Specify Decimal instead of Auto in calls to\n+\tUI_Image.\n+\t* sem_util.adb\n+\t(Compile_Time_Constraint_Error): Minor.\n+\t* uintp.adb\n+\t(Image_Uint): It's always better to initialize objects on their\n+\tdeclaration.\n+\n+2022-09-12  Patrick Bernardi  <bernardi@adacore.com>\n+\n+\t* libgnat/system-vxworks7-x86_64-kernel.ads: Set\n+\tSupport_Atomic_Primitives to false.\n+\t* libgnat/system-vxworks7-x86_64-rtp-smp.ads: Ditto.\n+\n+2022-09-12  Patrick Bernardi  <bernardi@adacore.com>\n+\n+\t* libgnat/system-qnx-arm.ads: Set Support_Atomic_Primitives to\n+\tfalse.\n+\t* libgnat/system-vxworks7-aarch64.ads: Ditto.\n+\t* libgnat/system-vxworks7-aarch64-rtp-smp.ads: Ditto.\n+\t* libgnat/system-vxworks7-arm.ads: Ditto.\n+\t* libgnat/system-vxworks7-arm-rtp-smp.ads: Ditto.\n+\t* libgnat/system-vxworks7-x86-kernel.ads: Ditto.\n+\t* libgnat/system-vxworks7-x86-rtp-smp.ads: Ditto.\n+\n+2022-09-12  Bob Duff  <duff@adacore.com>\n+\n+\t* par-tchk.adb, par-util.adb, prep.adb, prepcomp.adb, scng.adb:\n+\tUse \"in\" instead of chains of \"=\" connected with \"or else\".\n+\tLikewise for \"not in\", \"/=\", \"and then\". Misc cleanup.\n+\t* par-ch10.adb, par-ch12.adb, par-ch13.adb, par-ch4.adb: Likewise.\n+\t* par-ch8.adb, par-ch9.adb, par-endh.adb, par-sync.adb: Likewise.\n+\t* par.adb\n+\t(Pf_Rec): Remove filler, which was added August 25, 1993 to get\n+\taround a compiler limitation that no longer exists. Minor cleanup.\n+\tRemove useless qualfications.\n+\t* par-ch3.adb: Remove redundant return statements.\n+\t(Component_Scan_Loop): Remove loop name; there are no nested\n+\tloops, so it's unnecessary and possibly misleading, and it causes\n+\ttoo-long lines.\n+\t* par-ch5.adb: DRY: Remove comments that repeat the comments in\n+\tpar.adb.\n+\t(P_Sequence_Of_Statements): It is better to initialize things on\n+\tthe declaration. And constants are better than variables.\n+\t(Test_Statement_Required): Remove unnecessary insertion of a null\n+\tstatement.\n+\t* par-ch6.adb, par-ch7.adb: DRY: Remove comments that repeat the\n+\tcomments in par.adb.\n+\n+2022-09-12  Javier Miranda  <miranda@adacore.com>\n+\n+\tRevert:\n+\t2022-09-06  Javier Miranda  <miranda@adacore.com>\n+\n+\t* debug.adb\n+\t(Debug_Flag_Underscore_X): Switch added temporarily to allow\n+\tdisabling extra formal checks.\n+\t* exp_attr.adb\n+\t(Expand_N_Attribute_Reference [access types]): Add extra formals\n+\tto the subprogram referenced in the prefix of 'Unchecked_Access,\n+\t'Unrestricted_Access or 'Access; required to check that its extra\n+\tformals match the extra formals of the corresponding subprogram\n+\ttype.\n+\t* exp_ch3.adb\n+\t(Stream_Operation_OK): Declaration moved to the public part of the\n+\tpackage.\n+\t(Validate_Tagged_Type_Extra_Formals): New subprogram.\n+\t(Expand_Freeze_Record_Type): Improve the code that takes care of\n+\tadding the extra formals of dispatching primitives; extended to\n+\tadd also the extra formals to renamings of dispatching primitives.\n+\t* exp_ch3.ads\n+\t(Stream_Operation_OK): Declaration moved from the package body.\n+\t* exp_ch6.adb\n+\t(Has_BIP_Extra_Formal): Subprogram declaration moved to the public\n+\tpart of the package. In addition, a parameter has been added to\n+\tdisable an assertion that requires its use with frozen entities.\n+\t(Expand_Call_Helper): Enforce assertion checking extra formals on\n+\tthunks.\n+\t(Is_Build_In_Place_Function): Return False for entities with\n+\tforeign convention.\n+\t(Make_Build_In_Place_Call_In_Object_Declaration): Occurrences of\n+\tIs_Return_Object replaced by the local variable\n+\tIs_OK_Return_Object that evaluates to False for scopes with\n+\tforeign convention.\n+\t(Might_Have_Tasks): Fix check of class-wide limited record types.\n+\t(Needs_BIP_Task_Actuals): Remove assertion to allow calling this\n+\tfunction in more contexts; in addition it returns False for\n+\tfunctions returning objects with foreign convention.\n+\t(Needs_BIP_Finalization_Master): Likewise.\n+\t(Needs_BIP_Alloc_Form): Likewise.\n+\t* exp_ch6.ads\n+\t(Stream_Operation_OK): Declaration moved from the package body. In\n+\taddition, a parameter has been added to disable assertion that\n+\trequires its use with frozen entities.\n+\t* freeze.adb\n+\t(Check_Itype): Add extra formals to anonymous access subprogram\n+\titypes.\n+\t(Freeze_Expression): Improve code that disables the addition of\n+\textra formals to functions with foreign convention.\n+\t(Check_Extra_Formals): Moved to package Sem_Ch6 as\n+\tExtra_Formals_OK.\n+\t(Freeze_Subprogram): Add extra formals to non-dispatching\n+\tsubprograms.\n+\t* sem_ch3.adb\n+\t(Access_Subprogram_Declaration): Defer the addition of extra\n+\tformals to the freezing point so that we know the convention.\n+\t(Check_Anonymous_Access_Component): Likewise.\n+\t(Derive_Subprogram): Fix documentation.\n+\t* sem_ch6.adb\n+\t(Check_Anonymous_Return): Fix check of access to class-wide\n+\tlimited record types.\n+\t(Check_Untagged_Equality): Placed in alphabetical order.\n+\t(Extra_Formals_OK): Subprogram moved from freeze.adb.\n+\t(Extra_Formals_Match_OK): New subprogram.\n+\t(Has_BIP_Formals): New subprogram.\n+\t(Has_Extra_Formals): New subprograms.\n+\t(Needs_Accessibility_Check_Extra): New subprogram.\n+\t(Needs_Constrained_Extra): New subprogram.\n+\t(Parent_Subprogram): New subprogram.\n+\t(Add_Extra_Formal): Minor code cleanup.\n+\t(Create_Extra_Formals): Enforce matching extra formals on\n+\toverridden and aliased entities.\n+\t(Has_Reliable_Extra_Formals): New subprogram.\n+\t* sem_ch6.ads\n+\t(Extra_Formals_OK): Subprogram moved from freeze.adb.\n+\t(Extra_Formals_Match_OK): New subprogram.\n+\t* sem_eval.adb\n+\t(Compile_Time_Known_Value): Improve predicate to avoid assertion\n+\tfailure; found working on this ticket; this change does not affect\n+\tthe behavior of the compiler because this subprogram has an\n+\texception handler that returns False when the assertion fails.\n+\t* sem_util.adb\n+\t(Needs_Result_Accessibility_Level): Do not return False for\n+\tdispatching operations compiled with Ada_Version < 2012 since they\n+\tthey may be overridden by primitives compiled with Ada_Version >=\n+\tAda_2012.\n+\n+2022-09-06  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.cc (gnat_to_gnu_param): Set DECL_ARTIFICIAL.\n+\n+2022-09-06  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/trans.cc (At_End_Proc_to_gnu): Use the End_Label of\n+\tthe child Handled_Statement_Sequence for body nodes.\n+\t(set_end_locus_from_node): Minor tweaks.\n+\n+2022-09-06  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/trans.cc (Full_View_Of_Private_Constant): New\n+\tfunction returning the Full_View of a private constant, after\n+\tlooking through a chain of renamings, if any.\n+\t(Identifier_to_gnu): Call it on the entity.  Small cleanup.\n+\n+2022-09-06  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/utils.cc (gnat_pushdecl): Preserve named\n+\tTYPE_DECLs consistently for all kind of pointer types.\n+\n+2022-09-06  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/trans.cc (gnat_to_gnu) <N_Op_Divide>: Report a\n+\tviolation of No_Dependence on System.GCC if the result type is\n+\tlarger than a word.\n+\t<N_Op_Shift>: Likewise.\n+\t<N_Op_Mod>: Likewise.\n+\t<N_Op_Rem>: Likewise.\n+\t(convert_with_check): Report a violation of No_Dependence on\n+\tSystem.GCC for a conversion between an integer type larger than\n+\ta word and a floating-point type.\n+\n+2022-09-06  Steve Baird  <baird@adacore.com>\n+\n+\t* sem_ch9.adb\n+\t(Allows_Lock_Free_Implementation): Return False if\n+\tSupport_Atomic_Primitives is False.\n+\n+2022-09-06  Steve Baird  <baird@adacore.com>\n+\n+\t* debug.adb: Remove comment regarding the -gnatd9 switch.\n+\t* doc/gnat_rm/implementation_defined_attributes.rst: Remove all\n+\tmention of the Lock_Free attribute.\n+\t* gnat_rm.texi, gnat_ugn.texi: Regenerate.\n+\t* exp_attr.adb, sem_attr.adb: Remove all mention of the former\n+\tAttribute_Lock_Free enumeration element of the Attribute_Id type.\n+\t* sem_ch9.adb\n+\t(Allows_Lock_Free_Implementation): Remove the Debug_Flag_9 test.\n+\tReturn False in the case of a protected function whose result type\n+\trequires use of the secondary stack.\n+\t(Satisfies_Lock_Free_Requirements): This functions checks for\n+\tcertain constructs and returns False if one is found. In the case\n+\tof a protected function, there is no need to check to see if the\n+\tprotected object is being modified. So it is ok to omit *some*\n+\tchecks in the case of a protected function. But other checks which\n+\tare required (e.g., the test for a reference to a variable that is\n+\tnot part of the protected object) were being incorrectly omitted.\n+\tThis could result in accepting \"Lock_Free => True\" aspect\n+\tspecifications that should be rejected.\n+\t* snames.adb-tmpl: Name_Lock_Free no longer requires special\n+\ttreatment in Get_Pragma_Id or Is_Pragma_Name (because it is no\n+\tlonger an attribute name).\n+\t* snames.ads-tmpl: Move the declaration of Name_Lock_Free to\n+\treflect the fact that it is no longer the name of an attribute.\n+\tDelete Attribute_Lock_Free from the Attribute_Id enumeration type.\n+\n+2022-09-06  Steve Baird  <baird@adacore.com>\n+\n+\t* libgnat/a-coorse.ads: Restore Aggregate aspect specification for\n+\ttype Set.\n+\n+2022-09-06  Marc Poulhi\u00e8s  <poulhies@adacore.com>\n+\n+\t* exp_util.adb (Build_Allocate_Deallocate_Proc): Add\n+\tAlignment_Param in the formal list for calls to SS_Allocate.\n+\n+2022-09-06  Piotr Trojanek  <trojanek@adacore.com>\n+\n+\t* inline.adb (Process_Formals): Preserve Has_Private_View flag while\n+\trewriting formal into actual parameters.\n+\n+2022-09-06  Javier Miranda  <miranda@adacore.com>\n+\n+\t* debug.adb\n+\t(Debug_Flag_Underscore_X): Switch added temporarily to allow\n+\tdisabling extra formal checks.\n+\t* exp_attr.adb\n+\t(Expand_N_Attribute_Reference [access types]): Add extra formals\n+\tto the subprogram referenced in the prefix of 'Unchecked_Access,\n+\t'Unrestricted_Access or 'Access; required to check that its extra\n+\tformals match the extra formals of the corresponding subprogram\n+\ttype.\n+\t* exp_ch3.adb\n+\t(Stream_Operation_OK): Declaration moved to the public part of the\n+\tpackage.\n+\t(Validate_Tagged_Type_Extra_Formals): New subprogram.\n+\t(Expand_Freeze_Record_Type): Improve the code that takes care of\n+\tadding the extra formals of dispatching primitives; extended to\n+\tadd also the extra formals to renamings of dispatching primitives.\n+\t* exp_ch3.ads\n+\t(Stream_Operation_OK): Declaration moved from the package body.\n+\t* exp_ch6.adb\n+\t(Has_BIP_Extra_Formal): Subprogram declaration moved to the public\n+\tpart of the package. In addition, a parameter has been added to\n+\tdisable an assertion that requires its use with frozen entities.\n+\t(Expand_Call_Helper): Enforce assertion checking extra formals on\n+\tthunks.\n+\t(Is_Build_In_Place_Function): Return False for entities with\n+\tforeign convention.\n+\t(Make_Build_In_Place_Call_In_Object_Declaration): Occurrences of\n+\tIs_Return_Object replaced by the local variable\n+\tIs_OK_Return_Object that evaluates to False for scopes with\n+\tforeign convention.\n+\t(Might_Have_Tasks): Fix check of class-wide limited record types.\n+\t(Needs_BIP_Task_Actuals): Remove assertion to allow calling this\n+\tfunction in more contexts; in addition it returns False for\n+\tfunctions returning objects with foreign convention.\n+\t(Needs_BIP_Finalization_Master): Likewise.\n+\t(Needs_BIP_Alloc_Form): Likewise.\n+\t* exp_ch6.ads\n+\t(Stream_Operation_OK): Declaration moved from the package body. In\n+\taddition, a parameter has been added to disable assertion that\n+\trequires its use with frozen entities.\n+\t* freeze.adb\n+\t(Check_Itype): Add extra formals to anonymous access subprogram\n+\titypes.\n+\t(Freeze_Expression): Improve code that disables the addition of\n+\textra formals to functions with foreign convention.\n+\t(Check_Extra_Formals): Moved to package Sem_Ch6 as\n+\tExtra_Formals_OK.\n+\t(Freeze_Subprogram): Add extra formals to non-dispatching\n+\tsubprograms.\n+\t* sem_ch3.adb\n+\t(Access_Subprogram_Declaration): Defer the addition of extra\n+\tformals to the freezing point so that we know the convention.\n+\t(Check_Anonymous_Access_Component): Likewise.\n+\t(Derive_Subprogram): Fix documentation.\n+\t* sem_ch6.adb\n+\t(Check_Anonymous_Return): Fix check of access to class-wide\n+\tlimited record types.\n+\t(Check_Untagged_Equality): Placed in alphabetical order.\n+\t(Extra_Formals_OK): Subprogram moved from freeze.adb.\n+\t(Extra_Formals_Match_OK): New subprogram.\n+\t(Has_BIP_Formals): New subprogram.\n+\t(Has_Extra_Formals): New subprograms.\n+\t(Needs_Accessibility_Check_Extra): New subprogram.\n+\t(Needs_Constrained_Extra): New subprogram.\n+\t(Parent_Subprogram): New subprogram.\n+\t(Add_Extra_Formal): Minor code cleanup.\n+\t(Create_Extra_Formals): Enforce matching extra formals on\n+\toverridden and aliased entities.\n+\t(Has_Reliable_Extra_Formals): New subprogram.\n+\t* sem_ch6.ads\n+\t(Extra_Formals_OK): Subprogram moved from freeze.adb.\n+\t(Extra_Formals_Match_OK): New subprogram.\n+\t* sem_eval.adb\n+\t(Compile_Time_Known_Value): Improve predicate to avoid assertion\n+\tfailure; found working on this ticket; this change does not affect\n+\tthe behavior of the compiler because this subprogram has an\n+\texception handler that returns False when the assertion fails.\n+\t* sem_util.adb\n+\t(Needs_Result_Accessibility_Level): Do not return False for\n+\tdispatching operations compiled with Ada_Version < 2012 since they\n+\tthey may be overridden by primitives compiled with Ada_Version >=\n+\tAda_2012.\n+\n+2022-09-06  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* exp_ch4.adb (Expand_N_If_Expression): Disable optimization\n+\tfor LLVM.\n+\n+2022-09-06  Javier Miranda  <miranda@adacore.com>\n+\n+\t* sem_prag.adb\n+\t(Analyze_Pre_Post_Condition_In_Decl_Part): Improve check to report\n+\tan error in non-legal class-wide conditions.\n+\n+2022-09-06  Steve Baird  <baird@adacore.com>\n+\n+\t* libgnat/a-strsup.adb, libgnat/a-stwisu.adb, libgnat/a-stzsup.adb\n+\t(Super_Slice function and procedure): fix slice length computation.\n+\n+2022-09-06  Steve Baird  <baird@adacore.com>\n+\n+\t* doc/gnat_ugn/building_executable_programs_with_gnat.rst:\n+\tImprove -gnatVa, -gnatVc, -gnatVd, -gnatVe, -gnatVf, -gnatVo,\n+\t-gnatVp, -gnatVr, and -gnatVs switch descriptions.\n+\t* gnat_ugn.texi: Regenerate.\n+\n+2022-09-06  Justin Squirek  <squirek@adacore.com>\n+\n+\t* exp_unst.adb\n+\t(Visit_Node): Add N_Block_Statement to the enclosing construct\n+\tcase since they can now have \"At end\" procedures. Also, recognize\n+\tcalls from \"At end\" procedures when recording subprograms.\n+\n+2022-09-06  Piotr Trojanek  <trojanek@adacore.com>\n+\n+\t* inline.adb (Replace_Formal): Fix name of the referenced routine.\n+\n+2022-09-06  Piotr Trojanek  <trojanek@adacore.com>\n+\n+\t* exp_attr.adb (Expand_N_Attribute_Reference [Attribute_Old]):\n+\tRemove unnecessary local constant that was shadowing another\n+\tconstant with the same initial value.\n+\n+2022-09-06  Julien Bortolussi  <bortolussi@adacore.com>\n+\n+\t* libgnat/a-cforse.ads (Replace): Fix the postcondition.\n+\n+2022-09-06  Steve Baird  <baird@adacore.com>\n+\n+\t* exp_attr.adb\n+\t(Attribute_Valid): Ensure that PBtyp is initialized to a value for\n+\twhich Is_Scalar_Type is True.\n+\t* checks.adb\n+\t(Determine_Range): Call Implemention_Base_Type instead of\n+\tBase_Type in order to ensure that result is suitable for passing\n+\tto Enum_Pos_To_Rep.\n+\n+2022-09-06  Bob Duff  <duff@adacore.com>\n+\t    Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gen_il-fields.ads\n+\t(First_Real_Statement): Remove this field.\n+\t* gen_il-gen-gen_nodes.adb: Remove the First_Real_Statement field.\n+\tAdd the At_End_Proc field to nodes that have both Declarations and\n+\tHSS.\n+\t* sinfo.ads\n+\t(At_End_Proc): Document new semantics.\n+\t(First_Real_Statement): Remove comment.\n+\t* exp_ch11.adb\n+\t(Expand_N_Handled_Sequence_Of_Statements): Remove\n+\tFirst_Real_Statement.\n+\t* exp_ch7.adb\n+\t(Build_Cleanup_Statements): Remove \"Historical note\"; it doesn't\n+\tseem useful, and we have revision history.\n+\t(Create_Finalizer): Insert the finalizer later, typically in the\n+\tstatement list, in some cases.\n+\t(Build_Finalizer_Call): Attach the \"at end\" handler to the parent\n+\tof the HSS node in most cases, so it applies to declarations.\n+\t(Expand_Cleanup_Actions): Remove Wrap_HSS_In_Block and the call to\n+\tit. Remove the code that moves declarations. Remove some redundant\n+\tcode.\n+\t* exp_ch9.adb\n+\t(Build_Protected_Entry): Copy the At_End_Proc.\n+\t(Build_Protected_Subprogram_Body): Reverse the sense of Exc_Safe,\n+\tto avoid double negatives. Remove \"Historical note\" as in\n+\texp_ch7.adb.\n+\t(Build_Unprotected_Subprogram_Body): Copy the At_End_Proc from the\n+\tprotected version.\n+\t(Expand_N_Conditional_Entry_Call): Use First (Statements(...))\n+\tinstead of First_Real_Statement(...).\n+\t(Expand_N_Task_Body): Put the Abort_Undefer call at the beginning\n+\tof the declarations, rather than in the HSS. Use First\n+\t(Statements(...)) instead of First_Real_Statement(...). Copy the\n+\tAt_End_Proc.\n+\t* inline.adb\n+\t(Has_Initialized_Type): Return False if the declaration does not\n+\tcome from source.\n+\t* libgnarl/s-tpoben.ads\n+\t(Lock_Entries, Lock_Entries_With_Status): Document when these\n+\tthings raise Program_Error. It's not clear that\n+\tLock_Entries_With_Status ought to be raising exceptions, but at\n+\tleast it's documented now.\n+\t* sem.ads: Minor comment fixes.\n+\t* sem_ch6.adb\n+\t(Analyze_Subprogram_Body_Helper): Use First (Statements(...))\n+\tinstead of First_Real_Statement(...).\n+\t(Analyze_Null_Procedure): Minor comment fix.\n+\t* sem_util.adb\n+\t(Might_Raise): Return True for N_Raise_Expression. Adjust the part\n+\tabout exceptions generated by the back end to match the reality of\n+\twhat the back end generates.\n+\t(Update_First_Real_Statement): Remove.\n+\t* sem_util.ads: Remove First_Real_Statement from comment.\n+\t* sinfo-utils.ads\n+\t(First_Real_Statement): New function that always returns Empty.\n+\tThis should be removed once gnat-llvm and codepeer have been\n+\tupdated to not refer to First_Real_Statement.\n+\t* sprint.adb\n+\t(Sprint_At_End_Proc): Deal with printing At_End_Proc.\n+\t* sem_prag.adb: Minor comment fixes.\n+\t* gcc-interface/trans.cc (At_End_Proc_to_gnu): New function.\n+\t(Subprogram_Body_to_gnu): Call it to handle an At_End_Proc.\n+\t(Handled_Sequence_Of_Statements_to_gnu): Likewise. Remove the\n+\tsupport for First_Real_Statement and clean up the rest.\n+\t(Exception_Handler_to_gnu): Do not push binding levels.\n+\t(Compilation_Unit_to_gnu): Adjust call to process_decls.\n+\t(gnat_to_gnu) <N_Package_Specification>: Likewise. <N_Entry_Body>:\n+\tLikewise. <N_Freeze_Entity>: Likewise. <N_Block_Statement>:\n+\tLikewise and call At_End_Proc_to_gnu to handle an At_End_Proc.\n+\t<N_Package_Body>: Likewise.\n+\t(process_decls): Remove GNAT_END_LIST parameter and adjust\n+\trecursive calls.\n+\n+2022-09-06  Steve Baird  <baird@adacore.com>\n+\n+\t* doc/gnat_rm/implementation_defined_pragmas.rst: Document new\n+\ttemporary rule that a \"when others =>\" case choice must be given\n+\twhen casing on a composite selector.\n+\t* gnat_rm.texi: Regenerate.\n+\n+2022-09-06  Steve Baird  <baird@adacore.com>\n+\n+\t* sem_case.adb: Define a new Boolean constant,\n+\tSimplified_Composite_Coverage_Rules, initialized to True. Setting\n+\tthis constant to True has two effects: 1- Representative value\n+\tsets are not fully initialized - this is done to avoid capacity\n+\tproblems, as well as for performance. 2- In\n+\tCheck_Case_Pattern_Choices, the only legality check performed is a\n+\tcheck that a \"when others =>\" choice is present.\n+\n+2022-09-06  Piotr Trojanek  <trojanek@adacore.com>\n+\n+\t* sem_ch13.adb (Analyze_Aspect_Relaxed_Initialization): Fix error\n+\ttemplate.\n+\n+2022-09-06  Steve Baird  <baird@adacore.com>\n+\n+\t* exp_attr.adb\n+\t(Make_Range_Test): In determining which subtype's First and Last\n+\tattributes are to be queried as part of a range test, call\n+\tValidated_View in order to get a scalar (as opposed to private)\n+\tsubtype.\n+\t(Attribute_Valid): In determining whether to perform a signed or\n+\tunsigned comparison for a range test, call Validated_View in order\n+\tto get a scalar (as opposed to private) type. Also correct a typo\n+\twhich, by itself, is the source of the problem reported for this\n+\tticket.\n+\n+2022-09-06  Steve Baird  <baird@adacore.com>\n+\n+\t* sem_ch4.adb\n+\t(Analyze_Selected_Component): Define new Boolean-valued function,\n+\tConstraint_Has_Unprefixed_Discriminant_Reference, which takes a\n+\tsubtype that is subject to a discriminant-dependent constraint and\n+\treturns True if any of the constraint values are unprefixed\n+\tdiscriminant names. Usually, the Etype of a selected component\n+\tnode is set to Etype of the component. However, in the case of an\n+\taccess-to-array component for which this predicate returns True,\n+\twe instead use the base type of the Etype of the component.\n+\tNormally such problematic discriminant references are addressed by\n+\tcalling Build_Actual_Subtype_Of_Component, but that doesn't work\n+\tif Full_Analyze is False.\n+\n+2022-09-06  Piotr Trojanek  <trojanek@adacore.com>\n+\n+\t* Makefile.rtl (GNATRTL_NONTASKING_OBJS): Include\n+\tSystem.Value_U_Spec and System.Value_I_Spec units.\n+\n+2022-09-06  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* libgnat/s-powflt.ads (Powfive): New constant array.\n+\t* libgnat/s-powlfl.ads (Powfive): Likewise.\n+\t(Powfive_100): New constant.\n+\t(Powfive_200): Likewise.\n+\t(Powfive_300): Likewise.\n+\t* libgnat/s-powllf.ads (Powfive): New constant array.\n+\t(Powfive_100): New constant.\n+\t(Powfive_200): Likewise.\n+\t(Powfive_300): Likewise.\n+\t* libgnat/s-valflt.ads (Impl): Replace Powten with Powfive and pass\n+\tNull_Address for the address of large constants.\n+\t* libgnat/s-vallfl.ads (Impl): Replace Powten with Powfive and pass\n+\tthe address of large constants.\n+\t* libgnat/s-valllf.ads (Impl): Likewise.\n+\t* libgnat/s-valrea.ads (System.Val_Real): Replace Powten_Address\n+\twith Powfive_Address and add Powfive_{1,2,3}00_Address parameters.\n+\t* libgnat/s-valrea.adb (Is_Large_Type): New boolean constant.\n+\t(Is_Very_Large_Type): Likewise.\n+\t(Maxexp32): Change value of 10 to that of 5.\n+\t(Maxexp64): Likewise.\n+\t(Maxexp80): Likewise.\n+\t(Integer_to_Real): Use a combination of tables of powers of 5 and\n+\tscaling if the base is 10.\n+\t(Large_Powten): Rename into...\n+\t(Large_Powfive): ...this.  Add support for large constants.\n+\t(Large_Powfive): New overloaded function for very large exponents.\n+\n+2022-09-06  Piotr Trojanek  <trojanek@adacore.com>\n+\n+\t* doc/gnat_rm/implementation_defined_aspects.rst\n+\t(Aspect Iterable): Include Last and Previous primitives in\n+\tsyntactic and semantic description.\n+\t* exp_attr.adb\n+\t(Expand_N_Attribute_Reference): Don't expect attributes like\n+\tIterable that can only appear in attribute definition clauses.\n+\t* sem_ch13.adb\n+\t(Analyze_Attribute_Definition_Clause): Prevent crash on\n+\tnon-aggregate Iterable attribute; improve basic diagnosis of\n+\tattribute values.\n+\t(Resolve_Iterable_Operation): Improve checks for illegal\n+\tprimitives in aspect Iterable, e.g. with wrong number of formal\n+\tparameters.\n+\t(Validate_Iterable_Aspect): Prevent crashes on syntactically\n+\tillegal aspect expression.\n+\t* sem_util.adb\n+\t(Get_Cursor_Type): Fix style.\n+\t* gnat_ugn.texi, gnat_rm.texi: Regenerate.\n+\n+2022-09-06  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* libgnat/s-valuer.ads (System.Value_R): Add Parts formal parameter\n+\tas well as Data_Index, Scale_Array and Value_Array types.\n+\t(Scan_Raw_Real): Change type of Scale and return type.\n+\t(Value_Raw_Real): Likewise.\n+\t* libgnat/s-valuer.adb (Round_Extra): Reorder parameters and adjust\n+\trecursive call.\n+\t(Scan_Decimal_Digits): Reorder parameters, add N parameter and deal\n+\twith multi-part scale and value.\n+\t(Scan_Integral_Digits): Likewise.\n+\t(Scan_Raw_Real): Change type of Scale and return type and deal with\n+\tmulti-part scale and value.\n+\t(Value_Raw_Real): Change type of Scale and return type and tidy up.\n+\t* libgnat/s-valued.adb (Impl): Pass 1 as Parts actual parameter.\n+\t(Scan_Decimal): Adjust to type changes.\n+\t(Value_Decimal): Likewise.\n+\t* libgnat/s-valuef.adb (Impl): Pass 1 as Parts actual parameter.\n+\t(Scan_Fixed): Adjust to type changes.\n+\t(Value_Fixed): Likewise.\n+\t* libgnat/s-valrea.adb (Need_Extra): Delete.\n+\t(Precision_Limit): Always use the precision of the mantissa.\n+\t(Impl): Pass 2 as Parts actual parameter.\n+\t(Exact_Log2): New expression function.\n+\t(Integer_to_Real): Change type of Scale and Val and deal with a\n+\t2-part integer mantissa.\n+\t(Scan_Real): Adjust to type changes.\n+\t(Value_Real): Likewise.\n+\n+2022-09-05  Martin Liska  <mliska@suse.cz>\n+\n+\t* sigtramp-vxworks-target.h: Rename DBX_REGISTER_NUMBER to\n+\t  DEBUGGER_REGNO.\n+\n+2022-09-05  Piotr Trojanek  <trojanek@adacore.com>\n+\n+\t* exp_aggr.adb (Check_Bounds): Move code and comment related to\n+\tcheck for null array aggregate from Resolve_Null_Array_Aggregate.\n+\t* sem_aggr.ads (Is_Null_Aggregate): Move spec from unit body.\n+\t* sem_aggr.adb (Resolve_Null_Array_Aggregate): Move check to\n+\texpansion.\n+\n+2022-09-05  Piotr Trojanek  <trojanek@adacore.com>\n+\n+\t* sem_aggr.adb\n+\t(Array_Aggr_Subtype): Bypass call to Collect_Aggr_Bound with\n+\tdedicated code for null array aggregates.\n+\t(Resolve_Array_Aggregate): Remove special handling of null array\n+\taggregates.\n+\t(Resolve_Array_Aggregate): Create bounds, but let\n+\tArray_Aggr_Subtype create itype entities.\n+\n+2022-09-05  Piotr Trojanek  <trojanek@adacore.com>\n+\n+\t* sem_aggr.adb (Resolve_Null_Array_Aggregate): Insert check as a\n+\tRaise_Constraint_Error node and not an If_Statement.\n+\n+2022-09-05  Piotr Trojanek  <trojanek@adacore.com>\n+\n+\t* sem_aggr.adb\n+\t(Resolve_Container_Aggregate): Style cleanup.\n+\t(Resolve_Record_Aggregate): Remove redundant guard.\n+\n+2022-09-05  Piotr Trojanek  <trojanek@adacore.com>\n+\n+\t* exp_util.ads (Entry_Names_OK): Remove spec.\n+\t* exp_util.adb (Entry_Names_OK): Remove body.\n+\n+2022-09-05  Steve Baird  <baird@adacore.com>\n+\n+\t* libgnat/a-coinve.adb, libgnat/a-convec.adb\n+\t(Append): If the Append that takes an Element and a Count is\n+\tcalled with Count = 1, then call the Append that does not take a\n+\tCount parameter; otherwise call the code that handles the general\n+\tcase. Move the special case detection/handling code that was\n+\tformerly in that version of Append into the version that does not\n+\ttake a Count parameter, so that now both versions get the\n+\tperformance benefit.\n+\n+2022-09-05  Piotr Trojanek  <trojanek@adacore.com>\n+\n+\t* sem_aggr.adb (Resolve_Null_Array_Aggregate): Create internal\n+\ttype for the aggregate as an itype.\n+\n+2022-09-05  Piotr Trojanek  <trojanek@adacore.com>\n+\n+\t* sem_util.ads (Itype_Has_Declaration): Remove spec.\n+\t* sem_util.adb (Itype_Has_Declaration): Remove body.\n+\n+2022-09-05  Steve Baird  <baird@adacore.com>\n+\n+\t* exp_ch3.adb\n+\t(Expand_N_Object_Declaration): In deciding whether to emit a DIC\n+\tcheck, we were previously testing the Has_Init_Expression flag.\n+\tContinue to test that flag as before, but add a test for the\n+\tsyntactic presence of an initial value in the object declaration.\n+\tThis new test would not supersede the old test in the case where\n+\tan explicit initial value has been eliminated as part of some tree\n+\ttransformation.\n+\n+2022-09-05  Piotr Trojanek  <trojanek@adacore.com>\n+\n+\t* sem_ch13.adb (Validate_Unchecked_Conversions): Use\n+\tHas_Warnings_Off.\n+\t* sem_elab.adb (Check_Internal_Call_Continue): Likewise.\n+\n+2022-09-05  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* libgnat/s-valuer.adb (Scan_Decimal_Digits): Consistently avoid\n+\tinitializing local variables.\n+\t(Scan_Integral_Digits): Likewise.\n+\t(Scan_Raw_Real): Likewise and add a couple of comments.\n+\n+2022-09-05  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* sem_ch13.adb (Freeze_Entity_Checks): Build predicate functions\n+\tonly after checking the variant part of a record type, if any.\n+\n+2022-09-05  Piotr Trojanek  <trojanek@adacore.com>\n+\n+\t* exp_aggr.adb\n+\t(Two_Pass_Aggregate_Expansion): Expand into implicit rather than\n+\tordinary loops, to detect violations of restriction\n+\tNo_Implicit_Loops.\n+\t(Generate_Loop): Likewise for delta array aggregates.\n+\n+2022-09-05  Piotr Trojanek  <trojanek@adacore.com>\n+\n+\t* exp_aggr.adb (Two_Pass_Aggregate_Expansion): Expand iterated\n+\tcomponent association with an unanalyzed copy of iterated\n+\texpression. The previous code worked only because the expanded\n+\tloop used both an analyzed copy of the iterator_specification and\n+\tan analyzed copy of the iterated expression. Now the iterated\n+\texpression is reanalyzed in the context of the expanded loop.\n+\t* par-ch4.adb (Build_Iterated_Component_Association): Don't set\n+\tdefining identifier when iterator specification is present.\n+\t* sem_aggr.adb (Resolve_Iterated_Association): Pick index name\n+\tfrom the iterator specification.\n+\t* sem_elab.adb (Traverse_Potential_Scenario): Handle iterated\n+\telement association just like iterated component association. Not\n+\tstrictly part of this fix, but still worth for the completeness.\n+\t* sem_res.adb (Resolve): Pick index name from the iterator\n+\tspecification, when present.\n+\t* sem_util.adb (Traverse_More): For completeness, just like the\n+\tchange in Traverse_Potential_Scenario.\n+\t* sinfo.ads\n+\t(ITERATED_COMPONENT_ASSOCIATION): Fix and complete description.\n+\t(ITERATED_ELEMENT_ASSOCIATION): Likewise.\n+\n+2022-09-05  Bob Duff  <duff@adacore.com>\n+\n+\t* sem_ch6.adb\n+\t(Analyze_Subprogram_Body_Helper): Use First_Real_Statement to deal\n+\twith this case. Note that First_Real_Statement is likely to be\n+\tremoved as part of this ticket, so this is a temporary fix.\n+\n+2022-09-05  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* ali.adb (Scan_ALI): Special case i-c*.ali when setting\n+\tSec_Stack_Used.\n+\n+2022-09-05  Bob Duff  <duff@adacore.com>\n+\n+\t* par-ch5.adb\n+\t(P_Sequence_Of_Statements): Call Error_Msg_GNAT_Extension to give\n+\tthe error message.\n+\n+2022-09-05  Piotr Trojanek  <trojanek@adacore.com>\n+\n+\t* sem_aggr.adb (Resolve_Iterated_Component_Association): Split\n+\tprocessing of cases with and without iterator specification; reuse\n+\tanalysis of iterator specification; improve diagnostics for\n+\tpremature usage of iterator index in discrete choices.\n+\n+2022-09-05  Piotr Trojanek  <trojanek@adacore.com>\n+\n+\t* sem_ch5.adb (Check_Subtype_Definition): Remove redundant call to\n+\tPresent; style cleanup.\n+\n+2022-09-05  Piotr Trojanek  <trojanek@adacore.com>\n+\n+\t* sem_aggr.adb (Resolve_Array_Aggregate): Change an inconsistent\n+\tuse of False into its local equivalent Failure.\n+\n+2022-09-05  Piotr Trojanek  <trojanek@adacore.com>\n+\n+\t* sem_aggr.adb (Resolve_Iterated_Component_Association): Change\n+\tgeneric name Ent to a more intuitive Scop; rename Remove_Ref to\n+\tRemove_Reference, so it can be instantiated as a traversal routine\n+\twith plural name.\n+\n+2022-09-05  Piotr Trojanek  <trojanek@adacore.com>\n+\n+\t* sem_ch4.adb\n+\t(Is_Empty_Range): Move error reporting to the caller.\n+\t(Analyze_Qualified_Expression): Move error reporting from Is_Empty_Range;\n+\tadd matching call to End_Scope before rewriting and returning.\n+\n+2022-09-05  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* bindgen.adb (Gen_Elab_Calls): Check for Check_Elaboration_Flags.\n+\t* bindusg.adb (Display): Add -k.\n+\t* opt.ads (Check_Elaboration_Flags): New.\n+\t* switch-b.adb (Scan_Binder_Switches): Add processing of -k.\n+\t* doc/gnat_ugn/building_executable_programs_with_gnat.rst: Add\n+\tdocumentation for -k and -K.\n+\t* gnat_ugn.texi: Regenerate.\n+\n+2022-09-05  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* treepr.adb: Remove local To_Lower and use the procedure\n+\tversion instead.\n+\n+2022-09-05  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* aspects.ads (Delaying Evaluation of Aspect): Fix typos.\n+\t* exp_ch3.adb (Freeze_Type): Do not generate Invariant and DIC\n+\tprocedures for internal types.\n+\t* exp_util.adb (Build_DIC_Procedure_Body): Adjust comment.\n+\t* freeze.adb (Freeze_Entity): Call Inherit_Delayed_Rep_Aspects for\n+\tsubtypes and derived types only after the base or parent type has\n+\tbeen frozen.  Remove useless freezing for first subtype.\n+\t(Freeze_Fixed_Point_Type): Call Inherit_Delayed_Rep_Aspects too.\n+\t* layout.adb (Set_Elem_Alignment): Deal with private types.\n+\t* sem_ch3.adb (Build_Derived_Enumeration_Type): Build the implicit\n+\tbase as an itype and do not insert its declaration in the tree.\n+\t(Build_Derived_Numeric_Type): Do not freeze the implicit base.\n+\t(Derived_Standard_Character): Likewise.\n+\t(Constrain_Enumeration): Inherit the chain of representation items\n+\tinstead of replacing it.\n+\t* sem_ch13.ads (Inherit_Aspects_At_Freeze_Point): Add ??? comment.\n+\t(Inherit_Delayed_Rep_Aspects): Declare.\n+\t* sem_ch13.adb (Analyze_Aspects_At_Freeze_Point): Do not invoke\n+\tInherit_Delayed_Rep_Aspects.\n+\t(Inherit_Aspects_At_Freeze_Point): Deal with private types.\n+\t(Inherit_Delayed_Rep_Aspects): Move to library level.\n+\n+2022-09-05  Piotr Trojanek  <trojanek@adacore.com>\n+\n+\t* einfo-utils.adb (Number_Entries): Refine type of a local variable.\n+\t* exp_attr.adb (Expand_N_Attribute_Reference): Rename Conctyp to\n+\tProttyp; refactor repeated calls to New_Occurrence_Of; replace\n+\tNumber_Entries with Has_Entries.\n+\t* exp_ch5.adb (Expand_N_Assignment_Statement): Likewise; remove Subprg\n+\tvariable (apparently copy-pasted from expansion of the attribute).\n+\n+2022-09-05  Piotr Trojanek  <trojanek@adacore.com>\n+\n+\t* exp_attr.adb (Expand_N_Attribute_Reference): Fix detection of the\n+\tenclosing protected type and of the enclosing protected subprogram.\n+\t* exp_ch5.adb (Expand_N_Assignment_Statement): Likewise.\n+\n+2022-09-05  Piotr Trojanek  <trojanek@adacore.com>\n+\n+\t* freeze.adb (Freeze_Itype): Remove excessive guard.\n+\t* sem_ch5.adb (Analyze_Loop_Parameter_Specification): Likewise.\n+\n+2022-09-05  Piotr Trojanek  <trojanek@adacore.com>\n+\n+\t* sprint.adb (Sprint_Node_Actual): Handle iterator_specification within\n+\titerated_component_association and iterator_filter within\n+\titerator_specification.\n+\n+2022-09-05  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* doc/gnat_ugn/gnat_and_program_execution.rst: Fix rest syntax\n+\t* gnat_ugn.texi: Regenerate.\n+\n+2022-09-02  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* exp_util.adb (Expand_Subtype_From_Expr): Be prepared for\n+\trewritten aggregates as expressions.\n+\n+2022-09-02  Gary Dismukes  <dismukes@adacore.com>\n+\n+\t* exp_ch6.adb (Expand_Simple_Function_Return) Bypass creation of an actual\n+\tsubtype and unchecked conversion to that subtype when the underlying type\n+\tof the expression has discriminants without defaults.\n+\n+2022-09-02  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* exp_util.adb (Expand_Subtype_From_Expr): Check for the presence\n+\tof the Is_Constr_Subt_For_U_Nominal flag instead of the absence\n+\tof the Is_Constr_Subt_For_UN_Aliased flag on the subtype of the\n+\texpression of an object declaration before reusing this subtype.\n+\t* sem_ch3.adb (Analyze_Object_Declaration): Do not incorrectly\n+\tset the Is_Constr_Subt_For_UN_Aliased flag on the actual subtype\n+\tof an array with definite nominal subtype.  Remove useless test.\n+\n+2022-09-02  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* doc/gnat_rm/standard_and_implementation_defined_restrictions.rst\n+\t(No_Dependence): Cite implicit dependences on the runtime library.\n+\t* gnat_rm.texi, gnat_ugn.texi: Regenerate.\n+\n+2022-09-02  Claire Dross  <dross@adacore.com>\n+\n+\t* libgnat/a-strmap.adb: Add variants to simple and while loops.\n+\t* libgnat/a-strsea.adb: Idem.\n+\n+2022-09-02  Claire Dross  <dross@adacore.com>\n+\n+\t* libgnat/s-expmod.adb (Lemma_Add_Mod): Add new lemma to factor\n+\tout a complex sub-proof.\n+\t(Exp_Modular): Add assertion to help proof.\n+\n+2022-09-02  Claire Dross  <dross@adacore.com>\n+\n+\t* libgnat/s-widthu.adb (Lemma_Euclidean): Lemma to prove the\n+\trelation between the quotient/remainder of a division.\n+\n+2022-09-02  Yannick Moy  <moy@adacore.com>\n+\n+\t* libgnat/s-aridou.adb: Add or rework ghost code.\n+\t* libgnat/s-aridou.ads: Add Big_Positive subtype.\n+\n+2022-09-02  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* doc/gnat_ugn/gnat_and_program_execution.rst\n+\t(Non-Symbolic Traceback): Update section.\n+\t* gnat_rm.texi, gnat_ugn.texi, gnat-style.texi: Regenerate.\n+\n+2022-09-02  Claire Dross  <dross@adacore.com>\n+\n+\t* libgnat/a-nbnbig.ads: Add Always_Return annotation.\n+\t* libgnat/s-vaispe.ads: New ghost unit for the specification of\n+\tSystem.Value_I. Restore proofs.\n+\t* libgnat/s-vauspe.ads: New ghost unit for the specification of\n+\tSystem.Value_U. Restore proofs.\n+\t* libgnat/s-valuei.adb: The specification only subprograms are\n+\tmoved to System.Value_I_Spec. Restore proofs.\n+\t* libgnat/s-valueu.adb: The specification only subprograms are\n+\tmoved to System.Value_U_Spec. Restore proofs.\n+\t* libgnat/s-valuti.ads\n+\t(Uns_Params): Generic unit used to bundle together the\n+\tspecification functions of System.Value_U_Spec.\n+\t(Int_Params): Generic unit used to bundle together the\n+\tspecification functions of System.Value_I_Spec.\n+\t* libgnat/s-imagef.adb: It is now possible to instantiate the\n+\tappropriate specification units instead of creating imported ghost\n+\tsubprograms.\n+\t* libgnat/s-imagei.adb: Update to refactoring of specifications\n+\tand fix proofs.\n+\t* libgnat/s-imageu.adb: Likewise.\n+\t* libgnat/s-imgint.ads: Ghost parameters are grouped together in a\n+\tpackage now.\n+\t* libgnat/s-imglli.ads: Likewise.\n+\t* libgnat/s-imgllu.ads: Likewise.\n+\t* libgnat/s-imgllli.ads: Likewise.\n+\t* libgnat/s-imglllu.ads: Likewise.\n+\t* libgnat/s-imguns.ads: Likewise.\n+\t* libgnat/s-vallli.ads: Likewise.\n+\t* libgnat/s-valllli.ads: Likewise.\n+\t* libgnat/s-imagei.ads: Likewise.\n+\t* libgnat/s-imageu.ads: Likewise.\n+\t* libgnat/s-vaispe.adb: Likewise.\n+\t* libgnat/s-valint.ads: Likewise.\n+\t* libgnat/s-valuei.ads: Likewise.\n+\t* libgnat/s-valueu.ads: Likewise.\n+\t* libgnat/s-vauspe.adb: Likewise.\n+\n 2022-07-13  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/trans.cc (gnat_to_gnu) <N_Assignment_Statement>: Fix"}, {"sha": "96306f8cc9ae672340f98098fb6da45525586fb7", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -110,14 +110,6 @@ GNATRTL_NONTASKING_OBJS= \\\n   a-cbprqu$(objext) \\\n   a-cbsyqu$(objext) \\\n   a-cdlili$(objext) \\\n-  a-cfdlli$(objext) \\\n-  a-cfhama$(objext) \\\n-  a-cfhase$(objext) \\\n-  a-cfidll$(objext) \\\n-  a-cfinve$(objext) \\\n-  a-cfinse$(objext) \\\n-  a-cforma$(objext) \\\n-  a-cforse$(objext) \\\n   a-cgaaso$(objext) \\\n   a-cgarso$(objext) \\\n   a-cgcaso$(objext) \\\n@@ -144,14 +136,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   a-clrefi$(objext) \\\n   a-coboho$(objext) \\\n   a-cobove$(objext) \\\n-  a-cofove$(objext) \\\n-  a-cofuba$(objext) \\\n-  a-cofuma$(objext) \\\n-  a-cofuse$(objext) \\\n-  a-cofuve$(objext) \\\n   a-cogeso$(objext) \\\n-  a-cohama$(objext) \\\n-  a-cohase$(objext) \\\n   a-cohata$(objext) \\\n   a-coinho$(objext) \\\n   a-coinve$(objext) \\\n@@ -778,6 +763,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   s-vaenu8$(objext) \\\n   s-vafi32$(objext) \\\n   s-vafi64$(objext) \\\n+  s-vaispe$(objext) \\\n   s-valboo$(objext) \\\n   s-valcha$(objext) \\\n   s-valflt$(objext) \\\n@@ -796,6 +782,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   s-valuns$(objext) \\\n   s-valuti$(objext) \\\n   s-valwch$(objext) \\\n+  s-vauspe$(objext) \\\n   s-veboop$(objext) \\\n   s-vector$(objext) \\\n   s-vercon$(objext) \\"}, {"sha": "3febd48104895875804217a420e73ac3e07b7ae1", "filename": "gcc/ada/ali.adb", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fali.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fali.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fali.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -2079,15 +2079,24 @@ package body ALI is\n                --  Processing for SS\n \n                elsif C = 'S' then\n-                  --  Special case: a-tags.ali by itself should not set\n+                  --  Special case: a-tags/i-c* by themselves should not set\n                   --  Sec_Stack_Used, only if other code uses the secondary\n                   --  stack should we set this flag. This ensures that we do\n                   --  not bring the secondary stack unnecessarily when using\n-                  --  Ada.Tags and not actually using the secondary stack.\n+                  --  one of these packages and not actually using the\n+                  --  secondary stack.\n \n-                  if Get_Name_String (F) /= \"a-tags.ali\" then\n-                     Opt.Sec_Stack_Used := True;\n-                  end if;\n+                  declare\n+                     File : constant String := Get_Name_String (F);\n+                  begin\n+                     if File /= \"a-tags.ali\"\n+                       and then File /= \"i-c.ali\"\n+                       and then File /= \"i-cstrin.ali\"\n+                       and then File /= \"i-cpoint.ali\"\n+                     then\n+                        Opt.Sec_Stack_Used := True;\n+                     end if;\n+                  end;\n \n                --  Invalid switch starting with S\n "}, {"sha": "2edb6082de708315481526664383c5c444dee2a5", "filename": "gcc/ada/aspects.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Faspects.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Faspects.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.ads?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -822,11 +822,11 @@ package Aspects is\n    --  set on the parent type if it has delayed representation aspects. This\n    --  flag Has_Delayed_Rep_Aspects indicates that if we derive from this type\n    --  we have to worry about making sure we inherit any delayed aspects. The\n-   --  second flag is set on a derived type: May_Have_Inherited_Rep_Aspects\n+   --  second flag is set on a derived type: May_Inherit_Delayed_Rep_Aspects\n    --  is set if the parent type has Has_Delayed_Rep_Aspects set.\n \n-   --  When we freeze a derived type, if the May_Have_Inherited_Rep_Aspects\n-   --  flag is set, then we call Freeze.Inherit_Delayed_Rep_Aspects when\n+   --  When we freeze a derived type, if the May_Inherit_Delayed_Rep_Aspects\n+   --  flag is set, then we call Sem_Ch13.Inherit_Delayed_Rep_Aspects when\n    --  the derived type is frozen, which deals with the necessary copying of\n    --  information from the parent type, which must be frozen at that point\n    --  (since freezing the derived type first freezes the parent type)."}, {"sha": "b2fa44d2dffd0c623212d375ec9645b6b5ed2bc5", "filename": "gcc/ada/bindgen.adb", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fbindgen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fbindgen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindgen.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -114,6 +114,29 @@ package body Bindgen is\n    --  For CodePeer, introduce a wrapper subprogram which calls the\n    --  user-defined main subprogram.\n \n+   --  Names and link_names for CUDA device adainit/adafinal procs.\n+\n+   Device_Subp_Name_Prefix : constant String := \"imported_device_\";\n+   Device_Link_Name_Prefix : constant String := \"__device_\";\n+\n+   function Device_Ada_Final_Link_Name return String is\n+     (Device_Link_Name_Prefix & Ada_Final_Name.all);\n+\n+   function Device_Ada_Final_Subp_Name return String is\n+     (Device_Subp_Name_Prefix & Ada_Final_Name.all);\n+\n+   function Device_Ada_Init_Link_Name return String is\n+     (Device_Link_Name_Prefix & Ada_Init_Name.all);\n+\n+   function Device_Ada_Init_Subp_Name return String is\n+     (Device_Subp_Name_Prefix & Ada_Init_Name.all);\n+\n+   --  Text for aspect specifications (if any) given as part of the\n+   --  Adainit and Adafinal spec declarations.\n+\n+   function Aspect_Text return String is\n+     (if Enable_CUDA_Device_Expansion then \" with CUDA_Global\" else \"\");\n+\n    ----------------------------------\n    -- Interface_State Pragma Table --\n    ----------------------------------\n@@ -501,6 +524,12 @@ package body Bindgen is\n          WBI (\"      System.Standard_Library.Adafinal;\");\n       end if;\n \n+      --  perform device (as opposed to host) finalization\n+      if Enable_CUDA_Expansion then\n+         WBI (\"      pragma CUDA_Execute (\" &\n+                Device_Ada_Final_Subp_Name & \", 1, 1);\");\n+      end if;\n+\n       WBI (\"   end \" & Ada_Final_Name.all & \";\");\n       WBI (\"\");\n    end Gen_Adafinal;\n@@ -512,7 +541,6 @@ package body Bindgen is\n    procedure Gen_Adainit (Elab_Order : Unit_Id_Array) is\n       Main_Priority : Int renames ALIs.Table (ALIs.First).Main_Priority;\n       Main_CPU      : Int renames ALIs.Table (ALIs.First).Main_CPU;\n-\n    begin\n       --  Declare the access-to-subprogram type used for initialization of\n       --  of __gnat_finalize_library_objects. This is declared at library\n@@ -1334,6 +1362,13 @@ package body Bindgen is\n          end;\n       end loop;\n \n+      WBI (\"   procedure \" & Device_Ada_Init_Subp_Name & \";\");\n+      WBI (\"   pragma Import (C, \" & Device_Ada_Init_Subp_Name &\n+             \", Link_Name => \"\"\" & Device_Ada_Init_Link_Name & \"\"\");\");\n+      WBI (\"   procedure \" & Device_Ada_Final_Subp_Name & \";\");\n+      WBI (\"   pragma Import (C, \" & Device_Ada_Final_Subp_Name &\n+             \", Link_Name => \"\"\" & Device_Ada_Final_Link_Name & \"\"\");\");\n+\n       WBI (\"\");\n    end Gen_CUDA_Defs;\n \n@@ -1393,6 +1428,10 @@ package body Bindgen is\n       end loop;\n \n       WBI (\"      CUDA_Register_Fat_Binary_End (Fat_Binary_Handle);\");\n+\n+      --  perform device (as opposed to host) elaboration\n+      WBI (\"      pragma CUDA_Execute (\" &\n+             Device_Ada_Init_Subp_Name & \", 1, 1);\");\n    end Gen_CUDA_Init;\n \n    --------------------------\n@@ -1544,6 +1583,7 @@ package body Bindgen is\n \n                Check_Elab_Flag :=\n                  Units.Table (Unum_Spec).Set_Elab_Entity\n+                   and then Check_Elaboration_Flags\n                    and then not CodePeer_Mode\n                    and then (Force_Checking_Of_Elaboration_Flags\n                               or Interface_Library_Unit\n@@ -2512,6 +2552,9 @@ package body Bindgen is\n       if Enable_CUDA_Expansion then\n          WBI (\"with Interfaces.C;\");\n          WBI (\"with Interfaces.C.Strings;\");\n+\n+         --  with of CUDA.Internal needed for CUDA_Execute pragma expansion\n+         WBI (\"with CUDA.Internal;\");\n       end if;\n \n       Resolve_Binder_Options (Elab_Order);\n@@ -2601,9 +2644,14 @@ package body Bindgen is\n       end if;\n \n       WBI (\"\");\n-      WBI (\"   procedure \" & Ada_Init_Name.all & \";\");\n-      WBI (\"   pragma Export (C, \" & Ada_Init_Name.all & \", \"\"\" &\n-           Ada_Init_Name.all & \"\"\");\");\n+      WBI (\"   procedure \" & Ada_Init_Name.all & Aspect_Text & \";\");\n+      if Enable_CUDA_Device_Expansion then\n+         WBI (\"   pragma Export (C, \" & Ada_Init_Name.all &\n+                \", Link_Name => \"\"\" & Device_Ada_Init_Link_Name & \"\"\");\");\n+      else\n+         WBI (\"   pragma Export (C, \" & Ada_Init_Name.all & \", \"\"\" &\n+              Ada_Init_Name.all & \"\"\");\");\n+      end if;\n \n       --  If -a has been specified use pragma Linker_Constructor for the init\n       --  procedure and pragma Linker_Destructor for the final procedure.\n@@ -2614,9 +2662,15 @@ package body Bindgen is\n \n       if not Cumulative_Restrictions.Set (No_Finalization) then\n          WBI (\"\");\n-         WBI (\"   procedure \" & Ada_Final_Name.all & \";\");\n-         WBI (\"   pragma Export (C, \" & Ada_Final_Name.all & \", \"\"\" &\n-              Ada_Final_Name.all & \"\"\");\");\n+         WBI (\"   procedure \" & Ada_Final_Name.all & Aspect_Text & \";\");\n+\n+         if Enable_CUDA_Device_Expansion then\n+            WBI (\"   pragma Export (C, \" & Ada_Final_Name.all &\n+                   \", Link_Name => \"\"\" & Device_Ada_Final_Link_Name & \"\"\");\");\n+         else\n+            WBI (\"   pragma Export (C, \" & Ada_Final_Name.all & \", \"\"\" &\n+                 Ada_Final_Name.all & \"\"\");\");\n+         end if;\n \n          if Use_Pragma_Linker_Constructor then\n             WBI (\"   pragma Linker_Destructor (\" & Ada_Final_Name.all & \");\");"}, {"sha": "3f99bae8afe8dfc316768b2f4638cbe7c1ede281", "filename": "gcc/ada/bindusg.adb", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fbindusg.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fbindusg.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindusg.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -156,6 +156,11 @@ package body Bindusg is\n         (\"  -I-       Don't look for sources & library files in default \"\n          & \"directory\");\n \n+      --  Line for -k switch\n+\n+      Write_Line\n+        (\"  -k        Disable checking of elaboration flags\");\n+\n       --  Line for -K switch\n \n       Write_Line"}, {"sha": "8fa16b802dee2cb964dc77741d4940f8da334b7f", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -5094,7 +5094,8 @@ package body Checks is\n         --  Don't deal with enumerated types with non-standard representation\n \n         or else (Is_Enumeration_Type (Typ)\n-                   and then Present (Enum_Pos_To_Rep (Base_Type (Typ))))\n+                   and then Present (Enum_Pos_To_Rep\n+                                       (Implementation_Base_Type (Typ))))\n \n         --  Ignore type for which an error has been posted, since range in\n         --  this case may well be a bogosity deriving from the error. Also\n@@ -9950,8 +9951,8 @@ package body Checks is\n       --    Typ'Length /= Exp'Length\n \n       function Length_Mismatch_Info_Message\n-        (Left_Element_Count  : Uint;\n-         Right_Element_Count : Uint) return String;\n+        (Left_Element_Count  : Unat;\n+         Right_Element_Count : Unat) return String;\n       --  Returns a message indicating how many elements were expected\n       --  (Left_Element_Count) and how many were found (Right_Element_Count).\n \n@@ -10149,14 +10150,14 @@ package body Checks is\n       ----------------------------------\n \n       function Length_Mismatch_Info_Message\n-        (Left_Element_Count  : Uint;\n-         Right_Element_Count : Uint) return String\n+        (Left_Element_Count  : Unat;\n+         Right_Element_Count : Unat) return String\n       is\n \n-         function Plural_Vs_Singular_Ending (Count : Uint) return String;\n+         function Plural_Vs_Singular_Ending (Count : Unat) return String;\n          --  Returns an empty string if Count is 1; otherwise returns \"s\"\n \n-         function Plural_Vs_Singular_Ending (Count : Uint) return String is\n+         function Plural_Vs_Singular_Ending (Count : Unat) return String is\n          begin\n             if Count = 1 then\n                return \"\";\n@@ -10166,12 +10167,19 @@ package body Checks is\n          end Plural_Vs_Singular_Ending;\n \n       begin\n-         return \"expected \" & UI_Image (Left_Element_Count)\n+         return \"expected \"\n+                  & UI_Image (Left_Element_Count, Format => Decimal)\n                   & \" element\"\n                   & Plural_Vs_Singular_Ending (Left_Element_Count)\n-                  & \"; found \" & UI_Image (Right_Element_Count)\n+                  & \"; found \"\n+                  & UI_Image (Right_Element_Count, Format => Decimal)\n                   & \" element\"\n                   & Plural_Vs_Singular_Ending (Right_Element_Count);\n+         --  \"Format => Decimal\" above is needed because otherwise UI_Image\n+         --  can sometimes return a hexadecimal number 16#...#, but \"#\" means\n+         --  something special to Errout. A previous version used the default\n+         --  Auto, which was essentially the same bug as documented here:\n+         --  https://xkcd.com/327/ .\n       end Length_Mismatch_Info_Message;\n \n       -----------------\n@@ -10370,14 +10378,14 @@ package body Checks is\n                            if L_Length > R_Length then\n                               Add_Check\n                                 (Compile_Time_Constraint_Error\n-                                  (Wnode, \"too few elements for}??\", T_Typ,\n+                                  (Wnode, \"too few elements for}!!??\", T_Typ,\n                                    Extra_Msg => Length_Mismatch_Info_Message\n                                                   (L_Length, R_Length)));\n \n                            elsif L_Length < R_Length then\n                               Add_Check\n                                 (Compile_Time_Constraint_Error\n-                                  (Wnode, \"too many elements for}??\", T_Typ,\n+                                  (Wnode, \"too many elements for}!!??\", T_Typ,\n                                    Extra_Msg => Length_Mismatch_Info_Message\n                                                   (L_Length, R_Length)));\n                            end if;"}, {"sha": "34db67a8cabf2d4ac72c4d044c3fbf52a9dd9b14", "filename": "gcc/ada/contracts.adb", "status": "modified", "additions": 678, "deletions": 436, "changes": 1114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fcontracts.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fcontracts.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcontracts.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -68,6 +68,19 @@ package body Contracts is\n    --\n    --    Part_Of\n \n+   procedure Build_Subprogram_Contract_Wrapper\n+     (Body_Id : Entity_Id;\n+      Stmts   : List_Id;\n+      Decls   : List_Id;\n+      Result  : Entity_Id);\n+   --  Generate a wrapper for a given subprogram body when the expansion of\n+   --  postconditions require it by moving its declarations and statements\n+   --  into a locally declared subprogram _Wrapped_Statements.\n+\n+   --  Postcondition and precondition checks then get inserted in place of\n+   --  the original statements and declarations along with a call to\n+   --  _Wrapped_Statements.\n+\n    procedure Check_Class_Condition\n      (Cond            : Node_Id;\n       Subp            : Entity_Id;\n@@ -78,6 +91,10 @@ package body Contracts is\n    --  In SPARK_Mode, an inherited operation that is not overridden but has\n    --  inherited modified conditions pre/postconditions is illegal.\n \n+   function Is_Prologue_Renaming (Decl : Node_Id) return Boolean;\n+   --  Determine whether arbitrary declaration Decl denotes a renaming of\n+   --  a discriminant or protection field _object.\n+\n    procedure Check_Type_Or_Object_External_Properties\n      (Type_Or_Obj_Id : Entity_Id);\n    --  Perform checking of external properties pragmas that is common to both\n@@ -488,6 +505,45 @@ package body Contracts is\n       end loop;\n    end Analyze_Contracts;\n \n+   -------------------------------------\n+   -- Analyze_Pragmas_In_Declarations --\n+   -------------------------------------\n+\n+   procedure Analyze_Pragmas_In_Declarations (Body_Id : Entity_Id) is\n+      Curr_Decl : Node_Id;\n+\n+   begin\n+      --  Move through the body's declarations analyzing all pragmas which\n+      --  appear at the top of the declarations.\n+\n+      Curr_Decl := First (Declarations (Unit_Declaration_Node (Body_Id)));\n+      while Present (Curr_Decl) loop\n+\n+         if Nkind (Curr_Decl) = N_Pragma then\n+\n+            if Pragma_Significant_To_Subprograms\n+                 (Get_Pragma_Id (Curr_Decl))\n+            then\n+               Analyze (Curr_Decl);\n+            end if;\n+\n+         --  Skip the renamings of discriminants and protection fields\n+\n+         elsif Is_Prologue_Renaming (Curr_Decl) then\n+            null;\n+\n+         --  We have reached something which is not a pragma so we can be sure\n+         --  there are no more contracts or pragmas which need to be taken into\n+         --  account.\n+\n+         else\n+            exit;\n+         end if;\n+\n+         Next (Curr_Decl);\n+      end loop;\n+   end Analyze_Pragmas_In_Declarations;\n+\n    -----------------------------------------------\n    -- Analyze_Entry_Or_Subprogram_Body_Contract --\n    -----------------------------------------------\n@@ -644,7 +700,7 @@ package body Contracts is\n \n          else\n             declare\n-               Bod          : Node_Id;\n+               Bod          : Node_Id := Empty;\n                Freeze_Types : Boolean := False;\n \n             begin\n@@ -1263,6 +1319,18 @@ package body Contracts is\n       if Present (Items) then\n          if Analyzed (Items) then\n             return;\n+\n+         --  Do not analyze the contract of the internal package\n+         --  created to check conformance of an actual package.\n+         --  Such an internal package is removed from the tree after\n+         --  legality checks are completed, and it does not contain\n+         --  the declarations of all local entities of the generic.\n+\n+         elsif Is_Internal (Pack_Id)\n+           and then Is_Generic_Instance (Pack_Id)\n+         then\n+            return;\n+\n          else\n             Set_Analyzed (Items);\n          end if;\n@@ -1499,6 +1567,491 @@ package body Contracts is\n         (Type_Or_Obj_Id => Type_Id);\n    end Analyze_Type_Contract;\n \n+   ---------------------------------------\n+   -- Build_Subprogram_Contract_Wrapper --\n+   ---------------------------------------\n+\n+   procedure Build_Subprogram_Contract_Wrapper\n+     (Body_Id : Entity_Id;\n+      Stmts   : List_Id;\n+      Decls   : List_Id;\n+      Result  : Entity_Id)\n+   is\n+      Body_Decl : constant Entity_Id  := Unit_Declaration_Node (Body_Id);\n+      Loc       : constant Source_Ptr := Sloc (Body_Decl);\n+      Spec_Id   : constant Entity_Id  := Corresponding_Spec (Body_Decl);\n+      Subp_Id   : Entity_Id;\n+      Ret_Type  : Entity_Id;\n+\n+      Wrapper_Id   : Entity_Id;\n+      Wrapper_Body : Node_Id;\n+      Wrapper_Spec : Node_Id;\n+\n+   begin\n+      --  When there are no postcondition statements we do not need to\n+      --  generate a wrapper.\n+\n+      if No (Stmts) then\n+         return;\n+      end if;\n+\n+      --  Obtain the related subprogram id from the body id.\n+\n+      if Present (Spec_Id) then\n+         Subp_Id := Spec_Id;\n+      else\n+         Subp_Id := Body_Id;\n+      end if;\n+      Ret_Type := Etype (Subp_Id);\n+\n+      --  Generate the contracts wrapper by moving the original declarations\n+      --  and statements within a local subprogram, calling it and possibly\n+      --  preserving the result for the purpose of evaluating postconditions,\n+      --  contracts, type invariants, etc.\n+\n+      --  In the case of a function, generate:\n+      --\n+      --  function Original_Func (X : in out Integer) return Typ is\n+      --     <prologue renamings>\n+      --     <preconditions>\n+      --\n+      --     function _Wrapped_Statements return Typ is\n+      --        <original declarations>\n+      --     begin\n+      --        <original statements>\n+      --     end;\n+      --\n+      --  begin\n+      --     declare\n+      --        type Axx is access all Typ;\n+      --        Rxx : constant Axx := _Wrapped_Statements'reference;\n+      --        Result_Obj : Typ renames Rxx.all;\n+      --\n+      --     begin\n+      --        <postconditions statments>\n+      --        return Rxx.all;\n+      --     end;\n+      --  end;\n+      --\n+      --  This sequence is recognized by Expand_Simple_Function_Return as a\n+      --  tail call, in other words equivalent to \"return _Wrapped_Statements;\"\n+      --  and thus the copy to the anonymous return object is elided, including\n+      --  a pair of calls to Adjust/Finalize for types requiring finalization.\n+\n+      --  Note that an extended return statement does not yield the same result\n+      --  because the copy of the return object is not elided by GNAT for now.\n+\n+      --  Or, in the case of a procedure:\n+      --\n+      --  procedure Original_Proc (X : in out Integer) is\n+      --     <prologue renamings>\n+      --     <preconditions>\n+      --\n+      --     procedure _Wrapped_Statements is\n+      --        <original declarations>\n+      --     begin\n+      --        <original statements>\n+      --     end;\n+      --\n+      --  begin\n+      --     _Wrapped_Statements;\n+      --     <postconditions statments>\n+      --  end;\n+      --\n+\n+      --  Create Identifier\n+\n+      Wrapper_Id := Make_Defining_Identifier (Loc, Name_uWrapped_Statements);\n+      Set_Debug_Info_Needed  (Wrapper_Id);\n+      Set_Wrapped_Statements (Subp_Id, Wrapper_Id);\n+\n+      --  Create specification and declaration for the wrapper\n+\n+      if No (Ret_Type) or else Ret_Type = Standard_Void_Type then\n+         Wrapper_Spec :=\n+           Make_Procedure_Specification (Loc,\n+             Defining_Unit_Name => Wrapper_Id);\n+      else\n+         Wrapper_Spec :=\n+           Make_Function_Specification (Loc,\n+             Defining_Unit_Name => Wrapper_Id,\n+             Result_Definition  => New_Occurrence_Of (Ret_Type, Loc));\n+      end if;\n+\n+      --  Create the wrapper body using Body_Id's statements and declarations\n+\n+      Wrapper_Body :=\n+        Make_Subprogram_Body (Loc,\n+          Specification              => Wrapper_Spec,\n+          Declarations               => Declarations (Body_Decl),\n+          Handled_Statement_Sequence =>\n+            Relocate_Node (Handled_Statement_Sequence (Body_Decl)));\n+\n+      Append_To (Decls, Wrapper_Body);\n+      Set_Declarations (Body_Decl, Decls);\n+      Set_Handled_Statement_Sequence (Body_Decl,\n+        Make_Handled_Sequence_Of_Statements (Loc,\n+          End_Label  => Make_Identifier (Loc, Chars (Wrapper_Id))));\n+\n+      --  Move certain flags which are relevant to the body\n+\n+      --  Wouldn't a better way be to perform some sort of copy of Body_Decl\n+      --  for Wrapper_Body be less error-prone ???\n+\n+      if Was_Expression_Function (Body_Decl) then\n+         Set_Was_Expression_Function (Body_Decl, False);\n+         Set_Was_Expression_Function (Wrapper_Body);\n+      end if;\n+\n+      Set_Has_Pragma_Inline (Wrapper_Id, Has_Pragma_Inline (Subp_Id));\n+      Set_Has_Pragma_Inline_Always\n+        (Wrapper_Id, Has_Pragma_Inline_Always (Subp_Id));\n+\n+      --  Prepend a call to the wrapper when the subprogram is a procedure\n+\n+      if No (Ret_Type) or else Ret_Type = Standard_Void_Type then\n+         Prepend_To (Stmts,\n+           Make_Procedure_Call_Statement (Loc,\n+             Name => New_Occurrence_Of (Wrapper_Id, Loc)));\n+         Set_Statements\n+           (Handled_Statement_Sequence (Body_Decl), Stmts);\n+\n+      --  Declare a renaming of the result of the call to the wrapper and\n+      --  append a return of the result of the call when the subprogram is\n+      --  a function, after manually removing the side effects. Note that\n+      --  we cannot call Remove_Side_Effects here because nothing has been\n+      --  analyzed yet and we cannot return the renaming itself because\n+      --  Expand_Simple_Function_Return expects an explicit dereference.\n+\n+      else\n+         declare\n+            A_Id : constant Node_Id := Make_Temporary (Loc, 'A');\n+            R_Id : constant Node_Id := Make_Temporary (Loc, 'R');\n+\n+         begin\n+            Set_Statements (Handled_Statement_Sequence (Body_Decl), New_List (\n+              Make_Block_Statement (Loc,\n+\n+                Declarations => New_List (\n+                  Make_Full_Type_Declaration (Loc,\n+                    Defining_Identifier => A_Id,\n+                    Type_Definition     =>\n+                      Make_Access_To_Object_Definition (Loc,\n+                        All_Present        => True,\n+                        Null_Exclusion_Present => True,\n+                        Subtype_Indication =>\n+                          New_Occurrence_Of (Ret_Type, Loc))),\n+\n+                  Make_Object_Declaration (Loc,\n+                    Defining_Identifier => R_Id,\n+                    Object_Definition   => New_Occurrence_Of (A_Id, Loc),\n+                    Constant_Present    => True,\n+                    Expression          =>\n+                      Make_Reference (Loc,\n+                        Make_Function_Call (Loc,\n+                          Name => New_Occurrence_Of (Wrapper_Id, Loc)))),\n+\n+                  Make_Object_Renaming_Declaration (Loc,\n+                    Defining_Identifier => Result,\n+                    Subtype_Mark        => New_Occurrence_Of (Ret_Type, Loc),\n+                    Name                =>\n+                      Make_Explicit_Dereference (Loc,\n+                        New_Occurrence_Of (R_Id, Loc)))),\n+\n+                Handled_Statement_Sequence =>\n+                  Make_Handled_Sequence_Of_Statements (Loc,\n+                    Statements => Stmts))));\n+\n+            Append_To (Stmts,\n+              Make_Simple_Return_Statement (Loc,\n+                Expression =>\n+                  Make_Explicit_Dereference (Loc,\n+                    New_Occurrence_Of (R_Id, Loc))));\n+\n+            --  It is required for Is_Related_To_Func_Return to return True\n+            --  that the temporary Rxx be related to the expression of the\n+            --  simple return statement built just above.\n+\n+            Set_Related_Expression (R_Id, Expression (Last (Stmts)));\n+         end;\n+      end if;\n+   end Build_Subprogram_Contract_Wrapper;\n+\n+   ----------------------------------\n+   -- Build_Entry_Contract_Wrapper --\n+   ----------------------------------\n+\n+   procedure Build_Entry_Contract_Wrapper (E : Entity_Id; Decl : Node_Id) is\n+      Conc_Typ : constant Entity_Id  := Scope (E);\n+      Loc      : constant Source_Ptr := Sloc (E);\n+\n+      procedure Add_Discriminant_Renamings\n+        (Obj_Id : Entity_Id;\n+         Decls  : List_Id);\n+      --  Add renaming declarations for all discriminants of concurrent type\n+      --  Conc_Typ. Obj_Id is the entity of the wrapper formal parameter which\n+      --  represents the concurrent object.\n+\n+      procedure Add_Matching_Formals\n+        (Formals : List_Id;\n+         Actuals : in out List_Id);\n+      --  Add formal parameters that match those of entry E to list Formals.\n+      --  The routine also adds matching actuals for the new formals to list\n+      --  Actuals.\n+\n+      procedure Transfer_Pragma (Prag : Node_Id; To : in out List_Id);\n+      --  Relocate pragma Prag to list To. The routine creates a new list if\n+      --  To does not exist.\n+\n+      --------------------------------\n+      -- Add_Discriminant_Renamings --\n+      --------------------------------\n+\n+      procedure Add_Discriminant_Renamings\n+        (Obj_Id : Entity_Id;\n+         Decls  : List_Id)\n+      is\n+         Discr         : Entity_Id;\n+         Renaming_Decl : Node_Id;\n+\n+      begin\n+         --  Inspect the discriminants of the concurrent type and generate a\n+         --  renaming for each one.\n+\n+         if Has_Discriminants (Conc_Typ) then\n+            Discr := First_Discriminant (Conc_Typ);\n+            while Present (Discr) loop\n+               Renaming_Decl :=\n+                 Make_Object_Renaming_Declaration (Loc,\n+                   Defining_Identifier =>\n+                     Make_Defining_Identifier (Loc, Chars (Discr)),\n+                   Subtype_Mark        =>\n+                     New_Occurrence_Of (Etype (Discr), Loc),\n+                   Name                =>\n+                     Make_Selected_Component (Loc,\n+                       Prefix        => New_Occurrence_Of (Obj_Id, Loc),\n+                       Selector_Name =>\n+                         Make_Identifier (Loc, Chars (Discr))));\n+\n+               Prepend_To (Decls, Renaming_Decl);\n+\n+               Next_Discriminant (Discr);\n+            end loop;\n+         end if;\n+      end Add_Discriminant_Renamings;\n+\n+      --------------------------\n+      -- Add_Matching_Formals --\n+      --------------------------\n+\n+      procedure Add_Matching_Formals\n+        (Formals : List_Id;\n+         Actuals : in out List_Id)\n+      is\n+         Formal     : Entity_Id;\n+         New_Formal : Entity_Id;\n+\n+      begin\n+         --  Inspect the formal parameters of the entry and generate a new\n+         --  matching formal with the same name for the wrapper. A reference\n+         --  to the new formal becomes an actual in the entry call.\n+\n+         Formal := First_Formal (E);\n+         while Present (Formal) loop\n+            New_Formal := Make_Defining_Identifier (Loc, Chars (Formal));\n+            Append_To (Formals,\n+              Make_Parameter_Specification (Loc,\n+                Defining_Identifier => New_Formal,\n+                In_Present          => In_Present  (Parent (Formal)),\n+                Out_Present         => Out_Present (Parent (Formal)),\n+                Parameter_Type      =>\n+                  New_Occurrence_Of (Etype (Formal), Loc)));\n+\n+            if No (Actuals) then\n+               Actuals := New_List;\n+            end if;\n+\n+            Append_To (Actuals, New_Occurrence_Of (New_Formal, Loc));\n+            Next_Formal (Formal);\n+         end loop;\n+      end Add_Matching_Formals;\n+\n+      ---------------------\n+      -- Transfer_Pragma --\n+      ---------------------\n+\n+      procedure Transfer_Pragma (Prag : Node_Id; To : in out List_Id) is\n+         New_Prag : Node_Id;\n+\n+      begin\n+         if No (To) then\n+            To := New_List;\n+         end if;\n+\n+         New_Prag := Relocate_Node (Prag);\n+\n+         Set_Analyzed (New_Prag, False);\n+         Append       (New_Prag, To);\n+      end Transfer_Pragma;\n+\n+      --  Local variables\n+\n+      Items      : constant Node_Id := Contract (E);\n+      Actuals    : List_Id := No_List;\n+      Call       : Node_Id;\n+      Call_Nam   : Node_Id;\n+      Decls      : List_Id := No_List;\n+      Formals    : List_Id;\n+      Has_Pragma : Boolean := False;\n+      Index_Id   : Entity_Id;\n+      Obj_Id     : Entity_Id;\n+      Prag       : Node_Id;\n+      Wrapper_Id : Entity_Id;\n+\n+   --  Start of processing for Build_Entry_Contract_Wrapper\n+\n+   begin\n+      --  This routine generates a specialized wrapper for a protected or task\n+      --  entry [family] which implements precondition/postcondition semantics.\n+      --  Preconditions and case guards of contract cases are checked before\n+      --  the protected action or rendezvous takes place.\n+\n+      --    procedure Wrapper\n+      --      (Obj_Id    : Conc_Typ;    --  concurrent object\n+      --       [Index    : Index_Typ;]  --  index of entry family\n+      --       [Formal_1 : ...;         --  parameters of original entry\n+      --        Formal_N : ...])\n+      --    is\n+      --       [Discr_1 : ... renames Obj_Id.Discr_1;   --  discriminant\n+      --        Discr_N : ... renames Obj_Id.Discr_N;]  --  renamings\n+\n+      --       <contracts pragmas>\n+      --       <case guard checks>\n+\n+      --    begin\n+      --       Entry_Call (Obj_Id, [Index,] [Formal_1, Formal_N]);\n+      --    end Wrapper;\n+\n+      --  Create the wrapper only when the entry has at least one executable\n+      --  contract item such as contract cases, precondition or postcondition.\n+\n+      if Present (Items) then\n+\n+         --  Inspect the list of pre/postconditions and transfer all available\n+         --  pragmas to the declarative list of the wrapper.\n+\n+         Prag := Pre_Post_Conditions (Items);\n+         while Present (Prag) loop\n+            if Pragma_Name_Unmapped (Prag) in Name_Postcondition\n+                                            | Name_Precondition\n+              and then Is_Checked (Prag)\n+            then\n+               Has_Pragma := True;\n+               Transfer_Pragma (Prag, To => Decls);\n+            end if;\n+\n+            Prag := Next_Pragma (Prag);\n+         end loop;\n+\n+         --  Inspect the list of test/contract cases and transfer only contract\n+         --  cases pragmas to the declarative part of the wrapper.\n+\n+         Prag := Contract_Test_Cases (Items);\n+         while Present (Prag) loop\n+            if Pragma_Name (Prag) = Name_Contract_Cases\n+              and then Is_Checked (Prag)\n+            then\n+               Has_Pragma := True;\n+               Transfer_Pragma (Prag, To => Decls);\n+            end if;\n+\n+            Prag := Next_Pragma (Prag);\n+         end loop;\n+      end if;\n+\n+      --  The entry lacks executable contract items and a wrapper is not needed\n+\n+      if not Has_Pragma then\n+         return;\n+      end if;\n+\n+      --  Create the profile of the wrapper. The first formal parameter is the\n+      --  concurrent object.\n+\n+      Obj_Id :=\n+        Make_Defining_Identifier (Loc,\n+          Chars => New_External_Name (Chars (Conc_Typ), 'A'));\n+\n+      Formals := New_List (\n+        Make_Parameter_Specification (Loc,\n+          Defining_Identifier => Obj_Id,\n+          Out_Present         => True,\n+          In_Present          => True,\n+          Parameter_Type      => New_Occurrence_Of (Conc_Typ, Loc)));\n+\n+      --  Construct the call to the original entry. The call will be gradually\n+      --  augmented with an optional entry index and extra parameters.\n+\n+      Call_Nam :=\n+        Make_Selected_Component (Loc,\n+          Prefix        => New_Occurrence_Of (Obj_Id, Loc),\n+          Selector_Name => New_Occurrence_Of (E, Loc));\n+\n+      --  When creating a wrapper for an entry family, the second formal is the\n+      --  entry index.\n+\n+      if Ekind (E) = E_Entry_Family then\n+         Index_Id := Make_Defining_Identifier (Loc, Name_I);\n+\n+         Append_To (Formals,\n+           Make_Parameter_Specification (Loc,\n+             Defining_Identifier => Index_Id,\n+             Parameter_Type      =>\n+               New_Occurrence_Of (Entry_Index_Type (E), Loc)));\n+\n+         --  The call to the original entry becomes an indexed component to\n+         --  accommodate the entry index.\n+\n+         Call_Nam :=\n+           Make_Indexed_Component (Loc,\n+             Prefix      => Call_Nam,\n+             Expressions => New_List (New_Occurrence_Of (Index_Id, Loc)));\n+      end if;\n+\n+      --  Add formal parameters to match those of the entry and build actuals\n+      --  for the entry call.\n+\n+      Add_Matching_Formals (Formals, Actuals);\n+\n+      Call :=\n+        Make_Procedure_Call_Statement (Loc,\n+          Name                   => Call_Nam,\n+          Parameter_Associations => Actuals);\n+\n+      --  Add renaming declarations for the discriminants of the enclosing type\n+      --  as the various contract items may reference them.\n+\n+      Add_Discriminant_Renamings (Obj_Id, Decls);\n+\n+      Wrapper_Id :=\n+        Make_Defining_Identifier (Loc, New_External_Name (Chars (E), 'E'));\n+      Set_Contract_Wrapper (E, Wrapper_Id);\n+      Set_Is_Entry_Wrapper (Wrapper_Id);\n+\n+      --  The wrapper body is analyzed when the enclosing type is frozen\n+\n+      Append_Freeze_Action (Defining_Entity (Decl),\n+        Make_Subprogram_Body (Loc,\n+          Specification              =>\n+            Make_Procedure_Specification (Loc,\n+              Defining_Unit_Name       => Wrapper_Id,\n+              Parameter_Specifications => Formals),\n+          Declarations               => Decls,\n+          Handled_Statement_Sequence =>\n+            Make_Handled_Sequence_Of_Statements (Loc,\n+              Statements => New_List (Call))));\n+   end Build_Entry_Contract_Wrapper;\n+\n    ---------------------------\n    -- Check_Class_Condition --\n    ---------------------------\n@@ -1804,24 +2357,17 @@ package body Contracts is\n       --  the item denotes a pragma, it is added to the list only when it is\n       --  enabled.\n \n-      procedure Build_Postconditions_Procedure\n-        (Subp_Id : Entity_Id;\n-         Stmts   : List_Id;\n-         Result  : Entity_Id);\n-      --  Create the body of procedure _Postconditions which handles various\n-      --  assertion actions on exit from subprogram Subp_Id. Stmts is the list\n-      --  of statements to be checked on exit. Parameter Result is the entity\n-      --  of parameter _Result when Subp_Id denotes a function.\n-\n-      procedure Process_Contract_Cases (Stmts : in out List_Id);\n+      procedure Process_Contract_Cases\n+        (Stmts : in out List_Id;\n+         Decls : List_Id);\n       --  Process pragma Contract_Cases. This routine prepends items to the\n       --  body declarations and appends items to list Stmts.\n \n       procedure Process_Postconditions (Stmts : in out List_Id);\n       --  Collect all [inherited] spec and body postconditions and accumulate\n       --  their pragma Check equivalents in list Stmts.\n \n-      procedure Process_Preconditions;\n+      procedure Process_Preconditions (Decls : in out List_Id);\n       --  Collect all [inherited] spec and body preconditions and prepend their\n       --  pragma Check equivalents to the declarations of the body.\n \n@@ -2309,260 +2855,14 @@ package body Contracts is\n          end if;\n       end Append_Enabled_Item;\n \n-      ------------------------------------\n-      -- Build_Postconditions_Procedure --\n-      ------------------------------------\n-\n-      procedure Build_Postconditions_Procedure\n-        (Subp_Id : Entity_Id;\n-         Stmts   : List_Id;\n-         Result  : Entity_Id)\n-      is\n-         Loc       : constant Source_Ptr := Sloc (Body_Decl);\n-         Last_Decl : Node_Id;\n-         Params    : List_Id := No_List;\n-         Proc_Bod  : Node_Id;\n-         Proc_Decl : Node_Id;\n-         Proc_Id   : Entity_Id;\n-         Proc_Spec : Node_Id;\n-\n-         --  Extra declarations needed to handle interactions between\n-         --  postconditions and finalization.\n-\n-         Postcond_Enabled_Decl : Node_Id;\n-         Return_Success_Decl   : Node_Id;\n-         Result_Obj_Decl       : Node_Id;\n-         Result_Obj_Type_Decl  : Node_Id;\n-         Result_Obj_Type       : Entity_Id;\n-\n-      --  Start of processing for Build_Postconditions_Procedure\n-\n-      begin\n-         --  Nothing to do if there are no actions to check on exit\n-\n-         if No (Stmts) then\n-            return;\n-         end if;\n-\n-         --  Otherwise, we generate the postcondition procedure and add\n-         --  associated objects and conditions used to coordinate postcondition\n-         --  evaluation with finalization.\n-\n-         --  Generate:\n-         --\n-         --    procedure _postconditions (Return_Exp : Result_Typ);\n-         --\n-         --    --  Result_Obj_Type created when Result_Type is non-elementary\n-         --    [type Result_Obj_Type is access all Result_Typ;]\n-         --\n-         --    Result_Obj : Result_Obj_Type;\n-         --\n-         --    Postcond_Enabled            : Boolean := True;\n-         --    Return_Success_For_Postcond : Boolean := False;\n-         --\n-         --    procedure _postconditions (Return_Exp : Result_Typ) is\n-         --    begin\n-         --       if Postcond_Enabled and then Return_Success_For_Postcond then\n-         --          [stmts];\n-         --       end if;\n-         --    end;\n-\n-         Proc_Id := Make_Defining_Identifier (Loc, Name_uPostconditions);\n-         Set_Debug_Info_Needed   (Proc_Id);\n-         Set_Postconditions_Proc (Subp_Id, Proc_Id);\n-\n-         --  Mark it inlined to speed up the call\n-\n-         Set_Is_Inlined (Proc_Id);\n-\n-         --  Force the front-end inlining of _Postconditions when generating C\n-         --  code, since its body may have references to itypes defined in the\n-         --  enclosing subprogram, which would cause problems for unnesting\n-         --  routines in the absence of inlining.\n-\n-         if Modify_Tree_For_C then\n-            Set_Has_Pragma_Inline        (Proc_Id);\n-            Set_Has_Pragma_Inline_Always (Proc_Id);\n-         end if;\n-\n-         --  The related subprogram is a function: create the specification of\n-         --  parameter _Result.\n-\n-         if Present (Result) then\n-            Params := New_List (\n-              Make_Parameter_Specification (Loc,\n-                Defining_Identifier => Result,\n-                Parameter_Type      =>\n-                  New_Occurrence_Of (Etype (Result), Loc)));\n-         end if;\n-\n-         Proc_Spec :=\n-           Make_Procedure_Specification (Loc,\n-             Defining_Unit_Name       => Proc_Id,\n-             Parameter_Specifications => Params);\n-\n-         Proc_Decl := Make_Subprogram_Declaration (Loc, Proc_Spec);\n-\n-         --  Insert _Postconditions before the first source declaration of the\n-         --  body. This ensures that the body will not cause any premature\n-         --  freezing, as it may mention types:\n-\n-         --  Generate:\n-         --\n-         --    procedure Proc (Obj : Array_Typ) is\n-         --       procedure _postconditions is\n-         --       begin\n-         --          ... Obj ...\n-         --       end _postconditions;\n-         --\n-         --       subtype T is Array_Typ (Obj'First (1) .. Obj'Last (1));\n-         --    begin\n-\n-         --  In the example above, Obj is of type T but the incorrect placement\n-         --  of _Postconditions will cause a crash in gigi due to an out-of-\n-         --  order reference. The body of _Postconditions must be placed after\n-         --  the declaration of Temp to preserve correct visibility.\n-\n-         Insert_Before_First_Source_Declaration\n-           (Proc_Decl, Declarations (Body_Decl));\n-         Analyze (Proc_Decl);\n-         Last_Decl := Proc_Decl;\n-\n-         --  When Result is present (e.g. the postcondition checks apply to a\n-         --  function) we make a local object to capture the result, so, if\n-         --  needed, we can call the generated postconditions procedure during\n-         --  finalization instead of at the point of return.\n-\n-         --  Note: The placement of the following declarations before the\n-         --  declaration of the body of the postconditions, but after the\n-         --  declaration of the postconditions spec is deliberate and required\n-         --  since other code within the expander expects them to be located\n-         --  here. Perhaps when more space is available in the tree this will\n-         --  no longer be necessary ???\n-\n-         if Present (Result) then\n-            --  Elementary result types mean a copy is cheap and preferred over\n-            --  using pointers.\n-\n-            if Is_Elementary_Type (Etype (Result)) then\n-               Result_Obj_Type := Etype (Result);\n-\n-            --  Otherwise, we create a named access type to capture the result\n-\n-            --  Generate:\n-            --\n-            --  type Result_Obj_Type is access all [Result_Type];\n-\n-            else\n-               Result_Obj_Type := Make_Temporary (Loc, 'R');\n-\n-               Result_Obj_Type_Decl :=\n-                 Make_Full_Type_Declaration (Loc,\n-                   Defining_Identifier => Result_Obj_Type,\n-                   Type_Definition     =>\n-                     Make_Access_To_Object_Definition (Loc,\n-                       All_Present        => True,\n-                       Subtype_Indication => New_Occurrence_Of\n-                                               (Etype (Result), Loc)));\n-               Insert_After_And_Analyze (Proc_Decl, Result_Obj_Type_Decl);\n-               Last_Decl := Result_Obj_Type_Decl;\n-            end if;\n-\n-            --  Create the result obj declaration\n-\n-            --  Generate:\n-            --\n-            --  Result_Object_For_Postcond : Result_Obj_Type;\n-\n-            Result_Obj_Decl :=\n-              Make_Object_Declaration (Loc,\n-                Defining_Identifier =>\n-                  Make_Defining_Identifier\n-                    (Loc, Name_uResult_Object_For_Postcond),\n-                Object_Definition   =>\n-                  New_Occurrence_Of\n-                    (Result_Obj_Type, Loc));\n-            Set_No_Initialization (Result_Obj_Decl);\n-            Insert_After_And_Analyze (Last_Decl, Result_Obj_Decl);\n-            Last_Decl := Result_Obj_Decl;\n-         end if;\n-\n-         --  Build the Postcond_Enabled flag used to delay evaluation of\n-         --  postconditions until finalization has been performed when cleanup\n-         --  actions are present.\n-\n-         --  NOTE: This flag could be made into a predicate since we should be\n-         --  able at compile time to recognize when finalization and cleanup\n-         --  actions occur, but in practice this is not possible ???\n-\n-         --  Generate:\n-         --\n-         --    Postcond_Enabled : Boolean := True;\n-\n-         Postcond_Enabled_Decl :=\n-           Make_Object_Declaration (Loc,\n-             Defining_Identifier =>\n-               Make_Defining_Identifier\n-                 (Loc, Name_uPostcond_Enabled),\n-             Object_Definition   => New_Occurrence_Of (Standard_Boolean, Loc),\n-             Expression          => New_Occurrence_Of (Standard_True, Loc));\n-         Insert_After_And_Analyze (Last_Decl, Postcond_Enabled_Decl);\n-         Last_Decl := Postcond_Enabled_Decl;\n-\n-         --  Create a flag to indicate that return has been reached\n-\n-         --  This is necessary for deciding whether to execute _postconditions\n-         --  during finalization.\n-\n-         --  Generate:\n-         --\n-         --    Return_Success_For_Postcond : Boolean := False;\n-\n-         Return_Success_Decl :=\n-           Make_Object_Declaration (Loc,\n-             Defining_Identifier =>\n-               Make_Defining_Identifier\n-                 (Loc, Name_uReturn_Success_For_Postcond),\n-             Object_Definition   => New_Occurrence_Of (Standard_Boolean, Loc),\n-             Expression          => New_Occurrence_Of (Standard_False, Loc));\n-         Insert_After_And_Analyze (Last_Decl, Return_Success_Decl);\n-         Last_Decl := Return_Success_Decl;\n-\n-         --  Set an explicit End_Label to override the sloc of the implicit\n-         --  RETURN statement, and prevent it from inheriting the sloc of one\n-         --  the postconditions: this would cause confusing debug info to be\n-         --  produced, interfering with coverage-analysis tools.\n-\n-         --  NOTE: Coverage-analysis and static-analysis tools rely on the\n-         --  postconditions procedure being free of internally generated code\n-         --  since some of these tools, like CodePeer, treat _postconditions\n-         --  as original source.\n-\n-         --  Generate:\n-         --\n-         --    procedure _postconditions is\n-         --    begin\n-         --       [Stmts];\n-         --    end;\n-\n-         Proc_Bod :=\n-           Make_Subprogram_Body (Loc,\n-             Specification              =>\n-               Copy_Subprogram_Spec (Proc_Spec),\n-             Declarations               => Empty_List,\n-             Handled_Statement_Sequence =>\n-               Make_Handled_Sequence_Of_Statements (Loc,\n-                 End_Label  => Make_Identifier (Loc, Chars (Proc_Id)),\n-                 Statements => Stmts));\n-         Insert_After_And_Analyze (Last_Decl, Proc_Bod);\n-\n-      end Build_Postconditions_Procedure;\n-\n       ----------------------------\n       -- Process_Contract_Cases --\n       ----------------------------\n \n-      procedure Process_Contract_Cases (Stmts : in out List_Id) is\n+      procedure Process_Contract_Cases\n+        (Stmts : in out List_Id;\n+         Decls : List_Id)\n+      is\n          procedure Process_Contract_Cases_For (Subp_Id : Entity_Id);\n          --  Process pragma Contract_Cases for subprogram Subp_Id\n \n@@ -2583,14 +2883,14 @@ package body Contracts is\n                         Expand_Pragma_Contract_Cases\n                           (CCs     => Prag,\n                            Subp_Id => Subp_Id,\n-                           Decls   => Declarations (Body_Decl),\n+                           Decls   => Decls,\n                            Stmts   => Stmts);\n \n                      elsif Pragma_Name (Prag) = Name_Subprogram_Variant then\n                         Expand_Pragma_Subprogram_Variant\n                           (Prag       => Prag,\n                            Subp_Id    => Subp_Id,\n-                           Body_Decls => Declarations (Body_Decl));\n+                           Body_Decls => Decls);\n                      end if;\n                   end if;\n \n@@ -2599,11 +2899,6 @@ package body Contracts is\n             end if;\n          end Process_Contract_Cases_For;\n \n-         pragma Unmodified (Stmts);\n-         --  Stmts is passed as IN OUT to signal that the list can be updated,\n-         --  even if the corresponding integer value representing the list does\n-         --  not change.\n-\n       --  Start of processing for Process_Contract_Cases\n \n       begin\n@@ -2829,15 +3124,11 @@ package body Contracts is\n       -- Process_Preconditions --\n       ---------------------------\n \n-      procedure Process_Preconditions is\n+      procedure Process_Preconditions (Decls : in out List_Id) is\n          Insert_Node : Node_Id := Empty;\n          --  The insertion node after which all pragma Check equivalents are\n          --  inserted.\n \n-         function Is_Prologue_Renaming (Decl : Node_Id) return Boolean;\n-         --  Determine whether arbitrary declaration Decl denotes a renaming of\n-         --  a discriminant or protection field _object.\n-\n          procedure Prepend_To_Decls (Item : Node_Id);\n          --  Prepend a single item to the declarations of the subprogram body\n \n@@ -2849,64 +3140,12 @@ package body Contracts is\n          --  Collect all preconditions of subprogram Subp_Id and prepend their\n          --  pragma Check equivalents to the declarations of the body.\n \n-         --------------------------\n-         -- Is_Prologue_Renaming --\n-         --------------------------\n-\n-         function Is_Prologue_Renaming (Decl : Node_Id) return Boolean is\n-            Nam  : Node_Id;\n-            Obj  : Entity_Id;\n-            Pref : Node_Id;\n-            Sel  : Node_Id;\n-\n-         begin\n-            if Nkind (Decl) = N_Object_Renaming_Declaration then\n-               Obj := Defining_Entity (Decl);\n-               Nam := Name (Decl);\n-\n-               if Nkind (Nam) = N_Selected_Component then\n-                  Pref := Prefix (Nam);\n-                  Sel  := Selector_Name (Nam);\n-\n-                  --  A discriminant renaming appears as\n-                  --    Discr : constant ... := Prefix.Discr;\n-\n-                  if Ekind (Obj) = E_Constant\n-                    and then Is_Entity_Name (Sel)\n-                    and then Present (Entity (Sel))\n-                    and then Ekind (Entity (Sel)) = E_Discriminant\n-                  then\n-                     return True;\n-\n-                  --  A protection field renaming appears as\n-                  --    Prot : ... := _object._object;\n-\n-                  --  A renamed private component is just a component of\n-                  --  _object, with an arbitrary name.\n-\n-                  elsif Ekind (Obj) in E_Variable | E_Constant\n-                    and then Nkind (Pref) = N_Identifier\n-                    and then Chars (Pref) = Name_uObject\n-                    and then Nkind (Sel) = N_Identifier\n-                  then\n-                     return True;\n-                  end if;\n-               end if;\n-            end if;\n-\n-            return False;\n-         end Is_Prologue_Renaming;\n-\n          ----------------------\n          -- Prepend_To_Decls --\n          ----------------------\n \n          procedure Prepend_To_Decls (Item : Node_Id) is\n-            Decls : List_Id;\n-\n          begin\n-            Decls := Declarations (Body_Decl);\n-\n             --  Ensure that the body has a declarative list\n \n             if No (Decls) then\n@@ -2937,14 +3176,8 @@ package body Contracts is\n \n             else\n                Check_Prag := Build_Pragma_Check_Equivalent (Prag);\n+               Prepend_To_Decls (Check_Prag);\n \n-               if Present (Insert_Node) then\n-                  Insert_After (Insert_Node, Check_Prag);\n-               else\n-                  Prepend_To_Decls (Check_Prag);\n-               end if;\n-\n-               Analyze (Check_Prag);\n             end if;\n          end Prepend_Pragma_To_Decls;\n \n@@ -3037,16 +3270,17 @@ package body Contracts is\n \n          --  Local variables\n \n-         Decls : constant List_Id := Declarations (Body_Decl);\n-         Decl  : Node_Id;\n+         Body_Decls : constant List_Id := Declarations (Body_Decl);\n+         Decl       : Node_Id;\n+         Next_Decl  : Node_Id;\n \n       --  Start of processing for Process_Preconditions\n \n       begin\n          --  Find the proper insertion point for all pragma Check equivalents\n \n-         if Present (Decls) then\n-            Decl := First (Decls);\n+         if Present (Body_Decls) then\n+            Decl := First (Body_Decls);\n             while Present (Decl) loop\n \n                --  First source declaration terminates the search, because all\n@@ -3091,6 +3325,19 @@ package body Contracts is\n             --    <preconditions from body>\n \n             Process_Preconditions_For (Body_Id);\n+\n+            --  Move the generated entry-call prologue renamings into the\n+            --  outer declarations for use in the preconditions.\n+\n+            Decl := First (Body_Decls);\n+            while Present (Decl) and then Present (Insert_Node) loop\n+               Next_Decl := Next (Decl);\n+               Remove (Decl);\n+               Prepend_To_Decls (Decl);\n+\n+               exit when Decl = Insert_Node;\n+               Decl := Next_Decl;\n+            end loop;\n          end if;\n \n          if Present (Spec_Id) then\n@@ -3103,6 +3350,7 @@ package body Contracts is\n       Restore_Scope : Boolean := False;\n       Result        : Entity_Id;\n       Stmts         : List_Id := No_List;\n+      Decls         : List_Id := New_List;\n       Subp_Id       : Entity_Id;\n \n    --  Start of processing for Expand_Subprogram_Contract\n@@ -3181,33 +3429,33 @@ package body Contracts is\n       --  pragmas to verify the contract assertions of the spec and body in a\n       --  particular order. The order is as follows:\n \n-      --    function Example (...) return ... is\n-      --       procedure _Postconditions (...) is\n+      --    function Original_Code (...) return ... is\n+      --       <prologue renamings>\n+      --       <inherited preconditions>\n+      --       <preconditions from spec>\n+      --       <preconditions from body>\n+      --       <contract case conditions>\n+\n+      --       function _Wrapped_Statements (...) return ... is\n+      --          <source declarations>\n+      --       begin\n+      --          <source statements>\n+      --       end _Wrapped_Statements;\n+\n+      --    begin\n+      --       declare\n+      --          Result : ... renames _Wrapped_Statements;\n       --       begin\n       --          <refined postconditions from body>\n       --          <postconditions from body>\n       --          <postconditions from spec>\n       --          <inherited postconditions>\n       --          <contract case consequences>\n       --          <invariant check of function result>\n-      --          <invariant and predicate checks of parameters>\n-      --       end _Postconditions;\n-\n-      --       <inherited preconditions>\n-      --       <preconditions from spec>\n-      --       <preconditions from body>\n-      --       <contract case conditions>\n-\n-      --       <source declarations>\n-      --    begin\n-      --       <source statements>\n-\n-      --       _Preconditions (Result);\n-      --       return Result;\n-      --    end Example;\n-\n-      --  Routine _Postconditions holds all contract assertions that must be\n-      --  verified on exit from the related subprogram.\n+      --          <invariant and predicate checks of parameters\n+      --          return Result;\n+      --       end;\n+      --    end Original_Code;\n \n       --  Step 1: augment contracts list with postconditions associated with\n       --  Stable_Properties and Stable_Properties'Class aspects. This must\n@@ -3222,7 +3470,7 @@ package body Contracts is\n       --  processing of pragma Contract_Cases because the pragma prepends items\n       --  to the body declarations.\n \n-      Process_Preconditions;\n+      Process_Preconditions (Decls);\n \n       --  Step 3: Handle all postconditions. This action must come before the\n       --  processing of pragma Contract_Cases because the pragma appends items\n@@ -3234,16 +3482,26 @@ package body Contracts is\n       --  the processing of invariants and predicates because those append\n       --  items to list Stmts.\n \n-      Process_Contract_Cases (Stmts);\n+      Process_Contract_Cases (Stmts, Decls);\n \n       --  Step 5: Apply invariant and predicate checks on a function result and\n       --  all formals. The resulting checks are accumulated in list Stmts.\n \n       Add_Invariant_And_Predicate_Checks (Subp_Id, Stmts, Result);\n \n-      --  Step 6: Construct procedure _Postconditions\n+      --  Step 6: Construct subprogram _wrapped_statements\n+\n+      --  When no statements are present we still need to insert contract\n+      --  related declarations.\n+\n+      if No (Stmts) then\n+         Prepend_List_To (Declarations (Body_Decl), Decls);\n \n-      Build_Postconditions_Procedure (Subp_Id, Stmts, Result);\n+      --  Otherwise, we need a wrapper\n+\n+      else\n+         Build_Subprogram_Contract_Wrapper (Body_Id, Stmts, Decls, Result);\n+      end if;\n \n       if Restore_Scope then\n          End_Scope;\n@@ -3448,81 +3706,6 @@ package body Contracts is\n       Freeze_Contracts;\n    end Freeze_Previous_Contracts;\n \n-   --------------------------\n-   -- Get_Postcond_Enabled --\n-   --------------------------\n-\n-   function Get_Postcond_Enabled (Subp : Entity_Id) return Entity_Id is\n-      Decl : Node_Id;\n-   begin\n-      Decl :=\n-        Next (Unit_Declaration_Node (Postconditions_Proc (Subp)));\n-      while Present (Decl) loop\n-\n-         if Nkind (Decl) = N_Object_Declaration\n-          and then Chars (Defining_Identifier (Decl))\n-                     = Name_uPostcond_Enabled\n-         then\n-            return Defining_Identifier (Decl);\n-         end if;\n-\n-         Next (Decl);\n-      end loop;\n-\n-      return Empty;\n-   end Get_Postcond_Enabled;\n-\n-   ------------------------------------\n-   -- Get_Result_Object_For_Postcond --\n-   ------------------------------------\n-\n-   function Get_Result_Object_For_Postcond\n-     (Subp : Entity_Id) return Entity_Id\n-   is\n-      Decl : Node_Id;\n-   begin\n-      Decl :=\n-        Next (Unit_Declaration_Node (Postconditions_Proc (Subp)));\n-      while Present (Decl) loop\n-\n-         if Nkind (Decl) = N_Object_Declaration\n-           and then Chars (Defining_Identifier (Decl))\n-                      = Name_uResult_Object_For_Postcond\n-         then\n-            return Defining_Identifier (Decl);\n-         end if;\n-\n-         Next (Decl);\n-      end loop;\n-\n-      return Empty;\n-   end Get_Result_Object_For_Postcond;\n-\n-   -------------------------------------\n-   -- Get_Return_Success_For_Postcond --\n-   -------------------------------------\n-\n-   function Get_Return_Success_For_Postcond (Subp : Entity_Id) return Entity_Id\n-   is\n-      Decl : Node_Id;\n-   begin\n-      Decl :=\n-        Next (Unit_Declaration_Node (Postconditions_Proc (Subp)));\n-      while Present (Decl) loop\n-\n-         if Nkind (Decl) = N_Object_Declaration\n-          and then Chars (Defining_Identifier (Decl))\n-                     = Name_uReturn_Success_For_Postcond\n-         then\n-            return Defining_Identifier (Decl);\n-         end if;\n-\n-         Next (Decl);\n-      end loop;\n-\n-      return Empty;\n-   end Get_Return_Success_For_Postcond;\n-\n    ---------------------------------\n    -- Inherit_Subprogram_Contract --\n    ---------------------------------\n@@ -3617,6 +3800,65 @@ package body Contracts is\n       end if;\n    end Instantiate_Subprogram_Contract;\n \n+   --------------------------\n+   -- Is_Prologue_Renaming --\n+   --------------------------\n+\n+   --  This should be turned into a flag and set during the expansion of\n+   --  task and protected types when the renamings get generated ???\n+\n+   function Is_Prologue_Renaming (Decl : Node_Id) return Boolean is\n+      Nam  : Node_Id;\n+      Obj  : Entity_Id;\n+      Pref : Node_Id;\n+      Sel  : Node_Id;\n+\n+   begin\n+      if Nkind (Decl) = N_Object_Renaming_Declaration\n+        and then not Comes_From_Source (Decl)\n+      then\n+         Obj := Defining_Entity (Decl);\n+         Nam := Name (Decl);\n+\n+         if Nkind (Nam) = N_Selected_Component then\n+            --  Analyze the renaming declaration so we can further examine it\n+\n+            if not Analyzed (Decl) then\n+               Analyze (Decl);\n+            end if;\n+\n+            Pref := Prefix (Nam);\n+            Sel  := Selector_Name (Nam);\n+\n+            --  A discriminant renaming appears as\n+            --    Discr : constant ... := Prefix.Discr;\n+\n+            if Ekind (Obj) = E_Constant\n+              and then Is_Entity_Name (Sel)\n+              and then Present (Entity (Sel))\n+              and then Ekind (Entity (Sel)) = E_Discriminant\n+            then\n+               return True;\n+\n+            --  A protection field renaming appears as\n+            --    Prot : ... := _object._object;\n+\n+            --  A renamed private component is just a component of\n+            --  _object, with an arbitrary name.\n+\n+            elsif Ekind (Obj) in E_Variable | E_Constant\n+              and then Nkind (Pref) = N_Identifier\n+              and then Chars (Pref) = Name_uObject\n+              and then Nkind (Sel) = N_Identifier\n+            then\n+               return True;\n+            end if;\n+         end if;\n+      end if;\n+\n+      return False;\n+   end Is_Prologue_Renaming;\n+\n    -----------------------------------\n    -- Make_Class_Precondition_Subps --\n    -----------------------------------"}, {"sha": "bde32ffc5b44a382a54880d97308dccad50eeed0", "filename": "gcc/ada/contracts.ads", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fcontracts.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fcontracts.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcontracts.ads?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -64,6 +64,16 @@ package Contracts is\n    procedure Analyze_Contracts (L : List_Id);\n    --  Analyze the contracts of all eligible constructs found in list L\n \n+   procedure Analyze_Pragmas_In_Declarations (Body_Id : Entity_Id);\n+   --  Perform early analysis of pragmas at the top of a given subprogram's\n+   --  declarations.\n+   --\n+   --  The purpose of this is to analyze contract-related pragmas for later\n+   --  processing, but also to handle other such pragmas before these\n+   --  declarations get moved to an internal wrapper as part of contract\n+   --  expansion. For example, pragmas Inline, Ghost, Volatile all need to\n+   --  apply directly to the subprogram and not be moved to a wrapper.\n+\n    procedure Analyze_Entry_Or_Subprogram_Body_Contract (Body_Id : Entity_Id);\n    --  Analyze all delayed pragmas chained on the contract of entry or\n    --  subprogram body Body_Id as if they appeared at the end of a declarative\n@@ -177,6 +187,17 @@ package Contracts is\n    --    Depends\n    --    Global\n \n+   procedure Build_Entry_Contract_Wrapper (E : Entity_Id; Decl : Node_Id);\n+   --  Build the body of a wrapper procedure for an entry or entry family that\n+   --  has contract cases, preconditions, or postconditions, and add it to the\n+   --  freeze actions of the related synchronized type.\n+   --\n+   --  The body first verifies the preconditions and case guards of the\n+   --  contract cases, then invokes the entry [family], and finally verifies\n+   --  the postconditions and the consequences of the contract cases. E denotes\n+   --  the entry family. Decl denotes the declaration of the enclosing\n+   --  synchronized type.\n+\n    procedure Create_Generic_Contract (Unit : Node_Id);\n    --  Create a contract node for a generic package, generic subprogram, or a\n    --  generic body denoted by Unit by collecting all source contract-related\n@@ -188,21 +209,6 @@ package Contracts is\n    --  denoted by Body_Decl. In addition, freeze the contract of the nearest\n    --  enclosing package body.\n \n-   function Get_Postcond_Enabled (Subp : Entity_Id) return Entity_Id;\n-   --  Get the defining identifier for a subprogram's Postcond_Enabled\n-   --  object created during the expansion of the subprogram's postconditions.\n-\n-   function Get_Result_Object_For_Postcond (Subp : Entity_Id) return Entity_Id;\n-   --  Get the defining identifier for a subprogram's\n-   --  Result_Object_For_Postcond object created during the expansion of the\n-   --  subprogram's postconditions.\n-\n-   function Get_Return_Success_For_Postcond\n-     (Subp : Entity_Id) return Entity_Id;\n-   --  Get the defining identifier for a subprogram's\n-   --  Return_Success_For_Postcond object created during the expansion of the\n-   --  subprogram's postconditions.\n-\n    procedure Inherit_Subprogram_Contract\n      (Subp      : Entity_Id;\n       From_Subp : Entity_Id);"}, {"sha": "94e729e9bcc455e9a3ed9ba5e0f20c34cf53b245", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -142,7 +142,7 @@ package body Debug is\n    --  d_a  Stop elaboration checks on accept or select statement\n    --  d_b  Use designated type model under No_Dynamic_Accessibility_Checks\n    --  d_c  CUDA compilation : compile for the host\n-   --  d_d\n+   --  d_d  CUDA compilation : compile for the device\n    --  d_e  Ignore entry calls and requeue statements for elaboration\n    --  d_f  Issue info messages related to GNATprove usage\n    --  d_g  Disable large static aggregates\n@@ -201,7 +201,7 @@ package body Debug is\n    --  d6   Default access unconstrained to thin pointers\n    --  d7   Suppress version/source stamp/compilation time for -gnatv/-gnatl\n    --  d8   Force opposite endianness in packed stuff\n-   --  d9   Allow lock free implementation\n+   --  d9\n \n    --  d.1  Enable unnesting of nested procedures\n    --  d.2  Allow statements in declarative part\n@@ -345,8 +345,8 @@ package body Debug is\n \n    --  d_a  Ignore the effects of pragma Elaborate_All\n    --  d_b  Ignore the effects of pragma Elaborate_Body\n-   --  d_c\n-   --  d_d\n+   --  d_c  CUDA compilation : compile/bind for the host\n+   --  d_d  CUDA compilation : compile/bind for the device\n    --  d_e  Ignore the effects of pragma Elaborate\n    --  d_f\n    --  d_g\n@@ -1089,9 +1089,6 @@ package body Debug is\n    --       opposite endianness from the actual correct value. Useful in\n    --       testing out code generation from the packed routines.\n \n-   --  d9   This allows lock free implementation for protected objects\n-   --       (see Exp_Ch9).\n-\n    --  d.1  Sets Opt.Unnest_Subprogram_Mode to enable unnesting of subprograms.\n    --       This special pass does not actually unnest things, but it ensures\n    --       that a nested procedure does not contain any uplevel references."}, {"sha": "4541f2bc70b23f391d3015b968f449353d7682a0", "filename": "gcc/ada/doc/gnat_rm/implementation_defined_aspects.rst", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_aspects.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_aspects.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_aspects.rst?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -317,23 +317,27 @@ The following is a typical example of use:\n   type List is private with\n       Iterable => (First       => First_Cursor,\n                    Next        => Advance,\n-                   Has_Element => Cursor_Has_Element,\n-                  [Element     => Get_Element]);\n+                   Has_Element => Cursor_Has_Element\n+                 [,Element     => Get_Element]\n+                 [,Last        => Last_Cursor]\n+                 [,Previous    => Retreat]);\n \n-* The value denoted by ``First`` must denote a primitive operation of the\n-  container type that returns a ``Cursor``, which must a be a type declared in\n+* The values of ``First`` and ``Last`` are primitive operations of the\n+  container type that return a ``Cursor``, which must be a type declared in\n   the container package or visible from it. For example:\n \n .. code-block:: ada\n \n   function First_Cursor (Cont : Container) return Cursor;\n+  function Last_Cursor  (Cont : Container) return Cursor;\n \n-* The value of ``Next`` is a primitive operation of the container type that takes\n-  both a container and a cursor and yields a cursor. For example:\n+* The values of ``Next`` and ``Previous`` are primitive operations of the container type that take\n+  both a container and a cursor and yield a cursor. For example:\n \n .. code-block:: ada\n \n   function Advance (Cont : Container; Position : Cursor) return Cursor;\n+  function Retreat (Cont : Container; Position : Cursor) return Cursor;\n \n * The value of ``Has_Element`` is a primitive operation of the container type\n   that takes both a container and a cursor and yields a boolean. For example:"}, {"sha": "c25e3d441582787c2eafb95a108cc8862565405f", "filename": "gcc/ada/doc/gnat_rm/implementation_defined_attributes.rst", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_attributes.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_attributes.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_attributes.rst?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -606,13 +606,6 @@ in this example:\n   end Gen;\n \n \n-Attribute Lock_Free\n-===================\n-.. index:: Lock_Free\n-\n-``P'Lock_Free``, where P is a protected object, returns True if a\n-pragma ``Lock_Free`` applies to P.\n-\n Attribute Loop_Entry\n ====================\n .. index:: Loop_Entry"}, {"sha": "53836c9fbcf202b36a752be390cde91a4eaadfbf", "filename": "gcc/ada/doc/gnat_rm/implementation_defined_pragmas.rst", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_pragmas.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_pragmas.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_pragmas.rst?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -2262,7 +2262,8 @@ of GNAT specific extensions are recognized as follows:\n   will not be executed if the earlier alternative \"matches\"). All possible\n   values of the composite type shall be covered. The composite type of the\n   selector shall be an array or record type that is neither limited\n-  class-wide.\n+  class-wide. Currently, a \"when others =>\" case choice is required; it is\n+  intended that this requirement will be relaxed at some point.\n \n   If a subcomponent's subtype does not meet certain restrictions, then\n   the only value that can be specified for that subcomponent in a case\n@@ -3751,7 +3752,12 @@ In addition, each protected subprogram body must satisfy:\n * May not dereferenced access values\n * Function calls and attribute references must be static\n \n-\n+If the Lock_Free aspect is specified to be True for a protected unit\n+and the Ceiling_Locking locking policy is in effect, then the run-time\n+actions associated with the Ceiling_Locking locking policy (described in\n+Ada RM D.3) are not performed when a protected operation of the protected\n+unit is executed.\n+  \n Pragma Loop_Invariant\n =====================\n \n@@ -7119,7 +7125,7 @@ be.\n \n For the variable case, warnings are never given for unreferenced variables\n whose name contains one of the substrings\n-``DISCARD, DUMMY, IGNORE, JUNK, UNUSED`` in any casing. Such names\n+``DISCARD, DUMMY, IGNORE, JUNK, UNUSE, TMP, TEMP`` in any casing. Such names\n are typically to be used in cases where such warnings are expected.\n Thus it is never necessary to use ``pragma Unmodified`` for such\n variables, though it is harmless to do so."}, {"sha": "f8e2a58595fb2bc01e1dc91576725bf8df2e6119", "filename": "gcc/ada/doc/gnat_rm/standard_and_implementation_defined_restrictions.rst", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fstandard_and_implementation_defined_restrictions.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fstandard_and_implementation_defined_restrictions.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fstandard_and_implementation_defined_restrictions.rst?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -184,7 +184,9 @@ No_Dependence\n .. index:: No_Dependence\n \n [RM 13.12.1] This restriction ensures at compile time that there are no\n-dependences on a library unit.\n+dependences on a library unit. For GNAT, this includes implicit implementation\n+dependences on units of the runtime library that are created by the compiler\n+to support specific constructs of the language.\n \n No_Direct_Boolean_Operators\n ---------------------------"}, {"sha": "d791f8120ac8d36a7e1742d5fb75609376651a11", "filename": "gcc/ada/doc/gnat_rm/the_gnat_library.rst", "status": "modified", "additions": 0, "deletions": 219, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fthe_gnat_library.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fthe_gnat_library.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fthe_gnat_library.rst?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -120,225 +120,6 @@ instead of ``Character``.  The provision of such a package\n is specifically authorized by the Ada Reference Manual\n (RM A.3.3(27)).\n \n-.. _`Ada.Containers.Formal_Doubly_Linked_Lists_(a-cfdlli.ads)`:\n-\n-``Ada.Containers.Formal_Doubly_Linked_Lists`` (:file:`a-cfdlli.ads`)\n-====================================================================\n-\n-.. index:: Ada.Containers.Formal_Doubly_Linked_Lists (a-cfdlli.ads)\n-\n-.. index:: Formal container for doubly linked lists\n-\n-This child of ``Ada.Containers`` defines a modified version of the\n-Ada 2005 container for doubly linked lists, meant to facilitate formal\n-verification of code using such containers. The specification of this\n-unit is compatible with SPARK 2014.\n-\n-Note that although this container was designed with formal verification\n-in mind, it may well be generally useful in that it is a simplified more\n-efficient version than the one defined in the standard. In particular it\n-does not have the complex overhead required to detect cursor tampering.\n-\n-.. _`Ada.Containers.Formal_Hashed_Maps_(a-cfhama.ads)`:\n-\n-``Ada.Containers.Formal_Hashed_Maps`` (:file:`a-cfhama.ads`)\n-============================================================\n-\n-.. index:: Ada.Containers.Formal_Hashed_Maps (a-cfhama.ads)\n-\n-.. index:: Formal container for hashed maps\n-\n-This child of ``Ada.Containers`` defines a modified version of the\n-Ada 2005 container for hashed maps, meant to facilitate formal\n-verification of code using such containers. The specification of this\n-unit is compatible with SPARK 2014.\n-\n-Note that although this container was designed with formal verification\n-in mind, it may well be generally useful in that it is a simplified more\n-efficient version than the one defined in the standard. In particular it\n-does not have the complex overhead required to detect cursor tampering.\n-\n-.. _`Ada.Containers.Formal_Hashed_Sets_(a-cfhase.ads)`:\n-\n-``Ada.Containers.Formal_Hashed_Sets`` (:file:`a-cfhase.ads`)\n-============================================================\n-\n-.. index:: Ada.Containers.Formal_Hashed_Sets (a-cfhase.ads)\n-\n-.. index:: Formal container for hashed sets\n-\n-This child of ``Ada.Containers`` defines a modified version of the\n-Ada 2005 container for hashed sets, meant to facilitate formal\n-verification of code using such containers. The specification of this\n-unit is compatible with SPARK 2014.\n-\n-Note that although this container was designed with formal verification\n-in mind, it may well be generally useful in that it is a simplified more\n-efficient version than the one defined in the standard. In particular it\n-does not have the complex overhead required to detect cursor tampering.\n-\n-.. _`Ada.Containers.Formal_Ordered_Maps_(a-cforma.ads)`:\n-\n-``Ada.Containers.Formal_Ordered_Maps`` (:file:`a-cforma.ads`)\n-=============================================================\n-\n-.. index:: Ada.Containers.Formal_Ordered_Maps (a-cforma.ads)\n-\n-.. index:: Formal container for ordered maps\n-\n-This child of ``Ada.Containers`` defines a modified version of the\n-Ada 2005 container for ordered maps, meant to facilitate formal\n-verification of code using such containers. The specification of this\n-unit is compatible with SPARK 2014.\n-\n-Note that although this container was designed with formal verification\n-in mind, it may well be generally useful in that it is a simplified more\n-efficient version than the one defined in the standard. In particular it\n-does not have the complex overhead required to detect cursor tampering.\n-\n-.. _`Ada.Containers.Formal_Ordered_Sets_(a-cforse.ads)`:\n-\n-``Ada.Containers.Formal_Ordered_Sets`` (:file:`a-cforse.ads`)\n-=============================================================\n-\n-.. index:: Ada.Containers.Formal_Ordered_Sets (a-cforse.ads)\n-\n-.. index:: Formal container for ordered sets\n-\n-This child of ``Ada.Containers`` defines a modified version of the\n-Ada 2005 container for ordered sets, meant to facilitate formal\n-verification of code using such containers. The specification of this\n-unit is compatible with SPARK 2014.\n-\n-Note that although this container was designed with formal verification\n-in mind, it may well be generally useful in that it is a simplified more\n-efficient version than the one defined in the standard. In particular it\n-does not have the complex overhead required to detect cursor tampering.\n-\n-.. _`Ada.Containers.Formal_Vectors_(a-cofove.ads)`:\n-\n-``Ada.Containers.Formal_Vectors`` (:file:`a-cofove.ads`)\n-========================================================\n-\n-.. index:: Ada.Containers.Formal_Vectors (a-cofove.ads)\n-\n-.. index:: Formal container for vectors\n-\n-This child of ``Ada.Containers`` defines a modified version of the\n-Ada 2005 container for vectors, meant to facilitate formal\n-verification of code using such containers. The specification of this\n-unit is compatible with SPARK 2014.\n-\n-Note that although this container was designed with formal verification\n-in mind, it may well be generally useful in that it is a simplified more\n-efficient version than the one defined in the standard. In particular it\n-does not have the complex overhead required to detect cursor tampering.\n-\n-.. _`Ada.Containers.Formal_Indefinite_Vectors_(a-cfinve.ads)`:\n-\n-``Ada.Containers.Formal_Indefinite_Vectors`` (:file:`a-cfinve.ads`)\n-===================================================================\n-\n-.. index:: Ada.Containers.Formal_Indefinite_Vectors (a-cfinve.ads)\n-\n-.. index:: Formal container for vectors\n-\n-This child of ``Ada.Containers`` defines a modified version of the\n-Ada 2005 container for vectors of indefinite elements, meant to\n-facilitate formal verification of code using such containers. The\n-specification of this unit is compatible with SPARK 2014.\n-\n-Note that although this container was designed with formal verification\n-in mind, it may well be generally useful in that it is a simplified more\n-efficient version than the one defined in the standard. In particular it\n-does not have the complex overhead required to detect cursor tampering.\n-\n-.. _`Ada.Containers.Functional_Infinite_Sequences_(a-cfinse.ads)`:\n-\n-``Ada.Containers.Functional_Infinite_Sequences`` (:file:`a-cfinse.ads`)\n-=======================================================================\n-\n-.. index:: Ada.Containers.Functional_Infinite_Sequences (a-cfinse.ads)\n-\n-.. index:: Functional Infinite Sequences\n-\n-This child of ``Ada.Containers`` defines immutable sequences indexed by\n-``Big_Integer``. These containers are unbounded and may contain indefinite\n-elements. Their API features functions creating new containers from existing\n-ones. To remain reasonably efficient, their implementation involves sharing\n-between data-structures. As they are functional, that is, no primitives are\n-provided which would allow modifying an existing container, these containers\n-can still be used safely.\n-\n-These containers are controlled so that the allocated memory can be reclaimed\n-when the container is no longer referenced. Thus, they cannot directly be used\n-in contexts where controlled types are not supported.\n-The specification of this unit is compatible with SPARK 2014.\n-\n-.. _`Ada.Containers.Functional_Vectors_(a-cofuve.ads)`:\n-\n-``Ada.Containers.Functional_Vectors`` (:file:`a-cofuve.ads`)\n-============================================================\n-\n-.. index:: Ada.Containers.Functional_Vectors (a-cofuve.ads)\n-\n-.. index:: Functional vectors\n-\n-This child of ``Ada.Containers`` defines immutable vectors. These\n-containers are unbounded and may contain indefinite elements. Furthermore, to\n-be usable in every context, they are neither controlled nor limited. As they\n-are functional, that is, no primitives are provided which would allow modifying\n-an existing container, these containers can still be used safely.\n-\n-Their API features functions creating new containers from existing ones.\n-As a consequence, these containers are highly inefficient. They are also\n-memory consuming, as the allocated memory is not reclaimed when the container\n-is no longer referenced. Thus, they should in general be used in ghost code\n-and annotations, so that they can be removed from the final executable. The\n-specification of this unit is compatible with SPARK 2014.\n-\n-.. _`Ada.Containers.Functional_Sets_(a-cofuse.ads)`:\n-\n-``Ada.Containers.Functional_Sets`` (:file:`a-cofuse.ads`)\n-=========================================================\n-\n-.. index:: Ada.Containers.Functional_Sets (a-cofuse.ads)\n-\n-.. index:: Functional sets\n-\n-This child of ``Ada.Containers`` defines immutable sets. These containers are\n-unbounded and may contain indefinite elements. Their API features functions\n-creating new containers from existing ones. To remain reasonably efficient,\n-their implementation involves sharing between data-structures. As they are\n-functional, that is, no primitives are provided which would allow modifying an\n-existing container, these containers can still be used safely.\n-\n-These containers are controlled so that the allocated memory can be reclaimed\n-when the container is no longer referenced. Thus, they cannot directly be used\n-in contexts where controlled types are not supported.\n-The specification of this unit is compatible with SPARK 2014.\n-\n-.. _`Ada.Containers.Functional_Maps_(a-cofuma.ads)`:\n-\n-``Ada.Containers.Functional_Maps`` (:file:`a-cofuma.ads`)\n-=========================================================\n-\n-.. index:: Ada.Containers.Functional_Maps (a-cofuma.ads)\n-\n-.. index:: Functional maps\n-\n-This child of ``Ada.Containers`` defines immutable maps. These containers are\n-unbounded and may contain indefinite elements. Their API features functions\n-creating new containers from existing ones. To remain reasonably efficient,\n-their implementation involves sharing between data-structures. As they are\n-functional, that is, no primitives are provided which would allow modifying an\n-existing container, these containers can still be used safely.\n-\n-These containers are controlled so that the allocated memory can be reclaimed\n-when the container is no longer referenced. Thus, they cannot directly be used\n-in contexts where controlled types are not supported.\n-The specification of this unit is compatible with SPARK 2014.\n-\n .. _`Ada.Containers.Bounded_Holders_(a-coboho.ads)`:\n \n ``Ada.Containers.Bounded_Holders`` (:file:`a-coboho.ads`)"}, {"sha": "6a478095cfcb700821d635fb17a1abc9e1139315", "filename": "gcc/ada/doc/gnat_ugn/building_executable_programs_with_gnat.rst", "status": "modified", "additions": 60, "deletions": 37, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fbuilding_executable_programs_with_gnat.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fbuilding_executable_programs_with_gnat.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fbuilding_executable_programs_with_gnat.rst?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -4455,29 +4455,31 @@ to the default checks required by Ada as described above.\n \n   All validity checks are turned on.\n   That is, :switch:`-gnatVa` is\n-  equivalent to ``gnatVcdfimoprst``.\n+  equivalent to ``gnatVcdefimoprst``.\n \n \n .. index:: -gnatVc  (gcc)\n \n :switch:`-gnatVc`\n   *Validity checks for copies.*\n \n-  The right hand side of assignments, and the initializing values of\n-  object declarations are validity checked.\n+  The right-hand side of assignments, and the (explicit) initializing values\n+  of object declarations are validity checked.\n \n \n .. index:: -gnatVd  (gcc)\n \n :switch:`-gnatVd`\n   *Default (RM) validity checks.*\n \n-  Some validity checks are done by default following normal Ada semantics\n-  (RM 13.9.1 (9-11)).\n-  A check is done in case statements that the expression is within the range\n-  of the subtype. If it is not, Constraint_Error is raised.\n-  For assignments to array components, a check is done that the expression used\n-  as index is within the range. If it is not, Constraint_Error is raised.\n+  Some validity checks are required by Ada (see RM 13.9.1 (9-11)); these\n+  (and only these) validity checks are enabled by default.\n+  For case statements (and case expressions) that lack a \"when others =>\"\n+  choice, a check is made that the value of the selector expression\n+  belongs to its nominal subtype. If it does not, Constraint_Error is raised.\n+  For assignments to array components (and for indexed components in some\n+  other contexts), a check is made that each index expression belongs to the\n+  corresponding index subtype. If it does not, Constraint_Error is raised.\n   Both these validity checks may be turned off using switch :switch:`-gnatVD`.\n   They are turned on by default. If :switch:`-gnatVD` is specified, a subsequent\n   switch :switch:`-gnatVd` will leave the checks turned on.\n@@ -4490,28 +4492,31 @@ to the default checks required by Ada as described above.\n .. index:: -gnatVe  (gcc)\n \n :switch:`-gnatVe`\n-  *Validity checks for elementary components.*\n-\n-  In the absence of this switch, assignments to record or array components are\n-  not validity checked, even if validity checks for assignments generally\n-  (:switch:`-gnatVc`) are turned on. In Ada, assignment of composite values do not\n-  require valid data, but assignment of individual components does. So for\n-  example, there is a difference between copying the elements of an array with a\n-  slice assignment, compared to assigning element by element in a loop. This\n-  switch allows you to turn off validity checking for components, even when they\n-  are assigned component by component.\n+  *Validity checks for scalar components.*\n \n+  In the absence of this switch, assignments to scalar components of\n+  enclosing record or array objects are not validity checked, even if\n+  validity checks for assignments generally (:switch:`-gnatVc`) are turned on.\n+  Specifying this switch enables such checks.\n+  This switch has no effect if the :switch:`-gnatVc` switch is not specified.\n \n .. index:: -gnatVf  (gcc)\n \n :switch:`-gnatVf`\n   *Validity checks for floating-point values.*\n \n-  In the absence of this switch, validity checking occurs only for discrete\n-  values. If :switch:`-gnatVf` is specified, then validity checking also applies\n+  Specifying this switch enables validity checking for floating-point\n+  values in the same contexts where validity checking is enabled for\n+  other scalar values.\n+  In the absence of this switch, validity checking is not performed for\n+  floating-point values. This takes precedence over other statements about\n+  performing validity checking for scalar objects in various scenarios.\n+  One way to look at it is that if this switch is not set, then whenever\n+  any of the other rules in this section use the word \"scalar\" they\n+  really mean \"scalar and not floating-point\".\n+  If :switch:`-gnatVf` is specified, then validity checking also applies\n   for floating-point values, and NaNs and infinities are considered invalid,\n-  as well as out of range values for constrained types. Note that this means\n-  that standard IEEE infinity mode is not allowed. The exact contexts\n+  as well as out-of-range values for constrained types. The exact contexts\n   in which floating-point values are checked depends on the setting of other\n   options. For example, :switch:`-gnatVif` or :switch:`-gnatVfi`\n   (the order does not matter) specifies that floating-point parameters of mode\n@@ -4558,7 +4563,8 @@ to the default checks required by Ada as described above.\n :switch:`-gnatVo`\n   *Validity checks for operator and attribute operands.*\n \n-  Arguments for predefined operators and attributes are validity checked.\n+  Scalar arguments for predefined operators and for attributes are\n+  validity checked.\n   This includes all operators in package ``Standard``,\n   the shift operators defined as intrinsic in package ``Interfaces``\n   and operands for attributes such as ``Pos``. Checks are also made\n@@ -4572,22 +4578,22 @@ to the default checks required by Ada as described above.\n :switch:`-gnatVp`\n   *Validity checks for parameters.*\n \n-  This controls the treatment of parameters within a subprogram (as opposed\n-  to :switch:`-gnatVi` and :switch:`-gnatVm` which control validity testing\n-  of parameters on a call. If either of these call options is used, then\n-  normally an assumption is made within a subprogram that the input arguments\n-  have been validity checking at the point of call, and do not need checking\n-  again within a subprogram). If :switch:`-gnatVp` is set, then this assumption\n-  is not made, and parameters are not assumed to be valid, so their validity\n-  will be checked (or rechecked) within the subprogram.\n-\n+  This controls the treatment of formal parameters within a subprogram (as\n+  opposed to :switch:`-gnatVi` and :switch:`-gnatVm`, which control validity\n+  testing of actual parameters of a call). If either of these call options is\n+  specified, then normally an assumption is made within a subprogram that\n+  the validity of any incoming formal parameters of the corresponding mode(s)\n+  has already been checked at the point of call and does not need rechecking.\n+  If :switch:`-gnatVp` is set, then this assumption is not made and so their\n+  validity may be checked (or rechecked) within the subprogram. If neither of\n+  the two call-related options is specified, then this switch has no effect.\n \n .. index:: -gnatVr  (gcc)\n \n :switch:`-gnatVr`\n   *Validity checks for function returns.*\n \n-  The expression in ``return`` statements in functions is validity\n+  The expression in simple ``return`` statements in functions is validity\n   checked.\n \n \n@@ -4596,9 +4602,10 @@ to the default checks required by Ada as described above.\n :switch:`-gnatVs`\n   *Validity checks for subscripts.*\n \n-  All subscripts expressions are checked for validity, whether they appear\n-  on the right side or left side (in default mode only left side subscripts\n-  are validity checked).\n+  All subscript expressions are checked for validity, whatever context\n+  they occur in (in default mode some subscripts are not validity checked;\n+  for example, validity checking may be omitted in some cases involving\n+  a read of a component of an array).\n \n \n .. index:: -gnatVt  (gcc)\n@@ -6534,6 +6541,22 @@ be presented in subsequent sections.\n   ALI file named in the ``gnatbind`` command line.\n \n \n+  .. index:: -k  (gnatbind)\n+\n+:switch:`-k`\n+  Disable checking of elaboration flags. When using :switch:`-n`\n+  either explicitly or implicitly, :switch:`-F` is also implied,\n+  unless :switch:`-k` is used. This switch should be used with care\n+  and you should ensure manually that elaboration routines are not called\n+  twice unintentionally.\n+\n+\n+  .. index:: -K  (gnatbind)\n+\n+:switch:`-K`\n+  Give list of linker options specified for link.\n+\n+\n   .. index:: -l  (gnatbind)\n \n :switch:`-l`"}, {"sha": "0d78e433e733a959cb40f213defd59ab70bb32aa", "filename": "gcc/ada/doc/gnat_ugn/gnat_and_program_execution.rst", "status": "modified", "additions": 100, "deletions": 82, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fgnat_and_program_execution.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fgnat_and_program_execution.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fgnat_and_program_execution.rst?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -756,12 +756,14 @@ for a complete list of supported platforms.\n .. rubric:: Tracebacks From an Unhandled Exception\n \n A runtime non-symbolic traceback is a list of addresses of call instructions.\n-To enable this feature you must use the :switch:`-E`\n-``gnatbind`` option. With this option a stack traceback is stored as part\n-of exception information. You can retrieve this information using the\n-``addr2line`` tool.\n+To enable this feature you must use the :switch:`-E` ``gnatbind`` option. With\n+this option a stack traceback is stored as part of exception information.\n \n-Here is a simple example:\n+You can translate this information using the ``addr2line`` tool, provided that\n+the program is compiled with debugging options (see :ref:`Switches_for_gcc`)\n+and linked at a fixed position with :switch:`-no-pie`.\n+\n+Here is a simple example with ``gnatmake``:\n \n   .. code-block:: ada\n \n@@ -783,94 +785,110 @@ Here is a simple example:\n \n   ::\n \n-     $ gnatmake stb -bargs -E\n+     $ gnatmake stb -g -bargs -E -largs -no-pie\n      $ stb\n \n-     Execution terminated by unhandled exception\n-     Exception name: CONSTRAINT_ERROR\n-     Message: stb.adb:5\n+     Execution of stb terminated by unhandled exception\n+     raised CONSTRAINT_ERROR : stb.adb:5 explicit raise\n+     Load address: 0x400000\n      Call stack traceback locations:\n      0x401373 0x40138b 0x40139c 0x401335 0x4011c4 0x4011f1 0x77e892a4\n \n As we see the traceback lists a sequence of addresses for the unhandled\n exception ``CONSTRAINT_ERROR`` raised in procedure P1. It is easy to\n guess that this exception come from procedure P1. To translate these\n-addresses into the source lines where the calls appear, the\n-``addr2line`` tool, described below, is invaluable. The use of this tool\n-requires the program to be compiled with debug information.\n+addresses into the source lines where the calls appear, the ``addr2line``\n+tool needs to be invoked like this:\n \n   ::\n \n-     $ gnatmake -g stb -bargs -E\n-     $ stb\n-\n-     Execution terminated by unhandled exception\n-     Exception name: CONSTRAINT_ERROR\n-     Message: stb.adb:5\n-     Call stack traceback locations:\n-     0x401373 0x40138b 0x40139c 0x401335 0x4011c4 0x4011f1 0x77e892a4\n-\n-     $ addr2line --exe=stb 0x401373 0x40138b 0x40139c 0x401335 0x4011c4\n+     $ addr2line -e stb 0x401373 0x40138b 0x40139c 0x401335 0x4011c4\n         0x4011f1 0x77e892a4\n \n-     00401373 at d:/stb/stb.adb:5\n-     0040138B at d:/stb/stb.adb:10\n-     0040139C at d:/stb/stb.adb:14\n-     00401335 at d:/stb/b~stb.adb:104\n-     004011C4 at /build/.../crt1.c:200\n-     004011F1 at /build/.../crt1.c:222\n-     77E892A4 in ?? at ??:0\n+     d:/stb/stb.adb:5\n+     d:/stb/stb.adb:10\n+     d:/stb/stb.adb:14\n+     d:/stb/b~stb.adb:197\n+     crtexe.c:?\n+     crtexe.c:?\n+     ??:0\n \n The ``addr2line`` tool has several other useful options:\n \n-  ======================== ========================================================\n-  :samp:`--functions`      to get the function name corresponding to any location\n-  :samp:`--demangle=gnat`  to use the gnat decoding mode for the function names.\n-                           Note that for binutils version 2.9.x the option is\n-                           simply :samp:`--demangle`.\n-  ======================== ========================================================\n+  =========================  ====================================================\n+  :samp:`-a --addresses`     to show the addresses alongside the line numbers\n+  :samp:`-f --functions`     to get the function name corresponding to a location\n+  :samp:`-p --pretty-print`  to print all the information on a single line\n+  :samp:`--demangle=gnat`    to use the GNAT decoding mode for the function names\n+  =========================  ====================================================\n \n   ::\n \n-     $ addr2line --exe=stb --functions --demangle=gnat 0x401373 0x40138b\n-        0x40139c 0x401335 0x4011c4 0x4011f1\n+     $ addr2line -e stb -a -f -p --demangle=gnat 0x401373 0x40138b\n+        0x40139c 0x401335 0x4011c4 0x4011f1 0x77e892a4\n+\n+     0x00401373: stb.p1 at d:/stb/stb.adb:5\n+     0x0040138B: stb.p2 at d:/stb/stb.adb:10\n+     0x0040139C: stb at d:/stb/stb.adb:14\n+     0x00401335: main at d:/stb/b~stb.adb:197\n+     0x004011c4: ?? at crtexe.c:?\n+     0x004011f1: ?? at crtexe.c:?\n+     0x77e892a4: ?? ??:0\n \n-     00401373 in stb.p1 at d:/stb/stb.adb:5\n-     0040138B in stb.p2 at d:/stb/stb.adb:10\n-     0040139C in stb at d:/stb/stb.adb:14\n-     00401335 in main at d:/stb/b~stb.adb:104\n-     004011C4 in <__mingw_CRTStartup> at /build/.../crt1.c:200\n-     004011F1 in <mainCRTStartup> at /build/.../crt1.c:222\n \n-From this traceback we can see that the exception was raised in\n-:file:`stb.adb` at line 5, which was reached from a procedure call in\n-:file:`stb.adb` at line 10, and so on. The :file:`b~std.adb` is the binder file,\n-which contains the call to the main program.\n-:ref:`Running_gnatbind`. The remaining entries are assorted runtime routines,\n-and the output will vary from platform to platform.\n+From this traceback we can see that the exception was raised in :file:`stb.adb`\n+at line 5, which was reached from a procedure call in :file:`stb.adb` at line\n+10, and so on. The :file:`b~std.adb` is the binder file, which contains the\n+call to the main program. :ref:`Running_gnatbind`. The remaining entries are\n+assorted runtime routines and the output will vary from platform to platform.\n \n It is also possible to use ``GDB`` with these traceback addresses to debug\n the program. For example, we can break at a given code location, as reported\n-in the stack traceback:\n-\n-  ::\n+in the stack traceback::\n \n      $ gdb -nw stb\n \n-Furthermore, this feature is not implemented inside Windows DLL. Only\n-the non-symbolic traceback is reported in this case.\n-\n-  ::\n-\n      (gdb) break *0x401373\n      Breakpoint 1 at 0x401373: file stb.adb, line 5.\n \n-It is important to note that the stack traceback addresses\n-do not change when debug information is included. This is particularly useful\n-because it makes it possible to release software without debug information (to\n-minimize object size), get a field report that includes a stack traceback\n-whenever an internal bug occurs, and then be able to retrieve the sequence\n-of calls with the same program compiled with debug information.\n+It is important to note that the stack traceback addresses do not change when\n+debug information is included. This is particularly useful because it makes it\n+possible to release software without debug information (to minimize object\n+size), get a field report that includes a stack traceback whenever an internal\n+bug occurs, and then be able to retrieve the sequence of calls with the same\n+program compiled with debug information.\n+\n+However the ``addr2line`` tool does not work with Position-Independent Code\n+(PIC), the historical example being Windows DLLs, which nowadays encompasses\n+Position-Independent Executables (PIE) on recent Windows versions.\n+\n+In order to translate addresses into the source lines with Position-Independent\n+Executables on recent Windows versions, in other words without using the switch\n+:switch:`-no-pie` during linking, you need to use the ``gnatsymbolize`` tool\n+with :switch:`--load` instead of the ``addr2line`` tool. The main difference\n+is that you need to copy the Load Address output in the traceback ahead of the\n+sequence of addresses. And the default mode of ``gnatsymbolize`` is equivalent\n+to that of ``addr2line`` with the above switches, so none of them is needed::\n+\n+     $ gnatmake stb -g -bargs -E\n+     $ stb\n+\n+     Execution of stb terminated by unhandled exception\n+     raised CONSTRAINT_ERROR : stb.adb:5 explicit raise\n+     Load address: 0x400000\n+     Call stack traceback locations:\n+     0x401373 0x40138b 0x40139c 0x401335 0x4011c4 0x4011f1 0x77e892a4\n+\n+     $ gnatsymbolize --load stb 0x400000 0x401373 0x40138b 0x40139c 0x401335\n+        0x4011c4 0x4011f1 0x77e892a4\n+\n+     0x00401373 Stb.P1 at stb.adb:5\n+     0x0040138B Stb.P2 at stb.adb:10\n+     0x0040139C Stb at stb.adb:14\n+     0x00401335 Main at b~stb.adb:197\n+     0x004011c4 __tmainCRTStartup at ???\n+     0x004011f1 mainCRTStartup at ???\n+     0x77e892a4 ??? at ???\n \n \n .. rubric:: Tracebacks From Exception Occurrences\n@@ -914,25 +932,24 @@ This program will output:\n \n      $ stb\n \n-     Exception name: CONSTRAINT_ERROR\n-     Message: stb.adb:12\n+     raised CONSTRAINT_ERROR : stb.adb:12 range check failed\n+     Load address: 0x400000\n      Call stack traceback locations:\n      0x4015e4 0x401633 0x401644 0x401461 0x4011c4 0x4011f1 0x77e892a4\n \n \n .. rubric:: Tracebacks From Anywhere in a Program\n \n-It is also possible to retrieve a stack traceback from anywhere in a\n-program. For this you need to\n-use the ``GNAT.Traceback`` API. This package includes a procedure called\n-``Call_Chain`` that computes a complete stack traceback, as well as useful\n-display procedures described below. It is not necessary to use the\n-:switch:`-E` ``gnatbind`` option in this case, because the stack traceback mechanism\n-is invoked explicitly.\n+It is also possible to retrieve a stack traceback from anywhere in a program.\n+For this you need to use the ``GNAT.Traceback`` API. This package includes a\n+procedure called ``Call_Chain`` that computes a complete stack traceback, as\n+well as useful display procedures described below. It is not necessary to use\n+the :switch:`-E` ``gnatbind`` option in this case, because the stack traceback\n+mechanism is invoked explicitly.\n \n-In the following example we compute a traceback at a specific location in\n-the program, and we display it using ``GNAT.Debug_Utilities.Image`` to\n-convert addresses to strings:\n+In the following example we compute a traceback at a specific location in the\n+program, and we display it using ``GNAT.Debug_Utilities.Image`` to convert\n+addresses to strings:\n \n \n   .. code-block:: ada\n@@ -976,16 +993,16 @@ convert addresses to strings:\n \n   ::\n \n-     $ gnatmake -g stb\n+     $ gnatmake stb -g\n      $ stb\n \n      In STB.P1 : 16#0040_F1E4# 16#0040_14F2# 16#0040_170B# 16#0040_171C#\n      16#0040_1461# 16#0040_11C4# 16#0040_11F1# 16#77E8_92A4#\n \n \n-You can then get further information by invoking the ``addr2line``\n-tool as described earlier (note that the hexadecimal addresses\n-need to be specified in C format, with a leading '0x').\n+You can then get further information by invoking the ``addr2line`` tool or\n+the ``gnatsymbolize`` tool as described earlier (note that the hexadecimal\n+addresses need to be specified in C format, with a leading '0x').\n \n .. index:: traceback, symbolic\n \n@@ -3716,12 +3733,13 @@ execution of this erroneous program:\n   allocation and deallocation routines. This is done by linking with the\n   :file:`libgmem.a` library. For correct symbolic backtrace information,\n   the user program should also both be compiled with debugging options\n-  (see :ref:`Switches_for_gcc`) and be linked at a fixed position. For\n-  example to build :file:`my_program` with ``gnatmake``:\n+  (see :ref:`Switches_for_gcc`) and be linked at a fixed position with\n+  :switch:`-no-pie`. For example to build :file:`my_program` with\n+  ``gnatmake``:\n \n     ::\n \n-       $ gnatmake -g my_program -largs -lgmem -no-pie\n+       $ gnatmake my_program -g -largs -lgmem -no-pie\n \n   As library :file:`libgmem.a` contains an alternate body for package\n   ``System.Memory``, :file:`s-memory.adb` should not be compiled and linked"}, {"sha": "b7c9bdc51cc5fadb9a5e2d61f9986d49c7886c54", "filename": "gcc/ada/einfo-utils.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Feinfo-utils.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Feinfo-utils.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo-utils.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -2081,7 +2081,7 @@ package body Einfo.Utils is\n    --------------------\n \n    function Number_Entries (Id : E) return Nat is\n-      N   : Int;\n+      N   : Nat;\n       Ent : Entity_Id;\n \n    begin"}, {"sha": "7ac8cf6e99a745890a45d549f480ef1939824d2c", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -4014,9 +4014,7 @@ package Einfo is\n --       fully initialized when the full view is frozen.\n \n --    Postconditions_Proc\n---       Defined in functions, procedures, entries, and entry families. Refers\n---       to the entity of the _Postconditions procedure used to check contract\n---       assertions on exit from a subprogram.\n+--       Obsolete field which can be removed once CodePeer is fixed ???\n \n --    Predicate_Function (synthesized)\n --       Defined in all types. Set for types for which (Has_Predicates is True)\n@@ -4767,6 +4765,13 @@ package Einfo is\n --       Defined in functions and procedures which have been classified as\n --       Is_Primitive_Wrapper. Set to the entity being wrapper.\n \n+--    Wrapped_Statements\n+--       Defined in functions, procedures, entries, and entry families. Refers\n+--       to the entity of the _Wrapped_Statements procedure which gets\n+--       generated as part of the expansion of contracts and postconditions\n+--       and contains its enclosing subprogram's original source declarations\n+--       and statements.\n+\n --    LSP_Subprogram\n --       Defined in subprogram entities. Set on wrappers created to handle\n --       inherited class-wide pre/post conditions that call overridden\n@@ -5412,7 +5417,6 @@ package Einfo is\n    --    Protected_Body_Subprogram\n    --    Barrier_Function\n    --    Elaboration_Entity\n-   --    Postconditions_Proc\n    --    Entry_Parameters_Type\n    --    First_Entity\n    --    Alias                                (for entry only. Empty)\n@@ -5527,7 +5531,6 @@ package Einfo is\n    --    Protected_Body_Subprogram\n    --    Next_Inlined_Subprogram\n    --    Elaboration_Entity                   (not implicit /=)\n-   --    Postconditions_Proc                  (non-generic case only)\n    --    DT_Position\n    --    DTC_Entity\n    --    First_Entity\n@@ -5891,7 +5894,6 @@ package Einfo is\n    --    Protected_Body_Subprogram\n    --    Next_Inlined_Subprogram\n    --    Elaboration_Entity\n-   --    Postconditions_Proc                  (non-generic case only)\n    --    DT_Position\n    --    DTC_Entity\n    --    First_Entity"}, {"sha": "d0cbe9fdff11759e81be513ec3cffb68ff8bb685", "filename": "gcc/ada/erroutc.adb", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Ferroutc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Ferroutc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferroutc.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -1317,8 +1317,8 @@ package body Erroutc is\n             Name_Len := Name_Len - 1;\n          end if;\n \n-         --  If operator name or character literal name, just print it as is\n-         --  Also print as is if it ends in a right paren (case of x'val(nnn))\n+         --  If operator name or character literal name, just print it as is.\n+         --  Also print as is if it ends in a right paren (case of x'val(nnn)).\n \n          if Name_Buffer (1) = '\"'\n            or else Name_Buffer (1) = '''\n@@ -1534,6 +1534,32 @@ package body Erroutc is\n       elsif Text = \"_TYPE_INVARIANT\" then\n          Set_Msg_Str (\"TYPE_INVARIANT'CLASS\");\n \n+      --  Preserve casing for names that include acronyms\n+\n+      elsif Text = \"Cpp_Class\" then\n+         Set_Msg_Str (\"CPP_Class\");\n+\n+      elsif Text = \"Cpp_Constructor\" then\n+         Set_Msg_Str (\"CPP_Constructor\");\n+\n+      elsif Text = \"Cpp_Virtual\" then\n+         Set_Msg_Str (\"CPP_Virtual\");\n+\n+      elsif Text = \"Cpp_Vtable\" then\n+         Set_Msg_Str (\"CPP_Vtable\");\n+\n+      elsif Text = \"Persistent_Bss\" then\n+         Set_Msg_Str (\"Persistent_BSS\");\n+\n+      elsif Text = \"Spark_Mode\" then\n+         Set_Msg_Str (\"SPARK_Mode\");\n+\n+      elsif Text = \"Use_Vads_Size\" then\n+         Set_Msg_Str (\"Use_VADS_Size\");\n+\n+      elsif Text = \"Vads_Size\" then\n+         Set_Msg_Str (\"VADS_size\");\n+\n       --  Normal case with no replacement\n \n       else"}, {"sha": "185705544e93b6699e85aee5cec6ae4458f3d42d", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 29, "deletions": 9, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -5734,7 +5734,8 @@ package body Exp_Aggr is\n \n       procedure Check_Bounds (Aggr_Bounds_Node, Index_Bounds_Node : Node_Id);\n       --  Checks that the bounds of Aggr_Bounds are within the bounds defined\n-      --  by Index_Bounds.\n+      --  by Index_Bounds. For null array aggregate (Ada 2022) check that the\n+      --  aggregate bounds define a null range.\n \n       procedure Check_Same_Aggr_Bounds (Sub_Aggr : Node_Id; Dim : Pos);\n       --  Checks that in a multidimensional array aggregate all subaggregates\n@@ -5850,6 +5851,22 @@ package body Exp_Aggr is\n          Cond : Node_Id := Empty;\n \n       begin\n+         --  For a null array aggregate check that high bound (i.e., low\n+         --  bound predecessor) exists. Fail if low bound is low bound of\n+         --  base subtype (in all cases, including modular).\n+\n+         if Is_Null_Aggregate (N) then\n+            Insert_Action (N,\n+              Make_Raise_Constraint_Error (Loc,\n+                Condition =>\n+                  Make_Op_Eq (Loc,\n+                    New_Copy_Tree (Aggr_Bounds.First),\n+                    New_Copy_Tree\n+                      (Type_Low_Bound (Base_Type (Etype (Ind_Bounds.First))))),\n+                Reason    => CE_Range_Check_Failed));\n+            return;\n+         end if;\n+\n          --  Generate the following test:\n \n          --    [constraint_error when\n@@ -6430,7 +6447,7 @@ package body Exp_Aggr is\n                          Left_Opnd  => New_Occurrence_Of (Size_Id, Loc),\n                          Right_Opnd => Make_Integer_Literal (Loc, 1)));\n \n-            One_Loop := Make_Loop_Statement (Loc,\n+            One_Loop := Make_Implicit_Loop_Statement (N,\n               Iteration_Scheme =>\n                 Make_Iteration_Scheme (Loc,\n                   Iterator_Specification => New_Copy_Tree (Iter)),\n@@ -6536,7 +6553,7 @@ package body Exp_Aggr is\n                     Prefix => New_Occurrence_Of (TmpE, Loc),\n                     Expressions =>\n                       New_List (New_Occurrence_Of (Index_Id, Loc))),\n-               Expression => New_Copy_Tree (Expression (Assoc)));\n+               Expression => Copy_Separate_Tree (Expression (Assoc)));\n \n             --  Advance index position for insertion.\n \n@@ -6562,7 +6579,7 @@ package body Exp_Aggr is\n                       Attribute_Name => Name_Last)),\n                Then_Statements => New_List (Incr));\n \n-            One_Loop := Make_Loop_Statement (Loc,\n+            One_Loop := Make_Implicit_Loop_Statement (N,\n               Iteration_Scheme =>\n                 Make_Iteration_Scheme (Loc,\n                   Iterator_Specification => Copy_Separate_Tree (Iter)),\n@@ -7500,11 +7517,11 @@ package body Exp_Aggr is\n \n             --  Iterated_Component_Association.\n \n-            Loop_Id :=\n-              Make_Defining_Identifier (Loc,\n-                Chars => Chars (Defining_Identifier (Comp)));\n-\n             if Present (Iterator_Specification (Comp)) then\n+               Loop_Id :=\n+                 Make_Defining_Identifier (Loc,\n+                   Chars => Chars (Defining_Identifier\n+                              (Iterator_Specification (Comp))));\n                L_Iteration_Scheme :=\n                  Make_Iteration_Scheme (Loc,\n                    Iterator_Specification => Iterator_Specification (Comp));\n@@ -7513,6 +7530,9 @@ package body Exp_Aggr is\n                --  Loop_Parameter_Specification is parsed with a choice list.\n                --  where the range is the first (and only) choice.\n \n+               Loop_Id :=\n+                 Make_Defining_Identifier (Loc,\n+                   Chars => Chars (Defining_Identifier (Comp)));\n                L_Range := Relocate_Node (First (Discrete_Choices (Comp)));\n \n                L_Iteration_Scheme :=\n@@ -7997,7 +8017,7 @@ package body Exp_Aggr is\n          end if;\n \n          return\n-           Make_Loop_Statement (Loc,\n+           Make_Implicit_Loop_Statement (C,\n              Iteration_Scheme =>\n                Make_Iteration_Scheme (Sl,\n                  Loop_Parameter_Specification =>"}, {"sha": "0e79b5d10cd7a1ea9de7428c207b8fc3b1f9d602", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 87, "deletions": 69, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -2079,7 +2079,8 @@ package body Exp_Attr is\n \n       case Id is\n \n-      --  Attributes related to Ada 2012 iterators\n+      --  Attributes related to Ada 2012 iterators. They are only allowed in\n+      --  attribute definition clauses and should never be expanded.\n \n       when Attribute_Constant_Indexing\n          | Attribute_Default_Iterator\n@@ -2088,7 +2089,7 @@ package body Exp_Attr is\n          | Attribute_Iterator_Element\n          | Attribute_Variable_Indexing\n       =>\n-         null;\n+         raise Program_Error;\n \n       --  Internal attributes used to deal with Ada 2012 delayed aspects. These\n       --  were already rejected by the parser. Thus they shouldn't appear here.\n@@ -4883,7 +4884,6 @@ package body Exp_Attr is\n       ---------\n \n       when Attribute_Old => Old : declare\n-         Typ     : constant Entity_Id := Etype (N);\n          CW_Temp : Entity_Id;\n          CW_Typ  : Entity_Id;\n          Decl    : Node_Id;\n@@ -4895,24 +4895,25 @@ package body Exp_Attr is\n          use Old_Attr_Util.Indirect_Temps;\n       begin\n          --  Generating C code we don't need to expand this attribute when\n-         --  we are analyzing the internally built nested postconditions\n+         --  we are analyzing the internally built nested _Wrapped_Statements\n          --  procedure since it will be expanded inline (and later it will\n          --  be removed by Expand_N_Subprogram_Body). It this expansion is\n          --  performed in such case then the compiler generates unreferenced\n          --  extra temporaries.\n \n          if Modify_Tree_For_C\n-           and then Chars (Current_Scope) = Name_uPostconditions\n+           and then Chars (Current_Scope) = Name_uWrapped_Statements\n          then\n             return;\n          end if;\n \n-         --  Climb the parent chain looking for subprogram _Postconditions\n+         --  Climb the parent chain looking for subprogram _Wrapped_Statements\n \n          Subp := N;\n          while Present (Subp) loop\n             exit when Nkind (Subp) = N_Subprogram_Body\n-              and then Chars (Defining_Entity (Subp)) = Name_uPostconditions;\n+              and then Chars (Defining_Entity (Subp))\n+                         = Name_uWrapped_Statements;\n \n             --  If assertions are disabled, no need to create the declaration\n             --  that preserves the value. The postcondition pragma in which\n@@ -4925,14 +4926,11 @@ package body Exp_Attr is\n \n             Subp := Parent (Subp);\n          end loop;\n+         Subp := Empty;\n \n-         --  'Old can only appear in a postcondition, the generated body of\n-         --  _Postconditions must be in the tree (or inlined if we are\n-         --  generating C code).\n-\n-         pragma Assert\n-           (Present (Subp)\n-             or else (Modify_Tree_For_C and then In_Inlined_Body));\n+         --  'Old can only appear in the case where local contract-related\n+         --  wrapper has been generated with the purpose of wrapping the\n+         --  original declarations and statements.\n \n          Temp := Make_Temporary (Loc, 'T', Pref);\n \n@@ -4952,8 +4950,7 @@ package body Exp_Attr is\n          --  No need to push the scope when generating C code since the\n          --  _Postcondition procedure has been inlined.\n \n-         else pragma Assert (Modify_Tree_For_C);\n-            pragma Assert (In_Inlined_Body);\n+         else\n             null;\n          end if;\n \n@@ -4963,17 +4960,23 @@ package body Exp_Attr is\n          if Present (Subp) then\n             Ins_Nod := Subp;\n \n-         --  Generating C, the postcondition procedure has been inlined and the\n-         --  temporary is added before the first declaration of the enclosing\n-         --  subprogram.\n+         --  General case where the postcondtion checks occur after the call\n+         --  to _Wrapped_Statements.\n \n-         else pragma Assert (Modify_Tree_For_C);\n+         else\n             Ins_Nod := N;\n             while Nkind (Ins_Nod) /= N_Subprogram_Body loop\n                Ins_Nod := Parent (Ins_Nod);\n             end loop;\n \n-            Ins_Nod := First (Declarations (Ins_Nod));\n+            if Present (Corresponding_Spec (Ins_Nod))\n+              and then Present\n+                         (Wrapped_Statements (Corresponding_Spec (Ins_Nod)))\n+            then\n+               Ins_Nod := Last (Declarations (Ins_Nod));\n+            else\n+               Ins_Nod := First (Declarations (Ins_Nod));\n+            end if;\n          end if;\n \n          if Eligible_For_Conditional_Evaluation (N) then\n@@ -4986,9 +4989,9 @@ package body Exp_Attr is\n                --  unconditionally) or an evaluation statement (which is\n                --  to be executed conditionally).\n \n-               -------------------------------\n-               --  Append_For_Indirect_Temp --\n-               -------------------------------\n+               ------------------------------\n+               -- Append_For_Indirect_Temp --\n+               ------------------------------\n \n                procedure Append_For_Indirect_Temp\n                  (N : Node_Id; Is_Eval_Stmt : Boolean)\n@@ -5008,7 +5011,7 @@ package body Exp_Attr is\n                Declare_Indirect_Temporary\n                  (Attr_Prefix => Pref, Indirect_Temp => Temp);\n \n-               Insert_Before_And_Analyze (\n+               Insert_After_And_Analyze (\n                  Ins_Nod,\n                  Make_If_Statement\n                    (Sloc            => Loc,\n@@ -5085,7 +5088,17 @@ package body Exp_Attr is\n          --  to reflect the new placement of the prefix.\n \n          if Validity_Checks_On and then Validity_Check_Operands then\n-            Ensure_Valid (Expression (Decl));\n+\n+            --  Object declaration that captures the attribute prefix might\n+            --  be rewritten into object renaming declaration.\n+\n+            if Nkind (Decl) = N_Object_Declaration then\n+               Ensure_Valid (Expression (Decl));\n+            else\n+               pragma Assert (Nkind (Decl) = N_Object_Renaming_Declaration\n+                              and then Is_Rewrite_Substitution (Decl));\n+               Ensure_Valid (Name (Decl));\n+            end if;\n          end if;\n \n          Rewrite (N, New_Occurrence_Of (Temp, Loc));\n@@ -5667,33 +5680,35 @@ package body Exp_Attr is\n       --  which is illegal, because of the lack of aliasing.\n \n       when Attribute_Priority => Priority : declare\n-         Call           : Node_Id;\n-         Conctyp        : Entity_Id;\n-         New_Itype      : Entity_Id;\n-         Object_Parm    : Node_Id;\n-         Subprg         : Entity_Id;\n-         RT_Subprg_Name : Node_Id;\n+         Call        : Node_Id;\n+         New_Itype   : Entity_Id;\n+         Object_Parm : Node_Id;\n+         Prottyp     : Entity_Id;\n+         RT_Subprg   : RE_Id;\n+         Subprg      : Entity_Id;\n \n       begin\n-         --  Look for the enclosing concurrent type\n+         --  Look for the enclosing protected type\n \n-         Conctyp := Current_Scope;\n-         while not Is_Concurrent_Type (Conctyp) loop\n-            Conctyp := Scope (Conctyp);\n+         Prottyp := Current_Scope;\n+         while not Is_Protected_Type (Prottyp) loop\n+            Prottyp := Scope (Prottyp);\n          end loop;\n \n-         pragma Assert (Is_Protected_Type (Conctyp));\n+         pragma Assert (Is_Protected_Type (Prottyp));\n \n          --  Generate the actual of the call\n \n          Subprg := Current_Scope;\n-         while not Present (Protected_Body_Subprogram (Subprg)) loop\n+         while not (Is_Subprogram_Or_Entry (Subprg)\n+                    and then Present (Protected_Body_Subprogram (Subprg)))\n+         loop\n             Subprg := Scope (Subprg);\n          end loop;\n \n          --  Use of 'Priority inside protected entries and barriers (in both\n          --  cases the type of the first formal of their expanded subprogram\n-         --  is Address)\n+         --  is Address).\n \n          if Etype (First_Entity (Protected_Body_Subprogram (Subprg))) =\n               RTE (RE_Address)\n@@ -5708,7 +5723,7 @@ package body Exp_Attr is\n             New_Itype := Create_Itype (E_Access_Type, N);\n             Set_Etype (New_Itype, New_Itype);\n             Set_Directly_Designated_Type (New_Itype,\n-              Corresponding_Record_Type (Conctyp));\n+              Corresponding_Record_Type (Prottyp));\n             Freeze_Itype (New_Itype, N);\n \n             --  Generate:\n@@ -5743,15 +5758,16 @@ package body Exp_Attr is\n \n          --  Select the appropriate run-time subprogram\n \n-         if Number_Entries (Conctyp) = 0 then\n-            RT_Subprg_Name := New_Occurrence_Of (RTE (RE_Get_Ceiling), Loc);\n+         if Has_Entries (Prottyp) then\n+            RT_Subprg := RO_PE_Get_Ceiling;\n          else\n-            RT_Subprg_Name := New_Occurrence_Of (RTE (RO_PE_Get_Ceiling), Loc);\n+            RT_Subprg := RE_Get_Ceiling;\n          end if;\n \n          Call :=\n            Make_Function_Call (Loc,\n-             Name                   => RT_Subprg_Name,\n+             Name                   =>\n+               New_Occurrence_Of (RTE (RT_Subprg), Loc),\n              Parameter_Associations => New_List (Object_Parm));\n \n          Rewrite (N, Call);\n@@ -7099,7 +7115,11 @@ package body Exp_Attr is\n       --  See separate sections below for the generated code in each case.\n \n       when Attribute_Valid => Valid : declare\n-         PBtyp : Entity_Id := Base_Type (Ptyp);\n+         PBtyp : Entity_Id := Implementation_Base_Type (Validated_View (Ptyp));\n+         pragma Assert (Is_Scalar_Type (PBtyp)\n+                          or else Serious_Errors_Detected > 0);\n+\n+         --  The scalar base type, looking through private types\n \n          Save_Validity_Checks_On : constant Boolean := Validity_Checks_On;\n          --  Save the validity checking mode. We always turn off validity\n@@ -7146,21 +7166,27 @@ package body Exp_Attr is\n                Temp := Duplicate_Subexpr (Pref);\n             end if;\n \n-            return\n-              Make_In (Loc,\n-                Left_Opnd  => Unchecked_Convert_To (PBtyp, Temp),\n-                Right_Opnd =>\n-                  Make_Range (Loc,\n-                    Low_Bound  =>\n-                      Unchecked_Convert_To (PBtyp,\n-                        Make_Attribute_Reference (Loc,\n-                          Prefix         => New_Occurrence_Of (Ptyp, Loc),\n-                          Attribute_Name => Name_First)),\n-                    High_Bound =>\n-                      Unchecked_Convert_To (PBtyp,\n-                        Make_Attribute_Reference (Loc,\n-                          Prefix         => New_Occurrence_Of (Ptyp, Loc),\n-                          Attribute_Name => Name_Last))));\n+            declare\n+               Val_Typ : constant Entity_Id := Validated_View (Ptyp);\n+            begin\n+               return\n+                 Make_In (Loc,\n+                   Left_Opnd  => Unchecked_Convert_To (PBtyp, Temp),\n+                   Right_Opnd =>\n+                     Make_Range (Loc,\n+                       Low_Bound  =>\n+                         Unchecked_Convert_To (PBtyp,\n+                           Make_Attribute_Reference (Loc,\n+                             Prefix         =>\n+                               New_Occurrence_Of (Val_Typ, Loc),\n+                             Attribute_Name => Name_First)),\n+                       High_Bound =>\n+                         Unchecked_Convert_To (PBtyp,\n+                           Make_Attribute_Reference (Loc,\n+                             Prefix         =>\n+                               New_Occurrence_Of (Val_Typ, Loc),\n+                             Attribute_Name => Name_Last))));\n+            end;\n          end Make_Range_Test;\n \n          --  Local variables\n@@ -7182,13 +7208,6 @@ package body Exp_Attr is\n \n          Validity_Checks_On := False;\n \n-         --  Retrieve the base type. Handle the case where the base type is a\n-         --  private enumeration type.\n-\n-         if Is_Private_Type (PBtyp) and then Present (Full_View (PBtyp)) then\n-            PBtyp := Full_View (PBtyp);\n-         end if;\n-\n          --  Floating-point case. This case is handled by the Valid attribute\n          --  code in the floating-point attribute run-time library.\n \n@@ -7458,7 +7477,7 @@ package body Exp_Attr is\n                Uns  : constant Boolean :=\n                         Is_Unsigned_Type (Ptyp)\n                           or else (Is_Private_Type (Ptyp)\n-                                    and then Is_Unsigned_Type (Btyp));\n+                                    and then Is_Unsigned_Type (PBtyp));\n                Size : Uint;\n                P    : Node_Id := Pref;\n \n@@ -7943,7 +7962,6 @@ package body Exp_Attr is\n          | Attribute_Large\n          | Attribute_Last_Valid\n          | Attribute_Library_Level\n-         | Attribute_Lock_Free\n          | Attribute_Machine_Emax\n          | Attribute_Machine_Emin\n          | Attribute_Machine_Mantissa"}, {"sha": "98ce886c71cf16cb52deb7743add88edff64ec76", "filename": "gcc/ada/exp_ch11.adb", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fexp_ch11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fexp_ch11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch11.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -1305,9 +1305,6 @@ package body Exp_Ch11 is\n       then\n          pragma Assert (not Is_Thunk (Current_Scope));\n          Expand_Cleanup_Actions (Parent (N));\n-\n-      else\n-         Set_First_Real_Statement (N, First (Statements (N)));\n       end if;\n    end Expand_N_Handled_Sequence_Of_Statements;\n "}, {"sha": "0d826913f756d26b451dc3fb2b15f17999f410c7", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -7850,6 +7850,7 @@ package body Exp_Ch3 is\n         and then Present (DIC_Procedure (Typ))\n         and then not Has_Null_Body (DIC_Procedure (Typ))\n         and then not Has_Init_Expression (N)\n+        and then No (Expr)\n         and then not Is_Imported (Def_Id)\n       then\n          declare\n@@ -9182,9 +9183,12 @@ package body Exp_Ch3 is\n       --  the runtime verification of all invariants that pertain to the type.\n       --  This includes invariants on the partial and full view, inherited\n       --  class-wide invariants from parent types or interfaces, and invariants\n-      --  on array elements or record components.\n+      --  on array elements or record components. But skip internal types.\n \n-      if Is_Interface (Def_Id) then\n+      if Is_Itype (Def_Id) then\n+         null;\n+\n+      elsif Is_Interface (Def_Id) then\n \n          --  Interfaces are treated as the partial view of a private type in\n          --  order to achieve uniformity with the general case. As a result, an"}, {"sha": "0b7e3911c6a94503982abeb822f7442005b122ee", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -6135,6 +6135,10 @@ package body Exp_Ch4 is\n       --  itself such a slice, in order to catch if expressions with more than\n       --  two dependent expressions in the source code.\n \n+      --  Also note that this creates variables on branches without an explicit\n+      --  scope, causing troubles with e.g. the LLVM IR, so disable this\n+      --  optimization when Unnest_Subprogram_Mode (enabled for LLVM).\n+\n       elsif Is_Array_Type (Typ)\n         and then Number_Dimensions (Typ) = 1\n         and then not Is_Constrained (Typ)\n@@ -6151,6 +6155,7 @@ package body Exp_Ch4 is\n              and then\n                OK_For_Single_Subtype (Etype (Thenx), Etype (Prefix (Elsex)))))\n         and then not Generate_C_Code\n+        and then not Unnest_Subprogram_Mode\n       then\n          declare\n             Ityp : constant Entity_Id := Base_Type (Etype (First_Index (Typ)));"}, {"sha": "2e14c97632ae7def400a6d8a9429f138284fedb9", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 14, "deletions": 23, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -2392,11 +2392,10 @@ package body Exp_Ch5 is\n \n       if Ada_Version >= Ada_2005 then\n          declare\n-            Call           : Node_Id;\n-            Conctyp        : Entity_Id;\n-            Ent            : Entity_Id;\n-            Subprg         : Entity_Id;\n-            RT_Subprg_Name : Node_Id;\n+            Call      : Node_Id;\n+            Ent       : Entity_Id;\n+            Prottyp   : Entity_Id;\n+            RT_Subprg : RE_Id;\n \n          begin\n             --  Handle chains of renamings\n@@ -2416,35 +2415,27 @@ package body Exp_Ch5 is\n \n             if Is_Expanded_Priority_Attribute (Ent) then\n \n-               --  Look for the enclosing concurrent type\n+               --  Look for the enclosing protected type\n \n-               Conctyp := Current_Scope;\n-               while not Is_Concurrent_Type (Conctyp) loop\n-                  Conctyp := Scope (Conctyp);\n+               Prottyp := Current_Scope;\n+               while not Is_Protected_Type (Prottyp) loop\n+                  Prottyp := Scope (Prottyp);\n                end loop;\n \n-               pragma Assert (Is_Protected_Type (Conctyp));\n-\n-               --  Generate the first actual of the call\n-\n-               Subprg := Current_Scope;\n-               while not Present (Protected_Body_Subprogram (Subprg)) loop\n-                  Subprg := Scope (Subprg);\n-               end loop;\n+               pragma Assert (Is_Protected_Type (Prottyp));\n \n                --  Select the appropriate run-time call\n \n-               if Number_Entries (Conctyp) = 0 then\n-                  RT_Subprg_Name :=\n-                    New_Occurrence_Of (RTE (RE_Set_Ceiling), Loc);\n+               if Has_Entries (Prottyp) then\n+                  RT_Subprg := RO_PE_Set_Ceiling;\n                else\n-                  RT_Subprg_Name :=\n-                    New_Occurrence_Of (RTE (RO_PE_Set_Ceiling), Loc);\n+                  RT_Subprg := RE_Set_Ceiling;\n                end if;\n \n                Call :=\n                  Make_Procedure_Call_Statement (Loc,\n-                   Name => RT_Subprg_Name,\n+                   Name                   =>\n+                     New_Occurrence_Of (RTE (RT_Subprg), Loc),\n                    Parameter_Associations => New_List (\n                      New_Copy_Tree (First (Parameter_Associations (Ent))),\n                      Relocate_Node (Expression (N))));"}, {"sha": "ce1a7525fa2923a944c8441afe1f9c346f069ee0", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 16, "deletions": 166, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -26,7 +26,6 @@\n with Atree;          use Atree;\n with Aspects;        use Aspects;\n with Checks;         use Checks;\n-with Contracts;      use Contracts;\n with Debug;          use Debug;\n with Einfo;          use Einfo;\n with Einfo.Entities; use Einfo.Entities;\n@@ -2729,11 +2728,16 @@ package body Exp_Ch6 is\n                                 | N_Function_Call\n                                 | N_Procedure_Call_Statement);\n \n-      --  Check that this is not the call in the body of the wrapper\n+      --  Check that this is not the call in the body of the access\n+      --  subprogram wrapper or the postconditions wrapper.\n \n       if Must_Rewrite_Indirect_Call\n         and then (not Is_Overloadable (Current_Scope)\n-             or else not Is_Access_Subprogram_Wrapper (Current_Scope))\n+             or else not (Is_Access_Subprogram_Wrapper (Current_Scope)\n+                           or else\n+                             (Chars (Current_Scope) = Name_uWrapped_Statements\n+                               and then Is_Access_Subprogram_Wrapper\n+                                          (Scope (Current_Scope)))))\n       then\n          declare\n             Loc      : constant Source_Ptr := Sloc (N);\n@@ -4871,11 +4875,12 @@ package body Exp_Ch6 is\n                   then\n                      Must_Inline := not In_Extended_Main_Source_Unit (Subp);\n \n-                  --  Inline calls to _postconditions when generating C code\n+                  --  Inline calls to _Wrapped_Statements when generating C\n \n                   elsif Modify_Tree_For_C\n                     and then In_Same_Extended_Unit (Sloc (Bod), Loc)\n-                    and then Chars (Name (Call_Node)) = Name_uPostconditions\n+                    and then Chars (Name (Call_Node))\n+                               = Name_uWrapped_Statements\n                   then\n                      Must_Inline := True;\n                   end if;\n@@ -5047,11 +5052,11 @@ package body Exp_Ch6 is\n \n       Set_Analyzed (N);\n \n-      --  A function which returns a controlled object uses the secondary\n-      --  stack. Rewrite the call into a temporary which obtains the result of\n-      --  the function using 'reference.\n+      --  Apply the transformation, unless it was already applied manually\n \n-      Remove_Side_Effects (N);\n+      if Nkind (Par) /= N_Reference then\n+         Remove_Side_Effects (N);\n+      end if;\n \n       --  The side effect removal of the function call produced a temporary.\n       --  When the context is a case expression, if expression, or expression\n@@ -5567,45 +5572,6 @@ package body Exp_Ch6 is\n             Append_To (Stmts, Stmt);\n             Set_Analyzed (Stmt);\n \n-            --  Call the _Postconditions procedure if the related subprogram\n-            --  has contract assertions that need to be verified on exit.\n-\n-            --  Also, mark the successful return to signal that postconditions\n-            --  need to be evaluated when finalization occurs by setting\n-            --  Return_Success_For_Postcond to be True.\n-\n-            if Ekind (Spec_Id) = E_Procedure\n-              and then Present (Postconditions_Proc (Spec_Id))\n-            then\n-               --  Generate:\n-               --\n-               --    Return_Success_For_Postcond := True;\n-               --    if Postcond_Enabled then\n-               --       _postconditions;\n-               --    end if;\n-\n-               Insert_Action (Stmt,\n-                 Make_Assignment_Statement (Loc,\n-                   Name       =>\n-                     New_Occurrence_Of\n-                       (Get_Return_Success_For_Postcond (Spec_Id), Loc),\n-                   Expression => New_Occurrence_Of (Standard_True, Loc)));\n-\n-               --  Wrap the call to _postconditions within a test of the\n-               --  Postcond_Enabled flag to delay postcondition evaluation\n-               --  until after finalization when required.\n-\n-               Insert_Action (Stmt,\n-                 Make_If_Statement (Loc,\n-                   Condition       =>\n-                     New_Occurrence_Of (Get_Postcond_Enabled (Spec_Id), Loc),\n-                   Then_Statements => New_List (\n-                     Make_Procedure_Call_Statement (Loc,\n-                       Name =>\n-                         New_Occurrence_Of\n-                           (Postconditions_Proc (Spec_Id), Loc)))));\n-            end if;\n-\n             --  Ada 2022 (AI12-0279): append the call to 'Yield unless this is\n             --  a generic subprogram (since in such case it will be added to\n             --  the instantiations).\n@@ -6013,44 +5979,6 @@ package body Exp_Ch6 is\n       Lab_Node  : Node_Id;\n \n    begin\n-      --  Call the _Postconditions procedure if the related subprogram has\n-      --  contract assertions that need to be verified on exit.\n-\n-      --  Also, mark the successful return to signal that postconditions need\n-      --  to be evaluated when finalization occurs.\n-\n-      if Ekind (Scope_Id) in E_Entry | E_Entry_Family | E_Procedure\n-        and then Present (Postconditions_Proc (Scope_Id))\n-      then\n-         --  Generate:\n-         --\n-         --    Return_Success_For_Postcond := True;\n-         --    if Postcond_Enabled then\n-         --       _postconditions;\n-         --    end if;\n-\n-         Insert_Action (N,\n-           Make_Assignment_Statement (Loc,\n-             Name       =>\n-               New_Occurrence_Of\n-                (Get_Return_Success_For_Postcond (Scope_Id), Loc),\n-             Expression => New_Occurrence_Of (Standard_True, Loc)));\n-\n-         --  Wrap the call to _postconditions within a test of the\n-         --  Postcond_Enabled flag to delay postcondition evaluation until\n-         --  after finalization when required.\n-\n-         Insert_Action (N,\n-           Make_If_Statement (Loc,\n-             Condition       =>\n-               New_Occurrence_Of (Get_Postcond_Enabled (Scope_Id), Loc),\n-             Then_Statements => New_List (\n-               Make_Procedure_Call_Statement (Loc,\n-                 Name =>\n-                   New_Occurrence_Of\n-                     (Postconditions_Proc (Scope_Id), Loc)))));\n-      end if;\n-\n       --  Ada 2022 (AI12-0279)\n \n       if Has_Yield_Aspect (Scope_Id)\n@@ -6632,7 +6560,7 @@ package body Exp_Ch6 is\n \n          begin\n             if not Exp_Is_Function_Call\n-              and then Has_Discriminants (Ubt)\n+              and then Has_Defaulted_Discriminants (Ubt)\n               and then not Is_Constrained (Ubt)\n               and then not Has_Unchecked_Union (Ubt)\n             then\n@@ -6654,7 +6582,7 @@ package body Exp_Ch6 is\n \n          --  but optimize the case where the result is a function call that\n          --  also needs finalization. In this case the result can directly be\n-         --  allocated on the the return stack of the caller and no further\n+         --  allocated on the return stack of the caller and no further\n          --  processing is required.\n \n          if Present (Utyp)\n@@ -6995,84 +6923,6 @@ package body Exp_Ch6 is\n          end;\n       end if;\n \n-      --  Call the _Postconditions procedure if the related function has\n-      --  contract assertions that need to be verified on exit.\n-\n-      if Ekind (Scope_Id) = E_Function\n-        and then Present (Postconditions_Proc (Scope_Id))\n-      then\n-         --  In the case of discriminated objects, we have created a\n-         --  constrained subtype above, and used the underlying type. This\n-         --  transformation is post-analysis and harmless, except that now the\n-         --  call to the post-condition will be analyzed and the type kinds\n-         --  have to match.\n-\n-         if Nkind (Exp) = N_Unchecked_Type_Conversion\n-           and then Is_Private_Type (R_Type) /= Is_Private_Type (Etype (Exp))\n-         then\n-            Rewrite (Exp, Expression (Relocate_Node (Exp)));\n-         end if;\n-\n-         --  We are going to reference the returned value twice in this case,\n-         --  once in the call to _Postconditions, and once in the actual return\n-         --  statement, but we can't have side effects happening twice.\n-\n-         Force_Evaluation (Exp, Mode => Strict);\n-\n-         --  Save the return value or a pointer to the return value since we\n-         --  may need to call postconditions after finalization when cleanup\n-         --  actions are present.\n-\n-         --  Generate:\n-         --\n-         --    Result_Object_For_Postcond := [Exp]'Unrestricted_Access;\n-\n-         Insert_Action (Exp,\n-           Make_Assignment_Statement (Loc,\n-             Name       =>\n-               New_Occurrence_Of\n-                (Get_Result_Object_For_Postcond (Scope_Id), Loc),\n-             Expression =>\n-               (if Is_Elementary_Type (Etype (R_Type)) then\n-                   New_Copy_Tree (Exp)\n-                else\n-                   Make_Attribute_Reference (Loc,\n-                     Attribute_Name => Name_Unrestricted_Access,\n-                     Prefix         => New_Copy_Tree (Exp)))));\n-\n-         --  Mark the successful return to signal that postconditions need to\n-         --  be evaluated when finalization occurs.\n-\n-         --  Generate:\n-         --\n-         --    Return_Success_For_Postcond := True;\n-         --    if Postcond_Enabled then\n-         --       _Postconditions ([exp]);\n-         --    end if;\n-\n-         Insert_Action (Exp,\n-           Make_Assignment_Statement (Loc,\n-             Name       =>\n-               New_Occurrence_Of\n-                (Get_Return_Success_For_Postcond (Scope_Id), Loc),\n-             Expression => New_Occurrence_Of (Standard_True, Loc)));\n-\n-         --  Wrap the call to _postconditions within a test of the\n-         --  Postcond_Enabled flag to delay postcondition evaluation until\n-         --  after finalization when required.\n-\n-         Insert_Action (Exp,\n-           Make_If_Statement (Loc,\n-             Condition       =>\n-               New_Occurrence_Of (Get_Postcond_Enabled (Scope_Id), Loc),\n-             Then_Statements => New_List (\n-               Make_Procedure_Call_Statement (Loc,\n-                 Name                   =>\n-                   New_Occurrence_Of\n-                     (Postconditions_Proc (Scope_Id), Loc),\n-                 Parameter_Associations => New_List (New_Copy_Tree (Exp))))));\n-      end if;\n-\n       --  Ada 2005 (AI-251): If this return statement corresponds with an\n       --  simple return statement associated with an extended return statement\n       --  and the type of the returned object is an interface then generate an"}, {"sha": "fc4516dde5b187e65e196ada5a2d554c24403e5c", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 63, "deletions": 709, "changes": 772, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -28,7 +28,6 @@\n --    - transient scopes\n \n with Atree;          use Atree;\n-with Contracts;      use Contracts;\n with Debug;          use Debug;\n with Einfo;          use Einfo;\n with Einfo.Entities; use Einfo.Entities;\n@@ -59,7 +58,6 @@ with Sinfo.Nodes;    use Sinfo.Nodes;\n with Sinfo.Utils;    use Sinfo.Utils;\n with Sem;            use Sem;\n with Sem_Aux;        use Sem_Aux;\n-with Sem_Ch3;        use Sem_Ch3;\n with Sem_Ch7;        use Sem_Ch7;\n with Sem_Ch8;        use Sem_Ch8;\n with Sem_Res;        use Sem_Res;\n@@ -306,17 +304,6 @@ package body Exp_Ch7 is\n    --  such as for task termination. Fin_Id is the finalizer declaration\n    --  entity.\n \n-   procedure Build_Finalizer_Helper\n-     (N                 : Node_Id;\n-      Clean_Stmts       : List_Id;\n-      Mark_Id           : Entity_Id;\n-      Top_Decls         : List_Id;\n-      Defer_Abort       : Boolean;\n-      Fin_Id            : out Entity_Id;\n-      Finalize_Old_Only : Boolean);\n-   --  An internal routine which does all of the heavy lifting on behalf of\n-   --  Build_Finalizer.\n-\n    procedure Build_Finalizer_Call (N : Node_Id; Fin_Id : Entity_Id);\n    --  N is a construct that contains a handled sequence of statements, Fin_Id\n    --  is the entity of a finalizer. Create an At_End handler that covers the\n@@ -927,10 +914,6 @@ package body Exp_Ch7 is\n             pragma Assert (Present (Param));\n             pragma Assert (Present (Conc_Typ));\n \n-            --  Historical note: In earlier versions of GNAT, there was code\n-            --  at this point to generate stuff to service entry queues. It is\n-            --  now abstracted in Build_Protected_Subprogram_Call_Cleanup.\n-\n             Build_Protected_Subprogram_Call_Cleanup\n               (Specification (N), Conc_Typ, Loc, Stmts);\n          end;\n@@ -1382,18 +1365,17 @@ package body Exp_Ch7 is\n       end;\n    end Build_Finalization_Master;\n \n-   ----------------------------\n-   -- Build_Finalizer_Helper --\n-   ----------------------------\n+   ---------------------\n+   -- Build_Finalizer --\n+   ---------------------\n \n-   procedure Build_Finalizer_Helper\n+   procedure Build_Finalizer\n      (N                 : Node_Id;\n       Clean_Stmts       : List_Id;\n       Mark_Id           : Entity_Id;\n       Top_Decls         : List_Id;\n       Defer_Abort       : Boolean;\n-      Fin_Id            : out Entity_Id;\n-      Finalize_Old_Only : Boolean)\n+      Fin_Id            : out Entity_Id)\n    is\n       Acts_As_Clean    : constant Boolean :=\n                            Present (Mark_Id)\n@@ -1687,15 +1669,9 @@ package body Exp_Ch7 is\n             --  there will need to be multiple finalization routines in the\n             --  same scope. See Build_Finalizer for details.\n \n-            if Finalize_Old_Only then\n-               Fin_Id :=\n-                 Make_Defining_Identifier (Loc,\n-                   Chars => New_External_Name (Name_uFinalizer_Old));\n-            else\n-               Fin_Id :=\n-                 Make_Defining_Identifier (Loc,\n-                   Chars => New_External_Name (Name_uFinalizer));\n-            end if;\n+            Fin_Id :=\n+              Make_Defining_Identifier (Loc,\n+                Chars => New_External_Name (Name_uFinalizer));\n \n             --  The visibility semantics of AT_END handlers force a strange\n             --  separation of spec and body for stack-related finalizers:\n@@ -2066,10 +2042,15 @@ package body Exp_Ch7 is\n                --  In the case where the last construct to contain a controlled\n                --  object is either a nested package, an instantiation or a\n                --  freeze node, the body must be inserted directly after the\n-               --  construct.\n+               --  construct, except if the insertion point is already placed\n+               --  after the construct, typically in the statement list.\n \n                if Nkind (Last_Top_Level_Ctrl_Construct) in\n                     N_Freeze_Entity | N_Package_Declaration | N_Package_Body\n+                 and then not\n+                  (List_Containing (Last_Top_Level_Ctrl_Construct) = Spec_Decls\n+                    and then Present (Stmts)\n+                    and then List_Containing (Finalizer_Insert_Nod) = Stmts)\n                then\n                   Finalizer_Insert_Nod := Last_Top_Level_Ctrl_Construct;\n                end if;\n@@ -2222,26 +2203,9 @@ package body Exp_Ch7 is\n \n          Decl := Last_Non_Pragma (Decls);\n          while Present (Decl) loop\n-            --  Depending on the value of flag Finalize_Old_Only we determine\n-            --  which objects get finalized as part of the current finalizer\n-            --  being built.\n-\n-            --  When True, only temporaries capturing the value of attribute\n-            --  'Old are finalized and all other cases are ignored.\n-\n-            --  When False, temporary objects used to capture the value of 'Old\n-            --  are ignored and all others are considered.\n-\n-            if Finalize_Old_Only\n-                 xor (Nkind (Decl) = N_Object_Declaration\n-                       and then Stores_Attribute_Old_Prefix\n-                                  (Defining_Identifier (Decl)))\n-            then\n-               null;\n-\n             --  Library-level tagged types\n \n-            elsif Nkind (Decl) = N_Full_Type_Declaration then\n+            if Nkind (Decl) = N_Full_Type_Declaration then\n                Typ := Defining_Identifier (Decl);\n \n                --  Ignored Ghost types do not need any cleanup actions because\n@@ -2546,7 +2510,7 @@ package body Exp_Ch7 is\n                            --  template and not the actually instantiation\n                            --  (which is generated too late for us to process\n                            --  it), so there is no need to update in particular\n-                           --  to update Last_Top_Level_Ctrl_Construct here.\n+                           --  Last_Top_Level_Ctrl_Construct here.\n \n                            if Counter_Val > Old_Counter_Val then\n                               Counter_Val := Old_Counter_Val;\n@@ -3528,7 +3492,7 @@ package body Exp_Ch7 is\n                New_Occurrence_Of (DT_Ptr, Loc))));\n       end Process_Tagged_Type_Declaration;\n \n-   --  Start of processing for Build_Finalizer_Helper\n+   --  Start of processing for Build_Finalizer\n \n    begin\n       Fin_Id := Empty;\n@@ -3685,22 +3649,13 @@ package body Exp_Ch7 is\n       if Acts_As_Clean or Has_Ctrl_Objs or Has_Tagged_Types then\n          Create_Finalizer;\n       end if;\n-   end Build_Finalizer_Helper;\n+   end Build_Finalizer;\n \n    --------------------------\n    -- Build_Finalizer_Call --\n    --------------------------\n \n    procedure Build_Finalizer_Call (N : Node_Id; Fin_Id : Entity_Id) is\n-      Is_Protected_Subp_Body : constant Boolean :=\n-        Nkind (N) = N_Subprogram_Body\n-        and then Is_Protected_Subprogram_Body (N);\n-      --  Determine whether N denotes the protected version of a subprogram\n-      --  which belongs to a protected type.\n-\n-      Loc : constant Source_Ptr := Sloc (N);\n-      HSS : Node_Id := Handled_Statement_Sequence (N);\n-\n    begin\n       --  Do not perform this expansion in SPARK mode because we do not create\n       --  finalizers in the first place.\n@@ -3730,511 +3685,42 @@ package body Exp_Ch7 is\n       --        end;\n       --     end Prot_SubpP;\n \n-      if Is_Protected_Subp_Body then\n-         HSS := Handled_Statement_Sequence (Last (Statements (HSS)));\n-      end if;\n-\n-      pragma Assert (No (At_End_Proc (HSS)));\n-      Set_At_End_Proc (HSS, New_Occurrence_Of (Fin_Id, Loc));\n-\n-      --  Attach reference to finalizer to tree, for LLVM use\n-\n-      Set_Parent (At_End_Proc (HSS), HSS);\n+      declare\n+         Loc : constant Source_Ptr := Sloc (N);\n \n-      Analyze (At_End_Proc (HSS));\n-      Expand_At_End_Handler (HSS, Empty);\n+         Is_Protected_Subp_Body : constant Boolean :=\n+           Nkind (N) = N_Subprogram_Body\n+           and then Is_Protected_Subprogram_Body (N);\n+         --  True if N is the protected version of a subprogram that belongs to\n+         --  a protected type.\n+\n+         HSS : constant Node_Id :=\n+           (if Is_Protected_Subp_Body\n+             then Handled_Statement_Sequence\n+               (Last (Statements (Handled_Statement_Sequence (N))))\n+             else Handled_Statement_Sequence (N));\n+\n+         --  We attach the At_End_Proc to the HSS if this is an accept\n+         --  statement or extended return statement. Also in the case of\n+         --  a protected subprogram, because if Service_Entries raises an\n+         --  exception, we do not lock the PO, so we also do not want to\n+         --  unlock it.\n+\n+         Use_HSS : constant Boolean :=\n+           Nkind (N) in N_Accept_Statement | N_Extended_Return_Statement\n+           or else Is_Protected_Subp_Body;\n+\n+         At_End_Proc_Bearer : constant Node_Id := (if Use_HSS then HSS else N);\n+      begin\n+         pragma Assert (No (At_End_Proc (At_End_Proc_Bearer)));\n+         Set_At_End_Proc (At_End_Proc_Bearer, New_Occurrence_Of (Fin_Id, Loc));\n+         --  Attach reference to finalizer to tree, for LLVM use\n+         Set_Parent (At_End_Proc (At_End_Proc_Bearer), At_End_Proc_Bearer);\n+         Analyze (At_End_Proc (At_End_Proc_Bearer));\n+         Expand_At_End_Handler (At_End_Proc_Bearer, Empty);\n+      end;\n    end Build_Finalizer_Call;\n \n-   ---------------------\n-   -- Build_Finalizer --\n-   ---------------------\n-\n-   procedure Build_Finalizer\n-     (N           : Node_Id;\n-      Clean_Stmts : List_Id;\n-      Mark_Id     : Entity_Id;\n-      Top_Decls   : List_Id;\n-      Defer_Abort : Boolean;\n-      Fin_Id      : out Entity_Id)\n-   is\n-      Def_Ent : constant Entity_Id  := Unique_Defining_Entity (N);\n-      Loc     : constant Source_Ptr := Sloc (N);\n-\n-      --  Declarations used for the creation of _finalization_controller\n-\n-      Fin_Old_Id           : Entity_Id := Empty;\n-      Fin_Controller_Id    : Entity_Id := Empty;\n-      Fin_Controller_Decls : List_Id;\n-      Fin_Controller_Stmts : List_Id;\n-      Fin_Controller_Body  : Node_Id   := Empty;\n-      Fin_Controller_Spec  : Node_Id   := Empty;\n-      Postconditions_Call  : Node_Id   := Empty;\n-\n-      --  Defining identifiers for local objects used to store exception info\n-\n-      Raised_Post_Exception_Id         : Entity_Id := Empty;\n-      Raised_Finalization_Exception_Id : Entity_Id := Empty;\n-      Saved_Exception_Id               : Entity_Id := Empty;\n-\n-   --  Start of processing for Build_Finalizer\n-\n-   begin\n-      --  Create the general finalization routine\n-\n-      Build_Finalizer_Helper\n-        (N                 => N,\n-         Clean_Stmts       => Clean_Stmts,\n-         Mark_Id           => Mark_Id,\n-         Top_Decls         => Top_Decls,\n-         Defer_Abort       => Defer_Abort,\n-         Fin_Id            => Fin_Id,\n-         Finalize_Old_Only => False);\n-\n-      --  When postconditions are present, expansion gets much more complicated\n-      --  due to both the fact that they must be called after finalization and\n-      --  that finalization of 'Old objects must occur after the postconditions\n-      --  get checked.\n-\n-      --  Additionally, exceptions between general finalization and 'Old\n-      --  finalization must be propagated correctly and exceptions which happen\n-      --  during _postconditions need to be saved and reraised after\n-      --  finalization of 'Old objects.\n-\n-      --  Generate:\n-      --\n-      --    Postcond_Enabled := False;\n-      --\n-      --    procedure _finalization_controller is\n-      --\n-      --       --  Exception capturing and tracking\n-      --\n-      --       Saved_Exception               : Exception_Occurrence;\n-      --       Raised_Post_Exception         : Boolean := False;\n-      --       Raised_Finalization_Exception : Boolean := False;\n-      --\n-      --    --  Start of processing for _finalization_controller\n-      --\n-      --    begin\n-      --       --  Perform general finalization\n-      --\n-      --       begin\n-      --          _finalizer;\n-      --       exception\n-      --          when others =>\n-      --             --  Save the exception\n-      --\n-      --             Raised_Finalization_Exception := True;\n-      --             Save_Occurrence\n-      --               (Saved_Exception, Get_Current_Excep.all);\n-      --       end;\n-      --\n-      --       --  Perform postcondition checks after general finalization, but\n-      --       --  before finalization of 'Old related objects.\n-      --\n-      --       if not Raised_Finalization_Exception\n-      --         and then Return_Success_For_Postcond\n-      --       then\n-      --          begin\n-      --             --  Re-enable postconditions and check them\n-      --\n-      --             Postcond_Enabled := True;\n-      --             _postconditions [(Result_Obj_For_Postcond[.all])];\n-      --          exception\n-      --             when others =>\n-      --                --  Save the exception\n-      --\n-      --                Raised_Post_Exception := True;\n-      --                Save_Occurrence\n-      --                  (Saved_Exception, Get_Current_Excep.all);\n-      --          end;\n-      --       end if;\n-      --\n-      --       --  Finally finalize 'Old related objects\n-      --\n-      --       begin\n-      --          _finalizer_old;\n-      --       exception\n-      --          when others =>\n-      --             --  Reraise the previous finalization error if there is\n-      --             --  one.\n-      --\n-      --             if Raised_Finalization_Exception then\n-      --                Reraise_Occurrence (Saved_Exception);\n-      --             end if;\n-      --\n-      --             --  Otherwise, reraise the current one\n-      --\n-      --             raise;\n-      --       end;\n-      --\n-      --       --  Reraise any saved exception\n-      --\n-      --       if Raised_Finalization_Exception\n-      --            or else Raised_Post_Exception\n-      --       then\n-      --          Reraise_Occurrence (Saved_Exception);\n-      --       end if;\n-      --    end _finalization_controller;\n-\n-      if Nkind (N) = N_Subprogram_Body\n-        and then Present (Postconditions_Proc (Def_Ent))\n-      then\n-         Fin_Controller_Stmts := New_List;\n-         Fin_Controller_Decls := New_List;\n-\n-         --  Build the 'Old finalizer\n-\n-         Build_Finalizer_Helper\n-           (N                 => N,\n-            Clean_Stmts       => Empty_List,\n-            Mark_Id           => Mark_Id,\n-            Top_Decls         => Top_Decls,\n-            Defer_Abort       => Defer_Abort,\n-            Fin_Id            => Fin_Old_Id,\n-            Finalize_Old_Only => True);\n-\n-         --  Create local declarations for _finalization_controller needed for\n-         --  saving exceptions.\n-         --\n-         --  Generate:\n-         --\n-         --    Saved_Exception               : Exception_Occurrence;\n-         --    Raised_Post_Exception         : Boolean := False;\n-         --    Raised_Finalization_Exception : Boolean := False;\n-\n-         Saved_Exception_Id               := Make_Temporary (Loc, 'S');\n-         Raised_Post_Exception_Id         := Make_Temporary (Loc, 'P');\n-         Raised_Finalization_Exception_Id := Make_Temporary (Loc, 'F');\n-\n-         Append_List_To (Fin_Controller_Decls, New_List (\n-           Make_Object_Declaration (Loc,\n-             Defining_Identifier => Saved_Exception_Id,\n-             Object_Definition   =>\n-               New_Occurrence_Of (RTE (RE_Exception_Occurrence), Loc)),\n-           Make_Object_Declaration (Loc,\n-             Defining_Identifier => Raised_Post_Exception_Id,\n-             Object_Definition   => New_Occurrence_Of (Standard_Boolean, Loc),\n-             Expression          => New_Occurrence_Of (Standard_False, Loc)),\n-           Make_Object_Declaration (Loc,\n-             Defining_Identifier => Raised_Finalization_Exception_Id,\n-             Object_Definition   => New_Occurrence_Of (Standard_Boolean, Loc),\n-             Expression          => New_Occurrence_Of (Standard_False, Loc))));\n-\n-         --  Call _finalizer and save any exceptions which occur\n-\n-         --  Generate:\n-         --\n-         --    begin\n-         --       _finalizer;\n-         --    exception\n-         --       when others =>\n-         --          Raised_Finalization_Exception := True;\n-         --          Save_Occurrence\n-         --            (Saved_Exception, Get_Current_Excep.all);\n-         --    end;\n-\n-         if Present (Fin_Id) then\n-            Append_To (Fin_Controller_Stmts,\n-              Make_Block_Statement (Loc,\n-                Handled_Statement_Sequence =>\n-                  Make_Handled_Sequence_Of_Statements (Loc,\n-                    Statements         => New_List (\n-                      Make_Procedure_Call_Statement (Loc,\n-                        Name => New_Occurrence_Of (Fin_Id, Loc))),\n-                    Exception_Handlers => New_List (\n-                      Make_Exception_Handler (Loc,\n-                        Exception_Choices => New_List (\n-                          Make_Others_Choice (Loc)),\n-                        Statements        => New_List (\n-                          Make_Assignment_Statement (Loc,\n-                            Name       =>\n-                              New_Occurrence_Of\n-                                (Raised_Finalization_Exception_Id, Loc),\n-                            Expression =>\n-                              New_Occurrence_Of (Standard_True, Loc)),\n-                          Make_Procedure_Call_Statement (Loc,\n-                             Name                   =>\n-                               New_Occurrence_Of\n-                                 (RTE (RE_Save_Occurrence), Loc),\n-                             Parameter_Associations => New_List (\n-                               New_Occurrence_Of\n-                                 (Saved_Exception_Id, Loc),\n-                               Make_Explicit_Dereference (Loc,\n-                                 Prefix =>\n-                                   Make_Function_Call (Loc,\n-                                     Name =>\n-                                       Make_Explicit_Dereference (Loc,\n-                                         Prefix =>\n-                                           New_Occurrence_Of\n-                                             (RTE (RE_Get_Current_Excep),\n-                                              Loc))))))))))));\n-         end if;\n-\n-         --  Create the call to postconditions based on the kind of the current\n-         --  subprogram, and the type of the Result_Obj_For_Postcond.\n-\n-         --  Generate:\n-         --\n-         --    _postconditions (Result_Obj_For_Postcond[.all]);\n-         --\n-         --   or\n-         --\n-         --    _postconditions;\n-\n-         if Ekind (Def_Ent) = E_Procedure then\n-            Postconditions_Call :=\n-              Make_Procedure_Call_Statement (Loc,\n-                Name =>\n-                  New_Occurrence_Of\n-                    (Postconditions_Proc (Def_Ent), Loc));\n-         else\n-            Postconditions_Call :=\n-              Make_Procedure_Call_Statement (Loc,\n-                Name                   =>\n-                  New_Occurrence_Of\n-                    (Postconditions_Proc (Def_Ent), Loc),\n-                Parameter_Associations => New_List (\n-                  (if Is_Elementary_Type (Etype (Def_Ent)) then\n-                      New_Occurrence_Of\n-                        (Get_Result_Object_For_Postcond\n-                          (Def_Ent), Loc)\n-                   else\n-                      Make_Explicit_Dereference (Loc,\n-                        New_Occurrence_Of\n-                          (Get_Result_Object_For_Postcond\n-                            (Def_Ent), Loc)))));\n-         end if;\n-\n-         --  Call _postconditions when no general finalization exceptions have\n-         --  occurred taking care to enable the postconditions and save any\n-         --  exception occurrences.\n-\n-         --  Generate:\n-         --\n-         --    if not Raised_Finalization_Exception\n-         --      and then Return_Success_For_Postcond\n-         --    then\n-         --       begin\n-         --          Postcond_Enabled := True;\n-         --          _postconditions [(Result_Obj_For_Postcond[.all])];\n-         --       exception\n-         --          when others =>\n-         --             Raised_Post_Exception := True;\n-         --             Save_Occurrence\n-         --               (Saved_Exception, Get_Current_Excep.all);\n-         --       end;\n-         --    end if;\n-\n-         Append_To (Fin_Controller_Stmts,\n-           Make_If_Statement (Loc,\n-             Condition       =>\n-               Make_And_Then (Loc,\n-                 Left_Opnd  =>\n-                   Make_Op_Not (Loc,\n-                     Right_Opnd =>\n-                       New_Occurrence_Of\n-                         (Raised_Finalization_Exception_Id, Loc)),\n-                 Right_Opnd =>\n-                   New_Occurrence_Of\n-                     (Get_Return_Success_For_Postcond (Def_Ent), Loc)),\n-             Then_Statements => New_List (\n-               Make_Block_Statement (Loc,\n-                 Handled_Statement_Sequence =>\n-                   Make_Handled_Sequence_Of_Statements (Loc,\n-                     Statements         => New_List (\n-                       Make_Assignment_Statement (Loc,\n-                         Name       =>\n-                           New_Occurrence_Of\n-                             (Get_Postcond_Enabled (Def_Ent), Loc),\n-                         Expression =>\n-                            New_Occurrence_Of\n-                              (Standard_True, Loc)),\n-                       Postconditions_Call),\n-                     Exception_Handlers => New_List (\n-                       Make_Exception_Handler (Loc,\n-                         Exception_Choices => New_List (\n-                           Make_Others_Choice (Loc)),\n-                         Statements        => New_List (\n-                           Make_Assignment_Statement (Loc,\n-                             Name       =>\n-                               New_Occurrence_Of\n-                                 (Raised_Post_Exception_Id, Loc),\n-                             Expression =>\n-                               New_Occurrence_Of (Standard_True, Loc)),\n-                           Make_Procedure_Call_Statement (Loc,\n-                              Name                   =>\n-                                New_Occurrence_Of\n-                                  (RTE (RE_Save_Occurrence), Loc),\n-                              Parameter_Associations => New_List (\n-                                New_Occurrence_Of\n-                                  (Saved_Exception_Id, Loc),\n-                                Make_Explicit_Dereference (Loc,\n-                                  Prefix =>\n-                                    Make_Function_Call (Loc,\n-                                      Name =>\n-                                        Make_Explicit_Dereference (Loc,\n-                                          Prefix =>\n-                                            New_Occurrence_Of\n-                                              (RTE (RE_Get_Current_Excep),\n-                                               Loc))))))))))))));\n-\n-         --  Call _finalizer_old and reraise any exception that occurred during\n-         --  initial finalization within the exception handler. Otherwise,\n-         --  propagate the current exception.\n-\n-         --  Generate:\n-         --\n-         --    begin\n-         --       _finalizer_old;\n-         --    exception\n-         --       when others =>\n-         --          if Raised_Finalization_Exception then\n-         --             Reraise_Occurrence (Saved_Exception);\n-         --          end if;\n-         --          raise;\n-         --    end;\n-\n-         if Present (Fin_Old_Id) then\n-            Append_To (Fin_Controller_Stmts,\n-              Make_Block_Statement (Loc,\n-                Handled_Statement_Sequence =>\n-                  Make_Handled_Sequence_Of_Statements (Loc,\n-                    Statements         => New_List (\n-                      Make_Procedure_Call_Statement (Loc,\n-                        Name => New_Occurrence_Of (Fin_Old_Id, Loc))),\n-                    Exception_Handlers => New_List (\n-                      Make_Exception_Handler (Loc,\n-                        Exception_Choices => New_List (\n-                          Make_Others_Choice (Loc)),\n-                        Statements        => New_List (\n-                          Make_If_Statement (Loc,\n-                            Condition       =>\n-                              New_Occurrence_Of\n-                                (Raised_Finalization_Exception_Id, Loc),\n-                            Then_Statements => New_List (\n-                              Make_Procedure_Call_Statement (Loc,\n-                                Name                   =>\n-                                  New_Occurrence_Of\n-                                    (RTE (RE_Reraise_Occurrence), Loc),\n-                                Parameter_Associations => New_List (\n-                                  New_Occurrence_Of\n-                                    (Saved_Exception_Id, Loc))))),\n-                          Make_Raise_Statement (Loc)))))));\n-         end if;\n-\n-         --  Once finalization is complete reraise any pending exceptions\n-\n-         --  Generate:\n-         --\n-         --    if Raised_Post_Exception\n-         --      or else Raised_Finalization_Exception\n-         --    then\n-         --       Reraise_Occurrence (Saved_Exception);\n-         --    end if;\n-\n-         Append_To (Fin_Controller_Stmts,\n-           Make_If_Statement (Loc,\n-             Condition       =>\n-               Make_Or_Else (Loc,\n-                 Left_Opnd  =>\n-                   New_Occurrence_Of\n-                     (Raised_Post_Exception_Id, Loc),\n-                 Right_Opnd =>\n-                   New_Occurrence_Of\n-                     (Raised_Finalization_Exception_Id, Loc)),\n-             Then_Statements => New_List (\n-               Make_Procedure_Call_Statement (Loc,\n-                 Name            =>\n-                   New_Occurrence_Of (RTE (RE_Reraise_Occurrence), Loc),\n-                 Parameter_Associations => New_List (\n-                   New_Occurrence_Of\n-                     (Saved_Exception_Id, Loc))))));\n-\n-         --  Make the finalization controller subprogram body and declaration.\n-\n-         --  Generate:\n-         --    procedure _finalization_controller;\n-         --\n-         --    procedure _finalization_controller is\n-         --    begin\n-         --       [Fin_Controller_Stmts];\n-         --    end;\n-\n-         Fin_Controller_Id :=\n-           Make_Defining_Identifier (Loc,\n-             Chars => New_External_Name (Name_uFinalization_Controller));\n-\n-         Fin_Controller_Spec :=\n-           Make_Subprogram_Declaration (Loc,\n-             Specification =>\n-               Make_Procedure_Specification (Loc,\n-                 Defining_Unit_Name => Fin_Controller_Id));\n-\n-         Fin_Controller_Body :=\n-           Make_Subprogram_Body (Loc,\n-             Specification              =>\n-               Make_Procedure_Specification (Loc,\n-                 Defining_Unit_Name =>\n-                   Make_Defining_Identifier (Loc, Chars (Fin_Controller_Id))),\n-             Declarations               => Fin_Controller_Decls,\n-             Handled_Statement_Sequence =>\n-               Make_Handled_Sequence_Of_Statements (Loc,\n-                 Statements => Fin_Controller_Stmts));\n-\n-         --  Disable _postconditions calls which get generated before return\n-         --  statements to delay their evaluation until after finalization.\n-\n-         --  This is done by way of the local Postcond_Enabled object which is\n-         --  initially assigned to True - we then create an assignment within\n-         --  the subprogram's declaration to make it False and assign it back\n-         --  to True before _postconditions is called within\n-         --  _finalization_controller.\n-\n-         --  Generate:\n-         --\n-         --    Postcond_Enable := False;\n-\n-         --  Note that we do not disable early evaluation of postconditions\n-         --  for return types that are unconstrained or have unconstrained\n-         --  elements since the temporary result object could get allocated on\n-         --  the stack and be out of scope at the point where we perform late\n-         --  evaluation of postconditions - leading to uninitialized memory\n-         --  reads.\n-\n-         --  This disabling of early evaluation can lead to incorrect run-time\n-         --  semantics where functions with unconstrained elements will\n-         --  have their corresponding postconditions evaluated before\n-         --  finalization. The proper solution here is to generate a wrapper\n-         --  to capture the result instead of using multiple flags and playing\n-         --  with flags which does not even work in all cases ???\n-\n-         if not Has_Unconstrained_Elements (Etype (Def_Ent))\n-           or else (Is_Array_Type (Etype (Def_Ent))\n-                     and then not Is_Constrained (Etype (Def_Ent)))\n-         then\n-            Append_To (Top_Decls,\n-              Make_Assignment_Statement (Loc,\n-                Name       =>\n-                  New_Occurrence_Of\n-                    (Get_Postcond_Enabled (Def_Ent), Loc),\n-                Expression =>\n-                  New_Occurrence_Of\n-                    (Standard_False, Loc)));\n-         end if;\n-\n-         --  Add the subprogram to the list of declarations an analyze it\n-\n-         Append_To (Top_Decls, Fin_Controller_Spec);\n-         Analyze (Fin_Controller_Spec);\n-         Insert_After (Fin_Controller_Spec, Fin_Controller_Body);\n-         Analyze (Fin_Controller_Body, Suppress => All_Checks);\n-\n-         --  Return the finalization controller as the result Fin_Id\n-\n-         Fin_Id := Fin_Controller_Id;\n-      end if;\n-   end Build_Finalizer;\n-\n    ---------------------\n    -- Build_Late_Proc --\n    ---------------------\n@@ -5544,12 +5030,6 @@ package body Exp_Ch7 is\n                                  Nkind (N) = N_Block_Statement\n                                    and then Present (Cleanup_Actions (N));\n \n-      Has_Postcondition      : constant Boolean :=\n-                                 Nkind (N) = N_Subprogram_Body\n-                                   and then Present\n-                                              (Postconditions_Proc\n-                                                (Unique_Defining_Entity (N)));\n-\n       Actions_Required       : constant Boolean :=\n                                  Requires_Cleanup_Actions (N, True)\n                                    or else Is_Asynchronous_Call\n@@ -5560,47 +5040,9 @@ package body Exp_Ch7 is\n                                    or else Needs_Sec_Stack_Mark\n                                    or else Needs_Custom_Cleanup;\n \n-      HSS : Node_Id := Handled_Statement_Sequence (N);\n       Loc : Source_Ptr;\n       Cln : List_Id;\n \n-      procedure Wrap_HSS_In_Block;\n-      --  Move HSS inside a new block along with the original exception\n-      --  handlers. Make the newly generated block the sole statement of HSS.\n-\n-      -----------------------\n-      -- Wrap_HSS_In_Block --\n-      -----------------------\n-\n-      procedure Wrap_HSS_In_Block is\n-         Block : constant Node_Id :=\n-           Make_Block_Statement (Loc, Handled_Statement_Sequence => HSS);\n-         Block_Id : constant Entity_Id :=\n-           New_Internal_Entity (E_Block, Current_Scope, Loc, 'B');\n-         End_Lab : constant Node_Id := End_Label (HSS);\n-         --  Preserve end label to provide proper cross-reference information\n-\n-      begin\n-         Set_Identifier (Block, New_Occurrence_Of (Block_Id, Loc));\n-         Set_Etype (Block_Id, Standard_Void_Type);\n-         Set_Block_Node (Block_Id, Identifier (Block));\n-\n-         --  Signal the finalization machinery that this particular block\n-         --  contains the original context.\n-\n-         Set_Is_Finalization_Wrapper (Block);\n-\n-         HSS := Make_Handled_Sequence_Of_Statements (Loc,\n-           Statements => New_List (Block),\n-           End_Label => End_Lab);\n-         Set_First_Real_Statement (HSS, Block);\n-         Set_Handled_Statement_Sequence (N, HSS);\n-\n-         if Nkind (N) = N_Subprogram_Body then\n-            Set_Has_Nested_Block_With_Handler (Scop);\n-         end if;\n-      end Wrap_HSS_In_Block;\n-\n    --  Start of processing for Expand_Cleanup_Actions\n \n    begin\n@@ -5671,12 +5113,14 @@ package body Exp_Ch7 is\n          Cln := No_List;\n       end if;\n \n-      declare\n-         Decls     : List_Id := Declarations (N);\n-         Fin_Id    : Entity_Id;\n-         Mark      : Entity_Id := Empty;\n-         New_Decls : List_Id;\n+      if No (Declarations (N)) then\n+         Set_Declarations (N, New_List);\n+      end if;\n \n+      declare\n+         Decls  : constant List_Id := Declarations (N);\n+         Fin_Id : Entity_Id;\n+         Mark   : Entity_Id := Empty;\n       begin\n          --  If we are generating expanded code for debugging purposes, use the\n          --  Sloc of the point of insertion for the cleanup code. The Sloc will\n@@ -5703,109 +5147,22 @@ package body Exp_Ch7 is\n             Establish_Task_Master (N);\n          end if;\n \n-         New_Decls := New_List;\n-\n          --  If secondary stack is in use, generate:\n          --\n          --    Mnn : constant Mark_Id := SS_Mark;\n \n          if Needs_Sec_Stack_Mark then\n+            Set_Uses_Sec_Stack (Scop, False); -- avoid duplicate SS marks\n             Mark := Make_Temporary (Loc, 'M');\n \n-            Append_To (New_Decls, Build_SS_Mark_Call (Loc, Mark));\n-            Set_Uses_Sec_Stack (Scop, False);\n-         end if;\n-\n-         --  If exception handlers are present in a non-subprogram\n-         --  construct, wrap the sequence of statements in a block.\n-         --  Otherwise, code can be moved so that the wrong handlers\n-         --  apply. It is important not to do this for function bodies,\n-         --  because otherwise transient finalizable objects created\n-         --  by a return statement get finalized too late. It is harmless\n-         --  not to do this for procedures.\n-\n-         if Present (Exception_Handlers (HSS))\n-           and then Nkind (N) /= N_Subprogram_Body\n-         then\n-            Wrap_HSS_In_Block;\n-\n-         --  Ensure that the First_Real_Statement field is set\n-\n-         elsif No (First_Real_Statement (HSS)) then\n-            Set_First_Real_Statement (HSS, First (Statements (HSS)));\n-         end if;\n-\n-         --  Do not move the Activation_Chain declaration in the context of\n-         --  task allocation blocks. Task allocation blocks use _chain in their\n-         --  cleanup handlers and gigi complains if it is declared in the\n-         --  sequence of statements of the scope that declares the handler.\n-\n-         if Is_Task_Allocation then\n-            declare\n-               Chain_Decl : constant N_Object_Declaration_Id :=\n-                 Parent (Activation_Chain_Entity (N));\n-               pragma Assert (List_Containing (Chain_Decl) = Decls);\n-            begin\n-               Remove (Chain_Decl);\n-               Prepend_To (New_Decls, Chain_Decl);\n-            end;\n-         end if;\n-\n-         --  Move the _postconditions subprogram declaration and its associated\n-         --  objects into the declarations section so that it is callable\n-         --  within _postconditions.\n-\n-         if Has_Postcondition then\n             declare\n-               Decl      : Node_Id;\n-               Prev_Decl : Node_Id;\n-\n+               Mark_Call : constant Node_Id := Build_SS_Mark_Call (Loc, Mark);\n             begin\n-               Decl :=\n-                 Prev (Subprogram_Body\n-                        (Postconditions_Proc (Current_Subprogram)));\n-               while Present (Decl) loop\n-                  Prev_Decl := Prev (Decl);\n-\n-                  Remove (Decl);\n-                  Prepend_To (New_Decls, Decl);\n-\n-                  exit when Nkind (Decl) = N_Subprogram_Declaration\n-                              and then Chars (Corresponding_Body (Decl))\n-                                         = Name_uPostconditions;\n-\n-                  Decl := Prev_Decl;\n-               end loop;\n+               Prepend_To (Decls, Mark_Call);\n+               Analyze (Mark_Call);\n             end;\n          end if;\n \n-         --  Ensure the presence of a declaration list in order to successfully\n-         --  append all original statements to it.\n-\n-         if No (Decls) then\n-            Set_Declarations (N, New_List);\n-            Decls := Declarations (N);\n-         end if;\n-\n-         --  Move the declarations into the sequence of statements in order to\n-         --  have them protected by the At_End handler. It may seem weird to\n-         --  put declarations in the sequence of statement but in fact nothing\n-         --  forbids that at the tree level.\n-\n-         Append_List_To (Decls, Statements (HSS));\n-         Set_Statements (HSS, Decls);\n-\n-         --  Reset the Sloc of the handled statement sequence to properly\n-         --  reflect the new initial \"statement\" in the sequence.\n-\n-         Set_Sloc (HSS, Sloc (First (Decls)));\n-\n-         --  The declarations of finalizer spec and auxiliary variables replace\n-         --  the old declarations that have been moved inward.\n-\n-         Set_Declarations (N, New_Decls);\n-         Analyze_Declarations (New_Decls);\n-\n          --  Generate finalization calls for all controlled objects appearing\n          --  in the statements of N. Add context specific cleanup for various\n          --  constructs.\n@@ -5814,7 +5171,7 @@ package body Exp_Ch7 is\n            (N           => N,\n             Clean_Stmts => Build_Cleanup_Statements (N, Cln),\n             Mark_Id     => Mark,\n-            Top_Decls   => New_Decls,\n+            Top_Decls   => Decls,\n             Defer_Abort => Nkind (Original_Node (N)) = N_Task_Body\n                              or else Is_Master,\n             Fin_Id      => Fin_Id);\n@@ -10103,9 +9460,6 @@ package body Exp_Ch7 is\n             Make_Handled_Sequence_Of_Statements (Loc,\n               Statements => New_List (Loop_Copy)));\n \n-      Set_First_Real_Statement\n-        (Handled_Statement_Sequence (Local_Body), Loop_Copy);\n-\n       Rewrite (Loop_Stmt, Local_Body);\n       Analyze (Loop_Stmt);\n "}, {"sha": "8abff55110dc55232839fbb072bc3a4aed48ac10", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 49, "deletions": 341, "changes": 390, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -26,6 +26,7 @@\n with Atree;          use Atree;\n with Aspects;        use Aspects;\n with Checks;         use Checks;\n+with Contracts;      use Contracts;\n with Einfo;          use Einfo;\n with Einfo.Entities; use Einfo.Entities;\n with Einfo.Utils;    use Einfo.Utils;\n@@ -134,15 +135,6 @@ package body Exp_Ch9 is\n    --  Build a specification for a function implementing the protected entry\n    --  barrier of the specified entry body.\n \n-   procedure Build_Contract_Wrapper (E : Entity_Id; Decl : Node_Id);\n-   --  Build the body of a wrapper procedure for an entry or entry family that\n-   --  has contract cases, preconditions, or postconditions. The body gathers\n-   --  the executable contract items and expands them in the usual way, and\n-   --  performs the entry call itself. This way preconditions are evaluated\n-   --  before the call is queued. E is the entry in question, and Decl is the\n-   --  enclosing synchronized type declaration at whose freeze point the\n-   --  generated body is analyzed.\n-\n    function Build_Corresponding_Record\n      (N    : Node_Id;\n       Ctyp : Entity_Id;\n@@ -1296,288 +1288,6 @@ package body Exp_Ch9 is\n       Set_Master_Id (Typ, Master_Id);\n    end Build_Class_Wide_Master;\n \n-   ----------------------------\n-   -- Build_Contract_Wrapper --\n-   ----------------------------\n-\n-   procedure Build_Contract_Wrapper (E : Entity_Id; Decl : Node_Id) is\n-      Conc_Typ : constant Entity_Id  := Scope (E);\n-      Loc      : constant Source_Ptr := Sloc (E);\n-\n-      procedure Add_Discriminant_Renamings\n-        (Obj_Id : Entity_Id;\n-         Decls  : List_Id);\n-      --  Add renaming declarations for all discriminants of concurrent type\n-      --  Conc_Typ. Obj_Id is the entity of the wrapper formal parameter which\n-      --  represents the concurrent object.\n-\n-      procedure Add_Matching_Formals\n-        (Formals : List_Id;\n-         Actuals : in out List_Id);\n-      --  Add formal parameters that match those of entry E to list Formals.\n-      --  The routine also adds matching actuals for the new formals to list\n-      --  Actuals.\n-\n-      procedure Transfer_Pragma (Prag : Node_Id; To : in out List_Id);\n-      --  Relocate pragma Prag to list To. The routine creates a new list if\n-      --  To does not exist.\n-\n-      --------------------------------\n-      -- Add_Discriminant_Renamings --\n-      --------------------------------\n-\n-      procedure Add_Discriminant_Renamings\n-        (Obj_Id : Entity_Id;\n-         Decls  : List_Id)\n-      is\n-         Discr : Entity_Id;\n-\n-      begin\n-         --  Inspect the discriminants of the concurrent type and generate a\n-         --  renaming for each one.\n-\n-         if Has_Discriminants (Conc_Typ) then\n-            Discr := First_Discriminant (Conc_Typ);\n-            while Present (Discr) loop\n-               Prepend_To (Decls,\n-                 Make_Object_Renaming_Declaration (Loc,\n-                   Defining_Identifier =>\n-                     Make_Defining_Identifier (Loc, Chars (Discr)),\n-                   Subtype_Mark        =>\n-                     New_Occurrence_Of (Etype (Discr), Loc),\n-                   Name                =>\n-                     Make_Selected_Component (Loc,\n-                       Prefix        => New_Occurrence_Of (Obj_Id, Loc),\n-                       Selector_Name =>\n-                         Make_Identifier (Loc, Chars (Discr)))));\n-\n-               Next_Discriminant (Discr);\n-            end loop;\n-         end if;\n-      end Add_Discriminant_Renamings;\n-\n-      --------------------------\n-      -- Add_Matching_Formals --\n-      --------------------------\n-\n-      procedure Add_Matching_Formals\n-        (Formals : List_Id;\n-         Actuals : in out List_Id)\n-      is\n-         Formal     : Entity_Id;\n-         New_Formal : Entity_Id;\n-\n-      begin\n-         --  Inspect the formal parameters of the entry and generate a new\n-         --  matching formal with the same name for the wrapper. A reference\n-         --  to the new formal becomes an actual in the entry call.\n-\n-         Formal := First_Formal (E);\n-         while Present (Formal) loop\n-            New_Formal := Make_Defining_Identifier (Loc, Chars (Formal));\n-            Append_To (Formals,\n-              Make_Parameter_Specification (Loc,\n-                Defining_Identifier => New_Formal,\n-                In_Present          => In_Present  (Parent (Formal)),\n-                Out_Present         => Out_Present (Parent (Formal)),\n-                Parameter_Type      =>\n-                  New_Occurrence_Of (Etype (Formal), Loc)));\n-\n-            if No (Actuals) then\n-               Actuals := New_List;\n-            end if;\n-\n-            Append_To (Actuals, New_Occurrence_Of (New_Formal, Loc));\n-            Next_Formal (Formal);\n-         end loop;\n-      end Add_Matching_Formals;\n-\n-      ---------------------\n-      -- Transfer_Pragma --\n-      ---------------------\n-\n-      procedure Transfer_Pragma (Prag : Node_Id; To : in out List_Id) is\n-         New_Prag : Node_Id;\n-\n-      begin\n-         if No (To) then\n-            To := New_List;\n-         end if;\n-\n-         New_Prag := Relocate_Node (Prag);\n-\n-         Set_Analyzed (New_Prag, False);\n-         Append       (New_Prag, To);\n-      end Transfer_Pragma;\n-\n-      --  Local variables\n-\n-      Items      : constant Node_Id := Contract (E);\n-      Actuals    : List_Id := No_List;\n-      Call       : Node_Id;\n-      Call_Nam   : Node_Id;\n-      Decls      : List_Id := No_List;\n-      Formals    : List_Id;\n-      Has_Pragma : Boolean := False;\n-      Index_Id   : Entity_Id;\n-      Obj_Id     : Entity_Id;\n-      Prag       : Node_Id;\n-      Wrapper_Id : Entity_Id;\n-\n-   --  Start of processing for Build_Contract_Wrapper\n-\n-   begin\n-      --  This routine generates a specialized wrapper for a protected or task\n-      --  entry [family] which implements precondition/postcondition semantics.\n-      --  Preconditions and case guards of contract cases are checked before\n-      --  the protected action or rendezvous takes place. Postconditions and\n-      --  consequences of contract cases are checked after the protected action\n-      --  or rendezvous takes place. The structure of the generated wrapper is\n-      --  as follows:\n-\n-      --    procedure Wrapper\n-      --      (Obj_Id    : Conc_Typ;    --  concurrent object\n-      --       [Index    : Index_Typ;]  --  index of entry family\n-      --       [Formal_1 : ...;         --  parameters of original entry\n-      --        Formal_N : ...])\n-      --    is\n-      --       [Discr_1 : ... renames Obj_Id.Discr_1;   --  discriminant\n-      --        Discr_N : ... renames Obj_Id.Discr_N;]  --  renamings\n-\n-      --       <precondition checks>\n-      --       <case guard checks>\n-\n-      --       procedure _Postconditions is\n-      --       begin\n-      --          <postcondition checks>\n-      --          <consequence checks>\n-      --       end _Postconditions;\n-\n-      --    begin\n-      --       Entry_Call (Obj_Id, [Index,] [Formal_1, Formal_N]);\n-      --       _Postconditions;\n-      --    end Wrapper;\n-\n-      --  Create the wrapper only when the entry has at least one executable\n-      --  contract item such as contract cases, precondition or postcondition.\n-\n-      if Present (Items) then\n-\n-         --  Inspect the list of pre/postconditions and transfer all available\n-         --  pragmas to the declarative list of the wrapper.\n-\n-         Prag := Pre_Post_Conditions (Items);\n-         while Present (Prag) loop\n-            if Pragma_Name_Unmapped (Prag) in Name_Postcondition\n-                                            | Name_Precondition\n-              and then Is_Checked (Prag)\n-            then\n-               Has_Pragma := True;\n-               Transfer_Pragma (Prag, To => Decls);\n-            end if;\n-\n-            Prag := Next_Pragma (Prag);\n-         end loop;\n-\n-         --  Inspect the list of test/contract cases and transfer only contract\n-         --  cases pragmas to the declarative part of the wrapper.\n-\n-         Prag := Contract_Test_Cases (Items);\n-         while Present (Prag) loop\n-            if Pragma_Name (Prag) = Name_Contract_Cases\n-              and then Is_Checked (Prag)\n-            then\n-               Has_Pragma := True;\n-               Transfer_Pragma (Prag, To => Decls);\n-            end if;\n-\n-            Prag := Next_Pragma (Prag);\n-         end loop;\n-      end if;\n-\n-      --  The entry lacks executable contract items and a wrapper is not needed\n-\n-      if not Has_Pragma then\n-         return;\n-      end if;\n-\n-      --  Create the profile of the wrapper. The first formal parameter is the\n-      --  concurrent object.\n-\n-      Obj_Id :=\n-        Make_Defining_Identifier (Loc,\n-          Chars => New_External_Name (Chars (Conc_Typ), 'A'));\n-\n-      Formals := New_List (\n-        Make_Parameter_Specification (Loc,\n-          Defining_Identifier => Obj_Id,\n-          Out_Present         => True,\n-          In_Present          => True,\n-          Parameter_Type      => New_Occurrence_Of (Conc_Typ, Loc)));\n-\n-      --  Construct the call to the original entry. The call will be gradually\n-      --  augmented with an optional entry index and extra parameters.\n-\n-      Call_Nam :=\n-        Make_Selected_Component (Loc,\n-          Prefix        => New_Occurrence_Of (Obj_Id, Loc),\n-          Selector_Name => New_Occurrence_Of (E, Loc));\n-\n-      --  When creating a wrapper for an entry family, the second formal is the\n-      --  entry index.\n-\n-      if Ekind (E) = E_Entry_Family then\n-         Index_Id := Make_Defining_Identifier (Loc, Name_I);\n-\n-         Append_To (Formals,\n-           Make_Parameter_Specification (Loc,\n-             Defining_Identifier => Index_Id,\n-             Parameter_Type      =>\n-               New_Occurrence_Of (Entry_Index_Type (E), Loc)));\n-\n-         --  The call to the original entry becomes an indexed component to\n-         --  accommodate the entry index.\n-\n-         Call_Nam :=\n-           Make_Indexed_Component (Loc,\n-             Prefix      => Call_Nam,\n-             Expressions => New_List (New_Occurrence_Of (Index_Id, Loc)));\n-      end if;\n-\n-      --  Add formal parameters to match those of the entry and build actuals\n-      --  for the entry call.\n-\n-      Add_Matching_Formals (Formals, Actuals);\n-\n-      Call :=\n-        Make_Procedure_Call_Statement (Loc,\n-          Name                   => Call_Nam,\n-          Parameter_Associations => Actuals);\n-\n-      --  Add renaming declarations for the discriminants of the enclosing type\n-      --  as the various contract items may reference them.\n-\n-      Add_Discriminant_Renamings (Obj_Id, Decls);\n-\n-      Wrapper_Id :=\n-        Make_Defining_Identifier (Loc, New_External_Name (Chars (E), 'E'));\n-      Set_Contract_Wrapper (E, Wrapper_Id);\n-      Set_Is_Entry_Wrapper (Wrapper_Id);\n-\n-      --  The wrapper body is analyzed when the enclosing type is frozen\n-\n-      Append_Freeze_Action (Defining_Entity (Decl),\n-        Make_Subprogram_Body (Loc,\n-          Specification              =>\n-            Make_Procedure_Specification (Loc,\n-              Defining_Unit_Name       => Wrapper_Id,\n-              Parameter_Specifications => Formals),\n-          Declarations               => Decls,\n-          Handled_Statement_Sequence =>\n-            Make_Handled_Sequence_Of_Statements (Loc,\n-              Statements => New_List (Call))));\n-   end Build_Contract_Wrapper;\n-\n    --------------------------------\n    -- Build_Corresponding_Record --\n    --------------------------------\n@@ -3811,6 +3521,7 @@ package body Exp_Ch9 is\n          --  Establish link between subprogram body and source entry body\n \n          Set_Corresponding_Entry_Body (Proc_Body, N);\n+         Set_At_End_Proc (Proc_Body, At_End_Proc (N));\n \n          Reset_Scopes_To (Proc_Body, Protected_Body_Subprogram (Ent));\n          return Proc_Body;\n@@ -3867,32 +3578,35 @@ package body Exp_Ch9 is\n       Ident       : Entity_Id;\n       Unprotected : Boolean := False) return List_Id\n    is\n-      Loc       : constant Source_Ptr := Sloc (N);\n-      Decl      : Node_Id;\n-      Formal    : Entity_Id;\n-      New_Plist : List_Id;\n-      New_Param : Node_Id;\n+      Loc : constant Source_Ptr := Sloc (N);\n+\n+      Decl       : Node_Id;\n+      Formal     : Entity_Id;\n+      New_Formal : Entity_Id;\n+      New_Plist  : List_Id;\n \n    begin\n       New_Plist := New_List;\n \n       Formal := First_Formal (Ident);\n       while Present (Formal) loop\n-         New_Param :=\n+         New_Formal :=\n+           Make_Defining_Identifier (Sloc (Formal), Chars (Formal));\n+         Set_Comes_From_Source (New_Formal, Comes_From_Source (Formal));\n+\n+         if Unprotected then\n+            Mutate_Ekind (New_Formal, Ekind (Formal));\n+            Set_Protected_Formal (Formal, New_Formal);\n+         end if;\n+\n+         Append_To (New_Plist,\n            Make_Parameter_Specification (Loc,\n-             Defining_Identifier =>\n-               Make_Defining_Identifier (Sloc (Formal), Chars (Formal)),\n+             Defining_Identifier => New_Formal,\n              Aliased_Present     => Aliased_Present (Parent (Formal)),\n              In_Present          => In_Present      (Parent (Formal)),\n              Out_Present         => Out_Present     (Parent (Formal)),\n-             Parameter_Type      => New_Occurrence_Of (Etype (Formal), Loc));\n-\n-         if Unprotected then\n-            Set_Protected_Formal (Formal, Defining_Identifier (New_Param));\n-            Mutate_Ekind (Defining_Identifier (New_Param), Ekind (Formal));\n-         end if;\n+             Parameter_Type      => New_Occurrence_Of (Etype (Formal), Loc)));\n \n-         Append (New_Param, New_Plist);\n          Next_Formal (Formal);\n       end loop;\n \n@@ -4021,8 +3735,7 @@ package body Exp_Ch9 is\n       Pid       : Node_Id;\n       N_Op_Spec : Node_Id) return Node_Id\n    is\n-      Exc_Safe : constant Boolean := not Might_Raise (N);\n-      --  True if N cannot raise an exception\n+      Might_Raise : constant Boolean := Sem_Util.Might_Raise (N);\n \n       Loc       : constant Source_Ptr := Sloc (N);\n       Op_Spec   : constant Node_Id := Specification (N);\n@@ -4059,7 +3772,17 @@ package body Exp_Ch9 is\n       --  for use by the protected version built below.\n \n       if Nkind (Op_Spec) = N_Function_Specification then\n-         if Exc_Safe then\n+         if Might_Raise then\n+            Unprot_Call :=\n+              Make_Simple_Return_Statement (Loc,\n+                Expression =>\n+                  Make_Function_Call (Loc,\n+                    Name                   =>\n+                      Make_Identifier (Loc,\n+                        Chars => Chars (Defining_Unit_Name (N_Op_Spec))),\n+                    Parameter_Associations => Uactuals));\n+\n+         else\n             R := Make_Temporary (Loc, 'R');\n \n             Unprot_Call :=\n@@ -4078,16 +3801,6 @@ package body Exp_Ch9 is\n             Return_Stmt :=\n               Make_Simple_Return_Statement (Loc,\n                 Expression => New_Occurrence_Of (R, Loc));\n-\n-         else\n-            Unprot_Call :=\n-              Make_Simple_Return_Statement (Loc,\n-                Expression =>\n-                  Make_Function_Call (Loc,\n-                    Name                   =>\n-                      Make_Identifier (Loc,\n-                        Chars => Chars (Defining_Unit_Name (N_Op_Spec))),\n-                    Parameter_Associations => Uactuals));\n          end if;\n \n          if Has_Aspect (Pid, Aspect_Exclusive_Functions)\n@@ -4113,7 +3826,7 @@ package body Exp_Ch9 is\n \n       --  Wrap call in block that will be covered by an at_end handler\n \n-      if not Exc_Safe then\n+      if Might_Raise then\n          Unprot_Call :=\n            Make_Block_Statement (Loc,\n              Handled_Statement_Sequence =>\n@@ -4160,7 +3873,7 @@ package body Exp_Ch9 is\n          Stmts := New_List (Lock_Stmt);\n       end if;\n \n-      if not Exc_Safe then\n+      if Might_Raise then\n          Append (Unprot_Call, Stmts);\n       else\n          if Nkind (Op_Spec) = N_Function_Specification then\n@@ -4170,10 +3883,6 @@ package body Exp_Ch9 is\n             Append (Unprot_Call, Stmts);\n          end if;\n \n-         --  Historical note: Previously, call to the cleanup was inserted\n-         --  here. This is now done by Build_Protected_Subprogram_Call_Cleanup,\n-         --  which is also shared by the 'not Exc_Safe' path.\n-\n          Build_Protected_Subprogram_Call_Cleanup (Op_Spec, Pid, Loc, Stmts);\n \n          if Nkind (Op_Spec) = N_Function_Specification then\n@@ -4196,10 +3905,10 @@ package body Exp_Ch9 is\n             Make_Handled_Sequence_Of_Statements (Loc, Statements => Stmts));\n \n       --  Mark this subprogram as a protected subprogram body so that the\n-      --  cleanup will be inserted. This is done only in the 'not Exc_Safe'\n-      --  path as otherwise the cleanup has already been inserted.\n+      --  cleanup will be inserted. This is done only in the Might_Raise\n+      --  case because otherwise the cleanup has already been inserted.\n \n-      if not Exc_Safe then\n+      if Might_Raise then\n          Set_Is_Protected_Subprogram_Body (Sub_Body);\n       end if;\n \n@@ -5236,7 +4945,8 @@ package body Exp_Ch9 is\n           Specification              =>\n             Build_Protected_Sub_Specification (N, Pid, Unprotected_Mode),\n           Declarations               => Decls,\n-          Handled_Statement_Sequence => Handled_Statement_Sequence (N));\n+          Handled_Statement_Sequence => Handled_Statement_Sequence (N),\n+          At_End_Proc                => At_End_Proc (N));\n    end Build_Unprotected_Subprogram_Body;\n \n    ----------------------------\n@@ -8216,7 +7926,7 @@ package body Exp_Ch9 is\n \n       else\n          Transient_Blk :=\n-           First_Real_Statement (Handled_Statement_Sequence (Blk));\n+           First (Statements (Handled_Statement_Sequence (Blk)));\n \n          if Present (Transient_Blk)\n            and then Nkind (Transient_Blk) = N_Block_Statement\n@@ -9135,7 +8845,7 @@ package body Exp_Ch9 is\n          --  Build a wrapper procedure to handle contract cases, preconditions,\n          --  and postconditions.\n \n-         Build_Contract_Wrapper (Ent_Id, N);\n+         Build_Entry_Contract_Wrapper (Ent_Id, N);\n \n          --  Create the barrier function\n \n@@ -11833,17 +11543,11 @@ package body Exp_Ch9 is\n \n       if Abort_Allowed then\n          Call := Build_Runtime_Call (Loc, RE_Abort_Undefer);\n-         Insert_Before\n-           (First (Statements (Handled_Statement_Sequence (N))), Call);\n+         Prepend (Call, Declarations (N));\n          Analyze (Call);\n       end if;\n \n-      --  The statement part has already been protected with an at_end and\n-      --  cleanup actions. The call to Complete_Activation must be placed\n-      --  at the head of the sequence of statements of that block. The\n-      --  declarations have been merged in this sequence of statements but\n-      --  the first real statement is accessible from the First_Real_Statement\n-      --  field (which was set for exactly this purpose).\n+      --  Place call to Complete_Activation at the head of the statement list.\n \n       if Restricted_Profile then\n          Call := Build_Runtime_Call (Loc, RE_Complete_Restricted_Activation);\n@@ -11852,7 +11556,7 @@ package body Exp_Ch9 is\n       end if;\n \n       Insert_Before\n-        (First_Real_Statement (Handled_Statement_Sequence (N)), Call);\n+        (First (Statements (Handled_Statement_Sequence (N))), Call);\n       Analyze (Call);\n \n       New_N :=\n@@ -11861,6 +11565,7 @@ package body Exp_Ch9 is\n           Declarations               => Declarations (N),\n           Handled_Statement_Sequence => Handled_Statement_Sequence (N));\n       Set_Is_Task_Body_Procedure (New_N);\n+      Set_At_End_Proc (New_N, At_End_Proc (N));\n \n       --  If the task contains generic instantiations, cleanup actions are\n       --  delayed until after instantiation. Transfer the activation chain to\n@@ -12534,7 +12239,7 @@ package body Exp_Ch9 is\n          Ent := First_Entity (Tasktyp);\n          while Present (Ent) loop\n             if Ekind (Ent) in E_Entry | E_Entry_Family then\n-               Build_Contract_Wrapper (Ent, N);\n+               Build_Entry_Contract_Wrapper (Ent, N);\n             end if;\n \n             Next_Entity (Ent);\n@@ -13736,6 +13441,7 @@ package body Exp_Ch9 is\n                   Make_Selected_Component (Loc,\n                     Prefix        => New_Occurrence_Of (Obj_Ent, Loc),\n                     Selector_Name => Make_Identifier (Loc, Name_uObject)));\n+\n             Add (Decl);\n          end;\n       end if;\n@@ -13767,6 +13473,7 @@ package body Exp_Ch9 is\n                      Make_Selected_Component (Loc,\n                        Prefix        => New_Occurrence_Of (Obj_Ent, Loc),\n                        Selector_Name => Make_Identifier (Loc, Chars (D))));\n+\n                Add (Decl);\n \n                --  Set debug info needed on this renaming declaration even\n@@ -13833,6 +13540,7 @@ package body Exp_Ch9 is\n                            Make_Selected_Component (Loc,\n                              Prefix => New_Occurrence_Of (Obj_Ent, Loc),\n                              Selector_Name => Make_Identifier (Loc, Nam)));\n+\n                      Add (Decl);\n                   end if;\n "}, {"sha": "2def83cc20c87a16dc5857743fddc38b9483999a", "filename": "gcc/ada/exp_prag.adb", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fexp_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fexp_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_prag.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -453,6 +453,8 @@ package body Exp_Prag is\n                            New_Occurrence_Of (RTE (RE_Assert_Failure),\n                                                                    Loc))))))));\n \n+         Set_Comes_From_Check_Or_Contract (N);\n+\n       --  Case where we call the procedure\n \n       else\n@@ -541,6 +543,8 @@ package body Exp_Prag is\n                  Name                   =>\n                    New_Occurrence_Of (RTE (RE_Raise_Assert_Failure), Loc),\n                  Parameter_Associations => New_List (Relocate_Node (Msg))))));\n+\n+         Set_Comes_From_Check_Or_Contract (N);\n       end if;\n \n       Analyze (N);\n@@ -1433,6 +1437,8 @@ package body Exp_Prag is\n                 Condition       => Cond,\n                 Then_Statements => New_List (Error));\n \n+            Set_Comes_From_Check_Or_Contract (Checks);\n+\n          else\n             if No (Elsif_Parts (Checks)) then\n                Set_Elsif_Parts (Checks, New_List);\n@@ -1642,6 +1648,8 @@ package body Exp_Prag is\n                 Condition       => New_Occurrence_Of (Flag, Loc),\n                 Then_Statements => Eval_Stmts);\n \n+            Set_Comes_From_Check_Or_Contract (Evals);\n+\n          --  Otherwise generate:\n          --    elsif Flag then\n          --       <evaluation statements>\n@@ -1836,6 +1844,8 @@ package body Exp_Prag is\n                   Set (Flag),\n                   Increment (Count)));\n \n+            Set_Comes_From_Check_Or_Contract (If_Stmt);\n+\n             Append_To (Decls, If_Stmt);\n             Analyze (If_Stmt);\n \n@@ -1904,6 +1914,8 @@ package body Exp_Prag is\n               Right_Opnd => Make_Integer_Literal (Loc, 0)),\n           Then_Statements => CG_Stmts);\n \n+      Set_Comes_From_Check_Or_Contract (CG_Checks);\n+\n       --  Detect a possible failure due to several case guards evaluating to\n       --  True.\n \n@@ -1937,15 +1949,17 @@ package body Exp_Prag is\n                            New_Occurrence_Of (Msg_Str, Loc))))))))));\n       end if;\n \n+      --  Append the checks, but do not analyze them at this point, because\n+      --  contracts get potentially expanded as part of a wrapper which gets\n+      --  fully analyzed once it is fully formed.\n+\n       Append_To (Decls, CG_Checks);\n-      Analyze (CG_Checks);\n \n       --  Once all case guards are evaluated and checked, evaluate any prefixes\n       --  of attribute 'Old founds in the selected consequence.\n \n       if Present (Old_Evals) then\n          Append_To (Decls, Old_Evals);\n-         Analyze (Old_Evals);\n       end if;\n \n       --  Raise Assertion_Error when the corresponding consequence of a case"}, {"sha": "9164644747537167648770d1dd3092d8d2b2b292", "filename": "gcc/ada/exp_unst.adb", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fexp_unst.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fexp_unst.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_unst.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -938,7 +938,7 @@ package body Exp_Unst is\n                --  subprogram. As above, the called entity must be local and\n                --  not imported.\n \n-               when N_Handled_Sequence_Of_Statements =>\n+               when N_Handled_Sequence_Of_Statements | N_Block_Statement =>\n                   if Present (At_End_Proc (N))\n                     and then Scope_Within (Entity (At_End_Proc (N)), Subp)\n                     and then not Is_Imported (Entity (At_End_Proc (N)))\n@@ -1184,6 +1184,15 @@ package body Exp_Unst is\n \n                   Register_Subprogram (Ent, N);\n \n+                  --  Record a call from an At_End_Proc\n+\n+                  if Present (At_End_Proc (N))\n+                    and then Scope_Within (Entity (At_End_Proc (N)), Subp)\n+                    and then not Is_Imported (Entity (At_End_Proc (N)))\n+                  then\n+                     Append_Unique_Call ((N, Ent, Entity (At_End_Proc (N))));\n+                  end if;\n+\n                   --  We make a recursive call to scan the subprogram body, so\n                   --  that we can save and restore Current_Subprogram.\n \n@@ -2583,6 +2592,8 @@ package body Exp_Unst is\n                  and then Is_Library_Level_Entity (Spec_Id)\n                then\n                   Unnest_Subprogram (Spec_Id, N);\n+               else\n+                  return Skip;\n                end if;\n             end;\n "}, {"sha": "61395adf1956355ac35e9bb0c3602178924b3c34", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 14, "deletions": 23, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -1293,7 +1293,8 @@ package body Exp_Util is\n                --  Gigi expects a different profile in the Secondary_Stack_Pool\n                --  case. There must be no uses of the two missing formals\n                --  (i.e., Pool_Param and Alignment_Param) in this case.\n-               Formal_Params := New_List (Address_Param, Size_Param);\n+               Formal_Params := New_List\n+                 (Address_Param, Size_Param, Alignment_Param);\n             else\n                Formal_Params := New_List (\n                  Pool_Param, Address_Param, Size_Param, Alignment_Param);\n@@ -2042,7 +2043,7 @@ package body Exp_Util is\n       elsif Is_Underlying_Full_View (Work_Typ) then\n          return;\n \n-      --  Use the first subtype when dealing with various base types\n+      --  Use the first subtype when dealing with implicit base types\n \n       elsif Is_Itype (Work_Typ) then\n          Work_Typ := First_Subtype (Work_Typ);\n@@ -5187,19 +5188,6 @@ package body Exp_Util is\n       end if;\n    end Ensure_Defined;\n \n-   --------------------\n-   -- Entry_Names_OK --\n-   --------------------\n-\n-   function Entry_Names_OK return Boolean is\n-   begin\n-      return\n-        not Restricted_Profile\n-          and then not Global_Discard_Names\n-          and then not Restriction_Active (No_Implicit_Heap_Allocations)\n-          and then not Restriction_Active (No_Local_Allocators);\n-   end Entry_Names_OK;\n-\n    -------------------\n    -- Evaluate_Name --\n    -------------------\n@@ -5732,14 +5720,17 @@ package body Exp_Util is\n       then\n          if Is_Itype (Exp_Typ)\n \n-           --  If Exp_Typ was created for a previous declaration whose nominal\n-           --  subtype is unconstrained, and that declaration is aliased,\n-           --  we need to generate a new subtype, because otherwise the\n-           --  Is_Constr_Subt_For_U_Nominal flag will be set on the wrong\n-           --  subtype, causing failure to detect non-statically-matching\n-           --  subtypes on 'Access of the previously-declared object.\n-\n-           and then not Is_Constr_Subt_For_UN_Aliased (Exp_Typ)\n+           --  When this is for an object declaration, the caller may want to\n+           --  set Is_Constr_Subt_For_U_Nominal on the subtype, so we must make\n+           --  sure that either the subtype has been built for the expression,\n+           --  typically for an aggregate, or the flag is already set on it;\n+           --  otherwise it could end up being set on the nominal constrained\n+           --  subtype of an object and thus later cause the failure to detect\n+           --  non-statically-matching subtypes on 'Access of this object.\n+\n+           and then (Nkind (N) /= N_Object_Declaration\n+                      or else Nkind (Original_Node (Exp)) = N_Aggregate\n+                      or else Is_Constr_Subt_For_U_Nominal (Exp_Typ))\n          then\n             --  Within an initialization procedure, a selected component\n             --  denotes a component of the enclosing record, and it appears as"}, {"sha": "a21fb8b5c2a7c66ca34a2387abfadebf68a29aba", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -509,11 +509,6 @@ package Exp_Util is\n    --  used to ensure that an Itype is properly defined outside a conditional\n    --  construct when it is referenced in more than one branch.\n \n-   function Entry_Names_OK return Boolean;\n-   --  Determine whether it is appropriate to dynamically allocate strings\n-   --  which represent entry [family member] names. These strings are created\n-   --  by the compiler and used by GDB.\n-\n    procedure Evaluate_Name (Nam : Node_Id);\n    --  Remove all side effects from a name which appears as part of an object\n    --  renaming declaration. Similarly to Force_Evaluation, it removes the"}, {"sha": "02cf105d5e1991bc85ec519fbd1999ffd63c65e0", "filename": "gcc/ada/fe.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Ffe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Ffe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffe.h?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -217,6 +217,7 @@ extern Boolean In_Extended_Main_Code_Unit\t(Entity_Id);\n #define List_Representation_Info\topt__list_representation_info\n #define No_Strict_Aliasing_CP\t\topt__no_strict_aliasing\n #define Suppress_Checks\t\t\topt__suppress_checks\n+#define Unnest_Subprogram_Mode\t\topt__unnest_subprogram_mode\n \n typedef enum {\n   Ada_83, Ada_95, Ada_2005, Ada_2012, Ada_2022, Ada_With_Extensions\n@@ -233,6 +234,7 @@ extern Boolean GNAT_Mode;\n extern Int List_Representation_Info;\n extern Boolean No_Strict_Aliasing_CP;\n extern Boolean Suppress_Checks;\n+extern Boolean Unnest_Subprogram_Mode;\n \n #define ZCX_Exceptions\t\topt__zcx_exceptions\n #define SJLJ_Exceptions\t\topt__sjlj_exceptions"}, {"sha": "346904ee0a4681c145e9df020e3cfd3fd05fb42b", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 44, "deletions": 10, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -6248,6 +6248,32 @@ package body Freeze is\n         and then Scope (Test_E) /= Current_Scope\n         and then Ekind (Test_E) /= E_Constant\n       then\n+         --  Here we deal with the special case of the expansion of\n+         --  postconditions. Previously this was handled by the loop below,\n+         --  since these postcondition checks got isolated to a separate,\n+         --  internally generated, subprogram. Now, however, the postcondition\n+         --  checks get contained within their corresponding subprogram\n+         --  directly.\n+\n+         if not Comes_From_Source (N)\n+           and then Nkind (N) = N_Pragma\n+           and then From_Aspect_Specification (N)\n+           and then Is_Valid_Assertion_Kind (Original_Aspect_Pragma_Name (N))\n+\n+           --  Now, verify the placement of the pragma is within an expanded\n+           --  subprogram which contains postcondition expansion - detected\n+           --  through the presence of the \"Wrapped_Statements\" field.\n+\n+           and then Present (Enclosing_Subprogram (Current_Scope))\n+           and then Present (Wrapped_Statements\n+                              (Enclosing_Subprogram (Current_Scope)))\n+         then\n+            goto Leave;\n+         end if;\n+\n+         --  Otherwise, loop through scopes checking if an enclosing scope\n+         --  comes from source or is a generic.\n+\n          declare\n             S : Entity_Id;\n \n@@ -6366,9 +6392,7 @@ package body Freeze is\n          end;\n       end if;\n \n-      if Has_Delayed_Aspects (E)\n-        or else May_Inherit_Delayed_Rep_Aspects (E)\n-      then\n+      if Has_Delayed_Aspects (E) then\n          Analyze_Aspects_At_Freeze_Point (E);\n       end if;\n \n@@ -6799,18 +6823,25 @@ package body Freeze is\n             --  A subtype inherits all the type-related representation aspects\n             --  from its parents (RM 13.1(8)).\n \n+            if May_Inherit_Delayed_Rep_Aspects (E) then\n+               Inherit_Delayed_Rep_Aspects (E);\n+            end if;\n+\n             Inherit_Aspects_At_Freeze_Point (E);\n \n          --  For a derived type, freeze its parent type first (RM 13.14(15))\n \n          elsif Is_Derived_Type (E) then\n             Freeze_And_Append (Etype (E), N, Result);\n-            Freeze_And_Append (First_Subtype (Etype (E)), N, Result);\n \n             --  A derived type inherits each type-related representation aspect\n             --  of its parent type that was directly specified before the\n             --  declaration of the derived type (RM 13.1(15)).\n \n+            if May_Inherit_Delayed_Rep_Aspects (E) then\n+               Inherit_Delayed_Rep_Aspects (E);\n+            end if;\n+\n             Inherit_Aspects_At_Freeze_Point (E);\n          end if;\n \n@@ -8325,9 +8356,9 @@ package body Freeze is\n             --  If the parent is a subprogram body, the candidate insertion\n             --  point is just ahead of it.\n \n-            if  Nkind (Parent_P) = N_Subprogram_Body\n-                and then Unique_Defining_Entity (Parent_P) =\n-                           Freeze_Outside_Subp\n+            if Nkind (Parent_P) = N_Subprogram_Body\n+              and then Unique_Defining_Entity (Parent_P) =\n+                         Freeze_Outside_Subp\n             then\n                P := Parent_P;\n                exit;\n@@ -9089,6 +9120,11 @@ package body Freeze is\n          Set_Has_Delayed_Aspects (Ftyp, False);\n       end if;\n \n+      if May_Inherit_Delayed_Rep_Aspects (Ftyp) then\n+         Inherit_Delayed_Rep_Aspects (Ftyp);\n+         Set_May_Inherit_Delayed_Rep_Aspects (Ftyp, False);\n+      end if;\n+\n       --  Inherit the Small value from the first subtype in any case\n \n       if Typ /= Ftyp then\n@@ -9653,9 +9689,7 @@ package body Freeze is\n       Set_Has_Delayed_Freeze (T);\n       L := Freeze_Entity (T, N);\n \n-      if Is_Non_Empty_List (L) then\n-         Insert_Actions (N, L);\n-      end if;\n+      Insert_Actions (N, L);\n    end Freeze_Itype;\n \n    --------------------------"}, {"sha": "c5a93fb3acd5a5a6545980bcf6421ccccfffeb26", "filename": "gcc/ada/gcc-interface/decl.cc", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fgcc-interface%2Fdecl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fgcc-interface%2Fdecl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.cc?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -436,7 +436,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n   /* If this is a numeric or enumeral type, or an access type, a nonzero Esize\n      must be specified unless it was specified by the programmer.  Exceptions\n      are for access-to-protected-subprogram types and all access subtypes, as\n-     another GNAT type is used to lay out the GCC type for them.  */\n+     another GNAT type is used to lay out the GCC type for them, as well as\n+     access-to-subprogram types if front-end unnesting is enabled.  */\n   gcc_assert (!is_type\n \t      || Known_Esize (gnat_entity)\n \t      || Has_Size_Clause (gnat_entity)\n@@ -445,6 +446,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t\t  && (!IN (kind, Access_Kind)\n \t\t      || kind == E_Access_Protected_Subprogram_Type\n \t\t      || kind == E_Anonymous_Access_Protected_Subprogram_Type\n+\t\t      || ((kind == E_Access_Subprogram_Type\n+\t\t\t   || kind == E_Anonymous_Access_Subprogram_Type)\n+\t\t\t  && Unnest_Subprogram_Mode)\n \t\t      || kind == E_Access_Subtype\n \t\t      || type_annotate_only)));\n \n@@ -5602,6 +5606,7 @@ gnat_to_gnu_param (Entity_Id gnat_param, tree gnu_param_type, bool first,\n \n   gnu_param = create_param_decl (gnu_param_name, gnu_param_type);\n   TREE_READONLY (gnu_param) = ro_param || by_ref || by_component_ptr;\n+  DECL_ARTIFICIAL (gnu_param) = !Comes_From_Source (gnat_param);\n   DECL_BY_REF_P (gnu_param) = by_ref;\n   DECL_FORCED_BY_REF_P (gnu_param) = forced_by_ref;\n   DECL_BY_COMPONENT_PTR_P (gnu_param) = by_component_ptr;"}, {"sha": "2d93947cb2649ea9778a4cea9c16dbf6f187d48c", "filename": "gcc/ada/gcc-interface/trans.cc", "status": "modified", "additions": 149, "deletions": 113, "changes": 262, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fgcc-interface%2Ftrans.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fgcc-interface%2Ftrans.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.cc?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -234,7 +234,7 @@ static inline bool stmt_group_may_fallthru (void);\n static enum gimplify_status gnat_gimplify_stmt (tree *);\n static void elaborate_all_entities (Node_Id);\n static void process_freeze_entity (Node_Id);\n-static void process_decls (List_Id, List_Id, Node_Id, bool, bool);\n+static void process_decls (List_Id, List_Id, bool, bool);\n static tree emit_check (tree, tree, int, Node_Id);\n static tree build_unary_op_trapv (enum tree_code, tree, tree, Node_Id);\n static tree build_binary_op_trapv (enum tree_code, tree, tree, tree, Node_Id);\n@@ -413,7 +413,6 @@ gigi (Node_Id gnat_root,\n   save_gnu_tree (gnat_literal, t, false);\n \n   /* Declare the building blocks of function nodes.  */\n-  void_list_node = build_tree_list (NULL_TREE, void_type_node);\n   void_ftype = build_function_type_list (void_type_node, NULL_TREE);\n   ptr_void_ftype = build_pointer_type (void_ftype);\n \n@@ -1088,28 +1087,48 @@ Gigi_Types_Compatible (Entity_Id type, Entity_Id def_type)\n   return false;\n }\n \n+/* Return the full view of a private constant E, or of a renaming thereof, if\n+   its type has discriminants, and Empty otherwise.  */\n+\n+static Entity_Id\n+Full_View_Of_Private_Constant (Entity_Id E)\n+{\n+  while (Present (Renamed_Object (E)) && Is_Entity_Name (Renamed_Object (E)))\n+    E = Entity (Renamed_Object (E));\n+\n+  if (Ekind (E) != E_Constant || No (Full_View (E)))\n+    return Empty;\n+\n+  const Entity_Id T = Etype (E);\n+\n+  if (Is_Private_Type (T)\n+      && (Has_Unknown_Discriminants (T)\n+\t  || (Present (Full_View (T)) && Has_Discriminants (Full_View (T)))))\n+    return Full_View (E);\n+\n+  return Empty;\n+}\n+\n /* Subroutine of gnat_to_gnu to translate GNAT_NODE, an N_Identifier, to a GCC\n    tree, which is returned.  GNU_RESULT_TYPE_P is a pointer to where we should\n    place the result type.  */\n \n static tree\n Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n {\n-  /* The entity of GNAT_NODE and its type.  */\n-  Node_Id gnat_entity = (Nkind (gnat_node) == N_Defining_Identifier\n-\t\t\t || Nkind (gnat_node) == N_Defining_Operator_Symbol)\n-\t\t\t? gnat_node : Entity (gnat_node);\n-  Node_Id gnat_entity_type = Etype (gnat_entity);\n+  Entity_Id gnat_entity = (Nkind (gnat_node) == N_Defining_Identifier\n+\t\t\t   || Nkind (gnat_node) == N_Defining_Operator_Symbol)\n+\t\t\t  ? gnat_node : Entity (gnat_node);\n+  Entity_Id gnat_result_type;\n+  tree gnu_result, gnu_result_type;\n   /* If GNAT_NODE is a constant, whether we should use the initialization\n      value instead of the constant entity, typically for scalars with an\n      address clause when the parent doesn't require an lvalue.  */\n-  bool use_constant_initializer = false;\n+  bool use_constant_initializer;\n   /* Whether we should require an lvalue for GNAT_NODE.  Needed in\n      specific circumstances only, so evaluated lazily.  < 0 means\n      unknown, > 0 means known true, 0 means known false.  */\n-  int require_lvalue = -1;\n-  Entity_Id gnat_result_type;\n-  tree gnu_result, gnu_result_type;\n+  int require_lvalue;\n \n   /* If the Etype of this node is not the same as that of the Entity, then\n      something went wrong, probably in generic instantiation.  However, this\n@@ -1118,25 +1137,17 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n      may have been changed to a subtype by Exp_Ch3.Adjust_Discriminants.  */\n   gcc_assert (!Is_Object (gnat_entity)\n \t      || Ekind (gnat_entity) == E_Discriminant\n-\t      || Etype (gnat_node) == gnat_entity_type\n-\t      || Gigi_Types_Compatible (Etype (gnat_node), gnat_entity_type));\n+\t      || Etype (gnat_node) == Etype (gnat_entity)\n+\t      || Gigi_Types_Compatible (Etype (gnat_node),\n+\t\t\t\t\tEtype (gnat_entity)));\n \n-  /* If this is a reference to a deferred constant whose partial view is an\n+  /* If this is a reference to a deferred constant whose partial view is of\n      unconstrained private type, the proper type is on the full view of the\n-     constant, not on the full view of the type, which may be unconstrained.\n-\n-     This may be a reference to a type, for example in the prefix of the\n-     attribute Position, generated for dispatching code (see Make_DT in\n-     exp_disp,adb). In that case we need the type itself, not is parent,\n-     in particular if it is a derived type  */\n-  if (Ekind (gnat_entity) == E_Constant\n-      && Is_Private_Type (gnat_entity_type)\n-      && (Has_Unknown_Discriminants (gnat_entity_type)\n-\t  || (Present (Full_View (gnat_entity_type))\n- \t      && Has_Discriminants (Full_View (gnat_entity_type))))\n-      && Present (Full_View (gnat_entity)))\n+     constant, not on the full view of the type which may be unconstrained.  */\n+  const Entity_Id gnat_full_view = Full_View_Of_Private_Constant (gnat_entity);\n+  if (Present (gnat_full_view))\n     {\n-      gnat_entity = Full_View (gnat_entity);\n+      gnat_entity = gnat_full_view;\n       gnat_result_type = Etype (gnat_entity);\n     }\n   else\n@@ -1184,7 +1195,13 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n \t= lvalue_required_p (gnat_node, gnu_result_type, true, false);\n       use_constant_initializer = !require_lvalue;\n     }\n+  else\n+    {\n+      require_lvalue = -1;\n+      use_constant_initializer = false;\n+    }\n \n+  /* Fetch the initialization value of a constant if requested.  */\n   if (use_constant_initializer)\n     {\n       /* If this is a deferred constant, the initializer is attached to\n@@ -3778,6 +3795,39 @@ build_return_expr (tree ret_obj, tree ret_val)\n   return build1 (RETURN_EXPR, void_type_node, result_expr);\n }\n \n+/* Subroutine of gnat_to_gnu to translate the At_End_Proc of GNAT_NODE, an\n+   N_Block_Statement or N_Handled_Sequence_Of_Statements or N_*_Body node.\n+\n+   To invoked the GCC mechanism, we call add_cleanup and when we leave the\n+   group, end_stmt_group will create the TRY_FINALLY_EXPR construct.  */\n+\n+static void\n+At_End_Proc_to_gnu (Node_Id gnat_node)\n+{\n+  tree proc_decl = gnat_to_gnu (At_End_Proc (gnat_node));\n+  Node_Id gnat_end_label;\n+\n+  /* When not optimizing, disable inlining of finalizers as this can\n+     create a more complex CFG in the parent function.  */\n+  if (!optimize || optimize_debug)\n+    DECL_DECLARED_INLINE_P (proc_decl) = 0;\n+\n+  /* Retrieve the end label attached to the node, if any.  */\n+  if (Nkind (gnat_node) == N_Handled_Sequence_Of_Statements)\n+    gnat_end_label = End_Label (gnat_node);\n+  else if (Present (Handled_Statement_Sequence (gnat_node)))\n+    gnat_end_label = End_Label (Handled_Statement_Sequence (gnat_node));\n+  else\n+    gnat_end_label = Empty;\n+\n+  /* If there is no end label attached, we use the location of the At_End\n+     procedure because Expand_Cleanup_Actions might reset the location of\n+     the enclosing construct to that of an inner statement.  */\n+  add_cleanup (build_call_n_expr (proc_decl, 0),\n+\t       Present (gnat_end_label)\n+\t       ? gnat_end_label : At_End_Proc (gnat_node));\n+}\n+\n /* Subroutine of gnat_to_gnu to translate GNAT_NODE, an N_Subprogram_Body.  */\n \n static void\n@@ -3928,12 +3978,16 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n   gnat_pushlevel ();\n \n   /* First translate the declarations of the subprogram.  */\n-  process_decls (Declarations (gnat_node), Empty, Empty, true, true);\n+  process_decls (Declarations (gnat_node), Empty, true, true);\n \n   /* Then generate the code of the subprogram itself.  A return statement will\n      be present and any Out parameters will be handled there.  */\n   add_stmt (gnat_to_gnu (Handled_Statement_Sequence (gnat_node)));\n \n+  /* Process the At_End_Proc, if any.  */\n+  if (Present (At_End_Proc (gnat_node)))\n+    At_End_Proc_to_gnu (gnat_node);\n+\n   gnat_poplevel ();\n   tree gnu_result = end_stmt_group ();\n \n@@ -5305,86 +5359,50 @@ static tree\n Handled_Sequence_Of_Statements_to_gnu (Node_Id gnat_node)\n {\n   /* If just annotating, ignore all EH and cleanups.  */\n-  const bool gcc_eh\n+  const bool eh\n     = !type_annotate_only && Present (Exception_Handlers (gnat_node));\n   const bool at_end = !type_annotate_only && Present (At_End_Proc (gnat_node));\n-  const bool binding_for_block = (at_end || gcc_eh);\n-  tree gnu_inner_block; /* The statement(s) for the block itself.  */\n   tree gnu_result;\n   Node_Id gnat_temp;\n \n-  /* The GCC exception handling mechanism can handle both ZCX and SJLJ schemes.\n-     To call the GCC mechanism, we call add_cleanup, and when we leave the\n-     binding, end_stmt_group will create the TRY_FINALLY_EXPR construct.\n+  /* The exception handling mechanism can handle both ZCX and SJLJ schemes, and\n+     is exposed through the TRY_CATCH_EXPR construct that we build manually.\n \n      ??? The region level calls down there have been specifically put in place\n      for a ZCX context and currently the order in which things are emitted\n      (region/handlers) is different from the SJLJ case.  Instead of putting\n      other calls with different conditions at other places for the SJLJ case,\n      it seems cleaner to reorder things for the SJLJ case and generalize the\n-     condition to make it not ZCX specific.\n-\n-     If there are any exceptions or cleanup processing involved, we need an\n-     outer statement group and binding level.  */\n-  if (binding_for_block)\n-    {\n-      start_stmt_group ();\n-      gnat_pushlevel ();\n-    }\n-\n-  /* If we are to call a function when exiting this block, add a cleanup\n-     to the binding level we made above.  Note that add_cleanup is FIFO\n-     so we must register this cleanup after the EH cleanup just above.  */\n-  if (at_end)\n-    {\n-      tree proc_decl = gnat_to_gnu (At_End_Proc (gnat_node));\n-\n-      /* When not optimizing, disable inlining of finalizers as this can\n-\t create a more complex CFG in the parent function.  */\n-      if (!optimize || optimize_debug)\n-\tDECL_DECLARED_INLINE_P (proc_decl) = 0;\n-\n-      /* If there is no end label attached, we use the location of the At_End\n-\t procedure because Expand_Cleanup_Actions might reset the location of\n-\t the enclosing construct to that of an inner statement.  */\n-      add_cleanup (build_call_n_expr (proc_decl, 0),\n-\t\t   Present (End_Label (gnat_node))\n-\t\t   ? End_Label (gnat_node) : At_End_Proc (gnat_node));\n-    }\n+     condition to make it not ZCX specific.  */\n \n-  /* Now build the tree for the declarations and statements inside this\n-     block.  */\n+  /* First build the tree for the statements inside the sequence.  */\n   start_stmt_group ();\n \n-  if (Present (First_Real_Statement (gnat_node)))\n-    process_decls (Statements (gnat_node), Empty,\n-\t\t   First_Real_Statement (gnat_node), true, true);\n-\n-  /* Generate code for each statement in the block.  */\n-  for (gnat_temp = (Present (First_Real_Statement (gnat_node))\n-\t\t    ? First_Real_Statement (gnat_node)\n-\t\t    : First (Statements (gnat_node)));\n-       Present (gnat_temp); gnat_temp = Next (gnat_temp))\n+  for (gnat_temp = First (Statements (gnat_node));\n+       Present (gnat_temp);\n+       gnat_temp = Next (gnat_temp))\n     add_stmt (gnat_to_gnu (gnat_temp));\n \n-  gnu_inner_block = end_stmt_group ();\n+  gnu_result = end_stmt_group ();\n \n-  if (gcc_eh)\n+  /* Then process the exception handlers, if any.  */\n+  if (eh)\n     {\n       tree gnu_handlers;\n       location_t locus;\n \n-      /* First make a block containing the handlers.  */\n+      /* First make a group containing the handlers.  */\n       start_stmt_group ();\n       for (gnat_temp = First_Non_Pragma (Exception_Handlers (gnat_node));\n \t   Present (gnat_temp);\n \t   gnat_temp = Next_Non_Pragma (gnat_temp))\n \tadd_stmt (gnat_to_gnu (gnat_temp));\n       gnu_handlers = end_stmt_group ();\n \n-      /* Now make the TRY_CATCH_EXPR for the block.  */\n-      gnu_result = build2 (TRY_CATCH_EXPR, void_type_node,\n-\t\t\t   gnu_inner_block, gnu_handlers);\n+      /* Now make the TRY_CATCH_EXPR for the group.  */\n+      gnu_result\n+\t= build2 (TRY_CATCH_EXPR, void_type_node, gnu_result, gnu_handlers);\n+\n       /* Set a location.  We need to find a unique location for the dispatching\n \t code, otherwise we can get coverage or debugging issues.  Try with\n \t the location of the end label.  */\n@@ -5398,14 +5416,13 @@ Handled_Sequence_Of_Statements_to_gnu (Node_Id gnat_node)\n            coverage analysis tools.  */\n \tset_expr_location_from_node (gnu_result, gnat_node, true);\n     }\n-  else\n-    gnu_result = gnu_inner_block;\n \n-  /* Now close our outer block, if we had to make one.  */\n-  if (binding_for_block)\n+  /* Process the At_End_Proc, if any.  */\n+  if (at_end)\n     {\n+      start_stmt_group ();\n       add_stmt (gnu_result);\n-      gnat_poplevel ();\n+      At_End_Proc_to_gnu (gnat_node);\n       gnu_result = end_stmt_group ();\n     }\n \n@@ -5493,7 +5510,6 @@ Exception_Handler_to_gnu (Node_Id gnat_node)\n     }\n \n   start_stmt_group ();\n-  gnat_pushlevel ();\n \n   /* Expand a call to the begin_handler hook at the beginning of the\n      handler, and arrange for a call to the end_handler hook to occur\n@@ -5584,7 +5600,7 @@ Exception_Handler_to_gnu (Node_Id gnat_node)\n   else\n     {\n       start_stmt_group ();\n-      gnat_pushlevel ();\n+\n       /* CODE: void *EXPRP = __builtin_eh_handler (0); */\n       tree prop_ptr\n \t= create_var_decl (get_identifier (\"EXPRP\"), NULL_TREE,\n@@ -5604,14 +5620,11 @@ Exception_Handler_to_gnu (Node_Id gnat_node)\n       add_stmt_with_node (ecall, gnat_node);\n \n       /* CODE: } */\n-      gnat_poplevel ();\n       tree eblk = end_stmt_group ();\n       tree ehls = build2 (EH_ELSE_EXPR, void_type_node, call, eblk);\n       add_cleanup (ehls, gnat_node);\n     }\n \n-  gnat_poplevel ();\n-\n   gnu_incoming_exc_ptr = prev_gnu_incoming_exc_ptr;\n \n   return\n@@ -5677,7 +5690,7 @@ Compilation_Unit_to_gnu (Node_Id gnat_node)\n        gnat_pragma = Next (gnat_pragma))\n     if (Nkind (gnat_pragma) == N_Pragma)\n       add_stmt (gnat_to_gnu (gnat_pragma));\n-  process_decls (Declarations (Aux_Decls_Node (gnat_node)), Empty, Empty,\n+  process_decls (Declarations (Aux_Decls_Node (gnat_node)), Empty,\n \t\t true, true);\n \n   /* Process the unit itself.  */\n@@ -6877,6 +6890,11 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t\t\t    : (Rounded_Result (gnat_node)\n \t\t\t\t       ? ROUND_DIV_EXPR : TRUNC_DIV_EXPR),\n \t\t\t\t    gnu_result_type, gnu_lhs, gnu_rhs);\n+      /* If the result type is larger than a word, then declare the dependence\n+\t on the libgcc routine.  */\n+      if (INTEGRAL_TYPE_P (gnu_result_type)\n+\t  && TYPE_PRECISION (gnu_result_type) > BITS_PER_WORD)\n+\tCheck_Restriction_No_Dependence_On_System (Name_Gcc, gnat_node);\n       break;\n \n     case N_Op_Eq:\n@@ -6936,6 +6954,10 @@ gnat_to_gnu (Node_Id gnat_node)\n \t    gnu_rhs = convert (gnu_count_type, gnu_rhs);\n \t    gnu_max_shift\n \t      = convert (TREE_TYPE (gnu_rhs), TYPE_SIZE (gnu_type));\n+\t    /* If the result type is larger than a word, then declare the dependence\n+\t       on the libgcc routine.  */\n+\t    if (TYPE_PRECISION (gnu_result_type) > BITS_PER_WORD)\n+\t      Check_Restriction_No_Dependence_On_System (Name_Gcc, gnat_node);\n \t  }\n \n \t/* If this is a comparison between (potentially) large aggregates, then\n@@ -6948,6 +6970,12 @@ gnat_to_gnu (Node_Id gnat_node)\n \t  Check_Restriction_No_Dependence_On_System (Name_Memory_Compare,\n \t\t\t\t\t\t     gnat_node);\n \n+\t/* If this is a modulo/remainder and the result type is larger than a\n+\t   word, then declare the dependence on the libgcc routine.  */\n+\telse if ((kind == N_Op_Mod ||kind == N_Op_Rem)\n+\t\t && TYPE_PRECISION (gnu_result_type) > BITS_PER_WORD)\n+\t  Check_Restriction_No_Dependence_On_System (Name_Gcc, gnat_node);\n+\n \t/* Pending generic support for efficient vector logical operations in\n \t   GCC, convert vectors to their representative array type view.  */\n \tgnu_lhs = maybe_vector_array (gnu_lhs);\n@@ -7365,8 +7393,10 @@ gnat_to_gnu (Node_Id gnat_node)\n \t{\n \t  start_stmt_group ();\n \t  gnat_pushlevel ();\n-\t  process_decls (Declarations (gnat_node), Empty, Empty, true, true);\n+\t  process_decls (Declarations (gnat_node), Empty, true, true);\n \t  add_stmt (gnat_to_gnu (Handled_Statement_Sequence (gnat_node)));\n+\t  if (Present (At_End_Proc (gnat_node)))\n+\t    At_End_Proc_to_gnu (gnat_node);\n \t  gnat_poplevel ();\n \t  gnu_result = end_stmt_group ();\n \t}\n@@ -7606,15 +7636,14 @@ gnat_to_gnu (Node_Id gnat_node)\n       break;\n \n     case N_Package_Specification:\n-\n       start_stmt_group ();\n       process_decls (Visible_Declarations (gnat_node),\n-\t\t     Private_Declarations (gnat_node), Empty, true, true);\n+\t\t     Private_Declarations (gnat_node),\n+\t\t     true, true);\n       gnu_result = end_stmt_group ();\n       break;\n \n     case N_Package_Body:\n-\n       /* If this is the body of a generic package - do nothing.  */\n       if (Ekind (Corresponding_Spec (gnat_node)) == E_Generic_Package)\n \t{\n@@ -7623,11 +7652,11 @@ gnat_to_gnu (Node_Id gnat_node)\n \t}\n \n       start_stmt_group ();\n-      process_decls (Declarations (gnat_node), Empty, Empty, true, true);\n-\n+      process_decls (Declarations (gnat_node), Empty, true, true);\n       if (Present (Handled_Statement_Sequence (gnat_node)))\n \tadd_stmt (gnat_to_gnu (Handled_Statement_Sequence (gnat_node)));\n-\n+      if (Present (At_End_Proc (gnat_node)))\n+\tAt_End_Proc_to_gnu (gnat_node);\n       gnu_result = end_stmt_group ();\n       break;\n \n@@ -7673,7 +7702,7 @@ gnat_to_gnu (Node_Id gnat_node)\n     case N_Task_Body:\n       /* These nodes should only be present when annotating types.  */\n       gcc_assert (type_annotate_only);\n-      process_decls (Declarations (gnat_node), Empty, Empty, true, true);\n+      process_decls (Declarations (gnat_node), Empty, true, true);\n       gnu_result = alloc_stmt_list ();\n       break;\n \n@@ -7975,7 +8004,7 @@ gnat_to_gnu (Node_Id gnat_node)\n     case N_Freeze_Entity:\n       start_stmt_group ();\n       process_freeze_entity (gnat_node);\n-      process_decls (Actions (gnat_node), Empty, Empty, true, true);\n+      process_decls (Actions (gnat_node), Empty, true, true);\n       gnu_result = end_stmt_group ();\n       break;\n \n@@ -9203,17 +9232,13 @@ process_freeze_entity (Node_Id gnat_node)\n    we declare a function if there was no spec).  The second pass\n    elaborates the bodies.\n \n-   GNAT_END_LIST gives the element in the list past the end.  Normally,\n-   this is Empty, but can be First_Real_Statement for a\n-   Handled_Sequence_Of_Statements.\n-\n    We make a complete pass through both lists if PASS1P is true, then make\n    the second pass over both lists if PASS2P is true.  The lists usually\n    correspond to the public and private parts of a package.  */\n \n static void\n process_decls (List_Id gnat_decls, List_Id gnat_decls2,\n-\t       Node_Id gnat_end_list, bool pass1p, bool pass2p)\n+\t       bool pass1p, bool pass2p)\n {\n   List_Id gnat_decl_array[2];\n   Node_Id gnat_decl;\n@@ -9225,7 +9250,8 @@ process_decls (List_Id gnat_decls, List_Id gnat_decls2,\n     for (i = 0; i <= 1; i++)\n       if (Present (gnat_decl_array[i]))\n \tfor (gnat_decl = First (gnat_decl_array[i]);\n-\t     gnat_decl != gnat_end_list; gnat_decl = Next (gnat_decl))\n+\t     Present (gnat_decl);\n+\t     gnat_decl = Next (gnat_decl))\n \t  {\n \t    /* For package specs, we recurse inside the declarations,\n \t       thus taking the two pass approach inside the boundary.  */\n@@ -9234,14 +9260,14 @@ process_decls (List_Id gnat_decls, List_Id gnat_decls2,\n \t\t\t   == N_Package_Specification)))\n \t      process_decls (Visible_Declarations (Specification (gnat_decl)),\n \t\t\t     Private_Declarations (Specification (gnat_decl)),\n-\t\t\t     Empty, true, false);\n+\t\t\t     true, false);\n \n \t    /* Similarly for any declarations in the actions of a\n \t       freeze node.  */\n \t    else if (Nkind (gnat_decl) == N_Freeze_Entity)\n \t      {\n \t\tprocess_freeze_entity (gnat_decl);\n-\t\tprocess_decls (Actions (gnat_decl), Empty, Empty, true, false);\n+\t\tprocess_decls (Actions (gnat_decl), Empty, true, false);\n \t      }\n \n \t    /* Package bodies with freeze nodes get their elaboration deferred\n@@ -9308,7 +9334,8 @@ process_decls (List_Id gnat_decls, List_Id gnat_decls2,\n     for (i = 0; i <= 1; i++)\n       if (Present (gnat_decl_array[i]))\n \tfor (gnat_decl = First (gnat_decl_array[i]);\n-\t     gnat_decl != gnat_end_list; gnat_decl = Next (gnat_decl))\n+\t     Present (gnat_decl);\n+\t     gnat_decl = Next (gnat_decl))\n \t  {\n \t    if (Nkind (gnat_decl) == N_Subprogram_Body\n \t\t|| Nkind (gnat_decl) == N_Subprogram_Body_Stub\n@@ -9321,10 +9348,10 @@ process_decls (List_Id gnat_decls, List_Id gnat_decls2,\n \t\t\t\t== N_Package_Specification)))\n \t      process_decls (Visible_Declarations (Specification (gnat_decl)),\n \t\t\t     Private_Declarations (Specification (gnat_decl)),\n-\t\t\t     Empty, false, true);\n+\t\t\t     false, true);\n \n \t    else if (Nkind (gnat_decl) == N_Freeze_Entity)\n-\t      process_decls (Actions (gnat_decl), Empty, Empty, false, true);\n+\t      process_decls (Actions (gnat_decl), Empty, false, true);\n \n \t    else if (Nkind (gnat_decl) == N_Subprogram_Renaming_Declaration)\n \t      add_stmt (gnat_to_gnu (gnat_decl));\n@@ -9763,6 +9790,16 @@ convert_with_check (Entity_Id gnat_type, tree gnu_expr, bool overflow_p,\n   else\n     gnu_result = convert (gnu_base_type, gnu_result);\n \n+  /* If this is a conversion between an integer type larger than a word and a\n+     floating-point type, then declare the dependence on the libgcc routine.  */\n+  if ((INTEGRAL_TYPE_P (gnu_in_base_type)\n+       && TYPE_PRECISION (gnu_in_base_type) > BITS_PER_WORD\n+       && FLOAT_TYPE_P (gnu_base_type))\n+      || (FLOAT_TYPE_P (gnu_in_base_type)\n+\t  && INTEGRAL_TYPE_P (gnu_base_type)\n+\t  && TYPE_PRECISION (gnu_base_type) > BITS_PER_WORD))\n+    Check_Restriction_No_Dependence_On_System (Name_Gcc, gnat_node);\n+\n   return convert (gnu_type, gnu_result);\n }\n \n@@ -10389,7 +10426,6 @@ set_end_locus_from_node (tree gnu_node, Node_Id gnat_node)\n \tgnat_end_label = End_Label (Handled_Statement_Sequence (gnat_node));\n       else\n \tgnat_end_label = Empty;\n-\n       break;\n \n     case N_Package_Declaration:\n@@ -10410,7 +10446,7 @@ set_end_locus_from_node (tree gnu_node, Node_Id gnat_node)\n      transient block does not receive the sloc of a source condition.  */\n   if (!Sloc_to_locus (Sloc (gnat_node), &end_locus,\n                       No (gnat_end_label)\n-                      && (Nkind (gnat_node) == N_Block_Statement)))\n+                      && Nkind (gnat_node) == N_Block_Statement))\n     return false;\n \n   switch (TREE_CODE (gnu_node))"}, {"sha": "3d4c1c14fc1b3cd5a88f391088d3f051f30e5c2a", "filename": "gcc/ada/gcc-interface/utils.cc", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fgcc-interface%2Futils.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fgcc-interface%2Futils.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.cc?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -868,6 +868,13 @@ gnat_pushdecl (tree decl, Node_Id gnat_node)\n \t}\n     }\n \n+/* Pointer types aren't named types in the C sense so we need to generate a\n+   typedef in DWARF for them.  Also do that for fat pointer types because,\n+   even though they are named types in the C sense, they are still the XUP\n+   types created for the base array type at this point.  */\n+#define TYPE_IS_POINTER_P(NODE) \\\n+  (TREE_CODE (NODE) == POINTER_TYPE || TYPE_IS_FAT_POINTER_P (NODE))\n+\n   /* For the declaration of a type, set its name either if it isn't already\n      set or if the previous type name was not derived from a source name.\n      We'd rather have the type named with a real name and all the pointer\n@@ -877,18 +884,14 @@ gnat_pushdecl (tree decl, Node_Id gnat_node)\n     {\n       tree t = TREE_TYPE (decl);\n \n-      /* Pointer types aren't named types in the C sense so we need to generate\n-         a typedef in DWARF for them and make sure it is preserved, unless the\n-         type is artificial.  */\n+      /* For pointer types, make sure the typedef is generated and preserved\n+\t in DWARF, unless the type is artificial.  */\n       if (!(TYPE_NAME (t) && TREE_CODE (TYPE_NAME (t)) == TYPE_DECL)\n-\t  && (TREE_CODE (t) != POINTER_TYPE || DECL_ARTIFICIAL (decl)))\n+\t  && (!TYPE_IS_POINTER_P (t) || DECL_ARTIFICIAL (decl)))\n \t;\n       /* For pointer types, create the DECL_ORIGINAL_TYPE that will generate\n-\t the typedef in DWARF.  Also do that for fat pointer types because,\n-\t even though they are named types in the C sense, they are still the\n-\t XUP types created for the base array type at this point.  */\n-      else if (!DECL_ARTIFICIAL (decl)\n-\t       && (TREE_CODE (t) == POINTER_TYPE || TYPE_IS_FAT_POINTER_P (t)))\n+\t the typedef in DWARF.  */\n+      else if (TYPE_IS_POINTER_P (t) && !DECL_ARTIFICIAL (decl))\n \t{\n \t  tree tt = build_variant_type_copy (t);\n \t  TYPE_NAME (tt) = decl;\n@@ -920,9 +923,8 @@ gnat_pushdecl (tree decl, Node_Id gnat_node)\n \t to all parallel types too thanks to gnat_set_type_context.  */\n       if (t)\n \tfor (t = TYPE_MAIN_VARIANT (t); t; t = TYPE_NEXT_VARIANT (t))\n-\t  /* ??? Because of the previous kludge, we can have variants of fat\n-\t     pointer types with different names.  */\n-\t  if (!(TYPE_IS_FAT_POINTER_P (t)\n+\t  /* Skip it for pointer types to preserve the typedef.  */\n+\t  if (!(TYPE_IS_POINTER_P (t)\n \t\t&& TYPE_NAME (t)\n \t\t&& TREE_CODE (TYPE_NAME (t)) == TYPE_DECL))\n \t    {\n@@ -932,6 +934,8 @@ gnat_pushdecl (tree decl, Node_Id gnat_node)\n \t\t\t\t\t deferred_decl_context);\n \t    }\n     }\n+\n+#undef TYPE_IS_POINTER_P\n }\n \n /* Create a record type that contains a SIZE bytes long field of TYPE with a"}, {"sha": "83c71800b5a5af5de2e2a00ce35c3dc51de48af5", "filename": "gcc/ada/gen_il-fields.ads", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fgen_il-fields.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fgen_il-fields.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgen_il-fields.ads?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -96,6 +96,7 @@ package Gen_IL.Fields is\n       Class_Present,\n       Classifications,\n       Cleanup_Actions,\n+      Comes_From_Check_Or_Contract,\n       Comes_From_Extended_Return_Statement,\n       Compile_Time_Known_Aggregate,\n       Component_Associations,\n@@ -183,7 +184,6 @@ package Gen_IL.Fields is\n       First_Inlined_Subprogram,\n       First_Name,\n       First_Named_Actual,\n-      First_Real_Statement,\n       First_Subtype_Link,\n       Float_Truncate,\n       Formal_Type_Definition,\n@@ -930,7 +930,8 @@ package Gen_IL.Fields is\n       Warnings_Off_Used_Unmodified,\n       Warnings_Off_Used_Unreferenced,\n       Was_Hidden,\n-      Wrapped_Entity\n+      Wrapped_Entity,\n+      Wrapped_Statements\n \n       --  End of entity fields.\n      ); -- Opt_Field_Enum"}, {"sha": "2e1e3c99f72f5919c82cfd3fbe9cf2f8a443b936", "filename": "gcc/ada/gen_il-gen-gen_entities.adb", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fgen_il-gen-gen_entities.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fgen_il-gen-gen_entities.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgen_il-gen-gen_entities.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -1046,7 +1046,8 @@ begin -- Gen_IL.Gen.Gen_Entities\n         Sm (Thunk_Entity, Node_Id,\n             Pre => \"Is_Thunk (N)\"),\n         Sm (Wrapped_Entity, Node_Id,\n-            Pre => \"Is_Primitive_Wrapper (N)\")));\n+            Pre => \"Is_Primitive_Wrapper (N)\"),\n+        Sm (Wrapped_Statements, Node_Id)));\n \n    Cc (E_Operator, Subprogram_Kind,\n        --  A predefined operator, appearing in Standard, or an implicitly\n@@ -1095,7 +1096,8 @@ begin -- Gen_IL.Gen.Gen_Entities\n         Sm (Thunk_Entity, Node_Id,\n             Pre => \"Is_Thunk (N)\"),\n         Sm (Wrapped_Entity, Node_Id,\n-            Pre => \"Is_Primitive_Wrapper (N)\")));\n+            Pre => \"Is_Primitive_Wrapper (N)\"),\n+        Sm (Wrapped_Statements, Node_Id)));\n \n    Cc (E_Abstract_State, Overloadable_Kind,\n        --  A state abstraction. Used to designate entities introduced by aspect\n@@ -1134,7 +1136,8 @@ begin -- Gen_IL.Gen.Gen_Entities\n         Sm (Protection_Object, Node_Id),\n         Sm (Scope_Depth_Value, Unat),\n         Sm (SPARK_Pragma, Node_Id),\n-        Sm (SPARK_Pragma_Inherited, Flag)));\n+        Sm (SPARK_Pragma_Inherited, Flag),\n+        Sm (Wrapped_Statements, Node_Id)));\n \n    Cc (E_Entry_Family, Entity_Kind,\n        --  An entry family, created by an entry family declaration in a\n@@ -1161,7 +1164,8 @@ begin -- Gen_IL.Gen.Gen_Entities\n         Sm (Renamed_Or_Alias, Node_Id),\n         Sm (Scope_Depth_Value, Unat),\n         Sm (SPARK_Pragma, Node_Id),\n-        Sm (SPARK_Pragma_Inherited, Flag)));\n+        Sm (SPARK_Pragma_Inherited, Flag),\n+        Sm (Wrapped_Statements, Node_Id)));\n \n    Cc (E_Block, Entity_Kind,\n        --  A block identifier, created by an explicit or implicit label on"}, {"sha": "556326a3e61412ca0557ff33a93751802f9138fe", "filename": "gcc/ada/gen_il-gen-gen_nodes.adb", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fgen_il-gen-gen_nodes.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fgen_il-gen-gen_nodes.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgen_il-gen-gen_nodes.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -804,13 +804,15 @@ begin -- Gen_IL.Gen.Gen_Nodes\n    Cc (N_Package_Body, N_Unit_Body,\n        (Sy (Defining_Unit_Name, Node_Id),\n         Sy (Declarations, List_Id, Default_No_List),\n-        Sy (Handled_Statement_Sequence, Node_Id, Default_Empty)));\n+        Sy (Handled_Statement_Sequence, Node_Id, Default_Empty),\n+        Sy (At_End_Proc, Node_Id, Default_Empty)));\n \n    Cc (N_Subprogram_Body, N_Unit_Body,\n        (Sy (Specification, Node_Id),\n         Sy (Declarations, List_Id, Default_No_List),\n         Sy (Handled_Statement_Sequence, Node_Id, Default_Empty),\n         Sy (Bad_Is_Detected, Flag),\n+        Sy (At_End_Proc, Node_Id, Default_Empty),\n         Sm (Activation_Chain_Entity, Node_Id),\n         Sm (Acts_As_Spec, Flag),\n         Sm (Corresponding_Entry_Body, Node_Id),\n@@ -832,6 +834,7 @@ begin -- Gen_IL.Gen.Gen_Nodes\n        (Sy (Defining_Identifier, Node_Id),\n         Sy (Declarations, List_Id, Default_No_List),\n         Sy (Handled_Statement_Sequence, Node_Id, Default_Empty),\n+        Sy (At_End_Proc, Node_Id, Default_Empty),\n         Sm (Activation_Chain_Entity, Node_Id),\n         Sm (Is_Task_Master, Flag)));\n \n@@ -975,6 +978,7 @@ begin -- Gen_IL.Gen.Gen_Nodes\n         Sy (Has_Created_Identifier, Flag),\n         Sy (Is_Asynchronous_Call_Block, Flag),\n         Sy (Is_Task_Allocation_Block, Flag),\n+        Sy (At_End_Proc, Node_Id, Default_Empty),\n         Sm (Activation_Chain_Entity, Node_Id),\n         Sm (Cleanup_Actions, List_Id),\n         Sm (Exception_Junk, Flag),\n@@ -1094,7 +1098,8 @@ begin -- Gen_IL.Gen.Gen_Nodes\n         Sy (Elsif_Parts, List_Id, Default_No_List),\n         Sy (Else_Statements, List_Id, Default_No_List),\n         Sy (End_Span, Unat, Default_Uint_0),\n-        Sm (From_Conditional_Expression, Flag)));\n+        Sm (From_Conditional_Expression, Flag),\n+        Sm (Comes_From_Check_Or_Contract, Flag)));\n \n    Cc (N_Accept_Alternative, Node_Kind,\n        (Sy (Accept_Statement, Node_Id),\n@@ -1334,6 +1339,7 @@ begin -- Gen_IL.Gen.Gen_Nodes\n         Sy (Entry_Body_Formal_Part, Node_Id),\n         Sy (Declarations, List_Id, Default_No_List),\n         Sy (Handled_Statement_Sequence, Node_Id, Default_Empty),\n+        Sy (At_End_Proc, Node_Id, Default_Empty),\n         Sm (Activation_Chain_Entity, Node_Id)));\n \n    Cc (N_Entry_Call_Alternative, Node_Kind,\n@@ -1421,8 +1427,7 @@ begin -- Gen_IL.Gen.Gen_Nodes\n        (Sy (Statements, List_Id, Default_Empty_List),\n         Sy (End_Label, Node_Id, Default_Empty),\n         Sy (Exception_Handlers, List_Id, Default_No_List),\n-        Sy (At_End_Proc, Node_Id, Default_Empty),\n-        Sm (First_Real_Statement, Node_Id)));\n+        Sy (At_End_Proc, Node_Id, Default_Empty)));\n \n    Cc (N_Index_Or_Discriminant_Constraint, Node_Kind,\n        (Sy (Constraints, List_Id)));"}, {"sha": "0f03285b024174acac0d690e2bc1a97800c9e190", "filename": "gcc/ada/ghost.adb", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fghost.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fghost.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fghost.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -271,11 +271,11 @@ package body Ghost is\n \n                if Present (Subp_Id) then\n \n-                  --  The context is the internally built _Postconditions\n+                  --  The context is the internally built _Wrapped_Statements\n                   --  procedure, which is OK because the real check was done\n-                  --  before expansion activities.\n+                  --  before contract expansion activities.\n \n-                  if Chars (Subp_Id) = Name_uPostconditions then\n+                  if Chars (Subp_Id) = Name_uWrapped_Statements then\n                      return True;\n \n                   --  The context is the internally built predicate function,\n@@ -432,9 +432,7 @@ package body Ghost is\n             --  but it may still contain references to Ghost entities.\n \n             elsif Nkind (Stmt) = N_If_Statement\n-              and then Nkind (Original_Node (Stmt)) = N_Pragma\n-              and then Assertion_Expression_Pragma\n-                         (Get_Pragma_Id (Original_Node (Stmt)))\n+              and then Comes_From_Check_Or_Contract (Stmt)\n             then\n                return True;\n             end if;"}, {"sha": "f3b1c29a24f0c4b949f642a3e94d1876e70b1907", "filename": "gcc/ada/gnat-style.texi", "status": "modified", "additions": 33, "deletions": 35, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fgnat-style.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fgnat-style.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat-style.texi?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -3,7 +3,7 @@\n @setfilename gnat-style.info\n @documentencoding UTF-8\n @ifinfo\n-@*Generated by Sphinx 4.3.1.@*\n+@*Generated by Sphinx 5.1.1.@*\n @end ifinfo\n @settitle GNAT Coding Style A Guide for GNAT Developers\n @defindex ge\n@@ -15,13 +15,11 @@\n * gnat-style: (gnat-style.info). gnat-style\n @end direntry\n \n-@definfoenclose strong,`,'\n-@definfoenclose emph,`,'\n @c %**end of header\n \n @copying\n @quotation\n-GNAT Coding Style: A Guide for GNAT Developers , Jan 03, 2022\n+GNAT Coding Style: A Guide for GNAT Developers , Aug 25, 2022\n \n AdaCore\n \n@@ -255,7 +253,7 @@ When declarations are commented with \u2018hanging\u2019 comments, i.e.\n comments after the declaration, there is no blank line before the\n comment, and if it is absolutely necessary to have blank lines within\n the comments, e.g. to make paragraph separations within a single comment,\n-these blank lines @emph{do} have a @code{--} (unlike the\n+these blank lines `do' have a @code{--} (unlike the\n normal rule, which is to use entirely blank lines for separating\n comment paragraphs).  The comment starts at same level of indentation\n as code it is commenting.\n@@ -304,12 +302,12 @@ Other_Id := 6;           --  Second comment\n @end example\n \n @item \n-Short comments that fit on a single line are @emph{not} ended with a\n+Short comments that fit on a single line are `not' ended with a\n period.  Comments taking more than a line are punctuated in the normal\n manner.\n \n @item \n-Comments should focus on @emph{why} instead of @emph{what}.\n+Comments should focus on `why' instead of `what'.\n Descriptions of what subprograms do go with the specification.\n \n @item \n@@ -319,7 +317,7 @@ depend on the names of things.  The names are supplementary, not\n sufficient, as comments.\n \n @item \n-@emph{Do not} put two spaces after periods in comments.\n+`Do not' put two spaces after periods in comments.\n @end itemize\n \n @node Declarations and Types,Expressions and Names,Lexical Elements,Top\n@@ -958,7 +956,7 @@ Copyright  2000, 2001, 2002, 2007, 2008  Free Software Foundation, Inc\n Everyone is permitted to copy and distribute verbatim copies of this\n license document, but changing it is not allowed.\n \n-@strong{Preamble}\n+`Preamble'\n \n The purpose of this License is to make a manual, textbook, or other\n functional and useful document \u201cfree\u201d in the sense of freedom: to\n@@ -981,23 +979,23 @@ it can be used for any textual work, regardless of subject matter or\n whether it is published as a printed book.  We recommend this License\n principally for works whose purpose is instruction or reference.\n \n-@strong{1. APPLICABILITY AND DEFINITIONS}\n+`1. APPLICABILITY AND DEFINITIONS'\n \n This License applies to any manual or other work, in any medium, that\n contains a notice placed by the copyright holder saying it can be\n distributed under the terms of this License.  Such a notice grants a\n world-wide, royalty-free license, unlimited in duration, to use that\n-work under the conditions stated herein.  The @strong{Document}, below,\n+work under the conditions stated herein.  The `Document', below,\n refers to any such manual or work.  Any member of the public is a\n-licensee, and is addressed as \u201c@strong{you}\u201d.  You accept the license if you\n+licensee, and is addressed as \u201c`you'\u201d.  You accept the license if you\n copy, modify or distribute the work in a way requiring permission\n under copyright law.\n \n-A \u201c@strong{Modified Version}\u201d of the Document means any work containing the\n+A \u201c`Modified Version'\u201d of the Document means any work containing the\n Document or a portion of it, either copied verbatim, or with\n modifications and/or translated into another language.\n \n-A \u201c@strong{Secondary Section}\u201d is a named appendix or a front-matter section of\n+A \u201c`Secondary Section'\u201d is a named appendix or a front-matter section of\n the Document that deals exclusively with the relationship of the\n publishers or authors of the Document to the Document\u2019s overall subject\n (or to related matters) and contains nothing that could fall directly\n@@ -1008,20 +1006,20 @@ connection with the subject or with related matters, or of legal,\n commercial, philosophical, ethical or political position regarding\n them.\n \n-The \u201c@strong{Invariant Sections}\u201d are certain Secondary Sections whose titles\n+The \u201c`Invariant Sections'\u201d are certain Secondary Sections whose titles\n are designated, as being those of Invariant Sections, in the notice\n that says that the Document is released under this License.  If a\n section does not fit the above definition of Secondary then it is not\n allowed to be designated as Invariant.  The Document may contain zero\n Invariant Sections.  If the Document does not identify any Invariant\n Sections then there are none.\n \n-The \u201c@strong{Cover Texts}\u201d are certain short passages of text that are listed,\n+The \u201c`Cover Texts'\u201d are certain short passages of text that are listed,\n as Front-Cover Texts or Back-Cover Texts, in the notice that says that\n the Document is released under this License.  A Front-Cover Text may\n be at most 5 words, and a Back-Cover Text may be at most 25 words.\n \n-A \u201c@strong{Transparent}\u201d copy of the Document means a machine-readable copy,\n+A \u201c`Transparent'\u201d copy of the Document means a machine-readable copy,\n represented in a format whose specification is available to the\n general public, that is suitable for revising the document\n straightforwardly with generic text editors or (for images composed of\n@@ -1032,7 +1030,7 @@ to text formatters.  A copy made in an otherwise Transparent file\n format whose markup, or absence of markup, has been arranged to thwart\n or discourage subsequent modification by readers is not Transparent.\n An image format is not Transparent if used for any substantial amount\n-of text.  A copy that is not \u201cTransparent\u201d is called @strong{Opaque}.\n+of text.  A copy that is not \u201cTransparent\u201d is called `Opaque'.\n \n Examples of suitable formats for Transparent copies include plain\n ASCII without markup, Texinfo input format, LaTeX input format, SGML\n@@ -1045,22 +1043,22 @@ processing tools are not generally available, and the\n machine-generated HTML, PostScript or PDF produced by some word\n processors for output purposes only.\n \n-The \u201c@strong{Title Page}\u201d means, for a printed book, the title page itself,\n+The \u201c`Title Page'\u201d means, for a printed book, the title page itself,\n plus such following pages as are needed to hold, legibly, the material\n this License requires to appear in the title page.  For works in\n formats which do not have any title page as such, \u201cTitle Page\u201d means\n the text near the most prominent appearance of the work\u2019s title,\n preceding the beginning of the body of the text.\n \n-The \u201c@strong{publisher}\u201d means any person or entity that distributes\n+The \u201c`publisher'\u201d means any person or entity that distributes\n copies of the Document to the public.\n \n-A section \u201c@strong{Entitled XYZ}\u201d means a named subunit of the Document whose\n+A section \u201c`Entitled XYZ'\u201d means a named subunit of the Document whose\n title either is precisely XYZ or contains XYZ in parentheses following\n text that translates XYZ in another language.  (Here XYZ stands for a\n-specific section name mentioned below, such as \u201c@strong{Acknowledgements}\u201d,\n-\u201c@strong{Dedications}\u201d, \u201c@strong{Endorsements}\u201d, or \u201c@strong{History}\u201d.)\n-To \u201c@strong{Preserve the Title}\u201d\n+specific section name mentioned below, such as \u201c`Acknowledgements'\u201d,\n+\u201c`Dedications'\u201d, \u201c`Endorsements'\u201d, or \u201c`History'\u201d.)\n+To \u201c`Preserve the Title'\u201d\n of such a section when you modify the Document means that it remains a\n section \u201cEntitled XYZ\u201d according to this definition.\n \n@@ -1071,7 +1069,7 @@ License, but only as regards disclaiming warranties: any other\n implication that these Warranty Disclaimers may have is void and has\n no effect on the meaning of this License.\n \n-@strong{2. VERBATIM COPYING}\n+`2. VERBATIM COPYING'\n \n You may copy and distribute the Document in any medium, either\n commercially or noncommercially, provided that this License, the\n@@ -1086,7 +1084,7 @@ number of copies you must also follow the conditions in section 3.\n You may also lend copies, under the same conditions stated above, and\n you may publicly display copies.\n \n-@strong{3. COPYING IN QUANTITY}\n+`3. COPYING IN QUANTITY'\n \n If you publish printed copies (or copies in media that commonly have\n printed covers) of the Document, numbering more than 100, and the\n@@ -1123,7 +1121,7 @@ It is requested, but not required, that you contact the authors of the\n Document well before redistributing any large number of copies, to give\n them a chance to provide you with an updated version of the Document.\n \n-@strong{4. MODIFICATIONS}\n+`4. MODIFICATIONS'\n \n You may copy and distribute a Modified Version of the Document under\n the conditions of sections 2 and 3 above, provided that you release\n@@ -1240,7 +1238,7 @@ The author(s) and publisher(s) of the Document do not by this License\n give permission to use their names for publicity for or to assert or\n imply endorsement of any Modified Version.\n \n-@strong{5. COMBINING DOCUMENTS}\n+`5. COMBINING DOCUMENTS'\n \n You may combine the Document with other documents released under this\n License, under the terms defined in section 4 above for modified\n@@ -1264,7 +1262,7 @@ in the various original documents, forming one section Entitled\n and any sections Entitled \u201cDedications\u201d.  You must delete all sections\n Entitled \u201cEndorsements\u201d.\n \n-@strong{6. COLLECTIONS OF DOCUMENTS}\n+`6. COLLECTIONS OF DOCUMENTS'\n \n You may make a collection consisting of the Document and other documents\n released under this License, and replace the individual copies of this\n@@ -1277,7 +1275,7 @@ it individually under this License, provided you insert a copy of this\n License into the extracted document, and follow this License in all\n other respects regarding verbatim copying of that document.\n \n-@strong{7. AGGREGATION WITH INDEPENDENT WORKS}\n+`7. AGGREGATION WITH INDEPENDENT WORKS'\n \n A compilation of the Document or its derivatives with other separate\n and independent documents or works, in or on a volume of a storage or\n@@ -1296,7 +1294,7 @@ electronic equivalent of covers if the Document is in electronic form.\n Otherwise they must appear on printed covers that bracket the whole\n aggregate.\n \n-@strong{8. TRANSLATION}\n+`8. TRANSLATION'\n \n Translation is considered a kind of modification, so you may\n distribute translations of the Document under the terms of section 4.\n@@ -1316,7 +1314,7 @@ If a section in the Document is Entitled \u201cAcknowledgements\u201d,\n its Title (section 1) will typically require changing the actual\n title.\n \n-@strong{9. TERMINATION}\n+`9. TERMINATION'\n \n You may not copy, modify, sublicense, or distribute the Document\n except as expressly provided under this License.  Any attempt\n@@ -1343,7 +1341,7 @@ this License.  If your rights have been terminated and not permanently\n reinstated, receipt of a copy of some or all of the same material does\n not give you any rights to use it.\n \n-@strong{10. FUTURE REVISIONS OF THIS LICENSE}\n+`10. FUTURE REVISIONS OF THIS LICENSE'\n \n The Free Software Foundation may publish new, revised versions\n of the GNU Free Documentation License from time to time.  Such new\n@@ -1364,7 +1362,7 @@ License can be used, that proxy\u2019s public statement of acceptance of a\n version permanently authorizes you to choose that version for the\n Document.\n \n-@strong{11. RELICENSING}\n+`11. RELICENSING'\n \n \u201cMassive Multiauthor Collaboration Site\u201d (or \u201cMMC Site\u201d) means any\n World Wide Web server that publishes copyrightable works and also\n@@ -1393,7 +1391,7 @@ The operator of an MMC Site may republish an MMC contained in the site\n under CC-BY-SA on the same site at any time before August 1, 2009,\n provided the MMC is eligible for relicensing.\n \n-@strong{ADDENDUM: How to use this License for your documents}\n+`ADDENDUM: How to use this License for your documents'\n \n To use this License in a document you have written, include a copy of\n the License in the document and put the following copyright and"}, {"sha": "cdf8605f118dbcd44ba856d08683b8ef6b4cd4b2", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 1035, "deletions": 1277, "changes": 2312, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "f2cb1ed638a0a7f03047453fe2e294305355ebea", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 866, "deletions": 815, "changes": 1681, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "6562c121330632f7f84bead70204b405797d98a9", "filename": "gcc/ada/impunit.adb", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fimpunit.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fimpunit.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fimpunit.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -605,19 +605,7 @@ package body Impunit is\n    -- GNAT Defined Additions to Ada 2012 --\n    ----------------------------------------\n \n-    (\"a-cfidll\", F),  -- Ada.Containers.Formal_Indefinite_Doubly_Linked_Lists\n-    (\"a-cfinse\", F),  -- Ada.Containers.Functional_Infinite_Sequences\n-    (\"a-cfinve\", F),  -- Ada.Containers.Formal_Indefinite_Vectors\n     (\"a-coboho\", F),  -- Ada.Containers.Bounded_Holders\n-    (\"a-cofove\", F),  -- Ada.Containers.Formal_Vectors\n-    (\"a-cofuma\", F),  -- Ada.Containers.Functional_Maps\n-    (\"a-cofuse\", F),  -- Ada.Containers.Functional_Sets\n-    (\"a-cofuve\", F),  -- Ada.Containers.Functional_Vectors\n-    (\"a-cfdlli\", F),  -- Ada.Containers.Formal_Doubly_Linked_Lists\n-    (\"a-cforse\", F),  -- Ada.Containers.Formal_Ordered_Sets\n-    (\"a-cforma\", F),  -- Ada.Containers.Formal_Ordered_Maps\n-    (\"a-cfhase\", F),  -- Ada.Containers.Formal_Hashed_Sets\n-    (\"a-cfhama\", F),  -- Ada.Containers.Formal_Hashed_Maps\n     (\"a-cvgpso\", F)   -- Ada.Containers.Vectors.Generic_Parallel_Sorting from\n    );                 -- GNATCOLL.OMP\n "}, {"sha": "e3f35daca09a266cb2ef8ffcea5f2c6a0c038105", "filename": "gcc/ada/inline.adb", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Finline.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Finline.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finline.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -3257,7 +3257,7 @@ package body Inline is\n          pragma Assert\n            (Modify_Tree_For_C\n              and then Is_Subprogram (Enclosing_Subp)\n-             and then Present (Postconditions_Proc (Enclosing_Subp)));\n+             and then Present (Wrapped_Statements (Enclosing_Subp)));\n \n          if Ekind (Enclosing_Subp) = E_Function then\n             if Nkind (First (Parameter_Associations (N))) in\n@@ -3367,6 +3367,8 @@ package body Inline is\n          E   : Entity_Id;\n          Ret : Node_Id;\n \n+         Had_Private_View : Boolean;\n+\n       begin\n          if Is_Entity_Name (N) and then Present (Entity (N)) then\n             E := Entity (N);\n@@ -3380,13 +3382,21 @@ package body Inline is\n                --  subtype is private at the call point but its full view is\n                --  visible to the body, then the inlined tree here must be\n                --  analyzed with the full view).\n+               --\n+               --  The Has_Private_View flag is cleared by rewriting, so it\n+               --  must be explicitly saved and restored, just like when\n+               --  instantiating the body to inline.\n \n                if Is_Entity_Name (A) then\n+                  Had_Private_View := Has_Private_View (N);\n                   Rewrite (N, New_Occurrence_Of (Entity (A), Sloc (N)));\n+                  Set_Has_Private_View (N, Had_Private_View);\n                   Check_Private_View (N);\n \n                elsif Nkind (A) = N_Defining_Identifier then\n+                  Had_Private_View := Has_Private_View (N);\n                   Rewrite (N, New_Occurrence_Of (A, Sloc (N)));\n+                  Set_Has_Private_View (N, Had_Private_View);\n                   Check_Private_View (N);\n \n                --  Numeric literal\n@@ -3841,7 +3851,7 @@ package body Inline is\n \n             if Modify_Tree_For_C\n               and then Nkind (N) = N_Procedure_Call_Statement\n-              and then Chars (Name (N)) = Name_uPostconditions\n+              and then Chars (Name (N)) = Name_uWrapped_Statements\n             then\n                Declare_Postconditions_Result;\n             end if;\n@@ -4536,13 +4546,14 @@ package body Inline is\n       Decl   : Node_Id;\n \n    begin\n-      if No (E_Body) then        --  imported subprogram\n+      if No (E_Body) then -- imported subprogram\n          return False;\n \n       else\n          Decl := First (Declarations (E_Body));\n          while Present (Decl) loop\n             if Nkind (Decl) = N_Full_Type_Declaration\n+              and then Comes_From_Source (Decl)\n               and then Present (Init_Proc (Defining_Identifier (Decl)))\n             then\n                return True;\n@@ -4698,8 +4709,9 @@ package body Inline is\n    procedure Inline_Static_Function_Call (N : Node_Id; Subp : Entity_Id) is\n \n       function Replace_Formal (N : Node_Id) return Traverse_Result;\n-      --  Replace each occurrence of a formal with the corresponding actual,\n-      --  using the mapping created by Establish_Mapping_For_Inlined_Call.\n+      --  Replace each occurrence of a formal with the\n+      --  corresponding actual, using the mapping created\n+      --  by Establish_Actual_Mapping_For_Inlined_Call.\n \n       function Reset_Sloc (Nod : Node_Id) return Traverse_Result;\n       --  Reset the Sloc of a node to that of the call itself, so that errors"}, {"sha": "e4187dd9ce58ca3b50d53806b3fd07740e85a5ad", "filename": "gcc/ada/layout.adb", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flayout.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flayout.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flayout.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -1053,8 +1053,6 @@ package body Layout is\n             --  derived types.\n \n             declare\n-               FST : constant Entity_Id := First_Subtype (E);\n-\n                function Has_Attribute_Clause\n                  (E  : Entity_Id;\n                   Id : Attribute_Id) return Boolean;\n@@ -1072,7 +1070,17 @@ package body Layout is\n                   return Present (Get_Attribute_Definition_Clause (E, Id));\n                end Has_Attribute_Clause;\n \n+               FST : Entity_Id;\n+\n             begin\n+               FST := First_Subtype (E);\n+\n+               --  Deal with private types\n+\n+               if Is_Private_Type (FST) then\n+                  FST := Full_View (FST);\n+               end if;\n+\n                --  If the alignment comes from a clause, then we respect it.\n                --  Consider for example:\n "}, {"sha": "043444c0ea3cb297209d26aa57acb5e9bc6c1f4d", "filename": "gcc/ada/lib-xref.adb", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flib-xref.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flib-xref.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -618,15 +618,6 @@ package body Lib.Xref is\n          end if;\n       end if;\n \n-      --  Do not generate references if we are within a postcondition sub-\n-      --  program, because the reference does not comes from source, and the\n-      --  preanalysis of the aspect has already created an entry for the ALI\n-      --  file at the proper source location.\n-\n-      if Chars (Current_Scope) = Name_uPostconditions then\n-         return;\n-      end if;\n-\n       --  Never collect references if not in main source unit. However, we omit\n       --  this test if Typ is 'e' or 'k', since these entries are structural,\n       --  and it is useful to have them in units that reference packages as"}, {"sha": "691d8e4acb992d20ff126a3a734eadd8d78e9b2d", "filename": "gcc/ada/lib.adb", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -992,6 +992,15 @@ package body Lib is\n       return Is_Predefined_Renaming (Unit);\n    end In_Predefined_Renaming;\n \n+   ---------\n+   -- ipu --\n+   ---------\n+\n+   function ipu (N : Node_Or_Entity_Id) return Boolean is\n+   begin\n+      return In_Predefined_Unit (N);\n+   end ipu;\n+\n    ------------------------\n    -- In_Predefined_Unit --\n    ------------------------"}, {"sha": "c308ac17ed83de482bac6f878f204f674ba75a16", "filename": "gcc/ada/lib.ads", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flib.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flib.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib.ads?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -633,6 +633,12 @@ package Lib is\n    function In_Extended_Main_Source_Unit (Loc : Source_Ptr) return Boolean;\n    --  Same function as above, but argument is a source pointer\n \n+   function ipu (N : Node_Or_Entity_Id) return Boolean;\n+   --  Same as In_Predefined_Unit, but renamed so it can assist debugging.\n+   --  Otherwise, there is a disambiguous name conflict in the two versions of\n+   --  In_Predefined_Unit which makes it inconvient to set as a breakpoint\n+   --  condition.\n+\n    function In_Predefined_Unit (N : Node_Or_Entity_Id) return Boolean;\n    --  Returns True if the given node or entity appears within the source text\n    --  of a predefined unit (i.e. within Ada, Interfaces, System or within one"}, {"sha": "c6866f9a94cea363047557df7d450e3fe039210b", "filename": "gcc/ada/libgnarl/s-tpoben.ads", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnarl%2Fs-tpoben.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnarl%2Fs-tpoben.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fs-tpoben.ads?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -189,14 +189,19 @@ package System.Tasking.Protected_Objects.Entries is\n    --  Lock a protected object for write access. Upon return, the caller owns\n    --  the lock to this object, and no other call to Lock or Lock_Read_Only\n    --  with the same argument will return until the corresponding call to\n-   --  Unlock has been made by the caller. Program_Error is raised in case of\n-   --  ceiling violation.\n+   --  Unlock has been made by the caller. Program_Error is raised in case\n+   --  of ceiling violation, or if the protected object has already been\n+   --  finalized, or if Detect_Blocking is true and the protected object\n+   --  is already locked by the current task. In the Program_Error cases,\n+   --  the object is not locked.\n \n    procedure Lock_Entries_With_Status\n      (Object            : Protection_Entries_Access;\n       Ceiling_Violation : out Boolean);\n    --  Same as above, but return the ceiling violation status instead of\n-   --  raising Program_Error.\n+   --  raising Program_Error. This raises Program_Error in the other\n+   --  cases mentioned for Lock_Entries. In the Program_Error cases,\n+   --  the object is not locked.\n \n    procedure Lock_Read_Only_Entries (Object : Protection_Entries_Access);\n    --  Lock a protected object for read access. Upon return, the caller owns"}, {"sha": "bbb8fd449a7b7df382e5bf036602b64c5ae4b13a", "filename": "gcc/ada/libgnat/a-cfdlli.adb", "status": "removed", "additions": 0, "deletions": 1905, "changes": 1905, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6da3cab7b0acf5dc363c85069bef716923ddf90c/gcc%2Fada%2Flibgnat%2Fa-cfdlli.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6da3cab7b0acf5dc363c85069bef716923ddf90c/gcc%2Fada%2Flibgnat%2Fa-cfdlli.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cfdlli.adb?ref=6da3cab7b0acf5dc363c85069bef716923ddf90c", "patch": "@@ -1,1905 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT LIBRARY COMPONENTS                          --\n---                                                                          --\n---                 ADA.CONTAINERS.FORMAL_DOUBLY_LINKED_LISTS                --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 2010-2022, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n-------------------------------------------------------------------------------\n-\n-with Ada.Containers.Stable_Sorting; use Ada.Containers.Stable_Sorting;\n-\n-with System; use type System.Address;\n-\n-with Ada.Numerics.Big_Numbers.Big_Integers;\n-use Ada.Numerics.Big_Numbers.Big_Integers;\n-\n-package body Ada.Containers.Formal_Doubly_Linked_Lists with\n-  SPARK_Mode => Off\n-is\n-   --  Convert Count_Type to Big_Interger\n-\n-   package Conversions is new Signed_Conversions (Int => Count_Type);\n-   use Conversions;\n-\n-   -----------------------\n-   -- Local Subprograms --\n-   -----------------------\n-\n-   procedure Allocate\n-     (Container : in out List;\n-      New_Item  : Element_Type;\n-      New_Node  : out Count_Type);\n-\n-   procedure Free (Container : in out List; X : Count_Type);\n-\n-   procedure Insert_Internal\n-     (Container : in out List;\n-      Before    : Count_Type;\n-      New_Node  : Count_Type);\n-\n-   function Vet (L : List; Position : Cursor) return Boolean with Inline;\n-\n-   ---------\n-   -- \"=\" --\n-   ---------\n-\n-   function \"=\" (Left : List; Right : List) return Boolean is\n-      LI : Count_Type;\n-      RI : Count_Type;\n-\n-   begin\n-      if Left'Address = Right'Address then\n-         return True;\n-      end if;\n-\n-      if Left.Length /= Right.Length then\n-         return False;\n-      end if;\n-\n-      LI := Left.First;\n-      RI := Right.First;\n-      while LI /= 0 loop\n-         if Left.Nodes (LI).Element /= Right.Nodes (RI).Element then\n-            return False;\n-         end if;\n-\n-         LI := Left.Nodes (LI).Next;\n-         RI := Right.Nodes (RI).Next;\n-      end loop;\n-\n-      return True;\n-   end \"=\";\n-\n-   --------------\n-   -- Allocate --\n-   --------------\n-\n-   procedure Allocate\n-     (Container : in out List;\n-      New_Item  : Element_Type;\n-      New_Node  : out Count_Type)\n-   is\n-      N : Node_Array renames Container.Nodes;\n-\n-   begin\n-      if Container.Free >= 0 then\n-         New_Node := Container.Free;\n-         N (New_Node).Element := New_Item;\n-         Container.Free := N (New_Node).Next;\n-\n-      else\n-         New_Node := abs Container.Free;\n-         N (New_Node).Element := New_Item;\n-         Container.Free := Container.Free - 1;\n-      end if;\n-   end Allocate;\n-\n-   ------------\n-   -- Append --\n-   ------------\n-\n-   procedure Append (Container : in out List; New_Item : Element_Type) is\n-   begin\n-      Insert (Container, No_Element, New_Item, 1);\n-   end Append;\n-\n-   procedure Append\n-     (Container : in out List;\n-      New_Item  : Element_Type;\n-      Count     : Count_Type)\n-   is\n-   begin\n-      Insert (Container, No_Element, New_Item, Count);\n-   end Append;\n-\n-   ------------\n-   -- Assign --\n-   ------------\n-\n-   procedure Assign (Target : in out List; Source : List) is\n-      N : Node_Array renames Source.Nodes;\n-      J : Count_Type;\n-\n-   begin\n-      if Target'Address = Source'Address then\n-         return;\n-      end if;\n-\n-      if Target.Capacity < Source.Length then\n-         raise Constraint_Error with  -- ???\n-           \"Source length exceeds Target capacity\";\n-      end if;\n-\n-      Clear (Target);\n-\n-      J := Source.First;\n-      while J /= 0 loop\n-         Append (Target, N (J).Element, 1);\n-         J := N (J).Next;\n-      end loop;\n-   end Assign;\n-\n-   -----------\n-   -- Clear --\n-   -----------\n-\n-   procedure Clear (Container : in out List) is\n-      N : Node_Array renames Container.Nodes;\n-      X : Count_Type;\n-\n-   begin\n-      if Container.Length = 0 then\n-         pragma Assert (Container.First = 0);\n-         pragma Assert (Container.Last  = 0);\n-         return;\n-      end if;\n-\n-      pragma Assert (Container.First >= 1);\n-      pragma Assert (Container.Last  >= 1);\n-      pragma Assert (N (Container.First).Prev = 0);\n-      pragma Assert (N (Container.Last).Next  = 0);\n-\n-      while Container.Length > 1 loop\n-         X := Container.First;\n-\n-         Container.First := N (X).Next;\n-         N (Container.First).Prev := 0;\n-\n-         Container.Length := Container.Length - 1;\n-\n-         Free (Container, X);\n-      end loop;\n-\n-      X := Container.First;\n-\n-      Container.First := 0;\n-      Container.Last := 0;\n-      Container.Length := 0;\n-\n-      Free (Container, X);\n-   end Clear;\n-\n-   ------------------------\n-   -- Constant_Reference --\n-   ------------------------\n-\n-   function Constant_Reference\n-     (Container : aliased List;\n-      Position  : Cursor) return not null access constant Element_Type\n-   is\n-   begin\n-      if not Has_Element (Container => Container, Position  => Position) then\n-         raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      return Container.Nodes (Position.Node).Element'Access;\n-   end Constant_Reference;\n-\n-   --------------\n-   -- Contains --\n-   --------------\n-\n-   function Contains\n-     (Container : List;\n-      Item      : Element_Type) return Boolean\n-   is\n-   begin\n-      return Find (Container, Item) /= No_Element;\n-   end Contains;\n-\n-   ----------\n-   -- Copy --\n-   ----------\n-\n-   function Copy\n-     (Source   : List;\n-      Capacity : Count_Type := 0) return List\n-   is\n-      C : constant Count_Type := Count_Type'Max (Source.Capacity, Capacity);\n-      N : Count_Type;\n-      P : List (C);\n-\n-   begin\n-      if 0 < Capacity and then Capacity < Source.Capacity then\n-         raise Capacity_Error;\n-      end if;\n-\n-      N := 1;\n-      while N <= Source.Capacity loop\n-         P.Nodes (N).Prev := Source.Nodes (N).Prev;\n-         P.Nodes (N).Next := Source.Nodes (N).Next;\n-         P.Nodes (N).Element := Source.Nodes (N).Element;\n-         N := N + 1;\n-      end loop;\n-\n-      P.Free   := Source.Free;\n-      P.Length := Source.Length;\n-      P.First  := Source.First;\n-      P.Last   := Source.Last;\n-\n-      if P.Free >= 0 then\n-         N := Source.Capacity + 1;\n-         while N <= C loop\n-            Free (P, N);\n-            N := N + 1;\n-         end loop;\n-      end if;\n-\n-      return P;\n-   end Copy;\n-\n-   ------------\n-   -- Delete --\n-   ------------\n-\n-   procedure Delete (Container : in out List; Position : in out Cursor) is\n-   begin\n-      Delete\n-        (Container => Container,\n-         Position  => Position,\n-         Count     => 1);\n-   end Delete;\n-\n-   procedure Delete\n-     (Container : in out List;\n-      Position  : in out Cursor;\n-      Count     : Count_Type)\n-   is\n-      N : Node_Array renames Container.Nodes;\n-      X : Count_Type;\n-\n-   begin\n-      if not Has_Element (Container => Container,\n-                          Position  => Position)\n-      then\n-         raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      pragma Assert (Vet (Container, Position), \"bad cursor in Delete\");\n-      pragma Assert (Container.First >= 1);\n-      pragma Assert (Container.Last  >= 1);\n-      pragma Assert (N (Container.First).Prev = 0);\n-      pragma Assert (N (Container.Last).Next  = 0);\n-\n-      if Position.Node = Container.First then\n-         Delete_First (Container, Count);\n-         Position := No_Element;\n-         return;\n-      end if;\n-\n-      if Count = 0 then\n-         Position := No_Element;\n-         return;\n-      end if;\n-\n-      for Index in 1 .. Count loop\n-         pragma Assert (Container.Length >= 2);\n-\n-         X := Position.Node;\n-         Container.Length := Container.Length - 1;\n-\n-         if X = Container.Last then\n-            Position := No_Element;\n-\n-            Container.Last := N (X).Prev;\n-            N (Container.Last).Next := 0;\n-\n-            Free (Container, X);\n-            return;\n-         end if;\n-\n-         Position.Node := N (X).Next;\n-         pragma Assert (N (Position.Node).Prev >= 0);\n-\n-         N (N (X).Next).Prev := N (X).Prev;\n-         N (N (X).Prev).Next := N (X).Next;\n-\n-         Free (Container, X);\n-      end loop;\n-\n-      Position := No_Element;\n-   end Delete;\n-\n-   ------------------\n-   -- Delete_First --\n-   ------------------\n-\n-   procedure Delete_First (Container : in out List) is\n-   begin\n-      Delete_First\n-        (Container => Container,\n-         Count     => 1);\n-   end Delete_First;\n-\n-   procedure Delete_First (Container : in out List; Count : Count_Type) is\n-      N : Node_Array renames Container.Nodes;\n-      X : Count_Type;\n-\n-   begin\n-      if Count >= Container.Length then\n-         Clear (Container);\n-         return;\n-      end if;\n-\n-      if Count = 0 then\n-         return;\n-      end if;\n-\n-      for J in 1 .. Count loop\n-         X := Container.First;\n-         pragma Assert (N (N (X).Next).Prev = Container.First);\n-\n-         Container.First := N (X).Next;\n-         N (Container.First).Prev := 0;\n-\n-         Container.Length := Container.Length - 1;\n-\n-         Free (Container, X);\n-      end loop;\n-   end Delete_First;\n-\n-   -----------------\n-   -- Delete_Last --\n-   -----------------\n-\n-   procedure Delete_Last (Container : in out List) is\n-   begin\n-      Delete_Last\n-        (Container => Container,\n-         Count     => 1);\n-   end Delete_Last;\n-\n-   procedure Delete_Last (Container : in out List; Count : Count_Type) is\n-      N : Node_Array renames Container.Nodes;\n-      X : Count_Type;\n-\n-   begin\n-      if Count >= Container.Length then\n-         Clear (Container);\n-         return;\n-      end if;\n-\n-      if Count = 0 then\n-         return;\n-      end if;\n-\n-      for J in 1 .. Count loop\n-         X := Container.Last;\n-         pragma Assert (N (N (X).Prev).Next = Container.Last);\n-\n-         Container.Last := N (X).Prev;\n-         N (Container.Last).Next := 0;\n-\n-         Container.Length := Container.Length - 1;\n-\n-         Free (Container, X);\n-      end loop;\n-   end Delete_Last;\n-\n-   -------------\n-   -- Element --\n-   -------------\n-\n-   function Element\n-     (Container : List;\n-      Position  : Cursor) return Element_Type\n-   is\n-   begin\n-      if not Has_Element (Container => Container, Position  => Position) then\n-         raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      return Container.Nodes (Position.Node).Element;\n-   end Element;\n-\n-   ----------\n-   -- Find --\n-   ----------\n-\n-   function Find\n-     (Container : List;\n-      Item      : Element_Type;\n-      Position  : Cursor := No_Element) return Cursor\n-   is\n-      From : Count_Type := Position.Node;\n-\n-   begin\n-      if From = 0 and Container.Length = 0 then\n-         return No_Element;\n-      end if;\n-\n-      if From = 0 then\n-         From := Container.First;\n-      end if;\n-\n-      if Position.Node /= 0 and then not Has_Element (Container, Position) then\n-         raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      while From /= 0 loop\n-         if Container.Nodes (From).Element = Item then\n-            return (Node => From);\n-         end if;\n-\n-         From := Container.Nodes (From).Next;\n-      end loop;\n-\n-      return No_Element;\n-   end Find;\n-\n-   -----------\n-   -- First --\n-   -----------\n-\n-   function First (Container : List) return Cursor is\n-   begin\n-      if Container.First = 0 then\n-         return No_Element;\n-      end if;\n-\n-      return (Node => Container.First);\n-   end First;\n-\n-   -------------------\n-   -- First_Element --\n-   -------------------\n-\n-   function First_Element (Container : List) return Element_Type is\n-      F : constant Count_Type := Container.First;\n-\n-   begin\n-      if F = 0 then\n-         raise Constraint_Error with \"list is empty\";\n-      else\n-         return Container.Nodes (F).Element;\n-      end if;\n-   end First_Element;\n-\n-   ------------------\n-   -- Formal_Model --\n-   ------------------\n-\n-   package body Formal_Model is\n-\n-      ----------------------------\n-      -- Lift_Abstraction_Level --\n-      ----------------------------\n-\n-      procedure Lift_Abstraction_Level (Container : List) is null;\n-\n-      -------------------------\n-      -- M_Elements_In_Union --\n-      -------------------------\n-\n-      function M_Elements_In_Union\n-        (Container : M.Sequence;\n-         Left      : M.Sequence;\n-         Right     : M.Sequence) return Boolean\n-      is\n-         Elem : Element_Type;\n-\n-      begin\n-         for Index in 1 .. M.Length (Container) loop\n-            Elem := Element (Container, Index);\n-\n-            if not M.Contains (Left, 1, M.Length (Left), Elem)\n-               and then not M.Contains (Right, 1, M.Length (Right), Elem)\n-            then\n-               return False;\n-            end if;\n-         end loop;\n-\n-         return True;\n-      end M_Elements_In_Union;\n-\n-      -------------------------\n-      -- M_Elements_Included --\n-      -------------------------\n-\n-      function M_Elements_Included\n-        (Left  : M.Sequence;\n-         L_Fst : Positive_Count_Type := 1;\n-         L_Lst : Count_Type;\n-         Right : M.Sequence;\n-         R_Fst : Positive_Count_Type := 1;\n-         R_Lst : Count_Type) return Boolean\n-      is\n-      begin\n-         for I in L_Fst .. L_Lst loop\n-            declare\n-               Found : Boolean := False;\n-               J     : Count_Type := R_Fst - 1;\n-\n-            begin\n-               while not Found and J < R_Lst loop\n-                  J := J + 1;\n-                  if Element (Left, I) = Element (Right, J) then\n-                     Found := True;\n-                  end if;\n-               end loop;\n-\n-               if not Found then\n-                  return False;\n-               end if;\n-            end;\n-         end loop;\n-\n-         return True;\n-      end M_Elements_Included;\n-\n-      -------------------------\n-      -- M_Elements_Reversed --\n-      -------------------------\n-\n-      function M_Elements_Reversed\n-        (Left  : M.Sequence;\n-         Right : M.Sequence) return Boolean\n-      is\n-         L : constant Count_Type := M.Length (Left);\n-\n-      begin\n-         if L /= M.Length (Right) then\n-            return False;\n-         end if;\n-\n-         for I in 1 .. L loop\n-            if Element (Left, I) /= Element (Right, L - I + 1) then\n-               return False;\n-            end if;\n-         end loop;\n-\n-         return True;\n-      end M_Elements_Reversed;\n-\n-      ------------------------\n-      -- M_Elements_Swapped --\n-      ------------------------\n-\n-      function M_Elements_Swapped\n-        (Left  : M.Sequence;\n-         Right : M.Sequence;\n-         X     : Positive_Count_Type;\n-         Y     : Positive_Count_Type) return Boolean\n-      is\n-      begin\n-         if M.Length (Left) /= M.Length (Right)\n-           or else Element (Left, X) /= Element (Right, Y)\n-           or else Element (Left, Y) /= Element (Right, X)\n-         then\n-            return False;\n-         end if;\n-\n-         for I in 1 .. M.Length (Left) loop\n-            if I /= X and then I /= Y\n-              and then Element (Left, I) /= Element (Right, I)\n-            then\n-               return False;\n-            end if;\n-         end loop;\n-\n-         return True;\n-      end M_Elements_Swapped;\n-\n-      -----------\n-      -- Model --\n-      -----------\n-\n-      function Model (Container : List) return M.Sequence is\n-         Position : Count_Type := Container.First;\n-         R        : M.Sequence;\n-\n-      begin\n-         --  Can't use First, Next or Element here, since they depend on models\n-         --  for their postconditions.\n-\n-         while Position /= 0 loop\n-            R := M.Add (R, Container.Nodes (Position).Element);\n-            Position := Container.Nodes (Position).Next;\n-         end loop;\n-\n-         return R;\n-      end Model;\n-\n-      -----------------------\n-      -- Mapping_Preserved --\n-      -----------------------\n-\n-      function Mapping_Preserved\n-        (M_Left  : M.Sequence;\n-         M_Right : M.Sequence;\n-         P_Left  : P.Map;\n-         P_Right : P.Map) return Boolean\n-      is\n-      begin\n-         for C of P_Left loop\n-            if not P.Has_Key (P_Right, C)\n-              or else P.Get (P_Left,  C) > M.Length (M_Left)\n-              or else P.Get (P_Right, C) > M.Length (M_Right)\n-              or else M.Get (M_Left,  P.Get (P_Left,  C)) /=\n-                      M.Get (M_Right, P.Get (P_Right, C))\n-            then\n-               return False;\n-            end if;\n-         end loop;\n-\n-         for C of P_Right loop\n-            if not P.Has_Key (P_Left, C) then\n-               return False;\n-            end if;\n-         end loop;\n-\n-         return True;\n-      end Mapping_Preserved;\n-\n-      -------------------------\n-      -- P_Positions_Shifted --\n-      -------------------------\n-\n-      function P_Positions_Shifted\n-        (Small : P.Map;\n-         Big   : P.Map;\n-         Cut   : Positive_Count_Type;\n-         Count : Count_Type := 1) return Boolean\n-      is\n-      begin\n-         for Cu of Small loop\n-            if not P.Has_Key (Big, Cu) then\n-               return False;\n-            end if;\n-         end loop;\n-\n-         for Cu of Big loop\n-            declare\n-               Pos : constant Positive_Count_Type := P.Get (Big, Cu);\n-\n-            begin\n-               if Pos < Cut then\n-                  if not P.Has_Key (Small, Cu)\n-                    or else Pos /= P.Get (Small, Cu)\n-                  then\n-                     return False;\n-                  end if;\n-\n-               elsif Pos >= Cut + Count then\n-                  if not P.Has_Key (Small, Cu)\n-                    or else Pos /= P.Get (Small, Cu) + Count\n-                  then\n-                     return False;\n-                  end if;\n-\n-               else\n-                  if P.Has_Key (Small, Cu) then\n-                     return False;\n-                  end if;\n-               end if;\n-            end;\n-         end loop;\n-\n-         return True;\n-      end P_Positions_Shifted;\n-\n-      -------------------------\n-      -- P_Positions_Swapped --\n-      -------------------------\n-\n-      function P_Positions_Swapped\n-        (Left  : P.Map;\n-         Right : P.Map;\n-         X     : Cursor;\n-         Y     : Cursor) return Boolean\n-      is\n-      begin\n-         if not P.Has_Key (Left, X)\n-           or not P.Has_Key (Left, Y)\n-           or not P.Has_Key (Right, X)\n-           or not P.Has_Key (Right, Y)\n-         then\n-            return False;\n-         end if;\n-\n-         if P.Get (Left, X) /= P.Get (Right, Y)\n-           or P.Get (Left, Y) /= P.Get (Right, X)\n-         then\n-            return False;\n-         end if;\n-\n-         for C of Left loop\n-            if not P.Has_Key (Right, C) then\n-               return False;\n-            end if;\n-         end loop;\n-\n-         for C of Right loop\n-            if not P.Has_Key (Left, C)\n-              or else (C /= X\n-                        and C /= Y\n-                        and P.Get (Left, C) /= P.Get (Right, C))\n-            then\n-               return False;\n-            end if;\n-         end loop;\n-\n-         return True;\n-      end P_Positions_Swapped;\n-\n-      ---------------------------\n-      -- P_Positions_Truncated --\n-      ---------------------------\n-\n-      function P_Positions_Truncated\n-        (Small : P.Map;\n-         Big   : P.Map;\n-         Cut   : Positive_Count_Type;\n-         Count : Count_Type := 1) return Boolean\n-      is\n-      begin\n-         for Cu of Small loop\n-            if not P.Has_Key (Big, Cu) then\n-               return False;\n-            end if;\n-         end loop;\n-\n-         for Cu of Big loop\n-            declare\n-               Pos : constant Positive_Count_Type := P.Get (Big, Cu);\n-\n-            begin\n-               if Pos < Cut then\n-                  if not P.Has_Key (Small, Cu)\n-                    or else Pos /= P.Get (Small, Cu)\n-                  then\n-                     return False;\n-                  end if;\n-\n-               elsif Pos >= Cut + Count then\n-                  return False;\n-\n-               elsif P.Has_Key (Small, Cu) then\n-                  return False;\n-               end if;\n-            end;\n-         end loop;\n-\n-         return True;\n-      end P_Positions_Truncated;\n-\n-      ---------------\n-      -- Positions --\n-      ---------------\n-\n-      function Positions (Container : List) return P.Map is\n-         I        : Count_Type := 1;\n-         Position : Count_Type := Container.First;\n-         R        : P.Map;\n-\n-      begin\n-         --  Can't use First, Next or Element here, since they depend on models\n-         --  for their postconditions.\n-\n-         while Position /= 0 loop\n-            R := P.Add (R, (Node => Position), I);\n-            pragma Assert (P.Length (R) = To_Big_Integer (I));\n-            Position := Container.Nodes (Position).Next;\n-            I := I + 1;\n-         end loop;\n-\n-         return R;\n-      end Positions;\n-\n-   end Formal_Model;\n-\n-   ----------\n-   -- Free --\n-   ----------\n-\n-   procedure Free (Container : in out List; X : Count_Type) is\n-      pragma Assert (X > 0);\n-      pragma Assert (X <= Container.Capacity);\n-\n-      N : Node_Array renames Container.Nodes;\n-\n-   begin\n-      N (X).Prev := -1;  -- Node is deallocated (not on active list)\n-\n-      if Container.Free >= 0 then\n-         N (X).Next := Container.Free;\n-         Container.Free := X;\n-\n-      elsif X + 1 = abs Container.Free then\n-         N (X).Next := 0;  -- Not strictly necessary, but marginally safer\n-         Container.Free := Container.Free + 1;\n-\n-      else\n-         Container.Free := abs Container.Free;\n-\n-         if Container.Free > Container.Capacity then\n-            Container.Free := 0;\n-\n-         else\n-            for J in Container.Free .. Container.Capacity - 1 loop\n-               N (J).Next := J + 1;\n-            end loop;\n-\n-            N (Container.Capacity).Next := 0;\n-         end if;\n-\n-         N (X).Next := Container.Free;\n-         Container.Free := X;\n-      end if;\n-   end Free;\n-\n-   ---------------------\n-   -- Generic_Sorting --\n-   ---------------------\n-\n-   package body Generic_Sorting with SPARK_Mode => Off is\n-\n-      ------------------\n-      -- Formal_Model --\n-      ------------------\n-\n-      package body Formal_Model is\n-\n-         -----------------------\n-         -- M_Elements_Sorted --\n-         -----------------------\n-\n-         function M_Elements_Sorted (Container : M.Sequence) return Boolean is\n-         begin\n-            if M.Length (Container) = 0 then\n-               return True;\n-            end if;\n-\n-            declare\n-               E1 : Element_Type := Element (Container, 1);\n-\n-            begin\n-               for I in 2 .. M.Length (Container) loop\n-                  declare\n-                     E2 : constant Element_Type := Element (Container, I);\n-\n-                  begin\n-                     if E2 < E1 then\n-                        return False;\n-                     end if;\n-\n-                     E1 := E2;\n-                  end;\n-               end loop;\n-            end;\n-\n-            return True;\n-         end M_Elements_Sorted;\n-\n-      end Formal_Model;\n-\n-      ---------------\n-      -- Is_Sorted --\n-      ---------------\n-\n-      function Is_Sorted (Container : List) return Boolean is\n-         Nodes : Node_Array renames Container.Nodes;\n-         Node  : Count_Type := Container.First;\n-\n-      begin\n-         for J in 2 .. Container.Length loop\n-            if Nodes (Nodes (Node).Next).Element < Nodes (Node).Element then\n-               return False;\n-            else\n-               Node := Nodes (Node).Next;\n-            end if;\n-         end loop;\n-\n-         return True;\n-      end Is_Sorted;\n-\n-      -----------\n-      -- Merge --\n-      -----------\n-\n-      procedure Merge (Target : in out List; Source : in out List) is\n-         LN : Node_Array renames Target.Nodes;\n-         RN : Node_Array renames Source.Nodes;\n-         LI : Cursor;\n-         RI : Cursor;\n-\n-      begin\n-         if Target'Address = Source'Address then\n-            raise Program_Error with \"Target and Source denote same container\";\n-         end if;\n-\n-         LI := First (Target);\n-         RI := First (Source);\n-         while RI.Node /= 0 loop\n-            pragma Assert\n-              (RN (RI.Node).Next = 0\n-                or else not (RN (RN (RI.Node).Next).Element <\n-                             RN (RI.Node).Element));\n-\n-            if LI.Node = 0 then\n-               Splice (Target, No_Element, Source);\n-               return;\n-            end if;\n-\n-            pragma Assert\n-              (LN (LI.Node).Next = 0\n-                or else not (LN (LN (LI.Node).Next).Element <\n-                             LN (LI.Node).Element));\n-\n-            if RN (RI.Node).Element < LN (LI.Node).Element then\n-               declare\n-                  RJ : Cursor := RI;\n-                  pragma Warnings (Off, RJ);\n-               begin\n-                  RI.Node := RN (RI.Node).Next;\n-                  Splice (Target, LI, Source, RJ);\n-               end;\n-\n-            else\n-               LI.Node := LN (LI.Node).Next;\n-            end if;\n-         end loop;\n-      end Merge;\n-\n-      ----------\n-      -- Sort --\n-      ----------\n-\n-      procedure Sort (Container : in out List) is\n-         N : Node_Array renames Container.Nodes;\n-      begin\n-         if Container.Length <= 1 then\n-            return;\n-         end if;\n-\n-         pragma Assert (N (Container.First).Prev = 0);\n-         pragma Assert (N (Container.Last).Next = 0);\n-\n-         declare\n-            package Descriptors is new List_Descriptors\n-              (Node_Ref => Count_Type, Nil => 0);\n-            use Descriptors;\n-\n-            function Next (Idx : Count_Type) return Count_Type is\n-              (N (Idx).Next);\n-            procedure Set_Next (Idx : Count_Type; Next : Count_Type)\n-              with Inline;\n-            procedure Set_Prev (Idx : Count_Type; Prev : Count_Type)\n-              with Inline;\n-            function \"<\" (L, R : Count_Type) return Boolean is\n-              (N (L).Element < N (R).Element);\n-            procedure Update_Container (List : List_Descriptor) with Inline;\n-\n-            procedure Set_Next (Idx : Count_Type; Next : Count_Type) is\n-            begin\n-               N (Idx).Next := Next;\n-            end Set_Next;\n-\n-            procedure Set_Prev (Idx : Count_Type; Prev : Count_Type) is\n-            begin\n-               N (Idx).Prev := Prev;\n-            end Set_Prev;\n-\n-            procedure Update_Container (List : List_Descriptor) is\n-            begin\n-               Container.First  := List.First;\n-               Container.Last   := List.Last;\n-               Container.Length := List.Length;\n-            end Update_Container;\n-\n-            procedure Sort_List is new Doubly_Linked_List_Sort;\n-         begin\n-            Sort_List (List_Descriptor'(First  => Container.First,\n-                                        Last   => Container.Last,\n-                                        Length => Container.Length));\n-         end;\n-\n-         pragma Assert (N (Container.First).Prev = 0);\n-         pragma Assert (N (Container.Last).Next = 0);\n-      end Sort;\n-\n-   end Generic_Sorting;\n-\n-   -----------------\n-   -- Has_Element --\n-   -----------------\n-\n-   function Has_Element (Container : List; Position : Cursor) return Boolean is\n-   begin\n-      if Position.Node = 0 then\n-         return False;\n-      end if;\n-\n-      return Container.Nodes (Position.Node).Prev /= -1;\n-   end Has_Element;\n-\n-   ------------\n-   -- Insert --\n-   ------------\n-\n-   procedure Insert\n-     (Container : in out List;\n-      Before    : Cursor;\n-      New_Item  : Element_Type;\n-      Position  : out Cursor;\n-      Count     : Count_Type)\n-   is\n-      J : Count_Type;\n-\n-   begin\n-      if Before.Node /= 0 then\n-         pragma Assert (Vet (Container, Before), \"bad cursor in Insert\");\n-      end if;\n-\n-      if Count = 0 then\n-         Position := Before;\n-         return;\n-      end if;\n-\n-      if Container.Length > Container.Capacity - Count then\n-         raise Constraint_Error with \"new length exceeds capacity\";\n-      end if;\n-\n-      Allocate (Container, New_Item, New_Node => J);\n-      Insert_Internal (Container, Before.Node, New_Node => J);\n-      Position := (Node => J);\n-\n-      for Index in 2 .. Count loop\n-         Allocate (Container, New_Item, New_Node => J);\n-         Insert_Internal (Container, Before.Node, New_Node => J);\n-      end loop;\n-   end Insert;\n-\n-   procedure Insert\n-     (Container : in out List;\n-      Before    : Cursor;\n-      New_Item  : Element_Type;\n-      Position  : out Cursor)\n-   is\n-   begin\n-      Insert\n-        (Container => Container,\n-         Before    => Before,\n-         New_Item  => New_Item,\n-         Position  => Position,\n-         Count     => 1);\n-   end Insert;\n-\n-   procedure Insert\n-     (Container : in out List;\n-      Before    : Cursor;\n-      New_Item  : Element_Type;\n-      Count     : Count_Type)\n-   is\n-      Position : Cursor;\n-\n-   begin\n-      Insert (Container, Before, New_Item, Position, Count);\n-   end Insert;\n-\n-   procedure Insert\n-     (Container : in out List;\n-      Before    : Cursor;\n-      New_Item  : Element_Type)\n-   is\n-      Position : Cursor;\n-\n-   begin\n-      Insert (Container, Before, New_Item, Position, 1);\n-   end Insert;\n-\n-   ---------------------\n-   -- Insert_Internal --\n-   ---------------------\n-\n-   procedure Insert_Internal\n-     (Container : in out List;\n-      Before    : Count_Type;\n-      New_Node  : Count_Type)\n-   is\n-      N : Node_Array renames Container.Nodes;\n-\n-   begin\n-      if Container.Length = 0 then\n-         pragma Assert (Before = 0);\n-         pragma Assert (Container.First = 0);\n-         pragma Assert (Container.Last = 0);\n-\n-         Container.First := New_Node;\n-         Container.Last := New_Node;\n-\n-         N (Container.First).Prev := 0;\n-         N (Container.Last).Next := 0;\n-\n-      elsif Before = 0 then\n-         pragma Assert (N (Container.Last).Next = 0);\n-\n-         N (Container.Last).Next := New_Node;\n-         N (New_Node).Prev := Container.Last;\n-\n-         Container.Last := New_Node;\n-         N (Container.Last).Next := 0;\n-\n-      elsif Before = Container.First then\n-         pragma Assert (N (Container.First).Prev = 0);\n-\n-         N (Container.First).Prev := New_Node;\n-         N (New_Node).Next := Container.First;\n-\n-         Container.First := New_Node;\n-         N (Container.First).Prev := 0;\n-\n-      else\n-         pragma Assert (N (Container.First).Prev = 0);\n-         pragma Assert (N (Container.Last).Next = 0);\n-\n-         N (New_Node).Next := Before;\n-         N (New_Node).Prev := N (Before).Prev;\n-\n-         N (N (Before).Prev).Next := New_Node;\n-         N (Before).Prev := New_Node;\n-      end if;\n-\n-      Container.Length := Container.Length + 1;\n-   end Insert_Internal;\n-\n-   --------------\n-   -- Is_Empty --\n-   --------------\n-\n-   function Is_Empty (Container : List) return Boolean is\n-   begin\n-      return Length (Container) = 0;\n-   end Is_Empty;\n-\n-   ----------\n-   -- Last --\n-   ----------\n-\n-   function Last (Container : List) return Cursor is\n-   begin\n-      if Container.Last = 0 then\n-         return No_Element;\n-      end if;\n-\n-      return (Node => Container.Last);\n-   end Last;\n-\n-   ------------------\n-   -- Last_Element --\n-   ------------------\n-\n-   function Last_Element (Container : List) return Element_Type is\n-      L : constant Count_Type := Container.Last;\n-\n-   begin\n-      if L = 0 then\n-         raise Constraint_Error with \"list is empty\";\n-      else\n-         return Container.Nodes (L).Element;\n-      end if;\n-   end Last_Element;\n-\n-   ------------\n-   -- Length --\n-   ------------\n-\n-   function Length (Container : List) return Count_Type is\n-   begin\n-      return Container.Length;\n-   end Length;\n-\n-   ----------\n-   -- Move --\n-   ----------\n-\n-   procedure Move (Target : in out List; Source : in out List) is\n-      N : Node_Array renames Source.Nodes;\n-      X : Count_Type;\n-\n-   begin\n-      if Target'Address = Source'Address then\n-         return;\n-      end if;\n-\n-      if Target.Capacity < Source.Length then\n-         raise Constraint_Error with  -- ???\n-           \"Source length exceeds Target capacity\";\n-      end if;\n-\n-      Clear (Target);\n-\n-      while Source.Length > 1 loop\n-         pragma Assert (Source.First in 1 .. Source.Capacity);\n-         pragma Assert (Source.Last /= Source.First);\n-         pragma Assert (N (Source.First).Prev = 0);\n-         pragma Assert (N (Source.Last).Next = 0);\n-\n-         --  Copy first element from Source to Target\n-\n-         X := Source.First;\n-         Append (Target, N (X).Element);  -- optimize away???\n-\n-         --  Unlink first node of Source\n-\n-         Source.First := N (X).Next;\n-         N (Source.First).Prev := 0;\n-\n-         Source.Length := Source.Length - 1;\n-\n-         --  The representation invariants for Source have been restored. It is\n-         --  now safe to free the unlinked node, without fear of corrupting the\n-         --  active links of Source.\n-\n-         --  Note that the algorithm we use here models similar algorithms used\n-         --  in the unbounded form of the doubly-linked list container. In that\n-         --  case, Free is an instantation of Unchecked_Deallocation, which can\n-         --  fail (because PE will be raised if controlled Finalize fails), so\n-         --  we must defer the call until the last step. Here in the bounded\n-         --  form, Free merely links the node we have just \"deallocated\" onto a\n-         --  list of inactive nodes, so technically Free cannot fail. However,\n-         --  for consistency, we handle Free the same way here as we do for the\n-         --  unbounded form, with the pessimistic assumption that it can fail.\n-\n-         Free (Source, X);\n-      end loop;\n-\n-      if Source.Length = 1 then\n-         pragma Assert (Source.First in 1 .. Source.Capacity);\n-         pragma Assert (Source.Last = Source.First);\n-         pragma Assert (N (Source.First).Prev = 0);\n-         pragma Assert (N (Source.Last).Next = 0);\n-\n-         --  Copy element from Source to Target\n-\n-         X := Source.First;\n-         Append (Target, N (X).Element);\n-\n-         --  Unlink node of Source\n-\n-         Source.First := 0;\n-         Source.Last := 0;\n-         Source.Length := 0;\n-\n-         --  Return the unlinked node to the free store\n-\n-         Free (Source, X);\n-      end if;\n-   end Move;\n-\n-   ----------\n-   -- Next --\n-   ----------\n-\n-   procedure Next (Container : List; Position : in out Cursor) is\n-   begin\n-      Position := Next (Container, Position);\n-   end Next;\n-\n-   function Next (Container : List; Position : Cursor) return Cursor is\n-   begin\n-      if Position.Node = 0 then\n-         return No_Element;\n-      end if;\n-\n-      if not Has_Element (Container, Position) then\n-         raise Program_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      return (Node => Container.Nodes (Position.Node).Next);\n-   end Next;\n-\n-   -------------\n-   -- Prepend --\n-   -------------\n-\n-   procedure Prepend (Container : in out List; New_Item : Element_Type) is\n-   begin\n-      Insert (Container, First (Container), New_Item, 1);\n-   end Prepend;\n-\n-   procedure Prepend\n-     (Container : in out List;\n-      New_Item  : Element_Type;\n-      Count     : Count_Type)\n-   is\n-   begin\n-      Insert (Container, First (Container), New_Item, Count);\n-   end Prepend;\n-\n-   --------------\n-   -- Previous --\n-   --------------\n-\n-   procedure Previous (Container : List; Position : in out Cursor) is\n-   begin\n-      Position := Previous (Container, Position);\n-   end Previous;\n-\n-   function Previous (Container : List; Position : Cursor) return Cursor is\n-   begin\n-      if Position.Node = 0 then\n-         return No_Element;\n-      end if;\n-\n-      if not Has_Element (Container, Position) then\n-         raise Program_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      return (Node => Container.Nodes (Position.Node).Prev);\n-   end Previous;\n-\n-   ---------------\n-   -- Reference --\n-   ---------------\n-\n-   function Reference\n-     (Container : not null access List;\n-      Position  : Cursor) return not null access Element_Type\n-   is\n-   begin\n-      if not Has_Element (Container.all, Position) then\n-         raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      return Container.Nodes (Position.Node).Element'Access;\n-   end Reference;\n-\n-   ---------------------\n-   -- Replace_Element --\n-   ---------------------\n-\n-   procedure Replace_Element\n-     (Container : in out List;\n-      Position  : Cursor;\n-      New_Item  : Element_Type)\n-   is\n-   begin\n-      if not Has_Element (Container, Position) then\n-         raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      pragma Assert\n-        (Vet (Container, Position), \"bad cursor in Replace_Element\");\n-\n-      Container.Nodes (Position.Node).Element := New_Item;\n-   end Replace_Element;\n-\n-   ----------------------\n-   -- Reverse_Elements --\n-   ----------------------\n-\n-   procedure Reverse_Elements (Container : in out List) is\n-      N : Node_Array renames Container.Nodes;\n-      I : Count_Type := Container.First;\n-      J : Count_Type := Container.Last;\n-\n-      procedure Swap (L : Count_Type; R : Count_Type);\n-\n-      ----------\n-      -- Swap --\n-      ----------\n-\n-      procedure Swap (L : Count_Type; R : Count_Type) is\n-         LN : constant Count_Type := N (L).Next;\n-         LP : constant Count_Type := N (L).Prev;\n-\n-         RN : constant Count_Type := N (R).Next;\n-         RP : constant Count_Type := N (R).Prev;\n-\n-      begin\n-         if LP /= 0 then\n-            N (LP).Next := R;\n-         end if;\n-\n-         if RN /= 0 then\n-            N (RN).Prev := L;\n-         end if;\n-\n-         N (L).Next := RN;\n-         N (R).Prev := LP;\n-\n-         if LN = R then\n-            pragma Assert (RP = L);\n-\n-            N (L).Prev := R;\n-            N (R).Next := L;\n-\n-         else\n-            N (L).Prev := RP;\n-            N (RP).Next := L;\n-\n-            N (R).Next := LN;\n-            N (LN).Prev := R;\n-         end if;\n-      end Swap;\n-\n-   --  Start of processing for Reverse_Elements\n-\n-   begin\n-      if Container.Length <= 1 then\n-         return;\n-      end if;\n-\n-      pragma Assert (N (Container.First).Prev = 0);\n-      pragma Assert (N (Container.Last).Next = 0);\n-\n-      Container.First := J;\n-      Container.Last  := I;\n-      loop\n-         Swap (L => I, R => J);\n-\n-         J := N (J).Next;\n-         exit when I = J;\n-\n-         I := N (I).Prev;\n-         exit when I = J;\n-\n-         Swap (L => J, R => I);\n-\n-         I := N (I).Next;\n-         exit when I = J;\n-\n-         J := N (J).Prev;\n-         exit when I = J;\n-      end loop;\n-\n-      pragma Assert (N (Container.First).Prev = 0);\n-      pragma Assert (N (Container.Last).Next = 0);\n-   end Reverse_Elements;\n-\n-   ------------------\n-   -- Reverse_Find --\n-   ------------------\n-\n-   function Reverse_Find\n-     (Container : List;\n-      Item      : Element_Type;\n-      Position  : Cursor := No_Element) return Cursor\n-   is\n-      CFirst : Count_Type := Position.Node;\n-\n-   begin\n-      if CFirst = 0 then\n-         CFirst := Container.Last;\n-      end if;\n-\n-      if Container.Length = 0 then\n-         return No_Element;\n-\n-      else\n-         while CFirst /= 0 loop\n-            if Container.Nodes (CFirst).Element = Item then\n-               return (Node => CFirst);\n-            else\n-               CFirst := Container.Nodes (CFirst).Prev;\n-            end if;\n-         end loop;\n-\n-         return No_Element;\n-      end if;\n-   end Reverse_Find;\n-\n-   ------------\n-   -- Splice --\n-   ------------\n-\n-   procedure Splice\n-     (Target : in out List;\n-      Before : Cursor;\n-      Source : in out List)\n-   is\n-      SN : Node_Array renames Source.Nodes;\n-\n-   begin\n-      if Target'Address = Source'Address then\n-         raise Program_Error with \"Target and Source denote same container\";\n-      end if;\n-\n-      if Before.Node /= 0 then\n-         pragma Assert (Vet (Target, Before), \"bad cursor in Splice\");\n-      end if;\n-\n-      pragma Assert (SN (Source.First).Prev = 0);\n-      pragma Assert (SN (Source.Last).Next  = 0);\n-\n-      if Target.Length > Count_Type'Base'Last - Source.Length then\n-         raise Constraint_Error with \"new length exceeds maximum\";\n-      end if;\n-\n-      if Target.Length + Source.Length > Target.Capacity then\n-         raise Constraint_Error;\n-      end if;\n-\n-      loop\n-         Insert (Target, Before, SN (Source.Last).Element);\n-         Delete_Last (Source);\n-         exit when Is_Empty (Source);\n-      end loop;\n-   end Splice;\n-\n-   procedure Splice\n-     (Target   : in out List;\n-      Before   : Cursor;\n-      Source   : in out List;\n-      Position : in out Cursor)\n-   is\n-      Target_Position : Cursor;\n-\n-   begin\n-      if Target'Address = Source'Address then\n-         raise Program_Error with \"Target and Source denote same container\";\n-      end if;\n-\n-      if Position.Node = 0 then\n-         raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      pragma Assert (Vet (Source, Position), \"bad Position cursor in Splice\");\n-\n-      if Target.Length >= Target.Capacity then\n-         raise Constraint_Error;\n-      end if;\n-\n-      Insert\n-        (Container => Target,\n-         Before    => Before,\n-         New_Item  => Source.Nodes (Position.Node).Element,\n-         Position  => Target_Position);\n-\n-      Delete (Source, Position);\n-      Position := Target_Position;\n-   end Splice;\n-\n-   procedure Splice\n-     (Container : in out List;\n-      Before    : Cursor;\n-      Position  : Cursor)\n-   is\n-      N : Node_Array renames Container.Nodes;\n-\n-   begin\n-      if Before.Node /= 0 then\n-         pragma Assert\n-           (Vet (Container, Before), \"bad Before cursor in Splice\");\n-      end if;\n-\n-      if Position.Node = 0 then\n-         raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      pragma Assert\n-        (Vet (Container, Position), \"bad Position cursor in Splice\");\n-\n-      if Position.Node = Before.Node\n-        or else N (Position.Node).Next = Before.Node\n-      then\n-         return;\n-      end if;\n-\n-      pragma Assert (Container.Length >= 2);\n-\n-      if Before.Node = 0 then\n-         pragma Assert (Position.Node /= Container.Last);\n-\n-         if Position.Node = Container.First then\n-            Container.First := N (Position.Node).Next;\n-            N (Container.First).Prev := 0;\n-\n-         else\n-            N (N (Position.Node).Prev).Next := N (Position.Node).Next;\n-            N (N (Position.Node).Next).Prev := N (Position.Node).Prev;\n-         end if;\n-\n-         N (Container.Last).Next := Position.Node;\n-         N (Position.Node).Prev := Container.Last;\n-\n-         Container.Last := Position.Node;\n-         N (Container.Last).Next := 0;\n-\n-         return;\n-      end if;\n-\n-      if Before.Node = Container.First then\n-         pragma Assert (Position.Node /= Container.First);\n-\n-         if Position.Node = Container.Last then\n-            Container.Last := N (Position.Node).Prev;\n-            N (Container.Last).Next := 0;\n-\n-         else\n-            N (N (Position.Node).Prev).Next := N (Position.Node).Next;\n-            N (N (Position.Node).Next).Prev := N (Position.Node).Prev;\n-         end if;\n-\n-         N (Container.First).Prev := Position.Node;\n-         N (Position.Node).Next := Container.First;\n-\n-         Container.First := Position.Node;\n-         N (Container.First).Prev := 0;\n-\n-         return;\n-      end if;\n-\n-      if Position.Node = Container.First then\n-         Container.First := N (Position.Node).Next;\n-         N (Container.First).Prev := 0;\n-\n-      elsif Position.Node = Container.Last then\n-         Container.Last := N (Position.Node).Prev;\n-         N (Container.Last).Next := 0;\n-\n-      else\n-         N (N (Position.Node).Prev).Next := N (Position.Node).Next;\n-         N (N (Position.Node).Next).Prev := N (Position.Node).Prev;\n-      end if;\n-\n-      N (N (Before.Node).Prev).Next := Position.Node;\n-      N (Position.Node).Prev := N (Before.Node).Prev;\n-\n-      N (Before.Node).Prev := Position.Node;\n-      N (Position.Node).Next := Before.Node;\n-\n-      pragma Assert (N (Container.First).Prev = 0);\n-      pragma Assert (N (Container.Last).Next = 0);\n-   end Splice;\n-\n-   ----------\n-   -- Swap --\n-   ----------\n-\n-   procedure Swap\n-     (Container : in out List;\n-      I         : Cursor;\n-      J         : Cursor)\n-   is\n-   begin\n-      if I.Node = 0 then\n-         raise Constraint_Error with \"I cursor has no element\";\n-      end if;\n-\n-      if J.Node = 0 then\n-         raise Constraint_Error with \"J cursor has no element\";\n-      end if;\n-\n-      if I.Node = J.Node then\n-         return;\n-      end if;\n-\n-      pragma Assert (Vet (Container, I), \"bad I cursor in Swap\");\n-      pragma Assert (Vet (Container, J), \"bad J cursor in Swap\");\n-\n-      declare\n-         NN : Node_Array renames Container.Nodes;\n-         NI : Node_Type renames NN (I.Node);\n-         NJ : Node_Type renames NN (J.Node);\n-\n-         EI_Copy : constant Element_Type := NI.Element;\n-\n-      begin\n-         NI.Element := NJ.Element;\n-         NJ.Element := EI_Copy;\n-      end;\n-   end Swap;\n-\n-   ----------------\n-   -- Swap_Links --\n-   ----------------\n-\n-   procedure Swap_Links\n-     (Container : in out List;\n-      I         : Cursor;\n-      J         : Cursor)\n-   is\n-      I_Next : Cursor;\n-      J_Next : Cursor;\n-\n-   begin\n-      if I.Node = 0 then\n-         raise Constraint_Error with \"I cursor has no element\";\n-      end if;\n-\n-      if J.Node = 0 then\n-         raise Constraint_Error with \"J cursor has no element\";\n-      end if;\n-\n-      if I.Node = J.Node then\n-         return;\n-      end if;\n-\n-      pragma Assert (Vet (Container, I), \"bad I cursor in Swap_Links\");\n-      pragma Assert (Vet (Container, J), \"bad J cursor in Swap_Links\");\n-\n-      I_Next := Next (Container, I);\n-\n-      if I_Next = J then\n-         Splice (Container, Before => I, Position => J);\n-\n-      else\n-         J_Next := Next (Container, J);\n-\n-         if J_Next = I then\n-            Splice (Container, Before => J, Position => I);\n-\n-         else\n-            pragma Assert (Container.Length >= 3);\n-            Splice (Container, Before => I_Next, Position => J);\n-            Splice (Container, Before => J_Next, Position => I);\n-         end if;\n-      end if;\n-   end Swap_Links;\n-\n-   ---------\n-   -- Vet --\n-   ---------\n-\n-   function Vet (L : List; Position : Cursor) return Boolean is\n-      N : Node_Array renames L.Nodes;\n-   begin\n-      if not Container_Checks'Enabled then\n-         return True;\n-      end if;\n-\n-      if L.Length = 0 then\n-         return False;\n-      end if;\n-\n-      if L.First = 0 then\n-         return False;\n-      end if;\n-\n-      if L.Last = 0 then\n-         return False;\n-      end if;\n-\n-      if Position.Node > L.Capacity then\n-         return False;\n-      end if;\n-\n-      if N (Position.Node).Prev < 0\n-        or else N (Position.Node).Prev > L.Capacity\n-      then\n-         return False;\n-      end if;\n-\n-      if N (Position.Node).Next > L.Capacity then\n-         return False;\n-      end if;\n-\n-      if N (L.First).Prev /= 0 then\n-         return False;\n-      end if;\n-\n-      if N (L.Last).Next /= 0 then\n-         return False;\n-      end if;\n-\n-      if N (Position.Node).Prev = 0 and then Position.Node /= L.First then\n-         return False;\n-      end if;\n-\n-      if N (Position.Node).Next = 0 and then Position.Node /= L.Last then\n-         return False;\n-      end if;\n-\n-      if L.Length = 1 then\n-         return L.First = L.Last;\n-      end if;\n-\n-      if L.First = L.Last then\n-         return False;\n-      end if;\n-\n-      if N (L.First).Next = 0 then\n-         return False;\n-      end if;\n-\n-      if N (L.Last).Prev = 0 then\n-         return False;\n-      end if;\n-\n-      if N (N (L.First).Next).Prev /= L.First then\n-         return False;\n-      end if;\n-\n-      if N (N (L.Last).Prev).Next /= L.Last then\n-         return False;\n-      end if;\n-\n-      if L.Length = 2 then\n-         if N (L.First).Next /= L.Last then\n-            return False;\n-         end if;\n-\n-         if N (L.Last).Prev /= L.First then\n-            return False;\n-         end if;\n-\n-         return True;\n-      end if;\n-\n-      if N (L.First).Next = L.Last then\n-         return False;\n-      end if;\n-\n-      if N (L.Last).Prev = L.First then\n-         return False;\n-      end if;\n-\n-      if Position.Node = L.First then\n-         return True;\n-      end if;\n-\n-      if Position.Node = L.Last then\n-         return True;\n-      end if;\n-\n-      if N (Position.Node).Next = 0 then\n-         return False;\n-      end if;\n-\n-      if N (Position.Node).Prev = 0 then\n-         return False;\n-      end if;\n-\n-      if N (N (Position.Node).Next).Prev /= Position.Node then\n-         return False;\n-      end if;\n-\n-      if N (N (Position.Node).Prev).Next /= Position.Node then\n-         return False;\n-      end if;\n-\n-      if L.Length = 3 then\n-         if N (L.First).Next /= Position.Node then\n-            return False;\n-         end if;\n-\n-         if N (L.Last).Prev /= Position.Node then\n-            return False;\n-         end if;\n-      end if;\n-\n-      return True;\n-   end Vet;\n-\n-end Ada.Containers.Formal_Doubly_Linked_Lists;"}, {"sha": "3a53ca57cf59e1cde8a2cb9530ac4b996cf5015a", "filename": "gcc/ada/libgnat/a-cfdlli.ads", "status": "modified", "additions": 5, "deletions": 1636, "changes": 1641, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fa-cfdlli.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fa-cfdlli.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cfdlli.ads?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -29,1643 +29,12 @@\n -- <http://www.gnu.org/licenses/>.                                          --\n ------------------------------------------------------------------------------\n \n-with Ada.Containers.Functional_Vectors;\n-with Ada.Containers.Functional_Maps;\n-\n generic\n-   type Element_Type is private;\n-   with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n-\n-package Ada.Containers.Formal_Doubly_Linked_Lists with\n-  SPARK_Mode,\n-  Annotate => (GNATprove, Always_Return)\n-is\n-\n-   --  Contracts in this unit are meant for analysis only, not for run-time\n-   --  checking.\n-\n-   pragma Assertion_Policy (Pre => Ignore);\n-   pragma Assertion_Policy (Post => Ignore);\n-   pragma Assertion_Policy (Contract_Cases => Ignore);\n-   pragma Annotate (CodePeer, Skip_Analysis);\n-\n-   type List (Capacity : Count_Type) is private with\n-     Iterable => (First       => First,\n-                  Next        => Next,\n-                  Has_Element => Has_Element,\n-                  Element     => Element),\n-     Default_Initial_Condition => Is_Empty (List);\n-   pragma Preelaborable_Initialization (List);\n-\n-   type Cursor is record\n-      Node : Count_Type := 0;\n-   end record;\n-\n-   No_Element : constant Cursor := Cursor'(Node => 0);\n-\n-   Empty_List : constant List;\n-\n-   function Length (Container : List) return Count_Type with\n-     Global => null,\n-     Post   => Length'Result <= Container.Capacity;\n-\n-   pragma Unevaluated_Use_Of_Old (Allow);\n-\n-   package Formal_Model with Ghost is\n-      subtype Positive_Count_Type is Count_Type range 1 .. Count_Type'Last;\n-\n-      package M is new Ada.Containers.Functional_Vectors\n-        (Index_Type   => Positive_Count_Type,\n-         Element_Type => Element_Type);\n-\n-      function \"=\"\n-        (Left  : M.Sequence;\n-         Right : M.Sequence) return Boolean renames M.\"=\";\n-\n-      function \"<\"\n-        (Left  : M.Sequence;\n-         Right : M.Sequence) return Boolean renames M.\"<\";\n-\n-      function \"<=\"\n-        (Left  : M.Sequence;\n-         Right : M.Sequence) return Boolean renames M.\"<=\";\n-\n-      function M_Elements_In_Union\n-        (Container : M.Sequence;\n-         Left      : M.Sequence;\n-         Right     : M.Sequence) return Boolean\n-      --  The elements of Container are contained in either Left or Right\n-      with\n-        Global => null,\n-        Post   =>\n-          M_Elements_In_Union'Result =\n-            (for all I in 1 .. M.Length (Container) =>\n-              (for some J in 1 .. M.Length (Left) =>\n-                Element (Container, I) = Element (Left, J))\n-                  or (for some J in 1 .. M.Length (Right) =>\n-                       Element (Container, I) = Element (Right, J)));\n-      pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_In_Union);\n-\n-      function M_Elements_Included\n-        (Left  : M.Sequence;\n-         L_Fst : Positive_Count_Type := 1;\n-         L_Lst : Count_Type;\n-         Right : M.Sequence;\n-         R_Fst : Positive_Count_Type := 1;\n-         R_Lst : Count_Type) return Boolean\n-      --  The elements of the slice from L_Fst to L_Lst in Left are contained\n-      --  in the slide from R_Fst to R_Lst in Right.\n-      with\n-        Global => null,\n-        Pre    => L_Lst <= M.Length (Left) and R_Lst <= M.Length (Right),\n-        Post   =>\n-          M_Elements_Included'Result =\n-            (for all I in L_Fst .. L_Lst =>\n-              (for some J in R_Fst .. R_Lst =>\n-                Element (Left, I) = Element (Right, J)));\n-      pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_Included);\n-\n-      function M_Elements_Reversed\n-        (Left  : M.Sequence;\n-         Right : M.Sequence) return Boolean\n-      --  Right is Left in reverse order\n-      with\n-        Global => null,\n-        Post   =>\n-          M_Elements_Reversed'Result =\n-            (M.Length (Left) = M.Length (Right)\n-              and (for all I in 1 .. M.Length (Left) =>\n-                    Element (Left, I) =\n-                      Element (Right, M.Length (Left) - I + 1))\n-              and (for all I in 1 .. M.Length (Left) =>\n-                    Element (Right, I) =\n-                      Element (Left, M.Length (Left) - I + 1)));\n-      pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_Reversed);\n-\n-      function M_Elements_Swapped\n-        (Left  : M.Sequence;\n-         Right : M.Sequence;\n-         X     : Positive_Count_Type;\n-         Y     : Positive_Count_Type) return Boolean\n-      --  Elements stored at X and Y are reversed in Left and Right\n-      with\n-        Global => null,\n-        Pre    => X <= M.Length (Left) and Y <= M.Length (Left),\n-        Post   =>\n-          M_Elements_Swapped'Result =\n-            (M.Length (Left) = M.Length (Right)\n-              and Element (Left, X) = Element (Right, Y)\n-              and Element (Left, Y) = Element (Right, X)\n-              and M.Equal_Except (Left, Right, X, Y));\n-      pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_Swapped);\n-\n-      package P is new Ada.Containers.Functional_Maps\n-        (Key_Type                       => Cursor,\n-         Element_Type                   => Positive_Count_Type,\n-         Equivalent_Keys                => \"=\",\n-         Enable_Handling_Of_Equivalence => False);\n-\n-      function \"=\"\n-        (Left  : P.Map;\n-         Right : P.Map) return Boolean renames P.\"=\";\n-\n-      function \"<=\"\n-        (Left  : P.Map;\n-         Right : P.Map) return Boolean renames P.\"<=\";\n-\n-      function P_Positions_Shifted\n-        (Small : P.Map;\n-         Big   : P.Map;\n-         Cut   : Positive_Count_Type;\n-         Count : Count_Type := 1) return Boolean\n-      with\n-        Global => null,\n-        Post   =>\n-          P_Positions_Shifted'Result =\n-\n-            --  Big contains all cursors of Small\n-\n-            (P.Keys_Included (Small, Big)\n-\n-              --  Cursors located before Cut are not moved, cursors located\n-              --  after are shifted by Count.\n-\n-              and (for all I of Small =>\n-                    (if P.Get (Small, I) < Cut then\n-                        P.Get (Big, I) = P.Get (Small, I)\n-                     else\n-                        P.Get (Big, I) - Count = P.Get (Small, I)))\n-\n-              --  New cursors of Big (if any) are between Cut and Cut - 1 +\n-              --  Count.\n-\n-              and (for all I of Big =>\n-                    P.Has_Key (Small, I)\n-                      or P.Get (Big, I) - Count in Cut - Count  .. Cut - 1));\n-\n-      function P_Positions_Swapped\n-        (Left  : P.Map;\n-         Right : P.Map;\n-         X     : Cursor;\n-         Y     : Cursor) return Boolean\n-      --  Left and Right contain the same cursors, but the positions of X and Y\n-      --  are reversed.\n-      with\n-        Ghost,\n-        Global => null,\n-        Post   =>\n-          P_Positions_Swapped'Result =\n-            (P.Same_Keys (Left, Right)\n-              and P.Elements_Equal_Except (Left, Right, X, Y)\n-              and P.Has_Key (Left, X)\n-              and P.Has_Key (Left, Y)\n-              and P.Get (Left, X) = P.Get (Right, Y)\n-              and P.Get (Left, Y) = P.Get (Right, X));\n-\n-      function P_Positions_Truncated\n-        (Small : P.Map;\n-         Big   : P.Map;\n-         Cut   : Positive_Count_Type;\n-         Count : Count_Type := 1) return Boolean\n-      with\n-        Ghost,\n-        Global => null,\n-        Post   =>\n-          P_Positions_Truncated'Result =\n-\n-            --  Big contains all cursors of Small at the same position\n-\n-            (Small <= Big\n-\n-              --  New cursors of Big (if any) are between Cut and Cut - 1 +\n-              --  Count.\n-\n-              and (for all I of Big =>\n-                    P.Has_Key (Small, I)\n-                      or P.Get (Big, I) - Count in Cut - Count .. Cut - 1));\n-\n-      function Mapping_Preserved\n-        (M_Left  : M.Sequence;\n-         M_Right : M.Sequence;\n-         P_Left  : P.Map;\n-         P_Right : P.Map) return Boolean\n-      with\n-        Ghost,\n-        Global => null,\n-        Post   =>\n-          (if Mapping_Preserved'Result then\n-\n-             --  Left and Right contain the same cursors\n-\n-             P.Same_Keys (P_Left, P_Right)\n-\n-               --  Mappings from cursors to elements induced by M_Left, P_Left\n-               --  and M_Right, P_Right are the same.\n-\n-               and (for all C of P_Left =>\n-                     M.Get (M_Left, P.Get (P_Left, C)) =\n-                     M.Get (M_Right, P.Get (P_Right, C))));\n-\n-      function Model (Container : List) return M.Sequence with\n-      --  The high-level model of a list is a sequence of elements. Cursors are\n-      --  not represented in this model.\n-\n-        Ghost,\n-        Global => null,\n-        Post   => M.Length (Model'Result) = Length (Container);\n-      pragma Annotate (GNATprove, Iterable_For_Proof, \"Model\", Model);\n-\n-      function Positions (Container : List) return P.Map with\n-      --  The Positions map is used to model cursors. It only contains valid\n-      --  cursors and map them to their position in the container.\n-\n-        Ghost,\n-        Global => null,\n-        Post   =>\n-          not P.Has_Key (Positions'Result, No_Element)\n-\n-            --  Positions of cursors are smaller than the container's length.\n-\n-            and then\n-              (for all I of Positions'Result =>\n-                P.Get (Positions'Result, I) in 1 .. Length (Container)\n-\n-            --  No two cursors have the same position. Note that we do not\n-            --  state that there is a cursor in the map for each position, as\n-            --  it is rarely needed.\n-\n-            and then\n-              (for all J of Positions'Result =>\n-                (if P.Get (Positions'Result, I) = P.Get (Positions'Result, J)\n-                  then I = J)));\n-\n-      procedure Lift_Abstraction_Level (Container : List) with\n-        --  Lift_Abstraction_Level is a ghost procedure that does nothing but\n-        --  assume that we can access to the same elements by iterating over\n-        --  positions or cursors.\n-        --  This information is not generally useful except when switching from\n-        --  a low-level cursor-aware view of a container to a high-level\n-        --  position-based view.\n-\n-        Ghost,\n-        Global => null,\n-        Post   =>\n-          (for all Elt of Model (Container) =>\n-            (for some I of Positions (Container) =>\n-              M.Get (Model (Container), P.Get (Positions (Container), I)) =\n-                Elt));\n-\n-      function Element\n-        (S : M.Sequence;\n-         I : Count_Type) return Element_Type renames M.Get;\n-      --  To improve readability of contracts, we rename the function used to\n-      --  access an element in the model to Element.\n-\n-   end Formal_Model;\n-   use Formal_Model;\n-\n-   function \"=\" (Left, Right : List) return Boolean with\n-     Global => null,\n-     Post   => \"=\"'Result = (Model (Left) = Model (Right));\n-\n-   function Is_Empty (Container : List) return Boolean with\n-     Global => null,\n-     Post   => Is_Empty'Result = (Length (Container) = 0);\n-\n-   procedure Clear (Container : in out List) with\n-     Global => null,\n-     Post   => Length (Container) = 0;\n-\n-   procedure Assign (Target : in out List; Source : List) with\n-     Global => null,\n-     Pre    => Target.Capacity >= Length (Source),\n-     Post   => Model (Target) = Model (Source);\n-\n-   function Copy (Source : List; Capacity : Count_Type := 0) return List with\n-     Global => null,\n-     Pre    => Capacity = 0 or else Capacity >= Source.Capacity,\n-     Post   =>\n-       Model (Copy'Result) = Model (Source)\n-         and Positions (Copy'Result) = Positions (Source)\n-         and (if Capacity = 0 then\n-                 Copy'Result.Capacity = Source.Capacity\n-              else\n-                 Copy'Result.Capacity = Capacity);\n-\n-   function Element\n-     (Container : List;\n-      Position : Cursor) return Element_Type\n-   with\n-     Global => null,\n-     Pre    => Has_Element (Container, Position),\n-     Post   =>\n-       Element'Result =\n-         Element (Model (Container), P.Get (Positions (Container), Position));\n-   pragma Annotate (GNATprove, Inline_For_Proof, Element);\n-\n-   procedure Replace_Element\n-     (Container : in out List;\n-      Position  : Cursor;\n-      New_Item  : Element_Type)\n-   with\n-     Global => null,\n-     Pre    => Has_Element (Container, Position),\n-     Post   =>\n-       Length (Container) = Length (Container)'Old\n-\n-         --  Cursors are preserved\n-\n-         and Positions (Container)'Old = Positions (Container)\n-\n-         --  The element at the position of Position in Container is New_Item\n-\n-         and Element\n-               (Model (Container),\n-                P.Get (Positions (Container), Position)) = New_Item\n-\n-         --  Other elements are preserved\n-\n-         and M.Equal_Except\n-               (Model (Container)'Old,\n-                Model (Container),\n-                P.Get (Positions (Container), Position));\n-\n-   function At_End (E : access constant List) return access constant List\n-   is (E)\n-   with Ghost,\n-     Annotate => (GNATprove, At_End_Borrow);\n-\n-   function At_End\n-     (E : access constant Element_Type) return access constant Element_Type\n-   is (E)\n-   with Ghost,\n-     Annotate => (GNATprove, At_End_Borrow);\n-\n-   function Constant_Reference\n-     (Container : aliased List;\n-      Position  : Cursor) return not null access constant Element_Type\n-   with\n-     Global => null,\n-     Pre    => Has_Element (Container, Position),\n-     Post   =>\n-       Constant_Reference'Result.all =\n-         Element (Model (Container), P.Get (Positions (Container), Position));\n-\n-   function Reference\n-     (Container : not null access List;\n-      Position  : Cursor) return not null access Element_Type\n-   with\n-     Global => null,\n-     Pre    => Has_Element (Container.all, Position),\n-     Post   =>\n-      Length (Container.all) = Length (At_End (Container).all)\n-\n-         --  Cursors are preserved\n-\n-         and Positions (Container.all) = Positions (At_End (Container).all)\n-\n-         --  Container will have Result.all at position Position\n-\n-         and At_End (Reference'Result).all =\n-           Element (Model (At_End (Container).all),\n-                    P.Get (Positions (At_End (Container).all), Position))\n-\n-         --  All other elements are preserved\n-\n-         and M.Equal_Except\n-               (Model (Container.all),\n-                Model (At_End (Container).all),\n-                P.Get (Positions (At_End (Container).all), Position));\n-\n-   procedure Move (Target : in out List; Source : in out List) with\n-     Global => null,\n-     Pre    => Target.Capacity >= Length (Source),\n-     Post   => Model (Target) = Model (Source'Old) and Length (Source) = 0;\n-\n-   procedure Insert\n-     (Container : in out List;\n-      Before    : Cursor;\n-      New_Item  : Element_Type)\n-   with\n-     Global         => null,\n-     Pre            =>\n-       Length (Container) < Container.Capacity\n-         and then (Has_Element (Container, Before)\n-                    or else Before = No_Element),\n-     Post           => Length (Container) = Length (Container)'Old + 1,\n-     Contract_Cases =>\n-       (Before = No_Element =>\n-\n-          --  Positions contains a new mapping from the last cursor of\n-          --  Container to its length.\n-\n-          P.Get (Positions (Container), Last (Container)) = Length (Container)\n-\n-            --  Other cursors come from Container'Old\n-\n-            and P.Keys_Included_Except\n-                  (Left    => Positions (Container),\n-                   Right   => Positions (Container)'Old,\n-                   New_Key => Last (Container))\n-\n-            --  Cursors of Container'Old keep the same position\n-\n-            and Positions (Container)'Old <= Positions (Container)\n-\n-            --  Model contains a new element New_Item at the end\n-\n-            and Element (Model (Container), Length (Container)) = New_Item\n-\n-            --  Elements of Container'Old are preserved\n-\n-            and Model (Container)'Old <= Model (Container),\n-\n-        others =>\n-\n-          --  The elements of Container located before Before are preserved\n-\n-          M.Range_Equal\n-            (Left  => Model (Container)'Old,\n-             Right => Model (Container),\n-             Fst   => 1,\n-             Lst   => P.Get (Positions (Container)'Old, Before) - 1)\n-\n-            --  Other elements are shifted by 1\n-\n-            and M.Range_Shifted\n-                  (Left   => Model (Container)'Old,\n-                   Right  => Model (Container),\n-                   Fst    => P.Get (Positions (Container)'Old, Before),\n-                   Lst    => Length (Container)'Old,\n-                   Offset => 1)\n-\n-            --  New_Item is stored at the previous position of Before in\n-            --  Container.\n-\n-            and Element\n-                  (Model (Container),\n-                   P.Get (Positions (Container)'Old, Before)) = New_Item\n-\n-            --  A new cursor has been inserted at position Before in Container\n-\n-            and P_Positions_Shifted\n-                  (Positions (Container)'Old,\n-                   Positions (Container),\n-                   Cut => P.Get (Positions (Container)'Old, Before)));\n-\n-   procedure Insert\n-     (Container : in out List;\n-      Before    : Cursor;\n-      New_Item  : Element_Type;\n-      Count     : Count_Type)\n-   with\n-     Global         => null,\n-     Pre            =>\n-       Length (Container) <= Container.Capacity - Count\n-         and then (Has_Element (Container, Before)\n-                    or else Before = No_Element),\n-     Post           => Length (Container) = Length (Container)'Old + Count,\n-     Contract_Cases =>\n-       (Before = No_Element =>\n-\n-          --  The elements of Container are preserved\n-\n-          M.Range_Equal\n-            (Left  => Model (Container)'Old,\n-             Right => Model (Container),\n-             Fst   => 1,\n-             Lst   => Length (Container)'Old)\n-\n-            --  Container contains Count times New_Item at the end\n-\n-            and (if Count > 0 then\n-                    M.Constant_Range\n-                      (Container => Model (Container),\n-                       Fst       => Length (Container)'Old + 1,\n-                       Lst       => Length (Container),\n-                       Item      => New_Item))\n-\n-            --  Count cursors have been inserted at the end of Container\n-\n-            and P_Positions_Truncated\n-                  (Positions (Container)'Old,\n-                   Positions (Container),\n-                   Cut   => Length (Container)'Old + 1,\n-                   Count => Count),\n-\n-        others =>\n-\n-          --  The elements of Container located before Before are preserved\n-\n-          M.Range_Equal\n-            (Left  => Model (Container)'Old,\n-             Right => Model (Container),\n-             Fst   => 1,\n-             Lst   => P.Get (Positions (Container)'Old, Before) - 1)\n-\n-            --  Other elements are shifted by Count\n-\n-            and M.Range_Shifted\n-                  (Left   => Model (Container)'Old,\n-                   Right  => Model (Container),\n-                   Fst    => P.Get (Positions (Container)'Old, Before),\n-                   Lst    => Length (Container)'Old,\n-                   Offset => Count)\n-\n-            --  Container contains Count times New_Item after position Before\n-\n-            and M.Constant_Range\n-                  (Container => Model (Container),\n-                   Fst       => P.Get (Positions (Container)'Old, Before),\n-                   Lst       =>\n-                     P.Get (Positions (Container)'Old, Before) - 1 + Count,\n-                   Item      => New_Item)\n-\n-            --  Count cursors have been inserted at position Before in\n-            --  Container.\n-\n-            and P_Positions_Shifted\n-                  (Positions (Container)'Old,\n-                   Positions (Container),\n-                   Cut   => P.Get (Positions (Container)'Old, Before),\n-                   Count => Count));\n-\n-   procedure Insert\n-     (Container : in out List;\n-      Before    : Cursor;\n-      New_Item  : Element_Type;\n-      Position  : out Cursor)\n-   with\n-     Global => null,\n-     Pre    =>\n-       Length (Container) < Container.Capacity\n-         and then (Has_Element (Container, Before)\n-                    or else Before = No_Element),\n-     Post   =>\n-       Length (Container) = Length (Container)'Old + 1\n-\n-          --  Positions is valid in Container and it is located either before\n-          --  Before if it is valid in Container or at the end if it is\n-          --  No_Element.\n-\n-          and P.Has_Key (Positions (Container), Position)\n-          and (if Before = No_Element then\n-                  P.Get (Positions (Container), Position) = Length (Container)\n-               else\n-                  P.Get (Positions (Container), Position) =\n-                  P.Get (Positions (Container)'Old, Before))\n-\n-          --  The elements of Container located before Position are preserved\n-\n-          and M.Range_Equal\n-                (Left  => Model (Container)'Old,\n-                 Right => Model (Container),\n-                 Fst   => 1,\n-                 Lst   => P.Get (Positions (Container), Position) - 1)\n-\n-          --  Other elements are shifted by 1\n-\n-          and M.Range_Shifted\n-                (Left   => Model (Container)'Old,\n-                 Right  => Model (Container),\n-                 Fst    => P.Get (Positions (Container), Position),\n-                 Lst    => Length (Container)'Old,\n-                 Offset => 1)\n-\n-          --  New_Item is stored at Position in Container\n-\n-          and Element\n-                (Model (Container),\n-                 P.Get (Positions (Container), Position)) = New_Item\n-\n-          --  A new cursor has been inserted at position Position in Container\n-\n-          and P_Positions_Shifted\n-                (Positions (Container)'Old,\n-                 Positions (Container),\n-                 Cut => P.Get (Positions (Container), Position));\n-\n-   procedure Insert\n-     (Container : in out List;\n-      Before    : Cursor;\n-      New_Item  : Element_Type;\n-      Position  : out Cursor;\n-      Count     : Count_Type)\n-   with\n-     Global         => null,\n-     Pre            =>\n-       Length (Container) <= Container.Capacity - Count\n-         and then (Has_Element (Container, Before)\n-                    or else Before = No_Element),\n-     Post           => Length (Container) = Length (Container)'Old + Count,\n-     Contract_Cases =>\n-       (Count = 0 =>\n-         Position = Before\n-           and Model (Container) = Model (Container)'Old\n-           and Positions (Container) = Positions (Container)'Old,\n-\n-        others =>\n-\n-          --  Positions is valid in Container and it is located either before\n-          --  Before if it is valid in Container or at the end if it is\n-          --  No_Element.\n-\n-          P.Has_Key (Positions (Container), Position)\n-            and (if Before = No_Element then\n-                    P.Get (Positions (Container), Position) =\n-                    Length (Container)'Old + 1\n-                 else\n-                    P.Get (Positions (Container), Position) =\n-                    P.Get (Positions (Container)'Old, Before))\n-\n-            --  The elements of Container located before Position are preserved\n-\n-            and M.Range_Equal\n-                  (Left  => Model (Container)'Old,\n-                   Right => Model (Container),\n-                   Fst   => 1,\n-                   Lst   => P.Get (Positions (Container), Position) - 1)\n-\n-            --  Other elements are shifted by Count\n-\n-            and M.Range_Shifted\n-                  (Left   => Model (Container)'Old,\n-                   Right  => Model (Container),\n-                   Fst    => P.Get (Positions (Container), Position),\n-                   Lst    => Length (Container)'Old,\n-                   Offset => Count)\n-\n-            --  Container contains Count times New_Item after position Position\n-\n-            and M.Constant_Range\n-                  (Container => Model (Container),\n-                   Fst       => P.Get (Positions (Container), Position),\n-                   Lst       =>\n-                     P.Get (Positions (Container), Position) - 1 + Count,\n-                   Item      => New_Item)\n-\n-            --  Count cursor have been inserted at Position in Container\n-\n-            and P_Positions_Shifted\n-                  (Positions (Container)'Old,\n-                   Positions (Container),\n-                   Cut   => P.Get (Positions (Container), Position),\n-                   Count => Count));\n-\n-   procedure Prepend (Container : in out List; New_Item : Element_Type) with\n-     Global => null,\n-     Pre    => Length (Container) < Container.Capacity,\n-     Post   =>\n-       Length (Container) = Length (Container)'Old + 1\n-\n-         --  Elements are shifted by 1\n-\n-         and M.Range_Shifted\n-               (Left   => Model (Container)'Old,\n-                Right  => Model (Container),\n-                Fst    => 1,\n-                Lst    => Length (Container)'Old,\n-                Offset => 1)\n-\n-         --  New_Item is the first element of Container\n-\n-         and Element (Model (Container), 1) = New_Item\n-\n-         --  A new cursor has been inserted at the beginning of Container\n-\n-         and P_Positions_Shifted\n-               (Positions (Container)'Old,\n-                Positions (Container),\n-                Cut => 1);\n-\n-   procedure Prepend\n-     (Container : in out List;\n-      New_Item  : Element_Type;\n-      Count     : Count_Type)\n-   with\n-     Global => null,\n-     Pre    => Length (Container) <= Container.Capacity - Count,\n-     Post   =>\n-       Length (Container) = Length (Container)'Old + Count\n-\n-         --  Elements are shifted by Count\n-\n-         and M.Range_Shifted\n-               (Left     => Model (Container)'Old,\n-                Right     => Model (Container),\n-                Fst    => 1,\n-                Lst    => Length (Container)'Old,\n-                Offset => Count)\n-\n-         --  Container starts with Count times New_Item\n-\n-         and M.Constant_Range\n-               (Container => Model (Container),\n-                Fst       => 1,\n-                Lst       => Count,\n-                Item      => New_Item)\n-\n-         --  Count cursors have been inserted at the beginning of Container\n-\n-         and P_Positions_Shifted\n-               (Positions (Container)'Old,\n-                Positions (Container),\n-                Cut   => 1,\n-                Count => Count);\n-\n-   procedure Append (Container : in out List; New_Item : Element_Type) with\n-     Global => null,\n-     Pre    => Length (Container) < Container.Capacity,\n-     Post   =>\n-       Length (Container) = Length (Container)'Old + 1\n-\n-         --  Positions contains a new mapping from the last cursor of Container\n-         --  to its length.\n-\n-         and P.Get (Positions (Container), Last (Container)) =\n-               Length (Container)\n-\n-         --  Other cursors come from Container'Old\n-\n-         and P.Keys_Included_Except\n-               (Left    => Positions (Container),\n-                Right   => Positions (Container)'Old,\n-                New_Key => Last (Container))\n-\n-         --  Cursors of Container'Old keep the same position\n-\n-         and Positions (Container)'Old <= Positions (Container)\n-\n-         --  Model contains a new element New_Item at the end\n-\n-         and Element (Model (Container), Length (Container)) = New_Item\n-\n-         --  Elements of Container'Old are preserved\n-\n-         and Model (Container)'Old <= Model (Container);\n-\n-   procedure Append\n-     (Container : in out List;\n-      New_Item  : Element_Type;\n-      Count     : Count_Type)\n-   with\n-     Global => null,\n-     Pre    => Length (Container) <= Container.Capacity - Count,\n-     Post   =>\n-       Length (Container) = Length (Container)'Old + Count\n-\n-         --  The elements of Container are preserved\n-\n-         and Model (Container)'Old <= Model (Container)\n-\n-         --  Container contains Count times New_Item at the end\n-\n-         and (if Count > 0 then\n-                 M.Constant_Range\n-                   (Container => Model (Container),\n-                     Fst       => Length (Container)'Old + 1,\n-                     Lst       => Length (Container),\n-                     Item      => New_Item))\n-\n-         --  Count cursors have been inserted at the end of Container\n-\n-         and P_Positions_Truncated\n-               (Positions (Container)'Old,\n-                Positions (Container),\n-                Cut   => Length (Container)'Old + 1,\n-                Count => Count);\n-\n-   procedure Delete (Container : in out List; Position : in out Cursor) with\n-     Global  => null,\n-     Depends => (Container =>+ Position, Position => null),\n-     Pre     => Has_Element (Container, Position),\n-     Post    =>\n-       Length (Container) = Length (Container)'Old - 1\n-\n-         --  Position is set to No_Element\n-\n-         and Position = No_Element\n-\n-         --  The elements of Container located before Position are preserved.\n-\n-         and M.Range_Equal\n-               (Left  => Model (Container)'Old,\n-                Right => Model (Container),\n-                Fst   => 1,\n-                Lst   => P.Get (Positions (Container)'Old, Position'Old) - 1)\n-\n-         --  The elements located after Position are shifted by 1\n-\n-         and M.Range_Shifted\n-               (Left   => Model (Container),\n-                Right  => Model (Container)'Old,\n-                Fst    => P.Get (Positions (Container)'Old, Position'Old),\n-                Lst    => Length (Container),\n-                Offset => 1)\n-\n-         --  Position has been removed from Container\n-\n-         and P_Positions_Shifted\n-               (Positions (Container),\n-                Positions (Container)'Old,\n-                Cut   => P.Get (Positions (Container)'Old, Position'Old));\n-\n-   procedure Delete\n-     (Container : in out List;\n-      Position  : in out Cursor;\n-      Count     : Count_Type)\n-   with\n-     Global         => null,\n-     Pre            => Has_Element (Container, Position),\n-     Post           =>\n-       Length (Container) in\n-         Length (Container)'Old - Count .. Length (Container)'Old\n-\n-         --  Position is set to No_Element\n-\n-         and Position = No_Element\n-\n-         --  The elements of Container located before Position are preserved.\n-\n-         and M.Range_Equal\n-               (Left  => Model (Container)'Old,\n-                Right => Model (Container),\n-                Fst   => 1,\n-                Lst   => P.Get (Positions (Container)'Old, Position'Old) - 1),\n-\n-     Contract_Cases =>\n-\n-       --  All the elements after Position have been erased\n-\n-       (Length (Container) - Count < P.Get (Positions (Container), Position) =>\n-          Length (Container) =\n-            P.Get (Positions (Container)'Old, Position'Old) - 1\n-\n-            --  At most Count cursors have been removed at the end of Container\n-\n-            and P_Positions_Truncated\n-                 (Positions (Container),\n-                  Positions (Container)'Old,\n-                  Cut   => P.Get (Positions (Container)'Old, Position'Old),\n-                  Count => Count),\n-\n-        others =>\n-          Length (Container) = Length (Container)'Old - Count\n-\n-            --  Other elements are shifted by Count\n-\n-            and M.Range_Shifted\n-                  (Left   => Model (Container),\n-                   Right  => Model (Container)'Old,\n-                   Fst    => P.Get (Positions (Container)'Old, Position'Old),\n-                   Lst    => Length (Container),\n-                   Offset => Count)\n-\n-            --  Count cursors have been removed from Container at Position\n-\n-            and P_Positions_Shifted\n-                 (Positions (Container),\n-                  Positions (Container)'Old,\n-                  Cut   => P.Get (Positions (Container)'Old, Position'Old),\n-                  Count => Count));\n-\n-   procedure Delete_First (Container : in out List) with\n-     Global => null,\n-     Pre    => not Is_Empty (Container),\n-     Post   =>\n-       Length (Container) = Length (Container)'Old - 1\n-\n-         --  The elements of Container are shifted by 1\n-\n-         and M.Range_Shifted\n-               (Left   => Model (Container),\n-                Right  => Model (Container)'Old,\n-                Fst    => 1,\n-                Lst    => Length (Container),\n-                Offset => 1)\n-\n-         --  The first cursor of Container has been removed\n-\n-         and P_Positions_Shifted\n-               (Positions (Container),\n-                Positions (Container)'Old,\n-                Cut   => 1);\n-\n-   procedure Delete_First (Container : in out List; Count : Count_Type) with\n-     Global         => null,\n-     Contract_Cases =>\n-\n-       --  All the elements of Container have been erased\n-\n-       (Length (Container) <= Count =>\n-          Length (Container) = 0,\n-\n-        others =>\n-          Length (Container) = Length (Container)'Old - Count\n-\n-            --  Elements of Container are shifted by Count\n-\n-            and M.Range_Shifted\n-                  (Left   => Model (Container),\n-                   Right  => Model (Container)'Old,\n-                   Fst    => 1,\n-                   Lst    => Length (Container),\n-                   Offset => Count)\n-\n-            --  The first Count cursors have been removed from Container\n-\n-            and P_Positions_Shifted\n-                  (Positions (Container),\n-                   Positions (Container)'Old,\n-                   Cut   => 1,\n-                   Count => Count));\n-\n-   procedure Delete_Last (Container : in out List) with\n-     Global => null,\n-     Pre    => not Is_Empty (Container),\n-     Post   =>\n-       Length (Container) = Length (Container)'Old - 1\n-\n-         --  The elements of Container are preserved\n-\n-         and Model (Container) <= Model (Container)'Old\n-\n-         --  The last cursor of Container has been removed\n-\n-         and not P.Has_Key (Positions (Container), Last (Container)'Old)\n-\n-         --  Other cursors are still valid\n-\n-         and P.Keys_Included_Except\n-               (Left    => Positions (Container)'Old,\n-                Right   => Positions (Container)'Old,\n-                New_Key => Last (Container)'Old)\n-\n-         --  The positions of other cursors are preserved\n-\n-         and Positions (Container) <= Positions (Container)'Old;\n-\n-   procedure Delete_Last (Container : in out List; Count : Count_Type) with\n-     Global         => null,\n-     Contract_Cases =>\n-\n-       --  All the elements of Container have been erased\n-\n-       (Length (Container) <= Count =>\n-          Length (Container) = 0,\n-\n-        others =>\n-          Length (Container) = Length (Container)'Old - Count\n-\n-            --  The elements of Container are preserved\n-\n-            and Model (Container) <= Model (Container)'Old\n-\n-            --  At most Count cursors have been removed at the end of Container\n-\n-            and P_Positions_Truncated\n-                  (Positions (Container),\n-                   Positions (Container)'Old,\n-                   Cut   => Length (Container) + 1,\n-                   Count => Count));\n-\n-   procedure Reverse_Elements (Container : in out List) with\n-     Global => null,\n-     Post   => M_Elements_Reversed (Model (Container)'Old, Model (Container));\n-\n-   procedure Swap\n-     (Container : in out List;\n-      I         : Cursor;\n-      J         : Cursor)\n-   with\n-     Global => null,\n-     Pre    => Has_Element (Container, I) and then Has_Element (Container, J),\n-     Post   =>\n-       M_Elements_Swapped\n-         (Model (Container)'Old,\n-          Model (Container),\n-          X => P.Get (Positions (Container)'Old, I),\n-          Y => P.Get (Positions (Container)'Old, J))\n-\n-         and Positions (Container) = Positions (Container)'Old;\n-\n-   procedure Swap_Links\n-     (Container : in out List;\n-      I         : Cursor;\n-      J         : Cursor)\n-   with\n-     Global => null,\n-     Pre    => Has_Element (Container, I) and then Has_Element (Container, J),\n-     Post   =>\n-       M_Elements_Swapped\n-         (Model (Container'Old),\n-          Model (Container),\n-          X => P.Get (Positions (Container)'Old, I),\n-          Y => P.Get (Positions (Container)'Old, J))\n-         and P_Positions_Swapped\n-               (Positions (Container)'Old, Positions (Container), I, J);\n-\n-   procedure Splice\n-     (Target : in out List;\n-      Before : Cursor;\n-      Source : in out List)\n-   --  Target and Source should not be aliased\n-   with\n-     Global         => null,\n-     Pre            =>\n-       Length (Source) <= Target.Capacity - Length (Target)\n-         and then (Has_Element (Target, Before)\n-                    or else Before = No_Element),\n-     Post           =>\n-       Length (Source) = 0\n-         and Length (Target) = Length (Target)'Old + Length (Source)'Old,\n-     Contract_Cases =>\n-       (Before = No_Element =>\n-\n-          --  The elements of Target are preserved\n-\n-          M.Range_Equal\n-            (Left  => Model (Target)'Old,\n-             Right => Model (Target),\n-             Fst   => 1,\n-             Lst   => Length (Target)'Old)\n-\n-            --  The elements of Source are appended to target, the order is not\n-            --  specified.\n-\n-            and M_Elements_Included\n-                  (Left   => Model (Source)'Old,\n-                   L_Lst  => Length (Source)'Old,\n-                   Right  => Model (Target),\n-                   R_Fst  => Length (Target)'Old + 1,\n-                   R_Lst  => Length (Target))\n-\n-            and M_Elements_Included\n-                  (Left   => Model (Target),\n-                   L_Fst  => Length (Target)'Old + 1,\n-                   L_Lst  => Length (Target),\n-                   Right  => Model (Source)'Old,\n-                   R_Lst  => Length (Source)'Old)\n-\n-            --  Cursors have been inserted at the end of Target\n-\n-            and P_Positions_Truncated\n-                  (Positions (Target)'Old,\n-                   Positions (Target),\n-                   Cut   => Length (Target)'Old + 1,\n-                   Count => Length (Source)'Old),\n-\n-        others =>\n-\n-          --  The elements of Target located before Before are preserved\n-\n-          M.Range_Equal\n-            (Left  => Model (Target)'Old,\n-             Right => Model (Target),\n-             Fst   => 1,\n-             Lst   => P.Get (Positions (Target)'Old, Before) - 1)\n-\n-            --  The elements of Source are inserted before Before, the order is\n-            --  not specified.\n-\n-            and M_Elements_Included\n-                  (Left   => Model (Source)'Old,\n-                   L_Lst  => Length (Source)'Old,\n-                   Right  => Model (Target),\n-                   R_Fst  => P.Get (Positions (Target)'Old, Before),\n-                   R_Lst  =>\n-                     P.Get (Positions (Target)'Old, Before) - 1 +\n-                       Length (Source)'Old)\n-\n-            and M_Elements_Included\n-                  (Left   => Model (Target),\n-                   L_Fst  => P.Get (Positions (Target)'Old, Before),\n-                   L_Lst  =>\n-                     P.Get (Positions (Target)'Old, Before) - 1 +\n-                       Length (Source)'Old,\n-                   Right  => Model (Source)'Old,\n-                   R_Lst  => Length (Source)'Old)\n-\n-          --  Other elements are shifted by the length of Source\n-\n-          and M.Range_Shifted\n-                (Left   => Model (Target)'Old,\n-                 Right  => Model (Target),\n-                 Fst    => P.Get (Positions (Target)'Old, Before),\n-                 Lst    => Length (Target)'Old,\n-                 Offset => Length (Source)'Old)\n-\n-          --  Cursors have been inserted at position Before in Target\n-\n-          and P_Positions_Shifted\n-                (Positions (Target)'Old,\n-                 Positions (Target),\n-                 Cut   => P.Get (Positions (Target)'Old, Before),\n-                 Count => Length (Source)'Old));\n-\n-   procedure Splice\n-     (Target   : in out List;\n-      Before   : Cursor;\n-      Source   : in out List;\n-      Position : in out Cursor)\n-   --  Target and Source should not be aliased\n-   with\n-     Global => null,\n-     Pre    =>\n-       (Has_Element (Target, Before) or else Before = No_Element)\n-         and then Has_Element (Source, Position)\n-         and then Length (Target) < Target.Capacity,\n-     Post   =>\n-       Length (Target) = Length (Target)'Old + 1\n-         and Length (Source) = Length (Source)'Old - 1\n-\n-         --  The elements of Source located before Position are preserved\n-\n-         and M.Range_Equal\n-               (Left  => Model (Source)'Old,\n-                Right => Model (Source),\n-                Fst   => 1,\n-                Lst   => P.Get (Positions (Source)'Old, Position'Old) - 1)\n-\n-         --  The elements located after Position are shifted by 1\n-\n-         and M.Range_Shifted\n-               (Left   => Model (Source)'Old,\n-                Right  => Model (Source),\n-                Fst    => P.Get (Positions (Source)'Old, Position'Old) + 1,\n-                Lst    => Length (Source)'Old,\n-                Offset => -1)\n-\n-         --  Position has been removed from Source\n-\n-         and P_Positions_Shifted\n-               (Positions (Source),\n-                Positions (Source)'Old,\n-                Cut   => P.Get (Positions (Source)'Old, Position'Old))\n-\n-         --  Positions is valid in Target and it is located either before\n-         --  Before if it is valid in Target or at the end if it is No_Element.\n-\n-         and P.Has_Key (Positions (Target), Position)\n-         and (if Before = No_Element then\n-                 P.Get (Positions (Target), Position) = Length (Target)\n-              else\n-                 P.Get (Positions (Target), Position) =\n-                 P.Get (Positions (Target)'Old, Before))\n-\n-         --  The elements of Target located before Position are preserved\n-\n-         and M.Range_Equal\n-               (Left  => Model (Target)'Old,\n-                Right => Model (Target),\n-                Fst   => 1,\n-                Lst   => P.Get (Positions (Target), Position) - 1)\n-\n-         --  Other elements are shifted by 1\n-\n-         and M.Range_Shifted\n-               (Left   => Model (Target)'Old,\n-                Right  => Model (Target),\n-                Fst    => P.Get (Positions (Target), Position),\n-                Lst    => Length (Target)'Old,\n-                Offset => 1)\n-\n-         --  The element located at Position in Source is moved to Target\n-\n-         and Element (Model (Target),\n-                      P.Get (Positions (Target), Position)) =\n-             Element (Model (Source)'Old,\n-                      P.Get (Positions (Source)'Old, Position'Old))\n-\n-         --  A new cursor has been inserted at position Position in Target\n-\n-         and P_Positions_Shifted\n-               (Positions (Target)'Old,\n-                Positions (Target),\n-                Cut => P.Get (Positions (Target), Position));\n-\n-   procedure Splice\n-     (Container : in out List;\n-      Before    : Cursor;\n-      Position  : Cursor)\n-   with\n-     Global         => null,\n-     Pre            =>\n-       (Has_Element (Container, Before) or else Before = No_Element)\n-         and then Has_Element (Container, Position),\n-     Post           => Length (Container) = Length (Container)'Old,\n-     Contract_Cases =>\n-       (Before = Position =>\n-          Model (Container) = Model (Container)'Old\n-            and Positions (Container) = Positions (Container)'Old,\n-\n-        Before = No_Element =>\n-\n-          --  The elements located before Position are preserved\n-\n-          M.Range_Equal\n-            (Left  => Model (Container)'Old,\n-             Right => Model (Container),\n-             Fst   => 1,\n-             Lst   => P.Get (Positions (Container)'Old, Position) - 1)\n-\n-          --  The elements located after Position are shifted by 1\n-\n-          and M.Range_Shifted\n-                (Left   => Model (Container)'Old,\n-                 Right  => Model (Container),\n-                 Fst    => P.Get (Positions (Container)'Old, Position) + 1,\n-                 Lst    => Length (Container)'Old,\n-                 Offset => -1)\n-\n-          --  The last element of Container is the one that was previously at\n-          --  Position.\n-\n-          and Element (Model (Container),\n-                       Length (Container)) =\n-              Element (Model (Container)'Old,\n-                       P.Get (Positions (Container)'Old, Position))\n-\n-          --  Cursors from Container continue designating the same elements\n-\n-          and Mapping_Preserved\n-                (M_Left  => Model (Container)'Old,\n-                 M_Right => Model (Container),\n-                 P_Left  => Positions (Container)'Old,\n-                 P_Right => Positions (Container)),\n-\n-        others =>\n-\n-          --  The elements located before Position and Before are preserved\n-\n-          M.Range_Equal\n-            (Left  => Model (Container)'Old,\n-             Right => Model (Container),\n-             Fst   => 1,\n-             Lst   =>\n-               Count_Type'Min\n-                 (P.Get (Positions (Container)'Old, Position) - 1,\n-                  P.Get (Positions (Container)'Old, Before) - 1))\n-\n-            --  The elements located after Position and Before are preserved\n-\n-            and M.Range_Equal\n-                  (Left  => Model (Container)'Old,\n-                   Right => Model (Container),\n-                   Fst   =>\n-                     Count_Type'Max\n-                       (P.Get (Positions (Container)'Old, Position) + 1,\n-                        P.Get (Positions (Container)'Old, Before) + 1),\n-                   Lst   => Length (Container))\n-\n-            --  The elements located after Before and before Position are\n-            --  shifted by 1 to the right.\n-\n-            and M.Range_Shifted\n-                  (Left   => Model (Container)'Old,\n-                   Right  => Model (Container),\n-                   Fst    => P.Get (Positions (Container)'Old, Before) + 1,\n-                   Lst    => P.Get (Positions (Container)'Old, Position) - 1,\n-                   Offset => 1)\n-\n-            --  The elements located after Position and before Before are\n-            --  shifted by 1 to the left.\n-\n-            and M.Range_Shifted\n-                  (Left   => Model (Container)'Old,\n-                   Right  => Model (Container),\n-                   Fst    => P.Get (Positions (Container)'Old, Position) + 1,\n-                   Lst    => P.Get (Positions (Container)'Old, Before) - 1,\n-                   Offset => -1)\n-\n-            --  The element previously at Position is now before Before\n-\n-            and Element\n-                  (Model (Container),\n-                   P.Get (Positions (Container)'Old, Before)) =\n-                Element\n-                  (Model (Container)'Old,\n-                   P.Get (Positions (Container)'Old, Position))\n-\n-            --  Cursors from Container continue designating the same elements\n-\n-            and Mapping_Preserved\n-                  (M_Left  => Model (Container)'Old,\n-                   M_Right => Model (Container),\n-                   P_Left  => Positions (Container)'Old,\n-                   P_Right => Positions (Container)));\n-\n-   function First (Container : List) return Cursor with\n-     Global         => null,\n-     Contract_Cases =>\n-       (Length (Container) = 0 =>\n-          First'Result = No_Element,\n-\n-        others =>\n-          Has_Element (Container, First'Result)\n-            and P.Get (Positions (Container), First'Result) = 1);\n-\n-   function First_Element (Container : List) return Element_Type with\n-     Global => null,\n-     Pre    => not Is_Empty (Container),\n-     Post   => First_Element'Result = M.Get (Model (Container), 1);\n-\n-   function Last (Container : List) return Cursor with\n-     Global         => null,\n-     Contract_Cases =>\n-       (Length (Container) = 0 =>\n-          Last'Result = No_Element,\n-\n-        others =>\n-          Has_Element (Container, Last'Result)\n-            and P.Get (Positions (Container), Last'Result) =\n-                  Length (Container));\n-\n-   function Last_Element (Container : List) return Element_Type with\n-     Global => null,\n-     Pre    => not Is_Empty (Container),\n-     Post   =>\n-       Last_Element'Result = M.Get (Model (Container), Length (Container));\n-\n-   function Next (Container : List; Position : Cursor) return Cursor with\n-     Global         => null,\n-     Pre            =>\n-       Has_Element (Container, Position) or else Position = No_Element,\n-     Contract_Cases =>\n-       (Position = No_Element\n-          or else P.Get (Positions (Container), Position) = Length (Container)\n-        =>\n-          Next'Result = No_Element,\n-\n-        others =>\n-          Has_Element (Container, Next'Result)\n-            and then P.Get (Positions (Container), Next'Result) =\n-                     P.Get (Positions (Container), Position) + 1);\n-\n-   procedure Next (Container : List; Position : in out Cursor) with\n-     Global         => null,\n-     Pre            =>\n-       Has_Element (Container, Position) or else Position = No_Element,\n-     Contract_Cases =>\n-       (Position = No_Element\n-          or else P.Get (Positions (Container), Position) = Length (Container)\n-        =>\n-          Position = No_Element,\n-\n-        others =>\n-          Has_Element (Container, Position)\n-            and then P.Get (Positions (Container), Position) =\n-                     P.Get (Positions (Container), Position'Old) + 1);\n-\n-   function Previous (Container : List; Position : Cursor) return Cursor with\n-     Global         => null,\n-     Pre            =>\n-       Has_Element (Container, Position) or else Position = No_Element,\n-     Contract_Cases =>\n-       (Position = No_Element\n-          or else P.Get (Positions (Container), Position) = 1\n-        =>\n-          Previous'Result = No_Element,\n-\n-        others =>\n-          Has_Element (Container, Previous'Result)\n-            and then P.Get (Positions (Container), Previous'Result) =\n-                     P.Get (Positions (Container), Position) - 1);\n-\n-   procedure Previous (Container : List; Position : in out Cursor) with\n-     Global         => null,\n-     Pre            =>\n-       Has_Element (Container, Position) or else Position = No_Element,\n-     Contract_Cases =>\n-       (Position = No_Element\n-          or else P.Get (Positions (Container), Position) = 1\n-         =>\n-          Position = No_Element,\n-\n-        others =>\n-          Has_Element (Container, Position)\n-            and then P.Get (Positions (Container), Position) =\n-                     P.Get (Positions (Container), Position'Old) - 1);\n-\n-   function Find\n-     (Container : List;\n-      Item      : Element_Type;\n-      Position  : Cursor := No_Element) return Cursor\n-   with\n-     Global         => null,\n-     Pre            =>\n-       Has_Element (Container, Position) or else Position = No_Element,\n-     Contract_Cases =>\n-\n-       --  If Item is not contained in Container after Position, Find returns\n-       --  No_Element.\n-\n-       (not M.Contains\n-              (Container => Model (Container),\n-               Fst       =>\n-                 (if Position = No_Element then\n-                     1\n-                  else\n-                     P.Get (Positions (Container), Position)),\n-               Lst       => Length (Container),\n-               Item      => Item)\n-        =>\n-          Find'Result = No_Element,\n-\n-        --  Otherwise, Find returns a valid cursor in Container\n-\n-        others =>\n-          P.Has_Key (Positions (Container), Find'Result)\n-\n-            --  The element designated by the result of Find is Item\n-\n-            and Element\n-                  (Model (Container),\n-                   P.Get (Positions (Container), Find'Result)) = Item\n-\n-            --  The result of Find is located after Position\n-\n-            and (if Position /= No_Element then\n-                    P.Get (Positions (Container), Find'Result) >=\n-                    P.Get (Positions (Container), Position))\n-\n-            --  It is the first occurrence of Item in this slice\n-\n-            and not M.Contains\n-                      (Container => Model (Container),\n-                       Fst       =>\n-                         (if Position = No_Element then\n-                             1\n-                          else\n-                             P.Get (Positions (Container), Position)),\n-                       Lst       =>\n-                         P.Get (Positions (Container), Find'Result) - 1,\n-                       Item      => Item));\n-\n-   function Reverse_Find\n-     (Container : List;\n-      Item      : Element_Type;\n-      Position  : Cursor := No_Element) return Cursor\n-   with\n-     Global         => null,\n-     Pre            =>\n-       Has_Element (Container, Position) or else Position = No_Element,\n-     Contract_Cases =>\n-\n-       --  If Item is not contained in Container before Position, Find returns\n-       --  No_Element.\n-\n-       (not M.Contains\n-              (Container => Model (Container),\n-               Fst       => 1,\n-               Lst       =>\n-                 (if Position = No_Element then\n-                     Length (Container)\n-                  else\n-                     P.Get (Positions (Container), Position)),\n-               Item      => Item)\n-        =>\n-          Reverse_Find'Result = No_Element,\n-\n-        --  Otherwise, Find returns a valid cursor in Container\n-\n-        others =>\n-          P.Has_Key (Positions (Container), Reverse_Find'Result)\n-\n-            --  The element designated by the result of Find is Item\n-\n-            and Element\n-                  (Model (Container),\n-                   P.Get (Positions (Container), Reverse_Find'Result)) = Item\n-\n-            --  The result of Find is located before Position\n-\n-            and (if Position /= No_Element then\n-                    P.Get (Positions (Container), Reverse_Find'Result) <=\n-                    P.Get (Positions (Container), Position))\n-\n-            --  It is the last occurrence of Item in this slice\n-\n-            and not M.Contains\n-                      (Container => Model (Container),\n-                       Fst       =>\n-                         P.Get (Positions (Container),\n-                                Reverse_Find'Result) + 1,\n-                       Lst       =>\n-                         (if Position = No_Element then\n-                             Length (Container)\n-                          else\n-                             P.Get (Positions (Container), Position)),\n-                       Item      => Item));\n-\n-   function Contains\n-     (Container : List;\n-      Item      : Element_Type) return Boolean\n-   with\n-     Global => null,\n-     Post   =>\n-       Contains'Result = M.Contains (Container => Model (Container),\n-                                     Fst       => 1,\n-                                     Lst       => Length (Container),\n-                                     Item      => Item);\n-\n-   function Has_Element\n-     (Container : List;\n-      Position  : Cursor) return Boolean\n-   with\n-     Global => null,\n-     Post   =>\n-       Has_Element'Result = P.Has_Key (Positions (Container), Position);\n-   pragma Annotate (GNATprove, Inline_For_Proof, Has_Element);\n-\n-   generic\n-      with function \"<\" (Left, Right : Element_Type) return Boolean is <>;\n-\n-   package Generic_Sorting with SPARK_Mode is\n-\n-      package Formal_Model with Ghost is\n-         function M_Elements_Sorted (Container : M.Sequence) return Boolean\n-         with\n-           Global => null,\n-           Post   =>\n-             M_Elements_Sorted'Result =\n-               (for all I in 1 .. M.Length (Container) =>\n-                 (for all J in I .. M.Length (Container) =>\n-                   not (Element (Container, J) < Element (Container, I))));\n-         pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_Sorted);\n-\n-      end Formal_Model;\n-      use Formal_Model;\n-\n-      function Is_Sorted (Container : List) return Boolean with\n-        Global => null,\n-        Post   => Is_Sorted'Result = M_Elements_Sorted (Model (Container));\n-\n-      procedure Sort (Container : in out List) with\n-        Global => null,\n-        Post   =>\n-          Length (Container) = Length (Container)'Old\n-            and M_Elements_Sorted (Model (Container))\n-            and M_Elements_Included\n-                  (Left  => Model (Container)'Old,\n-                   L_Lst => Length (Container),\n-                   Right => Model (Container),\n-                   R_Lst => Length (Container))\n-            and M_Elements_Included\n-                  (Left  => Model (Container),\n-                   L_Lst => Length (Container),\n-                   Right => Model (Container)'Old,\n-                   R_Lst => Length (Container));\n-\n-      procedure Merge (Target : in out List; Source : in out List) with\n-      --  Target and Source should not be aliased\n-        Global => null,\n-        Pre    => Length (Source) <= Target.Capacity - Length (Target),\n-        Post   =>\n-          Length (Target) = Length (Target)'Old + Length (Source)'Old\n-            and Length (Source) = 0\n-            and (if M_Elements_Sorted (Model (Target)'Old)\n-                   and M_Elements_Sorted (Model (Source)'Old)\n-                 then\n-                    M_Elements_Sorted (Model (Target)))\n-            and M_Elements_Included\n-                  (Left  => Model (Target)'Old,\n-                   L_Lst => Length (Target)'Old,\n-                   Right => Model (Target),\n-                   R_Lst => Length (Target))\n-            and M_Elements_Included\n-                  (Left  => Model (Source)'Old,\n-                   L_Lst => Length (Source)'Old,\n-                   Right => Model (Target),\n-                   R_Lst => Length (Target))\n-            and M_Elements_In_Union\n-                  (Model (Target),\n-                   Model (Source)'Old,\n-                   Model (Target)'Old);\n-   end Generic_Sorting;\n-\n-private\n-   pragma SPARK_Mode (Off);\n-\n-   type Node_Type is record\n-      Prev    : Count_Type'Base := -1;\n-      Next    : Count_Type;\n-      Element : aliased Element_Type;\n-   end record;\n-\n-   function \"=\" (L, R : Node_Type) return Boolean is abstract;\n-\n-   type Node_Array is array (Count_Type range <>) of Node_Type;\n-   function \"=\" (L, R : Node_Array) return Boolean is abstract;\n-\n-   type List (Capacity : Count_Type) is record\n-      Free   : Count_Type'Base := -1;\n-      Length : Count_Type := 0;\n-      First  : Count_Type := 0;\n-      Last   : Count_Type := 0;\n-      Nodes  : Node_Array (1 .. Capacity);\n-   end record;\n+package Ada.Containers.Formal_Doubly_Linked_Lists with SPARK_Mode is\n \n-   Empty_List : constant List := (0, others => <>);\n+   pragma Compile_Time_Error\n+     (True,\n+      \"This package has been moved to the SPARK library shipped with any\"\n+      & \" SPARK release starting with version 23.\");\n \n end Ada.Containers.Formal_Doubly_Linked_Lists;"}, {"sha": "bdf2c61d61e4ea08117ec7c855d2bf8aba1cd093", "filename": "gcc/ada/libgnat/a-cfhama.adb", "status": "removed", "additions": 0, "deletions": 976, "changes": 976, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6da3cab7b0acf5dc363c85069bef716923ddf90c/gcc%2Fada%2Flibgnat%2Fa-cfhama.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6da3cab7b0acf5dc363c85069bef716923ddf90c/gcc%2Fada%2Flibgnat%2Fa-cfhama.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cfhama.adb?ref=6da3cab7b0acf5dc363c85069bef716923ddf90c", "patch": "@@ -1,976 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT LIBRARY COMPONENTS                          --\n---                                                                          --\n---    A D A . C O N T A I N E R S . F O R M A L _ H A S H E D _ M A P S     --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 2010-2022, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n-------------------------------------------------------------------------------\n-\n-with Ada.Containers.Hash_Tables.Generic_Formal_Operations;\n-pragma Elaborate_All (Ada.Containers.Hash_Tables.Generic_Formal_Operations);\n-\n-with Ada.Containers.Hash_Tables.Generic_Formal_Keys;\n-pragma Elaborate_All (Ada.Containers.Hash_Tables.Generic_Formal_Keys);\n-\n-with Ada.Containers.Prime_Numbers; use Ada.Containers.Prime_Numbers;\n-\n-with Ada.Numerics.Big_Numbers.Big_Integers;\n-use Ada.Numerics.Big_Numbers.Big_Integers;\n-\n-with System; use type System.Address;\n-\n-package body Ada.Containers.Formal_Hashed_Maps with\n-  SPARK_Mode => Off\n-is\n-   -----------------------\n-   -- Local Subprograms --\n-   -----------------------\n-\n-   --  All local subprograms require comments ???\n-\n-   function Equivalent_Keys\n-     (Key  : Key_Type;\n-      Node : Node_Type) return Boolean;\n-   pragma Inline (Equivalent_Keys);\n-\n-   procedure Free\n-     (HT : in out Map;\n-      X  : Count_Type);\n-\n-   generic\n-      with procedure Set_Element (Node : in out Node_Type);\n-   procedure Generic_Allocate\n-     (HT   : in out HT_Types.Hash_Table_Type;\n-      Node : out Count_Type);\n-\n-   function Hash_Node (Node : Node_Type) return Hash_Type;\n-   pragma Inline (Hash_Node);\n-\n-   function Next (Node : Node_Type) return Count_Type;\n-   pragma Inline (Next);\n-\n-   procedure Set_Next (Node : in out Node_Type; Next : Count_Type);\n-   pragma Inline (Set_Next);\n-\n-   function Vet (Container : Map; Position : Cursor) return Boolean\n-     with Inline;\n-\n-   --  Convert Count_Type to Big_Interger\n-\n-   package Conversions is new Signed_Conversions (Int => Count_Type);\n-\n-   function Big (J : Count_Type) return Big_Integer renames\n-     Conversions.To_Big_Integer;\n-\n-   --------------------------\n-   -- Local Instantiations --\n-   --------------------------\n-\n-   package HT_Ops is\n-     new Hash_Tables.Generic_Formal_Operations\n-       (HT_Types  => HT_Types,\n-        Hash_Node => Hash_Node,\n-        Next      => Next,\n-        Set_Next  => Set_Next);\n-\n-   package Key_Ops is\n-     new Hash_Tables.Generic_Formal_Keys\n-       (HT_Types        => HT_Types,\n-        Next            => Next,\n-        Set_Next        => Set_Next,\n-        Key_Type        => Key_Type,\n-        Hash            => Hash,\n-        Equivalent_Keys => Equivalent_Keys);\n-\n-   ---------\n-   -- \"=\" --\n-   ---------\n-\n-   function \"=\" (Left, Right : Map) return Boolean is\n-   begin\n-      if Length (Left) /= Length (Right) then\n-         return False;\n-      end if;\n-\n-      if Length (Left) = 0 then\n-         return True;\n-      end if;\n-\n-      declare\n-         Node  : Count_Type;\n-         ENode : Count_Type;\n-\n-      begin\n-         Node := First (Left).Node;\n-         while Node /= 0 loop\n-            ENode :=\n-              Find\n-                (Container => Right,\n-                 Key       => Left.Content.Nodes (Node).Key).Node;\n-\n-            if ENode = 0 or else\n-              Right.Content.Nodes (ENode).Element /=\n-              Left.Content.Nodes (Node).Element\n-            then\n-               return False;\n-            end if;\n-\n-            Node := HT_Ops.Next (Left.Content, Node);\n-         end loop;\n-\n-         return True;\n-      end;\n-   end \"=\";\n-\n-   ------------\n-   -- Assign --\n-   ------------\n-\n-   procedure Assign (Target : in out Map; Source : Map) is\n-      procedure Insert_Element (Source_Node : Count_Type);\n-      pragma Inline (Insert_Element);\n-\n-      procedure Insert_Elements is\n-        new HT_Ops.Generic_Iteration (Insert_Element);\n-\n-      --------------------\n-      -- Insert_Element --\n-      --------------------\n-\n-      procedure Insert_Element (Source_Node : Count_Type) is\n-         N : Node_Type renames Source.Content.Nodes (Source_Node);\n-      begin\n-         Insert (Target, N.Key, N.Element);\n-      end Insert_Element;\n-\n-   --  Start of processing for Assign\n-\n-   begin\n-      if Target.Capacity < Length (Source) then\n-         raise Constraint_Error with  -- correct exception ???\n-           \"Source length exceeds Target capacity\";\n-      end if;\n-\n-      Clear (Target);\n-\n-      Insert_Elements (Source.Content);\n-   end Assign;\n-\n-   --------------\n-   -- Capacity --\n-   --------------\n-\n-   function Capacity (Container : Map) return Count_Type is\n-   begin\n-      return Container.Content.Nodes'Length;\n-   end Capacity;\n-\n-   -----------\n-   -- Clear --\n-   -----------\n-\n-   procedure Clear (Container : in out Map) is\n-   begin\n-      HT_Ops.Clear (Container.Content);\n-   end Clear;\n-\n-   ------------------------\n-   -- Constant_Reference --\n-   ------------------------\n-\n-   function Constant_Reference\n-     (Container : aliased Map;\n-      Position  : Cursor) return not null access constant Element_Type\n-   is\n-   begin\n-      if not Has_Element (Container, Position) then\n-         raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      pragma Assert\n-        (Vet (Container, Position),\n-         \"bad cursor in function Constant_Reference\");\n-\n-      return Container.Content.Nodes (Position.Node).Element'Access;\n-   end Constant_Reference;\n-\n-   function Constant_Reference\n-     (Container : aliased Map;\n-      Key       : Key_Type) return not null access constant Element_Type\n-   is\n-      Node : constant Count_Type := Find (Container, Key).Node;\n-\n-   begin\n-      if Node = 0 then\n-         raise Constraint_Error with\n-           \"no element available because key not in map\";\n-      end if;\n-\n-      return Container.Content.Nodes (Node).Element'Access;\n-   end Constant_Reference;\n-\n-   --------------\n-   -- Contains --\n-   --------------\n-\n-   function Contains (Container : Map; Key : Key_Type) return Boolean is\n-   begin\n-      return Find (Container, Key) /= No_Element;\n-   end Contains;\n-\n-   ----------\n-   -- Copy --\n-   ----------\n-\n-   function Copy\n-     (Source   : Map;\n-      Capacity : Count_Type := 0) return Map\n-   is\n-      C      : constant Count_Type :=\n-                 Count_Type'Max (Capacity, Source.Capacity);\n-      Cu     : Cursor;\n-      H      : Hash_Type;\n-      N      : Count_Type;\n-      Target : Map (C, Source.Modulus);\n-\n-   begin\n-      if 0 < Capacity and then Capacity < Source.Capacity then\n-         raise Capacity_Error;\n-      end if;\n-\n-      Target.Content.Length := Source.Content.Length;\n-      Target.Content.Free := Source.Content.Free;\n-\n-      H := 1;\n-      while H <= Source.Modulus loop\n-         Target.Content.Buckets (H) := Source.Content.Buckets (H);\n-         H := H + 1;\n-      end loop;\n-\n-      N := 1;\n-      while N <= Source.Capacity loop\n-         Target.Content.Nodes (N) := Source.Content.Nodes (N);\n-         N := N + 1;\n-      end loop;\n-\n-      while N <= C loop\n-         Cu := (Node => N);\n-         Free (Target, Cu.Node);\n-         N := N + 1;\n-      end loop;\n-\n-      return Target;\n-   end Copy;\n-\n-   ---------------------\n-   -- Default_Modulus --\n-   ---------------------\n-\n-   function Default_Modulus (Capacity : Count_Type) return Hash_Type is\n-   begin\n-      return To_Prime (Capacity);\n-   end Default_Modulus;\n-\n-   ------------\n-   -- Delete --\n-   ------------\n-\n-   procedure Delete (Container : in out Map; Key : Key_Type) is\n-      X : Count_Type;\n-\n-   begin\n-      Key_Ops.Delete_Key_Sans_Free (Container.Content, Key, X);\n-\n-      if X = 0 then\n-         raise Constraint_Error with \"attempt to delete key not in map\";\n-      end if;\n-\n-      Free (Container, X);\n-   end Delete;\n-\n-   procedure Delete (Container : in out Map; Position : in out Cursor) is\n-   begin\n-      if not Has_Element (Container, Position) then\n-         raise Constraint_Error with\n-           \"Position cursor of Delete has no element\";\n-      end if;\n-\n-      pragma Assert (Vet (Container, Position), \"bad cursor in Delete\");\n-\n-      HT_Ops.Delete_Node_Sans_Free (Container.Content, Position.Node);\n-\n-      Free (Container, Position.Node);\n-      Position := No_Element;\n-   end Delete;\n-\n-   -------------\n-   -- Element --\n-   -------------\n-\n-   function Element (Container : Map; Key : Key_Type) return Element_Type is\n-      Node : constant Count_Type := Find (Container, Key).Node;\n-\n-   begin\n-      if Node = 0 then\n-         raise Constraint_Error with\n-           \"no element available because key not in map\";\n-      end if;\n-\n-      return Container.Content.Nodes (Node).Element;\n-   end Element;\n-\n-   function Element (Container : Map; Position : Cursor) return Element_Type is\n-   begin\n-      if not Has_Element (Container, Position) then\n-         raise Constraint_Error with \"Position cursor equals No_Element\";\n-      end if;\n-\n-      pragma Assert\n-        (Vet (Container, Position), \"bad cursor in function Element\");\n-\n-      return Container.Content.Nodes (Position.Node).Element;\n-   end Element;\n-\n-   ---------------------\n-   -- Equivalent_Keys --\n-   ---------------------\n-\n-   function Equivalent_Keys\n-     (Key  : Key_Type;\n-      Node : Node_Type) return Boolean\n-   is\n-   begin\n-      return Equivalent_Keys (Key, Node.Key);\n-   end Equivalent_Keys;\n-\n-   -------------\n-   -- Exclude --\n-   -------------\n-\n-   procedure Exclude (Container : in out Map; Key : Key_Type) is\n-      X : Count_Type;\n-   begin\n-      Key_Ops.Delete_Key_Sans_Free (Container.Content, Key, X);\n-      Free (Container, X);\n-   end Exclude;\n-\n-   ----------\n-   -- Find --\n-   ----------\n-\n-   function Find (Container : Map; Key : Key_Type) return Cursor is\n-      Node : constant Count_Type := Key_Ops.Find (Container.Content, Key);\n-\n-   begin\n-      if Node = 0 then\n-         return No_Element;\n-      end if;\n-\n-      return (Node => Node);\n-   end Find;\n-\n-   -----------\n-   -- First --\n-   -----------\n-\n-   function First (Container : Map) return Cursor is\n-      Node : constant Count_Type := HT_Ops.First (Container.Content);\n-\n-   begin\n-      if Node = 0 then\n-         return No_Element;\n-      end if;\n-\n-      return (Node => Node);\n-   end First;\n-\n-   ------------------\n-   -- Formal_Model --\n-   ------------------\n-\n-   package body Formal_Model is\n-\n-      ----------\n-      -- Find --\n-      ----------\n-\n-      function Find\n-        (Container : K.Sequence;\n-         Key       : Key_Type) return Count_Type\n-      is\n-      begin\n-         for I in 1 .. K.Length (Container) loop\n-            if Equivalent_Keys (Key, K.Get (Container, I)) then\n-               return I;\n-            end if;\n-         end loop;\n-         return 0;\n-      end Find;\n-\n-      ---------------------\n-      -- K_Keys_Included --\n-      ---------------------\n-\n-      function K_Keys_Included\n-        (Left  : K.Sequence;\n-         Right : K.Sequence) return Boolean\n-      is\n-      begin\n-         for I in 1 .. K.Length (Left) loop\n-            if not K.Contains (Right, 1, K.Length (Right), K.Get (Left, I))\n-            then\n-               return False;\n-            end if;\n-         end loop;\n-\n-         return True;\n-      end K_Keys_Included;\n-\n-      ----------\n-      -- Keys --\n-      ----------\n-\n-      function Keys (Container : Map) return K.Sequence is\n-         Position : Count_Type := HT_Ops.First (Container.Content);\n-         R        : K.Sequence;\n-\n-      begin\n-         --  Can't use First, Next or Element here, since they depend on models\n-         --  for their postconditions.\n-\n-         while Position /= 0 loop\n-            R := K.Add (R, Container.Content.Nodes (Position).Key);\n-            Position := HT_Ops.Next (Container.Content, Position);\n-         end loop;\n-\n-         return R;\n-      end Keys;\n-\n-      ----------------------------\n-      -- Lift_Abstraction_Level --\n-      ----------------------------\n-\n-      procedure Lift_Abstraction_Level (Container : Map) is null;\n-\n-      -----------------------\n-      -- Mapping_Preserved --\n-      -----------------------\n-\n-      function Mapping_Preserved\n-        (K_Left  : K.Sequence;\n-         K_Right : K.Sequence;\n-         P_Left  : P.Map;\n-         P_Right : P.Map) return Boolean\n-      is\n-      begin\n-         for C of P_Left loop\n-            if not P.Has_Key (P_Right, C)\n-              or else P.Get (P_Left,  C) > K.Length (K_Left)\n-              or else P.Get (P_Right, C) > K.Length (K_Right)\n-              or else K.Get (K_Left,  P.Get (P_Left,  C)) /=\n-                      K.Get (K_Right, P.Get (P_Right, C))\n-            then\n-               return False;\n-            end if;\n-         end loop;\n-\n-         return True;\n-      end Mapping_Preserved;\n-\n-      -----------\n-      -- Model --\n-      -----------\n-\n-      function Model (Container : Map) return M.Map is\n-         Position : Count_Type := HT_Ops.First (Container.Content);\n-         R        : M.Map;\n-\n-      begin\n-         --  Can't use First, Next or Element here, since they depend on models\n-         --  for their postconditions.\n-\n-         while Position /= 0 loop\n-            R :=\n-              M.Add\n-                (Container => R,\n-                 New_Key   => Container.Content.Nodes (Position).Key,\n-                 New_Item  => Container.Content.Nodes (Position).Element);\n-\n-            Position := HT_Ops.Next (Container.Content, Position);\n-         end loop;\n-\n-         return R;\n-      end Model;\n-\n-      ---------------\n-      -- Positions --\n-      ---------------\n-\n-      function Positions (Container : Map) return P.Map is\n-         I        : Count_Type := 1;\n-         Position : Count_Type := HT_Ops.First (Container.Content);\n-         R        : P.Map;\n-\n-      begin\n-         --  Can't use First, Next or Element here, since they depend on models\n-         --  for their postconditions.\n-\n-         while Position /= 0 loop\n-            R := P.Add (R, (Node => Position), I);\n-            pragma Assert (P.Length (R) = Big (I));\n-            Position := HT_Ops.Next (Container.Content, Position);\n-            I := I + 1;\n-         end loop;\n-\n-         return R;\n-      end Positions;\n-\n-   end Formal_Model;\n-\n-   ----------\n-   -- Free --\n-   ----------\n-\n-   procedure Free (HT : in out Map; X : Count_Type) is\n-   begin\n-      if X /= 0 then\n-         pragma Assert (X <= HT.Capacity);\n-         HT.Content.Nodes (X).Has_Element := False;\n-         HT_Ops.Free (HT.Content, X);\n-      end if;\n-   end Free;\n-\n-   ----------------------\n-   -- Generic_Allocate --\n-   ----------------------\n-\n-   procedure Generic_Allocate\n-     (HT   : in out HT_Types.Hash_Table_Type;\n-      Node : out Count_Type)\n-   is\n-      procedure Allocate is\n-        new HT_Ops.Generic_Allocate (Set_Element);\n-\n-   begin\n-      Allocate (HT, Node);\n-      HT.Nodes (Node).Has_Element := True;\n-   end Generic_Allocate;\n-\n-   -----------------\n-   -- Has_Element --\n-   -----------------\n-\n-   function Has_Element (Container : Map; Position : Cursor) return Boolean is\n-   begin\n-      if Position.Node = 0\n-        or else not Container.Content.Nodes (Position.Node).Has_Element\n-      then\n-         return False;\n-      else\n-         return True;\n-      end if;\n-   end Has_Element;\n-\n-   ---------------\n-   -- Hash_Node --\n-   ---------------\n-\n-   function Hash_Node (Node : Node_Type) return Hash_Type is\n-   begin\n-      return Hash (Node.Key);\n-   end Hash_Node;\n-\n-   -------------\n-   -- Include --\n-   -------------\n-\n-   procedure Include\n-     (Container : in out Map;\n-      Key       : Key_Type;\n-      New_Item  : Element_Type)\n-   is\n-      Position : Cursor;\n-      Inserted : Boolean;\n-\n-   begin\n-      Insert (Container, Key, New_Item, Position, Inserted);\n-\n-      if not Inserted then\n-         declare\n-            P : constant Count_Type := Position.Node;\n-            N : Node_Type renames Container.Content.Nodes (P);\n-         begin\n-            N.Key := Key;\n-            N.Element := New_Item;\n-         end;\n-      end if;\n-   end Include;\n-\n-   ------------\n-   -- Insert --\n-   ------------\n-\n-   procedure Insert\n-     (Container : in out Map;\n-      Key       : Key_Type;\n-      New_Item  : Element_Type;\n-      Position  : out Cursor;\n-      Inserted  : out Boolean)\n-   is\n-      procedure Assign_Key (Node : in out Node_Type);\n-      pragma Inline (Assign_Key);\n-\n-      procedure New_Node\n-        (HT   : in out HT_Types.Hash_Table_Type;\n-         Node : out Count_Type);\n-      pragma Inline (New_Node);\n-\n-      procedure Local_Insert is\n-        new Key_Ops.Generic_Conditional_Insert (New_Node);\n-\n-      procedure Allocate is\n-        new Generic_Allocate (Assign_Key);\n-\n-      -----------------\n-      --  Assign_Key --\n-      -----------------\n-\n-      procedure Assign_Key (Node : in out Node_Type) is\n-      begin\n-         Node.Key := Key;\n-         Node.Element := New_Item;\n-      end Assign_Key;\n-\n-      --------------\n-      -- New_Node --\n-      --------------\n-\n-      procedure New_Node\n-        (HT   : in out HT_Types.Hash_Table_Type;\n-         Node : out Count_Type)\n-      is\n-      begin\n-         Allocate (HT, Node);\n-      end New_Node;\n-\n-   --  Start of processing for Insert\n-\n-   begin\n-      Local_Insert (Container.Content, Key, Position.Node, Inserted);\n-   end Insert;\n-\n-   procedure Insert\n-     (Container : in out Map;\n-      Key       : Key_Type;\n-      New_Item  : Element_Type)\n-   is\n-      Unused_Position : Cursor;\n-      Inserted        : Boolean;\n-\n-   begin\n-      Insert (Container, Key, New_Item, Unused_Position, Inserted);\n-\n-      if not Inserted then\n-         raise Constraint_Error with \"attempt to insert key already in map\";\n-      end if;\n-   end Insert;\n-\n-   --------------\n-   -- Is_Empty --\n-   --------------\n-\n-   function Is_Empty (Container : Map) return Boolean is\n-   begin\n-      return Length (Container) = 0;\n-   end Is_Empty;\n-\n-   ---------\n-   -- Key --\n-   ---------\n-\n-   function Key (Container : Map; Position : Cursor) return Key_Type is\n-   begin\n-      if not Has_Element (Container, Position) then\n-         raise Constraint_Error with\n-           \"Position cursor of function Key has no element\";\n-      end if;\n-\n-      pragma Assert (Vet (Container, Position), \"bad cursor in function Key\");\n-\n-      return Container.Content.Nodes (Position.Node).Key;\n-   end Key;\n-\n-   ------------\n-   -- Length --\n-   ------------\n-\n-   function Length (Container : Map) return Count_Type is\n-   begin\n-      return Container.Content.Length;\n-   end Length;\n-\n-   ----------\n-   -- Move --\n-   ----------\n-\n-   procedure Move\n-     (Target : in out Map;\n-      Source : in out Map)\n-   is\n-      NN : HT_Types.Nodes_Type renames Source.Content.Nodes;\n-      X  : Count_Type;\n-      Y  : Count_Type;\n-\n-   begin\n-      if Target.Capacity < Length (Source) then\n-         raise Constraint_Error with  -- ???\n-           \"Source length exceeds Target capacity\";\n-      end if;\n-\n-      Clear (Target);\n-\n-      if Source.Content.Length = 0 then\n-         return;\n-      end if;\n-\n-      X := HT_Ops.First (Source.Content);\n-      while X /= 0 loop\n-         Insert (Target, NN (X).Key, NN (X).Element);  -- optimize???\n-\n-         Y := HT_Ops.Next (Source.Content, X);\n-\n-         HT_Ops.Delete_Node_Sans_Free (Source.Content, X);\n-         Free (Source, X);\n-\n-         X := Y;\n-      end loop;\n-   end Move;\n-\n-   ----------\n-   -- Next --\n-   ----------\n-\n-   function Next (Node : Node_Type) return Count_Type is\n-   begin\n-      return Node.Next;\n-   end Next;\n-\n-   function Next (Container : Map; Position : Cursor) return Cursor is\n-   begin\n-      if Position.Node = 0 then\n-         return No_Element;\n-      end if;\n-\n-      if not Has_Element (Container, Position) then\n-         raise Constraint_Error with \"Position has no element\";\n-      end if;\n-\n-      pragma Assert (Vet (Container, Position), \"bad cursor in function Next\");\n-\n-      declare\n-         Node : constant Count_Type :=\n-           HT_Ops.Next (Container.Content, Position.Node);\n-\n-      begin\n-         if Node = 0 then\n-            return No_Element;\n-         end if;\n-\n-         return (Node => Node);\n-      end;\n-   end Next;\n-\n-   procedure Next (Container : Map; Position : in out Cursor) is\n-   begin\n-      Position := Next (Container, Position);\n-   end Next;\n-\n-   ---------------\n-   -- Reference --\n-   ---------------\n-\n-   function Reference\n-     (Container : not null access Map;\n-      Position  : Cursor) return not null access Element_Type\n-   is\n-   begin\n-      if not Has_Element (Container.all, Position) then\n-         raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      pragma Assert\n-        (Vet (Container.all, Position), \"bad cursor in function Reference\");\n-\n-      return Container.Content.Nodes (Position.Node).Element'Access;\n-   end Reference;\n-\n-   function Reference\n-     (Container : not null access Map;\n-      Key       : Key_Type) return not null access Element_Type\n-   is\n-      Node : constant Count_Type := Find (Container.all, Key).Node;\n-\n-   begin\n-      if Node = 0 then\n-         raise Constraint_Error with\n-           \"no element available because key not in map\";\n-      end if;\n-\n-      return Container.Content.Nodes (Node).Element'Access;\n-   end Reference;\n-\n-   -------------\n-   -- Replace --\n-   -------------\n-\n-   procedure Replace\n-     (Container : in out Map;\n-      Key       : Key_Type;\n-      New_Item  : Element_Type)\n-   is\n-      Node : constant Count_Type := Key_Ops.Find (Container.Content, Key);\n-\n-   begin\n-      if Node = 0 then\n-         raise Constraint_Error with \"attempt to replace key not in map\";\n-      end if;\n-\n-      declare\n-         N : Node_Type renames Container.Content.Nodes (Node);\n-      begin\n-         N.Key := Key;\n-         N.Element := New_Item;\n-      end;\n-   end Replace;\n-\n-   ---------------------\n-   -- Replace_Element --\n-   ---------------------\n-\n-   procedure Replace_Element\n-     (Container : in out Map;\n-      Position  : Cursor;\n-      New_Item  : Element_Type)\n-   is\n-   begin\n-      if not Has_Element (Container, Position) then\n-         raise Constraint_Error with\n-           \"Position cursor of Replace_Element has no element\";\n-      end if;\n-\n-      pragma Assert\n-        (Vet (Container, Position), \"bad cursor in Replace_Element\");\n-\n-      Container.Content.Nodes (Position.Node).Element := New_Item;\n-   end Replace_Element;\n-\n-   ----------------------\n-   -- Reserve_Capacity --\n-   ----------------------\n-\n-   procedure Reserve_Capacity\n-     (Container : in out Map;\n-      Capacity  : Count_Type)\n-   is\n-   begin\n-      if Capacity > Container.Capacity then\n-         raise Capacity_Error with \"requested capacity is too large\";\n-      end if;\n-   end Reserve_Capacity;\n-\n-   --------------\n-   -- Set_Next --\n-   --------------\n-\n-   procedure Set_Next (Node : in out Node_Type; Next : Count_Type) is\n-   begin\n-      Node.Next := Next;\n-   end Set_Next;\n-\n-   ---------\n-   -- Vet --\n-   ---------\n-\n-   function Vet (Container : Map; Position : Cursor) return Boolean is\n-   begin\n-      if not Container_Checks'Enabled then\n-         return True;\n-      end if;\n-\n-      if Position.Node = 0 then\n-         return True;\n-      end if;\n-\n-      declare\n-         X : Count_Type;\n-\n-      begin\n-         if Container.Content.Length = 0 then\n-            return False;\n-         end if;\n-\n-         if Container.Capacity = 0 then\n-            return False;\n-         end if;\n-\n-         if Container.Content.Buckets'Length = 0 then\n-            return False;\n-         end if;\n-\n-         if Position.Node > Container.Capacity then\n-            return False;\n-         end if;\n-\n-         if Container.Content.Nodes (Position.Node).Next = Position.Node then\n-            return False;\n-         end if;\n-\n-         X :=\n-           Container.Content.Buckets\n-             (Key_Ops.Index\n-                (Container.Content,\n-                 Container.Content.Nodes (Position.Node).Key));\n-\n-         for J in 1 .. Container.Content.Length loop\n-            if X = Position.Node then\n-               return True;\n-            end if;\n-\n-            if X = 0 then\n-               return False;\n-            end if;\n-\n-            if X = Container.Content.Nodes (X).Next then\n-\n-               --  Prevent unnecessary looping\n-\n-               return False;\n-            end if;\n-\n-            X := Container.Content.Nodes (X).Next;\n-         end loop;\n-\n-         return False;\n-      end;\n-   end Vet;\n-\n-end Ada.Containers.Formal_Hashed_Maps;"}, {"sha": "42c7fbd896b158bd43d65d3f8f6e41583c6ee2f6", "filename": "gcc/ada/libgnat/a-cfhama.ads", "status": "modified", "additions": 5, "deletions": 878, "changes": 883, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fa-cfhama.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fa-cfhama.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cfhama.ads?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -29,885 +29,12 @@\n -- <http://www.gnu.org/licenses/>.                                          --\n ------------------------------------------------------------------------------\n \n---  This spec is derived from package Ada.Containers.Bounded_Hashed_Maps in the\n---  Ada 2012 RM. The modifications are meant to facilitate formal proofs by\n---  making it easier to express properties, and by making the specification of\n---  this unit compatible with SPARK 2014. Note that the API of this unit may be\n---  subject to incompatible changes as SPARK 2014 evolves.\n-\n---  The modifications are:\n-\n---    A parameter for the container is added to every function reading the\n---    contents of a container: Key, Element, Next, Query_Element, Has_Element,\n---    Iterate, Equivalent_Keys. This change is motivated by the need to have\n---    cursors which are valid on different containers (typically a container C\n---    and its previous version C'Old) for expressing properties, which is not\n---    possible if cursors encapsulate an access to the underlying container.\n-\n---  Iteration over maps is done using the Iterable aspect, which is SPARK\n---  compatible. \"For of\" iteration ranges over keys instead of elements.\n-\n-with Ada.Containers.Functional_Vectors;\n-with Ada.Containers.Functional_Maps;\n-private with Ada.Containers.Hash_Tables;\n-\n generic\n-   type Key_Type is private;\n-   type Element_Type is private;\n-\n-   with function Hash (Key : Key_Type) return Hash_Type;\n-   with function Equivalent_Keys\n-     (Left  : Key_Type;\n-      Right : Key_Type) return Boolean is \"=\";\n-   with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n-\n-package Ada.Containers.Formal_Hashed_Maps with\n-  SPARK_Mode,\n-  Annotate => (GNATprove, Always_Return)\n-is\n-\n-   --  Contracts in this unit are meant for analysis only, not for run-time\n-   --  checking.\n-\n-   pragma Assertion_Policy (Pre => Ignore);\n-   pragma Assertion_Policy (Post => Ignore);\n-   pragma Assertion_Policy (Contract_Cases => Ignore);\n-   pragma Annotate (CodePeer, Skip_Analysis);\n-\n-   type Map (Capacity : Count_Type; Modulus : Hash_Type) is private with\n-     Iterable => (First       => First,\n-                  Next        => Next,\n-                  Has_Element => Has_Element,\n-                  Element     => Key),\n-     Default_Initial_Condition => Is_Empty (Map);\n-   pragma Preelaborable_Initialization (Map);\n-\n-   Empty_Map : constant Map;\n-\n-   type Cursor is record\n-      Node : Count_Type;\n-   end record;\n-\n-   No_Element : constant Cursor := (Node => 0);\n-\n-   function Length (Container : Map) return Count_Type with\n-     Global => null,\n-     Post   => Length'Result <= Container.Capacity;\n-\n-   pragma Unevaluated_Use_Of_Old (Allow);\n-\n-   package Formal_Model with Ghost is\n-      subtype Positive_Count_Type is Count_Type range 1 .. Count_Type'Last;\n-\n-      package M is new Ada.Containers.Functional_Maps\n-        (Element_Type    => Element_Type,\n-         Key_Type        => Key_Type,\n-         Equivalent_Keys => Equivalent_Keys);\n-\n-      function \"=\"\n-        (Left  : M.Map;\n-         Right : M.Map) return Boolean renames M.\"=\";\n-\n-      function \"<=\"\n-        (Left  : M.Map;\n-         Right : M.Map) return Boolean renames M.\"<=\";\n-\n-      package K is new Ada.Containers.Functional_Vectors\n-        (Element_Type => Key_Type,\n-         Index_Type   => Positive_Count_Type);\n-\n-      function \"=\"\n-        (Left  : K.Sequence;\n-         Right : K.Sequence) return Boolean renames K.\"=\";\n-\n-      function \"<\"\n-        (Left  : K.Sequence;\n-         Right : K.Sequence) return Boolean renames K.\"<\";\n-\n-      function \"<=\"\n-        (Left  : K.Sequence;\n-         Right : K.Sequence) return Boolean renames K.\"<=\";\n-\n-      function Find (Container : K.Sequence; Key : Key_Type) return Count_Type\n-      --  Search for Key in Container\n-\n-      with\n-        Global => null,\n-        Post =>\n-          (if Find'Result > 0 then\n-              Find'Result <= K.Length (Container)\n-                and Equivalent_Keys (Key, K.Get (Container, Find'Result)));\n-\n-      function K_Keys_Included\n-        (Left  : K.Sequence;\n-         Right : K.Sequence) return Boolean\n-      --  Return True if Right contains all the keys of Left\n-\n-      with\n-        Global => null,\n-        Post   =>\n-          K_Keys_Included'Result =\n-            (for all I in 1 .. K.Length (Left) =>\n-              Find (Right, K.Get (Left, I)) > 0\n-                and then K.Get (Right, Find (Right, K.Get (Left, I))) =\n-                         K.Get (Left, I));\n-\n-      package P is new Ada.Containers.Functional_Maps\n-        (Key_Type                       => Cursor,\n-         Element_Type                   => Positive_Count_Type,\n-         Equivalent_Keys                => \"=\",\n-         Enable_Handling_Of_Equivalence => False);\n-\n-      function \"=\"\n-        (Left  : P.Map;\n-         Right : P.Map) return Boolean renames P.\"=\";\n-\n-      function \"<=\"\n-        (Left  : P.Map;\n-         Right : P.Map) return Boolean renames P.\"<=\";\n-\n-      function Mapping_Preserved\n-        (K_Left  : K.Sequence;\n-         K_Right : K.Sequence;\n-         P_Left  : P.Map;\n-         P_Right : P.Map) return Boolean\n-      with\n-        Global => null,\n-        Post   =>\n-          (if Mapping_Preserved'Result then\n-\n-             --  Right contains all the cursors of Left\n-\n-             P.Keys_Included (P_Left, P_Right)\n-\n-               --  Right contains all the keys of Left\n-\n-               and K_Keys_Included (K_Left, K_Right)\n-\n-               --  Mappings from cursors to elements induced by K_Left, P_Left\n-               --  and K_Right, P_Right are the same.\n-\n-               and (for all C of P_Left =>\n-                     K.Get (K_Left, P.Get (P_Left, C)) =\n-                     K.Get (K_Right, P.Get (P_Right, C))));\n-\n-      function Model (Container : Map) return M.Map with\n-      --  The high-level model of a map is a map from keys to elements. Neither\n-      --  cursors nor order of elements are represented in this model. Keys are\n-      --  modeled up to equivalence.\n-\n-        Ghost,\n-        Global => null;\n-\n-      function Keys (Container : Map) return K.Sequence with\n-      --  The Keys sequence represents the underlying list structure of maps\n-      --  that is used for iteration. It stores the actual values of keys in\n-      --  the map. It does not model cursors nor elements.\n-\n-        Ghost,\n-        Global => null,\n-        Post   =>\n-          K.Length (Keys'Result) = Length (Container)\n-\n-            --  It only contains keys contained in Model\n-\n-            and (for all Key of Keys'Result =>\n-                  M.Has_Key (Model (Container), Key))\n-\n-            --  It contains all the keys contained in Model\n-\n-            and (for all Key of Model (Container) =>\n-                  (Find (Keys'Result, Key) > 0\n-                    and then Equivalent_Keys\n-                               (K.Get (Keys'Result, Find (Keys'Result, Key)),\n-                                Key)))\n-\n-            --  It has no duplicate\n-\n-            and (for all I in 1 .. Length (Container) =>\n-                  Find (Keys'Result, K.Get (Keys'Result, I)) = I)\n-\n-            and (for all I in 1 .. Length (Container) =>\n-                  (for all J in 1 .. Length (Container) =>\n-                    (if Equivalent_Keys\n-                          (K.Get (Keys'Result, I), K.Get (Keys'Result, J))\n-                     then\n-                        I = J)));\n-      pragma Annotate (GNATprove, Iterable_For_Proof, \"Model\", Keys);\n-\n-      function Positions (Container : Map) return P.Map with\n-      --  The Positions map is used to model cursors. It only contains valid\n-      --  cursors and maps them to their position in the container.\n-\n-        Ghost,\n-        Global => null,\n-        Post   =>\n-          not P.Has_Key (Positions'Result, No_Element)\n-\n-            --  Positions of cursors are smaller than the container's length\n-\n-            and then\n-              (for all I of Positions'Result =>\n-                P.Get (Positions'Result, I) in 1 .. Length (Container)\n-\n-            --  No two cursors have the same position. Note that we do not\n-            --  state that there is a cursor in the map for each position, as\n-            --  it is rarely needed.\n-\n-            and then\n-              (for all J of Positions'Result =>\n-                (if P.Get (Positions'Result, I) = P.Get (Positions'Result, J)\n-                 then I = J)));\n-\n-      procedure Lift_Abstraction_Level (Container : Map) with\n-        --  Lift_Abstraction_Level is a ghost procedure that does nothing but\n-        --  assume that we can access the same elements by iterating over\n-        --  positions or cursors.\n-        --  This information is not generally useful except when switching from\n-        --  a low-level, cursor-aware view of a container, to a high-level,\n-        --  position-based view.\n-\n-        Ghost,\n-        Global => null,\n-        Post   =>\n-          (for all Key of Keys (Container) =>\n-            (for some I of Positions (Container) =>\n-              K.Get (Keys (Container), P.Get (Positions (Container), I)) =\n-                Key));\n-\n-      function Contains\n-        (C : M.Map;\n-         K : Key_Type) return Boolean renames M.Has_Key;\n-      --  To improve readability of contracts, we rename the function used to\n-      --  search for a key in the model to Contains.\n-\n-      function Element\n-        (C : M.Map;\n-         K : Key_Type) return Element_Type renames M.Get;\n-      --  To improve readability of contracts, we rename the function used to\n-      --  access an element in the model to Element.\n-\n-   end Formal_Model;\n-   use Formal_Model;\n-\n-   function \"=\" (Left, Right : Map) return Boolean with\n-     Global => null,\n-     Post   => \"=\"'Result = (Model (Left) = Model (Right));\n-\n-   function Capacity (Container : Map) return Count_Type with\n-     Global => null,\n-     Post   => Capacity'Result = Container.Capacity;\n-\n-   procedure Reserve_Capacity\n-     (Container : in out Map;\n-      Capacity  : Count_Type)\n-   with\n-     Global => null,\n-     Pre    => Capacity <= Container.Capacity,\n-     Post   =>\n-       Model (Container) = Model (Container)'Old\n-         and Length (Container)'Old = Length (Container)\n-\n-         --  Actual keys are preserved\n-\n-         and K_Keys_Included (Keys (Container), Keys (Container)'Old)\n-         and K_Keys_Included (Keys (Container)'Old, Keys (Container));\n-\n-   function Is_Empty (Container : Map) return Boolean with\n-     Global => null,\n-     Post   => Is_Empty'Result = (Length (Container) = 0);\n-\n-   procedure Clear (Container : in out Map) with\n-     Global => null,\n-     Post   => Length (Container) = 0 and M.Is_Empty (Model (Container));\n-\n-   procedure Assign (Target : in out Map; Source : Map) with\n-     Global => null,\n-     Pre    => Target.Capacity >= Length (Source),\n-     Post   =>\n-       Model (Target) = Model (Source)\n-         and Length (Source) = Length (Target)\n-\n-         --  Actual keys are preserved\n-\n-         and K_Keys_Included (Keys (Target), Keys (Source))\n-         and K_Keys_Included (Keys (Source), Keys (Target));\n-\n-   function Copy\n-     (Source   : Map;\n-      Capacity : Count_Type := 0) return Map\n-   with\n-     Global => null,\n-     Pre    => Capacity = 0 or else Capacity >= Source.Capacity,\n-     Post   =>\n-       Model (Copy'Result) = Model (Source)\n-         and Keys (Copy'Result) = Keys (Source)\n-         and Positions (Copy'Result) = Positions (Source)\n-         and (if Capacity = 0 then\n-                 Copy'Result.Capacity = Source.Capacity\n-              else\n-                 Copy'Result.Capacity = Capacity);\n-   --  Copy returns a container stricty equal to Source. It must have the same\n-   --  cursors associated with each element. Therefore:\n-   --  - capacity=0 means use Source.Capacity as capacity of target\n-   --  - the modulus cannot be changed.\n-\n-   function Key (Container : Map; Position : Cursor) return Key_Type with\n-     Global => null,\n-     Pre    => Has_Element (Container, Position),\n-     Post   =>\n-       Key'Result =\n-         K.Get (Keys (Container), P.Get (Positions (Container), Position));\n-   pragma Annotate (GNATprove, Inline_For_Proof, Key);\n-\n-   function Element\n-     (Container : Map;\n-      Position  : Cursor) return Element_Type\n-   with\n-     Global => null,\n-     Pre    => Has_Element (Container, Position),\n-     Post   =>\n-       Element'Result = Element (Model (Container), Key (Container, Position));\n-   pragma Annotate (GNATprove, Inline_For_Proof, Element);\n-\n-   procedure Replace_Element\n-     (Container : in out Map;\n-      Position  : Cursor;\n-      New_Item  : Element_Type)\n-   with\n-     Global => null,\n-     Pre    => Has_Element (Container, Position),\n-     Post   =>\n-\n-       --  Order of keys and cursors is preserved\n-\n-       Keys (Container) = Keys (Container)'Old\n-         and Positions (Container) = Positions (Container)'Old\n-\n-         --  New_Item is now associated with the key at position Position in\n-         --  Container.\n-\n-         and Element (Container, Position) = New_Item\n-\n-         --  Elements associated with other keys are preserved\n-\n-         and M.Same_Keys (Model (Container), Model (Container)'Old)\n-         and M.Elements_Equal_Except\n-               (Model (Container),\n-                Model (Container)'Old,\n-                Key (Container, Position));\n-\n-   function At_End\n-     (E : not null access constant Map) return not null access constant Map\n-   is (E)\n-   with Ghost,\n-     Annotate => (GNATprove, At_End_Borrow);\n-\n-   function At_End\n-     (E : access constant Element_Type) return access constant Element_Type\n-   is (E)\n-   with Ghost,\n-     Annotate => (GNATprove, At_End_Borrow);\n-\n-   function Constant_Reference\n-     (Container : aliased Map;\n-      Position  : Cursor) return not null access constant Element_Type\n-   with\n-     Global => null,\n-     Pre    => Has_Element (Container, Position),\n-     Post   =>\n-       Constant_Reference'Result.all =\n-           Element (Model (Container), Key (Container, Position));\n-\n-   function Reference\n-     (Container : not null access Map;\n-      Position  : Cursor) return not null access Element_Type\n-   with\n-     Global => null,\n-     Pre    => Has_Element (Container.all, Position),\n-     Post   =>\n-\n-       --  Order of keys and cursors is preserved\n-\n-       Keys (At_End (Container).all) = Keys (Container.all)\n-         and Positions (At_End (Container).all) = Positions (Container.all)\n-\n-         --  The value designated by the result of Reference is now associated\n-         --  with the key at position Position in Container.\n-\n-         and Element (At_End (Container).all, Position) =\n-               At_End (Reference'Result).all\n-\n-         --  Elements associated with other keys are preserved\n-\n-         and M.Same_Keys\n-               (Model (At_End (Container).all),\n-                Model (Container.all))\n-         and M.Elements_Equal_Except\n-               (Model (At_End (Container).all),\n-                Model (Container.all),\n-                Key (At_End (Container).all, Position));\n-\n-   function Constant_Reference\n-     (Container : aliased Map;\n-      Key       : Key_Type) return not null access constant Element_Type\n-   with\n-     Global => null,\n-     Pre    => Contains (Container, Key),\n-     Post   =>\n-       Constant_Reference'Result.all = Element (Model (Container), Key);\n-\n-   function Reference\n-     (Container : not null access Map;\n-      Key       : Key_Type) return not null access Element_Type\n-   with\n-     Global => null,\n-     Pre    => Contains (Container.all, Key),\n-     Post   =>\n-\n-       --  Order of keys and cursors is preserved\n-\n-       Keys (At_End (Container).all) = Keys (Container.all)\n-         and Positions (At_End (Container).all) = Positions (Container.all)\n-\n-         --  The value designated by the result of Reference is now associated\n-         --  with Key in Container.\n-\n-         and Element (Model (At_End (Container).all), Key) =\n-               At_End (Reference'Result).all\n-\n-         --  Elements associated with other keys are preserved\n-\n-         and M.Same_Keys\n-               (Model (At_End (Container).all),\n-                Model (Container.all))\n-         and M.Elements_Equal_Except\n-               (Model (At_End (Container).all),\n-                Model (Container.all),\n-                Key);\n-\n-   procedure Move (Target : in out Map; Source : in out Map) with\n-     Global => null,\n-     Pre    => Target.Capacity >= Length (Source),\n-     Post   =>\n-       Model (Target) = Model (Source)'Old\n-         and Length (Source)'Old = Length (Target)\n-         and Length (Source) = 0\n-\n-         --  Actual keys are preserved\n-\n-         and K_Keys_Included (Keys (Target), Keys (Source)'Old)\n-         and K_Keys_Included (Keys (Source)'Old, Keys (Target));\n-\n-   procedure Insert\n-     (Container : in out Map;\n-      Key       : Key_Type;\n-      New_Item  : Element_Type;\n-      Position  : out Cursor;\n-      Inserted  : out Boolean)\n-   with\n-     Global         => null,\n-     Pre            =>\n-       Length (Container) < Container.Capacity or Contains (Container, Key),\n-     Post           =>\n-       Contains (Container, Key)\n-         and Has_Element (Container, Position)\n-         and Equivalent_Keys\n-               (Formal_Hashed_Maps.Key (Container, Position), Key),\n-     Contract_Cases =>\n-\n-       --  If Key is already in Container, it is not modified and Inserted is\n-       --  set to False.\n-\n-       (Contains (Container, Key) =>\n-          not Inserted\n-            and Model (Container) = Model (Container)'Old\n-            and Keys (Container) = Keys (Container)'Old\n-            and Positions (Container) = Positions (Container)'Old,\n-\n-        --  Otherwise, Key is inserted in Container and Inserted is set to True\n-\n-        others =>\n-          Inserted\n-            and Length (Container) = Length (Container)'Old + 1\n-\n-            --  Key now maps to New_Item\n-\n-            and Formal_Hashed_Maps.Key (Container, Position) = Key\n-            and Element (Model (Container), Key) = New_Item\n-\n-            --  Other keys are preserved\n-\n-            and Model (Container)'Old <= Model (Container)\n-            and M.Keys_Included_Except\n-                  (Model (Container),\n-                   Model (Container)'Old,\n-                   Key)\n-\n-            --  Mapping from cursors to keys is preserved\n-\n-            and Mapping_Preserved\n-                  (K_Left  => Keys (Container)'Old,\n-                   K_Right => Keys (Container),\n-                   P_Left  => Positions (Container)'Old,\n-                   P_Right => Positions (Container))\n-            and P.Keys_Included_Except\n-                  (Positions (Container),\n-                   Positions (Container)'Old,\n-                   Position));\n-\n-   procedure Insert\n-     (Container : in out Map;\n-      Key       : Key_Type;\n-      New_Item  : Element_Type)\n-   with\n-     Global => null,\n-     Pre    =>\n-       Length (Container) < Container.Capacity\n-        and then (not Contains (Container, Key)),\n-     Post   =>\n-       Length (Container) = Length (Container)'Old + 1\n-         and Contains (Container, Key)\n-\n-         --  Key now maps to New_Item\n-\n-         and Formal_Hashed_Maps.Key (Container, Find (Container, Key)) = Key\n-         and Element (Model (Container), Key) = New_Item\n-\n-         --  Other keys are preserved\n-\n-         and Model (Container)'Old <= Model (Container)\n-         and M.Keys_Included_Except\n-               (Model (Container),\n-                Model (Container)'Old,\n-                Key)\n-\n-         --  Mapping from cursors to keys is preserved\n-\n-         and Mapping_Preserved\n-               (K_Left  => Keys (Container)'Old,\n-                K_Right => Keys (Container),\n-                P_Left  => Positions (Container)'Old,\n-                P_Right => Positions (Container))\n-         and P.Keys_Included_Except\n-               (Positions (Container),\n-                Positions (Container)'Old,\n-                Find (Container, Key));\n-\n-   procedure Include\n-     (Container : in out Map;\n-      Key       : Key_Type;\n-      New_Item  : Element_Type)\n-   with\n-     Global         => null,\n-     Pre            =>\n-       Length (Container) < Container.Capacity or Contains (Container, Key),\n-     Post           =>\n-       Contains (Container, Key) and Element (Container, Key) = New_Item,\n-     Contract_Cases =>\n-\n-       --  If Key is already in Container, Key is mapped to New_Item\n-\n-       (Contains (Container, Key) =>\n-\n-          --  Cursors are preserved\n-\n-          Positions (Container) = Positions (Container)'Old\n-\n-            --  The key equivalent to Key in Container is replaced by Key\n-\n-            and K.Get\n-                  (Keys (Container),\n-                   P.Get (Positions (Container), Find (Container, Key))) = Key\n-            and K.Equal_Except\n-                  (Keys (Container)'Old,\n-                   Keys (Container),\n-                   P.Get (Positions (Container), Find (Container, Key)))\n-\n-            --  Elements associated with other keys are preserved\n-\n-            and M.Same_Keys (Model (Container), Model (Container)'Old)\n-            and M.Elements_Equal_Except\n-                  (Model (Container),\n-                   Model (Container)'Old,\n-                   Key),\n-\n-        --  Otherwise, Key is inserted in Container\n-\n-        others =>\n-          Length (Container) = Length (Container)'Old + 1\n-\n-            --  Other keys are preserved\n-\n-            and Model (Container)'Old <= Model (Container)\n-            and M.Keys_Included_Except\n-                  (Model (Container),\n-                   Model (Container)'Old,\n-                   Key)\n-\n-            --  Key is inserted in Container\n-\n-            and K.Get\n-                  (Keys (Container),\n-                   P.Get (Positions (Container), Find (Container, Key))) = Key\n-\n-            --  Mapping from cursors to keys is preserved\n-\n-            and Mapping_Preserved\n-                  (K_Left  => Keys (Container)'Old,\n-                   K_Right => Keys (Container),\n-                   P_Left  => Positions (Container)'Old,\n-                   P_Right => Positions (Container))\n-            and P.Keys_Included_Except\n-                  (Positions (Container),\n-                   Positions (Container)'Old,\n-                   Find (Container, Key)));\n-\n-   procedure Replace\n-     (Container : in out Map;\n-      Key       : Key_Type;\n-      New_Item  : Element_Type)\n-   with\n-     Global => null,\n-     Pre    => Contains (Container, Key),\n-     Post   =>\n-\n-       --  Cursors are preserved\n-\n-       Positions (Container) = Positions (Container)'Old\n-\n-         --  The key equivalent to Key in Container is replaced by Key\n-\n-         and K.Get\n-               (Keys (Container),\n-                P.Get (Positions (Container), Find (Container, Key))) = Key\n-         and K.Equal_Except\n-               (Keys (Container)'Old,\n-                Keys (Container),\n-                P.Get (Positions (Container), Find (Container, Key)))\n-\n-         --  New_Item is now associated with the Key in Container\n-\n-         and Element (Model (Container), Key) = New_Item\n-\n-         --  Elements associated with other keys are preserved\n-\n-         and M.Same_Keys (Model (Container), Model (Container)'Old)\n-         and M.Elements_Equal_Except\n-               (Model (Container),\n-                Model (Container)'Old,\n-                Key);\n-\n-   procedure Exclude (Container : in out Map; Key : Key_Type) with\n-     Global         => null,\n-     Post           => not Contains (Container, Key),\n-     Contract_Cases =>\n-\n-       --  If Key is not in Container, nothing is changed\n-\n-       (not Contains (Container, Key) =>\n-          Model (Container) = Model (Container)'Old\n-            and Keys (Container) = Keys (Container)'Old\n-            and Positions (Container) = Positions (Container)'Old,\n-\n-        --  Otherwise, Key is removed from Container\n-\n-        others =>\n-          Length (Container) = Length (Container)'Old - 1\n-\n-            --  Other keys are preserved\n-\n-            and Model (Container) <= Model (Container)'Old\n-            and M.Keys_Included_Except\n-                  (Model (Container)'Old,\n-                   Model (Container),\n-                   Key)\n-\n-            --  Mapping from cursors to keys is preserved\n-\n-            and Mapping_Preserved\n-                  (K_Left  => Keys (Container),\n-                   K_Right => Keys (Container)'Old,\n-                   P_Left  => Positions (Container),\n-                   P_Right => Positions (Container)'Old)\n-            and P.Keys_Included_Except\n-                  (Positions (Container)'Old,\n-                   Positions (Container),\n-                   Find (Container, Key)'Old));\n-\n-   procedure Delete (Container : in out Map; Key : Key_Type) with\n-     Global => null,\n-     Pre    => Contains (Container, Key),\n-     Post   =>\n-       Length (Container) = Length (Container)'Old - 1\n-\n-         --  Key is no longer in Container\n-\n-         and not Contains (Container, Key)\n-\n-         --  Other keys are preserved\n-\n-         and Model (Container) <= Model (Container)'Old\n-         and M.Keys_Included_Except\n-               (Model (Container)'Old,\n-                Model (Container),\n-                Key)\n-\n-         --  Mapping from cursors to keys is preserved\n-\n-         and Mapping_Preserved\n-               (K_Left  => Keys (Container),\n-                K_Right => Keys (Container)'Old,\n-                P_Left  => Positions (Container),\n-                P_Right => Positions (Container)'Old)\n-         and P.Keys_Included_Except\n-               (Positions (Container)'Old,\n-                Positions (Container),\n-                Find (Container, Key)'Old);\n-\n-   procedure Delete (Container : in out Map; Position : in out Cursor) with\n-     Global  => null,\n-     Depends => (Container =>+ Position, Position => null),\n-     Pre     => Has_Element (Container, Position),\n-     Post    =>\n-       Position = No_Element\n-         and Length (Container) = Length (Container)'Old - 1\n-\n-         --  The key at position Position is no longer in Container\n-\n-         and not Contains (Container, Key (Container, Position)'Old)\n-         and not P.Has_Key (Positions (Container), Position'Old)\n-\n-         --  Other keys are preserved\n-\n-         and Model (Container) <= Model (Container)'Old\n-         and M.Keys_Included_Except\n-               (Model (Container)'Old,\n-                Model (Container),\n-                Key (Container, Position)'Old)\n-\n-         --  Mapping from cursors to keys is preserved\n-\n-         and Mapping_Preserved\n-               (K_Left  => Keys (Container),\n-                K_Right => Keys (Container)'Old,\n-                P_Left  => Positions (Container),\n-                P_Right => Positions (Container)'Old)\n-         and P.Keys_Included_Except\n-               (Positions (Container)'Old,\n-                Positions (Container),\n-                Position'Old);\n-\n-   function First (Container : Map) return Cursor with\n-     Global         => null,\n-     Contract_Cases =>\n-       (Length (Container) = 0 =>\n-          First'Result = No_Element,\n-\n-        others =>\n-          Has_Element (Container, First'Result)\n-            and P.Get (Positions (Container), First'Result) = 1);\n-\n-   function Next (Container : Map; Position : Cursor) return Cursor with\n-     Global         => null,\n-     Pre            =>\n-       Has_Element (Container, Position) or else Position = No_Element,\n-     Contract_Cases =>\n-       (Position = No_Element\n-          or else P.Get (Positions (Container), Position) = Length (Container)\n-        =>\n-          Next'Result = No_Element,\n-\n-        others =>\n-          Has_Element (Container, Next'Result)\n-            and then P.Get (Positions (Container), Next'Result) =\n-                     P.Get (Positions (Container), Position) + 1);\n-\n-   procedure Next (Container : Map; Position : in out Cursor) with\n-     Global         => null,\n-     Pre            =>\n-       Has_Element (Container, Position) or else Position = No_Element,\n-     Contract_Cases =>\n-       (Position = No_Element\n-          or else P.Get (Positions (Container), Position) = Length (Container)\n-        =>\n-          Position = No_Element,\n-\n-        others =>\n-          Has_Element (Container, Position)\n-            and then P.Get (Positions (Container), Position) =\n-                     P.Get (Positions (Container), Position'Old) + 1);\n-\n-   function Find (Container : Map; Key : Key_Type) return Cursor with\n-     Global         => null,\n-     Contract_Cases =>\n-\n-       --  If Key is not contained in Container, Find returns No_Element\n-\n-       (not Contains (Model (Container), Key) =>\n-          Find'Result = No_Element,\n-\n-        --  Otherwise, Find returns a valid cursor in Container\n-\n-        others =>\n-          P.Has_Key (Positions (Container), Find'Result)\n-            and P.Get (Positions (Container), Find'Result) =\n-                Find (Keys (Container), Key)\n-\n-            --  The key designated by the result of Find is Key\n-\n-            and Equivalent_Keys\n-                  (Formal_Hashed_Maps.Key (Container, Find'Result), Key));\n-\n-   function Contains (Container : Map; Key : Key_Type) return Boolean with\n-     Global => null,\n-     Post   => Contains'Result = Contains (Model (Container), Key);\n-   pragma Annotate (GNATprove, Inline_For_Proof, Contains);\n-\n-   function Element (Container : Map; Key : Key_Type) return Element_Type with\n-     Global => null,\n-     Pre    => Contains (Container, Key),\n-     Post   => Element'Result = Element (Model (Container), Key);\n-   pragma Annotate (GNATprove, Inline_For_Proof, Element);\n-\n-   function Has_Element (Container : Map; Position : Cursor) return Boolean\n-   with\n-     Global => null,\n-     Post   =>\n-       Has_Element'Result = P.Has_Key (Positions (Container), Position);\n-   pragma Annotate (GNATprove, Inline_For_Proof, Has_Element);\n-\n-   function Default_Modulus (Capacity : Count_Type) return Hash_Type with\n-     Global => null;\n-\n-private\n-   pragma SPARK_Mode (Off);\n-\n-   pragma Inline (Length);\n-   pragma Inline (Is_Empty);\n-   pragma Inline (Clear);\n-   pragma Inline (Key);\n-   pragma Inline (Element);\n-   pragma Inline (Contains);\n-   pragma Inline (Capacity);\n-   pragma Inline (Has_Element);\n-   pragma Inline (Equivalent_Keys);\n-   pragma Inline (Next);\n-\n-   type Node_Type is record\n-      Key         : Key_Type;\n-      Element     : aliased Element_Type;\n-      Next        : Count_Type;\n-      Has_Element : Boolean := False;\n-   end record;\n-\n-   package HT_Types is new\n-     Ada.Containers.Hash_Tables.Generic_Formal_Hash_Table_Types (Node_Type);\n-\n-   type Map (Capacity : Count_Type; Modulus : Hash_Type) is record\n-     Content : HT_Types.Hash_Table_Type (Capacity, Modulus);\n-   end record;\n+package Ada.Containers.Formal_Hashed_Maps with SPARK_Mode is\n \n-   Empty_Map : constant Map := (Capacity => 0, Modulus => 0, others => <>);\n+   pragma Compile_Time_Error\n+     (True,\n+      \"This package has been moved to the SPARK library shipped with any\"\n+      & \" SPARK release starting with version 23.\");\n \n end Ada.Containers.Formal_Hashed_Maps;"}, {"sha": "34afa554c5f7068cfddb35732e5b02f8024d8c8c", "filename": "gcc/ada/libgnat/a-cfhase.adb", "status": "removed", "additions": 0, "deletions": 1559, "changes": 1559, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6da3cab7b0acf5dc363c85069bef716923ddf90c/gcc%2Fada%2Flibgnat%2Fa-cfhase.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6da3cab7b0acf5dc363c85069bef716923ddf90c/gcc%2Fada%2Flibgnat%2Fa-cfhase.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cfhase.adb?ref=6da3cab7b0acf5dc363c85069bef716923ddf90c", "patch": "@@ -1,1559 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT LIBRARY COMPONENTS                          --\n---                                                                          --\n---    A D A . C O N T A I N E R S . F O R M A L _ H A S H E D _ S E T S     --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 2010-2022, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n-------------------------------------------------------------------------------\n-\n-with Ada.Containers.Hash_Tables.Generic_Formal_Operations;\n-pragma Elaborate_All (Ada.Containers.Hash_Tables.Generic_Formal_Operations);\n-\n-with Ada.Containers.Hash_Tables.Generic_Formal_Keys;\n-pragma Elaborate_All (Ada.Containers.Hash_Tables.Generic_Formal_Keys);\n-\n-with Ada.Containers.Prime_Numbers; use Ada.Containers.Prime_Numbers;\n-\n-with System; use type System.Address;\n-\n-package body Ada.Containers.Formal_Hashed_Sets with\n-  SPARK_Mode => Off\n-is\n-   -----------------------\n-   -- Local Subprograms --\n-   -----------------------\n-\n-   --  All need comments ???\n-\n-   procedure Difference (Left : Set; Right : Set; Target : in out Set);\n-\n-   function Equivalent_Keys\n-     (Key  : Element_Type;\n-      Node : Node_Type) return Boolean;\n-   pragma Inline (Equivalent_Keys);\n-\n-   procedure Free\n-     (HT : in out Set;\n-      X  : Count_Type);\n-\n-   generic\n-      with procedure Set_Element (Node : in out Node_Type);\n-   procedure Generic_Allocate\n-     (HT   : in out Hash_Table_Type;\n-      Node : out Count_Type);\n-\n-   function Hash_Node (Node : Node_Type) return Hash_Type;\n-   pragma Inline (Hash_Node);\n-\n-   procedure Insert\n-     (Container : in out Set;\n-      New_Item  : Element_Type;\n-      Node      : out Count_Type;\n-      Inserted  : out Boolean);\n-\n-   procedure Intersection\n-     (Left   : Set;\n-      Right  : Set;\n-      Target : in out Set);\n-\n-   function Is_In\n-     (HT  : Set;\n-      Key : Node_Type) return Boolean;\n-   pragma Inline (Is_In);\n-\n-   procedure Set_Element (Node : in out Node_Type; Item : Element_Type);\n-   pragma Inline (Set_Element);\n-\n-   function Next (Node : Node_Type) return Count_Type;\n-   pragma Inline (Next);\n-\n-   procedure Set_Next (Node : in out Node_Type; Next : Count_Type);\n-   pragma Inline (Set_Next);\n-\n-   function Vet (Container : Set; Position : Cursor) return Boolean\n-     with Inline;\n-\n-   --------------------------\n-   -- Local Instantiations --\n-   --------------------------\n-\n-   package HT_Ops is new Hash_Tables.Generic_Formal_Operations\n-     (HT_Types  => HT_Types,\n-      Hash_Node => Hash_Node,\n-      Next      => Next,\n-      Set_Next  => Set_Next);\n-\n-   package Element_Keys is new Hash_Tables.Generic_Formal_Keys\n-     (HT_Types        => HT_Types,\n-      Next            => Next,\n-      Set_Next        => Set_Next,\n-      Key_Type        => Element_Type,\n-      Hash            => Hash,\n-      Equivalent_Keys => Equivalent_Keys);\n-\n-   procedure Replace_Element is\n-     new Element_Keys.Generic_Replace_Element (Hash_Node, Set_Element);\n-\n-   ---------\n-   -- \"=\" --\n-   ---------\n-\n-   function \"=\" (Left, Right : Set) return Boolean is\n-   begin\n-      if Length (Left) /= Length (Right) then\n-         return False;\n-      end if;\n-\n-      if Length (Left) = 0 then\n-         return True;\n-      end if;\n-\n-      declare\n-         Node  : Count_Type;\n-         ENode : Count_Type;\n-\n-      begin\n-         Node  := First (Left).Node;\n-         while Node /= 0 loop\n-            ENode :=\n-              Find\n-                (Container => Right,\n-                 Item      => Left.Content.Nodes (Node).Element).Node;\n-\n-            if ENode = 0\n-              or else Right.Content.Nodes (ENode).Element /=\n-              Left.Content.Nodes (Node).Element\n-            then\n-               return False;\n-            end if;\n-\n-            Node := HT_Ops.Next (Left.Content, Node);\n-         end loop;\n-\n-         return True;\n-      end;\n-   end \"=\";\n-\n-   ------------\n-   -- Assign --\n-   ------------\n-\n-   procedure Assign (Target : in out Set; Source : Set) is\n-      procedure Insert_Element (Source_Node : Count_Type);\n-\n-      procedure Insert_Elements is\n-        new HT_Ops.Generic_Iteration (Insert_Element);\n-\n-      --------------------\n-      -- Insert_Element --\n-      --------------------\n-\n-      procedure Insert_Element (Source_Node : Count_Type) is\n-         N        : Node_Type renames Source.Content.Nodes (Source_Node);\n-         Unused_X : Count_Type;\n-         B        : Boolean;\n-\n-      begin\n-         Insert (Target, N.Element, Unused_X, B);\n-         pragma Assert (B);\n-      end Insert_Element;\n-\n-   --  Start of processing for Assign\n-\n-   begin\n-      if Target.Capacity < Length (Source) then\n-         raise Storage_Error with \"not enough capacity\";  -- SE or CE? ???\n-      end if;\n-\n-      HT_Ops.Clear (Target.Content);\n-      Insert_Elements (Source.Content);\n-   end Assign;\n-\n-   --------------\n-   -- Capacity --\n-   --------------\n-\n-   function Capacity (Container : Set) return Count_Type is\n-   begin\n-      return Container.Content.Nodes'Length;\n-   end Capacity;\n-\n-   -----------\n-   -- Clear --\n-   -----------\n-\n-   procedure Clear (Container : in out Set) is\n-   begin\n-      HT_Ops.Clear (Container.Content);\n-   end Clear;\n-\n-   ------------------------\n-   -- Constant_Reference --\n-   ------------------------\n-\n-   function Constant_Reference\n-     (Container : aliased Set;\n-      Position  : Cursor) return not null access constant Element_Type\n-   is\n-   begin\n-      if not Has_Element (Container, Position) then\n-         raise Constraint_Error with \"Position cursor equals No_Element\";\n-      end if;\n-\n-      pragma Assert\n-        (Vet (Container, Position), \"bad cursor in function Element\");\n-\n-      return Container.Content.Nodes (Position.Node).Element'Access;\n-   end Constant_Reference;\n-\n-   --------------\n-   -- Contains --\n-   --------------\n-\n-   function Contains (Container : Set; Item : Element_Type) return Boolean is\n-   begin\n-      return Find (Container, Item) /= No_Element;\n-   end Contains;\n-\n-   ----------\n-   -- Copy --\n-   ----------\n-\n-   function Copy\n-     (Source   : Set;\n-      Capacity : Count_Type := 0) return Set\n-   is\n-      C      : constant Count_Type :=\n-                 Count_Type'Max (Capacity, Source.Capacity);\n-      Cu     : Cursor;\n-      H      : Hash_Type;\n-      N      : Count_Type;\n-      Target : Set (C, Source.Modulus);\n-\n-   begin\n-      if 0 < Capacity and then Capacity < Source.Capacity then\n-         raise Capacity_Error;\n-      end if;\n-\n-      Target.Content.Length := Source.Content.Length;\n-      Target.Content.Free := Source.Content.Free;\n-\n-      H := 1;\n-      while H <= Source.Modulus loop\n-         Target.Content.Buckets (H) := Source.Content.Buckets (H);\n-         H := H + 1;\n-      end loop;\n-\n-      N := 1;\n-      while N <= Source.Capacity loop\n-         Target.Content.Nodes (N) := Source.Content.Nodes (N);\n-         N := N + 1;\n-      end loop;\n-\n-      while N <= C loop\n-         Cu := (Node => N);\n-         Free (Target, Cu.Node);\n-         N := N + 1;\n-      end loop;\n-\n-      return Target;\n-   end Copy;\n-\n-   ---------------------\n-   -- Default_Modulus --\n-   ---------------------\n-\n-   function Default_Modulus (Capacity : Count_Type) return Hash_Type is\n-   begin\n-      return To_Prime (Capacity);\n-   end Default_Modulus;\n-\n-   ------------\n-   -- Delete --\n-   ------------\n-\n-   procedure Delete (Container : in out Set; Item : Element_Type) is\n-      X : Count_Type;\n-\n-   begin\n-      Element_Keys.Delete_Key_Sans_Free (Container.Content, Item, X);\n-\n-      if X = 0 then\n-         raise Constraint_Error with \"attempt to delete element not in set\";\n-      end if;\n-\n-      Free (Container, X);\n-   end Delete;\n-\n-   procedure Delete (Container : in out Set; Position : in out Cursor) is\n-   begin\n-      if not Has_Element (Container, Position) then\n-         raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      pragma Assert (Vet (Container, Position), \"bad cursor in Delete\");\n-\n-      HT_Ops.Delete_Node_Sans_Free (Container.Content, Position.Node);\n-      Free (Container, Position.Node);\n-\n-      Position := No_Element;\n-   end Delete;\n-\n-   ----------------\n-   -- Difference --\n-   ----------------\n-\n-   procedure Difference (Target : in out Set; Source : Set) is\n-      Src_Last   : Count_Type;\n-      Src_Length : Count_Type;\n-      Src_Node   : Count_Type;\n-      Tgt_Node   : Count_Type;\n-\n-      TN : Nodes_Type renames Target.Content.Nodes;\n-      SN : Nodes_Type renames Source.Content.Nodes;\n-\n-   begin\n-      Src_Length := Source.Content.Length;\n-\n-      if Src_Length = 0 then\n-         return;\n-      end if;\n-\n-      if Src_Length >= Target.Content.Length then\n-         Tgt_Node := HT_Ops.First (Target.Content);\n-         while Tgt_Node /= 0 loop\n-            if Element_Keys.Find (Source.Content, TN (Tgt_Node).Element) /= 0\n-            then\n-               declare\n-                  X : constant Count_Type := Tgt_Node;\n-               begin\n-                  Tgt_Node := HT_Ops.Next (Target.Content, Tgt_Node);\n-                  HT_Ops.Delete_Node_Sans_Free (Target.Content, X);\n-                  Free (Target, X);\n-               end;\n-\n-            else\n-               Tgt_Node := HT_Ops.Next (Target.Content, Tgt_Node);\n-            end if;\n-         end loop;\n-\n-         return;\n-      else\n-         Src_Node := HT_Ops.First (Source.Content);\n-         Src_Last := 0;\n-      end if;\n-\n-      while Src_Node /= Src_Last loop\n-         Tgt_Node := Element_Keys.Find (Target.Content, SN (Src_Node).Element);\n-\n-         if Tgt_Node /= 0 then\n-            HT_Ops.Delete_Node_Sans_Free (Target.Content, Tgt_Node);\n-            Free (Target, Tgt_Node);\n-         end if;\n-\n-         Src_Node := HT_Ops.Next (Source.Content, Src_Node);\n-      end loop;\n-   end Difference;\n-\n-   procedure Difference (Left : Set; Right : Set; Target : in out Set) is\n-      procedure Process (L_Node : Count_Type);\n-\n-      procedure Iterate is\n-        new HT_Ops.Generic_Iteration (Process);\n-\n-      -------------\n-      -- Process --\n-      -------------\n-\n-      procedure Process (L_Node : Count_Type) is\n-         B        : Boolean;\n-         E        : Element_Type renames Left.Content.Nodes (L_Node).Element;\n-         Unused_X : Count_Type;\n-\n-      begin\n-         if Find (Right, E).Node = 0 then\n-            Insert (Target, E, Unused_X, B);\n-            pragma Assert (B);\n-         end if;\n-      end Process;\n-\n-   --  Start of processing for Difference\n-\n-   begin\n-      Iterate (Left.Content);\n-   end Difference;\n-\n-   function Difference (Left : Set; Right : Set) return Set is\n-   begin\n-      if Length (Left) = 0 then\n-         return Empty_Set;\n-      end if;\n-\n-      if Length (Right) = 0 then\n-         return Copy (Left);\n-      end if;\n-\n-      declare\n-         C : constant Count_Type := Length (Left);\n-         H : constant Hash_Type := Default_Modulus (C);\n-      begin\n-         return S : Set (C, H) do\n-            Difference (Left, Right, Target => S);\n-         end return;\n-      end;\n-   end Difference;\n-\n-   -------------\n-   -- Element --\n-   -------------\n-\n-   function Element\n-     (Container : Set;\n-      Position  : Cursor) return Element_Type\n-   is\n-   begin\n-      if not Has_Element (Container, Position) then\n-         raise Constraint_Error with \"Position cursor equals No_Element\";\n-      end if;\n-\n-      pragma Assert\n-        (Vet (Container, Position), \"bad cursor in function Element\");\n-\n-      return Container.Content.Nodes (Position.Node).Element;\n-   end Element;\n-\n-   ---------------------\n-   -- Equivalent_Sets --\n-   ---------------------\n-\n-   function Equivalent_Sets (Left, Right : Set) return Boolean is\n-\n-      function Find_Equivalent_Key\n-        (R_HT   : Hash_Table_Type;\n-         L_Node : Node_Type) return Boolean;\n-      pragma Inline (Find_Equivalent_Key);\n-\n-      function Is_Equivalent is\n-        new HT_Ops.Generic_Equal (Find_Equivalent_Key);\n-\n-      -------------------------\n-      -- Find_Equivalent_Key --\n-      -------------------------\n-\n-      function Find_Equivalent_Key\n-        (R_HT   : Hash_Table_Type;\n-         L_Node : Node_Type) return Boolean\n-      is\n-         R_Index : constant Hash_Type :=\n-                     Element_Keys.Index (R_HT, L_Node.Element);\n-         R_Node  : Count_Type := R_HT.Buckets (R_Index);\n-         RN      : Nodes_Type renames R_HT.Nodes;\n-\n-      begin\n-         loop\n-            if R_Node = 0 then\n-               return False;\n-            end if;\n-\n-            if Equivalent_Elements\n-                 (L_Node.Element, RN (R_Node).Element)\n-            then\n-               return True;\n-            end if;\n-\n-            R_Node := HT_Ops.Next (R_HT, R_Node);\n-         end loop;\n-      end Find_Equivalent_Key;\n-\n-   --  Start of processing for Equivalent_Sets\n-\n-   begin\n-      return Is_Equivalent (Left.Content, Right.Content);\n-   end Equivalent_Sets;\n-\n-   ---------------------\n-   -- Equivalent_Keys --\n-   ---------------------\n-\n-   function Equivalent_Keys\n-     (Key  : Element_Type;\n-      Node : Node_Type) return Boolean\n-   is\n-   begin\n-      return Equivalent_Elements (Key, Node.Element);\n-   end Equivalent_Keys;\n-\n-   -------------\n-   -- Exclude --\n-   -------------\n-\n-   procedure Exclude (Container : in out Set; Item : Element_Type) is\n-      X : Count_Type;\n-   begin\n-      Element_Keys.Delete_Key_Sans_Free (Container.Content, Item, X);\n-      Free (Container, X);\n-   end Exclude;\n-\n-   ----------\n-   -- Find --\n-   ----------\n-\n-   function Find\n-     (Container : Set;\n-      Item      : Element_Type) return Cursor\n-   is\n-      Node : constant Count_Type :=\n-        Element_Keys.Find (Container.Content, Item);\n-\n-   begin\n-      if Node = 0 then\n-         return No_Element;\n-      end if;\n-\n-      return (Node => Node);\n-   end Find;\n-\n-   -----------\n-   -- First --\n-   -----------\n-\n-   function First (Container : Set) return Cursor is\n-      Node : constant Count_Type := HT_Ops.First (Container.Content);\n-\n-   begin\n-      if Node = 0 then\n-         return No_Element;\n-      end if;\n-\n-      return (Node => Node);\n-   end First;\n-\n-   ------------------\n-   -- Formal_Model --\n-   ------------------\n-\n-   package body Formal_Model is\n-\n-      -------------------------\n-      -- E_Elements_Included --\n-      -------------------------\n-\n-      function E_Elements_Included\n-        (Left  : E.Sequence;\n-         Right : E.Sequence) return Boolean\n-      is\n-      begin\n-         for I in 1 .. E.Length (Left) loop\n-            if not E.Contains (Right, 1, E.Length (Right), E.Get (Left, I))\n-            then\n-               return False;\n-            end if;\n-         end loop;\n-\n-         return True;\n-      end E_Elements_Included;\n-\n-      function E_Elements_Included\n-        (Left  : E.Sequence;\n-         Model : M.Set;\n-         Right : E.Sequence) return Boolean\n-      is\n-      begin\n-         for I in 1 .. E.Length (Left) loop\n-            declare\n-               Item : constant Element_Type := E.Get (Left, I);\n-            begin\n-               if M.Contains (Model, Item) then\n-                  if not E.Contains (Right, 1, E.Length (Right), Item) then\n-                     return False;\n-                  end if;\n-               end if;\n-            end;\n-         end loop;\n-\n-         return True;\n-      end E_Elements_Included;\n-\n-      function E_Elements_Included\n-        (Container : E.Sequence;\n-         Model     : M.Set;\n-         Left      : E.Sequence;\n-         Right     : E.Sequence) return Boolean\n-      is\n-      begin\n-         for I in 1 .. E.Length (Container) loop\n-            declare\n-               Item : constant Element_Type := E.Get (Container, I);\n-            begin\n-               if M.Contains (Model, Item) then\n-                  if not E.Contains (Left, 1, E.Length (Left), Item) then\n-                     return False;\n-                  end if;\n-               else\n-                  if not E.Contains (Right, 1, E.Length (Right), Item) then\n-                     return False;\n-                  end if;\n-               end if;\n-            end;\n-         end loop;\n-\n-         return True;\n-      end E_Elements_Included;\n-\n-      ----------\n-      -- Find --\n-      ----------\n-\n-      function Find\n-        (Container : E.Sequence;\n-         Item      : Element_Type) return Count_Type\n-      is\n-      begin\n-         for I in 1 .. E.Length (Container) loop\n-            if Equivalent_Elements (Item, E.Get (Container, I)) then\n-               return I;\n-            end if;\n-         end loop;\n-         return 0;\n-      end Find;\n-\n-      --------------\n-      -- Elements --\n-      --------------\n-\n-      function Elements (Container : Set) return E.Sequence is\n-         Position : Count_Type := HT_Ops.First (Container.Content);\n-         R        : E.Sequence;\n-\n-      begin\n-         --  Can't use First, Next or Element here, since they depend on models\n-         --  for their postconditions.\n-\n-         while Position /= 0 loop\n-            R := E.Add (R, Container.Content.Nodes (Position).Element);\n-            Position := HT_Ops.Next (Container.Content, Position);\n-         end loop;\n-\n-         return R;\n-      end Elements;\n-\n-      ----------------------------\n-      -- Lift_Abstraction_Level --\n-      ----------------------------\n-\n-      procedure Lift_Abstraction_Level (Container : Set) is null;\n-\n-      -----------------------\n-      -- Mapping_Preserved --\n-      -----------------------\n-\n-      function Mapping_Preserved\n-        (E_Left  : E.Sequence;\n-         E_Right : E.Sequence;\n-         P_Left  : P.Map;\n-         P_Right : P.Map) return Boolean\n-      is\n-      begin\n-         for C of P_Left loop\n-            if not P.Has_Key (P_Right, C)\n-              or else P.Get (P_Left,  C) > E.Length (E_Left)\n-              or else P.Get (P_Right, C) > E.Length (E_Right)\n-              or else E.Get (E_Left,  P.Get (P_Left,  C)) /=\n-                      E.Get (E_Right, P.Get (P_Right, C))\n-            then\n-               return False;\n-            end if;\n-         end loop;\n-\n-         return True;\n-      end Mapping_Preserved;\n-\n-      ------------------------------\n-      -- Mapping_Preserved_Except --\n-      ------------------------------\n-\n-      function Mapping_Preserved_Except\n-        (E_Left   : E.Sequence;\n-         E_Right  : E.Sequence;\n-         P_Left   : P.Map;\n-         P_Right  : P.Map;\n-         Position : Cursor) return Boolean\n-      is\n-      begin\n-         for C of P_Left loop\n-            if C /= Position\n-              and (not P.Has_Key (P_Right, C)\n-                    or else P.Get (P_Left,  C) > E.Length (E_Left)\n-                    or else P.Get (P_Right, C) > E.Length (E_Right)\n-                    or else E.Get (E_Left,  P.Get (P_Left,  C)) /=\n-                            E.Get (E_Right, P.Get (P_Right, C)))\n-            then\n-               return False;\n-            end if;\n-         end loop;\n-\n-         return True;\n-      end Mapping_Preserved_Except;\n-\n-      -----------\n-      -- Model --\n-      -----------\n-\n-      function Model (Container : Set) return M.Set is\n-         Position : Count_Type := HT_Ops.First (Container.Content);\n-         R        : M.Set;\n-\n-      begin\n-         --  Can't use First, Next or Element here, since they depend on models\n-         --  for their postconditions.\n-\n-         while Position /= 0 loop\n-            R :=\n-              M.Add\n-                (Container => R,\n-                 Item      => Container.Content.Nodes (Position).Element);\n-\n-            Position := HT_Ops.Next (Container.Content, Position);\n-         end loop;\n-\n-         return R;\n-      end Model;\n-\n-      ---------------\n-      -- Positions --\n-      ---------------\n-\n-      function Positions (Container : Set) return P.Map is\n-         I        : Count_Type := 1;\n-         Position : Count_Type := HT_Ops.First (Container.Content);\n-         R        : P.Map;\n-\n-      begin\n-         --  Can't use First, Next or Element here, since they depend on models\n-         --  for their postconditions.\n-\n-         while Position /= 0 loop\n-            R := P.Add (R, (Node => Position), I);\n-            pragma Assert (P.Length (R) = Big (I));\n-            Position := HT_Ops.Next (Container.Content, Position);\n-            I := I + 1;\n-         end loop;\n-\n-         return R;\n-      end Positions;\n-\n-   end Formal_Model;\n-\n-   ----------\n-   -- Free --\n-   ----------\n-\n-   procedure Free (HT : in out Set; X : Count_Type) is\n-   begin\n-      if X /= 0 then\n-         pragma Assert (X <= HT.Capacity);\n-         HT.Content.Nodes (X).Has_Element := False;\n-         HT_Ops.Free (HT.Content, X);\n-      end if;\n-   end Free;\n-\n-   ----------------------\n-   -- Generic_Allocate --\n-   ----------------------\n-\n-   procedure Generic_Allocate\n-     (HT   : in out Hash_Table_Type;\n-      Node : out Count_Type)\n-   is\n-      procedure Allocate is new HT_Ops.Generic_Allocate (Set_Element);\n-   begin\n-      Allocate (HT, Node);\n-      HT.Nodes (Node).Has_Element := True;\n-   end Generic_Allocate;\n-\n-   package body Generic_Keys with SPARK_Mode => Off is\n-\n-      -----------------------\n-      -- Local Subprograms --\n-      -----------------------\n-\n-      function Equivalent_Key_Node\n-        (Key  : Key_Type;\n-         Node : Node_Type) return Boolean;\n-      pragma Inline (Equivalent_Key_Node);\n-\n-      --------------------------\n-      -- Local Instantiations --\n-      --------------------------\n-\n-      package Key_Keys is new Hash_Tables.Generic_Formal_Keys\n-        (HT_Types        => HT_Types,\n-         Next            => Next,\n-         Set_Next        => Set_Next,\n-         Key_Type        => Key_Type,\n-         Hash            => Hash,\n-         Equivalent_Keys => Equivalent_Key_Node);\n-\n-      --------------\n-      -- Contains --\n-      --------------\n-\n-      function Contains\n-        (Container : Set;\n-         Key       : Key_Type) return Boolean\n-      is\n-      begin\n-         return Find (Container, Key) /= No_Element;\n-      end Contains;\n-\n-      ------------\n-      -- Delete --\n-      ------------\n-\n-      procedure Delete (Container : in out Set; Key : Key_Type) is\n-         X : Count_Type;\n-\n-      begin\n-         Key_Keys.Delete_Key_Sans_Free (Container.Content, Key, X);\n-\n-         if X = 0 then\n-            raise Constraint_Error with \"attempt to delete key not in set\";\n-         end if;\n-\n-         Free (Container, X);\n-      end Delete;\n-\n-      -------------\n-      -- Element --\n-      -------------\n-\n-      function Element\n-        (Container : Set;\n-         Key       : Key_Type) return Element_Type\n-      is\n-         Node : constant Count_Type := Find (Container, Key).Node;\n-\n-      begin\n-         if Node = 0 then\n-            raise Constraint_Error with \"key not in map\";\n-         end if;\n-\n-         return Container.Content.Nodes (Node).Element;\n-      end Element;\n-\n-      -------------------------\n-      -- Equivalent_Key_Node --\n-      -------------------------\n-\n-      function Equivalent_Key_Node\n-        (Key  : Key_Type;\n-         Node : Node_Type) return Boolean\n-      is\n-      begin\n-         return Equivalent_Keys (Key, Generic_Keys.Key (Node.Element));\n-      end Equivalent_Key_Node;\n-\n-      -------------\n-      -- Exclude --\n-      -------------\n-\n-      procedure Exclude (Container : in out Set; Key : Key_Type) is\n-         X : Count_Type;\n-      begin\n-         Key_Keys.Delete_Key_Sans_Free (Container.Content, Key, X);\n-         Free (Container, X);\n-      end Exclude;\n-\n-      ----------\n-      -- Find --\n-      ----------\n-\n-      function Find\n-        (Container : Set;\n-         Key       : Key_Type) return Cursor\n-      is\n-         Node : constant Count_Type := Key_Keys.Find (Container.Content, Key);\n-      begin\n-         return (if Node = 0 then No_Element else (Node => Node));\n-      end Find;\n-\n-      ------------------\n-      -- Formal_Model --\n-      ------------------\n-\n-      package body Formal_Model is\n-\n-         -----------------------\n-         -- M_Included_Except --\n-         -----------------------\n-\n-         function M_Included_Except\n-           (Left  : M.Set;\n-            Right : M.Set;\n-            Key   : Key_Type) return Boolean\n-         is\n-         begin\n-            for E of Left loop\n-               if not Contains (Right, E)\n-                 and not Equivalent_Keys (Generic_Keys.Key (E), Key)\n-               then\n-                  return False;\n-               end if;\n-            end loop;\n-\n-            return True;\n-         end M_Included_Except;\n-\n-      end Formal_Model;\n-\n-      ---------\n-      -- Key --\n-      ---------\n-\n-      function Key (Container : Set; Position : Cursor) return Key_Type is\n-      begin\n-         if not Has_Element (Container, Position) then\n-            raise Constraint_Error with \"Position cursor has no element\";\n-         end if;\n-\n-         pragma Assert\n-           (Vet (Container, Position), \"bad cursor in function Key\");\n-\n-         declare\n-            N : Node_Type renames Container.Content.Nodes (Position.Node);\n-         begin\n-            return Key (N.Element);\n-         end;\n-      end Key;\n-\n-      -------------\n-      -- Replace --\n-      -------------\n-\n-      procedure Replace\n-        (Container : in out Set;\n-         Key       : Key_Type;\n-         New_Item  : Element_Type)\n-      is\n-         Node : constant Count_Type := Key_Keys.Find (Container.Content, Key);\n-\n-      begin\n-         if Node = 0 then\n-            raise Constraint_Error with \"attempt to replace key not in set\";\n-         end if;\n-\n-         Replace_Element (Container.Content, Node, New_Item);\n-      end Replace;\n-\n-   end Generic_Keys;\n-\n-   -----------------\n-   -- Has_Element --\n-   -----------------\n-\n-   function Has_Element (Container : Set; Position : Cursor) return Boolean is\n-   begin\n-      if Position.Node = 0\n-        or else not Container.Content.Nodes (Position.Node).Has_Element\n-      then\n-         return False;\n-      end if;\n-\n-      return True;\n-   end Has_Element;\n-\n-   ---------------\n-   -- Hash_Node --\n-   ---------------\n-\n-   function Hash_Node (Node : Node_Type) return Hash_Type is\n-   begin\n-      return Hash (Node.Element);\n-   end Hash_Node;\n-\n-   -------------\n-   -- Include --\n-   -------------\n-\n-   procedure Include (Container : in out Set; New_Item : Element_Type) is\n-      Inserted : Boolean;\n-      Position : Cursor;\n-\n-   begin\n-      Insert (Container, New_Item, Position, Inserted);\n-\n-      if not Inserted then\n-         Container.Content.Nodes (Position.Node).Element := New_Item;\n-      end if;\n-   end Include;\n-\n-   ------------\n-   -- Insert --\n-   ------------\n-\n-   procedure Insert\n-     (Container : in out Set;\n-      New_Item  : Element_Type;\n-      Position  : out Cursor;\n-      Inserted  : out Boolean)\n-   is\n-   begin\n-      Insert (Container, New_Item, Position.Node, Inserted);\n-   end Insert;\n-\n-   procedure Insert (Container : in out Set; New_Item : Element_Type) is\n-      Inserted        : Boolean;\n-      Unused_Position : Cursor;\n-\n-   begin\n-      Insert (Container, New_Item, Unused_Position, Inserted);\n-\n-      if not Inserted then\n-         raise Constraint_Error with\n-           \"attempt to insert element already in set\";\n-      end if;\n-   end Insert;\n-\n-   procedure Insert\n-     (Container : in out Set;\n-      New_Item  : Element_Type;\n-      Node      : out Count_Type;\n-      Inserted  : out Boolean)\n-   is\n-      procedure Allocate_Set_Element (Node : in out Node_Type);\n-      pragma Inline (Allocate_Set_Element);\n-\n-      procedure New_Node\n-        (HT   : in out Hash_Table_Type;\n-         Node : out Count_Type);\n-      pragma Inline (New_Node);\n-\n-      procedure Local_Insert is\n-        new Element_Keys.Generic_Conditional_Insert (New_Node);\n-\n-      procedure Allocate is\n-        new Generic_Allocate (Allocate_Set_Element);\n-\n-      ---------------------------\n-      --  Allocate_Set_Element --\n-      ---------------------------\n-\n-      procedure Allocate_Set_Element (Node : in out Node_Type) is\n-      begin\n-         Node.Element := New_Item;\n-      end Allocate_Set_Element;\n-\n-      --------------\n-      -- New_Node --\n-      --------------\n-\n-      procedure New_Node\n-        (HT   : in out Hash_Table_Type;\n-         Node : out Count_Type)\n-      is\n-      begin\n-         Allocate (HT, Node);\n-      end New_Node;\n-\n-   --  Start of processing for Insert\n-\n-   begin\n-      Local_Insert (Container.Content, New_Item, Node, Inserted);\n-   end Insert;\n-\n-   ------------------\n-   -- Intersection --\n-   ------------------\n-\n-   procedure Intersection (Target : in out Set; Source : Set) is\n-      Tgt_Node : Count_Type;\n-      TN       : Nodes_Type renames Target.Content.Nodes;\n-\n-   begin\n-      if Source.Content.Length = 0 then\n-         Clear (Target);\n-         return;\n-      end if;\n-\n-      Tgt_Node := HT_Ops.First (Target.Content);\n-      while Tgt_Node /= 0 loop\n-         if Find (Source, TN (Tgt_Node).Element).Node /= 0 then\n-            Tgt_Node := HT_Ops.Next (Target.Content, Tgt_Node);\n-\n-         else\n-            declare\n-               X : constant Count_Type := Tgt_Node;\n-            begin\n-               Tgt_Node := HT_Ops.Next (Target.Content, Tgt_Node);\n-               HT_Ops.Delete_Node_Sans_Free (Target.Content, X);\n-               Free (Target, X);\n-            end;\n-         end if;\n-      end loop;\n-   end Intersection;\n-\n-   procedure Intersection (Left : Set; Right : Set; Target : in out Set) is\n-      procedure Process (L_Node : Count_Type);\n-\n-      procedure Iterate is\n-        new HT_Ops.Generic_Iteration (Process);\n-\n-      -------------\n-      -- Process --\n-      -------------\n-\n-      procedure Process (L_Node : Count_Type) is\n-         E        : Element_Type renames Left.Content.Nodes (L_Node).Element;\n-         Unused_X : Count_Type;\n-         B        : Boolean;\n-\n-      begin\n-         if Find (Right, E).Node /= 0 then\n-            Insert (Target, E, Unused_X, B);\n-            pragma Assert (B);\n-         end if;\n-      end Process;\n-\n-   --  Start of processing for Intersection\n-\n-   begin\n-      Iterate (Left.Content);\n-   end Intersection;\n-\n-   function Intersection (Left : Set; Right : Set) return Set is\n-      C : constant Count_Type :=\n-        Count_Type'Min (Length (Left), Length (Right));  -- ???\n-      H : constant Hash_Type := Default_Modulus (C);\n-\n-   begin\n-      return S : Set (C, H) do\n-         if Length (Left) /= 0 and Length (Right) /= 0 then\n-            Intersection (Left, Right, Target => S);\n-         end if;\n-      end return;\n-   end Intersection;\n-\n-   --------------\n-   -- Is_Empty --\n-   --------------\n-\n-   function Is_Empty (Container : Set) return Boolean is\n-   begin\n-      return Length (Container) = 0;\n-   end Is_Empty;\n-\n-   -----------\n-   -- Is_In --\n-   -----------\n-\n-   function Is_In (HT : Set; Key : Node_Type) return Boolean is\n-   begin\n-      return Element_Keys.Find (HT.Content, Key.Element) /= 0;\n-   end Is_In;\n-\n-   ---------------\n-   -- Is_Subset --\n-   ---------------\n-\n-   function Is_Subset (Subset : Set; Of_Set : Set) return Boolean is\n-      Subset_Node  : Count_Type;\n-      Subset_Nodes : Nodes_Type renames Subset.Content.Nodes;\n-\n-   begin\n-      if Length (Subset) > Length (Of_Set) then\n-         return False;\n-      end if;\n-\n-      Subset_Node := First (Subset).Node;\n-      while Subset_Node /= 0 loop\n-         declare\n-            S : constant Count_Type := Subset_Node;\n-            N : Node_Type renames Subset_Nodes (S);\n-            E : Element_Type renames N.Element;\n-\n-         begin\n-            if Find (Of_Set, E).Node = 0 then\n-               return False;\n-            end if;\n-         end;\n-\n-         Subset_Node := HT_Ops.Next (Subset.Content, Subset_Node);\n-      end loop;\n-\n-      return True;\n-   end Is_Subset;\n-\n-   ------------\n-   -- Length --\n-   ------------\n-\n-   function Length (Container : Set) return Count_Type is\n-   begin\n-      return Container.Content.Length;\n-   end Length;\n-\n-   ----------\n-   -- Move --\n-   ----------\n-\n-   --  Comments???\n-\n-   procedure Move (Target : in out Set; Source : in out Set) is\n-      NN   : HT_Types.Nodes_Type renames Source.Content.Nodes;\n-      X, Y : Count_Type;\n-\n-   begin\n-      if Target.Capacity < Length (Source) then\n-         raise Constraint_Error with  -- ???\n-           \"Source length exceeds Target capacity\";\n-      end if;\n-\n-      Clear (Target);\n-\n-      if Source.Content.Length = 0 then\n-         return;\n-      end if;\n-\n-      X := HT_Ops.First (Source.Content);\n-      while X /= 0 loop\n-         Insert (Target, NN (X).Element);  -- optimize???\n-\n-         Y := HT_Ops.Next (Source.Content, X);\n-\n-         HT_Ops.Delete_Node_Sans_Free (Source.Content, X);\n-         Free (Source, X);\n-\n-         X := Y;\n-      end loop;\n-   end Move;\n-\n-   ----------\n-   -- Next --\n-   ----------\n-\n-   function Next (Node : Node_Type) return Count_Type is\n-   begin\n-      return Node.Next;\n-   end Next;\n-\n-   function Next (Container : Set; Position : Cursor) return Cursor is\n-   begin\n-      if Position.Node = 0 then\n-         return No_Element;\n-      end if;\n-\n-      if not Has_Element (Container, Position) then\n-         raise Constraint_Error with \"Position has no element\";\n-      end if;\n-\n-      pragma Assert (Vet (Container, Position), \"bad cursor in Next\");\n-\n-      return (Node => HT_Ops.Next (Container.Content, Position.Node));\n-   end Next;\n-\n-   procedure Next (Container : Set; Position : in out Cursor) is\n-   begin\n-      Position := Next (Container, Position);\n-   end Next;\n-\n-   -------------\n-   -- Overlap --\n-   -------------\n-\n-   function Overlap (Left, Right : Set) return Boolean is\n-      Left_Node  : Count_Type;\n-      Left_Nodes : Nodes_Type renames Left.Content.Nodes;\n-\n-   begin\n-      if Length (Right) = 0 or Length (Left) = 0 then\n-         return False;\n-      end if;\n-\n-      Left_Node := First (Left).Node;\n-      while Left_Node /= 0 loop\n-         declare\n-            L : constant Count_Type := Left_Node;\n-            N : Node_Type renames Left_Nodes (L);\n-            E : Element_Type renames N.Element;\n-         begin\n-            if Find (Right, E).Node /= 0 then\n-               return True;\n-            end if;\n-         end;\n-\n-         Left_Node := HT_Ops.Next (Left.Content, Left_Node);\n-      end loop;\n-\n-      return False;\n-   end Overlap;\n-\n-   -------------\n-   -- Replace --\n-   -------------\n-\n-   procedure Replace (Container : in out Set; New_Item : Element_Type) is\n-      Node : constant Count_Type :=\n-        Element_Keys.Find (Container.Content, New_Item);\n-\n-   begin\n-      if Node = 0 then\n-         raise Constraint_Error with \"attempt to replace element not in set\";\n-      end if;\n-\n-      Container.Content.Nodes (Node).Element := New_Item;\n-   end Replace;\n-\n-   ---------------------\n-   -- Replace_Element --\n-   ---------------------\n-\n-   procedure Replace_Element\n-     (Container : in out Set;\n-      Position  : Cursor;\n-      New_Item  : Element_Type)\n-   is\n-   begin\n-      if not Has_Element (Container, Position) then\n-         raise Constraint_Error with \"Position cursor equals No_Element\";\n-      end if;\n-\n-      pragma Assert\n-        (Vet (Container, Position), \"bad cursor in Replace_Element\");\n-\n-      Replace_Element (Container.Content, Position.Node, New_Item);\n-   end Replace_Element;\n-\n-   ----------------------\n-   -- Reserve_Capacity --\n-   ----------------------\n-\n-   procedure Reserve_Capacity\n-     (Container : in out Set;\n-      Capacity  : Count_Type)\n-   is\n-   begin\n-      if Capacity > Container.Capacity then\n-         raise Constraint_Error with \"requested capacity is too large\";\n-      end if;\n-   end Reserve_Capacity;\n-\n-   ------------------\n-   --  Set_Element --\n-   ------------------\n-\n-   procedure Set_Element (Node : in out Node_Type; Item : Element_Type) is\n-   begin\n-      Node.Element := Item;\n-   end Set_Element;\n-\n-   --------------\n-   -- Set_Next --\n-   --------------\n-\n-   procedure Set_Next (Node : in out Node_Type; Next : Count_Type) is\n-   begin\n-      Node.Next := Next;\n-   end Set_Next;\n-\n-   --------------------------\n-   -- Symmetric_Difference --\n-   --------------------------\n-\n-   procedure Symmetric_Difference (Target : in out Set; Source : Set) is\n-      procedure Process (Source_Node : Count_Type);\n-      pragma Inline (Process);\n-\n-      procedure Iterate is new HT_Ops.Generic_Iteration (Process);\n-\n-      -------------\n-      -- Process --\n-      -------------\n-\n-      procedure Process (Source_Node : Count_Type) is\n-         B        : Boolean;\n-         N        : Node_Type renames Source.Content.Nodes (Source_Node);\n-         Unused_X : Count_Type;\n-\n-      begin\n-         if Is_In (Target, N) then\n-            Delete (Target, N.Element);\n-         else\n-            Insert (Target, N.Element, Unused_X, B);\n-            pragma Assert (B);\n-         end if;\n-      end Process;\n-\n-   --  Start of processing for Symmetric_Difference\n-\n-   begin\n-      if Length (Target) = 0 then\n-         Assign (Target, Source);\n-         return;\n-      end if;\n-\n-      Iterate (Source.Content);\n-   end Symmetric_Difference;\n-\n-   function Symmetric_Difference (Left : Set; Right : Set) return Set is\n-   begin\n-      if Length (Right) = 0 then\n-         return Copy (Left);\n-      end if;\n-\n-      if Length (Left) = 0 then\n-         return Copy (Right);\n-      end if;\n-\n-      declare\n-         C : constant Count_Type := Length (Left) + Length (Right);\n-         H : constant Hash_Type := Default_Modulus (C);\n-      begin\n-         return S : Set (C, H) do\n-            Difference (Left, Right, S);\n-            Difference (Right, Left, S);\n-         end return;\n-      end;\n-   end Symmetric_Difference;\n-\n-   ------------\n-   -- To_Set --\n-   ------------\n-\n-   function To_Set (New_Item : Element_Type) return Set is\n-      Unused_X : Count_Type;\n-      B        : Boolean;\n-\n-   begin\n-      return S : Set (Capacity => 1, Modulus => 1) do\n-         Insert (S, New_Item, Unused_X, B);\n-         pragma Assert (B);\n-      end return;\n-   end To_Set;\n-\n-   -----------\n-   -- Union --\n-   -----------\n-\n-   procedure Union (Target : in out Set; Source : Set) is\n-      procedure Process (Src_Node : Count_Type);\n-\n-      procedure Iterate is\n-        new HT_Ops.Generic_Iteration (Process);\n-\n-      -------------\n-      -- Process --\n-      -------------\n-\n-      procedure Process (Src_Node : Count_Type) is\n-         N : Node_Type renames Source.Content.Nodes (Src_Node);\n-         E : Element_Type renames N.Element;\n-\n-         Unused_X : Count_Type;\n-         Unused_B : Boolean;\n-\n-      begin\n-         Insert (Target, E, Unused_X, Unused_B);\n-      end Process;\n-\n-   --  Start of processing for Union\n-\n-   begin\n-      Iterate (Source.Content);\n-   end Union;\n-\n-   function Union (Left : Set; Right : Set) return Set is\n-   begin\n-      if Length (Right) = 0 then\n-         return Copy (Left);\n-      end if;\n-\n-      if Length (Left) = 0 then\n-         return Copy (Right);\n-      end if;\n-\n-      declare\n-         C : constant Count_Type := Length (Left) + Length (Right);\n-         H : constant Hash_Type := Default_Modulus (C);\n-      begin\n-         return S : Set (C, H) do\n-            Assign (Target => S, Source => Left);\n-            Union (Target => S, Source => Right);\n-         end return;\n-      end;\n-   end Union;\n-\n-   ---------\n-   -- Vet --\n-   ---------\n-\n-   function Vet (Container : Set; Position : Cursor) return Boolean is\n-   begin\n-      if not Container_Checks'Enabled then\n-         return True;\n-      end if;\n-\n-      if Position.Node = 0 then\n-         return True;\n-      end if;\n-\n-      declare\n-         S : Set renames Container;\n-         N : Nodes_Type renames S.Content.Nodes;\n-         X : Count_Type;\n-\n-      begin\n-         if S.Content.Length = 0 then\n-            return False;\n-         end if;\n-\n-         if Position.Node > N'Last then\n-            return False;\n-         end if;\n-\n-         if N (Position.Node).Next = Position.Node then\n-            return False;\n-         end if;\n-\n-         X := S.Content.Buckets\n-           (Element_Keys.Index (S.Content, N (Position.Node).Element));\n-\n-         for J in 1 .. S.Content.Length loop\n-            if X = Position.Node then\n-               return True;\n-            end if;\n-\n-            if X = 0 then\n-               return False;\n-            end if;\n-\n-            if X = N (X).Next then  --  to prevent unnecessary looping\n-               return False;\n-            end if;\n-\n-            X := N (X).Next;\n-         end loop;\n-\n-         return False;\n-      end;\n-   end Vet;\n-\n-end Ada.Containers.Formal_Hashed_Sets;"}, {"sha": "633ed20841d6778f35521987f033cccf0f4e47a8", "filename": "gcc/ada/libgnat/a-cfhase.ads", "status": "modified", "additions": 5, "deletions": 1468, "changes": 1473, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fa-cfhase.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fa-cfhase.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cfhase.ads?ref=13de60fb8e26a874dd58089286a0ea99a90972c8", "patch": "@@ -29,1475 +29,12 @@\n -- <http://www.gnu.org/licenses/>.                                          --\n ------------------------------------------------------------------------------\n \n---  This spec is derived from package Ada.Containers.Bounded_Hashed_Sets in the\n---  Ada 2012 RM. The modifications are meant to facilitate formal proofs by\n---  making it easier to express properties, and by making the specification of\n---  this unit compatible with SPARK 2014. Note that the API of this unit may be\n---  subject to incompatible changes as SPARK 2014 evolves.\n-\n---  The modifications are:\n-\n---    A parameter for the container is added to every function reading the\n---    content of a container: Element, Next, Query_Element, Has_Element, Key,\n---    Iterate, Equivalent_Elements. This change is motivated by the need to\n---    have cursors which are valid on different containers (typically a\n---    container C and its previous version C'Old) for expressing properties,\n---    which is not possible if cursors encapsulate an access to the underlying\n---    container.\n-\n-with Ada.Containers.Functional_Maps;\n-with Ada.Containers.Functional_Sets;\n-with Ada.Containers.Functional_Vectors;\n-with Ada.Numerics.Big_Numbers.Big_Integers;\n-use Ada.Numerics.Big_Numbers.Big_Integers;\n-private with Ada.Containers.Hash_Tables;\n-\n generic\n-   type Element_Type is private;\n-\n-   with function Hash (Element : Element_Type) return Hash_Type;\n-\n-   with function Equivalent_Elements\n-     (Left  : Element_Type;\n-      Right : Element_Type) return Boolean is \"=\";\n-\n-package Ada.Containers.Formal_Hashed_Sets with\n-  SPARK_Mode,\n-  Annotate => (GNATprove, Always_Return)\n-is\n-\n-   --  Contracts in this unit are meant for analysis only, not for run-time\n-   --  checking.\n-\n-   pragma Assertion_Policy (Pre => Ignore);\n-   pragma Assertion_Policy (Post => Ignore);\n-   pragma Assertion_Policy (Contract_Cases => Ignore);\n-   pragma Annotate (CodePeer, Skip_Analysis);\n-\n-   --  Convert Count_Type to Big_Interger.\n-\n-   package Conversions is new Signed_Conversions (Int => Count_Type);\n-\n-   function Big (J : Count_Type) return Big_Integer renames\n-     Conversions.To_Big_Integer;\n-\n-   type Set (Capacity : Count_Type; Modulus : Hash_Type) is private with\n-     Iterable => (First       => First,\n-                  Next        => Next,\n-                  Has_Element => Has_Element,\n-                  Element     => Element),\n-     Default_Initial_Condition => Is_Empty (Set);\n-   pragma Preelaborable_Initialization (Set);\n-\n-   type Cursor is record\n-      Node : Count_Type;\n-   end record;\n-\n-   No_Element : constant Cursor := (Node => 0);\n-\n-   function Length (Container : Set) return Count_Type with\n-     Global => null,\n-     Post   => Length'Result <= Container.Capacity;\n-\n-   pragma Unevaluated_Use_Of_Old (Allow);\n-\n-   package Formal_Model with Ghost is\n-      subtype Positive_Count_Type is Count_Type range 1 .. Count_Type'Last;\n-\n-      package M is new Ada.Containers.Functional_Sets\n-        (Element_Type    => Element_Type,\n-         Equivalent_Elements => Equivalent_Elements);\n-\n-      function \"=\"\n-        (Left  : M.Set;\n-         Right : M.Set) return Boolean renames M.\"=\";\n-\n-      function \"<=\"\n-        (Left  : M.Set;\n-         Right : M.Set) return Boolean renames M.\"<=\";\n-\n-      package E is new Ada.Containers.Functional_Vectors\n-        (Element_Type => Element_Type,\n-         Index_Type   => Positive_Count_Type);\n-\n-      function \"=\"\n-        (Left  : E.Sequence;\n-         Right : E.Sequence) return Boolean renames E.\"=\";\n-\n-      function \"<\"\n-        (Left  : E.Sequence;\n-         Right : E.Sequence) return Boolean renames E.\"<\";\n-\n-      function \"<=\"\n-        (Left  : E.Sequence;\n-         Right : E.Sequence) return Boolean renames E.\"<=\";\n-\n-      function Find\n-        (Container : E.Sequence;\n-         Item      : Element_Type) return Count_Type\n-      --  Search for Item in Container\n-\n-      with\n-        Global => null,\n-        Post =>\n-          (if Find'Result > 0 then\n-              Find'Result <= E.Length (Container)\n-                and Equivalent_Elements\n-                      (Item, E.Get (Container, Find'Result)));\n-\n-      function E_Elements_Included\n-        (Left  : E.Sequence;\n-         Right : E.Sequence) return Boolean\n-      --  The elements of Left are contained in Right\n-\n-      with\n-        Global => null,\n-        Post   =>\n-          E_Elements_Included'Result =\n-            (for all I in 1 .. E.Length (Left) =>\n-              Find (Right, E.Get (Left, I)) > 0\n-                and then E.Get (Right, Find (Right, E.Get (Left, I))) =\n-                         E.Get (Left, I));\n-      pragma Annotate (GNATprove, Inline_For_Proof, E_Elements_Included);\n-\n-      function E_Elements_Included\n-        (Left  : E.Sequence;\n-         Model : M.Set;\n-         Right : E.Sequence) return Boolean\n-      --  The elements of Container contained in Model are in Right\n-\n-      with\n-        Global => null,\n-        Post   =>\n-          E_Elements_Included'Result =\n-            (for all I in 1 .. E.Length (Left) =>\n-              (if M.Contains (Model, E.Get (Left, I)) then\n-                  Find (Right, E.Get (Left, I)) > 0\n-                    and then E.Get (Right, Find (Right, E.Get (Left, I))) =\n-                             E.Get (Left, I)));\n-      pragma Annotate (GNATprove, Inline_For_Proof, E_Elements_Included);\n-\n-      function E_Elements_Included\n-        (Container : E.Sequence;\n-         Model     : M.Set;\n-         Left      : E.Sequence;\n-         Right     : E.Sequence) return Boolean\n-      --  The elements of Container contained in Model are in Left and others\n-      --  are in Right.\n-\n-      with\n-        Global => null,\n-        Post   =>\n-          E_Elements_Included'Result =\n-            (for all I in 1 .. E.Length (Container) =>\n-              (if M.Contains (Model, E.Get (Container, I)) then\n-                  Find (Left, E.Get (Container, I)) > 0\n-                    and then E.Get (Left, Find (Left, E.Get (Container, I))) =\n-                             E.Get (Container, I)\n-               else\n-                  Find (Right, E.Get (Container, I)) > 0\n-                    and then E.Get\n-                               (Right, Find (Right, E.Get (Container, I))) =\n-                             E.Get (Container, I)));\n-      pragma Annotate (GNATprove, Inline_For_Proof, E_Elements_Included);\n-\n-      package P is new Ada.Containers.Functional_Maps\n-        (Key_Type                       => Cursor,\n-         Element_Type                   => Positive_Count_Type,\n-         Equivalent_Keys                => \"=\",\n-         Enable_Handling_Of_Equivalence => False);\n-\n-      function \"=\"\n-        (Left  : P.Map;\n-         Right : P.Map) return Boolean renames P.\"=\";\n-\n-      function \"<=\"\n-        (Left  : P.Map;\n-         Right : P.Map) return Boolean renames P.\"<=\";\n-\n-      function Mapping_Preserved\n-        (E_Left  : E.Sequence;\n-         E_Right : E.Sequence;\n-         P_Left  : P.Map;\n-         P_Right : P.Map) return Boolean\n-      with\n-        Ghost,\n-        Global => null,\n-        Post   =>\n-          (if Mapping_Preserved'Result then\n-\n-             --  Right contains all the cursors of Left\n-\n-             P.Keys_Included (P_Left, P_Right)\n-\n-               --  Right contains all the elements of Left\n-\n-               and E_Elements_Included (E_Left, E_Right)\n-\n-               --  Mappings from cursors to elements induced by E_Left, P_Left\n-               --  and E_Right, P_Right are the same.\n-\n-               and (for all C of P_Left =>\n-                     E.Get (E_Left, P.Get (P_Left, C)) =\n-                     E.Get (E_Right, P.Get (P_Right, C))));\n-\n-      function Mapping_Preserved_Except\n-        (E_Left   : E.Sequence;\n-         E_Right  : E.Sequence;\n-         P_Left   : P.Map;\n-         P_Right  : P.Map;\n-         Position : Cursor) return Boolean\n-      with\n-        Ghost,\n-        Global => null,\n-        Post   =>\n-          (if Mapping_Preserved_Except'Result then\n-\n-             --  Right contains all the cursors of Left\n-\n-             P.Keys_Included (P_Left, P_Right)\n-\n-               --  Mappings from cursors to elements induced by E_Left, P_Left\n-               --  and E_Right, P_Right are the same except for Position.\n-\n-               and (for all C of P_Left =>\n-                     (if C /= Position then\n-                         E.Get (E_Left, P.Get (P_Left, C)) =\n-                         E.Get (E_Right, P.Get (P_Right, C)))));\n-\n-      function Model (Container : Set) return M.Set with\n-      --  The high-level model of a set is a set of elements. Neither cursors\n-      --  nor order of elements are represented in this model. Elements are\n-      --  modeled up to equivalence.\n-\n-        Ghost,\n-        Global => null,\n-        Post   => M.Length (Model'Result) = Big (Length (Container));\n-\n-      function Elements (Container : Set) return E.Sequence with\n-      --  The Elements sequence represents the underlying list structure of\n-      --  sets that is used for iteration. It stores the actual values of\n-      --  elements in the set. It does not model cursors.\n-\n-        Ghost,\n-        Global => null,\n-        Post   =>\n-          E.Length (Elements'Result) = Length (Container)\n-\n-            --  It only contains keys contained in Model\n-\n-            and (for all Item of Elements'Result =>\n-                  M.Contains (Model (Container), Item))\n-\n-            --  It contains all the elements contained in Model\n-\n-            and (for all Item of Model (Container) =>\n-                  (Find (Elements'Result, Item) > 0\n-                    and then Equivalent_Elements\n-                               (E.Get (Elements'Result,\n-                                       Find (Elements'Result, Item)),\n-                                Item)))\n-\n-            --  It has no duplicate\n-\n-            and (for all I in 1 .. Length (Container) =>\n-                  Find (Elements'Result, E.Get (Elements'Result, I)) = I)\n-\n-            and (for all I in 1 .. Length (Container) =>\n-                  (for all J in 1 .. Length (Container) =>\n-                    (if Equivalent_Elements\n-                          (E.Get (Elements'Result, I),\n-                           E.Get (Elements'Result, J))\n-                     then I = J)));\n-      pragma Annotate (GNATprove, Iterable_For_Proof, \"Model\", Elements);\n-\n-      function Positions (Container : Set) return P.Map with\n-      --  The Positions map is used to model cursors. It only contains valid\n-      --  cursors and maps them to their position in the container.\n-\n-        Ghost,\n-        Global => null,\n-        Post   =>\n-          not P.Has_Key (Positions'Result, No_Element)\n-\n-            --  Positions of cursors are smaller than the container's length\n-\n-            and then\n-              (for all I of Positions'Result =>\n-                P.Get (Positions'Result, I) in 1 .. Length (Container)\n-\n-            --  No two cursors have the same position. Note that we do not\n-            --  state that there is a cursor in the map for each position, as\n-            --  it is rarely needed.\n-\n-            and then\n-              (for all J of Positions'Result =>\n-                (if P.Get (Positions'Result, I) = P.Get (Positions'Result, J)\n-                 then I = J)));\n-\n-      procedure Lift_Abstraction_Level (Container : Set) with\n-        --  Lift_Abstraction_Level is a ghost procedure that does nothing but\n-        --  assume that we can access the same elements by iterating over\n-        --  positions or cursors.\n-        --  This information is not generally useful except when switching from\n-        --  a low-level, cursor-aware view of a container, to a high-level,\n-        --  position-based view.\n-\n-        Ghost,\n-        Global => null,\n-        Post   =>\n-          (for all Item of Elements (Container) =>\n-            (for some I of Positions (Container) =>\n-              E.Get (Elements (Container), P.Get (Positions (Container), I)) =\n-                Item));\n-\n-      function Contains\n-        (C : M.Set;\n-         K : Element_Type) return Boolean renames M.Contains;\n-      --  To improve readability of contracts, we rename the function used to\n-      --  search for an element in the model to Contains.\n-\n-   end Formal_Model;\n-   use Formal_Model;\n-\n-   Empty_Set : constant Set;\n-\n-   function \"=\" (Left, Right : Set) return Boolean with\n-     Global => null,\n-     Post   =>\n-         \"=\"'Result =\n-           (Length (Left) = Length (Right)\n-             and E_Elements_Included (Elements (Left), Elements (Right)))\n-       and\n-         \"=\"'Result =\n-           (E_Elements_Included (Elements (Left), Elements (Right))\n-             and E_Elements_Included (Elements (Right), Elements (Left)));\n-   --  For each element in Left, set equality attempts to find the equal\n-   --  element in Right; if a search fails, then set equality immediately\n-   --  returns False. The search works by calling Hash to find the bucket in\n-   --  the Right set that corresponds to the Left element. If the bucket is\n-   --  non-empty, the search calls the generic formal element equality operator\n-   --  to compare the element (in Left) to the element of each node in the\n-   --  bucket (in Right); the search terminates when a matching node in the\n-   --  bucket is found, or the nodes in the bucket are exhausted. (Note that\n-   --  element equality is called here, not Equivalent_Elements. Set equality\n-   --  is the only operation in which element equality is used. Compare set\n-   --  equality to Equivalent_Sets, which does call Equivalent_Elements.)\n-\n-   function Equivalent_Sets (Left, Right : Set) return Boolean with\n-     Global => null,\n-     Post   => Equivalent_Sets'Result = (Model (Left) = Model (Right));\n-   --  Similar to set equality, with the difference that the element in Left is\n-   --  compared to the elements in Right using the generic formal\n-   --  Equivalent_Elements operation instead of element equality.\n-\n-   function To_Set (New_Item : Element_Type) return Set with\n-     Global => null,\n-     Post   =>\n-       M.Is_Singleton (Model (To_Set'Result), New_Item)\n-         and Length (To_Set'Result) = 1\n-         and E.Get (Elements (To_Set'Result), 1) = New_Item;\n-   --  Constructs a singleton set comprising New_Element. To_Set calls Hash to\n-   --  determine the bucket for New_Item.\n-\n-   function Capacity (Container : Set) return Count_Type with\n-     Global => null,\n-     Post   => Capacity'Result = Container.Capacity;\n-   --  Returns the current capacity of the set. Capacity is the maximum length\n-   --  before which rehashing in guaranteed not to occur.\n-\n-   procedure Reserve_Capacity\n-     (Container : in out Set;\n-      Capacity  : Count_Type)\n-   with\n-     Global => null,\n-     Pre    => Capacity <= Container.Capacity,\n-     Post   =>\n-       Model (Container) = Model (Container)'Old\n-         and Length (Container)'Old = Length (Container)\n-\n-         --  Actual elements are preserved\n-\n-         and E_Elements_Included\n-              (Elements (Container), Elements (Container)'Old)\n-         and E_Elements_Included\n-              (Elements (Container)'Old, Elements (Container));\n-   --  If the value of the Capacity actual parameter is less or equal to\n-   --  Container.Capacity, then the operation has no effect.  Otherwise it\n-   --  raises Capacity_Error (as no expansion of capacity is possible for a\n-   --  bounded form).\n-\n-   function Is_Empty (Container : Set) return Boolean with\n-     Global => null,\n-     Post   => Is_Empty'Result = (Length (Container) = 0);\n-   --  Equivalent to Length (Container) = 0\n-\n-   procedure Clear (Container : in out Set) with\n-     Global => null,\n-     Post   => Length (Container) = 0 and M.Is_Empty (Model (Container));\n-   --  Removes all of the items from the set. This will deallocate all memory\n-   --  associated with this set.\n-\n-   procedure Assign (Target : in out Set; Source : Set) with\n-     Global => null,\n-     Pre    => Target.Capacity >= Length (Source),\n-     Post   =>\n-       Model (Target) = Model (Source)\n-         and Length (Target) = Length (Source)\n-\n-         --  Actual elements are preserved\n-\n-         and E_Elements_Included (Elements (Target), Elements (Source))\n-         and E_Elements_Included (Elements (Source), Elements (Target));\n-   --  If Target denotes the same object as Source, then the operation has no\n-   --  effect. If the Target capacity is less than the Source length, then\n-   --  Assign raises Capacity_Error.  Otherwise, Assign clears Target and then\n-   --  copies the (active) elements from Source to Target.\n-\n-   function Copy\n-     (Source   : Set;\n-      Capacity : Count_Type := 0) return Set\n-   with\n-     Global => null,\n-     Pre    => Capacity = 0 or else Capacity >= Source.Capacity,\n-     Post   =>\n-       Model (Copy'Result) = Model (Source)\n-         and Elements (Copy'Result) = Elements (Source)\n-         and Positions (Copy'Result) = Positions (Source)\n-         and (if Capacity = 0 then\n-                 Copy'Result.Capacity = Source.Capacity\n-              else\n-                 Copy'Result.Capacity = Capacity);\n-   --  Constructs a new set object whose elements correspond to Source.  If the\n-   --  Capacity parameter is 0, then the capacity of the result is the same as\n-   --  the length of Source. If the Capacity parameter is equal or greater than\n-   --  the length of Source, then the capacity of the result is the specified\n-   --  value. Otherwise, Copy raises Capacity_Error. If the Modulus parameter\n-   --  is 0, then the modulus of the result is the value returned by a call to\n-   --  Default_Modulus with the capacity parameter determined as above;\n-   --  otherwise the modulus of the result is the specified value.\n-\n-   function Element\n-     (Container : Set;\n-      Position  : Cursor) return Element_Type\n-   with\n-     Global => null,\n-     Pre    => Has_Element (Container, Position),\n-     Post   =>\n-       Element'Result =\n-         E.Get (Elements (Container), P.Get (Positions (Container), Position));\n-   pragma Annotate (GNATprove, Inline_For_Proof, Element);\n-\n-   procedure Replace_Element\n-     (Container : in out Set;\n-      Position  : Cursor;\n-      New_Item  : Element_Type)\n-   with\n-     Global => null,\n-     Pre    => Has_Element (Container, Position),\n-     Post   =>\n-       Length (Container) = Length (Container)'Old\n-\n-          --  Position now maps to New_Item\n-\n-          and Element (Container, Position) = New_Item\n-\n-          --  New_Item is contained in Container\n-\n-          and Contains (Model (Container), New_Item)\n-\n-          --  Other elements are preserved\n-\n-          and M.Included_Except\n-                (Model (Container)'Old,\n-                 Model (Container),\n-                 Element (Container, Position)'Old)\n-          and M.Included_Except\n-                (Model (Container),\n-                 Model (Container)'Old,\n-                 New_Item)\n-\n-          --  Mapping from cursors to elements is preserved\n-\n-          and Mapping_Preserved_Except\n-                (E_Left   => Elements (Container)'Old,\n-                 E_Right  => Elements (Container),\n-                 P_Left   => Positions (Container)'Old,\n-                 P_Right  => Positions (Container),\n-                 Position => Position)\n-          and Positions (Container) = Positions (Container)'Old;\n-\n-   function Constant_Reference\n-     (Container : aliased Set;\n-      Position  : Cursor) return not null access constant Element_Type\n-   with\n-     Global => null,\n-     Pre    => Has_Element (Container, Position),\n-     Post   =>\n-       Constant_Reference'Result.all =\n-         E.Get (Elements (Container), P.Get (Positions (Container), Position));\n-\n-   procedure Move (Target : in out Set; Source : in out Set) with\n-     Global => null,\n-     Pre    => Target.Capacity >= Length (Source),\n-     Post   =>\n-       Length (Source) = 0\n-         and Model (Target) = Model (Source)'Old\n-         and Length (Target) = Length (Source)'Old\n-\n-         --  Actual elements are preserved\n-\n-         and E_Elements_Included (Elements (Target), Elements (Source)'Old)\n-         and E_Elements_Included (Elements (Source)'Old, Elements (Target));\n-   --  Clears Target (if it's not empty), and then moves (not copies) the\n-   --  buckets array and nodes from Source to Target.\n-\n-   procedure Insert\n-     (Container : in out Set;\n-      New_Item  : Element_Type;\n-      Position  : out Cursor;\n-      Inserted  : out Boolean)\n-   with\n-     Global         => null,\n-     Pre            =>\n-       Length (Container) < Container.Capacity\n-         or Contains (Container, New_Item),\n-     Post           =>\n-       Contains (Container, New_Item)\n-         and Has_Element (Container, Position)\n-         and Equivalent_Elements (Element (Container, Position), New_Item),\n-     Contract_Cases =>\n-\n-       --  If New_Item is already in Container, it is not modified and Inserted\n-       --  is set to False.\n-\n-       (Contains (Container, New_Item) =>\n-          not Inserted\n-            and Model (Container) = Model (Container)'Old\n-            and Elements (Container) = Elements (Container)'Old\n-            and Positions (Container) = Positions (Container)'Old,\n-\n-        --  Otherwise, New_Item is inserted in Container and Inserted is set to\n-        --  True.\n-\n-        others =>\n-          Inserted\n-            and Length (Container) = Length (Container)'Old + 1\n-\n-            --  Position now maps to New_Item\n-\n-            and Element (Container, Position) = New_Item\n-\n-            --  Other elements are preserved\n-\n-            and Model (Container)'Old <= Model (Container)\n-            and M.Included_Except\n-                  (Model (Container),\n-                   Model (Container)'Old,\n-                   New_Item)\n-\n-            --  Mapping from cursors to elements is preserved\n-\n-            and Mapping_Preserved\n-                  (E_Left  => Elements (Container)'Old,\n-                   E_Right => Elements (Container),\n-                   P_Left  => Positions (Container)'Old,\n-                   P_Right => Positions (Container))\n-            and P.Keys_Included_Except\n-                  (Positions (Container),\n-                   Positions (Container)'Old,\n-                   Position));\n-   --  Conditionally inserts New_Item into the set. If New_Item is already in\n-   --  the set, then Inserted returns False and Position designates the node\n-   --  containing the existing element (which is not modified). If New_Item is\n-   --  not already in the set, then Inserted returns True and Position\n-   --  designates the newly-inserted node containing New_Item. The search for\n-   --  an existing element works as follows. Hash is called to determine\n-   --  New_Item's bucket; if the bucket is non-empty, then Equivalent_Elements\n-   --  is called to compare New_Item to the element of each node in that\n-   --  bucket. If the bucket is empty, or there were no equivalent elements in\n-   --  the bucket, the search \"fails\" and the New_Item is inserted in the set\n-   --  (and Inserted returns True); otherwise, the search \"succeeds\" (and\n-   --  Inserted returns False).\n-\n-   procedure Insert  (Container : in out Set; New_Item : Element_Type) with\n-     Global => null,\n-     Pre    => Length (Container) < Container.Capacity\n-                 and then (not Contains (Container, New_Item)),\n-     Post   =>\n-       Length (Container) = Length (Container)'Old + 1\n-         and Contains (Container, New_Item)\n-         and Element (Container, Find (Container, New_Item)) = New_Item\n-\n-         --  Other elements are preserved\n-\n-         and Model (Container)'Old <= Model (Container)\n-         and M.Included_Except\n-               (Model (Container),\n-                Model (Container)'Old,\n-                New_Item)\n-\n-         --  Mapping from cursors to elements is preserved\n-\n-         and Mapping_Preserved\n-               (E_Left  => Elements (Container)'Old,\n-                E_Right => Elements (Container),\n-                P_Left  => Positions (Container)'Old,\n-                P_Right => Positions (Container))\n-         and P.Keys_Included_Except\n-               (Positions (Container),\n-                Positions (Container)'Old,\n-                Find (Container, New_Item));\n-   --  Attempts to insert New_Item into the set, performing the usual insertion\n-   --  search (which involves calling both Hash and Equivalent_Elements); if\n-   --  the search succeeds (New_Item is equivalent to an element already in the\n-   --  set, and so was not inserted), then this operation raises\n-   --  Constraint_Error. (This version of Insert is similar to Replace, but\n-   --  having the opposite exception behavior. It is intended for use when you\n-   --  want to assert that the item is not already in the set.)\n-\n-   procedure Include (Container : in out Set; New_Item : Element_Type) with\n-     Global         => null,\n-     Pre            =>\n-       Length (Container) < Container.Capacity\n-         or Contains (Container, New_Item),\n-     Post           =>\n-       Contains (Container, New_Item)\n-         and Element (Container, Find (Container, New_Item)) = New_Item,\n-     Contract_Cases =>\n-\n-       --  If an element equivalent to New_Item is already in Container, it is\n-       --  replaced by New_Item.\n-\n-       (Contains (Container, New_Item) =>\n-\n-          --  Elements are preserved modulo equivalence\n-\n-          Model (Container) = Model (Container)'Old\n-\n-            --  Cursors are preserved\n-\n-            and Positions (Container) = Positions (Container)'Old\n-\n-            --  The actual value of other elements is preserved\n-\n-            and E.Equal_Except\n-                  (Elements (Container)'Old,\n-                   Elements (Container),\n-                   P.Get (Positions (Container), Find (Container, New_Item))),\n-\n-        --  Otherwise, New_Item is inserted in Container\n-\n-        others =>\n-          Length (Container) = Length (Container)'Old + 1\n-\n-            --  Other elements are preserved\n-\n-            and Model (Container)'Old <= Model (Container)\n-            and M.Included_Except\n-                  (Model (Container),\n-                   Model (Container)'Old,\n-                   New_Item)\n-\n-            --  Mapping from cursors to elements is preserved\n-\n-            and Mapping_Preserved\n-                  (E_Left  => Elements (Container)'Old,\n-                   E_Right => Elements (Container),\n-                   P_Left  => Positions (Container)'Old,\n-                   P_Right => Positions (Container))\n-            and P.Keys_Included_Except\n-                  (Positions (Container),\n-                   Positions (Container)'Old,\n-                   Find (Container, New_Item)));\n-   --  Attempts to insert New_Item into the set. If an element equivalent to\n-   --  New_Item is already in the set (the insertion search succeeded, and\n-   --  hence New_Item was not inserted), then the value of New_Item is assigned\n-   --  to the existing element. (This insertion operation only raises an\n-   --  exception if cursor tampering occurs. It is intended for use when you\n-   --  want to insert the item in the set, and you don't care whether an\n-   --  equivalent element is already present.)\n-\n-   procedure Replace (Container : in out Set; New_Item : Element_Type) with\n-     Global => null,\n-     Pre    => Contains (Container, New_Item),\n-     Post   =>\n-\n-       --  Elements are preserved modulo equivalence\n-\n-       Model (Container) = Model (Container)'Old\n-         and Contains (Container, New_Item)\n-\n-         --  Cursors are preserved\n-\n-         and Positions (Container) = Positions (Container)'Old\n-\n-         --  The element equivalent to New_Item in Container is replaced by\n-         --  New_Item.\n-\n-         and Element (Container, Find (Container, New_Item)) = New_Item\n-         and E.Equal_Except\n-               (Elements (Container)'Old,\n-                Elements (Container),\n-                P.Get (Positions (Container), Find (Container, New_Item)));\n-   --  Searches for New_Item in the set; if the search fails (because an\n-   --  equivalent element was not in the set), then it raises\n-   --  Constraint_Error. Otherwise, the existing element is assigned the value\n-   --  New_Item. (This is similar to Insert, but with the opposite exception\n-   --  behavior. It is intended for use when you want to assert that the item\n-   --  is already in the set.)\n-\n-   procedure Exclude (Container : in out Set; Item : Element_Type) with\n-     Global         => null,\n-     Post           => not Contains (Container, Item),\n-     Contract_Cases =>\n-\n-       --  If Item is not in Container, nothing is changed\n-\n-       (not Contains (Container, Item) =>\n-          Model (Container) = Model (Container)'Old\n-            and Elements (Container) = Elements (Container)'Old\n-            and Positions (Container) = Positions (Container)'Old,\n-\n-        --  Otherwise, Item is removed from Container\n-\n-        others =>\n-          Length (Container) = Length (Container)'Old - 1\n-\n-            --  Other elements are preserved\n-\n-            and Model (Container) <= Model (Container)'Old\n-            and M.Included_Except\n-                  (Model (Container)'Old,\n-                   Model (Container),\n-                   Item)\n-\n-            --  Mapping from cursors to elements is preserved\n-\n-            and Mapping_Preserved\n-                  (E_Left  => Elements (Container),\n-                   E_Right => Elements (Container)'Old,\n-                   P_Left  => Positions (Container),\n-                   P_Right => Positions (Container)'Old)\n-            and P.Keys_Included_Except\n-                  (Positions (Container)'Old,\n-                   Positions (Container),\n-                   Find (Container, Item)'Old));\n-   --  Searches for Item in the set, and if found, removes its node from the\n-   --  set and then deallocates it. The search works as follows. The operation\n-   --  calls Hash to determine the item's bucket; if the bucket is not empty,\n-   --  it calls Equivalent_Elements to compare Item to the element of each node\n-   --  in the bucket. (This is the deletion analog of Include. It is intended\n-   --  for use when you want to remove the item from the set, but don't care\n-   --  whether the item is already in the set.)\n-\n-   procedure Delete  (Container : in out Set; Item : Element_Type) with\n-     Global => null,\n-     Pre    => Contains (Container, Item),\n-     Post   =>\n-       Length (Container) = Length (Container)'Old - 1\n-\n-         --  Item is no longer in Container\n-\n-         and not Contains (Container, Item)\n-\n-         --  Other elements are preserved\n-\n-         and Model (Container) <= Model (Container)'Old\n-         and M.Included_Except\n-               (Model (Container)'Old,\n-                Model (Container),\n-                Item)\n-\n-         --  Mapping from cursors to elements is preserved\n-\n-         and Mapping_Preserved\n-               (E_Left  => Elements (Container),\n-                E_Right => Elements (Container)'Old,\n-                P_Left  => Positions (Container),\n-                P_Right => Positions (Container)'Old)\n-         and P.Keys_Included_Except\n-               (Positions (Container)'Old,\n-                Positions (Container),\n-                Find (Container, Item)'Old);\n-   --  Searches for Item in the set (which involves calling both Hash and\n-   --  Equivalent_Elements). If the search fails, then the operation raises\n-   --  Constraint_Error. Otherwise it removes the node from the set and then\n-   --  deallocates it. (This is the deletion analog of non-conditional\n-   --  Insert. It is intended for use when you want to assert that the item is\n-   --  already in the set.)\n-\n-   procedure Delete (Container : in out Set; Position : in out Cursor) with\n-     Global  => null,\n-     Depends => (Container =>+ Position, Position => null),\n-     Pre     => Has_Element (Container, Position),\n-     Post    =>\n-       Position = No_Element\n-         and Length (Container) = Length (Container)'Old - 1\n-\n-         --  The element at position Position is no longer in Container\n-\n-         and not Contains (Container, Element (Container, Position)'Old)\n-         and not P.Has_Key (Positions (Container), Position'Old)\n-\n-         --  Other elements are preserved\n-\n-         and Model (Container) <= Model (Container)'Old\n-         and M.Included_Except\n-               (Model (Container)'Old,\n-                Model (Container),\n-                Element (Container, Position)'Old)\n-\n-         --  Mapping from cursors to elements is preserved\n-\n-         and Mapping_Preserved\n-               (E_Left  => Elements (Container),\n-                E_Right => Elements (Container)'Old,\n-                P_Left  => Positions (Container),\n-                P_Right => Positions (Container)'Old)\n-         and P.Keys_Included_Except\n-               (Positions (Container)'Old,\n-                Positions (Container),\n-                Position'Old);\n-   --  Removes the node designated by Position from the set, and then\n-   --  deallocates the node. The operation calls Hash to determine the bucket,\n-   --  and then compares Position to each node in the bucket until there's a\n-   --  match (it does not call Equivalent_Elements).\n-\n-   procedure Union (Target : in out Set; Source : Set) with\n-     Global => null,\n-     Pre    =>\n-       Length (Source) - Length (Target and Source) <=\n-         Target.Capacity - Length (Target),\n-     Post   =>\n-       Big (Length (Target)) = Big (Length (Target)'Old)\n-         - M.Num_Overlaps (Model (Target)'Old, Model (Source))\n-         + Big (Length (Source))\n-\n-         --  Elements already in Target are still in Target\n-\n-         and Model (Target)'Old <= Model (Target)\n-\n-         --  Elements of Source are included in Target\n-\n-         and Model (Source) <= Model (Target)\n-\n-         --  Elements of Target come from either Source or Target\n-\n-         and M.Included_In_Union\n-               (Model (Target), Model (Source), Model (Target)'Old)\n-\n-         --  Actual value of elements come from either Left or Right\n-\n-         and E_Elements_Included\n-               (Elements (Target),\n-                Model (Target)'Old,\n-                Elements (Target)'Old,\n-                Elements (Source))\n-\n-         and E_Elements_Included\n-               (Elements (Target)'Old, Model (Target)'Old, Elements (Target))\n-\n-         and E_Elements_Included\n-               (Elements (Source),\n-                Model (Target)'Old,\n-                Elements (Source),\n-                Elements (Target))\n-\n-         --  Mapping from cursors of Target to elements is preserved\n-\n-         and Mapping_Preserved\n-               (E_Left  => Elements (Target)'Old,\n-                E_Right => Elements (Target),\n-                P_Left  => Positions (Target)'Old,\n-                P_Right => Positions (Target));\n-   --  Iterates over the Source set, and conditionally inserts each element\n-   --  into Target.\n-\n-   function Union (Left, Right : Set) return Set with\n-     Global => null,\n-     Pre    => Length (Left) <= Count_Type'Last - Length (Right),\n-     Post   =>\n-       Big (Length (Union'Result)) = Big (Length (Left))\n-         - M.Num_Overlaps (Model (Left), Model (Right))\n-         + Big (Length (Right))\n-\n-         --  Elements of Left and Right are in the result of Union\n-\n-         and Model (Left) <= Model (Union'Result)\n-         and Model (Right) <= Model (Union'Result)\n-\n-         --  Elements of the result of union come from either Left or Right\n-\n-         and\n-           M.Included_In_Union\n-             (Model (Union'Result), Model (Left), Model (Right))\n-\n-         --  Actual value of elements come from either Left or Right\n-\n-         and E_Elements_Included\n-               (Elements (Union'Result),\n-                Model (Left),\n-                Elements (Left),\n-                Elements (Right))\n-\n-         and E_Elements_Included\n-               (Elements (Left), Model (Left), Elements (Union'Result))\n-\n-         and E_Elements_Included\n-               (Elements (Right),\n-                Model (Left),\n-                Elements (Right),\n-                Elements (Union'Result));\n-   --  The operation first copies the Left set to the result, and then iterates\n-   --  over the Right set to conditionally insert each element into the result.\n-\n-   function \"or\" (Left, Right : Set) return Set renames Union;\n-\n-   procedure Intersection (Target : in out Set; Source : Set) with\n-     Global => null,\n-     Post   =>\n-       Big (Length (Target)) =\n-         M.Num_Overlaps (Model (Target)'Old, Model (Source))\n-\n-         --  Elements of Target were already in Target\n-\n-         and Model (Target) <= Model (Target)'Old\n-\n-         --  Elements of Target are in Source\n-\n-         and Model (Target) <= Model (Source)\n-\n-         --  Elements both in Source and Target are in the intersection\n-\n-         and M.Includes_Intersection\n-               (Model (Target), Model (Source), Model (Target)'Old)\n-\n-         --  Actual value of elements of Target is preserved\n-\n-         and E_Elements_Included (Elements (Target), Elements (Target)'Old)\n-         and E_Elements_Included\n-               (Elements (Target)'Old, Model (Source), Elements (Target))\n-\n-         --  Mapping from cursors of Target to elements is preserved\n-\n-         and Mapping_Preserved\n-               (E_Left  => Elements (Target),\n-                E_Right => Elements (Target)'Old,\n-                P_Left  => Positions (Target),\n-                P_Right => Positions (Target)'Old);\n-   --  Iterates over the Target set (calling First and Next), calling Find to\n-   --  determine whether the element is in Source. If an equivalent element is\n-   --  not found in Source, the element is deleted from Target.\n-\n-   function Intersection (Left, Right : Set) return Set with\n-     Global => null,\n-     Post   =>\n-       Big (Length (Intersection'Result)) =\n-         M.Num_Overlaps (Model (Left), Model (Right))\n-\n-         --  Elements in the result of Intersection are in Left and Right\n-\n-         and Model (Intersection'Result) <= Model (Left)\n-         and Model (Intersection'Result) <= Model (Right)\n-\n-         --  Elements both in Left and Right are in the result of Intersection\n-\n-         and M.Includes_Intersection\n-               (Model (Intersection'Result), Model (Left), Model (Right))\n-\n-         --  Actual value of elements come from Left\n-\n-         and E_Elements_Included\n-               (Elements (Intersection'Result), Elements (Left))\n-\n-         and E_Elements_Included\n-               (Elements (Left), Model (Right),\n-                Elements (Intersection'Result));\n-   --  Iterates over the Left set, calling Find to determine whether the\n-   --  element is in Right. If an equivalent element is found, it is inserted\n-   --  into the result set.\n-\n-   function \"and\" (Left, Right : Set) return Set renames Intersection;\n-\n-   procedure Difference (Target : in out Set; Source : Set) with\n-     Global => null,\n-     Post   =>\n-       Big (Length (Target)) = Big (Length (Target)'Old) -\n-         M.Num_Overlaps (Model (Target)'Old, Model (Source))\n-\n-         --  Elements of Target were already in Target\n-\n-         and Model (Target) <= Model (Target)'Old\n-\n-         --  Elements of Target are not in Source\n-\n-         and M.No_Overlap (Model (Target), Model (Source))\n-\n-         --  Elements in Target but not in Source are in the difference\n-\n-         and M.Included_In_Union\n-               (Model (Target)'Old, Model (Target), Model (Source))\n-\n-         --  Actual value of elements of Target is preserved\n-\n-         and E_Elements_Included (Elements (Target), Elements (Target)'Old)\n-         and E_Elements_Included\n-               (Elements (Target)'Old, Model (Target), Elements (Target))\n-\n-         --  Mapping from cursors of Target to elements is preserved\n-\n-         and Mapping_Preserved\n-               (E_Left  => Elements (Target),\n-                E_Right => Elements (Target)'Old,\n-                P_Left  => Positions (Target),\n-                P_Right => Positions (Target)'Old);\n-   --  Iterates over the Source (calling First and Next), calling Find to\n-   --  determine whether the element is in Target. If an equivalent element is\n-   --  found, it is deleted from Target.\n-\n-   function Difference (Left, Right : Set) return Set with\n-     Global => null,\n-     Post   =>\n-       Big (Length (Difference'Result)) = Big (Length (Left)) -\n-         M.Num_Overlaps (Model (Left), Model (Right))\n-\n-         --  Elements of the result of Difference are in Left\n-\n-         and Model (Difference'Result) <= Model (Left)\n-\n-         --  Elements of the result of Difference are in Right\n-\n-         and M.No_Overlap (Model (Difference'Result), Model (Right))\n-\n-         --  Elements in Left but not in Right are in the difference\n-\n-         and M.Included_In_Union\n-               (Model (Left), Model (Difference'Result), Model (Right))\n-\n-         --  Actual value of elements come from Left\n-\n-         and E_Elements_Included\n-               (Elements (Difference'Result), Elements (Left))\n-\n-         and E_Elements_Included\n-               (Elements (Left),\n-                Model (Difference'Result),\n-                Elements (Difference'Result));\n-   --  Iterates over the Left set, calling Find to determine whether the\n-   --  element is in the Right set. If an equivalent element is not found, the\n-   --  element is inserted into the result set.\n-\n-   function \"-\" (Left, Right : Set) return Set renames Difference;\n-\n-   procedure Symmetric_Difference (Target : in out Set; Source : Set) with\n-     Global => null,\n-     Pre    =>\n-       Length (Source) - Length (Target and Source) <=\n-         Target.Capacity - Length (Target) + Length (Target and Source),\n-     Post   =>\n-       Big (Length (Target)) = Big (Length (Target)'Old) -\n-         2 * M.Num_Overlaps (Model (Target)'Old, Model (Source)) +\n-         Big (Length (Source))\n-\n-         --  Elements of the difference were not both in Source and in Target\n-\n-         and M.Not_In_Both (Model (Target), Model (Target)'Old, Model (Source))\n-\n-         --  Elements in Target but not in Source are in the difference\n-\n-         and M.Included_In_Union\n-               (Model (Target)'Old, Model (Target), Model (Source))\n-\n-         --  Elements in Source but not in Target are in the difference\n-\n-         and M.Included_In_Union\n-               (Model (Source), Model (Target), Model (Target)'Old)\n-\n-         --  Actual value of elements come from either Left or Right\n-\n-         and E_Elements_Included\n-               (Elements (Target),\n-                Model (Target)'Old,\n-                Elements (Target)'Old,\n-                Elements (Source))\n-\n-         and E_Elements_Included\n-               (Elements (Target)'Old, Model (Target), Elements (Target))\n-\n-         and E_Elements_Included\n-               (Elements (Source), Model (Target), Elements (Target));\n-   --  The operation iterates over the Source set, searching for the element\n-   --  in Target (calling Hash and Equivalent_Elements). If an equivalent\n-   --  element is found, it is removed from Target; otherwise it is inserted\n-   --  into Target.\n-\n-   function Symmetric_Difference (Left, Right : Set) return Set with\n-     Global => null,\n-     Pre    => Length (Left) <= Count_Type'Last - Length (Right),\n-     Post   =>\n-       Big (Length (Symmetric_Difference'Result)) = Big (Length (Left)) -\n-         2 * M.Num_Overlaps (Model (Left), Model (Right)) +\n-         Big (Length (Right))\n-\n-         --  Elements of the difference were not both in Left and Right\n-\n-         and M.Not_In_Both\n-               (Model (Symmetric_Difference'Result),\n-                Model (Left),\n-                Model (Right))\n-\n-         --  Elements in Left but not in Right are in the difference\n-\n-         and M.Included_In_Union\n-               (Model (Left),\n-                Model (Symmetric_Difference'Result),\n-                Model (Right))\n-\n-         --  Elements in Right but not in Left are in the difference\n-\n-         and M.Included_In_Union\n-               (Model (Right),\n-                Model (Symmetric_Difference'Result),\n-                Model (Left))\n-\n-         --  Actual value of elements come from either Left or Right\n-\n-         and E_Elements_Included\n-               (Elements (Symmetric_Difference'Result),\n-                Model (Left),\n-                Elements (Left),\n-                Elements (Right))\n-\n-         and E_Elements_Included\n-               (Elements (Left),\n-                Model (Symmetric_Difference'Result),\n-                Elements (Symmetric_Difference'Result))\n-\n-         and E_Elements_Included\n-               (Elements (Right),\n-                Model (Symmetric_Difference'Result),\n-                Elements (Symmetric_Difference'Result));\n-   --  The operation first iterates over the Left set. It calls Find to\n-   --  determine whether the element is in the Right set. If no equivalent\n-   --  element is found, the element from Left is inserted into the result. The\n-   --  operation then iterates over the Right set, to determine whether the\n-   --  element is in the Left set. If no equivalent element is found, the Right\n-   --  element is inserted into the result.\n-\n-   function \"xor\" (Left, Right : Set) return Set\n-     renames Symmetric_Difference;\n-\n-   function Overlap (Left, Right : Set) return Boolean with\n-     Global => null,\n-     Post   =>\n-       Overlap'Result = not (M.No_Overlap (Model (Left), Model (Right)));\n-   --  Iterates over the Left set (calling First and Next), calling Find to\n-   --  determine whether the element is in the Right set. If an equivalent\n-   --  element is found, the operation immediately returns True. The operation\n-   --  returns False if the iteration over Left terminates without finding any\n-   --  equivalent element in Right.\n-\n-   function Is_Subset (Subset : Set; Of_Set : Set) return Boolean with\n-     Global => null,\n-     Post   => Is_Subset'Result = (Model (Subset) <= Model (Of_Set));\n-   --  Iterates over Subset (calling First and Next), calling Find to determine\n-   --  whether the element is in Of_Set. If no equivalent element is found in\n-   --  Of_Set, the operation immediately returns False. The operation returns\n-   --  True if the iteration over Subset terminates without finding an element\n-   --  not in Of_Set (that is, every element in Subset is equivalent to an\n-   --  element in Of_Set).\n-\n-   function First (Container : Set) return Cursor with\n-     Global         => null,\n-     Contract_Cases =>\n-       (Length (Container) = 0 =>\n-          First'Result = No_Element,\n-\n-        others =>\n-          Has_Element (Container, First'Result)\n-            and P.Get (Positions (Container), First'Result) = 1);\n-   --  Returns a cursor that designates the first non-empty bucket, by\n-   --  searching from the beginning of the buckets array.\n-\n-   function Next (Container : Set; Position : Cursor) return Cursor with\n-     Global         => null,\n-     Pre            =>\n-       Has_Element (Container, Position) or else Position = No_Element,\n-     Contract_Cases =>\n-       (Position = No_Element\n-          or else P.Get (Positions (Container), Position) = Length (Container)\n-        =>\n-          Next'Result = No_Element,\n-\n-        others =>\n-          Has_Element (Container, Next'Result)\n-            and then P.Get (Positions (Container), Next'Result) =\n-                     P.Get (Positions (Container), Position) + 1);\n-   --  Returns a cursor that designates the node that follows the current one\n-   --  designated by Position. If Position designates the last node in its\n-   --  bucket, the operation calls Hash to compute the index of this bucket,\n-   --  and searches the buckets array for the first non-empty bucket, starting\n-   --  from that index; otherwise, it simply follows the link to the next node\n-   --  in the same bucket.\n-\n-   procedure Next (Container : Set; Position : in out Cursor) with\n-     Global         => null,\n-     Pre            =>\n-       Has_Element (Container, Position) or else Position = No_Element,\n-     Contract_Cases =>\n-       (Position = No_Element\n-          or else P.Get (Positions (Container), Position) = Length (Container)\n-        =>\n-          Position = No_Element,\n-\n-        others =>\n-          Has_Element (Container, Position)\n-            and then P.Get (Positions (Container), Position) =\n-                     P.Get (Positions (Container), Position'Old) + 1);\n-   --  Equivalent to Position := Next (Position)\n-\n-   function Find\n-     (Container : Set;\n-      Item      : Element_Type) return Cursor\n-   with\n-     Global         => null,\n-     Contract_Cases =>\n-\n-       --  If Item is not contained in Container, Find returns No_Element\n-\n-       (not Contains (Model (Container), Item) =>\n-          Find'Result = No_Element,\n-\n-        --  Otherwise, Find returns a valid cursor in Container\n-\n-        others =>\n-          P.Has_Key (Positions (Container), Find'Result)\n-            and P.Get (Positions (Container), Find'Result) =\n-                Find (Elements (Container), Item)\n-\n-            --  The element designated by the result of Find is Item\n-\n-            and Equivalent_Elements\n-                  (Element (Container, Find'Result), Item));\n-   --  Searches for Item in the set. Find calls Hash to determine the item's\n-   --  bucket; if the bucket is not empty, it calls Equivalent_Elements to\n-   --  compare Item to each element in the bucket. If the search succeeds, Find\n-   --  returns a cursor designating the node containing the equivalent element;\n-   --  otherwise, it returns No_Element.\n-\n-   function Contains (Container : Set; Item : Element_Type) return Boolean with\n-     Global => null,\n-     Post   => Contains'Result = Contains (Model (Container), Item);\n-   pragma Annotate (GNATprove, Inline_For_Proof, Contains);\n-\n-   function Has_Element (Container : Set; Position : Cursor) return Boolean\n-   with\n-     Global => null,\n-     Post   =>\n-       Has_Element'Result = P.Has_Key (Positions (Container), Position);\n-   pragma Annotate (GNATprove, Inline_For_Proof, Has_Element);\n-\n-   function Default_Modulus (Capacity : Count_Type) return Hash_Type with\n-     Global => null;\n-\n-   generic\n-      type Key_Type (<>) is private;\n-\n-      with function Key (Element : Element_Type) return Key_Type;\n-\n-      with function Hash (Key : Key_Type) return Hash_Type;\n-\n-      with function Equivalent_Keys (Left, Right : Key_Type) return Boolean;\n-\n-   package Generic_Keys with SPARK_Mode is\n-\n-      package Formal_Model with Ghost is\n-\n-         function M_Included_Except\n-           (Left  : M.Set;\n-            Right : M.Set;\n-            Key   : Key_Type) return Boolean\n-           with\n-             Global => null,\n-             Post   =>\n-               M_Included_Except'Result =\n-                 (for all E of Left =>\n-                   Contains (Right, E)\n-                     or Equivalent_Keys (Generic_Keys.Key (E), Key));\n-\n-      end Formal_Model;\n-      use Formal_Model;\n-\n-      function Key (Container : Set; Position : Cursor) return Key_Type with\n-        Global => null,\n-        Post   => Key'Result = Key (Element (Container, Position));\n-      pragma Annotate (GNATprove, Inline_For_Proof, Key);\n-\n-      function Element (Container : Set; Key : Key_Type) return Element_Type\n-      with\n-        Global => null,\n-        Pre    => Contains (Container, Key),\n-        Post   =>\n-          Element'Result = Element (Container, Find (Container, Key));\n-      pragma Annotate (GNATprove, Inline_For_Proof, Element);\n-\n-      procedure Replace\n-        (Container : in out Set;\n-         Key       : Key_Type;\n-         New_Item  : Element_Type)\n-      with\n-        Global => null,\n-        Pre    => Contains (Container, Key),\n-        Post   =>\n-          Length (Container) = Length (Container)'Old\n-\n-             --  Key now maps to New_Item\n-\n-             and Element (Container, Key) = New_Item\n-\n-             --  New_Item is contained in Container\n-\n-             and Contains (Model (Container), New_Item)\n-\n-             --  Other elements are preserved\n-\n-             and M_Included_Except\n-                   (Model (Container)'Old,\n-                    Model (Container),\n-                    Key)\n-             and M.Included_Except\n-                   (Model (Container),\n-                    Model (Container)'Old,\n-                    New_Item)\n-\n-             --  Mapping from cursors to elements is preserved\n-\n-             and Mapping_Preserved_Except\n-                   (E_Left   => Elements (Container)'Old,\n-                    E_Right  => Elements (Container),\n-                    P_Left   => Positions (Container)'Old,\n-                    P_Right  => Positions (Container),\n-                    Position => Find (Container, Key))\n-             and Positions (Container) = Positions (Container)'Old;\n-\n-      procedure Exclude (Container : in out Set; Key : Key_Type) with\n-        Global         => null,\n-        Post           => not Contains (Container, Key),\n-        Contract_Cases =>\n-\n-          --  If Key is not in Container, nothing is changed\n-\n-          (not Contains (Container, Key) =>\n-             Model (Container) = Model (Container)'Old\n-               and Elements (Container) = Elements (Container)'Old\n-               and Positions (Container) = Positions (Container)'Old,\n-\n-           --  Otherwise, Key is removed from Container\n-\n-           others =>\n-             Length (Container) = Length (Container)'Old - 1\n-\n-               --  Other elements are preserved\n-\n-               and Model (Container) <= Model (Container)'Old\n-               and M_Included_Except\n-                     (Model (Container)'Old,\n-                      Model (Container),\n-                      Key)\n-\n-               --  Mapping from cursors to elements is preserved\n-\n-               and Mapping_Preserved\n-                     (E_Left  => Elements (Container),\n-                      E_Right => Elements (Container)'Old,\n-                      P_Left  => Positions (Container),\n-                      P_Right => Positions (Container)'Old)\n-               and P.Keys_Included_Except\n-                     (Positions (Container)'Old,\n-                      Positions (Container),\n-                      Find (Container, Key)'Old));\n-\n-      procedure Delete (Container : in out Set; Key : Key_Type) with\n-        Global => null,\n-        Pre    => Contains (Container, Key),\n-        Post   =>\n-          Length (Container) = Length (Container)'Old - 1\n-\n-            --  Key is no longer in Container\n-\n-            and not Contains (Container, Key)\n-\n-            --  Other elements are preserved\n-\n-            and Model (Container) <= Model (Container)'Old\n-            and M_Included_Except\n-                  (Model (Container)'Old,\n-                   Model (Container),\n-                   Key)\n-\n-            --  Mapping from cursors to elements is preserved\n-\n-            and Mapping_Preserved\n-                  (E_Left  => Elements (Container),\n-                   E_Right => Elements (Container)'Old,\n-                   P_Left  => Positions (Container),\n-                   P_Right => Positions (Container)'Old)\n-            and P.Keys_Included_Except\n-                  (Positions (Container)'Old,\n-                   Positions (Container),\n-                   Find (Container, Key)'Old);\n-\n-      function Find (Container : Set; Key : Key_Type) return Cursor with\n-        Global         => null,\n-        Contract_Cases =>\n-\n-          --  If Key is not contained in Container, Find returns No_Element\n-\n-          ((for all E of Model (Container) =>\n-               not Equivalent_Keys (Key, Generic_Keys.Key (E))) =>\n-             Find'Result = No_Element,\n-\n-           --  Otherwise, Find returns a valid cursor in Container\n-\n-           others =>\n-             P.Has_Key (Positions (Container), Find'Result)\n-\n-               --  The key designated by the result of Find is Key\n-\n-               and Equivalent_Keys\n-                     (Generic_Keys.Key (Container, Find'Result), Key));\n-\n-      function Contains (Container : Set; Key : Key_Type) return Boolean with\n-        Global => null,\n-        Post   =>\n-          Contains'Result =\n-            (for some E of Model (Container) =>\n-              Equivalent_Keys (Key, Generic_Keys.Key (E)));\n-\n-   end Generic_Keys;\n-\n-private\n-   pragma SPARK_Mode (Off);\n-\n-   pragma Inline (Next);\n-\n-   type Node_Type is\n-      record\n-         Element     : aliased Element_Type;\n-         Next        : Count_Type;\n-         Has_Element : Boolean := False;\n-      end record;\n-\n-   package HT_Types is new\n-     Ada.Containers.Hash_Tables.Generic_Formal_Hash_Table_Types (Node_Type);\n-\n-   type Set (Capacity : Count_Type; Modulus : Hash_Type) is record\n-     Content : HT_Types.Hash_Table_Type (Capacity, Modulus);\n-   end record;\n-\n-   use HT_Types;\n+package Ada.Containers.Formal_Hashed_Sets with SPARK_Mode is\n \n-   Empty_Set : constant Set := (Capacity => 0, Modulus => 0, others => <>);\n+   pragma Compile_Time_Error\n+     (True,\n+      \"This package has been moved to the SPARK library shipped with any\"\n+      & \" SPARK release starting with version 23.\");\n \n end Ada.Containers.Formal_Hashed_Sets;"}, {"sha": "17e48d29e65fbd60403a55972d1ee932cd343e6a", "filename": "gcc/ada/libgnat/a-cfidll.adb", "status": "removed", "additions": 0, "deletions": 2054, "changes": 2054, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6da3cab7b0acf5dc363c85069bef716923ddf90c/gcc%2Fada%2Flibgnat%2Fa-cfidll.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6da3cab7b0acf5dc363c85069bef716923ddf90c/gcc%2Fada%2Flibgnat%2Fa-cfidll.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cfidll.adb?ref=6da3cab7b0acf5dc363c85069bef716923ddf90c", "patch": "@@ -1,2054 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT LIBRARY COMPONENTS                          --\n---                                                                          --\n---           ADA.CONTAINERS.FORMAL_INDEFINITE_DOUBLY_LINKED_LISTS           --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 2022-2022, Free Software Foundation, Inc.         --\n---                                                                          --\n--- This specification is derived from the Ada Reference Manual for use with --\n--- GNAT. The copyright notice above, and the license provisions that follow --\n--- apply solely to the  contents of the part following the private keyword. --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n-------------------------------------------------------------------------------\n-\n-with Ada.Unchecked_Deallocation;\n-\n-with Ada.Containers.Stable_Sorting; use Ada.Containers.Stable_Sorting;\n-\n-with System; use type System.Address;\n-\n-with Ada.Numerics.Big_Numbers.Big_Integers;\n-use Ada.Numerics.Big_Numbers.Big_Integers;\n-\n-package body Ada.Containers.Formal_Indefinite_Doubly_Linked_Lists with\n-  SPARK_Mode => Off\n-is\n-   --  Convert Count_Type to Big_Integer\n-\n-   package Conversions is new Signed_Conversions (Int => Count_Type);\n-   use Conversions;\n-\n-   -----------------------\n-   -- Local Subprograms --\n-   -----------------------\n-\n-   procedure Allocate\n-     (Container : in out List;\n-      New_Item  : Element_Type;\n-      New_Node  : out Count_Type);\n-\n-   procedure Allocate\n-     (Container : in out List;\n-      New_Node  : out Count_Type);\n-\n-   procedure Free (Container : in out List; X : Count_Type);\n-\n-   procedure Insert_Internal\n-     (Container : in out List;\n-      Before    : Count_Type;\n-      New_Node  : Count_Type);\n-\n-   function Vet (L : List; Position : Cursor) return Boolean with Inline;\n-\n-   procedure Resize (Container : in out List) with\n-   --  Add more room in the internal array\n-\n-     Global => null,\n-     Pre    => Container.Nodes = null\n-                 or else Length (Container) = Container.Nodes'Length,\n-     Post   => Model (Container) = Model (Container)'Old\n-                 and Positions (Container) = Positions (Container)'Old;\n-\n-   procedure Finalize_Element is new Ada.Unchecked_Deallocation\n-     (Object => Element_Type,\n-      Name   => Element_Access);\n-\n-   procedure Finalize_Nodes is new Ada.Unchecked_Deallocation\n-     (Object => Node_Array,\n-      Name   => Node_Array_Access);\n-\n-   ---------\n-   -- \"=\" --\n-   ---------\n-\n-   function \"=\" (Left : List; Right : List) return Boolean is\n-      LI : Count_Type;\n-      RI : Count_Type;\n-\n-   begin\n-      if Left'Address = Right'Address then\n-         return True;\n-      end if;\n-\n-      if Left.Length /= Right.Length then\n-         return False;\n-      end if;\n-\n-      LI := Left.First;\n-      RI := Right.First;\n-      while LI /= 0 loop\n-         if Left.Nodes (LI).Element.all /= Right.Nodes (RI).Element.all then\n-            return False;\n-         end if;\n-\n-         LI := Left.Nodes (LI).Next;\n-         RI := Right.Nodes (RI).Next;\n-      end loop;\n-\n-      return True;\n-   end \"=\";\n-\n-   ------------\n-   -- Adjust --\n-   ------------\n-\n-   overriding procedure Adjust (Container : in out List) is\n-      N_Src : Node_Array_Access renames Container.Nodes;\n-      N_Tar : Node_Array_Access;\n-\n-   begin\n-      if N_Src = null then\n-         return;\n-      end if;\n-\n-      if Container.Length = 0 then\n-         Container.Nodes := null;\n-         Container.Free := -1;\n-         return;\n-      end if;\n-\n-      N_Tar := new Node_Array (1 .. N_Src'Length);\n-\n-      for X in 1 .. Count_Type (N_Src'Length) loop\n-         N_Tar (X) := N_Src (X);\n-         if N_Src (X).Element /= null\n-         then\n-            N_Tar (X).Element := new Element_Type'(N_Src (X).Element.all);\n-         end if;\n-      end loop;\n-\n-      N_Src := N_Tar;\n-\n-   end Adjust;\n-\n-   --------------\n-   -- Allocate --\n-   --------------\n-\n-   procedure Allocate\n-     (Container : in out List;\n-      New_Node  : out Count_Type)\n-   is\n-      N : Node_Array_Access renames Container.Nodes;\n-\n-   begin\n-      if Container.Nodes = null\n-        or else Length (Container) = Container.Nodes'Length\n-      then\n-         Resize (Container);\n-      end if;\n-\n-      if Container.Free >= 0 then\n-         New_Node := Container.Free;\n-         Container.Free := N (New_Node).Next;\n-      else\n-         New_Node := abs Container.Free;\n-         Container.Free := Container.Free - 1;\n-      end if;\n-\n-      N (New_Node).Element := null;\n-   end Allocate;\n-\n-   procedure Allocate\n-     (Container : in out List;\n-      New_Item  : Element_Type;\n-      New_Node  : out Count_Type)\n-   is\n-      N : Node_Array_Access renames Container.Nodes;\n-\n-   begin\n-      Allocate (Container, New_Node);\n-\n-      N (New_Node).Element := new Element_Type'(New_Item);\n-   end Allocate;\n-\n-   ------------\n-   -- Append --\n-   ------------\n-\n-   procedure Append (Container : in out List; New_Item : Element_Type) is\n-   begin\n-      Insert (Container, No_Element, New_Item, 1);\n-   end Append;\n-\n-   procedure Append\n-     (Container : in out List;\n-      New_Item  : Element_Type;\n-      Count     : Count_Type)\n-   is\n-   begin\n-      Insert (Container, No_Element, New_Item, Count);\n-   end Append;\n-\n-   ------------\n-   -- Assign --\n-   ------------\n-\n-   procedure Assign (Target : in out List; Source : List) is\n-      N : Node_Array_Access renames Source.Nodes;\n-      J : Count_Type;\n-\n-   begin\n-      if Target'Address = Source'Address then\n-         return;\n-      end if;\n-\n-      Clear (Target);\n-\n-      J := Source.First;\n-      while J /= 0 loop\n-         Append (Target, N (J).Element.all);\n-         J := N (J).Next;\n-      end loop;\n-   end Assign;\n-\n-   -----------\n-   -- Clear --\n-   -----------\n-\n-   procedure Clear (Container : in out List) is\n-      N : Node_Array_Access renames Container.Nodes;\n-      X : Count_Type;\n-\n-   begin\n-      if Container.Length = 0 then\n-         pragma Assert (Container.First = 0);\n-         pragma Assert (Container.Last  = 0);\n-         return;\n-      end if;\n-\n-      pragma Assert (Container.First >= 1);\n-      pragma Assert (Container.Last  >= 1);\n-      pragma Assert (N (Container.First).Prev = 0);\n-      pragma Assert (N (Container.Last).Next  = 0);\n-\n-      while Container.Length > 1 loop\n-         X := Container.First;\n-\n-         Container.First := N (X).Next;\n-         N (Container.First).Prev := 0;\n-\n-         Container.Length := Container.Length - 1;\n-\n-         Free (Container, X);\n-      end loop;\n-\n-      X := Container.First;\n-\n-      Container.First := 0;\n-      Container.Last := 0;\n-      Container.Length := 0;\n-\n-      Free (Container, X);\n-   end Clear;\n-\n-   ------------------------\n-   -- Constant_Reference --\n-   ------------------------\n-\n-   function Constant_Reference\n-     (Container : List;\n-      Position  : Cursor) return not null access constant Element_Type\n-   is\n-   begin\n-      if not Has_Element (Container => Container, Position  => Position) then\n-         raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      return Container.Nodes (Position.Node).Element;\n-   end Constant_Reference;\n-\n-   --------------\n-   -- Contains --\n-   --------------\n-\n-   function Contains\n-     (Container : List;\n-      Item      : Element_Type) return Boolean\n-   is\n-   begin\n-      return Find (Container, Item) /= No_Element;\n-   end Contains;\n-\n-   ----------\n-   -- Copy --\n-   ----------\n-\n-   function Copy (Source : List) return List\n-   is\n-      N : Count_Type;\n-      P : List;\n-\n-   begin\n-      if Source.Nodes = null then\n-         return P;\n-      end if;\n-\n-      P.Nodes := new Node_Array (1 .. Source.Nodes'Length);\n-\n-      N := 1;\n-      while N <= Source.Nodes'Length loop\n-         P.Nodes (N).Prev := Source.Nodes (N).Prev;\n-         P.Nodes (N).Next := Source.Nodes (N).Next;\n-         if Source.Nodes (N).Element /= null then\n-            P.Nodes (N).Element :=\n-              new Element_Type'(Source.Nodes (N).Element.all);\n-         end if;\n-         N := N + 1;\n-      end loop;\n-\n-      P.Free   := Source.Free;\n-      P.Length := Source.Length;\n-      P.First  := Source.First;\n-      P.Last   := Source.Last;\n-\n-      return P;\n-   end Copy;\n-\n-   ------------\n-   -- Delete --\n-   ------------\n-\n-   procedure Delete (Container : in out List; Position : in out Cursor) is\n-   begin\n-      Delete\n-        (Container => Container,\n-         Position  => Position,\n-         Count     => 1);\n-   end Delete;\n-\n-   procedure Delete\n-     (Container : in out List;\n-      Position  : in out Cursor;\n-      Count     : Count_Type)\n-   is\n-      N : Node_Array_Access renames Container.Nodes;\n-      X : Count_Type;\n-\n-   begin\n-      if not Has_Element (Container => Container,\n-                          Position  => Position)\n-      then\n-         raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      pragma Assert (Vet (Container, Position), \"bad cursor in Delete\");\n-      pragma Assert (Container.First >= 1);\n-      pragma Assert (Container.Last  >= 1);\n-      pragma Assert (N (Container.First).Prev = 0);\n-      pragma Assert (N (Container.Last).Next  = 0);\n-\n-      if Position.Node = Container.First then\n-         Delete_First (Container, Count);\n-         Position := No_Element;\n-         return;\n-      end if;\n-\n-      if Count = 0 then\n-         Position := No_Element;\n-         return;\n-      end if;\n-\n-      for Index in 1 .. Count loop\n-         pragma Assert (Container.Length >= 2);\n-\n-         X := Position.Node;\n-         Container.Length := Container.Length - 1;\n-\n-         if X = Container.Last then\n-            Position := No_Element;\n-\n-            Container.Last := N (X).Prev;\n-            N (Container.Last).Next := 0;\n-\n-            Free (Container, X);\n-            return;\n-         end if;\n-\n-         Position.Node := N (X).Next;\n-         pragma Assert (N (Position.Node).Prev >= 0);\n-\n-         N (N (X).Next).Prev := N (X).Prev;\n-         N (N (X).Prev).Next := N (X).Next;\n-\n-         Free (Container, X);\n-      end loop;\n-\n-      Position := No_Element;\n-   end Delete;\n-\n-   ------------------\n-   -- Delete_First --\n-   ------------------\n-\n-   procedure Delete_First (Container : in out List) is\n-   begin\n-      Delete_First\n-        (Container => Container,\n-         Count     => 1);\n-   end Delete_First;\n-\n-   procedure Delete_First (Container : in out List; Count : Count_Type) is\n-      N : Node_Array_Access renames Container.Nodes;\n-      X : Count_Type;\n-\n-   begin\n-      if Count >= Container.Length then\n-         Clear (Container);\n-         return;\n-      end if;\n-\n-      if Count = 0 then\n-         return;\n-      end if;\n-\n-      for J in 1 .. Count loop\n-         X := Container.First;\n-         pragma Assert (N (N (X).Next).Prev = Container.First);\n-\n-         Container.First := N (X).Next;\n-         N (Container.First).Prev := 0;\n-\n-         Container.Length := Container.Length - 1;\n-\n-         Free (Container, X);\n-      end loop;\n-   end Delete_First;\n-\n-   -----------------\n-   -- Delete_Last --\n-   -----------------\n-\n-   procedure Delete_Last (Container : in out List) is\n-   begin\n-      Delete_Last\n-        (Container => Container,\n-         Count     => 1);\n-   end Delete_Last;\n-\n-   procedure Delete_Last (Container : in out List; Count : Count_Type) is\n-      N : Node_Array_Access renames Container.Nodes;\n-      X : Count_Type;\n-\n-   begin\n-      if Count >= Container.Length then\n-         Clear (Container);\n-         return;\n-      end if;\n-\n-      if Count = 0 then\n-         return;\n-      end if;\n-\n-      for J in 1 .. Count loop\n-         X := Container.Last;\n-         pragma Assert (N (N (X).Prev).Next = Container.Last);\n-\n-         Container.Last := N (X).Prev;\n-         N (Container.Last).Next := 0;\n-\n-         Container.Length := Container.Length - 1;\n-\n-         Free (Container, X);\n-      end loop;\n-   end Delete_Last;\n-\n-   -------------\n-   -- Element --\n-   -------------\n-\n-   function Element\n-     (Container : List;\n-      Position  : Cursor) return Element_Type\n-   is\n-   begin\n-      if not Has_Element (Container => Container, Position  => Position) then\n-         raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      return Container.Nodes (Position.Node).Element.all;\n-   end Element;\n-\n-   ----------------\n-   -- Empty_List --\n-   ----------------\n-\n-   function Empty_List return List is\n-      ((Controlled with others => <>));\n-\n-   --------------\n-   -- Finalize --\n-   --------------\n-\n-   procedure Finalize (Container : in out List) is\n-      X : Count_Type := Container.First;\n-      N : Node_Array_Access renames Container.Nodes;\n-   begin\n-\n-      if N = null then\n-         return;\n-      end if;\n-\n-      while X /= 0 loop\n-         Finalize_Element (N (X).Element);\n-         X := N (X).Next;\n-      end loop;\n-\n-      Finalize_Nodes (N);\n-\n-      Container.Free := 0;\n-      Container.Last := 0;\n-      Container.First := 0;\n-      Container.Length := 0;\n-   end Finalize;\n-\n-   ----------\n-   -- Find --\n-   ----------\n-\n-   function Find\n-     (Container : List;\n-      Item      : Element_Type;\n-      Position  : Cursor := No_Element) return Cursor\n-   is\n-      From : Count_Type := Position.Node;\n-\n-   begin\n-      if From = 0 and Container.Length = 0 then\n-         return No_Element;\n-      end if;\n-\n-      if From = 0 then\n-         From := Container.First;\n-      end if;\n-\n-      if Position.Node /= 0 and then not Has_Element (Container, Position) then\n-         raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      while From /= 0 loop\n-         if Container.Nodes (From).Element.all = Item then\n-            return (Node => From);\n-         end if;\n-\n-         From := Container.Nodes (From).Next;\n-      end loop;\n-\n-      return No_Element;\n-   end Find;\n-\n-   -----------\n-   -- First --\n-   -----------\n-\n-   function First (Container : List) return Cursor is\n-   begin\n-      if Container.First = 0 then\n-         return No_Element;\n-      end if;\n-\n-      return (Node => Container.First);\n-   end First;\n-\n-   -------------------\n-   -- First_Element --\n-   -------------------\n-\n-   function First_Element (Container : List) return Element_Type is\n-      F : constant Count_Type := Container.First;\n-   begin\n-      if F = 0 then\n-         raise Constraint_Error with \"list is empty\";\n-      else\n-         return Container.Nodes (F).Element.all;\n-      end if;\n-   end First_Element;\n-\n-   ------------------\n-   -- Formal_Model --\n-   ------------------\n-\n-   package body Formal_Model is\n-\n-      ----------------------------\n-      -- Lift_Abstraction_Level --\n-      ----------------------------\n-\n-      procedure Lift_Abstraction_Level (Container : List) is null;\n-\n-      -------------------------\n-      -- M_Elements_In_Union --\n-      -------------------------\n-\n-      function M_Elements_In_Union\n-        (Container : M.Sequence;\n-         Left      : M.Sequence;\n-         Right     : M.Sequence) return Boolean\n-      is\n-         Elem : Element_Type;\n-\n-      begin\n-         for Index in 1 .. M.Length (Container) loop\n-            Elem := Element (Container, Index);\n-\n-            if not M.Contains (Left, 1, M.Length (Left), Elem)\n-               and then not M.Contains (Right, 1, M.Length (Right), Elem)\n-            then\n-               return False;\n-            end if;\n-         end loop;\n-\n-         return True;\n-      end M_Elements_In_Union;\n-\n-      -------------------------\n-      -- M_Elements_Included --\n-      -------------------------\n-\n-      function M_Elements_Included\n-        (Left  : M.Sequence;\n-         L_Fst : Positive_Count_Type := 1;\n-         L_Lst : Count_Type;\n-         Right : M.Sequence;\n-         R_Fst : Positive_Count_Type := 1;\n-         R_Lst : Count_Type) return Boolean\n-      is\n-      begin\n-         for I in L_Fst .. L_Lst loop\n-            declare\n-               Found : Boolean := False;\n-               J     : Count_Type := R_Fst - 1;\n-\n-            begin\n-               while not Found and J < R_Lst loop\n-                  J := J + 1;\n-                  if Element (Left, I) = Element (Right, J) then\n-                     Found := True;\n-                  end if;\n-               end loop;\n-\n-               if not Found then\n-                  return False;\n-               end if;\n-            end;\n-         end loop;\n-\n-         return True;\n-      end M_Elements_Included;\n-\n-      -------------------------\n-      -- M_Elements_Reversed --\n-      -------------------------\n-\n-      function M_Elements_Reversed\n-        (Left  : M.Sequence;\n-         Right : M.Sequence) return Boolean\n-      is\n-         L : constant Count_Type := M.Length (Left);\n-\n-      begin\n-         if L /= M.Length (Right) then\n-            return False;\n-         end if;\n-\n-         for I in 1 .. L loop\n-            if Element (Left, I) /= Element (Right, L - I + 1) then\n-               return False;\n-            end if;\n-         end loop;\n-\n-         return True;\n-      end M_Elements_Reversed;\n-\n-      ------------------------\n-      -- M_Elements_Swapped --\n-      ------------------------\n-\n-      function M_Elements_Swapped\n-        (Left  : M.Sequence;\n-         Right : M.Sequence;\n-         X     : Positive_Count_Type;\n-         Y     : Positive_Count_Type) return Boolean\n-      is\n-      begin\n-         if M.Length (Left) /= M.Length (Right)\n-           or else Element (Left, X) /= Element (Right, Y)\n-           or else Element (Left, Y) /= Element (Right, X)\n-         then\n-            return False;\n-         end if;\n-\n-         for I in 1 .. M.Length (Left) loop\n-            if I /= X and then I /= Y\n-              and then Element (Left, I) /= Element (Right, I)\n-            then\n-               return False;\n-            end if;\n-         end loop;\n-\n-         return True;\n-      end M_Elements_Swapped;\n-\n-      -----------\n-      -- Model --\n-      -----------\n-\n-      function Model (Container : List) return M.Sequence is\n-         Position : Count_Type := Container.First;\n-         R        : M.Sequence;\n-\n-      begin\n-         --  Can't use First, Next or Element here, since they depend on models\n-         --  for their postconditions.\n-\n-         while Position /= 0 loop\n-            R := M.Add (R, Container.Nodes (Position).Element.all);\n-            Position := Container.Nodes (Position).Next;\n-         end loop;\n-\n-         return R;\n-      end Model;\n-\n-      -----------------------\n-      -- Mapping_Preserved --\n-      -----------------------\n-\n-      function Mapping_Preserved\n-        (M_Left  : M.Sequence;\n-         M_Right : M.Sequence;\n-         P_Left  : P.Map;\n-         P_Right : P.Map) return Boolean\n-      is\n-      begin\n-         for C of P_Left loop\n-            if not P.Has_Key (P_Right, C)\n-              or else P.Get (P_Left,  C) > M.Length (M_Left)\n-              or else P.Get (P_Right, C) > M.Length (M_Right)\n-              or else M.Get (M_Left,  P.Get (P_Left,  C)) /=\n-                      M.Get (M_Right, P.Get (P_Right, C))\n-            then\n-               return False;\n-            end if;\n-         end loop;\n-\n-         for C of P_Right loop\n-            if not P.Has_Key (P_Left, C) then\n-               return False;\n-            end if;\n-         end loop;\n-\n-         return True;\n-      end Mapping_Preserved;\n-\n-      -------------------------\n-      -- P_Positions_Shifted --\n-      -------------------------\n-\n-      function P_Positions_Shifted\n-        (Small : P.Map;\n-         Big   : P.Map;\n-         Cut   : Positive_Count_Type;\n-         Count : Count_Type := 1) return Boolean\n-      is\n-      begin\n-         for Cu of Small loop\n-            if not P.Has_Key (Big, Cu) then\n-               return False;\n-            end if;\n-         end loop;\n-\n-         for Cu of Big loop\n-            declare\n-               Pos : constant Positive_Count_Type := P.Get (Big, Cu);\n-\n-            begin\n-               if Pos < Cut then\n-                  if not P.Has_Key (Small, Cu)\n-                    or else Pos /= P.Get (Small, Cu)\n-                  then\n-                     return False;\n-                  end if;\n-\n-               elsif Pos >= Cut + Count then\n-                  if not P.Has_Key (Small, Cu)\n-                    or else Pos /= P.Get (Small, Cu) + Count\n-                  then\n-                     return False;\n-                  end if;\n-\n-               else\n-                  if P.Has_Key (Small, Cu) then\n-                     return False;\n-                  end if;\n-               end if;\n-            end;\n-         end loop;\n-\n-         return True;\n-      end P_Positions_Shifted;\n-\n-      -------------------------\n-      -- P_Positions_Swapped --\n-      -------------------------\n-\n-      function P_Positions_Swapped\n-        (Left  : P.Map;\n-         Right : P.Map;\n-         X     : Cursor;\n-         Y     : Cursor) return Boolean\n-      is\n-      begin\n-         if not P.Has_Key (Left, X)\n-           or not P.Has_Key (Left, Y)\n-           or not P.Has_Key (Right, X)\n-           or not P.Has_Key (Right, Y)\n-         then\n-            return False;\n-         end if;\n-\n-         if P.Get (Left, X) /= P.Get (Right, Y)\n-           or P.Get (Left, Y) /= P.Get (Right, X)\n-         then\n-            return False;\n-         end if;\n-\n-         for C of Left loop\n-            if not P.Has_Key (Right, C) then\n-               return False;\n-            end if;\n-         end loop;\n-\n-         for C of Right loop\n-            if not P.Has_Key (Left, C)\n-              or else (C /= X\n-                        and C /= Y\n-                        and P.Get (Left, C) /= P.Get (Right, C))\n-            then\n-               return False;\n-            end if;\n-         end loop;\n-\n-         return True;\n-      end P_Positions_Swapped;\n-\n-      ---------------------------\n-      -- P_Positions_Truncated --\n-      ---------------------------\n-\n-      function P_Positions_Truncated\n-        (Small : P.Map;\n-         Big   : P.Map;\n-         Cut   : Positive_Count_Type;\n-         Count : Count_Type := 1) return Boolean\n-      is\n-      begin\n-         for Cu of Small loop\n-            if not P.Has_Key (Big, Cu) then\n-               return False;\n-            end if;\n-         end loop;\n-\n-         for Cu of Big loop\n-            declare\n-               Pos : constant Positive_Count_Type := P.Get (Big, Cu);\n-\n-            begin\n-               if Pos < Cut then\n-                  if not P.Has_Key (Small, Cu)\n-                    or else Pos /= P.Get (Small, Cu)\n-                  then\n-                     return False;\n-                  end if;\n-\n-               elsif Pos >= Cut + Count then\n-                  return False;\n-\n-               elsif P.Has_Key (Small, Cu) then\n-                  return False;\n-               end if;\n-            end;\n-         end loop;\n-\n-         return True;\n-      end P_Positions_Truncated;\n-\n-      ---------------\n-      -- Positions --\n-      ---------------\n-\n-      function Positions (Container : List) return P.Map is\n-         I        : Count_Type := 1;\n-         Position : Count_Type := Container.First;\n-         R        : P.Map;\n-\n-      begin\n-         --  Can't use First, Next or Element here, since they depend on models\n-         --  for their postconditions.\n-\n-         while Position /= 0 loop\n-            R := P.Add (R, (Node => Position), I);\n-            pragma Assert (P.Length (R) = To_Big_Integer (I));\n-            Position := Container.Nodes (Position).Next;\n-            I := I + 1;\n-         end loop;\n-\n-         return R;\n-      end Positions;\n-\n-   end Formal_Model;\n-\n-   ----------\n-   -- Free --\n-   ----------\n-\n-   procedure Free (Container : in out List; X : Count_Type) is\n-      pragma Assert (X > 0);\n-      pragma Assert (X <= Container.Nodes'Length);\n-\n-      N : Node_Array_Access renames Container.Nodes;\n-\n-   begin\n-      N (X).Prev := -1;  -- Node is deallocated (not on active list)\n-\n-      if N (X).Element /= null then\n-         Finalize_Element (N (X).Element);\n-      end if;\n-\n-      if Container.Free >= 0 then\n-         N (X).Next := Container.Free;\n-         Container.Free := X;\n-      elsif X + 1 = abs Container.Free then\n-         N (X).Next := 0;  -- Not strictly necessary, but marginally safer\n-         Container.Free := Container.Free + 1;\n-      else\n-         Container.Free := abs Container.Free;\n-\n-         for J in Container.Free .. Container.Nodes'Length loop\n-            N (J).Next := J + 1;\n-         end loop;\n-\n-         N (Container.Nodes'Length).Next := 0;\n-\n-         N (X).Next := Container.Free;\n-         Container.Free := X;\n-      end if;\n-   end Free;\n-\n-   ---------------------\n-   -- Generic_Sorting --\n-   ---------------------\n-\n-   package body Generic_Sorting with SPARK_Mode => Off is\n-\n-      ------------------\n-      -- Formal_Model --\n-      ------------------\n-\n-      package body Formal_Model is\n-\n-         -----------------------\n-         -- M_Elements_Sorted --\n-         -----------------------\n-\n-         function M_Elements_Sorted (Container : M.Sequence) return Boolean is\n-         begin\n-            if M.Length (Container) = 0 then\n-               return True;\n-            end if;\n-\n-            declare\n-               E1 : Element_Type := Element (Container, 1);\n-\n-            begin\n-               for I in 2 .. M.Length (Container) loop\n-                  declare\n-                     E2 : constant Element_Type := Element (Container, I);\n-\n-                  begin\n-                     if E2 < E1 then\n-                        return False;\n-                     end if;\n-\n-                     E1 := E2;\n-                  end;\n-               end loop;\n-            end;\n-\n-            return True;\n-         end M_Elements_Sorted;\n-\n-      end Formal_Model;\n-\n-      ---------------\n-      -- Is_Sorted --\n-      ---------------\n-\n-      function Is_Sorted (Container : List) return Boolean is\n-         Nodes : Node_Array_Access renames Container.Nodes;\n-         Node  : Count_Type := Container.First;\n-\n-      begin\n-         for J in 2 .. Container.Length loop\n-            if Nodes (Nodes (Node).Next).Element.all < Nodes (Node).Element.all\n-            then\n-               return False;\n-            else\n-               Node := Nodes (Node).Next;\n-            end if;\n-         end loop;\n-\n-         return True;\n-      end Is_Sorted;\n-\n-      -----------\n-      -- Merge --\n-      -----------\n-\n-      procedure Merge (Target : in out List; Source : in out List) is\n-         LN : Node_Array_Access renames Target.Nodes;\n-         RN : Node_Array_Access renames Source.Nodes;\n-         LI : Cursor;\n-         RI : Cursor;\n-\n-      begin\n-         if Target'Address = Source'Address then\n-            raise Program_Error with \"Target and Source denote same container\";\n-         end if;\n-\n-         LI := First (Target);\n-         RI := First (Source);\n-         while RI.Node /= 0 loop\n-            pragma Assert\n-              (RN (RI.Node).Next = 0\n-                or else not (RN (RN (RI.Node).Next).Element.all <\n-                             RN (RI.Node).Element.all));\n-\n-            if LI.Node = 0 then\n-               Splice (Target, No_Element, Source);\n-               return;\n-            end if;\n-\n-            pragma Assert\n-              (LN (LI.Node).Next = 0\n-                or else not (LN (LN (LI.Node).Next).Element.all <\n-                             LN (LI.Node).Element.all));\n-\n-            if RN (RI.Node).Element.all < LN (LI.Node).Element.all then\n-               declare\n-                  RJ : Cursor := RI;\n-                  pragma Warnings (Off, RJ);\n-               begin\n-                  RI.Node := RN (RI.Node).Next;\n-                  Splice (Target, LI, Source, RJ);\n-               end;\n-\n-            else\n-               LI.Node := LN (LI.Node).Next;\n-            end if;\n-         end loop;\n-      end Merge;\n-\n-      ----------\n-      -- Sort --\n-      ----------\n-\n-      procedure Sort (Container : in out List) is\n-         N : Node_Array_Access renames Container.Nodes;\n-      begin\n-         if Container.Length <= 1 then\n-            return;\n-         end if;\n-\n-         pragma Assert (N (Container.First).Prev = 0);\n-         pragma Assert (N (Container.Last).Next = 0);\n-\n-         declare\n-            package Descriptors is new List_Descriptors\n-              (Node_Ref => Count_Type, Nil => 0);\n-            use Descriptors;\n-\n-            function Next (Idx : Count_Type) return Count_Type is\n-              (N (Idx).Next);\n-            procedure Set_Next (Idx : Count_Type; Next : Count_Type)\n-              with Inline;\n-            procedure Set_Prev (Idx : Count_Type; Prev : Count_Type)\n-              with Inline;\n-            function \"<\" (L, R : Count_Type) return Boolean is\n-              (N (L).Element.all < N (R).Element.all);\n-            procedure Update_Container (List : List_Descriptor) with Inline;\n-\n-            procedure Set_Next (Idx : Count_Type; Next : Count_Type) is\n-            begin\n-               N (Idx).Next := Next;\n-            end Set_Next;\n-\n-            procedure Set_Prev (Idx : Count_Type; Prev : Count_Type) is\n-            begin\n-               N (Idx).Prev := Prev;\n-            end Set_Prev;\n-\n-            procedure Update_Container (List : List_Descriptor) is\n-            begin\n-               Container.First  := List.First;\n-               Container.Last   := List.Last;\n-               Container.Length := List.Length;\n-            end Update_Container;\n-\n-            procedure Sort_List is new Doubly_Linked_List_Sort;\n-         begin\n-            Sort_List (List_Descriptor'(First  => Container.First,\n-                                        Last   => Container.Last,\n-                                        Length => Container.Length));\n-         end;\n-\n-         pragma Assert (N (Container.First).Prev = 0);\n-         pragma Assert (N (Container.Last).Next = 0);\n-      end Sort;\n-\n-   end Generic_Sorting;\n-\n-   -----------------\n-   -- Has_Element --\n-   -----------------\n-\n-   function Has_Element (Container : List; Position : Cursor) return Boolean is\n-   begin\n-      if Position.Node = 0 then\n-         return False;\n-      end if;\n-\n-      return Container.Nodes (Position.Node).Prev /= -1;\n-   end Has_Element;\n-\n-   ------------\n-   -- Insert --\n-   ------------\n-\n-   procedure Insert\n-     (Container : in out List;\n-      Before    : Cursor;\n-      New_Item  : Element_Type;\n-      Position  : out Cursor;\n-      Count     : Count_Type)\n-   is\n-      J : Count_Type;\n-\n-   begin\n-      if Before.Node /= 0 then\n-         pragma Assert (Vet (Container, Before), \"bad cursor in Insert\");\n-      end if;\n-\n-      if Count = 0 then\n-         Position := Before;\n-         return;\n-      end if;\n-      Allocate (Container, New_Item, New_Node => J);\n-      Insert_Internal (Container, Before.Node, New_Node => J);\n-      Position := (Node => J);\n-\n-      for Index in 2 .. Count loop\n-         Allocate (Container, New_Item, New_Node => J);\n-         Insert_Internal (Container, Before.Node, New_Node => J);\n-      end loop;\n-   end Insert;\n-\n-   procedure Insert\n-     (Container : in out List;\n-      Before    : Cursor;\n-      New_Item  : Element_Type;\n-      Position  : out Cursor)\n-   is\n-   begin\n-      Insert\n-        (Container => Container,\n-         Before    => Before,\n-         New_Item  => New_Item,\n-         Position  => Position,\n-         Count     => 1);\n-   end Insert;\n-\n-   procedure Insert\n-     (Container : in out List;\n-      Before    : Cursor;\n-      New_Item  : Element_Type;\n-      Count     : Count_Type)\n-   is\n-      Position : Cursor;\n-\n-   begin\n-      Insert (Container, Before, New_Item, Position, Count);\n-   end Insert;\n-\n-   procedure Insert\n-     (Container : in out List;\n-      Before    : Cursor;\n-      New_Item  : Element_Type)\n-   is\n-      Position : Cursor;\n-\n-   begin\n-      Insert (Container, Before, New_Item, Position, 1);\n-   end Insert;\n-\n-   ---------------------\n-   -- Insert_Internal --\n-   ---------------------\n-\n-   procedure Insert_Internal\n-     (Container : in out List;\n-      Before    : Count_Type;\n-      New_Node  : Count_Type)\n-   is\n-      N : Node_Array_Access renames Container.Nodes;\n-\n-   begin\n-      if Container.Length = 0 then\n-         pragma Assert (Before = 0);\n-         pragma Assert (Container.First = 0);\n-         pragma Assert (Container.Last = 0);\n-\n-         Container.First := New_Node;\n-         Container.Last := New_Node;\n-\n-         N (Container.First).Prev := 0;\n-         N (Container.Last).Next := 0;\n-\n-      elsif Before = 0 then\n-         pragma Assert (N (Container.Last).Next = 0);\n-\n-         N (Container.Last).Next := New_Node;\n-         N (New_Node).Prev := Container.Last;\n-\n-         Container.Last := New_Node;\n-         N (Container.Last).Next := 0;\n-\n-      elsif Before = Container.First then\n-         pragma Assert (N (Container.First).Prev = 0);\n-\n-         N (Container.First).Prev := New_Node;\n-         N (New_Node).Next := Container.First;\n-\n-         Container.First := New_Node;\n-         N (Container.First).Prev := 0;\n-\n-      else\n-         pragma Assert (N (Container.First).Prev = 0);\n-         pragma Assert (N (Container.Last).Next = 0);\n-\n-         N (New_Node).Next := Before;\n-         N (New_Node).Prev := N (Before).Prev;\n-\n-         N (N (Before).Prev).Next := New_Node;\n-         N (Before).Prev := New_Node;\n-      end if;\n-      Container.Length := Container.Length + 1;\n-   end Insert_Internal;\n-\n-   --------------\n-   -- Is_Empty --\n-   --------------\n-\n-   function Is_Empty (Container : List) return Boolean is\n-   begin\n-      return Length (Container) = 0;\n-   end Is_Empty;\n-\n-   ----------\n-   -- Last --\n-   ----------\n-\n-   function Last (Container : List) return Cursor is\n-   begin\n-      if Container.Last = 0 then\n-         return No_Element;\n-      end if;\n-\n-      return (Node => Container.Last);\n-   end Last;\n-\n-   ------------------\n-   -- Last_Element --\n-   ------------------\n-\n-   function Last_Element (Container : List) return Element_Type is\n-      L : constant Count_Type := Container.Last;\n-\n-   begin\n-      if L = 0 then\n-         raise Constraint_Error with \"list is empty\";\n-      else\n-         return Container.Nodes (L).Element.all;\n-      end if;\n-   end Last_Element;\n-\n-   ------------\n-   -- Length --\n-   ------------\n-\n-   function Length (Container : List) return Count_Type is\n-   begin\n-      return Container.Length;\n-   end Length;\n-\n-   ----------\n-   -- Move --\n-   ----------\n-\n-   procedure Move (Target : in out List; Source : in out List) is\n-      N     : Node_Array_Access renames Source.Nodes;\n-\n-      procedure Finalize_Node_Array is new Ada.Unchecked_Deallocation\n-        (Object => Node_Array,\n-         Name   => Node_Array_Access);\n-\n-   begin\n-      if Target'Address = Source'Address then\n-         return;\n-      end if;\n-\n-      Clear (Target);\n-\n-      if Source.Length = 0 then\n-         return;\n-      end if;\n-\n-      --  Make sure that Target is large enough\n-\n-      if Target.Nodes = null\n-        or else Target.Nodes'Length < Source.Length\n-      then\n-         if Target.Nodes /= null then\n-            Finalize_Node_Array (Target.Nodes);\n-         end if;\n-         Target.Nodes := new Node_Array (1 .. Source.Length);\n-      end if;\n-\n-      --  Copy first element from Source to Target\n-\n-      Target.First := 1;\n-\n-      Target.Nodes (1).Prev := 0;\n-      Target.Nodes (1).Element := N (Source.First).Element;\n-      N (Source.First).Element := null;\n-\n-      --  Copy the other elements\n-\n-      declare\n-         X_Src : Count_Type := N (Source.First).Next;\n-         X_Tar : Count_Type := 2;\n-\n-      begin\n-         while X_Src /= 0 loop\n-            Target.Nodes (X_Tar).Prev := X_Tar - 1;\n-            Target.Nodes (X_Tar - 1).Next := X_Tar;\n-\n-            Target.Nodes (X_Tar).Element := N (X_Src).Element;\n-            N (X_Src).Element := null;\n-\n-            X_Src := N (X_Src).Next;\n-            X_Tar := X_Tar + 1;\n-         end loop;\n-      end;\n-\n-      Target.Last := Source.Length;\n-      Target.Length := Source.Length;\n-      Target.Nodes (Target.Last).Next := 0;\n-\n-      --  Set up the free list\n-\n-      Target.Free := -Source.Length - 1;\n-\n-      --  It is possible to Clear Source because the Element accesses were\n-      --  set to null.\n-\n-      Clear (Source);\n-   end Move;\n-\n-   ----------\n-   -- Next --\n-   ----------\n-\n-   procedure Next (Container : List; Position : in out Cursor) is\n-   begin\n-      Position := Next (Container, Position);\n-   end Next;\n-\n-   function Next (Container : List; Position : Cursor) return Cursor is\n-   begin\n-      if Position.Node = 0 then\n-         return No_Element;\n-      end if;\n-\n-      if not Has_Element (Container, Position) then\n-         raise Program_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      return (Node => Container.Nodes (Position.Node).Next);\n-   end Next;\n-\n-   -------------\n-   -- Prepend --\n-   -------------\n-\n-   procedure Prepend (Container : in out List; New_Item : Element_Type) is\n-   begin\n-      Insert (Container, First (Container), New_Item, 1);\n-   end Prepend;\n-\n-   procedure Prepend\n-     (Container : in out List;\n-      New_Item  : Element_Type;\n-      Count     : Count_Type)\n-   is\n-   begin\n-      Insert (Container, First (Container), New_Item, Count);\n-   end Prepend;\n-\n-   --------------\n-   -- Previous --\n-   --------------\n-\n-   procedure Previous (Container : List; Position : in out Cursor) is\n-   begin\n-      Position := Previous (Container, Position);\n-   end Previous;\n-\n-   function Previous (Container : List; Position : Cursor) return Cursor is\n-   begin\n-      if Position.Node = 0 then\n-         return No_Element;\n-      end if;\n-\n-      if not Has_Element (Container, Position) then\n-         raise Program_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      return (Node => Container.Nodes (Position.Node).Prev);\n-   end Previous;\n-\n-   ---------------\n-   -- Reference --\n-   ---------------\n-\n-   function Reference\n-     (Container : not null access List;\n-      Position  : Cursor) return not null access Element_Type\n-   is\n-   begin\n-      if not Has_Element (Container.all, Position) then\n-         raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      return Container.Nodes (Position.Node).Element;\n-   end Reference;\n-\n-   ---------------------\n-   -- Replace_Element --\n-   ---------------------\n-\n-   procedure Replace_Element\n-     (Container : in out List;\n-      Position  : Cursor;\n-      New_Item  : Element_Type)\n-   is\n-   begin\n-      if not Has_Element (Container, Position) then\n-         raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      pragma Assert\n-        (Vet (Container, Position), \"bad cursor in Replace_Element\");\n-\n-      Finalize_Element (Container.Nodes (Position.Node).Element);\n-      Container.Nodes (Position.Node).Element := new Element_Type'(New_Item);\n-   end Replace_Element;\n-\n-   ------------\n-   -- Resize --\n-   ------------\n-\n-   procedure Resize (Container : in out List) is\n-      Min_Size : constant Count_Type := 100;\n-   begin\n-      if Container.Nodes = null then\n-         Container.Nodes := new Node_Array (1 .. Min_Size);\n-         Container.First := 0;\n-         Container.Last := 0;\n-         Container.Length := 0;\n-         Container.Free := -1;\n-\n-         return;\n-      end if;\n-\n-      if Container.Length /= Container.Nodes'Length then\n-         raise Program_Error with \"List must be at size max to resize\";\n-      end if;\n-\n-      declare\n-         procedure Finalize_Node_Array is new Ada.Unchecked_Deallocation\n-              (Object => Node_Array,\n-               Name   => Node_Array_Access);\n-\n-         New_Size : constant Count_Type :=\n-           (if Container.Nodes'Length > Count_Type'Last / 2\n-            then Count_Type'Last\n-            else 2 * Container.Nodes'Length);\n-         New_Nodes : Node_Array_Access;\n-\n-      begin\n-         New_Nodes :=\n-           new Node_Array (1 .. Count_Type'Max (New_Size, Min_Size));\n-\n-         New_Nodes (1 .. Container.Nodes'Length) :=\n-           Container.Nodes (1 .. Container.Nodes'Length);\n-\n-         Container.Free := -Container.Nodes'Length - 1;\n-\n-         Finalize_Node_Array (Container.Nodes);\n-         Container.Nodes := New_Nodes;\n-      end;\n-   end Resize;\n-\n-   ----------------------\n-   -- Reverse_Elements --\n-   ----------------------\n-\n-   procedure Reverse_Elements (Container : in out List) is\n-      N : Node_Array_Access renames Container.Nodes;\n-      I : Count_Type := Container.First;\n-      J : Count_Type := Container.Last;\n-\n-      procedure Swap (L : Count_Type; R : Count_Type);\n-\n-      ----------\n-      -- Swap --\n-      ----------\n-\n-      procedure Swap (L : Count_Type; R : Count_Type) is\n-         LN : constant Count_Type := N (L).Next;\n-         LP : constant Count_Type := N (L).Prev;\n-\n-         RN : constant Count_Type := N (R).Next;\n-         RP : constant Count_Type := N (R).Prev;\n-\n-      begin\n-         if LP /= 0 then\n-            N (LP).Next := R;\n-         end if;\n-\n-         if RN /= 0 then\n-            N (RN).Prev := L;\n-         end if;\n-\n-         N (L).Next := RN;\n-         N (R).Prev := LP;\n-\n-         if LN = R then\n-            pragma Assert (RP = L);\n-\n-            N (L).Prev := R;\n-            N (R).Next := L;\n-\n-         else\n-            N (L).Prev := RP;\n-            N (RP).Next := L;\n-\n-            N (R).Next := LN;\n-            N (LN).Prev := R;\n-         end if;\n-      end Swap;\n-\n-   --  Start of processing for Reverse_Elements\n-\n-   begin\n-      if Container.Length <= 1 then\n-         return;\n-      end if;\n-\n-      pragma Assert (N (Container.First).Prev = 0);\n-      pragma Assert (N (Container.Last).Next = 0);\n-\n-      Container.First := J;\n-      Container.Last  := I;\n-      loop\n-         Swap (L => I, R => J);\n-\n-         J := N (J).Next;\n-         exit when I = J;\n-\n-         I := N (I).Prev;\n-         exit when I = J;\n-\n-         Swap (L => J, R => I);\n-\n-         I := N (I).Next;\n-         exit when I = J;\n-\n-         J := N (J).Prev;\n-         exit when I = J;\n-      end loop;\n-\n-      pragma Assert (N (Container.First).Prev = 0);\n-      pragma Assert (N (Container.Last).Next = 0);\n-   end Reverse_Elements;\n-\n-   ------------------\n-   -- Reverse_Find --\n-   ------------------\n-\n-   function Reverse_Find\n-     (Container : List;\n-      Item      : Element_Type;\n-      Position  : Cursor := No_Element) return Cursor\n-   is\n-      CFirst : Count_Type := Position.Node;\n-\n-   begin\n-      if CFirst = 0 then\n-         CFirst := Container.Last;\n-      end if;\n-\n-      if Container.Length = 0 then\n-         return No_Element;\n-      else\n-         while CFirst /= 0 loop\n-            if Container.Nodes (CFirst).Element.all = Item then\n-               return (Node => CFirst);\n-            else\n-               CFirst := Container.Nodes (CFirst).Prev;\n-            end if;\n-         end loop;\n-\n-         return No_Element;\n-      end if;\n-   end Reverse_Find;\n-\n-   ------------\n-   -- Splice --\n-   ------------\n-\n-   procedure Splice\n-     (Target : in out List;\n-      Before : Cursor;\n-      Source : in out List)\n-   is\n-      SN : Node_Array_Access renames Source.Nodes;\n-      TN : Node_Array_Access renames Target.Nodes;\n-\n-   begin\n-      if Target'Address = Source'Address then\n-         raise Program_Error with \"Target and Source denote same container\";\n-      end if;\n-\n-      if Before.Node /= 0 then\n-         pragma Assert (Vet (Target, Before), \"bad cursor in Splice\");\n-      end if;\n-\n-      if Is_Empty (Source) then\n-         return;\n-      end if;\n-\n-      pragma Assert (SN (Source.First).Prev = 0);\n-      pragma Assert (SN (Source.Last).Next  = 0);\n-\n-      declare\n-         X : Count_Type;\n-\n-      begin\n-         while not Is_Empty (Source) loop\n-            Allocate (Target, X);\n-\n-            TN (X).Element := SN (Source.Last).Element;\n-\n-            --  Insert the new node in Target\n-\n-            Insert_Internal (Target, Before.Node, X);\n-\n-            --  Free the last node of Source\n-\n-            SN (Source.Last).Element := null;\n-            Delete_Last (Source);\n-         end loop;\n-      end;\n-\n-   end Splice;\n-\n-   procedure Splice\n-     (Target   : in out List;\n-      Before   : Cursor;\n-      Source   : in out List;\n-      Position : in out Cursor)\n-   is\n-   begin\n-      if Target'Address = Source'Address then\n-         raise Program_Error with \"Target and Source denote same container\";\n-      end if;\n-\n-      if Position.Node = 0 then\n-         raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      pragma Assert (Vet (Source, Position), \"bad Position cursor in Splice\");\n-\n-      declare\n-         X : Count_Type;\n-\n-      begin\n-         Allocate (Target, X);\n-\n-         Target.Nodes (X).Element := Source.Nodes (Position.Node).Element;\n-\n-         --  Insert the new node in Target\n-\n-         Insert_Internal (Target, Before.Node, X);\n-\n-         --  Free the node at position Position in Source\n-\n-         Source.Nodes (Position.Node).Element := null;\n-         Delete (Source, Position);\n-\n-         Position := (Node => X);\n-      end;\n-   end Splice;\n-\n-   procedure Splice\n-     (Container : in out List;\n-      Before    : Cursor;\n-      Position  : Cursor)\n-   is\n-      N : Node_Array_Access renames Container.Nodes;\n-\n-   begin\n-      if Before.Node /= 0 then\n-         pragma Assert\n-           (Vet (Container, Before), \"bad Before cursor in Splice\");\n-      end if;\n-\n-      if Position.Node = 0 then\n-         raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      pragma Assert\n-        (Vet (Container, Position), \"bad Position cursor in Splice\");\n-\n-      if Position.Node = Before.Node\n-        or else N (Position.Node).Next = Before.Node\n-      then\n-         return;\n-      end if;\n-\n-      pragma Assert (Container.Length >= 2);\n-\n-      if Before.Node = 0 then\n-         pragma Assert (Position.Node /= Container.Last);\n-\n-         if Position.Node = Container.First then\n-            Container.First := N (Position.Node).Next;\n-            N (Container.First).Prev := 0;\n-\n-         else\n-            N (N (Position.Node).Prev).Next := N (Position.Node).Next;\n-            N (N (Position.Node).Next).Prev := N (Position.Node).Prev;\n-         end if;\n-\n-         N (Container.Last).Next := Position.Node;\n-         N (Position.Node).Prev := Container.Last;\n-\n-         Container.Last := Position.Node;\n-         N (Container.Last).Next := 0;\n-\n-         return;\n-      end if;\n-\n-      if Before.Node = Container.First then\n-         pragma Assert (Position.Node /= Container.First);\n-\n-         if Position.Node = Container.Last then\n-            Container.Last := N (Position.Node).Prev;\n-            N (Container.Last).Next := 0;\n-\n-         else\n-            N (N (Position.Node).Prev).Next := N (Position.Node).Next;\n-            N (N (Position.Node).Next).Prev := N (Position.Node).Prev;\n-         end if;\n-\n-         N (Container.First).Prev := Position.Node;\n-         N (Position.Node).Next := Container.First;\n-\n-         Container.First := Position.Node;\n-         N (Container.First).Prev := 0;\n-\n-         return;\n-      end if;\n-\n-      if Position.Node = Container.First then\n-         Container.First := N (Position.Node).Next;\n-         N (Container.First).Prev := 0;\n-\n-      elsif Position.Node = Container.Last then\n-         Container.Last := N (Position.Node).Prev;\n-         N (Container.Last).Next := 0;\n-\n-      else\n-         N (N (Position.Node).Prev).Next := N (Position.Node).Next;\n-         N (N (Position.Node).Next).Prev := N (Position.Node).Prev;\n-      end if;\n-\n-      N (N (Before.Node).Prev).Next := Position.Node;\n-      N (Position.Node).Prev := N (Before.Node).Prev;\n-\n-      N (Before.Node).Prev := Position.Node;\n-      N (Position.Node).Next := Before.Node;\n-\n-      pragma Assert (N (Container.First).Prev = 0);\n-      pragma Assert (N (Container.Last).Next = 0);\n-   end Splice;\n-\n-   ----------\n-   -- Swap --\n-   ----------\n-\n-   procedure Swap\n-     (Container : in out List;\n-      I         : Cursor;\n-      J         : Cursor)\n-   is\n-   begin\n-      if I.Node = 0 then\n-         raise Constraint_Error with \"I cursor has no element\";\n-      end if;\n-\n-      if J.Node = 0 then\n-         raise Constraint_Error with \"J cursor has no element\";\n-      end if;\n-\n-      if I.Node = J.Node then\n-         return;\n-      end if;\n-\n-      pragma Assert (Vet (Container, I), \"bad I cursor in Swap\");\n-      pragma Assert (Vet (Container, J), \"bad J cursor in Swap\");\n-\n-      declare\n-         NN : Node_Array_Access renames Container.Nodes;\n-         NI : Node_Type renames NN (I.Node);\n-         NJ : Node_Type renames NN (J.Node);\n-\n-         EI_Copy : constant Element_Access := NI.Element;\n-\n-      begin\n-         NI.Element := NJ.Element;\n-         NJ.Element := EI_Copy;\n-      end;\n-   end Swap;\n-\n-   ----------------\n-   -- Swap_Links --\n-   ----------------\n-\n-   procedure Swap_Links\n-     (Container : in out List;\n-      I         : Cursor;\n-      J         : Cursor)\n-   is\n-      I_Next : Cursor;\n-      J_Next : Cursor;\n-\n-   begin\n-      if I.Node = 0 then\n-         raise Constraint_Error with \"I cursor has no element\";\n-      end if;\n-\n-      if J.Node = 0 then\n-         raise Constraint_Error with \"J cursor has no element\";\n-      end if;\n-\n-      if I.Node = J.Node then\n-         return;\n-      end if;\n-\n-      pragma Assert (Vet (Container, I), \"bad I cursor in Swap_Links\");\n-      pragma Assert (Vet (Container, J), \"bad J cursor in Swap_Links\");\n-\n-      I_Next := Next (Container, I);\n-\n-      if I_Next = J then\n-         Splice (Container, Before => I, Position => J);\n-\n-      else\n-         J_Next := Next (Container, J);\n-\n-         if J_Next = I then\n-            Splice (Container, Before => J, Position => I);\n-\n-         else\n-            pragma Assert (Container.Length >= 3);\n-            Splice (Container, Before => I_Next, Position => J);\n-            Splice (Container, Before => J_Next, Position => I);\n-         end if;\n-      end if;\n-   end Swap_Links;\n-\n-   ---------\n-   -- Vet --\n-   ---------\n-\n-   function Vet (L : List; Position : Cursor) return Boolean is\n-      N : Node_Array_Access renames L.Nodes;\n-   begin\n-      if not Container_Checks'Enabled then\n-         return True;\n-      end if;\n-\n-      if L.Length = 0 then\n-         return False;\n-      end if;\n-\n-      if L.First = 0 then\n-         return False;\n-      end if;\n-\n-      if L.Last = 0 then\n-         return False;\n-      end if;\n-\n-      if Position.Node > L.Nodes'Length then\n-         return False;\n-      end if;\n-\n-      if N (Position.Node).Prev < 0\n-        or else N (Position.Node).Prev > L.Nodes'Length\n-      then\n-         return False;\n-      end if;\n-\n-      if N (Position.Node).Next > L.Nodes'Length then\n-         return False;\n-      end if;\n-\n-      if N (L.First).Prev /= 0 then\n-         return False;\n-      end if;\n-\n-      if N (L.Last).Next /= 0 then\n-         return False;\n-      end if;\n-\n-      if N (Position.Node).Prev = 0 and then Position.Node /= L.First then\n-         return False;\n-      end if;\n-\n-      if N (Position.Node).Next = 0 and then Position.Node /= L.Last then\n-         return False;\n-      end if;\n-\n-      if L.Length = 1 then\n-         return L.First = L.Last;\n-      end if;\n-\n-      if L.First = L.Last then\n-         return False;\n-      end if;\n-\n-      if N (L.First).Next = 0 then\n-         return False;\n-      end if;\n-\n-      if N (L.Last).Prev = 0 then\n-         return False;\n-      end if;\n-\n-      if N (N (L.First).Next).Prev /= L.First then\n-         return False;\n-      end if;\n-\n-      if N (N (L.Last).Prev).Next /= L.Last then\n-         return False;\n-      end if;\n-\n-      if L.Length = 2 then\n-         if N (L.First).Next /= L.Last then\n-            return False;\n-         end if;\n-\n-         if N (L.Last).Prev /= L.First then\n-            return False;\n-         end if;\n-\n-         return True;\n-      end if;\n-\n-      if N (L.First).Next = L.Last then\n-         return False;\n-      end if;\n-\n-      if N (L.Last).Prev = L.First then\n-         return False;\n-      end if;\n-\n-      if Position.Node = L.First then\n-         return True;\n-      end if;\n-\n-      if Position.Node = L.Last then\n-         return True;\n-      end if;\n-\n-      if N (Position.Node).Next = 0 then\n-         return False;\n-      end if;\n-\n-      if N (Position.Node).Prev = 0 then\n-         return False;\n-      end if;\n-\n-      if N (N (Position.Node).Next).Prev /= Position.Node then\n-         return False;\n-      end if;\n-\n-      if N (N (Position.Node).Prev).Next /= Position.Node then\n-         return False;\n-      end if;\n-\n-      if L.Length = 3 then\n-         if N (L.First).Next /= Position.Node then\n-            return False;\n-         end if;\n-\n-         if N (L.Last).Prev /= Position.Node then\n-            return False;\n-         end if;\n-      end if;\n-\n-      return True;\n-   end Vet;\n-\n-end Ada.Containers.Formal_Indefinite_Doubly_Linked_Lists;"}, {"sha": "cbddde31b918d29ac0c4b096e31b1adce1fa7927", "filename": "gcc/ada/libgnat/a-cfidll.ads", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fa-cfidll.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fa-cfidll.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cfidll.ads?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "7b457f6fb9f57a06e625b6a72b6c7494a0ce656b", "filename": "gcc/ada/libgnat/a-cfinse.adb", "status": "removed", "additions": 0, "deletions": 304, "changes": 304, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6da3cab7b0acf5dc363c85069bef716923ddf90c/gcc%2Fada%2Flibgnat%2Fa-cfinse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6da3cab7b0acf5dc363c85069bef716923ddf90c/gcc%2Fada%2Flibgnat%2Fa-cfinse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cfinse.adb?ref=6da3cab7b0acf5dc363c85069bef716923ddf90c"}, {"sha": "6f517fa804615a561269dc4071a3020cef364e56", "filename": "gcc/ada/libgnat/a-cfinse.ads", "status": "modified", "additions": 5, "deletions": 345, "changes": 350, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fa-cfinse.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fa-cfinse.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cfinse.ads?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "a55786d95d0b86d323c914e32b4166f533331460", "filename": "gcc/ada/libgnat/a-cfinve.adb", "status": "removed", "additions": 0, "deletions": 1452, "changes": 1452, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6da3cab7b0acf5dc363c85069bef716923ddf90c/gcc%2Fada%2Flibgnat%2Fa-cfinve.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6da3cab7b0acf5dc363c85069bef716923ddf90c/gcc%2Fada%2Flibgnat%2Fa-cfinve.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cfinve.adb?ref=6da3cab7b0acf5dc363c85069bef716923ddf90c"}, {"sha": "dcec6ba3cd5b9442443d174042f88e56c555eb90", "filename": "gcc/ada/libgnat/a-cfinve.ads", "status": "modified", "additions": 5, "deletions": 952, "changes": 957, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fa-cfinve.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fa-cfinve.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cfinve.ads?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "38d15e7bb091d78b080981028fb8534868d215a5", "filename": "gcc/ada/libgnat/a-cforma.adb", "status": "removed", "additions": 0, "deletions": 1239, "changes": 1239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6da3cab7b0acf5dc363c85069bef716923ddf90c/gcc%2Fada%2Flibgnat%2Fa-cforma.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6da3cab7b0acf5dc363c85069bef716923ddf90c/gcc%2Fada%2Flibgnat%2Fa-cforma.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cforma.adb?ref=6da3cab7b0acf5dc363c85069bef716923ddf90c"}, {"sha": "21a5d78dfc8d7b8371f069b47b399ab08207c71f", "filename": "gcc/ada/libgnat/a-cforma.ads", "status": "modified", "additions": 5, "deletions": 1117, "changes": 1122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fa-cforma.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fa-cforma.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cforma.ads?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "e5cddde498527a039ca006f0d8b827ba41e866a5", "filename": "gcc/ada/libgnat/a-cforse.adb", "status": "removed", "additions": 0, "deletions": 1939, "changes": 1939, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6da3cab7b0acf5dc363c85069bef716923ddf90c/gcc%2Fada%2Flibgnat%2Fa-cforse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6da3cab7b0acf5dc363c85069bef716923ddf90c/gcc%2Fada%2Flibgnat%2Fa-cforse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cforse.adb?ref=6da3cab7b0acf5dc363c85069bef716923ddf90c"}, {"sha": "fe5de2bff4ee1f8e8108668a9e2a5d2f65e089c2", "filename": "gcc/ada/libgnat/a-cforse.ads", "status": "modified", "additions": 5, "deletions": 1778, "changes": 1783, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fa-cforse.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fa-cforse.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cforse.ads?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "c921184eb0347e11e30a7bfac3730bb7ad1b78b1", "filename": "gcc/ada/libgnat/a-cofove.adb", "status": "removed", "additions": 0, "deletions": 1311, "changes": 1311, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6da3cab7b0acf5dc363c85069bef716923ddf90c/gcc%2Fada%2Flibgnat%2Fa-cofove.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6da3cab7b0acf5dc363c85069bef716923ddf90c/gcc%2Fada%2Flibgnat%2Fa-cofove.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cofove.adb?ref=6da3cab7b0acf5dc363c85069bef716923ddf90c"}, {"sha": "fb9301fe7f5cdf0e704ebebf1d9a94e2fe28d957", "filename": "gcc/ada/libgnat/a-cofove.ads", "status": "modified", "additions": 5, "deletions": 947, "changes": 952, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fa-cofove.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fa-cofove.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cofove.ads?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "68cf2ae585729b71dbecbc2614571bb53852f0d5", "filename": "gcc/ada/libgnat/a-cofuba.adb", "status": "removed", "additions": 0, "deletions": 432, "changes": 432, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6da3cab7b0acf5dc363c85069bef716923ddf90c/gcc%2Fada%2Flibgnat%2Fa-cofuba.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6da3cab7b0acf5dc363c85069bef716923ddf90c/gcc%2Fada%2Flibgnat%2Fa-cofuba.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cofuba.adb?ref=6da3cab7b0acf5dc363c85069bef716923ddf90c"}, {"sha": "8a99a433837427edcb157bf8a384a5376c9cc67e", "filename": "gcc/ada/libgnat/a-cofuba.ads", "status": "removed", "additions": 0, "deletions": 198, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6da3cab7b0acf5dc363c85069bef716923ddf90c/gcc%2Fada%2Flibgnat%2Fa-cofuba.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6da3cab7b0acf5dc363c85069bef716923ddf90c/gcc%2Fada%2Flibgnat%2Fa-cofuba.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cofuba.ads?ref=6da3cab7b0acf5dc363c85069bef716923ddf90c"}, {"sha": "f83b4d829f767f0506d0c07f98535b16e0e61bfc", "filename": "gcc/ada/libgnat/a-cofuma.adb", "status": "removed", "additions": 0, "deletions": 306, "changes": 306, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6da3cab7b0acf5dc363c85069bef716923ddf90c/gcc%2Fada%2Flibgnat%2Fa-cofuma.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6da3cab7b0acf5dc363c85069bef716923ddf90c/gcc%2Fada%2Flibgnat%2Fa-cofuma.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cofuma.adb?ref=6da3cab7b0acf5dc363c85069bef716923ddf90c"}, {"sha": "9b4863af0bfc5d86b41923ebbaaa2714fd23efe0", "filename": "gcc/ada/libgnat/a-cofuma.ads", "status": "modified", "additions": 5, "deletions": 361, "changes": 366, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fa-cofuma.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fa-cofuma.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cofuma.ads?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "bbb3f7e96f9e6c1489e82d3be64f2bb46c295556", "filename": "gcc/ada/libgnat/a-cofuse.adb", "status": "removed", "additions": 0, "deletions": 184, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6da3cab7b0acf5dc363c85069bef716923ddf90c/gcc%2Fada%2Flibgnat%2Fa-cofuse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6da3cab7b0acf5dc363c85069bef716923ddf90c/gcc%2Fada%2Flibgnat%2Fa-cofuse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cofuse.adb?ref=6da3cab7b0acf5dc363c85069bef716923ddf90c"}, {"sha": "9c57ba193a49d9ceeedf82605cb0e42cafd3b99a", "filename": "gcc/ada/libgnat/a-cofuse.ads", "status": "modified", "additions": 5, "deletions": 301, "changes": 306, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fa-cofuse.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fa-cofuse.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cofuse.ads?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "0d91da5015e8f308f6a9bd03bc43a69fa8378126", "filename": "gcc/ada/libgnat/a-cofuve.adb", "status": "removed", "additions": 0, "deletions": 262, "changes": 262, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6da3cab7b0acf5dc363c85069bef716923ddf90c/gcc%2Fada%2Flibgnat%2Fa-cofuve.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6da3cab7b0acf5dc363c85069bef716923ddf90c/gcc%2Fada%2Flibgnat%2Fa-cofuve.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cofuve.adb?ref=6da3cab7b0acf5dc363c85069bef716923ddf90c"}, {"sha": "da0611e7d154cac0d520c19a1dfb18ae02e2a48d", "filename": "gcc/ada/libgnat/a-cofuve.ads", "status": "modified", "additions": 5, "deletions": 376, "changes": 381, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fa-cofuve.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fa-cofuve.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cofuve.ads?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "46d6730ad55c5c055275c3db3e3625ec5fc86675", "filename": "gcc/ada/libgnat/a-coinve.adb", "status": "modified", "additions": 23, "deletions": 18, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fa-coinve.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fa-coinve.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-coinve.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "751d468b1a3e04fda59be6ab7d8d8fc721bc3dd3", "filename": "gcc/ada/libgnat/a-convec.adb", "status": "modified", "additions": 26, "deletions": 21, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fa-convec.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fa-convec.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-convec.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "fed41ec5d2db63144d4313fb2222c1e26091a40d", "filename": "gcc/ada/libgnat/a-coorse.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fa-coorse.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fa-coorse.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-coorse.ads?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "3979f147d2a18969027c575e3ba91aaca5381de2", "filename": "gcc/ada/libgnat/a-nbnbig.ads", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fa-nbnbig.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fa-nbnbig.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-nbnbig.ads?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "e092db046caaa42741105eb0b253713721154778", "filename": "gcc/ada/libgnat/a-strmap.adb", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fa-strmap.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fa-strmap.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-strmap.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "652c79716fed0b956f0d12c27c935ca18c2fa3a7", "filename": "gcc/ada/libgnat/a-strsea.adb", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fa-strsea.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fa-strsea.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-strsea.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "831a18e1e19a4e1602108d325e3afbc82f713a59", "filename": "gcc/ada/libgnat/a-strsup.adb", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fa-strsup.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fa-strsup.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-strsup.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "d325676edf9333e278eb6f4312d9968c293decaf", "filename": "gcc/ada/libgnat/a-stwisu.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fa-stwisu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fa-stwisu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-stwisu.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "6153bbe392f8d69a56a25ebcc41796979baf2de7", "filename": "gcc/ada/libgnat/a-stzsup.adb", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fa-stzsup.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fa-stzsup.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-stzsup.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "52f23601448e37dfc890ed33b45c8405a249e90e", "filename": "gcc/ada/libgnat/s-aridou.adb", "status": "modified", "additions": 210, "deletions": 122, "changes": 332, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-aridou.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-aridou.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-aridou.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "08af4f5868907b41f4fe5764e5c3f38c504dac21", "filename": "gcc/ada/libgnat/s-aridou.ads", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-aridou.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-aridou.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-aridou.ads?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "f1fdf71207406f1d737befe054395f29e190a37a", "filename": "gcc/ada/libgnat/s-expmod.adb", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-expmod.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-expmod.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-expmod.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "bfe854038884fd3a2eac50433070ffd63b6ce7e4", "filename": "gcc/ada/libgnat/s-imagef.adb", "status": "modified", "additions": 10, "deletions": 63, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-imagef.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-imagef.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imagef.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "c467777c7b02c281d2771eeae087a8504d562393", "filename": "gcc/ada/libgnat/s-imagei.adb", "status": "modified", "additions": 114, "deletions": 140, "changes": 254, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-imagei.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-imagei.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imagei.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "575c60abb2c849aae1049587a3753eaf49addc91", "filename": "gcc/ada/libgnat/s-imagei.ads", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-imagei.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-imagei.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imagei.ads?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "0e1c2bb593fa4cc107db3457e6cd0def5672f284", "filename": "gcc/ada/libgnat/s-imageu.adb", "status": "modified", "additions": 92, "deletions": 102, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-imageu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-imageu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imageu.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "3d80ea9af5a820c6f5d908b4489a877e5e9de6cc", "filename": "gcc/ada/libgnat/s-imageu.ads", "status": "modified", "additions": 11, "deletions": 33, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-imageu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-imageu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imageu.ads?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "8672e58b083d6dad7021de9636cf46a726263f04", "filename": "gcc/ada/libgnat/s-imgint.ads", "status": "modified", "additions": 5, "deletions": 22, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-imgint.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-imgint.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imgint.ads?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "99c1951348d39e030178e6dc779c1a4da27d1cb5", "filename": "gcc/ada/libgnat/s-imglli.ads", "status": "modified", "additions": 7, "deletions": 23, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-imglli.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-imglli.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imglli.ads?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "931c288d20e55157892de3c79101cdf11a76549d", "filename": "gcc/ada/libgnat/s-imgllli.ads", "status": "modified", "additions": 5, "deletions": 22, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-imgllli.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-imgllli.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imgllli.ads?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "53b39a8fdd22af1f32285a4042c17bba64db0560", "filename": "gcc/ada/libgnat/s-imglllu.ads", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-imglllu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-imglllu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imglllu.ads?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "28339cd7afe451aafd398ad5b52f45634921eb09", "filename": "gcc/ada/libgnat/s-imgllu.ads", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-imgllu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-imgllu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imgllu.ads?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "120bd5db7df171fb84da46e052c65f2c803a3b00", "filename": "gcc/ada/libgnat/s-imguns.ads", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-imguns.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-imguns.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imguns.ads?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "df7c7df17b28e94b32e008074f6c8f78a70a898e", "filename": "gcc/ada/libgnat/s-maccod.ads", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-maccod.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-maccod.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-maccod.ads?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "24e22c973ef5807fd7f665cbfc12c29b10e6259a", "filename": "gcc/ada/libgnat/s-powflt.ads", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-powflt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-powflt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-powflt.ads?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "a627c0c6a82dc57ea23f450960fda4bafbb5397e", "filename": "gcc/ada/libgnat/s-powlfl.ads", "status": "modified", "additions": 60, "deletions": 3, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-powlfl.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-powlfl.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-powlfl.ads?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "4b5f1ae199e53de2d0aa689121a0389550a4c461", "filename": "gcc/ada/libgnat/s-powllf.ads", "status": "modified", "additions": 70, "deletions": 3, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-powllf.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-powllf.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-powllf.ads?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "dca2fd782f5adfb8d4653f90e33c74890036ac33", "filename": "gcc/ada/libgnat/s-vaispe.adb", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-vaispe.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-vaispe.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-vaispe.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "5a5e051620ab783a990665992a604b55054d75e5", "filename": "gcc/ada/libgnat/s-vaispe.ads", "status": "added", "additions": 199, "deletions": 0, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-vaispe.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-vaispe.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-vaispe.ads?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "cc8f583a8d13bbc26cba50bb1ce4c578f6fed7c4", "filename": "gcc/ada/libgnat/s-valflt.ads", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-valflt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-valflt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valflt.ads?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "3872d7cc7e12bc1ec38001ad2ef154f59d3243c0", "filename": "gcc/ada/libgnat/s-valint.ads", "status": "modified", "additions": 4, "deletions": 17, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-valint.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-valint.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valint.ads?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "12be755049d3dcfd45d1b8fbf51484bf82dacab1", "filename": "gcc/ada/libgnat/s-vallfl.ads", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-vallfl.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-vallfl.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-vallfl.ads?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "80566c3331bed9940d1a15597c17959b5d3eadf2", "filename": "gcc/ada/libgnat/s-valllf.ads", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-valllf.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-valllf.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valllf.ads?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "85bf28203b588c8f07c004ef8a6196b3d5cf810b", "filename": "gcc/ada/libgnat/s-vallli.ads", "status": "modified", "additions": 4, "deletions": 18, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-vallli.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-vallli.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-vallli.ads?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "e53fb0b0357c1fac1c54df50862dbbef1a3a46af", "filename": "gcc/ada/libgnat/s-valllli.ads", "status": "modified", "additions": 4, "deletions": 18, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-valllli.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-valllli.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valllli.ads?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "079c48b3785eec21f2eac89fff1ff834af77b45c", "filename": "gcc/ada/libgnat/s-valrea.adb", "status": "modified", "additions": 207, "deletions": 138, "changes": 345, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-valrea.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-valrea.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valrea.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "89be8d7219c8bc573327cf12c507ecc00cc5efe1", "filename": "gcc/ada/libgnat/s-valrea.ads", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-valrea.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-valrea.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valrea.ads?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "92e9140443e29eb48dd72f666ea9de25a262b083", "filename": "gcc/ada/libgnat/s-valued.adb", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-valued.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-valued.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valued.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "1b9d18ef7083cdf941e98e84a3f97219f60c2bd5", "filename": "gcc/ada/libgnat/s-valuef.adb", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-valuef.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-valuef.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valuef.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "51764b20c9d837d1f57de84fd8361100b4199563", "filename": "gcc/ada/libgnat/s-valuei.adb", "status": "modified", "additions": 37, "deletions": 58, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-valuei.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-valuei.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valuei.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "3f78db6ee4348cedd329fca1131fed1021953511", "filename": "gcc/ada/libgnat/s-valuei.ads", "status": "modified", "additions": 21, "deletions": 167, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-valuei.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-valuei.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valuei.ads?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "c55444a1ec7b8968247f6ac7dbb032836a5a66fb", "filename": "gcc/ada/libgnat/s-valuer.adb", "status": "modified", "additions": 131, "deletions": 88, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-valuer.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-valuer.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valuer.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "d9d168ecb3e857621ed770384cfff2d3857a4240", "filename": "gcc/ada/libgnat/s-valuer.ads", "status": "modified", "additions": 25, "deletions": 6, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-valuer.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-valuer.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valuer.ads?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "8f19086508bce002d96df1527ae671313d2927b4", "filename": "gcc/ada/libgnat/s-valueu.adb", "status": "modified", "additions": 127, "deletions": 317, "changes": 444, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-valueu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-valueu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valueu.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "466b96a6fa6099b72c8c8db34782c731c56bfad3", "filename": "gcc/ada/libgnat/s-valueu.ads", "status": "modified", "additions": 15, "deletions": 463, "changes": 478, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-valueu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-valueu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valueu.ads?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "7c2da17aa53c0411a57e993ff8248a56b38a4d76", "filename": "gcc/ada/libgnat/s-valuti.ads", "status": "modified", "additions": 247, "deletions": 21, "changes": 268, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-valuti.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-valuti.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valuti.ads?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "1a870b9b99709ef345ee850989cd01a27e410776", "filename": "gcc/ada/libgnat/s-vauspe.adb", "status": "added", "additions": 198, "deletions": 0, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-vauspe.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-vauspe.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-vauspe.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "0d5c19e8c532685ceb026ebce28c1142721e54da", "filename": "gcc/ada/libgnat/s-vauspe.ads", "status": "added", "additions": 639, "deletions": 0, "changes": 639, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-vauspe.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-vauspe.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-vauspe.ads?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "df5f224426c867e5a289815b054835070928fda3", "filename": "gcc/ada/libgnat/s-widthu.adb", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-widthu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fs-widthu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-widthu.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "038fe6c9230f6cf76f09b610d31ebd8aa029691e", "filename": "gcc/ada/libgnat/system-qnx-arm.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fsystem-qnx-arm.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fsystem-qnx-arm.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-qnx-arm.ads?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "ae67cd0bab8cf795bb8f00d0379cf917fa1e5dd7", "filename": "gcc/ada/libgnat/system-vxworks7-aarch64-rtp-smp.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-aarch64-rtp-smp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-aarch64-rtp-smp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-aarch64-rtp-smp.ads?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "a943ecd9c4a43c00855d64add8bd60bb4ca4e9eb", "filename": "gcc/ada/libgnat/system-vxworks7-aarch64.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-aarch64.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-aarch64.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-aarch64.ads?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "49e6e7adeeb2144dd2d51c0044fed0eb3f6e401e", "filename": "gcc/ada/libgnat/system-vxworks7-arm-rtp-smp.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-arm-rtp-smp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-arm-rtp-smp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-arm-rtp-smp.ads?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "6d3218f456f7a2921d78dbf3c4329374d55af329", "filename": "gcc/ada/libgnat/system-vxworks7-arm.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-arm.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-arm.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-arm.ads?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "e34c22aba0bcdf3f3ad776bfc8d3d043a7d2ed49", "filename": "gcc/ada/libgnat/system-vxworks7-x86-kernel.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-x86-kernel.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-x86-kernel.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-x86-kernel.ads?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "68ca423cd1283f61c01326804917bcbf60084ce8", "filename": "gcc/ada/libgnat/system-vxworks7-x86-rtp-smp.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-x86-rtp-smp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-x86-rtp-smp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-x86-rtp-smp.ads?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "6504a027a284e2e76a15ffe47cdf8c4128767795", "filename": "gcc/ada/libgnat/system-vxworks7-x86_64-kernel.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-x86_64-kernel.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-x86_64-kernel.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-x86_64-kernel.ads?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "ffcc78fc80918961b3b226e46e53b272f39cdc20", "filename": "gcc/ada/libgnat/system-vxworks7-x86_64-rtp-smp.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-x86_64-rtp-smp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-x86_64-rtp-smp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-x86_64-rtp-smp.ads?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "8f903ca7efd7d5d744b56a27d0c27c2c0b409c98", "filename": "gcc/ada/opt.ads", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "70fd7ad70eaa6bac765a279eec5c2316d4d84196", "filename": "gcc/ada/par-ch10.adb", "status": "modified", "additions": 6, "deletions": 23, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fpar-ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fpar-ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch10.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "0f124f041586e28a68bd375eb31e9f854cb686ba", "filename": "gcc/ada/par-ch12.adb", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fpar-ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fpar-ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch12.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "62e58076baa965d44a63bef318efdd2c963dc25e", "filename": "gcc/ada/par-ch13.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fpar-ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fpar-ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch13.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "568483997082fe1e27366023b39203546745110f", "filename": "gcc/ada/par-ch3.adb", "status": "modified", "additions": 25, "deletions": 46, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fpar-ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fpar-ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch3.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "0dc6c8ac1086b903033e8b7778ea12d0926cf8f0", "filename": "gcc/ada/par-ch4.adb", "status": "modified", "additions": 407, "deletions": 418, "changes": 825, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fpar-ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fpar-ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch4.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "60b52bfb58aac21f511f30ed4468bd9e973f1c74", "filename": "gcc/ada/par-ch5.adb", "status": "modified", "additions": 36, "deletions": 75, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fpar-ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fpar-ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch5.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "4f06297b4558eced2d73fa79118989800aeea3e9", "filename": "gcc/ada/par-ch6.adb", "status": "modified", "additions": 15, "deletions": 43, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fpar-ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fpar-ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch6.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "07c910a101607dee5d99c330827f9d027c0d88eb", "filename": "gcc/ada/par-ch7.adb", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fpar-ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fpar-ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch7.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "6e9139c8eeead84b76a3337711f312f454133256", "filename": "gcc/ada/par-ch8.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fpar-ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fpar-ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch8.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "310494eaf3b8740555d513fa1943504e023e3963", "filename": "gcc/ada/par-ch9.adb", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fpar-ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fpar-ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch9.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "15b21cdddcfcf3e5b590750b816cc74ec780082b", "filename": "gcc/ada/par-endh.adb", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fpar-endh.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fpar-endh.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-endh.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "570d22944aadba47d8a883aec0cad016b2d38c63", "filename": "gcc/ada/par-sync.adb", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fpar-sync.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fpar-sync.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-sync.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "3989cd25015ccc74a7da4238a473a6d2a55b17c9", "filename": "gcc/ada/par-tchk.adb", "status": "modified", "additions": 11, "deletions": 24, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fpar-tchk.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fpar-tchk.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-tchk.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "038741853d77d46c9f9a95a55ec150efcd84175b", "filename": "gcc/ada/par-util.adb", "status": "modified", "additions": 12, "deletions": 22, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fpar-util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fpar-util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-util.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "01e3c4b1a4f4737b3c98e83fca97668341f4e248", "filename": "gcc/ada/par.adb", "status": "modified", "additions": 27, "deletions": 34, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fpar.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fpar.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "6731baeb6e1e13d07d60a8da00829c979a18deb0", "filename": "gcc/ada/prep.adb", "status": "modified", "additions": 14, "deletions": 29, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fprep.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fprep.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprep.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "a1fe0254de1492babb85761f160008a24604e1c2", "filename": "gcc/ada/prepcomp.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fprepcomp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fprepcomp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprepcomp.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "b6698a673638626cb8208cdc67ace3e1d4b257b1", "filename": "gcc/ada/scng.adb", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fscng.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fscng.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscng.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "5c7633bbb6b19ef1fc0cb6cf1a05f1287f78f3a8", "filename": "gcc/ada/sem.ads", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fsem.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fsem.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem.ads?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "5db1fce01b08fa3c45328bcb4b5c4275a0769b51", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 72, "deletions": 102, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "0d305a8923fde132e688327988e96d4d81067e04", "filename": "gcc/ada/sem_aggr.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fsem_aggr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fsem_aggr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.ads?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "0c88be71b94413411399c9fa9aa2fd1c2f97aeff", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 27, "deletions": 70, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "2810d3e3f9d879a6cb75721ecbc43706018359d9", "filename": "gcc/ada/sem_case.adb", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fsem_case.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fsem_case.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_case.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "339edd35d91698f2339fd70c65433be0ed8de0ef", "filename": "gcc/ada/sem_ch11.adb", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fsem_ch11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fsem_ch11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch11.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "54b10dd6597365f4e1eb58d285593551de4a03b3", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 417, "deletions": 399, "changes": 816, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "1405f89f598358413da694363e35b9abaf7b4baa", "filename": "gcc/ada/sem_ch13.ads", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fsem_ch13.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fsem_ch13.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.ads?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "00c2e67fa20dd5558df6dd8e511b76347be1d381", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 24, "deletions": 68, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "ceaf66bd3e2a434e90f4386fe82e1bb4c2477bf5", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 123, "deletions": 34, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "17bf6d91b44bb6e89c0923d6f166e7dceb87a843", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "7db0cb7c08f7293f35e9788e54729ec0396c6818", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 52, "deletions": 51, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "cae0f233c52a4c50c56f58f8d261510f5ad3ab34", "filename": "gcc/ada/sem_ch9.adb", "status": "modified", "additions": 214, "deletions": 179, "changes": 393, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fsem_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fsem_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch9.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "841fc741dfcbf13f119216a8f29855f9bcf082c9", "filename": "gcc/ada/sem_disp.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fsem_disp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fsem_disp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_disp.ads?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "f912f8bfb0a2c41b95268d84526b40d6139a423f", "filename": "gcc/ada/sem_elab.adb", "status": "modified", "additions": 7, "deletions": 50, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fsem_elab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fsem_elab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elab.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "77ff68e23cb5cc47108084fba013360e891e32c8", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 41, "deletions": 23, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "619f8411f5c5e549f82370fab760b508a084c916", "filename": "gcc/ada/sem_prag.ads", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fsem_prag.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fsem_prag.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.ads?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "76750708bcad93f22cbf1bb56b3eecebf4559f60", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 30, "deletions": 3, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "b0babeb9d6f19679a6c7d8cfbc6452b054e04e73", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 107, "deletions": 100, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "132c2b8cddf3da7c4924a85507d97aa1ef8b5bfb", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "3c85aa206f2b09a0759812797049074d21438a1c", "filename": "gcc/ada/sigtramp-vxworks-target.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fsigtramp-vxworks-target.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fsigtramp-vxworks-target.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsigtramp-vxworks-target.h?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "3f250349a0c1913b12f4bc6805db55de5c0f356e", "filename": "gcc/ada/sinfo-utils.ads", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fsinfo-utils.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fsinfo-utils.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo-utils.ads?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "53880c5dfce77b1a8f6ac808052bd9625dbf8a7c", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 31, "deletions": 14, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "9b087e6cd62c80a8c22d595c67c5fd30263f6d25", "filename": "gcc/ada/snames.adb-tmpl", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fsnames.adb-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fsnames.adb-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.adb-tmpl?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "8f71ad98db3e22aab84fe9f99f866e12efdc966a", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "0f292c870b846a1bccf10680dd180a0964bc35f1", "filename": "gcc/ada/sprint.adb", "status": "modified", "additions": 37, "deletions": 11, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fsprint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fsprint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsprint.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "c40cb970bef48c1b478e695f143b670305b7d359", "filename": "gcc/ada/switch-b.adb", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fswitch-b.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fswitch-b.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fswitch-b.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "a9f40887d8a6ff652c1020681321a6c39a579c7d", "filename": "gcc/ada/treepr.adb", "status": "modified", "additions": 5, "deletions": 17, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Ftreepr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Ftreepr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftreepr.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "248298acded855514463d2ccc1d0f6d6c53fed71", "filename": "gcc/ada/uintp.adb", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fuintp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fada%2Fuintp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fuintp.adb?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "3af1a38cec379773d61d9423f54d14256fdf665e", "filename": "gcc/analyzer/ChangeLog", "status": "modified", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fanalyzer%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fanalyzer%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2FChangeLog?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "b325aee37ce959b3136168b2d2d6e5f9de69450a", "filename": "gcc/analyzer/analyzer.h", "status": "modified", "additions": 28, "deletions": 8, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fanalyzer%2Fanalyzer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fanalyzer%2Fanalyzer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer.h?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "dbab3b82deb34a5aab1f155b9bda60c255f2d7b3", "filename": "gcc/analyzer/analyzer.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fanalyzer%2Fanalyzer.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fanalyzer%2Fanalyzer.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer.opt?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "22bae2f34b1c227e1c820329b5f308212f17320c", "filename": "gcc/analyzer/checker-path.cc", "status": "modified", "additions": 77, "deletions": 14, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fanalyzer%2Fchecker-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fanalyzer%2Fchecker-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fchecker-path.cc?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "5d009340189543d466ad071d71b49cb75a7b1557", "filename": "gcc/analyzer/checker-path.h", "status": "modified", "additions": 30, "deletions": 4, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fanalyzer%2Fchecker-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fanalyzer%2Fchecker-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fchecker-path.h?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "2d185a1f3e6bb8a8fa98de89061bb2f411561b16", "filename": "gcc/analyzer/diagnostic-manager.cc", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fdiagnostic-manager.cc?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "742ac02e4f28d8bf9c85fecdba8c2f8325190ce5", "filename": "gcc/analyzer/engine.cc", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fanalyzer%2Fengine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fanalyzer%2Fengine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fengine.cc?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "f0fd4fc527174877f8f1468550fc3f272b3c1db5", "filename": "gcc/analyzer/known-function-manager.cc", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fanalyzer%2Fknown-function-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fanalyzer%2Fknown-function-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fknown-function-manager.cc?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "fbde853a721b1af0d5aeb95b4635a09c1ca79a60", "filename": "gcc/analyzer/known-function-manager.h", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fanalyzer%2Fknown-function-manager.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fanalyzer%2Fknown-function-manager.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fknown-function-manager.h?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "71fb2770143224c72387824b06b48e16d3c07f98", "filename": "gcc/analyzer/region-model-impl-calls.cc", "status": "modified", "additions": 37, "deletions": 29, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "cbda77f3d9ce482041763e6282f02fc33645bbe7", "filename": "gcc/analyzer/region-model-manager.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fanalyzer%2Fregion-model-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fanalyzer%2Fregion-model-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-manager.cc?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "22c52872c3e33d10814fbd2c126204a5ca25d828", "filename": "gcc/analyzer/region-model.cc", "status": "modified", "additions": 1140, "deletions": 32, "changes": 1172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fanalyzer%2Fregion-model.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fanalyzer%2Fregion-model.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.cc?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "e86720a645c72d25c6398b921c9e4824c1b5baac", "filename": "gcc/analyzer/region-model.h", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fanalyzer%2Fregion-model.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fanalyzer%2Fregion-model.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.h?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "09646bfc98ab68afaa4943bd2fe4e719cfeb67fe", "filename": "gcc/analyzer/region.cc", "status": "modified", "additions": 127, "deletions": 14, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fanalyzer%2Fregion.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fanalyzer%2Fregion.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion.cc?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "6315fac62e543782a43f8cb4ddbcd3ce8a0d84e5", "filename": "gcc/analyzer/region.h", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fanalyzer%2Fregion.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fanalyzer%2Fregion.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion.h?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "f5c0cc13a2f39123ca7e5c460bf656f3195fefa7", "filename": "gcc/analyzer/sm-taint.cc", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fanalyzer%2Fsm-taint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fanalyzer%2Fsm-taint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-taint.cc?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "1857d95f0b603d936f8a21f2677330da37ae5add", "filename": "gcc/analyzer/store.cc", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fanalyzer%2Fstore.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fanalyzer%2Fstore.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fstore.cc?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "d172ee756c8b8619dbf56f6c4e8718075b24a784", "filename": "gcc/analyzer/store.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fanalyzer%2Fstore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fanalyzer%2Fstore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fstore.h?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "b1f103222aac7ad087b02ad97c4ed4da6ff699f5", "filename": "gcc/attribs.cc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fattribs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fattribs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fattribs.cc?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "5f319b2803027f64e9fb699a969958cee35013cd", "filename": "gcc/builtins.cc", "status": "modified", "additions": 320, "deletions": 9, "changes": 329, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fbuiltins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fbuiltins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.cc?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "f02363168509cd5d9d6e2c55ea4f47ae0ee979dc", "filename": "gcc/builtins.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.def?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "415c4cf795493453d49364c54fd5ec3f9104f55d", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "8bb80e251dc26583afc3a0e17e651e7c2e2612d1", "filename": "gcc/c-family/c-attribs.cc", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fc-family%2Fc-attribs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fc-family%2Fc-attribs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-attribs.cc?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "dce3045c9f27a663ed08fef89fbb8a51842fadf2", "filename": "gcc/c-family/c-common.cc", "status": "modified", "additions": 36, "deletions": 15, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fc-family%2Fc-common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fc-family%2Fc-common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.cc?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "31397d800299abe31606685f5c2e9d497b631ae2", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 31, "deletions": 17, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "a1557eb23d5886b8f8612a7883bdb2e2a2ea4c18", "filename": "gcc/c-family/c-cppbuiltin.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fc-family%2Fc-cppbuiltin.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fc-family%2Fc-cppbuiltin.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-cppbuiltin.cc?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "a6c380bf1c87d9b13ec2cc7c26f1f0730536f9f1", "filename": "gcc/c-family/c-format.cc", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fc-family%2Fc-format.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fc-family%2Fc-format.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-format.cc?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "110d029ee0c44cec53fe25ab3e103622416a3813", "filename": "gcc/c-family/c-lex.cc", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fc-family%2Fc-lex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fc-family%2Fc-lex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-lex.cc?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "1b086d805813fa6e5e618e122ae37ad920538ea4", "filename": "gcc/c-family/c-omp.cc", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fc-family%2Fc-omp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fc-family%2Fc-omp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-omp.cc?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "babaa2fc157af8c724b2c600f5f81313518a9bcc", "filename": "gcc/c-family/c-opts.cc", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fc-family%2Fc-opts.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fc-family%2Fc-opts.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-opts.cc?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "c894a2594d622ac2c0bcb3d0cb9402dee88ef4d0", "filename": "gcc/c-family/c-pragma.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fc-family%2Fc-pragma.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fc-family%2Fc-pragma.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pragma.h?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "efa1768f4d6255719183c4cf028ea4d6d12fda3f", "filename": "gcc/c-family/c-pretty-print.cc", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fc-family%2Fc-pretty-print.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fc-family%2Fc-pretty-print.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pretty-print.cc?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "6742f447ff58424a32ec1640d95306fdac1f2adb", "filename": "gcc/c-family/c-warn.cc", "status": "modified", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fc-family%2Fc-warn.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fc-family%2Fc-warn.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-warn.cc?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "1c7f89eeb94e5c1c6896f1fd2268d67ec90ceba4", "filename": "gcc/c-family/c.opt", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fc-family%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fc-family%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc.opt?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "21248d35b31652a209d2e7762b2b1cae6d29ba63", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "6e7491339d427d72fb8eb3630894dd041d4fbcef", "filename": "gcc/c/c-convert.cc", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fc%2Fc-convert.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fc%2Fc-convert.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-convert.cc?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "b09c6393b91049fd99b296123e969aa280326c7d", "filename": "gcc/c/c-decl.cc", "status": "modified", "additions": 11, "deletions": 28, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fc%2Fc-decl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fc%2Fc-decl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.cc?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "bce79d3e61a548e64283e4d7944fbbcf4d82c805", "filename": "gcc/c/c-parser.cc", "status": "modified", "additions": 192, "deletions": 62, "changes": 254, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fc%2Fc-parser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fc%2Fc-parser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.cc?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "46a3e8e97098578896593f415a2660c8749c84e6", "filename": "gcc/c/c-tree.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-tree.h?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "ac242b5ed13d99cc52dc93abaa8ef26eccebccc3", "filename": "gcc/c/c-typeck.cc", "status": "modified", "additions": 130, "deletions": 45, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fc%2Fc-typeck.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fc%2Fc-typeck.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.cc?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "5a2da2cfa0e7a6d9a66968ef31c20eeaa2c89497", "filename": "gcc/c/gimple-parser.cc", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fc%2Fgimple-parser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fc%2Fgimple-parser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fgimple-parser.cc?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "296d6f194bf4f1379fb55991171b56bb7abf33f4", "filename": "gcc/common.opt", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "c4c6230073ab77991a9651697fc4cdf52c51862d", "filename": "gcc/common/common-target.def", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fcommon%2Fcommon-target.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fcommon%2Fcommon-target.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fcommon-target.def?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "7499be27b68ca64ee98843314fe89972dd41443c", "filename": "gcc/common/common-targhooks.cc", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fcommon%2Fcommon-targhooks.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fcommon%2Fcommon-targhooks.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fcommon-targhooks.cc?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "1f03495010377cf4e9eb2acf38e7d1abe389d323", "filename": "gcc/common/common-targhooks.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fcommon%2Fcommon-targhooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fcommon%2Fcommon-targhooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fcommon-targhooks.h?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "6d0b2be52edb670733cfd257ba3fcacaf8fd9e9a", "filename": "gcc/common/config/cr16/cr16-common.cc", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6da3cab7b0acf5dc363c85069bef716923ddf90c/gcc%2Fcommon%2Fconfig%2Fcr16%2Fcr16-common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6da3cab7b0acf5dc363c85069bef716923ddf90c/gcc%2Fcommon%2Fconfig%2Fcr16%2Fcr16-common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Fcr16%2Fcr16-common.cc?ref=6da3cab7b0acf5dc363c85069bef716923ddf90c"}, {"sha": "c39ed2e26962c907f696aa46c2a057e21ad30b57", "filename": "gcc/common/config/riscv/riscv-common.cc", "status": "modified", "additions": 382, "deletions": 1, "changes": 383, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fcommon%2Fconfig%2Friscv%2Friscv-common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fcommon%2Fconfig%2Friscv%2Friscv-common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Friscv%2Friscv-common.cc?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "be3e6f201429029721eae75367e5ce80b29c662f", "filename": "gcc/common/config/s390/s390-common.cc", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fcommon%2Fconfig%2Fs390%2Fs390-common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fcommon%2Fconfig%2Fs390%2Fs390-common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Fs390%2Fs390-common.cc?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "eb3bfbf92e839778a1c41521eb0861139bf87dc1", "filename": "gcc/config.build", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig.build", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig.build", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.build?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "27ffce3fb500ce421ac9552d2685800272973f62", "filename": "gcc/config.gcc", "status": "modified", "additions": 126, "deletions": 215, "changes": 341, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "992638df3850f82931a66f916b8e841e8d30fda6", "filename": "gcc/config.host", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.host?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "6ac17be189eb36305c70d3c9f69636391c30c66c", "filename": "gcc/config.in", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.in?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "5eef5aaa40206b953ee14db24bed50fcef391bb6", "filename": "gcc/config/aarch64/aarch64-builtins.cc", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Faarch64%2Faarch64-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Faarch64%2Faarch64-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-builtins.cc?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "52ed4a218a87465c27b323a55f34187a5cf90416", "filename": "gcc/config/aarch64/aarch64-c.cc", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Faarch64%2Faarch64-c.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Faarch64%2Faarch64-c.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-c.cc?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "0402bfb748faff3a6b104521d09c4cb877575036", "filename": "gcc/config/aarch64/aarch64-cores.def", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Faarch64%2Faarch64-cores.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Faarch64%2Faarch64-cores.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-cores.def?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "e0e0401631e5f100396347e5da9cbdc0fd0e7a59", "filename": "gcc/config/aarch64/aarch64-d.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Faarch64%2Faarch64-d.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Faarch64%2Faarch64-d.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-d.cc?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "c605a68ef9fa3745285d5d674e9cf464ebfeee5a", "filename": "gcc/config/aarch64/aarch64-d.h", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Faarch64%2Faarch64-d.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Faarch64%2Faarch64-d.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-d.h?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "8e05b1f1cbe83601928a7be7e4c644d30e3c869e", "filename": "gcc/config/aarch64/aarch64-elf.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Faarch64%2Faarch64-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Faarch64%2Faarch64-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-elf.h?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "f8446e2120853954c360b9ff6085ea6a22f8b26c", "filename": "gcc/config/aarch64/aarch64-ldpstp.md", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Faarch64%2Faarch64-ldpstp.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Faarch64%2Faarch64-ldpstp.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-ldpstp.md?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "5ecdb8af8638b31345373f5679622d81a90ee52f", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "dc80f826100ea4feb4150f117eaf53a4f2afbbff", "filename": "gcc/config/aarch64/aarch64-simd.md", "status": "modified", "additions": 133, "deletions": 84, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "12d9beee4da3c9e7cca8ba3f750a7236cf300cfc", "filename": "gcc/config/aarch64/aarch64-sve-builtins.cc", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins.cc?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "84e9bbf44f6222b3e5bcf4cbf8fab7ebf17015e1", "filename": "gcc/config/aarch64/aarch64-tune.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Faarch64%2Faarch64-tune.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Faarch64%2Faarch64-tune.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-tune.md?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "b4971bd1d1476e681efe5897a301e7d18ee0ab84", "filename": "gcc/config/aarch64/aarch64.cc", "status": "modified", "additions": 99, "deletions": 58, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Faarch64%2Faarch64.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Faarch64%2Faarch64.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.cc?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "6f6bb70fde955f6664e7cd48236ef79d0ee330d5", "filename": "gcc/config/aarch64/aarch64.h", "status": "modified", "additions": 34, "deletions": 24, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Faarch64%2Faarch64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Faarch64%2Faarch64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.h?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "3f8e40a48b5e512600caefbf73508e4da213df7a", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 29, "deletions": 20, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "9354dbec866f3a75212fec181d86ed1f9183eb42", "filename": "gcc/config/aarch64/iterators.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Faarch64%2Fiterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Faarch64%2Fiterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fiterators.md?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "66c17149d4ddbaf64483d07d61baea3900cbd1dd", "filename": "gcc/config/alpha/alpha.cc", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Falpha%2Falpha.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Falpha%2Falpha.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.cc?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "1f6d2caa093674b38a663bf59c8fc87a399ad1ce", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "c9cd42e69f81597be3e01dbbfc4f2cfa3a99ce0e", "filename": "gcc/config/alpha/elf.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Falpha%2Felf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Falpha%2Felf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Felf.h?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "db4b56b23ff9fe8c4651fdc9b54418ada0f12cc9", "filename": "gcc/config/arc/arc.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Farc%2Farc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Farc%2Farc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.cc?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "0280b53ad924a98271ed22eb1c6d781c0e69444e", "filename": "gcc/config/arc/arc.h", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Farc%2Farc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Farc%2Farc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.h?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "cfb8db52c59fb5178178a2bb419f0ffc51077ed3", "filename": "gcc/config/arm/aout.h", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Farm%2Faout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Farm%2Faout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Faout.h?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "5c89f1b1079e9a70b179f0edd2bb568f21504f30", "filename": "gcc/config/arm/arm-d.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Farm%2Farm-d.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Farm%2Farm-d.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-d.cc?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "479a89bb120a962cf31f57899f3f1e3cca9c0e2a", "filename": "gcc/config/arm/arm-d.h", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Farm%2Farm-d.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Farm%2Farm-d.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-d.h?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "550272facd12e60a49bf8a3b20f811cc13765b3a", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "1a375367ac72a51e9811ba89777a207da8ab6f2d", "filename": "gcc/config/arm/arm.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Farm%2Farm.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Farm%2Farm.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.cc?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "984ab789285dd0bb8d648fda89053b24ada93698", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "714178609f725a89598b0df1a0f748c60efd9ddc", "filename": "gcc/config/arm/mve.md", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Farm%2Fmve.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Farm%2Fmve.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fmve.md?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "ef1bba28077cd9e82e6d88aa847de8c0ce484356", "filename": "gcc/config/arm/netbsd-elf.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Farm%2Fnetbsd-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Farm%2Fnetbsd-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fnetbsd-elf.h?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "4e7753038a872f6ef4567558a4f62d3eed915d3f", "filename": "gcc/config/bfin/bfin.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Fbfin%2Fbfin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Fbfin%2Fbfin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.h?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "51055651707499198d639ccb1db8c322ce6d16e3", "filename": "gcc/config/bpf/bpf.cc", "status": "modified", "additions": 29, "deletions": 11, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Fbpf%2Fbpf.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Fbpf%2Fbpf.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbpf%2Fbpf.cc?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "57903477a4ae7df32bd3c6a9feeae479660e30af", "filename": "gcc/config/bpf/bpf.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Fbpf%2Fbpf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Fbpf%2Fbpf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbpf%2Fbpf.h?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "8897a045ea17d8eb42ef233651617486b6b6f9f7", "filename": "gcc/config/bpf/coreout.cc", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Fbpf%2Fcoreout.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Fbpf%2Fcoreout.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbpf%2Fcoreout.cc?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "4baf30238a47d818f819e812bab61e0ffad7a58b", "filename": "gcc/config/c6x/c6x.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Fc6x%2Fc6x.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Fc6x%2Fc6x.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc6x%2Fc6x.cc?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "88fc73d95c4c1fc21cfdcd15c5828f6f9c8d669c", "filename": "gcc/config/c6x/c6x.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Fc6x%2Fc6x.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Fc6x%2Fc6x.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc6x%2Fc6x.h?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "708fe21a7ab101ac99c3021235afc1aba257e8e1", "filename": "gcc/config/cr16/constraints.md", "status": "removed", "additions": 0, "deletions": 81, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6da3cab7b0acf5dc363c85069bef716923ddf90c/gcc%2Fconfig%2Fcr16%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6da3cab7b0acf5dc363c85069bef716923ddf90c/gcc%2Fconfig%2Fcr16%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcr16%2Fconstraints.md?ref=6da3cab7b0acf5dc363c85069bef716923ddf90c"}, {"sha": "300bb31ad84af025279a38d25d00dfee39eb65ee", "filename": "gcc/config/cr16/cr16-protos.h", "status": "removed", "additions": 0, "deletions": 98, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6da3cab7b0acf5dc363c85069bef716923ddf90c/gcc%2Fconfig%2Fcr16%2Fcr16-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6da3cab7b0acf5dc363c85069bef716923ddf90c/gcc%2Fconfig%2Fcr16%2Fcr16-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcr16%2Fcr16-protos.h?ref=6da3cab7b0acf5dc363c85069bef716923ddf90c"}, {"sha": "55dad9994a53b4d81aacbe449c65f69e2a3507c9", "filename": "gcc/config/cr16/cr16.cc", "status": "removed", "additions": 0, "deletions": 2201, "changes": 2201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6da3cab7b0acf5dc363c85069bef716923ddf90c/gcc%2Fconfig%2Fcr16%2Fcr16.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6da3cab7b0acf5dc363c85069bef716923ddf90c/gcc%2Fconfig%2Fcr16%2Fcr16.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcr16%2Fcr16.cc?ref=6da3cab7b0acf5dc363c85069bef716923ddf90c"}, {"sha": "100bb4f123c40c2e04e54a29f005ec709ddc3603", "filename": "gcc/config/cr16/cr16.h", "status": "removed", "additions": 0, "deletions": 556, "changes": 556, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6da3cab7b0acf5dc363c85069bef716923ddf90c/gcc%2Fconfig%2Fcr16%2Fcr16.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6da3cab7b0acf5dc363c85069bef716923ddf90c/gcc%2Fconfig%2Fcr16%2Fcr16.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcr16%2Fcr16.h?ref=6da3cab7b0acf5dc363c85069bef716923ddf90c"}, {"sha": "7ec746802dc7b87642b644c082354d049496b80e", "filename": "gcc/config/cr16/cr16.md", "status": "removed", "additions": 0, "deletions": 1084, "changes": 1084, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6da3cab7b0acf5dc363c85069bef716923ddf90c/gcc%2Fconfig%2Fcr16%2Fcr16.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6da3cab7b0acf5dc363c85069bef716923ddf90c/gcc%2Fconfig%2Fcr16%2Fcr16.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcr16%2Fcr16.md?ref=6da3cab7b0acf5dc363c85069bef716923ddf90c"}, {"sha": "8d7da69509f817e1e2f90752980099230efc6489", "filename": "gcc/config/cr16/cr16.opt", "status": "removed", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6da3cab7b0acf5dc363c85069bef716923ddf90c/gcc%2Fconfig%2Fcr16%2Fcr16.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6da3cab7b0acf5dc363c85069bef716923ddf90c/gcc%2Fconfig%2Fcr16%2Fcr16.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcr16%2Fcr16.opt?ref=6da3cab7b0acf5dc363c85069bef716923ddf90c"}, {"sha": "d8789f5a50e24a24761f5de3bf651e5d4dcf0c58", "filename": "gcc/config/cr16/predicates.md", "status": "removed", "additions": 0, "deletions": 225, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6da3cab7b0acf5dc363c85069bef716923ddf90c/gcc%2Fconfig%2Fcr16%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6da3cab7b0acf5dc363c85069bef716923ddf90c/gcc%2Fconfig%2Fcr16%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcr16%2Fpredicates.md?ref=6da3cab7b0acf5dc363c85069bef716923ddf90c"}, {"sha": "928730f2dfdee81ac1b3aaf8699166efc03c5174", "filename": "gcc/config/cr16/t-cr16", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6da3cab7b0acf5dc363c85069bef716923ddf90c/gcc%2Fconfig%2Fcr16%2Ft-cr16", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6da3cab7b0acf5dc363c85069bef716923ddf90c/gcc%2Fconfig%2Fcr16%2Ft-cr16", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcr16%2Ft-cr16?ref=6da3cab7b0acf5dc363c85069bef716923ddf90c"}, {"sha": "16caa292b404aa472582ac58ebc5f30b3452ed74", "filename": "gcc/config/cris/cris.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Fcris%2Fcris.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Fcris%2Fcris.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.h?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}, {"sha": "4dc74d8924f6a86b318c626e228e3590a753b8cc", "filename": "gcc/config/csky/csky.cc", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Fcsky%2Fcsky.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13de60fb8e26a874dd58089286a0ea99a90972c8/gcc%2Fconfig%2Fcsky%2Fcsky.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcsky%2Fcsky.cc?ref=13de60fb8e26a874dd58089286a0ea99a90972c8"}]}