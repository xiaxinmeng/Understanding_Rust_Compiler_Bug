{"sha": "7d3b27ff12610fde9d6c4b56abc70c6ee9b6b3db", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2QzYjI3ZmYxMjYxMGZkZTlkNmM0YjU2YWJjNzBjNmVlOWI2YjNkYg==", "commit": {"author": {"name": "Wilco Dijkstra", "email": "wdijkstr@arm.com", "date": "2019-10-16T14:24:41Z"}, "committer": {"name": "Wilco Dijkstra", "email": "wilco@gcc.gnu.org", "date": "2019-10-16T14:24:41Z"}, "message": "[AArch64] Fix symbol offset limit\n\nIn aarch64_classify_symbol symbols are allowed large offsets on relocations. \nThis means the offset can use all of the +/-4GB offset, leaving no offset\navailable for the symbol itself.  This results in relocation overflow and\nlink-time errors for simple expressions like &global_array + 0xffffff00.\n\nTo avoid this, unless the offset_within_block_p is true, limit the offset\nto +/-1MB so that the symbol needs to be within a 3.9GB offset from its\nreferences.  For the tiny code model use a 64KB offset, allowing most of\nthe 1MB range for code/data between the symbol and its references.\n\n    gcc/\n\t* config/aarch64/aarch64.c (aarch64_classify_symbol):\n\tApply reasonable limit to symbol offsets.\n\n    testsuite/\n\t* gcc.target/aarch64/symbol-range.c: Improve testcase.\n\t* gcc.target/aarch64/symbol-range-tiny.c: Likewise.\n\nFrom-SVN: r277068", "tree": {"sha": "2c2ebc761a61533c8bc20a4cc3ae61decee73ab5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2c2ebc761a61533c8bc20a4cc3ae61decee73ab5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7d3b27ff12610fde9d6c4b56abc70c6ee9b6b3db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d3b27ff12610fde9d6c4b56abc70c6ee9b6b3db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d3b27ff12610fde9d6c4b56abc70c6ee9b6b3db", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d3b27ff12610fde9d6c4b56abc70c6ee9b6b3db/comments", "author": null, "committer": null, "parents": [{"sha": "aab8c2fd6542a52663243eec160b80bdd61516d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aab8c2fd6542a52663243eec160b80bdd61516d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aab8c2fd6542a52663243eec160b80bdd61516d5"}], "stats": {"total": 59, "additions": 37, "deletions": 22}, "files": [{"sha": "70e51c5e21c8ad8218c3d45d5eaff9756f4a67ec", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d3b27ff12610fde9d6c4b56abc70c6ee9b6b3db/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d3b27ff12610fde9d6c4b56abc70c6ee9b6b3db/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7d3b27ff12610fde9d6c4b56abc70c6ee9b6b3db", "patch": "@@ -1,3 +1,8 @@\n+2019-10-16  Wilco Dijkstra  <wdijkstr@arm.com>\n+\n+\t* config/aarch64/aarch64.c (aarch64_classify_symbol):\n+\tApply reasonable limit to symbol offsets.\n+\n 2019-10-16  Richard Biener  <rguenther@suse.de>\n \n \t* tree-vect-loop.c (vect_valid_reduction_input_p): Remove."}, {"sha": "af74354c55c597e4a7d6c5a323850ec4b067defe", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d3b27ff12610fde9d6c4b56abc70c6ee9b6b3db/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d3b27ff12610fde9d6c4b56abc70c6ee9b6b3db/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=7d3b27ff12610fde9d6c4b56abc70c6ee9b6b3db", "patch": "@@ -14122,26 +14122,31 @@ aarch64_classify_symbol (rtx x, HOST_WIDE_INT offset)\n \t     the offset does not cause overflow of the final address.  But\n \t     we have no way of knowing the address of symbol at compile time\n \t     so we can't accurately say if the distance between the PC and\n-\t     symbol + offset is outside the addressible range of +/-1M in the\n-\t     TINY code model.  So we rely on images not being greater than\n-\t     1M and cap the offset at 1M and anything beyond 1M will have to\n-\t     be loaded using an alternative mechanism.  Furthermore if the\n-\t     symbol is a weak reference to something that isn't known to\n-\t     resolve to a symbol in this module, then force to memory.  */\n-\t  if ((SYMBOL_REF_WEAK (x)\n-\t       && !aarch64_symbol_binds_local_p (x))\n-\t      || !IN_RANGE (offset, -1048575, 1048575))\n+\t     symbol + offset is outside the addressible range of +/-1MB in the\n+\t     TINY code model.  So we limit the maximum offset to +/-64KB and\n+\t     assume the offset to the symbol is not larger than +/-(1MB - 64KB).\n+\t     If offset_within_block_p is true we allow larger offsets.\n+\t     Furthermore force to memory if the symbol is a weak reference to\n+\t     something that doesn't resolve to a symbol in this module.  */\n+\n+\t  if (SYMBOL_REF_WEAK (x) && !aarch64_symbol_binds_local_p (x))\n \t    return SYMBOL_FORCE_TO_MEM;\n+\t  if (!(IN_RANGE (offset, -0x10000, 0x10000)\n+\t\t|| offset_within_block_p (x, offset)))\n+\t    return SYMBOL_FORCE_TO_MEM;\n+\n \t  return SYMBOL_TINY_ABSOLUTE;\n \n \tcase AARCH64_CMODEL_SMALL:\n \t  /* Same reasoning as the tiny code model, but the offset cap here is\n-\t     4G.  */\n-\t  if ((SYMBOL_REF_WEAK (x)\n-\t       && !aarch64_symbol_binds_local_p (x))\n-\t      || !IN_RANGE (offset, HOST_WIDE_INT_C (-4294967263),\n-\t\t\t    HOST_WIDE_INT_C (4294967264)))\n+\t     1MB, allowing +/-3.9GB for the offset to the symbol.  */\n+\n+\t  if (SYMBOL_REF_WEAK (x) && !aarch64_symbol_binds_local_p (x))\n \t    return SYMBOL_FORCE_TO_MEM;\n+\t  if (!(IN_RANGE (offset, -0x100000, 0x100000)\n+\t\t|| offset_within_block_p (x, offset)))\n+\t    return SYMBOL_FORCE_TO_MEM;\n+\n \t  return SYMBOL_SMALL_ABSOLUTE;\n \n \tcase AARCH64_CMODEL_TINY_PIC:"}, {"sha": "2c1d794c928b44f332ce10a103208bcbb7a237f1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d3b27ff12610fde9d6c4b56abc70c6ee9b6b3db/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d3b27ff12610fde9d6c4b56abc70c6ee9b6b3db/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7d3b27ff12610fde9d6c4b56abc70c6ee9b6b3db", "patch": "@@ -1,3 +1,8 @@\n+2019-10-16  Wilco Dijkstra  <wdijkstr@arm.com>\n+\n+\t* gcc.target/aarch64/symbol-range.c: Improve testcase.\n+\t* gcc.target/aarch64/symbol-range-tiny.c: Likewise.\n+\n 2019-10-16  Richard Biener  <rguenther@suse.de>\n \n \t* gcc.dg/vect/vect-cond-reduc-3.c: New testcase."}, {"sha": "fc6a4f3ec780d9fa86de1c8e1a42a55992ee8b2d", "filename": "gcc/testsuite/gcc.target/aarch64/symbol-range-tiny.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d3b27ff12610fde9d6c4b56abc70c6ee9b6b3db/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsymbol-range-tiny.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d3b27ff12610fde9d6c4b56abc70c6ee9b6b3db/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsymbol-range-tiny.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsymbol-range-tiny.c?ref=7d3b27ff12610fde9d6c4b56abc70c6ee9b6b3db", "patch": "@@ -1,12 +1,12 @@\n-/* { dg-do compile } */\n+/* { dg-do link } */\n /* { dg-options \"-O3 -save-temps -mcmodel=tiny\" } */\n \n-int fixed_regs[0x00200000];\n+char fixed_regs[0x00080000];\n \n int\n-foo()\n+main ()\n {\n-  return fixed_regs[0x00080000];\n+  return fixed_regs[0x000ff000];\n }\n \n /* { dg-final { scan-assembler-not \"adr\\tx\\[0-9\\]+, fixed_regs\\\\\\+\" } } */"}, {"sha": "d8e82fa1b2829fd300b6ccf7f80241e5573e7e17", "filename": "gcc/testsuite/gcc.target/aarch64/symbol-range.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d3b27ff12610fde9d6c4b56abc70c6ee9b6b3db/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsymbol-range.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d3b27ff12610fde9d6c4b56abc70c6ee9b6b3db/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsymbol-range.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsymbol-range.c?ref=7d3b27ff12610fde9d6c4b56abc70c6ee9b6b3db", "patch": "@@ -1,12 +1,12 @@\n-/* { dg-do compile } */\n+/* { dg-do link } */\n /* { dg-options \"-O3 -save-temps -mcmodel=small\" } */\n \n-int fixed_regs[0x200000000ULL];\n+char fixed_regs[0x80000000];\n \n int\n-foo()\n+main ()\n {\n-  return fixed_regs[0x100000000ULL];\n+  return fixed_regs[0xfffff000];\n }\n \n /* { dg-final { scan-assembler-not \"adrp\\tx\\[0-9\\]+, fixed_regs\\\\\\+\" } } */"}]}