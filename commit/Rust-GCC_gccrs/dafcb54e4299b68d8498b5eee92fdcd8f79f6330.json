{"sha": "dafcb54e4299b68d8498b5eee92fdcd8f79f6330", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGFmY2I1NGU0Mjk5YjY4ZDg0OThiNWVlZTkyZmRjZDhmNzlmNjMzMA==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@redhat.com", "date": "2009-12-02T10:59:04Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2009-12-02T10:59:04Z"}, "message": "rx.c (rx_conditional_register_usage): Do not warn if no fixed registers are available for interrupt handlers.\n\n        * config/rx/rx.c (rx_conditional_register_usage): Do not warn if\n        no fixed registers are available for interrupt handlers.  Do not\n        fix normal registers.\n        (MUST_SAVE_ACC_REGISTER): New macro.\n        (rx_get_stack_layout): Create a stack frame for fast interrupt\n        handlers, if necessary.  Push extra registers if needed in order\n        to save the accumulator.\n        (rx_expand_prologue): Create a stack frame for fast interrupt\n        handlers, if necessary.\n        (rx_expand_builtin_mvfc): Handle the case where there is no\n        target.\n\nFrom-SVN: r154903", "tree": {"sha": "031d1485543d358195439ebebb1a4d656c2c5108", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/031d1485543d358195439ebebb1a4d656c2c5108"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dafcb54e4299b68d8498b5eee92fdcd8f79f6330", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dafcb54e4299b68d8498b5eee92fdcd8f79f6330", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dafcb54e4299b68d8498b5eee92fdcd8f79f6330", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dafcb54e4299b68d8498b5eee92fdcd8f79f6330/comments", "author": {"login": "nickclifton", "id": 31441682, "node_id": "MDQ6VXNlcjMxNDQxNjgy", "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nickclifton", "html_url": "https://github.com/nickclifton", "followers_url": "https://api.github.com/users/nickclifton/followers", "following_url": "https://api.github.com/users/nickclifton/following{/other_user}", "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}", "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions", "organizations_url": "https://api.github.com/users/nickclifton/orgs", "repos_url": "https://api.github.com/users/nickclifton/repos", "events_url": "https://api.github.com/users/nickclifton/events{/privacy}", "received_events_url": "https://api.github.com/users/nickclifton/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "57cdf653e3cb6f4f006afe01793de0b3ed10312d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57cdf653e3cb6f4f006afe01793de0b3ed10312d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57cdf653e3cb6f4f006afe01793de0b3ed10312d"}], "stats": {"total": 101, "additions": 57, "deletions": 44}, "files": [{"sha": "2459495483d12cee4418f9c26e1855595fde7664", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dafcb54e4299b68d8498b5eee92fdcd8f79f6330/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dafcb54e4299b68d8498b5eee92fdcd8f79f6330/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dafcb54e4299b68d8498b5eee92fdcd8f79f6330", "patch": "@@ -1,3 +1,17 @@\n+2009-12-02  Nick Clifton  <nickc@redhat.com>\n+\n+\t* config/rx/rx.c (rx_conditional_register_usage): Do not warn if\n+\tno fixed registers are available for interrupt handlers.  Do not\n+\tfix normal registers.\n+\t(MUST_SAVE_ACC_REGISTER): New macro.\n+\t(rx_get_stack_layout): Create a stack frame for fast interrupt\n+\thandlers, if necessary.  Push extra registers if needed in order\n+\tto save the accumulator.\n+\t(rx_expand_prologue): Create a stack frame for fast interrupt\n+\thandlers, if necessary.\n+\t(rx_expand_builtin_mvfc): Handle the case where there is no\n+\ttarget.\n+\n 2009-12-01  Sebastian Pop  <sebastian.pop@amd.com>\n \n \t* config/i386/abmintrin.h (__lzcnt16): New."}, {"sha": "3fb8b320e525f71ff9b6510343c340890661cf28", "filename": "gcc/config/rx/rx.c", "status": "modified", "additions": 43, "deletions": 44, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dafcb54e4299b68d8498b5eee92fdcd8f79f6330/gcc%2Fconfig%2Frx%2Frx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dafcb54e4299b68d8498b5eee92fdcd8f79f6330/gcc%2Fconfig%2Frx%2Frx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx.c?ref=dafcb54e4299b68d8498b5eee92fdcd8f79f6330", "patch": "@@ -887,46 +887,25 @@ rx_conditional_register_usage (void)\n \n       if (use_fixed_regs)\n \t{\n-\t  unsigned int switched = 0;\n \t  unsigned int r;\n \n-\t  /* This is for fast interrupt handlers.  Any register in\n-\t     the range r10 to r13 (inclusive) that is currently\n-\t     marked as fixed is now a viable, call-saved register.\n-\t     All other registers are fixed.  */\n \t  memcpy (saved_fixed_regs, fixed_regs, sizeof fixed_regs);\n \t  memcpy (saved_call_used_regs, call_used_regs, sizeof call_used_regs);\n-\t  \n-\t  for (r = 1; r < 10; r++)\n-\t    fixed_regs[r] = call_used_regs[r] = 1;\n-\t  \n+\n+\t  /* This is for fast interrupt handlers.  Any register in\n+\t     the range r10 to r13 (inclusive) that is currently\n+\t     marked as fixed is now a viable, call-used register.  */\t  \n \t  for (r = 10; r <= 13; r++)\n \t    if (fixed_regs[r])\n \t      {\n \t\tfixed_regs[r] = 0;\n \t\tcall_used_regs[r] = 1;\n-\t\t++ switched;\n-\t      }\n-\t    else\n-\t      {\n-\t\tfixed_regs[r] = 1;\n-\t\tcall_used_regs[r] = 1;\n \t      }\n \n-\t  fixed_regs[14] = call_used_regs[14] = 1;\n-\t  fixed_regs[15] = call_used_regs[15] = 1;\n-\n-\t  if (switched == 0)\n-\t    {\n-\t      static bool warned = false;\n-\n-\t      if (! warned)\n-\t\t{\n-\t\t  warning (0, \"no fixed registers available \"\n-\t\t\t   \"for use by fast interrupt handler\");\n-\t\t  warned = true;\n-\t\t}\n-\t    }\n+\t  /* Mark r7 as fixed.  This is just a hack to avoid\n+\t     altering the reg_alloc_order array so that the newly\n+\t     freed r10-r13 registers are the preferred registers.  */\n+\t  fixed_regs[7] = call_used_regs[7] = 1;\n \t}\n       else\n \t{\n@@ -1017,6 +996,11 @@ bit_count (unsigned int x)\n   return (x + (x >> 16)) & 0x3f;\n }\n \n+#define MUST_SAVE_ACC_REGISTER\t\t\t\\\n+  (TARGET_SAVE_ACC_REGISTER\t\t\t\\\n+   && (is_interrupt_func (NULL_TREE)\t\t\\\n+       || is_fast_interrupt_func (NULL_TREE)))\n+\n /* Returns either the lowest numbered and highest numbered registers that\n    occupy the call-saved area of the stack frame, if the registers are\n    stored as a contiguous block, or else a bitmask of the individual\n@@ -1040,15 +1024,10 @@ rx_get_stack_layout (unsigned int * lowest,\n   unsigned int pushed_mask;\n   unsigned int unneeded_pushes;\n \n-  if (is_naked_func (NULL_TREE)\n-      || is_fast_interrupt_func (NULL_TREE))\n+  if (is_naked_func (NULL_TREE))\n     {\n       /* Naked functions do not create their own stack frame.\n-\t Instead the programmer must do that for us.\n-\n-\t Fast interrupt handlers use fixed registers that have\n-\t been epsecially released to the function, so they do\n-\t not need or want a stack frame.  */\n+\t Instead the programmer must do that for us.  */\n       * lowest = 0;\n       * highest = 0;\n       * register_mask = 0;\n@@ -1063,7 +1042,14 @@ rx_get_stack_layout (unsigned int * lowest,\n \t  && (! call_used_regs[reg]\n \t      /* Even call clobbered registered must\n \t\t be pushed inside interrupt handlers.  */\n-\t      || is_interrupt_func (NULL_TREE)))\n+\t      || is_interrupt_func (NULL_TREE)\n+\t      /* Likewise for fast interrupt handlers, except registers r10 -\n+\t\t r13.  These are normally call-saved, but may have been set\n+\t\t to call-used by rx_conditional_register_usage.  If so then\n+\t\t they can be used in the fast interrupt handler without\n+\t\t saving them on the stack.  */\n+\t      || (is_fast_interrupt_func (NULL_TREE)\n+\t\t  && ! IN_RANGE (reg, 10, 13))))\n \t{\n \t  if (low == 0)\n \t    low = reg;\n@@ -1078,6 +1064,18 @@ rx_get_stack_layout (unsigned int * lowest,\n \tfixed_reg = reg;\n     }\n \n+  /* If we have to save the accumulator register, make sure\n+     that at least two registers are pushed into the frame.  */\n+  if (MUST_SAVE_ACC_REGISTER\n+      && bit_count (save_mask) < 2)\n+    {\n+      save_mask |= (1 << 13) | (1 << 14);\n+      if (low == 0)\n+\tlow = 13;\n+      if (high == 0)\n+\thigh = 14;\n+    }\n+\n   /* Decide if it would be faster fill in the call-saved area of the stack\n      frame using multiple PUSH instructions instead of a single PUSHM\n      instruction.\n@@ -1207,9 +1205,7 @@ rx_expand_prologue (void)\n   rtx insn;\n \n   /* Naked functions use their own, programmer provided prologues.  */\n-  if (is_naked_func (NULL_TREE)\n-      /* Fast interrupt functions never use the stack.  */\n-      || is_fast_interrupt_func (NULL_TREE))\n+  if (is_naked_func (NULL_TREE))\n     return;\n \n   rx_get_stack_layout (& low, & high, & mask, & frame_size, & stack_size);\n@@ -1236,13 +1232,13 @@ rx_expand_prologue (void)\n       mark_frame_related (insn);\n     }\n \n-  if (is_interrupt_func (NULL_TREE) && TARGET_SAVE_ACC_REGISTER)\n+  if (MUST_SAVE_ACC_REGISTER)\n     {\n       unsigned int acc_high, acc_low;\n \n       /* Interrupt handlers have to preserve the accumulator\n \t register if so requested by the user.  Use the first\n-         two pushed register as intermediaries.  */\n+         two pushed registers as intermediaries.  */\n       if (mask)\n \t{\n \t  acc_low = acc_high = 0;\n@@ -1510,7 +1506,7 @@ rx_expand_epilogue (bool is_sibcall)\n \temit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n \t\t\t       GEN_INT (total_size)));\n \n-      if (is_interrupt_func (NULL_TREE) && TARGET_SAVE_ACC_REGISTER)\n+      if (MUST_SAVE_ACC_REGISTER)\n \t{\n \t  unsigned int acc_low, acc_high;\n \n@@ -1901,6 +1897,9 @@ rx_expand_builtin_mvfc (tree t_arg, rtx target)\n   if (! CONST_INT_P (arg))\n     return NULL_RTX;\n \n+  if (target == NULL_RTX)\n+    return NULL_RTX;\n+\n   if (! REG_P (target))\n     target = force_reg (SImode, target);\n \n@@ -2135,7 +2134,7 @@ rx_func_attr_inlinable (const_tree decl)\n    a function_decl or NULL if this is an indirect call, using EXP  */\n \n static bool\n-rx_function_ok_for_sibcall (tree decl, tree exp)\n+rx_function_ok_for_sibcall (tree decl, tree exp ATTRIBUTE_UNUSED)\n {\n   /* Do not allow indirect tailcalls.  The\n      sibcall patterns do not support them.  */"}]}