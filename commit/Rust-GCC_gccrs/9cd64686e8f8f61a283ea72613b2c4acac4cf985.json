{"sha": "9cd64686e8f8f61a283ea72613b2c4acac4cf985", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWNkNjQ2ODZlOGY4ZjYxYTI4M2VhNzI2MTNiMmM0YWNhYzRjZjk4NQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-09-06T02:43:09Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-09-06T02:43:09Z"}, "message": "Get ready for garbage collection.\n\n\t* Makefile.in (CXX_TREE_H): Add varray.h\n\t(lex.o): Depend on ggc.h.\n\t(decl.o): Likewise.\n\t(decl2.o): Likewise.\n\t(method.o): Likewise.\n\t(search.o): Likewise.\n\t(pt.o): Likewise.\n\t(repo.o): Likewise.\n\t* class.c: Include ggc.h.\n\t(current_class_name): Remove.\n\t(current_class_type): Likewise.\n\t(current_access_specifier): Likewise.\n\t(previous_class_type): Likewise.\n\t(previous_class_values): Likewise.\n\t(class_cache_firstobj): Likewise.\n\t(current_lang_base): Likewise.\n\t(current_lang_stack): Likewise.\n\t(current_lang_stacksize): Likewise.\n\t(lang_name_c): Likewise.\n\t(lang_name_cplusplus): Likewise.\n\t(lang_name_java): Likewise.\n\t(current_lang_name): Likewise.\n\t(base_layout_decl): Likewise.\n\t(access_default_node): Likewise.\n\t(access_public_node): Likewise.\n\t(access_protected_node): Likewise.\n\t(access_private_node): Likewise.\n\t(access_default_virtual_node): Likewise.\n\t(access_public_virtual_node): Likewise.\n\t(access_protected_virtual_node): Likewise.\n\t(access_private_virtual_node): Likewise.\n\t(signed_zero_node): Likewise.\n\t(init_class_processing): Don't build base_layout_decl.\n\t(push_lang_context): Adjust now that current_lang_base is a varray.\n\t(pop_lang_context): Likewise.\n\t* cp-tree.h: Include varray.h.\n\t(cp_global_trees): Add access_default, access_public,\n\taccess_protected, access_private, access_default_virtual,\n\taccess_public_virtual, access_protected_virtual,\n\taccess_private_virtual, ctor_identifier, delta2_identifier,\n\tdelta_identifier, dtor_identifier, in_charge_identifier,\n\tindex_identifier, nelts_identifier, this_identifier,\n\tpfn_identifier, pfn_or_delta2_identifier, vptr_identifier,\n\tlang_name_c, lang_name_cplusplus, lang_name_java,\n\tempty_except_spec, null, jclass, minus_one, terminate.\n\t(saved_scope): Move here from decl.c.  Define globals in terms of\n\tsaved_scope: current_namespace, current_class_name,\n\tcurrent_class_type, current_access_specifier, current_lang_stack,\n\tcurrent_lang_base, current_lang_name, current_function_parms,\n\tcurrent_template_parms, processing_template_decl,\n\tprocessing_specialization, processing_explicit_instantiation,\n\tprevious_class_type, previous_class_values, class_cache_firstobj.\n\t(scope_chain): New variable.\n\t(init_pt): New function.\n\t* decl.c (current_namespace): Remove.\n\t(this_identifier, in_charge_identifier, ctor_identifier): Likewise.\n\t(dtor_identifier, pfn_identifier, index_identifier): Likewise.\n\t(delta_identifier, delta2_identifier): Likewise.\n\t(pfn_or_delta2_identifier, tag_identifier): Likewise\n\t(vt_off_identifier, empty_except_spec, null_node): Likewise.\n\t(current_function_parms, current_lang_base): Remove.\n\t(current_lang_stack, previous_class_values): Remove.\n\t(class_binding_level): Macroize.\n\t(saved_scope): Remove.\n\t(current_saved_scope): Rename to scope_chain.\n\t(mark_saved_scope): Adjust for new scope structure.\n\t(maybe_push_to_top_level): Likewise.\n\t(pop_from_top_level): Likewise.\n\t(duplicate_decls): Adjust now that current_lang_base is a varray.\n\t(build_typename_type): Call ggc_add_tree_hash_table_root.\n\t(init_decl_processing): Call init_pt.  Call push_to_top_level to\n\tset up globals.  Add GC roots.\n\t(xref_basetypes): Adjust now that current_lang_base is a varray.\n\t* decl.h (this_identifier): Remove.\n\t(in_charge_identifier): Likewise.\n\t* decl2.c: Don't include varray.h.\n\t(current_namespace): Remove.\n\t(init_decl2): Add GC roots.\n\t* except.c (Terminate): Remove.\n\t(init_exception_processing): Use terminate_node instead.\n\t(build_terminate_handler): Likewise.\n\t* init.c (nc_nelts_field_id): Remove.\n\t(minus_one): Likewise.\n\t(init_init_processing): Use minus_one_node and nelts_identifier\n\tinstead.  Add GC roots.\n\t(jclass_node): Remove.\n\t(build_new_1): Use nelts_identifier.\n\t(build_vec_init): Likewise.\n\t(build_vec_delete): Likewise.\n\t* lex.c: Include ggc.h.\n\t(defarg_fn): Move declaration early.\n\t(defarg_parms): Likewise.\n\t(init_parse): Add GC roots.\n\t(handle_cp_pragma): Remove redundant declaration of\n\tpending_vtables.\n\t* method.c: Include ggc.h.\n\t(btypelist): Make it a varray.  All uses changed.\n\t(ktypelist): Likewise.\n\t(init_method): Add GC roots.\n\t* pt.c: Don't include varray.h.  Include ggc.h.\n\t(current_template_parms): Remove.\n\t(processing_template_decl): Likewise.\n\t(processing_specialization): Likewise.\n\t(processing_explicit_instantiation): Likewise.\n\t(init_pt): New function.\n\t* repo.c: Include ggc.h.\n\t(init_repo): Add GC roots.\n\t* search.c: Don't include varray.h.\n\t(_vptr_name): Remove.\n\t(lookup_field_1): Use vtpr_identifier instead.\n\t(expand_indirect_vtbls_init): Remove redundant declaration of\n\tin_charge_identifier.\n\t(init_search_processing): Use vptr_identifier.\n\nFrom-SVN: r29135", "tree": {"sha": "e2a685bcbfc3b5ef40f703f25a36b461437c4c79", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e2a685bcbfc3b5ef40f703f25a36b461437c4c79"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9cd64686e8f8f61a283ea72613b2c4acac4cf985", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9cd64686e8f8f61a283ea72613b2c4acac4cf985", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9cd64686e8f8f61a283ea72613b2c4acac4cf985", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9cd64686e8f8f61a283ea72613b2c4acac4cf985/comments", "author": null, "committer": null, "parents": [{"sha": "565e3f3ec215eb47c30758a8944a6efce5d1fbb1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/565e3f3ec215eb47c30758a8944a6efce5d1fbb1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/565e3f3ec215eb47c30758a8944a6efce5d1fbb1"}], "stats": {"total": 845, "additions": 464, "deletions": 381}, "files": [{"sha": "9318c0b21bf956dfb7d89f38c00e7934fa379905", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cd64686e8f8f61a283ea72613b2c4acac4cf985/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cd64686e8f8f61a283ea72613b2c4acac4cf985/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9cd64686e8f8f61a283ea72613b2c4acac4cf985", "patch": "@@ -1,3 +1,120 @@\n+1999-09-05  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tGet ready for garbage collection.\n+\t* Makefile.in (CXX_TREE_H): Add varray.h\n+\t(lex.o): Depend on ggc.h.\n+\t(decl.o): Likewise.\n+\t(decl2.o): Likewise.\n+\t(method.o): Likewise.\n+\t(search.o): Likewise.\n+\t(pt.o): Likewise.\n+\t(repo.o): Likewise.\n+\t* clas.c: Include ggc.h.\n+\t(current_class_name): Remove.\n+\t(current_class_type): Likewise.\n+\t(current_access_specifier): Likewise.\n+\t(previous_class_type): Likewise.\n+\t(previous_class_values): Likewise.\n+\t(class_cache_firstobj): Likewise.\n+\t(current_lang_base): Likewise.\n+\t(current_lang_stack): Likewise.\n+\t(current_lang_stacksize): Likewise.\n+\t(lang_name_c): Likewise.\n+\t(lang_name_cplusplus): Likewise.\n+\t(lang_name_java): Likewise.\n+\t(current_lang_name): Likewise.\n+\t(base_layout_decl): Likewise.\n+\t(access_default_node): Likewise.\n+\t(access_public_node): Likewise.\n+\t(access_protected_node): Likewise.\n+\t(access_private_node): Likewise.\n+\t(access_default_virtual_node): Likewise.\n+\t(access_public_virtual_node): Likewise.\n+\t(access_protected_virtual_node): Likewise.\n+\t(access_private_virtual_node): Likewise.\n+\t(signed_zero_node): Likewise.\n+\t(init_class_processing): Don't build base_layout_decl.\n+\t(push_lang_context): Adjust now that current_lang_base is a varray.\n+\t(pop_lang_context): Likewise.\n+\t* cp-tree.h: Include varray.h.\n+\t(cp_global_trees): Add access_default, access_public,\n+\taccess_protected, access_private, access_default_virtual,\n+\taccess_public_virtual, access_protected_virtual,\n+\taccess_private_virtual, ctor_identifier, delta2_identifier, \n+\tdelta_identifier, dtor_identifier, in_charge_identifier,\n+\tindex_identifier, nelts_identifier, this_identifier,\n+\tpfn_identifier, pfn_or_delta2_identifier, vptr_identifier,\n+\tlang_name_c, lang_name_cplusplus, lang_name_java,\n+\tempty_except_spec, null, jclass, minus_one, terminate.\n+\t(saved_scope): Move here from decl.c.  Define globals in terms of\n+\tsaved_scope: current_namespace, current_class_name,\n+\tcurrent_class_type, current_access_specifier, current_lang_stack,\n+\tcurrent_lang_base, current_lang_name, current_function_parms,\n+\tcurrent_template_parms, processing_template_decl,\n+\tprocessing_specialization, processing_explicit_instantiation,\n+\tprevious_class_type, previous_class_values, class_cache_firstobj.\n+\t(scope_chain): New variable.\n+\t(init_pt): New function.\n+\t* decl.c (current_namespace): Remove.\n+\t(this_identifier, in_charge_identifier, ctor_identifier): Likewise.\n+\t(dtor_identifier, pfn_identifier, index_identifier): Likewise.\n+\t(delta_identifier, delta2_identifier): Likewise.\n+\t(pfn_or_delta2_identifier, tag_identifier): Likewise\n+\t(vt_off_identifier, empty_except_spec, null_node): Likewise.\n+\t(current_function_parms, current_lang_base): Remove.\n+\t(current_lang_stack, previous_class_values): Remove.\n+\t(class_binding_level): Macroize.\n+\t(saved_scope): Remove.\n+\t(current_saved_scope): Rename to scope_chain.\n+\t(mark_saved_scope): Adjust for new scope structure.\n+\t(maybe_push_to_top_level): Likewise.\n+\t(pop_from_top_level): Likewise.\n+\t(duplicate_decls): Adjust now that current_lang_base is a varray.\n+\t(build_typename_type): Call ggc_add_tree_hash_table_root.\n+\t(init_decl_processing): Call init_pt.  Call push_to_top_level to\n+\tset up globals.  Add GC roots.\n+\t(xref_basetypes): Adjust now that current_lang_base is a varray.\n+\t* decl.h (this_identifier): Remove.\n+\t(in_charge_identifier): Likewise.\n+\t* decl2.c: Don't include varray.h.\n+\t(current_namespace): Remove.\n+\t(init_decl2): Add GC roots.\n+\t* except.c (Terminate): Remove. \n+\t(init_exception_processing): Use terminate_node instead.\n+\t(build_terminate_handler): Likewise.\n+\t* init.c (nc_nelts_field_id): Remove.\n+\t(minus_one): Likewise.\n+\t(init_init_processing): Use minus_one_node and nelts_identifier\n+\tinstead.  Add GC roots.\n+\t(jclass_node): Remove.\n+\t(build_new_1): Use nelts_identifier.\n+\t(build_vec_init): Likewise.\n+\t(build_vec_delete): Likewise.\n+\t* lex.c: Include ggc.h.\n+\t(defarg_fn): Move declaration early.\n+\t(defarg_parms): Likewise.\n+\t(init_parse): Add GC roots.\n+\t(handle_cp_pragma): Remove redundant declaration of\n+\tpending_vtables.\n+\t* method.c: Include ggc.h.\n+\t(btypelist): Make it a varray.  All uses changed.\n+\t(ktypelist): Likewise.\n+\t(init_method): Add GC roots.\n+\t* pt.c: Don't include varray.h.  Include ggc.h.\n+\t(current_template_parms): Remove.\n+\t(processing_template_decl): Likewise.\n+\t(processing_specialization): Likewise.\n+\t(processing_explicit_instantiation): Likewise.\n+\t(init_pt): New function.\n+\t* repo.c: Include ggc.h.\n+\t(init_repo): Add GC roots.\n+\t* search.c: Don't include varray.h.\n+\t(_vptr_name): Remove.\n+\t(lookup_field_1): Use vtpr_identifier instead.\n+\t(expand_indirect_vtbls_init): Remove redundant declaration of\n+\tin_charge_identifier.\n+\t(init_search_processing): Use vptr_identifier.\n+\t\n 1999-09-05  Richard Henderson  <rth@cygnus.com>\n             Bernd Schmidt <bernds@cygnus.co.uk>\n             Mark Mitchell  <mark@codesourcery.com>"}, {"sha": "07e0f83286103f624302ad6354a310fe7d31b6a0", "filename": "gcc/cp/Makefile.in", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cd64686e8f8f61a283ea72613b2c4acac4cf985/gcc%2Fcp%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cd64686e8f8f61a283ea72613b2c4acac4cf985/gcc%2Fcp%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMakefile.in?ref=9cd64686e8f8f61a283ea72613b2c4acac4cf985", "patch": "@@ -202,7 +202,7 @@ RTL_H = $(srcdir)/../rtl.h $(srcdir)/../rtl.def \\\n TREE_H = $(srcdir)/../tree.h $(srcdir)/../real.h $(srcdir)/../tree.def \\\n \t$(srcdir)/../machmode.h $(srcdir)/../machmode.def\n CXX_TREE_H = $(TREE_H) cp-tree.h $(srcdir)/../c-common.h cp-tree.def \\\n-\t$(srcdir)/../function.h\n+\t$(srcdir)/../function.h $(srcdir)/../varray.h\n PARSE_H = $(srcdir)/parse.h\n PARSE_C = $(srcdir)/parse.c\n EXPR_H = $(srcdir)/../expr.h ../insn-codes.h\n@@ -241,17 +241,16 @@ spew.o : spew.c $(CONFIG_H) $(CXX_TREE_H) $(PARSE_H) $(srcdir)/../flags.h \\\n lex.o : lex.c $(CONFIG_H) $(CXX_TREE_H) \\\n   $(PARSE_H) input.c $(srcdir)/../flags.h hash.h lex.h \\\n   $(srcdir)/../c-pragma.h $(srcdir)/../system.h $(srcdir)/../toplev.h \\\n-  $(srcdir)/../output.h $(srcdir)/../mbchar.h\n+  $(srcdir)/../output.h $(srcdir)/../mbchar.h $(srcdir)/../ggc.h\n decl.o : decl.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h \\\n   lex.h decl.h $(srcdir)/../stack.h $(srcdir)/../output.h  \\\n   $(srcdir)/../except.h $(srcdir)/../system.h $(srcdir)/../toplev.h \\\n-  $(srcdir)/../hash.h\n+  $(srcdir)/../hash.h $(srcdir)/../ggc.h\n decl2.o : decl2.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h \\\n   lex.h decl.h $(EXPR_H) $(srcdir)/../except.h \\\n   $(srcdir)/../output.h $(srcdir)/../except.h $(srcdir)/../system.h \\\n   $(srcdir)/../toplev.h $(srcdir)/../dwarf2out.h $(srcdir)/../dwarfout.h \\\n-  $(srcdir)/../../include/splay-tree.h $(srcdir)/../varray.h \\\n-  $(srcdir)/../ggc.h\n+  $(srcdir)/../../include/splay-tree.h $(srcdir)/../ggc.h\n typeck2.o : typeck2.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h \\\n   $(srcdir)/../system.h $(srcdir)/../toplev.h\n typeck.o : typeck.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h $(RTL_H) \\\n@@ -266,12 +265,11 @@ friend.o : friend.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h $(RTL_H) \\\n init.o : init.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h $(RTL_H) \\\n   $(EXPR_H) $(srcdir)/../system.h $(srcdir)/../toplev.h $(srcdir)/../ggc.h\n method.o : method.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../system.h \\\n-  $(srcdir)/../toplev.h\n+  $(srcdir)/../toplev.h $(srcdir)/../ggc.h\n cvt.o : cvt.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../system.h decl.h \\\n   $(srcdir)/../flags.h $(srcdir)/../toplev.h $(srcdir)/../convert.h\n search.o : search.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../stack.h \\\n-  $(srcdir)/../flags.h $(srcdir)/../system.h $(srcdir)/../toplev.h \\\n-  $(srcdir)/../varray.h\n+  $(srcdir)/../flags.h $(srcdir)/../system.h $(srcdir)/../toplev.h\n tree.o : tree.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h \\\n   $(srcdir)/../system.h $(srcdir)/../toplev.h\n ptree.o : ptree.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../system.h\n@@ -284,13 +282,13 @@ expr.o : expr.c $(CONFIG_H) $(CXX_TREE_H) $(RTL_H) $(srcdir)/../flags.h \\\n xref.o : xref.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../input.h \\\n   $(srcdir)/../system.h $(srcdir)/../toplev.h\n pt.o : pt.c $(CONFIG_H) $(CXX_TREE_H) decl.h $(PARSE_H) lex.h \\\n-  $(srcdir)/../system.h $(srcdir)/../toplev.h\n+  $(srcdir)/../system.h $(srcdir)/../toplev.h $(srcdir)/../ggc.h\n error.o : error.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../system.h \\\n   $(srcdir)/../toplev.h\n errfn.o : errfn.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../system.h \\\n   $(srcdir)/../toplev.h\n repo.o : repo.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../system.h \\\n-  $(srcdir)/../toplev.h\n+  $(srcdir)/../toplev.h $(srcdir)/../ggc.h\n semantics.o: semantics.c $(CONFIG_H) $(CXX_TREE_H) lex.h \\\n   $(srcdir)/../except.h $(srcdir)/../system.h $(srcdir)/../toplev.h\n dump.o: dump.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../system.h"}, {"sha": "7b508703d0fc18bb54d67e699fddf2de3f00a10e", "filename": "gcc/cp/class.c", "status": "modified", "additions": 10, "deletions": 50, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cd64686e8f8f61a283ea72613b2c4acac4cf985/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cd64686e8f8f61a283ea72613b2c4acac4cf985/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=9cd64686e8f8f61a283ea72613b2c4acac4cf985", "patch": "@@ -31,6 +31,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"output.h\"\n #include \"toplev.h\"\n #include \"splay-tree.h\"\n+#include \"ggc.h\"\n \n #include \"obstack.h\"\n #define obstack_chunk_alloc xmalloc\n@@ -71,19 +72,8 @@ typedef struct class_stack_node {\n static int current_class_stack_size;\n static class_stack_node_t current_class_stack;\n \n-/* The following two can be derived from the previous one */\n-tree current_class_name;\t/* IDENTIFIER_NODE: name of current class */\n-tree current_class_type;\t/* _TYPE: the type of the current class */\n-tree current_access_specifier;\n-tree previous_class_type;\t/* _TYPE: the previous type that was a class */\n-tree previous_class_values;\t/* TREE_LIST: copy of the class_shadowed list\n-\t\t\t\t   when leaving an outermost class scope.  */\n-\n /* The obstack on which the cached class declarations are kept.  */\n static struct obstack class_cache_obstack;\n-/* The first object allocated on that obstack.  We can use\n-   obstack_free with tis value to free the entire obstack.  */\n-char *class_cache_firstobj;\n \n struct base_info;\n \n@@ -137,29 +127,6 @@ static tree build_vtbl_initializer PROTO((tree));\n static int count_fields PROTO((tree));\n static int add_fields_to_vec PROTO((tree, tree, int));\n \n-/* Way of stacking language names.  */\n-tree *current_lang_base, *current_lang_stack;\n-int current_lang_stacksize;\n-\n-/* Names of languages we recognize.  */\n-tree lang_name_c, lang_name_cplusplus, lang_name_java;\n-tree current_lang_name;\n-\n-/* When layout out an aggregate type, the size of the\n-   basetypes (virtual and non-virtual) is passed to layout_record\n-   via this node.  */\n-static tree base_layout_decl;\n-\n-/* Constants used for access control.  */\n-tree access_default_node; /* 0 */\n-tree access_public_node; /* 1 */\n-tree access_protected_node; /* 2 */\n-tree access_private_node; /* 3 */\n-tree access_default_virtual_node; /* 4 */\n-tree access_public_virtual_node; /* 5 */\n-tree access_protected_virtual_node; /* 6 */\n-tree access_private_virtual_node; /* 7 */\n-\n /* Variables shared between class.c and call.c.  */\n \n #ifdef GATHER_STATISTICS\n@@ -780,8 +747,6 @@ build_vtable (binfo, type)\n   return decl;\n }\n \n-extern tree signed_size_zero_node;\n-\n /* Give TYPE a new virtual function table which is initialized\n    with a skeleton-copy of its original initialization.  The only\n    entry that changes is the `delta' entry, so we can really\n@@ -4488,10 +4453,6 @@ init_class_processing ()\n     = (class_stack_node_t) xmalloc (current_class_stack_size \n \t\t\t\t    * sizeof (struct class_stack_node));\n \n-  current_lang_stacksize = 10;\n-  current_lang_base = (tree *)xmalloc(current_lang_stacksize * sizeof (tree));\n-  current_lang_stack = current_lang_base;\n-\n   access_default_node = build_int_2 (0, 0);\n   access_public_node = build_int_2 (1, 0);\n   access_protected_node = build_int_2 (2, 0);\n@@ -4501,10 +4462,6 @@ init_class_processing ()\n   access_protected_virtual_node = build_int_2 (6, 0);\n   access_private_virtual_node = build_int_2 (7, 0);\n \n-  /* Keep these values lying around.  */\n-  base_layout_decl = build_lang_decl (FIELD_DECL, NULL_TREE, error_mark_node);\n-  TREE_TYPE (base_layout_decl) = make_node (RECORD_TYPE);\n-\n   gcc_obstack_init (&class_obstack);\n }\n \n@@ -4736,13 +4693,13 @@ push_lang_context (name)\n      tree name;\n {\n   *current_lang_stack++ = current_lang_name;\n-  if (current_lang_stack >= current_lang_base + current_lang_stacksize)\n+  if (current_lang_stack - &VARRAY_TREE (current_lang_base, 0)\n+      >= (ptrdiff_t) VARRAY_SIZE (current_lang_base))\n     {\n-      current_lang_base\n-\t= (tree *)xrealloc (current_lang_base,\n-\t\t\t    sizeof (tree) * (current_lang_stacksize + 10));\n-      current_lang_stack = current_lang_base + current_lang_stacksize;\n-      current_lang_stacksize += 10;\n+      size_t old_size = VARRAY_SIZE (current_lang_base);\n+\n+      VARRAY_GROW (current_lang_base, old_size + 10);\n+      current_lang_stack = &VARRAY_TREE (current_lang_base, old_size);\n     }\n \n   if (name == lang_name_cplusplus)\n@@ -4781,6 +4738,9 @@ push_lang_context (name)\n void\n pop_lang_context ()\n {\n+  /* Clear the current entry so that garbage collector won't hold on\n+     to it.  */\n+  *current_lang_stack = NULL_TREE;\n   current_lang_name = *--current_lang_stack;\n   if (current_lang_name == lang_name_cplusplus\n       || current_lang_name == lang_name_java)"}, {"sha": "14231e803b6c476e8b5cff2ba614c6b4c0036e10", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 160, "deletions": 51, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cd64686e8f8f61a283ea72613b2c4acac4cf985/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cd64686e8f8f61a283ea72613b2c4acac4cf985/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=9cd64686e8f8f61a283ea72613b2c4acac4cf985", "patch": "@@ -21,6 +21,7 @@ Boston, MA 02111-1307, USA.  */\n \n #include \"c-common.h\"\n #include \"function.h\"\n+#include \"varray.h\"\n \n #ifndef _CP_TREE_H\n #define _CP_TREE_H\n@@ -390,6 +391,37 @@ enum cp_tree_index\n     CPTI_ABORT_FNDECL,\n     CPTI_GLOBAL_DELETE_FNDECL,\n \n+    CPTI_ACCESS_DEFAULT,\n+    CPTI_ACCESS_PUBLIC,\n+    CPTI_ACCESS_PROTECTED,\n+    CPTI_ACCESS_PRIVATE,\n+    CPTI_ACCESS_DEFAULT_VIRTUAL,\n+    CPTI_ACCESS_PUBLIC_VIRTUAL,\n+    CPTI_ACCESS_PROTECTED_VIRTUAL,\n+    CPTI_ACCESS_PRIVATE_VIRTUAL,\n+\n+    CPTI_CTOR_IDENTIFIER,\n+    CPTI_DELTA2_IDENTIFIER,\n+    CPTI_DELTA_IDENTIFIER,\n+    CPTI_DTOR_IDENTIFIER,\n+    CPTI_IN_CHARGE_IDENTIFIER,\n+    CPTI_INDEX_IDENTIFIER,\n+    CPTI_NELTS_IDENTIFIER,\n+    CPTI_THIS_IDENTIFIER,\n+    CPTI_PFN_IDENTIFIER,\n+    CPTI_PFN_OR_DELTA2_IDENTIFIER,\n+    CPTI_VPTR_IDENTIFIER,\n+\n+    CPTI_LANG_NAME_C,\n+    CPTI_LANG_NAME_CPLUSPLUS,\n+    CPTI_LANG_NAME_JAVA,\n+\n+    CPTI_EMPTY_EXCEPT_SPEC,\n+    CPTI_NULL,\n+    CPTI_JCLASS,\n+    CPTI_MINUS_ONE,\n+    CPTI_TERMINATE,\n+\n     CPTI_MAX\n };\n \n@@ -433,6 +465,129 @@ extern tree cp_global_trees[CPTI_MAX];\n #define abort_fndecl\t\t\tcp_global_trees[CPTI_ABORT_FNDECL]\n #define global_delete_fndecl\t\tcp_global_trees[CPTI_GLOBAL_DELETE_FNDECL]\n \n+/* Define the sets of attributes that member functions and baseclasses\n+   can have.  These are sensible combinations of {public,private,protected}\n+   cross {virtual,non-virtual}.  */\n+\n+#define access_default_node             cp_global_trees[CPTI_ACCESS_DEFAULT]\n+#define access_public_node              cp_global_trees[CPTI_ACCESS_PUBLIC]\n+#define access_protected_node           cp_global_trees[CPTI_ACCESS_PROTECTED]\n+#define access_private_node             cp_global_trees[CPTI_ACCESS_PRIVATE]\n+#define access_default_virtual_node     cp_global_trees[CPTI_ACCESS_DEFAULT_VIRTUAL]\n+#define access_public_virtual_node      cp_global_trees[CPTI_ACCESS_PUBLIC_VIRTUAL]\n+#define access_protected_virtual_node   cp_global_trees[CPTI_ACCESS_PROTECTED_VIRTUAL]\n+#define access_private_virtual_node     cp_global_trees[CPTI_ACCESS_PRIVATE_VIRTUAL]\n+\n+/* We cache these tree nodes so as to call get_identifier less\n+   frequently.  */\n+\n+#define ctor_identifier                 cp_global_trees[CPTI_CTOR_IDENTIFIER]\n+#define delta2_identifier               cp_global_trees[CPTI_DELTA2_IDENTIFIER]\n+#define delta_identifier                cp_global_trees[CPTI_DELTA_IDENTIFIER]\n+#define dtor_identifier                 cp_global_trees[CPTI_DTOR_IDENTIFIER]\n+#define in_charge_identifier            cp_global_trees[CPTI_IN_CHARGE_IDENTIFIER]\n+#define index_identifier                cp_global_trees[CPTI_INDEX_IDENTIFIER]\n+#define nelts_identifier                cp_global_trees[CPTI_NELTS_IDENTIFIER]\n+#define this_identifier                 cp_global_trees[CPTI_THIS_IDENTIFIER]\n+#define pfn_identifier                  cp_global_trees[CPTI_PFN_IDENTIFIER]\n+#define pfn_or_delta2_identifier        cp_global_trees[CPTI_PFN_OR_DELTA2_IDENTIFIER]\n+#define vptr_identifier                 cp_global_trees[CPTI_VPTR_IDENTIFIER]\n+\n+#define lang_name_c                     cp_global_trees[CPTI_LANG_NAME_C]\n+#define lang_name_cplusplus             cp_global_trees[CPTI_LANG_NAME_CPLUSPLUS]\n+#define lang_name_java                  cp_global_trees[CPTI_LANG_NAME_JAVA]\n+\n+/* Exception specifier used for throw().  */\n+#define empty_except_spec               cp_global_trees[CPTI_EMPTY_EXCEPT_SPEC]\n+\n+/* The node for `__null'.  */\n+#define null_node                       cp_global_trees[CPTI_NULL]\n+\n+/* If non-NULL, a POINTER_TYPE equivalent to (java::lang::Class*). */\n+#define jclass_node                     cp_global_trees[CPTI_JCLASS]\n+\n+/* A node for `(int) -1'.  */\n+#define minus_one_node                  cp_global_trees[CPTI_MINUS_ONE]\n+\n+/* The declaration for `std::terminate'.  */\n+#define terminate_node                  cp_global_trees[CPTI_TERMINATE]\n+\n+/* Global state.  */\n+\n+struct saved_scope {\n+  struct binding_level *old_binding_level;\n+  tree old_bindings;\n+  tree old_namespace;\n+  struct saved_scope *prev;\n+  tree class_name, class_type;\n+  tree access_specifier;\n+  tree function_decl;\n+  struct binding_level *class_bindings;\n+  varray_type lang_base;\n+  tree *lang_stack;\n+  tree lang_name;\n+  tree x_function_parms;\n+  tree template_parms;\n+  HOST_WIDE_INT x_processing_template_decl;\n+  tree x_previous_class_type;\n+  tree x_previous_class_values;\n+  int x_processing_specialization;\n+  int x_processing_explicit_instantiation;\n+  char *firstobj;\n+};\n+\n+/* The current open namespace.  */\n+\n+#define current_namespace scope_chain->old_namespace\n+\n+/* IDENTIFIER_NODE: name of current class */\n+\n+#define current_class_name scope_chain->class_name\n+\n+/* _TYPE: the type of the current class */\n+\n+#define current_class_type scope_chain->class_type\n+\n+/* When parsing a class definition, the access specifier most recently\n+   given by the user, or, if no access specifier was given, the\n+   default value appropriate for the kind of class (i.e., struct,\n+   class, or union).  */\n+\n+#define current_access_specifier scope_chain->access_specifier\n+\n+/* Pointer to the top of the language name stack.  */\n+\n+#define current_lang_stack scope_chain->lang_stack\n+#define current_lang_base scope_chain->lang_base\n+#define current_lang_name scope_chain->lang_name\n+\n+/* Parsing a function declarator leaves a list of parameter names\n+   or a chain or parameter decls here.  */\n+\n+#define current_function_parms scope_chain->x_function_parms\n+#define current_template_parms scope_chain->template_parms\n+\n+#define processing_template_decl scope_chain->x_processing_template_decl\n+#define processing_specialization scope_chain->x_processing_specialization\n+#define processing_explicit_instantiation scope_chain->x_processing_explicit_instantiation\n+\n+/* _TYPE: the previous type that was a class */\n+\n+#define previous_class_type scope_chain->x_previous_class_type\n+\n+/* This is a copy of the class_shadowed list of the previous class\n+   binding contour when at global scope.  It's used to reset\n+   IDENTIFIER_CLASS_VALUEs when entering another class scope (i.e. a\n+   cache miss).  */\n+\n+#define previous_class_values scope_chain->x_previous_class_values\n+\n+/* The low-water mark on the class-cache obstack.  */\n+\n+#define class_cache_firstobj scope_chain->firstobj\n+\n+extern struct saved_scope *scope_chain;\n+\n /* Global state pertinent to the current function.  */\n \n struct language_function\n@@ -562,12 +717,12 @@ struct language_function\n #define in_function_try_handler cp_function_chain->in_function_try_handler\n \n extern tree current_function_return_value;\n-extern tree current_namespace;\n extern tree global_namespace;\n \n extern tree ridpointers[];\n extern tree ansi_opname[];\n extern tree ansi_assopname[];\n+extern tree null_pointer_node;\n \n /* Nonzero means `$' can be in an identifier.  */\n \n@@ -2377,20 +2532,12 @@ extern tree type_for_size                       PROTO((unsigned, int));\n extern int c_get_alias_set                      PROTO((tree));\n \n /* in decl{2}.c */\n-extern tree this_identifier;\n-extern tree ctor_identifier, dtor_identifier;\n-extern tree pfn_identifier;\n-extern tree index_identifier;\n-extern tree delta_identifier;\n-extern tree delta2_identifier;\n-extern tree pfn_or_delta2_identifier;\n-extern tree tag_identifier;\n-extern tree vt_off_identifier;\n-extern tree empty_except_spec;\n-\n /* A node that is a list (length 1) of error_mark_nodes.  */\n extern tree error_mark_list;\n \n+/* A list of virtual function tables we must make sure to write out.  */\n+extern tree pending_vtables;\n+\n /* Node for \"pointer to (virtual) function\".\n    This may be distinct from ptr_type_node so gdb can distinguish them.  */\n #define vfunc_ptr_type_node \\\n@@ -2400,8 +2547,6 @@ extern tree error_mark_list;\n /* For building calls to `delete'.  */\n extern tree integer_two_node, integer_three_node;\n \n-extern tree null_node;\n-\n extern tree anonymous_namespace_name;\n \n /* in pt.c  */\n@@ -2416,9 +2561,6 @@ typedef enum unification_kind_t {\n   DEDUCE_EXACT\n } unification_kind_t;\n \n-extern tree current_template_parms;\n-extern HOST_WIDE_INT processing_template_decl;\n-\n /* The template currently being instantiated, and where the instantiation\n    was triggered.  */\n struct tinst_level\n@@ -2433,23 +2575,8 @@ extern void maybe_print_template_context\tPROTO ((void));\n \n /* in class.c */\n \n-/* When parsing a class definition, the access specifier most recently\n-   given by the user, or, if no access specifier was given, the\n-   default value appropriate for the kind of class (i.e., struct,\n-   class, or union).  */\n-extern tree current_access_specifier;\n-\n-extern tree current_class_name;\n-extern tree current_class_type;\n-extern tree previous_class_type;\n extern int current_class_depth;\n \n-extern tree current_lang_name;\n-extern tree lang_name_cplusplus, lang_name_c, lang_name_java;\n-\n-/* The low-water mark on the class-cache obstack.  */\n-extern char *class_cache_firstobj;\n-\n /* Points to the name of that function. May not be the DECL_NAME\n    of CURRENT_FUNCTION_DECL due to overloading */\n extern tree original_function_name;\n@@ -2634,20 +2761,6 @@ extern tree global_base_init_list;\n     && MAIN_NAME_P (DECL_NAME (NODE)))\n \n \f\n-/* Define the sets of attributes that member functions and baseclasses\n-   can have.  These are sensible combinations of {public,private,protected}\n-   cross {virtual,non-virtual}.  */\n-\n-/* in class.c.  */\n-extern tree access_default_node; /* 0 */\n-extern tree access_public_node; /* 1 */\n-extern tree access_protected_node; /* 2 */\n-extern tree access_private_node; /* 3 */\n-extern tree access_default_virtual_node; /* 4 */\n-extern tree access_public_virtual_node; /* 5 */\n-extern tree access_protected_virtual_node; /* 6 */\n-extern tree access_private_virtual_node; /* 7 */\n-\n /* Things for handling inline functions.  */\n \n struct pending_inline\n@@ -2715,9 +2828,6 @@ extern int at_eof;\n \n enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, OP_FLAG, TYPENAME_FLAG };\n \n-/* The following two can be derived from the previous one */\n-extern tree current_class_name;\t/* IDENTIFIER_NODE: name of current class */\n-\n /* Some macros for char-based bitfields.  */\n #define B_SET(a,x) (a[x>>3] |= (1 << (x&7)))\n #define B_CLR(a,x) (a[x>>3] &= ~(1 << (x&7)))\n@@ -3321,6 +3431,7 @@ extern void synthesize_method\t\t\tPROTO((tree));\n extern tree get_id_2\t\t\t\tPROTO((const char *, tree));\n \n /* in pt.c */\n+extern void init_pt                             PROTO ((void));\n extern void check_template_shadow\t\tPROTO ((tree));\n extern tree innermost_args\t\t\tPROTO ((tree));\n extern tree tsubst\t\t\t\tPROTO ((tree, tree, int, tree));\n@@ -3377,8 +3488,6 @@ extern void print_candidates                    PROTO((tree));\n extern int instantiate_pending_templates        PROTO((void));\n extern tree tsubst_default_argument             PROTO((tree, tree, tree));\n \n-extern int processing_specialization;\n-extern int processing_explicit_instantiation;\n extern int processing_template_parmlist;\n \n /* in repo.c */"}, {"sha": "93558bb6435a4b558060f549c6cabfa18915e2c4", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 56, "deletions": 150, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cd64686e8f8f61a283ea72613b2c4acac4cf985/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cd64686e8f8f61a283ea72613b2c4acac4cf985/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=9cd64686e8f8f61a283ea72613b2c4acac4cf985", "patch": "@@ -55,7 +55,6 @@ extern int current_class_depth;\n \n extern tree static_ctors, static_dtors;\n \n-extern tree current_namespace;\n extern tree global_namespace;\n \n extern int (*valid_lang_attribute) PROTO ((tree, tree, tree, tree));\n@@ -294,6 +293,7 @@ tree unsigned_type_node;\n \n tree ptr_type_node;\n tree va_list_type_node;\n+tree null_pointer_node;\n \n /* Indicates that there is a type value in some namespace, although\n    that is not necessarily in scope at the moment.  */\n@@ -325,19 +325,6 @@ static int only_namespace_names;\n \n #define original_result_rtx cp_function_chain->x_result_rtx\n \n-/* C++: Keep these around to reduce calls to `get_identifier'.\n-   Identifiers for `this' in member functions and the auto-delete\n-   parameter for destructors.  */\n-tree this_identifier, in_charge_identifier;\n-tree ctor_identifier, dtor_identifier;\n-/* Used in pointer to member functions, in vtables, and in sigtables.  */\n-tree pfn_identifier, index_identifier, delta_identifier, delta2_identifier;\n-tree pfn_or_delta2_identifier, tag_identifier;\n-tree vt_off_identifier;\n-\n-/* Exception specifier used for throw().  */\n-tree empty_except_spec;\n-\n struct named_label_list\n {\n   struct binding_level *binding_level;\n@@ -375,15 +362,9 @@ tree static_aggregates;\n \n /* -- end of C++ */\n \n-/* Two expressions that are constants with value zero.\n-   The first is of type `int', the second of type `void *'.  */\n+/* An expression of type `int' for the constant zero.  */\n \n tree integer_zero_node;\n-tree null_pointer_node;\n-\n-/* The value for __null (NULL), namely, a zero of an integer type with\n-   the same number of bits as a pointer.  */\n-tree null_node;\n \n /* A node for the integer constants 1, 2, and 3.  */\n \n@@ -398,23 +379,13 @@ static tree enum_next_value;\n \n static int enum_overflow;\n \n-/* Parsing a function declarator leaves a list of parameter names\n-   or a chain or parameter decls here.  */\n-\n-tree last_function_parms;\n-\n /* Parsing a function declarator leaves here a chain of structure\n    and enum types declared in the parmlist.  */\n \n static tree last_function_parm_tags;\n \n-/* After parsing the declarator that starts a function definition,\n-   `start_function' puts here the list of parameter names or chain of decls.\n-   `store_parm_decls' finds it here.  */\n-\n-static tree current_function_parms;\n-\n /* Similar, for last_function_parm_tags.  */\n+tree last_function_parms;\n static tree current_function_parm_tags;\n \n /* A list (chain of TREE_LIST nodes) of all LABEL_DECLs in the function\n@@ -462,10 +433,6 @@ extern int flag_huge_objects;\n    .common instead of .data at the expense of not flagging multiple\n    definitions.  */\n extern int flag_conserve_space;\n-\n-/* Pointers to the base and current top of the language name stack.  */\n-\n-extern tree *current_lang_base, *current_lang_stack;\n \f\n /* C and C++ flags are in decl2.c.  */\n \n@@ -480,11 +447,6 @@ extern tree *current_lang_base, *current_lang_stack;\n \n extern int spew_debug;\n \n-/* This is a copy of the class_shadowed list of the previous class binding\n-   contour when at global scope.  It's used to reset IDENTIFIER_CLASS_VALUEs\n-   when entering another class scope (i.e. a cache miss).  */\n-extern tree previous_class_values;\n-\n /* A expression of value 0 with the same precision as a sizetype\n    node, but signed.  */\n tree signed_size_zero_node;\n@@ -645,7 +607,7 @@ struct binding_level\n \n /* The binding level of the current class, if any.  */\n \n-static struct binding_level *class_binding_level;\n+#define class_binding_level scope_chain->class_bindings\n \n /* A chain of binding_level structures awaiting reuse.  */\n \n@@ -2432,28 +2394,9 @@ pop_nested_namespace (ns)\n    local-value slots of all identifiers, so that only the global values\n    are at all visible.  Simply setting current_binding_level to the global\n    scope isn't enough, because more binding levels may be pushed.  */\n-struct saved_scope {\n-  struct binding_level *old_binding_level;\n-  tree old_bindings;\n-  tree old_namespace;\n-  struct saved_scope *prev;\n-  tree class_name, class_type;\n-  tree access_specifier;\n-  tree function_decl;\n-  struct binding_level *class_bindings;\n-  tree *lang_base, *lang_stack, lang_name;\n-  int lang_stacksize;\n-  tree last_function_parms;\n-  tree template_parms;\n-  HOST_WIDE_INT processing_template_decl;\n-  tree previous_class_type, previous_class_values;\n-  int processing_specialization;\n-  int processing_explicit_instantiation;\n-  char *class_cache_firstobj;\n-};\n-static struct saved_scope *current_saved_scope;\n+struct saved_scope *scope_chain;\n \n-/* Mark ARG (which is really a struct saved_scoipe **) for GC.  */\n+/* Mark ARG (which is really a struct saved_scope **) for GC.  */\n \n static void\n mark_saved_scope (arg)\n@@ -2471,14 +2414,12 @@ mark_saved_scope (arg)\n       ggc_mark_tree (t->access_specifier);\n       ggc_mark_tree (t->function_decl);\n       if (t->lang_base)\n-\tggc_mark_tree (*t->lang_base);\n-      if (t->lang_stack)\n-\tggc_mark_tree (*t->lang_stack);\n+\tggc_mark_tree_varray (t->lang_base);\n       ggc_mark_tree (t->lang_name);\n-      ggc_mark_tree (t->last_function_parms);\n+      ggc_mark_tree (t->x_function_parms);\n       ggc_mark_tree (t->template_parms);\n-      ggc_mark_tree (t->previous_class_type);\n-      ggc_mark_tree (t->previous_class_values);\n+      ggc_mark_tree (t->x_previous_class_type);\n+      ggc_mark_tree (t->x_previous_class_values);\n       t = t->prev;\n     }\n }\n@@ -2543,15 +2484,16 @@ void\n maybe_push_to_top_level (pseudo)\n      int pseudo;\n {\n-  extern int current_lang_stacksize;\n   struct saved_scope *s\n     = (struct saved_scope *) xmalloc (sizeof (struct saved_scope));\n-  struct binding_level *b = current_binding_level;\n+  struct binding_level *b;\n   tree old_bindings = NULL_TREE;\n \n+  b = scope_chain ? current_binding_level : 0;\n+\n   push_function_context_to (NULL_TREE);\n \n-  if (previous_class_type)\n+  if (scope_chain && previous_class_type)\n     old_bindings = store_bindings (previous_class_values, old_bindings);\n \n   /* Have to include global_binding_level, because class-level decls\n@@ -2577,35 +2519,19 @@ maybe_push_to_top_level (pseudo)\n       for (t = b->type_shadowed; t; t = TREE_CHAIN (t))\n \tSET_IDENTIFIER_TYPE_VALUE (TREE_PURPOSE (t), TREE_VALUE (t));\n     }\n-\n-  s->old_binding_level = current_binding_level;\n+  if (scope_chain)\n+    *s = *scope_chain;\n+  s->old_binding_level = scope_chain ? current_binding_level : 0;\n+  s->old_bindings = old_bindings;\n+  s->prev = scope_chain;\n+  scope_chain = s;\n   current_binding_level = b;\n \n-  s->old_namespace = current_namespace;\n-  s->class_name = current_class_name;\n-  s->class_type = current_class_type;\n-  s->access_specifier = current_access_specifier;\n-  s->function_decl = current_function_decl;\n-  s->class_bindings = class_binding_level;\n-  s->lang_stack = current_lang_stack;\n-  s->lang_base = current_lang_base;\n-  s->lang_stacksize = current_lang_stacksize;\n-  s->lang_name = current_lang_name;\n-  s->last_function_parms = last_function_parms;\n-  s->template_parms = current_template_parms;\n-  s->processing_template_decl = processing_template_decl;\n-  s->previous_class_type = previous_class_type;\n-  s->previous_class_values = previous_class_values;\n-  s->class_cache_firstobj = class_cache_firstobj;\n-  s->processing_specialization = processing_specialization;\n-  s->processing_explicit_instantiation = processing_explicit_instantiation;\n-\n   current_class_name = current_class_type = NULL_TREE;\n   current_function_decl = NULL_TREE;\n   class_binding_level = (struct binding_level *)0;\n-  current_lang_stacksize = 10;\n-  current_lang_stack = current_lang_base\n-    = (tree *) xmalloc (current_lang_stacksize * sizeof (tree));\n+  VARRAY_TREE_INIT (current_lang_base, 10, \"current_lang_base\");\n+  current_lang_stack = &VARRAY_TREE (current_lang_base, 0);\n   current_lang_name = lang_name_cplusplus;\n   strict_prototype = strict_prototypes_lang_cplusplus;\n   named_labels = NULL_TREE;\n@@ -2617,10 +2543,6 @@ maybe_push_to_top_level (pseudo)\n   processing_template_decl = 0;\n   current_namespace = global_namespace;\n \n-  s->prev = current_saved_scope;\n-  s->old_bindings = old_bindings;\n-  current_saved_scope = s;\n-\n   push_obstacks (&permanent_obstack, &permanent_obstack);\n }\n \n@@ -2633,8 +2555,7 @@ push_to_top_level ()\n void\n pop_from_top_level ()\n {\n-  extern int current_lang_stacksize;\n-  struct saved_scope *s = current_saved_scope;\n+  struct saved_scope *s = scope_chain;\n   tree t;\n \n   /* Clear out class-level bindings cache.  */\n@@ -2643,8 +2564,9 @@ pop_from_top_level ()\n \n   pop_obstacks ();\n \n-  current_binding_level = s->old_binding_level;\n-  current_saved_scope = s->prev;\n+  VARRAY_FREE (current_lang_base);\n+\n+  scope_chain = s->prev;\n   for (t = s->old_bindings; t; )\n     {\n       tree save = t;\n@@ -2654,34 +2576,16 @@ pop_from_top_level ()\n \t  SET_IDENTIFIER_TYPE_VALUE (id, TREE_VEC_ELT (t, 1));\n \t  IDENTIFIER_BINDING (id) = TREE_VEC_ELT (t, 2);\n \t  IDENTIFIER_CLASS_VALUE (id) = TREE_VEC_ELT (t, 3);\n-\t}\n+ \t}\n       t = TREE_CHAIN (t);\n       TREE_CHAIN (save) = free_binding_vecs;\n       free_binding_vecs = save;\n     }\n-  current_namespace = s->old_namespace;\n-  current_class_name = s->class_name;\n-  current_class_type = s->class_type;\n-  current_access_specifier = s->access_specifier;\n-  current_function_decl = s->function_decl;\n-  class_binding_level = s->class_bindings;\n-  free (current_lang_base);\n-  current_lang_base = s->lang_base;\n-  current_lang_stack = s->lang_stack;\n-  current_lang_name = s->lang_name;\n-  current_lang_stacksize = s->lang_stacksize;\n+\n   if (current_lang_name == lang_name_cplusplus)\n     strict_prototype = strict_prototypes_lang_cplusplus;\n   else if (current_lang_name == lang_name_c)\n     strict_prototype = strict_prototypes_lang_c;\n-  last_function_parms = s->last_function_parms;\n-  current_template_parms = s->template_parms;\n-  processing_template_decl = s->processing_template_decl;\n-  previous_class_type = s->previous_class_type;\n-  previous_class_values = s->previous_class_values;\n-  processing_specialization = s->processing_specialization;\n-  processing_explicit_instantiation = s->processing_explicit_instantiation;\n-  class_cache_firstobj = s->class_cache_firstobj;\n \n   free (s);\n \n@@ -3410,7 +3314,8 @@ duplicate_decls (newdecl, olddecl)\n \t  /* extern \"C\" int foo ();\n \t     int foo () { bar (); }\n \t     is OK.  */\n-\t  if (current_lang_stack == current_lang_base)\n+\t  if (current_lang_stack\n+\t      == &VARRAY_TREE (current_lang_base, 0))\n \t    DECL_LANGUAGE (newdecl) = DECL_LANGUAGE (olddecl);\n \t  else\n \t    {\n@@ -5490,10 +5395,14 @@ build_typename_type (context, name, fullname, base_type)\n \n   push_obstacks (&permanent_obstack, &permanent_obstack);\n \n-  if (!ht.table\n-      && !hash_table_init (&ht, &hash_newfunc, &typename_hash, \n-\t\t\t   &typename_compare))\n-    fatal (\"virtual memory exhausted\");\n+  if (!ht.table)\n+    {\n+      static struct hash_table *h = &ht;\n+      if (!hash_table_init (&ht, &hash_newfunc, &typename_hash, \n+\t\t\t    &typename_compare))\n+\tfatal (\"virtual memory exhausted\");\n+      ggc_add_tree_hash_table_root (&h, 1);\n+    }\n \n   /* The FULLNAME needs to exist for the life of the hash table, i.e.,\n      for the entire compilation.  */\n@@ -6092,14 +6001,6 @@ signal_catch (sig)\n   my_friendly_abort (0);\n }\n \n-#if 0\n-/* Unused -- brendan 970107 */\n-/* Array for holding types considered \"built-in\".  These types\n-   are output in the module in which `main' is defined.  */\n-static tree *builtin_type_tdescs_arr;\n-static int builtin_type_tdescs_len, builtin_type_tdescs_max;\n-#endif\n-\n /* Push the declarations of builtin types into the namespace.\n    RID_INDEX, if < RID_MAX is the index of the builtin type\n    in the array RID_POINTERS.  NAME is the name used when looking\n@@ -6245,14 +6146,13 @@ init_decl_processing ()\n \n   cp_parse_init ();\n   init_decl2 ();\n+  init_pt ();\n \n-  /* Create the global per-function variables.  */\n-  push_function_context_to (NULL_TREE);\n+  /* Create the global variables.  */\n+  push_to_top_level ();\n \n   /* Enter the global namespace. */\n   my_friendly_assert (global_namespace == NULL_TREE, 375);\n-  my_friendly_assert (current_lang_name == NULL_TREE, 375);\n-  current_lang_name = lang_name_cplusplus;\n   push_namespace (get_identifier (\"::\"));\n   global_namespace = current_namespace;\n   current_lang_name = NULL_TREE;\n@@ -6704,39 +6604,44 @@ init_decl_processing ()\n   ggc_add_tree_root (c_global_trees, sizeof c_global_trees / sizeof(tree));\n   ggc_add_tree_root (cp_global_trees, sizeof cp_global_trees / sizeof(tree));\n   ggc_add_tree_root (&char_type_node, 1);\n-  ggc_add_tree_root (&current_function_decl, 1);\n   ggc_add_tree_root (&error_mark_node, 1);\n   ggc_add_tree_root (&integer_type_node, 1);\n   ggc_add_tree_root (&integer_three_node, 1);\n   ggc_add_tree_root (&integer_two_node, 1);\n   ggc_add_tree_root (&integer_one_node, 1);\n   ggc_add_tree_root (&integer_zero_node, 1);\n   ggc_add_tree_root (&signed_size_zero_node, 1);\n-  ggc_add_tree_root (&named_labels, 1);\n-  ggc_add_tree_root (&null_pointer_node, 1);\n   ggc_add_tree_root (&size_one_node, 1);\n   ggc_add_tree_root (&size_zero_node, 1);\n   ggc_add_tree_root (&unsigned_type_node, 1);\n+  ggc_add_tree_root (&ptr_type_node, 1);\n+  ggc_add_tree_root (&null_pointer_node, 1);\n+  ggc_add_tree_root (&va_list_type_node, 1);\n   ggc_add_tree_root (&void_type_node, 1);\n   ggc_add_root (&global_binding_level, 1, sizeof global_binding_level,\n \t\tmark_binding_level);\n-  ggc_add_root (&current_saved_scope, 1, sizeof current_saved_scope,\n-\t\t&mark_saved_scope);\n+  ggc_add_root (&scope_chain, 1, sizeof scope_chain, &mark_saved_scope);\n   ggc_add_tree_root (&static_ctors, 1);\n   ggc_add_tree_root (&static_dtors, 1);\n+  ggc_add_tree_root (&lastiddecl, 1);\n \n   ggc_add_tree_root (&enum_next_value, 1);\n-  ggc_add_tree_root (&last_function_parms, 1);\n   ggc_add_tree_root (&last_function_parm_tags, 1);\n   ggc_add_tree_root (&current_function_return_value, 1);\n   ggc_add_tree_root (&current_function_parms, 1);\n   ggc_add_tree_root (&current_function_parm_tags, 1);\n+  ggc_add_tree_root (&last_function_parms, 1);\n   ggc_add_tree_root (&error_mark_list, 1);\n-  ggc_add_tree_root (&void_list_node, 1);\n+\n   ggc_add_tree_root (&global_namespace, 1);\n-  ggc_add_tree_root (&current_namespace, 1);\n   ggc_add_tree_root (&global_type_node, 1);\n   ggc_add_tree_root (&anonymous_namespace_name, 1);\n+\n+  ggc_add_tree_root (&got_object, 1);\n+  ggc_add_tree_root (&got_scope, 1);\n+\n+  ggc_add_tree_root (&current_lang_name, 1);\n+  ggc_add_tree_root (&static_aggregates, 1);\n }\n \n /* Function to print any language-specific context for an error message.  */\n@@ -12644,7 +12549,8 @@ xref_basetypes (code_type_node, name, ref, binfo)\n \t    }\n \n \t  if (TYPE_FOR_JAVA (basetype)\n-\t      && current_lang_stack == current_lang_base)\n+\t      && (current_lang_stack \n+\t\t  == &VARRAY_TREE (current_lang_base, 0)))\n \t    TYPE_FOR_JAVA (ref) = 1;\n \n \t  /* Note that the BINFO records which describe individual"}, {"sha": "d6c376c39bfe90769795d3fa52c0bc2fa2dec1d8", "filename": "gcc/cp/decl.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cd64686e8f8f61a283ea72613b2c4acac4cf985/gcc%2Fcp%2Fdecl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cd64686e8f8f61a283ea72613b2c4acac4cf985/gcc%2Fcp%2Fdecl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.h?ref=9cd64686e8f8f61a283ea72613b2c4acac4cf985", "patch": "@@ -33,11 +33,6 @@ enum decl_context\n /* We need this in here to get the decl_context definition.  */\n extern tree grokdeclarator\t\t\tPROTO((tree, tree, enum decl_context, int, tree));\n \n-/* C++: Keep these around to reduce calls to `get_identifier'.\n-   Identifiers for `this' in member functions and the auto-delete\n-   parameter for destructors.  */\n-extern tree this_identifier, in_charge_identifier;\n-\n /* Parsing a function declarator leaves a list of parameter names\n    or a chain or parameter decls here.  */\n extern tree last_function_parms;"}, {"sha": "169eba2566fe20c5a3d390ec3830a4d1303c9543", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cd64686e8f8f61a283ea72613b2c4acac4cf985/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cd64686e8f8f61a283ea72613b2c4acac4cf985/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=9cd64686e8f8f61a283ea72613b2c4acac4cf985", "patch": "@@ -43,7 +43,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"dwarf2out.h\"\n #include \"dwarfout.h\"\n #include \"splay-tree.h\"\n-#include \"varray.h\"\n #include \"ggc.h\"\n \n #if USE_CPPLIB\n@@ -128,9 +127,8 @@ int at_eof;\n \n tree static_ctors, static_dtors;\n \n-/* The current open namespace, and ::. */\n+/* The :: namespace. */\n \n-tree current_namespace;\n tree global_namespace;\n \n /* The stack for namespaces of current declarations. */\n@@ -5276,4 +5274,10 @@ init_decl2 ()\n {\n   ggc_add_tree_root (&decl_namespace_list, 1);\n   ggc_add_tree_varray_root (&saved_inlines, 1);\n+  ggc_add_tree_varray_root (&pending_statics, 1);\n+  ggc_add_tree_varray_root (&ssdf_decls, 1);\n+  ggc_add_tree_root (&ssdf_decl, 1);\n+  ggc_add_tree_root (&priority_decl, 1);\n+  ggc_add_tree_root (&initialize_p_decl, 1);\n+  ggc_add_tree_root (&pending_vtables, 1);\n }"}, {"sha": "15e2e8fd169745ff2fac989f608aec9d05942e5a", "filename": "gcc/cp/except.c", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cd64686e8f8f61a283ea72613b2c4acac4cf985/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cd64686e8f8f61a283ea72613b2c4acac4cf985/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=9cd64686e8f8f61a283ea72613b2c4acac4cf985", "patch": "@@ -151,11 +151,6 @@ asm (TEXT_SECTION_ASM_OP);\n      \n      ===================================================================== */\n \n-/* local globals for function calls\n-   ====================================================================== */\n-\n-static tree Terminate;\n-\n /* ====================================================================== */\n \n /* sets up all the global eh stuff that needs to be initialized at the\n@@ -169,9 +164,9 @@ init_exception_processing ()\n   \n   if (flag_honor_std)\n     push_namespace (get_identifier (\"std\"));\n-  Terminate = auto_function (get_identifier (\"terminate\"),\n-\t\t\t     vtype, NOT_BUILT_IN);\n-  TREE_THIS_VOLATILE (Terminate) = 1;\n+  terminate_node = auto_function (get_identifier (\"terminate\"),\n+\t\t\t\t  vtype, NOT_BUILT_IN);\n+  TREE_THIS_VOLATILE (terminate_node) = 1;\n   if (flag_honor_std)\n     pop_namespace ();\n \n@@ -500,7 +495,7 @@ static tree\n build_terminate_handler ()\n {\n   int yes = suspend_momentary ();\n-  tree term = build_function_call (Terminate, NULL_TREE);\n+  tree term = build_function_call (terminate_node, NULL_TREE);\n   resume_momentary (yes);\n   return term;\n }"}, {"sha": "b49dda3833a4481c0b2dc4a6a5bbfa1270b02df2", "filename": "gcc/cp/init.c", "status": "modified", "additions": 9, "deletions": 19, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cd64686e8f8f61a283ea72613b2c4acac4cf985/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cd64686e8f8f61a283ea72613b2c4acac4cf985/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=9cd64686e8f8f61a283ea72613b2c4acac4cf985", "patch": "@@ -50,11 +50,6 @@ static tree build_java_class_ref PROTO((tree));\n static void expand_cleanup_for_base PROTO((tree, tree));\n static tree get_temp_regvar PROTO((tree, tree));\n \n-/* Cache the identifier nodes for the magic field of a new cookie.  */\n-static tree nc_nelts_field_id;\n-\n-static tree minus_one;\n-\n /* Set up local variable for this file.  MUST BE CALLED AFTER\n    INIT_DECL_PROCESSING.  */\n \n@@ -64,20 +59,19 @@ void init_init_processing ()\n {\n   tree fields[1];\n \n-  minus_one = build_int_2 (-1, -1);\n+  minus_one_node = build_int_2 (-1, -1);\n \n   /* Define the structure that holds header information for\n      arrays allocated via operator new.  */\n   BI_header_type = make_lang_type (RECORD_TYPE);\n-  nc_nelts_field_id = get_identifier (\"nelts\");\n-  fields[0] = build_lang_decl (FIELD_DECL, nc_nelts_field_id, sizetype);\n+  nelts_identifier = get_identifier (\"nelts\");\n+  fields[0] = build_lang_decl (FIELD_DECL, nelts_identifier, sizetype);\n   finish_builtin_type (BI_header_type, \"__new_cookie\", fields,\n \t\t       0, double_type_node);\n   BI_header_size = size_in_bytes (BI_header_type);\n \n-  ggc_add_tree_root (&current_base_init_list, 1);\n-  ggc_add_tree_root (&current_member_init_list, 1);\n-  ggc_add_tree_root (&minus_one, 1);\n+  ggc_add_tree_root (&BI_header_type, 1);\n+  ggc_add_tree_root (&BI_header_size, 1);\n }\n \n /* Subroutine of emit_base_init.  For BINFO, initialize all the\n@@ -2107,10 +2101,6 @@ build_new (placement, decl, init, use_global_new)\n   return rval;\n }\n \n-/* If non-NULL, a POINTER_TYPE equivalent to (java::lang::Class*). */\n-\n-static tree jclass_node = NULL_TREE;\n-\n /* Given a Java class, return a decl for the corresponding java.lang.Class. */\n \n static tree\n@@ -2328,7 +2318,7 @@ build_new_1 (exp)\n \t\t\t\t\t  build_pointer_type (BI_header_type),\n \t\t\t\t\t  rval, extra), NULL_PTR);\n       exp1 = build (MODIFY_EXPR, void_type_node,\n-\t\t    build_component_ref (cookie, nc_nelts_field_id,\n+\t\t    build_component_ref (cookie, nelts_identifier,\n \t\t\t\t\t NULL_TREE, 0),\n \t\t    nelts);\n       TREE_SIDE_EFFECTS (exp1) = 1;\n@@ -2909,7 +2899,7 @@ build_vec_init (decl, base, maxindex, init, from_array)\n \n       if_stmt = begin_if_stmt ();\n       finish_if_stmt_cond (build (NE_EXPR, boolean_type_node,\n-\t\t\t\t  iterator, minus_one),\n+\t\t\t\t  iterator, minus_one_node),\n \t\t\t   if_stmt);\n \n       /* Otherwise, loop through the elements.  */\n@@ -3004,7 +2994,7 @@ build_vec_init (decl, base, maxindex, init, from_array)\n \t\t\t\t    ptrdiff_type_node, \n \t\t\t\t    iterator,\n \t\t\t\t    integer_one_node), \n-\t\t\t     minus_one),\n+\t\t\t     minus_one_node),\n \t\t      do_stmt);\n \n       finish_then_clause (if_stmt);\n@@ -3372,7 +3362,7 @@ build_vec_delete (base, maxindex, auto_delete_vec, auto_delete,\n       tree cookie_addr = build (MINUS_EXPR, build_pointer_type (BI_header_type),\n \t\t\t\tbase, BI_header_size);\n       tree cookie = build_indirect_ref (cookie_addr, NULL_PTR);\n-      maxindex = build_component_ref (cookie, nc_nelts_field_id, NULL_TREE, 0);\n+      maxindex = build_component_ref (cookie, nelts_identifier, NULL_TREE, 0);\n       do\n \ttype = TREE_TYPE (type);\n       while (TREE_CODE (type) == ARRAY_TYPE);"}, {"sha": "72995f3a6c30b4daa36fda96da81718b8d3f330e", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cd64686e8f8f61a283ea72613b2c4acac4cf985/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cd64686e8f8f61a283ea72613b2c4acac4cf985/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=9cd64686e8f8f61a283ea72613b2c4acac4cf985", "patch": "@@ -37,6 +37,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"c-pragma.h\"\n #include \"toplev.h\"\n #include \"output.h\"\n+#include \"ggc.h\"\n \n #ifdef MULTIBYTE_CHARS\n #include \"mbchar.h\"\n@@ -173,6 +174,17 @@ static tree this_filename_time;\n \n /* Array for holding counts of the numbers of tokens seen.  */\n extern int *token_count;\n+\n+/* When we see a default argument in a method declaration, we snarf it as\n+   text using snarf_defarg.  When we get up to namespace scope, we then go\n+   through and parse all of them using do_pending_defargs.  Since yacc\n+   parsers are not reentrant, we retain defargs state in these two\n+   variables so that subsequent calls to do_pending_defargs can resume\n+   where the previous call left off.  */\n+\n+static tree defarg_fns;\n+static tree defarg_parm;\n+\n \f\n /* Return something to represent absolute declarators containing a *.\n    TARGET is the absolute declarator that the * contains.\n@@ -875,6 +887,14 @@ init_parse (filename)\n   token_count = init_cpp_parse ();\n   interface_unknown = 1;\n \n+  ggc_add_tree_root (ansi_opname, LAST_CPLUS_TREE_CODE);\n+  ggc_add_tree_root (ansi_assopname, LAST_CPLUS_TREE_CODE);\n+  ggc_add_tree_root (ridpointers, RID_MAX);\n+  ggc_add_tree_root (&defarg_fns, 1);\n+  ggc_add_tree_root (&defarg_parm, 1);\n+  ggc_add_tree_root (&this_filename_time, 1);\n+  ggc_add_tree_root (&filename_times, 1);\n+\n   return filename;\n }\n \n@@ -1821,16 +1841,6 @@ maybe_snarf_defarg ()\n     do_snarf_defarg = 1;\n }\n \n-/* When we see a default argument in a method declaration, we snarf it as\n-   text using snarf_defarg.  When we get up to namespace scope, we then go\n-   through and parse all of them using do_pending_defargs.  Since yacc\n-   parsers are not reentrant, we retain defargs state in these two\n-   variables so that subsequent calls to do_pending_defargs can resume\n-   where the previous call left off.  */\n-\n-tree defarg_fns;\n-tree defarg_parm;\n-\n tree\n snarf_defarg ()\n {\n@@ -2717,8 +2727,6 @@ handle_cp_pragma (pname)\n \n   if (! strcmp (pname, \"vtable\"))\n     {\n-      extern tree pending_vtables;\n-\n       /* More follows: it must be a string constant (class name).  */\n       token = real_yylex ();\n       if (token != STRING || TREE_CODE (yylval.ttype) != STRING_CST)"}, {"sha": "cf681e1deca218a7b4c953d609994fb87d04132e", "filename": "gcc/cp/method.c", "status": "modified", "additions": 56, "deletions": 60, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cd64686e8f8f61a283ea72613b2c4acac4cf985/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cd64686e8f8f61a283ea72613b2c4acac4cf985/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=9cd64686e8f8f61a283ea72613b2c4acac4cf985", "patch": "@@ -41,6 +41,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"hard-reg-set.h\"\n #include \"flags.h\"\n #include \"toplev.h\"\n+#include \"ggc.h\"\n \n /* TREE_LIST of the current inline functions that need to be\n    processed.  */\n@@ -98,11 +99,31 @@ static void build_mangled_name_for_type_with_Gcode PROTO((tree, int));\n # define OB_FINISH() (obstack_1grow (&scratch_obstack, '\\0'))\n # define OB_LAST() (obstack_next_free (&scratch_obstack)[-1])\n \n+/* type tables for K and B type compression */\n+static varray_type btypelist;\n+static varray_type ktypelist;\n+\n+/* number of each type seen */\n+static size_t maxbtype;\n+static size_t maxktype;\n+\n+/* Array of types seen so far in top-level call to `build_mangled_name'.\n+   Allocated and deallocated by caller.  */\n+static varray_type typevec;\n+\n+/* Number of types interned by `build_mangled_name' so far.  */\n+static size_t maxtype;\n+\n+/* Called once to initialize method.c.  */\n+\n void\n init_method ()\n {\n   gcc_obstack_init (&scratch_obstack);\n   scratch_firstobj = (char *)obstack_alloc (&scratch_obstack, 0);\n+  ggc_add_tree_varray_root (&btypelist, 1);\n+  ggc_add_tree_varray_root (&ktypelist, 1);\n+  ggc_add_tree_varray_root (&typevec, 1);\n }\n \n /* This must be large enough to hold any printed integer or floating-point\n@@ -172,24 +193,6 @@ do_inline_function_hair (type, friend_list)\n \f\n /* Here is where overload code starts.  */\n \n-/* type tables for K and B type compression */\n-static tree *btypelist = NULL;\n-static tree *ktypelist = NULL;\n-static int maxbsize = 0;\n-static int maxksize = 0;\n-\n-/* number of each type seen */\n-static int maxbtype = 0;\n-static int maxktype = 0;\n-\n-/* Array of types seen so far in top-level call to `build_mangled_name'.\n-   Allocated and deallocated by caller.  */\n-static tree *typevec = NULL;\n-static int  typevec_size;\n-\n-/* Number of types interned by `build_mangled_name' so far.  */\n-static int maxtype = 0;\n-\n /* Nonzero if we should not try folding parameter types.  */\n static int nofold;\n \n@@ -205,10 +208,8 @@ start_squangling ()\n       nofold = 0;\n       maxbtype = 0;\n       maxktype = 0;\n-      maxbsize = 50;\n-      maxksize = 50;\n-      btypelist = (tree *)xmalloc (sizeof (tree) * maxbsize);\n-      ktypelist = (tree *)xmalloc (sizeof (tree) * maxksize);\n+      VARRAY_TREE_INIT (btypelist, 50, \"btypelist\");\n+      VARRAY_TREE_INIT (ktypelist, 50, \"ktypelist\");\n     }\n }\n \n@@ -217,16 +218,10 @@ end_squangling ()\n {\n   if (flag_do_squangling)\n     {\n-      if (ktypelist)\n-        free (ktypelist);\n-      if (btypelist)\n-        free (btypelist);\n-      maxbsize = 0;\n-      maxksize = 0;\n+      VARRAY_FREE (ktypelist);\n+      VARRAY_FREE (btypelist);\n       maxbtype = 0;\n       maxktype = 0;\n-      ktypelist = NULL;\n-      btypelist = NULL;\n     }\n }\n \n@@ -303,15 +298,15 @@ static __inline int\n old_backref_index (type)\n      tree type;\n {\n-  int tindex = 0;\n+  size_t tindex;\n \n   if (! is_back_referenceable_type (type))\n     return -1;\n \n   /* The entry for this parm is at maxtype-1, so don't look there for\n      something to repeat.  */\n   for (tindex = 0; tindex < maxtype - 1; ++tindex)\n-    if (same_type_p (typevec[tindex], type))\n+    if (same_type_p (VARRAY_TREE (typevec, tindex), type))\n       break;\n \n   if (tindex == maxtype - 1)\n@@ -425,7 +420,7 @@ check_ktype (node, add)\n      tree node;\n      int add;\n {\n-  int x;\n+  size_t x;\n   tree localnode = node;\n \n   if (ktypelist == NULL)\n@@ -434,20 +429,19 @@ check_ktype (node, add)\n   if (TREE_CODE (node) == TYPE_DECL)\n     localnode = TREE_TYPE (node);\n \n-  for (x=0; x < maxktype; x++)\n+  for (x = 0; x < maxktype; x++)\n     {\n-      if (same_type_p (localnode, ktypelist[x]))\n+      if (same_type_p (localnode, VARRAY_TREE (ktypelist, x)))\n         return x;\n     }\n   /* Didn't find it, so add it here.  */\n   if (add)\n     {\n-      if (maxksize <= maxktype)\n-        {\n-          maxksize = maxksize* 3 / 2;\n-          ktypelist = (tree *)xrealloc (ktypelist, sizeof (tree) * maxksize);\n-        }\n-      ktypelist[maxktype++] = localnode;\n+      if (VARRAY_SIZE (ktypelist) <= maxktype)\n+\tVARRAY_GROW (ktypelist, \n+\t\t     VARRAY_SIZE (ktypelist) * 3 / 2);\n+      VARRAY_TREE (ktypelist, maxktype) = localnode;\n+      maxktype++;\n     }\n   return -1;\n }\n@@ -1166,8 +1160,9 @@ build_mangled_name (parmtypes, begin, end)\n \t  if (old_style_repeats)\n \t    {\n \t      /* Every argument gets counted.  */\n-\t      my_friendly_assert (maxtype < typevec_size, 387);\n-\t      typevec[maxtype++] = parmtype;\n+\t      my_friendly_assert (maxtype < VARRAY_SIZE (typevec), 387);\n+\t      VARRAY_TREE (typevec, maxtype) = parmtype;\n+\t      maxtype++;\n \t    }\n \n \t  if (last_type && same_type_p (parmtype, last_type))\n@@ -1261,7 +1256,7 @@ static int\n check_btype (type) \n      tree type;\n {\n-  int x;\n+  size_t x;\n \n   if (btypelist == NULL)\n     return 0;\n@@ -1270,7 +1265,7 @@ check_btype (type)\n     return 0;\n \n   for (x = 0; x < maxbtype; x++) \n-    if (same_type_p (type, btypelist[x]))\n+    if (same_type_p (type, VARRAY_TREE (btypelist, x)))\n       {\n \tOB_PUTC ('B');\n \ticat (x);\n@@ -1279,15 +1274,14 @@ check_btype (type)\n \treturn 1 ;\n       }\n \n-  if (maxbsize <= maxbtype) \n-    {\n-      /* Enlarge the table.  */\n-      maxbsize = maxbsize * 3 / 2;\n-      btypelist = (tree *)xrealloc (btypelist, sizeof (tree) * maxbsize); \n-    }\n-  \n+  if (VARRAY_SIZE (btypelist) <= maxbtype) \n+    /* Enlarge the table.  */\n+    VARRAY_GROW (btypelist,\n+\t\t VARRAY_SIZE (btypelist) * 3 / 2);\n+\n   /* Register the TYPE.  */\n-  btypelist[maxbtype++] = type;\n+  VARRAY_TREE (btypelist, maxbtype) = type;\n+  maxbtype++;\n \n   return 0;\n }\n@@ -1638,12 +1632,12 @@ build_decl_overload_real (dname, parms, ret_type, tparms, targs,\n       if (!flag_do_squangling)\n         {\n \t  /* Allocate typevec array.  */\n+\t  size_t typevec_size = list_length (parms);\n           maxtype = 0;\n-\t  typevec_size = list_length (parms);\n \t  if (!for_method && current_namespace != global_namespace)\n \t    /* The namespace of a global function needs one slot.  */\n \t    typevec_size++;\n-          typevec = (tree *)alloca (typevec_size * sizeof (tree));\n+\t  VARRAY_TREE_INIT (typevec, typevec_size, \"typevec\");\n         }\n       nofold = 0;\n \n@@ -1655,8 +1649,9 @@ build_decl_overload_real (dname, parms, ret_type, tparms, targs,\n \n           if (!flag_do_squangling) \n \t    {\n-\t      my_friendly_assert (maxtype < typevec_size, 387);\n-\t      typevec[maxtype++] = this_type;\n+\t      my_friendly_assert (maxtype < VARRAY_SIZE (typevec), 387);\n+\t      VARRAY_TREE (typevec, maxtype) = this_type;\n+\t      maxtype++;\n \t    }\n \n \t  if (TREE_CHAIN (parms))\n@@ -1671,15 +1666,16 @@ build_decl_overload_real (dname, parms, ret_type, tparms, targs,\n \t  if (current_namespace != global_namespace\n \t      && !flag_do_squangling)\n \t    {\n-\t      my_friendly_assert (maxtype < typevec_size, 387);\n-\t      typevec[maxtype++] = current_namespace;\n+\t      my_friendly_assert (maxtype < VARRAY_SIZE (typevec), 387);\n+\t      VARRAY_TREE (typevec, maxtype) = current_namespace;\n+\t      maxtype++;\n \t    }\n \t  build_mangled_name (parms, 0, 0);\n \t}\n \n       if (!flag_do_squangling)\n \t/* Deallocate typevec array.  */\n-\ttypevec = NULL;\n+\tVARRAY_FREE (typevec);\n     }\n \n   if (ret_type != NULL_TREE && for_method != 2)"}, {"sha": "01d4f1f078d4cd43ed503ec2bb25572e71545829", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cd64686e8f8f61a283ea72613b2c4acac4cf985/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cd64686e8f8f61a283ea72613b2c4acac4cf985/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=9cd64686e8f8f61a283ea72613b2c4acac4cf985", "patch": "@@ -40,8 +40,8 @@ Boston, MA 02111-1307, USA.  */\n #include \"except.h\"\n #include \"toplev.h\"\n #include \"rtl.h\"\n-#include \"varray.h\"\n #include \"defaults.h\"\n+#include \"ggc.h\"\n \n /* The type of functions taking a tree, and some additional data, and\n    returning an int.  */\n@@ -52,9 +52,6 @@ extern struct obstack permanent_obstack;\n extern int lineno;\n extern char *input_filename;\n \n-tree current_template_parms;\n-HOST_WIDE_INT processing_template_decl;\n-\n /* The PENDING_TEMPLATES is a TREE_LIST of templates whose\n    instantiations have been deferred, either because their definitions\n    were not yet available, or because we were putting off doing the\n@@ -68,8 +65,6 @@ static tree *template_tail = &pending_templates;\n static tree maybe_templates;\n static tree *maybe_template_tail = &maybe_templates;\n \n-int processing_specialization;\n-int processing_explicit_instantiation;\n int processing_template_parmlist;\n static int template_header_count;\n \n@@ -224,6 +219,16 @@ static void tsubst_default_arguments PROTO((tree));\n #define TMPL_PARMS_DEPTH(NODE) \\\n   (TREE_INT_CST_HIGH (TREE_PURPOSE (NODE)))\n \n+/* Called once to initialize pt.c.  */\n+\n+void\n+init_pt ()\n+{\n+  ggc_add_tree_root (&pending_templates, 1);\n+  ggc_add_tree_root (&maybe_templates, 1);\n+  ggc_add_tree_root (&saved_trees, 1);\n+}\n+\n /* Do any processing required when DECL (a member template declaration\n    using TEMPLATE_PARAMETERS as its innermost parameter list) is\n    finished.  Returns the TEMPLATE_DECL corresponding to DECL, unless"}, {"sha": "4adcc35eaab3fc2332ee9f28a57f6b55e9055a69", "filename": "gcc/cp/repo.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cd64686e8f8f61a283ea72613b2c4acac4cf985/gcc%2Fcp%2Frepo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cd64686e8f8f61a283ea72613b2c4acac4cf985/gcc%2Fcp%2Frepo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frepo.c?ref=9cd64686e8f8f61a283ea72613b2c4acac4cf985", "patch": "@@ -32,6 +32,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"input.h\"\n #include \"obstack.h\"\n #include \"toplev.h\"\n+#include \"ggc.h\"\n \n static tree repo_get_id PROTO((tree));\n static char *extract_string PROTO((char **));\n@@ -308,6 +309,9 @@ init_repo (filename)\n   if (! flag_use_repository)\n     return;\n \n+  ggc_add_tree_root (&pending_repo, 1);\n+  ggc_add_tree_root (&original_repo, 1);\n+\n   open_repo_file (filename);\n \n   if (repo_file == 0)"}, {"sha": "dc81a3383020c5377bf8f5954bdfa3138a98d82d", "filename": "gcc/cp/search.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cd64686e8f8f61a283ea72613b2c4acac4cf985/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cd64686e8f8f61a283ea72613b2c4acac4cf985/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=9cd64686e8f8f61a283ea72613b2c4acac4cf985", "patch": "@@ -31,7 +31,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"rtl.h\"\n #include \"output.h\"\n #include \"toplev.h\"\n-#include \"varray.h\"\n \n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free free\n@@ -176,8 +175,6 @@ pop_search_level (obstack)\n   return stack;\n }\n \f\n-static tree _vptr_name;\n-\n /* Variables for gathering statistics.  */\n #ifdef GATHER_STATISTICS\n static int n_fields_searched;\n@@ -584,7 +581,7 @@ lookup_field_1 (type, name)\n       field = TREE_CHAIN (field);\n     }\n   /* Not found.  */\n-  if (name == _vptr_name)\n+  if (name == vptr_identifier)\n     {\n       /* Give the user what s/he thinks s/he wants.  */\n       if (TYPE_VIRTUAL_P (type))\n@@ -2792,7 +2789,6 @@ expand_indirect_vtbls_init (binfo, true_exp, decl_ptr)\n \n       if (fixup_insns)\n \t{\n-\t  extern tree in_charge_identifier;\n \t  tree in_charge_node = lookup_name (in_charge_identifier, 0);\n \t  if (! in_charge_node)\n \t    {\n@@ -3140,7 +3136,7 @@ void\n init_search_processing ()\n {\n   gcc_obstack_init (&search_obstack);\n-  _vptr_name = get_identifier (\"_vptr\");\n+  vptr_identifier = get_identifier (\"_vptr\");\n }\n \n void"}]}