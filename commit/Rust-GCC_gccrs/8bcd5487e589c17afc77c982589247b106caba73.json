{"sha": "8bcd5487e589c17afc77c982589247b106caba73", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGJjZDU0ODdlNTg5YzE3YWZjNzdjOTgyNTg5MjQ3YjEwNmNhYmE3Mw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2013-09-27T17:53:46Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2013-09-27T17:53:46Z"}, "message": "reflect: Implement MakeFunc for amd64.\n\nFrom-SVN: r202982", "tree": {"sha": "133857cd0c49e652d0d0f10641c67369221de3f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/133857cd0c49e652d0d0f10641c67369221de3f9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8bcd5487e589c17afc77c982589247b106caba73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8bcd5487e589c17afc77c982589247b106caba73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8bcd5487e589c17afc77c982589247b106caba73", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8bcd5487e589c17afc77c982589247b106caba73/comments", "author": null, "committer": null, "parents": [{"sha": "f6113c278ac0953abf9d8d2bdbed8fcc240cf352", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6113c278ac0953abf9d8d2bdbed8fcc240cf352", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6113c278ac0953abf9d8d2bdbed8fcc240cf352"}], "stats": {"total": 764, "additions": 676, "deletions": 88}, "files": [{"sha": "6d452f4f5cde8004596b03403f717ea251a6bbf1", "filename": "libgo/Makefile.am", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bcd5487e589c17afc77c982589247b106caba73/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bcd5487e589c17afc77c982589247b106caba73/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=8bcd5487e589c17afc77c982589247b106caba73", "patch": "@@ -895,9 +895,21 @@ go_path_files = \\\n \tgo/path/match.go \\\n \tgo/path/path.go\n \n+if LIBGO_IS_X86_64\n+go_reflect_makefunc_file = \\\n+\tgo/reflect/makefuncgo_amd64.go\n+go_reflect_makefunc_s_file = \\\n+\tgo/reflect/makefunc_amd64.S\n+else\n+go_reflect_makefunc_file =\n+go_reflect_makefunc_s_file = \\\n+\tgo/reflect/makefunc_dummy.c\n+endif\n+\n go_reflect_files = \\\n \tgo/reflect/deepequal.go \\\n \tgo/reflect/makefunc.go \\\n+\t$(go_reflect_makefunc_file) \\\n \tgo/reflect/type.go \\\n \tgo/reflect/value.go\n \n@@ -1761,6 +1773,7 @@ libgo_go_objs = \\\n \tos.lo \\\n \tpath.lo \\\n \treflect-go.lo \\\n+\treflect/makefunc.lo \\\n \tregexp.lo \\\n \truntime-go.lo \\\n \tsort.lo \\\n@@ -2147,6 +2160,9 @@ reflect-go.lo: $(go_reflect_files)\n \t$(BUILDPACKAGE)\n reflect/check: $(CHECK_DEPS)\n \t@$(CHECK)\n+reflect/makefunc.lo: $(go_reflect_makefunc_s_file)\n+\t@$(MKDIR_P) reflect\n+\t$(LTCOMPILE) -c -o $@ $<\n .PHONY: reflect/check\n \n @go_include@ regexp.lo.dep"}, {"sha": "b72e8aa559a2eb2305c662169d37b511824fa6c0", "filename": "libgo/Makefile.in", "status": "modified", "additions": 26, "deletions": 11, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bcd5487e589c17afc77c982589247b106caba73/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bcd5487e589c17afc77c982589247b106caba73/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=8bcd5487e589c17afc77c982589247b106caba73", "patch": "@@ -134,17 +134,17 @@ am__DEPENDENCIES_1 =\n am__DEPENDENCIES_2 = bufio.lo bytes.lo bytes/index.lo crypto.lo \\\n \terrors.lo expvar.lo flag.lo fmt.lo hash.lo html.lo image.lo \\\n \tio.lo log.lo math.lo mime.lo net.lo os.lo path.lo \\\n-\treflect-go.lo regexp.lo runtime-go.lo sort.lo strconv.lo \\\n-\tstrings.lo sync.lo syscall.lo syscall/errno.lo \\\n-\tsyscall/signame.lo syscall/wait.lo testing.lo time-go.lo \\\n-\tunicode.lo archive/tar.lo archive/zip.lo compress/bzip2.lo \\\n-\tcompress/flate.lo compress/gzip.lo compress/lzw.lo \\\n-\tcompress/zlib.lo container/heap.lo container/list.lo \\\n-\tcontainer/ring.lo crypto/aes.lo crypto/cipher.lo crypto/des.lo \\\n-\tcrypto/dsa.lo crypto/ecdsa.lo crypto/elliptic.lo \\\n-\tcrypto/hmac.lo crypto/md5.lo crypto/rand.lo crypto/rc4.lo \\\n-\tcrypto/rsa.lo crypto/sha1.lo crypto/sha256.lo crypto/sha512.lo \\\n-\tcrypto/subtle.lo crypto/tls.lo crypto/x509.lo \\\n+\treflect-go.lo reflect/makefunc.lo regexp.lo runtime-go.lo \\\n+\tsort.lo strconv.lo strings.lo sync.lo syscall.lo \\\n+\tsyscall/errno.lo syscall/signame.lo syscall/wait.lo testing.lo \\\n+\ttime-go.lo unicode.lo archive/tar.lo archive/zip.lo \\\n+\tcompress/bzip2.lo compress/flate.lo compress/gzip.lo \\\n+\tcompress/lzw.lo compress/zlib.lo container/heap.lo \\\n+\tcontainer/list.lo container/ring.lo crypto/aes.lo \\\n+\tcrypto/cipher.lo crypto/des.lo crypto/dsa.lo crypto/ecdsa.lo \\\n+\tcrypto/elliptic.lo crypto/hmac.lo crypto/md5.lo crypto/rand.lo \\\n+\tcrypto/rc4.lo crypto/rsa.lo crypto/sha1.lo crypto/sha256.lo \\\n+\tcrypto/sha512.lo crypto/subtle.lo crypto/tls.lo crypto/x509.lo \\\n \tcrypto/x509/pkix.lo database/sql.lo database/sql/driver.lo \\\n \tdebug/dwarf.lo debug/elf.lo debug/gosym.lo debug/macho.lo \\\n \tdebug/pe.lo encoding/ascii85.lo encoding/asn1.lo \\\n@@ -1087,9 +1087,20 @@ go_path_files = \\\n \tgo/path/match.go \\\n \tgo/path/path.go\n \n+@LIBGO_IS_X86_64_FALSE@go_reflect_makefunc_file = \n+@LIBGO_IS_X86_64_TRUE@go_reflect_makefunc_file = \\\n+@LIBGO_IS_X86_64_TRUE@\tgo/reflect/makefuncgo_amd64.go\n+\n+@LIBGO_IS_X86_64_FALSE@go_reflect_makefunc_s_file = \\\n+@LIBGO_IS_X86_64_FALSE@\tgo/reflect/makefunc_dummy.c\n+\n+@LIBGO_IS_X86_64_TRUE@go_reflect_makefunc_s_file = \\\n+@LIBGO_IS_X86_64_TRUE@\tgo/reflect/makefunc_amd64.S\n+\n go_reflect_files = \\\n \tgo/reflect/deepequal.go \\\n \tgo/reflect/makefunc.go \\\n+\t$(go_reflect_makefunc_file) \\\n \tgo/reflect/type.go \\\n \tgo/reflect/value.go\n \n@@ -1846,6 +1857,7 @@ libgo_go_objs = \\\n \tos.lo \\\n \tpath.lo \\\n \treflect-go.lo \\\n+\treflect/makefunc.lo \\\n \tregexp.lo \\\n \truntime-go.lo \\\n \tsort.lo \\\n@@ -4499,6 +4511,9 @@ reflect-go.lo: $(go_reflect_files)\n \t$(BUILDPACKAGE)\n reflect/check: $(CHECK_DEPS)\n \t@$(CHECK)\n+reflect/makefunc.lo: $(go_reflect_makefunc_s_file)\n+\t@$(MKDIR_P) reflect\n+\t$(LTCOMPILE) -c -o $@ $<\n .PHONY: reflect/check\n \n @go_include@ regexp.lo.dep"}, {"sha": "fb25130e835701404deeb74d725d924fc4c6f8af", "filename": "libgo/go/reflect/all_test.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bcd5487e589c17afc77c982589247b106caba73/libgo%2Fgo%2Freflect%2Fall_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bcd5487e589c17afc77c982589247b106caba73/libgo%2Fgo%2Freflect%2Fall_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fall_test.go?ref=8bcd5487e589c17afc77c982589247b106caba73", "patch": "@@ -1430,11 +1430,13 @@ func TestFunc(t *testing.T) {\n \t}\n }\n \n-/*\n-\n-Not yet implemented for gccgo.\n-\n func TestMakeFunc(t *testing.T) {\n+\tswitch runtime.GOARCH {\n+\tcase \"amd64\":\n+\tdefault:\n+\t\tt.Skip(\"MakeFunc not implemented for \" + runtime.GOARCH)\n+\t}\n+\n \tf := dummy\n \tfv := MakeFunc(TypeOf(f), func(in []Value) []Value { return in })\n \tValueOf(&f).Elem().Set(fv)\n@@ -1452,8 +1454,6 @@ func TestMakeFunc(t *testing.T) {\n \t}\n }\n \n-*/\n-\n type Point struct {\n \tx, y int\n }"}, {"sha": "7253a6398a640492c17ef24361cce4253f3f9aca", "filename": "libgo/go/reflect/makefunc.go", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bcd5487e589c17afc77c982589247b106caba73/libgo%2Fgo%2Freflect%2Fmakefunc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bcd5487e589c17afc77c982589247b106caba73/libgo%2Fgo%2Freflect%2Fmakefunc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fmakefunc.go?ref=8bcd5487e589c17afc77c982589247b106caba73", "patch": "@@ -7,6 +7,7 @@\n package reflect\n \n import (\n+\t\"runtime\"\n \t\"unsafe\"\n )\n \n@@ -45,14 +46,33 @@ func MakeFunc(typ Type, fn func(args []Value) (results []Value)) Value {\n \t\tpanic(\"reflect: call of MakeFunc with non-Func type\")\n \t}\n \n+\tswitch runtime.GOARCH {\n+\tcase \"amd64\":\n+\tdefault:\n+\t\tpanic(\"reflect.MakeFunc not implemented for \" + runtime.GOARCH)\n+\t}\n+\n \tt := typ.common()\n \tftyp := (*funcType)(unsafe.Pointer(t))\n \n-\t_, _ = t, ftyp\n+\t// Indirect Go func value (dummy) to obtain\n+\t// actual code address. (A Go func value is a pointer\n+\t// to a C function pointer. http://golang.org/s/go11func.)\n+\tdummy := makeFuncStub\n+\tcode := **(**uintptr)(unsafe.Pointer(&dummy))\n \n-\tpanic(\"reflect MakeFunc not implemented\")\n+\timpl := &makeFuncImpl{code: code, typ: ftyp, fn: fn}\n+\n+\treturn Value{t, unsafe.Pointer(impl), flag(Func) << flagKindShift}\n }\n \n+// makeFuncStub is an assembly function that is the code half of\n+// the function returned from MakeFunc. It expects a *callReflectFunc\n+// as its context register, and its job is to invoke callReflect(ctxt, frame)\n+// where ctxt is the context register and frame is a pointer to the first\n+// word in the passed-in argument frame.\n+func makeFuncStub()\n+\n // makeMethodValue converts v from the rcvr+method index representation\n // of a method value to an actual method func value, which is\n // basically the receiver value with a special bit set, into a true"}, {"sha": "319aa18505c36e7b201010279a35764ce2fd9495", "filename": "libgo/go/reflect/makefunc_amd64.S", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bcd5487e589c17afc77c982589247b106caba73/libgo%2Fgo%2Freflect%2Fmakefunc_amd64.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bcd5487e589c17afc77c982589247b106caba73/libgo%2Fgo%2Freflect%2Fmakefunc_amd64.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fmakefunc_amd64.S?ref=8bcd5487e589c17afc77c982589247b106caba73", "patch": "@@ -0,0 +1,107 @@\n+# Copyright 2013 The Go Authors. All rights reserved.\n+# Use of this source code is governed by a BSD-style\n+# license that can be found in the LICENSE file.\n+\n+# MakeFunc amd64 assembly code.\n+\n+\t.global\treflect.makeFuncStub\n+\n+#ifdef __ELF__\n+\t.type\treflect.makeFuncStub,@function\n+#endif\n+\n+reflect.makeFuncStub:\n+\t.cfi_startproc\n+\n+\t# Store all the parameter registers in a struct that looks\n+\t# like:\n+\t# struct {\n+\t#   rax uint64\t\t// 0x0\n+\t#   rdi uint64\t\t// 0x8\n+\t#   rsi uint64\t\t// 0x10\n+\t#   rdx uint64\t\t// 0x18\n+\t#   rcx uint64\t\t// 0x20\n+\t#   r8 uint64\t\t// 0x28\n+\t#   r9 uint64\t\t// 0x30\n+\t#   rsp uint64\t\t// 0x38 Pointer to arguments on stack.\n+\t#   xmm0 [2]uint64\t// 0x40\n+\t#   xmm1 [2]uint64\t// 0x50\n+\t#   xmm2 [2]uint64\t// 0x60\n+\t#   xmm3 [2]uint64\t// 0x70\n+\t#   xmm4 [2]uint64\t// 0x80\n+\t#   xmm5 [2]uint64\t// 0x90\n+\t#   xmm6 [2]uint64\t// 0xa0\n+\t#   xmm7 [2]uint64\t// 0xb0\n+\t# };\n+\n+\tpushq\t%rbp\n+\t.cfi_def_cfa_offset 16\n+\t.cfi_offset %rbp, -16\n+\tmovq\t%rsp, %rbp\n+\t.cfi_def_cfa_register %rbp\n+\n+\tsubq\t$0xc0, %rsp\t\t# Space for struct on stack.\n+\n+\tmovq\t%rax, 0x0(%rsp)\n+\tmovq\t%rdi, 0x8(%rsp)\n+\tmovq\t%rsi, 0x10(%rsp)\n+\tmovq\t%rdx, 0x18(%rsp)\n+\tmovq\t%rcx, 0x20(%rsp)\n+\tmovq\t%r8, 0x28(%rsp)\n+\tmovq\t%r9, 0x30(%rsp)\n+\tleaq\t16(%rbp), %rax\n+\tmovq\t%rax, 0x38(%rsp)\n+\tmovdqa\t%xmm0, 0x40(%rsp)\n+\tmovdqa\t%xmm1, 0x50(%rsp)\n+\tmovdqa\t%xmm2, 0x60(%rsp)\n+\tmovdqa\t%xmm3, 0x70(%rsp)\n+\tmovdqa\t%xmm4, 0x80(%rsp)\n+\tmovdqa\t%xmm5, 0x90(%rsp)\n+\tmovdqa\t%xmm6, 0xa0(%rsp)\n+\tmovdqa\t%xmm7, 0xb0(%rsp)\n+\n+\t# Get function type.\n+#ifdef __PIC__\n+\tcall\t__go_get_closure@PLT\n+#else\n+\tcall\t__go_get_closure\n+#endif\n+\tmovq\t%rax, %rsi\n+\n+\tmovq\t%rsp, %rdi\n+\n+#ifdef __PIC__\n+\tcall\treflect.MakeFuncStubGo@PLT\n+#else\n+\tcall\treflect.MakeFuncStubGo\n+#endif\n+\n+\t# The structure will be updated with any return values.  Load\n+\t# all possible return registers before returning to the caller.\n+\n+\tmovq\t0x0(%rsp), %rax\n+\tmovq\t0x18(%rsp), %rdx\n+\tmovq\t0x8(%rsp), %rdi\n+\tmovq\t0x10(%rsp), %rsi\n+\tmovdqa\t0x40(%rsp), %xmm0\n+\tmovdqa\t0x50(%rsp), %xmm1\n+\n+\t# long double values are returned on the floating point stack,\n+\t# but we don't worry about that since Go doesn't have a long\n+\t# double type.\n+\n+\tleave\n+\t.cfi_def_cfa %rsp, 8\n+\n+\tret\n+\n+\t.cfi_endproc\n+#ifdef __ELF__\n+\t.size\treflect.makeFuncStub, . - reflect.makeFuncStub\n+#endif\n+\n+#ifdef __ELF__\n+\t.section\t.note.GNU-stack,\"\",@progbits\n+\t.section\t.note.GNU-split-stack,\"\",@progbits\n+\t.section\t.note.GNU-no-split-stack,\"\",@progbits\n+#endif"}, {"sha": "aba48df3eb88974e93ea24864fd36aea7219004c", "filename": "libgo/go/reflect/makefunc_dummy.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bcd5487e589c17afc77c982589247b106caba73/libgo%2Fgo%2Freflect%2Fmakefunc_dummy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bcd5487e589c17afc77c982589247b106caba73/libgo%2Fgo%2Freflect%2Fmakefunc_dummy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fmakefunc_dummy.c?ref=8bcd5487e589c17afc77c982589247b106caba73", "patch": "@@ -0,0 +1,12 @@\n+// Copyright 2013 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build !amd64\n+\n+// Dummy function for processors without makefunc support.\n+\n+void makeFuncStub () __asm__ (\"reflect.makeFuncStub\");\n+void makeFuncStub ()\n+{\n+}"}, {"sha": "bdc655605061203f1ee7793a74c369379b4c7d91", "filename": "libgo/go/reflect/makefuncgo_amd64.go", "status": "added", "additions": 487, "deletions": 0, "changes": 487, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bcd5487e589c17afc77c982589247b106caba73/libgo%2Fgo%2Freflect%2Fmakefuncgo_amd64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bcd5487e589c17afc77c982589247b106caba73/libgo%2Fgo%2Freflect%2Fmakefuncgo_amd64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fmakefuncgo_amd64.go?ref=8bcd5487e589c17afc77c982589247b106caba73", "patch": "@@ -0,0 +1,487 @@\n+// Copyright 2013 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// MakeFunc amd64 implementation.\n+\n+package reflect\n+\n+import \"unsafe\"\n+\n+// The assembler stub will pass a pointer to this structure.\n+// This will come in holding all the registers that might hold\n+// function parameters.  On return we will set the registers that\n+// might hold result values.\n+type amd64Regs struct {\n+\trax  uint64\n+\trdi  uint64\n+\trsi  uint64\n+\trdx  uint64\n+\trcx  uint64\n+\tr8   uint64\n+\tr9   uint64\n+\trsp  uint64\n+\txmm0 [2]uint64\n+\txmm1 [2]uint64\n+\txmm2 [2]uint64\n+\txmm3 [2]uint64\n+\txmm4 [2]uint64\n+\txmm5 [2]uint64\n+\txmm6 [2]uint64\n+\txmm7 [2]uint64\n+}\n+\n+// Argument classifications.  The amd64 ELF ABI uses several more, but\n+// these are the only ones that arise for Go types.\n+type amd64Class int\n+\n+const (\n+\tamd64Integer amd64Class = iota\n+\tamd64SSE\n+\tamd64NoClass\n+\tamd64Memory\n+)\n+\n+// amd64Classify returns the one or two register classes needed to\n+// pass the value of type.  Go types never need more than two\n+// registers.  amd64Memory means the value is stored in memory.\n+// amd64NoClass means the register is not used.\n+func amd64Classify(typ *rtype) (amd64Class, amd64Class) {\n+\tswitch typ.Kind() {\n+\tdefault:\n+\t\tpanic(\"internal error--unknown kind in amd64Classify\")\n+\n+\tcase Bool, Int, Int8, Int16, Int32, Int64,\n+\t\tUint, Uint8, Uint16, Uint32, Uint64,\n+\t\tUintptr, Chan, Func, Map, Ptr, UnsafePointer:\n+\n+\t\treturn amd64Integer, amd64NoClass\n+\n+\tcase Float32, Float64, Complex64:\n+\t\treturn amd64SSE, amd64NoClass\n+\n+\tcase Complex128:\n+\t\treturn amd64SSE, amd64SSE\n+\n+\tcase Array:\n+\t\tif typ.size == 0 {\n+\t\t\treturn amd64NoClass, amd64NoClass\n+\t\t} else if typ.size > 16 {\n+\t\t\treturn amd64Memory, amd64NoClass\n+\t\t}\n+\t\tatyp := (*arrayType)(unsafe.Pointer(typ))\n+\t\teclass1, eclass2 := amd64Classify(atyp.elem)\n+\t\tif eclass1 == amd64Memory {\n+\t\t\treturn amd64Memory, amd64NoClass\n+\t\t}\n+\t\tif eclass2 == amd64NoClass && typ.size > 8 {\n+\t\t\teclass2 = eclass1\n+\t\t}\n+\t\treturn eclass1, eclass2\n+\n+\tcase Interface:\n+\t\treturn amd64Integer, amd64Integer\n+\n+\tcase Slice:\n+\t\treturn amd64Memory, amd64NoClass\n+\n+\tcase String:\n+\t\treturn amd64Integer, amd64Integer\n+\n+\tcase Struct:\n+\t\tif typ.size == 0 {\n+\t\t\treturn amd64NoClass, amd64NoClass\n+\t\t} else if typ.size > 16 {\n+\t\t\treturn amd64Memory, amd64NoClass\n+\t\t}\n+\t\tvar first, second amd64Class\n+\t\tf := amd64NoClass\n+\t\tonFirst := true\n+\t\tstyp := (*structType)(unsafe.Pointer(typ))\n+\t\tfor _, field := range styp.fields {\n+\t\t\tif onFirst && field.offset >= 8 {\n+\t\t\t\tfirst = f\n+\t\t\t\tf = amd64NoClass\n+\t\t\t\tonFirst = false\n+\t\t\t}\n+\t\t\tfclass1, fclass2 := amd64Classify(field.typ)\n+\t\t\tf = amd64MergeClasses(f, fclass1)\n+\t\t\tif fclass2 != amd64NoClass {\n+\t\t\t\tif !onFirst {\n+\t\t\t\t\tpanic(\"amd64Classify inconsistent\")\n+\t\t\t\t}\n+\t\t\t\tfirst = f\n+\t\t\t\tf = fclass2\n+\t\t\t\tonFirst = false\n+\t\t\t}\n+\t\t}\n+\t\tif onFirst {\n+\t\t\tfirst = f\n+\t\t\tsecond = amd64NoClass\n+\t\t} else {\n+\t\t\tsecond = f\n+\t\t}\n+\t\tif first == amd64Memory || second == amd64Memory {\n+\t\t\treturn amd64Memory, amd64NoClass\n+\t\t}\n+\t\treturn first, second\n+\t}\n+}\n+\n+// amd64MergeClasses merges two register classes as described in the\n+// amd64 ELF ABI.\n+func amd64MergeClasses(c1, c2 amd64Class) amd64Class {\n+\tswitch {\n+\tcase c1 == c2:\n+\t\treturn c1\n+\tcase c1 == amd64NoClass:\n+\t\treturn c2\n+\tcase c2 == amd64NoClass:\n+\t\treturn c1\n+\tcase c1 == amd64Memory || c2 == amd64Memory:\n+\t\treturn amd64Memory\n+\tcase c1 == amd64Integer || c2 == amd64Integer:\n+\t\treturn amd64Integer\n+\tdefault:\n+\t\treturn amd64SSE\n+\t}\n+}\n+\n+// MakeFuncStubGo implements the amd64 calling convention for\n+// MakeFunc.  This should not be called.  It is exported so that\n+// assembly code can call it.\n+\n+func MakeFuncStubGo(regs *amd64Regs, c *makeFuncImpl) {\n+\tftyp := c.typ\n+\n+\t// See if the result requires a struct.  If it does, the first\n+\t// parameter is a pointer to the struct.\n+\tvar ret1, ret2 amd64Class\n+\tswitch len(ftyp.out) {\n+\tcase 0:\n+\t\tret1, ret2 = amd64NoClass, amd64NoClass\n+\tcase 1:\n+\t\tret1, ret2 = amd64Classify(ftyp.out[0])\n+\tdefault:\n+\t\toff := uintptr(0)\n+\t\tf := amd64NoClass\n+\t\tonFirst := true\n+\t\tfor _, rt := range ftyp.out {\n+\t\t\toff = align(off, uintptr(rt.fieldAlign))\n+\n+\t\t\tif onFirst && off >= 8 {\n+\t\t\t\tret1 = f\n+\t\t\t\tf = amd64NoClass\n+\t\t\t\tonFirst = false\n+\t\t\t}\n+\n+\t\t\toff += rt.size\n+\t\t\tif off > 16 {\n+\t\t\t\tbreak\n+\t\t\t}\n+\n+\t\t\tfclass1, fclass2 := amd64Classify(rt)\n+\t\t\tf = amd64MergeClasses(f, fclass1)\n+\t\t\tif fclass2 != amd64NoClass {\n+\t\t\t\tif !onFirst {\n+\t\t\t\t\tpanic(\"amd64Classify inconsistent\")\n+\t\t\t\t}\n+\t\t\t\tret1 = f\n+\t\t\t\tf = fclass2\n+\t\t\t\tonFirst = false\n+\t\t\t}\n+\t\t}\n+\t\tif off > 16 {\n+\t\t\tret1, ret2 = amd64Memory, amd64NoClass\n+\t\t} else {\n+\t\t\tif onFirst {\n+\t\t\t\tret1, ret2 = f, amd64NoClass\n+\t\t\t} else {\n+\t\t\t\tret2 = f\n+\t\t\t}\n+\t\t}\n+\t\tif ret1 == amd64Memory || ret2 == amd64Memory {\n+\t\t\tret1, ret2 = amd64Memory, amd64NoClass\n+\t\t}\n+\t}\n+\n+\tin := make([]Value, 0, len(ftyp.in))\n+\tintreg := 0\n+\tssereg := 0\n+\tap := uintptr(regs.rsp)\n+\n+\tmaxIntregs := 6 // When we support Windows, this would be 4.\n+\tmaxSSEregs := 8\n+\n+\tif ret1 == amd64Memory {\n+\t\t// We are returning a value in memory, which means\n+\t\t// that the first argument is a hidden parameter\n+\t\t// pointing to that return area.\n+\t\tintreg++\n+\t}\n+\n+argloop:\n+\tfor _, rt := range ftyp.in {\n+\t\tc1, c2 := amd64Classify(rt)\n+\n+\t\tfl := flag(rt.Kind()) << flagKindShift\n+\t\tif c2 == amd64NoClass {\n+\n+\t\t\t// Argument is passed in a single register or\n+\t\t\t// in memory.\n+\n+\t\t\tswitch c1 {\n+\t\t\tcase amd64NoClass:\n+\t\t\t\tv := Value{rt, nil, fl | flagIndir}\n+\t\t\t\tin = append(in, v)\n+\t\t\t\tcontinue argloop\n+\t\t\tcase amd64Integer:\n+\t\t\t\tif intreg < maxIntregs {\n+\t\t\t\t\treg := amd64IntregVal(regs, intreg)\n+\t\t\t\t\tiw := unsafe.Pointer(reg)\n+\t\t\t\t\tif k := rt.Kind(); k != Ptr && k != UnsafePointer {\n+\t\t\t\t\t\tiw = unsafe.Pointer(&reg)\n+\t\t\t\t\t\tfl |= flagIndir\n+\t\t\t\t\t}\n+\t\t\t\t\tv := Value{rt, iw, fl}\n+\t\t\t\t\tin = append(in, v)\n+\t\t\t\t\tintreg++\n+\t\t\t\t\tcontinue argloop\n+\t\t\t\t}\n+\t\t\tcase amd64SSE:\n+\t\t\t\tif ssereg < maxSSEregs {\n+\t\t\t\t\treg := amd64SSEregVal(regs, ssereg)\n+\t\t\t\t\tv := Value{rt, unsafe.Pointer(&reg), fl | flagIndir}\n+\t\t\t\t\tin = append(in, v)\n+\t\t\t\t\tssereg++\n+\t\t\t\t\tcontinue argloop\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tin, ap = amd64Memarg(in, ap, rt)\n+\t\t\tcontinue argloop\n+\t\t}\n+\n+\t\t// Argument is passed in two registers.\n+\n+\t\tnintregs := 0\n+\t\tnsseregs := 0\n+\t\tswitch c1 {\n+\t\tcase amd64Integer:\n+\t\t\tnintregs++\n+\t\tcase amd64SSE:\n+\t\t\tnsseregs++\n+\t\tdefault:\n+\t\t\tpanic(\"inconsistent\")\n+\t\t}\n+\t\tswitch c2 {\n+\t\tcase amd64Integer:\n+\t\t\tnintregs++\n+\t\tcase amd64SSE:\n+\t\t\tnsseregs++\n+\t\tdefault:\n+\t\t\tpanic(\"inconsistent\")\n+\t\t}\n+\n+\t\t// If the whole argument does not fit in registers, it\n+\t\t// is passed in memory.\n+\n+\t\tif intreg+nintregs > maxIntregs || ssereg+nsseregs > maxSSEregs {\n+\t\t\tin, ap = amd64Memarg(in, ap, rt)\n+\t\t\tcontinue argloop\n+\t\t}\n+\n+\t\tvar word1, word2 uintptr\n+\t\tswitch c1 {\n+\t\tcase amd64Integer:\n+\t\t\tword1 = amd64IntregVal(regs, intreg)\n+\t\t\tintreg++\n+\t\tcase amd64SSE:\n+\t\t\tword1 = amd64SSEregVal(regs, ssereg)\n+\t\t\tssereg++\n+\t\t}\n+\t\tswitch c2 {\n+\t\tcase amd64Integer:\n+\t\t\tword2 = amd64IntregVal(regs, intreg)\n+\t\t\tintreg++\n+\t\tcase amd64SSE:\n+\t\t\tword2 = amd64SSEregVal(regs, ssereg)\n+\t\t\tssereg++\n+\t\t}\n+\n+\t\tp := unsafe_New(rt)\n+\t\t*(*uintptr)(p) = word1\n+\t\t*(*uintptr)(unsafe.Pointer(uintptr(p) + ptrSize)) = word2\n+\t\tv := Value{rt, p, fl | flagIndir}\n+\t\tin = append(in, v)\n+\t}\n+\n+\t// All the real arguments have been found and turned into\n+\t// Value's.  Call the real function.\n+\n+\tout := c.fn(in)\n+\n+\tif len(out) != len(ftyp.out) {\n+\t\tpanic(\"reflect: wrong return count from function created by MakeFunc\")\n+\t}\n+\n+\tfor i, typ := range ftyp.out {\n+\t\tv := out[i]\n+\t\tif v.typ != typ {\n+\t\t\tpanic(\"reflect: function created by MakeFunc using \" + funcName(c.fn) +\n+\t\t\t\t\" returned wrong type: have \" +\n+\t\t\t\tout[i].typ.String() + \" for \" + typ.String())\n+\t\t}\n+\t\tif v.flag&flagRO != 0 {\n+\t\t\tpanic(\"reflect: function created by MakeFunc using \" + funcName(c.fn) +\n+\t\t\t\t\" returned value obtained from unexported field\")\n+\t\t}\n+\t}\n+\n+\tif ret1 == amd64NoClass {\n+\t\treturn\n+\t}\n+\n+\tif ret1 == amd64Memory {\n+\t\t// The address of the memory area was passed as a\n+\t\t// hidden parameter in %rdi.\n+\t\tptr := unsafe.Pointer(uintptr(regs.rdi))\n+\t\toff := uintptr(0)\n+\t\tfor i, typ := range ftyp.out {\n+\t\t\tv := out[i]\n+\t\t\toff = align(off, uintptr(typ.fieldAlign))\n+\t\t\taddr := unsafe.Pointer(uintptr(ptr) + off)\n+\t\t\tif v.flag&flagIndir == 0 && (v.kind() == Ptr || v.kind() == UnsafePointer) {\n+\t\t\t\tstoreIword(addr, iword(v.val), typ.size)\n+\t\t\t} else {\n+\t\t\t\tmemmove(addr, v.val, typ.size)\n+\t\t\t}\n+\t\t\toff += typ.size\n+\t\t}\n+\t\treturn\n+\t}\n+\n+\tif len(out) == 1 && ret2 == amd64NoClass {\n+\t\tv := out[0]\n+\t\tw := v.iword()\n+\t\tif v.Kind() != Ptr && v.Kind() != UnsafePointer {\n+\t\t\tw = loadIword(unsafe.Pointer(w), v.typ.size)\n+\t\t}\n+\t\tswitch ret1 {\n+\t\tcase amd64Integer:\n+\t\t\tregs.rax = uint64(uintptr(w))\n+\t\tcase amd64SSE:\n+\t\t\tregs.xmm0[0] = uint64(uintptr(w))\n+\t\t\tregs.xmm0[1] = 0\n+\t\tdefault:\n+\t\t\tpanic(\"inconsistency\")\n+\t\t}\n+\t\treturn\n+\t}\n+\n+\tvar buf [2]unsafe.Pointer\n+\tptr := unsafe.Pointer(&buf[0])\n+\toff := uintptr(0)\n+\tfor i, typ := range ftyp.out {\n+\t\tv := out[i]\n+\t\toff = align(off, uintptr(typ.fieldAlign))\n+\t\taddr := unsafe.Pointer(uintptr(ptr) + off)\n+\t\tif v.flag&flagIndir == 0 && (v.kind() == Ptr || v.kind() == UnsafePointer) {\n+\t\t\tstoreIword(addr, iword(v.val), typ.size)\n+\t\t} else {\n+\t\t\tmemmove(addr, v.val, typ.size)\n+\t\t}\n+\t\toff += uintptr(typ.size)\n+\t}\n+\n+\tswitch ret1 {\n+\tcase amd64Integer:\n+\t\tregs.rax = *(*uint64)(unsafe.Pointer(&buf[0]))\n+\tcase amd64SSE:\n+\t\tregs.xmm0[0] = *(*uint64)(unsafe.Pointer(&buf[0]))\n+\t\tregs.xmm0[1] = 0\n+\tdefault:\n+\t\tpanic(\"inconsistency\")\n+\t}\n+\n+\tswitch ret2 {\n+\tcase amd64Integer:\n+\t\treg := *(*uint64)(unsafe.Pointer(&buf[1]))\n+\t\tif ret1 == amd64Integer {\n+\t\t\tregs.rdx = reg\n+\t\t} else {\n+\t\t\tregs.rax = reg\n+\t\t}\n+\tcase amd64SSE:\n+\t\treg := *(*uint64)(unsafe.Pointer(&buf[1]))\n+\t\tif ret1 == amd64Integer {\n+\t\t\tregs.xmm0[0] = reg\n+\t\t\tregs.xmm0[1] = 0\n+\t\t} else {\n+\t\t\tregs.xmm1[0] = reg\n+\t\t\tregs.xmm1[1] = 0\n+\t\t}\n+\tcase amd64NoClass:\n+\tdefault:\n+\t\tpanic(\"inconsistency\")\n+\t}\n+}\n+\n+// The amd64Memarg function adds an argument passed in memory.\n+func amd64Memarg(in []Value, ap uintptr, rt *rtype) ([]Value, uintptr) {\n+\tap = align(ap, ptrSize)\n+\tap = align(ap, uintptr(rt.align))\n+\tp := Value{rt, unsafe.Pointer(ap), flag(rt.Kind()<<flagKindShift) | flagIndir}\n+\tin = append(in, p)\n+\tap += rt.size\n+\treturn in, ap\n+}\n+\n+// The amd64IntregVal function returns the value of integer register i.\n+func amd64IntregVal(regs *amd64Regs, i int) uintptr {\n+\tvar r uint64\n+\tswitch i {\n+\tcase 0:\n+\t\tr = regs.rdi\n+\tcase 1:\n+\t\tr = regs.rsi\n+\tcase 2:\n+\t\tr = regs.rdx\n+\tcase 3:\n+\t\tr = regs.rcx\n+\tcase 4:\n+\t\tr = regs.r8\n+\tcase 5:\n+\t\tr = regs.r9\n+\tdefault:\n+\t\tpanic(\"amd64IntregVal: bad index\")\n+\t}\n+\treturn uintptr(r)\n+}\n+\n+// The amd64SSEregVal function returns the value of SSE register i.\n+// Note that although SSE registers can hold two uinptr's, for the\n+// types we use in Go we only ever use the least significant one.  The\n+// most significant one would only be used for 128 bit types.\n+func amd64SSEregVal(regs *amd64Regs, i int) uintptr {\n+\tvar r uint64\n+\tswitch i {\n+\tcase 0:\n+\t\tr = regs.xmm0[0]\n+\tcase 1:\n+\t\tr = regs.xmm1[0]\n+\tcase 2:\n+\t\tr = regs.xmm2[0]\n+\tcase 3:\n+\t\tr = regs.xmm3[0]\n+\tcase 4:\n+\t\tr = regs.xmm4[0]\n+\tcase 5:\n+\t\tr = regs.xmm5[0]\n+\tcase 6:\n+\t\tr = regs.xmm6[0]\n+\tcase 7:\n+\t\tr = regs.xmm7[0]\n+\t}\n+\treturn uintptr(r)\n+}"}, {"sha": "9901ed6a4c6eb3fcb489299cbcb84528e1b9a1da", "filename": "libgo/go/reflect/value.go", "status": "modified", "additions": 0, "deletions": 69, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bcd5487e589c17afc77c982589247b106caba73/libgo%2Fgo%2Freflect%2Fvalue.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bcd5487e589c17afc77c982589247b106caba73/libgo%2Fgo%2Freflect%2Fvalue.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fvalue.go?ref=8bcd5487e589c17afc77c982589247b106caba73", "patch": "@@ -509,75 +509,6 @@ func isMethod(t *rtype) bool {\n \treturn params > 2\n }\n \n-// callReflect is the call implementation used by a function\n-// returned by MakeFunc. In many ways it is the opposite of the\n-// method Value.call above. The method above converts a call using Values\n-// into a call of a function with a concrete argument frame, while\n-// callReflect converts a call of a function with a concrete argument\n-// frame into a call using Values.\n-// It is in this file so that it can be next to the call method above.\n-// The remainder of the MakeFunc implementation is in makefunc.go.\n-func callReflect(ctxt *makeFuncImpl, frame unsafe.Pointer) {\n-\tftyp := ctxt.typ\n-\tf := ctxt.fn\n-\n-\t// Copy argument frame into Values.\n-\tptr := frame\n-\toff := uintptr(0)\n-\tin := make([]Value, 0, len(ftyp.in))\n-\tfor _, arg := range ftyp.in {\n-\t\ttyp := arg\n-\t\toff += -off & uintptr(typ.align-1)\n-\t\tv := Value{typ, nil, flag(typ.Kind()) << flagKindShift}\n-\t\tif typ.size <= ptrSize {\n-\t\t\t// value fits in word.\n-\t\t\tv.val = unsafe.Pointer(loadIword(unsafe.Pointer(uintptr(ptr)+off), typ.size))\n-\t\t} else {\n-\t\t\t// value does not fit in word.\n-\t\t\t// Must make a copy, because f might keep a reference to it,\n-\t\t\t// and we cannot let f keep a reference to the stack frame\n-\t\t\t// after this function returns, not even a read-only reference.\n-\t\t\tv.val = unsafe_New(typ)\n-\t\t\tmemmove(v.val, unsafe.Pointer(uintptr(ptr)+off), typ.size)\n-\t\t\tv.flag |= flagIndir\n-\t\t}\n-\t\tin = append(in, v)\n-\t\toff += typ.size\n-\t}\n-\n-\t// Call underlying function.\n-\tout := f(in)\n-\tif len(out) != len(ftyp.out) {\n-\t\tpanic(\"reflect: wrong return count from function created by MakeFunc\")\n-\t}\n-\n-\t// Copy results back into argument frame.\n-\tif len(ftyp.out) > 0 {\n-\t\toff += -off & (ptrSize - 1)\n-\t\tfor i, arg := range ftyp.out {\n-\t\t\ttyp := arg\n-\t\t\tv := out[i]\n-\t\t\tif v.typ != typ {\n-\t\t\t\tpanic(\"reflect: function created by MakeFunc using \" + funcName(f) +\n-\t\t\t\t\t\" returned wrong type: have \" +\n-\t\t\t\t\tout[i].typ.String() + \" for \" + typ.String())\n-\t\t\t}\n-\t\t\tif v.flag&flagRO != 0 {\n-\t\t\t\tpanic(\"reflect: function created by MakeFunc using \" + funcName(f) +\n-\t\t\t\t\t\" returned value obtained from unexported field\")\n-\t\t\t}\n-\t\t\toff += -off & uintptr(typ.align-1)\n-\t\t\taddr := unsafe.Pointer(uintptr(ptr) + off)\n-\t\t\tif v.flag&flagIndir == 0 {\n-\t\t\t\tstoreIword(addr, iword(v.val), typ.size)\n-\t\t\t} else {\n-\t\t\t\tmemmove(addr, v.val, typ.size)\n-\t\t\t}\n-\t\t\toff += typ.size\n-\t\t}\n-\t}\n-}\n-\n // methodReceiver returns information about the receiver\n // described by v. The Value v may or may not have the\n // flagMethod bit set, so the kind cached in v.flag should"}]}