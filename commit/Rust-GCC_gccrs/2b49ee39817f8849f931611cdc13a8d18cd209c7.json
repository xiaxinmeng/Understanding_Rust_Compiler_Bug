{"sha": "2b49ee39817f8849f931611cdc13a8d18cd209c7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmI0OWVlMzk4MTdmODg0OWY5MzE2MTFjZGMxM2E4ZDE4Y2QyMDljNw==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "amylaar@cygnus.co.uk", "date": "1998-12-01T10:00:11Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "1998-12-01T10:00:11Z"}, "message": "local-alloc.c (function_invariant_p): New function.\n\n\t* local-alloc.c (function_invariant_p): New function.\n\t(update_equiv_regs): Use function_invariant_p instead of CONSTANT_P\n\tto decide if an equivalence should be recorded.\n\t* reload1.c (num_eliminable_invariants): New static variable.\n\t(reload): Set it.  Use function_invariant_p instead of CONSTANT_P\n\tto decide if an equivalence should be recorded.\n\tUnshare PLUS.\n\t(calculate_needs_all_insns): Skip insns that only set an equivalence.\n\tTake num_eliminable_invariants into account when deciding\n\tif register elimination should be done.\n\t(reload_as_needed): Take num_eliminable_invariants into account\n\twhen deciding if register elimination should be done.\n\t(eliminate_regs): Handle non-constant reg_equiv_constant.\n\t* rtl.h (function_invariant_p): Declare.\n\nFrom-SVN: r24026", "tree": {"sha": "b9995987f19d6ca65c15b71f6f69120fde1b5af5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b9995987f19d6ca65c15b71f6f69120fde1b5af5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2b49ee39817f8849f931611cdc13a8d18cd209c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b49ee39817f8849f931611cdc13a8d18cd209c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b49ee39817f8849f931611cdc13a8d18cd209c7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b49ee39817f8849f931611cdc13a8d18cd209c7/comments", "author": null, "committer": null, "parents": [{"sha": "bbe348cd18f81dd9469c81ba6f498e01ca9c5a37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbe348cd18f81dd9469c81ba6f498e01ca9c5a37", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bbe348cd18f81dd9469c81ba6f498e01ca9c5a37"}], "stats": {"total": 78, "additions": 71, "deletions": 7}, "files": [{"sha": "ee4b9ff74cb7aecd5fb939b37773cce49f3a4f6c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b49ee39817f8849f931611cdc13a8d18cd209c7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b49ee39817f8849f931611cdc13a8d18cd209c7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2b49ee39817f8849f931611cdc13a8d18cd209c7", "patch": "@@ -1,3 +1,20 @@\n+Tue Dec  1 17:58:26 1998  J\"orn Rennecke <amylaar@cygnus.co.uk>\n+\n+\t* local-alloc.c (function_invariant_p): New function.\n+\t(update_equiv_regs): Use function_invariant_p instead of CONSTANT_P\n+\tto decide if an equivalence should be recorded.\n+\t* reload1.c (num_eliminable_invariants): New static variable.\n+\t(reload): Set it.  Use function_invariant_p instead of CONSTANT_P\n+\tto decide if an equivalence should be recorded.\n+\tUnshare PLUS.\n+\t(calculate_needs_all_insns): Skip insns that only set an equivalence.\n+\tTake num_eliminable_invariants into account when deciding\n+\tif register elimination should be done.\n+\t(reload_as_needed): Take num_eliminable_invariants into account\n+\twhen deciding if register elimination should be done.\n+\t(eliminate_regs): Handle non-constant reg_equiv_constant.\n+\t* rtl.h (function_invariant_p): Declare.\n+\n Mon Nov 30 02:00:08 PST 1998 Jeff Law  (law@cygnus.com)\n \n \t* version.c: Bump for snapshot."}, {"sha": "f112713b2841f3137078b31294dd7571a389b1a1", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b49ee39817f8849f931611cdc13a8d18cd209c7/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b49ee39817f8849f931611cdc13a8d18cd209c7/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=2b49ee39817f8849f931611cdc13a8d18cd209c7", "patch": "@@ -630,6 +630,22 @@ memref_used_between_p (memref, start, end)\n   return 0;\n }\n \f\n+/* Return nonzero if the rtx X is invariant over the current function.  */\n+int\n+function_invariant_p (x)\n+     rtx x;\n+{\n+  if (CONSTANT_P (x))\n+    return 1;\n+  if (x == frame_pointer_rtx || x == arg_pointer_rtx)\n+    return 1;\n+  if (GET_CODE (x) == PLUS\n+      && (XEXP (x, 0) == frame_pointer_rtx || XEXP (x, 0) == arg_pointer_rtx)\n+      && CONSTANT_P (XEXP (x, 1)))\n+    return 1;\n+  return 0;\n+}\n+\n /* Find registers that are equivalent to a single value throughout the\n    compilation (either because they can be referenced in memory or are set once\n    from a single constant).  Lower their priority for a register.\n@@ -798,7 +814,7 @@ update_equiv_regs ()\n \n       if (REG_N_SETS (regno) != 1\n \t  && (! note\n-\t      || ! CONSTANT_P (XEXP (note, 0))\n+\t      || ! function_invariant_p (XEXP (note, 0))\n \t      || (reg_equiv_replacement[regno]\n \t\t  && ! rtx_equal_p (XEXP (note, 0),\n \t\t\t\t    reg_equiv_replacement[regno]))))\n@@ -812,7 +828,7 @@ update_equiv_regs ()\n \n       /* If this register is known to be equal to a constant, record that\n \t it is always equivalent to the constant.  */\n-      if (note && CONSTANT_P (XEXP (note, 0)))\n+      if (note && function_invariant_p (XEXP (note, 0)))\n \tPUT_MODE (note, (enum machine_mode) REG_EQUIV);\n \n       /* If this insn introduces a \"constant\" register, decrease the priority"}, {"sha": "08f53759f997cb2230fa652bdd74ce8f765dbed8", "filename": "gcc/reload1.c", "status": "modified", "additions": 35, "deletions": 5, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b49ee39817f8849f931611cdc13a8d18cd209c7/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b49ee39817f8849f931611cdc13a8d18cd209c7/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=2b49ee39817f8849f931611cdc13a8d18cd209c7", "patch": "@@ -338,6 +338,9 @@ int num_not_at_initial_offset;\n \n /* Count the number of registers that we may be able to eliminate.  */\n static int num_eliminable;\n+/* And the number of registers that are equivalent to a constant that\n+   can be eliminated to frame_pointer / arg_pointer + constant.  */\n+static int num_eliminable_invariants;\n \n /* For each label, we record the offset of each elimination.  If we reach\n    a label by more than one path and an offset differs, we cannot do the\n@@ -659,6 +662,7 @@ reload (first, global, dumpfile)\n      Also look for a \"constant\" NOTE_INSN_SETJMP.  This means that all\n      caller-saved registers must be marked live.  */\n \n+  num_eliminable_invariants = 0;\n   for (insn = first; insn; insn = NEXT_INSN (insn))\n     {\n       rtx set = single_set (insn);\n@@ -674,7 +678,8 @@ reload (first, global, dumpfile)\n \t  rtx note = find_reg_note (insn, REG_EQUIV, NULL_RTX);\n \t  if (note\n #ifdef LEGITIMATE_PIC_OPERAND_P\n-\t      && (! CONSTANT_P (XEXP (note, 0)) || ! flag_pic\n+\t      && (! function_invariant_p (XEXP (note, 0))\n+\t\t  || ! flag_pic\n \t\t  || LEGITIMATE_PIC_OPERAND_P (XEXP (note, 0)))\n #endif\n \t      )\n@@ -692,9 +697,22 @@ reload (first, global, dumpfile)\n \n \t\t      reg_equiv_memory_loc[i] = x;\n \t\t    }\n-\t\t  else if (CONSTANT_P (x))\n+\t\t  else if (function_invariant_p (x))\n \t\t    {\n-\t\t      if (LEGITIMATE_CONSTANT_P (x))\n+\t\t      if (GET_CODE (x) == PLUS)\n+\t\t\t{\n+\t\t\t  /* This is PLUS of frame pointer and a constant,\n+\t\t\t     and might be shared.  Unshare it.  */\n+\t\t\t  reg_equiv_constant[i] = copy_rtx (x);\n+\t\t\t  num_eliminable_invariants++;\n+\t\t\t}\n+\t\t      else if (x == frame_pointer_rtx\n+\t\t\t       || x == arg_pointer_rtx)\n+\t\t\t{\n+\t\t\t  reg_equiv_constant[i] = x;\n+\t\t\t  num_eliminable_invariants++;\n+\t\t\t}\n+\t\t      else if (LEGITIMATE_CONSTANT_P (x))\n \t\t\treg_equiv_constant[i] = x;\n \t\t      else\n \t\t\treg_equiv_memory_loc[i]\n@@ -1335,9 +1353,16 @@ calculate_needs_all_insns (global)\n \t  rtx old_notes = REG_NOTES (insn);\n \t  int did_elimination = 0;\n \t  int operands_changed = 0;\n+\t  rtx set = single_set (insn);\n+\n+\t  /* Skip insns that only set an equivalence.  */\n+\t  if (set && GET_CODE (SET_DEST (set)) == REG\n+\t      && reg_renumber[REGNO (SET_DEST (set))] < 0\n+\t      && reg_equiv_constant[REGNO (SET_DEST (set))])\n+\t    continue;\n \n \t  /* If needed, eliminate any eliminable registers.  */\n-\t  if (num_eliminable)\n+\t  if (num_eliminable || num_eliminable_invariants)\n \t    did_elimination = eliminate_regs_in_insn (insn, 0);\n \n \t  /* Analyze the instruction.  */\n@@ -2698,6 +2723,11 @@ eliminate_regs (x, mem_mode, insn)\n \t      }\n \n \t}\n+      else if (reg_renumber[regno] < 0 && reg_equiv_constant\n+\t       && reg_equiv_constant[regno]\n+\t       && ! CONSTANT_P (reg_equiv_constant[regno]))\n+\treturn eliminate_regs (copy_rtx (reg_equiv_constant[regno]),\n+\t\t\t       mem_mode, insn);\n       return x;\n \n     case PLUS:\n@@ -4163,7 +4193,7 @@ reload_as_needed (live_known)\n \n \t  /* If we need to do register elimination processing, do so.\n \t     This might delete the insn, in which case we are done.  */\n-\t  if (num_eliminable && chain->need_elim)\n+\t  if ((num_eliminable || num_eliminable_invariants) && chain->need_elim)\n \t    {\n \t      eliminate_regs_in_insn (insn, 1);\n \t      if (GET_CODE (insn) == NOTE)"}, {"sha": "93e784285d0907963ecd96d0f298de3d1f83b88d", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b49ee39817f8849f931611cdc13a8d18cd209c7/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b49ee39817f8849f931611cdc13a8d18cd209c7/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=2b49ee39817f8849f931611cdc13a8d18cd209c7", "patch": "@@ -1440,6 +1440,7 @@ extern void init_optabs\t\t\tPROTO ((void));\n extern void dump_local_alloc\t\tPROTO ((FILE *));\n #endif\n extern void local_alloc\t\t\tPROTO ((void));\n+extern int function_invariant_p\t\tPROTO ((rtx));\n \n /* In reload1.c */\n extern void reload_cse_regs\t\tPROTO ((rtx));"}]}