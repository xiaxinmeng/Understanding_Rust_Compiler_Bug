{"sha": "1ec57cf03b8ba96e9e98553cabf16b2f70d062a6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWVjNTdjZjAzYjhiYTk2ZTllOTg1NTNjYWJmMTZiMmY3MGQwNjJhNg==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@integrable-solutions.net", "date": "2003-10-03T20:27:05Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2003-10-03T20:27:05Z"}, "message": "decl.c (struct cp_binding_level): Move to name-lookup.h\n\n\t* decl.c (struct cp_binding_level): Move to name-lookup.h\n\t(current_binding_level): Likewise.\n\t(class_binding_level): Likewise.\n\t* cp-tree.h (enum scope_kind): Likewise.\n\nFrom-SVN: r72076", "tree": {"sha": "c33a109e0bbd4932f8cb2ce57e482ad3b9feca4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c33a109e0bbd4932f8cb2ce57e482ad3b9feca4a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1ec57cf03b8ba96e9e98553cabf16b2f70d062a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ec57cf03b8ba96e9e98553cabf16b2f70d062a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ec57cf03b8ba96e9e98553cabf16b2f70d062a6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ec57cf03b8ba96e9e98553cabf16b2f70d062a6/comments", "author": {"login": "cxx-undef", "id": 5528103, "node_id": "MDQ6VXNlcjU1MjgxMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/5528103?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cxx-undef", "html_url": "https://github.com/cxx-undef", "followers_url": "https://api.github.com/users/cxx-undef/followers", "following_url": "https://api.github.com/users/cxx-undef/following{/other_user}", "gists_url": "https://api.github.com/users/cxx-undef/gists{/gist_id}", "starred_url": "https://api.github.com/users/cxx-undef/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cxx-undef/subscriptions", "organizations_url": "https://api.github.com/users/cxx-undef/orgs", "repos_url": "https://api.github.com/users/cxx-undef/repos", "events_url": "https://api.github.com/users/cxx-undef/events{/privacy}", "received_events_url": "https://api.github.com/users/cxx-undef/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a97386cda2fd05aebec13fd455e8191dae9b3511", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a97386cda2fd05aebec13fd455e8191dae9b3511", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a97386cda2fd05aebec13fd455e8191dae9b3511"}], "stats": {"total": 306, "additions": 155, "deletions": 151}, "files": [{"sha": "3cc736991c4c50ebfb0132097867db5b1aee85be", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ec57cf03b8ba96e9e98553cabf16b2f70d062a6/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ec57cf03b8ba96e9e98553cabf16b2f70d062a6/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=1ec57cf03b8ba96e9e98553cabf16b2f70d062a6", "patch": "@@ -1,3 +1,10 @@\n+2003-10-03  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n+\n+\t* decl.c (struct cp_binding_level): Move to name-lookup.h\n+\t(current_binding_level): Likewise.\n+\t(class_binding_level): Likewise.\n+\t* cp-tree.h (enum scope_kind): Likewise.\n+\n 2003-10-03  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n \n \t* name-lookup.c (binding_entry_free): Nullify name and type"}, {"sha": "eb6b6c2f81e6d4ef77dcc28abe1de27acdd6be4c", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ec57cf03b8ba96e9e98553cabf16b2f70d062a6/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ec57cf03b8ba96e9e98553cabf16b2f70d062a6/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=1ec57cf03b8ba96e9e98553cabf16b2f70d062a6", "patch": "@@ -2926,31 +2926,6 @@ typedef enum cp_lvalue_kind {\n   clk_packed = 8    /* An lvalue for a packed field. */\n } cp_lvalue_kind;\n \n-/* The kinds of scopes we recognize.  */\n-typedef enum scope_kind {\n-  sk_block = 0,      /* An ordinary block scope.  This enumerator must\n-\t\t\thave the value zero because \"cp_binding_level\"\n-\t\t\tis initialized by using \"memset\" to set the\n-\t\t\tcontents to zero, and the default scope kind\n-\t\t\tis \"sk_block\".  */\n-  sk_cleanup,        /* A scope for (pseudo-)scope for cleanup.  It is\n-                        peusdo in that it is transparent to name lookup\n-                        activities.  */\n-  sk_try,\t     /* A try-block.  */\n-  sk_catch,          /* A catch-block.  */\n-  sk_for,            /* The scope of the variable declared in a\n-\t\t\tfor-init-statement.  */\n-  sk_function_parms, /* The scope containing function parameters.  */\n-  sk_class,          /* The scope containing the members of a class.  */\n-  sk_namespace,      /* The scope containing the members of a\n-\t\t\tnamespace, including the global scope.  */\n-  sk_template_parms, /* A scope for template parameters.  */\n-  sk_template_spec   /* Like sk_template_parms, but for an explicit\n-\t\t\tspecialization.  Since, by definition, an\n-\t\t\texplicit specialization is introduced by\n-\t\t\t\"template <>\", this scope is always empty.  */\n-} scope_kind;\n-\n /* Various kinds of template specialization, instantiation, etc.  */\n typedef enum tmpl_spec_kind {\n   tsk_none,                /* Not a template at all.  */"}, {"sha": "729e54990a964ab814ec82380d0f1cbec401773e", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 126, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ec57cf03b8ba96e9e98553cabf16b2f70d062a6/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ec57cf03b8ba96e9e98553cabf16b2f70d062a6/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=1ec57cf03b8ba96e9e98553cabf16b2f70d062a6", "patch": "@@ -278,130 +278,6 @@ int adding_implicit_members = 0;\n bool have_extern_spec;\n \n \f\n-/* For each binding contour we allocate a binding_level structure\n-   which records the names defined in that contour.\n-   Contours include:\n-    0) the global one\n-    1) one for each function definition,\n-       where internal declarations of the parameters appear.\n-    2) one for each compound statement,\n-       to record its declarations.\n-\n-   The current meaning of a name can be found by searching the levels\n-   from the current one out to the global one.\n-\n-   Off to the side, may be the class_binding_level.  This exists only\n-   to catch class-local declarations.  It is otherwise nonexistent.\n-\n-   Also there may be binding levels that catch cleanups that must be\n-   run when exceptions occur.  Thus, to see whether a name is bound in\n-   the current scope, it is not enough to look in the\n-   CURRENT_BINDING_LEVEL.  You should use lookup_name_current_level\n-   instead.  */\n-\n-/* Note that the information in the `names' component of the global contour\n-   is duplicated in the IDENTIFIER_GLOBAL_VALUEs of all identifiers.  */\n-\n-struct cp_binding_level GTY(())\n-  {\n-    /* A chain of _DECL nodes for all variables, constants, functions,\n-       and typedef types.  These are in the reverse of the order\n-       supplied.  There may be OVERLOADs on this list, too, but they\n-       are wrapped in TREE_LISTs; the TREE_VALUE is the OVERLOAD.  */\n-    tree names;\n-\n-    /* Count of elements in names chain.  */\n-    size_t names_size;\n-\n-    /* A chain of NAMESPACE_DECL nodes.  */\n-    tree namespaces;\n-\n-    /* An array of static functions and variables (for namespaces only) */\n-    varray_type static_decls;\n-\n-    /* A chain of VTABLE_DECL nodes.  */\n-    tree vtables; \n-\n-    /* A dictionary for looking up user-defined-types.  */\n-    binding_table type_decls;\n-\n-    /* A list of USING_DECL nodes.  */\n-    tree usings;\n-\n-    /* A list of used namespaces. PURPOSE is the namespace,\n-       VALUE the common ancestor with this binding_level's namespace.  */\n-    tree using_directives;\n-\n-    /* If this binding level is the binding level for a class, then\n-       class_shadowed is a TREE_LIST.  The TREE_PURPOSE of each node\n-       is the name of an entity bound in the class.  The TREE_TYPE is\n-       the DECL bound by this name in the class.  */\n-    tree class_shadowed;\n-\n-    /* Similar to class_shadowed, but for IDENTIFIER_TYPE_VALUE, and\n-       is used for all binding levels. In addition the TREE_VALUE is the\n-       IDENTIFIER_TYPE_VALUE before we entered the class.  */\n-    tree type_shadowed;\n-\n-    /* A TREE_LIST.  Each TREE_VALUE is the LABEL_DECL for a local\n-       label in this scope.  The TREE_PURPOSE is the previous value of\n-       the IDENTIFIER_LABEL VALUE.  */\n-    tree shadowed_labels;\n-\n-    /* For each level (except not the global one),\n-       a chain of BLOCK nodes for all the levels\n-       that were entered and exited one level down.  */\n-    tree blocks;\n-\n-    /* The entity (namespace, class, function) the scope of which this\n-       binding contour corresponds to.  Otherwise NULL.  */\n-    tree this_entity;\n-\n-    /* The binding level which this one is contained in (inherits from).  */\n-    struct cp_binding_level *level_chain;\n-\n-    /* List of VAR_DECLS saved from a previous for statement.\n-       These would be dead in ISO-conforming code, but might\n-       be referenced in ARM-era code.  These are stored in a\n-       TREE_LIST; the TREE_VALUE is the actual declaration.  */\n-    tree dead_vars_from_for;\n-\n-    /* Binding depth at which this level began.  */\n-    int binding_depth;\n-\n-    /* The kind of scope that this object represents.  However, a\n-       SK_TEMPLATE_SPEC scope is represented with KIND set to\n-       SK_TEMPALTE_PARMS and EXPLICIT_SPEC_P set to true.  */\n-    enum scope_kind kind : 4;\n-\n-    /* True if this scope is an SK_TEMPLATE_SPEC scope.  This field is\n-       only valid if KIND == SK_TEMPLATE_PARMS.  */\n-    bool explicit_spec_p : 1;\n-\n-    /* true means make a BLOCK for this level regardless of all else.  */\n-    unsigned keep : 1;\n-\n-    /* Nonzero if this level can safely have additional\n-       cleanup-needing variables added to it.  */\n-    unsigned more_cleanups_ok : 1;\n-    unsigned have_cleanups : 1;\n-\n-    /* 22 bits left to fill a 32-bit word.  */\n-  };\n-\n-#define NULL_BINDING_LEVEL ((struct cp_binding_level *) NULL)\n-\n-/* The binding level currently in effect.  */\n-\n-#define current_binding_level\t\t\t\\\n-  (*(cfun && cp_function_chain->bindings\t\\\n-   ? &cp_function_chain->bindings\t\t\\\n-   : &scope_chain->bindings))\n-\n-/* The binding level of the current class, if any.  */\n-\n-#define class_binding_level scope_chain->class_bindings\n-\n /* A chain of binding_level structures awaiting reuse.  */\n \n static GTY((deletable (\"\"))) struct cp_binding_level *free_binding_level;\n@@ -6055,8 +5931,7 @@ cxx_init_decl_processing (void)\n   push_to_top_level ();\n \n   current_function_decl = NULL_TREE;\n-  current_binding_level = NULL_BINDING_LEVEL;\n-  free_binding_level = NULL_BINDING_LEVEL;\n+  current_binding_level = NULL;\n   /* Enter the global namespace.  */\n   my_friendly_assert (global_namespace == NULL_TREE, 375);\n   global_namespace = build_lang_decl (NAMESPACE_DECL, global_scope_name,"}, {"sha": "15f1936ebf279a4f87006a46ae842c7d1fd8356f", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ec57cf03b8ba96e9e98553cabf16b2f70d062a6/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ec57cf03b8ba96e9e98553cabf16b2f70d062a6/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=1ec57cf03b8ba96e9e98553cabf16b2f70d062a6", "patch": "@@ -97,6 +97,153 @@ extern cxx_binding *cxx_binding_make (tree, tree);\n extern void cxx_binding_free (cxx_binding *);\n extern bool supplement_binding (cxx_binding *, tree);\n \f\n+/* The kinds of scopes we recognize.  */\n+typedef enum scope_kind {\n+  sk_block = 0,      /* An ordinary block scope.  This enumerator must\n+\t\t\thave the value zero because \"cp_binding_level\"\n+\t\t\tis initialized by using \"memset\" to set the\n+\t\t\tcontents to zero, and the default scope kind\n+\t\t\tis \"sk_block\".  */\n+  sk_cleanup,        /* A scope for (pseudo-)scope for cleanup.  It is\n+                        peusdo in that it is transparent to name lookup\n+                        activities.  */\n+  sk_try,\t     /* A try-block.  */\n+  sk_catch,          /* A catch-block.  */\n+  sk_for,            /* The scope of the variable declared in a\n+\t\t\tfor-init-statement.  */\n+  sk_function_parms, /* The scope containing function parameters.  */\n+  sk_class,          /* The scope containing the members of a class.  */\n+  sk_namespace,      /* The scope containing the members of a\n+\t\t\tnamespace, including the global scope.  */\n+  sk_template_parms, /* A scope for template parameters.  */\n+  sk_template_spec   /* Like sk_template_parms, but for an explicit\n+\t\t\tspecialization.  Since, by definition, an\n+\t\t\texplicit specialization is introduced by\n+\t\t\t\"template <>\", this scope is always empty.  */\n+} scope_kind;\n+\n+/* For each binding contour we allocate a binding_level structure\n+   which records the names defined in that contour.\n+   Contours include:\n+    0) the global one\n+    1) one for each function definition,\n+       where internal declarations of the parameters appear.\n+    2) one for each compound statement,\n+       to record its declarations.\n+\n+   The current meaning of a name can be found by searching the levels\n+   from the current one out to the global one.\n+\n+   Off to the side, may be the class_binding_level.  This exists only\n+   to catch class-local declarations.  It is otherwise nonexistent.\n+\n+   Also there may be binding levels that catch cleanups that must be\n+   run when exceptions occur.  Thus, to see whether a name is bound in\n+   the current scope, it is not enough to look in the\n+   CURRENT_BINDING_LEVEL.  You should use lookup_name_current_level\n+   instead.  */\n+\n+/* Note that the information in the `names' component of the global contour\n+   is duplicated in the IDENTIFIER_GLOBAL_VALUEs of all identifiers.  */\n+\n+struct cp_binding_level GTY(())\n+  {\n+    /* A chain of _DECL nodes for all variables, constants, functions,\n+       and typedef types.  These are in the reverse of the order\n+       supplied.  There may be OVERLOADs on this list, too, but they\n+       are wrapped in TREE_LISTs; the TREE_VALUE is the OVERLOAD.  */\n+    tree names;\n+\n+    /* Count of elements in names chain.  */\n+    size_t names_size;\n+\n+    /* A chain of NAMESPACE_DECL nodes.  */\n+    tree namespaces;\n+\n+    /* An array of static functions and variables (for namespaces only) */\n+    varray_type static_decls;\n+\n+    /* A chain of VTABLE_DECL nodes.  */\n+    tree vtables; \n+\n+    /* A dictionary for looking up user-defined-types.  */\n+    binding_table type_decls;\n+\n+    /* A list of USING_DECL nodes.  */\n+    tree usings;\n+\n+    /* A list of used namespaces. PURPOSE is the namespace,\n+       VALUE the common ancestor with this binding_level's namespace.  */\n+    tree using_directives;\n+\n+    /* If this binding level is the binding level for a class, then\n+       class_shadowed is a TREE_LIST.  The TREE_PURPOSE of each node\n+       is the name of an entity bound in the class.  The TREE_TYPE is\n+       the DECL bound by this name in the class.  */\n+    tree class_shadowed;\n+\n+    /* Similar to class_shadowed, but for IDENTIFIER_TYPE_VALUE, and\n+       is used for all binding levels. In addition the TREE_VALUE is the\n+       IDENTIFIER_TYPE_VALUE before we entered the class.  */\n+    tree type_shadowed;\n+\n+    /* A TREE_LIST.  Each TREE_VALUE is the LABEL_DECL for a local\n+       label in this scope.  The TREE_PURPOSE is the previous value of\n+       the IDENTIFIER_LABEL VALUE.  */\n+    tree shadowed_labels;\n+\n+    /* For each level (except not the global one),\n+       a chain of BLOCK nodes for all the levels\n+       that were entered and exited one level down.  */\n+    tree blocks;\n+\n+    /* The entity (namespace, class, function) the scope of which this\n+       binding contour corresponds to.  Otherwise NULL.  */\n+    tree this_entity;\n+\n+    /* The binding level which this one is contained in (inherits from).  */\n+    struct cp_binding_level *level_chain;\n+\n+    /* List of VAR_DECLS saved from a previous for statement.\n+       These would be dead in ISO-conforming code, but might\n+       be referenced in ARM-era code.  These are stored in a\n+       TREE_LIST; the TREE_VALUE is the actual declaration.  */\n+    tree dead_vars_from_for;\n+\n+    /* Binding depth at which this level began.  */\n+    int binding_depth;\n+\n+    /* The kind of scope that this object represents.  However, a\n+       SK_TEMPLATE_SPEC scope is represented with KIND set to\n+       SK_TEMPALTE_PARMS and EXPLICIT_SPEC_P set to true.  */\n+    enum scope_kind kind : 4;\n+\n+    /* True if this scope is an SK_TEMPLATE_SPEC scope.  This field is\n+       only valid if KIND == SK_TEMPLATE_PARMS.  */\n+    bool explicit_spec_p : 1;\n+\n+    /* true means make a BLOCK for this level regardless of all else.  */\n+    unsigned keep : 1;\n+\n+    /* Nonzero if this level can safely have additional\n+       cleanup-needing variables added to it.  */\n+    unsigned more_cleanups_ok : 1;\n+    unsigned have_cleanups : 1;\n+\n+    /* 22 bits left to fill a 32-bit word.  */\n+  };\n+\n+/* The binding level currently in effect.  */\n+\n+#define current_binding_level\t\t\t\\\n+  (*(cfun && cp_function_chain->bindings\t\\\n+   ? &cp_function_chain->bindings\t\t\\\n+   : &scope_chain->bindings))\n+\n+/* The binding level of the current class, if any.  */\n+\n+#define class_binding_level scope_chain->class_bindings\n+\n /* The tree node representing the global scope.  */\n extern GTY(()) tree global_namespace;\n "}]}