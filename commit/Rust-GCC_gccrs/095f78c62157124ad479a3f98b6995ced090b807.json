{"sha": "095f78c62157124ad479a3f98b6995ced090b807", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDk1Zjc4YzYyMTU3MTI0YWQ0NzlhM2Y5OGI2OTk1Y2VkMDkwYjgwNw==", "commit": {"author": {"name": "Feng Xue", "email": "fxue@os.amperecomputing.com", "date": "2019-11-07T15:43:01Z"}, "committer": {"name": "Feng Xue", "email": "fxue@gcc.gnu.org", "date": "2019-11-07T15:43:01Z"}, "message": "Loop split on semi-invariant conditional statement\n\n2019-11-07  Feng Xue <fxue@os.amperecomputing.com>\n\n        PR tree-optimization/89134\n        * doc/invoke.texi (min-loop-cond-split-prob): Document new --params.\n        * params.def: Add min-loop-cond-split-prob.\n        * tree-ssa-loop-split.c (split_loop): Remove niter parameter, move some\n        outside checks on loop into the function.\n        (split_info): New class.\n        (find_vdef_in_loop, get_control_equiv_head_block): New functions.\n        (find_control_dep_blocks, vuse_semi_invariant_p): Likewise.\n        (ssa_semi_invariant_p, loop_iter_phi_semi_invariant_p): Likewise.\n        (control_dep_semi_invariant_p, stmt_semi_invariant_p_1): Likewise.\n        (stmt_semi_invariant_p, branch_removable_p): Likewise.\n        (get_cond_invariant_branch, compute_added_num_insns): Likewise.\n        (get_cond_branch_to_split_loop, do_split_loop_on_cond): Likewise.\n        (split_loop_on_cond): Likewise.\n        (tree_ssa_split_loops): Add loop split on conditional statement.\n\n2019-11-07  Feng Xue  <fxue@os.amperecomputing.com>\n\n        PR tree-optimization/89134\n        * gcc.dg/tree-ssa/loop-cond-split-1.c: New test.\n        * g++.dg/tree-ssa/loop-cond-split-1.C: New test.\n        * gcc.dg/torture/pr55107.c: Add -fno-split-loops.\n\nFrom-SVN: r277923", "tree": {"sha": "c923adca9e7c669cc0ba77cd8fe7c525094b99ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c923adca9e7c669cc0ba77cd8fe7c525094b99ff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/095f78c62157124ad479a3f98b6995ced090b807", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/095f78c62157124ad479a3f98b6995ced090b807", "html_url": "https://github.com/Rust-GCC/gccrs/commit/095f78c62157124ad479a3f98b6995ced090b807", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/095f78c62157124ad479a3f98b6995ced090b807/comments", "author": {"login": "feng-xue-ampere", "id": 95893536, "node_id": "U_kgDOBbc4IA", "avatar_url": "https://avatars.githubusercontent.com/u/95893536?v=4", "gravatar_id": "", "url": "https://api.github.com/users/feng-xue-ampere", "html_url": "https://github.com/feng-xue-ampere", "followers_url": "https://api.github.com/users/feng-xue-ampere/followers", "following_url": "https://api.github.com/users/feng-xue-ampere/following{/other_user}", "gists_url": "https://api.github.com/users/feng-xue-ampere/gists{/gist_id}", "starred_url": "https://api.github.com/users/feng-xue-ampere/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/feng-xue-ampere/subscriptions", "organizations_url": "https://api.github.com/users/feng-xue-ampere/orgs", "repos_url": "https://api.github.com/users/feng-xue-ampere/repos", "events_url": "https://api.github.com/users/feng-xue-ampere/events{/privacy}", "received_events_url": "https://api.github.com/users/feng-xue-ampere/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "163f23d21e5f2faee08163f2dcb363042b53ee1e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/163f23d21e5f2faee08163f2dcb363042b53ee1e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/163f23d21e5f2faee08163f2dcb363042b53ee1e"}], "stats": {"total": 1190, "additions": 1162, "deletions": 28}, "files": [{"sha": "d3ef93111260fb75dcb2e411d55ae1f5aff87ba0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095f78c62157124ad479a3f98b6995ced090b807/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095f78c62157124ad479a3f98b6995ced090b807/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=095f78c62157124ad479a3f98b6995ced090b807", "patch": "@@ -1,3 +1,21 @@\n+2019-11-07  Feng Xue <fxue@os.amperecomputing.com>\n+\n+\tPR tree-optimization/89134\n+\t* doc/invoke.texi (min-loop-cond-split-prob): Document new --params.\n+\t* params.def: Add min-loop-cond-split-prob.\n+\t* tree-ssa-loop-split.c (split_loop): Remove niter parameter, move some\n+\toutside checks on loop into the function.\n+\t(split_info): New class.\n+\t(find_vdef_in_loop, get_control_equiv_head_block): New functions.\n+\t(find_control_dep_blocks, vuse_semi_invariant_p): Likewise.\n+\t(ssa_semi_invariant_p, loop_iter_phi_semi_invariant_p): Likewise.\n+\t(control_dep_semi_invariant_p, stmt_semi_invariant_p_1): Likewise.\n+\t(stmt_semi_invariant_p, branch_removable_p): Likewise.\n+\t(get_cond_invariant_branch, compute_added_num_insns): Likewise.\n+\t(get_cond_branch_to_split_loop, do_split_loop_on_cond): Likewise.\n+\t(split_loop_on_cond): Likewise.\n+\t(tree_ssa_split_loops): Add loop split on conditional statement.\n+\n 2019-11-07  Andreas Krebbel  <krebbel@linux.ibm.com>\n \n \t* config/s390/s390.md (\"*cstorecc<mode>_z13\"): New insn_and_split"}, {"sha": "15fe2284d4210d78947ba3c951cec714268a3a1a", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095f78c62157124ad479a3f98b6995ced090b807/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095f78c62157124ad479a3f98b6995ced090b807/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=095f78c62157124ad479a3f98b6995ced090b807", "patch": "@@ -11517,6 +11517,11 @@ The maximum number of branches unswitched in a single loop.\n @item lim-expensive\n The minimum cost of an expensive expression in the loop invariant motion.\n \n+@item min-loop-cond-split-prob\n+When FDO profile information is available, @option{min-loop-cond-split-prob}\n+specifies minimum threshold for probability of semi-invariant condition\n+statement to trigger loop split.\n+\n @item iv-consider-all-candidates-bound\n Bound on number of candidates for induction variables, below which\n all candidates are considered for each use in induction variable"}, {"sha": "df7d1f7c5e732c098aaeb90b4af0923a569b9e1d", "filename": "gcc/params.def", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095f78c62157124ad479a3f98b6995ced090b807/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095f78c62157124ad479a3f98b6995ced090b807/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=095f78c62157124ad479a3f98b6995ced090b807", "patch": "@@ -415,6 +415,12 @@ DEFPARAM(PARAM_MAX_UNSWITCH_LEVEL,\n \t\"The maximum number of unswitchings in a single loop.\",\n \t3, 0, 0)\n \n+DEFPARAM(PARAM_MIN_LOOP_COND_SPLIT_PROB,\n+\t\"min-loop-cond-split-prob\",\n+\t\"The minimum threshold for probability of semi-invariant condition \"\n+\t\"statement to trigger loop split.\",\n+\t30, 0, 100)\n+\n /* The maximum number of insns in loop header duplicated by the copy loop\n    headers pass.  */\n DEFPARAM(PARAM_MAX_LOOP_HEADER_INSNS,"}, {"sha": "c80457cca9efe13b5d29cb7530aab673264c8aab", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095f78c62157124ad479a3f98b6995ced090b807/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095f78c62157124ad479a3f98b6995ced090b807/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=095f78c62157124ad479a3f98b6995ced090b807", "patch": "@@ -1,3 +1,10 @@\n+2019-11-07  Feng Xue  <fxue@os.amperecomputing.com>\n+\n+\tPR tree-optimization/89134\n+\t* gcc.dg/tree-ssa/loop-cond-split-1.c: New test.\n+\t* g++.dg/tree-ssa/loop-cond-split-1.C: New test.\n+\t* gcc.dg/torture/pr55107.c: Add -fno-split-loops.\n+\n 2019-11-07  Andreas Krebbel  <krebbel@linux.ibm.com>\n \n \t* gcc.target/s390/addsub-signed-overflow-1.c: Expect lochi"}, {"sha": "0d679cb9035a65181c505e7b063c782a232729af", "filename": "gcc/testsuite/g++.dg/tree-ssa/loop-cond-split-1.C", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095f78c62157124ad479a3f98b6995ced090b807/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Floop-cond-split-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095f78c62157124ad479a3f98b6995ced090b807/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Floop-cond-split-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Floop-cond-split-1.C?ref=095f78c62157124ad479a3f98b6995ced090b807", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-tree-lsplit-details\" } */\n+\n+#include <string>\n+#include <map>\n+\n+using namespace std;\n+\n+class  A\n+{\n+public:\n+  bool empty;\n+  void set (string s);\n+};\n+\n+class  B\n+{\n+  map<int, string> m;\n+  void f ();\n+};\n+\n+extern A *ga;\n+\n+void B::f ()\n+{\n+  for (map<int, string>::iterator iter = m.begin (); iter != m.end (); ++iter)\n+    {\n+      if (ga->empty)\n+        ga->set (iter->second);\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"loop split on semi-invariant condition at false branch\" 1 \"lsplit\" } } */"}, {"sha": "d757c0412201cd7cbd893b9d81f721b10752f118", "filename": "gcc/testsuite/gcc.dg/torture/pr55107.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095f78c62157124ad479a3f98b6995ced090b807/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr55107.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095f78c62157124ad479a3f98b6995ced090b807/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr55107.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr55107.c?ref=095f78c62157124ad479a3f98b6995ced090b807", "patch": "@@ -1,4 +1,5 @@\n /* { dg-do compile } */\n+/* { dg-additional-options \"-fno-split-loops\" } */\n \n typedef unsigned short uint16_t;\n "}, {"sha": "feb776e8373dfd27d4c2590f9315b442d26f0c70", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-cond-split-1.c", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095f78c62157124ad479a3f98b6995ced090b807/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-cond-split-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095f78c62157124ad479a3f98b6995ced090b807/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-cond-split-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-cond-split-1.c?ref=095f78c62157124ad479a3f98b6995ced090b807", "patch": "@@ -0,0 +1,97 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-tree-lsplit-details\" } */\n+\n+extern const int step;\n+\n+int ga, gb;\n+\n+__attribute__((pure)) __attribute__((noinline)) int inc (int i)\n+{\n+  return i + step;\n+}\n+\n+extern int do_something (void);\n+\n+void test1 (int n)\n+{\n+  int i;\n+\n+  for (i = 0; i < n; i = inc (i))\n+    {\n+      if (ga)\n+        ga = do_something ();\n+    }\n+}\n+\n+void test2 (int n, int p)\n+{\n+  int i;\n+  int v;\n+\n+  for (i = 0; i < n ; i = inc (i))\n+    {\n+      if (ga)\n+       {\n+         v = inc (2);\n+         gb += 1;\n+       }\n+      else\n+       {\n+         v = p * p;\n+         gb *= 3;\n+       }\n+\n+      if (v < 10)\n+        ga = do_something ();\n+    }\n+}\n+\n+void test3 (int n, int p)\n+{\n+  int i;\n+  int c = p + 1;\n+  int v;\n+\n+  for (i = 0; i < n ; i = inc (i))\n+    {\n+      if (c)\n+       {\n+         v = inc (c);\n+         gb += 1;\n+       }\n+      else\n+       {\n+         v = p * p;\n+         gb *= 3;\n+       }\n+\n+      if (v < 10)\n+        c = do_something ();\n+    }\n+}\n+\n+void test4 (int n, int p)\n+{\n+  int i;\n+  int v;\n+\n+  for (i = 0; i < n ; i = inc (i))\n+    {\n+      if (ga)\n+       {\n+         v = inc (2);\n+         if (gb > 16)\n+           v = inc (5);  \n+       }\n+      else\n+       {\n+         v = p * p;\n+         gb += 2;\n+       }\n+\n+      if (v < 10)\n+        ga = do_something ();\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"loop split on semi-invariant condition at false branch\" 3 \"lsplit\" } } */"}, {"sha": "6302d044e092daabe4502a66928920ea0dde5713", "filename": "gcc/tree-ssa-loop-split.c", "status": "modified", "additions": 995, "deletions": 28, "changes": 1023, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/095f78c62157124ad479a3f98b6995ced090b807/gcc%2Ftree-ssa-loop-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/095f78c62157124ad479a3f98b6995ced090b807/gcc%2Ftree-ssa-loop-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-split.c?ref=095f78c62157124ad479a3f98b6995ced090b807", "patch": "@@ -32,15 +32,20 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-ssa-loop.h\"\n #include \"tree-ssa-loop-manip.h\"\n #include \"tree-into-ssa.h\"\n+#include \"tree-inline.h\"\n+#include \"tree-cfgcleanup.h\"\n #include \"cfgloop.h\"\n+#include \"params.h\"\n #include \"tree-scalar-evolution.h\"\n #include \"gimple-iterator.h\"\n #include \"gimple-pretty-print.h\"\n #include \"cfghooks.h\"\n #include \"gimple-fold.h\"\n #include \"gimplify-me.h\"\n \n-/* This file implements loop splitting, i.e. transformation of loops like\n+/* This file implements two kinds of loop splitting.\n+\n+   One transformation of loops like:\n \n    for (i = 0; i < 100; i++)\n      {\n@@ -487,26 +492,47 @@ compute_new_first_bound (gimple_seq *stmts, class tree_niter_desc *niter,\n    single exit of LOOP.  */\n \n static bool\n-split_loop (class loop *loop1, class tree_niter_desc *niter)\n+split_loop (class loop *loop1)\n {\n+  class tree_niter_desc niter;\n   basic_block *bbs;\n   unsigned i;\n   bool changed = false;\n   tree guard_iv;\n   tree border = NULL_TREE;\n   affine_iv iv;\n \n+  if (!single_exit (loop1)\n+      /* ??? We could handle non-empty latches when we split the latch edge\n+\t (not the exit edge), and put the new exit condition in the new block.\n+\t OTOH this executes some code unconditionally that might have been\n+\t skipped by the original exit before.  */\n+      || !empty_block_p (loop1->latch)\n+      || !easy_exit_values (loop1)\n+      || !number_of_iterations_exit (loop1, single_exit (loop1), &niter,\n+\t\t\t\t     false, true)\n+      || niter.cmp == ERROR_MARK\n+      /* We can't yet handle loops controlled by a != predicate.  */\n+      || niter.cmp == NE_EXPR)\n+    return false;\n+\n   bbs = get_loop_body (loop1);\n \n+  if (!can_copy_bbs_p (bbs, loop1->num_nodes))\n+    {\n+      free (bbs);\n+      return false;\n+    }\n+\n   /* Find a splitting opportunity.  */\n   for (i = 0; i < loop1->num_nodes; i++)\n     if ((guard_iv = split_at_bb_p (loop1, bbs[i], &border, &iv)))\n       {\n \t/* Handling opposite steps is not implemented yet.  Neither\n \t   is handling different step sizes.  */\n \tif ((tree_int_cst_sign_bit (iv.step)\n-\t     != tree_int_cst_sign_bit (niter->control.step))\n-\t    || !tree_int_cst_equal (iv.step, niter->control.step))\n+\t     != tree_int_cst_sign_bit (niter.control.step))\n+\t    || !tree_int_cst_equal (iv.step, niter.control.step))\n \t  continue;\n \n \t/* Find a loop PHI node that defines guard_iv directly,\n@@ -575,7 +601,7 @@ split_loop (class loop *loop1, class tree_niter_desc *niter)\n \t   Compute the new bound for the guarding IV and patch the\n \t   loop exit to use it instead of original IV and bound.  */\n \tgimple_seq stmts = NULL;\n-\ttree newend = compute_new_first_bound (&stmts, niter, border,\n+\ttree newend = compute_new_first_bound (&stmts, &niter, border,\n \t\t\t\t\t       guard_code, guard_init);\n \tif (stmts)\n \t  gsi_insert_seq_on_edge_immediate (loop_preheader_edge (loop1),\n@@ -612,6 +638,956 @@ split_loop (class loop *loop1, class tree_niter_desc *niter)\n   return changed;\n }\n \n+/* Another transformation of loops like:\n+\n+   for (i = INIT (); CHECK (i); i = NEXT ())\n+     {\n+       if (expr (a_1, a_2, ..., a_n))  // expr is pure\n+         a_j = ...;  // change at least one a_j\n+       else\n+         S;          // not change any a_j\n+     }\n+\n+   into:\n+\n+   for (i = INIT (); CHECK (i); i = NEXT ())\n+     {\n+       if (expr (a_1, a_2, ..., a_n))\n+         a_j = ...;\n+       else\n+         {\n+           S;\n+           i = NEXT ();\n+           break;\n+         }\n+     }\n+\n+   for (; CHECK (i); i = NEXT ())\n+     {\n+       S;\n+     }\n+\n+   */\n+\n+/* Data structure to hold temporary information during loop split upon\n+   semi-invariant conditional statement.  */\n+class split_info {\n+public:\n+  /* Array of all basic blocks in a loop, returned by get_loop_body().  */\n+  basic_block *bbs;\n+\n+  /* All memory store/clobber statements in a loop.  */\n+  auto_vec<gimple *> memory_stores;\n+\n+  /* Whether above memory stores vector has been filled.  */\n+  int need_init;\n+\n+  /* Control dependencies of basic blocks in a loop.  */\n+  auto_vec<hash_set<basic_block> *> control_deps;\n+\n+  split_info () : bbs (NULL),  need_init (true) { }\n+\n+  ~split_info ()\n+    {\n+      if (bbs)\n+\tfree (bbs);\n+\n+      for (unsigned i = 0; i < control_deps.length (); i++)\n+\tdelete control_deps[i];\n+    }\n+};\n+\n+/* Find all statements with memory-write effect in LOOP, including memory\n+   store and non-pure function call, and keep those in a vector.  This work\n+   is only done one time, for the vector should be constant during analysis\n+   stage of semi-invariant condition.  */\n+\n+static void\n+find_vdef_in_loop (struct loop *loop)\n+{\n+  split_info *info = (split_info *) loop->aux;\n+  gphi *vphi = get_virtual_phi (loop->header);\n+\n+  /* Indicate memory store vector has been filled.  */\n+  info->need_init = false;\n+\n+  /* If loop contains memory operation, there must be a virtual PHI node in\n+     loop header basic block.  */\n+  if (vphi == NULL)\n+    return;\n+\n+  /* All virtual SSA names inside the loop are connected to be a cyclic\n+     graph via virtual PHI nodes.  The virtual PHI node in loop header just\n+     links the first and the last virtual SSA names, by using the last as\n+     PHI operand to define the first.  */\n+  const edge latch = loop_latch_edge (loop);\n+  const tree first = gimple_phi_result (vphi);\n+  const tree last = PHI_ARG_DEF_FROM_EDGE (vphi, latch);\n+\n+  /* The virtual SSA cyclic graph might consist of only one SSA name, who\n+     is defined by itself.\n+\n+       .MEM_1 = PHI <.MEM_2(loop entry edge), .MEM_1(latch edge)>\n+\n+     This means the loop contains only memory loads, so we can skip it.  */\n+  if (first == last)\n+    return;\n+\n+  auto_vec<gimple *> other_stores;\n+  auto_vec<tree> worklist;\n+  auto_bitmap visited;\n+\n+  bitmap_set_bit (visited, SSA_NAME_VERSION (first));\n+  bitmap_set_bit (visited, SSA_NAME_VERSION (last));\n+  worklist.safe_push (last);\n+\n+  do\n+    {\n+      tree vuse = worklist.pop ();\n+      gimple *stmt = SSA_NAME_DEF_STMT (vuse);\n+\n+      /* We mark the first and last SSA names as visited at the beginning,\n+\t and reversely start the process from the last SSA name towards the\n+\t first, which ensures that this do-while will not touch SSA names\n+\t defined outside the loop.  */\n+      gcc_assert (gimple_bb (stmt)\n+\t\t  && flow_bb_inside_loop_p (loop, gimple_bb (stmt)));\n+\n+      if (gimple_code (stmt) == GIMPLE_PHI)\n+\t{\n+\t  gphi *phi = as_a <gphi *> (stmt);\n+\n+\t  for (unsigned i = 0; i < gimple_phi_num_args (phi); ++i)\n+\t    {\n+\t      tree arg = gimple_phi_arg_def (stmt, i);\n+\n+\t      if (bitmap_set_bit (visited, SSA_NAME_VERSION (arg)))\n+\t\tworklist.safe_push (arg);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  tree prev = gimple_vuse (stmt);\n+\n+\t  /* Non-pure call statement is conservatively assumed to impact all\n+\t     memory locations.  So place call statements ahead of other memory\n+\t     stores in the vector with an idea of of using them as shortcut\n+\t     terminators to memory alias analysis.  */\n+\t  if (gimple_code (stmt) == GIMPLE_CALL)\n+\t    info->memory_stores.safe_push (stmt);\n+\t  else\n+\t    other_stores.safe_push (stmt);\n+\n+\t  if (bitmap_set_bit (visited, SSA_NAME_VERSION (prev)))\n+\t    worklist.safe_push (prev);\n+\t}\n+    } while (!worklist.is_empty ());\n+\n+    info->memory_stores.safe_splice (other_stores);\n+}\n+\n+/* Two basic blocks have equivalent control dependency if one dominates to\n+   the other, and it is post-dominated by the latter.  Given a basic block\n+   BB in LOOP, find farest equivalent dominating basic block.  For BB, there\n+   is a constraint that BB does not post-dominate loop header of LOOP, this\n+   means BB is control-dependent on at least one basic block in LOOP.  */\n+\n+static basic_block\n+get_control_equiv_head_block (struct loop *loop, basic_block bb)\n+{\n+  while (!bb->aux)\n+    {\n+      basic_block dom_bb = get_immediate_dominator (CDI_DOMINATORS, bb);\n+\n+      gcc_checking_assert (dom_bb && flow_bb_inside_loop_p (loop, dom_bb));\n+\n+      if (!dominated_by_p (CDI_POST_DOMINATORS, dom_bb, bb))\n+\tbreak;\n+\n+      bb = dom_bb;\n+    }\n+  return bb;\n+}\n+\n+/* Given a BB in LOOP, find out all basic blocks in LOOP that BB is control-\n+   dependent on.  */\n+\n+static hash_set<basic_block> *\n+find_control_dep_blocks (struct loop *loop, basic_block bb)\n+{\n+  /* BB has same control dependency as loop header, then it is not control-\n+     dependent on any basic block in LOOP.  */\n+  if (dominated_by_p (CDI_POST_DOMINATORS, loop->header, bb))\n+    return NULL;\n+\n+  basic_block equiv_head = get_control_equiv_head_block (loop, bb);\n+\n+  if (equiv_head->aux)\n+    {\n+      /* There is a basic block containing control dependency equivalent\n+\t to BB.  No need to recompute that, and also set this information\n+\t to other equivalent basic blocks.  */\n+      for (; bb != equiv_head;\n+\t   bb = get_immediate_dominator (CDI_DOMINATORS, bb))\n+\tbb->aux = equiv_head->aux;\n+      return (hash_set<basic_block> *) equiv_head->aux;\n+    }\n+\n+  /* A basic block X is control-dependent on another Y iff there exists\n+     a path from X to Y, in which every basic block other than X and Y\n+     is post-dominated by Y, but X is not post-dominated by Y.\n+\n+     According to this rule, traverse basic blocks in the loop backwards\n+     starting from BB, if a basic block is post-dominated by BB, extend\n+     current post-dominating path to this block, otherwise it is another\n+     one that BB is control-dependent on.  */\n+\n+  auto_vec<basic_block> pdom_worklist;\n+  hash_set<basic_block> pdom_visited;\n+  hash_set<basic_block> *dep_bbs = new hash_set<basic_block>;\n+\n+  pdom_worklist.safe_push (equiv_head);\n+\n+  do\n+    {\n+      basic_block pdom_bb = pdom_worklist.pop ();\n+      edge_iterator ei;\n+      edge e;\n+\n+      if (pdom_visited.add (pdom_bb))\n+\tcontinue;\n+\n+      FOR_EACH_EDGE (e, ei, pdom_bb->preds)\n+\t{\n+\t  basic_block pred_bb = e->src;\n+\n+\t  if (!dominated_by_p (CDI_POST_DOMINATORS, pred_bb, bb))\n+\t    {\n+\t      dep_bbs->add (pred_bb);\n+\t      continue;\n+\t    }\n+\n+\t  pred_bb = get_control_equiv_head_block (loop, pred_bb);\n+\n+\t  if (pdom_visited.contains (pred_bb))\n+\t    continue;\n+\n+\t  if (!pred_bb->aux)\n+\t    {\n+\t      pdom_worklist.safe_push (pred_bb);\n+\t      continue;\n+\t    }\n+\n+\t  /* If control dependency of basic block is available, fast extend\n+\t     post-dominating path using the information instead of advancing\n+\t     forward step-by-step.  */\n+\t  hash_set<basic_block> *pred_dep_bbs\n+\t\t\t= (hash_set<basic_block> *) pred_bb->aux;\n+\n+\t  for (hash_set<basic_block>::iterator iter = pred_dep_bbs->begin ();\n+\t       iter != pred_dep_bbs->end (); ++iter)\n+\t    {\n+\t      basic_block pred_dep_bb = *iter;\n+\n+\t      /* Basic blocks can either be in control dependency of BB, or\n+\t\t must be post-dominated by BB, if so, extend the path from\n+\t\t these basic blocks.  */\n+\t      if (!dominated_by_p (CDI_POST_DOMINATORS, pred_dep_bb, bb))\n+\t\tdep_bbs->add (pred_dep_bb);\n+\t      else if (!pdom_visited.contains (pred_dep_bb))\n+\t\tpdom_worklist.safe_push (pred_dep_bb);\n+\t    }\n+\t}\n+    } while (!pdom_worklist.is_empty ());\n+\n+  /* Record computed control dependencies in loop so that we can reach them\n+     when reclaiming resources.  */\n+  ((split_info *) loop->aux)->control_deps.safe_push (dep_bbs);\n+\n+  /* Associate control dependence with related equivalent basic blocks.  */\n+  for (equiv_head->aux = dep_bbs; bb != equiv_head;\n+       bb = get_immediate_dominator (CDI_DOMINATORS, bb))\n+    bb->aux = dep_bbs;\n+\n+  return dep_bbs;\n+}\n+\n+/* Forward declaration */\n+\n+static bool\n+stmt_semi_invariant_p_1 (struct loop *loop, gimple *stmt,\n+\t\t\t const_basic_block skip_head,\n+\t\t\t hash_map<gimple *, bool> &stmt_stat);\n+\n+/* Given STMT, memory load or pure call statement, check whether it is impacted\n+   by some memory store in LOOP, excluding trace starting from SKIP_HEAD (the\n+   trace is composed of SKIP_HEAD and those basic block dominated by it, always\n+   corresponds to one branch of a conditional statement).  If SKIP_HEAD is\n+   NULL, all basic blocks of LOOP are checked.  */\n+\n+static bool\n+vuse_semi_invariant_p (struct loop *loop, gimple *stmt,\n+\t\t       const_basic_block skip_head)\n+{\n+  split_info *info = (split_info *) loop->aux;\n+  tree rhs = NULL_TREE;\n+  ao_ref ref;\n+  gimple *store;\n+  unsigned i;\n+\n+  /* Collect memory store/clobber statements if haven't done that.  */\n+  if (info->need_init)\n+    find_vdef_in_loop (loop);\n+\n+  if (is_gimple_assign (stmt))\n+    rhs = gimple_assign_rhs1 (stmt);\n+\n+  ao_ref_init (&ref, rhs);\n+\n+  FOR_EACH_VEC_ELT (info->memory_stores, i, store)\n+    {\n+      /* Skip basic blocks dominated by SKIP_HEAD, if non-NULL.  */\n+      if (skip_head\n+\t  && dominated_by_p (CDI_DOMINATORS, gimple_bb (store), skip_head))\n+\tcontinue;\n+\n+      if (!ref.ref || stmt_may_clobber_ref_p_1 (store, &ref))\n+\treturn false;\n+    }\n+\n+  return true;\n+}\n+\n+/* Suppose one condition branch, led by SKIP_HEAD, is not executed since\n+   certain iteration of LOOP, check whether an SSA name (NAME) remains\n+   unchanged in next iteration.  We call this characteristic semi-\n+   invariantness.  SKIP_HEAD might be NULL, if so, nothing excluded, all basic\n+   blocks and control flows in the loop will be considered.  Semi-invariant\n+   state of checked statement is cached in hash map STMT_STAT to avoid\n+   redundant computation in possible following re-check.  */\n+\n+static inline bool\n+ssa_semi_invariant_p (struct loop *loop, tree name,\n+\t\t      const_basic_block skip_head,\n+\t\t      hash_map<gimple *, bool> &stmt_stat)\n+{\n+  gimple *def = SSA_NAME_DEF_STMT (name);\n+  const_basic_block def_bb = gimple_bb (def);\n+\n+  /* An SSA name defined outside loop is definitely semi-invariant.  */\n+  if (!def_bb || !flow_bb_inside_loop_p (loop, def_bb))\n+    return true;\n+\n+  return stmt_semi_invariant_p_1 (loop, def, skip_head, stmt_stat);\n+}\n+\n+/* Check whether a loop iteration PHI node (LOOP_PHI) defines a value that is\n+   semi-invariant in LOOP.  Basic blocks dominated by SKIP_HEAD (if non-NULL),\n+   are excluded from LOOP.  */\n+\n+static bool\n+loop_iter_phi_semi_invariant_p (struct loop *loop, gphi *loop_phi,\n+\t\t\t\tconst_basic_block skip_head)\n+{\n+  const_edge latch = loop_latch_edge (loop);\n+  tree name = gimple_phi_result (loop_phi);\n+  tree from = PHI_ARG_DEF_FROM_EDGE (loop_phi, latch);\n+\n+  gcc_checking_assert (from);\n+\n+  /* Loop iteration PHI node locates in loop header, and it has two source\n+     operands, one is an initial value coming from outside the loop, the other\n+     is a value through latch of the loop, which is derived in last iteration,\n+     we call the latter latch value.  From the PHI node to definition of latch\n+     value, if excluding branch trace starting from SKIP_HEAD, except copy-\n+     assignment or likewise, there is no other kind of value redefinition, SSA\n+     name defined by the PHI node is semi-invariant.\n+\n+                         loop entry\n+                              |     .--- latch ---.\n+                              |     |             |\n+                              v     v             |\n+                  x_1 = PHI <x_0,  x_3>           |\n+                           |                      |\n+                           v                      |\n+              .------- if (cond) -------.         |\n+              |                         |         |\n+              |                     [ SKIP ]      |\n+              |                         |         |\n+              |                     x_2 = ...     |\n+              |                         |         |\n+              '---- T ---->.<---- F ----'         |\n+                           |                      |\n+                           v                      |\n+                  x_3 = PHI <x_1, x_2>            |\n+                           |                      |\n+                           '----------------------'\n+\n+     Suppose in certain iteration, execution flow in above graph goes through\n+     true branch, which means that one source value to define x_3 in false\n+     branch (x_2) is skipped, x_3 only comes from x_1, and x_1 in next\n+     iterations is defined by x_3, we know that x_1 will never changed if COND\n+     always chooses true branch from then on.  */\n+\n+  while (from != name)\n+    {\n+      /* A new value comes from a CONSTANT.  */\n+      if (TREE_CODE (from) != SSA_NAME)\n+\treturn false;\n+\n+      gimple *stmt = SSA_NAME_DEF_STMT (from);\n+      const_basic_block bb = gimple_bb (stmt);\n+\n+      /* A new value comes from outside the loop.  */\n+      if (!bb || !flow_bb_inside_loop_p (loop, bb))\n+\treturn false;\n+\n+      from = NULL_TREE;\n+\n+      if (gimple_code (stmt) == GIMPLE_PHI)\n+\t{\n+\t  gphi *phi = as_a <gphi *> (stmt);\n+\n+\t  for (unsigned i = 0; i < gimple_phi_num_args (phi); ++i)\n+\t    {\n+\t      if (skip_head)\n+\t\t{\n+\t\t  const_edge e = gimple_phi_arg_edge (phi, i);\n+\n+\t\t  /* Don't consider redefinitions in excluded basic blocks.  */\n+\t\t  if (dominated_by_p (CDI_DOMINATORS, e->src, skip_head))\n+\t\t    continue;\n+\t\t}\n+\n+\t      tree arg = gimple_phi_arg_def (phi, i);\n+\n+\t      if (!from)\n+\t\tfrom = arg;\n+\t      else if (!operand_equal_p (from, arg, 0))\n+\t\t/* There are more than one source operands that provide\n+\t\t   different values to the SSA name, it is variant.  */\n+\t\treturn false;\n+\t    }\n+\t}\n+      else if (gimple_code (stmt) == GIMPLE_ASSIGN)\n+\t{\n+\t  /* For simple value copy, check its rhs instead.  */\n+\t  if (gimple_assign_ssa_name_copy_p (stmt))\n+\t    from = gimple_assign_rhs1 (stmt);\n+\t}\n+\n+      /* Any other kind of definition is deemed to introduce a new value\n+\t to the SSA name.  */\n+      if (!from)\n+\treturn false;\n+    }\n+  return true;\n+}\n+\n+/* Check whether conditional predicates that BB is control-dependent on, are\n+   semi-invariant in LOOP.  Basic blocks dominated by SKIP_HEAD (if non-NULL),\n+   are excluded from LOOP.  Semi-invariant state of checked statement is cached\n+   in hash map STMT_STAT.  */\n+\n+static bool\n+control_dep_semi_invariant_p (struct loop *loop, basic_block bb,\n+\t\t\t      const_basic_block skip_head,\n+\t\t\t      hash_map<gimple *, bool> &stmt_stat)\n+{\n+  hash_set<basic_block> *dep_bbs = find_control_dep_blocks (loop, bb);\n+\n+  if (!dep_bbs)\n+    return true;\n+\n+  for (hash_set<basic_block>::iterator iter = dep_bbs->begin ();\n+       iter != dep_bbs->end (); ++iter)\n+    {\n+      gimple *last = last_stmt (*iter);\n+\n+      if (!last)\n+\treturn false;\n+\n+      /* Only check condition predicates.  */\n+      if (gimple_code (last) != GIMPLE_COND\n+\t  && gimple_code (last) != GIMPLE_SWITCH)\n+\treturn false;\n+\n+      if (!stmt_semi_invariant_p_1 (loop, last, skip_head, stmt_stat))\n+\treturn false;\n+    }\n+\n+  return true;\n+}\n+\n+/* Check whether STMT is semi-invariant in LOOP, iff all its operands are\n+   semi-invariant, consequently, all its defined values are semi-invariant.\n+   Basic blocks dominated by SKIP_HEAD (if non-NULL), are excluded from LOOP.\n+   Semi-invariant state of checked statement is cached in hash map\n+   STMT_STAT.  */\n+\n+static bool\n+stmt_semi_invariant_p_1 (struct loop *loop, gimple *stmt,\n+\t\t\t const_basic_block skip_head,\n+\t\t\t hash_map<gimple *, bool> &stmt_stat)\n+{\n+  bool existed;\n+  bool &invar = stmt_stat.get_or_insert (stmt, &existed);\n+\n+  if (existed)\n+    return invar;\n+\n+  /* A statement might depend on itself, which is treated as variant.  So set\n+     state of statement under check to be variant to ensure that.  */\n+  invar = false;\n+\n+  if (gimple_code (stmt) == GIMPLE_PHI)\n+    {\n+      gphi *phi = as_a <gphi *> (stmt);\n+\n+      if (gimple_bb (stmt) == loop->header)\n+\t{\n+\t  invar = loop_iter_phi_semi_invariant_p (loop, phi, skip_head);\n+\t  return invar;\n+\t}\n+\n+      /* For a loop PHI node that does not locate in loop header, it is semi-\n+\t invariant only if two conditions are met.  The first is its source\n+\t values are derived from CONSTANT (including loop-invariant value), or\n+\t from SSA name defined by semi-invariant loop iteration PHI node.  The\n+\t second is its source incoming edges are control-dependent on semi-\n+\t invariant conditional predicates.  */\n+      for (unsigned i = 0; i < gimple_phi_num_args (phi); ++i)\n+\t{\n+\t  const_edge e = gimple_phi_arg_edge (phi, i);\n+\t  tree arg = gimple_phi_arg_def (phi, i);\n+\n+\t  if (TREE_CODE (arg) == SSA_NAME)\n+\t    {\n+\t      if (!ssa_semi_invariant_p (loop, arg, skip_head, stmt_stat))\n+\t\treturn false;\n+\n+\t      /* If source value is defined in location from where the source\n+\t\t edge comes in, no need to check control dependency again\n+\t\t since this has been done in above SSA name check stage.  */\n+\t      if (e->src == gimple_bb (SSA_NAME_DEF_STMT (arg)))\n+\t\tcontinue;\n+\t    }\n+\n+\t  if (!control_dep_semi_invariant_p (loop, e->src, skip_head,\n+\t\t\t\t\t     stmt_stat))\n+\t    return false;\n+\t}\n+    }\n+  else\n+    {\n+      ssa_op_iter iter;\n+      tree use;\n+\n+      /* Volatile memory load or return of normal (non-const/non-pure) call\n+\t should not be treated as constant in each iteration of loop.  */\n+      if (gimple_has_side_effects (stmt))\n+\treturn false;\n+\n+      /* Check if any memory store may kill memory load at this place.  */\n+      if (gimple_vuse (stmt) && !vuse_semi_invariant_p (loop, stmt, skip_head))\n+\treturn false;\n+\n+      /* Although operand of a statement might be SSA name, CONSTANT or\n+\t VARDECL, here we only need to check SSA name operands.  This is\n+\t because check on VARDECL operands, which involve memory loads,\n+\t must have been done prior to invocation of this function in\n+\t vuse_semi_invariant_p.  */\n+      FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_USE)\n+\tif (!ssa_semi_invariant_p (loop, use, skip_head, stmt_stat))\n+\t  return false;\n+    }\n+\n+  if (!control_dep_semi_invariant_p (loop, gimple_bb (stmt), skip_head,\n+\t\t\t\t     stmt_stat))\n+    return false;\n+\n+  /* Here we SHOULD NOT use invar = true, since hash map might be changed due\n+     to new insertion, and thus invar may point to invalid memory.  */\n+  stmt_stat.put (stmt, true);\n+  return true;\n+}\n+\n+/* A helper function to check whether STMT is semi-invariant in LOOP.  Basic\n+   blocks dominated by SKIP_HEAD (if non-NULL), are excluded from LOOP.  */\n+\n+static bool\n+stmt_semi_invariant_p (struct loop *loop, gimple *stmt,\n+\t\t       const_basic_block skip_head)\n+{\n+  hash_map<gimple *, bool> stmt_stat;\n+  return stmt_semi_invariant_p_1 (loop, stmt, skip_head, stmt_stat);\n+}\n+\n+/* Determine when conditional statement never transfers execution to one of its\n+   branch, whether we can remove the branch's leading basic block (BRANCH_BB)\n+   and those basic blocks dominated by BRANCH_BB.  */\n+\n+static bool\n+branch_removable_p (basic_block branch_bb)\n+{\n+  edge_iterator ei;\n+  edge e;\n+\n+  if (single_pred_p (branch_bb))\n+    return true;\n+\n+  FOR_EACH_EDGE (e, ei, branch_bb->preds)\n+    {\n+      if (dominated_by_p (CDI_DOMINATORS, e->src, branch_bb))\n+\tcontinue;\n+\n+      if (dominated_by_p (CDI_DOMINATORS, branch_bb, e->src))\n+\tcontinue;\n+\n+       /* The branch can be reached from opposite branch, or from some\n+\t  statement not dominated by the conditional statement.  */\n+      return false;\n+    }\n+\n+  return true;\n+}\n+\n+/* Find out which branch of a conditional statement (COND) is invariant in the\n+   execution context of LOOP.  That is: once the branch is selected in certain\n+   iteration of the loop, any operand that contributes to computation of the\n+   conditional statement remains unchanged in all following iterations.  */\n+\n+static edge\n+get_cond_invariant_branch (struct loop *loop, gcond *cond)\n+{\n+  basic_block cond_bb = gimple_bb (cond);\n+  basic_block targ_bb[2];\n+  bool invar[2];\n+  unsigned invar_checks = 0;\n+\n+  for (unsigned i = 0; i < 2; i++)\n+    {\n+      targ_bb[i] = EDGE_SUCC (cond_bb, i)->dest;\n+\n+      /* One branch directs to loop exit, no need to perform loop split upon\n+\t this conditional statement.  Firstly, it is trivial if the exit branch\n+\t is semi-invariant, for the statement is just to break loop.  Secondly,\n+\t if the opposite branch is semi-invariant, it means that the statement\n+\t is real loop-invariant, which is covered by loop unswitch.  */\n+      if (!flow_bb_inside_loop_p (loop, targ_bb[i]))\n+\treturn NULL;\n+    }\n+\n+  for (unsigned i = 0; i < 2; i++)\n+    {\n+      invar[!i] = false;\n+\n+      if (!branch_removable_p (targ_bb[i]))\n+\tcontinue;\n+\n+      /* Given a semi-invariant branch, if its opposite branch dominates\n+\t loop latch, it and its following trace will only be executed in\n+\t final iteration of loop, namely it is not part of repeated body\n+\t of the loop.  Similar to the above case that the branch is loop\n+\t exit, no need to split loop.  */\n+      if (dominated_by_p (CDI_DOMINATORS, loop->latch, targ_bb[i]))\n+\tcontinue;\n+\n+      invar[!i] = stmt_semi_invariant_p (loop, cond, targ_bb[i]);\n+      invar_checks++;\n+    }\n+\n+  /* With both branches being invariant (handled by loop unswitch) or\n+     variant is not what we want.  */\n+  if (invar[0] ^ !invar[1])\n+    return NULL;\n+\n+  /* Found a real loop-invariant condition, do nothing.  */\n+  if (invar_checks < 2 && stmt_semi_invariant_p (loop, cond, NULL))\n+    return NULL;\n+\n+  return EDGE_SUCC (cond_bb, invar[0] ? 0 : 1);\n+}\n+\n+/* Calculate increased code size measured by estimated insn number if applying\n+   loop split upon certain branch (BRANCH_EDGE) of a conditional statement.  */\n+\n+static int\n+compute_added_num_insns (struct loop *loop, const_edge branch_edge)\n+{\n+  basic_block cond_bb = branch_edge->src;\n+  unsigned branch = EDGE_SUCC (cond_bb, 1) == branch_edge;\n+  basic_block opposite_bb = EDGE_SUCC (cond_bb, !branch)->dest;\n+  basic_block *bbs = ((split_info *) loop->aux)->bbs;\n+  int num = 0;\n+\n+  for (unsigned i = 0; i < loop->num_nodes; i++)\n+    {\n+      /* Do no count basic blocks only in opposite branch.  */\n+      if (dominated_by_p (CDI_DOMINATORS, bbs[i], opposite_bb))\n+\tcontinue;\n+\n+      num += estimate_num_insns_seq (bb_seq (bbs[i]), &eni_size_weights);\n+    }\n+\n+  /* It is unnecessary to evaluate expression of the conditional statement\n+     in new loop that contains only invariant branch.  This expression should\n+     be constant value (either true or false).  Exclude code size of insns\n+     that contribute to computation of the expression.  */\n+\n+  auto_vec<gimple *> worklist;\n+  hash_set<gimple *> removed;\n+  gimple *stmt = last_stmt (cond_bb);\n+\n+  worklist.safe_push (stmt);\n+  removed.add (stmt);\n+  num -= estimate_num_insns (stmt, &eni_size_weights);\n+\n+  do\n+    {\n+      ssa_op_iter opnd_iter;\n+      use_operand_p opnd_p;\n+\n+      stmt = worklist.pop ();\n+      FOR_EACH_PHI_OR_STMT_USE (opnd_p, stmt, opnd_iter, SSA_OP_USE)\n+\t{\n+\t  tree opnd = USE_FROM_PTR (opnd_p);\n+\n+\t  if (TREE_CODE (opnd) != SSA_NAME || SSA_NAME_IS_DEFAULT_DEF (opnd))\n+\t    continue;\n+\n+\t  gimple *opnd_stmt = SSA_NAME_DEF_STMT (opnd);\n+\t  use_operand_p use_p;\n+\t  imm_use_iterator use_iter;\n+\n+\t  if (removed.contains (opnd_stmt)\n+\t      || !flow_bb_inside_loop_p (loop, gimple_bb (opnd_stmt)))\n+\t    continue;\n+\n+\t  FOR_EACH_IMM_USE_FAST (use_p, use_iter, opnd)\n+\t    {\n+\t      gimple *use_stmt = USE_STMT (use_p);\n+\n+\t      if (!is_gimple_debug (use_stmt) && !removed.contains (use_stmt))\n+\t\t{\n+\t\t  opnd_stmt = NULL;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\n+\t  if (opnd_stmt)\n+\t    {\n+\t      worklist.safe_push (opnd_stmt);\n+\t      removed.add (opnd_stmt);\n+\t      num -= estimate_num_insns (opnd_stmt, &eni_size_weights);\n+\t    }\n+\t}\n+    } while (!worklist.is_empty ());\n+\n+  gcc_assert (num >= 0);\n+  return num;\n+}\n+\n+/* Find out loop-invariant branch of a conditional statement (COND) if it has,\n+   and check whether it is eligible and profitable to perform loop split upon\n+   this branch in LOOP.  */\n+\n+static edge\n+get_cond_branch_to_split_loop (struct loop *loop, gcond *cond)\n+{\n+  edge invar_branch = get_cond_invariant_branch (loop, cond);\n+  if (!invar_branch)\n+    return NULL;\n+\n+  /* When accurate profile information is available, and execution\n+     frequency of the branch is too low, just let it go.  */\n+  profile_probability prob = invar_branch->probability;\n+  if (prob.reliable_p ())\n+    {\n+      int thres = PARAM_VALUE (PARAM_MIN_LOOP_COND_SPLIT_PROB);\n+\n+      if (prob < profile_probability::always ().apply_scale (thres, 100))\n+\treturn NULL;\n+    }\n+\n+  /* Add a threshold for increased code size to disable loop split.  */\n+  if (compute_added_num_insns (loop, invar_branch)\n+      > PARAM_VALUE (PARAM_MAX_PEELED_INSNS))\n+    return NULL;\n+\n+  return invar_branch;\n+}\n+\n+/* Given a loop (LOOP1) with a loop-invariant branch (INVAR_BRANCH) of some\n+   conditional statement, perform loop split transformation illustrated\n+   as the following graph.\n+\n+               .-------T------ if (true) ------F------.\n+               |                    .---------------. |\n+               |                    |               | |\n+               v                    |               v v\n+          pre-header                |            pre-header\n+               | .------------.     |                 | .------------.\n+               | |            |     |                 | |            |\n+               | v            |     |                 | v            |\n+             header           |     |               header           |\n+               |              |     |                 |              |\n+      .--- if (cond) ---.     |     |        .--- if (true) ---.     |\n+      |                 |     |     |        |                 |     |\n+  invariant             |     |     |    invariant             |     |\n+      |                 |     |     |        |                 |     |\n+      '---T--->.<---F---'     |     |        '---T--->.<---F---'     |\n+               |              |    /                  |              |\n+             stmts            |   /                 stmts            |\n+               |              F  T                    |              |\n+              / \\             | /                    / \\             |\n+     .-------*   *      [ if (cond) ]       .-------*   *            |\n+     |           |            |             |           |            |\n+     |         latch          |             |         latch          |\n+     |           |            |             |           |            |\n+     |           '------------'             |           '------------'\n+     '------------------------. .-----------'\n+             loop1            | |                   loop2\n+                              v v\n+                             exits\n+\n+   In the graph, loop1 represents the part derived from original one, and\n+   loop2 is duplicated using loop_version (), which corresponds to the part\n+   of original one being splitted out.  In original latch edge of loop1, we\n+   insert a new conditional statement duplicated from the semi-invariant cond,\n+   and one of its branch goes back to loop1 header as a latch edge, and the\n+   other branch goes to loop2 pre-header as an entry edge.  And also in loop2,\n+   we abandon the variant branch of the conditional statement by setting a\n+   constant bool condition, based on which branch is semi-invariant.  */\n+\n+static bool\n+do_split_loop_on_cond (struct loop *loop1, edge invar_branch)\n+{\n+  basic_block cond_bb = invar_branch->src;\n+  bool true_invar = !!(invar_branch->flags & EDGE_TRUE_VALUE);\n+  gcond *cond = as_a <gcond *> (last_stmt (cond_bb));\n+\n+  gcc_assert (cond_bb->loop_father == loop1);\n+\n+  if (dump_enabled_p ())\n+    dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, cond,\n+\t\t     \"loop split on semi-invariant condition at %s branch\\n\",\n+\t\t     true_invar ? \"true\" : \"false\");\n+\n+  initialize_original_copy_tables ();\n+\n+  struct loop *loop2 = loop_version (loop1, boolean_true_node, NULL,\n+\t\t\t\t     profile_probability::always (),\n+\t\t\t\t     profile_probability::never (),\n+\t\t\t\t     profile_probability::always (),\n+\t\t\t\t     profile_probability::always (),\n+\t\t\t\t     true);\n+  if (!loop2)\n+    {\n+      free_original_copy_tables ();\n+      return false;\n+    }\n+\n+  basic_block cond_bb_copy = get_bb_copy (cond_bb);\n+  gcond *cond_copy = as_a<gcond *> (last_stmt (cond_bb_copy));\n+\n+  /* Replace the condition in loop2 with a bool constant to let PassManager\n+     remove the variant branch after current pass completes.  */\n+  if (true_invar)\n+    gimple_cond_make_true (cond_copy);\n+  else\n+    gimple_cond_make_false (cond_copy);\n+\n+  update_stmt (cond_copy);\n+\n+  /* Insert a new conditional statement on latch edge of loop1, its condition\n+     is duplicated from the semi-invariant.  This statement acts as a switch\n+     to transfer execution from loop1 to loop2, when loop1 enters into\n+     invariant state.  */\n+  basic_block latch_bb = split_edge (loop_latch_edge (loop1));\n+  basic_block break_bb = split_edge (single_pred_edge (latch_bb));\n+  gimple *break_cond = gimple_build_cond (gimple_cond_code(cond),\n+\t\t\t\t\t  gimple_cond_lhs (cond),\n+\t\t\t\t\t  gimple_cond_rhs (cond),\n+\t\t\t\t\t  NULL_TREE, NULL_TREE);\n+\n+  gimple_stmt_iterator gsi = gsi_last_bb (break_bb);\n+  gsi_insert_after (&gsi, break_cond, GSI_NEW_STMT);\n+\n+  edge to_loop1 = single_succ_edge (break_bb);\n+  edge to_loop2 = make_edge (break_bb, loop_preheader_edge (loop2)->src, 0);\n+\n+  to_loop1->flags &= ~EDGE_FALLTHRU;\n+  to_loop1->flags |= true_invar ? EDGE_FALSE_VALUE : EDGE_TRUE_VALUE;\n+  to_loop2->flags |= true_invar ? EDGE_TRUE_VALUE : EDGE_FALSE_VALUE;\n+\n+  update_ssa (TODO_update_ssa);\n+\n+  /* Due to introduction of a control flow edge from loop1 latch to loop2\n+     pre-header, we should update PHIs in loop2 to reflect this connection\n+     between loop1 and loop2.  */\n+  connect_loop_phis (loop1, loop2, to_loop2);\n+\n+  free_original_copy_tables ();\n+\n+  rewrite_into_loop_closed_ssa_1 (NULL, 0, SSA_OP_USE, loop1);\n+\n+  return true;\n+}\n+\n+/* Traverse all conditional statements in LOOP, to find out a good candidate\n+   upon which we can do loop split.  */\n+\n+static bool\n+split_loop_on_cond (struct loop *loop)\n+{\n+  split_info *info = new split_info ();\n+  basic_block *bbs = info->bbs = get_loop_body (loop);\n+  bool do_split = false;\n+\n+  /* Allocate an area to keep temporary info, and associate its address\n+     with loop aux field.  */\n+  loop->aux = info;\n+\n+  for (unsigned i = 0; i < loop->num_nodes; i++)\n+    bbs[i]->aux = NULL;\n+\n+  for (unsigned i = 0; i < loop->num_nodes; i++)\n+    {\n+      basic_block bb = bbs[i];\n+\n+      /* We only consider conditional statement, which be executed at most once\n+\t in each iteration of the loop.  So skip statements in inner loops.  */\n+      if ((bb->loop_father != loop) || (bb->flags & BB_IRREDUCIBLE_LOOP))\n+\tcontinue;\n+\n+      /* Actually this check is not a must constraint.  With it, we can ensure\n+\t conditional statement will always be executed in each iteration.  */\n+      if (!dominated_by_p (CDI_DOMINATORS, loop->latch, bb))\n+\tcontinue;\n+\n+      gimple *last = last_stmt (bb);\n+\n+      if (!last || gimple_code (last) != GIMPLE_COND)\n+\tcontinue;\n+\n+      gcond *cond = as_a <gcond *> (last);\n+      edge branch_edge = get_cond_branch_to_split_loop (loop, cond);\n+\n+      if (branch_edge)\n+\t{\n+\t  do_split_loop_on_cond (loop, branch_edge);\n+\t  do_split = true;\n+\t  break;\n+\t}\n+    }\n+\n+  delete info;\n+  loop->aux = NULL;\n+\n+  return do_split;\n+}\n+\n /* Main entry point.  Perform loop splitting on all suitable loops.  */\n \n static unsigned int\n@@ -621,13 +1597,15 @@ tree_ssa_split_loops (void)\n   bool changed = false;\n \n   gcc_assert (scev_initialized_p ());\n+\n+  calculate_dominance_info (CDI_POST_DOMINATORS);\n+\n   FOR_EACH_LOOP (loop, LI_INCLUDE_ROOT)\n     loop->aux = NULL;\n \n   /* Go through all loops starting from innermost.  */\n   FOR_EACH_LOOP (loop, LI_FROM_INNERMOST)\n     {\n-      class tree_niter_desc niter;\n       if (loop->aux)\n \t{\n \t  /* If any of our inner loops was split, don't split us,\n@@ -636,35 +1614,24 @@ tree_ssa_split_loops (void)\n \t  continue;\n \t}\n \n-      if (single_exit (loop)\n-\t  /* ??? We could handle non-empty latches when we split\n-\t     the latch edge (not the exit edge), and put the new\n-\t     exit condition in the new block.  OTOH this executes some\n-\t     code unconditionally that might have been skipped by the\n-\t     original exit before.  */\n-\t  && empty_block_p (loop->latch)\n-\t  && !optimize_loop_for_size_p (loop)\n-\t  && easy_exit_values (loop)\n-\t  && number_of_iterations_exit (loop, single_exit (loop), &niter,\n-\t\t\t\t\tfalse, true)\n-\t  && niter.cmp != ERROR_MARK\n-\t  /* We can't yet handle loops controlled by a != predicate.  */\n-\t  && niter.cmp != NE_EXPR\n-\t  && can_duplicate_loop_p (loop))\n+      if (optimize_loop_for_size_p (loop))\n+\tcontinue;\n+\n+      if (split_loop (loop) || split_loop_on_cond (loop))\n \t{\n-\t  if (split_loop (loop, &niter))\n-\t    {\n-\t      /* Mark our containing loop as having had some split inner\n-\t         loops.  */\n-\t      loop_outer (loop)->aux = loop;\n-\t      changed = true;\n-\t    }\n+\t  /* Mark our containing loop as having had some split inner loops.  */\n+\t  loop_outer (loop)->aux = loop;\n+\t  changed = true;\n \t}\n     }\n \n   FOR_EACH_LOOP (loop, LI_INCLUDE_ROOT)\n     loop->aux = NULL;\n \n+  clear_aux_for_blocks ();\n+\n+  free_dominance_info (CDI_POST_DOMINATORS);\n+\n   if (changed)\n     return TODO_cleanup_cfg;\n   return 0;"}]}