{"sha": "e730a0ef11a788bb00034e007b320c6608c17e66", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTczMGEwZWYxMWE3ODhiYjAwMDM0ZTAwN2IzMjBjNjYwOGMxN2U2Ng==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2018-07-07T10:46:10Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2018-07-07T10:46:10Z"}, "message": "c-ada-spec.c (to_ada_name): Remove index parameter.\n\n\t* c-ada-spec.c (to_ada_name): Remove index parameter.\n\t(pp_ada_tree_identifier): Likewise.\n\t(dump_ada_macros): Adjust call to to_ada_name.\n\t(struct overloaded_name_hash): Delete.\n\t(struct overloaded_name_hasher): Likewise.\n\t(overloaded_names): Likewise.\n\t(compute_overloading_index): Likewise.\n\t(dump_ada_decl_name): Do not call compute_overloading_index and\n\tadjust calls to pp_ada_tree_identifier.\n\t(dump_ada_double_name): Adjust calls to pp_ada_tree_identifier.\n\t(dump_ada_import): Add spc parameter and switch to aspect syntax.\n\t(dump_ada_function_declaration): Adjust call to pp_ada_tree_identifier.\n\t(dump_ada_enum_type): Remove type and display_convention parameters.\n\tAdjust calls to pp_ada_tree_identifier.\n\t(dump_ada_node): Likewise and for dump_ada_structure.\n\t(dump_nested_type) <ENUMERAL_TYPE>: Adjust call to dump_ada_enum_type\n\tand tidy up.\n\t<RECORD_TYPE>: Adjust call to dump_ada_structure and switch to aspect\n\tsyntax.\n\t(print_constructor): Adjust call to pp_ada_tree_identifier.\n\t(print_destructor): Likewise.\n\t(dump_ada_declaration): Switch to aspect syntax.\n\t(dump_ada_structure): Likewise and tidy up.  Replace display_convention\n\tparameter with nested parameter.\n\t(dump_ads): Emit pragma Ada_2012 in lieu of pragma Ada_2005.\n\t(dump_ada_specs): Do not delete overloaded_names table.\n\nFrom-SVN: r262499", "tree": {"sha": "8f5a53d62ff14fa3e45f5d5e759e99d9f274ae0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8f5a53d62ff14fa3e45f5d5e759e99d9f274ae0c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e730a0ef11a788bb00034e007b320c6608c17e66", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e730a0ef11a788bb00034e007b320c6608c17e66", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e730a0ef11a788bb00034e007b320c6608c17e66", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e730a0ef11a788bb00034e007b320c6608c17e66/comments", "author": null, "committer": null, "parents": [{"sha": "87668878151c9d5aba57357368d3a90277c6b87f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87668878151c9d5aba57357368d3a90277c6b87f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87668878151c9d5aba57357368d3a90277c6b87f"}], "stats": {"total": 353, "additions": 135, "deletions": 218}, "files": [{"sha": "bf4e7e9bd89a54fb146b13c838c5a2cdb768f957", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e730a0ef11a788bb00034e007b320c6608c17e66/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e730a0ef11a788bb00034e007b320c6608c17e66/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=e730a0ef11a788bb00034e007b320c6608c17e66", "patch": "@@ -1,7 +1,36 @@\n+2018-07-07  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* c-ada-spec.c (to_ada_name): Remove index parameter.\n+\t(pp_ada_tree_identifier): Likewise.\n+\t(dump_ada_macros): Adjust call to to_ada_name.\n+\t(struct overloaded_name_hash): Delete.\n+\t(struct overloaded_name_hasher): Likewise.\n+\t(overloaded_names): Likewise.\n+\t(compute_overloading_index): Likewise.\n+\t(dump_ada_decl_name): Do not call compute_overloading_index and\n+\tadjust calls to pp_ada_tree_identifier.\n+\t(dump_ada_double_name): Adjust calls to pp_ada_tree_identifier.\n+\t(dump_ada_import): Add spc parameter and switch to aspect syntax.\n+\t(dump_ada_function_declaration): Adjust call to pp_ada_tree_identifier.\n+\t(dump_ada_enum_type): Remove type and display_convention parameters.\n+\tAdjust calls to pp_ada_tree_identifier.\n+\t(dump_ada_node): Likewise and for dump_ada_structure.\n+\t(dump_nested_type) <ENUMERAL_TYPE>: Adjust call to dump_ada_enum_type\n+\tand tidy up.\n+\t<RECORD_TYPE>: Adjust call to dump_ada_structure and switch to aspect\n+\tsyntax.\n+\t(print_constructor): Adjust call to pp_ada_tree_identifier.\n+\t(print_destructor): Likewise.\n+\t(dump_ada_declaration): Switch to aspect syntax.\n+\t(dump_ada_structure): Likewise and tidy up.  Replace display_convention\n+\tparameter with nested parameter.\n+\t(dump_ads): Emit pragma Ada_2012 in lieu of pragma Ada_2005.\n+\t(dump_ada_specs): Do not delete overloaded_names table.\n+\n 2018-07-06  Peter Bergner  <bergner@linux.ibm.com>\n \n \tPR target/86324\n-\t* c-attribs.c (handle_mode_attribute): Call new translate_mode_attribute\n+\t* c-attribs.c (handle_mode_attribute): Call translate_mode_attribute\n \ttarget hook.\n \n 2018-07-05  Nathan Sidwell  <nathan@acm.org>"}, {"sha": "9c7de23a04ec8b41d9fbbd84a50ceb8dda898b39", "filename": "gcc/c-family/c-ada-spec.c", "status": "modified", "additions": 105, "deletions": 217, "changes": 322, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e730a0ef11a788bb00034e007b320c6608c17e66/gcc%2Fc-family%2Fc-ada-spec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e730a0ef11a788bb00034e007b320c6608c17e66/gcc%2Fc-family%2Fc-ada-spec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-ada-spec.c?ref=e730a0ef11a788bb00034e007b320c6608c17e66", "patch": "@@ -34,8 +34,8 @@ along with GCC; see the file COPYING3.  If not see\n /* Local functions, macros and variables.  */\n static int  dump_ada_node (pretty_printer *, tree, tree, int, bool, bool);\n static int  dump_ada_declaration (pretty_printer *, tree, tree, int);\n-static void dump_ada_structure (pretty_printer *, tree, tree, int, bool);\n-static char *to_ada_name (const char *, unsigned int, bool *);\n+static void dump_ada_structure (pretty_printer *, tree, tree, bool, int);\n+static char *to_ada_name (const char *, bool *);\n \n #define INDENT(SPACE) \\\n   do { int i; for (i = 0; i<SPACE; i++) pp_space (buffer); } while (0)\n@@ -591,7 +591,7 @@ dump_ada_macros (pretty_printer *pp, const char* file)\n \t  prev_line = sloc.line;\n \n \t  pp_string (pp, \"   \");\n-\t  ada_name = to_ada_name ((const char *) NODE_NAME (node), 0, NULL);\n+\t  ada_name = to_ada_name ((const char *) NODE_NAME (node), NULL);\n \t  pp_string (pp, ada_name);\n \t  free (ada_name);\n \t  pp_string (pp, \" : \");\n@@ -1095,17 +1095,17 @@ has_nontrivial_methods (tree type)\n #define INDEX_LENGTH 8\n \n /* Generate a legal Ada name from a C/C++ NAME and return a malloc'ed string.\n-   INDEX, if non-zero, is used to disambiguate overloaded names.  SPACE_FOUND,\n-   if not NULL, is used to indicate whether a space was found in NAME.  */\n+   SPACE_FOUND, if not NULL, is used to indicate whether a space was found in\n+   NAME.  */\n \n static char *\n-to_ada_name (const char *name, unsigned int index, bool *space_found)\n+to_ada_name (const char *name, bool *space_found)\n {\n   const char **names;\n   const int len = strlen (name);\n   int j, len2 = 0;\n   bool found = false;\n-  char *s = XNEWVEC (char, len * 2 + 5 + (index ? INDEX_LENGTH : 0));\n+  char *s = XNEWVEC (char, len * 2 + 5);\n   char c;\n \n   if (space_found)\n@@ -1303,10 +1303,7 @@ to_ada_name (const char *name, unsigned int index, bool *space_found)\n   if (s[len2 - 1] == '_')\n     s[len2++] = 'u';\n \n-  if (index)\n-    snprintf (&s[len2], INDEX_LENGTH, \"_u_%d\", index + 1);\n-  else\n-    s[len2] = '\\0';\n+  s[len2] = '\\0';\n \n   return s;\n }\n@@ -1324,17 +1321,16 @@ separate_class_package (tree decl)\n static bool package_prefix = true;\n \n /* Dump in BUFFER the name of an identifier NODE of type TYPE, following Ada\n-   syntax.  INDEX, if non-zero, is used to disambiguate overloaded names.\n-   LIMITED_ACCESS indicates whether NODE can be accessed via a limited\n-   'with' clause rather than a regular 'with' clause.  */\n+   syntax.  LIMITED_ACCESS indicates whether NODE can be accessed through a\n+   limited 'with' clause rather than a regular 'with' clause.  */\n \n static void\n pp_ada_tree_identifier (pretty_printer *buffer, tree node, tree type,\n-\t\t\tunsigned int index, bool limited_access)\n+\t\t\tbool limited_access)\n {\n   const char *name = IDENTIFIER_POINTER (node);\n   bool space_found = false;\n-  char *s = to_ada_name (name, index, &space_found);\n+  char *s = to_ada_name (name, &space_found);\n   tree decl = get_underlying_decl (type);\n \n   /* If the entity comes from another file, generate a package prefix.  */\n@@ -1446,71 +1442,6 @@ pp_asm_name (pretty_printer *buffer, tree t)\n   pp_string (buffer, ada_name);\n }\n \n-/* Hash table of overloaded names associating identifier nodes with DECL_UIDs.\n-   It is needed in Ada 2005 because we can have at most one import directive\n-   per subprogram name in a given scope, so we have to mangle the subprogram\n-   names on the Ada side to import overloaded subprograms from C++.  */\n-\n-struct overloaded_name_hash {\n-  hashval_t hash;\n-  tree name;\n-  tree context;\n-  vec<unsigned int> homonyms;\n-};\n-\n-struct overloaded_name_hasher : delete_ptr_hash<overloaded_name_hash>\n-{\n-  static inline hashval_t hash (overloaded_name_hash *t)\n-    { return t->hash; }\n-  static inline bool equal (overloaded_name_hash *a, overloaded_name_hash *b)\n-    { return a->name == b->name && a->context == b->context; }\n-};\n-\n-static hash_table<overloaded_name_hasher> *overloaded_names;\n-\n-/* Compute the overloading index of function DECL in its context.  */\n-\n-static unsigned int\n-compute_overloading_index (tree decl)\n-{\n-  const hashval_t hashcode\n-    = iterative_hash_hashval_t (htab_hash_pointer (DECL_NAME (decl)),\n-\t\t\t        htab_hash_pointer (DECL_CONTEXT (decl)));\n-  struct overloaded_name_hash in, *h, **slot;\n-  unsigned int index, *iter;\n-\n-  if (!overloaded_names)\n-    overloaded_names = new hash_table<overloaded_name_hasher> (512);\n-\n-  /* Look up the list of homonyms in the table.  */\n-  in.hash = hashcode;\n-  in.name = DECL_NAME (decl);\n-  in.context = DECL_CONTEXT (decl);\n-  slot = overloaded_names->find_slot_with_hash (&in, hashcode, INSERT);\n-  if (*slot)\n-    h = *slot;\n-  else\n-    {\n-      h = new overloaded_name_hash;\n-      h->hash = hashcode;\n-      h->name = DECL_NAME (decl);\n-      h->context = DECL_CONTEXT (decl);\n-      h->homonyms.create (0);\n-      *slot = h;\n-    }\n-\n-  /* Look up the function in the list of homonyms.  */\n-  FOR_EACH_VEC_ELT (h->homonyms, index, iter)\n-    if (*iter == DECL_UID (decl))\n-      break;\n-\n-  /* If it is not present, push it onto the list.  */\n-  if (!iter)\n-    h->homonyms.safe_push (DECL_UID (decl));\n-\n-  return index;\n-}\n-\n /* Dump in BUFFER the name of a DECL node if set, in Ada syntax.\n    LIMITED_ACCESS indicates whether NODE can be accessed via a\n    limited 'with' clause rather than a regular 'with' clause.  */\n@@ -1519,13 +1450,7 @@ static void\n dump_ada_decl_name (pretty_printer *buffer, tree decl, bool limited_access)\n {\n   if (DECL_NAME (decl))\n-    {\n-      const unsigned int index\n-\t= (TREE_CODE (decl) == FUNCTION_DECL && cpp_check)\n-\t  ? compute_overloading_index (decl) : 0;\n-      pp_ada_tree_identifier (buffer, DECL_NAME (decl), decl, index,\n-\t\t\t      limited_access);\n-    }\n+    pp_ada_tree_identifier (buffer, DECL_NAME (decl), decl, limited_access);\n   else\n     {\n       tree type_name = TYPE_NAME (TREE_TYPE (decl));\n@@ -1539,7 +1464,7 @@ dump_ada_decl_name (pretty_printer *buffer, tree decl, bool limited_access)\n \t    pp_scalar (buffer, \"%d\", TYPE_UID (TREE_TYPE (decl)));\n \t}\n       else if (TREE_CODE (type_name) == IDENTIFIER_NODE)\n-\tpp_ada_tree_identifier (buffer, type_name, decl, 0, limited_access);\n+\tpp_ada_tree_identifier (buffer, type_name, decl, limited_access);\n     }\n }\n \n@@ -1549,7 +1474,7 @@ static void\n dump_ada_double_name (pretty_printer *buffer, tree t1, tree t2)\n {\n   if (DECL_NAME (t1))\n-    pp_ada_tree_identifier (buffer, DECL_NAME (t1), t1, 0, false);\n+    pp_ada_tree_identifier (buffer, DECL_NAME (t1), t1, false);\n   else\n     {\n       pp_string (buffer, \"anon\");\n@@ -1559,7 +1484,7 @@ dump_ada_double_name (pretty_printer *buffer, tree t1, tree t2)\n   pp_underscore (buffer);\n \n   if (DECL_NAME (t2))\n-    pp_ada_tree_identifier (buffer, DECL_NAME (t2), t2, 0, false);\n+    pp_ada_tree_identifier (buffer, DECL_NAME (t2), t2, false);\n   else\n     {\n       pp_string (buffer, \"anon\");\n@@ -1586,32 +1511,38 @@ dump_ada_double_name (pretty_printer *buffer, tree t1, tree t2)\n     }\n }\n \n-/* Dump in BUFFER pragma Import C/CPP on a given node T.  */\n+/* Dump in BUFFER aspect Import on a given node T.  SPC is the current\n+   indentation level.  */\n \n static void\n-dump_ada_import (pretty_printer *buffer, tree t)\n+dump_ada_import (pretty_printer *buffer, tree t, int spc)\n {\n   const char *name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (t));\n   const bool is_stdcall\n     = TREE_CODE (t) == FUNCTION_DECL\n       && lookup_attribute (\"stdcall\", TYPE_ATTRIBUTES (TREE_TYPE (t)));\n \n+  pp_string (buffer, \"with Import => True, \");\n+\n+  newline_and_indent (buffer, spc + 5);\n+\n   if (is_stdcall)\n-    pp_string (buffer, \"pragma Import (Stdcall, \");\n+    pp_string (buffer, \"Convention => Stdcall, \");\n   else if (name[0] == '_' && name[1] == 'Z')\n-    pp_string (buffer, \"pragma Import (CPP, \");\n+    pp_string (buffer, \"Convention => CPP, \");\n   else\n-    pp_string (buffer, \"pragma Import (C, \");\n+    pp_string (buffer, \"Convention => C, \");\n \n-  dump_ada_decl_name (buffer, t, false);\n-  pp_string (buffer, \", \\\"\");\n+  newline_and_indent (buffer, spc + 5);\n+\n+  pp_string (buffer, \"External_Name => \\\"\");\n \n   if (is_stdcall)\n     pp_string (buffer, IDENTIFIER_POINTER (DECL_NAME (t)));\n   else\n     pp_asm_name (buffer, t);\n \n-  pp_string (buffer, \"\\\");\");\n+  pp_string (buffer, \"\\\";\");\n }\n \n /* Check whether T and its type have different names, and append \"the_\"\n@@ -1717,7 +1648,7 @@ dump_ada_function_declaration (pretty_printer *buffer, tree func,\n \t  if (DECL_NAME (arg))\n \t    {\n \t      check_name (buffer, arg);\n-\t      pp_ada_tree_identifier (buffer, DECL_NAME (arg), NULL_TREE, 0,\n+\t      pp_ada_tree_identifier (buffer, DECL_NAME (arg), NULL_TREE,\n \t\t\t\t      false);\n \t      pp_string (buffer, \" : \");\n \t    }\n@@ -2022,13 +1953,11 @@ is_simple_enum (tree node)\n   return true;\n }\n \n-/* Dump in BUFFER an enumeral type NODE of type TYPE in Ada syntax.  SPC is\n-   the indentation level.  If DISPLAY_CONVENTION is true, also print the\n-   pragma Convention for NODE.  */\n+/* Dump in BUFFER an enumeral type NODE in Ada syntax.  SPC is the indentation\n+   level.  */\n \n static void\n-dump_ada_enum_type (pretty_printer *buffer, tree node, tree type, int spc,\n-\t\t    bool display_convention)\n+dump_ada_enum_type (pretty_printer *buffer, tree node, int spc)\n {\n   if (is_simple_enum (node))\n     {\n@@ -2046,19 +1975,12 @@ dump_ada_enum_type (pretty_printer *buffer, tree node, tree type, int spc,\n \t      newline_and_indent (buffer, spc);\n \t    }\n \n-\t  pp_ada_tree_identifier (buffer, TREE_PURPOSE (value), node, 0, false);\n+\t  pp_ada_tree_identifier (buffer, TREE_PURPOSE (value), node, false);\n \t}\n-      pp_string (buffer, \");\");\n+      pp_string (buffer, \")\");\n       spc -= INDENT_INCR;\n       newline_and_indent (buffer, spc);\n-\n-      if (display_convention)\n-\t{\n-\t  pp_string (buffer, \"pragma Convention (C, \");\n-\t  dump_ada_node (buffer, DECL_NAME (type) ? type : TYPE_NAME (node),\n-\t\t     type, spc, false, true);\n-\t  pp_right_paren (buffer);\n-\t}\n+      pp_string (buffer, \"with Convention => C\");\n     }\n   else\n     {\n@@ -2071,7 +1993,7 @@ dump_ada_enum_type (pretty_printer *buffer, tree node, tree type, int spc,\n \t  pp_semicolon (buffer);\n \t  newline_and_indent (buffer, spc);\n \n-\t  pp_ada_tree_identifier (buffer, TREE_PURPOSE (value), node, 0, false);\n+\t  pp_ada_tree_identifier (buffer, TREE_PURPOSE (value), node, false);\n \t  pp_string (buffer, \" : constant \");\n \n \t  if (TYPE_UNSIGNED (node))\n@@ -2110,7 +2032,7 @@ dump_ada_node (pretty_printer *buffer, tree node, tree type, int spc,\n       return 0;\n \n     case IDENTIFIER_NODE:\n-      pp_ada_tree_identifier (buffer, node, type, 0, limited_access);\n+      pp_ada_tree_identifier (buffer, node, type, limited_access);\n       break;\n \n     case TREE_LIST:\n@@ -2149,7 +2071,7 @@ dump_ada_node (pretty_printer *buffer, tree node, tree type, int spc,\n       if (name_only)\n \tdump_ada_node (buffer, TYPE_NAME (node), node, spc, false, true);\n       else\n-\tdump_ada_enum_type (buffer, node, type, spc, true);\n+\tdump_ada_enum_type (buffer, node, spc);\n       break;\n \n     case REAL_TYPE:\n@@ -2171,7 +2093,7 @@ dump_ada_node (pretty_printer *buffer, tree node, tree type, int spc,\n       if (TYPE_NAME (node))\n \t{\n \t  if (TREE_CODE (TYPE_NAME (node)) == IDENTIFIER_NODE)\n-\t    pp_ada_tree_identifier (buffer, TYPE_NAME (node), node, 0,\n+\t    pp_ada_tree_identifier (buffer, TYPE_NAME (node), node,\n \t\t\t\t    limited_access);\n \t  else if (TREE_CODE (TYPE_NAME (node)) == TYPE_DECL\n \t\t   && DECL_NAME (TYPE_NAME (node)))\n@@ -2215,14 +2137,11 @@ dump_ada_node (pretty_printer *buffer, tree node, tree type, int spc,\n \t\t\t\t\t spc + INDENT_INCR);\n \n \t  /* If we are dumping the full type, it means we are part of a\n-\t     type definition and need also a Convention C pragma.  */\n+\t     type definition and need also a Convention C aspect.  */\n \t  if (!name_only)\n \t    {\n-\t      pp_semicolon (buffer);\n \t      newline_and_indent (buffer, spc);\n-\t      pp_string (buffer, \"pragma Convention (C, \");\n-\t      dump_ada_node (buffer, type, NULL_TREE, spc, false, true);\n-\t      pp_right_paren (buffer);\n+\t      pp_string (buffer, \"with Convention => C\");\n \t    }\n \t}\n       else\n@@ -2336,7 +2255,7 @@ dump_ada_node (pretty_printer *buffer, tree node, tree type, int spc,\n \tdump_ada_node (buffer, TYPE_NAME (node), node, spc, limited_access,\n \t\t       true);\n       else\n-\tdump_ada_structure (buffer, node, type, spc, true);\n+\tdump_ada_structure (buffer, node, type, false, spc);\n       break;\n \n     case INTEGER_CST:\n@@ -2607,23 +2526,9 @@ dump_nested_type (pretty_printer *buffer, tree field, tree t, tree parent,\n       else\n \tdump_ada_double_name (buffer, parent, field);\n       pp_string (buffer, \" is \");\n-      dump_ada_enum_type (buffer, field_type, t, spc, false);\n-\n-      if (is_simple_enum (field_type))\n-\t{\n-\t  pp_string (buffer, \"pragma Convention (C, \");\n-\t  if (TYPE_NAME (field_type))\n-\t    dump_ada_node (buffer, field_type, NULL_TREE, spc, false, true);\n-\t  else\n-\t    dump_ada_double_name (buffer, parent, field);\n-\t  pp_string (buffer, \");\");\n-\t  newline_and_indent (buffer, spc);\n-\t}\n-      else\n-\t{\n-\t  pp_semicolon (buffer);\n-\t  newline_and_indent (buffer, spc);\n-\t}\n+      dump_ada_enum_type (buffer, field_type, spc);\n+      pp_semicolon (buffer);\n+      newline_and_indent (buffer, spc);\n       break;\n \n     case RECORD_TYPE:\n@@ -2641,25 +2546,19 @@ dump_nested_type (pretty_printer *buffer, tree field, tree t, tree parent,\n \tpp_string (buffer, \" (discr : unsigned := 0)\");\n \n       pp_string (buffer, \" is \");\n-      dump_ada_structure (buffer, field_type, t, spc, false);\n+      dump_ada_structure (buffer, field_type, t, true, spc);\n \n-      pp_string (buffer, \"pragma Convention (C_Pass_By_Copy, \");\n-      if (TYPE_NAME (field_type))\n-\tdump_ada_node (buffer, field_type, NULL_TREE, spc, false, true);\n-      else\n-\tdump_ada_double_name (buffer, parent, field);\n-      pp_string (buffer, \");\");\n-      newline_and_indent (buffer, spc);\n+      pp_string (buffer, \"with Convention => C_Pass_By_Copy\");\n \n       if (TREE_CODE (field_type) == UNION_TYPE)\n \t{\n-\t  pp_string (buffer, \"pragma Unchecked_Union (\");\n-\t  if (TYPE_NAME (field_type))\n-\t    dump_ada_node (buffer, field_type, NULL_TREE, spc, false, true);\n-\t  else\n-\t    dump_ada_double_name (buffer, parent, field);\n-\t  pp_string (buffer, \");\");\n+\t  pp_comma (buffer);\n+\t  newline_and_indent (buffer, spc + 5);\n+\t  pp_string (buffer, \"Unchecked_Union => True\");\n \t}\n+\n+      pp_semicolon (buffer);\n+      newline_and_indent (buffer, spc);\n       break;\n \n     default:\n@@ -2675,7 +2574,7 @@ print_constructor (pretty_printer *buffer, tree t, tree type)\n   tree decl_name = DECL_NAME (TYPE_NAME (type));\n \n   pp_string (buffer, \"New_\");\n-  pp_ada_tree_identifier (buffer, decl_name, t, 0, false);\n+  pp_ada_tree_identifier (buffer, decl_name, t, false);\n }\n \n /* Dump in BUFFER destructor spec corresponding to T.  */\n@@ -2686,7 +2585,7 @@ print_destructor (pretty_printer *buffer, tree t, tree type)\n   tree decl_name = DECL_NAME (TYPE_NAME (type));\n \n   pp_string (buffer, \"Delete_\");\n-  pp_ada_tree_identifier (buffer, decl_name, t, 0, false);\n+  pp_ada_tree_identifier (buffer, decl_name, t, false);\n }\n \n /* Return the name of type T.  */\n@@ -2981,33 +2880,33 @@ dump_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n       if (is_abstract || is_abstract_class)\n \tpp_string (buffer, \" is abstract\");\n \n-      pp_semicolon (buffer);\n-      pp_string (buffer, \"  -- \");\n-      dump_sloc (buffer, t);\n-\n       if (is_abstract || !DECL_ASSEMBLER_NAME (t))\n-\treturn 1;\n-\n-      newline_and_indent (buffer, spc);\n-\n-      if (is_constructor)\n \t{\n+\t  pp_semicolon (buffer);\n+\t  pp_string (buffer, \"  -- \");\n+\t  dump_sloc (buffer, t);\n+\t}\n+      else if (is_constructor)\n+\t{\n+\t  pp_semicolon (buffer);\n+\t  pp_string (buffer, \"  -- \");\n+\t  dump_sloc (buffer, t);\n+\n+\t  newline_and_indent (buffer, spc);\n \t  pp_string (buffer, \"pragma CPP_Constructor (\");\n \t  print_constructor (buffer, t, type);\n \t  pp_string (buffer, \", \\\"\");\n \t  pp_asm_name (buffer, t);\n \t  pp_string (buffer, \"\\\");\");\n \t}\n-      else if (is_destructor)\n+      else\n \t{\n-\t  pp_string (buffer, \"pragma Import (CPP, \");\n-\t  print_destructor (buffer, t, type);\n-\t  pp_string (buffer, \", \\\"\");\n-\t  pp_asm_name (buffer, t);\n-\t  pp_string (buffer, \"\\\");\");\n+\t  pp_string (buffer, \"  -- \");\n+\t  dump_sloc (buffer, t);\n+\n+\t  newline_and_indent (buffer, spc);\n+\t  dump_ada_import (buffer, t, spc);\n \t}\n-      else\n-\tdump_ada_import (buffer, t);\n \n       return 1;\n     }\n@@ -3062,13 +2961,12 @@ dump_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n       TREE_VISITED (t) = 1; \n       if (is_interface)\n \t{\n-\t  pp_string (buffer, \"limited interface;  -- \");\n+\t  pp_string (buffer, \"limited interface  -- \");\n \t  dump_sloc (buffer, t);\n \t  newline_and_indent (buffer, spc);\n-\t  pp_string (buffer, \"pragma Import (CPP, \");\n-\t  dump_ada_node (buffer, TYPE_NAME (TREE_TYPE (t)), type, spc, false,\n-\t\t\t true);\n-\t  pp_right_paren (buffer);\n+\t  pp_string (buffer, \"with Import => True,\");\n+\t  newline_and_indent (buffer, spc + 5);\n+\t  pp_string (buffer, \"Convention => CPP\");\n \n \t  dump_ada_methods (buffer, TREE_TYPE (t), spc);\n \t}\n@@ -3152,28 +3050,29 @@ dump_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n       /* All needed indentation/newline performed already, so return 0.  */\n       return 0;\n     }\n-  else\n+  else if (is_var)\n     {\n-      pp_string (buffer, \";  -- \");\n+      pp_string (buffer, \"  -- \");\n       dump_sloc (buffer, t);\n+      newline_and_indent (buffer, spc);\n+      dump_ada_import (buffer, t, spc);\n     }\n \n-  if (is_var)\n+  else\n     {\n-      newline_and_indent (buffer, spc);\n-      dump_ada_import (buffer, t);\n+      pp_string (buffer, \";  -- \");\n+      dump_sloc (buffer, t);\n     }\n \n   return 1;\n }\n \n-/* Dump in BUFFER a structure NODE of type TYPE: name, fields, and methods\n-   in Ada syntax.  SPC is the indentation level.  If DISPLAY_CONVENTION is\n-   true, also print the pragma Convention for NODE.  */\n+/* Dump in BUFFER a structure NODE of type TYPE in Ada syntax.  If NESTED is\n+   true, it's an anonymous nested type.  SPC is the indentation level.  */\n \n static void\n-dump_ada_structure (pretty_printer *buffer, tree node, tree type, int spc,\n-\t\t    bool display_convention)\n+dump_ada_structure (pretty_printer *buffer, tree node, tree type, bool nested,\n+\t\t    int spc)\n {\n   const bool is_union = (TREE_CODE (node) == UNION_TYPE);\n   char buf[32];\n@@ -3268,45 +3167,35 @@ dump_ada_structure (pretty_printer *buffer, tree node, tree type, int spc,\n     }\n \n   INDENT (spc);\n-  pp_string (buffer, \"end record;\");\n+  pp_string (buffer, \"end record\");\n \n   newline_and_indent (buffer, spc);\n \n-  if (!display_convention)\n+  /* We disregard the methods for anonymous nested types.  */\n+  if (nested)\n     return;\n \n-  if (RECORD_OR_UNION_TYPE_P (TREE_TYPE (type)))\n+  if (has_nontrivial_methods (node))\n     {\n-      if (has_nontrivial_methods (TREE_TYPE (type)))\n-\tpp_string (buffer, \"pragma Import (CPP, \");\n-      else\n-\tpp_string (buffer, \"pragma Convention (C_Pass_By_Copy, \");\n+      pp_string (buffer, \"with Import => True,\");\n+      newline_and_indent (buffer, spc + 5);\n+      pp_string (buffer, \"Convention => CPP\");\n     }\n   else\n-    pp_string (buffer, \"pragma Convention (C, \");\n-\n-  package_prefix = false;\n-  dump_ada_node (buffer, TREE_TYPE (type), type, spc, false, true);\n-  package_prefix = true;\n-  pp_right_paren (buffer);\n+    pp_string (buffer, \"with Convention => C_Pass_By_Copy\");\n \n   if (is_union)\n     {\n-      pp_semicolon (buffer);\n-      newline_and_indent (buffer, spc);\n-      pp_string (buffer, \"pragma Unchecked_Union (\");\n-\n-      dump_ada_node (buffer, TREE_TYPE (type), type, spc, false, true);\n-      pp_right_paren (buffer);\n+      pp_comma (buffer);\n+      newline_and_indent (buffer, spc + 5);\n+      pp_string (buffer, \"Unchecked_Union => True\");\n     }\n \n   if (bitfield_used)\n     {\n-      pp_semicolon (buffer);\n-      newline_and_indent (buffer, spc);\n-      pp_string (buffer, \"pragma Pack (\");\n-      dump_ada_node (buffer, TREE_TYPE (type), type, spc, false, true);\n-      pp_right_paren (buffer);\n+      pp_comma (buffer);\n+      newline_and_indent (buffer, spc + 5);\n+      pp_string (buffer, \"Pack => True\");\n       bitfield_used = false;\n     }\n \n@@ -3377,9 +3266,9 @@ dump_ads (const char *source_file,\n       cpp_check = check;\n       dump_ada_nodes (&pp, source_file);\n \n-      /* Requires Ada 2005 syntax, so generate corresponding pragma.\n+      /* We require Ada 2012 syntax, so generate corresponding pragma.\n          Also, disable style checks since this file is auto-generated.  */\n-      fprintf (f, \"pragma Ada_2005;\\npragma Style_Checks (Off);\\n\\n\");\n+      fprintf (f, \"pragma Ada_2012;\\npragma Style_Checks (Off);\\n\\n\");\n \n       /* Dump withs.  */\n       dump_ada_withs (f);\n@@ -3445,5 +3334,4 @@ dump_ada_specs (void (*collect_all_refs)(const char *),\n \n   /* Free various tables.  */\n   free (source_refs);\n-  delete overloaded_names;\n }"}]}