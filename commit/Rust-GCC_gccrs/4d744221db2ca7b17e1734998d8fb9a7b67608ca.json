{"sha": "4d744221db2ca7b17e1734998d8fb9a7b67608ca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGQ3NDQyMjFkYjJjYTdiMTdlMTczNDk5OGQ4ZmI5YTdiNjc2MDhjYQ==", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2005-12-09T17:13:28Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-12-09T17:13:28Z"}, "message": "a-tags.ads, a-tags.adb (Offset_To_Top): Moved from the package body to the specification because the frontend generates...\n\n2005-12-05  Javier Miranda  <miranda@adacore.com>\n\t    Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* a-tags.ads, a-tags.adb (Offset_To_Top): Moved from the package body\n\tto the specification because the frontend generates code that uses this\n\tsubprogram.\n\t(Set_Interface_Table): Add missing assertion.\n\tUpdate documentation describing the run-time structure.\n\t(Displace): New subprogram that displaces the pointer to the object\n\tto reference one of its secondary dispatch tables.\n\t(IW_Membership): Modified to use the new table of interfaces.\n\t(Inherit_TSD): Modified to use the new table of interfaces.\n\t(Register_Interface_Tag): Use the additional formal to fill the\n\tcontents of the new table of interfaces.\n\t(Set_Interface_Table): New subprogram that stores in the TSD the\n\tpointer to the table of interfaces.\n\t(Set_Offset_To_Top): Use the additional formal to save copy of\n\tthe offset value in the table of interfaces.\n\tUpdate structure of GNAT Primary and Secondary dispatch table diagram.\n\tAdd comment section on GNAT dispatch table prologue.\n\t(Offset_To_Signature): Update the constant value of the Signature field.\n\t(Dispatch_Table): Update comment on hidden fields in the prologue.\n\t(Get_Entry_Index, Get_Prim_Op_Kind, Get_Offset_Index, OSD,\n\tSet_Entry_Index, Set_Offset_Index, Set_Prim_Op_Kind, SSD, TSD): Change\n\tthe type of formal parameter T to Tag, introduce additional assertions.\n\t(Get_Num_Prim_Ops, Set_Num_Prim_Ops): Remove an unnecessary type\n\tconversion.\n\t(Get_Tagged_Kind, Set_Tagged_Kind): New bodies.\n\n\t* exp_ch6.adb (Register_Interface_DT_Entry): Remove the Thunk_Id actual\n\tin all the calls to Expand_Interface_Thunk. Instead of referencing the\n\trecord component containing the tag of the secondary dispatch table we\n\thave to use the Offset_To_Top run-time function to get this information;\n\totherwise if the pointer to the base of the object has been displace\n\twe get a wrong value if we use the 'position attribute.\n\n\t* exp_disp.adb (Expand_Interface_Thunk): Remove the Thunk_Id actual in\n\tall the calls to Expand_Interface_Thunk.\n\t(Make_Secondary_DT): Secondary dispatch tables do not have a table of\n\tinterfaces; hence the call to Set_Interface_Table was clearly wrong.\n\t(Collect_All_Interfaces): Modify the internal subprogram Collect to\n\tensure that the interfaces implemented by the ancestors are placed\n\tat the header of the generated list.\n\t(Expand_Interface_Conversion): Handle the case in which the displacement\n\tassociated with the interface conversion is not statically known. In\n\tthis case we generate a call to the new run-time subprogram Displace.\n\t(Make_DT): Generate and fill the new table of interfaces.\n\t(Ada_Actions, Action_Is_Proc, Action_Nb_Arg): Add entries for\n\tGet_Tagged_Kind and Set_Tagged_Kind.\n\t(Tagged_Kind): New function that determines the tagged kind of a type\n\twith respect to limitedness and concurrency and returns a reference to\n\tRE_Tagged_Kind.\n\t(Make_Disp_Asynchronous_Select_Body, Make_Disp_Conditional_Select_Body,\n\tMake_Disp_Timed_Select_Body): Correctly retrieve the pointer to the\n\tprimary dispatch table for a type.\n\t(Make_DT, Make_Secondary_DT): Set the tagged kind in the primary and\n\tsecondary dispatch table respectively of a tagged type.\n\n\t* exp_disp.ads (Expand_Interface_Thunk): Remove Thunk_Id formal.\n\t(Expand_Interface_Conversion): New subprogram to indicate if the\n\tdisplacement of the type conversion is statically known.\n\t(DT_Access_Action): Add values Get_Tagged_Kind and Set_Tagged_Kind.\n\n\t* rtsfind.ads (RE_Offset_To_Top): New entity\n\t(RTU_Id): Add Ada_Task_Termination to the list so that it is made\n\taccessible to users.\n\t(Re_Displace): New entity\n\t(RE_Interface_Data): New entity\n\t(RE_Set_Interface_Data): New_Entity\n\t(RE_Id, RE_Unit_Table): Add entry for RE_Get_Tagged_Kind,\n\tSet_Tagged_Kind, RE_Tagged_Kind, RE_TK_Abstract_Limited_Tagged,\n\tRE_TK_Abstract_Tagged, RE_TK_Limited_Tagged, RE_TK_Protected,\n\tRE_TK_Tagged, RE_TK_Task.\n\n\t* exp_ch3.adb (Init_Secondary_Tags): Modify the subprogram\n\tInit_Secondary_Tags_Internal to allow its use with interface types and\n\talso to generate the code for the new additional actual required\n\tby Set_Offset_To_Top.\n\t(Build_Init_Statements): In case of components associated with abstract\n\tinterface types there is no need to generate a call to its IP.\n\t(Freeze_Record_Type): Generate Select Specific Data tables only for\n\tconcurrent types.\n\t(Make_Predefined_Primitive_Specs, Predefined_Primitive_Bodies): Generate\n\tthe bodies and specifications of the predefined primitive operations\n\tdealing with dispatching selects and abort, 'Callable, 'Terminated only\n\tfor concurrent types.\n\n        * exp_sel.ads, exp_sel.adb: New files.\n\n\t* exp_ch9.adb (Build_Protected_Entry, Expand_N_Protected_Body,\n\tExpand_N_Protected_Type_Declaration, Make_Initialize_Protection): Handle\n\tproperly protected objects and attach handler in the case of the\n\trestricted profile.\n\tMove embeded package Select_Expansion_Utilities into a separate external\n\tpackage.\n\t(Expand_N_Asynchronous_Select, Expand_N_Conditional_Select,\n\tExpand_N_Timed_Entry_Call): Correct calls external package Exp_Sel.\n\t(Build_K, Build_S_Assignment): New subprograms, part of the select\n\texpansion utilities.\n\t(Expand_N_Asynchronous_Select, Expand_N_Conditional_Entry_Call,\n\tExpand_N_Timed_Entry_Call): Optimize expansion of select statements\n\twhere the trigger is a dispatching procedure of a limited tagged type.\n\nFrom-SVN: r108284", "tree": {"sha": "74694593470bc6398db1d8d5eb792064a2175c0a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/74694593470bc6398db1d8d5eb792064a2175c0a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4d744221db2ca7b17e1734998d8fb9a7b67608ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d744221db2ca7b17e1734998d8fb9a7b67608ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d744221db2ca7b17e1734998d8fb9a7b67608ca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d744221db2ca7b17e1734998d8fb9a7b67608ca/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e51b97bef78798d57a052a1a09ce8823aa926efd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e51b97bef78798d57a052a1a09ce8823aa926efd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e51b97bef78798d57a052a1a09ce8823aa926efd"}], "stats": {"total": 2697, "additions": 1750, "deletions": 947}, "files": [{"sha": "a8d6cd001096a3e16223228d2866acbfaf6aa4be", "filename": "gcc/ada/a-tags.adb", "status": "modified", "additions": 370, "deletions": 152, "changes": 522, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d744221db2ca7b17e1734998d8fb9a7b67608ca/gcc%2Fada%2Fa-tags.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d744221db2ca7b17e1734998d8fb9a7b67608ca/gcc%2Fada%2Fa-tags.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tags.adb?ref=4d744221db2ca7b17e1734998d8fb9a7b67608ca", "patch": "@@ -41,47 +41,53 @@ package body Ada.Tags is\n \n --  Structure of the GNAT Primary Dispatch Table\n \n---           +-----------------------+\n---           |       Signature       |\n---           +-----------------------+\n---           |     Offset_To_Top     |\n---           +-----------------------+\n---           | Typeinfo_Ptr/TSD_Ptr  | ---> Type Specific Data\n---  Tag ---> +-----------------------+      +-------------------+\n---           |        table of       |      | inheritance depth |\n---           :     primitive ops     :      +-------------------+\n---           |        pointers       |      |   access level    |\n---           +-----------------------+      +-------------------+\n---                                          |   expanded name   |\n---                                          +-------------------+\n---                                          |   external tag    |\n---                                          +-------------------+\n---                                          |   hash table link |\n---                                          +-------------------+\n---                                          | remotely callable |\n---                                          +-------------------+\n---                                          | rec ctrler offset |\n---                                          +-------------------+\n---                                          |   num prim ops    |\n---                                          +-------------------+\n---                                          |  num interfaces   |\n---                                          +-------------------+\n---           Select Specific Data      <--- |     SSD_Ptr       |\n---           +-----------------------+      +-------------------+\n---           | table of primitive    |      | table of          |\n---           :    operation          :      :    ancestor       :\n---           |       kinds           |      |       tags        |\n---           +-----------------------+      +-------------------+\n---           | table of              |      | table of          |\n---           :    entry              :      :    interface      :\n---           |       indices         |      |       tags        |\n---           +-----------------------+      +-------------------+\n+--           +----------------------+\n+--           |       Signature      |\n+--           +----------------------+\n+--           |      Tagged_Kind     |\n+--           +----------------------+\n+--           |     Offset_To_Top    |\n+--           +----------------------+\n+--           | Typeinfo_Ptr/TSD_Ptr ---> Type Specific Data\n+--  Tag ---> +----------------------+   +-------------------+\n+--           |       table of       |   | inheritance depth |\n+--           :    primitive ops     :   +-------------------+\n+--           |       pointers       |   |   access level    |\n+--           +----------------------+   +-------------------+\n+--                                      |   expanded name   |\n+--                                      +-------------------+\n+--                                      |   external tag    |\n+--                                      +-------------------+\n+--                                      |   hash table link |\n+--                                      +-------------------+\n+--                                      | remotely callable |\n+--                                      +-------------------+\n+--                                      | rec ctrler offset |\n+--                                      +-------------------+\n+--                                      |   num prim ops    |\n+--                                      +-------------------+\n+--                                      |  num interfaces   |\n+--                                      +-------------------+\n+--                                      |  Ifaces_Table_Ptr --> Interface Data\n+--                                      +-------------------+   +------------+\n+--            Select Specific Data  <----     SSD_Ptr       |   |  table     |\n+--           +--------------------+     +-------------------+   :    of      :\n+--           | table of primitive |     | table of          |   | interfaces |\n+--           :    operation       :     :    ancestor       :   +------------+\n+--           |       kinds        |     |       tags        |\n+--           +--------------------+     +-------------------+\n+--           | table of           |\n+--           :    entry           :\n+--           |       indices      |\n+--           +--------------------+\n \n --  Structure of the GNAT Secondary Dispatch Table\n \n --           +-----------------------+\n --           |       Signature       |\n --           +-----------------------+\n+--           |      Tagged_Kind      |\n+--           +-----------------------+\n --           |     Offset_To_Top     |\n --           +-----------------------+\n --           |        OSD_Ptr        |---> Object Specific Data\n@@ -93,10 +99,77 @@ package body Ada.Tags is\n --                                          |    op offsets |\n --                                          +---------------+\n \n-   Offset_To_Signature : constant SSE.Storage_Count :=\n-                           DT_Typeinfo_Ptr_Size\n-                             + DT_Offset_To_Top_Size\n-                             + DT_Signature_Size;\n+   ----------------------------------\n+   -- GNAT Dispatch Table Prologue --\n+   ----------------------------------\n+\n+   --  GNAT's Dispatch Table prologue contains several fields which are hidden\n+   --  in order to preserve compatibility with C++. These fields are accessed\n+   --  by address calculations performed in the following manner:\n+\n+   --     Field : Field_Type :=\n+   --               (To_Address (Tag) - Sum_Of_Preceding_Field_Sizes).all;\n+\n+   --  The bracketed subtraction shifts the pointer (Tag) from the table of\n+   --  primitive operations (or thunks) to the field in question. Since the\n+   --  result of the subtraction is an address, dereferencing it will obtain\n+   --  the actual value of the field.\n+\n+   --  Guidelines for addition of new hidden fields\n+\n+   --     Define a Field_Type and Field_Type_Ptr (access to Field_Type) in\n+   --     A-Tags.ads for the newly introduced field.\n+\n+   --     Defined the size of the new field as a constant Field_Name_Size\n+\n+   --     Introduce an Unchecked_Conversion from System.Address to\n+   --     Field_Type_Ptr in A-Tags.ads.\n+\n+   --     Define the specifications of Get_<Field_Name> and Set_<Field_Name>\n+   --     in A-Tags.ads.\n+\n+   --     Update the GNAT Dispatch Table structure in A-Tags.adb\n+\n+   --     Provide bodies to the Get_<Field_Name> and Set_<Field_Name> routines.\n+   --     The profile of a Get_<Field_Name> routine should resemble:\n+\n+   --        function Get_<Field_Name> (T : Tag; ...) return Field_Type is\n+   --           Field : constant System.Address :=\n+   --                     To_Address (T) - <Sum_Of_Previous_Field_Sizes>;\n+   --        begin\n+   --           pragma Assert (Check_Signature (T, <Applicable_DT>));\n+   --           <Additional_Assertions>\n+\n+   --           return To_Field_Type_Ptr (Field).all;\n+   --        end Get_<Field_Name>;\n+\n+   --     The profile of a Set_<Field_Name> routine should resemble:\n+\n+   --        procedure Set_<Field_Name> (T : Tag; ..., Value : Field_Type) is\n+   --           Field : constant System.Address :=\n+   --                     To_Address (T) - <Sum_Of_Previous_Field_Sizes>;\n+   --           begin\n+   --           pragma Assert (Check_Signature (T, <Applicable_DT>));\n+   --           <Additional_Assertions>\n+\n+   --           To_Field_Type_Ptr (Field).all := Value;\n+   --        end Set_<Field_Name>;\n+\n+   --  NOTE: For each field in the prologue which precedes the newly added\n+   --  one, find and update its respective Sum_Of_Previous_Field_Sizes by\n+   --  subtractind Field_Name_Size from it. Falure to do so will clobber the\n+   --  previous prologue field.\n+\n+   K_Typeinfo      : constant SSE.Storage_Count := DT_Typeinfo_Ptr_Size;\n+\n+   K_Offset_To_Top : constant SSE.Storage_Count :=\n+                       K_Typeinfo + DT_Offset_To_Top_Size;\n+\n+   K_Tagged_Kind   : constant SSE.Storage_Count :=\n+                       K_Offset_To_Top + DT_Tagged_Kind_Size;\n+\n+   K_Signature     : constant SSE.Storage_Count :=\n+                       K_Tagged_Kind + DT_Signature_Size;\n \n    subtype Cstring is String (Positive);\n    type Cstring_Ptr is access all Cstring;\n@@ -108,6 +181,20 @@ package body Ada.Tags is\n    pragma Suppress_Initialization (Tag_Table);\n    pragma Suppress (Index_Check, On => Tag_Table);\n \n+   --  Declarations for the table of interfaces\n+\n+   type Interface_Data_Element is record\n+      Iface_Tag : Tag;\n+      Offset    : System.Storage_Elements.Storage_Offset;\n+   end record;\n+\n+   type Interfaces_Array is\n+     array (Natural range <>) of Interface_Data_Element;\n+\n+   type Interface_Data (Nb_Ifaces : Positive) is record\n+      Table : Interfaces_Array (1 .. Nb_Ifaces);\n+   end record;\n+\n    --  Object specific data types\n \n    type Object_Specific_Data_Array is array (Positive range <>) of Positive;\n@@ -171,17 +258,16 @@ package body Ada.Tags is\n       --  Controller Offset: Used to give support to tagged controlled objects\n       --  (see Get_Deep_Controller at s-finimp)\n \n+      Ifaces_Table_Ptr : System.Address;\n+      --  Pointer to the table of interface tags. It is used to implement the\n+      --  membership test associated with interfaces and also for backward\n+      --  abstract interface type conversions (Ada 2005:AI-251)\n+\n       Num_Prim_Ops : Natural;\n       --  Number of primitive operations of the dispatch table. This field is\n       --  used for additional run-time checks when the run-time is compiled\n       --  with assertions enabled.\n \n-      Num_Interfaces : Natural;\n-      --  Number of abstract interface types implemented by the tagged type.\n-      --  The value Idepth+Num_Interfaces indicates the end of the second table\n-      --  stored in the Tags_Table component. It is used to implement the\n-      --  membership test associated with interfaces (Ada 2005:AI-251).\n-\n       SSD_Ptr : System.Address;\n       --  Pointer to a table of records used in dispatching selects. This\n       --  field has a meaningful value for all tagged types that implement\n@@ -210,6 +296,8 @@ package body Ada.Tags is\n       --  enough space for these additional components, and generates code that\n       --  displaces the _Tag to point after these components.\n \n+      --  Signature     : Signature_Kind;\n+      --  Tagged_Kind   : Tagged_Kind;\n       --  Offset_To_Top : Natural;\n       --  Typeinfo_Ptr  : System.Address;\n \n@@ -305,11 +393,6 @@ package body Ada.Tags is\n    --  Length of string represented by the given pointer (treating the string\n    --  as a C-style string, which is Nul terminated).\n \n-   function Offset_To_Top\n-     (T : Tag) return System.Storage_Elements.Storage_Offset;\n-   --  Returns the current value of the offset_to_top component available in\n-   --  the prologue of the dispatch table.\n-\n    function Typeinfo_Ptr (T : Tag) return System.Address;\n    --  Returns the current value of the typeinfo_ptr component available in\n    --  the prologue of the dispatch table.\n@@ -425,21 +508,20 @@ package body Ada.Tags is\n    ---------------------\n \n    function Check_Signature (T : Tag; Kind : Signature_Type) return Boolean is\n-      Offset_To_Top_Ptr : constant Storage_Offset_Ptr :=\n-                            To_Storage_Offset_Ptr (To_Address (T)\n-                              - Offset_To_Signature);\n+      Signature : constant Storage_Offset_Ptr :=\n+                    To_Storage_Offset_Ptr (To_Address (T) - K_Signature);\n \n-      Signature : constant Signature_Values :=\n-                    To_Signature_Values (Offset_To_Top_Ptr.all);\n+      Sig_Values : constant Signature_Values :=\n+                     To_Signature_Values (Signature.all);\n \n       Signature_Id : Signature_Kind;\n \n    begin\n-      if Signature (1) /= Valid_Signature then\n+      if Sig_Values (1) /= Valid_Signature then\n          Signature_Id := Unknown;\n \n-      elsif Signature (2) in Primary_DT .. Abstract_Interface then\n-         Signature_Id := Signature (2);\n+      elsif Sig_Values (2) in Primary_DT .. Abstract_Interface then\n+         Signature_Id := Sig_Values (2);\n \n       else\n          Signature_Id := Unknown;\n@@ -522,6 +604,54 @@ package body Ada.Tags is\n       return Pos >= 0 and then TSD (Obj_Tag).Tags_Table (Pos) = Typ_Tag;\n    end CW_Membership;\n \n+   --------------\n+   -- Displace --\n+   --------------\n+\n+   function Displace\n+     (This : System.Address;\n+      T    : Tag) return System.Address\n+   is\n+      Curr_DT     : constant Tag := To_Tag_Ptr (This).all;\n+      Iface_Table : Interface_Data_Ptr;\n+      Obj_Base    : System.Address;\n+      Obj_DT      : Tag;\n+      Obj_TSD     : Type_Specific_Data_Ptr;\n+\n+   begin\n+      pragma Assert\n+        (Check_Signature (Curr_DT, Must_Be_Primary_Or_Secondary_DT));\n+      pragma Assert\n+        (Check_Signature (T, Must_Be_Interface));\n+\n+      Obj_Base    := This - Offset_To_Top (Curr_DT);\n+      Obj_DT      := To_Tag_Ptr (Obj_Base).all;\n+\n+      pragma Assert\n+        (Check_Signature (Obj_DT, Must_Be_Primary_DT));\n+\n+      Obj_TSD     := TSD (Obj_DT);\n+      Iface_Table := To_Interface_Data_Ptr (Obj_TSD.Ifaces_Table_Ptr);\n+\n+      if Iface_Table /= null then\n+         for Id in 1 .. Iface_Table.Nb_Ifaces loop\n+            if Iface_Table.Table (Id).Iface_Tag = T then\n+               Obj_Base := Obj_Base + Iface_Table.Table (Id).Offset;\n+               Obj_DT   := To_Tag_Ptr (Obj_Base).all;\n+\n+               pragma Assert\n+                 (Check_Signature (Obj_DT, Must_Be_Secondary_DT));\n+\n+               return Obj_Base;\n+            end if;\n+         end loop;\n+      end if;\n+\n+      --  If the object does not implement the interface we must raise CE\n+\n+      raise Constraint_Error;\n+   end Displace;\n+\n    -------------------\n    -- IW_Membership --\n    -------------------\n@@ -537,12 +667,12 @@ package body Ada.Tags is\n    --  that are contained in the dispatch table referenced by Obj'Tag.\n \n    function IW_Membership (This : System.Address; T : Tag) return Boolean is\n-      Curr_DT  : constant Tag := To_Tag_Ptr (This).all;\n-      Id       : Natural;\n-      Last_Id  : Natural;\n-      Obj_Base : System.Address;\n-      Obj_DT   : Tag;\n-      Obj_TSD  : Type_Specific_Data_Ptr;\n+      Curr_DT     : constant Tag := To_Tag_Ptr (This).all;\n+      Iface_Table : Interface_Data_Ptr;\n+      Last_Id     : Natural;\n+      Obj_Base    : System.Address;\n+      Obj_DT      : Tag;\n+      Obj_TSD     : Type_Specific_Data_Ptr;\n \n    begin\n       pragma Assert\n@@ -554,29 +684,32 @@ package body Ada.Tags is\n       Obj_DT   := To_Tag_Ptr (Obj_Base).all;\n \n       pragma Assert\n-        (Check_Signature (Curr_DT, Must_Be_Primary_DT));\n+        (Check_Signature (Obj_DT, Must_Be_Primary_DT));\n \n       Obj_TSD := TSD (Obj_DT);\n-      Last_Id := Obj_TSD.Idepth + Obj_TSD.Num_Interfaces;\n-\n-      if Obj_TSD.Num_Interfaces > 0 then\n+      Last_Id := Obj_TSD.Idepth;\n \n-         --  Traverse the ancestor tags table plus the interface tags table.\n-         --  The former part is required for:\n+      --  Look for the tag in the table of interfaces\n \n-         --     Iface_CW in Typ'Class\n+      Iface_Table := To_Interface_Data_Ptr (Obj_TSD.Ifaces_Table_Ptr);\n \n-         Id := 0;\n-         loop\n-            if Obj_TSD.Tags_Table (Id) = T then\n+      if Iface_Table /= null then\n+         for Id in 1 .. Iface_Table.Nb_Ifaces loop\n+            if Iface_Table.Table (Id).Iface_Tag = T then\n                return True;\n             end if;\n-\n-            Id := Id + 1;\n-            exit when Id > Last_Id;\n          end loop;\n       end if;\n \n+      --  Look for the tag in the ancestor tags table. This is required for:\n+      --     Iface_CW in Typ'Class\n+\n+      for Id in 0 .. Last_Id loop\n+         if Obj_TSD.Tags_Table (Id) = T then\n+            return True;\n+         end if;\n+      end loop;\n+\n       return False;\n    end IW_Membership;\n \n@@ -652,6 +785,7 @@ package body Ada.Tags is\n       Index : constant Integer := Position - Default_Prim_Op_Count;\n    begin\n       pragma Assert (Check_Signature (T, Must_Be_Primary_DT));\n+      pragma Assert (Check_Index (T, Position));\n       pragma Assert (Index > 0);\n       return SSD (T).SSD_Table (Index).Index;\n    end Get_Entry_Index;\n@@ -677,7 +811,7 @@ package body Ada.Tags is\n       if Is_Primary_DT (T) then\n          return TSD (T).Num_Prim_Ops;\n       else\n-         return OSD (Interface_Tag (T)).Num_Prim_Ops;\n+         return OSD (T).Num_Prim_Ops;\n       end if;\n    end Get_Num_Prim_Ops;\n \n@@ -706,6 +840,7 @@ package body Ada.Tags is\n       Index : constant Integer := Position - Default_Prim_Op_Count;\n    begin\n       pragma Assert (Check_Signature (T, Must_Be_Primary_DT));\n+      pragma Assert (Check_Index (T, Position));\n       pragma Assert (Index > 0);\n       return SSD (T).SSD_Table (Index).Kind;\n    end Get_Prim_Op_Kind;\n@@ -715,12 +850,13 @@ package body Ada.Tags is\n    ----------------------\n \n    function Get_Offset_Index\n-     (T        : Interface_Tag;\n+     (T        : Tag;\n       Position : Positive) return Positive\n    is\n       Index : constant Integer := Position - Default_Prim_Op_Count;\n    begin\n-      pragma Assert (Check_Signature (Tag (T), Must_Be_Secondary_DT));\n+      pragma Assert (Check_Signature (T, Must_Be_Secondary_DT));\n+      pragma Assert (Check_Index (T, Position));\n       pragma Assert (Index > 0);\n       return OSD (T).OSD_Table (Index);\n    end Get_Offset_Index;\n@@ -745,6 +881,18 @@ package body Ada.Tags is\n       return TSD (T).Remotely_Callable;\n    end Get_Remotely_Callable;\n \n+   ---------------------\n+   -- Get_Tagged_Kind --\n+   ---------------------\n+\n+   function Get_Tagged_Kind (T : Tag) return Tagged_Kind is\n+      Tagged_Kind_Ptr : constant System.Address :=\n+                          To_Address (T) - K_Tagged_Kind;\n+   begin\n+      pragma Assert (Check_Signature (T, Must_Be_Primary_Or_Secondary_DT));\n+      return To_Tagged_Kind_Ptr (Tagged_Kind_Ptr).all;\n+   end Get_Tagged_Kind;\n+\n    ----------------\n    -- Inherit_DT --\n    ----------------\n@@ -766,8 +914,10 @@ package body Ada.Tags is\n    -----------------\n \n    procedure Inherit_TSD (Old_Tag : Tag; New_Tag : Tag) is\n-      New_TSD_Ptr : Type_Specific_Data_Ptr;\n-      Old_TSD_Ptr : Type_Specific_Data_Ptr;\n+      New_TSD_Ptr         : Type_Specific_Data_Ptr;\n+      New_Iface_Table_Ptr : Interface_Data_Ptr;\n+      Old_TSD_Ptr         : Type_Specific_Data_Ptr;\n+      Old_Iface_Table_Ptr : Interface_Data_Ptr;\n \n    begin\n       pragma Assert (Check_Signature (New_Tag, Must_Be_Primary_Or_Interface));\n@@ -778,18 +928,29 @@ package body Ada.Tags is\n            (Check_Signature (Old_Tag, Must_Be_Primary_Or_Interface));\n          Old_TSD_Ptr := TSD (Old_Tag);\n          New_TSD_Ptr.Idepth := Old_TSD_Ptr.Idepth + 1;\n-         New_TSD_Ptr.Num_Interfaces := Old_TSD_Ptr.Num_Interfaces;\n \n          --  Copy the \"table of ancestor tags\" plus the \"table of interfaces\"\n          --  of the parent.\n \n-         New_TSD_Ptr.Tags_Table\n-           (1 .. New_TSD_Ptr.Idepth + New_TSD_Ptr.Num_Interfaces) :=\n-             Old_TSD_Ptr.Tags_Table\n-               (0 .. Old_TSD_Ptr.Idepth + Old_TSD_Ptr.Num_Interfaces);\n+         New_TSD_Ptr.Tags_Table (1 .. New_TSD_Ptr.Idepth) :=\n+           Old_TSD_Ptr.Tags_Table (0 .. Old_TSD_Ptr.Idepth);\n+\n+         --  Copy the table of interfaces of the parent\n+\n+         if not System.\"=\" (Old_TSD_Ptr.Ifaces_Table_Ptr,\n+                            System.Null_Address)\n+         then\n+            Old_Iface_Table_Ptr :=\n+              To_Interface_Data_Ptr (Old_TSD_Ptr.Ifaces_Table_Ptr);\n+            New_Iface_Table_Ptr :=\n+              To_Interface_Data_Ptr (New_TSD_Ptr.Ifaces_Table_Ptr);\n+\n+            New_Iface_Table_Ptr.Table (1 .. Old_Iface_Table_Ptr.Nb_Ifaces) :=\n+              Old_Iface_Table_Ptr.Table (1 .. Old_Iface_Table_Ptr.Nb_Ifaces);\n+         end if;\n+\n       else\n-         New_TSD_Ptr.Idepth         := 0;\n-         New_TSD_Ptr.Num_Interfaces := 0;\n+         New_TSD_Ptr.Idepth := 0;\n       end if;\n \n       New_TSD_Ptr.Tags_Table (0) := New_Tag;\n@@ -845,13 +1006,12 @@ package body Ada.Tags is\n    -------------------\n \n    function Is_Primary_DT (T : Tag) return Boolean is\n-      Offset_To_Top_Ptr : constant Storage_Offset_Ptr :=\n-                            To_Storage_Offset_Ptr (To_Address (T)\n-                              - Offset_To_Signature);\n-      Signature         : constant Signature_Values :=\n-                            To_Signature_Values (Offset_To_Top_Ptr.all);\n+      Signature  : constant Storage_Offset_Ptr :=\n+                     To_Storage_Offset_Ptr (To_Address (T) - K_Signature);\n+      Sig_Values : constant Signature_Values :=\n+                     To_Signature_Values (Signature.all);\n    begin\n-      return Signature (2) = Primary_DT;\n+      return Sig_Values (2) = Primary_DT;\n    end Is_Primary_DT;\n \n    ------------\n@@ -876,26 +1036,22 @@ package body Ada.Tags is\n    function Offset_To_Top\n      (T : Tag) return System.Storage_Elements.Storage_Offset\n    is\n-      Offset_To_Top_Ptr : constant Storage_Offset_Ptr :=\n-                            To_Storage_Offset_Ptr (To_Address (T)\n-                              - DT_Typeinfo_Ptr_Size\n-                              - DT_Offset_To_Top_Size);\n-\n+      Offset_To_Top : constant Storage_Offset_Ptr :=\n+                        To_Storage_Offset_Ptr\n+                          (To_Address (T) - K_Offset_To_Top);\n    begin\n-      return Offset_To_Top_Ptr.all;\n+      return Offset_To_Top.all;\n    end Offset_To_Top;\n \n    ---------\n    -- OSD --\n    ---------\n \n-   function OSD\n-     (T : Interface_Tag) return Object_Specific_Data_Ptr\n-   is\n-      OSD_Ptr : Addr_Ptr;\n-\n+   function OSD (T : Tag) return Object_Specific_Data_Ptr is\n+      OSD_Ptr : constant Addr_Ptr :=\n+                  To_Addr_Ptr (To_Address (T) - K_Typeinfo);\n    begin\n-      OSD_Ptr := To_Addr_Ptr (To_Address (T) - DT_Typeinfo_Ptr_Size);\n+      pragma Assert (Check_Signature (T, Must_Be_Secondary_DT));\n       return To_Object_Specific_Data_Ptr (OSD_Ptr.all);\n    end OSD;\n \n@@ -952,39 +1108,24 @@ package body Ada.Tags is\n    -- Register_Interface_Tag --\n    ----------------------------\n \n-   procedure Register_Interface_Tag (T : Tag; Interface_T : Tag) is\n-      New_T_TSD : Type_Specific_Data_Ptr;\n-      Index     : Natural;\n+   procedure Register_Interface_Tag\n+     (T           : Tag;\n+      Interface_T : Tag;\n+      Position    : Positive)\n+   is\n+      New_T_TSD   : Type_Specific_Data_Ptr;\n+      Iface_Table : Interface_Data_Ptr;\n \n    begin\n       pragma Assert (Check_Signature (T, Must_Be_Primary_DT));\n       pragma Assert (Check_Signature (Interface_T, Must_Be_Interface));\n \n-      New_T_TSD := TSD (T);\n-\n-      --  Check if the interface is already registered\n-\n-      if New_T_TSD.Num_Interfaces > 0 then\n-         declare\n-            Id      : Natural          := New_T_TSD.Idepth + 1;\n-            Last_Id : constant Natural := New_T_TSD.Idepth\n-                                            + New_T_TSD.Num_Interfaces;\n+      New_T_TSD   := TSD (T);\n+      Iface_Table := To_Interface_Data_Ptr (New_T_TSD.Ifaces_Table_Ptr);\n \n-         begin\n-            loop\n-               if New_T_TSD.Tags_Table (Id) = Interface_T then\n-                  return;\n-               end if;\n-\n-               Id := Id + 1;\n-               exit when Id > Last_Id;\n-            end loop;\n-         end;\n-      end if;\n+      pragma Assert (Position <= Iface_Table.Nb_Ifaces);\n \n-      New_T_TSD.Num_Interfaces := New_T_TSD.Num_Interfaces + 1;\n-      Index := New_T_TSD.Idepth + New_T_TSD.Num_Interfaces;\n-      New_T_TSD.Tags_Table (Index) := Interface_T;\n+      Iface_Table.Table (Position).Iface_Tag := Interface_T;\n    end Register_Interface_Tag;\n \n    ------------------\n@@ -1016,9 +1157,9 @@ package body Ada.Tags is\n       Value    : Positive)\n    is\n       Index : constant Integer := Position - Default_Prim_Op_Count;\n-\n    begin\n       pragma Assert (Check_Signature (T, Must_Be_Primary_DT));\n+      pragma Assert (Check_Index (T, Position));\n       pragma Assert (Index > 0);\n       SSD (T).SSD_Table (Index).Index := Value;\n    end Set_Entry_Index;\n@@ -1044,6 +1185,16 @@ package body Ada.Tags is\n       TSD (T).External_Tag := To_Cstring_Ptr (Value);\n    end Set_External_Tag;\n \n+   -------------------------\n+   -- Set_Interface_Table --\n+   -------------------------\n+\n+   procedure Set_Interface_Table (T : Tag; Value : System.Address) is\n+   begin\n+      pragma Assert (Check_Signature (T, Must_Be_Primary_DT));\n+      TSD (T).Ifaces_Table_Ptr := Value;\n+   end Set_Interface_Table;\n+\n    ----------------------\n    -- Set_Num_Prim_Ops --\n    ----------------------\n@@ -1055,7 +1206,7 @@ package body Ada.Tags is\n       if Is_Primary_DT (T) then\n          TSD (T).Num_Prim_Ops := Value;\n       else\n-         OSD (Interface_Tag (T)).Num_Prim_Ops := Value;\n+         OSD (T).Num_Prim_Ops := Value;\n       end if;\n    end Set_Num_Prim_Ops;\n \n@@ -1064,13 +1215,14 @@ package body Ada.Tags is\n    ----------------------\n \n    procedure Set_Offset_Index\n-     (T        : Interface_Tag;\n+     (T        : Tag;\n       Position : Positive;\n       Value    : Positive)\n    is\n       Index : constant Integer := Position - Default_Prim_Op_Count;\n    begin\n-      pragma Assert (Check_Signature (Tag (T), Must_Be_Secondary_DT));\n+      pragma Assert (Check_Signature (T, Must_Be_Secondary_DT));\n+      pragma Assert (Check_Index (T, Position));\n       pragma Assert (Index > 0);\n       OSD (T).OSD_Table (Index) := Value;\n    end Set_Offset_Index;\n@@ -1080,27 +1232,78 @@ package body Ada.Tags is\n    -----------------------\n \n    procedure Set_Offset_To_Top\n-     (T     : Tag;\n-      Value : System.Storage_Elements.Storage_Offset)\n+     (This          : System.Address;\n+      Interface_T   : Tag;\n+      Offset_Value  : System.Storage_Elements.Storage_Offset)\n    is\n-      Offset_To_Top_Ptr : constant Storage_Offset_Ptr :=\n-                            To_Storage_Offset_Ptr (To_Address (T)\n-                              - DT_Typeinfo_Ptr_Size\n-                              - DT_Offset_To_Top_Size);\n+      Prim_DT       : Tag;\n+      Sec_Base      : System.Address;\n+      Sec_DT        : Tag;\n+      Offset_To_Top : Storage_Offset_Ptr;\n+      Iface_Table   : Interface_Data_Ptr;\n+      Obj_TSD       : Type_Specific_Data_Ptr;\n    begin\n-      pragma Assert (Check_Signature (T, Must_Be_Primary_Or_Secondary_DT));\n-      Offset_To_Top_Ptr.all := Value;\n+      if System.\"=\" (This, System.Null_Address) then\n+         pragma Assert\n+           (Check_Signature (Interface_T, Must_Be_Primary_DT));\n+         pragma Assert (Offset_Value = 0);\n+\n+         Offset_To_Top :=\n+           To_Storage_Offset_Ptr (To_Address (Interface_T) - K_Offset_To_Top);\n+         Offset_To_Top.all := Offset_Value;\n+         return;\n+      end if;\n+\n+      --  \"This\" points to the primary DT and we must save Offset_Value in the\n+      --  Offset_To_Top field of the corresponding secondary dispatch table.\n+\n+      Prim_DT := To_Tag_Ptr (This).all;\n+\n+      pragma Assert\n+        (Check_Signature (Prim_DT, Must_Be_Primary_DT));\n+\n+      Sec_Base := This + Offset_Value;\n+      Sec_DT   := To_Tag_Ptr (Sec_Base).all;\n+      Offset_To_Top :=\n+        To_Storage_Offset_Ptr (To_Address (Sec_DT) - K_Offset_To_Top);\n+\n+      pragma Assert\n+        (Check_Signature (Sec_DT, Must_Be_Primary_Or_Secondary_DT));\n+\n+      Offset_To_Top.all := Offset_Value;\n+\n+      --  Save Offset_Value in the table of interfaces of the primary DT. This\n+      --  data will be used by the subprogram \"Displace\" to give support to\n+      --  backward abstract interface type conversions.\n+\n+      Obj_TSD     := TSD (Prim_DT);\n+      Iface_Table := To_Interface_Data_Ptr (Obj_TSD.Ifaces_Table_Ptr);\n+\n+      --  Register the offset in the table of interfaces\n+\n+      if Iface_Table /= null then\n+         for Id in 1 .. Iface_Table.Nb_Ifaces loop\n+            if Iface_Table.Table (Id).Iface_Tag = Interface_T then\n+               Iface_Table.Table (Id).Offset := Offset_Value;\n+               return;\n+            end if;\n+         end loop;\n+      end if;\n+\n+      --  If we arrive here there is some error in the run-time data structure\n+\n+      raise Program_Error;\n    end Set_Offset_To_Top;\n \n    -------------\n    -- Set_OSD --\n    -------------\n \n-   procedure Set_OSD (T : Interface_Tag; Value : System.Address) is\n-      OSD_Ptr : Addr_Ptr;\n+   procedure Set_OSD (T : Tag; Value : System.Address) is\n+      OSD_Ptr : constant Addr_Ptr :=\n+                  To_Addr_Ptr (To_Address (T) - K_Typeinfo);\n    begin\n-      pragma Assert (Check_Signature (Tag (T), Must_Be_Secondary_DT));\n-      OSD_Ptr := To_Addr_Ptr (To_Address (T) - DT_Typeinfo_Ptr_Size);\n+      pragma Assert (Check_Signature (T, Must_Be_Secondary_DT));\n       OSD_Ptr.all := Value;\n    end Set_OSD;\n \n@@ -1131,6 +1334,7 @@ package body Ada.Tags is\n       Index : constant Integer := Position - Default_Prim_Op_Count;\n    begin\n       pragma Assert (Check_Signature (T, Must_Be_Primary_DT));\n+      pragma Assert (Check_Index (T, Position));\n       pragma Assert (Index > 0);\n       SSD (T).SSD_Table (Index).Kind := Value;\n    end Set_Prim_Op_Kind;\n@@ -1165,6 +1369,18 @@ package body Ada.Tags is\n       TSD (T).SSD_Ptr := Value;\n    end Set_SSD;\n \n+   ---------------------\n+   -- Set_Tagged_Kind --\n+   ---------------------\n+\n+   procedure Set_Tagged_Kind (T : Tag; Value : Tagged_Kind) is\n+      Tagged_Kind_Ptr : constant System.Address :=\n+                          To_Address (T) - K_Tagged_Kind;\n+   begin\n+      pragma Assert (Check_Signature (T, Must_Be_Primary_Or_Secondary_DT));\n+      To_Tagged_Kind_Ptr (Tagged_Kind_Ptr).all := Value;\n+   end Set_Tagged_Kind;\n+\n    -------------\n    -- Set_TSD --\n    -------------\n@@ -1173,7 +1389,7 @@ package body Ada.Tags is\n       TSD_Ptr : Addr_Ptr;\n    begin\n       pragma Assert (Check_Signature (T, Must_Be_Primary_Or_Interface));\n-      TSD_Ptr := To_Addr_Ptr (To_Address (T) - DT_Typeinfo_Ptr_Size);\n+      TSD_Ptr := To_Addr_Ptr (To_Address (T) - K_Typeinfo);\n       TSD_Ptr.all := Value;\n    end Set_TSD;\n \n@@ -1183,6 +1399,7 @@ package body Ada.Tags is\n \n    function SSD (T : Tag) return Select_Specific_Data_Ptr is\n    begin\n+      pragma Assert (Check_Signature (T, Must_Be_Primary_DT));\n       return To_Select_Specific_Data_Ptr (TSD (T).SSD_Ptr);\n    end SSD;\n \n@@ -1192,7 +1409,7 @@ package body Ada.Tags is\n \n    function Typeinfo_Ptr (T : Tag) return System.Address is\n       TSD_Ptr : constant Addr_Ptr :=\n-                  To_Addr_Ptr (To_Address (T) - DT_Typeinfo_Ptr_Size);\n+                  To_Addr_Ptr (To_Address (T) - K_Typeinfo);\n    begin\n       return TSD_Ptr.all;\n    end Typeinfo_Ptr;\n@@ -1203,8 +1420,9 @@ package body Ada.Tags is\n \n    function TSD (T : Tag) return Type_Specific_Data_Ptr is\n       TSD_Ptr : constant Addr_Ptr :=\n-                  To_Addr_Ptr (To_Address (T) - DT_Typeinfo_Ptr_Size);\n+                  To_Addr_Ptr (To_Address (T) - K_Typeinfo);\n    begin\n+      pragma Assert (Check_Signature (T, Must_Be_Primary_Or_Interface));\n       return To_Type_Specific_Data_Ptr (TSD_Ptr.all);\n    end TSD;\n "}, {"sha": "25fed4f1dcb7dd26083762173d3022b7e17b403c", "filename": "gcc/ada/a-tags.ads", "status": "modified", "additions": 100, "deletions": 44, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d744221db2ca7b17e1734998d8fb9a7b67608ca/gcc%2Fada%2Fa-tags.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d744221db2ca7b17e1734998d8fb9a7b67608ca/gcc%2Fada%2Fa-tags.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tags.ads?ref=4d744221db2ca7b17e1734998d8fb9a7b67608ca", "patch": "@@ -102,6 +102,11 @@ private\n \n    No_Tag : constant Tag := null;\n \n+   type Interface_Data (Nb_Ifaces : Positive);\n+   type Interface_Data_Ptr is access all Interface_Data;\n+   --  Table of abstract interfaces used to give support to backward interface\n+   --  conversions and also to IW_Membership.\n+\n    type Object_Specific_Data (Nb_Prim : Positive);\n    type Object_Specific_Data_Ptr is access all Object_Specific_Data;\n    --  Information associated with the secondary dispatch table of tagged-type\n@@ -132,6 +137,18 @@ private\n       POK_Task_Function,\n       POK_Task_Procedure);\n \n+   --  Tagged type kinds with respect to concurrency and limitedness\n+\n+   type Tagged_Kind is\n+     (TK_Abstract_Limited_Tagged,\n+      TK_Abstract_Tagged,\n+      TK_Limited_Tagged,\n+      TK_Protected,\n+      TK_Tagged,\n+      TK_Task);\n+\n+   type Tagged_Kind_Ptr is access all Tagged_Kind;\n+\n    Default_Prim_Op_Count : constant Positive := 15;\n    --  Number of predefined primitive operations added by the Expander for a\n    --  tagged type. It is utilized for indexing in the two auxiliary tables\n@@ -160,6 +177,10 @@ private\n    --         return O in T'Class.\n    --      end Test;\n \n+   function Displace (This : System.Address; T : Tag) return System.Address;\n+   --  (Ada 2005 (AI-251): Displace \"This\" to point to the secondary dispatch\n+   --  table of T.\n+\n    function Get_Access_Level (T : Tag) return Natural;\n    --  Given the tag associated with a type, returns the accessibility level\n    --  of the type.\n@@ -173,7 +194,7 @@ private\n    --  the external name.\n \n    function Get_Offset_Index\n-     (T        : Interface_Tag;\n+     (T        : Tag;\n       Position : Positive) return Positive;\n    --  Given a pointer to a secondary dispatch table (T) and a position of an\n    --  operation in the DT, retrieve the corresponding operation's position in\n@@ -204,6 +225,11 @@ private\n    function Get_Remotely_Callable (T : Tag) return Boolean;\n    --  Return the value previously set by Set_Remotely_Callable\n \n+   function Get_Tagged_Kind (T : Tag) return Tagged_Kind;\n+   --  Given a pointer to either a primary or a secondary dispatch table,\n+   --  return the tagged kind of a type in the context of concurrency and\n+   --  limitedness.\n+\n    procedure Inherit_DT (Old_T : Tag; New_T : Tag; Entry_Count : Natural);\n    --  Entry point used to initialize the DT of a type knowing the tag\n    --  of the direct ancestor and the number of primitive ops that are\n@@ -212,7 +238,12 @@ private\n    procedure Inherit_TSD (Old_Tag : Tag; New_Tag : Tag);\n    --  Initialize the TSD of a type knowing the tag of the direct ancestor\n \n-   function OSD (T : Interface_Tag) return Object_Specific_Data_Ptr;\n+   function Offset_To_Top\n+     (T : Tag) return System.Storage_Elements.Storage_Offset;\n+   --  Returns the current value of the offset_to_top component available in\n+   --  the prologue of the dispatch table.\n+\n+   function OSD (T : Tag) return Object_Specific_Data_Ptr;\n    --  Ada 2005 (AI-251): Given a pointer T to a secondary dispatch table,\n    --  retrieve the address of the record containing the Objet Specific\n    --  Data table.\n@@ -228,38 +259,63 @@ private\n    pragma Export (Ada, Parent_Size, \"ada__tags__parent_size\");\n    --  This procedure is used in s-finimp and is thus exported manually\n \n-   procedure Register_Interface_Tag (T : Tag; Interface_T : Tag);\n+   procedure Register_Interface_Tag\n+     (T           : Tag;\n+      Interface_T : Tag;\n+      Position    : Positive);\n    --  Ada 2005 (AI-251): Used to initialize the table of interfaces\n-   --  implemented by a type. Required to give support to IW_Membership.\n+   --  implemented by a type. Required to give support to backward interface\n+   --  conversions and also to IW_Membership.\n \n    procedure Register_Tag (T : Tag);\n    --  Insert the Tag and its associated external_tag in a table for the\n    --  sake of Internal_Tag\n \n+   procedure Set_Access_Level (T : Tag; Value : Natural);\n+   --  Sets the accessibility level of the tagged type associated with T\n+   --  in its TSD.\n+\n    procedure Set_Entry_Index (T : Tag; Position : Positive; Value : Positive);\n    --  Set the entry index of a primitive operation in T's TSD table indexed\n    --  by Position.\n \n+   procedure Set_Expanded_Name (T : Tag; Value : System.Address);\n+   --  Set the address of the string containing the expanded name\n+   --  in the Dispatch table.\n+\n+   procedure Set_External_Tag (T : Tag; Value : System.Address);\n+   --  Set the address of the string containing the external tag\n+   --  in the Dispatch table.\n+\n+   procedure Set_Interface_Table (T : Tag; Value : System.Address);\n+   --  Ada 2005 (AI-251): Given a pointer T to a dispatch Table, stores the\n+   --  pointer to the table of interfaces.\n+\n    procedure Set_Num_Prim_Ops (T : Tag; Value : Natural);\n    --  Set the number of primitive operations in the dispatch table of T. This\n    --  is used for debugging purposes.\n \n    procedure Set_Offset_Index\n-     (T        : Interface_Tag;\n+     (T        : Tag;\n       Position : Positive;\n       Value    : Positive);\n    --  Set the offset value of a primitive operation in a secondary dispatch\n    --  table denoted by T, indexed by Position.\n \n    procedure Set_Offset_To_Top\n-     (T     : Tag;\n-      Value : System.Storage_Elements.Storage_Offset);\n+     (This         : System.Address;\n+      Interface_T  : Tag;\n+      Offset_Value : System.Storage_Elements.Storage_Offset);\n    --  Ada 2005 (AI-251): Initialize the Offset_To_Top field in the prologue of\n-   --  the dispatch table. In primary dispatch tables the value of this field\n-   --  is always 0; in secondary dispatch tables this is the offset to the base\n-   --  of the enclosing type.\n-\n-   procedure Set_OSD (T : Interface_Tag; Value : System.Address);\n+   --  the dispatch table. In primary dispatch tables the value of \"This\" is\n+   --  not required (and the compiler passes always the Null_Address value) and\n+   --  the Offset_Value is always cero; in secondary dispatch tables \"This\"\n+   --  points to the object, Interface_T is the interface for which the\n+   --  secondary dispatch table is being initialized, and Offset_Value is the\n+   --  distance from \"This\" to the object component containing the tag of the\n+   --  secondary dispatch table.\n+\n+   procedure Set_OSD (T : Tag; Value : System.Address);\n    --  Given a pointer T to a secondary dispatch table, store the pointer to\n    --  the record containing the Object Specific Data generated by GNAT.\n \n@@ -278,26 +334,6 @@ private\n    --  Set the kind of a primitive operation in T's TSD table indexed by\n    --  Position.\n \n-   procedure Set_SSD (T : Tag; Value : System.Address);\n-   --  Given a pointer T to a dispatch Table, stores the pointer to the record\n-   --  containing the Select Specific Data generated by GNAT.\n-\n-   procedure Set_TSD (T : Tag; Value : System.Address);\n-   --  Given a pointer T to a dispatch Table, stores the address of the record\n-   --  containing the Type Specific Data generated by GNAT.\n-\n-   procedure Set_Access_Level (T : Tag; Value : Natural);\n-   --  Sets the accessibility level of the tagged type associated with T\n-   --  in its TSD.\n-\n-   procedure Set_Expanded_Name (T : Tag; Value : System.Address);\n-   --  Set the address of the string containing the expanded name\n-   --  in the Dispatch table.\n-\n-   procedure Set_External_Tag (T : Tag; Value : System.Address);\n-   --  Set the address of the string containing the external tag\n-   --  in the Dispatch table.\n-\n    procedure Set_RC_Offset (T : Tag; Value : SSE.Storage_Offset);\n    --  Sets the Offset of the implicit record controller when the object\n    --  has controlled components. Set to O otherwise.\n@@ -306,6 +342,18 @@ private\n    --  Set to true if the type has been declared in a context described\n    --  in E.4 (18).\n \n+   procedure Set_SSD (T : Tag; Value : System.Address);\n+   --  Given a pointer T to a dispatch Table, stores the pointer to the record\n+   --  containing the Select Specific Data generated by GNAT.\n+\n+   procedure Set_Tagged_Kind (T : Tag; Value : Tagged_Kind);\n+   --  Set the tagged kind of a type in either a primary or a secondary\n+   --  dispatch table denoted by T.\n+\n+   procedure Set_TSD (T : Tag; Value : System.Address);\n+   --  Given a pointer T to a dispatch Table, stores the address of the record\n+   --  containing the Type Specific Data generated by GNAT.\n+\n    function SSD (T : Tag) return Select_Specific_Data_Ptr;\n    --  Given a pointer T to a dispatch Table, retrieves the address of the\n    --  record containing the Select Specific Data in T's TSD.\n@@ -315,33 +363,31 @@ private\n    --  record containing the Type Specific Data generated by GNAT.\n \n    DT_Prologue_Size : constant SSE.Storage_Count :=\n-                        SSE.Storage_Count\n-                          (3 * (Standard'Address_Size / System.Storage_Unit));\n+     SSE.Storage_Count (4 * (Standard'Address_Size / System.Storage_Unit));\n    --  Size of the first part of the dispatch table\n \n    DT_Signature_Size : constant SSE.Storage_Count :=\n-                         SSE.Storage_Count\n-                           (Standard'Address_Size / System.Storage_Unit);\n+     SSE.Storage_Count (1 * (Standard'Address_Size / System.Storage_Unit));\n    --  Size of the Signature field of the dispatch table\n \n+   DT_Tagged_Kind_Size : constant SSE.Storage_Count :=\n+     SSE.Storage_Count (1 * (Standard'Address_Size / System.Storage_Unit));\n+   --  Size of the Tagged_Type_Kind field of the dispatch table\n+\n    DT_Offset_To_Top_Size : constant SSE.Storage_Count :=\n-                            SSE.Storage_Count\n-                              (Standard'Address_Size / System.Storage_Unit);\n+     SSE.Storage_Count (1 * (Standard'Address_Size / System.Storage_Unit));\n    --  Size of the Offset_To_Top field of the Dispatch Table\n \n    DT_Typeinfo_Ptr_Size : constant SSE.Storage_Count :=\n-                            SSE.Storage_Count\n-                              (Standard'Address_Size / System.Storage_Unit);\n+     SSE.Storage_Count (1 * (Standard'Address_Size / System.Storage_Unit));\n    --  Size of the Typeinfo_Ptr field of the Dispatch Table\n \n    DT_Entry_Size : constant SSE.Storage_Count :=\n-                     SSE.Storage_Count\n-                       (1 * (Standard'Address_Size / System.Storage_Unit));\n+     SSE.Storage_Count (1 * (Standard'Address_Size / System.Storage_Unit));\n    --  Size of each primitive operation entry in the Dispatch Table\n \n    TSD_Prologue_Size : constant SSE.Storage_Count :=\n-                         SSE.Storage_Count\n-                          (10 * (Standard'Address_Size / System.Storage_Unit));\n+     SSE.Storage_Count (10 * (Standard'Address_Size / System.Storage_Unit));\n    --  Size of the first part of the type specific data\n \n    TSD_Entry_Size : constant SSE.Storage_Count :=\n@@ -396,6 +442,9 @@ private\n    function To_Address is\n      new Unchecked_Conversion (Type_Specific_Data_Ptr, System.Address);\n \n+   function To_Interface_Data_Ptr is\n+     new Unchecked_Conversion (System.Address, Interface_Data_Ptr);\n+\n    function To_Object_Specific_Data_Ptr is\n      new Unchecked_Conversion (System.Address, Object_Specific_Data_Ptr);\n \n@@ -409,10 +458,14 @@ private\n    function To_Tag_Ptr is\n      new Unchecked_Conversion (System.Address, Tag_Ptr);\n \n+   function To_Tagged_Kind_Ptr is\n+     new Unchecked_Conversion (System.Address, Tagged_Kind_Ptr);\n+\n    --  Primitive dispatching operations are always inlined, to facilitate\n    --  use in a minimal/no run-time environment for high integrity use.\n \n    pragma Inline_Always (CW_Membership);\n+   pragma Inline_Always (Displace);\n    pragma Inline_Always (IW_Membership);\n    pragma Inline_Always (Get_Access_Level);\n    pragma Inline_Always (Get_Entry_Index);\n@@ -421,6 +474,7 @@ private\n    pragma Inline_Always (Get_Prim_Op_Kind);\n    pragma Inline_Always (Get_RC_Offset);\n    pragma Inline_Always (Get_Remotely_Callable);\n+   pragma Inline_Always (Get_Tagged_Kind);\n    pragma Inline_Always (Inherit_DT);\n    pragma Inline_Always (Inherit_TSD);\n    pragma Inline_Always (OSD);\n@@ -430,6 +484,7 @@ private\n    pragma Inline_Always (Set_Entry_Index);\n    pragma Inline_Always (Set_Expanded_Name);\n    pragma Inline_Always (Set_External_Tag);\n+   pragma Inline_Always (Set_Interface_Table);\n    pragma Inline_Always (Set_Num_Prim_Ops);\n    pragma Inline_Always (Set_Offset_Index);\n    pragma Inline_Always (Set_Offset_To_Top);\n@@ -440,6 +495,7 @@ private\n    pragma Inline_Always (Set_OSD);\n    pragma Inline_Always (Set_SSD);\n    pragma Inline_Always (Set_TSD);\n+   pragma Inline_Always (Set_Tagged_Kind);\n    pragma Inline_Always (SSD);\n    pragma Inline_Always (TSD);\n "}, {"sha": "6a975e6d68a8065d379237df74c5e7ac3c4b204b", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 47, "deletions": 43, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d744221db2ca7b17e1734998d8fb9a7b67608ca/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d744221db2ca7b17e1734998d8fb9a7b67608ca/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=4d744221db2ca7b17e1734998d8fb9a7b67608ca", "patch": "@@ -1760,20 +1760,18 @@ package body Exp_Ch3 is\n             procedure Init_Secondary_Tags_Internal (Typ : Entity_Id) is\n                E     : Entity_Id;\n                Aux_N : Node_Id;\n+               Iface : Entity_Id;\n \n             begin\n-               if not Is_Interface (Typ) then\n+               --  Climb to the ancestor (if any) handling private types\n \n-                  --  Climb to the ancestor (if any) handling private types\n-\n-                  if Present (Full_View (Etype (Typ))) then\n-                     if Full_View (Etype (Typ)) /= Typ then\n-                        Init_Secondary_Tags_Internal (Full_View (Etype (Typ)));\n-                     end if;\n-\n-                  elsif Etype (Typ) /= Typ then\n-                     Init_Secondary_Tags_Internal (Etype (Typ));\n+               if Present (Full_View (Etype (Typ))) then\n+                  if Full_View (Etype (Typ)) /= Typ then\n+                     Init_Secondary_Tags_Internal (Full_View (Etype (Typ)));\n                   end if;\n+\n+               elsif Etype (Typ) /= Typ then\n+                  Init_Secondary_Tags_Internal (Etype (Typ));\n                end if;\n \n                if Present (Abstract_Interfaces (Typ))\n@@ -1787,6 +1785,8 @@ package body Exp_Ch3 is\n                         Aux_N := Node (ADT);\n                         pragma Assert (Present (Aux_N));\n \n+                        Iface := Find_Interface (Typ, E);\n+\n                         --  Initialize the pointer to the secondary DT\n                         --  associated with the interface\n \n@@ -1801,15 +1801,23 @@ package body Exp_Ch3 is\n                               New_Reference_To (Aux_N, Loc)));\n \n                         --  Generate:\n-                        --    Set_Offset_To_Top (DT_Ptr, n);\n+                        --    Set_Offset_To_Top (Init, Iface'Tag, n);\n \n                         Append_To (Body_Stmts,\n                           Make_Procedure_Call_Statement (Loc,\n                             Name => New_Reference_To\n                                       (RTE (RE_Set_Offset_To_Top), Loc),\n                             Parameter_Associations => New_List (\n+                              Make_Attribute_Reference (Loc,\n+                                Prefix => Make_Identifier (Loc, Name_uInit),\n+                                Attribute_Name => Name_Address),\n+\n                               Unchecked_Convert_To (RTE (RE_Tag),\n-                                New_Reference_To (Aux_N, Loc)),\n+                                New_Reference_To\n+                                  (Node (First_Elmt\n+                                         (Access_Disp_Table (Iface))),\n+                                   Loc)),\n+\n                               Unchecked_Convert_To (RTE (RE_Storage_Offset),\n                                 Make_Attribute_Reference (Loc,\n                                   Prefix         =>\n@@ -2118,7 +2126,9 @@ package body Exp_Ch3 is\n \n                --  Case of composite component with its own Init_Proc\n \n-               elsif Has_Non_Null_Base_Init_Proc (Typ) then\n+               elsif not Is_Interface (Typ)\n+                 and then Has_Non_Null_Base_Init_Proc (Typ)\n+               then\n                   Stmts :=\n                     Build_Initialization_Call\n                       (Loc,\n@@ -4743,18 +4753,15 @@ package body Exp_Ch3 is\n          Append_Freeze_Actions (Def_Id, Predef_List);\n \n          --  Populate the two auxiliary tables used for dispatching\n-         --  asynchronous, conditional and timed selects for tagged\n+         --  asynchronous, conditional and timed selects for synchronized\n          --  types that implement a limited interface.\n \n          if Ada_Version >= Ada_05\n-           and then not Is_Interface  (Def_Id)\n-           and then not Is_Abstract   (Def_Id)\n-           and then not Is_Controlled (Def_Id)\n-           and then\n-             Implements_Interface\n-               (Typ          => Def_Id,\n-                Kind         => Any_Limited_Interface,\n-                Check_Parent => True)\n+           and then Is_Concurrent_Record_Type (Def_Id)\n+           and then Implements_Interface (\n+                      Typ          => Def_Id,\n+                      Kind         => Any_Limited_Interface,\n+                      Check_Parent => True)\n          then\n             Append_Freeze_Actions (Def_Id,\n               Make_Select_Specific_Data_Table (Def_Id));\n@@ -5950,26 +5957,25 @@ package body Exp_Ch3 is\n       end if;\n \n       --  Generate the declarations for the following primitive operations:\n+\n       --    disp_asynchronous_select\n       --    disp_conditional_select\n       --    disp_get_prim_op_kind\n       --    disp_get_task_id\n       --    disp_timed_select\n-      --  for limited interfaces and tagged types that implement a limited\n-      --  interface.\n+\n+      --  for limited interfaces and synchronized types that implement a\n+      --  limited interface.\n \n       if Ada_Version >= Ada_05\n         and then\n-            ((Is_Interface (Tag_Typ)\n-                and then Is_Limited_Record (Tag_Typ))\n-          or else\n-             (not Is_Abstract (Tag_Typ)\n-                and then not Is_Controlled (Tag_Typ)\n-              and then\n-                Implements_Interface\n-                  (Typ          => Tag_Typ,\n-                   Kind         => Any_Limited_Interface,\n-                   Check_Parent => True)))\n+          ((Is_Interface (Tag_Typ) and then Is_Limited_Record (Tag_Typ))\n+              or else\n+                (Is_Concurrent_Record_Type (Tag_Typ)\n+                   and then Implements_Interface (\n+                              Typ          => Tag_Typ,\n+                              Kind         => Any_Limited_Interface,\n+                              Check_Parent => True)))\n       then\n          Append_To (Res,\n            Make_Subprogram_Declaration (Loc,\n@@ -6360,20 +6366,18 @@ package body Exp_Ch3 is\n       --    disp_get_task_id\n       --    disp_timed_select\n \n-      --  for limited interfaces and tagged types that implement a limited\n-      --  interface. The interface versions will have null bodies.\n+      --  for limited interfaces and synchronized types that implement a\n+      --  limited interface. The interface versions will have null bodies.\n \n       if Ada_Version >= Ada_05\n         and then\n           ((Is_Interface (Tag_Typ) and then Is_Limited_Record (Tag_Typ))\n               or else\n-                (not Is_Abstract (Tag_Typ)\n-                   and then not Is_Controlled (Tag_Typ)\n-                   and then\n-                     Implements_Interface\n-                       (Typ          => Tag_Typ,\n-                        Kind         => Any_Limited_Interface,\n-                        Check_Parent => True)))\n+                (Is_Concurrent_Record_Type (Tag_Typ)\n+                   and then Implements_Interface (\n+                              Typ          => Tag_Typ,\n+                              Kind         => Any_Limited_Interface,\n+                              Check_Parent => True)))\n       then\n          Append_To (Res, Make_Disp_Asynchronous_Select_Body (Tag_Typ));\n          Append_To (Res, Make_Disp_Conditional_Select_Body  (Tag_Typ));"}, {"sha": "bb9407c7ffb559fed6354f10e743da6461ce5022", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d744221db2ca7b17e1734998d8fb9a7b67608ca/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d744221db2ca7b17e1734998d8fb9a7b67608ca/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=4d744221db2ca7b17e1734998d8fb9a7b67608ca", "patch": "@@ -4289,8 +4289,7 @@ package body Exp_Ch6 is\n                     Expand_Interface_Thunk\n                       (N           => Prim,\n                        Thunk_Alias => Alias (Prim),\n-                       Thunk_Id    => Thunk_Id,\n-                       Thunk_Tag   => Iface_Tag);\n+                       Thunk_Id    => Thunk_Id);\n \n                   Insert_After (N, New_Thunk);\n \n@@ -4341,8 +4340,7 @@ package body Exp_Ch6 is\n                  Expand_Interface_Thunk\n                    (N           => Ancestor_Iface_Prim,\n                     Thunk_Alias => Prim_Op,\n-                    Thunk_Id    => Thunk_Id,\n-                    Thunk_Tag   => Iface_Tag);\n+                    Thunk_Id    => Thunk_Id);\n \n                Insert_After (N, New_Thunk);\n \n@@ -4401,8 +4399,7 @@ package body Exp_Ch6 is\n                  Expand_Interface_Thunk\n                   (N           => Prim,\n                    Thunk_Alias => Prim,\n-                   Thunk_Id    => Thunk_Id,\n-                   Thunk_Tag   => Iface_Tag);\n+                   Thunk_Id    => Thunk_Id);\n \n                Insert_After (N, New_Thunk);\n                Insert_After (New_Thunk,"}, {"sha": "310278d62e0194ac62383649d700300ba8ea8f5b", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 401, "deletions": 448, "changes": 849, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d744221db2ca7b17e1734998d8fb9a7b67608ca/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d744221db2ca7b17e1734998d8fb9a7b67608ca/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=4d744221db2ca7b17e1734998d8fb9a7b67608ca", "patch": "@@ -33,6 +33,7 @@ with Exp_Ch3;  use Exp_Ch3;\n with Exp_Ch11; use Exp_Ch11;\n with Exp_Ch6;  use Exp_Ch6;\n with Exp_Dbug; use Exp_Dbug;\n+with Exp_Sel;  use Exp_Sel;\n with Exp_Smem; use Exp_Smem;\n with Exp_Tss;  use Exp_Tss;\n with Exp_Util; use Exp_Util;\n@@ -61,10 +62,6 @@ with Uintp;    use Uintp;\n \n package body Exp_Ch9 is\n \n-   --------------------------------\n-   -- Select_Expansion_Utilities --\n-   --------------------------------\n-\n    --  The following constant establishes the upper bound for the index of\n    --  an entry family. It is used to limit the allocated size of protected\n    --  types with defaulted discriminant of an integer type, when the bound\n@@ -75,232 +72,6 @@ package body Exp_Ch9 is\n \n    Entry_Family_Bound : constant Int := 2**16;\n \n-   --  The following package contains helper routines used in the expansion of\n-   --  dispatching asynchronous, conditional and timed selects.\n-\n-   package Select_Expansion_Utilities is\n-      function Build_Abort_Block\n-        (Loc         : Source_Ptr;\n-         Abr_Blk_Ent : Entity_Id;\n-         Cln_Blk_Ent : Entity_Id;\n-         Blk         : Node_Id) return Node_Id;\n-      --  Generate:\n-      --    begin\n-      --       Blk\n-      --    exception\n-      --       when Abort_Signal => Abort_Undefer;\n-      --    end;\n-      --  Abr_Blk_Ent is the name of the generated block, Cln_Blk_Ent is\n-      --  the name of the encapsulated cleanup block, Blk is the actual\n-      --  block node.\n-\n-      function Build_B\n-        (Loc   : Source_Ptr;\n-         Decls : List_Id) return Entity_Id;\n-      --  Generate:\n-      --    B : Boolean := False;\n-      --  Append the object declaration to the list and return the name of\n-      --  the object.\n-\n-      function Build_C\n-        (Loc   : Source_Ptr;\n-         Decls : List_Id) return Entity_Id;\n-      --  Generate:\n-      --    C : Ada.Tags.Prim_Op_Kind;\n-      --  Append the object declaration to the list and return the name of\n-      --  the object.\n-\n-      function Build_Cleanup_Block\n-        (Loc       : Source_Ptr;\n-         Blk_Ent   : Entity_Id;\n-         Stmts     : List_Id;\n-         Clean_Ent : Entity_Id) return Node_Id;\n-      --  Generate:\n-      --    declare\n-      --       procedure _clean is\n-      --       begin\n-      --          ...\n-      --       end _clean;\n-      --    begin\n-      --       Stmts\n-      --    at end\n-      --       _clean;\n-      --    end;\n-      --  Blk_Ent is the name of the generated block, Stmts is the list\n-      --  of encapsulated statements and Clean_Ent is the parameter to\n-      --  the _clean procedure.\n-\n-      function Build_S\n-        (Loc      : Source_Ptr;\n-         Decls    : List_Id;\n-         Obj      : Entity_Id;\n-         Call_Ent : Entity_Id) return Entity_Id;\n-      --  Generate:\n-      --    S : constant Integer :=\n-      --          Ada.Tags.Get_Offset_Index (\n-      --            Unchecked_Convert_To (Ada.Tags.Interface_Tag, Obj),\n-      --            DT_Position (Call_Ent));\n-      --  where Obj is the pointer to a secondary table, Call_Ent is the\n-      --  entity of the dispatching call name. Append the object declaration\n-      --  to the list and return its defining identifier.\n-\n-   end Select_Expansion_Utilities;\n-\n-   -----------------------------------------\n-   -- Body for Select_Expansion_Utilities --\n-   -----------------------------------------\n-\n-   package body Select_Expansion_Utilities is\n-\n-      -----------------------\n-      -- Build_Abort_Block --\n-      -----------------------\n-\n-      function Build_Abort_Block\n-        (Loc         : Source_Ptr;\n-         Abr_Blk_Ent : Entity_Id;\n-         Cln_Blk_Ent : Entity_Id;\n-         Blk         : Node_Id) return Node_Id\n-      is\n-      begin\n-         return\n-           Make_Block_Statement (Loc,\n-             Identifier   => New_Reference_To (Abr_Blk_Ent, Loc),\n-\n-             Declarations => No_List,\n-\n-             Handled_Statement_Sequence =>\n-               Make_Handled_Sequence_Of_Statements (Loc,\n-                 Statements =>\n-                   New_List (\n-                     Make_Implicit_Label_Declaration (Loc,\n-                       Defining_Identifier =>\n-                         Cln_Blk_Ent,\n-                       Label_Construct =>\n-                         Blk),\n-                     Blk),\n-\n-                 Exception_Handlers =>\n-                   New_List (\n-                     Make_Exception_Handler (Loc,\n-                       Exception_Choices =>\n-                         New_List (\n-                           New_Reference_To (Stand.Abort_Signal, Loc)),\n-                       Statements =>\n-                         New_List (\n-                           Make_Procedure_Call_Statement (Loc,\n-                             Name =>\n-                               New_Reference_To (RTE (\n-                                 RE_Abort_Undefer), Loc),\n-                             Parameter_Associations => No_List))))));\n-      end Build_Abort_Block;\n-\n-      -------------\n-      -- Build_B --\n-      -------------\n-\n-      function Build_B\n-        (Loc   : Source_Ptr;\n-         Decls : List_Id) return Entity_Id\n-      is\n-         B : constant Entity_Id := Make_Defining_Identifier (Loc,\n-                                     Chars => New_Internal_Name ('B'));\n-\n-      begin\n-         Append_To (Decls,\n-           Make_Object_Declaration (Loc,\n-             Defining_Identifier =>\n-               B,\n-             Object_Definition =>\n-               New_Reference_To (Standard_Boolean, Loc),\n-             Expression =>\n-               New_Reference_To (Standard_False, Loc)));\n-\n-         return B;\n-      end Build_B;\n-\n-      -------------\n-      -- Build_C --\n-      -------------\n-\n-      function Build_C\n-        (Loc   : Source_Ptr;\n-         Decls : List_Id) return Entity_Id\n-      is\n-         C : constant Entity_Id := Make_Defining_Identifier (Loc,\n-                                     Chars => New_Internal_Name ('C'));\n-\n-      begin\n-         Append_To (Decls,\n-           Make_Object_Declaration (Loc,\n-             Defining_Identifier =>\n-               C,\n-             Object_Definition =>\n-               New_Reference_To (RTE (RE_Prim_Op_Kind), Loc)));\n-\n-         return C;\n-      end Build_C;\n-\n-      -------------------------\n-      -- Build_Cleanup_Block --\n-      -------------------------\n-\n-      function Build_Cleanup_Block\n-        (Loc       : Source_Ptr;\n-         Blk_Ent   : Entity_Id;\n-         Stmts     : List_Id;\n-         Clean_Ent : Entity_Id) return Node_Id\n-      is\n-         Cleanup_Block : constant Node_Id :=\n-                           Make_Block_Statement (Loc,\n-                             Identifier   => New_Reference_To (Blk_Ent, Loc),\n-                             Declarations => No_List,\n-                             Handled_Statement_Sequence =>\n-                               Make_Handled_Sequence_Of_Statements (Loc,\n-                                 Statements => Stmts),\n-                             Is_Asynchronous_Call_Block => True);\n-\n-      begin\n-         Set_Entry_Cancel_Parameter (Blk_Ent, Clean_Ent);\n-\n-         return Cleanup_Block;\n-      end Build_Cleanup_Block;\n-\n-      -------------\n-      -- Build_S --\n-      -------------\n-\n-      function Build_S\n-        (Loc      : Source_Ptr;\n-         Decls    : List_Id;\n-         Obj      : Entity_Id;\n-         Call_Ent : Entity_Id) return Entity_Id\n-      is\n-         S : constant Entity_Id := Make_Defining_Identifier (Loc,\n-                                     Chars => New_Internal_Name ('S'));\n-\n-      begin\n-         Append_To (Decls,\n-           Make_Object_Declaration (Loc,\n-             Defining_Identifier => S,\n-             Constant_Present    => True,\n-\n-             Object_Definition   =>\n-               New_Reference_To (Standard_Integer, Loc),\n-\n-             Expression          =>\n-               Make_Function_Call (Loc,\n-                 Name => New_Reference_To (RTE (RE_Get_Offset_Index), Loc),\n-                 Parameter_Associations => New_List (\n-                   Unchecked_Convert_To (RTE (RE_Interface_Tag), Obj),\n-                   Make_Integer_Literal (Loc, DT_Position (Call_Ent))))));\n-\n-         return S;\n-      end Build_S;\n-   end Select_Expansion_Utilities;\n-\n-   package SEU renames Select_Expansion_Utilities;\n-\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -2210,6 +1981,7 @@ package body Exp_Ch9 is\n       if Abort_Allowed\n         or else Restriction_Active (No_Entry_Queue) = False\n         or else Number_Entries (Pid) > 1\n+        or else (Has_Attach_Handler (Pid) and then not Restricted_Profile)\n       then\n          Complete := New_Reference_To (RTE (RE_Complete_Entry_Body), Loc);\n       else\n@@ -2251,6 +2023,7 @@ package body Exp_Ch9 is\n          if Abort_Allowed\n            or else Restriction_Active (No_Entry_Queue) = False\n            or else Number_Entries (Pid) > 1\n+           or else (Has_Attach_Handler (Pid) and then not Restricted_Profile)\n          then\n             Complete :=\n               New_Reference_To (RTE (RE_Exceptional_Complete_Entry_Body), Loc);\n@@ -2660,6 +2433,7 @@ package body Exp_Ch9 is\n          if Abort_Allowed\n            or else Restriction_Active (No_Entry_Queue) = False\n            or else Number_Entries (Pid) > 1\n+           or else (Has_Attach_Handler (Pid) and then not Restricted_Profile)\n          then\n             Lock_Name := New_Reference_To (RTE (RE_Lock_Entries), Loc);\n             Service_Name := New_Reference_To (RTE (RE_Service_Entries), Loc);\n@@ -2994,6 +2768,8 @@ package body Exp_Ch9 is\n            or else Restriction_Active (No_Entry_Queue) = False\n            or else not Is_Protected_Type (Conctyp)\n            or else Number_Entries (Conctyp) > 1\n+           or else (Has_Attach_Handler (Conctyp)\n+                     and then not Restricted_Profile)\n          then\n             X := Make_Defining_Identifier (Loc, Name_uX);\n \n@@ -3133,6 +2909,8 @@ package body Exp_Ch9 is\n             if Abort_Allowed\n               or else Restriction_Active (No_Entry_Queue) = False\n               or else Number_Entries (Conctyp) > 1\n+              or else (Has_Attach_Handler (Conctyp)\n+                        and then not Restricted_Profile)\n             then\n                --  Change the type of the index declaration\n \n@@ -4898,86 +4676,98 @@ package body Exp_Ch9 is\n    --  Ada 2005 (AI-345): If the trigger is a dispatching call, the select is\n    --  expanded into:\n \n-   --  declare\n-   --     B   : Boolean := False;\n-   --     Bnn : Communication_Block;\n-   --     C   : Ada.Tags.Prim_Op_Kind;\n-   --     P   : Parameters := (Param1 .. ParamN)\n-   --     S   : constant Integer := DT_Position (<dispatching-call>);\n-   --     U   : Boolean;\n-\n-   --  begin\n-   --     disp_get_prim_op_kind (<object>, S, C);\n-\n-   --     if C = POK_Protected_Entry then\n-   --        declare\n-   --           procedure _clean is\n-   --           begin\n-   --              if Enqueued (Bnn) then\n-   --                 Cancel_Protected_Entry_Call (Bnn);\n-   --              end if;\n-   --           end _clean;\n-\n-   --        begin\n-   --           begin\n-   --              disp_asynchronous_select\n-   --                (Obj, S, P'address, Bnn, B);\n-\n-   --              Param1 := P.Param1;\n-   --              ...\n-   --              ParamN := P.ParamN;\n-\n-   --              if Enqueued (Bnn) then\n-   --                 <abortable-statements>\n-   --              end if;\n-   --           at end\n-   --              _clean;\n-   --           end;\n-   --        exception\n-   --           when Abort_Signal => Abort_Undefer;\n-   --        end;\n-\n-   --        if not Cancelled (Bnn) then\n-   --           <triggering-statements>\n-   --        end if;\n-\n-   --     elsif C = POK_Task_Entry then\n-   --        declare\n-   --           procedure _clean is\n-   --           begin\n-   --              Cancel_Task_Entry_Call (U);\n-   --           end _clean;\n-\n-   --        begin\n-   --           Abort_Defer;\n-\n-   --           disp_asynchronous_select\n-   --             (<object>, S, P'address, Bnn, B);\n+   --    declare\n+   --       B   : Boolean := False;\n+   --       Bnn : Communication_Block;\n+   --       C   : Ada.Tags.Prim_Op_Kind;\n+   --       K   : Ada.Tags.Tagged_Kind :=\n+   --               Ada.Tags.Get_Tagged_Kind (Ada.Tags.Tag (<object>));\n+   --       P   : Parameters := (Param1 .. ParamN);\n+   --       S   : Integer;\n+   --       U   : Boolean;\n \n-   --           Param1 := P.Param1;\n-   --           ...\n-   --           ParamN := P.ParamN;\n-\n-   --           begin\n-   --              begin\n-   --                 Abort_Undefer;\n-   --                 <abortable-statements>\n-   --              at end\n-   --                 _clean;\n-   --              end;\n-   --           exception\n-   --              when Abort_Signal => Abort_Undefer;\n-   --           end;\n-\n-   --           if not U then\n-   --              <triggering-statements>\n-   --           end if;\n-   --        end;\n+   --    begin\n+   --       if K = Ada.Tags.TK_Limited_Tagged then\n+   --          <dispatching-call>;\n+   --          <triggering-statements>;\n \n-   --     else\n-   --        <dispatching-call>;\n-   --        <triggering-statements>\n-   --     end if;\n+   --       else\n+   --          S := Ada.Tags.Get_Offset_Index (Ada.Tags.Tag (<object>),\n+   --                 DT_Position (<dispatching-call>));\n+\n+   --          _Disp_Get_Prim_Op_Kind (<object>, S, C);\n+\n+   --          if C = POK_Protected_Entry then\n+   --             declare\n+   --                procedure _clean is\n+   --                begin\n+   --                   if Enqueued (Bnn) then\n+   --                      Cancel_Protected_Entry_Call (Bnn);\n+   --                   end if;\n+   --                end _clean;\n+\n+   --             begin\n+   --                begin\n+   --                   _Disp_Asynchronous_Select\n+   --                     (<object>, S, P'address, Bnn, B);\n+\n+   --                   Param1 := P.Param1;\n+   --                   ...\n+   --                   ParamN := P.ParamN;\n+\n+   --                   if Enqueued (Bnn) then\n+   --                      <abortable-statements>\n+   --                   end if;\n+   --                at end\n+   --                   _clean;\n+   --                end;\n+   --             exception\n+   --                when Abort_Signal => Abort_Undefer;\n+   --             end;\n+\n+   --             if not Cancelled (Bnn) then\n+   --                <triggering-statements>\n+   --             end if;\n+\n+   --          elsif C = POK_Task_Entry then\n+   --             declare\n+   --                procedure _clean is\n+   --                begin\n+   --                   Cancel_Task_Entry_Call (U);\n+   --                end _clean;\n+\n+   --             begin\n+   --                Abort_Defer;\n+\n+   --                _Disp_Asynchronous_Select\n+   --                  (<object>, S, P'address, Bnn, B);\n+\n+   --                Param1 := P.Param1;\n+   --                ...\n+   --                ParamN := P.ParamN;\n+\n+   --                begin\n+   --                   begin\n+   --                      Abort_Undefer;\n+   --                      <abortable-statements>\n+   --                   at end\n+   --                      _clean;\n+   --                   end;\n+   --                exception\n+   --                   when Abort_Signal => Abort_Undefer;\n+   --                end;\n+\n+   --                if not U then\n+   --                   <triggering-statements>\n+   --                end if;\n+   --             end;\n+\n+   --          else\n+   --             <dispatching-call>;\n+   --             <triggering-statements>\n+   --          end if;\n+   --       end if;\n+   --    end;\n \n    --  The job is to convert this to the asynchronous form\n \n@@ -5011,6 +4801,7 @@ package body Exp_Ch9 is\n       Cleanup_Block     : Node_Id;\n       Cleanup_Block_Ent : Entity_Id;\n       Cleanup_Stmts     : List_Id;\n+      Conc_Typ_Stmts    : List_Id;\n       Concval           : Node_Id;\n       Dblock_Ent        : Entity_Id;\n       Decl              : Node_Id;\n@@ -5021,6 +4812,7 @@ package body Exp_Ch9 is\n       Formals           : List_Id;\n       Hdle              : List_Id;\n       Index             : Node_Id;\n+      Lim_Typ_Stmts     : List_Id;\n       N_Orig            : Node_Id;\n       Obj               : Entity_Id;\n       Param             : Node_Id;\n@@ -5037,6 +4829,7 @@ package body Exp_Ch9 is\n       B   : Entity_Id;  --  Call status flag\n       Bnn : Entity_Id;  --  Communication block\n       C   : Entity_Id;  --  Call kind\n+      K   : Entity_Id;  --  Tagged kind\n       P   : Entity_Id;  --  Parameter block\n       S   : Entity_Id;  --  Primitive operation slot\n       T   : Entity_Id;  --  Additional status flag\n@@ -5077,7 +4870,7 @@ package body Exp_Ch9 is\n             --  Call status flag processing, generate:\n             --    B : Boolean := False;\n \n-            B := SEU.Build_B (Loc, Decls);\n+            B := Build_B (Loc, Decls);\n \n             --  Communication block processing, generate:\n             --    Bnn : Communication_Block;\n@@ -5094,7 +4887,13 @@ package body Exp_Ch9 is\n             --  Call kind processing, generate:\n             --    C : Ada.Tags.Prim_Op_Kind;\n \n-            C := SEU.Build_C (Loc, Decls);\n+            C := Build_C (Loc, Decls);\n+\n+            --  Tagged kind processing, generate:\n+            --    K : Ada.Tags.Tagged_Kind :=\n+            --          Ada.Tags.Get_Tagged_Kind (Ada.Tags.Tag (<object>));\n+\n+            K := Build_K (Loc, Decls, Obj);\n \n             --  Parameter block processing\n \n@@ -5104,12 +4903,9 @@ package body Exp_Ch9 is\n                          (Loc, Blk_Typ, Actuals, Formals, Decls, Stmts);\n \n             --  Dispatch table slot processing, generate:\n-            --    S : constant Integer :=\n-            --          Ada.Tags.Get_Offset_Index (\n-            --            Unchecked_Convert_To (Ada.Tags.Interface_Tag, Obj),\n-            --            DT_Position (<dispatching-procedure>));\n+            --    S : Integer;\n \n-            S := SEU.Build_S (Loc, Decls, Obj, Call_Ent);\n+            S := Build_S (Loc, Decls);\n \n             --  Additional status flag processing, generate:\n \n@@ -5122,19 +4918,6 @@ package body Exp_Ch9 is\n                 Object_Definition =>\n                   New_Reference_To (Standard_Boolean, Loc)));\n \n-            Append_To (Stmts,\n-              Make_Procedure_Call_Statement (Loc,\n-                Name =>\n-                  New_Reference_To (\n-                    Find_Prim_Op (Etype (Etype (Obj)),\n-                      Name_uDisp_Get_Prim_Op_Kind),\n-                  Loc),\n-                Parameter_Associations =>\n-                  New_List (\n-                    New_Copy_Tree    (Obj),\n-                    New_Reference_To (S, Loc),\n-                    New_Reference_To (C, Loc))));\n-\n             --  ---------------------------------------------------------------\n             --  Protected entry handling\n \n@@ -5146,16 +4929,15 @@ package body Exp_Ch9 is\n             Cleanup_Stmts := Parameter_Block_Unpack (Loc, P, Actuals, Formals);\n \n             --  Generate:\n-            --    _dispatching_asynchronous_select\n-            --      (<object>, S, P'address, Bnn, B);\n+            --    _Disp_Asynchronous_Select (<object>, S, P'address, Bnn, B);\n \n             Prepend_To (Cleanup_Stmts,\n               Make_Procedure_Call_Statement (Loc,\n                 Name =>\n                   New_Reference_To (\n                     Find_Prim_Op (Etype (Etype (Obj)),\n                       Name_uDisp_Asynchronous_Select),\n-                  Loc),\n+                    Loc),\n                 Parameter_Associations =>\n                   New_List (\n                     New_Copy_Tree    (Obj),\n@@ -5204,8 +4986,8 @@ package body Exp_Ch9 is\n             Cleanup_Block_Ent :=\n               Make_Defining_Identifier (Loc, New_Internal_Name ('C'));\n \n-            Cleanup_Block := SEU.Build_Cleanup_Block (Loc,\n-              Cleanup_Block_Ent, Cleanup_Stmts, Bnn);\n+            Cleanup_Block :=\n+              Build_Cleanup_Block (Loc, Cleanup_Block_Ent, Cleanup_Stmts, Bnn);\n \n             --  Wrap the cleanup block in an exception handling block\n \n@@ -5224,8 +5006,8 @@ package body Exp_Ch9 is\n                 Make_Implicit_Label_Declaration (Loc,\n                   Defining_Identifier => Abort_Block_Ent),\n \n-                SEU.Build_Abort_Block (Loc,\n-                  Abort_Block_Ent, Cleanup_Block_Ent, Cleanup_Block));\n+                Build_Abort_Block\n+                  (Loc, Abort_Block_Ent, Cleanup_Block_Ent, Cleanup_Block));\n \n             --  Generate:\n             --    if not Cancelled (Bnn) then\n@@ -5258,16 +5040,15 @@ package body Exp_Ch9 is\n             TaskE_Stmts := Parameter_Block_Unpack (Loc, P, Actuals, Formals);\n \n             --  Generate:\n-            --    _dispatching_asynchronous_select\n-            --      (<object>, S, P'address, Bnn, B);\n+            --    _Disp_Asynchronous_Select (<object>, S, P'address, Bnn, B);\n \n             Prepend_To (TaskE_Stmts,\n               Make_Procedure_Call_Statement (Loc,\n                 Name =>\n                   New_Reference_To (\n                     Find_Prim_Op (Etype (Etype (Obj)),\n                       Name_uDisp_Asynchronous_Select),\n-                  Loc),\n+                    Loc),\n                 Parameter_Associations =>\n                   New_List (\n                     New_Copy_Tree    (Obj),\n@@ -5319,8 +5100,8 @@ package body Exp_Ch9 is\n             Cleanup_Block_Ent :=\n               Make_Defining_Identifier (Loc, New_Internal_Name ('C'));\n \n-            Cleanup_Block := SEU.Build_Cleanup_Block (Loc,\n-              Cleanup_Block_Ent, Cleanup_Stmts, T);\n+            Cleanup_Block :=\n+              Build_Cleanup_Block (Loc, Cleanup_Block_Ent, Cleanup_Stmts, T);\n \n             --  Wrap the cleanup block in an exception handling block\n \n@@ -5339,8 +5120,8 @@ package body Exp_Ch9 is\n                 Defining_Identifier => Abort_Block_Ent));\n \n             Append_To (TaskE_Stmts,\n-              SEU.Build_Abort_Block (Loc,\n-                Abort_Block_Ent, Cleanup_Block_Ent, Cleanup_Block));\n+              Build_Abort_Block\n+                (Loc, Abort_Block_Ent, Cleanup_Block_Ent, Cleanup_Block));\n \n             --  Generate:\n             --    if not T then\n@@ -5367,6 +5148,29 @@ package body Exp_Ch9 is\n             ProtP_Stmts := New_Copy_List_Tree (Tstats);\n             Prepend_To (ProtP_Stmts, New_Copy_Tree (Ecall));\n \n+            --  Generate:\n+            --    S := Ada.Tags.Get_Offset_Index (\n+            --           Ada.Tags.Tag (<object>), DT_Position (Call_Ent));\n+\n+            Conc_Typ_Stmts := New_List (\n+              Build_S_Assignment (Loc, S, Obj, Call_Ent));\n+\n+            --  Generate:\n+            --    _Disp_Get_Prim_Op_Kind (<object>, S, C);\n+\n+            Append_To (Conc_Typ_Stmts,\n+              Make_Procedure_Call_Statement (Loc,\n+                Name =>\n+                  New_Reference_To (\n+                    Find_Prim_Op (Etype (Etype (Obj)),\n+                      Name_uDisp_Get_Prim_Op_Kind),\n+                    Loc),\n+                Parameter_Associations =>\n+                  New_List (\n+                    New_Copy_Tree    (Obj),\n+                    New_Reference_To (S, Loc),\n+                    New_Reference_To (C, Loc))));\n+\n             --  Generate:\n             --    if C = POK_Procedure_Entry then\n             --       ProtE_Stmts\n@@ -5376,7 +5180,7 @@ package body Exp_Ch9 is\n             --       ProtP_Stmts\n             --    end if;\n \n-            Append_To (Stmts,\n+            Append_To (Conc_Typ_Stmts,\n               Make_If_Statement (Loc,\n                 Condition =>\n                   Make_Op_Eq (Loc,\n@@ -5404,6 +5208,35 @@ package body Exp_Ch9 is\n                 Else_Statements =>\n                   ProtP_Stmts));\n \n+            --  Generate:\n+            --    <dispatching-call>;\n+            --    <triggering-statements>\n+\n+            Lim_Typ_Stmts := New_Copy_List_Tree (Tstats);\n+            Prepend_To (Lim_Typ_Stmts, New_Copy_Tree (Ecall));\n+\n+            --  Generate:\n+            --    if K = Ada.Tags.TK_Limited_Tagged then\n+            --       Lim_Typ_Stmts\n+            --    else\n+            --       Conc_Typ_Stmts\n+            --    end if;\n+\n+            Append_To (Stmts,\n+              Make_If_Statement (Loc,\n+                Condition =>\n+                   Make_Op_Eq (Loc,\n+                     Left_Opnd =>\n+                       New_Reference_To (K, Loc),\n+                     Right_Opnd =>\n+                       New_Reference_To (RTE (RE_TK_Limited_Tagged), Loc)),\n+\n+                Then_Statements =>\n+                  Lim_Typ_Stmts,\n+\n+                Else_Statements =>\n+                  Conc_Typ_Stmts));\n+\n             Rewrite (N,\n               Make_Block_Statement (Loc,\n                 Declarations =>\n@@ -5866,30 +5699,42 @@ package body Exp_Ch9 is\n    --    declare\n    --       B : Boolean := False;\n    --       C : Ada.Tags.Prim_Op_Kind;\n+   --       K : Ada.Tags.Tagged_Kind :=\n+   --             Ada.Tags.Get_Tagged_Kind (Ada.Tags.Tag (<object>));\n    --       P : Parameters := (Param1 .. ParamN);\n-   --       S : constant Integer := DT_Position (<dispatching-procedure>);\n+   --       S : Integer;\n \n    --    begin\n-   --       disp_conditional_select (<object>, S, P'address, C, B);\n+   --       if K = Ada.Tags.TK_Limited_Tagged then\n+   --          <dispatching-call>;\n+   --          <triggering-statements>\n \n-   --       if C = POK_Protected_Entry\n-   --         or else C = POK_Task_Entry\n-   --       then\n-   --          Param1 := P.Param1;\n-   --          ...\n-   --          ParamN := P.ParamN;\n-   --       end if;\n+   --       else\n+   --          S := Ada.Tags.Get_Offset_Index (Ada.Tags.Tag (<object>),\n+   --                 DT_Position (<dispatching-call>));\n \n-   --       if B then\n-   --          if C = POK_Procedure\n-   --            or else C = POK_Protected_Procedure\n-   --            or else C = POK_Task_Procedure\n+   --          _Disp_Conditional_Select (<object>, S, P'address, C, B);\n+\n+   --          if C = POK_Protected_Entry\n+   --            or else C = POK_Task_Entry\n    --          then\n-   --             <dispatching-procedure> (<object>, Param1 .. ParamN);\n+   --             Param1 := P.Param1;\n+   --             ...\n+   --             ParamN := P.ParamN;\n+   --          end if;\n+\n+   --          if B then\n+   --             if C = POK_Procedure\n+   --               or else C = POK_Protected_Procedure\n+   --               or else C = POK_Task_Procedure\n+   --             then\n+   --                <dispatching-call>;\n+   --             end if;\n+\n+   --             <triggering-statements>\n+   --          else\n+   --             <else-statements>\n    --          end if;\n-   --          <normal-statements>\n-   --       else\n-   --          <else-statements>\n    --       end if;\n    --    end;\n \n@@ -5899,25 +5744,28 @@ package body Exp_Ch9 is\n       Blk : Node_Id             := Entry_Call_Statement (Alt);\n       Transient_Blk : Node_Id;\n \n-      Actuals  : List_Id;\n-      Blk_Typ  : Entity_Id;\n-      Call     : Node_Id;\n-      Call_Ent : Entity_Id;\n-      Decl     : Node_Id;\n-      Decls    : List_Id;\n-      Formals  : List_Id;\n-      N_Stats  : List_Id;\n-      Obj      : Entity_Id;\n-      Param    : Node_Id;\n-      Params   : List_Id;\n-      Stmt     : Node_Id;\n-      Stmts    : List_Id;\n-      Unpack   : List_Id;\n-\n-      B        : Entity_Id;  --  Call status flag\n-      C        : Entity_Id;  --  Call kind\n-      P        : Entity_Id;  --  Parameter block\n-      S        : Entity_Id;  --  Primitive operation slot\n+      Actuals        : List_Id;\n+      Blk_Typ        : Entity_Id;\n+      Call           : Node_Id;\n+      Call_Ent       : Entity_Id;\n+      Conc_Typ_Stmts : List_Id;\n+      Decl           : Node_Id;\n+      Decls          : List_Id;\n+      Formals        : List_Id;\n+      Lim_Typ_Stmts  : List_Id;\n+      N_Stats        : List_Id;\n+      Obj            : Entity_Id;\n+      Param          : Node_Id;\n+      Params         : List_Id;\n+      Stmt           : Node_Id;\n+      Stmts          : List_Id;\n+      Unpack         : List_Id;\n+\n+      B : Entity_Id;  --  Call status flag\n+      C : Entity_Id;  --  Call kind\n+      K : Entity_Id;  --  Tagged kind\n+      P : Entity_Id;  --  Parameter block\n+      S : Entity_Id;  --  Primitive operation slot\n \n    begin\n       if Ada_Version >= Ada_05\n@@ -5931,31 +5779,41 @@ package body Exp_Ch9 is\n          --  Call status flag processing, generate:\n          --    B : Boolean := False;\n \n-         B := SEU.Build_B (Loc, Decls);\n+         B := Build_B (Loc, Decls);\n \n          --  Call kind processing, generate:\n          --    C : Ada.Tags.Prim_Op_Kind;\n \n-         C := SEU.Build_C (Loc, Decls);\n+         C := Build_C (Loc, Decls);\n+\n+         --  Tagged kind processing, generate:\n+         --    K : Ada.Tags.Tagged_Kind :=\n+         --          Ada.Tags.Get_Tagged_Kind (Ada.Tags.Tag (<object>));\n+\n+         K := Build_K (Loc, Decls, Obj);\n \n          --  Parameter block processing\n \n          Blk_Typ := Build_Parameter_Block (Loc, Actuals, Formals, Decls);\n-         P       := Parameter_Block_Pack  (Loc, Blk_Typ, Actuals, Formals,\n-                      Decls, Stmts);\n+         P       := Parameter_Block_Pack\n+                      (Loc, Blk_Typ, Actuals, Formals, Decls, Stmts);\n \n          --  Dispatch table slot processing, generate:\n-         --    S : constant Integer :=\n-         --          Ada.Tags.Get_Offset_Index (\n-         --            Unchecked_Convert_To (Ada.Tags.Interface_Tag, Obj),\n-         --            DT_Position (<dispatching-procedure>));\n+         --    S : Integer;\n \n-         S := SEU.Build_S (Loc, Decls, Obj, Call_Ent);\n+         S := Build_S (Loc, Decls);\n \n          --  Generate:\n-         --    _dispatching_conditional_select (<object>, S, P'address, C, B);\n+         --    S := Ada.Tags.Get_Offset_Index (\n+         --           Ada.Tags.Tag (<object>), DT_Position (Call_Ent));\n \n-         Append_To (Stmts,\n+         Conc_Typ_Stmts := New_List (\n+           Build_S_Assignment (Loc, S, Obj, Call_Ent));\n+\n+         --  Generate:\n+         --    _Disp_Conditional_Select (<object>, S, P'address, C, B);\n+\n+         Append_To (Conc_Typ_Stmts,\n            Make_Procedure_Call_Statement (Loc,\n              Name =>\n                New_Reference_To (\n@@ -5987,7 +5845,7 @@ package body Exp_Ch9 is\n          --  explicit assignments to their corresponding actuals.\n \n          if Present (Unpack) then\n-            Append_To (Stmts,\n+            Append_To (Conc_Typ_Stmts,\n               Make_If_Statement (Loc,\n \n                 Condition =>\n@@ -6006,7 +5864,8 @@ package body Exp_Ch9 is\n                         Right_Opnd =>\n                           New_Reference_To (RTE (RE_POK_Task_Entry), Loc))),\n \n-                 Then_Statements => Unpack));\n+                 Then_Statements =>\n+                   Unpack));\n          end if;\n \n          --  Generate:\n@@ -6015,7 +5874,7 @@ package body Exp_Ch9 is\n          --         or else C = POK_Protected_Procedure\n          --         or else C = POK_Task_Procedure\n          --       then\n-         --          <dispatching-procedure-call>\n+         --          <dispatching-call>\n          --       end if;\n          --       <normal-statements>\n          --    else\n@@ -6056,12 +5915,41 @@ package body Exp_Ch9 is\n              Then_Statements =>\n                New_List (Blk)));\n \n-         Append_To (Stmts,\n+         Append_To (Conc_Typ_Stmts,\n            Make_If_Statement (Loc,\n              Condition       => New_Reference_To (B, Loc),\n              Then_Statements => N_Stats,\n              Else_Statements => Else_Statements (N)));\n \n+         --  Generate:\n+         --    <dispatching-call>;\n+         --    <triggering-statements>\n+\n+         Lim_Typ_Stmts := New_Copy_List_Tree (Statements (Alt));\n+         Prepend_To (Lim_Typ_Stmts, New_Copy_Tree (Blk));\n+\n+         --  Generate:\n+         --    if K = Ada.Tags.TK_Limited_Tagged then\n+         --       Lim_Typ_Stmts\n+         --    else\n+         --       Conc_Typ_Stmts\n+         --    end if;\n+\n+         Append_To (Stmts,\n+           Make_If_Statement (Loc,\n+             Condition =>\n+               Make_Op_Eq (Loc,\n+                 Left_Opnd =>\n+                   New_Reference_To (K, Loc),\n+                 Right_Opnd =>\n+                   New_Reference_To (RTE (RE_TK_Limited_Tagged), Loc)),\n+\n+             Then_Statements =>\n+               Lim_Typ_Stmts,\n+\n+             Else_Statements =>\n+               Conc_Typ_Stmts));\n+\n          Rewrite (N,\n            Make_Block_Statement (Loc,\n              Declarations               => Decls,\n@@ -6771,8 +6659,10 @@ package body Exp_Ch9 is\n \n       if Has_Entries\n         and then (Abort_Allowed\n-                    or else Restriction_Active (No_Entry_Queue) = False\n-                    or else Num_Entries > 1)\n+                  or else Restriction_Active (No_Entry_Queue) = False\n+                  or else Num_Entries > 1\n+                  or else (Has_Attach_Handler (Pid)\n+                            and then not Restricted_Profile))\n       then\n          New_Op_Body := Build_Find_Body_Index (Pid);\n          Insert_After (Current_Node, New_Op_Body);\n@@ -7494,6 +7384,8 @@ package body Exp_Ch9 is\n          if Abort_Allowed\n            or else Restriction_Active (No_Entry_Queue) = False\n            or else E_Count > 1\n+           or else (Has_Attach_Handler (Prottyp)\n+                     and then not Restricted_Profile)\n          then\n             Body_Arr := Make_Object_Declaration (Loc,\n               Defining_Identifier => Body_Id,\n@@ -7543,6 +7435,8 @@ package body Exp_Ch9 is\n          if Abort_Allowed\n            or else Restriction_Active (No_Entry_Queue) = False\n            or else E_Count > 1\n+           or else (Has_Attach_Handler (Prottyp)\n+                     and then not Restricted_Profile)\n          then\n             Sub :=\n               Make_Subprogram_Declaration (Loc,\n@@ -9538,31 +9432,43 @@ package body Exp_Ch9 is\n    --       B  : Boolean := False;\n    --       C  : Ada.Tags.Prim_Op_Kind;\n    --       DX : Duration := To_Duration (D)\n+   --       K : Ada.Tags.Tagged_Kind :=\n+   --             Ada.Tags.Get_Tagged_Kind (Ada.Tags.Tag (<object>));\n    --       M  : Integer :=...;\n    --       P  : Parameters := (Param1 .. ParamN);\n-   --       S  : constant Iteger := DT_Position (<dispatching-procedure>);\n+   --       S  : Iteger;\n \n    --    begin\n-   --       disp_timed_select (<object>, S, P'Address, DX, M, C, B);\n+   --       if K = Ada.Tags.TK_Limited_Tagged then\n+   --          <dispatching-call>;\n+   --          <triggering-statements>\n \n-   --       if C = POK_Protected_Entry\n-   --         or else C = POK_Task_Entry\n-   --       then\n-   --          Param1 := P.Param1;\n-   --          ...\n-   --          ParamN := P.ParamN;\n-   --       end if;\n+   --       else\n+   --          S := Ada.Tags.Get_Offset_Index (Ada.Tags.Tag (<object>),\n+   --                 DT_Position (<dispatching-call>));\n \n-   --       if B then\n-   --          if C = POK_Procedure\n-   --            or else C = POK_Protected_Procedure\n-   --            or else C = POK_Task_Procedure\n+   --          _Disp_Timed_Select (<object>, S, P'Address, DX, M, C, B);\n+\n+   --          if C = POK_Protected_Entry\n+   --            or else C = POK_Task_Entry\n    --          then\n-   --             T.E;\n+   --             Param1 := P.Param1;\n+   --             ...\n+   --             ParamN := P.ParamN;\n+   --          end if;\n+\n+   --          if B then\n+   --             if C = POK_Procedure\n+   --               or else C = POK_Protected_Procedure\n+   --               or else C = POK_Task_Procedure\n+   --             then\n+   --                <dispatching-call>;\n+   --             end if;\n+\n+   --             <triggering-statements>\n+   --          else\n+   --             <timed-statements>\n    --          end if;\n-   --          S1;\n-   --       else\n-   --          S2;\n    --       end if;\n    --    end;\n \n@@ -9578,30 +9484,33 @@ package body Exp_Ch9 is\n       D_Stats : constant List_Id :=\n                   Statements (Delay_Alternative (N));\n \n-      Actuals  : List_Id;\n-      Blk_Typ  : Entity_Id;\n-      Call     : Node_Id;\n-      Call_Ent : Entity_Id;\n-      Concval  : Node_Id;\n-      D_Conv   : Node_Id;\n-      D_Disc   : Node_Id;\n-      D_Type   : Entity_Id;\n-      Decls    : List_Id;\n-      Dummy    : Node_Id;\n-      Ename    : Node_Id;\n-      Formals  : List_Id;\n-      Index    : Node_Id;\n-      N_Stats  : List_Id;\n-      Obj      : Entity_Id;\n-      Param    : Node_Id;\n-      Params   : List_Id;\n-      Stmt     : Node_Id;\n-      Stmts    : List_Id;\n-      Unpack   : List_Id;\n+      Actuals        : List_Id;\n+      Blk_Typ        : Entity_Id;\n+      Call           : Node_Id;\n+      Call_Ent       : Entity_Id;\n+      Conc_Typ_Stmts : List_Id;\n+      Concval        : Node_Id;\n+      D_Conv         : Node_Id;\n+      D_Disc         : Node_Id;\n+      D_Type         : Entity_Id;\n+      Decls          : List_Id;\n+      Dummy          : Node_Id;\n+      Ename          : Node_Id;\n+      Formals        : List_Id;\n+      Index          : Node_Id;\n+      Lim_Typ_Stmts  : List_Id;\n+      N_Stats        : List_Id;\n+      Obj            : Entity_Id;\n+      Param          : Node_Id;\n+      Params         : List_Id;\n+      Stmt           : Node_Id;\n+      Stmts          : List_Id;\n+      Unpack         : List_Id;\n \n       B : Entity_Id;  --  Call status flag\n       C : Entity_Id;  --  Call kind\n       D : Entity_Id;  --  Delay\n+      K : Entity_Id;  --  Tagged kind\n       M : Entity_Id;  --  Delay mode\n       P : Entity_Id;  --  Parameter block\n       S : Entity_Id;  --  Primitive operation slot\n@@ -9651,7 +9560,7 @@ package body Exp_Ch9 is\n          --  Generate:\n          --    B : Boolean := False;\n \n-         B := SEU.Build_B (Loc, Decls);\n+         B := Build_B (Loc, Decls);\n \n       else\n          --  Generate:\n@@ -9675,7 +9584,7 @@ package body Exp_Ch9 is\n          --  Generate:\n          --    C : Ada.Tags.Prim_Op_Kind;\n \n-         C := SEU.Build_C (Loc, Decls);\n+         C := Build_C (Loc, Decls);\n       end if;\n \n       --  Duration and mode processing\n@@ -9747,20 +9656,30 @@ package body Exp_Ch9 is\n       if Ada_Version >= Ada_05\n         and then Nkind (E_Call) = N_Procedure_Call_Statement\n       then\n+         --  Tagged kind processing, generate:\n+         --    K : Ada.Tags.Tagged_Kind :=\n+         --          Ada.Tags.Get_Tagged_Kind (Ada.Tags.Tag <object>));\n+\n+         K := Build_K (Loc, Decls, Obj);\n+\n          Blk_Typ := Build_Parameter_Block (Loc, Actuals, Formals, Decls);\n          P       := Parameter_Block_Pack  (Loc, Blk_Typ, Actuals, Formals,\n                       Decls, Stmts);\n \n          --  Dispatch table slot processing, generate:\n-         --    S : constant Integer :=\n-         --          Ada.Tags.Get_Offset_Index (\n-         --            Unchecked_Convert_To (Ada.Tags.Interface_Tag, Obj),\n-         --            DT_Position (<dispatching-procedure>));\n+         --    S : Integer;\n \n-         S := SEU.Build_S (Loc, Decls, Obj, Call_Ent);\n+         S := Build_S (Loc, Decls);\n \n          --  Generate:\n-         --    _dispatching_timed_select (Obj, S, P'address, D, M, C, B);\n+         --    S := Ada.Tags.Get_Offset_Index (\n+         --           Ada.Tags.Tag (<object>), DT_Position (Call_Ent));\n+\n+         Conc_Typ_Stmts := New_List (\n+           Build_S_Assignment (Loc, S, Obj, Call_Ent));\n+\n+         --  Generate:\n+         --    _Disp_Timed_Select (<object>, S, P'address, D, M, C, B);\n \n          --  where Obj is the controlling formal parameter, S is the dispatch\n          --  table slot number of the dispatching operation, P is the wrapped\n@@ -9779,7 +9698,7 @@ package body Exp_Ch9 is\n          Append_To (Params, New_Reference_To (C, Loc));\n          Append_To (Params, New_Reference_To (B, Loc));\n \n-         Append_To (Stmts,\n+         Append_To (Conc_Typ_Stmts,\n            Make_Procedure_Call_Statement (Loc,\n              Name =>\n                New_Reference_To (\n@@ -9804,7 +9723,7 @@ package body Exp_Ch9 is\n          --  explicit assignments to their corresponding actuals.\n \n          if Present (Unpack) then\n-            Append_To (Stmts,\n+            Append_To (Conc_Typ_Stmts,\n               Make_If_Statement (Loc,\n \n                 Condition =>\n@@ -9823,7 +9742,8 @@ package body Exp_Ch9 is\n                         Right_Opnd =>\n                           New_Reference_To (RTE (RE_POK_Task_Entry), Loc))),\n \n-                Then_Statements => Unpack));\n+                Then_Statements =>\n+                  Unpack));\n          end if;\n \n          --  Generate:\n@@ -9833,11 +9753,11 @@ package body Exp_Ch9 is\n          --         or else C = POK_Protected_Procedure\n          --         or else C = POK_Task_Procedure\n          --       then\n-         --          <dispatching-procedure-call>\n+         --          <dispatching-call>\n          --       end if;\n-         --       <normal-statements>\n+         --       <triggering-statements>\n          --    else\n-         --       <delay-statements>\n+         --       <timed-statements>\n          --    end if;\n \n          N_Stats := New_Copy_List_Tree (E_Stats);\n@@ -9873,11 +9793,41 @@ package body Exp_Ch9 is\n              Then_Statements =>\n                New_List (E_Call)));\n \n-         Append_To (Stmts,\n+         Append_To (Conc_Typ_Stmts,\n            Make_If_Statement (Loc,\n              Condition       => New_Reference_To (B, Loc),\n              Then_Statements => N_Stats,\n              Else_Statements => D_Stats));\n+\n+         --  Generate:\n+         --    <dispatching-call>;\n+         --    <triggering-statements>\n+\n+         Lim_Typ_Stmts := New_Copy_List_Tree (E_Stats);\n+         Prepend_To (Lim_Typ_Stmts, New_Copy_Tree (E_Call));\n+\n+         --  Generate:\n+         --    if K = Ada.Tags.TK_Limited_Tagged then\n+         --       Lim_Typ_Stmts\n+         --    else\n+         --       Conc_Typ_Stmts\n+         --    end if;\n+\n+         Append_To (Stmts,\n+           Make_If_Statement (Loc,\n+             Condition =>\n+               Make_Op_Eq (Loc,\n+                 Left_Opnd =>\n+                   New_Reference_To (K, Loc),\n+                 Right_Opnd =>\n+                   New_Reference_To (RTE (RE_TK_Limited_Tagged), Loc)),\n+\n+             Then_Statements =>\n+               Lim_Typ_Stmts,\n+\n+             Else_Statements =>\n+               Conc_Typ_Stmts));\n+\n       else\n          --  Skip assignments to temporaries created for in-out parameters.\n          --  This makes unwarranted assumptions about the shape of the expanded\n@@ -10579,6 +10529,7 @@ package body Exp_Ch9 is\n             if Abort_Allowed\n               or else Restriction_Active (No_Entry_Queue) = False\n               or else Number_Entries (Ptyp) > 1\n+              or else (Has_Attach_Handler (Ptyp) and then not Restricted)\n             then\n                --  Find index mapping function (clumsy but ok for now)\n \n@@ -10601,6 +10552,8 @@ package body Exp_Ch9 is\n          if Abort_Allowed\n            or else Restriction_Active (No_Entry_Queue) = False\n            or else Number_Entries (Ptyp) > 1\n+           or else (Has_Attach_Handler (Ptyp)\n+                     and then not Restricted)\n          then\n             Append_To (L,\n               Make_Procedure_Call_Statement (Loc,"}, {"sha": "e3daf07bfc47687c9e2be9bc86d3ee7d134fbc85", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 447, "deletions": 235, "changes": 682, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d744221db2ca7b17e1734998d8fb9a7b67608ca/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d744221db2ca7b17e1734998d8fb9a7b67608ca/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=4d744221db2ca7b17e1734998d8fb9a7b67608ca", "patch": "@@ -309,11 +309,11 @@ package body Exp_Disp is\n        Get_Access_Level        => RE_Get_Access_Level,\n        Get_Entry_Index         => RE_Get_Entry_Index,\n        Get_External_Tag        => RE_Get_External_Tag,\n-       Get_Offset_Index        => RE_Get_Offset_Index,\n        Get_Prim_Op_Address     => RE_Get_Prim_Op_Address,\n        Get_Prim_Op_Kind        => RE_Get_Prim_Op_Kind,\n        Get_RC_Offset           => RE_Get_RC_Offset,\n        Get_Remotely_Callable   => RE_Get_Remotely_Callable,\n+       Get_Tagged_Kind         => RE_Get_Tagged_Kind,\n        Inherit_DT              => RE_Inherit_DT,\n        Inherit_TSD             => RE_Inherit_TSD,\n        Register_Interface_Tag  => RE_Register_Interface_Tag,\n@@ -322,6 +322,7 @@ package body Exp_Disp is\n        Set_Entry_Index         => RE_Set_Entry_Index,\n        Set_Expanded_Name       => RE_Set_Expanded_Name,\n        Set_External_Tag        => RE_Set_External_Tag,\n+       Set_Interface_Table     => RE_Set_Interface_Table,\n        Set_Offset_Index        => RE_Set_Offset_Index,\n        Set_OSD                 => RE_Set_OSD,\n        Set_Prim_Op_Address     => RE_Set_Prim_Op_Address,\n@@ -330,6 +331,7 @@ package body Exp_Disp is\n        Set_Remotely_Callable   => RE_Set_Remotely_Callable,\n        Set_SSD                 => RE_Set_SSD,\n        Set_TSD                 => RE_Set_TSD,\n+       Set_Tagged_Kind         => RE_Set_Tagged_Kind,\n        TSD_Entry_Size          => RE_TSD_Entry_Size,\n        TSD_Prologue_Size       => RE_TSD_Prologue_Size);\n \n@@ -341,11 +343,11 @@ package body Exp_Disp is\n        Get_Access_Level        => False,\n        Get_Entry_Index         => False,\n        Get_External_Tag        => False,\n-       Get_Offset_Index        => False,\n        Get_Prim_Op_Address     => False,\n        Get_Prim_Op_Kind        => False,\n-       Get_Remotely_Callable   => False,\n        Get_RC_Offset           => False,\n+       Get_Remotely_Callable   => False,\n+       Get_Tagged_Kind         => False,\n        Inherit_DT              => True,\n        Inherit_TSD             => True,\n        Register_Interface_Tag  => True,\n@@ -354,6 +356,7 @@ package body Exp_Disp is\n        Set_Entry_Index         => True,\n        Set_Expanded_Name       => True,\n        Set_External_Tag        => True,\n+       Set_Interface_Table     => True,\n        Set_Offset_Index        => True,\n        Set_OSD                 => True,\n        Set_Prim_Op_Address     => True,\n@@ -362,6 +365,7 @@ package body Exp_Disp is\n        Set_Remotely_Callable   => True,\n        Set_SSD                 => True,\n        Set_TSD                 => True,\n+       Set_Tagged_Kind         => True,\n        TSD_Entry_Size          => False,\n        TSD_Prologue_Size       => False);\n \n@@ -373,19 +377,20 @@ package body Exp_Disp is\n        Get_Access_Level        => 1,\n        Get_Entry_Index         => 2,\n        Get_External_Tag        => 1,\n-       Get_Offset_Index        => 2,\n        Get_Prim_Op_Address     => 2,\n        Get_Prim_Op_Kind        => 2,\n        Get_RC_Offset           => 1,\n        Get_Remotely_Callable   => 1,\n+       Get_Tagged_Kind         => 1,\n        Inherit_DT              => 3,\n        Inherit_TSD             => 2,\n-       Register_Interface_Tag  => 2,\n+       Register_Interface_Tag  => 3,\n        Register_Tag            => 1,\n        Set_Access_Level        => 2,\n        Set_Entry_Index         => 3,\n        Set_Expanded_Name       => 2,\n        Set_External_Tag        => 2,\n+       Set_Interface_Table     => 2,\n        Set_Offset_Index        => 3,\n        Set_OSD                 => 2,\n        Set_Prim_Op_Address     => 3,\n@@ -394,6 +399,7 @@ package body Exp_Disp is\n        Set_Remotely_Callable   => 2,\n        Set_SSD                 => 2,\n        Set_TSD                 => 2,\n+       Set_Tagged_Kind         => 2,\n        TSD_Entry_Size          => 0,\n        TSD_Prologue_Size       => 0);\n \n@@ -414,9 +420,13 @@ package body Exp_Disp is\n      (Prim : Entity_Id;\n       Typ  : Entity_Id) return Node_Id;\n    --  Ada 2005 (AI-345): Determine the primitive operation kind of Prim\n-   --  according to its type Typ. Return a reference to an RTE Prim_Op_Kind\n+   --  according to its type Typ. Return a reference to an RE_Prim_Op_Kind\n    --  enumeration value.\n \n+   function Tagged_Kind (T : Entity_Id) return Node_Id;\n+   --  Ada 2005 (AI-345): Determine the tagged kind of T and return a reference\n+   --  to an RE_Tagged_Kind enumeration value.\n+\n    ----------------------------\n    -- Collect_All_Interfaces --\n    ----------------------------\n@@ -426,7 +436,7 @@ package body Exp_Disp is\n       procedure Add_Interface (Iface : Entity_Id);\n       --  Add the interface it if is not already in the list\n \n-      procedure Collect (Typ   : Entity_Id);\n+      procedure Collect (Typ : Entity_Id);\n       --  Subsidiary subprogram used to traverse the whole list\n       --  of directly and indirectly implemented interfaces\n \n@@ -453,34 +463,34 @@ package body Exp_Disp is\n       -------------\n \n       procedure Collect (Typ : Entity_Id) is\n-         Nod      : constant Node_Id := Type_Definition (Parent (Typ));\n+         Ancestor : Entity_Id;\n          Id       : Node_Id;\n          Iface    : Entity_Id;\n-         Ancestor : Entity_Id;\n+         Nod      : Node_Id;\n \n       begin\n+         if Ekind (Typ) = E_Record_Type_With_Private then\n+            Nod := Type_Definition (Parent (Full_View (Typ)));\n+         else\n+            Nod := Type_Definition (Parent (Typ));\n+         end if;\n+\n          pragma Assert (False\n             or else Nkind (Nod) = N_Derived_Type_Definition\n             or else Nkind (Nod) = N_Record_Definition);\n \n-         if Nkind (Nod) = N_Record_Definition then\n-            return;\n-         end if;\n-\n          --  Include the ancestor if we are generating the whole list\n          --  of interfaces. This is used to know the size of the table\n          --  that stores the tag of all the ancestor interfaces.\n \n          Ancestor := Etype (Typ);\n \n-         if Is_Interface (Ancestor) then\n-            Add_Interface (Ancestor);\n+         if Ancestor /= Typ then\n+            Collect (Ancestor);\n          end if;\n \n-         if Ancestor /= Typ\n-           and then Ekind (Ancestor) /= E_Record_Type_With_Private\n-         then\n-            Collect (Ancestor);\n+         if Is_Interface (Ancestor) then\n+            Add_Interface (Ancestor);\n          end if;\n \n          --  Traverse the graph of ancestor interfaces\n@@ -1008,7 +1018,10 @@ package body Exp_Disp is\n    -- Expand_Interface_Conversion --\n    ---------------------------------\n \n-   procedure Expand_Interface_Conversion (N : Node_Id) is\n+   procedure Expand_Interface_Conversion\n+     (N         : Node_Id;\n+      Is_Static : Boolean := True)\n+   is\n       Loc         : constant Source_Ptr := Sloc (N);\n       Operand     : constant Node_Id    := Expression (N);\n       Operand_Typ : Entity_Id           := Etype (Operand);\n@@ -1046,6 +1059,40 @@ package body Exp_Disp is\n       pragma Assert (not Is_Class_Wide_Type (Iface_Typ)\n         and then Is_Interface (Iface_Typ));\n \n+      if not Is_Static then\n+         Rewrite (N,\n+           Make_Function_Call (Loc,\n+             Name => New_Reference_To (RTE (RE_Displace), Loc),\n+             Parameter_Associations => New_List (\n+               Make_Attribute_Reference (Loc,\n+                 Prefix => Relocate_Node (Expression (N)),\n+                 Attribute_Name => Name_Address),\n+               New_Occurrence_Of\n+                 (Node (First_Elmt (Access_Disp_Table (Iface_Typ))),\n+                  Loc))));\n+\n+         Analyze (N);\n+\n+         --  Change the type of the data returned by IW_Convert to\n+         --  indicate that this is a dispatching call.\n+\n+         declare\n+            New_Itype : Entity_Id;\n+\n+         begin\n+            New_Itype := Create_Itype (E_Anonymous_Access_Type, N);\n+            Set_Etype       (New_Itype, New_Itype);\n+            Init_Size_Align (New_Itype);\n+            Set_Directly_Designated_Type (New_Itype,\n+              Class_Wide_Type (Iface_Typ));\n+\n+            Rewrite (N, Unchecked_Convert_To (New_Itype,\n+                          Relocate_Node (N)));\n+         end;\n+\n+         return;\n+      end if;\n+\n       Iface_Tag := Find_Interface_Tag (Operand_Typ, Iface_Typ);\n       pragma Assert (Iface_Tag /= Empty);\n \n@@ -1359,8 +1406,7 @@ package body Exp_Disp is\n    function Expand_Interface_Thunk\n      (N           : Node_Id;\n       Thunk_Alias : Entity_Id;\n-      Thunk_Id    : Entity_Id;\n-      Thunk_Tag   : Entity_Id) return Node_Id\n+      Thunk_Id    : Entity_Id) return Node_Id\n    is\n       Loc         : constant Source_Ptr := Sloc (N);\n       Actuals     : constant List_Id    := New_List;\n@@ -1417,7 +1463,7 @@ package body Exp_Disp is\n \n          --     type T is access all <<type of the first formal>>\n          --     S1 := Storage_Offset!(First_formal)\n-         --           - Storage_Offset!(First_Formal.Thunk_Tag'Position)\n+         --           - Offset_To_Top (First_Formal.Tag)\n \n          --  ... and the first actual of the call is generated as T!(S1)\n \n@@ -1452,17 +1498,15 @@ package body Exp_Disp is\n                       New_Reference_To\n                         (Defining_Identifier (First (Formals)), Loc)),\n                   Right_Opnd =>\n-                    Unchecked_Convert_To\n-                      (RTE (RE_Storage_Offset),\n-                       Make_Attribute_Reference (Loc,\n-                         Prefix =>\n-                           Make_Selected_Component (Loc,\n-                             Prefix =>\n-                               New_Reference_To\n-                                 (Defining_Identifier (First (Formals)), Loc),\n-                             Selector_Name =>\n-                               New_Occurrence_Of (Thunk_Tag, Loc)),\n-                         Attribute_Name => Name_Position))));\n+                    Make_Function_Call (Loc,\n+                      Name => New_Reference_To (RTE (RE_Offset_To_Top), Loc),\n+                      Parameter_Associations => New_List (\n+                        Make_Selected_Component (Loc,\n+                          Prefix => New_Reference_To\n+                                      (Defining_Identifier (First (Formals)),\n+                                       Loc),\n+                          Selector_Name => Make_Identifier (Loc,\n+                                             Name_uTag))))));\n \n          Append_To (Decl, Decl_2);\n          Append_To (Decl, Decl_1);\n@@ -1474,14 +1518,11 @@ package body Exp_Disp is\n              (Defining_Identifier (Decl_2),\n               New_Reference_To (Defining_Identifier (Decl_1), Loc)));\n \n-         --  Side note: The reverse order of declarations is just to ensure\n-         --  that the call to RE_Print is correct.\n-\n       else\n          --  Generate:\n-         --\n+\n          --     S1 := Storage_Offset!(First_formal'Address)\n-         --           - Storage_Offset!(First_Formal.Thunk_Tag'Position)\n+         --           - Offset_To_Top (First_Formal.Tag)\n          --     S2 := Tag_Ptr!(S3)\n \n          Decl_1 :=\n@@ -1502,17 +1543,15 @@ package body Exp_Disp is\n                             (Defining_Identifier (First (Formals)), Loc),\n                         Attribute_Name => Name_Address)),\n                  Right_Opnd =>\n-                   Unchecked_Convert_To\n-                     (RTE (RE_Storage_Offset),\n-                      Make_Attribute_Reference (Loc,\n-                        Prefix =>\n-                          Make_Selected_Component (Loc,\n-                            Prefix =>\n-                              New_Reference_To\n-                                (Defining_Identifier (First (Formals)), Loc),\n-                                 Selector_Name =>\n-                                   New_Occurrence_Of (Thunk_Tag, Loc)),\n-                        Attribute_Name => Name_Position))));\n+                    Make_Function_Call (Loc,\n+                      Name => New_Reference_To (RTE (RE_Offset_To_Top), Loc),\n+                      Parameter_Associations => New_List (\n+                        Make_Selected_Component (Loc,\n+                          Prefix => New_Reference_To\n+                                      (Defining_Identifier (First (Formals)),\n+                                       Loc),\n+                          Selector_Name => Make_Identifier (Loc,\n+                                             Name_uTag))))));\n \n          Decl_2 :=\n            Make_Object_Declaration (Loc,\n@@ -1726,6 +1765,8 @@ package body Exp_Disp is\n       Stmts    : constant List_Id    := New_List;\n \n    begin\n+      --  Null body is generated for interface types\n+\n       if Is_Interface (Typ) then\n          return\n            Make_Subprogram_Body (Loc,\n@@ -1738,16 +1779,13 @@ package body Exp_Disp is\n                  New_List (Make_Null_Statement (Loc))));\n       end if;\n \n-      if Is_Concurrent_Record_Type (Typ) then\n-         Conc_Typ := Corresponding_Concurrent_Type (Typ);\n-      end if;\n-\n       DT_Ptr := Node (First_Elmt (Access_Disp_Table (Typ)));\n \n-      if Present (Conc_Typ) then\n+      if Is_Concurrent_Record_Type (Typ) then\n+         Conc_Typ := Corresponding_Concurrent_Type (Typ);\n \n          --  Generate:\n-         --    I : Integer := get_entry_index (tag! (<type>VP), S);\n+         --    I : Integer := Get_Entry_Index (tag! (<type>VP), S);\n \n          --  where I will be used to capture the entry index of the primitive\n          --  wrapper at position S.\n@@ -1847,12 +1885,6 @@ package body Exp_Disp is\n                       RTE (RE_Asynchronous_Call), Loc),\n                     Make_Identifier (Loc, Name_uF))));    --  status flag\n          end if;\n-\n-      --  Implementation for limited tagged types\n-\n-      else\n-         Append_To (Stmts,\n-           Make_Raise_Program_Error (Loc, Reason => PE_Explicit_Raise));\n       end if;\n \n       return\n@@ -1914,6 +1946,8 @@ package body Exp_Disp is\n       Stmts    : constant List_Id    := New_List;\n \n    begin\n+      --  Null body is generated for interface types\n+\n       if Is_Interface (Typ) then\n          return\n            Make_Subprogram_Body (Loc,\n@@ -1926,13 +1960,10 @@ package body Exp_Disp is\n                  New_List (Make_Null_Statement (Loc))));\n       end if;\n \n-      if Is_Concurrent_Record_Type (Typ) then\n-         Conc_Typ := Corresponding_Concurrent_Type (Typ);\n-      end if;\n-\n       DT_Ptr := Node (First_Elmt (Access_Disp_Table (Typ)));\n \n-      if Present (Conc_Typ) then\n+      if Is_Concurrent_Record_Type (Typ) then\n+         Conc_Typ := Corresponding_Concurrent_Type (Typ);\n \n          --  Generate:\n          --    I : Integer;\n@@ -1946,22 +1977,20 @@ package body Exp_Disp is\n                Make_Defining_Identifier (Loc, Name_uI),\n              Object_Definition =>\n                New_Reference_To (Standard_Integer, Loc)));\n-      end if;\n \n-      --  Generate:\n-      --    C := get_prim_op_kind (tag! (<type>VP), S);\n-\n-      --    if C = POK_Procedure\n-      --      or else C = POK_Protected_Procedure\n-      --      or else C = POK_Task_Procedure;\n-      --    then\n-      --       F := True;\n-      --       return;\n-      --    end if;\n+         --  Generate:\n+         --    C := Get_Prim_Op_Kind (tag! (<type>VP), S);\n \n-      SEU.Build_Common_Dispatching_Select_Statements (Loc, Typ, DT_Ptr, Stmts);\n+         --    if C = POK_Procedure\n+         --      or else C = POK_Protected_Procedure\n+         --      or else C = POK_Task_Procedure;\n+         --    then\n+         --       F := True;\n+         --       return;\n+         --    end if;\n \n-      if Present (Conc_Typ) then\n+         SEU.Build_Common_Dispatching_Select_Statements\n+          (Loc, Typ, DT_Ptr, Stmts);\n \n          --  Generate:\n          --    Bnn : Communication_Block;\n@@ -1979,7 +2008,7 @@ package body Exp_Disp is\n                New_Reference_To (RTE (RE_Communication_Block), Loc)));\n \n          --  Generate:\n-         --    I := get_entry_index (tag! (<type>VP), S);\n+         --    I := Get_Entry_Index (tag! (<type>VP), S);\n \n          --  I is the entry index and S is the dispatch table slot\n \n@@ -2097,12 +2126,6 @@ package body Exp_Disp is\n                       RTE (RE_Conditional_Call), Loc),\n                     Make_Identifier (Loc, Name_uF))));    --  status flag\n          end if;\n-\n-      --  Implementation for limited tagged types\n-\n-      else\n-         Append_To (Stmts,\n-           Make_Raise_Program_Error (Loc, Reason => PE_Explicit_Raise));\n       end if;\n \n       return\n@@ -2318,6 +2341,8 @@ package body Exp_Disp is\n       Stmts    : constant List_Id    := New_List;\n \n    begin\n+      --  Null body is generated for interface types\n+\n       if Is_Interface (Typ) then\n          return\n            Make_Subprogram_Body (Loc,\n@@ -2330,13 +2355,10 @@ package body Exp_Disp is\n                  New_List (Make_Null_Statement (Loc))));\n       end if;\n \n-      if Is_Concurrent_Record_Type (Typ) then\n-         Conc_Typ := Corresponding_Concurrent_Type (Typ);\n-      end if;\n-\n       DT_Ptr := Node (First_Elmt (Access_Disp_Table (Typ)));\n \n-      if Present (Conc_Typ) then\n+      if Is_Concurrent_Record_Type (Typ) then\n+         Conc_Typ := Corresponding_Concurrent_Type (Typ);\n \n          --  Generate:\n          --    I : Integer;\n@@ -2350,25 +2372,23 @@ package body Exp_Disp is\n                Make_Defining_Identifier (Loc, Name_uI),\n              Object_Definition =>\n                New_Reference_To (Standard_Integer, Loc)));\n-      end if;\n-\n-      --  Generate:\n-      --    C := get_prim_op_kind (tag! (<type>VP), S);\n \n-      --    if C = POK_Procedure\n-      --      or else C = POK_Protected_Procedure\n-      --      or else C = POK_Task_Procedure;\n-      --    then\n-      --       F := True;\n-      --       return;\n-      --    end if;\n+         --  Generate:\n+         --    C := Get_Prim_Op_Kind (tag! (<type>VP), S);\n \n-      SEU.Build_Common_Dispatching_Select_Statements (Loc, Typ, DT_Ptr, Stmts);\n+         --    if C = POK_Procedure\n+         --      or else C = POK_Protected_Procedure\n+         --      or else C = POK_Task_Procedure;\n+         --    then\n+         --       F := True;\n+         --       return;\n+         --    end if;\n \n-      if Present (Conc_Typ) then\n+         SEU.Build_Common_Dispatching_Select_Statements\n+          (Loc, Typ, DT_Ptr, Stmts);\n \n          --  Generate:\n-         --    I := get_entry_index (tag! (<type>VP), S);\n+         --    I := Get_Entry_Index (tag! (<type>VP), S);\n \n          --  I is the entry index and S is the dispatch table slot\n \n@@ -2469,12 +2489,6 @@ package body Exp_Disp is\n                     Make_Identifier (Loc, Name_uM),       --  delay mode\n                     Make_Identifier (Loc, Name_uF))));    --  status flag\n          end if;\n-\n-      --  Implementation for limited tagged types\n-\n-      else\n-         Append_To (Stmts,\n-           Make_Raise_Program_Error (Loc, Reason => PE_Explicit_Raise));\n       end if;\n \n       return\n@@ -2554,52 +2568,74 @@ package body Exp_Disp is\n       Name_TSD    : constant Name_Id := New_External_Name (Tname, 'B');\n       Name_Exname : constant Name_Id := New_External_Name (Tname, 'E');\n       Name_No_Reg : constant Name_Id := New_External_Name (Tname, 'F');\n+      Name_ITable : Name_Id;\n \n       DT     : constant Node_Id := Make_Defining_Identifier (Loc, Name_DT);\n       DT_Ptr : constant Node_Id := Make_Defining_Identifier (Loc, Name_DT_Ptr);\n       SSD    : constant Node_Id := Make_Defining_Identifier (Loc, Name_SSD);\n       TSD    : constant Node_Id := Make_Defining_Identifier (Loc, Name_TSD);\n       Exname : constant Node_Id := Make_Defining_Identifier (Loc, Name_Exname);\n       No_Reg : constant Node_Id := Make_Defining_Identifier (Loc, Name_No_Reg);\n-\n-      Generalized_Tag : constant Entity_Id := RTE (RE_Tag);\n-      I_Depth         : Int;\n-      Size_Expr_Node  : Node_Id;\n-      Old_Tag1        : Node_Id;\n-      Old_Tag2        : Node_Id;\n-      Num_Ifaces      : Int;\n-      Nb_Prim         : Int;\n-      TSD_Num_Entries : Int;\n-      Typ_Copy        : constant Entity_Id := New_Copy (Typ);\n-      AI              : Elmt_Id;\n+      ITable : Node_Id;\n+\n+      Generalized_Tag   : constant Entity_Id := RTE (RE_Tag);\n+      AI                : Elmt_Id;\n+      I_Depth           : Int;\n+      Nb_Prim           : Int;\n+      Num_Ifaces        : Int;\n+      Old_Tag1          : Node_Id;\n+      Old_Tag2          : Node_Id;\n+      Parent_Num_Ifaces : Int;\n+      Size_Expr_Node    : Node_Id;\n+      TSD_Num_Entries   : Int;\n+\n+      Ancestor_Copy     : Entity_Id;\n+      Typ_Copy          : Entity_Id;\n \n    begin\n       if not RTE_Available (RE_Tag) then\n          Error_Msg_CRT (\"tagged types\", Typ);\n          return New_List;\n       end if;\n \n-      --  Collect full list of directly and indirectly implemented interfaces\n-\n-      Set_Parent              (Typ_Copy, Parent (Typ));\n-      Set_Abstract_Interfaces (Typ_Copy, New_Elmt_List);\n-      Collect_All_Interfaces  (Typ_Copy);\n-\n       --  Calculate the size of the DT and the TSD\n \n       if Is_Interface (Typ) then\n          --  Abstract interfaces need neither the DT nor the ancestors table.\n          --  We reserve a single entry for its DT because at run-time the\n-         --  pointer to this dummy DT is the tag of this abstract interface\n-         --  type.\n+         --  pointer to this dummy DT will be used as the tag of this abstract\n+         --  interface type.\n \n          Nb_Prim         := 1;\n          TSD_Num_Entries := 0;\n+         Num_Ifaces      := 0;\n \n       else\n-         --  Calculate the number of entries for the table of interfaces\n+         --  Count the number of interfaces implemented by the ancestors\n+\n+         Parent_Num_Ifaces := 0;\n+         Num_Ifaces        := 0;\n+\n+         if Typ /= Etype (Typ) then\n+            Ancestor_Copy := New_Copy (Etype (Typ));\n+            Set_Parent (Ancestor_Copy, Parent (Etype (Typ)));\n+            Set_Abstract_Interfaces (Ancestor_Copy, New_Elmt_List);\n+            Collect_All_Interfaces (Ancestor_Copy);\n+\n+            AI := First_Elmt (Abstract_Interfaces (Ancestor_Copy));\n+            while Present (AI) loop\n+               Parent_Num_Ifaces := Parent_Num_Ifaces + 1;\n+               Next_Elmt (AI);\n+            end loop;\n+         end if;\n+\n+         --  Count the number of additional interfaces implemented by Typ\n+\n+         Typ_Copy := New_Copy (Typ);\n+         Set_Parent (Typ_Copy, Parent (Typ));\n+         Set_Abstract_Interfaces (Typ_Copy, New_Elmt_List);\n+         Collect_All_Interfaces (Typ_Copy);\n \n-         Num_Ifaces := 0;\n          AI := First_Elmt (Abstract_Interfaces (Typ_Copy));\n          while Present (AI) loop\n             Num_Ifaces := Num_Ifaces + 1;\n@@ -2630,7 +2666,7 @@ package body Exp_Disp is\n             end loop;\n          end;\n \n-         TSD_Num_Entries := I_Depth + Num_Ifaces + 1;\n+         TSD_Num_Entries := I_Depth + 1;\n          Nb_Prim := UI_To_Int (DT_Entry_Count (First_Tag_Component (Typ)));\n \n          --  If the number of primitives of Typ is less that the number of\n@@ -2650,6 +2686,16 @@ package body Exp_Disp is\n       Set_Ekind (DT_Ptr, E_Variable);\n       Set_Is_Statically_Allocated (DT_Ptr);\n \n+      if not Is_Interface (Typ)\n+        and then Num_Ifaces > 0\n+      then\n+         Name_ITable := New_External_Name (Tname, 'I');\n+         ITable      := Make_Defining_Identifier (Loc, Name_ITable);\n+\n+         Set_Ekind (ITable, E_Variable);\n+         Set_Is_Statically_Allocated (ITable);\n+      end if;\n+\n       Set_Ekind (SSD, E_Variable);\n       Set_Is_Statically_Allocated (SSD);\n \n@@ -2842,6 +2888,47 @@ package body Exp_Disp is\n                 Prefix          => New_Reference_To (TSD, Loc),\n                 Attribute_Name  => Name_Address))));\n \n+      --  Set the pointer to the Interfaces_Table (if any). Otherwise the\n+      --  corresponding access component is set to null.\n+\n+      if Is_Interface (Typ) then\n+         null;\n+\n+      elsif Num_Ifaces = 0 then\n+         Append_To (Elab_Code,\n+           Make_DT_Access_Action (Typ,\n+             Action => Set_Interface_Table,\n+             Args   => New_List (\n+               New_Reference_To (DT_Ptr, Loc),                    -- DTptr\n+               New_Reference_To (RTE (RE_Null_Address), Loc))));  -- null\n+\n+      --  Generate the Interface_Table object and set the access\n+      --  component if the TSD to it.\n+\n+      else\n+         Append_To (Result,\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => ITable,\n+             Aliased_Present     => True,\n+             Object_Definition   =>\n+               Make_Subtype_Indication (Loc,\n+                 Subtype_Mark => New_Reference_To\n+                   (RTE (RE_Interface_Data), Loc),\n+                 Constraint   => Make_Index_Or_Discriminant_Constraint (Loc,\n+                   Constraints => New_List (\n+                     Make_Integer_Literal (Loc,\n+                       Num_Ifaces))))));\n+\n+         Append_To (Elab_Code,\n+           Make_DT_Access_Action (Typ,\n+             Action => Set_Interface_Table,\n+             Args   => New_List (\n+               New_Reference_To (DT_Ptr, Loc),               -- DTptr\n+               Make_Attribute_Reference (Loc,                -- Value\n+                 Prefix         => New_Reference_To (ITable, Loc),\n+                 Attribute_Name => Name_Address))));\n+      end if;\n+\n       --  Generate:\n       --    Set_Num_Prim_Ops (T'Tag, Nb_Prim)\n \n@@ -2858,39 +2945,53 @@ package body Exp_Disp is\n         and then not Is_Interface  (Typ)\n         and then not Is_Abstract   (Typ)\n         and then not Is_Controlled (Typ)\n-        and then Implements_Interface (\n-          Typ  => Typ,\n-          Kind => Any_Limited_Interface,\n-          Check_Parent => True)\n-        and then (Nb_Prim - Default_Prim_Op_Count) > 0\n       then\n-         --  Generate the Select Specific Data table for tagged types that\n-         --  implement a synchronized interface. The size of the table is\n-         --  constrained by the number of non-predefined primitive operations.\n-\n-         Append_To (Result,\n-           Make_Object_Declaration (Loc,\n-             Defining_Identifier => SSD,\n-             Aliased_Present     => True,\n-             Object_Definition   =>\n-               Make_Subtype_Indication (Loc,\n-                 Subtype_Mark => New_Reference_To (\n-                   RTE (RE_Select_Specific_Data), Loc),\n-                 Constraint   => Make_Index_Or_Discriminant_Constraint (Loc,\n-                   Constraints => New_List (\n-                     Make_Integer_Literal (Loc,\n-                       Nb_Prim - Default_Prim_Op_Count))))));\n-\n-         --  Set the pointer to the Select Specific Data table in the TSD\n+         --  Generate:\n+         --    Set_Type_Kind (T'Tag, Type_Kind (Typ));\n \n          Append_To (Elab_Code,\n            Make_DT_Access_Action (Typ,\n-             Action => Set_SSD,\n+             Action => Set_Tagged_Kind,\n              Args   => New_List (\n                New_Reference_To (DT_Ptr, Loc),               -- DTptr\n-               Make_Attribute_Reference (Loc,                -- Value\n-                 Prefix         => New_Reference_To (SSD, Loc),\n-                 Attribute_Name => Name_Address))));\n+               Tagged_Kind (Typ))));                         -- Value\n+\n+         --  Generate the Select Specific Data table for synchronized\n+         --  types that implement a synchronized interface. The size\n+         --  of the table is constrained by the number of non-predefined\n+         --  primitive operations.\n+\n+         if Is_Concurrent_Record_Type (Typ)\n+           and then Implements_Interface (\n+                      Typ          => Typ,\n+                      Kind         => Any_Limited_Interface,\n+                      Check_Parent => True)\n+           and then (Nb_Prim - Default_Prim_Op_Count) > 0\n+         then\n+            Append_To (Result,\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier => SSD,\n+                Aliased_Present     => True,\n+                Object_Definition   =>\n+                  Make_Subtype_Indication (Loc,\n+                    Subtype_Mark => New_Reference_To (\n+                      RTE (RE_Select_Specific_Data), Loc),\n+                    Constraint   => Make_Index_Or_Discriminant_Constraint (Loc,\n+                      Constraints => New_List (\n+                        Make_Integer_Literal (Loc,\n+                          Nb_Prim - Default_Prim_Op_Count))))));\n+\n+            --  Set the pointer to the Select Specific Data table in the TSD\n+\n+            Append_To (Elab_Code,\n+              Make_DT_Access_Action (Typ,\n+                Action => Set_SSD,\n+                Args   => New_List (\n+                  New_Reference_To (DT_Ptr, Loc),            -- DTptr\n+                  Make_Attribute_Reference (Loc,             -- Value\n+                    Prefix         => New_Reference_To (SSD, Loc),\n+                    Attribute_Name => Name_Address))));\n+         end if;\n       end if;\n \n       --  Generate: Exname : constant String := full_qualified_name (typ);\n@@ -3158,12 +3259,13 @@ package body Exp_Disp is\n          end;\n \n          --  Generate:\n-         --    Set_Offset_To_Top (DT_Ptr, 0);\n+         --    Set_Offset_To_Top (0, DT_Ptr, 0);\n \n          Append_To (Elab_Code,\n            Make_Procedure_Call_Statement (Loc,\n              Name => New_Reference_To (RTE (RE_Set_Offset_To_Top), Loc),\n              Parameter_Associations => New_List (\n+               New_Reference_To (RTE (RE_Null_Address), Loc),\n                New_Reference_To (DT_Ptr, Loc),\n                Make_Integer_Literal (Loc, Uint_0))));\n       end if;\n@@ -3222,31 +3324,82 @@ package body Exp_Disp is\n           Then_Statements => Elab_Code));\n \n       --  Ada 2005 (AI-251): Register the tag of the interfaces into\n-      --  the table of implemented interfaces and ...\n+      --  the table of implemented interfaces.\n \n       if not Is_Interface (Typ)\n-        and then Present (Abstract_Interfaces (Typ_Copy))\n-        and then not Is_Empty_Elmt_List (Abstract_Interfaces (Typ_Copy))\n+        and then Num_Ifaces > 0\n       then\n-         AI := First_Elmt (Abstract_Interfaces (Typ_Copy));\n-         while Present (AI) loop\n+         declare\n+            Position : Int;\n \n-            --  Generate:\n-            --    Register_Interface (DT_Ptr, Interface'Tag);\n+         begin\n+            --  If the parent is an interface we must generate code to register\n+            --  all its interfaces; otherwise this code is not needed because\n+            --  Inherit_TSD has already inherited such interfaces.\n \n-            Append_To (Result,\n-              Make_DT_Access_Action (Typ,\n-                Action => Register_Interface_Tag,\n-                Args   => New_List (\n-                  Node1 => New_Reference_To (DT_Ptr, Loc),\n-                  Node2 => New_Reference_To\n-                             (Node\n-                              (First_Elmt\n-                               (Access_Disp_Table (Node (AI)))),\n-                              Loc))));\n+            if Is_Interface (Etype (Typ)) then\n+               Position := 1;\n \n-            Next_Elmt (AI);\n-         end loop;\n+               AI := First_Elmt (Abstract_Interfaces (Ancestor_Copy));\n+               while Present (AI) loop\n+                  --  Generate:\n+                  --    Register_Interface (DT_Ptr, Interface'Tag);\n+\n+                  Append_To (Result,\n+                    Make_DT_Access_Action (Typ,\n+                      Action => Register_Interface_Tag,\n+                      Args   => New_List (\n+                        Node1 => New_Reference_To (DT_Ptr, Loc),\n+                        Node2 => New_Reference_To\n+                                   (Node\n+                                    (First_Elmt\n+                                     (Access_Disp_Table (Node (AI)))),\n+                                    Loc),\n+                        Node3 => Make_Integer_Literal (Loc, Position))));\n+\n+                  Position := Position + 1;\n+                  Next_Elmt (AI);\n+               end loop;\n+            end if;\n+\n+            --  Register the interfaces that are not implemented by the\n+            --  ancestor\n+\n+            if Present (Abstract_Interfaces (Typ_Copy)) then\n+               AI := First_Elmt (Abstract_Interfaces (Typ_Copy));\n+\n+               --  Skip the interfaces implemented by the ancestor\n+\n+               for Count in 1 .. Parent_Num_Ifaces loop\n+                  Next_Elmt (AI);\n+               end loop;\n+\n+               --  Register the additional interfaces\n+\n+               Position := Parent_Num_Ifaces + 1;\n+               while Present (AI) loop\n+                  --  Generate:\n+                  --    Register_Interface (DT_Ptr, Interface'Tag);\n+\n+                  Append_To (Result,\n+                    Make_DT_Access_Action (Typ,\n+                      Action => Register_Interface_Tag,\n+                      Args   => New_List (\n+                        Node1 => New_Reference_To (DT_Ptr, Loc),\n+                        Node2 => New_Reference_To\n+                                   (Node\n+                                    (First_Elmt\n+                                     (Access_Disp_Table (Node (AI)))),\n+                                    Loc),\n+                        Node3 => Make_Integer_Literal (Loc, Position))));\n+\n+                  Position := Position + 1;\n+                  Next_Elmt (AI);\n+               end loop;\n+            end if;\n+\n+            pragma Assert (Position = Num_Ifaces + 1);\n+         end;\n       end if;\n \n       return Result;\n@@ -3471,7 +3624,7 @@ package body Exp_Disp is\n                 Make_Index_Or_Discriminant_Constraint (Loc,\n                   Constraints => New_List (\n                     Make_Integer_Literal (Loc,\n-                      Nb_Prim - Default_Prim_Op_Count))))));\n+                      Nb_Prim - Default_Prim_Op_Count + 1))))));\n \n       --  Generate:\n       --    Ada.Tags.Set_OSD (Iface_DT_Ptr, OSD);\n@@ -3480,63 +3633,12 @@ package body Exp_Disp is\n         Make_DT_Access_Action (Typ,\n           Action => Set_OSD,\n           Args   => New_List (\n-            New_Reference_To (Iface_DT_Ptr, Loc),\n+            Unchecked_Convert_To (RTE (RE_Tag),\n+              New_Reference_To (Iface_DT_Ptr, Loc)),\n             Make_Attribute_Reference (Loc,\n               Prefix         => New_Reference_To (OSD, Loc),\n               Attribute_Name => Name_Address))));\n \n-      --  Offset table creation\n-\n-      if not Is_Interface (Typ)\n-        and then not Is_Abstract   (Typ)\n-        and then not Is_Controlled (Typ)\n-        and then Implements_Interface\n-                  (Typ  => Typ,\n-                   Kind => Any_Limited_Interface,\n-                   Check_Parent => True)\n-        and then (Nb_Prim - Default_Prim_Op_Count) > 0\n-      then\n-         declare\n-            Prim       : Entity_Id;\n-            Prim_Alias : Entity_Id;\n-            Prim_Elmt  : Elmt_Id;\n-\n-         begin\n-            --  Step 2: Populate the OSD table\n-\n-            Prim_Alias := Empty;\n-            Prim_Elmt  := First_Elmt (Primitive_Operations (Typ));\n-            while Present (Prim_Elmt) loop\n-               Prim := Node (Prim_Elmt);\n-\n-               if Present (Abstract_Interface_Alias (Prim)) then\n-                  Prim_Alias := Abstract_Interface_Alias (Prim);\n-               end if;\n-\n-               if Present (Prim_Alias)\n-                 and then Present (First_Entity (Prim_Alias))\n-                 and then Etype (First_Entity (Prim_Alias)) = Iface\n-               then\n-                  --  Generate:\n-                  --    Ada.Tags.Set_Offset_Index (\n-                  --      Iface_DT_Ptr, secondary_DT_Pos, primary_DT_pos);\n-\n-                  Append_To (Result,\n-                    Make_DT_Access_Action (Iface,\n-                      Action => Set_Offset_Index,\n-                      Args   => New_List (\n-                        New_Reference_To (Iface_DT_Ptr, Loc),\n-                        Make_Integer_Literal (Loc, DT_Position (Prim_Alias)),\n-                        Make_Integer_Literal (Loc, DT_Position (Prim)))));\n-\n-                  Prim_Alias := Empty;\n-               end if;\n-\n-               Next_Elmt (Prim_Elmt);\n-            end loop;\n-         end;\n-      end if;\n-\n       --  Generate:\n       --    Set_Num_Prim_Ops (T'Tag, Nb_Prim)\n \n@@ -3548,6 +3650,73 @@ package body Exp_Disp is\n               New_Reference_To (Iface_DT_Ptr, Loc)),\n             Make_Integer_Literal (Loc, Nb_Prim))));\n \n+      if Ada_Version >= Ada_05\n+        and then not Is_Interface  (Typ)\n+        and then not Is_Abstract   (Typ)\n+        and then not Is_Controlled (Typ)\n+      then\n+         --  Generate:\n+         --    Set_Tagged_Kind (Iface'Tag, Tagged_Kind (Iface));\n+\n+         Append_To (Result,\n+           Make_DT_Access_Action (Typ,\n+             Action => Set_Tagged_Kind,\n+             Args   => New_List (\n+               Unchecked_Convert_To (RTE (RE_Tag),              -- DTptr\n+                 New_Reference_To (Iface_DT_Ptr, Loc)),\n+               Tagged_Kind (Typ))));                            -- Value\n+\n+         if Is_Concurrent_Record_Type (Typ)\n+           and then Implements_Interface (\n+                      Typ          => Typ,\n+                      Kind         => Any_Limited_Interface,\n+                      Check_Parent => True)\n+           and then (Nb_Prim - Default_Prim_Op_Count) > 0\n+         then\n+            declare\n+               Prim       : Entity_Id;\n+               Prim_Alias : Entity_Id;\n+               Prim_Elmt  : Elmt_Id;\n+\n+            begin\n+               --  Step 2: Populate the OSD table\n+\n+               Prim_Alias := Empty;\n+               Prim_Elmt  := First_Elmt (Primitive_Operations (Typ));\n+               while Present (Prim_Elmt) loop\n+                  Prim := Node (Prim_Elmt);\n+\n+                  if Present (Abstract_Interface_Alias (Prim)) then\n+                     Prim_Alias := Abstract_Interface_Alias (Prim);\n+                  end if;\n+\n+                  if Present (Prim_Alias)\n+                    and then Present (First_Entity (Prim_Alias))\n+                    and then Etype (First_Entity (Prim_Alias)) = Iface\n+                  then\n+                     --  Generate:\n+                     --    Ada.Tags.Set_Offset_Index (Tag (Iface_DT_Ptr),\n+                     --      Secondary_DT_Pos, Primary_DT_pos);\n+\n+                     Append_To (Result,\n+                       Make_DT_Access_Action (Iface,\n+                         Action => Set_Offset_Index,\n+                         Args   => New_List (\n+                           Unchecked_Convert_To (RTE (RE_Tag),\n+                             New_Reference_To (Iface_DT_Ptr, Loc)),\n+                           Make_Integer_Literal (Loc,\n+                             DT_Position (Prim_Alias)),\n+                           Make_Integer_Literal (Loc,\n+                             DT_Position (Prim)))));\n+\n+                     Prim_Alias := Empty;\n+                  end if;\n+\n+                  Next_Elmt (Prim_Elmt);\n+               end loop;\n+            end;\n+         end if;\n+      end if;\n    end Make_Secondary_DT;\n \n    -------------------------------------\n@@ -4413,6 +4582,49 @@ package body Exp_Disp is\n       end if;\n    end Set_Default_Constructor;\n \n+   -----------------\n+   -- Tagged_Kind --\n+   -----------------\n+\n+   function Tagged_Kind (T : Entity_Id) return Node_Id is\n+      Conc_Typ : Entity_Id;\n+      Loc      : constant Source_Ptr := Sloc (T);\n+\n+   begin\n+      pragma Assert (Is_Tagged_Type (T));\n+\n+      --  Abstract kinds\n+\n+      if Is_Abstract (T) then\n+         if Is_Limited_Record (T) then\n+            return New_Reference_To (RTE (RE_TK_Abstract_Limited_Tagged), Loc);\n+         else\n+            return New_Reference_To (RTE (RE_TK_Abstract_Tagged), Loc);\n+         end if;\n+\n+      --  Concurrent kinds\n+\n+      elsif Is_Concurrent_Record_Type (T) then\n+         Conc_Typ := Corresponding_Concurrent_Type (T);\n+\n+         if Ekind (Conc_Typ) = E_Protected_Type then\n+            return New_Reference_To (RTE (RE_TK_Protected), Loc);\n+         else\n+            pragma Assert (Ekind (Conc_Typ) = E_Task_Type);\n+            return New_Reference_To (RTE (RE_TK_Task), Loc);\n+         end if;\n+\n+      --  Regular tagged kinds\n+\n+      else\n+         if Is_Limited_Record (T) then\n+            return New_Reference_To (RTE (RE_TK_Limited_Tagged), Loc);\n+         else\n+            return New_Reference_To (RTE (RE_TK_Tagged), Loc);\n+         end if;\n+      end if;\n+   end Tagged_Kind;\n+\n    --------------\n    -- Write_DT --\n    --------------"}, {"sha": "a0f6b18672d01105f07ef1f4db0676f7e2626f61", "filename": "gcc/ada/exp_disp.ads", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d744221db2ca7b17e1734998d8fb9a7b67608ca/gcc%2Fada%2Fexp_disp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d744221db2ca7b17e1734998d8fb9a7b67608ca/gcc%2Fada%2Fexp_disp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.ads?ref=4d744221db2ca7b17e1734998d8fb9a7b67608ca", "patch": "@@ -184,11 +184,11 @@ package Exp_Disp is\n        Get_Access_Level,\n        Get_Entry_Index,\n        Get_External_Tag,\n-       Get_Offset_Index,\n        Get_Prim_Op_Address,\n        Get_Prim_Op_Kind,\n        Get_RC_Offset,\n        Get_Remotely_Callable,\n+       Get_Tagged_Kind,\n        Inherit_DT,\n        Inherit_TSD,\n        Register_Interface_Tag,\n@@ -197,6 +197,7 @@ package Exp_Disp is\n        Set_Entry_Index,\n        Set_Expanded_Name,\n        Set_External_Tag,\n+       Set_Interface_Table,\n        Set_Offset_Index,\n        Set_OSD,\n        Set_Prim_Op_Address,\n@@ -205,6 +206,7 @@ package Exp_Disp is\n        Set_Remotely_Callable,\n        Set_SSD,\n        Set_TSD,\n+       Set_Tagged_Kind,\n        TSD_Entry_Size,\n        TSD_Prologue_Size);\n \n@@ -217,16 +219,17 @@ package Exp_Disp is\n    --  Ada 2005 (AI-251): Displace all the actuals corresponding to class-wide\n    --  interfaces to reference the interface tag of the actual object\n \n-   procedure Expand_Interface_Conversion (N : Node_Id);\n+   procedure Expand_Interface_Conversion\n+     (N         : Node_Id;\n+      Is_Static : Boolean := True);\n    --  Ada 2005 (AI-251): N is a type-conversion node. Reference the base of\n    --  the object to give access to the interface tag associated with the\n-   --  secondary dispatch table\n+   --  secondary dispatch table.\n \n    function Expand_Interface_Thunk\n      (N           : Node_Id;\n       Thunk_Alias : Node_Id;\n-      Thunk_Id    : Entity_Id;\n-      Thunk_Tag   : Entity_Id) return Node_Id;\n+      Thunk_Id    : Entity_Id) return Node_Id;\n    --  Ada 2005 (AI-251): When a tagged type implements abstract interfaces we\n    --  generate additional subprograms (thunks) to have a layout compatible\n    --  with the C++ ABI. The thunk modifies the value of the first actual of"}, {"sha": "dbb7fb290865f13bd7ac51820eaab3ec19544139", "filename": "gcc/ada/exp_sel.adb", "status": "added", "additions": 220, "deletions": 0, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d744221db2ca7b17e1734998d8fb9a7b67608ca/gcc%2Fada%2Fexp_sel.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d744221db2ca7b17e1734998d8fb9a7b67608ca/gcc%2Fada%2Fexp_sel.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_sel.adb?ref=4d744221db2ca7b17e1734998d8fb9a7b67608ca", "patch": "@@ -0,0 +1,220 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              E X P _ S E L                               --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Einfo;   use Einfo;\n+with Nlists;  use Nlists;\n+with Nmake;   use Nmake;\n+with Rtsfind; use Rtsfind;\n+with Stand;   use Stand;\n+with Tbuild;  use Tbuild;\n+\n+package body Exp_Sel is\n+\n+   -----------------------\n+   -- Build_Abort_Block --\n+   -----------------------\n+\n+   function Build_Abort_Block\n+     (Loc         : Source_Ptr;\n+      Abr_Blk_Ent : Entity_Id;\n+      Cln_Blk_Ent : Entity_Id;\n+      Blk         : Node_Id) return Node_Id\n+   is\n+   begin\n+      return\n+        Make_Block_Statement (Loc,\n+          Identifier   => New_Reference_To (Abr_Blk_Ent, Loc),\n+\n+          Declarations => No_List,\n+\n+          Handled_Statement_Sequence =>\n+            Make_Handled_Sequence_Of_Statements (Loc,\n+              Statements =>\n+                New_List (\n+                  Make_Implicit_Label_Declaration (Loc,\n+                    Defining_Identifier =>\n+                      Cln_Blk_Ent,\n+                    Label_Construct =>\n+                      Blk),\n+                  Blk),\n+\n+              Exception_Handlers =>\n+                New_List (\n+                  Make_Exception_Handler (Loc,\n+                    Exception_Choices =>\n+                      New_List (\n+                        New_Reference_To (Stand.Abort_Signal, Loc)),\n+                    Statements =>\n+                      New_List (\n+                        Make_Procedure_Call_Statement (Loc,\n+                          Name =>\n+                            New_Reference_To (RTE (\n+                              RE_Abort_Undefer), Loc),\n+                          Parameter_Associations => No_List))))));\n+   end Build_Abort_Block;\n+\n+   -------------\n+   -- Build_B --\n+   -------------\n+\n+   function Build_B\n+     (Loc   : Source_Ptr;\n+      Decls : List_Id) return Entity_Id\n+   is\n+      B : constant Entity_Id := Make_Defining_Identifier (Loc,\n+                                  Chars => New_Internal_Name ('B'));\n+\n+   begin\n+      Append_To (Decls,\n+        Make_Object_Declaration (Loc,\n+          Defining_Identifier =>\n+            B,\n+          Object_Definition =>\n+            New_Reference_To (Standard_Boolean, Loc),\n+          Expression =>\n+            New_Reference_To (Standard_False, Loc)));\n+\n+      return B;\n+   end Build_B;\n+\n+   -------------\n+   -- Build_C --\n+   -------------\n+\n+   function Build_C\n+     (Loc   : Source_Ptr;\n+      Decls : List_Id) return Entity_Id\n+   is\n+      C : constant Entity_Id := Make_Defining_Identifier (Loc,\n+                                  Chars => New_Internal_Name ('C'));\n+\n+   begin\n+      Append_To (Decls,\n+        Make_Object_Declaration (Loc,\n+          Defining_Identifier =>\n+            C,\n+          Object_Definition =>\n+            New_Reference_To (RTE (RE_Prim_Op_Kind), Loc)));\n+\n+      return C;\n+   end Build_C;\n+\n+   -------------------------\n+   -- Build_Cleanup_Block --\n+   -------------------------\n+\n+   function Build_Cleanup_Block\n+     (Loc       : Source_Ptr;\n+      Blk_Ent   : Entity_Id;\n+      Stmts     : List_Id;\n+      Clean_Ent : Entity_Id) return Node_Id\n+   is\n+      Cleanup_Block : constant Node_Id :=\n+                        Make_Block_Statement (Loc,\n+                          Identifier   => New_Reference_To (Blk_Ent, Loc),\n+                          Declarations => No_List,\n+                          Handled_Statement_Sequence =>\n+                            Make_Handled_Sequence_Of_Statements (Loc,\n+                              Statements => Stmts),\n+                          Is_Asynchronous_Call_Block => True);\n+\n+   begin\n+      Set_Entry_Cancel_Parameter (Blk_Ent, Clean_Ent);\n+\n+      return Cleanup_Block;\n+   end Build_Cleanup_Block;\n+\n+   -------------\n+   -- Build_K --\n+   -------------\n+\n+   function Build_K\n+     (Loc   : Source_Ptr;\n+      Decls : List_Id;\n+      Obj   : Entity_Id) return Entity_Id\n+   is\n+      K : constant Entity_Id := Make_Defining_Identifier (Loc,\n+                                  Chars => New_Internal_Name ('K'));\n+\n+   begin\n+      Append_To (Decls,\n+        Make_Object_Declaration (Loc,\n+          Defining_Identifier => K,\n+          Object_Definition   =>\n+            New_Reference_To (RTE (RE_Tagged_Kind), Loc),\n+          Expression          =>\n+            Make_Function_Call (Loc,\n+              Name => New_Reference_To (RTE (RE_Get_Tagged_Kind), Loc),\n+              Parameter_Associations => New_List (\n+                Unchecked_Convert_To (RTE (RE_Tag), Obj)))));\n+\n+      return K;\n+   end Build_K;\n+\n+   -------------\n+   -- Build_S --\n+   -------------\n+\n+   function Build_S\n+     (Loc   : Source_Ptr;\n+      Decls : List_Id) return Entity_Id\n+   is\n+      S : constant Entity_Id := Make_Defining_Identifier (Loc,\n+                                  Chars => New_Internal_Name ('S'));\n+\n+   begin\n+      Append_To (Decls,\n+        Make_Object_Declaration (Loc,\n+          Defining_Identifier => S,\n+          Object_Definition   =>\n+            New_Reference_To (Standard_Integer, Loc)));\n+\n+      return S;\n+   end Build_S;\n+\n+   ------------------------\n+   -- Build_S_Assignment --\n+   ------------------------\n+\n+   function Build_S_Assignment\n+     (Loc      : Source_Ptr;\n+      S        : Entity_Id;\n+      Obj      : Entity_Id;\n+      Call_Ent : Entity_Id) return Node_Id\n+   is\n+   begin\n+      return\n+        Make_Assignment_Statement (Loc,\n+          Name => New_Reference_To (S, Loc),\n+          Expression =>\n+            Make_Function_Call (Loc,\n+              Name => New_Reference_To (RTE (RE_Get_Offset_Index), Loc),\n+              Parameter_Associations => New_List (\n+                Unchecked_Convert_To (RTE (RE_Tag), Obj),\n+                Make_Integer_Literal (Loc, DT_Position (Call_Ent)))));\n+   end Build_S_Assignment;\n+\n+end Exp_Sel;"}, {"sha": "fd8caceeee681a825fa6f0e0b5d3018136d2ad94", "filename": "gcc/ada/exp_sel.ads", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d744221db2ca7b17e1734998d8fb9a7b67608ca/gcc%2Fada%2Fexp_sel.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d744221db2ca7b17e1734998d8fb9a7b67608ca/gcc%2Fada%2Fexp_sel.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_sel.ads?ref=4d744221db2ca7b17e1734998d8fb9a7b67608ca", "patch": "@@ -0,0 +1,113 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              E X P _ S E L                               --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Routines used in Chapter 9 for the expansion of dispatching triggers in\n+--  select statements (Ada 2005: AI-345)\n+\n+with Types; use Types;\n+\n+package Exp_Sel is\n+\n+   function Build_Abort_Block\n+     (Loc         : Source_Ptr;\n+      Abr_Blk_Ent : Entity_Id;\n+      Cln_Blk_Ent : Entity_Id;\n+      Blk         : Node_Id) return Node_Id;\n+   --  Generate:\n+   --    begin\n+   --       Blk\n+   --    exception\n+   --       when Abort_Signal => Abort_Undefer;\n+   --    end;\n+   --  Abr_Blk_Ent is the name of the generated block, Cln_Blk_Ent is the name\n+   --  of the encapsulated cleanup block, Blk is the actual block name.\n+\n+   function Build_B\n+     (Loc   : Source_Ptr;\n+      Decls : List_Id) return Entity_Id;\n+   --  Generate:\n+   --    B : Boolean := False;\n+   --  Append the object declaration to the list and return its defining\n+   --  identifier.\n+\n+   function Build_C\n+     (Loc   : Source_Ptr;\n+      Decls : List_Id) return Entity_Id;\n+   --  Generate:\n+   --    C : Ada.Tags.Prim_Op_Kind;\n+   --  Append the object declaration to the list and return its defining\n+   --  identifier.\n+\n+   function Build_Cleanup_Block\n+     (Loc       : Source_Ptr;\n+      Blk_Ent   : Entity_Id;\n+      Stmts     : List_Id;\n+      Clean_Ent : Entity_Id) return Node_Id;\n+   --  Generate:\n+   --    declare\n+   --       procedure _clean is\n+   --       begin\n+   --          ...\n+   --       end _clean;\n+   --    begin\n+   --       Stmts\n+   --    at end\n+   --       _clean;\n+   --    end;\n+   --  Blk_Ent is the name of the generated block, Stmts is the list of\n+   --  encapsulated statements and Clean_Ent is the parameter to the\n+   --  _clean procedure.\n+\n+   function Build_K\n+     (Loc   : Source_Ptr;\n+      Decls : List_Id;\n+      Obj   : Entity_Id) return Entity_Id;\n+   --  Generate\n+   --    K : Ada.Tags.Tagged_Kind :=\n+   --          Ada.Tags.Get_Tagged_Kind (Ada.Tags.Tag (Obj));\n+   --  where Obj is the pointer to a secondary table. Append the object\n+   --  declaration to the list and return its defining identifier.\n+\n+   function Build_S\n+     (Loc  : Source_Ptr;\n+      Decls : List_Id) return Entity_Id;\n+   --  Generate:\n+   --    S : Integer;\n+   --  Append the object declaration to the list and return its defining\n+   --  identifier.\n+\n+   function Build_S_Assignment\n+     (Loc      : Source_Ptr;\n+      S        : Entity_Id;\n+      Obj      : Entity_Id;\n+      Call_Ent : Entity_Id) return Node_Id;\n+   --  Generate:\n+   --    S := Ada.Tags.Get_Offset_Index (\n+   --           Ada.Tags.Tag (Obj), DT_Position (Call_Ent));\n+   --  where Obj is the pointer to a secondary table, Call_Ent is the entity\n+   --  of the dispatching call name. Return the generated assignment.\n+\n+end Exp_Sel;"}, {"sha": "3b4522c85f96c4e7c1b210bc71445e2233375822", "filename": "gcc/ada/rtsfind.ads", "status": "modified", "additions": 41, "deletions": 14, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d744221db2ca7b17e1734998d8fb9a7b67608ca/gcc%2Fada%2Frtsfind.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d744221db2ca7b17e1734998d8fb9a7b67608ca/gcc%2Fada%2Frtsfind.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.ads?ref=4d744221db2ca7b17e1734998d8fb9a7b67608ca", "patch": "@@ -120,6 +120,7 @@ package Rtsfind is\n       Ada_Streams,\n       Ada_Tags,\n       Ada_Task_Identification,\n+      Ada_Task_Termination,\n \n       --  Children of Ada.Calendar\n \n@@ -488,10 +489,12 @@ package Rtsfind is\n \n      RE_Stream_Access,                   -- Ada.Streams.Stream_IO\n \n+     RE_Abstract_Interface,              -- Ada.Tags\n      RE_Addr_Ptr,                        -- Ada.Tags\n+     RE_Address_Array,                   -- Ada.Tags\n      RE_CW_Membership,                   -- Ada.Tags\n-     RE_IW_Membership,                   -- Ada.Tags\n      RE_Descendant_Tag,                  -- Ada.Tags\n+     RE_Displace,                        -- Ada.Tags\n      RE_DT_Entry_Size,                   -- Ada.Tags\n      RE_DT_Prologue_Size,                -- Ada.Tags\n      RE_External_Tag,                    -- Ada.Tags\n@@ -503,11 +506,16 @@ package Rtsfind is\n      RE_Get_Prim_Op_Kind,                -- Ada.Tags\n      RE_Get_RC_Offset,                   -- Ada.Tags\n      RE_Get_Remotely_Callable,           -- Ada.Tags\n+     RE_Get_Tagged_Kind,                 -- Ada.Tags\n      RE_Inherit_DT,                      -- Ada.Tags\n      RE_Inherit_TSD,                     -- Ada.Tags\n+     RE_Interface_Data,                  -- Ada.Tags\n+     RE_Interface_Tag,                   -- Ada.Tags\n      RE_Internal_Tag,                    -- Ada.Tags\n      RE_Is_Descendant_At_Same_Level,     -- Ada.Tags\n+     RE_IW_Membership,                   -- Ada.Tags\n      RE_Object_Specific_Data,            -- Ada.Tags\n+     RE_Offset_To_Top,                   -- Ada.Tags\n      RE_POK_Function,                    -- Ada.Tags\n      RE_POK_Procedure,                   -- Ada.Tags\n      RE_POK_Protected_Entry,             -- Ada.Tags\n@@ -517,13 +525,16 @@ package Rtsfind is\n      RE_POK_Task_Function,               -- Ada.Tags\n      RE_POK_Task_Procedure,              -- Ada.Tags\n      RE_Prim_Op_Kind,                    -- Ada.Tags\n+     RE_Primary_DT,                      -- Ada.Tags\n      RE_Register_Interface_Tag,          -- Ada.Tags\n      RE_Register_Tag,                    -- Ada.Tags\n+     RE_Secondary_DT,                    -- Ada.Tags\n      RE_Select_Specific_Data,            -- Ada.Tags\n      RE_Set_Access_Level,                -- Ada.Tags\n      RE_Set_Entry_Index,                 -- Ada.Tags\n      RE_Set_Expanded_Name,               -- Ada.Tags\n      RE_Set_External_Tag,                -- Ada.Tags\n+     RE_Set_Interface_Table,             -- Ada.Tags\n      RE_Set_Num_Prim_Ops,                -- Ada.Tags\n      RE_Set_Offset_Index,                -- Ada.Tags\n      RE_Set_Offset_To_Top,               -- Ada.Tags\n@@ -533,17 +544,20 @@ package Rtsfind is\n      RE_Set_RC_Offset,                   -- Ada.Tags\n      RE_Set_Remotely_Callable,           -- Ada.Tags\n      RE_Set_SSD,                         -- Ada.Tags\n+     RE_Set_Tagged_Kind,                 -- Ada.Tags\n      RE_Set_TSD,                         -- Ada.Tags\n+     RE_Tag,                             -- Ada.Tags\n      RE_Tag_Error,                       -- Ada.Tags\n+     RE_Tagged_Kind,                     -- Ada.Tags\n      RE_TSD_Entry_Size,                  -- Ada.Tags\n      RE_TSD_Prologue_Size,               -- Ada.Tags\n-     RE_Interface_Tag,                   -- Ada.Tags\n-     RE_Tag,                             -- Ada.Tags\n-     RE_Address_Array,                   -- Ada.Tags\n+     RE_TK_Abstract_Limited_Tagged,      -- Ada.Tags\n+     RE_TK_Abstract_Tagged,              -- Ada.Tags\n+     RE_TK_Limited_Tagged,               -- Ada.Tags\n+     RE_TK_Protected,                    -- Ada.Tags\n+     RE_TK_Tagged,                       -- Ada.Tags\n+     RE_TK_Task,                         -- Ada.Tags\n      RE_Valid_Signature,                 -- Ada.Tags\n-     RE_Primary_DT,                      -- Ada.Tags\n-     RE_Secondary_DT,                    -- Ada.Tags\n-     RE_Abstract_Interface,              -- Ada.Tags\n \n      RE_Abort_Task,                      -- Ada.Task_Identification\n      RE_Current_Task,                    -- Ada.Task_Identification\n@@ -1629,10 +1643,12 @@ package Rtsfind is\n \n      RE_Stream_Access                    => Ada_Streams_Stream_IO,\n \n+     RE_Abstract_Interface               => Ada_Tags,\n      RE_Addr_Ptr                         => Ada_Tags,\n+     RE_Address_Array                    => Ada_Tags,\n      RE_CW_Membership                    => Ada_Tags,\n-     RE_IW_Membership                    => Ada_Tags,\n      RE_Descendant_Tag                   => Ada_Tags,\n+     RE_Displace                         => Ada_Tags,\n      RE_DT_Entry_Size                    => Ada_Tags,\n      RE_DT_Prologue_Size                 => Ada_Tags,\n      RE_External_Tag                     => Ada_Tags,\n@@ -1644,11 +1660,16 @@ package Rtsfind is\n      RE_Get_Prim_Op_Kind                 => Ada_Tags,\n      RE_Get_RC_Offset                    => Ada_Tags,\n      RE_Get_Remotely_Callable            => Ada_Tags,\n+     RE_Get_Tagged_Kind                  => Ada_Tags,\n      RE_Inherit_DT                       => Ada_Tags,\n      RE_Inherit_TSD                      => Ada_Tags,\n+     RE_Interface_Data                   => Ada_Tags,\n+     RE_Interface_Tag                    => Ada_Tags,\n      RE_Internal_Tag                     => Ada_Tags,\n      RE_Is_Descendant_At_Same_Level      => Ada_Tags,\n+     RE_IW_Membership                    => Ada_Tags,\n      RE_Object_Specific_Data             => Ada_Tags,\n+     RE_Offset_To_Top                    => Ada_Tags,\n      RE_POK_Function                     => Ada_Tags,\n      RE_POK_Procedure                    => Ada_Tags,\n      RE_POK_Protected_Entry              => Ada_Tags,\n@@ -1658,13 +1679,16 @@ package Rtsfind is\n      RE_POK_Task_Function                => Ada_Tags,\n      RE_POK_Task_Procedure               => Ada_Tags,\n      RE_Prim_Op_Kind                     => Ada_Tags,\n+     RE_Primary_DT                       => Ada_Tags,\n      RE_Register_Interface_Tag           => Ada_Tags,\n      RE_Register_Tag                     => Ada_Tags,\n+     RE_Secondary_DT                     => Ada_Tags,\n      RE_Select_Specific_Data             => Ada_Tags,\n      RE_Set_Access_Level                 => Ada_Tags,\n      RE_Set_Entry_Index                  => Ada_Tags,\n      RE_Set_Expanded_Name                => Ada_Tags,\n      RE_Set_External_Tag                 => Ada_Tags,\n+     RE_Set_Interface_Table              => Ada_Tags,\n      RE_Set_Num_Prim_Ops                 => Ada_Tags,\n      RE_Set_Offset_Index                 => Ada_Tags,\n      RE_Set_Offset_To_Top                => Ada_Tags,\n@@ -1674,17 +1698,20 @@ package Rtsfind is\n      RE_Set_RC_Offset                    => Ada_Tags,\n      RE_Set_Remotely_Callable            => Ada_Tags,\n      RE_Set_SSD                          => Ada_Tags,\n+     RE_Set_Tagged_Kind                  => Ada_Tags,\n      RE_Set_TSD                          => Ada_Tags,\n+     RE_Tag                              => Ada_Tags,\n      RE_Tag_Error                        => Ada_Tags,\n+     RE_Tagged_Kind                      => Ada_Tags,\n      RE_TSD_Entry_Size                   => Ada_Tags,\n      RE_TSD_Prologue_Size                => Ada_Tags,\n-     RE_Interface_Tag                    => Ada_Tags,\n-     RE_Tag                              => Ada_Tags,\n-     RE_Address_Array                    => Ada_Tags,\n+     RE_TK_Abstract_Limited_Tagged       => Ada_Tags,\n+     RE_TK_Abstract_Tagged               => Ada_Tags,\n+     RE_TK_Limited_Tagged                => Ada_Tags,\n+     RE_TK_Protected                     => Ada_Tags,\n+     RE_TK_Tagged                        => Ada_Tags,\n+     RE_TK_Task                          => Ada_Tags,\n      RE_Valid_Signature                  => Ada_Tags,\n-     RE_Primary_DT                       => Ada_Tags,\n-     RE_Secondary_DT                     => Ada_Tags,\n-     RE_Abstract_Interface               => Ada_Tags,\n \n      RE_Abort_Task                       => Ada_Task_Identification,\n      RE_Current_Task                     => Ada_Task_Identification,"}]}