{"sha": "f193b29e42bcca7b92752d98d3a38dc9df884bef", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjE5M2IyOWU0MmJjY2E3YjkyNzUyZDk4ZDNhMzhkYzlkZjg4NGJlZg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2020-04-09T09:42:22Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-06-16T13:07:18Z"}, "message": "[Ada] Expand 'Pos and 'Val for enumeration types with standard representation\n\n2020-06-16  Eric Botcazou  <ebotcazou@adacore.com>\n\ngcc/ada/\n\n\t* sinfo.ads (Conversion_OK): Document use for 'Pos and 'Val.\n\t* exp_attr.adb (Get_Integer_Type): New function returning a\n\tsmall integer type appropriate for an enumeration type.\n\t(Expand_N_Attribute_Reference) <Attribute_Enum_Rep>: Call it.\n\t<Attribute_Pos>: For an enumeration type with a standard\n\trepresentation, expand to a conversion with Conversion_OK.\n\t<Attribute_Val>: Likewise.\n\t* exp_ch4.adb (Expand_N_Type_Conversion): Do not expand when\n\tthe target is an enumeration type and Conversion_OK is set.", "tree": {"sha": "c956536208297d7eae77b9b7a0a5e977fbc64a90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c956536208297d7eae77b9b7a0a5e977fbc64a90"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f193b29e42bcca7b92752d98d3a38dc9df884bef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f193b29e42bcca7b92752d98d3a38dc9df884bef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f193b29e42bcca7b92752d98d3a38dc9df884bef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f193b29e42bcca7b92752d98d3a38dc9df884bef/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dad94b3aca12f25cd2b3f6c32b7e55d69c8c4ad6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dad94b3aca12f25cd2b3f6c32b7e55d69c8c4ad6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dad94b3aca12f25cd2b3f6c32b7e55d69c8c4ad6"}], "stats": {"total": 106, "additions": 69, "deletions": 37}, "files": [{"sha": "d31f61dcb8cb6d8cd09e39b974fcdcce02897e6c", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 63, "deletions": 33, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f193b29e42bcca7b92752d98d3a38dc9df884bef/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f193b29e42bcca7b92752d98d3a38dc9df884bef/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=f193b29e42bcca7b92752d98d3a38dc9df884bef", "patch": "@@ -1737,11 +1737,41 @@ package body Exp_Attr is\n       Pref  : constant Node_Id      := Prefix (N);\n       Exprs : constant List_Id      := Expressions (N);\n \n+      function Get_Integer_Type (Typ : Entity_Id) return Entity_Id;\n+      --  Return a small integer type appropriate for the enumeration type\n+\n       procedure Rewrite_Attribute_Proc_Call (Pname : Entity_Id);\n       --  Rewrites an attribute for Read, Write, Output, or Put_Image with a\n       --  call to the appropriate TSS procedure. Pname is the entity for the\n       --  procedure to call.\n \n+      ----------------------\n+      -- Get_Integer_Type --\n+      ----------------------\n+\n+      function Get_Integer_Type (Typ : Entity_Id) return Entity_Id is\n+         Siz     : constant Uint := RM_Size (Base_Type (Typ));\n+         Int_Typ : Entity_Id;\n+\n+      begin\n+         --  We need to accommodate unsigned values\n+\n+         if Siz < 8 then\n+            Int_Typ := Standard_Integer_8;\n+\n+         elsif Siz < 16 then\n+            Int_Typ := Standard_Integer_16;\n+\n+         elsif Siz < 32 then\n+            Int_Typ := Standard_Integer_32;\n+\n+         else\n+            Int_Typ := Standard_Integer_64;\n+         end if;\n+\n+         return Int_Typ;\n+      end Get_Integer_Type;\n+\n       ---------------------------------\n       -- Rewrite_Attribute_Proc_Call --\n       ---------------------------------\n@@ -3146,8 +3176,6 @@ package body Exp_Attr is\n \n       when Attribute_Enum_Rep => Enum_Rep : declare\n          Expr : Node_Id;\n-         Ityp : Entity_Id;\n-         Psiz : Uint;\n \n       begin\n          --  Get the expression, which is X for Enum_Type'Enum_Rep (X) or\n@@ -3177,22 +3205,7 @@ package body Exp_Attr is\n          --  the size information.\n \n          if Is_Enumeration_Type (Ptyp) then\n-            Psiz := RM_Size (Base_Type (Ptyp));\n-\n-            if Psiz < 8 then\n-               Ityp := Standard_Integer_8;\n-\n-            elsif Psiz < 16 then\n-               Ityp := Standard_Integer_16;\n-\n-            elsif Psiz < 32 then\n-               Ityp := Standard_Integer_32;\n-\n-            else\n-               Ityp := Standard_Integer_64;\n-            end if;\n-\n-            Rewrite (N, OK_Convert_To (Ityp, Expr));\n+            Rewrite (N, OK_Convert_To (Get_Integer_Type (Ptyp), Expr));\n             Convert_To_And_Rewrite (Typ, N);\n \n          else\n@@ -5159,9 +5172,6 @@ package body Exp_Attr is\n       -- Pos --\n       ---------\n \n-      --  For enumeration types with a standard representation, Pos is handled\n-      --  by the back end.\n-\n       --  For enumeration types, with a non-standard representation we generate\n       --  a call to the _Rep_To_Pos function created when the type was frozen.\n       --  The call has the form:\n@@ -5172,17 +5182,21 @@ package body Exp_Attr is\n       --  Program_Error to be raised if the expression has an invalid\n       --  representation, and False if range checks are suppressed.\n \n+      --  For enumeration types with a standard representation, Pos can be\n+      --  rewritten as a simple conversion with Conversion_OK set.\n+\n       --  For integer types, Pos is equivalent to a simple integer conversion\n       --  and we rewrite it as such.\n \n       when Attribute_Pos => Pos : declare\n+         Expr : constant Node_Id := First (Exprs);\n          Etyp : Entity_Id := Base_Type (Ptyp);\n \n       begin\n          --  Deal with zero/non-zero boolean values\n \n          if Is_Boolean_Type (Etyp) then\n-            Adjust_Condition (First (Exprs));\n+            Adjust_Condition (Expr);\n             Etyp := Standard_Boolean;\n             Set_Prefix (N, New_Occurrence_Of (Standard_Boolean, Loc));\n          end if;\n@@ -5202,21 +5216,32 @@ package body Exp_Attr is\n                        New_Occurrence_Of (TSS (Etyp, TSS_Rep_To_Pos), Loc),\n                      Parameter_Associations => Exprs)));\n \n-               Analyze_And_Resolve (N, Typ);\n+            --  Standard enumeration type (replace by conversion)\n+\n+            --  This is simply a direct conversion from the enumeration type to\n+            --  the target integer type, which is treated by the back end as a\n+            --  normal integer conversion, treating the enumeration type as an\n+            --  integer, which is exactly what we want. We set Conversion_OK to\n+            --  make sure that the analyzer does not complain about what might\n+            --  be an illegal conversion.\n \n-            --  Standard enumeration type (do universal integer check)\n+            --  However the target type is universal integer in most cases,\n+            --  which is a very large type, so we first convert to a small\n+            --  signed integer type in order not to lose the size information.\n \n             else\n-               Apply_Universal_Integer_Attribute_Checks (N);\n+               Rewrite (N, OK_Convert_To (Get_Integer_Type (Ptyp), Expr));\n+               Convert_To_And_Rewrite (Typ, N);\n+\n             end if;\n \n          --  Deal with integer types (replace by conversion)\n \n          elsif Is_Integer_Type (Etyp) then\n-            Rewrite (N, Convert_To (Typ, First (Exprs)));\n-            Analyze_And_Resolve (N, Typ);\n+            Rewrite (N, Convert_To (Typ, Expr));\n          end if;\n \n+         Analyze_And_Resolve (N, Typ);\n       end Pos;\n \n       --------------\n@@ -6660,13 +6685,13 @@ package body Exp_Attr is\n       -- Val --\n       ---------\n \n-      --  For enumeration types with a standard representation, Val is handled\n-      --  by the back end.\n-\n       --  For enumeration types with a non-standard representation we use the\n       --  _Pos_To_Rep array that was created when the type was frozen, unless\n       --  the representation is contiguous in which case we use an addition.\n \n+      --  For enumeration types with a standard representation, Val can be\n+      --  rewritten as a simple conversion with Conversion_OK set.\n+\n       --  For integer types, Val is equivalent to a simple integer conversion\n       --  and we rewrite it as such.\n \n@@ -6749,11 +6774,16 @@ package body Exp_Attr is\n                         Right_Opnd =>\n                           Convert_To (Ityp, Expr))));\n \n-                  --  Suppress checks since the range check was done above\n-                  --  and it guarantees that the addition cannot overflow.\n+               --  Standard enumeration type\n \n-                  Analyze_And_Resolve (N, Typ, Suppress => All_Checks);\n+               else\n+                  Rewrite (N, OK_Convert_To (Typ, Expr));\n                end if;\n+\n+               --  Suppress checks since the range check was done above\n+               --  and it guarantees that the addition cannot overflow.\n+\n+               Analyze_And_Resolve (N, Typ, Suppress => All_Checks);\n             end if;\n \n          --  Deal with integer types"}, {"sha": "aeb41c97fe6253616e8e9500cb2e8768933ff4d0", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f193b29e42bcca7b92752d98d3a38dc9df884bef/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f193b29e42bcca7b92752d98d3a38dc9df884bef/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=f193b29e42bcca7b92752d98d3a38dc9df884bef", "patch": "@@ -12280,9 +12280,11 @@ package body Exp_Ch4 is\n          --  Special processing is required if there is a change of\n          --  representation (from enumeration representation clauses).\n \n-         if not Same_Representation (Target_Type, Operand_Type) then\n+         if not Same_Representation (Target_Type, Operand_Type)\n+           and then not Conversion_OK (N)\n+         then\n \n-            --  Convert: x(y) to x'val (ytyp'val (y))\n+            --  Convert: x(y) to x'val (ytyp'pos (y))\n \n             Rewrite (N,\n               Make_Attribute_Reference (Loc,"}, {"sha": "401b38dccab46434242cf14e27478df82e3e6876", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f193b29e42bcca7b92752d98d3a38dc9df884bef/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f193b29e42bcca7b92752d98d3a38dc9df884bef/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=f193b29e42bcca7b92752d98d3a38dc9df884bef", "patch": "@@ -1017,8 +1017,8 @@ package Sinfo is\n    --    A flag set on type conversion nodes to indicate that the conversion\n    --    is to be considered as being valid, even though it is the case that\n    --    the conversion is not valid Ada. This is used for attributes Enum_Rep,\n-   --    Fixed_Value and Integer_Value, for internal conversions done for\n-   --    fixed-point operations, and for certain conversions for calls to\n+   --    Pos, Val, Fixed_Value and Integer_Value, for internal conversions done\n+   --    for fixed-point operations, and for certain conversions for calls to\n    --    initialization procedures. If Conversion_OK is set, then Etype must be\n    --    set (the analyzer assumes that Etype has been set). For the case of\n    --    fixed-point operands, it also indicates that the conversion is to be"}]}