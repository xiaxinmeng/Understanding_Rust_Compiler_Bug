{"sha": "beacce027435fb068f0edcb0a0e094ab6630ff01", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmVhY2NlMDI3NDM1ZmIwNjhmMGVkY2IwYTBlMDk0YWI2NjMwZmYwMQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-12T11:00:42Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-12T11:00:42Z"}, "message": "[multiple changes]\n\n2010-10-12  Robert Dewar  <dewar@adacore.com>\n\n\t* gnat_rm.texi: Clarify that 'Old can be used in preconditions and\n\tpostcondition pragmas.\n\n2010-10-12  Robert Dewar  <dewar@adacore.com>\n\n\t* errout.ads, erroutc.adb: The # insertion now handles from in place of\n\tat.\n\t* exp_prag.adb (Expand_Pragma_Check): Suppress generated default\n\tmessage if new switch Exception_Locations_Suppressed is set.\n\t(Expand_Pragma_Check): Revised wording for default message for case\n\tof precondition or postcondition.\n\t* namet.ads, namet.adb (Build_Location_String): New procedure.\n\t* opt.ads (List_Inherited_Pre_Post): New flag.\n\t* sem_ch12.adb (Analyze_Generic_Subprogram_Declaration): Add call to\n\tlist inherited pre/post aspects.\n\t* sem_ch13.adb (Analyze_Aspect_Specification): Improve generation of\n\tmessages for precondition/postcondition cases.\n\t* sem_ch6.adb (Process_PPCs): General cleanup, and list inherited PPC's\n\tif flag List_Inherited_Pre_Post is set True.\n\t(Process_PPCs): Add initial handling for inherited preconditions\n\t(List_Inherited_Pre_Post_Aspects): New procedure\n\t* sem_ch6.ads (List_Inherited_Pre_Post_Aspects): New procedure\n\t* sem_disp.adb (Inherited_Subprograms): New function\n\t* sem_disp.ads (Inherited_Subprograms): New function\n\t* sem_prag.adb (Check_Duplicate_Pragma): Clean up handling of\n\tpre/postcondition.\n\t(Check_Precondition_Postcondition): Check for inherited aspects\n\t* sem_warn.adb: Process -gnatw.l/w.L setting List_Inherited_Pre_Post\n\t* sinfo.ads, sinfo.adb (Split_PPC): New flag.\n\t* sinput.ads, sinput.adb (Build_Location_String): New function.\n\t* usage.adb: Add line for -gnatw.l/-gnatw.L\n\n2010-10-12  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_util.adb (Remove_Side_Effects): Remove wrong code.\n\n2010-10-12  Arnaud Charlet  <charlet@adacore.com>\n\n\t* xref_lib.adb: Add handling of j/J letters.\n\nFrom-SVN: r165361", "tree": {"sha": "7e0cd7e0a9942df3ea3c59ba7deec6900d9f0a80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7e0cd7e0a9942df3ea3c59ba7deec6900d9f0a80"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/beacce027435fb068f0edcb0a0e094ab6630ff01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/beacce027435fb068f0edcb0a0e094ab6630ff01", "html_url": "https://github.com/Rust-GCC/gccrs/commit/beacce027435fb068f0edcb0a0e094ab6630ff01", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/beacce027435fb068f0edcb0a0e094ab6630ff01/comments", "author": null, "committer": null, "parents": [{"sha": "a4feaa716751d9755b7c0420cd8845089c6d6d3a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4feaa716751d9755b7c0420cd8845089c6d6d3a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4feaa716751d9755b7c0420cd8845089c6d6d3a"}], "stats": {"total": 724, "additions": 585, "deletions": 139}, "files": [{"sha": "b7fe85f8db40478a27c5ea38cc248c81d3cac7c5", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/beacce027435fb068f0edcb0a0e094ab6630ff01/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/beacce027435fb068f0edcb0a0e094ab6630ff01/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=beacce027435fb068f0edcb0a0e094ab6630ff01", "patch": "@@ -1,3 +1,45 @@\n+2010-10-12  Robert Dewar  <dewar@adacore.com>\n+\n+\t* gnat_rm.texi: Clarify that 'Old can be used in preconditions and\n+\tpostcondition pragmas.\n+\n+2010-10-12  Robert Dewar  <dewar@adacore.com>\n+\n+\t* errout.ads, erroutc.adb: The # insertion now handles from in place of\n+\tat.\n+\t* exp_prag.adb (Expand_Pragma_Check): Suppress generated default\n+\tmessage if new switch Exception_Locations_Suppressed is set.\n+\t(Expand_Pragma_Check): Revised wording for default message for case\n+\tof precondition or postcondition.\n+\t* namet.ads, namet.adb (Build_Location_String): New procedure.\n+\t* opt.ads (List_Inherited_Pre_Post): New flag.\n+\t* sem_ch12.adb (Analyze_Generic_Subprogram_Declaration): Add call to\n+\tlist inherited pre/post aspects.\n+\t* sem_ch13.adb (Analyze_Aspect_Specification): Improve generation of\n+\tmessages for precondition/postcondition cases.\n+\t* sem_ch6.adb (Process_PPCs): General cleanup, and list inherited PPC's\n+\tif flag List_Inherited_Pre_Post is set True.\n+\t(Process_PPCs): Add initial handling for inherited preconditions\n+\t(List_Inherited_Pre_Post_Aspects): New procedure\n+\t* sem_ch6.ads (List_Inherited_Pre_Post_Aspects): New procedure\n+\t* sem_disp.adb (Inherited_Subprograms): New function\n+\t* sem_disp.ads (Inherited_Subprograms): New function\n+\t* sem_prag.adb (Check_Duplicate_Pragma): Clean up handling of\n+\tpre/postcondition.\n+\t(Check_Precondition_Postcondition): Check for inherited aspects\n+\t* sem_warn.adb: Process -gnatw.l/w.L setting List_Inherited_Pre_Post\n+\t* sinfo.ads, sinfo.adb (Split_PPC): New flag.\n+\t* sinput.ads, sinput.adb (Build_Location_String): New function.\n+\t* usage.adb: Add line for -gnatw.l/-gnatw.L\n+\n+2010-10-12  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_util.adb (Remove_Side_Effects): Remove wrong code.\n+\n+2010-10-12  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* xref_lib.adb: Add handling of j/J letters.\n+\n 2010-10-12  Pascal Obry  <obry@adacore.com>\n \n \t* adaint.c (__gnat_number_of_cpus): Add implementation for Windows."}, {"sha": "8fc5f82632fac2ee298f9b5a54c9ce32ce0f0841", "filename": "gcc/ada/errout.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/beacce027435fb068f0edcb0a0e094ab6630ff01/gcc%2Fada%2Ferrout.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/beacce027435fb068f0edcb0a0e094ab6630ff01/gcc%2Fada%2Ferrout.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferrout.ads?ref=beacce027435fb068f0edcb0a0e094ab6630ff01", "patch": "@@ -207,6 +207,10 @@ package Errout is\n    --      The idea is that for any use of -gnatj, it will still be the case\n    --      that a location reference appears only at the end of a line.\n \n+   --      Note: the output of the string \"at \" is suppressed if the string\n+   --      \" from\" or \" from \" immediately precedes the insertion character #.\n+   --      Certain messages read better with from than at.\n+\n    --    Insertion character } (Right brace: insert type reference)\n    --      The character } is replaced by a string describing the type\n    --      referenced by the entity whose Id is stored in Error_Msg_Node_1."}, {"sha": "e023f3174400597f4c265c264f93e82dfa9264a5", "filename": "gcc/ada/erroutc.adb", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/beacce027435fb068f0edcb0a0e094ab6630ff01/gcc%2Fada%2Ferroutc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/beacce027435fb068f0edcb0a0e094ab6630ff01/gcc%2Fada%2Ferroutc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferroutc.adb?ref=beacce027435fb068f0edcb0a0e094ab6630ff01", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -717,11 +717,31 @@ package body Erroutc is\n       Sindex_Loc  : Source_File_Index;\n       Sindex_Flag : Source_File_Index;\n \n+      procedure Set_At;\n+      --  Outputs \"at \" unless last characters in buffer are \" from \". Certain\n+      --  messages read better with from than at.\n+\n+      ------------\n+      -- Set_At --\n+      ------------\n+\n+      procedure Set_At is\n+      begin\n+         if Msglen < 6\n+           or else Msg_Buffer (Msglen - 5 .. Msglen) /= \" from \"\n+         then\n+            Set_Msg_Str (\"at \");\n+         end if;\n+      end Set_At;\n+\n+   --  Start of processing for Set_Msg_Insertion_Line_Number\n+\n    begin\n       Set_Msg_Blank;\n \n       if Loc = No_Location then\n-         Set_Msg_Str (\"at unknown location\");\n+         Set_At;\n+         Set_Msg_Str (\"unknown location\");\n \n       elsif Loc = System_Location then\n          Set_Msg_Str (\"in package System\");\n@@ -743,7 +763,7 @@ package body Erroutc is\n          Sindex_Flag := Get_Source_File_Index (Flag);\n \n          if Full_File_Name (Sindex_Loc) /= Full_File_Name (Sindex_Flag) then\n-            Set_Msg_Str (\"at \");\n+            Set_At;\n             Get_Name_String\n               (Reference_Name (Get_Source_File_Index (Loc)));\n             Set_Msg_Name_Buffer;\n@@ -752,7 +772,8 @@ package body Erroutc is\n          --  If in current file, add text \"at line \"\n \n          else\n-            Set_Msg_Str (\"at line \");\n+            Set_At;\n+            Set_Msg_Str (\"line \");\n          end if;\n \n          --  Output line number for reference"}, {"sha": "cb896ec20ba76655f278804ff66e054882571d03", "filename": "gcc/ada/exp_prag.adb", "status": "modified", "additions": 49, "deletions": 19, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/beacce027435fb068f0edcb0a0e094ab6630ff01/gcc%2Fada%2Fexp_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/beacce027435fb068f0edcb0a0e094ab6630ff01/gcc%2Fada%2Fexp_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_prag.adb?ref=beacce027435fb068f0edcb0a0e094ab6630ff01", "patch": "@@ -310,6 +310,9 @@ package body Exp_Prag is\n       --  be able to handle the assert error (which would not be the case if a\n       --  call is made to the Raise_Assert_Failure procedure).\n \n+      --  We also generate the direct raise if the Suppress_Exception_Locations\n+      --  is active, since we don't want to generate messages in this case.\n+\n       --  Note that the reason we do not always generate a direct raise is that\n       --  the form in which the procedure is called allows for more efficient\n       --  breakpointing of assertion errors.\n@@ -320,9 +323,10 @@ package body Exp_Prag is\n \n       --  Case where we generate a direct raise\n \n-      if (Debug_Flag_Dot_G\n+      if ((Debug_Flag_Dot_G\n            or else Restriction_Active (No_Exception_Propagation))\n-        and then Present (Find_Local_Handler (RTE (RE_Assert_Failure), N))\n+          and then Present (Find_Local_Handler (RTE (RE_Assert_Failure), N)))\n+        or else (Opt.Exception_Locations_Suppressed and then No (Arg3 (N)))\n       then\n          Rewrite (N,\n            Make_If_Statement (Loc,\n@@ -337,29 +341,55 @@ package body Exp_Prag is\n       --  Case where we call the procedure\n \n       else\n-         --  First, we need to prepare the string argument\n-\n          --  If we have a message given, use it\n \n          if Present (Arg3 (N)) then\n-            Msg := Arg3 (N);\n+            Msg := Get_Pragma_Arg (Arg3 (N));\n \n-         --  Otherwise string is \"name failed at location\" except in the case\n-         --  of Assertion where \"name failed at\" is omitted.\n+         --  Here we have no string, so prepare one\n \n          else\n-            if Nam = Name_Assertion then\n-               Name_Len := 0;\n-            else\n-               Get_Name_String (Nam);\n-               Set_Casing (Identifier_Casing (Current_Source_File));\n-               Add_Str_To_Name_Buffer (\" failed at \");\n-            end if;\n+            declare\n+               Msg_Loc : constant String := Build_Location_String (Loc);\n \n-            Build_Location_String (Loc);\n-            Msg :=\n-              Make_String_Literal (Loc,\n-                Strval => String_From_Name_Buffer);\n+            begin\n+               --  For Assert, we just use the location\n+\n+               if Nam = Name_Assertion then\n+                  Name_Len := 0;\n+\n+                  --  For any check except Precondition/Postcondition, the\n+                  --  string is \"xxx failed at yyy\" where xxx is the name of\n+                  --  the check with current source file casing.\n+\n+               elsif Nam /= Name_Precondition\n+                       and then\n+                     Nam /= Name_Postcondition\n+               then\n+                  Get_Name_String (Nam);\n+                  Set_Casing (Identifier_Casing (Current_Source_File));\n+                  Add_Str_To_Name_Buffer (\" failed at \");\n+\n+               --  For special case of Precondition/Postcondition the string is\n+               --  \"failed xx from yy\" where xx is precondition/postcondition\n+               --  in all lower case. The reason for this different wording is\n+               --  that the failure is not at the point of occurrence of the\n+               --  pragma, unlike the other Check cases.\n+\n+               else\n+                  Get_Name_String (Nam);\n+                  Insert_Str_In_Name_Buffer (\"failed \", 1);\n+                  Add_Str_To_Name_Buffer (\" from \");\n+               end if;\n+\n+               --  In all cases, add location string\n+\n+               Add_Str_To_Name_Buffer (Msg_Loc);\n+\n+               --  Build the message\n+\n+               Msg := Make_String_Literal (Loc, Name_Buffer (1 .. Name_Len));\n+            end;\n          end if;\n \n          --  Now rewrite as an if statement\n@@ -373,7 +403,7 @@ package body Exp_Prag is\n                Make_Procedure_Call_Statement (Loc,\n                  Name =>\n                    New_Reference_To (RTE (RE_Raise_Assert_Failure), Loc),\n-                 Parameter_Associations => New_List (Msg)))));\n+                 Parameter_Associations => New_List (Relocate_Node (Msg))))));\n       end if;\n \n       Analyze (N);"}, {"sha": "fc2bb6944455e87786c305d483036c4fb7926dd4", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/beacce027435fb068f0edcb0a0e094ab6630ff01/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/beacce027435fb068f0edcb0a0e094ab6630ff01/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=beacce027435fb068f0edcb0a0e094ab6630ff01", "patch": "@@ -4839,21 +4839,6 @@ package body Exp_Util is\n          return;\n       end if;\n \n-      --  No action needed for renamings of class-wide expressions because for\n-      --  class-wide types Remove_Side_Effects uses a renaming to capture the\n-      --  expression (and hence we would generate a never-ending loop in the\n-      --  front end).\n-\n-      --  For now, disable this test. class-wide renamings can have side\n-      --  effects, and this test causes such side effects to be duplicated.\n-      --  To be sorted out later ???\n-\n-      if False and then Is_Class_Wide_Type (Exp_Type)\n-        and then Nkind (Parent (Exp)) = N_Object_Renaming_Declaration\n-      then\n-         return;\n-      end if;\n-\n       --  All this must not have any checks\n \n       Scope_Suppress := (others => True);"}, {"sha": "930dda4c955113d4fa88ff9f621e3aa38051e3ba", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/beacce027435fb068f0edcb0a0e094ab6630ff01/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/beacce027435fb068f0edcb0a0e094ab6630ff01/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=beacce027435fb068f0edcb0a0e094ab6630ff01", "patch": "@@ -6158,14 +6158,17 @@ will be 64 (8 bytes).\n @cindex Postconditions\n @noindent\n The attribute Prefix'Old can be used within a\n-subprogram to refer to the value of the prefix on entry. So for\n+subprogram body or within a precondition or\n+postcondition pragma. The effect is to\n+refer to the value of the prefix on entry. So for\n example if you have an argument of a record type X called Arg1,\n you can refer to Arg1.Field'Old which yields the value of\n Arg1.Field on entry. The implementation simply involves generating\n an object declaration which captures the value on entry. Any\n prefix is allowed except one of a limited type (since limited\n-types cannot be copied to capture their values) or a local variable\n-(since it does not exist at subprogram entry time).\n+types cannot be copied to capture their values) or an expression\n+which references a local variable\n+(since local variables do not exist at subprogram entry time).\n \n The following example shows the use of 'Old to implement\n a test of a postcondition:"}, {"sha": "fc9eeee8caa4a397e323aa2c03ea9f3010634361", "filename": "gcc/ada/namet.adb", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/beacce027435fb068f0edcb0a0e094ab6630ff01/gcc%2Fada%2Fnamet.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/beacce027435fb068f0edcb0a0e094ab6630ff01/gcc%2Fada%2Fnamet.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnamet.adb?ref=beacce027435fb068f0edcb0a0e094ab6630ff01", "patch": "@@ -867,6 +867,19 @@ package body Namet is\n       null;\n    end Initialize;\n \n+   -------------------------------\n+   -- Insert_Str_In_Name_Buffer --\n+   -------------------------------\n+\n+   procedure Insert_Str_In_Name_Buffer (S : String; Index : Positive) is\n+      SL : constant Natural := S'Length;\n+   begin\n+      Name_Buffer (Index + SL .. Name_Len + SL) :=\n+        Name_Buffer (Index .. Name_Len);\n+      Name_Buffer (Index .. Index + SL - 1) := S;\n+      Name_Len := Name_Len + SL;\n+   end Insert_Str_In_Name_Buffer;\n+\n    ----------------------\n    -- Is_Internal_Name --\n    ----------------------"}, {"sha": "9d57220e59f5032a7de20cd20a4b9bf91b773024", "filename": "gcc/ada/namet.ads", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/beacce027435fb068f0edcb0a0e094ab6630ff01/gcc%2Fada%2Fnamet.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/beacce027435fb068f0edcb0a0e094ab6630ff01/gcc%2Fada%2Fnamet.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnamet.ads?ref=beacce027435fb068f0edcb0a0e094ab6630ff01", "patch": "@@ -350,6 +350,11 @@ package Namet is\n    --  Add characters of string S to the end of the string currently stored\n    --  in the Name_Buffer, incrementing Name_Len by the length of the string.\n \n+   procedure Insert_Str_In_Name_Buffer (S : String; Index : Positive);\n+   --  Inserts given string in name buffer, starting at Index. Any existing\n+   --  characters at or past this location get moved beyond the inserted string\n+   --  and Name_Len is incremented by the length of the string.\n+\n    procedure Set_Character_Literal_Name (C : Char_Code);\n    --  This procedure sets the proper encoded name for the character literal\n    --  for the given character code. On return Name_Buffer and Name_Len are"}, {"sha": "9a0b0cb33ce431fa18134375799f8a47ce176616", "filename": "gcc/ada/opt.ads", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/beacce027435fb068f0edcb0a0e094ab6630ff01/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/beacce027435fb068f0edcb0a0e094ab6630ff01/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=beacce027435fb068f0edcb0a0e094ab6630ff01", "patch": "@@ -729,6 +729,11 @@ package Opt is\n    --  Set to True to skip compile and bind steps (except when Bind_Only is\n    --  set to True).\n \n+   List_Inherited_Pre_Post : Boolean := True;\n+   --  GNAT\n+   --  List inherited preconditions and postconditions from Pre'Class and\n+   --  Post'Class aspects for ancestor subprograms.\n+\n    List_Restrictions : Boolean := False;\n    --  GNATBIND\n    --  Set to True to list restrictions pragmas that could apply to partition"}, {"sha": "c139cf963adc3db5b523ee9fa9a3e4b79ddacd82", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/beacce027435fb068f0edcb0a0e094ab6630ff01/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/beacce027435fb068f0edcb0a0e094ab6630ff01/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=beacce027435fb068f0edcb0a0e094ab6630ff01", "patch": "@@ -2877,6 +2877,8 @@ package body Sem_Ch12 is\n       End_Scope;\n       Exit_Generic_Scope (Id);\n       Generate_Reference_To_Formals (Id);\n+\n+      List_Inherited_Pre_Post_Aspects (Id);\n       Analyze_Aspect_Specifications (N, Id, Aspect_Specifications (N));\n    end Analyze_Generic_Subprogram_Declaration;\n "}, {"sha": "d23868de0cf4ac62842d220512e6b64f4839898c", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 72, "deletions": 27, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/beacce027435fb068f0edcb0a0e094ab6630ff01/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/beacce027435fb068f0edcb0a0e094ab6630ff01/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=beacce027435fb068f0edcb0a0e094ab6630ff01", "patch": "@@ -667,12 +667,14 @@ package body Sem_Ch13 is\n             Loc  : constant Source_Ptr := Sloc (Aspect);\n             Id   : constant Node_Id    := Identifier (Aspect);\n             Expr : constant Node_Id    := Expression (Aspect);\n-            Eloc :          Source_Ptr := Sloc (Expr);\n             Nam  : constant Name_Id    := Chars (Id);\n             A_Id : constant Aspect_Id  := Get_Aspect_Id (Nam);\n             Anod : Node_Id;\n             T    : Entity_Id;\n \n+            Eloc : Source_Ptr := Sloc (Expr);\n+            --  Source location of expression, modified when we split PPC's\n+\n          begin\n             Set_Entity (Aspect, E);\n             Ent := New_Occurrence_Of (E, Sloc (Id));\n@@ -688,8 +690,41 @@ package body Sem_Ch13 is\n                then\n                   Error_Msg_Name_1 := Nam;\n                   Error_Msg_Sloc := Sloc (Anod);\n-                  Error_Msg_NE\n-                    (\"aspect% for & ignored, already given at#\", Id, E);\n+\n+                  --  Case of same aspect specified twice\n+\n+                  if Class_Present (Anod) = Class_Present (Aspect) then\n+                     if not Class_Present (Anod) then\n+                        Error_Msg_NE\n+                          (\"aspect% for & previously given#\",\n+                           Id, E);\n+                     else\n+                        Error_Msg_NE\n+                          (\"aspect `%''Class` for & previously given#\",\n+                           Id, E);\n+                     end if;\n+\n+                  --  Case of Pre and Pre'Class both specified\n+\n+                  elsif Nam = Name_Pre then\n+                     if Class_Present (Aspect) then\n+                        Error_Msg_NE\n+                          (\"aspect `Pre''Class` for & is not allowed here\",\n+                           Id, E);\n+                        Error_Msg_NE\n+                          (\"\\since aspect `Pre` previously given#\",\n+                           Id, E);\n+\n+                     else\n+                        Error_Msg_NE\n+                          (\"aspect `Pre` for & is not allowed here\",\n+                           Id, E);\n+                        Error_Msg_NE\n+                          (\"\\since aspect `Pre''Class` previously given#\",\n+                           Id, E);\n+                     end if;\n+                  end if;\n+\n                   goto Continue;\n                end if;\n \n@@ -872,7 +907,6 @@ package body Sem_Ch13 is\n \n                when Aspect_Pre | Aspect_Post => declare\n                   Pname : Name_Id;\n-                  Msg   : Node_Id;\n \n                begin\n                   if A_Id = Aspect_Pre then\n@@ -886,40 +920,51 @@ package body Sem_Ch13 is\n                   --  clauses. Since we allow multiple pragmas, there is no\n                   --  problem in allowing multiple Pre/Post aspects internally.\n \n-                  while Nkind (Expr) = N_And_Then loop\n-                     Insert_After (Aspect,\n-                       Make_Aspect_Specification (Sloc (Right_Opnd (Expr)),\n-                         Identifier    => Identifier (Aspect),\n-                         Expression    => Relocate_Node (Right_Opnd (Expr)),\n-                         Class_Present => Class_Present (Aspect)));\n-                     Rewrite (Expr, Relocate_Node (Left_Opnd (Expr)));\n-                     Eloc := Sloc (Expr);\n-                  end loop;\n-\n-                  --  Proceed with handling what's left after this split up\n+                  --  We do not do this for Pre'Class, since we have to put\n+                  --  these conditions together in a complex OR expression\n \n-                  Msg :=\n-                    Make_String_Literal (Eloc,\n-                      Strval => \"failed \"\n-                                  & Get_Name_String (Pname)\n-                                  & \" from line \"\n-                                  & Get_Logical_Line_Number_Img (Eloc));\n+                  if Pname = Name_Postcondition\n+                       or else not Class_Present (Aspect)\n+                  then\n+                     while Nkind (Expr) = N_And_Then loop\n+                        Insert_After (Aspect,\n+                          Make_Aspect_Specification (Sloc (Right_Opnd (Expr)),\n+                            Identifier    => Identifier (Aspect),\n+                            Expression    => Relocate_Node (Right_Opnd (Expr)),\n+                            Class_Present => Class_Present (Aspect),\n+                            Split_PPC     => True));\n+                        Rewrite (Expr, Relocate_Node (Left_Opnd (Expr)));\n+                        Eloc := Sloc (Expr);\n+                     end loop;\n+                  end if;\n \n-                  --  Construct the pragma\n+                  --  Build the precondition/postcondition pragma\n \n                   Aitem :=\n                     Make_Pragma (Loc,\n                       Pragma_Identifier            =>\n                         Make_Identifier (Sloc (Id),\n                           Chars => Pname),\n                       Class_Present                => Class_Present (Aspect),\n+                      Split_PPC                    => Split_PPC (Aspect),\n                       Pragma_Argument_Associations => New_List (\n                         Make_Pragma_Argument_Association (Eloc,\n                           Chars      => Name_Check,\n-                          Expression => Relocate_Node (Expr)),\n-                        Make_Pragma_Argument_Association (Eloc,\n-                          Chars      => Name_Message,\n-                          Expression => Msg)));\n+                          Expression => Relocate_Node (Expr))));\n+\n+                  --  Add message unless exception messages are suppressed\n+\n+                  if not Opt.Exception_Locations_Suppressed then\n+                     Append_To (Pragma_Argument_Associations (Aitem),\n+                       Make_Pragma_Argument_Association (Eloc,\n+                         Chars     => Name_Message,\n+                         Expression =>\n+                           Make_String_Literal (Eloc,\n+                             Strval => \"failed \"\n+                                       & Get_Name_String (Pname)\n+                                       & \" from \"\n+                                       & Build_Location_String (Eloc))));\n+                  end if;\n \n                   Set_From_Aspect_Specification (Aitem, True);\n \n@@ -1213,7 +1258,7 @@ package body Sem_Ch13 is\n             if Entity (A) = U_Ent then\n                Error_Msg_Name_1 := Chars (N);\n                Error_Msg_Sloc := Sloc (A);\n-               Error_Msg_NE (\"aspect% for & previously specified#\", N, U_Ent);\n+               Error_Msg_NE (\"aspect% for & previously given#\", N, U_Ent);\n                return True;\n             end if;\n          end if;"}, {"sha": "befcb1614b8f6c4a8f608e7066c34110af806f51", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 181, "deletions": 37, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/beacce027435fb068f0edcb0a0e094ab6630ff01/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/beacce027435fb068f0edcb0a0e094ab6630ff01/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=beacce027435fb068f0edcb0a0e094ab6630ff01", "patch": "@@ -2766,7 +2766,7 @@ package body Sem_Ch6 is\n          end if;\n       end if;\n \n-      Designator :=  Analyze_Subprogram_Specification (Specification (N));\n+      Designator := Analyze_Subprogram_Specification (Specification (N));\n       Generate_Definition (Designator);\n \n       if Debug_Flag_C then\n@@ -2916,6 +2916,7 @@ package body Sem_Ch6 is\n          Write_Eol;\n       end if;\n \n+      List_Inherited_Pre_Post_Aspects (Designator);\n       Analyze_Aspect_Specifications (N, Designator, Aspect_Specifications (N));\n    end Analyze_Subprogram_Declaration;\n \n@@ -6937,6 +6938,43 @@ package body Sem_Ch6 is\n       end if;\n    end Is_Non_Overriding_Operation;\n \n+   -------------------------------------\n+   -- List_Inherited_Pre_Post_Aspects --\n+   -------------------------------------\n+\n+   procedure List_Inherited_Pre_Post_Aspects (E : Entity_Id) is\n+   begin\n+      if Opt.List_Inherited_Pre_Post\n+        and then (Is_Subprogram (E) or else Is_Generic_Subprogram (E))\n+      then\n+         declare\n+            Inherited : constant Subprogram_List :=\n+                          Inherited_Subprograms (E);\n+            P         : Node_Id;\n+\n+         begin\n+            for J in Inherited'Range loop\n+               P := Spec_PPC_List (Inherited (J));\n+               while Present (P) loop\n+                  Error_Msg_Sloc := Sloc (P);\n+\n+                  if Class_Present (P) and then not Split_PPC (P) then\n+                     if Pragma_Name (P) = Name_Precondition then\n+                        Error_Msg_N\n+                          (\"?info: & inherits `Pre''Class` aspect from #\", E);\n+                     else\n+                        Error_Msg_N\n+                          (\"?info: & inherits `Post''Class` aspect from #\", E);\n+                     end if;\n+                  end if;\n+\n+                  P := Next_Pragma (P);\n+               end loop;\n+            end loop;\n+         end;\n+      end if;\n+   end List_Inherited_Pre_Post_Aspects;\n+\n    ------------------------------\n    -- Make_Inequality_Operator --\n    ------------------------------\n@@ -8586,11 +8624,25 @@ package body Sem_Ch6 is\n       Body_Id : Entity_Id)\n    is\n       Loc   : constant Source_Ptr := Sloc (N);\n-      Plist : List_Id             := No_List;\n       Prag  : Node_Id;\n       Subp  : Entity_Id;\n       Parms : List_Id;\n \n+      Precond : Node_Id := Empty;\n+      --  Set non-Empty if we prepend precondition to the declarations. This\n+      --  is used to hook up inherited preconditions (adding the condition\n+      --  expression with OR ELSE, and adding the message).\n+\n+      Inherited_Precond : Node_Id;\n+      --  Precondition inherited from parent subprogram\n+\n+      Inherited : constant Subprogram_List :=\n+                    Inherited_Subprograms (Spec_Id);\n+      --  List of subprograms inherited by this subprogram, null if no Spec_Id\n+\n+      Plist : List_Id := No_List;\n+      --  List of generated postconditions\n+\n       function Grab_PPC (Pspec : Entity_Id := Empty) return Node_Id;\n       --  Prag contains an analyzed precondition or postcondition pragma. This\n       --  function copies the pragma, changes it to the corresponding Check\n@@ -8665,19 +8717,26 @@ package body Sem_Ch6 is\n            Make_Identifier (Sloc (Prag),\n              Chars => Name_Check));\n \n-         --  If this is inherited case then the current message starts with\n-         --  \"failed p\" and we change this to \"failed inherited p\".\n+         --  If this is inherited case and the current message starts with\n+         --  \"failed p\", we change it to \"failed inherited p...\".\n \n          if Present (Pspec) then\n-            String_To_Name_Buffer\n-              (Strval (Expression (Last (Pragma_Argument_Associations (CP)))));\n-            pragma Assert (Name_Buffer (1 .. 8) = \"failed p\");\n-            Name_Len := Name_Len + 10;\n-            Name_Buffer (17 .. Name_Len) := Name_Buffer (7 .. Name_Len - 10);\n-            Name_Buffer (7 .. 16) := \" inherited\";\n-            Set_Strval\n-              (Expression (Last (Pragma_Argument_Associations (CP))),\n-               String_From_Name_Buffer);\n+            declare\n+               Msg : constant Node_Id :=\n+                       Last (Pragma_Argument_Associations (CP));\n+\n+            begin\n+               if Chars (Msg) = Name_Message then\n+                  String_To_Name_Buffer (Strval (Expression (Msg)));\n+\n+                  if Name_Buffer (1 .. 8) = \"failed p\" then\n+                     Insert_Str_In_Name_Buffer (\"inherited \", 8);\n+                     Set_Strval\n+                       (Expression (Last (Pragma_Argument_Associations (CP))),\n+                        String_From_Name_Buffer);\n+                  end if;\n+               end if;\n+            end;\n          end if;\n \n          --  Return the check pragma\n@@ -8688,12 +8747,6 @@ package body Sem_Ch6 is\n    --  Start of processing for Process_PPCs\n \n    begin\n-      --  Nothing to do if we are not generating code\n-\n-      if Operating_Mode /= Generate_Code then\n-         return;\n-      end if;\n-\n       --  Grab preconditions from spec\n \n       if Present (Spec_Id) then\n@@ -8707,16 +8760,115 @@ package body Sem_Ch6 is\n             if Pragma_Name (Prag) = Name_Precondition\n               and then Pragma_Enabled (Prag)\n             then\n-               --  Add pragma Check at the start of the declarations of N.\n-               --  Note that this processing reverses the order of the list,\n-               --  which is what we want since new entries were chained to\n-               --  the head of the list.\n-\n-               Prepend (Grab_PPC, Declarations (N));\n+               --  For Pre (or Precondition pragma), we simply prepend the\n+               --  pragma to the list of declarations right away so that it\n+               --  will be executed at the start of the procedure. Note that\n+               --  this processing reverses the order of the list, which is\n+               --  what we want since new entries were chained to the head of\n+               --  the list. There can be more then one precondition when we\n+               --  use pragma Precondition\n+\n+               if not Class_Present (Prag) then\n+                  Prepend (Grab_PPC, Declarations (N));\n+\n+               --  For Pre'Class there can only be one pragma, and we save\n+               --  it in Precond for now. We will add inherited Pre'Class\n+               --  stuff before inserting this pragma in the declarations.\n+               else\n+                  Precond := Grab_PPC;\n+               end if;\n             end if;\n \n             Prag := Next_Pragma (Prag);\n          end loop;\n+\n+         --  Now deal with inherited preconditions\n+\n+         for J in Inherited'Range loop\n+            Prag := Spec_PPC_List (Inherited (J));\n+\n+            while Present (Prag) loop\n+               if Pragma_Name (Prag) = Name_Precondition\n+                 and then Class_Present (Prag)\n+               then\n+                  Inherited_Precond := Grab_PPC;\n+\n+                  --  No precondition so far, so establish this as the first\n+\n+                  if No (Precond) then\n+                     Precond := Inherited_Precond;\n+\n+                  --  Here we already have a precondition, add inherited one\n+\n+                  else\n+                     --  Add new precondition to old one using OR ELSE\n+\n+                     declare\n+                        New_Expr : constant Node_Id :=\n+                                     Get_Pragma_Arg\n+                                       (Next\n+                                         (First\n+                                           (Pragma_Argument_Associations\n+                                             (Inherited_Precond))));\n+                        Old_Expr : constant Node_Id :=\n+                                     Get_Pragma_Arg\n+                                       (Next\n+                                         (First\n+                                           (Pragma_Argument_Associations\n+                                             (Precond))));\n+\n+                     begin\n+                        if Paren_Count (Old_Expr) = 0 then\n+                           Set_Paren_Count (Old_Expr, 1);\n+                        end if;\n+\n+                        if Paren_Count (New_Expr) = 0 then\n+                           Set_Paren_Count (New_Expr, 1);\n+                        end if;\n+\n+                        Rewrite (Old_Expr,\n+                          Make_Or_Else (Sloc (Old_Expr),\n+                            Left_Opnd  => Relocate_Node (Old_Expr),\n+                            Right_Opnd => New_Expr));\n+                     end;\n+\n+                     --  Add new message in the form:\n+\n+                     --     failed precondition from bla\n+                     --       also failed inherited precondition from bla\n+                     --       ...\n+\n+                     declare\n+                        New_Msg : constant Node_Id :=\n+                                    Get_Pragma_Arg\n+                                      (Last\n+                                        (Pragma_Argument_Associations\n+                                          (Inherited_Precond)));\n+                        Old_Msg : constant Node_Id :=\n+                                    Get_Pragma_Arg\n+                                      (Last\n+                                        (Pragma_Argument_Associations\n+                                          (Precond)));\n+                     begin\n+                        Start_String (Strval (Old_Msg));\n+                        Store_String_Chars (ASCII.LF & \"  also \");\n+                        Store_String_Chars (Strval (New_Msg));\n+                        Set_Strval (Old_Msg, End_String);\n+                     end;\n+                  end if;\n+               end if;\n+\n+               Prag := Next_Pragma (Prag);\n+            end loop;\n+         end loop;\n+\n+         --  If we have built a precondition for Pre'Class (including any\n+         --  Pre'Class aspects inherited from parent subprograms), then we\n+         --  insert this composite precondition at this stage.\n+\n+         if Present (Precond) then\n+            Prepend (Precond, Declarations (N));\n+         end if;\n       end if;\n \n       --  Build postconditions procedure if needed and prepend the following\n@@ -8779,8 +8931,6 @@ package body Sem_Ch6 is\n \n       if Present (Spec_Id) then\n          declare\n-            Parent_Op : Node_Id;\n-\n             procedure Process_Post_Conditions\n               (Spec  : Node_Id;\n                Class : Boolean);\n@@ -8836,17 +8986,11 @@ package body Sem_Ch6 is\n                Process_Post_Conditions (Spec_Id, Class => False);\n             end if;\n \n-            --  Process directly inherited specifications\n+            --  Process inherited postconditions\n \n-            Parent_Op := Spec_Id;\n-            loop\n-               Parent_Op := Overridden_Operation (Parent_Op);\n-               exit when No (Parent_Op);\n-\n-               if Ekind (Parent_Op) /= E_Enumeration_Literal\n-                 and then Present (Spec_PPC_List (Parent_Op))\n-               then\n-                  Process_Post_Conditions (Parent_Op, Class => True);\n+            for J in Inherited'Range loop\n+               if Present (Spec_PPC_List (Inherited (J))) then\n+                  Process_Post_Conditions (Inherited (J), Class => True);\n                end if;\n             end loop;\n          end;"}, {"sha": "4041f3799cbda265707f43b00dcf7b2fb031b27c", "filename": "gcc/ada/sem_ch6.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/beacce027435fb068f0edcb0a0e094ab6630ff01/gcc%2Fada%2Fsem_ch6.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/beacce027435fb068f0edcb0a0e094ab6630ff01/gcc%2Fada%2Fsem_ch6.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.ads?ref=beacce027435fb068f0edcb0a0e094ab6630ff01", "patch": "@@ -190,6 +190,10 @@ package Sem_Ch6 is\n    --  conformant, and Prim is defined in the scope of Tagged_Type. Special\n    --  management is done for functions returning interfaces.\n \n+   procedure List_Inherited_Pre_Post_Aspects (E : Entity_Id);\n+   --  E is the entity for a subprogram or generic subprogram spec. This call\n+   --  lists all inherited Pre/Post aspects if List_Inherited_Pre_Post is True.\n+\n    function Mode_Conformant (New_Id, Old_Id : Entity_Id) return Boolean;\n    --  Determine whether two callable entities (subprograms, entries,\n    --  literals) are mode conformant (RM 6.3.1(15))"}, {"sha": "c7afc3fc5a7bf1645a4b84ae1cdf8b4efb14b9ca", "filename": "gcc/ada/sem_disp.adb", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/beacce027435fb068f0edcb0a0e094ab6630ff01/gcc%2Fada%2Fsem_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/beacce027435fb068f0edcb0a0e094ab6630ff01/gcc%2Fada%2Fsem_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_disp.adb?ref=beacce027435fb068f0edcb0a0e094ab6630ff01", "patch": "@@ -1726,6 +1726,47 @@ package body Sem_Disp is\n       return Empty;\n    end Find_Primitive_Covering_Interface;\n \n+   ---------------------------\n+   -- Inherited_Subprograms --\n+   ---------------------------\n+\n+   function Inherited_Subprograms (S : Entity_Id) return Subprogram_List is\n+      Result : Subprogram_List (1 .. 6000);\n+      --  6000 here is intended to be infinity. We could use an expandable\n+      --  table, but it would be awfully heavy, and there is no way that we\n+      --  could reasonably exceed this value.\n+\n+      N : Int := 0;\n+      --  Number of entries in Result\n+\n+      Parent_Op : Entity_Id;\n+      --  Traverses the Overridden_Operation chain\n+\n+   begin\n+      if Present (S) then\n+\n+         --  Deal with direct inheritance\n+\n+         Parent_Op := S;\n+         loop\n+            Parent_Op := Overridden_Operation (Parent_Op);\n+            exit when No (Parent_Op);\n+\n+            if Is_Subprogram (Parent_Op)\n+              or else Is_Generic_Subprogram (Parent_Op)\n+            then\n+               N := N + 1;\n+               Result (N) := Parent_Op;\n+            end if;\n+         end loop;\n+\n+         --  For now don't bother with interfaces, TBD ???\n+\n+      end if;\n+\n+      return Result (1 .. N);\n+   end Inherited_Subprograms;\n+\n    ---------------------------\n    -- Is_Dynamically_Tagged --\n    ---------------------------"}, {"sha": "ddd7a89c72b8fa31acd23672e4df928bccce898c", "filename": "gcc/ada/sem_disp.ads", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/beacce027435fb068f0edcb0a0e094ab6630ff01/gcc%2Fada%2Fsem_disp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/beacce027435fb068f0edcb0a0e094ab6630ff01/gcc%2Fada%2Fsem_disp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_disp.ads?ref=beacce027435fb068f0edcb0a0e094ab6630ff01", "patch": "@@ -93,6 +93,17 @@ package Sem_Disp is\n    --  whose alias attribute references the interface primitive). If none of\n    --  these entities is found then return Empty.\n \n+   type Subprogram_List is array (Nat range <>) of Entity_Id;\n+   --  Type returned by Inherited_Subprograms function\n+\n+   function Inherited_Subprograms (S : Entity_Id) return Subprogram_List;\n+   --  Given the spec of a subprogram, this function gathers any inherited\n+   --  subprograms from direct inheritance or via interfaces. The list is\n+   --  a list of entity id's of the specs of inherited subprograms. Returns\n+   --  a null array if passed an Empty spec id. Note that the returned array\n+   --  only includes subprograms and generic subprograms (and excludes any\n+   --  other inherited entities, in particular enumeration literals).\n+\n    function Is_Dynamically_Tagged (N : Node_Id) return Boolean;\n    --  Used to determine whether a call is dispatching, i.e. if is an\n    --  an expression of a class_Wide type, or a call to a function with"}, {"sha": "33cfe01fb69b80b7f01d852628c0cfb17bff5c31", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 56, "deletions": 33, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/beacce027435fb068f0edcb0a0e094ab6630ff01/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/beacce027435fb068f0edcb0a0e094ab6630ff01/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=beacce027435fb068f0edcb0a0e094ab6630ff01", "patch": "@@ -58,6 +58,7 @@ with Sem_Ch6;  use Sem_Ch6;\n with Sem_Ch8;  use Sem_Ch8;\n with Sem_Ch12; use Sem_Ch12;\n with Sem_Ch13; use Sem_Ch13;\n+with Sem_Disp; use Sem_Disp;\n with Sem_Dist; use Sem_Dist;\n with Sem_Elim; use Sem_Elim;\n with Sem_Eval; use Sem_Eval;\n@@ -90,10 +91,9 @@ package body Sem_Prag is\n    -- Common Handling of Import-Export Pragmas --\n    ----------------------------------------------\n \n-   --  In the following section, a number of Import_xxx and Export_xxx\n-   --  pragmas are defined by GNAT. These are compatible with the DEC\n-   --  pragmas of the same name, and all have the following common\n-   --  form and processing:\n+   --  In the following section, a number of Import_xxx and Export_xxx pragmas\n+   --  are defined by GNAT. These are compatible with the DEC pragmas of the\n+   --  same name, and all have the following common form and processing:\n \n    --  pragma Export_xxx\n    --        [Internal                 =>] LOCAL_NAME\n@@ -1247,7 +1247,7 @@ package body Sem_Prag is\n             if Nkind (P) = N_Aspect_Specification\n               or else From_Aspect_Specification (P)\n             then\n-               Error_Msg_NE (\"aspect% for & previously specified#\", N, E);\n+               Error_Msg_NE (\"aspect% for & previously given#\", N, E);\n             else\n                Error_Msg_NE (\"pragma% for & duplicates pragma#\", N, E);\n             end if;\n@@ -1529,33 +1529,58 @@ package body Sem_Prag is\n \n             S := Defining_Unit_Name (Specification (PO));\n \n-            --  Make sure we do not have the case of a pre/postcondition\n-            --  pragma when the corresponding aspect is present. This is\n-            --  never allowed. We allow either pragmas or aspects, not both.\n+            --  Make sure we do not have the case of a precondition pragma when\n+            --  the Pre'Class aspect is present.\n \n             --  We do this by looking at pragmas already chained to the entity\n             --  since the aspect derived pragma will be put on this list first.\n \n-            if not From_Aspect_Specification (N) then\n-               P := Spec_PPC_List (S);\n-               while Present (P) loop\n-                  if Pragma_Name (P) = Pragma_Name (N)\n-                    and then From_Aspect_Specification (P)\n-                  then\n-                     Error_Msg_Sloc := Sloc (P);\n-\n-                     if Prag_Id = Pragma_Precondition then\n-                        Error_Msg_Name_2 := Name_Pre;\n-                     else\n-                        Error_Msg_Name_2 := Name_Post;\n+            if Pragma_Name (N) = Name_Precondition then\n+               if not From_Aspect_Specification (N) then\n+                  P := Spec_PPC_List (S);\n+                  while Present (P) loop\n+                     if Pragma_Name (P) = Name_Precondition\n+                       and then From_Aspect_Specification (P)\n+                       and then Class_Present (P)\n+                     then\n+                        Error_Msg_Sloc := Sloc (P);\n+                        Error_Pragma\n+                          (\"pragma% not allowed, `Pre''Class` aspect given#\");\n                      end if;\n \n-                     Error_Pragma\n-                       (\"pragma% not allowed, % aspect given#\");\n-                  end if;\n+                     P := Next_Pragma (P);\n+                  end loop;\n+               end if;\n+            end if;\n \n-                  P := Next_Pragma (P);\n-               end loop;\n+            --  Similarly check for Pre with inherited Pre'Class. Note that\n+            --  we cover the aspect case as well here.\n+\n+            if Pragma_Name (N) = Name_Precondition\n+              and then not Class_Present (N)\n+            then\n+               declare\n+                  Inherited : constant Subprogram_List :=\n+                                Inherited_Subprograms (S);\n+                  P         : Node_Id;\n+\n+               begin\n+                  for J in Inherited'Range loop\n+                     P := Spec_PPC_List (Inherited (J));\n+                     while Present (P) loop\n+                        if Pragma_Name (P) = Name_Precondition\n+                          and then Class_Present (P)\n+                        then\n+                           Error_Msg_Sloc := Sloc (P);\n+                           Error_Pragma\n+                             (\"pragma% not allowed, `Pre''Class` \"\n+                              & \"aspect inherited from#\");\n+                        end if;\n+\n+                        P := Next_Pragma (P);\n+                     end loop;\n+                  end loop;\n+               end;\n             end if;\n \n             --  Analyze the pragma unless it appears within a package spec,\n@@ -1645,9 +1670,7 @@ package body Sem_Prag is\n             if Operating_Mode /= Generate_Code\n               or else Inside_A_Generic\n             then\n-\n-               --  Analyze expression in pragma, for correctness\n-               --  and for ASIS use.\n+               --  Analyze pragma expression for correctness and for ASIS use\n \n                Preanalyze_Spec_Expression\n                  (Get_Pragma_Arg (Arg1), Standard_Boolean);\n@@ -3639,7 +3662,7 @@ package body Sem_Prag is\n                               Set_Mechanism_Value\n                                 (Formal, Expression (Massoc));\n \n-                              --  Set entity on identifier for ASIS\n+                              --  Set entity on identifier (needed by ASIS)\n \n                               Set_Entity (Choice, Formal);\n \n@@ -3814,15 +3837,15 @@ package body Sem_Prag is\n          elsif Is_Subprogram (Def_Id)\n            or else Is_Generic_Subprogram (Def_Id)\n          then\n-            --  If the name is overloaded, pragma applies to all of the\n-            --  denoted entities in the same declarative part.\n+            --  If the name is overloaded, pragma applies to all of the denoted\n+            --  entities in the same declarative part.\n \n             Hom_Id := Def_Id;\n             while Present (Hom_Id) loop\n                Def_Id := Get_Base_Subprogram (Hom_Id);\n \n-               --  Ignore inherited subprograms because the pragma will\n-               --  apply to the parent operation, which is the one called.\n+               --  Ignore inherited subprograms because the pragma will apply\n+               --  to the parent operation, which is the one called.\n \n                if Is_Overloadable (Def_Id)\n                  and then Present (Alias (Def_Id))"}, {"sha": "782e67773d0353688bddfab501cc9609e9bb1b47", "filename": "gcc/ada/sem_warn.adb", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/beacce027435fb068f0edcb0a0e094ab6630ff01/gcc%2Fada%2Fsem_warn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/beacce027435fb068f0edcb0a0e094ab6630ff01/gcc%2Fada%2Fsem_warn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_warn.adb?ref=beacce027435fb068f0edcb0a0e094ab6630ff01", "patch": "@@ -3068,6 +3068,7 @@ package body Sem_Warn is\n             Elab_Warnings                       := True;\n             Implementation_Unit_Warnings        := True;\n             Ineffective_Inline_Warnings         := True;\n+            List_Inherited_Pre_Post             := True;\n             Warn_On_Ada_2005_Compatibility      := True;\n             Warn_On_Ada_2012_Compatibility      := True;\n             Warn_On_All_Unread_Out_Parameters   := True;\n@@ -3113,6 +3114,12 @@ package body Sem_Warn is\n          when 'I' =>\n             Warn_On_Overlap                     := False;\n \n+         when 'l' =>\n+            List_Inherited_Pre_Post             := True;\n+\n+         when 'L' =>\n+            List_Inherited_Pre_Post             := False;\n+\n          when 'm' =>\n             Warn_On_Suspicious_Modulus_Value    := True;\n \n@@ -3189,6 +3196,7 @@ package body Sem_Warn is\n       Elab_Warnings                       := False;\n       Implementation_Unit_Warnings        := False;\n       Ineffective_Inline_Warnings         := True;\n+      List_Inherited_Pre_Post             := False;\n       Warn_On_Ada_2005_Compatibility      := True;\n       Warn_On_Ada_2012_Compatibility      := True;\n       Warn_On_All_Unread_Out_Parameters   := False;\n@@ -3231,6 +3239,7 @@ package body Sem_Warn is\n             Constant_Condition_Warnings         := True;\n             Implementation_Unit_Warnings        := True;\n             Ineffective_Inline_Warnings         := True;\n+            List_Inherited_Pre_Post             := True;\n             Warn_On_Ada_2005_Compatibility      := True;\n             Warn_On_Ada_2012_Compatibility      := True;\n             Warn_On_Assertion_Failure           := True;\n@@ -3261,6 +3270,7 @@ package body Sem_Warn is\n             Elab_Warnings                       := False;\n             Implementation_Unit_Warnings        := False;\n             Ineffective_Inline_Warnings         := False;\n+            List_Inherited_Pre_Post             := False;\n             Warn_On_Ada_2005_Compatibility      := False;\n             Warn_On_Ada_2012_Compatibility      := False;\n             Warn_On_All_Unread_Out_Parameters   := False;"}, {"sha": "b75139f59a6bd90c4b66d39ceb6c226e9bf3ead5", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/beacce027435fb068f0edcb0a0e094ab6630ff01/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/beacce027435fb068f0edcb0a0e094ab6630ff01/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=beacce027435fb068f0edcb0a0e094ab6630ff01", "patch": "@@ -2745,6 +2745,15 @@ package body Sinfo is\n       return Node1 (N);\n    end Specification;\n \n+   function Split_PPC\n+      (N : Node_Id) return Boolean is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Aspect_Specification\n+        or else NT (N).Nkind = N_Pragma);\n+      return Flag17 (N);\n+   end Split_PPC;\n+\n    function Statements\n       (N : Node_Id) return List_Id is\n    begin\n@@ -5706,6 +5715,15 @@ package body Sinfo is\n       Set_Node1_With_Parent (N, Val);\n    end Set_Specification;\n \n+   procedure Set_Split_PPC\n+      (N : Node_Id; Val : Boolean) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Aspect_Specification\n+        or else NT (N).Nkind = N_Pragma);\n+      Set_Flag17 (N, Val);\n+   end Set_Split_PPC;\n+\n    procedure Set_Statements\n       (N : Node_Id; Val : List_Id) is\n    begin"}, {"sha": "aa0dfe37a28eb23e98adf082a6fb1fa76f01922d", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/beacce027435fb068f0edcb0a0e094ab6630ff01/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/beacce027435fb068f0edcb0a0e094ab6630ff01/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=beacce027435fb068f0edcb0a0e094ab6630ff01", "patch": "@@ -1689,6 +1689,14 @@ package Sinfo is\n    --    source type entity for the unchecked conversion instantiation\n    --    which gigi must do size validation for.\n \n+   --  Split_PPC (Flag17)\n+   --     When a Pre or Postaspect specification is processed, it is broken\n+   --     into AND THEN sections. The left most section has Split_PPC set to\n+   --     False, indicating that it is the original specification (e.g. for\n+   --     posting errors). For other sections, Split_PPC is set to True.\n+   --     This flag is set in both the N_Aspect_Specification node itself,\n+   --     and in the pragma which is generated from this node.\n+\n    --  Static_Processing_OK (Flag4-Sem)\n    --    Present in N_Aggregate nodes. When the Compile_Time_Known_Aggregate\n    --    flag is set, the full value of the aggregate can be determined at\n@@ -2037,7 +2045,8 @@ package Sinfo is\n       --  Is_Delayed_Aspect (Flag14-Sem)\n       --  Import_Interface_Present (Flag16-Sem)\n       --  Aspect_Cancel (Flag11-Sem)\n-      --  Class_Present (Flag6) (set False if not from Aspect with 'Class)\n+      --  Split_PPC (Flag17) set if corresponding aspect had Split_PPC set\n+      --  Class_Present (Flag6) set if from Aspect with 'Class\n \n       --  Note: we should have a section on what pragmas are passed on to\n       --  the back end to be processed. This section should note that pragma\n@@ -6442,9 +6451,15 @@ package Sinfo is\n       --  Entity (Node4-Sem) entity to which the aspect applies\n       --  Class_Present (Flag6) Set if 'Class present\n       --  Next_Rep_Item (Node5-Sem)\n+      --  Split_PPC (Flag17) Set if split pre/post attribute\n \n       --  Note: Aspect_Specification is an Ada 2012 feature\n \n+      --  Note: When a Pre or Post aspect specification is processed, it is\n+      --  broken into AND THEN sections. The left most section has Split_PPC\n+      --  set to False, indicating that it is the original specification (e.g.\n+      --  for posting errors). For the other sections, Split_PPC is set True.\n+\n       ---------------------------------------------\n       -- 13.4  Enumeration representation clause --\n       ---------------------------------------------\n@@ -8709,6 +8724,9 @@ package Sinfo is\n    function Specification\n      (N : Node_Id) return Node_Id;    -- Node1\n \n+   function Split_PPC\n+     (N : Node_Id) return Boolean;    -- Flag17\n+\n    function Statements\n      (N : Node_Id) return List_Id;    -- List3\n \n@@ -9654,6 +9672,9 @@ package Sinfo is\n    procedure Set_Specification\n      (N : Node_Id; Val : Node_Id);            -- Node1\n \n+   procedure Set_Split_PPC\n+     (N : Node_Id; Val : Boolean);            -- Flag17\n+\n    procedure Set_Statements\n      (N : Node_Id; Val : List_Id);            -- List3\n \n@@ -11744,6 +11765,7 @@ package Sinfo is\n    pragma Inline (Shift_Count_OK);\n    pragma Inline (Source_Type);\n    pragma Inline (Specification);\n+   pragma Inline (Split_PPC);\n    pragma Inline (Statements);\n    pragma Inline (Static_Processing_OK);\n    pragma Inline (Storage_Pool);\n@@ -12055,6 +12077,7 @@ package Sinfo is\n    pragma Inline (Set_Shift_Count_OK);\n    pragma Inline (Set_Source_Type);\n    pragma Inline (Set_Specification);\n+   pragma Inline (Set_Split_PPC);\n    pragma Inline (Set_Statements);\n    pragma Inline (Set_Static_Processing_OK);\n    pragma Inline (Set_Storage_Pool);"}, {"sha": "6d0be93a571018cbcef2e7254f6c745b8064b6f6", "filename": "gcc/ada/sinput.adb", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/beacce027435fb068f0edcb0a0e094ab6630ff01/gcc%2Fada%2Fsinput.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/beacce027435fb068f0edcb0a0e094ab6630ff01/gcc%2Fada%2Fsinput.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinput.adb?ref=beacce027435fb068f0edcb0a0e094ab6630ff01", "patch": "@@ -238,6 +238,13 @@ package body Sinput is\n       return;\n    end Build_Location_String;\n \n+   function Build_Location_String (Loc : Source_Ptr) return String is\n+   begin\n+      Name_Len := 0;\n+      Build_Location_String (Loc);\n+      return Name_Buffer (1 .. Name_Len);\n+   end Build_Location_String;\n+\n    -----------------------\n    -- Get_Column_Number --\n    -----------------------"}, {"sha": "bdc268eaf0f2fd409f1e377a9f9c8a158d59d06c", "filename": "gcc/ada/sinput.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/beacce027435fb068f0edcb0a0e094ab6630ff01/gcc%2Fada%2Fsinput.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/beacce027435fb068f0edcb0a0e094ab6630ff01/gcc%2Fada%2Fsinput.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinput.ads?ref=beacce027435fb068f0edcb0a0e094ab6630ff01", "patch": "@@ -471,6 +471,10 @@ package Sinput is\n    --  ASCII.NUL, with Name_Length indicating the length not including the\n    --  terminating Nul.\n \n+   function Build_Location_String (Loc : Source_Ptr) return String;\n+   --  Functional form returning a string, which does not include a terminating\n+   --  null character. The contents of Name_Buffer is destroyed.\n+\n    function Get_Column_Number (P : Source_Ptr) return Column_Number;\n    --  The ones-origin column number of the specified Source_Ptr value is\n    --  determined and returned. Tab characters if present are assumed to"}, {"sha": "6ad0ef509be6a16f9e6b390f380c736aef1558ed", "filename": "gcc/ada/usage.adb", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/beacce027435fb068f0edcb0a0e094ab6630ff01/gcc%2Fada%2Fusage.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/beacce027435fb068f0edcb0a0e094ab6630ff01/gcc%2Fada%2Fusage.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fusage.adb?ref=beacce027435fb068f0edcb0a0e094ab6630ff01", "patch": "@@ -438,6 +438,10 @@ begin\n                                                   \"elaboration pragma\");\n    Write_Line (\"        L*   turn off warnings for missing \" &\n                                                   \"elaboration pragma\");\n+   Write_Line (\"        .l*  turn on info messages for inherited pre/\" &\n+                                                  \"postconditions\");\n+   Write_Line (\"        .L   turn off info messages for inherited pre/\" &\n+                                                  \"postconditions\");\n    Write_Line (\"        m+   turn on warnings for variable assigned \" &\n                                                   \"but not read\");\n    Write_Line (\"        M*   turn off warnings for variable assigned \" &"}, {"sha": "021db06e5df95688bbbad72b1aa6181cfd968ba4", "filename": "gcc/ada/xref_lib.adb", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/beacce027435fb068f0edcb0a0e094ab6630ff01/gcc%2Fada%2Fxref_lib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/beacce027435fb068f0edcb0a0e094ab6630ff01/gcc%2Fada%2Fxref_lib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fxref_lib.adb?ref=beacce027435fb068f0edcb0a0e094ab6630ff01", "patch": "@@ -525,6 +525,7 @@ package body Xref_Lib is\n          when 'e' => return Param_String & \"enumeration object\";\n          when 'f' => return Param_String & \"float object\";\n          when 'i' => return Param_String & \"integer object\";\n+         when 'j' => return Param_String & \"class object\";\n          when 'm' => return Param_String & \"modular object\";\n          when 'o' => return Param_String & \"fixed object\";\n          when 'p' => return Param_String & \"access object\";\n@@ -537,6 +538,7 @@ package body Xref_Lib is\n \n          when 'h' => return \"interface\";\n          when 'g' => return \"macro\";\n+         when 'J' => return \"class\";\n          when 'K' => return \"package\";\n          when 'k' => return \"generic package\";\n          when 'L' => return \"statement label\";"}]}