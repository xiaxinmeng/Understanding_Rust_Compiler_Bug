{"sha": "a110855667782dac7b674d3e328b253b3b3c919b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTExMDg1NTY2Nzc4MmRhYzdiNjc0ZDNlMzI4YjI1M2IzYjNjOTE5Yg==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2021-07-07T20:05:25Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2021-07-07T20:06:59Z"}, "message": "Correct handling of variable offset minus constant in -Warray-bounds [PR100137]\n\nResolves:\nPR tree-optimization/100137 - -Warray-bounds false positive on varying offset plus negative\nPR tree-optimization/99121 - ICE in -Warray-bounds on a multidimensional\nPR tree-optimization/97027 - missing warning on buffer overflow storing a larger scalar into a smaller array\n\ngcc/ChangeLog:\n\n\tPR tree-optimization/100137\n\tPR tree-optimization/99121\n\tPR tree-optimization/97027\n\t* builtins.c (access_ref::access_ref): Also set offmax.\n\t(access_ref::offset_in_range): Define new function.\n\t(access_ref::add_offset): Set offmax.\n\t(access_ref::inform_access): Handle access_none.\n\t(handle_mem_ref): Clear ostype.\n\t(compute_objsize_r): Handle ASSERT_EXPR.\n\t* builtins.h (struct access_ref): Add offmax member.\n\t* gimple-array-bounds.cc (array_bounds_checker::check_mem_ref): Use\n\tcompute_objsize() and simplify.\n\ngcc/testsuite/ChangeLog:\n\n\tPR tree-optimization/100137\n\tPR tree-optimization/99121\n\tPR tree-optimization/97027\n\t* c-c++-common/Warray-bounds-3.c: Remove xfail\n\t* c-c++-common/Warray-bounds-4.c: Add an expected warning.\n\t* c-c++-common/Warray-bounds-9.c: New test.\n\t* c-c++-common/Warray-bounds-10.c: New test.\n\t* g++.dg/asan/asan_test.C: Suppress expected warnings.\n\t* g++.dg/pr95768.C: Same.\n\t* g++.dg/warn/Warray-bounds-10.C: Adjust text of expected messages.\n\t* g++.dg/warn/Warray-bounds-11.C: Same.\n\t* g++.dg/warn/Warray-bounds-12.C: Same.\n\t* g++.dg/warn/Warray-bounds-13.C: Same.\n\t* g++.dg/warn/Warray-bounds-17.C: Same.\n\t* g++.dg/warn/Warray-bounds-20.C: Same.\n\t* gcc.dg/Warray-bounds-29.c: Same.\n\t* gcc.dg/Warray-bounds-30.c: Add xfail.\n\t* gcc.dg/Warray-bounds-31.c: Adjust text of expected messages.\n\t* gcc.dg/Warray-bounds-32.c: Same.\n\t* gcc.dg/Warray-bounds-52.c: Same.\n\t* gcc.dg/Warray-bounds-53.c: Same.\n\t* gcc.dg/Warray-bounds-58.c: Remove xfail.\n\t* gcc.dg/Warray-bounds-63.c: Adjust text of expected messages.\n\t* gcc.dg/Warray-bounds-66.c: Same.\n\t* gcc.dg/Warray-bounds-69.c: Same.\n\t* gcc.dg/Wstringop-overflow-34.c: Same.\n\t* gcc.dg/Wstringop-overflow-47.c: Same.\n\t* gcc.dg/Wstringop-overflow-61.c: Same.\n\t* gcc.dg/Warray-bounds-77.c: New test.\n\t* gcc.dg/Warray-bounds-78.c: New test.\n\t* gcc.dg/Warray-bounds-79.c: New test.", "tree": {"sha": "4d7212fdc8b29304d8defd03eefdb6ca842daa2f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4d7212fdc8b29304d8defd03eefdb6ca842daa2f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a110855667782dac7b674d3e328b253b3b3c919b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a110855667782dac7b674d3e328b253b3b3c919b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a110855667782dac7b674d3e328b253b3b3c919b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a110855667782dac7b674d3e328b253b3b3c919b/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6278065af07634278ba30029d92a82b089969baa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6278065af07634278ba30029d92a82b089969baa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6278065af07634278ba30029d92a82b089969baa"}], "stats": {"total": 1188, "additions": 817, "deletions": 371}, "files": [{"sha": "39ab139b7e1c06c98d2db1aef2b3a6095ffbec63", "filename": "gcc/builtins.c", "status": "modified", "additions": 61, "deletions": 8, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a110855667782dac7b674d3e328b253b3b3c919b/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a110855667782dac7b674d3e328b253b3b3c919b/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=a110855667782dac7b674d3e328b253b3b3c919b", "patch": "@@ -206,6 +206,7 @@ access_ref::access_ref (tree bound /* = NULL_TREE */,\n {\n   /* Set to valid.  */\n   offrng[0] = offrng[1] = 0;\n+  offmax[0] = offmax[1] = 0;\n   /* Invalidate.   */\n   sizrng[0] = sizrng[1] = -1;\n \n@@ -457,6 +458,21 @@ access_ref::size_remaining (offset_int *pmin /* = NULL */) const\n   return sizrng[1] - or0;\n }\n \n+/* Return true if the offset and object size are in range for SIZE.  */\n+\n+bool\n+access_ref::offset_in_range (const offset_int &size) const\n+{\n+  if (size_remaining () < size)\n+    return false;\n+\n+  if (base0)\n+    return offmax[0] >= 0 && offmax[1] <= sizrng[1];\n+\n+  offset_int maxoff = wi::to_offset (TYPE_MAX_VALUE (ptrdiff_type_node));\n+  return offmax[0] > -maxoff && offmax[1] < maxoff;\n+}\n+\n /* Add the range [MIN, MAX] to the offset range.  For known objects (with\n    zero-based offsets) at least one of whose offset's bounds is in range,\n    constrain the other (or both) to the bounds of the object (i.e., zero\n@@ -493,6 +509,8 @@ void access_ref::add_offset (const offset_int &min, const offset_int &max)\n       if (max >= 0)\n \t{\n \t  offrng[0] = 0;\n+\t  if (offmax[0] > 0)\n+\t    offmax[0] = 0;\n \t  return;\n \t}\n \n@@ -509,6 +527,12 @@ void access_ref::add_offset (const offset_int &min, const offset_int &max)\n \toffrng[0] = 0;\n     }\n \n+  /* Set the minimum and maximmum computed so far. */\n+  if (offrng[1] < 0 && offrng[1] < offmax[0])\n+    offmax[0] = offrng[1];\n+  if (offrng[0] > 0 && offrng[0] > offmax[1])\n+    offmax[1] = offrng[0];\n+\n   if (!base0)\n     return;\n \n@@ -4571,23 +4595,46 @@ access_ref::inform_access (access_mode mode) const\n       return;\n     }\n \n+  if (mode == access_read_only)\n+    {\n+      if (allocfn == NULL_TREE)\n+\t{\n+\t  if (*offstr)\n+\t    inform (loc, \"at offset %s into source object %qE of size %s\",\n+\t\t    offstr, ref, sizestr);\n+\t  else\n+\t    inform (loc, \"source object %qE of size %s\", ref, sizestr);\n+\n+\t  return;\n+\t}\n+\n+      if (*offstr)\n+\tinform (loc,\n+\t\t\"at offset %s into source object of size %s allocated by %qE\",\n+\t\toffstr, sizestr, allocfn);\n+      else\n+\tinform (loc, \"source object of size %s allocated by %qE\",\n+\t\tsizestr, allocfn);\n+      return;\n+    }\n+\n   if (allocfn == NULL_TREE)\n     {\n       if (*offstr)\n-\tinform (loc, \"at offset %s into source object %qE of size %s\",\n+\tinform (loc, \"at offset %s into object %qE of size %s\",\n \t\toffstr, ref, sizestr);\n       else\n-\tinform (loc, \"source object %qE of size %s\", ref, sizestr);\n+\tinform (loc, \"object %qE of size %s\", ref, sizestr);\n \n       return;\n     }\n \n   if (*offstr)\n     inform (loc,\n-\t    \"at offset %s into source object of size %s allocated by %qE\",\n+\t    \"at offset %s into object of size %s allocated by %qE\",\n \t    offstr, sizestr, allocfn);\n   else\n-    inform (loc, \"source object of size %s allocated by %qE\",\n+    inform (loc, \"object of size %s allocated by %qE\",\n \t    sizestr, allocfn);\n }\n \n@@ -5433,16 +5480,16 @@ handle_mem_ref (tree mref, int ostype, access_ref *pref,\n \n   if (VECTOR_TYPE_P (TREE_TYPE (mref)))\n     {\n-      /* Hack: Give up for MEM_REFs of vector types; those may be\n-\t synthesized from multiple assignments to consecutive data\n-\t members (see PR 93200 and 96963).\n+      /* Hack: Handle MEM_REFs of vector types as those to complete\n+\t objects; those may be synthesized from multiple assignments\n+\t to consecutive data members (see PR 93200 and 96963).\n \t FIXME: Vectorized assignments should only be present after\n \t vectorization so this hack is only necessary after it has\n \t run and could be avoided in calls from prior passes (e.g.,\n \t tree-ssa-strlen.c).\n \t FIXME: Deal with this more generally, e.g., by marking up\n \t such MEM_REFs at the time they're created.  */\n-      return false;\n+      ostype = 0;\n     }\n \n   tree mrefop = TREE_OPERAND (mref, 0);\n@@ -5796,6 +5843,12 @@ compute_objsize_r (tree ptr, int ostype, access_ref *pref,\n \n       tree rhs = gimple_assign_rhs1 (stmt);\n \n+      if (code == ASSERT_EXPR)\n+\t{\n+\t  rhs = TREE_OPERAND (rhs, 0);\n+\t  return compute_objsize_r (rhs, ostype, pref, snlim, qry);\n+\t}\n+\n       if (code == POINTER_PLUS_EXPR\n \t  && TREE_CODE (TREE_TYPE (rhs)) == POINTER_TYPE)\n \t{"}, {"sha": "a64ece3f1cd9aed195cd2e5ec5383d4a96e39bf8", "filename": "gcc/builtins.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a110855667782dac7b674d3e328b253b3b3c919b/gcc%2Fbuiltins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a110855667782dac7b674d3e328b253b3b3c919b/gcc%2Fbuiltins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.h?ref=a110855667782dac7b674d3e328b253b3b3c919b", "patch": "@@ -222,6 +222,9 @@ struct access_ref\n      argument to the minimum.  */\n   offset_int size_remaining (offset_int * = NULL) const;\n \n+/* Return true if the offset and object size are in range for SIZE.  */\n+  bool offset_in_range (const offset_int &) const;\n+\n   /* Return true if *THIS is an access to a declared object.  */\n   bool ref_declared () const\n   {\n@@ -261,6 +264,8 @@ struct access_ref\n   /* Range of byte offsets into and sizes of the object(s).  */\n   offset_int offrng[2];\n   offset_int sizrng[2];\n+  /* The minimum and maximum offset computed.  */\n+  offset_int offmax[2];\n   /* Range of the bound of the access: denotes that the access\n      is at least BNDRNG[0] bytes but no more than BNDRNG[1].\n      For string functions the size of the actual access is"}, {"sha": "83b8db9755e84f83c96735a6f2cfb25320506d9b", "filename": "gcc/gimple-array-bounds.cc", "status": "modified", "additions": 50, "deletions": 286, "changes": 336, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a110855667782dac7b674d3e328b253b3b3c919b/gcc%2Fgimple-array-bounds.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a110855667782dac7b674d3e328b253b3b3c919b/gcc%2Fgimple-array-bounds.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-array-bounds.cc?ref=a110855667782dac7b674d3e328b253b3b3c919b", "patch": "@@ -414,269 +414,72 @@ array_bounds_checker::check_mem_ref (location_t location, tree ref,\n   if (warning_suppressed_p (ref, OPT_Warray_bounds))\n     return false;\n \n-  tree arg = TREE_OPERAND (ref, 0);\n-  /* The constant and variable offset of the reference.  */\n-  tree cstoff = TREE_OPERAND (ref, 1);\n-  tree varoff = NULL_TREE;\n-\n-  const offset_int maxobjsize = tree_to_shwi (max_object_size ());\n-\n-  /* The zero-based array or string constant bounds in bytes.  Initially\n-     set to [-MAXOBJSIZE - 1, MAXOBJSIZE]  until a tighter bound is\n-     determined.  */\n-  offset_int arrbounds[2] = { -maxobjsize - 1, maxobjsize };\n-\n-  /* The minimum and maximum intermediate offset.  For a reference\n-     to be valid, not only does the final offset/subscript must be\n-     in bounds but all intermediate offsets should be as well.\n-     GCC may be able to deal gracefully with such out-of-bounds\n-     offsets so the checking is only enabled at -Warray-bounds=2\n-     where it may help detect bugs in uses of the intermediate\n-     offsets that could otherwise not be detectable.  */\n-  offset_int ioff = wi::to_offset (fold_convert (ptrdiff_type_node, cstoff));\n-  offset_int extrema[2] = { 0, wi::abs (ioff) };\n-\n-  /* The range of the byte offset into the reference.  */\n-  offset_int offrange[2] = { 0, 0 };\n-\n   /* The statement used to allocate the array or null.  */\n   gimple *alloc_stmt = NULL;\n   /* For an allocation statement, the low bound of the size range.  */\n   offset_int minbound = 0;\n+  /* The type and size of the access.  */\n+  tree axstype = TREE_TYPE (ref);\n+  offset_int axssize = 0;\n+  if (TREE_CODE (axstype) != UNION_TYPE)\n+    if (tree access_size = TYPE_SIZE_UNIT (axstype))\n+      if (TREE_CODE (access_size) == INTEGER_CST)\n+\taxssize = wi::to_offset (access_size);\n \n-  /* Determine the offsets and increment OFFRANGE for the bounds of each.\n-     The loop computes the range of the final offset for expressions such\n-     as (A + i0 + ... + iN)[CSTOFF] where i0 through iN are SSA_NAMEs in\n-     some range.  */\n-  const unsigned limit = param_ssa_name_def_chain_limit;\n-  for (unsigned n = 0; TREE_CODE (arg) == SSA_NAME && n < limit; ++n)\n-    {\n-      gimple *def = SSA_NAME_DEF_STMT (arg);\n-      if (is_gimple_call (def))\n-\t{\n-\t  /* Determine the byte size of the array from an allocation call.  */\n-\t  wide_int sizrng[2];\n-\t  if (gimple_call_alloc_size (def, sizrng))\n-\t    {\n-\t      arrbounds[0] = 0;\n-\t      arrbounds[1] = offset_int::from (sizrng[1], UNSIGNED);\n-\t      minbound = offset_int::from (sizrng[0], UNSIGNED);\n-\t      alloc_stmt = def;\n-\t    }\n-\t  break;\n-\t}\n-\n-      if (gimple_nop_p (def))\n-\t{\n-\t  /* For a function argument try to determine the byte size\n-\t     of the array from the current function declaratation\n-\t     (e.g., attribute access or related).  */\n-\t  wide_int wr[2];\n-\t  tree ref = gimple_parm_array_size (arg, wr);\n-\t  if (!ref)\n-\t    break;\n-\t  arrbounds[0] = offset_int::from (wr[0], UNSIGNED);\n-\t  arrbounds[1] = offset_int::from (wr[1], UNSIGNED);\n-\t  arg = ref;\n-\t  break;\n-\t}\n-\n-      if (!is_gimple_assign (def))\n-\tbreak;\n-\n-      tree_code code = gimple_assign_rhs_code (def);\n-      if (code == POINTER_PLUS_EXPR)\n-\t{\n-\t  arg = gimple_assign_rhs1 (def);\n-\t  varoff = gimple_assign_rhs2 (def);\n-\t}\n-      else if (code == ASSERT_EXPR)\n-\t{\n-\t  arg = TREE_OPERAND (gimple_assign_rhs1 (def), 0);\n-\t  continue;\n-\t}\n-      else\n-\treturn false;\n-\n-      /* VAROFF should always be a SSA_NAME here (and not even\n-\t INTEGER_CST) but there's no point in taking chances.  */\n-      if (TREE_CODE (varoff) != SSA_NAME)\n-\tbreak;\n-\n-      const value_range* const vr = get_value_range (varoff);\n-      if (!vr || vr->undefined_p () || vr->varying_p ())\n-\tbreak;\n-\n-      if (!vr->constant_p ())\n-\tbreak;\n-\n-      if (vr->kind () == VR_RANGE)\n-\t{\n-\t  offset_int min\n-\t    = wi::to_offset (fold_convert (ptrdiff_type_node, vr->min ()));\n-\t  offset_int max\n-\t    = wi::to_offset (fold_convert (ptrdiff_type_node, vr->max ()));\n-\t  if (min < max)\n-\t    {\n-\t      offrange[0] += min;\n-\t      offrange[1] += max;\n-\t    }\n-\t  else\n-\t    {\n-\t      /* When MIN >= MAX, the offset is effectively in a union\n-\t\t of two ranges: [-MAXOBJSIZE -1, MAX] and [MIN, MAXOBJSIZE].\n-\t\t Since there is no way to represent such a range across\n-\t\t additions, conservatively add [-MAXOBJSIZE -1, MAXOBJSIZE]\n-\t\t to OFFRANGE.  */\n-\t      offrange[0] += arrbounds[0];\n-\t      offrange[1] += arrbounds[1];\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  /* For an anti-range, analogously to the above, conservatively\n-\t     add [-MAXOBJSIZE -1, MAXOBJSIZE] to OFFRANGE.  */\n-\t  offrange[0] += arrbounds[0];\n-\t  offrange[1] += arrbounds[1];\n-\t}\n-\n-      /* Keep track of the minimum and maximum offset.  */\n-      if (offrange[1] < 0 && offrange[1] < extrema[0])\n-\textrema[0] = offrange[1];\n-      if (offrange[0] > 0 && offrange[0] > extrema[1])\n-\textrema[1] = offrange[0];\n-\n-      if (offrange[0] < arrbounds[0])\n-\toffrange[0] = arrbounds[0];\n-\n-      if (offrange[1] > arrbounds[1])\n-\toffrange[1] = arrbounds[1];\n-    }\n+  access_ref aref;\n+  if (!compute_objsize (ref, 1, &aref, ranges))\n+    return false;\n \n-  tree reftype = NULL_TREE;\n-  offset_int eltsize = -1;\n-  if (arrbounds[0] >= 0)\n-    {\n-      /* The byte size of the array has already been determined above\n-\t based on a pointer ARG.  Set ELTSIZE to the size of the type\n-\t it points to and REFTYPE to the array with the size, rounded\n-\t down as necessary.  */\n-      reftype = TREE_TYPE (TREE_TYPE (arg));\n-      if (TREE_CODE (reftype) == ARRAY_TYPE)\n-\treftype = TREE_TYPE (reftype);\n-      if (tree refsize = TYPE_SIZE_UNIT (reftype))\n-\tif (TREE_CODE (refsize) == INTEGER_CST)\n-\t  eltsize = wi::to_offset (refsize);\n-\n-      if (eltsize < 0)\n-\treturn false;\n+  if (aref.offset_in_range (axssize))\n+    return false;\n \n-      offset_int nelts = arrbounds[1] / eltsize;\n-      reftype = build_printable_array_type (reftype, nelts.to_uhwi ());\n-    }\n-  else if (TREE_CODE (arg) == ADDR_EXPR)\n+  if (TREE_CODE (aref.ref) == SSA_NAME)\n     {\n-      arg = TREE_OPERAND (arg, 0);\n-      if (TREE_CODE (arg) != STRING_CST\n-\t  && TREE_CODE (arg) != PARM_DECL\n-\t  && TREE_CODE (arg) != VAR_DECL)\n-\treturn false;\n-\n-      /* The type of the object being referred to.  It can be an array,\n-\t string literal, or a non-array type when the MEM_REF represents\n-\t a reference/subscript via a pointer to an object that is not\n-\t an element of an array.  Incomplete types are excluded as well\n-\t because their size is not known.  */\n-      reftype = TREE_TYPE (arg);\n-      if (POINTER_TYPE_P (reftype)\n-\t  || !COMPLETE_TYPE_P (reftype)\n-\t  || TREE_CODE (TYPE_SIZE_UNIT (reftype)) != INTEGER_CST)\n-\treturn false;\n-\n-      /* Except in declared objects, references to trailing array members\n-\t of structs and union objects are excluded because MEM_REF doesn't\n-\t make it possible to identify the member where the reference\n-\t originated.  */\n-      if (RECORD_OR_UNION_TYPE_P (reftype)\n-\t  && (!VAR_P (arg)\n-\t      || (DECL_EXTERNAL (arg) && array_at_struct_end_p (ref))))\n-\treturn false;\n-\n-      /* FIXME: Should this be 1 for Fortran?  */\n-      arrbounds[0] = 0;\n-\n-      if (TREE_CODE (reftype) == ARRAY_TYPE)\n-\t{\n-\t  /* Set to the size of the array element (and adjust below).  */\n-\t  eltsize = wi::to_offset (TYPE_SIZE_UNIT (TREE_TYPE (reftype)));\n-\t  /* Use log2 of size to convert the array byte size in to its\n-\t     upper bound in elements.  */\n-\t  const offset_int eltsizelog2 = wi::floor_log2 (eltsize);\n-\t  if (tree dom = TYPE_DOMAIN (reftype))\n-\t    {\n-\t      tree bnds[] = { TYPE_MIN_VALUE (dom), TYPE_MAX_VALUE (dom) };\n-\t      if (TREE_CODE (arg) == COMPONENT_REF)\n-\t\t{\n-\t\t  offset_int size = maxobjsize;\n-\t\t  if (tree fldsize = component_ref_size (arg))\n-\t\t    size = wi::to_offset (fldsize);\n-\t\t  arrbounds[1] = wi::lrshift (size, eltsizelog2);\n-\t\t}\n-\t      else if (array_at_struct_end_p (arg) || !bnds[0] || !bnds[1])\n-\t\tarrbounds[1] = wi::lrshift (maxobjsize, eltsizelog2);\n-\t      else\n-\t\tarrbounds[1] = (wi::to_offset (bnds[1]) - wi::to_offset (bnds[0])\n-\t\t\t\t+ 1) * eltsize;\n-\t    }\n-\t  else\n-\t    arrbounds[1] = wi::lrshift (maxobjsize, eltsizelog2);\n-\n-\t  /* Determine a tighter bound of the non-array element type.  */\n-\t  tree eltype = TREE_TYPE (reftype);\n-\t  while (TREE_CODE (eltype) == ARRAY_TYPE)\n-\t    eltype = TREE_TYPE (eltype);\n-\t  eltsize = wi::to_offset (TYPE_SIZE_UNIT (eltype));\n-\t}\n-      else\n+      gimple *def = SSA_NAME_DEF_STMT (aref.ref);\n+      if (is_gimple_call (def))\n \t{\n-\t  eltsize = 1;\n-\t  tree size = TYPE_SIZE_UNIT (reftype);\n-\t  if (VAR_P (arg))\n-\t    if (tree initsize = DECL_SIZE_UNIT (arg))\n-\t      if (tree_int_cst_lt (size, initsize))\n-\t\tsize = initsize;\n-\n-\t  arrbounds[1] = wi::to_offset (size);\n+\t  /* Save the allocation call and the low bound on the size.  */\n+\t  alloc_stmt = def;\n+\t  minbound = aref.sizrng[0];\n \t}\n     }\n-  else\n-    return false;\n-\n-  offrange[0] += ioff;\n-  offrange[1] += ioff;\n+\t\t\t\n+  /* The range of the byte offset into the reference.  Adjusted below.  */\n+  offset_int offrange[2] = { aref.offrng[0], aref.offrng[1] };\n+\n+  /* The type of the referenced object.  */\n+  tree reftype = TREE_TYPE (aref.ref);\n+  /* The size of the referenced array element.  */\n+  offset_int eltsize = 1;\n+  /* The byte size of the array has already been determined above\n+     based on a pointer ARG.  Set ELTSIZE to the size of the type\n+     it points to and REFTYPE to the array with the size, rounded\n+     down as necessary.  */\n+  if (POINTER_TYPE_P (reftype))\n+    reftype = TREE_TYPE (reftype);\n+  if (TREE_CODE (reftype) == ARRAY_TYPE)\n+    reftype = TREE_TYPE (reftype);\n+  if (tree refsize = TYPE_SIZE_UNIT (reftype))\n+    if (TREE_CODE (refsize) == INTEGER_CST)\n+      eltsize = wi::to_offset (refsize);\n+\n+  const offset_int nelts = aref.sizrng[1] / eltsize;\n+  reftype = build_printable_array_type (reftype, nelts.to_uhwi ());\n \n   /* Compute the more permissive upper bound when IGNORE_OFF_BY_ONE\n      is set (when taking the address of the one-past-last element\n      of an array) but always use the stricter bound in diagnostics. */\n-  offset_int ubound = arrbounds[1];\n+  offset_int ubound = aref.sizrng[1];\n   if (ignore_off_by_one)\n     ubound += eltsize;\n \n-  bool warned = false;\n   /* Set if the lower bound of the subscript is out of bounds.  */\n-  const bool lboob = (arrbounds[0] == arrbounds[1]\n+  const bool lboob = (aref.sizrng[1] == 0\n \t\t      || offrange[0] >= ubound\n-\t\t      || offrange[1] < arrbounds[0]);\n+\t\t      || offrange[1] < 0);\n   /* Set if only the upper bound of the subscript is out of bounds.\n      This can happen when using a bigger type to index into an array\n      of a smaller type, as is common with unsigned char.  */\n-  tree axstype = TREE_TYPE (ref);\n-  offset_int axssize = 0;\n-  if (TREE_CODE (axstype) != UNION_TYPE)\n-    if (tree access_size = TYPE_SIZE_UNIT (axstype))\n-      if (TREE_CODE (access_size) == INTEGER_CST)\n-\taxssize = wi::to_offset (access_size);\n-\n   const bool uboob = !lboob && offrange[0] + axssize > ubound;\n   if (lboob || uboob)\n     {\n@@ -689,16 +492,15 @@ array_bounds_checker::check_mem_ref (location_t location, tree ref,\n \t to compute the index to print in the diagnostic; arrays\n \t in MEM_REF don't mean anything.  A type with no size like\n \t void is as good as having a size of 1.  */\n-      tree type = TREE_TYPE (ref);\n-      while (TREE_CODE (type) == ARRAY_TYPE)\n-\ttype = TREE_TYPE (type);\n+      tree type = strip_array_types (TREE_TYPE (ref));\n       if (tree size = TYPE_SIZE_UNIT (type))\n \t{\n \t  offrange[0] = offrange[0] / wi::to_offset (size);\n \t  offrange[1] = offrange[1] / wi::to_offset (size);\n \t}\n     }\n \n+  bool warned = false;\n   if (lboob)\n     {\n       if (offrange[0] == offrange[1])\n@@ -720,7 +522,7 @@ array_bounds_checker::check_mem_ref (location_t location, tree ref,\n \t/* If the memory was dynamically allocated refer to it as if\n \t   it were an untyped array of bytes.  */\n \tbacktype = build_array_type_nelts (unsigned_char_type_node,\n-\t\t\t\t\t   arrbounds[1].to_uhwi ());\n+\t\t\t\t\t   aref.sizrng[1].to_uhwi ());\n \n       warned = warning_at (location, OPT_Warray_bounds,\n \t\t\t   \"array subscript %<%T[%wi]%> is partly \"\n@@ -730,46 +532,8 @@ array_bounds_checker::check_mem_ref (location_t location, tree ref,\n \n   if (warned)\n     {\n-      if (DECL_P (arg))\n-\tinform (DECL_SOURCE_LOCATION (arg), \"while referencing %qD\", arg);\n-      else if (alloc_stmt)\n-\t{\n-\t  location_t loc = gimple_location (alloc_stmt);\n-\t  if (gimple_call_builtin_p (alloc_stmt, BUILT_IN_ALLOCA_WITH_ALIGN))\n-\t    {\n-\t      if (minbound == arrbounds[1])\n-\t\tinform (loc, \"referencing a variable length array \"\n-\t\t\t\"of size %wu\", minbound.to_uhwi ());\n-\t      else\n-\t\tinform (loc, \"referencing a variable length array \"\n-\t\t\t\"of size between %wu and %wu\",\n-\t\t\tminbound.to_uhwi (), arrbounds[1].to_uhwi ());\n-\t    }\n-\t  else if (tree fndecl = gimple_call_fndecl (alloc_stmt))\n-\t    {\n-\t      if (minbound == arrbounds[1])\n-\t\tinform (loc, \"referencing an object of size %wu \"\n-\t\t\t\"allocated by %qD\",\n-\t\t\tminbound.to_uhwi (), fndecl);\n-\t      else\n-\t\tinform (loc, \"referencing an object of size between \"\n-\t\t\t\"%wu and %wu allocated by %qD\",\n-\t\t\tminbound.to_uhwi (), arrbounds[1].to_uhwi (), fndecl);\n-\t    }\n-\t  else\n-\t    {\n-\t      tree fntype = gimple_call_fntype (alloc_stmt);\n-\t      if (minbound == arrbounds[1])\n-\t\tinform (loc, \"referencing an object of size %wu \"\n-\t\t\t\"allocated by %qT\",\n-\t\t\tminbound.to_uhwi (), fntype);\n-\t      else\n-\t\tinform (loc, \"referencing an object of size between \"\n-\t\t\t\"%wu and %wu allocated by %qT\",\n-\t\t\tminbound.to_uhwi (), arrbounds[1].to_uhwi (), fntype);\n-\t    }\n-\t}\n-\n+      /* TODO: Determine the access from the statement and use it.  */\n+      aref.inform_access (access_none);\n       suppress_warning (ref, OPT_Warray_bounds);\n       return true;\n     }\n@@ -779,9 +543,9 @@ array_bounds_checker::check_mem_ref (location_t location, tree ref,\n \n   /* At level 2 check also intermediate offsets.  */\n   int i = 0;\n-  if (extrema[i] < -arrbounds[1] || extrema[i = 1] > ubound)\n+  if (aref.offmax[i] < -aref.sizrng[1] || aref.offmax[i = 1] > ubound)\n     {\n-      HOST_WIDE_INT tmpidx = extrema[i].to_shwi () / eltsize.to_shwi ();\n+      HOST_WIDE_INT tmpidx = aref.offmax[i].to_shwi () / eltsize.to_shwi ();\n \n       if (warning_at (location, OPT_Warray_bounds,\n \t\t      \"intermediate array offset %wi is outside array bounds \""}, {"sha": "cfe9a38341087e010a7e883afe9ca74808b587a1", "filename": "gcc/testsuite/c-c++-common/Warray-bounds-10.c", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a110855667782dac7b674d3e328b253b3b3c919b/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWarray-bounds-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a110855667782dac7b674d3e328b253b3b3c919b/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWarray-bounds-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWarray-bounds-10.c?ref=a110855667782dac7b674d3e328b253b3b3c919b", "patch": "@@ -0,0 +1,114 @@\n+/* PR tree-optimization/99475 - bogus -Warray-bounds accessing an array\n+   element of empty structs\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+struct S\n+{\n+#if SOME_CONFIG_MACRO\n+  /* Suppose the contents are empty in the development configuration\n+     but non-empty in others.  Out of bounds accesses to elements of\n+     the arrays below should be diagnosed in all configurations,\n+     including when S is empty, even if they are folded away.  */\n+  int member;\n+#endif\n+};\n+\n+extern struct S sa3[3];\n+extern struct S sa2_3[2][3];\n+extern struct S sa3_4_5[3][4][5];\n+\n+void sink (void*);\n+\n+\n+void access_sa3 (struct S s)\n+{\n+  sa3[0] = s;\n+  sa3[1] = s;\n+  sa3[2] = s;\n+  sa3[3] = s;       // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr?????\" { xfail *-*-* } }\n+}\n+\n+void access_sa3_ptr (struct S s)\n+{\n+  struct S *p = &sa3[0];\n+\n+  p[0] = s;         // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+  p[1] = s;         // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+  p[2] = s;         // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+  p[3] = s;         // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr?????\" { xfail *-*-* } }\n+}\n+\n+void access_sa2_3_ptr (struct S s)\n+{\n+  struct S *p = &sa2_3[0][0];\n+\n+  p[0] = s;         // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+  p[1] = s;         // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+  p[2] = s;         // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+  p[6] = s;         // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr?????\" { xfail *-*-* } }\n+}\n+\n+void access_sa3_4_5_ptr (struct S s, int i)\n+{\n+  struct S *p = &sa3_4_5[0][0][0];\n+\n+  p[0] = s;         // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+  p[1] = s;         // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+  p[2] = s;         // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+  p[60] = s;        // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr?????\" { xfail *-*-* } }\n+}\n+\n+\n+void access_vla3 (struct S s, unsigned n)\n+{\n+  struct S vla3[3 < n ? 3 : n];\n+\n+  vla3[0] = s;\n+  vla3[1] = s;\n+  vla3[2] = s;\n+  vla3[3] = s;       // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr?????\" { xfail *-*-* } }\n+\n+  sink (vla3);\n+}\n+\n+void access_vla3_ptr (struct S s, unsigned n)\n+{\n+  struct S vla3[3 < n ? 3 : n];\n+  struct S *p = &vla3[0];\n+\n+  p[0] = s;         // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+  p[1] = s;         // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+  p[2] = s;         // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+  p[3] = s;         // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr?????\" { xfail *-*-* } }\n+\n+  sink (vla3);\n+}\n+\n+void access_vla2_3_ptr (struct S s, unsigned n)\n+{\n+  struct S vla2_3[2 < n ? 2 : n][3 < n ? 3 : n];\n+  struct S *p = &vla2_3[0][0];\n+\n+  p[0] = s;         // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+  p[1] = s;         // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+  p[2] = s;         // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+  p[6] = s;         // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr?????\" { xfail *-*-* } }\n+\n+  sink (vla2_3);\n+}\n+\n+void access_vla3_4_5_ptr (struct S s, unsigned n)\n+{\n+  struct S vla3_4_5[3 < n ? 3 : n][4 < n ? 4 : n][5 < n ? 5 : n];\n+  struct S *p = &vla3_4_5[0][0][0];\n+\n+  p[0] = s;         // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+  p[1] = s;         // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+  p[2] = s;         // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+  p[60] = s;        // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr?????\" { xfail *-*-* } }\n+\n+  sink (vla3_4_5);\n+}\n+\n+// { dg-prune-output \"empty struct has size 0 in C\" }"}, {"sha": "3d7c768737414f1c132ba10cfc486b08c3f4dc02", "filename": "gcc/testsuite/c-c++-common/Warray-bounds-3.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a110855667782dac7b674d3e328b253b3b3c919b/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWarray-bounds-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a110855667782dac7b674d3e328b253b3b3c919b/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWarray-bounds-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWarray-bounds-3.c?ref=a110855667782dac7b674d3e328b253b3b3c919b", "patch": "@@ -158,7 +158,7 @@ void test_memcpy_overflow (char *d, const char *s, size_t n)\n      but known access size is detected.  This works except with small\n      sizes that are powers of 2 due to bug .  */\n   T (char, 1, arr + SR (DIFF_MAX - 1, DIFF_MAX), s, 1);\n-  T (char, 1, arr + SR (DIFF_MAX - 1, DIFF_MAX), s, 2);  /* { dg-warning \"pointer overflow between offset \\\\\\[\\[0-9\\]+, \\[0-9\\]+] and size 2 accessing array \" \"bug \" { xfail non_strict_align } } */\n+  T (char, 1, arr + SR (DIFF_MAX - 1, DIFF_MAX), s, 2);  /* { dg-warning \"\\\\\\[-Warray-bounds\" } */\n   T (char, 1, arr + SR (DIFF_MAX - 2, DIFF_MAX), s, 3);  /* { dg-warning \"pointer overflow between offset \\\\\\[\\[0-9\\]+, \\[0-9\\]+] and size 3 accessing array \" \"memcpy\" } */\n   T (char, 1, arr + SR (DIFF_MAX - 4, DIFF_MAX), s, 5);  /* { dg-warning \"pointer overflow between offset \\\\\\[\\[0-9\\]+, \\[0-9\\]+] and size 5 accessing array \" \"memcpy\" } */\n }\n@@ -178,7 +178,7 @@ void test_memcpy_bounds_memarray_range (void)\n \n   TM (ma.a5, ma.a5 + i, ma.a5, 1);\n   TM (ma.a5, ma.a5 + i, ma.a5, 3);\n-  TM (ma.a5, ma.a5 + i, ma.a5, 5);\n+  TM (ma.a5, ma.a5 + i, ma.a5, 5);     /* { dg-warning \"\\\\\\[-Warray-bounds\" } */\n   TM (ma.a5, ma.a5 + i, ma.a5, 7);     /* diagnosed with -Warray-bounds=2 */\n }\n "}, {"sha": "1f73f11943fe633a344f1f91728ea81813dd1f23", "filename": "gcc/testsuite/c-c++-common/Warray-bounds-4.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a110855667782dac7b674d3e328b253b3b3c919b/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWarray-bounds-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a110855667782dac7b674d3e328b253b3b3c919b/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWarray-bounds-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWarray-bounds-4.c?ref=a110855667782dac7b674d3e328b253b3b3c919b", "patch": "@@ -43,7 +43,17 @@ void test_memcpy_bounds_memarray_range (void)\n \n   TM (ma.a5, ma.a5 + j, ma.a5, 1);\n   TM (ma.a5, ma.a5 + j, ma.a5, 3);\n-  TM (ma.a5, ma.a5 + j, ma.a5, 5);\n+\n+  /* The copy below is invalid for two reasons: 1) it overlaps and 2) it\n+     writes past the end of ma.a5.  The warning is a little cryptic here\n+     because the GIMPLE is:\n+       _4 = &ma.a5 + prephitmp_14;\n+       MEM <unsigned char[5]> [(char * {ref-all})_4]\n+         = MEM <unsigned char[5]> [(char * {ref-all})&ma];\n+     and could be improved.  Just verify that one is issued but not its\n+     full text.  */\n+  TM (ma.a5, ma.a5 + j, ma.a5, 5);        /* { dg-warning \"\\\\\\[-Warray-bounds\" } */\n+\n   TM (ma.a5, ma.a5 + j, ma.a5, 7);        /* { dg-warning \"offset \\\\\\[5, 7] from the object at .ma. is out of the bounds of referenced subobject .\\(MA::\\)?a5. with type .char ?\\\\\\[5]. at offset 0\" } */\n   TM (ma.a5, ma.a5 + j, ma.a5, 9);        /* { dg-warning \"offset \\\\\\[5, 9] from the object at .ma. is out of the bounds of referenced subobject .\\(MA::\\)?a5. with type .char ?\\\\\\[5]. at offset 0\" } */\n }"}, {"sha": "be05775fa913ad4bd181dc3a4e239aef6b14e117", "filename": "gcc/testsuite/c-c++-common/Warray-bounds-9.c", "status": "added", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a110855667782dac7b674d3e328b253b3b3c919b/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWarray-bounds-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a110855667782dac7b674d3e328b253b3b3c919b/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWarray-bounds-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWarray-bounds-9.c?ref=a110855667782dac7b674d3e328b253b3b3c919b", "patch": "@@ -0,0 +1,144 @@\n+/* PR tree-optimization/99121 - ICE in -Warray-bounds on a multidimensional\n+   VLA\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -ftrack-macro-expansion=0\" } */\n+\n+#define NOIPA __attribute__ ((noipa))\n+\n+void sink (void*, ...);\n+#define T(a, x) sink (a, x)\n+\n+\n+NOIPA void a_0_n (int n)\n+{\n+  int a[0][n];\n+\n+  sink (a);\n+\n+  T (a, ((int *) a)[0]);      // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (a, ((char *) a)[1]);     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (a, ((float *) a)[n]);    // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+NOIPA void a_n_0 (int n)\n+{\n+  int a[n][0];\n+\n+  sink (a);\n+\n+  T (a, ((int *) a)[0]);      // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (a, ((char *) a)[1]);     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (a, ((float *) a)[n]);    // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+\n+NOIPA void a_1_n_0 (int n)\n+{\n+  int a[1][n][0];\n+\n+  sink (a);\n+\n+  T (a, ((int *) a)[0]);      // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (a, ((char *) a)[1]);     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (a, ((float *) a)[n]);    // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+NOIPA void a_1_0_n (int n)\n+{\n+  int a[1][0][n];\n+\n+  sink (a);\n+\n+  T (a, ((int *) a)[0]);      // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (a, ((char *) a)[1]);     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (a, ((float *) a)[n]);    // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+NOIPA void a_0_1_n (int n)\n+{\n+  int a[0][1][n];\n+\n+  sink (a);\n+\n+  T (a, ((int *) a)[0]);      // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (a, ((char *) a)[1]);     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (a, ((float *) a)[n]);    // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+NOIPA void a_0_n_1 (int n)\n+{\n+  int a[0][n][1];\n+\n+  sink (a);\n+\n+  T (a, ((int *) a)[0]);      // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (a, ((char *) a)[1]);     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (a, ((float *) a)[n]);    // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+NOIPA void a_n_0_n (int n)\n+{\n+  int a[n][0][n];\n+\n+  sink (a);\n+\n+  T (a, ((int *) a)[0]);      // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (a, ((char *) a)[1]);     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (a, ((float *) a)[n]);    // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+NOIPA void a_n_n_0 (int n)\n+{\n+  int a[n][n][0];\n+\n+  sink (a);\n+\n+  T (a, ((int *) a)[0]);      // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (a, ((char *) a)[1]);     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (a, ((float *) a)[n]);    // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+NOIPA void a_0_n_n (int n)\n+{\n+  int a[0][n][n];\n+\n+  sink (a);\n+\n+  T (a, ((int *) a)[0]);      // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (a, ((char *) a)[1]);     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (a, ((float *) a)[n]);    // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+NOIPA void a_0_0_n (int n)\n+{\n+  int a[0][0][n];\n+\n+  sink (a);\n+\n+  T (a, ((int *) a)[0]);      // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (a, ((char *) a)[1]);     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (a, ((float *) a)[n]);    // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+NOIPA void a_n_0_0 (int n)\n+{\n+  int a[n][0][0];\n+\n+  sink (a);\n+\n+  T (a, ((int *) a)[0]);      // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (a, ((char *) a)[1]);     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  T (a, ((float *) a)[n]);    // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+NOIPA void a_n_n_n (int n)\n+{\n+  int a[n][n][n];\n+\n+  sink (a);\n+\n+  T (a, ((int *) a)[-1]);     // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr99140\" }\n+  T (a, ((int *) a)[0]);\n+  T (a, ((char *) a)[1]);\n+  T (a, ((float *) a)[n]);\n+}"}, {"sha": "49933ab8e4da59980fbf8db4d71f4a0bf1e2a422", "filename": "gcc/testsuite/g++.dg/asan/asan_test.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a110855667782dac7b674d3e328b253b3b3c919b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_test.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a110855667782dac7b674d3e328b253b3b3c919b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_test.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fasan%2Fasan_test.C?ref=a110855667782dac7b674d3e328b253b3b3c919b", "patch": "@@ -2,7 +2,7 @@\n // { dg-skip-if \"\" { *-*-* } { \"*\" } { \"-O2\" } }\n // { dg-skip-if \"\" { *-*-* } { \"-flto\" } { \"\" } }\n // { dg-additional-sources \"asan_globals_test-wrapper.cc\" }\n-// { dg-options \"-std=c++11 -fsanitize=address -fno-builtin -Wall -Werror -Wno-alloc-size-larger-than -Wno-stringop-overflow -g -DASAN_UAR=0 -DASAN_HAS_EXCEPTIONS=1 -DASAN_HAS_BLACKLIST=0 -DSANITIZER_USE_DEJAGNU_GTEST=1 -lasan -lpthread\" }\n+// { dg-options \"-std=c++11 -fsanitize=address -fno-builtin -Wall -Werror -Wno-alloc-size-larger-than -Wno-array-bounds -Wno-stringop-overflow -g -DASAN_UAR=0 -DASAN_HAS_EXCEPTIONS=1 -DASAN_HAS_BLACKLIST=0 -DSANITIZER_USE_DEJAGNU_GTEST=1 -lasan -lpthread\" }\n // { dg-additional-options \"-ldl\" { target { ! *-*-freebsd* } } }\n // { dg-additional-options \"-DASAN_NEEDS_SEGV=1\" { target { ! arm*-*-* } } }\n // { dg-additional-options \"-DASAN_LOW_MEMORY=1 -DASAN_NEEDS_SEGV=0\" { target arm*-*-* } }"}, {"sha": "d34d513313469faa1dd9fdfb630ad4ec91700c07", "filename": "gcc/testsuite/g++.dg/pr95768.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a110855667782dac7b674d3e328b253b3b3c919b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr95768.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a110855667782dac7b674d3e328b253b3b3c919b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr95768.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr95768.C?ref=a110855667782dac7b674d3e328b253b3b3c919b", "patch": "@@ -1,6 +1,6 @@\n /* PR c++/95768 - pretty-printer ICE on -Wuninitialized with allocated storage\n    { dg-do compile }\n-   { dg-options \"-O2 -Wall\" } */\n+   { dg-options \"-O2 -Wall -Wno-array-bounds\" } */\n \n extern \"C\" void *malloc (__SIZE_TYPE__);\n "}, {"sha": "4b758aadaa164adffa6a9f42190cf9eb3c4048e2", "filename": "gcc/testsuite/g++.dg/warn/Warray-bounds-10.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a110855667782dac7b674d3e328b253b3b3c919b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWarray-bounds-10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a110855667782dac7b674d3e328b253b3b3c919b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWarray-bounds-10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWarray-bounds-10.C?ref=a110855667782dac7b674d3e328b253b3b3c919b", "patch": "@@ -18,7 +18,7 @@ void sink (void*);\n void warn_op_new ()\n {\n   T (int32_t, 0, 0);          // { dg-warning \"array subscript 0 is outside array bounds of 'int32_t \\\\\\[0]'\" }\n-                              // { dg-message \"referencing an object of size \\\\d allocated by 'void\\\\\\* operator new\\\\\\(\\(long \\)?unsigned int\\\\\\)'\" \"note\" { target *-*-* } .-1 }\n+                              // { dg-message \"object of size \\\\d allocated by '\\[^\\n\\r]*operator new\\[^\\n\\r]*'\" \"note\" { target *-*-* } .-1 }\n   T (int32_t, 1, 0);          // { dg-warning \"array subscript 'int32_t {aka (long )?int}\\\\\\[0]' is partly outside array bounds of 'unsigned char \\\\\\[1]'\" }\n   T (int32_t, 2, 0);         //  { dg-warning \"array subscript 'int32_t {aka (long )?int}\\\\\\[0]' is partly outside array bounds of 'unsigned char \\\\\\[2]'\" }\n   T (int32_t, 3, 0);         // { dg-warning \"array subscript 'int32_t {aka (long )?int}\\\\\\[0]' is partly outside array bounds of 'unsigned char \\\\\\[3]'\" }\n@@ -44,7 +44,7 @@ void warn_op_array_new ()\n #define OP_NEW(n)  operator new[] (n)\n \n   T (int32_t, 0, 0);          // { dg-warning \"array subscript 0 is outside array bounds of 'int32_t \\\\\\[0]'\" }\n-                              // { dg-message \"referencing an object of size \\\\d allocated by 'void\\\\\\* operator new \\\\\\[]\\\\\\(\\(long \\)?unsigned int\\\\\\)'\" \"note\" { target *-*-* } .-1 }\n+                              // { dg-message \"object of size \\\\d allocated by '\\[^\\n\\r]*operator new\\[^\\n\\r]*'\" \"note\" { target *-*-* } .-1 }\n   T (int32_t, 1, 0);          // { dg-warning \"array subscript 'int32_t {aka (long )?int}\\\\\\[0]' is partly outside array bounds of 'unsigned char \\\\\\[1]'\" }\n   T (int32_t, 2, 0);         //  { dg-warning \"array subscript 'int32_t {aka (long )?int}\\\\\\[0]' is partly outside array bounds of 'unsigned char \\\\\\[2]'\" }\n   T (int32_t, 3, 0);         // { dg-warning \"array subscript 'int32_t {aka (long )?int}\\\\\\[0]' is partly outside array bounds of 'unsigned char \\\\\\[3]'\" }"}, {"sha": "70b39122f78abea5e08a0d85833196dbc01970b0", "filename": "gcc/testsuite/g++.dg/warn/Warray-bounds-11.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a110855667782dac7b674d3e328b253b3b3c919b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWarray-bounds-11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a110855667782dac7b674d3e328b253b3b3c919b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWarray-bounds-11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWarray-bounds-11.C?ref=a110855667782dac7b674d3e328b253b3b3c919b", "patch": "@@ -20,7 +20,7 @@ void sink (void*);\n void warn_op_new ()\n {\n   T (int32_t, 0, 0);          // { dg-warning \"array subscript 0 is outside array bounds of 'int32_t \\\\\\[0]'\" }\n-                              // { dg-message \"referencing an object of size \\\\d allocated by 'void\\\\\\* operator new\\\\\\(std::size_t, const std::nothrow_t.\\\\\\)'\" \"note\" { target *-*-* } .-1 }\n+                              // { dg-message \"object of size \\\\d allocated by '\\[^\\n\\r]*operator new\\[^\\n\\r]*'\" \"note\" { target *-*-* } .-1 }\n   T (int32_t, 1, 0);          // { dg-warning \"array subscript 'int32_t {aka (long )?int}\\\\\\[0]' is partly outside array bounds of 'unsigned char \\\\\\[1]'\" }\n   T (int32_t, 2, 0);         //  { dg-warning \"array subscript 'int32_t {aka (long )?int}\\\\\\[0]' is partly outside array bounds of 'unsigned char \\\\\\[2]'\" }\n   T (int32_t, 3, 0);         // { dg-warning \"array subscript 'int32_t {aka (long )?int}\\\\\\[0]' is partly outside array bounds of 'unsigned char \\\\\\[3]'\" }\n@@ -46,7 +46,7 @@ void warn_op_array_new ()\n #define OP_NEW(n)  operator new[] (n, std::nothrow)\n \n   T (int32_t, 0, 0);          // { dg-warning \"array subscript 0 is outside array bounds of 'int32_t \\\\\\[0]'\" }\n-                              // { dg-message \"referencing an object of size \\\\d allocated by 'void\\\\\\* operator new \\\\\\[]\\\\\\(std::size_t, const std::nothrow_t&\\\\\\)'\" \"note\" { target *-*-* } .-1 }\n+                              // { dg-message \"object of size \\\\d allocated by '\\[^\\n\\r]*operator new\\[^\\n\\r]*'\" \"note\" { target *-*-* } .-1 }\n   T (int32_t, 1, 0);          // { dg-warning \"array subscript 'int32_t {aka (long )?int}\\\\\\[0]' is partly outside array bounds of 'unsigned char \\\\\\[1]'\" }\n   T (int32_t, 2, 0);         //  { dg-warning \"array subscript 'int32_t {aka (long )?int}\\\\\\[0]' is partly outside array bounds of 'unsigned char \\\\\\[2]'\" }\n   T (int32_t, 3, 0);         // { dg-warning \"array subscript 'int32_t {aka (long )?int}\\\\\\[0]' is partly outside array bounds of 'unsigned char \\\\\\[3]'\" }"}, {"sha": "07fa351a86ceb265616ebe5a9c83d9507e55ce86", "filename": "gcc/testsuite/g++.dg/warn/Warray-bounds-12.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a110855667782dac7b674d3e328b253b3b3c919b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWarray-bounds-12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a110855667782dac7b674d3e328b253b3b3c919b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWarray-bounds-12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWarray-bounds-12.C?ref=a110855667782dac7b674d3e328b253b3b3c919b", "patch": "@@ -20,7 +20,7 @@ void sink (void*);\n void warn_new ()\n {\n   T (int32_t, 0, 0);          // { dg-warning \"array subscript 0 is outside array bounds of 'int32_t \\\\\\[0]'\" }\n-                              // { dg-message \"referencing an object of size \\\\d allocated by 'void\\\\\\* operator new\\\\\\(\\(long \\)?unsigned int\\\\\\)'\" \"note\" { target *-*-* } .-1 }\n+                              // { dg-message \"object of size \\\\d allocated by '\\[^\\n\\r]*operator new\\[^\\n\\r]*'\" \"note\" { target *-*-* } .-1 }\n   T (int32_t, 1, 0);          // { dg-warning \"array subscript 'int32_t {aka (long )?int}\\\\\\[0]' is partly outside array bounds of 'unsigned char \\\\\\[1]'\" }\n   T (int32_t, 2, 0);         //  { dg-warning \"array subscript 'int32_t {aka (long )?int}\\\\\\[0]' is partly outside array bounds of 'unsigned char \\\\\\[2]'\" }\n   T (int32_t, 3, 0);         // { dg-warning \"array subscript 'int32_t {aka (long )?int}\\\\\\[0]' is partly outside array bounds of 'unsigned char \\\\\\[3]'\" }\n@@ -46,7 +46,7 @@ void warn_array_new ()\n #define NEW(n)  new char [n]\n \n   T (int32_t, 0, 0);          // { dg-warning \"array subscript 0 is outside array bounds of 'int32_t \\\\\\[0]'\" }\n-                              // { dg-message \"referencing an object of size \\\\d allocated by 'void\\\\\\* operator new \\\\\\[]\\\\\\(\\(long \\)?unsigned int\\\\\\)'\" \"note\" { target *-*-* } .-1 }\n+                              // { dg-message \"object of size \\\\d allocated by '\\[^\\n\\r]*operator new\\[^\\n\\r]*'\" \"note\" { target *-*-* } .-1 }\n   T (int32_t, 1, 0);          // { dg-warning \"array subscript 'int32_t {aka (long )?int}\\\\\\[0]' is partly outside array bounds of 'unsigned char \\\\\\[1]'\" }\n   T (int32_t, 2, 0);         //  { dg-warning \"array subscript 'int32_t {aka (long )?int}\\\\\\[0]' is partly outside array bounds of 'unsigned char \\\\\\[2]'\" }\n   T (int32_t, 3, 0);         // { dg-warning \"array subscript 'int32_t {aka (long )?int}\\\\\\[0]' is partly outside array bounds of 'unsigned char \\\\\\[3]'\" }"}, {"sha": "2d3e9dcfd684f5c9eed46f927e603ab7c30c5a37", "filename": "gcc/testsuite/g++.dg/warn/Warray-bounds-13.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a110855667782dac7b674d3e328b253b3b3c919b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWarray-bounds-13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a110855667782dac7b674d3e328b253b3b3c919b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWarray-bounds-13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWarray-bounds-13.C?ref=a110855667782dac7b674d3e328b253b3b3c919b", "patch": "@@ -24,7 +24,7 @@ void sink (void*);\n void warn_nothrow_new ()\n {\n   T (int32_t, 0, 0);          // { dg-warning \"array subscript 0 is outside array bounds of 'int32_t \\\\\\[0]'\" }\n-                              // { dg-message \"referencing an object of size \\\\d allocated by 'void\\\\\\* operator new\\\\\\(std::size_t, const std::nothrow_t.\\\\\\)'\" \"note\" { target *-*-* } .-1 }\n+                              // { dg-message \"object of size \\\\d allocated by '\\[^\\n\\r]*operator new\\[^\\n\\r]*'\" \"note\" { target *-*-* } .-1 }\n   T (int32_t, 1, 0);          // { dg-warning \"array subscript 'int32_t {aka (long )?int}\\\\\\[0]' is partly outside array bounds of 'unsigned char \\\\\\[1]'\" }\n   T (int32_t, 2, 0);         //  { dg-warning \"array subscript 'int32_t {aka (long )?int}\\\\\\[0]' is partly outside array bounds of 'unsigned char \\\\\\[2]'\" }\n   T (int32_t, 3, 0);         // { dg-warning \"array subscript 'int32_t {aka (long )?int}\\\\\\[0]' is partly outside array bounds of 'unsigned char \\\\\\[3]'\" }\n@@ -50,7 +50,7 @@ void warn_nothrow_array_new ()\n #define NEW(n)  new (std::nothrow) char [n]\n \n   T (int32_t, 0, 0);          // { dg-warning \"array subscript 0 is outside array bounds of 'int32_t \\\\\\[0]'\" }\n-                              // { dg-message \"referencing an object of size \\\\d allocated by 'void\\\\\\* operator new \\\\\\[]\\\\\\(std::size_t, const std::nothrow_t&\\\\\\)'\" \"note\" { target *-*-* } .-1 }\n+                              // { dg-message \"object of size \\\\d allocated by '\\[^\\n\\r]*operator new\\[^\\n\\r]*'\" \"note\" { target *-*-* } .-1 }\n   T (int32_t, 1, 0);          // { dg-warning \"array subscript 'int32_t {aka (long )?int}\\\\\\[0]' is partly outside array bounds of 'unsigned char \\\\\\[1]'\" }\n   T (int32_t, 2, 0);         //  { dg-warning \"array subscript 'int32_t {aka (long )?int}\\\\\\[0]' is partly outside array bounds of 'unsigned char \\\\\\[2]'\" }\n   T (int32_t, 3, 0);         // { dg-warning \"array subscript 'int32_t {aka (long )?int}\\\\\\[0]' is partly outside array bounds of 'unsigned char \\\\\\[3]'\" }"}, {"sha": "518f9bb26fabc0bb70841d1a67ee2436c64d7b49", "filename": "gcc/testsuite/g++.dg/warn/Warray-bounds-17.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a110855667782dac7b674d3e328b253b3b3c919b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWarray-bounds-17.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a110855667782dac7b674d3e328b253b3b3c919b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWarray-bounds-17.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWarray-bounds-17.C?ref=a110855667782dac7b674d3e328b253b3b3c919b", "patch": "@@ -8,7 +8,7 @@ void foo (int *);\n void\n bar (void)\n {\n-  A b;\t\t\t// { dg-message \"while referencing\" }\n+  A b;\t\t\t// { dg-message \"at offset -\\\\d into object 'b' of size 4\" \"note\" }\n   int *p = &b;\n   int *x = (p - 1);\t// { dg-warning \"outside array bounds\" }\n   foo (x);"}, {"sha": "a65b29e62690122cd983702288220d60af1b6520", "filename": "gcc/testsuite/g++.dg/warn/Warray-bounds-20.C", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a110855667782dac7b674d3e328b253b3b3c919b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWarray-bounds-20.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a110855667782dac7b674d3e328b253b3b3c919b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWarray-bounds-20.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWarray-bounds-20.C?ref=a110855667782dac7b674d3e328b253b3b3c919b", "patch": "@@ -35,7 +35,7 @@ void sink (void*);\n \n void warn_derived_ctor_access_new_decl ()\n {\n-  char a[sizeof (D1)];        // { dg-message \"referencing 'a'\" \"note\" }\n+  char a[sizeof (D1)];        // { dg-message \"at offset 1 into object 'a' of size 40\" \"note\" }\n   char *p = a;\n   ++p;\n   D1 *q = new (p) D1;\n@@ -44,15 +44,15 @@ void warn_derived_ctor_access_new_decl ()\n \n void warn_derived_ctor_access_new_alloc ()\n {\n-  char *p = (char*)operator new (sizeof (D1));    // { dg-message \"referencing an object of size \\\\d+ allocated by 'void\\\\\\* operator new\\\\\\(\" \"note\" }\n+  char *p = (char*)operator new (sizeof (D1));    // { dg-message \"at offset 1 into object of size \\\\d+ allocated by '\\[^\\n\\r]*operator new\\[^\\n\\r]*'\" \"note\" }\n   ++p;\n   D1 *q = new (p) D1;\n   sink (q);\n }\n \n void warn_derived_ctor_access_new_array_decl ()\n {\n-  char b[sizeof (D1) * 2];    // { dg-message \"referencing 'b'\" \"note\" }\n+  char b[sizeof (D1) * 2];    // { dg-message \"at offset \\\\d+ into object 'b' of size 80\" \"note\" }\n   char *p = b;\n   ++p;\n   D1 *q = new (p) D1[2];\n@@ -61,7 +61,7 @@ void warn_derived_ctor_access_new_array_decl ()\n \n void warn_derived_ctor_access_new_array_alloc ()\n {\n-  char *p = new char[sizeof (D1) * 2];            // { dg-message \"referencing an object of size \\\\d+ allocated by 'void\\\\\\* operator new \\\\\\[]\\\\\\(\" \"note\" }\n+  char *p = new char[sizeof (D1) * 2];            // { dg-message \"at offset \\\\d+ into object of size \\\\d+ allocated by '\\[^\\n\\r]*operator new\\[^\\n\\r]*\" \"note\" }\n   ++p;\n   D1 *q = new (p) D1[2];\n   sink (q);"}, {"sha": "44e5bd36127d16b934160ee93b66ce520125b73d", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-29.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a110855667782dac7b674d3e328b253b3b3c919b/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-29.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a110855667782dac7b674d3e328b253b3b3c919b/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-29.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-29.c?ref=a110855667782dac7b674d3e328b253b3b3c919b", "patch": "@@ -44,7 +44,7 @@ void test_narrow (void)\n   T (p1[-1]);\n   T (p1[ 0]);\n   T (p1[ 1]);\n-  T (p1[ 2]);                 /* { dg-warning \"array subscript \\\\\\[3, 4] is outside array bounds of .char\\\\\\[3].\" } */\n+  T (p1[ 2]);                 /* { dg-warning \"array subscript 3 is outside array bounds of .char\\\\\\[3].\" } */\n   T (p1[ 3]);                 /* { dg-warning \"array subscript \\\\\\[4, 5] is outside array bounds of .char\\\\\\[3].\" } */\n \n   T (&p1[-3]);                /* { dg-warning \"array subscript \\\\\\[-2, -1] is outside array bounds of .char\\\\\\[3].\" \"bug\" { xfail *-*-* } } */\n@@ -55,7 +55,7 @@ void test_narrow (void)\n   T (&p1[ 2]);\n   T (&p1[ 3]);                /* { dg-warning \"array subscript \\\\\\[4, 6] is outside array bounds of .char\\\\\\[3].\" \"bug\" { xfail *-*-* } } */\n \n-  T (p2[-4]);                 /* { dg-warning \"intermediate array offset 4 is outside array bounds of .char\\\\\\[3].\" } */\n+  T (p2[-4]);                 /* { dg-warning \"subscript \\\\\\[-2, -1\\\\\\] is outside array bounds of .char\\\\\\[3].\" } */\n   T (p2[-3]);\n   T (p2[-2]);\n   T (p2[-1]);\n@@ -64,19 +64,19 @@ void test_narrow (void)\n   /* Even though the lower bound of p3's offsets is in bounds, in order\n      to subtract 4 from p3 and get a dereferenceable pointer its value\n      would have to be out-of-bounds.  */\n-  T (p3[-4]);                 /* { dg-warning \"intermediate array offset 4 is outside array bounds of .char\\\\\\[3].\" } */\n+  T (p3[-4]);                 /* { dg-warning \"array subscript -1 is outside array bounds of .char\\\\\\[3].\" } */\n   T (p3[-3]);\n   T (p3[-2]);\n   T (p3[-1]);\n-  T (p3[ 0]);                 /* { dg-warning \"array subscript \\\\\\[3, 6] is outside array bounds of .char\\\\\\[3].\" } */\n+  T (p3[ 0]);                 /* { dg-warning \"array subscript 3 is outside array bounds of .char\\\\\\[3].\" } */\n \n   T (p4[-4]);                 /* { dg-warning \"intermediate array offset 4 is outside array bounds of .char\\\\\\[3].\" } */\n   T (p4[-3]);                 /* { dg-warning \"intermediate array offset 4 is outside array bounds of .char\\\\\\[3].\" } */\n   T (p4[-2]);                 /* { dg-warning \"intermediate array offset 4 is outside array bounds of .char\\\\\\[3].\" } */\n \n   /* The final subscripts below are invalid.  */\n-  T (p4[-1]);                 /* { dg-warning \"array subscript \\\\\\[3, 7] is outside array bounds of .char\\\\\\[3].\" } */\n-  T (p4[ 0]);                 /* { dg-warning \"array subscript \\\\\\[4, 8] is outside array bounds of .char\\\\\\[3].\" } */\n+  T (p4[-1]);                 /* { dg-warning \"array subscript 3 is outside array bounds of .char\\\\\\[3].\" } */\n+  T (p4[ 0]);                 /* { dg-warning \"array subscript \\\\\\[4, 5] is outside array bounds of .char\\\\\\[3].\" } */\n }\n \n \n@@ -114,7 +114,7 @@ void test_wide (void)\n   T (p1[ 0]);\n   T (p1[ 1]);\n   T (p1[ 2]);\n-  T (p1[ 3]);                  /* { dg-warning \"array subscript \\\\\\[4, 5] is outside array bounds of .\\[a-z \\]+\\\\\\[4].\" } */\n+  T (p1[ 3]);                  /* { dg-warning \"array subscript 4 is outside array bounds of .\\[a-z \\]+\\\\\\[4].\" } */\n \n   T (&p1[-1]);\n   T (&p1[ 0]);\n@@ -133,18 +133,18 @@ void test_wide (void)\n   /* Even though the lower bound of p3's offsets is in bounds, in order\n      to subtract 5 from p3 and get a dereferenceable pointer its value\n      would have to be out-of-bounds.  */\n-  T (p3[-5]);                 /* { dg-warning \"intermediate array offset 5 is outside array bounds of .\\[a-z \\]+\\\\\\[4].\" } */\n+  T (p3[-5]);                 /* { dg-warning \"array subscript \\\\\\[-2, -1\\\\\\] is outside array bounds of .\\[a-z \\]+\\\\\\[4].\" } */\n   T (p3[-4]);\n   T (p3[-3]);\n   T (p3[-2]);\n   T (p3[-1]);\n   T (p3[ 0]);\n-  T (p3[ 1]);                 /* { dg-warning \"array subscript \\\\\\[4, 7] is outside array bounds of .\\[a-z \\]+\\\\\\[4].\" } */\n+  T (p3[ 1]);                 /* { dg-warning \"array subscript 4 is outside array bounds of .\\[a-z \\]+\\\\\\[4].\" } */\n \n-  T (p4[-5]);                 /* { dg-warning \"intermediate array offset 5 is outside array bounds of .\\[a-z \\]+\\\\\\[4].\" } */\n+  T (p4[-5]);                 /* { dg-warning \"array subscript -1 is outside array bounds of .\\[a-z \\]+\\\\\\[4].\" } */\n   T (p4[-4]);\n   T (p4[-3]);\n   T (p4[-2]);\n   T (p4[-1]);\n-  T (p4[ 0]);                 /* { dg-warning \"array subscript \\\\\\[4, 8] is outside array bounds of .\\[a-z \\]+\\\\\\[4].\" } */\n+  T (p4[ 0]);                 /* { dg-warning \"array subscript 4 is outside array bounds of .\\[a-z \\]+\\\\\\[4].\" } */\n }"}, {"sha": "b837ad0c36cf1cd8a03eaf2c4a5ae7000314094c", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-30.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a110855667782dac7b674d3e328b253b3b3c919b/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-30.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a110855667782dac7b674d3e328b253b3b3c919b/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-30.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-30.c?ref=a110855667782dac7b674d3e328b253b3b3c919b", "patch": "@@ -120,7 +120,7 @@ void test_global_short_2dim_array (void)\n   T (&p[1]);\n   T (&p[2]);\n   T (&p[3]);\n-  T (&p[16]);       /* { dg-warning \"subscript 16 is \\(above|outside\\) array bounds of .short int\\\\\\[3]\" } */\n+  T (&p[16]);       /* { dg-warning \"subscript 16 is \\(above|outside\\) array bounds of .short int\\\\\\[3]\" \"pr??????\" { xfail *-*-* } } */\n   T (&p[MAX]);      /* { dg-warning \"subscript -?\\[0-9\\]+ is \\(above|outside\\) array bounds of .short int\\\\\\[3]\" } */\n }\n "}, {"sha": "921461a549d61341d254b6034e1fb1e98d040778", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-31.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a110855667782dac7b674d3e328b253b3b3c919b/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-31.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a110855667782dac7b674d3e328b253b3b3c919b/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-31.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-31.c?ref=a110855667782dac7b674d3e328b253b3b3c919b", "patch": "@@ -174,7 +174,7 @@ void narrow_ptr_deref_range (ptrdiff_t i, size_t j)\n   T (*p);\n \n   p = S1 + SR (2, 3);\n-  T (*p);                     /* { dg-warning \"array subscript \\\\\\[2, 3] is outside array bounds of .char\\\\\\[2].\" } */\n+  T (*p);                     /* { dg-warning \"array subscript 2 is outside array bounds of .char\\\\\\[2].\" } */\n \n   p = S1 + SR (9, 99);\n   T (*p);                     /* { dg-warning \"array subscript \\\\\\[9, 99] is outside array bounds of .char\\\\\\[2].\" } */\n@@ -198,7 +198,7 @@ void narrow_ptr_deref_range (ptrdiff_t i, size_t j)\n   T (*p);\n \n   p = S8 + SR (9, 123);\n-  T (*p);                     /* { dg-warning \"array subscript \\\\\\[9, 123] is outside array bounds of .char\\\\\\[9].\" } */\n+  T (*p);                     /* { dg-warning \"array subscript 9 is outside array bounds of .char\\\\\\[9].\" } */\n \n   {\n     const char *p1 = S3 + i;\n@@ -226,7 +226,7 @@ void narrow_ptr_deref_range (ptrdiff_t i, size_t j)\n     T (*p1);\n     T (*p2);\n     T (*p3);\n-    T (*p4);                  /* { dg-warning \"array subscript \\\\\\[4, \\[0-9\\]+] is outside array bounds of .char\\\\\\[4].\" } */\n+    T (*p4);                  /* { dg-warning \"array subscript 4 is outside array bounds of .char\\\\\\[4].\" } */\n     T (*p5);                  /* { dg-warning \"array subscript \\\\\\[5, \\[0-9\\]+] is outside array bounds of .char\\\\\\[4].\" } */\n   }\n }\n@@ -241,7 +241,7 @@ void narrow_ptr_index_range (void)\n   T (p[SR (-8, 0)]);\n   T (p[SR (0, MAX)]);\n   T (p[SR (1, 9)]);\n-  T (p[SR (8, 9)]);           /* { dg-warning \"array subscript \\\\\\[8, 9] is outside array bounds of .char\\\\\\[8].\" } */\n+  T (p[SR (8, 9)]);           /* { dg-warning \"array subscript 8 is outside array bounds of .char\\\\\\[8].\" } */\n \n   p = S7 + SR (4, 6);\n   T (p[5]);                   /* { dg-warning \"array subscript \\\\\\[9, 11] is outside array bounds of .char\\\\\\[8].\" } */"}, {"sha": "02dac6522114a9b33ef0e0089ae06442e873da4a", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-32.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a110855667782dac7b674d3e328b253b3b3c919b/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a110855667782dac7b674d3e328b253b3b3c919b/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-32.c?ref=a110855667782dac7b674d3e328b253b3b3c919b", "patch": "@@ -87,7 +87,7 @@ void wide_ptr_deref_range (ptrdiff_t i, size_t j)\n   T (*p);\n \n   p = W8 + SR (9, 123);\n-  T (*p);                     /* { dg-warning \"array subscript \\\\\\[9, 123] is outside array bounds of .\\[a-z \\]+\\\\\\[9].\" } */\n+  T (*p);                     /* { dg-warning \"array subscript 9 is outside array bounds of .\\[a-z \\]+\\\\\\[9].\" } */\n }\n \n void wide_ptr_index_range (void)\n@@ -99,7 +99,7 @@ void wide_ptr_index_range (void)\n   T (p[SR (-8, 0)]);\n   T (p[SR (0, MAX)]);\n   T (p[SR (1, 9)]);\n-  T (p[SR (8, 9)]);           /* { dg-warning \"array subscript \\\\\\[8, 9] is outside array bounds of .\\[a-z \\]+\\\\\\[8].\" } */\n+  T (p[SR (8, 9)]);           /* { dg-warning \"array subscript 8 is outside array bounds of .\\[a-z \\]+\\\\\\[8].\" } */\n \n   p = W7 + SR (4, 6);\n   T (p[5]);                   /* { dg-warning \"array subscript \\\\\\[9, 11] is outside array bounds of .\\[a-z \\]+\\\\\\[8].\" } */\n@@ -123,7 +123,7 @@ void wide_ptr_index_range_1 (void)\n     int i = SR (1, 2);\n     const wchar_t *p1 = W2 + i;\n \n-    T (p1[2]);                /* { dg-warning \"array subscript \\\\\\[3, 4] is outside array bounds of .\\[a-z \\]+\\\\\\[3].\" } */\n+    T (p1[2]);                /* { dg-warning \"array subscript 3 is outside array bounds of .\\[a-z \\]+\\\\\\[3].\" } */\n   }\n }\n \n@@ -140,17 +140,17 @@ void wide_ptr_index_range_chain (void)\n     T (p1[-1]);\n     T (p1[0]);\n     T (p1[1]);\n-    T (p1[2]);                /* { dg-warning \"array subscript \\\\\\[3, 4] is outside array bounds of .\\[a-z \\]+\\\\\\[3].\" } */\n+    T (p1[2]);                /* { dg-warning \"array subscript 3 is outside array bounds of .\\[a-z \\]+\\\\\\[3].\" } */\n \n-    T (p2[-5]);               /* { dg-warning \"array subscript \\\\\\[-3, -1] is outside array bounds of .\\[a-z \\]+\\\\\\[3].\" } */\n-    T (p2[-4]);\n+    T (p2[-5]);               /* { dg-warning \"array subscript \\\\\\[-3, -2] is outside array bounds of .\\[a-z \\]+\\\\\\[3].\" } */\n+    T (p2[-4]);               /* { dg-warning \"array subscript \\\\\\[-2, -1] is outside array bounds of .\\[a-z \\]+\\\\\\[3].\" } */\n     T (p2[-1]);\n     T (p2[0]);\n-    T (p2[1]);                /* { dg-warning \"array subscript \\\\\\[3, 5] is outside array bounds of .\\[a-z \\]+\\\\\\[3].\" } */\n+    T (p2[1]);                /* { dg-warning \"array subscript 3 is outside array bounds of .\\[a-z \\]+\\\\\\[3].\" } */\n \n-    T (p3[0]);                /* { dg-warning \"array subscript \\\\\\[3, 6] is outside array bounds of .\\[a-z \\]+\\\\\\[3].\" } */\n-    T (p3[1]);                /* { dg-warning \"array subscript \\\\\\[4, 7] is outside array bounds of .\\[a-z \\]+\\\\\\[3].\" } */\n-    T (p3[9999]);             /* { dg-warning \"array subscript \\\\\\[10002, 10005] is outside array bounds of .\\[a-z \\]+\\\\\\[3].\" \"\" { target size20plus} } */\n+    T (p3[0]);                /* { dg-warning \"array subscript 3 is outside array bounds of .\\[a-z \\]+\\\\\\[3].\" } */\n+    T (p3[1]);                /* { dg-warning \"array subscript 4 is outside array bounds of .\\[a-z \\]+\\\\\\[3].\" } */\n+    T (p3[9999]);             /* { dg-warning \"array subscript 10002 is outside array bounds of .\\[a-z \\]+\\\\\\[3].\" \"\" { target size20plus} } */\n     /* { dg-warning \"array subscript \\\\\\[-6382, -6379] is outside array bounds of .\\[a-z \\]+\\\\\\[3].\" \"\" { target { ! size20plus } } .-1 } */\n     /* Large offsets are indistinguishable from negative values.  */\n     T (p3[DIFF_MAX]);         /* { dg-warning \"array subscript\" \"bug\" { xfail *-*-* } } */\n@@ -166,9 +166,9 @@ void wide_ptr_index_range_chain (void)\n     T (p1[-2]);\n     T (p1[1]);\n     T (p1[2]);\n-    T (p1[3]);                /* { dg-warning \"array subscript \\\\\\[4, 5] is outside array bounds of .\\[a-z \\]+\\\\\\[4].\" } */\n+    T (p1[3]);                /* { dg-warning \"array subscript 4 is outside array bounds of .\\[a-z \\]+\\\\\\[4].\" } */\n \n-    T (p3[1]);                /* { dg-warning \"array subscript \\\\\\[4, 7] is outside array bounds of .\\[a-z \\]+\\\\\\[4].\" } */\n+    T (p3[1]);                /* { dg-warning \"array subscript 4 is outside array bounds of .\\[a-z \\]+\\\\\\[4].\" } */\n   }\n }\n \n@@ -180,5 +180,5 @@ void wide_ptr_index_range_4 (void)\n   const wchar_t *p3 = p2 + i;\n   const wchar_t *p4 = p3 + i;\n \n-  T (p4[1]);                  /* { dg-warning \"array subscript \\\\\\[5, 9] is outside array bounds of .\\[a-z \\]+\\\\\\[5].\" } */\n+  T (p4[1]);                  /* { dg-warning \"array subscript 5 is outside array bounds of .\\[a-z \\]+\\\\\\[5].\" } */\n }"}, {"sha": "c7217ad4f7b8eeb47dd8114b3939a8288c209f6b", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-52.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a110855667782dac7b674d3e328b253b3b3c919b/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-52.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a110855667782dac7b674d3e328b253b3b3c919b/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-52.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-52.c?ref=a110855667782dac7b674d3e328b253b3b3c919b", "patch": "@@ -83,17 +83,17 @@ void ptr_idx_range (void)\n \n   i = SR (0, 1);\n \n-  T (i, (int[]){ });            // { dg-warning \"array subscript \\\\\\[0, 1] is outside array bounds of 'int\\\\\\[0]'\" }\n+  T (i, (int[]){ });            // { dg-warning \"array subscript 0 is outside array bounds of 'int\\\\\\[0]'\" }\n   T (i, (int[]){ 1 });\n \n   i = SR (1, 2);\n-  T (i, (int[]){ 1 });          // { dg-warning \"array subscript \\\\\\[1, 2] is outside array bounds of 'int\\\\\\[1]'\" }\n+  T (i, (int[]){ 1 });          // { dg-warning \"array subscript 1 is outside array bounds of 'int\\\\\\[1]'\" }\n \n   i = SR (2, 3);\n   T (i, (int[]){ 1, 2, 3 });\n \n   i = SR (3, 4);\n-  T (i, (int[]){ 2, 3, 4 });          // { dg-warning \"array subscript \\\\\\[3, 4] is outside array bounds of 'int\\\\\\[3]'\" }\n+  T (i, (int[]){ 2, 3, 4 });          // { dg-warning \"array subscript 3 is outside array bounds of 'int\\\\\\[3]'\" }\n }\n \n /* Some of the invalid accesses above also trigger -Wuninitialized."}, {"sha": "591cca28d27efc890ba044a140dc28f710c80679", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-53.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a110855667782dac7b674d3e328b253b3b3c919b/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-53.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a110855667782dac7b674d3e328b253b3b3c919b/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-53.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-53.c?ref=a110855667782dac7b674d3e328b253b3b3c919b", "patch": "@@ -83,17 +83,17 @@ void ptr_idx_range (void)\n \n   i = SR (0, 1);\n \n-  T (i, (int[]){ });            // { dg-warning \"array subscript \\\\\\[0, 1] is outside array bounds of 'int\\\\\\[0]'\" }\n+  T (i, (int[]){ });            // { dg-warning \"array subscript 0 is outside array bounds of 'int\\\\\\[0]'\" }\n   T (i, (int[]){ 1 });\n \n   i = SR (1, 2);\n-  T (i, (int[]){ 1 });          // { dg-warning \"array subscript \\\\\\[1, 2] is outside array bounds of 'int\\\\\\[1]'\" }\n+  T (i, (int[]){ 1 });          // { dg-warning \"array subscript 1 is outside array bounds of 'int\\\\\\[1]'\" }\n \n   i = SR (2, 3);\n   T (i, (int[]){ 1, 2, 3 });\n \n   i = SR (3, 4);\n-  T (i, (int[]){ 2, 3, 4 });          // { dg-warning \"array subscript \\\\\\[3, 4] is outside array bounds of 'int\\\\\\[3]'\" }\n+  T (i, (int[]){ 2, 3, 4 });          // { dg-warning \"array subscript 3 is outside array bounds of 'int\\\\\\[3]'\" }\n }\n \n /* Some of the invalid accesses above also trigger -Wuninitialized."}, {"sha": "616145b65a61a1414363583df44ddde64be599a9", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-58.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a110855667782dac7b674d3e328b253b3b3c919b/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-58.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a110855667782dac7b674d3e328b253b3b3c919b/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-58.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-58.c?ref=a110855667782dac7b674d3e328b253b3b3c919b", "patch": "@@ -36,7 +36,7 @@ extern struct Ax ax;\n \n void fax_extern (void)\n {\n-  sink (strlen (ax.a - 2));     // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr93514\" { xfail *-*-* } }\n+  sink (strlen (ax.a - 2));     // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr93514\" }\n   sink (strlen (ax.a - 1));     // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr93514\" { xfail *-*-* } }\n   sink (strlen (ax.a));\n   sink (strlen (ax.a + 123));"}, {"sha": "530e2c564528193be971a13fed8bd259c9e5a57c", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-63.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a110855667782dac7b674d3e328b253b3b3c919b/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-63.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a110855667782dac7b674d3e328b253b3b3c919b/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-63.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-63.c?ref=a110855667782dac7b674d3e328b253b3b3c919b", "patch": "@@ -14,7 +14,7 @@ void sink (void*);\n \n void byte_store_to_decl (void)\n {\n-  struct S6 { char a[6]; } s;   // { dg-message \"referencing 's'\" }\n+  struct S6 { char a[6]; } s;   // { dg-message \"at offset 6 into object 's' of size 6\" \"note\" }\n \n   char *p = (char*)&s;\n \n@@ -27,7 +27,7 @@ void byte_store_to_decl (void)\n \n void word_store_to_decl (void)\n {\n-  struct S6 { char a[6]; } s;   // { dg-message \"referencing 's'\" }\n+  struct S6 { char a[6]; } s;   // { dg-message \"at offset 5 into object 's' of size 6\" \"note\" }\n \n   char *p = (char*)&s;\n \n@@ -43,7 +43,7 @@ void word_store_to_decl (void)\n void word_store_to_alloc (void)\n {\n   struct S6 { char a[6]; } *p;\n-  p = alloca (sizeof *p);       // { dg-message \"referencing an object of size 6 allocated by 'alloca'\" }\n+  p = alloca (sizeof *p);       // { dg-message \"at offset 5 into object of size 6 allocated by 'alloca'\" \"note\" }\n \n   int16_t *q = (int16_t*)((char*)p + 1);\n "}, {"sha": "6ab3398c762d908556884bb9f7f2c94e9194eb2f", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-66.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a110855667782dac7b674d3e328b253b3b3c919b/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-66.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a110855667782dac7b674d3e328b253b3b3c919b/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-66.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-66.c?ref=a110855667782dac7b674d3e328b253b3b3c919b", "patch": "@@ -117,22 +117,22 @@ void test_alloca_int16_range (unsigned n)\n   }\n \n   {\n-    p = alloca (UR (0, 1));   // { dg-message \"object of size between 0 and 1 allocated by '__builtin_alloca'\" }\n+    p = alloca (UR (0, 1));   // { dg-message \"at offset \\\\d+ into object of size \\\\\\[0, 1] allocated by '__builtin_alloca'\" \"note\" }\n     sink (p);\n     T (p[0]);                 // { dg-warning \"subscript 'int16_t {aka short int}\\\\\\[0\\\\\\]' is partly outside array bounds of 'unsigned char\\\\\\[1]'\" }\n     T (p[1]);                 // { dg-warning \"subscript 1 is outside array bounds of 'int16_t\\\\\\[0]'\" }\n   }\n \n   {\n-    p = alloca (UR (0, 2));   // { dg-message \"object of size between 0 and 2 allocated by '__builtin_alloca'\" }\n+    p = alloca (UR (0, 2));   // { dg-message \"at offset \\\\d+ into object of size \\\\\\[0, 2] allocated by '__builtin_alloca'\" \"note\" }\n     sink (p);\n     sink (p[0]);\n     sink (p[1]);              // { dg-warning \"subscript 1 is outside array bounds of 'int16_t\\\\\\[1]'\" }\n     sink (p[2]);              // { dg-warning \"subscript 2 is outside array bounds of 'int16_t\\\\\\[1\\\\\\]'\" }\n   }\n \n   {\n-    p = alloca (UR (0, 3));   // { dg-message \"object of size between 0 and 3 allocated by '__builtin_alloca'\" }\n+    p = alloca (UR (0, 3));   // { dg-message \"at offset \\\\d+ into object of size \\\\\\[0, 3] allocated by '__builtin_alloca'\" \"note\" }\n     sink (p);\n     T (p[0]);\n     T (p[1]);                 // { dg-warning \"subscript 'int16_t {aka short int}\\\\\\[1\\\\\\]' is partly outside array bounds of 'unsigned char\\\\\\[3]'\" }\n@@ -141,7 +141,7 @@ void test_alloca_int16_range (unsigned n)\n   }\n \n   {\n-    p = alloca (UR (1, 3));    // { dg-message \"object of size between 1 and 3 allocated by '__builtin_alloca'\" }\n+    p = alloca (UR (1, 3));    // { dg-message \"at offset 1|2|3 into object of size \\\\\\[1, 3] allocated by '__builtin_alloca'\" \"note\" }\n     sink (p);\n     T (p[0]);\n     T (p[1]);                 // { dg-warning \"subscript 'int16_t {aka short int}\\\\\\[1\\\\\\]' is partly outside array bounds of 'unsigned char\\\\\\[3]'\" }\n@@ -150,7 +150,7 @@ void test_alloca_int16_range (unsigned n)\n   }\n \n   {\n-    p = alloca (UR (2, 3));    // { dg-message \"object of size between 2 and 3 allocated by '__builtin_alloca'\" }\n+    p = alloca (UR (2, 3));    // { dg-message \"at offset 2|4 into object of size \\\\\\[2, 3] allocated by '__builtin_alloca'\" \"note\" }\n     sink (p);\n     T (p[0]);\n     T (p[1]);                 // { dg-warning \"subscript 'int16_t {aka short int}\\\\\\[1\\\\\\]' is partly outside array bounds of 'unsigned char\\\\\\[3]'\" }\n@@ -159,7 +159,7 @@ void test_alloca_int16_range (unsigned n)\n   }\n \n   {\n-    p = alloca (UR (3, 4));    // { dg-message \"object of size between 3 and 4 allocated by '__builtin_alloca'\" }\n+    p = alloca (UR (3, 4));    // { dg-message \"at offset 4|6 into object of size \\\\\\[3, 4] allocated by '__builtin_alloca'\" \"note\" }\n     sink (p);\n     T (p[0]);\n     T (p[1]);"}, {"sha": "80503f8d217e7e173893f5f7619ece75d8739da9", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-69.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a110855667782dac7b674d3e328b253b3b3c919b/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-69.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a110855667782dac7b674d3e328b253b3b3c919b/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-69.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-69.c?ref=a110855667782dac7b674d3e328b253b3b3c919b", "patch": "@@ -1,6 +1,6 @@\n /* Verify that storing a bigger vector into smaller space is diagnosed.\n    { dg-do compile }\n-   { dg-options \"-O2 -Warray-bounds\" } */\n+   { dg-options \"-O2 -Warray-bounds -Wno-stringop-overflow\" } */\n \n typedef __INT16_TYPE__                         int16_t;\n typedef __attribute__ ((__vector_size__ (32))) char C32;"}, {"sha": "6487613374dd1d2146c51dd5ecd571a348e995ea", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-77.c", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a110855667782dac7b674d3e328b253b3b3c919b/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-77.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a110855667782dac7b674d3e328b253b3b3c919b/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-77.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-77.c?ref=a110855667782dac7b674d3e328b253b3b3c919b", "patch": "@@ -0,0 +1,135 @@\n+/* PR middle-end/100137 - -Warray-bounds false positive on varying offset\n+   plus negative\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+extern char ax[], a1[1], a2[2], a3[3], a4[4], a5[5];\n+\n+int* ptr;\n+#define X (*ptr++)\n+\n+\n+__attribute__ ((noipa)) void\n+array_plus_var_minus_cstint (int i, int j)\n+{\n+  {\n+    const char *p = ax;\n+    p += i;\n+    X = p[-1];\n+    X = p[-123];\n+  }\n+\n+  {\n+    const char *p = a1;\n+    p += i;\n+    X = p[-1];      // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+    X = p[-2];      // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+    X = p[-3];      // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+    X = p[-4];      // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  }\n+\n+  {\n+    const char *p = a2;\n+    p += i;\n+    X = p[-1];      // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+    X = p[-2];      // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+    X = p[-3];      // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+    X = p[-4];      // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  }\n+\n+  {\n+    const char *p = a3;\n+    p += i;\n+    X = p[-1];      // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+    X = p[-2];      // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+    X = p[-3];      // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+    X = p[-4];      // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+    X = p[-5];      // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  }\n+\n+  {\n+    const char *p = a4;\n+    p += i;\n+    X = p[-1];      // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+    X = p[-2];      // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+    X = p[-3];      // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+    X = p[-4];      // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+    X = p[-5];      // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+    X = p[-6];      // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  }\n+\n+  {\n+    const char *p = a5;\n+    p += i;\n+    p += j;\n+    X = p[-1];      // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+    X = p[-2];      // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+    X = p[-3];      // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+    X = p[-4];      // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+    X = p[-5];      // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+    X = p[-6];      // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  }\n+}\n+\n+\n+__attribute__ ((noipa)) void\n+array_plus_var_minus_cstlong (long i, long j)\n+{\n+  {\n+    const char *p = ax;\n+    p += i;\n+    X = p[-1];\n+    X = p[-123];\n+  }\n+\n+  {\n+    const char *p = a1;\n+    p += i;\n+    X = p[-1];      // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+    X = p[-2];      // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+    X = p[-3];      // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+    X = p[-4];      // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  }\n+\n+  {\n+    const char *p = a2;\n+    p += i;\n+    X = p[-1];      // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+    X = p[-2];      // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+    X = p[-3];      // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+    X = p[-4];      // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  }\n+\n+  {\n+    const char *p = a3;\n+    p += i;\n+    X = p[-1];      // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+    X = p[-2];      // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+    X = p[-3];      // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+    X = p[-4];      // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+    X = p[-5];      // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  }\n+\n+  {\n+    const char *p = a4;\n+    p += i;\n+    X = p[-1];      // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+    X = p[-2];      // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+    X = p[-3];      // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+    X = p[-4];      // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+    X = p[-5];      // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+    X = p[-6];      // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  }\n+\n+  {\n+    const char *p = a5;\n+    p += i;\n+    p += j;\n+    X = p[-1];      // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+    X = p[-2];      // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+    X = p[-3];      // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+    X = p[-4];      // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+    X = p[-5];      // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+    X = p[-6];      // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  }\n+}"}, {"sha": "73c335fd8a6bac83e2c9aa6c70894c1d429bd511", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-78.c", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a110855667782dac7b674d3e328b253b3b3c919b/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-78.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a110855667782dac7b674d3e328b253b3b3c919b/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-78.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-78.c?ref=a110855667782dac7b674d3e328b253b3b3c919b", "patch": "@@ -0,0 +1,109 @@\n+/* PR tree-optimization/99475 - bogus -Warray-bounds accessing an array\n+   element of empty structs\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -Wno-strict-aliasing\" } */\n+\n+typedef _Bool bool;\n+\n+#define NOIPA __attribute__ ((noipa))\n+\n+struct S { };\n+\n+extern struct S sa3[3];\n+extern struct S sa2_3[2][3];\n+extern struct S sa3_4_5[3][4][5];\n+\n+void sink (void*);\n+\n+\n+NOIPA void access_sa3 (void)\n+{\n+  ((bool*)sa3)[0] = __LINE__;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  ((bool*)sa3)[1] = __LINE__;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  ((bool*)sa3)[2] = __LINE__;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  ((bool*)sa3)[3] = __LINE__;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+NOIPA void access_sa3_ptr (void)\n+{\n+  bool *p = (bool*)&sa3[0];\n+\n+  p[0] = __LINE__;        // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  p[1] = __LINE__;        // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  p[2] = __LINE__;        // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  p[3] = __LINE__;        // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+NOIPA void access_sa2_3_ptr (void)\n+{\n+  bool *p = (bool*)&sa2_3[0][0];\n+\n+  p[0] = __LINE__;        // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  p[1] = __LINE__;        // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  p[2] = __LINE__;        // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  p[6] = __LINE__;        // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+NOIPA void access_sa3_4_5_ptr (struct S s, int i)\n+{\n+  bool *p = (bool*)&sa3_4_5[0][0][0];\n+\n+  p[0] = __LINE__;        // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  p[1] = __LINE__;        // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  p[2] = __LINE__;        // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  p[60] = __LINE__;       // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+\n+NOIPA void access_vla3 (struct S s, unsigned n)\n+{\n+  struct S vla3[3 < n ? 3 : n];\n+\n+  ((bool*)vla3)[0] = __LINE__;    // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  ((bool*)vla3)[1] = __LINE__;    // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  ((bool*)vla3)[2] = __LINE__;    // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  ((bool*)vla3)[3] = __LINE__;    // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+\n+  sink (vla3);\n+}\n+\n+NOIPA void access_vla3_ptr (struct S s, unsigned n)\n+{\n+  struct S vla3[3 < n ? 3 : n];\n+  bool *p = (bool*)&vla3[0];\n+\n+  p[0] = __LINE__;        // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  p[1] = __LINE__;        // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  p[2] = __LINE__;        // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  p[3] = __LINE__;        // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+\n+  sink (vla3);\n+}\n+\n+NOIPA void access_vla2_3_ptr (struct S s, unsigned n)\n+{\n+  struct S vla2_3[2 < n ? 2 : n][3 < n ? 3 : n];\n+  bool *p = (bool*)&vla2_3[0][0];\n+\n+  p[0] = __LINE__;        // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  p[1] = __LINE__;        // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  p[2] = __LINE__;        // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  p[6] = __LINE__;        // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+\n+  sink (vla2_3);\n+}\n+\n+NOIPA void access_vla3_4_5_ptr (struct S s, unsigned n)\n+{\n+  struct S vla3_4_5[3 < n ? 3 : n][4 < n ? 4 : n][5 < n ? 5 : n];\n+  bool *p = (bool*)&vla3_4_5[0][0][0];\n+\n+  p[0] = __LINE__;        // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  p[1] = __LINE__;        // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  p[2] = __LINE__;        // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  p[60] = __LINE__;       // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+\n+  sink (vla3_4_5);\n+}\n+\n+// { dg-prune-output \"empty struct has size 0 in C\" }"}, {"sha": "b44ac9d3aa280da3910ea734beb279bc5a289ddd", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-79.c", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a110855667782dac7b674d3e328b253b3b3c919b/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-79.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a110855667782dac7b674d3e328b253b3b3c919b/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-79.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-79.c?ref=a110855667782dac7b674d3e328b253b3b3c919b", "patch": "@@ -0,0 +1,112 @@\n+/* PR tree-optimization/99475 - bogus -Warray-bounds accessing an array\n+   element of empty structs\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+struct S\n+{\n+#if SOME_CONFIG_MACRO\n+  /* Suppose the contents are empty in the development configuration\n+     but non-empty in others.  Out of bounds accesses to elements of\n+     the arrays below should be diagnosed in all configurations,\n+     including when S is empty, even if they are folded away.  */\n+  int member;\n+#endif\n+};\n+\n+extern struct S sa3[3];\n+extern struct S sa2_3[2][3];\n+extern struct S sa3_4_5[3][4][5];\n+\n+void sink (void*);\n+\n+\n+void access_sa3 (void)\n+{\n+  sa3[0] = (struct S){ };\n+  sa3[1] = (struct S){ };\n+  sa3[2] = (struct S){ };\n+  sa3[3] = (struct S){ };       // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr?????\" { xfail *-*-* } }\n+}\n+\n+void access_sa3_ptr (void)\n+{\n+  struct S *p = &sa3[0];\n+\n+  p[0] = (struct S){ };         // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+  p[1] = (struct S){ };         // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+  p[2] = (struct S){ };         // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+  p[3] = (struct S){ };         // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr?????\" { xfail *-*-* } }\n+}\n+\n+void access_sa2_3_ptr (void)\n+{\n+  struct S *p = &sa2_3[0][0];\n+\n+  p[0] = (struct S){ };         // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+  p[1] = (struct S){ };         // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+  p[2] = (struct S){ };         // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+  p[6] = (struct S){ };         // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr?????\" { xfail *-*-* } }\n+}\n+\n+void access_sa3_4_5_ptr (struct S s, int i)\n+{\n+  struct S *p = &sa3_4_5[0][0][0];\n+\n+  p[0] = (struct S){ };         // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+  p[1] = (struct S){ };         // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+  p[2] = (struct S){ };         // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+  p[60] = (struct S){ };        // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr?????\" { xfail *-*-* } }\n+}\n+\n+\n+void access_vla3 (struct S s, unsigned n)\n+{\n+  struct S vla3[3 < n ? 3 : n];\n+\n+  vla3[0] = (struct S){ };\n+  vla3[1] = (struct S){ };\n+  vla3[2] = (struct S){ };\n+  vla3[3] = (struct S){ };       // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr?????\" { xfail *-*-* } }\n+\n+  sink (vla3);\n+}\n+\n+void access_vla3_ptr (struct S s, unsigned n)\n+{\n+  struct S vla3[3 < n ? 3 : n];\n+  struct S *p = &vla3[0];\n+\n+  p[0] = (struct S){ };         // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+  p[1] = (struct S){ };         // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+  p[2] = (struct S){ };         // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+  p[3] = (struct S){ };         // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr?????\" { xfail *-*-* } }\n+\n+  sink (vla3);\n+}\n+\n+void access_vla2_3_ptr (struct S s, unsigned n)\n+{\n+  struct S vla2_3[2 < n ? 2 : n][3 < n ? 3 : n];\n+  struct S *p = &vla2_3[0][0];\n+\n+  p[0] = (struct S){ };         // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+  p[1] = (struct S){ };         // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+  p[2] = (struct S){ };         // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+  p[6] = (struct S){ };         // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr?????\" { xfail *-*-* } }\n+\n+  sink (vla2_3);\n+}\n+\n+void access_vla3_4_5_ptr (struct S s, unsigned n)\n+{\n+  struct S vla3_4_5[3 < n ? 3 : n][4 < n ? 4 : n][5 < n ? 5 : n];\n+  struct S *p = &vla3_4_5[0][0][0];\n+\n+  p[0] = (struct S){ };         // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+  p[1] = (struct S){ };         // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+  p[2] = (struct S){ };         // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n+  p[60] = (struct S){ };        // { dg-warning \"\\\\\\[-Warray-bounds\" \"pr?????\" { xfail *-*-* } }\n+\n+  sink (vla3_4_5);\n+}"}, {"sha": "d9ca3447eb963c24ea460f89b6d7177cbf67cc89", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-34.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a110855667782dac7b674d3e328b253b3b3c919b/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-34.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a110855667782dac7b674d3e328b253b3b3c919b/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-34.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-34.c?ref=a110855667782dac7b674d3e328b253b3b3c919b", "patch": "@@ -112,7 +112,7 @@ void s2_warn_cstoff_cstidx (struct S2 *p)\n void s2_warn_varoff_cstdix (struct S2 *p, int i)\n {\n   char *q = p->a + i;\n-  q[2] = __LINE__;            // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  q[2] = __LINE__;            // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" }\n }\n \n void s2_warn_cstoff_varidx (struct S2 *p, int i)\n@@ -235,8 +235,8 @@ void si0_warn_cstoff_cstidx (struct Si0 *p)\n void si0_warn_varoff_cstdix (struct Si0 *p, int i)\n {\n   char *q = p->a + i;\n-  q[1] = __LINE__;            // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n-  q[9] = __LINE__;            // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  q[1] = __LINE__;            // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" }\n+  q[9] = __LINE__;            // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" }\n }\n \n void si0_warn_cstoff_varidx (struct Si0 *p, int i)\n@@ -248,5 +248,5 @@ void si0_warn_cstoff_varidx (struct Si0 *p, int i)\n void si0_warn_varoff_varidx (struct Si0 *p, int i, int j)\n {\n   char *q = p->a + i;\n-  q[j] = __LINE__;            // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  q[j] = __LINE__;            // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" }\n }"}, {"sha": "6412874e2f958859f9459c67ad4558bb54de3dcf", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-47.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a110855667782dac7b674d3e328b253b3b3c919b/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-47.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a110855667782dac7b674d3e328b253b3b3c919b/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-47.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-47.c?ref=a110855667782dac7b674d3e328b253b3b3c919b", "patch": "@@ -24,22 +24,22 @@ void nowarn_c32 (char c)\n   sink (p);\n }\n \n-/* The tests below fail as a result of the hack for PR 96963.  However,\n-   with -Wall, the invalid stores are diagnosed by -Warray-bounds which\n-   runs before vectorization and so doesn't need the hack.  If/when\n-   -Warray changes to use compute_objsize() this will need adjusting.  */\n+/* The tests below failed as a result of the hack for PR 96963.  However,\n+   with -Wall, the invalid stores were diagnosed by -Warray-bounds which\n+   runs before vectorization and so doesn't need the hack.  Now that\n+   -Warray-bounds has changed to use compute_objsize() the tests pass.  */\n \n void warn_c32 (char c)\n {\n-  extern char warn_a32[32];   // { dg-message \"at offset 32 into destination object 'warn_a32' of size 32\" \"pr97027\" { xfail *-*-* } }\n+  extern char warn_a32[32];   // { dg-message \"at offset 32 into destination object 'warn_a32' of size 32\" \"pr97027\" }\n \n   void *p = warn_a32 + 1;\n-  *(C32*)p = (C32){ c };      // { dg-warning \"writing 1 byte into a region of size 0\" \"pr97027\" { xfail *-*-* } }\n+  *(C32*)p = (C32){ c };      // { dg-warning \"writing 1 byte into a region of size 0\" \"pr97027\" }\n \n   /* Verify a local variable too. */\n   char a32[32];\n   p = a32 + 1;\n-  *(C32*)p = (C32){ c };      // { dg-warning \"writing 1 byte into a region of size 0\" \"pr97027\" { xfail *-*-* } }\n+  *(C32*)p = (C32){ c };      // { dg-warning \"writing 1 byte into a region of size 0\" \"pr97027\" }\n   sink (p);\n }\n "}, {"sha": "93c54c646c069f0d466003241f201b49dad31b65", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-61.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a110855667782dac7b674d3e328b253b3b3c919b/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-61.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a110855667782dac7b674d3e328b253b3b3c919b/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-61.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-61.c?ref=a110855667782dac7b674d3e328b253b3b3c919b", "patch": "@@ -65,7 +65,7 @@ void nowarn_cond_escape (int c, int *x)\n void warn_cond_escape (int c, int *x)\n {\n   extern char a3_2[3];\n-  extern char a5_2[5];        // { dg-message \"at offset 5 into destination object 'a5_2'\" }\n+  extern char a5_2[5];        // { dg-message \"at offset 5 into object 'a5_2'\" }\n \n   char *p;\n   if (c)\n@@ -84,5 +84,5 @@ void warn_cond_escape (int c, int *x)\n   if (*x == 2)\n     p[2] = 0;\n   else if (*x == 5)\n-    p[5] = 0;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+    p[5] = 0;                 // { dg-warning \"\\\\\\[-Warray-bounds|-Wstringop-overflow\" }\n }"}]}