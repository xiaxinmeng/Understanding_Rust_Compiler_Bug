{"sha": "201b7ecd2509a48951347b9f1ff366aabbc04b7e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjAxYjdlY2QyNTA5YTQ4OTUxMzQ3YjlmMWZmMzY2YWFiYmMwNGI3ZQ==", "commit": {"author": {"name": "Alex Velenko", "email": "Alex.Velenko@arm.com", "date": "2014-01-20T18:30:32Z"}, "committer": {"name": "Marcus Shawcroft", "email": "mshawcroft@gcc.gnu.org", "date": "2014-01-20T18:30:32Z"}, "message": "[AArch64] vneg floating point testcase BE fixed.\n\n2013-01-20  Alex Velenko  <Alex.Velenko@arm.com>\n\n\t* gcc.target/aarch64/vneg_f.c (STORE_INST): New macro.\n\t(RUN_TEST): Use new macro.\n\t(INDEX64_32): Delete.\n\t(INDEX64_64): Likewise.\n\t(INDEX128_32): Likewise.\n\t(INDEX128_64): Likewise.\n\t(INDEX): Likewise.\n\t(test_vneg_f32): Use fixed RUN_TEST.\n\nFrom-SVN: r206850", "tree": {"sha": "d74f677b98a2dfa9b2194ad6c8b44a7c45a2b0dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d74f677b98a2dfa9b2194ad6c8b44a7c45a2b0dd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/201b7ecd2509a48951347b9f1ff366aabbc04b7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/201b7ecd2509a48951347b9f1ff366aabbc04b7e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/201b7ecd2509a48951347b9f1ff366aabbc04b7e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/201b7ecd2509a48951347b9f1ff366aabbc04b7e/comments", "author": null, "committer": null, "parents": [{"sha": "9a7eefec743956cfd72de8e2f5e1d42be4f7d20d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a7eefec743956cfd72de8e2f5e1d42be4f7d20d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a7eefec743956cfd72de8e2f5e1d42be4f7d20d"}], "stats": {"total": 128, "additions": 68, "deletions": 60}, "files": [{"sha": "8f66ea95642f3a33dff48653ea5548040fa0e3e0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/201b7ecd2509a48951347b9f1ff366aabbc04b7e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/201b7ecd2509a48951347b9f1ff366aabbc04b7e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=201b7ecd2509a48951347b9f1ff366aabbc04b7e", "patch": "@@ -1,3 +1,14 @@\n+2013-01-20  Alex Velenko  <Alex.Velenko@arm.com>\n+\n+\t* gcc.target/aarch64/vneg_f.c (STORE_INST): New macro.\n+\t(RUN_TEST): Use new macro.\n+\t(INDEX64_32): Delete.\n+\t(INDEX64_64): Likewise.\n+\t(INDEX128_32): Likewise.\n+\t(INDEX128_64): Likewise.\n+\t(INDEX): Likewise.\n+\t(test_vneg_f32): Use fixed RUN_TEST.\n+\n 2014-01-20  Richard Biener  <rguenther@suse.de>\n \n \tPR middle-end/59860"}, {"sha": "01503028547f320ab3d8ea725ff09ee5d0487f18", "filename": "gcc/testsuite/gcc.target/aarch64/vneg_f.c", "status": "modified", "additions": 57, "deletions": 60, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/201b7ecd2509a48951347b9f1ff366aabbc04b7e/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvneg_f.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/201b7ecd2509a48951347b9f1ff366aabbc04b7e/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvneg_f.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvneg_f.c?ref=201b7ecd2509a48951347b9f1ff366aabbc04b7e", "patch": "@@ -44,34 +44,27 @@ extern void abort (void);\n #define DATA_TYPE_64 double\n #define DATA_TYPE(data_len) DATA_TYPE_##data_len\n \n-#define INDEX64_32 [i]\n-#define INDEX64_64\n-#define INDEX128_32 [i]\n-#define INDEX128_64 [i]\n-#define INDEX(reg_len, data_len) \\\n-  CONCAT1 (INDEX, reg_len##_##data_len)\n-\n+#define STORE_INST(reg_len, data_len) \\\n+  CONCAT1 (vst1, POSTFIX (reg_len, data_len))\n #define LOAD_INST(reg_len, data_len) \\\n   CONCAT1 (vld1, POSTFIX (reg_len, data_len))\n #define NEG_INST(reg_len, data_len) \\\n   CONCAT1 (vneg, POSTFIX (reg_len, data_len))\n \n #define INHIB_OPTIMIZATION asm volatile (\"\" : : : \"memory\")\n-\n-#define RUN_TEST(test_set, reg_len, data_len, n, a, b) \\\n+#define RUN_TEST(test_set, reg_len, data_len, n, a, b, c) \\\n   {\t\t\t\t\t\t       \\\n     int i;\t\t\t\t\t       \\\n     (a) = LOAD_INST (reg_len, data_len) (test_set);    \\\n     (b) = NEG_INST (reg_len, data_len) (a);\t       \\\n+    STORE_INST (reg_len, data_len) (c, b);\t       \\\n     for (i = 0; i < n; i++)\t\t\t       \\\n       {\t\t\t\t\t\t       \\\n \tDATA_TYPE (data_len) diff;\t\t       \\\n \tINHIB_OPTIMIZATION;\t\t\t       \\\n-\tdiff\t\t\t\t\t       \\\n-\t  = a INDEX (reg_len, data_len)\t\t       \\\n-\t    + b INDEX (reg_len, data_len);\t       \\\n+\tdiff = test_set[i] + c[i];\t\t       \\\n \tif (diff > EPSILON)\t\t\t       \\\n-\t  return 1;\t\t\t\t       \\\n+\t    return 1;\t\t\t\t       \\\n       }\t\t\t\t\t\t       \\\n   }\n \n@@ -84,28 +77,29 @@ extern void abort (void);\n int\n test_vneg_f32 ()\n {\n-  float test_set0[2] = { TEST0, TEST1 };\n-  float test_set1[2] = { TEST2, TEST3 };\n-  float test_set2[2] = { VAR_MAX, VAR_MIN };\n-  float test_set3[2] = { INFINITY, NAN };\n-\n   float32x2_t a;\n   float32x2_t b;\n+  float32_t c[2];\n \n-  RUN_TEST (test_set0, 64, 32, 2, a, b);\n-  RUN_TEST (test_set1, 64, 32, 2, a, b);\n-  RUN_TEST (test_set2, 64, 32, 2, a, b);\n-  RUN_TEST (test_set3, 64, 32, 0, a, b);\n+  float32_t test_set0[2] = { TEST0, TEST1 };\n+  float32_t test_set1[2] = { TEST2, TEST3 };\n+  float32_t test_set2[2] = { VAR_MAX, VAR_MIN };\n+  float32_t test_set3[2] = { INFINITY, NAN };\n+\n+  RUN_TEST (test_set0, 64, 32, 2, a, b, c);\n+  RUN_TEST (test_set1, 64, 32, 2, a, b, c);\n+  RUN_TEST (test_set2, 64, 32, 2, a, b, c);\n+  RUN_TEST (test_set3, 64, 32, 0, a, b, c);\n \n   /* Since last test cannot be checked in a uniform way by adding\n      negation result to original value, the number of lanes to be\n      checked in RUN_TEST is 0 (last argument).  Instead, result\n      will be checked manually.  */\n \n-  if (b[0] != -INFINITY)\n+  if (c[0] != -INFINITY)\n     return 1;\n \n-  if (!__builtin_isnan (b[1]))\n+  if (!__builtin_isnan (c[1]))\n     return 1;\n \n   return 0;\n@@ -130,37 +124,38 @@ test_vneg_f64 ()\n {\n   float64x1_t a;\n   float64x1_t b;\n-\n-  double test_set0[1] = { TEST0 };\n-  double test_set1[1] = { TEST1 };\n-  double test_set2[1] = { TEST2 };\n-  double test_set3[1] = { TEST3 };\n-  double test_set4[1] = { VAR_MAX };\n-  double test_set5[1] = { VAR_MIN };\n-  double test_set6[1] = { INFINITY };\n-  double test_set7[1] = { NAN };\n-\n-  RUN_TEST (test_set0, 64, 64, 1, a, b);\n-  RUN_TEST (test_set1, 64, 64, 1, a, b);\n-  RUN_TEST (test_set2, 64, 64, 1, a, b);\n-  RUN_TEST (test_set3, 64, 64, 1, a, b);\n-  RUN_TEST (test_set4, 64, 64, 1, a, b);\n-  RUN_TEST (test_set5, 64, 64, 1, a, b);\n-  RUN_TEST (test_set6, 64, 64, 0, a, b);\n+  float64_t c[1];\n+\n+  float64_t test_set0[1] = { TEST0 };\n+  float64_t test_set1[1] = { TEST1 };\n+  float64_t test_set2[1] = { TEST2 };\n+  float64_t test_set3[1] = { TEST3 };\n+  float64_t test_set4[1] = { VAR_MAX };\n+  float64_t test_set5[1] = { VAR_MIN };\n+  float64_t test_set6[1] = { INFINITY };\n+  float64_t test_set7[1] = { NAN };\n+\n+  RUN_TEST (test_set0, 64, 64, 1, a, b, c);\n+  RUN_TEST (test_set1, 64, 64, 1, a, b, c);\n+  RUN_TEST (test_set2, 64, 64, 1, a, b, c);\n+  RUN_TEST (test_set3, 64, 64, 1, a, b, c);\n+  RUN_TEST (test_set4, 64, 64, 1, a, b, c);\n+  RUN_TEST (test_set5, 64, 64, 1, a, b, c);\n+  RUN_TEST (test_set6, 64, 64, 0, a, b, c);\n \n   /* Since last test cannot be checked in a uniform way by adding\n      negation result to original value, the number of lanes to be\n      checked in RUN_TEST is 0 (last argument).  Instead, result\n      will be checked manually.  */\n \n-  if (b != -INFINITY)\n+  if (c[0] != -INFINITY)\n     return 1;\n \n   /* Same as above.  */\n \n-  RUN_TEST (test_set7, 64, 64, 0, a, b);\n+  RUN_TEST (test_set7, 64, 64, 0, a, b, c);\n \n-  if (!__builtin_isnan (b))\n+  if (!__builtin_isnan (c[0]))\n     return 1;\n \n   return 0;\n@@ -185,22 +180,23 @@ test_vnegq_f32 ()\n {\n   float32x4_t a;\n   float32x4_t b;\n+  float32_t c[4];\n \n-  float test_set0[4] = { TEST0, TEST1, TEST2, TEST3 };\n-  float test_set1[4] = { FLT_MAX, FLT_MIN, INFINITY, NAN };\n+  float32_t test_set0[4] = { TEST0, TEST1, TEST2, TEST3 };\n+  float32_t test_set1[4] = { FLT_MAX, FLT_MIN, INFINITY, NAN };\n \n-  RUN_TEST (test_set0, 128, 32, 4, a, b);\n-  RUN_TEST (test_set1, 128, 32, 2, a, b);\n+  RUN_TEST (test_set0, 128, 32, 4, a, b, c);\n+  RUN_TEST (test_set1, 128, 32, 2, a, b, c);\n \n   /* Since last test cannot be fully checked in a uniform way by\n      adding negation result to original value, the number of lanes\n      to be checked in RUN_TEST is 0 (last argument).  Instead, result\n      will be checked manually.  */\n \n-  if (b[2] != -INFINITY)\n+  if (c[2] != -INFINITY)\n     return 1;\n \n-  if (!__builtin_isnan (b[3]))\n+  if (!__builtin_isnan (c[3]))\n     return 1;\n \n   return 0;\n@@ -225,26 +221,27 @@ test_vnegq_f64 ()\n {\n   float64x2_t a;\n   float64x2_t b;\n+  float64_t c[2];\n \n-  double test_set0[2] = { TEST0, TEST1 };\n-  double test_set1[2] = { TEST2, TEST3 };\n-  double test_set2[2] = { FLT_MAX, FLT_MIN };\n-  double test_set3[2] = { INFINITY, NAN };\n+  float64_t test_set0[2] = { TEST0, TEST1 };\n+  float64_t test_set1[2] = { TEST2, TEST3 };\n+  float64_t test_set2[2] = { FLT_MAX, FLT_MIN };\n+  float64_t test_set3[2] = { INFINITY, NAN };\n \n-  RUN_TEST (test_set0, 128, 64, 2, a, b);\n-  RUN_TEST (test_set1, 128, 64, 2, a, b);\n-  RUN_TEST (test_set2, 128, 64, 2, a, b);\n-  RUN_TEST (test_set3, 128, 64, 0, a, b);\n+  RUN_TEST (test_set0, 128, 64, 2, a, b, c);\n+  RUN_TEST (test_set1, 128, 64, 2, a, b, c);\n+  RUN_TEST (test_set2, 128, 64, 2, a, b, c);\n+  RUN_TEST (test_set3, 128, 64, 0, a, b, c);\n \n   /* Since last test cannot be checked in a uniform way by adding\n      negation result to original value, the number of lanes to be\n      checked in RUN_TEST is 0 (last argument).  Instead, result\n      will be checked manually.  */\n \n-  if (b[0] != -INFINITY)\n+  if (c[0] != -INFINITY)\n     return 1;\n \n-  if (!__builtin_isnan (b[1]))\n+  if (!__builtin_isnan (c[1]))\n     return 1;\n \n   return 0;"}]}