{"sha": "0422e94065d77179d610740f8d27dc6fb31685ae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDQyMmU5NDA2NWQ3NzE3OWQ2MTA3NDBmOGQyN2RjNmZiMzE2ODVhZQ==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2003-12-01T16:17:32Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2003-12-01T16:17:32Z"}, "message": "reload.c (find_reloads_address): Split addresses of type (plus (plus (reg) (reg)) (const_int)) only if...\n\n\t* reload.c (find_reloads_address): Split addresses of type\n\t(plus (plus (reg) (reg)) (const_int)) only if one register\n\tis either a valid base register or else one of the stack\n\tframe related registers (sp/fp/ap).\n\nFrom-SVN: r74107", "tree": {"sha": "07a2d383d9f35ac0378a58c573b4e81245aee0ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/07a2d383d9f35ac0378a58c573b4e81245aee0ae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0422e94065d77179d610740f8d27dc6fb31685ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0422e94065d77179d610740f8d27dc6fb31685ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0422e94065d77179d610740f8d27dc6fb31685ae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0422e94065d77179d610740f8d27dc6fb31685ae/comments", "author": null, "committer": null, "parents": [{"sha": "1fa7e0fd52d115bbe68f138a06d12e7a8adc4be5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fa7e0fd52d115bbe68f138a06d12e7a8adc4be5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1fa7e0fd52d115bbe68f138a06d12e7a8adc4be5"}], "stats": {"total": 25, "additions": 25, "deletions": 0}, "files": [{"sha": "545d9f11c3c28228c06aa5ac27550b5784b1af52", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0422e94065d77179d610740f8d27dc6fb31685ae/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0422e94065d77179d610740f8d27dc6fb31685ae/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0422e94065d77179d610740f8d27dc6fb31685ae", "patch": "@@ -1,3 +1,10 @@\n+2003-12-01  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* reload.c (find_reloads_address): Split addresses of type\n+\t(plus (plus (reg) (reg)) (const_int)) only if one register\n+\tis either a valid base register or else one of the stack\n+\tframe related registers (sp/fp/ap).\n+\n 2003-12-01  Steven Bosscher  <stevenb@suse.de>\n \n \t* function.c (update_epilogue_consts): Don't use PARAMS."}, {"sha": "b448ff2d967f87b0bea59190d41b7468fa016840", "filename": "gcc/reload.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0422e94065d77179d610740f8d27dc6fb31685ae/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0422e94065d77179d610740f8d27dc6fb31685ae/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=0422e94065d77179d610740f8d27dc6fb31685ae", "patch": "@@ -4905,6 +4905,15 @@ find_reloads_address (enum machine_mode mode, rtx *memrefloc, rtx ad,\n \t   && GET_CODE (XEXP (ad, 0)) == PLUS\n \t   && GET_CODE (XEXP (XEXP (ad, 0), 0)) == REG\n \t   && REGNO (XEXP (XEXP (ad, 0), 0)) < FIRST_PSEUDO_REGISTER\n+\t   && (REG_MODE_OK_FOR_BASE_P (XEXP (XEXP (ad, 0), 0), mode)\n+\t       || XEXP (XEXP (ad, 0), 0) == frame_pointer_rtx\n+#if FRAME_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM\n+\t       || XEXP (XEXP (ad, 0), 0) == hard_frame_pointer_rtx\n+#endif\n+#if FRAME_POINTER_REGNUM != ARG_POINTER_REGNUM\n+\t       || XEXP (XEXP (ad, 0), 0) == arg_pointer_rtx\n+#endif\n+\t       || XEXP (XEXP (ad, 0), 0) == stack_pointer_rtx)\n \t   && ! maybe_memory_address_p (mode, ad, &XEXP (XEXP (ad, 0), 1)))\n     {\n       *loc = ad = gen_rtx_PLUS (GET_MODE (ad),\n@@ -4924,6 +4933,15 @@ find_reloads_address (enum machine_mode mode, rtx *memrefloc, rtx ad,\n \t   && GET_CODE (XEXP (ad, 0)) == PLUS\n \t   && GET_CODE (XEXP (XEXP (ad, 0), 1)) == REG\n \t   && REGNO (XEXP (XEXP (ad, 0), 1)) < FIRST_PSEUDO_REGISTER\n+\t   && (REG_MODE_OK_FOR_BASE_P (XEXP (XEXP (ad, 0), 1), mode)\n+\t       || XEXP (XEXP (ad, 0), 1) == frame_pointer_rtx\n+#if FRAME_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM\n+\t       || XEXP (XEXP (ad, 0), 1) == hard_frame_pointer_rtx\n+#endif\n+#if FRAME_POINTER_REGNUM != ARG_POINTER_REGNUM\n+\t       || XEXP (XEXP (ad, 0), 1) == arg_pointer_rtx\n+#endif\n+\t       || XEXP (XEXP (ad, 0), 1) == stack_pointer_rtx)\n \t   && ! maybe_memory_address_p (mode, ad, &XEXP (XEXP (ad, 0), 0)))\n     {\n       *loc = ad = gen_rtx_PLUS (GET_MODE (ad),"}]}