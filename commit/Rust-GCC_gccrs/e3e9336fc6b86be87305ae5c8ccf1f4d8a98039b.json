{"sha": "e3e9336fc6b86be87305ae5c8ccf1f4d8a98039b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTNlOTMzNmZjNmI4NmJlODczMDVhZTVjOGNjZjFmNGQ4YTk4MDM5Yg==", "commit": {"author": {"name": "Dale Johannesen", "email": "dalej@apple.com", "date": "2003-12-22T18:25:35Z"}, "committer": {"name": "Dale Johannesen", "email": "dalej@gcc.gnu.org", "date": "2003-12-22T18:25:35Z"}, "message": "reload1.c: Add reg_reloaded_call_part_clobbered.\n\n\n2003-12-22  Dale Johannesen  <dalej@apple.com>\n\n        * reload1.c:  Add reg_reloaded_call_part_clobbered.\n        (reload_as_needed):  Use it.\n        (forget_old_reloads_1):  Ditto.\n        (emit_reload_insns):  Ditto.\n\nFrom-SVN: r74936", "tree": {"sha": "327de0674aeed7ccab094bea1d154d6e220af7a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/327de0674aeed7ccab094bea1d154d6e220af7a7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e3e9336fc6b86be87305ae5c8ccf1f4d8a98039b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3e9336fc6b86be87305ae5c8ccf1f4d8a98039b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3e9336fc6b86be87305ae5c8ccf1f4d8a98039b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3e9336fc6b86be87305ae5c8ccf1f4d8a98039b/comments", "author": null, "committer": null, "parents": [{"sha": "aaf3ce3e553c3bb85fe447691c9309f9522facb5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aaf3ce3e553c3bb85fe447691c9309f9522facb5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aaf3ce3e553c3bb85fe447691c9309f9522facb5"}], "stats": {"total": 39, "additions": 35, "deletions": 4}, "files": [{"sha": "a5636deae014a11000a17a935b0983b2c5d39749", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3e9336fc6b86be87305ae5c8ccf1f4d8a98039b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3e9336fc6b86be87305ae5c8ccf1f4d8a98039b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e3e9336fc6b86be87305ae5c8ccf1f4d8a98039b", "patch": "@@ -1,3 +1,10 @@\n+2003-12-22  Dale Johannesen  <dalej@apple.com>\n+\n+        * reload1.c:  Add reg_reloaded_call_part_clobbered.\n+        (reload_as_needed):  Use it.\n+        (forget_old_reloads_1):  Ditto.\n+        (emit_reload_insns):  Ditto.\n+\n 2003-12-22  Dale Johannesen  <dalej@apple.com>\n \n         PR optimization/12828"}, {"sha": "9a0ad8947468d74457b6af5b1de5089a10f2ad73", "filename": "gcc/reload1.c", "status": "modified", "additions": 28, "deletions": 4, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3e9336fc6b86be87305ae5c8ccf1f4d8a98039b/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3e9336fc6b86be87305ae5c8ccf1f4d8a98039b/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=e3e9336fc6b86be87305ae5c8ccf1f4d8a98039b", "patch": "@@ -138,6 +138,11 @@ static HARD_REG_SET reg_reloaded_valid;\n    This is only valid if reg_reloaded_contents is set and valid.  */\n static HARD_REG_SET reg_reloaded_dead;\n \n+/* Indicate whether the register's current value is one that is not\n+   safe to retain across a call, even for registers that are normally\n+   call-saved.  */\n+static HARD_REG_SET reg_reloaded_call_part_clobbered;\n+\n /* Number of spill-regs so far; number of valid elements of spill_regs.  */\n static int n_spills;\n \n@@ -3757,6 +3762,7 @@ reload_as_needed (int live_known)\n   reg_last_reload_reg = xcalloc (max_regno, sizeof (rtx));\n   reg_has_output_reload = xmalloc (max_regno);\n   CLEAR_HARD_REG_SET (reg_reloaded_valid);\n+  CLEAR_HARD_REG_SET (reg_reloaded_call_part_clobbered);\n \n   set_initial_elim_offsets ();\n \n@@ -4004,9 +4010,13 @@ reload_as_needed (int live_known)\n \tCLEAR_HARD_REG_SET (reg_reloaded_valid);\n \n       /* Don't assume a reload reg is still good after a call insn\n-\t if it is a call-used reg.  */\n+\t if it is a call-used reg, or if it contains a value that will\n+         be partially clobbered by the call.  */\n       else if (GET_CODE (insn) == CALL_INSN)\n+\t{\n \tAND_COMPL_HARD_REG_SET (reg_reloaded_valid, call_used_reg_set);\n+\tAND_COMPL_HARD_REG_SET (reg_reloaded_valid, reg_reloaded_call_part_clobbered);\n+\t}\n     }\n \n   /* Clean up.  */\n@@ -4061,6 +4071,7 @@ forget_old_reloads_1 (rtx x, rtx ignored ATTRIBUTE_UNUSED,\n \t    || ! TEST_HARD_REG_BIT (reg_is_output_reload, regno + i))\n \t  {\n \t    CLEAR_HARD_REG_BIT (reg_reloaded_valid, regno + i);\n+\t    CLEAR_HARD_REG_BIT (reg_reloaded_call_part_clobbered, regno + i);\n \t    spill_reg_store[regno + i] = 0;\n \t  }\n     }\n@@ -7043,7 +7054,10 @@ emit_reload_insns (struct insn_chain *chain)\n \t\t If consecutive registers are used, clear them all.  */\n \n \t      for (k = 0; k < nr; k++)\n+  \t        {\n \t\tCLEAR_HARD_REG_BIT (reg_reloaded_valid, i + k);\n+  \t\t  CLEAR_HARD_REG_BIT (reg_reloaded_call_part_clobbered, i + k);\n+  \t\t}\n \n \t      /* Maybe the spill reg contains a copy of reload_out.  */\n \t      if (rld[r].out != 0\n@@ -7090,6 +7104,8 @@ emit_reload_insns (struct insn_chain *chain)\n \t\t\t   : nregno + k);\n \t\t      reg_reloaded_insn[i + k] = insn;\n \t\t      SET_HARD_REG_BIT (reg_reloaded_valid, i + k);\n+\t\t      if (HARD_REGNO_CALL_PART_CLOBBERED (i + k, GET_MODE (out)))\n+\t\t\tSET_HARD_REG_BIT (reg_reloaded_call_part_clobbered, i + k);\n \t\t    }\n \t\t}\n \n@@ -7107,14 +7123,16 @@ emit_reload_insns (struct insn_chain *chain)\n \t\t{\n \t\t  int nregno;\n \t\t  int nnr;\n+\t\t  rtx in;\n \n \t\t  if (GET_CODE (rld[r].in) == REG\n \t\t      && REGNO (rld[r].in) >= FIRST_PSEUDO_REGISTER)\n-\t\t    nregno = REGNO (rld[r].in);\n+\t\t    in = rld[r].in;\n \t\t  else if (GET_CODE (rld[r].in_reg) == REG)\n-\t\t    nregno = REGNO (rld[r].in_reg);\n+\t\t    in = rld[r].in_reg;\n \t\t  else\n-\t\t    nregno = REGNO (XEXP (rld[r].in_reg, 0));\n+\t\t    in = XEXP (rld[r].in_reg, 0);\n+\t\t  nregno = REGNO (in);\n \n \t\t  nnr = (nregno >= FIRST_PSEUDO_REGISTER ? 1\n \t\t\t : HARD_REGNO_NREGS (nregno,\n@@ -7146,6 +7164,8 @@ emit_reload_insns (struct insn_chain *chain)\n \t\t\t   : nregno + k);\n \t\t      reg_reloaded_insn[i + k] = insn;\n \t\t      SET_HARD_REG_BIT (reg_reloaded_valid, i + k);\n+\t\t      if (HARD_REGNO_CALL_PART_CLOBBERED (i + k, GET_MODE (in)))\n+\t\t\tSET_HARD_REG_BIT (reg_reloaded_call_part_clobbered, i + k);\n \t\t    }\n \t\t}\n \t    }\n@@ -7232,6 +7252,10 @@ emit_reload_insns (struct insn_chain *chain)\n \t\t      reg_reloaded_insn[src_regno + nr] = store_insn;\n \t\t      CLEAR_HARD_REG_BIT (reg_reloaded_dead, src_regno + nr);\n \t\t      SET_HARD_REG_BIT (reg_reloaded_valid, src_regno + nr);\n+\t\t      if (HARD_REGNO_CALL_PART_CLOBBERED (src_regno + nr, \n+\t\t\t\t\t\t\t  GET_MODE (src_reg)))\n+\t\t\tSET_HARD_REG_BIT (reg_reloaded_call_part_clobbered, \n+\t\t\t\t\t  src_regno + nr);\n \t\t      SET_HARD_REG_BIT (reg_is_output_reload, src_regno + nr);\n \t\t      if (note)\n \t\t\tSET_HARD_REG_BIT (reg_reloaded_died, src_regno);"}]}