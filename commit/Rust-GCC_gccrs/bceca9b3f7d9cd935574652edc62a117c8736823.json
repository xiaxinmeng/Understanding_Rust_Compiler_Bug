{"sha": "bceca9b3f7d9cd935574652edc62a117c8736823", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmNlY2E5YjNmN2Q5Y2Q5MzU1NzQ2NTJlZGM2MmExMTdjODczNjgyMw==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2018-12-19T06:51:19Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2018-12-19T06:51:19Z"}, "message": "[PR c++/88146] do not crash synthesizing inherited ctor(...)\n\nThis patch started out from the testcase in PR88146, that attempted to\nsynthesize an inherited ctor without any args before a varargs\nellipsis and crashed while at that, because of the unguarded\ndereferencing of the parm type list, that usually contains a\nterminator.  The terminator is not there for varargs functions,\nhowever, and without any other args, we ended up dereferencing a NULL\npointer.  Oops.\n\nGuarding accesses to parm would be easy, but not necessary.  In\ndo_build_copy_constructor, non-inherited ctors are copy-ctors, that\nalways have at least one parm, so parm needs not be guarded when we\nknow the access will only take place when we're dealing with an\ninherited ctor.  The only other problematic use was in the cvquals\ninitializer, a variable only used in a loop over fields, that we\nskipped individually in inherited ctors.  I've guarded the cvquals\ninitialization and the entire loop over fields so they only run for\ncopy-ctors.\n\nAvoiding the crash from unguarded accesses was easy, but I thought we\nshould still produce the sorry message we got in other testcases that\npassed arguments through the ellipsis in inherited ctors.  I put a\ncheck in, and noticed the inherited ctors were synthesized with the\nlocation assigned to the class name, although they were initially\nassigned the location of the using declaration.  I decided the latter\nwas better, and arranged for the better location to be retained.\n\nFurther investigation revealed the lack of a sorry message had to do\nwith the call being in a non-evaluated context, in this case, a\nnoexcept expression.  The sorry would be correctly reported in other\ncontexts, so I rolled back the check I'd added, but retained the\nsource location improvement.\n\nI was still concerned about issuing sorry messages while instantiating\ntemplate ctors even in non-evaluated contexts, e.g., if a template\nctor had a base initializer that used an inherited ctor with enough\narguments that they'd go through an ellipsis.  I wanted to defer the\ninstantiation of such template ctors, but that would have been wrong\nfor constexpr template ctors, and already done for non-constexpr ones.\nSo, I just consolidated multiple test variants into a single testcase\nthat explores and explains various of the possibilities I thought of.\n\n\nfor  gcc/cp/ChangeLog\n\n\tPR c++/88146\n\t* method.c (do_build_copy_constructor): Guard cvquals init and\n\tloop over fields to run for non-inherited ctors only.\n\t(synthesize_method): Retain location of inherited ctor.\n\nfor  gcc/testsuite/ChangeLog\n\n\tPR c++/88146\n\t* g++.dg/cpp0x/inh-ctor32.C: New.\n\nFrom-SVN: r267250", "tree": {"sha": "93061afdcfb56ab9463e3f2da40496c7479c5608", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/93061afdcfb56ab9463e3f2da40496c7479c5608"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bceca9b3f7d9cd935574652edc62a117c8736823", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bceca9b3f7d9cd935574652edc62a117c8736823", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bceca9b3f7d9cd935574652edc62a117c8736823", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bceca9b3f7d9cd935574652edc62a117c8736823/comments", "author": null, "committer": null, "parents": [{"sha": "4469188ce7f228902629595941e1c2ff24b9c4d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4469188ce7f228902629595941e1c2ff24b9c4d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4469188ce7f228902629595941e1c2ff24b9c4d6"}], "stats": {"total": 330, "additions": 287, "deletions": 43}, "files": [{"sha": "0246806c9a7c112e30097f7662240cb886721023", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bceca9b3f7d9cd935574652edc62a117c8736823/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bceca9b3f7d9cd935574652edc62a117c8736823/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=bceca9b3f7d9cd935574652edc62a117c8736823", "patch": "@@ -1,3 +1,10 @@\n+2018-12-19  Alexandre Oliva <aoliva@redhat.com>\n+\n+\tPR c++/88146\n+\t* method.c (do_build_copy_constructor): Guard cvquals init and\n+\tloop over fields to run for non-inherited ctors only.\n+\t(synthesize_method): Retain location of inherited ctor.\n+\n 2018-12-17  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/88410"}, {"sha": "17404a65b0fdecb870497953ccbc280b165c1c1f", "filename": "gcc/cp/method.c", "status": "modified", "additions": 46, "deletions": 43, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bceca9b3f7d9cd935574652edc62a117c8736823/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bceca9b3f7d9cd935574652edc62a117c8736823/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=bceca9b3f7d9cd935574652edc62a117c8736823", "patch": "@@ -675,12 +675,9 @@ do_build_copy_constructor (tree fndecl)\n     }\n   else\n     {\n-      tree fields = TYPE_FIELDS (current_class_type);\n       tree member_init_list = NULL_TREE;\n-      int cvquals = cp_type_quals (TREE_TYPE (parm));\n       int i;\n       tree binfo, base_binfo;\n-      tree init;\n       vec<tree, va_gc> *vbases;\n \n       /* Initialize all the base-classes with the parameter converted\n@@ -704,53 +701,58 @@ do_build_copy_constructor (tree fndecl)\n \t\t\t\t\t\tinh, member_init_list);\n \t}\n \n-      for (; fields; fields = DECL_CHAIN (fields))\n+      if (!inh)\n \t{\n-\t  tree field = fields;\n-\t  tree expr_type;\n-\n-\t  if (TREE_CODE (field) != FIELD_DECL)\n-\t    continue;\n-\t  if (inh)\n-\t    continue;\n+\t  int cvquals = cp_type_quals (TREE_TYPE (parm));\n \n-\t  expr_type = TREE_TYPE (field);\n-\t  if (DECL_NAME (field))\n+\t  for (tree fields = TYPE_FIELDS (current_class_type);\n+\t       fields; fields = DECL_CHAIN (fields))\n \t    {\n-\t      if (VFIELD_NAME_P (DECL_NAME (field)))\n+\t      tree field = fields;\n+\t      tree expr_type;\n+\n+\t      if (TREE_CODE (field) != FIELD_DECL)\n \t\tcontinue;\n-\t    }\n-\t  else if (ANON_AGGR_TYPE_P (expr_type) && TYPE_FIELDS (expr_type))\n-\t    /* Just use the field; anonymous types can't have\n-\t       nontrivial copy ctors or assignment ops or this\n-\t       function would be deleted.  */;\n-\t  else\n-\t    continue;\n \n-\t  /* Compute the type of \"init->field\".  If the copy-constructor\n-\t     parameter is, for example, \"const S&\", and the type of\n-\t     the field is \"T\", then the type will usually be \"const\n-\t     T\".  (There are no cv-qualified variants of reference\n-\t     types.)  */\n-\t  if (!TYPE_REF_P (expr_type))\n-\t    {\n-\t      int quals = cvquals;\n+\t      expr_type = TREE_TYPE (field);\n+\t      if (DECL_NAME (field))\n+\t\t{\n+\t\t  if (VFIELD_NAME_P (DECL_NAME (field)))\n+\t\t    continue;\n+\t\t}\n+\t      else if (ANON_AGGR_TYPE_P (expr_type) && TYPE_FIELDS (expr_type))\n+\t\t/* Just use the field; anonymous types can't have\n+\t\t   nontrivial copy ctors or assignment ops or this\n+\t\t   function would be deleted.  */;\n+\t      else\n+\t\tcontinue;\n \n-\t      if (DECL_MUTABLE_P (field))\n-\t\tquals &= ~TYPE_QUAL_CONST;\n-\t      quals |= cp_type_quals (expr_type);\n-\t      expr_type = cp_build_qualified_type (expr_type, quals);\n-\t    }\n+\t      /* Compute the type of \"init->field\".  If the copy-constructor\n+\t\t parameter is, for example, \"const S&\", and the type of\n+\t\t the field is \"T\", then the type will usually be \"const\n+\t\t T\".  (There are no cv-qualified variants of reference\n+\t\t types.)  */\n+\t      if (!TYPE_REF_P (expr_type))\n+\t\t{\n+\t\t  int quals = cvquals;\n \n-\t  init = build3 (COMPONENT_REF, expr_type, parm, field, NULL_TREE);\n-\t  if (move_p && !TYPE_REF_P (expr_type)\n-\t      /* 'move' breaks bit-fields, and has no effect for scalars.  */\n-\t      && !scalarish_type_p (expr_type))\n-\t    init = move (init);\n-\t  init = build_tree_list (NULL_TREE, init);\n+\t\t  if (DECL_MUTABLE_P (field))\n+\t\t    quals &= ~TYPE_QUAL_CONST;\n+\t\t  quals |= cp_type_quals (expr_type);\n+\t\t  expr_type = cp_build_qualified_type (expr_type, quals);\n+\t\t}\n+\n+\t      tree init = build3 (COMPONENT_REF, expr_type, parm, field, NULL_TREE);\n+\t      if (move_p && !TYPE_REF_P (expr_type)\n+\t\t  /* 'move' breaks bit-fields, and has no effect for scalars.  */\n+\t\t  && !scalarish_type_p (expr_type))\n+\t\tinit = move (init);\n+\t      init = build_tree_list (NULL_TREE, init);\n \n-\t  member_init_list = tree_cons (field, init, member_init_list);\n+\t      member_init_list = tree_cons (field, init, member_init_list);\n+\t    }\n \t}\n+\n       finish_mem_initializers (member_init_list);\n     }\n }\n@@ -891,8 +893,9 @@ synthesize_method (tree fndecl)\n \n   /* Reset the source location, we might have been previously\n      deferred, and thus have saved where we were first needed.  */\n-  DECL_SOURCE_LOCATION (fndecl)\n-    = DECL_SOURCE_LOCATION (TYPE_NAME (DECL_CONTEXT (fndecl)));\n+  if (!DECL_INHERITED_CTOR (fndecl))\n+    DECL_SOURCE_LOCATION (fndecl)\n+      = DECL_SOURCE_LOCATION (TYPE_NAME (DECL_CONTEXT (fndecl)));\n \n   /* If we've been asked to synthesize a clone, just synthesize the\n      cloned function instead.  Doing so will automatically fill in the"}, {"sha": "a0d8c9981bc7a50c30bd39b888b5fb7a21dce1fc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bceca9b3f7d9cd935574652edc62a117c8736823/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bceca9b3f7d9cd935574652edc62a117c8736823/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bceca9b3f7d9cd935574652edc62a117c8736823", "patch": "@@ -1,3 +1,8 @@\n+2018-12-19  Alexandre Oliva <aoliva@redhat.com>\n+\n+\tPR c++/88146\n+\t* g++.dg/cpp0x/inh-ctor32.C: New.\n+\n 2018-12-18  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR rtl-optimization/87759"}, {"sha": "c40412fc5346db7f6cae3595e852cc41beb0007b", "filename": "gcc/testsuite/g++.dg/cpp0x/inh-ctor32.C", "status": "added", "additions": 229, "deletions": 0, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bceca9b3f7d9cd935574652edc62a117c8736823/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor32.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bceca9b3f7d9cd935574652edc62a117c8736823/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor32.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor32.C?ref=bceca9b3f7d9cd935574652edc62a117c8736823", "patch": "@@ -0,0 +1,229 @@\n+// { dg-do compile { target c++11 } }\n+// Minimized from the testcase for PR c++/88146,\n+// then turned into multiple variants. \n+\n+// We issue an error when calling an inherited ctor with at least one\n+// argument passed through a varargs ellipsis, if the call is in an\n+// evaluated context.  Even in nonevaluated contexts, we will\n+// instantiate constexpr templates (unlike non-constexpr templates),\n+// which might then issue errors that in nonevlauated contexts\n+// wouldn't be issued.\n+\n+// In these variants, the inherited ctor is constexpr, but it's only\n+// called in unevaluated contexts, so no error is issued.  The\n+// templateness of the ctor doesn't matter, because the only call that\n+// passes args through the ellipsis is in a noexcept expr, that is not\n+// evaluated.  The ctors in derived classes are created and\n+// instantiated, discarding arguments passed through the ellipsis when\n+// calling base ctors, but that's not reported: we only report a\n+// problem when *calling* ctors that behave this way.\n+namespace unevaled_call {\n+  namespace no_arg_before_ellipsis {\n+    namespace without_template {\n+      struct foo {\n+\tconstexpr foo(...) {}\n+      };\n+      struct boo : foo {\n+\tusing foo::foo;\n+      };\n+      struct bar : boo {\n+\tusing boo::boo;\n+      };\n+      void f() noexcept(noexcept(bar{0}));\n+    }\n+\n+    namespace with_template {\n+      struct foo {\n+\ttemplate <typename... T>\n+\tconstexpr foo(...) {}\n+      };\n+      struct boo : foo {\n+\tusing foo::foo;\n+      };\n+      struct bar : boo {\n+\tusing boo::boo;\n+      };\n+      void f() noexcept(noexcept(bar{0}));\n+    }\n+  }\n+\n+  namespace one_arg_before_ellipsis {\n+    namespace without_template {\n+      struct foo {\n+\tconstexpr foo(int, ...) {}\n+      };\n+      struct boo : foo {\n+\tusing foo::foo;\n+      };\n+      struct bar : boo {\n+\tusing boo::boo;\n+      };\n+      void f() noexcept(noexcept(bar{0,1}));\n+    }\n+\n+    namespace with_template {\n+      struct foo {\n+\ttemplate <typename T>\n+\tconstexpr foo(T, ...) {}\n+      };\n+      struct boo : foo {\n+\tusing foo::foo;\n+      };\n+      struct bar : boo {\n+\tusing boo::boo;\n+      };\n+      void f() noexcept(noexcept(bar{0,1}));\n+    }\n+  }\n+}\n+\n+// In these variants, the inherited ctor is constexpr, and it's called\n+// in unevaluated contexts in ways that would otherwise trigger the\n+// sorry message.  Here we check that the message is not issued at\n+// those calls, nor at subsequent calls that use the same ctor without\n+// passing arguments through its ellipsis.  We check that it is issued\n+// later, when we pass the ctor arguments through the ellipsis.\n+namespace evaled_bad_call_in_u {\n+  namespace one_arg_before_ellipsis {\n+    namespace without_template {\n+      struct foo {\n+\tconstexpr foo(int, ...) {}\n+      };\n+      struct boo : foo {\n+\tusing foo::foo;\n+      };\n+      struct bar : boo {\n+\tusing boo::boo;\n+      };\n+      void f() noexcept(noexcept(bar{0, 1}));\n+      bar t(0);\n+      bar u(0, 1); // { dg-message \"sorry, unimplemented: passing arguments to ellipsis\" }\n+    }\n+\n+    namespace with_template {\n+      struct foo {\n+\ttemplate <typename T>\n+\tconstexpr foo(T, ...) {}\n+      };\n+      struct boo : foo {\n+\tusing foo::foo;\n+      };\n+      struct bar : boo {\n+\tusing boo::boo;\n+      };\n+      void f() noexcept(noexcept(bar{0,1}));\n+      bar t(0);\n+      bar u(0,1); // { dg-message \"sorry, unimplemented: passing arguments to ellipsis\" }\n+    }\n+  }\n+\n+  namespace no_arg_before_ellipsis {\n+    namespace without_template {\n+      struct foo {\n+\tconstexpr foo(...) {}\n+      };\n+      struct boo : foo {\n+\tusing foo::foo;\n+      };\n+      struct bar : boo {\n+\tusing boo::boo;\n+      };\n+      void f() noexcept(noexcept(bar{0}));\n+      bar u(0); // { dg-message \"sorry, unimplemented: passing arguments to ellipsis\" }\n+    }\n+\n+    namespace with_template {\n+      struct foo {\n+\ttemplate <typename... T>\n+\tconstexpr foo(...) {}\n+      };\n+      struct boo : foo {\n+\tusing foo::foo;\n+      };\n+      struct bar : boo {\n+\tusing boo::boo;\n+      };\n+      void f() noexcept(noexcept(bar{0}));\n+      bar u(0); // { dg-message \"sorry, unimplemented: passing arguments to ellipsis\" }\n+    }\n+  }\n+}\n+\n+// Now, instead of instantiating a class that uses a derived ctor, we\n+// introduce another template ctor that will use the varargs ctor to\n+// initialize its base class.  The idea is to verify that the error\n+// message is issued, even if the instantiation occurs in a\n+// nonevaluated context, e.g., for constexpr templates.  In the\n+// inherited_derived_ctor, we check that even an inherited ctor of a\n+// constexpr ctor is instantiated and have an error message issued.\n+namespace derived_ctor {\n+  namespace direct_derived_ctor {\n+    namespace constexpr_noninherited_ctor {\n+      struct foo {\n+\ttemplate <typename T>\n+\tconstexpr foo(T, ...) {}\n+      };\n+      struct boo : foo {\n+\tusing foo::foo;\n+      };\n+      struct bar : boo {\n+\ttemplate <typename ...T>\n+\tconstexpr bar(T ... args) : boo(args...) {} // { dg-message \"sorry, unimplemented: passing arguments to ellipsis\" }\n+      };\n+      void f() noexcept(noexcept(bar{0,1}));\n+    }\n+\n+    namespace no_constexpr_noninherited_ctor {\n+      struct foo {\n+\ttemplate <typename T>\n+\tconstexpr foo(T, ...) {}\n+      };\n+      struct boo : foo {\n+\tusing foo::foo;\n+      };\n+      struct bar : boo {\n+\ttemplate <typename ...T>\n+\t/* constexpr */ bar(T ... args) : boo(args...) {}\n+      };\n+      void f() noexcept(noexcept(bar{0,1}));\n+    }\n+  }\n+\n+  namespace inherited_derived_ctor {\n+    namespace constexpr_noninherited_ctor {\n+      struct foo {\n+\ttemplate <typename T>\n+\tconstexpr foo(T, ...) {}\n+      };\n+      struct boo : foo {\n+\tusing foo::foo;\n+      };\n+      struct bor : boo {\n+\ttemplate <typename ...T>\n+\tconstexpr bor(T ... args) : boo(args...) {} // { dg-message \"sorry, unimplemented: passing arguments to ellipsis\" }\n+      };\n+      struct bar : bor {\n+\tusing bor::bor;\n+      };\n+      void f() noexcept(noexcept(bar{0,1})); // { dg-message \"'constexpr' expansion\" }\n+    }\n+\n+    namespace no_constexpr_noninherited_ctor {\n+      struct foo {\n+\ttemplate <typename T>\n+\tconstexpr foo(T, ...) {}\n+      };\n+      struct boo : foo {\n+\tusing foo::foo;\n+      };\n+      struct bor : boo {\n+\ttemplate <typename ...T>\n+\t/* constexpr */ bor(T ... args) : boo(args...) {}\n+      };\n+      struct bar : bor {\n+\tusing bor::bor;\n+      };\n+      void f() noexcept(noexcept(bar{0,1}));\n+    }\n+  }\n+}"}]}