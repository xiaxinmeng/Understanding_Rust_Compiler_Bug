{"sha": "51b86d8b0d4e395161645faeb7fa422faad235a8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTFiODZkOGIwZDRlMzk1MTYxNjQ1ZmFlYjdmYTQyMmZhYWQyMzVhOA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-05-27T10:03:04Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-05-27T10:03:04Z"}, "message": "(qty_phys_num{,_copy}_sugg): New variables.\n\n(qty_phys_has{,_copy}_sugg): Deleted.\n(qty_sugg_compare{,_1}): New functions.\n(local_alloc): Allocate and init new vars instead of deleted ones.\n(block_alloc): Update and use new vars.\nOrder quantities using new functions when allocating quantities with\nsuggested registers.\n(combine_regs, find_free_reg): Use new vars to count number of suggestions.\n\nFrom-SVN: r7356", "tree": {"sha": "c91c68bf6df9305ce059473fca49fffd8d34db17", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c91c68bf6df9305ce059473fca49fffd8d34db17"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/51b86d8b0d4e395161645faeb7fa422faad235a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51b86d8b0d4e395161645faeb7fa422faad235a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51b86d8b0d4e395161645faeb7fa422faad235a8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51b86d8b0d4e395161645faeb7fa422faad235a8/comments", "author": null, "committer": null, "parents": [{"sha": "c03c4711734044f4c18b8697918cacc74d9728f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c03c4711734044f4c18b8697918cacc74d9728f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c03c4711734044f4c18b8697918cacc74d9728f0"}], "stats": {"total": 174, "additions": 143, "deletions": 31}, "files": [{"sha": "60ad072c1230e4b24cad12a671613a636fe52efc", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 143, "deletions": 31, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51b86d8b0d4e395161645faeb7fa422faad235a8/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51b86d8b0d4e395161645faeb7fa422faad235a8/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=51b86d8b0d4e395161645faeb7fa422faad235a8", "patch": "@@ -105,14 +105,13 @@ static HARD_REG_SET *qty_phys_copy_sugg;\n \n static HARD_REG_SET *qty_phys_sugg;\n \n-/* Element Q is non-zero if there is a suggested register in\n-   qty_phys_copy_sugg.  */\n+/* Element Q is the number of suggested registers in qty_phys_copy_sugg.  */\n \n-static char *qty_phys_has_copy_sugg;\n+static short *qty_phys_num_copy_sugg;\n \n-/* Element Q is non-zero if there is a suggested register in qty_phys_sugg. */\n+/* Element Q is the number of suggested registers in qty_phys_sugg. */\n \n-static char *qty_phys_has_sugg;\n+static short *qty_phys_num_sugg;\n \n /* Element Q is the number of refs to quantity Q.  */\n \n@@ -247,6 +246,8 @@ static void optimize_reg_copy_1\tPROTO((rtx, rtx, rtx));\n static void optimize_reg_copy_2\tPROTO((rtx, rtx, rtx));\n static void update_equiv_regs\tPROTO((void));\n static void block_alloc\t\tPROTO((int));\n+static int qty_sugg_compare    \tPROTO((int, int));\n+static int qty_sugg_compare_1\tPROTO((int *, int *));\n static int qty_compare    \tPROTO((int, int));\n static int qty_compare_1\tPROTO((int *, int *));\n static int combine_regs\t\tPROTO((rtx, rtx, int, int, rtx, int));\n@@ -421,9 +422,9 @@ local_alloc ()\n \n   qty_phys_reg = (short *) alloca (max_qty * sizeof (short));\n   qty_phys_copy_sugg = (HARD_REG_SET *) alloca (max_qty * sizeof (HARD_REG_SET));\n-  qty_phys_has_copy_sugg = (char *) alloca (max_qty * sizeof (char));\n+  qty_phys_num_copy_sugg = (short *) alloca (max_qty * sizeof (char));\n   qty_phys_sugg = (HARD_REG_SET *) alloca (max_qty * sizeof (HARD_REG_SET));\n-  qty_phys_has_sugg = (char *) alloca (max_qty * sizeof (char));\n+  qty_phys_num_sugg = (short *) alloca (max_qty * sizeof (char));\n   qty_birth = (int *) alloca (max_qty * sizeof (int));\n   qty_death = (int *) alloca (max_qty * sizeof (int));\n   qty_scratch_rtx = (rtx *) alloca (max_qty * sizeof (rtx));\n@@ -483,9 +484,9 @@ local_alloc ()\n \t    {\n \t      qty_scratch_rtx[i] = 0;\n \t      CLEAR_HARD_REG_SET (qty_phys_copy_sugg[i]);\n-\t      qty_phys_has_copy_sugg[i] = 0;\n+\t      qty_phys_num_copy_sugg[i] = 0;\n \t      CLEAR_HARD_REG_SET (qty_phys_sugg[i]);\n-\t      qty_phys_has_sugg[i] = 0;\n+\t      qty_phys_num_sugg[i] = 0;\n \t    }\n \t}\n       else\n@@ -495,9 +496,9 @@ local_alloc ()\n \n \t  CLEAR (qty_scratch_rtx);\n \t  CLEAR (qty_phys_copy_sugg);\n-\t  CLEAR (qty_phys_has_copy_sugg);\n+\t  CLEAR (qty_phys_num_copy_sugg);\n \t  CLEAR (qty_phys_sugg);\n-\t  CLEAR (qty_phys_has_sugg);\n+\t  CLEAR (qty_phys_num_sugg);\n \t}\n \n       next_qty = 0;\n@@ -1392,9 +1393,9 @@ block_alloc (b)\n      should have been given a quantity, or else -1 meaning ignore it.\n      Every quantity should have a known birth and death.  \n \n-     Order the qtys so we assign them registers in order of \n-     decreasing length of life.  Normally call qsort, but if we \n-     have only a very small number of quantities, sort them ourselves.  */\n+     Order the qtys so we assign them registers in order of the\n+     number of suggested registers they need so we allocate those with\n+     the most restrictive needs first.  */\n \n   qty_order = (int *) alloca (next_qty * sizeof (int));\n   for (i = 0; i < next_qty; i++)\n@@ -1407,15 +1408,15 @@ block_alloc (b)\n     {\n     case 3:\n       /* Make qty_order[2] be the one to allocate last.  */\n-      if (qty_compare (0, 1) > 0)\n+      if (qty_sugg_compare (0, 1) > 0)\n \tEXCHANGE (0, 1);\n-      if (qty_compare (1, 2) > 0)\n+      if (qty_sugg_compare (1, 2) > 0)\n \tEXCHANGE (2, 1);\n \n       /* ... Fall through ... */\n     case 2:\n       /* Put the best one to allocate in qty_order[0].  */\n-      if (qty_compare (0, 1) > 0)\n+      if (qty_sugg_compare (0, 1) > 0)\n \tEXCHANGE (0, 1);\n \n       /* ... Fall through ... */\n@@ -1426,7 +1427,7 @@ block_alloc (b)\n       break;\n \n     default:\n-      qsort (qty_order, next_qty, sizeof (int), qty_compare_1);\n+      qsort (qty_order, next_qty, sizeof (int), qty_sugg_compare_1);\n     }\n \n   /* Try to put each quantity in a suggested physical register, if it has one.\n@@ -1435,13 +1436,49 @@ block_alloc (b)\n   for (i = 0; i < next_qty; i++)\n     {\n       q = qty_order[i];\n-      if (qty_phys_has_sugg[q] || qty_phys_has_copy_sugg[q])\n+      if (qty_phys_num_sugg[q] != 0 || qty_phys_num_copy_sugg[q] != 0)\n \tqty_phys_reg[q] = find_free_reg (qty_min_class[q], qty_mode[q], q,\n \t\t\t\t\t 0, 1, qty_birth[q], qty_death[q]);\n       else\n \tqty_phys_reg[q] = -1;\n     }\n \n+  /* Order the qtys so we assign them registers in order of \n+     decreasing length of life.  Normally call qsort, but if we \n+     have only a very small number of quantities, sort them ourselves.  */\n+\n+  for (i = 0; i < next_qty; i++)\n+    qty_order[i] = i;\n+\n+#define EXCHANGE(I1, I2)  \\\n+  { i = qty_order[I1]; qty_order[I1] = qty_order[I2]; qty_order[I2] = i; }\n+\n+  switch (next_qty)\n+    {\n+    case 3:\n+      /* Make qty_order[2] be the one to allocate last.  */\n+      if (qty_compare (0, 1) > 0)\n+\tEXCHANGE (0, 1);\n+      if (qty_compare (1, 2) > 0)\n+\tEXCHANGE (2, 1);\n+\n+      /* ... Fall through ... */\n+    case 2:\n+      /* Put the best one to allocate in qty_order[0].  */\n+      if (qty_compare (0, 1) > 0)\n+\tEXCHANGE (0, 1);\n+\n+      /* ... Fall through ... */\n+\n+    case 1:\n+    case 0:\n+      /* Nothing to do here.  */\n+      break;\n+\n+    default:\n+      qsort (qty_order, next_qty, sizeof (int), qty_compare_1);\n+    }\n+\n   /* Now for each qty that is not a hardware register,\n      look for a hardware register to put it in.\n      First try the register class that is cheapest for this qty,\n@@ -1552,6 +1589,79 @@ qty_compare_1 (q1, q2)\n   return *q1 - *q2;\n }\n \f\n+/* Compare two quantities' priority for getting real registers.  This version\n+   is called for quantities that have suggested hard registers.  First priority\n+   goes to quantities that have copy preferences, then to those that have\n+   normal preferences.  Within those groups, quantities with the lower\n+   number of preferenes have the highest priority.  Of those, we use the same\n+   algorithm as above.  */\n+\n+static int\n+qty_sugg_compare (q1, q2)\n+     int q1, q2;\n+{\n+  register int sugg1 = (qty_phys_num_copy_sugg[q1]\n+\t\t\t? qty_phys_num_copy_sugg[q1]\n+\t\t\t: qty_phys_num_sugg[q1] * FIRST_PSEUDO_REGISTER);\n+  register int sugg2 = (qty_phys_num_copy_sugg[q2]\n+\t\t\t? qty_phys_num_copy_sugg[q2]\n+\t\t\t: qty_phys_num_sugg[q2] * FIRST_PSEUDO_REGISTER);\n+  /* Note that the quotient will never be bigger than\n+     the value of floor_log2 times the maximum number of\n+     times a register can occur in one insn (surely less than 100).\n+     Multiplying this by 10000 can't overflow.  */\n+  register int pri1\n+    = (((double) (floor_log2 (qty_n_refs[q1]) * qty_n_refs[q1] * qty_size[q1])\n+\t/ (qty_death[q1] - qty_birth[q1]))\n+       * 10000);\n+  register int pri2\n+    = (((double) (floor_log2 (qty_n_refs[q2]) * qty_n_refs[q2] * qty_size[q2])\n+\t/ (qty_death[q2] - qty_birth[q2]))\n+       * 10000);\n+\n+  if (sugg1 != sugg2)\n+    return sugg1 - sugg2;\n+  \n+  return pri2 - pri1;\n+}\n+\n+static int\n+qty_sugg_compare_1 (q1, q2)\n+     int *q1, *q2;\n+{\n+  register int sugg1 = (qty_phys_num_copy_sugg[*q1]\n+\t\t\t? qty_phys_num_copy_sugg[*q1]\n+\t\t\t: qty_phys_num_sugg[*q1] * FIRST_PSEUDO_REGISTER);\n+  register int sugg2 = (qty_phys_num_copy_sugg[*q2]\n+\t\t\t? qty_phys_num_copy_sugg[*q2]\n+\t\t\t: qty_phys_num_sugg[*q2] * FIRST_PSUEDO_REGISTER);\n+\n+  /* Note that the quotient will never be bigger than\n+     the value of floor_log2 times the maximum number of\n+     times a register can occur in one insn (surely less than 100).\n+     Multiplying this by 10000 can't overflow.  */\n+  register int pri1\n+    = (((double) (floor_log2 (qty_n_refs[*q1]) * qty_n_refs[*q1]\n+\t\t  * qty_size[*q1])\n+\t/ (qty_death[*q1] - qty_birth[*q1]))\n+       * 10000);\n+  register int pri2\n+    = (((double) (floor_log2 (qty_n_refs[*q2]) * qty_n_refs[*q2]\n+\t\t  * qty_size[*q2])\n+\t/ (qty_death[*q2] - qty_birth[*q2]))\n+       * 10000);\n+\n+  if (sugg1 != sugg2)\n+    return sugg1 - sugg2;\n+  \n+  if (pri1 != pri2)\n+    return pri2 - pri1;\n+\n+  /* If qtys are equally good, sort by qty number,\n+     so that the results of qsort leave nothing to chance.  */\n+  return *q1 - *q2;\n+}\n+\f\n /* Attempt to combine the two registers (rtx's) USEDREG and SETREG.\n    Returns 1 if have done so, or 0 if cannot.\n \n@@ -1661,15 +1771,16 @@ combine_regs (usedreg, setreg, may_save_copy, insn_number, insn, already_dead)\n \n       if (reg_qty[sreg] >= 0)\n \t{\n-\t  if (may_save_copy)\n+\t  if (may_save_copy\n+\t      && ! TEST_HARD_REG_BIT (qty_phys_copy_sugg[reg_qty[sreg]], ureg))\n \t    {\n \t      SET_HARD_REG_BIT (qty_phys_copy_sugg[reg_qty[sreg]], ureg);\n-\t      qty_phys_has_copy_sugg[reg_qty[sreg]] = 1;\n+\t      qty_phys_num_copy_sugg[reg_qty[sreg]]++;\n \t    }\n-\t  else\n+\t  else if (! TEST_HARD_REG_BIT (qty_phys_sugg[reg_qty[sreg]], ureg))\n \t    {\n \t      SET_HARD_REG_BIT (qty_phys_sugg[reg_qty[sreg]], ureg);\n-\t      qty_phys_has_sugg[reg_qty[sreg]] = 1;\n+\t      qty_phys_num_sugg[reg_qty[sreg]]++;\n \t    }\n \t}\n       return 0;\n@@ -1679,15 +1790,16 @@ combine_regs (usedreg, setreg, may_save_copy, insn_number, insn, already_dead)\n \n   if (sreg < FIRST_PSEUDO_REGISTER)\n     {\n-      if (may_save_copy)\n+      if (may_save_copy\n+\t  && ! TEST_HARD_REG_BIT (qty_phys_copy_sugg[reg_qty[ureg]], sreg))\n \t{\n \t  SET_HARD_REG_BIT (qty_phys_copy_sugg[reg_qty[ureg]], sreg);\n-\t  qty_phys_has_copy_sugg[reg_qty[ureg]] = 1;\n+\t  qty_phys_num_copy_sugg[reg_qty[ureg]]++;\n \t}\n-      else\n+      else if (! TEST_HARD_REG_BIT (qty_phys_sugg[reg_qty[ureg]], sreg))\n \t{\n \t  SET_HARD_REG_BIT (qty_phys_sugg[reg_qty[ureg]], sreg);\n-\t  qty_phys_has_sugg[reg_qty[ureg]] = 1;\n+\t  qty_phys_num_sugg[reg_qty[ureg]]++;\n \t}\n       return 0;\n     }\n@@ -1984,7 +2096,7 @@ find_free_reg (class, mode, qty, accept_call_clobbered, just_try_suggested,\n \n   if (just_try_suggested)\n     {\n-      if (qty_phys_has_copy_sugg[qty])\n+      if (qty_phys_num_copy_sugg[qty] != 0)\n \tIOR_COMPL_HARD_REG_SET (first_used, qty_phys_copy_sugg[qty]);\n       else\n \tIOR_COMPL_HARD_REG_SET (first_used, qty_phys_sugg[qty]);\n@@ -2029,11 +2141,11 @@ find_free_reg (class, mode, qty, accept_call_clobbered, just_try_suggested,\n   \n   /* If it would be profitable to allocate a call-clobbered register\n      and save and restore it around calls, do that.  */\n-  if (just_try_suggested && qty_phys_has_copy_sugg[qty]\n-      && qty_phys_has_sugg[qty])\n+  if (just_try_suggested && qty_phys_num_copy_sugg[qty] != 0\n+      && qty_phys_num_sugg[qty] != 0)\n     {\n       /* Don't try the copy-suggested regs again.  */\n-      qty_phys_has_copy_sugg[qty] = 0;\n+      qty_phys_num_copy_sugg[qty] = 0;\n       return find_free_reg (class, mode, qty, accept_call_clobbered, 1,\n \t\t\t    born_index, dead_index);\n     }"}]}