{"sha": "2c58d42c3ed599b4c2976fc173eefd8e016ea216", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmM1OGQ0MmMzZWQ1OTliNGMyOTc2ZmMxNzNlZWZkOGUwMTZlYTIxNg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-07-12T13:02:00Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-07-12T13:02:00Z"}, "message": "Use conditional internal functions in if-conversion\n\nThis patch uses IFN_COND_* to vectorise conditionally-executed,\npotentially-trapping arithmetic, such as most floating-point\nops with -ftrapping-math.  E.g.:\n\n    if (cond) { ... x = a + b; ... }\n\nbecomes:\n\n    ...\n    x = .COND_ADD (cond, a, b, else_value);\n    ...\n\nWhen this transformation is done on its own, the value of x for\n!cond isn't important, so else_value is simply the target's\npreferred_else_value (i.e. the value it can handle the most\nefficiently).\n\nHowever, the patch also looks for the equivalent of:\n\n    y = cond ? x : c;\n\nin which the \"then\" value is the result of the conditionally-executed\noperation and the \"else\" value \"c\" is some value that is available at x.\nIn that case we can instead use:\n\n    x = .COND_ADD (cond, a, b, c);\n\nand replace uses of y with uses of x.\n\nThe patch also looks for:\n\n    y = !cond ? c : x;\n\nwhich can be transformed in the same way.  This involved adding a new\nutility function inverse_conditions_p, which was already open-coded\nin a more limited way in match.pd.\n\n2018-07-12  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* fold-const.h (inverse_conditions_p): Declare.\n\t* fold-const.c (inverse_conditions_p): New function.\n\t* match.pd: Use inverse_conditions_p.  Add folds of view_converts\n\tthat test the inverse condition of a conditional internal function.\n\t* internal-fn.h (vectorized_internal_fn_supported_p): Declare.\n\t* internal-fn.c (internal_fn_mask_index): Handle conditional\n\tinternal functions.\n\t(vectorized_internal_fn_supported_p): New function.\n\t* tree-if-conv.c: Include internal-fn.h and fold-const.h.\n\t(any_pred_load_store): Replace with...\n\t(need_to_predicate): ...this new variable.\n\t(redundant_ssa_names): New variable.\n\t(ifcvt_can_use_mask_load_store): Move initial checks to...\n\t(ifcvt_can_predicate): ...this new function.  Handle tree codes\n\tfor which a conditional internal function exists.\n\t(if_convertible_gimple_assign_stmt_p): Use ifcvt_can_predicate\n\tinstead of ifcvt_can_use_mask_load_store.  Update after variable\n\tname change.\n\t(predicate_load_or_store): New function, split out from\n\tpredicate_mem_writes.\n\t(check_redundant_cond_expr): New function.\n\t(value_available_p): Likewise.\n\t(predicate_rhs_code): Likewise.\n\t(predicate_mem_writes): Rename to...\n\t(predicate_statements): ...this.  Use predicate_load_or_store\n\tand predicate_rhs_code.\n\t(combine_blocks, tree_if_conversion): Update after above name changes.\n\t(ifcvt_local_dce): Handle redundant_ssa_names.\n\t* tree-vect-patterns.c (vect_recog_mask_conversion_pattern): Handle\n\tgeneral conditional functions.\n\t* tree-vect-stmts.c (vectorizable_call): Likewise.\n\ngcc/testsuite/\n\t* gcc.dg/vect/vect-cond-arith-4.c: New test.\n\t* gcc.dg/vect/vect-cond-arith-5.c: Likewise.\n\t* gcc.target/aarch64/sve/cond_arith_1.c: Likewise.\n\t* gcc.target/aarch64/sve/cond_arith_1_run.c: Likewise.\n\t* gcc.target/aarch64/sve/cond_arith_2.c: Likewise.\n\t* gcc.target/aarch64/sve/cond_arith_2_run.c: Likewise.\n\t* gcc.target/aarch64/sve/cond_arith_3.c: Likewise.\n\t* gcc.target/aarch64/sve/cond_arith_3_run.c: Likewise.\n\nFrom-SVN: r262589", "tree": {"sha": "1e031aeefba8cc358f1917d8f4088473cf5a38d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1e031aeefba8cc358f1917d8f4088473cf5a38d7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c58d42c3ed599b4c2976fc173eefd8e016ea216", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c58d42c3ed599b4c2976fc173eefd8e016ea216", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c58d42c3ed599b4c2976fc173eefd8e016ea216", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c58d42c3ed599b4c2976fc173eefd8e016ea216/comments", "author": null, "committer": null, "parents": [{"sha": "0936858f081b77319f8f6e5825dc86d2861d0445", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0936858f081b77319f8f6e5825dc86d2861d0445", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0936858f081b77319f8f6e5825dc86d2861d0445"}], "stats": {"total": 981, "additions": 841, "deletions": 140}, "files": [{"sha": "a77b04ccf6b74510aa18b899c785e6e84adf4dec", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c58d42c3ed599b4c2976fc173eefd8e016ea216/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c58d42c3ed599b4c2976fc173eefd8e016ea216/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2c58d42c3ed599b4c2976fc173eefd8e016ea216", "patch": "@@ -1,3 +1,37 @@\n+2018-07-12  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* fold-const.h (inverse_conditions_p): Declare.\n+\t* fold-const.c (inverse_conditions_p): New function.\n+\t* match.pd: Use inverse_conditions_p.  Add folds of view_converts\n+\tthat test the inverse condition of a conditional internal function.\n+\t* internal-fn.h (vectorized_internal_fn_supported_p): Declare.\n+\t* internal-fn.c (internal_fn_mask_index): Handle conditional\n+\tinternal functions.\n+\t(vectorized_internal_fn_supported_p): New function.\n+\t* tree-if-conv.c: Include internal-fn.h and fold-const.h.\n+\t(any_pred_load_store): Replace with...\n+\t(need_to_predicate): ...this new variable.\n+\t(redundant_ssa_names): New variable.\n+\t(ifcvt_can_use_mask_load_store): Move initial checks to...\n+\t(ifcvt_can_predicate): ...this new function.  Handle tree codes\n+\tfor which a conditional internal function exists.\n+\t(if_convertible_gimple_assign_stmt_p): Use ifcvt_can_predicate\n+\tinstead of ifcvt_can_use_mask_load_store.  Update after variable\n+\tname change.\n+\t(predicate_load_or_store): New function, split out from\n+\tpredicate_mem_writes.\n+\t(check_redundant_cond_expr): New function.\n+\t(value_available_p): Likewise.\n+\t(predicate_rhs_code): Likewise.\n+\t(predicate_mem_writes): Rename to...\n+\t(predicate_statements): ...this.  Use predicate_load_or_store\n+\tand predicate_rhs_code.\n+\t(combine_blocks, tree_if_conversion): Update after above name changes.\n+\t(ifcvt_local_dce): Handle redundant_ssa_names.\n+\t* tree-vect-patterns.c (vect_recog_mask_conversion_pattern): Handle\n+\tgeneral conditional functions.\n+\t* tree-vect-stmts.c (vectorizable_call): Likewise.\n+\n 2018-07-12  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "1197d75ec75924d5aa17b7073aa17f6956103831", "filename": "gcc/fold-const.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c58d42c3ed599b4c2976fc173eefd8e016ea216/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c58d42c3ed599b4c2976fc173eefd8e016ea216/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=2c58d42c3ed599b4c2976fc173eefd8e016ea216", "patch": "@@ -2787,6 +2787,22 @@ compcode_to_comparison (enum comparison_code code)\n     }\n }\n \n+/* Return true if COND1 tests the opposite condition of COND2.  */\n+\n+bool\n+inverse_conditions_p (const_tree cond1, const_tree cond2)\n+{\n+  return (COMPARISON_CLASS_P (cond1)\n+\t  && COMPARISON_CLASS_P (cond2)\n+\t  && (invert_tree_comparison\n+\t      (TREE_CODE (cond1),\n+\t       HONOR_NANS (TREE_OPERAND (cond1, 0))) == TREE_CODE (cond2))\n+\t  && operand_equal_p (TREE_OPERAND (cond1, 0),\n+\t\t\t      TREE_OPERAND (cond2, 0), 0)\n+\t  && operand_equal_p (TREE_OPERAND (cond1, 1),\n+\t\t\t      TREE_OPERAND (cond2, 1), 0));\n+}\n+\n /* Return a tree for the comparison which is the combination of\n    doing the AND or OR (depending on CODE) of the two operations LCODE\n    and RCODE on the identical operands LL_ARG and LR_ARG.  Take into account"}, {"sha": "b3225752385b49711934d7ccbcd82a673d03bf06", "filename": "gcc/fold-const.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c58d42c3ed599b4c2976fc173eefd8e016ea216/gcc%2Ffold-const.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c58d42c3ed599b4c2976fc173eefd8e016ea216/gcc%2Ffold-const.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.h?ref=2c58d42c3ed599b4c2976fc173eefd8e016ea216", "patch": "@@ -127,6 +127,7 @@ extern enum tree_code swap_tree_comparison (enum tree_code);\n \n extern bool ptr_difference_const (tree, tree, poly_int64_pod *);\n extern enum tree_code invert_tree_comparison (enum tree_code, bool);\n+extern bool inverse_conditions_p (const_tree, const_tree);\n \n extern bool tree_unary_nonzero_warnv_p (enum tree_code, tree, tree, bool *);\n extern bool tree_binary_nonzero_warnv_p (enum tree_code, tree, tree, tree op1,"}, {"sha": "8ede9cac3ef3118ba4781f6d80f44189874bec91", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c58d42c3ed599b4c2976fc173eefd8e016ea216/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c58d42c3ed599b4c2976fc173eefd8e016ea216/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=2c58d42c3ed599b4c2976fc173eefd8e016ea216", "patch": "@@ -3466,7 +3466,8 @@ internal_fn_mask_index (internal_fn fn)\n       return 4;\n \n     default:\n-      return -1;\n+      return (conditional_internal_fn_code (fn) != ERROR_MARK\n+\t      || get_unconditional_internal_fn (fn) != IFN_LAST ? 0 : -1);\n     }\n }\n \n@@ -3531,6 +3532,26 @@ expand_internal_call (gcall *stmt)\n   expand_internal_call (gimple_call_internal_fn (stmt), stmt);\n }\n \n+/* If TYPE is a vector type, return true if IFN is a direct internal\n+   function that is supported for that type.  If TYPE is a scalar type,\n+   return true if IFN is a direct internal function that is supported for\n+   the target's preferred vector version of TYPE.  */\n+\n+bool\n+vectorized_internal_fn_supported_p (internal_fn ifn, tree type)\n+{\n+  scalar_mode smode;\n+  if (!VECTOR_TYPE_P (type) && is_a <scalar_mode> (TYPE_MODE (type), &smode))\n+    {\n+      machine_mode vmode = targetm.vectorize.preferred_simd_mode (smode);\n+      if (VECTOR_MODE_P (vmode))\n+\ttype = build_vector_type_for_mode (type, vmode);\n+    }\n+\n+  return (VECTOR_MODE_P (TYPE_MODE (type))\n+\t  && direct_internal_fn_supported_p (ifn, type, OPTIMIZE_FOR_SPEED));\n+}\n+\n void\n expand_PHI (internal_fn, gcall *)\n {"}, {"sha": "48db7721aa80f162c6177f2d7af5ce18001efc48", "filename": "gcc/internal-fn.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c58d42c3ed599b4c2976fc173eefd8e016ea216/gcc%2Finternal-fn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c58d42c3ed599b4c2976fc173eefd8e016ea216/gcc%2Finternal-fn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.h?ref=2c58d42c3ed599b4c2976fc173eefd8e016ea216", "patch": "@@ -212,4 +212,6 @@ extern void expand_internal_call (gcall *);\n extern void expand_internal_call (internal_fn, gcall *);\n extern void expand_PHI (internal_fn, gcall *);\n \n+extern bool vectorized_internal_fn_supported_p (internal_fn, tree);\n+\n #endif"}, {"sha": "1a8ad4465858dec02d729e00b8c0900d735262a9", "filename": "gcc/match.pd", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c58d42c3ed599b4c2976fc173eefd8e016ea216/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c58d42c3ed599b4c2976fc173eefd8e016ea216/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=2c58d42c3ed599b4c2976fc173eefd8e016ea216", "patch": "@@ -2951,21 +2951,11 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n     from if-conversion.  */\n  (simplify\n   (cnd @0 @1 (cnd @2 @3 @4))\n-  (if (COMPARISON_CLASS_P (@0)\n-       && COMPARISON_CLASS_P (@2)\n-       && invert_tree_comparison\n-           (TREE_CODE (@0), HONOR_NANS (TREE_OPERAND (@0, 0))) == TREE_CODE (@2)\n-       && operand_equal_p (TREE_OPERAND (@0, 0), TREE_OPERAND (@2, 0), 0)\n-       && operand_equal_p (TREE_OPERAND (@0, 1), TREE_OPERAND (@2, 1), 0))\n+  (if (inverse_conditions_p (@0, @2))\n    (cnd @0 @1 @3)))\n  (simplify\n   (cnd @0 (cnd @1 @2 @3) @4)\n-  (if (COMPARISON_CLASS_P (@0)\n-       && COMPARISON_CLASS_P (@1)\n-       && invert_tree_comparison\n-           (TREE_CODE (@0), HONOR_NANS (TREE_OPERAND (@0, 0))) == TREE_CODE (@1)\n-       && operand_equal_p (TREE_OPERAND (@0, 0), TREE_OPERAND (@1, 0), 0)\n-       && operand_equal_p (TREE_OPERAND (@0, 1), TREE_OPERAND (@1, 1), 0))\n+  (if (inverse_conditions_p (@0, @1))\n    (cnd @0 @3 @4)))\n \n  /* A ? B : B -> B.  */\n@@ -4913,12 +4903,24 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n   (vec_cond @0 (view_convert? (cond_op @0 @1 @2 @3)) @4)\n   (with { tree op_type = TREE_TYPE (@3); }\n    (if (element_precision (type) == element_precision (op_type))\n-    (view_convert (cond_op @0 @1 @2 (view_convert:op_type @4)))))))\n+    (view_convert (cond_op @0 @1 @2 (view_convert:op_type @4))))))\n+ (simplify\n+  (vec_cond @0 @1 (view_convert? (cond_op @2 @3 @4 @5)))\n+  (with { tree op_type = TREE_TYPE (@5); }\n+   (if (inverse_conditions_p (@0, @2)\n+        && element_precision (type) == element_precision (op_type))\n+    (view_convert (cond_op @2 @3 @4 (view_convert:op_type @1)))))))\n \n /* Same for ternary operations.  */\n (for cond_op (COND_TERNARY)\n  (simplify\n   (vec_cond @0 (view_convert? (cond_op @0 @1 @2 @3 @4)) @5)\n   (with { tree op_type = TREE_TYPE (@4); }\n    (if (element_precision (type) == element_precision (op_type))\n-    (view_convert (cond_op @0 @1 @2 @3 (view_convert:op_type @5)))))))\n+    (view_convert (cond_op @0 @1 @2 @3 (view_convert:op_type @5))))))\n+ (simplify\n+  (vec_cond @0 @1 (view_convert? (cond_op @2 @3 @4 @5 @6)))\n+  (with { tree op_type = TREE_TYPE (@6); }\n+   (if (inverse_conditions_p (@0, @2)\n+        && element_precision (type) == element_precision (op_type))\n+    (view_convert (cond_op @2 @3 @4 @5 (view_convert:op_type @1)))))))"}, {"sha": "b101f230e5453f3e26af5087d2da51d2eb0e2c9f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c58d42c3ed599b4c2976fc173eefd8e016ea216/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c58d42c3ed599b4c2976fc173eefd8e016ea216/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2c58d42c3ed599b4c2976fc173eefd8e016ea216", "patch": "@@ -1,3 +1,14 @@\n+2018-07-12  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* gcc.dg/vect/vect-cond-arith-4.c: New test.\n+\t* gcc.dg/vect/vect-cond-arith-5.c: Likewise.\n+\t* gcc.target/aarch64/sve/cond_arith_1.c: Likewise.\n+\t* gcc.target/aarch64/sve/cond_arith_1_run.c: Likewise.\n+\t* gcc.target/aarch64/sve/cond_arith_2.c: Likewise.\n+\t* gcc.target/aarch64/sve/cond_arith_2_run.c: Likewise.\n+\t* gcc.target/aarch64/sve/cond_arith_3.c: Likewise.\n+\t* gcc.target/aarch64/sve/cond_arith_3_run.c: Likewise.\n+\n 2018-07-12  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "55a174a7ec1fa42c40d4359e882ca475a4feaca3", "filename": "gcc/testsuite/gcc.dg/vect/vect-cond-arith-4.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c58d42c3ed599b4c2976fc173eefd8e016ea216/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cond-arith-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c58d42c3ed599b4c2976fc173eefd8e016ea216/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cond-arith-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cond-arith-4.c?ref=2c58d42c3ed599b4c2976fc173eefd8e016ea216", "patch": "@@ -0,0 +1,58 @@\n+/* { dg-additional-options \"-fdump-tree-optimized\" } */\n+\n+#include \"tree-vect.h\"\n+\n+#define N (VECTOR_BITS * 11 / 64 + 3)\n+\n+#define add(A, B) ((A) + (B))\n+#define sub(A, B) ((A) - (B))\n+#define mul(A, B) ((A) * (B))\n+#define div(A, B) ((A) / (B))\n+\n+#define DEF(OP)\t\t\t\t\t\t\t\\\n+  void __attribute__ ((noipa))\t\t\t\t\t\\\n+  f_##OP (double *restrict a, double *restrict b, double x)\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\t\t\\\n+      a[i] = b[i] < 100 ? OP (b[i], x) : b[i];\t\t\t\\\n+  }\n+\n+#define TEST(OP)\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\\\n+    f_##OP (a, b, 10);\t\t\t\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tint bval = (i % 17) * 10;\t\t\t\\\n+\tint truev = OP (bval, 10);\t\t\t\\\n+\tif (a[i] != (bval < 100 ? truev : bval))\t\\\n+\t__builtin_abort ();\t\t\t\t\\\n+\tasm volatile (\"\" ::: \"memory\");\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+  }\n+\n+#define FOR_EACH_OP(T)\t\t\t\t\\\n+  T (add)\t\t\t\t\t\\\n+  T (sub)\t\t\t\t\t\\\n+  T (mul)\t\t\t\t\t\\\n+  T (div)\n+\n+FOR_EACH_OP (DEF)\n+\n+int\n+main (void)\n+{\n+  double a[N], b[N];\n+  for (int i = 0; i < N; ++i)\n+    {\n+      b[i] = (i % 17) * 10;\n+      asm volatile (\"\" ::: \"memory\");\n+    }\n+  FOR_EACH_OP (TEST)\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump { = \\.COND_ADD} \"optimized\" { target vect_double_cond_arith } } } */\n+/* { dg-final { scan-tree-dump { = \\.COND_SUB} \"optimized\" { target vect_double_cond_arith } } } */\n+/* { dg-final { scan-tree-dump { = \\.COND_MUL} \"optimized\" { target vect_double_cond_arith } } } */\n+/* { dg-final { scan-tree-dump { = \\.COND_RDIV} \"optimized\" { target vect_double_cond_arith } } } */\n+/* { dg-final { scan-tree-dump-not {VEC_COND_EXPR} \"optimized\" { target vect_double_cond_arith } } } */"}, {"sha": "d2eadc4e9454eba204b94532ee3b002692969ddb", "filename": "gcc/testsuite/gcc.dg/vect/vect-cond-arith-5.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c58d42c3ed599b4c2976fc173eefd8e016ea216/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cond-arith-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c58d42c3ed599b4c2976fc173eefd8e016ea216/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cond-arith-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cond-arith-5.c?ref=2c58d42c3ed599b4c2976fc173eefd8e016ea216", "patch": "@@ -0,0 +1,60 @@\n+/* { dg-additional-options \"-fdump-tree-optimized\" } */\n+\n+#include \"tree-vect.h\"\n+\n+#define N (VECTOR_BITS * 11 / 64 + 3)\n+\n+#define add(A, B) ((A) + (B))\n+#define sub(A, B) ((A) - (B))\n+#define mul(A, B) ((A) * (B))\n+#define div(A, B) ((A) / (B))\n+\n+#define DEF(OP)\t\t\t\t\t\t\t\\\n+  void __attribute__ ((noipa))\t\t\t\t\t\\\n+  f_##OP (double *restrict a, double *restrict b, double x)\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\t\t\\\n+      if (b[i] < 100)\t\t\t\t\t\t\\\n+\ta[i] = OP (b[i], x);\t\t\t\t\t\\\n+  }\n+\n+#define TEST(OP)\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\\\n+    f_##OP (a, b, 10);\t\t\t\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tint bval = (i % 17) * 10;\t\t\t\\\n+\tint truev = OP (bval, 10);\t\t\t\\\n+\tif (a[i] != (bval < 100 ? truev : i * 3))\t\\\n+\t  __builtin_abort ();\t\t\t\t\\\n+\tasm volatile (\"\" ::: \"memory\");\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+  }\n+\n+#define FOR_EACH_OP(T)\t\t\t\t\\\n+  T (add)\t\t\t\t\t\\\n+  T (sub)\t\t\t\t\t\\\n+  T (mul)\t\t\t\t\t\\\n+  T (div)\n+\n+FOR_EACH_OP (DEF)\n+\n+int\n+main (void)\n+{\n+  double a[N], b[N];\n+  for (int i = 0; i < N; ++i)\n+    {\n+      a[i] = i * 3;\n+      b[i] = (i % 17) * 10;\n+      asm volatile (\"\" ::: \"memory\");\n+    }\n+  FOR_EACH_OP (TEST)\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump { = \\.COND_ADD} \"optimized\" { target { vect_double_cond_arith && vect_masked_store } } } } */\n+/* { dg-final { scan-tree-dump { = \\.COND_SUB} \"optimized\" { target { vect_double_cond_arith && vect_masked_store } } } } */\n+/* { dg-final { scan-tree-dump { = \\.COND_MUL} \"optimized\" { target { vect_double_cond_arith && vect_masked_store } } } } */\n+/* { dg-final { scan-tree-dump { = \\.COND_RDIV} \"optimized\" { target { vect_double_cond_arith && vect_masked_store } } } } */\n+/* { dg-final { scan-tree-dump-not {VEC_COND_EXPR} \"optimized\" { target { vect_double_cond_arith && vect_masked_store } } } } */"}, {"sha": "52138d2b023bee8160737c1946a9025456fd3374", "filename": "gcc/testsuite/gcc.target/aarch64/sve/cond_arith_1.c", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c58d42c3ed599b4c2976fc173eefd8e016ea216/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fcond_arith_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c58d42c3ed599b4c2976fc173eefd8e016ea216/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fcond_arith_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fcond_arith_1.c?ref=2c58d42c3ed599b4c2976fc173eefd8e016ea216", "patch": "@@ -0,0 +1,64 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#include <stdint.h>\n+\n+#define TEST(TYPE, NAME, OP)\t\t\t\t\\\n+  void __attribute__ ((noinline, noclone))\t\t\\\n+  test_##TYPE##_##NAME (TYPE *__restrict x,\t\t\\\n+\t\t\tTYPE *__restrict y,\t\t\\\n+\t\t\tTYPE *__restrict z,\t\t\\\n+\t\t\tTYPE *__restrict pred, int n)\t\\\n+  {\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < n; ++i)\t\t\t\t\\\n+      x[i] = pred[i] != 1 ? y[i] OP z[i] : y[i];\t\\\n+  }\n+\n+#define TEST_INT_TYPE(TYPE) \\\n+  TEST (TYPE, div, /)\n+\n+#define TEST_FP_TYPE(TYPE) \\\n+  TEST (TYPE, add, +) \\\n+  TEST (TYPE, sub, -) \\\n+  TEST (TYPE, mul, *) \\\n+  TEST (TYPE, div, /)\n+\n+#define TEST_ALL \\\n+  TEST_INT_TYPE (int8_t) \\\n+  TEST_INT_TYPE (uint8_t) \\\n+  TEST_INT_TYPE (int16_t) \\\n+  TEST_INT_TYPE (uint16_t) \\\n+  TEST_INT_TYPE (int32_t) \\\n+  TEST_INT_TYPE (uint32_t) \\\n+  TEST_INT_TYPE (int64_t) \\\n+  TEST_INT_TYPE (uint64_t) \\\n+  TEST_FP_TYPE (float) \\\n+  TEST_FP_TYPE (double)\n+\n+TEST_ALL\n+\n+/* { dg-final { scan-assembler-not {\\t.div\\tz[0-9]+\\.b} } } */\t\t\\\n+/* { dg-final { scan-assembler-not {\\t.div\\tz[0-9]+\\.h} } } */\t\t\\\n+/* { dg-final { scan-assembler-times {\\tsdiv\\tz[0-9]+\\.s, p[0-7]/m,} 7 } } */\n+/* At present we don't vectorize the uint8_t or uint16_t loops because the\n+   division is done directly in the narrow type, rather than being widened\n+   to int first.  */\n+/* { dg-final { scan-assembler-times {\\tudiv\\tz[0-9]+\\.s, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tsdiv\\tz[0-9]+\\.d, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tudiv\\tz[0-9]+\\.d, p[0-7]/m,} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tfadd\\tz[0-9]+\\.s, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tfadd\\tz[0-9]+\\.d, p[0-7]/m,} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tfsub\\tz[0-9]+\\.s, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tfsub\\tz[0-9]+\\.d, p[0-7]/m,} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tfmul\\tz[0-9]+\\.s, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tfmul\\tz[0-9]+\\.d, p[0-7]/m,} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tfdiv\\tz[0-9]+\\.s, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tfdiv\\tz[0-9]+\\.d, p[0-7]/m,} 1 } } */\n+\n+/* We fail to optimize away the SEL for the int8_t and int16_t loops,\n+   because the 32-bit result is converted before selection.  */\n+/* { dg-final { scan-assembler-times {\\tsel\\t} 2 } } */"}, {"sha": "876f98f6ec20ca5087f0164d67b893333f253106", "filename": "gcc/testsuite/gcc.target/aarch64/sve/cond_arith_1_run.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c58d42c3ed599b4c2976fc173eefd8e016ea216/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fcond_arith_1_run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c58d42c3ed599b4c2976fc173eefd8e016ea216/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fcond_arith_1_run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fcond_arith_1_run.c?ref=2c58d42c3ed599b4c2976fc173eefd8e016ea216", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#include \"cond_arith_1.c\"\n+\n+#define N 99\n+\n+#undef TEST\n+#define TEST(TYPE, NAME, OP)\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    TYPE x[N], y[N], z[N], pred[N];\t\t\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\ty[i] = i * i;\t\t\t\t\t\t\\\n+\tz[i] = ((i + 2) % 3) * (i + 1);\t\t\t\t\\\n+\tpred[i] = i % 3;\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    test_##TYPE##_##NAME (x, y, z, pred, N);\t\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tTYPE expected = i % 3 != 1 ? y[i] OP z[i] : y[i];\t\\\n+\tif (x[i] != expected)\t\t\t\t\t\\\n+\t  __builtin_abort ();\t\t\t\t\t\\\n+\tasm volatile (\"\" ::: \"memory\");\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+  }\n+\n+int\n+main (void)\n+{\n+  TEST_ALL\n+  return 0;\n+}"}, {"sha": "0474ab52d4a0f7fd912be35a2f3424fb9e2e510b", "filename": "gcc/testsuite/gcc.target/aarch64/sve/cond_arith_2.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c58d42c3ed599b4c2976fc173eefd8e016ea216/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fcond_arith_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c58d42c3ed599b4c2976fc173eefd8e016ea216/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fcond_arith_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fcond_arith_2.c?ref=2c58d42c3ed599b4c2976fc173eefd8e016ea216", "patch": "@@ -0,0 +1,63 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize -fno-vect-cost-model\" } */\n+\n+#include <stdint.h>\n+\n+#define TEST(DATA_TYPE, PRED_TYPE, NAME, OP)\t\t\t\t\\\n+  void __attribute__ ((noinline, noclone))\t\t\t\t\\\n+  test_##DATA_TYPE##_##PRED_TYPE##_##NAME (DATA_TYPE *__restrict x,\t\\\n+\t\t\t\t\t   DATA_TYPE *__restrict y,\t\\\n+\t\t\t\t\t   DATA_TYPE *__restrict z,\t\\\n+\t\t\t\t\t   PRED_TYPE *__restrict pred,\t\\\n+\t\t\t\t\t   int n)\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < n; ++i)\t\t\t\t\t\t\\\n+      x[i] = pred[i] != 1 ? y[i] OP z[i] : y[i];\t\t\t\\\n+  }\n+\n+#define TEST_INT_TYPE(DATA_TYPE, PRED_TYPE) \\\n+  TEST (DATA_TYPE, PRED_TYPE, div, /)\n+\n+#define TEST_FP_TYPE(DATA_TYPE, PRED_TYPE) \\\n+  TEST (DATA_TYPE, PRED_TYPE, add, +) \\\n+  TEST (DATA_TYPE, PRED_TYPE, sub, -) \\\n+  TEST (DATA_TYPE, PRED_TYPE, mul, *) \\\n+  TEST (DATA_TYPE, PRED_TYPE, div, /)\n+\n+#define TEST_ALL \\\n+  TEST_INT_TYPE (int32_t, int8_t) \\\n+  TEST_INT_TYPE (uint32_t, int8_t) \\\n+  TEST_INT_TYPE (int32_t, int16_t) \\\n+  TEST_INT_TYPE (uint32_t, int16_t) \\\n+  TEST_INT_TYPE (int64_t, int8_t) \\\n+  TEST_INT_TYPE (uint64_t, int8_t) \\\n+  TEST_INT_TYPE (int64_t, int16_t) \\\n+  TEST_INT_TYPE (uint64_t, int16_t) \\\n+  TEST_INT_TYPE (int64_t, int32_t) \\\n+  TEST_INT_TYPE (uint64_t, int32_t) \\\n+  TEST_FP_TYPE (float, int8_t) \\\n+  TEST_FP_TYPE (float, int16_t) \\\n+  TEST_FP_TYPE (double, int8_t) \\\n+  TEST_FP_TYPE (double, int16_t) \\\n+  TEST_FP_TYPE (double, int32_t)\n+\n+TEST_ALL\n+\n+/* { dg-final { scan-assembler-times {\\tsdiv\\tz[0-9]+\\.s, p[0-7]/m,} 6 } } */\n+/* { dg-final { scan-assembler-times {\\tudiv\\tz[0-9]+\\.s, p[0-7]/m,} 6 } } */\n+/* { dg-final { scan-assembler-times {\\tsdiv\\tz[0-9]+\\.d, p[0-7]/m,} 14 } } */\n+/* { dg-final { scan-assembler-times {\\tudiv\\tz[0-9]+\\.d, p[0-7]/m,} 14 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tfadd\\tz[0-9]+\\.s, p[0-7]/m,} 6 } } */\n+/* { dg-final { scan-assembler-times {\\tfadd\\tz[0-9]+\\.d, p[0-7]/m,} 14 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tfsub\\tz[0-9]+\\.s, p[0-7]/m,} 6 } } */\n+/* { dg-final { scan-assembler-times {\\tfsub\\tz[0-9]+\\.d, p[0-7]/m,} 14 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tfmul\\tz[0-9]+\\.s, p[0-7]/m,} 6 } } */\n+/* { dg-final { scan-assembler-times {\\tfmul\\tz[0-9]+\\.d, p[0-7]/m,} 14 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tfdiv\\tz[0-9]+\\.s, p[0-7]/m,} 6 } } */\n+/* { dg-final { scan-assembler-times {\\tfdiv\\tz[0-9]+\\.d, p[0-7]/m,} 14 } } */\n+\n+/* { dg-final { scan-assembler-not {\\tsel\\t} } } */"}, {"sha": "1eac60552eefad20736cb772fd0caab6040a70fb", "filename": "gcc/testsuite/gcc.target/aarch64/sve/cond_arith_2_run.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c58d42c3ed599b4c2976fc173eefd8e016ea216/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fcond_arith_2_run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c58d42c3ed599b4c2976fc173eefd8e016ea216/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fcond_arith_2_run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fcond_arith_2_run.c?ref=2c58d42c3ed599b4c2976fc173eefd8e016ea216", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#include \"cond_arith_2.c\"\n+\n+#define N 99\n+\n+#undef TEST\n+#define TEST(DATA_TYPE, PRED_TYPE, NAME, OP)\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    DATA_TYPE x[N], y[N], z[N];\t\t\t\t\t\\\n+    PRED_TYPE pred[N];\t\t\t\t\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\ty[i] = i * i;\t\t\t\t\t\t\\\n+\tz[i] = ((i + 2) % 3) * (i + 1);\t\t\t\t\\\n+\tpred[i] = i % 3;\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    test_##DATA_TYPE##_##PRED_TYPE##_##NAME (x, y, z, pred, N);\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tDATA_TYPE expected = i % 3 != 1 ? y[i] OP z[i] : y[i];\t\\\n+\tif (x[i] != expected)\t\t\t\t\t\\\n+\t  __builtin_abort ();\t\t\t\t\t\\\n+\tasm volatile (\"\" ::: \"memory\");\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+  }\n+\n+int\n+main (void)\n+{\n+  TEST_ALL\n+  return 0;\n+}"}, {"sha": "94eb255c969b535f61d19a0abe9c77d2cca1b652", "filename": "gcc/testsuite/gcc.target/aarch64/sve/cond_arith_3.c", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c58d42c3ed599b4c2976fc173eefd8e016ea216/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fcond_arith_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c58d42c3ed599b4c2976fc173eefd8e016ea216/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fcond_arith_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fcond_arith_3.c?ref=2c58d42c3ed599b4c2976fc173eefd8e016ea216", "patch": "@@ -0,0 +1,62 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#include <stdint.h>\n+\n+#define TEST(TYPE, NAME, OP)\t\t\t\t\\\n+  void __attribute__ ((noinline, noclone))\t\t\\\n+  test_##TYPE##_##NAME (TYPE *__restrict x,\t\t\\\n+\t\t\tTYPE *__restrict y,\t\t\\\n+\t\t\tTYPE *__restrict z,\t\t\\\n+\t\t\tTYPE *__restrict pred, int n)\t\\\n+  {\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < n; ++i)\t\t\t\t\\\n+      x[i] = pred[i] != 1 ? y[i] OP z[i] : 1;\t\t\\\n+  }\n+\n+#define TEST_INT_TYPE(TYPE) \\\n+  TEST (TYPE, div, /)\n+\n+#define TEST_FP_TYPE(TYPE) \\\n+  TEST (TYPE, add, +) \\\n+  TEST (TYPE, sub, -) \\\n+  TEST (TYPE, mul, *) \\\n+  TEST (TYPE, div, /)\n+\n+#define TEST_ALL \\\n+  TEST_INT_TYPE (int8_t) \\\n+  TEST_INT_TYPE (uint8_t) \\\n+  TEST_INT_TYPE (int16_t) \\\n+  TEST_INT_TYPE (uint16_t) \\\n+  TEST_INT_TYPE (int32_t) \\\n+  TEST_INT_TYPE (uint32_t) \\\n+  TEST_INT_TYPE (int64_t) \\\n+  TEST_INT_TYPE (uint64_t) \\\n+  TEST_FP_TYPE (float) \\\n+  TEST_FP_TYPE (double)\n+\n+TEST_ALL\n+\n+/* { dg-final { scan-assembler-not {\\t.div\\tz[0-9]+\\.b} } } */\t\t\\\n+/* { dg-final { scan-assembler-not {\\t.div\\tz[0-9]+\\.h} } } */\t\t\\\n+/* { dg-final { scan-assembler-times {\\tsdiv\\tz[0-9]+\\.s, p[0-7]/m,} 7 } } */\n+/* At present we don't vectorize the uint8_t or uint16_t loops because the\n+   division is done directly in the narrow type, rather than being widened\n+   to int first.  */\n+/* { dg-final { scan-assembler-times {\\tudiv\\tz[0-9]+\\.s, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tsdiv\\tz[0-9]+\\.d, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tudiv\\tz[0-9]+\\.d, p[0-7]/m,} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tfadd\\tz[0-9]+\\.s, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tfadd\\tz[0-9]+\\.d, p[0-7]/m,} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tfsub\\tz[0-9]+\\.s, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tfsub\\tz[0-9]+\\.d, p[0-7]/m,} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tfmul\\tz[0-9]+\\.s, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tfmul\\tz[0-9]+\\.d, p[0-7]/m,} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tfdiv\\tz[0-9]+\\.s, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tfdiv\\tz[0-9]+\\.d, p[0-7]/m,} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tsel\\t} 14 } } */"}, {"sha": "31457da523b459eb7f28e46c9ede183c3fa7e697", "filename": "gcc/testsuite/gcc.target/aarch64/sve/cond_arith_3_run.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c58d42c3ed599b4c2976fc173eefd8e016ea216/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fcond_arith_3_run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c58d42c3ed599b4c2976fc173eefd8e016ea216/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fcond_arith_3_run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fcond_arith_3_run.c?ref=2c58d42c3ed599b4c2976fc173eefd8e016ea216", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#include \"cond_arith_3.c\"\n+\n+#define N 99\n+\n+#undef TEST\n+#define TEST(TYPE, NAME, OP)\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    TYPE x[N], y[N], z[N], pred[N];\t\t\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tx[i] = -1;\t\t\t\t\t\t\\\n+\ty[i] = i * i;\t\t\t\t\t\t\\\n+\tz[i] = ((i + 2) % 3) * (i + 1);\t\t\t\t\\\n+\tpred[i] = i % 3;\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    test_##TYPE##_##NAME (x, y, z, pred, N);\t\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tTYPE expected = i % 3 != 1 ? y[i] OP z[i] : 1;\t\t\\\n+\tif (x[i] != expected)\t\t\t\t\t\\\n+\t  __builtin_abort ();\t\t\t\t\t\\\n+\tasm volatile (\"\" ::: \"memory\");\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+  }\n+\n+int\n+main (void)\n+{\n+  TEST_ALL\n+  return 0;\n+}"}, {"sha": "e181468fba91a6e17afb7b6dea0371e5fc5d8275", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 224, "deletions": 61, "changes": 285, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c58d42c3ed599b4c2976fc173eefd8e016ea216/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c58d42c3ed599b4c2976fc173eefd8e016ea216/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=2c58d42c3ed599b4c2976fc173eefd8e016ea216", "patch": "@@ -116,15 +116,19 @@ along with GCC; see the file COPYING3.  If not see\n #include \"builtins.h\"\n #include \"params.h\"\n #include \"cfganal.h\"\n+#include \"internal-fn.h\"\n+#include \"fold-const.h\"\n \n /* Only handle PHIs with no more arguments unless we are asked to by\n    simd pragma.  */\n #define MAX_PHI_ARG_NUM \\\n   ((unsigned) PARAM_VALUE (PARAM_MAX_TREE_IF_CONVERSION_PHI_ARGS))\n \n-/* Indicate if new load/store that needs to be predicated is introduced\n-   during if conversion.  */\n-static bool any_pred_load_store;\n+/* True if we've converted a statement that was only executed when some\n+   condition C was true, and if for correctness we need to predicate the\n+   statement to ensure that it is a no-op when C is false.  See\n+   predicate_statements for the kinds of predication we support.  */\n+static bool need_to_predicate;\n \n /* Indicate if there are any complicated PHIs that need to be handled in\n    if-conversion.  Complicated PHI has more than two arguments and can't\n@@ -193,6 +197,9 @@ static hash_map<innermost_loop_behavior_hash,\n /* Hash table to store <base reference, DR> pairs.  */\n static hash_map<tree_operand_hash, data_reference_p> *baseref_DR_map;\n \n+/* List of redundant SSA names: the first should be replaced by the second.  */\n+static vec< std::pair<tree, tree> > redundant_ssa_names;\n+\n /* Structure used to predicate basic blocks.  This is attached to the\n    ->aux field of the BBs in the loop to be if-converted.  */\n struct bb_predicate {\n@@ -919,19 +926,10 @@ ifcvt_memrefs_wont_trap (gimple *stmt, vec<data_reference_p> drs)\n static bool\n ifcvt_can_use_mask_load_store (gimple *stmt)\n {\n-  tree lhs, ref;\n-  machine_mode mode;\n-  basic_block bb = gimple_bb (stmt);\n-  bool is_load;\n-\n-  if (!(flag_tree_loop_vectorize || bb->loop_father->force_vectorize)\n-      || bb->loop_father->dont_vectorize\n-      || !gimple_assign_single_p (stmt)\n-      || gimple_has_volatile_ops (stmt))\n-    return false;\n-\n   /* Check whether this is a load or store.  */\n-  lhs = gimple_assign_lhs (stmt);\n+  tree lhs = gimple_assign_lhs (stmt);\n+  bool is_load;\n+  tree ref;\n   if (gimple_store_p (stmt))\n     {\n       if (!is_gimple_val (gimple_assign_rhs1 (stmt)))\n@@ -952,7 +950,7 @@ ifcvt_can_use_mask_load_store (gimple *stmt)\n \n   /* Mask should be integer mode of the same size as the load/store\n      mode.  */\n-  mode = TYPE_MODE (TREE_TYPE (lhs));\n+  machine_mode mode = TYPE_MODE (TREE_TYPE (lhs));\n   if (!int_mode_for_mode (mode).exists () || VECTOR_MODE_P (mode))\n     return false;\n \n@@ -962,6 +960,32 @@ ifcvt_can_use_mask_load_store (gimple *stmt)\n   return false;\n }\n \n+/* Return true if STMT could be converted from an operation that is\n+   unconditional to one that is conditional on a bb predicate mask.  */\n+\n+static bool\n+ifcvt_can_predicate (gimple *stmt)\n+{\n+  basic_block bb = gimple_bb (stmt);\n+\n+  if (!(flag_tree_loop_vectorize || bb->loop_father->force_vectorize)\n+      || bb->loop_father->dont_vectorize\n+      || gimple_has_volatile_ops (stmt))\n+    return false;\n+\n+  if (gimple_assign_single_p (stmt))\n+    return ifcvt_can_use_mask_load_store (stmt);\n+\n+  tree_code code = gimple_assign_rhs_code (stmt);\n+  tree lhs_type = TREE_TYPE (gimple_assign_lhs (stmt));\n+  tree rhs_type = TREE_TYPE (gimple_assign_rhs1 (stmt));\n+  if (!types_compatible_p (lhs_type, rhs_type))\n+    return false;\n+  internal_fn cond_fn = get_conditional_internal_fn (code);\n+  return (cond_fn != IFN_LAST\n+\t  && vectorized_internal_fn_supported_p (cond_fn, lhs_type));\n+}\n+\n /* Return true when STMT is if-convertible.\n \n    GIMPLE_ASSIGN statement is not if-convertible if,\n@@ -1006,10 +1030,10 @@ if_convertible_gimple_assign_stmt_p (gimple *stmt,\n        || ! ifcvt_memrefs_wont_trap (stmt, refs))\n       && gimple_could_trap_p (stmt))\n     {\n-      if (ifcvt_can_use_mask_load_store (stmt))\n+      if (ifcvt_can_predicate (stmt))\n \t{\n \t  gimple_set_plf (stmt, GF_PLF_2, true);\n-\t  any_pred_load_store = true;\n+\t  need_to_predicate = true;\n \t  return true;\n \t}\n       if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -1020,7 +1044,7 @@ if_convertible_gimple_assign_stmt_p (gimple *stmt,\n   /* When if-converting stores force versioning, likewise if we\n      ended up generating store data races.  */\n   if (gimple_vdef (stmt))\n-    any_pred_load_store = true;\n+    need_to_predicate = true;\n \n   return true;\n }\n@@ -2052,7 +2076,7 @@ insert_gimplified_predicates (loop_p loop)\n       stmts = bb_predicate_gimplified_stmts (bb);\n       if (stmts)\n \t{\n-\t  if (any_pred_load_store)\n+\t  if (need_to_predicate)\n \t    {\n \t      /* Insert the predicate of the BB just after the label,\n \t\t as the if-conversion of memory writes will use this\n@@ -2080,7 +2104,7 @@ insert_gimplified_predicates (loop_p loop)\n     }\n }\n \n-/* Helper function for predicate_mem_writes. Returns index of existent\n+/* Helper function for predicate_statements. Returns index of existent\n    mask if it was created for given SIZE and -1 otherwise.  */\n \n static int\n@@ -2094,6 +2118,160 @@ mask_exists (int size, vec<int> vec)\n   return -1;\n }\n \n+/* Helper function for predicate_statements.  STMT is a memory read or\n+   write and it needs to be predicated by MASK.  Return a statement\n+   that does so.  */\n+\n+static gimple *\n+predicate_load_or_store (gimple_stmt_iterator *gsi, gassign *stmt, tree mask)\n+{\n+  gcall *new_stmt;\n+\n+  tree lhs = gimple_assign_lhs (stmt);\n+  tree rhs = gimple_assign_rhs1 (stmt);\n+  tree ref = TREE_CODE (lhs) == SSA_NAME ? rhs : lhs;\n+  mark_addressable (ref);\n+  tree addr = force_gimple_operand_gsi (gsi, build_fold_addr_expr (ref),\n+\t\t\t\t\ttrue, NULL_TREE, true, GSI_SAME_STMT);\n+  tree ptr = build_int_cst (reference_alias_ptr_type (ref),\n+\t\t\t    get_object_alignment (ref));\n+  /* Copy points-to info if possible.  */\n+  if (TREE_CODE (addr) == SSA_NAME && !SSA_NAME_PTR_INFO (addr))\n+    copy_ref_info (build2 (MEM_REF, TREE_TYPE (ref), addr, ptr),\n+\t\t   ref);\n+  if (TREE_CODE (lhs) == SSA_NAME)\n+    {\n+      new_stmt\n+\t= gimple_build_call_internal (IFN_MASK_LOAD, 3, addr,\n+\t\t\t\t      ptr, mask);\n+      gimple_call_set_lhs (new_stmt, lhs);\n+      gimple_set_vuse (new_stmt, gimple_vuse (stmt));\n+    }\n+  else\n+    {\n+      new_stmt\n+\t= gimple_build_call_internal (IFN_MASK_STORE, 4, addr, ptr,\n+\t\t\t\t      mask, rhs);\n+      gimple_set_vuse (new_stmt, gimple_vuse (stmt));\n+      gimple_set_vdef (new_stmt, gimple_vdef (stmt));\n+      SSA_NAME_DEF_STMT (gimple_vdef (new_stmt)) = new_stmt;\n+    }\n+  gimple_call_set_nothrow (new_stmt, true);\n+  return new_stmt;\n+}\n+\n+/* STMT uses OP_LHS.  Check whether it is equivalent to:\n+\n+     ... = OP_MASK ? OP_LHS : X;\n+\n+   Return X if so, otherwise return null.  OP_MASK is an SSA_NAME that is\n+   known to have value OP_COND.  */\n+\n+static tree\n+check_redundant_cond_expr (gimple *stmt, tree op_mask, tree op_cond,\n+\t\t\t   tree op_lhs)\n+{\n+  gassign *assign = dyn_cast <gassign *> (stmt);\n+  if (!assign || gimple_assign_rhs_code (assign) != COND_EXPR)\n+    return NULL_TREE;\n+\n+  tree use_cond = gimple_assign_rhs1 (assign);\n+  tree if_true = gimple_assign_rhs2 (assign);\n+  tree if_false = gimple_assign_rhs3 (assign);\n+\n+  if ((use_cond == op_mask || operand_equal_p (use_cond, op_cond, 0))\n+      && if_true == op_lhs)\n+    return if_false;\n+\n+  if (inverse_conditions_p (use_cond, op_cond) && if_false == op_lhs)\n+    return if_true;\n+\n+  return NULL_TREE;\n+}\n+\n+/* Return true if VALUE is available for use at STMT.  SSA_NAMES is\n+   the set of SSA names defined earlier in STMT's block.  */\n+\n+static bool\n+value_available_p (gimple *stmt, hash_set<tree_ssa_name_hash> *ssa_names,\n+\t\t   tree value)\n+{\n+  if (is_gimple_min_invariant (value))\n+    return true;\n+\n+  if (TREE_CODE (value) == SSA_NAME)\n+    {\n+      if (SSA_NAME_IS_DEFAULT_DEF (value))\n+\treturn true;\n+\n+      basic_block def_bb = gimple_bb (SSA_NAME_DEF_STMT (value));\n+      basic_block use_bb = gimple_bb (stmt);\n+      return (def_bb == use_bb\n+\t      ? ssa_names->contains (value)\n+\t      : dominated_by_p (CDI_DOMINATORS, use_bb, def_bb));\n+    }\n+\n+  return false;\n+}\n+\n+/* Helper function for predicate_statements.  STMT is a potentially-trapping\n+   arithmetic operation that needs to be predicated by MASK, an SSA_NAME that\n+   has value COND.  Return a statement that does so.  SSA_NAMES is the set of\n+   SSA names defined earlier in STMT's block.  */\n+\n+static gimple *\n+predicate_rhs_code (gassign *stmt, tree mask, tree cond,\n+\t\t    hash_set<tree_ssa_name_hash> *ssa_names)\n+{\n+  tree lhs = gimple_assign_lhs (stmt);\n+  tree_code code = gimple_assign_rhs_code (stmt);\n+  unsigned int nops = gimple_num_ops (stmt);\n+  internal_fn cond_fn = get_conditional_internal_fn (code);\n+\n+  /* Construct the arguments to the conditional internal function.   */\n+  auto_vec<tree, 8> args;\n+  args.safe_grow (nops + 1);\n+  args[0] = mask;\n+  for (unsigned int i = 1; i < nops; ++i)\n+    args[i] = gimple_op (stmt, i);\n+  args[nops] = NULL_TREE;\n+\n+  /* Look for uses of the result to see whether they are COND_EXPRs that can\n+     be folded into the conditional call.  */\n+  imm_use_iterator imm_iter;\n+  gimple *use_stmt;\n+  FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter, lhs)\n+    {\n+      tree new_else = check_redundant_cond_expr (use_stmt, mask, cond, lhs);\n+      if (new_else && value_available_p (stmt, ssa_names, new_else))\n+\t{\n+\t  if (!args[nops])\n+\t    args[nops] = new_else;\n+\t  if (operand_equal_p (new_else, args[nops], 0))\n+\t    {\n+\t      /* We have:\n+\n+\t\t   LHS = IFN_COND (MASK, ..., ELSE);\n+\t\t   X = MASK ? LHS : ELSE;\n+\n+\t\t which makes X equivalent to LHS.  */\n+\t      tree use_lhs = gimple_assign_lhs (use_stmt);\n+\t      redundant_ssa_names.safe_push (std::make_pair (use_lhs, lhs));\n+\t    }\n+\t}\n+    }\n+  if (!args[nops])\n+    args[nops] = targetm.preferred_else_value (cond_fn, TREE_TYPE (lhs),\n+\t\t\t\t\t       nops - 1, &args[1]);\n+\n+  /* Create and insert the call.  */\n+  gcall *new_stmt = gimple_build_call_internal_vec (cond_fn, args);\n+  gimple_call_set_lhs (new_stmt, lhs);\n+  gimple_call_set_nothrow (new_stmt, true);\n+\n+  return new_stmt;\n+}\n+\n /* Predicate each write to memory in LOOP.\n \n    This function transforms control flow constructs containing memory\n@@ -2158,7 +2336,7 @@ mask_exists (int size, vec<int> vec)\n    |   goto bb_1\n    | end_bb_4\n \n-   predicate_mem_writes is then predicating the memory write as follows:\n+   predicate_statements is then predicating the memory write as follows:\n \n    | bb_0\n    |   i = 0\n@@ -2202,19 +2380,19 @@ mask_exists (int size, vec<int> vec)\n */\n \n static void\n-predicate_mem_writes (loop_p loop)\n+predicate_statements (loop_p loop)\n {\n   unsigned int i, orig_loop_num_nodes = loop->num_nodes;\n   auto_vec<int, 1> vect_sizes;\n   auto_vec<tree, 1> vect_masks;\n+  hash_set<tree_ssa_name_hash> ssa_names;\n \n   for (i = 1; i < orig_loop_num_nodes; i++)\n     {\n       gimple_stmt_iterator gsi;\n       basic_block bb = ifc_bbs[i];\n       tree cond = bb_predicate (bb);\n       bool swap;\n-      gimple *stmt;\n       int index;\n \n       if (is_true_predicate (cond))\n@@ -2232,7 +2410,8 @@ predicate_mem_writes (loop_p loop)\n \n       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi);)\n \t{\n-\t  if (!gimple_assign_single_p (stmt = gsi_stmt (gsi)))\n+\t  gassign *stmt = dyn_cast <gassign *> (gsi_stmt (gsi));\n+\t  if (!stmt)\n \t    ;\n \t  else if (is_false_predicate (cond)\n \t\t   && gimple_vdef (stmt))\n@@ -2245,19 +2424,13 @@ predicate_mem_writes (loop_p loop)\n \t  else if (gimple_plf (stmt, GF_PLF_2))\n \t    {\n \t      tree lhs = gimple_assign_lhs (stmt);\n-\t      tree rhs = gimple_assign_rhs1 (stmt);\n-\t      tree ref, addr, ptr, mask;\n-\t      gcall *new_stmt;\n+\t      tree mask;\n+\t      gimple *new_stmt;\n \t      gimple_seq stmts = NULL;\n \t      machine_mode mode = TYPE_MODE (TREE_TYPE (lhs));\n \t      /* We checked before setting GF_PLF_2 that an equivalent\n \t\t integer mode exists.  */\n \t      int bitsize = GET_MODE_BITSIZE (mode).to_constant ();\n-\t      ref = TREE_CODE (lhs) == SSA_NAME ? rhs : lhs;\n-\t      mark_addressable (ref);\n-\t      addr = force_gimple_operand_gsi (&gsi, build_fold_addr_expr (ref),\n-\t\t\t\t\t       true, NULL_TREE, true,\n-\t\t\t\t\t       GSI_SAME_STMT);\n \t      if (!vect_sizes.is_empty ()\n \t\t  && (index = mask_exists (bitsize, vect_sizes)) != -1)\n \t\t/* Use created mask.  */\n@@ -2285,30 +2458,10 @@ predicate_mem_writes (loop_p loop)\n \t\t  vect_sizes.safe_push (bitsize);\n \t\t  vect_masks.safe_push (mask);\n \t\t}\n-\t      ptr = build_int_cst (reference_alias_ptr_type (ref),\n-\t\t\t\t   get_object_alignment (ref));\n-\t      /* Copy points-to info if possible.  */\n-\t      if (TREE_CODE (addr) == SSA_NAME && !SSA_NAME_PTR_INFO (addr))\n-\t\tcopy_ref_info (build2 (MEM_REF, TREE_TYPE (ref), addr, ptr),\n-\t\t\t       ref);\n-\t      if (TREE_CODE (lhs) == SSA_NAME)\n-\t\t{\n-\t\t  new_stmt\n-\t\t    = gimple_build_call_internal (IFN_MASK_LOAD, 3, addr,\n-\t\t\t\t\t\t  ptr, mask);\n-\t\t  gimple_call_set_lhs (new_stmt, lhs);\n-\t\t  gimple_set_vuse (new_stmt, gimple_vuse (stmt));\n-\t\t}\n+\t      if (gimple_assign_single_p (stmt))\n+\t\tnew_stmt = predicate_load_or_store (&gsi, stmt, mask);\n \t      else\n-\t\t{\n-\t\t  new_stmt\n-\t\t    = gimple_build_call_internal (IFN_MASK_STORE, 4, addr, ptr,\n-\t\t\t\t\t\t  mask, rhs);\n-\t\t  gimple_set_vuse (new_stmt, gimple_vuse (stmt));\n-\t\t  gimple_set_vdef (new_stmt, gimple_vdef (stmt));\n-\t\t  SSA_NAME_DEF_STMT (gimple_vdef (new_stmt)) = new_stmt;\n-\t\t}\n-\t      gimple_call_set_nothrow (new_stmt, true);\n+\t\tnew_stmt = predicate_rhs_code (stmt, mask, cond, &ssa_names);\n \n \t      gsi_replace (&gsi, new_stmt, true);\n \t    }\n@@ -2329,8 +2482,12 @@ predicate_mem_writes (loop_p loop)\n \t      gimple_assign_set_rhs1 (stmt, ifc_temp_var (type, rhs, &gsi));\n \t      update_stmt (stmt);\n \t    }\n+\t  tree lhs = gimple_get_lhs (gsi_stmt (gsi));\n+\t  if (lhs && TREE_CODE (lhs) == SSA_NAME)\n+\t    ssa_names.add (lhs);\n \t  gsi_next (&gsi);\n \t}\n+      ssa_names.empty ();\n     }\n }\n \n@@ -2392,8 +2549,8 @@ combine_blocks (struct loop *loop)\n   insert_gimplified_predicates (loop);\n   predicate_all_scalar_phis (loop);\n \n-  if (any_pred_load_store)\n-    predicate_mem_writes (loop);\n+  if (need_to_predicate)\n+    predicate_statements (loop);\n \n   /* Merge basic blocks: first remove all the edges in the loop,\n      except for those from the exit block.  */\n@@ -2733,6 +2890,12 @@ ifcvt_local_dce (basic_block bb)\n   enum gimple_code code;\n   use_operand_p use_p;\n   imm_use_iterator imm_iter;\n+  std::pair <tree, tree> *name_pair;\n+  unsigned int i;\n+\n+  FOR_EACH_VEC_ELT (redundant_ssa_names, i, name_pair)\n+    replace_uses_by (name_pair->first, name_pair->second);\n+  redundant_ssa_names.release ();\n \n   worklist.create (64);\n   /* Consider all phi as live statements.  */\n@@ -2833,7 +2996,7 @@ tree_if_conversion (struct loop *loop)\n  again:\n   rloop = NULL;\n   ifc_bbs = NULL;\n-  any_pred_load_store = false;\n+  need_to_predicate = false;\n   any_complicated_phi = false;\n \n   /* Apply more aggressive if-conversion when loop or its outer loop were\n@@ -2854,7 +3017,7 @@ tree_if_conversion (struct loop *loop)\n       || !dbg_cnt (if_conversion_tree))\n     goto cleanup;\n \n-  if ((any_pred_load_store || any_complicated_phi)\n+  if ((need_to_predicate || any_complicated_phi)\n       && ((!flag_tree_loop_vectorize && !loop->force_vectorize)\n \t  || loop->dont_vectorize))\n     goto cleanup;\n@@ -2864,7 +3027,7 @@ tree_if_conversion (struct loop *loop)\n      Either version this loop, or if the pattern is right for outer-loop\n      vectorization, version the outer loop.  In the latter case we will\n      still if-convert the original inner loop.  */\n-  if (any_pred_load_store\n+  if (need_to_predicate\n       || any_complicated_phi\n       || flag_tree_loop_if_convert != 1)\n     {"}, {"sha": "4c22afd2b5fa1885d9163a6e752e991dec0206f9", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 37, "deletions": 34, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c58d42c3ed599b4c2976fc173eefd8e016ea216/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c58d42c3ed599b4c2976fc173eefd8e016ea216/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=2c58d42c3ed599b4c2976fc173eefd8e016ea216", "patch": "@@ -3905,65 +3905,68 @@ vect_recog_mask_conversion_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n \n   /* Check for MASK_LOAD ans MASK_STORE calls requiring mask conversion.  */\n   if (is_gimple_call (last_stmt)\n-      && gimple_call_internal_p (last_stmt)\n-      && (gimple_call_internal_fn (last_stmt) == IFN_MASK_STORE\n-\t  || gimple_call_internal_fn (last_stmt) == IFN_MASK_LOAD))\n+      && gimple_call_internal_p (last_stmt))\n     {\n       gcall *pattern_stmt;\n-      bool load = (gimple_call_internal_fn (last_stmt) == IFN_MASK_LOAD);\n \n-      if (load)\n+      internal_fn ifn = gimple_call_internal_fn (last_stmt);\n+      int mask_argno = internal_fn_mask_index (ifn);\n+      if (mask_argno < 0)\n+\treturn NULL;\n+\n+      bool store_p = internal_store_fn_p (ifn);\n+      if (store_p)\n \t{\n-\t  lhs = gimple_call_lhs (last_stmt);\n-\t  vectype1 = get_vectype_for_scalar_type (TREE_TYPE (lhs));\n+\t  int rhs_index = internal_fn_stored_value_index (ifn);\n+\t  tree rhs = gimple_call_arg (last_stmt, rhs_index);\n+\t  vectype1 = get_vectype_for_scalar_type (TREE_TYPE (rhs));\n \t}\n       else\n \t{\n-\t  rhs2 = gimple_call_arg (last_stmt, 3);\n-\t  vectype1 = get_vectype_for_scalar_type (TREE_TYPE (rhs2));\n+\t  lhs = gimple_call_lhs (last_stmt);\n+\t  vectype1 = get_vectype_for_scalar_type (TREE_TYPE (lhs));\n \t}\n \n-      rhs1 = gimple_call_arg (last_stmt, 2);\n-      rhs1_type = search_type_for_mask (rhs1, vinfo);\n-      if (!rhs1_type)\n+      tree mask_arg = gimple_call_arg (last_stmt, mask_argno);\n+      tree mask_arg_type = search_type_for_mask (mask_arg, vinfo);\n+      if (!mask_arg_type)\n \treturn NULL;\n-      vectype2 = get_mask_type_for_scalar_type (rhs1_type);\n+      vectype2 = get_mask_type_for_scalar_type (mask_arg_type);\n \n       if (!vectype1 || !vectype2\n \t  || known_eq (TYPE_VECTOR_SUBPARTS (vectype1),\n \t\t       TYPE_VECTOR_SUBPARTS (vectype2)))\n \treturn NULL;\n \n-      tmp = build_mask_conversion (rhs1, vectype1, stmt_vinfo);\n+      tmp = build_mask_conversion (mask_arg, vectype1, stmt_vinfo);\n \n-      if (load)\n+      auto_vec<tree, 8> args;\n+      unsigned int nargs = gimple_call_num_args (last_stmt);\n+      args.safe_grow (nargs);\n+      for (unsigned int i = 0; i < nargs; ++i)\n+\targs[i] = ((int) i == mask_argno\n+\t\t   ? tmp\n+\t\t   : gimple_call_arg (last_stmt, i));\n+      pattern_stmt = gimple_build_call_internal_vec (ifn, args);\n+\n+      if (!store_p)\n \t{\n \t  lhs = vect_recog_temp_ssa_var (TREE_TYPE (lhs), NULL);\n-\t  pattern_stmt\n-\t    = gimple_build_call_internal (IFN_MASK_LOAD, 3,\n-\t\t\t\t\t  gimple_call_arg (last_stmt, 0),\n-\t\t\t\t\t  gimple_call_arg (last_stmt, 1),\n-\t\t\t\t\t  tmp);\n \t  gimple_call_set_lhs (pattern_stmt, lhs);\n \t}\n-      else\n-\t  pattern_stmt\n-\t    = gimple_build_call_internal (IFN_MASK_STORE, 4,\n-\t\t\t\t\t  gimple_call_arg (last_stmt, 0),\n-\t\t\t\t\t  gimple_call_arg (last_stmt, 1),\n-\t\t\t\t\t  tmp,\n-\t\t\t\t\t  gimple_call_arg (last_stmt, 3));\n-\n       gimple_call_set_nothrow (pattern_stmt, true);\n \n       pattern_stmt_info = new_stmt_vec_info (pattern_stmt, vinfo);\n       set_vinfo_for_stmt (pattern_stmt, pattern_stmt_info);\n-      STMT_VINFO_DATA_REF (pattern_stmt_info)\n-\t= STMT_VINFO_DATA_REF (stmt_vinfo);\n-      STMT_VINFO_DR_WRT_VEC_LOOP (pattern_stmt_info)\n-\t= STMT_VINFO_DR_WRT_VEC_LOOP (stmt_vinfo);\n-      STMT_VINFO_GATHER_SCATTER_P (pattern_stmt_info)\n-\t= STMT_VINFO_GATHER_SCATTER_P (stmt_vinfo);\n+      if (STMT_VINFO_DATA_REF (stmt_vinfo))\n+\t{\n+\t  STMT_VINFO_DATA_REF (pattern_stmt_info)\n+\t    = STMT_VINFO_DATA_REF (stmt_vinfo);\n+\t  STMT_VINFO_DR_WRT_VEC_LOOP (pattern_stmt_info)\n+\t    = STMT_VINFO_DR_WRT_VEC_LOOP (stmt_vinfo);\n+\t  STMT_VINFO_GATHER_SCATTER_P (pattern_stmt_info)\n+\t    = STMT_VINFO_GATHER_SCATTER_P (stmt_vinfo);\n+\t}\n \n       *type_out = vectype1;\n       vect_pattern_detected (\"vect_recog_mask_conversion_pattern\", last_stmt);"}, {"sha": "1c847ae016d1de09f5d8719ab689a9c0414ba822", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 70, "deletions": 30, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c58d42c3ed599b4c2976fc173eefd8e016ea216/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c58d42c3ed599b4c2976fc173eefd8e016ea216/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=2c58d42c3ed599b4c2976fc173eefd8e016ea216", "patch": "@@ -3126,12 +3126,14 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n   bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_info);\n   vec_info *vinfo = stmt_info->vinfo;\n   tree fndecl, new_temp, rhs_type;\n-  enum vect_def_type dt[3]\n-    = {vect_unknown_def_type, vect_unknown_def_type, vect_unknown_def_type};\n-  int ndts = 3;\n+  enum vect_def_type dt[4]\n+    = { vect_unknown_def_type, vect_unknown_def_type, vect_unknown_def_type,\n+\tvect_unknown_def_type };\n+  int ndts = ARRAY_SIZE (dt);\n   gimple *new_stmt = NULL;\n   int ncopies, j;\n-  vec<tree> vargs = vNULL;\n+  auto_vec<tree, 8> vargs;\n+  auto_vec<tree, 8> orig_vargs;\n   enum { NARROW, NONE, WIDEN } modifier;\n   size_t i, nargs;\n   tree lhs;\n@@ -3170,22 +3172,38 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n   /* Bail out if the function has more than three arguments, we do not have\n      interesting builtin functions to vectorize with more than two arguments\n      except for fma.  No arguments is also not good.  */\n-  if (nargs == 0 || nargs > 3)\n+  if (nargs == 0 || nargs > 4)\n     return false;\n \n   /* Ignore the argument of IFN_GOMP_SIMD_LANE, it is magic.  */\n-  if (gimple_call_internal_p (stmt)\n-      && gimple_call_internal_fn (stmt) == IFN_GOMP_SIMD_LANE)\n+  combined_fn cfn = gimple_call_combined_fn (stmt);\n+  if (cfn == CFN_GOMP_SIMD_LANE)\n     {\n       nargs = 0;\n       rhs_type = unsigned_type_node;\n     }\n \n+  int mask_opno = -1;\n+  if (internal_fn_p (cfn))\n+    mask_opno = internal_fn_mask_index (as_internal_fn (cfn));\n+\n   for (i = 0; i < nargs; i++)\n     {\n       tree opvectype;\n \n       op = gimple_call_arg (stmt, i);\n+      if (!vect_is_simple_use (op, vinfo, &dt[i], &opvectype))\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"use not simple.\\n\");\n+\t  return false;\n+\t}\n+\n+      /* Skip the mask argument to an internal function.  This operand\n+\t has been converted via a pattern if necessary.  */\n+      if ((int) i == mask_opno)\n+\tcontinue;\n \n       /* We can only handle calls with arguments of the same type.  */\n       if (rhs_type\n@@ -3199,14 +3217,6 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n       if (!rhs_type)\n \trhs_type = TREE_TYPE (op);\n \n-      if (!vect_is_simple_use (op, vinfo, &dt[i], &opvectype))\n-\t{\n-\t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                             \"use not simple.\\n\");\n-\t  return false;\n-\t}\n-\n       if (!vectype_in)\n \tvectype_in = opvectype;\n       else if (opvectype\n@@ -3264,7 +3274,6 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n      to vectorize other operations in the loop.  */\n   fndecl = NULL_TREE;\n   internal_fn ifn = IFN_LAST;\n-  combined_fn cfn = gimple_call_combined_fn (stmt);\n   tree callee = gimple_call_fndecl (stmt);\n \n   /* First try using an internal function.  */\n@@ -3328,6 +3337,7 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n      needs to be generated.  */\n   gcc_assert (ncopies >= 1);\n \n+  vec_loop_masks *masks = &LOOP_VINFO_MASKS (loop_vinfo);\n   if (!vec_stmt) /* transformation not required.  */\n     {\n       STMT_VINFO_TYPE (stmt_info) = call_vec_info_type;\n@@ -3337,6 +3347,13 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \trecord_stmt_cost (cost_vec, ncopies / 2,\n \t\t\t  vec_promote_demote, stmt_info, 0, vect_body);\n \n+      if (loop_vinfo && mask_opno >= 0)\n+\t{\n+\t  unsigned int nvectors = (slp_node\n+\t\t\t\t   ? SLP_TREE_NUMBER_OF_VEC_STMTS (slp_node)\n+\t\t\t\t   : ncopies);\n+\t  vect_record_loop_mask (loop_vinfo, masks, nvectors, vectype_out);\n+\t}\n       return true;\n     }\n \n@@ -3349,25 +3366,24 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n   scalar_dest = gimple_call_lhs (stmt);\n   vec_dest = vect_create_destination_var (scalar_dest, vectype_out);\n \n+  bool masked_loop_p = loop_vinfo && LOOP_VINFO_FULLY_MASKED_P (loop_vinfo);\n+\n   prev_stmt_info = NULL;\n   if (modifier == NONE || ifn != IFN_LAST)\n     {\n       tree prev_res = NULL_TREE;\n+      vargs.safe_grow (nargs);\n+      orig_vargs.safe_grow (nargs);\n       for (j = 0; j < ncopies; ++j)\n \t{\n \t  /* Build argument list for the vectorized call.  */\n-\t  if (j == 0)\n-\t    vargs.create (nargs);\n-\t  else\n-\t    vargs.truncate (0);\n-\n \t  if (slp_node)\n \t    {\n \t      auto_vec<vec<tree> > vec_defs (nargs);\n \t      vec<tree> vec_oprnds0;\n \n \t      for (i = 0; i < nargs; i++)\n-\t\tvargs.quick_push (gimple_call_arg (stmt, i));\n+\t\tvargs[i] = gimple_call_arg (stmt, i);\n \t      vect_get_slp_defs (vargs, slp_node, &vec_defs);\n \t      vec_oprnds0 = vec_defs[0];\n \n@@ -3382,6 +3398,9 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t\t    }\n \t\t  if (modifier == NARROW)\n \t\t    {\n+\t\t      /* We don't define any narrowing conditional functions\n+\t\t\t at present.  */\n+\t\t      gcc_assert (mask_opno < 0);\n \t\t      tree half_res = make_ssa_name (vectype_in);\n \t\t      gcall *call\n \t\t\t= gimple_build_call_internal_vec (ifn, vargs);\n@@ -3400,6 +3419,17 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t\t    }\n \t\t  else\n \t\t    {\n+\t\t      if (mask_opno >= 0 && masked_loop_p)\n+\t\t\t{\n+\t\t\t  unsigned int vec_num = vec_oprnds0.length ();\n+\t\t\t  /* Always true for SLP.  */\n+\t\t\t  gcc_assert (ncopies == 1);\n+\t\t\t  tree mask = vect_get_loop_mask (gsi, masks, vec_num,\n+\t\t\t\t\t\t\t  vectype_out, i);\n+\t\t\t  vargs[mask_opno] = prepare_load_store_mask\n+\t\t\t    (TREE_TYPE (mask), mask, vargs[mask_opno], gsi);\n+\t\t\t}\n+\n \t\t      gcall *call;\n \t\t      if (ifn != IFN_LAST)\n \t\t\tcall = gimple_build_call_internal_vec (ifn, vargs);\n@@ -3429,17 +3459,22 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t\tvec_oprnd0\n \t\t  = vect_get_vec_def_for_operand (op, stmt);\n \t      else\n-\t\t{\n-\t\t  vec_oprnd0 = gimple_call_arg (new_stmt, i);\n-\t\t  vec_oprnd0\n-                    = vect_get_vec_def_for_stmt_copy (dt[i], vec_oprnd0);\n-\t\t}\n+\t\tvec_oprnd0\n+\t\t  = vect_get_vec_def_for_stmt_copy (dt[i], orig_vargs[i]);\n \n-\t      vargs.quick_push (vec_oprnd0);\n+\t      orig_vargs[i] = vargs[i] = vec_oprnd0;\n+\t    }\n+\n+\t  if (mask_opno >= 0 && masked_loop_p)\n+\t    {\n+\t      tree mask = vect_get_loop_mask (gsi, masks, ncopies,\n+\t\t\t\t\t      vectype_out, j);\n+\t      vargs[mask_opno]\n+\t\t= prepare_load_store_mask (TREE_TYPE (mask), mask,\n+\t\t\t\t\t   vargs[mask_opno], gsi);\n \t    }\n \n-\t  if (gimple_call_internal_p (stmt)\n-\t      && gimple_call_internal_fn (stmt) == IFN_GOMP_SIMD_LANE)\n+\t  if (cfn == CFN_GOMP_SIMD_LANE)\n \t    {\n \t      tree cst = build_index_vector (vectype_out, j * nunits_out, 1);\n \t      tree new_var\n@@ -3451,6 +3486,9 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t    }\n \t  else if (modifier == NARROW)\n \t    {\n+\t      /* We don't define any narrowing conditional functions at\n+\t\t present.  */\n+\t      gcc_assert (mask_opno < 0);\n \t      tree half_res = make_ssa_name (vectype_in);\n \t      gcall *call = gimple_build_call_internal_vec (ifn, vargs);\n \t      gimple_call_set_lhs (call, half_res);\n@@ -3490,6 +3528,8 @@ vectorizable_call (gimple *gs, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n     }\n   else if (modifier == NARROW)\n     {\n+      /* We don't define any narrowing conditional functions at present.  */\n+      gcc_assert (mask_opno < 0);\n       for (j = 0; j < ncopies; ++j)\n \t{\n \t  /* Build argument list for the vectorized call.  */"}]}