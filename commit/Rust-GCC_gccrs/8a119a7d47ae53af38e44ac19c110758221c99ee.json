{"sha": "8a119a7d47ae53af38e44ac19c110758221c99ee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGExMTlhN2Q0N2FlNTNhZjM4ZTQ0YWMxOWMxMTA3NTgyMjFjOTllZQ==", "commit": {"author": {"name": "Michael Hayes", "email": "m.hayes@elec.canterbury.ac.nz", "date": "2000-12-16T23:13:15Z"}, "committer": {"name": "Michael Hayes", "email": "m.hayes@gcc.gnu.org", "date": "2000-12-16T23:13:15Z"}, "message": "c4x.h (MD_INIT_BUILTINS, [...]): Define.\n\n\t* config/c4x/c4x.h (MD_INIT_BUILTINS, MD_EXPAND_BUILTIN): Define.\n\n\t* config/c4x/c4x-protos.h (c4x_init_builtins): New prototype.\n\t(c4x_expand_builtin): Likewise.\n\n\t* config/c4x/c4x.c (c4x_init_builtins): New function.\n\t(c4x_expand_builtin): Likewise.\n\n\t* config/c4x/c4x.md (floatunsqihf2): New pattern.\n\t(*floatqihf2_set, *fixhfqi_set, fix_trunchfqi2): Likewise.\n\t(fixuns_trunchfqi2, toieee, frieee, *ldhf_conditional): Likewise.\n\t(*ldhf_conditional_noov, movhfcc, trap, cond_trap_cc): Likewise.\n\t(*toieee_movqf_clobber, *frieee_movqf_clobber): Likewise.\n\nCo-Authored-By: Herman A.J. ten Brugge <Haj.Ten.Brugge@net.HCC.nl>\n\nFrom-SVN: r38315", "tree": {"sha": "16004b13a615ad8983fecd2654b9a2179727012c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/16004b13a615ad8983fecd2654b9a2179727012c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8a119a7d47ae53af38e44ac19c110758221c99ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a119a7d47ae53af38e44ac19c110758221c99ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a119a7d47ae53af38e44ac19c110758221c99ee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a119a7d47ae53af38e44ac19c110758221c99ee/comments", "author": null, "committer": null, "parents": [{"sha": "66f7715434c4a3b03b572f9c1dfbb4a33f130246", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66f7715434c4a3b03b572f9c1dfbb4a33f130246", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66f7715434c4a3b03b572f9c1dfbb4a33f130246"}], "stats": {"total": 520, "additions": 487, "deletions": 33}, "files": [{"sha": "4a729a8ea95e2c2a4c7de2ca98327d82ed2715da", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a119a7d47ae53af38e44ac19c110758221c99ee/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a119a7d47ae53af38e44ac19c110758221c99ee/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8a119a7d47ae53af38e44ac19c110758221c99ee", "patch": "@@ -1,5 +1,22 @@\n 2000-12-17  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n+            Herman A.J. ten Brugge <Haj.Ten.Brugge@net.HCC.nl>\n \n+\t* config/c4x/c4x.h (MD_INIT_BUILTINS, MD_EXPAND_BUILTIN): Define.\n+\n+\t* config/c4x/c4x-protos.h (c4x_init_builtins): New prototype.\n+\t(c4x_expand_builtin): Likewise.\n+\n+\t* config/c4x/c4x.c (c4x_init_builtins): New function.\n+\t(c4x_expand_builtin): Likewise.\n+\n+\t* config/c4x/c4x.md (floatunsqihf2): New pattern.\n+\t(*floatqihf2_set, *fixhfqi_set, fix_trunchfqi2): Likewise.\n+\t(fixuns_trunchfqi2, toieee, frieee, *ldhf_conditional): Likewise.\n+\t(*ldhf_conditional_noov, movhfcc, trap, cond_trap_cc): Likewise.\n+\t(*toieee_movqf_clobber, *frieee_movqf_clobber): Likewise.\n+\n+2000-12-17  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n+\t\n \t* libgcc2.h: Use Wtype for SItype and DWtype for DItype in prototypes.\n \t* libgcc2.c (__absvsi2): Use Wtype and DWtype.\n \t(__absvdi2, __addvsi3, __addvdi3, __subvsi3): Likewise."}, {"sha": "62fae3b809c1bdcd9cdbe10a909ed580e268b489", "filename": "gcc/config/c4x/c4x-protos.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a119a7d47ae53af38e44ac19c110758221c99ee/gcc%2Fconfig%2Fc4x%2Fc4x-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a119a7d47ae53af38e44ac19c110758221c99ee/gcc%2Fconfig%2Fc4x%2Fc4x-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x-protos.h?ref=8a119a7d47ae53af38e44ac19c110758221c99ee", "patch": "@@ -62,6 +62,7 @@ extern struct rtx_def *c4x_function_arg PARAMS ((CUMULATIVE_ARGS *,\n extern void c4x_encode_section_info PARAMS ((tree));\n \n extern int c4x_valid_type_attribute_p PARAMS ((tree, tree, tree, tree));\n+\n #endif /* TREE_CODE */\n \n \n@@ -71,6 +72,9 @@ extern void c4x_init_cumulative_args PARAMS ((CUMULATIVE_ARGS *c, tree, rtx));\n extern void c4x_va_start PARAMS ((int, tree, rtx));\n \n extern struct rtx_def *c4x_va_arg PARAMS ((tree, tree));\n+\n+extern rtx c4x_expand_builtin PARAMS((tree, rtx, rtx,\n+\t\t\t\t      enum machine_mode, int));\n #endif /* TREE_CODE and RTX_CODE*/\n \n \n@@ -271,6 +275,8 @@ extern int valid_parallel_operands_5 PARAMS ((rtx *, enum machine_mode));\n \n extern int valid_parallel_operands_6 PARAMS ((rtx *, enum machine_mode));\n \n+extern void c4x_init_builtins PARAMS((void));\n+\n extern rtx smulhi3_libfunc;\n extern rtx umulhi3_libfunc;\n extern rtx fix_truncqfhi2_libfunc;"}, {"sha": "406ec0e8daabc28ee676646ad64d3c181b83ebbf", "filename": "gcc/config/c4x/c4x.c", "status": "modified", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a119a7d47ae53af38e44ac19c110758221c99ee/gcc%2Fconfig%2Fc4x%2Fc4x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a119a7d47ae53af38e44ac19c110758221c99ee/gcc%2Fconfig%2Fc4x%2Fc4x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.c?ref=8a119a7d47ae53af38e44ac19c110758221c99ee", "patch": "@@ -315,6 +315,7 @@ c4x_output_ascii (stream, ptr, len)\n   char sbuf[C4X_ASCII_LIMIT + 1];\n   int s, l, special, first, onlys;\n \n+  first = 0;\n   if (len)\n     {\n       fprintf (stream, \"\\t.byte\\t\");\n@@ -4855,3 +4856,181 @@ c4x_adjust_cost (insn, link, dep_insn, cost)\n   else\n     abort ();\n }\n+\n+void\n+c4x_init_builtins ()\n+{\n+  tree endlink = tree_cons (NULL_TREE, void_type_node, NULL_TREE);\n+\n+  builtin_function (\"abs\",\n+\t\t    build_function_type\n+\t\t    (integer_type_node, \n+\t\t     tree_cons (NULL_TREE, integer_type_node, endlink)),\n+ \t\t    C4X_BUILTIN_ABS, BUILT_IN_MD, NULL_PTR);\n+  builtin_function (\"fabs\",\n+ \t\t    build_function_type\n+\t\t    (double_type_node, \n+\t\t     tree_cons (NULL_TREE, double_type_node, endlink)),\n+ \t\t    C4X_BUILTIN_FABS, BUILT_IN_MD, NULL_PTR);\n+  builtin_function (\"labs\",\n+\t\t    build_function_type \n+\t\t    (long_integer_type_node, \n+\t\t     tree_cons (NULL_TREE, long_integer_type_node, endlink)),\n+\t\t    C4X_BUILTIN_LABS, BUILT_IN_MD, NULL_PTR);\n+  builtin_function (\"fast_ftoi\",\n+\t\t    build_function_type \n+\t\t    (integer_type_node,\n+\t\t     tree_cons (NULL_TREE, double_type_node, endlink)),\n+\t\t    C4X_BUILTIN_FIX, BUILT_IN_MD, NULL_PTR);\n+  builtin_function (\"ansi_ftoi\",\n+\t\t    build_function_type \n+\t\t    (integer_type_node, \n+\t\t     tree_cons (NULL_TREE, double_type_node, endlink)),\n+\t\t    C4X_BUILTIN_FIX_ANSI, BUILT_IN_MD, NULL_PTR);\n+  if (TARGET_C3X)\n+    builtin_function (\"fast_imult\",\n+\t\t      build_function_type\n+\t\t      (integer_type_node, \n+\t\t       tree_cons (NULL_TREE, integer_type_node,\n+\t\t\t\t  tree_cons (NULL_TREE,\n+\t\t\t\t\t     integer_type_node, endlink))),\n+\t\t      C4X_BUILTIN_MPYI, BUILT_IN_MD, NULL_PTR);\n+  else\n+    {\n+      builtin_function (\"toieee\",\n+\t\t        build_function_type \n+\t\t\t(double_type_node,\n+\t\t\t tree_cons (NULL_TREE, double_type_node, endlink)),\n+\t\t        C4X_BUILTIN_TOIEEE, BUILT_IN_MD, NULL_PTR);\n+      builtin_function (\"frieee\",\n+\t\t        build_function_type\n+\t\t\t(double_type_node, \n+\t\t\t tree_cons (NULL_TREE, double_type_node, endlink)),\n+\t\t        C4X_BUILTIN_FRIEEE, BUILT_IN_MD, NULL_PTR);\n+      builtin_function (\"fast_invf\",\n+\t\t        build_function_type \n+\t\t\t(double_type_node, \n+\t\t\t tree_cons (NULL_TREE, double_type_node, endlink)),\n+\t\t        C4X_BUILTIN_RCPF, BUILT_IN_MD, NULL_PTR);\n+    }\n+}\n+\n+\n+rtx\n+c4x_expand_builtin (exp, target, subtarget, mode, ignore)\n+     tree exp;\n+     rtx target;\n+     rtx subtarget ATTRIBUTE_UNUSED;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n+     int ignore ATTRIBUTE_UNUSED;\n+{\n+  tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n+  unsigned int fcode = DECL_FUNCTION_CODE (fndecl);\n+  tree arglist = TREE_OPERAND (exp, 1);\n+  tree arg0, arg1;\n+  rtx r0, r1;\n+\n+  switch (fcode)\n+    {\n+    case C4X_BUILTIN_ABS:\n+      arg0 = TREE_VALUE (arglist);\n+      r0 = expand_expr (arg0, NULL_RTX, QImode, 0);\n+      r0 = protect_from_queue (r0, 0);\n+      if (! target || ! register_operand (target, QImode))\n+\ttarget = gen_reg_rtx (QImode);\n+      emit_insn (gen_absqi2 (target, r0));\n+      return target;\n+\n+    case C4X_BUILTIN_FABS:\n+      arg0 = TREE_VALUE (arglist);\n+      r0 = expand_expr (arg0, NULL_RTX, QFmode, 0);\n+      r0 = protect_from_queue (r0, 0);\n+      if (! target || ! register_operand (target, QFmode))\n+\ttarget = gen_reg_rtx (QFmode);\n+      emit_insn (gen_absqf2 (target, r0));\n+      return target;\n+\n+    case C4X_BUILTIN_LABS:\n+      arg0 = TREE_VALUE (arglist);\n+      r0 = expand_expr (arg0, NULL_RTX, QImode, 0);\n+      r0 = protect_from_queue (r0, 0);\n+      if (! target || ! register_operand (target, QImode))\n+\ttarget = gen_reg_rtx (QImode);\n+      emit_insn (gen_absqi2 (target, r0));\n+      return target;\n+\n+    case C4X_BUILTIN_FIX:\n+      arg0 = TREE_VALUE (arglist);\n+      r0 = expand_expr (arg0, NULL_RTX, QFmode, 0);\n+      r0 = protect_from_queue (r0, 0);\n+      if (! target || ! register_operand (target, QImode))\n+\ttarget = gen_reg_rtx (QImode);\n+      emit_insn (gen_fixqfqi_clobber (target, r0));\n+      return target;\n+\n+    case C4X_BUILTIN_FIX_ANSI:\n+      arg0 = TREE_VALUE (arglist);\n+      r0 = expand_expr (arg0, NULL_RTX, QFmode, 0);\n+      r0 = protect_from_queue (r0, 0);\n+      if (! target || ! register_operand (target, QImode))\n+\ttarget = gen_reg_rtx (QImode);\n+      emit_insn (gen_fix_truncqfqi2 (target, r0));\n+      return target;\n+\n+    case C4X_BUILTIN_MPYI:\n+      if (! TARGET_C3X)\n+\tbreak;\n+      arg0 = TREE_VALUE (arglist);\n+      arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n+      r0 = expand_expr (arg0, NULL_RTX, QImode, 0);\n+      r1 = expand_expr (arg1, NULL_RTX, QImode, 0);\n+      r0 = protect_from_queue (r0, 0);\n+      r1 = protect_from_queue (r1, 0);\n+      if (! target || ! register_operand (target, QImode))\n+\ttarget = gen_reg_rtx (QImode);\n+      emit_insn (gen_mulqi3_24_clobber (target, r0, r1));\n+      return target;\n+\n+    case C4X_BUILTIN_TOIEEE:\n+      if (TARGET_C3X)\n+\tbreak;\n+      arg0 = TREE_VALUE (arglist);\n+      r0 = expand_expr (arg0, NULL_RTX, QFmode, 0);\n+      r0 = protect_from_queue (r0, 0);\n+      if (! target || ! register_operand (target, QFmode))\n+\ttarget = gen_reg_rtx (QFmode);\n+      emit_insn (gen_toieee (target, r0));\n+      return target;\n+\n+    case C4X_BUILTIN_FRIEEE:\n+      if (TARGET_C3X)\n+\tbreak;\n+      arg0 = TREE_VALUE (arglist);\n+      if (TREE_CODE (arg0) == VAR_DECL || TREE_CODE (arg0) == PARM_DECL)\n+\tput_var_into_stack (arg0);\n+      r0 = expand_expr (arg0, NULL_RTX, QFmode, 0);\n+      r0 = protect_from_queue (r0, 0);\n+      if (register_operand (r0, QFmode))\n+\t{\n+\t  r1 = assign_stack_local (QFmode, GET_MODE_SIZE (QFmode), 0);\n+\t  emit_move_insn (r1, r0);\n+\t  r0 = r1;\n+\t}\n+      if (! target || ! register_operand (target, QFmode))\n+\ttarget = gen_reg_rtx (QFmode);\n+      emit_insn (gen_frieee (target, r0));\n+      return target;\n+\n+    case C4X_BUILTIN_RCPF:\n+      if (TARGET_C3X)\n+\tbreak;\n+      arg0 = TREE_VALUE (arglist);\n+      r0 = expand_expr (arg0, NULL_RTX, QFmode, 0);\n+      r0 = protect_from_queue (r0, 0);\n+      if (! target || ! register_operand (target, QFmode))\n+\ttarget = gen_reg_rtx (QFmode);\n+      emit_insn (gen_rcpfqf_clobber (target, r0));\n+      return target;\n+    }\n+  return NULL_RTX;\n+}"}, {"sha": "0ccc26eb45eb6a3d2ef46f6d04e9c22651dd8f2c", "filename": "gcc/config/c4x/c4x.h", "status": "modified", "additions": 42, "deletions": 15, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a119a7d47ae53af38e44ac19c110758221c99ee/gcc%2Fconfig%2Fc4x%2Fc4x.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a119a7d47ae53af38e44ac19c110758221c99ee/gcc%2Fconfig%2Fc4x%2Fc4x.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.h?ref=8a119a7d47ae53af38e44ac19c110758221c99ee", "patch": "@@ -2609,7 +2609,7 @@ do { fprintf (asm_out_file, \"\\t.sdef\\t\");\t\t\\\n /* MOVE_RATIO is the number of move instructions that is better than a\n    block move.  */\n \n-#define MOVE_RATIO 2\t\t/* Default value.  */\n+#define MOVE_RATIO 3\n \n #define BSS_SECTION_ASM_OP \"\\t.bss\"\n \n@@ -2638,20 +2638,23 @@ do { fprintf (asm_out_file, \"\\t.sdef\\t\");\t\t\\\n \n #define MACHINE_DEPENDENT_REORG(INSNS) c4x_process_after_reload(INSNS)\n \n-#define DBR_OUTPUT_SEQEND(FILE)\t\t\\\n-if (final_sequence != NULL_RTX)\t\t\\\n-{\t\t\t\t\t\\\n- int count;\t\t\t\t\\\n- int laj = GET_CODE (XVECEXP (final_sequence, 0, 0)) == CALL_INSN; \\\n-\t\t\t\t\t\\\n- count = dbr_sequence_length();\t\t\\\n- while (count < (laj ? 2 : 3))\t\t\\\n- {\t\t\t\t\t\\\n-    fputs(\"\\tnop\\n\", FILE);\t\t\\\n-    count++;\t\t\t\t\\\n- }\t\t\t\t\t\\\n- if (laj)\t\t\t\t\\\n-    fputs(\"\\tpush\\tr11\\n\", FILE);\t\\\n+#define DBR_OUTPUT_SEQEND(FILE)\t\t\t\t\\\n+if (final_sequence != NULL_RTX)\t\t\t\t\\\n+{\t\t\t\t\t\t\t\\\n+ int count;\t\t\t\t\t\t\\\n+ rtx insn = XVECEXP (final_sequence, 0, 0); \t\t\\\n+ int laj = GET_CODE (insn) == CALL_INSN \t\t\\\n+\t   || (GET_CODE (insn) == INSN\t\t\t\\\n+\t       && GET_CODE (PATTERN (insn)) == TRAP_IF);\\\n+\t\t\t\t\t\t\t\\\n+ count = dbr_sequence_length();\t\t\t\t\\\n+ while (count < (laj ? 2 : 3))\t\t\t\t\\\n+ {\t\t\t\t\t\t\t\\\n+    fputs(\"\\tnop\\n\", FILE);\t\t\t\t\\\n+    count++;\t\t\t\t\t\t\\\n+ }\t\t\t\t\t\t\t\\\n+ if (laj)\t\t\t\t\t\t\\\n+    fputs(\"\\tpush\\tr11\\n\", FILE);\t\t\t\\\n }\n \n #define NO_FUNCTION_CSE\n@@ -2692,3 +2695,27 @@ if (final_sequence != NULL_RTX)\t\t\\\n   {\"parallel_operand\", {SUBREG, REG, MEM}},\t\t\t\\\n   {\"symbolic_address_operand\", {SYMBOL_REF, LABEL_REF, CONST}},\t\\\n   {\"mem_operand\", {MEM}},\t\t\t\t\t\n+\n+\n+/* Define the intrinsic functions for the c3x/c4x.  */\n+\n+enum c4x_builtins\n+{\n+\t\t\t/*\tintrinsic name\t\t*/\n+  C4X_BUILTIN_ABS,\t/*\tabs\t\t\t*/\n+  C4X_BUILTIN_FABS,\t/*\tfabs\t\t\t*/\n+  C4X_BUILTIN_LABS,\t/*\tlabs\t\t\t*/\n+  C4X_BUILTIN_FIX,\t/*\tfast_ftoi\t\t*/\n+  C4X_BUILTIN_FIX_ANSI,\t/*\tansi_ftoi\t\t*/\n+  C4X_BUILTIN_MPYI,\t/*\tfast_imult (only C3x)\t*/\n+  C4X_BUILTIN_TOIEEE,\t/*\ttoieee\t   (only C4x)\t*/\n+  C4X_BUILTIN_FRIEEE,\t/*\tfrieee\t   (only C4x)\t*/\n+  C4X_BUILTIN_RCPF\t/*\tfast_invf  (only C4x)\t*/\n+};\n+\n+#define MD_INIT_BUILTINS do { \\\n+    c4x_init_builtins (); \\\n+  } while (0)\n+\n+#define MD_EXPAND_BUILTIN(EXP, TARGET, SUBTARGET, MODE, IGNORE) \\\n+    c4x_expand_builtin ((EXP), (TARGET), (SUBTARGET), (MODE), (IGNORE))"}, {"sha": "022c92cd7b7d73218dfad512bb5f414b81870c54", "filename": "gcc/config/c4x/c4x.md", "status": "modified", "additions": 243, "deletions": 18, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a119a7d47ae53af38e44ac19c110758221c99ee/gcc%2Fconfig%2Fc4x%2Fc4x.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a119a7d47ae53af38e44ac19c110758221c99ee/gcc%2Fconfig%2Fc4x%2Fc4x.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.md?ref=8a119a7d47ae53af38e44ac19c110758221c99ee", "patch": "@@ -33,10 +33,10 @@\n \n ; Additional C30/C40 instructions not coded:\n ; CALLcond, IACK, IDLE, LDE, LDFI, LDII, LDM, NORM, RETIcond\n-; ROLC, RORC, SIGI, STFI, STII, SUBC, SWI, TRAPcond\n+; ROLC, RORC, SIGI, STFI, STII, SUBC, SWI\n \n ; Additional C40 instructions not coded:\n-; LDEP, LDPE, LWRct, FRIEEE, TOIEEE, LAJcond, LATcond, RETIcondD\n+; LDEP, LDPE, LWRct, LAJcond, RETIcondD\n \n ;\n ; C4x MODES\n@@ -376,9 +376,11 @@\n \t\t(const_string \"true\")\n \t\t(const_string \"false\")))\n \n+/* Disable ldp because the c4x contains a bug. The ldp insn modifies\n+   the dp register when the insn is anulled or not.  */\n (define_attr \"in_annul_slot_3\" \"false,true\"\n   (if_then_else (and (eq_attr \"cpu\" \"c4x\")\n-\t\t     (eq_attr \"type\" \"!jump,call,rets,jmpc,db,dbc,repeat,repeat_top,laj,push,pop,multi\"))\n+\t\t     (eq_attr \"type\" \"!jump,call,rets,jmpc,db,dbc,repeat,repeat_top,laj,push,pop,ldp,multi\"))\n \t\t(const_string \"true\")\n \t\t(const_string \"false\")))\n \n@@ -463,6 +465,8 @@\n ; 19 popqf_unspec\n ; 20 andn_st\n ; 22 rptb_init\n+; 23 toieee\n+; 24 frieee\n \n ;\n ; C4x FUNCTIONAL UNITS\n@@ -950,7 +954,7 @@\n   [(set_attr \"type\" \"unary\")])\n \n (define_insn \"set_lo_sum\"\n-  [(set (match_operand:QI 0 \"std_reg_operand\" \"=c\")\n+  [(set (match_operand:QI 0 \"std_reg_operand\" \"+c\")\n         (lo_sum:QI (match_dup 0)\n                    (match_operand:QI 1 \"symbolic_address_operand\" \"\")))]\n   \"! TARGET_TI\"\n@@ -2168,7 +2172,7 @@\n \n ; The C3x multiply instruction assumes 24-bit signed integer operands\n ; and the 48-bit result is truncated to 32-bits.\n-(define_insn \"*mulqi3_24_clobber\"\n+(define_insn \"mulqi3_24_clobber\"\n   [(set (match_operand:QI 0 \"reg_operand\" \"=d,d,?d,c,c,?c\")\n         (mult:QI\n          (sign_extend:QI\n@@ -3344,7 +3348,7 @@\n  \")\n \n (define_insn \"*insv_clobber\"\n-  [(set (zero_extract:QI (match_operand:QI 0 \"reg_operand\" \"=d,c\")\n+  [(set (zero_extract:QI (match_operand:QI 0 \"reg_operand\" \"+d,c\")\n                          (match_operand:QI 1 \"const_int_operand\" \"n,n\")\n                          (match_operand:QI 2 \"const_int_operand\" \"n,n\"))\n         (match_operand:QI 3 \"src_operand\" \"rLm,rLm\"))\n@@ -3373,7 +3377,7 @@\n    (set_attr \"data\" \"uint16,uint16\")])\n \n (define_peephole\n-  [(parallel [(set (zero_extract:QI (match_operand:QI 0 \"ext_reg_operand\" \"=d\")\n+  [(parallel [(set (zero_extract:QI (match_operand:QI 0 \"ext_reg_operand\" \"+d\")\n                                     (match_operand:QI 1 \"const_int_operand\" \"n\")\n                                     (match_operand:QI 2 \"const_int_operand\" \"n\"))\n                    (match_operand:QI 3 \"src_operand\" \"rLm\"))\n@@ -3712,6 +3716,29 @@\n   emit_move_insn (operands[5], \n    immed_real_const_1 (REAL_VALUE_ATOF (\\\"4294967296.0\\\", QFmode), QFmode));\")\n \n+(define_expand \"floatunsqihf2\"\n+ [(set (match_dup 2) (match_dup 3))\n+  (parallel [(set (reg:CC 21)\n+                  (compare:CC (float:HF (match_operand:QI 1 \"src_operand\" \"\"))\n+                              (match_dup 3)))\n+             (set (match_dup 4)\n+                  (float:HF (match_dup 1)))])\n+  (set (match_dup 6)\n+       (if_then_else:HF (lt (reg:CC 21) (const_int 0))\n+                        (match_dup 5)\n+                        (match_dup 2)))\n+  (parallel [(set (match_operand:HF 0 \"reg_operand\" \"\")\n+                  (plus:HF (match_dup 6) (match_dup 4)))\n+             (clobber (reg:CC_NOOV 21))])]\n+ \"\"\n+ \"operands[2] = gen_reg_rtx (HFmode);\n+  operands[3] = CONST0_RTX (HFmode); \n+  operands[4] = gen_reg_rtx (HFmode);\n+  operands[5] = gen_reg_rtx (HFmode);\n+  operands[6] = gen_reg_rtx (HFmode);\n+  emit_move_insn (operands[5], \n+   immed_real_const_1 (REAL_VALUE_ATOF (\\\"4294967296.0\\\", HFmode), HFmode));\")\n+\n (define_insn \"floatqihf2\"\n   [(set (match_operand:HF 0 \"reg_operand\" \"=h\")\n         (float:HF (match_operand:QI 1 \"src_operand\" \"rIm\")))\n@@ -3720,6 +3747,16 @@\n  \"float\\\\t%1,%0\"\n   [(set_attr \"type\" \"unarycc\")])\n \n+(define_insn \"*floatqihf2_set\"\n+  [(set (reg:CC 21)\n+\t(compare:CC (float:HF (match_operand:QI 1 \"src_operand\" \"rIm\"))\n+                    (match_operand:QF 2 \"fp_zero_operand\" \"G\")))\n+   (set (match_operand:HF 0 \"reg_operand\" \"=h\")\n+        (float:HF (match_dup 1)))]\n+ \"\"\n+ \"float\\\\t%1,%0\"\n+  [(set_attr \"type\" \"unarycc\")])\n+\n ;\n ; FIX\n ;\n@@ -3741,6 +3778,16 @@\n  \"fix\\\\t%1,%0\"\n   [(set_attr \"type\" \"unarycc\")])\n \n+(define_insn \"*fixhfqi_set\"\n+  [(set (reg:CC 21)\n+        (compare:CC (fix:QI (match_operand:HF 1 \"src_operand\" \"fH\"))\n+                    (const_int 0)))\n+   (set (match_operand:QI 0 \"ext_reg_operand\" \"=d\")\n+        (fix:QI (match_dup 1)))]\n+ \"\"\n+ \"fix\\\\t%1,%0\"\n+  [(set_attr \"type\" \"unarycc\")])\n+\n ;\n ; The C[34]x fix instruction implements a floor, not a straight trunc,\n ; so we have to invert the number, fix it, and reinvert it if negative\n@@ -3773,6 +3820,34 @@\n   operands[5] = gen_reg_rtx (QImode);\n  \")\n \n+(define_expand \"fix_trunchfqi2\"\n+  [(parallel [(set (match_dup 2)\n+                   (fix:QI (match_operand:HF 1 \"src_operand\" \"\")))\n+              (clobber (reg:CC 21))])\n+   (parallel [(set (match_dup 3) (neg:HF (match_dup 1)))\n+              (clobber (reg:CC_NOOV 21))])\n+   (parallel [(set (match_dup 4) (fix:QI (match_dup 3)))\n+              (clobber (reg:CC 21))])\n+   (parallel [(set (reg:CC_NOOV 21)\n+                   (compare:CC_NOOV (neg:QI (match_dup 4)) (const_int 0)))\n+              (set (match_dup 5) (neg:QI (match_dup 4)))])\n+   (set (match_dup 2)\n+        (if_then_else:QI (le (reg:CC 21) (const_int 0))\n+                         (match_dup 5)\n+                         (match_dup 2)))\n+   (set (match_operand:QI 0 \"reg_operand\" \"=r\") (match_dup 2))]\n+ \"\"\n+ \"if (TARGET_FAST_FIX)\n+    {\n+       emit_insn (gen_fixhfqi_clobber (operands[0], operands[1]));\n+       DONE;\n+    }\n+  operands[2] = gen_reg_rtx (QImode);\n+  operands[3] = gen_reg_rtx (HFmode);\n+  operands[4] = gen_reg_rtx (QImode);\n+  operands[5] = gen_reg_rtx (QImode);\n+ \")\n+\n (define_expand \"fix_truncqfhi2\"\n   [(parallel [(set (match_operand:HI 0 \"reg_operand\" \"\")\n                    (fix:HI (match_operand:QF 1 \"src_operand\" \"\")))\n@@ -3804,6 +3879,29 @@\n   emit_move_insn (operands[5],\n    immed_real_const_1 (REAL_VALUE_ATOF (\\\"4294967296.0\\\", QFmode), QFmode));\")\n \n+(define_expand \"fixuns_trunchfqi2\"\n+ [(parallel [(set (match_dup 2)\n+\t\t  (fix:QI (match_operand:HF 1 \"src_operand\" \"hH\")))\n+\t     (clobber (reg:CC 21))])\n+  (parallel [(set (match_dup 3)\n+\t          (minus:HF (match_dup 1) (match_dup 5)))\n+\t     (clobber (reg:CC_NOOV 21))])\n+  (parallel [(set (reg:CC 21)\n+\t\t  (compare:CC (fix:QI (match_dup 3))\n+\t\t              (const_int 0)))\n+\t     (set (match_dup 4)\n+\t\t  (fix:QI (match_dup 3)))])\n+  (parallel [(set (match_dup 4) (unspec:QI [(match_dup 2)] 13))\n+             (use (reg:CC 21))])\n+  (set (match_operand:QI 0 \"reg_operand\" \"=r\") (match_dup 4))]\n+ \"\"\n+ \"operands[2] = gen_reg_rtx (QImode);\n+  operands[3] = gen_reg_rtx (HFmode);\n+  operands[4] = gen_reg_rtx (QImode);\n+  operands[5] = gen_reg_rtx (HFmode);\n+  emit_move_insn (operands[5],\n+   immed_real_const_1 (REAL_VALUE_ATOF (\\\"4294967296.0\\\", HFmode), HFmode));\")\n+\n (define_expand \"fixuns_truncqfhi2\"\n   [(parallel [(set (match_operand:HI 0 \"reg_operand\" \"\")\n                    (unsigned_fix:HI (match_operand:QF 1 \"src_operand\" \"\")))\n@@ -3816,7 +3914,7 @@\n ;\n ; RCPF\n ;\n-(define_insn \"*rcpfqf_clobber\"\n+(define_insn \"rcpfqf_clobber\"\n   [(set (match_operand:QF 0 \"reg_operand\" \"=f\")\n         (unspec:QF [(match_operand:QF 1 \"src_operand\" \"fHm\")] 5))\n    (clobber (reg:CC_NOOV 21))]\n@@ -3895,6 +3993,23 @@\n   \"emit_insn (gen_sqrtqf2_inline (operands[0], operands[1]));\n    DONE;\")\n \n+;\n+; TOIEEE / FRIEEE\n+;\n+(define_insn \"toieee\"\n+  [(set (match_operand:QF 0 \"reg_operand\" \"=f\")\n+        (unspec:QF [(match_operand:QF 1 \"src_operand\" \"fHm\")] 23))\n+   (clobber (reg:CC 21))]\n+ \"\"\n+ \"toieee\\\\t%1,%0\")\n+\n+(define_insn \"frieee\"\n+  [(set (match_operand:QF 0 \"reg_operand\" \"=f\")\n+        (unspec:QF [(match_operand:QF 1 \"memory_operand\" \"m\")] 24))\n+   (clobber (reg:CC 21))]\n+ \"\"\n+ \"frieee\\\\t%1,%0\")\n+\n ;\n ; THREE OPERAND FLOAT INSTRUCTIONS\n ;\n@@ -4239,6 +4354,49 @@\n                                           operands[2], operands[3])));\n     DONE;}\")\n \n+(define_insn \"*ldhf_conditional\"\n+  [(set (match_operand:HF 0 \"reg_operand\" \"=h,h\")\n+        (if_then_else:HF (match_operator 1 \"comparison_operator\"\n+                          [(reg:CC 21) (const_int 0)])\n+                         (match_operand:HF 2 \"src_operand\" \"hH,0\")\n+                         (match_operand:HF 3 \"src_operand\" \"0,hH\")))]\n+ \"\"\n+ \"@\n+  ldf%1\\\\t%2,%0\n+  ldf%I1\\\\t%3,%0\"\n+ [(set_attr \"type\" \"binary\")])\n+\n+(define_insn \"*ldhf_conditional_noov\"\n+  [(set (match_operand:HF 0 \"reg_operand\" \"=h,h\")\n+        (if_then_else:HF (match_operator 1 \"comparison_operator\"\n+                          [(reg:CC_NOOV 21) (const_int 0)])\n+                         (match_operand:HF 2 \"src_operand\" \"hH,0\")\n+                         (match_operand:HF 3 \"src_operand\" \"0,hH\")))]\n+ \"GET_CODE (operands[1]) != LE\n+  && GET_CODE (operands[1]) != GE\n+  && GET_CODE (operands[1]) != LT\n+  && GET_CODE (operands[1]) != GT\"\n+ \"@\n+  ldf%1\\\\t%2,%0\n+  ldf%I1\\\\t%3,%0\"\n+ [(set_attr \"type\" \"binary\")])\n+\n+(define_expand \"movhfcc\"\n+  [(set (match_operand:HF 0 \"reg_operand\" \"\")\n+        (if_then_else:HF (match_operand 1 \"comparison_operator\" \"\")\n+                         (match_operand:HF 2 \"src_operand\" \"\")\n+                         (match_operand:HF 3 \"src_operand\" \"\")))]\n+ \"\"\n+ \"{ \n+    enum rtx_code code = GET_CODE (operands[1]);\n+    rtx ccreg = c4x_gen_compare_reg (code, c4x_compare_op0, c4x_compare_op1);\n+    if (ccreg == NULL_RTX) FAIL;\n+    emit_insn (gen_rtx_SET (HFmode, operands[0],\n+                            gen_rtx_IF_THEN_ELSE (HFmode,\n+                                 gen_rtx (code, VOIDmode, ccreg, const0_rtx),\n+                                          operands[2], operands[3])));\n+    DONE;}\")\n+\n (define_expand \"seq\"\n  [(set (match_operand:QI 0 \"reg_operand\" \"\")\n        (const_int 0))\n@@ -4537,6 +4695,34 @@\n   \"subf3\\\\t%2,%1,%0\\\\n||\\\\tstf\\\\t%4,%3\"\n   [(set_attr \"type\" \"binarycc\")])\n \n+;\n+; TOIEEE/STF\n+;\n+\n+(define_insn \"*toieee_movqf_clobber\"\n+  [(set (match_operand:QF 0 \"ext_low_reg_operand\" \"=q\")\n+\t(unspec:QF [(match_operand:QF 1 \"par_ind_operand\" \"S<>\")] 23))\n+   (set (match_operand:QF 2 \"par_ind_operand\" \"=S<>\")\n+        (match_operand:QF 3 \"ext_low_reg_operand\" \"q\"))\n+   (clobber (reg:CC 21))]\n+  \"TARGET_PARALLEL && valid_parallel_operands_4 (operands, QFmode)\"\n+  \"toieee\\\\t%1,%0\\\\n||\\\\tstf\\\\t%3,%2\"\n+  [(set_attr \"type\" \"binarycc\")])\n+\n+;\n+; FRIEEE/STF\n+;\n+\n+(define_insn \"*frieee_movqf_clobber\"\n+  [(set (match_operand:QF 0 \"ext_low_reg_operand\" \"=q\")\n+\t(unspec:QF [(match_operand:QF 1 \"par_ind_operand\" \"S<>\")] 24))\n+   (set (match_operand:QF 2 \"par_ind_operand\" \"=S<>\")\n+        (match_operand:QF 3 \"ext_low_reg_operand\" \"q\"))\n+   (clobber (reg:CC 21))]\n+  \"TARGET_PARALLEL && valid_parallel_operands_4 (operands, QFmode)\"\n+  \"frieee\\\\t%1,%0\\\\n||\\\\tstf\\\\t%3,%2\"\n+  [(set_attr \"type\" \"binarycc\")])\n+\n ;\n ; PARALLEL INTEGER INSTRUCTIONS\n ;\n@@ -5090,6 +5276,45 @@\n   \"br%#\\\\t%l0\"\n   [(set_attr \"type\" \"jump\")])\n \n+(define_insn \"trap\"\n+  [(trap_if (const_int 1) (const_int 31))]\n+  \"\"\n+  \"trapu\\\\t31\"\n+  [(set_attr \"type\" \"call\")])\n+\n+(define_expand \"conditional_trap\"\n+ [(trap_if (match_operand 0 \"comparison_operator\" \"\")\n+\t   (match_operand 1 \"const_int_operand\" \"\"))]\n+ \"\"\n+ \"{\n+    enum rtx_code code = GET_CODE (operands[1]);\n+    rtx ccreg = c4x_gen_compare_reg (code, c4x_compare_op0, c4x_compare_op1);\n+    if (ccreg == NULL_RTX) FAIL;\n+    if (GET_MODE (ccreg) == CCmode)\n+      emit_insn (gen_cond_trap_cc (operands[0], operands[1]));\n+    else \n+      emit_insn (gen_cond_trap_cc_noov (operands[0], operands[1]));\n+    DONE;}\")\n+\n+(define_insn \"cond_trap_cc\"\n+  [(trap_if (match_operator 0 \"comparison_operator\"\n+            [(reg:CC 21) (const_int 0)])\n+\t    (match_operand 1 \"const_int_operand\" \"\"))]\n+  \"\"\n+  \"trap%0\\\\t31\"\n+  [(set_attr \"type\" \"call\")])\n+\n+(define_insn \"cond_trap_cc_noov\"\n+  [(trap_if (match_operator 0 \"comparison_operator\"\n+            [(reg:CC_NOOV 21) (const_int 0)])\n+\t    (match_operand 1 \"const_int_operand\" \"\"))]\n+  \"GET_CODE (operands[0]) != LE\n+   && GET_CODE (operands[0]) != GE\n+   && GET_CODE (operands[0]) != LT\n+   && GET_CODE (operands[0]) != GT\"\n+  \"trap%0\\\\t31\"\n+  [(set_attr \"type\" \"call\")])\n+\n ;\n ; DBcond\n ;\n@@ -5710,7 +5935,7 @@\n   [(set_attr \"type\" \"unary\")])\n \n (define_insn \"*loadhf_int\"\n- [(set (match_operand:HF 0 \"reg_operand\" \"=h\")\n+ [(set (match_operand:HF 0 \"reg_operand\" \"+h\")\n        (unspec:HF [(subreg:QI (match_dup 0) 0)\n                    (match_operand:QI 1 \"src_operand\" \"rIm\")] 8))]\n  \"\"\n@@ -5806,7 +6031,7 @@\n  \"\")\n \n (define_insn \"*pophf_int\"\n- [(set (match_operand:HF 0 \"reg_operand\" \"=h\")\n+ [(set (match_operand:HF 0 \"reg_operand\" \"+h\")\n        (unspec:HF [(subreg:QI (match_dup 0) 0)\n                    (mem:QI (post_dec:QI (reg:QI 20)))] 8))\n   (clobber (reg:CC 21))]\n@@ -5879,31 +6104,31 @@\n (define_expand \"neghf2\"\n   [(parallel [(set (match_operand:HF 0 \"reg_operand\" \"\")\n                    (neg:HF (match_operand:HF 1 \"reg_or_const_operand\" \"\")))\n-              (clobber (reg:CC 21))])]\n+              (clobber (reg:CC_NOOV 21))])]\n \"\"\n \"\")\n \n (define_insn \"*neghf2_clobber\"\n   [(set (match_operand:HF 0 \"reg_operand\" \"=h\")\n         (neg:HF (match_operand:HF 1 \"reg_or_const_operand\" \"hH\")))\n-   (clobber (reg:CC 21))]\n+   (clobber (reg:CC_NOOV 21))]\n   \"\"\n   \"negf\\\\t%1,%0\"\n   [(set_attr \"type\" \"unarycc\")])\n \n (define_insn \"*neghf2_test\"\n-  [(set (reg:CC 21)\n-        (compare:CC (neg:HF (match_operand:HF 1 \"reg_or_const_operand\" \"hH\"))\n-                    (match_operand:HF 2 \"fp_zero_operand\" \"G\")))\n+  [(set (reg:CC_NOOV 21)\n+        (compare:CC_NOOV (neg:HF (match_operand:HF 1 \"reg_or_const_operand\" \"hH\"))\n+                         (match_operand:HF 2 \"fp_zero_operand\" \"G\")))\n    (clobber (match_scratch:HF 0 \"=h\"))]\n   \"\"\n   \"negf\\\\t%1,%0\"\n   [(set_attr \"type\" \"unarycc\")])\n \n (define_insn \"*neghf2_set\"\n-  [(set (reg:CC 21)\n-        (compare:CC (neg:HF (match_operand:HF 1 \"reg_or_const_operand\" \"hH\"))\n-                    (match_operand:HF 2 \"fp_zero_operand\" \"G\")))\n+  [(set (reg:CC_NOOV 21)\n+        (compare:CC_NOOV (neg:HF (match_operand:HF 1 \"reg_or_const_operand\" \"hH\"))\n+                         (match_operand:HF 2 \"fp_zero_operand\" \"G\")))\n    (set (match_operand:HF 0 \"reg_operand\" \"=h\")\n         (neg:HF (match_dup 1)))]\n   \"\""}]}