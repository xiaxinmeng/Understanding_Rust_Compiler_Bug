{"sha": "52c29905259363ce2b78dd7aa8a25cf531cddb3a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTJjMjk5MDUyNTkzNjNjZTJiNzhkZDdhYThhMjVjZjUzMWNkZGIzYQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-11-16T11:41:16Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-11-16T11:41:16Z"}, "message": "Record whether a dr_with_seg_len contains mixed steps\n\nprune_runtime_alias_test_list can merge dr_with_seg_len_pair_ts that\nhave different steps for the first reference or different steps for the\nsecond reference.  This patch adds a flag to record that.\n\nI don't know whether the change to create_intersect_range_checks_index\nfixes anything in practice.  It would have to be a corner case if so,\nsince at present we only merge two alias pairs if either the first or\nthe second references are identical and only the other references differ.\nAnd the vectoriser uses VF-based segment lengths only if both references\nin a pair have the same step.  Either way, it still seems wrong to use\nDR_STEP when it doesn't represent all checks that have been merged into\nthe pair.\n\n2019-11-16  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* tree-data-ref.h (DR_ALIAS_MIXED_STEPS): New flag.\n\t* tree-data-ref.c (prune_runtime_alias_test_list): Set it when\n\tmerging data references with different steps.\n\t(create_intersect_range_checks_index): Take a\n\tdr_with_seg_len_pair_t instead of two dr_with_seg_lens.\n\tBail out if DR_ALIAS_MIXED_STEPS is set.\n\t(create_intersect_range_checks): Take a dr_with_seg_len_pair_t\n\tinstead of two dr_with_seg_lens.  Update call to\n\tcreate_intersect_range_checks_index.\n\t(create_runtime_alias_checks): Update call accordingly.\n\nFrom-SVN: r278351", "tree": {"sha": "8bf16421dbe2ab49c76b7329d45d58f6e510114f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8bf16421dbe2ab49c76b7329d45d58f6e510114f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/52c29905259363ce2b78dd7aa8a25cf531cddb3a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52c29905259363ce2b78dd7aa8a25cf531cddb3a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52c29905259363ce2b78dd7aa8a25cf531cddb3a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52c29905259363ce2b78dd7aa8a25cf531cddb3a/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e9acf80c96d681917d930869b7cbfb7d2fa54d51", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9acf80c96d681917d930869b7cbfb7d2fa54d51", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9acf80c96d681917d930869b7cbfb7d2fa54d51"}], "stats": {"total": 77, "additions": 55, "deletions": 22}, "files": [{"sha": "95f6363e8bf8accd29627b34bbacd0c97c585355", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52c29905259363ce2b78dd7aa8a25cf531cddb3a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52c29905259363ce2b78dd7aa8a25cf531cddb3a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=52c29905259363ce2b78dd7aa8a25cf531cddb3a", "patch": "@@ -1,3 +1,16 @@\n+2019-11-16  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* tree-data-ref.h (DR_ALIAS_MIXED_STEPS): New flag.\n+\t* tree-data-ref.c (prune_runtime_alias_test_list): Set it when\n+\tmerging data references with different steps.\n+\t(create_intersect_range_checks_index): Take a\n+\tdr_with_seg_len_pair_t instead of two dr_with_seg_lens.\n+\tBail out if DR_ALIAS_MIXED_STEPS is set.\n+\t(create_intersect_range_checks): Take a dr_with_seg_len_pair_t\n+\tinstead of two dr_with_seg_lens.  Update call to\n+\tcreate_intersect_range_checks_index.\n+\t(create_runtime_alias_checks): Update call accordingly.\n+\n 2019-11-16  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* tree-data-ref.h (DR_ALIAS_RAW, DR_ALIAS_WAR, DR_ALIAS_WAW)"}, {"sha": "bc5d2130ae168b2a86a39fe85d7669a2a9d5862d", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 35, "deletions": 22, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52c29905259363ce2b78dd7aa8a25cf531cddb3a/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52c29905259363ce2b78dd7aa8a25cf531cddb3a/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=52c29905259363ce2b78dd7aa8a25cf531cddb3a", "patch": "@@ -1617,6 +1617,11 @@ prune_runtime_alias_test_list (vec<dr_with_seg_len_pair_t> *alias_pairs,\n \t      std::swap (init_a1, init_a2);\n \t    }\n \n+\t  /* The DR_Bs are equal, so only the DR_As can introduce\n+\t     mixed steps.  */\n+\t  if (!operand_equal_p (DR_STEP (dr_a1->dr), DR_STEP (dr_a2->dr), 0))\n+\t    alias_pair1->flags |= DR_ALIAS_MIXED_STEPS;\n+\n \t  if (new_seg_len_p)\n \t    {\n \t      dr_a1->seg_len = build_int_cst (TREE_TYPE (dr_a1->seg_len),\n@@ -1662,11 +1667,14 @@ prune_runtime_alias_test_list (vec<dr_with_seg_len_pair_t> *alias_pairs,\n     }\n }\n \n-/* Given LOOP's two data references and segment lengths described by DR_A\n-   and DR_B, create expression checking if the two addresses ranges intersect\n-   with each other based on index of the two addresses.  This can only be\n-   done if DR_A and DR_B referring to the same (array) object and the index\n-   is the only difference.  For example:\n+/* Try to generate a runtime condition that is true if ALIAS_PAIR is\n+   free of aliases, using a condition based on index values instead\n+   of a condition based on addresses.  Return true on success,\n+   storing the condition in *COND_EXPR.\n+\n+   This can only be done if the two data references in ALIAS_PAIR access\n+   the same array object and the index is the only difference.  For example,\n+   if the two data references are DR_A and DR_B:\n \n                        DR_A                           DR_B\n       data-ref         arr[i]                         arr[j]\n@@ -1689,10 +1697,12 @@ prune_runtime_alias_test_list (vec<dr_with_seg_len_pair_t> *alias_pairs,\n \n static bool\n create_intersect_range_checks_index (class loop *loop, tree *cond_expr,\n-\t\t\t\t     const dr_with_seg_len& dr_a,\n-\t\t\t\t     const dr_with_seg_len& dr_b)\n+\t\t\t\t     const dr_with_seg_len_pair_t &alias_pair)\n {\n-  if (integer_zerop (DR_STEP (dr_a.dr))\n+  const dr_with_seg_len &dr_a = alias_pair.first;\n+  const dr_with_seg_len &dr_b = alias_pair.second;\n+  if ((alias_pair.flags & DR_ALIAS_MIXED_STEPS)\n+      || integer_zerop (DR_STEP (dr_a.dr))\n       || integer_zerop (DR_STEP (dr_b.dr))\n       || DR_NUM_DIMENSIONS (dr_a.dr) != DR_NUM_DIMENSIONS (dr_b.dr))\n     return false;\n@@ -1914,24 +1924,26 @@ get_segment_min_max (const dr_with_seg_len &d, tree *seg_min_out,\n   *seg_max_out = fold_build_pointer_plus (addr_base, max_reach);\n }\n \n-/* Given two data references and segment lengths described by DR_A and DR_B,\n-   create expression checking if the two addresses ranges intersect with\n-   each other:\n+/* Generate a runtime condition that is true if ALIAS_PAIR is free of aliases,\n+   storing the condition in *COND_EXPR.  The fallback is to generate a\n+   a test that the two accesses do not overlap:\n \n-     ((DR_A_addr_0 + DR_A_segment_length_0) <= DR_B_addr_0)\n-     || (DR_B_addr_0 + DER_B_segment_length_0) <= DR_A_addr_0))  */\n+     end_a <= start_b || end_b <= start_a.  */\n \n static void\n create_intersect_range_checks (class loop *loop, tree *cond_expr,\n-\t\t\t       const dr_with_seg_len& dr_a,\n-\t\t\t       const dr_with_seg_len& dr_b)\n+\t\t\t       const dr_with_seg_len_pair_t &alias_pair)\n {\n+  const dr_with_seg_len& dr_a = alias_pair.first;\n+  const dr_with_seg_len& dr_b = alias_pair.second;\n   *cond_expr = NULL_TREE;\n-  if (create_intersect_range_checks_index (loop, cond_expr, dr_a, dr_b))\n+  if (create_intersect_range_checks_index (loop, cond_expr, alias_pair))\n     return;\n \n   unsigned HOST_WIDE_INT min_align;\n   tree_code cmp_code;\n+  /* We don't have to check DR_ALIAS_MIXED_STEPS here, since both versions\n+     are equivalent.  This is just an optimization heuristic.  */\n   if (TREE_CODE (DR_STEP (dr_a.dr)) == INTEGER_CST\n       && TREE_CODE (DR_STEP (dr_b.dr)) == INTEGER_CST)\n     {\n@@ -1988,18 +2000,19 @@ create_runtime_alias_checks (class loop *loop,\n   tree part_cond_expr;\n \n   fold_defer_overflow_warnings ();\n-  for (size_t i = 0, s = alias_pairs->length (); i < s; ++i)\n+  dr_with_seg_len_pair_t *alias_pair;\n+  unsigned int i;\n+  FOR_EACH_VEC_ELT (*alias_pairs, i, alias_pair)\n     {\n-      const dr_with_seg_len& dr_a = (*alias_pairs)[i].first;\n-      const dr_with_seg_len& dr_b = (*alias_pairs)[i].second;\n-\n+      gcc_assert (alias_pair->flags);\n       if (dump_enabled_p ())\n \tdump_printf (MSG_NOTE,\n \t\t     \"create runtime check for data references %T and %T\\n\",\n-\t\t     DR_REF (dr_a.dr), DR_REF (dr_b.dr));\n+\t\t     DR_REF (alias_pair->first.dr),\n+\t\t     DR_REF (alias_pair->second.dr));\n \n       /* Create condition expression for each pair data references.  */\n-      create_intersect_range_checks (loop, &part_cond_expr, dr_a, dr_b);\n+      create_intersect_range_checks (loop, &part_cond_expr, *alias_pair);\n       if (*cond_expr)\n \t*cond_expr = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n \t\t\t\t  *cond_expr, part_cond_expr);"}, {"sha": "e4f71cae5ea4b3d9a9407cf17eb95cab8e25c669", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52c29905259363ce2b78dd7aa8a25cf531cddb3a/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52c29905259363ce2b78dd7aa8a25cf531cddb3a/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=52c29905259363ce2b78dd7aa8a25cf531cddb3a", "patch": "@@ -250,6 +250,12 @@ class dr_with_seg_len\n \tTemporary flags that indicate whether there is a pair P whose\n \tDRs have or haven't been swapped around.\n \n+   DR_ALIAS_MIXED_STEPS:\n+\tThe DR_STEP for one of the data references in the pair does not\n+\taccurately describe that reference for all members of P.  (Note\n+\tthat the flag does not say anything about whether the DR_STEPs\n+\tof the two references in the pair are the same.)\n+\n    The ordering assumption mentioned above is that for every pair\n    (DR_A, DR_B) in P:\n \n@@ -287,6 +293,7 @@ const unsigned int DR_ALIAS_WAW = 1U << 2;\n const unsigned int DR_ALIAS_ARBITRARY = 1U << 3;\n const unsigned int DR_ALIAS_SWAPPED = 1U << 4;\n const unsigned int DR_ALIAS_UNSWAPPED = 1U << 5;\n+const unsigned int DR_ALIAS_MIXED_STEPS = 1U << 6;\n \n /* This struct contains two dr_with_seg_len objects with aliasing data\n    refs.  Two comparisons are generated from them.  */"}]}