{"sha": "82c8274320fcfdf2ce27d26c017a4d9d9cafa4b1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODJjODI3NDMyMGZjZmRmMmNlMjdkMjZjMDE3YTRkOWQ5Y2FmYTRiMQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-07-03T00:15:50Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-07-03T00:15:50Z"}, "message": "c-decl.c (grokdeclarator): Don't frob current_function_decl around variable_size.\n\n        * c-decl.c (grokdeclarator): Don't frob current_function_decl\n        around variable_size.\n        (set_decl_nonlocal): Remove.\n        (store_parm_decls): Add stmts for pending sizes.\n        * calls.c (calls_function, calls_function_1): Remove.\n        (precompute_arguments): Don't call it.\n        * cfgexpand.c (set_save_expr_context): Remove.\n        (tree_expand_cfg): Don't call it.\n        * dwarf2out.c (add_bound_info): Don't handle SAVE_EXPR.\n        (dwarf2out_finish): Likewise.\n        * expr.c (emit_block_move): Adjust addresses to BLKmode.\n        (store_constructor): Don't pre-evaluate SAVE_EXPR.\n        (safe_from_p): Don't queue SAVE_EXPRs.\n        (expand_expr_real_1 <case SAVE_EXPR>): Rewrite to expect,\n        or build plain VAR_DECLs.\n        * fold-const.c (twoval_comparison_p): Don't look at SAVE_EXPR_RTL.\n        (fold): Likewise.\n        (fold_checksum_tree): Don't special-case SAVE_EXPR.\n        * function.c (free_after_compilation): Don't clear x_save_expr_regs.\n        (put_var_into_stack): Don't handle SAVE_EXPR.\n        (gen_mem_addressof): Likewise.\n        * function.h (struct function): Remove x_save_expr_regs.\n        (save_expr_regs): Remove.\n        * gengtype.c (adjust_field_tree_exp): Don't special-case SAVE_EXPR.\n        * print-tree.c (print_node): Don't dump SAVE_EXPR_NOPLACEHOLDER.\n        * stor-layout.c (variable_size): Don't set it.\n        (force_type_save_exprs, force_type_save_exprs_1): Remove.\n        * tree-inline.c (remap_save_expr): Remove fn argument.  Update\n        all callers.  Don't set SAVE_EXPR_CONTEXT.\n        * tree-inline.h (remap_save_expr): Update decl.\n        * tree.c (save_expr): Update build size.\n        (first_rtl_op): Don't handle SAVE_EXPR.\n        (unsave_expr_1, contains_placeholder_p): Likewise.\n        (decl_function_context): Likewise.\n        * tree.def (SAVE_EXPR): Remove args 1 and 2.\n        * tree.h (SAVE_EXPR_CONTEXT, SAVE_EXPR_RTL): Remove.\n        (SAVE_EXPR_NOPLACEHOLDER, SAVE_EXPR_PERSISTENT_P): Remove.\ncp/\n        * tree.c (cp_unsave_r): Update remap_save_expr call.\njava/\n        * jcf-write.c (generate_bytecode_insns <case SAVE_EXPR>): Rewrite.\n\nFrom-SVN: r84036", "tree": {"sha": "1c3ed35626f7a5ec145a2aaec1364cd9a760a955", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1c3ed35626f7a5ec145a2aaec1364cd9a760a955"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/82c8274320fcfdf2ce27d26c017a4d9d9cafa4b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82c8274320fcfdf2ce27d26c017a4d9d9cafa4b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82c8274320fcfdf2ce27d26c017a4d9d9cafa4b1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82c8274320fcfdf2ce27d26c017a4d9d9cafa4b1/comments", "author": null, "committer": null, "parents": [{"sha": "a7e4cdca852a596dffe4e7cd2a1b0bd887c5ebec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7e4cdca852a596dffe4e7cd2a1b0bd887c5ebec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7e4cdca852a596dffe4e7cd2a1b0bd887c5ebec"}], "stats": {"total": 822, "additions": 160, "deletions": 662}, "files": [{"sha": "bce517a67d1a27b8f57c3c384943d14342ca4cc6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c8274320fcfdf2ce27d26c017a4d9d9cafa4b1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c8274320fcfdf2ce27d26c017a4d9d9cafa4b1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=82c8274320fcfdf2ce27d26c017a4d9d9cafa4b1", "patch": "@@ -1,3 +1,43 @@\n+2004-07-02  Richard Henderson  <rth@redhat.com>\n+\n+\t* c-decl.c (grokdeclarator): Don't frob current_function_decl\n+\taround variable_size.\n+\t(set_decl_nonlocal): Remove.\n+\t(store_parm_decls): Add stmts for pending sizes.\n+\t* calls.c (calls_function, calls_function_1): Remove.\n+\t(precompute_arguments): Don't call it.\n+\t* cfgexpand.c (set_save_expr_context): Remove.\n+\t(tree_expand_cfg): Don't call it.\n+\t* dwarf2out.c (add_bound_info): Don't handle SAVE_EXPR.\n+\t(dwarf2out_finish): Likewise.\n+\t* expr.c (emit_block_move): Adjust addresses to BLKmode.\n+\t(store_constructor): Don't pre-evaluate SAVE_EXPR.\n+\t(safe_from_p): Don't queue SAVE_EXPRs.\n+\t(expand_expr_real_1 <case SAVE_EXPR>): Rewrite to expect,\n+\tor build plain VAR_DECLs.\n+\t* fold-const.c (twoval_comparison_p): Don't look at SAVE_EXPR_RTL.\n+\t(fold): Likewise.\n+\t(fold_checksum_tree): Don't special-case SAVE_EXPR.\n+\t* function.c (free_after_compilation): Don't clear x_save_expr_regs.\n+\t(put_var_into_stack): Don't handle SAVE_EXPR.\n+\t(gen_mem_addressof): Likewise.\n+\t* function.h (struct function): Remove x_save_expr_regs.\n+\t(save_expr_regs): Remove.\n+\t* gengtype.c (adjust_field_tree_exp): Don't special-case SAVE_EXPR.\n+\t* print-tree.c (print_node): Don't dump SAVE_EXPR_NOPLACEHOLDER.\n+\t* stor-layout.c (variable_size): Don't set it.\n+\t(force_type_save_exprs, force_type_save_exprs_1): Remove.\n+\t* tree-inline.c (remap_save_expr): Remove fn argument.  Update\n+\tall callers.  Don't set SAVE_EXPR_CONTEXT.\n+\t* tree-inline.h (remap_save_expr): Update decl.\n+\t* tree.c (save_expr): Update build size.\n+\t(first_rtl_op): Don't handle SAVE_EXPR.\n+\t(unsave_expr_1, contains_placeholder_p): Likewise.\n+\t(decl_function_context): Likewise.\n+\t* tree.def (SAVE_EXPR): Remove args 1 and 2.\n+\t* tree.h (SAVE_EXPR_CONTEXT, SAVE_EXPR_RTL): Remove.\n+\t(SAVE_EXPR_NOPLACEHOLDER, SAVE_EXPR_PERSISTENT_P): Remove.\n+\n 2004-07-03  Joseph S. Myers  <jsm@polyomino.org.uk>\n \n \t* doc/bugreport.texi, doc/configterms.texi, doc/contrib.texi,"}, {"sha": "329c86222a47b74d057473b1816ea11fd616301b", "filename": "gcc/c-decl.c", "status": "modified", "additions": 9, "deletions": 57, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c8274320fcfdf2ce27d26c017a4d9d9cafa4b1/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c8274320fcfdf2ce27d26c017a4d9d9cafa4b1/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=82c8274320fcfdf2ce27d26c017a4d9d9cafa4b1", "patch": "@@ -3990,20 +3990,7 @@ grokdeclarator (tree declarator, tree declspecs,\n \t\t    }\n \n \t\t  if (size_varies)\n-\t\t    {\n-\t\t      /* We must be able to distinguish the\n-\t\t\t SAVE_EXPR_CONTEXT for the variably-sized type\n-\t\t\t so that we can set it correctly in\n-\t\t\t set_save_expr_context.  The convention is\n-\t\t\t that all SAVE_EXPRs that need to be reset\n-\t\t\t have NULL_TREE for their SAVE_EXPR_CONTEXT.  */\n-\t\t      tree cfd = current_function_decl;\n-\t\t      if (decl_context == PARM)\n-\t\t\tcurrent_function_decl = NULL_TREE;\n-\t\t      itype = variable_size (itype);\n-\t\t      if (decl_context == PARM)\n-\t\t\tcurrent_function_decl = cfd;\n-\t\t    }\n+\t\t    itype = variable_size (itype);\n \t\t  itype = build_index_type (itype);\n \t\t}\n \t    }\n@@ -6065,25 +6052,6 @@ store_parm_decls_oldstyle (tree fndecl, tree arg_info)\n     }\n }\n \n-/* A subroutine of store_parm_decls called via walk_tree.  Mark all\n-   decls non-local.  */\n-\n-static tree\n-set_decl_nonlocal (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n-{\n-  tree t = *tp;\n-\n-  if (DECL_P (t))\n-    {\n-      DECL_NONLOCAL (t) = 1;\n-      *walk_subtrees = 0;\n-    }\n-  else if (TYPE_P (t))\n-    *walk_subtrees = 0;\n-\n-  return NULL;\n-}\n-\n /* Store the parameter declarations into the current function declaration.\n    This is called after parsing the parameter declarations, before\n    digesting the body of the function.\n@@ -6096,9 +6064,6 @@ store_parm_decls (void)\n {\n   tree fndecl = current_function_decl;\n \n-  /* The function containing FNDECL, if any.  */\n-  tree context = decl_function_context (fndecl);\n-\n   /* The argument information block for FNDECL.  */\n   tree arg_info = DECL_ARGUMENTS (fndecl);\n \n@@ -6129,27 +6094,14 @@ store_parm_decls (void)\n   /* Begin the statement tree for this function.  */\n   DECL_SAVED_TREE (fndecl) = push_stmt_list ();\n \n-  /* If this is a nested function, save away the sizes of any\n-     variable-size types so that we can expand them when generating\n-     RTL.  */\n-  if (context)\n-    {\n-      tree t;\n-\n-      DECL_LANG_SPECIFIC (fndecl)->pending_sizes\n-\t= nreverse (get_pending_sizes ());\n-      for (t = DECL_LANG_SPECIFIC (fndecl)->pending_sizes;\n-\t   t;\n-\t   t = TREE_CHAIN (t))\n-\t{\n-\t  /* We will have a nonlocal use of whatever variables are\n-\t     buried inside here.  */\n-\t  walk_tree (&TREE_OPERAND (TREE_VALUE (t), 0),\n-\t\t     set_decl_nonlocal, NULL, NULL);\n-\n-\t  SAVE_EXPR_CONTEXT (TREE_VALUE (t)) = context;\n-\t}\n-    }\n+  /* ??? Insert the contents of the pending sizes list into the function\n+     to be evaluated.  This just changes mis-behaviour until assign_parms\n+     phase ordering problems are resolved.  */\n+  {\n+    tree t;\n+    for (t = nreverse (get_pending_sizes ()); t ; t = TREE_CHAIN (t))\n+      add_stmt (TREE_VALUE (t));\n+  }\n \n   /* Even though we're inside a function body, we still don't want to\n      call expand_expr to calculate the size of a variable-sized array."}, {"sha": "328488e4ed3a3d34b08603906a8149650424ff34", "filename": "gcc/calls.c", "status": "modified", "additions": 36, "deletions": 164, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c8274320fcfdf2ce27d26c017a4d9d9cafa4b1/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c8274320fcfdf2ce27d26c017a4d9d9cafa4b1/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=82c8274320fcfdf2ce27d26c017a4d9d9cafa4b1", "patch": "@@ -117,9 +117,6 @@ static sbitmap stored_args_map;\n    argument list for the constructor call.  */\n int stack_arg_under_construction;\n \n-static int calls_function (tree, int);\n-static int calls_function_1 (tree, int);\n-\n static void emit_call_1 (rtx, tree, tree, tree, HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t HOST_WIDE_INT, rtx, rtx, int, rtx, int,\n \t\t\t CUMULATIVE_ARGS *);\n@@ -155,123 +152,6 @@ static rtx save_fixed_argument_area (int, rtx, int *, int *);\n static void restore_fixed_argument_area (rtx, rtx, int, int);\n #endif\n \f\n-/* If WHICH is 1, return 1 if EXP contains a call to the built-in function\n-   `alloca'.\n-\n-   If WHICH is 0, return 1 if EXP contains a call to any function.\n-   Actually, we only need return 1 if evaluating EXP would require pushing\n-   arguments on the stack, but that is too difficult to compute, so we just\n-   assume any function call might require the stack.  */\n-\n-static tree calls_function_save_exprs;\n-\n-static int\n-calls_function (tree exp, int which)\n-{\n-  int val;\n-\n-  calls_function_save_exprs = 0;\n-  val = calls_function_1 (exp, which);\n-  calls_function_save_exprs = 0;\n-  return val;\n-}\n-\n-/* Recursive function to do the work of above function.  */\n-\n-static int\n-calls_function_1 (tree exp, int which)\n-{\n-  int i;\n-  enum tree_code code = TREE_CODE (exp);\n-  int class = TREE_CODE_CLASS (code);\n-  int length = first_rtl_op (code);\n-\n-  /* If this code is language-specific, we don't know what it will do.  */\n-  if ((int) code >= NUM_TREE_CODES)\n-    return 1;\n-\n-  switch (code)\n-    {\n-    case CALL_EXPR:\n-      if (which == 0)\n-\treturn 1;\n-      else if ((TREE_CODE (TREE_TYPE (TREE_TYPE (TREE_OPERAND (exp, 0))))\n-\t\t== FUNCTION_TYPE)\n-\t       && (TYPE_RETURNS_STACK_DEPRESSED\n-\t\t   (TREE_TYPE (TREE_TYPE (TREE_OPERAND (exp, 0))))))\n-\treturn 1;\n-      else if (TREE_CODE (TREE_OPERAND (exp, 0)) == ADDR_EXPR\n-\t       && (TREE_CODE (TREE_OPERAND (TREE_OPERAND (exp, 0), 0))\n-\t\t   == FUNCTION_DECL)\n-\t       && (special_function_p (TREE_OPERAND (TREE_OPERAND (exp, 0), 0),\n-\t\t\t\t       0)\n-\t\t   & ECF_MAY_BE_ALLOCA))\n-\treturn 1;\n-\n-      break;\n-\n-    case CONSTRUCTOR:\n-      {\n-\ttree tem;\n-\n-\tfor (tem = CONSTRUCTOR_ELTS (exp); tem != 0; tem = TREE_CHAIN (tem))\n-\t  if (calls_function_1 (TREE_VALUE (tem), which))\n-\t    return 1;\n-      }\n-\n-      return 0;\n-\n-    case SAVE_EXPR:\n-      if (SAVE_EXPR_RTL (exp) != 0)\n-\treturn 0;\n-      if (value_member (exp, calls_function_save_exprs))\n-\treturn 0;\n-      calls_function_save_exprs = tree_cons (NULL_TREE, exp,\n-\t\t\t\t\t     calls_function_save_exprs);\n-      return (TREE_OPERAND (exp, 0) != 0\n-\t      && calls_function_1 (TREE_OPERAND (exp, 0), which));\n-\n-    case BLOCK:\n-      {\n-\ttree local;\n-\ttree subblock;\n-\n-\tfor (local = BLOCK_VARS (exp); local; local = TREE_CHAIN (local))\n-\t  if (DECL_INITIAL (local) != 0\n-\t      && calls_function_1 (DECL_INITIAL (local), which))\n-\t    return 1;\n-\n-\tfor (subblock = BLOCK_SUBBLOCKS (exp);\n-\t     subblock;\n-\t     subblock = TREE_CHAIN (subblock))\n-\t  if (calls_function_1 (subblock, which))\n-\t    return 1;\n-      }\n-      return 0;\n-\n-    case TREE_LIST:\n-      for (; exp != 0; exp = TREE_CHAIN (exp))\n-\tif (calls_function_1 (TREE_VALUE (exp), which))\n-\t  return 1;\n-      return 0;\n-\n-    default:\n-      break;\n-    }\n-\n-  /* Only expressions and blocks can contain calls.\n-     Blocks were handled above.  */\n-  if (! IS_EXPR_CODE_CLASS (class))\n-    return 0;\n-\n-  for (i = 0; i < length; i++)\n-    if (TREE_OPERAND (exp, i) != 0\n-\t&& calls_function_1 (TREE_OPERAND (exp, i), which))\n-      return 1;\n-\n-  return 0;\n-}\n-\f\n /* Force FUNEXP into a form suitable for the address of a CALL,\n    and return that as an rtx.  Also load the static chain register\n    if FNDECL is a nested function.\n@@ -1372,58 +1252,50 @@ precompute_arguments (int flags, int num_actuals, struct arg_data *args)\n   int i;\n \n   /* If this is a libcall, then precompute all arguments so that we do not\n-     get extraneous instructions emitted as part of the libcall sequence.\n-\n-     If this target defines ACCUMULATE_OUTGOING_ARGS to true, then we must\n-     precompute all arguments that contain function calls.  Otherwise,\n-     computing arguments for a subcall may clobber arguments for this call.\n-\n-     If this target defines ACCUMULATE_OUTGOING_ARGS to false, then we only\n-     need to precompute arguments that change the stack pointer, such as calls\n-     to alloca, and calls that do not pop all of their arguments.  */\n-\n+     get extraneous instructions emitted as part of the libcall sequence.  */\n+  if ((flags & ECF_LIBCALL_BLOCK) == 0)\n+    return;\n+    \n   for (i = 0; i < num_actuals; i++)\n-    if ((flags & ECF_LIBCALL_BLOCK)\n-\t|| calls_function (args[i].tree_value, !ACCUMULATE_OUTGOING_ARGS))\n-      {\n-\tenum machine_mode mode;\n+    {\n+      enum machine_mode mode;\n \n-\t/* If this is an addressable type, we cannot pre-evaluate it.  */\n-\tif (TREE_ADDRESSABLE (TREE_TYPE (args[i].tree_value)))\n-\t  abort ();\n+      /* If this is an addressable type, we cannot pre-evaluate it.  */\n+      if (TREE_ADDRESSABLE (TREE_TYPE (args[i].tree_value)))\n+\tabort ();\n \n-\targs[i].value\n-\t  = expand_expr (args[i].tree_value, NULL_RTX, VOIDmode, 0);\n+      args[i].value\n+\t= expand_expr (args[i].tree_value, NULL_RTX, VOIDmode, 0);\n \n-\t/* ANSI doesn't require a sequence point here,\n-\t   but PCC has one, so this will avoid some problems.  */\n-\temit_queue ();\n+      /* ANSI doesn't require a sequence point here,\n+\t but PCC has one, so this will avoid some problems.  */\n+      emit_queue ();\n \n-\targs[i].initial_value = args[i].value\n-\t  = protect_from_queue (args[i].value, 0);\n+      args[i].initial_value = args[i].value\n+\t= protect_from_queue (args[i].value, 0);\n \n-\tmode = TYPE_MODE (TREE_TYPE (args[i].tree_value));\n-\tif (mode != args[i].mode)\n-\t  {\n-\t    args[i].value\n-\t      = convert_modes (args[i].mode, mode,\n-\t\t\t       args[i].value, args[i].unsignedp);\n+      mode = TYPE_MODE (TREE_TYPE (args[i].tree_value));\n+      if (mode != args[i].mode)\n+\t{\n+\t  args[i].value\n+\t    = convert_modes (args[i].mode, mode,\n+\t\t\t     args[i].value, args[i].unsignedp);\n #if defined(PROMOTE_FUNCTION_MODE) && !defined(PROMOTE_MODE)\n-\t    /* CSE will replace this only if it contains args[i].value\n-\t       pseudo, so convert it down to the declared mode using\n-\t       a SUBREG.  */\n-\t    if (REG_P (args[i].value)\n-\t\t&& GET_MODE_CLASS (args[i].mode) == MODE_INT)\n-\t      {\n-\t\targs[i].initial_value\n-\t\t  = gen_lowpart_SUBREG (mode, args[i].value);\n-\t\tSUBREG_PROMOTED_VAR_P (args[i].initial_value) = 1;\n-\t\tSUBREG_PROMOTED_UNSIGNED_SET (args[i].initial_value,\n-\t\t  args[i].unsignedp);\n-\t      }\n+\t  /* CSE will replace this only if it contains args[i].value\n+\t     pseudo, so convert it down to the declared mode using\n+\t     a SUBREG.  */\n+\t  if (REG_P (args[i].value)\n+\t      && GET_MODE_CLASS (args[i].mode) == MODE_INT)\n+\t    {\n+\t      args[i].initial_value\n+\t\t= gen_lowpart_SUBREG (mode, args[i].value);\n+\t      SUBREG_PROMOTED_VAR_P (args[i].initial_value) = 1;\n+\t      SUBREG_PROMOTED_UNSIGNED_SET (args[i].initial_value,\n+\t\t\t\t\t    args[i].unsignedp);\n+\t    }\n #endif\n-\t  }\n-      }\n+\t}\n+    }\n }\n \n /* Given the current state of MUST_PREALLOCATE and information about"}, {"sha": "01b58a1d7b15f1886e744242acd17e455e4e4901", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c8274320fcfdf2ce27d26c017a4d9d9cafa4b1/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c8274320fcfdf2ce27d26c017a4d9d9cafa4b1/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=82c8274320fcfdf2ce27d26c017a4d9d9cafa4b1", "patch": "@@ -360,26 +360,6 @@ construct_exit_block (void)\n   update_bb_for_insn (exit_block);\n }\n \n-/* Called to move the SAVE_EXPRs for parameter declarations in a\n-   nested function into the nested function.  DATA is really the\n-   nested FUNCTION_DECL.  */\n-\n-static tree\n-set_save_expr_context (tree *tp,\n-                       int *walk_subtrees,\n-                       void *data)\n-{\n-  if (TREE_CODE (*tp) == SAVE_EXPR && !SAVE_EXPR_CONTEXT (*tp))\n-    SAVE_EXPR_CONTEXT (*tp) = (tree) data;\n-  /* Do not walk back into the SAVE_EXPR_CONTEXT; that will cause\n-     circularity.  */\n-  else if (DECL_P (*tp))\n-    *walk_subtrees = 0;\n-\n-  return NULL;\n-}\n-\n-\n /* Translate the intermediate representation contained in the CFG\n    from GIMPLE trees to RTL.\n \n@@ -403,15 +383,6 @@ tree_expand_cfg (void)\n \t       IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (current_function_decl)));\n     }\n \n-  /* If the function has a variably modified type, there may be\n-     SAVE_EXPRs in the parameter types.  Their context must be set to\n-     refer to this function; they cannot be expanded in the containing\n-     function.  */\n-  if (decl_function_context (current_function_decl) == current_function_decl\n-      && variably_modified_type_p (TREE_TYPE (current_function_decl)))\n-    walk_tree (&TREE_TYPE (current_function_decl), set_save_expr_context,\n-\t       current_function_decl, NULL);\n-\n   /* Prepare the rtl middle end to start recording block changes.  */\n   reset_block_changes ();\n "}, {"sha": "dbd0ac78953561fd0ee23e5b73b2ba0cca15b598", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c8274320fcfdf2ce27d26c017a4d9d9cafa4b1/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c8274320fcfdf2ce27d26c017a4d9d9cafa4b1/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=82c8274320fcfdf2ce27d26c017a4d9d9cafa4b1", "patch": "@@ -1,3 +1,7 @@\n+2004-07-02  Richard Henderson  <rth@redhat.com>\n+\n+\t* tree.c (cp_unsave_r): Update remap_save_expr call.\n+\n 2004-07-02  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/16240"}, {"sha": "deee9dc86286a41a579be235b55ed3ac485157e0", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c8274320fcfdf2ce27d26c017a4d9d9cafa4b1/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c8274320fcfdf2ce27d26c017a4d9d9cafa4b1/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=82c8274320fcfdf2ce27d26c017a4d9d9cafa4b1", "patch": "@@ -2256,7 +2256,7 @@ cp_unsave_r (tree* tp,\n \t*tp = (tree) n->value;\n     }\n   else if (TREE_CODE (*tp) == SAVE_EXPR)\n-    remap_save_expr (tp, st, current_function_decl, walk_subtrees);\n+    remap_save_expr (tp, st, walk_subtrees);\n   else\n     {\n       copy_tree_r (tp, walk_subtrees, NULL);"}, {"sha": "2fb962ce63a5ff30071df95e2ce34f9509a07633", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 0, "deletions": 65, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c8274320fcfdf2ce27d26c017a4d9d9cafa4b1/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c8274320fcfdf2ce27d26c017a4d9d9cafa4b1/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=82c8274320fcfdf2ce27d26c017a4d9d9cafa4b1", "patch": "@@ -10249,53 +10249,6 @@ add_bound_info (dw_die_ref subrange_die, enum dwarf_attribute bound_attr, tree b\n       break;\n \n     case SAVE_EXPR:\n-      /* If optimization is turned on, the SAVE_EXPRs that describe how to\n-\t access the upper bound values may be bogus.  If they refer to a\n-\t register, they may only describe how to get at these values at the\n-\t points in the generated code right after they have just been\n-\t computed.  Worse yet, in the typical case, the upper bound values\n-\t will not even *be* computed in the optimized code (though the\n-\t number of elements will), so these SAVE_EXPRs are entirely\n-\t bogus. In order to compensate for this fact, we check here to see\n-\t if optimization is enabled, and if so, we don't add an attribute\n-\t for the (unknown and unknowable) upper bound.  This should not\n-\t cause too much trouble for existing (stupid?)  debuggers because\n-\t they have to deal with empty upper bounds location descriptions\n-\t anyway in order to be able to deal with incomplete array types.\n-\t Of course an intelligent debugger (GDB?)  should be able to\n-\t comprehend that a missing upper bound specification in an array\n-\t type used for a storage class `auto' local array variable\n-\t indicates that the upper bound is both unknown (at compile- time)\n-\t and unknowable (at run-time) due to optimization.\n-\n-\t We assume that a MEM rtx is safe because gcc wouldn't put the\n-\t value there unless it was going to be used repeatedly in the\n-\t function, i.e. for cleanups.  */\n-      if (SAVE_EXPR_RTL (bound)\n-\t  && (! optimize || MEM_P (SAVE_EXPR_RTL (bound))))\n-\t{\n-\t  dw_die_ref ctx = lookup_decl_die (current_function_decl);\n-\t  dw_die_ref decl_die = new_die (DW_TAG_variable, ctx, bound);\n-\t  rtx loc = SAVE_EXPR_RTL (bound);\n-\n-\t  /* If the RTL for the SAVE_EXPR is memory, handle the case where\n-\t     it references an outer function's frame.  */\n-\t  if (MEM_P (loc))\n-\t    {\n-\t      rtx new_addr = fix_lexical_addr (XEXP (loc, 0), bound);\n-\n-\t      if (XEXP (loc, 0) != new_addr)\n-\t\tloc = gen_rtx_MEM (GET_MODE (loc), new_addr);\n-\t    }\n-\n-\t  add_AT_flag (decl_die, DW_AT_artificial, 1);\n-\t  add_type_attribute (decl_die, TREE_TYPE (bound), 1, 0, ctx);\n-\t  add_AT_location_description (decl_die, DW_AT_location,\n-\t\t\t\t       loc_descriptor (loc, true));\n-\t  add_AT_die_ref (subrange_die, bound_attr, decl_die);\n-\t}\n-\n-      /* Else leave out the attribute.  */\n       break;\n \n     case VAR_DECL:\n@@ -10331,15 +10284,6 @@ add_bound_info (dw_die_ref subrange_die, enum dwarf_attribute bound_attr, tree b\n \telse\n \t  ctx = lookup_decl_die (current_function_decl);\n \n-\t/* If we weren't able to find a context, it's most likely the case\n-\t   that we are processing the return type of the function.  So\n-\t   make a SAVE_EXPR to point to it and have the limbo DIE code\n-\t   find the proper die.  The save_expr function doesn't always\n-\t   make a SAVE_EXPR, so do it ourselves.  */\n-\tif (ctx == 0)\n-\t  bound = build (SAVE_EXPR, TREE_TYPE (bound), bound,\n-\t\t\t current_function_decl, NULL_TREE);\n-\n \tdecl_die = new_die (DW_TAG_variable, ctx, bound);\n \tadd_AT_flag (decl_die, DW_AT_artificial, 1);\n \tadd_type_attribute (decl_die, TREE_TYPE (bound), 1, 0, ctx);\n@@ -13735,15 +13679,6 @@ dwarf2out_finish (const char *filename)\n \t    add_child_die (origin->die_parent, die);\n \t  else if (die == comp_unit_die)\n \t    ;\n-\t  /* If this was an expression for a bound involved in a function\n-\t     return type, it may be a SAVE_EXPR for which we weren't able\n-\t     to find a DIE previously.  So try now.  */\n-\t  else if (node->created_for\n-\t\t   && TREE_CODE (node->created_for) == SAVE_EXPR\n-\t\t   && 0 != (origin = (lookup_decl_die\n-\t\t\t\t      (SAVE_EXPR_CONTEXT\n-\t\t\t\t       (node->created_for)))))\n-\t    add_child_die (origin, die);\n \t  else if (errorcount > 0 || sorrycount > 0)\n \t    /* It's OK to be confused by errors in the input.  */\n \t    add_child_die (comp_unit_die, die);"}, {"sha": "d3951fed769a6db1551b3bfd861a4c36988ac406", "filename": "gcc/expr.c", "status": "modified", "additions": 44, "deletions": 178, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c8274320fcfdf2ce27d26c017a4d9d9cafa4b1/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c8274320fcfdf2ce27d26c017a4d9d9cafa4b1/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=82c8274320fcfdf2ce27d26c017a4d9d9cafa4b1", "patch": "@@ -1349,11 +1349,6 @@ emit_block_move (rtx x, rtx y, rtx size, enum block_op_methods method)\n \n   align = MIN (MEM_ALIGN (x), MEM_ALIGN (y));\n \n-  if (GET_MODE (x) != BLKmode)\n-    abort ();\n-  if (GET_MODE (y) != BLKmode)\n-    abort ();\n-\n   x = protect_from_queue (x, 1);\n   y = protect_from_queue (y, 0);\n   size = protect_from_queue (size, 0);\n@@ -1365,6 +1360,11 @@ emit_block_move (rtx x, rtx y, rtx size, enum block_op_methods method)\n   if (size == 0)\n     abort ();\n \n+  /* Make sure we've got BLKmode addresses; store_one_arg can decide that\n+     block copy is more efficient for other large modes, e.g. DCmode.  */\n+  x = adjust_address (x, BLKmode, 0);\n+  y = adjust_address (y, BLKmode, 0);\n+\n   /* Set MEM_SIZE as appropriate for this block copy.  The main place this\n      can be incorrect is coming from __builtin_memcpy.  */\n   if (GET_CODE (size) == CONST_INT)\n@@ -5090,14 +5090,6 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t\t    = gen_reg_rtx (promote_mode (domain, DECL_MODE (index),\n \t\t\t\t\t\t &unsignedp, 0));\n \t\t  SET_DECL_RTL (index, index_r);\n-\t\t  if (TREE_CODE (value) == SAVE_EXPR\n-\t\t      && SAVE_EXPR_RTL (value) == 0)\n-\t\t    {\n-\t\t      /* Make sure value gets expanded once before the\n-                         loop.  */\n-\t\t      expand_expr (value, const0_rtx, VOIDmode, 0);\n-\t\t      emit_queue ();\n-\t\t    }\n \t\t  store_expr (lo_index, index_r, 0);\n \n \t\t  /* Build the head of the loop.  */\n@@ -5986,7 +5978,6 @@ safe_from_p (rtx x, tree exp, int top_p)\n {\n   rtx exp_rtl = 0;\n   int i, nops;\n-  static tree save_expr_list;\n \n   if (x == 0\n       /* If EXP has varying size, we MUST use a target since we currently\n@@ -6018,30 +6009,6 @@ safe_from_p (rtx x, tree exp, int top_p)\n \treturn 0;\n     }\n \n-  /* A SAVE_EXPR might appear many times in the expression passed to the\n-     top-level safe_from_p call, and if it has a complex subexpression,\n-     examining it multiple times could result in a combinatorial explosion.\n-     E.g. on an Alpha running at least 200MHz, a Fortran testcase compiled\n-     with optimization took about 28 minutes to compile -- even though it was\n-     only a few lines long.  So we mark each SAVE_EXPR we see with TREE_PRIVATE\n-     and turn that off when we are done.  We keep a list of the SAVE_EXPRs\n-     we have processed.  Note that the only test of top_p was above.  */\n-\n-  if (top_p)\n-    {\n-      int rtn;\n-      tree t;\n-\n-      save_expr_list = 0;\n-\n-      rtn = safe_from_p (x, exp, 0);\n-\n-      for (t = save_expr_list; t != 0; t = TREE_CHAIN (t))\n-\tTREE_PRIVATE (TREE_PURPOSE (t)) = 0;\n-\n-      return rtn;\n-    }\n-\n   /* Now look at our tree code and possibly recurse.  */\n   switch (TREE_CODE_CLASS (TREE_CODE (exp)))\n     {\n@@ -6139,28 +6106,8 @@ safe_from_p (rtx x, tree exp, int top_p)\n \t  break;\n \n \tcase CLEANUP_POINT_EXPR:\n-\t  return safe_from_p (x, TREE_OPERAND (exp, 0), 0);\n-\n \tcase SAVE_EXPR:\n-\t  exp_rtl = SAVE_EXPR_RTL (exp);\n-\t  if (exp_rtl)\n-\t    break;\n-\n-\t  /* If we've already scanned this, don't do it again.  Otherwise,\n-\t     show we've scanned it and record for clearing the flag if we're\n-\t     going on.  */\n-\t  if (TREE_PRIVATE (exp))\n-\t    return 1;\n-\n-\t  TREE_PRIVATE (exp) = 1;\n-\t  if (! safe_from_p (x, TREE_OPERAND (exp, 0), 0))\n-\t    {\n-\t      TREE_PRIVATE (exp) = 0;\n-\t      return 0;\n-\t    }\n-\n-\t  save_expr_list = tree_cons (exp, NULL_TREE, save_expr_list);\n-\t  return 1;\n+\t  return safe_from_p (x, TREE_OPERAND (exp, 0), 0);\n \n \tcase BIND_EXPR:\n \t  /* The only operand we look at is operand 1.  The rest aren't\n@@ -6841,88 +6788,30 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       return temp;\n \n     case SAVE_EXPR:\n-      context = decl_function_context (exp);\n-\n-      /* If this SAVE_EXPR was at global context, assume we are an\n-\t initialization function and move it into our context.  */\n-      if (context == 0)\n-\tSAVE_EXPR_CONTEXT (exp) = current_function_decl;\n-\n-      if (context == current_function_decl)\n-\tcontext = 0;\n-\n-      /* If this is non-local, handle it.  */\n-      if (context)\n-\t{\n-\t  /* The following call just exists to abort if the context is\n-\t     not of a containing function.  */\n-\t  find_function_data (context);\n-\n-\t  temp = SAVE_EXPR_RTL (exp);\n-\t  if (temp && REG_P (temp))\n-\t    {\n-\t      put_var_into_stack (exp, /*rescan=*/true);\n-\t      temp = SAVE_EXPR_RTL (exp);\n-\t    }\n-\t  if (temp == 0 || !MEM_P (temp))\n-\t    abort ();\n-\t  return\n-\t    replace_equiv_address (temp,\n-\t\t\t\t   fix_lexical_addr (XEXP (temp, 0), exp));\n-\t}\n-      if (SAVE_EXPR_RTL (exp) == 0)\n-\t{\n-\t  if (mode == VOIDmode)\n-\t    temp = const0_rtx;\n-\t  else\n-\t    temp = assign_temp (build_qualified_type (type,\n-\t\t\t\t\t\t      (TYPE_QUALS (type)\n-\t\t\t\t\t\t       | TYPE_QUAL_CONST)),\n-\t\t\t\t3, 0, 0);\n-\n-\t  SAVE_EXPR_RTL (exp) = temp;\n-\t  if (!optimize && REG_P (temp))\n-\t    save_expr_regs = gen_rtx_EXPR_LIST (VOIDmode, temp,\n-\t\t\t\t\t\tsave_expr_regs);\n-\n-\t  /* If the mode of TEMP does not match that of the expression, it\n-\t     must be a promoted value.  We pass store_expr a SUBREG of the\n-\t     wanted mode but mark it so that we know that it was already\n-\t     extended.  */\n-\n-\t  if (REG_P (temp) && GET_MODE (temp) != mode)\n-\t    {\n-\t      temp = gen_lowpart_SUBREG (mode, SAVE_EXPR_RTL (exp));\n-\t      promote_mode (type, mode, &unsignedp, 0);\n-\t      SUBREG_PROMOTED_VAR_P (temp) = 1;\n-\t      SUBREG_PROMOTED_UNSIGNED_SET (temp, unsignedp);\n-\t    }\n-\n-\t  if (temp == const0_rtx)\n-\t    expand_expr (TREE_OPERAND (exp, 0), const0_rtx, VOIDmode, 0);\n-\t  else\n-\t    store_expr (TREE_OPERAND (exp, 0), temp,\n-\t\t\tmodifier == EXPAND_STACK_PARM ? 2 : 0);\n+      {\n+\ttree val = TREE_OPERAND (exp, 0);\n+\trtx ret = expand_expr_real_1 (val, target, tmode, modifier, alt_rtl);\n \n-\t  TREE_USED (exp) = 1;\n-\t}\n+\tif (TREE_CODE (val) != VAR_DECL || !DECL_ARTIFICIAL (val))\n+\t  {\n+\t    /* We can indeed still hit this case, typically via builtin\n+\t       expanders calling save_expr immediately before expanding\n+\t       something.  Assume this means that we only have to deal\n+\t       with non-BLKmode values.  */\n+\t    if (GET_MODE (ret) == BLKmode)\n+\t      abort ();\n \n-      /* If the mode of SAVE_EXPR_RTL does not match that of the expression, it\n-\t must be a promoted value.  We return a SUBREG of the wanted mode,\n-\t but mark it so that we know that it was already extended.  */\n+\t    val = build_decl (VAR_DECL, NULL, TREE_TYPE (exp));\n+\t    DECL_ARTIFICIAL (val) = 1;\n+\t    TREE_OPERAND (exp, 0) = val;\n \n-      if (REG_P (SAVE_EXPR_RTL (exp))\n-\t  && GET_MODE (SAVE_EXPR_RTL (exp)) != mode)\n-\t{\n-\t  /* Compute the signedness and make the proper SUBREG.  */\n-\t  promote_mode (type, mode, &unsignedp, 0);\n-\t  temp = gen_lowpart_SUBREG (mode, SAVE_EXPR_RTL (exp));\n-\t  SUBREG_PROMOTED_VAR_P (temp) = 1;\n-\t  SUBREG_PROMOTED_UNSIGNED_SET (temp, unsignedp);\n-\t  return temp;\n-\t}\n+\t    if (!CONSTANT_P (ret))\n+\t      ret = copy_to_reg (ret);\n+\t    SET_DECL_RTL (val, ret);\n+\t  }\n \n-      return SAVE_EXPR_RTL (exp);\n+        return ret;\n+      }\n \n     case UNSAVE_EXPR:\n       {\n@@ -7301,25 +7190,13 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t\t && (offset != 0\n \t\t     || (code == ARRAY_RANGE_REF && mode == BLKmode)))\n \t  {\n-\t    /* If the operand is a SAVE_EXPR, we can deal with this by\n-\t       forcing the SAVE_EXPR into memory.  */\n-\t    if (TREE_CODE (TREE_OPERAND (exp, 0)) == SAVE_EXPR)\n-\t      {\n-\t\tput_var_into_stack (TREE_OPERAND (exp, 0),\n-\t\t\t\t    /*rescan=*/true);\n-\t\top0 = SAVE_EXPR_RTL (TREE_OPERAND (exp, 0));\n-\t      }\n-\t    else\n-\t      {\n-\t\ttree nt\n-\t\t  = build_qualified_type (TREE_TYPE (tem),\n-\t\t\t\t\t  (TYPE_QUALS (TREE_TYPE (tem))\n-\t\t\t\t\t   | TYPE_QUAL_CONST));\n-\t\trtx memloc = assign_temp (nt, 1, 1, 1);\n+\t    tree nt = build_qualified_type (TREE_TYPE (tem),\n+\t\t\t\t\t    (TYPE_QUALS (TREE_TYPE (tem))\n+\t\t\t\t\t     | TYPE_QUAL_CONST));\n+\t    rtx memloc = assign_temp (nt, 1, 1, 1);\n \n-\t\temit_move_insn (memloc, op0);\n-\t\top0 = memloc;\n-\t      }\n+\t    emit_move_insn (memloc, op0);\n+\t    op0 = memloc;\n \t  }\n \n \tif (offset != 0)\n@@ -9045,31 +8922,20 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t\t   || GET_CODE (op0) == CONCAT || GET_CODE (op0) == ADDRESSOF\n \t\t   || GET_CODE (op0) == PARALLEL || GET_CODE (op0) == LO_SUM)\n \t    {\n-\t      /* If the operand is a SAVE_EXPR, we can deal with this by\n-\t\t forcing the SAVE_EXPR into memory.  */\n-\t      if (TREE_CODE (TREE_OPERAND (exp, 0)) == SAVE_EXPR)\n-\t\t{\n-\t\t  put_var_into_stack (TREE_OPERAND (exp, 0),\n-\t\t\t\t      /*rescan=*/true);\n-\t\t  op0 = SAVE_EXPR_RTL (TREE_OPERAND (exp, 0));\n-\t\t}\n+\t      /* If this object is in a register, it can't be BLKmode.  */\n+\t      tree inner_type = TREE_TYPE (TREE_OPERAND (exp, 0));\n+\t      rtx memloc = assign_temp (inner_type, 1, 1, 1);\n+\n+\t      if (GET_CODE (op0) == PARALLEL)\n+\t        /* Handle calls that pass values in multiple\n+\t\t   non-contiguous locations.  The Irix 6 ABI has examples\n+\t\t   of this.  */\n+\t\temit_group_store (memloc, op0, inner_type,\n+\t\t\t\t  int_size_in_bytes (inner_type));\n \t      else\n-\t\t{\n-\t\t  /* If this object is in a register, it can't be BLKmode.  */\n-\t\t  tree inner_type = TREE_TYPE (TREE_OPERAND (exp, 0));\n-\t\t  rtx memloc = assign_temp (inner_type, 1, 1, 1);\n-\n-\t\t  if (GET_CODE (op0) == PARALLEL)\n-\t\t    /* Handle calls that pass values in multiple\n-\t\t       non-contiguous locations.  The Irix 6 ABI has examples\n-\t\t       of this.  */\n-\t\t    emit_group_store (memloc, op0, inner_type,\n-\t\t\t\t      int_size_in_bytes (inner_type));\n-\t\t  else\n-\t\t    emit_move_insn (memloc, op0);\n+\t\temit_move_insn (memloc, op0);\n \n-\t\t  op0 = memloc;\n-\t\t}\n+\t      op0 = memloc;\n \t    }\n \n \t  if (!MEM_P (op0))"}, {"sha": "bfd17989003d919049f3ed6d45d6f81e88be33b6", "filename": "gcc/fold-const.c", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c8274320fcfdf2ce27d26c017a4d9d9cafa4b1/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c8274320fcfdf2ce27d26c017a4d9d9cafa4b1/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=82c8274320fcfdf2ce27d26c017a4d9d9cafa4b1", "patch": "@@ -2661,7 +2661,7 @@ twoval_comparison_p (tree arg, tree *cval1, tree *cval2, int *save_p)\n \t       || code == COMPOUND_EXPR))\n     class = '2';\n \n-  else if (class == 'e' && code == SAVE_EXPR && SAVE_EXPR_RTL (arg) == 0\n+  else if (class == 'e' && code == SAVE_EXPR\n \t   && ! TREE_SIDE_EFFECTS (TREE_OPERAND (arg, 0)))\n     {\n       /* If we've already found a CVAL1 or CVAL2, this expression is\n@@ -5971,10 +5971,6 @@ fold (tree expr)\n      if all operands are constant.  */\n   int wins = 1;\n \n-  /* Don't try to process an SAVE_EXPR that's already been evaluated.  */\n-  if (code == SAVE_EXPR && SAVE_EXPR_RTL (t) != 0)\n-    return t;\n-\n   /* Return right away if a constant.  */\n   if (kind == 'c')\n     return t;\n@@ -8985,14 +8981,7 @@ fold_checksum_tree (tree expr, struct md5_ctx *ctx, htab_t ht)\n     return;\n   *slot = expr;\n   code = TREE_CODE (expr);\n-  if (code == SAVE_EXPR && SAVE_EXPR_NOPLACEHOLDER (expr))\n-    {\n-      /* Allow SAVE_EXPR_NOPLACEHOLDER flag to be modified.  */\n-      memcpy (buf, expr, tree_size (expr));\n-      expr = (tree) buf;\n-      SAVE_EXPR_NOPLACEHOLDER (expr) = 0;\n-    }\n-  else if (TREE_CODE_CLASS (code) == 'd' && DECL_ASSEMBLER_NAME_SET_P (expr))\n+  if (TREE_CODE_CLASS (code) == 'd' && DECL_ASSEMBLER_NAME_SET_P (expr))\n     {\n       /* Allow DECL_ASSEMBLER_NAME to be modified.  */\n       memcpy (buf, expr, tree_size (expr));\n@@ -9051,7 +9040,6 @@ fold_checksum_tree (tree expr, struct md5_ctx *ctx, htab_t ht)\n     case 'e':\n       switch (code)\n \t{\n-\tcase SAVE_EXPR: len = 2; break;\n \tcase GOTO_SUBROUTINE_EXPR: len = 0; break;\n \tcase WITH_CLEANUP_EXPR: len = 2; break;\n \tdefault: break;"}, {"sha": "b6d37896a8e6176fece97735d0624ca5760a7f6a", "filename": "gcc/function.c", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c8274320fcfdf2ce27d26c017a4d9d9cafa4b1/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c8274320fcfdf2ce27d26c017a4d9d9cafa4b1/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=82c8274320fcfdf2ce27d26c017a4d9d9cafa4b1", "patch": "@@ -436,7 +436,6 @@ free_after_compilation (struct function *f)\n   f->x_nonlocal_goto_handler_labels = NULL;\n   f->x_return_label = NULL;\n   f->x_naked_return_label = NULL;\n-  f->x_save_expr_regs = NULL;\n   f->x_stack_slot_list = NULL;\n   f->x_tail_recursion_reentry = NULL;\n   f->x_arg_pointer_save_area = NULL;\n@@ -1305,9 +1304,7 @@ put_var_into_stack (tree decl, int rescan)\n   context = decl_function_context (decl);\n \n   /* Get the current rtl used for this object and its original mode.  */\n- orig_reg = reg = (TREE_CODE (decl) == SAVE_EXPR\n-\t\t   ? SAVE_EXPR_RTL (decl)\n-\t\t   : DECL_RTL_IF_SET (decl));\n+  orig_reg = reg = DECL_RTL_IF_SET (decl);\n \n   /* No need to do anything if decl has no rtx yet\n      since in that case caller is setting TREE_ADDRESSABLE\n@@ -2824,10 +2821,8 @@ gen_mem_addressof (rtx reg, tree decl, int rescan)\n   if (decl)\n     {\n       tree type = TREE_TYPE (decl);\n-      enum machine_mode decl_mode\n-\t= (DECL_P (decl) ? DECL_MODE (decl) : TYPE_MODE (TREE_TYPE (decl)));\n-      rtx decl_rtl = (TREE_CODE (decl) == SAVE_EXPR ? SAVE_EXPR_RTL (decl)\n-\t\t      : DECL_RTL_IF_SET (decl));\n+      enum machine_mode decl_mode = DECL_MODE (decl);\n+      rtx decl_rtl = DECL_RTL_IF_SET (decl);\n \n       PUT_MODE (reg, decl_mode);\n "}, {"sha": "4a057625bcfdbe784f3fa16b2d24a011f648dec7", "filename": "gcc/function.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c8274320fcfdf2ce27d26c017a4d9d9cafa4b1/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c8274320fcfdf2ce27d26c017a4d9d9cafa4b1/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=82c8274320fcfdf2ce27d26c017a4d9d9cafa4b1", "patch": "@@ -243,10 +243,6 @@ struct function GTY(())\n      on machines which require execution of the epilogue on all returns.  */\n   rtx x_naked_return_label;\n \n-  /* List (chain of EXPR_LISTs) of pseudo-regs of SAVE_EXPRs.\n-     So we can mark them all live at the end of the function, if nonopt.  */\n-  rtx x_save_expr_regs;\n-\n   /* List (chain of EXPR_LISTs) of all stack slots in this function.\n      Made for the sake of unshare_all_rtl.  */\n   rtx x_stack_slot_list;\n@@ -506,7 +502,6 @@ extern int trampolines_created;\n #define parm_reg_stack_loc (cfun->x_parm_reg_stack_loc)\n #define return_label (cfun->x_return_label)\n #define naked_return_label (cfun->x_naked_return_label)\n-#define save_expr_regs (cfun->x_save_expr_regs)\n #define stack_slot_list (cfun->x_stack_slot_list)\n #define parm_birth_insn (cfun->x_parm_birth_insn)\n #define frame_offset (cfun->x_frame_offset)"}, {"sha": "55a26de0128623e8fb555f9904d52206719fd11f", "filename": "gcc/gengtype.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c8274320fcfdf2ce27d26c017a4d9d9cafa4b1/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c8274320fcfdf2ce27d26c017a4d9d9cafa4b1/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=82c8274320fcfdf2ce27d26c017a4d9d9cafa4b1", "patch": "@@ -650,7 +650,6 @@ adjust_field_tree_exp (type_p t, options_p opt ATTRIBUTE_UNUSED)\n     int first_rtl;\n     int num_rtl;\n   } data[] = {\n-    { \"SAVE_EXPR\", 2, 1 },\n     { \"GOTO_SUBROUTINE_EXPR\", 0, 2 },\n     { \"WITH_CLEANUP_EXPR\", 2, 1 },\n   };"}, {"sha": "efa1c0cd2cd25c49e7cf30da1faac6705ec130c9", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c8274320fcfdf2ce27d26c017a4d9d9cafa4b1/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c8274320fcfdf2ce27d26c017a4d9d9cafa4b1/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=82c8274320fcfdf2ce27d26c017a4d9d9cafa4b1", "patch": "@@ -1,3 +1,7 @@\n+2004-07-02  Richard Henderson  <rth@redhat.com>\n+\n+\t* jcf-write.c (generate_bytecode_insns <case SAVE_EXPR>): Rewrite.\n+\n 2004-07-01  Richard Henderson  <rth@redhat.com>\n \n \t* class.c (registerClass_libfunc): Remove."}, {"sha": "09b39da91a3bfbf5c37a2fb492c5c00dbf6f7dd6", "filename": "gcc/java/jcf-write.c", "status": "modified", "additions": 8, "deletions": 19, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c8274320fcfdf2ce27d26c017a4d9d9cafa4b1/gcc%2Fjava%2Fjcf-write.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c8274320fcfdf2ce27d26c017a4d9d9cafa4b1/gcc%2Fjava%2Fjcf-write.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-write.c?ref=82c8274320fcfdf2ce27d26c017a4d9d9cafa4b1", "patch": "@@ -2197,35 +2197,24 @@ generate_bytecode_insns (tree exp, int target, struct jcf_partial *state)\n       }\n       break;\n     case SAVE_EXPR:\n-      /* Because the state associated with a SAVE_EXPR tree node must\n-\t be a RTL expression, we use it to store the DECL_LOCAL_INDEX\n-\t of a temporary variable in a CONST_INT.  */\n-      if (! SAVE_EXPR_RTL (exp))\n+      /* The first time through, the argument of the SAVE_EXPR will be\n+\t something complex.  Evaluate it, and replace the argument with\n+\t a VAR_DECL that holds the result.  */\n+      arg = TREE_OPERAND (exp, 0);\n+      if (TREE_CODE (arg) != VAR_DECL || DECL_NAME (arg))\n \t{\n \t  tree type = TREE_TYPE (exp);\n \t  tree decl = build_decl (VAR_DECL, NULL_TREE, type);\n-\t  generate_bytecode_insns (TREE_OPERAND (exp, 0),\n-\t\t\t\t   STACK_TARGET, state);\n+\t  generate_bytecode_insns (arg, STACK_TARGET, state);\n \t  localvar_alloc (decl, state);\n-\t  SAVE_EXPR_RTL (exp) = GEN_INT (DECL_LOCAL_INDEX (decl));\n+\t  TREE_OPERAND (exp, 0) = decl;\n \t  emit_dup (TYPE_IS_WIDE (type) ? 2 : 1, 0, state);\n \t  emit_store (decl, state);\n \t}\n       else\n \t{\n-\t  /* The following code avoids creating a temporary DECL just\n-\t     to pass to emit_load.  This code could be factored with\n-\t     the similar implementation in emit_load_or_store.  */\n \t  tree type = TREE_TYPE (exp);\n-\t  int kind = adjust_typed_op (type, 4);\n-\t  int index = (int) INTVAL (SAVE_EXPR_RTL (exp));\n-\t  if (index <= 3)\n-\t    {\n-\t      RESERVE (1);  /* [ilfda]load_[0123]  */\n-\t      OP1 (OPCODE_iload + 5 + 4*kind + index);\n-\t    }\n-\t  else  /* [ilfda]load  */\n-\t    maybe_wide (OPCODE_iload + kind, index, state);\n+\t  emit_load (arg, state);\n \t  NOTE_PUSH (TYPE_IS_WIDE (type) ? 2 : 1);\n \t}\n       break;"}, {"sha": "320879775c3d2422cba38d11ca7fb0cda4494167", "filename": "gcc/print-tree.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c8274320fcfdf2ce27d26c017a4d9d9cafa4b1/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c8274320fcfdf2ce27d26c017a4d9d9cafa4b1/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=82c8274320fcfdf2ce27d26c017a4d9d9cafa4b1", "patch": "@@ -578,8 +578,6 @@ print_node (FILE *file, const char *prefix, tree node, int indent)\n     case 's':\n       if (TREE_CODE (node) == BIT_FIELD_REF && BIT_FIELD_REF_UNSIGNED (node))\n \tfputs (\" unsigned\", file);\n-      else if (TREE_CODE (node) == SAVE_EXPR && SAVE_EXPR_NOPLACEHOLDER (node))\n-\tfputs (\" noplaceholder\", file);\n       if (TREE_CODE (node) == BIND_EXPR)\n \t{\n \t  print_node (file, \"vars\", TREE_OPERAND (node, 0), indent + 4);"}, {"sha": "cf97159b5c5f5ca8386b316eb6eadadb33040914", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c8274320fcfdf2ce27d26c017a4d9d9cafa4b1/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c8274320fcfdf2ce27d26c017a4d9d9cafa4b1/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=82c8274320fcfdf2ce27d26c017a4d9d9cafa4b1", "patch": "@@ -66,7 +66,6 @@ static void place_union_field (record_layout_info, tree);\n static int excess_unit_span (HOST_WIDE_INT, HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t     HOST_WIDE_INT, tree);\n #endif\n-static void force_type_save_exprs_1 (tree);\n extern void debug_rli (record_layout_info);\n \f\n /* SAVE_EXPRs for sizes of types and decls, waiting to be expanded.  */\n@@ -146,8 +145,6 @@ variable_size (tree size)\n      not wish to do that here; the array-size is the same in both\n      places.  */\n   save = skip_simple_arithmetic (size);\n-  if (TREE_CODE (save) == SAVE_EXPR)\n-    SAVE_EXPR_PERSISTENT_P (save) = 1;\n \n   if (cfun && cfun->x_dont_save_pending_sizes_p)\n     /* The front-end doesn't want us to keep a list of the expressions\n@@ -168,60 +165,6 @@ variable_size (tree size)\n \n   return size;\n }\n-\n-/* Given a type T, force elaboration of any SAVE_EXPRs used in the definition\n-   of that type.  */\n-\n-void\n-force_type_save_exprs (tree t)\n-{\n-  tree field;\n-\n-  switch (TREE_CODE (t))\n-    {\n-    case ERROR_MARK:\n-      return;\n-\n-    case ARRAY_TYPE:\n-    case SET_TYPE:\n-    case VECTOR_TYPE:\n-      /* It's probably overly-conservative to force elaboration of bounds and\n-\t also the sizes, but it's better to be safe than sorry.  */\n-      force_type_save_exprs_1 (TYPE_MIN_VALUE (TYPE_DOMAIN (t)));\n-      force_type_save_exprs_1 (TYPE_MAX_VALUE (TYPE_DOMAIN (t)));\n-      break;\n-\n-    case RECORD_TYPE:\n-    case UNION_TYPE:\n-    case QUAL_UNION_TYPE:\n-      for (field = TYPE_FIELDS (t); field; field = TREE_CHAIN (field))\n-\tif (TREE_CODE (field) == FIELD_DECL)\n-\t  {\n-\t    force_type_save_exprs (TREE_TYPE (field));\n-\t    force_type_save_exprs_1 (DECL_FIELD_OFFSET (field));\n-\t  }\n-      break;\n-\n-    default:\n-      break;\n-    }\n-\n-  force_type_save_exprs_1 (TYPE_SIZE (t));\n-  force_type_save_exprs_1 (TYPE_SIZE_UNIT (t));\n-}\n-\n-/* Utility routine of above, to verify that SIZE has been elaborated and\n-   do so it it is a SAVE_EXPR and has not been.  */\n-\n-static void\n-force_type_save_exprs_1 (tree size)\n-{\n-  if (size\n-      && (size = skip_simple_arithmetic (size))\n-      && TREE_CODE (size) == SAVE_EXPR\n-      && !SAVE_EXPR_RTL (size))\n-    expand_expr (size, NULL_RTX, VOIDmode, 0);\n-}\n \f\n #ifndef MAX_FIXED_MODE_SIZE\n #define MAX_FIXED_MODE_SIZE GET_MODE_BITSIZE (DImode)"}, {"sha": "d2d0fd4bab8dd546622d8dde5b7723b9ea4e2f3d", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c8274320fcfdf2ce27d26c017a4d9d9cafa4b1/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c8274320fcfdf2ce27d26c017a4d9d9cafa4b1/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=82c8274320fcfdf2ce27d26c017a4d9d9cafa4b1", "patch": "@@ -528,8 +528,7 @@ copy_body_r (tree *tp, int *walk_subtrees, void *data)\n   else if (TREE_CODE (*tp) == STATEMENT_LIST)\n     copy_statement_list (tp);\n   else if (TREE_CODE (*tp) == SAVE_EXPR)\n-    remap_save_expr (tp, id->decl_map, VARRAY_TREE (id->fns, 0),\n-\t\t     walk_subtrees);\n+    remap_save_expr (tp, id->decl_map, walk_subtrees);\n   else if (TREE_CODE (*tp) == UNSAVE_EXPR)\n     /* UNSAVE_EXPRs should not be generated until expansion time.  */\n     abort ();\n@@ -2318,11 +2317,10 @@ copy_tree_r (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n \n /* The SAVE_EXPR pointed to by TP is being copied.  If ST contains\n    information indicating to what new SAVE_EXPR this one should be mapped,\n-   use that one.  Otherwise, create a new node and enter it in ST.  FN is the\n-   function into which the copy will be placed.  */\n+   use that one.  Otherwise, create a new node and enter it in ST.  */\n \n void\n-remap_save_expr (tree *tp, void *st_, tree fn, int *walk_subtrees)\n+remap_save_expr (tree *tp, void *st_, int *walk_subtrees)\n {\n   splay_tree st = (splay_tree) st_;\n   splay_tree_node n;\n@@ -2336,11 +2334,6 @@ remap_save_expr (tree *tp, void *st_, tree fn, int *walk_subtrees)\n     {\n       t = copy_node (*tp);\n \n-      /* The SAVE_EXPR is now part of the function into which we\n-\t are inlining this body.  */\n-      SAVE_EXPR_CONTEXT (t) = fn;\n-      /* And we haven't evaluated it yet.  */\n-      SAVE_EXPR_RTL (t) = NULL_RTX;\n       /* Remember this SAVE_EXPR.  */\n       splay_tree_insert (st, (splay_tree_key) *tp, (splay_tree_value) t);\n       /* Make sure we don't remap an already-remapped SAVE_EXPR.  */\n@@ -2412,7 +2405,7 @@ unsave_r (tree *tp, int *walk_subtrees, void *data)\n   else if (TREE_CODE (*tp) == BIND_EXPR)\n     copy_bind_expr (tp, walk_subtrees, id);\n   else if (TREE_CODE (*tp) == SAVE_EXPR)\n-    remap_save_expr (tp, st, current_function_decl, walk_subtrees);\n+    remap_save_expr (tp, st, walk_subtrees);\n   else\n     {\n       copy_tree_r (tp, walk_subtrees, NULL);"}, {"sha": "4619e314bef290449e20038ca5424df30017701e", "filename": "gcc/tree-inline.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c8274320fcfdf2ce27d26c017a4d9d9cafa4b1/gcc%2Ftree-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c8274320fcfdf2ce27d26c017a4d9d9cafa4b1/gcc%2Ftree-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.h?ref=82c8274320fcfdf2ce27d26c017a4d9d9cafa4b1", "patch": "@@ -29,7 +29,7 @@ bool tree_inlinable_function_p (tree);\n tree copy_tree_r (tree*, int*, void*);\n void clone_body (tree, tree, void*);\n tree save_body (tree, tree *);\n-void remap_save_expr (tree*, void*, tree, int*);\n+void remap_save_expr (tree*, void*, int*);\n int estimate_num_insns (tree expr);\n \n /* 0 if we should not perform inlining."}, {"sha": "bc6d3aec1ebb5bbb6e5d047a31f81d2947e8f728", "filename": "gcc/tree.c", "status": "modified", "additions": 1, "deletions": 26, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c8274320fcfdf2ce27d26c017a4d9d9cafa4b1/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c8274320fcfdf2ce27d26c017a4d9d9cafa4b1/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=82c8274320fcfdf2ce27d26c017a4d9d9cafa4b1", "patch": "@@ -1375,8 +1375,7 @@ save_expr (tree expr)\n   if (contains_placeholder_p (inner))\n     return t;\n \n-  t = build3 (SAVE_EXPR, TREE_TYPE (expr), t, current_function_decl,\n-\t      NULL_TREE);\n+  t = build1 (SAVE_EXPR, TREE_TYPE (expr), t);\n \n   /* This expression might be placed ahead of a jump to ensure that the\n      value was computed on both sides of the jump.  So make sure it isn't\n@@ -1451,8 +1450,6 @@ first_rtl_op (enum tree_code code)\n {\n   switch (code)\n     {\n-    case SAVE_EXPR:\n-      return 2;\n     case GOTO_SUBROUTINE_EXPR:\n       return 0;\n     case WITH_CLEANUP_EXPR:\n@@ -1511,11 +1508,6 @@ unsave_expr_1 (tree expr)\n {\n   switch (TREE_CODE (expr))\n     {\n-    case SAVE_EXPR:\n-      if (! SAVE_EXPR_PERSISTENT_P (expr))\n-\tSAVE_EXPR_RTL (expr) = 0;\n-      break;\n-\n     case TARGET_EXPR:\n       /* Don't mess with a TARGET_EXPR that hasn't been expanded.\n          It's OK for this to happen if it was part of a subtree that\n@@ -1640,7 +1632,6 @@ bool\n contains_placeholder_p (tree exp)\n {\n   enum tree_code code;\n-  int result;\n \n   if (!exp)\n     return 0;\n@@ -1678,19 +1669,6 @@ contains_placeholder_p (tree exp)\n \t\t  || CONTAINS_PLACEHOLDER_P (TREE_OPERAND (exp, 1))\n \t\t  || CONTAINS_PLACEHOLDER_P (TREE_OPERAND (exp, 2)));\n \n-\tcase SAVE_EXPR:\n-\t  /* If we already know this doesn't have a placeholder, don't\n-\t     check again.  */\n-\t  if (SAVE_EXPR_NOPLACEHOLDER (exp) || SAVE_EXPR_RTL (exp) != 0)\n-\t    return 0;\n-\n-\t  SAVE_EXPR_NOPLACEHOLDER (exp) = 1;\n-\t  result = CONTAINS_PLACEHOLDER_P (TREE_OPERAND (exp, 0));\n-\t  if (result)\n-\t    SAVE_EXPR_NOPLACEHOLDER (exp) = 0;\n-\n-\t  return result;\n-\n \tdefault:\n \t  break;\n \t}\n@@ -4781,9 +4759,6 @@ decl_function_context (tree decl)\n   if (TREE_CODE (decl) == ERROR_MARK)\n     return 0;\n \n-  if (TREE_CODE (decl) == SAVE_EXPR)\n-    context = SAVE_EXPR_CONTEXT (decl);\n-\n   /* C++ virtual functions use DECL_CONTEXT for the class of the vtable\n      where we look up the function at runtime.  Such functions always take\n      a first argument of type 'pointer to real context'."}, {"sha": "bb49981a133873287a31c6c99dd9abfb87cb9291", "filename": "gcc/tree.def", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c8274320fcfdf2ce27d26c017a4d9d9cafa4b1/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c8274320fcfdf2ce27d26c017a4d9d9cafa4b1/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=82c8274320fcfdf2ce27d26c017a4d9d9cafa4b1", "patch": "@@ -723,10 +723,9 @@ DEFTREECODE (NON_LVALUE_EXPR, \"non_lvalue_expr\", '1', 1)\n DEFTREECODE (VIEW_CONVERT_EXPR, \"view_convert_expr\", '1', 1)\n \n /* Represents something we computed once and will use multiple times.\n-   First operand is that expression.  Second is the function decl\n-   in which the SAVE_EXPR was created.  The third operand is the RTL,\n-   nonzero only after the expression has been computed.  */\n-DEFTREECODE (SAVE_EXPR, \"save_expr\", 'e', 3)\n+   First operand is that expression.  After it is evaluated once, it\n+   will be replaced by the temporary variable that holds the value.  */\n+DEFTREECODE (SAVE_EXPR, \"save_expr\", 'e', 1)\n \n /* For a UNSAVE_EXPR, operand 0 is the value to unsave.  By unsave, we\n    mean that all _EXPRs such as TARGET_EXPRs, SAVE_EXPRs, CALL_EXPRs,"}, {"sha": "eff90686c73eed922d7d1861f36beb03bdcff632", "filename": "gcc/tree.h", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82c8274320fcfdf2ce27d26c017a4d9d9cafa4b1/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82c8274320fcfdf2ce27d26c017a4d9d9cafa4b1/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=82c8274320fcfdf2ce27d26c017a4d9d9cafa4b1", "patch": "@@ -282,8 +282,6 @@ struct tree_common GTY(())\n            all decls\n        BIT_FIELD_REF_UNSIGNED in\n            BIT_FIELD_REF\n-       SAVE_EXPR_NOPLACEHOLDER in\n-\t   SAVE_EXPR\n \n    asm_written_flag:\n \n@@ -1030,19 +1028,6 @@ struct tree_vec GTY(())\n \t\t\t\t && VOID_TYPE_P (TREE_TYPE (NODE)) \\\n \t\t\t\t && integer_zerop (TREE_OPERAND (NODE, 0)))\n \n-/* In a SAVE_EXPR node.  */\n-#define SAVE_EXPR_CONTEXT(NODE) TREE_OPERAND_CHECK_CODE (NODE, SAVE_EXPR, 1)\n-#define SAVE_EXPR_RTL(NODE) TREE_RTL_OPERAND_CHECK (NODE, SAVE_EXPR, 2)\n-\n-#define SAVE_EXPR_NOPLACEHOLDER(NODE) \\\n-  (SAVE_EXPR_CHECK (NODE)->common.unsigned_flag)\n-\n-/* Nonzero if the SAVE_EXPRs value should be kept, even if it occurs\n-   both in normal code and in a handler.  (Normally, in a handler, all\n-   SAVE_EXPRs are unsaved, meaning that their values are\n-   recalculated.)  */\n-#define SAVE_EXPR_PERSISTENT_P(NODE) TREE_ASM_WRITTEN (SAVE_EXPR_CHECK (NODE))\n-\n /* In a WITH_CLEANUP_EXPR node.  */\n #define WITH_CLEANUP_EXPR_RTL(NODE) \\\n   TREE_RTL_OPERAND_CHECK (NODE, WITH_CLEANUP_EXPR, 2)\n@@ -3210,11 +3195,6 @@ extern tree substitute_placeholder_in_expr (tree, tree);\n \n extern tree variable_size (tree);\n \n-/* Given a type T, force elaboration of any SAVE_EXPRs used in the definition\n-   of that type.  */\n-\n-extern void force_type_save_exprs (tree);\n-\n /* stabilize_reference (EXP) returns a reference equivalent to EXP\n    but it can be used multiple times\n    and only evaluate the subexpressions once.  */"}]}