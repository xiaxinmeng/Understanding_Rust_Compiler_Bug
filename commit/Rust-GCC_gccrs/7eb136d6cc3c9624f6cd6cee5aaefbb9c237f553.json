{"sha": "7eb136d6cc3c9624f6cd6cee5aaefbb9c237f553", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2ViMTM2ZDZjYzNjOTYyNGY2Y2Q2Y2VlNWFhZWZiYjljMjM3ZjU1Mw==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1997-06-05T20:35:53Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1997-06-05T20:35:53Z"}, "message": "Fix urgent bug\n\nFrom-SVN: r14150", "tree": {"sha": "a0824028e49cab21fc8f6f163e744e8b2fa0d0d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a0824028e49cab21fc8f6f163e744e8b2fa0d0d8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7eb136d6cc3c9624f6cd6cee5aaefbb9c237f553", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7eb136d6cc3c9624f6cd6cee5aaefbb9c237f553", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7eb136d6cc3c9624f6cd6cee5aaefbb9c237f553", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7eb136d6cc3c9624f6cd6cee5aaefbb9c237f553/comments", "author": null, "committer": null, "parents": [{"sha": "cb1009434066d5c1882d4c381cb79409a096ee72", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb1009434066d5c1882d4c381cb79409a096ee72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb1009434066d5c1882d4c381cb79409a096ee72"}], "stats": {"total": 99, "additions": 56, "deletions": 43}, "files": [{"sha": "ce38672d17a3fa9f9480af86c0c1586b66cb8f85", "filename": "gcc/basic-block.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7eb136d6cc3c9624f6cd6cee5aaefbb9c237f553/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7eb136d6cc3c9624f6cd6cee5aaefbb9c237f553/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=7eb136d6cc3c9624f6cd6cee5aaefbb9c237f553", "patch": "@@ -251,8 +251,8 @@ do {\t\t\t\t\t\t\t\t\t\\\n } while (0)\n \n /* Allocate a register set with oballoc.  */\n-#define OBALLOC_REG_SET()\t\t\t\t\t\t\\\n-  ((regset) obstack_alloc (&flow_obstack, regset_bytes))\n+#define OBSTACK_ALLOC_REG_SET(OBSTACK)\t\t\t\t\t\\\n+  ((regset) obstack_alloc (OBSTACK, regset_bytes))\n \n /* Allocate a register set with alloca.  */\n #define ALLOCA_REG_SET() ((regset) alloca (regset_bytes))"}, {"sha": "11d051d32f324b68bfa7d6aa085b696230a43b44", "filename": "gcc/flow.c", "status": "modified", "additions": 37, "deletions": 34, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7eb136d6cc3c9624f6cd6cee5aaefbb9c237f553/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7eb136d6cc3c9624f6cd6cee5aaefbb9c237f553/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=7eb136d6cc3c9624f6cd6cee5aaefbb9c237f553", "patch": "@@ -123,6 +123,13 @@ Boston, MA 02111-1307, USA.  */\n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free free\n \n+/* The contents of the current function definition are allocated\n+   in this obstack, and all are freed at the end of the function.\n+   For top-level functions, this is temporary_obstack.\n+   Separate obstacks are made for nested functions.  */\n+\n+extern struct obstack *function_obstack;\n+\n /* List of labels that must never be deleted.  */\n extern rtx forced_labels;\n \n@@ -246,7 +253,7 @@ static int jmp_uses_reg_or_mem\t\tPROTO((rtx));\n static void mark_label_ref\t\tPROTO((rtx, rtx, int));\n static void life_analysis\t\tPROTO((rtx, int));\n void allocate_for_life_analysis\t\tPROTO((void));\n-static void init_regset_vector\t\tPROTO((regset *, regset, int, int));\n+static void init_regset_vector\t\tPROTO((regset *, int, int, struct obstack *));\n static void propagate_block\t\tPROTO((regset, rtx, rtx, int, \n \t\t\t\t\t       regset, int));\n static rtx flow_delete_insn\t\tPROTO((rtx));\n@@ -260,7 +267,8 @@ static void find_auto_inc\t\tPROTO((regset, rtx, rtx));\n static void mark_used_regs\t\tPROTO((regset, regset, rtx, int, rtx));\n static int try_pre_increment_1\t\tPROTO((rtx));\n static int try_pre_increment\t\tPROTO((rtx, rtx, HOST_WIDE_INT));\n-static rtx find_use_as_address\t\tPROTO((rtx, rtx, HOST_WIDE_INT));\n+/* CYGNUS LOCAL: regmove/amylaar */ /* find_use_as_address non-static */\n+rtx find_use_as_address\t\t\tPROTO((rtx, rtx, HOST_WIDE_INT));\n void dump_flow_info\t\t\tPROTO((FILE *));\n \f\n /* Find basic blocks of the current function and perform data flow analysis.\n@@ -860,7 +868,6 @@ life_analysis (f, nregs)\n      rtx f;\n      int nregs;\n {\n-  register regset tem;\n   int first_pass;\n   int changed;\n   /* For each basic block, a bitmask of regs\n@@ -906,24 +913,18 @@ life_analysis (f, nregs)\n      if there isn't enough space.\n      Don't use oballoc since we may need to allocate other things during\n      this function on the temporary obstack.  */\n-  tem = (regset) obstack_alloc (&flow_obstack, n_basic_blocks * regset_bytes);\n-  bzero ((char *) tem, n_basic_blocks * regset_bytes);\n-  init_regset_vector (basic_block_live_at_end, tem,\n-\t\t      n_basic_blocks, regset_bytes);\n+  init_regset_vector (basic_block_live_at_end, n_basic_blocks, regset_bytes,\n+\t\t      &flow_obstack);\n \n   basic_block_new_live_at_end\n     = (regset *) alloca (n_basic_blocks * sizeof (regset));\n-  tem = (regset) obstack_alloc (&flow_obstack, n_basic_blocks * regset_bytes);\n-  bzero ((char *) tem, n_basic_blocks * regset_bytes);\n-  init_regset_vector (basic_block_new_live_at_end, tem,\n-\t\t      n_basic_blocks, regset_bytes);\n+  init_regset_vector (basic_block_new_live_at_end, n_basic_blocks, regset_bytes,\n+\t\t      &flow_obstack);\n \n   basic_block_significant\n     = (regset *) alloca (n_basic_blocks * sizeof (regset));\n-  tem = (regset) obstack_alloc (&flow_obstack, n_basic_blocks * regset_bytes);\n-  bzero ((char *) tem, n_basic_blocks * regset_bytes);\n-  init_regset_vector (basic_block_significant, tem,\n-\t\t      n_basic_blocks, regset_bytes);\n+  init_regset_vector (basic_block_significant, n_basic_blocks, regset_bytes,\n+\t\t      &flow_obstack);\n \n   /* Record which insns refer to any volatile memory\n      or for any reason can't be deleted just because they are dead stores.\n@@ -1259,7 +1260,6 @@ void\n allocate_for_life_analysis ()\n {\n   register int i;\n-  register regset tem;\n \n   regset_size = ((max_regno + REGSET_ELT_BITS - 1) / REGSET_ELT_BITS);\n   regset_bytes = regset_size * sizeof (*(regset) 0);\n@@ -1275,13 +1275,11 @@ allocate_for_life_analysis ()\n \n   basic_block_live_at_start\n     = (regset *) oballoc (n_basic_blocks * sizeof (regset));\n-  tem = (regset) oballoc (n_basic_blocks * regset_bytes);\n-  bzero ((char *) tem, n_basic_blocks * regset_bytes);\n-  init_regset_vector (basic_block_live_at_start, tem,\n-\t\t      n_basic_blocks, regset_bytes);\n+  init_regset_vector (basic_block_live_at_start, n_basic_blocks, regset_bytes,\n+\t\t      function_obstack);\n \n-  regs_live_at_setjmp = (regset) oballoc (regset_bytes);\n-  bzero ((char *) regs_live_at_setjmp, regset_bytes);\n+  regs_live_at_setjmp = OBSTACK_ALLOC_REG_SET (function_obstack);\n+  CLEAR_REG_SET (regs_live_at_setjmp);\n }\n \n /* Make each element of VECTOR point at a regset,\n@@ -1290,19 +1288,18 @@ allocate_for_life_analysis ()\n    BYTES_PER_ELT is the number of bytes in one regset.  */\n \n static void\n-init_regset_vector (vector, space, nelts, bytes_per_elt)\n+init_regset_vector (vector, nelts, bytes_per_elt, alloc_obstack)\n      regset *vector;\n-     regset space;\n      int nelts;\n      int bytes_per_elt;\n+     struct obstack *alloc_obstack;\n {\n   register int i;\n-  register regset p = space;\n \n   for (i = 0; i < nelts; i++)\n     {\n-      vector[i] = p;\n-      p += bytes_per_elt / sizeof (*p);\n+      vector[i] = OBSTACK_ALLOC_REG_SET (alloc_obstack);\n+      CLEAR_REG_SET (vector[i]);\n     }\n }\n \n@@ -1354,8 +1351,8 @@ propagate_block (old, first, last, final, significant, bnum)\n      current basic block, and adjust as we pass ends and starts of loops.  */\n   loop_depth = basic_block_loop_depth[bnum];\n \n-  dead = (regset) alloca (regset_bytes);\n-  live = (regset) alloca (regset_bytes);\n+  dead = ALLOCA_REG_SET ();\n+  live = ALLOCA_REG_SET ();\n \n   cc0_live = 0;\n   last_mem_set = 0;\n@@ -1378,7 +1375,7 @@ propagate_block (old, first, last, final, significant, bnum)\n       register int i;\n \n       num_scratch = 0;\n-      maxlive = (regset) alloca (regset_bytes);\n+      maxlive = ALLOCA_REG_SET ();\n       COPY_REG_SET (maxlive, old);\n       regs_sometimes_live = (int *) alloca (max_regno * sizeof (int));\n \n@@ -2300,9 +2297,15 @@ mark_used_regs (needed, live, x, final, insn)\n       return;\n \n     case MEM:\n-      /* Invalidate the data for the last MEM stored.  We could do this only\n-\t if the addresses conflict, but this doesn't seem worthwhile.  */\n-      last_mem_set = 0;\n+      /* CYGNUS LOCAL dje/8176 */\n+      /* Invalidate the data for the last MEM stored, but only if MEM is\n+\t something that can be stored into.  */\n+      if (GET_CODE (XEXP (x, 0)) == SYMBOL_REF\n+\t  && CONSTANT_POOL_ADDRESS_P (XEXP (x, 0)))\n+\t; /* needn't clear last_mem_set */\n+      else\n+\tlast_mem_set = 0;\n+      /* END CYGNUS LOCAL */\n \n #ifdef AUTO_INC_DEC\n       if (final)\n@@ -2732,7 +2735,7 @@ try_pre_increment (insn, reg, amount)\n    If REG appears more than once, or is used other than in such an address,\n    return (rtx)1.  */\n \n-static rtx\n+rtx /* CYGNUS LOCAL: regmove/amylaar */ /* find_use_as_address non-static */\n find_use_as_address (x, reg, plusconst)\n      register rtx x;\n      rtx reg;"}, {"sha": "8d2c2a68b3c98d914db6c597f3ae683e7b6e8947", "filename": "gcc/reorg.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7eb136d6cc3c9624f6cd6cee5aaefbb9c237f553/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7eb136d6cc3c9624f6cd6cee5aaefbb9c237f553/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=7eb136d6cc3c9624f6cd6cee5aaefbb9c237f553", "patch": "@@ -1350,6 +1350,15 @@ mostly_true_jump (jump_insn, condition)\n   int rare_dest = rare_destination (target_label);\n   int rare_fallthrough = rare_destination (NEXT_INSN (jump_insn));\n \n+  /* CYGNUS LOCAL -- branch prediction */\n+  int expected = condjump_expect_p (jump_insn);\n+\n+  if (expected > 0)\n+    return 2;\n+  else if (expected < 0)\n+    return -1;\n+  /* END CYGNUS LOCAL -- branch prediction */\n+\n   /* If branch probabilities are available, then use that number since it\n      always gives a correct answer.  */\n   if (flag_branch_probabilities)"}, {"sha": "78f9b21d384486d0ea26ad45f90b461c27b03ac0", "filename": "gcc/sched.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7eb136d6cc3c9624f6cd6cee5aaefbb9c237f553/gcc%2Fsched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7eb136d6cc3c9624f6cd6cee5aaefbb9c237f553/gcc%2Fsched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched.c?ref=7eb136d6cc3c9624f6cd6cee5aaefbb9c237f553", "patch": "@@ -3857,12 +3857,13 @@ schedule_block (b, file)\n \t      attach_deaths_insn (insn);\n \n \t      /* Find registers now made live by that instruction.  */\n-\t      EXECUTE_IF_SET_IN_REG_SET (bb_live_regs, 0, i,\n-\t\t\t\t\t {\n-\t\t\t\t\t   sometimes_max\n-\t\t\t\t\t     = new_sometimes_live (regs_sometimes_live,\n-\t\t\t\t\t\t\t\t   i, sometimes_max);\n-\t\t\t\t\t });\n+\t      EXECUTE_IF_AND_COMPL_IN_REG_SET (bb_live_regs, old_live_regs, 0, i,\n+\t\t\t\t\t       {\n+\t\t\t\t\t\t sometimes_max\n+\t\t\t\t\t\t   = new_sometimes_live (regs_sometimes_live,\n+\t\t\t\t\t\t\t\t\t i, sometimes_max);\n+\t\t\t\t\t       });\n+\t      IOR_REG_SET (old_live_regs, bb_live_regs);\n \n \t      /* Count lengths of all regs we are worrying about now,\n \t\t and handle registers no longer live.  */\n@@ -3874,7 +3875,7 @@ schedule_block (b, file)\n \n \t\t  p->live_length += 1;\n \n-\t\t  if (REGNO_REG_SET_P (bb_live_regs, p->regno))\n+\t\t  if (!REGNO_REG_SET_P (bb_live_regs, p->regno))\n \t\t    {\n \t\t      /* This is the end of one of this register's lifetime\n \t\t\t segments.  Save the lifetime info collected so far,"}]}