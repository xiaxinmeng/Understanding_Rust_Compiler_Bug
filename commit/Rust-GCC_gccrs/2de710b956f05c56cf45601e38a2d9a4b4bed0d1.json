{"sha": "2de710b956f05c56cf45601e38a2d9a4b4bed0d1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmRlNzEwYjk1NmYwNWM1NmNmNDU2MDFlMzhhMmQ5YTRiNGJlZDBkMQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2010-07-08T12:27:01Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2010-07-08T12:27:01Z"}, "message": "cygming.h (STACK_CHECK_STATIC_BUILTIN): Define to 1.\n\n\t* config/i386/cygming.h (STACK_CHECK_STATIC_BUILTIN): Define to 1.\n\t* config/i386/freebsd.h (STACK_CHECK_STATIC_BUILTIN): Likewise.\n\t* config/i386/linux.h (STACK_CHECK_STATIC_BUILTIN): Likewise.\n\t* config/i386/linux64.h (STACK_CHECK_STATIC_BUILTIN): Likewise.\n\t* config/i386/sol2.h (STACK_CHECK_STATIC_BUILTIN): Likewise.\n\t* config/i386/i386.c (ix86_gen_adjust_stack_and_probe): New variable.\n\t(ix86_gen_probe_stack_range): Likewise.\n\t(override_options): Set them.\n\t(ix86_target_stack_probe): New function.\n\t(ix86_compute_frame_layout): Force use of push instructions to\n\tsave registers if stack checking with probes is enabled.\n\t(get_scratch_register_on_entry): New function.\n\t(release_scratch_register_on_entry): Likewise.\n\t(ix86_adjust_stack_and_probe): Likewise.\n\t(output_adjust_stack_and_probe): Likewise.\n\t(ix86_emit_probe_stack_range): Likewise.\n\t(output_probe_stack_range): Likewise.\n\t(ix86_expand_prologue): Emit stack checking code if static built-in\n\tstack checking is enabled.\n\tTest ix86_target_stack_probe instead of TARGET_STACK_PROBE.\n\t* config/i386/i386-protos.h (ix86_target_stack_probe): Declare.\n\t(output_adjust_stack_and_probe): Likewise.\n\t(output_probe_stack_range): Likewise.\n\t* config/i386/i386.md (UNSPECV_PROBE_STACK_RANGE): New constant.\n\t(allocate_stack_worker_32): Test ix86_target_stack_probe instead of\n\tTARGET_STACK_PROBE.\n\t(allocate_stack_worker_64): Likewise.\n\t(allocate_stack): Likewise.\n\t(adjust_stack_and_probe): New insn.\n\t(probe_stack_range): Likewise.\n\nFrom-SVN: r161952", "tree": {"sha": "ca5b252d0f945589fbef65bd7cd88cbe03b560bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ca5b252d0f945589fbef65bd7cd88cbe03b560bb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2de710b956f05c56cf45601e38a2d9a4b4bed0d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2de710b956f05c56cf45601e38a2d9a4b4bed0d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2de710b956f05c56cf45601e38a2d9a4b4bed0d1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2de710b956f05c56cf45601e38a2d9a4b4bed0d1/comments", "author": null, "committer": null, "parents": [{"sha": "f076debaba31c16b9a2f06394a43e38025a3a390", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f076debaba31c16b9a2f06394a43e38025a3a390", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f076debaba31c16b9a2f06394a43e38025a3a390"}], "stats": {"total": 504, "additions": 500, "deletions": 4}, "files": [{"sha": "5172c45b8e3729a07ec5c91793935a67c07ea6b6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2de710b956f05c56cf45601e38a2d9a4b4bed0d1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2de710b956f05c56cf45601e38a2d9a4b4bed0d1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2de710b956f05c56cf45601e38a2d9a4b4bed0d1", "patch": "@@ -1,3 +1,36 @@\n+2010-07-08  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* config/i386/cygming.h (STACK_CHECK_STATIC_BUILTIN): Define to 1.\n+\t* config/i386/freebsd.h (STACK_CHECK_STATIC_BUILTIN): Likewise.\n+\t* config/i386/linux.h (STACK_CHECK_STATIC_BUILTIN): Likewise.\n+\t* config/i386/linux64.h (STACK_CHECK_STATIC_BUILTIN): Likewise.\n+\t* config/i386/sol2.h (STACK_CHECK_STATIC_BUILTIN): Likewise.\n+\t* config/i386/i386.c (ix86_gen_adjust_stack_and_probe): New variable.\n+\t(ix86_gen_probe_stack_range): Likewise.\n+\t(override_options): Set them.\n+\t(ix86_target_stack_probe): New function.\n+\t(ix86_compute_frame_layout): Force use of push instructions to\n+\tsave registers if stack checking with probes is enabled.\n+\t(get_scratch_register_on_entry): New function.\n+\t(release_scratch_register_on_entry): Likewise.\n+\t(ix86_adjust_stack_and_probe): Likewise.\n+\t(output_adjust_stack_and_probe): Likewise.\n+\t(ix86_emit_probe_stack_range): Likewise.\n+\t(output_probe_stack_range): Likewise.\n+\t(ix86_expand_prologue): Emit stack checking code if static built-in\n+\tstack checking is enabled.\n+\tTest ix86_target_stack_probe instead of TARGET_STACK_PROBE.\n+\t* config/i386/i386-protos.h (ix86_target_stack_probe): Declare.\n+\t(output_adjust_stack_and_probe): Likewise.\n+\t(output_probe_stack_range): Likewise.\n+\t* config/i386/i386.md (UNSPECV_PROBE_STACK_RANGE): New constant.\n+\t(allocate_stack_worker_32): Test ix86_target_stack_probe instead of\n+\tTARGET_STACK_PROBE.\n+\t(allocate_stack_worker_64): Likewise.\n+\t(allocate_stack): Likewise.\n+\t(adjust_stack_and_probe): New insn.\n+\t(probe_stack_range): Likewise.\n+\n 2010-07-08  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/44831"}, {"sha": "470637644ff4f1404678725ca1219b2e93439f01", "filename": "gcc/config/i386/cygming.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2de710b956f05c56cf45601e38a2d9a4b4bed0d1/gcc%2Fconfig%2Fi386%2Fcygming.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2de710b956f05c56cf45601e38a2d9a4b4bed0d1/gcc%2Fconfig%2Fi386%2Fcygming.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fcygming.h?ref=2de710b956f05c56cf45601e38a2d9a4b4bed0d1", "patch": "@@ -429,6 +429,9 @@ do {\t\t\t\t\t\t\\\n #define TARGET_CXX_ADJUST_CLASS_AT_DEFINITION i386_pe_adjust_class_at_definition\n #define TARGET_MANGLE_DECL_ASSEMBLER_NAME i386_pe_mangle_decl_assembler_name\n \n+/* Static stack checking is supported by means of probes.  */\n+#define STACK_CHECK_STATIC_BUILTIN 1\n+\n #undef TREE\n \n #ifndef BUFSIZ"}, {"sha": "c616a205d2c34f9a8ef3519ddf85f4fb080895b3", "filename": "gcc/config/i386/freebsd.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2de710b956f05c56cf45601e38a2d9a4b4bed0d1/gcc%2Fconfig%2Fi386%2Ffreebsd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2de710b956f05c56cf45601e38a2d9a4b4bed0d1/gcc%2Fconfig%2Fi386%2Ffreebsd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Ffreebsd.h?ref=2de710b956f05c56cf45601e38a2d9a4b4bed0d1", "patch": "@@ -138,3 +138,6 @@ along with GCC; see the file COPYING3.  If not see\n    compiler get the contents of <float.h> and std::numeric_limits correct.  */\n #undef TARGET_96_ROUND_53_LONG_DOUBLE\n #define TARGET_96_ROUND_53_LONG_DOUBLE (!TARGET_64BIT)\n+\n+/* Static stack checking is supported by means of probes.  */\n+#define STACK_CHECK_STATIC_BUILTIN 1"}, {"sha": "696bb4a6cdab215e95e1f625dd7ebdd285d2995f", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2de710b956f05c56cf45601e38a2d9a4b4bed0d1/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2de710b956f05c56cf45601e38a2d9a4b4bed0d1/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=2de710b956f05c56cf45601e38a2d9a4b4bed0d1", "patch": "@@ -24,6 +24,7 @@ extern void override_options (bool);\n extern void optimization_options (int, int);\n extern void ix86_conditional_register_usage (void);\n \n+extern bool ix86_target_stack_probe (void);\n extern int ix86_can_use_return_insn_p (void);\n extern void ix86_setup_frame_addresses (void);\n \n@@ -71,6 +72,8 @@ extern const char *output_387_binary_op (rtx, rtx*);\n extern const char *output_387_reg_move (rtx, rtx*);\n extern const char *output_fix_trunc (rtx, rtx*, int);\n extern const char *output_fp_compare (rtx, rtx*, int, int);\n+extern const char *output_adjust_stack_and_probe (rtx);\n+extern const char *output_probe_stack_range (rtx, rtx);\n \n extern void ix86_expand_clear (rtx);\n extern void ix86_expand_move (enum machine_mode, rtx[]);"}, {"sha": "52abbdd8bdea7e12f3a8d8d485f03780325a50c9", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 423, "deletions": 1, "changes": 424, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2de710b956f05c56cf45601e38a2d9a4b4bed0d1/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2de710b956f05c56cf45601e38a2d9a4b4bed0d1/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=2de710b956f05c56cf45601e38a2d9a4b4bed0d1", "patch": "@@ -1908,6 +1908,8 @@ static rtx (*ix86_gen_one_cmpl2) (rtx, rtx);\n static rtx (*ix86_gen_monitor) (rtx, rtx, rtx);\n static rtx (*ix86_gen_andsp) (rtx, rtx, rtx);\n static rtx (*ix86_gen_allocate_stack_worker) (rtx, rtx);\n+static rtx (*ix86_gen_adjust_stack_and_probe) (rtx, rtx, rtx);\n+static rtx (*ix86_gen_probe_stack_range) (rtx, rtx, rtx);\n \n /* Preferred alignment for stack boundary in bits.  */\n unsigned int ix86_preferred_stack_boundary;\n@@ -3643,6 +3645,8 @@ override_options (bool main_args_p)\n       ix86_gen_monitor = gen_sse3_monitor64;\n       ix86_gen_andsp = gen_anddi3;\n       ix86_gen_allocate_stack_worker = gen_allocate_stack_worker_64;\n+      ix86_gen_adjust_stack_and_probe = gen_adjust_stack_and_probedi;\n+      ix86_gen_probe_stack_range = gen_probe_stack_rangedi;\n     }\n   else\n     {\n@@ -3655,6 +3659,8 @@ override_options (bool main_args_p)\n       ix86_gen_monitor = gen_sse3_monitor;\n       ix86_gen_andsp = gen_andsi3;\n       ix86_gen_allocate_stack_worker = gen_allocate_stack_worker_32;\n+      ix86_gen_adjust_stack_and_probe = gen_adjust_stack_and_probesi;\n+      ix86_gen_probe_stack_range = gen_probe_stack_rangesi;\n     }\n \n #ifdef USE_IX86_CLD\n@@ -4514,6 +4520,20 @@ optimization_options (int level, int size ATTRIBUTE_UNUSED)\n   SUBTARGET_OPTIMIZATION_OPTIONS;\n #endif\n }\n+\n+/* Decide whether we must probe the stack before any space allocation\n+   on this target.  It's essentially TARGET_STACK_PROBE except when\n+   -fstack-check causes the stack to be already probed differently.  */\n+\n+bool\n+ix86_target_stack_probe (void)\n+{\n+  /* Do not probe the stack twice if static stack checking is enabled.  */\n+  if (flag_stack_check == STATIC_BUILTIN_STACK_CHECK)\n+    return false;\n+\n+  return TARGET_STACK_PROBE;\n+}\n \f\n /* Decide whether we can make a sibling call to a function.  DECL is the\n    declaration of the function being targeted by the call and EXP is the\n@@ -8299,6 +8319,11 @@ ix86_compute_frame_layout (struct ix86_frame *frame)\n   else\n     frame->save_regs_using_mov = false;\n \n+  /* If static stack checking is enabled and done with probes, the registers\n+     need to be saved before allocating the frame.  */\n+  if (flag_stack_check == STATIC_BUILTIN_STACK_CHECK)\n+    frame->save_regs_using_mov = false;\n+\n   /* Skip return address.  */\n   offset = UNITS_PER_WORD;\n \n@@ -8708,6 +8733,377 @@ ix86_internal_arg_pointer (void)\n   return virtual_incoming_args_rtx;\n }\n \n+struct scratch_reg {\n+  rtx reg;\n+  bool saved;\n+};\n+\n+/* Return a short-lived scratch register for use on function entry.\n+   In 32-bit mode, it is valid only after the registers are saved\n+   in the prologue.  This register must be released by means of\n+   release_scratch_register_on_entry once it is dead.  */\n+\n+static void\n+get_scratch_register_on_entry (struct scratch_reg *sr)\n+{\n+  int regno;\n+\n+  sr->saved = false;\n+\n+  if (TARGET_64BIT)\n+    {\n+      /* We always use R11 in 64-bit mode.  */\n+      regno = R11_REG;\n+    }\n+  else\n+    {\n+      tree decl = current_function_decl, fntype = TREE_TYPE (decl);\n+      bool fastcall_p\n+\t= lookup_attribute (\"fastcall\", TYPE_ATTRIBUTES (fntype)) != NULL_TREE;\n+      bool static_chain_p = DECL_STATIC_CHAIN (decl);\n+      int regparm = ix86_function_regparm (fntype, decl);\n+      int drap_regno\n+\t= crtl->drap_reg ? REGNO (crtl->drap_reg) : INVALID_REGNUM;\n+\n+      /* 'fastcall' sets regparm to 2, uses ecx/edx for arguments and eax\n+\t  for the static chain register.  */\n+      if ((regparm < 1 || (fastcall_p && !static_chain_p))\n+\t  && drap_regno != AX_REG)\n+\tregno = AX_REG;\n+      else if (regparm < 2 && drap_regno != DX_REG)\n+\tregno = DX_REG;\n+      /* ecx is the static chain register.  */\n+      else if (regparm < 3 && !fastcall_p && !static_chain_p\n+\t       && drap_regno != CX_REG)\n+\tregno = CX_REG;\n+      else if (ix86_save_reg (BX_REG, true))\n+\tregno = BX_REG;\n+      /* esi is the static chain register.  */\n+      else if (!(regparm == 3 && static_chain_p)\n+\t       && ix86_save_reg (SI_REG, true))\n+\tregno = SI_REG;\n+      else if (ix86_save_reg (DI_REG, true))\n+\tregno = DI_REG;\n+      else\n+\t{\n+\t  regno = (drap_regno == AX_REG ? DX_REG : AX_REG);\n+\t  sr->saved = true;\n+\t}\n+    }\n+\n+  sr->reg = gen_rtx_REG (Pmode, regno);\n+  if (sr->saved)\n+    {\n+      rtx insn = emit_insn (gen_push (sr->reg));\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+    }\n+}\n+\n+/* Release a scratch register obtained from the preceding function.  */\n+\n+static void\n+release_scratch_register_on_entry (struct scratch_reg *sr)\n+{\n+  if (sr->saved)\n+    {\n+      rtx x, insn = emit_insn (ix86_gen_pop1 (sr->reg));\n+\n+      /* The RTX_FRAME_RELATED_P mechanism doesn't know about pop.  */\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+      x = gen_rtx_PLUS (Pmode, stack_pointer_rtx, GEN_INT (UNITS_PER_WORD));\n+      x = gen_rtx_SET (VOIDmode, stack_pointer_rtx, x);\n+      add_reg_note (insn, REG_FRAME_RELATED_EXPR, x);\n+    }\n+}\n+\n+#define PROBE_INTERVAL (1 << STACK_CHECK_PROBE_INTERVAL_EXP)\n+\n+/* Emit code to adjust the stack pointer by SIZE bytes while probing it.  */\n+\n+static void\n+ix86_adjust_stack_and_probe (HOST_WIDE_INT size)\n+{\n+  /* We skip the probe for the first interval + a small dope of 4 words and\n+     probe that many bytes past the specified size to maintain a protection\n+     area at the botton of the stack.  */\n+  const int dope = 4 * UNITS_PER_WORD;\n+  rtx size_rtx = GEN_INT (size);\n+\n+  /* See if we have a constant small number of probes to generate.  If so,\n+     that's the easy case.  The run-time loop is made up of 11 insns in the\n+     generic case while the compile-time loop is made up of 3+2*(n-1) insns\n+     for n # of intervals.  */\n+  if (size <= 5 * PROBE_INTERVAL)\n+    {\n+      HOST_WIDE_INT i, adjust;\n+      bool first_probe = true;\n+\n+      /* Adjust SP and probe at PROBE_INTERVAL + N * PROBE_INTERVAL for\n+\t values of N from 1 until it exceeds SIZE.  If only one probe is\n+\t needed, this will not generate any code.  Then adjust and probe\n+\t to PROBE_INTERVAL + SIZE.  */\n+      for (i = PROBE_INTERVAL; i < size; i += PROBE_INTERVAL)\n+\t{\n+\t  if (first_probe)\n+\t    {\n+\t      adjust = 2 * PROBE_INTERVAL + dope;\n+\t      first_probe = false;\n+\t    }\n+\t  else\n+\t    adjust = PROBE_INTERVAL;\n+\n+\t  emit_insn (gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n+\t\t\t\t  plus_constant (stack_pointer_rtx, -adjust)));\n+\t  emit_stack_probe (stack_pointer_rtx);\n+\t}\n+\n+      if (first_probe)\n+\tadjust = size + PROBE_INTERVAL + dope;\n+      else\n+        adjust = size + PROBE_INTERVAL - i;\n+\n+      emit_insn (gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n+\t\t\t      plus_constant (stack_pointer_rtx, -adjust)));\n+      emit_stack_probe (stack_pointer_rtx);\n+\n+      /* Adjust back to account for the additional first interval.  */\n+      emit_insn (gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n+\t\t\t      plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t     PROBE_INTERVAL + dope)));\n+    }\n+\n+  /* Otherwise, do the same as above, but in a loop.  Note that we must be\n+     extra careful with variables wrapping around because we might be at\n+     the very top (or the very bottom) of the address space and we have\n+     to be able to handle this case properly; in particular, we use an\n+     equality test for the loop condition.  */\n+  else\n+    {\n+      HOST_WIDE_INT rounded_size;\n+      struct scratch_reg sr;\n+\n+      get_scratch_register_on_entry (&sr);\n+\n+\n+      /* Step 1: round SIZE to the previous multiple of the interval.  */\n+\n+      rounded_size = size & -PROBE_INTERVAL;\n+\n+\n+      /* Step 2: compute initial and final value of the loop counter.  */\n+\n+      /* SP = SP_0 + PROBE_INTERVAL.  */\n+      emit_insn (gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n+\t\t\t      plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t     - (PROBE_INTERVAL + dope))));\n+\n+      /* LAST_ADDR = SP_0 + PROBE_INTERVAL + ROUNDED_SIZE.  */\n+      emit_move_insn (sr.reg, GEN_INT (-rounded_size));\n+      emit_insn (gen_rtx_SET (VOIDmode, sr.reg,\n+\t\t\t      gen_rtx_PLUS (Pmode, sr.reg,\n+\t\t\t\t\t    stack_pointer_rtx)));\n+\n+\n+      /* Step 3: the loop\n+\n+\t while (SP != LAST_ADDR)\n+\t   {\n+\t     SP = SP + PROBE_INTERVAL\n+\t     probe at SP\n+\t   }\n+\n+\t adjusts SP and probes to PROBE_INTERVAL + N * PROBE_INTERVAL for\n+\t values of N from 1 until it is equal to ROUNDED_SIZE.  */\n+\n+      emit_insn (ix86_gen_adjust_stack_and_probe (sr.reg, sr.reg, size_rtx));\n+\n+\n+      /* Step 4: adjust SP and probe at PROBE_INTERVAL + SIZE if we cannot\n+\t assert at compile-time that SIZE is equal to ROUNDED_SIZE.  */\n+\n+      if (size != rounded_size)\n+\t{\n+\t  emit_insn (gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n+\t\t\t          plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t\t rounded_size - size)));\n+\t  emit_stack_probe (stack_pointer_rtx);\n+\t}\n+\n+      /* Adjust back to account for the additional first interval.  */\n+      emit_insn (gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n+\t\t\t      plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t     PROBE_INTERVAL + dope)));\n+\n+      release_scratch_register_on_entry (&sr);\n+    }\n+\n+  gcc_assert (ix86_cfa_state->reg != stack_pointer_rtx);\n+\n+  /* Make sure nothing is scheduled before we are done.  */\n+  emit_insn (gen_blockage ());\n+}\n+\n+/* Adjust the stack pointer up to REG while probing it.  */\n+\n+const char *\n+output_adjust_stack_and_probe (rtx reg)\n+{\n+  static int labelno = 0;\n+  char loop_lab[32], end_lab[32];\n+  rtx xops[2];\n+\n+  ASM_GENERATE_INTERNAL_LABEL (loop_lab, \"LPSRL\", labelno);\n+  ASM_GENERATE_INTERNAL_LABEL (end_lab, \"LPSRE\", labelno++);\n+\n+  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, loop_lab);\n+\n+  /* Jump to END_LAB if SP == LAST_ADDR.  */\n+  xops[0] = stack_pointer_rtx;\n+  xops[1] = reg;\n+  output_asm_insn (\"cmp%z0\\t{%1, %0|%0, %1}\", xops);\n+  fputs (\"\\tje\\t\", asm_out_file);\n+  assemble_name_raw (asm_out_file, end_lab);\n+  fputc ('\\n', asm_out_file);\n+\n+  /* SP = SP + PROBE_INTERVAL.  */\n+  xops[1] = GEN_INT (PROBE_INTERVAL);\n+  output_asm_insn (\"sub%z0\\t{%1, %0|%0, %1}\", xops);\n+\n+  /* Probe at SP.  */\n+  xops[1] = const0_rtx;\n+  output_asm_insn (\"or%z0\\t{%1, (%0)|DWORD PTR [%0], %1}\", xops);\n+\n+  fprintf (asm_out_file, \"\\tjmp\\t\");\n+  assemble_name_raw (asm_out_file, loop_lab);\n+  fputc ('\\n', asm_out_file);\n+\n+  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, end_lab);\n+\n+  return \"\";\n+}\n+\n+/* Emit code to probe a range of stack addresses from FIRST to FIRST+SIZE,\n+   inclusive.  These are offsets from the current stack pointer.  */\n+\n+static void\n+ix86_emit_probe_stack_range (HOST_WIDE_INT first, HOST_WIDE_INT size)\n+{\n+  /* See if we have a constant small number of probes to generate.  If so,\n+     that's the easy case.  The run-time loop is made up of 7 insns in the\n+     generic case while the compile-time loop is made up of n insns for n #\n+     of intervals.  */\n+  if (size <= 7 * PROBE_INTERVAL)\n+    {\n+      HOST_WIDE_INT i;\n+\n+      /* Probe at FIRST + N * PROBE_INTERVAL for values of N from 1 until\n+\t it exceeds SIZE.  If only one probe is needed, this will not\n+\t generate any code.  Then probe at FIRST + SIZE.  */\n+      for (i = PROBE_INTERVAL; i < size; i += PROBE_INTERVAL)\n+\temit_stack_probe (plus_constant (stack_pointer_rtx, -(first + i)));\n+\n+      emit_stack_probe (plus_constant (stack_pointer_rtx, -(first + size)));\n+    }\n+\n+  /* Otherwise, do the same as above, but in a loop.  Note that we must be\n+     extra careful with variables wrapping around because we might be at\n+     the very top (or the very bottom) of the address space and we have\n+     to be able to handle this case properly; in particular, we use an\n+     equality test for the loop condition.  */\n+  else\n+    {\n+      HOST_WIDE_INT rounded_size, last;\n+      struct scratch_reg sr;\n+\n+      get_scratch_register_on_entry (&sr);\n+\n+\n+      /* Step 1: round SIZE to the previous multiple of the interval.  */\n+\n+      rounded_size = size & -PROBE_INTERVAL;\n+\n+\n+      /* Step 2: compute initial and final value of the loop counter.  */\n+\n+      /* TEST_OFFSET = FIRST.  */\n+      emit_move_insn (sr.reg, GEN_INT (-first));\n+\n+      /* LAST_OFFSET = FIRST + ROUNDED_SIZE.  */\n+      last = first + rounded_size;\n+\n+\n+      /* Step 3: the loop\n+\n+\t while (TEST_ADDR != LAST_ADDR)\n+\t   {\n+\t     TEST_ADDR = TEST_ADDR + PROBE_INTERVAL\n+\t     probe at TEST_ADDR\n+\t   }\n+\n+         probes at FIRST + N * PROBE_INTERVAL for values of N from 1\n+         until it is equal to ROUNDED_SIZE.  */\n+\n+      emit_insn (ix86_gen_probe_stack_range (sr.reg, sr.reg, GEN_INT (-last)));\n+\n+\n+      /* Step 4: probe at FIRST + SIZE if we cannot assert at compile-time\n+\t that SIZE is equal to ROUNDED_SIZE.  */\n+\n+      if (size != rounded_size)\n+\temit_stack_probe (plus_constant (gen_rtx_PLUS (Pmode,\n+\t\t\t\t\t\t       stack_pointer_rtx,\n+\t\t\t\t\t\t       sr.reg),\n+\t\t\t\t\t rounded_size - size));\n+\n+      release_scratch_register_on_entry (&sr);\n+    }\n+\n+  /* Make sure nothing is scheduled before we are done.  */\n+  emit_insn (gen_blockage ());\n+}\n+\n+/* Probe a range of stack addresses from REG to END, inclusive.  These are\n+   offsets from the current stack pointer.  */\n+\n+const char *\n+output_probe_stack_range (rtx reg, rtx end)\n+{\n+  static int labelno = 0;\n+  char loop_lab[32], end_lab[32];\n+  rtx xops[3];\n+\n+  ASM_GENERATE_INTERNAL_LABEL (loop_lab, \"LPSRL\", labelno);\n+  ASM_GENERATE_INTERNAL_LABEL (end_lab, \"LPSRE\", labelno++);\n+\n+  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, loop_lab);\n+\n+  /* Jump to END_LAB if TEST_ADDR == LAST_ADDR.  */\n+  xops[0] = reg;\n+  xops[1] = end;\n+  output_asm_insn (\"cmp%z0\\t{%1, %0|%0, %1}\", xops);\n+  fputs (\"\\tje\\t\", asm_out_file);\n+  assemble_name_raw (asm_out_file, end_lab);\n+  fputc ('\\n', asm_out_file);\n+\n+  /* TEST_ADDR = TEST_ADDR + PROBE_INTERVAL.  */\n+  xops[1] = GEN_INT (PROBE_INTERVAL);\n+  output_asm_insn (\"sub%z0\\t{%1, %0|%0, %1}\", xops);\n+\n+  /* Probe at TEST_ADDR.  */\n+  xops[0] = stack_pointer_rtx;\n+  xops[1] = reg;\n+  xops[2] = const0_rtx;\n+  output_asm_insn (\"or%z0\\t{%2, (%0,%1)|DWORD PTR [%0+%1], %2}\", xops);\n+\n+  fprintf (asm_out_file, \"\\tjmp\\t\");\n+  assemble_name_raw (asm_out_file, loop_lab);\n+  fputc ('\\n', asm_out_file);\n+\n+  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, end_lab);\n+\n+  return \"\";\n+}\n+\n /* Finalize stack_realign_needed flag, which will guide prologue/epilogue\n    to be generated in correct form.  */\n static void\n@@ -8900,6 +9296,32 @@ ix86_expand_prologue (void)\n   else\n     allocate += frame.nregs * UNITS_PER_WORD;\n \n+  /* The stack has already been decremented by the instruction calling us\n+     so we need to probe unconditionally to preserve the protection area.  */\n+  if (flag_stack_check == STATIC_BUILTIN_STACK_CHECK)\n+    {\n+      /* We expect the registers to be saved when probes are used.  */\n+      gcc_assert (!frame.save_regs_using_mov);\n+\n+      if (STACK_CHECK_MOVING_SP)\n+\t{\n+\t  ix86_adjust_stack_and_probe (allocate);\n+\t  allocate = 0;\n+\t}\n+      else\n+\t{\n+\t  HOST_WIDE_INT size = allocate;\n+\n+\t  if (TARGET_64BIT && size >= (HOST_WIDE_INT) 0x80000000)\n+\t    size = 0x80000000 - STACK_CHECK_PROTECT - 1;\n+\n+\t  if (TARGET_STACK_PROBE)\n+\t    ix86_emit_probe_stack_range (0, size + STACK_CHECK_PROTECT);\n+\t  else\n+\t    ix86_emit_probe_stack_range (STACK_CHECK_PROTECT, size);\n+\t}\n+    }\n+\n   /* When using red zone we may start register saving before allocating\n      the stack frame saving one cycle of the prologue. However I will\n      avoid doing this if I am going to have to probe the stack since\n@@ -8915,7 +9337,7 @@ ix86_expand_prologue (void)\n \n   if (allocate == 0)\n     ;\n-  else if (! TARGET_STACK_PROBE || allocate < CHECK_STACK_LIMIT)\n+  else if (!ix86_target_stack_probe () || allocate < CHECK_STACK_LIMIT)\n     pro_epilogue_adjust_stack (stack_pointer_rtx, stack_pointer_rtx,\n \t\t\t       GEN_INT (-allocate), -1,\n \t\t\t       ix86_cfa_state->reg == stack_pointer_rtx);"}, {"sha": "dddb3ab77724b65665eb8c0c9a8744f151330594", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 26, "deletions": 3, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2de710b956f05c56cf45601e38a2d9a4b4bed0d1/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2de710b956f05c56cf45601e38a2d9a4b4bed0d1/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=2de710b956f05c56cf45601e38a2d9a4b4bed0d1", "patch": "@@ -233,6 +233,7 @@\n (define_c_enum \"unspecv\" [\n   UNSPECV_BLOCKAGE\n   UNSPECV_STACK_PROBE\n+  UNSPECV_PROBE_STACK_RANGE\n   UNSPECV_EMMS\n   UNSPECV_LDMXCSR\n   UNSPECV_STMXCSR\n@@ -16441,7 +16442,7 @@\n \t\t\t    UNSPECV_STACK_PROBE))\n    (set (reg:SI SP_REG) (minus:SI (reg:SI SP_REG) (match_dup 1)))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"!TARGET_64BIT && TARGET_STACK_PROBE\"\n+  \"!TARGET_64BIT && ix86_target_stack_probe ()\"\n   \"call\\t___chkstk\"\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"length\" \"5\")])\n@@ -16454,15 +16455,15 @@\n    (clobber (reg:DI R10_REG))\n    (clobber (reg:DI R11_REG))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT && TARGET_STACK_PROBE\"\n+  \"TARGET_64BIT && ix86_target_stack_probe ()\"\n   \"call\\t___chkstk\"\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"length\" \"5\")])\n \n (define_expand \"allocate_stack\"\n   [(match_operand 0 \"register_operand\" \"\")\n    (match_operand 1 \"general_operand\" \"\")]\n-  \"TARGET_STACK_PROBE\"\n+  \"ix86_target_stack_probe ()\"\n {\n   rtx x;\n \n@@ -16509,6 +16510,28 @@\n   DONE;\n })\n \n+(define_insn \"adjust_stack_and_probe<mode>\"\n+  [(set (match_operand:P 0 \"register_operand\" \"=r\")\n+\t(unspec_volatile:P [(match_operand:P 1 \"register_operand\" \"0\")]\n+\t\t\t    UNSPECV_PROBE_STACK_RANGE))\n+   (set (reg:P SP_REG)\n+        (minus:P (reg:P SP_REG) (match_operand:P 2 \"const_int_operand\" \"n\")))\n+   (clobber (reg:CC FLAGS_REG))\n+   (clobber (mem:BLK (scratch)))]\n+  \"\"\n+  \"* return output_adjust_stack_and_probe (operands[0]);\"\n+  [(set_attr \"type\" \"multi\")])\n+\n+(define_insn \"probe_stack_range<mode>\"\n+  [(set (match_operand:P 0 \"register_operand\" \"=r\")\n+\t(unspec_volatile:P [(match_operand:P 1 \"register_operand\" \"0\")\n+\t\t\t    (match_operand:P 2 \"const_int_operand\" \"n\")]\n+\t\t\t    UNSPECV_PROBE_STACK_RANGE))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"\"\n+  \"* return output_probe_stack_range (operands[0], operands[2]);\"\n+  [(set_attr \"type\" \"multi\")])\n+\n (define_expand \"builtin_setjmp_receiver\"\n   [(label_ref (match_operand 0 \"\" \"\"))]\n   \"!TARGET_64BIT && flag_pic\""}, {"sha": "81dfd1e2509b45057e51c176ddc2d9167c94ef93", "filename": "gcc/config/i386/linux.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2de710b956f05c56cf45601e38a2d9a4b4bed0d1/gcc%2Fconfig%2Fi386%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2de710b956f05c56cf45601e38a2d9a4b4bed0d1/gcc%2Fconfig%2Fi386%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Flinux.h?ref=2de710b956f05c56cf45601e38a2d9a4b4bed0d1", "patch": "@@ -209,6 +209,9 @@ along with GCC; see the file COPYING3.  If not see\n /* The stack pointer needs to be moved while checking the stack.  */\n #define STACK_CHECK_MOVING_SP 1\n \n+/* Static stack checking is supported by means of probes.  */\n+#define STACK_CHECK_STATIC_BUILTIN 1\n+\n /* This macro may be overridden in i386/k*bsd-gnu.h.  */\n #define REG_NAME(reg) reg\n "}, {"sha": "33b4dc9cd8fecb38185a565e408da308db3ecb0f", "filename": "gcc/config/i386/linux64.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2de710b956f05c56cf45601e38a2d9a4b4bed0d1/gcc%2Fconfig%2Fi386%2Flinux64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2de710b956f05c56cf45601e38a2d9a4b4bed0d1/gcc%2Fconfig%2Fi386%2Flinux64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Flinux64.h?ref=2de710b956f05c56cf45601e38a2d9a4b4bed0d1", "patch": "@@ -112,6 +112,9 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n /* The stack pointer needs to be moved while checking the stack.  */\n #define STACK_CHECK_MOVING_SP 1\n \n+/* Static stack checking is supported by means of probes.  */\n+#define STACK_CHECK_STATIC_BUILTIN 1\n+\n /* This macro may be overridden in i386/k*bsd-gnu.h.  */\n #define REG_NAME(reg) reg\n "}, {"sha": "e4595e0135a6615e5ae4e38504e7538f6bec0031", "filename": "gcc/config/i386/sol2.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2de710b956f05c56cf45601e38a2d9a4b4bed0d1/gcc%2Fconfig%2Fi386%2Fsol2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2de710b956f05c56cf45601e38a2d9a4b4bed0d1/gcc%2Fconfig%2Fi386%2Fsol2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsol2.h?ref=2de710b956f05c56cf45601e38a2d9a4b4bed0d1", "patch": "@@ -154,6 +154,9 @@ along with GCC; see the file COPYING3.  If not see\n #undef X86_FILE_START_VERSION_DIRECTIVE\n #define X86_FILE_START_VERSION_DIRECTIVE false\n \n+/* Static stack checking is supported by means of probes.  */\n+#define STACK_CHECK_STATIC_BUILTIN 1\n+\n /* Only recent versions of Solaris 11 ld properly support hidden .gnu.linkonce\n    sections, so don't use them.  */\n #ifndef TARGET_GNU_LD"}]}