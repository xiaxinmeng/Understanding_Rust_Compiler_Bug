{"sha": "8b7b9d66fe761fb42a55d016c90a4790f301f6c0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGI3YjlkNjZmZTc2MWZiNDJhNTVkMDE2YzkwYTQ3OTBmMzAxZjZjMA==", "commit": {"author": {"name": "Ira Rosen", "email": "irar@il.ibm.com", "date": "2008-08-23T17:04:12Z"}, "committer": {"name": "Ira Rosen", "email": "irar@gcc.gnu.org", "date": "2008-08-23T17:04:12Z"}, "message": "re PR middle-end/37161 (Revision 139225 caused gfortran.dg/vect/pr33301.f  -O)\n\n\tPR tree-optimization/37161\n\t* tree-vectorizer.h (vect_get_smallest_scalar_type): Declare.\n\t* tree-vect-analyze.c (vect_get_smallest_scalar_type): New function.\n\t(vect_determine_vectorization_factor): Move the scalar type\n\tretrieval to vect_get_smallest_scalar_type.\n\t(vect_build_slp_tree): Call vect_get_smallest_scalar_type to get\n\tscalar type. Remove redundant computation.\n\t* tree-vect-transform.c (vect_get_constant_vectors): Add argument.\n\t(vect_get_slp_defs): Take the type of RHS into account if\n\tnecessary by calling vect_get_smallest_scalar_type. Call\n\tvect_get_constant_vectors with additional argument.\n\nFrom-SVN: r139518", "tree": {"sha": "4732cf98327fb0a83820979f35dc3cc279be0a92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4732cf98327fb0a83820979f35dc3cc279be0a92"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8b7b9d66fe761fb42a55d016c90a4790f301f6c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b7b9d66fe761fb42a55d016c90a4790f301f6c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b7b9d66fe761fb42a55d016c90a4790f301f6c0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b7b9d66fe761fb42a55d016c90a4790f301f6c0/comments", "author": {"login": "irar2", "id": 16818592, "node_id": "MDQ6VXNlcjE2ODE4NTky", "avatar_url": "https://avatars.githubusercontent.com/u/16818592?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irar2", "html_url": "https://github.com/irar2", "followers_url": "https://api.github.com/users/irar2/followers", "following_url": "https://api.github.com/users/irar2/following{/other_user}", "gists_url": "https://api.github.com/users/irar2/gists{/gist_id}", "starred_url": "https://api.github.com/users/irar2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irar2/subscriptions", "organizations_url": "https://api.github.com/users/irar2/orgs", "repos_url": "https://api.github.com/users/irar2/repos", "events_url": "https://api.github.com/users/irar2/events{/privacy}", "received_events_url": "https://api.github.com/users/irar2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f4185118a442bf05af6b640909cd1dec96dc84e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4185118a442bf05af6b640909cd1dec96dc84e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4185118a442bf05af6b640909cd1dec96dc84e9"}], "stats": {"total": 125, "additions": 84, "deletions": 41}, "files": [{"sha": "1e1deebced5dc2dee52de948e77c64945d4eb7ad", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b7b9d66fe761fb42a55d016c90a4790f301f6c0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b7b9d66fe761fb42a55d016c90a4790f301f6c0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8b7b9d66fe761fb42a55d016c90a4790f301f6c0", "patch": "@@ -1,3 +1,17 @@\n+2008-08-23  Ira Rosen  <irar@il.ibm.com>\n+\n+\tPR tree-optimization/37161\n+\t* tree-vectorizer.h (vect_get_smallest_scalar_type): Declare.\n+\t* tree-vect-analyze.c (vect_get_smallest_scalar_type): New function.\n+\t(vect_determine_vectorization_factor): Move the scalar type\n+\tretrieval to vect_get_smallest_scalar_type.\n+\t(vect_build_slp_tree): Call vect_get_smallest_scalar_type to get\n+\tscalar type. Remove redundant computation.\n+\t* tree-vect-transform.c (vect_get_constant_vectors): Add argument.\n+\t(vect_get_slp_defs): Take the type of RHS into account if\n+\tnecessary by calling vect_get_smallest_scalar_type. Call\n+\tvect_get_constant_vectors with additional argument.\n+\n 2008-08-23  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n \n \tPR 35648"}, {"sha": "305ba4c6603719899bca71cf90a1a459eaf298fc", "filename": "gcc/tree-vect-analyze.c", "status": "modified", "additions": 49, "deletions": 34, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b7b9d66fe761fb42a55d016c90a4790f301f6c0/gcc%2Ftree-vect-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b7b9d66fe761fb42a55d016c90a4790f301f6c0/gcc%2Ftree-vect-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-analyze.c?ref=8b7b9d66fe761fb42a55d016c90a4790f301f6c0", "patch": "@@ -44,6 +44,50 @@ along with GCC; see the file COPYING3.  If not see\n \n static bool vect_can_advance_ivs_p (loop_vec_info);\n \n+/* Return the smallest scalar part of STMT.\n+   This is used to determine the vectype of the stmt. We generally set the \n+   vectype according to the type of the result (lhs). For stmts whose \n+   result-type is different than the type of the arguments (e.g., demotion,\n+   promotion), vectype will be reset appropriately (later).  Note that we have \n+   to visit the smallest datatype in this function, because that determines the\n+   VF. If the smallest datatype in the loop is present only as the rhs of a \n+   promotion operation - we'd miss it.\n+   Such a case, where a variable of this datatype does not appear in the lhs\n+   anywhere in the loop, can only occur if it's an invariant: e.g.:\n+   'int_x = (int) short_inv', which we'd expect to have been optimized away by \n+   invariant motion. However, we cannot rely on invariant motion to always take\n+   invariants out of the loop, and so in the case of promotion we also have to\n+   check the rhs. \n+   LHS_SIZE_UNIT and RHS_SIZE_UNIT contain the sizes of the corresponding\n+   types.  */\n+\n+tree\n+vect_get_smallest_scalar_type (gimple stmt, HOST_WIDE_INT *lhs_size_unit,\n+                               HOST_WIDE_INT *rhs_size_unit)\n+{\n+  tree scalar_type = gimple_expr_type (stmt);\n+  HOST_WIDE_INT lhs, rhs;\n+\n+  lhs = rhs = TREE_INT_CST_LOW (TYPE_SIZE_UNIT (scalar_type));\n+\n+  if (is_gimple_assign (stmt)\n+      && (gimple_assign_cast_p (stmt)\n+          || gimple_assign_rhs_code (stmt) == WIDEN_MULT_EXPR\n+          || gimple_assign_rhs_code (stmt) == FLOAT_EXPR))\n+    {\n+      tree rhs_type = TREE_TYPE (gimple_assign_rhs1 (stmt));\n+\n+      rhs = TREE_INT_CST_LOW (TYPE_SIZE_UNIT (rhs_type));\n+      if (rhs < lhs)\n+        scalar_type = rhs_type;\n+    }\n+     \n+  *lhs_size_unit = lhs; \n+  *rhs_size_unit = rhs;\n+  return scalar_type;\n+}\n+\n+\n /* Function vect_determine_vectorization_factor\n \n    Determine the vectorization factor (VF). VF is the number of data elements\n@@ -83,6 +127,7 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n   unsigned int nunits;\n   stmt_vec_info stmt_info;\n   int i;\n+  HOST_WIDE_INT dummy;\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"=== vect_determine_vectorization_factor ===\");\n@@ -200,34 +245,8 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \t      gcc_assert (! STMT_VINFO_DATA_REF (stmt_info)\n \t\t\t  && !is_pattern_stmt_p (stmt_info));\n \n-\t      /* We generally set the vectype according to the type of the \n-\t\t result (lhs).\n-\t\t For stmts whose result-type is different than the type of the\n-\t\t arguments (e.g. demotion, promotion), vectype will be reset \n-\t\t appropriately (later).  Note that we have to visit the smallest \n-\t\t datatype in this function, because that determines the VF.  \n-\t\t If the smallest datatype in the loop is present only as the \n-\t\t rhs of a promotion operation - we'd miss it here.\n-\t\t Such a case, where a variable of this datatype does not appear \n-\t\t in the lhs anywhere in the loop, can only occur if it's an\n-\t\t invariant: e.g.: 'int_x = (int) short_inv', which we'd expect\n-\t\t to have been optimized away by invariant motion. However, we \n-\t\t cannot rely on invariant motion to always take invariants out\n-\t\t of the loop, and so in the case of promotion we also have to \n-\t\t check the rhs.  */\n-\t      scalar_type = gimple_expr_type (stmt);\n-\n-\t      if (is_gimple_assign (stmt)\n-\t\t  && (gimple_assign_cast_p (stmt)\n-\t\t      || gimple_assign_rhs_code (stmt) == WIDEN_MULT_EXPR\n-\t\t      || gimple_assign_rhs_code (stmt) == FLOAT_EXPR))\n-\t\t{\n-\t\t  tree rhs_type = TREE_TYPE (gimple_assign_rhs1 (stmt));\n-\t\t  if (TREE_INT_CST_LOW (TYPE_SIZE_UNIT (rhs_type))\n-\t\t      < TREE_INT_CST_LOW (TYPE_SIZE_UNIT (scalar_type)))\n-\t\t    scalar_type = rhs_type;\n-\t\t}\n-\n+\t      scalar_type = vect_get_smallest_scalar_type (stmt, &dummy, \n+                                                           &dummy);\n \t      if (vect_print_dump_info (REPORT_DETAILS))\n \t\t{\n \t\t  fprintf (vect_dump, \"get vectype for scalar type:  \");\n@@ -2708,6 +2727,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, slp_tree *node,\n   tree first_stmt_const_oprnd = NULL_TREE;\n   struct data_reference *first_dr;\n   bool pattern0 = false, pattern1 = false;\n+  HOST_WIDE_INT dummy;\n \n   /* For every stmt in NODE find its def stmt/s.  */\n   for (i = 0; VEC_iterate (gimple, stmts, i, stmt); i++)\n@@ -2731,7 +2751,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, slp_tree *node,\n \t  return false;\n \t}\n \n-      scalar_type = TREE_TYPE (lhs);\n+      scalar_type = vect_get_smallest_scalar_type (stmt, &dummy, &dummy); \n       vectype = get_vectype_for_scalar_type (scalar_type);\n       if (!vectype)\n         {\n@@ -2860,11 +2880,6 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, slp_tree *node,\n \t\t/* Load.  */\n \t\tif (i == 0)\n \t\t  {\n-                    /* In case of multiple types we need to detect the smallest\n-                       type.  */\n-                    if (*max_nunits < TYPE_VECTOR_SUBPARTS (vectype))\n-                       *max_nunits = TYPE_VECTOR_SUBPARTS (vectype);\n-\n \t\t    /* First stmt of the SLP group should be the first load of \n \t\t       the interleaving loop if data permutation is not allowed.\n \t\t       Check that there is no gap between the loads.  */"}, {"sha": "0744527794dd80db694911d8b75960acc8aac72a", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b7b9d66fe761fb42a55d016c90a4790f301f6c0/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b7b9d66fe761fb42a55d016c90a4790f301f6c0/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=8b7b9d66fe761fb42a55d016c90a4790f301f6c0", "patch": "@@ -1385,11 +1385,11 @@ vect_init_vector (gimple stmt, tree vector_var, tree vector_type,\n /* For constant and loop invariant defs of SLP_NODE this function returns \n    (vector) defs (VEC_OPRNDS) that will be used in the vectorized stmts.  \n    OP_NUM determines if we gather defs for operand 0 or operand 1 of the scalar\n-   stmts.  */\n+   stmts. NUMBER_OF_VECTORS is the number of vector defs to create.  */\n \n static void\n vect_get_constant_vectors (slp_tree slp_node, VEC(tree,heap) **vec_oprnds,\n-\t\t\t   unsigned int op_num)\n+\t\t\t   unsigned int op_num, unsigned int number_of_vectors)\n {\n   VEC (gimple, heap) *stmts = SLP_TREE_SCALAR_STMTS (slp_node);\n   gimple stmt = VEC_index (gimple, stmts, 0);\n@@ -1405,7 +1405,6 @@ vect_get_constant_vectors (slp_tree slp_node, VEC(tree,heap) **vec_oprnds,\n   unsigned int vec_num, i;\n   int number_of_copies = 1;\n   bool is_store = false;\n-  unsigned int number_of_vectors = SLP_TREE_NUMBER_OF_VEC_STMTS (slp_node);\n   VEC (tree, heap) *voprnds = VEC_alloc (tree, heap, number_of_vectors);\n   bool constant_p;\n \n@@ -1529,13 +1528,27 @@ vect_get_slp_defs (slp_tree slp_node, VEC (tree,heap) **vec_oprnds0,\n   gimple first_stmt;\n   enum tree_code code;\n   int number_of_vects;\n+  HOST_WIDE_INT lhs_size_unit, rhs_size_unit; \n \n+  first_stmt = VEC_index (gimple, SLP_TREE_SCALAR_STMTS (slp_node), 0);\n   /* The number of vector defs is determined by the number of vector statements\n      in the node from which we get those statements.  */\n   if (SLP_TREE_LEFT (slp_node)) \n     number_of_vects = SLP_TREE_NUMBER_OF_VEC_STMTS (SLP_TREE_LEFT (slp_node));\n   else\n-    number_of_vects = SLP_TREE_NUMBER_OF_VEC_STMTS (slp_node);\n+    {\n+      number_of_vects = SLP_TREE_NUMBER_OF_VEC_STMTS (slp_node);\n+      /* Number of vector stmts was calculated according to LHS in\n+         vect_schedule_slp_instance(), fix it by replacing LHS with RHS, if\n+         necessary. See vect_get_smallest_scalar_type() for details.  */\n+      vect_get_smallest_scalar_type (first_stmt, &lhs_size_unit,\n+                                     &rhs_size_unit);\n+      if (rhs_size_unit != lhs_size_unit)\n+        {\n+          number_of_vects *= rhs_size_unit;\n+          number_of_vects /= lhs_size_unit;\n+        }\n+    }\n \n   /* Allocate memory for vectorized defs.  */\n   *vec_oprnds0 = VEC_alloc (tree, heap, number_of_vects);\n@@ -1547,9 +1560,8 @@ vect_get_slp_defs (slp_tree slp_node, VEC (tree,heap) **vec_oprnds0,\n     vect_get_slp_vect_defs (SLP_TREE_LEFT (slp_node), vec_oprnds0);\n   else\n     /* Build vectors from scalar defs.  */\n-    vect_get_constant_vectors (slp_node, vec_oprnds0, 0);\n+    vect_get_constant_vectors (slp_node, vec_oprnds0, 0, number_of_vects);\n \n-  first_stmt = VEC_index (gimple, SLP_TREE_SCALAR_STMTS (slp_node), 0);\n   if (STMT_VINFO_DATA_REF (vinfo_for_stmt (first_stmt)))\n     /* Since we don't call this function with loads, this is a group of\n        stores.  */\n@@ -1573,7 +1585,7 @@ vect_get_slp_defs (slp_tree slp_node, VEC (tree,heap) **vec_oprnds0,\n     vect_get_slp_vect_defs (SLP_TREE_RIGHT (slp_node), vec_oprnds1);\n   else\n     /* Build vectors from scalar defs.  */\n-    vect_get_constant_vectors (slp_node, vec_oprnds1, 1);\n+    vect_get_constant_vectors (slp_node, vec_oprnds1, 1, number_of_vects);\n }\n \n "}, {"sha": "10e7aa309004d153f9a1af232d3e4e53a0e9b3a2", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b7b9d66fe761fb42a55d016c90a4790f301f6c0/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b7b9d66fe761fb42a55d016c90a4790f301f6c0/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=8b7b9d66fe761fb42a55d016c90a4790f301f6c0", "patch": "@@ -702,6 +702,8 @@ extern void free_stmt_vec_info (gimple stmt);\n extern loop_vec_info vect_analyze_loop (struct loop *);\n extern void vect_free_slp_tree (slp_tree);\n extern loop_vec_info vect_analyze_loop_form (struct loop *);\n+extern tree vect_get_smallest_scalar_type (gimple, HOST_WIDE_INT *, \n+                                           HOST_WIDE_INT *);\n \n /** In tree-vect-patterns.c  **/\n /* Pattern recognition functions."}]}