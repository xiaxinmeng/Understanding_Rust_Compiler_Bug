{"sha": "69bc6bff15bc6d1d294a828693091d0265549130", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjliYzZiZmYxNWJjNmQxZDI5NGE4Mjg2OTMwOTFkMDI2NTU0OTEzMA==", "commit": {"author": {"name": "Manuel L\u00f3pez-Ib\u00e1\u00f1ez", "email": "manu@gcc.gnu.org", "date": "2009-07-06T09:09:47Z"}, "committer": {"name": "Manuel L\u00f3pez-Ib\u00e1\u00f1ez", "email": "manu@gcc.gnu.org", "date": "2009-07-06T09:09:47Z"}, "message": "decl.c: Replace %H by an explicit location.\n\n2009-07-06  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n\ncp/\n\t* decl.c: Replace %H by an explicit location. Update all calls.\n\t* except.c: Likewise.\n\t* semantics.c: Likewise.\n\t* parser.c: Likewise.\n\nFrom-SVN: r149277", "tree": {"sha": "9429281816e5f0ce1b0e27a9de8cbfa48bc75a3f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9429281816e5f0ce1b0e27a9de8cbfa48bc75a3f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/69bc6bff15bc6d1d294a828693091d0265549130", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69bc6bff15bc6d1d294a828693091d0265549130", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69bc6bff15bc6d1d294a828693091d0265549130", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69bc6bff15bc6d1d294a828693091d0265549130/comments", "author": null, "committer": null, "parents": [{"sha": "c4efba1c212b3cc4c3af05a420888b878fcc29ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4efba1c212b3cc4c3af05a420888b878fcc29ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4efba1c212b3cc4c3af05a420888b878fcc29ae"}], "stats": {"total": 564, "additions": 297, "deletions": 267}, "files": [{"sha": "f76561efc5d77cf00d9bbf87ace0a440fdf247f1", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69bc6bff15bc6d1d294a828693091d0265549130/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69bc6bff15bc6d1d294a828693091d0265549130/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=69bc6bff15bc6d1d294a828693091d0265549130", "patch": "@@ -1,3 +1,10 @@\n+2009-07-06  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n+\n+\t* decl.c: Replace %H by an explicit location. Update all calls.\n+\t* except.c: Likewise.\n+\t* semantics.c: Likewise.\n+\t* parser.c: Likewise.\n+\n 2009-07-06  Simon Martin  <simartin@users.sourceforge.net>\n \n \tPR c++/40557"}, {"sha": "6d15783601670650f3da0953d2a81e5a7e2b7a8a", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69bc6bff15bc6d1d294a828693091d0265549130/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69bc6bff15bc6d1d294a828693091d0265549130/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=69bc6bff15bc6d1d294a828693091d0265549130", "patch": "@@ -2490,7 +2490,7 @@ identify_goto (tree decl, const location_t *locus)\n   else\n     permerror (input_location, \"jump to case label\");\n   if (locus)\n-    permerror (input_location, \"%H  from here\", locus);\n+    permerror (*locus, \"  from here\");\n }\n \n /* Check that a single previously seen jump to a newly defined label"}, {"sha": "01512860725704b7f31e678d3e3bc4580eb9d3e7", "filename": "gcc/cp/except.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69bc6bff15bc6d1d294a828693091d0265549130/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69bc6bff15bc6d1d294a828693091d0265549130/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=69bc6bff15bc6d1d294a828693091d0265549130", "patch": "@@ -998,10 +998,11 @@ check_handlers_1 (tree master, tree_stmt_iterator i)\n       tree handler = tsi_stmt (i);\n       if (TREE_TYPE (handler) && can_convert_eh (type, TREE_TYPE (handler)))\n \t{\n-\t  warning (0, \"%Hexception of type %qT will be caught\",\n-\t\t   EXPR_LOCUS (handler), TREE_TYPE (handler));\n-\t  warning (0, \"%H   by earlier handler for %qT\",\n-\t\t   EXPR_LOCUS (master), type);\n+\t  warning_at (EXPR_LOCATION (handler), 0,\n+\t\t      \"exception of type %qT will be caught\",\n+\t\t      TREE_TYPE (handler));\n+\t  warning_at (EXPR_LOCATION (master), 0,\n+\t\t      \"   by earlier handler for %qT\", type);\n \t  break;\n \t}\n     }\n@@ -1030,8 +1031,8 @@ check_handlers (tree handlers)\n \tif (tsi_end_p (i))\n \t  break;\n \tif (TREE_TYPE (handler) == NULL_TREE)\n-\t  permerror (input_location, \"%H%<...%> handler must be the last handler for\"\n-\t\t     \" its try block\", EXPR_LOCUS (handler));\n+\t  permerror (EXPR_LOCATION (handler), \"%<...%>\"\n+\t\t     \" handler must be the last handler for its try block\");\n \telse\n \t  check_handlers_1 (handler, i);\n       }"}, {"sha": "d6d4d5bbd27930deaa8179e6fd83633210ef470b", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 265, "deletions": 243, "changes": 508, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69bc6bff15bc6d1d294a828693091d0265549130/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69bc6bff15bc6d1d294a828693091d0265549130/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=69bc6bff15bc6d1d294a828693091d0265549130", "patch": "@@ -2079,7 +2079,8 @@ cp_parser_error (cp_parser* parser, const char* message)\n \n       if (token->type == CPP_PRAGMA)\n \t{\n-\t  error (\"%H%<#pragma%> is not allowed here\", &token->location);\n+\t  error_at (token->location,\n+\t\t    \"%<#pragma%> is not allowed here\");\n \t  cp_parser_skip_to_pragma_eol (parser, token);\n \t  return;\n \t}\n@@ -2110,26 +2111,26 @@ cp_parser_name_lookup_error (cp_parser* parser,\n   if (decl == error_mark_node)\n     {\n       if (parser->scope && parser->scope != global_namespace)\n-\terror (\"%H%<%E::%E%> has not been declared\",\n-\t       &location, parser->scope, name);\n+\terror_at (location, \"%<%E::%E%> has not been declared\",\n+\t\t  parser->scope, name);\n       else if (parser->scope == global_namespace)\n-\terror (\"%H%<::%E%> has not been declared\", &location, name);\n+\terror_at (location, \"%<::%E%> has not been declared\", name);\n       else if (parser->object_scope\n \t       && !CLASS_TYPE_P (parser->object_scope))\n-\terror (\"%Hrequest for member %qE in non-class type %qT\",\n-\t       &location, name, parser->object_scope);\n+\terror_at (location, \"request for member %qE in non-class type %qT\",\n+\t\t  name, parser->object_scope);\n       else if (parser->object_scope)\n-\terror (\"%H%<%T::%E%> has not been declared\",\n-\t       &location, parser->object_scope, name);\n+\terror_at (location, \"%<%T::%E%> has not been declared\",\n+\t\t  parser->object_scope, name);\n       else\n-\terror (\"%H%qE has not been declared\", &location, name);\n+\terror_at (location, \"%qE has not been declared\", name);\n     }\n   else if (parser->scope && parser->scope != global_namespace)\n-    error (\"%H%<%E::%E%> %s\", &location, parser->scope, name, desired);\n+    error_at (location, \"%<%E::%E%> %s\", parser->scope, name, desired);\n   else if (parser->scope == global_namespace)\n-    error (\"%H%<::%E%> %s\", &location, name, desired);\n+    error_at (location, \"%<::%E%> %s\", name, desired);\n   else\n-    error (\"%H%qE %s\", &location, name, desired);\n+    error_at (location, \"%qE %s\", name, desired);\n }\n \n /* If we are parsing tentatively, remember that an error has occurred\n@@ -2164,7 +2165,7 @@ cp_parser_check_decl_spec (cp_decl_specifier_seq *decl_specs,\n       if (ds == ds_long)\n \t{\n \t  if (count > 2)\n-\t    error (\"%H%<long long long%> is too long for GCC\", &location);\n+\t    error_at (location, \"%<long long long%> is too long for GCC\");\n \t  else \n \t    pedwarn_cxx98 (location, OPT_Wlong_long, \n \t\t\t   \"ISO C++ 1998 does not support %<long long%>\");\n@@ -2187,7 +2188,7 @@ cp_parser_check_decl_spec (cp_decl_specifier_seq *decl_specs,\n \t    \"__complex\",\n \t    \"__thread\"\n \t  };\n-\t  error (\"%Hduplicate %qs\", &location, decl_spec_names[ds]);\n+\t  error_at (location, \"duplicate %qs\", decl_spec_names[ds]);\n \t}\n     }\n }\n@@ -2231,7 +2232,8 @@ cp_parser_check_for_definition_in_return_type (cp_declarator *declarator,\n   if (declarator\n       && declarator->kind == cdk_function)\n     {\n-      error (\"%Hnew types may not be defined in a return type\", &type_location);\n+      error_at (type_location,\n+\t\t\"new types may not be defined in a return type\");\n       inform (type_location, \n \t      \"(perhaps a semicolon is missing after the definition of %qT)\",\n \t      type);\n@@ -2253,11 +2255,11 @@ cp_parser_check_for_invalid_template_id (cp_parser* parser,\n   if (cp_lexer_next_token_is (parser->lexer, CPP_LESS))\n     {\n       if (TYPE_P (type))\n-\terror (\"%H%qT is not a template\", &location, type);\n+\terror_at (location, \"%qT is not a template\", type);\n       else if (TREE_CODE (type) == IDENTIFIER_NODE)\n-\terror (\"%H%qE is not a template\", &location, type);\n+\terror_at (location, \"%qE is not a template\", type);\n       else\n-\terror (\"%Hinvalid template-id\", &location);\n+\terror_at (location, \"invalid template-id\");\n       /* Remember the location of the invalid \"<\".  */\n       if (cp_parser_uncommitted_to_tentative_parse_p (parser))\n \tstart = cp_lexer_token_position (parser->lexer, true);\n@@ -2319,18 +2321,18 @@ cp_parser_diagnose_invalid_type_name (cp_parser *parser,\n   /* If the lookup found a template-name, it means that the user forgot\n   to specify an argument list. Emit a useful error message.  */\n   if (TREE_CODE (decl) == TEMPLATE_DECL)\n-    error (\"%Hinvalid use of template-name %qE without an argument list\",\n-           &location, decl);\n+    error_at (location,\n+\t      \"invalid use of template-name %qE without an argument list\",\n+\t      decl);\n   else if (TREE_CODE (id) == BIT_NOT_EXPR)\n-    error (\"%Hinvalid use of destructor %qD as a type\", &location, id);\n+    error_at (location, \"invalid use of destructor %qD as a type\", id);\n   else if (TREE_CODE (decl) == TYPE_DECL)\n     /* Something like 'unsigned A a;'  */\n-    error (\"%Hinvalid combination of multiple type-specifiers\",\n-           &location);\n+    error_at (location, \"invalid combination of multiple type-specifiers\");\n   else if (!parser->scope)\n     {\n       /* Issue an error message.  */\n-      error (\"%H%qE does not name a type\", &location, id);\n+      error_at (location, \"%qE does not name a type\", id);\n       /* If we're in a template class, it's possible that the user was\n \t referring to a type from a base class.  For example:\n \n@@ -2378,11 +2380,11 @@ cp_parser_diagnose_invalid_type_name (cp_parser *parser,\n   else if (parser->scope != error_mark_node)\n     {\n       if (TREE_CODE (parser->scope) == NAMESPACE_DECL)\n-\terror (\"%H%qE in namespace %qE does not name a type\",\n-\t       &location, id, parser->scope);\n+\terror_at (location, \"%qE in namespace %qE does not name a type\",\n+\t\t  id, parser->scope);\n       else if (TYPE_P (parser->scope))\n-\terror (\"%H%qE in class %qT does not name a type\",\n-               &location, id, parser->scope);\n+\terror_at (location, \"%qE in class %qT does not name a type\",\n+\t\t  id, parser->scope);\n       else\n \tgcc_unreachable ();\n     }\n@@ -2945,8 +2947,9 @@ cp_parser_string_literal (cp_parser *parser, bool translate, bool wide_ok)\n \t      if (type == CPP_STRING)\n \t\ttype = tok->type;\n \t      else if (tok->type != CPP_STRING)\n-\t\terror (\"%Hunsupported non-standard concatenation \"\n-                       \"of string literals\", &tok->location);\n+\t\terror_at (tok->location,\n+\t\t\t  \"unsupported non-standard concatenation \"\n+\t\t\t  \"of string literals\");\n \t    }\n \n \t  obstack_grow (&str_ob, &str, sizeof (cpp_string));\n@@ -3148,8 +3151,8 @@ cp_parser_primary_expression (cp_parser *parser,\n       token = cp_lexer_consume_token (parser->lexer);\n       if (TREE_CODE (token->u.value) == FIXED_CST)\n \t{\n-\t  error (\"%Hfixed-point types not supported in C++\",\n-\t\t &token->location);\n+\t  error_at (token->location,\n+\t\t    \"fixed-point types not supported in C++\");\n \t  return error_mark_node;\n \t}\n       /* Floating-point literals are only allowed in an integral\n@@ -3240,9 +3243,9 @@ cp_parser_primary_expression (cp_parser *parser,\n \t    if (!parser->in_function_body\n \t\t|| parser->in_template_argument_list_p)\n \t      {\n-\t\terror (\"%Hstatement-expressions are not allowed outside \"\n-\t\t       \"functions nor in template-argument lists\",\n-\t\t       &token->location);\n+\t\terror_at (token->location,\n+\t\t\t  \"statement-expressions are not allowed outside \"\n+\t\t\t  \"functions nor in template-argument lists\");\n \t\tcp_parser_skip_to_end_of_block_or_statement (parser);\n \t\texpr = error_mark_node;\n \t      }\n@@ -3299,8 +3302,8 @@ cp_parser_primary_expression (cp_parser *parser,\n \t  cp_lexer_consume_token (parser->lexer);\n \t  if (parser->local_variables_forbidden_p)\n \t    {\n-\t      error (\"%H%<this%> may not be used in this context\",\n-                     &token->location);\n+\t      error_at (token->location,\n+\t\t\t\"%<this%> may not be used in this context\");\n \t      return error_mark_node;\n \t    }\n \t  /* Pointers cannot appear in constant-expressions.  */\n@@ -3508,8 +3511,9 @@ cp_parser_primary_expression (cp_parser *parser,\n \t\tdecl = check_for_out_of_scope_variable (decl);\n \t\tif (local_variable_p (decl))\n \t\t  {\n-\t\t    error (\"%Hlocal variable %qD may not appear in this context\",\n-\t\t\t   &id_expr_token->location, decl);\n+\t\t    error_at (id_expr_token->location,\n+\t\t\t      \"local variable %qD may not appear in this context\",\n+\t\t\t      decl);\n \t\t    return error_mark_node;\n \t\t  }\n \t      }\n@@ -3808,8 +3812,9 @@ cp_parser_unqualified_id (cp_parser* parser,\n \tif (scope && TREE_CODE (scope) == NAMESPACE_DECL)\n \t  {\n \t    if (!cp_parser_uncommitted_to_tentative_parse_p (parser))\n-\t      error (\"%Hscope %qT before %<~%> is not a class-name\",\n-\t\t     &token->location, scope);\n+\t      error_at (token->location,\n+\t\t\t\"scope %qT before %<~%> is not a class-name\",\n+\t\t\tscope);\n \t    cp_parser_simulate_error (parser);\n \t    if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n \t      cp_lexer_consume_token (parser->lexer);\n@@ -3922,8 +3927,9 @@ cp_parser_unqualified_id (cp_parser* parser,\n \tif (declarator_p && scope && !check_dtor_name (scope, type_decl))\n \t  {\n \t    if (!cp_parser_uncommitted_to_tentative_parse_p (parser))\n-\t      error (\"%Hdeclaration of %<~%T%> as member of %qT\",\n-\t\t     &token->location, type_decl, scope);\n+\t      error_at (token->location,\n+\t\t\t\"declaration of %<~%T%> as member of %qT\",\n+\t\t\ttype_decl, scope);\n \t    cp_parser_simulate_error (parser);\n \t    return error_mark_node;\n \t  }\n@@ -3936,8 +3942,9 @@ cp_parser_unqualified_id (cp_parser* parser,\n \t    && !DECL_IMPLICIT_TYPEDEF_P (type_decl)\n \t    && !DECL_SELF_REFERENCE_P (type_decl)\n \t    && !cp_parser_uncommitted_to_tentative_parse_p (parser))\n-\t  error (\"%Htypedef-name %qD used as destructor declarator\",\n-\t\t &token->location, type_decl);\n+\t  error_at (token->location,\n+\t\t    \"typedef-name %qD used as destructor declarator\",\n+\t\t    type_decl);\n \n \treturn build_nt (BIT_NOT_EXPR, TREE_TYPE (type_decl));\n       }\n@@ -4150,12 +4157,14 @@ cp_parser_nested_name_specifier_opt (cp_parser *parser,\n \t\t\t\t\t\t    &ambiguous_decls,\n \t\t\t\t\t\t    token->location);\n \t\t      if (TREE_CODE (decl) == TEMPLATE_DECL)\n-\t\t\terror (\"%H%qD used without template parameters\",\n-\t\t\t       &token->location, decl);\n+\t\t\terror_at (token->location,\n+\t\t\t\t  \"%qD used without template parameters\",\n+\t\t\t\t  decl);\n \t\t      else if (ambiguous_decls)\n \t\t\t{\n-\t\t\t  error (\"%Hreference to %qD is ambiguous\",\n-\t\t\t\t &token->location, token->u.value);\n+\t\t\t  error_at (token->location,\n+\t\t\t\t    \"reference to %qD is ambiguous\",\n+\t\t\t\t    token->u.value);\n \t\t\t  print_candidates (ambiguous_decls);\n \t\t\t  decl = error_mark_node;\n \t\t\t}\n@@ -5002,7 +5011,8 @@ cp_parser_postfix_dot_deref_expression (cp_parser *parser,\n       /* The type of the POSTFIX_EXPRESSION must be complete.  */\n       if (scope == unknown_type_node)\n \t{\n-\t  error (\"%H%qE does not have class type\", &location, postfix_expression);\n+\t  error_at (location, \"%qE does not have class type\",\n+\t\t    postfix_expression);\n \t  scope = NULL_TREE;\n \t}\n       else\n@@ -5086,7 +5096,7 @@ cp_parser_postfix_dot_deref_expression (cp_parser *parser,\n \t TYPE_DECL here.  That is invalid code.  */\n       if (TREE_CODE (name) == TYPE_DECL)\n \t{\n-\t  error (\"%Hinvalid use of %qD\", &token->location, name);\n+\t  error_at (token->location, \"invalid use of %qD\", name);\n \t  postfix_expression = error_mark_node;\n \t}\n       else\n@@ -5668,8 +5678,8 @@ cp_parser_new_expression (cp_parser* parser)\n \t message for this case.  */\n       if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_SQUARE))\n \t{\n-\t  error (\"%Harray bound forbidden after parenthesized type-id\",\n-\t\t &token->location);\n+\t  error_at (token->location,\n+\t\t    \"array bound forbidden after parenthesized type-id\");\n \t  inform (token->location, \n \t\t  \"try removing the parentheses around the type-id\");\n \t  cp_parser_direct_new_declarator (parser);\n@@ -5873,8 +5883,9 @@ cp_parser_direct_new_declarator (cp_parser* parser)\n \t\t\t\t\t      /*complain=*/true);\n \t      if (!expression)\n \t\t{\n-\t\t  error (\"%Hexpression in new-declarator must have integral \"\n-\t\t\t \"or enumeration type\", &token->location);\n+\t\t  error_at (token->location,\n+\t\t\t    \"expression in new-declarator must have integral \"\n+\t\t\t    \"or enumeration type\");\n \t\t  expression = error_mark_node;\n \t\t}\n \t    }\n@@ -6257,11 +6268,11 @@ cp_parser_binary_expression (cp_parser* parser, bool cast_p,\n           && token->type == CPP_RSHIFT\n           && !parser->greater_than_is_operator_p)\n         {\n-          warning (OPT_Wc__0x_compat, \n-                   \"%H%<>>%> operator will be treated as two right angle brackets in C++0x\", \n-                   &token->location);\n-          warning (OPT_Wc__0x_compat, \n-                   \"suggest parentheses around %<>>%> expression\");\n+          if (warning_at (token->location, OPT_Wc__0x_compat, \n+\t\t\t  \"%<>>%> operator will be treated as\"\n+\t\t\t  \" two right angle brackets in C++0x\"))\n+\t    inform (token->location,\n+\t\t    \"suggest parentheses around %<>>%> expression\");\n         }\n \n       new_prec = TOKEN_PRECEDENCE (token);\n@@ -7122,8 +7133,9 @@ cp_parser_label_for_labeled_statement (cp_parser* parser)\n \tif (parser->in_switch_statement_p)\n \t  finish_case_label (token->location, expr, expr_hi);\n \telse\n-\t  error (\"%Hcase label %qE not within a switch statement\",\n-\t\t &token->location, expr);\n+\t  error_at (token->location,\n+\t\t    \"case label %qE not within a switch statement\",\n+\t\t    expr);\n       }\n       break;\n \n@@ -7134,7 +7146,7 @@ cp_parser_label_for_labeled_statement (cp_parser* parser)\n       if (parser->in_switch_statement_p)\n \tfinish_case_label (token->location, NULL_TREE, NULL_TREE);\n       else\n-\terror (\"%Hcase label not within a switch statement\", &token->location);\n+\terror_at (token->location, \"case label not within a switch statement\");\n       break;\n \n     default:\n@@ -7274,7 +7286,7 @@ cp_parser_statement_seq_opt (cp_parser* parser, tree in_statement_expr)\n \t  else\n \t    {\n \t      token = cp_lexer_consume_token (parser->lexer);\n-\t      error (\"%H%<else%> without a previous %<if%>\", &token->location);\n+\t      error_at (token->location, \"%<else%> without a previous %<if%>\");\n \t    }\n \t}\n \n@@ -7404,10 +7416,9 @@ cp_parser_selection_statement (cp_parser* parser, bool *if_p)\n \t\t   statement which does have an else clause.  We warn\n \t\t   about the potential ambiguity.  */\n \t\tif (nested_if)\n-\t\t  warning (OPT_Wparentheses,\n-\t\t\t   (\"%Hsuggest explicit braces \"\n-\t\t\t    \"to avoid ambiguous %<else%>\"),\n-\t\t\t   EXPR_LOCUS (statement));\n+\t\t  warning_at (EXPR_LOCATION (statement), OPT_Wparentheses,\n+\t\t\t      \"suggest explicit braces to avoid ambiguous\"\n+\t\t\t      \" %<else%>\");\n \t      }\n \n \t    /* Now we're all done with the if-statement.  */\n@@ -7755,18 +7766,18 @@ cp_parser_jump_statement (cp_parser* parser)\n       switch (in_statement)\n \t{\n \tcase 0:\n-\t  error (\"%Hbreak statement not within loop or switch\", &token->location);\n+\t  error_at (token->location, \"break statement not within loop or switch\");\n \t  break;\n \tdefault:\n \t  gcc_assert ((in_statement & IN_SWITCH_STMT)\n \t\t      || in_statement == IN_ITERATION_STMT);\n \t  statement = finish_break_stmt ();\n \t  break;\n \tcase IN_OMP_BLOCK:\n-\t  error (\"%Hinvalid exit from OpenMP structured block\", &token->location);\n+\t  error_at (token->location, \"invalid exit from OpenMP structured block\");\n \t  break;\n \tcase IN_OMP_FOR:\n-\t  error (\"%Hbreak statement used with OpenMP for loop\", &token->location);\n+\t  error_at (token->location, \"break statement used with OpenMP for loop\");\n \t  break;\n \t}\n       cp_parser_require (parser, CPP_SEMICOLON, \"%<;%>\");\n@@ -7776,14 +7787,14 @@ cp_parser_jump_statement (cp_parser* parser)\n       switch (parser->in_statement & ~(IN_SWITCH_STMT | IN_IF_STMT))\n \t{\n \tcase 0:\n-\t  error (\"%Hcontinue statement not within a loop\", &token->location);\n+\t  error_at (token->location, \"continue statement not within a loop\");\n \t  break;\n \tcase IN_ITERATION_STMT:\n \tcase IN_OMP_FOR:\n \t  statement = finish_continue_stmt ();\n \t  break;\n \tcase IN_OMP_BLOCK:\n-\t  error (\"%Hinvalid exit from OpenMP structured block\", &token->location);\n+\t  error_at (token->location, \"invalid exit from OpenMP structured block\");\n \t  break;\n \tdefault:\n \t  gcc_unreachable ();\n@@ -8185,7 +8196,7 @@ cp_parser_block_declaration (cp_parser *parser,\n   else if (token1->keyword == RID_LABEL)\n     {\n       cp_lexer_consume_token (parser->lexer);\n-      error (\"%H%<__label__%> not at the beginning of a block\", &token1->location);\n+      error_at (token1->location, \"%<__label__%> not at the beginning of a block\");\n       cp_parser_skip_to_end_of_statement (parser);\n       /* If the next token is now a `;', consume it.  */\n       if (cp_lexer_next_token_is (parser->lexer, CPP_SEMICOLON))\n@@ -8322,8 +8333,9 @@ cp_parser_simple_declaration (cp_parser* parser,\n \t  if (cp_lexer_next_token_is (parser->lexer, CPP_COMMA))\n \t    {\n \t      cp_token *token = cp_lexer_peek_token (parser->lexer);\n-\t      error (\"%Hmixing declarations and function-definitions is forbidden\",\n-\t\t     &token->location);\n+\t      error_at (token->location,\n+\t\t\t\"mixing\"\n+\t\t\t\" declarations and function-definitions is forbidden\");\n \t    }\n \t  /* Otherwise, we're done with the list of declarators.  */\n \t  else\n@@ -8462,7 +8474,7 @@ cp_parser_decl_specifier_seq (cp_parser* parser,\n \tcase RID_FRIEND:\n \t  if (!at_class_scope_p ())\n \t    {\n-\t      error (\"%H%<friend%> used outside of class\", &token->location);\n+\t      error_at (token->location, \"%<friend%> used outside of class\");\n \t      cp_lexer_purge_token (parser->lexer);\n \t    }\n \t  else\n@@ -8516,10 +8528,8 @@ cp_parser_decl_specifier_seq (cp_parser* parser,\n \n               /* Complain about `auto' as a storage specifier, if\n                  we're complaining about C++0x compatibility.  */\n-              warning \n-                (OPT_Wc__0x_compat, \n-                 \"%H%<auto%> will change meaning in C++0x; please remove it\",\n-\t\t &token->location);\n+              warning_at (token->location, OPT_Wc__0x_compat, \"%<auto%>\"\n+\t\t\t  \" will change meaning in C++0x; please remove it\");\n \n               /* Set the storage class anyway.  */\n               cp_parser_set_storage_class (parser, decl_specs, RID_AUTO,\n@@ -8637,8 +8647,8 @@ cp_parser_decl_specifier_seq (cp_parser* parser,\n   /* Don't allow a friend specifier with a class definition.  */\n   if (decl_specs->specs[(int) ds_friend] != 0\n       && (*declares_class_or_enum & 2))\n-    error (\"%Hclass definition may not be declared a friend\",\n-\t    &start_token->location);\n+    error_at (start_token->location,\n+\t      \"class definition may not be declared a friend\");\n }\n \n /* Parse an (optional) storage-class-specifier.\n@@ -8707,7 +8717,7 @@ cp_parser_function_specifier_opt (cp_parser* parser,\n \n \t A member function template shall not be virtual.  */\n       if (PROCESSING_REAL_TEMPLATE_DECL_P ())\n-\terror (\"%Htemplates may not be %<virtual%>\", &token->location);\n+\terror_at (token->location, \"templates may not be %<virtual%>\");\n       else if (decl_specs)\n \t++decl_specs->specs[(int) ds_virtual];\n       break;\n@@ -9198,8 +9208,8 @@ cp_parser_mem_initializer_list (cp_parser* parser)\n   /* Let the semantic analysis code know that we are starting the\n      mem-initializer-list.  */\n   if (!DECL_CONSTRUCTOR_P (current_function_decl))\n-    error (\"%Honly constructors take base initializers\",\n-\t   &token->location);\n+    error_at (token->location,\n+\t      \"only constructors take base initializers\");\n \n   /* Loop through the list.  */\n   while (true)\n@@ -9220,8 +9230,9 @@ cp_parser_mem_initializer_list (cp_parser* parser)\n           if (mem_initializer != error_mark_node\n               && !TYPE_P (TREE_PURPOSE (mem_initializer)))\n             {\n-              error (\"%Hcannot expand initializer for member %<%D%>\",\n-                     &token->location, TREE_PURPOSE (mem_initializer));\n+              error_at (token->location,\n+\t\t\t\"cannot expand initializer for member %<%D%>\",\n+\t\t\tTREE_PURPOSE (mem_initializer));\n               mem_initializer = error_mark_node;\n             }\n \n@@ -9342,9 +9353,9 @@ cp_parser_mem_initializer_id (cp_parser* parser)\n   /* `typename' is not allowed in this context ([temp.res]).  */\n   if (cp_lexer_next_token_is_keyword (parser->lexer, RID_TYPENAME))\n     {\n-      error (\"%Hkeyword %<typename%> not allowed in this context (a qualified \"\n-\t     \"member initializer is implicitly a type)\",\n-\t     &token->location);\n+      error_at (token->location, \n+\t\t\"keyword %<typename%> not allowed in this context (a qualified \"\n+\t\t\"member initializer is implicitly a type)\");\n       cp_lexer_consume_token (parser->lexer);\n     }\n   /* Look for the optional `::' operator.  */\n@@ -9873,11 +9884,12 @@ cp_parser_template_parameter (cp_parser* parser, bool *is_non_type,\n \tid_declarator = id_declarator->declarator;\n       \n       if (id_declarator && id_declarator->kind == cdk_id)\n-\terror (\"%Htemplate parameter pack %qD cannot have a default argument\",\n-\t       &start_token->location, id_declarator->u.id.unqualified_name);\n+\terror_at (start_token->location,\n+\t\t  \"template parameter pack %qD cannot have a default argument\",\n+\t\t  id_declarator->u.id.unqualified_name);\n       else\n-\terror (\"%Htemplate parameter pack cannot have a default argument\",\n-\t       &start_token->location);\n+\terror_at (start_token->location,\n+\t\t  \"template parameter pack cannot have a default argument\");\n       \n       /* Parse the default argument, but throw away the result.  */\n       cp_parser_default_argument (parser, /*template_parm_p=*/true);\n@@ -9971,11 +9983,13 @@ cp_parser_type_parameter (cp_parser* parser, bool *is_parameter_pack)\n             if (*is_parameter_pack)\n               {\n                 if (identifier)\n-                  error (\"%Htemplate parameter pack %qD cannot have a \"\n-\t\t\t \"default argument\", &token->location, identifier);\n+                  error_at (token->location,\n+\t\t\t    \"template parameter pack %qD cannot have a \"\n+\t\t\t    \"default argument\", identifier);\n                 else\n-                  error (\"%Htemplate parameter packs cannot have \"\n-\t\t\t \"default arguments\", &token->location);\n+                  error_at (token->location,\n+\t\t\t    \"template parameter packs cannot have \"\n+\t\t\t    \"default arguments\");\n                 default_argument = NULL_TREE;\n               }\n \t    pop_deferring_access_checks ();\n@@ -10077,13 +10091,13 @@ cp_parser_type_parameter (cp_parser* parser, bool *is_parameter_pack)\n             if (*is_parameter_pack)\n               {\n                 if (identifier)\n-                  error (\"%Htemplate parameter pack %qD cannot \"\n-\t\t\t \"have a default argument\",\n-\t\t\t &token->location, identifier);\n+                  error_at (token->location,\n+\t\t\t    \"template parameter pack %qD cannot \"\n+\t\t\t    \"have a default argument\",\n+\t\t\t    identifier);\n                 else\n-                  error (\"%Htemplate parameter packs cannot \"\n-\t\t\t \"have default arguments\",\n-\t\t\t &token->location);\n+                  error_at (token->location, \"template parameter packs cannot \"\n+\t\t\t    \"have default arguments\");\n                 default_argument = NULL_TREE;\n               }\n \t    pop_deferring_access_checks ();\n@@ -10305,8 +10319,7 @@ cp_parser_template_id (cp_parser *parser,\n \t user, as opposed to simply marking the tentative parse as\n \t failed?  */\n       if (cp_parser_error_occurred (parser) && template_id != error_mark_node)\n-\terror (\"%Hparse error in template argument list\",\n-\t       &token->location);\n+\terror_at (token->location, \"parse error in template argument list\");\n     }\n \n   pop_deferring_access_checks ();\n@@ -10420,9 +10433,9 @@ cp_parser_template_name (cp_parser* parser,\n \t  cp_token_position start = 0;\n \n \t  /* Explain what went wrong.  */\n-\t  error (\"%Hnon-template %qD used as template\",\n-\t\t &token->location, identifier);\n-\t  inform (input_location, \"use %<%T::template %D%> to indicate that it is a template\",\n+\t  error_at (token->location, \"non-template %qD used as template\",\n+\t\t    identifier);\n+\t  inform (token->location, \"use %<%T::template %D%> to indicate that it is a template\",\n \t\t  parser->scope, identifier);\n \t  /* If parsing tentatively, find the location of the \"<\" token.  */\n \t  if (cp_parser_simulate_error (parser))\n@@ -10555,8 +10568,8 @@ cp_parser_template_argument_list (cp_parser* parser)\n \t  if (argument == error_mark_node)\n \t    {\n \t      cp_token *token = cp_lexer_peek_token (parser->lexer);\n-\t      error (\"%Hexpected parameter pack before %<...%>\",\n-\t\t     &token->location);\n+\t      error_at (token->location,\n+\t\t\t\"expected parameter pack before %<...%>\");\n \t    }\n           /* Consume the `...' token. */\n           cp_lexer_consume_token (parser->lexer);\n@@ -10965,7 +10978,7 @@ cp_parser_explicit_specialization (cp_parser* parser)\n      linkage.  */\n   if (current_lang_name == lang_name_c)\n     {\n-      error (\"%Htemplate specialization with C linkage\", &token->location);\n+      error_at (token->location, \"template specialization with C linkage\");\n       /* Give it C++ linkage to avoid confusing other parts of the\n \t front end.  */\n       push_lang_context (lang_name_cplusplus);\n@@ -12157,7 +12170,7 @@ cp_parser_namespace_name (cp_parser* parser)\n       || TREE_CODE (namespace_decl) != NAMESPACE_DECL)\n     {\n       if (!cp_parser_uncommitted_to_tentative_parse_p (parser))\n-\terror (\"%H%qD is not a namespace-name\", &token->location, identifier);\n+\terror_at (token->location, \"%qD is not a namespace-name\", identifier);\n       cp_parser_error (parser, \"expected namespace-name\");\n       namespace_decl = error_mark_node;\n     }\n@@ -12284,7 +12297,7 @@ cp_parser_namespace_alias_definition (cp_parser* parser)\n   if (!cp_parser_uncommitted_to_tentative_parse_p (parser)\n       && cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE)) \n     {\n-      error (\"%H%<namespace%> definition is not allowed here\", &token->location);\n+      error_at (token->location, \"%<namespace%> definition is not allowed here\");\n       /* Skip the definition.  */\n       cp_lexer_consume_token (parser->lexer);\n       if (cp_parser_skip_to_closing_brace (parser))\n@@ -12424,8 +12437,8 @@ cp_parser_using_declaration (cp_parser* parser,\n     /* [namespace.udecl]\n \n        A using declaration shall not name a template-id.  */\n-    error (\"%Ha template-id may not appear in a using-declaration\",\n-            &token->location);\n+    error_at (token->location,\n+\t      \"a template-id may not appear in a using-declaration\");\n   else\n     {\n       if (at_class_scope_p ())\n@@ -12801,12 +12814,12 @@ cp_parser_init_declarator (cp_parser* parser,\n \t  /* Neither attributes nor an asm-specification are allowed\n \t     on a function-definition.  */\n \t  if (asm_specification)\n-\t    error (\"%Han asm-specification is not allowed \"\n-\t\t   \"on a function-definition\",\n-\t\t   &asm_spec_start_token->location);\n+\t    error_at (asm_spec_start_token->location,\n+\t\t      \"an asm-specification is not allowed \"\n+\t\t      \"on a function-definition\");\n \t  if (attributes)\n-\t    error (\"%Hattributes are not allowed on a function-definition\",\n-\t\t   &attributes_start_token->location);\n+\t    error_at (attributes_start_token->location,\n+\t\t      \"attributes are not allowed on a function-definition\");\n \t  /* This is a function-definition.  */\n \t  *function_definition_p = true;\n \n@@ -12958,8 +12971,8 @@ cp_parser_init_declarator (cp_parser* parser,\n \t\t  know what the user intended, so just silently\n \t\t  consume the initializer.  */\n \t       if (decl != error_mark_node)\n-\t\t error (\"%Hinitializer provided for function\",\n-\t\t\t&initializer_start_token->location);\n+\t\t error_at (initializer_start_token->location,\n+\t\t\t   \"initializer provided for function\");\n \t       cp_parser_skip_to_closing_parenthesis (parser,\n \t\t\t\t\t\t      /*recovering=*/true,\n \t\t\t\t\t\t      /*or_comma=*/false,\n@@ -13378,8 +13391,8 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t\t in function scopes.  */\n \t      else if (!parser->in_function_body)\n \t\t{\n-\t\t  error (\"%Harray bound is not an integer constant\",\n-\t\t\t &token->location);\n+\t\t  error_at (token->location,\n+\t\t\t    \"array bound is not an integer constant\");\n \t\t  bounds = error_mark_node;\n \t\t}\n \t      else if (processing_template_decl && !error_operand_p (bounds))\n@@ -13497,10 +13510,10 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t\t\t\t\t      /*only_current_p=*/false);\n \t\t/* If that failed, the declarator is invalid.  */\n \t\tif (TREE_CODE (type) == TYPENAME_TYPE)\n-\t\t  error (\"%H%<%T::%E%> is not a type\",\n-\t\t\t &declarator_id_start_token->location,\n-\t\t\t TYPE_CONTEXT (qualifying_scope),\n-\t\t\t TYPE_IDENTIFIER (qualifying_scope));\n+\t\t  error_at (declarator_id_start_token->location,\n+\t\t\t    \"%<%T::%E%> is not a type\",\n+\t\t\t    TYPE_CONTEXT (qualifying_scope),\n+\t\t\t    TYPE_IDENTIFIER (qualifying_scope));\n \t\tqualifying_scope = type;\n \t      }\n \n@@ -13524,9 +13537,10 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t\t\tif (qualifying_scope\n \t\t\t    && CLASSTYPE_USE_TEMPLATE (name_type))\n \t\t\t  {\n-\t\t\t    error (\"%Hinvalid use of constructor as a template\",\n-\t\t\t\t   &declarator_id_start_token->location);\n-\t\t\t    inform (input_location, \"use %<%T::%D%> instead of %<%T::%D%> to \"\n+\t\t\t    error_at (declarator_id_start_token->location,\n+\t\t\t\t      \"invalid use of constructor as a template\");\n+\t\t\t    inform (declarator_id_start_token->location,\n+\t\t\t\t    \"use %<%T::%D%> instead of %<%T::%D%> to \"\n \t\t\t\t    \"name the constructor in a qualified name\",\n \t\t\t\t    class_type,\n \t\t\t\t    DECL_NAME (TYPE_TI_TEMPLATE (class_type)),\n@@ -13700,7 +13714,7 @@ cp_parser_ptr_operator (cp_parser* parser,\n \t  code = INDIRECT_REF;\n \n \t  if (TREE_CODE (parser->scope) == NAMESPACE_DECL)\n-\t    error (\"%H%qD is a namespace\", &token->location, parser->scope);\n+\t    error_at (token->location, \"%qD is a namespace\", parser->scope);\n \t  else\n \t    {\n \t      /* The type of which the member is a member is given by the\n@@ -13775,7 +13789,7 @@ cp_parser_cv_qualifier_seq_opt (cp_parser* parser)\n \n       if (cv_quals & cv_qualifier)\n \t{\n-\t  error (\"%Hduplicate cv-qualifier\", &token->location);\n+\t  error_at (token->location, \"duplicate cv-qualifier\");\n \t  cp_lexer_purge_token (parser->lexer);\n \t}\n       else\n@@ -14488,7 +14502,7 @@ cp_parser_parameter_declaration (cp_parser *parser,\n \t\t  /* If we run out of tokens, issue an error message.  */\n \t\tcase CPP_EOF:\n \t\tcase CPP_PRAGMA_EOL:\n-\t\t  error (\"%Hfile ends in default argument\", &token->location);\n+\t\t  error_at (token->location, \"file ends in default argument\");\n \t\t  done = true;\n \t\t  break;\n \n@@ -14537,30 +14551,33 @@ cp_parser_parameter_declaration (cp_parser *parser,\n \t    warning (0, \"deprecated use of default argument for parameter of non-function\");\n \t  else\n \t    {\n-\t      error (\"%Hdefault arguments are only \"\n-\t\t     \"permitted for function parameters\",\n-\t\t     &token->location);\n+\t      error_at (token->location,\n+\t\t\t\"default arguments are only \"\n+\t\t\t\"permitted for function parameters\");\n \t      default_argument = NULL_TREE;\n \t    }\n \t}\n       else if ((declarator && declarator->parameter_pack_p)\n \t       || (decl_specifiers.type\n \t\t   && PACK_EXPANSION_P (decl_specifiers.type)))\n \t{\n-\t  const char* kind = template_parm_p? \"template \" : \"\";\n-\t  \n \t  /* Find the name of the parameter pack.  */     \n \t  cp_declarator *id_declarator = declarator;\n \t  while (id_declarator && id_declarator->kind != cdk_id)\n \t    id_declarator = id_declarator->declarator;\n \t  \n \t  if (id_declarator && id_declarator->kind == cdk_id)\n-\t    error (\"%H%sparameter pack %qD cannot have a default argument\",\n-\t\t   &declarator_token_start->location,\n-\t\t   kind, id_declarator->u.id.unqualified_name);\n+\t    error_at (declarator_token_start->location,\n+\t\t      template_parm_p \n+\t\t      ? \"template parameter pack %qD\"\n+\t\t      \" cannot have a default argument\"\n+\t\t      : \"parameter pack %qD cannot have a default argument\",\n+\t\t      id_declarator->u.id.unqualified_name);\n \t  else\n-\t    error (\"%H%sparameter pack cannot have a default argument\",\n-\t\t   &declarator_token_start->location, kind);\n+\t    error_at (declarator_token_start->location,\n+\t\t      template_parm_p \n+\t\t      ? \"template parameter pack cannot have a default argument\"\n+\t\t      : \"parameter pack cannot have a default argument\");\n \t  \n \t  default_argument = NULL_TREE;\n \t}\n@@ -14982,8 +14999,8 @@ cp_parser_class_name (cp_parser *parser,\n \t\t\t\t\tidentifier_token->location);\n \t  if (ambiguous_decls)\n \t    {\n-\t      error (\"%Hreference to %qD is ambiguous\",\n-\t\t     &identifier_token->location, identifier);\n+\t      error_at (identifier_token->location,\n+\t\t\t\"reference to %qD is ambiguous\", identifier);\n \t      print_candidates (ambiguous_decls);\n \t      if (cp_parser_parsing_tentatively (parser))\n \t\t{\n@@ -15448,8 +15465,9 @@ cp_parser_class_head (cp_parser* parser,\n       /* Reject typedef-names in class heads.  */\n       if (!DECL_IMPLICIT_TYPEDEF_P (type))\n \t{\n-\t  error (\"%Hinvalid class name in declaration of %qD\",\n-\t\t &type_start_token->location, type);\n+\t  error_at (type_start_token->location,\n+\t\t    \"invalid class name in declaration of %qD\",\n+\t\t    type);\n \t  type = NULL_TREE;\n \t  goto done;\n \t}\n@@ -15461,14 +15479,14 @@ cp_parser_class_head (cp_parser* parser,\n       if (scope && !is_ancestor (scope, nested_name_specifier))\n \t{\n \t  if (at_namespace_scope_p ())\n-\t    error (\"%Hdeclaration of %qD in namespace %qD which does not \"\n-\t\t   \"enclose %qD\",\n-\t\t   &type_start_token->location,\n-\t\t   type, scope, nested_name_specifier);\n+\t    error_at (type_start_token->location,\n+\t\t      \"declaration of %qD in namespace %qD which does not \"\n+\t\t      \"enclose %qD\",\n+\t\t      type, scope, nested_name_specifier);\n \t  else\n-\t    error (\"%Hdeclaration of %qD in %qD which does not enclose %qD\",\n-\t\t   &type_start_token->location,\n-\t\t   type, scope, nested_name_specifier);\n+\t    error_at (type_start_token->location,\n+\t\t      \"declaration of %qD in %qD which does not enclose %qD\",\n+\t\t      type, scope, nested_name_specifier);\n \t  type = NULL_TREE;\n \t  goto done;\n \t}\n@@ -15480,8 +15498,8 @@ cp_parser_class_head (cp_parser* parser,\n \t class member of a namespace outside of its namespace.  */\n       if (scope == nested_name_specifier)\n \t{\n-\t  permerror (input_location, \"%Hextra qualification not allowed\",\n-\t\t     &nested_name_specifier_token_start->location);\n+\t  permerror (nested_name_specifier_token_start->location,\n+\t\t     \"extra qualification not allowed\");\n \t  nested_name_specifier = NULL_TREE;\n \t  num_templates = 0;\n \t}\n@@ -15492,8 +15510,8 @@ cp_parser_class_head (cp_parser* parser,\n       && parser->num_template_parameter_lists == 0\n       && template_id_p)\n     {\n-      error (\"%Han explicit specialization must be preceded by %<template <>%>\",\n-\t     &type_start_token->location);\n+      error_at (type_start_token->location,\n+\t\t\"an explicit specialization must be preceded by %<template <>%>\");\n       invalid_explicit_specialization_p = true;\n       /* Take the same action that would have been taken by\n \t cp_parser_explicit_specialization.  */\n@@ -15522,8 +15540,8 @@ cp_parser_class_head (cp_parser* parser,\n \t  && (DECL_FUNCTION_TEMPLATE_P (TREE_OPERAND (id, 0))\n \t      || TREE_CODE (TREE_OPERAND (id, 0)) == OVERLOAD))\n \t{\n-\t  error (\"%Hfunction template %qD redeclared as a class template\",\n-\t\t &type_start_token->location, id);\n+\t  error_at (type_start_token->location,\n+\t\t    \"function template %qD redeclared as a class template\", id);\n \t  type = error_mark_node;\n \t}\n       else\n@@ -15604,10 +15622,10 @@ cp_parser_class_head (cp_parser* parser,\n      that's an error.  */\n   if (type != error_mark_node && COMPLETE_TYPE_P (type))\n     {\n-      error (\"%Hredefinition of %q#T\",\n-\t     &type_start_token->location, type);\n-      error (\"%Hprevious definition of %q+#T\",\n-\t     &type_start_token->location, type);\n+      error_at (type_start_token->location, \"redefinition of %q#T\",\n+\t\ttype);\n+      error_at (type_start_token->location, \"previous definition of %q+#T\",\n+\t\ttype);\n       type = NULL_TREE;\n       goto done;\n     }\n@@ -15874,8 +15892,8 @@ cp_parser_member_declaration (cp_parser* parser)\n \t      /* If the `friend' keyword was present, the friend must\n \t\t be introduced with a class-key.  */\n \t       if (!declares_class_or_enum)\n-\t\t error (\"%Ha class-key must be used when declaring a friend\",\n-                        &decl_spec_token_start->location);\n+\t\t error_at (decl_spec_token_start->location,\n+\t\t\t   \"a class-key must be used when declaring a friend\");\n \t       /* In this case:\n \n \t\t    template <typename T> struct A {\n@@ -15889,8 +15907,9 @@ cp_parser_member_declaration (cp_parser* parser)\n \t\t   && TYPE_P (decl_specifiers.type))\n \t\t type = decl_specifiers.type;\n \t       if (!type || !TYPE_P (type))\n-\t\t error (\"%Hfriend declaration does not name a class or \"\n-\t\t\t\"function\", &decl_spec_token_start->location);\n+\t\t error_at (decl_spec_token_start->location,\n+\t\t\t   \"friend declaration does not name a class or \"\n+\t\t\t   \"function\");\n \t       else\n \t\t make_friend_class (current_class_type, type,\n \t\t\t\t    /*complain=*/true);\n@@ -16070,8 +16089,8 @@ cp_parser_member_declaration (cp_parser* parser)\n \t\t     standard, since a pure function may be defined\n \t\t     outside of the class-specifier.  */\n \t\t  if (initializer)\n-\t\t    error (\"%Hpure-specifier on function-definition\",\n-\t\t\t   &initializer_token_start->location);\n+\t\t    error_at (initializer_token_start->location,\n+\t\t\t      \"pure-specifier on function-definition\");\n \t\t  decl = cp_parser_save_member_function_body (parser,\n \t\t\t\t\t\t\t      &decl_specifiers,\n \t\t\t\t\t\t\t      declarator,\n@@ -16179,7 +16198,7 @@ cp_parser_pure_specifier (cp_parser* parser)\n     }\n   if (PROCESSING_REAL_TEMPLATE_DECL_P ())\n     {\n-      error (\"%Htemplates may not be %<virtual%>\", &token->location);\n+      error_at (token->location, \"templates may not be %<virtual%>\");\n       return error_mark_node;\n     }\n \n@@ -16383,12 +16402,12 @@ cp_parser_base_specifier (cp_parser* parser)\n     {\n       token = cp_lexer_peek_token (parser->lexer);\n       if (!processing_template_decl)\n-\terror (\"%Hkeyword %<typename%> not allowed outside of templates\",\n-\t       &token->location);\n+\terror_at (token->location,\n+\t\t  \"keyword %<typename%> not allowed outside of templates\");\n       else\n-\terror (\"%Hkeyword %<typename%> not allowed in this context \"\n-\t       \"(the base class is implicitly a type)\",\n-\t       &token->location);\n+\terror_at (token->location,\n+\t\t  \"keyword %<typename%> not allowed in this context \"\n+\t\t  \"(the base class is implicitly a type)\");\n       cp_lexer_consume_token (parser->lexer);\n     }\n \n@@ -17288,8 +17307,8 @@ cp_parser_lookup_name (cp_parser *parser, tree name,\n \t cp_parser_error, so we incorporate its actions directly.  */\n       if (!cp_parser_simulate_error (parser))\n \t{\n-\t  error (\"%Hreference to %qD is ambiguous\",\n-\t\t &name_location, name);\n+\t  error_at (name_location, \"reference to %qD is ambiguous\",\n+\t\t    name);\n \t  print_candidates (decl);\n \t}\n       return error_mark_node;\n@@ -17489,7 +17508,7 @@ cp_parser_check_template_parameters (cp_parser* parser,\n      something like:\n \n      template <class T> template <class U> void S::f();  */\n-  error (\"%Htoo many template-parameter-lists\", &location);\n+  error_at (location, \"too many template-parameter-lists\");\n   return false;\n }\n \n@@ -17763,8 +17782,8 @@ cp_parser_function_definition_after_declarator (cp_parser* parser,\n \t returned.  */\n       cp_parser_identifier (parser);\n       /* Issue an error message.  */\n-      error (\"%Hnamed return values are no longer supported\",\n-\t     &token->location);\n+      error_at (token->location,\n+\t\t\"named return values are no longer supported\");\n       /* Skip tokens until we reach the start of the function body.  */\n       while (true)\n \t{\n@@ -17838,8 +17857,8 @@ cp_parser_template_declaration_after_export (cp_parser* parser, bool member_p)\n       /* 14.5.2.2 [temp.mem]\n \n          A local class shall not have member templates.  */\n-      error (\"%Hinvalid declaration of member template in local class\",\n-\t     &token->location);\n+      error_at (token->location,\n+\t\t\"invalid declaration of member template in local class\");\n       cp_parser_skip_to_end_of_block_or_statement (parser);\n       return;\n     }\n@@ -17848,7 +17867,7 @@ cp_parser_template_declaration_after_export (cp_parser* parser, bool member_p)\n      A template ... shall not have C linkage.  */\n   if (current_lang_name == lang_name_c)\n     {\n-      error (\"%Htemplate with C linkage\", &token->location);\n+      error_at (token->location, \"template with C linkage\");\n       /* Give it C++ linkage to avoid confusing other parts of the\n \t front end.  */\n       push_lang_context (lang_name_cplusplus);\n@@ -17995,8 +18014,8 @@ cp_parser_single_declaration (cp_parser* parser,\n   /* There are no template typedefs.  */\n   if (decl_specifiers.specs[(int) ds_typedef])\n     {\n-      error (\"%Htemplate declaration of %qs\",\n-\t     &decl_spec_token_start->location, \"typedef\");\n+      error_at (decl_spec_token_start->location,\n+\t\t\"template declaration of %<typedef%>\");\n       decl = error_mark_node;\n     }\n \n@@ -18059,8 +18078,8 @@ cp_parser_single_declaration (cp_parser* parser,\n         && explicit_specialization_p\n         && decl_specifiers.storage_class != sc_none)\n       {\n-        error (\"%Hexplicit template specialization cannot have a storage class\",\n-\t       &decl_spec_token_start->location);\n+        error_at (decl_spec_token_start->location,\n+\t\t  \"explicit template specialization cannot have a storage class\");\n         decl = error_mark_node;\n       }\n     }\n@@ -18288,9 +18307,8 @@ cp_parser_enclosed_template_argument_list (cp_parser* parser)\n \t    global source location is still on the token before the\n \t    '>>', so we need to say explicitly where we want it.  */\n \t  cp_token *token = cp_lexer_peek_token (parser->lexer);\n-\t  error (\"%H%<>>%> should be %<> >%> \"\n-\t\t \"within a nested template argument list\",\n-\t\t &token->location);\n+\t  error_at (token->location, \"%<>>%> should be %<> >%> \"\n+\t\t    \"within a nested template argument list\");\n \n \t  token->type = CPP_GREATER;\n \t}\n@@ -18301,8 +18319,9 @@ cp_parser_enclosed_template_argument_list (cp_parser* parser)\n \t    Same deal about the token location, but here we can get it\n \t    right by consuming the '>>' before issuing the diagnostic.  */\n \t  cp_token *token = cp_lexer_consume_token (parser->lexer);\n-\t  error (\"%Hspurious %<>>%>, use %<>%> to terminate \"\n-\t\t \"a template argument list\", &token->location);\n+\t  error_at (token->location,\n+\t\t    \"spurious %<>>%>, use %<>%> to terminate \"\n+\t\t    \"a template argument list\");\n \t}\n     }\n   else\n@@ -18638,8 +18657,8 @@ cp_parser_set_storage_class (cp_parser *parser,\n \n   if (parser->in_unbraced_linkage_specification_p)\n     {\n-      error (\"%Hinvalid use of %qD in linkage specification\",\n-\t     &location, ridpointers[keyword]);\n+      error_at (location, \"invalid use of %qD in linkage specification\",\n+\t\tridpointers[keyword]);\n       return;\n     }\n   else if (decl_specs->storage_class != sc_none)\n@@ -18651,7 +18670,7 @@ cp_parser_set_storage_class (cp_parser *parser,\n   if ((keyword == RID_EXTERN || keyword == RID_STATIC)\n       && decl_specs->specs[(int) ds_thread])\n     {\n-      error (\"%H%<__thread%> before %qD\", &location, ridpointers[keyword]);\n+      error_at (location, \"%<__thread%> before %qD\", ridpointers[keyword]);\n       decl_specs->specs[(int) ds_thread] = 0;\n     }\n \n@@ -18993,7 +19012,7 @@ cp_parser_check_access_in_redeclaration (tree decl, location_t location)\n        != (current_access_specifier == access_private_node))\n       || (TREE_PROTECTED (decl)\n \t  != (current_access_specifier == access_protected_node)))\n-    error (\"%H%qD redeclared with different access\", &location, decl);\n+    error_at (location, \"%qD redeclared with different access\", decl);\n }\n \n /* Look for the `template' keyword, as a syntactic disambiguator.\n@@ -19011,8 +19030,9 @@ cp_parser_optional_template_keyword (cp_parser *parser)\n       if (!processing_template_decl)\n \t{\n \t  cp_token *token = cp_lexer_peek_token (parser->lexer);\n-\t  error (\"%H%<template%> (as a disambiguator) is only allowed \"\n-\t\t \"within templates\", &token->location);\n+\t  error_at (token->location,\n+\t\t    \"%<template%> (as a disambiguator) is only allowed \"\n+\t\t    \"within templates\");\n \t  /* If this part of the token stream is rescanned, the same\n \t     error message would be generated.  So, we purge the token\n \t     from the stream.  */\n@@ -19277,8 +19297,9 @@ cp_parser_objc_expression (cp_parser* parser)\n \t  break;\n \t}\n     default:\n-      error (\"%Hmisplaced %<@%D%> Objective-C++ construct\",\n-\t     &kwd->location, kwd->u.value);\n+      error_at (kwd->location,\n+\t\t\"misplaced %<@%D%> Objective-C++ construct\",\n+\t\tkwd->u.value);\n       cp_parser_skip_to_end_of_block_or_statement (parser);\n     }\n \n@@ -19421,8 +19442,8 @@ cp_parser_objc_encode_expression (cp_parser* parser)\n \n   if (!type)\n     {\n-      error (\"%H%<@encode%> must specify a type as an argument\",\n-\t     &token->location);\n+      error_at (token->location, \n+\t\t\"%<@encode%> must specify a type as an argument\");\n       return error_mark_node;\n     }\n \n@@ -19738,7 +19759,7 @@ cp_parser_objc_selector (cp_parser* parser)\n \n   if (!cp_parser_objc_selector_p (token->type))\n     {\n-      error (\"%Hinvalid Objective-C++ selector name\", &token->location);\n+      error_at (token->location, \"invalid Objective-C++ selector name\");\n       return error_mark_node;\n     }\n \n@@ -20069,7 +20090,7 @@ cp_parser_objc_protocol_declaration (cp_parser* parser)\n   if (cp_lexer_next_token_is_not (parser->lexer, CPP_NAME))\n     {\n       tok = cp_lexer_peek_token (parser->lexer);\n-      error (\"%Hidentifier expected after %<@protocol%>\", &tok->location);\n+      error_at (tok->location, \"identifier expected after %<@protocol%>\");\n       goto finish;\n     }\n \n@@ -20205,8 +20226,8 @@ cp_parser_objc_declaration (cp_parser* parser)\n       cp_parser_objc_end_implementation (parser);\n       break;\n     default:\n-      error (\"%Hmisplaced %<@%D%> Objective-C++ construct\",\n-\t     &kwd->location, kwd->u.value);\n+      error_at (kwd->location, \"misplaced %<@%D%> Objective-C++ construct\",\n+\t\tkwd->u.value);\n       cp_parser_skip_to_end_of_block_or_statement (parser);\n     }\n }\n@@ -20338,8 +20359,8 @@ cp_parser_objc_statement (cp_parser * parser) {\n     case RID_AT_THROW:\n       return cp_parser_objc_throw_statement (parser);\n     default:\n-      error (\"%Hmisplaced %<@%D%> Objective-C++ construct\",\n-\t     &kwd->location, kwd->u.value);\n+      error_at (kwd->location, \"misplaced %<@%D%> Objective-C++ construct\",\n+\t       kwd->u.value);\n       cp_parser_skip_to_end_of_block_or_statement (parser);\n     }\n \n@@ -20431,7 +20452,7 @@ check_no_duplicate_clause (tree clauses, enum omp_clause_code code,\n   for (c = clauses; c ; c = OMP_CLAUSE_CHAIN (c))\n     if (OMP_CLAUSE_CODE (c) == code)\n       {\n-\terror (\"%Htoo many %qs clauses\", &location, name);\n+\terror_at (location, \"too many %qs clauses\", name);\n \tbreak;\n       }\n }\n@@ -20545,8 +20566,7 @@ cp_parser_omp_clause_collapse (cp_parser *parser, tree list, location_t location\n       || (n = tree_low_cst (num, 0)) <= 0\n       || (int) n != n)\n     {\n-      error (\"%Hcollapse argument needs positive constant integer expression\",\n-\t     &loc);\n+      error_at (loc, \"collapse argument needs positive constant integer expression\");\n       return list;\n     }\n \n@@ -20834,11 +20854,11 @@ cp_parser_omp_clause_schedule (cp_parser *parser, tree list, location_t location\n       if (t == error_mark_node)\n \tgoto resync_fail;\n       else if (OMP_CLAUSE_SCHEDULE_KIND (c) == OMP_CLAUSE_SCHEDULE_RUNTIME)\n-\terror (\"%Hschedule %<runtime%> does not take \"\n-\t       \"a %<chunk_size%> parameter\", &token->location);\n+\terror_at (token->location, \"schedule %<runtime%> does not take \"\n+\t\t  \"a %<chunk_size%> parameter\");\n       else if (OMP_CLAUSE_SCHEDULE_KIND (c) == OMP_CLAUSE_SCHEDULE_AUTO)\n-\terror (\"%Hschedule %<auto%> does not take \"\n-\t       \"a %<chunk_size%> parameter\", &token->location);\n+\terror_at (token->location, \"schedule %<auto%> does not take \"\n+\t\t  \"a %<chunk_size%> parameter\");\n       else\n \tOMP_CLAUSE_SCHEDULE_CHUNK_EXPR (c) = t;\n \n@@ -20985,7 +21005,7 @@ cp_parser_omp_all_clauses (cp_parser *parser, unsigned int mask,\n \t  /* Remove the invalid clause(s) from the list to avoid\n \t     confusing the rest of the compiler.  */\n \t  clauses = prev;\n-\t  error (\"%H%qs is not valid for %qs\", &token->location, c_name, where);\n+\t  error_at (token->location, \"%qs is not valid for %qs\", c_name, where);\n \t}\n     }\n  saw_error:\n@@ -21533,8 +21553,8 @@ cp_parser_omp_for_loop (cp_parser *parser, tree clauses, tree *par_clauses)\n \t    if (OMP_CLAUSE_CODE (*c) == OMP_CLAUSE_FIRSTPRIVATE\n \t\t&& OMP_CLAUSE_DECL (*c) == real_decl)\n \t      {\n-\t\terror (\"%Hiteration variable %qD should not be firstprivate\",\n-\t\t       &loc, real_decl);\n+\t\terror_at (loc, \"iteration variable %qD\"\n+\t\t\t  \" should not be firstprivate\", real_decl);\n \t\t*c = OMP_CLAUSE_CHAIN (*c);\n \t      }\n \t    else if (OMP_CLAUSE_CODE (*c) == OMP_CLAUSE_LASTPRIVATE\n@@ -21571,12 +21591,13 @@ cp_parser_omp_for_loop (cp_parser *parser, tree clauses, tree *par_clauses)\n \t\tbreak;\n \t      else if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_FIRSTPRIVATE\n \t\t       && OMP_CLAUSE_DECL (c) == decl)\n-\t\terror (\"%Hiteration variable %qD should not be firstprivate\",\n-\t\t       &loc, decl);\n+\t\terror_at (loc, \"iteration variable %qD \"\n+\t\t\t  \"should not be firstprivate\",\n+\t\t\t  decl);\n \t      else if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION\n \t\t       && OMP_CLAUSE_DECL (c) == decl)\n-\t\terror (\"%Hiteration variable %qD should not be reduction\",\n-\t\t       &loc, decl);\n+\t\terror_at (loc, \"iteration variable %qD should not be reduction\",\n+\t\t\t  decl);\n \t    }\n \t  if (c == NULL)\n \t    {\n@@ -21642,7 +21663,7 @@ cp_parser_omp_for_loop (cp_parser *parser, tree clauses, tree *par_clauses)\n \t  else\n \t    {\n \t      loc = cp_lexer_peek_token (parser->lexer)->location;\n-\t      error (\"%Hnot enough collapsed for loops\", &loc);\n+\t      error_at (loc, \"not enough collapsed for loops\");\n \t      collapse_err = true;\n \t      cp_parser_abort_tentative_parse (parser);\n \t      declv = NULL_TREE;\n@@ -21687,8 +21708,8 @@ cp_parser_omp_for_loop (cp_parser *parser, tree clauses, tree *par_clauses)\n \t{\n \t  if (!collapse_err)\n \t    {\n-\t      location_t loc = cp_lexer_peek_token (parser->lexer)->location;\n-\t      error (\"%Hcollapsed loops not perfectly nested\", &loc);\n+\t      error_at (cp_lexer_peek_token (parser->lexer)->location,\n+\t\t\t\"collapsed loops not perfectly nested\");\n \t    }\n \t  collapse_err = true;\n \t  cp_parser_statement_seq_opt (parser, NULL);\n@@ -22102,11 +22123,11 @@ cp_parser_initial_pragma (cp_token *first_token)\n \n       cp_lexer_get_preprocessor_token (NULL, first_token);\n       if (first_token->type != CPP_PRAGMA_EOL)\n-\terror (\"%Hjunk at end of %<#pragma GCC pch_preprocess%>\",\n-               &first_token->location);\n+\terror_at (first_token->location,\n+\t\t  \"junk at end of %<#pragma GCC pch_preprocess%>\");\n     }\n   else\n-    error (\"%Hexpected string literal\", &first_token->location);\n+    error_at (first_token->location, \"expected string literal\");\n \n   /* Skip to the end of the pragma.  */\n   while (first_token->type != CPP_PRAGMA_EOL && first_token->type != CPP_EOF)\n@@ -22139,8 +22160,8 @@ cp_parser_pragma (cp_parser *parser, enum pragma_context context)\n   switch (id)\n     {\n     case PRAGMA_GCC_PCH_PREPROCESS:\n-      error (\"%H%<#pragma GCC pch_preprocess%> must be first\",\n-             &pragma_tok->location);\n+      error_at (pragma_tok->location,\n+\t\t\"%<#pragma GCC pch_preprocess%> must be first\");\n       break;\n \n     case PRAGMA_OMP_BARRIER:\n@@ -22150,8 +22171,8 @@ cp_parser_pragma (cp_parser *parser, enum pragma_context context)\n \t  cp_parser_omp_barrier (parser, pragma_tok);\n \t  return false;\n \tcase pragma_stmt:\n-\t  error (\"%H%<#pragma omp barrier%> may only be \"\n-\t\t \"used in compound statements\", &pragma_tok->location);\n+\t  error_at (pragma_tok->location, \"%<#pragma omp barrier%> may only be \"\n+\t\t    \"used in compound statements\");\n \t  break;\n \tdefault:\n \t  goto bad_stmt;\n@@ -22165,8 +22186,8 @@ cp_parser_pragma (cp_parser *parser, enum pragma_context context)\n \t  cp_parser_omp_flush (parser, pragma_tok);\n \t  return false;\n \tcase pragma_stmt:\n-\t  error (\"%H%<#pragma omp flush%> may only be \"\n-\t\t \"used in compound statements\", &pragma_tok->location);\n+\t  error_at (pragma_tok->location, \"%<#pragma omp flush%> may only be \"\n+\t\t    \"used in compound statements\");\n \t  break;\n \tdefault:\n \t  goto bad_stmt;\n@@ -22180,9 +22201,9 @@ cp_parser_pragma (cp_parser *parser, enum pragma_context context)\n \t  cp_parser_omp_taskwait (parser, pragma_tok);\n \t  return false;\n \tcase pragma_stmt:\n-\t  error (\"%H%<#pragma omp taskwait%> may only be \"\n-\t\t \"used in compound statements\",\n-\t\t &pragma_tok->location);\n+\t  error_at (pragma_tok->location,\n+\t\t    \"%<#pragma omp taskwait%> may only be \"\n+\t\t    \"used in compound statements\");\n \t  break;\n \tdefault:\n \t  goto bad_stmt;\n@@ -22208,8 +22229,9 @@ cp_parser_pragma (cp_parser *parser, enum pragma_context context)\n       return true;\n \n     case PRAGMA_OMP_SECTION:\n-      error (\"%H%<#pragma omp section%> may only be used in \"\n-\t     \"%<#pragma omp sections%> construct\", &pragma_tok->location);\n+      error_at (pragma_tok->location, \n+\t\t\"%<#pragma omp section%> may only be used in \"\n+\t\t\"%<#pragma omp sections%> construct\");\n       break;\n \n     default:"}, {"sha": "1b96ac265a285300a431bd7cb0f86bd186d79b12", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69bc6bff15bc6d1d294a828693091d0265549130/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69bc6bff15bc6d1d294a828693091d0265549130/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=69bc6bff15bc6d1d294a828693091d0265549130", "patch": "@@ -2563,20 +2563,21 @@ qualified_name_lookup_error (tree scope, tree name,\n   else if (TYPE_P (scope))\n     {\n       if (!COMPLETE_TYPE_P (scope))\n-\terror (\"%Hincomplete type %qT used in nested name specifier\",\n-\t       &location, scope);\n+\terror_at (location, \"incomplete type %qT used in nested name specifier\",\n+\t\t  scope);\n       else if (TREE_CODE (decl) == TREE_LIST)\n \t{\n-\t  error (\"%Hreference to %<%T::%D%> is ambiguous\", &location, scope, name);\n+\t  error_at (location, \"reference to %<%T::%D%> is ambiguous\",\n+\t\t    scope, name);\n \t  print_candidates (decl);\n \t}\n       else\n-\terror (\"%H%qD is not a member of %qT\", &location, name, scope);\n+\terror_at (location, \"%qD is not a member of %qT\", name, scope);\n     }\n   else if (scope != global_namespace)\n-    error (\"%H%qD is not a member of %qD\", &location, name, scope);\n+    error_at (location, \"%qD is not a member of %qD\", name, scope);\n   else\n-    error (\"%H%<::%D%> has not been declared\", &location, name);\n+    error_at (location, \"%<::%D%> has not been declared\", name);\n }\n \n /* If FNS is a member function, a set of member functions, or a\n@@ -3984,7 +3985,7 @@ handle_omp_for_class_iterator (int i, location_t locus, tree declv, tree initv,\n     }\n   if (cond == error_mark_node)\n     {\n-      error (\"%Hinvalid controlling predicate\", &elocus);\n+      error_at (elocus, \"invalid controlling predicate\");\n       return true;\n     }\n   diff = build_x_binary_op (MINUS_EXPR, TREE_OPERAND (cond, 1),\n@@ -3994,8 +3995,8 @@ handle_omp_for_class_iterator (int i, location_t locus, tree declv, tree initv,\n     return true;\n   if (TREE_CODE (TREE_TYPE (diff)) != INTEGER_TYPE)\n     {\n-      error (\"%Hdifference between %qE and %qD does not have integer type\",\n-\t     &elocus, TREE_OPERAND (cond, 1), iter);\n+      error_at (elocus, \"difference between %qE and %qD does not have integer type\",\n+\t\tTREE_OPERAND (cond, 1), iter);\n       return true;\n     }\n \n@@ -4089,7 +4090,7 @@ handle_omp_for_class_iterator (int i, location_t locus, tree declv, tree initv,\n \n   if (incr == error_mark_node)\n     {\n-      error (\"%Hinvalid increment expression\", &elocus);\n+      error_at (elocus, \"invalid increment expression\");\n       return true;\n     }\n \n@@ -4216,8 +4217,8 @@ finish_omp_for (location_t locus, tree declv, tree initv, tree condv,\n \n \t  if (decl == NULL)\n \t    {\n-\t      error (\"%Hexpected iteration declaration or initialization\",\n-\t\t     &locus);\n+\t      error_at (locus,\n+\t\t\t\"expected iteration declaration or initialization\");\n \t      return NULL;\n \t    }\n \t}\n@@ -4227,13 +4228,13 @@ finish_omp_for (location_t locus, tree declv, tree initv, tree condv,\n \n       if (cond == NULL)\n \t{\n-\t  error (\"%Hmissing controlling predicate\", &elocus);\n+\t  error_at (elocus, \"missing controlling predicate\");\n \t  return NULL;\n \t}\n \n       if (incr == NULL)\n \t{\n-\t  error (\"%Hmissing increment expression\", &elocus);\n+\t  error_at (elocus, \"missing increment expression\");\n \t  return NULL;\n \t}\n \n@@ -4287,8 +4288,7 @@ finish_omp_for (location_t locus, tree declv, tree initv, tree condv,\n \n       if (!DECL_P (decl))\n \t{\n-\t  error (\"%Hexpected iteration declaration or initialization\",\n-\t\t &elocus);\n+\t  error_at (elocus, \"expected iteration declaration or initialization\");\n \t  return NULL;\n \t}\n \n@@ -4313,7 +4313,7 @@ finish_omp_for (location_t locus, tree declv, tree initv, tree condv,\n       if (!INTEGRAL_TYPE_P (TREE_TYPE (decl))\n \t  && TREE_CODE (TREE_TYPE (decl)) != POINTER_TYPE)\n \t{\n-\t  error (\"%Hinvalid type for iteration variable %qE\", &elocus, decl);\n+\t  error_at (elocus, \"invalid type for iteration variable %qE\", decl);\n \t  return NULL;\n \t}\n "}]}