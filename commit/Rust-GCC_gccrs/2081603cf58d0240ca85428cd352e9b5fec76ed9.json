{"sha": "2081603cf58d0240ca85428cd352e9b5fec76ed9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjA4MTYwM2NmNThkMDI0MGNhODU0MjhjZDM1MmU5YjVmZWM3NmVkOQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@casey.cygnus.com", "date": "1999-11-25T09:31:49Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1999-11-25T09:31:49Z"}, "message": "dwarf2out.c (pend_type, [...]): Lose.\n\n        * dwarf2out.c (pend_type, output_pending_types_for_scope): Lose.\n        (splice_child_die): Handle moving a child DIE from the declaration\n        DIE of a class to its specification.\n        (gen_struct_or_union_type_die): Use 'complete' consistently.\n        (gen_decl_die): Generate the virtual context DIE first.\n        Use decl_ultimate_origin instead of DECL_ABSTRACT_ORIGIN.\n\nFrom-SVN: r30662", "tree": {"sha": "8d48794740bd74554d05d50ab21d5740e9ced326", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8d48794740bd74554d05d50ab21d5740e9ced326"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2081603cf58d0240ca85428cd352e9b5fec76ed9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2081603cf58d0240ca85428cd352e9b5fec76ed9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2081603cf58d0240ca85428cd352e9b5fec76ed9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2081603cf58d0240ca85428cd352e9b5fec76ed9/comments", "author": null, "committer": null, "parents": [{"sha": "51621758ba967ce4a1c983494fba4a8aca22b260", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51621758ba967ce4a1c983494fba4a8aca22b260", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51621758ba967ce4a1c983494fba4a8aca22b260"}], "stats": {"total": 100, "additions": 24, "deletions": 76}, "files": [{"sha": "29d43a1b29735c5f8ad7dd878818b1e226599991", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2081603cf58d0240ca85428cd352e9b5fec76ed9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2081603cf58d0240ca85428cd352e9b5fec76ed9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2081603cf58d0240ca85428cd352e9b5fec76ed9", "patch": "@@ -1,3 +1,12 @@\n+1999-11-25  Jason Merrill  <jason@casey.cygnus.com>\n+\n+\t* dwarf2out.c (pend_type, output_pending_types_for_scope): Lose.\n+\t(splice_child_die): Handle moving a child DIE from the declaration\n+\tDIE of a class to its specification.\n+\t(gen_struct_or_union_type_die): Use 'complete' consistently.\n+\t(gen_decl_die): Generate the virtual context DIE first.\n+\tUse decl_ultimate_origin instead of DECL_ABSTRACT_ORIGIN.\n+\n 1999-11-24  Gavin Romig-Koch  <gavin@cygnus.com>\n \n \t* config/mips/mips.md (call_value_multiple_interanal1): New."}, {"sha": "cd736a6979a28b8813c5826d3c638b66758bdcc8", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 15, "deletions": 76, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2081603cf58d0240ca85428cd352e9b5fec76ed9/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2081603cf58d0240ca85428cd352e9b5fec76ed9/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=2081603cf58d0240ca85428cd352e9b5fec76ed9", "patch": "@@ -2322,23 +2322,6 @@ static unsigned arange_table_in_use;\n    arange_table.  */\n #define ARANGE_TABLE_INCREMENT 64\n \n-/* A pointer to the base of a list of pending types which we haven't\n-   generated DIEs for yet, but which we will have to come back to\n-   later on.  */\n-\n-static tree *pending_types_list;\n-\n-/* Number of elements currently allocated for the pending_types_list.  */\n-static unsigned pending_types_allocated;\n-\n-/* Number of elements of pending_types_list currently in use.  */\n-static unsigned pending_types;\n-\n-/* Size (in elements) of increments by which we may expand the pending\n-   types list.  Actually, a single hunk of space of this size should\n-   be enough for most typical programs.\t */\n-#define PENDING_TYPES_INCREMENT 64\n-\n /* A pointer to the base of a list of incomplete types which might be\n    completed at some later time.  */\n \n@@ -2511,8 +2494,6 @@ static void gen_set_type_die\t\tPROTO((tree, dw_die_ref));\n #if 0\n static void gen_entry_point_die\t\tPROTO((tree, dw_die_ref));\n #endif\n-static void pend_type\t\t\tPROTO((tree));\n-static void output_pending_types_for_scope PROTO((dw_die_ref));\n static void gen_inlined_enumeration_type_die PROTO((tree, dw_die_ref));\n static void gen_inlined_structure_type_die PROTO((tree, dw_die_ref));\n static void gen_inlined_union_type_die\tPROTO((tree, dw_die_ref));\n@@ -4153,8 +4134,8 @@ add_child_die (die, child_die)\n     }\n }\n \n-/* Move CHILD, which must be a child of PARENT, to the front of\n-   PARENT's list of children.  */\n+/* Move CHILD, which must be a child of PARENT or the DIE for which PARENT\n+   is the specification, to the front of PARENT's list of children.  */\n \n static void\n splice_child_die (parent, child)\n@@ -4165,9 +4146,14 @@ splice_child_die (parent, child)\n   /* We want the declaration DIE from inside the class, not the\n      specification DIE at toplevel.  */\n   if (child->die_parent != parent)\n-    child = get_AT_ref (child, DW_AT_specification);\n+    {\n+      dw_die_ref tmp = get_AT_ref (child, DW_AT_specification);\n+      if (tmp)\n+\tchild = tmp;\n+    }\n \n-  if (parent == NULL || child == NULL || child->die_parent != parent)\n+  if (child->die_parent != parent\n+      && child->die_parent != get_AT_ref (parent, DW_AT_specification))\n     abort ();\n \n   for (p = &(parent->die_child); *p; p = &((*p)->die_sib))\n@@ -7954,45 +7940,6 @@ gen_entry_point_die (decl, context_die)\n }\n #endif\n \n-/* Remember a type in the pending_types_list.  */\n-\n-static void\n-pend_type (type)\n-     register tree type;\n-{\n-  if (pending_types == pending_types_allocated)\n-    {\n-      pending_types_allocated += PENDING_TYPES_INCREMENT;\n-      pending_types_list\n-\t= (tree *) xrealloc (pending_types_list,\n-\t\t\t     sizeof (tree) * pending_types_allocated);\n-    }\n-\n-  pending_types_list[pending_types++] = type;\n-}\n-\n-/* Output any pending types (from the pending_types list) which we can output\n-   now (taking into account the scope that we are working on now).\n-\n-   For each type output, remove the given type from the pending_types_list\n-   *before* we try to output it.  */\n-\n-static void\n-output_pending_types_for_scope (context_die)\n-     register dw_die_ref context_die;\n-{\n-  register tree type;\n-\n-  while (pending_types)\n-    {\n-      --pending_types;\n-      type = pending_types_list[pending_types];\n-      gen_type_die (type, context_die);\n-      if (!TREE_ASM_WRITTEN (type))\n-\tabort ();\n-    }\n-}\n-\n /* Remember a type in the incomplete_types_list.  */\n \n static void\n@@ -9054,16 +9001,9 @@ gen_struct_or_union_type_die (type, context_die)\n   else\n     remove_AT (type_die, DW_AT_declaration);\n \n-  /* If we're not in the right context to be defining this type, defer to\n-     avoid tricky recursion.  */\n-  if (TYPE_SIZE (type) && decl_scope_depth > 0 && scope_die == comp_unit_die)\n-    {\n-      add_AT_flag (type_die, DW_AT_declaration, 1);\n-      pend_type (type);\n-    }\n   /* If this type has been completed, then give it a byte_size attribute and\n      then give a list of members.  */\n-  else if (complete)\n+  if (complete)\n     {\n       /* Prevent infinite recursion in cases where the type of some member of \n          this type is expressed in terms of this type itself.  */\n@@ -9548,14 +9488,14 @@ gen_decl_die (decl, context_die)\n \t     have described its return type.  */\n \t  gen_type_die (TREE_TYPE (TREE_TYPE (decl)), context_die);\n \n+\t  /* And its virtual context.  */\n+\t  if (DECL_VINDEX (decl) != NULL_TREE)\n+\t    gen_type_die (DECL_CONTEXT (decl), context_die);\n+\n \t  /* And its containing type.  */\n \t  origin = decl_class_context (decl);\n \t  if (origin != NULL_TREE)\n \t    gen_type_die_for_member (origin, decl, context_die);\n-\n-\t  /* And its virtual context.  */\n-\t  if (DECL_VINDEX (decl) != NULL_TREE)\n-\t    gen_type_die (DECL_CONTEXT (decl), context_die);\n \t}\n \n       /* Now output a DIE to represent the function itself.  */\n@@ -9575,7 +9515,7 @@ gen_decl_die (decl, context_die)\n          inline function) we have to generate a special (abbreviated)\n          DW_TAG_structure_type, DW_TAG_union_type, or DW_TAG_enumeration_type \n          DIE here.  */\n-      if (TYPE_DECL_IS_STUB (decl) && DECL_ABSTRACT_ORIGIN (decl) != NULL_TREE)\n+      if (TYPE_DECL_IS_STUB (decl) && decl_ultimate_origin (decl) != NULL_TREE)\n \t{\n \t  gen_tagged_type_instantiation_die (TREE_TYPE (decl), context_die);\n \t  break;\n@@ -9789,7 +9729,6 @@ dwarf2out_decl (decl)\n     }\n \n   gen_decl_die (decl, context_die);\n-  output_pending_types_for_scope (comp_unit_die);\n }\n \n /* Output a marker (i.e. a label) for the beginning of the generated code for"}]}