{"sha": "dbd160bff8ca492b8e14fe347f0995d70f23065b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGJkMTYwYmZmOGNhNDkyYjhlMTRmZTM0N2YwOTk1ZDcwZjIzMDY1Yg==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2005-07-15T00:05:44Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2005-07-15T00:05:44Z"}, "message": "PR libstdc++/21193 (float, double, long double)\n\n2005-07-14  Paolo Carlini  <pcarlini@suse.de>\n\n\tPR libstdc++/21193 (float, double, long double)\n\t* include/tr1/functional (hash<float>, hash<double>):\n\tReimplement exploiting the Fnv_hash<>::hash helper.\n\t(hash<long double>): Reimplement using frexp (in this\n\tcase, due to random padding bits, the former approach\n\tis not generally viable).\n\nFrom-SVN: r102043", "tree": {"sha": "fd4d3d335b870f0c8c475f54839d0be2acaef633", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fd4d3d335b870f0c8c475f54839d0be2acaef633"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dbd160bff8ca492b8e14fe347f0995d70f23065b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbd160bff8ca492b8e14fe347f0995d70f23065b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dbd160bff8ca492b8e14fe347f0995d70f23065b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbd160bff8ca492b8e14fe347f0995d70f23065b/comments", "author": null, "committer": null, "parents": [{"sha": "06277571f475f065d79e7d7b107200b2eb970580", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06277571f475f065d79e7d7b107200b2eb970580", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06277571f475f065d79e7d7b107200b2eb970580"}], "stats": {"total": 85, "additions": 77, "deletions": 8}, "files": [{"sha": "15862e3772aac4c8a721fc0d9073692244ca8087", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbd160bff8ca492b8e14fe347f0995d70f23065b/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbd160bff8ca492b8e14fe347f0995d70f23065b/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=dbd160bff8ca492b8e14fe347f0995d70f23065b", "patch": "@@ -1,3 +1,12 @@\n+2005-07-14  Paolo Carlini  <pcarlini@suse.de>\n+\n+\tPR libstdc++/21193 (float, double, long double)\n+\t* include/tr1/functional (hash<float>, hash<double>):\n+\tReimplement exploiting the Fnv_hash<>::hash helper.\n+\t(hash<long double>): Reimplement using frexp (in this\n+\tcase, due to random padding bits, the former approach\n+\tis not generally viable).\n+\n 2005-07-13  Paolo Carlini  <pcarlini@suse.de>\n \n \tPR libstdc++/21193 (string & wstring)"}, {"sha": "f609fd3d98438683f201e608a78d8eefbb438e0a", "filename": "libstdc++-v3/include/tr1/functional", "status": "modified", "additions": 68, "deletions": 8, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbd160bff8ca492b8e14fe347f0995d70f23065b/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ffunctional", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbd160bff8ca492b8e14fe347f0995d70f23065b/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ffunctional", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ffunctional?ref=dbd160bff8ca492b8e14fe347f0995d70f23065b", "patch": "@@ -40,6 +40,7 @@\n #include <bits/cpp_type_traits.h>\n #include <string>               // for std::tr1::hash\n #include <cstdlib>              // for std::abort\n+#include <cmath>                // for std::frexp\n #include <tr1/tuple>\n \n namespace std\n@@ -1116,10 +1117,6 @@ namespace tr1\n   tr1_hashtable_define_trivial_hash(unsigned int);\n   tr1_hashtable_define_trivial_hash(unsigned long);\n \n-  tr1_hashtable_define_trivial_hash(float);\n-  tr1_hashtable_define_trivial_hash(double);\n-  tr1_hashtable_define_trivial_hash(long double);\n-\n #undef tr1_hashtable_define_trivial_hash\n \n   template<typename T>\n@@ -1133,7 +1130,7 @@ namespace tr1\n   // Fowler / Noll / Vo (FNV) Hash (type FNV-1a)\n   // (used by the next specializations of std::tr1::hash<>)\n \n-  // Dummy generic implementation (for sizeof(size_t) != 4,8).\n+  // Dummy generic implementation (for sizeof(size_t) != 4, 8).\n   template<std::size_t = sizeof(std::size_t)>\n     struct Fnv_hash\n     {\n@@ -1179,9 +1176,9 @@ namespace tr1\n       }\n     };\n \n-  // XXX String hash probably shouldn't be an inline member function,\n-  // since it's nontrivial.  Once we have the framework for TR1 .cc\n-  // files, this should go in one.\n+  // XXX String and floating point hashes probably shouldn't be inline\n+  // member functions, since are nontrivial.  Once we have the framework\n+  // for TR1 .cc files, these should go in one.\n   template<>\n     struct hash<std::string>\n     {\n@@ -1203,6 +1200,69 @@ namespace tr1\n     };\n #endif\n \n+  template<>\n+    struct hash<float>\n+    {\n+      std::size_t\n+      operator()(float fval) const\n+      {\n+\tstd::size_t result = 0;\n+\n+\t// 0 and -0 both hash to zero.\n+\tif (fval != 0.0f)\n+\t  result = Fnv_hash<>::hash(reinterpret_cast<const char*>(&fval),\n+\t\t\t\t    sizeof(fval));\n+\treturn result;\n+      }\n+    };\n+\n+  template<>\n+    struct hash<double>\n+    {\n+      std::size_t\n+      operator()(double dval) const\n+      {\n+\tstd::size_t result = 0;\n+\n+\t// 0 and -0 both hash to zero.\n+\tif (dval != 0.0)\n+\t  result = Fnv_hash<>::hash(reinterpret_cast<const char*>(&dval),\n+\t\t\t\t    sizeof(dval));\n+\treturn result;\n+      }\n+    };\n+\n+  // For long double, careful with random padding bits (e.g., on x86,\n+  // 10 bytes -> 12 bytes) and resort to frexp.\n+  template<>\n+    struct hash<long double>\n+    {\n+      std::size_t\n+      operator()(long double ldval) const\n+      {\n+\tstd::size_t result = 0;\n+\n+\tint exponent;\n+\tldval = std::frexp(ldval, &exponent);\n+\tldval = ldval < 0.0l ? -(ldval + 0.5l) : ldval;\n+\n+\tconst long double mult = std::numeric_limits<std::size_t>::max() + 1.0l;\n+\tldval *= mult;\n+\n+\t// Try to use all the bits of the mantissa (really necessary only\n+\t// on 32-bit targets, at least for 80-bit floating point formats).\n+\tconst std::size_t hibits = (std::size_t)ldval;\n+\tldval = (ldval - (long double)hibits) * mult;\n+\n+\tconst std::size_t coeff =\n+\t  (std::numeric_limits<std::size_t>::max()\n+\t   / std::numeric_limits<long double>::max_exponent);\n+\n+\tresult = hibits + (std::size_t)ldval + coeff * exponent;\n+\n+\treturn result;\n+      }\n+    };\n }\n }\n "}]}