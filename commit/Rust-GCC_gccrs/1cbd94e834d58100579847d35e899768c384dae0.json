{"sha": "1cbd94e834d58100579847d35e899768c384dae0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWNiZDk0ZTgzNGQ1ODEwMDU3OTg0N2QzNWU4OTk3NjhjMzg0ZGFlMA==", "commit": {"author": {"name": "Julian Brown", "email": "julian@codesourcery.com", "date": "2019-12-13T23:14:15Z"}, "committer": {"name": "Julian Brown", "email": "jules@gcc.gnu.org", "date": "2019-12-13T23:14:15Z"}, "message": "Fix potential race condition in OpenACC \"exit data\" operations\n\n\tPR libgomp/92881\n\n\tlibgomp/\n\t* libgomp.h (gomp_remove_var_async): Add prototype.\n\t* oacc-mem.c (delete_copyout): Call gomp_remove_var_async instead of\n\tgomp_remove_var.\n\t* target.c (gomp_unref_tgt): Change return type to bool, indicating\n\twhether target_mem_desc was unmapped.\n\t(gomp_unref_tgt_void): New.\n\t(gomp_remove_var): Reimplement in terms of...\n\t(gomp_remove_var_internal): ...this new helper function.\n\t(gomp_remove_var_async): New, implemented using above helper function.\n\t(gomp_unmap_vars_internal): Use gomp_unref_tgt_void instead of\n\tgomp_unref_tgt.\n\nReviewed-by: Thomas Schwinge <thomas@codesourcery.com>\n\nFrom-SVN: r279388", "tree": {"sha": "c17d82d0dc67d657c321886da4f4691306c4f3a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c17d82d0dc67d657c321886da4f4691306c4f3a6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1cbd94e834d58100579847d35e899768c384dae0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1cbd94e834d58100579847d35e899768c384dae0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1cbd94e834d58100579847d35e899768c384dae0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1cbd94e834d58100579847d35e899768c384dae0/comments", "author": {"login": "jtb20", "id": 6094880, "node_id": "MDQ6VXNlcjYwOTQ4ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/6094880?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jtb20", "html_url": "https://github.com/jtb20", "followers_url": "https://api.github.com/users/jtb20/followers", "following_url": "https://api.github.com/users/jtb20/following{/other_user}", "gists_url": "https://api.github.com/users/jtb20/gists{/gist_id}", "starred_url": "https://api.github.com/users/jtb20/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jtb20/subscriptions", "organizations_url": "https://api.github.com/users/jtb20/orgs", "repos_url": "https://api.github.com/users/jtb20/repos", "events_url": "https://api.github.com/users/jtb20/events{/privacy}", "received_events_url": "https://api.github.com/users/jtb20/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a7c70129b9cb1cc9300400dc4f4adc639f0ba9c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7c70129b9cb1cc9300400dc4f4adc639f0ba9c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7c70129b9cb1cc9300400dc4f4adc639f0ba9c3"}], "stats": {"total": 88, "additions": 68, "deletions": 20}, "files": [{"sha": "6b16bf34b17905491a883d762187c3dee531dc83", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cbd94e834d58100579847d35e899768c384dae0/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cbd94e834d58100579847d35e899768c384dae0/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=1cbd94e834d58100579847d35e899768c384dae0", "patch": "@@ -1,3 +1,19 @@\n+2019-12-13  Julian Brown  <julian@codesourcery.com>\n+\n+\tPR libgomp/92881\n+\n+\t* libgomp.h (gomp_remove_var_async): Add prototype.\n+\t* oacc-mem.c (delete_copyout): Call gomp_remove_var_async instead of\n+\tgomp_remove_var.\n+\t* target.c (gomp_unref_tgt): Change return type to bool, indicating\n+\twhether target_mem_desc was unmapped.\n+\t(gomp_unref_tgt_void): New.\n+\t(gomp_remove_var): Reimplement in terms of...\n+\t(gomp_remove_var_internal): ...this new helper function.\n+\t(gomp_remove_var_async): New, implemented using above helper function.\n+\t(gomp_unmap_vars_internal): Use gomp_unref_tgt_void instead of\n+\tgomp_unref_tgt.\n+\n 2019-12-13  Andrew Stubbs  <ams@codesourcery.com>\n \n \t* testsuite/libgomp.oacc-c-c++-common/acc_prof-init-1.c: Handle gcn."}, {"sha": "36dcca2835379ea43ffd0c103ac63dc1e96281e0", "filename": "libgomp/libgomp.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cbd94e834d58100579847d35e899768c384dae0/libgomp%2Flibgomp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cbd94e834d58100579847d35e899768c384dae0/libgomp%2Flibgomp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.h?ref=1cbd94e834d58100579847d35e899768c384dae0", "patch": "@@ -1166,6 +1166,8 @@ extern bool gomp_fini_device (struct gomp_device_descr *);\n extern void gomp_free_memmap (struct splay_tree_s *);\n extern void gomp_unload_device (struct gomp_device_descr *);\n extern bool gomp_remove_var (struct gomp_device_descr *, splay_tree_key);\n+extern void gomp_remove_var_async (struct gomp_device_descr *, splay_tree_key,\n+\t\t\t\t   struct goacc_asyncqueue *);\n \n /* work.c */\n "}, {"sha": "196b7e2a52027f6e2eaf86b2ac560255dfef0b38", "filename": "libgomp/oacc-mem.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cbd94e834d58100579847d35e899768c384dae0/libgomp%2Foacc-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cbd94e834d58100579847d35e899768c384dae0/libgomp%2Foacc-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-mem.c?ref=1cbd94e834d58100579847d35e899768c384dae0", "patch": "@@ -660,7 +660,6 @@ static void\n delete_copyout (unsigned f, void *h, size_t s, int async, const char *libfnname)\n {\n   splay_tree_key n;\n-  void *d;\n   struct goacc_thread *thr = goacc_thread ();\n   struct gomp_device_descr *acc_dev = thr->dev;\n \n@@ -689,9 +688,6 @@ delete_copyout (unsigned f, void *h, size_t s, int async, const char *libfnname)\n       gomp_fatal (\"[%p,%d] is not mapped\", (void *)h, (int)s);\n     }\n \n-  d = (void *) (n->tgt->tgt_start + n->tgt_offset\n-\t\t+ (uintptr_t) h - n->host_start);\n-\n   if ((uintptr_t) h < n->host_start || (uintptr_t) h + s > n->host_end)\n     {\n       size_t host_size = n->host_end - n->host_start;\n@@ -723,12 +719,15 @@ delete_copyout (unsigned f, void *h, size_t s, int async, const char *libfnname)\n \n   if (n->refcount == 0)\n     {\n+      goacc_aq aq = get_goacc_asyncqueue (async);\n+\n       if (f & FLAG_COPYOUT)\n \t{\n-\t  goacc_aq aq = get_goacc_asyncqueue (async);\n+\t  void *d = (void *) (n->tgt->tgt_start + n->tgt_offset\n+\t\t\t      + (uintptr_t) h - n->host_start);\n \t  gomp_copy_dev2host (acc_dev, aq, h, d, s);\n \t}\n-      gomp_remove_var (acc_dev, n);\n+      gomp_remove_var_async (acc_dev, n, aq);\n     }\n \n   gomp_mutex_unlock (&acc_dev->lock);"}, {"sha": "82ed38c01ec8d165383644fd1aa2a4906ebde16c", "filename": "libgomp/target.c", "status": "modified", "additions": 45, "deletions": 14, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cbd94e834d58100579847d35e899768c384dae0/libgomp%2Ftarget.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cbd94e834d58100579847d35e899768c384dae0/libgomp%2Ftarget.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftarget.c?ref=1cbd94e834d58100579847d35e899768c384dae0", "patch": "@@ -1116,32 +1116,63 @@ gomp_unmap_tgt (struct target_mem_desc *tgt)\n   free (tgt);\n }\n \n-attribute_hidden bool\n-gomp_remove_var (struct gomp_device_descr *devicep, splay_tree_key k)\n+static bool\n+gomp_unref_tgt (void *ptr)\n {\n   bool is_tgt_unmapped = false;\n-  splay_tree_remove (&devicep->mem_map, k);\n-  if (k->link_key)\n-    splay_tree_insert (&devicep->mem_map, (splay_tree_node) k->link_key);\n-  if (k->tgt->refcount > 1)\n-    k->tgt->refcount--;\n+\n+  struct target_mem_desc *tgt = (struct target_mem_desc *) ptr;\n+\n+  if (tgt->refcount > 1)\n+    tgt->refcount--;\n   else\n     {\n+      gomp_unmap_tgt (tgt);\n       is_tgt_unmapped = true;\n-      gomp_unmap_tgt (k->tgt);\n     }\n+\n   return is_tgt_unmapped;\n }\n \n static void\n-gomp_unref_tgt (void *ptr)\n+gomp_unref_tgt_void (void *ptr)\n {\n-  struct target_mem_desc *tgt = (struct target_mem_desc *) ptr;\n+  (void) gomp_unref_tgt (ptr);\n+}\n \n-  if (tgt->refcount > 1)\n-    tgt->refcount--;\n+static inline __attribute__((always_inline)) bool\n+gomp_remove_var_internal (struct gomp_device_descr *devicep, splay_tree_key k,\n+\t\t\t  struct goacc_asyncqueue *aq)\n+{\n+  bool is_tgt_unmapped = false;\n+  splay_tree_remove (&devicep->mem_map, k);\n+  if (k->link_key)\n+    splay_tree_insert (&devicep->mem_map, (splay_tree_node) k->link_key);\n+  if (aq)\n+    devicep->openacc.async.queue_callback_func (aq, gomp_unref_tgt_void,\n+\t\t\t\t\t\t(void *) k->tgt);\n   else\n-    gomp_unmap_tgt (tgt);\n+    is_tgt_unmapped = gomp_unref_tgt ((void *) k->tgt);\n+  return is_tgt_unmapped;\n+}\n+\n+attribute_hidden bool\n+gomp_remove_var (struct gomp_device_descr *devicep, splay_tree_key k)\n+{\n+  return gomp_remove_var_internal (devicep, k, NULL);\n+}\n+\n+/* Remove a variable asynchronously.  This actually removes the variable\n+   mapping immediately, but retains the linked target_mem_desc until the\n+   asynchronous operation has completed (as it may still refer to target\n+   memory).  The device lock must be held before entry, and remains locked on\n+   exit.  */\n+\n+attribute_hidden void\n+gomp_remove_var_async (struct gomp_device_descr *devicep, splay_tree_key k,\n+\t\t       struct goacc_asyncqueue *aq)\n+{\n+  (void) gomp_remove_var_internal (devicep, k, aq);\n }\n \n /* Unmap variables described by TGT.  If DO_COPYFROM is true, copy relevant\n@@ -1197,7 +1228,7 @@ gomp_unmap_vars_internal (struct target_mem_desc *tgt, bool do_copyfrom,\n     }\n \n   if (aq)\n-    devicep->openacc.async.queue_callback_func (aq, gomp_unref_tgt,\n+    devicep->openacc.async.queue_callback_func (aq, gomp_unref_tgt_void,\n \t\t\t\t\t\t(void *) tgt);\n   else\n     gomp_unref_tgt ((void *) tgt);"}]}