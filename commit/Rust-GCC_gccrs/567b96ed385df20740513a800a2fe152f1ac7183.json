{"sha": "567b96ed385df20740513a800a2fe152f1ac7183", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTY3Yjk2ZWQzODVkZjIwNzQwNTEzYTgwMGEyZmUxNTJmMWFjNzE4Mw==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2007-01-10T21:32:36Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2007-01-10T21:32:36Z"}, "message": "tree-ssa-loop-manip.c (tree_unroll_loop): Make it a wrapper over ...\n\n\t* tree-ssa-loop-manip.c (tree_unroll_loop): Make it a wrapper over ...\n\t(tree_transform_and_unroll_loop): New.\n\t* tree-flow.h (transform_callback, tree_transform_and_unroll_loop):\n\tDeclare.\n\nFrom-SVN: r120650", "tree": {"sha": "c0a87d1a68c27464ce0aba76bd5b7a16d3f58ae7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c0a87d1a68c27464ce0aba76bd5b7a16d3f58ae7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/567b96ed385df20740513a800a2fe152f1ac7183", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/567b96ed385df20740513a800a2fe152f1ac7183", "html_url": "https://github.com/Rust-GCC/gccrs/commit/567b96ed385df20740513a800a2fe152f1ac7183", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/567b96ed385df20740513a800a2fe152f1ac7183/comments", "author": null, "committer": null, "parents": [{"sha": "6b074ef6a052a19061eba1d2305c74277429d9bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b074ef6a052a19061eba1d2305c74277429d9bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b074ef6a052a19061eba1d2305c74277429d9bd"}], "stats": {"total": 140, "additions": 93, "deletions": 47}, "files": [{"sha": "607cbb06b618afd7370bc4e9584e010f861a63fc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/567b96ed385df20740513a800a2fe152f1ac7183/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/567b96ed385df20740513a800a2fe152f1ac7183/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=567b96ed385df20740513a800a2fe152f1ac7183", "patch": "@@ -1,3 +1,10 @@\n+2007-01-10  Zdenek Dvorak <dvorakz@suse.cz>\n+\n+\t* tree-ssa-loop-manip.c (tree_unroll_loop): Make it a wrapper over ...\n+\t(tree_transform_and_unroll_loop): New.\n+\t* tree-flow.h (transform_callback, tree_transform_and_unroll_loop):\n+\tDeclare.\n+\n 2007-01-10  Robert Kennedy <jimbob@google.com>\n \n \t* fold-const.c (fold_comparison): Fold comparisons like (x *\n@@ -24,11 +31,11 @@\n \t* config/bfin/t-bfin, config/bfin/t-bfin-elf: Remove GCC_CFLAGS.\n \n 2007-01-10  Razya Ladelsky  <razya@il.ibm.com>\n-        \n-        * function.c (get_last_funcdef_no): New function.\n+\n+\t* function.c (get_last_funcdef_no): New function.\n \t* function.h (get_last_funcdef_no): Declare. \n-        * tree-inline.c (initialize_cfun): Add initialization.\n-        (tree_function_versioning): Cleanup.\n+\t* tree-inline.c (initialize_cfun): Add initialization.\n+\t(tree_function_versioning): Cleanup.\n \t\n 2007-01-10  Jan Hubicka  <jh@suse.cz>\n "}, {"sha": "5bd07dce64312057dd9df935853bb9c45076dc0c", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/567b96ed385df20740513a800a2fe152f1ac7183/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/567b96ed385df20740513a800a2fe152f1ac7183/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=567b96ed385df20740513a800a2fe152f1ac7183", "patch": "@@ -908,6 +908,10 @@ bool can_unroll_loop_p (struct loop *loop, unsigned factor,\n \t\t\tstruct tree_niter_desc *niter);\n void tree_unroll_loop (struct loop *, unsigned,\n \t\t       edge, struct tree_niter_desc *);\n+typedef void (*transform_callback)(struct loop *, void *);\n+void tree_transform_and_unroll_loop (struct loop *, unsigned,\n+\t\t\t\t     edge, struct tree_niter_desc *,\n+\t\t\t\t     transform_callback, void *);\n bool contains_abnormal_ssa_name_p (tree);\n \n /* In tree-ssa-threadedge.c */"}, {"sha": "53280b9a3827ab35603ca009c84d1e8bd88ca02e", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 78, "deletions": 43, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/567b96ed385df20740513a800a2fe152f1ac7183/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/567b96ed385df20740513a800a2fe152f1ac7183/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=567b96ed385df20740513a800a2fe152f1ac7183", "patch": "@@ -803,14 +803,20 @@ determine_exit_conditions (struct loop *loop, struct tree_niter_desc *desc,\n        if (st)\n          break;\n        post;\n-     } */\n+     }\n+ \n+   Before the loop is unrolled, TRANSFORM is called for it (only for the\n+   unrolled loop, but not for its versioned copy).  DATA is passed to\n+   TRANSFORM.  */\n \n /* Probability in % that the unrolled loop is entered.  Just a guess.  */\n #define PROB_UNROLLED_LOOP_ENTERED 90\n \n void\n-tree_unroll_loop (struct loop *loop, unsigned factor,\n-\t\t  edge exit, struct tree_niter_desc *desc)\n+tree_transform_and_unroll_loop (struct loop *loop, unsigned factor,\n+\t\t\t\tedge exit, struct tree_niter_desc *desc,\n+\t\t\t\ttransform_callback transform,\n+\t\t\t\tvoid *data)\n {\n   tree dont_exit, exit_if, ctr_before, ctr_after;\n   tree enter_main_cond, exit_base, exit_step, exit_bound;\n@@ -859,24 +865,7 @@ tree_unroll_loop (struct loop *loop, unsigned factor,\n   gcc_assert (new_loop != NULL);\n   update_ssa (TODO_update_ssa);\n \n-  /* Unroll the loop and remove the old exits.  */\n-  dont_exit = ((exit->flags & EDGE_TRUE_VALUE)\n-\t       ? boolean_false_node\n-\t       : boolean_true_node);\n-  exit_if = last_stmt (exit->src);\n-  COND_EXPR_COND (exit_if) = dont_exit;\n-  update_stmt (exit_if);\n-      \n-  wont_exit = sbitmap_alloc (factor);\n-  sbitmap_ones (wont_exit);\n-  ok = tree_duplicate_loop_to_header_edge\n-\t  (loop, loop_latch_edge (loop), factor - 1,\n-\t   wont_exit, exit, NULL, DLTHE_FLAG_UPDATE_FREQ);\n-  free (wont_exit);\n-  gcc_assert (ok);\n-  update_ssa (TODO_update_ssa);\n-\n-  /* Determine the probability of the exit edge.  */\n+  /* Determine the probability of the exit edge of the unrolled loop.  */\n   new_est_niter = est_niter / factor;\n \n   /* Without profile feedback, loops for that we do not know a better estimate\n@@ -892,31 +881,24 @@ tree_unroll_loop (struct loop *loop, unsigned factor,\n \tnew_est_niter = 5;\n     }\n \n-  /* Ensure that the frequencies in the loop match the new estimated\n-     number of iterations.  */\n-  freq_h = loop->header->frequency;\n-  freq_e = EDGE_FREQUENCY (loop_preheader_edge (loop));\n-  if (freq_h != 0)\n-    scale_loop_frequencies (loop, freq_e * new_est_niter, freq_h);\n-\n   /* Prepare the cfg and update the phi nodes.  */\n   rest = loop_preheader_edge (new_loop)->src;\n   precond_edge = single_pred_edge (rest);\n   split_edge (loop_latch_edge (loop));\n   exit_bb = single_pred (loop->latch);\n \n+  /* For the moment, make it appear that the new exit edge cannot\n+     be taken.  */\n+  bsi = bsi_last (exit_bb);\n+  exit_if = build_if_stmt (boolean_true_node,\n+\t\t\t   tree_block_label (loop->latch),\n+\t\t\t   tree_block_label (rest));\n+  bsi_insert_after (&bsi, exit_if, BSI_NEW_STMT);\n   new_exit = make_edge (exit_bb, rest, EDGE_FALSE_VALUE | irr);\n-  new_exit->count = loop_preheader_edge (loop)->count;\n-  new_exit->probability = REG_BR_PROB_BASE / new_est_niter;\n-\n-  rest->count += new_exit->count;\n-  rest->frequency += EDGE_FREQUENCY (new_exit);\n-\n+  new_exit->count = 0;\n+  new_exit->probability = 0;\n   new_nonexit = single_pred_edge (loop->latch);\n   new_nonexit->flags = EDGE_TRUE_VALUE;\n-  new_nonexit->probability = REG_BR_PROB_BASE - new_exit->probability;\n-  scale_bbs_frequencies_int (&loop->latch, 1, new_nonexit->probability,\n-\t\t\t     REG_BR_PROB_BASE);\n \n   old_entry = loop_preheader_edge (loop);\n   new_entry = loop_preheader_edge (new_loop);\n@@ -954,16 +936,57 @@ tree_unroll_loop (struct loop *loop, unsigned factor,\n       SET_USE (op, new_init);\n     }\n \n+  /* Transform the loop.  */\n+  if (transform)\n+    (*transform) (loop, data);\n+\n+  /* Unroll the loop and remove the old exits.  */\n+  dont_exit = ((exit->flags & EDGE_TRUE_VALUE)\n+\t       ? boolean_false_node\n+\t       : boolean_true_node);\n+  exit_if = last_stmt (exit->src);\n+  COND_EXPR_COND (exit_if) = dont_exit;\n+  update_stmt (exit_if);\n+      \n+  wont_exit = sbitmap_alloc (factor);\n+  sbitmap_ones (wont_exit);\n+  ok = tree_duplicate_loop_to_header_edge\n+\t  (loop, loop_latch_edge (loop), factor - 1,\n+\t   wont_exit, exit, NULL, DLTHE_FLAG_UPDATE_FREQ);\n+  free (wont_exit);\n+  gcc_assert (ok);\n+  update_ssa (TODO_update_ssa);\n+\n+  /* Ensure that the frequencies in the loop match the new estimated\n+     number of iterations, and change the probability of the new\n+     exit edge.  */\n+  freq_h = loop->header->frequency;\n+  freq_e = EDGE_FREQUENCY (loop_preheader_edge (loop));\n+  if (freq_h != 0)\n+    scale_loop_frequencies (loop, freq_e * (new_est_niter + 1), freq_h);\n+\n+  exit_bb = single_pred (loop->latch);\n+  new_exit = find_edge (exit_bb, rest);\n+  new_exit->count = loop_preheader_edge (loop)->count;\n+  new_exit->probability = REG_BR_PROB_BASE / (new_est_niter + 1);\n+\n+  rest->count += new_exit->count;\n+  rest->frequency += EDGE_FREQUENCY (new_exit);\n+\n+  new_nonexit = single_pred_edge (loop->latch);\n+  new_nonexit->probability = REG_BR_PROB_BASE - new_exit->probability;\n+  scale_bbs_frequencies_int (&loop->latch, 1, new_nonexit->probability,\n+\t\t\t     REG_BR_PROB_BASE);\n+\n   /* Finally create the new counter for number of iterations and add the new\n      exit instruction.  */\n   bsi = bsi_last (exit_bb);\n+  exit_if = bsi_stmt (bsi);\n   create_iv (exit_base, exit_step, NULL_TREE, loop,\n-\t     &bsi, true, &ctr_before, &ctr_after);\n-  exit_if = build_if_stmt (build2 (exit_cmp, boolean_type_node, ctr_after,\n-\t\t\t\t   exit_bound),\n-\t\t\t   tree_block_label (loop->latch),\n-\t\t\t   tree_block_label (rest));\n-  bsi_insert_after (&bsi, exit_if, BSI_NEW_STMT);\n+\t     &bsi, false, &ctr_before, &ctr_after);\n+  COND_EXPR_COND (exit_if) = build2 (exit_cmp, boolean_type_node, ctr_after,\n+\t\t\t\t     exit_bound);\n+  update_stmt (exit_if);\n \n #ifdef ENABLE_CHECKING\n   verify_flow_info ();\n@@ -972,3 +995,15 @@ tree_unroll_loop (struct loop *loop, unsigned factor,\n   verify_loop_closed_ssa ();\n #endif\n }\n+\n+/* Wrapper over tree_transform_and_unroll_loop for case we do not\n+   want to transform the loop before unrolling.  The meaning\n+   of the arguments is the same as for tree_transform_and_unroll_loop.  */\n+\n+void\n+tree_unroll_loop (struct loop *loop, unsigned factor,\n+\t\t  edge exit, struct tree_niter_desc *desc)\n+{\n+  tree_transform_and_unroll_loop (loop, factor, exit, desc,\n+\t\t\t\t  NULL, NULL);\n+}"}]}