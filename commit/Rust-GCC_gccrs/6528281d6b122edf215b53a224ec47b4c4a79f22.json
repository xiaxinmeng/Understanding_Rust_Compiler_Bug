{"sha": "6528281d6b122edf215b53a224ec47b4c4a79f22", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjUyODI4MWQ2YjEyMmVkZjIxNWI1M2EyMjRlYzQ3YjRjNGE3OWYyMg==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2008-08-29T21:35:55Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2008-08-29T21:35:55Z"}, "message": "mn10300.c (mn10300_secondary_reload_class): We need secondary reloads for AM33-2 if IN is a pseudo with an equivalent...\n\n\t* mn10300.c (mn10300_secondary_reload_class): We need secondary\n\treloads for AM33-2 if IN is a pseudo with an equivalent memory\n\tlocation and class is an FP register.\n\nFrom-SVN: r139789", "tree": {"sha": "745b48b331e6dcd4e005c7953b1817e0b3cb0fa3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/745b48b331e6dcd4e005c7953b1817e0b3cb0fa3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6528281d6b122edf215b53a224ec47b4c4a79f22", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6528281d6b122edf215b53a224ec47b4c4a79f22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6528281d6b122edf215b53a224ec47b4c4a79f22", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6528281d6b122edf215b53a224ec47b4c4a79f22/comments", "author": null, "committer": null, "parents": [{"sha": "041f300d6d7c6fd4e006ca8defee0bcbaca0e6e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/041f300d6d7c6fd4e006ca8defee0bcbaca0e6e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/041f300d6d7c6fd4e006ca8defee0bcbaca0e6e7"}], "stats": {"total": 46, "additions": 34, "deletions": 12}, "files": [{"sha": "bec1f6a0591f807f803804526e440968defd839f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6528281d6b122edf215b53a224ec47b4c4a79f22/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6528281d6b122edf215b53a224ec47b4c4a79f22/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6528281d6b122edf215b53a224ec47b4c4a79f22", "patch": "@@ -1,6 +1,13 @@\n+2008-08-29  Jeff Law  <law@redhat.com>\n+\n+\t* mn10300.c (mn10300_secondary_reload_class): We need secondary\n+\treloads for AM33-2 if IN is a pseudo with an equivalent memory\n+\tlocation and class is an FP register.\n+\n 2008-08-29  Jan Hubicka  <jh@suse.cz>\n \n-\t* see.c (see_merge_one_def_extension): Silence used uninitialized warning.\n+\t* see.c (see_merge_one_def_extension): Silence used uninitialized\n+\twarning.\n \t* matrix-reorg.c (check_allocation_function): Likewise.\n \t* config/i386/driver-i386.c (detect_caches_amd): Likewise.\n "}, {"sha": "13c0ff72f2ed9d0f47acb06fb8f2a409b24ef05b", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 26, "deletions": 11, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6528281d6b122edf215b53a224ec47b4c4a79f22/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6528281d6b122edf215b53a224ec47b4c4a79f22/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=6528281d6b122edf215b53a224ec47b4c4a79f22", "patch": "@@ -34,6 +34,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"insn-attr.h\"\n #include \"flags.h\"\n #include \"recog.h\"\n+#include \"reload.h\"\n #include \"expr.h\"\n #include \"optabs.h\"\n #include \"function.h\"\n@@ -1326,15 +1327,20 @@ enum reg_class\n mn10300_secondary_reload_class (enum reg_class rclass, enum machine_mode mode,\n \t\t\t\trtx in)\n {\n+  rtx inner = in;\n+\n+  /* Strip off any SUBREG expressions from IN.  Basically we want\n+     to know if IN is a pseudo or (subreg (pseudo)) as those can\n+     turn into MEMs during reload.  */\n+  while (GET_CODE (inner) == SUBREG)\n+    inner = SUBREG_REG (inner);\n+\n   /* Memory loads less than a full word wide can't have an\n      address or stack pointer destination.  They must use\n      a data register as an intermediate register.  */\n   if ((GET_CODE (in) == MEM\n-       || (GET_CODE (in) == REG\n-\t   && REGNO (in) >= FIRST_PSEUDO_REGISTER)\n-       || (GET_CODE (in) == SUBREG\n-\t   && GET_CODE (SUBREG_REG (in)) == REG\n-\t   && REGNO (SUBREG_REG (in)) >= FIRST_PSEUDO_REGISTER))\n+       || (GET_CODE (inner) == REG\n+\t   && REGNO (inner) >= FIRST_PSEUDO_REGISTER))\n       && (mode == QImode || mode == HImode)\n       && (rclass == ADDRESS_REGS || rclass == SP_REGS\n \t  || rclass == SP_OR_ADDRESS_REGS))\n@@ -1363,13 +1369,22 @@ mn10300_secondary_reload_class (enum reg_class rclass, enum machine_mode mode,\n \t  || XEXP (in, 1) == stack_pointer_rtx))\n     return GENERAL_REGS;\n \n-  if (TARGET_AM33_2 && rclass == FP_REGS\n-      && GET_CODE (in) == MEM\n-      && ! (GET_CODE (in) == MEM && !CONSTANT_ADDRESS_P (XEXP (in, 0))))\n+  if (TARGET_AM33_2\n+      && rclass == FP_REGS)\n     {\n-      if (TARGET_AM33)\n-\treturn DATA_OR_EXTENDED_REGS;\n-      return DATA_REGS;\n+      /* We can't load directly into an FP register from a\t\n+\t constant address.  */\n+      if (GET_CODE (in) == MEM\n+\t  && CONSTANT_ADDRESS_P (XEXP (in, 0)))\n+\treturn (TARGET_AM33 ? DATA_OR_EXTENDED_REGS : DATA_REGS);\n+\n+      /* Handle case were a pseudo may not get a hard register\n+\t but has an equivalent memory location defined.  */\n+      if (GET_CODE (inner) == REG\n+\t  && REGNO (inner) >= FIRST_PSEUDO_REGISTER\n+\t  && reg_equiv_mem [REGNO (inner)]\n+\t  && CONSTANT_ADDRESS_P (XEXP (reg_equiv_mem [REGNO (inner)], 0)))\n+\treturn (TARGET_AM33 ? DATA_OR_EXTENDED_REGS : DATA_REGS);\n     }\n \n   /* Otherwise assume no secondary reloads are needed.  */"}]}