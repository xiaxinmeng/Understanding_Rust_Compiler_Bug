{"sha": "42da70b76e5d7818e9c44c171b354b0ce3226dd0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDJkYTcwYjc2ZTVkNzgxOGU5YzQ0YzE3MWIzNTRiMGNlMzIyNmRkMA==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernd.schmidt@analog.com", "date": "2006-05-04T11:10:03Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2006-05-04T11:10:03Z"}, "message": "bfin.c: Include \"optabs.h\".\n\n\t* config/bfin/bfin.c: Include \"optabs.h\".\n\t(bfin_rtx_costs): Some costs for vector operations, to allow combine\n\tto do more work.\n\t(enum bfin_builtins): Add a number of fractional and vector builtins.\n\t(bfin_init_builtins): Likewise.\n\t(struct builtin_description, bdesc_2arg, bdesc_1arg): New.\n\t(safe_vector_operand, bfin_expand_binop_builtin,\n\tbfin_expand_unop_builtin): New functions.\n\t(bfin_expand_builtin): Handle the new builtins.\n\t* config/bfin/bfin.h (TARGET_CPU_CPP_BUILTINS): Define\n\t__ADSPBLACKFIN__.\n\nFrom-SVN: r113521", "tree": {"sha": "cd49c6be4cebd67fb8344a92e4327ac7c26fb89c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cd49c6be4cebd67fb8344a92e4327ac7c26fb89c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/42da70b76e5d7818e9c44c171b354b0ce3226dd0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42da70b76e5d7818e9c44c171b354b0ce3226dd0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42da70b76e5d7818e9c44c171b354b0ce3226dd0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42da70b76e5d7818e9c44c171b354b0ce3226dd0/comments", "author": null, "committer": null, "parents": [{"sha": "554006bd1a4ac1a43bb386198b69682691c7496f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/554006bd1a4ac1a43bb386198b69682691c7496f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/554006bd1a4ac1a43bb386198b69682691c7496f"}], "stats": {"total": 475, "additions": 474, "deletions": 1}, "files": [{"sha": "b74f0cb45fbf0b4552289a308a01a7cf62b02433", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42da70b76e5d7818e9c44c171b354b0ce3226dd0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42da70b76e5d7818e9c44c171b354b0ce3226dd0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=42da70b76e5d7818e9c44c171b354b0ce3226dd0", "patch": "@@ -4,6 +4,18 @@\n \tthat this only matches CONST_INTs.  All users changed to VOIDmode\n \toperands.\n \n+\t* config/bfin/bfin.c: Include \"optabs.h\".\n+\t(bfin_rtx_costs): Some costs for vector operations, to allow combine\n+\tto do more work.\n+\t(enum bfin_builtins): Add a number of fractional and vector builtins.\n+\t(bfin_init_builtins): Likewise.\n+\t(struct builtin_description, bdesc_2arg, bdesc_1arg): New.\n+\t(safe_vector_operand, bfin_expand_binop_builtin,\n+\tbfin_expand_unop_builtin): New functions.\n+\t(bfin_expand_builtin): Handle the new builtins.\n+\t* config/bfin/bfin.h (TARGET_CPU_CPP_BUILTINS): Define\n+\t__ADSPBLACKFIN__.\n+\n 2006-05-04  Leehod Baruch  <leehod@il.ibm.com>\n \n         * see.c: New file."}, {"sha": "c7477113c4a92107b81fac2a0380da4ff04125bd", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 461, "deletions": 1, "changes": 462, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42da70b76e5d7818e9c44c171b354b0ce3226dd0/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42da70b76e5d7818e9c44c171b354b0ce3226dd0/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=42da70b76e5d7818e9c44c171b354b0ce3226dd0", "patch": "@@ -43,6 +43,7 @@\n #include \"expr.h\"\n #include \"toplev.h\"\n #include \"recog.h\"\n+#include \"optabs.h\"\n #include \"ggc.h\"\n #include \"integrate.h\"\n #include \"cgraph.h\"\n@@ -2283,6 +2284,12 @@ bfin_rtx_costs (rtx x, int code, int outer_code, int *total)\n \t*total = COSTS_N_INSNS (3);\n       return false;\n \n+    case VEC_CONCAT:\n+    case VEC_SELECT:\n+      if (outer_code == SET)\n+\t*total = cost2;\n+      return true;\n+\n     default:\n       return false;\n     }\n@@ -2963,6 +2970,56 @@ enum bfin_builtins\n {\n   BFIN_BUILTIN_CSYNC,\n   BFIN_BUILTIN_SSYNC,\n+  BFIN_BUILTIN_COMPOSE_2X16,\n+  BFIN_BUILTIN_EXTRACTLO,\n+  BFIN_BUILTIN_EXTRACTHI,\n+\n+  BFIN_BUILTIN_SSADD_2X16,\n+  BFIN_BUILTIN_SSSUB_2X16,\n+  BFIN_BUILTIN_SSADDSUB_2X16,\n+  BFIN_BUILTIN_SSSUBADD_2X16,\n+  BFIN_BUILTIN_MULT_2X16,\n+  BFIN_BUILTIN_MULTR_2X16,\n+  BFIN_BUILTIN_NEG_2X16,\n+  BFIN_BUILTIN_ABS_2X16,\n+  BFIN_BUILTIN_MIN_2X16,\n+  BFIN_BUILTIN_MAX_2X16,\n+\n+  BFIN_BUILTIN_SSADD_1X16,\n+  BFIN_BUILTIN_SSSUB_1X16,\n+  BFIN_BUILTIN_MULT_1X16,\n+  BFIN_BUILTIN_MULTR_1X16,\n+  BFIN_BUILTIN_NORM_1X16,\n+  BFIN_BUILTIN_NEG_1X16,\n+  BFIN_BUILTIN_ABS_1X16,\n+  BFIN_BUILTIN_MIN_1X16,\n+  BFIN_BUILTIN_MAX_1X16,\n+\n+  BFIN_BUILTIN_DIFFHL_2X16,\n+  BFIN_BUILTIN_DIFFLH_2X16,\n+\n+  BFIN_BUILTIN_SSADD_1X32,\n+  BFIN_BUILTIN_SSSUB_1X32,\n+  BFIN_BUILTIN_NORM_1X32,\n+  BFIN_BUILTIN_NEG_1X32,\n+  BFIN_BUILTIN_MIN_1X32,\n+  BFIN_BUILTIN_MAX_1X32,\n+  BFIN_BUILTIN_MULT_1X32,\n+\n+  BFIN_BUILTIN_MULHISILL,\n+  BFIN_BUILTIN_MULHISILH,\n+  BFIN_BUILTIN_MULHISIHL,\n+  BFIN_BUILTIN_MULHISIHH,\n+\n+  BFIN_BUILTIN_LSHIFT_1X16,\n+  BFIN_BUILTIN_LSHIFT_2X16,\n+  BFIN_BUILTIN_SSASHIFT_1X16,\n+  BFIN_BUILTIN_SSASHIFT_2X16,\n+\n+  BFIN_BUILTIN_CPLX_MUL_16,\n+  BFIN_BUILTIN_CPLX_MAC_16,\n+  BFIN_BUILTIN_CPLX_MSU_16,\n+\n   BFIN_BUILTIN_MAX\n };\n \n@@ -2976,12 +3033,306 @@ do {\t\t\t\t\t\t\t\t\t\\\n static void\n bfin_init_builtins (void)\n {\n+  tree V2HI_type_node = build_vector_type_for_mode (intHI_type_node, V2HImode);\n   tree void_ftype_void\n     = build_function_type (void_type_node, void_list_node);\n+  tree short_ftype_short\n+    = build_function_type_list (short_integer_type_node, short_integer_type_node,\n+\t\t\t\tNULL_TREE);\n+  tree short_ftype_int_int\n+    = build_function_type_list (short_integer_type_node, integer_type_node,\n+\t\t\t\tinteger_type_node, NULL_TREE);\n+  tree int_ftype_int_int\n+    = build_function_type_list (integer_type_node, integer_type_node,\n+\t\t\t\tinteger_type_node, NULL_TREE);\n+  tree int_ftype_int\n+    = build_function_type_list (integer_type_node, integer_type_node,\n+\t\t\t\tNULL_TREE);\n+  tree short_ftype_int\n+    = build_function_type_list (short_integer_type_node, integer_type_node,\n+\t\t\t\tNULL_TREE);\n+  tree int_ftype_v2hi_v2hi\n+    = build_function_type_list (integer_type_node, V2HI_type_node,\n+\t\t\t\tV2HI_type_node, NULL_TREE);\n+  tree v2hi_ftype_v2hi_v2hi\n+    = build_function_type_list (V2HI_type_node, V2HI_type_node,\n+\t\t\t\tV2HI_type_node, NULL_TREE);\n+  tree v2hi_ftype_v2hi_v2hi_v2hi\n+    = build_function_type_list (V2HI_type_node, V2HI_type_node,\n+\t\t\t\tV2HI_type_node, V2HI_type_node, NULL_TREE);\n+  tree v2hi_ftype_int_int\n+    = build_function_type_list (V2HI_type_node, integer_type_node,\n+\t\t\t\tinteger_type_node, NULL_TREE);\n+  tree v2hi_ftype_v2hi_int\n+    = build_function_type_list (V2HI_type_node, V2HI_type_node,\n+\t\t\t\tinteger_type_node, NULL_TREE);\n+  tree int_ftype_short_short\n+    = build_function_type_list (integer_type_node, short_integer_type_node,\n+\t\t\t\tshort_integer_type_node, NULL_TREE);\n+  tree v2hi_ftype_v2hi\n+    = build_function_type_list (V2HI_type_node, V2HI_type_node, NULL_TREE);\n+  tree short_ftype_v2hi\n+    = build_function_type_list (short_integer_type_node, V2HI_type_node,\n+\t\t\t\tNULL_TREE);\n \n   /* Add the remaining MMX insns with somewhat more complicated types.  */\n   def_builtin (\"__builtin_bfin_csync\", void_ftype_void, BFIN_BUILTIN_CSYNC);\n   def_builtin (\"__builtin_bfin_ssync\", void_ftype_void, BFIN_BUILTIN_SSYNC);\n+\n+  def_builtin (\"__builtin_bfin_compose_2x16\", v2hi_ftype_int_int,\n+\t       BFIN_BUILTIN_COMPOSE_2X16);\n+  def_builtin (\"__builtin_bfin_extract_hi\", short_ftype_v2hi,\n+\t       BFIN_BUILTIN_EXTRACTHI);\n+  def_builtin (\"__builtin_bfin_extract_lo\", short_ftype_v2hi,\n+\t       BFIN_BUILTIN_EXTRACTLO);\n+\n+  def_builtin (\"__builtin_bfin_min_fr2x16\", v2hi_ftype_v2hi_v2hi,\n+\t       BFIN_BUILTIN_MIN_2X16);\n+  def_builtin (\"__builtin_bfin_max_fr2x16\", v2hi_ftype_v2hi_v2hi,\n+\t       BFIN_BUILTIN_MAX_2X16);\n+\n+  def_builtin (\"__builtin_bfin_add_fr2x16\", v2hi_ftype_v2hi_v2hi,\n+\t       BFIN_BUILTIN_SSADD_2X16);\n+  def_builtin (\"__builtin_bfin_sub_fr2x16\", v2hi_ftype_v2hi_v2hi,\n+\t       BFIN_BUILTIN_SSSUB_2X16);\n+  def_builtin (\"__builtin_bfin_dspaddsubsat\", v2hi_ftype_v2hi_v2hi,\n+\t       BFIN_BUILTIN_SSADDSUB_2X16);\n+  def_builtin (\"__builtin_bfin_dspsubaddsat\", v2hi_ftype_v2hi_v2hi,\n+\t       BFIN_BUILTIN_SSSUBADD_2X16);\n+  def_builtin (\"__builtin_bfin_mult_fr2x16\", v2hi_ftype_v2hi_v2hi,\n+\t       BFIN_BUILTIN_MULT_2X16);\n+  def_builtin (\"__builtin_bfin_multr_fr2x16\", v2hi_ftype_v2hi_v2hi,\n+\t       BFIN_BUILTIN_MULTR_2X16);\n+  def_builtin (\"__builtin_bfin_negate_fr2x16\", v2hi_ftype_v2hi,\n+\t       BFIN_BUILTIN_NEG_2X16);\n+  def_builtin (\"__builtin_bfin_abs_fr2x16\", v2hi_ftype_v2hi,\n+\t       BFIN_BUILTIN_ABS_2X16);\n+\n+  def_builtin (\"__builtin_bfin_add_fr1x16\", short_ftype_int_int,\n+\t       BFIN_BUILTIN_SSADD_1X16);\n+  def_builtin (\"__builtin_bfin_sub_fr1x16\", short_ftype_int_int,\n+\t       BFIN_BUILTIN_SSSUB_1X16);\n+  def_builtin (\"__builtin_bfin_mult_fr1x16\", short_ftype_int_int,\n+\t       BFIN_BUILTIN_MULT_1X16);\n+  def_builtin (\"__builtin_bfin_multr_fr1x16\", short_ftype_int_int,\n+\t       BFIN_BUILTIN_MULTR_1X16);\n+  def_builtin (\"__builtin_bfin_negate_fr1x16\", short_ftype_short,\n+\t       BFIN_BUILTIN_NEG_1X16);\n+  def_builtin (\"__builtin_bfin_abs_fr1x16\", short_ftype_short,\n+\t       BFIN_BUILTIN_ABS_1X16);\n+  def_builtin (\"__builtin_bfin_norm_fr1x16\", short_ftype_int,\n+\t       BFIN_BUILTIN_NORM_1X16);\n+\n+  def_builtin (\"__builtin_bfin_diff_hl_fr2x16\", short_ftype_v2hi,\n+\t       BFIN_BUILTIN_DIFFHL_2X16);\n+  def_builtin (\"__builtin_bfin_diff_lh_fr2x16\", short_ftype_v2hi,\n+\t       BFIN_BUILTIN_DIFFLH_2X16);\n+\n+  def_builtin (\"__builtin_bfin_mulhisill\", int_ftype_v2hi_v2hi,\n+\t       BFIN_BUILTIN_MULHISILL);\n+  def_builtin (\"__builtin_bfin_mulhisihl\", int_ftype_v2hi_v2hi,\n+\t       BFIN_BUILTIN_MULHISIHL);\n+  def_builtin (\"__builtin_bfin_mulhisilh\", int_ftype_v2hi_v2hi,\n+\t       BFIN_BUILTIN_MULHISILH);\n+  def_builtin (\"__builtin_bfin_mulhisihh\", int_ftype_v2hi_v2hi,\n+\t       BFIN_BUILTIN_MULHISIHH);\n+\n+  def_builtin (\"__builtin_bfin_add_fr1x32\", int_ftype_int_int,\n+\t       BFIN_BUILTIN_SSADD_1X32);\n+  def_builtin (\"__builtin_bfin_sub_fr1x32\", int_ftype_int_int,\n+\t       BFIN_BUILTIN_SSSUB_1X32);\n+  def_builtin (\"__builtin_bfin_negate_fr1x32\", int_ftype_int,\n+\t       BFIN_BUILTIN_NEG_1X32);\n+  def_builtin (\"__builtin_bfin_norm_fr1x32\", short_ftype_int,\n+\t       BFIN_BUILTIN_NORM_1X32);\n+  def_builtin (\"__builtin_bfin_mult_fr1x32\", int_ftype_short_short,\n+\t       BFIN_BUILTIN_MULT_1X32);\n+\n+  /* Shifts.  */\n+  def_builtin (\"__builtin_bfin_shl_fr1x16\", short_ftype_int_int,\n+\t       BFIN_BUILTIN_SSASHIFT_1X16);\n+  def_builtin (\"__builtin_bfin_shl_fr2x16\", v2hi_ftype_v2hi_int,\n+\t       BFIN_BUILTIN_SSASHIFT_2X16);\n+  def_builtin (\"__builtin_bfin_lshl_fr1x16\", short_ftype_int_int,\n+\t       BFIN_BUILTIN_LSHIFT_1X16);\n+  def_builtin (\"__builtin_bfin_lshl_fr2x16\", v2hi_ftype_v2hi_int,\n+\t       BFIN_BUILTIN_LSHIFT_2X16);\n+\n+  /* Complex numbers.  */\n+  def_builtin (\"__builtin_bfin_cmplx_mul\", v2hi_ftype_v2hi_v2hi,\n+\t       BFIN_BUILTIN_CPLX_MUL_16);\n+  def_builtin (\"__builtin_bfin_cmplx_mac\", v2hi_ftype_v2hi_v2hi_v2hi,\n+\t       BFIN_BUILTIN_CPLX_MAC_16);\n+  def_builtin (\"__builtin_bfin_cmplx_msu\", v2hi_ftype_v2hi_v2hi_v2hi,\n+\t       BFIN_BUILTIN_CPLX_MSU_16);\n+}\n+\n+\n+struct builtin_description\n+{\n+  const enum insn_code icode;\n+  const char *const name;\n+  const enum bfin_builtins code;\n+  int macflag;\n+};\n+\n+static const struct builtin_description bdesc_2arg[] =\n+{\n+  { CODE_FOR_composev2hi, \"__builtin_bfin_compose_2x16\", BFIN_BUILTIN_COMPOSE_2X16, -1 },\n+\n+  { CODE_FOR_ssashiftv2hi3, \"__builtin_bfin_shl_fr2x16\", BFIN_BUILTIN_SSASHIFT_2X16, -1 },\n+  { CODE_FOR_ssashifthi3, \"__builtin_bfin_shl_fr1x16\", BFIN_BUILTIN_SSASHIFT_1X16, -1 },\n+  { CODE_FOR_lshiftv2hi3, \"__builtin_bfin_lshl_fr2x16\", BFIN_BUILTIN_LSHIFT_2X16, -1 },\n+  { CODE_FOR_lshifthi3, \"__builtin_bfin_lshl_fr1x16\", BFIN_BUILTIN_LSHIFT_1X16, -1 },\n+\n+  { CODE_FOR_sminhi3, \"__builtin_bfin_min_fr1x16\", BFIN_BUILTIN_MIN_1X16, -1 },\n+  { CODE_FOR_smaxhi3, \"__builtin_bfin_max_fr1x16\", BFIN_BUILTIN_MAX_1X16, -1 },\n+  { CODE_FOR_ssaddhi3, \"__builtin_bfin_add_fr1x16\", BFIN_BUILTIN_SSADD_1X16, -1 },\n+  { CODE_FOR_sssubhi3, \"__builtin_bfin_sub_fr1x16\", BFIN_BUILTIN_SSSUB_1X16, -1 },\n+\n+  { CODE_FOR_sminsi3, \"__builtin_bfin_min_fr1x32\", BFIN_BUILTIN_MIN_1X32, -1 },\n+  { CODE_FOR_smaxsi3, \"__builtin_bfin_max_fr1x32\", BFIN_BUILTIN_MAX_1X32, -1 },\n+  { CODE_FOR_ssaddsi3, \"__builtin_bfin_add_fr1x32\", BFIN_BUILTIN_SSADD_1X32, -1 },\n+  { CODE_FOR_sssubsi3, \"__builtin_bfin_sub_fr1x32\", BFIN_BUILTIN_SSSUB_1X32, -1 },\n+\n+  { CODE_FOR_sminv2hi3, \"__builtin_bfin_min_fr2x16\", BFIN_BUILTIN_MIN_2X16, -1 },\n+  { CODE_FOR_smaxv2hi3, \"__builtin_bfin_max_fr2x16\", BFIN_BUILTIN_MAX_2X16, -1 },\n+  { CODE_FOR_ssaddv2hi3, \"__builtin_bfin_add_fr2x16\", BFIN_BUILTIN_SSADD_2X16, -1 },\n+  { CODE_FOR_sssubv2hi3, \"__builtin_bfin_sub_fr2x16\", BFIN_BUILTIN_SSSUB_2X16, -1 },\n+  { CODE_FOR_ssaddsubv2hi3, \"__builtin_bfin_dspaddsubsat\", BFIN_BUILTIN_SSADDSUB_2X16, -1 },\n+  { CODE_FOR_sssubaddv2hi3, \"__builtin_bfin_dspsubaddsat\", BFIN_BUILTIN_SSSUBADD_2X16, -1 },\n+\n+  { CODE_FOR_flag_mulhisi, \"__builtin_bfin_mult_fr1x32\", BFIN_BUILTIN_MULT_1X32, MACFLAG_NONE },\n+  { CODE_FOR_flag_mulhi, \"__builtin_bfin_mult_fr1x16\", BFIN_BUILTIN_MULT_1X16, MACFLAG_T },\n+  { CODE_FOR_flag_mulhi, \"__builtin_bfin_multr_fr1x16\", BFIN_BUILTIN_MULTR_1X16, MACFLAG_NONE },\n+  { CODE_FOR_flag_mulv2hi, \"__builtin_bfin_mult_fr2x16\", BFIN_BUILTIN_MULT_2X16, MACFLAG_T },\n+  { CODE_FOR_flag_mulv2hi, \"__builtin_bfin_multr_fr2x16\", BFIN_BUILTIN_MULTR_2X16, MACFLAG_NONE }\n+};\n+\n+static const struct builtin_description bdesc_1arg[] =\n+{\n+  { CODE_FOR_signbitshi2, \"__builtin_bfin_norm_fr1x16\", BFIN_BUILTIN_NORM_1X16, 0 },\n+  { CODE_FOR_ssneghi2, \"__builtin_bfin_negate_fr1x16\", BFIN_BUILTIN_NEG_1X16, 0 },\n+  { CODE_FOR_abshi2, \"__builtin_bfin_abs_fr1x16\", BFIN_BUILTIN_ABS_1X16, 0 },\n+\n+  { CODE_FOR_signbitssi2, \"__builtin_bfin_norm_fr1x32\", BFIN_BUILTIN_NORM_1X32, 0 },\n+  { CODE_FOR_ssnegsi2, \"__builtin_bfin_negate_fr1x32\", BFIN_BUILTIN_NEG_1X32, 0 },\n+\n+  { CODE_FOR_movv2hi_hi_low, \"__builtin_bfin_extract_lo\", BFIN_BUILTIN_EXTRACTLO, 0 },\n+  { CODE_FOR_movv2hi_hi_high, \"__builtin_bfin_extract_hi\", BFIN_BUILTIN_EXTRACTHI, 0 },\n+  { CODE_FOR_ssnegv2hi2, \"__builtin_bfin_negate_fr2x16\", BFIN_BUILTIN_NEG_2X16, 0 },\n+  { CODE_FOR_absv2hi2, \"__builtin_bfin_abs_fr2x16\", BFIN_BUILTIN_ABS_2X16, 0 }\n+};\n+\n+/* Errors in the source file can cause expand_expr to return const0_rtx\n+   where we expect a vector.  To avoid crashing, use one of the vector\n+   clear instructions.  */\n+static rtx\n+safe_vector_operand (rtx x, enum machine_mode mode)\n+{\n+  if (x != const0_rtx)\n+    return x;\n+  x = gen_reg_rtx (SImode);\n+\n+  emit_insn (gen_movsi (x, CONST0_RTX (SImode)));\n+  return gen_lowpart (mode, x);\n+}\n+\n+/* Subroutine of bfin_expand_builtin to take care of binop insns.  MACFLAG is -1\n+   if this is a normal binary op, or one of the MACFLAG_xxx constants.  */\n+\n+static rtx\n+bfin_expand_binop_builtin (enum insn_code icode, tree arglist, rtx target,\n+\t\t\t   int macflag)\n+{\n+  rtx pat;\n+  tree arg0 = TREE_VALUE (arglist);\n+  tree arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n+  rtx op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n+  rtx op1 = expand_expr (arg1, NULL_RTX, VOIDmode, 0);\n+  enum machine_mode op0mode = GET_MODE (op0);\n+  enum machine_mode op1mode = GET_MODE (op1);\n+  enum machine_mode tmode = insn_data[icode].operand[0].mode;\n+  enum machine_mode mode0 = insn_data[icode].operand[1].mode;\n+  enum machine_mode mode1 = insn_data[icode].operand[2].mode;\n+\n+  if (VECTOR_MODE_P (mode0))\n+    op0 = safe_vector_operand (op0, mode0);\n+  if (VECTOR_MODE_P (mode1))\n+    op1 = safe_vector_operand (op1, mode1);\n+\n+  if (! target\n+      || GET_MODE (target) != tmode\n+      || ! (*insn_data[icode].operand[0].predicate) (target, tmode))\n+    target = gen_reg_rtx (tmode);\n+\n+  if ((op0mode == SImode || op0mode == VOIDmode) && mode0 == HImode)\n+    {\n+      op0mode = HImode;\n+      op0 = gen_lowpart (HImode, op0);\n+    }\n+  if ((op1mode == SImode || op1mode == VOIDmode) && mode1 == HImode)\n+    {\n+      op1mode = HImode;\n+      op1 = gen_lowpart (HImode, op1);\n+    }\n+  /* In case the insn wants input operands in modes different from\n+     the result, abort.  */\n+  gcc_assert ((op0mode == mode0 || op0mode == VOIDmode)\n+\t      && (op1mode == mode1 || op1mode == VOIDmode));\n+\n+  if (! (*insn_data[icode].operand[1].predicate) (op0, mode0))\n+    op0 = copy_to_mode_reg (mode0, op0);\n+  if (! (*insn_data[icode].operand[2].predicate) (op1, mode1))\n+    op1 = copy_to_mode_reg (mode1, op1);\n+\n+  if (macflag == -1)\n+    pat = GEN_FCN (icode) (target, op0, op1);\n+  else\n+    pat = GEN_FCN (icode) (target, op0, op1, GEN_INT (macflag));\n+  if (! pat)\n+    return 0;\n+\n+  emit_insn (pat);\n+  return target;\n+}\n+\n+/* Subroutine of bfin_expand_builtin to take care of unop insns.  */\n+\n+static rtx\n+bfin_expand_unop_builtin (enum insn_code icode, tree arglist,\n+\t\t\t  rtx target)\n+{\n+  rtx pat;\n+  tree arg0 = TREE_VALUE (arglist);\n+  rtx op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n+  enum machine_mode op0mode = GET_MODE (op0);\n+  enum machine_mode tmode = insn_data[icode].operand[0].mode;\n+  enum machine_mode mode0 = insn_data[icode].operand[1].mode;\n+\n+  if (! target\n+      || GET_MODE (target) != tmode\n+      || ! (*insn_data[icode].operand[0].predicate) (target, tmode))\n+    target = gen_reg_rtx (tmode);\n+\n+  if (VECTOR_MODE_P (mode0))\n+    op0 = safe_vector_operand (op0, mode0);\n+\n+  if (op0mode == SImode && mode0 == HImode)\n+    {\n+      op0mode = HImode;\n+      op0 = gen_lowpart (HImode, op0);\n+    }\n+  gcc_assert (op0mode == mode0 || op0mode == VOIDmode);\n+\n+  if (! (*insn_data[icode].operand[1].predicate) (op0, mode0))\n+    op0 = copy_to_mode_reg (mode0, op0);\n+\n+  pat = GEN_FCN (icode) (target, op0);\n+  if (! pat)\n+    return 0;\n+  emit_insn (pat);\n+  return target;\n }\n \n /* Expand an expression EXP that calls a built-in function,\n@@ -2996,8 +3347,15 @@ bfin_expand_builtin (tree exp, rtx target ATTRIBUTE_UNUSED,\n \t\t     enum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t     int ignore ATTRIBUTE_UNUSED)\n {\n+  size_t i;\n+  enum insn_code icode;\n+  const struct builtin_description *d;\n   tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n+  tree arglist = TREE_OPERAND (exp, 1);\n   unsigned int fcode = DECL_FUNCTION_CODE (fndecl);\n+  tree arg0, arg1, arg2;\n+  rtx op0, op1, op2, accvec, pat, tmp1, tmp2;\n+  enum machine_mode tmode, mode0;\n \n   switch (fcode)\n     {\n@@ -3008,9 +3366,111 @@ bfin_expand_builtin (tree exp, rtx target ATTRIBUTE_UNUSED,\n       emit_insn (gen_ssync ());\n       return 0;\n \n+    case BFIN_BUILTIN_DIFFHL_2X16:\n+    case BFIN_BUILTIN_DIFFLH_2X16:\n+      arg0 = TREE_VALUE (arglist);\n+      op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n+      icode = (fcode == BFIN_BUILTIN_DIFFHL_2X16\n+\t       ? CODE_FOR_subhilov2hi3 : CODE_FOR_sublohiv2hi3);\n+      tmode = insn_data[icode].operand[0].mode;\n+      mode0 = insn_data[icode].operand[1].mode;\n+\n+      if (! target\n+\t  || GET_MODE (target) != tmode\n+\t  || ! (*insn_data[icode].operand[0].predicate) (target, tmode))\n+\ttarget = gen_reg_rtx (tmode);\n+\n+      if (VECTOR_MODE_P (mode0))\n+\top0 = safe_vector_operand (op0, mode0);\n+\n+      if (! (*insn_data[icode].operand[1].predicate) (op0, mode0))\n+\top0 = copy_to_mode_reg (mode0, op0);\n+\n+      pat = GEN_FCN (icode) (target, op0, op0);\n+      if (! pat)\n+\treturn 0;\n+      emit_insn (pat);\n+      return target;\n+\n+    case BFIN_BUILTIN_CPLX_MUL_16:\n+      arg0 = TREE_VALUE (arglist);\n+      arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n+      op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n+      op1 = expand_expr (arg1, NULL_RTX, VOIDmode, 0);\n+      accvec = gen_reg_rtx (V2PDImode);\n+\n+      if (! target\n+\t  || GET_MODE (target) != V2HImode\n+\t  || ! (*insn_data[icode].operand[0].predicate) (target, V2HImode))\n+\ttarget = gen_reg_rtx (tmode);\n+      if (! register_operand (op0, GET_MODE (op0)))\n+\top0 = copy_to_mode_reg (GET_MODE (op0), op0);\n+      if (! register_operand (op1, GET_MODE (op1)))\n+\top1 = copy_to_mode_reg (GET_MODE (op1), op1);\n+\n+      emit_insn (gen_flag_macinit1v2hi_parts (accvec, op0, op1, const0_rtx,\n+\t\t\t\t\t      const0_rtx, const0_rtx,\n+\t\t\t\t\t      const1_rtx, GEN_INT (MACFLAG_NONE)));\n+      emit_insn (gen_flag_macv2hi_parts (target, op0, op1, const1_rtx,\n+\t\t\t\t\t const1_rtx, const1_rtx,\n+\t\t\t\t\t const0_rtx, accvec, const1_rtx, const0_rtx,\n+\t\t\t\t\t GEN_INT (MACFLAG_NONE), accvec));\n+\n+      return target;\n+\n+    case BFIN_BUILTIN_CPLX_MAC_16:\n+    case BFIN_BUILTIN_CPLX_MSU_16:\n+      arg0 = TREE_VALUE (arglist);\n+      arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n+      arg2 = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n+      op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n+      op1 = expand_expr (arg1, NULL_RTX, VOIDmode, 0);\n+      op2 = expand_expr (arg2, NULL_RTX, VOIDmode, 0);\n+      accvec = gen_reg_rtx (V2PDImode);\n+\n+      if (! target\n+\t  || GET_MODE (target) != V2HImode\n+\t  || ! (*insn_data[icode].operand[0].predicate) (target, V2HImode))\n+\ttarget = gen_reg_rtx (tmode);\n+      if (! register_operand (op0, GET_MODE (op0)))\n+\top0 = copy_to_mode_reg (GET_MODE (op0), op0);\n+      if (! register_operand (op1, GET_MODE (op1)))\n+\top1 = copy_to_mode_reg (GET_MODE (op1), op1);\n+\n+      tmp1 = gen_reg_rtx (SImode);\n+      tmp2 = gen_reg_rtx (SImode);\n+      emit_insn (gen_ashlsi3 (tmp1, gen_lowpart (SImode, op2), GEN_INT (16)));\n+      emit_move_insn (tmp2, gen_lowpart (SImode, op2));\n+      emit_insn (gen_movstricthi_1 (gen_lowpart (HImode, tmp2), const0_rtx));\n+      emit_insn (gen_load_accumulator_pair (accvec, tmp1, tmp2));\n+      emit_insn (gen_flag_macv2hi_parts_acconly (accvec, op0, op1, const0_rtx,\n+\t\t\t\t\t\t const0_rtx, const0_rtx,\n+\t\t\t\t\t\t const1_rtx, accvec, const0_rtx,\n+\t\t\t\t\t\t const0_rtx,\n+\t\t\t\t\t\t GEN_INT (MACFLAG_W32)));\n+      tmp1 = (fcode == BFIN_BUILTIN_CPLX_MAC_16 ? const1_rtx : const0_rtx);\n+      tmp2 = (fcode == BFIN_BUILTIN_CPLX_MAC_16 ? const0_rtx : const1_rtx);\n+      emit_insn (gen_flag_macv2hi_parts (target, op0, op1, const1_rtx,\n+\t\t\t\t\t const1_rtx, const1_rtx,\n+\t\t\t\t\t const0_rtx, accvec, tmp1, tmp2,\n+\t\t\t\t\t GEN_INT (MACFLAG_NONE), accvec));\n+\n+      return target;\n+\n     default:\n-      gcc_unreachable ();\n+      break;\n     }\n+\n+  for (i = 0, d = bdesc_2arg; i < ARRAY_SIZE (bdesc_2arg); i++, d++)\n+    if (d->code == fcode)\n+      return bfin_expand_binop_builtin (d->icode, arglist, target,\n+\t\t\t\t\td->macflag);\n+\n+  for (i = 0, d = bdesc_1arg; i < ARRAY_SIZE (bdesc_1arg); i++, d++)\n+    if (d->code == fcode)\n+      return bfin_expand_unop_builtin (d->icode, arglist, target);\n+\n+  gcc_unreachable ();\n }\n \f\n #undef TARGET_INIT_BUILTINS"}, {"sha": "21f107055d91e2399cf475e04da6b2e304f7072b", "filename": "gcc/config/bfin/bfin.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42da70b76e5d7818e9c44c171b354b0ce3226dd0/gcc%2Fconfig%2Fbfin%2Fbfin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42da70b76e5d7818e9c44c171b354b0ce3226dd0/gcc%2Fconfig%2Fbfin%2Fbfin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.h?ref=42da70b76e5d7818e9c44c171b354b0ce3226dd0", "patch": "@@ -41,6 +41,7 @@ extern int target_flags;\n     {                                           \\\n       builtin_define (\"bfin\");                  \\\n       builtin_define (\"BFIN\");                  \\\n+      builtin_define (\"__ADSPBLACKFIN__\");\t\\\n       if (TARGET_ID_SHARED_LIBRARY)\t\t\\\n \tbuiltin_define (\"__ID_SHARED_LIB__\");\t\\\n     }                                           \\"}]}