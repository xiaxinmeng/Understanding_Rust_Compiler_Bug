{"sha": "b5068425b9d7ab59694014bc78d4a29e04e44918", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjUwNjg0MjViOWQ3YWI1OTY5NDAxNGJjNzhkNGEyOWUwNGU0NDkxOA==", "commit": {"author": {"name": "Andreas Krebbel", "email": "Andreas.Krebbel@de.ibm.com", "date": "2012-04-26T08:15:45Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2012-04-26T08:15:45Z"}, "message": "reload.c (find_reloads): Change the loop nesting when trying an alternative with swapped operands.\n\n2012-04-26  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n\n\t* reload.c (find_reloads): Change the loop nesting when trying an\n\talternative with swapped operands.\n\nFrom-SVN: r186861", "tree": {"sha": "bdf1d40539dbb7fb71331cf144f566a3eba0e5e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bdf1d40539dbb7fb71331cf144f566a3eba0e5e9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b5068425b9d7ab59694014bc78d4a29e04e44918", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5068425b9d7ab59694014bc78d4a29e04e44918", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5068425b9d7ab59694014bc78d4a29e04e44918", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5068425b9d7ab59694014bc78d4a29e04e44918/comments", "author": null, "committer": null, "parents": [{"sha": "1d72e96f53abe39dfa4cefce338d2886a9ae0ea1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d72e96f53abe39dfa4cefce338d2886a9ae0ea1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d72e96f53abe39dfa4cefce338d2886a9ae0ea1"}], "stats": {"total": 1540, "additions": 779, "deletions": 761}, "files": [{"sha": "f79f49deacb0b64480eef75ca26cb40741aae801", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5068425b9d7ab59694014bc78d4a29e04e44918/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5068425b9d7ab59694014bc78d4a29e04e44918/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b5068425b9d7ab59694014bc78d4a29e04e44918", "patch": "@@ -1,3 +1,8 @@\n+2012-04-26  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n+\n+\t* reload.c (find_reloads): Change the loop nesting when trying an\n+\talternative with swapped operands.\n+\n 2012-04-26  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n \n \t* tree-diagnostic.c (maybe_unwind_expanded_macro_loc): Fix"}, {"sha": "9eddc4d414af07c0609e6e64319c7ad25904cacb", "filename": "gcc/reload.c", "status": "modified", "additions": 774, "deletions": 761, "changes": 1535, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5068425b9d7ab59694014bc78d4a29e04e44918/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5068425b9d7ab59694014bc78d4a29e04e44918/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=b5068425b9d7ab59694014bc78d4a29e04e44918", "patch": "@@ -2592,7 +2592,6 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n   char this_alternative_offmemok[MAX_RECOG_OPERANDS];\n   char this_alternative_earlyclobber[MAX_RECOG_OPERANDS];\n   int this_alternative_matches[MAX_RECOG_OPERANDS];\n-  int swapped;\n   reg_class_t goal_alternative[MAX_RECOG_OPERANDS];\n   int this_alternative_number;\n   int goal_alternative_number = 0;\n@@ -2938,9 +2937,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \n   best = MAX_RECOG_OPERANDS * 2 + 600;\n \n-  swapped = 0;\n   goal_alternative_swapped = 0;\n- try_swapped:\n \n   /* The constraints are made of several alternatives.\n      Each operand's constraint looks like foo,bar,... with commas\n@@ -2953,20 +2950,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n        this_alternative_number < n_alternatives;\n        this_alternative_number++)\n     {\n-      /* Loop over operands for one constraint alternative.  */\n-      /* LOSERS counts those that don't fit this alternative\n-\t and would require loading.  */\n-      int losers = 0;\n-      /* BAD is set to 1 if it some operand can't fit this alternative\n-\t even after reloading.  */\n-      int bad = 0;\n-      /* REJECT is a count of how undesirable this alternative says it is\n-\t if any reloading is required.  If the alternative matches exactly\n-\t then REJECT is ignored, but otherwise it gets this much\n-\t counted against it in addition to the reloading needed.  Each\n-\t ? counts three times here since we want the disparaging caused by\n-\t a bad register class to only count 1/3 as much.  */\n-      int reject = 0;\n+      int swapped;\n \n       if (!recog_data.alternative_enabled_p[this_alternative_number])\n \t{\n@@ -2978,825 +2962,854 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t  continue;\n \t}\n \n-      this_earlyclobber = 0;\n-\n-      for (i = 0; i < noperands; i++)\n+      /* If insn is commutative (it's safe to exchange a certain pair\n+\t of operands) then we need to try each alternative twice, the\n+\t second time matching those two operands as if we had\n+\t exchanged them.  To do this, really exchange them in\n+\t operands.  */\n+      for (swapped = 0; swapped < (commutative >= 0 ? 2 : 1); swapped++)\n \t{\n-\t  const char *p = constraints[i];\n-\t  char *end;\n-\t  int len;\n-\t  int win = 0;\n-\t  int did_match = 0;\n-\t  /* 0 => this operand can be reloaded somehow for this alternative.  */\n-\t  int badop = 1;\n-\t  /* 0 => this operand can be reloaded if the alternative allows regs.  */\n-\t  int winreg = 0;\n-\t  int c;\n-\t  int m;\n-\t  rtx operand = recog_data.operand[i];\n-\t  int offset = 0;\n-\t  /* Nonzero means this is a MEM that must be reloaded into a reg\n-\t     regardless of what the constraint says.  */\n-\t  int force_reload = 0;\n-\t  int offmemok = 0;\n-\t  /* Nonzero if a constant forced into memory would be OK for this\n-\t     operand.  */\n-\t  int constmemok = 0;\n-\t  int earlyclobber = 0;\n-\n-\t  /* If the predicate accepts a unary operator, it means that\n-\t     we need to reload the operand, but do not do this for\n-\t     match_operator and friends.  */\n-\t  if (UNARY_P (operand) && *p != 0)\n-\t    operand = XEXP (operand, 0);\n-\n-\t  /* If the operand is a SUBREG, extract\n-\t     the REG or MEM (or maybe even a constant) within.\n-\t     (Constants can occur as a result of reg_equiv_constant.)  */\n-\n-\t  while (GET_CODE (operand) == SUBREG)\n+\t  /* Loop over operands for one constraint alternative.  */\n+\t  /* LOSERS counts those that don't fit this alternative\n+\t     and would require loading.  */\n+\t  int losers = 0;\n+\t  /* BAD is set to 1 if it some operand can't fit this alternative\n+\t     even after reloading.  */\n+\t  int bad = 0;\n+\t  /* REJECT is a count of how undesirable this alternative says it is\n+\t     if any reloading is required.  If the alternative matches exactly\n+\t     then REJECT is ignored, but otherwise it gets this much\n+\t     counted against it in addition to the reloading needed.  Each\n+\t     ? counts three times here since we want the disparaging caused by\n+\t     a bad register class to only count 1/3 as much.  */\n+\t  int reject = 0;\n+\n+\t  if (swapped)\n+\t    {\n+\t      enum reg_class tclass;\n+\t      int t;\n+\n+\t      recog_data.operand[commutative] = substed_operand[commutative + 1];\n+\t      recog_data.operand[commutative + 1] = substed_operand[commutative];\n+\t      /* Swap the duplicates too.  */\n+\t      for (i = 0; i < recog_data.n_dups; i++)\n+\t\tif (recog_data.dup_num[i] == commutative\n+\t\t    || recog_data.dup_num[i] == commutative + 1)\n+\t\t  *recog_data.dup_loc[i]\n+\t\t    = recog_data.operand[(int) recog_data.dup_num[i]];\n+\n+\t      tclass = preferred_class[commutative];\n+\t      preferred_class[commutative] = preferred_class[commutative + 1];\n+\t      preferred_class[commutative + 1] = tclass;\n+\n+\t      t = pref_or_nothing[commutative];\n+\t      pref_or_nothing[commutative] = pref_or_nothing[commutative + 1];\n+\t      pref_or_nothing[commutative + 1] = t;\n+\n+\t      t = address_reloaded[commutative];\n+\t      address_reloaded[commutative] = address_reloaded[commutative + 1];\n+\t      address_reloaded[commutative + 1] = t;\n+\t    }\n+\n+\t  this_earlyclobber = 0;\n+\n+\t  for (i = 0; i < noperands; i++)\n \t    {\n-\t      /* Offset only matters when operand is a REG and\n-\t\t it is a hard reg.  This is because it is passed\n-\t\t to reg_fits_class_p if it is a REG and all pseudos\n-\t\t return 0 from that function.  */\n-\t      if (REG_P (SUBREG_REG (operand))\n-\t\t  && REGNO (SUBREG_REG (operand)) < FIRST_PSEUDO_REGISTER)\n+\t      const char *p = constraints[i];\n+\t      char *end;\n+\t      int len;\n+\t      int win = 0;\n+\t      int did_match = 0;\n+\t      /* 0 => this operand can be reloaded somehow for this alternative.  */\n+\t      int badop = 1;\n+\t      /* 0 => this operand can be reloaded if the alternative allows regs.  */\n+\t      int winreg = 0;\n+\t      int c;\n+\t      int m;\n+\t      rtx operand = recog_data.operand[i];\n+\t      int offset = 0;\n+\t      /* Nonzero means this is a MEM that must be reloaded into a reg\n+\t\t regardless of what the constraint says.  */\n+\t      int force_reload = 0;\n+\t      int offmemok = 0;\n+\t      /* Nonzero if a constant forced into memory would be OK for this\n+\t\t operand.  */\n+\t      int constmemok = 0;\n+\t      int earlyclobber = 0;\n+\n+\t      /* If the predicate accepts a unary operator, it means that\n+\t\t we need to reload the operand, but do not do this for\n+\t\t match_operator and friends.  */\n+\t      if (UNARY_P (operand) && *p != 0)\n+\t\toperand = XEXP (operand, 0);\n+\n+\t      /* If the operand is a SUBREG, extract\n+\t\t the REG or MEM (or maybe even a constant) within.\n+\t\t (Constants can occur as a result of reg_equiv_constant.)  */\n+\n+\t      while (GET_CODE (operand) == SUBREG)\n \t\t{\n-\t\t  if (simplify_subreg_regno (REGNO (SUBREG_REG (operand)),\n-\t\t\t\t\t     GET_MODE (SUBREG_REG (operand)),\n-\t\t\t\t\t     SUBREG_BYTE (operand),\n-\t\t\t\t\t     GET_MODE (operand)) < 0)\n-\t\t    force_reload = 1;\n-\t\t  offset += subreg_regno_offset (REGNO (SUBREG_REG (operand)),\n+\t\t  /* Offset only matters when operand is a REG and\n+\t\t     it is a hard reg.  This is because it is passed\n+\t\t     to reg_fits_class_p if it is a REG and all pseudos\n+\t\t     return 0 from that function.  */\n+\t\t  if (REG_P (SUBREG_REG (operand))\n+\t\t      && REGNO (SUBREG_REG (operand)) < FIRST_PSEUDO_REGISTER)\n+\t\t    {\n+\t\t      if (simplify_subreg_regno (REGNO (SUBREG_REG (operand)),\n \t\t\t\t\t\t GET_MODE (SUBREG_REG (operand)),\n \t\t\t\t\t\t SUBREG_BYTE (operand),\n-\t\t\t\t\t\t GET_MODE (operand));\n-\t\t}\n-\t      operand = SUBREG_REG (operand);\n-\t      /* Force reload if this is a constant or PLUS or if there may\n-\t\t be a problem accessing OPERAND in the outer mode.  */\n-\t      if (CONSTANT_P (operand)\n-\t\t  || GET_CODE (operand) == PLUS\n-\t\t  /* We must force a reload of paradoxical SUBREGs\n-\t\t     of a MEM because the alignment of the inner value\n-\t\t     may not be enough to do the outer reference.  On\n-\t\t     big-endian machines, it may also reference outside\n-\t\t     the object.\n-\n-\t\t     On machines that extend byte operations and we have a\n-\t\t     SUBREG where both the inner and outer modes are no wider\n-\t\t     than a word and the inner mode is narrower, is integral,\n-\t\t     and gets extended when loaded from memory, combine.c has\n-\t\t     made assumptions about the behavior of the machine in such\n-\t\t     register access.  If the data is, in fact, in memory we\n-\t\t     must always load using the size assumed to be in the\n-\t\t     register and let the insn do the different-sized\n-\t\t     accesses.\n-\n-\t\t     This is doubly true if WORD_REGISTER_OPERATIONS.  In\n-\t\t     this case eliminate_regs has left non-paradoxical\n-\t\t     subregs for push_reload to see.  Make sure it does\n-\t\t     by forcing the reload.\n-\n-\t\t     ??? When is it right at this stage to have a subreg\n-\t\t     of a mem that is _not_ to be handled specially?  IMO\n-\t\t     those should have been reduced to just a mem.  */\n-\t\t  || ((MEM_P (operand)\n-\t\t       || (REG_P (operand)\n-\t\t\t   && REGNO (operand) >= FIRST_PSEUDO_REGISTER))\n+\t\t\t\t\t\t GET_MODE (operand)) < 0)\n+\t\t\tforce_reload = 1;\n+\t\t      offset += subreg_regno_offset (REGNO (SUBREG_REG (operand)),\n+\t\t\t\t\t\t     GET_MODE (SUBREG_REG (operand)),\n+\t\t\t\t\t\t     SUBREG_BYTE (operand),\n+\t\t\t\t\t\t     GET_MODE (operand));\n+\t\t    }\n+\t\t  operand = SUBREG_REG (operand);\n+\t\t  /* Force reload if this is a constant or PLUS or if there may\n+\t\t     be a problem accessing OPERAND in the outer mode.  */\n+\t\t  if (CONSTANT_P (operand)\n+\t\t      || GET_CODE (operand) == PLUS\n+\t\t      /* We must force a reload of paradoxical SUBREGs\n+\t\t\t of a MEM because the alignment of the inner value\n+\t\t\t may not be enough to do the outer reference.  On\n+\t\t\t big-endian machines, it may also reference outside\n+\t\t\t the object.\n+\n+\t\t\t On machines that extend byte operations and we have a\n+\t\t\t SUBREG where both the inner and outer modes are no wider\n+\t\t\t than a word and the inner mode is narrower, is integral,\n+\t\t\t and gets extended when loaded from memory, combine.c has\n+\t\t\t made assumptions about the behavior of the machine in such\n+\t\t\t register access.  If the data is, in fact, in memory we\n+\t\t\t must always load using the size assumed to be in the\n+\t\t\t register and let the insn do the different-sized\n+\t\t\t accesses.\n+\n+\t\t\t This is doubly true if WORD_REGISTER_OPERATIONS.  In\n+\t\t\t this case eliminate_regs has left non-paradoxical\n+\t\t\t subregs for push_reload to see.  Make sure it does\n+\t\t\t by forcing the reload.\n+\n+\t\t\t ??? When is it right at this stage to have a subreg\n+\t\t\t of a mem that is _not_ to be handled specially?  IMO\n+\t\t\t those should have been reduced to just a mem.  */\n+\t\t      || ((MEM_P (operand)\n+\t\t\t   || (REG_P (operand)\n+\t\t\t       && REGNO (operand) >= FIRST_PSEUDO_REGISTER))\n #ifndef WORD_REGISTER_OPERATIONS\n-\t\t      && (((GET_MODE_BITSIZE (GET_MODE (operand))\n-\t\t\t    < BIGGEST_ALIGNMENT)\n-\t\t\t   && (GET_MODE_SIZE (operand_mode[i])\n-\t\t\t       > GET_MODE_SIZE (GET_MODE (operand))))\n-\t\t\t  || BYTES_BIG_ENDIAN\n+\t\t\t  && (((GET_MODE_BITSIZE (GET_MODE (operand))\n+\t\t\t\t< BIGGEST_ALIGNMENT)\n+\t\t\t       && (GET_MODE_SIZE (operand_mode[i])\n+\t\t\t\t   > GET_MODE_SIZE (GET_MODE (operand))))\n+\t\t\t      || BYTES_BIG_ENDIAN\n #ifdef LOAD_EXTEND_OP\n-\t\t\t  || (GET_MODE_SIZE (operand_mode[i]) <= UNITS_PER_WORD\n-\t\t\t      && (GET_MODE_SIZE (GET_MODE (operand))\n-\t\t\t\t  <= UNITS_PER_WORD)\n-\t\t\t      && (GET_MODE_SIZE (operand_mode[i])\n-\t\t\t\t  > GET_MODE_SIZE (GET_MODE (operand)))\n-\t\t\t      && INTEGRAL_MODE_P (GET_MODE (operand))\n-\t\t\t      && LOAD_EXTEND_OP (GET_MODE (operand)) != UNKNOWN)\n+\t\t\t      || (GET_MODE_SIZE (operand_mode[i]) <= UNITS_PER_WORD\n+\t\t\t\t  && (GET_MODE_SIZE (GET_MODE (operand))\n+\t\t\t\t      <= UNITS_PER_WORD)\n+\t\t\t\t  && (GET_MODE_SIZE (operand_mode[i])\n+\t\t\t\t      > GET_MODE_SIZE (GET_MODE (operand)))\n+\t\t\t\t  && INTEGRAL_MODE_P (GET_MODE (operand))\n+\t\t\t\t  && LOAD_EXTEND_OP (GET_MODE (operand)) != UNKNOWN)\n #endif\n-\t\t\t  )\n+\t\t\t      )\n #endif\n+\t\t\t  )\n \t\t      )\n-\t\t  )\n-\t\tforce_reload = 1;\n-\t    }\n+\t\t    force_reload = 1;\n+\t\t}\n \n-\t  this_alternative[i] = NO_REGS;\n-\t  this_alternative_win[i] = 0;\n-\t  this_alternative_match_win[i] = 0;\n-\t  this_alternative_offmemok[i] = 0;\n-\t  this_alternative_earlyclobber[i] = 0;\n-\t  this_alternative_matches[i] = -1;\n-\n-\t  /* An empty constraint or empty alternative\n-\t     allows anything which matched the pattern.  */\n-\t  if (*p == 0 || *p == ',')\n-\t    win = 1, badop = 0;\n-\n-\t  /* Scan this alternative's specs for this operand;\n-\t     set WIN if the operand fits any letter in this alternative.\n-\t     Otherwise, clear BADOP if this operand could\n-\t     fit some letter after reloads,\n-\t     or set WINREG if this operand could fit after reloads\n-\t     provided the constraint allows some registers.  */\n-\n-\t  do\n-\t    switch ((c = *p, len = CONSTRAINT_LEN (c, p)), c)\n-\t      {\n-\t      case '\\0':\n-\t\tlen = 0;\n-\t\tbreak;\n-\t      case ',':\n-\t\tc = '\\0';\n-\t\tbreak;\n+\t      this_alternative[i] = NO_REGS;\n+\t      this_alternative_win[i] = 0;\n+\t      this_alternative_match_win[i] = 0;\n+\t      this_alternative_offmemok[i] = 0;\n+\t      this_alternative_earlyclobber[i] = 0;\n+\t      this_alternative_matches[i] = -1;\n+\n+\t      /* An empty constraint or empty alternative\n+\t\t allows anything which matched the pattern.  */\n+\t      if (*p == 0 || *p == ',')\n+\t\twin = 1, badop = 0;\n+\n+\t      /* Scan this alternative's specs for this operand;\n+\t\t set WIN if the operand fits any letter in this alternative.\n+\t\t Otherwise, clear BADOP if this operand could\n+\t\t fit some letter after reloads,\n+\t\t or set WINREG if this operand could fit after reloads\n+\t\t provided the constraint allows some registers.  */\n+\n+\t      do\n+\t\tswitch ((c = *p, len = CONSTRAINT_LEN (c, p)), c)\n+\t\t  {\n+\t\t  case '\\0':\n+\t\t    len = 0;\n+\t\t    break;\n+\t\t  case ',':\n+\t\t    c = '\\0';\n+\t\t    break;\n \n-\t      case '=':  case '+':  case '*':\n-\t\tbreak;\n+\t\t  case '=':  case '+':  case '*':\n+\t\t    break;\n \n-\t      case '%':\n-\t\t/* We only support one commutative marker, the first\n-\t\t   one.  We already set commutative above.  */\n-\t\tbreak;\n+\t\t  case '%':\n+\t\t    /* We only support one commutative marker, the first\n+\t\t       one.  We already set commutative above.  */\n+\t\t    break;\n \n-\t      case '?':\n-\t\treject += 6;\n-\t\tbreak;\n+\t\t  case '?':\n+\t\t    reject += 6;\n+\t\t    break;\n \n-\t      case '!':\n-\t\treject = 600;\n-\t\tbreak;\n+\t\t  case '!':\n+\t\t    reject = 600;\n+\t\t    break;\n \n-\t      case '#':\n-\t\t/* Ignore rest of this alternative as far as\n-\t\t   reloading is concerned.  */\n-\t\tdo\n-\t\t  p++;\n-\t\twhile (*p && *p != ',');\n-\t\tlen = 0;\n-\t\tbreak;\n+\t\t  case '#':\n+\t\t    /* Ignore rest of this alternative as far as\n+\t\t       reloading is concerned.  */\n+\t\t    do\n+\t\t      p++;\n+\t\t    while (*p && *p != ',');\n+\t\t    len = 0;\n+\t\t    break;\n \n-\t      case '0':  case '1':  case '2':  case '3':  case '4':\n-\t      case '5':  case '6':  case '7':  case '8':  case '9':\n-\t\tm = strtoul (p, &end, 10);\n-\t\tp = end;\n-\t\tlen = 0;\n-\n-\t\tthis_alternative_matches[i] = m;\n-\t\t/* We are supposed to match a previous operand.\n-\t\t   If we do, we win if that one did.\n-\t\t   If we do not, count both of the operands as losers.\n-\t\t   (This is too conservative, since most of the time\n-\t\t   only a single reload insn will be needed to make\n-\t\t   the two operands win.  As a result, this alternative\n-\t\t   may be rejected when it is actually desirable.)  */\n-\t\tif ((swapped && (m != commutative || i != commutative + 1))\n-\t\t    /* If we are matching as if two operands were swapped,\n-\t\t       also pretend that operands_match had been computed\n-\t\t       with swapped.\n-\t\t       But if I is the second of those and C is the first,\n-\t\t       don't exchange them, because operands_match is valid\n-\t\t       only on one side of its diagonal.  */\n-\t\t    ? (operands_match\n-\t\t       [(m == commutative || m == commutative + 1)\n-\t\t       ? 2 * commutative + 1 - m : m]\n-\t\t       [(i == commutative || i == commutative + 1)\n-\t\t       ? 2 * commutative + 1 - i : i])\n-\t\t    : operands_match[m][i])\n-\t\t  {\n-\t\t    /* If we are matching a non-offsettable address where an\n-\t\t       offsettable address was expected, then we must reject\n-\t\t       this combination, because we can't reload it.  */\n-\t\t    if (this_alternative_offmemok[m]\n-\t\t\t&& MEM_P (recog_data.operand[m])\n-\t\t\t&& this_alternative[m] == NO_REGS\n-\t\t\t&& ! this_alternative_win[m])\n-\t\t      bad = 1;\n-\n-\t\t    did_match = this_alternative_win[m];\n-\t\t  }\n-\t\telse\n-\t\t  {\n-\t\t    /* Operands don't match.  */\n-\t\t    rtx value;\n-\t\t    int loc1, loc2;\n-\t\t    /* Retroactively mark the operand we had to match\n-\t\t       as a loser, if it wasn't already.  */\n-\t\t    if (this_alternative_win[m])\n-\t\t      losers++;\n-\t\t    this_alternative_win[m] = 0;\n-\t\t    if (this_alternative[m] == NO_REGS)\n-\t\t      bad = 1;\n-\t\t    /* But count the pair only once in the total badness of\n-\t\t       this alternative, if the pair can be a dummy reload.\n-\t\t       The pointers in operand_loc are not swapped; swap\n-\t\t       them by hand if necessary.  */\n-\t\t    if (swapped && i == commutative)\n-\t\t      loc1 = commutative + 1;\n-\t\t    else if (swapped && i == commutative + 1)\n-\t\t      loc1 = commutative;\n-\t\t    else\n-\t\t      loc1 = i;\n-\t\t    if (swapped && m == commutative)\n-\t\t      loc2 = commutative + 1;\n-\t\t    else if (swapped && m == commutative + 1)\n-\t\t      loc2 = commutative;\n+\t\t  case '0':  case '1':  case '2':  case '3':  case '4':\n+\t\t  case '5':  case '6':  case '7':  case '8':  case '9':\n+\t\t    m = strtoul (p, &end, 10);\n+\t\t    p = end;\n+\t\t    len = 0;\n+\n+\t\t    this_alternative_matches[i] = m;\n+\t\t    /* We are supposed to match a previous operand.\n+\t\t       If we do, we win if that one did.\n+\t\t       If we do not, count both of the operands as losers.\n+\t\t       (This is too conservative, since most of the time\n+\t\t       only a single reload insn will be needed to make\n+\t\t       the two operands win.  As a result, this alternative\n+\t\t       may be rejected when it is actually desirable.)  */\n+\t\t    if ((swapped && (m != commutative || i != commutative + 1))\n+\t\t\t/* If we are matching as if two operands were swapped,\n+\t\t\t   also pretend that operands_match had been computed\n+\t\t\t   with swapped.\n+\t\t\t   But if I is the second of those and C is the first,\n+\t\t\t   don't exchange them, because operands_match is valid\n+\t\t\t   only on one side of its diagonal.  */\n+\t\t\t? (operands_match\n+\t\t\t   [(m == commutative || m == commutative + 1)\n+\t\t\t    ? 2 * commutative + 1 - m : m]\n+\t\t\t   [(i == commutative || i == commutative + 1)\n+\t\t\t    ? 2 * commutative + 1 - i : i])\n+\t\t\t: operands_match[m][i])\n+\t\t      {\n+\t\t\t/* If we are matching a non-offsettable address where an\n+\t\t\t   offsettable address was expected, then we must reject\n+\t\t\t   this combination, because we can't reload it.  */\n+\t\t\tif (this_alternative_offmemok[m]\n+\t\t\t    && MEM_P (recog_data.operand[m])\n+\t\t\t    && this_alternative[m] == NO_REGS\n+\t\t\t    && ! this_alternative_win[m])\n+\t\t\t  bad = 1;\n+\n+\t\t\tdid_match = this_alternative_win[m];\n+\t\t      }\n \t\t    else\n-\t\t      loc2 = m;\n-\t\t    value\n-\t\t      = find_dummy_reload (recog_data.operand[i],\n-\t\t\t\t\t   recog_data.operand[m],\n-\t\t\t\t\t   recog_data.operand_loc[loc1],\n-\t\t\t\t\t   recog_data.operand_loc[loc2],\n-\t\t\t\t\t   operand_mode[i], operand_mode[m],\n-\t\t\t\t\t   this_alternative[m], -1,\n-\t\t\t\t\t   this_alternative_earlyclobber[m]);\n-\n-\t\t    if (value != 0)\n-\t\t      losers--;\n-\t\t  }\n-\t\t/* This can be fixed with reloads if the operand\n-\t\t   we are supposed to match can be fixed with reloads.  */\n-\t\tbadop = 0;\n-\t\tthis_alternative[i] = this_alternative[m];\n-\n-\t\t/* If we have to reload this operand and some previous\n-\t\t   operand also had to match the same thing as this\n-\t\t   operand, we don't know how to do that.  So reject this\n-\t\t   alternative.  */\n-\t\tif (! did_match || force_reload)\n-\t\t  for (j = 0; j < i; j++)\n-\t\t    if (this_alternative_matches[j]\n-\t\t\t== this_alternative_matches[i])\n-\t\t      badop = 1;\n-\t\tbreak;\n+\t\t      {\n+\t\t\t/* Operands don't match.  */\n+\t\t\trtx value;\n+\t\t\tint loc1, loc2;\n+\t\t\t/* Retroactively mark the operand we had to match\n+\t\t\t   as a loser, if it wasn't already.  */\n+\t\t\tif (this_alternative_win[m])\n+\t\t\t  losers++;\n+\t\t\tthis_alternative_win[m] = 0;\n+\t\t\tif (this_alternative[m] == NO_REGS)\n+\t\t\t  bad = 1;\n+\t\t\t/* But count the pair only once in the total badness of\n+\t\t\t   this alternative, if the pair can be a dummy reload.\n+\t\t\t   The pointers in operand_loc are not swapped; swap\n+\t\t\t   them by hand if necessary.  */\n+\t\t\tif (swapped && i == commutative)\n+\t\t\t  loc1 = commutative + 1;\n+\t\t\telse if (swapped && i == commutative + 1)\n+\t\t\t  loc1 = commutative;\n+\t\t\telse\n+\t\t\t  loc1 = i;\n+\t\t\tif (swapped && m == commutative)\n+\t\t\t  loc2 = commutative + 1;\n+\t\t\telse if (swapped && m == commutative + 1)\n+\t\t\t  loc2 = commutative;\n+\t\t\telse\n+\t\t\t  loc2 = m;\n+\t\t\tvalue\n+\t\t\t  = find_dummy_reload (recog_data.operand[i],\n+\t\t\t\t\t       recog_data.operand[m],\n+\t\t\t\t\t       recog_data.operand_loc[loc1],\n+\t\t\t\t\t       recog_data.operand_loc[loc2],\n+\t\t\t\t\t       operand_mode[i], operand_mode[m],\n+\t\t\t\t\t       this_alternative[m], -1,\n+\t\t\t\t\t       this_alternative_earlyclobber[m]);\n+\n+\t\t\tif (value != 0)\n+\t\t\t  losers--;\n+\t\t      }\n+\t\t    /* This can be fixed with reloads if the operand\n+\t\t       we are supposed to match can be fixed with reloads.  */\n+\t\t    badop = 0;\n+\t\t    this_alternative[i] = this_alternative[m];\n+\n+\t\t    /* If we have to reload this operand and some previous\n+\t\t       operand also had to match the same thing as this\n+\t\t       operand, we don't know how to do that.  So reject this\n+\t\t       alternative.  */\n+\t\t    if (! did_match || force_reload)\n+\t\t      for (j = 0; j < i; j++)\n+\t\t\tif (this_alternative_matches[j]\n+\t\t\t    == this_alternative_matches[i])\n+\t\t\t  badop = 1;\n+\t\t    break;\n \n-\t      case 'p':\n-\t\t/* All necessary reloads for an address_operand\n-\t\t   were handled in find_reloads_address.  */\n-\t\tthis_alternative[i]\n-\t\t  = base_reg_class (VOIDmode, ADDR_SPACE_GENERIC,\n-\t\t\t\t    ADDRESS, SCRATCH);\n-\t\twin = 1;\n-\t\tbadop = 0;\n-\t\tbreak;\n+\t\t  case 'p':\n+\t\t    /* All necessary reloads for an address_operand\n+\t\t       were handled in find_reloads_address.  */\n+\t\t    this_alternative[i]\n+\t\t      = base_reg_class (VOIDmode, ADDR_SPACE_GENERIC,\n+\t\t\t\t\tADDRESS, SCRATCH);\n+\t\t    win = 1;\n+\t\t    badop = 0;\n+\t\t    break;\n \n-\t      case TARGET_MEM_CONSTRAINT:\n-\t\tif (force_reload)\n-\t\t  break;\n-\t\tif (MEM_P (operand)\n-\t\t    || (REG_P (operand)\n-\t\t\t&& REGNO (operand) >= FIRST_PSEUDO_REGISTER\n-\t\t\t&& reg_renumber[REGNO (operand)] < 0))\n-\t\t  win = 1;\n-\t\tif (CONST_POOL_OK_P (operand_mode[i], operand))\n-\t\t  badop = 0;\n-\t\tconstmemok = 1;\n-\t\tbreak;\n+\t\t  case TARGET_MEM_CONSTRAINT:\n+\t\t    if (force_reload)\n+\t\t      break;\n+\t\t    if (MEM_P (operand)\n+\t\t\t|| (REG_P (operand)\n+\t\t\t    && REGNO (operand) >= FIRST_PSEUDO_REGISTER\n+\t\t\t    && reg_renumber[REGNO (operand)] < 0))\n+\t\t      win = 1;\n+\t\t    if (CONST_POOL_OK_P (operand_mode[i], operand))\n+\t\t      badop = 0;\n+\t\t    constmemok = 1;\n+\t\t    break;\n \n-\t      case '<':\n-\t\tif (MEM_P (operand)\n-\t\t    && ! address_reloaded[i]\n-\t\t    && (GET_CODE (XEXP (operand, 0)) == PRE_DEC\n-\t\t\t|| GET_CODE (XEXP (operand, 0)) == POST_DEC))\n-\t\t  win = 1;\n-\t\tbreak;\n+\t\t  case '<':\n+\t\t    if (MEM_P (operand)\n+\t\t\t&& ! address_reloaded[i]\n+\t\t\t&& (GET_CODE (XEXP (operand, 0)) == PRE_DEC\n+\t\t\t    || GET_CODE (XEXP (operand, 0)) == POST_DEC))\n+\t\t      win = 1;\n+\t\t    break;\n \n-\t      case '>':\n-\t\tif (MEM_P (operand)\n-\t\t    && ! address_reloaded[i]\n-\t\t    && (GET_CODE (XEXP (operand, 0)) == PRE_INC\n-\t\t\t|| GET_CODE (XEXP (operand, 0)) == POST_INC))\n-\t\t  win = 1;\n-\t\tbreak;\n+\t\t  case '>':\n+\t\t    if (MEM_P (operand)\n+\t\t\t&& ! address_reloaded[i]\n+\t\t\t&& (GET_CODE (XEXP (operand, 0)) == PRE_INC\n+\t\t\t    || GET_CODE (XEXP (operand, 0)) == POST_INC))\n+\t\t      win = 1;\n+\t\t    break;\n \n-\t\t/* Memory operand whose address is not offsettable.  */\n-\t      case 'V':\n-\t\tif (force_reload)\n-\t\t  break;\n-\t\tif (MEM_P (operand)\n-\t\t    && ! (ind_levels ? offsettable_memref_p (operand)\n-\t\t\t  : offsettable_nonstrict_memref_p (operand))\n-\t\t    /* Certain mem addresses will become offsettable\n-\t\t       after they themselves are reloaded.  This is important;\n-\t\t       we don't want our own handling of unoffsettables\n-\t\t       to override the handling of reg_equiv_address.  */\n-\t\t    && !(REG_P (XEXP (operand, 0))\n-\t\t\t && (ind_levels == 0\n-\t\t\t     || reg_equiv_address (REGNO (XEXP (operand, 0))) != 0)))\n-\t\t  win = 1;\n-\t\tbreak;\n+\t\t    /* Memory operand whose address is not offsettable.  */\n+\t\t  case 'V':\n+\t\t    if (force_reload)\n+\t\t      break;\n+\t\t    if (MEM_P (operand)\n+\t\t\t&& ! (ind_levels ? offsettable_memref_p (operand)\n+\t\t\t      : offsettable_nonstrict_memref_p (operand))\n+\t\t\t/* Certain mem addresses will become offsettable\n+\t\t\t   after they themselves are reloaded.  This is important;\n+\t\t\t   we don't want our own handling of unoffsettables\n+\t\t\t   to override the handling of reg_equiv_address.  */\n+\t\t\t&& !(REG_P (XEXP (operand, 0))\n+\t\t\t     && (ind_levels == 0\n+\t\t\t\t || reg_equiv_address (REGNO (XEXP (operand, 0))) != 0)))\n+\t\t      win = 1;\n+\t\t    break;\n \n-\t\t/* Memory operand whose address is offsettable.  */\n-\t      case 'o':\n-\t\tif (force_reload)\n-\t\t  break;\n-\t\tif ((MEM_P (operand)\n-\t\t     /* If IND_LEVELS, find_reloads_address won't reload a\n-\t\t\tpseudo that didn't get a hard reg, so we have to\n-\t\t\treject that case.  */\n-\t\t     && ((ind_levels ? offsettable_memref_p (operand)\n-\t\t\t  : offsettable_nonstrict_memref_p (operand))\n-\t\t\t /* A reloaded address is offsettable because it is now\n-\t\t\t    just a simple register indirect.  */\n-\t\t\t || address_reloaded[i] == 1))\n-\t\t    || (REG_P (operand)\n-\t\t\t&& REGNO (operand) >= FIRST_PSEUDO_REGISTER\n-\t\t\t&& reg_renumber[REGNO (operand)] < 0\n-\t\t\t/* If reg_equiv_address is nonzero, we will be\n-\t\t\t   loading it into a register; hence it will be\n-\t\t\t   offsettable, but we cannot say that reg_equiv_mem\n-\t\t\t   is offsettable without checking.  */\n-\t\t\t&& ((reg_equiv_mem (REGNO (operand)) != 0\n-\t\t\t     && offsettable_memref_p (reg_equiv_mem (REGNO (operand))))\n-\t\t\t    || (reg_equiv_address (REGNO (operand)) != 0))))\n-\t\t  win = 1;\n-\t\tif (CONST_POOL_OK_P (operand_mode[i], operand)\n-\t\t    || MEM_P (operand))\n-\t\t  badop = 0;\n-\t\tconstmemok = 1;\n-\t\toffmemok = 1;\n-\t\tbreak;\n+\t\t    /* Memory operand whose address is offsettable.  */\n+\t\t  case 'o':\n+\t\t    if (force_reload)\n+\t\t      break;\n+\t\t    if ((MEM_P (operand)\n+\t\t\t /* If IND_LEVELS, find_reloads_address won't reload a\n+\t\t\t    pseudo that didn't get a hard reg, so we have to\n+\t\t\t    reject that case.  */\n+\t\t\t && ((ind_levels ? offsettable_memref_p (operand)\n+\t\t\t      : offsettable_nonstrict_memref_p (operand))\n+\t\t\t     /* A reloaded address is offsettable because it is now\n+\t\t\t\tjust a simple register indirect.  */\n+\t\t\t     || address_reloaded[i] == 1))\n+\t\t\t|| (REG_P (operand)\n+\t\t\t    && REGNO (operand) >= FIRST_PSEUDO_REGISTER\n+\t\t\t    && reg_renumber[REGNO (operand)] < 0\n+\t\t\t    /* If reg_equiv_address is nonzero, we will be\n+\t\t\t       loading it into a register; hence it will be\n+\t\t\t       offsettable, but we cannot say that reg_equiv_mem\n+\t\t\t       is offsettable without checking.  */\n+\t\t\t    && ((reg_equiv_mem (REGNO (operand)) != 0\n+\t\t\t\t && offsettable_memref_p (reg_equiv_mem (REGNO (operand))))\n+\t\t\t\t|| (reg_equiv_address (REGNO (operand)) != 0))))\n+\t\t      win = 1;\n+\t\t    if (CONST_POOL_OK_P (operand_mode[i], operand)\n+\t\t\t|| MEM_P (operand))\n+\t\t      badop = 0;\n+\t\t    constmemok = 1;\n+\t\t    offmemok = 1;\n+\t\t    break;\n \n-\t      case '&':\n-\t\t/* Output operand that is stored before the need for the\n-\t\t   input operands (and their index registers) is over.  */\n-\t\tearlyclobber = 1, this_earlyclobber = 1;\n-\t\tbreak;\n+\t\t  case '&':\n+\t\t    /* Output operand that is stored before the need for the\n+\t\t       input operands (and their index registers) is over.  */\n+\t\t    earlyclobber = 1, this_earlyclobber = 1;\n+\t\t    break;\n \n-\t      case 'E':\n-\t      case 'F':\n-\t\tif (GET_CODE (operand) == CONST_DOUBLE\n-\t\t    || (GET_CODE (operand) == CONST_VECTOR\n-\t\t\t&& (GET_MODE_CLASS (GET_MODE (operand))\n-\t\t\t    == MODE_VECTOR_FLOAT)))\n-\t\t  win = 1;\n-\t\tbreak;\n+\t\t  case 'E':\n+\t\t  case 'F':\n+\t\t    if (GET_CODE (operand) == CONST_DOUBLE\n+\t\t\t|| (GET_CODE (operand) == CONST_VECTOR\n+\t\t\t    && (GET_MODE_CLASS (GET_MODE (operand))\n+\t\t\t\t== MODE_VECTOR_FLOAT)))\n+\t\t      win = 1;\n+\t\t    break;\n \n-\t      case 'G':\n-\t      case 'H':\n-\t\tif (GET_CODE (operand) == CONST_DOUBLE\n-\t\t    && CONST_DOUBLE_OK_FOR_CONSTRAINT_P (operand, c, p))\n-\t\t  win = 1;\n-\t\tbreak;\n+\t\t  case 'G':\n+\t\t  case 'H':\n+\t\t    if (GET_CODE (operand) == CONST_DOUBLE\n+\t\t\t&& CONST_DOUBLE_OK_FOR_CONSTRAINT_P (operand, c, p))\n+\t\t      win = 1;\n+\t\t    break;\n \n-\t      case 's':\n-\t\tif (CONST_INT_P (operand)\n-\t\t    || (GET_CODE (operand) == CONST_DOUBLE\n-\t\t\t&& GET_MODE (operand) == VOIDmode))\n-\t\t  break;\n-\t      case 'i':\n-\t\tif (CONSTANT_P (operand)\n-\t\t    && (! flag_pic || LEGITIMATE_PIC_OPERAND_P (operand)))\n-\t\t  win = 1;\n-\t\tbreak;\n+\t\t  case 's':\n+\t\t    if (CONST_INT_P (operand)\n+\t\t\t|| (GET_CODE (operand) == CONST_DOUBLE\n+\t\t\t    && GET_MODE (operand) == VOIDmode))\n+\t\t      break;\n+\t\t  case 'i':\n+\t\t    if (CONSTANT_P (operand)\n+\t\t\t&& (! flag_pic || LEGITIMATE_PIC_OPERAND_P (operand)))\n+\t\t      win = 1;\n+\t\t    break;\n \n-\t      case 'n':\n-\t\tif (CONST_INT_P (operand)\n-\t\t    || (GET_CODE (operand) == CONST_DOUBLE\n-\t\t\t&& GET_MODE (operand) == VOIDmode))\n-\t\t  win = 1;\n-\t\tbreak;\n+\t\t  case 'n':\n+\t\t    if (CONST_INT_P (operand)\n+\t\t\t|| (GET_CODE (operand) == CONST_DOUBLE\n+\t\t\t    && GET_MODE (operand) == VOIDmode))\n+\t\t      win = 1;\n+\t\t    break;\n \n-\t      case 'I':\n-\t      case 'J':\n-\t      case 'K':\n-\t      case 'L':\n-\t      case 'M':\n-\t      case 'N':\n-\t      case 'O':\n-\t      case 'P':\n-\t\tif (CONST_INT_P (operand)\n-\t\t    && CONST_OK_FOR_CONSTRAINT_P (INTVAL (operand), c, p))\n-\t\t  win = 1;\n-\t\tbreak;\n+\t\t  case 'I':\n+\t\t  case 'J':\n+\t\t  case 'K':\n+\t\t  case 'L':\n+\t\t  case 'M':\n+\t\t  case 'N':\n+\t\t  case 'O':\n+\t\t  case 'P':\n+\t\t    if (CONST_INT_P (operand)\n+\t\t\t&& CONST_OK_FOR_CONSTRAINT_P (INTVAL (operand), c, p))\n+\t\t      win = 1;\n+\t\t    break;\n \n-\t      case 'X':\n-\t\tforce_reload = 0;\n-\t\twin = 1;\n-\t\tbreak;\n+\t\t  case 'X':\n+\t\t    force_reload = 0;\n+\t\t    win = 1;\n+\t\t    break;\n \n-\t      case 'g':\n-\t\tif (! force_reload\n-\t\t    /* A PLUS is never a valid operand, but reload can make\n-\t\t       it from a register when eliminating registers.  */\n-\t\t    && GET_CODE (operand) != PLUS\n-\t\t    /* A SCRATCH is not a valid operand.  */\n-\t\t    && GET_CODE (operand) != SCRATCH\n-\t\t    && (! CONSTANT_P (operand)\n-\t\t\t|| ! flag_pic\n-\t\t\t|| LEGITIMATE_PIC_OPERAND_P (operand))\n-\t\t    && (GENERAL_REGS == ALL_REGS\n-\t\t\t|| !REG_P (operand)\n-\t\t\t|| (REGNO (operand) >= FIRST_PSEUDO_REGISTER\n-\t\t\t    && reg_renumber[REGNO (operand)] < 0)))\n-\t\t  win = 1;\n-\t\t/* Drop through into 'r' case.  */\n-\n-\t      case 'r':\n-\t\tthis_alternative[i]\n-\t\t  = reg_class_subunion[this_alternative[i]][(int) GENERAL_REGS];\n-\t\tgoto reg;\n+\t\t  case 'g':\n+\t\t    if (! force_reload\n+\t\t\t/* A PLUS is never a valid operand, but reload can make\n+\t\t\t   it from a register when eliminating registers.  */\n+\t\t\t&& GET_CODE (operand) != PLUS\n+\t\t\t/* A SCRATCH is not a valid operand.  */\n+\t\t\t&& GET_CODE (operand) != SCRATCH\n+\t\t\t&& (! CONSTANT_P (operand)\n+\t\t\t    || ! flag_pic\n+\t\t\t    || LEGITIMATE_PIC_OPERAND_P (operand))\n+\t\t\t&& (GENERAL_REGS == ALL_REGS\n+\t\t\t    || !REG_P (operand)\n+\t\t\t    || (REGNO (operand) >= FIRST_PSEUDO_REGISTER\n+\t\t\t\t&& reg_renumber[REGNO (operand)] < 0)))\n+\t\t      win = 1;\n+\t\t    /* Drop through into 'r' case.  */\n \n-\t      default:\n-\t\tif (REG_CLASS_FROM_CONSTRAINT (c, p) == NO_REGS)\n-\t\t  {\n-#ifdef EXTRA_CONSTRAINT_STR\n-\t\t    if (EXTRA_MEMORY_CONSTRAINT (c, p))\n-\t\t      {\n-\t\t\tif (force_reload)\n-\t\t\t  break;\n-\t\t        if (EXTRA_CONSTRAINT_STR (operand, c, p))\n-\t\t          win = 1;\n-\t\t\t/* If the address was already reloaded,\n-\t\t\t   we win as well.  */\n-\t\t\telse if (MEM_P (operand)\n-\t\t\t\t && address_reloaded[i] == 1)\n-\t\t\t  win = 1;\n-\t\t\t/* Likewise if the address will be reloaded because\n-\t\t\t   reg_equiv_address is nonzero.  For reg_equiv_mem\n-\t\t\t   we have to check.  */\n-\t\t        else if (REG_P (operand)\n-\t\t\t\t && REGNO (operand) >= FIRST_PSEUDO_REGISTER\n-\t\t\t\t && reg_renumber[REGNO (operand)] < 0\n-\t\t\t\t && ((reg_equiv_mem (REGNO (operand)) != 0\n-\t\t\t\t      && EXTRA_CONSTRAINT_STR (reg_equiv_mem (REGNO (operand)), c, p))\n-\t\t\t\t     || (reg_equiv_address (REGNO (operand)) != 0)))\n-\t\t\t  win = 1;\n+\t\t  case 'r':\n+\t\t    this_alternative[i]\n+\t\t      = reg_class_subunion[this_alternative[i]][(int) GENERAL_REGS];\n+\t\t    goto reg;\n \n-\t\t\t/* If we didn't already win, we can reload\n-\t\t\t   constants via force_const_mem, and other\n-\t\t\t   MEMs by reloading the address like for 'o'.  */\n-\t\t\tif (CONST_POOL_OK_P (operand_mode[i], operand)\n-\t\t\t    || MEM_P (operand))\n-\t\t\t  badop = 0;\n-\t\t\tconstmemok = 1;\n-\t\t\toffmemok = 1;\n-\t\t\tbreak;\n-\t\t      }\n-\t\t    if (EXTRA_ADDRESS_CONSTRAINT (c, p))\n+\t\t  default:\n+\t\t    if (REG_CLASS_FROM_CONSTRAINT (c, p) == NO_REGS)\n \t\t      {\n-\t\t        if (EXTRA_CONSTRAINT_STR (operand, c, p))\n-\t\t          win = 1;\n-\n-\t\t\t/* If we didn't already win, we can reload\n-\t\t\t   the address into a base register.  */\n-\t\t\tthis_alternative[i]\n-\t\t\t  = base_reg_class (VOIDmode, ADDR_SPACE_GENERIC,\n-\t\t\t\t\t    ADDRESS, SCRATCH);\n-\t\t\tbadop = 0;\n+#ifdef EXTRA_CONSTRAINT_STR\n+\t\t\tif (EXTRA_MEMORY_CONSTRAINT (c, p))\n+\t\t\t  {\n+\t\t\t    if (force_reload)\n+\t\t\t      break;\n+\t\t\t    if (EXTRA_CONSTRAINT_STR (operand, c, p))\n+\t\t\t      win = 1;\n+\t\t\t    /* If the address was already reloaded,\n+\t\t\t       we win as well.  */\n+\t\t\t    else if (MEM_P (operand)\n+\t\t\t\t     && address_reloaded[i] == 1)\n+\t\t\t      win = 1;\n+\t\t\t    /* Likewise if the address will be reloaded because\n+\t\t\t       reg_equiv_address is nonzero.  For reg_equiv_mem\n+\t\t\t       we have to check.  */\n+\t\t\t    else if (REG_P (operand)\n+\t\t\t\t     && REGNO (operand) >= FIRST_PSEUDO_REGISTER\n+\t\t\t\t     && reg_renumber[REGNO (operand)] < 0\n+\t\t\t\t     && ((reg_equiv_mem (REGNO (operand)) != 0\n+\t\t\t\t\t  && EXTRA_CONSTRAINT_STR (reg_equiv_mem (REGNO (operand)), c, p))\n+\t\t\t\t\t || (reg_equiv_address (REGNO (operand)) != 0)))\n+\t\t\t      win = 1;\n+\n+\t\t\t    /* If we didn't already win, we can reload\n+\t\t\t       constants via force_const_mem, and other\n+\t\t\t       MEMs by reloading the address like for 'o'.  */\n+\t\t\t    if (CONST_POOL_OK_P (operand_mode[i], operand)\n+\t\t\t\t|| MEM_P (operand))\n+\t\t\t      badop = 0;\n+\t\t\t    constmemok = 1;\n+\t\t\t    offmemok = 1;\n+\t\t\t    break;\n+\t\t\t  }\n+\t\t\tif (EXTRA_ADDRESS_CONSTRAINT (c, p))\n+\t\t\t  {\n+\t\t\t    if (EXTRA_CONSTRAINT_STR (operand, c, p))\n+\t\t\t      win = 1;\n+\n+\t\t\t    /* If we didn't already win, we can reload\n+\t\t\t       the address into a base register.  */\n+\t\t\t    this_alternative[i]\n+\t\t\t      = base_reg_class (VOIDmode, ADDR_SPACE_GENERIC,\n+\t\t\t\t\t\tADDRESS, SCRATCH);\n+\t\t\t    badop = 0;\n+\t\t\t    break;\n+\t\t\t  }\n+\n+\t\t\tif (EXTRA_CONSTRAINT_STR (operand, c, p))\n+\t\t\t  win = 1;\n+#endif\n \t\t\tbreak;\n \t\t      }\n \n-\t\t    if (EXTRA_CONSTRAINT_STR (operand, c, p))\n+\t\t    this_alternative[i]\n+\t\t      = (reg_class_subunion\n+\t\t\t [this_alternative[i]]\n+\t\t\t [(int) REG_CLASS_FROM_CONSTRAINT (c, p)]);\n+\t\t  reg:\n+\t\t    if (GET_MODE (operand) == BLKmode)\n+\t\t      break;\n+\t\t    winreg = 1;\n+\t\t    if (REG_P (operand)\n+\t\t\t&& reg_fits_class_p (operand, this_alternative[i],\n+  \t\t\t             offset, GET_MODE (recog_data.operand[i])))\n \t\t      win = 1;\n-#endif\n \t\t    break;\n \t\t  }\n+\t      while ((p += len), c);\n \n-\t\tthis_alternative[i]\n-\t\t  = (reg_class_subunion\n-\t\t     [this_alternative[i]]\n-\t\t     [(int) REG_CLASS_FROM_CONSTRAINT (c, p)]);\n-\t      reg:\n-\t\tif (GET_MODE (operand) == BLKmode)\n-\t\t  break;\n-\t\twinreg = 1;\n-\t\tif (REG_P (operand)\n-\t\t    && reg_fits_class_p (operand, this_alternative[i],\n-\t\t\t\t\t offset, GET_MODE (recog_data.operand[i])))\n-\t\t  win = 1;\n-\t\tbreak;\n-\t      }\n-\t  while ((p += len), c);\n-\n-\t  constraints[i] = p;\n-\n-\t  /* If this operand could be handled with a reg,\n-\t     and some reg is allowed, then this operand can be handled.  */\n-\t  if (winreg && this_alternative[i] != NO_REGS\n-\t      && (win || !class_only_fixed_regs[this_alternative[i]]))\n-\t    badop = 0;\n-\n-\t  /* Record which operands fit this alternative.  */\n-\t  this_alternative_earlyclobber[i] = earlyclobber;\n-\t  if (win && ! force_reload)\n-\t    this_alternative_win[i] = 1;\n-\t  else if (did_match && ! force_reload)\n-\t    this_alternative_match_win[i] = 1;\n-\t  else\n-\t    {\n-\t      int const_to_mem = 0;\n-\n-\t      this_alternative_offmemok[i] = offmemok;\n-\t      losers++;\n-\t      if (badop)\n-\t\tbad = 1;\n-\t      /* Alternative loses if it has no regs for a reg operand.  */\n-\t      if (REG_P (operand)\n-\t\t  && this_alternative[i] == NO_REGS\n-\t\t  && this_alternative_matches[i] < 0)\n-\t\tbad = 1;\n-\n-\t      /* If this is a constant that is reloaded into the desired\n-\t\t class by copying it to memory first, count that as another\n-\t\t reload.  This is consistent with other code and is\n-\t\t required to avoid choosing another alternative when\n-\t\t the constant is moved into memory by this function on\n-\t\t an early reload pass.  Note that the test here is\n-\t\t precisely the same as in the code below that calls\n-\t\t force_const_mem.  */\n-\t      if (CONST_POOL_OK_P (operand_mode[i], operand)\n-\t\t  && ((targetm.preferred_reload_class (operand,\n-\t\t\t\t\t\t       this_alternative[i])\n-\t\t       == NO_REGS)\n-\t\t      || no_input_reloads))\n-\t\t{\n-\t\t  const_to_mem = 1;\n-\t\t  if (this_alternative[i] != NO_REGS)\n-\t\t    losers++;\n-\t\t}\n+\t      if (swapped == (commutative >= 0 ? 1 : 0))\n+\t\tconstraints[i] = p;\n \n-\t      /* Alternative loses if it requires a type of reload not\n-\t\t permitted for this insn.  We can always reload SCRATCH\n-\t\t and objects with a REG_UNUSED note.  */\n-\t      if (GET_CODE (operand) != SCRATCH\n-\t\t       && modified[i] != RELOAD_READ && no_output_reloads\n-\t\t       && ! find_reg_note (insn, REG_UNUSED, operand))\n-\t\tbad = 1;\n-\t      else if (modified[i] != RELOAD_WRITE && no_input_reloads\n-\t\t       && ! const_to_mem)\n-\t\tbad = 1;\n-\n-\t      /* If we can't reload this value at all, reject this\n-\t\t alternative.  Note that we could also lose due to\n-\t\t LIMIT_RELOAD_CLASS, but we don't check that\n-\t\t here.  */\n-\n-\t      if (! CONSTANT_P (operand) && this_alternative[i] != NO_REGS)\n+\t      /* If this operand could be handled with a reg,\n+\t\t and some reg is allowed, then this operand can be handled.  */\n+\t      if (winreg && this_alternative[i] != NO_REGS\n+\t\t  && (win || !class_only_fixed_regs[this_alternative[i]]))\n+\t\tbadop = 0;\n+\n+\t      /* Record which operands fit this alternative.  */\n+\t      this_alternative_earlyclobber[i] = earlyclobber;\n+\t      if (win && ! force_reload)\n+\t\tthis_alternative_win[i] = 1;\n+\t      else if (did_match && ! force_reload)\n+\t\tthis_alternative_match_win[i] = 1;\n+\t      else\n \t\t{\n-\t\t  if (targetm.preferred_reload_class (operand, this_alternative[i])\n-\t\t      == NO_REGS)\n-\t\t    reject = 600;\n+\t\t  int const_to_mem = 0;\n+\n+\t\t  this_alternative_offmemok[i] = offmemok;\n+\t\t  losers++;\n+\t\t  if (badop)\n+\t\t    bad = 1;\n+\t\t  /* Alternative loses if it has no regs for a reg operand.  */\n+\t\t  if (REG_P (operand)\n+\t\t      && this_alternative[i] == NO_REGS\n+\t\t      && this_alternative_matches[i] < 0)\n+\t\t    bad = 1;\n+\n+\t\t  /* If this is a constant that is reloaded into the desired\n+\t\t     class by copying it to memory first, count that as another\n+\t\t     reload.  This is consistent with other code and is\n+\t\t     required to avoid choosing another alternative when\n+\t\t     the constant is moved into memory by this function on\n+\t\t     an early reload pass.  Note that the test here is\n+\t\t     precisely the same as in the code below that calls\n+\t\t     force_const_mem.  */\n+\t\t  if (CONST_POOL_OK_P (operand_mode[i], operand)\n+\t\t      && ((targetm.preferred_reload_class (operand,\n+\t\t\t\t\t\t\t   this_alternative[i])\n+\t\t\t   == NO_REGS)\n+\t\t\t  || no_input_reloads))\n+\t\t    {\n+\t\t      const_to_mem = 1;\n+\t\t      if (this_alternative[i] != NO_REGS)\n+\t\t\tlosers++;\n+\t\t    }\n \n-\t\t  if (operand_type[i] == RELOAD_FOR_OUTPUT\n-\t\t      && (targetm.preferred_output_reload_class (operand,\n-\t\t\t\t\t\t\t\t this_alternative[i])\n-\t\t\t  == NO_REGS))\n-\t\t    reject = 600;\n-\t\t}\n+\t\t  /* Alternative loses if it requires a type of reload not\n+\t\t     permitted for this insn.  We can always reload SCRATCH\n+\t\t     and objects with a REG_UNUSED note.  */\n+\t\t  if (GET_CODE (operand) != SCRATCH\n+\t\t      && modified[i] != RELOAD_READ && no_output_reloads\n+\t\t      && ! find_reg_note (insn, REG_UNUSED, operand))\n+\t\t    bad = 1;\n+\t\t  else if (modified[i] != RELOAD_WRITE && no_input_reloads\n+\t\t\t   && ! const_to_mem)\n+\t\t    bad = 1;\n+\n+\t\t  /* If we can't reload this value at all, reject this\n+\t\t     alternative.  Note that we could also lose due to\n+\t\t     LIMIT_RELOAD_CLASS, but we don't check that\n+\t\t     here.  */\n+\n+\t\t  if (! CONSTANT_P (operand) && this_alternative[i] != NO_REGS)\n+\t\t    {\n+\t\t      if (targetm.preferred_reload_class (operand,\n+\t\t\t\t\t\t\t  this_alternative[i])\n+\t\t\t  == NO_REGS)\n+\t\t\treject = 600;\n+\n+\t\t      if (operand_type[i] == RELOAD_FOR_OUTPUT\n+\t\t\t  && (targetm.preferred_output_reload_class (operand,\n+\t\t\t\t\t\t\t    this_alternative[i])\n+\t\t\t      == NO_REGS))\n+\t\t\treject = 600;\n+\t\t    }\n \n-\t      /* We prefer to reload pseudos over reloading other things,\n-\t\t since such reloads may be able to be eliminated later.\n-\t\t If we are reloading a SCRATCH, we won't be generating any\n-\t\t insns, just using a register, so it is also preferred.\n-\t\t So bump REJECT in other cases.  Don't do this in the\n-\t\t case where we are forcing a constant into memory and\n-\t\t it will then win since we don't want to have a different\n-\t\t alternative match then.  */\n-\t      if (! (REG_P (operand)\n-\t\t     && REGNO (operand) >= FIRST_PSEUDO_REGISTER)\n-\t\t  && GET_CODE (operand) != SCRATCH\n-\t\t  && ! (const_to_mem && constmemok))\n-\t\treject += 2;\n-\n-\t      /* Input reloads can be inherited more often than output\n-\t\t reloads can be removed, so penalize output reloads.  */\n-\t      if (operand_type[i] != RELOAD_FOR_INPUT\n-\t\t  && GET_CODE (operand) != SCRATCH)\n-\t\treject++;\n-\t    }\n+\t\t  /* We prefer to reload pseudos over reloading other things,\n+\t\t     since such reloads may be able to be eliminated later.\n+\t\t     If we are reloading a SCRATCH, we won't be generating any\n+\t\t     insns, just using a register, so it is also preferred.\n+\t\t     So bump REJECT in other cases.  Don't do this in the\n+\t\t     case where we are forcing a constant into memory and\n+\t\t     it will then win since we don't want to have a different\n+\t\t     alternative match then.  */\n+\t\t  if (! (REG_P (operand)\n+\t\t\t && REGNO (operand) >= FIRST_PSEUDO_REGISTER)\n+\t\t      && GET_CODE (operand) != SCRATCH\n+\t\t      && ! (const_to_mem && constmemok))\n+\t\t    reject += 2;\n+\n+\t\t  /* Input reloads can be inherited more often than output\n+\t\t     reloads can be removed, so penalize output reloads.  */\n+\t\t  if (operand_type[i] != RELOAD_FOR_INPUT\n+\t\t      && GET_CODE (operand) != SCRATCH)\n+\t\t    reject++;\n+\t\t}\n \n-\t  /* If this operand is a pseudo register that didn't get a hard\n-\t     reg and this alternative accepts some register, see if the\n-\t     class that we want is a subset of the preferred class for this\n-\t     register.  If not, but it intersects that class, use the\n-\t     preferred class instead.  If it does not intersect the preferred\n-\t     class, show that usage of this alternative should be discouraged;\n-\t     it will be discouraged more still if the register is `preferred\n-\t     or nothing'.  We do this because it increases the chance of\n-\t     reusing our spill register in a later insn and avoiding a pair\n-\t     of memory stores and loads.\n-\n-\t     Don't bother with this if this alternative will accept this\n-\t     operand.\n-\n-\t     Don't do this for a multiword operand, since it is only a\n-\t     small win and has the risk of requiring more spill registers,\n-\t     which could cause a large loss.\n-\n-\t     Don't do this if the preferred class has only one register\n-\t     because we might otherwise exhaust the class.  */\n-\n-\t  if (! win && ! did_match\n-\t      && this_alternative[i] != NO_REGS\n-\t      && GET_MODE_SIZE (operand_mode[i]) <= UNITS_PER_WORD\n-\t      && reg_class_size [(int) preferred_class[i]] > 0\n-\t      && ! small_register_class_p (preferred_class[i]))\n-\t    {\n-\t      if (! reg_class_subset_p (this_alternative[i],\n-\t\t\t\t\tpreferred_class[i]))\n+\t      /* If this operand is a pseudo register that didn't get\n+\t\t a hard reg and this alternative accepts some\n+\t\t register, see if the class that we want is a subset\n+\t\t of the preferred class for this register.  If not,\n+\t\t but it intersects that class, use the preferred class\n+\t\t instead.  If it does not intersect the preferred\n+\t\t class, show that usage of this alternative should be\n+\t\t discouraged; it will be discouraged more still if the\n+\t\t register is `preferred or nothing'.  We do this\n+\t\t because it increases the chance of reusing our spill\n+\t\t register in a later insn and avoiding a pair of\n+\t\t memory stores and loads.\n+\n+\t\t Don't bother with this if this alternative will\n+\t\t accept this operand.\n+\n+\t\t Don't do this for a multiword operand, since it is\n+\t\t only a small win and has the risk of requiring more\n+\t\t spill registers, which could cause a large loss.\n+\n+\t\t Don't do this if the preferred class has only one\n+\t\t register because we might otherwise exhaust the\n+\t\t class.  */\n+\n+\t      if (! win && ! did_match\n+\t\t  && this_alternative[i] != NO_REGS\n+\t\t  && GET_MODE_SIZE (operand_mode[i]) <= UNITS_PER_WORD\n+\t\t  && reg_class_size [(int) preferred_class[i]] > 0\n+\t\t  && ! small_register_class_p (preferred_class[i]))\n \t\t{\n-\t\t  /* Since we don't have a way of forming the intersection,\n-\t\t     we just do something special if the preferred class\n-\t\t     is a subset of the class we have; that's the most\n-\t\t     common case anyway.  */\n-\t\t  if (reg_class_subset_p (preferred_class[i],\n-\t\t\t\t\t  this_alternative[i]))\n-\t\t    this_alternative[i] = preferred_class[i];\n-\t\t  else\n-\t\t    reject += (2 + 2 * pref_or_nothing[i]);\n+\t\t  if (! reg_class_subset_p (this_alternative[i],\n+\t\t\t\t\t    preferred_class[i]))\n+\t\t    {\n+\t\t      /* Since we don't have a way of forming the intersection,\n+\t\t\t we just do something special if the preferred class\n+\t\t\t is a subset of the class we have; that's the most\n+\t\t\t common case anyway.  */\n+\t\t      if (reg_class_subset_p (preferred_class[i],\n+\t\t\t\t\t      this_alternative[i]))\n+\t\t\tthis_alternative[i] = preferred_class[i];\n+\t\t      else\n+\t\t\treject += (2 + 2 * pref_or_nothing[i]);\n+\t\t    }\n \t\t}\n \t    }\n-\t}\n \n-      /* Now see if any output operands that are marked \"earlyclobber\"\n-\t in this alternative conflict with any input operands\n-\t or any memory addresses.  */\n+\t  /* Now see if any output operands that are marked \"earlyclobber\"\n+\t     in this alternative conflict with any input operands\n+\t     or any memory addresses.  */\n \n-      for (i = 0; i < noperands; i++)\n-\tif (this_alternative_earlyclobber[i]\n-\t    && (this_alternative_win[i] || this_alternative_match_win[i]))\n-\t  {\n-\t    struct decomposition early_data;\n+\t  for (i = 0; i < noperands; i++)\n+\t    if (this_alternative_earlyclobber[i]\n+\t\t&& (this_alternative_win[i] || this_alternative_match_win[i]))\n+\t      {\n+\t\tstruct decomposition early_data;\n \n-\t    early_data = decompose (recog_data.operand[i]);\n+\t\tearly_data = decompose (recog_data.operand[i]);\n \n-\t    gcc_assert (modified[i] != RELOAD_READ);\n+\t\tgcc_assert (modified[i] != RELOAD_READ);\n \n-\t    if (this_alternative[i] == NO_REGS)\n-\t      {\n-\t\tthis_alternative_earlyclobber[i] = 0;\n-\t\tgcc_assert (this_insn_is_asm);\n-\t\terror_for_asm (this_insn,\n-\t\t\t       \"%<&%> constraint used with no register class\");\n-\t      }\n+\t\tif (this_alternative[i] == NO_REGS)\n+\t\t  {\n+\t\t    this_alternative_earlyclobber[i] = 0;\n+\t\t    gcc_assert (this_insn_is_asm);\n+\t\t    error_for_asm (this_insn,\n+\t\t\t      \"%<&%> constraint used with no register class\");\n+\t\t  }\n \n-\t    for (j = 0; j < noperands; j++)\n-\t      /* Is this an input operand or a memory ref?  */\n-\t      if ((MEM_P (recog_data.operand[j])\n-\t\t   || modified[j] != RELOAD_WRITE)\n-\t\t  && j != i\n-\t\t  /* Ignore things like match_operator operands.  */\n-\t\t  && !recog_data.is_operator[j]\n-\t\t  /* Don't count an input operand that is constrained to match\n-\t\t     the early clobber operand.  */\n-\t\t  && ! (this_alternative_matches[j] == i\n-\t\t\t&& rtx_equal_p (recog_data.operand[i],\n-\t\t\t\t\trecog_data.operand[j]))\n-\t\t  /* Is it altered by storing the earlyclobber operand?  */\n-\t\t  && !immune_p (recog_data.operand[j], recog_data.operand[i],\n-\t\t\t\tearly_data))\n-\t\t{\n-\t\t  /* If the output is in a non-empty few-regs class,\n-\t\t     it's costly to reload it, so reload the input instead.  */\n-\t\t  if (small_register_class_p (this_alternative[i])\n-\t\t      && (REG_P (recog_data.operand[j])\n-\t\t\t  || GET_CODE (recog_data.operand[j]) == SUBREG))\n-\t\t    {\n-\t\t      losers++;\n-\t\t      this_alternative_win[j] = 0;\n-\t\t      this_alternative_match_win[j] = 0;\n-\t\t    }\n-\t\t  else\n-\t\t    break;\n-\t\t}\n-\t    /* If an earlyclobber operand conflicts with something,\n-\t       it must be reloaded, so request this and count the cost.  */\n-\t    if (j != noperands)\n-\t      {\n-\t\tlosers++;\n-\t\tthis_alternative_win[i] = 0;\n-\t\tthis_alternative_match_win[j] = 0;\n \t\tfor (j = 0; j < noperands; j++)\n-\t\t  if (this_alternative_matches[j] == i\n-\t\t      && this_alternative_match_win[j])\n+\t\t  /* Is this an input operand or a memory ref?  */\n+\t\t  if ((MEM_P (recog_data.operand[j])\n+\t\t       || modified[j] != RELOAD_WRITE)\n+\t\t      && j != i\n+\t\t      /* Ignore things like match_operator operands.  */\n+\t\t      && !recog_data.is_operator[j]\n+\t\t      /* Don't count an input operand that is constrained to match\n+\t\t\t the early clobber operand.  */\n+\t\t      && ! (this_alternative_matches[j] == i\n+\t\t\t    && rtx_equal_p (recog_data.operand[i],\n+\t\t\t\t\t    recog_data.operand[j]))\n+\t\t      /* Is it altered by storing the earlyclobber operand?  */\n+\t\t      && !immune_p (recog_data.operand[j], recog_data.operand[i],\n+\t\t\t\t    early_data))\n \t\t    {\n-\t\t      this_alternative_win[j] = 0;\n-\t\t      this_alternative_match_win[j] = 0;\n-\t\t      losers++;\n+\t\t      /* If the output is in a non-empty few-regs class,\n+\t\t\t it's costly to reload it, so reload the input instead.  */\n+\t\t      if (small_register_class_p (this_alternative[i])\n+\t\t\t  && (REG_P (recog_data.operand[j])\n+\t\t\t      || GET_CODE (recog_data.operand[j]) == SUBREG))\n+\t\t\t{\n+\t\t\t  losers++;\n+\t\t\t  this_alternative_win[j] = 0;\n+\t\t\t  this_alternative_match_win[j] = 0;\n+\t\t\t}\n+\t\t      else\n+\t\t\tbreak;\n \t\t    }\n+\t\t/* If an earlyclobber operand conflicts with something,\n+\t\t   it must be reloaded, so request this and count the cost.  */\n+\t\tif (j != noperands)\n+\t\t  {\n+\t\t    losers++;\n+\t\t    this_alternative_win[i] = 0;\n+\t\t    this_alternative_match_win[j] = 0;\n+\t\t    for (j = 0; j < noperands; j++)\n+\t\t      if (this_alternative_matches[j] == i\n+\t\t\t  && this_alternative_match_win[j])\n+\t\t\t{\n+\t\t\t  this_alternative_win[j] = 0;\n+\t\t\t  this_alternative_match_win[j] = 0;\n+\t\t\t  losers++;\n+\t\t\t}\n+\t\t  }\n \t      }\n-\t  }\n-\n-      /* If one alternative accepts all the operands, no reload required,\n-\t choose that alternative; don't consider the remaining ones.  */\n-      if (losers == 0)\n-\t{\n-\t  /* Unswap these so that they are never swapped at `finish'.  */\n-\t  if (commutative >= 0)\n-\t    {\n-\t      recog_data.operand[commutative] = substed_operand[commutative];\n-\t      recog_data.operand[commutative + 1]\n-\t\t= substed_operand[commutative + 1];\n-\t    }\n-\t  for (i = 0; i < noperands; i++)\n-\t    {\n-\t      goal_alternative_win[i] = this_alternative_win[i];\n-\t      goal_alternative_match_win[i] = this_alternative_match_win[i];\n-\t      goal_alternative[i] = this_alternative[i];\n-\t      goal_alternative_offmemok[i] = this_alternative_offmemok[i];\n-\t      goal_alternative_matches[i] = this_alternative_matches[i];\n-\t      goal_alternative_earlyclobber[i]\n-\t\t= this_alternative_earlyclobber[i];\n-\t    }\n-\t  goal_alternative_number = this_alternative_number;\n-\t  goal_alternative_swapped = swapped;\n-\t  goal_earlyclobber = this_earlyclobber;\n-\t  goto finish;\n-\t}\n-\n-      /* REJECT, set by the ! and ? constraint characters and when a register\n-\t would be reloaded into a non-preferred class, discourages the use of\n-\t this alternative for a reload goal.  REJECT is incremented by six\n-\t for each ? and two for each non-preferred class.  */\n-      losers = losers * 6 + reject;\n \n-      /* If this alternative can be made to work by reloading,\n-\t and it needs less reloading than the others checked so far,\n-\t record it as the chosen goal for reloading.  */\n-      if (! bad)\n-\t{\n-\t  if (best > losers)\n+\t  /* If one alternative accepts all the operands, no reload required,\n+\t     choose that alternative; don't consider the remaining ones.  */\n+\t  if (losers == 0)\n \t    {\n+\t      /* Unswap these so that they are never swapped at `finish'.  */\n+\t      if (swapped)\n+\t\t{\n+\t\t  recog_data.operand[commutative] = substed_operand[commutative];\n+\t\t  recog_data.operand[commutative + 1]\n+\t\t    = substed_operand[commutative + 1];\n+\t\t}\n \t      for (i = 0; i < noperands; i++)\n \t\t{\n-\t\t  goal_alternative[i] = this_alternative[i];\n \t\t  goal_alternative_win[i] = this_alternative_win[i];\n-\t\t  goal_alternative_match_win[i]\n-\t\t    = this_alternative_match_win[i];\n-\t\t  goal_alternative_offmemok[i]\n-\t\t    = this_alternative_offmemok[i];\n+\t\t  goal_alternative_match_win[i] = this_alternative_match_win[i];\n+\t\t  goal_alternative[i] = this_alternative[i];\n+\t\t  goal_alternative_offmemok[i] = this_alternative_offmemok[i];\n \t\t  goal_alternative_matches[i] = this_alternative_matches[i];\n \t\t  goal_alternative_earlyclobber[i]\n \t\t    = this_alternative_earlyclobber[i];\n \t\t}\n-\t      goal_alternative_swapped = swapped;\n-\t      best = losers;\n \t      goal_alternative_number = this_alternative_number;\n+\t      goal_alternative_swapped = swapped;\n \t      goal_earlyclobber = this_earlyclobber;\n+\t      goto finish;\n \t    }\n-\t}\n-    }\n \n-  /* If insn is commutative (it's safe to exchange a certain pair of operands)\n-     then we need to try each alternative twice,\n-     the second time matching those two operands\n-     as if we had exchanged them.\n-     To do this, really exchange them in operands.\n+\t  /* REJECT, set by the ! and ? constraint characters and when a register\n+\t     would be reloaded into a non-preferred class, discourages the use of\n+\t     this alternative for a reload goal.  REJECT is incremented by six\n+\t     for each ? and two for each non-preferred class.  */\n+\t  losers = losers * 6 + reject;\n+\n+\t  /* If this alternative can be made to work by reloading,\n+\t     and it needs less reloading than the others checked so far,\n+\t     record it as the chosen goal for reloading.  */\n+\t  if (! bad)\n+\t    {\n+\t      if (best > losers)\n+\t\t{\n+\t\t  for (i = 0; i < noperands; i++)\n+\t\t    {\n+\t\t      goal_alternative[i] = this_alternative[i];\n+\t\t      goal_alternative_win[i] = this_alternative_win[i];\n+\t\t      goal_alternative_match_win[i]\n+\t\t\t= this_alternative_match_win[i];\n+\t\t      goal_alternative_offmemok[i]\n+\t\t\t= this_alternative_offmemok[i];\n+\t\t      goal_alternative_matches[i] = this_alternative_matches[i];\n+\t\t      goal_alternative_earlyclobber[i]\n+\t\t\t= this_alternative_earlyclobber[i];\n+\t\t    }\n+\t\t  goal_alternative_swapped = swapped;\n+\t\t  best = losers;\n+\t\t  goal_alternative_number = this_alternative_number;\n+\t\t  goal_earlyclobber = this_earlyclobber;\n+\t\t}\n+\t    }\n \n-     If we have just tried the alternatives the second time,\n-     return operands to normal and drop through.  */\n+\t  if (swapped)\n+\t    {\n+\t      enum reg_class tclass;\n+\t      int t;\n \n-  if (commutative >= 0)\n-    {\n-      swapped = !swapped;\n-      if (swapped)\n-\t{\n-\t  enum reg_class tclass;\n-\t  int t;\n-\n-\t  recog_data.operand[commutative] = substed_operand[commutative + 1];\n-\t  recog_data.operand[commutative + 1] = substed_operand[commutative];\n-\t  /* Swap the duplicates too.  */\n-\t  for (i = 0; i < recog_data.n_dups; i++)\n-\t    if (recog_data.dup_num[i] == commutative\n-\t\t|| recog_data.dup_num[i] == commutative + 1)\n-\t      *recog_data.dup_loc[i]\n-\t\t = recog_data.operand[(int) recog_data.dup_num[i]];\n-\n-\t  tclass = preferred_class[commutative];\n-\t  preferred_class[commutative] = preferred_class[commutative + 1];\n-\t  preferred_class[commutative + 1] = tclass;\n-\n-\t  t = pref_or_nothing[commutative];\n-\t  pref_or_nothing[commutative] = pref_or_nothing[commutative + 1];\n-\t  pref_or_nothing[commutative + 1] = t;\n-\n-\t  t = address_reloaded[commutative];\n-\t  address_reloaded[commutative] = address_reloaded[commutative + 1];\n-\t  address_reloaded[commutative + 1] = t;\n-\n-\t  memcpy (constraints, recog_data.constraints,\n-\t\t  noperands * sizeof (const char *));\n-\t  goto try_swapped;\n-\t}\n-      else\n-\t{\n-\t  recog_data.operand[commutative] = substed_operand[commutative];\n-\t  recog_data.operand[commutative + 1]\n-\t    = substed_operand[commutative + 1];\n-\t  /* Unswap the duplicates too.  */\n-\t  for (i = 0; i < recog_data.n_dups; i++)\n-\t    if (recog_data.dup_num[i] == commutative\n-\t\t|| recog_data.dup_num[i] == commutative + 1)\n-\t      *recog_data.dup_loc[i]\n-\t\t = recog_data.operand[(int) recog_data.dup_num[i]];\n+\t      /* If the commutative operands have been swapped, swap\n+\t\t them back in order to check the next alternative.  */\n+\t      recog_data.operand[commutative] = substed_operand[commutative];\n+\t      recog_data.operand[commutative + 1] = substed_operand[commutative + 1];\n+\t      /* Unswap the duplicates too.  */\n+\t      for (i = 0; i < recog_data.n_dups; i++)\n+\t\tif (recog_data.dup_num[i] == commutative\n+\t\t    || recog_data.dup_num[i] == commutative + 1)\n+\t\t  *recog_data.dup_loc[i]\n+\t\t    = recog_data.operand[(int) recog_data.dup_num[i]];\n+\n+\t      /* Unswap the operand related information as well.  */\n+\t      tclass = preferred_class[commutative];\n+\t      preferred_class[commutative] = preferred_class[commutative + 1];\n+\t      preferred_class[commutative + 1] = tclass;\n+\n+\t      t = pref_or_nothing[commutative];\n+\t      pref_or_nothing[commutative] = pref_or_nothing[commutative + 1];\n+\t      pref_or_nothing[commutative + 1] = t;\n+\n+\t      t = address_reloaded[commutative];\n+\t      address_reloaded[commutative] = address_reloaded[commutative + 1];\n+\t      address_reloaded[commutative + 1] = t;\n+\t    }\n \t}\n     }\n "}]}