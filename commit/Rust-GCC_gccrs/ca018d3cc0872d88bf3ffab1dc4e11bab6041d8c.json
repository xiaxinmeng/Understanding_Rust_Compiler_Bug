{"sha": "ca018d3cc0872d88bf3ffab1dc4e11bab6041d8c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2EwMThkM2NjMDg3MmQ4OGJmM2ZmYWIxZGM0ZTExYmFiNjA0MWQ4Yw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2015-07-16T13:47:48Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2015-07-16T13:47:48Z"}, "message": "genoutput.c (data): Use a file_location to record the source position.\n\ngcc/\n\t* genoutput.c (data): Use a file_location to record the source\n\tposition.\n\t(nothing): Delete.\n\t(idata, idata_end): Remove initialization.\n\t(constraint_data): Replace lineno with a file_location.\n\t(output_insn_data): Update after changes to data.\n\t(gen_insn, gen_peephole, gen_expand, gen_split): Likewise.\n\t(scan_operands): Likewise, using *_at rather than *_with_line\n\tfunctions.\n\t(process_template): Likewise.\n\t(validate_insn_alternatives): Likewise.\n\t(validate_insn_operands): Likewise.\n\t(validate_optab_operands): Likewise.\n\t(init_insn_for_nothing): Initialize idata and idata_end.\n\t(note_constraint): Update after changes to constraint_data,\n\tusing at rather than with_line functions.\n\t(mdep_constraint_len): Take a file_location rather than a\n\tline number.  Use at rather than with_line functions.\n\nFrom-SVN: r225881", "tree": {"sha": "ec73c85210d27d49c4d0db4b0c2864cf3a2466d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ec73c85210d27d49c4d0db4b0c2864cf3a2466d5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ca018d3cc0872d88bf3ffab1dc4e11bab6041d8c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca018d3cc0872d88bf3ffab1dc4e11bab6041d8c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca018d3cc0872d88bf3ffab1dc4e11bab6041d8c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca018d3cc0872d88bf3ffab1dc4e11bab6041d8c/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8f2463105bc389b72bb78526168a1173eed032ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f2463105bc389b72bb78526168a1173eed032ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f2463105bc389b72bb78526168a1173eed032ef"}], "stats": {"total": 147, "additions": 78, "deletions": 69}, "files": [{"sha": "4e6b3aea6f7ba70a724d264d9665171d297eb219", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca018d3cc0872d88bf3ffab1dc4e11bab6041d8c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca018d3cc0872d88bf3ffab1dc4e11bab6041d8c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ca018d3cc0872d88bf3ffab1dc4e11bab6041d8c", "patch": "@@ -1,3 +1,24 @@\n+2015-07-16  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* genoutput.c (data): Use a file_location to record the source\n+\tposition.\n+\t(nothing): Delete.\n+\t(idata, idata_end): Remove initialization.\n+\t(constraint_data): Replace lineno with a file_location.\n+\t(output_insn_data): Update after changes to data.\n+\t(gen_insn, gen_peephole, gen_expand, gen_split): Likewise.\n+\t(scan_operands): Likewise, using *_at rather than *_with_line\n+\tfunctions.\n+\t(process_template): Likewise.\n+\t(validate_insn_alternatives): Likewise.\n+\t(validate_insn_operands): Likewise.\n+\t(validate_optab_operands): Likewise.\n+\t(init_insn_for_nothing): Initialize idata and idata_end.\n+\t(note_constraint): Update after changes to constraint_data,\n+\tusing at rather than with_line functions.\n+\t(mdep_constraint_len): Take a file_location rather than a\n+\tline number.  Use at rather than with_line functions.\n+\n 2015-07-16  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* read-md.h (fatal_at): Declare."}, {"sha": "46ad6024d5f386ecacdf28f9426d0e3a8b0c6876", "filename": "gcc/genoutput.c", "status": "modified", "additions": 57, "deletions": 69, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca018d3cc0872d88bf3ffab1dc4e11bab6041d8c/gcc%2Fgenoutput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca018d3cc0872d88bf3ffab1dc4e11bab6041d8c/gcc%2Fgenoutput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenoutput.c?ref=ca018d3cc0872d88bf3ffab1dc4e11bab6041d8c", "patch": "@@ -154,9 +154,8 @@ struct data\n   struct data *next;\n   const char *name;\n   const char *template_code;\n+  file_location loc;\n   int code_number;\n-  const char *filename;\n-  int lineno;\n   int n_generator_args;\t\t/* Number of arguments passed to generator */\n   int n_operands;\t\t/* Number of operands this insn recognizes */\n   int n_dups;\t\t\t/* Number times match_dup appears in pattern */\n@@ -166,15 +165,12 @@ struct data\n   struct operand_data operand[MAX_MAX_OPERANDS];\n };\n \n-/* A dummy insn, for CODE_FOR_nothing.  */\n-static struct data nothing;\n-\n /* This variable points to the first link in the insn chain.  */\n-static struct data *idata = &nothing;\n+static struct data *idata;\n \n /* This variable points to the end of the insn chain.  This is where\n    everything relevant from the machien description is appended to.  */\n-static struct data **idata_end = &nothing.next;\n+static struct data **idata_end;\n \n \f\n static void output_prologue (void);\n@@ -196,9 +192,9 @@ static void gen_split (rtx, int);\n struct constraint_data\n {\n   struct constraint_data *next_this_letter;\n-  int lineno;\n+  file_location loc;\n   unsigned int namelen;\n-  const char name[1];\n+  char name[1];\n };\n \n /* All machine-independent constraint characters (except digits) that\n@@ -208,7 +204,7 @@ static const char indep_constraints[] = \",=+%*?!^$#&g\";\n static struct constraint_data *\n constraints_by_letter_table[1 << CHAR_BIT];\n \n-static int mdep_constraint_len (const char *, int, int);\n+static int mdep_constraint_len (const char *, file_location, int);\n static void note_constraint (rtx, int);\n \f\n static void\n@@ -306,7 +302,7 @@ output_insn_data (void)\n \n   for (d = idata; d; d = d->next)\n     {\n-      printf (\"  /* %s:%d */\\n\", d->filename, d->lineno);\n+      printf (\"  /* %s:%d */\\n\", d->loc.filename, d->loc.lineno);\n       printf (\"  {\\n\");\n \n       if (d->name)\n@@ -449,11 +445,11 @@ scan_operands (struct data *d, rtx part, int this_address_p,\n       opno = XINT (part, 0);\n       if (opno >= MAX_MAX_OPERANDS)\n \t{\n-\t  error_with_line (d->lineno, \"maximum number of operands exceeded\");\n+\t  error_at (d->loc, \"maximum number of operands exceeded\");\n \t  return;\n \t}\n       if (d->operand[opno].seen)\n-\terror_with_line (d->lineno, \"repeated operand number %d\\n\", opno);\n+\terror_at (d->loc, \"repeated operand number %d\\n\", opno);\n \n       d->operand[opno].seen = 1;\n       d->operand[opno].mode = GET_MODE (part);\n@@ -470,11 +466,11 @@ scan_operands (struct data *d, rtx part, int this_address_p,\n       opno = XINT (part, 0);\n       if (opno >= MAX_MAX_OPERANDS)\n \t{\n-\t  error_with_line (d->lineno, \"maximum number of operands exceeded\");\n+\t  error_at (d->loc, \"maximum number of operands exceeded\");\n \t  return;\n \t}\n       if (d->operand[opno].seen)\n-\terror_with_line (d->lineno, \"repeated operand number %d\\n\", opno);\n+\terror_at (d->loc, \"repeated operand number %d\\n\", opno);\n \n       d->operand[opno].seen = 1;\n       d->operand[opno].mode = GET_MODE (part);\n@@ -492,11 +488,11 @@ scan_operands (struct data *d, rtx part, int this_address_p,\n       opno = XINT (part, 0);\n       if (opno >= MAX_MAX_OPERANDS)\n \t{\n-\t  error_with_line (d->lineno, \"maximum number of operands exceeded\");\n+\t  error_at (d->loc, \"maximum number of operands exceeded\");\n \t  return;\n \t}\n       if (d->operand[opno].seen)\n-\terror_with_line (d->lineno, \"repeated operand number %d\\n\", opno);\n+\terror_at (d->loc, \"repeated operand number %d\\n\", opno);\n \n       d->operand[opno].seen = 1;\n       d->operand[opno].mode = GET_MODE (part);\n@@ -708,8 +704,7 @@ process_template (struct data *d, const char *template_code)\n \t      sp = ep + 1;\n \n \t  if (sp != ep)\n-\t    message_with_line (d->lineno,\n-\t\t\t       \"trailing whitespace in output template\");\n+\t    message_at (d->loc, \"trailing whitespace in output template\");\n \n \t  while (cp < sp)\n \t    {\n@@ -732,11 +727,11 @@ process_template (struct data *d, const char *template_code)\n \t  i++;\n \t}\n       if (i == 1)\n-\tmessage_with_line (d->lineno,\n-\t\t\t   \"'@' is redundant for output template with single alternative\");\n+\tmessage_at (d->loc, \"'@' is redundant for output template with\"\n+\t\t    \" single alternative\");\n       if (i != d->n_alternatives)\n-\terror_with_line (d->lineno,\n-\t\t\t \"wrong number of alternatives in the output template\");\n+\terror_at (d->loc, \"wrong number of alternatives in the output\"\n+\t\t  \" template\");\n \n       if (found_star)\n \tputs (\"      default: gcc_unreachable ();\\n    }\\n}\");\n@@ -773,20 +768,17 @@ validate_insn_alternatives (struct data *d)\n \t  {\n \t    if ((c == '%' || c == '=' || c == '+')\n \t\t&& p != d->operand[start].constraint)\n-\t      error_with_line (d->lineno,\n-\t\t\t       \"character '%c' can only be used at the\"\n-\t\t\t       \" beginning of a constraint string\", c);\n+\t      error_at (d->loc, \"character '%c' can only be used at the\"\n+\t\t\t\" beginning of a constraint string\", c);\n \n \t    if (c == '=' || c == '+')\n \t      seen_write = true;\n \n \t    /* Earlyclobber operands must always be marked write-only\n \t       or read/write.  */\n \t    if (!seen_write && c == '&')\n-\t      error_with_line (d->lineno,\n-\t\t\t       \"earlyclobber operands may not be\"\n-\t\t\t       \" read-only in alternative %d\",\n-\t\t\t       which_alternative);\n+\t      error_at (d->loc, \"earlyclobber operands may not be\"\n+\t\t\t\" read-only in alternative %d\", which_alternative);\n \n \t    if (ISSPACE (c) || strchr (indep_constraints, c))\n \t      len = 1;\n@@ -799,7 +791,7 @@ validate_insn_alternatives (struct data *d)\n \t\tlen = q - p;\n \t      }\n \t    else\n-\t      len = mdep_constraint_len (p, d->lineno, start);\n+\t      len = mdep_constraint_len (p, d->loc, start);\n \n \t    if (c == ',')\n \t      {\n@@ -810,17 +802,15 @@ validate_insn_alternatives (struct data *d)\n \t    for (i = 1; i < len; i++)\n \t      if (p[i] == '\\0')\n \t\t{\n-\t\t  error_with_line (d->lineno,\n-\t\t\t\t   \"NUL in alternative %d of operand %d\",\n-\t\t\t\t   which_alternative, start);\n+\t\t  error_at (d->loc, \"NUL in alternative %d of operand %d\",\n+\t\t\t    which_alternative, start);\n \t\t  alternative_count_unsure = 1;\n \t\t  break;\n \t\t}\n \t      else if (strchr (\",#*\", p[i]))\n \t\t{\n-\t\t  error_with_line (d->lineno,\n-\t\t\t\t   \"'%c' in alternative %d of operand %d\",\n-\t\t\t\t   p[i], which_alternative, start);\n+\t\t  error_at (d->loc, \"'%c' in alternative %d of operand %d\",\n+\t\t\t    p[i], which_alternative, start);\n \t\t  alternative_count_unsure = 1;\n \t\t}\n \t  }\n@@ -829,9 +819,8 @@ validate_insn_alternatives (struct data *d)\n \t    if (n == 0)\n \t      n = d->operand[start].n_alternatives;\n \t    else if (n != d->operand[start].n_alternatives)\n-\t      error_with_line (d->lineno,\n-\t\t\t       \"wrong number of alternatives in operand %d\",\n-\t\t\t       start);\n+\t      error_at (d->loc, \"wrong number of alternatives in operand %d\",\n+\t\t\tstart);\n \t  }\n       }\n \n@@ -848,7 +837,7 @@ validate_insn_operands (struct data *d)\n \n   for (i = 0; i < d->n_operands; ++i)\n     if (d->operand[i].seen == 0)\n-      error_with_line (d->lineno, \"missing operand %d\", i);\n+      error_at (d->loc, \"missing operand %d\", i);\n }\n \n static void\n@@ -862,7 +851,7 @@ validate_optab_operands (struct data *d)\n       && d->name[strlen (d->name) - 1] == '4'\n       && d->operand[0].mode == VOIDmode)\n     {\n-      message_with_line (d->lineno, \"missing mode for operand 0 of cstore\");\n+      message_at (d->loc, \"missing mode for operand 0 of cstore\");\n       have_error = 1;\n     }\n }\n@@ -875,12 +864,11 @@ static void\n gen_insn (rtx insn, int lineno)\n {\n   struct pattern_stats stats;\n-  struct data *d = XNEW (struct data);\n+  data *d = new data;\n   int i;\n \n   d->code_number = next_code_number;\n-  d->filename = read_md_filename;\n-  d->lineno = lineno;\n+  d->loc = file_location (read_md_filename, lineno);\n   if (XSTR (insn, 0)[0])\n     d->name = XSTR (insn, 0);\n   else\n@@ -917,12 +905,11 @@ static void\n gen_peephole (rtx peep, int lineno)\n {\n   struct pattern_stats stats;\n-  struct data *d = XNEW (struct data);\n+  data *d = new data;\n   int i;\n \n   d->code_number = next_code_number;\n-  d->filename = read_md_filename;\n-  d->lineno = lineno;\n+  d->loc = file_location (read_md_filename, lineno);\n   d->name = 0;\n \n   /* Build up the list in the same order as the insns are seen\n@@ -956,12 +943,11 @@ static void\n gen_expand (rtx insn, int lineno)\n {\n   struct pattern_stats stats;\n-  struct data *d = XNEW (struct data);\n+  data *d = new data;\n   int i;\n \n   d->code_number = next_code_number;\n-  d->filename = read_md_filename;\n-  d->lineno = lineno;\n+  d->loc = file_location (read_md_filename, lineno);\n   if (XSTR (insn, 0)[0])\n     d->name = XSTR (insn, 0);\n   else\n@@ -1001,12 +987,11 @@ static void\n gen_split (rtx split, int lineno)\n {\n   struct pattern_stats stats;\n-  struct data *d = XNEW (struct data);\n+  data *d = new data;\n   int i;\n \n   d->code_number = next_code_number;\n-  d->filename = read_md_filename;\n-  d->lineno = lineno;\n+  d->loc = file_location (read_md_filename, lineno);\n   d->name = 0;\n \n   /* Build up the list in the same order as the insns are seen\n@@ -1037,9 +1022,11 @@ gen_split (rtx split, int lineno)\n static void\n init_insn_for_nothing (void)\n {\n-  memset (&nothing, 0, sizeof (nothing));\n-  nothing.name = \"*placeholder_for_nothing\";\n-  nothing.filename = \"<internal>\";\n+  idata = XCNEW (struct data);\n+  new (idata) data ();\n+  idata->name = \"*placeholder_for_nothing\";\n+  idata->loc = file_location (\"<internal>\", 0);\n+  idata_end = &idata->next;\n }\n \n extern int main (int, char **);\n@@ -1189,28 +1176,30 @@ note_constraint (rtx exp, int lineno)\n       if (!strcmp ((*iter)->name, name))\n \t{\n \t  error_with_line (lineno, \"redefinition of constraint '%s'\", name);\n-\t  message_with_line ((*iter)->lineno, \"previous definition is here\");\n+\t  message_at ((*iter)->loc, \"previous definition is here\");\n \t  return;\n \t}\n       else if (!strncmp ((*iter)->name, name, (*iter)->namelen))\n \t{\n \t  error_with_line (lineno, \"defining constraint '%s' here\", name);\n-\t  message_with_line ((*iter)->lineno, \"renders constraint '%s' \"\n-\t\t\t     \"(defined here) a prefix\", (*iter)->name);\n+\t  message_at ((*iter)->loc, \"renders constraint '%s' \"\n+\t\t      \"(defined here) a prefix\", (*iter)->name);\n \t  return;\n \t}\n       else if (!strncmp ((*iter)->name, name, namelen))\n \t{\n \t  error_with_line (lineno, \"constraint '%s' is a prefix\", name);\n-\t  message_with_line ((*iter)->lineno, \"of constraint '%s' \"\n-\t\t\t     \"(defined here)\", (*iter)->name);\n+\t  message_at ((*iter)->loc, \"of constraint '%s' \"\n+\t\t      \"(defined here)\", (*iter)->name);\n \t  return;\n \t}\n     }\n-  new_cdata = XNEWVAR (struct constraint_data, sizeof (struct constraint_data) + namelen);\n+  new_cdata = XNEWVAR (struct constraint_data,\n+\t\t       sizeof (struct constraint_data) + namelen);\n+  new (new_cdata) constraint_data ();\n   strcpy (CONST_CAST (char *, new_cdata->name), name);\n   new_cdata->namelen = namelen;\n-  new_cdata->lineno = lineno;\n+  new_cdata->loc = file_location (read_md_filename, lineno);\n   new_cdata->next_this_letter = *slot;\n   *slot = new_cdata;\n }\n@@ -1220,7 +1209,7 @@ note_constraint (rtx exp, int lineno)\n    is no such constraint.  Does not expect to be called for generic\n    constraints.  */\n static int\n-mdep_constraint_len (const char *s, int lineno, int opno)\n+mdep_constraint_len (const char *s, file_location loc, int opno)\n {\n   struct constraint_data *p;\n \n@@ -1231,9 +1220,8 @@ mdep_constraint_len (const char *s, int lineno, int opno)\n       if (!strncmp (s, p->name, p->namelen))\n \treturn p->namelen;\n \n-  error_with_line (lineno,\n-\t\t   \"error: undefined machine-specific constraint \"\n-\t\t   \"at this point: \\\"%s\\\"\", s);\n-  message_with_line (lineno, \"note:  in operand %d\", opno);\n+  error_at (loc, \"error: undefined machine-specific constraint \"\n+\t    \"at this point: \\\"%s\\\"\", s);\n+  message_at (loc, \"note:  in operand %d\", opno);\n   return 1; /* safe */\n }"}]}