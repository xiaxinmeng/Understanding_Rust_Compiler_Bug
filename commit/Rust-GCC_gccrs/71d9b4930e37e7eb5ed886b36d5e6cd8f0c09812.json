{"sha": "71d9b4930e37e7eb5ed886b36d5e6cd8f0c09812", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzFkOWI0OTMwZTM3ZTdlYjVlZDg4NmIzNmQ1ZTZjZDhmMGMwOTgxMg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1997-12-23T05:34:27Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1997-12-23T05:34:27Z"}, "message": "genattrtab.c (expand_units): For large nr opclasses, expand function_units_used with ORX to prevent blowups.\n\n* genattrtab.c (expand_units): For large nr opclasses, expand\nfunction_units_used with ORX to prevent blowups.  Tag with FFS.\n(num_unit_opclasses): New variable.\n(gen_unit): Update it.\n(enum operator): Add ORX_OP.\n(operate_exp): Treat ORX as or, except don't expand across an if.\nReuse number rtx's after operating on them.\n(check_attr_value): Accept IOR, AND, & FFS.\n(write_test_expr): Transmute `in_comparison' to `flags'.  Allow\nfor attribute value caching.  Handle CONST_STRING, IF_THEN_ELSE.\n(write_expr_attr_cache, write_toplevel_expr): New functions.\n(write_attr_get): Handle FFS-tagged expressions.\n(make_canonical): Don't expand const attributes.\n(convert_const_symbol_ref): Dike out.\n(evaluate_eq_attr): Handle SYMBOL_REF.\n(main): Don't emit get_attr_foo for const attributes.\n* alpha.c (override_options): Reinstate PROCESSOR_EV6.\n(alpha_adjust_cost): Add EV6 tuning; streamline EV5 tests.\n* alpha.h (REGISTER_MOVE_COST): Increase ftoi/itof cost slightly.\n* alpha.md: Redo all of the scheduling, adding EV6 support, and\ncombining function units where possible.\n(attr \"type\"): Split loads, stores, cmov into int/fp.  Combine\nmultiplies and divides.  Add EV6 sqrt, ftoi, itof.\n(attr \"opsize\"): New attribute.\n(sqrtsf2-1, sqrtdf2-1): Provide proper TP_INSN patterns.\n(movsf2-[12], movdf2-[12]): Provide CIX varients; don't allow CIX\nto control register allocation.\n(movsi2-1, movdi2-1): Likewise.\n\nFrom-SVN: r17212", "tree": {"sha": "59b6544257938fc9d961b17b9f069e18ee794489", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/59b6544257938fc9d961b17b9f069e18ee794489"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/71d9b4930e37e7eb5ed886b36d5e6cd8f0c09812", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71d9b4930e37e7eb5ed886b36d5e6cd8f0c09812", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71d9b4930e37e7eb5ed886b36d5e6cd8f0c09812", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71d9b4930e37e7eb5ed886b36d5e6cd8f0c09812/comments", "author": null, "committer": null, "parents": [{"sha": "b0435cf4cfaac64f49fc2b118b002ea1d32eb004", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0435cf4cfaac64f49fc2b118b002ea1d32eb004", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0435cf4cfaac64f49fc2b118b002ea1d32eb004"}], "stats": {"total": 970, "additions": 703, "deletions": 267}, "files": [{"sha": "e456fe1ea727b5ff8f0014ced15d7ef250f4b4ea", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71d9b4930e37e7eb5ed886b36d5e6cd8f0c09812/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71d9b4930e37e7eb5ed886b36d5e6cd8f0c09812/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=71d9b4930e37e7eb5ed886b36d5e6cd8f0c09812", "patch": "@@ -1,3 +1,35 @@\n+Tue Dec 23 05:17:28 1997  Richard Henderson  <rth@cygnus.com>\n+\n+\t* genattrtab.c (expand_units): For large nr opclasses, expand\n+\tfunction_units_used with ORX to prevent blowups.  Tag with FFS.\n+\t(num_unit_opclasses): New variable.\n+\t(gen_unit): Update it.\n+\t(enum operator): Add ORX_OP.\n+\t(operate_exp): Treat ORX as or, except don't expand across an if.\n+\tReuse number rtx's after operating on them.\n+\t(check_attr_value): Accept IOR, AND, & FFS.\n+\t(write_test_expr): Transmute `in_comparison' to `flags'.  Allow\n+\tfor attribute value caching.  Handle CONST_STRING, IF_THEN_ELSE.\n+\t(write_expr_attr_cache, write_toplevel_expr): New functions.\n+\t(write_attr_get): Handle FFS-tagged expressions.\n+\t(make_canonical): Don't expand const attributes.\n+\t(convert_const_symbol_ref): Dike out.\n+\t(evaluate_eq_attr): Handle SYMBOL_REF.\n+\t(main): Don't emit get_attr_foo for const attributes.\n+\n+\t* alpha.c (override_options): Reinstate PROCESSOR_EV6.\n+\t(alpha_adjust_cost): Add EV6 tuning; streamline EV5 tests.\n+\t* alpha.h (REGISTER_MOVE_COST): Increase ftoi/itof cost slightly.\n+\t* alpha.md: Redo all of the scheduling, adding EV6 support, and \n+\tcombining function units where possible.  \n+\t(attr \"type\"): Split loads, stores, cmov into int/fp.  Combine\n+\tmultiplies and divides.  Add EV6 sqrt, ftoi, itof.\n+\t(attr \"opsize\"): New attribute.\n+\t(sqrtsf2-1, sqrtdf2-1): Provide proper TP_INSN patterns.\n+\t(movsf2-[12], movdf2-[12]): Provide CIX varients; don't allow CIX\n+\tto control register allocation.\n+\t(movsi2-1, movdi2-1): Likewise.\n+\n Tue Dec 23 03:53:21 1997  Richard Henderson  <rth@cygnus.com>\n \t\n \t* alpha.h (CPP_PREDEFINES, LIB_SPEC, LINK_SPEC, STARTFILE_SPEC,"}, {"sha": "e36629fad958fa3781923c47a45b6513767b53ac", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 74, "deletions": 65, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71d9b4930e37e7eb5ed886b36d5e6cd8f0c09812/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71d9b4930e37e7eb5ed886b36d5e6cd8f0c09812/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=71d9b4930e37e7eb5ed886b36d5e6cd8f0c09812", "patch": "@@ -134,7 +134,7 @@ override_options ()\n   /* 971208 -- EV6 scheduling parameters are still secret, so don't even\n      pretend and just schedule for an EV5 for now.  -- r~  */\n   alpha_cpu\n-    = TARGET_CPU_DEFAULT & MASK_CPU_EV6 ? PROCESSOR_EV5\n+    = TARGET_CPU_DEFAULT & MASK_CPU_EV6 ? PROCESSOR_EV6\n       : (TARGET_CPU_DEFAULT & MASK_CPU_EV5 ? PROCESSOR_EV5 : PROCESSOR_EV4);\n \n   if (alpha_cpu_string)\n@@ -169,7 +169,7 @@ override_options ()\n       else if (! strcmp (alpha_cpu_string, \"ev6\")\n \t       || ! strcmp (alpha_cpu_string, \"21264\"))\n \t{\n-\t  alpha_cpu = PROCESSOR_EV5;\n+\t  alpha_cpu = PROCESSOR_EV6;\n \t  target_flags |= MASK_BWX | MASK_CIX | MASK_MAX;\n \t}\n       else\n@@ -274,7 +274,7 @@ override_options ()\n \t{\n \t  { 3, 30, -1 },\t/* ev4 -- Bcache is a guess */\n \t  { 2, 12, 38 },\t/* ev5 -- Bcache from PC164 LMbench numbers */\n-\t  { 3, 12, -1 },\t/* ev6 -- Ho hum, doesn't exist yet */\n+\t  { 3, 13, -1 },\t/* ev6 -- Ho hum, doesn't exist yet */\n \t};\n \n \tlat = alpha_mlat_string[1] - '0';\n@@ -1291,80 +1291,30 @@ alpha_adjust_cost (insn, link, dep_insn, cost)\n   dep_insn_type = get_attr_type (dep_insn);\n \n   /* Bring in the user-defined memory latency.  */\n-  if (dep_insn_type == TYPE_LD || dep_insn_type == TYPE_LDSYM)\n+  if (dep_insn_type == TYPE_ILD\n+      || dep_insn_type == TYPE_FLD\n+      || dep_insn_type == TYPE_LDSYM)\n     cost += alpha_memory_latency-1;\n \n-  if (alpha_cpu == PROCESSOR_EV5)\n-    {\n-      /* And the lord DEC saith:  \"A special bypass provides an effective\n-\t latency of 0 cycles for an ICMP or ILOG insn producing the test\n-\t operand of an IBR or CMOV insn.\" */\n-      if ((dep_insn_type == TYPE_ICMP\n-\t   || dep_insn_type == TYPE_ILOG)\n-\t  && (insn_type == TYPE_IBR\n-\t      || (insn_type == TYPE_CMOV\n-\t\t  && !((set = single_set (dep_insn)) != 0\n-\t\t       && GET_CODE (PATTERN (insn)) == SET\n-\t\t       && (set_src = SET_SRC (PATTERN (insn)),\n-\t\t\t   GET_CODE (set_src) == IF_THEN_ELSE)\n-\t\t       && (set = SET_DEST (set),\n-\t\t\t   rtx_equal_p (set, XEXP (set_src, 1))\n-\t\t\t   || rtx_equal_p (set, XEXP (set_src, 2)))))))\n-\treturn 0;\n-\n-      /* \"The multiplier is unable to receive data from IEU bypass paths.\n-\t The instruction issues at the expected time, but its latency is\n-\t increased by the time it takes for the input data to become\n-\t available to the multiplier\" -- which happens in pipeline stage\n-\t six, when results are comitted to the register file.  */\n-\n-      if ((insn_type == TYPE_IMULL\n-\t   || insn_type == TYPE_IMULQ\n-\t   || insn_type == TYPE_IMULH)\n-\t  && (set = single_set (dep_insn)) != 0\n-\t  && GET_CODE (PATTERN (insn)) == SET\n-\t  && (set_src = SET_SRC (PATTERN (insn)),\n-\t      GET_CODE (set_src) == MULT)\n-\t  && (set = SET_DEST (set),\n-\t      rtx_equal_p (set, XEXP (set_src, 0))\n-\t      || rtx_equal_p (set, XEXP (set_src, 1))))\n-\t{\n-\t  switch (dep_insn_type)\n-\t    {\n-\t    /* These insns produce their results in pipeline stage five.  */\n-\t    case TYPE_LD:\n-\t    case TYPE_CMOV:\n-\t    case TYPE_IMULL:\n-\t    case TYPE_IMULQ:\n-\t    case TYPE_IMULH:\n-\t    case TYPE_MVI:\n-\t      return cost + 1;\n-\n-\t    /* Other integer insns produce results in pipeline stage four.  */\n-\t    default:\n-\t      return cost + 2;\n-\t    }\n-\t}\n-    }\n-  else\n+  switch (alpha_cpu)\n     {\n+    case PROCESSOR_EV4:\n       /* On EV4, if INSN is a store insn and DEP_INSN is setting the data\n \t being stored, we can sometimes lower the cost.  */\n \n-      if (insn_type == TYPE_ST\n+      if ((insn_type == TYPE_IST || insn_type == TYPE_FST)\n \t  && (set = single_set (dep_insn)) != 0\n \t  && GET_CODE (PATTERN (insn)) == SET\n \t  && rtx_equal_p (SET_DEST (set), SET_SRC (PATTERN (insn))))\n \t{\n \t  switch (dep_insn_type)\n \t    {\n-\t    case TYPE_LD:\n+\t    case TYPE_ILD:\n+\t    case TYPE_FLD:\n \t      /* No savings here.  */\n \t      return cost;\n \n-\t    case TYPE_IMULL:\n-\t    case TYPE_IMULQ:\n-\t    case TYPE_IMULH:\n+\t    case TYPE_IMUL:\n \t      /* In these cases, we save one cycle.  */\n \t      return cost - 1;\n \n@@ -1377,14 +1327,17 @@ alpha_adjust_cost (insn, link, dep_insn, cost)\n       /* Another case that needs adjustment is an arithmetic or logical\n \t operation.  It's cost is usually one cycle, but we default it to\n \t two in the MD file.  The only case that it is actually two is\n-\t for the address in loads and stores.  */\n+\t for the address in loads, stores, and jumps.  */\n \n       if (dep_insn_type == TYPE_IADD || dep_insn_type == TYPE_ILOG)\n \t{\n \t  switch (insn_type)\n \t    {\n-\t    case TYPE_LD:\n-\t    case TYPE_ST:\n+\t    case TYPE_ILD:\n+\t    case TYPE_IST:\n+\t    case TYPE_FLD:\n+\t    case TYPE_FST:\n+\t    case TYPE_JSR:\n \t      return cost;\n \t    default:\n \t      return 1;\n@@ -1396,6 +1349,62 @@ alpha_adjust_cost (insn, link, dep_insn, cost)\n \n       if (dep_insn_type == TYPE_ICMP && insn_type == TYPE_IBR)\n \treturn 1;\n+      break;\n+\n+    case PROCESSOR_EV5:\n+      /* And the lord DEC saith:  \"A special bypass provides an effective\n+\t latency of 0 cycles for an ICMP or ILOG insn producing the test\n+\t operand of an IBR or ICMOV insn.\" */\n+\n+      if ((dep_insn_type == TYPE_ICMP || dep_insn_type == TYPE_ILOG)\n+\t  && (set = single_set (dep_insn)) != 0)\n+\t{\n+\t  /* A branch only has one input.  This must be it.  */\n+\t  if (insn_type == TYPE_IBR)\n+\t    return 0;\n+\t  /* A conditional move has three, make sure it is the test.  */\n+\t  if (insn_type == TYPE_ICMOV\n+\t      && GET_CODE (set_src = PATTERN (insn)) == SET\n+\t      && GET_CODE (set_src = SET_SRC (set_src)) == IF_THEN_ELSE\n+\t      && rtx_equal_p (SET_DEST (set), XEXP (set_src, 0)))\n+\t    return 0;\n+\t}\n+\n+      /* \"The multiplier is unable to receive data from IEU bypass paths.\n+\t The instruction issues at the expected time, but its latency is\n+\t increased by the time it takes for the input data to become\n+\t available to the multiplier\" -- which happens in pipeline stage\n+\t six, when results are comitted to the register file.  */\n+\n+      if (insn_type == TYPE_IMUL)\n+\t{\n+\t  switch (dep_insn_type)\n+\t    {\n+\t    /* These insns produce their results in pipeline stage five.  */\n+\t    case TYPE_ILD:\n+\t    case TYPE_ICMOV:\n+\t    case TYPE_IMUL:\n+\t    case TYPE_MVI:\n+\t      return cost + 1;\n+\n+\t    /* Other integer insns produce results in pipeline stage four.  */\n+\t    default:\n+\t      return cost + 2;\n+\t    }\n+\t}\n+      break;\n+\n+    case PROCESSOR_EV6:\n+      /* There is additional latency to move the result of (most) FP \n+         operations anywhere but the FP register file.  */\n+\n+      if ((insn_type == TYPE_FST || insn_type == TYPE_FTOI)\n+\t  && (dep_insn_type == TYPE_FADD ||\n+\t      dep_insn_type == TYPE_FMUL ||\n+\t      dep_insn_type == TYPE_FCMOV))\n+        return cost + 2;\n+\n+      break;\n     }\n \n   /* Otherwise, return the default cost. */"}, {"sha": "501fe564d0f8b9461d2f8ce6d2b0d86396f21077", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71d9b4930e37e7eb5ed886b36d5e6cd8f0c09812/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71d9b4930e37e7eb5ed886b36d5e6cd8f0c09812/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=71d9b4930e37e7eb5ed886b36d5e6cd8f0c09812", "patch": "@@ -769,9 +769,10 @@ enum reg_class { NO_REGS, GENERAL_REGS, FLOAT_REGS, ALL_REGS,\n    reduce the impact of not being able to allocate a pseudo to a\n    hard register.  */\n \n-#define REGISTER_MOVE_COST(CLASS1, CLASS2)\t\t\t\t\\\n-  (TARGET_CIX || ((CLASS1) == FLOAT_REGS) == ((CLASS2) == FLOAT_REGS)\t\\\n-   ? 2 : 4+2*alpha_memory_latency)\n+#define REGISTER_MOVE_COST(CLASS1, CLASS2)\t\t\\\n+  (((CLASS1) == FLOAT_REGS) == ((CLASS2) == FLOAT_REGS)\t\\\n+   ? 2\t\t\t\t\t\t\t\\\n+   : TARGET_CIX ? 3 : 4+2*alpha_memory_latency)\n \n /* A C expressions returning the cost of moving data of MODE from a register to\n    or from memory.\n@@ -1596,7 +1597,7 @@ extern void alpha_init_expanders ();\n    our own exit function.  */\n #define HAVE_ATEXIT\n \n-/* The EV4 is dual issue; EV5 is quad issue.  */\n+/* The EV4 is dual issue; EV5/EV6 are quad issue.  */\n #define ISSUE_RATE  (alpha_cpu == PROCESSOR_EV4 ? 2 : 4)\n \n /* Compute the cost of computing a constant rtl expression RTX"}, {"sha": "583517f633f9292c794bb19428366fba2a8a3511", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 345, "deletions": 165, "changes": 510, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71d9b4930e37e7eb5ed886b36d5e6cd8f0c09812/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71d9b4930e37e7eb5ed886b36d5e6cd8f0c09812/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=71d9b4930e37e7eb5ed886b36d5e6cd8f0c09812", "patch": "@@ -24,7 +24,7 @@\n ;; Processor type -- this attribute must exactly match the processor_type\n ;; enumeration in alpha.h.\n \n-(define_attr \"cpu\" \"ev4,ev5\"\n+(define_attr \"cpu\" \"ev4,ev5,ev6\"\n   (const (symbol_ref \"alpha_cpu\")))\n \n ;; Define an insn type attribute.  This is used in function unit delay\n@@ -33,194 +33,319 @@\n ;; separately.\n \n (define_attr \"type\"\n-  \"ld,st,ibr,fbr,jsr,iadd,ilog,shift,cmov,icmp,imull,imulq,imulh,fadd,fmul,fcpys,fdivs,fdivt,ldsym,misc,mvi\"\n+  \"ild,fld,ldsym,ist,fst,ibr,fbr,jsr,iadd,ilog,shift,icmov,fcmov,icmp,imul,fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof\"\n   (const_string \"iadd\"))\n \n+(define_attr \"opsize\" \"si,di,udi\" (const_string \"di\"))\n+\n ;; The TRAP_TYPE attribute marks instructions that may generate traps\n ;; (which are imprecise and may need a trapb if software completion\n ;; is desired).\n (define_attr \"trap\" \"no,yes\" (const_string \"no\"))\n \n-;; For the EV4 we include four function units: ABOX, which computes\n-;; the address, BBOX, used for branches, EBOX, used for integer\n-;; operations, and FBOX, used for FP operations.\n+\f\n+;; On EV4 there are two classes of resources to consider: resources needed\n+;; to issue, and resources needed to execute.  IBUS[01] are in the first\n+;; category.  ABOX, BBOX, EBOX, FBOX, IMUL & FDIV make up the second.\n+;; (There are are a few other register-like resources, but ...)\n+\n+; First, describe all of the issue constraints with single cycle delays.\n+; All insns need a bus, but all except loads require one or the other.\n+(define_function_unit \"ev4_ibus0\" 1 0\n+  (and (eq_attr \"cpu\" \"ev4\")\n+       (eq_attr \"type\" \"fst,fbr,iadd,imul,ilog,shift,icmov,icmp\"))\n+  1 1)\n+\n+(define_function_unit \"ev4_ibus1\" 1 0\n+  (and (eq_attr \"cpu\" \"ev4\")\n+       (eq_attr \"type\" \"ist,ibr,jsr,fadd,fcmov,fcpys,fmul,fdiv,misc\"))\n+  1 1)\n \n-;; Memory delivers its result in three cycles.  Actually return one and\n-;; take care of this in adjust_cost, since we want to handle user-defined\n-;; memory latencies.\n+; Memory delivers its result in three cycles.  Actually return one and\n+; take care of this in adjust_cost, since we want to handle user-defined\n+; memory latencies.\n (define_function_unit \"ev4_abox\" 1 0\n   (and (eq_attr \"cpu\" \"ev4\")\n-       (eq_attr \"type\" \"ld,ldsym,st\"))\n+       (eq_attr \"type\" \"ild,fld,ldsym,ist,fst\"))\n   1 1)\n \n-;; Branches have no delay cost, but do tie up the unit for two cycles.\n+; Branches have no delay cost, but do tie up the unit for two cycles.\n (define_function_unit \"ev4_bbox\" 1 1\n   (and (eq_attr \"cpu\" \"ev4\")\n        (eq_attr \"type\" \"ibr,fbr,jsr\"))\n   2 2)\n \n-;; Arithmetic insns are normally have their results available after\n-;; two cycles.  There are a number of exceptions.  They are encoded in\n-;; ADJUST_COST.  Some of the other insns have similar exceptions.\n-\n+; Arithmetic insns are normally have their results available after\n+; two cycles.  There are a number of exceptions.  They are encoded in\n+; ADJUST_COST.  Some of the other insns have similar exceptions.\n (define_function_unit \"ev4_ebox\" 1 0\n   (and (eq_attr \"cpu\" \"ev4\")\n-       (eq_attr \"type\" \"iadd,ilog,shift,cmov,icmp\"))\n+       (eq_attr \"type\" \"iadd,ilog,shift,icmov,icmp,misc\"))\n   2 1)\n \n-;; These really don't take up the integer pipeline, but they do occupy\n-;; IBOX1; we approximate here.\n-\n-(define_function_unit \"ev4_ebox\" 1 0\n-  (and (eq_attr \"cpu\" \"ev4\")\n-       (eq_attr \"type\" \"imull\"))\n-  21 1)\n-\n-(define_function_unit \"ev4_ebox\" 1 0\n-  (and (eq_attr \"cpu\" \"ev4\")\n-       (eq_attr \"type\" \"imulq,imulh\"))\n-  23 1)\n-\n-(define_function_unit \"ev4_imult\" 1 0\n+(define_function_unit \"imul\" 1 0\n   (and (eq_attr \"cpu\" \"ev4\")\n-       (eq_attr \"type\" \"imull\"))\n+       (and (eq_attr \"type\" \"imul\")\n+\t    (eq_attr \"opsize\" \"si\")))\n   21 19)\n \n-(define_function_unit \"ev4_imult\" 1 0\n+(define_function_unit \"imul\" 1 0\n   (and (eq_attr \"cpu\" \"ev4\")\n-       (eq_attr \"type\" \"imulq,imulh\"))\n+       (and (eq_attr \"type\" \"imul\")\n+\t    (eq_attr \"opsize\" \"!si\")))\n   23 21)\n \n (define_function_unit \"ev4_fbox\" 1 0\n   (and (eq_attr \"cpu\" \"ev4\")\n-       (eq_attr \"type\" \"fadd,fmul,fcpys\"))\n+       (eq_attr \"type\" \"fadd,fmul,fcpys,fcmov\"))\n   6 1)\n \n-(define_function_unit \"ev4_fbox\" 1 0\n-  (and (eq_attr \"cpu\" \"ev4\")\n-       (eq_attr \"type\" \"fdivs\"))\n-  34 0)\n-\n-(define_function_unit \"ev4_fbox\" 1 0\n+(define_function_unit \"fdiv\" 1 0\n   (and (eq_attr \"cpu\" \"ev4\")\n-       (eq_attr \"type\" \"fdivt\"))\n-  63 0)\n-\n-(define_function_unit \"ev4_divider\" 1 0\n-  (and (eq_attr \"cpu\" \"ev4\")\n-       (eq_attr \"type\" \"fdivs\"))\n+       (and (eq_attr \"type\" \"fdiv\")\n+\t    (eq_attr \"opsize\" \"si\")))\n   34 30)\n \n-(define_function_unit \"ev4_divider\" 1 0\n+(define_function_unit \"fdiv\" 1 0\n   (and (eq_attr \"cpu\" \"ev4\")\n-       (eq_attr \"type\" \"fdivt\"))\n-  64 59)\n+       (and (eq_attr \"type\" \"fdiv\")\n+\t    (eq_attr \"opsize\" \"di\")))\n+  63 59)\n \f\n ;; EV5 scheduling.  EV5 can issue 4 insns per clock.\n-;; We consider the EV6 and EV5 for now.\n-\n-;; EV5 has two asymetric integer units.  Model this with ebox,e0,e1.\n-;; Everything uses ebox, and those that require particular pipes grab\n-;; those as well.\n+;;\n+;; EV5 has two asymetric integer units.  Model this with E0 & E1 along\n+;; with the combined resource EBOX.\n \n (define_function_unit \"ev5_ebox\" 2 0\n   (and (eq_attr \"cpu\" \"ev5\")\n-       (eq_attr \"type\" \"iadd,ilog,icmp,st,shift,imull,imulq,imulh,mvi\"))\n+       (eq_attr \"type\" \"!fbr,fcmov,fadd,fmul,fcpys,fdiv\"))\n   1 1)\n \n-;; Memory takes at least 2 clocks, and load cannot dual issue with stores.\n-;; Return one from here and fix up with user-defined latencies in adjust_cost.\n+; Memory takes at least 2 clocks.  Return one from here and fix up with\n+; user-defined latencies in adjust_cost.\n+; ??? How to: \"An instruction of class LD cannot be issued in the _second_\n+; cycle after an instruction of class ST is issued.\"\n (define_function_unit \"ev5_ebox\" 2 0\n   (and (eq_attr \"cpu\" \"ev5\")\n-       (eq_attr \"type\" \"ld,ldsym\"))\n+       (eq_attr \"type\" \"ild,fld,ldsym\"))\n   1 1)\n \n+; Stores, shifts, multiplies can only issue to E0\n (define_function_unit \"ev5_e0\" 1 0\n   (and (eq_attr \"cpu\" \"ev5\")\n-       (eq_attr \"type\" \"ld,ldsym\"))\n-  0 1\n-  [(eq_attr \"type\" \"st\")])\n-\n-;; Conditional moves always take 2 ticks.\n-(define_function_unit \"ev5_ebox\" 2 0\n-  (and (eq_attr \"cpu\" \"ev5\")\n-       (eq_attr \"type\" \"cmov\"))\n-  2 1)\n-\n-;; Stores, shifts, multiplies can only issue to E0\n-(define_function_unit \"ev5_e0\" 1 0\n-  (and (eq_attr \"cpu\" \"ev5\")\n-       (eq_attr \"type\" \"st\"))\n+       (eq_attr \"type\" \"ist,fst,shift,imul\"))\n   1 1)\n \n-;; Motion video insns also issue only to E0, and take two ticks.\n+; Motion video insns also issue only to E0, and take two ticks.\n (define_function_unit \"ev5_e0\" 1 0\n   (and (eq_attr \"cpu\" \"ev5\")\n        (eq_attr \"type\" \"mvi\"))\n   2 1)\n \n-;; But shifts and multiplies don't conflict with loads.\n-(define_function_unit \"ev5_e0\" 1 0\n+; Conditional moves always take 2 ticks.\n+(define_function_unit \"ev5_ebox\" 2 0\n   (and (eq_attr \"cpu\" \"ev5\")\n-       (eq_attr \"type\" \"shift,imull,imulq,imulh,mvi\"))\n-  1 1\n-  [(eq_attr \"type\" \"st,shift,imull,imulq,imulh,mvi\")])\n+       (eq_attr \"type\" \"icmov\"))\n+  2 1)\n \n-;; Branches can only issue to E1\n+; Branches can only issue to E1\n (define_function_unit \"ev5_e1\" 1 0\n   (and (eq_attr \"cpu\" \"ev5\")\n        (eq_attr \"type\" \"ibr,jsr\"))\n   1 1)\n \n-;; Multiplies also use the integer multiplier.\n-(define_function_unit \"ev5_imult\" 1 0\n+; Multiplies also use the integer multiplier.\n+; ??? How to: \"No instruction can be issued to pipe E0 exactly two\n+; cycles before an integer multiplication completes.\"\n+(define_function_unit \"imul\" 1 0\n   (and (eq_attr \"cpu\" \"ev5\")\n-       (eq_attr \"type\" \"imull\"))\n+       (and (eq_attr \"type\" \"imul\")\n+\t    (eq_attr \"opsize\" \"si\")))\n   8 4)\n \n-(define_function_unit \"ev5_imult\" 1 0\n+(define_function_unit \"imul\" 1 0\n   (and (eq_attr \"cpu\" \"ev5\")\n-       (eq_attr \"type\" \"imulq\"))\n+       (and (eq_attr \"type\" \"imul\")\n+\t    (eq_attr \"opsize\" \"di\")))\n   12 8)\n \n-(define_function_unit \"ev5_imult\" 1 0\n+(define_function_unit \"imul\" 1 0\n   (and (eq_attr \"cpu\" \"ev5\")\n-       (eq_attr \"type\" \"imulh\"))\n+       (and (eq_attr \"type\" \"imul\")\n+\t    (eq_attr \"opsize\" \"udi\")))\n   14 8)\n \n ;; Similarly for the FPU we have two asymetric units.  But fcpys can issue\n ;; on either so we have to play the game again.\n \n-(define_function_unit \"ev5_fpu\" 2 0\n+(define_function_unit \"ev5_fbox\" 2 0\n   (and (eq_attr \"cpu\" \"ev5\")\n-       (eq_attr \"type\" \"fadd,fmul,fcpys,fbr,fdivs,fdivt\"))\n+       (eq_attr \"type\" \"fadd,fcmov,fmul,fcpys,fbr,fdiv\"))\n   4 1)\n   \n-;; Multiplies (resp. adds) also use the fmul (resp. fadd) units.\n (define_function_unit \"ev5_fm\" 1 0\n   (and (eq_attr \"cpu\" \"ev5\")\n        (eq_attr \"type\" \"fmul\"))\n   4 1)\n \n+; Add and cmov as you would expect; fbr never produces a result;\n+; fdiv issues through fa to the divider, \n (define_function_unit \"ev5_fa\" 1 0\n   (and (eq_attr \"cpu\" \"ev5\")\n-       (eq_attr \"type\" \"fadd\"))\n+       (eq_attr \"type\" \"fadd,fcmov,fbr,fdiv\"))\n   4 1)\n \n-(define_function_unit \"ev5_fa\" 1 0\n+; ??? How to: \"No instruction can be issued to pipe FA exactly five\n+; cycles before a floating point divide completes.\"\n+(define_function_unit \"fdiv\" 1 0\n   (and (eq_attr \"cpu\" \"ev5\")\n-       (eq_attr \"type\" \"fbr\"))\n-  1 1)\n+       (and (eq_attr \"type\" \"fdiv\")\n+\t    (eq_attr \"opsize\" \"si\")))\n+  15 15)\t\t\t\t; 15 to 31 data dependant\n \n-(define_function_unit \"ev5_fa\" 1 0\n+(define_function_unit \"fdiv\" 1 0\n   (and (eq_attr \"cpu\" \"ev5\")\n-       (eq_attr \"type\" \"fdivs\"))\n-  15 1)\n+       (and (eq_attr \"type\" \"fdiv\")\n+\t    (eq_attr \"opsize\" \"di\")))\n+  22 22)\t\t\t\t; 22 to 60 data dependant\n+\f\n+;; EV6 scheduling.  EV6 can issue 4 insns per clock.\n+;;\n+;; EV6 has two symmetric pairs (\"clusters\") of two asymetric integer units\n+;; (\"upper\" and \"lower\"), yielding pipe names U0, U1, L0, L1.\n+\n+;; Conditional moves decompose into two independant primitives, each \n+;; taking one cycle.  Since ev6 is out-of-order, we can't see anything\n+;; but two cycles.\n+(define_function_unit \"ev6_ebox\" 4 0\n+  (and (eq_attr \"cpu\" \"ev6\")\n+       (eq_attr \"type\" \"icmov\"))\n+  2 1)\n+\n+(define_function_unit \"ev6_ebox\" 4 0\n+  (and (eq_attr \"cpu\" \"ev6\")\n+       (eq_attr \"type\" \"!fbr,fcmov,fadd,fmul,fcpys,fdiv,fsqrt\"))\n+  1 1)\n+\n+;; Integer loads take at least 3 clocks, and only issue to lower units.\n+;; Return one from here and fix up with user-defined latencies in adjust_cost.\n+(define_function_unit \"ev6_l\" 2 0\n+  (and (eq_attr \"cpu\" \"ev6\")\n+       (eq_attr \"type\" \"ild,ldsym,ist,fst\"))\n+  1 1)\n+\n+;; FP loads take at least 4 clocks.  Return two from here...\n+(define_function_unit \"ev6_l\" 2 0\n+  (and (eq_attr \"cpu\" \"ev6\")\n+       (eq_attr \"type\" \"fld\"))\n+  2 1)\n+\n+;; Motion video insns also issue only to U0, and take three ticks.\n+(define_function_unit \"ev6_u0\" 1 0\n+  (and (eq_attr \"cpu\" \"ev6\")\n+       (eq_attr \"type\" \"mvi\"))\n+  3 1)\n+\n+(define_function_unit \"ev6_u\" 2 0\n+  (and (eq_attr \"cpu\" \"ev6\")\n+       (eq_attr \"type\" \"mvi\"))\n+  3 1)\n+\n+;; Shifts issue to either upper pipe.\n+(define_function_unit \"ev6_u\" 2 0\n+  (and (eq_attr \"cpu\" \"ev6\")\n+       (eq_attr \"type\" \"shift\"))\n+  1 1)\n+\n+;; Multiplies issue only to U1, and all take 7 ticks.\n+;; Rather than create a new function unit just for U1, reuse IMUL\n+(define_function_unit \"imul\" 1 0\n+  (and (eq_attr \"cpu\" \"ev6\")\n+       (eq_attr \"type\" \"imul\"))\n+  7 1)\n+\n+(define_function_unit \"ev6_u\" 2 0\n+  (and (eq_attr \"cpu\" \"ev6\")\n+       (eq_attr \"type\" \"imul\"))\n+  7 1)\n+\n+;; Branches issue to either upper pipe\n+(define_function_unit \"ev6_u\" 2 0\n+  (and (eq_attr \"cpu\" \"ev6\")\n+       (eq_attr \"type\" \"ibr\"))\n+  3 1)\n+\n+;; Calls only issue to L0.\n+(define_function_unit \"ev6_l0\" 1 0\n+  (and (eq_attr \"cpu\" \"ev6\")\n+       (eq_attr \"type\" \"jsr\"))\n+  1 1)\n+\n+(define_function_unit \"ev6_l\" 2 0\n+  (and (eq_attr \"cpu\" \"ev6\")\n+       (eq_attr \"type\" \"jsr\"))\n+  1 1)\n+\n+;; Ftoi/itof only issue to lower pipes\n+(define_function_unit \"ev6_l\" 2 0\n+  (and (eq_attr \"cpu\" \"ev6\")\n+       (eq_attr \"type\" \"ftoi\"))\n+  3 1)\n+\n+(define_function_unit \"ev6_l\" 2 0\n+  (and (eq_attr \"cpu\" \"ev6\")\n+       (eq_attr \"type\" \"itof\"))\n+  4 1)\n+\n+;; For the FPU we are very similar to EV5, except there's no insn that\n+;; can issue to fm & fa, so we get to leave that out.\n+  \n+(define_function_unit \"ev6_fm\" 1 0\n+  (and (eq_attr \"cpu\" \"ev6\")\n+       (eq_attr \"type\" \"fmul\"))\n+  4 1)\n+\n+(define_function_unit \"ev6_fa\" 1 0\n+  (and (eq_attr \"cpu\" \"ev6\")\n+       (eq_attr \"type\" \"fadd,fcpys,fbr,fdiv,fsqrt\"))\n+  4 1)\n+\n+(define_function_unit \"ev6_fa\" 1 0\n+  (and (eq_attr \"cpu\" \"ev6\")\n+       (eq_attr \"type\" \"fcmov\"))\n+  8 1)\n+\n+(define_function_unit \"fdiv\" 1 0\n+  (and (eq_attr \"cpu\" \"ev6\")\n+       (and (eq_attr \"type\" \"fdiv\")\n+\t    (eq_attr \"opsize\" \"si\")))\n+  12 10)\n+\n+(define_function_unit \"fdiv\" 1 0\n+  (and (eq_attr \"cpu\" \"ev6\")\n+       (and (eq_attr \"type\" \"fdiv\")\n+\t    (eq_attr \"opsize\" \"di\")))\n+  15 13)\n+\n+(define_function_unit \"fsqrt\" 1 0\n+  (and (eq_attr \"cpu\" \"ev6\")\n+       (and (eq_attr \"type\" \"fsqrt\")\n+\t    (eq_attr \"opsize\" \"si\")))\n+  16 14)\n+\n+(define_function_unit \"fsqrt\" 1 0\n+  (and (eq_attr \"cpu\" \"ev6\")\n+       (and (eq_attr \"type\" \"fsqrt\")\n+\t    (eq_attr \"opsize\" \"di\")))\n+  32 30)\n+\n+; ??? The FPU communicates with memory and the integer register file\n+; via two fp store units.  We need a slot in the fst immediately, and\n+; a slot in LOW after the operand data is ready.  At which point the\n+; data may be movedeither to the store queue or the integer register\n+; file and the insn retired.\n \n-(define_function_unit \"ev5_fa\" 1 0\n-  (and (eq_attr \"cpu\" \"ev5\")\n-       (eq_attr \"type\" \"fdivt\"))\n-  22 1)\n \f\n ;; First define the arithmetic insns.  Note that the 32-bit forms also\n ;; sign-extend.\n@@ -238,7 +363,7 @@\n    addl %1,$31,%0\n    ldl %0,%1\n    cvtql %1,%0\\;cvtlq %0,%0\"\n-  [(set_attr \"type\" \"iadd,ld,fadd\")])\n+  [(set_attr \"type\" \"iadd,ild,fadd\")])\n \n ;; Do addsi3 the way expand_binop would do if we didn't have one.  This\n ;; generates better code.  We have the anonymous addsi3 pattern below in\n@@ -595,23 +720,25 @@\n \t\t (match_operand:SI 2 \"reg_or_0_operand\" \"rJ\")))]\n   \"\"\n   \"mull %r1,%r2,%0\"\n-  [(set_attr \"type\" \"imull\")])\n+  [(set_attr \"type\" \"imul\")\n+   (set_attr \"opsize\" \"si\")])\n \n (define_insn \"\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(sign_extend:DI (mult:SI (match_operand:SI 1 \"reg_or_0_operand\" \"%rJ\")\n \t\t\t\t (match_operand:SI 2 \"reg_or_0_operand\" \"rJ\"))))]\n   \"\"\n   \"mull %r1,%r2,%0\"\n-  [(set_attr \"type\" \"imull\")])\n+  [(set_attr \"type\" \"imul\")\n+   (set_attr \"opsize\" \"si\")])\n \n (define_insn \"muldi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(mult:DI (match_operand:DI 1 \"reg_or_0_operand\" \"%rJ\")\n \t\t (match_operand:DI 2 \"reg_or_0_operand\" \"rJ\")))]\n   \"\"\n   \"mulq %r1,%r2,%0\"\n-  [(set_attr \"type\" \"imulq\")])\n+  [(set_attr \"type\" \"imul\")])\n \n (define_insn \"umuldi3_highpart\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n@@ -622,7 +749,8 @@\n \t  (const_int 64))))]\n   \"\"\n   \"umulh %1,%2,%0\"\n-  [(set_attr \"type\" \"imulh\")])\n+  [(set_attr \"type\" \"imul\")\n+   (set_attr \"opsize\" \"udi\")])\n \n (define_insn \"\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n@@ -633,7 +761,8 @@\n \t  (const_int 64))))]\n   \"\"\n   \"umulh %1,%2,%0\"\n-  [(set_attr \"type\" \"imulh\")])\n+  [(set_attr \"type\" \"imul\")\n+   (set_attr \"opsize\" \"udi\")])\n \f\n ;; The divide and remainder operations always take their inputs from\n ;; r24 and r25, put their output in r27, and clobber r23 and r28.\n@@ -824,7 +953,7 @@\n   \"@\n    and %1,255,%0\n    ldbu %0,%1\"\n-  [(set_attr \"type\" \"ilog,ld\")])\n+  [(set_attr \"type\" \"ilog,ild\")])\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n@@ -846,7 +975,7 @@\n   \"@\n    and %1,255,%0\n    ldbu %0,%1\"\n-  [(set_attr \"type\" \"ilog,ld\")])\n+  [(set_attr \"type\" \"ilog,ild\")])\n \n (define_insn \"\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n@@ -868,7 +997,7 @@\n   \"@\n    zapnot %1,3,%0\n    ldwu %0,%1\"\n-  [(set_attr \"type\" \"shift,ld\")])\n+  [(set_attr \"type\" \"shift,ild\")])\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n@@ -890,7 +1019,7 @@\n   \"@\n    zapnot %1,3,%0\n    ldwu %0,%1\"\n-  [(set_attr \"type\" \"shift,ld\")])\n+  [(set_attr \"type\" \"shift,ild\")])\n \n (define_insn \"\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n@@ -985,7 +1114,9 @@\n \t(unspec [(match_operand:DI 1 \"register_operand\" \"r\")] 1))]\n   \"TARGET_CIX\"\n   \"cttz %1,%0\"\n-  [(set_attr \"type\" \"shift\")])\n+  ; ev6 calls all mvi and cttz/ctlz/popc class imisc, so just \n+  ; reuse the existing type name.\n+  [(set_attr \"type\" \"mvi\")])\n \f\n ;; Next come the shifts and the various extract and insert operations.\n \n@@ -1619,7 +1750,7 @@\n    cpys %1,%1,%0\n    ld%, %0,%1\n    st%- %1,%0\"\n-  [(set_attr \"type\" \"fcpys,ld,st\")\n+  [(set_attr \"type\" \"fcpys,fld,fst\")\n    (set_attr \"trap\" \"yes\")])\n \n (define_insn \"\"\n@@ -1644,7 +1775,8 @@\n \t\t(match_operand:SF 2 \"reg_or_fp0_operand\" \"fG\")))]\n   \"TARGET_FP && alpha_tp == ALPHA_TP_INSN\"\n   \"div%,%)%& %R1,%R2,%0\"\n-  [(set_attr \"type\" \"fdivs\")\n+  [(set_attr \"type\" \"fdiv\")\n+   (set_attr \"opsize\" \"si\")\n    (set_attr \"trap\" \"yes\")])\n \n (define_insn \"divsf3\"\n@@ -1653,7 +1785,8 @@\n \t\t(match_operand:SF 2 \"reg_or_fp0_operand\" \"fG\")))]\n   \"TARGET_FP\"\n   \"div%,%)%& %R1,%R2,%0\"\n-  [(set_attr \"type\" \"fdivs\")\n+  [(set_attr \"type\" \"fdiv\")\n+   (set_attr \"opsize\" \"si\")\n    (set_attr \"trap\" \"yes\")])\n \n (define_insn \"\"\n@@ -1662,7 +1795,7 @@\n \t\t(match_operand:DF 2 \"reg_or_fp0_operand\" \"fG\")))]\n   \"TARGET_FP && alpha_tp == ALPHA_TP_INSN\"\n   \"div%-%)%& %R1,%R2,%0\"\n-  [(set_attr \"type\" \"fdivt\")\n+  [(set_attr \"type\" \"fdiv\")\n    (set_attr \"trap\" \"yes\")])\n \n (define_insn \"divdf3\"\n@@ -1671,7 +1804,7 @@\n \t\t(match_operand:DF 2 \"reg_or_fp0_operand\" \"fG\")))]\n   \"TARGET_FP\"\n   \"div%-%)%& %R1,%R2,%0\"\n-  [(set_attr \"type\" \"fdivt\")\n+  [(set_attr \"type\" \"fdiv\")\n    (set_attr \"trap\" \"yes\")])\n \n (define_insn \"\"\n@@ -1680,7 +1813,7 @@\n \t\t(match_operand:DF 2 \"reg_or_fp0_operand\" \"fG\")))]\n   \"TARGET_FP && alpha_tp != ALPHA_TP_INSN\"\n   \"div%-%)%& %R1,%R2,%0\"\n-  [(set_attr \"type\" \"fdivt\")\n+  [(set_attr \"type\" \"fdiv\")\n    (set_attr \"trap\" \"yes\")])\n \n (define_insn \"\"\n@@ -1690,7 +1823,7 @@\n \t\t (match_operand:SF 2 \"reg_or_fp0_operand\" \"fG\"))))]\n   \"TARGET_FP && alpha_tp != ALPHA_TP_INSN\"\n   \"div%-%)%& %R1,%R2,%0\"\n-  [(set_attr \"type\" \"fdivt\")\n+  [(set_attr \"type\" \"fdiv\")\n    (set_attr \"trap\" \"yes\")])\n \n (define_insn \"\"\n@@ -1699,7 +1832,7 @@\n \t\t(float_extend:DF (match_operand:SF 2 \"reg_or_fp0_operand\" \"fG\"))))]\n   \"TARGET_FP && alpha_tp != ALPHA_TP_INSN\"\n   \"div%-%)%& %R1,%R2,%0\"\n-  [(set_attr \"type\" \"fdivt\")\n+  [(set_attr \"type\" \"fdiv\")\n    (set_attr \"trap\" \"yes\")])\n \n (define_insn \"\"\n@@ -1826,29 +1959,38 @@\n   [(set_attr \"type\" \"fadd\")\n    (set_attr \"trap\" \"yes\")])\n \n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=&f\")\n+\t(sqrt:SF (match_operand:SF 1 \"reg_or_fp0_operand\" \"fG\")))]\n+  \"TARGET_FP && TARGET_CIX && alpha_tp == ALPHA_TP_INSN\"\n+  \"sqrt%,%)%& %R1,%0\"\n+  [(set_attr \"type\" \"fsqrt\")\n+   (set_attr \"opsize\" \"si\")\n+   (set_attr \"trap\" \"yes\")])\n+\n (define_insn \"sqrtsf2\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n \t(sqrt:SF (match_operand:SF 1 \"reg_or_fp0_operand\" \"fG\")))]\n   \"TARGET_FP && TARGET_CIX\"\n-  \"sqrt%, %1,%0\"\n-  [(set_attr \"type\" \"fdivs\")\n+  \"sqrt%,%)%& %R1,%0\"\n+  [(set_attr \"type\" \"fsqrt\")\n+   (set_attr \"opsize\" \"si\")\n    (set_attr \"trap\" \"yes\")])\n \n-(define_insn \"sqrtdf2\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=&f\")\n \t(sqrt:DF (match_operand:DF 1 \"reg_or_fp0_operand\" \"fG\")))]\n-  \"TARGET_FP && TARGET_CIX\"\n-  \"sqrt%- %1,%0\"\n-  [(set_attr \"type\" \"fdivt\")\n+  \"TARGET_FP && TARGET_CIX && alpha_tp == ALPHA_TP_INSN\"\n+  \"sqrt%-%)%& %R1,%0\"\n+  [(set_attr \"type\" \"fsqrt\")\n    (set_attr \"trap\" \"yes\")])\n \n-(define_insn \"\"\n+(define_insn \"sqrtdf2\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n-\t(sqrt:DF (float_extend:DF\n-\t\t  (match_operand:SF 1 \"reg_or_fp0_operand\" \"fG\"))))]\n-  \"TARGET_FP && TARGET_CIX&& alpha_tp != ALPHA_TP_INSN\"\n-  \"sqrt%- %1,%0\"\n-  [(set_attr \"type\" \"fdivt\")\n+\t(sqrt:DF (match_operand:DF 1 \"reg_or_fp0_operand\" \"fG\")))]\n+  \"TARGET_FP && TARGET_CIX\"\n+  \"sqrt%-%)%& %1,%0\"\n+  [(set_attr \"type\" \"fsqrt\")\n    (set_attr \"trap\" \"yes\")])\n \f\n ;; Next are all the integer comparisons, and conditional moves and branches\n@@ -1889,7 +2031,7 @@\n    cmov%D2 %r3,%5,%0\n    cmov%c2 %r4,%1,%0\n    cmov%d2 %r4,%5,%0\"\n-  [(set_attr \"type\" \"cmov\")])\n+  [(set_attr \"type\" \"icmov\")])\n \n (define_insn \"\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r,r,r,r\")\n@@ -1905,7 +2047,7 @@\n    cmov%D2 %r3,%5,%0\n    cmov%c2 %r4,%1,%0\n    cmov%d2 %r4,%5,%0\"\n-  [(set_attr \"type\" \"cmov\")])\n+  [(set_attr \"type\" \"icmov\")])\n \n (define_insn \"\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n@@ -1920,7 +2062,7 @@\n   \"@\n    cmovlbc %r2,%1,%0\n    cmovlbs %r2,%3,%0\"\n-  [(set_attr \"type\" \"cmov\")])\n+  [(set_attr \"type\" \"icmov\")])\n \n (define_insn \"\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n@@ -1935,7 +2077,7 @@\n   \"@\n    cmovlbs %r2,%1,%0\n    cmovlbc %r2,%3,%0\"\n-  [(set_attr \"type\" \"cmov\")])\n+  [(set_attr \"type\" \"icmov\")])\n \n ;; This form is added since combine thinks that an IF_THEN_ELSE with both\n ;; arms constant is a single insn, so it won't try to form it if combine\n@@ -1954,7 +2096,7 @@\n    (clobber (match_scratch:DI 4 \"=&r\"))]\n   \"\"\n   \"addq %0,%1,%4\\;cmov%C2 %r3,%4,%0\"\n-  [(set_attr \"type\" \"cmov\")])\n+  [(set_attr \"type\" \"icmov\")])\n \n (define_split\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n@@ -2165,7 +2307,7 @@\n \t\t (const_int 0)))]\n   \"\"\n   \"cmovlt %0,0,%0\"\n-  [(set_attr \"type\" \"cmov\")])\n+  [(set_attr \"type\" \"icmov\")])\n \n (define_expand \"smindi3\"\n   [(set (match_dup 3)\n@@ -2196,7 +2338,7 @@\n \t\t (const_int 0)))]\n   \"\"\n   \"cmovgt %0,0,%0\"\n-  [(set_attr \"type\" \"cmov\")])\n+  [(set_attr \"type\" \"icmov\")])\n \n (define_expand \"umaxdi3\"\n   [(set (match_dup 3) \n@@ -2389,7 +2531,7 @@\n   \"@\n    fcmov%C3 %R4,%R1,%0\n    fcmov%D3 %R4,%R5,%0\"\n-  [(set_attr \"type\" \"fadd\")])\n+  [(set_attr \"type\" \"fcmov\")])\n \n (define_insn \"\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f,f\")\n@@ -2403,7 +2545,7 @@\n   \"@\n    fcmov%C3 %R4,%R1,%0\n    fcmov%D3 %R4,%R5,%0\"\n-  [(set_attr \"type\" \"fadd\")])\n+  [(set_attr \"type\" \"fcmov\")])\n \n (define_insn \"\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=&f,f\")\n@@ -2417,7 +2559,7 @@\n   \"@\n    fcmov%C3 %R4,%R1,%0\n    fcmov%D3 %R4,%R5,%0\"\n-  [(set_attr \"type\" \"fadd\")])\n+  [(set_attr \"type\" \"fcmov\")])\n \n (define_insn \"\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f,f\")\n@@ -2431,7 +2573,7 @@\n   \"@\n    fcmov%C3 %R4,%R1,%0\n    fcmov%D3 %R4,%R5,%0\"\n-  [(set_attr \"type\" \"fadd\")])\n+  [(set_attr \"type\" \"fcmov\")])\n \n (define_insn \"\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f,f\")\n@@ -2445,7 +2587,7 @@\n   \"@\n    fcmov%C3 %R4,%R1,%0\n    fcmov%D3 %R4,%R5,%0\"\n-  [(set_attr \"type\" \"fadd\")])\n+  [(set_attr \"type\" \"fcmov\")])\n \n (define_insn \"\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f,f\")\n@@ -2460,7 +2602,7 @@\n   \"@\n    fcmov%C3 %R4,%R1,%0\n    fcmov%D3 %R4,%R5,%0\"\n-  [(set_attr \"type\" \"fadd\")])\n+  [(set_attr \"type\" \"fcmov\")])\n \n (define_insn \"\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f,f\")\n@@ -2475,7 +2617,7 @@\n   \"@\n    fcmov%C3 %R4,%R1,%0\n    fcmov%D3 %R4,%R5,%0\"\n-  [(set_attr \"type\" \"fadd\")])\n+  [(set_attr \"type\" \"fcmov\")])\n \n (define_insn \"\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f,f\")\n@@ -2490,7 +2632,7 @@\n   \"@\n    fcmov%C3 %R4,%R1,%0\n    fcmov%D3 %R4,%R5,%0\"\n-  [(set_attr \"type\" \"fadd\")])\n+  [(set_attr \"type\" \"fcmov\")])\n \n (define_expand \"maxdf3\"\n   [(set (match_dup 3)\n@@ -3687,7 +3829,7 @@\n ;; want to have to include pal.h in our .s file.\n ;;\n ;; Technically the type for call_pal is jsr, but we use that for determining\n-;; if we need a GP.  Use ibr instead since it has the same scheduling \n+;; if we need a GP.  Use ibr instead since it has the same EV5 scheduling\n ;; characteristics.\n (define_insn \"\"\n   [(unspec_volatile [(const_int 0)] 0)]\n@@ -3702,8 +3844,9 @@\n (define_insn \"\"\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=r,r,m,f,f,f,m\")\n \t(match_operand:SF 1 \"input_operand\" \"rG,m,rG,f,G,m,fG\"))]\n-  \"register_operand (operands[0], SFmode)\n-   || reg_or_fp0_operand (operands[1], SFmode)\"\n+  \"! TARGET_CIX\n+   && (register_operand (operands[0], SFmode)\n+       || reg_or_fp0_operand (operands[1], SFmode))\"\n   \"@\n    bis %r1,%r1,%0\n    ldl %0,%1\n@@ -3712,13 +3855,32 @@\n    cpys $f31,$f31,%0\n    ld%, %0,%1\n    st%, %R1,%0\"\n-  [(set_attr \"type\" \"ilog,ld,st,fcpys,fcpys,ld,st\")])\n+  [(set_attr \"type\" \"ilog,ild,ist,fcpys,fcpys,fld,fst\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=r,r,m,f,f,f,m,f,*r\")\n+\t(match_operand:SF 1 \"input_operand\" \"rG,m,rG,f,G,m,fG,r,*f\"))]\n+  \"TARGET_CIX\n+   && (register_operand (operands[0], SFmode)\n+       || reg_or_fp0_operand (operands[1], SFmode))\"\n+  \"@\n+   bis %r1,%r1,%0\n+   ldl %0,%1\n+   stl %r1,%0\n+   cpys %1,%1,%0\n+   cpys $f31,$f31,%0\n+   ld%, %0,%1\n+   st%, %R1,%0\n+   itofs %1,%0\n+   ftois %1,%0\"\n+  [(set_attr \"type\" \"ilog,ild,ist,fcpys,fcpys,fld,fst,itof,ftoi\")])\n \n (define_insn \"\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=r,r,m,f,f,f,m\")\n \t(match_operand:DF 1 \"input_operand\" \"rG,m,rG,f,G,m,fG\"))]\n-  \"register_operand (operands[0], DFmode)\n-   || reg_or_fp0_operand (operands[1], DFmode)\"\n+  \"! TARGET_CIX\n+   && (register_operand (operands[0], DFmode)\n+       || reg_or_fp0_operand (operands[1], DFmode))\"\n   \"@\n    bis %r1,%r1,%0\n    ldq %0,%1\n@@ -3727,7 +3889,25 @@\n    cpys $f31,$f31,%0\n    ld%- %0,%1\n    st%- %R1,%0\"\n-  [(set_attr \"type\" \"ilog,ld,st,fcpys,fcpys,ld,st\")])\n+  [(set_attr \"type\" \"ilog,ild,ist,fcpys,fcpys,fld,fst\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=r,r,m,f,f,f,m,f,*r\")\n+\t(match_operand:DF 1 \"input_operand\" \"rG,m,rG,f,G,m,fG,r,*f\"))]\n+  \"TARGET_CIX\n+   && (register_operand (operands[0], DFmode)\n+       || reg_or_fp0_operand (operands[1], DFmode))\"\n+  \"@\n+   bis %r1,%r1,%0\n+   ldq %0,%1\n+   stq %r1,%0\n+   cpys %1,%1,%0\n+   cpys $f31,$f31,%0\n+   ld%- %0,%1\n+   st%- %R1,%0\n+   itoft %1,%0\n+   ftoit %1,%0\"\n+  [(set_attr \"type\" \"ilog,ild,ist,fcpys,fcpys,fld,fst,itof,ftoi\")])\n \n (define_expand \"movsf\"\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"\")\n@@ -3769,11 +3949,11 @@\n    cpys $f31,$f31,%0\n    ld%, %0,%1\n    st%, %R1,%0\"\n-  [(set_attr \"type\" \"ilog,ilog,ilog,iadd,iadd,ld,st,fcpys,fcpys,ld,st\")])\n+  [(set_attr \"type\" \"ilog,ilog,ilog,iadd,iadd,ild,ist,fcpys,fcpys,fld,fst\")])\n \n (define_insn \"\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,r,r,r,r,m,f,f,f,m,r,f\")\n-\t(match_operand:SI 1 \"input_operand\" \"r,J,I,K,L,m,rJ,f,J,m,fG,f,r\"))]\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,r,r,r,r,m,f,f,f,m,r,*f\")\n+\t(match_operand:SI 1 \"input_operand\" \"r,J,I,K,L,m,rJ,f,J,m,fG,f,*r\"))]\n   \"! TARGET_WINDOWS_NT && ! TARGET_OPEN_VMS && TARGET_CIX\n    && (register_operand (operands[0], SImode)\n        || reg_or_0_operand (operands[1], SImode))\"\n@@ -3790,8 +3970,8 @@\n    ld%, %0,%1\n    st%, %R1,%0\n    ftois %1,%0\n-   itof%, %1,%0\"\n-  [(set_attr \"type\" \"ilog,ilog,ilog,iadd,iadd,ld,st,fcpys,fcpys,ld,st,ld,st\")])\n+   itofs %1,%0\"\n+  [(set_attr \"type\" \"ilog,ilog,ilog,iadd,iadd,ild,ist,fcpys,fcpys,fld,fst,ftoi,itof\")])\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,r,r,r,r,r,m,f,f,f,m\")\n@@ -3812,7 +3992,7 @@\n    cpys $f31,$f31,%0\n    ld%, %0,%1\n    st%, %R1,%0\"\n-  [(set_attr \"type\" \"ilog,ilog,ilog,iadd,iadd,ldsym,ld,st,fcpys,fcpys,ld,st\")])\n+  [(set_attr \"type\" \"ilog,ilog,ilog,iadd,iadd,ldsym,ild,ist,fcpys,fcpys,fld,fst\")])\n \n (define_insn \"\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r,r,r,r,f,f\")\n@@ -3844,7 +4024,7 @@\n    stw %r1,%0\n    cpys %1,%1,%0\n    cpys $f31,$f31,%0\"\n-  [(set_attr \"type\" \"ilog,ilog,ilog,iadd,ld,st,fcpys,fcpys\")])\n+  [(set_attr \"type\" \"ilog,ilog,ilog,iadd,ild,ist,fcpys,fcpys\")])\n \n (define_insn \"\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=r,r,r,r,f,f\")\n@@ -3876,7 +4056,7 @@\n    stb %r1,%0\n    cpys %1,%1,%0\n    cpys $f31,$f31,%0\"\n-  [(set_attr \"type\" \"ilog,ilog,ilog,iadd,ld,st,fcpys,fcpys\")])\n+  [(set_attr \"type\" \"ilog,ilog,ilog,iadd,ild,ist,fcpys,fcpys\")])\n \n ;; We do two major things here: handle mem->mem and construct long\n ;; constants.\n@@ -3940,11 +4120,11 @@\n    cpys $f31,$f31,%0\n    ldt %0,%1\n    stt %R1,%0\"\n-  [(set_attr \"type\" \"ilog,ilog,ilog,iadd,iadd,ldsym,ld,st,fcpys,fcpys,ld,st\")])\n+  [(set_attr \"type\" \"ilog,ilog,ilog,iadd,iadd,ldsym,ild,ist,fcpys,fcpys,fld,fst\")])\n \n (define_insn \"\"\n-  [(set (match_operand:DI 0 \"general_operand\" \"=r,r,r,r,r,r,r,m,f,f,f,Q,r,f\")\n-\t(match_operand:DI 1 \"input_operand\" \"r,J,I,K,L,s,m,rJ,f,J,Q,fG,f,r\"))]\n+  [(set (match_operand:DI 0 \"general_operand\" \"=r,r,r,r,r,r,r,m,f,f,f,Q,r,*f\")\n+\t(match_operand:DI 1 \"input_operand\" \"r,J,I,K,L,s,m,rJ,f,J,Q,fG,f,*r\"))]\n   \"TARGET_CIX\n    && (register_operand (operands[0], DImode)\n        || reg_or_0_operand (operands[1], DImode))\"\n@@ -3963,7 +4143,7 @@\n    stt %R1,%0\n    ftoit %1,%0\n    itoft %1,%0\"\n-  [(set_attr \"type\" \"ilog,ilog,ilog,iadd,iadd,ldsym,ld,st,fcpys,fcpys,ld,st,ld,st\")])\n+  [(set_attr \"type\" \"ilog,ilog,ilog,iadd,iadd,ldsym,ild,ist,fcpys,fcpys,fld,fst,ftoi,itof\")])\n \n ;; We do three major things here: handle mem->mem, put 64-bit constants in\n ;; memory, and construct long 32-bit constants."}, {"sha": "8655c0602bed38a785d57a3da87d3d9e2c8fe446", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 247, "deletions": 33, "changes": 280, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71d9b4930e37e7eb5ed886b36d5e6cd8f0c09812/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71d9b4930e37e7eb5ed886b36d5e6cd8f0c09812/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=71d9b4930e37e7eb5ed886b36d5e6cd8f0c09812", "patch": "@@ -318,12 +318,12 @@ static int address_used;\n static int length_used;\n static int num_delays;\n static int have_annul_true, have_annul_false;\n-static int num_units;\n+static int num_units, num_unit_opclasses;\n static int num_insn_ents;\n \n /* Used as operand to `operate_exp':  */\n \n-enum operator {PLUS_OP, MINUS_OP, POS_MINUS_OP, EQ_OP, OR_OP, MAX_OP, MIN_OP, RANGE_OP};\n+enum operator {PLUS_OP, MINUS_OP, POS_MINUS_OP, EQ_OP, OR_OP, ORX_OP, MAX_OP, MIN_OP, RANGE_OP};\n \n /* Stores, for each insn code, the number of constraint alternatives.  */\n \n@@ -381,7 +381,9 @@ static rtx check_attr_value\tPROTO((rtx, struct attr_desc *));\n static rtx convert_set_attr_alternative PROTO((rtx, int, int, int));\n static rtx convert_set_attr\tPROTO((rtx, int, int, int));\n static void check_defs\t\tPROTO((void));\n+#if 0\n static rtx convert_const_symbol_ref PROTO((rtx, struct attr_desc *));\n+#endif\n static rtx make_canonical\tPROTO((struct attr_desc *, rtx));\n static struct attr_value *get_attr_value PROTO((rtx, struct attr_desc *, int));\n static rtx copy_rtx_unchanging\tPROTO((rtx));\n@@ -447,6 +449,8 @@ static void write_eligible_delay PROTO((char *));\n static void write_function_unit_info PROTO((void));\n static void write_complex_function PROTO((struct function_unit *, char *,\n \t\t\t\t\t  char *));\n+static int write_expr_attr_cache PROTO((rtx, struct attr_desc *));\n+static void write_toplevel_expr\tPROTO((rtx));\n static int n_comma_elts\t\tPROTO((char *));\n static char *next_comma_elt\tPROTO((char **));\n static struct attr_desc *find_attr PROTO((char *, int));\n@@ -1052,7 +1056,7 @@ check_attr_test (exp, is_const)\n       /* These cases can't be simplified.  */\n       RTX_UNCHANGING_P (exp) = 1;\n       break;\n-\n+ \n     case LE:  case LT:  case GT:  case GE:\n     case LEU: case LTU: case GTU: case GEU:\n     case NE:  case EQ:\n@@ -1144,6 +1148,16 @@ check_attr_value (exp, attr)\n       XEXP (exp, 2) = check_attr_value (XEXP (exp, 2), attr);\n       break;\n \n+    case IOR:\n+    case AND:\n+      XEXP (exp, 0) = check_attr_value (XEXP (exp, 0), attr);\n+      XEXP (exp, 1) = check_attr_value (XEXP (exp, 1), attr);\n+      break;\n+\n+    case FFS:\n+      XEXP (exp, 0) = check_attr_value (XEXP (exp, 0), attr);\n+      break;\n+\n     case COND:\n       if (XVECLEN (exp, 0) % 2 != 0)\n \tfatal (\"First operand of COND must have even length\");\n@@ -1303,6 +1317,7 @@ check_defs ()\n     }\n }\n \f\n+#if 0\n /* Given a constant SYMBOL_REF expression, convert to a COND that\n    explicitly tests each enumerated value.  */\n \n@@ -1353,6 +1368,7 @@ convert_const_symbol_ref (exp, attr)\n \n   return condexp;\n }\n+#endif\n \f\n /* Given a valid expression for an attribute value, remove any IF_THEN_ELSE\n    expressions by converting them into a COND.  This removes cases from this\n@@ -1390,13 +1406,21 @@ make_canonical (attr, exp)\n \t This makes the COND something that won't be considered an arbitrary\n \t expression by walk_attr_value.  */\n       RTX_UNCHANGING_P (exp) = 1;\n+#if 0\n+      /* ??? Why do we do this?  With attribute values { A B C D E }, this\n+         tends to generate (!(x==A) && !(x==B) && !(x==C) && !(x==D)) rather\n+\t than (x==E). */\n       exp = convert_const_symbol_ref (exp, attr);\n       RTX_UNCHANGING_P (exp) = 1;\n       exp = check_attr_value (exp, attr);\n       /* Goto COND case since this is now a COND.  Note that while the\n          new expression is rescanned, all symbol_ref notes are marked as\n \t unchanging.  */\n       goto cond;\n+#else\n+      exp = check_attr_value (exp, attr);\n+      break;\n+#endif\n \n     case IF_THEN_ELSE:\n       newexp = rtx_alloc (COND);\n@@ -1634,6 +1658,7 @@ operate_exp (op, left, right)\n \t      break;\n \n \t    case OR_OP:\n+\t    case ORX_OP:\n \t      i = left_value | right_value;\n \t      break;\n \n@@ -1663,6 +1688,10 @@ operate_exp (op, left, right)\n \t      abort ();\n \t    }\n \n+\t  if (i == left_value)\n+\t    return left;\n+\t  if (i == right_value)\n+\t    return right;\n \t  return make_numeric_value (i);\n \t}\n       else if (GET_CODE (right) == IF_THEN_ELSE)\n@@ -1715,6 +1744,13 @@ operate_exp (op, left, right)\n \tfatal (\"Badly formed attribute value\");\n     }\n \n+  /* A hack to prevent expand_units from completely blowing up: ORX_OP does\n+     not associate through IF_THEN_ELSE.  */\n+  else if (op == ORX_OP && GET_CODE (right) == IF_THEN_ELSE)\n+    {\n+      return attr_rtx (IOR, left, right);\n+    }\n+\n   /* Otherwise, do recursion the other way.  */\n   else if (GET_CODE (left) == IF_THEN_ELSE)\n     {\n@@ -1857,18 +1893,48 @@ expand_units ()\n   newexp = rtx_alloc (IF_THEN_ELSE);\n   XEXP (newexp, 2) = make_numeric_value (0);\n \n-  /* Merge each function unit into the unit mask attributes.  */\n-  for (unit = units; unit; unit = unit->next)\n+  /* If we have just a few units, we may be all right expanding the whole\n+     thing.  But the expansion is 2**N in space on the number of opclasses,\n+     so we can't do this for very long -- Alpha and MIPS in particular have\n+     problems with this.  So in that situation, we fall back on an alternate\n+     implementation method.  */\n+#define NUM_UNITOP_CUTOFF 20\n+\n+  if (num_unit_opclasses < NUM_UNITOP_CUTOFF)\n     {\n-      XEXP (newexp, 0) = unit->condexp;\n-      XEXP (newexp, 1) = make_numeric_value (1 << unit->num);\n-      unitsmask = operate_exp (OR_OP, unitsmask, newexp);\n+      /* Merge each function unit into the unit mask attributes.  */\n+      for (unit = units; unit; unit = unit->next)\n+        {\n+          XEXP (newexp, 0) = unit->condexp;\n+          XEXP (newexp, 1) = make_numeric_value (1 << unit->num);\n+          unitsmask = operate_exp (OR_OP, unitsmask, newexp);\n+        }\n+    }\n+  else\n+    {\n+      /* Merge each function unit into the unit mask attributes.  */\n+      for (unit = units; unit; unit = unit->next)\n+        {\n+          XEXP (newexp, 0) = unit->condexp;\n+          XEXP (newexp, 1) = make_numeric_value (1 << unit->num);\n+          unitsmask = operate_exp (ORX_OP, unitsmask, attr_copy_rtx (newexp));\n+        }\n     }\n \n   /* Simplify the unit mask expression, encode it, and make an attribute\n      for the function_units_used function.  */\n   unitsmask = simplify_by_exploding (unitsmask);\n-  unitsmask = encode_units_mask (unitsmask);\n+\n+  if (num_unit_opclasses < NUM_UNITOP_CUTOFF)\n+    unitsmask = encode_units_mask (unitsmask);\n+  else\n+    {\n+      /* We can no longer encode unitsmask at compile time, so emit code to\n+         calculate it at runtime.  Rather, put a marker for where we'd do\n+\t the code, and actually output it in write_attr_get().  */\n+      unitsmask = attr_rtx (FFS, unitsmask);\n+    }\n+\n   make_internal_attr (\"*function_units_used\", unitsmask, 2);\n \n   /* Create an array of ops for each unit.  Add an extra unit for the\n@@ -2737,6 +2803,26 @@ evaluate_eq_attr (exp, value, insn_code, insn_index)\n       else\n \tnewexp = false_rtx;\n     }\n+  else if (GET_CODE (value) == SYMBOL_REF)\n+    {\n+      char *p, *string;\n+\n+      if (GET_CODE (exp) != EQ_ATTR)\n+\tabort();\n+\n+      string = (char *) alloca (2 + strlen (XSTR (exp, 0))\n+\t\t\t\t+ strlen (XSTR (exp, 1)));\n+      strcpy (string, XSTR (exp, 0));\n+      strcat (string, \"_\");\n+      strcat (string, XSTR (exp, 1));\n+      for (p = string; *p ; p++)\n+\tif (*p >= 'a' && *p <= 'z')\n+\t  *p -= 'a' - 'A';\n+      \n+      newexp = attr_rtx (EQ, value,\n+\t\t\t attr_rtx (SYMBOL_REF,\n+\t\t\t\t   attr_string(string, strlen(string))));\n+    }\n   else if (GET_CODE (value) == COND)\n     {\n       /* We construct an IOR of all the cases for which the requested attribute\n@@ -3694,7 +3780,7 @@ add_values_to_cover (dim)\n     abort ();\n   else if (nalt == dim->num_values)\n     ; /* Ok.  */\n-  else if (nalt * 2 < dim->num_values * 3)\n+  else if (nalt * 2 >= dim->num_values)\n     {\n       /* Most all the values of the attribute are used, so add all the unused\n \t values.  */\n@@ -4292,6 +4378,7 @@ gen_unit (def)\n   op->issue_delay = issue_delay;\n   op->next = unit->ops;\n   unit->ops = op;\n+  num_unit_opclasses++;\n \n   /* Set our issue expression based on whether or not an optional conflict\n      vector was specified.  */\n@@ -4319,14 +4406,18 @@ gen_unit (def)\n }\n \f\n /* Given a piece of RTX, print a C expression to test it's truth value.\n+\n    We use AND and IOR both for logical and bit-wise operations, so \n    interpret them as logical unless they are inside a comparison expression.\n-   The second operand of this function will be non-zero in that case.  */\n+   The first bit of FLAGS will be non-zero in that case.\n+\n+   Set the second bit of FLAGS to make references to attribute values use\n+   a cached local variable instead of calling a function.  */\n \n static void\n-write_test_expr (exp, in_comparison)\n+write_test_expr (exp, flags)\n      rtx exp;\n-     int in_comparison;\n+     int flags;\n {\n   int comparison_operator = 0;\n   RTX_CODE code;\n@@ -4348,7 +4439,7 @@ write_test_expr (exp, in_comparison)\n     case PLUS:   case MINUS:  case MULT:     case DIV:      case MOD:\n     case AND:    case IOR:    case XOR:\n     case ASHIFT: case LSHIFTRT: case ASHIFTRT:\n-      write_test_expr (XEXP (exp, 0), in_comparison || comparison_operator);\n+      write_test_expr (XEXP (exp, 0), flags | comparison_operator);\n       switch (code)\n         {\n \tcase EQ:\n@@ -4397,13 +4488,13 @@ write_test_expr (exp, in_comparison)\n \t  printf (\" %% \");\n \t  break;\n \tcase AND:\n-\t  if (in_comparison)\n+\t  if (flags & 1)\n \t    printf (\" & \");\n \t  else\n \t    printf (\" && \");\n \t  break;\n \tcase IOR:\n-\t  if (in_comparison)\n+\t  if (flags & 1)\n \t    printf (\" | \");\n \t  else\n \t    printf (\" || \");\n@@ -4422,12 +4513,12 @@ write_test_expr (exp, in_comparison)\n \t  abort ();\n         }\n \n-      write_test_expr (XEXP (exp, 1), in_comparison || comparison_operator);\n+      write_test_expr (XEXP (exp, 1), flags | comparison_operator);\n       break;\n \n     case NOT:\n       /* Special-case (not (eq_attrq \"alternative\" \"x\")) */\n-      if (! in_comparison && GET_CODE (XEXP (exp, 0)) == EQ_ATTR\n+      if (! (flags & 1) && GET_CODE (XEXP (exp, 0)) == EQ_ATTR\n \t  && XSTR (XEXP (exp, 0), 0) == alternative_name)\n \t{\n \t  printf (\"which_alternative != %s\", XSTR (XEXP (exp, 0), 1));\n@@ -4441,7 +4532,7 @@ write_test_expr (exp, in_comparison)\n       switch (code)\n \t{\n \tcase NOT:\n-\t  if (in_comparison)\n+\t  if (flags & 1)\n \t    printf (\"~ \");\n \t  else\n \t    printf (\"! \");\n@@ -4456,14 +4547,14 @@ write_test_expr (exp, in_comparison)\n \t  abort ();\n \t}\n \n-      write_test_expr (XEXP (exp, 0), in_comparison);\n+      write_test_expr (XEXP (exp, 0), flags);\n       break;\n \n     /* Comparison test of an attribute with a value.  Most of these will\n        have been removed by optimization.   Handle \"alternative\"\n        specially and give error if EQ_ATTR present inside a comparison.  */\n     case EQ_ATTR:\n-      if (in_comparison)\n+      if (flags & 1)\n \tfatal (\"EQ_ATTR not valid inside comparison\");\n \n       if (XSTR (exp, 0) == alternative_name)\n@@ -4480,18 +4571,22 @@ write_test_expr (exp, in_comparison)\n \t{\n \t  write_test_expr (evaluate_eq_attr (exp, attr->default_val->value,\n \t\t\t\t\t     -2, -2),\n-\t\t\t   in_comparison);\n+\t\t\t   flags);\n \t}\n       else\n \t{\n-\t  printf (\"get_attr_%s (insn) == \", attr->name);\n-\t  write_attr_valueq (attr, XSTR (exp, 1)); \n+\t  if (flags & 2)\n+\t    printf (\"attr_%s\", attr->name);\n+\t  else\n+\t    printf (\"get_attr_%s (insn)\", attr->name);\n+\t  printf (\" == \");\n+\t  write_attr_valueq (attr, XSTR (exp, 1));\n \t}\n       break;\n \n     /* Comparison test of flags for define_delays.  */\n     case ATTR_FLAG:\n-      if (in_comparison)\n+      if (flags & 1)\n \tfatal (\"ATTR_FLAG not valid inside comparison\");\n       printf (\"(flags & ATTR_FLAG_%s) != 0\", XSTR (exp, 0));\n       break;\n@@ -4541,6 +4636,18 @@ write_test_expr (exp, in_comparison)\n       printf (\"insn_current_address\");\n       break;\n \n+    case CONST_STRING:\n+      printf (\"%s\", XSTR (exp, 0));\n+      break;\n+\n+    case IF_THEN_ELSE:\n+      write_test_expr (XEXP (exp, 0), flags & 2);\n+      printf (\" ? \");\n+      write_test_expr (XEXP (exp, 1), flags | 1);\n+      printf (\" : \");\n+      write_test_expr (XEXP (exp, 2), flags | 1);\n+      break;\n+\n     default:\n       fatal (\"bad RTX code `%s' in attribute calculation\\n\",\n \t     GET_RTX_NAME (code));\n@@ -4707,17 +4814,40 @@ write_attr_get (attr)\n       printf (\"}\\n\\n\");\n       return;\n     }\n+\n   printf (\"     rtx insn;\\n\");\n   printf (\"{\\n\");\n-  printf (\"  switch (recog_memoized (insn))\\n\");\n-  printf (\"    {\\n\");\n \n-  for (av = attr->first_value; av; av = av->next)\n-    if (av != common_av)\n-      write_attr_case (attr, av, 1, \"return\", \";\", 4, true_rtx);\n+  if (GET_CODE (common_av->value) == FFS)\n+    {\n+      rtx p = XEXP (common_av->value, 0);\n \n-  write_attr_case (attr, common_av, 0, \"return\", \";\", 4, true_rtx);\n-  printf (\"    }\\n}\\n\\n\");\n+      /* No need to emit code to abort if the insn is unrecognized; the \n+         other get_attr_foo functions will do that when we call them.  */\n+\n+      write_toplevel_expr (p);\n+\n+      printf (\"\\n  if (accum && accum == (accum & -accum))\\n\");\n+      printf (\"    {\\n\");\n+      printf (\"      int i;\\n\");\n+      printf (\"      for (i = 0; accum >>= 1; ++i) continue;\\n\");\n+      printf (\"      accum = i;\\n\");\n+      printf (\"    }\\n  else\\n\");\n+      printf (\"    accum = ~accum;\\n\");\n+      printf (\"  return accum;\\n}\\n\\n\");\n+    }\n+  else\n+    {\n+      printf (\"  switch (recog_memoized (insn))\\n\");\n+      printf (\"    {\\n\");\n+\n+      for (av = attr->first_value; av; av = av->next)\n+\tif (av != common_av)\n+\t  write_attr_case (attr, av, 1, \"return\", \";\", 4, true_rtx);\n+\n+      write_attr_case (attr, common_av, 0, \"return\", \";\", 4, true_rtx);\n+      printf (\"    }\\n}\\n\\n\");\n+    }\n }\n \f\n /* Given an AND tree of known true terms (because we are inside an `if' with\n@@ -4927,6 +5057,90 @@ write_attr_case (attr, av, write_case_lines, prefix, suffix, indent,\n   printf (\"\\n\");\n }\n \f\n+/* Search for uses of non-const attributes and write code to cache them.  */\n+\n+static int\n+write_expr_attr_cache (p, attr)\n+     rtx p;\n+     struct attr_desc *attr;\n+{\n+  char *fmt;\n+  int i, ie, j, je;\n+\n+  if (GET_CODE (p) == EQ_ATTR)\n+    {\n+      if (XSTR (p, 0) != attr->name)\n+\treturn 0;\n+\n+      if (!attr->is_numeric)\n+\tprintf (\"  register enum attr_%s \", attr->name);\n+      else if (attr->unsigned_p)\n+\tprintf (\"  register unsigned int \");\n+      else\n+\tprintf (\"  register int \");\n+\n+      printf (\"attr_%s = get_attr_%s (insn);\\n\", attr->name, attr->name);\n+      return 1;\n+    }\n+\n+  fmt = GET_RTX_FORMAT (GET_CODE (p));\n+  ie = GET_RTX_LENGTH (GET_CODE (p));\n+  for (i = 0; i < ie; i++)\n+    {\n+      switch (*fmt++)\n+\t{\n+\tcase 'e':\n+\t  if (write_expr_attr_cache (XEXP (p, i), attr))\n+\t    return 1;\n+\t  break;\n+\n+\tcase 'E':\n+\t  je = XVECLEN (p, i);\n+\t  for (j = 0; j < je; ++j)\n+\t    if (write_expr_attr_cache (XVECEXP (p, i, j), attr))\n+\t      return 1;\n+\t  break;\n+\t}\n+    }\n+\n+  return 0;\n+}\n+\n+/* Evaluate an expression at top level.  A front end to write_test_expr,\n+   in which we cache attribute values and break up excessively large\n+   expressions to cater to older compilers.  */\n+\n+static void\n+write_toplevel_expr (p)\n+     rtx p;\n+{\n+  struct attr_desc *attr;\n+  int i;\n+\n+  for (i = 0; i < MAX_ATTRS_INDEX; ++i)\n+    for (attr = attrs[i]; attr ; attr = attr->next)\n+      if (!attr->is_const)\n+\twrite_expr_attr_cache (p, attr);\n+\n+  printf(\"  register unsigned long accum = 0;\\n\\n\");\n+\n+  while (GET_CODE (p) == IOR)\n+    {\n+      rtx e;\n+      if (GET_CODE (XEXP (p, 0)) == IOR)\n+\te = XEXP (p, 1), p = XEXP (p, 0);\n+      else\n+\te = XEXP (p, 0), p = XEXP (p, 1);\n+\n+      printf (\"  accum |= \");\n+      write_test_expr (e, 3);\n+      printf (\";\\n\");\n+    }\n+  printf (\"  accum |= \");\n+  write_test_expr (p, 3);\n+  printf (\";\\n\");\n+}\n+\f\n /* Utilities to write names in various forms.  */\n \n static void\n@@ -5735,7 +5949,7 @@ from the machine description file `md'.  */\\n\\n\");\n   for (i = 0; i < MAX_ATTRS_INDEX; i++)\n     for (attr = attrs[i]; attr; attr = attr->next)\n       {\n-\tif (! attr->is_special)\n+\tif (! attr->is_special && ! attr->is_const)\n \t  write_attr_get (attr);\n       }\n "}]}