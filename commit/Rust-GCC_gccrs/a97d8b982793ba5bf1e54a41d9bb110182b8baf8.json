{"sha": "a97d8b982793ba5bf1e54a41d9bb110182b8baf8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTk3ZDhiOTgyNzkzYmE1YmYxZTU0YTQxZDliYjExMDE4MmI4YmFmOA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-12-21T06:57:04Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-12-21T06:57:04Z"}, "message": "[AArch64] Tweak aarch64_classify_address interface\n\nPreviously aarch64_classify_address used an rtx code to distinguish\nLDP/STP addresses from normal addresses; the code was PARALLEL\nto select LDP/STP and anything else to select normal addresses.\nThis patch replaces that parameter with a dedicated enum.\n\nThe SVE port will add another enum value that didn't map naturally\nto an rtx code.\n\n2017-12-21  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* config/aarch64/aarch64-protos.h (aarch64_addr_query_type): New enum.\n\t(aarch64_legitimate_address_p): Use it instead of an rtx code,\n\tas an optional final parameter.\n\t* config/aarch64/aarch64.c (aarch64_classify_address): Likewise.\n\t(aarch64_legitimate_address_p): Likewise.\n\t(aarch64_print_address_internal): Take an aarch64_addr_query_type\n\tinstead of an rtx code.\n\t(aarch64_address_valid_for_prefetch_p): Update calls accordingly.\n\t(aarch64_legitimate_address_hook_p): Likewise.\n\t(aarch64_print_ldpstp_address): Likewise.\n\t(aarch64_print_operand_address): Likewise.\n\t(aarch64_address_cost): Likewise.\n\t* config/aarch64/constraints.md (Uml, Umq, Ump, Utq): Likewise.\n\t* config/aarch64/predicates.md (aarch64_mem_pair_operand): Likewise.\n\t(aarch64_mem_pair_lanes_operand): Likewise.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r255911", "tree": {"sha": "62aaefa775450b5e1cecb47fd10b0360dec12e5a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/62aaefa775450b5e1cecb47fd10b0360dec12e5a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a97d8b982793ba5bf1e54a41d9bb110182b8baf8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a97d8b982793ba5bf1e54a41d9bb110182b8baf8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a97d8b982793ba5bf1e54a41d9bb110182b8baf8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a97d8b982793ba5bf1e54a41d9bb110182b8baf8/comments", "author": null, "committer": null, "parents": [{"sha": "75b7462e1ac607a9107ef8a158dafdef0728f01d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75b7462e1ac607a9107ef8a158dafdef0728f01d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75b7462e1ac607a9107ef8a158dafdef0728f01d"}], "stats": {"total": 96, "additions": 65, "deletions": 31}, "files": [{"sha": "adb02ee10e147f4072678801e6e589088fba0162", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a97d8b982793ba5bf1e54a41d9bb110182b8baf8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a97d8b982793ba5bf1e54a41d9bb110182b8baf8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a97d8b982793ba5bf1e54a41d9bb110182b8baf8", "patch": "@@ -1,3 +1,23 @@\n+2017-12-21  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* config/aarch64/aarch64-protos.h (aarch64_addr_query_type): New enum.\n+\t(aarch64_legitimate_address_p): Use it instead of an rtx code,\n+\tas an optional final parameter.\n+\t* config/aarch64/aarch64.c (aarch64_classify_address): Likewise.\n+\t(aarch64_legitimate_address_p): Likewise.\n+\t(aarch64_print_address_internal): Take an aarch64_addr_query_type\n+\tinstead of an rtx code.\n+\t(aarch64_address_valid_for_prefetch_p): Update calls accordingly.\n+\t(aarch64_legitimate_address_hook_p): Likewise.\n+\t(aarch64_print_ldpstp_address): Likewise.\n+\t(aarch64_print_operand_address): Likewise.\n+\t(aarch64_address_cost): Likewise.\n+\t* config/aarch64/constraints.md (Uml, Umq, Ump, Utq): Likewise.\n+\t* config/aarch64/predicates.md (aarch64_mem_pair_operand): Likewise.\n+\t(aarch64_mem_pair_lanes_operand): Likewise.\n+\n 2017-12-20  Richard Biener  <rguenther@suse.de>\n \n \t* tree-ssa-dom.c (dom_opt_dom_walker::optimize_stmt): Call"}, {"sha": "002ac330c6da73a8de35ff1eefa787f7662b3027", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a97d8b982793ba5bf1e54a41d9bb110182b8baf8/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a97d8b982793ba5bf1e54a41d9bb110182b8baf8/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=a97d8b982793ba5bf1e54a41d9bb110182b8baf8", "patch": "@@ -111,6 +111,19 @@ enum aarch64_symbol_type\n   SYMBOL_FORCE_TO_MEM\n };\n \n+/* Classifies the type of an address query.\n+\n+   ADDR_QUERY_M\n+      Query what is valid for an \"m\" constraint and a memory_operand\n+      (the rules are the same for both).\n+\n+   ADDR_QUERY_LDP_STP\n+      Query what is valid for a load/store pair.  */\n+enum aarch64_addr_query_type {\n+  ADDR_QUERY_M,\n+  ADDR_QUERY_LDP_STP\n+};\n+\n /* A set of tuning parameters contains references to size and time\n    cost models and vectors for address cost calculations, register\n    move costs and memory move costs.  */\n@@ -440,7 +453,8 @@ bool aarch64_float_const_representable_p (rtx);\n \n #if defined (RTX_CODE)\n \n-bool aarch64_legitimate_address_p (machine_mode, rtx, RTX_CODE, bool);\n+bool aarch64_legitimate_address_p (machine_mode, rtx, bool,\n+\t\t\t\t   aarch64_addr_query_type = ADDR_QUERY_M);\n machine_mode aarch64_select_cc_mode (RTX_CODE, rtx, rtx);\n rtx aarch64_gen_compare_reg (RTX_CODE, rtx, rtx);\n rtx aarch64_load_tp (rtx);"}, {"sha": "fc27b4073dd88402ab6e7ab05f6cafacca256494", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a97d8b982793ba5bf1e54a41d9bb110182b8baf8/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a97d8b982793ba5bf1e54a41d9bb110182b8baf8/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=a97d8b982793ba5bf1e54a41d9bb110182b8baf8", "patch": "@@ -4437,21 +4437,21 @@ virt_or_elim_regno_p (unsigned regno)\n \t  || regno == ARG_POINTER_REGNUM);\n }\n \n-/* Return true if X is a valid address for machine mode MODE.  If it is,\n-   fill in INFO appropriately.  STRICT_P is true if REG_OK_STRICT is in\n-   effect.  OUTER_CODE is PARALLEL for a load/store pair.  */\n+/* Return true if X is a valid address of type TYPE for machine mode MODE.\n+   If it is, fill in INFO appropriately.  STRICT_P is true if\n+   REG_OK_STRICT is in effect.  */\n \n static bool\n aarch64_classify_address (struct aarch64_address_info *info,\n-\t\t\t  rtx x, machine_mode mode,\n-\t\t\t  RTX_CODE outer_code, bool strict_p)\n+\t\t\t  rtx x, machine_mode mode, bool strict_p,\n+\t\t\t  aarch64_addr_query_type type = ADDR_QUERY_M)\n {\n   enum rtx_code code = GET_CODE (x);\n   rtx op0, op1;\n \n   /* On BE, we use load/store pair for all large int mode load/stores.\n      TI/TFmode may also use a load/store pair.  */\n-  bool load_store_pair_p = (outer_code == PARALLEL\n+  bool load_store_pair_p = (type == ADDR_QUERY_LDP_STP\n \t\t\t    || mode == TImode\n \t\t\t    || mode == TFmode\n \t\t\t    || (BYTES_BIG_ENDIAN\n@@ -4683,7 +4683,7 @@ aarch64_address_valid_for_prefetch_p (rtx x, bool strict_p)\n   struct aarch64_address_info addr;\n \n   /* PRFM accepts the same addresses as DImode...  */\n-  bool res = aarch64_classify_address (&addr, x, DImode, MEM, strict_p);\n+  bool res = aarch64_classify_address (&addr, x, DImode, strict_p);\n   if (!res)\n     return false;\n \n@@ -4719,19 +4719,18 @@ aarch64_legitimate_address_hook_p (machine_mode mode, rtx x, bool strict_p)\n {\n   struct aarch64_address_info addr;\n \n-  return aarch64_classify_address (&addr, x, mode, MEM, strict_p);\n+  return aarch64_classify_address (&addr, x, mode, strict_p);\n }\n \n-/* Return TRUE if X is a legitimate address for accessing memory in\n-   mode MODE.  OUTER_CODE will be PARALLEL if this is a load/store\n-   pair operation.  */\n+/* Return TRUE if X is a legitimate address of type TYPE for accessing\n+   memory in mode MODE.  STRICT_P is true if REG_OK_STRICT is in effect.  */\n bool\n-aarch64_legitimate_address_p (machine_mode mode, rtx x,\n-\t\t\t      RTX_CODE outer_code, bool strict_p)\n+aarch64_legitimate_address_p (machine_mode mode, rtx x, bool strict_p,\n+\t\t\t      aarch64_addr_query_type type)\n {\n   struct aarch64_address_info addr;\n \n-  return aarch64_classify_address (&addr, x, mode, outer_code, strict_p);\n+  return aarch64_classify_address (&addr, x, mode, strict_p, type);\n }\n \n /* Split an out-of-range address displacement into a base and offset.\n@@ -5630,14 +5629,15 @@ aarch64_print_operand (FILE *f, rtx x, int code)\n    'op' is the context required by aarch64_classify_address.  It can either be\n    MEM for a normal memory access or PARALLEL for LDP/STP.  */\n static bool\n-aarch64_print_address_internal (FILE *f, machine_mode mode, rtx x, RTX_CODE op)\n+aarch64_print_address_internal (FILE *f, machine_mode mode, rtx x,\n+\t\t\t\taarch64_addr_query_type type)\n {\n   struct aarch64_address_info addr;\n \n   /* Check all addresses are Pmode - including ILP32.  */\n   gcc_assert (GET_MODE (x) == Pmode);\n \n-  if (aarch64_classify_address (&addr, x, mode, op, true))\n+  if (aarch64_classify_address (&addr, x, mode, true, type))\n     switch (addr.type)\n       {\n       case ADDRESS_REG_IMM:\n@@ -5725,14 +5725,14 @@ aarch64_print_address_internal (FILE *f, machine_mode mode, rtx x, RTX_CODE op)\n static bool\n aarch64_print_ldpstp_address (FILE *f, machine_mode mode, rtx x)\n {\n-  return aarch64_print_address_internal (f, mode, x, PARALLEL);\n+  return aarch64_print_address_internal (f, mode, x, ADDR_QUERY_LDP_STP);\n }\n \n /* Print address 'x' of a memory access with mode 'mode'.  */\n static void\n aarch64_print_operand_address (FILE *f, machine_mode mode, rtx x)\n {\n-  if (!aarch64_print_address_internal (f, mode, x, MEM))\n+  if (!aarch64_print_address_internal (f, mode, x, ADDR_QUERY_M))\n     output_addr_const (f, x);\n }\n \n@@ -6561,7 +6561,7 @@ aarch64_address_cost (rtx x,\n   int cost = 0;\n   info.shift = 0;\n \n-  if (!aarch64_classify_address (&info, x, mode, c, false))\n+  if (!aarch64_classify_address (&info, x, mode, false))\n     {\n       if (GET_CODE (x) == CONST || GET_CODE (x) == SYMBOL_REF)\n \t{"}, {"sha": "70ea3cde686914db4e0fc93819774b0b7ff17ee5", "filename": "gcc/config/aarch64/constraints.md", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a97d8b982793ba5bf1e54a41d9bb110182b8baf8/gcc%2Fconfig%2Faarch64%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a97d8b982793ba5bf1e54a41d9bb110182b8baf8/gcc%2Fconfig%2Faarch64%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fconstraints.md?ref=a97d8b982793ba5bf1e54a41d9bb110182b8baf8", "patch": "@@ -161,24 +161,24 @@\n    A memory address which uses a base register with an offset small enough for\n    a load/store pair operation in DI mode.\"\n    (and (match_code \"mem\")\n-\t(match_test \"aarch64_legitimate_address_p (DImode, XEXP (op, 0),\n-\t\t\t\t\t\t   PARALLEL, false)\")))\n+\t(match_test \"aarch64_legitimate_address_p (DImode, XEXP (op, 0), false,\n+\t\t\t\t\t\t   ADDR_QUERY_LDP_STP)\")))\n \n (define_memory_constraint \"Ump\"\n   \"@internal\n   A memory address suitable for a load/store pair operation.\"\n   (and (match_code \"mem\")\n        (match_test \"aarch64_legitimate_address_p (GET_MODE (op), XEXP (op, 0),\n-\t\t\t\t\t\t  PARALLEL, 1)\")))\n+\t\t\t\t\t\t  true, ADDR_QUERY_LDP_STP)\")))\n \n ;; Used for storing two 64-bit values in an AdvSIMD register using an STP\n ;; as a 128-bit vec_concat.\n (define_memory_constraint \"Uml\"\n   \"@internal\n   A memory address suitable for a load/store pair operation.\"\n   (and (match_code \"mem\")\n-       (match_test \"aarch64_legitimate_address_p (DFmode, XEXP (op, 0),\n-\t\t\t\t\t\t   PARALLEL, 1)\")))\n+       (match_test \"aarch64_legitimate_address_p (DFmode, XEXP (op, 0), 1,\n+\t\t\t\t\t\t  ADDR_QUERY_LDP_STP)\")))\n \n (define_memory_constraint \"Utv\"\n   \"@internal\n@@ -191,8 +191,8 @@\n   \"@internal\n    An address valid for loading or storing a 128-bit AdvSIMD register\"\n   (and (match_code \"mem\")\n-       (match_test \"aarch64_legitimate_address_p (V2DImode, XEXP (op, 0),\n-\t\t\t\t\t\t  MEM, 1)\")))\n+       (match_test \"aarch64_legitimate_address_p (V2DImode,\n+\t\t\t\t\t\t  XEXP (op, 0), 1)\")))\n \n (define_constraint \"Ufc\"\n   \"A floating point constant which can be used with an\\"}, {"sha": "d5593d1c8584f06b3900ec1de39fe9823d2808dc", "filename": "gcc/config/aarch64/predicates.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a97d8b982793ba5bf1e54a41d9bb110182b8baf8/gcc%2Fconfig%2Faarch64%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a97d8b982793ba5bf1e54a41d9bb110182b8baf8/gcc%2Fconfig%2Faarch64%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fpredicates.md?ref=a97d8b982793ba5bf1e54a41d9bb110182b8baf8", "patch": "@@ -186,15 +186,15 @@\n \n (define_predicate \"aarch64_mem_pair_operand\"\n   (and (match_code \"mem\")\n-       (match_test \"aarch64_legitimate_address_p (mode, XEXP (op, 0), PARALLEL,\n-\t\t\t\t\t       0)\")))\n+       (match_test \"aarch64_legitimate_address_p (mode, XEXP (op, 0), false,\n+\t\t\t\t\t\t  ADDR_QUERY_LDP_STP)\")))\n \n ;; Used for storing two 64-bit values in an AdvSIMD register using an STP\n ;; as a 128-bit vec_concat.\n (define_predicate \"aarch64_mem_pair_lanes_operand\"\n   (and (match_code \"mem\")\n-       (match_test \"aarch64_legitimate_address_p (DFmode, XEXP (op, 0),\n-\t\t\t\t\t\t   PARALLEL, 1)\")))\n+       (match_test \"aarch64_legitimate_address_p (DFmode, XEXP (op, 0), 1,\n+\t\t\t\t\t\t  ADDR_QUERY_LDP_STP)\")))\n \n (define_predicate \"aarch64_prefetch_operand\"\n   (match_test \"aarch64_address_valid_for_prefetch_p (op, false)\"))"}]}