{"sha": "904ac8577521b8152b97e9b549c1a1ca569a3d1f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTA0YWM4NTc3NTIxYjgxNTJiOTdlOWI1NDljMWExY2E1NjlhM2QxZg==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-12-05T18:47:22Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-12-05T18:47:22Z"}, "message": "c++: Distinguish unsatisfaction vs errors during satisfaction [PR97093]\n\nDuring satisfaction, the flag info.noisy() controls three things:\nwhether to diagnose ill-formed satisfaction (such as the satisfaction\nvalue of an atom being non-bool or non-constant); whether to diagnose\nunsatisfaction; and whether to bypass the satisfaction cache.\n\nThe flag turns out to be too coarse however, because in some cases we\nwant to diagnose ill-formed satisfaction (and bypass the satisfaction\ncache) but not diagnose unsatisfaction, for instance when replaying an\nerroneous satisfaction result from constraint_satisfaction_value,\nevaluate_concept_check and tsubst_nested_requirement.\n\nAnd when noisily evaluating a disjunction, we want to first evaluate its\nbranches noisily (bypassing the satisfaction cache) but suppress\nunsatisfaction diagnostics.  We currently work around this by instead\nfirst evaluating each branch quietly, but that means the recursive calls\nto satisfy_atom will use the satisfaction cache.\n\nTo fix this, this patch adds the info.diagnose_unsatisfaction_p() flag,\nwhich refines the info.noisy() flag as part of a new sat_info class that\nderives from subst_info.  During satisfaction, info.noisy() now controls\nwhether to diagnose ill-formed satisfaction, and\ninfo.diagnose_unsatisfaction_p() controls whether to additionally\ndiagnose unsatisfaction.  This enables us to address the above two\nissues straightforwardly.\n\nIncidentally, the change to satisfy_disjunction suppresses the ICE in\nthe PR97093 testcase because we no longer insert atoms into the\nsatisfaction cache that have been incorrectly re-normalized in\ndiagnose_nested_requirement (after losing the necessary template\ncontext).  But the underlying re-normalization issue remains, and will\nbe fixed in a subsequent patch.\n\ngcc/cp/ChangeLog:\n\n\tPR c++/97093\n\t* constraint.cc (struct sat_info): Define.\n\t(tsubst_nested_requirement): Pass a sat_info object to\n\tsatisfy_constraint.\n\t(satisfy_constraint_r): Take a sat_info argument instead of\n\tsubst_info.\n\t(satisfy_conjunction): Likewise.\n\t(satisfy_disjunction): Likewise.  Instead of first evaluating\n\teach branch quietly, evaluate each branch only with\n\tunsatisfaction diagnostics disabled.  Exit early if evaluation\n\tof a branch returns error_mark_node.\n\t(satisfy_atom): Take a sat_info argument instead of subst_info.\n\tFix a comment.  Check diagnose_unsatisfaction_p() instead of\n\tnoisy() before replaying a substitution failure.\n\t(satisfy_constraint): Take a sat_info argument instead of\n\tsubst_info.\n\t(satisfy_associated_constraints): Likewise.\n\t(satisfy_constraint_expression): Likewise.\n\t(satisfy_declaration_constraints): Likewise.\n\t(constraint_satisfaction_value): Likewise and adjust\n\taccordingly.  Fix formatting.\n\t(constraints_satisfied_p): Pass a sat_info object to\n\tconstraint_satisfaction_value.\n\t(evaluate_concept_check): Pass a sat_info object to\n\tsatisfy_constraint_expression.\n\t(diagnose_nested_requirement): Likewise.\n\t(diagnose_constraints): Pass an appropriate sat_info object to\n\tconstraint_satisfaction_value.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/97093\n\t* g++.dg/concepts/pr94252.C: Verify we no longer issue a\n\tspurious unsatisfaction note when diagnosing ill-formed\n\tsatisfaction.\n\t* g++.dg/cpp2a/concepts-requires18.C: No longer expect a\n\tspurious unsatisfaction diagnostic when evaluating the\n\tnested-requirement subst<void&> of a requires-expression that\n\tappears outside of a template.\n\t* g++.dg/cpp2a/concepts-requires21.C: Verify we no longer issue\n\ta spurious unsatisfaction note when evaluating a\n\tnested-requirement of a requires-expression that appears outside\n\tof a template.\n\t* g++.dg/cpp2a/concepts-nonbool3.C: New test.\n\t* g++.dg/cpp2a/concepts-pr97093.C: New test.", "tree": {"sha": "27d5a2361240316caea8b0f21a2ad06e8d441d37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/27d5a2361240316caea8b0f21a2ad06e8d441d37"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/904ac8577521b8152b97e9b549c1a1ca569a3d1f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/904ac8577521b8152b97e9b549c1a1ca569a3d1f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/904ac8577521b8152b97e9b549c1a1ca569a3d1f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/904ac8577521b8152b97e9b549c1a1ca569a3d1f/comments", "author": null, "committer": null, "parents": [{"sha": "4f47fca1d0fc2c6efef791d6dd115abd9d221733", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f47fca1d0fc2c6efef791d6dd115abd9d221733", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f47fca1d0fc2c6efef791d6dd115abd9d221733"}], "stats": {"total": 196, "additions": 142, "deletions": 54}, "files": [{"sha": "1117508837530edb15c1de2b6d75d04185c61a8c", "filename": "gcc/cp/constraint.cc", "status": "modified", "additions": 102, "deletions": 53, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/904ac8577521b8152b97e9b549c1a1ca569a3d1f/gcc%2Fcp%2Fconstraint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/904ac8577521b8152b97e9b549c1a1ca569a3d1f/gcc%2Fcp%2Fconstraint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstraint.cc?ref=904ac8577521b8152b97e9b549c1a1ca569a3d1f", "patch": "@@ -98,7 +98,42 @@ struct subst_info\n   tree in_decl;\n };\n \n-static tree satisfy_constraint (tree, tree, subst_info);\n+/* Provides additional context for satisfaction.\n+\n+   The flag noisy() controls whether to diagnose ill-formed satisfaction,\n+   such as the satisfaction value of an atom being non-bool or non-constant.\n+\n+   The flag diagnose_unsatisfaction_p() controls whether to explain why\n+   a constraint is not satisfied.\n+\n+   The entrypoints to satisfaction for which we set noisy+unsat are\n+   diagnose_constraints and diagnose_nested_requirement.  The entrypoints for\n+   which we set noisy-unsat are the replays inside constraint_satisfaction_value,\n+   evaluate_concept_check and tsubst_nested_requirement.  In other entrypoints,\n+   e.g. constraints_satisfied_p, we enter satisfaction quietly (both flags\n+   cleared).  */\n+\n+struct sat_info : subst_info\n+{\n+  sat_info (tsubst_flags_t cmp, tree in, bool diag_unsat = false)\n+    : subst_info (cmp, in), diagnose_unsatisfaction (diag_unsat)\n+  {\n+    if (diagnose_unsatisfaction_p ())\n+      gcc_checking_assert (noisy ());\n+  }\n+\n+  /* True if we should diagnose the cause of satisfaction failure.\n+     Implies noisy().  */\n+  bool\n+  diagnose_unsatisfaction_p () const\n+  {\n+    return diagnose_unsatisfaction;\n+  }\n+\n+  bool diagnose_unsatisfaction;\n+};\n+\n+static tree satisfy_constraint (tree, tree, sat_info);\n \n /* True if T is known to be some type other than bool. Note that this\n    is false for dependent types and errors.  */\n@@ -2059,10 +2094,11 @@ tsubst_nested_requirement (tree t, tree args, subst_info info)\n {\n   /* Ensure that we're in an evaluation context prior to satisfaction.  */\n   tree norm = TREE_TYPE (t);\n-  tree result = satisfy_constraint (norm, args, info);\n+  tree result = satisfy_constraint (norm, args,\n+\t\t\t\t    sat_info (info.complain, info.in_decl));\n   if (result == error_mark_node && info.quiet ())\n     {\n-      subst_info noisy (tf_warning_or_error, info.in_decl);\n+      sat_info noisy (tf_warning_or_error, info.in_decl);\n       satisfy_constraint (norm, args, noisy);\n     }\n   if (result != boolean_true_node)\n@@ -2499,12 +2535,12 @@ tsubst_constraint (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n   return expr;\n }\n \n-static tree satisfy_constraint_r (tree, tree, subst_info info);\n+static tree satisfy_constraint_r (tree, tree, sat_info info);\n \n /* Compute the satisfaction of a conjunction.  */\n \n static tree\n-satisfy_conjunction (tree t, tree args, subst_info info)\n+satisfy_conjunction (tree t, tree args, sat_info info)\n {\n   tree lhs = satisfy_constraint_r (TREE_OPERAND (t, 0), args, info);\n   if (lhs == error_mark_node || lhs == boolean_false_node)\n@@ -2558,20 +2594,25 @@ collect_operands_of_disjunction (tree t, auto_vec<tree_pair> *operands)\n /* Compute the satisfaction of a disjunction.  */\n \n static tree\n-satisfy_disjunction (tree t, tree args, subst_info info)\n+satisfy_disjunction (tree t, tree args, sat_info info)\n {\n-  /* Evaluate the operands quietly.  */\n-  subst_info quiet (tf_none, NULL_TREE);\n+  /* Evaluate each operand with unsatisfaction diagnostics disabled.  */\n+  sat_info sub = info;\n+  sub.diagnose_unsatisfaction = false;\n \n-  /* Register the constraint for diagnostics, if needed.  */\n-  diagnosing_failed_constraint failure (t, args, info.noisy ());\n+  tree lhs = satisfy_constraint_r (TREE_OPERAND (t, 0), args, sub);\n+  if (lhs == boolean_true_node || lhs == error_mark_node)\n+    return lhs;\n \n-  tree lhs = satisfy_constraint_r (TREE_OPERAND (t, 0), args, quiet);\n-  if (lhs == boolean_true_node)\n-    return boolean_true_node;\n-  tree rhs = satisfy_constraint_r (TREE_OPERAND (t, 1), args, quiet);\n-  if (rhs != boolean_true_node && info.noisy ())\n+  tree rhs = satisfy_constraint_r (TREE_OPERAND (t, 1), args, sub);\n+  if (rhs == boolean_true_node || rhs == error_mark_node)\n+    return rhs;\n+\n+  /* Both branches evaluated to false.  Explain the satisfaction failure in\n+     each branch.  */\n+  if (info.diagnose_unsatisfaction_p ())\n     {\n+      diagnosing_failed_constraint failure (t, args, info.noisy ());\n       cp_expr disj_expr = CONSTR_EXPR (t);\n       inform (disj_expr.get_location (),\n \t      \"no operand of the disjunction is satisfied\");\n@@ -2592,7 +2633,8 @@ satisfy_disjunction (tree t, tree args, subst_info info)\n \t    }\n \t}\n     }\n-  return rhs;\n+\n+  return boolean_false_node;\n }\n \n /* Ensures that T is a truth value and not (accidentally, as sometimes\n@@ -2673,7 +2715,7 @@ static void diagnose_atomic_constraint (tree, tree, tree, subst_info);\n /* Compute the satisfaction of an atomic constraint.  */\n \n static tree\n-satisfy_atom (tree t, tree args, subst_info info)\n+satisfy_atom (tree t, tree args, sat_info info)\n {\n   satisfaction_cache cache (t, args, info.complain);\n   if (tree r = cache.get ())\n@@ -2691,9 +2733,9 @@ satisfy_atom (tree t, tree args, subst_info info)\n   tree map = tsubst_parameter_mapping (ATOMIC_CONSTR_MAP (t), args, quiet);\n   if (map == error_mark_node)\n     {\n-      /* If instantiation of the parameter mapping fails, the program\n-         is ill-formed.  */\n-      if (info.noisy())\n+      /* If instantiation of the parameter mapping fails, the constraint is\n+\t not satisfied.  Replay the substitution.  */\n+      if (info.diagnose_unsatisfaction_p ())\n \ttsubst_parameter_mapping (ATOMIC_CONSTR_MAP (t), args, info);\n       return cache.save (boolean_false_node);\n     }\n@@ -2720,7 +2762,7 @@ satisfy_atom (tree t, tree args, subst_info info)\n     {\n       /* If substitution results in an invalid type or expression, the constraint\n \t is not satisfied. Replay the substitution.  */\n-      if (info.noisy ())\n+      if (info.diagnose_unsatisfaction_p ())\n \ttsubst_expr (expr, args, info.complain, info.in_decl, false);\n       return cache.save (inst_cache.save (boolean_false_node));\n     }\n@@ -2748,7 +2790,7 @@ satisfy_atom (tree t, tree args, subst_info info)\n \tresult = error_mark_node;\n     }\n   result = satisfaction_value (result);\n-  if (result == boolean_false_node && info.noisy ())\n+  if (result == boolean_false_node && info.diagnose_unsatisfaction_p ())\n     diagnose_atomic_constraint (t, map, result, info);\n \n   return cache.save (inst_cache.save (result));\n@@ -2766,7 +2808,7 @@ satisfy_atom (tree t, tree args, subst_info info)\n    constraint only matters for subsumption.  */\n \n static tree\n-satisfy_constraint_r (tree t, tree args, subst_info info)\n+satisfy_constraint_r (tree t, tree args, sat_info info)\n {\n   if (t == error_mark_node)\n     return error_mark_node;\n@@ -2787,7 +2829,7 @@ satisfy_constraint_r (tree t, tree args, subst_info info)\n /* Check that the normalized constraint T is satisfied for ARGS.  */\n \n static tree\n-satisfy_constraint (tree t, tree args, subst_info info)\n+satisfy_constraint (tree t, tree args, sat_info info)\n {\n   auto_timevar time (TV_CONSTRAINT_SAT);\n \n@@ -2805,7 +2847,7 @@ satisfy_constraint (tree t, tree args, subst_info info)\n    value (either true, false, or error).  */\n \n static tree\n-satisfy_associated_constraints (tree t, tree args, subst_info info)\n+satisfy_associated_constraints (tree t, tree args, sat_info info)\n {\n   /* If there are no constraints then this is trivially satisfied.  */\n   if (!t)\n@@ -2823,7 +2865,7 @@ satisfy_associated_constraints (tree t, tree args, subst_info info)\n    satisfaction value. */\n \n static tree\n-satisfy_constraint_expression (tree t, tree args, subst_info info)\n+satisfy_constraint_expression (tree t, tree args, sat_info info)\n {\n   if (t == error_mark_node)\n     return error_mark_node;\n@@ -2852,12 +2894,12 @@ satisfy_constraint_expression (tree t, tree args, subst_info info)\n tree\n satisfy_constraint_expression (tree expr)\n {\n-  subst_info info (tf_none, NULL_TREE);\n+  sat_info info (tf_none, NULL_TREE);\n   return satisfy_constraint_expression (expr, NULL_TREE, info);\n }\n \n static tree\n-satisfy_declaration_constraints (tree t, subst_info info)\n+satisfy_declaration_constraints (tree t, sat_info info)\n {\n   gcc_assert (DECL_P (t));\n   const tree saved_t = t;\n@@ -2917,7 +2959,7 @@ satisfy_declaration_constraints (tree t, subst_info info)\n }\n \n static tree\n-satisfy_declaration_constraints (tree t, tree args, subst_info info)\n+satisfy_declaration_constraints (tree t, tree args, sat_info info)\n {\n   /* Update the declaration for diagnostics.  */\n   info.in_decl = t;\n@@ -2942,36 +2984,40 @@ satisfy_declaration_constraints (tree t, tree args, subst_info info)\n }\n \n static tree\n-constraint_satisfaction_value (tree t, tsubst_flags_t complain)\n+constraint_satisfaction_value (tree t, sat_info info)\n {\n-  subst_info info (complain, NULL_TREE);\n   tree r;\n   if (DECL_P (t))\n     r = satisfy_declaration_constraints (t, info);\n   else\n     r = satisfy_constraint_expression (t, NULL_TREE, info);\n   if (r == error_mark_node && info.quiet ()\n       && !(DECL_P (t) && TREE_NO_WARNING (t)))\n-      {\n-\tconstraint_satisfaction_value (t, tf_warning_or_error);\n-\tif (DECL_P (t))\n-\t  /* Avoid giving these errors again.  */\n-\t  TREE_NO_WARNING (t) = true;\n-      }\n+    {\n+      /* Replay the error with re-normalized requirements.  */\n+      sat_info noisy (tf_warning_or_error, info.in_decl);\n+      constraint_satisfaction_value (t, noisy);\n+      if (DECL_P (t))\n+\t/* Avoid giving these errors again.  */\n+\tTREE_NO_WARNING (t) = true;\n+    }\n   return r;\n }\n \n static tree\n-constraint_satisfaction_value (tree t, tree args, tsubst_flags_t complain)\n+constraint_satisfaction_value (tree t, tree args, sat_info info)\n {\n-  subst_info info (complain, NULL_TREE);\n   tree r;\n   if (DECL_P (t))\n     r = satisfy_declaration_constraints (t, args, info);\n   else\n     r = satisfy_constraint_expression (t, args, info);\n   if (r == error_mark_node && info.quiet ())\n-    constraint_satisfaction_value (t, args, tf_warning_or_error);\n+    {\n+      /* Replay the error with re-normalized requirements.  */\n+      sat_info noisy (tf_warning_or_error, info.in_decl);\n+      constraint_satisfaction_value (t, args, noisy);\n+    }\n   return r;\n }\n \n@@ -2984,7 +3030,8 @@ constraints_satisfied_p (tree t)\n   if (!flag_concepts)\n     return true;\n \n-  return constraint_satisfaction_value (t, tf_none) == boolean_true_node;\n+  sat_info quiet (tf_none, NULL_TREE);\n+  return constraint_satisfaction_value (t, quiet) == boolean_true_node;\n }\n \n /* True iff the result of satisfying T with ARGS is BOOLEAN_TRUE_NODE\n@@ -2996,7 +3043,8 @@ constraints_satisfied_p (tree t, tree args)\n   if (!flag_concepts)\n     return true;\n \n-  return constraint_satisfaction_value (t, args, tf_none) == boolean_true_node;\n+  sat_info quiet (tf_none, NULL_TREE);\n+  return constraint_satisfaction_value (t, args, quiet) == boolean_true_node;\n }\n \n /* Evaluate a concept check of the form C<ARGS>. This is only used for the\n@@ -3011,14 +3059,14 @@ evaluate_concept_check (tree check, tsubst_flags_t complain)\n   gcc_assert (concept_check_p (check));\n \n   /* Check for satisfaction without diagnostics.  */\n-  subst_info quiet (tf_none, NULL_TREE);\n+  sat_info quiet (tf_none, NULL_TREE);\n   tree result = satisfy_constraint_expression (check, NULL_TREE, quiet);\n   if (result == error_mark_node && (complain & tf_error))\n-  {\n-    /* Replay the error with re-normalized requirements.  */\n-    subst_info noisy (tf_warning_or_error, NULL_TREE);\n-    satisfy_constraint_expression (check, NULL_TREE, noisy);\n-  }\n+    {\n+      /* Replay the error with re-normalized requirements.  */\n+      sat_info noisy (tf_warning_or_error, NULL_TREE);\n+      satisfy_constraint_expression (check, NULL_TREE, noisy);\n+    }\n   return result;\n }\n \n@@ -3496,7 +3544,7 @@ diagnose_nested_requirement (tree req, tree args)\n   /* Quietly check for satisfaction first. We can elaborate details\n      later if needed.  */\n   tree norm = TREE_TYPE (req);\n-  subst_info info (tf_none, NULL_TREE);\n+  sat_info info (tf_none, NULL_TREE);\n   tree result = satisfy_constraint (norm, args, info);\n   if (result == boolean_true_node)\n     return;\n@@ -3507,7 +3555,7 @@ diagnose_nested_requirement (tree req, tree args)\n     {\n       /* Replay the substitution error.  */\n       inform (loc, \"nested requirement %qE is not satisfied, because\", expr);\n-      subst_info noisy (tf_warning_or_error, NULL_TREE);\n+      sat_info noisy (tf_warning_or_error, NULL_TREE, /*diag_unsat=*/true);\n       satisfy_constraint_expression (expr, args, noisy);\n     }\n   else\n@@ -3651,11 +3699,12 @@ diagnose_constraints (location_t loc, tree t, tree args)\n   if (concepts_diagnostics_max_depth == 0)\n     return;\n \n-  /* Replay satisfaction, but diagnose errors.  */\n+  /* Replay satisfaction, but diagnose unsatisfaction.  */\n+  sat_info noisy (tf_warning_or_error, NULL_TREE, /*diag_unsat=*/true);\n   if (!args)\n-    constraint_satisfaction_value (t, tf_warning_or_error);\n+    constraint_satisfaction_value (t, noisy);\n   else\n-    constraint_satisfaction_value (t, args, tf_warning_or_error);\n+    constraint_satisfaction_value (t, args, noisy);\n \n   static bool suggested_p;\n   if (concepts_diagnostics_max_depth_exceeded_p"}, {"sha": "b0457037ede4e0a53a29394c5c7df53424b98967", "filename": "gcc/testsuite/g++.dg/concepts/pr94252.C", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/904ac8577521b8152b97e9b549c1a1ca569a3d1f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr94252.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/904ac8577521b8152b97e9b549c1a1ca569a3d1f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr94252.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fpr94252.C?ref=904ac8577521b8152b97e9b549c1a1ca569a3d1f", "patch": "@@ -16,6 +16,7 @@ static_assert(requires(S o, int i) {\n \n template<typename T>\n   concept c = requires (T t) { requires (T)5; }; // { dg-error \"has type .int.\" }\n+// { dg-bogus \"not satisfied\" \"\" { target *-*-* } .-1 }\n \n int\n foo()"}, {"sha": "2a2af54847b286abf58ddb8380435fc8c58c8c36", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-nonbool3.C", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/904ac8577521b8152b97e9b549c1a1ca569a3d1f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-nonbool3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/904ac8577521b8152b97e9b549c1a1ca569a3d1f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-nonbool3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-nonbool3.C?ref=904ac8577521b8152b97e9b549c1a1ca569a3d1f", "patch": "@@ -0,0 +1,5 @@\n+// { dg-do compile { target c++20 } }\n+\n+template <auto V> concept C = false || V || false; // { dg-error \"has type 'int'\" }\n+template <auto V> int f() requires C<V>;\n+int a = f<0>(); // { dg-error \"no match\" }"}, {"sha": "d662552614e5216388059f3922a5ccc5c0517917", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr97093.C", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/904ac8577521b8152b97e9b549c1a1ca569a3d1f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr97093.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/904ac8577521b8152b97e9b549c1a1ca569a3d1f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr97093.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr97093.C?ref=904ac8577521b8152b97e9b549c1a1ca569a3d1f", "patch": "@@ -0,0 +1,32 @@\n+// PR c++/97093\n+// { dg-do compile { target c++20 } }\n+// { dg-additional-options \"-fconcepts-diagnostics-depth=3 --param=hash-table-verification-limit=10000\" }\n+\n+template <typename T>\n+concept C =  requires (T t)\n+{\n+  requires t.some_const < 2 || requires { t.some_fn (); };\n+};\n+\n+template <unsigned, unsigned>\n+struct c\n+{};\n+\n+template <typename T>\n+concept P = requires (T t, c <0, 1> v) { { t (v) }; }; // { dg-error \"no match\" }\n+\n+template <P auto, P auto ...>\n+struct m\n+{\n+  constexpr auto operator () (C auto) const\n+  {};\n+};\n+\n+struct pc\n+{\n+  constexpr auto operator () (C auto) const\n+  {};\n+};\n+\n+constexpr auto cc = pc {};\n+constexpr auto mmcc = m <cc> {}; // { dg-error \"not satisfied\" }"}, {"sha": "9e45c5869172578695a1c953bce826ff9afee618", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-requires18.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/904ac8577521b8152b97e9b549c1a1ca569a3d1f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires18.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/904ac8577521b8152b97e9b549c1a1ca569a3d1f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires18.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires18.C?ref=904ac8577521b8152b97e9b549c1a1ca569a3d1f", "patch": "@@ -4,7 +4,7 @@ template<typename T>\n concept integer = __is_same_as(T, int);\n \n template<typename T>\n-concept subst = requires (T x) { requires true; }; // { dg-error \"parameter type .void.\" }\n+concept subst = requires (T x) { requires true; };\n \n template<typename T>\n concept c1 = requires { requires integer<T> || subst<T&>; }; // { dg-message \"in requirements\" }"}, {"sha": "8aead2fe2c53c714d41c28a0007911860f2f6b18", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-requires21.C", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/904ac8577521b8152b97e9b549c1a1ca569a3d1f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires21.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/904ac8577521b8152b97e9b549c1a1ca569a3d1f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires21.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires21.C?ref=904ac8577521b8152b97e9b549c1a1ca569a3d1f", "patch": "@@ -5,3 +5,4 @@ template<typename T, typename U>\n constexpr bool is_same_v = __is_same (T, U);\n \n static_assert(is_same_v<bool, decltype(requires { requires false; })>);\n+// { dg-bogus \"evaluated to 'false\" \"\" { target *-*-* } .-1 }"}]}