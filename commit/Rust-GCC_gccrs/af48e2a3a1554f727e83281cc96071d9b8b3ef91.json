{"sha": "af48e2a3a1554f727e83281cc96071d9b8b3ef91", "node_id": "C_kwDOANBUbNoAKGFmNDhlMmEzYTE1NTRmNzI3ZTgzMjgxY2M5NjA3MWQ5YjhiM2VmOTE", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-04-28T09:16:03Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-04-28T09:16:03Z"}, "message": "Merge #1186\n\n1186: Refactor `ResolvePath` in its own file r=CohenArthur a=CohenArthur\n\n\n\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>", "tree": {"sha": "e34b1c2459b7f9bc94a65d86a4aee4e3d287d18f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e34b1c2459b7f9bc94a65d86a4aee4e3d287d18f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/af48e2a3a1554f727e83281cc96071d9b8b3ef91", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJialtTCRBK7hj4Ov3rIwAATTYIAAWwu7QLPisz062ZMw03Qw6A\nfbb4Hxy/MOIq/wTAQ7YiQwRMIQbPIP5WMediOGRlbPBqdrXXvD08xu/dEn4/xZ91\nE7+Uq6XPQoc8SK6A30XlLJXZ0O39tJhsRoRExzwsrf5MFmft02JlwmyRn6aEcaKF\neEqjej73PeiU3Oyq9WJOqvi069HmKzMRkqyoPUf5ksNbfz8BB8Q6IQG6QEXpfFlo\n+gsuOrKY/6tCeV57n2zIjvrc2XAo8dmk5Upwpsq9mVT+t5aFcWWAtk/W5TzBaGeP\nkbUaOrA7s1JNsn4oVUNTnstVS1rE0ZmX9sG5MUvBiJJAY+9EYkq5je7h/pK8+dM=\n=s+V0\n-----END PGP SIGNATURE-----\n", "payload": "tree e34b1c2459b7f9bc94a65d86a4aee4e3d287d18f\nparent 9a9bb44058a8406b41bb1ab3110e08a897772bb0\nparent 10b01c305ff73a9da40fb81b7f90312d1f79f037\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1651137363 +0000\ncommitter GitHub <noreply@github.com> 1651137363 +0000\n\nMerge #1186\n\n1186: Refactor `ResolvePath` in its own file r=CohenArthur a=CohenArthur\n\n\n\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af48e2a3a1554f727e83281cc96071d9b8b3ef91", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af48e2a3a1554f727e83281cc96071d9b8b3ef91", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af48e2a3a1554f727e83281cc96071d9b8b3ef91/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a9bb44058a8406b41bb1ab3110e08a897772bb0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a9bb44058a8406b41bb1ab3110e08a897772bb0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a9bb44058a8406b41bb1ab3110e08a897772bb0"}, {"sha": "10b01c305ff73a9da40fb81b7f90312d1f79f037", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10b01c305ff73a9da40fb81b7f90312d1f79f037", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10b01c305ff73a9da40fb81b7f90312d1f79f037"}], "stats": {"total": 594, "additions": 328, "deletions": 266}, "files": [{"sha": "f59deb847f85cc483ae4b16527b5aa96c00bd3a0", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af48e2a3a1554f727e83281cc96071d9b8b3ef91/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af48e2a3a1554f727e83281cc96071d9b8b3ef91/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=af48e2a3a1554f727e83281cc96071d9b8b3ef91", "patch": "@@ -91,6 +91,7 @@ GRS_OBJS = \\\n     rust/rust-ast-resolve-pattern.o \\\n     rust/rust-ast-resolve-expr.o \\\n     rust/rust-ast-resolve-type.o \\\n+    rust/rust-ast-resolve-path.o \\\n     rust/rust-hir-type-check.o \\\n     rust/rust-privacy-check.o \\\n     rust/rust-privacy-ctx.o \\"}, {"sha": "71af8c23205ebf7424e7fd77b551298e90a17ec0", "filename": "gcc/rust/resolve/rust-ast-resolve-expr.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af48e2a3a1554f727e83281cc96071d9b8b3ef91/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af48e2a3a1554f727e83281cc96071d9b8b3ef91/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.cc?ref=af48e2a3a1554f727e83281cc96071d9b8b3ef91", "patch": "@@ -22,6 +22,7 @@\n #include \"rust-ast-verify-assignee.h\"\n #include \"rust-ast-resolve-type.h\"\n #include \"rust-ast-resolve-pattern.h\"\n+#include \"rust-ast-resolve-path.h\"\n \n namespace Rust {\n namespace Resolver {"}, {"sha": "34a318d6d045c1cf881c16567107614176999677", "filename": "gcc/rust/resolve/rust-ast-resolve-expr.h", "status": "modified", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af48e2a3a1554f727e83281cc96071d9b8b3ef91/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af48e2a3a1554f727e83281cc96071d9b8b3ef91/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h?ref=af48e2a3a1554f727e83281cc96071d9b8b3ef91", "patch": "@@ -25,35 +25,6 @@\n namespace Rust {\n namespace Resolver {\n \n-class ResolvePath : public ResolverBase\n-{\n-  using Rust::Resolver::ResolverBase::visit;\n-\n-public:\n-  static void go (AST::PathInExpression *expr, NodeId parent)\n-  {\n-    ResolvePath resolver (parent);\n-    resolver.resolve_path (expr);\n-  }\n-\n-  static void go (AST::QualifiedPathInExpression *expr, NodeId parent)\n-  {\n-    ResolvePath resolver (parent);\n-    resolver.resolve_path (expr);\n-  }\n-\n-private:\n-  ResolvePath (NodeId parent) : ResolverBase (parent) {}\n-\n-  void resolve_path (AST::PathInExpression *expr);\n-\n-  void resolve_path (AST::QualifiedPathInExpression *expr);\n-\n-  void resolve_segments (CanonicalPath prefix, size_t offs,\n-\t\t\t std::vector<AST::PathExprSegment> &segs,\n-\t\t\t NodeId expr_node_id, Location expr_locus);\n-};\n-\n class ResolveExpr : public ResolverBase\n {\n   using Rust::Resolver::ResolverBase::visit;"}, {"sha": "7aec4f8a70eddb6233e6add5bb6c6ef81cbce5a1", "filename": "gcc/rust/resolve/rust-ast-resolve-path.cc", "status": "added", "additions": 276, "deletions": 0, "changes": 276, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af48e2a3a1554f727e83281cc96071d9b8b3ef91/gcc%2Frust%2Fresolve%2Frust-ast-resolve-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af48e2a3a1554f727e83281cc96071d9b8b3ef91/gcc%2Frust%2Fresolve%2Frust-ast-resolve-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-path.cc?ref=af48e2a3a1554f727e83281cc96071d9b8b3ef91", "patch": "@@ -0,0 +1,276 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-ast-resolve-path.h\"\n+#include \"rust-ast-resolve-type.h\"\n+#include \"rust-path.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+void\n+ResolvePath::go (AST::PathInExpression *expr, NodeId parent)\n+{\n+  ResolvePath resolver (parent);\n+  resolver.resolve_path (expr);\n+}\n+\n+void\n+ResolvePath::go (AST::QualifiedPathInExpression *expr, NodeId parent)\n+{\n+  ResolvePath resolver (parent);\n+  resolver.resolve_path (expr);\n+}\n+\n+void\n+ResolvePath::resolve_path (AST::PathInExpression *expr)\n+{\n+  // resolve root segment first then apply segments in turn\n+  std::vector<AST::PathExprSegment> &segs = expr->get_segments ();\n+  AST::PathExprSegment &root_segment = segs.at (0);\n+  AST::PathIdentSegment &root_ident_seg = root_segment.get_ident_segment ();\n+\n+  bool segment_is_type = false;\n+  CanonicalPath root_seg_path\n+    = CanonicalPath::new_seg (root_segment.get_node_id (),\n+\t\t\t      root_ident_seg.as_string ());\n+\n+  // name scope first\n+  if (resolver->get_name_scope ().lookup (root_seg_path, &resolved_node))\n+    {\n+      segment_is_type = false;\n+      resolver->insert_resolved_name (root_segment.get_node_id (),\n+\t\t\t\t      resolved_node);\n+      resolver->insert_new_definition (root_segment.get_node_id (),\n+\t\t\t\t       Definition{expr->get_node_id (),\n+\t\t\t\t\t\t  parent});\n+    }\n+  // check the type scope\n+  else if (resolver->get_type_scope ().lookup (root_seg_path, &resolved_node))\n+    {\n+      segment_is_type = true;\n+      resolver->insert_resolved_type (root_segment.get_node_id (),\n+\t\t\t\t      resolved_node);\n+      resolver->insert_new_definition (root_segment.get_node_id (),\n+\t\t\t\t       Definition{expr->get_node_id (),\n+\t\t\t\t\t\t  parent});\n+    }\n+  else\n+    {\n+      rust_error_at (expr->get_locus (),\n+\t\t     \"Cannot find path %<%s%> in this scope\",\n+\t\t     root_segment.as_string ().c_str ());\n+      return;\n+    }\n+\n+  if (root_segment.has_generic_args ())\n+    {\n+      bool ok = ResolveTypeToCanonicalPath::type_resolve_generic_args (\n+\troot_segment.get_generic_args ());\n+      if (!ok)\n+\t{\n+\t  rust_error_at (root_segment.get_locus (),\n+\t\t\t \"failed to resolve generic arguments\");\n+\t  return;\n+\t}\n+    }\n+\n+  bool is_single_segment = segs.size () == 1;\n+  if (is_single_segment)\n+    {\n+      if (segment_is_type)\n+\tresolver->insert_resolved_type (expr->get_node_id (), resolved_node);\n+      else\n+\tresolver->insert_resolved_name (expr->get_node_id (), resolved_node);\n+\n+      resolver->insert_new_definition (expr->get_node_id (),\n+\t\t\t\t       Definition{expr->get_node_id (),\n+\t\t\t\t\t\t  parent});\n+      return;\n+    }\n+\n+  resolve_segments (root_seg_path, 1, expr->get_segments (),\n+\t\t    expr->get_node_id (), expr->get_locus ());\n+}\n+\n+void\n+ResolvePath::resolve_path (AST::QualifiedPathInExpression *expr)\n+{\n+  AST::QualifiedPathType &root_segment = expr->get_qualified_path_type ();\n+\n+  bool canonicalize_type_with_generics = false;\n+  ResolveType::go (&root_segment.get_as_type_path (),\n+\t\t   root_segment.get_node_id (),\n+\t\t   canonicalize_type_with_generics);\n+\n+  ResolveType::go (root_segment.get_type ().get (), root_segment.get_node_id (),\n+\t\t   canonicalize_type_with_generics);\n+\n+  bool type_resolve_generic_args = true;\n+  CanonicalPath impl_type_seg\n+    = ResolveTypeToCanonicalPath::resolve (*root_segment.get_type ().get (),\n+\t\t\t\t\t   canonicalize_type_with_generics,\n+\t\t\t\t\t   type_resolve_generic_args);\n+\n+  CanonicalPath trait_type_seg\n+    = ResolveTypeToCanonicalPath::resolve (root_segment.get_as_type_path (),\n+\t\t\t\t\t   canonicalize_type_with_generics,\n+\t\t\t\t\t   type_resolve_generic_args);\n+  CanonicalPath root_seg_path\n+    = TraitImplProjection::resolve (root_segment.get_node_id (), trait_type_seg,\n+\t\t\t\t    impl_type_seg);\n+  bool segment_is_type = false;\n+\n+  // name scope first\n+  if (resolver->get_name_scope ().lookup (root_seg_path, &resolved_node))\n+    {\n+      segment_is_type = false;\n+      resolver->insert_resolved_name (root_segment.get_node_id (),\n+\t\t\t\t      resolved_node);\n+      resolver->insert_new_definition (root_segment.get_node_id (),\n+\t\t\t\t       Definition{expr->get_node_id (),\n+\t\t\t\t\t\t  parent});\n+    }\n+  // check the type scope\n+  else if (resolver->get_type_scope ().lookup (root_seg_path, &resolved_node))\n+    {\n+      segment_is_type = true;\n+      resolver->insert_resolved_type (root_segment.get_node_id (),\n+\t\t\t\t      resolved_node);\n+      resolver->insert_new_definition (root_segment.get_node_id (),\n+\t\t\t\t       Definition{expr->get_node_id (),\n+\t\t\t\t\t\t  parent});\n+    }\n+  else\n+    {\n+      rust_error_at (expr->get_locus (),\n+\t\t     \"Cannot find path %<%s%> in this scope\",\n+\t\t     root_segment.as_string ().c_str ());\n+      return;\n+    }\n+\n+  bool is_single_segment = expr->get_segments ().empty ();\n+  if (is_single_segment)\n+    {\n+      if (segment_is_type)\n+\tresolver->insert_resolved_type (expr->get_node_id (), resolved_node);\n+      else\n+\tresolver->insert_resolved_name (expr->get_node_id (), resolved_node);\n+\n+      resolver->insert_new_definition (expr->get_node_id (),\n+\t\t\t\t       Definition{expr->get_node_id (),\n+\t\t\t\t\t\t  parent});\n+      return;\n+    }\n+\n+  resolve_segments (root_seg_path, 0, expr->get_segments (),\n+\t\t    expr->get_node_id (), expr->get_locus ());\n+}\n+\n+void\n+ResolvePath::resolve_segments (CanonicalPath prefix, size_t offs,\n+\t\t\t       std::vector<AST::PathExprSegment> &segs,\n+\t\t\t       NodeId expr_node_id, Location expr_locus)\n+{\n+  // we can attempt to resolve this path fully\n+  CanonicalPath path = prefix;\n+  bool segment_is_type = false;\n+  for (size_t i = offs; i < segs.size (); i++)\n+    {\n+      AST::PathExprSegment &seg = segs.at (i);\n+      auto s = ResolvePathSegmentToCanonicalPath::resolve (seg);\n+      path = path.append (s);\n+\n+      // reset state\n+      segment_is_type = false;\n+      resolved_node = UNKNOWN_NODEID;\n+\n+      if (resolver->get_name_scope ().lookup (path, &resolved_node))\n+\t{\n+\t  resolver->insert_resolved_name (seg.get_node_id (), resolved_node);\n+\t  resolver->insert_new_definition (seg.get_node_id (),\n+\t\t\t\t\t   Definition{expr_node_id, parent});\n+\t}\n+      // check the type scope\n+      else if (resolver->get_type_scope ().lookup (path, &resolved_node))\n+\t{\n+\t  segment_is_type = true;\n+\t  resolver->insert_resolved_type (seg.get_node_id (), resolved_node);\n+\t  resolver->insert_new_definition (seg.get_node_id (),\n+\t\t\t\t\t   Definition{expr_node_id, parent});\n+\t}\n+      else\n+\t{\n+\t  // attempt to fully resolve the path which is allowed to fail given\n+\t  // the following scenario\n+\t  //\n+\t  // https://github.com/Rust-GCC/gccrs/issues/355 Paths are\n+\t  // resolved fully here, there are limitations though imagine:\n+\t  //\n+\t  // struct Foo<A> (A);\n+\t  //\n+\t  // impl Foo<isize> {\n+\t  //    fn test() -> ...\n+\t  //\n+\t  // impl Foo<f32> {\n+\t  //    fn test() -> ...\n+\t  //\n+\t  // fn main() {\n+\t  //    let a:i32 = Foo::test();\n+\t  //\n+\t  // there are multiple paths that test can resolve to Foo::<?>::test\n+\t  // here so we cannot resolve this case\n+\t  //\n+\t  // canonical names:\n+\t  //\n+\t  // struct Foo<A>            -> Foo\n+\t  // impl Foo<isize>::fn test -> Foo::isize::test\n+\t  // impl Foo<f32>::fn test   -> Foo::f32::test\n+\t  //\n+\t  // Since there is the case we have the following paths for test:\n+\t  //\n+\t  // Foo::isize::test\n+\t  // Foo::f32::test\n+\t  // vs\n+\t  // Foo::test\n+\t  //\n+\t  // but the lookup was simply Foo::test we must rely on type resolution\n+\t  // to figure this type out in a similar fashion to method resolution\n+\t  // with a probe phase\n+\n+\t  // nothing more we can do we need the type resolver to try and resolve\n+\t  // this\n+\t  return;\n+\t}\n+    }\n+\n+  // its fully resolved lets mark it as such\n+  if (resolved_node != UNKNOWN_NODEID)\n+    {\n+      if (segment_is_type)\n+\tresolver->insert_resolved_type (expr_node_id, resolved_node);\n+      else\n+\tresolver->insert_resolved_name (expr_node_id, resolved_node);\n+\n+      resolver->insert_new_definition (expr_node_id,\n+\t\t\t\t       Definition{expr_node_id, parent});\n+    }\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "7a4413b8ca14c11edf09dd73b33c3798c164bf41", "filename": "gcc/rust/resolve/rust-ast-resolve-path.h", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af48e2a3a1554f727e83281cc96071d9b8b3ef91/gcc%2Frust%2Fresolve%2Frust-ast-resolve-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af48e2a3a1554f727e83281cc96071d9b8b3ef91/gcc%2Frust%2Fresolve%2Frust-ast-resolve-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-path.h?ref=af48e2a3a1554f727e83281cc96071d9b8b3ef91", "patch": "@@ -0,0 +1,49 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_RESOLVE_PATH_H\n+#define RUST_AST_RESOLVE_PATH_H\n+\n+#include \"rust-ast-resolve-base.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class ResolvePath : public ResolverBase\n+{\n+  using Rust::Resolver::ResolverBase::visit;\n+\n+public:\n+  static void go (AST::PathInExpression *expr, NodeId parent);\n+  static void go (AST::QualifiedPathInExpression *expr, NodeId parent);\n+\n+private:\n+  ResolvePath (NodeId parent) : ResolverBase (parent) {}\n+\n+  void resolve_path (AST::PathInExpression *expr);\n+  void resolve_path (AST::QualifiedPathInExpression *expr);\n+\n+  void resolve_segments (CanonicalPath prefix, size_t offs,\n+\t\t\t std::vector<AST::PathExprSegment> &segs,\n+\t\t\t NodeId expr_node_id, Location expr_locus);\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // !RUST_AST_RESOLVE_PATH_H"}, {"sha": "bac55212f48856357872924f66a3787505e13a01", "filename": "gcc/rust/resolve/rust-ast-resolve-pattern.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af48e2a3a1554f727e83281cc96071d9b8b3ef91/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af48e2a3a1554f727e83281cc96071d9b8b3ef91/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.cc?ref=af48e2a3a1554f727e83281cc96071d9b8b3ef91", "patch": "@@ -17,6 +17,7 @@\n // <http://www.gnu.org/licenses/>.\n \n #include \"rust-ast-resolve-pattern.h\"\n+#include \"rust-ast-resolve-path.h\"\n #include \"rust-ast-resolve-expr.h\"\n \n namespace Rust {"}, {"sha": "6da560946b29388448cfac1be178425d03ca86af", "filename": "gcc/rust/resolve/rust-ast-resolve.cc", "status": "modified", "additions": 0, "deletions": 237, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af48e2a3a1554f727e83281cc96071d9b8b3ef91/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af48e2a3a1554f727e83281cc96071d9b8b3ef91/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc?ref=af48e2a3a1554f727e83281cc96071d9b8b3ef91", "patch": "@@ -122,243 +122,6 @@ ResolveStructExprField::visit (AST::StructExprFieldIdentifier &field)\n   ResolveExpr::go (&expr, field.get_node_id (), prefix, canonical_prefix);\n }\n \n-// rust-ast-resolve-expr.h\n-\n-void\n-ResolvePath::resolve_path (AST::PathInExpression *expr)\n-{\n-  // resolve root segment first then apply segments in turn\n-  std::vector<AST::PathExprSegment> &segs = expr->get_segments ();\n-  AST::PathExprSegment &root_segment = segs.at (0);\n-  AST::PathIdentSegment &root_ident_seg = root_segment.get_ident_segment ();\n-\n-  bool segment_is_type = false;\n-  CanonicalPath root_seg_path\n-    = CanonicalPath::new_seg (root_segment.get_node_id (),\n-\t\t\t      root_ident_seg.as_string ());\n-\n-  // name scope first\n-  if (resolver->get_name_scope ().lookup (root_seg_path, &resolved_node))\n-    {\n-      segment_is_type = false;\n-      resolver->insert_resolved_name (root_segment.get_node_id (),\n-\t\t\t\t      resolved_node);\n-      resolver->insert_new_definition (root_segment.get_node_id (),\n-\t\t\t\t       Definition{expr->get_node_id (),\n-\t\t\t\t\t\t  parent});\n-    }\n-  // check the type scope\n-  else if (resolver->get_type_scope ().lookup (root_seg_path, &resolved_node))\n-    {\n-      segment_is_type = true;\n-      resolver->insert_resolved_type (root_segment.get_node_id (),\n-\t\t\t\t      resolved_node);\n-      resolver->insert_new_definition (root_segment.get_node_id (),\n-\t\t\t\t       Definition{expr->get_node_id (),\n-\t\t\t\t\t\t  parent});\n-    }\n-  else\n-    {\n-      rust_error_at (expr->get_locus (),\n-\t\t     \"Cannot find path %<%s%> in this scope\",\n-\t\t     root_segment.as_string ().c_str ());\n-      return;\n-    }\n-\n-  if (root_segment.has_generic_args ())\n-    {\n-      bool ok = ResolveTypeToCanonicalPath::type_resolve_generic_args (\n-\troot_segment.get_generic_args ());\n-      if (!ok)\n-\t{\n-\t  rust_error_at (root_segment.get_locus (),\n-\t\t\t \"failed to resolve generic arguments\");\n-\t  return;\n-\t}\n-    }\n-\n-  bool is_single_segment = segs.size () == 1;\n-  if (is_single_segment)\n-    {\n-      if (segment_is_type)\n-\tresolver->insert_resolved_type (expr->get_node_id (), resolved_node);\n-      else\n-\tresolver->insert_resolved_name (expr->get_node_id (), resolved_node);\n-\n-      resolver->insert_new_definition (expr->get_node_id (),\n-\t\t\t\t       Definition{expr->get_node_id (),\n-\t\t\t\t\t\t  parent});\n-      return;\n-    }\n-\n-  resolve_segments (root_seg_path, 1, expr->get_segments (),\n-\t\t    expr->get_node_id (), expr->get_locus ());\n-}\n-\n-void\n-ResolvePath::resolve_path (AST::QualifiedPathInExpression *expr)\n-{\n-  AST::QualifiedPathType &root_segment = expr->get_qualified_path_type ();\n-\n-  bool canonicalize_type_with_generics = false;\n-  ResolveType::go (&root_segment.get_as_type_path (),\n-\t\t   root_segment.get_node_id (),\n-\t\t   canonicalize_type_with_generics);\n-\n-  ResolveType::go (root_segment.get_type ().get (), root_segment.get_node_id (),\n-\t\t   canonicalize_type_with_generics);\n-\n-  bool type_resolve_generic_args = true;\n-  CanonicalPath impl_type_seg\n-    = ResolveTypeToCanonicalPath::resolve (*root_segment.get_type ().get (),\n-\t\t\t\t\t   canonicalize_type_with_generics,\n-\t\t\t\t\t   type_resolve_generic_args);\n-\n-  CanonicalPath trait_type_seg\n-    = ResolveTypeToCanonicalPath::resolve (root_segment.get_as_type_path (),\n-\t\t\t\t\t   canonicalize_type_with_generics,\n-\t\t\t\t\t   type_resolve_generic_args);\n-  CanonicalPath root_seg_path\n-    = TraitImplProjection::resolve (root_segment.get_node_id (), trait_type_seg,\n-\t\t\t\t    impl_type_seg);\n-  bool segment_is_type = false;\n-\n-  // name scope first\n-  if (resolver->get_name_scope ().lookup (root_seg_path, &resolved_node))\n-    {\n-      segment_is_type = false;\n-      resolver->insert_resolved_name (root_segment.get_node_id (),\n-\t\t\t\t      resolved_node);\n-      resolver->insert_new_definition (root_segment.get_node_id (),\n-\t\t\t\t       Definition{expr->get_node_id (),\n-\t\t\t\t\t\t  parent});\n-    }\n-  // check the type scope\n-  else if (resolver->get_type_scope ().lookup (root_seg_path, &resolved_node))\n-    {\n-      segment_is_type = true;\n-      resolver->insert_resolved_type (root_segment.get_node_id (),\n-\t\t\t\t      resolved_node);\n-      resolver->insert_new_definition (root_segment.get_node_id (),\n-\t\t\t\t       Definition{expr->get_node_id (),\n-\t\t\t\t\t\t  parent});\n-    }\n-  else\n-    {\n-      rust_error_at (expr->get_locus (),\n-\t\t     \"Cannot find path %<%s%> in this scope\",\n-\t\t     root_segment.as_string ().c_str ());\n-      return;\n-    }\n-\n-  bool is_single_segment = expr->get_segments ().empty ();\n-  if (is_single_segment)\n-    {\n-      if (segment_is_type)\n-\tresolver->insert_resolved_type (expr->get_node_id (), resolved_node);\n-      else\n-\tresolver->insert_resolved_name (expr->get_node_id (), resolved_node);\n-\n-      resolver->insert_new_definition (expr->get_node_id (),\n-\t\t\t\t       Definition{expr->get_node_id (),\n-\t\t\t\t\t\t  parent});\n-      return;\n-    }\n-\n-  resolve_segments (root_seg_path, 0, expr->get_segments (),\n-\t\t    expr->get_node_id (), expr->get_locus ());\n-}\n-\n-void\n-ResolvePath::resolve_segments (CanonicalPath prefix, size_t offs,\n-\t\t\t       std::vector<AST::PathExprSegment> &segs,\n-\t\t\t       NodeId expr_node_id, Location expr_locus)\n-{\n-  // we can attempt to resolve this path fully\n-  CanonicalPath path = prefix;\n-  bool segment_is_type = false;\n-  for (size_t i = offs; i < segs.size (); i++)\n-    {\n-      AST::PathExprSegment &seg = segs.at (i);\n-      auto s = ResolvePathSegmentToCanonicalPath::resolve (seg);\n-      path = path.append (s);\n-\n-      // reset state\n-      segment_is_type = false;\n-      resolved_node = UNKNOWN_NODEID;\n-\n-      if (resolver->get_name_scope ().lookup (path, &resolved_node))\n-\t{\n-\t  resolver->insert_resolved_name (seg.get_node_id (), resolved_node);\n-\t  resolver->insert_new_definition (seg.get_node_id (),\n-\t\t\t\t\t   Definition{expr_node_id, parent});\n-\t}\n-      // check the type scope\n-      else if (resolver->get_type_scope ().lookup (path, &resolved_node))\n-\t{\n-\t  segment_is_type = true;\n-\t  resolver->insert_resolved_type (seg.get_node_id (), resolved_node);\n-\t  resolver->insert_new_definition (seg.get_node_id (),\n-\t\t\t\t\t   Definition{expr_node_id, parent});\n-\t}\n-      else\n-\t{\n-\t  // attempt to fully resolve the path which is allowed to fail given\n-\t  // the following scenario\n-\t  //\n-\t  // https://github.com/Rust-GCC/gccrs/issues/355 Paths are\n-\t  // resolved fully here, there are limitations though imagine:\n-\t  //\n-\t  // struct Foo<A> (A);\n-\t  //\n-\t  // impl Foo<isize> {\n-\t  //    fn test() -> ...\n-\t  //\n-\t  // impl Foo<f32> {\n-\t  //    fn test() -> ...\n-\t  //\n-\t  // fn main() {\n-\t  //    let a:i32 = Foo::test();\n-\t  //\n-\t  // there are multiple paths that test can resolve to Foo::<?>::test\n-\t  // here so we cannot resolve this case\n-\t  //\n-\t  // canonical names:\n-\t  //\n-\t  // struct Foo<A>            -> Foo\n-\t  // impl Foo<isize>::fn test -> Foo::isize::test\n-\t  // impl Foo<f32>::fn test   -> Foo::f32::test\n-\t  //\n-\t  // Since there is the case we have the following paths for test:\n-\t  //\n-\t  // Foo::isize::test\n-\t  // Foo::f32::test\n-\t  // vs\n-\t  // Foo::test\n-\t  //\n-\t  // but the lookup was simply Foo::test we must rely on type resolution\n-\t  // to figure this type out in a similar fashion to method resolution\n-\t  // with a probe phase\n-\n-\t  // nothing more we can do we need the type resolver to try and resolve\n-\t  // this\n-\t  return;\n-\t}\n-    }\n-\n-  // its fully resolved lets mark it as such\n-  if (resolved_node != UNKNOWN_NODEID)\n-    {\n-      if (segment_is_type)\n-\tresolver->insert_resolved_type (expr_node_id, resolved_node);\n-      else\n-\tresolver->insert_resolved_name (expr_node_id, resolved_node);\n-\n-      resolver->insert_new_definition (expr_node_id,\n-\t\t\t\t       Definition{expr_node_id, parent});\n-    }\n-}\n-\n // rust-ast-resolve-item.h\n \n void"}]}