{"sha": "f26881e300b648e46ae89e24575fe493d772802f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjI2ODgxZTMwMGI2NDhlNDZhZTg5ZTI0NTc1ZmU0OTNkNzcyODAyZg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2017-10-31T16:27:59Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-10-31T16:27:59Z"}, "message": "[C++ PATCH] overloaded operator fns [3/N]\n\nhttps://gcc.gnu.org/ml/gcc-patches/2017-10/msg02343.html\n\t* cp-tree.h (enum ovl_op_flags): New.\n\t(struct operator_name_info_t): Rename arity to flags.\n\t* lex.c (set_operator_ident): New.\n\t(init_operators): Use it.  Adjust for flags.\n\t* mangle.c (write_unqualified_id): Adjust for flags.\n\t* operators.def: Replace arity with flags.\n\nFrom-SVN: r254271", "tree": {"sha": "676bf479638e840e2f2ed3e95577fa6e78227ce0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/676bf479638e840e2f2ed3e95577fa6e78227ce0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f26881e300b648e46ae89e24575fe493d772802f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f26881e300b648e46ae89e24575fe493d772802f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f26881e300b648e46ae89e24575fe493d772802f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f26881e300b648e46ae89e24575fe493d772802f/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5e36e11e2d3ba4cafa9e6523d161b7ffc9023672", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e36e11e2d3ba4cafa9e6523d161b7ffc9023672", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e36e11e2d3ba4cafa9e6523d161b7ffc9023672"}], "stats": {"total": 226, "additions": 126, "deletions": 100}, "files": [{"sha": "82651bf3237163e326075836c637ff1285a13068", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f26881e300b648e46ae89e24575fe493d772802f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f26881e300b648e46ae89e24575fe493d772802f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f26881e300b648e46ae89e24575fe493d772802f", "patch": "@@ -1,5 +1,12 @@\n 2017-10-31  Nathan Sidwell  <nathan@acm.org>\n \n+\t* cp-tree.h (enum ovl_op_flags): New.\n+\t(struct operator_name_info_t): Rename arity to flags.\n+\t* lex.c (set_operator_ident): New.\n+\t(init_operators): Use it.  Adjust for flags.\n+\t* mangle.c (write_unqualified_id): Adjust for flags.\n+\t* operators.def: Replace arity with flags.\n+\n \t* cp-tree.h (ovl_op_identifier): New.\n \t(assign_op_identifier, call_op_identifier): Adjust.\n \t(cp_operator_id, cp_assignment_operator_ide): Delete."}, {"sha": "c74a1860ec4d477cc99e1c4fe837825bf928b6d7", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f26881e300b648e46ae89e24575fe493d772802f/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f26881e300b648e46ae89e24575fe493d772802f/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=f26881e300b648e46ae89e24575fe493d772802f", "patch": "@@ -5474,16 +5474,27 @@ enum auto_deduction_context\n \n extern void init_reswords (void);\n \n-typedef struct GTY(()) operator_name_info_t {\n+/* Various flags for the overloaded operator information.  */\n+enum ovl_op_flags\n+  {\n+    OVL_OP_FLAG_NONE = 0,\n+    OVL_OP_FLAG_UNARY = 1,\n+    OVL_OP_FLAG_BINARY = 2,\n+    OVL_OP_FLAG_ALLOC = 4,  \t/* operator new or delete  */\n+    OVL_OP_FLAG_DELETE = 1,\t/* operator delete  */\n+    OVL_OP_FLAG_VEC = 2\t\t/* vector new or delete  */\n+  };\n+\n+struct GTY(()) operator_name_info_t {\n   /* The IDENTIFIER_NODE for the operator.  */\n   tree identifier;\n   /* The name of the operator.  */\n   const char *name;\n   /* The mangled name of the operator.  */\n   const char *mangled_name;\n-  /* The arity of the operator.  */\n-  int arity;\n-} operator_name_info_t;\n+  /* The ovl_op_flags of the operator */\n+  unsigned flags : 8;\n+};\n \n /* A mapping from tree codes to operator name information.  */\n extern GTY(()) operator_name_info_t operator_name_info"}, {"sha": "cd2d886b1eba176ffc966e24bbc3584fa60fa19d", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 27, "deletions": 22, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f26881e300b648e46ae89e24575fe493d772802f/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f26881e300b648e46ae89e24575fe493d772802f/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=f26881e300b648e46ae89e24575fe493d772802f", "patch": "@@ -82,13 +82,6 @@ operator_name_info_t operator_name_info[(int) MAX_TREE_CODES];\n /* Similar, but for assignment operators.  */\n operator_name_info_t assignment_operator_name_info[(int) MAX_TREE_CODES];\n \n-/* Initialize data structures that keep track of operator names.  */\n-\n-#define DEF_OPERATOR(NAME, C, M, AR, AP) \\\n- CONSTRAINT (C, sizeof \"operator \" + sizeof NAME <= 256);\n-#include \"operators.def\"\n-#undef DEF_OPERATOR\n-\n /* Get the name of the kind of identifier T.  */\n \n const char *\n@@ -120,28 +113,40 @@ set_identifier_kind (tree id, cp_identifier_kind kind)\n   IDENTIFIER_KIND_BIT_0 (id) |= (kind >> 0) & 1;\n }\n \n+/* Create and tag the internal operator name for the overloaded\n+   operator PTR describes.  */\n+\n+static tree\n+set_operator_ident (operator_name_info_t *ptr)\n+{\n+  char buffer[32];\n+  size_t len = snprintf (buffer, sizeof (buffer), \"operator%s%s\",\n+\t\t\t &\" \"[ptr->name[0] && ptr->name[0] != '_'\n+\t\t\t      && !ISALPHA (ptr->name[0])],\n+\t\t\t ptr->name);\n+  gcc_checking_assert (len < sizeof (buffer));\n+\n+  tree ident = get_identifier_with_length (buffer, len);\n+  ptr->identifier = ident;\n+\n+  return ident;\n+}\n+\n static void\n init_operators (void)\n {\n   tree identifier;\n-  char buffer[256];\n-  struct operator_name_info_t *oni;\n+  operator_name_info_t *oni;\n \n-#define DEF_OPERATOR(NAME, CODE, MANGLING, ARITY, KIND)\t\t\t\\\n-  sprintf (buffer, \"operator%s%s\", !NAME[0]\t\t\t\t\\\n-\t   || NAME[0] == '_' || ISALPHA (NAME[0]) ? \" \" : \"\", NAME);\t\\\n-  identifier = get_identifier (buffer);\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  if (KIND != cik_simple_op || !IDENTIFIER_ANY_OP_P (identifier))\t\\\n-    set_identifier_kind (identifier, KIND);\t\t\t\t\\\n-  \t\t\t\t\t\t\t\t\t\\\n-  oni = (KIND == cik_assign_op\t\t\t\t\t\t\\\n-\t ? &assignment_operator_name_info[(int) CODE]\t\t\t\\\n-\t : &operator_name_info[(int) CODE]);\t\t\t\t\\\n-  oni->identifier = identifier;\t\t\t\t\t\t\\\n+#define DEF_OPERATOR(NAME, CODE, MANGLING, FLAGS, KIND)\t\t\t\\\n+  oni = OVL_OP_INFO (KIND == cik_assign_op, CODE);\t\t\t\\\n   oni->name = NAME;\t\t\t\t\t\t\t\\\n   oni->mangled_name = MANGLING;\t\t\t\t\t\t\\\n-  oni->arity = ARITY;\n+  oni->flags = FLAGS;\t\t\t\t\t\t\t\\\n+  identifier = set_operator_ident (oni);\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  if (KIND != cik_simple_op || !IDENTIFIER_ANY_OP_P (identifier))\t\\\n+    set_identifier_kind (identifier, KIND);\n \n #include \"operators.def\"\n #undef DEF_OPERATOR"}, {"sha": "b745576cd330b783a708f0310a86005c01b4c68d", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f26881e300b648e46ae89e24575fe493d772802f/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f26881e300b648e46ae89e24575fe493d772802f/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=f26881e300b648e46ae89e24575fe493d772802f", "patch": "@@ -1276,7 +1276,7 @@ write_unqualified_id (tree identifier)\n \t  {\n \t    /* The ABI says that we prefer binary operator\n \t       names to unary operator names.  */\n-\t    if (operator_name_info[i].arity == 2)\n+\t    if (operator_name_info[i].flags == OVL_OP_FLAG_BINARY)\n \t      {\n \t\tmangled_name = operator_name_info[i].mangled_name;\n \t\tbreak;"}, {"sha": "51f746529432cfe5d943c80063caf82e07e4ae04", "filename": "gcc/cp/operators.def", "status": "modified", "additions": 76, "deletions": 73, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f26881e300b648e46ae89e24575fe493d772802f/gcc%2Fcp%2Foperators.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f26881e300b648e46ae89e24575fe493d772802f/gcc%2Fcp%2Foperators.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foperators.def?ref=f26881e300b648e46ae89e24575fe493d772802f", "patch": "@@ -45,11 +45,10 @@ along with GCC; see the file COPYING3.  If not see\n      mangled under the new ABI.  For `operator +', for example, this\n      would be \"pl\".\n \n-   ARITY\n+   FLAGS\n \n-     The arity of the operator, or -1 if any arity is allowed.  (As\n-     for `operator ()'.)  Postincrement and postdecrement operators\n-     are marked as binary.\n+     ovl_op_flags bits.  Postincrement and postdecrement operators are\n+     marked as binary.\n \n    ASSN_P\n \n@@ -66,95 +65,99 @@ along with GCC; see the file COPYING3.  If not see\n    arguments are as for DEF_OPERATOR, but there is no need to provide\n    an ASSIGNMENT_P argument; it is always zero.  */\n \n-#define DEF_SIMPLE_OPERATOR(NAME, CODE, MANGLING, ARITY) \\\n-  DEF_OPERATOR(NAME, CODE, MANGLING, ARITY, cik_simple_op)\n+#define DEF_SIMPLE_OPERATOR(NAME, CODE, MANGLING, FLAGS) \\\n+  DEF_OPERATOR(NAME, CODE, MANGLING, FLAGS, cik_simple_op)\n \n /* Use DEF_ASSN_OPERATOR to define an assignment operator.  Its\n    arguments are as for DEF_OPERATOR, but there is no need to provide\n    an ASSIGNMENT_P argument; it is always one.  */\n \n-#define DEF_ASSN_OPERATOR(NAME, CODE, MANGLING, ARITY) \\\n-  DEF_OPERATOR(NAME, CODE, MANGLING, ARITY, cik_assign_op)\n+#define DEF_ASSN_OPERATOR(NAME, CODE, MANGLING, FLAGS) \\\n+  DEF_OPERATOR(NAME, CODE, MANGLING, FLAGS, cik_assign_op)\n \n /* Memory allocation operators.  */\n-DEF_OPERATOR (\"new\", NEW_EXPR, \"nw\", -1, cik_newdel_op)\n-DEF_OPERATOR (\"new []\", VEC_NEW_EXPR, \"na\", -1, cik_newdel_op)\n-DEF_OPERATOR (\"delete\", DELETE_EXPR, \"dl\", -1, cik_newdel_op)\n-DEF_OPERATOR (\"delete []\", VEC_DELETE_EXPR, \"da\", -1, cik_newdel_op)\n+DEF_OPERATOR (\"new\", NEW_EXPR, \"nw\", OVL_OP_FLAG_ALLOC, cik_newdel_op)\n+DEF_OPERATOR (\"new []\", VEC_NEW_EXPR, \"na\",\n+\t      OVL_OP_FLAG_ALLOC | OVL_OP_FLAG_VEC, cik_newdel_op)\n+DEF_OPERATOR (\"delete\", DELETE_EXPR, \"dl\",\n+\t      OVL_OP_FLAG_ALLOC | OVL_OP_FLAG_DELETE, cik_newdel_op)\n+DEF_OPERATOR (\"delete []\", VEC_DELETE_EXPR, \"da\",\n+\t      OVL_OP_FLAG_ALLOC | OVL_OP_FLAG_DELETE | OVL_OP_FLAG_VEC,\n+\t      cik_newdel_op)\n \n /* Unary operators.  */\n-DEF_SIMPLE_OPERATOR (\"+\", UNARY_PLUS_EXPR, \"ps\", 1)\n-DEF_SIMPLE_OPERATOR (\"-\", NEGATE_EXPR, \"ng\", 1)\n-DEF_SIMPLE_OPERATOR (\"&\", ADDR_EXPR, \"ad\", 1)\n-DEF_SIMPLE_OPERATOR (\"*\", INDIRECT_REF, \"de\", 1)\n-DEF_SIMPLE_OPERATOR (\"~\", BIT_NOT_EXPR, \"co\", 1)\n-DEF_SIMPLE_OPERATOR (\"!\", TRUTH_NOT_EXPR, \"nt\", 1)\n-DEF_SIMPLE_OPERATOR (\"++\", PREINCREMENT_EXPR, \"pp\", 1)\n-DEF_SIMPLE_OPERATOR (\"--\", PREDECREMENT_EXPR, \"mm\", 1)\n-DEF_SIMPLE_OPERATOR (\"sizeof\", SIZEOF_EXPR, \"sz\", 1)\n+DEF_SIMPLE_OPERATOR (\"+\", UNARY_PLUS_EXPR, \"ps\", OVL_OP_FLAG_UNARY)\n+DEF_SIMPLE_OPERATOR (\"-\", NEGATE_EXPR, \"ng\", OVL_OP_FLAG_UNARY)\n+DEF_SIMPLE_OPERATOR (\"&\", ADDR_EXPR, \"ad\", OVL_OP_FLAG_UNARY)\n+DEF_SIMPLE_OPERATOR (\"*\", INDIRECT_REF, \"de\", OVL_OP_FLAG_UNARY)\n+DEF_SIMPLE_OPERATOR (\"~\", BIT_NOT_EXPR, \"co\", OVL_OP_FLAG_UNARY)\n+DEF_SIMPLE_OPERATOR (\"!\", TRUTH_NOT_EXPR, \"nt\", OVL_OP_FLAG_UNARY)\n+DEF_SIMPLE_OPERATOR (\"++\", PREINCREMENT_EXPR, \"pp\", OVL_OP_FLAG_UNARY)\n+DEF_SIMPLE_OPERATOR (\"--\", PREDECREMENT_EXPR, \"mm\", OVL_OP_FLAG_UNARY)\n+DEF_SIMPLE_OPERATOR (\"sizeof\", SIZEOF_EXPR, \"sz\", OVL_OP_FLAG_UNARY)\n /* These are extensions.  */\n-DEF_SIMPLE_OPERATOR (\"alignof\", ALIGNOF_EXPR, \"az\", 1)\n-DEF_SIMPLE_OPERATOR (\"__imag__\", IMAGPART_EXPR, \"v18__imag__\", 1)\n-DEF_SIMPLE_OPERATOR (\"__real__\", REALPART_EXPR, \"v18__real__\", 1)\n+DEF_SIMPLE_OPERATOR (\"alignof\", ALIGNOF_EXPR, \"az\", OVL_OP_FLAG_UNARY)\n+DEF_SIMPLE_OPERATOR (\"__imag__\", IMAGPART_EXPR, \"v18__imag__\", OVL_OP_FLAG_UNARY)\n+DEF_SIMPLE_OPERATOR (\"__real__\", REALPART_EXPR, \"v18__real__\", OVL_OP_FLAG_UNARY)\n \n /* The cast operators.  */\n-DEF_SIMPLE_OPERATOR (\"\", CAST_EXPR, \"cv\", 1)\n-DEF_SIMPLE_OPERATOR (\"dynamic_cast\", DYNAMIC_CAST_EXPR, \"dc\", 1)\n-DEF_SIMPLE_OPERATOR (\"reinterpret_cast\", REINTERPRET_CAST_EXPR, \"rc\", 1)\n-DEF_SIMPLE_OPERATOR (\"const_cast\", CONST_CAST_EXPR, \"cc\", 1)\n-DEF_SIMPLE_OPERATOR (\"static_cast\", STATIC_CAST_EXPR, \"sc\", 1)\n+DEF_SIMPLE_OPERATOR (\"\", CAST_EXPR, \"cv\", OVL_OP_FLAG_UNARY)\n+DEF_SIMPLE_OPERATOR (\"dynamic_cast\", DYNAMIC_CAST_EXPR, \"dc\", OVL_OP_FLAG_UNARY)\n+DEF_SIMPLE_OPERATOR (\"reinterpret_cast\", REINTERPRET_CAST_EXPR, \"rc\", OVL_OP_FLAG_UNARY)\n+DEF_SIMPLE_OPERATOR (\"const_cast\", CONST_CAST_EXPR, \"cc\", OVL_OP_FLAG_UNARY)\n+DEF_SIMPLE_OPERATOR (\"static_cast\", STATIC_CAST_EXPR, \"sc\", OVL_OP_FLAG_UNARY)\n \n /* Binary operators.  */\n-DEF_SIMPLE_OPERATOR (\"+\", PLUS_EXPR, \"pl\", 2)\n-DEF_SIMPLE_OPERATOR (\"-\", MINUS_EXPR, \"mi\", 2)\n-DEF_SIMPLE_OPERATOR (\"*\", MULT_EXPR, \"ml\", 2)\n-DEF_SIMPLE_OPERATOR (\"/\", TRUNC_DIV_EXPR, \"dv\", 2)\n-DEF_SIMPLE_OPERATOR (\"%\", TRUNC_MOD_EXPR, \"rm\", 2)\n-DEF_SIMPLE_OPERATOR (\"&\", BIT_AND_EXPR, \"an\", 2)\n-DEF_SIMPLE_OPERATOR (\"|\", BIT_IOR_EXPR, \"or\", 2)\n-DEF_SIMPLE_OPERATOR (\"^\", BIT_XOR_EXPR, \"eo\", 2)\n-DEF_SIMPLE_OPERATOR (\"<<\", LSHIFT_EXPR, \"ls\", 2)\n-DEF_SIMPLE_OPERATOR (\">>\", RSHIFT_EXPR, \"rs\", 2)\n-DEF_SIMPLE_OPERATOR (\"==\", EQ_EXPR, \"eq\", 2)\n-DEF_SIMPLE_OPERATOR (\"!=\", NE_EXPR, \"ne\", 2)\n-DEF_SIMPLE_OPERATOR (\"<\", LT_EXPR, \"lt\", 2)\n-DEF_SIMPLE_OPERATOR (\">\", GT_EXPR, \"gt\", 2)\n-DEF_SIMPLE_OPERATOR (\"<=\", LE_EXPR, \"le\", 2)\n-DEF_SIMPLE_OPERATOR (\">=\", GE_EXPR, \"ge\", 2)\n-DEF_SIMPLE_OPERATOR (\"&&\", TRUTH_ANDIF_EXPR, \"aa\", 2)\n-DEF_SIMPLE_OPERATOR (\"||\", TRUTH_ORIF_EXPR, \"oo\", 2)\n-DEF_SIMPLE_OPERATOR (\",\", COMPOUND_EXPR, \"cm\", 2)\n-DEF_SIMPLE_OPERATOR (\"->*\", MEMBER_REF, \"pm\", 2)\n-DEF_SIMPLE_OPERATOR (\".*\", DOTSTAR_EXPR, \"ds\", 2)\n-DEF_SIMPLE_OPERATOR (\"->\", COMPONENT_REF, \"pt\", 2)\n-DEF_SIMPLE_OPERATOR (\"[]\", ARRAY_REF, \"ix\", 2)\n-DEF_SIMPLE_OPERATOR (\"++\", POSTINCREMENT_EXPR, \"pp\", 2)\n-DEF_SIMPLE_OPERATOR (\"--\", POSTDECREMENT_EXPR, \"mm\", 2)\n+DEF_SIMPLE_OPERATOR (\"+\", PLUS_EXPR, \"pl\", OVL_OP_FLAG_BINARY)\n+DEF_SIMPLE_OPERATOR (\"-\", MINUS_EXPR, \"mi\", OVL_OP_FLAG_BINARY)\n+DEF_SIMPLE_OPERATOR (\"*\", MULT_EXPR, \"ml\", OVL_OP_FLAG_BINARY)\n+DEF_SIMPLE_OPERATOR (\"/\", TRUNC_DIV_EXPR, \"dv\", OVL_OP_FLAG_BINARY)\n+DEF_SIMPLE_OPERATOR (\"%\", TRUNC_MOD_EXPR, \"rm\", OVL_OP_FLAG_BINARY)\n+DEF_SIMPLE_OPERATOR (\"&\", BIT_AND_EXPR, \"an\", OVL_OP_FLAG_BINARY)\n+DEF_SIMPLE_OPERATOR (\"|\", BIT_IOR_EXPR, \"or\", OVL_OP_FLAG_BINARY)\n+DEF_SIMPLE_OPERATOR (\"^\", BIT_XOR_EXPR, \"eo\", OVL_OP_FLAG_BINARY)\n+DEF_SIMPLE_OPERATOR (\"<<\", LSHIFT_EXPR, \"ls\", OVL_OP_FLAG_BINARY)\n+DEF_SIMPLE_OPERATOR (\">>\", RSHIFT_EXPR, \"rs\", OVL_OP_FLAG_BINARY)\n+DEF_SIMPLE_OPERATOR (\"==\", EQ_EXPR, \"eq\", OVL_OP_FLAG_BINARY)\n+DEF_SIMPLE_OPERATOR (\"!=\", NE_EXPR, \"ne\", OVL_OP_FLAG_BINARY)\n+DEF_SIMPLE_OPERATOR (\"<\", LT_EXPR, \"lt\", OVL_OP_FLAG_BINARY)\n+DEF_SIMPLE_OPERATOR (\">\", GT_EXPR, \"gt\", OVL_OP_FLAG_BINARY)\n+DEF_SIMPLE_OPERATOR (\"<=\", LE_EXPR, \"le\", OVL_OP_FLAG_BINARY)\n+DEF_SIMPLE_OPERATOR (\">=\", GE_EXPR, \"ge\", OVL_OP_FLAG_BINARY)\n+DEF_SIMPLE_OPERATOR (\"&&\", TRUTH_ANDIF_EXPR, \"aa\", OVL_OP_FLAG_BINARY)\n+DEF_SIMPLE_OPERATOR (\"||\", TRUTH_ORIF_EXPR, \"oo\", OVL_OP_FLAG_BINARY)\n+DEF_SIMPLE_OPERATOR (\",\", COMPOUND_EXPR, \"cm\", OVL_OP_FLAG_BINARY)\n+DEF_SIMPLE_OPERATOR (\"->*\", MEMBER_REF, \"pm\", OVL_OP_FLAG_BINARY)\n+DEF_SIMPLE_OPERATOR (\".*\", DOTSTAR_EXPR, \"ds\", OVL_OP_FLAG_BINARY)\n+DEF_SIMPLE_OPERATOR (\"->\", COMPONENT_REF, \"pt\", OVL_OP_FLAG_BINARY)\n+DEF_SIMPLE_OPERATOR (\"[]\", ARRAY_REF, \"ix\", OVL_OP_FLAG_BINARY)\n+DEF_SIMPLE_OPERATOR (\"++\", POSTINCREMENT_EXPR, \"pp\", OVL_OP_FLAG_BINARY)\n+DEF_SIMPLE_OPERATOR (\"--\", POSTDECREMENT_EXPR, \"mm\", OVL_OP_FLAG_BINARY)\n /* This one is needed for mangling.  */\n-DEF_SIMPLE_OPERATOR (\"::\", SCOPE_REF, \"sr\", 2)\n+DEF_SIMPLE_OPERATOR (\"::\", SCOPE_REF, \"sr\", OVL_OP_FLAG_BINARY)\n \n /* Assignment operators.  */\n-DEF_ASSN_OPERATOR (\"=\", NOP_EXPR, \"aS\", 2)\n-DEF_ASSN_OPERATOR (\"+=\", PLUS_EXPR, \"pL\", 2)\n-DEF_ASSN_OPERATOR (\"-=\", MINUS_EXPR, \"mI\", 2)\n-DEF_ASSN_OPERATOR (\"*=\", MULT_EXPR, \"mL\", 2)\n-DEF_ASSN_OPERATOR (\"/=\", TRUNC_DIV_EXPR, \"dV\", 2)\n-DEF_ASSN_OPERATOR (\"%=\", TRUNC_MOD_EXPR, \"rM\", 2)\n-DEF_ASSN_OPERATOR (\"&=\", BIT_AND_EXPR, \"aN\", 2)\n-DEF_ASSN_OPERATOR (\"|=\", BIT_IOR_EXPR, \"oR\", 2)\n-DEF_ASSN_OPERATOR (\"^=\", BIT_XOR_EXPR, \"eO\", 2)\n-DEF_ASSN_OPERATOR (\"<<=\", LSHIFT_EXPR, \"lS\", 2)\n-DEF_ASSN_OPERATOR (\">>=\", RSHIFT_EXPR, \"rS\", 2)\n+DEF_ASSN_OPERATOR (\"=\", NOP_EXPR, \"aS\", OVL_OP_FLAG_BINARY)\n+DEF_ASSN_OPERATOR (\"+=\", PLUS_EXPR, \"pL\", OVL_OP_FLAG_BINARY)\n+DEF_ASSN_OPERATOR (\"-=\", MINUS_EXPR, \"mI\", OVL_OP_FLAG_BINARY)\n+DEF_ASSN_OPERATOR (\"*=\", MULT_EXPR, \"mL\", OVL_OP_FLAG_BINARY)\n+DEF_ASSN_OPERATOR (\"/=\", TRUNC_DIV_EXPR, \"dV\", OVL_OP_FLAG_BINARY)\n+DEF_ASSN_OPERATOR (\"%=\", TRUNC_MOD_EXPR, \"rM\", OVL_OP_FLAG_BINARY)\n+DEF_ASSN_OPERATOR (\"&=\", BIT_AND_EXPR, \"aN\", OVL_OP_FLAG_BINARY)\n+DEF_ASSN_OPERATOR (\"|=\", BIT_IOR_EXPR, \"oR\", OVL_OP_FLAG_BINARY)\n+DEF_ASSN_OPERATOR (\"^=\", BIT_XOR_EXPR, \"eO\", OVL_OP_FLAG_BINARY)\n+DEF_ASSN_OPERATOR (\"<<=\", LSHIFT_EXPR, \"lS\", OVL_OP_FLAG_BINARY)\n+DEF_ASSN_OPERATOR (\">>=\", RSHIFT_EXPR, \"rS\", OVL_OP_FLAG_BINARY)\n \n /* Ternary operators.  */\n-DEF_SIMPLE_OPERATOR (\"?:\", COND_EXPR, \"qu\", 3)\n+DEF_SIMPLE_OPERATOR (\"?:\", COND_EXPR, \"qu\", OVL_OP_FLAG_NONE)\n \n /* Miscellaneous.  */\n-DEF_SIMPLE_OPERATOR (\"()\", CALL_EXPR, \"cl\", -1)\n+DEF_SIMPLE_OPERATOR (\"()\", CALL_EXPR, \"cl\", OVL_OP_FLAG_NONE)\n \n /* Variadic templates extension. */\n-DEF_SIMPLE_OPERATOR (\"...\", EXPR_PACK_EXPANSION, \"sp\", 1)\n-DEF_SIMPLE_OPERATOR (\"... +\", UNARY_LEFT_FOLD_EXPR, \"fl\", 2)\n-DEF_SIMPLE_OPERATOR (\"+ ...\", UNARY_RIGHT_FOLD_EXPR, \"fr\", 2)\n-DEF_SIMPLE_OPERATOR (\"+ ... +\", BINARY_LEFT_FOLD_EXPR, \"fL\", 3)\n-DEF_SIMPLE_OPERATOR (\"+ ... +\", BINARY_RIGHT_FOLD_EXPR, \"fR\", 3)\n+DEF_SIMPLE_OPERATOR (\"...\", EXPR_PACK_EXPANSION, \"sp\", OVL_OP_FLAG_UNARY)\n+DEF_SIMPLE_OPERATOR (\"... +\", UNARY_LEFT_FOLD_EXPR, \"fl\", OVL_OP_FLAG_BINARY)\n+DEF_SIMPLE_OPERATOR (\"+ ...\", UNARY_RIGHT_FOLD_EXPR, \"fr\", OVL_OP_FLAG_BINARY)\n+DEF_SIMPLE_OPERATOR (\"+ ... +\", BINARY_LEFT_FOLD_EXPR, \"fL\", OVL_OP_FLAG_NONE)\n+DEF_SIMPLE_OPERATOR (\"+ ... +\", BINARY_RIGHT_FOLD_EXPR, \"fR\", OVL_OP_FLAG_NONE)"}]}