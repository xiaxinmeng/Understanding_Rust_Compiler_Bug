{"sha": "3c56b037d3517192aeb66c7dde1e893c5a20fd99", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2M1NmIwMzdkMzUxNzE5MmFlYjY2YzdkZGUxZTg5M2M1YTIwZmQ5OQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2012-04-09T23:39:11Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2012-04-09T23:39:11Z"}, "message": "re PR lto/52722 (ICE in lto_output_varpool_node)\n\n\n\tPR lto/52722\n\tPR lto/51765\n\tPR lto/52634\t\n\t* lto-cgraph.c (compute_ltrans_boundary): When alias is in the boundary,\n\tadd its target too.\n\t* lto.c (add_references_to_partition): Add also aliased nodes.\n\t(add_cgraph_node_to_partition,\n\tadd_varpool_node_to_partition): Work on nodes, not functions/variables;\n\twhen adding alias, add also the aliased object.\n\n\t* gcc.dg/lto/pr52634_1.c: New testcase.\n\t* gcc.dg/lto/pr52634_0.c: New testcase.\n\nFrom-SVN: r186252", "tree": {"sha": "f3f75fa5d40c0187f09c5fb152838f703f00c122", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f3f75fa5d40c0187f09c5fb152838f703f00c122"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3c56b037d3517192aeb66c7dde1e893c5a20fd99", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c56b037d3517192aeb66c7dde1e893c5a20fd99", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c56b037d3517192aeb66c7dde1e893c5a20fd99", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c56b037d3517192aeb66c7dde1e893c5a20fd99/comments", "author": null, "committer": null, "parents": [{"sha": "3cb2b15b6c800aa7afef5b427978371aabb6d20a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cb2b15b6c800aa7afef5b427978371aabb6d20a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3cb2b15b6c800aa7afef5b427978371aabb6d20a"}], "stats": {"total": 93, "additions": 84, "deletions": 9}, "files": [{"sha": "e58e86f3ada99b5eb5f5751e27e2cf9109f7ffed", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c56b037d3517192aeb66c7dde1e893c5a20fd99/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c56b037d3517192aeb66c7dde1e893c5a20fd99/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3c56b037d3517192aeb66c7dde1e893c5a20fd99", "patch": "@@ -1,3 +1,15 @@\n+2012-04-09  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR lto/52722\n+\tPR lto/51765\n+\tPR lto/52634\t\n+\t* lto-cgraph.c (compute_ltrans_boundary): When alias is in the boundary,\n+\tadd its target too.\n+\t* lto.c (add_references_to_partition): Add also aliased nodes.\n+\t(add_cgraph_node_to_partition,\n+\tadd_varpool_node_to_partition): Work on nodes, not functions/variables;\n+\twhen adding alias, add also the aliased object.\n+\n 2012-04-09  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR target/52883"}, {"sha": "f57028d07fb545adad1a9405fdb3f046847abc38", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c56b037d3517192aeb66c7dde1e893c5a20fd99/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c56b037d3517192aeb66c7dde1e893c5a20fd99/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=3c56b037d3517192aeb66c7dde1e893c5a20fd99", "patch": "@@ -799,6 +799,8 @@ compute_ltrans_boundary (struct lto_out_decl_state *state,\n \t  lto_set_varpool_encoder_encode_initializer (varpool_encoder, vnode);\n \t  add_references (encoder, varpool_encoder, &vnode->ref_list);\n \t}\n+      else if (vnode->alias || vnode->alias_of)\n+        add_references (encoder, varpool_encoder, &vnode->ref_list);\n     }\n \n   /* Go over all the nodes again to include callees that are not in"}, {"sha": "26b4065e0ab5992497f2bd02948e780de81acc18", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 51, "deletions": 9, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c56b037d3517192aeb66c7dde1e893c5a20fd99/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c56b037d3517192aeb66c7dde1e893c5a20fd99/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=3c56b037d3517192aeb66c7dde1e893c5a20fd99", "patch": "@@ -1444,7 +1444,8 @@ free_ltrans_partitions (void)\n   VEC_free (ltrans_partition, heap, ltrans_partitions);\n }\n \n-/* See all references that go to comdat objects and bring them into partition too.  */\n+/* See all references that go to comdat objects and bring them into partition too.\n+   Also see all aliases of the newly added entry and bring them, too.  */\n static void\n add_references_to_partition (ltrans_partition part, struct ipa_ref_list *refs)\n {\n@@ -1453,15 +1454,45 @@ add_references_to_partition (ltrans_partition part, struct ipa_ref_list *refs)\n   for (i = 0; ipa_ref_list_reference_iterate (refs, i, ref); i++)\n     {\n       if (ref->refered_type == IPA_REF_CGRAPH\n-\t  && DECL_COMDAT (cgraph_function_node (ipa_ref_node (ref), NULL)->decl)\n+\t  && (DECL_COMDAT (cgraph_function_node (ipa_ref_node (ref),\n+\t\t\t   NULL)->decl)\n+\t      || (ref->use == IPA_REF_ALIAS\n+\t\t  && lookup_attribute\n+\t\t       (\"weakref\", DECL_ATTRIBUTES (ipa_ref_node (ref)->decl))))\n \t  && !cgraph_node_in_set_p (ipa_ref_node (ref), part->cgraph_set))\n \tadd_cgraph_node_to_partition (part, ipa_ref_node (ref));\n       else\n \tif (ref->refered_type == IPA_REF_VARPOOL\n-\t    && DECL_COMDAT (ipa_ref_varpool_node (ref)->decl)\n-\t    && !varpool_node_in_set_p (ipa_ref_varpool_node (ref), part->varpool_set))\n+\t    && (DECL_COMDAT (ipa_ref_varpool_node (ref)->decl)\n+\t        || (ref->use == IPA_REF_ALIAS\n+\t\t    && lookup_attribute\n+\t\t         (\"weakref\",\n+\t\t\t  DECL_ATTRIBUTES (ipa_ref_varpool_node (ref)->decl))))\n+\t    && !varpool_node_in_set_p (ipa_ref_varpool_node (ref),\n+\t\t\t\t       part->varpool_set))\n \t  add_varpool_node_to_partition (part, ipa_ref_varpool_node (ref));\n     }\n+  for (i = 0; ipa_ref_list_refering_iterate (refs, i, ref); i++)\n+    {\n+      if (ref->refering_type == IPA_REF_CGRAPH\n+\t  && ref->use == IPA_REF_ALIAS\n+\t  && !cgraph_node_in_set_p (ipa_ref_refering_node (ref),\n+\t\t\t\t    part->cgraph_set)\n+\t  && !lookup_attribute (\"weakref\",\n+\t\t\t\tDECL_ATTRIBUTES\n+\t\t\t\t  (ipa_ref_refering_node (ref)->decl)))\n+\tadd_cgraph_node_to_partition (part, ipa_ref_refering_node (ref));\n+      else\n+\tif (ref->refering_type == IPA_REF_VARPOOL\n+\t    && ref->use == IPA_REF_ALIAS\n+\t    && !varpool_node_in_set_p (ipa_ref_refering_varpool_node (ref),\n+\t\t\t\t       part->varpool_set)\n+\t    && !lookup_attribute (\"weakref\",\n+\t\t\t\t  DECL_ATTRIBUTES\n+\t\t\t\t    (ipa_ref_refering_varpool_node (ref)->decl)))\n+\t  add_varpool_node_to_partition (part,\n+\t\t\t\t\t ipa_ref_refering_varpool_node (ref));\n+    }\n }\n \n /* Worker for add_cgraph_node_to_partition.  */\n@@ -1501,9 +1532,6 @@ add_cgraph_node_to_partition (ltrans_partition part, struct cgraph_node *node)\n   cgraph_node_set_iterator csi;\n   struct cgraph_node *n;\n \n-  /* We always decide on functions, not associated thunks and aliases.  */\n-  node = cgraph_function_node (node, NULL);\n-\n   /* If NODE is already there, we have nothing to do.  */\n   csi = cgraph_node_set_find (part->cgraph_set, node);\n   if (!csi_end_p (csi))\n@@ -1522,7 +1550,14 @@ add_cgraph_node_to_partition (ltrans_partition part, struct cgraph_node *node)\n \t&& !cgraph_node_in_set_p (e->callee, part->cgraph_set))\n       add_cgraph_node_to_partition (part, e->callee);\n \n+  /* The only way to assemble non-weakref alias is to add the aliased object into\n+     the unit.  */\n   add_references_to_partition (part, &node->ref_list);\n+  n = cgraph_function_node (node, NULL);\n+  if (n != node\n+      && !lookup_attribute (\"weakref\",\n+\t\t\t    DECL_ATTRIBUTES (node->decl)))\n+    add_cgraph_node_to_partition (part, n);\n \n   if (node->same_comdat_group)\n     for (n = node->same_comdat_group; n != node; n = n->same_comdat_group)\n@@ -1535,8 +1570,7 @@ static void\n add_varpool_node_to_partition (ltrans_partition part, struct varpool_node *vnode)\n {\n   varpool_node_set_iterator vsi;\n-\n-  vnode = varpool_variable_node (vnode, NULL);\n+  struct varpool_node *v;\n \n   /* If NODE is already there, we have nothing to do.  */\n   vsi = varpool_node_set_find (part->varpool_set, vnode);\n@@ -1554,6 +1588,14 @@ add_varpool_node_to_partition (ltrans_partition part, struct varpool_node *vnode\n     }\n   vnode->aux = (void *)((size_t)vnode->aux + 1);\n \n+  /* The only way to assemble non-weakref alias is to add the aliased object into\n+     the unit.  */\n+  v = varpool_variable_node (vnode, NULL);\n+  if (v != vnode\n+      && !lookup_attribute (\"weakref\",\n+\t\t\t    DECL_ATTRIBUTES (vnode->decl)))\n+    add_varpool_node_to_partition (part, v);\n+\n   add_references_to_partition (part, &vnode->ref_list);\n \n   if (vnode->same_comdat_group"}, {"sha": "5a0e5ef19c73011262b7e9da37aa9a49ba38e553", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c56b037d3517192aeb66c7dde1e893c5a20fd99/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c56b037d3517192aeb66c7dde1e893c5a20fd99/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3c56b037d3517192aeb66c7dde1e893c5a20fd99", "patch": "@@ -1,3 +1,11 @@\n+2012-04-09  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR lto/52722\n+\tPR lto/51765\n+\tPR lto/52634\t\n+\t* gcc.dg/lto/pr52634_1.c: New testcase.\n+\t* gcc.dg/lto/pr52634_0.c: New testcase.\n+\n 2012-04-09  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR target/52883"}, {"sha": "27e075d4758a0ce5562e184285e4cfc0c2ef0fdb", "filename": "gcc/testsuite/gcc.dg/lto/pr52634_0.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c56b037d3517192aeb66c7dde1e893c5a20fd99/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fpr52634_0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c56b037d3517192aeb66c7dde1e893c5a20fd99/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fpr52634_0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fpr52634_0.c?ref=3c56b037d3517192aeb66c7dde1e893c5a20fd99", "patch": "@@ -0,0 +1,5 @@\n+/* { dg-lto-do link } */\n+/* { dg-lto-options {{-flto -r -nostdlib -flto-partition=1to1}} */\n+extern int cfliteValueCallBacks;\n+void baz (int *);\n+int main () { baz(&cfliteValueCallBacks); }"}, {"sha": "af4c43980d13ab8c4202a8a57caba8878e9e05e2", "filename": "gcc/testsuite/gcc.dg/lto/pr52634_1.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c56b037d3517192aeb66c7dde1e893c5a20fd99/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fpr52634_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c56b037d3517192aeb66c7dde1e893c5a20fd99/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fpr52634_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fpr52634_1.c?ref=3c56b037d3517192aeb66c7dde1e893c5a20fd99", "patch": "@@ -0,0 +1,6 @@\n+int cfliteKeyCallBacks = 5;\n+extern int cfliteValueCallBacks __attribute__((alias(\"cfliteKeyCallBacks\")));\n+void baz(void *ptr)\n+{\n+  asm volatile (\"\"::\"r\"(ptr));\n+}"}]}