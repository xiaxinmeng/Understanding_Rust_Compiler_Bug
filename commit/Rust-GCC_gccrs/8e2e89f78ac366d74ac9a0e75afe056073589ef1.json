{"sha": "8e2e89f78ac366d74ac9a0e75afe056073589ef1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGUyZTg5Zjc4YWMzNjZkNzRhYzlhMGU3NWFmZTA1NjA3MzU4OWVmMQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@hxi.com", "date": "2002-01-15T13:38:03Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2002-01-15T13:38:03Z"}, "message": "read-rtl.c: Fix formatting.\n\n\t* read-rtl.c: Fix formatting.\n\t* real.c: Likewise.\n\t* recog.c: Likewise.\n\t* regclass.c: Likewise.\n\t* regmove.c: Likewise.\n\t* reg-stack.c: Likewise.\n\t* reload1.c: Likewise.\n\t* rtlanal.c: Likewise.\n\nFrom-SVN: r48870", "tree": {"sha": "15c488cfd0892394f03a3a880f8a6027ac7d4155", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/15c488cfd0892394f03a3a880f8a6027ac7d4155"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8e2e89f78ac366d74ac9a0e75afe056073589ef1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e2e89f78ac366d74ac9a0e75afe056073589ef1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e2e89f78ac366d74ac9a0e75afe056073589ef1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e2e89f78ac366d74ac9a0e75afe056073589ef1/comments", "author": null, "committer": null, "parents": [{"sha": "b531087a3826b2cee37655af1725fe243fd898fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b531087a3826b2cee37655af1725fe243fd898fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b531087a3826b2cee37655af1725fe243fd898fb"}], "stats": {"total": 143, "additions": 77, "deletions": 66}, "files": [{"sha": "206c1b917c4a5259bd9c89f5bf836d8ef4a5e645", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e2e89f78ac366d74ac9a0e75afe056073589ef1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e2e89f78ac366d74ac9a0e75afe056073589ef1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8e2e89f78ac366d74ac9a0e75afe056073589ef1", "patch": "@@ -1,3 +1,14 @@\n+2002-01-15  Kazu Hirata  <kazu@hxi.com>\n+\n+\t* read-rtl.c: Fix formatting.\n+\t* real.c: Likewise.\n+\t* recog.c: Likewise.\n+\t* regclass.c: Likewise.\n+\t* regmove.c: Likewise.\n+\t* reg-stack.c: Likewise.\n+\t* reload1.c: Likewise.\n+\t* rtlanal.c: Likewise.\n+\n 2002-01-15  Kazu Hirata  <kazu@hxi.com>\n \n \t* config/i386/i386.c: Fix formatting."}, {"sha": "5b937ec9f3bd592a25c5f809d74fef68452d878d", "filename": "gcc/read-rtl.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e2e89f78ac366d74ac9a0e75afe056073589ef1/gcc%2Fread-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e2e89f78ac366d74ac9a0e75afe056073589ef1/gcc%2Fread-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-rtl.c?ref=8e2e89f78ac366d74ac9a0e75afe056073589ef1", "patch": "@@ -73,7 +73,7 @@ fatal_with_file_and_line VPARAMS ((FILE *infile, const char *msg, ...))\n   putc ('\\n', stderr);\n \n   /* Gather some following context.  */\n-  for (i = 0; i < sizeof(context)-1; ++i)\n+  for (i = 0; i < sizeof (context)-1; ++i)\n     {\n       c = getc (infile);\n       if (c == EOF)\n@@ -376,21 +376,21 @@ read_string (ob, infile, star_if_braced)\n    not provide one.  */\n #if HOST_BITS_PER_WIDE_INT > HOST_BITS_PER_LONG && !defined(HAVE_ATOLL) && !defined(HAVE_ATOQ)\n HOST_WIDE_INT\n-atoll(p)\n+atoll (p)\n     const char *p;\n {\n   int neg = 0;\n   HOST_WIDE_INT tmp_wide;\n \n-  while (ISSPACE(*p))\n+  while (ISSPACE (*p))\n     p++;\n   if (*p == '-')\n     neg = 1, p++;\n   else if (*p == '+')\n     p++;\n \n   tmp_wide = 0;\n-  while (ISDIGIT(*p))\n+  while (ISDIGIT (*p))\n     {\n       HOST_WIDE_INT new_wide = tmp_wide*10 + (*p - '0');\n       if (new_wide < tmp_wide)\n@@ -415,7 +415,7 @@ def_hash (def)\n      const void *def;\n {\n   unsigned result, i;\n-  const char *string = ((const struct md_constant *)def)->name;\n+  const char *string = ((const struct md_constant *) def)->name;\n \n   for (result = i = 0;*string++ != '\\0'; i++)\n     result += ((unsigned char) *string << (i % CHAR_BIT));\n@@ -427,8 +427,8 @@ static int\n def_name_eq_p (def1, def2)\n      const void *def1, *def2;\n {\n-  return ! strcmp (((const struct md_constant *)def1)->name,\n-\t\t   ((const struct md_constant *)def2)->name);\n+  return ! strcmp (((const struct md_constant *) def1)->name,\n+\t\t   ((const struct md_constant *) def2)->name);\n }\n \n /* INFILE is a FILE pointer to read text from.  TMP_CHAR is a buffer suitable\n@@ -510,7 +510,7 @@ validate_const_int (infile, string)\n   int valid = 1;\n \n   cp = string;\n-  while (*cp && ISSPACE(*cp))\n+  while (*cp && ISSPACE (*cp))\n     cp++;\n   if (*cp == '-' || *cp == '+')\n     cp++;\n@@ -728,7 +728,7 @@ read_rtx (infile)\n \n       case 'w':\n \tread_name (tmp_char, infile);\n-\tvalidate_const_int(infile, tmp_char);\n+\tvalidate_const_int (infile, tmp_char);\n #if HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_INT\n \ttmp_wide = atoi (tmp_char);\n #else\n@@ -750,7 +750,7 @@ read_rtx (infile)\n       case 'i':\n       case 'n':\n \tread_name (tmp_char, infile);\n-\tvalidate_const_int(infile, tmp_char);\n+\tvalidate_const_int (infile, tmp_char);\n \ttmp_int = atoi (tmp_char);\n \tXINT (return_rtx, i) = tmp_int;\n \tbreak;"}, {"sha": "7b8879b87646c6681b38bbb7e210c634b9c9ad4f", "filename": "gcc/real.c", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e2e89f78ac366d74ac9a0e75afe056073589ef1/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e2e89f78ac366d74ac9a0e75afe056073589ef1/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=8e2e89f78ac366d74ac9a0e75afe056073589ef1", "patch": "@@ -271,8 +271,8 @@ typedef unsigned int UHItype __attribute__ ((mode (HI)));\n # define PUT_REAL(e,r)\t\t\t\t\t\t\\\n \tdo {\t\t\t\t\t\t\t\\\n \t  memcpy ((r), (e), 2*NE);\t\t\t\t\\\n-\t  if (2*NE < sizeof(*r))\t\t\t\t\\\n-\t    memset ((char *) (r) + 2*NE, 0, sizeof(*r) - 2*NE);\t\\\n+\t  if (2*NE < sizeof (*r))\t\t\t\t\\\n+\t    memset ((char *) (r) + 2*NE, 0, sizeof (*r) - 2*NE);\t\\\n \t} while (0)\n # else /* no XFmode */\n #  if MAX_LONG_DOUBLE_TYPE_SIZE == 128\n@@ -283,8 +283,8 @@ typedef unsigned int UHItype __attribute__ ((mode (HI)));\n #   define PUT_REAL(e,r)\t\t\t\t\t\\\n \tdo {\t\t\t\t\t\t\t\\\n \t  memcpy ((r), (e), 2*NE);\t\t\t\t\\\n-\t  if (2*NE < sizeof(*r))\t\t\t\t\\\n-\t    memset ((char *) (r) + 2*NE, 0, sizeof(*r) - 2*NE);\t\\\n+\t  if (2*NE < sizeof (*r))\t\t\t\t\\\n+\t    memset ((char *) (r) + 2*NE, 0, sizeof (*r) - 2*NE);\t\\\n \t} while (0)\n #else\n #define NE 6\n@@ -1015,7 +1015,7 @@ ereal_to_int (low, high, rr)\n   ediv (df, d, dg);\t\t/* dg = d / 2^32 is the high word */\n   euifrac (dg, (unsigned HOST_WIDE_INT *) high, dh);\n   emul (df, dh, dg);\t\t/* fractional part is the low word */\n-  euifrac (dg, (unsigned HOST_WIDE_INT *)low, dh);\n+  euifrac (dg, (unsigned HOST_WIDE_INT *) low, dh);\n   if (s)\n     {\n       /* complement and add 1 */\n@@ -2382,9 +2382,9 @@ m16m (a, b, c)\n \t{\n \t  m = (unsigned EMULONG) aa * *ps--;\n \t  carry = (m & 0xffff) + *pp;\n-\t  *pp-- = (UEMUSHORT)carry;\n+\t  *pp-- = (UEMUSHORT) carry;\n \t  carry = (carry >> 16) + (m >> 16) + *pp;\n-\t  *pp = (UEMUSHORT)carry;\n+\t  *pp = (UEMUSHORT) carry;\n \t  *(pp-1) = carry >> 16;\n \t}\n     }\n@@ -2428,7 +2428,7 @@ edivm (den, num)\n       else\n \ttquot = tnum / tdenm;\n       /* Multiply denominator by trial quotient digit.  */\n-      m16m ((unsigned int)tquot, den, tprod);\n+      m16m ((unsigned int) tquot, den, tprod);\n       /* The quotient digit may have been overestimated.  */\n       if (ecmpm (tprod, num) > 0)\n \t{\n@@ -2442,7 +2442,7 @@ edivm (den, num)\n \t}\n       esubm (tprod, num);\n       equot[i] = tquot;\n-      eshup6(num);\n+      eshup6 (num);\n     }\n   /* test for nonzero remainder after roundoff bit */\n   p = &num[M];\n@@ -2457,7 +2457,7 @@ edivm (den, num)\n   for (i=0; i<NI; i++)\n     num[i] = equot[i];\n \n-  return ((int)j);\n+  return ((int) j);\n }\n \n /* Multiply significands of exploded e-type A and B, result in B.  */\n@@ -2490,17 +2490,17 @@ emulm (a, b)\n       else\n \t{\n \t  m16m ((unsigned int) *p--, b, pprod);\n-\t  eaddm(pprod, equot);\n+\t  eaddm (pprod, equot);\n \t}\n       j |= *q;\n-      eshdn6(equot);\n+      eshdn6 (equot);\n     }\n \n   for (i=0; i<NI; i++)\n     b[i] = equot[i];\n \n   /* return flag for lost nonzero bits */\n-  return ((int)j);\n+  return ((int) j);\n }\n #endif\n \n@@ -2946,7 +2946,7 @@ ediv (a, b, c)\n \n /* IEEE says if result is not a NaN, the sign is \"-\" if and only if\n    operands have opposite signs -- but flush -0 to 0 later if not IEEE.  */\n-  sign = eisneg(a) ^ eisneg(b);\n+  sign = eisneg (a) ^ eisneg (b);\n \n #ifdef NANS\n /* Return any NaN input.  */\n@@ -3051,7 +3051,7 @@ emul (a, b, c)\n \n /* IEEE says if result is not a NaN, the sign is \"-\" if and only if\n    operands have opposite signs -- but flush -0 to 0 later if not IEEE.  */\n-  sign = eisneg(a) ^ eisneg(b);\n+  sign = eisneg (a) ^ eisneg (b);\n \n #ifdef NANS\n /* NaN times anything is the same NaN.  */\n@@ -3283,13 +3283,13 @@ e64toe (pe, y)\n       /* For denormal long double Intel format, shift significand up one\n \t -- but only if the top significand bit is zero.  A top bit of 1\n \t is \"pseudodenormal\" when the exponent is zero.  */\n-      if((yy[NE-1] & 0x7fff) == 0 && (yy[NE-2] & 0x8000) == 0)\n+      if ((yy[NE-1] & 0x7fff) == 0 && (yy[NE-2] & 0x8000) == 0)\n \t{\n \t  UEMUSHORT temp[NI];\n \n-\t  emovi(yy, temp);\n-\t  eshup1(temp);\n-\t  emovo(temp,y);\n+\t  emovi (yy, temp);\n+\t  eshup1 (temp);\n+\t  emovo (temp,y);\n \t  return;\n \t}\n     }\n@@ -5035,7 +5035,7 @@ etoasc (x, string, ndigs)\n     }\n   else\n     {\n-      *s++ = (char)digit + '0';\n+      *s++ = (char) digit + '0';\n       *s++ = '.';\n     }\n   /* Generate digits after the decimal point.  */\n@@ -5231,7 +5231,7 @@ asctoeg (ss, y, oprec)\n   trail = 0;\n \n  nxtcom:\n-  k = hex_value(*s);\n+  k = hex_value (*s);\n   if ((k >= 0) && (k < base))\n     {\n       /* Ignore leading zeros */\n@@ -6123,7 +6123,7 @@ c4xtoe (d, e, mode)\n         }\n       else\n \tsize = 2;\n-      eshift(y, -8);\n+      eshift (y, -8);\n \n       /* Now do the two's complement on the data.  */\n \n@@ -6143,7 +6143,7 @@ c4xtoe (d, e, mode)\n \n       if (carry)\n         {\n-\t  eshift(y, -1);\n+\t  eshift (y, -1);\n \t  y[M+1] |= 0x8000;\n \t  r++;\n          }\n@@ -6165,7 +6165,7 @@ c4xtoe (d, e, mode)\n \t y[M+2] = dn[2];\t/* Fill in the rest of our mantissa.  */\n \t y[M+3] = dn[3];\n        }\n-     eshift(y, -8);\n+     eshift (y, -8);\n     }\n \n   emovo (y, e);\n@@ -6261,7 +6261,7 @@ toc4x (x, y, mode)\n \t{\n \t  /* This is the case of -1 x 2^m, we have to rid ourselves of the\n \t     high sign bit and shift the exponent.  */\n-\t  eshift(x, 1);\n+\t  eshift (x, 1);\n \t  i--;\n \t}\n     }"}, {"sha": "ec0ec882dc72ee2a1d6e16eff6b9aafbffb9104e", "filename": "gcc/recog.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e2e89f78ac366d74ac9a0e75afe056073589ef1/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e2e89f78ac366d74ac9a0e75afe056073589ef1/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=8e2e89f78ac366d74ac9a0e75afe056073589ef1", "patch": "@@ -1,6 +1,6 @@\n /* Subroutines used by or related to instruction recognition.\n    Copyright (C) 1987, 1988, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998\n-   1999, 2000, 2001 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -157,7 +157,7 @@ check_asm_operands (x)\n       const char *c = constraints[i];\n       if (c[0] == '%')\n \tc++;\n-      if (ISDIGIT ((unsigned char)c[0]) && c[1] == '\\0')\n+      if (ISDIGIT ((unsigned char) c[0]) && c[1] == '\\0')\n \tc = constraints[c[0] - '0'];\n \n       if (! asm_operand_ok (operands[i], c))\n@@ -2253,7 +2253,7 @@ preprocess_constraints ()\n \t\t  break;\n \n \t\tdefault:\n-\t\t  op_alt[j].class = reg_class_subunion[(int) op_alt[j].class][(int) REG_CLASS_FROM_LETTER ((unsigned char)c)];\n+\t\t  op_alt[j].class = reg_class_subunion[(int) op_alt[j].class][(int) REG_CLASS_FROM_LETTER ((unsigned char) c)];\n \t\t  break;\n \t\t}\n \t    }"}, {"sha": "e7f69b0e786dffbaa8477806bbad6e4439052823", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e2e89f78ac366d74ac9a0e75afe056073589ef1/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e2e89f78ac366d74ac9a0e75afe056073589ef1/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=8e2e89f78ac366d74ac9a0e75afe056073589ef1", "patch": "@@ -871,7 +871,7 @@ remove_regno_note (insn, note, regno)\n {\n   rtx *note_link, this;\n \n-  note_link = &REG_NOTES(insn);\n+  note_link = &REG_NOTES (insn);\n   for (this = *note_link; this; this = XEXP (this, 1))\n     if (REG_NOTE_KIND (this) == note\n \t&& REG_P (XEXP (this, 0)) && REGNO (XEXP (this, 0)) == regno)\n@@ -2223,7 +2223,7 @@ subst_stack_regs (insn, regstack)\n      since the form of the newly emitted pop insn references the reg,\n      making it no longer `unset'.  */\n \n-  note_link = &REG_NOTES(insn);\n+  note_link = &REG_NOTES (insn);\n   for (note = *note_link; note; note = XEXP (note, 1))\n     if (REG_NOTE_KIND (note) == REG_UNUSED && STACK_REG_P (XEXP (note, 0)))\n       {"}, {"sha": "9bf07048db9562b217a5c1ac142d6b132fe0ca4b", "filename": "gcc/regclass.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e2e89f78ac366d74ac9a0e75afe056073589ef1/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e2e89f78ac366d74ac9a0e75afe056073589ef1/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=8e2e89f78ac366d74ac9a0e75afe056073589ef1", "patch": "@@ -1192,7 +1192,7 @@ regclass (f, nregs, dump)\n   costs = (struct costs *) xmalloc (nregs * sizeof (struct costs));\n \n #ifdef CLASS_CANNOT_CHANGE_MODE\n-  reg_changes_mode = BITMAP_XMALLOC();\n+  reg_changes_mode = BITMAP_XMALLOC ();\n #endif  \n \n #ifdef FORBIDDEN_INC_DEC_CLASSES\n@@ -1341,7 +1341,7 @@ regclass (f, nregs, dump)\n \t\t  best = (enum reg_class) class;\n \t\t}\n \t      else if (p->cost[class] == best_cost)\n-\t\tbest = reg_class_subunion[(int)best][class];\n+\t\tbest = reg_class_subunion[(int) best][class];\n \t    }\n \n \t  /* Record the alternate register class; i.e., a class for which\n@@ -2214,17 +2214,17 @@ allocate_reg_info (num_regs, new_p, renumber_p)\n \n \t  if (new_p)\t\t/* if we're zapping everything, no need to realloc */\n \t    {\n-\t      free ((char *)renumber);\n-\t      free ((char *)reg_pref);\n+\t      free ((char *) renumber);\n+\t      free ((char *) reg_pref);\n \t      renumber = (short *) xmalloc (size_renumber);\n \t      reg_pref_buffer = (struct reg_pref *) xmalloc (regno_allocated \n \t\t\t\t\t\t  * sizeof (struct reg_pref));\n \t    }\n \n \t  else\n \t    {\n-\t      renumber = (short *) xrealloc ((char *)renumber, size_renumber);\n-\t      reg_pref_buffer = (struct reg_pref *) xrealloc ((char *)reg_pref_buffer,\n+\t      renumber = (short *) xrealloc ((char *) renumber, size_renumber);\n+\t      reg_pref_buffer = (struct reg_pref *) xrealloc ((char *) reg_pref_buffer,\n \t\t\t\t\t\t   regno_allocated \n \t\t\t\t\t\t   * sizeof (struct reg_pref));\n \t    }\n@@ -2301,7 +2301,7 @@ free_reg_info ()\n       for (reg_data = reg_info_head; reg_data; reg_data = reg_next)\n \t{\n \t  reg_next = reg_data->next;\n-\t  free ((char *)reg_data);\n+\t  free ((char *) reg_data);\n \t}\n \n       free (reg_pref_buffer);\n@@ -2571,8 +2571,8 @@ reg_class_subset_p (c1, c2)\n   if (c2 == ALL_REGS)\n   win:\n     return 1;\n-  GO_IF_HARD_REG_SUBSET (reg_class_contents[(int)c1],\n-\t\t\t reg_class_contents[(int)c2],\n+  GO_IF_HARD_REG_SUBSET (reg_class_contents[(int) c1],\n+\t\t\t reg_class_contents[(int) c2],\n \t\t\t win);\n   return 0;\n }"}, {"sha": "f184deb769cce04b6e687fd22292b4d51f423413", "filename": "gcc/regmove.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e2e89f78ac366d74ac9a0e75afe056073589ef1/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e2e89f78ac366d74ac9a0e75afe056073589ef1/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=8e2e89f78ac366d74ac9a0e75afe056073589ef1", "patch": "@@ -239,7 +239,7 @@ mark_flags_life_zones (flags)\n     {\n       enum machine_mode mode = (flags ? HImode : VOIDmode);\n       rtx insn;\n-      for (insn = get_insns(); insn; insn = NEXT_INSN (insn))\n+      for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n \tPUT_MODE (insn, mode);\n       return;\n     }\n@@ -334,7 +334,7 @@ static int *regno_src_regno;\n    a candidate for tying to a hard register, since the output might in\n    turn be a candidate to be tied to a different hard register.  */\n static int\n-replacement_quality(reg)\n+replacement_quality (reg)\n      rtx reg;\n {\n   int src_regno;\n@@ -1104,12 +1104,12 @@ regmove_optimize (f, nregs, regmove_dump_file)\n \t      && (GET_CODE (SET_SRC (set)) == SIGN_EXTEND\n \t\t  || GET_CODE (SET_SRC (set)) == ZERO_EXTEND)\n \t      && GET_CODE (XEXP (SET_SRC (set), 0)) == REG\n-\t      && GET_CODE (SET_DEST(set)) == REG)\n+\t      && GET_CODE (SET_DEST (set)) == REG)\n \t    optimize_reg_copy_3 (insn, SET_DEST (set), SET_SRC (set));\n \n \t  if (flag_expensive_optimizations && ! pass\n \t      && GET_CODE (SET_SRC (set)) == REG\n-\t      && GET_CODE (SET_DEST(set)) == REG)\n+\t      && GET_CODE (SET_DEST (set)) == REG)\n \t    {\n \t      /* If this is a register-register copy where SRC is not dead,\n \t\t see if we can optimize it.  If this optimization succeeds,\n@@ -1124,7 +1124,7 @@ regmove_optimize (f, nregs, regmove_dump_file)\n \t\t  if (regno_src_regno[REGNO (SET_DEST (set))] < 0\n \t\t      && SET_SRC (set) != SET_DEST (set))\n \t\t    {\n-\t\t      int srcregno = REGNO (SET_SRC(set));\n+\t\t      int srcregno = REGNO (SET_SRC (set));\n \t\t      if (regno_src_regno[srcregno] >= 0)\n \t\t\tsrcregno = regno_src_regno[srcregno];\n \t\t      regno_src_regno[REGNO (SET_DEST (set))] = srcregno;\n@@ -1599,7 +1599,7 @@ find_matches (insn, matchp)\n \t  case 'j': case 'k': case 'l': case 'p': case 'q': case 't': case 'u':\n \t  case 'v': case 'w': case 'x': case 'y': case 'z': case 'A': case 'B':\n \t  case 'C': case 'D': case 'W': case 'Y': case 'Z':\n-\t    if (CLASS_LIKELY_SPILLED_P (REG_CLASS_FROM_LETTER ((unsigned char)c)))\n+\t    if (CLASS_LIKELY_SPILLED_P (REG_CLASS_FROM_LETTER ((unsigned char) c)))\n \t      likely_spilled[op_no] = 1;\n \t    break;\n \t  }\n@@ -1922,7 +1922,7 @@ fixup_match_1 (insn, set, src, src_subreg, dst, backward, operand_number,\n \n       if (note && CONSTANT_P (XEXP (note, 0)))\n \t{\n-\t  for (q = PREV_INSN (insn); q; q = PREV_INSN(q))\n+\t  for (q = PREV_INSN (insn); q; q = PREV_INSN (q))\n \t    {\n \t      /* ??? We can't scan past the end of a basic block without\n \t\t updating the register lifetime info"}, {"sha": "521e482394282a3fdeab2ad174953ba546da11f5", "filename": "gcc/reload1.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e2e89f78ac366d74ac9a0e75afe056073589ef1/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e2e89f78ac366d74ac9a0e75afe056073589ef1/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=8e2e89f78ac366d74ac9a0e75afe056073589ef1", "patch": "@@ -366,9 +366,9 @@ static int (*offsets_at)[NUM_ELIMINABLE_REGS];\n \n static int num_labels;\n \f\n-static void replace_pseudos_in_call_usage\tPARAMS((rtx *,\n-\t\t\t\t\t\t\tenum machine_mode,\n-\t\t\t\t\t\t\trtx));\n+static void replace_pseudos_in_call_usage\tPARAMS ((rtx *,\n+\t\t\t\t\t\t\t enum machine_mode,\n+\t\t\t\t\t\t\t rtx));\n static void maybe_fix_stack_asms\tPARAMS ((void));\n static void copy_reloads\t\tPARAMS ((struct insn_chain *));\n static void calculate_needs_all_insns\tPARAMS ((int));\n@@ -4058,7 +4058,7 @@ reload_as_needed (live_known)\n       /* Don't assume a reload reg is still good after a call insn\n \t if it is a call-used reg.  */\n       else if (GET_CODE (insn) == CALL_INSN)\n-\tAND_COMPL_HARD_REG_SET(reg_reloaded_valid, call_used_reg_set);\n+\tAND_COMPL_HARD_REG_SET (reg_reloaded_valid, call_used_reg_set);\n     }\n \n   /* Clean up.  */\n@@ -5317,7 +5317,7 @@ choose_reload_regs (chain)\n \t{\n \t  max_group_size = MAX (rld[j].nregs, max_group_size);\n \t  group_class\n-\t    = reg_class_superunion[(int) rld[j].class][(int)group_class];\n+\t    = reg_class_superunion[(int) rld[j].class][(int) group_class];\n \t}\n \n       save_reload_reg_rtx[j] = rld[j].reg_rtx;\n@@ -8347,8 +8347,8 @@ reload_cse_simplify_operands (insn)\n   alternative_reject = (int *) alloca (recog_data.n_alternatives * sizeof (int));\n   alternative_nregs = (int *) alloca (recog_data.n_alternatives * sizeof (int));\n   alternative_order = (int *) alloca (recog_data.n_alternatives * sizeof (int));\n-  memset ((char *)alternative_reject, 0, recog_data.n_alternatives * sizeof (int));\n-  memset ((char *)alternative_nregs, 0, recog_data.n_alternatives * sizeof (int));\n+  memset ((char *) alternative_reject, 0, recog_data.n_alternatives * sizeof (int));\n+  memset ((char *) alternative_nregs, 0, recog_data.n_alternatives * sizeof (int));\n \n   /* For each operand, find out which regs are equivalent.  */\n   for (i = 0; i < recog_data.n_operands; i++)\n@@ -8451,7 +8451,7 @@ reload_cse_simplify_operands (insn)\n \n \t\tdefault:\n \t\t  class\n-\t\t    = reg_class_subunion[(int) class][(int) REG_CLASS_FROM_LETTER ((unsigned char)c)];\n+\t\t    = reg_class_subunion[(int) class][(int) REG_CLASS_FROM_LETTER ((unsigned char) c)];\n \t\t  break;\n \n \t\tcase ',': case '\\0':"}, {"sha": "3af6da7e78c2d4a4ae60eda5ec68cb3a83779bba", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e2e89f78ac366d74ac9a0e75afe056073589ef1/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e2e89f78ac366d74ac9a0e75afe056073589ef1/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=8e2e89f78ac366d74ac9a0e75afe056073589ef1", "patch": "@@ -1410,7 +1410,7 @@ reg_overlap_mentioned_p (x, in)\n     do_reg:\n       endregno = regno + (regno < FIRST_PSEUDO_REGISTER\n \t\t\t  ? HARD_REGNO_NREGS (regno, GET_MODE (x)) : 1);\n-      return refers_to_regno_p (regno, endregno, in, (rtx*)0);\n+      return refers_to_regno_p (regno, endregno, in, (rtx*) 0);\n \n     case MEM:\n       {\n@@ -1857,7 +1857,7 @@ find_reg_fusage (insn, code, datum)\n     return 0;\n \n   if (! datum)\n-    abort();\n+    abort ();\n \n   if (GET_CODE (datum) != REG)\n     {"}]}