{"sha": "13f44099bcc64ddb50a6dbd462bf79b258dfd02c", "node_id": "C_kwDOANBUbNoAKDEzZjQ0MDk5YmNjNjRkZGI1MGE2ZGJkNDYyYmY3OWIyNThkZmQwMmM", "commit": {"author": {"name": "Tamar Christina", "email": "tamar.christina@arm.com", "date": "2022-07-08T06:37:20Z"}, "committer": {"name": "Tamar Christina", "email": "tamar.christina@arm.com", "date": "2022-07-08T06:39:33Z"}, "message": "middle-end: Use subregs to expand COMPLEX_EXPR to set the lowpart.\n\nWhen lowering COMPLEX_EXPR we currently emit two VEC_EXTRACTs.  One for the\nlowpart and one for the highpart.\n\nThe problem with this is that in RTL the lvalue of the RTX is the only thing\ntying the two instructions together.\n\nThis means that e.g. combine is unable to try to combine the two instructions\nfor setting the lowpart and highpart.\n\nFor ISAs that have bit extract instructions we can eliminate one of the extracts\nif, and only if we're setting the entire complex number.\n\nThis change changes the expand code when we're setting the entire complex number\nto generate a subreg for the lowpart instead of a vec_extract.\n\nThis allows us to optimize sequences such as:\n\n_Complex int f(int a, int b) {\n    _Complex int t = a + b * 1i;\n    return t;\n}\n\nfrom:\n\nf:\n\tbfi     x2, x0, 0, 32\n\tbfi     x2, x1, 32, 32\n\tmov     x0, x2\n\tret\n\ninto:\n\nf:\n\tbfi\tx0, x1, 32, 32\n\tret\n\nI have also confirmed the codegen for x86_64 did not change.\n\ngcc/ChangeLog:\n\n\t* expmed.cc (store_bit_field_1): Add parameter that indicates if value is\n\tstill undefined and if so emit a subreg move instead.\n\t(store_integral_bit_field): Likewise.\n\t(store_bit_field): Likewise.\n\t* expr.h (write_complex_part): Likewise.\n\t* expmed.h (store_bit_field): Add new parameter.\n\t* builtins.cc (expand_ifn_atomic_compare_exchange_into_call): Use new\n\tparameter.\n\t(expand_ifn_atomic_compare_exchange): Likewise.\n\t* calls.cc (store_unaligned_arguments_into_pseudos): Likewise.\n\t* emit-rtl.cc (validate_subreg): Likewise.\n\t* expr.cc (emit_group_store): Likewise.\n\t(copy_blkmode_from_reg): Likewise.\n\t(copy_blkmode_to_reg): Likewise.\n\t(clear_storage_hints): Likewise.\n\t(write_complex_part):  Likewise.\n\t(emit_move_complex_parts): Likewise.\n\t(expand_assignment): Likewise.\n\t(store_expr): Likewise.\n\t(store_field): Likewise.\n\t(expand_expr_real_2): Likewise.\n\t* ifcvt.cc (noce_emit_move_insn): Likewise.\n\t* internal-fn.cc (expand_arith_set_overflow): Likewise.\n\t(expand_arith_overflow_result_store): Likewise.\n\t(expand_addsub_overflow): Likewise.\n\t(expand_neg_overflow): Likewise.\n\t(expand_mul_overflow): Likewise.\n\t(expand_arith_overflow): Likewise.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.target/aarch64/complex-init.C: New test.", "tree": {"sha": "7ea840cf4915eabc7761e0c1bc3989a9c3859bba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7ea840cf4915eabc7761e0c1bc3989a9c3859bba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/13f44099bcc64ddb50a6dbd462bf79b258dfd02c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13f44099bcc64ddb50a6dbd462bf79b258dfd02c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13f44099bcc64ddb50a6dbd462bf79b258dfd02c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13f44099bcc64ddb50a6dbd462bf79b258dfd02c/comments", "author": {"login": "TamarChristinaArm", "id": 48126768, "node_id": "MDQ6VXNlcjQ4MTI2NzY4", "avatar_url": "https://avatars.githubusercontent.com/u/48126768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TamarChristinaArm", "html_url": "https://github.com/TamarChristinaArm", "followers_url": "https://api.github.com/users/TamarChristinaArm/followers", "following_url": "https://api.github.com/users/TamarChristinaArm/following{/other_user}", "gists_url": "https://api.github.com/users/TamarChristinaArm/gists{/gist_id}", "starred_url": "https://api.github.com/users/TamarChristinaArm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TamarChristinaArm/subscriptions", "organizations_url": "https://api.github.com/users/TamarChristinaArm/orgs", "repos_url": "https://api.github.com/users/TamarChristinaArm/repos", "events_url": "https://api.github.com/users/TamarChristinaArm/events{/privacy}", "received_events_url": "https://api.github.com/users/TamarChristinaArm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TamarChristinaArm", "id": 48126768, "node_id": "MDQ6VXNlcjQ4MTI2NzY4", "avatar_url": "https://avatars.githubusercontent.com/u/48126768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TamarChristinaArm", "html_url": "https://github.com/TamarChristinaArm", "followers_url": "https://api.github.com/users/TamarChristinaArm/followers", "following_url": "https://api.github.com/users/TamarChristinaArm/following{/other_user}", "gists_url": "https://api.github.com/users/TamarChristinaArm/gists{/gist_id}", "starred_url": "https://api.github.com/users/TamarChristinaArm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TamarChristinaArm/subscriptions", "organizations_url": "https://api.github.com/users/TamarChristinaArm/orgs", "repos_url": "https://api.github.com/users/TamarChristinaArm/repos", "events_url": "https://api.github.com/users/TamarChristinaArm/events{/privacy}", "received_events_url": "https://api.github.com/users/TamarChristinaArm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bf3695691f4fc964a3b1c8274a6949d844e3edff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf3695691f4fc964a3b1c8274a6949d844e3edff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf3695691f4fc964a3b1c8274a6949d844e3edff"}], "stats": {"total": 150, "additions": 99, "deletions": 51}, "files": [{"sha": "35b9197945fdc8ba44a8b02a871490ed384a4927", "filename": "gcc/builtins.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13f44099bcc64ddb50a6dbd462bf79b258dfd02c/gcc%2Fbuiltins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13f44099bcc64ddb50a6dbd462bf79b258dfd02c/gcc%2Fbuiltins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.cc?ref=13f44099bcc64ddb50a6dbd462bf79b258dfd02c", "patch": "@@ -6029,8 +6029,8 @@ expand_ifn_atomic_compare_exchange_into_call (gcall *call, machine_mode mode)\n       if (GET_MODE (boolret) != mode)\n \tboolret = convert_modes (mode, GET_MODE (boolret), boolret, 1);\n       x = force_reg (mode, x);\n-      write_complex_part (target, boolret, true);\n-      write_complex_part (target, x, false);\n+      write_complex_part (target, boolret, true, true);\n+      write_complex_part (target, x, false, false);\n     }\n }\n \n@@ -6085,8 +6085,8 @@ expand_ifn_atomic_compare_exchange (gcall *call)\n       rtx target = expand_expr (lhs, NULL_RTX, VOIDmode, EXPAND_WRITE);\n       if (GET_MODE (boolret) != mode)\n \tboolret = convert_modes (mode, GET_MODE (boolret), boolret, 1);\n-      write_complex_part (target, boolret, true);\n-      write_complex_part (target, oldval, false);\n+      write_complex_part (target, boolret, true, true);\n+      write_complex_part (target, oldval, false, false);\n     }\n }\n "}, {"sha": "bc96aff38f063cad2d7484babb16d80781e304e5", "filename": "gcc/calls.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13f44099bcc64ddb50a6dbd462bf79b258dfd02c/gcc%2Fcalls.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13f44099bcc64ddb50a6dbd462bf79b258dfd02c/gcc%2Fcalls.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.cc?ref=13f44099bcc64ddb50a6dbd462bf79b258dfd02c", "patch": "@@ -1226,7 +1226,7 @@ store_unaligned_arguments_into_pseudos (struct arg_data *args, int num_actuals)\n \n \t    bytes -= bitsize / BITS_PER_UNIT;\n \t    store_bit_field (reg, bitsize, endian_correction, 0, 0,\n-\t\t\t     word_mode, word, false);\n+\t\t\t     word_mode, word, false, false);\n \t  }\n       }\n }"}, {"sha": "3929ee08986cb9137dada62b0edcc30ed81cc1a4", "filename": "gcc/emit-rtl.cc", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13f44099bcc64ddb50a6dbd462bf79b258dfd02c/gcc%2Femit-rtl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13f44099bcc64ddb50a6dbd462bf79b258dfd02c/gcc%2Femit-rtl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.cc?ref=13f44099bcc64ddb50a6dbd462bf79b258dfd02c", "patch": "@@ -947,9 +947,11 @@ validate_subreg (machine_mode omode, machine_mode imode,\n \t   && GET_MODE_INNER (omode) == GET_MODE_INNER (imode))\n     ;\n   /* Subregs involving floating point modes are not allowed to\n-     change size.  Therefore (subreg:DI (reg:DF) 0) is fine, but\n+     change size unless it's an insert into a complex mode.\n+     Therefore (subreg:DI (reg:DF) 0) and (subreg:CS (reg:SF) 0) are fine, but\n      (subreg:SI (reg:DF) 0) isn't.  */\n-  else if (FLOAT_MODE_P (imode) || FLOAT_MODE_P (omode))\n+  else if ((FLOAT_MODE_P (imode) || FLOAT_MODE_P (omode))\n+\t   && !COMPLEX_MODE_P (omode))\n     {\n       if (! (known_eq (isize, osize)\n \t     /* LRA can use subreg to store a floating point value in"}, {"sha": "9b01b5a51e797e18daa2f312f9bdb8f74bcf1ed9", "filename": "gcc/expmed.cc", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13f44099bcc64ddb50a6dbd462bf79b258dfd02c/gcc%2Fexpmed.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13f44099bcc64ddb50a6dbd462bf79b258dfd02c/gcc%2Fexpmed.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.cc?ref=13f44099bcc64ddb50a6dbd462bf79b258dfd02c", "patch": "@@ -738,13 +738,16 @@ store_bit_field_using_insv (const extraction_insn *insv, rtx op0,\n \n    If FALLBACK_P is true, fall back to store_fixed_bit_field if we have\n    no other way of implementing the operation.  If FALLBACK_P is false,\n-   return false instead.  */\n+   return false instead.\n+\n+   if UNDEFINED_P is true then STR_RTX is undefined and may be set using\n+   a subreg instead.  */\n \n static bool\n store_bit_field_1 (rtx str_rtx, poly_uint64 bitsize, poly_uint64 bitnum,\n \t\t   poly_uint64 bitregion_start, poly_uint64 bitregion_end,\n \t\t   machine_mode fieldmode,\n-\t\t   rtx value, bool reverse, bool fallback_p)\n+\t\t   rtx value, bool reverse, bool fallback_p, bool undefined_p)\n {\n   rtx op0 = str_rtx;\n \n@@ -805,8 +808,9 @@ store_bit_field_1 (rtx str_rtx, poly_uint64 bitsize, poly_uint64 bitnum,\n \t      return true;\n \t    }\n \t}\n-      else if (constant_multiple_p (bitnum, regsize * BITS_PER_UNIT, &regnum)\n-\t       && multiple_p (bitsize, regsize * BITS_PER_UNIT)\n+      else if (((constant_multiple_p (bitnum, regsize * BITS_PER_UNIT, &regnum)\n+\t\t && multiple_p (bitsize, regsize * BITS_PER_UNIT))\n+\t\t|| undefined_p)\n \t       && known_ge (GET_MODE_BITSIZE (GET_MODE (op0)), bitsize))\n \t{\n \t  sub = simplify_gen_subreg (fieldmode, op0, GET_MODE (op0),\n@@ -869,7 +873,7 @@ store_bit_field_1 (rtx str_rtx, poly_uint64 bitsize, poly_uint64 bitnum,\n \t\t\t\t\tGET_MODE_SIZE (GET_MODE (op0)));\n \t  emit_move_insn (temp, op0);\n \t  store_bit_field_1 (temp, bitsize, bitnum, 0, 0, fieldmode, value,\n-\t\t\t     reverse, fallback_p);\n+\t\t\t     reverse, fallback_p, undefined_p);\n \t  emit_move_insn (op0, temp);\n \t  return true;\n \t}\n@@ -994,7 +998,7 @@ store_integral_bit_field (rtx op0, opt_scalar_int_mode op0_mode,\n \t\t\t\t  bitnum + bit_offset,\n \t\t\t\t  bitregion_start, bitregion_end,\n \t\t\t\t  word_mode,\n-\t\t\t\t  value_word, reverse, fallback_p))\n+\t\t\t\t  value_word, reverse, fallback_p, false))\n \t    {\n \t      delete_insns_since (last);\n \t      return false;\n@@ -1084,7 +1088,7 @@ store_integral_bit_field (rtx op0, opt_scalar_int_mode op0_mode,\n \t  rtx tempreg = copy_to_reg (xop0);\n \t  if (store_bit_field_1 (tempreg, bitsize, bitpos,\n \t\t\t\t bitregion_start, bitregion_end,\n-\t\t\t\t fieldmode, orig_value, reverse, false))\n+\t\t\t\t fieldmode, orig_value, reverse, false, false))\n \t    {\n \t      emit_move_insn (xop0, tempreg);\n \t      return true;\n@@ -1112,13 +1116,15 @@ store_integral_bit_field (rtx op0, opt_scalar_int_mode op0_mode,\n \n    FIELDMODE is the machine-mode of the FIELD_DECL node for this field.\n \n-   If REVERSE is true, the store is to be done in reverse order.  */\n+   If REVERSE is true, the store is to be done in reverse order.\n+\n+   If UNDEFINED_P is true then STR_RTX is currently undefined.  */\n \n void\n store_bit_field (rtx str_rtx, poly_uint64 bitsize, poly_uint64 bitnum,\n \t\t poly_uint64 bitregion_start, poly_uint64 bitregion_end,\n \t\t machine_mode fieldmode,\n-\t\t rtx value, bool reverse)\n+\t\t rtx value, bool reverse, bool undefined_p)\n {\n   /* Handle -fstrict-volatile-bitfields in the cases where it applies.  */\n   unsigned HOST_WIDE_INT ibitsize = 0, ibitnum = 0;\n@@ -1151,7 +1157,7 @@ store_bit_field (rtx str_rtx, poly_uint64 bitsize, poly_uint64 bitnum,\n \t  gcc_assert (ibitnum + ibitsize <= GET_MODE_BITSIZE (int_mode));\n \t  temp = copy_to_reg (str_rtx);\n \t  if (!store_bit_field_1 (temp, ibitsize, ibitnum, 0, 0,\n-\t\t\t\t  int_mode, value, reverse, true))\n+\t\t\t\t  int_mode, value, reverse, true, undefined_p))\n \t    gcc_unreachable ();\n \n \t  emit_move_insn (str_rtx, temp);\n@@ -1186,7 +1192,7 @@ store_bit_field (rtx str_rtx, poly_uint64 bitsize, poly_uint64 bitnum,\n \n   if (!store_bit_field_1 (str_rtx, bitsize, bitnum,\n \t\t\t  bitregion_start, bitregion_end,\n-\t\t\t  fieldmode, value, reverse, true))\n+\t\t\t  fieldmode, value, reverse, true, undefined_p))\n     gcc_unreachable ();\n }\n \f"}, {"sha": "0b2538c4c6bd51dfdc772ef70bdf631c0bed8717", "filename": "gcc/expmed.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13f44099bcc64ddb50a6dbd462bf79b258dfd02c/gcc%2Fexpmed.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13f44099bcc64ddb50a6dbd462bf79b258dfd02c/gcc%2Fexpmed.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.h?ref=13f44099bcc64ddb50a6dbd462bf79b258dfd02c", "patch": "@@ -715,7 +715,7 @@ extern rtx expand_divmod (int, enum tree_code, machine_mode, rtx, rtx,\n \n extern void store_bit_field (rtx, poly_uint64, poly_uint64,\n \t\t\t     poly_uint64, poly_uint64,\n-\t\t\t     machine_mode, rtx, bool);\n+\t\t\t     machine_mode, rtx, bool, bool);\n extern rtx extract_bit_field (rtx, poly_uint64, poly_uint64, int, rtx,\n \t\t\t      machine_mode, machine_mode, bool, rtx *);\n extern rtx extract_low_bits (machine_mode, machine_mode, rtx);"}, {"sha": "eb280e6cac3b1e7f2f9d001b1405633d1e3321c9", "filename": "gcc/expr.cc", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13f44099bcc64ddb50a6dbd462bf79b258dfd02c/gcc%2Fexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13f44099bcc64ddb50a6dbd462bf79b258dfd02c/gcc%2Fexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.cc?ref=13f44099bcc64ddb50a6dbd462bf79b258dfd02c", "patch": "@@ -2891,7 +2891,7 @@ emit_group_store (rtx orig_dst, rtx src, tree type ATTRIBUTE_UNUSED,\n \t  store_bit_field (dest,\n \t\t\t   adj_bytelen * BITS_PER_UNIT, bytepos * BITS_PER_UNIT,\n \t\t\t   bytepos * BITS_PER_UNIT, ssize * BITS_PER_UNIT - 1,\n-\t\t\t   VOIDmode, tmps[i], false);\n+\t\t\t   VOIDmode, tmps[i], false, false);\n \t}\n \n       /* Optimize the access just a bit.  */\n@@ -2905,7 +2905,7 @@ emit_group_store (rtx orig_dst, rtx src, tree type ATTRIBUTE_UNUSED,\n \n       else\n \tstore_bit_field (dest, bytelen * BITS_PER_UNIT, bytepos * BITS_PER_UNIT,\n-\t\t\t 0, 0, mode, tmps[i], false);\n+\t\t\t 0, 0, mode, tmps[i], false, false);\n     }\n \n   /* Copy from the pseudo into the (probable) hard reg.  */\n@@ -3038,7 +3038,7 @@ copy_blkmode_from_reg (rtx target, rtx srcreg, tree type)\n \t\t\t\t\t  xbitpos % BITS_PER_WORD, 1,\n \t\t\t\t\t  NULL_RTX, copy_mode, copy_mode,\n \t\t\t\t\t  false, NULL),\n-\t\t       false);\n+\t\t       false, false);\n     }\n }\n \n@@ -3140,7 +3140,7 @@ copy_blkmode_to_reg (machine_mode mode_in, tree src)\n \t\t\t\t\t  bitpos % BITS_PER_WORD, 1,\n \t\t\t\t\t  NULL_RTX, word_mode, word_mode,\n \t\t\t\t\t  false, NULL),\n-\t\t       false);\n+\t\t       false, false);\n     }\n \n   if (mode == BLKmode)\n@@ -3308,8 +3308,8 @@ clear_storage_hints (rtx object, rtx size, enum block_op_methods method,\n \t  zero = CONST0_RTX (GET_MODE_INNER (mode));\n \t  if (zero != NULL)\n \t    {\n-\t      write_complex_part (object, zero, 0);\n-\t      write_complex_part (object, zero, 1);\n+\t      write_complex_part (object, zero, 0, true);\n+\t      write_complex_part (object, zero, 1, false);\n \t      return NULL;\n \t    }\n \t}\n@@ -3470,10 +3470,11 @@ set_storage_via_setmem (rtx object, rtx size, rtx val, unsigned int align,\n \n \f\n /* Write to one of the components of the complex value CPLX.  Write VAL to\n-   the real part if IMAG_P is false, and the imaginary part if its true.  */\n+   the real part if IMAG_P is false, and the imaginary part if its true.\n+   If UNDEFINED_P then the value in CPLX is currently undefined.  */\n \n void\n-write_complex_part (rtx cplx, rtx val, bool imag_p)\n+write_complex_part (rtx cplx, rtx val, bool imag_p, bool undefined_p)\n {\n   machine_mode cmode;\n   scalar_mode imode;\n@@ -3528,7 +3529,7 @@ write_complex_part (rtx cplx, rtx val, bool imag_p)\n     }\n \n   store_bit_field (cplx, ibitsize, imag_p ? ibitsize : 0, 0, 0, imode, val,\n-\t\t   false);\n+\t\t   false, undefined_p);\n }\n \n /* Extract one of the components of the complex value CPLX.  Extract the\n@@ -3781,8 +3782,8 @@ emit_move_complex_parts (rtx x, rtx y)\n       && REG_P (x) && !reg_overlap_mentioned_p (x, y))\n     emit_clobber (x);\n \n-  write_complex_part (x, read_complex_part (y, false), false);\n-  write_complex_part (x, read_complex_part (y, true), true);\n+  write_complex_part (x, read_complex_part (y, false), false, true);\n+  write_complex_part (x, read_complex_part (y, true), true, false);\n \n   return get_last_insn ();\n }\n@@ -5441,7 +5442,7 @@ expand_assignment (tree to, tree from, bool nontemporal)\n \t}\n       else\n \tstore_bit_field (mem, GET_MODE_BITSIZE (mode), 0, 0, 0, mode, reg,\n-\t\t\t false);\n+\t\t\t false, false);\n       return;\n     }\n \n@@ -5663,8 +5664,8 @@ expand_assignment (tree to, tree from, bool nontemporal)\n \t    concat_store_slow:;\n \t      rtx temp = assign_stack_temp (GET_MODE (to_rtx),\n \t\t\t\t\t    GET_MODE_SIZE (GET_MODE (to_rtx)));\n-\t      write_complex_part (temp, XEXP (to_rtx, 0), false);\n-\t      write_complex_part (temp, XEXP (to_rtx, 1), true);\n+\t      write_complex_part (temp, XEXP (to_rtx, 0), false, true);\n+\t      write_complex_part (temp, XEXP (to_rtx, 1), true, false);\n \t      result = store_field (temp, bitsize, bitpos,\n \t\t\t\t    bitregion_start, bitregion_end,\n \t\t\t\t    mode1, from, get_alias_set (to),\n@@ -6222,7 +6223,8 @@ store_expr (tree exp, rtx target, int call_param_p,\n \t\tstore_bit_field (target,\n \t\t\t\t rtx_to_poly_int64 (expr_size (exp))\n \t\t\t\t * BITS_PER_UNIT,\n-\t\t\t\t 0, 0, 0, GET_MODE (temp), temp, reverse);\n+\t\t\t\t 0, 0, 0, GET_MODE (temp), temp, reverse,\n+\t\t\t\t false);\n \t    }\n \t  else\n \t    convert_move (target, temp, TYPE_UNSIGNED (TREE_TYPE (exp)));\n@@ -7631,7 +7633,7 @@ store_field (rtx target, poly_int64 bitsize, poly_int64 bitpos,\n       gcc_checking_assert (known_ge (bitpos, 0));\n       store_bit_field (target, bitsize, bitpos,\n \t\t       bitregion_start, bitregion_end,\n-\t\t       mode, temp, reverse);\n+\t\t       mode, temp, reverse, false);\n \n       return const0_rtx;\n     }\n@@ -10120,8 +10122,8 @@ expand_expr_real_2 (sepops ops, rtx target, machine_mode tmode,\n \t      complex_expr_swap_order:\n \t\t/* Move the imaginary (op1) and real (op0) parts to their\n \t\t   location.  */\n-\t\twrite_complex_part (target, op1, true);\n-\t\twrite_complex_part (target, op0, false);\n+\t\twrite_complex_part (target, op1, true, true);\n+\t\twrite_complex_part (target, op0, false, false);\n \n \t\treturn target;\n \t      }\n@@ -10150,8 +10152,8 @@ expand_expr_real_2 (sepops ops, rtx target, machine_mode tmode,\n \t  }\n \n       /* Move the real (op0) and imaginary (op1) parts to their location.  */\n-      write_complex_part (target, op0, false);\n-      write_complex_part (target, op1, true);\n+      write_complex_part (target, op0, false, true);\n+      write_complex_part (target, op1, true, false);\n \n       return target;\n \n@@ -10390,7 +10392,7 @@ expand_expr_real_2 (sepops ops, rtx target, machine_mode tmode,\n \trtx dst = gen_reg_rtx (mode);\n \temit_move_insn (dst, op0);\n \tstore_bit_field (dst, bitsize, bitpos, 0, 0,\n-\t\t\t TYPE_MODE (TREE_TYPE (treeop1)), op1, false);\n+\t\t\t TYPE_MODE (TREE_TYPE (treeop1)), op1, false, false);\n \treturn dst;\n       }\n "}, {"sha": "08b59b8d869a6289c364eee00084ce1bc9357000", "filename": "gcc/expr.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13f44099bcc64ddb50a6dbd462bf79b258dfd02c/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13f44099bcc64ddb50a6dbd462bf79b258dfd02c/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=13f44099bcc64ddb50a6dbd462bf79b258dfd02c", "patch": "@@ -262,7 +262,7 @@ extern rtx_insn *emit_move_insn_1 (rtx, rtx);\n extern rtx_insn *emit_move_complex_push (machine_mode, rtx, rtx);\n extern rtx_insn *emit_move_complex_parts (rtx, rtx);\n extern rtx read_complex_part (rtx, bool);\n-extern void write_complex_part (rtx, rtx, bool);\n+extern void write_complex_part (rtx, rtx, bool, bool);\n extern rtx read_complex_part (rtx, bool);\n extern rtx emit_move_resolve_push (machine_mode, rtx);\n "}, {"sha": "2e8ab396e266691252b9058918a017683fd56aa4", "filename": "gcc/ifcvt.cc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13f44099bcc64ddb50a6dbd462bf79b258dfd02c/gcc%2Fifcvt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13f44099bcc64ddb50a6dbd462bf79b258dfd02c/gcc%2Fifcvt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.cc?ref=13f44099bcc64ddb50a6dbd462bf79b258dfd02c", "patch": "@@ -999,7 +999,8 @@ noce_emit_move_insn (rtx x, rtx y)\n \t\t}\n \n \t      gcc_assert (start < (MEM_P (op) ? BITS_PER_UNIT : BITS_PER_WORD));\n-\t      store_bit_field (op, size, start, 0, 0, GET_MODE (x), y, false);\n+\t      store_bit_field (op, size, start, 0, 0, GET_MODE (x), y, false,\n+\t\t\t       false);\n \t      return;\n \t    }\n \n@@ -1056,7 +1057,7 @@ noce_emit_move_insn (rtx x, rtx y)\n   outmode = GET_MODE (outer);\n   bitpos = SUBREG_BYTE (outer) * BITS_PER_UNIT;\n   store_bit_field (inner, GET_MODE_BITSIZE (outmode), bitpos,\n-\t\t   0, 0, outmode, y, false);\n+\t\t   0, 0, outmode, y, false, false);\n }\n \n /* Return the CC reg if it is used in COND.  */"}, {"sha": "d666ccccf670b5c639c5ae21659aae4e3f789f6a", "filename": "gcc/internal-fn.cc", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13f44099bcc64ddb50a6dbd462bf79b258dfd02c/gcc%2Finternal-fn.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13f44099bcc64ddb50a6dbd462bf79b258dfd02c/gcc%2Finternal-fn.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.cc?ref=13f44099bcc64ddb50a6dbd462bf79b258dfd02c", "patch": "@@ -815,9 +815,9 @@ expand_arith_set_overflow (tree lhs, rtx target)\n {\n   if (TYPE_PRECISION (TREE_TYPE (TREE_TYPE (lhs))) == 1\n       && !TYPE_UNSIGNED (TREE_TYPE (TREE_TYPE (lhs))))\n-    write_complex_part (target, constm1_rtx, true);\n+    write_complex_part (target, constm1_rtx, true, false);\n   else\n-    write_complex_part (target, const1_rtx, true);\n+    write_complex_part (target, const1_rtx, true, false);\n }\n \n /* Helper for expand_*_overflow.  Store RES into the __real__ part\n@@ -872,7 +872,7 @@ expand_arith_overflow_result_store (tree lhs, rtx target,\n       expand_arith_set_overflow (lhs, target);\n       emit_label (done_label);\n     }\n-  write_complex_part (target, lres, false);\n+  write_complex_part (target, lres, false, false);\n }\n \n /* Helper for expand_*_overflow.  Store RES into TARGET.  */\n@@ -917,7 +917,7 @@ expand_addsub_overflow (location_t loc, tree_code code, tree lhs,\n     {\n       target = expand_expr (lhs, NULL_RTX, VOIDmode, EXPAND_WRITE);\n       if (!is_ubsan)\n-\twrite_complex_part (target, const0_rtx, true);\n+\twrite_complex_part (target, const0_rtx, true, false);\n     }\n \n   /* We assume both operands and result have the same precision\n@@ -1362,7 +1362,7 @@ expand_neg_overflow (location_t loc, tree lhs, tree arg1, bool is_ubsan,\n     {\n       target = expand_expr (lhs, NULL_RTX, VOIDmode, EXPAND_WRITE);\n       if (!is_ubsan)\n-\twrite_complex_part (target, const0_rtx, true);\n+\twrite_complex_part (target, const0_rtx, true, false);\n     }\n \n   enum insn_code icode = optab_handler (negv3_optab, mode);\n@@ -1487,7 +1487,7 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n     {\n       target = expand_expr (lhs, NULL_RTX, VOIDmode, EXPAND_WRITE);\n       if (!is_ubsan)\n-\twrite_complex_part (target, const0_rtx, true);\n+\twrite_complex_part (target, const0_rtx, true, false);\n     }\n \n   if (is_ubsan)\n@@ -2304,7 +2304,7 @@ expand_mul_overflow (location_t loc, tree lhs, tree arg0, tree arg1,\n       do_compare_rtx_and_jump (op1, res, NE, true, mode, NULL_RTX, NULL,\n \t\t\t       all_done_label, profile_probability::very_unlikely ());\n       emit_label (set_noovf);\n-      write_complex_part (target, const0_rtx, true);\n+      write_complex_part (target, const0_rtx, true, false);\n       emit_label (all_done_label);\n     }\n \n@@ -2573,7 +2573,7 @@ expand_arith_overflow (enum tree_code code, gimple *stmt)\n \t{\n \t  /* The infinity precision result will always fit into result.  */\n \t  rtx target = expand_expr (lhs, NULL_RTX, VOIDmode, EXPAND_WRITE);\n-\t  write_complex_part (target, const0_rtx, true);\n+\t  write_complex_part (target, const0_rtx, true, false);\n \t  scalar_int_mode mode = SCALAR_INT_TYPE_MODE (type);\n \t  struct separate_ops ops;\n \t  ops.code = code;"}, {"sha": "c3637d898243626a2da20426b868932c05648a54", "filename": "gcc/testsuite/g++.target/aarch64/complex-init.C", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13f44099bcc64ddb50a6dbd462bf79b258dfd02c/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fcomplex-init.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13f44099bcc64ddb50a6dbd462bf79b258dfd02c/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fcomplex-init.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fcomplex-init.C?ref=13f44099bcc64ddb50a6dbd462bf79b258dfd02c", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" \"\" { target { le } } } } */\n+\n+/*\n+** _Z1fii:\n+** ...\n+** \tbfi\tx0, x1, 32, 32\n+** \tret\n+*/\n+_Complex int f(int a, int b) {\n+    _Complex int t = a + b * 1i;\n+    return t;\n+}\n+\n+/*\n+** _Z2f2ii:\n+** ...\n+** \tbfi\tx0, x1, 32, 32\n+** \tret\n+*/\n+_Complex int f2(int a, int b) {\n+    _Complex int t = {a, b};\n+    return t;\n+}\n+\n+/* \n+** _Z12f_convolutedii:\n+** ...\n+** \tbfi\tx0, x1, 32, 32\n+** \tret\n+*/\n+_Complex int f_convoluted(int a, int b) {\n+    _Complex int t = (_Complex int)a;\n+    __imag__ t = b;\n+    return t;\n+}"}]}