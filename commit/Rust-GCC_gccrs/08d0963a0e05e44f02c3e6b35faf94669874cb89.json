{"sha": "08d0963a0e05e44f02c3e6b35faf94669874cb89", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDhkMDk2M2EwZTA1ZTQ0ZjAyYzNlNmIzNWZhZjk0NjY5ODc0Y2I4OQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2008-08-09T19:08:15Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2008-08-09T19:08:15Z"}, "message": "configure.ac (mips*-*-*linux*, [...]): Use mt-mips-gnu.\n\n\t* configure.ac (mips*-*-*linux*, mips*-*-gnu*): Use mt-mips-gnu.\n\t* configure: Regenerate.\n\nconfig/\n\t* mt-mips16-compat: New file, taken from mt-mips-elfoabi.\n\t* mt-mips-elfoabi: Include mt-mips16-compat.\n\t* mt-mips-gnu: New file.\n\ngcc/\n\t* config.gcc (mips*-*-linux*, mips64*-*-linux*): Add\n\tmips/t-libgcc-mips16 to tmake_file.\n\t* config/mips/mips-protos.h (mips_call_type): New enum.\n\t(mips_pic_base_register, mips_got_load): Declare.\n\t(mips_restore_gp): Take an rtx argument.\n\t(mips_use_pic_fn_addr_reg_p): Declare.\n\t(mips_expand_call): Replace the sibcall_p argument with\n\ta mips_call_type argument.  Add a lazy_p parameter.\n\t(mips_split_call): Declare.\n\t* config/mips/mips.h (MIPS16_PIC_TEMP_REGNUM): New macro.\n\t(MIPS16_PIC_TEMP): Likewise.\n\t(reg_class): Delete M16_NA_REGS.\n\t(REG_CLASS_NAMES, REG_CLASS_CONTENTS): Update accordingly.\n\t(SYMBOL_FLAG_BIND_NOW, SYMBOL_REF_BIND_NOW_P): New macros.\n\t(mips_split_hi_p): Declare.\n\t* config/mips/mips.c (mips_split_hi_p): New array.\n\t(mips_regno_to_class): Change M16_NA_REGS entries to M16_REGS.\n\t(mips_got_symbol_type_p): New function.\n\t(mips_global_symbol_p): Check SYMBOL_REF_EXTERNAL_P.\n\t(mips16_stub_function_p): New function.\n\t(mips16_local_function_p): Likewise.\n\t(mips_use_pic_fn_addr_reg_p): Likewise.\n\t(mips_cannot_force_const_mem): Return false for HIGHs.\n\tExtend CONST_INT and symbolic handling to MIPS16, using\n\tmips_symbol_insns to check that the base symbol type is a\n\tlegitimate constant.  Reject GOT-based constants if\n\tTARGET_MIPS16_PCREL_LOADS.\n\t(mips_const_insns): Check targetm.cannot_force_const_mem when\n\tdecomposing a symbolic base and a large offset.\n\t(mips_emit_call_insn): Add ORIG_ADDR and ADDR parameters.\n\tWhen calling a function that needs $25 from MIPS16 code,\n\tmove the target address into $25 separately and add a USE\n\tto the call insn.\n\t(mips16_gp_pseudo_reg): Insert the initializer immediately\n\tbefore the first real insn.\n\t(mips_pic_base_register, mips_got_load): New functions.\n\t(mips_split_symbol): Generalize the name of the LO_SUM_OUT\n\tparameter to LOW_OUT.  Say that it can be any valid SET_SRC\n\twhen splitting a load-address operation.  Split SYMBOL_GOT_DISP\n\tconstants and highs of SYMBOL_GOT_PAGE_OFST constants.\n\t(mips_call_tls_get_addr): Update the call to mips_expand_call,\n\talso passing NULL_RTX rather than const0_rtx as the aux argument.\n\t(mips_rewrite_small_data_p): Check mips_lo_relocs and mips_split_p\n\tinstead of TARGET_EXPLICIT_RELOCS.\n\t(mips_ok_for_lazy_binding_p): Check SYMBOL_REF_BIND_NOW_P.\n\t(mips_load_call_address): Replace the sibcall_p argument with\n\ta mips_call_type argument.  Use mips_got_load.\n\t(mips16_local_alias): New structure.\n\t(mips16_local_aliases): New variable.\n\t(mips16_local_aliases_hash): New function.\n\t(mips16_local_aliases_eq): Likewise.\n\t(mips16_local_alias): Likewise.\n\t(mips16_stub_function): Likewise.\n\t(mips16_build_function_stub): Create a local alias for the target\n\tfunction.  Handle TARGET_ABICALLS.  For PIC abicalls, emit a\n\t.cpload directive and an R_MIPS_NONE relocation for the target\n\tfunction, then load the alias rather than the function itself.\n\tWrap the non-PIC abicalls version in \".option pic0/.option pic2\".\n\t(mips16_copy_fpr_return_value): Use mips16_stub_function and\n\tmips_expand_call.  Set SYMBOL_REF_BIND_NOW on the symbol.\n\t(mips16_build_call_stub): Replace the FN parameter with an\n\tFN_PTR parameter.  Force the address into a register if it\n\tisn't a call_insn_operand; don't rely on the caller to do this.\n\tIf a call to a locally-defined and locally-binding MIPS16\n\tfunction must be made indirectly, redirect the call to the\n\tfunction's local alias.  Use mips16_stub_function_p,\n\tmips16_stub_function, mips_expand_call and use_reg.\n\tSet SYMBOL_FLAG_BIND_NOW on __mips_call_* symbols.\n\tUse explicit %hi and %lo accesses where possible.\n\tUse MIPS_CALL to generate the correct code form of a\n\tjal instruction.  Add clobbers of $18 instead of uses.\n\tUpdate the call to mips_emit_call_insn.\n\t(mips_expand_call): Replace the SIBCALL_P argument with a\n\tmips_call_type argument and handle the new MIPS_CALL_EPILOGUE value.\n\tTake a LAZY_P parameter.  Call mips16_build_call_stub first,\n\tallowing it to modify the call address.  Update the calls to\n\tmips_load_call_address and mips_emit_call_insn.\n\t(mips_split_call): New function.\n\t(mips_init_relocs): Clear mips_split_hi_p.  Only use %gp_rel if\n\t!TARGET_MIPS16.  Split SYMBOL_GOT_DISP, and the high parts of\n\tSYMBOL_GOT_PAGE_OFST, for MIPS16 code.\n\t(mips_global_pointer): Check mips16_cfun_returns_in_fpr_p.\n\t(mips_extra_live_on_entry): Include MIPS16_PIC_TEMP_REGNUM\n\tif TARGET_MIPS16.\n\t(mips_cprestore_slot): New function.\n\t(mips_restore_gp): Take a TEMP parameter.  Handle TARGET_MIPS16\n\tand use mips_cprestore_slot.\n\t(mips_output_function_prologue): Handle TARGET_MIPS16 for\n\tLOADGP_OLDABI.\n\t(mips_emit_loadgp): Move into MIPS16_PIC_TEMP for MIPS16,\n\tthen use a copygp_mips16 instruction to set up $28.\n\t(mips_expand_prologue): Initialize the cprestore slot for MIPS16 too.\n\t(mips16_lay_out_constants): Call split_all_insns_noflow.\n\t(mips_reorg_process_insns): Explicitly set all_noreorder_p to\n\tfalse if TARGET_MIPS16.\n\t(mips_reorg): Don't call vr4130_align_insns if TARGET_MIPS16.\n\t(mips_output_mi_thunk): Use mips_got_symbol_type_p.  Use the\n\tmips_dangerous_for_la25_p approach for MIPS16 PIC calls too.\n\t(mips_set_mips16_mode): Always set MASK_EXPLICIT_RELOCS for\n\tMIPS16 code.  Allow MIPS16 o32 PIC.\n\t(mips_override_options): Allow MIPS16 o32 PIC.\n\t* config/mips/mips.md: Lower CONST_GP_P moves into register moves\n\tafter reload if TARGET_USE_GOT.\n\t(UNSPEC_COPYGP): New constant.\n\t(length): Use a default length of 8 for MIPS16 GOT loads.\n\t(*got_disp<mode>): Check mips_split_p instead of TARGET_XGOT.\n\t(*got_page<mode>): Check mips_split_hi_p.\n\t(*got_disp<mode>, *got_page<mode>): Use mips_got_load.\n\t(unspec_got<mode>, unspec_call<mode>): New expanders.\n\t(load_got<mode>, load_call<mode>): Remove the length attributes.\n\tUse a got attribute instead of a type attribute.\n\t(copygp_mips16): New insn.\n\t(restore_gp): Add a scratch clobber and pass it to mips_restore_gp.\n\t(load_call<mode>): Use a \"d\" constraint instead of an \"r\" constraint.\n\t(sibcall, sibcall_value, call, call_value): Update the calls\n\tto mips_expand_call.\n\t(call_internal, call_value_internal): Use mips_split_call.\n\t(call_value_multiple_internal): Likewise.\n\t(call_split): Move after call_internal (the insn it is split from).\n\t(call_internal_direct, call_value_internal_direct): Turn into\n\tdefine_insn_and_splits.  Split if TARGET_SPLIT_CALLS.\n\t(call_direct_split, call_value_direct_split): New patterns.\n\t* config/mips/constraints.md (c): Handle TARGET_MIPS16 first\n\tand use M16_REGS instead of M16_NA_REGS.\n\t* config/mips/predicates.md (const_call_insn_operand): Replace\n\tthe TARGET_ABSOLUTE_ABICALLS-based check with a more general\n\tmips_use_pic_fn_addr_reg_p check.\n\t(move_operand): Reject HIGHs if mips_split_hi_p.\n\t* config/mips/mips16.S: Assembly as empty if the ABI is not suitable.\n\t(__mips16_floatunsisf): Inline __mips16_floatsisf.\n\t(CALL_STUB_NO_RET, CALL_STUB_REG): Copy the target register to $25.\n\t* config/mips/libgcc-mips16.ver: New file.\n\t* config/mips/t-libgcc-mips16 (SHLIB_MAPFILES): Add\n\t$(srcdir)/config/mips/libgcc-mips16.ver.\n\ngcc/testsuite/\n\t* lib/target-supports.exp (check_profiling_available): Return false\n\tfor -p and -pg on MIPS16 targets.\n\nFrom-SVN: r138912", "tree": {"sha": "14858d78ffeb002f17d43ccb7d48dc3bbbb01b4d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/14858d78ffeb002f17d43ccb7d48dc3bbbb01b4d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/08d0963a0e05e44f02c3e6b35faf94669874cb89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08d0963a0e05e44f02c3e6b35faf94669874cb89", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08d0963a0e05e44f02c3e6b35faf94669874cb89", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08d0963a0e05e44f02c3e6b35faf94669874cb89/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7462a71535a4cb6768099b77057ff7558dc303eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7462a71535a4cb6768099b77057ff7558dc303eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7462a71535a4cb6768099b77057ff7558dc303eb"}], "stats": {"total": 1329, "additions": 1054, "deletions": 275}, "files": [{"sha": "156f55d9b3002931651c0dbb42ad4224e8b4218f", "filename": "ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08d0963a0e05e44f02c3e6b35faf94669874cb89/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08d0963a0e05e44f02c3e6b35faf94669874cb89/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=08d0963a0e05e44f02c3e6b35faf94669874cb89", "patch": "@@ -1,3 +1,8 @@\n+2008-08-09  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* configure.ac (mips*-*-*linux*, mips*-*-gnu*): Use mt-mips-gnu.\n+\t* configure: Regenerate.\n+\n 2008-07-30 Paolo Bonzini  <bonzini@gnu.org>\n \n \t* configure.ac: Add makefile fragments for hpux."}, {"sha": "1062d8ee5e26eb5f5732070c5d45279324ec8649", "filename": "config/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08d0963a0e05e44f02c3e6b35faf94669874cb89/config%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08d0963a0e05e44f02c3e6b35faf94669874cb89/config%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/config%2FChangeLog?ref=08d0963a0e05e44f02c3e6b35faf94669874cb89", "patch": "@@ -1,3 +1,9 @@\n+2008-08-09  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* mt-mips16-compat: New file, taken from mt-mips-elfoabi.\n+\t* mt-mips-elfoabi: Include mt-mips16-compat.\n+\t* mt-mips-gnu: New file.\n+\n 2008-08-03  Alan Modra  <amodra@bigpond.net.au>\n \n \t* mt-spu (all-ld): Update for ld Makefile changes."}, {"sha": "a9f9cbec7d253fe10ec3456f5b23bbfc13e7ae61", "filename": "config/mt-mips-elfoabi", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08d0963a0e05e44f02c3e6b35faf94669874cb89/config%2Fmt-mips-elfoabi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08d0963a0e05e44f02c3e6b35faf94669874cb89/config%2Fmt-mips-elfoabi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/config%2Fmt-mips-elfoabi?ref=08d0963a0e05e44f02c3e6b35faf94669874cb89", "patch": "@@ -1,6 +1 @@\n-# The *-elfoabi configurations are intended to be usable for both\n-# MIPS16 and non-MIPS16 code, but the libraries are all non-MIPS16.\n-# Add -minterlink-mips16 so that the libraries can be used with both\n-# ISA modes.\n-CFLAGS_FOR_TARGET += -minterlink-mips16\n-CXXFLAGS_FOR_TARGET += -minterlink-mips16\n+include $(srcdir)/config/mt-mips16-compat"}, {"sha": "a8198c03ff874d0f958d7213723ecd4ad4a3f616", "filename": "config/mt-mips-gnu", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08d0963a0e05e44f02c3e6b35faf94669874cb89/config%2Fmt-mips-gnu", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08d0963a0e05e44f02c3e6b35faf94669874cb89/config%2Fmt-mips-gnu", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/config%2Fmt-mips-gnu?ref=08d0963a0e05e44f02c3e6b35faf94669874cb89", "patch": "@@ -0,0 +1,2 @@\n+include $(srcdir)/config/mt-gnu\n+include $(srcdir)/config/mt-mips16-compat"}, {"sha": "7e36791e67f4a15845b3715437b3ce8ca82a12de", "filename": "config/mt-mips16-compat", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08d0963a0e05e44f02c3e6b35faf94669874cb89/config%2Fmt-mips16-compat", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08d0963a0e05e44f02c3e6b35faf94669874cb89/config%2Fmt-mips16-compat", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/config%2Fmt-mips16-compat?ref=08d0963a0e05e44f02c3e6b35faf94669874cb89", "patch": "@@ -0,0 +1,5 @@\n+# Configurations use this fragment if they support MIPS16 and non-MIPS16 code,\n+# but if the libraries are all non-MIPS16.  Add -minterlink-mips16 so\n+# that the libraries can be used with both ISA modes.\n+CFLAGS_FOR_TARGET += -minterlink-mips16\n+CXXFLAGS_FOR_TARGET += -minterlink-mips16"}, {"sha": "b69f90d7009c024f723cf8410a7321de524f3ffb", "filename": "configure", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08d0963a0e05e44f02c3e6b35faf94669874cb89/configure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08d0963a0e05e44f02c3e6b35faf94669874cb89/configure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure?ref=08d0963a0e05e44f02c3e6b35faf94669874cb89", "patch": "@@ -5448,6 +5448,9 @@ case \"${target}\" in\n   mipsisa*-*-elfoabi*)\n     target_makefile_frag=\"config/mt-mips-elfoabi\"\n     ;;\n+  mips*-*-*linux* | mips*-*-gnu*)\n+    target_makefile_frag=\"config/mt-mips-gnu\"\n+    ;;\n   *-*-netware*)\n     target_makefile_frag=\"config/mt-netware\"\n     ;;"}, {"sha": "1804731774ef424d8865a8fbe227f828756b53f2", "filename": "configure.ac", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08d0963a0e05e44f02c3e6b35faf94669874cb89/configure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08d0963a0e05e44f02c3e6b35faf94669874cb89/configure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure.ac?ref=08d0963a0e05e44f02c3e6b35faf94669874cb89", "patch": "@@ -1904,6 +1904,9 @@ case \"${target}\" in\n   mipsisa*-*-elfoabi*)\n     target_makefile_frag=\"config/mt-mips-elfoabi\"\n     ;;\n+  mips*-*-*linux* | mips*-*-gnu*)\n+    target_makefile_frag=\"config/mt-mips-gnu\"\n+    ;;\n   *-*-netware*)\n     target_makefile_frag=\"config/mt-netware\"\n     ;;"}, {"sha": "c6a244963b31ebaaab6aa89b0bfd4f1e54e4294c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08d0963a0e05e44f02c3e6b35faf94669874cb89/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08d0963a0e05e44f02c3e6b35faf94669874cb89/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=08d0963a0e05e44f02c3e6b35faf94669874cb89", "patch": "@@ -1,3 +1,140 @@\n+2008-08-09  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* config.gcc (mips*-*-linux*, mips64*-*-linux*): Add\n+\tmips/t-libgcc-mips16 to tmake_file.\n+\t* config/mips/mips-protos.h (mips_call_type): New enum.\n+\t(mips_pic_base_register, mips_got_load): Declare.\n+\t(mips_restore_gp): Take an rtx argument.\n+\t(mips_use_pic_fn_addr_reg_p): Declare.\n+\t(mips_expand_call): Replace the sibcall_p argument with\n+\ta mips_call_type argument.  Add a lazy_p parameter.\n+\t(mips_split_call): Declare.\n+\t* config/mips/mips.h (MIPS16_PIC_TEMP_REGNUM): New macro.\n+\t(MIPS16_PIC_TEMP): Likewise.\n+\t(reg_class): Delete M16_NA_REGS.\n+\t(REG_CLASS_NAMES, REG_CLASS_CONTENTS): Update accordingly.\n+\t(SYMBOL_FLAG_BIND_NOW, SYMBOL_REF_BIND_NOW_P): New macros.\n+\t(mips_split_hi_p): Declare.\n+\t* config/mips/mips.c (mips_split_hi_p): New array.\n+\t(mips_regno_to_class): Change M16_NA_REGS entries to M16_REGS.\n+\t(mips_got_symbol_type_p): New function.\n+\t(mips_global_symbol_p): Check SYMBOL_REF_EXTERNAL_P.\n+\t(mips16_stub_function_p): New function.\n+\t(mips16_local_function_p): Likewise.\n+\t(mips_use_pic_fn_addr_reg_p): Likewise.\n+\t(mips_cannot_force_const_mem): Return false for HIGHs.\n+\tExtend CONST_INT and symbolic handling to MIPS16, using\n+\tmips_symbol_insns to check that the base symbol type is a\n+\tlegitimate constant.  Reject GOT-based constants if\n+\tTARGET_MIPS16_PCREL_LOADS.\n+\t(mips_const_insns): Check targetm.cannot_force_const_mem when\n+\tdecomposing a symbolic base and a large offset.\n+\t(mips_emit_call_insn): Add ORIG_ADDR and ADDR parameters.\n+\tWhen calling a function that needs $25 from MIPS16 code,\n+\tmove the target address into $25 separately and add a USE\n+\tto the call insn.\n+\t(mips16_gp_pseudo_reg): Insert the initializer immediately\n+\tbefore the first real insn.\n+\t(mips_pic_base_register, mips_got_load): New functions.\n+\t(mips_split_symbol): Generalize the name of the LO_SUM_OUT\n+\tparameter to LOW_OUT.  Say that it can be any valid SET_SRC\n+\twhen splitting a load-address operation.  Split SYMBOL_GOT_DISP\n+\tconstants and highs of SYMBOL_GOT_PAGE_OFST constants.\n+\t(mips_call_tls_get_addr): Update the call to mips_expand_call,\n+\talso passing NULL_RTX rather than const0_rtx as the aux argument.\n+\t(mips_rewrite_small_data_p): Check mips_lo_relocs and mips_split_p\n+\tinstead of TARGET_EXPLICIT_RELOCS.\n+\t(mips_ok_for_lazy_binding_p): Check SYMBOL_REF_BIND_NOW_P.\n+\t(mips_load_call_address): Replace the sibcall_p argument with\n+\ta mips_call_type argument.  Use mips_got_load.\n+\t(mips16_local_alias): New structure.\n+\t(mips16_local_aliases): New variable.\n+\t(mips16_local_aliases_hash): New function.\n+\t(mips16_local_aliases_eq): Likewise.\n+\t(mips16_local_alias): Likewise.\n+\t(mips16_stub_function): Likewise.\n+\t(mips16_build_function_stub): Create a local alias for the target\n+\tfunction.  Handle TARGET_ABICALLS.  For PIC abicalls, emit a\n+\t.cpload directive and an R_MIPS_NONE relocation for the target\n+\tfunction, then load the alias rather than the function itself.\n+\tWrap the non-PIC abicalls version in \".option pic0/.option pic2\".\n+\t(mips16_copy_fpr_return_value): Use mips16_stub_function and\n+\tmips_expand_call.  Set SYMBOL_REF_BIND_NOW on the symbol.\n+\t(mips16_build_call_stub): Replace the FN parameter with an\n+\tFN_PTR parameter.  Force the address into a register if it\n+\tisn't a call_insn_operand; don't rely on the caller to do this.\n+\tIf a call to a locally-defined and locally-binding MIPS16\n+\tfunction must be made indirectly, redirect the call to the\n+\tfunction's local alias.  Use mips16_stub_function_p,\n+\tmips16_stub_function, mips_expand_call and use_reg.\n+\tSet SYMBOL_FLAG_BIND_NOW on __mips_call_* symbols.\n+\tUse explicit %hi and %lo accesses where possible.\n+\tUse MIPS_CALL to generate the correct code form of a\n+\tjal instruction.  Add clobbers of $18 instead of uses.\n+\tUpdate the call to mips_emit_call_insn.\n+\t(mips_expand_call): Replace the SIBCALL_P argument with a\n+\tmips_call_type argument and handle the new MIPS_CALL_EPILOGUE value.\n+\tTake a LAZY_P parameter.  Call mips16_build_call_stub first,\n+\tallowing it to modify the call address.  Update the calls to\n+\tmips_load_call_address and mips_emit_call_insn.\n+\t(mips_split_call): New function.\n+\t(mips_init_relocs): Clear mips_split_hi_p.  Only use %gp_rel if\n+\t!TARGET_MIPS16.  Split SYMBOL_GOT_DISP, and the high parts of\n+\tSYMBOL_GOT_PAGE_OFST, for MIPS16 code.\n+\t(mips_global_pointer): Check mips16_cfun_returns_in_fpr_p.\n+\t(mips_extra_live_on_entry): Include MIPS16_PIC_TEMP_REGNUM\n+\tif TARGET_MIPS16.\n+\t(mips_cprestore_slot): New function.\n+\t(mips_restore_gp): Take a TEMP parameter.  Handle TARGET_MIPS16\n+\tand use mips_cprestore_slot.\n+\t(mips_output_function_prologue): Handle TARGET_MIPS16 for\n+\tLOADGP_OLDABI.\n+\t(mips_emit_loadgp): Move into MIPS16_PIC_TEMP for MIPS16,\n+\tthen use a copygp_mips16 instruction to set up $28.\n+\t(mips_expand_prologue): Initialize the cprestore slot for MIPS16 too.\n+\t(mips16_lay_out_constants): Call split_all_insns_noflow.\n+\t(mips_reorg_process_insns): Explicitly set all_noreorder_p to\n+\tfalse if TARGET_MIPS16.\n+\t(mips_reorg): Don't call vr4130_align_insns if TARGET_MIPS16.\n+\t(mips_output_mi_thunk): Use mips_got_symbol_type_p.  Use the\n+\tmips_dangerous_for_la25_p approach for MIPS16 PIC calls too.\n+\t(mips_set_mips16_mode): Always set MASK_EXPLICIT_RELOCS for\n+\tMIPS16 code.  Allow MIPS16 o32 PIC.\n+\t(mips_override_options): Allow MIPS16 o32 PIC.\n+\t* config/mips/mips.md: Lower CONST_GP_P moves into register moves\n+\tafter reload if TARGET_USE_GOT.\n+\t(UNSPEC_COPYGP): New constant.\n+\t(length): Use a default length of 8 for MIPS16 GOT loads.\n+\t(*got_disp<mode>): Check mips_split_p instead of TARGET_XGOT.\n+\t(*got_page<mode>): Check mips_split_hi_p.\n+\t(*got_disp<mode>, *got_page<mode>): Use mips_got_load.\n+\t(unspec_got<mode>, unspec_call<mode>): New expanders.\n+\t(load_got<mode>, load_call<mode>): Remove the length attributes.\n+\tUse a got attribute instead of a type attribute.\n+\t(copygp_mips16): New insn.\n+\t(restore_gp): Add a scratch clobber and pass it to mips_restore_gp.\n+\t(load_call<mode>): Use a \"d\" constraint instead of an \"r\" constraint.\n+\t(sibcall, sibcall_value, call, call_value): Update the calls\n+\tto mips_expand_call.\n+\t(call_internal, call_value_internal): Use mips_split_call.\n+\t(call_value_multiple_internal): Likewise.\n+\t(call_split): Move after call_internal (the insn it is split from).\n+\t(call_internal_direct, call_value_internal_direct): Turn into\n+\tdefine_insn_and_splits.  Split if TARGET_SPLIT_CALLS.\n+\t(call_direct_split, call_value_direct_split): New patterns.\n+\t* config/mips/constraints.md (c): Handle TARGET_MIPS16 first\n+\tand use M16_REGS instead of M16_NA_REGS.\n+\t* config/mips/predicates.md (const_call_insn_operand): Replace\n+\tthe TARGET_ABSOLUTE_ABICALLS-based check with a more general\n+\tmips_use_pic_fn_addr_reg_p check.\n+\t(move_operand): Reject HIGHs if mips_split_hi_p.\n+\t* config/mips/mips16.S: Assembly as empty if the ABI is not suitable.\n+\t(__mips16_floatunsisf): Inline __mips16_floatsisf.\n+\t(CALL_STUB_NO_RET, CALL_STUB_REG): Copy the target register to $25.\n+\t* config/mips/libgcc-mips16.ver: New file.\n+\t* config/mips/t-libgcc-mips16 (SHLIB_MAPFILES): Add\n+\t$(srcdir)/config/mips/libgcc-mips16.ver.\n+\n 2008-08-09  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* config/mips/mips.c (mips_unspec_address_offset): Move earlier in file."}, {"sha": "30339e233d482f044f41dd86f688a33b9ef8c22d", "filename": "gcc/config.gcc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08d0963a0e05e44f02c3e6b35faf94669874cb89/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08d0963a0e05e44f02c3e6b35faf94669874cb89/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=08d0963a0e05e44f02c3e6b35faf94669874cb89", "patch": "@@ -1544,7 +1544,7 @@ mips*-*-netbsd*)\t\t\t# NetBSD/mips, either endian.\n \t;;\n mips64*-*-linux* | mipsisa64*-*-linux*)\n \ttm_file=\"dbxelf.h elfos.h svr4.h linux.h ${tm_file} mips/linux.h mips/linux64.h\"\n-\ttmake_file=\"${tmake_file} mips/t-linux64\"\n+\ttmake_file=\"${tmake_file} mips/t-linux64 mips/t-libgcc-mips16\"\n \ttm_defines=\"${tm_defines} MIPS_ABI_DEFAULT=ABI_N32\"\n \tcase ${target} in\n \t\tmips64el-st-linux-gnu)\n@@ -1561,6 +1561,7 @@ mips64*-*-linux* | mipsisa64*-*-linux*)\n \t;;\n mips*-*-linux*)\t\t\t\t# Linux MIPS, either endian.\n         tm_file=\"dbxelf.h elfos.h svr4.h linux.h ${tm_file} mips/linux.h\"\n+\ttmake_file=\"${tmake_file} mips/t-libgcc-mips16\"\n \tcase ${target} in\n         mipsisa32r2*)\n \t\ttm_defines=\"${tm_defines} MIPS_ISA_DEFAULT=33\""}, {"sha": "3a03a3cb633ca33993f2139234c8b3c6224c46fd", "filename": "gcc/config/mips/constraints.md", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08d0963a0e05e44f02c3e6b35faf94669874cb89/gcc%2Fconfig%2Fmips%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08d0963a0e05e44f02c3e6b35faf94669874cb89/gcc%2Fconfig%2Fmips%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fconstraints.md?ref=08d0963a0e05e44f02c3e6b35faf94669874cb89", "patch": "@@ -43,8 +43,10 @@\n (define_register_constraint \"b\" \"ALL_REGS\"\n   \"@internal\")\n \n-(define_register_constraint \"c\" \"TARGET_USE_PIC_FN_ADDR_REG ? PIC_FN_ADDR_REG\n-\t\t\t\t : TARGET_MIPS16 ? M16_NA_REGS\n+;; MIPS16 code always calls through a MIPS16 register; see mips_emit_call_insn\n+;; for details.\n+(define_register_constraint \"c\" \"TARGET_MIPS16 ? M16_REGS\n+\t\t\t\t : TARGET_USE_PIC_FN_ADDR_REG ? PIC_FN_ADDR_REG\n \t\t\t\t : GR_REGS\"\n   \"A register suitable for use in an indirect jump.  This will always be\n    @code{$25} for @option{-mabicalls}.\")"}, {"sha": "d74bf49f20387b0cee1ed9c7e371ffe52c703e58", "filename": "gcc/config/mips/libgcc-mips16.ver", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08d0963a0e05e44f02c3e6b35faf94669874cb89/gcc%2Fconfig%2Fmips%2Flibgcc-mips16.ver", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08d0963a0e05e44f02c3e6b35faf94669874cb89/gcc%2Fconfig%2Fmips%2Flibgcc-mips16.ver", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Flibgcc-mips16.ver?ref=08d0963a0e05e44f02c3e6b35faf94669874cb89", "patch": "@@ -0,0 +1,68 @@\n+GCC_4.4.0 {\n+  __mips16_addsf3\n+  __mips16_subsf3\n+  __mips16_mulsf3\n+  __mips16_divsf3\n+  __mips16_eqsf2\n+  __mips16_nesf2\n+  __mips16_gtsf2\n+  __mips16_gesf2\n+  __mips16_lesf2\n+  __mips16_ltsf2\n+  __mips16_floatsisf\n+  __mips16_floatunsisf\n+  __mips16_fix_truncsfsi\n+  __mips16_adddf3\n+  __mips16_subdf3\n+  __mips16_muldf3\n+  __mips16_divdf3\n+  __mips16_extendsfdf2\n+  __mips16_truncdfsf2\n+  __mips16_eqdf2\n+  __mips16_nedf2\n+  __mips16_gtdf2\n+  __mips16_gedf2\n+  __mips16_ledf2\n+  __mips16_ltdf2\n+  __mips16_floatsidf\n+  __mips16_floatunsidf\n+  __mips16_fix_truncdfsi\n+  __mips16_ret_sf\n+  __mips16_ret_sc\n+  __mips16_ret_df\n+  __mips16_ret_dc\n+  __mips16_call_stub_1\n+  __mips16_call_stub_5\n+  __mips16_call_stub_2\n+  __mips16_call_stub_6\n+  __mips16_call_stub_9\n+  __mips16_call_stub_10\n+  __mips16_call_stub_sf_0\n+  __mips16_call_stub_sf_1\n+  __mips16_call_stub_sf_5\n+  __mips16_call_stub_sf_2\n+  __mips16_call_stub_sf_6\n+  __mips16_call_stub_sf_9\n+  __mips16_call_stub_sf_10\n+  __mips16_call_stub_sc_0\n+  __mips16_call_stub_sc_1\n+  __mips16_call_stub_sc_5\n+  __mips16_call_stub_sc_2\n+  __mips16_call_stub_sc_6\n+  __mips16_call_stub_sc_9\n+  __mips16_call_stub_sc_10\n+  __mips16_call_stub_df_0\n+  __mips16_call_stub_df_1\n+  __mips16_call_stub_df_5\n+  __mips16_call_stub_df_2\n+  __mips16_call_stub_df_6\n+  __mips16_call_stub_df_9\n+  __mips16_call_stub_df_10\n+  __mips16_call_stub_dc_0\n+  __mips16_call_stub_dc_1\n+  __mips16_call_stub_dc_5\n+  __mips16_call_stub_dc_2\n+  __mips16_call_stub_dc_6\n+  __mips16_call_stub_dc_9\n+  __mips16_call_stub_dc_10\n+}"}, {"sha": "01645a1ebc29edb5bc51136e29df97aab3e47962", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08d0963a0e05e44f02c3e6b35faf94669874cb89/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08d0963a0e05e44f02c3e6b35faf94669874cb89/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=08d0963a0e05e44f02c3e6b35faf94669874cb89", "patch": "@@ -164,6 +164,22 @@ enum mips_loadgp_style {\n \n struct mips16e_save_restore_info;\n \n+/* Classifies a type of call.\n+\n+   MIPS_CALL_NORMAL\n+\tA normal call or call_value pattern.\n+\n+   MIPS_CALL_SIBCALL\n+\tA sibcall or sibcall_value pattern.\n+\n+   MIPS_CALL_EPILOGUE\n+\tA call inserted in the epilogue.  */\n+enum mips_call_type {\n+  MIPS_CALL_NORMAL,\n+  MIPS_CALL_SIBCALL,\n+  MIPS_CALL_EPILOGUE\n+};\n+\n extern bool mips_symbolic_constant_p (rtx, enum mips_symbol_context,\n \t\t\t\t      enum mips_symbol_type *);\n extern int mips_regno_mode_ok_for_base_p (int, enum machine_mode, bool);\n@@ -175,6 +191,8 @@ extern int mips_split_const_insns (rtx);\n extern int mips_load_store_insns (rtx, rtx);\n extern int mips_idiv_insns (void);\n extern rtx mips_emit_move (rtx, rtx);\n+extern rtx mips_pic_base_register (rtx);\n+extern rtx mips_got_load (rtx, rtx, enum mips_symbol_type);\n extern bool mips_split_symbol (rtx, rtx, enum machine_mode, rtx *);\n extern rtx mips_unspec_address (rtx, enum mips_symbol_type);\n extern bool mips_legitimize_address (rtx *, enum machine_mode);\n@@ -202,15 +220,17 @@ extern rtx mips_subword (rtx, bool);\n extern bool mips_split_64bit_move_p (rtx, rtx);\n extern void mips_split_doubleword_move (rtx, rtx);\n extern const char *mips_output_move (rtx, rtx);\n-extern void mips_restore_gp (void);\n+extern void mips_restore_gp (rtx);\n #ifdef RTX_CODE\n extern bool mips_expand_scc (enum rtx_code, rtx);\n extern void mips_expand_conditional_branch (rtx *, enum rtx_code);\n extern void mips_expand_vcondv2sf (rtx, rtx, rtx, enum rtx_code, rtx, rtx);\n extern void mips_expand_conditional_move (rtx *);\n extern void mips_expand_conditional_trap (enum rtx_code);\n #endif\n-extern rtx mips_expand_call (rtx, rtx, rtx, rtx, bool);\n+extern bool mips_use_pic_fn_addr_reg_p (const_rtx);\n+extern rtx mips_expand_call (enum mips_call_type, rtx, rtx, rtx, rtx, bool);\n+extern void mips_split_call (rtx, rtx);\n extern void mips_expand_fcc_reload (rtx, rtx, rtx);\n extern void mips_set_return_address (rtx, rtx);\n extern bool mips_expand_block_move (rtx, rtx, rtx);"}, {"sha": "48daec4175d232061be3bf00e7a98f33367b8c43", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 622, "deletions": 198, "changes": 820, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08d0963a0e05e44f02c3e6b35faf94669874cb89/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08d0963a0e05e44f02c3e6b35faf94669874cb89/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=08d0963a0e05e44f02c3e6b35faf94669874cb89", "patch": "@@ -469,6 +469,10 @@ static GTY (()) int mips_output_filename_first_time = 1;\n    mips_split_symbol.  */\n bool mips_split_p[NUM_SYMBOL_TYPES];\n \n+/* mips_split_hi_p[X] is true if the high parts of symbols of type X\n+   can be split by mips_split_symbol.  */\n+bool mips_split_hi_p[NUM_SYMBOL_TYPES];\n+\n /* mips_lo_relocs[X] is the relocation to use when a symbol of type X\n    appears in a LO_SUM.  It can be null if such LO_SUMs aren't valid or\n    if they are matched by a special .md file pattern.  */\n@@ -479,11 +483,11 @@ static const char *mips_hi_relocs[NUM_SYMBOL_TYPES];\n \n /* Index R is the smallest register class that contains register R.  */\n const enum reg_class mips_regno_to_class[FIRST_PSEUDO_REGISTER] = {\n-  LEA_REGS,\tLEA_REGS,\tM16_NA_REGS,\tV1_REG,\n+  LEA_REGS,\tLEA_REGS,\tM16_REGS,\tV1_REG,\n   M16_REGS,\tM16_REGS,\tM16_REGS,\tM16_REGS,\n   LEA_REGS,\tLEA_REGS,\tLEA_REGS,\tLEA_REGS,\n   LEA_REGS,\tLEA_REGS,\tLEA_REGS,\tLEA_REGS,\n-  M16_NA_REGS,\tM16_NA_REGS,\tLEA_REGS,\tLEA_REGS,\n+  M16_REGS,\tM16_REGS,\tLEA_REGS,\tLEA_REGS,\n   LEA_REGS,\tLEA_REGS,\tLEA_REGS,\tLEA_REGS,\n   T_REG,\tPIC_FN_ADDR_REG, LEA_REGS,\tLEA_REGS,\n   LEA_REGS,\tLEA_REGS,\tLEA_REGS,\tLEA_REGS,\n@@ -1342,6 +1346,22 @@ mips_build_integer (struct mips_integer_op *codes,\n     }\n }\n \f\n+/* Return true if symbols of type TYPE require a GOT access.  */\n+\n+static bool\n+mips_got_symbol_type_p (enum mips_symbol_type type)\n+{\n+  switch (type)\n+    {\n+    case SYMBOL_GOT_PAGE_OFST:\n+    case SYMBOL_GOT_DISP:\n+      return true;\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n /* Return true if X is a thread-local symbol.  */\n \n static bool\n@@ -1359,14 +1379,35 @@ mips_global_symbol_p (const_rtx x)\n   const_tree decl = SYMBOL_REF_DECL (x);\n \n   if (!decl)\n-    return !SYMBOL_REF_LOCAL_P (x);\n+    return !SYMBOL_REF_LOCAL_P (x) || SYMBOL_REF_EXTERNAL_P (x);\n \n   /* Weakref symbols are not TREE_PUBLIC, but their targets are global\n      or weak symbols.  Relocations in the object file will be against\n      the target symbol, so it's that symbol's binding that matters here.  */\n   return DECL_P (decl) && (TREE_PUBLIC (decl) || DECL_WEAK (decl));\n }\n \n+/* Return true if function X is a libgcc MIPS16 stub function.  */\n+\n+static bool\n+mips16_stub_function_p (const_rtx x)\n+{\n+  return (GET_CODE (x) == SYMBOL_REF\n+\t  && strncmp (XSTR (x, 0), \"__mips16_\", 9) == 0);\n+}\n+\n+/* Return true if function X is a locally-defined and locally-binding\n+   MIPS16 function.  */\n+\n+static bool\n+mips16_local_function_p (const_rtx x)\n+{\n+  return (GET_CODE (x) == SYMBOL_REF\n+\t  && SYMBOL_REF_LOCAL_P (x)\n+\t  && !SYMBOL_REF_EXTERNAL_P (x)\n+\t  && mips_use_mips16_mode_p (SYMBOL_REF_DECL (x)));\n+}\n+\n /* Return true if SYMBOL_REF X binds locally.  */\n \n static bool\n@@ -1401,6 +1442,29 @@ mips_dangerous_for_la25_p (rtx x)\n \t  && mips_global_symbol_p (x));\n }\n \n+/* Return true if calls to X might need $25 to be valid on entry.  */\n+\n+bool\n+mips_use_pic_fn_addr_reg_p (const_rtx x)\n+{\n+  if (!TARGET_USE_PIC_FN_ADDR_REG)\n+    return false;\n+\n+  /* MIPS16 stub functions are guaranteed not to use $25.  */\n+  if (mips16_stub_function_p (x))\n+    return false;\n+\n+  /* When TARGET_ABSOLUTE_ABICALLS is true, locally-defined functions\n+     use absolute accesses to set up the global pointer.  */\n+  if (TARGET_ABSOLUTE_ABICALLS\n+      && GET_CODE (x) == SYMBOL_REF\n+      && mips_symbol_binds_local_p (x)\n+      && !SYMBOL_REF_EXTERNAL_P (x))\n+    return false;\n+\n+  return true;\n+}\n+\n /* Return the method that should be used to access SYMBOL_REF or\n    LABEL_REF X in context CONTEXT.  */\n \n@@ -1736,24 +1800,37 @@ mips_tls_symbol_ref_1 (rtx *x, void *data ATTRIBUTE_UNUSED)\n static bool\n mips_cannot_force_const_mem (rtx x)\n {\n+  enum mips_symbol_type type;\n   rtx base, offset;\n \n-  if (!TARGET_MIPS16)\n-    {\n-      /* As an optimization, reject constants that mips_legitimize_move\n-\t can expand inline.\n+  /* There is no assembler syntax for expressing an address-sized\n+     high part.  */\n+  if (GET_CODE (x) == HIGH)\n+    return true;\n+\n+  /* As an optimization, reject constants that mips_legitimize_move\n+     can expand inline.\n+\n+     Suppose we have a multi-instruction sequence that loads constant C\n+     into register R.  If R does not get allocated a hard register, and\n+     R is used in an operand that allows both registers and memory\n+     references, reload will consider forcing C into memory and using\n+     one of the instruction's memory alternatives.  Returning false\n+     here will force it to use an input reload instead.  */\n+  if (GET_CODE (x) == CONST_INT && LEGITIMATE_CONSTANT_P (x))\n+    return true;\n \n-\t Suppose we have a multi-instruction sequence that loads constant C\n-\t into register R.  If R does not get allocated a hard register, and\n-\t R is used in an operand that allows both registers and memory\n-\t references, reload will consider forcing C into memory and using\n-\t one of the instruction's memory alternatives.  Returning false\n-\t here will force it to use an input reload instead.  */\n-      if (GET_CODE (x) == CONST_INT)\n+  split_const (x, &base, &offset);\n+  if (mips_symbolic_constant_p (base, SYMBOL_CONTEXT_LEA, &type)\n+      && type != SYMBOL_FORCE_TO_MEM)\n+    {\n+      /* The same optimization as for CONST_INT.  */\n+      if (SMALL_INT (offset) && mips_symbol_insns (type, MAX_MACHINE_MODE) > 0)\n \treturn true;\n \n-      split_const (x, &base, &offset);\n-      if (symbolic_operand (base, VOIDmode) && SMALL_INT (offset))\n+      /* If MIPS16 constant pools live in the text section, they should\n+\t not refer to anything that might need run-time relocation.  */\n+      if (TARGET_MIPS16_PCREL_LOADS && mips_got_symbol_type_p (type))\n \treturn true;\n     }\n \n@@ -2097,8 +2174,13 @@ mips_const_insns (rtx x)\n \treturn mips_symbol_insns (symbol_type, MAX_MACHINE_MODE);\n \n       /* Otherwise try splitting the constant into a base and offset.\n-\t 16-bit offsets can be added using an extra ADDIU.  Larger offsets\n-\t must be calculated separately and then added to the base.  */\n+\t If the offset is a 16-bit value, we can load the base address\n+\t into a register and then use (D)ADDIU to add in the offset.\n+\t If the offset is larger, we can load the base and offset\n+\t into separate registers and add them together with (D)ADDU.\n+\t However, the latter is only possible before reload; during\n+\t and after reload, we must have the option of forcing the\n+\t constant into the pool instead.  */\n       split_const (x, &x, &offset);\n       if (offset != 0)\n \t{\n@@ -2107,7 +2189,7 @@ mips_const_insns (rtx x)\n \t    {\n \t      if (SMALL_INT (offset))\n \t\treturn n + 1;\n-\t      else\n+\t      else if (!targetm.cannot_force_const_mem (x))\n \t\treturn n + 1 + mips_build_integer (codes, INTVAL (offset));\n \t    }\n \t}\n@@ -2238,17 +2320,30 @@ mips_force_temporary (rtx dest, rtx value)\n \n /* Emit a call sequence with call pattern PATTERN and return the call\n    instruction itself (which is not necessarily the last instruction\n-   emitted).  LAZY_P is true if the call address is lazily-bound.  */\n+   emitted).  ORIG_ADDR is the original, unlegitimized address,\n+   ADDR is the legitimized form, and LAZY_P is true if the call\n+   address is lazily-bound.  */\n \n static rtx\n-mips_emit_call_insn (rtx pattern, bool lazy_p)\n+mips_emit_call_insn (rtx pattern, rtx orig_addr, rtx addr, bool lazy_p)\n {\n-  rtx insn;\n+  rtx insn, reg;\n \n   insn = emit_call_insn (pattern);\n \n-  /* Lazy-binding stubs require $gp to be valid on entry.  */\n+  if (TARGET_MIPS16 && mips_use_pic_fn_addr_reg_p (orig_addr))\n+    {\n+      /* MIPS16 JALRs only take MIPS16 registers.  If the target\n+\t function requires $25 to be valid on entry, we must copy it\n+\t there separately.  The move instruction can be put in the\n+\t call's delay slot.  */\n+      reg = gen_rtx_REG (Pmode, PIC_FUNCTION_ADDR_REGNUM);\n+      emit_insn_before (gen_move_insn (reg, addr), insn);\n+      use_reg (&CALL_INSN_FUNCTION_USAGE (insn), reg);\n+    }\n+\n   if (lazy_p)\n+    /* Lazy-binding stubs require $gp to be valid on entry.  */\n     use_reg (&CALL_INSN_FUNCTION_USAGE (insn), pic_offset_table_rtx);\n \n   if (TARGET_USE_GOT)\n@@ -2334,21 +2429,17 @@ mips16_gp_pseudo_reg (void)\n   if (!cfun->machine->initialized_mips16_gp_pseudo_p\n       && (current_ir_type () != IR_GIMPLE || currently_expanding_to_rtl))\n     {\n-      rtx insn, scan, after;\n+      rtx insn, scan;\n+\n+      push_topmost_sequence ();\n+\n+      scan = get_insns ();\n+      while (NEXT_INSN (scan) && !INSN_P (NEXT_INSN (scan)))\n+\tscan = NEXT_INSN (scan);\n \n       insn = gen_load_const_gp (cfun->machine->mips16_gp_pseudo_rtx);\n+      emit_insn_after (insn, scan);\n \n-      push_topmost_sequence ();\n-      /* We need to emit the initialization after the FUNCTION_BEG\n-         note, so that it will be integrated.  */\n-      after = get_insns ();\n-      for (scan = after; scan != NULL_RTX; scan = NEXT_INSN (scan))\n-\tif (NOTE_P (scan) && NOTE_KIND (scan) == NOTE_INSN_FUNCTION_BEG)\n-\t  {\n-\t    after = scan;\n-\t    break;\n-\t  }\n-      insn = emit_insn_after (insn, after);\n       pop_topmost_sequence ();\n \n       cfun->machine->initialized_mips16_gp_pseudo_p = true;\n@@ -2357,17 +2448,74 @@ mips16_gp_pseudo_reg (void)\n   return cfun->machine->mips16_gp_pseudo_rtx;\n }\n \n+/* Return a base register that holds pic_offset_table_rtx.\n+   TEMP, if nonnull, is a scratch Pmode base register.  */\n+\n+rtx\n+mips_pic_base_register (rtx temp)\n+{\n+  if (!TARGET_MIPS16)\n+    return pic_offset_table_rtx;\n+\n+  if (can_create_pseudo_p ())\n+    return mips16_gp_pseudo_reg ();\n+\n+  if (TARGET_USE_GOT)\n+    /* The first post-reload split exposes all references to $gp\n+       (both uses and definitions).  All references must remain\n+       explicit after that point.\n+\n+       It is safe to introduce uses of $gp at any time, so for\n+       simplicity, we do that before the split too.  */\n+    mips_emit_move (temp, pic_offset_table_rtx);\n+  else\n+    emit_insn (gen_load_const_gp (temp));\n+  return temp;\n+}\n+\n+/* Create and return a GOT reference of type TYPE for address ADDR.\n+   TEMP, if nonnull, is a scratch Pmode base register.  */\n+\n+rtx\n+mips_got_load (rtx temp, rtx addr, enum mips_symbol_type type)\n+{\n+  rtx base, high, lo_sum_symbol;\n+\n+  base = mips_pic_base_register (temp);\n+\n+  /* If we used the temporary register to load $gp, we can't use\n+     it for the high part as well.  */\n+  if (temp != NULL && reg_overlap_mentioned_p (base, temp))\n+    temp = NULL;\n+\n+  high = mips_unspec_offset_high (temp, base, addr, type);\n+  lo_sum_symbol = mips_unspec_address (addr, type);\n+\n+  if (type == SYMBOL_GOTOFF_CALL)\n+    return (Pmode == SImode\n+\t    ? gen_unspec_callsi (high, lo_sum_symbol)\n+\t    : gen_unspec_calldi (high, lo_sum_symbol));\n+  else\n+    return (Pmode == SImode\n+\t    ? gen_unspec_gotsi (high, lo_sum_symbol)\n+\t    : gen_unspec_gotdi (high, lo_sum_symbol));\n+}\n+\n /* If MODE is MAX_MACHINE_MODE, ADDR appears as a move operand, otherwise\n    it appears in a MEM of that mode.  Return true if ADDR is a legitimate\n-   constant in that context and can be split into a high part and a LO_SUM.\n-   If so, and if LO_SUM_OUT is nonnull, emit the high part and return\n-   the LO_SUM in *LO_SUM_OUT.  Leave *LO_SUM_OUT unchanged otherwise.\n+   constant in that context and can be split into high and low parts.\n+   If so, and if LOW_OUT is nonnull, emit the high part and store the\n+   low part in *LOW_OUT.  Leave *LOW_OUT unchanged otherwise.\n \n    TEMP is as for mips_force_temporary and is used to load the high\n-   part into a register.  */\n+   part into a register.\n+\n+   When MODE is MAX_MACHINE_MODE, the low part is guaranteed to be\n+   a legitimize SET_SRC for an .md pattern, otherwise the low part\n+   is guaranteed to be a legitimate address for mode MODE.  */\n \n bool\n-mips_split_symbol (rtx temp, rtx addr, enum machine_mode mode, rtx *lo_sum_out)\n+mips_split_symbol (rtx temp, rtx addr, enum machine_mode mode, rtx *low_out)\n {\n   enum mips_symbol_context context;\n   enum mips_symbol_type symbol_type;\n@@ -2376,31 +2524,56 @@ mips_split_symbol (rtx temp, rtx addr, enum machine_mode mode, rtx *lo_sum_out)\n   context = (mode == MAX_MACHINE_MODE\n \t     ? SYMBOL_CONTEXT_LEA\n \t     : SYMBOL_CONTEXT_MEM);\n-  if (!mips_symbolic_constant_p (addr, context, &symbol_type)\n-      || mips_symbol_insns (symbol_type, mode) == 0\n-      || !mips_split_p[symbol_type])\n-    return false;\n-\n-  if (lo_sum_out)\n+  if (GET_CODE (addr) == HIGH && context == SYMBOL_CONTEXT_LEA)\n     {\n-      if (symbol_type == SYMBOL_GP_RELATIVE)\n+      addr = XEXP (addr, 0);\n+      if (mips_symbolic_constant_p (addr, context, &symbol_type)\n+\t  && mips_symbol_insns (symbol_type, mode) > 0\n+\t  && mips_split_hi_p[symbol_type])\n \t{\n-\t  if (!can_create_pseudo_p ())\n-\t    {\n-\t      emit_insn (gen_load_const_gp (temp));\n-\t      high = temp;\n-\t    }\n-\t  else\n-\t    high = mips16_gp_pseudo_reg ();\n+\t  if (low_out)\n+\t    switch (symbol_type)\n+\t      {\n+\t      case SYMBOL_GOT_PAGE_OFST:\n+\t\t/* The high part of a page/ofst pair is loaded from the GOT.  */\n+\t\t*low_out = mips_got_load (temp, addr, SYMBOL_GOTOFF_PAGE);\n+\t\tbreak;\n+\n+\t      default:\n+\t\tgcc_unreachable ();\n+\t      }\n+\t  return true;\n \t}\n-      else\n+    }\n+  else\n+    {\n+      if (mips_symbolic_constant_p (addr, context, &symbol_type)\n+\t  && mips_symbol_insns (symbol_type, mode) > 0\n+\t  && mips_split_p[symbol_type])\n \t{\n-\t  high = gen_rtx_HIGH (Pmode, copy_rtx (addr));\n-\t  high = mips_force_temporary (temp, high);\n+\t  if (low_out)\n+\t    switch (symbol_type)\n+\t      {\n+\t      case SYMBOL_GOT_DISP:\n+\t\t/* SYMBOL_GOT_DISP symbols are loaded from the GOT.  */\n+\t\t*low_out = mips_got_load (temp, addr, SYMBOL_GOTOFF_DISP);\n+\t\tbreak;\n+\n+\t      case SYMBOL_GP_RELATIVE:\n+\t\thigh = mips_pic_base_register (temp);\n+\t\t*low_out = gen_rtx_LO_SUM (Pmode, high, addr);\n+\t\tbreak;\n+\n+\t      default:\n+\t\thigh = gen_rtx_HIGH (Pmode, copy_rtx (addr));\n+\t\thigh = mips_force_temporary (temp, high);\n+\t\t*low_out = gen_rtx_LO_SUM (Pmode, high, addr);\n+\t\tbreak;\n+\t      }\n+\t  return true;\n \t}\n-      *lo_sum_out = gen_rtx_LO_SUM (Pmode, high, addr);\n     }\n-  return true;\n+  return false;\n }\n \n /* Return a legitimate address for REG + OFFSET.  TEMP is as for\n@@ -2457,7 +2630,8 @@ mips_call_tls_get_addr (rtx sym, enum mips_symbol_type type, rtx v0)\n \n   emit_insn (gen_rtx_SET (Pmode, a0,\n \t\t\t  gen_rtx_LO_SUM (Pmode, pic_offset_table_rtx, loc)));\n-  insn = mips_expand_call (v0, mips_tls_symbol, const0_rtx, const0_rtx, false);\n+  insn = mips_expand_call (MIPS_CALL_NORMAL, v0, mips_tls_symbol,\n+\t\t\t   const0_rtx, NULL_RTX, false);\n   RTL_CONST_CALL_P (insn) = 1;\n   use_reg (&CALL_INSN_FUNCTION_USAGE (insn), a0);\n   insn = get_insns ();\n@@ -2716,7 +2890,8 @@ mips_rewrite_small_data_p (rtx x, enum mips_symbol_context context)\n {\n   enum mips_symbol_type symbol_type;\n \n-  return (TARGET_EXPLICIT_RELOCS\n+  return (mips_lo_relocs[SYMBOL_GP_RELATIVE]\n+\t  && !mips_split_p[SYMBOL_GP_RELATIVE]\n \t  && mips_symbolic_constant_p (x, context, &symbol_type)\n \t  && symbol_type == SYMBOL_GP_RELATIVE);\n }\n@@ -5215,33 +5390,27 @@ mips_ok_for_lazy_binding_p (rtx x)\n {\n   return (TARGET_USE_GOT\n \t  && GET_CODE (x) == SYMBOL_REF\n+\t  && !SYMBOL_REF_BIND_NOW_P (x)\n \t  && !mips_symbol_binds_local_p (x));\n }\n \n-/* Load function address ADDR into register DEST.  SIBCALL_P is true\n-   if the address is needed for a sibling call.  Return true if we\n-   used an explicit lazy-binding sequence.  */\n+/* Load function address ADDR into register DEST.  TYPE is as for\n+   mips_expand_call.  Return true if we used an explicit lazy-binding\n+   sequence.  */\n \n static bool\n-mips_load_call_address (rtx dest, rtx addr, bool sibcall_p)\n+mips_load_call_address (enum mips_call_type type, rtx dest, rtx addr)\n {\n   /* If we're generating PIC, and this call is to a global function,\n      try to allow its address to be resolved lazily.  This isn't\n      possible for sibcalls when $gp is call-saved because the value\n      of $gp on entry to the stub would be our caller's gp, not ours.  */\n   if (TARGET_EXPLICIT_RELOCS\n-      && !(sibcall_p && TARGET_CALL_SAVED_GP)\n+      && !(type == MIPS_CALL_SIBCALL && TARGET_CALL_SAVED_GP)\n       && mips_ok_for_lazy_binding_p (addr))\n     {\n-      rtx high, lo_sum_symbol;\n-\n-      high = mips_unspec_offset_high (dest, pic_offset_table_rtx,\n-\t\t\t\t      addr, SYMBOL_GOTOFF_CALL);\n-      lo_sum_symbol = mips_unspec_address (addr, SYMBOL_GOTOFF_CALL);\n-      if (Pmode == SImode)\n-\temit_insn (gen_load_callsi (dest, high, lo_sum_symbol));\n-      else\n-\temit_insn (gen_load_calldi (dest, high, lo_sum_symbol));\n+      addr = mips_got_load (dest, addr, SYMBOL_GOTOFF_CALL);\n+      emit_insn (gen_rtx_SET (VOIDmode, dest, addr));\n       return true;\n     }\n   else\n@@ -5251,6 +5420,78 @@ mips_load_call_address (rtx dest, rtx addr, bool sibcall_p)\n     }\n }\n \f\n+/* Each locally-defined hard-float MIPS16 function has a local symbol\n+   associated with it.  This hash table maps the function symbol (FUNC)\n+   to the local symbol (LOCAL). */\n+struct mips16_local_alias GTY(()) {\n+  rtx func;\n+  rtx local;\n+};\n+static GTY ((param_is (struct mips16_local_alias))) htab_t mips16_local_aliases;\n+\n+/* Hash table callbacks for mips16_local_aliases.  */\n+\n+static hashval_t\n+mips16_local_aliases_hash (const void *entry)\n+{\n+  const struct mips16_local_alias *alias;\n+\n+  alias = (const struct mips16_local_alias *) entry;\n+  return htab_hash_string (XSTR (alias->func, 0));\n+}\n+\n+static int\n+mips16_local_aliases_eq (const void *entry1, const void *entry2)\n+{\n+  const struct mips16_local_alias *alias1, *alias2;\n+\n+  alias1 = (const struct mips16_local_alias *) entry1;\n+  alias2 = (const struct mips16_local_alias *) entry2;\n+  return rtx_equal_p (alias1->func, alias2->func);\n+}\n+\n+/* FUNC is the symbol for a locally-defined hard-float MIPS16 function.\n+   Return a local alias for it, creating a new one if necessary.  */\n+\n+static rtx\n+mips16_local_alias (rtx func)\n+{\n+  struct mips16_local_alias *alias, tmp_alias;\n+  void **slot;\n+\n+  /* Create the hash table if this is the first call.  */\n+  if (mips16_local_aliases == NULL)\n+    mips16_local_aliases = htab_create_ggc (37, mips16_local_aliases_hash,\n+\t\t\t\t\t    mips16_local_aliases_eq, NULL);\n+\n+  /* Look up the function symbol, creating a new entry if need be.  */\n+  tmp_alias.func = func;\n+  slot = htab_find_slot (mips16_local_aliases, &tmp_alias, INSERT);\n+  gcc_assert (slot != NULL);\n+\n+  alias = (struct mips16_local_alias *) *slot;\n+  if (alias == NULL)\n+    {\n+      const char *func_name, *local_name;\n+      rtx local;\n+\n+      /* Create a new SYMBOL_REF for the local symbol.  The choice of\n+\t __fn_local_* is based on the __fn_stub_* names that we've\n+\t traditionally used for the non-MIPS16 stub.  */\n+      func_name = targetm.strip_name_encoding (XSTR (func, 0));\n+      local_name = ACONCAT ((\"__fn_local_\", func_name, NULL));\n+      local = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (local_name));\n+      SYMBOL_REF_FLAGS (local) = SYMBOL_REF_FLAGS (func) | SYMBOL_FLAG_LOCAL;\n+\n+      /* Create a new structure to represent the mapping.  */\n+      alias = GGC_NEW (struct mips16_local_alias);\n+      alias->func = func;\n+      alias->local = local;\n+      *slot = alias;\n+    }\n+  return alias->local;\n+}\n+\f\n /* A chained list of functions for which mips16_build_call_stub has already\n    generated a stub.  NAME is the name of the function and FP_RET_P is true\n    if the function returns a value in floating-point registers.  */\n@@ -5261,6 +5502,18 @@ struct mips16_stub {\n };\n static struct mips16_stub *mips16_stubs;\n \n+/* Return a SYMBOL_REF for a MIPS16 function called NAME.  */\n+\n+static rtx\n+mips16_stub_function (const char *name)\n+{\n+  rtx x;\n+\n+  x = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (name));\n+  SYMBOL_REF_FLAGS (x) |= (SYMBOL_FLAG_EXTERNAL | SYMBOL_FLAG_FUNCTION);\n+  return x;\n+}\n+\n /* Return the two-character string that identifies floating-point\n    return mode MODE in the name of a MIPS16 function stub.  */\n \n@@ -5367,14 +5620,18 @@ mips_output_args_xfer (int fp_code, char direction)\n static void\n mips16_build_function_stub (void)\n {\n-  const char *fnname, *separator;\n+  const char *fnname, *alias_name, *separator;\n   char *secname, *stubname;\n   tree stubdecl;\n   unsigned int f;\n+  rtx symbol, alias;\n \n   /* Create the name of the stub, and its unique section.  */\n-  fnname = XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0);\n-  fnname = targetm.strip_name_encoding (fnname);\n+  symbol = XEXP (DECL_RTL (current_function_decl), 0);\n+  alias = mips16_local_alias (symbol);\n+\n+  fnname = targetm.strip_name_encoding (XSTR (symbol, 0));\n+  alias_name = targetm.strip_name_encoding (XSTR (alias, 0));\n   secname = ACONCAT ((\".mips16.fn.\", fnname, NULL));\n   stubname = ACONCAT ((\"__fn_stub_\", fnname, NULL));\n \n@@ -5400,23 +5657,48 @@ mips16_build_function_stub (void)\n   assemble_start_function (stubdecl, stubname);\n   mips_start_function_definition (stubname, false);\n \n+  /* If generating abicalls code, either set up the global pointer or\n+     switch to absolute mode.  */\n+  if (TARGET_ABSOLUTE_ABICALLS)\n+    fprintf (asm_out_file, \"\\t.option\\tpic0\\n\");\n+  else if (TARGET_ABICALLS)\n+    {\n+      output_asm_insn (\"%(.cpload\\t%^%)\", NULL);\n+      /* Emit an R_MIPS_NONE relocation to tell the linker what the\n+\t target function is.  Use a local GOT access when loading the\n+\t symbol, to cut down on the number of unnecessary GOT entries\n+\t for stubs that aren't needed.  */\n+      output_asm_insn (\".reloc\\t0,R_MIPS_NONE,%0\", &symbol);\n+      symbol = alias;\n+    }\n+\n   /* Load the address of the MIPS16 function into $at.  Do this first so\n      that targets with coprocessor interlocks can use an MFC1 to fill the\n      delay slot.  */\n   fprintf (asm_out_file, \"\\t.set\\tnoat\\n\");\n-  fprintf (asm_out_file, \"\\tla\\t%s,\", reg_names[GP_REG_FIRST + 1]);\n-  assemble_name (asm_out_file, fnname);\n-  fprintf (asm_out_file, \"\\n\");\n+  output_asm_insn (\"la\\t%@,%0\", &symbol);\n \n   /* Move the arguments from floating-point registers to general registers.  */\n   mips_output_args_xfer (crtl->args.info.fp_code, 'f');\n \n   /* Jump to the MIPS16 function.  */\n-  fprintf (asm_out_file, \"\\tjr\\t%s\\n\", reg_names[GP_REG_FIRST + 1]);\n+  output_asm_insn (\"jr\\t%@\", NULL);\n   fprintf (asm_out_file, \"\\t.set\\tat\\n\");\n \n+  if (TARGET_ABSOLUTE_ABICALLS)\n+    fprintf (asm_out_file, \"\\t.option\\tpic2\\n\");\n+\n   mips_end_function_definition (stubname);\n \n+  /* If the linker needs to create a dynamic symbol for the target\n+     function, it will associate the symbol with the stub (which,\n+     unlike the target function, follows the proper calling conventions).\n+     It is therefore useful to have a local alias for the target function,\n+     so that it can still be identified as MIPS16 code.  As an optimization,\n+     this symbol can also be used for indirect MIPS16 references from\n+     within this file.  */\n+  ASM_OUTPUT_DEF (asm_out_file, alias_name, fnname);\n+\n   switch_to_section (function_section (current_function_decl));\n }\n \n@@ -5427,31 +5709,46 @@ mips16_build_function_stub (void)\n static void\n mips16_copy_fpr_return_value (void)\n {\n-  rtx fn, insn, arg, call;\n-  tree id, return_type;\n+  rtx fn, insn, retval;\n+  tree return_type;\n   enum machine_mode return_mode;\n+  const char *name;\n \n   return_type = DECL_RESULT (current_function_decl);\n   return_mode = DECL_MODE (return_type);\n \n-  id = get_identifier (ACONCAT ((\"__mips16_ret_\",\n-\t\t\t\t mips16_call_stub_mode_suffix (return_mode),\n-\t\t\t\t NULL)));\n-  fn = gen_rtx_SYMBOL_REF (Pmode, IDENTIFIER_POINTER (id));\n-  arg = gen_rtx_REG (return_mode, GP_RETURN);\n-  call = gen_call_value_internal (arg, fn, const0_rtx);\n-  insn = mips_emit_call_insn (call, false);\n-  use_reg (&CALL_INSN_FUNCTION_USAGE (insn), arg);\n+  name = ACONCAT ((\"__mips16_ret_\",\n+\t\t   mips16_call_stub_mode_suffix (return_mode),\n+\t\t   NULL));\n+  fn = mips16_stub_function (name);\n+\n+  /* The function takes arguments in $2 (and possibly $3), so calls\n+     to it cannot be lazily bound.  */\n+  SYMBOL_REF_FLAGS (fn) |= SYMBOL_FLAG_BIND_NOW;\n+\n+  /* Model the call as something that takes the GPR return value as\n+     argument and returns an \"updated\" value.  */\n+  retval = gen_rtx_REG (return_mode, GP_RETURN);\n+  insn = mips_expand_call (MIPS_CALL_EPILOGUE, retval, fn,\n+\t\t\t   const0_rtx, NULL_RTX, false);\n+  use_reg (&CALL_INSN_FUNCTION_USAGE (insn), retval);\n }\n \n-/* Consider building a stub for a MIPS16 call to function FN.\n+/* Consider building a stub for a MIPS16 call to function *FN_PTR.\n    RETVAL is the location of the return value, or null if this is\n    a \"call\" rather than a \"call_value\".  ARGS_SIZE is the size of the\n    arguments and FP_CODE is the code built by mips_function_arg;\n    see the comment above CUMULATIVE_ARGS for details.\n \n-   If a stub was needed, emit the call and return the call insn itself.\n-   Return null otherwise.\n+   There are three alternatives:\n+\n+   - If a stub was needed, emit the call and return the call insn itself.\n+\n+   - If we can avoid using a stub by redirecting the call, set *FN_PTR\n+     to the new target and return null.\n+\n+   - If *FN_PTR doesn't need a stub, return null and leave *FN_PTR\n+     unmodified.\n \n    A stub is needed for calls to functions that, in normal mode,\n    receive arguments in FPRs or return values in FPRs.  The stub\n@@ -5460,17 +5757,18 @@ mips16_copy_fpr_return_value (void)\n    return value from its hard-float position to its soft-float\n    position.\n \n-   We emit a JAL to FN even when FN might need a stub.  If FN turns out\n-   to be to a non-MIPS16 function, the linker automatically redirects\n-   the JAL to the stub, otherwise the JAL continues to call FN directly.  */\n+   We can emit a JAL to *FN_PTR even when *FN_PTR might need a stub.\n+   If *FN_PTR turns out to be to a non-MIPS16 function, the linker\n+   automatically redirects the JAL to the stub, otherwise the JAL\n+   continues to call FN directly.  */\n \n static rtx\n-mips16_build_call_stub (rtx retval, rtx fn, rtx args_size, int fp_code)\n+mips16_build_call_stub (rtx retval, rtx *fn_ptr, rtx args_size, int fp_code)\n {\n   const char *fnname;\n   bool fp_ret_p;\n   struct mips16_stub *l;\n-  rtx insn;\n+  rtx insn, fn;\n \n   /* We don't need to do anything if we aren't in MIPS16 mode, or if\n      we were invoked with the -msoft-float option.  */\n@@ -5489,8 +5787,8 @@ mips16_build_call_stub (rtx retval, rtx fn, rtx args_size, int fp_code)\n \n   /* We don't need to do anything if this is a call to a special\n      MIPS16 support function.  */\n-  if (GET_CODE (fn) == SYMBOL_REF\n-      && strncmp (XSTR (fn, 0), \"__mips16_\", 9) == 0)\n+  fn = *fn_ptr;\n+  if (mips16_stub_function_p (fn))\n     return NULL_RTX;\n \n   /* This code will only work for o32 and o64 abis.  The other ABI's\n@@ -5500,11 +5798,20 @@ mips16_build_call_stub (rtx retval, rtx fn, rtx args_size, int fp_code)\n   /* If we're calling via a function pointer, use one of the magic\n      libgcc.a stubs provided for each (FP_CODE, FP_RET_P) combination.\n      Each stub expects the function address to arrive in register $2.  */\n-  if (GET_CODE (fn) != SYMBOL_REF)\n+  if (GET_CODE (fn) != SYMBOL_REF\n+      || !call_insn_operand (fn, VOIDmode))\n     {\n       char buf[30];\n-      tree id;\n-      rtx stub_fn, insn;\n+      rtx stub_fn, insn, addr;\n+      bool lazy_p;\n+\n+      /* If this is a locally-defined and locally-binding function,\n+\t avoid the stub by calling the local alias directly.  */\n+      if (mips16_local_function_p (fn))\n+\t{\n+\t  *fn_ptr = mips16_local_alias (fn);\n+\t  return NULL_RTX;\n+\t}\n \n       /* Create a SYMBOL_REF for the libgcc.a function.  */\n       if (fp_ret_p)\n@@ -5513,24 +5820,22 @@ mips16_build_call_stub (rtx retval, rtx fn, rtx args_size, int fp_code)\n \t\t fp_code);\n       else\n \tsprintf (buf, \"__mips16_call_stub_%d\", fp_code);\n-      id = get_identifier (buf);\n-      stub_fn = gen_rtx_SYMBOL_REF (Pmode, IDENTIFIER_POINTER (id));\n+      stub_fn = mips16_stub_function (buf);\n+\n+      /* The function uses $2 as an argument, so calls to it\n+\t cannot be lazily bound.  */\n+      SYMBOL_REF_FLAGS (stub_fn) |= SYMBOL_FLAG_BIND_NOW;\n \n       /* Load the target function into $2.  */\n-      mips_emit_move (gen_rtx_REG (Pmode, 2), fn);\n+      addr = gen_rtx_REG (Pmode, GP_REG_FIRST + 2);\n+      lazy_p = mips_load_call_address (MIPS_CALL_NORMAL, addr, fn);\n \n       /* Emit the call.  */\n-      if (retval == NULL_RTX)\n-\tinsn = gen_call_internal (stub_fn, args_size);\n-      else\n-\tinsn = gen_call_value_internal (retval, stub_fn, args_size);\n-      insn = mips_emit_call_insn (insn, false);\n+      insn = mips_expand_call (MIPS_CALL_NORMAL, retval, stub_fn,\n+\t\t\t       args_size, NULL_RTX, lazy_p);\n \n       /* Tell GCC that this call does indeed use the value of $2.  */\n-      CALL_INSN_FUNCTION_USAGE (insn) =\n-\tgen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\t   gen_rtx_USE (VOIDmode, gen_rtx_REG (Pmode, 2)),\n-\t\t\t   CALL_INSN_FUNCTION_USAGE (insn));\n+      use_reg (&CALL_INSN_FUNCTION_USAGE (insn), addr);\n \n       /* If we are handling a floating-point return value, we need to\n          save $18 in the function prologue.  Putting a note on the\n@@ -5540,8 +5845,8 @@ mips16_build_call_stub (rtx retval, rtx fn, rtx args_size, int fp_code)\n       if (fp_ret_p)\n \tCALL_INSN_FUNCTION_USAGE (insn) =\n \t  gen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\t     gen_rtx_USE (VOIDmode,\n-\t\t\t\t\t  gen_rtx_REG (word_mode, 18)),\n+\t\t\t     gen_rtx_CLOBBER (VOIDmode,\n+\t\t\t\t\t      gen_rtx_REG (word_mode, 18)),\n \t\t\t     CALL_INSN_FUNCTION_USAGE (insn));\n \n       return insn;\n@@ -5605,8 +5910,13 @@ mips16_build_call_stub (rtx retval, rtx fn, rtx args_size, int fp_code)\n \t     first so that targets with coprocessor interlocks can use\n \t     an MFC1 to fill the delay slot.  */\n \t  fprintf (asm_out_file, \"\\t.set\\tnoat\\n\");\n-\t  fprintf (asm_out_file, \"\\tla\\t%s,%s\\n\", reg_names[GP_REG_FIRST + 1],\n-\t\t   fnname);\n+\t  if (TARGET_EXPLICIT_RELOCS)\n+\t    {\n+\t      output_asm_insn (\"lui\\t%^,%%hi(%0)\", &fn);\n+\t      output_asm_insn (\"addiu\\t%^,%^,%%lo(%0)\", &fn);\n+\t    }\n+\t  else\n+\t    output_asm_insn (\"la\\t%^,%0\", &fn);\n \t}\n \n       /* Move the arguments from general registers to floating-point\n@@ -5616,7 +5926,7 @@ mips16_build_call_stub (rtx retval, rtx fn, rtx args_size, int fp_code)\n       if (!fp_ret_p)\n \t{\n \t  /* Jump to the previously-loaded address.  */\n-\t  fprintf (asm_out_file, \"\\tjr\\t%s\\n\", reg_names[GP_REG_FIRST + 1]);\n+\t  output_asm_insn (\"jr\\t%^\", NULL);\n \t  fprintf (asm_out_file, \"\\t.set\\tat\\n\");\n \t}\n       else\n@@ -5626,7 +5936,7 @@ mips16_build_call_stub (rtx retval, rtx fn, rtx args_size, int fp_code)\n \t     $18 is usually a call-saved register.  */\n \t  fprintf (asm_out_file, \"\\tmove\\t%s,%s\\n\",\n \t\t   reg_names[GP_REG_FIRST + 18], reg_names[GP_REG_FIRST + 31]);\n-\t  fprintf (asm_out_file, \"\\tjal\\t%s\\n\", fnname);\n+\t  output_asm_insn (MIPS_CALL (\"jal\", &fn, 0), &fn);\n \n \t  /* Move the result from floating-point registers to\n \t     general registers.  */\n@@ -5696,7 +6006,7 @@ mips16_build_call_stub (rtx retval, rtx fn, rtx args_size, int fp_code)\n     insn = gen_call_internal_direct (fn, args_size);\n   else\n     insn = gen_call_value_internal_direct (retval, fn, args_size);\n-  insn = mips_emit_call_insn (insn, false);\n+  insn = mips_emit_call_insn (insn, fn, fn, false);\n \n   /* If we are calling a stub which handles a floating-point return\n      value, we need to arrange to save $18 in the prologue.  We do this\n@@ -5705,70 +6015,114 @@ mips16_build_call_stub (rtx retval, rtx fn, rtx args_size, int fp_code)\n   if (fp_ret_p)\n     CALL_INSN_FUNCTION_USAGE (insn) =\n       gen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\t gen_rtx_USE (VOIDmode, gen_rtx_REG (word_mode, 18)),\n+\t\t\t gen_rtx_CLOBBER (VOIDmode,\n+\t\t\t\t\t  gen_rtx_REG (word_mode, 18)),\n \t\t\t CALL_INSN_FUNCTION_USAGE (insn));\n \n   return insn;\n }\n \f\n-/* Expand a \"call\", \"sibcall\", \"call_value\" or \"sibcall_value\" instruction.\n-   RESULT is where the result will go (null for \"call\"s and \"sibcall\"s),\n-   ADDR is the address of the function, ARGS_SIZE is the size of the\n-   arguments and AUX is the value passed to us by mips_function_arg.\n-   SIBCALL_P is true if we are expanding a sibling call, false if we're\n-   expanding a normal call.\n+/* Expand a call of type TYPE.  RESULT is where the result will go (null\n+   for \"call\"s and \"sibcall\"s), ADDR is the address of the function,\n+   ARGS_SIZE is the size of the arguments and AUX is the value passed\n+   to us by mips_function_arg.  LAZY_P is true if this call already\n+   involves a lazily-bound function address (such as when calling\n+   functions through a MIPS16 hard-float stub).\n \n    Return the call itself.  */\n \n rtx\n-mips_expand_call (rtx result, rtx addr, rtx args_size, rtx aux, bool sibcall_p)\n+mips_expand_call (enum mips_call_type type, rtx result, rtx addr,\n+\t\t  rtx args_size, rtx aux, bool lazy_p)\n {\n   rtx orig_addr, pattern, insn;\n-  bool lazy_p;\n+  int fp_code;\n \n+  fp_code = aux == 0 ? 0 : (int) GET_MODE (aux);\n+  insn = mips16_build_call_stub (result, &addr, args_size, fp_code);\n+  if (insn)\n+    {\n+      gcc_assert (!lazy_p && type == MIPS_CALL_NORMAL);\n+      return insn;\n+    }\n+\t\t\t\t ;\n   orig_addr = addr;\n-  lazy_p = false;\n   if (!call_insn_operand (addr, VOIDmode))\n     {\n-      addr = gen_reg_rtx (Pmode);\n-      lazy_p = mips_load_call_address (addr, orig_addr, sibcall_p);\n+      if (type == MIPS_CALL_EPILOGUE)\n+\taddr = MIPS_EPILOGUE_TEMP (Pmode);\n+      else\n+\taddr = gen_reg_rtx (Pmode);\n+      lazy_p |= mips_load_call_address (type, addr, orig_addr);\n     }\n \n-  insn = mips16_build_call_stub (result, addr, args_size,\n-\t\t\t\t aux == 0 ? 0 : (int) GET_MODE (aux));\n-  if (insn)\n+  if (result == 0)\n     {\n-      gcc_assert (!sibcall_p && !lazy_p);\n-      return insn;\n-    }\n+      rtx (*fn) (rtx, rtx);\n \n-  if (result == 0)\n-    pattern = (sibcall_p\n-\t       ? gen_sibcall_internal (addr, args_size)\n-\t       : gen_call_internal (addr, args_size));\n+      if (type == MIPS_CALL_EPILOGUE && TARGET_SPLIT_CALLS)\n+\tfn = gen_call_split;\n+      else if (type == MIPS_CALL_SIBCALL)\n+\tfn = gen_sibcall_internal;\n+      else\n+\tfn = gen_call_internal;\n+\n+      pattern = fn (addr, args_size);\n+    }\n   else if (GET_CODE (result) == PARALLEL && XVECLEN (result, 0) == 2)\n     {\n       /* Handle return values created by mips_return_fpr_pair.  */\n+      rtx (*fn) (rtx, rtx, rtx, rtx);\n       rtx reg1, reg2;\n \n+      if (type == MIPS_CALL_EPILOGUE && TARGET_SPLIT_CALLS)\n+\tfn = gen_call_value_multiple_split;\n+      else if (type == MIPS_CALL_SIBCALL)\n+\tfn = gen_sibcall_value_multiple_internal;\n+      else\n+\tfn = gen_call_value_multiple_internal;\n+\n       reg1 = XEXP (XVECEXP (result, 0, 0), 0);\n       reg2 = XEXP (XVECEXP (result, 0, 1), 0);\n-      pattern =\n-\t(sibcall_p\n-\t ? gen_sibcall_value_multiple_internal (reg1, addr, args_size, reg2)\n-\t : gen_call_value_multiple_internal (reg1, addr, args_size, reg2));\n+      pattern = fn (reg1, addr, args_size, reg2);\n     }\n   else\n     {\n+      rtx (*fn) (rtx, rtx, rtx);\n+\n+      if (type == MIPS_CALL_EPILOGUE && TARGET_SPLIT_CALLS)\n+\tfn = gen_call_value_split;\n+      else if (type == MIPS_CALL_SIBCALL)\n+\tfn = gen_sibcall_value_internal;\n+      else\n+\tfn = gen_call_value_internal;\n+\n       /* Handle return values created by mips_return_fpr_single.  */\n       if (GET_CODE (result) == PARALLEL && XVECLEN (result, 0) == 1)\n \tresult = XEXP (XVECEXP (result, 0, 0), 0);\n-      pattern = (sibcall_p\n-\t\t ? gen_sibcall_value_internal (result, addr, args_size)\n-\t\t : gen_call_value_internal (result, addr, args_size));\n+      pattern = fn (result, addr, args_size);\n     }\n \n-  return mips_emit_call_insn (pattern, lazy_p);\n+  return mips_emit_call_insn (pattern, orig_addr, addr, lazy_p);\n+}\n+\n+/* Split call instruction INSN into a $gp-clobbering call and\n+   (where necessary) an instruction to restore $gp from its save slot.\n+   CALL_PATTERN is the pattern of the new call.  */\n+\n+void\n+mips_split_call (rtx insn, rtx call_pattern)\n+{\n+  rtx new_insn;\n+\n+  new_insn = emit_call_insn (call_pattern);\n+  CALL_INSN_FUNCTION_USAGE (new_insn)\n+    = copy_rtx (CALL_INSN_FUNCTION_USAGE (insn));\n+  if (!find_reg_note (insn, REG_NORETURN, 0))\n+    /* Pick a temporary register that is suitable for both MIPS16 and\n+       non-MIPS16 code.  $4 and $5 are used for returning complex double\n+       values in soft-float code, so $6 is the first suitable candidate.  */\n+    mips_restore_gp (gen_rtx_REG (Pmode, GP_ARG_FIRST + 2));\n }\n \n /* Implement TARGET_FUNCTION_OK_FOR_SIBCALL.  */\n@@ -6315,6 +6669,7 @@ static void\n mips_init_relocs (void)\n {\n   memset (mips_split_p, '\\0', sizeof (mips_split_p));\n+  memset (mips_split_hi_p, '\\0', sizeof (mips_split_hi_p));\n   memset (mips_hi_relocs, '\\0', sizeof (mips_hi_relocs));\n   memset (mips_lo_relocs, '\\0', sizeof (mips_lo_relocs));\n \n@@ -6356,13 +6711,13 @@ mips_init_relocs (void)\n       mips_split_p[SYMBOL_GP_RELATIVE] = true;\n       mips_lo_relocs[SYMBOL_GP_RELATIVE] = \"%gprel(\";\n     }\n+  else if (TARGET_EXPLICIT_RELOCS)\n+    /* Small data constants are kept whole until after reload,\n+       then lowered by mips_rewrite_small_data.  */\n+    mips_lo_relocs[SYMBOL_GP_RELATIVE] = \"%gp_rel(\";\n \n   if (TARGET_EXPLICIT_RELOCS)\n     {\n-      /* Small data constants are kept whole until after reload,\n-\t then lowered by mips_rewrite_small_data.  */\n-      mips_lo_relocs[SYMBOL_GP_RELATIVE] = \"%gp_rel(\";\n-\n       mips_split_p[SYMBOL_GOT_PAGE_OFST] = true;\n       if (TARGET_NEWABI)\n \t{\n@@ -6374,6 +6729,9 @@ mips_init_relocs (void)\n \t  mips_lo_relocs[SYMBOL_GOTOFF_PAGE] = \"%got(\";\n \t  mips_lo_relocs[SYMBOL_GOT_PAGE_OFST] = \"%lo(\";\n \t}\n+      if (TARGET_MIPS16)\n+\t/* Expose the use of $28 as soon as possible.  */\n+\tmips_split_hi_p[SYMBOL_GOT_PAGE_OFST] = true;\n \n       if (TARGET_XGOT)\n \t{\n@@ -6395,6 +6753,9 @@ mips_init_relocs (void)\n \t  else\n \t    mips_lo_relocs[SYMBOL_GOTOFF_DISP] = \"%got(\";\n \t  mips_lo_relocs[SYMBOL_GOTOFF_CALL] = \"%call16(\";\n+\t  if (TARGET_MIPS16)\n+\t    /* Expose the use of $28 as soon as possible.  */\n+\t    mips_split_p[SYMBOL_GOT_DISP] = true;\n \t}\n     }\n \n@@ -7939,6 +8300,7 @@ mips_global_pointer (void)\n      but no instruction will yet refer to it.  */\n   if (!df_regs_ever_live_p (GLOBAL_POINTER_REGNUM)\n       && !crtl->uses_const_pool\n+      && !mips16_cfun_returns_in_fpr_p ()\n       && !mips_function_has_gp_insn ())\n     return 0;\n \n@@ -8261,6 +8623,11 @@ mips_extra_live_on_entry (bitmap regs)\n       if (!TARGET_ABSOLUTE_ABICALLS)\n \tbitmap_set_bit (regs, PIC_FUNCTION_ADDR_REGNUM);\n \n+      /* The prologue may set MIPS16_PIC_TEMP_REGNUM to the value of\n+\t the global pointer.  */\n+      if (TARGET_MIPS16)\n+\tbitmap_set_bit (regs, MIPS16_PIC_TEMP_REGNUM);\n+\n       /* See the comment above load_call<mode> for details.  */\n       bitmap_set_bit (regs, GOT_VERSION_REGNUM);\n     }\n@@ -8293,20 +8660,45 @@ mips_set_return_address (rtx address, rtx scratch)\n   mips_emit_move (gen_frame_mem (GET_MODE (address), slot_address), address);\n }\n \n-/* Restore $gp from its save slot.  Valid only when using o32 or\n-   o64 abicalls.  */\n+/* Return a MEM rtx for the cprestore slot, using TEMP as a temporary base\n+   register if need be.  */\n \n-void\n-mips_restore_gp (void)\n+static rtx\n+mips_cprestore_slot (rtx temp)\n {\n-  rtx base, address;\n+  const struct mips_frame_info *frame;\n+  rtx base;\n+  HOST_WIDE_INT offset;\n \n+  frame = &cfun->machine->frame;\n+  if (frame_pointer_needed)\n+    {\n+      base = hard_frame_pointer_rtx;\n+      offset = frame->args_size - frame->hard_frame_pointer_offset;\n+    }\n+  else\n+    {\n+      base = stack_pointer_rtx;\n+      offset = frame->args_size;\n+    }\n+  return gen_frame_mem (Pmode, mips_add_offset (temp, base, offset));\n+}\n+\n+/* Restore $gp from its save slot, using TEMP as a temporary base register\n+   if need be.  This function is for o32 and o64 abicalls only.  */\n+\n+void\n+mips_restore_gp (rtx temp)\n+{\n   gcc_assert (TARGET_ABICALLS && TARGET_OLDABI);\n \n-  base = frame_pointer_needed ? hard_frame_pointer_rtx : stack_pointer_rtx;\n-  address = mips_add_offset (pic_offset_table_rtx, base,\n-\t\t\t     crtl->outgoing_args_size);\n-  mips_emit_move (pic_offset_table_rtx, gen_frame_mem (Pmode, address));\n+  if (TARGET_MIPS16)\n+    {\n+      mips_emit_move (temp, mips_cprestore_slot (temp));\n+      mips_emit_move (pic_offset_table_rtx, temp);\n+    }\n+  else\n+    mips_emit_move (pic_offset_table_rtx, mips_cprestore_slot (temp));\n   if (!TARGET_EXPLICIT_RELOCS)\n     emit_insn (gen_blockage ());\n }\n@@ -8448,8 +8840,18 @@ mips_output_function_prologue (FILE *file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n      that need it.  */\n   if (mips_current_loadgp_style () == LOADGP_OLDABI)\n     {\n+      if (TARGET_MIPS16)\n+\t{\n+\t  /* This is a fixed-form sequence.  The position of the\n+\t     first two instructions is important because of the\n+\t     way _gp_disp is defined.  */\n+\t  output_asm_insn (\"li\\t$2,%%hi(_gp_disp)\", 0);\n+\t  output_asm_insn (\"addiu\\t$3,$pc,%%lo(_gp_disp)\", 0);\n+\t  output_asm_insn (\"sll\\t$2,16\", 0);\n+\t  output_asm_insn (\"addu\\t$2,$3\", 0);\n+\t}\n       /* .cpload must be in a .set noreorder but not a .set nomacro block.  */\n-      if (!cfun->machine->all_noreorder_p)\n+      else if (!cfun->machine->all_noreorder_p)\n \toutput_asm_insn (\"%(.cpload\\t%^%)\", 0);\n       else\n \toutput_asm_insn (\"%(.cpload\\t%^\\n\\t%<\", 0);\n@@ -8541,7 +8943,7 @@ mips_emit_loadgp (void)\n {\n   rtx addr, offset, incoming_address, base, index, pic_reg;\n \n-  pic_reg = pic_offset_table_rtx;\n+  pic_reg = TARGET_MIPS16 ? MIPS16_PIC_TEMP : pic_offset_table_rtx;\n   switch (mips_current_loadgp_style ())\n     {\n     case LOADGP_ABSOLUTE:\n@@ -8555,6 +8957,10 @@ mips_emit_loadgp (void)\n \t\t : gen_loadgp_absolute_di (pic_reg, mips_gnu_local_gp));\n       break;\n \n+    case LOADGP_OLDABI:\n+      /* Added by mips_output_function_prologue.  */\n+      break;\n+\n     case LOADGP_NEWABI:\n       addr = XEXP (DECL_RTL (current_function_decl), 0);\n       offset = mips_unspec_address (addr, SYMBOL_GOTOFF_LOADGP);\n@@ -8575,6 +8981,10 @@ mips_emit_loadgp (void)\n     default:\n       return;\n     }\n+\n+  if (TARGET_MIPS16)\n+    emit_insn (gen_copygp_mips16 (pic_offset_table_rtx, pic_reg));\n+\n   /* Emit a blockage if there are implicit uses of the GP register.\n      This includes profiled functions, because FUNCTION_PROFILE uses\n      a jal macro.  */\n@@ -8710,7 +9120,13 @@ mips_expand_prologue (void)\n \n   /* Initialize the $gp save slot.  */\n   if (frame->cprestore_size > 0)\n-    emit_insn (gen_cprestore (GEN_INT (crtl->outgoing_args_size)));\n+    {\n+      if (TARGET_MIPS16)\n+\tmips_emit_move (mips_cprestore_slot (MIPS_PROLOGUE_TEMP (Pmode)),\n+\t\t\tMIPS16_PIC_TEMP);\n+      else\n+\temit_insn (gen_cprestore (GEN_INT (frame->args_size)));\n+    }\n \n   /* If we are profiling, make sure no instructions are scheduled before\n      the call to mcount.  */\n@@ -11462,6 +11878,7 @@ mips16_lay_out_constants (void)\n   if (!TARGET_MIPS16_PCREL_LOADS)\n     return;\n \n+  split_all_insns_noflow ();\n   barrier = 0;\n   memset (&pool, 0, sizeof (pool));\n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n@@ -12096,6 +12513,11 @@ mips_reorg_process_insns (void)\n \n   cfun->machine->all_noreorder_p = true;\n \n+  /* We don't track MIPS16 PC-relative offsets closely enough to make\n+     a good job of \"set .noreorder\" code in MIPS16 mode.  */\n+  if (TARGET_MIPS16)\n+    cfun->machine->all_noreorder_p = false;\n+\n   /* Code that doesn't use explicit relocs can't be \".set nomacro\".  */\n   if (!TARGET_EXPLICIT_RELOCS)\n     cfun->machine->all_noreorder_p = false;\n@@ -12185,7 +12607,10 @@ mips_reorg (void)\n   if (mips_base_delayed_branch)\n     dbr_schedule (get_insns ());\n   mips_reorg_process_insns ();\n-  if (TARGET_EXPLICIT_RELOCS && TUNE_MIPS4130 && TARGET_VR4130_ALIGN)\n+  if (!TARGET_MIPS16\n+      && TARGET_EXPLICIT_RELOCS\n+      && TUNE_MIPS4130\n+      && TARGET_VR4130_ALIGN)\n     vr4130_align_insns ();\n }\n \f\n@@ -12212,24 +12637,19 @@ mips_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n \t\t   && const_call_insn_operand (fnaddr, Pmode));\n \n   /* Determine if we need to load FNADDR from the GOT.  */\n-  if (!use_sibcall_p)\n-    switch (mips_classify_symbol (fnaddr, SYMBOL_CONTEXT_LEA))\n-      {\n-      case SYMBOL_GOT_PAGE_OFST:\n-      case SYMBOL_GOT_DISP:\n-\t/* Pick a global pointer.  Use a call-clobbered register if\n-\t   TARGET_CALL_SAVED_GP.  */\n-\tcfun->machine->global_pointer =\n-\t  TARGET_CALL_SAVED_GP ? 15 : GLOBAL_POINTER_REGNUM;\n-\tSET_REGNO (pic_offset_table_rtx, cfun->machine->global_pointer);\n-\n-\t/* Set up the global pointer for n32 or n64 abicalls.  */\n-\tmips_emit_loadgp ();\n-\tbreak;\n+  if (!use_sibcall_p\n+      && (mips_got_symbol_type_p\n+\t  (mips_classify_symbol (fnaddr, SYMBOL_CONTEXT_LEA))))\n+    {\n+      /* Pick a global pointer.  Use a call-clobbered register if\n+\t TARGET_CALL_SAVED_GP.  */\n+      cfun->machine->global_pointer\n+\t= TARGET_CALL_SAVED_GP ? 15 : GLOBAL_POINTER_REGNUM;\n+      SET_REGNO (pic_offset_table_rtx, cfun->machine->global_pointer);\n \n-      default:\n-\tbreak;\n-      }\n+      /* Set up the global pointer for n32 or n64 abicalls.  */\n+      mips_emit_loadgp ();\n+    }\n \n   /* We need two temporary registers in some cases.  */\n   temp1 = gen_rtx_REG (Pmode, 2);\n@@ -12288,12 +12708,17 @@ mips_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n \t We must therefore load the address via a temporary\n \t register if mips_dangerous_for_la25_p.\n \n-\t If we jump to the temporary register rather than $25, the assembler\n-\t can use the move insn to fill the jump's delay slot.  */\n+\t If we jump to the temporary register rather than $25,\n+\t the assembler can use the move insn to fill the jump's\n+\t delay slot.\n+\n+\t We can use the same technique for MIPS16 code, where $25\n+\t is not a valid JR register.  */\n       if (TARGET_USE_PIC_FN_ADDR_REG\n+\t  && !TARGET_MIPS16\n \t  && !mips_dangerous_for_la25_p (fnaddr))\n \ttemp1 = gen_rtx_REG (Pmode, PIC_FUNCTION_ADDR_REGNUM);\n-      mips_load_call_address (temp1, fnaddr, true);\n+      mips_load_call_address (MIPS_CALL_SIBCALL, temp1, fnaddr);\n \n       if (TARGET_USE_PIC_FN_ADDR_REG\n \t  && REGNO (temp1) != PIC_FUNCTION_ADDR_REGNUM)\n@@ -12367,11 +12792,7 @@ mips_set_mips16_mode (int mips16_p)\n \t call.  */\n       flag_move_loop_invariants = 0;\n \n-      /* Silently disable -mexplicit-relocs since it doesn't apply\n-\t to MIPS16 code.  Even so, it would overly pedantic to warn\n-\t about \"-mips16 -mexplicit-relocs\", especially given that\n-\t we use a %gprel() operator.  */\n-      target_flags &= ~MASK_EXPLICIT_RELOCS;\n+      target_flags |= MASK_EXPLICIT_RELOCS;\n \n       /* Experiments suggest we get the best overall section-anchor\n \t results from using the range of an unextended LW or SW.  Code\n@@ -12381,8 +12802,11 @@ mips_set_mips16_mode (int mips16_p)\n       targetm.min_anchor_offset = 0;\n       targetm.max_anchor_offset = 127;\n \n-      if (flag_pic || TARGET_ABICALLS)\n-\tsorry (\"MIPS16 PIC\");\n+      if (flag_pic && !TARGET_OLDABI)\n+\tsorry (\"MIPS16 PIC for ABIs other than o32 and o64\");\n+\n+      if (TARGET_XGOT)\n+\tsorry (\"MIPS16 -mxgot code\");\n \n       if (TARGET_HARD_FLOAT_ABI && !TARGET_OLDABI)\n \tsorry (\"hard-float MIPS16 code for ABIs other than o32 and o64\");"}, {"sha": "ffeef0a16d4810684e396e4be4dcde37dc18796f", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 25, "deletions": 9, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08d0963a0e05e44f02c3e6b35faf94669874cb89/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08d0963a0e05e44f02c3e6b35faf94669874cb89/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=08d0963a0e05e44f02c3e6b35faf94669874cb89", "patch": "@@ -1659,16 +1659,29 @@ enum mips_code_readable_setting {\n /* Register in which static-chain is passed to a function.  */\n #define STATIC_CHAIN_REGNUM (GP_REG_FIRST + 15)\n \n-/* Registers used as temporaries in prologue/epilogue code.  If we're\n-   generating mips16 code, these registers must come from the core set\n-   of 8.  The prologue register mustn't conflict with any incoming\n-   arguments, the static chain pointer, or the frame pointer.  The\n-   epilogue temporary mustn't conflict with the return registers, the\n-   frame pointer, the EH stack adjustment, or the EH data registers.  */\n+/* Registers used as temporaries in prologue/epilogue code:\n \n+   - If a MIPS16 PIC function needs access to _gp, it first loads\n+     the value into MIPS16_PIC_TEMP and then copies it to $gp.\n+\n+   - The prologue can use MIPS_PROLOGUE_TEMP as a general temporary\n+     register.  The register must not conflict with MIPS16_PIC_TEMP.\n+\n+   - The epilogue can use MIPS_EPILOGUE_TEMP as a general temporary\n+     register.\n+\n+   If we're generating MIPS16 code, these registers must come from the\n+   core set of 8.  The prologue registers mustn't conflict with any\n+   incoming arguments, the static chain pointer, or the frame pointer.\n+   The epilogue temporary mustn't conflict with the return registers,\n+   the PIC call register ($25), the frame pointer, the EH stack adjustment,\n+   or the EH data registers.  */\n+\n+#define MIPS16_PIC_TEMP_REGNUM (GP_REG_FIRST + 2)\n #define MIPS_PROLOGUE_TEMP_REGNUM (GP_REG_FIRST + 3)\n #define MIPS_EPILOGUE_TEMP_REGNUM (GP_REG_FIRST + (TARGET_MIPS16 ? 6 : 8))\n \n+#define MIPS16_PIC_TEMP gen_rtx_REG (Pmode, MIPS16_PIC_TEMP_REGNUM)\n #define MIPS_PROLOGUE_TEMP(MODE) gen_rtx_REG (MODE, MIPS_PROLOGUE_TEMP_REGNUM)\n #define MIPS_EPILOGUE_TEMP(MODE) gen_rtx_REG (MODE, MIPS_EPILOGUE_TEMP_REGNUM)\n \n@@ -1716,7 +1729,6 @@ enum mips_code_readable_setting {\n enum reg_class\n {\n   NO_REGS,\t\t\t/* no registers in set */\n-  M16_NA_REGS,\t\t\t/* mips16 regs not used to pass args */\n   M16_REGS,\t\t\t/* mips16 directly accessible registers */\n   T_REG,\t\t\t/* mips16 T register ($24) */\n   M16_T_REGS,\t\t\t/* mips16 registers plus T register */\n@@ -1757,7 +1769,6 @@ enum reg_class\n #define REG_CLASS_NAMES\t\t\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n   \"NO_REGS\",\t\t\t\t\t\t\t\t\\\n-  \"M16_NA_REGS\",\t\t\t\t\t\t\t\\\n   \"M16_REGS\",\t\t\t\t\t\t\t\t\\\n   \"T_REG\",\t\t\t\t\t\t\t\t\\\n   \"M16_T_REGS\",\t\t\t\t\t\t\t\t\\\n@@ -1801,7 +1812,6 @@ enum reg_class\n #define REG_CLASS_CONTENTS\t\t\t\t\t\t                                \\\n {\t\t\t\t\t\t\t\t\t                                \\\n   { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000 },\t/* no registers */\t\\\n-  { 0x0003000c, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000 },\t/* mips16 nonarg regs */\\\n   { 0x000300fc, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000 },\t/* mips16 registers */\t\\\n   { 0x01000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000 },\t/* mips16 T register */\t\\\n   { 0x010300fc, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000 },\t/* mips16 and T regs */ \\\n@@ -2419,6 +2429,11 @@ typedef struct mips_args {\n #define SYMBOL_REF_LONG_CALL_P(X)\t\t\t\t\t\\\n   ((SYMBOL_REF_FLAGS (X) & SYMBOL_FLAG_LONG_CALL) != 0)\n \n+/* This flag marks functions that cannot be lazily bound.  */\n+#define SYMBOL_FLAG_BIND_NOW (SYMBOL_FLAG_MACH_DEP << 1)\n+#define SYMBOL_REF_BIND_NOW_P(RTX) \\\n+  ((SYMBOL_REF_FLAGS (RTX) & SYMBOL_FLAG_BIND_NOW) != 0)\n+\n /* True if we're generating a form of MIPS16 code in which jump tables\n    are stored in the text section and encoded as 16-bit PC-relative\n    offsets.  This is only possible when general text loads are allowed,\n@@ -3280,6 +3295,7 @@ extern int set_nomacro;\t\t\t/* # of nested .set nomacro's  */\n extern int mips_dbx_regno[];\n extern int mips_dwarf_regno[];\n extern bool mips_split_p[];\n+extern bool mips_split_hi_p[];\n extern GTY(()) rtx cmp_operands[2];\n extern enum processor_type mips_arch;   /* which cpu to codegen for */\n extern enum processor_type mips_tune;   /* which cpu to schedule for */"}, {"sha": "4d09085757d8baeae9f5adbca048cbf63047b2e6", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 111, "deletions": 48, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08d0963a0e05e44f02c3e6b35faf94669874cb89/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08d0963a0e05e44f02c3e6b35faf94669874cb89/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=08d0963a0e05e44f02c3e6b35faf94669874cb89", "patch": "@@ -66,6 +66,7 @@\n    (UNSPEC_MEMORY_BARRIER\t45)\n    (UNSPEC_SET_GOT_VERSION\t46)\n    (UNSPEC_UPDATE_GOT_VERSION\t47)\n+   (UNSPEC_COPYGP\t\t48)\n    \n    (UNSPEC_ADDRESS_FIRST\t100)\n \n@@ -478,7 +479,9 @@\n \t  (const_int 0)\n \n \t  (eq_attr \"got\" \"load\")\n-\t  (const_int 4)\n+\t  (if_then_else (ne (symbol_ref \"TARGET_MIPS16\") (const_int 0))\n+\t\t\t(const_int 8)\n+\t\t\t(const_int 4))\n \t  (eq_attr \"got\" \"xgot_high\")\n \t  (const_int 8)\n \n@@ -3590,15 +3593,11 @@\n (define_insn_and_split \"*got_disp<mode>\"\n   [(set (match_operand:P 0 \"register_operand\" \"=d\")\n \t(match_operand:P 1 \"got_disp_operand\" \"\"))]\n-  \"TARGET_EXPLICIT_RELOCS && !TARGET_XGOT\"\n+  \"TARGET_EXPLICIT_RELOCS && !mips_split_p[SYMBOL_GOT_DISP]\"\n   \"#\"\n   \"&& reload_completed\"\n-  [(set (match_dup 0)\n-\t(unspec:P [(match_dup 2) (match_dup 3)] UNSPEC_LOAD_GOT))]\n-{\n-  operands[2] = pic_offset_table_rtx;\n-  operands[3] = mips_unspec_address (operands[1], SYMBOL_GOTOFF_DISP);\n-}\n+  [(set (match_dup 0) (match_dup 2))]\n+  { operands[2] = mips_got_load (NULL, operands[1], SYMBOL_GOTOFF_DISP); }\n   [(set_attr \"got\" \"load\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n@@ -3607,18 +3606,19 @@\n (define_insn_and_split \"*got_page<mode>\"\n   [(set (match_operand:P 0 \"register_operand\" \"=d\")\n \t(high:P (match_operand:P 1 \"got_page_ofst_operand\" \"\")))]\n-  \"TARGET_EXPLICIT_RELOCS\"\n+  \"TARGET_EXPLICIT_RELOCS && !mips_split_hi_p[SYMBOL_GOT_PAGE_OFST]\"\n   \"#\"\n   \"&& reload_completed\"\n-  [(set (match_dup 0)\n-\t(unspec:P [(match_dup 2) (match_dup 3)] UNSPEC_LOAD_GOT))]\n-{\n-  operands[2] = pic_offset_table_rtx;\n-  operands[3] = mips_unspec_address (operands[1], SYMBOL_GOTOFF_PAGE);\n-}\n+  [(set (match_dup 0) (match_dup 2))]\n+  { operands[2] = mips_got_load (NULL, operands[1], SYMBOL_GOTOFF_PAGE); }\n   [(set_attr \"got\" \"load\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n+;; Convenience expander that generates the rhs of a load_got<mode> insn.\n+(define_expand \"unspec_got<mode>\"\n+  [(unspec:P [(match_operand:P 0)\n+\t      (match_operand:P 1)] UNSPEC_LOAD_GOT)])\n+\n ;; Lower-level instructions for loading an address from the GOT.\n ;; We could use MEMs, but an unspec gives more optimization\n ;; opportunities.\n@@ -3630,9 +3630,8 @@\n \t\t  UNSPEC_LOAD_GOT))]\n   \"\"\n   \"<load>\\t%0,%R2(%1)\"\n-  [(set_attr \"type\" \"load\")\n-   (set_attr \"mode\" \"<MODE>\")\n-   (set_attr \"length\" \"4\")])\n+  [(set_attr \"got\" \"load\")\n+   (set_attr \"mode\" \"<MODE>\")])\n \n ;; Instructions for adding the low 16 bits of an address to a register.\n ;; Operand 2 is the address: mips_print_operand works out which relocation\n@@ -3657,6 +3656,15 @@\n    (set_attr \"mode\" \"<MODE>\")\n    (set_attr \"extended_mips16\" \"yes\")])\n \n+;; Expose MIPS16 uses of the global pointer after reload if the function\n+;; is responsible for setting up the register itself.\n+(define_split\n+  [(set (match_operand:GPR 0 \"d_operand\")\n+\t(const:GPR (unspec:GPR [(const_int 0)] UNSPEC_GP)))]\n+  \"TARGET_MIPS16 && TARGET_USE_GOT && reload_completed\"\n+  [(set (match_dup 0) (match_dup 1))]\n+  { operands[1] = pic_offset_table_rtx; })\n+\n ;; Allow combine to split complex const_int load sequences, using operand 2\n ;; to store the intermediate results.  See move_operand for details.\n (define_split\n@@ -4521,6 +4529,18 @@\n }\n   [(set_attr \"length\" \"12\")])\n \n+;; Initialize the global pointer for MIPS16 code.  Operand 0 is the\n+;; global pointer and operand 1 is the MIPS16 register that holds\n+;; the required value.\n+(define_insn_and_split \"copygp_mips16\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=y\")\n+\t(unspec_volatile:SI [(match_operand:SI 1 \"register_operand\" \"d\")]\n+\t\t\t    UNSPEC_COPYGP))]\n+  \"TARGET_MIPS16\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 0) (match_dup 1))])\n+\n ;; Emit a .cprestore directive, which normally expands to a single store\n ;; instruction.  Note that we continue to use .cprestore for explicit reloc\n ;; code so that jals inside inline asms will work correctly.\n@@ -5981,16 +6001,17 @@\n ;; volatile until all uses of $28 are exposed.\n (define_insn_and_split \"restore_gp\"\n   [(set (reg:SI 28)\n-\t(unspec_volatile:SI [(const_int 0)] UNSPEC_RESTORE_GP))]\n+\t(unspec_volatile:SI [(const_int 0)] UNSPEC_RESTORE_GP))\n+   (clobber (match_scratch:SI 0 \"=&d\"))]\n   \"TARGET_CALL_CLOBBERED_GP\"\n   \"#\"\n   \"&& reload_completed\"\n   [(const_int 0)]\n {\n-  mips_restore_gp ();\n+  mips_restore_gp (operands[0]);\n   DONE;\n }\n-  [(set_attr \"type\"   \"load\")\n+  [(set_attr \"type\" \"load\")\n    (set_attr \"length\" \"12\")])\n \f\n ;;\n@@ -6043,16 +6064,22 @@\n ;;    - Leave GOT_VERSION_REGNUM out of all register classes.\n ;;\tThe register is therefore not a valid register_operand\n ;;\tand cannot be moved to or from other registers.\n+\n+;; Convenience expander that generates the rhs of a load_call<mode> insn.\n+(define_expand \"unspec_call<mode>\"\n+  [(unspec:P [(match_operand:P 0)\n+\t      (match_operand:P 1)\n+\t      (reg:SI GOT_VERSION_REGNUM)] UNSPEC_LOAD_CALL)])\n+\n (define_insn \"load_call<mode>\"\n   [(set (match_operand:P 0 \"register_operand\" \"=d\")\n-\t(unspec:P [(match_operand:P 1 \"register_operand\" \"r\")\n+\t(unspec:P [(match_operand:P 1 \"register_operand\" \"d\")\n \t\t   (match_operand:P 2 \"immediate_operand\" \"\")\n \t\t   (reg:SI GOT_VERSION_REGNUM)] UNSPEC_LOAD_CALL))]\n   \"TARGET_USE_GOT\"\n   \"<load>\\t%0,%R2(%1)\"\n-  [(set_attr \"type\" \"load\")\n-   (set_attr \"mode\" \"<MODE>\")\n-   (set_attr \"length\" \"4\")])\n+  [(set_attr \"got\" \"load\")\n+   (set_attr \"mode\" \"<MODE>\")])\n \n (define_insn \"set_got_version\"\n   [(set (reg:SI GOT_VERSION_REGNUM)\n@@ -6088,7 +6115,8 @@\n \t      (use (match_operand 3 \"\"))])]\t;; struct_value_size_rtx\n   \"TARGET_SIBCALLS\"\n {\n-  mips_expand_call (0, XEXP (operands[0], 0), operands[1], operands[2], true);\n+  mips_expand_call (MIPS_CALL_SIBCALL, NULL_RTX, XEXP (operands[0], 0),\n+\t\t    operands[1], operands[2], false);\n   DONE;\n })\n \n@@ -6106,8 +6134,8 @@\n \t      (use (match_operand 3 \"\"))])]\t\t;; next_arg_reg\n   \"TARGET_SIBCALLS\"\n {\n-  mips_expand_call (operands[0], XEXP (operands[1], 0),\n-\t\t    operands[2], operands[3], true);\n+  mips_expand_call (MIPS_CALL_SIBCALL, operands[0], XEXP (operands[1], 0),\n+\t\t    operands[2], operands[3], false);\n   DONE;\n })\n \n@@ -6137,7 +6165,8 @@\n \t      (use (match_operand 3 \"\"))])]\t;; struct_value_size_rtx\n   \"\"\n {\n-  mips_expand_call (0, XEXP (operands[0], 0), operands[1], operands[2], false);\n+  mips_expand_call (MIPS_CALL_NORMAL, NULL_RTX, XEXP (operands[0], 0),\n+\t\t    operands[1], operands[2], false);\n   DONE;\n })\n \n@@ -6187,28 +6216,44 @@\n   \"reload_completed && TARGET_SPLIT_CALLS && (operands[2] = insn)\"\n   [(const_int 0)]\n {\n-  emit_call_insn (gen_call_split (operands[0], operands[1]));\n-  if (!find_reg_note (operands[2], REG_NORETURN, 0))\n-    mips_restore_gp ();\n+  mips_split_call (operands[2], gen_call_split (operands[0], operands[1]));\n   DONE;\n }\n   [(set_attr \"jal\" \"indirect,direct\")])\n \n+(define_insn \"call_split\"\n+  [(call (mem:SI (match_operand 0 \"call_insn_operand\" \"cS\"))\n+\t (match_operand 1 \"\" \"\"))\n+   (clobber (reg:SI 31))\n+   (clobber (reg:SI 28))]\n+  \"TARGET_SPLIT_CALLS\"\n+  { return MIPS_CALL (\"jal\", operands, 0); }\n+  [(set_attr \"type\" \"call\")])\n+\n ;; A pattern for calls that must be made directly.  It is used for\n ;; MIPS16 calls that the linker may need to redirect to a hard-float\n ;; stub; the linker relies on the call relocation type to detect when\n ;; such redirection is needed.\n-(define_insn \"call_internal_direct\"\n+(define_insn_and_split \"call_internal_direct\"\n   [(call (mem:SI (match_operand 0 \"const_call_insn_operand\"))\n \t (match_operand 1))\n    (const_int 1)\n    (clobber (reg:SI 31))]\n   \"\"\n-  { return MIPS_CALL (\"jal\", operands, 0); })\n+  { return TARGET_SPLIT_CALLS ? \"#\" : MIPS_CALL (\"jal\", operands, 0); }\n+  \"reload_completed && TARGET_SPLIT_CALLS && (operands[2] = insn)\"\n+  [(const_int 0)]\n+{\n+  mips_split_call (operands[2],\n+\t\t   gen_call_direct_split (operands[0], operands[1]));\n+  DONE;\n+}\n+  [(set_attr \"type\" \"call\")])\n \n-(define_insn \"call_split\"\n-  [(call (mem:SI (match_operand 0 \"call_insn_operand\" \"cS\"))\n-\t (match_operand 1 \"\" \"\"))\n+(define_insn \"call_direct_split\"\n+  [(call (mem:SI (match_operand 0 \"const_call_insn_operand\"))\n+\t (match_operand 1))\n+   (const_int 1)\n    (clobber (reg:SI 31))\n    (clobber (reg:SI 28))]\n   \"TARGET_SPLIT_CALLS\"\n@@ -6222,7 +6267,7 @@\n \t      (use (match_operand 3 \"\"))])]\t\t;; next_arg_reg\n   \"\"\n {\n-  mips_expand_call (operands[0], XEXP (operands[1], 0),\n+  mips_expand_call (MIPS_CALL_NORMAL, operands[0], XEXP (operands[1], 0),\n \t\t    operands[2], operands[3], false);\n   DONE;\n })\n@@ -6238,10 +6283,9 @@\n   \"reload_completed && TARGET_SPLIT_CALLS && (operands[3] = insn)\"\n   [(const_int 0)]\n {\n-  emit_call_insn (gen_call_value_split (operands[0], operands[1],\n-\t\t\t\t\toperands[2]));\n-  if (!find_reg_note (operands[3], REG_NORETURN, 0))\n-    mips_restore_gp ();\n+  mips_split_call (operands[3],\n+\t\t   gen_call_value_split (operands[0], operands[1],\n+\t\t\t\t\t operands[2]));\n   DONE;\n }\n   [(set_attr \"jal\" \"indirect,direct\")])\n@@ -6257,14 +6301,34 @@\n   [(set_attr \"type\" \"call\")])\n \n ;; See call_internal_direct.\n-(define_insn \"call_value_internal_direct\"\n+(define_insn_and_split \"call_value_internal_direct\"\n   [(set (match_operand 0 \"register_operand\")\n         (call (mem:SI (match_operand 1 \"const_call_insn_operand\"))\n               (match_operand 2)))\n    (const_int 1)\n    (clobber (reg:SI 31))]\n   \"\"\n-  { return MIPS_CALL (\"jal\", operands, 1); })\n+  { return TARGET_SPLIT_CALLS ? \"#\" : MIPS_CALL (\"jal\", operands, 1); }\n+  \"reload_completed && TARGET_SPLIT_CALLS && (operands[3] = insn)\"\n+  [(const_int 0)]\n+{\n+  mips_split_call (operands[3],\n+\t\t   gen_call_value_direct_split (operands[0], operands[1],\n+\t\t\t\t\t\toperands[2]));\n+  DONE;\n+}\n+  [(set_attr \"type\" \"call\")])\n+\n+(define_insn \"call_value_direct_split\"\n+  [(set (match_operand 0 \"register_operand\")\n+        (call (mem:SI (match_operand 1 \"const_call_insn_operand\"))\n+              (match_operand 2)))\n+   (const_int 1)\n+   (clobber (reg:SI 31))\n+   (clobber (reg:SI 28))]\n+  \"TARGET_SPLIT_CALLS\"\n+  { return MIPS_CALL (\"jal\", operands, 1); }\n+  [(set_attr \"type\" \"call\")])\n \n ;; See comment for call_internal.\n (define_insn_and_split \"call_value_multiple_internal\"\n@@ -6280,10 +6344,9 @@\n   \"reload_completed && TARGET_SPLIT_CALLS && (operands[4] = insn)\"\n   [(const_int 0)]\n {\n-  emit_call_insn (gen_call_value_multiple_split (operands[0], operands[1],\n-\t\t\t\t\t\t operands[2], operands[3]));\n-  if (!find_reg_note (operands[4], REG_NORETURN, 0))\n-    mips_restore_gp ();\n+  mips_split_call (operands[4],\n+\t\t   gen_call_value_multiple_split (operands[0], operands[1],\n+\t\t\t\t\t\t  operands[2], operands[3]));\n   DONE;\n }\n   [(set_attr \"jal\" \"indirect,direct\")])"}, {"sha": "edc84de80434fcb89659c8367143a63c217a8b9d", "filename": "gcc/config/mips/mips16.S", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08d0963a0e05e44f02c3e6b35faf94669874cb89/gcc%2Fconfig%2Fmips%2Fmips16.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08d0963a0e05e44f02c3e6b35faf94669874cb89/gcc%2Fconfig%2Fmips%2Fmips16.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips16.S?ref=08d0963a0e05e44f02c3e6b35faf94669874cb89", "patch": "@@ -38,6 +38,8 @@ Boston, MA 02110-1301, USA.  */\n    values using the soft-float calling convention, but do the actual\n    operation using the hard floating point instructions.  */\n \n+#if defined _MIPS_SIM && (_MIPS_SIM == _ABIO32 || _MIPS_SIM == _ABIO64)\n+\n /* This file contains 32-bit assembly code.  */\n \t.set nomips16\n \n@@ -303,8 +305,12 @@ STARTFN (__mips16_floatsisf)\n \n #ifdef L_m16fltunsisf\n STARTFN (__mips16_floatunsisf)\n+\t.set\tnoreorder\n \tbltz\t$4,1f\n-\tj\t__mips16_floatsisf\n+\tMOVE_SF_BYTE0 (t)\n+\t.set\treorder\n+\tcvt.s.w\tRET,ARG1\n+\tMOVE_SF_RET (f, $31)\n 1:\t\t\n \tand\t$2,$4,1\n \tsrl\t$3,$4,1\n@@ -522,7 +528,10 @@ RET_FUNCTION (__mips16_ret_dc, DC)\n #define CALL_STUB_NO_RET(NAME, CODE)\t\\\n STARTFN (NAME);\t\t\t\t\\\n \tSTUB_ARGS_##CODE;\t\t\\\n+\t.set\tnoreorder;\t\t\\\n \tjr\t$2;\t\t\t\\\n+\tmove\t$25,$2;\t\t\t\\\n+\t.set\treorder;\t\t\\\n \tENDFN (NAME)\n \n #ifdef L_m16stub1\n@@ -569,7 +578,10 @@ CALL_STUB_NO_RET (__mips16_call_stub_10, 10)\n STARTFN (NAME);\t\t\t\t\\\n \tmove\t$18,$31;\t\t\\\n \tSTUB_ARGS_##CODE;\t\t\\\n+\t.set\tnoreorder;\t\t\\\n \tjalr\t$2;\t\t\t\\\n+\tmove\t$25,$2;\t\t\t\\\n+\t.set\treorder;\t\t\\\n \tMOVE_##MODE##_RET (f, $18);\t\\\n \tENDFN (NAME)\n \n@@ -705,3 +717,4 @@ CALL_STUB_RET (__mips16_call_stub_dc_9, 9, DC)\n CALL_STUB_RET (__mips16_call_stub_dc_10, 10, DC)\n #endif\n #endif /* !__mips_single_float */\n+#endif"}, {"sha": "0e8c85b93be98c893a75a634863625d9ca54115c", "filename": "gcc/config/mips/predicates.md", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08d0963a0e05e44f02c3e6b35faf94669874cb89/gcc%2Fconfig%2Fmips%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08d0963a0e05e44f02c3e6b35faf94669874cb89/gcc%2Fconfig%2Fmips%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fpredicates.md?ref=08d0963a0e05e44f02c3e6b35faf94669874cb89", "patch": "@@ -104,14 +104,9 @@\n   switch (symbol_type)\n     {\n     case SYMBOL_ABSOLUTE:\n-      /* We can only use direct calls for TARGET_ABSOLUTE_ABICALLS if we\n-\t are sure that the target function does not need $25 to be live\n-\t on entry.  This is true for any locally-defined function because\n-\t any such function will use %hi/%lo accesses to set up $gp.  */\n-      if (TARGET_ABSOLUTE_ABICALLS\n-          && !(GET_CODE (op) == SYMBOL_REF\n-\t       && SYMBOL_REF_DECL (op)\n-\t       && !DECL_EXTERNAL (SYMBOL_REF_DECL (op))))\n+      /* We can only use direct calls if we're sure that the target\n+\t function does not need $25 to be valid on entry.  */\n+      if (mips_use_pic_fn_addr_reg_p (op))\n \treturn false;\n \n       /* If -mlong-calls or if this function has an explicit long_call\n@@ -206,6 +201,11 @@\n       return (mips_symbolic_constant_p (op, SYMBOL_CONTEXT_LEA, &symbol_type)\n \t      && !mips_split_p[symbol_type]);\n \n+    case HIGH:\n+      op = XEXP (op, 0);\n+      return (mips_symbolic_constant_p (op, SYMBOL_CONTEXT_LEA, &symbol_type)\n+\t      && !mips_split_hi_p[symbol_type]);\n+\n     default:\n       return true;\n     }"}, {"sha": "b1a547d7029f4f9c2db26af331eab52ed8d1e2a9", "filename": "gcc/config/mips/t-libgcc-mips16", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08d0963a0e05e44f02c3e6b35faf94669874cb89/gcc%2Fconfig%2Fmips%2Ft-libgcc-mips16", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08d0963a0e05e44f02c3e6b35faf94669874cb89/gcc%2Fconfig%2Fmips%2Ft-libgcc-mips16", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Ft-libgcc-mips16?ref=08d0963a0e05e44f02c3e6b35faf94669874cb89", "patch": "@@ -22,3 +22,6 @@ LIB1ASMFUNCS = _m16addsf3 _m16subsf3 _m16mulsf3 _m16divsf3 \\\n \n LIBGCC_SYNC = yes\n LIBGCC_SYNC_CFLAGS = -mno-mips16\n+\n+# Version these symbols if building libgcc.so.\n+SHLIB_MAPFILES += $(srcdir)/config/mips/libgcc-mips16.ver"}, {"sha": "de65eae1a1f8a729ca14b23cd3dc7f3acfa2008f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08d0963a0e05e44f02c3e6b35faf94669874cb89/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08d0963a0e05e44f02c3e6b35faf94669874cb89/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=08d0963a0e05e44f02c3e6b35faf94669874cb89", "patch": "@@ -1,3 +1,8 @@\n+2008-08-09  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* lib/target-supports.exp (check_profiling_available): Return false\n+\tfor -p and -pg on MIPS16 targets.\n+\n 2008-08-09  Richard Guenther  <rguenther@suse.de>\n \n \t* gcc.dg/tree-ssa/inline-2.c: New testcase."}, {"sha": "2c9165c3c04305567a1570c27ea1173c6d6294cc", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08d0963a0e05e44f02c3e6b35faf94669874cb89/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08d0963a0e05e44f02c3e6b35faf94669874cb89/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=08d0963a0e05e44f02c3e6b35faf94669874cb89", "patch": "@@ -439,6 +439,14 @@ proc check_profiling_available { test_what } {\n \treturn 0\n     }\n \n+    # We don't yet support profiling for MIPS16.\n+    if { [istarget mips*-*-*]\n+\t && ![check_effective_target_nomips16]\n+\t && ([lindex $test_what 1] == \"-p\"\n+\t     || [lindex $test_what 1] == \"-pg\") } {\n+\treturn 0\n+    }\n+\n     # MinGW does not support -p.\n     if { [istarget *-*-mingw*] && [lindex $test_what 1] == \"-p\" } {\n \treturn 0"}]}