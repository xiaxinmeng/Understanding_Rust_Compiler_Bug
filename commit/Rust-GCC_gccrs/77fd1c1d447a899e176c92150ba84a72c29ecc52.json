{"sha": "77fd1c1d447a899e176c92150ba84a72c29ecc52", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzdmZDFjMWQ0NDdhODk5ZTE3NmM5MjE1MGJhODRhNzJjMjllY2M1Mg==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo.carlini@oracle.com", "date": "2010-08-08T10:07:16Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2010-08-08T10:07:16Z"}, "message": "cmath: Implement US 136.\n\n2010-08-08  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\t* include/c_global/cmath: Implement US 136.\n\t* include/tr1_impl/cmath: Do not bring fpclassify, etc from namespace\n\tstd, define namespace tr1.\n\t* testsuite/26_numerics/headers/cmath/\n\tc99_classification_macros_c++0x.cc: New.\n\nFrom-SVN: r162995", "tree": {"sha": "3dcbcfb53c58869df23992490255df43bde8eb51", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3dcbcfb53c58869df23992490255df43bde8eb51"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/77fd1c1d447a899e176c92150ba84a72c29ecc52", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77fd1c1d447a899e176c92150ba84a72c29ecc52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77fd1c1d447a899e176c92150ba84a72c29ecc52", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77fd1c1d447a899e176c92150ba84a72c29ecc52/comments", "author": null, "committer": null, "parents": [{"sha": "1159da448c8666d559371dc00a5d64a2ad1205b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1159da448c8666d559371dc00a5d64a2ad1205b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1159da448c8666d559371dc00a5d64a2ad1205b5"}], "stats": {"total": 474, "additions": 458, "deletions": 16}, "files": [{"sha": "b70de70edba38765636766ee3fe08d20cd6f640a", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77fd1c1d447a899e176c92150ba84a72c29ecc52/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77fd1c1d447a899e176c92150ba84a72c29ecc52/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=77fd1c1d447a899e176c92150ba84a72c29ecc52", "patch": "@@ -1,3 +1,11 @@\n+2010-08-08  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\t* include/c_global/cmath: Implement US 136.\n+\t* include/tr1_impl/cmath: Do not bring fpclassify, etc from namespace\n+\tstd, define namespace tr1.\n+\t* testsuite/26_numerics/headers/cmath/\n+\tc99_classification_macros_c++0x.cc: New.\n+\n 2010-08-06  David Malcolm  <dmalcolm@redhat.com>\n \t    Jan Kratochvil  <jan.kratochvil@redhat.com>\n "}, {"sha": "02ca6af744b37d59a866cab054149f3f4f5d8950", "filename": "libstdc++-v3/include/c_global/cmath", "status": "modified", "additions": 248, "deletions": 0, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77fd1c1d447a899e176c92150ba84a72c29ecc52/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcmath", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77fd1c1d447a899e176c92150ba84a72c29ecc52/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcmath", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_global%2Fcmath?ref=77fd1c1d447a899e176c92150ba84a72c29ecc52", "patch": "@@ -497,6 +497,252 @@ _GLIBCXX_END_NAMESPACE\n \n _GLIBCXX_BEGIN_NAMESPACE(std)\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+  inline int\n+  fpclassify(float __x)\n+  { return __builtin_fpclassify(FP_NAN, FP_INFINITE, FP_NORMAL,\n+\t\t\t\tFP_SUBNORMAL, FP_ZERO, __x); }\n+\n+  inline int\n+  fpclassify(double __x)\n+  { return __builtin_fpclassify(FP_NAN, FP_INFINITE, FP_NORMAL,\n+\t\t\t\tFP_SUBNORMAL, FP_ZERO, __x); }\n+\n+  inline int\n+  fpclassify(long double __x)\n+  { return __builtin_fpclassify(FP_NAN, FP_INFINITE, FP_NORMAL,\n+\t\t\t\tFP_SUBNORMAL, FP_ZERO, __x); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,\n+\t\t\t\t\t   int>::__type\n+    fpclassify(_Tp __x)\n+    { return __x != 0 ? FP_NORMAL : FP_ZERO; }\n+\n+  inline bool\n+  isfinite(float __x)\n+  { return __builtin_isfinite(__x); }\n+\n+  inline bool\n+  isfinite(double __x)\n+  { return __builtin_isfinite(__x); }\n+\n+  inline bool\n+  isfinite(long double __x)\n+  { return __builtin_isfinite(__x); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,\n+\t\t\t\t\t   bool>::__type\n+    isfinite(_Tp __x)\n+    { return true; }\n+\n+  inline bool\n+  isinf(float __x)\n+  { return __builtin_isinf(__x); }\n+\n+  inline bool\n+  isinf(double __x)\n+  { return __builtin_isinf(__x); }\n+\n+  inline bool\n+  isinf(long double __x)\n+  { return __builtin_isinf(__x); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,\n+\t\t\t\t\t   bool>::__type\n+    isinf(_Tp __x)\n+    { return false; }\n+\n+  inline bool\n+  isnan(float __x)\n+  { return __builtin_isnan(__x); }\n+\n+  inline bool\n+  isnan(double __x)\n+  { return __builtin_isnan(__x); }\n+\n+  inline bool\n+  isnan(long double __x)\n+  { return __builtin_isnan(__x); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,\n+\t\t\t\t\t   bool>::__type\n+    isnan(_Tp __x)\n+    { return false; }\n+\n+  inline bool\n+  isnormal(float __x)\n+  { return __builtin_isnormal(__x); }\n+\n+  inline bool\n+  isnormal(double __x)\n+  { return __builtin_isnormal(__x); }\n+\n+  inline bool\n+  isnormal(long double __x)\n+  { return __builtin_isnormal(__x); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,\n+\t\t\t\t\t   bool>::__type\n+    isnormal(_Tp __x)\n+    { return __x != 0 ? true : false; }\n+\n+  inline bool\n+  signbit(float __x)\n+  { return __builtin_signbit(__x); }\n+\n+  inline bool\n+  signbit(double __x)\n+  { return __builtin_signbit(__x); }\n+\n+  inline bool\n+  signbit(long double __x)\n+  { return __builtin_signbit(__x); }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,\n+\t\t\t\t\t   bool>::__type\n+    signbit(_Tp __x)\n+    { return __x < 0 ? true : false; }\n+\n+  inline bool\n+  isgreater(float __x, float __y)\n+  { return __builtin_isgreater(__x, __y); }\n+\n+  inline bool\n+  isgreater(double __x, double __y)\n+  { return __builtin_isgreater(__x, __y); }\n+\n+  inline bool\n+  isgreater(long double __x, long double __y)\n+  { return __builtin_isgreater(__x, __y); }\n+\n+  template<typename _Tp, typename _Up>\n+    inline typename\n+    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value\n+\t\t\t    && __is_arithmetic<_Up>::__value), bool>::__type\n+    isgreater(_Tp __x, _Up __y)\n+    {\n+      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;\n+      return __builtin_isgreater(__type(__x), __type(__y));\n+    }\n+\n+  inline bool\n+  isgreaterequal(float __x, float __y)\n+  { return __builtin_isgreaterequal(__x, __y); }\n+\n+  inline bool\n+  isgreaterequal(double __x, double __y)\n+  { return __builtin_isgreaterequal(__x, __y); }\n+\n+  inline bool\n+  isgreaterequal(long double __x, long double __y)\n+  { return __builtin_isgreaterequal(__x, __y); }\n+\n+  template<typename _Tp, typename _Up>\n+    inline typename\n+    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value\n+\t\t\t    && __is_arithmetic<_Up>::__value), bool>::__type\n+    isgreaterequal(_Tp __x, _Up __y)\n+    {\n+      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;\n+      return __builtin_isgreaterequal(__type(__x), __type(__y));\n+    }\n+\n+  inline bool\n+  isless(float __x, float __y)\n+  { return __builtin_isless(__x, __y); }\n+\n+  inline bool\n+  isless(double __x, double __y)\n+  { return __builtin_isless(__x, __y); }\n+\n+  inline bool\n+  isless(long double __x, long double __y)\n+  { return __builtin_isless(__x, __y); }\n+\n+  template<typename _Tp, typename _Up>\n+    inline typename\n+    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value\n+\t\t\t    && __is_arithmetic<_Up>::__value), bool>::__type\n+    isless(_Tp __x, _Up __y)\n+    {\n+      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;\n+      return __builtin_isless(__type(__x), __type(__y));\n+    }\n+\n+  inline bool\n+  islessequal(float __x, float __y)\n+  { return __builtin_islessequal(__x, __y); }\n+\n+  inline bool\n+  islessequal(double __x, double __y)\n+  { return __builtin_islessequal(__x, __y); }\n+\n+  inline bool\n+  islessequal(long double __x, long double __y)\n+  { return __builtin_islessequal(__x, __y); }\n+\n+  template<typename _Tp, typename _Up>\n+    inline typename\n+    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value\n+\t\t\t    && __is_arithmetic<_Up>::__value), bool>::__type\n+    islessequal(_Tp __x, _Up __y)\n+    {\n+      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;\n+      return __builtin_islessequal(__type(__x), __type(__y));\n+    }\n+\n+  inline bool\n+  islessgreater(float __x, float __y)\n+  { return __builtin_islessgreater(__x, __y); }\n+\n+  inline bool\n+  islessgreater(double __x, double __y)\n+  { return __builtin_islessgreater(__x, __y); }\n+\n+  inline bool\n+  islessgreater(long double __x, long double __y)\n+  { return __builtin_islessgreater(__x, __y); }\n+\n+  template<typename _Tp, typename _Up>\n+    inline typename\n+    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value\n+\t\t\t    && __is_arithmetic<_Up>::__value), bool>::__type\n+    islessgreater(_Tp __x, _Up __y)\n+    {\n+      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;\n+      return __builtin_islessgreater(__type(__x), __type(__y));\n+    }\n+\n+  inline bool\n+  isunordered(float __x, float __y)\n+  { return __builtin_isunordered(__x, __y); }\n+\n+  inline bool\n+  isunordered(double __x, double __y)\n+  { return __builtin_isunordered(__x, __y); }\n+\n+  inline bool\n+  isunordered(long double __x, long double __y)\n+  { return __builtin_isunordered(__x, __y); }\n+\n+  template<typename _Tp, typename _Up>\n+    inline typename\n+    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value\n+\t\t\t    && __is_arithmetic<_Up>::__value), bool>::__type\n+    isunordered(_Tp __x, _Up __y)\n+    {\n+      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;\n+      return __builtin_isunordered(__type(__x), __type(__y));\n+    }\n+\n+#else\n+\n   template<typename _Tp>\n     inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,\n \t\t\t\t\t   int>::__type\n@@ -606,6 +852,8 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       return __builtin_isunordered(__type(__f1), __type(__f2));\n     }\n \n+#endif\n+\n _GLIBCXX_END_NAMESPACE\n \n #endif /* _GLIBCXX_USE_C99_FP_MACROS_DYNAMIC */"}, {"sha": "cf460dd7c9532c1f467cda49dcf22455e9f1b9a9", "filename": "libstdc++-v3/include/tr1_impl/cmath", "status": "modified", "additions": 110, "deletions": 16, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77fd1c1d447a899e176c92150ba84a72c29ecc52/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fcmath", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77fd1c1d447a899e176c92150ba84a72c29ecc52/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fcmath", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1_impl%2Fcmath?ref=77fd1c1d447a899e176c92150ba84a72c29ecc52", "patch": "@@ -1,6 +1,6 @@\n // TR1 cmath -*- C++ -*-\n \n-// Copyright (C) 2007, 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -294,21 +294,115 @@ _GLIBCXX_BEGIN_NAMESPACE_TR1\n #if !_GLIBCXX_USE_C99_FP_MACROS_DYNAMIC\n \n   /// Function template definitions [8.16.3].\n-  using std::signbit;\n-  \n-  using std::fpclassify;\n-\n-  using std::isfinite;\n-  using std::isinf;\n-  using std::isnan;\n-  using std::isnormal;\n-\n-  using std::isgreater;\n-  using std::isgreaterequal;\n-  using std::isless;\n-  using std::islessequal;\n-  using std::islessgreater;\n-  using std::isunordered;\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,\n+\t\t\t\t\t   int>::__type\n+    fpclassify(_Tp __f)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return __builtin_fpclassify(FP_NAN, FP_INFINITE, FP_NORMAL,\n+\t\t\t\t  FP_SUBNORMAL, FP_ZERO, __type(__f));\n+    }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,\n+\t\t\t\t\t   int>::__type\n+    isfinite(_Tp __f)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return __builtin_isfinite(__type(__f));\n+    }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,\n+\t\t\t\t\t   int>::__type\n+    isinf(_Tp __f)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return __builtin_isinf(__type(__f));\n+    }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,\n+\t\t\t\t\t   int>::__type\n+    isnan(_Tp __f)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return __builtin_isnan(__type(__f));\n+    }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,\n+\t\t\t\t\t   int>::__type\n+    isnormal(_Tp __f)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return __builtin_isnormal(__type(__f));\n+    }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,\n+\t\t\t\t\t   int>::__type\n+    signbit(_Tp __f)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return __builtin_signbit(__type(__f));\n+    }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,\n+\t\t\t\t\t   int>::__type\n+    isgreater(_Tp __f1, _Tp __f2)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return __builtin_isgreater(__type(__f1), __type(__f2));\n+    }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,\n+\t\t\t\t\t   int>::__type\n+    isgreaterequal(_Tp __f1, _Tp __f2)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return __builtin_isgreaterequal(__type(__f1), __type(__f2));\n+    }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,\n+\t\t\t\t\t   int>::__type\n+    isless(_Tp __f1, _Tp __f2)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return __builtin_isless(__type(__f1), __type(__f2));\n+    }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,\n+\t\t\t\t\t   int>::__type\n+    islessequal(_Tp __f1, _Tp __f2)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return __builtin_islessequal(__type(__f1), __type(__f2));\n+    }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,\n+\t\t\t\t\t   int>::__type\n+    islessgreater(_Tp __f1, _Tp __f2)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return __builtin_islessgreater(__type(__f1), __type(__f2));\n+    }\n+\n+  template<typename _Tp>\n+    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,\n+\t\t\t\t\t   int>::__type\n+    isunordered(_Tp __f1, _Tp __f2)\n+    {\n+      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n+      return __builtin_isunordered(__type(__f1), __type(__f2));\n+    }\n+\n #endif\n #endif\n "}, {"sha": "413fe69259a932f5ccf9594eaed2d1fef27f6dde", "filename": "libstdc++-v3/testsuite/26_numerics/headers/cmath/c99_classification_macros_c++0x.cc", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77fd1c1d447a899e176c92150ba84a72c29ecc52/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fheaders%2Fcmath%2Fc99_classification_macros_c%2B%2B0x.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77fd1c1d447a899e176c92150ba84a72c29ecc52/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fheaders%2Fcmath%2Fc99_classification_macros_c%2B%2B0x.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fheaders%2Fcmath%2Fc99_classification_macros_c%2B%2B0x.cc?ref=77fd1c1d447a899e176c92150ba84a72c29ecc52", "patch": "@@ -0,0 +1,92 @@\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile { xfail uclibc } }\n+// { dg-excess-errors \"\" { target uclibc } }\n+\n+#include <cmath>\n+\n+void fpclassify() { }\n+\n+void isfinite() { }\n+\n+void isinf() { }\n+\n+void isnan() { }\n+\n+void isnormal() { }\n+\n+void signbit() { }\n+\n+void isgreater() { }\n+\n+void isgreaterequal() { }\n+\n+void isless() { }\n+\n+void islessequal() { }\n+\n+void islessgreater() { }\n+\n+void isunordered() { }\n+\n+#if _GLIBCXX_USE_C99_MATH\n+template <typename _Tp, typename _Up = _Tp>\n+  void test_c99_classify()\n+  {\n+    bool test __attribute__((unused)) = true;\n+\n+    typedef _Tp fp_type_one;\n+    typedef _Up fp_type_two;\n+    fp_type_one f1 = 1.0;\n+    fp_type_two f2 = 3.0;\n+    int resi;\n+    bool res;\n+\n+    resi = std::fpclassify(f1);\n+    res = std::isfinite(f2);\n+    res = std::isinf(f1);\n+    res = std::isnan(f2);\n+    res = std::isnormal(f1);\n+    res = std::signbit(f2);\n+    res = std::isgreater(f1, f2);\n+    res = std::isgreaterequal(f1, f2);\n+    res = std::isless(f1, f2);\n+    res = std::islessequal(f1,f2);\n+    res = std::islessgreater(f1, f2);\n+    res = std::isunordered(f1, f2);\n+    resi = resi; // Suppress unused warning.\n+    res = res;\n+  }\n+#endif\n+\n+int main()\n+{\n+#if _GLIBCXX_USE_C99_MATH\n+  test_c99_classify<float>();\n+  test_c99_classify<double>();\n+  test_c99_classify<long double>();\n+  test_c99_classify<float, double>();\n+  test_c99_classify<float, long double>();\n+  test_c99_classify<double, float>();\n+  test_c99_classify<double, long double>();\n+  test_c99_classify<long double, float>();\n+  test_c99_classify<long double, double>();\n+#endif\n+  return 0;\n+}"}]}