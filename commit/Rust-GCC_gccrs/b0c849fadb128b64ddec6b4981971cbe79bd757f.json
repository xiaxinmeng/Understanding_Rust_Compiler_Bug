{"sha": "b0c849fadb128b64ddec6b4981971cbe79bd757f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjBjODQ5ZmFkYjEyOGI2NGRkZWM2YjQ5ODE5NzFjYmU3OWJkNzU3Zg==", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2019-06-17T10:25:04Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2019-06-17T10:25:04Z"}, "message": "Simplify node ownership in _Hashtable members\n\nIntroduce an RAII type to manage nodes in unordered containers while\nthey are being inserted. If the caller always owns a node until it is\ninserted, then the insertion functions don't need to deallocate on\nfailure. This allows a FIXME in the node re-insertion API to be removed.\n\nAlso change extract(const key_type&) to not call extract(const_iterator)\nanymore.  This avoids looping through the bucket nodes again to find the\nnode before the one being extracted.\n\n2019-06-17  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n\t    Jonathan Wakely  <jwakely@redhat.com>\n\n\t* include/bits/hashtable.h (struct _Hashtable::_Scoped_node): New type.\n\t(_Hashtable::_M_insert_unique_node): Add key_type parameter. Don't\n\tdeallocate node if insertion fails.\n\t(_Hashtable::_M_insert_multi_node): Likewise.\n\t(_Hashtable::_M_reinsert_node): Pass additional key argument.\n\t(_Hashtable::_M_reinsert_node_multi): Likewise. Remove FIXME.\n\t(_Hashtable::_M_extract_node(size_t, __node_base*)): New function.\n\t(_Hashtable::extract(const_iterator)): Use _M_extract_node.\n\t(_Hashtable::extract(const _Key&)): Likewise.\n\t(_Hashtable::_M_merge_unique): Pass additional key argument.\n\t(_Hashtable::_M_emplace<Args>(true_type, Args&&...)): Likewise. Use\n\t_Scoped_node.\n\t(_Hashtable::_M_insert): Likewise.\n\t* include/bits/hashtable_policy.h (_Map_base::operator[]): Likewise.\n\t(_Hashtable_alloc): Add comments to functions with misleading names.\n\nCo-Authored-By: Jonathan Wakely <jwakely@redhat.com>\n\nFrom-SVN: r272381", "tree": {"sha": "5209e2e39ec4b61a054aea1f3e3fc283e420d0d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5209e2e39ec4b61a054aea1f3e3fc283e420d0d4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b0c849fadb128b64ddec6b4981971cbe79bd757f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0c849fadb128b64ddec6b4981971cbe79bd757f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0c849fadb128b64ddec6b4981971cbe79bd757f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0c849fadb128b64ddec6b4981971cbe79bd757f/comments", "author": null, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e67ddda63ca523614921f2baaf3d571791d32d1a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e67ddda63ca523614921f2baaf3d571791d32d1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e67ddda63ca523614921f2baaf3d571791d32d1a"}], "stats": {"total": 360, "additions": 190, "deletions": 170}, "files": [{"sha": "1bca26b8b8eedfa68d4f9cd4ae51e87fbdd02777", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0c849fadb128b64ddec6b4981971cbe79bd757f/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0c849fadb128b64ddec6b4981971cbe79bd757f/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=b0c849fadb128b64ddec6b4981971cbe79bd757f", "patch": "@@ -1,3 +1,22 @@\n+2019-06-17  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n+\t    Jonathan Wakely  <jwakely@redhat.com>\n+\n+\t* include/bits/hashtable.h (struct _Hashtable::_Scoped_node): New type.\n+\t(_Hashtable::_M_insert_unique_node): Add key_type parameter. Don't\n+\tdeallocate node if insertion fails.\n+\t(_Hashtable::_M_insert_multi_node): Likewise.\n+\t(_Hashtable::_M_reinsert_node): Pass additional key argument.\n+\t(_Hashtable::_M_reinsert_node_multi): Likewise. Remove FIXME.\n+\t(_Hashtable::_M_extract_node(size_t, __node_base*)): New function.\n+\t(_Hashtable::extract(const_iterator)): Use _M_extract_node.\n+\t(_Hashtable::extract(const _Key&)): Likewise.\n+\t(_Hashtable::_M_merge_unique): Pass additional key argument.\n+\t(_Hashtable::_M_emplace<Args>(true_type, Args&&...)): Likewise. Use\n+\t_Scoped_node.\n+\t(_Hashtable::_M_insert): Likewise.\n+\t* include/bits/hashtable_policy.h (_Map_base::operator[]): Likewise.\n+\t(_Hashtable_alloc): Add comments to functions with misleading names.\n+\n 2019-06-17  Jonathan Wakely  <jwakely@redhat.com>\n \n \t* testsuite/20_util/bad_function_call/what.cc: Include <string> header"}, {"sha": "ab579a7059ea5a399009a0f71d367df8fed417db", "filename": "libstdc++-v3/include/bits/hashtable.h", "status": "modified", "additions": 138, "deletions": 145, "changes": 283, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0c849fadb128b64ddec6b4981971cbe79bd757f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0c849fadb128b64ddec6b4981971cbe79bd757f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h?ref=b0c849fadb128b64ddec6b4981971cbe79bd757f", "patch": "@@ -256,6 +256,30 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       using __reuse_or_alloc_node_gen_t =\n \t__detail::_ReuseOrAllocNode<__node_alloc_type>;\n \n+      // Simple RAII type for managing a node containing an element\n+      struct _Scoped_node\n+      {\n+\t// Take ownership of a node with a constructed element.\n+\t_Scoped_node(__node_type* __n, __hashtable_alloc* __h)\n+\t: _M_h(__h), _M_node(__n) { }\n+\n+\t// Allocate a node and construct an element within it.\n+\ttemplate<typename... _Args>\n+\t  _Scoped_node(__hashtable_alloc* __h, _Args&&... __args)\n+\t  : _M_h(__h),\n+\t    _M_node(__h->_M_allocate_node(std::forward<_Args>(__args)...))\n+\t  { }\n+\n+\t// Destroy element and deallocate node.\n+\t~_Scoped_node() { if (_M_node) _M_h->_M_deallocate_node(_M_node); };\n+\n+\t_Scoped_node(const _Scoped_node&) = delete;\n+\t_Scoped_node& operator=(const _Scoped_node&) = delete;\n+\n+\t__hashtable_alloc* _M_h;\n+\t__node_type* _M_node;\n+      };\n+\n       // Metaprogramming for picking apart hash caching.\n       template<typename _Cond>\n \tusing __if_hash_cached = __or_<__not_<__hash_cached>, _Cond>;\n@@ -669,17 +693,18 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       __node_base*\n       _M_get_previous_node(size_type __bkt, __node_base* __n);\n \n-      // Insert node with hash code __code, in bucket bkt if no rehash (assumes\n-      // no element with its key already present). Take ownership of the node,\n-      // deallocate it on exception.\n+      // Insert node __n with key __k and hash code __code, in bucket __bkt\n+      // if no rehash (assumes no element with same key already present).\n+      // Takes ownership of __n if insertion succeeds, throws otherwise.\n       iterator\n-      _M_insert_unique_node(size_type __bkt, __hash_code __code,\n-\t\t\t    __node_type* __n, size_type __n_elt = 1);\n+      _M_insert_unique_node(const key_type& __k, size_type __bkt,\n+\t\t\t    __hash_code __code, __node_type* __n,\n+\t\t\t    size_type __n_elt = 1);\n \n-      // Insert node with hash code __code. Take ownership of the node,\n-      // deallocate it on exception.\n+      // Insert node __n with key __k and hash code __code.\n+      // Takes ownership of __n if insertion succeeds, throws otherwise.\n       iterator\n-      _M_insert_multi_node(__node_type* __hint,\n+      _M_insert_multi_node(__node_type* __hint, const key_type& __k,\n \t\t\t   __hash_code __code, __node_type* __n);\n \n       template<typename... _Args>\n@@ -806,7 +831,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    else\n \t      {\n \t\t__ret.position\n-\t\t  = _M_insert_unique_node(__bkt, __code, __nh._M_ptr);\n+\t\t  = _M_insert_unique_node(__k, __bkt, __code, __nh._M_ptr);\n \t\t__nh._M_ptr = nullptr;\n \t\t__ret.inserted = true;\n \t      }\n@@ -818,33 +843,24 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       iterator\n       _M_reinsert_node_multi(const_iterator __hint, node_type&& __nh)\n       {\n-\titerator __ret;\n \tif (__nh.empty())\n-\t  __ret = end();\n-\telse\n-\t  {\n-\t    __glibcxx_assert(get_allocator() == __nh.get_allocator());\n+\t  return end();\n \n-\t    auto __code = this->_M_hash_code(__nh._M_key());\n-\t    auto __node = std::exchange(__nh._M_ptr, nullptr);\n-\t    // FIXME: this deallocates the node on exception.\n-\t    __ret = _M_insert_multi_node(__hint._M_cur, __code, __node);\n-\t  }\n+\t__glibcxx_assert(get_allocator() == __nh.get_allocator());\n+\n+\tconst key_type& __k = __nh._M_key();\n+\tauto __code = this->_M_hash_code(__k);\n+\tauto __ret\n+\t  = _M_insert_multi_node(__hint._M_cur, __k, __code, __nh._M_ptr);\n+\t__nh._M_ptr = nullptr;\n \treturn __ret;\n       }\n \n-      /// Extract a node.\n+    private:\n       node_type\n-      extract(const_iterator __pos)\n+      _M_extract_node(size_t __bkt, __node_base* __prev_n)\n       {\n-\t__node_type* __n = __pos._M_cur;\n-\tsize_t __bkt = _M_bucket_index(__n);\n-\n-\t// Look for previous node to unlink it from the erased one, this\n-\t// is why we need buckets to contain the before begin to make\n-\t// this search fast.\n-\t__node_base* __prev_n = _M_get_previous_node(__bkt, __n);\n-\n+\t__node_type* __n = static_cast<__node_type*>(__prev_n->_M_nxt);\n \tif (__prev_n == _M_buckets[__bkt])\n \t  _M_remove_bucket_begin(__bkt, __n->_M_next(),\n \t     __n->_M_nxt ? _M_bucket_index(__n->_M_next()) : 0);\n@@ -861,14 +877,25 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \treturn { __n, this->_M_node_allocator() };\n       }\n \n+    public:\n+      // Extract a node.\n+      node_type\n+      extract(const_iterator __pos)\n+      {\n+\tsize_t __bkt = _M_bucket_index(__pos._M_cur);\n+\treturn _M_extract_node(__bkt,\n+\t\t\t       _M_get_previous_node(__bkt, __pos._M_cur));\n+      }\n+\n       /// Extract a node.\n       node_type\n       extract(const _Key& __k)\n       {\n \tnode_type __nh;\n-\tauto __pos = find(__k);\n-\tif (__pos != end())\n-\t  __nh = extract(const_iterator(__pos));\n+\t__hash_code __code = this->_M_hash_code(__k);\n+\tstd::size_t __bkt = _M_bucket_index(__k, __code);\n+\tif (__node_base* __prev_node = _M_find_before_node(__bkt, __k, __code))\n+\t  __nh = _M_extract_node(__bkt, __prev_node);\n \treturn __nh;\n       }\n \n@@ -885,13 +912,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  for (auto __i = __src.begin(), __end = __src.end(); __i != __end;)\n \t    {\n \t      auto __pos = __i++;\n-\t      const key_type& __k = this->_M_extract()(__pos._M_cur->_M_v());\n+\t      const key_type& __k = this->_M_extract()(*__pos);\n \t      __hash_code __code = this->_M_hash_code(__k);\n \t      size_type __bkt = _M_bucket_index(__k, __code);\n \t      if (_M_find_node(__bkt, __k, __code) == nullptr)\n \t\t{\n \t\t  auto __nh = __src.extract(__pos);\n-\t\t  _M_insert_unique_node(__bkt, __code, __nh._M_ptr, __n_elt);\n+\t\t  _M_insert_unique_node(__k, __bkt, __code, __nh._M_ptr,\n+\t\t\t\t\t__n_elt);\n \t\t  __nh._M_ptr = nullptr;\n \t\t  __n_elt = 1;\n \t\t}\n@@ -1634,31 +1662,18 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       -> pair<iterator, bool>\n       {\n \t// First build the node to get access to the hash code\n-\t__node_type* __node\n-\t  = this->_M_allocate_node(std::forward<_Args>(__args)...);\n-\tconst key_type& __k = this->_M_extract()(__node->_M_v());\n-\t__hash_code __code;\n-\t__try\n-\t  {\n-\t    __code = this->_M_hash_code(__k);\n-\t  }\n-\t__catch(...)\n-\t  {\n-\t    this->_M_deallocate_node(__node);\n-\t    __throw_exception_again;\n-\t  }\n-\n+\t_Scoped_node __node { this, std::forward<_Args>(__args)...  };\n+\tconst key_type& __k = this->_M_extract()(__node._M_node->_M_v());\n+\t__hash_code __code = this->_M_hash_code(__k);\n \tsize_type __bkt = _M_bucket_index(__k, __code);\n \tif (__node_type* __p = _M_find_node(__bkt, __k, __code))\n-\t  {\n-\t    // There is already an equivalent node, no insertion\n-\t    this->_M_deallocate_node(__node);\n-\t    return std::make_pair(iterator(__p), false);\n-\t  }\n+\t  // There is already an equivalent node, no insertion\n+\t  return std::make_pair(iterator(__p), false);\n \n \t// Insert the node\n-\treturn std::make_pair(_M_insert_unique_node(__bkt, __code, __node),\n-\t\t\t      true);\n+\tauto __pos = _M_insert_unique_node(__k, __bkt, __code, __node._M_node);\n+\t__node._M_node = nullptr;\n+\treturn { __pos, true };\n       }\n \n   template<typename _Key, typename _Value,\n@@ -1673,21 +1688,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       -> iterator\n       {\n \t// First build the node to get its hash code.\n-\t__node_type* __node =\n-\t  this->_M_allocate_node(std::forward<_Args>(__args)...);\n-\n-\t__hash_code __code;\n-\t__try\n-\t  {\n-\t    __code = this->_M_hash_code(this->_M_extract()(__node->_M_v()));\n-\t  }\n-\t__catch(...)\n-\t  {\n-\t    this->_M_deallocate_node(__node);\n-\t    __throw_exception_again;\n-\t  }\n+\t_Scoped_node __node { this, std::forward<_Args>(__args)...  };\n+\tconst key_type& __k = this->_M_extract()(__node._M_node->_M_v());\n \n-\treturn _M_insert_multi_node(__hint._M_cur, __code, __node);\n+\t__hash_code __code = this->_M_hash_code(__k);\n+\tauto __pos\n+\t  = _M_insert_multi_node(__hint._M_cur, __k, __code, __node._M_node);\n+\t__node._M_node = nullptr;\n+\treturn __pos;\n       }\n \n   template<typename _Key, typename _Value,\n@@ -1697,101 +1705,81 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     auto\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n-    _M_insert_unique_node(size_type __bkt, __hash_code __code,\n-\t\t\t  __node_type* __node, size_type __n_elt)\n+    _M_insert_unique_node(const key_type& __k, size_type __bkt,\n+\t\t\t  __hash_code __code, __node_type* __node,\n+\t\t\t  size_type __n_elt)\n     -> iterator\n     {\n       const __rehash_state& __saved_state = _M_rehash_policy._M_state();\n       std::pair<bool, std::size_t> __do_rehash\n \t= _M_rehash_policy._M_need_rehash(_M_bucket_count, _M_element_count,\n \t\t\t\t\t  __n_elt);\n \n-      __try\n+      if (__do_rehash.first)\n \t{\n-\t  if (__do_rehash.first)\n-\t    {\n-\t      _M_rehash(__do_rehash.second, __saved_state);\n-\t      __bkt\n-\t\t= _M_bucket_index(this->_M_extract()(__node->_M_v()), __code);\n-\t    }\n+\t  _M_rehash(__do_rehash.second, __saved_state);\n+\t  __bkt = _M_bucket_index(__k, __code);\n+\t}\n \n-\t  this->_M_store_code(__node, __code);\n+      this->_M_store_code(__node, __code);\n \n-\t  // Always insert at the beginning of the bucket.\n-\t  _M_insert_bucket_begin(__bkt, __node);\n-\t  ++_M_element_count;\n-\t  return iterator(__node);\n-\t}\n-      __catch(...)\n-\t{\n-\t  this->_M_deallocate_node(__node);\n-\t  __throw_exception_again;\n-\t}\n+      // Always insert at the beginning of the bucket.\n+      _M_insert_bucket_begin(__bkt, __node);\n+      ++_M_element_count;\n+      return iterator(__node);\n     }\n \n-  // Insert node, in bucket bkt if no rehash (assumes no element with its key\n-  // already present). Take ownership of the node, deallocate it on exception.\n   template<typename _Key, typename _Value,\n \t   typename _Alloc, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n \t   typename _Traits>\n     auto\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n-    _M_insert_multi_node(__node_type* __hint, __hash_code __code,\n-\t\t\t __node_type* __node)\n+    _M_insert_multi_node(__node_type* __hint, const key_type& __k,\n+\t\t\t __hash_code __code, __node_type* __node)\n     -> iterator\n     {\n       const __rehash_state& __saved_state = _M_rehash_policy._M_state();\n       std::pair<bool, std::size_t> __do_rehash\n \t= _M_rehash_policy._M_need_rehash(_M_bucket_count, _M_element_count, 1);\n \n-      __try\n-\t{\n-\t  if (__do_rehash.first)\n-\t    _M_rehash(__do_rehash.second, __saved_state);\n-\n-\t  this->_M_store_code(__node, __code);\n-\t  const key_type& __k = this->_M_extract()(__node->_M_v());\n-\t  size_type __bkt = _M_bucket_index(__k, __code);\n-\n-\t  // Find the node before an equivalent one or use hint if it exists and\n-\t  // if it is equivalent.\n-\t  __node_base* __prev\n-\t    = __builtin_expect(__hint != nullptr, false)\n-\t      && this->_M_equals(__k, __code, __hint)\n-\t\t? __hint\n-\t\t: _M_find_before_node(__bkt, __k, __code);\n-\t  if (__prev)\n-\t    {\n-\t      // Insert after the node before the equivalent one.\n-\t      __node->_M_nxt = __prev->_M_nxt;\n-\t      __prev->_M_nxt = __node;\n-\t      if (__builtin_expect(__prev == __hint, false))\n-\t      \t// hint might be the last bucket node, in this case we need to\n-\t      \t// update next bucket.\n-\t      \tif (__node->_M_nxt\n-\t      \t    && !this->_M_equals(__k, __code, __node->_M_next()))\n-\t      \t  {\n-\t      \t    size_type __next_bkt = _M_bucket_index(__node->_M_next());\n-\t      \t    if (__next_bkt != __bkt)\n-\t      \t      _M_buckets[__next_bkt] = __node;\n-\t      \t  }\n-\t    }\n-\t  else\n-\t    // The inserted node has no equivalent in the\n-\t    // hashtable. We must insert the new node at the\n-\t    // beginning of the bucket to preserve equivalent\n-\t    // elements' relative positions.\n-\t    _M_insert_bucket_begin(__bkt, __node);\n-\t  ++_M_element_count;\n-\t  return iterator(__node);\n-\t}\n-      __catch(...)\n+      if (__do_rehash.first)\n+\t_M_rehash(__do_rehash.second, __saved_state);\n+\n+      this->_M_store_code(__node, __code);\n+      size_type __bkt = _M_bucket_index(__k, __code);\n+\n+      // Find the node before an equivalent one or use hint if it exists and\n+      // if it is equivalent.\n+      __node_base* __prev\n+\t= __builtin_expect(__hint != nullptr, false)\n+\t  && this->_M_equals(__k, __code, __hint)\n+\t    ? __hint\n+\t    : _M_find_before_node(__bkt, __k, __code);\n+      if (__prev)\n \t{\n-\t  this->_M_deallocate_node(__node);\n-\t  __throw_exception_again;\n+\t  // Insert after the node before the equivalent one.\n+\t  __node->_M_nxt = __prev->_M_nxt;\n+\t  __prev->_M_nxt = __node;\n+\t  if (__builtin_expect(__prev == __hint, false))\n+\t    // hint might be the last bucket node, in this case we need to\n+\t    // update next bucket.\n+\t    if (__node->_M_nxt\n+\t\t&& !this->_M_equals(__k, __code, __node->_M_next()))\n+\t      {\n+\t\tsize_type __next_bkt = _M_bucket_index(__node->_M_next());\n+\t\tif (__next_bkt != __bkt)\n+\t\t  _M_buckets[__next_bkt] = __node;\n+\t      }\n \t}\n+      else\n+\t// The inserted node has no equivalent in the hashtable. We must\n+\t// insert the new node at the beginning of the bucket to preserve\n+\t// equivalent elements' relative positions.\n+\t_M_insert_bucket_begin(__bkt, __node);\n+      ++_M_element_count;\n+      return iterator(__node);\n     }\n \n   // Insert v if no element with its key is already present.\n@@ -1811,12 +1799,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t__hash_code __code = this->_M_hash_code(__k);\n \tsize_type __bkt = _M_bucket_index(__k, __code);\n \n-\t__node_type* __n = _M_find_node(__bkt, __k, __code);\n-\tif (__n)\n-\t  return std::make_pair(iterator(__n), false);\n+\tif (__node_type* __node = _M_find_node(__bkt, __k, __code))\n+\t  return { iterator(__node), false };\n \n-\t__n = __node_gen(std::forward<_Arg>(__v));\n-\treturn { _M_insert_unique_node(__bkt, __code, __n, __n_elt), true };\n+\t_Scoped_node __node{ __node_gen(std::forward<_Arg>(__v)), this };\n+\tauto __pos\n+\t  = _M_insert_unique_node(__k, __bkt, __code, __node._M_node, __n_elt);\n+\t__node._M_node = nullptr;\n+\treturn { __pos, true };\n       }\n \n   // Insert v unconditionally.\n@@ -1837,9 +1827,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t__hash_code __code = this->_M_hash_code(this->_M_extract()(__v));\n \n \t// Second allocate new node so that we don't rehash if it throws.\n-\t__node_type* __node = __node_gen(std::forward<_Arg>(__v));\n-\n-\treturn _M_insert_multi_node(__hint._M_cur, __code, __node);\n+\t_Scoped_node __node{ __node_gen(std::forward<_Arg>(__v)), this };\n+\tconst key_type& __k = this->_M_extract()(__node._M_node->_M_v());\n+\tauto __pos\n+\t  = _M_insert_multi_node(__hint._M_cur, __k, __code, __node._M_node);\n+\t__node._M_node = nullptr;\n+\treturn __pos;\n       }\n \n   template<typename _Key, typename _Value,"}, {"sha": "f5809c7443a7339fe5ea0831f664ba1798a67f2b", "filename": "libstdc++-v3/include/bits/hashtable_policy.h", "status": "modified", "additions": 33, "deletions": 25, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0c849fadb128b64ddec6b4981971cbe79bd757f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0c849fadb128b64ddec6b4981971cbe79bd757f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h?ref=b0c849fadb128b64ddec6b4981971cbe79bd757f", "patch": "@@ -706,17 +706,19 @@ namespace __detail\n       __hashtable* __h = static_cast<__hashtable*>(this);\n       __hash_code __code = __h->_M_hash_code(__k);\n       std::size_t __bkt = __h->_M_bucket_index(__k, __code);\n-      __node_type* __p = __h->_M_find_node(__bkt, __k, __code);\n-\n-      if (!__p)\n-\t{\n-\t  __p = __h->_M_allocate_node(std::piecewise_construct,\n-\t\t\t\t      std::tuple<const key_type&>(__k),\n-\t\t\t\t      std::tuple<>());\n-\t  return __h->_M_insert_unique_node(__bkt, __code, __p)->second;\n-\t}\n-\n-      return __p->_M_v().second;\n+      if (__node_type* __node = __h->_M_find_node(__bkt, __k, __code))\n+\treturn __node->_M_v().second;\n+\n+      typename __hashtable::_Scoped_node __node {\n+\t__h,\n+\tstd::piecewise_construct,\n+\tstd::tuple<const key_type&>(__k),\n+\tstd::tuple<>()\n+      };\n+      auto __pos\n+\t= __h->_M_insert_unique_node(__k, __bkt, __code, __node._M_node);\n+      __node._M_node = nullptr;\n+      return __pos->second;\n     }\n \n   template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,\n@@ -731,17 +733,19 @@ namespace __detail\n       __hashtable* __h = static_cast<__hashtable*>(this);\n       __hash_code __code = __h->_M_hash_code(__k);\n       std::size_t __bkt = __h->_M_bucket_index(__k, __code);\n-      __node_type* __p = __h->_M_find_node(__bkt, __k, __code);\n-\n-      if (!__p)\n-\t{\n-\t  __p = __h->_M_allocate_node(std::piecewise_construct,\n-\t\t\t\t      std::forward_as_tuple(std::move(__k)),\n-\t\t\t\t      std::tuple<>());\n-\t  return __h->_M_insert_unique_node(__bkt, __code, __p)->second;\n-\t}\n-\n-      return __p->_M_v().second;\n+      if (__node_type* __node = __h->_M_find_node(__bkt, __k, __code))\n+\treturn __node->_M_v().second;\n+\n+      typename __hashtable::_Scoped_node __node {\n+\t__h,\n+\tstd::piecewise_construct,\n+\tstd::forward_as_tuple(std::move(__k)),\n+\tstd::tuple<>()\n+      };\n+      auto __pos\n+\t= __h->_M_insert_unique_node(__k, __bkt, __code, __node._M_node);\n+      __node._M_node = nullptr;\n+      return __pos->second;\n     }\n \n   template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,\n@@ -1972,8 +1976,8 @@ namespace __detail\n     }\n \n   /**\n-   * This type deals with all allocation and keeps an allocator instance through\n-   * inheritance to benefit from EBO when possible.\n+   * This type deals with all allocation and keeps an allocator instance\n+   * through inheritance to benefit from EBO when possible.\n    */\n   template<typename _NodeAlloc>\n     struct _Hashtable_alloc : private _Hashtable_ebo_helper<0, _NodeAlloc>\n@@ -2012,17 +2016,21 @@ namespace __detail\n       _M_node_allocator() const\n       { return __ebo_node_alloc::_M_cget(); }\n \n+      // Allocate a node and construct an element within it.\n       template<typename... _Args>\n \t__node_type*\n \t_M_allocate_node(_Args&&... __args);\n \n+      // Destroy the element within a node and deallocate the node.\n       void\n       _M_deallocate_node(__node_type* __n);\n \n+      // Deallocate a node.\n       void\n       _M_deallocate_node_ptr(__node_type* __n);\n \n-      // Deallocate the linked list of nodes pointed to by __n\n+      // Deallocate the linked list of nodes pointed to by __n.\n+      // The elements within the nodes are destroyed.\n       void\n       _M_deallocate_nodes(__node_type* __n);\n "}]}