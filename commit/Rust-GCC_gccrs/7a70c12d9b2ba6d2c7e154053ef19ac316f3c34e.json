{"sha": "7a70c12d9b2ba6d2c7e154053ef19ac316f3c34e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2E3MGMxMmQ5YjJiYTZkMmM3ZTE1NDA1M2VmMTlhYzMxNmYzYzM0ZQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard@codesourcery.com", "date": "2005-09-09T06:34:08Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2005-09-09T06:34:08Z"}, "message": "re PR fortran/19239 ([4.0 only] gfortran ICE on vector subscript expressions)\n\n\tPR fortran/19239\n\t* Makefile.in (fortran/trans-expr.o): Depend on dependency.h.\n\t* dependency.h (gfc_ref_needs_temporary_p): Declare.\n\t* dependency.c (gfc_ref_needs_temporary_p): New function.\n\t(gfc_check_fncall_dependency): Use it instead of inlined check.\n\tBy so doing, take advantage of the fact that character substrings\n\twithin an array reference also need a temporary.\n\t* trans.h (GFC_SS_VECTOR): Adjust comment.\n\t* trans-array.c (gfc_free_ss): Remove GFC_SS_VECTOR case.\n\t(gfc_set_vector_loop_bounds): New function.\n\t(gfc_add_loop_ss_code): Call it after evaluating the subscripts of\n\ta GFC_SS_SECTION.  Deal with the GFC_SS_VECTOR case by evaluating\n\tthe vector expression and caching its descriptor for use within\n\tthe loop.\n\t(gfc_conv_array_index_ref, gfc_conv_vector_array_index): Delete.\n\t(gfc_conv_array_index_offset): Handle scalar, vector and range\n\tdimensions as separate cases of a switch statement.  In the vector\n\tcase, use the loop variable to calculate a vector index and use the\n\treferenced element as the dimension's index.  Perform bounds checking\n\ton this final index.\n\t(gfc_conv_section_upper_bound): Return null for vector indexes.\n\t(gfc_conv_section_startstride): Give vector indexes a start value\n\tof 0 and a stride of 1.\n\t(gfc_conv_ss_startstride): Adjust for new GFC_SS_VECTOR representation.\n\t(gfc_conv_expr_descriptor): Expand comments.  Generalize the\n\thandling of the !want_pointer && !direct_byref case.  Use\n\tgfc_ref_needs_temporary_p to decide whether the variable case\n\tneeds a temporary.\n\t(gfc_walk_variable_expr): Handle DIMEN_VECTOR by creating a\n\tGFC_SS_VECTOR index.\n\t* trans-expr.c: Include dependency.h.\n\t(gfc_trans_arrayfunc_assign): Fail if the target needs a temporary.\n\n2005-09-09  Richard Sandiford  <richard@codesourcery.com>\n\n\tPR fortran/21104\n\t* trans.h (gfc_interface_sym_mapping, gfc_interface_mapping): Moved\n\tfrom trans-expr.c.\n\t(gfc_init_interface_mapping, gfc_free_interface_mapping)\n\t(gfc_add_interface_mapping, gfc_finish_interface_mapping)\n\t(gfc_apply_interface_mapping): Declare.\n\t* trans-array.h (gfc_set_loop_bounds_from_array_spec): Declare.\n\t(gfc_trans_allocate_temp_array): Add pre and post block arguments.\n\t* trans-array.c (gfc_set_loop_bounds_from_array_spec): New function.\n\t(gfc_trans_allocate_array_storage): Replace loop argument with\n\tseparate pre and post blocks.\n\t(gfc_trans_allocate_temp_array): Add pre and post block arguments.\n\tUpdate call to gfc_trans_allocate_array_storage.\n\t(gfc_trans_array_constructor, gfc_conv_loop_setup): Adjust for new\n\tinterface to gfc_trans_allocate_temp_array.\n\t* trans-expr.c (gfc_interface_sym_mapping, gfc_interface_mapping):\n\tMoved to trans.h.\n\t(gfc_init_interface_mapping, gfc_free_interface_mapping)\n\t(gfc_add_interface_mapping, gfc_finish_interface_mapping)\n\t(gfc_apply_interface_mapping): Make extern.\n\t(gfc_conv_function_call): Build an interface mapping for array\n\treturn values too.  Call gfc_set_loop_bounds_from_array_spec.\n\tAdjust call to gfc_trans_allocate_temp_array so that code is\n\tadded to SE rather than LOOP.\n\nFrom-SVN: r104077", "tree": {"sha": "6320cd48af2ca2f1553a582aa75b00c42d833159", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6320cd48af2ca2f1553a582aa75b00c42d833159"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7a70c12d9b2ba6d2c7e154053ef19ac316f3c34e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a70c12d9b2ba6d2c7e154053ef19ac316f3c34e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a70c12d9b2ba6d2c7e154053ef19ac316f3c34e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a70c12d9b2ba6d2c7e154053ef19ac316f3c34e/comments", "author": null, "committer": null, "parents": [{"sha": "62ab4a54994341ab463149da427a51d70d2fbc70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62ab4a54994341ab463149da427a51d70d2fbc70", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62ab4a54994341ab463149da427a51d70d2fbc70"}], "stats": {"total": 710, "additions": 463, "deletions": 247}, "files": [{"sha": "5b592e7d4f60b1e914c1766461307ccea02574a3", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a70c12d9b2ba6d2c7e154053ef19ac316f3c34e/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a70c12d9b2ba6d2c7e154053ef19ac316f3c34e/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=7a70c12d9b2ba6d2c7e154053ef19ac316f3c34e", "patch": "@@ -1,3 +1,38 @@\n+2005-09-09  Richard Sandiford  <richard@codesourcery.com>\n+\n+\tPR fortran/19239\n+\t* Makefile.in (fortran/trans-expr.o): Depend on dependency.h.\n+\t* dependency.h (gfc_ref_needs_temporary_p): Declare.\n+\t* dependency.c (gfc_ref_needs_temporary_p): New function.\n+\t(gfc_check_fncall_dependency): Use it instead of inlined check.\n+\tBy so doing, take advantage of the fact that character substrings\n+\twithin an array reference also need a temporary.\n+\t* trans.h (GFC_SS_VECTOR): Adjust comment.\n+\t* trans-array.c (gfc_free_ss): Remove GFC_SS_VECTOR case.\n+\t(gfc_set_vector_loop_bounds): New function.\n+\t(gfc_add_loop_ss_code): Call it after evaluating the subscripts of\n+\ta GFC_SS_SECTION.  Deal with the GFC_SS_VECTOR case by evaluating\n+\tthe vector expression and caching its descriptor for use within\n+\tthe loop.\n+\t(gfc_conv_array_index_ref, gfc_conv_vector_array_index): Delete.\n+\t(gfc_conv_array_index_offset): Handle scalar, vector and range\n+\tdimensions as separate cases of a switch statement.  In the vector\n+\tcase, use the loop variable to calculate a vector index and use the\n+\treferenced element as the dimension's index.  Perform bounds checking\n+\ton this final index.\n+\t(gfc_conv_section_upper_bound): Return null for vector indexes.\n+\t(gfc_conv_section_startstride): Give vector indexes a start value\n+\tof 0 and a stride of 1.\n+\t(gfc_conv_ss_startstride): Adjust for new GFC_SS_VECTOR representation.\n+\t(gfc_conv_expr_descriptor): Expand comments.  Generalize the\n+\thandling of the !want_pointer && !direct_byref case.  Use\n+\tgfc_ref_needs_temporary_p to decide whether the variable case\n+\tneeds a temporary.\n+\t(gfc_walk_variable_expr): Handle DIMEN_VECTOR by creating a\n+\tGFC_SS_VECTOR index.\n+\t* trans-expr.c: Include dependency.h.\n+\t(gfc_trans_arrayfunc_assign): Fail if the target needs a temporary.\n+\n 2005-09-09  Richard Sandiford  <richard@codesourcery.com>\n \n \tPR fortran/21104"}, {"sha": "184ac6b569526c32c53f7abf264a42a4a102eebb", "filename": "gcc/fortran/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a70c12d9b2ba6d2c7e154053ef19ac316f3c34e/gcc%2Ffortran%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a70c12d9b2ba6d2c7e154053ef19ac316f3c34e/gcc%2Ffortran%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FMake-lang.in?ref=7a70c12d9b2ba6d2c7e154053ef19ac316f3c34e", "patch": "@@ -289,7 +289,7 @@ fortran/trans-decl.o: $(GFORTRAN_TRANS_DEPS) gt-fortran-trans-decl.h \\\n fortran/trans-types.o: $(GFORTRAN_TRANS_DEPS) gt-fortran-trans-types.h \\\n   real.h toplev.h $(TARGET_H)\n fortran/trans-const.o: $(GFORTRAN_TRANS_DEPS)\n-fortran/trans-expr.o: $(GFORTRAN_TRANS_DEPS)\n+fortran/trans-expr.o: $(GFORTRAN_TRANS_DEPS) fortran/dependency.h\n fortran/trans-stmt.o: $(GFORTRAN_TRANS_DEPS)\n fortran/trans-io.o: $(GFORTRAN_TRANS_DEPS) gt-fortran-trans-io.h\n fortran/trans-array.o: $(GFORTRAN_TRANS_DEPS)"}, {"sha": "9c6b4f677733eb07cec5e46731b92a6f9bda07ef", "filename": "gcc/fortran/dependency.c", "status": "modified", "additions": 41, "deletions": 27, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a70c12d9b2ba6d2c7e154053ef19ac316f3c34e/gcc%2Ffortran%2Fdependency.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a70c12d9b2ba6d2c7e154053ef19ac316f3c34e/gcc%2Ffortran%2Fdependency.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdependency.c?ref=7a70c12d9b2ba6d2c7e154053ef19ac316f3c34e", "patch": "@@ -175,6 +175,45 @@ gfc_is_same_range (gfc_array_ref * ar1, gfc_array_ref * ar2, int n, int def)\n }\n \n \n+/* Return true if the result of reference REF can only be constructed\n+   using a temporary array.  */\n+\n+bool\n+gfc_ref_needs_temporary_p (gfc_ref *ref)\n+{\n+  int n;\n+  bool subarray_p;\n+\n+  subarray_p = false;\n+  for (; ref; ref = ref->next)\n+    switch (ref->type)\n+      {\n+      case REF_ARRAY:\n+\t/* Vector dimensions are generally not monotonic and must be\n+\t   handled using a temporary.  */\n+\tif (ref->u.ar.type == AR_SECTION)\n+\t  for (n = 0; n < ref->u.ar.dimen; n++)\n+\t    if (ref->u.ar.dimen_type[n] == DIMEN_VECTOR)\n+\t      return true;\n+\n+\tsubarray_p = true;\n+\tbreak;\n+\n+      case REF_SUBSTRING:\n+\t/* Within an array reference, character substrings generally\n+\t   need a temporary.  Character array strides are expressed as\n+\t   multiples of the element size (consistent with other array\n+\t   types), not in characters.  */\n+\treturn subarray_p;\n+\n+      case REF_COMPONENT:\n+\tbreak;\n+      }\n+\n+  return false;\n+}\n+\n+\n /* Dependency checking for direct function return by reference.\n    Returns true if the arguments of the function depend on the\n    destination.  This is considerably less conservative than other\n@@ -185,9 +224,7 @@ int\n gfc_check_fncall_dependency (gfc_expr * dest, gfc_expr * fncall)\n {\n   gfc_actual_arglist *actual;\n-  gfc_ref *ref;\n   gfc_expr *expr;\n-  int n;\n \n   gcc_assert (dest->expr_type == EXPR_VARIABLE\n \t  && fncall->expr_type == EXPR_FUNCTION);\n@@ -205,31 +242,8 @@ gfc_check_fncall_dependency (gfc_expr * dest, gfc_expr * fncall)\n       switch (expr->expr_type)\n \t{\n \tcase EXPR_VARIABLE:\n-\t  if (expr->rank > 1)\n-\t    {\n-\t      /* This is an array section.  */\n-\t      for (ref = expr->ref; ref; ref = ref->next)\n-\t\t{\n-\t\t  if (ref->type == REF_ARRAY && ref->u.ar.type != AR_ELEMENT)\n-\t\t    break;\n-\t\t}\n-\t      gcc_assert (ref);\n-\t      /* AR_FULL can't contain vector subscripts.  */\n-\t      if (ref->u.ar.type == AR_SECTION)\n-\t\t{\n-\t\t  for (n = 0; n < ref->u.ar.dimen; n++)\n-\t\t    {\n-\t\t      if (ref->u.ar.dimen_type[n] == DIMEN_VECTOR)\n-\t\t\tbreak;\n-\t\t    }\n-\t\t  /* Vector subscript array sections will be copied to a\n-\t\t     temporary.  */\n-\t\t  if (n != ref->u.ar.dimen)\n-\t\t    continue;\n-\t\t}\n-\t    }\n-\n-\t  if (gfc_check_dependency (dest, actual->expr, NULL, 0))\n+\t  if (!gfc_ref_needs_temporary_p (expr->ref)\n+\t      && gfc_check_dependency (dest, expr, NULL, 0))\n \t    return 1;\n \t  break;\n "}, {"sha": "c4fe493c9ec419f619c5638440e69c0277041656", "filename": "gcc/fortran/dependency.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a70c12d9b2ba6d2c7e154053ef19ac316f3c34e/gcc%2Ffortran%2Fdependency.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a70c12d9b2ba6d2c7e154053ef19ac316f3c34e/gcc%2Ffortran%2Fdependency.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdependency.h?ref=7a70c12d9b2ba6d2c7e154053ef19ac316f3c34e", "patch": "@@ -21,6 +21,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n \n \n+bool gfc_ref_needs_temporary_p (gfc_ref *);\n int gfc_check_fncall_dependency (gfc_expr *, gfc_expr *);\n int gfc_check_dependency (gfc_expr *, gfc_expr *, gfc_expr **, int);\n int gfc_is_same_range (gfc_array_ref *, gfc_array_ref *, int, int);"}, {"sha": "552bae69f2ef8abf4333ca70aa984e87a85e1542", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 159, "deletions": 217, "changes": 376, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a70c12d9b2ba6d2c7e154053ef19ac316f3c34e/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a70c12d9b2ba6d2c7e154053ef19ac316f3c34e/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=7a70c12d9b2ba6d2c7e154053ef19ac316f3c34e", "patch": "@@ -361,7 +361,6 @@ gfc_free_ss (gfc_ss * ss)\n   switch (ss->type)\n     {\n     case GFC_SS_SECTION:\n-    case GFC_SS_VECTOR:\n       for (n = 0; n < GFC_MAX_DIMENSIONS; n++)\n \t{\n \t  if (ss->data.info.subscript[n])\n@@ -1355,6 +1354,47 @@ gfc_trans_array_constructor (gfc_loopinfo * loop, gfc_ss * ss)\n }\n \n \n+/* INFO describes a GFC_SS_SECTION in loop LOOP, and this function is\n+   called after evaluating all of INFO's vector dimensions.  Go through\n+   each such vector dimension and see if we can now fill in any missing\n+   loop bounds.  */\n+\n+static void\n+gfc_set_vector_loop_bounds (gfc_loopinfo * loop, gfc_ss_info * info)\n+{\n+  gfc_se se;\n+  tree tmp;\n+  tree desc;\n+  tree zero;\n+  int n;\n+  int dim;\n+\n+  for (n = 0; n < loop->dimen; n++)\n+    {\n+      dim = info->dim[n];\n+      if (info->ref->u.ar.dimen_type[dim] == DIMEN_VECTOR\n+\t  && loop->to[n] == NULL)\n+\t{\n+\t  /* Loop variable N indexes vector dimension DIM, and we don't\n+\t     yet know the upper bound of loop variable N.  Set it to the\n+\t     difference between the vector's upper and lower bounds.  */\n+\t  gcc_assert (loop->from[n] == gfc_index_zero_node);\n+\t  gcc_assert (info->subscript[dim]\n+\t\t      && info->subscript[dim]->type == GFC_SS_VECTOR);\n+\n+\t  gfc_init_se (&se, NULL);\n+\t  desc = info->subscript[dim]->data.info.descriptor;\n+\t  zero = gfc_rank_cst[0];\n+\t  tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n+\t\t\t     gfc_conv_descriptor_ubound (desc, zero),\n+\t\t\t     gfc_conv_descriptor_lbound (desc, zero));\n+\t  tmp = gfc_evaluate_now (tmp, &loop->pre);\n+\t  loop->to[n] = tmp;\n+\t}\n+    }\n+}\n+\n+\n /* Add the pre and post chains for all the scalar expressions in a SS chain\n    to loop.  This is called after the loop parameters have been calculated,\n    but before the actual scalarizing loops.  */\n@@ -1410,14 +1450,21 @@ gfc_add_loop_ss_code (gfc_loopinfo * loop, gfc_ss * ss, bool subscript)\n \t  break;\n \n \tcase GFC_SS_SECTION:\n-\tcase GFC_SS_VECTOR:\n-\t  /* Scalarized expression.  Evaluate any scalar subscripts.  */\n+\t  /* Add the expressions for scalar and vector subscripts.  */\n \t  for (n = 0; n < GFC_MAX_DIMENSIONS; n++)\n-\t    {\n-\t      /* Add the expressions for scalar subscripts.  */\n-\t      if (ss->data.info.subscript[n])\n-\t\tgfc_add_loop_ss_code (loop, ss->data.info.subscript[n], true);\n-\t    }\n+\t    if (ss->data.info.subscript[n])\n+\t      gfc_add_loop_ss_code (loop, ss->data.info.subscript[n], true);\n+\n+\t  gfc_set_vector_loop_bounds (loop, &ss->data.info);\n+\t  break;\n+\n+\tcase GFC_SS_VECTOR:\n+\t  /* Get the vector's descriptor and store it in SS.  */\n+\t  gfc_init_se (&se, NULL);\n+\t  gfc_conv_expr_descriptor (&se, ss->expr, gfc_walk_expr (ss->expr));\n+\t  gfc_add_block_to_block (&loop->pre, &se.pre);\n+\t  gfc_add_block_to_block (&loop->post, &se.post);\n+\t  ss->data.info.descriptor = se.expr;\n \t  break;\n \n \tcase GFC_SS_INTRINSIC:\n@@ -1620,41 +1667,6 @@ gfc_conv_array_ubound (tree descriptor, int dim)\n }\n \n \n-/* Translate an array reference.  The descriptor should be in se->expr.\n-   Do not use this function, it wil be removed soon.  */\n-/*GCC ARRAYS*/\n-\n-static void\n-gfc_conv_array_index_ref (gfc_se * se, tree pointer, tree * indices,\n-                         tree offset, int dimen)\n-{\n-  tree array;\n-  tree tmp;\n-  tree index;\n-  int n;\n-\n-  array = gfc_build_indirect_ref (pointer);\n-\n-  index = offset;\n-  for (n = 0; n < dimen; n++)\n-    {\n-      /* index = index + stride[n]*indices[n] */\n-      tmp = gfc_conv_array_stride (se->expr, n);\n-      tmp = fold_build2 (MULT_EXPR, gfc_array_index_type, indices[n], tmp);\n-\n-      index = fold_build2 (PLUS_EXPR, gfc_array_index_type, index, tmp);\n-    }\n-\n-  /* Result = data[index].  */\n-  tmp = gfc_build_array_ref (array, index);\n-\n-  /* Check we've used the correct number of dimensions.  */\n-  gcc_assert (TREE_CODE (TREE_TYPE (tmp)) != ARRAY_TYPE);\n-\n-  se->expr = tmp;\n-}\n-\n-\n /* Generate code to perform an array index bound check.  */\n \n static tree\n@@ -1682,61 +1694,6 @@ gfc_trans_array_bound_check (gfc_se * se, tree descriptor, tree index, int n)\n }\n \n \n-/* A reference to an array vector subscript.  Uses recursion to handle nested\n-   vector subscripts.  */\n-\n-static tree\n-gfc_conv_vector_array_index (gfc_se * se, tree index, gfc_ss * ss)\n-{\n-  tree descsave;\n-  tree indices[GFC_MAX_DIMENSIONS];\n-  gfc_array_ref *ar;\n-  gfc_ss_info *info;\n-  int n;\n-\n-  gcc_assert (ss && ss->type == GFC_SS_VECTOR);\n-\n-  /* Save the descriptor.  */\n-  descsave = se->expr;\n-  info = &ss->data.info;\n-  se->expr = info->descriptor;\n-\n-  ar = &info->ref->u.ar;\n-  for (n = 0; n < ar->dimen; n++)\n-    {\n-      switch (ar->dimen_type[n])\n-\t{\n-\tcase DIMEN_ELEMENT:\n-\t  gcc_assert (info->subscript[n] != gfc_ss_terminator\n-\t\t  && info->subscript[n]->type == GFC_SS_SCALAR);\n-\t  indices[n] = info->subscript[n]->data.scalar.expr;\n-\t  break;\n-\n-\tcase DIMEN_RANGE:\n-\t  indices[n] = index;\n-\t  break;\n-\n-\tcase DIMEN_VECTOR:\n-\t  index = gfc_conv_vector_array_index (se, index, info->subscript[n]);\n-\n-\t  indices[n] =\n-\t    gfc_trans_array_bound_check (se, info->descriptor, index, n);\n-\t  break;\n-\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n-    }\n-  /* Get the index from the vector.  */\n-  gfc_conv_array_index_ref (se, info->data, indices, info->offset, ar->dimen);\n-  index = se->expr;\n-  /* Put the descriptor back.  */\n-  se->expr = descsave;\n-\n-  return index;\n-}\n-\n-\n /* Return the offset for an index.  Performs bound checking for elemental\n    dimensions.  Single element references are processed separately.  */\n \n@@ -1745,25 +1702,52 @@ gfc_conv_array_index_offset (gfc_se * se, gfc_ss_info * info, int dim, int i,\n \t\t\t     gfc_array_ref * ar, tree stride)\n {\n   tree index;\n+  tree desc;\n+  tree data;\n \n   /* Get the index into the array for this dimension.  */\n   if (ar)\n     {\n       gcc_assert (ar->type != AR_ELEMENT);\n-      if (ar->dimen_type[dim] == DIMEN_ELEMENT)\n+      switch (ar->dimen_type[dim])\n \t{\n+\tcase DIMEN_ELEMENT:\n \t  gcc_assert (i == -1);\n \t  /* Elemental dimension.  */\n \t  gcc_assert (info->subscript[dim]\n-\t\t  && info->subscript[dim]->type == GFC_SS_SCALAR);\n+\t\t      && info->subscript[dim]->type == GFC_SS_SCALAR);\n \t  /* We've already translated this value outside the loop.  */\n \t  index = info->subscript[dim]->data.scalar.expr;\n \n \t  index =\n \t    gfc_trans_array_bound_check (se, info->descriptor, index, dim);\n-\t}\n-      else\n-\t{\n+\t  break;\n+\n+\tcase DIMEN_VECTOR:\n+\t  gcc_assert (info && se->loop);\n+\t  gcc_assert (info->subscript[dim]\n+\t\t      && info->subscript[dim]->type == GFC_SS_VECTOR);\n+\t  desc = info->subscript[dim]->data.info.descriptor;\n+\n+\t  /* Get a zero-based index into the vector.  */\n+\t  index = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n+\t\t\t       se->loop->loopvar[i], se->loop->from[i]);\n+\n+\t  /* Multiply the index by the stride.  */\n+\t  index = fold_build2 (MULT_EXPR, gfc_array_index_type,\n+\t\t\t       index, gfc_conv_array_stride (desc, 0));\n+\n+\t  /* Read the vector to get an index into info->descriptor.  */\n+\t  data = gfc_build_indirect_ref (gfc_conv_array_data (desc));\n+\t  index = gfc_build_array_ref (data, index);\n+\t  index = gfc_evaluate_now (index, &se->pre);\n+\n+\t  /* Do any bounds checking on the final info->descriptor index.  */\n+\t  index = gfc_trans_array_bound_check (se, info->descriptor,\n+\t\t\t\t\t       index, dim);\n+\t  break;\n+\n+\tcase DIMEN_RANGE:\n \t  /* Scalarized dimension.  */\n \t  gcc_assert (info && se->loop);\n \n@@ -1773,18 +1757,10 @@ gfc_conv_array_index_offset (gfc_se * se, gfc_ss_info * info, int dim, int i,\n \t\t\t       info->stride[i]);\n \t  index = fold_build2 (PLUS_EXPR, gfc_array_index_type, index,\n \t\t\t       info->delta[i]);\n+\t  break;\n \n-\t  if (ar->dimen_type[dim] == DIMEN_VECTOR)\n-\t    {\n-              /* Handle vector subscripts.  */\n-\t      index = gfc_conv_vector_array_index (se, index,\n-\t\t\t\t\t\t   info->subscript[dim]);\n-\t      index =\n-\t\tgfc_trans_array_bound_check (se, info->descriptor, index,\n-\t\t\t\t\t     dim);\n-\t    }\n-\t  else\n-\t    gcc_assert (ar->dimen_type[dim] == DIMEN_RANGE);\n+\tdefault:\n+\t  gcc_unreachable ();\n \t}\n     }\n   else\n@@ -2195,27 +2171,25 @@ static tree\n gfc_conv_section_upper_bound (gfc_ss * ss, int n, stmtblock_t * pblock)\n {\n   int dim;\n-  gfc_ss *vecss;\n   gfc_expr *end;\n   tree desc;\n   tree bound;\n   gfc_se se;\n+  gfc_ss_info *info;\n \n   gcc_assert (ss->type == GFC_SS_SECTION);\n \n-  /* For vector array subscripts we want the size of the vector.  */\n-  dim = ss->data.info.dim[n];\n-  vecss = ss;\n-  while (vecss->data.info.ref->u.ar.dimen_type[dim] == DIMEN_VECTOR)\n-    {\n-      vecss = vecss->data.info.subscript[dim];\n-      gcc_assert (vecss && vecss->type == GFC_SS_VECTOR);\n-      dim = vecss->data.info.dim[0];\n-    }\n+  info = &ss->data.info;\n+  dim = info->dim[n];\n \n-  gcc_assert (vecss->data.info.ref->u.ar.dimen_type[dim] == DIMEN_RANGE);\n-  end = vecss->data.info.ref->u.ar.end[dim];\n-  desc = vecss->data.info.descriptor;\n+  if (info->ref->u.ar.dimen_type[dim] == DIMEN_VECTOR)\n+    /* We'll calculate the upper bound once we have access to the\n+       vector's descriptor.  */\n+    return NULL;\n+\n+  gcc_assert (info->ref->u.ar.dimen_type[dim] == DIMEN_RANGE);\n+  desc = info->descriptor;\n+  end = info->ref->u.ar.end[dim];\n \n   if (end)\n     {\n@@ -2242,32 +2216,28 @@ gfc_conv_section_startstride (gfc_loopinfo * loop, gfc_ss * ss, int n)\n {\n   gfc_expr *start;\n   gfc_expr *stride;\n-  gfc_ss *vecss;\n   tree desc;\n   gfc_se se;\n   gfc_ss_info *info;\n   int dim;\n \n-  info = &ss->data.info;\n+  gcc_assert (ss->type == GFC_SS_SECTION);\n \n+  info = &ss->data.info;\n   dim = info->dim[n];\n \n-  /* For vector array subscripts we want the size of the vector.  */\n-  vecss = ss;\n-  while (vecss->data.info.ref->u.ar.dimen_type[dim] == DIMEN_VECTOR)\n+  if (info->ref->u.ar.dimen_type[dim] == DIMEN_VECTOR)\n     {\n-      vecss = vecss->data.info.subscript[dim];\n-      gcc_assert (vecss && vecss->type == GFC_SS_VECTOR);\n-      /* Get the descriptors for the vector subscripts as well.  */\n-      if (!vecss->data.info.descriptor)\n-\tgfc_conv_ss_descriptor (&loop->pre, vecss, !loop->array_parameter);\n-      dim = vecss->data.info.dim[0];\n+      /* We use a zero-based index to access the vector.  */\n+      info->start[n] = gfc_index_zero_node;\n+      info->stride[n] = gfc_index_one_node;\n+      return;\n     }\n \n-  gcc_assert (vecss->data.info.ref->u.ar.dimen_type[dim] == DIMEN_RANGE);\n-  start = vecss->data.info.ref->u.ar.start[dim];\n-  stride = vecss->data.info.ref->u.ar.stride[dim];\n-  desc = vecss->data.info.descriptor;\n+  gcc_assert (info->ref->u.ar.dimen_type[dim] == DIMEN_RANGE);\n+  desc = info->descriptor;\n+  start = info->ref->u.ar.start[dim];\n+  stride = info->ref->u.ar.stride[dim];\n \n   /* Calculate the start of the range.  For vector subscripts this will\n      be the range of the vector.  */\n@@ -2309,7 +2279,6 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n   int n;\n   tree tmp;\n   gfc_ss *ss;\n-  gfc_ss *vecss;\n   tree desc;\n \n   loop->dimen = 0;\n@@ -2390,22 +2359,15 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t  /* TODO: range checking for mapped dimensions.  */\n \t  info = &ss->data.info;\n \n-\t  /* This only checks scalarized dimensions, elemental dimensions are\n-\t     checked later.  */\n+\t  /* This code only checks ranges.  Elemental and vector\n+\t     dimensions are checked later.  */\n \t  for (n = 0; n < loop->dimen; n++)\n \t    {\n \t      dim = info->dim[n];\n-\t      vecss = ss;\n-\t      while (vecss->data.info.ref->u.ar.dimen_type[dim]\n-\t\t     == DIMEN_VECTOR)\n-\t\t{\n-\t\t  vecss = vecss->data.info.subscript[dim];\n-\t\t  gcc_assert (vecss && vecss->type == GFC_SS_VECTOR);\n-\t\t  dim = vecss->data.info.dim[0];\n-\t\t}\n-\t      gcc_assert (vecss->data.info.ref->u.ar.dimen_type[dim]\n-\t\t      == DIMEN_RANGE);\n-\t      desc = vecss->data.info.descriptor;\n+\t      if (info->ref->u.ar.dimen_type[dim] != DIMEN_RANGE)\n+\t\tcontinue;\n+\n+\t      desc = ss->data.info.descriptor;\n \n \t      /* Check lower bound.  */\n \t      bound = gfc_conv_array_lbound (desc, dim);\n@@ -3662,11 +3624,28 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc, tree body)\n }\n \n \n-/* Convert an array for passing as an actual parameter.  Expressions and\n+/* Convert an array for passing as an actual argument.  Expressions and\n    vector subscripts are evaluated and stored in a temporary, which is then\n    passed.  For whole arrays the descriptor is passed.  For array sections\n    a modified copy of the descriptor is passed, but using the original data.\n-   Also used for array pointer assignments by setting se->direct_byref.  */\n+\n+   This function is also used for array pointer assignments, and there\n+   are three cases:\n+\n+     - want_pointer && !se->direct_byref\n+\t EXPR is an actual argument.  On exit, se->expr contains a\n+\t pointer to the array descriptor.\n+\n+     - !want_pointer && !se->direct_byref\n+\t EXPR is an actual argument to an intrinsic function or the\n+\t left-hand side of a pointer assignment.  On exit, se->expr\n+\t contains the descriptor for EXPR.\n+\n+     - !want_pointer && se->direct_byref\n+\t EXPR is the right-hand side of a pointer assignment and\n+\t se->expr is the descriptor for the previously-evaluated\n+\t left-hand side.  The function creates an assignment from\n+\t EXPR to se->expr.  */\n \n void\n gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n@@ -3682,7 +3661,6 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n   tree start;\n   tree offset;\n   int full;\n-  gfc_ss *vss;\n   gfc_ref *ref;\n \n   gcc_assert (ss != gfc_ss_terminator);\n@@ -3701,21 +3679,16 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \tsecss = secss->next;\n \n       gcc_assert (secss != gfc_ss_terminator);\n-\n-      need_tmp = 0;\n-      for (n = 0; n < secss->data.info.dimen; n++)\n-\t{\n-\t  vss = secss->data.info.subscript[secss->data.info.dim[n]];\n-\t  if (vss && vss->type == GFC_SS_VECTOR)\n-\t    need_tmp = 1;\n-\t}\n-\n       info = &secss->data.info;\n \n       /* Get the descriptor for the array.  */\n       gfc_conv_ss_descriptor (&se->pre, secss, 0);\n       desc = info->descriptor;\n-      if (GFC_ARRAY_TYPE_P (TREE_TYPE (desc)))\n+\n+      need_tmp = gfc_ref_needs_temporary_p (expr->ref);\n+      if (need_tmp)\n+\tfull = 0;\n+      else if (GFC_ARRAY_TYPE_P (TREE_TYPE (desc)))\n \t{\n \t  /* Create a new descriptor if the array doesn't have one.  */\n \t  full = 0;\n@@ -3745,23 +3718,6 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \t    }\n \t}\n \n-      /* Check for substring references.  */\n-      ref = expr->ref;\n-      if (!need_tmp && ref && expr->ts.type == BT_CHARACTER)\n-\t{\n-\t  while (ref->next)\n-\t    ref = ref->next;\n-\t  if (ref->type == REF_SUBSTRING)\n-\t    {\n-\t      /* In general character substrings need a copy.  Character\n-\t\t array strides are expressed as multiples of the element\n-\t\t size (consistent with other array types), not in\n-\t\t characters.  */\n-\t      full = 0;\n-\t      need_tmp = 1;\n-\t    }\n-\t}\n-\n       if (full)\n \t{\n \t  if (se->direct_byref)\n@@ -3841,7 +3797,8 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n   if (!need_tmp)\n     loop.array_parameter = 1;\n   else\n-    gcc_assert (se->want_pointer && !se->direct_byref);\n+    /* The right-hand side of a pointer assignment mustn't use a temporary.  */\n+    gcc_assert (!se->direct_byref);\n \n   /* Setup the scalarizing loops and bounds.  */\n   gfc_conv_ss_startstride (&loop);\n@@ -3922,17 +3879,11 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n       gfc_add_modify_expr (&loop.pre, tmp, gfc_index_zero_node);\n \n       gcc_assert (is_gimple_lvalue (desc));\n-      se->expr = gfc_build_addr_expr (NULL, desc);\n     }\n   else if (expr->expr_type == EXPR_FUNCTION)\n     {\n       desc = info->descriptor;\n \n-      if (se->want_pointer)\n-\tse->expr = gfc_build_addr_expr (NULL_TREE, desc);\n-      else\n-\tse->expr = desc;\n-\n       if (expr->ts.type == BT_CHARACTER)\n \tse->string_length = expr->symtree->n.sym->ts.cl->backend_decl;\n     }\n@@ -4083,15 +4034,16 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \t  tmp = gfc_conv_descriptor_offset (parm);\n \t  gfc_add_modify_expr (&loop.pre, tmp, gfc_index_zero_node);\n \t}\n+      desc = parm;\n+    }\n \n-      if (!se->direct_byref)\n-\t{\n-\t  /* Get a pointer to the new descriptor.  */\n-          if (se->want_pointer)\n-\t    se->expr = gfc_build_addr_expr (NULL, parm);\n-          else\n-            se->expr = parm;\n-\t}\n+  if (!se->direct_byref)\n+    {\n+      /* Get a pointer to the new descriptor.  */\n+      if (se->want_pointer)\n+\tse->expr = gfc_build_addr_expr (NULL, desc);\n+      else\n+\tse->expr = desc;\n     }\n \n   gfc_add_block_to_block (&se->pre, &loop.pre);\n@@ -4383,24 +4335,14 @@ gfc_walk_variable_expr (gfc_ss * ss, gfc_expr * expr)\n \t\t  break;\n \n \t\tcase DIMEN_VECTOR:\n-\t\t  /* Get a SS for the vector.  This will not be added to the\n-\t\t     chain directly.  */\n-\t\t  indexss = gfc_walk_expr (ar->start[n]);\n-\t\t  if (indexss == gfc_ss_terminator)\n-\t\t    internal_error (\"scalar vector subscript???\");\n-\n-                  /* We currently only handle really simple vector\n-                     subscripts.  */\n-\t\t  if (indexss->next != gfc_ss_terminator)\n-\t\t    gfc_todo_error (\"vector subscript expressions\");\n-\t\t  indexss->loop_chain = gfc_ss_terminator;\n-\n-\t\t  /* Mark this as a vector subscript.  We don't add this\n-                     directly into the chain, but as a subscript of the\n-                     existing SS for this term.  */\n+\t\t  /* Create a GFC_SS_VECTOR index in which we can store\n+\t\t     the vector's descriptor.  */\n+\t\t  indexss = gfc_get_ss ();\n \t\t  indexss->type = GFC_SS_VECTOR;\n+\t\t  indexss->expr = ar->start[n];\n+\t\t  indexss->next = gfc_ss_terminator;\n+\t\t  indexss->loop_chain = gfc_ss_terminator;\n \t\t  newss->data.info.subscript[n] = indexss;\n-                  /* Also remember this dimension.  */\n \t\t  newss->data.info.dim[newss->data.info.dimen] = n;\n \t\t  newss->data.info.dimen++;\n \t\t  break;"}, {"sha": "fce8e7b614e8650a46a329238af22043c8dd0263", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a70c12d9b2ba6d2c7e154053ef19ac316f3c34e/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a70c12d9b2ba6d2c7e154053ef19ac316f3c34e/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=7a70c12d9b2ba6d2c7e154053ef19ac316f3c34e", "patch": "@@ -39,6 +39,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"trans-array.h\"\n /* Only for gfc_trans_assign and gfc_trans_pointer_assign.  */\n #include \"trans-stmt.h\"\n+#include \"dependency.h\"\n \n static tree gfc_trans_structure_assign (tree dest, gfc_expr * expr);\n static void gfc_apply_interface_mapping_to_expr (gfc_interface_mapping *,\n@@ -2575,6 +2576,10 @@ gfc_trans_arrayfunc_assign (gfc_expr * expr1, gfc_expr * expr2)\n   if (expr2->symtree->n.sym->attr.elemental)\n     return NULL;\n \n+  /* Fail if EXPR1 can't be expressed as a descriptor.  */\n+  if (gfc_ref_needs_temporary_p (expr1->ref))\n+    return NULL;\n+\n   /* Check for a dependency.  */\n   if (gfc_check_fncall_dependency (expr1, expr2))\n     return NULL;"}, {"sha": "a0b4334c3a142675b07fd775aa746dd3b651147e", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a70c12d9b2ba6d2c7e154053ef19ac316f3c34e/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a70c12d9b2ba6d2c7e154053ef19ac316f3c34e/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=7a70c12d9b2ba6d2c7e154053ef19ac316f3c34e", "patch": "@@ -138,8 +138,8 @@ typedef enum\n      uses this temporary inside the scalarization loop.  */\n   GFC_SS_CONSTRUCTOR,\n \n-  /* A vector subscript.  Only used as the SS chain for a subscript.\n-     Similar int format to a GFC_SS_SECTION.  */\n+  /* A vector subscript.  The vector's descriptor is cached in the\n+     \"descriptor\" field of the associated gfc_ss_info.  */\n   GFC_SS_VECTOR,\n \n   /* A temporary array allocated by the scalarizer.  Its rank can be less"}, {"sha": "6ce489e65b92a35350bd83b61e83cd915ce3a56d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a70c12d9b2ba6d2c7e154053ef19ac316f3c34e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a70c12d9b2ba6d2c7e154053ef19ac316f3c34e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7a70c12d9b2ba6d2c7e154053ef19ac316f3c34e", "patch": "@@ -1,3 +1,9 @@\n+2005-09-09  Richard Sandiford  <richard@codesourcery.com>\n+\n+\tPR fortran/19239\n+\t* gfortran.fortran-torture/execute/pr19239-1.f90,\n+\t* gfortran.fortran-torture/execute/pr19239-2.f90: New tests\n+\n 2005-09-09  Richard Sandiford  <richard@codesourcery.com>\n \n \tPR fortran/21104"}, {"sha": "dd09fbb0b8a8a1cdcdfafb0e300065a76e6f62b8", "filename": "gcc/testsuite/gfortran.dg/vector_subscript_1.f90", "status": "added", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a70c12d9b2ba6d2c7e154053ef19ac316f3c34e/gcc%2Ftestsuite%2Fgfortran.dg%2Fvector_subscript_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a70c12d9b2ba6d2c7e154053ef19ac316f3c34e/gcc%2Ftestsuite%2Fgfortran.dg%2Fvector_subscript_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fvector_subscript_1.f90?ref=7a70c12d9b2ba6d2c7e154053ef19ac316f3c34e", "patch": "@@ -0,0 +1,174 @@\n+! PR 19239.  Check for various kinds of vector subscript.  In this test,\n+! all vector subscripts are indexing single-dimensional arrays.\n+! { dg-do run }\n+program main\n+  implicit none\n+  integer, parameter :: n = 10\n+  integer :: i, j, calls\n+  integer, dimension (n) :: a, b, idx, id\n+\n+  idx = (/ 3, 1, 5, 2, 4, 10, 8, 7, 6, 9 /)\n+  id = (/ (i, i = 1, n) /)\n+  b = (/ (i * 100, i = 1, n) /)\n+\n+  !------------------------------------------------------------------\n+  ! Tests for a simple variable subscript\n+  !------------------------------------------------------------------\n+\n+  a (idx) = b\n+  call test (idx, id)\n+\n+  a = b (idx)\n+  call test (id, idx)\n+\n+  a (idx) = b (idx)\n+  call test (idx, idx)\n+\n+  !------------------------------------------------------------------\n+  ! Tests for constant ranges with non-default stride\n+  !------------------------------------------------------------------\n+\n+  a (idx (1:7:3)) = b (10:6:-2)\n+  call test (idx (1:7:3), id (10:6:-2))\n+\n+  a (10:6:-2) = b (idx (1:7:3))\n+  call test (id (10:6:-2), idx (1:7:3))\n+\n+  a (idx (1:7:3)) = b (idx (1:7:3))\n+  call test (idx (1:7:3), idx (1:7:3))\n+\n+  a (idx (1:7:3)) = b (idx (10:6:-2))\n+  call test (idx (1:7:3), idx (10:6:-2))\n+\n+  a (idx (10:6:-2)) = b (idx (10:6:-2))\n+  call test (idx (10:6:-2), idx (10:6:-2))\n+\n+  a (idx (10:6:-2)) = b (idx (1:7:3))\n+  call test (idx (10:6:-2), idx (1:7:3))\n+\n+  !------------------------------------------------------------------\n+  ! Tests for subscripts of the form CONSTRANGE + CONST\n+  !------------------------------------------------------------------\n+\n+  a (idx (1:5) + 1) = b (1:5)\n+  call test (idx (1:5) + 1, id (1:5))\n+\n+  a (1:5) = b (idx (1:5) + 1)\n+  call test (id (1:5), idx (1:5) + 1)\n+\n+  a (idx (6:10) - 1) = b (idx (1:5) + 1)\n+  call test (idx (6:10) - 1, idx (1:5) + 1)\n+\n+  !------------------------------------------------------------------\n+  ! Tests for variable subranges\n+  !------------------------------------------------------------------\n+\n+  do j = 5, 10\n+    a (idx (2:j:2)) = b (3:2+j/2)\n+    call test (idx (2:j:2), id (3:2+j/2))\n+\n+    a (3:2+j/2) = b (idx (2:j:2))\n+    call test (id (3:2+j/2), idx (2:j:2))\n+\n+    a (idx (2:j:2)) = b (idx (2:j:2))\n+    call test (idx (2:j:2), idx (2:j:2))\n+  end do\n+\n+  !------------------------------------------------------------------\n+  ! Tests for function vectors\n+  !------------------------------------------------------------------\n+\n+  calls = 0\n+\n+  a (foo (5, calls)) = b (2:10:2)\n+  call test (foo (5, calls), id (2:10:2))\n+\n+  a (2:10:2) = b (foo (5, calls))\n+  call test (id (2:10:2), foo (5, calls))\n+\n+  a (foo (5, calls)) = b (foo (5, calls))\n+  call test (foo (5, calls), foo (5, calls))\n+\n+  if (calls .ne. 8) call abort\n+\n+  !------------------------------------------------------------------\n+  ! Tests for constant vector constructors\n+  !------------------------------------------------------------------\n+\n+  a ((/ 1, 5, 3, 9 /)) = b (1:4)\n+  call test ((/ 1, 5, 3, 9 /), id (1:4))\n+\n+  a (1:4) = b ((/ 1, 5, 3, 9 /))\n+  call test (id (1:4), (/ 1, 5, 3, 9 /))\n+\n+  a ((/ 1, 5, 3, 9 /)) = b ((/ 2, 5, 3, 7 /))\n+  call test ((/ 1, 5, 3, 9 /), (/ 2, 5, 3, 7 /))\n+\n+  !------------------------------------------------------------------\n+  ! Tests for variable vector constructors\n+  !------------------------------------------------------------------\n+\n+  do j = 1, 5\n+    a ((/ 1, (i + 3, i = 2, j) /)) = b (1:j)\n+    call test ((/ 1, (i + 3, i = 2, j) /), id (1:j))\n+\n+    a (1:j) = b ((/ 1, (i + 3, i = 2, j) /))\n+    call test (id (1:j), (/ 1, (i + 3, i = 2, j) /))\n+\n+    a ((/ 1, (i + 3, i = 2, j) /)) = b ((/ 8, (i + 2, i = 2, j) /))\n+    call test ((/ 1, (i + 3, i = 2, j) /), (/ 8, (i + 2, i = 2, j) /))\n+  end do\n+\n+  !------------------------------------------------------------------\n+  ! Tests in which the vector dimension is partnered by a temporary\n+  !------------------------------------------------------------------\n+\n+  calls = 0\n+  a (idx (1:6)) = foo (6, calls)\n+  if (calls .ne. 1) call abort\n+  do i = 1, 6\n+    if (a (idx (i)) .ne. i + 3) call abort\n+  end do\n+  a = 0\n+\n+  calls = 0\n+  a (idx (1:6)) = foo (6, calls) * 100\n+  if (calls .ne. 1) call abort\n+  do i = 1, 6\n+    if (a (idx (i)) .ne. (i + 3) * 100) call abort\n+  end do\n+  a = 0\n+\n+  a (idx) = id + 100\n+  do i = 1, n\n+    if (a (idx (i)) .ne. i + 100) call abort\n+  end do\n+  a = 0\n+\n+  a (idx (1:10:3)) = (/ 20, 10, 9, 11 /)\n+  if (a (idx (1)) .ne. 20) call abort\n+  if (a (idx (4)) .ne. 10) call abort\n+  if (a (idx (7)) .ne. 9) call abort\n+  if (a (idx (10)) .ne. 11) call abort\n+  a = 0\n+\n+contains\n+  subroutine test (lhs, rhs)\n+    integer, dimension (:) :: lhs, rhs\n+    integer :: i\n+\n+    if (size (lhs, 1) .ne. size (rhs, 1)) call abort\n+    do i = 1, size (lhs, 1)\n+      if (a (lhs (i)) .ne. b (rhs (i))) call abort\n+    end do\n+    a = 0\n+  end subroutine test\n+\n+  function foo (n, calls)\n+    integer :: i, n, calls\n+    integer, dimension (n) :: foo\n+\n+    calls = calls + 1\n+    foo = (/ (i + 3, i = 1, n) /)\n+  end function foo\n+end program main"}, {"sha": "a5c024a28edbc953328c73742e40dc6d3f493d8f", "filename": "gcc/testsuite/gfortran.dg/vector_subscript_2.f90", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a70c12d9b2ba6d2c7e154053ef19ac316f3c34e/gcc%2Ftestsuite%2Fgfortran.dg%2Fvector_subscript_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a70c12d9b2ba6d2c7e154053ef19ac316f3c34e/gcc%2Ftestsuite%2Fgfortran.dg%2Fvector_subscript_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fvector_subscript_2.f90?ref=7a70c12d9b2ba6d2c7e154053ef19ac316f3c34e", "patch": "@@ -0,0 +1,39 @@\n+! Like vector_subscript_1.f90, but check subscripts in multi-dimensional\n+! arrays.\n+! { dg-do run }\n+program main\n+  implicit none\n+  integer, parameter :: n = 5\n+  integer :: i1, i2, i3\n+  integer, dimension (n, n, n) :: a, b\n+  integer, dimension (n) :: idx, id\n+\n+  idx = (/ 3, 1, 5, 2, 4 /)\n+  id = (/ (i1, i1 = 1, n) /)\n+  forall (i1 = 1:n, i2 = 1:n, i3 = 1:n)\n+    b (i1, i2, i3) = i1 + i2 * 10 + i3 * 100\n+  end forall\n+\n+  i1 = 5\n+  a (foo (i1), 1, :) = b (2, :, foo (i1))\n+  do i1 = 1, 5\n+    do i2 = 1, 5\n+      if (a (idx (i1), 1, i2) .ne. b (2, i1, idx (i2))) call abort\n+    end do\n+  end do\n+  a = 0\n+\n+  a (1, idx (1:4), 2:4) = b (2:5, idx (3:5), 2)\n+  do i1 = 1, 4\n+    do i2 = 1, 3\n+      if (a (1, idx (i1), 1 + i2) .ne. b (1 + i1, idx (i2 + 2), 2)) call abort\n+    end do\n+  end do\n+  a = 0\n+contains\n+  function foo (n)\n+    integer :: n\n+    integer, dimension (n) :: foo\n+    foo = idx (1:n)\n+  end function foo\n+end program main"}]}