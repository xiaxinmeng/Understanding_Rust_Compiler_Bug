{"sha": "a55e9d2b21e897007f739cdbe66d5227b35ebba3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTU1ZTlkMmIyMWU4OTcwMDdmNzM5Y2RiZTY2ZDUyMjdiMzVlYmJhMw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-07-28T13:06:19Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-07-28T13:06:19Z"}, "message": "(reg_unused_after): New function.\n\nFrom-SVN: r10183", "tree": {"sha": "1fbb6b3edf66e0fd19ea225a5896e115c517d731", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1fbb6b3edf66e0fd19ea225a5896e115c517d731"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a55e9d2b21e897007f739cdbe66d5227b35ebba3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a55e9d2b21e897007f739cdbe66d5227b35ebba3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a55e9d2b21e897007f739cdbe66d5227b35ebba3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a55e9d2b21e897007f739cdbe66d5227b35ebba3/comments", "author": null, "committer": null, "parents": [{"sha": "aa6301773f48e7130fa002def822371f8d7e2975", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa6301773f48e7130fa002def822371f8d7e2975", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa6301773f48e7130fa002def822371f8d7e2975"}], "stats": {"total": 50, "additions": 50, "deletions": 0}, "files": [{"sha": "36d489c0f2fd48dbdcbb04b091c810a3499ca0c6", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a55e9d2b21e897007f739cdbe66d5227b35ebba3/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a55e9d2b21e897007f739cdbe66d5227b35ebba3/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=a55e9d2b21e897007f739cdbe66d5227b35ebba3", "patch": "@@ -1850,3 +1850,53 @@ sh_function_arg_partial_nregs (cum, mode, type, named)\n     }\n   return 0;\n }\n+\f\n+/* Return non-zero if REG is not used after INSN.\n+   We assume REG is a reload reg, and therefore does\n+   not live past labels or calls or jumps.  */\n+int\n+reg_unused_after (reg, insn)\n+     rtx reg;\n+     rtx insn;\n+{\n+  enum rtx_code code, prev_code = UNKNOWN;\n+  rtx set;\n+\n+  /* If the reg is set by this instruction, then it is safe for our\n+     case.  Disregard the case where this is a store to memory, since\n+     we are checking a register used in the store address.  */\n+  set = single_set (insn);\n+  if (set && GET_CODE (SET_DEST (set)) != MEM\n+      && reg_overlap_mentioned_p (reg, SET_DEST (set)))\n+    return 1;\n+\n+  while (insn = NEXT_INSN (insn))\n+    {\n+      if (prev_code == CALL_INSN && call_used_regs[REGNO (reg)])\n+\treturn 1;\n+\n+      code = GET_CODE (insn);\n+      if (GET_CODE (insn) == CODE_LABEL)\n+\treturn 1;\n+\n+      if (code == INSN && GET_CODE (PATTERN (insn)) == SEQUENCE)\n+\t{\n+\t  insn = XVECEXP (PATTERN (insn), 0, 0);\n+\t  code = GET_CODE (insn);\n+\t}\n+\n+      if (GET_RTX_CLASS (code) == 'i')\n+\t{\n+\t  rtx set = single_set (insn);\n+\n+\t  if (set && reg_overlap_mentioned_p (reg, SET_SRC (set)))\n+\t    return 0;\n+\t  if (set && reg_overlap_mentioned_p (reg, SET_DEST (set)))\n+\t    return GET_CODE (SET_DEST (set)) != MEM;\n+\t  if (set == 0 && reg_overlap_mentioned_p (reg, PATTERN (insn)))\n+\t    return 0;\n+\t}\n+      prev_code = code;\n+    }\n+  return 1;\n+}"}]}