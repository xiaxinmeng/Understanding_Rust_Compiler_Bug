{"sha": "f9610d205a723ac0d4cb4076dbd2d935b0077373", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjk2MTBkMjA1YTcyM2FjMGQ0Y2I0MDc2ZGJkMmQ5MzViMDA3NzM3Mw==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2011-07-11T17:57:49Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2011-07-11T17:57:49Z"}, "message": "i386.c (ix86_trampoline_init): Switch arms of if expr.\n\n\t* config/i386/i386.c (ix86_trampoline_init): Switch arms of if expr.\n\tUse offset everywhere.  Always assert that offset <= TRAMPOLINE_SIZE.\n\nFrom-SVN: r176173", "tree": {"sha": "b69e6e1c54778d6baf9070b704dad28ca59ae249", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b69e6e1c54778d6baf9070b704dad28ca59ae249"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f9610d205a723ac0d4cb4076dbd2d935b0077373", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9610d205a723ac0d4cb4076dbd2d935b0077373", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9610d205a723ac0d4cb4076dbd2d935b0077373", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9610d205a723ac0d4cb4076dbd2d935b0077373/comments", "author": null, "committer": null, "parents": [{"sha": "4d4a9b72beceb6e1bf6233f4e2496a6e34b6332f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d4a9b72beceb6e1bf6233f4e2496a6e34b6332f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d4a9b72beceb6e1bf6233f4e2496a6e34b6332f"}], "stats": {"total": 202, "additions": 97, "deletions": 105}, "files": [{"sha": "cb1fd65169c53e8453716660b9a523c940d68487", "filename": "gcc/ChangeLog", "status": "modified", "additions": 39, "deletions": 55, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9610d205a723ac0d4cb4076dbd2d935b0077373/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9610d205a723ac0d4cb4076dbd2d935b0077373/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f9610d205a723ac0d4cb4076dbd2d935b0077373", "patch": "@@ -1,3 +1,8 @@\n+2011-07-11  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386.c (ix86_trampoline_init): Switch arms of if expr.\n+\tUse offset everywhere.  Always assert that offset <= TRAMPOLINE_SIZE.\n+\n 2011-07-11  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR debug/49676\n@@ -74,7 +79,7 @@\n \tafter induction variable optimization.\n \n 2011-07-11  Georg-Johann Lay  <avr@gjlay.de>\n-\t\n+\n \tPR target/39633\n \t* config/avr/avr.c (notice_update_cc): For ashiftrt:QI, only\n \toffsets 1..5 set cc0 in a usable way.\n@@ -191,8 +196,7 @@\n \tPR debug/49676\n \t* dwarf2out.c (size_of_int_loc_descriptor): New function.\n \t(address_of_int_loc_descriptor): Use it.\n-\t(scompare_loc_descriptor): Optimize EQ/NE comparison with\n-\tconstant.\n+\t(scompare_loc_descriptor): Optimize EQ/NE comparison with constant.\n \n 2011-07-09  Richard Henderson  <rth@redhat.com>\n \n@@ -249,8 +253,7 @@\n \n \tPR target/49621\n \t* config/rs6000/rs6000.c (rs6000_emit_vector_cond_expr): Use\n-\tCONST0_RTX (dest_mode) instead of const0_rtx as second operand\n-\tof NE.\n+\tCONST0_RTX (dest_mode) instead of const0_rtx as second operand of NE.\n \t* config/rs6000/vector.md (vector_select_<mode>,\n \tvector_select_<mode>_uns): Change second operand of NE to\n \tCONST0_RTX (<MODE>mode) instead of const0_rtx.\n@@ -266,7 +269,7 @@\n \tcontinue from loop, add one more assert.\n \n 2011-07-08  Georg-Johann Lay  <avr@gjlay.de>\n-\t\n+\n \tPR target/46779\n \t* config/avr/avr.c (avr_hard_regno_mode_ok): Rewrite.\n \tIn particular, allow 8-bit values in r28 and r29.\n@@ -347,8 +350,7 @@\n \n \t* optabs.c (expand_binop): Tighten conditions for doubleword\n \texpansions.\n-\t(widen_bswap): Assert that mode bitsize and precision are the\n-\tsame.\n+\t(widen_bswap): Assert that mode bitsize and precision are the same.\n \t* stor-layout.c (get_best_mode): Skip modes that have lower\n \tprecision than bitsize.\n \t* recog.c (simplify_while_replacing): Assert that bitsize and\n@@ -545,8 +547,7 @@\n \n 2011-07-07  Joseph Myers  <joseph@codesourcery.com>\n \n-\t* config/i386/t-crtpic, config/i386/t-svr3dbx, config/pa/t-pa:\n-\tRemove.\n+\t* config/i386/t-crtpic, config/i386/t-svr3dbx, config/pa/t-pa: Remove.\n \n 2011-07-07  Bernd Schmidt  <bernds@codesourcery.com>\n \n@@ -574,8 +575,7 @@\n \n 2011-07-07  H.J. Lu  <hongjiu.lu@intel.com>\n \n-\t* config.gcc: Support --with-multilib-list for x86 Linux\n-\ttargets.\n+\t* config.gcc: Support --with-multilib-list for x86 Linux targets.\n \n \t* configure.ac: Mention x86-64 for --with-multilib-list.\n \t* configure: Regenerated.\n@@ -609,8 +609,7 @@\n \n \t* config/i386/t-linux64: Support TM_MULTILIB_CONFIG.\n \n-\t* doc/install.texi: Document --with-multilib-list for\n-\tLinux/x86-64.\n+\t* doc/install.texi: Document --with-multilib-list for Linux/x86-64.\n \n \t* doc/invoke.texi: Document -mx32.\n \n@@ -660,24 +659,18 @@\n \t(TARGET_HAVE_NAMED_SECTIONS): Don't define.\n \t* common/config/m32c/m32c-common.c: Remove.\n \t* config.gcc (m32c*-*-*): Set target_has_targetm_common=no.\n-\t* config/alpha/osf5.h (TARGET_HAVE_NAMED_SECTIONS): Define to\n-\tfalse.\n-\t* config/i386/openbsd.h (TARGET_HAVE_NAMED_SECTIONS): Define to\n-\tfalse.\n-\t* config/m68k/openbsd.h (TARGET_HAVE_NAMED_SECTIONS): Define to\n-\tfalse.\n+\t* config/alpha/osf5.h (TARGET_HAVE_NAMED_SECTIONS): Define to false.\n+\t* config/i386/openbsd.h (TARGET_HAVE_NAMED_SECTIONS): Define to false.\n+\t* config/m68k/openbsd.h (TARGET_HAVE_NAMED_SECTIONS): Define to false.\n \t* config/pa/som.h (TARGET_HAVE_NAMED_SECTIONS): Define to false.\n-\t* config/pdp11/pdp11.h (TARGET_HAVE_NAMED_SECTIONS): Define to\n-\tfalse.\n-\t* config/vax/openbsd.h (TARGET_HAVE_NAMED_SECTIONS): Define to\n-\tfalse.\n+\t* config/pdp11/pdp11.h (TARGET_HAVE_NAMED_SECTIONS): Define to false.\n+\t* config/vax/openbsd.h (TARGET_HAVE_NAMED_SECTIONS): Define to false.\n \n 2011-07-07  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/49640\n-\t* gimplify.c (gimplify_compound_lval): For last 2 ARRAY_*REF\n-\toperands and last COMPONENT_REF operand call gimplify_expr on it\n-\tif non-NULL.\n+\t* gimplify.c (gimplify_compound_lval): For last 2 ARRAY_*REF operands\n+\tand last COMPONENT_REF operand call gimplify_expr on it if non-NULL.\n \n 2011-07-07  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n@@ -708,8 +701,7 @@\n \t(ASM_SPEC): Redefine.\n \t(DEFAULT_ARCH32_P): Define using TARGET_64BIT_DEFAULT.\n \t* config/host-solaris.c [__x86_64__] (TRY_EMPTY_VM_SPACE): Reduce.\n-\t* doc/install.texi (Specific, amd64-*-solaris2.1[0-9]*):\n-\tDocument.\n+\t* doc/install.texi (Specific, amd64-*-solaris2.1[0-9]*): Document.\n \t(Specific, i?86-*-solaris2.10): Mention x86_64-*-solaris2.1[0-9]*\n \tconfiguration.\n \t(Specific, x86_64-*-solaris2.1[0-9]*): Document.\n@@ -724,7 +716,7 @@\n \t* config/sparc/sol2.h (ASM_SPEC): Redefine.\n \n 2011-07-07  Georg-Johann Lay  <avr@gjlay.de>\n-\t\n+\n \t* config/avr/avr.md (*reload_insi): Change predicate #1 to\n \tconst_int_operand.  Ditto for peep2 producing this insn.\n \tAdd argument to output_reload_insisf call.\n@@ -787,11 +779,10 @@\n \n \tRevert:\n \t* simplify-rtx.c (simplify_const_binary_operation): Use the\n-\tshift_truncation_mask hook instead of performing modulo by\n-\twidth.  Compare against mode precision, not bitsize.\n+\tshift_truncation_mask hook instead of performing modulo by width.\n+\tCompare against mode precision, not bitsize.\n \t* combine.c (combine_simplify_rtx, simplify_shift_const_1):\n-\tUse shift_truncation_mask instead of constructing the value\n-\tmanually.\n+\tUse shift_truncation_mask instead of constructing the value manually.\n \n 2011-07-06  Michael Meissner  <meissner@linux.vnet.ibm.com>\n \n@@ -830,10 +821,8 @@\n \t(AIX_FUNC_DESC_TOC_64BIT): Ditto.\n \t(AIX_FUNC_DESC_SC_32BIT): Ditto.\n \t(AIX_FUNC_DESC_SC_64BIT): Ditto.\n-\t(ptrload): New mode attribute for the appropriate load of a\n-\tpointer.\n-\t(call_indirect_aix32): Delete, rewrite AIX indirect function\n-\tcalls.\n+\t(ptrload): New mode attribute for the appropriate load of a pointer.\n+\t(call_indirect_aix32): Delete, rewrite AIX indirect function calls.\n \t(call_indirect_aix64): Ditto.\n \t(call_value_indirect_aix32): Ditto.\n \t(call_value_indirect_aix64): Ditto.\n@@ -866,8 +855,7 @@\n \n 2011-07-06  James Greenhalgh  <james.greenhalgh@arm.com>\n \n-\t* config/arm/arm.h (TARGET_CPU_CPP_BUILTINS): Add\n-\t__ARM_FEATURE_DSP.\n+\t* config/arm/arm.h (TARGET_CPU_CPP_BUILTINS): Add __ARM_FEATURE_DSP.\n \n 2011-07-06  Basile Starynkevitch  <basile@starynkevitch.net>\n \n@@ -906,16 +894,14 @@\n \t* simplify-rtx.c (mode_signbit_p): Use GET_MODE_PRECISION.\n \t(val_mode_signbit_p, val_mode_signbit_set_p): New functions.\n \t(simplify_const_unary_operation, simplify_binary_operation_1,\n-\tsimplify_const_binary_operation,\n-\tsimplify_const_relational_operation): Use them.  Use\n-\tGET_MODE_MASK for masking and sign-extensions.\n+\tsimplify_const_binary_operation, simplify_const_relational_operation):\n+\tUse them.  Use GET_MODE_MASK for masking and sign-extensions.\n \t* combine.c (set_nonzero_bits_and_sign_copies, simplify_set,\n \tcombine_simplify_rtx, force_to_mode, reg_nonzero_bits_for_combine,\n \tsimplify_shift_const_1, simplify_comparison): Likewise.\n \t* expr.c (convert_modes): Likewise.\n \t* rtlanal.c (nonzero_bits1, canonicalize_condition): Likewise.\n-\t* expmed.c (emit_cstore, emit_store_flag_1, emit_store_flag):\n-\tLikewise.\n+\t* expmed.c (emit_cstore, emit_store_flag_1, emit_store_flag): Likewise.\n \t* rtl.h (val_mode_signbit_p, val_mode_signbit_set_p): Declare.\n \n \t* simplify-rtx.c (simplify_ternary_operation): Remove dead code.\n@@ -940,11 +926,10 @@\n 2011-07-06  Bernd Schmidt  <bernds@codesourcery.com>\n \n \t* simplify-rtx.c (simplify_const_binary_operation): Use the\n-\tshift_truncation_mask hook instead of performing modulo by\n-\twidth.  Compare against mode precision, not bitsize.\n+\tshift_truncation_mask hook instead of performing modulo by width.\n+\tCompare against mode precision, not bitsize.\n \t* combine.c (combine_simplify_rtx, simplify_shift_const_1):\n-\tUse shift_truncation_mask instead of constructing the value\n-\tmanually.\n+\tUse shift_truncation_mask instead of constructing the value manually.\n \n 2011-07-06  H.J. Lu  <hongjiu.lu@intel.com>\n \n@@ -1082,10 +1067,10 @@\n 2011-07-05  Razya Ladelsky  <razya@il.ibm.com>\n \n \tPR tree-optimization/49580\n-\t* tree-cfg.c (gimple_duplicate_sese_tail): Remove handling of \n+\t* tree-cfg.c (gimple_duplicate_sese_tail): Remove handling of\n \tthe loop's number of iterations.\n-\t* tree-parloops.c (transform_to_exit_first_loop): Add the \n-\thandling of the loop's number of iterations before the call \n+\t* tree-parloops.c (transform_to_exit_first_loop): Add the\n+\thandling of the loop's number of iterations before the call\n \tto gimple_duplicate_sese_tail.\n \tInsert the stmt caclculating the new rhs of the loop's\n \tcondition stmt to the preheader instead of iters_bb.\n@@ -1117,9 +1102,8 @@\n \t* simplify-rtx.c (simplify_unary_operation_1) <case NEG>: When\n \tnegating MULT, negate the second operand instead of first.\n \t(simplify_binary_operation_1) <case MULT>: If one operand is\n-\ta NEG and the other is MULT, don't attempt to optimize by\n-\tnegation of the MULT operand if it only moves the NEG operation\n-\taround.\n+\ta NEG and the other is MULT, don't attempt to optimize by negation\n+\tof the MULT operand if it only moves the NEG operation around.\n \n \tPR debug/49602\n \t* tree-into-ssa.c (rewrite_debug_stmt_uses): Disregard"}, {"sha": "c419c3782351a0342697eb0636779d53b4927046", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 58, "deletions": 50, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9610d205a723ac0d4cb4076dbd2d935b0077373/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9610d205a723ac0d4cb4076dbd2d935b0077373/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=f9610d205a723ac0d4cb4076dbd2d935b0077373", "patch": "@@ -22683,54 +22683,14 @@ static void\n ix86_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)\n {\n   rtx mem, fnaddr;\n+  int opcode;\n+  int offset = 0;\n \n   fnaddr = XEXP (DECL_RTL (fndecl), 0);\n \n-  if (!TARGET_64BIT)\n-    {\n-      rtx disp, chain;\n-      int opcode;\n-\n-      /* Depending on the static chain location, either load a register\n-\t with a constant, or push the constant to the stack.  All of the\n-\t instructions are the same size.  */\n-      chain = ix86_static_chain (fndecl, true);\n-      if (REG_P (chain))\n-\t{\n-\t  if (REGNO (chain) == CX_REG)\n-\t    opcode = 0xb9;\n-\t  else if (REGNO (chain) == AX_REG)\n-\t    opcode = 0xb8;\n-\t  else\n-\t    gcc_unreachable ();\n-\t}\n-      else\n-\topcode = 0x68;\n-\n-      mem = adjust_address (m_tramp, QImode, 0);\n-      emit_move_insn (mem, gen_int_mode (opcode, QImode));\n-\n-      mem = adjust_address (m_tramp, SImode, 1);\n-      emit_move_insn (mem, chain_value);\n-\n-      /* Compute offset from the end of the jmp to the target function.\n-\t In the case in which the trampoline stores the static chain on\n-\t the stack, we need to skip the first insn which pushes the\n-\t (call-saved) register static chain; this push is 1 byte.  */\n-      disp = expand_binop (SImode, sub_optab, fnaddr,\n-\t\t\t   plus_constant (XEXP (m_tramp, 0),\n-\t\t\t\t\t  MEM_P (chain) ? 9 : 10),\n-\t\t\t   NULL_RTX, 1, OPTAB_DIRECT);\n-\n-      mem = adjust_address (m_tramp, QImode, 5);\n-      emit_move_insn (mem, gen_int_mode (0xe9, QImode));\n-\n-      mem = adjust_address (m_tramp, SImode, 6);\n-      emit_move_insn (mem, disp);\n-    }\n-  else\n+  if (TARGET_64BIT)\n     {\n-      int offset = 0, size;\n+      int size;\n \n       /* Load the function address to r11.  Try to load address using\n \t the shorter movl instead of movabs.  We may want to support\n@@ -22757,20 +22717,22 @@ ix86_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)\n \t  offset += 10;\n \t}\n \n-      /* Load static chain using movabs to r10.  */\n-      mem = adjust_address (m_tramp, HImode, offset);\n-      /* Use the shorter movl instead of movabs for x32.  */\n+      /* Load static chain using movabs to r10.  Use the\n+\t shorter movl instead of movabs for x32.  */\n       if (TARGET_X32)\n \t{\n+\t  opcode = 0xba41;\n \t  size = 6;\n-\t  emit_move_insn (mem, gen_int_mode (0xba41, HImode));\n \t}\n       else\n \t{\n+\t  opcode = 0xba49;\n \t  size = 10;\n-\t  emit_move_insn (mem, gen_int_mode (0xba49, HImode));\n \t}\n \n+      mem = adjust_address (m_tramp, HImode, offset);\n+      emit_move_insn (mem, gen_int_mode (opcode, HImode));\n+\n       mem = adjust_address (m_tramp, ptr_mode, offset + 2);\n       emit_move_insn (mem, chain_value);\n       offset += size;\n@@ -22780,10 +22742,56 @@ ix86_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)\n       mem = adjust_address (m_tramp, SImode, offset);\n       emit_move_insn (mem, gen_int_mode (0x90e3ff49, SImode));\n       offset += 4;\n+    }\n+  else\n+    {\n+      rtx disp, chain;\n+\n+      /* Depending on the static chain location, either load a register\n+\t with a constant, or push the constant to the stack.  All of the\n+\t instructions are the same size.  */\n+      chain = ix86_static_chain (fndecl, true);\n+      if (REG_P (chain))\n+\t{\n+\t  switch (REGNO (chain))\n+\t    {\n+\t    case AX_REG:\n+\t      opcode = 0xb8; break;\n+\t    case CX_REG:\n+\t      opcode = 0xb9; break;\t\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n+\t}\n+      else\n+\topcode = 0x68;\n+\n+      mem = adjust_address (m_tramp, QImode, offset);\n+      emit_move_insn (mem, gen_int_mode (opcode, QImode));\n+\n+      mem = adjust_address (m_tramp, SImode, offset + 1);\n+      emit_move_insn (mem, chain_value);\n+      offset += 5;\n+\n+      mem = adjust_address (m_tramp, QImode, offset);\n+      emit_move_insn (mem, gen_int_mode (0xe9, QImode));\n+\n+      mem = adjust_address (m_tramp, SImode, offset + 1);\n \n-      gcc_assert (offset <= TRAMPOLINE_SIZE);\n+      /* Compute offset from the end of the jmp to the target function.\n+\t In the case in which the trampoline stores the static chain on\n+\t the stack, we need to skip the first insn which pushes the\n+\t (call-saved) register static chain; this push is 1 byte.  */\n+      offset += 5;\n+      disp = expand_binop (SImode, sub_optab, fnaddr,\n+\t\t\t   plus_constant (XEXP (m_tramp, 0),\n+\t\t\t\t\t  offset - (MEM_P (chain) ? 1 : 0)),\n+\t\t\t   NULL_RTX, 1, OPTAB_DIRECT);\n+      emit_move_insn (mem, disp);\n     }\n \n+  gcc_assert (offset <= TRAMPOLINE_SIZE);\n+\n #ifdef HAVE_ENABLE_EXECUTE_STACK\n #ifdef CHECK_EXECUTE_STACK_ENABLED\n   if (CHECK_EXECUTE_STACK_ENABLED)"}]}