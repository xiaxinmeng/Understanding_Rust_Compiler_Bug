{"sha": "4daa9c14297ebb5fb84a1f47510ef102f805593c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGRhYTljMTQyOTdlYmI1ZmI4NGExZjQ3NTEwZWYxMDJmODA1NTkzYw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-04-17T15:52:17Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-04-17T15:52:17Z"}, "message": "redo\n\nFrom-SVN: r19270", "tree": {"sha": "c945a8d81fa2f974ab45a111b96ee3a3401a20ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c945a8d81fa2f974ab45a111b96ee3a3401a20ba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4daa9c14297ebb5fb84a1f47510ef102f805593c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4daa9c14297ebb5fb84a1f47510ef102f805593c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4daa9c14297ebb5fb84a1f47510ef102f805593c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4daa9c14297ebb5fb84a1f47510ef102f805593c/comments", "author": null, "committer": null, "parents": [{"sha": "2702902024749f65511625ca65c0aee627d458b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2702902024749f65511625ca65c0aee627d458b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2702902024749f65511625ca65c0aee627d458b8"}], "stats": {"total": 131, "additions": 48, "deletions": 83}, "files": [{"sha": "4080a8ee6b71cebed86c2682854bd625c8493337", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 48, "deletions": 83, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4daa9c14297ebb5fb84a1f47510ef102f805593c/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4daa9c14297ebb5fb84a1f47510ef102f805593c/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=4daa9c14297ebb5fb84a1f47510ef102f805593c", "patch": "@@ -877,7 +877,10 @@ comptypes (type1, type2, strict)\n \n    NPTRS is the number of pointers we can strip off and keep cool.\n    This is used to permit (for aggr A, aggr B) A, B* to convert to A*,\n-   but to not permit B** to convert to A**.  */\n+   but to not permit B** to convert to A**.\n+\n+   This should go away.  Callers should use can_convert or something\n+   similar instead.  (jason 17 Apr 1997)  */\n \n int\n comp_target_types (ttl, ttr, nptrs)\n@@ -892,12 +895,15 @@ comp_target_types (ttl, ttr, nptrs)\n   if (TREE_CODE (ttr) != TREE_CODE (ttl))\n     return 0;\n \n-  if (TREE_CODE (ttr) == POINTER_TYPE)\n+  if (TREE_CODE (ttr) == POINTER_TYPE\n+      || (TREE_CODE (ttr) == REFERENCE_TYPE))\n     {\n+      int is_ptr = TREE_CODE (ttr) == POINTER_TYPE;\n+\n       ttl = TREE_TYPE (ttl);\n       ttr = TREE_TYPE (ttr);\n \n-      if (nptrs > 0)\n+      if (nptrs > 0 && is_ptr)\n \t{\n \t  if (TREE_CODE (ttl) == UNKNOWN_TYPE\n \t      || TREE_CODE (ttr) == UNKNOWN_TYPE)\n@@ -949,27 +955,23 @@ comp_target_types (ttl, ttr, nptrs)\n       }\n     }\n \n-  if (TREE_CODE (ttr) == REFERENCE_TYPE)\n-    return comp_target_types (TREE_TYPE (ttl), TREE_TYPE (ttr), nptrs);\n   if (TREE_CODE (ttr) == ARRAY_TYPE)\n     return comp_array_types (comp_target_types, ttl, ttr, 0);\n   else if (TREE_CODE (ttr) == FUNCTION_TYPE || TREE_CODE (ttr) == METHOD_TYPE)\n     {\n-      if (comp_target_types (TREE_TYPE (ttl), TREE_TYPE (ttr), -1))\n-\tswitch (comp_target_parms (TYPE_ARG_TYPES (ttl),\n-\t\t\t\t   TYPE_ARG_TYPES (ttr), 1))\n-\t  {\n-\t  case 0:\n+      if (pedantic)\n+\t{\n+\t  if (comptypes (TREE_TYPE (ttl), TREE_TYPE (ttr), 1) == 0)\n \t    return 0;\n-\t  case 1:\n-\t    return 1;\n-\t  case 2:\n-\t    return -1;\n-\t  default:\n-\t    my_friendly_abort (112);\n-\t  }\n+\t}\n       else\n-\treturn 0;\n+\t{\n+\t  if (comp_target_types (TREE_TYPE (ttl), TREE_TYPE (ttr), -1) == 0)\n+\t    return 0;\n+\t}\n+\n+      return comp_target_parms (TYPE_ARG_TYPES (ttl),\n+\t\t\t\tTYPE_ARG_TYPES (ttr), 1);\n     }\n   /* for C++ */\n   else if (TREE_CODE (ttr) == OFFSET_TYPE)\n@@ -1059,9 +1061,9 @@ common_base_type (tt1, tt2)\n    If either list is empty, we win.\n    Otherwise, the two lists must be equivalent, element by element.\n \n-   C++: See comment above about TYPE1, TYPE2, STRICT.\n-   If STRICT == 3, it means checking is strict, but do not compare\n-   default parameter values.  */\n+   C++: See comment above about TYPE1, TYPE2.\n+\n+   STRICT is no longer used.  */\n \n int\n compparms (parms1, parms2, strict)\n@@ -1073,42 +1075,30 @@ compparms (parms1, parms2, strict)\n   /* An unspecified parmlist matches any specified parmlist\n      whose argument types don't need default promotions.  */\n \n-  if (strict <= 0 && t1 == 0)\n-\treturn self_promoting_args_p (t2);\n-  if (strict < 0 && t2 == 0)\n-\treturn self_promoting_args_p (t1);\n-\n   while (1)\n     {\n       if (t1 == 0 && t2 == 0)\n \treturn 1;\n       /* If one parmlist is shorter than the other,\n-\t they fail to match, unless STRICT is <= 0.  */\n+\t they fail to match.  */\n       if (t1 == 0 || t2 == 0)\n-\t{\n-\t  if (strict > 0)\n-\t    return 0;\n-\t  if (strict < 0)\n-\t    return 1;\n-\t  if (strict == 0)\n-\t    return t1 && TREE_PURPOSE (t1);\n-\t}\n-      if (! comptypes (TREE_VALUE (t2), TREE_VALUE (t1), strict))\n-\t{\n-\t  if (strict > 0)\n-\t    return 0;\n-\t  if (strict == 0)\n-\t    return t2 == void_list_node && TREE_PURPOSE (t1);\n-\t  return TREE_PURPOSE (t1) || TREE_PURPOSE (t2);\n-\t}\n+\treturn 0;\n+      if (! comptypes (TREE_VALUE (t2), TREE_VALUE (t1), 1))\n+\treturn 0;\n \n       t1 = TREE_CHAIN (t1);\n       t2 = TREE_CHAIN (t2);\n     }\n }\n \n /* This really wants return whether or not parameter type lists\n-   would make their owning functions assignment compatible or not.  */\n+   would make their owning functions assignment compatible or not.\n+\n+   The return value is like for comp_target_types.\n+\n+   This should go away, possibly with the exception of the empty parmlist\n+   conversion; there are no conversions between function types in C++.\n+   (jason 17 Apr 1997)  */\n \n static int\n comp_target_parms (parms1, parms2, strict)\n@@ -1118,9 +1108,9 @@ comp_target_parms (parms1, parms2, strict)\n   register tree t1 = parms1, t2 = parms2;\n   int warn_contravariance = 0;\n \n-  /* An unspecified parmlist matches any specified parmlist\n-     whose argument types don't need default promotions.\n-     @@@ see 13.3.3 for a counterexample...  */\n+  /* In C, an unspecified parmlist matches any specified parmlist\n+     whose argument types don't need default promotions.  This is not\n+     true for C++, but let's do it anyway for unfixed headers.  */\n \n   if (t1 == 0 && t2 != 0)\n     {\n@@ -1147,9 +1137,12 @@ comp_target_parms (parms1, parms2, strict)\n \t}\n       p1 = TREE_VALUE (t1);\n       p2 = TREE_VALUE (t2);\n-      if (p1 == p2)\n+      if (comptypes (p1, p2, 1))\n \tcontinue;\n \n+      if (pedantic)\n+\treturn 0;\n+\n       if ((TREE_CODE (p1) == POINTER_TYPE && TREE_CODE (p2) == POINTER_TYPE)\n \t  || (TREE_CODE (p1) == REFERENCE_TYPE\n \t      && TREE_CODE (p2) == REFERENCE_TYPE))\n@@ -1170,52 +1163,24 @@ comp_target_parms (parms1, parms2, strict)\n \t    }\n \t  if (IS_AGGR_TYPE (TREE_TYPE (p1)))\n \t    {\n-\t      if (comptypes (p2, p1, 0) == 0)\n-\t\t{\n-\t\t  if (comptypes (p1, p2, 0) != 0)\n-\t\t    warn_contravariance = 1;\n-\t\t  else\n-\t\t    return 0;\n-\t\t}\n-\t      continue;\n+\t      if (comptypes (TYPE_MAIN_VARIANT (TREE_TYPE (p1)),\n+\t\t\t     TYPE_MAIN_VARIANT (TREE_TYPE (p2)), 1) == 0)\n+\t\treturn 0;\n \t    }\n \t}\n       /* Note backwards order due to contravariance.  */\n-      if (comp_target_types (p2, p1, 1) == 0)\n+      if (comp_target_types (p2, p1, 1) <= 0)\n \t{\n-\t  if (comp_target_types (p1, p2, 1))\n+\t  if (comp_target_types (p1, p2, 1) > 0)\n \t    {\n \t      warn_contravariance = 1;\n \t      continue;\n \t    }\n \t  if (strict != 0)\n \t    return 0;\n \t}\n-      /* Target types are compatible--just make sure that if\n-\t we use parameter lists, that they are ok as well.  */\n-      if (TREE_CODE (p1) == FUNCTION_TYPE || TREE_CODE (p1) == METHOD_TYPE)\n-\tswitch (comp_target_parms (TYPE_ARG_TYPES (p1),\n-\t\t\t\t   TYPE_ARG_TYPES (p2),\n-\t\t\t\t   strict))\n-\t  {\n-\t  case 0:\n-\t    return 0;\n-\t  case 1:\n-\t    break;\n-\t  case 2:\n-\t    warn_contravariance = 1;\n-\t  }\n-\n-      if (TREE_PURPOSE (t1) && TREE_PURPOSE (t2))\n-\t{\n-\t  int cmp = simple_cst_equal (TREE_PURPOSE (t1), TREE_PURPOSE (t2));\n-\t  if (cmp < 0)\n-\t    my_friendly_abort (114);\n-\t  if (cmp == 0)\n-\t    return 0;\n-\t}\n     }\n-  return 1 + warn_contravariance;\n+  return warn_contravariance ? -1 : 1;\n }\n \n /* Return 1 if PARMS specifies a fixed number of parameters\n@@ -6876,7 +6841,7 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n     {\n       tree ttl = TYPE_PTRMEMFUNC_FN_TYPE (type);\n       tree ttr = (TREE_CODE (rhstype) == POINTER_TYPE ? rhstype\n-\t\t    : TYPE_PTRMEMFUNC_FN_TYPE (type));\n+\t\t  : TYPE_PTRMEMFUNC_FN_TYPE (rhstype));\n       int ctt = comp_target_types (ttl, ttr, 1);\n \n       if (ctt < 0)"}]}