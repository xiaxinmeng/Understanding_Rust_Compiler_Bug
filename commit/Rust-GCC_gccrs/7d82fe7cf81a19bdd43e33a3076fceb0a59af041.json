{"sha": "7d82fe7cf81a19bdd43e33a3076fceb0a59af041", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2Q4MmZlN2NmODFhMTliZGQ0M2UzM2EzMDc2ZmNlYjBhNTlhZjA0MQ==", "commit": {"author": {"name": "Kelley Cook", "email": "kelleycook@wideopenwest.com", "date": "2003-09-26T00:14:28Z"}, "committer": {"name": "R. Kelley Cook", "email": "kcook@gcc.gnu.org", "date": "2003-09-26T00:14:28Z"}, "message": "cgraph.c (dump_cgraph): Don't output newline before dump.\n\n2003-09-23  Kelley Cook  <kelleycook@wideopenwest.com>\n\n\t* cgraph.c (dump_cgraph):  Don't output newline before dump.  Add in\n\t\"local\" to the callgraph dump.  Output \"after inlining\" earlier.\n\t* cgraphunit.c: Fix dumpfile whitespace and commonize headers of the\n\tcallgraph dumps.  Correct misspellings.\n\t(cgraph_decide_inlining):  Output number of insns before inlining.\n\tOutput the calling function into which a function is inlined.\n\t(cgraph_decide_small_functions): Format dump file like always_inline.\n\nFrom-SVN: r71804", "tree": {"sha": "9c0bb7257cbd0e4289f45ea4902f676279aa5517", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9c0bb7257cbd0e4289f45ea4902f676279aa5517"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7d82fe7cf81a19bdd43e33a3076fceb0a59af041", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d82fe7cf81a19bdd43e33a3076fceb0a59af041", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d82fe7cf81a19bdd43e33a3076fceb0a59af041", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d82fe7cf81a19bdd43e33a3076fceb0a59af041/comments", "author": null, "committer": null, "parents": [{"sha": "c73f02bef2bbfbad114bb0b2284cae9eb23b81e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c73f02bef2bbfbad114bb0b2284cae9eb23b81e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c73f02bef2bbfbad114bb0b2284cae9eb23b81e5"}], "stats": {"total": 138, "additions": 94, "deletions": 44}, "files": [{"sha": "844cb297b41ab959b876fcaf98bd9f950aaac067", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d82fe7cf81a19bdd43e33a3076fceb0a59af041/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d82fe7cf81a19bdd43e33a3076fceb0a59af041/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7d82fe7cf81a19bdd43e33a3076fceb0a59af041", "patch": "@@ -1,3 +1,13 @@\n+2003-09-25  Kelley Cook  <kelleycook@wideopenwest.com>\n+\n+\t* cgraph.c (dump_cgraph):  Don't output newline before dump.  Add in\n+\t\"local\" to the callgraph dump.  Output \"after inlining\" earlier.\n+\t* cgraphunit.c: Fix dumpfile whitespace and commonize headers of the\n+\tcallgraph dumps.  Correct misspellings.\n+\t(cgraph_decide_inlining):  Output number of insns before inlining.\n+\tOutput the calling function into which a function is inlined.\n+\t(cgraph_decide_small_functions): Format dump file like always_inline.\n+\n 2003-09-25  Loren James Rittle  <ljrittle@acm.org>\n \n \t* config/i386/i386.h (ix86_return_in_memory): Add prototype."}, {"sha": "108cdfc7b9bd4874f972e9ebe8f962aa6f25cecd", "filename": "gcc/cgraph.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d82fe7cf81a19bdd43e33a3076fceb0a59af041/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d82fe7cf81a19bdd43e33a3076fceb0a59af041/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=7d82fe7cf81a19bdd43e33a3076fceb0a59af041", "patch": "@@ -350,13 +350,15 @@ dump_cgraph (FILE *f)\n {\n   struct cgraph_node *node;\n \n-  fprintf (f, \"\\nCallgraph:\\n\\n\");\n+  fprintf (f, \"callgraph:\\n\\n\");\n   for (node = cgraph_nodes; node; node = node->next)\n     {\n       struct cgraph_edge *edge;\n-      fprintf (f, \"%s\", cgraph_node_name (node));\n+      fprintf (f, \"%s:\", cgraph_node_name (node));\n       if (node->local.self_insns)\n         fprintf (f, \" %i insns\", node->local.self_insns);\n+      if (node->global.insns && node->global.insns != node->local.self_insns)\n+\tfprintf (f, \" (%i after inlining)\", node->global.insns);\n       if (node->origin)\n \tfprintf (f, \" nested in: %s\", cgraph_node_name (node->origin));\n       if (node->needed)\n@@ -366,12 +368,12 @@ dump_cgraph (FILE *f)\n       if (DECL_SAVED_TREE (node->decl))\n \tfprintf (f, \" tree\");\n \n+      if (node->local.local)\n+\tfprintf (f, \" local\");\n       if (node->local.disregard_inline_limits)\n \tfprintf (f, \" always_inline\");\n       else if (node->local.inlinable)\n \tfprintf (f, \" inlinable\");\n-      if (node->global.insns && node->global.insns != node->local.self_insns)\n-\tfprintf (f, \" %i insns after inlining\", node->global.insns);\n       if (node->global.cloned_times > 1)\n \tfprintf (f, \" cloned %ix\", node->global.cloned_times);\n "}, {"sha": "15e3ebb8fcdedc3e19e66b6614ea5e875447c53c", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 78, "deletions": 40, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d82fe7cf81a19bdd43e33a3076fceb0a59af041/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d82fe7cf81a19bdd43e33a3076fceb0a59af041/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=7d82fe7cf81a19bdd43e33a3076fceb0a59af041", "patch": "@@ -112,7 +112,7 @@ decide_is_function_needed (struct cgraph_node *node, tree decl)\n   if (!DECL_INLINE (decl)\n       || (!node->local.disregard_inline_limits\n \t  /* When declared inline, defer even the uninlinable functions.\n-\t     This allows them to be elliminated when unused.  */\n+\t     This allows them to be eliminated when unused.  */\n \t  && !DECL_DECLARED_INLINE_P (decl) \n \t  && (node->local.inlinable || !cgraph_default_inline_p (node))))\n     return true;\n@@ -354,7 +354,7 @@ cgraph_finalize_compilation_unit (void)\n   timevar_push (TV_CGRAPH);\n   if (cgraph_dump_file)\n     {\n-      fprintf (cgraph_dump_file, \"\\nInitial entry points:\");\n+      fprintf (cgraph_dump_file, \"Initial entry points:\");\n       for (node = cgraph_nodes; node; node = node->next)\n \tif (node->needed && DECL_SAVED_TREE (node->decl))\n \t  fprintf (cgraph_dump_file, \" %s\", cgraph_node_name (node));\n@@ -395,11 +395,11 @@ cgraph_finalize_compilation_unit (void)\n \n   if (cgraph_dump_file)\n     {\n-      fprintf (cgraph_dump_file, \"\\nUnit entry points:\");\n+      fprintf (cgraph_dump_file, \"Unit entry points:\");\n       for (node = cgraph_nodes; node; node = node->next)\n \tif (node->needed && DECL_SAVED_TREE (node->decl))\n \t  fprintf (cgraph_dump_file, \" %s\", cgraph_node_name (node));\n-      fprintf (cgraph_dump_file, \"\\n\");\n+      fprintf (cgraph_dump_file, \"\\n\\nInitial \");\n       dump_cgraph (cgraph_dump_file);\n     }\n \n@@ -418,7 +418,10 @@ cgraph_finalize_compilation_unit (void)\n \t}\n     }\n   if (cgraph_dump_file)\n-    fprintf (cgraph_dump_file, \"\\n\");\n+    {\n+      fprintf (cgraph_dump_file, \"\\n\\nReclaimed \");\n+      dump_cgraph (cgraph_dump_file);\n+    }\n   ggc_collect ();\n   timevar_pop (TV_CGRAPH);\n }\n@@ -657,7 +660,7 @@ cgraph_inlined_into (struct cgraph_node *node, struct cgraph_node **array)\n \n   if (cgraph_dump_file)\n     {\n-      fprintf (cgraph_dump_file, \"Found inline predecesors of %s:\",\n+      fprintf (cgraph_dump_file, \" Found inline predecesors of %s:\",\n \t       cgraph_node_name (node));\n       for (i = 0; i < nfound; i++)\n \t{\n@@ -754,7 +757,7 @@ cgraph_inlined_callees (struct cgraph_node *node, struct cgraph_node **array)\n \n   if (cgraph_dump_file)\n     {\n-      fprintf (cgraph_dump_file, \"Found inline successors of %s:\",\n+      fprintf (cgraph_dump_file, \" Found inline successors of %s:\",\n \t       cgraph_node_name (node));\n       for (i = 0; i < nfound; i++)\n \t{\n@@ -775,7 +778,7 @@ static int\n cgraph_estimate_size_after_inlining (int times, struct cgraph_node *to,\n \t\t\t\t     struct cgraph_node *what)\n {\n-  return (what->global.insns - INSNS_PER_CALL) *times + to->global.insns;\n+  return (what->global.insns - INSNS_PER_CALL) * times + to->global.insns;\n }\n \n /* Estimate the growth caused by inlining NODE into all callees.  */\n@@ -919,7 +922,7 @@ cgraph_check_inline_limits (struct cgraph_node *to, struct cgraph_node *what,\n   return true;\n }\n \n-/* Return true when function N is small enought to be inlined.  */\n+/* Return true when function N is small enough to be inlined.  */\n \n static bool\n cgraph_default_inline_p (struct cgraph_node *n)\n@@ -973,21 +976,23 @@ cgraph_decide_inlining_of_small_functions (struct cgraph_node **inlined,\n     }\n \n   if (cgraph_dump_file)\n-    fprintf (cgraph_dump_file, \"\\n\\nDeciding on inlining: \");\n+    fprintf (cgraph_dump_file, \"\\nDeciding on smaller functions:\\n\");\n   while ((node = fibheap_extract_min (heap)) && overall_insns <= max_insns)\n     {\n       struct cgraph_edge *e;\n       int old_insns = overall_insns;\n \n       heap_node[node->uid] = NULL;\n       if (cgraph_dump_file)\n-\tfprintf (cgraph_dump_file, \"Considering %s %i insns, growth %i.\\n\",\n+\tfprintf (cgraph_dump_file, \n+\t\t \"\\nConsidering %s with %i insns\\n\"\n+\t\t \" Estimated growth is %+i insns.\\n\",\n \t\t cgraph_node_name (node), node->global.insns,\n \t\t cgraph_estimate_growth (node));\n       if (!cgraph_default_inline_p (node))\n \t{\n \t  if (cgraph_dump_file)\n-\t    fprintf (cgraph_dump_file, \"Function too large.\\n\");\n+\t    fprintf (cgraph_dump_file, \" Function too large.\\n\");\n \t  continue;\n \t}\n       ninlined_callees = cgraph_inlined_callees (node, inlined_callees);\n@@ -1002,7 +1007,7 @@ cgraph_decide_inlining_of_small_functions (struct cgraph_node **inlined,\n \t\tfor (i = 0; i < ninlined; i++)\n \t\t  inlined[i]->output = 0, node->aux = 0;\n \t\tif (cgraph_dump_file)\n-\t\t  fprintf (cgraph_dump_file, \"Not inlining into %s\\n\",\n+\t\t  fprintf (cgraph_dump_file, \" Not inlining into %s.\\n\",\n \t\t\t   cgraph_node_name (e->caller));\n \t\tcontinue;\n \t      }\n@@ -1021,9 +1026,15 @@ cgraph_decide_inlining_of_small_functions (struct cgraph_node **inlined,\n \t\t  fibheap_replace_key (heap, heap_node[inlined[i]->uid],\n \t\t\t\t       cgraph_estimate_growth (inlined[i]));\n \t      }\n+\tif (cgraph_dump_file)\n+\t  fprintf (cgraph_dump_file, \n+\t\t   \" Inlined into %s which now has %i insns.\\n\",\n+\t\t   cgraph_node_name (e->caller),\n+\t\t   e->caller->global.insns);\n+\n \t  }\n \n-      /* Similarly all functions called by function we just inlined\n+      /* Similarly all functions called by the function we just inlined\n          are now called more times; update keys.  */\n \n       for (e = node->callees; e; e = e->next_callee)\n@@ -1043,14 +1054,12 @@ cgraph_decide_inlining_of_small_functions (struct cgraph_node **inlined,\n \t  inlined_callees[i]->output = 0, node->aux = 0;\n \t}\n       if (cgraph_dump_file)\n-\tfprintf (cgraph_dump_file,\n-\t\t \"Created %i clones, Num insns:%i (%+i), %.2f%%.\\n\\n\",\n-\t\t node->global.cloned_times - 1,\n-\t\t overall_insns, overall_insns - old_insns,\n-\t\t overall_insns * 100.0 / initial_insns);\n+\tfprintf (cgraph_dump_file, \n+\t\t \" Inlined %i times for a net change of %+i insns.\\n\",\n+\t\t node->global.cloned_times, overall_insns - old_insns);\n     }\n   if (cgraph_dump_file && !fibheap_empty (heap))\n-    fprintf (cgraph_dump_file, \"inline-unit-growth limit reached.\\n\");\n+    fprintf (cgraph_dump_file, \"\\nReached the inline-unit-growth limit.\\n\");\n   fibheap_delete (heap);\n   free (heap_node);\n }\n@@ -1071,6 +1080,7 @@ cgraph_decide_inlining (void)\n     xcalloc (cgraph_n_nodes, sizeof (struct cgraph_node *));\n   int ninlined;\n   int ninlined_callees;\n+  int old_insns;\n   int i, y;\n \n   for (node = cgraph_nodes; node; node = node->next)\n@@ -1079,14 +1089,19 @@ cgraph_decide_inlining (void)\n \n   nnodes = cgraph_postorder (order);\n \n+  if (cgraph_dump_file)\n+    fprintf (cgraph_dump_file,\n+\t     \"\\nDeciding on inlining.  Starting with %i insns.\\n\",\n+\t     initial_insns);\n+\n   for (node = cgraph_nodes; node; node = node->next)\n     node->aux = 0;\n \n   if (cgraph_dump_file)\n-    fprintf (cgraph_dump_file, \"\\n\\nDeciding on always_inline functions:\\n\");\n+    fprintf (cgraph_dump_file, \"\\nInlining always_inline functions:\\n\");\n \n   /* In the first pass mark all always_inline edges.  Do this with a priority\n-     so no our decisions makes this impossible.  */\n+     so none of our later choices will make this impossible.  */\n   for (i = nnodes - 1; i >= 0; i--)\n     {\n       struct cgraph_edge *e;\n@@ -1100,11 +1115,12 @@ cgraph_decide_inlining (void)\n \tcontinue;\n       if (cgraph_dump_file)\n \tfprintf (cgraph_dump_file,\n-\t\t \"Considering %s %i insns (always inline)\\n\",\n-\t\t cgraph_node_name (node), node->global.insns);\n+\t\t \"\\nConsidering %s %i insns (always inline)\\n\",\n+\t\t cgraph_node_name (e->callee), e->callee->global.insns);\n       ninlined = cgraph_inlined_into (order[i], inlined);\n       for (; e; e = e->next_callee)\n \t{\n+\t  old_insns = overall_insns;\n \t  if (e->inline_call || !e->callee->local.disregard_inline_limits)\n \t    continue;\n \t  if (e->callee->output || e->callee == node)\n@@ -1116,17 +1132,23 @@ cgraph_decide_inlining (void)\n \t  for (y = 0; y < ninlined_callees; y++)\n \t    inlined_callees[y]->output = 0, node->aux = 0;\n \t  if (cgraph_dump_file)\n-\t    fprintf (cgraph_dump_file, \"Inlined %i times. Now %i insns\\n\\n\",\n-\t\t     node->global.cloned_times, overall_insns);\n+\t    fprintf (cgraph_dump_file, \n+\t\t     \" Inlined into %s which now has %i insns.\\n\",\n+\t\t     cgraph_node_name (node->callees->caller),\n+\t             node->callees->caller->global.insns);\n \t}\n+\tif (cgraph_dump_file && node->global.cloned_times > 0)\n+\t  fprintf (cgraph_dump_file, \n+\t\t   \" Inlined %i times for a net change of %+i insns.\\n\",\n+\t\t   node->global.cloned_times, overall_insns - old_insns);\n       for (y = 0; y < ninlined; y++)\n \tinlined[y]->output = 0, node->aux = 0;\n     }\n \n   cgraph_decide_inlining_of_small_functions (inlined, inlined_callees);\n \n   if (cgraph_dump_file)\n-    fprintf (cgraph_dump_file, \"\\n\\nFunctions to inline once:\\n\");\n+    fprintf (cgraph_dump_file, \"\\nDeciding on functions called once:\\n\");\n \n   /* And finally decide what functions are called once.  */\n \n@@ -1151,9 +1173,13 @@ cgraph_decide_inlining (void)\n \t    {\n \t      if (cgraph_dump_file)\n \t\tfprintf (cgraph_dump_file,\n-\t\t\t \"Considering %s %i insns (called once)\\n\",\n-\t\t\t cgraph_node_name (node), node->global.insns);\n+\t\t\t \"\\nConsidering %s %i insns.\\n\"\n+\t\t\t \" Called once from %s %i insns.\\n\",\n+\t\t\t cgraph_node_name (node), node->global.insns,\n+\t\t\t cgraph_node_name (node->callers->caller),\n+\t\t\t node->callers->caller->global.insns);\n \t      ninlined = cgraph_inlined_into (node->callers->caller, inlined);\n+\t      old_insns = overall_insns;\n \t      if (cgraph_check_inline_limits\n \t\t  (node->callers->caller, node, inlined, ninlined))\n \t\t{\n@@ -1165,8 +1191,19 @@ cgraph_decide_inlining (void)\n \t\t  for (y = 0; y < ninlined_callees; y++)\n \t\t    inlined_callees[y]->output = 0, node->aux = 0;\n \t\t  if (cgraph_dump_file)\n-\t\t    fprintf (cgraph_dump_file, \"Inlined. Now %i insns\\n\\n\", overall_insns);\n+\t\t    fprintf (cgraph_dump_file,\n+\t\t\t     \" Inlined into %s which now has %i insns\"\n+\t\t\t     \" for a net change of %+i insns.\\n\",\n+\t\t\t     cgraph_node_name (node->callers->caller),\n+\t\t\t     node->callers->caller->global.insns,\n+\t\t\t     overall_insns - old_insns);\n \t\t}\n+\t      else\n+                {\n+\t\t  if (cgraph_dump_file)\n+\t\t    fprintf (cgraph_dump_file,\n+\t                     \" Inline limit reached, not inlined.\\n\");\n+\t        }\n \t      for (y = 0; y < ninlined; y++)\n \t\tinlined[y]->output = 0, node->aux = 0;\n \t    }\n@@ -1175,7 +1212,8 @@ cgraph_decide_inlining (void)\n \n   if (cgraph_dump_file)\n     fprintf (cgraph_dump_file,\n-\t     \"\\nInlined %i calls, elliminated %i functions, %i insns turned to %i insns.\\n\",\n+\t     \"\\nInlined %i calls, eliminated %i functions, \"\n+\t     \"%i insns turned to %i insns.\\n\\n\",\n \t     ncalls_inlined, nfunctions_inlined, initial_insns,\n \t     overall_insns);\n   free (order);\n@@ -1250,7 +1288,7 @@ cgraph_mark_local_functions (void)\n   struct cgraph_node *node;\n \n   if (cgraph_dump_file)\n-    fprintf (cgraph_dump_file, \"Marking local functions:\");\n+    fprintf (cgraph_dump_file, \"\\nMarking local functions:\");\n \n   /* Figure out functions we want to assemble.  */\n   for (node = cgraph_nodes; node; node = node->next)\n@@ -1262,7 +1300,7 @@ cgraph_mark_local_functions (void)\n \tfprintf (cgraph_dump_file, \" %s\", cgraph_node_name (node));\n     }\n   if (cgraph_dump_file)\n-    fprintf (cgraph_dump_file, \"\\n\");\n+    fprintf (cgraph_dump_file, \"\\n\\n\");\n }\n \n /* Perform simple optimizations based on callgraph.  */\n@@ -1275,30 +1313,30 @@ cgraph_optimize (void)\n   timevar_push (TV_CGRAPHOPT);\n   if (!quiet_flag)\n     fprintf (stderr, \"Performing intraprocedural optimizations\\n\");\n+\n+  cgraph_mark_local_functions ();\n   if (cgraph_dump_file)\n     {\n-      fprintf (cgraph_dump_file, \"Initial callgraph:\");\n+      fprintf (cgraph_dump_file, \"Marked \");\n       dump_cgraph (cgraph_dump_file);\n     }\n-  cgraph_mark_local_functions ();\n \n   cgraph_decide_inlining ();\n-\n   cgraph_global_info_ready = true;\n   if (cgraph_dump_file)\n     {\n-      fprintf (cgraph_dump_file, \"Optimized callgraph:\");\n+      fprintf (cgraph_dump_file, \"Optimized \");\n       dump_cgraph (cgraph_dump_file);\n     }\n   timevar_pop (TV_CGRAPHOPT);\n-  if (!quiet_flag)\n-    fprintf (stderr, \"Assembling functions:\");\n \n   /* Output everything.  */\n+  if (!quiet_flag)\n+    fprintf (stderr, \"Assembling functions:\\n\");\n   cgraph_expand_all_functions ();\n   if (cgraph_dump_file)\n     {\n-      fprintf (cgraph_dump_file, \"Final callgraph:\");\n+      fprintf (cgraph_dump_file, \"\\nFinal \");\n       dump_cgraph (cgraph_dump_file);\n     }\n }"}]}