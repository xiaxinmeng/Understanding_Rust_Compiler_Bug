{"sha": "840ceb345b02d8f883b740949984878c9ed6f18e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODQwY2ViMzQ1YjAyZDhmODgzYjc0MDk0OTk4NDg3OGM5ZWQ2ZjE4ZQ==", "commit": {"author": {"name": "Phil Edwards", "email": "pme@gcc.gnu.org", "date": "2002-11-21T07:06:41Z"}, "committer": {"name": "Phil Edwards", "email": "pme@gcc.gnu.org", "date": "2002-11-21T07:06:41Z"}, "message": "TODO: Note change in clause 27 docs.\n\n2002-11-21  Phil Edwards  <pme@gcc.gnu.org>\n\n\t* docs/doxygen/TODO:  Note change in clause 27 docs.\n\t* include/bits/basic_ios.h, include/bits/fpos.h,\n\tinclude/bits/ios_base.h, include/bits/stl_deque.h,\n\tinclude/bits/stl_iterator_base_types.h, include/std/std_fstream.h,\n\tinclude/std/std_iomanip.h, include/std/std_iosfwd.h,\n\tinclude/std/std_iostream.h, include/std/std_istream.h,\n\tinclude/std/std_ostream.h, include/std/std_sstream.h,\n\tinclude/std/std_streambuf.h:  Doxygenate all I/O entities.\n\nFrom-SVN: r59325", "tree": {"sha": "2b1a8da9a0c1528bf18c344aaa22f845817bfb4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2b1a8da9a0c1528bf18c344aaa22f845817bfb4b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/840ceb345b02d8f883b740949984878c9ed6f18e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/840ceb345b02d8f883b740949984878c9ed6f18e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/840ceb345b02d8f883b740949984878c9ed6f18e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/840ceb345b02d8f883b740949984878c9ed6f18e/comments", "author": null, "committer": null, "parents": [{"sha": "02f0f531d49fc0c0d6b91692fe49b23a0cc9e2bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02f0f531d49fc0c0d6b91692fe49b23a0cc9e2bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02f0f531d49fc0c0d6b91692fe49b23a0cc9e2bf"}], "stats": {"total": 2682, "additions": 2477, "deletions": 205}, "files": [{"sha": "48118781e58b1d9e4018254ada763d59e142691f", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/840ceb345b02d8f883b740949984878c9ed6f18e/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/840ceb345b02d8f883b740949984878c9ed6f18e/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=840ceb345b02d8f883b740949984878c9ed6f18e", "patch": "@@ -1,3 +1,14 @@\n+2002-11-21  Phil Edwards  <pme@gcc.gnu.org>\n+\n+\t* docs/doxygen/TODO:  Note change in clause 27 docs.\n+\t* include/bits/basic_ios.h, include/bits/fpos.h,\n+\tinclude/bits/ios_base.h, include/bits/stl_deque.h,\n+\tinclude/bits/stl_iterator_base_types.h, include/std/std_fstream.h,\n+\tinclude/std/std_iomanip.h, include/std/std_iosfwd.h,\n+\tinclude/std/std_iostream.h, include/std/std_istream.h,\n+\tinclude/std/std_ostream.h, include/std/std_sstream.h,\n+\tinclude/std/std_streambuf.h:  Doxygenate all I/O entities.\n+\n 2002-11-20  Benjamin Kosnik  <bkoz@redhat.com>\n             Jonathan Lennox  <lennox@cs.columbia.edu>\n "}, {"sha": "0b6e3d6c00b91d22a8e06528e8227a238b527a8a", "filename": "libstdc++-v3/docs/doxygen/TODO", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/840ceb345b02d8f883b740949984878c9ed6f18e/libstdc%2B%2B-v3%2Fdocs%2Fdoxygen%2FTODO", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/840ceb345b02d8f883b740949984878c9ed6f18e/libstdc%2B%2B-v3%2Fdocs%2Fdoxygen%2FTODO", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fdoxygen%2FTODO?ref=840ceb345b02d8f883b740949984878c9ed6f18e", "patch": "@@ -31,7 +31,11 @@ c24             stl_iterator.h (__normal_iterator, other small TODO bits)\n                 stream iterators\n c25             stl_algo.h (lots of stuff)\n c26             <complex>, <valarray>, stl_numeric.h[26.4], Note A\n-c27             Untouched\n+c27             ios_base callbacks and local storage\n+                basic_ios::copyfmt()\n+                std_streambuf.h's __copy_streambufs()\n+                    \" \"           _M_* protected memfns (data has been done)\n+                fstream and sstream protected members\n \n backward/*      Not scanned by doxygen.  Should it be?  Doubtful.\n "}, {"sha": "b6ef89ba8b0938641cf978bf2c8582e5f924b32a", "filename": "libstdc++-v3/include/bits/basic_ios.h", "status": "modified", "additions": 257, "deletions": 26, "changes": 283, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/840ceb345b02d8f883b740949984878c9ed6f18e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_ios.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/840ceb345b02d8f883b740949984878c9ed6f18e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_ios.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_ios.h?ref=840ceb345b02d8f883b740949984878c9ed6f18e", "patch": "@@ -43,115 +43,282 @@\n namespace std \n {\n   // 27.4.5  Template class basic_ios\n+  /**\n+   *  @brief  Virtual base class for all stream classes.\n+   *\n+   *  Most of the member functions called dispatched on stream objects\n+   *  (e.g., @c std::cout.foo(bar);) are consolidated in this class.\n+  */\n   template<typename _CharT, typename _Traits>\n     class basic_ios : public ios_base\n     {\n     public:\n-      // Types:\n-      typedef _CharT \t\t\t\tchar_type;\n-      typedef typename _Traits::int_type \tint_type;\n-      typedef typename _Traits::pos_type \tpos_type;\n-      typedef typename _Traits::off_type \toff_type;\n-      typedef _Traits \t\t\t\ttraits_type;\n-\n-      // Non-standard Types:\n-      typedef ctype<_CharT>           \t\t\t__ctype_type;\n-      typedef ostreambuf_iterator<_CharT, _Traits>      __ostreambuf_iter;\n-      typedef num_put<_CharT, __ostreambuf_iter>        __numput_type;\n-      typedef istreambuf_iterator<_CharT, _Traits>\t__istreambuf_iter;\n-      typedef num_get<_CharT, __istreambuf_iter>        __numget_type;\n+      //@{\n+      /**\n+       *  These are standard types.  They permit a standardized way of\n+       *  referring to names of (or names dependant on) the template\n+       *  parameters, which are specific to the implementation.\n+      */\n+      typedef _CharT                                 char_type;\n+      typedef typename _Traits::int_type             int_type;\n+      typedef typename _Traits::pos_type             pos_type;\n+      typedef typename _Traits::off_type             off_type;\n+      typedef _Traits                                traits_type;\n+      //@}\n+\n+      //@{\n+      /**\n+       *  @if maint\n+       *  These are non-standard types.\n+       *  @endif\n+      */\n+      typedef ctype<_CharT>                          __ctype_type;\n+      typedef ostreambuf_iterator<_CharT, _Traits>   __ostreambuf_iter;\n+      typedef num_put<_CharT, __ostreambuf_iter>     __numput_type;\n+      typedef istreambuf_iterator<_CharT, _Traits>   __istreambuf_iter;\n+      typedef num_get<_CharT, __istreambuf_iter>     __numget_type;\n+      //@}\n       \n       // Data members:\n     protected:\n-      basic_ostream<_CharT, _Traits>* \t_M_tie;\n-      mutable char_type \t\t_M_fill;\n-      mutable bool\t\t\t_M_fill_init;\n-      basic_streambuf<_CharT, _Traits>* _M_streambuf;\n+      basic_ostream<_CharT, _Traits>*                _M_tie;\n+      mutable char_type                              _M_fill;\n+      mutable bool                                   _M_fill_init;\n+      basic_streambuf<_CharT, _Traits>*              _M_streambuf;\n \n       // Cached use_facet<ctype>, which is based on the current locale info.\n-      const __ctype_type*\t\t_M_fctype;      \n+      const __ctype_type*                            _M_fctype;      \n       // From ostream.\n-      const __numput_type* \t\t_M_fnumput;\n+      const __numput_type*                           _M_fnumput;\n       // From istream.\n-      const __numget_type* \t\t_M_fnumget;\n+      const __numget_type*                           _M_fnumget;\n \n     public:\n+      //@{\n+      /**\n+       *  @brief  The quick-and-easy status check.\n+       *\n+       *  This allows you to write constructs such as\n+       *  \"if (!a_stream) ...\" and \"while (a_stream) ...\"\n+      */\n       operator void*() const \n       { return this->fail() ? 0 : const_cast<basic_ios*>(this); }\n \n       bool \n       operator!() const \n       { return this->fail(); }\n-\n+      //@}\n+\n+      /**\n+       *  @brief  Returns the error state of the stream buffer.\n+       *  @return  A bit pattern (well, isn't everything?)\n+       *\n+       *  See std::ios_base::iostate for the possible bit values.  Most\n+       *  users will call one of the interpreting wrappers, e.g., good().\n+      */\n       iostate \n       rdstate() const \n       { return _M_streambuf_state; }\n \n+      /**\n+       *  @brief  [Re]sets the error state.\n+       *  @param  state  The new state flag(s) to set.\n+       *\n+       *  See std::ios_base::iostate for the possible bit values.  Most\n+       *  users will not need to pass an argument.\n+      */\n       void \n       clear(iostate __state = goodbit);\n \n+      /**\n+       *  @brief  Sets additional flags in the error state.\n+       *  @param  state  The additional state flag(s) to set.\n+       *\n+       *  See std::ios_base::iostate for the possible bit values.\n+      */\n       void \n       setstate(iostate __state) \n       { this->clear(this->rdstate() | __state); }\n \n+      /**\n+       *  @brief  Fast error checking.\n+       *  @return  True if no error flags are set.\n+       *\n+       *  A wrapper around rdstate.\n+      */\n       bool \n       good() const \n       { return this->rdstate() == 0; }\n \n+      /**\n+       *  @brief  Fast error checking.\n+       *  @return  True if the eofbit is set.\n+       *\n+       *  Note that other iostate flags may also be set.\n+      */\n       bool \n       eof() const \n       { return (this->rdstate() & eofbit) != 0; }\n \n+      /**\n+       *  @brief  Fast error checking.\n+       *  @return  True if either the badbit or the failbit is set.\n+       *\n+       *  Checking the badbit in fail() is historical practice.\n+       *  Note that other iostate flags may also be set.\n+      */\n       bool \n       fail() const \n       { return (this->rdstate() & (badbit | failbit)) != 0; }\n \n+      /**\n+       *  @brief  Fast error checking.\n+       *  @return  True if the badbit is set.\n+       *\n+       *  Note that other iostate flags may also be set.\n+      */\n       bool \n       bad() const \n       { return (this->rdstate() & badbit) != 0; }\n \n+      /**\n+       *  @brief  Throwing exceptions on errors.\n+       *  @return  The current exceptions mask.\n+       *\n+       *  This changes nothing in the stream.  See the one-argument version\n+       *  of exceptions(iostate) for the meaning of the return value.\n+      */\n       iostate \n       exceptions() const \n       { return _M_exception; }\n \n+      /**\n+       *  @brief  Throwing exceptions on errors.\n+       *  @param  except  The new exceptions mask.\n+       *\n+       *  By default, error flags are set silently.  You can set an\n+       *  exceptions mask for each stream; if a bit in the mask becomes set\n+       *  in the error flags, then an exception of type\n+       *  std::ios_base::failure is thrown.\n+       *\n+       *  If the error flage is already set when the exceptions mask is\n+       *  added, the exception is immediately thrown.  Try running the\n+       *  following under GCC 3.1 or later:\n+       *  @code\n+       *  #include <iostream>\n+       *  #include <fstream>\n+       *  #include <exception>\n+       *  \n+       *  int main()\n+       *  {\n+       *      std::set_terminate (__gnu_cxx::__verbose_terminate_handler);\n+       *  \n+       *      std::ifstream f (\"/etc/motd\");\n+       *  \n+       *      std::cerr << \"Setting badbit\\n\";\n+       *      f.setstate (std::ios_base::badbit);\n+       *  \n+       *      std::cerr << \"Setting exception mask\\n\";\n+       *      f.exceptions (std::ios_base::badbit);\n+       *  }\n+       *  @endcode\n+      */\n       void \n       exceptions(iostate __except) \n       { \n-\t_M_exception = __except; \n-\tthis->clear(_M_streambuf_state); \n+        _M_exception = __except; \n+        this->clear(_M_streambuf_state); \n       }\n \n       // Constructor/destructor:\n+      /**\n+       *  @brief  Constructor performs initialization.\n+       *\n+       *  The parameter is passed by derived streams.\n+      */\n       explicit \n       basic_ios(basic_streambuf<_CharT, _Traits>* __sb) : ios_base() \n       { this->init(__sb); }\n \n+      /**\n+       *  @brief  Empty.\n+       *\n+       *  The destructor does nothing.  More specifically, it does not\n+       *  destroy the streambuf held by rdbuf().\n+      */\n       virtual \n       ~basic_ios() { }\n       \n       // Members:\n+      /**\n+       *  @brief  Fetches the current @e tied stream.\n+       *  @return  A pointer to the tied stream, or NULL if the stream is\n+       *           not tied.\n+       *\n+       *  A stream may be @e tied (or synchronized) to a second output\n+       *  stream.  When this stream performs any I/O, the tied stream is\n+       *  first flushed.  For example, @c std::cin is tied to @c std::cout.\n+      */\n       basic_ostream<_CharT, _Traits>*\n       tie() const      \n       { return _M_tie; }\n \n+      /**\n+       *  @brief  Ties this stream to an output stream.\n+       *  @param  tiestr  The output stream.\n+       *  @return  The previously tied output stream, or NULL if the stream\n+       *           was not tied.\n+       *\n+       *  This sets up a new tie; see tie() for more.\n+      */\n       basic_ostream<_CharT, _Traits>*\n       tie(basic_ostream<_CharT, _Traits>* __tiestr)\n       {\n-\tbasic_ostream<_CharT, _Traits>* __old = _M_tie;\n-\t_M_tie = __tiestr;\n-\treturn __old;\n+        basic_ostream<_CharT, _Traits>* __old = _M_tie;\n+        _M_tie = __tiestr;\n+        return __old;\n       }\n \n+      /**\n+       *  @brief  Accessing the underlying buffer.\n+       *  @return  The current stream buffer.\n+       *\n+       *  This does not change the state of the stream.\n+      */\n       basic_streambuf<_CharT, _Traits>*\n       rdbuf() const    \n       { return _M_streambuf; }\n \n+      /**\n+       *  @brief  Changing the underlying buffer.\n+       *  @param  sb  The new stream buffer.\n+       *  @return  The previous stream buffer.\n+       *\n+       *  Associates a new buffer with the current stream, and clears the\n+       *  error state.\n+       *\n+       *  Due to historical accidents which the LWG refuses to correct, the\n+       *  I/O library suffers from a design error:  this function is hidden\n+       *  in derived classes by overrides of the zero-argument @c rdbuf(),\n+       *  which is non-virtual for hysterical raisins.  As a result, you\n+       *  must use explicit qualifications to access this function via any\n+       *  derived class.\n+      */\n       basic_streambuf<_CharT, _Traits>* \n       rdbuf(basic_streambuf<_CharT, _Traits>* __sb);\n \n+      /**\n+       *  @doctodo\n+      */\n       basic_ios&\n       copyfmt(const basic_ios& __rhs);\n \n+      /**\n+       *  @brief  Retreives the \"empty\" character.\n+       *  @return  The current fill character.\n+       *\n+       *  It defaults to a space (' ') in the current locale.\n+      */\n       char_type \n       fill() const \n       {\n@@ -163,6 +330,15 @@ namespace std\n \treturn _M_fill; \n       }\n \n+      /**\n+       *  @brief  Sets a new \"empty\" character.\n+       *  @param  ch  The new character.\n+       *  @return  The previous fill character.\n+       *\n+       *  The fill character is used to fill out space when P+ characters\n+       *  have been requested (e.g., via setw), Q characters are actually\n+       *  used, and Q<P.  It defaults to a space (' ') in the current locale.\n+      */\n       char_type \n       fill(char_type __ch)\n       {\n@@ -172,20 +348,75 @@ namespace std\n       }\n \n       // Locales:\n+      /**\n+       *  @brief  Moves to a new locale.\n+       *  @param  loc  The new locale.\n+       *  @return  The previous locale.\n+       *\n+       *  Calls @c ios_base::imbue(loc), and if a stream buffer is associated\n+       *  with this stream, calls that buffer's @c pubimbue(loc).\n+       *\n+       *  Additional l10n notes are at\n+       *  http://gcc.gnu.org/onlinedocs/libstdc++/22_locale/howto.html\n+      */\n       locale \n       imbue(const locale& __loc);\n \n+      /**\n+       *  @brief  Squeezes characters.\n+       *  @param  c  The character to narrow.\n+       *  @param  dfault  The character to narrow.\n+       *  @return  The narrowed character.\n+       *\n+       *  Maps a character of @c char_type to a character of @c char,\n+       *  if possible.\n+       *\n+       *  Returns the result of\n+       *  @code\n+       *    std::use_facet< ctype<char_type> >(getloc()).narrow(c,dfault)\n+       *  @endcode\n+       *\n+       *  Additional l10n notes are at\n+       *  http://gcc.gnu.org/onlinedocs/libstdc++/22_locale/howto.html\n+      */\n       char \n       narrow(char_type __c, char __dfault) const;\n \n+      /**\n+       *  @brief  Widens characters.\n+       *  @param  c  The character to widen.\n+       *  @return  The widened character.\n+       *\n+       *  Maps a character of @c char to a character of @c char_type.\n+       *\n+       *  Returns the result of\n+       *  @code\n+       *    std::use_facet< ctype<char_type> >(getloc()).widen(c)\n+       *  @endcode\n+       *\n+       *  Additional l10n notes are at\n+       *  http://gcc.gnu.org/onlinedocs/libstdc++/22_locale/howto.html\n+      */\n       char_type \n       widen(char __c) const;\n      \n     protected:\n       // 27.4.5.1  basic_ios constructors\n+      /**\n+       *  @brief  Empty.\n+       *\n+       *  The default constructor does nothing and is not normally\n+       *  accessible to users.\n+      */\n       basic_ios() : ios_base() \n       { }\n \n+      /**\n+       *  @brief  All setup is performed here.\n+       *\n+       *  This is called from the public constructor.  It is not virtual and\n+       *  cannot be redefined.\n+      */\n       void \n       init(basic_streambuf<_CharT, _Traits>* __sb);\n "}, {"sha": "5432527421a67956774c4c2d50398f36dec09d64", "filename": "libstdc++-v3/include/bits/fpos.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/840ceb345b02d8f883b740949984878c9ed6f18e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffpos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/840ceb345b02d8f883b740949984878c9ed6f18e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffpos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffpos.h?ref=840ceb345b02d8f883b740949984878c9ed6f18e", "patch": "@@ -48,7 +48,10 @@ namespace std\n {\n   // 27.4.1  Types\n \n-  // 27.4.3  Template class fpos\n+  // [27.4.3] template class fpos\n+  /**\n+   *  @doctodo\n+  */\n   template<typename _StateT>\n     class fpos\n     {\n@@ -113,9 +116,10 @@ namespace std\n       _M_position(streamoff __off)  { _M_off = __off; }\n     };\n \n-  // 27.2, paragraph 10 about fpos/char_traits circularity\n+  /// 27.2, paragraph 10 about fpos/char_traits circularity\n   typedef fpos<mbstate_t> \t\tstreampos;\n #  ifdef _GLIBCPP_USE_WCHAR_T\n+  /// 27.2, paragraph 10 about fpos/char_traits circularity\n   typedef fpos<mbstate_t> \t\twstreampos;\n #  endif\n }  // namespace std"}, {"sha": "1f085d9e4e717c487e54d9c84f508e5b7de98dcc", "filename": "libstdc++-v3/include/bits/ios_base.h", "status": "modified", "additions": 257, "deletions": 11, "changes": 268, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/840ceb345b02d8f883b740949984878c9ed6f18e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fios_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/840ceb345b02d8f883b740949984878c9ed6f18e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fios_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fios_base.h?ref=840ceb345b02d8f883b740949984878c9ed6f18e", "patch": "@@ -145,11 +145,20 @@ namespace std\n   enum _Ios_Seekdir { _M_ios_seekdir_end = 1L << 16 };\n \n   // 27.4.2  Class ios_base\n+  /**\n+   *  @brief  The very top of the I/O class hierarchy.\n+   *\n+   *  This class defines everything that can be defined about I/O that does\n+   *  not depend on the type of characters being input or output.  Most\n+   *  people will only see @c ios_base when they need to specify the full\n+   *  name of the various I/O flags (e.g., the openmodes).\n+  */\n   class ios_base\n   {\n   public:\n     \n     // 27.4.2.1.1  Class ios_base::failure\n+    /// These are thrown to indicate problems.  Doc me.\n     class failure : public exception\n     {\n     public:\n@@ -173,47 +182,148 @@ namespace std\n     };\n \n     // 27.4.2.1.2  Type ios_base::fmtflags\n+    /**\n+     *  @brief This is a bitmask type.\n+     *\n+     *  @c \"_Ios_Fmtflags\" is implementation-defined, but it is valid to\n+     *  perform bitwise operations on these values and expect the Right\n+     *  Thing to happen.  Defined objects of type fmtflags are:\n+     *  - boolalpha\n+     *  - dec\n+     *  - fixed\n+     *  - hex\n+     *  - internal\n+     *  - left\n+     *  - oct\n+     *  - right\n+     *  - scientific\n+     *  - showbase\n+     *  - showpoint\n+     *  - showpos\n+     *  - skipws\n+     *  - unitbuf\n+     *  - uppercase\n+     *  - adjustfield\n+     *  - basefield\n+     *  - floatfield\n+    */\n     typedef _Ios_Fmtflags fmtflags;\n-    // 27.4.2.1.2  Type fmtflags\n+    /// Insert/extract @c bool in alphabetic rather than numeric format.\n     static const fmtflags boolalpha =   fmtflags(__ios_flags::_S_boolalpha);\n+    /// Converts integer input or generates integer output in decimal base.\n     static const fmtflags dec =         fmtflags(__ios_flags::_S_dec);\n+    /// Generate floating-point output in fixed-point notation.\n     static const fmtflags fixed =       fmtflags(__ios_flags::_S_fixed);\n+    /// Converts integer input or generates integer output in hexadecimal base.\n     static const fmtflags hex =         fmtflags(__ios_flags::_S_hex);\n+    /// Adds fill characters at a designated internal point in certain\n+    /// generated output, or identical to @c right if no such point is\n+    /// designated.\n     static const fmtflags internal =    fmtflags(__ios_flags::_S_internal);\n+    /// Adds fill characters on the right (final positions) of certain\n+    /// generated output.  (I.e., the thing you print is flush left.)\n     static const fmtflags left =        fmtflags(__ios_flags::_S_left);\n+    /// Converts integer input or generates integer output in octal base.\n     static const fmtflags oct =         fmtflags(__ios_flags::_S_oct);\n+    /// Adds fill characters on the left (initial positions) of certain\n+    /// generated output.  (I.e., the thing you print is flush right.)\n     static const fmtflags right =       fmtflags(__ios_flags::_S_right);\n+    /// Generates floating-point output in scientific notation.\n     static const fmtflags scientific =  fmtflags(__ios_flags::_S_scientific);\n+    /// Generates a prefix indicating the numeric base of generated integer\n+    /// output.\n     static const fmtflags showbase =    fmtflags(__ios_flags::_S_showbase);\n+    /// Generates a decimal-point character unconditionally in generated\n+    /// floating-point output.\n     static const fmtflags showpoint =   fmtflags(__ios_flags::_S_showpoint);\n+    /// Generates a + sign in non-negative generated numeric output.\n     static const fmtflags showpos =     fmtflags(__ios_flags::_S_showpos);\n+    /// Skips leading white space before certain input operations.\n     static const fmtflags skipws =      fmtflags(__ios_flags::_S_skipws);\n+    /// Flushes output after each output operation.\n     static const fmtflags unitbuf =     fmtflags(__ios_flags::_S_unitbuf);\n+    /// Replaces certain lowercase letters with their uppercase equivalents\n+    /// in generated output.\n     static const fmtflags uppercase =   fmtflags(__ios_flags::_S_uppercase);\n+    /// A mask of left|right|internal.  Useful for the 2-arg form of @c setf.\n     static const fmtflags adjustfield = fmtflags(__ios_flags::_S_adjustfield);\n+    /// A mask of dec|oct|hex.  Useful for the 2-arg form of @c setf.\n     static const fmtflags basefield =   fmtflags(__ios_flags::_S_basefield);\n+    /// A mask of scientific|fixed.  Useful for the 2-arg form of @c setf.\n     static const fmtflags floatfield =  fmtflags(__ios_flags::_S_floatfield);\n \n     // 27.4.2.1.3  Type ios_base::iostate\n+    /**\n+     *  @brief This is a bitmask type.\n+     *\n+     *  @c \"_Ios_Iostate\" is implementation-defined, but it is valid to\n+     *  perform bitwise operations on these values and expect the Right\n+     *  Thing to happen.  Defined objects of type iostate are:\n+     *  - badbit\n+     *  - eofbit\n+     *  - failbit\n+     *  - goodbit\n+    */\n     typedef _Ios_Iostate iostate;\n+    /// Indicates a loss of integrity in an input or output sequence (such\n+    /// as an irrecoverable read error from a file).\n     static const iostate badbit =  \tiostate(__ios_flags::_S_badbit);\n+    /// Indicates that an input operation reached the end of an input sequence.\n     static const iostate eofbit =  \tiostate(__ios_flags::_S_eofbit);\n+    /// Indicates that an input operation failed to read the expected\n+    /// characters, or that an output operation failed to generate the\n+    /// desired characters.\n     static const iostate failbit = \tiostate(__ios_flags::_S_failbit);\n+    /// Indicates all is well.\n     static const iostate goodbit = \tiostate(0);\n \n-    // 27.4.2.1.4  Type openmode\n+    // 27.4.2.1.4  Type ios_base::openmode\n+    /**\n+     *  @brief This is a bitmask type.\n+     *\n+     *  @c \"_Ios_Openmode\" is implementation-defined, but it is valid to\n+     *  perform bitwise operations on these values and expect the Right\n+     *  Thing to happen.  Defined objects of type openmode are:\n+     *  - app\n+     *  - ate\n+     *  - binary\n+     *  - in\n+     *  - out\n+     *  - trunc\n+    */\n     typedef _Ios_Openmode openmode;\n+    /// Seek to end before each write.\n     static const openmode app =    \topenmode(__ios_flags::_S_app);\n+    /// Open and seek to end immediately after opening.\n     static const openmode ate =    \topenmode(__ios_flags::_S_ate);\n+    /// Perform input and output in binary mode (as opposed to text mode).\n+    /// This is probably not what you think it is; see\n+    /// http://gcc.gnu.org/onlinedocs/libstdc++/27_io/howto.html#3 and\n+    /// http://gcc.gnu.org/onlinedocs/libstdc++/27_io/howto.html#7 for more.\n     static const openmode binary = \topenmode(__ios_flags::_S_bin);\n+    /// Open for input.  Default for @c ifstream and fstream.\n     static const openmode in =     \topenmode(__ios_flags::_S_in);\n+    /// Open for output.  Default for @c ofstream and fstream.\n     static const openmode out =    \topenmode(__ios_flags::_S_out);\n+    /// Open for input.  Default for @c ofstream.\n     static const openmode trunc =  \topenmode(__ios_flags::_S_trunc);\n \n-    // 27.4.2.1.5  Type seekdir\n+    // 27.4.2.1.5  Type ios_base::seekdir\n+    /**\n+     *  @brief This is an enumerated type.\n+     *\n+     *  @c \"_Ios_Seekdir\" is implementation-defined.  Defined values\n+     *  of type seekdir are:\n+     *  - beg\n+     *  - cur, equivalent to @c SEEK_CUR in the C standard library.\n+     *  - end, equivalent to @c SEEK_END in the C standard library.\n+    */\n     typedef _Ios_Seekdir seekdir;\n+    /// Request a seek relative to the beginning of the stream.\n     static const seekdir beg = \t\tseekdir(0);\n+    /// Request a seek relative to the current position within the sequence.\n     static const seekdir cur = \t\tseekdir(SEEK_CUR);\n+    /// Request a seek relative to the current end of the sequence.\n     static const seekdir end = \t\tseekdir(SEEK_END);\n \n #ifdef _GLIBCPP_DEPRECATED\n@@ -227,25 +337,40 @@ namespace std\n #endif\n \n     // Callbacks;\n+    /**\n+     *  @doctodo\n+    */\n     enum event\n     {\n       erase_event,\n       imbue_event,\n       copyfmt_event\n     };\n \n+    /**\n+     *  @doctodo\n+    */\n     typedef void (*event_callback) (event, ios_base&, int);\n \n+    /**\n+     *  @doctodo\n+    */\n     void \n     register_callback(event_callback __fn, int __index);\n \n   protected:\n-    // Data Members\n+    //@{\n+    /**\n+     *  @if maint\n+     *  ios_base data members (doc me)\n+     *  @endif\n+    */\n     streamsize \t\t_M_precision;\n     streamsize \t\t_M_width;\n     fmtflags \t\t_M_flags;\n     iostate \t\t_M_exception;\n     iostate \t       \t_M_streambuf_state;\n+    //@}\n \n     // 27.4.2.6  Members for callbacks\n     // 27.4.2.6  ios_base callbacks\n@@ -329,10 +454,21 @@ namespace std\n       static bool\t_S_synced_with_stdio;\n     };\n \n-    // Fmtflags state:\n+    // [27.4.2.2] fmtflags state functions\n+    /**\n+     *  @brief  Access to format flags.\n+     *  @return  The format control flags for both input and output.\n+    */\n     inline fmtflags \n     flags() const { return _M_flags; }\n \n+    /**\n+     *  @brief  Setting new format flags all at once.\n+     *  @param  fmtfl  The new flags to set.\n+     *  @return  The previous format control flags.\n+     *\n+     *  This function overwrites all the format flags with @a fmtfl.\n+    */\n     inline fmtflags \n     flags(fmtflags __fmtfl)\n     { \n@@ -341,6 +477,14 @@ namespace std\n       return __old; \n     }\n \n+    /**\n+     *  @brief  Setting new format flags.\n+     *  @param  fmtfl  Additional flags to set.\n+     *  @return  The previous format control flags.\n+     *\n+     *  This function sets additional flags in format control.  Flags that\n+     *  were previously set remain set.\n+    */\n     inline fmtflags \n     setf(fmtflags __fmtfl)\n     { \n@@ -349,6 +493,15 @@ namespace std\n       return __old; \n     }\n \n+    /**\n+     *  @brief  Setting new format flags.\n+     *  @param  fmtfl  Additional flags to set.\n+     *  @param  mask  The flags mask for @a fmtfl.\n+     *  @return  The previous format control flags.\n+     *\n+     *  This function clears @a mask in the format flags, then sets\n+     *  @a fmtfl @c & @a mask.  An example mask is @c ios_base::adjustfield.\n+    */\n     inline fmtflags \n     setf(fmtflags __fmtfl, fmtflags __mask)\n     {\n@@ -358,12 +511,32 @@ namespace std\n       return __old;\n     }\n \n+    /**\n+     *  @brief  Clearing format flags.\n+     *  @param  mask  The flags to unset.\n+     *\n+     *  This function clears @a mask in the format flags.\n+    */\n     inline void \n     unsetf(fmtflags __mask) { _M_flags &= ~__mask; }\n \n+    /**\n+     *  @brief  Flags access.\n+     *  @return  The precision to generate on certain output operations.\n+     *\n+     *  @if maint\n+     *  Be careful if you try to give a definition of \"precision\" here; see\n+     *  DR 189.\n+     *  @endif\n+    */\n     inline streamsize \n     precision() const { return _M_precision; }\n \n+    /**\n+     *  @brief  Changing flags.\n+     *  @param  prec  The new precision value.\n+     *  @return  The previous value of precision().\n+    */\n     inline streamsize \n     precision(streamsize __prec)\n     { \n@@ -372,9 +545,20 @@ namespace std\n       return __old; \n     }\n \n+    /**\n+     *  @brief  Flags access.\n+     *  @return  The minimum field width to generate on output operations.\n+     *\n+     *  \"Minimum field width\" refers to the number of characters.\n+    */\n     inline streamsize \n     width() const { return _M_width; }\n \n+    /**\n+     *  @brief  Changing flags.\n+     *  @param  wide  The new width value.\n+     *  @return  The previous value of width().\n+    */\n     inline streamsize \n     width(streamsize __wide)\n     { \n@@ -383,20 +567,53 @@ namespace std\n       return __old; \n     }\n \n+    // [27.4.2.4] ios_base static members\n+    /**\n+     *  @brief  Interaction with the standard C I/O objects.\n+     *  @param  sync  Whether to synchronize or not.\n+     *  @return  True if the standard streams were previously synchronized.\n+     *\n+     *  The synchronization referred to is @e only that between the standard\n+     *  C facilities (e.g., stdout) and the standard C++ objects (e.g.,\n+     *  cout).  User-declared streams are unaffected.  See\n+     *  http://gcc.gnu.org/onlinedocs/libstdc++/27_io/howto.html#8 for more.\n+    */\n     static bool \n     sync_with_stdio(bool __sync = true);\n \n-    // Locales:\n+    // [27.4.2.3] ios_base locale functions\n+    /**\n+     *  @brief  Setting a new locale.\n+     *  @param  loc  The new locale.\n+     *  @return  The previous locale.\n+     *\n+     *  Sets the new locale for this stream, and\n+     *  [XXX does something with callbacks].\n+    */\n     locale \n     imbue(const locale& __loc);\n \n+    /**\n+     *  @brief  Locale access\n+     *  @return  The locale currently in effect.\n+     *\n+     *  If @c imbue(loc) has previously been called, then this function\n+     *  returns @c loc.  Otherwise, it returns a copy of @c std::locale(),\n+     *  the global C++ locale.\n+    */\n     inline locale \n     getloc() const { return _M_ios_locale; }\n \n-    // Storage:\n+    // [27.4.2.5] ios_base storage functions\n+    /**\n+     *  @doctodo\n+    */\n     static int \n     xalloc() throw();\n \n+    /**\n+     *  @doctodo\n+    */\n     inline long& \n     iword(int __ix)\n     {\n@@ -405,6 +622,9 @@ namespace std\n       return __word._M_iword;\n     }\n \n+    /**\n+     *  @doctodo\n+    */\n     inline void*& \n     pword(int __ix)\n     {\n@@ -414,6 +634,10 @@ namespace std\n     }\n \n     // Destructor\n+    /**\n+     *  Destroys local storage and\n+     *  [XXX does something with callbacks].\n+    */\n     virtual ~ios_base();\n \n   protected:\n@@ -429,157 +653,179 @@ namespace std\n #endif\n   };\n  \n-  // 27.4.5.1 fmtflags manipulators:\n+  // [27.4.5.1] fmtflags manipulators\n+  /// Calls base.setf(ios_base::boolalpha).\n   inline ios_base& \n   boolalpha(ios_base& __base)\n   {\n     __base.setf(ios_base::boolalpha);\n     return __base;\n   }\n \n+  /// Calls base.unsetf(ios_base::boolalpha).\n   inline ios_base& \n   noboolalpha(ios_base& __base)\n   {\n     __base.unsetf(ios_base::boolalpha);\n     return __base;\n   }\n \n+  /// Calls base.setf(ios_base::showbase).\n   inline ios_base& \n   showbase(ios_base& __base)\n   {\n     __base.setf(ios_base::showbase);\n     return __base;\n   }\n \n+  /// Calls base.unsetf(ios_base::showbase).\n   inline ios_base& \n   noshowbase(ios_base& __base)\n   {\n     __base.unsetf(ios_base::showbase);\n     return __base;\n   }\n \n+  /// Calls base.setf(ios_base::showpoint).\n   inline ios_base& \n   showpoint(ios_base& __base)\n   {\n     __base.setf(ios_base::showpoint);\n     return __base;\n   }\n \n+  /// Calls base.unsetf(ios_base::showpoint).\n   inline ios_base& \n   noshowpoint(ios_base& __base)\n   {\n     __base.unsetf(ios_base::showpoint);\n     return __base;\n   }\n \n+  /// Calls base.setf(ios_base::showpos).\n   inline ios_base& \n   showpos(ios_base& __base)\n   {\n     __base.setf(ios_base::showpos);\n     return __base;\n   }\n \n+  /// Calls base.unsetf(ios_base::showpos).\n   inline ios_base& \n   noshowpos(ios_base& __base)\n   {\n     __base.unsetf(ios_base::showpos);\n     return __base;\n   }\n \n+  /// Calls base.setf(ios_base::skipws).\n   inline ios_base& \n   skipws(ios_base& __base)\n   {\n     __base.setf(ios_base::skipws);\n     return __base;\n   }\n   \n+  /// Calls base.unsetf(ios_base::skipws).\n   inline ios_base& \n   noskipws(ios_base& __base)\n   {\n     __base.unsetf(ios_base::skipws);\n     return __base;\n   }\n \n+  /// Calls base.setf(ios_base::uppercase).\n   inline ios_base& \n   uppercase(ios_base& __base)\n   {\n     __base.setf(ios_base::uppercase);\n     return __base;\n   }\n \n+  /// Calls base.unsetf(ios_base::uppercase).\n   inline ios_base& \n   nouppercase(ios_base& __base)\n   {\n     __base.unsetf(ios_base::uppercase);\n     return __base;\n   }\n \n+  /// Calls base.setf(ios_base::unitbuf).\n   inline ios_base& \n   unitbuf(ios_base& __base)\n   {\n      __base.setf(ios_base::unitbuf);      \n      return __base;\n   }\n \n+  /// Calls base.unsetf(ios_base::unitbuf).\n   inline ios_base& \n   nounitbuf(ios_base& __base)\n   {\n      __base.unsetf(ios_base::unitbuf);\n      return __base;    \n   }\n \n-  // 27.4.5.2 adjustfield anipulators:\n+  // [27.4.5.2] adjustfield anipulators\n+  /// Calls base.setf(ios_base::internal, ios_base::adjustfield).\n   inline ios_base& \n   internal(ios_base& __base)\n   {\n      __base.setf(ios_base::internal, ios_base::adjustfield);\n      return __base;    \n   }\n \n+  /// Calls base.setf(ios_base::left, ios_base::adjustfield).\n   inline ios_base& \n   left(ios_base& __base)\n   {\n     __base.setf(ios_base::left, ios_base::adjustfield);\n     return __base;\n   }\n   \n+  /// Calls base.setf(ios_base::right, ios_base::adjustfield).\n   inline ios_base& \n   right(ios_base& __base)\n   {\n     __base.setf(ios_base::right, ios_base::adjustfield);\n     return __base;\n   }\n   \n-  // 27.4.5.3 basefield anipulators:\n+  // [27.4.5.3] basefield anipulators\n+  /// Calls base.setf(ios_base::dec, ios_base::basefield).\n   inline ios_base& \n   dec(ios_base& __base)\n   {\n     __base.setf(ios_base::dec, ios_base::basefield);\n     return __base;\n   }\n   \n+  /// Calls base.setf(ios_base::hex, ios_base::basefield).\n   inline ios_base& \n   hex(ios_base& __base)\n   {\n     __base.setf(ios_base::hex, ios_base::basefield);\n     return __base;\n   }\n \n+  /// Calls base.setf(ios_base::oct, ios_base::basefield).\n   inline ios_base& \n   oct(ios_base& __base)\n   {\n     __base.setf(ios_base::oct, ios_base::basefield);\n     return __base;\n   }\n   \n-  // 27.4.5.4 floatfield anipulators:\n+  // [27.4.5.4] floatfield anipulators\n+  /// Calls base.setf(ios_base::fixed, ios_base::floatfield).\n   inline ios_base& \n   fixed(ios_base& __base)\n   {\n     __base.setf(ios_base::fixed, ios_base::floatfield);\n     return __base;\n   }\n \n+  /// Calls base.setf(ios_base::scientific, ios_base::floatfield).\n   inline ios_base& \n   scientific(ios_base& __base)\n   {"}, {"sha": "454fed31bf73bd5d75d73e94eb04a4213573202a", "filename": "libstdc++-v3/include/bits/stl_deque.h", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/840ceb345b02d8f883b740949984878c9ed6f18e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/840ceb345b02d8f883b740949984878c9ed6f18e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h?ref=840ceb345b02d8f883b740949984878c9ed6f18e", "patch": "@@ -1280,7 +1280,8 @@ namespace std\n       }\n   \n     // called by the second initialize_dispatch above\n-    /** @{\n+    //@{\n+    /**\n      *  @if maint\n      *  @brief Fills the deque with whatever is in [first,last).\n      *  @param  first  An input iterator.\n@@ -1302,7 +1303,7 @@ namespace std\n       void\n       _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,\n                           forward_iterator_tag);\n-    /** @} */\n+    //@}\n   \n     /**\n      *  @if maint\n@@ -1383,7 +1384,8 @@ namespace std\n     }\n   \n   \n-    /** @{\n+    //@{\n+    /**\n      *  @if maint\n      *  @brief Helper functions for push_* and pop_*.\n      *  @endif\n@@ -1396,7 +1398,7 @@ namespace std\n   #endif\n     void _M_pop_back_aux();\n     void _M_pop_front_aux();\n-    /** @} */\n+    //@}\n   \n   \n     // Internal insert functions follow.  The *_aux functions do the actual\n@@ -1462,7 +1464,8 @@ namespace std\n     iterator _M_insert_aux(iterator __pos);\n   #endif\n   \n-    /** @{\n+    //@{\n+    /**\n      *  @if maint\n      *  @brief Memory-handling helpers for the previous internal insert\n      *         functions.\n@@ -1491,10 +1494,11 @@ namespace std\n   \n     void\n     _M_new_elements_at_back(size_type __new_elements);\n-    /** @} */\n+    //@}\n   \n   \n-    /** @{\n+    //@{\n+    /**\n      *  @if maint\n      *  @brief Memory-handling helpers for the major %map.\n      *\n@@ -1519,7 +1523,7 @@ namespace std\n   \n     void\n     _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front);\n-    /** @} */\n+    //@}\n   };\n   \n   "}, {"sha": "8b040e496023703e47e465e8b38a36af70d37a2d", "filename": "libstdc++-v3/include/bits/stl_iterator_base_types.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/840ceb345b02d8f883b740949984878c9ed6f18e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator_base_types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/840ceb345b02d8f883b740949984878c9ed6f18e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator_base_types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator_base_types.h?ref=840ceb345b02d8f883b740949984878c9ed6f18e", "patch": "@@ -68,7 +68,8 @@\n \n namespace std\n {\n-  /** @{\n+  //@{\n+  /**\n    *  @defgroup iterator_tags Iterator Tags\n    *  These are empty types, used to distinguish different iterators.  The\n    *  distinction is not made by what they contain, but simply by what they"}, {"sha": "685a38dd94439ce0589c71c1faabfb633d3f7293", "filename": "libstdc++-v3/include/std/std_fstream.h", "status": "modified", "additions": 296, "deletions": 38, "changes": 334, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/840ceb345b02d8f883b740949984878c9ed6f18e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_fstream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/840ceb345b02d8f883b740949984878c9ed6f18e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_fstream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_fstream.h?ref=840ceb345b02d8f883b740949984878c9ed6f18e", "patch": "@@ -50,6 +50,15 @@\n \n namespace std\n {\n+  // [27.8.1.1] template class basic_filebuf\n+  /**\n+   *  @brief  The actual work of input and output (for files).\n+   *\n+   *  This class associates both its input and output sequence with an\n+   *  external disk file, and maintains a joint file position for both\n+   *  sequences.  Many of its sematics are described in terms of similar\n+   *  behavior in the Standard C Library's @c FILE streams.\n+  */\n   template<typename _CharT, typename _Traits>\n     class basic_filebuf : public basic_streambuf<_CharT, _Traits>\n     {\n@@ -61,43 +70,83 @@ namespace std\n       typedef typename traits_type::pos_type \t\tpos_type;\n       typedef typename traits_type::off_type \t\toff_type;\n \n-      // Non-standard Types:\n+      //@{\n+      /**\n+       *  @if maint\n+       *  @doctodo\n+       *  @endif\n+      */\n       typedef basic_streambuf<char_type, traits_type>  \t__streambuf_type;\n       typedef basic_filebuf<char_type, traits_type>     __filebuf_type;\n       typedef __basic_file<char>\t\t        __file_type;\n       typedef typename traits_type::state_type          __state_type;\n       typedef codecvt<char_type, char, __state_type>    __codecvt_type;\n       typedef typename __codecvt_type::result \t        __res_type;\n       typedef ctype<char_type>                          __ctype_type;\n+      //@}\n \n       friend class ios_base; // For sync_with_stdio.\n \n     protected:\n       // Data Members:\n       // MT lock inherited from libio or other low-level io library.\n+      /**\n+       *  @if maint\n+       *  @doctodo\n+       *  @endif\n+      */\n       __c_lock          \t_M_lock;\n \n       // External buffer.\n+      /**\n+       *  @if maint\n+       *  @doctodo\n+       *  @endif\n+      */\n       __file_type \t\t_M_file;\n \n       // Current and beginning state type for codecvt.\n+      /**\n+       *  @if maint\n+       *  @doctodo\n+       *  @endif\n+      */\n       __state_type\t\t_M_state_cur;\n       __state_type \t\t_M_state_beg;\n \n       // Set iff _M_buf is allocated memory from _M_allocate_internal_buffer.\n+      /**\n+       *  @if maint\n+       *  @doctodo\n+       *  @endif\n+      */\n       bool\t\t\t_M_buf_allocated;\n       \n       // XXX Needed?\n       bool\t\t\t_M_last_overflowed;\n \n       // The position in the buffer corresponding to the external file\n       // pointer.\n+      /**\n+       *  @if maint\n+       *  @doctodo\n+       *  @endif\n+      */\n       char_type*\t\t_M_filepos;\n \n     public:\n       // Constructors/destructor:\n+      /**\n+       *  @brief  Does not open any files.\n+       *\n+       *  The default constructor initializes the parent class using its\n+       *  own default ctor.\n+      */\n       basic_filebuf();\n \n+      /**\n+       *  @brief  The destructor closes the file first.\n+      */\n       virtual\n       ~basic_filebuf()\n       {\n@@ -106,23 +155,61 @@ namespace std\n       }\n \n       // Members:\n+      /**\n+       *  @brief  Returns true if the external file is open.\n+      */\n       bool\n       is_open() const { return _M_file.is_open(); }\n \n+      /**\n+       *  @brief  Opens an external file.\n+       *  @param  s  The name of the file.\n+       *  @param  mode  The open mode flags.\n+       *  @return  @c this on success, NULL on failure\n+       *\n+       *  If a file is already open, this function immediately fails.\n+       *  Otherwise it tries to open the file named @a s using the flags\n+       *  given in @a mode.\n+       *\n+       *  [Table 92 gives the relation between openmode combinations and the\n+       *  equivalent fopen() flags, but the table has not been copied yet.]\n+      */\n       __filebuf_type*\n       open(const char* __s, ios_base::openmode __mode);\n \n+      /**\n+       *  @brief  Closes the currently associated file.\n+       *  @return  @c this on success, NULL on failure\n+       *\n+       *  If no file is currently open, this function immediately fails.\n+       *\n+       *  If a \"put buffer area\" exists, @c overflow(eof) is called to flush\n+       *  all the characters.  The file is then closed.\n+       *\n+       *  If any operations fail, this function also fails.\n+      */\n       __filebuf_type*\n       close();\n \n     protected:\n+      /**\n+       *  @if maint\n+       *  @doctodo\n+       *  @endif\n+      */\n       void\n       _M_allocate_internal_buffer();\n \n+      /**\n+       *  @if maint\n+       *  @doctodo\n+       *  @endif\n+      */\n       void\n       _M_destroy_internal_buffer();\n \n-      // Overridden virtual functions:\n+      // [27.8.1.4] overridden virtual functions\n+      // [documentation is inherited]\n       virtual streamsize\n       showmanyc();\n \n@@ -137,15 +224,23 @@ namespace std\n       // the underflow() case in order to maintain synchronization.  So\n       // instead of calling underflow() from uflow(), we create a common\n       // subroutine to do the real work.\n+      /**\n+       *  @if maint\n+       *  @doctodo\n+       *  @endif\n+      */\n       int_type\n       _M_underflow_common(bool __bump);\n \n+      // [documentation is inherited]\n       virtual int_type\n       underflow() { return _M_underflow_common(false); }\n \n+      // [documentation is inherited]\n       virtual int_type\n       uflow() { return _M_underflow_common(true); }\n \n+      // [documentation is inherited]\n       virtual int_type\n       pbackfail(int_type __c = _Traits::eof());\n \n@@ -157,6 +252,8 @@ namespace std\n       // this in actuality be a helper function that checks for the\n       // eccentricities of this implementation, and then call\n       // overflow() if indeed the buffer is full.\n+\n+      // [documentation is inherited]\n       virtual int_type\n       overflow(int_type __c = _Traits::eof());\n \n@@ -167,25 +264,50 @@ namespace std\n       // character c.\n       // 27.5.2.4.5\n       // Consume some sequence of the characters in the pending sequence.\n+      /**\n+       *  @if maint\n+       *  @doctodo\n+       *  @endif\n+      */\n       int_type\n       _M_really_overflow(int_type __c = _Traits::eof());\n \n       // Convert internal byte sequence to external, char-based\n       // sequence via codecvt.\n+      /**\n+       *  @if maint\n+       *  @doctodo\n+       *  @endif\n+      */\n       void\n       _M_convert_to_external(char_type*, streamsize, streamsize&, streamsize&);\n \n+      /**\n+       *  @brief  Manipulates the buffer.\n+       *  @param  s  Pointer to a buffer area.\n+       *  @param  n  Size of @a s.\n+       *  @return  @c this\n+       *\n+       *  If no file has been opened, and both @a s and @a n are zero, then\n+       *  the stream becomes unbuffered.  Otherwise, @c s is used as a\n+       *  buffer; see\n+       *  http://gcc.gnu.org/onlinedocs/libstdc++/27_io/howto.html#2\n+       *  for more.\n+      */\n       virtual __streambuf_type*\n       setbuf(char_type* __s, streamsize __n);\n \n+      // [documentation is inherited]\n       virtual pos_type\n       seekoff(off_type __off, ios_base::seekdir __way,\n \t      ios_base::openmode __mode = ios_base::in | ios_base::out);\n \n+      // [documentation is inherited]\n       virtual pos_type\n       seekpos(pos_type __pos,\n \t      ios_base::openmode __mode = ios_base::in | ios_base::out);\n \n+      // [documentation is inherited]\n       virtual int\n       sync()\n       {\n@@ -207,9 +329,11 @@ namespace std\n \treturn 0;\n       }\n \n+      // [documentation is inherited]\n       virtual void\n       imbue(const locale& __loc);\n \n+      // [documentation is inherited]\n       virtual streamsize\n       xsgetn(char_type* __s, streamsize __n)\n       {\n@@ -231,13 +355,19 @@ namespace std\n \treturn __ret;\n       }\n \n+      // [documentation is inherited]\n       virtual streamsize\n       xsputn(const char_type* __s, streamsize __n)\n       {\n \t_M_pback_destroy();\n \treturn __streambuf_type::xsputn(__s, __n);\n       }\n \n+      /**\n+       *  @if maint\n+       *  @doctodo\n+       *  @endif\n+      */\n       void\n       _M_output_unshift();\n \n@@ -248,6 +378,11 @@ namespace std\n       // internal buffer does not truly reflect the contents of the\n       // external buffer. At this point, for whatever reason, it is in\n       // an indeterminate state.\n+      /**\n+       *  @if maint\n+       *  @doctodo\n+       *  @endif\n+      */\n       void\n       _M_set_indeterminate(void)\n       {\n@@ -258,6 +393,11 @@ namespace std\n \t_M_filepos = _M_buf;\n       }\n \n+      /**\n+       *  @if maint\n+       *  @doctodo\n+       *  @endif\n+      */\n       void\n       _M_set_determinate(off_type __off)\n       {\n@@ -270,6 +410,11 @@ namespace std\n \t_M_filepos = _M_buf + __off;\n       }\n \n+      /**\n+       *  @if maint\n+       *  @doctodo\n+       *  @endif\n+      */\n       bool\n       _M_is_indeterminate(void)\n       { \n@@ -286,7 +431,7 @@ namespace std\n       }\n     };\n \n-  // Explicit specializations.\n+  // Explicit specializations, defined in src/fstream.cc.\n   template<> \n     basic_filebuf<char>::int_type \n     basic_filebuf<char>::_M_underflow_common(bool __bump);\n@@ -297,9 +442,14 @@ namespace std\n     basic_filebuf<wchar_t>::_M_underflow_common(bool __bump);\n  #endif\n \n-  // 27.8.1.5  Template class basic_ifstream\n+  // [27.8.1.5] Template class basic_ifstream\n   /**\n-   *  Derivation of general input streams, specific to files.\n+   *  @brief  Controlling input for files.\n+   *\n+   *  This class supports reading from named files, using the inherited\n+   *  functions from std::basic_istream.  To control the associated\n+   *  sequence, an instance of std::basic_filebuf is used, which this page\n+   *  refers to as @c sb.\n   */\n   template<typename _CharT, typename _Traits>\n     class basic_ifstream : public basic_istream<_CharT, _Traits>\n@@ -317,20 +467,33 @@ namespace std\n       typedef basic_istream<char_type, traits_type>\t__istream_type;\n \n     private:\n+      /**\n+       *  @if maint\n+       *  @doctodo\n+       *  @endif\n+      */\n       __filebuf_type\t_M_filebuf;\n \n     public:\n-     // Constructors/Destructors:\n-     /** Default constructor.  Create an input file stream.  */\n+      // Constructors/Destructors:\n+      /**\n+       *  @brief  Default constructor.\n+       *\n+       *  Initializes @c sb using its default constructor, and passes\n+       *  @c &sb to the base class initializer.  Does not open any files\n+       *  (you haven't given it a filename to open).\n+      */\n       basic_ifstream()\n       : __istream_type(NULL), _M_filebuf()\n       { this->init(&_M_filebuf); }\n \n       /**\n-       *  @brief Create an input file stream.\n-       *  @param  s  Null terminated string specifying filename.\n+       *  @brief  Create an input file stream.\n+       *  @param  s  Null terminated string specifying the filename.\n        *  @param  mode  Open file in specified mode (see std::ios_base).\n        *\n+       *  @c ios_base::in is automatically included in @a mode.\n+       *\n        *  Tip:  When using std::string to hold the filename, you must use\n        *  .c_str() before passing it to this constructor.\n       */\n@@ -342,29 +505,57 @@ namespace std\n \tthis->open(__s, __mode);\n       }\n \n+      /**\n+       *  @brief  The destructor does nothing.\n+       *\n+       *  The file is closed by the filebuf object, not the formatting\n+       *  stream.\n+      */\n       ~basic_ifstream()\n       { }\n \n       // Members:\n       /**\n-       *  @brief  Get a pointer to the file stream's buffer.\n-       *  @return Pointer to basic_filebuf.\n+       *  @brief  Accessing the underlying buffer.\n+       *  @return  The current basic_filebuf buffer.\n+       *\n+       *  This hides both signatures of std::basic_ios::rdbuf().\n       */\n       __filebuf_type*\n       rdbuf() const\n       { return const_cast<__filebuf_type*>(&_M_filebuf); }\n \n+      /**\n+       *  @brief  Wrapper to test for an open file.\n+       *  @return  @c rdbuf()->is_open()\n+      */\n       bool\n       is_open() { return _M_filebuf.is_open(); }\n \n+      /**\n+       *  @brief  Opens an external file.\n+       *  @param  s  The name of the file.\n+       *  @param  mode  The open mode flags.\n+       *\n+       *  Calls @c std::basic_filebuf::open(s,mode|in).  If that function\n+       *  fails, @c failbit is set in the stream's error state.\n+       *\n+       *  Tip:  When using std::string to hold the filename, you must use\n+       *  .c_str() before passing it to this constructor.\n+      */\n       void\n       open(const char* __s, ios_base::openmode __mode = ios_base::in)\n       {\n \tif (!_M_filebuf.open(__s, __mode | ios_base::in))\n \t  this->setstate(ios_base::failbit);\n       }\n \n-      /** Close the file.  */\n+      /**\n+       *  @brief  Close the file.\n+       *\n+       *  Calls @c std::basic_filebuf::close().  If that function\n+       *  fails, @c failbit is set in the stream's error state.\n+      */\n       void\n       close()\n       {\n@@ -374,9 +565,14 @@ namespace std\n     };\n \n \n-  // 27.8.1.8  Template class basic_ofstream\n+  // [27.8.1.8] Template class basic_ofstream\n   /**\n-   *  Derivation of general output streams, specific to files.\n+   *  @brief  Controlling output for files.\n+   *\n+   *  This class supports reading from named files, using the inherited\n+   *  functions from std::basic_ostream.  To control the associated\n+   *  sequence, an instance of std::basic_filebuf is used, which this page\n+   *  refers to as @c sb.\n   */\n   template<typename _CharT, typename _Traits>\n     class basic_ofstream : public basic_ostream<_CharT,_Traits>\n@@ -394,20 +590,34 @@ namespace std\n       typedef basic_ostream<char_type, traits_type>\t__ostream_type;\n \n     private:\n+      /**\n+       *  @if maint\n+       *  @doctodo\n+       *  @endif\n+      */\n       __filebuf_type\t_M_filebuf;\n \n     public:\n       // Constructors:\n-      /** Default constructor for output file_stream.  */\n+      /**\n+       *  @brief  Default constructor.\n+       *\n+       *  Initializes @c sb using its default constructor, and passes\n+       *  @c &sb to the base class initializer.  Does not open any files\n+       *  (you haven't given it a filename to open).\n+      */\n       basic_ofstream()\n       : __ostream_type(NULL), _M_filebuf()\n       { this->init(&_M_filebuf); }\n \n       /**\n-       *  @brief  Create an output stream.\n-       *  @param  s  Null terminated string specifying filename.\n+       *  @brief  Create an output file stream.\n+       *  @param  s  Null terminated string specifying the filename.\n        *  @param  mode  Open file in specified mode (see std::ios_base).\n        *\n+       *  @c ios_base::out|ios_base::trunc is automatically included in\n+       *  @a mode.\n+       *\n        *  Tip:  When using std::string to hold the filename, you must use\n        *  .c_str() before passing it to this constructor.\n       */\n@@ -420,29 +630,40 @@ namespace std\n \tthis->open(__s, __mode);\n       }\n \n+      /**\n+       *  @brief  The destructor does nothing.\n+       *\n+       *  The file is closed by the filebuf object, not the formatting\n+       *  stream.\n+      */\n       ~basic_ofstream()\n       { }\n \n       // Members:\n       /**\n-       *  @brief  Get a pointer to the file stream's buffer.\n-       *  @return Pointer to basic_filebuf.\n+       *  @brief  Accessing the underlying buffer.\n+       *  @return  The current basic_filebuf buffer.\n+       *\n+       *  This hides both signatures of std::basic_ios::rdbuf().\n       */\n       __filebuf_type*\n       rdbuf() const\n       { return const_cast<__filebuf_type*>(&_M_filebuf); }\n \n       /**\n-       *  @brief Query to see if file stream is open.\n-       *  @return True if stream is open.\n+       *  @brief  Wrapper to test for an open file.\n+       *  @return  @c rdbuf()->is_open()\n       */\n       bool\n       is_open() { return _M_filebuf.is_open(); }\n \n       /**\n-       *  @brief Specify a file to open for output.\n-       *  @param  s  Null terminated string specifying filename.\n-       *  @param  mode  Mode in which to open file (see std::ios_base).\n+       *  @brief  Opens an external file.\n+       *  @param  s  The name of the file.\n+       *  @param  mode  The open mode flags.\n+       *\n+       *  Calls @c std::basic_filebuf::open(s,mode|out|trunc).  If that\n+       *  function fails, @c failbit is set in the stream's error state.\n        *\n        *  Tip:  When using std::string to hold the filename, you must use\n        *  .c_str() before passing it to this constructor.\n@@ -455,7 +676,12 @@ namespace std\n \t  this->setstate(ios_base::failbit);\n       }\n \n-      /** Close the file stream.  */\n+      /**\n+       *  @brief  Close the file.\n+       *\n+       *  Calls @c std::basic_filebuf::close().  If that function\n+       *  fails, @c failbit is set in the stream's error state.\n+      */\n       void\n       close()\n       {\n@@ -465,9 +691,14 @@ namespace std\n     };\n \n \n-  // 27.8.1.11  Template class basic_fstream\n+  // [27.8.1.11] Template class basic_fstream\n   /**\n-   *  Derivation of general input/output streams, specific to files.\n+   *  @brief  Controlling intput and output for files.\n+   *\n+   *  This class supports reading from and writing to named files, using\n+   *  the inherited functions from std::basic_iostream.  To control the\n+   *  associated sequence, an instance of std::basic_filebuf is used, which\n+   *  this page refers to as @c sb.\n   */\n   template<typename _CharT, typename _Traits>\n     class basic_fstream : public basic_iostream<_CharT, _Traits>\n@@ -486,18 +717,29 @@ namespace std\n       typedef basic_iostream<char_type, traits_type>\t__iostream_type;\n \n     private:\n+      /**\n+       *  @if maint\n+       *  @doctodo\n+       *  @endif\n+      */\n       __filebuf_type\t_M_filebuf;\n \n     public:\n       // Constructors/destructor:\n-      /** Default constructor.  Create a file stream.  */\n+      /**\n+       *  @brief  Default constructor.\n+       *\n+       *  Initializes @c sb using its default constructor, and passes\n+       *  @c &sb to the base class initializer.  Does not open any files\n+       *  (you haven't given it a filename to open).\n+      */\n       basic_fstream()\n       : __iostream_type(NULL), _M_filebuf()\n       { this->init(&_M_filebuf); }\n \n       /**\n-       *  @brief Create an input/output stream.\n-       *  @param  s  Null terminated string specifying filename.\n+       *  @brief  Create an input/output file stream.\n+       *  @param  s  Null terminated string specifying the filename.\n        *  @param  mode  Open file in specified mode (see std::ios_base).\n        *\n        *  Tip:  When using std::string to hold the filename, you must use\n@@ -512,29 +754,40 @@ namespace std\n \tthis->open(__s, __mode);\n       }\n \n+      /**\n+       *  @brief  The destructor does nothing.\n+       *\n+       *  The file is closed by the filebuf object, not the formatting\n+       *  stream.\n+      */\n       ~basic_fstream()\n       { }\n \n       // Members:\n       /**\n-       *  @brief  Get a pointer to the file stream's buffer.\n-       *  @return Pointer to basic_filebuf.\n+       *  @brief  Accessing the underlying buffer.\n+       *  @return  The current basic_filebuf buffer.\n+       *\n+       *  This hides both signatures of std::basic_ios::rdbuf().\n       */\n       __filebuf_type*\n       rdbuf() const\n       { return const_cast<__filebuf_type*>(&_M_filebuf); }\n \n       /**\n-       *  @brief Query to see if file stream is open.\n-       *  @return True if stream is open.\n+       *  @brief  Wrapper to test for an open file.\n+       *  @return  @c rdbuf()->is_open()\n       */\n       bool\n       is_open() { return _M_filebuf.is_open(); }\n \n       /**\n-       *  @brief Specify a file to open for input and/or output.\n-       *  @param  s  Null terminated string specifying filename.\n-       *  @param  mode  Mode in which to open file (see std::ios_base).\n+       *  @brief  Opens an external file.\n+       *  @param  s  The name of the file.\n+       *  @param  mode  The open mode flags.\n+       *\n+       *  Calls @c std::basic_filebuf::open(s,mode).  If that\n+       *  function fails, @c failbit is set in the stream's error state.\n        *\n        *  Tip:  When using std::string to hold the filename, you must use\n        *  .c_str() before passing it to this constructor.\n@@ -547,7 +800,12 @@ namespace std\n \t  setstate(ios_base::failbit);\n       }\n \n-      /** Close the file stream.  */\n+      /**\n+       *  @brief  Close the file.\n+       *\n+       *  Calls @c std::basic_filebuf::close().  If that function\n+       *  fails, @c failbit is set in the stream's error state.\n+      */\n       void\n       close()\n       {"}, {"sha": "26756a8041cc93cf5c3744d530dd36a6bbc15d07", "filename": "libstdc++-v3/include/std/std_iomanip.h", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/840ceb345b02d8f883b740949984878c9ed6f18e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_iomanip.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/840ceb345b02d8f883b740949984878c9ed6f18e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_iomanip.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_iomanip.h?ref=840ceb345b02d8f883b740949984878c9ed6f18e", "patch": "@@ -47,8 +47,18 @@\n \n namespace std\n {\n+  // [27.6.3] standard manipulators\n+  // Also see DR 183.\n+\n   struct _Resetiosflags { ios_base::fmtflags _M_mask; };\n \n+  /**\n+   *  @brief  Manipulator for @c setf.\n+   *  @param  mask  A format flags mask.\n+   *\n+   *  Sent to a stream object, this manipulator resets the specified flags,\n+   *  via @e stream.setf(0,mask).\n+  */\n   inline _Resetiosflags \n   resetiosflags(ios_base::fmtflags __mask)\n   { \n@@ -76,6 +86,13 @@ namespace std\n \n   struct _Setiosflags { ios_base::fmtflags _M_mask; };\n \n+  /**\n+   *  @brief  Manipulator for @c setf.\n+   *  @param  mask  A format flags mask.\n+   *\n+   *  Sent to a stream object, this manipulator sets the format flags\n+   *  to @a mask.\n+  */\n   inline _Setiosflags \n   setiosflags(ios_base::fmtflags __mask)\n   { \n@@ -103,6 +120,14 @@ namespace std\n \n   struct _Setbase { int _M_base; };\n \n+  /**\n+   *  @brief  Manipulator for @c setf.\n+   *  @param  base  A numeric base.\n+   *\n+   *  Sent to a stream object, this manipulator changes the\n+   *  @c ios_base::basefield flags to @c oct, @c dec, or @c hex when @a base\n+   *  is 8, 10, or 16, accordingly, and to 0 if @a base is any other value.\n+  */\n   inline _Setbase \n   setbase(int __base)\n   { \n@@ -137,6 +162,13 @@ namespace std\n   template<typename _CharT> \n     struct _Setfill { _CharT _M_c; };\n \n+  /**\n+   *  @brief  Manipulator for @c fill.\n+   *  @param  c  The new fill character.\n+   *\n+   *  Sent to a stream object, this manipulator calls @c fill(c) for that\n+   *  object.\n+  */\n   template<typename _CharT> \n     inline _Setfill<_CharT> \n     setfill(_CharT __c)\n@@ -165,6 +197,13 @@ namespace std\n \n   struct _Setprecision { int _M_n; };\n \n+  /**\n+   *  @brief  Manipulator for @c precision.\n+   *  @param  n  The new precision.\n+   *\n+   *  Sent to a stream object, this manipulator calls @c precision(n) for\n+   *  that object.\n+  */\n   inline _Setprecision \n   setprecision(int __n)\n   { \n@@ -192,6 +231,13 @@ namespace std\n \n   struct _Setw { int _M_n; };\n \n+  /**\n+   *  @brief  Manipulator for @c width.\n+   *  @param  n  The new width.\n+   *\n+   *  Sent to a stream object, this manipulator calls @c width(n) for\n+   *  that object.\n+  */\n   inline _Setw \n   setw(int __n)\n   { "}, {"sha": "124c8ffc5ff09e7ed37fcaca5e74418497c589f5", "filename": "libstdc++-v3/include/std/std_iosfwd.h", "status": "modified", "additions": 55, "deletions": 26, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/840ceb345b02d8f883b740949984878c9ed6f18e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_iosfwd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/840ceb345b02d8f883b740949984878c9ed6f18e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_iosfwd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_iosfwd.h?ref=840ceb345b02d8f883b740949984878c9ed6f18e", "patch": "@@ -102,35 +102,64 @@ namespace std\n   class ios_base; \n #endif\n \n-  typedef basic_ios<char> \t\tios;\n-  typedef basic_streambuf<char> \tstreambuf;\n-  typedef basic_istream<char> \t\tistream;\n-  typedef basic_ostream<char> \t\tostream;\n-  typedef basic_iostream<char> \t\tiostream;\n-  typedef basic_stringbuf<char> \tstringbuf;\n-  typedef basic_istringstream<char> \tistringstream;\n-  typedef basic_ostringstream<char> \tostringstream;\n-  typedef basic_stringstream<char> \tstringstream;\n-  typedef basic_filebuf<char> \t\tfilebuf;\n-  typedef basic_ifstream<char> \t\tifstream;\n-  typedef basic_ofstream<char> \t\tofstream;\n-  typedef basic_fstream<char> \t\tfstream;\n+  /** \n+   *  @defgroup s27_2_iosfwd I/O Forward Declarations\n+   *\n+   *  Nearly all of the I/O classes are parameterized on the type of\n+   *  characters they read and write.  (The major exception is ios_base at\n+   *  the top of the hierarchy.)  This is a change from pre-Standard\n+   *  streams, which were not templates.\n+   *\n+   *  For ease of use and compatibility, all of the basic_* I/O-related\n+   *  classes are given typedef names for both of the builtin character\n+   *  widths (wide and narrow).  The typedefs are the same as the\n+   *  pre-Standard names, for example:\n+   *\n+   *  @code\n+   *     typedef basic_ifstream<char>  ifstream;\n+   *  @endcode\n+   *\n+   *  Because properly forward-declaring these classes can be difficult, you\n+   *  should not do it yourself.  Instead, include the &lt;iosfwd&gt;\n+   *  header, which contains only declarations of all the I/O classes as\n+   *  well as the typedefs.  Trying to forward-declare the typedefs\n+   *  themselves (e.g., \"class ostream;\") is not valid ISO C++.\n+   *\n+   *  For more specific declarations, see\n+   *  http://gcc.gnu.org/onlinedocs/libstdc++/27_io/howto.html#10\n+   *\n+   *  @{\n+  */\n+  typedef basic_ios<char> \t\tios;\t\t///< @isiosfwd\n+  typedef basic_streambuf<char> \tstreambuf;\t///< @isiosfwd\n+  typedef basic_istream<char> \t\tistream;\t///< @isiosfwd\n+  typedef basic_ostream<char> \t\tostream;\t///< @isiosfwd\n+  typedef basic_iostream<char> \t\tiostream;\t///< @isiosfwd\n+  typedef basic_stringbuf<char> \tstringbuf;\t///< @isiosfwd\n+  typedef basic_istringstream<char> \tistringstream;\t///< @isiosfwd\n+  typedef basic_ostringstream<char> \tostringstream;\t///< @isiosfwd\n+  typedef basic_stringstream<char> \tstringstream;\t///< @isiosfwd\n+  typedef basic_filebuf<char> \t\tfilebuf;\t///< @isiosfwd\n+  typedef basic_ifstream<char> \t\tifstream;\t///< @isiosfwd\n+  typedef basic_ofstream<char> \t\tofstream;\t///< @isiosfwd\n+  typedef basic_fstream<char> \t\tfstream;\t///< @isiosfwd\n \n #ifdef _GLIBCPP_USE_WCHAR_T\n-  typedef basic_ios<wchar_t> \t\twios;\n-  typedef basic_streambuf<wchar_t> \twstreambuf;\n-  typedef basic_istream<wchar_t> \twistream;\n-  typedef basic_ostream<wchar_t> \twostream;\n-  typedef basic_iostream<wchar_t> \twiostream;\n-  typedef basic_stringbuf<wchar_t> \twstringbuf;\n-  typedef basic_istringstream<wchar_t> \twistringstream;\n-  typedef basic_ostringstream<wchar_t> \twostringstream;\n-  typedef basic_stringstream<wchar_t> \twstringstream;\n-  typedef basic_filebuf<wchar_t> \twfilebuf;\n-  typedef basic_ifstream<wchar_t> \twifstream;\n-  typedef basic_ofstream<wchar_t> \twofstream;\n-  typedef basic_fstream<wchar_t> \twfstream;\n+  typedef basic_ios<wchar_t> \t\twios;\t\t///< @isiosfwd\n+  typedef basic_streambuf<wchar_t> \twstreambuf;\t///< @isiosfwd\n+  typedef basic_istream<wchar_t> \twistream;\t///< @isiosfwd\n+  typedef basic_ostream<wchar_t> \twostream;\t///< @isiosfwd\n+  typedef basic_iostream<wchar_t> \twiostream;\t///< @isiosfwd\n+  typedef basic_stringbuf<wchar_t> \twstringbuf;\t///< @isiosfwd\n+  typedef basic_istringstream<wchar_t> \twistringstream;\t///< @isiosfwd\n+  typedef basic_ostringstream<wchar_t> \twostringstream;\t///< @isiosfwd\n+  typedef basic_stringstream<wchar_t> \twstringstream;\t///< @isiosfwd\n+  typedef basic_filebuf<wchar_t> \twfilebuf;\t///< @isiosfwd\n+  typedef basic_ifstream<wchar_t> \twifstream;\t///< @isiosfwd\n+  typedef basic_ofstream<wchar_t> \twofstream;\t///< @isiosfwd\n+  typedef basic_fstream<wchar_t> \twfstream;\t///< @isiosfwd\n #endif\n+  /** @}  */\n } // namespace std\n \n #endif"}, {"sha": "d70949377df146c413d4fb18ae13de8e1aa539fb", "filename": "libstdc++-v3/include/std/std_iostream.h", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/840ceb345b02d8f883b740949984878c9ed6f18e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_iostream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/840ceb345b02d8f883b740949984878c9ed6f18e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_iostream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_iostream.h?ref=840ceb345b02d8f883b740949984878c9ed6f18e", "patch": "@@ -47,17 +47,31 @@\n \n namespace std \n {\n-  extern istream cin;\n-  extern ostream cout;\n-  extern ostream cerr;\n-  extern ostream clog;\n+  /**\n+   *  @name Standard Stream Objects\n+   *\n+   *  The &lt;iostream&gt; header declares the eight <em>standard stream\n+   *  objects</em>.  For other declarations, see\n+   *  http://gcc.gnu.org/onlinedocs/libstdc++/27_io/howto.html#10 and the\n+   *  @link s27_2_iosfwd I/O forward declarations @endlink\n+   *\n+   *  They are required by default to cooperate with the global C library's\n+   *  @c FILE streams, and to be available during program startup and\n+   *  termination.  For more information, see the HOWTO linked to above.\n+  */\n+  //@{\n+  extern istream cin;\t\t///< Linked to standard input\n+  extern ostream cout;\t\t///< Linked to standard output\n+  extern ostream cerr;\t\t///< Linked to standard error (unbuffered)\n+  extern ostream clog;\t\t///< Linked to standard error (buffered)\n \n #ifdef _GLIBCPP_USE_WCHAR_T\n-  extern wistream wcin;\n-  extern wostream wcout;\n-  extern wostream wcerr;\n-  extern wostream wclog;\n+  extern wistream wcin;\t\t///< Linked to standard input\n+  extern wostream wcout;\t///< Linked to standard output\n+  extern wostream wcerr;\t///< Linked to standard error (unbuffered)\n+  extern wostream wclog;\t///< Linked to standard error (buffered)\n #endif\n+  //@}\n \n   // For construction of filebuffers for cout, cin, cerr, clog et. al.\n   static ios_base::Init __ioinit;"}, {"sha": "7e050322328530996fb9069a678e8ad595f1eda3", "filename": "libstdc++-v3/include/std/std_istream.h", "status": "modified", "additions": 496, "deletions": 20, "changes": 516, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/840ceb345b02d8f883b740949984878c9ed6f18e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_istream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/840ceb345b02d8f883b740949984878c9ed6f18e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_istream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_istream.h?ref=840ceb345b02d8f883b740949984878c9ed6f18e", "patch": "@@ -46,7 +46,14 @@\n \n namespace std\n {\n-  // 27.6.1.1 Template class basic_istream\n+  // [27.6.1.1] Template class basic_istream\n+  /**\n+   *  @brief  Controlling input.\n+   *\n+   *  This is the base class for all input streams.  It provides text\n+   *  formatting of all builtin types, and communicates with any class\n+   *  derived from basic_streambuf to do the actual input.\n+  */\n   template<typename _CharT, typename _Traits>\n     class basic_istream : virtual public basic_ios<_CharT, _Traits>\n     {\n@@ -68,27 +75,53 @@ namespace std\n \n     protected:\n       // Data Members:\n+      /**\n+       *  @if maint\n+       *  The number of characters extracted in the previous unformatted\n+       *  function; see gcount().\n+       *  @endif\n+      */\n       streamsize \t\t_M_gcount;\n \n     public:\n-      // 27.6.1.1.1 Constructor/destructor:\n+      // [27.6.1.1.1] constructor/destructor\n+      /**\n+       *  @brief  Base constructor.\n+       *\n+       *  This ctor is almost never called by the user directly, rather from\n+       *  derived classes' initialization lists, which pass a pointer to\n+       *  their own stream buffer.\n+      */\n       explicit \n       basic_istream(__streambuf_type* __sb)\n       { \n \tthis->init(__sb);\n \t_M_gcount = streamsize(0);\n       }\n \n+      /**\n+       *  @brief  Base destructor.\n+       *\n+       *  This does very little apart from providing a virtual base dtor.\n+      */\n       virtual \n       ~basic_istream() \n       { _M_gcount = streamsize(0); }\n \n-      // 27.6.1.1.2 Prefix/suffix:\n+      // [27.6.1.1.2] prefix/suffix\n       class sentry;\n       friend class sentry;\n \n-      // 27.6.1.2 Formatted input:\n-      // 27.6.1.2.3 basic_istream::operator>>\n+      // [27.6.1.2] formatted input\n+      // [27.6.1.2.3] basic_istream::operator>>\n+      //@{\n+      /**\n+       *  @brief  Interface for manipulators.\n+       *\n+       *  Manuipulators such as @c std::ws and @c std::dec use these\n+       *  functions in constructs like \"std::cin >> std::ws\".  For more\n+       *  information, see the iomanip header.\n+      */\n       __istream_type&\n       operator>>(__istream_type& (*__pf)(__istream_type&));\n \n@@ -97,8 +130,36 @@ namespace std\n \n       __istream_type&\n       operator>>(ios_base& (*__pf)(ios_base&));\n+      //@}\n       \n-      // 27.6.1.2.2 Arithmetic Extractors\n+      // [27.6.1.2.2] arithmetic extractors\n+      /**\n+       *  @name Arithmetic Extractors\n+       *\n+       *  All the @c operator>> functions (aka <em>formatted input\n+       *  functions</em>) have some common behavior.  Each starts by\n+       *  constructing a temporary object of type std::basic_istream::sentry\n+       *  with the second argument (noskipws) set to false.  This has several\n+       *  effects, concluding with the setting of a status flag; see the\n+       *  sentry documentation for more.\n+       *\n+       *  If the sentry status is good, the function tries to extract\n+       *  whatever data is appropriate for the type of the argument.\n+       *\n+       *  If an exception is thrown during extraction, ios_base::badbit\n+       *  will be turned on in the stream's error state without causing an\n+       *  ios_base::failure to be thrown.  The original exception will then\n+       *  be rethrown.\n+      */\n+      //@{\n+      /**\n+       *  @brief  Basic arithmetic extractors\n+       *  @param  A variable of builtin type.\n+       *  @return  @c *this if successful\n+       *\n+       *  These functions use the stream's current locale (specifically, the\n+       *  @c num_get facet) to parse the input data.\n+      */\n       __istream_type& \n       operator>>(bool& __n);\n       \n@@ -140,92 +201,444 @@ namespace std\n       __istream_type& \n       operator>>(void*& __p);\n \n+      /**\n+       *  @brief  Extracting into another streambuf.\n+       *  @param  sb  A pointer to a streambuf\n+       *\n+       *  This function behaves like one of the basic arithmetic extractors,\n+       *  in that it also constructs a sentry onject and has the same error\n+       *  handling behavior.\n+       *\n+       *  If @a sb is NULL, the stream will set failbit in its error state.\n+       *\n+       *  Characters are extracted from this stream and inserted into the\n+       *  @a sb streambuf until one of the following occurs:\n+       *\n+       *  - the input stream reaches end-of-file,\n+       *  - insertion into the output buffer fails (in this case, the\n+       *    character that would have been inserted is not extracted), or\n+       *  - an exception occurs (and in this case is caught)\n+       *\n+       *  If the function inserts no characters, failbit is set.\n+      */\n       __istream_type& \n       operator>>(__streambuf_type* __sb);\n+      //@}\n       \n-      // 27.6.1.3 Unformatted input:\n+      // [27.6.1.3] unformatted input\n+      /**\n+       *  @brief  Character counting\n+       *  @return  The number of characters extracted by the previous\n+       *           unformatted input function dispatched for this stream.\n+      */\n       inline streamsize \n-      gcount(void) const \n+      gcount() const \n       { return _M_gcount; }\n       \n+      /**\n+       *  @name Unformatted Input Functions\n+       *\n+       *  All the unformatted input functions have some common behavior.\n+       *  Each starts by constructing a temporary object of type\n+       *  std::basic_istream::sentry with the second argument (noskipws)\n+       *  set to true.  This has several effects, concluding with the\n+       *  setting of a status flag; see the sentry documentation for more.\n+       *\n+       *  If the sentry status is good, the function tries to extract\n+       *  whatever data is appropriate for the type of the argument.\n+       *\n+       *  The number of characters extracted is stored for later retrieval\n+       *  by gcount().\n+       *\n+       *  If an exception is thrown during extraction, ios_base::badbit\n+       *  will be turned on in the stream's error state without causing an\n+       *  ios_base::failure to be thrown.  The original exception will then\n+       *  be rethrown.\n+      */\n+      //@{\n+      /**\n+       *  @brief  Simple extraction.\n+       *  @return  A character, or eof().\n+       *\n+       *  Tries to extract a character.  If none are available, sets failbit\n+       *  and returns traits::eof().\n+      */\n       int_type \n-      get(void);\n-\n+      get();\n+\n+      /**\n+       *  @brief  Simple extraction.\n+       *  @param  c  The character in which to store data.\n+       *  @return  *this\n+       *\n+       *  Tries to extract a character and store it in @a c.  If none are\n+       *  available, sets failbit and returns traits::eof().\n+       *\n+       *  @note  This function is not overloaded on signed char and\n+       *         unsigned char.\n+      */\n       __istream_type& \n       get(char_type& __c);\n \n+      /**\n+       *  @brief  Simple multiple-character extraction.\n+       *  @param  s  Pointer to an array.\n+       *  @param  n  Maximum number of characters to store in @a s.\n+       *  @param  delim  A \"stop\" character.\n+       *  @return  *this\n+       *\n+       *  Characters are extracted and stored into @a s until one of the\n+       *  following happens:\n+       *\n+       *  - @c n-1 characters are stored\n+       *  - the input sequence reaches EOF\n+       *  - the next character equals @a delim, in which case the character\n+       *    is not extracted\n+       *\n+       * If no characters are stored, failbit is set in the stream's error\n+       * state.\n+       *\n+       * In any case, a null character is stored into the next location in\n+       * the array.\n+       *\n+       *  @note  This function is not overloaded on signed char and\n+       *         unsigned char.\n+      */\n       __istream_type& \n       get(char_type* __s, streamsize __n, char_type __delim);\n \n+      /**\n+       *  @brief  Simple multiple-character extraction.\n+       *  @param  s  Pointer to an array.\n+       *  @param  n  Maximum number of characters to store in @a s.\n+       *  @return  *this\n+       *\n+       *  Returns @c get(s,n,widen('\\n')).\n+      */\n       inline __istream_type& \n       get(char_type* __s, streamsize __n)\n       { return this->get(__s, __n, this->widen('\\n')); }\n \n+      /**\n+       *  @brief  Extraction into another streambuf.\n+       *  @param  sb  A streambuf in which to store data.\n+       *  @param  delim  A \"stop\" character.\n+       *  @return  *this\n+       *\n+       *  Characters are extracted and inserted into @a sb until one of the\n+       *  following happens:\n+       *\n+       *  - the input sequence reaches EOF\n+       *  - insertion into the output buffer fails (in this case, the\n+       *    character that would have been inserted is not extracted)\n+       *  - the next character equals @a delim (in this case, the character\n+       *    is not extracted)\n+       *  - an exception occurs (and in this case is caught)\n+       *\n+       * If no characters are stored, failbit is set in the stream's error\n+       * state.\n+      */\n       __istream_type&\n       get(__streambuf_type& __sb, char_type __delim);\n \n+      /**\n+       *  @brief  Extraction into another streambuf.\n+       *  @param  sb  A streambuf in which to store data.\n+       *  @return  *this\n+       *\n+       *  Returns @c get(sb,widen('\\n')).\n+      */\n       inline __istream_type&\n       get(__streambuf_type& __sb)\n       { return this->get(__sb, this->widen('\\n')); }\n \n+      /**\n+       *  @brief  String extraction.\n+       *  @param  s  A character array in which to store the data.\n+       *  @param  n  Maximum number of characters to extract.\n+       *  @param  delim  A \"stop\" character.\n+       *  @return  *this\n+       *\n+       *  Extracts and stores characters into @a s until one of the\n+       *  following happens.  Note that these criteria are required to be\n+       *  tested in the order listed here, to allow an input line to exactly\n+       *  fill the @a s array without setting failbit.\n+       *\n+       *  -# the input sequence reaches end-of-file, in which case eofbit\n+       *     is set in the stream error state\n+       *  -# the next character equals @c delim, in which case the character\n+       *     is extracted (and therefore counted in @c gcount()) but not stored\n+       *  -# @c n-1 characters are stored, in which case failbit is set\n+       *     in the stream error state\n+       *\n+       *  If no characters are extracted, failbit is set.  (An empty line of\n+       *  input should therefore not cause failbit to be set.)\n+       *\n+       *  In any case, a null character is stored in the next location in\n+       *  the array.\n+      */\n       __istream_type& \n       getline(char_type* __s, streamsize __n, char_type __delim);\n \n+      /**\n+       *  @brief  String extraction.\n+       *  @param  s  A character array in which to store the data.\n+       *  @param  n  Maximum number of characters to extract.\n+       *  @return  *this\n+       *\n+       *  Returns @c getline(s,n,widen('\\n')).\n+      */\n       inline __istream_type& \n       getline(char_type* __s, streamsize __n)\n       { return this->getline(__s, __n, this->widen('\\n')); }\n \n+      /**\n+       *  @brief  Discarding characters\n+       *  @param  n  Number of characters to discard.\n+       *  @param  delim  A \"stop\" character.\n+       *  @return  *this\n+       *\n+       *  Extracts characters and throws them away until one of the\n+       *  following happens:\n+       *  - if @a n @c != @c std::numeric_limits<int>::max(), @a n\n+       *    characters are extracted\n+       *  - the input sequence reaches end-of-file\n+       *  - the next character equals @a delim (in this case, the character\n+       *    is extracted); note that this condition will never occur if\n+       *    @a delim equals @c traits::eof().\n+      */\n       __istream_type& \n       ignore(streamsize __n = 1, int_type __delim = traits_type::eof());\n       \n+      /**\n+       *  @brief  Looking ahead in the stream\n+       *  @return  The next character, or eof().\n+       *\n+       *  If, after constructing the sentry object, @c good() is false,\n+       *  returns @c traits::eof().  Otherwise reads but does not extract\n+       *  the next input character.\n+      */\n       int_type \n-      peek(void);\n+      peek();\n       \n+      /**\n+       *  @brief  Extraction without delimiters.\n+       *  @param  s  A character array.\n+       *  @param  n  Maximum number of characters to store.\n+       *  @return  *this\n+       *\n+       *  If the stream state is @c good(), extracts characters and stores\n+       *  them into @a s until one of the following happens:\n+       *  - @a n characters are stored\n+       *  - the input sequence reaches end-of-file, in which case the error\n+       *    state is set to @c failbit|eofbit.\n+       *\n+       *  @note  This function is not overloaded on signed char and\n+       *         unsigned char.\n+      */\n       __istream_type& \n       read(char_type* __s, streamsize __n);\n \n+      /**\n+       *  @brief  Extraction until the buffer is exhausted, but no more.\n+       *  @param  s  A character array.\n+       *  @param  n  Maximum number of characters to store.\n+       *  @return  The number of characters extracted.\n+       *\n+       *  Extracts characters and stores them into @a s depending on the\n+       *  number of characters remaining in the streambuf's buffer,\n+       *  @c rdbuf()->in_avail(), called @c A here:\n+       *  - if @c A @c == @c -1, sets eofbit and extracts no characters\n+       *  - if @c A @c == @c 0, extracts no characters\n+       *  - if @c A @c > @c 0, extracts @c min(A,n)\n+       *\n+       *  The goal is to empty the current buffer, and to not request any\n+       *  more from the external input sequence controlled by the streambuf.\n+      */\n       streamsize \n       readsome(char_type* __s, streamsize __n);\n       \n+      /**\n+       *  @brief  Unextracting a single character.\n+       *  @param  c  The character to push back into the input stream.\n+       *  @return  *this\n+       *\n+       *  If @c rdbuf() is not null, calls @c rdbuf()->sputbackc(c).\n+       *\n+       *  If @c rdbuf() is null or if @c sputbackc() fails, sets badbit in\n+       *  the error state.\n+       *\n+       *  @note  Since no characters are extracted, the next call to\n+       *         @c gcount() will return 0, as required by DR 60.\n+       *\n+       *  @if maint\n+       *  FIXME We don't comply with DR 60 here, _M_gcount is untouched.\n+       *  @endif\n+      */\n       __istream_type& \n       putback(char_type __c);\n \n+      /**\n+       *  @brief  Unextracting the previous character.\n+       *  @return  *this\n+       *\n+       *  If @c rdbuf() is not null, calls @c rdbuf()->sungetc(c).\n+       *\n+       *  If @c rdbuf() is null or if @c sungetc() fails, sets badbit in\n+       *  the error state.\n+       *\n+       *  @note  Since no characters are extracted, the next call to\n+       *         @c gcount() will return 0, as required by DR 60.\n+      */\n       __istream_type& \n-      unget(void);\n-\n+      unget();\n+\n+      /**\n+       *  @brief  Synchronizing the stream buffer.\n+       *  @return  0 on success, -1 on failure\n+       *\n+       *  If @c rdbuf() is a null pointer, returns -1.\n+       *\n+       *  Otherwise, calls @c rdbuf()->pubsync(), and if that returns -1,\n+       *  sets badbit and returns -1.\n+       *\n+       *  Otherwise, returns 0.\n+       *\n+       *  @note  This function does not count the number of characters\n+       *         extracted, if any, and therefore does not affect the next\n+       *         call to @c gcount().\n+       *  @if maint\n+       *  FIXME We don't comply with DR 60 here, _M_gcount is zeroed.\n+       *  @endif\n+      */\n       int \n-      sync(void);\n-\n+      sync();\n+\n+      /**\n+       *  @brief  Getting the current read position.\n+       *  @return  A file position object.\n+       *\n+       *  If @c fail() is not false, returns @c pos_type(-1) to indicate\n+       *  failure.  Otherwise returns @c rdbuf()->pubseekoff(0,cur,in).\n+       *\n+       *  @note  This function does not count the number of characters\n+       *         extracted, if any, and therefore does not affect the next\n+       *         call to @c gcount().\n+      */\n       pos_type \n-      tellg(void);\n-\n+      tellg();\n+\n+      /**\n+       *  @brief  Changing the current read position.\n+       *  @param  pos  A file position object.\n+       *  @return  *this\n+       *\n+       *  If @c fail() is not true, calls @c rdbuf()->pubseekpos(pos).  If\n+       *  that function fails, sets failbit.\n+       *\n+       *  @note  This function does not count the number of characters\n+       *         extracted, if any, and therefore does not affect the next\n+       *         call to @c gcount().\n+       *  @if maint\n+       *  FIXME We don't comply with DR 60 here, _M_gcount is zeroed.\n+       *  @endif\n+      */\n       __istream_type& \n       seekg(pos_type);\n \n+      /**\n+       *  @brief  Changing the current read position.\n+       *  @param  off  A file offset object.\n+       *  @param  dir  The direction in which to seek.\n+       *  @return  *this\n+       *\n+       *  If @c fail() is not true, calls @c rdbuf()->pubseekoff(off,dir).\n+       *  If that function fails, sets failbit.\n+       *\n+       *  @note  This function does not count the number of characters\n+       *         extracted, if any, and therefore does not affect the next\n+       *         call to @c gcount().\n+       *  @if maint\n+       *  FIXME We don't comply with DR 60 here, _M_gcount is zeroed.\n+       *  @endif\n+      */\n       __istream_type& \n       seekg(off_type, ios_base::seekdir);\n+      //@}\n     };\n   \n+  /**\n+   *  @brief  Performs setup work for input streams.\n+   *\n+   *  Objects of this class are created before all of the standard\n+   *  extractors are run.  It is responsible for \"exception-safe prefix and\n+   *  suffix operations,\" although only prefix actions are currently required\n+   *  by the standard.  Additional actions may be added by the\n+   *  implementation, and we list them in\n+   *  http://gcc.gnu.org/onlinedocs/libstdc++/17_intro/howto.html#5\n+   *  under [27.6] notes.\n+  */\n   template<typename _CharT, typename _Traits>\n     class basic_istream<_CharT, _Traits>::sentry\n     {\n     public:\n+      /// Easy access to dependant types.\n       typedef _Traits \t\t\t\t\ttraits_type;\n       typedef basic_streambuf<_CharT, _Traits> \t\t__streambuf_type;\n       typedef basic_istream<_CharT, _Traits> \t\t__istream_type;\n       typedef typename __istream_type::__ctype_type \t__ctype_type;\n       typedef typename _Traits::int_type\t\t__int_type;\n \n+      /**\n+       *  @brief  The constructor performs all the work.\n+       *  @param  is  The input stream to guard.\n+       *  @param  noskipws  Whether to consume whitespace or not.\n+       *\n+       *  If the stream state is good (@a is.good() is true), then the\n+       *  following actions are performed, otherwise the sentry state is\n+       *  false (\"not okay\") and failbit is set in the stream state.\n+       *\n+       *  The sentry's preparatory actions are:\n+       *\n+       *  -# if the stream is tied to an output stream, @c is.tie()->flush()\n+       *     is called to synchronize the output sequence\n+       *  -# if @a noskipws is false, and @c ios_base::skipws is set in\n+       *     @c is.flags(), the sentry extracts and discards whitespace\n+       *     characters from the stream.  The currently imbued locale is\n+       *     used to determine whether each character is whitespace.\n+       *\n+       *  If the stream state is still good, then the sentry state becomes\n+       *  true (\"okay\").\n+      */\n       explicit \n       sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws = false);\n \n+      /**\n+       *  @brief  Quick status checking.\n+       *  @return  The sentry state.\n+       *\n+       *  For ease of use, sentries may be converted to booleans.  The\n+       *  return value is that of the sentry state (true == okay).\n+      */\n       operator bool() { return _M_ok; }\n \n     private:\n       bool _M_ok;\n     };\n \n-  // 27.6.1.2.3 Character extraction templates\n+  // [27.6.1.2.3] character extraction templates\n+  //@{\n+  /**\n+   *  @brief  Character extractors\n+   *  @param  in  An input stream.\n+   *  @param  c  A character reference.\n+   *  @return  in\n+   *\n+   *  Behaves like one of the formatted arithmetic extractors described in\n+   *  std::basic_istream.  After constructing a sentry object with good\n+   *  status, this function extracts a character (if one is available) and\n+   *  stores it in @a c.  Otherwise, sets failbit in the input stream.\n+  */\n   template<typename _CharT, typename _Traits>\n     basic_istream<_CharT, _Traits>&\n     operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c);\n@@ -239,7 +652,34 @@ namespace std\n     basic_istream<char, _Traits>&\n     operator>>(basic_istream<char, _Traits>& __in, signed char& __c)\n     { return (__in >> reinterpret_cast<char&>(__c)); }\n-\n+  //@}\n+\n+  //@{\n+  /**\n+   *  @brief  Character string extractors\n+   *  @param  in  An input stream.\n+   *  @param  s  A pointer to a character array.\n+   *  @return  in\n+   *\n+   *  Behaves like one of the formatted arithmetic extractors described in\n+   *  std::basic_istream.  After constructing a sentry object with good\n+   *  status, this function extracts up to @c n characters and stores them\n+   *  into the array starting at @a s.  @c n is defined as:\n+   *\n+   *  - if @c width() is greater than zero, @c n is width()\n+   *  - otherwise @c n is \"the number of elements of the largest array of\n+   *    @c char_type that can store a terminating @c eos.\" [27.6.1.2.3]/6\n+   *\n+   *  Characters are extracted and stored until one of the following happens:\n+   *  - @c n-1 characters are stored\n+   *  - EOF is reached\n+   *  - the next character is whitespace according to the current locale\n+   *  - the next character is a null byte (i.e., @c charT() )\n+   *\n+   *  @c width(0) is then called for the input stream.\n+   *\n+   *  If no characters are extracted, sets failbit.\n+  */\n   template<typename _CharT, typename _Traits>\n     basic_istream<_CharT, _Traits>&\n     operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s);\n@@ -253,8 +693,15 @@ namespace std\n     basic_istream<char,_Traits>&\n     operator>>(basic_istream<char,_Traits>& __in, signed char* __s)\n     { return (__in >> reinterpret_cast<char*>(__s)); }\n+  //@}\n \n   // 27.6.1.5 Template class basic_iostream\n+  /**\n+   *  @brief  Merging istream and ostream capabilities.\n+   *\n+   *  This class multiply inherits from the input and output stream classes\n+   *  simply to provide a single interface.\n+  */\n   template<typename _CharT, typename _Traits>\n     class basic_iostream\n     : public basic_istream<_CharT, _Traits>, \n@@ -275,16 +722,45 @@ namespace std\n       typedef basic_istream<_CharT, _Traits>\t\t__istream_type;\n       typedef basic_ostream<_CharT, _Traits>\t\t__ostream_type;\n \n+      /**\n+       *  @brief  Constructor does nothing.\n+       *\n+       *  Both of the parent classes are initialized with the same\n+       *  streambuf pointer passed to this constructor.\n+      */\n       explicit \n       basic_iostream(basic_streambuf<_CharT, _Traits>* __sb)\n       : __istream_type(__sb), __ostream_type(__sb)\n       { }\n \n+      /**\n+       *  @brief  Destructor does nothing.\n+      */\n       virtual \n       ~basic_iostream() { }\n     };\n \n-  // 27.6.1.4 Standard basic_istream manipulators\n+  // [27.6.1.4] standard basic_istream manipulators\n+  /**\n+   *  @brief  Quick and easy way to eat whitespace\n+   *\n+   *  This manipulator extracts whitespace characters, stopping when the\n+   *  next character is non-whitespace, or when the input sequence is empty.\n+   *  If the sequence is empty, @c eofbit is set in the stream, but not\n+   *  @c failbit.\n+   *\n+   *  The current locale is used to distinguish whitespace characters.\n+   *\n+   *  Example:\n+   *  @code\n+   *     MyClass   mc;\n+   *\n+   *     std::cin >> std::ws >> mc;\n+   *  @endcode\n+   *  will skip leading whitespace before calling operator>> on cin and your\n+   *  object.  Note that the same effect can be achieved by creating a\n+   *  std::basic_istream::sentry inside your definition of operator>>.\n+  */\n   template<typename _CharT, typename _Traits>\n     basic_istream<_CharT, _Traits>& \n     ws(basic_istream<_CharT, _Traits>& __is);"}, {"sha": "7a5532961024b4c19ec069a9636a1c448213a114", "filename": "libstdc++-v3/include/std/std_ostream.h", "status": "modified", "additions": 255, "deletions": 15, "changes": 270, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/840ceb345b02d8f883b740949984878c9ed6f18e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_ostream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/840ceb345b02d8f883b740949984878c9ed6f18e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_ostream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_ostream.h?ref=840ceb345b02d8f883b740949984878c9ed6f18e", "patch": "@@ -46,7 +46,14 @@\n \n namespace std\n {\n-  // 27.6.2.1 Template class basic_ostream\n+  // [27.6.2.1] Template class basic_ostream\n+  /**\n+   *  @brief  Controlling output.\n+   *\n+   *  This is the base class for all output streams.  It provides text\n+   *  formatting of all builtin types, and communicates with any class\n+   *  derived from basic_streambuf to do the actual output.\n+  */\n   template<typename _CharT, typename _Traits>\n     class basic_ostream : virtual public basic_ios<_CharT, _Traits>\n     {\n@@ -66,20 +73,40 @@ namespace std\n       typedef num_put<_CharT, __ostreambuf_iter>        __numput_type;\n       typedef ctype<_CharT>           \t\t\t__ctype_type;\n \n-      // 27.6.2.2 Constructor/destructor:\n+      // [27.6.2.2] constructor/destructor\n+      /**\n+       *  @brief  Base constructor.\n+       *\n+       *  This ctor is almost never called by the user directly, rather from\n+       *  derived classes' initialization lists, which pass a pointer to\n+       *  their own stream buffer.\n+      */\n       explicit \n       basic_ostream(__streambuf_type* __sb)\n       { this->init(__sb); }\n \n+      /**\n+       *  @brief  Base destructor.\n+       *\n+       *  This does very little apart from providing a virtual base dtor.\n+      */\n       virtual \n       ~basic_ostream() { }\n \n-      // 27.6.2.3 Prefix/suffix:\n+      // [27.6.2.3] prefix/suffix\n       class sentry;\n       friend class sentry;\n       \n-      // 27.6.2.5 Formatted output:\n-      // 27.6.2.5.3  basic_ostream::operator<<\n+      // [27.6.2.5] formatted output\n+      // [27.6.2.5.3]  basic_ostream::operator<<\n+      //@{\n+      /**\n+       *  @brief  Interface for manipulators.\n+       *\n+       *  Manuipulators such as @c std::endl and @c std::hex use these\n+       *  functions in constructs like \"std::cout << std::endl\".  For more\n+       *  information, see the iomanip header.\n+      */\n       __ostream_type&\n       operator<<(__ostream_type& (*__pf)(__ostream_type&));\n       \n@@ -88,8 +115,35 @@ namespace std\n       \n       __ostream_type&\n       operator<<(ios_base& (*__pf) (ios_base&));\n-\n-      // 27.6.2.5.2 Arithmetic Inserters\n+      //@}\n+\n+      // [27.6.2.5.2] arithmetic inserters\n+      /**\n+       *  @name Arithmetic Inserters\n+       *\n+       *  All the @c operator<< functions (aka <em>formatted output\n+       *  functions</em>) have some common behavior.  Each starts by\n+       *  constructing a temporary object of type std::basic_ostream::sentry.\n+       *  This can have several effects, concluding with the setting of a\n+       *  status flag; see the sentry documentation for more.\n+       *\n+       *  If the sentry status is good, the function tries to generate\n+       *  whatever data is appropriate for the type of the argument.\n+       *\n+       *  If an exception is thrown during insertion, ios_base::badbit\n+       *  will be turned on in the stream's error state without causing an\n+       *  ios_base::failure to be thrown.  The original exception will then\n+       *  be rethrown.\n+      */\n+      //@{\n+      /**\n+       *  @brief  Basic arithmetic inserters\n+       *  @param  A variable of builtin type.\n+       *  @return  @c *this if successful\n+       *\n+       *  These functions use the stream's current locale (specifically, the\n+       *  @c num_get facet) to perform numeric formatting.\n+      */\n       __ostream_type& \n       operator<<(long __n);\n       \n@@ -150,31 +204,140 @@ namespace std\n       __ostream_type& \n       operator<<(const void* __p);\n \n+      /**\n+       *  @brief  Extracting from another streambuf.\n+       *  @param  sb  A pointer to a streambuf\n+       *\n+       *  This function behaves like one of the basic arithmetic extractors,\n+       *  in that it also constructs a sentry onject and has the same error\n+       *  handling behavior.\n+       *\n+       *  If @a sb is NULL, the stream will set failbit in its error state.\n+       *\n+       *  Characters are extracted from @a sb and inserted into @c *this\n+       *  until one of the following occurs:\n+       *\n+       *  - the input stream reaches end-of-file,\n+       *  - insertion into the output sequence fails (in this case, the\n+       *    character that would have been inserted is not extracted), or\n+       *  - an exception occurs while getting a character from @a sb, which\n+       *    sets failbit in the error state\n+       *\n+       *  If the function inserts no characters, failbit is set.\n+      */\n       __ostream_type& \n       operator<<(__streambuf_type* __sb);\n-\n-      // Unformatted output:\n+      //@}\n+\n+      // [27.6.2.6] unformatted output functions\n+      /**\n+       *  @name Unformatted Output Functions\n+       *\n+       *  All the unformatted output functions have some common behavior.\n+       *  Each starts by constructing a temporary object of type\n+       *  std::basic_ostream::sentry.  This has several effects, concluding\n+       *  with the setting of a status flag; see the sentry documentation\n+       *  for more.\n+       *\n+       *  If the sentry status is good, the function tries to generate\n+       *  whatever data is appropriate for the type of the argument.\n+       *\n+       *  If an exception is thrown during insertion, ios_base::badbit\n+       *  will be turned on in the stream's error state.  If badbit is on in\n+       *  the stream's exceptions mask, the exception will be rethrown\n+       *  without completing its actions.\n+      */\n+      //@{\n+      /**\n+       *  @brief  Simple insertion.\n+       *  @param  c  The character to insert.\n+       *  @return  *this\n+       *\n+       *  Tries to insert @a c.\n+       *\n+       *  @note  This function is not overloaded on signed char and\n+       *         unsigned char.\n+      */\n       __ostream_type& \n       put(char_type __c);\n \n+      /**\n+       *  @brief  Character string insertion.\n+       *  @param  s  The array to insert.\n+       *  @param  n  Maximum number of characters to insert.\n+       *  @return  *this\n+       *\n+       *  Characters are copied from @a s and inserted into the stream until\n+       *  one of the following happens:\n+       *\n+       *  - @a n characters are inserted\n+       *  - inserting into the output sequence fails (in this case, badbit\n+       *    will be set in the stream's error state)\n+       *\n+       *  @note  This function is not overloaded on signed char and\n+       *         unsigned char.\n+      */\n       __ostream_type& \n       write(const char_type* __s, streamsize __n);\n-\n+      //@}\n+\n+      /**\n+       *  @brief  Synchronizing the stream buffer.\n+       *  @return  *this\n+       *\n+       *  If @c rdbuf() is a null pointer, changes nothing.\n+       *\n+       *  Otherwise, calls @c rdbuf()->pubsync(), and if that returns -1,\n+       *  sets badbit.\n+      */\n       __ostream_type& \n       flush();\n \n-      // Seeks:\n+      // [27.6.2.4] seek members\n+      /**\n+       *  @brief  Getting the current write position.\n+       *  @return  A file position object.\n+       *\n+       *  If @c fail() is not false, returns @c pos_type(-1) to indicate\n+       *  failure.  Otherwise returns @c rdbuf()->pubseekoff(0,cur,out).\n+      */\n       pos_type \n       tellp();\n \n+      /**\n+       *  @brief  Changing the current write position.\n+       *  @param  pos  A file position object.\n+       *  @return  *this\n+       *\n+       *  If @c fail() is not true, calls @c rdbuf()->pubseekpos(pos).  If\n+       *  that function fails, sets failbit.\n+      */\n       __ostream_type& \n       seekp(pos_type);\n \n-      __ostream_type& \n+      /**\n+       *  @brief  Changing the current write position.\n+       *  @param  off  A file offset object.\n+       *  @param  dir  The direction in which to seek.\n+       *  @return  *this\n+       *\n+       *  If @c fail() is not true, calls @c rdbuf()->pubseekoff(off,dir).\n+       *  If that function fails, sets failbit.\n+      */\n+       __ostream_type& \n       seekp(off_type, ios_base::seekdir);\n     };\n \n-  // 27.6.2.3  Class basic_ostream::sentry\n+  /**\n+   *  @brief  Performs setup work for output streams.\n+   *\n+   *  Objects of this class are created before all of the standard\n+   *  inserters are run.  It is responsible for \"exception-safe prefix and\n+   *  suffix operations.\"  Additional actions may be added by the\n+   *  implementation, and we list them in\n+   *  http://gcc.gnu.org/onlinedocs/libstdc++/17_intro/howto.html#5\n+   *  under [27.6] notes.\n+  */\n   template <typename _CharT, typename _Traits>\n     class basic_ostream<_CharT, _Traits>::sentry\n     {\n@@ -183,9 +346,27 @@ namespace std\n       basic_ostream<_CharT,_Traits>& \t_M_os;\n       \n     public:\n+      /**\n+       *  @brief  The constructor performs preparatory work.\n+       *  @param  os  The output stream to guard.\n+       *\n+       *  If the stream state is good (@a os.good() is true), then if the\n+       *  stream is tied to another output stream, @c is.tie()->flush()\n+       *  is called to synchronize the output sequences.\n+       *\n+       *  If the stream state is still good, then the sentry state becomes\n+       *  true (\"okay\").\n+      */\n       explicit\n       sentry(basic_ostream<_CharT,_Traits>& __os);\n \n+      /**\n+       *  @brief  Possibly flushes the stream.\n+       *\n+       *  If @c ios_base::unitbuf is set in @c os.flags(), and\n+       *  @c std::uncaught_exception() is true, the sentry destructor calls\n+       *  @c flush() on the output stream.\n+      */\n       ~sentry()\n       {\n \t// XXX MT\n@@ -197,10 +378,34 @@ namespace std\n \t  }\n       }\n \n+      /**\n+       *  @brief  Quick status checking.\n+       *  @return  The sentry state.\n+       *\n+       *  For ease of use, sentries may be converted to booleans.  The\n+       *  return value is that of the sentry state (true == okay).\n+      */\n       operator bool() \n       { return _M_ok; }\n     };\n \n+  // [27.6.2.5.4] character insertion templates\n+  //@{\n+  /**\n+   *  @brief  Character inserters\n+   *  @param  out  An output stream.\n+   *  @param  c  A character.\n+   *  @return  out\n+   *\n+   *  Behaves like one of the formatted arithmetic inserters described in\n+   *  std::basic_ostream.  After constructing a sentry object with good\n+   *  status, this function inserts a single character and any required\n+   *  padding (as determined by [22.2.2.2.2]).  @c out.width(0) is then\n+   *  called.\n+   *\n+   *  If @a c is of type @c char and the character type of the stream is not\n+   *  @c char, the character is widened before insertion.\n+  */\n   template<typename _CharT, typename _Traits>\n     basic_ostream<_CharT, _Traits>&\n     operator<<(basic_ostream<_CharT, _Traits>& __out, _CharT __c);\n@@ -225,7 +430,22 @@ namespace std\n     basic_ostream<char, _Traits>&\n     operator<<(basic_ostream<char, _Traits>& __out, unsigned char __c)\n     { return (__out << static_cast<char>(__c)); }\n+  //@}\n   \n+  //@{\n+  /**\n+   *  @brief  String inserters\n+   *  @param  out  An output stream.\n+   *  @param  s  A character string.\n+   *  @return  out\n+   *  @pre  @a s must be a non-NULL pointer\n+   *\n+   *  Behaves like one of the formatted arithmetic inserters described in\n+   *  std::basic_ostream.  After constructing a sentry object with good\n+   *  status, this function inserts @c traits::length(s) characters starting\n+   *  at @a s, widened if necessary, followed by any required padding (as\n+   *  determined by [22.2.2.2.2]).  @c out.width(0) is then called.\n+  */\n   template<typename _CharT, typename _Traits>\n     basic_ostream<_CharT, _Traits>&\n     operator<<(basic_ostream<_CharT, _Traits>& __out, const _CharT* __s);\n@@ -249,18 +469,38 @@ namespace std\n     basic_ostream<char, _Traits> &\n     operator<<(basic_ostream<char, _Traits>& __out, const unsigned char* __s)\n     { return (__out << reinterpret_cast<const char*>(__s)); }\n-\n-  // 27.6.2.7 Standard basic_ostream manipulators\n+  //@}\n+\n+  // [27.6.2.7] standard basic_ostream manipulators\n+  /**\n+   *  @brief  Write a newline and flush the stream.\n+   *\n+   *  This manipulator is often mistakenly used when a simple newline is\n+   *  desired, leading to poor buffering performance.  See\n+   *  http://gcc.gnu.org/onlinedocs/libstdc++/27_io/howto.html#2 for more\n+   *  on this subject.\n+  */\n   template<typename _CharT, typename _Traits>\n     basic_ostream<_CharT, _Traits>& \n     endl(basic_ostream<_CharT, _Traits>& __os)\n     { return flush(__os.put(__os.widen('\\n'))); }\n \n+  /**\n+   *  @brief  Write a null character into the output sequence.\n+   *\n+   *  \"Null character\" is @c CharT() by definition.  For CharT of @c char,\n+   *  this correctly writes the ASCII @c NUL character string terminator.\n+  */\n   template<typename _CharT, typename _Traits>\n     basic_ostream<_CharT, _Traits>& \n     ends(basic_ostream<_CharT, _Traits>& __os)\n     { return __os.put(_CharT()); }\n   \n+  /**\n+   *  @brief  Flushes the output stream.\n+   *\n+   *  This manipulator simply calls the stream's @c flush() member function.\n+  */\n   template<typename _CharT, typename _Traits>\n     basic_ostream<_CharT, _Traits>& \n     flush(basic_ostream<_CharT, _Traits>& __os)"}, {"sha": "aaec83f082b45b9e9fa978fa44f537df5f751a98", "filename": "libstdc++-v3/include/std/std_sstream.h", "status": "modified", "additions": 272, "deletions": 5, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/840ceb345b02d8f883b740949984878c9ed6f18e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_sstream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/840ceb345b02d8f883b740949984878c9ed6f18e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_sstream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_sstream.h?ref=840ceb345b02d8f883b740949984878c9ed6f18e", "patch": "@@ -46,6 +46,18 @@\n \n namespace std\n {\n+  // [27.7.1] template class basic_stringbuf\n+  /**\n+   *  @brief  The actual work of input and output (for std::string).\n+   *\n+   *  This class associates either or both of its input and output sequences\n+   *  with a sequence of characters, which can be initialized from, or made\n+   *  available as, a @c std::basic_string.  (Paraphrased from [27.7.1]/1.)\n+   *\n+   *  For this class, open modes (of type @c ios_base::openmode) have\n+   *  @c in set if the input sequence can be read, and @c out set if the\n+   *  output sequence can be written.\n+  */\n   template<typename _CharT, typename _Traits, typename _Alloc>\n     class basic_stringbuf : public basic_streambuf<_CharT, _Traits>\n     {\n@@ -61,29 +73,63 @@ namespace std\n       typedef typename traits_type::pos_type \t\tpos_type;\n       typedef typename traits_type::off_type \t\toff_type;\n \n-      // Non-standard Types:\n+      //@{\n+      /**\n+       *  @if maint\n+       *  @doctodo\n+       *  @endif\n+      */\n       typedef basic_streambuf<char_type, traits_type>  \t__streambuf_type;\n       typedef basic_string<char_type, _Traits, _Alloc> \t__string_type;\n       typedef typename __string_type::size_type\t\t__size_type;\n+      //@}\n \n     protected:\n       // Data Members:\n+      /**\n+       *  @if maint\n+       *  @doctodo\n+       *  @endif\n+      */\n       __string_type \t\t_M_string;\n \n     public:\n       // Constructors:\n+      /**\n+       *  @brief  Starts with an empty string buffer.\n+       *  @param  mode  Whether the buffer can read, or write, or both.\n+       *\n+       *  The default constructor initializes the parent class using its\n+       *  own default ctor.\n+      */\n       explicit\n       basic_stringbuf(ios_base::openmode __mode = ios_base::in | ios_base::out)\n       : __streambuf_type(), _M_string()\n       { _M_stringbuf_init(__mode); }\n \n+      /**\n+       *  @brief  Starts with an existing string buffer.\n+       *  @param  str  A string to copy as a starting buffer.\n+       *  @param  mode  Whether the buffer can read, or write, or both.\n+       *\n+       *  This constructor initializes the parent class using its\n+       *  own default ctor.\n+      */\n       explicit\n       basic_stringbuf(const __string_type& __str,\n \t\t      ios_base::openmode __mode = ios_base::in | ios_base::out)\n       : __streambuf_type(), _M_string(__str.data(), __str.size())\n       { _M_stringbuf_init(__mode); }\n \n       // Get and set:\n+      /**\n+       *  @brief  Copying out the string buffer.\n+       *  @return  A copy of one of the underlying sequences.\n+       *\n+       *  \"If the buffer is only created in input mode, the underlying\n+       *  character sequence is equal to the input sequence; otherwise, it\n+       *  is equal to the output sequence.\" [27.7.1.2]/1\n+      */\n       __string_type\n       str() const\n       {\n@@ -102,6 +148,13 @@ namespace std\n \t  return _M_string;\n       }\n \n+      /**\n+       *  @brief  Setting a new buffer.\n+       *  @param  s  The string to use as a new sequence.\n+       *\n+       *  Deallocates any previous stored sequence, then copies @a s to\n+       *  use as a new one.\n+      */\n       void\n       str(const __string_type& __s)\n       {\n@@ -112,6 +165,11 @@ namespace std\n \n     protected:\n       // Common initialization code for both ctors goes here.\n+      /**\n+       *  @if maint\n+       *  @doctodo\n+       *  @endif\n+      */\n       void\n       _M_stringbuf_init(ios_base::openmode __mode)\n       {\n@@ -135,6 +193,7 @@ namespace std\n       }\n \n       // Overridden virtual functions:\n+      // [documentation is inherited]\n       virtual int_type\n       underflow()\n       {\n@@ -144,12 +203,25 @@ namespace std\n \t  return traits_type::eof();\n       }\n \n+      // [documentation is inherited]\n       virtual int_type\n       pbackfail(int_type __c = traits_type::eof());\n \n+      // [documentation is inherited]\n       virtual int_type\n       overflow(int_type __c = traits_type::eof());\n \n+      /**\n+       *  @brief  Manipulates the buffer.\n+       *  @param  s  Pointer to a buffer area.\n+       *  @param  n  Size of @a s.\n+       *  @return  @c this\n+       *\n+       *  If no buffer has already been created, and both @a s and @a n are\n+       *  non-zero, then @c s is used as a buffer; see\n+       *  http://gcc.gnu.org/onlinedocs/libstdc++/27_io/howto.html#2\n+       *  for more.\n+      */\n       virtual __streambuf_type*\n       setbuf(char_type* __s, streamsize __n)\n       {\n@@ -161,10 +233,12 @@ namespace std\n \treturn this;\n       }\n \n+      // [documentation is inherited]\n       virtual pos_type\n       seekoff(off_type __off, ios_base::seekdir __way,\n \t      ios_base::openmode __mode = ios_base::in | ios_base::out);\n \n+      // [documentation is inherited]\n       virtual pos_type\n       seekpos(pos_type __sp,\n \t      ios_base::openmode __mode = ios_base::in | ios_base::out);\n@@ -175,6 +249,11 @@ namespace std\n       // Assumes: contents of _M_string and internal buffer match exactly.\n       // __i == _M_in_cur - _M_in_beg\n       // __o == _M_out_cur - _M_out_beg\n+      /**\n+       *  @if maint\n+       *  @doctodo\n+       *  @endif\n+      */\n       virtual int\n       _M_really_sync(__size_type __i, __size_type __o)\n       {\n@@ -196,7 +275,15 @@ namespace std\n     };\n \n \n-  // 27.7.2  Template class basic_istringstream\n+  // [27.7.2] Template class basic_istringstream\n+  /**\n+   *  @brief  Controlling input for std::string.\n+   *\n+   *  This class supports reading from objects of type std::basic_string,\n+   *  using the inherited functions from std::basic_istream.  To control\n+   *  the associated sequence, an instance of std::basic_stringbuf is used,\n+   *  which this page refers to as @c sb.\n+  */\n   template<typename _CharT, typename _Traits, typename _Alloc>\n     class basic_istringstream : public basic_istream<_CharT, _Traits>\n     {\n@@ -218,40 +305,104 @@ namespace std\n       typedef basic_istream<char_type, traits_type>\t__istream_type;\n \n     private:\n+      /**\n+       *  @if maint\n+       *  @doctodo\n+       *  @endif\n+      */\n       __stringbuf_type\t_M_stringbuf;\n \n     public:\n       // Constructors:\n+      /**\n+       *  @brief  Default constructor starts with an empty string buffer.\n+       *  @param  mode  Whether the buffer can read, or write, or both.\n+       *\n+       *  @c ios_base::in is automatically included in @a mode.\n+       *\n+       *  Initializes @c sb using @c mode|in, and passes @c &sb to the base\n+       *  class initializer.  Does not allocate any buffer.\n+       *\n+       *  @if maint\n+       *  That's a lie.  We initialize the base class with NULL, because the\n+       *  string class does its own memory management.\n+       *  @endif\n+      */\n       explicit\n       basic_istringstream(ios_base::openmode __mode = ios_base::in)\n       : __istream_type(NULL), _M_stringbuf(__mode | ios_base::in)\n       { this->init(&_M_stringbuf); }\n \n+      /**\n+       *  @brief  Starts with an existing string buffer.\n+       *  @param  str  A string to copy as a starting buffer.\n+       *  @param  mode  Whether the buffer can read, or write, or both.\n+       *\n+       *  @c ios_base::in is automatically included in @a mode.\n+       *\n+       *  Initializes @c sb using @a str and @c mode|in, and passes @c &sb\n+       *  to the base class initializer.\n+       *\n+       *  @if maint\n+       *  That's a lie.  We initialize the base class with NULL, because the\n+       *  string class does its own memory management.\n+       *  @endif\n+      */\n       explicit\n       basic_istringstream(const __string_type& __str,\n \t\t\t  ios_base::openmode __mode = ios_base::in)\n       : __istream_type(NULL), _M_stringbuf(__str, __mode | ios_base::in)\n       { this->init(&_M_stringbuf); }\n \n+      /**\n+       *  @brief  The destructor does nothing.\n+       *\n+       *  The buffer is deallocated by the stringbuf object, not the\n+       *  formatting stream.\n+      */\n       ~basic_istringstream()\n       { }\n \n       // Members:\n+      /**\n+       *  @brief  Accessing the underlying buffer.\n+       *  @return  The current basic_stringbuf buffer.\n+       *\n+       *  This hides both signatures of std::basic_ios::rdbuf().\n+      */\n       __stringbuf_type*\n       rdbuf() const\n       { return const_cast<__stringbuf_type*>(&_M_stringbuf); }\n \n+      /**\n+       *  @brief  Copying out the string buffer.\n+       *  @return  @c rdbuf()->str()\n+      */\n       __string_type\n       str() const\n       { return _M_stringbuf.str(); }\n \n+      /**\n+       *  @brief  Setting a new buffer.\n+       *  @param  s  The string to use as a new sequence.\n+       *\n+       *  Calls @c rdbuf()->str(s).\n+      */\n       void\n       str(const __string_type& __s)\n       { _M_stringbuf.str(__s); }\n     };\n \n \n-  // 27.7.3  Template class basic_ostringstream\n+  // [27.7.3] Template class basic_ostringstream\n+  /**\n+   *  @brief  Controlling output for std::string.\n+   *\n+   *  This class supports writing to objects of type std::basic_string,\n+   *  using the inherited functions from std::basic_ostream.  To control\n+   *  the associated sequence, an instance of std::basic_stringbuf is used,\n+   *  which this page refers to as @c sb.\n+  */\n   template <typename _CharT, typename _Traits, typename _Alloc>\n     class basic_ostringstream : public basic_ostream<_CharT, _Traits>\n     {\n@@ -273,40 +424,104 @@ namespace std\n       typedef basic_ostream<char_type, traits_type>\t__ostream_type;\n \n     private:\n+      /**\n+       *  @if maint\n+       *  @doctodo\n+       *  @endif\n+      */\n       __stringbuf_type\t_M_stringbuf;\n \n     public:\n-     // Constructors/destructor:\n+      // Constructors/destructor:\n+      /**\n+       *  @brief  Default constructor starts with an empty string buffer.\n+       *  @param  mode  Whether the buffer can read, or write, or both.\n+       *\n+       *  @c ios_base::out is automatically included in @a mode.\n+       *\n+       *  Initializes @c sb using @c mode|out, and passes @c &sb to the base\n+       *  class initializer.  Does not allocate any buffer.\n+       *\n+       *  @if maint\n+       *  That's a lie.  We initialize the base class with NULL, because the\n+       *  string class does its own memory management.\n+       *  @endif\n+      */\n       explicit\n       basic_ostringstream(ios_base::openmode __mode = ios_base::out)\n       : __ostream_type(NULL), _M_stringbuf(__mode | ios_base::out)\n       { this->init(&_M_stringbuf); }\n \n+      /**\n+       *  @brief  Starts with an existing string buffer.\n+       *  @param  str  A string to copy as a starting buffer.\n+       *  @param  mode  Whether the buffer can read, or write, or both.\n+       *\n+       *  @c ios_base::out is automatically included in @a mode.\n+       *\n+       *  Initializes @c sb using @a str and @c mode|out, and passes @c &sb\n+       *  to the base class initializer.\n+       *\n+       *  @if maint\n+       *  That's a lie.  We initialize the base class with NULL, because the\n+       *  string class does its own memory management.\n+       *  @endif\n+      */\n       explicit\n       basic_ostringstream(const __string_type& __str,\n \t\t\t  ios_base::openmode __mode = ios_base::out)\n       : __ostream_type(NULL), _M_stringbuf(__str, __mode | ios_base::out)\n       { this->init(&_M_stringbuf); }\n \n+      /**\n+       *  @brief  The destructor does nothing.\n+       *\n+       *  The buffer is deallocated by the stringbuf object, not the\n+       *  formatting stream.\n+      */\n       ~basic_ostringstream()\n       { }\n \n       // Members:\n+      /**\n+       *  @brief  Accessing the underlying buffer.\n+       *  @return  The current basic_stringbuf buffer.\n+       *\n+       *  This hides both signatures of std::basic_ios::rdbuf().\n+      */\n       __stringbuf_type*\n       rdbuf() const\n       { return const_cast<__stringbuf_type*>(&_M_stringbuf); }\n \n+      /**\n+       *  @brief  Copying out the string buffer.\n+       *  @return  @c rdbuf()->str()\n+      */\n       __string_type\n       str() const\n       { return _M_stringbuf.str(); }\n \n+      /**\n+       *  @brief  Setting a new buffer.\n+       *  @param  s  The string to use as a new sequence.\n+       *\n+       *  Calls @c rdbuf()->str(s).\n+      */\n       void\n       str(const __string_type& __s)\n       { _M_stringbuf.str(__s); }\n     };\n \n \n-  // 27.7.4  Template class basic_stringstream\n+  // [27.7.4] Template class basic_stringstream\n+  /**\n+   *  @brief  Controlling input and output for std::string.\n+   *\n+   *  This class supports reading from and writing to objects of type\n+   *  std::basic_string, using the inherited functions from\n+   *  std::basic_iostream.  To control the associated sequence, an instance\n+   *  of std::basic_stringbuf is used, which this page refers to as @c sb.\n+  */\n   template <typename _CharT, typename _Traits, typename _Alloc>\n     class basic_stringstream : public basic_iostream<_CharT, _Traits>\n     {\n@@ -328,33 +543,85 @@ namespace std\n       typedef basic_iostream<char_type, traits_type>\t__iostream_type;\n \n     private:\n+      /**\n+       *  @if maint\n+       *  @doctodo\n+       *  @endif\n+      */\n       __stringbuf_type\t_M_stringbuf;\n \n     public:\n       // Constructors/destructors\n+      /**\n+       *  @brief  Default constructor starts with an empty string buffer.\n+       *  @param  mode  Whether the buffer can read, or write, or both.\n+       *\n+       *  Initializes @c sb using @c mode, and passes @c &sb to the base\n+       *  class initializer.  Does not allocate any buffer.\n+       *\n+       *  @if maint\n+       *  That's a lie.  We initialize the base class with NULL, because the\n+       *  string class does its own memory management.\n+       *  @endif\n+      */\n       explicit\n       basic_stringstream(ios_base::openmode __m = ios_base::out | ios_base::in)\n       : __iostream_type(NULL), _M_stringbuf(__m)\n       { this->init(&_M_stringbuf); }\n \n+      /**\n+       *  @brief  Starts with an existing string buffer.\n+       *  @param  str  A string to copy as a starting buffer.\n+       *  @param  mode  Whether the buffer can read, or write, or both.\n+       *\n+       *  Initializes @c sb using @a str and @c mode, and passes @c &sb\n+       *  to the base class initializer.\n+       *\n+       *  @if maint\n+       *  That's a lie.  We initialize the base class with NULL, because the\n+       *  string class does its own memory management.\n+       *  @endif\n+      */\n       explicit\n       basic_stringstream(const __string_type& __str,\n \t\t\t ios_base::openmode __m = ios_base::out | ios_base::in)\n       : __iostream_type(NULL), _M_stringbuf(__str, __m)\n       { this->init(&_M_stringbuf); }\n \n+      /**\n+       *  @brief  The destructor does nothing.\n+       *\n+       *  The buffer is deallocated by the stringbuf object, not the\n+       *  formatting stream.\n+      */\n       ~basic_stringstream()\n       { }\n \n       // Members:\n+      /**\n+       *  @brief  Accessing the underlying buffer.\n+       *  @return  The current basic_stringbuf buffer.\n+       *\n+       *  This hides both signatures of std::basic_ios::rdbuf().\n+      */\n       __stringbuf_type*\n       rdbuf() const\n       { return const_cast<__stringbuf_type*>(&_M_stringbuf); }\n \n+      /**\n+       *  @brief  Copying out the string buffer.\n+       *  @return  @c rdbuf()->str()\n+      */\n       __string_type\n       str() const\n       { return _M_stringbuf.str(); }\n \n+      /**\n+       *  @brief  Setting a new buffer.\n+       *  @param  s  The string to use as a new sequence.\n+       *\n+       *  Calls @c rdbuf()->str(s).\n+      */\n       void\n       str(const __string_type& __s)\n       { _M_stringbuf.str(__s); }"}, {"sha": "883401bf6eeef509224cea6da44b134e284eb62b", "filename": "libstdc++-v3/include/std/std_streambuf.h", "status": "modified", "additions": 485, "deletions": 44, "changes": 529, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/840ceb345b02d8f883b740949984878c9ed6f18e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_streambuf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/840ceb345b02d8f883b740949984878c9ed6f18e/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_streambuf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_streambuf.h?ref=840ceb345b02d8f883b740949984878c9ed6f18e", "patch": "@@ -50,28 +50,104 @@\n \n namespace std\n {\n+  /**\n+   *  @if maint\n+   *  Does stuff.\n+   *  @endif\n+  */\n   template<typename _CharT, typename _Traits>\n     streamsize\n     __copy_streambufs(basic_ios<_CharT, _Traits>& _ios,\n \t\t      basic_streambuf<_CharT, _Traits>* __sbin,\n \t\t      basic_streambuf<_CharT, _Traits>* __sbout);\n   \n-  // 27.5.2 Template class basic_streambuf<_CharT, _Traits>\n+  /**\n+   *  @brief  The actual work of input and output (interface).\n+   *\n+   *  This is a base class.  Derived stream buffers each control a\n+   *  pair of character sequences:  one for input, and one for output.\n+   *\n+   *  Section [27.5.1] of the standard describes the requirements and\n+   *  behavior of stream buffer classes.  That section (three paragraphs)\n+   *  is reproduced here, for simplicity and accuracy.\n+   *\n+   *  -# Stream buffers can impose various constraints on the sequences\n+   *     they control.  Some constraints are:\n+   *     - The controlled input sequence can be not readable.\n+   *     - The controlled output sequence can be not writable.\n+   *     - The controlled sequences can be associated with the contents of\n+   *       other representations for character sequences, such as external\n+   *       files.\n+   *     - The controlled sequences can support operations @e directly to or\n+   *       from associated sequences.\n+   *     - The controlled sequences can impose limitations on how the\n+   *       program can read characters from a sequence, write characters to\n+   *       a sequence, put characters back into an input sequence, or alter\n+   *       the stream position.\n+   *     .\n+   *  -# Each sequence is characterized by three pointers which, if non-null,\n+   *     all point into the same @c charT array object.  The array object\n+   *     represents, at any moment, a (sub)sequence of characters from the\n+   *     sequence.  Operations performed on a sequence alter the values\n+   *     stored in these pointers, perform reads and writes directly to or\n+   *     from associated sequences, and alter \"the stream position\" and\n+   *     conversion state as needed to maintain this subsequence relationship.\n+   *     The three pointers are:\n+   *     - the <em>beginning pointer</em>, or lowest element address in the\n+   *       array (called @e xbeg here);\n+   *     - the <em>next pointer</em>, or next element address that is a\n+   *       current candidate for reading or writing (called @e xnext here);\n+   *     - the <em>end pointer</em>, or first element address beyond the\n+   *       end of the array (called @e xend here).\n+   *     .\n+   *  -# The following semantic constraints shall always apply for any set\n+   *     of three pointers for a sequence, using the pointer names given\n+   *     immediately above:\n+   *     - If @e xnext is not a null pointer, then @e xbeg and @e xend shall\n+   *       also be non-null pointers into the same @c charT array, as\n+   *       described above; otherwise, @e xbeg and @e xend shall also be null.\n+   *     - If @e xnext is not a null pointer and @e xnext < @e xend for an\n+   *       output sequence, then a <em>write position</em> is available.\n+   *       In this case, @e *xnext shall be assignable as the next element\n+   *       to write (to put, or to store a character value, into the sequence).\n+   *     - If @e xnext is not a null pointer and @e xbeg < @e xnext for an\n+   *       input sequence, then a <em>putback position</em> is available.\n+   *       In this case, @e xnext[-1] shall have a defined value and is the\n+   *       next (preceding) element to store a character that is put back\n+   *       into the input sequence.\n+   *     - If @e xnext is not a null pointer and @e xnext< @e xend for an\n+   *       input sequence, then a <em>read position</em> is available.\n+   *       In this case, @e *xnext shall have a defined value and is the\n+   *       next element to read (to get, or to obtain a character value,\n+   *       from the sequence).\n+  */\n   template<typename _CharT, typename _Traits>\n     class basic_streambuf \n     {\n     public:\n-      // Types:\n+      //@{\n+      /**\n+       *  These are standard types.  They permit a standardized way of\n+       *  referring to names of (or names dependant on) the template\n+       *  parameters, which are specific to the implementation.\n+      */\n       typedef _CharT \t\t\t\t\tchar_type;\n       typedef _Traits \t\t\t\t\ttraits_type;\n       typedef typename traits_type::int_type \t\tint_type;\n       typedef typename traits_type::pos_type \t\tpos_type;\n       typedef typename traits_type::off_type \t\toff_type;\n-\n-      // Non-standard Types:\n+      //@}\n+\n+      //@{\n+      /**\n+       *  @if maint\n+       *  These are non-standard types.\n+       *  @endif\n+      */\n       typedef ctype<char_type>           \t\t__ctype_type;\n       typedef basic_streambuf<char_type, traits_type>  \t__streambuf_type;\n       typedef typename traits_type::state_type \t\t__state_type;\n+      //@}\n       \n       friend class basic_ios<char_type, traits_type>;\n       friend class basic_istream<char_type, traits_type>;\n@@ -84,56 +160,100 @@ namespace std\n \t\t\t  __streambuf_type* __sbin,__streambuf_type* __sbout);\n       \n     protected:\n-      // Pointer to the beginning of internally-allocated\n-      // space. Filebuf manually allocates/deallocates this, whereas\n-      // stringstreams attempt to use the built-in intelligence of the\n-      // string class. If you are managing memory, set this. If not,\n-      // leave it NULL.\n+      /**\n+       *  @if maint\n+       *  Pointer to the beginning of internally-allocated space.  Filebuf\n+       *  manually allocates/deallocates this, whereas stringstreams attempt\n+       *  to use the built-in intelligence of the string class.  If you are\n+       *  managing memory, set this.  If not, leave it NULL.\n+       *  @endif\n+      */\n       char_type*\t\t_M_buf; \t\n \n-      // Actual size of allocated internal buffer, in bytes.\n+      /**\n+       *  @if maint\n+       *  Actual size of allocated internal buffer, in bytes.\n+       *  @endif\n+      */\n       size_t\t\t\t_M_buf_size;\n \n-      // Optimal or preferred size of internal buffer, in bytes.\n+      /**\n+       *  @if maint\n+       *  Optimal or preferred size of internal buffer, in bytes.\n+       *  @endif\n+      */\n       size_t\t\t\t_M_buf_size_opt;\n \n-      // True iff _M_in_* and _M_out_* buffers should always point to\n-      // the same place.  True for fstreams, false for sstreams.\n+      /**\n+       *  @if maint\n+       *  True iff _M_in_* and _M_out_* buffers should always point to\n+       *  the same place.  True for fstreams, false for sstreams.\n+       *  @endif\n+      */\n       bool \t\t\t_M_buf_unified;\t\n \n-      // This is based on _IO_FILE, just reordered to be more\n-      // consistent, and is intended to be the most minimal abstraction\n-      // for an internal buffer.\n-      // get == input == read\n-      // put == output == write\n+      //@{\n+      /**\n+       *  @if maint\n+       *  This is based on _IO_FILE, just reordered to be more consistent,\n+       *  and is intended to be the most minimal abstraction for an\n+       *  internal buffer.\n+       *  -  get == input == read\n+       *  -  put == output == write\n+       *  @endif\n+      */\n       char_type* \t\t_M_in_beg;  \t// Start of get area. \n       char_type* \t\t_M_in_cur;\t// Current read area. \n       char_type* \t\t_M_in_end;\t// End of get area. \n       char_type* \t\t_M_out_beg; \t// Start of put area. \n       char_type* \t\t_M_out_cur;  \t// Current put area. \n       char_type* \t\t_M_out_end;  \t// End of put area. \n+      //@}\n \n-      // Place to stash in || out || in | out settings for current streambuf.\n+      /**\n+       *  @if maint\n+       *  Place to stash in || out || in | out settings for current streambuf.\n+       *  @endif\n+      */\n       ios_base::openmode \t_M_mode;\t\n \n-      // Current locale setting.\n+      /**\n+       *  @if maint\n+       *  Current locale setting.\n+       *  @endif\n+      */\n       locale \t\t\t_M_buf_locale;\t\n \n-      // True iff locale is initialized.\n+      /**\n+       *  @if maint\n+       *  True iff locale is initialized.\n+       *  @endif\n+      */\n       bool \t\t\t_M_buf_locale_init;\n \n-      // Necessary bits for putback buffer management. Only used in\n-      // the basic_filebuf class, as necessary for the standard\n-      // requirements. The only basic_streambuf member function that\n-      // needs access to these data members is in_avail...\n-      // NB: pbacks of over one character are not currently supported.\n+      //@{\n+      /**\n+       *  @if maint\n+       *  Necessary bits for putback buffer management. Only used in\n+       *  the basic_filebuf class, as necessary for the standard\n+       *  requirements. The only basic_streambuf member function that\n+       *  needs access to these data members is in_avail...\n+       *  \n+       *  @note pbacks of over one character are not currently supported.\n+       *  @endif\n+      */\n       static const size_t   \t_S_pback_size = 1; \n       char_type\t\t\t_M_pback[_S_pback_size]; \n       char_type*\t\t_M_pback_cur_save;\n       char_type*\t\t_M_pback_end_save;\n       bool\t\t\t_M_pback_init; \n+      //@}\n \n-      // Yet unused.\n+      /**\n+       *  @if maint\n+       *  Yet unused.\n+       *  @endif\n+      */\n       fpos<__state_type>\t_M_pos;\n \n       // Initializes pback buffers, and moves normal buffers to safety.\n@@ -236,6 +356,7 @@ namespace std\n       }\n \n   public:\n+      /// Destructor deallocates no buffer space.\n       virtual \n       ~basic_streambuf() \n       {\n@@ -246,7 +367,14 @@ namespace std\n \t_M_buf_locale_init = false;\n       }\n \n-      // Locales:\n+      // [27.5.2.2.1] locales\n+      /**\n+       *  @brief  Entry point for imbue().\n+       *  @param  loc  The new locale.\n+       *  @return  The previous locale.\n+       *\n+       *  Calls the derived imbue(loc).\n+      */\n       locale \n       pubimbue(const locale &__loc)\n       {\n@@ -255,6 +383,14 @@ namespace std\n \treturn __tmp;\n       }\n \n+      /**\n+       *  @brief  Locale access.\n+       *  @return  The current locale in effect.\n+       *\n+       *  If pubimbue(loc) has been called, then the most recent @c loc\n+       *  is returned.  Otherwise the global locale in effect at the time\n+       *  of construction is returned.\n+      */\n       locale   \n       getloc() const\n       {\n@@ -264,7 +400,15 @@ namespace std\n \t  return locale();\n       } \n \n-      // Buffer and positioning:\n+      // [27.5.2.2.2] buffer management and positioning\n+      //@{\n+      /**\n+       *  @brief  Entry points for derived buffer functions.\n+       *\n+       *  The public versions of @c pubfoo dispatch to the protected\n+       *  derived @c foo member functions, passing the arguments (if any)\n+       *  and returning the result unchanged.\n+      */\n       __streambuf_type* \n       pubsetbuf(char_type* __s, streamsize __n) \n       { return this->setbuf(__s, __n); }\n@@ -281,9 +425,17 @@ namespace std\n \n       int \n       pubsync() { return this->sync(); }\n-\n-      // Get and put areas:\n-      // Get area:\n+      //@}\n+\n+      // [27.5.2.2.3] get area\n+      /**\n+       *  @brief  Looking ahead into the stream.\n+       *  @return  The number of characters available.\n+       *\n+       *  If a read position is available, returns the number of characters\n+       *  available for reading before the buffer must be refilled.\n+       *  Otherwise returns the derived @c showmanyc().\n+      */\n       streamsize \n       in_avail() \n       { \n@@ -304,6 +456,13 @@ namespace std\n \treturn __ret;\n       }\n \n+      /**\n+       *  @brief  Getting the next character.\n+       *  @return  The next character, or eof.\n+       *\n+       *  Calls @c sbumpc(), and if that function returns\n+       *  @c traits::eof(), so does this function.  Otherwise, @c sgetc().\n+      */\n       int_type \n       snextc()\n       {\n@@ -312,9 +471,25 @@ namespace std\n \t\t? __eof : this->sgetc());\n       }\n \n+      /**\n+       *  @brief  Getting the next character.\n+       *  @return  The next character, or eof.\n+       *\n+       *  If the input read position is available, returns that character\n+       *  and increments the read pointer, otherwise calls and returns\n+       *  @c uflow().\n+      */\n       int_type \n       sbumpc();\n \n+      /**\n+       *  @brief  Getting the next character.\n+       *  @return  The next character, or eof.\n+       *\n+       *  If the input read position is available, returns that character,\n+       *  otherwise calls and returns @c underflow().  Does not move the \n+       *  read position after fetching the character.\n+      */\n       int_type \n       sgetc()\n       {\n@@ -326,26 +501,84 @@ namespace std\n \treturn __ret;\n       }\n \n+      /**\n+       *  @brief  Entry point for xsgetn.\n+       *  @param  s  A buffer area.\n+       *  @param  n  A count.\n+       *\n+       *  Returns xsgetn(s,n).  The effect is to fill @a s[0] through\n+       *  @a s[n-1] with characters from the input sequence, if possible.\n+      */\n       streamsize \n       sgetn(char_type* __s, streamsize __n)\n       { return this->xsgetn(__s, __n); }\n \n-      // Putback:\n+      // [27.5.2.2.4] putback\n+      /**\n+       *  @brief  Pushing characters back into the input stream.\n+       *  @param  c  The character to push back.\n+       *  @return  The previous character, if possible.\n+       *\n+       *  Similar to sungetc(), but @a c is pushed onto the stream instead\n+       *  of \"the previous character\".  If successful, the next character\n+       *  fetched from the input stream will be @a c.\n+      */\n       int_type \n       sputbackc(char_type __c);\n \n+      /**\n+       *  @brief  Moving backwards in the input stream.\n+       *  @return  The previous character, if possible.\n+       *\n+       *  If a putback position is available, this function decrements the\n+       *  input pointer and returns that character.  Otherwise, calls and\n+       *  returns pbackfail().  The effect is to \"unget\" the last character\n+       *  \"gotten\".\n+      */\n       int_type \n       sungetc();\n \n-      // Put area:\n+      // [27.5.2.2.5] put area\n+      /**\n+       *  @brief  Entry point for all single-character output functions.\n+       *  @param  c  A character to output.\n+       *  @return  @a c, if possible.\n+       *\n+       *  One of two public output functions.\n+       *\n+       *  If a write position is available for the output sequence (i.e.,\n+       *  the buffer is not full), stores @a c in that position, increments\n+       *  the position, and returns @c traits::to_int_type(c).  If a write\n+       *  position is not available, returns @c overflow(c).\n+      */\n       int_type \n       sputc(char_type __c);\n \n+      /**\n+       *  @brief  Entry point for all single-character output functions.\n+       *  @param  s  A buffer read area.\n+       *  @param  n  A count.\n+       *\n+       *  One of two public output functions.\n+       *\n+       *\n+       *  Returns xsputn(s,n).  The effect is to write @a s[0] through\n+       *  @a s[n-1] to the output sequence, if possible.\n+      */\n       streamsize \n       sputn(const char_type* __s, streamsize __n)\n       { return this->xsputn(__s, __n); }\n \n     protected:\n+      /**\n+       *  @brief  Base constructor.\n+       *\n+       *  Only called from derived constructors, and sets up all the\n+       *  buffer data to zero, including the pointers described in the\n+       *  basic_streambuf class description.  Note that, as a result,\n+       *  - the class starts with no read nor write positions available,\n+       *  - this is not an error\n+      */\n       basic_streambuf()\n       : _M_buf(NULL), _M_buf_size(0), _M_buf_size_opt(BUFSIZ), \n       _M_buf_unified(false), _M_in_beg(0), _M_in_cur(0), _M_in_end(0), \n@@ -355,7 +588,18 @@ namespace std\n       _M_pback_init(false)\n       { }\n \n-      // Get area:\n+      // [27.5.2.3.1] get area access\n+      //@{\n+      /**\n+       *  @brief  Access to the get area.\n+       *\n+       *  These functions are only available to other protected functions,\n+       *  including derived classes.\n+       *\n+       *  - eback() returns the beginning pointer for the input sequence\n+       *  - gptr() returns the next pointer for the input sequence\n+       *  - egptr() returns the end pointer for the input sequence\n+      */\n       char_type* \n       eback() const { return _M_in_beg; }\n \n@@ -364,10 +608,25 @@ namespace std\n \n       char_type* \n       egptr() const { return _M_in_end; }\n-\n+      //@}\n+\n+      /**\n+       *  @brief  Moving the read position.\n+       *  @param  n  The delta by which to move.\n+       *\n+       *  This just advances the read position without returning any data.\n+      */\n       void \n       gbump(int __n) { _M_in_cur += __n; }\n \n+      /**\n+       *  @brief  Setting the three read area pointers.\n+       *  @param  gbeg  A pointer.\n+       *  @param  gnext  A pointer.\n+       *  @param  gend  A pointer.\n+       *  @post  @a gbeg == @c eback(), @a gnext == @c gptr(), and\n+       *         @a gend == @c egptr()\n+      */\n       void \n       setg(char_type* __gbeg, char_type* __gnext, char_type* __gend)\n       {\n@@ -378,7 +637,18 @@ namespace std\n \t  _M_mode = _M_mode | ios_base::in;\n       }\n \n-      // Put area:\n+      // [27.5.2.3.2] put area access\n+      //@{\n+      /**\n+       *  @brief  Access to the put area.\n+       *\n+       *  These functions are only available to other protected functions,\n+       *  including derived classes.\n+       *\n+       *  - pbase() returns the beginning pointer for the output sequence\n+       *  - pptr() returns the next pointer for the output sequence\n+       *  - epptr() returns the end pointer for the output sequence\n+      */\n       char_type* \n       pbase() const { return _M_out_beg; }\n \n@@ -387,10 +657,24 @@ namespace std\n \n       char_type* \n       epptr() const { return _M_out_end; }\n-\n+      //@}\n+\n+      /**\n+       *  @brief  Moving the write position.\n+       *  @param  n  The delta by which to move.\n+       *\n+       *  This just advances the write position without returning any data.\n+      */\n       void \n       pbump(int __n) { _M_out_cur += __n; }\n \n+      /**\n+       *  @brief  Setting the three write area pointers.\n+       *  @param  pbeg  A pointer.\n+       *  @param  pend  A pointer.\n+       *  @post  @a pbeg == @c pbase(), @a pbeg == @c pptr(), and\n+       *         @a pend == @c epptr()\n+      */\n       void \n       setp(char_type* __pbeg, char_type* __pend)\n       { \n@@ -400,8 +684,19 @@ namespace std\n \t  _M_mode = _M_mode | ios_base::out;\n       }\n \n-      // Virtual functions:\n-      // Locales:\n+      // [27.5.2.4] virtual functions\n+      // [27.5.2.4.1] locales\n+      /**\n+       *  @brief  Changes translations.\n+       *  @param  loc  A new locale.\n+       *\n+       *  Translations done during I/O which depend on the current locale\n+       *  are changed by this call.  The standard adds, \"Between invocations\n+       *  of this function a class derived from streambuf can safely cache\n+       *  results of calls to locale functions and to members of facets\n+       *  so obtained.\"  This function simply stores the new locale for use\n+       *  by derived classes.\n+      */\n       virtual void \n       imbue(const locale& __loc) \n       { \n@@ -410,35 +705,126 @@ namespace std\n \t  _M_buf_locale = __loc;\n       }\n \n-      // Buffer management and positioning:\n+      // [27.5.2.4.2] buffer management and positioning\n+      /**\n+       *  @brief  Maniuplates the buffer.\n+       *\n+       *  Each derived class provides its own appropriate behavior.  See\n+       *  the next-to-last paragraph of \n+       *  http://gcc.gnu.org/onlinedocs/libstdc++/27_io/howto.html#2 for\n+       *  more on this function.\n+       *\n+       *  @note  Base class version does nothing, returns @c this.\n+      */\n       virtual basic_streambuf<char_type,_Traits>* \n       setbuf(char_type*, streamsize)\n       {\treturn this; }\n       \n+      /**\n+       *  @brief  Alters the stream positions.\n+       *\n+       *  Each derived class provides its own appropriate behavior.\n+       *  @note  Base class version does nothing, returns a @c pos_type\n+       *         that represents an invalid stream position.\n+      */\n       virtual pos_type \n       seekoff(off_type, ios_base::seekdir,\n \t      ios_base::openmode /*__mode*/ = ios_base::in | ios_base::out)\n       { return pos_type(off_type(-1)); } \n \n+      /**\n+       *  @brief  Alters the stream positions.\n+       *\n+       *  Each derived class provides its own appropriate behavior.\n+       *  @note  Base class version does nothing, returns a @c pos_type\n+       *         that represents an invalid stream position.\n+      */\n       virtual pos_type \n       seekpos(pos_type, \n \t      ios_base::openmode /*__mode*/ = ios_base::in | ios_base::out)\n       { return pos_type(off_type(-1)); } \n \n+      /**\n+       *  @brief  Synchronizes the buffer arrays with the controlled sequences.\n+       *  @return  -1 on failure.\n+       *\n+       *  Each derived class provides its own appropriate behavior,\n+       *  including the definition of \"failure\".\n+       *  @note  Base class version does nothing, returns zero.\n+      */\n       virtual int \n       sync() { return 0; }\n \n-      // Get area:\n+      // [27.5.2.4.3] get area\n+      /**\n+       *  @brief  Investigating the data available.\n+       *  @return  An estimate of the number of characters available in the\n+       *           input sequence, or -1.\n+       *\n+       *  \"If it returns a positive value, then successive calls to\n+       *  @c underflow() will not return @c traits::eof() until at least that\n+       *  number of characters have been supplied.  If @c showmanyc()\n+       *  returns -1, then calls to @c underflow() or @c uflow() will fail.\"\n+       *  [27.5.2.4.3]/1\n+       *\n+       *  @note  Base class version does nothing, returns zero.\n+       *  @note  The standard adds that \"the intention is not only that the\n+       *         calls [to underflow or uflow] will not return @c eof() but\n+       *         that they will return \"immediately\".\n+       *  @note  The standard adds that \"the morphemes of @c showmanyc are\n+       *         \"es-how-many-see\", not \"show-manic\".\n+      */\n       virtual streamsize \n       showmanyc() { return 0; }\n \n+      /**\n+       *  @brief  Multiple character extraction.\n+       *  @param  s  A buffer area.\n+       *  @param  n  Maximum number of characters to assign.\n+       *  @return  The number of characters assigned.\n+       *\n+       *  Fills @a s[0] through @a s[n-1] with characters from the input\n+       *  sequence, as if by @c sbumpc().  Stops when either @a n characters\n+       *  have been copied, or when @c traits::eof() would be copied.\n+       *\n+       *  It is expected that derived classes provide a more efficient\n+       *  implementation by overriding this definition.\n+      */\n       virtual streamsize \n       xsgetn(char_type* __s, streamsize __n);\n \n+      /**\n+       *  @brief  Fetches more data from the controlled sequence.\n+       *  @return  The first character from the <em>pending sequence</em>.\n+       *\n+       *  Informally, this function is called when the input buffer is\n+       *  exhausted (or does not exist, as buffering need not actually be\n+       *  done).  If a buffer exists, it is \"refilled\".  In either case, the\n+       *  next available character is returned, or @c traits::eof() to\n+       *  indicate a null pending sequence.\n+       *\n+       *  For a formal definiton of the pending sequence, see a good text\n+       *  such as Langer & Kreft, or [27.5.2.4.3]/7-14.\n+       *\n+       *  A functioning input streambuf can be created by overriding only\n+       *  this function (no buffer area will be used).  For an example, see\n+       *  http://gcc.gnu.org/onlinedocs/libstdc++/27_io/howto.html#6\n+       *\n+       *  @note  Base class version does nothing, returns eof().\n+      */\n       virtual int_type \n       underflow()\n       { return traits_type::eof(); }\n \n+      /**\n+       *  @brief  Fetches more data from the controlled sequence.\n+       *  @return  The first character from the <em>pending sequence</em>.\n+       *\n+       *  Informally, this function does the same thing as @c underflow(),\n+       *  and in fact is required to call that function.  It also returns\n+       *  the new character, like @c underflow() does.  However, this\n+       *  function also moves the read position forward by one.\n+      */\n       virtual int_type \n       uflow() \n       {\n@@ -455,23 +841,78 @@ namespace std\n \treturn __ret;    \n       }\n \n-      // Putback:\n+      // [27.5.2.4.4] putback\n+      /**\n+       *  @brief  Tries to back up the input sequence.\n+       *  @param  c  The character to be inserted back into the sequence.\n+       *  @return  eof() on failure, \"some other value\" on success\n+       *  @post  The constraints of @c gptr(), @c eback(), and @c pptr()\n+       *         are the same as for @c underflow().\n+       *\n+       *  @note  Base class version does nothing, returns eof().\n+      */\n       virtual int_type \n       pbackfail(int_type /* __c */  = traits_type::eof())\n       { return traits_type::eof(); }\n \n       // Put area:\n+      /**\n+       *  @brief  Multiple character insertion.\n+       *  @param  s  A buffer area.\n+       *  @param  n  Maximum number of characters to write.\n+       *  @return  The number of characters written.\n+       *\n+       *  Writes @a s[0] through @a s[n-1] to the output sequence, as if\n+       *  by @c sputc().  Stops when either @a n characters have been\n+       *  copied, or when @c sputc() would return @c traits::eof().\n+       *\n+       *  It is expected that derived classes provide a more efficient\n+       *  implementation by overriding this definition.\n+      */\n       virtual streamsize \n       xsputn(const char_type* __s, streamsize __n);\n \n+      /**\n+       *  @brief  Consumes data from the buffer; writes to the\n+       *          controlled sequence.\n+       *  @param  c  An additional character to consume.\n+       *  @return  eof() to indicate failure, something else (usually\n+       *           @a c, or not_eof())\n+       *\n+       *  Informally, this function is called when the output buffer is full\n+       *  (or does not exist, as buffering need not actually be done).  If a\n+       *  buffer exists, it is \"consumed\", with \"some effect\" on the\n+       *  controlled sequence.  (Typically, the buffer is written out to the\n+       *  sequence verbatim.)  In either case, the character @a c is also\n+       *  written out, if @a c is not @c eof().\n+       *\n+       *  For a formal definiton of this function, see a good text\n+       *  such as Langer & Kreft, or [27.5.2.4.5]/3-7.\n+       *\n+       *  A functioning output streambuf can be created by overriding only\n+       *  this function (no buffer area will be used).\n+       *\n+       *  @note  Base class version does nothing, returns eof().\n+      */\n       virtual int_type \n       overflow(int_type /* __c */ = traits_type::eof())\n       { return traits_type::eof(); }\n \n #ifdef _GLIBCPP_DEPRECATED\n-    // http://gcc.gnu.org/ml/libstdc++/2002-05/msg00168.html\n     // Annex D.6\n     public:\n+      /**\n+       *  @brief  Tosses a character.\n+       *\n+       *  Advances the read pointer, ignoring the character that would have\n+       *  been read.\n+       *\n+       *  See http://gcc.gnu.org/ml/libstdc++/2002-05/msg00168.html\n+       *\n+       *  @note  This function has been deprecated by the standard.  You\n+       *         must define @c _GLIBCPP_DEPRECATED to make this visible; see\n+       *         c++config.h.\n+      */\n       void \n       stossc() \n       {"}]}