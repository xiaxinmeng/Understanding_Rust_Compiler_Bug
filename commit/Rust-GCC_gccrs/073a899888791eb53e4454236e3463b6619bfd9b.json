{"sha": "073a899888791eb53e4454236e3463b6619bfd9b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDczYTg5OTg4ODc5MWViNTNlNDQ1NDIzNmUzNDYzYjY2MTliZmQ5Yg==", "commit": {"author": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2012-05-29T14:14:06Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2012-05-29T14:14:06Z"}, "message": "LANGUAGES: Fix typos.\n\n\t* LANGUAGES: Fix typos.\n\t* Makefile.in: Fix typos.\n\t* alias.c: Fix typos.\n\t* auto-inc-dec.c: Fix typos.\n\t* bb-reorder.c: Fix typos.\n\t* cfgcleanup.c: Fix typos.\n\t* cgraph.c: Fix typos.\n\t* cgraph.h: Fix typos.\n\t* cgraphunit.c: Fix typos.\n\t* collect2-aix.h: Fix typos.\n\t* collect2.c: Fix typos.\n\t* compare-elim.c: Fix typos.\n\t* config/alpha/vms.h: Fix typos.\n\t* config/arm/README-interworking: Fix typos.\n\t* config/arm/arm.c: Fix typos.\n\t* config/arm/iterators.md: Fix typos.\n\t* config/arm/vxworks.h: Fix typos.\n\t* config/avr/avr.c: Fix typos.\n\t* config/avr/avr.h: Fix typos.\n\t* config/avr/avr.md: Fix typos.\n\t* config/avr/builtins.def: Fix typos.\n\t* config/c6x/c6x.c: Fix typos.\n\t* config/cr16/cr16.c: Fix typos.\n\t* config/cr16/cr16.md: Fix typos.\n\t* config/cris/cris.md: Fix typos.\n\t* config/darwin.c: Fix typos.\n\t* config/darwin.opt: Fix typos.\n\t* config/i386/i386-c.c: Fix typos.\n\t* config/i386/i386.c: Fix typos.\n\t* config/ia64/ia64.c: Fix typos.\n\t* config/m68k/cf.md: Fix typos.\n\t* config/mep/mep.c: Fix typos.\n\t* config/microblaze/microblaze.c: Fix typos.\n\t* config/microblaze/microblaze.h: Fix typos.\n\t* config/mn10300/mn10300.c: Fix typos.\n\t* config/mn10300/mn10300.md: Fix typos.\n\t* config/pa/pa.c: Fix typos.\n\t* config/picochip/picochip.h: Fix typos.\n\t* config/rs6000/a2.md: Fix typos.\n\t* config/rs6000/rs6000.c: Fix typos.\n\t* config/rs6000/vector.md: Fix typos.\n\t* config/rx/rx.md: Fix typos.\n\t* config/rx/rx.opt: Fix typos.\n\t* config/s390/2097.md: Fix typos.\n\t* config/s390/s390.c: Fix typos.\n\t* config/s390/s390.h: Fix typos.\n\t* config/sh/sh.c: Fix typos.\n\t* config/sh/sh.md: Fix typos.\n\t* config/sparc/sync.md: Fix typos.\n\t* config/spu/spu.c: Fix typos.\n\t* config/spu/spu.md: Fix typos.\n\t* config/vms/vms.c: Fix typos.\n\t* config/vxworks-dummy.h: Fix typos.\n\t* config/vxworks.h: Fix typos.\n\t* cselib.c: Fix typos.\n\t* df-scan.c: Fix typos.\n\t* df.h: Fix typos.\n\t* doc/extend.texi: Fix typos.\n\t* doc/install.texi: Fix typos.\n\t* doc/invoke.texi: Fix typos.\n\t* doc/md.texi: Fix typos.\n\t* doc/plugins.texi: Fix typos.\n\t* doc/rtl.texi: Fix typos.\n\t* dse.c: Fix typos.\n\t* dwarf2asm.c: Fix typos.\n\t* dwarf2out.c: Fix typos.\n\t* except.h: Fix typos.\n\t* expr.c: Fix typos.\n\t* fold-const.c: Fix typos.\n\t* gcc.c: Fix typos.\n\t* gcse.c: Fix typos.\n\t* genautomata.c: Fix typos.\n\t* gengtype-state.c: Fix typos.\n\t* gengtype.c: Fix typos.\n\t* genhooks.c: Fix typos.\n\t* gimple-fold.c: Fix typos.\n\t* gimple-pretty-print.c: Fix typos.\n\t* gimple.c: Fix typos.\n\t* gimple.h: Fix typos.\n\t* gimplify.c: Fix typos.\n\t* graphite-interchange.c: Fix typos.\n\t* graphite-sese-to-poly.c: Fix typos.\n\t* ifcvt.c: Fix typos.\n\t* input.c: Fix typos.\n\t* ipa-cp.c: Fix typos.\n\t* ipa-inline-analysis.c: Fix typos.\n\t* ipa-inline-transform.c: Fix typos.\n\t* ipa-inline.c: Fix typos.\n\t* ipa-pure-const.c: Fix typos.\n\t* ipa-ref.h: Fix typos.\n\t* ipa-reference.c: Fix typos.\n\t* ipa-utils.c: Fix typos.\n\t* ipa.c: Fix typos.\n\t* ira-emit.c: Fix typos.\n\t* ira-lives.c: Fix typos.\n\t* lto-streamer.c: Fix typos.\n\t* lto-streamer.h: Fix typos.\n\t* lto-wrapper.c: Fix typos.\n\t* mcf.c: Fix typos.\n\t* mode-switching.c: Fix typos.\n\t* modulo-sched.c: Fix typos.\n\t* plugin.c: Fix typos.\n\t* postreload.c: Fix typos.\n\t* sched-deps.c: Fix typos.\n\t* sel-sched-ir.c: Fix typos.\n\t* sel-sched-ir.h: Fix typos.\n\t* sel-sched.c: Fix typos.\n\t* sese.c: Fix typos.\n\t* stor-layout.c: Fix typos.\n\t* target-hooks-macros.h: Fix typos.\n\t* target.def: Fix typos.\n\t* trans-mem.c: Fix typos.\n\t* tree-eh.c: Fix typos.\n\t* tree-predcom.c: Fix typos.\n\t* tree-sra.c: Fix typos.\n\t* tree-ssa-address.c: Fix typos.\n\t* tree-ssa-loop-ivopts.c: Fix typos.\n\t* tree-ssa-loop-niter.c: Fix typos.\n\t* tree-ssa-math-opts.c: Fix typos.\n\t* tree-ssa-pre.c: Fix typos.\n\t* tree-ssa-propagate.c: Fix typos.\n\t* tree-ssa-reassoc.c: Fix typos.\n\t* tree-ssa-sccvn.c: Fix typos.\n\t* tree-ssa-ter.c: Fix typos.\n\t* tree-ssa-uninit.c: Fix typos.\n\t* tree-ssanames.c: Fix typos.\n\t* tree-vect-generic.c: Fix typos.\n\t* tree-vect-slp.c: Fix typos.\n\t* tree.c: Fix typos.\n\t* tree.h: Fix typos.\n\t* varasm.c: Fix typos.\n\t* varpool.c: Fix typos.\n\nFrom-SVN: r187959", "tree": {"sha": "5351bdc84968d76b5e18f2ee67aeccd816620443", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5351bdc84968d76b5e18f2ee67aeccd816620443"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/073a899888791eb53e4454236e3463b6619bfd9b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/073a899888791eb53e4454236e3463b6619bfd9b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/073a899888791eb53e4454236e3463b6619bfd9b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/073a899888791eb53e4454236e3463b6619bfd9b/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aba6f2c2a9100592c94fa863990d80b5d3252cb2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aba6f2c2a9100592c94fa863990d80b5d3252cb2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aba6f2c2a9100592c94fa863990d80b5d3252cb2"}], "stats": {"total": 599, "additions": 367, "deletions": 232}, "files": [{"sha": "f86c56bc5b262ad21a08401c5681ff974919f758", "filename": "gcc/ChangeLog", "status": "modified", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -1,3 +1,138 @@\n+2012-05-29  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* LANGUAGES: Fix typos.\n+\t* Makefile.in: Fix typos.\n+\t* alias.c: Fix typos.\n+\t* auto-inc-dec.c: Fix typos.\n+\t* bb-reorder.c: Fix typos.\n+\t* cfgcleanup.c: Fix typos.\n+\t* cgraph.c: Fix typos.\n+\t* cgraph.h: Fix typos.\n+\t* cgraphunit.c: Fix typos.\n+\t* collect2-aix.h: Fix typos.\n+\t* collect2.c: Fix typos.\n+\t* compare-elim.c: Fix typos.\n+\t* config/alpha/vms.h: Fix typos.\n+\t* config/arm/README-interworking: Fix typos.\n+\t* config/arm/arm.c: Fix typos.\n+\t* config/arm/iterators.md: Fix typos.\n+\t* config/arm/vxworks.h: Fix typos.\n+\t* config/avr/avr.c: Fix typos.\n+\t* config/avr/avr.h: Fix typos.\n+\t* config/avr/avr.md: Fix typos.\n+\t* config/avr/builtins.def: Fix typos.\n+\t* config/c6x/c6x.c: Fix typos.\n+\t* config/cr16/cr16.c: Fix typos.\n+\t* config/cr16/cr16.md: Fix typos.\n+\t* config/cris/cris.md: Fix typos.\n+\t* config/darwin.c: Fix typos.\n+\t* config/darwin.opt: Fix typos.\n+\t* config/i386/i386-c.c: Fix typos.\n+\t* config/i386/i386.c: Fix typos.\n+\t* config/ia64/ia64.c: Fix typos.\n+\t* config/m68k/cf.md: Fix typos.\n+\t* config/mep/mep.c: Fix typos.\n+\t* config/microblaze/microblaze.c: Fix typos.\n+\t* config/microblaze/microblaze.h: Fix typos.\n+\t* config/mn10300/mn10300.c: Fix typos.\n+\t* config/mn10300/mn10300.md: Fix typos.\n+\t* config/pa/pa.c: Fix typos.\n+\t* config/picochip/picochip.h: Fix typos.\n+\t* config/rs6000/a2.md: Fix typos.\n+\t* config/rs6000/rs6000.c: Fix typos.\n+\t* config/rs6000/vector.md: Fix typos.\n+\t* config/rx/rx.md: Fix typos.\n+\t* config/rx/rx.opt: Fix typos.\n+\t* config/s390/2097.md: Fix typos.\n+\t* config/s390/s390.c: Fix typos.\n+\t* config/s390/s390.h: Fix typos.\n+\t* config/sh/sh.c: Fix typos.\n+\t* config/sh/sh.md: Fix typos.\n+\t* config/sparc/sync.md: Fix typos.\n+\t* config/spu/spu.c: Fix typos.\n+\t* config/spu/spu.md: Fix typos.\n+\t* config/vms/vms.c: Fix typos.\n+\t* config/vxworks-dummy.h: Fix typos.\n+\t* config/vxworks.h: Fix typos.\n+\t* cselib.c: Fix typos.\n+\t* df-scan.c: Fix typos.\n+\t* df.h: Fix typos.\n+\t* doc/extend.texi: Fix typos.\n+\t* doc/install.texi: Fix typos.\n+\t* doc/invoke.texi: Fix typos.\n+\t* doc/md.texi: Fix typos.\n+\t* doc/plugins.texi: Fix typos.\n+\t* doc/rtl.texi: Fix typos.\n+\t* dse.c: Fix typos.\n+\t* dwarf2asm.c: Fix typos.\n+\t* dwarf2out.c: Fix typos.\n+\t* except.h: Fix typos.\n+\t* expr.c: Fix typos.\n+\t* fold-const.c: Fix typos.\n+\t* gcc.c: Fix typos.\n+\t* gcse.c: Fix typos.\n+\t* genautomata.c: Fix typos.\n+\t* gengtype-state.c: Fix typos.\n+\t* gengtype.c: Fix typos.\n+\t* genhooks.c: Fix typos.\n+\t* gimple-fold.c: Fix typos.\n+\t* gimple-pretty-print.c: Fix typos.\n+\t* gimple.c: Fix typos.\n+\t* gimple.h: Fix typos.\n+\t* gimplify.c: Fix typos.\n+\t* graphite-interchange.c: Fix typos.\n+\t* graphite-sese-to-poly.c: Fix typos.\n+\t* ifcvt.c: Fix typos.\n+\t* input.c: Fix typos.\n+\t* ipa-cp.c: Fix typos.\n+\t* ipa-inline-analysis.c: Fix typos.\n+\t* ipa-inline-transform.c: Fix typos.\n+\t* ipa-inline.c: Fix typos.\n+\t* ipa-pure-const.c: Fix typos.\n+\t* ipa-ref.h: Fix typos.\n+\t* ipa-reference.c: Fix typos.\n+\t* ipa-utils.c: Fix typos.\n+\t* ipa.c: Fix typos.\n+\t* ira-emit.c: Fix typos.\n+\t* ira-lives.c: Fix typos.\n+\t* lto-streamer.c: Fix typos.\n+\t* lto-streamer.h: Fix typos.\n+\t* lto-wrapper.c: Fix typos.\n+\t* mcf.c: Fix typos.\n+\t* mode-switching.c: Fix typos.\n+\t* modulo-sched.c: Fix typos.\n+\t* plugin.c: Fix typos.\n+\t* postreload.c: Fix typos.\n+\t* sched-deps.c: Fix typos.\n+\t* sel-sched-ir.c: Fix typos.\n+\t* sel-sched-ir.h: Fix typos.\n+\t* sel-sched.c: Fix typos.\n+\t* sese.c: Fix typos.\n+\t* stor-layout.c: Fix typos.\n+\t* target-hooks-macros.h: Fix typos.\n+\t* target.def: Fix typos.\n+\t* trans-mem.c: Fix typos.\n+\t* tree-eh.c: Fix typos.\n+\t* tree-predcom.c: Fix typos.\n+\t* tree-sra.c: Fix typos.\n+\t* tree-ssa-address.c: Fix typos.\n+\t* tree-ssa-loop-ivopts.c: Fix typos.\n+\t* tree-ssa-loop-niter.c: Fix typos.\n+\t* tree-ssa-math-opts.c: Fix typos.\n+\t* tree-ssa-pre.c: Fix typos.\n+\t* tree-ssa-propagate.c: Fix typos.\n+\t* tree-ssa-reassoc.c: Fix typos.\n+\t* tree-ssa-sccvn.c: Fix typos.\n+\t* tree-ssa-ter.c: Fix typos.\n+\t* tree-ssa-uninit.c: Fix typos.\n+\t* tree-ssanames.c: Fix typos.\n+\t* tree-vect-generic.c: Fix typos.\n+\t* tree-vect-slp.c: Fix typos.\n+\t* tree.c: Fix typos.\n+\t* tree.h: Fix typos.\n+\t* varasm.c: Fix typos.\n+\t* varpool.c: Fix typos.\n+\n 2012-05-29  Joseph Myers  <joseph@codesourcery.com>\n \n \t* doc/include/texinfo.tex: Update to version 2012-05-16.16."}, {"sha": "c1c48b37a4155773b7f0459064c92e8b1f84390e", "filename": "gcc/LANGUAGES", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2FLANGUAGES", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2FLANGUAGES", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FLANGUAGES?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -3,7 +3,7 @@ Right now there is no documentation for the GCC tree -> rtl interfaces\n \n Such documentation would be of great benefit to the project.  Until such\n time as we can formally start documenting the interface this file will\n-serve as a repository for information on these interface and any incompatable\n+serve as a repository for information on these interface and any incompatible\n changes we've made.\n \n 2004-09-09:"}, {"sha": "a6fe0e4eba20d1cc348a6d825d17669ec057f37d", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -293,7 +293,7 @@ mkinstalldirs=$(SHELL) $(srcdir)/../mkinstalldirs\n \n # write_entries_to_file - writes each entry in a list\n # to the specified file.  Entries are written in chunks of\n-# $(write_entries_to_file_split) to accomodate systems with\n+# $(write_entries_to_file_split) to accommodate systems with\n # severe command-line-length limitations.\n # Parameters:\n # $(1): variable containing entries to iterate over\n@@ -461,7 +461,7 @@ NATIVE_SYSTEM_HEADER_DIR = @NATIVE_SYSTEM_HEADER_DIR@\n CROSS_SYSTEM_HEADER_DIR = @CROSS_SYSTEM_HEADER_DIR@\n \n # autoconf sets SYSTEM_HEADER_DIR to one of the above.\n-# Purge it of unneccessary internal relative paths\n+# Purge it of unnecessary internal relative paths\n # to directories that might not exist yet.\n # The sed idiom for this is to repeat the search-and-replace until it doesn't match, using :a ... ta.\n # Use single quotes here to avoid nested double- and backquotes, this"}, {"sha": "2b89e587fe7f16aa532c14e2ce48386c380deb83", "filename": "gcc/alias.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -76,7 +76,7 @@ along with GCC; see the file COPYING3.  If not see\n \n    The first two questions can be answered with a simple examination\n    of the type system.  If structure X contains a field of type Y then\n-   a store thru a pointer to an X can overwrite any field that is\n+   a store through a pointer to an X can overwrite any field that is\n    contained (recursively) in an X (unless we know that px1 != px2).\n \n    The last two of the questions can be solved in the same way as the"}, {"sha": "86c5d62c561f213f3f4b10a06ed79bd87f65ff69", "filename": "gcc/auto-inc-dec.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fauto-inc-dec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fauto-inc-dec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fauto-inc-dec.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -495,7 +495,7 @@ attempt_change (rtx new_addr, rtx inc_reg)\n       return false;\n     }\n \n-  /* Jump thru a lot of hoops to keep the attributes up to date.  We\n+  /* Jump through a lot of hoops to keep the attributes up to date.  We\n      do not want to call one of the change address variants that take\n      an offset even though we know the offset in many cases.  These\n      assume you are changing where the address is pointing by the"}, {"sha": "89431cc32c06a3d51bf036b649b859258aa34b47", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -1524,7 +1524,7 @@ fix_up_fall_thru_edges (void)\n \t\t  /* We know the fall-thru edge crosses; if the cond\n \t\t     jump edge does NOT cross, and its destination is the\n \t\t     next block in the bb order, invert the jump\n-\t\t     (i.e. fix it so the fall thru does not cross and\n+\t\t     (i.e. fix it so the fall through does not cross and\n \t\t     the cond jump does).  */\n \n \t\t  if (!cond_jump_crosses\n@@ -2251,7 +2251,7 @@ partition_hot_cold_basic_blocks (void)\n \n   /* Convert all crossing fall_thru edges to non-crossing fall\n      thrus to unconditional jumps (that jump to the original fall\n-     thru dest).  */\n+     through dest).  */\n   fix_up_fall_thru_edges ();\n \n   /* If the architecture does not have conditional branches that can"}, {"sha": "23d36010458d1a3520f4b4188fffdddd779e9383", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -62,7 +62,7 @@ along with GCC; see the file COPYING3.  If not see\n /* Set to true when we are running first pass of try_optimize_cfg loop.  */\n static bool first_pass;\n \n-/* Set to true if crossjumps occured in the latest run of try_optimize_cfg.  */\n+/* Set to true if crossjumps occurred in the latest run of try_optimize_cfg.  */\n static bool crossjumps_occured;\n \n /* Set to true if we couldn't run an optimization due to stale liveness"}, {"sha": "3bf9541ecca13c6680d25b5911530874a0c6ef73", "filename": "gcc/cgraph.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -413,7 +413,7 @@ cgraph_get_create_node (tree decl)\n }\n \n /* Mark ALIAS as an alias to DECL.  DECL_NODE is cgraph node representing\n-   the function body is associated with (not neccesarily cgraph_node (DECL).  */\n+   the function body is associated with (not necessarily cgraph_node (DECL).  */\n \n struct cgraph_node *\n cgraph_create_function_alias (tree alias, tree decl)\n@@ -1581,7 +1581,7 @@ cgraph_node_can_be_local_p (struct cgraph_node *node)\n \t\t\t\t\t   NULL, true));\n }\n \n-/* Call calback on NODE, thunks and aliases asociated to NODE. \n+/* Call calback on NODE, thunks and aliases associated to NODE. \n    When INCLUDE_OVERWRITABLE is false, overwritable aliases and thunks are\n    skipped. */\n \n@@ -1617,7 +1617,7 @@ cgraph_for_node_thunks_and_aliases (struct cgraph_node *node,\n   return false;\n }\n \n-/* Call calback on NODE and aliases asociated to NODE. \n+/* Call calback on NODE and aliases associated to NODE. \n    When INCLUDE_OVERWRITABLE is false, overwritable aliases and thunks are\n    skipped. */\n \n@@ -2087,7 +2087,7 @@ verify_edge_count_and_frequency (struct cgraph_edge *e)\n   if (gimple_has_body_p (e->caller->symbol.decl)\n       && !e->caller->global.inlined_to\n       /* FIXME: Inline-analysis sets frequency to 0 when edge is optimized out.\n-\t Remove this once edges are actualy removed from the function at that time.  */\n+\t Remove this once edges are actually removed from the function at that time.  */\n       && (e->frequency\n \t  || (inline_edge_summary_vec\n \t      && ((VEC_length(inline_edge_summary_t, inline_edge_summary_vec)"}, {"sha": "0dec33f7757b13cb242d2c123f1439afa770c519", "filename": "gcc/cgraph.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -1181,7 +1181,7 @@ varpool_alias_aliased_node (struct varpool_node *n)\n \n /* Given NODE, walk the alias chain to return the function NODE is alias of.\n    Walk through thunk, too.\n-   When AVAILABILITY is non-NULL, get minimal availablity in the chain.  */\n+   When AVAILABILITY is non-NULL, get minimal availability in the chain.  */\n \n static inline struct cgraph_node *\n cgraph_function_node (struct cgraph_node *node, enum availability *availability)\n@@ -1211,7 +1211,7 @@ cgraph_function_node (struct cgraph_node *node, enum availability *availability)\n \n /* Given NODE, walk the alias chain to return the function NODE is alias of.\n    Do not walk through thunks.\n-   When AVAILABILITY is non-NULL, get minimal availablity in the chain.  */\n+   When AVAILABILITY is non-NULL, get minimal availability in the chain.  */\n \n static inline struct cgraph_node *\n cgraph_function_or_thunk_node (struct cgraph_node *node, enum availability *availability)\n@@ -1239,7 +1239,7 @@ cgraph_function_or_thunk_node (struct cgraph_node *node, enum availability *avai\n \n /* Given NODE, walk the alias chain to return the function NODE is alias of.\n    Do not walk through thunks.\n-   When AVAILABILITY is non-NULL, get minimal availablity in the chain.  */\n+   When AVAILABILITY is non-NULL, get minimal availability in the chain.  */\n \n static inline struct varpool_node *\n varpool_variable_node (struct varpool_node *node, enum availability *availability)"}, {"sha": "e47008f969cd1ddb690ae746e1284f234651f583", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -51,7 +51,7 @@ along with GCC; see the file COPYING3.  If not see\n       The symbol table is constructed starting from the trivially needed\n       symbols finalized by the frontend.  Functions are lowered into\n       GIMPLE representation and callgraph/reference lists are constructed.\n-      Those are used to discover other neccesary functions and variables.\n+      Those are used to discover other necessary functions and variables.\n \n       At the end the bodies of unreachable functions are removed.\n \n@@ -220,7 +220,7 @@ static GTY (()) tree vtable_entry_type;\n \n /* Determine if function DECL is trivially needed and should stay in the\n    compilation unit.  This is used at the symbol table construction time\n-   and differs from later logic removing unnecesary functions that can\n+   and differs from later logic removing unnecessary functions that can\n    take into account results of analysis, whole program info etc.  */\n \n static bool\n@@ -385,7 +385,7 @@ referred_to_p (symtab_node node)\n {\n   struct ipa_ref *ref;\n \n-  /* See if there are any refrences at all.  */\n+  /* See if there are any references at all.  */\n   if (ipa_ref_list_referring_iterate (&node->symbol.ref_list, 0, ref))\n     return true;\n   /* For functions check also calls.  */\n@@ -1534,7 +1534,7 @@ assemble_thunk (struct cgraph_node *node)\n \n \n \n-/* Assemble thunks and aliases asociated to NODE.  */\n+/* Assemble thunks and aliases associated to NODE.  */\n \n static void\n assemble_thunks_and_aliases (struct cgraph_node *node)\n@@ -1903,7 +1903,7 @@ get_alias_symbol (tree decl)\n \n \n /* Weakrefs may be associated to external decls and thus not output\n-   at expansion time.  Emit all neccesary aliases.  */\n+   at expansion time.  Emit all necessary aliases.  */\n \n static void\n output_weakrefs (void)"}, {"sha": "203f42cbd3db3adfd637efc1ddacee0dd6e786c0", "filename": "gcc/collect2-aix.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fcollect2-aix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fcollect2-aix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect2-aix.h?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -29,7 +29,7 @@ along with GCC; see the file COPYING3.  If not see\n    Definitions adapted from bfd.  (Fairly heavily adapted in some cases.)\n    ------------------------------------------------------------------------- */\n \n-/* Compatiblity types for bfd.  */\n+/* Compatibility types for bfd.  */\n typedef unsigned HOST_WIDE_INT bfd_vma;\n \n /* The size of an archive's fl_magic field.  */\n@@ -135,7 +135,7 @@ struct external_filehdr_32\n   /* The number of entries in the symbol table.  */\n   char f_nsyms[4];\n \n-  /* The size of the auxillary header.  */\n+  /* The size of the auxiliary header.  */\n   char f_opthdr[2];\n \n   /* Flags.  */\n@@ -157,7 +157,7 @@ struct external_filehdr_64\n   /* The offset of the symbol table from the start of the file.  */\n   char f_symptr[8];\n \n-  /* The size of the auxillary header.  */\n+  /* The size of the auxiliary header.  */\n   char f_opthdr[2];\n \n   /* Flags.  */\n@@ -222,7 +222,7 @@ struct external_syment\n   /* The class of symbol (a C_* value).  */\n   char n_sclass[1];\n \n-  /* The number of auxillary symbols attached to this entry.  */\n+  /* The number of auxiliary symbols attached to this entry.  */\n   char n_numaux[1];\n };\n "}, {"sha": "9ee12c7a50267c643450a554b7d044886cf91cc4", "filename": "gcc/collect2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fcollect2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fcollect2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect2.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -842,7 +842,7 @@ add_lto_object (struct lto_object_list *list, const char *name)\n    files contain LTO info.  The linker command line LTO_LD_ARGV\n    represents the linker command that would produce a final executable\n    without the use of LTO. OBJECT_LST is a vector of object file names\n-   appearing in LTO_LD_ARGV that are to be considerd for link-time\n+   appearing in LTO_LD_ARGV that are to be considered for link-time\n    recompilation, where OBJECT is a pointer to the last valid element.\n    (This awkward convention avoids an impedance mismatch with the\n    usage of similarly-named variables in main().)  The elements of\n@@ -2567,7 +2567,7 @@ scan_prog_file (const char *prog_name, scanpass which_pass,\n \n   /* LTO objects must be in a known format.  This check prevents\n      us from accepting an archive containing LTO objects, which\n-     gcc cannnot currently handle.  */\n+     gcc cannot currently handle.  */\n   if (which_pass == PASS_LTOINFO && !maybe_lto_object_file (prog_name))\n     return;\n "}, {"sha": "b021e8daf88ea69fbcee79099a381e0cfeedb20a", "filename": "gcc/compare-elim.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fcompare-elim.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fcompare-elim.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcompare-elim.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -494,7 +494,7 @@ try_eliminate_compare (struct comparison *cmp)\n {\n   rtx x, insn, bb_head, flags, in_a, cmp_src;\n \n-  /* We must have found an interesting \"clobber\" preceeding the compare.  */\n+  /* We must have found an interesting \"clobber\" preceding the compare.  */\n   if (cmp->prev_clobber == NULL)\n     return false;\n "}, {"sha": "03d9b9b229a53a32d8b3c533e2e28e825feb4906", "filename": "gcc/config/alpha/vms.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Falpha%2Fvms.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Falpha%2Fvms.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fvms.h?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -153,7 +153,7 @@ typedef struct {int num_args; enum avms_arg_type atypes[6];} avms_arg_info;\n \n #define DEFAULT_PCC_STRUCT_RETURN 0\n \n-/* Eventhough pointers are 64bits, only 32bit ever remain significant in code\n+/* Even though pointers are 64bits, only 32bit ever remain significant in code\n    addresses.  */\n #define MASK_RETURN_ADDR                                \\\n   (flag_vms_pointer_size == VMS_POINTER_SIZE_NONE       \\"}, {"sha": "cfa7f66e29468c1ad1648c615efaab7673e68bcb", "filename": "gcc/config/arm/README-interworking", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Farm%2FREADME-interworking", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Farm%2FREADME-interworking", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2FREADME-interworking?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -227,7 +227,7 @@ considerations when building programs and DLLs:\n \n Switching between the ARM and Thumb instruction sets is accomplished\n via the BX instruction which takes as an argument a register name.\n-Control is transfered to the address held in this register (with the\n+Control is transferred to the address held in this register (with the\n bottom bit masked out), and if the bottom bit is set, then Thumb\n instruction processing is enabled, otherwise ARM instruction\n processing is enabled."}, {"sha": "e2eebda958ee0ab354688ab6c12eabbfbd4cfdfb", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -2588,7 +2588,7 @@ optimal_immediate_sequence (enum rtx_code code, unsigned HOST_WIDE_INT val,\n   int insns1, insns2;\n   struct four_ints tmp_sequence;\n \n-  /* If we aren't targetting ARM, the best place to start is always at\n+  /* If we aren't targeting ARM, the best place to start is always at\n      the bottom, otherwise look more closely.  */\n   if (TARGET_ARM)\n     {\n@@ -8473,7 +8473,7 @@ cortex_a9_sched_adjust_cost (rtx insn, rtx link, rtx dep, int * cost)\n \t\t\t&& reg_overlap_mentioned_p (SET_DEST (PATTERN (insn)),\n \t\t\t\t\t\t    SET_DEST (PATTERN (dep))))\n \t\t      {\n-\t\t\t/* FMACS is a special case where the dependant\n+\t\t\t/* FMACS is a special case where the dependent\n \t\t\t   instruction can be issued 3 cycles before\n \t\t\t   the normal latency in case of an output\n \t\t\t   dependency.  */\n@@ -16187,7 +16187,7 @@ arm_output_epilogue (rtx sibling)\n \t now we have to use add/sub in those cases. However, the value\n \t of that would be marginal, as both mov and add/sub are 32-bit\n \t in ARM mode, and it would require extra conditionals\n-\t in arm_expand_prologue to distingish ARM-apcs-frame case\n+\t in arm_expand_prologue to distinguish ARM-apcs-frame case\n \t (where frame pointer is required to point at first register)\n \t and ARM-non-apcs-frame. Therefore, such change is postponed\n \t until real need arise.  */"}, {"sha": "bb0d44e75e0165879bf664425fedb186ddbc0b4d", "filename": "gcc/config/arm/iterators.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Farm%2Fiterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Farm%2Fiterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fiterators.md?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -36,7 +36,7 @@\n ;; A list of integer modes that are less than a word\n (define_mode_iterator NARROW [QI HI])\n \n-;; A list of all the integer modes upto 64bit\n+;; A list of all the integer modes up to 64bit\n (define_mode_iterator QHSD [QI HI SI DI])\n \n ;; A list of the 32bit and 64bit integer modes"}, {"sha": "391c166336b5cdfa801d93e310d79b7a50d4b5d3", "filename": "gcc/config/arm/vxworks.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Farm%2Fvxworks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Farm%2Fvxworks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fvxworks.h?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GCC,\n-   for ARM with targetting the VXWorks run time environment. \n+   for ARM with targeting the VXWorks run time environment. \n    Copyright (C) 1999, 2000, 2003, 2004, 2007, 2008, 2009, 2010, 2011\n    Free Software Foundation, Inc.\n "}, {"sha": "208f650c9afcdd2dc614edd35534904d97e765cd", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -6840,7 +6840,7 @@ avr_progmem_p (tree decl, tree attributes)\n /* Scan type TYP for pointer references to address space ASn.\n    Return ADDR_SPACE_GENERIC (i.e. 0) if all pointers targeting\n    the AS are also declared to be CONST.\n-   Otherwise, return the respective addres space, i.e. a value != 0.  */\n+   Otherwise, return the respective address space, i.e. a value != 0.  */\n    \n static addr_space_t\n avr_nonconst_pointer_addrspace (tree typ)\n@@ -6884,7 +6884,7 @@ avr_nonconst_pointer_addrspace (tree typ)\n }\n \n \n-/* Sanity check NODE so that all pointers targeting non-generic addres spaces\n+/* Sanity check NODE so that all pointers targeting non-generic address spaces\n    go along with CONST qualifier.  Writing to these address spaces should\n    be detected and complained about as early as possible.  */\n \n@@ -9727,7 +9727,7 @@ avr_emit_movmemhi (rtx *xop)\n   /* FIXME: Register allocator does a bad job and might spill address\n         register(s) inside the loop leading to additional move instruction\n         to/from stack which could clobber tmp_reg.  Thus, do *not* emit\n-        load and store as seperate insns.  Instead, we perform the copy\n+        load and store as separate insns.  Instead, we perform the copy\n         by means of one monolithic insn.  */\n \n   gcc_assert (TMP_REGNO == LPM_REGNO);"}, {"sha": "54c127469e1c9b6759089798821779da557ab544", "filename": "gcc/config/avr/avr.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Favr%2Favr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Favr%2Favr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.h?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -713,7 +713,7 @@ struct GTY(()) machine_function\n   int attributes_checked_p;\n };\n \n-/* AVR does not round pushes, but the existance of this macro is\n+/* AVR does not round pushes, but the existence of this macro is\n    required in order for pushes to be generated.  */\n #define PUSH_ROUNDING(X)\t(X)\n "}, {"sha": "2b1a83c607a29056ba27bb946ff2c16a0ab4ab92", "filename": "gcc/config/avr/avr.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Favr%2Favr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Favr%2Favr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.md?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -29,7 +29,7 @@\n ;;  k  Reverse branch condition.\n ;;..m..Constant Direct Data memory address.\n ;;  i  Print the SFR address quivalent of a CONST_INT or a CONST_INT\n-;;     RAM address.  The resulting addres is suitable to be used in IN/OUT.\n+;;     RAM address.  The resulting address is suitable to be used in IN/OUT.\n ;;  o  Displacement for (mem (plus (reg) (const_int))) operands.\n ;;  p  POST_INC or PRE_DEC address as a pointer (X, Y, Z)\n ;;  r  POST_INC or PRE_DEC address as a register (r26, r28, r30)"}, {"sha": "4b04ff1b367853dbdf0590702c18b355b8a67f07", "filename": "gcc/config/avr/builtins.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Favr%2Fbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Favr%2Fbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Fbuiltins.def?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -38,7 +38,7 @@ DEF_BUILTIN (\"__builtin_avr_cli\",   0, AVR_BUILTIN_CLI, void_ftype_void, CODE_FO\n DEF_BUILTIN (\"__builtin_avr_wdr\",   0, AVR_BUILTIN_WDR,   void_ftype_void, CODE_FOR_wdr)\n DEF_BUILTIN (\"__builtin_avr_sleep\", 0, AVR_BUILTIN_SLEEP, void_ftype_void, CODE_FOR_sleep)\n \n-/* Mapped to respective instruction but might alse be folded away\n+/* Mapped to respective instruction but might also be folded away\n    or emit as libgcc call if ISA does not provide the instruction.  */\n DEF_BUILTIN (\"__builtin_avr_swap\",   1, AVR_BUILTIN_SWAP,   uchar_ftype_uchar,      CODE_FOR_rotlqi3_4)\n DEF_BUILTIN (\"__builtin_avr_fmul\",   2, AVR_BUILTIN_FMUL,   uint_ftype_uchar_uchar, CODE_FOR_fmul)"}, {"sha": "a613bbae8e1029e993636c4b5293a9796310c0cd", "filename": "gcc/config/c6x/c6x.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Fc6x%2Fc6x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Fc6x%2Fc6x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc6x%2Fc6x.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -3630,7 +3630,7 @@ typedef struct c6x_sched_context\n /* The current scheduling state.  */\n static struct c6x_sched_context ss;\n \n-/* The following variable value is DFA state before issueing the first insn\n+/* The following variable value is DFA state before issuing the first insn\n    in the current clock cycle.  This is used in c6x_variable_issue for\n    comparison with the state after issuing the last insn in a cycle.  */\n static state_t prev_cycle_state;"}, {"sha": "df272600c8b7e6de5829bcdd228143f168d7ec34", "filename": "gcc/config/cr16/cr16.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Fcr16%2Fcr16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Fcr16%2Fcr16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcr16%2Fcr16.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -61,7 +61,7 @@\n #define FUNC_IS_NORETURN_P(decl) (TREE_THIS_VOLATILE (decl))\n \n /* Predicate that holds when we need to save registers even for 'noreturn'\n-   functions, to accomodate for unwinding.  */\n+   functions, to accommodate for unwinding.  */\n #define MUST_SAVE_REGS_P() \\\n   (flag_unwind_tables || (flag_exceptions && !UI_SJLJ))\n "}, {"sha": "12072b46f0cf566d1b8a5f287d8966b45a151430", "filename": "gcc/config/cr16/cr16.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Fcr16%2Fcr16.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Fcr16%2Fcr16.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcr16%2Fcr16.md?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -144,7 +144,7 @@\n   [(set_attr \"length\" \"2\")]\n )\n \n-;; Arithmetic Instuction  Patterns\n+;; Arithmetic Instruction  Patterns\n \n ;; Addition-Subtraction \"adddi3/subdi3\" insns.\n (define_insn \"<plusminus_insn>di3\""}, {"sha": "7d691f5a0b54c9118260e2ec86e8f064e2c89990", "filename": "gcc/config/cris/cris.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Fcris%2Fcris.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Fcris%2Fcris.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.md?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -1530,7 +1530,7 @@\n   \"movs<m> %1,%0\"\n   [(set_attr \"slottable\" \"yes,yes,no\")])\n \n-;; To do a byte->word extension, extend to dword, exept that the top half\n+;; To do a byte->word extension, extend to dword, except that the top half\n ;; of the register will be clobbered.  FIXME: Perhaps this is not needed.\n \n (define_insn \"extendqihi2\""}, {"sha": "6805cf1264e1d040da1c2654ffc75aa34e9b8c30", "filename": "gcc/config/darwin.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Fdarwin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Fdarwin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -3461,7 +3461,7 @@ darwin_function_section (tree decl, enum node_frequency freq,\n \n   /* Startup code should go to startup subsection unless it is\n      unlikely executed (this happens especially with function splitting\n-     where we can split away unnecesary parts of static constructors).  */\n+     where we can split away unnecessary parts of static constructors).  */\n   if (startup && freq != NODE_FREQUENCY_UNLIKELY_EXECUTED)\n     return (weak)\n \t    ? darwin_sections[text_startup_coal_section]"}, {"sha": "23419f9b0b1c0891cc076050aa90c00d329bbca0", "filename": "gcc/config/darwin.opt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Fdarwin.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Fdarwin.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.opt?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -224,7 +224,7 @@ Generate code suitable for fast turn around debugging\n ; and cc1plus don't crash if no -mmacosx-version-min is passed.  The\n ; driver will always pass a -mmacosx-version-min, so in normal use the\n ; Init is never used.  Useful for setting the OS on which people\n-; ususally debug.\n+; usually debug.\n mmacosx-version-min=\n Target Joined Report Var(darwin_macosx_version_min) Init(\"10.6\")\n The earliest MacOS X version on which this program will run"}, {"sha": "0f78d8928eda53b99a302c043a625bdeba0041ea", "filename": "gcc/config/i386/i386-c.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Fi386%2Fi386-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Fi386%2Fi386-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-c.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -48,7 +48,7 @@ ix86_target_macros_internal (HOST_WIDE_INT isa_flag,\n \t\t\t     void (*def_or_undef) (cpp_reader *,\n \t\t\t\t\t\t   const char *))\n {\n-  /* For some of the k6/pentium varients there weren't seperate ISA bits to\n+  /* For some of the k6/pentium varients there weren't separate ISA bits to\n      identify which tune/arch flag was passed, so figure it out here.  */\n   size_t arch_len = strlen (ix86_arch_string);\n   size_t tune_len = strlen (ix86_tune_string);"}, {"sha": "30dbb0899715460f23f9dbdf9ff90dc473282e01", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -9185,7 +9185,7 @@ choose_baseaddr (HOST_WIDE_INT cfa_offset)\n   if (m->use_fast_prologue_epilogue)\n     {\n       /* Choose the base register most likely to allow the most scheduling\n-         opportunities.  Generally FP is valid througout the function,\n+         opportunities.  Generally FP is valid throughout the function,\n          while DRAP must be reloaded within the epilogue.  But choose either\n          over the SP due to increased encoding size.  */\n \n@@ -33112,7 +33112,7 @@ ix86_count_insn (basic_block bb)\n   return min_prev_count;\n }\n \n-/* Pad short funtion to 4 instructions.   */\n+/* Pad short function to 4 instructions.   */\n \n static void\n ix86_pad_short_function (void)\n@@ -36909,7 +36909,7 @@ expand_vec_perm_interleave2 (struct expand_vec_perm_d *d)\n \t{\n \t  if (d->perm[0] / nelt2 == nonzero_halves[1])\n \t    {\n-\t      /* Attempt to increase the likelyhood that dfinal\n+\t      /* Attempt to increase the likelihood that dfinal\n \t\t shuffle will be intra-lane.  */\n \t      char tmph = nonzero_halves[0];\n \t      nonzero_halves[0] = nonzero_halves[1];\n@@ -38985,7 +38985,7 @@ fits_dispatch_window (rtx insn)\n   /* Make disp_cmp and disp_jcc get scheduled at the latest.  These\n      instructions should be given the lowest priority in the\n      scheduling process in Haifa scheduler to make sure they will be\n-     scheduled in the same dispatch window as the refrence to them.  */\n+     scheduled in the same dispatch window as the reference to them.  */\n   if (group == disp_jcc || group == disp_cmp)\n     return false;\n "}, {"sha": "9a8bc0789c6e4011db969e5770df87adb9c18259", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -3454,7 +3454,7 @@ output_probe_stack_range (rtx reg1, rtx reg2)\n    Also any insns generated here should have RTX_FRAME_RELATED_P(insn) = 1\n    so that the debug info generation code can handle them properly.\n \n-   The register save area is layed out like so:\n+   The register save area is laid out like so:\n    cfa+16\n \t[ varargs spill area ]\n \t[ fr register spill area ]"}, {"sha": "96519dc9e4dd60773fa8f33fbddb6172785c3d4e", "filename": "gcc/config/m68k/cf.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Fm68k%2Fcf.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Fm68k%2Fcf.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fcf.md?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -52,7 +52,7 @@\n \n (define_cpu_unit \"cf_dsoc,cf_agex\" \"cfv123_oep\")\n \n-;; A memory unit that is reffered to as 'certain hardware resources' in\n+;; A memory unit that is referred to as 'certain hardware resources' in\n ;; ColdFire reference manuals.  This unit remains occupied for two cycles\n ;; after last dsoc cycle of a store - hence there is a 2 cycle delay between\n ;; two consecutive stores."}, {"sha": "f9ebab840488fa5104309b73316a9b4d6ddcaf5e", "filename": "gcc/config/mep/mep.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Fmep%2Fmep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Fmep%2Fmep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmep%2Fmep.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -3869,7 +3869,7 @@ static int prev_opcode = 0;\n \n /* This isn't as optimal as it could be, because we don't know what\n    control register the STC opcode is storing in.  We only need to add\n-   the nop if it's the relevent register, but we add it for irrelevent\n+   the nop if it's the relevant register, but we add it for irrelevant\n    registers also.  */\n \n void\n@@ -6993,7 +6993,7 @@ core_insn_p (rtx insn)\n }\n \n /* Mark coprocessor instructions that can be bundled together with\n-   the immediately preceeding core instruction.  This is later used\n+   the immediately preceding core instruction.  This is later used\n    to emit the \"+\" that tells the assembler to create a VLIW insn.\n \n    For unbundled insns, the assembler will automatically add coprocessor"}, {"sha": "081715d98235372d70a5c8671cf9e10dd8039d75", "filename": "gcc/config/microblaze/microblaze.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -190,7 +190,7 @@ enum reg_class microblaze_regno_to_class[] =\n /* MicroBlaze specific machine attributes.\n    interrupt_handler - Interrupt handler attribute to add interrupt prologue \n \t\t       and epilogue and use appropriate interrupt return.\n-   save_volatiles    - Similiar to interrupt handler, but use normal return.  */\n+   save_volatiles    - Similar to interrupt handler, but use normal return.  */\n int interrupt_handler;\n int save_volatiles;\n "}, {"sha": "d17d89483355bf4bfa8d5fde76c71badd801f29d", "filename": "gcc/config/microblaze/microblaze.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmicroblaze%2Fmicroblaze.h?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -546,7 +546,7 @@ typedef struct microblaze_args\n \n #define FUNCTION_MODE   SImode\n \n-/* Mode should alwasy be SImode */\n+/* Mode should always be SImode */\n #define REGISTER_MOVE_COST(MODE, FROM, TO)\t\t\t\\\n   ( GR_REG_CLASS_P (FROM) && GR_REG_CLASS_P (TO) ? 2 \t\t\\\n    : (FROM) == ST_REGS && GR_REG_CLASS_P (TO) ? 4\t\t\\"}, {"sha": "5b9f0699469af2a14b1da6a6c167ca4540335be1", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -2762,7 +2762,7 @@ mn10300_adjust_sched_cost (rtx insn, rtx link, rtx dep, int cost)\n       Chapter 3 of the MN103E Series Instruction Manual\n       where it says:\n \n-        \"When the preceeding instruction is a CPU load or\n+        \"When the preceding instruction is a CPU load or\n \t store instruction, a following FPU instruction\n \t cannot be executed until the CPU completes the\n \t latency period even though there are no register\n@@ -2788,7 +2788,7 @@ mn10300_adjust_sched_cost (rtx insn, rtx link, rtx dep, int cost)\n     return cost;\n \n   /* XXX: Verify: The text of 1-7-4 implies that the restriction\n-     only applies when an INTEGER load/store preceeds an FPU\n+     only applies when an INTEGER load/store precedes an FPU\n      instruction, but is this true ?  For now we assume that it is.  */\n   if (GET_MODE_CLASS (GET_MODE (SET_SRC (PATTERN (insn)))) != MODE_INT)\n     return cost;"}, {"sha": "a1cbc7a9fd427f315a4fe40c15d2f842cbdd0a60", "filename": "gcc/config/mn10300/mn10300.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.md?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -999,7 +999,7 @@\n ;; ??? Note that AM33 has a third multiply variant that puts the high part\n ;; into the MDRQ register, however this variant also constrains the inputs\n ;; to be in DATA_REGS and thus isn't as helpful as it might be considering\n-;; the existance of the 4-operand multiply.  Nor is there a set of divide\n+;; the existence of the 4-operand multiply.  Nor is there a set of divide\n ;; insns that use MDRQ.  Given that there is an IMM->MDRQ insn, this would\n ;; have been very handy for starting udivmodsi4...\n \n@@ -1808,7 +1808,7 @@\n )\n \n ;; ----------------------------------------------------------------------\n-;; MISCELANEOUS\n+;; MISCELLANEOUS\n ;; ----------------------------------------------------------------------\n \n ;; Note the use of the (const_int 0) when generating the insn that matches"}, {"sha": "a95d7037724d805a2169650fcfce547cc596483c", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -5939,7 +5939,7 @@ pa_secondary_reload (bool in_p, rtx x, reg_class_t rclass_i,\n \t}\n \n       /* Request a secondary reload with a general scratch register\n-\t for everthing else.  ??? Could symbolic operands be handled\n+\t for everything else.  ??? Could symbolic operands be handled\n \t directly when generating non-pic PA 2.0 code?  */\n       sri->icode = (in_p\n \t\t    ? direct_optab_handler (reload_in_optab, mode)"}, {"sha": "9eb7df94c014768aca39a9e1ff91e9ede0699e79", "filename": "gcc/config/picochip/picochip.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Fpicochip%2Fpicochip.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Fpicochip%2Fpicochip.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpicochip%2Fpicochip.h?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -221,7 +221,7 @@ extern enum picochip_dfa_type picochip_schedule_type;\n #define CALL_USED_REGISTERS {1,1,1,1,1,1,0,0, 0,0,0,0,1,1,0,1, 1,1,1,1}\n #define CALL_REALLY_USED_REGISTERS {1,1,1,1,1,1,0,0, 0,0,0,0,1,1,0,0, 0,1,0,0}\n \n-/* Define the number of the picoChip link and condition psuedo registers. */\n+/* Define the number of the picoChip link and condition pseudo registers. */\n #define LINK_REGNUM 12\n #define CC_REGNUM 17\n #define ACC_REGNUM 16"}, {"sha": "79fdf913de15c9da130d2daec073010e2ab51269", "filename": "gcc/config/rs6000/a2.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Frs6000%2Fa2.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Frs6000%2Fa2.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fa2.md?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -25,7 +25,7 @@\n ;; The multiplier pipeline.\n (define_cpu_unit \"mult\" \"ppca2\")\n \n-;; The auxillary processor unit (FP/vector unit).\n+;; The auxiliary processor unit (FP/vector unit).\n (define_cpu_unit \"axu\" \"ppca2\")\n \n ;; D.4.6"}, {"sha": "3d895390bcca98ef9b4fcfe10e141f5770e55903", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -2077,7 +2077,7 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n \n   /* TODO add SPE and paired floating point vector support.  */\n \n-  /* Register class constaints for the constraints that depend on compile\n+  /* Register class constraints for the constraints that depend on compile\n      switches.  */\n   if (TARGET_HARD_FLOAT && TARGET_FPRS)\n     rs6000_constraints[RS6000_CONSTRAINT_f] = FLOAT_REGS;\n@@ -2328,7 +2328,7 @@ darwin_rs6000_override_options (void)\n \n   /* Unless the user (not the configurer) has explicitly overridden\n      it with -mcpu=G3 or -mno-altivec, then 10.5+ targets default to\n-     G4 unless targetting the kernel.  */\n+     G4 unless targeting the kernel.  */\n   if (!flag_mkernel\n       && !flag_apple_kext\n       && strverscmp (darwin_macosx_version_min, \"10.5\") >= 0"}, {"sha": "87a52762a4d7cba318d67e9a35c458d15e9bfebf", "filename": "gcc/config/rs6000/vector.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Frs6000%2Fvector.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Frs6000%2Fvector.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvector.md?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -172,7 +172,7 @@\n \n \n \f\n-;; Reload patterns for vector operations.  We may need an addtional base\n+;; Reload patterns for vector operations.  We may need an additional base\n ;; register to convert the reg+offset addressing to reg+reg for vector\n ;; registers and reg+reg or (reg+reg)&(-16) addressing to just an index\n ;; register for gpr registers."}, {"sha": "95ba051a48639d39146ba0dfb080eff488d3f387", "filename": "gcc/config/rx/rx.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Frx%2Frx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Frx%2Frx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx.md?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -408,7 +408,7 @@\n \n ;; Note - the following set of patterns do not use the \"memory_operand\"\n ;; predicate or an \"m\" constraint because we do not allow symbol_refs\n-;; or label_refs as legitmate memory addresses.  This matches the\n+;; or label_refs as legitimate memory addresses.  This matches the\n ;; behaviour of most of the RX instructions.  Only the call/branch\n ;; instructions are allowed to refer to symbols/labels directly.\n ;; The call operands are in QImode because that is the value of"}, {"sha": "76c2f61c79bcffe2320cec82c6e8b042fe9df877", "filename": "gcc/config/rx/rx.opt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Frx%2Frx.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Frx%2Frx.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx.opt?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -87,7 +87,7 @@ Use the simulator runtime.\n \n mas100-syntax\n Target Mask(AS100_SYNTAX) Report\n-Generate assembler output that is compatible with the Renesas AS100 assembler.  This may restrict some of the compiler's capabilities.  The default is to generate GAS compatable syntax.\n+Generate assembler output that is compatible with the Renesas AS100 assembler.  This may restrict some of the compiler's capabilities.  The default is to generate GAS compatible syntax.\n \n ;---------------------------------------------------\n "}, {"sha": "333e1b26ff4547157811dde64d4ca7f8799bc6ed", "filename": "gcc/config/s390/2097.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Fs390%2F2097.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Fs390%2F2097.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2F2097.md?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -703,11 +703,11 @@\n \n \n ; Declaration for some pseudo-pipeline stages that reflect the\n-; dispatch gap when issueing an INT/FXU/BFU-executed instruction after\n+; dispatch gap when issuing an INT/FXU/BFU-executed instruction after\n ; an instruction executed by a different unit has been executed.  The\n ; approach is that we pretend a pipelined execution of BFU operations\n ; with as many stages as the gap is long and request that none of\n-; these stages is busy when issueing a FXU- or DFU-executed\n+; these stages is busy when issuing a FXU- or DFU-executed\n ; instruction.  Similar for FXU- and DFU-executed instructions.\n \n ; Declaration for FPU stages."}, {"sha": "934e68b53a34bda4b9eedcaa22e7716fbb70074a", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -10533,7 +10533,7 @@ s390_z10_prevent_earlyload_conflicts (rtx *ready, int *nready_p)\n }\n \n /* This function is called via hook TARGET_SCHED_REORDER before\n-   issueing one insn from list READY which contains *NREADYP entries.\n+   issuing one insn from list READY which contains *NREADYP entries.\n    For target z10 it reorders load instructions to avoid early load\n    conflicts in the floating point pipeline  */\n static int"}, {"sha": "f69b3174b005d8b8724daedee703bdd65e2f5f15", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -762,7 +762,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n /* This value is used in tree-sra to decide whether it might benefical\n    to split a struct move into several word-size moves.  For S/390\n    only small values make sense here since struct moves are relatively\n-   cheap thanks to mvc so the small default value choosen for archs\n+   cheap thanks to mvc so the small default value chosen for archs\n    with memmove patterns should be ok.  But this value is multiplied\n    in tree-sra with UNITS_PER_WORD to make a decision so we adjust it\n    here to compensate for that factor since mvc costs exactly the same"}, {"sha": "048a7549739af91492e4df63389a4fb921253645", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -393,7 +393,7 @@ static const struct attribute_spec sh_attribute_table[] =\n    The insn that frees registers is most likely to be the insn with lowest\n    LUID (original insn order); but such an insn might be there in the stalled\n    queue (Q) instead of the ready queue (R).  To solve this, we skip cycles\n-   upto a max of 8 cycles so that such insns may move from Q -> R.\n+   up to a max of 8 cycles so that such insns may move from Q -> R.\n \n    The description of the hooks are as below:\n \n@@ -11478,7 +11478,7 @@ sh_expand_binop_v2sf (enum rtx_code code, rtx op0, rtx op1, rtx op2)\n    We could hold SFmode / SCmode values in XD registers, but that\n    would require a tertiary reload when reloading from / to memory,\n    and a secondary reload to reload from / to general regs; that\n-   seems to be a loosing proposition.\n+   seems to be a losing proposition.\n \n    We want to allow TImode FP regs so that when V4SFmode is loaded as TImode,\n    it won't be ferried through GP registers first.  */"}, {"sha": "99d4c625f23950871aa63e601eca14cd893e4d5e", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -577,7 +577,7 @@\n   (and (eq_attr \"type\" \"cbranch\")\n        (match_test \"TARGET_SH2\"))\n   ;; SH2e has a hardware bug that pretty much prohibits the use of\n-  ;; annuled delay slots.\n+  ;; annulled delay slots.\n   [(eq_attr \"cond_delay_slot\" \"yes\") (and (eq_attr \"cond_delay_slot\" \"yes\")\n \t\t\t\t\t  (not (eq_attr \"cpu\" \"sh2e\"))) (nil)])\n \f\n@@ -631,7 +631,7 @@\n   [(set_attr \"type\" \"mt_group\")])\n \n ;; Test low QI subreg against zero.\n-;; This avoids unecessary zero extension before the test.\n+;; This avoids unnecessary zero extension before the test.\n \n (define_insn \"tstqi_t_zero\"\n   [(set (reg:SI T_REG)\n@@ -5470,7 +5470,7 @@ label:\n ;; selected to copy QImode regs.  If one of them happens to be allocated\n ;; on the stack, reload will stick to movqi insn and generate wrong\n ;; displacement addressing because of the generic m alternatives.  \n-;; With the movqi_reg_reg being specified before movqi it will be intially \n+;; With the movqi_reg_reg being specified before movqi it will be initially \n ;; picked to load/store regs.  If the regs regs are on the stack reload will\n ;; try other insns and not stick to movqi_reg_reg.\n ;; The same applies to the movhi variants."}, {"sha": "d11f663649003e6dcd34abb3bb3c517d741d8662", "filename": "gcc/config/sparc/sync.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Fsparc%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Fsparc%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsync.md?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -45,7 +45,7 @@\n })\n \n ;; A compiler-only memory barrier.  Generic code, when checking for the\n-;; existance of various named patterns, uses asm(\"\":::\"memory\") when we\n+;; existence of various named patterns, uses asm(\"\":::\"memory\") when we\n ;; don't need an actual instruction.  Here, it's easiest to pretend that\n ;; membar 0 is such a barrier.  Further, this gives us a nice hook to \n ;; ignore all such barriers on Sparc V7."}, {"sha": "fb482fb4c8202a5911cb816add35a2152460d9fb", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -2870,7 +2870,7 @@ spu_machine_dependent_reorg (void)\n \t    prop = prev;\n \n \t  /* If this is the JOIN block of a simple IF-THEN then\n-\t     propogate the hint to the HEADER block. */\n+\t     propagate the hint to the HEADER block. */\n \t  else if (prev && prev2\n \t\t   && EDGE_COUNT (bb->preds) == 2\n \t\t   && EDGE_COUNT (prev->preds) == 1\n@@ -3124,7 +3124,7 @@ spu_sched_variable_issue (FILE *file ATTRIBUTE_UNUSED,\n \tprev_priority = INSN_PRIORITY (insn);\n     }\n \n-  /* Always try issueing more insns.  spu_sched_reorder will decide \n+  /* Always try issuing more insns.  spu_sched_reorder will decide \n      when the cycle should be advanced. */\n   return 1;\n }\n@@ -3231,7 +3231,7 @@ spu_sched_reorder (FILE *file ATTRIBUTE_UNUSED, int verbose ATTRIBUTE_UNUSED,\n      used to effect it. */\n   if (in_spu_reorg && spu_dual_nops < 10)\n     {\n-      /* When we are at an even address and we are not issueing nops to\n+      /* When we are at an even address and we are not issuing nops to\n          improve scheduling then we need to advance the cycle.  */\n       if ((spu_sched_length & 7) == 0 && prev_clock_var == clock\n \t  && (spu_dual_nops == 0"}, {"sha": "03ed45755916c89f30fc50b959d8611d1e4a5e89", "filename": "gcc/config/spu/spu.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Fspu%2Fspu.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Fspu%2Fspu.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.md?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -4209,7 +4209,7 @@ selb\\t%0,%4,%0,%3\"\n   \"\"\n   { spu_expand_prologue (); DONE; })\n \n-;; \"blockage\" is only emited in epilogue.  This is what it took to\n+;; \"blockage\" is only emitted in epilogue.  This is what it took to\n ;; make \"basic block reordering\" work with the insns sequence\n ;; generated by the spu_expand_epilogue (taken from mips.md)\n "}, {"sha": "d23e8a8456ab620cc9786f14a499734d324b9280", "filename": "gcc/config/vms/vms.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Fvms%2Fvms.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Fvms%2Fvms.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvms%2Fvms.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -99,12 +99,12 @@ static const struct vms_crtl_name vms_crtl_names[] =\n \n #define NBR_CRTL_NAMES (sizeof (vms_crtl_names) / sizeof (*vms_crtl_names))\n \n-/* List of aliased identifiers.  They must be persistant accross gc.  */\n+/* List of aliased identifiers.  They must be persistent across gc.  */\n \n static GTY(()) VEC(tree,gc) *aliases_id;\n \n /* Add a CRTL translation.  This simply use the transparent alias\n-   mechanism, which is platform independant and works with the\n+   mechanism, which is platform independent and works with the\n    #pragma extern_prefix (which set the assembler name).  */\n \n static void"}, {"sha": "e2ea7fa4d641c9ee432599a51f97ff4fdf3a238f", "filename": "gcc/config/vxworks-dummy.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Fvxworks-dummy.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Fvxworks-dummy.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvxworks-dummy.h?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -22,7 +22,7 @@ a copy of the GCC Runtime Library Exception along with this program;\n see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n-/* True if we're targetting VxWorks.  */\n+/* True if we're targeting VxWorks.  */\n #ifndef TARGET_VXWORKS\n #define TARGET_VXWORKS 0\n #endif"}, {"sha": "000de3604f6b1683b5a7d8d214b3c7a1157829bd", "filename": "gcc/config/vxworks.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Fvxworks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fconfig%2Fvxworks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvxworks.h?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -20,7 +20,7 @@ You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n-/* Assert that we are targetting VxWorks.  */\n+/* Assert that we are targeting VxWorks.  */\n #undef TARGET_VXWORKS\n #define TARGET_VXWORKS 1\n "}, {"sha": "11c5652a74eb785bd68b383805b39d4d55aa6cb6", "filename": "gcc/cselib.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -1374,7 +1374,7 @@ cselib_lookup_mem (rtx x, int create)\n   return mem_elt;\n }\n \n-/* Search thru the possible substitutions in P.  We prefer a non reg\n+/* Search through the possible substitutions in P.  We prefer a non reg\n    substitution because this allows us to expand the tree further.  If\n    we find, just a reg, take the lowest regno.  There may be several\n    non-reg results, we just take the first one because they will all"}, {"sha": "c5e733404e162537fe6c4ed6a93029d109e96505", "filename": "gcc/df-scan.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -3734,7 +3734,7 @@ df_get_eh_block_artificial_uses (bitmap eh_block_artificial_uses)\n {\n   bitmap_clear (eh_block_artificial_uses);\n \n-  /* The following code (down thru the arg_pointer setting APPEARS\n+  /* The following code (down through the arg_pointer setting APPEARS\n      to be necessary because there is nothing that actually\n      describes what the exception handling code may actually need\n      to keep alive.  */\n@@ -4539,7 +4539,7 @@ df_scan_verify (void)\n \n   /* Verification is a 4 step process. */\n \n-  /* (1) All of the refs are marked by going thru the reg chains.  */\n+  /* (1) All of the refs are marked by going through the reg chains.  */\n   for (i = 0; i < DF_REG_SIZE (df); i++)\n     {\n       gcc_assert (df_reg_chain_mark (DF_REG_DEF_CHAIN (i), i, true, false)"}, {"sha": "1b4882d1d167e08764f3409a5d9a91599afa1575", "filename": "gcc/df.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -367,7 +367,7 @@ struct df_base_ref\n      when FUDs are added.  */\n   struct df_insn_info *insn_info;\n   /* For each regno, there are three chains of refs, one for the uses,\n-     the eq_uses and the defs.  These chains go thru the refs\n+     the eq_uses and the defs.  These chains go through the refs\n      themselves rather than using an external structure.  */\n   union df_ref_d *next_reg;     /* Next ref with same regno and type.  */\n   union df_ref_d *prev_reg;     /* Prev ref with same regno and type.  */"}, {"sha": "a60d6da0c20ad6b18fc45610e87e44f17bffd27a", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -3736,7 +3736,7 @@ the PowerPC V2.05 architecture.\n @cindex @code{target(\"dlmzb\")} attribute\n Generate code that uses (does not use) the string-search @samp{dlmzb}\n instruction on the IBM 405, 440, 464 and 476 processors.  This instruction is\n-generated by default when targetting those processors.\n+generated by default when targeting those processors.\n \n @item fprnd\n @itemx no-fprnd\n@@ -3775,7 +3775,7 @@ other processors that support the extended PowerPC V2.05 architecture.\n @cindex @code{target(\"mulhw\")} attribute\n Generate code that uses (does not use) the half-word multiply and\n multiply-accumulate instructions on the IBM 405, 440, 464 and 476 processors.\n-These instructions are generated by default when targetting those\n+These instructions are generated by default when targeting those\n processors.\n \n @item multiple\n@@ -9558,7 +9558,7 @@ else\n @end deftypefn\n \n @deftypefn {Built-in Function} int __builtin_cpu_supports (const char *@var{feature})\n-This function returns a postive integer if the runtime cpu supports @var{feature}\n+This function returns a positive integer if the runtime cpu supports @var{feature}\n  and returns @code{0} otherwise. The following features can be detected:\n \n @table @samp"}, {"sha": "7b5cf1acb4efd88f09729cde8c0cc8ae29a9726d", "filename": "gcc/doc/install.texi", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fdoc%2Finstall.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fdoc%2Finstall.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finstall.texi?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -305,9 +305,9 @@ systems' @command{tar} programs will also work, only try GNU\n \n @item Perl version 5.6.1 (or later)\n \n-Necessary when targetting Darwin, building @samp{libstdc++},\n+Necessary when targeting Darwin, building @samp{libstdc++},\n and not using @option{--disable-symvers}.\n-Necessary when targetting Solaris 2 with Sun @command{ld} and not using\n+Necessary when targeting Solaris 2 with Sun @command{ld} and not using\n @option{--disable-symvers}.  The bundled @command{perl} in Solaris@tie{}8\n and up works.\n "}, {"sha": "e9b3b4328c2f6cb96d088f22e0147497fdae9ae3", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -15376,7 +15376,7 @@ Equivalent to @option{-march=mips64r2}.\n @itemx -mno-mips16\n @opindex mips16\n @opindex mno-mips16\n-Generate (do not generate) MIPS16 code.  If GCC is targetting a\n+Generate (do not generate) MIPS16 code.  If GCC is targeting a\n MIPS32 or MIPS64 architecture, it makes use of the MIPS16e ASE@.\n \n MIPS16 code generation can also be controlled on a per-function basis\n@@ -16929,7 +16929,7 @@ Generate code that tries to avoid (not avoid) the use of indexed load\n or store instructions. These instructions can incur a performance\n penalty on Power6 processors in certain situations, such as when\n stepping through large arrays that cross a 16M boundary.  This option\n-is enabled by default when targetting Power6 and disabled otherwise.\n+is enabled by default when targeting Power6 and disabled otherwise.\n \n @item -mfused-madd\n @itemx -mno-fused-madd\n@@ -16948,7 +16948,7 @@ mapped to @option{-ffp-contract=off}.\n @opindex mno-mulhw\n Generate code that uses (does not use) the half-word multiply and\n multiply-accumulate instructions on the IBM 405, 440, 464 and 476 processors.\n-These instructions are generated by default when targetting those\n+These instructions are generated by default when targeting those\n processors.\n \n @item -mdlmzb\n@@ -16957,7 +16957,7 @@ processors.\n @opindex mno-dlmzb\n Generate code that uses (does not use) the string-search @samp{dlmzb}\n instruction on the IBM 405, 440, 464 and 476 processors.  This instruction is\n-generated by default when targetting those processors.\n+generated by default when targeting those processors.\n \n @item -mno-bit-align\n @itemx -mbit-align\n@@ -18506,7 +18506,7 @@ Visual Instruction Set extensions.  The default is @option{-mno-vis}.\n @opindex mno-vis2\n With @option{-mvis2}, GCC generates code that takes advantage of\n version 2.0 of the UltraSPARC Visual Instruction Set extensions.  The\n-default is @option{-mvis2} when targetting a cpu that supports such\n+default is @option{-mvis2} when targeting a cpu that supports such\n instructions, such as UltraSPARC-III and later.  Setting @option{-mvis2}\n also sets @option{-mvis}.\n \n@@ -18516,7 +18516,7 @@ also sets @option{-mvis}.\n @opindex mno-vis3\n With @option{-mvis3}, GCC generates code that takes advantage of\n version 3.0 of the UltraSPARC Visual Instruction Set extensions.  The\n-default is @option{-mvis3} when targetting a cpu that supports such\n+default is @option{-mvis3} when targeting a cpu that supports such\n instructions, such as niagara-3 and later.  Setting @option{-mvis3}\n also sets @option{-mvis2} and @option{-mvis}.\n \n@@ -18526,7 +18526,7 @@ also sets @option{-mvis2} and @option{-mvis}.\n @opindex mno-popc\n With @option{-mpopc}, GCC generates code that takes advantage of the UltraSPARC\n population count instruction.  The default is @option{-mpopc}\n-when targetting a cpu that supports such instructions, such as Niagara-2 and\n+when targeting a cpu that supports such instructions, such as Niagara-2 and\n later.\n \n @item -mfmaf\n@@ -18535,7 +18535,7 @@ later.\n @opindex mno-fmaf\n With @option{-mfmaf}, GCC generates code that takes advantage of the UltraSPARC\n Fused Multiply-Add Floating-point extensions.  The default is @option{-mfmaf}\n-when targetting a cpu that supports such instructions, such as Niagara-3 and\n+when targeting a cpu that supports such instructions, such as Niagara-3 and\n later.\n \n @item -mfix-at697f"}, {"sha": "ac642b4b43f688eec373c1a295380c860aa05450", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -5683,7 +5683,7 @@ built-in setjmp that isn't needed at the site of a nonlocal goto.  You\n will not normally need to define this pattern.  A typical reason why you\n might need this pattern is if some value, such as a pointer to a global\n table, must be restored.  It takes one argument, which is the label\n-to which builtin_longjmp transfered control; this pattern may be emitted\n+to which builtin_longjmp transferred control; this pattern may be emitted\n at a small offset from that label.\n \n @cindex @code{builtin_longjmp} instruction pattern"}, {"sha": "039c480351f25dfdda2713c933a5dfa9a3e7430c", "filename": "gcc/doc/plugins.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fdoc%2Fplugins.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fdoc%2Fplugins.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fplugins.texi?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -276,7 +276,7 @@ the start or end of the GCC garbage collection.\n Some plugins may need to have GGC mark additional data. This can be\n done by registering a callback (called with a null @code{gcc_data})\n for the @code{PLUGIN_GGC_MARKING} event. Such callbacks can call the\n-@code{ggc_set_mark} routine, preferably thru the @code{ggc_mark} macro\n+@code{ggc_set_mark} routine, preferably through the @code{ggc_mark} macro\n (and conversely, these routines should usually not be used in plugins\n outside of the @code{PLUGIN_GGC_MARKING} event).\n "}, {"sha": "07c480d6a7ca0b1c013f689fd8013f8c97d2f228", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -775,7 +775,7 @@ Read-only in this context means never modified during the lifetime of the\n program, not necessarily in ROM or in write-disabled pages.  A common\n example of the later is a shared library's global offset table.  This\n table is initialized by the runtime loader, so the memory is technically\n-writable, but after control is transfered from the runtime loader to the\n+writable, but after control is transferred from the runtime loader to the\n application, this memory will never be subsequently modified.\n \n Stored in the @code{unchanging} field and printed as @samp{/u}."}, {"sha": "06c71d74b1ae5df0484278d4e75214e80401fc0f", "filename": "gcc/dse.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -95,7 +95,7 @@ along with GCC; see the file COPYING3.  If not see\n    5) Delete the insns that the global analysis has indicated are\n    unnecessary.\n \n-   6) Delete insns that store the same value as preceeding store\n+   6) Delete insns that store the same value as preceding store\n    where the earlier store couldn't be eliminated.\n \n    7) Cleanup.\n@@ -388,7 +388,7 @@ struct insn_info\n   struct insn_info * prev_insn;\n \n   /* The linked list of insns that are in consideration for removal in\n-     the forwards pass thru the basic block.  This pointer may be\n+     the forwards pass through the basic block.  This pointer may be\n      trash as it is not cleared when a wild read occurs.  The only\n      time it is guaranteed to be correct is when the traversal starts\n      at active_local_stores.  */\n@@ -457,7 +457,7 @@ struct bb_info\n      being processed.  While it contains info for all of the\n      registers, only the hard registers are actually examined.  It is used\n      to assure that shift and/or add sequences that are inserted do not\n-     accidently clobber live hard regs.  */\n+     accidentally clobber live hard regs.  */\n   bitmap regs_live;\n };\n "}, {"sha": "ca3d7ffb6949c1f1f75e19781b5ba691f00becac", "filename": "gcc/dwarf2asm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fdwarf2asm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fdwarf2asm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2asm.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -161,7 +161,7 @@ dw2_asm_output_vms_delta (int size ATTRIBUTE_UNUSED,\n   va_start (ap, comment);\n \n #ifndef ASM_OUTPUT_DWARF_VMS_DELTA\n-  /* VMS Delta is only special on ia64-vms, but this funtion also gets\n+  /* VMS Delta is only special on ia64-vms, but this function also gets\n      called on alpha-vms so it has to do something sane.  */\n   dw2_asm_output_delta (size, lab1, lab2, comment);\n #else"}, {"sha": "15cbff0a45c933c56876c58cea095d91a36819dc", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -4504,7 +4504,7 @@ adjust_piece_list (rtx *dest, rtx *src, rtx *inner,\n \n   if (copy)\n     {\n-      /* First copy all nodes preceeding the current bitpos.  */\n+      /* First copy all nodes preceding the current bitpos.  */\n       while (src != inner)\n \t{\n \t  *dest = decl_piece_node (*decl_piece_varloc_ptr (*src),\n@@ -12686,7 +12686,7 @@ add_loc_descr_to_each (dw_loc_list_ref list, dw_loc_descr_ref ref)\n \n /* Given two lists RET and LIST\n    produce location list that is result of adding expression in LIST\n-   to expression in RET on each possition in program.\n+   to expression in RET on each position in program.\n    Might be destructive on both RET and LIST.\n \n    TODO: We handle only simple cases of RET or LIST having at most one\n@@ -19989,7 +19989,7 @@ dwarf2out_source_line (unsigned int line, const char *filename,\n   /* Recall that this end-of-prologue indication is *not* the same thing\n      as the end_prologue debug hook.  The NOTE_INSN_PROLOGUE_END note,\n      to which the hook corresponds, follows the last insn that was \n-     emitted by gen_prologue.  What we need is to preceed the first insn\n+     emitted by gen_prologue.  What we need is to precede the first insn\n      that had been emitted after NOTE_INSN_FUNCTION_BEG, i.e. the first\n      insn that corresponds to something the user wrote.  These may be\n      very different locations once scheduling is enabled.  */"}, {"sha": "5b3939e0fc419d8f3a7e550116c156778d6b36f2", "filename": "gcc/except.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.h?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -46,7 +46,7 @@ enum eh_region_type\n \n   /* TRY regions implement catching an exception.  The list of types associated\n      with the attached catch handlers is examined in order by the runtime and\n-     control is transfered to the appropriate handler.  Note that a NULL type\n+     control is transferred to the appropriate handler.  Note that a NULL type\n      list is a catch-all handler, and that it will catch *all* exceptions\n      including those originating from a different language.  */\n   ERT_TRY,\n@@ -80,7 +80,7 @@ struct GTY(()) eh_landing_pad_d\n   /* The region with which this landing pad is associated.  */\n   struct eh_region_d *region;\n \n-  /* At the gimple level, the location to which control will be transfered\n+  /* At the gimple level, the location to which control will be transferred\n      for this landing pad.  There can be both EH and normal edges into the\n      block containing the post-landing-pad label.  */\n   tree post_landing_pad;"}, {"sha": "d568deb32fdc6b4383280ea74b04271fb90b2f58", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -7374,7 +7374,7 @@ highest_pow2_factor_for_target (const_tree target, const_tree exp)\n }\n \f\n #ifdef HAVE_conditional_move\n-/* Convert the tree comparision code TCODE to the rtl one where the\n+/* Convert the tree comparison code TCODE to the rtl one where the\n    signedness is UNSIGNEDP.  */\n \n static enum rtx_code"}, {"sha": "8a548107485846d8ec3d989e5e0acd17e737a105", "filename": "gcc/fold-const.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -2567,7 +2567,7 @@ operand_equal_p (const_tree arg0, const_tree arg1, unsigned int flags)\n \t  return OP_SAME (0);\n \n \tcase TARGET_MEM_REF:\n-\t  /* Require equal extra operands and then fall thru to MEM_REF\n+\t  /* Require equal extra operands and then fall through to MEM_REF\n \t     handling of the two common operands.  */\n \t  if (!OP_SAME_WITH_NULL (2)\n \t      || !OP_SAME_WITH_NULL (3)\n@@ -12018,7 +12018,7 @@ fold_binary_loc (location_t loc,\n \t  }\n \t}\n \n-      /* Fall thru */\n+      /* Fall through */\n       \n     case FLOOR_DIV_EXPR:\n       /* Simplify A / (B << N) where A and B are positive and B is\n@@ -12061,7 +12061,7 @@ fold_binary_loc (location_t loc,\n \t  && code == FLOOR_DIV_EXPR)\n \treturn fold_build2_loc (loc, TRUNC_DIV_EXPR, type, op0, op1);\n \n-      /* Fall thru */\n+      /* Fall through */\n \n     case ROUND_DIV_EXPR:\n     case CEIL_DIV_EXPR:"}, {"sha": "eb3b220d10af032f60a1c7033ad9f3f3ec75c1b7", "filename": "gcc/gcc.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -8071,7 +8071,7 @@ include_spec_function (int argc, const char **argv)\n }\n \n /* %:find-file spec function.  This function replaces its argument by\n-    the file found thru find_file, that is the -print-file-name gcc\n+    the file found through find_file, that is the -print-file-name gcc\n     program option. */\n static const char *\n find_file_spec_function (int argc, const char **argv)\n@@ -8087,7 +8087,7 @@ find_file_spec_function (int argc, const char **argv)\n \n \n /* %:find-plugindir spec function.  This function replaces its argument\n-    by the -iplugindir=<dir> option.  `dir' is found thru find_file, that\n+    by the -iplugindir=<dir> option.  `dir' is found through find_file, that\n     is the -print-file-name gcc program option. */\n static const char *\n find_plugindir_spec_function (int argc, const char **argv ATTRIBUTE_UNUSED)"}, {"sha": "d07ee86f4888216e568476f90ee41cc98c78f49c", "filename": "gcc/gcse.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -2906,7 +2906,7 @@ hoist_expr_reaches_here_p (basic_block expr_bb, int expr_index, basic_block bb,\n   return (pred == NULL);\n }\n \f\n-/* Find occurence in BB.  */\n+/* Find occurrence in BB.  */\n \n static struct occr *\n find_occr_in_bb (struct occr *occr, basic_block bb)\n@@ -2990,11 +2990,11 @@ hoist_code (void)\n \t    {\n \t      /* Current expression.  */\n \t      struct expr *expr = index_map[i];\n-\t      /* Number of occurences of EXPR that can be hoisted to BB.  */\n+\t      /* Number of occurrences of EXPR that can be hoisted to BB.  */\n \t      int hoistable = 0;\n-\t      /* Basic blocks that have occurences reachable from BB.  */\n+\t      /* Basic blocks that have occurrences reachable from BB.  */\n \t      bitmap_head _from_bbs, *from_bbs = &_from_bbs;\n-\t      /* Occurences reachable from BB.  */\n+\t      /* Occurrences reachable from BB.  */\n \t      VEC (occr_t, heap) *occrs_to_hoist = NULL;\n \t      /* We want to insert the expression into BB only once, so\n \t\t note when we've inserted it.  */\n@@ -3004,14 +3004,14 @@ hoist_code (void)\n \t      bitmap_initialize (from_bbs, 0);\n \n \t      /* If an expression is computed in BB and is available at end of\n-\t\t BB, hoist all occurences dominated by BB to BB.  */\n+\t\t BB, hoist all occurrences dominated by BB to BB.  */\n \t      if (TEST_BIT (comp[bb->index], i))\n \t\t{\n \t\t  occr = find_occr_in_bb (expr->antic_occr, bb);\n \n \t\t  if (occr)\n \t\t    {\n-\t\t      /* An occurence might've been already deleted\n+\t\t      /* An occurrence might've been already deleted\n \t\t\t while processing a dominator of BB.  */\n \t\t      if (!occr->deleted_p)\n \t\t\t{\n@@ -3042,7 +3042,7 @@ hoist_code (void)\n \t\t  occr = find_occr_in_bb (expr->antic_occr, dominated);\n \t\t  gcc_assert (occr);\n \n-\t\t  /* An occurence might've been already deleted\n+\t\t  /* An occurrence might've been already deleted\n \t\t     while processing a dominator of BB.  */\n \t\t  if (occr->deleted_p)\n \t\t    continue;\n@@ -3084,7 +3084,7 @@ hoist_code (void)\n \t      if (hoistable > 1 && dbg_cnt (hoist_insn))\n \t\t{\n \t\t  /* If (hoistable != VEC_length), then there is\n-\t\t     an occurence of EXPR in BB itself.  Don't waste\n+\t\t     an occurrence of EXPR in BB itself.  Don't waste\n \t\t     time looking for LCA in this case.  */\n \t\t  if ((unsigned) hoistable\n \t\t      == VEC_length (occr_t, occrs_to_hoist))\n@@ -3094,7 +3094,7 @@ hoist_code (void)\n \t\t      lca = nearest_common_dominator_for_set (CDI_DOMINATORS,\n \t\t\t\t\t\t\t      from_bbs);\n \t\t      if (lca != bb)\n-\t\t\t/* Punt, it's better to hoist these occurences to\n+\t\t\t/* Punt, it's better to hoist these occurrences to\n \t\t\t   LCA.  */\n \t\t\tVEC_free (occr_t, heap, occrs_to_hoist);\n \t\t    }\n@@ -3105,7 +3105,7 @@ hoist_code (void)\n \n \t      insn_inserted_p = 0;\n \n-\t      /* Walk through occurences of I'th expressions we want\n+\t      /* Walk through occurrences of I'th expressions we want\n \t\t to hoist to BB and make the transformations.  */\n \t      FOR_EACH_VEC_ELT (occr_t, occrs_to_hoist, j, occr)\n \t\t{"}, {"sha": "9f9e066b119d5a08b406a72f5d50368b45b45a91", "filename": "gcc/genautomata.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fgenautomata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fgenautomata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenautomata.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -2390,7 +2390,7 @@ add_presence_absence (unit_set_el_t dest_list,\n \n /* The function inserts BYPASS in the list of bypasses of the\n    corresponding output insn.  The order of bypasses in the list is\n-   decribed in a comment for member `bypass_list' (see above).  If\n+   described in a comment for member `bypass_list' (see above).  If\n    there is already the same bypass in the list the function reports\n    this and does nothing.  */\n static void"}, {"sha": "d7ea9b48d943cd0a3c8f61978eff40c27385ba72", "filename": "gcc/gengtype-state.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fgengtype-state.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fgengtype-state.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype-state.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -65,7 +65,7 @@ type_lineloc (const_type_p ty)\n }\n \n /* The state file has simplistic lispy lexical tokens.  Its lexer gives\n-   a linked list of struct state_token_st, thru the peek_state_token\n+   a linked list of struct state_token_st, through the peek_state_token\n    function.  Lexical tokens are consumed with next_state_tokens.  */\n \n \n@@ -818,7 +818,7 @@ write_state_lang_struct_type (type_p current)\n   type_p hty = NULL;\n   const char *homoname = 0;\n   write_state_struct_union_type (current, \"lang_struct\");\n-  /* lang_struct-ures are particularily tricky, since their\n+  /* lang_struct-ures are particularly tricky, since their\n      u.s.lang_struct field gives a list of homonymous struct-s or\n      union-s! */\n   DBGPRINTF (\"lang_struct @ %p #%d\", (void *) current, current->state_number);"}, {"sha": "584712a2a7ed543e086a70953215877aa5e1a8d1", "filename": "gcc/gengtype.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -159,7 +159,7 @@ static outf_p *base_files;\n \n #if ENABLE_CHECKING\n /* Utility debugging function, printing the various type counts within\n-   a list of types.  Called thru the DBGPRINT_COUNT_TYPE macro.  */\n+   a list of types.  Called through the DBGPRINT_COUNT_TYPE macro.  */\n void\n dbgprint_count_type_at (const char *fil, int lin, const char *msg, type_p t)\n {\n@@ -1828,7 +1828,7 @@ struct file_rule_st files_rules[] = {\n \n   /* Source *.c files are using get_file_gtfilename to compute their\n      output_name and get_file_basename to compute their for_name\n-     thru the source_dot_c_frul action.  */\n+     through the source_dot_c_frul action.  */\n   { DIR_PREFIX_REGEX \"([[:alnum:]_-]*)\\\\.c$\",\n     REG_EXTENDED, NULL_REGEX, \"gt-$3.h\", \"$3.c\", source_dot_c_frul},\n   /* Common header files get \"gtype-desc.c\" as their output_name,\n@@ -2004,7 +2004,7 @@ get_output_file_with_visibility (input_file *inpf)\n   /* Try each rule in sequence in files_rules until one is triggered. */\n   {\n     int rulix = 0;\n-    DBGPRINTF (\"passing input file @ %p named %s thru the files_rules\",\n+    DBGPRINTF (\"passing input file @ %p named %s through the files_rules\",\n \t       (void*) inpf, inpfname);\n \n     for (; files_rules[rulix].frul_srcexpr != NULL; rulix++)"}, {"sha": "fc48e45161c3b372b2ee2ae00ffea611bbc321be", "filename": "gcc/genhooks.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fgenhooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fgenhooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenhooks.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -91,7 +91,7 @@ s_hook_eq_p (const void *p1, const void *p2)\n }\n \n /* Read the documentation file with name IN_FNAME, perform substitutions\n-   to incorporate informtion from hook_array, and emit the result on stdout.\n+   to incorporate information from hook_array, and emit the result on stdout.\n    Hooks defined with DEFHOOK / DEFHOOKPOD are emitted at the place of a\n    matching @hook in the input file; if there is no matching @hook, the\n    hook is emitted after the hook that precedes it in target.def ."}, {"sha": "8bcc13e1a41377e7fbff67ac5da101b415b82ac0", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -94,7 +94,7 @@ can_refer_decl_in_current_unit_p (tree decl, tree from_decl)\n      produced.\n \n      As observed in PR20991 for already optimized out comdat virtual functions\n-     it may be tempting to not neccesarily give up because the copy will be\n+     it may be tempting to not necessarily give up because the copy will be\n      output elsewhere when corresponding vtable is output.  \n      This is however not possible - ABI specify that COMDATs are output in\n      units where they are used and when the other unit was compiled with LTO\n@@ -1054,7 +1054,7 @@ gimple_extract_devirt_binfo_from_cst (tree cst)\n       type = TREE_TYPE (fld);\n       offset -= pos;\n     }\n-  /* Artifical sub-objects are ancestors, we do not want to use them for\n+  /* Artificial sub-objects are ancestors, we do not want to use them for\n      devirtualization, at least not here.  */\n   if (last_artificial)\n     return NULL_TREE;"}, {"sha": "a80ae90a6f0c26c280e5fb7537dcdb6ea68e4e95", "filename": "gcc/gimple-pretty-print.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fgimple-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fgimple-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -156,7 +156,7 @@ debug_gimple_seq (gimple_seq seq)\n \n \n /* A simple helper to pretty-print some of the gimple tuples in the printf\n-   style. The format modifiers are preceeded by '%' and are:\n+   style. The format modifiers are preceded by '%' and are:\n      'G' - outputs a string corresponding to the code of the given gimple,\n      'S' - outputs a gimple_seq with indent of spc + 2,\n      'T' - outputs the tree t,"}, {"sha": "398cb1f93e45ef7b5adcfa12d72892519b66f0d4", "filename": "gcc/gimple.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -3333,7 +3333,7 @@ gtc_visit (tree t1, tree t2,\n \t  || FIXED_POINT_TYPE_P (t1))\n \treturn true;\n \n-      /* For other types fall thru to more complex checks.  */\n+      /* For other types fall through to more complex checks.  */\n     }\n \n   /* If the types have been previously registered and found equal\n@@ -3755,7 +3755,7 @@ gimple_types_compatible_p (tree t1, tree t2)\n \t  || FIXED_POINT_TYPE_P (t1))\n \treturn true;\n \n-      /* For other types fall thru to more complex checks.  */\n+      /* For other types fall through to more complex checks.  */\n     }\n \n   /* If the types have been previously registered and found equal"}, {"sha": "219592f71cd0aba8bbd3b1d8a4593ff501cbb505", "filename": "gcc/gimple.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -4800,7 +4800,7 @@ gimple_return_set_retval (gimple gs, tree retval)\n }\n \n \n-/* Returns true when the gimple statment STMT is any of the OpenMP types.  */\n+/* Returns true when the gimple statement STMT is any of the OpenMP types.  */\n \n #define CASE_GIMPLE_OMP\t\t\t\t\\\n     case GIMPLE_OMP_PARALLEL:\t\t\t\\"}, {"sha": "0c672e82382c7dc80f1c15bd90df232c8f729b96", "filename": "gcc/gimplify.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -2811,7 +2811,7 @@ shortcut_cond_r (tree pred, tree *true_label_p, tree *false_label_p,\n \n /* Given a conditional expression EXPR with short-circuit boolean\n    predicates using TRUTH_ANDIF_EXPR or TRUTH_ORIF_EXPR, break the\n-   predicate appart into the equivalent sequence of conditionals.  */\n+   predicate apart into the equivalent sequence of conditionals.  */\n \n static tree\n shortcut_cond_expr (tree expr)"}, {"sha": "ae3262a6a612f7904a5e68d4a04ba44ddd325a50", "filename": "gcc/graphite-interchange.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fgraphite-interchange.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fgraphite-interchange.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-interchange.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -144,7 +144,7 @@ build_partial_difference (ppl_Pointset_Powerset_C_Polyhedron_t *p,\n \n      This means that all the time dimensions are equal except for\n      time_depth, where the constraint is t_{depth} = t'_{depth} + 1\n-     step.  More to this: we should be carefull not to add equalities\n+     step.  More to this: we should be careful not to add equalities\n      to the 'coupled' dimensions, which happens when the one dimension\n      is stripmined dimension, and the other dimension corresponds\n      to the point loop inside stripmined dimension.  */"}, {"sha": "555100fc5c46cde80bc43898c8e932e3092015b0", "filename": "gcc/graphite-sese-to-poly.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fgraphite-sese-to-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fgraphite-sese-to-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-sese-to-poly.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -1223,7 +1223,7 @@ add_condition_to_domain (ppl_Pointset_Powerset_C_Polyhedron_t ps, gimple stmt,\n   ppl_delete_Linear_Expression (right);\n }\n \n-/* Add conditional statement STMT to pbb.  CODE is used as the comparision\n+/* Add conditional statement STMT to pbb.  CODE is used as the comparison\n    operator.  This allows us to invert the condition or to handle\n    inequalities.  */\n \n@@ -2840,7 +2840,7 @@ follow_inital_value_to_phi (tree arg, tree lhs)\n }\n \n \n-/* Return the argument of the loop PHI that is the inital value coming\n+/* Return the argument of the loop PHI that is the initial value coming\n    from outside the loop.  */\n \n static edge\n@@ -2860,7 +2860,7 @@ edge_initial_value_for_loop_phi (gimple phi)\n   return NULL;\n }\n \n-/* Return the argument of the loop PHI that is the inital value coming\n+/* Return the argument of the loop PHI that is the initial value coming\n    from outside the loop.  */\n \n static tree"}, {"sha": "adeb214a5e40863625300c9c46ffb401a3509e09", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -3877,7 +3877,7 @@ find_if_case_1 (basic_block test_bb, edge then_edge, edge else_edge)\n \n   /* We can avoid creating a new basic block if then_bb is immediately\n      followed by else_bb, i.e. deleting then_bb allows test_bb to fall\n-     thru to else_bb.  */\n+     through to else_bb.  */\n \n   if (then_bb->next_bb == else_bb\n       && then_bb->prev_bb == test_bb"}, {"sha": "99e6e041bb283bcaf91a07bdc7af0966619c9745", "filename": "gcc/input.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Finput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Finput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finput.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -155,7 +155,7 @@ expand_location_to_spelling_point (source_location loc)\n   return expand_location_1 (loc, /*expansion_piont_p=*/false);\n }\n \n-/* If LOCATION is in a sytem header and if it's a virtual location for\n+/* If LOCATION is in a system header and if it's a virtual location for\n    a token coming from the expansion of a macro M, unwind it to the\n    location of the expansion point of M.  Otherwise, just return\n    LOCATION."}, {"sha": "4539d46ab734a20ee7fa0a1dfa53696650b25045", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -82,7 +82,7 @@ along with GCC; see the file COPYING3.  If not see\n    for each strongly connected component (SCC), we propagate constants\n    according to previously computed jump functions.  We also record what known\n    values depend on other known values and estimate local effects.  Finally, we\n-   propagate cumulative information about these effects from dependant values\n+   propagate cumulative information about these effects from dependent values\n    to those on which they depend.\n \n    Second, we again traverse the call graph in the same topological order and\n@@ -1588,7 +1588,7 @@ safe_add (int a, int b)\n \n \n /* Propagate the estimated effects of individual values along the topological\n-   from the dependant values to those they depend on.  */\n+   from the dependent values to those they depend on.  */\n \n static void\n propagate_effects (void)"}, {"sha": "f0111cb66b4509d2a5d9b7a8126708b27dc57c9e", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -2010,7 +2010,7 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \t\tp = true_predicate ();\n \n \t      /* We account everything but the calls.  Calls have their own\n-\t\t size/time info attached to cgraph edges.  This is neccesary\n+\t\t size/time info attached to cgraph edges.  This is necessary\n \t\t in order to make the cost disappear after inlining.  */\n \t      if (!is_gimple_call (stmt))\n \t\t{"}, {"sha": "27b5458ad24a0f6ddbdff6ffb63022236c9a3234", "filename": "gcc/ipa-inline-transform.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fipa-inline-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fipa-inline-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-transform.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -264,7 +264,7 @@ inline_call (struct cgraph_edge *e, bool update_original,\n    This is done before inline plan is applied to NODE when there are\n    still some inline clones if it.\n \n-   This is neccesary because inline decisions are not really transitive\n+   This is necessary because inline decisions are not really transitive\n    and the other inline clones may have different bodies.  */\n \n static struct cgraph_node *"}, {"sha": "c45d4701da25d661e53b2bed28bfb4dc0b941033", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -777,7 +777,7 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n \t\tedge_growth\n      badness = -goodness  \n \n-    The fraction is upside down, becuase on edge counts and time beneits\n+    The fraction is upside down, because on edge counts and time beneits\n     the bounds are known. Edge growth is essentially unlimited.  */\n \n   else if (max_count)\n@@ -1369,7 +1369,7 @@ inline_small_functions (void)\n \tcontinue;\n \n       /* Be sure that caches are maintained consistent.  \n-         We can not make this ENABLE_CHECKING only because it cause differnt\n+         We can not make this ENABLE_CHECKING only because it cause different\n          updates of the fibheap queue.  */\n       cached_badness = edge_badness (edge, false);\n       reset_edge_growth_cache (edge);"}, {"sha": "445ee792688ef5d8a88ef71bf8c35c5771759e95", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -1109,7 +1109,7 @@ propagate_pure_const (void)\n       ipa_print_order(dump_file, \"reduced\", order, order_pos);\n     }\n \n-  /* Propagate the local information thru the call graph to produce\n+  /* Propagate the local information through the call graph to produce\n      the global information.  All the nodes within a cycle will have\n      the same info so we collapse cycles first.  Then we can do the\n      propagation in one pass from the leaves to the roots.  */\n@@ -1381,7 +1381,7 @@ propagate_nothrow (void)\n       ipa_print_order (dump_file, \"reduced for nothrow\", order, order_pos);\n     }\n \n-  /* Propagate the local information thru the call graph to produce\n+  /* Propagate the local information through the call graph to produce\n      the global information.  All the nodes within a cycle will have\n      the same info so we collapse cycles first.  Then we can do the\n      propagation in one pass from the leaves to the roots.  */"}, {"sha": "99273c50fb1bb8e15da06022bee581ba7127e10f", "filename": "gcc/ipa-ref.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fipa-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fipa-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-ref.h?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -58,7 +58,7 @@ struct GTY(()) ipa_ref_list\n {\n   /* Store actual references in references vector.  */\n   VEC(ipa_ref_t,gc) *references;\n-  /* Refering is vector of pointers to references.  It must not live in GGC space\n+  /* Referring is vector of pointers to references.  It must not live in GGC space\n      or GGC will try to mark middle of references vectors.  */\n   VEC(ipa_ref_ptr,heap) * GTY((skip)) referring;\n };"}, {"sha": "5a3d1e55ab9d68b7b1a1ab620d79a5702cd15ba1", "filename": "gcc/ipa-reference.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fipa-reference.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fipa-reference.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-reference.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -615,7 +615,7 @@ propagate (void)\n   ipa_discover_readonly_nonaddressable_vars ();\n   generate_summary ();\n \n-  /* Now we know what vars are realy statics; prune out those that aren't.  */\n+  /* Now we know what vars are really statics; prune out those that aren't.  */\n   FOR_EACH_VARIABLE (vnode)\n     if (vnode->symbol.externally_visible\n \t|| TREE_ADDRESSABLE (vnode->symbol.decl)\n@@ -637,7 +637,7 @@ propagate (void)\n         bitmap_and_into (node_l->statics_written, all_module_statics);\n     }\n \n-  /* Propagate the local information thru the call graph to produce\n+  /* Propagate the local information through the call graph to produce\n      the global information.  All the nodes within a cycle will have\n      the same info so we collapse cycles first.  Then we can do the\n      propagation in one pass from the leaves to the roots.  */"}, {"sha": "7cbf3ac11f4583eeb147ebedbc5807c724a99ac6", "filename": "gcc/ipa-utils.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fipa-utils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fipa-utils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -325,7 +325,7 @@ ipa_reverse_postorder (struct cgraph_node **order)\n \n \n /* Given a memory reference T, will return the variable at the bottom\n-   of the access.  Unlike get_base_address, this will recurse thru\n+   of the access.  Unlike get_base_address, this will recurse through\n    INDIRECT_REFS.  */\n \n tree"}, {"sha": "f5cce1ba41a740cd51ce090a18c1f46f95680e0c", "filename": "gcc/ipa.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -683,7 +683,7 @@ varpool_externally_visible_p (struct varpool_node *vnode, bool aliased)\n   if (vnode->symbol.resolution == LDPR_PREVAILING_DEF_IRONLY)\n     return false;\n \n-  /* As a special case, the COMDAT virutal tables can be unshared.\n+  /* As a special case, the COMDAT virtual tables can be unshared.\n      In LTO mode turn vtables into static variables.  The variable is readonly,\n      so this does not enable more optimization, but referring static var\n      is faster for dynamic linking.  Also this match logic hidding vtables\n@@ -791,7 +791,7 @@ function_and_variable_visibility (bool whole_program)\n \n       /* C++ FE on lack of COMDAT support create local COMDAT functions\n \t (that ought to be shared but can not due to object format\n-\t limitations).  It is neccesary to keep the flag to make rest of C++ FE\n+\t limitations).  It is necessary to keep the flag to make rest of C++ FE\n \t happy.  Clear the flag here to avoid confusion in middle-end.  */\n       if (DECL_COMDAT (node->symbol.decl) && !TREE_PUBLIC (node->symbol.decl))\n         DECL_COMDAT (node->symbol.decl) = 0;\n@@ -974,7 +974,7 @@ gate_whole_program_function_and_variable_visibility (void)\n   return !flag_ltrans;\n }\n \n-/* Bring functionss local at LTO time whith -fwhole-program.  */\n+/* Bring functionss local at LTO time with -fwhole-program.  */\n \n static unsigned int\n whole_program_function_and_variable_visibility (void)\n@@ -1350,7 +1350,7 @@ build_cdtor_fns (void)\n \n /* Look for constructors and destructors and produce function calling them.\n    This is needed for targets not supporting ctors or dtors, but we perform the\n-   transformation also at linktime to merge possibly numberous\n+   transformation also at linktime to merge possibly numerous\n    constructors/destructors into single function to improve code locality and\n    reduce size.  */\n "}, {"sha": "968a64823d618b583be3523dd359234573e354a9", "filename": "gcc/ira-emit.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fira-emit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fira-emit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-emit.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -160,7 +160,7 @@ create_new_allocno (int regno, ira_loop_tree_node_t loop_tree_node)\n typedef struct move *move_t;\n \n /* The structure represents an allocno move.  Both allocnos have the\n-   same origional regno but different allocation.  */\n+   same original regno but different allocation.  */\n struct move\n {\n   /* The allocnos involved in the move.  */\n@@ -446,7 +446,7 @@ setup_entered_from_non_parent_p (void)\n }\n \n /* Return TRUE if move of SRC_ALLOCNO (assigned to hard register) to\n-   DEST_ALLOCNO (assigned to memory) can be removed beacuse it does\n+   DEST_ALLOCNO (assigned to memory) can be removed because it does\n    not change value of the destination.  One possible reason for this\n    is the situation when SRC_ALLOCNO is not modified in the\n    corresponding loop.  */"}, {"sha": "348fe607f863a2cf397e26c75c5d9b000260b040", "filename": "gcc/ira-lives.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fira-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fira-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-lives.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -528,7 +528,7 @@ mark_ref_dead (df_ref def)\n \n /* If REG is a pseudo or a subreg of it, and the class of its allocno\n    intersects CL, make a conflict with pseudo DREG.  ORIG_DREG is the\n-   rtx actually accessed, it may be indentical to DREG or a subreg of it.\n+   rtx actually accessed, it may be identical to DREG or a subreg of it.\n    Advance the current program point before making the conflict if\n    ADVANCE_P.  Return TRUE if we will need to advance the current\n    program point.  */\n@@ -562,7 +562,7 @@ make_pseudo_conflict (rtx reg, enum reg_class cl, rtx dreg, rtx orig_dreg,\n \n /* Check and make if necessary conflicts for pseudo DREG of class\n    DEF_CL of the current insn with input operand USE of class USE_CL.\n-   ORIG_DREG is the rtx actually accessed, it may be indentical to\n+   ORIG_DREG is the rtx actually accessed, it may be identical to\n    DREG or a subreg of it.  Advance the current program point before\n    making the conflict if ADVANCE_P.  Return TRUE if we will need to\n    advance the current program point.  */"}, {"sha": "7649a78052a5fc1262ee803151061e49a78b8068", "filename": "gcc/lto-streamer.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Flto-streamer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Flto-streamer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -39,7 +39,7 @@ along with GCC; see the file COPYING3.  If not see\n /* Statistics gathered during LTO, WPA and LTRANS.  */\n struct lto_stats_d lto_stats;\n \n-/* LTO uses bitmaps with different life-times.  So use a seperate\n+/* LTO uses bitmaps with different life-times.  So use a separate\n    obstack for all LTO bitmaps.  */\n static bitmap_obstack lto_obstack;\n static bool lto_obstack_initialized;"}, {"sha": "5c7bdd281d3a86e249ec8de722e057cc5120df20", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -300,7 +300,7 @@ typedef const char* (lto_get_section_data_f) (struct lto_file_decl_data *,\n \n /* Return the data found from the above call.  The first three\n    parameters are the same as above.  The fourth parameter is the data\n-   itself and the fifth is the lenght of the data. */\n+   itself and the fifth is the length of the data. */\n typedef void (lto_free_section_data_f) (struct lto_file_decl_data *,\n \t\t\t\t\tenum lto_section_type,\n \t\t\t\t\tconst char *,\n@@ -987,7 +987,7 @@ lto_init_tree_ref_encoder (struct lto_tree_ref_encoder *encoder,\n }\n \n \n-/* Destory an lto_tree_ref_encoder ENCODER by freeing its contents.  The\n+/* Destroy an lto_tree_ref_encoder ENCODER by freeing its contents.  The\n    memory used by ENCODER is not freed by this function.  */\n static inline void\n lto_destroy_tree_ref_encoder (struct lto_tree_ref_encoder *encoder)"}, {"sha": "1f4d2128d94d1ef22f04097cdfd889b7e5a4d180", "filename": "gcc/lto-wrapper.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Flto-wrapper.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Flto-wrapper.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-wrapper.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -727,7 +727,7 @@ run_gcc (unsigned argc, char *argv[])\n       obstack_ptr_grow (&argv_obstack, \"-fwpa\");\n     }\n \n-  /* Append the input objects and possible preceeding arguments.  */\n+  /* Append the input objects and possible preceding arguments.  */\n   for (i = 1; i < argc; ++i)\n     obstack_ptr_grow (&argv_obstack, argv[i]);\n   obstack_ptr_grow (&argv_obstack, NULL);"}, {"sha": "6a09244fa98dd20e9eb83b44e1be321893bfe80c", "filename": "gcc/mcf.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fmcf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fmcf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmcf.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -1385,7 +1385,7 @@ sum_edge_counts (VEC (edge, gc) *to_edges)\n }\n \n \n-/* Main routine. Smoothes the intial assigned basic block and edge counts using\n+/* Main routine. Smoothes the initial assigned basic block and edge counts using\n    a minimum cost flow algorithm, to ensure that the flow consistency rule is\n    obeyed: sum of outgoing edges = sum of incoming edges for each basic\n    block.  */"}, {"sha": "d03430aef82b481f14ad3a25263a13b64f8ff742", "filename": "gcc/mode-switching.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fmode-switching.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fmode-switching.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmode-switching.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -445,7 +445,7 @@ optimize_mode_switching (void)\n   int i, j;\n   int n_entities;\n   int max_num_modes = 0;\n-  bool emited ATTRIBUTE_UNUSED = false;\n+  bool emitted ATTRIBUTE_UNUSED = false;\n   basic_block post_entry ATTRIBUTE_UNUSED, pre_exit ATTRIBUTE_UNUSED;\n \n   for (e = N_ENTITIES - 1, n_entities = 0; e >= 0; e--)\n@@ -704,7 +704,7 @@ optimize_mode_switching (void)\n \t\t  /* Insert MODE_SET only if it is nonempty.  */\n \t\t  if (mode_set != NULL_RTX)\n \t\t    {\n-\t\t      emited = true;\n+\t\t      emitted = true;\n \t\t      if (NOTE_INSN_BASIC_BLOCK_P (ptr->insn_ptr))\n \t\t\temit_insn_after (mode_set, ptr->insn_ptr);\n \t\t      else\n@@ -731,7 +731,7 @@ optimize_mode_switching (void)\n #if defined (MODE_ENTRY) && defined (MODE_EXIT)\n   cleanup_cfg (CLEANUP_NO_INSN_DEL);\n #else\n-  if (!need_commit && !emited)\n+  if (!need_commit && !emitted)\n     return 0;\n #endif\n "}, {"sha": "3dc87294bb6f68572e5297b29980221245c009c7", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -322,7 +322,7 @@ ps_rtl_insn (partial_schedule_ptr ps, int id)\n     return ps_reg_move (ps, id)->insn;\n }\n \n-/* Partial schedule instruction ID, which belongs to PS, occured in\n+/* Partial schedule instruction ID, which belongs to PS, occurred in\n    the original (unscheduled) loop.  Return the first instruction\n    in the loop that was associated with ps_rtl_insn (PS, ID).\n    If the instruction had some notes before it, this is the first"}, {"sha": "1f56fa2f38bf81f19b547af3e73f36c34f4fad7a", "filename": "gcc/plugin.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fplugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fplugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fplugin.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -865,7 +865,7 @@ get_event_last (void)\n \n \n /* Retrieve the default plugin directory.  The gcc driver should have passed\n-   it as -iplugindir <dir> to the cc1 program, and it is queriable thru the\n+   it as -iplugindir <dir> to the cc1 program, and it is queriable through the\n    -print-file-name=plugin option to gcc.  */\n const char*\n default_plugin_dir_name (void)"}, {"sha": "e1ec874dd6afca7a6f62d3045dfcd4a9afe78ef7", "filename": "gcc/postreload.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -683,7 +683,7 @@ struct reg_use\n   /* Points to the memory reference enclosing the use, if any, NULL_RTX\n      otherwise.  */\n   rtx containing_mem;\n-  /* Location of the register withing INSN.  */\n+  /* Location of the register within INSN.  */\n   rtx *usep;\n   /* The reverse uid of the insn.  */\n   int ruid;"}, {"sha": "b92ba9b9334d728c09473a07c648bf0ae4c4b4a8", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -1583,8 +1583,8 @@ add_dependence_list_and_free (struct deps_desc *deps, rtx insn, rtx *listp,\n     }\n }\n \n-/* Remove all occurences of INSN from LIST.  Return the number of\n-   occurences removed.  */\n+/* Remove all occurrences of INSN from LIST.  Return the number of\n+   occurrences removed.  */\n \n static int\n remove_from_dependence_list (rtx insn, rtx* listp)\n@@ -2798,7 +2798,7 @@ sched_analyze_insn (struct deps_desc *deps, rtx x, rtx insn)\n \t\t\t && code == SET);\n \n   if (may_trap_p (x))\n-    /* Avoid moving trapping instructions accross function calls that might\n+    /* Avoid moving trapping instructions across function calls that might\n        not always return.  */\n     add_dependence_list (insn, deps->last_function_call_may_noreturn,\n \t\t\t 1, REG_DEP_ANTI);"}, {"sha": "23f99f42e194236835138f0f33330523e01b3bb9", "filename": "gcc/sel-sched-ir.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fsel-sched-ir.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fsel-sched-ir.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-ir.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -5044,7 +5044,7 @@ find_place_to_insert_bb (basic_block bb, int rgn)\n             break;\n         }\n \n-      /* We skipped the right block, so we increase i.  We accomodate\n+      /* We skipped the right block, so we increase i.  We accommodate\n          it for increasing by step later, so we decrease i.  */\n       return (i + 1) - 1;\n     }"}, {"sha": "20035527597e5771e9eccfd0816d4897f8e4fb16", "filename": "gcc/sel-sched-ir.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fsel-sched-ir.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fsel-sched-ir.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-ir.h?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -874,7 +874,7 @@ typedef struct\n {\n   /* For each bb header this field contains a set of live registers.\n      For all other insns this field has a NULL.\n-     We also need to know LV sets for the instructions, that are immediatly\n+     We also need to know LV sets for the instructions, that are immediately\n      after the border of the region.  */\n   regset lv_set;\n \n@@ -987,7 +987,7 @@ typedef struct\n   short flags;\n \n   /* When flags include SUCCS_ALL, this will be set to the exact type\n-     of the sucessor we're traversing now.  */\n+     of the successor we're traversing now.  */\n   short current_flags;\n \n   /* If skip to loop exits, save here information about loop exits.  */"}, {"sha": "cfecd6bc14865398f1b5b14866ab9c825cce8531", "filename": "gcc/sel-sched.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fsel-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fsel-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -285,7 +285,7 @@ struct rtx_search_arg\n   /* What we are searching for.  */\n   rtx x;\n \n-  /* The occurence counter.  */\n+  /* The occurrence counter.  */\n   int n;\n };\n \n@@ -733,7 +733,7 @@ can_substitute_through_p (insn_t insn, ds_t ds)\n   return false;\n }\n \n-/* Substitute all occurences of INSN's destination in EXPR' vinsn with INSN's\n+/* Substitute all occurrences of INSN's destination in EXPR' vinsn with INSN's\n    source (if INSN is eligible for substitution).  Returns TRUE if\n    substitution was actually performed, FALSE otherwise.  Substitution might\n    be not performed because it's either EXPR' vinsn doesn't contain INSN's\n@@ -4138,7 +4138,7 @@ invoke_reorder_hooks (fence_t fence)\n   return issue_more;\n }\n \n-/* Return an EXPR correponding to INDEX element of ready list, if\n+/* Return an EXPR corresponding to INDEX element of ready list, if\n    FOLLOW_READY_ELEMENT is true (i.e., an expr of\n    ready_element (&ready, INDEX) will be returned), and to INDEX element of\n    ready.vec otherwise.  */"}, {"sha": "d664403a52c68f3d5dc00660aae3500a7c4ee467", "filename": "gcc/sese.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fsese.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fsese.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsese.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -133,7 +133,7 @@ eq_ivtype_map_elts (const void *e1, const void *e2)\n \n \f\n \n-/* Record LOOP as occuring in REGION.  */\n+/* Record LOOP as occurring in REGION.  */\n \n static void\n sese_record_loop (sese region, loop_p loop)"}, {"sha": "34ec7ea8c48eb93a1cf28216dc723da4c77a4c23", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -1799,7 +1799,7 @@ finish_bitfield_representative (tree repr, tree field)\n   if (nextf)\n     {\n       tree maxsize;\n-      /* If there was an error, the field may be not layed out\n+      /* If there was an error, the field may be not laid out\n          correctly.  Don't bother to do anything.  */\n       if (TREE_TYPE (nextf) == error_mark_node)\n \treturn;\n@@ -1880,7 +1880,7 @@ finish_bitfield_representative (tree repr, tree field)\n }\n \n /* Compute and set FIELD_DECLs for the underlying objects we should\n-   use for bitfield access for the structure layed out with RLI.  */\n+   use for bitfield access for the structure laid out with RLI.  */\n \n static void\n finish_bitfield_layout (record_layout_info rli)\n@@ -2231,7 +2231,7 @@ layout_type (tree type)\n \t      }\n \n \t    /* If we arrived at a length of zero ignore any overflow\n-\t       that occured as part of the calculation.  There exists\n+\t       that occurred as part of the calculation.  There exists\n \t       an association of the plus one where that overflow would\n \t       not happen.  */\n \t    if (integer_zerop (length)"}, {"sha": "56cddac7c893c6480d80de9d61028a63231438dd", "filename": "gcc/target-hooks-macros.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Ftarget-hooks-macros.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Ftarget-hooks-macros.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-hooks-macros.h?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -60,7 +60,7 @@\n    In both these cases, leave the DOC string empty, i.e. \"\".\n    Sometimes, for some historic reason the function declaration \n    has to be documented differently\n-   than what it is.  In that case, use DEFHOOK_UNDOC to supress auto-generation\n+   than what it is.  In that case, use DEFHOOK_UNDOC to suppress auto-generation\n    of documentation.  DEFHOOK_UNDOC takes a DOC string which it ignores, so\n    you can put GPLed documentation string there if you have hopes that you\n    can clear the declaration & documentation for GFDL distribution later,"}, {"sha": "fd2bf8a7e33df4290d9b9682b946d0915f2b2090", "filename": "gcc/target.def", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -678,11 +678,11 @@ DEFHOOK\n    of INSN on CPU that are not described in DFA.\n    READY_TRY and N_READY represent the current state of search in the\n    optimization space.  The target can filter out instructions that\n-   should not be tried after issueing INSN by setting corresponding\n+   should not be tried after issuing INSN by setting corresponding\n    elements in READY_TRY to non-zero.\n    INSN is the instruction being evaluated.\n    PREV_DATA is a pointer to target-specific data corresponding\n-   to a state before issueing INSN.  */\n+   to a state before issuing INSN.  */\n DEFHOOK\n (first_cycle_multipass_issue,\n  \"\",\n@@ -696,7 +696,7 @@ DEFHOOK\n    described in DFA.\n    READY_TRY and N_READY represent the current state of search in the\n    optimization space.  The target can filter out instructions that\n-   should not be tried after issueing INSN by setting corresponding\n+   should not be tried after issuing INSN by setting corresponding\n    elements in READY_TRY to non-zero.  */\n DEFHOOK\n (first_cycle_multipass_backtrack,"}, {"sha": "702682300d80155a65290cff4f78537839612573", "filename": "gcc/trans-mem.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Ftrans-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Ftrans-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftrans-mem.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -1778,7 +1778,7 @@ static struct tm_region *all_tm_regions;\n static bitmap_obstack tm_obstack;\n \n \n-/* A subroutine of tm_region_init.  Record the existance of the\n+/* A subroutine of tm_region_init.  Record the existence of the\n    GIMPLE_TRANSACTION statement in a tree of tm_region elements.  */\n \n static struct tm_region *"}, {"sha": "89b95fa78afd97896d93a95372f1ea01c9a7ae3a", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -1346,7 +1346,7 @@ lower_try_finally_switch (struct leh_state *state, struct leh_tf_state *tf)\n \n   /* Begin inserting code for getting to the finally block.  Things\n      are done in this order to correspond to the sequence the code is\n-     layed out.  */\n+     laid out.  */\n \n   if (tf->may_fallthru)\n     {\n@@ -1957,7 +1957,7 @@ lower_eh_constructs_2 (struct leh_state *state, gimple_stmt_iterator *gsi)\n       /* If the stmt can throw use a new temporary for the assignment\n          to a LHS.  This makes sure the old value of the LHS is\n \t available on the EH edge.  Only do so for statements that\n-\t potentially fall thru (no noreturn calls e.g.), otherwise\n+\t potentially fall through (no noreturn calls e.g.), otherwise\n \t this new assignment might create fake fallthru regions.  */\n       if (stmt_could_throw_p (stmt)\n \t  && gimple_has_lhs (stmt)\n@@ -2748,7 +2748,7 @@ maybe_clean_or_replace_eh_stmt (gimple old_stmt, gimple new_stmt)\n   return false;\n }\n \n-/* Given a statement OLD_STMT in OLD_FUN and a duplicate statment NEW_STMT\n+/* Given a statement OLD_STMT in OLD_FUN and a duplicate statement NEW_STMT\n    in NEW_FUN, copy the EH table data from OLD_STMT to NEW_STMT.  The MAP\n    operand is the return value of duplicate_eh_regions.  */\n \n@@ -3307,7 +3307,7 @@ lower_eh_dispatch (basic_block src, gimple stmt)\n \n \t/* Collect the labels for a switch.  Zero the post_landing_pad\n \t   field becase we'll no longer have anything keeping these labels\n-\t   in existance and the optimizer will be free to merge these\n+\t   in existence and the optimizer will be free to merge these\n \t   blocks at will.  */\n \tfor (c = r->u.eh_try.first_catch; c ; c = c->next_catch)\n \t  {"}, {"sha": "310fe3bd1d7c6d9e33e8675084ea8cb104d23ec5", "filename": "gcc/tree-predcom.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Ftree-predcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Ftree-predcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-predcom.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -100,7 +100,7 @@ along with GCC; see the file COPYING3.  If not see\n       and we can combine the chains for e and f into one chain.\n \n    5) For each root reference (end of the chain) R, let N be maximum distance\n-      of a reference reusing its value.  Variables R0 upto RN are created,\n+      of a reference reusing its value.  Variables R0 up to RN are created,\n       together with phi nodes that transfer values from R1 .. RN to\n       R0 .. R(N-1).\n       Initial values are loaded to R0..R(N-1) (in case not all references"}, {"sha": "650d9b110ab9f647597e653dfaabce1950562de1", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -1081,7 +1081,7 @@ disqualify_ops_if_throwing_stmt (gimple stmt, tree lhs, tree rhs)\n   return false;\n }\n \n-/* Scan expressions occuring in STMT, create access structures for all accesses\n+/* Scan expressions occurring in STMT, create access structures for all accesses\n    to candidates for scalarization and remove those candidates which occur in\n    statements or expressions that prevent them from being split apart.  Return\n    true if any access has been inserted.  */"}, {"sha": "ca261341c3f54224ef1615c6cdad9b5726fa3af8", "filename": "gcc/tree-ssa-address.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Ftree-ssa-address.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Ftree-ssa-address.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-address.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -868,7 +868,7 @@ copy_ref_info (tree new_ref, tree old_ref)\n \t  duplicate_ssa_name_ptr_info\n \t    (new_ptr_base, SSA_NAME_PTR_INFO (TREE_OPERAND (base, 0)));\n \t  new_pi = SSA_NAME_PTR_INFO (new_ptr_base);\n-\t  /* We have to be careful about transfering alignment information.  */\n+\t  /* We have to be careful about transferring alignment information.  */\n \t  if (get_ptr_info_alignment (new_pi, &align, &misalign)\n \t      && TREE_CODE (old_ref) == MEM_REF\n \t      && !(TREE_CODE (new_ref) == TARGET_MEM_REF"}, {"sha": "9ce3a42f182f546161dda238a5a1b1bc829348c3", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -4704,7 +4704,7 @@ may_eliminate_iv (struct ivopts_data *data,\n       period_value = tree_to_double_int (period);\n       if (double_int_ucmp (max_niter, period_value) > 0)\n         {\n-          /* See if we can take advantage of infered loop bound information.  */\n+          /* See if we can take advantage of inferred loop bound information.  */\n           if (data->loop_single_exit_p)\n             {\n               if (!max_loop_iterations (loop, &max_niter))\n@@ -4817,7 +4817,7 @@ determine_use_iv_cost_condition (struct ivopts_data *data,\n   /* When the condition is a comparison of the candidate IV against\n      zero, prefer this IV.\n \n-     TODO: The constant that we're substracting from the cost should\n+     TODO: The constant that we're subtracting from the cost should\n      be target-dependent.  This information should be added to the\n      target costs for each backend.  */\n   if (!infinite_cost_p (elim_cost) /* Do not try to decrease infinite! */"}, {"sha": "befe46128344cfedf79713756b528cf8050c7017", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -591,7 +591,7 @@ number_of_iterations_ne_max (mpz_t bnd, bool no_overflow, tree c, tree s,\n      overflow, ... */\n   if (exit_must_be_taken)\n     {\n-      /* ... then we can strenghten this to C / S, and possibly we can use\n+      /* ... then we can strengthen this to C / S, and possibly we can use\n \t the upper bound on C given by BNDS.  */\n       if (TREE_CODE (c) == INTEGER_CST)\n \tmpz_set_double_int (bnd, tree_to_double_int (c), true);"}, {"sha": "a8aaed3962a93447f84d2a650fc3b40d2920fde3", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -2533,7 +2533,7 @@ convert_mult_to_fma (gimple mul_stmt, tree op1, tree op2)\n \t a*b-c -> fma(a,b,-c): we've exchanged MUL+SUB for FMA+NEG, which\n \t is still two operations.  Consider -(a*b)-c -> fma(-a,b,-c): we\n \t still have 3 operations, but in the FMA form the two NEGs are\n-\t independant and could be run in parallel.  */\n+\t independent and could be run in parallel.  */\n     }\n \n   FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter, mul_result)"}, {"sha": "9adf55d18cf24bc23ee03f1d159deb81c8885f10", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -4069,7 +4069,7 @@ compute_avail (void)\n \t\t\tif (TREE_CODE (nary->op[i]) == SSA_NAME)\n \t\t\t  add_to_exp_gen (block, nary->op[i]);\n \n-\t\t      /* If the NARY traps and there was a preceeding\n+\t\t      /* If the NARY traps and there was a preceding\n \t\t         point in the block that might not return avoid\n \t\t\t adding the nary to EXP_GEN.  */\n \t\t      if (BB_MAY_NOTRETURN (block)"}, {"sha": "1c3c77b2229e43342a1a09bd5353415a641d90c7", "filename": "gcc/tree-ssa-propagate.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Ftree-ssa-propagate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Ftree-ssa-propagate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -723,7 +723,7 @@ update_gimple_call (gimple_stmt_iterator *si_p, tree fn, int nargs, ...)\n    call.  This can only be done if EXPR is a CALL_EXPR with valid\n    GIMPLE operands as arguments, or if it is a suitable RHS expression\n    for a GIMPLE_ASSIGN.  More complex expressions will require\n-   gimplification, which will introduce addtional statements.  In this\n+   gimplification, which will introduce additional statements.  In this\n    event, no update is performed, and the function returns false.\n    Note that we cannot mutate a GIMPLE_CALL in-place, so we always\n    replace the statement at *SI_P with an entirely new statement."}, {"sha": "b4f442de7a80c74e8fdfec38f7c03e4817dd6cb3", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -1245,15 +1245,15 @@ build_and_add_sum (tree tmpvar, tree op1, tree op2, enum tree_code opcode)\n       in the candidates bitmap with relevant indices into *OPS.\n \n     - Second we build the chains of multiplications or divisions for\n-      these candidates, counting the number of occurences of (operand, code)\n+      these candidates, counting the number of occurrences of (operand, code)\n       pairs in all of the candidates chains.\n \n-    - Third we sort the (operand, code) pairs by number of occurence and\n+    - Third we sort the (operand, code) pairs by number of occurrence and\n       process them starting with the pair with the most uses.\n \n       * For each such pair we walk the candidates again to build a\n         second candidate bitmap noting all multiplication/division chains\n-\tthat have at least one occurence of (operand, code).\n+\tthat have at least one occurrence of (operand, code).\n \n       * We build an alternate addition chain only covering these\n         candidates with one (operand, code) operation removed from their"}, {"sha": "ae912d732a8a50c55220cd933e130c4addd6611d", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -998,7 +998,7 @@ vn_reference_fold_indirect (VEC (vn_reference_op_s, heap) **ops,\n   HOST_WIDE_INT addr_offset;\n \n   /* The only thing we have to do is from &OBJ.foo.bar add the offset\n-     from .foo.bar to the preceeding MEM_REF offset and replace the\n+     from .foo.bar to the preceding MEM_REF offset and replace the\n      address with &OBJ.  */\n   addr_base = get_addr_base_and_unit_offset (TREE_OPERAND (op->op0, 0),\n \t\t\t\t\t     &addr_offset);\n@@ -1043,7 +1043,7 @@ vn_reference_maybe_forwprop_address (VEC (vn_reference_op_s, heap) **ops,\n   off = double_int_sext (off, TYPE_PRECISION (TREE_TYPE (mem_op->op0)));\n \n   /* The only thing we have to do is from &OBJ.foo.bar add the offset\n-     from .foo.bar to the preceeding MEM_REF offset and replace the\n+     from .foo.bar to the preceding MEM_REF offset and replace the\n      address with &OBJ.  */\n   if (code == ADDR_EXPR)\n     {\n@@ -1379,7 +1379,7 @@ vn_reference_lookup_or_insert_for_pieces (tree vuse,\n \n /* Callback for walk_non_aliased_vuses.  Tries to perform a lookup\n    from the statement defining VUSE and if not successful tries to\n-   translate *REFP and VR_ through an aggregate copy at the defintion\n+   translate *REFP and VR_ through an aggregate copy at the definition\n    of VUSE.  */\n \n static void *"}, {"sha": "c4a50f5d329e872603c2b218ae0356196d7f3100", "filename": "gcc/tree-ssa-ter.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Ftree-ssa-ter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Ftree-ssa-ter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ter.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -473,7 +473,7 @@ finished_with_expr (temp_expr_table_p tab, int version, bool free_expr)\n   bitmap_iterator bi;\n \n   /* Remove this expression from its dependent lists.  The partition dependence\n-     list is retained and transfered later to whomever uses this version.  */\n+     list is retained and transferred later to whomever uses this version.  */\n   if (tab->partition_dependencies[version])\n     {\n       EXECUTE_IF_SET_IN_BITMAP (tab->partition_dependencies[version], 0, i, bi)"}, {"sha": "7337b68b4fe325068dfbfb03137baf350f603203", "filename": "gcc/tree-ssa-uninit.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Ftree-ssa-uninit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Ftree-ssa-uninit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uninit.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -1756,15 +1756,15 @@ normalize_preds (VEC(use_pred_info_t, heap) **preds, size_t *n)\n \n /* Computes the predicates that guard the use and checks\n    if the incoming paths that have empty (or possibly\n-   empty) defintion can be pruned/filtered. The function returns\n+   empty) definition can be pruned/filtered. The function returns\n    true if it can be determined that the use of PHI's def in\n    USE_STMT is guarded with a predicate set not overlapping with\n    predicate sets of all runtime paths that do not have a definition.\n    Returns false if it is not or it can not be determined. USE_BB is\n    the bb of the use (for phi operand use, the bb is not the bb of\n    the phi stmt, but the src bb of the operand edge). UNINIT_OPNDS\n    is a bit vector. If an operand of PHI is uninitialized, the\n-   correponding bit in the vector is 1.  VISIED_PHIS is a pointer\n+   corresponding bit in the vector is 1.  VISIED_PHIS is a pointer\n    set of phis being visted.  */\n \n static bool"}, {"sha": "ac63bc671eb37f3cd08521669b019ffd64dff629", "filename": "gcc/tree-ssanames.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Ftree-ssanames.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Ftree-ssanames.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssanames.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -281,7 +281,7 @@ set_ptr_info_alignment (struct ptr_info_def *pi, unsigned int align,\n   pi->misalign = misalign;\n }\n \n-/* If pointer decribed by PI has known alignment, increase its known\n+/* If pointer described by PI has known alignment, increase its known\n    misalignment by INCREMENT modulo its current alignment.  */\n \n void"}, {"sha": "10e194fcf1e81cd10f1ee763ce5112147c7b5c8c", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -508,7 +508,7 @@ type_for_widest_vector_mode (tree type, optab op)\n    returns either the element itself, either BIT_FIELD_REF, or an\n    ARRAY_REF expression.\n \n-   GSI is requred to insert temporary variables while building a\n+   GSI is required to insert temporary variables while building a\n    refernece to the element of the vector VECT.\n \n    PTMPVEC is a pointer to the temporary variable for caching"}, {"sha": "83cc77116d9988d65ae698cd8cc070da70fb9f82", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -1291,7 +1291,7 @@ vect_supported_load_permutation_p (slp_instance slp_instn, int group_size,\n      FORNOW: not supported in loop SLP because of realignment compications.  */\n   bb_vinfo = STMT_VINFO_BB_VINFO (vinfo_for_stmt (stmt));\n   bad_permutation = false;\n-  /* Check that for every node in the instance teh loads form a subchain.  */\n+  /* Check that for every node in the instance the loads form a subchain.  */\n   if (bb_vinfo)\n     {\n       FOR_EACH_VEC_ELT (slp_tree, SLP_INSTANCE_LOADS (slp_instn), i, node)"}, {"sha": "d3fa39ea9e08ca4fa336ee1e7bcfb97a321ed176", "filename": "gcc/tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -3057,7 +3057,7 @@ push_without_duplicates (tree exp, VEC (tree, heap) **queue)\n     VEC_safe_push (tree, heap, *queue, exp);\n }\n \n-/* Given a tree EXP, find all occurences of references to fields\n+/* Given a tree EXP, find all occurrences of references to fields\n    in a PLACEHOLDER_EXPR and place them in vector REFS without\n    duplicates.  Also record VAR_DECLs and CONST_DECLs.  Note that\n    we assume here that EXP contains only arithmetic expressions"}, {"sha": "69294b68f491b9e13fb3dba395ca7ba280492d03", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -4700,7 +4700,7 @@ typedef struct record_layout_info_s\n   /* The alignment of the record so far, ignoring #pragma pack and\n      __attribute__ ((packed)), in bits.  */\n   unsigned int unpacked_align;\n-  /* The previous field layed out.  */\n+  /* The previous field laid out.  */\n   tree prev_field;\n   /* The static variables (i.e., class variables, as opposed to\n      instance variables) encountered in T.  */\n@@ -4933,7 +4933,7 @@ extern bool contains_placeholder_p (const_tree);\n \n extern bool type_contains_placeholder_p (tree);\n \n-/* Given a tree EXP, find all occurences of references to fields\n+/* Given a tree EXP, find all occurrences of references to fields\n    in a PLACEHOLDER_EXPR and place them in vector REFS without\n    duplicates.  Also record VAR_DECLs and CONST_DECLs.  Note that\n    we assume here that EXP contains only arithmetic expressions"}, {"sha": "1aae3096a3ff4e6cdf7d2ce845df4d1f707df719", "filename": "gcc/varasm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -546,7 +546,7 @@ default_function_section (tree decl, enum node_frequency freq,\n     return NULL;\n   /* Startup code should go to startup subsection unless it is\n      unlikely executed (this happens especially with function splitting\n-     where we can split away unnecesary parts of static constructors.  */\n+     where we can split away unnecessary parts of static constructors.  */\n   if (startup && freq != NODE_FREQUENCY_UNLIKELY_EXECUTED)\n     return get_named_text_section (decl, \".text.startup\", NULL);\n "}, {"sha": "b0063c1632894511fd683bc908a0b753ee1d3dad", "filename": "gcc/varpool.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073a899888791eb53e4454236e3463b6619bfd9b/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=073a899888791eb53e4454236e3463b6619bfd9b", "patch": "@@ -259,7 +259,7 @@ varpool_analyze_node (struct varpool_node *node)\n   node->analyzed = true;\n }\n \n-/* Assemble thunks and aliases asociated to NODE.  */\n+/* Assemble thunks and aliases associated to NODE.  */\n \n static void\n assemble_aliases (struct varpool_node *node)\n@@ -508,7 +508,7 @@ varpool_extra_name_alias (tree alias, tree decl)\n   return alias_node;\n }\n \n-/* Call calback on NODE and aliases asociated to NODE. \n+/* Call calback on NODE and aliases associated to NODE. \n    When INCLUDE_OVERWRITABLE is false, overwritable aliases and thunks are\n    skipped. */\n "}]}