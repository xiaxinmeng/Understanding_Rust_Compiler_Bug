{"sha": "eaeec5ecfa45ef6af7642c6bf45c3d77dd4de6b9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWFlZWM1ZWNmYTQ1ZWY2YWY3NjQyYzZiZjQ1YzNkNzdkZDRkZTZiOQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2015-03-27T06:58:59Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-03-27T06:58:59Z"}, "message": "re PR lto/65536 (LTO line number information garbled)\n\n\n\tPR lto/65536\n\t* lto-streamer.h (class lto_location_cache): New.\n\t(struct data_in): Add location_cache.\n\t(lto_input_location): Update prototype.\n\t(stream_input_location_now): New.\n\t* streamer-hooks.h (struct streamer_hooks): Make input_location to take\n\tpointer to location.\n\t(stream_input_location): Update.\n\t* ipa-devirt.c: Include streamer-hooks.h and lto-streamer.h\n\t(warn_odr): Apply location cache before warning.\n\t(lto_input_location): Update prototype.\n\t* gimple-streamer-in.c (input_phi, input_gimple_stmt):\n\tUse stream_input_location_now.\n\t* lto/lto.c (unify_scc): Revert location cache when unification\n\tsuceeded.\n\t(lto_read_decls): Accept location cache after sucess;\n\tapply location cache before calling debug hooks.\n\t* lto-streamer-in.c (lto_location_cache::current_cache): New static\n\tvariable.\n\t(lto_location_cache::cmp_loc): New function.\n\t(lto_location_cache::apply_location_cache): New function.\n\t(lto_location_cache::accept_location_cache): New function.\n\t(lto_location_cache::revert_location_cache): New function.\n\t(lto_location_cache::input_location): New function.\n\t(lto_input_location): Do location caching.\n\t(stream_input_location_now): New function.\n\t(input_eh_region, input_struct_function_base): Use\n\tstream_input_location_now.\n\t(lto_data_in_create): use new.\n\t(lto_data_in_delete): Use delete.\n\t* tree-streamer-in.c (unpack_ts_block_value_fields,\n\tunpack_ts_omp_clause_value_fields, streamer_read_tree_bitfields,\n\tlto_input_ts_exp_tree_pointers): Update for cached location api.\n\nFrom-SVN: r221720", "tree": {"sha": "cbd2e935efaa0cca2a297c9acffbbdf68e1c834d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cbd2e935efaa0cca2a297c9acffbbdf68e1c834d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eaeec5ecfa45ef6af7642c6bf45c3d77dd4de6b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eaeec5ecfa45ef6af7642c6bf45c3d77dd4de6b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eaeec5ecfa45ef6af7642c6bf45c3d77dd4de6b9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eaeec5ecfa45ef6af7642c6bf45c3d77dd4de6b9/comments", "author": null, "committer": null, "parents": [{"sha": "38147a2a4e7c553840b45ba7d099a5f93ac192a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38147a2a4e7c553840b45ba7d099a5f93ac192a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38147a2a4e7c553840b45ba7d099a5f93ac192a4"}], "stats": {"total": 315, "additions": 276, "deletions": 39}, "files": [{"sha": "eef076634ec10a86493027c90f2560e503756b0a", "filename": "gcc/gimple-streamer-in.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaeec5ecfa45ef6af7642c6bf45c3d77dd4de6b9/gcc%2Fgimple-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaeec5ecfa45ef6af7642c6bf45c3d77dd4de6b9/gcc%2Fgimple-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-streamer-in.c?ref=eaeec5ecfa45ef6af7642c6bf45c3d77dd4de6b9", "patch": "@@ -87,7 +87,9 @@ input_phi (struct lto_input_block *ib, basic_block bb, struct data_in *data_in,\n       tree def = stream_read_tree (ib, data_in);\n       int src_index = streamer_read_uhwi (ib);\n       bitpack_d bp = streamer_read_bitpack (ib);\n-      location_t arg_loc = stream_input_location (&bp, data_in);\n+      /* Do not cache a location - we do not have API to get pointer to the\n+\t location in PHI statement and we may trigger reallocation.  */\n+      location_t arg_loc = stream_input_location_now (&bp, data_in);\n       basic_block sbb = BASIC_BLOCK_FOR_FN (fn, src_index);\n \n       edge e = NULL;\n@@ -134,8 +136,9 @@ input_gimple_stmt (struct lto_input_block *ib, struct data_in *data_in,\n   has_hist = bp_unpack_value (&bp, 1);\n   stmt->subcode = bp_unpack_var_len_unsigned (&bp);\n \n-  /* Read location information.  */\n-  gimple_set_location (stmt, stream_input_location (&bp, data_in));\n+  /* Read location information.  Caching here makes no sense until streamer\n+     cache can handle the following gimple_set_block.  */\n+  gimple_set_location (stmt, stream_input_location_now (&bp, data_in));\n \n   /* Read lexical block reference.  */\n   gimple_set_block (stmt, stream_read_tree (ib, data_in));"}, {"sha": "534f6c0220d40135d6bedb334895250fa1ea63f7", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaeec5ecfa45ef6af7642c6bf45c3d77dd4de6b9/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaeec5ecfa45ef6af7642c6bf45c3d77dd4de6b9/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=eaeec5ecfa45ef6af7642c6bf45c3d77dd4de6b9", "patch": "@@ -166,6 +166,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple-pretty-print.h\"\n #include \"stor-layout.h\"\n #include \"intl.h\"\n+#include \"streamer-hooks.h\"\n+#include \"lto-streamer.h\"\n \n /* Hash based set of pairs of types.  */\n typedef struct\n@@ -935,6 +937,10 @@ warn_odr (tree t1, tree t2, tree st1, tree st2,\n   if (!warn || !TYPE_NAME(t1))\n     return;\n \n+  /* ODR warnings are output druing LTO streaming; we must apply location\n+     cache for potential warnings to be output correctly.  */\n+  lto_location_cache::current_cache->apply_location_cache ();\n+\n   if (!warning_at (DECL_SOURCE_LOCATION (TYPE_NAME (t1)), OPT_Wodr,\n \t\t   \"type %qT violates one definition rule\",\n \t\t   t1))"}, {"sha": "4268bdeb8231bb715785a84a80d21b9be5f257b1", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 152, "deletions": 24, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaeec5ecfa45ef6af7642c6bf45c3d77dd4de6b9/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaeec5ecfa45ef6af7642c6bf45c3d77dd4de6b9/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=eaeec5ecfa45ef6af7642c6bf45c3d77dd4de6b9", "patch": "@@ -172,47 +172,174 @@ canon_file_name (const char *string)\n     }\n }\n \n+/* Pointer to currently alive instance of lto_location_cache.  */\n \n-/* Read a location bitpack from input block IB.  */\n+lto_location_cache *lto_location_cache::current_cache;\n \n-location_t\n-lto_input_location (struct bitpack_d *bp, struct data_in *data_in)\n+/* Sort locations in source order. Start with file from last application.  */\n+\n+int\n+lto_location_cache::cmp_loc (const void *pa, const void *pb)\n+{\n+  const cached_location *a = ((const cached_location *)pa);\n+  const cached_location *b = ((const cached_location *)pb);\n+  const char *current_file = current_cache->current_file;\n+  int current_line = current_cache->current_line;\n+\n+  if (a->file == current_file && b->file != current_file)\n+    return -1;\n+  if (a->file != current_file && b->file == current_file)\n+    return 1;\n+  if (a->file == current_file && b->file == current_file)\n+    {\n+      if (a->line == current_line && b->line != current_line)\n+\treturn -1;\n+      if (a->line != current_line && b->line == current_line)\n+\treturn 1;\n+    }\n+  if (a->file != b->file)\n+    return strcmp (a->file, b->file);\n+  if (a->line != b->line)\n+    return a->line - b->line;\n+  return a->col - b->col;\n+}\n+\n+/* Apply all changes in location cache.  Add locations into linemap and patch\n+   trees.  */\n+\n+bool\n+lto_location_cache::apply_location_cache ()\n+{\n+  static const char *prev_file;\n+  if (!loc_cache.length ())\n+    return false;\n+  if (loc_cache.length () > 1)\n+    loc_cache.qsort (cmp_loc);\n+\n+  for (unsigned int i = 0; i < loc_cache.length (); i++)\n+    {\n+      struct cached_location loc = loc_cache[i];\n+\n+      if (current_file != loc.file)\n+\tlinemap_add (line_table, prev_file ? LC_RENAME : LC_ENTER,\n+\t\t     false, loc.file, loc.line);\n+      else if (current_line != loc.line)\n+\t{\n+\t  int max = loc.col;\n+\n+\t  for (unsigned int j = i + 1; j < loc_cache.length (); j++)\n+\t    if (loc.file != loc_cache[j].file\n+\t\t|| loc.line != loc_cache[j].line)\n+\t      break;\n+\t    else if (max < loc_cache[j].col)\n+\t      max = loc_cache[j].col;\n+\t  linemap_line_start (line_table, loc.line, max + 1);\n+\t}\n+      gcc_assert (*loc.loc == BUILTINS_LOCATION + 1);\n+      if (current_file == loc.file && current_line == loc.line\n+\t  && current_col == loc.col)\n+\t*loc.loc = current_loc;\n+      else\n+        current_loc = *loc.loc = linemap_position_for_column (line_table,\n+\t\t\t\t\t\t\t      loc.col);\n+      current_line = loc.line;\n+      prev_file = current_file = loc.file;\n+      current_col = loc.col;\n+    }\n+  loc_cache.truncate (0);\n+  accepted_length = 0;\n+  return true;\n+}\n+\n+/* Tree merging did not suceed; mark all changes in the cache as accepted.  */\n+\n+void\n+lto_location_cache::accept_location_cache ()\n+{\n+  gcc_assert (current_cache == this);\n+  accepted_length = loc_cache.length ();\n+}\n+\n+/* Tree merging did suceed; throw away recent changes.  */\n+\n+void\n+lto_location_cache::revert_location_cache ()\n+{\n+  loc_cache.truncate (accepted_length);\n+}\n+\n+/* Read a location bitpack from input block IB and either update *LOC directly\n+   or add it to the location cache.\n+   It is neccesary to call apply_location_cache to get *LOC updated.  */\n+\n+void\n+lto_location_cache::input_location (location_t *loc, struct bitpack_d *bp,\n+\t\t\t\t    struct data_in *data_in)\n {\n-  static const char *current_file;\n-  static int current_line;\n-  static int current_col;\n+  static const char *stream_file;\n+  static int stream_line;\n+  static int stream_col;\n   bool file_change, line_change, column_change;\n-  bool prev_file = current_file != NULL;\n+\n+  gcc_assert (current_cache == this);\n \n   if (bp_unpack_value (bp, 1))\n-    return UNKNOWN_LOCATION;\n+    {\n+      *loc = UNKNOWN_LOCATION;\n+      return;\n+    }\n+  *loc = BUILTINS_LOCATION + 1;\n \n   file_change = bp_unpack_value (bp, 1);\n   line_change = bp_unpack_value (bp, 1);\n   column_change = bp_unpack_value (bp, 1);\n \n   if (file_change)\n-    current_file = canon_file_name (bp_unpack_string (data_in, bp));\n+    stream_file = canon_file_name (bp_unpack_string (data_in, bp));\n \n   if (line_change)\n-    current_line = bp_unpack_var_len_unsigned (bp);\n+    stream_line = bp_unpack_var_len_unsigned (bp);\n \n   if (column_change)\n-    current_col = bp_unpack_var_len_unsigned (bp);\n+    stream_col = bp_unpack_var_len_unsigned (bp);\n \n-  if (file_change)\n+  /* This optimization saves location cache operations druing gimple\n+     streaming.  */\n+     \n+  if (current_file == stream_file && current_line == stream_line\n+      && current_col == stream_col)\n     {\n-      if (prev_file)\n-\tlinemap_add (line_table, LC_LEAVE, false, NULL, 0);\n-\n-      linemap_add (line_table, LC_ENTER, false, current_file, current_line);\n+      *loc = current_loc;\n+      return;\n     }\n-  else if (line_change)\n-    linemap_line_start (line_table, current_line, current_col);\n \n-  return linemap_position_for_column (line_table, current_col);\n+  struct cached_location entry = {stream_file, loc, stream_line, stream_col};\n+  loc_cache.safe_push (entry);\n+}\n+\n+/* Read a location bitpack from input block IB and either update *LOC directly\n+   or add it to the location cache.\n+   It is neccesary to call apply_location_cache to get *LOC updated.  */\n+\n+void\n+lto_input_location (location_t *loc, struct bitpack_d *bp,\n+\t\t    struct data_in *data_in)\n+{\n+  data_in->location_cache.input_location (loc, bp, data_in);\n }\n \n+/* Read location and return it instead of going through location caching.\n+   This should be used only when the resulting location is not going to be\n+   discarded.  */\n+\n+location_t\n+stream_input_location_now (struct bitpack_d *bp, struct data_in *data_in)\n+{\n+  location_t loc;\n+  stream_input_location (&loc, bp, data_in);\n+  data_in->location_cache.apply_location_cache ();\n+  return loc;\n+}\n \n /* Read a reference to a tree node from DATA_IN using input block IB.\n    TAG is the expected node that should be found in IB, if TAG belongs\n@@ -390,7 +517,7 @@ input_eh_region (struct lto_input_block *ib, struct data_in *data_in, int ix)\n \t  r->u.must_not_throw.failure_decl = stream_read_tree (ib, data_in);\n \t  bitpack_d bp = streamer_read_bitpack (ib);\n \t  r->u.must_not_throw.failure_loc\n-\t   = stream_input_location (&bp, data_in);\n+\t   = stream_input_location_now (&bp, data_in);\n \t}\n \tbreak;\n \n@@ -927,8 +1054,8 @@ input_struct_function_base (struct function *fn, struct data_in *data_in,\n   fn->last_clique = bp_unpack_value (&bp, sizeof (short) * 8);\n \n   /* Input the function start and end loci.  */\n-  fn->function_start_locus = stream_input_location (&bp, data_in);\n-  fn->function_end_locus = stream_input_location (&bp, data_in);\n+  fn->function_start_locus = stream_input_location_now (&bp, data_in);\n+  fn->function_end_locus = stream_input_location_now (&bp, data_in);\n }\n \n \n@@ -1126,6 +1253,7 @@ lto_read_body_or_constructor (struct lto_file_decl_data *file_data, struct symta\n \t}\n       else\n         input_constructor (fn_decl, data_in, &ib_main);\n+      data_in->location_cache.apply_location_cache ();\n       /* And fixup types we streamed locally.  */\n \t{\n \t  struct streamer_tree_cache_d *cache = data_in->reader_cache;\n@@ -1543,7 +1671,7 @@ lto_data_in_create (struct lto_file_decl_data *file_data, const char *strings,\n \t\t    unsigned len,\n \t\t    vec<ld_plugin_symbol_resolution_t> resolutions)\n {\n-  struct data_in *data_in = XCNEW (struct data_in);\n+  struct data_in *data_in = new (struct data_in);\n   data_in->file_data = file_data;\n   data_in->strings = strings;\n   data_in->strings_len = len;\n@@ -1560,5 +1688,5 @@ lto_data_in_delete (struct data_in *data_in)\n {\n   data_in->globals_resolution.release ();\n   streamer_tree_cache_delete (data_in->reader_cache);\n-  free (data_in);\n+  delete data_in;\n }"}, {"sha": "bf17efe470a85088317a651bedcf9592e777aa98", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 71, "deletions": 1, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaeec5ecfa45ef6af7642c6bf45c3d77dd4de6b9/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaeec5ecfa45ef6af7642c6bf45c3d77dd4de6b9/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=eaeec5ecfa45ef6af7642c6bf45c3d77dd4de6b9", "patch": "@@ -307,6 +307,71 @@ typedef void (lto_free_section_data_f) (struct lto_file_decl_data *,\n \t\t\t\t\tconst char *,\n \t\t\t\t\tsize_t);\n \n+/* The location cache holds expanded locations for streamed in trees.\n+   This is done to reduce memory usage of libcpp linemap that strongly preffers\n+   locations to be inserted in the soruce order.  */\n+\n+class lto_location_cache\n+{\n+public:\n+  /* Apply all changes in location cache.  Add locations into linemap and patch\n+     trees.  */\n+  bool apply_location_cache ();\n+  /* Tree merging did not suceed; mark all changes in the cache as accepted.  */\n+  void accept_location_cache ();\n+  /* Tree merging did suceed; throw away recent changes.  */\n+  void revert_location_cache ();\n+  void input_location (location_t *loc, struct bitpack_d *bp,\n+\t\t       struct data_in *data_in);\n+  lto_location_cache ()\n+     : loc_cache (), accepted_length (0), current_file (NULL), current_line (0),\n+       current_col (0), current_loc (UNKNOWN_LOCATION)\n+  {\n+    gcc_assert (!current_cache);\n+    current_cache = this;\n+  }\n+  ~lto_location_cache ()\n+  {\n+    apply_location_cache ();\n+    gcc_assert (current_cache == this);\n+    current_cache = NULL;\n+  }\n+\n+  /* There can be at most one instance of location cache (combining multiple\n+     would bring it out of sync with libcpp linemap); point to current\n+     one.  */\n+  static lto_location_cache *current_cache;\n+  \n+private:\n+  static int cmp_loc (const void *pa, const void *pb);\n+\n+  struct cached_location\n+  {\n+    const char *file;\n+    location_t *loc;\n+    int line, col;\n+  };\n+\n+  /* The location cache.  */\n+\n+  vec<cached_location> loc_cache;\n+\n+  /* Accepted entries are ones used by trees that are known to be not unified\n+     by tree merging.  */\n+\n+  int accepted_length;\n+\n+  /* Bookkeeping to remember state in between calls to lto_apply_location_cache\n+     When streaming gimple, the location cache is not used and thus\n+     lto_apply_location_cache happens per location basis.  It is then\n+     useful to avoid redundant calls of linemap API.  */\n+\n+  const char *current_file;\n+  int current_line;\n+  int current_col;\n+  location_t current_loc;\n+};\n+\n /* Structure used as buffer for reading an LTO file.  */\n class lto_input_block\n {\n@@ -680,6 +745,9 @@ struct data_in\n \n   /* Cache of pickled nodes.  */\n   struct streamer_tree_cache_d *reader_cache;\n+\n+  /* Cache of source code location.  */\n+  lto_location_cache location_cache;\n };\n \n \n@@ -788,7 +856,9 @@ extern struct data_in *lto_data_in_create (struct lto_file_decl_data *,\n \t\t\t\t    vec<ld_plugin_symbol_resolution_t> );\n extern void lto_data_in_delete (struct data_in *);\n extern void lto_input_data_block (struct lto_input_block *, void *, size_t);\n-location_t lto_input_location (struct bitpack_d *, struct data_in *);\n+void lto_input_location (location_t *, struct bitpack_d *, struct data_in *);\n+location_t stream_input_location_now (struct bitpack_d *bp,\n+\t\t\t\t      struct data_in *data);\n tree lto_input_tree_ref (struct lto_input_block *, struct data_in *,\n \t\t\t struct function *, enum LTO_tags);\n void lto_tag_check_set (enum LTO_tags, int, ...);"}, {"sha": "588b60361ee6fe82b536d236debe30f63314d8f6", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaeec5ecfa45ef6af7642c6bf45c3d77dd4de6b9/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaeec5ecfa45ef6af7642c6bf45c3d77dd4de6b9/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=eaeec5ecfa45ef6af7642c6bf45c3d77dd4de6b9", "patch": "@@ -1,3 +1,11 @@\n+2015-03-26  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR lto/65536\n+\t* lto.c (unify_scc): Revert location cache when unification\n+\tsuceeded.\n+\t(lto_read_decls): Accept location cache after sucess;\n+\tapply location cache before calling debug hooks.\n+\n 2015-03-10  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* lto.c (read_cgraph_and_symbols): Do not do merging"}, {"sha": "360aeedcca1c7730c711a5e7cea0af323603cd98", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaeec5ecfa45ef6af7642c6bf45c3d77dd4de6b9/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaeec5ecfa45ef6af7642c6bf45c3d77dd4de6b9/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=eaeec5ecfa45ef6af7642c6bf45c3d77dd4de6b9", "patch": "@@ -1734,10 +1734,11 @@ cmp_tree (const void *p1_, const void *p2_)\n    that was successful, otherwise return false.  */\n \n static bool\n-unify_scc (struct streamer_tree_cache_d *cache, unsigned from,\n+unify_scc (struct data_in *data_in, unsigned from,\n \t   unsigned len, unsigned scc_entry_len, hashval_t scc_hash)\n {\n   bool unified_p = false;\n+  struct streamer_tree_cache_d *cache = data_in->reader_cache;\n   tree_scc *scc\n     = (tree_scc *) alloca (sizeof (tree_scc) + (len - 1) * sizeof (tree));\n   scc->next = NULL;\n@@ -1827,6 +1828,7 @@ unify_scc (struct streamer_tree_cache_d *cache, unsigned from,\n \t    }\n \n \t  /* Free the tree nodes from the read SCC.  */\n+\t  data_in->location_cache.revert_location_cache ();\n \t  for (unsigned i = 0; i < len; ++i)\n \t    {\n \t      enum tree_code code;\n@@ -1920,10 +1922,14 @@ lto_read_decls (struct lto_file_decl_data *decl_data, const void *data,\n \n \t  /* Try to unify the SCC with already existing ones.  */\n \t  if (!flag_ltrans\n-\t      && unify_scc (data_in->reader_cache, from,\n+\t      && unify_scc (data_in, from,\n \t\t\t    len, scc_entry_len, scc_hash))\n \t    continue;\n \n+\t  /* Tree merging failed, mark entries in location cache as\n+\t     permanent.  */\n+\t  data_in->location_cache.accept_location_cache ();\n+\n \t  bool seen_type = false;\n \t  for (unsigned i = 0; i < len; ++i)\n \t    {\n@@ -1953,7 +1959,13 @@ lto_read_decls (struct lto_file_decl_data *decl_data, const void *data,\n \t      /* Register TYPE_DECLs with the debuginfo machinery.  */\n \t      if (!flag_wpa\n \t\t  && TREE_CODE (t) == TYPE_DECL)\n-\t\tdebug_hooks->type_decl (t, !DECL_FILE_SCOPE_P (t));\n+\t\t{\n+\t\t  /* Dwarf2out needs location information.\n+\t\t     TODO: Moving this out of the streamer loop may noticealy\n+\t\t     improve ltrans linemap memory use.  */\n+\t\t  data_in->location_cache.apply_location_cache ();\n+\t\t  debug_hooks->type_decl (t, !DECL_FILE_SCOPE_P (t));\n+\t\t}\n \t      if (!flag_ltrans)\n \t\t{\n \t\t  /* Register variables and functions with the\n@@ -1979,6 +1991,7 @@ lto_read_decls (struct lto_file_decl_data *decl_data, const void *data,\n \t  gcc_assert (t && data_in->reader_cache->nodes.length () == from);\n \t}\n     }\n+  data_in->location_cache.apply_location_cache ();\n \n   /* Read in lto_in_decl_state objects.  */\n   data_ptr = (const uint32_t *) ((const char*) data + decl_offset); "}, {"sha": "8678b89d5f572229948d39600816f755f7eac882", "filename": "gcc/streamer-hooks.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaeec5ecfa45ef6af7642c6bf45c3d77dd4de6b9/gcc%2Fstreamer-hooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaeec5ecfa45ef6af7642c6bf45c3d77dd4de6b9/gcc%2Fstreamer-hooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstreamer-hooks.h?ref=eaeec5ecfa45ef6af7642c6bf45c3d77dd4de6b9", "patch": "@@ -52,7 +52,7 @@ struct streamer_hooks {\n   tree (*read_tree) (struct lto_input_block *, struct data_in *);\n \n   /* [REQ] Called by every streaming routine that needs to read a location.  */\n-  location_t (*input_location) (struct bitpack_d *, struct data_in *);\n+  void (*input_location) (location_t *, struct bitpack_d *, struct data_in *);\n \n   /* [REQ] Called by every streaming routine that needs to write a location.  */\n   void (*output_location) (struct output_block *, struct bitpack_d *, location_t);\n@@ -67,8 +67,8 @@ struct streamer_hooks {\n #define stream_read_tree(IB, DATA_IN) \\\n     streamer_hooks.read_tree (IB, DATA_IN)\n \n-#define stream_input_location(BP, DATA_IN) \\\n-    streamer_hooks.input_location (BP, DATA_IN)\n+#define stream_input_location(LOCPTR, BP, DATA_IN) \\\n+    streamer_hooks.input_location (LOCPTR, BP, DATA_IN)\n \n #define stream_output_location(OB, BP, LOC) \\\n     streamer_hooks.output_location (OB, BP, LOC)"}, {"sha": "6d84efbffe97d6ad5dc802bab71436413ce4fd2e", "filename": "gcc/tree-streamer-in.c", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaeec5ecfa45ef6af7642c6bf45c3d77dd4de6b9/gcc%2Ftree-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaeec5ecfa45ef6af7642c6bf45c3d77dd4de6b9/gcc%2Ftree-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer-in.c?ref=eaeec5ecfa45ef6af7642c6bf45c3d77dd4de6b9", "patch": "@@ -411,7 +411,7 @@ unpack_ts_block_value_fields (struct data_in *data_in,\n {\n   BLOCK_ABSTRACT (expr) = (unsigned) bp_unpack_value (bp, 1);\n   /* BLOCK_NUMBER is recomputed.  */\n-  BLOCK_SOURCE_LOCATION (expr) = stream_input_location (bp, data_in);\n+  stream_input_location (&BLOCK_SOURCE_LOCATION (expr), bp, data_in);\n }\n \n /* Unpack all the non-pointer fields of the TS_TRANSLATION_UNIT_DECL\n@@ -433,7 +433,7 @@ static void\n unpack_ts_omp_clause_value_fields (struct data_in *data_in,\n \t\t\t\t   struct bitpack_d *bp, tree expr)\n {\n-  OMP_CLAUSE_LOCATION (expr) = stream_input_location (bp, data_in);\n+  stream_input_location (&OMP_CLAUSE_LOCATION (expr), bp, data_in);\n   switch (OMP_CLAUSE_CODE (expr))\n     {\n     case OMP_CLAUSE_DEFAULT:\n@@ -503,7 +503,7 @@ streamer_read_tree_bitfields (struct lto_input_block *ib,\n     unpack_ts_fixed_cst_value_fields (&bp, expr);\n \n   if (CODE_CONTAINS_STRUCT (code, TS_DECL_MINIMAL))\n-    DECL_SOURCE_LOCATION (expr) = stream_input_location (&bp, data_in);\n+    stream_input_location (&DECL_SOURCE_LOCATION (expr), &bp, data_in);\n \n   if (CODE_CONTAINS_STRUCT (code, TS_DECL_COMMON))\n     unpack_ts_decl_common_value_fields (&bp, expr);\n@@ -522,7 +522,7 @@ streamer_read_tree_bitfields (struct lto_input_block *ib,\n \n   if (CODE_CONTAINS_STRUCT (code, TS_EXP))\n     {\n-      SET_EXPR_LOCATION (expr, stream_input_location (&bp, data_in));\n+      stream_input_location (&EXPR_CHECK (expr)->exp.locus, &bp, data_in);\n       if (code == MEM_REF\n \t  || code == TARGET_MEM_REF)\n \t{\n@@ -905,11 +905,20 @@ lto_input_ts_exp_tree_pointers (struct lto_input_block *ib,\n \t\t\t        struct data_in *data_in, tree expr)\n {\n   int i;\n+  tree block;\n \n   for (i = 0; i < TREE_OPERAND_LENGTH (expr); i++)\n     TREE_OPERAND (expr, i) = stream_read_tree (ib, data_in);\n \n-  TREE_SET_BLOCK (expr, stream_read_tree (ib, data_in));\n+  block = stream_read_tree (ib, data_in);\n+\n+  /* TODO: Block is stored in the locus information.  It may make more sense to\n+     to make it go via the location cache.  */\n+  if (block)\n+    {\n+      data_in->location_cache.apply_location_cache ();\n+      TREE_SET_BLOCK (expr, block);\n+    }\n }\n \n "}]}