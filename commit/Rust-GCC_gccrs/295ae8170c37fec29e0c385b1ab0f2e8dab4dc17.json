{"sha": "295ae8170c37fec29e0c385b1ab0f2e8dab4dc17", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjk1YWU4MTcwYzM3ZmVjMjllMGMzODViMWFiMGYyZThkYWI0ZGMxNw==", "commit": {"author": {"name": "Jason Eckhardt", "email": "jle@cygnus.com", "date": "2000-03-16T14:56:55Z"}, "committer": {"name": "Jason Eckhardt", "email": "jle@gcc.gnu.org", "date": "2000-03-16T14:56:55Z"}, "message": "flow.c: Move all basic block reordering code into its own file.\n\n\t* flow.c: Move all basic block reordering code into its own file.\n\t(create_basic_block): Externalize.\n\t* bb-reorder.c: New file. Copy all basic block reordering code from\n\tflow.c to this file.\n\t(reorder_basic_blocks): Fix fencepost error in for-loop.\n\t(reorder_basic_blocks): Remove braces from single statement for-loops.\n\t* basic-block.h: Add declaration for create_basic_block.\n\t* Makefile.in: Add rules for bb-reorder.o.\n\nFrom-SVN: r32585", "tree": {"sha": "f3ae6e2e07c4fd2a16104bf92617881e95c693af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f3ae6e2e07c4fd2a16104bf92617881e95c693af"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/295ae8170c37fec29e0c385b1ab0f2e8dab4dc17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/295ae8170c37fec29e0c385b1ab0f2e8dab4dc17", "html_url": "https://github.com/Rust-GCC/gccrs/commit/295ae8170c37fec29e0c385b1ab0f2e8dab4dc17", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/295ae8170c37fec29e0c385b1ab0f2e8dab4dc17/comments", "author": null, "committer": null, "parents": [{"sha": "e1e97c4f15e638cbace4f54ec987525f20893fa5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1e97c4f15e638cbace4f54ec987525f20893fa5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1e97c4f15e638cbace4f54ec987525f20893fa5"}], "stats": {"total": 1534, "additions": 800, "deletions": 734}, "files": [{"sha": "deeac92ea146e5f4727f7afbd75ad0ac9049f77d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/295ae8170c37fec29e0c385b1ab0f2e8dab4dc17/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/295ae8170c37fec29e0c385b1ab0f2e8dab4dc17/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=295ae8170c37fec29e0c385b1ab0f2e8dab4dc17", "patch": "@@ -1,3 +1,14 @@\n+Thu Mar 16 09:02:19 2000  Jason Eckhardt  <jle@cygnus.com>\n+\n+\t* flow.c: Move all basic block reordering code into its own file.\n+\t(create_basic_block): Externalize.\n+\t* bb-reorder.c: New file. Copy all basic block reordering code from\n+\tflow.c to this file.\n+\t(reorder_basic_blocks): Fix fencepost error in for-loop.\n+\t(reorder_basic_blocks): Remove braces from single statement for-loops.\n+\t* basic-block.h: Add declaration for create_basic_block.\n+\t* Makefile.in: Add rules for bb-reorder.o.\n+\n 2000-03-16  Neil Booth  <NeilB@earthling.net>\n \n \t* cppinit.c (handle_option):  Implement #unassert directive"}, {"sha": "b41eebb443216aca4bc882132332eb0602db6a26", "filename": "gcc/Makefile.in", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/295ae8170c37fec29e0c385b1ab0f2e8dab4dc17/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/295ae8170c37fec29e0c385b1ab0f2e8dab4dc17/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=295ae8170c37fec29e0c385b1ab0f2e8dab4dc17", "patch": "@@ -675,7 +675,7 @@ OBJS = diagnostic.o \\\n  insn-opinit.o insn-recog.o insn-extract.o insn-output.o insn-emit.o lcm.o \\\n  profile.o insn-attrtab.o $(out_object_file) $(EXTRA_OBJS) convert.o \\\n  mbchar.o dyn-string.o splay-tree.o graph.o sbitmap.o resource.o hash.o \\\n- predict.o lists.o ggc-common.o $(GGC) simplify-rtx.o ssa.o\n+ predict.o lists.o ggc-common.o $(GGC) simplify-rtx.o ssa.o bb-reorder.o\n \n # GEN files are listed separately, so they can be built before doing parallel\n #  makes for cc1 or cc1plus.  Otherwise sequent parallel make attempts to load\n@@ -1632,6 +1632,9 @@ predict.o: predict.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h \\\n    insn-config.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h output.h toplev.h \\\n    $(RECOG_H) insn-flags.h function.h except.h $(EXPR_H)\n lists.o: lists.c $(CONFIG_H) system.h toplev.h $(RTL_H) ggc.h\n+bb-reorder.o : bb-reorder.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h \\\n+   insn-config.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h output.h toplev.h \\\n+   $(RECOG_H) insn-flags.h function.h except.h $(EXPR_H)\n \n $(out_object_file): $(out_file) $(CONFIG_H) $(TREE_H) ggc.h \\\n    $(RTL_H) $(REGS_H) hard-reg-set.h real.h insn-config.h conditions.h \\"}, {"sha": "7705daa2b12ee93c78bb9be33db8867f57fa930c", "filename": "gcc/basic-block.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/295ae8170c37fec29e0c385b1ab0f2e8dab4dc17/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/295ae8170c37fec29e0c385b1ab0f2e8dab4dc17/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=295ae8170c37fec29e0c385b1ab0f2e8dab4dc17", "patch": "@@ -227,6 +227,7 @@ extern void flow_delete_insn_chain\tPARAMS ((rtx, rtx));\n extern void make_edge\t\t\tPARAMS ((sbitmap *, basic_block,\n \t\t\t\t\t\t basic_block, int));\n extern void remove_edge\t\t\tPARAMS ((edge));\n+extern void create_basic_block\t\tPARAMS ((int, rtx, rtx, rtx));\n \n \n /* Structure to hold information for each natural loop.  */"}, {"sha": "0adf68324d1ef57bc70384e7f5c7b96e7b63e045", "filename": "gcc/bb-reorder.c", "status": "added", "additions": 783, "deletions": 0, "changes": 783, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/295ae8170c37fec29e0c385b1ab0f2e8dab4dc17/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/295ae8170c37fec29e0c385b1ab0f2e8dab4dc17/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=295ae8170c37fec29e0c385b1ab0f2e8dab4dc17", "patch": "@@ -0,0 +1,783 @@\n+/* Basic block reordering routines for the GNU compiler.\n+   Copyright (C) 2000 Free Software Foundation, Inc.\n+\n+   This file is part of GNU CC.\n+\n+   GNU CC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   GNU CC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GNU CC; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n+\n+/* References:\n+\n+   \"Profile Guided Code Positioning\"\n+   Pettis and Hanson; PLDI '90.\n+*/\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"tree.h\"\n+#include \"rtl.h\"\n+#include \"tm_p.h\"\n+#include \"basic-block.h\"\n+#include \"insn-config.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"flags.h\"\n+#include \"output.h\"\n+#include \"function.h\"\n+#include \"except.h\"\n+#include \"toplev.h\"\n+#include \"recog.h\"\n+#include \"insn-flags.h\"\n+#include \"expr.h\"\n+#include \"obstack.h\"\n+\n+\n+/* The contents of the current function definition are allocated\n+   in this obstack, and all are freed at the end of the function.\n+   For top-level functions, this is temporary_obstack.\n+   Separate obstacks are made for nested functions.  */\n+\n+extern struct obstack *function_obstack;\n+\n+\n+typedef struct reorder_block_def {\n+  int flags;\n+  int index;\n+  basic_block add_jump;\n+  edge succ;\n+  rtx end;\n+  int block_begin;\n+  int block_end;\n+} *reorder_block_def;\n+\n+#define REORDER_BLOCK_HEAD\t0x1\n+#define REORDER_BLOCK_VISITED\t0x2\n+#define REORDER_MOVED_BLOCK_END 0x3\n+  \n+#define REORDER_BLOCK_FLAGS(bb) \\\n+  ((reorder_block_def) (bb)->aux)->flags\n+\n+#define REORDER_BLOCK_INDEX(bb) \\\n+  ((reorder_block_def) (bb)->aux)->index\n+\n+#define REORDER_BLOCK_ADD_JUMP(bb) \\\n+  ((reorder_block_def) (bb)->aux)->add_jump\n+\n+#define REORDER_BLOCK_SUCC(bb) \\\n+  ((reorder_block_def) (bb)->aux)->succ\n+\n+#define REORDER_BLOCK_OLD_END(bb) \\\n+  ((reorder_block_def) (bb)->aux)->end\n+\n+#define REORDER_BLOCK_BEGIN(bb) \\\n+  ((reorder_block_def) (bb)->aux)->block_begin\n+\n+#define REORDER_BLOCK_END(bb) \\\n+  ((reorder_block_def) (bb)->aux)->block_end\n+\n+\n+static int reorder_index;\n+static basic_block reorder_last_visited;\n+\n+enum reorder_skip_type {REORDER_SKIP_BEFORE, REORDER_SKIP_AFTER,\n+\t\t\tREORDER_SKIP_BLOCK_END};\n+\n+\n+/* Local function prototypes.  */\n+static rtx skip_insns_between_block\tPARAMS ((basic_block,\n+\t\t\t\t\t\t enum reorder_skip_type));\n+static basic_block get_common_dest\tPARAMS ((basic_block, basic_block));\n+static basic_block chain_reorder_blocks\tPARAMS ((edge, basic_block));\n+static void make_reorder_chain\t\tPARAMS ((basic_block));\n+static void fixup_reorder_chain\t\tPARAMS ((void));\n+\n+\n+/* Skip over insns BEFORE or AFTER BB which are typically associated with\n+   basic block BB.  */\n+\n+static rtx\n+skip_insns_between_block (bb, skip_type)\n+     basic_block bb;\n+     enum reorder_skip_type skip_type;\n+{\n+  rtx insn, last_insn;\n+\n+  if (skip_type == REORDER_SKIP_BEFORE)\n+    {\n+      if (bb == ENTRY_BLOCK_PTR)\n+\treturn 0;\n+\n+      last_insn = bb->head;\n+      for (insn = PREV_INSN (bb->head);\n+\t   insn && insn != BASIC_BLOCK (bb->index - 1)->end;\n+\t   last_insn = insn, insn = PREV_INSN (insn))\n+\t{\n+\t  if (NEXT_INSN (insn) != last_insn)\n+\t    break;\n+\n+\t  if (GET_CODE (insn) == NOTE\n+\t      && NOTE_LINE_NUMBER (insn) != NOTE_INSN_LOOP_END\n+\t      && NOTE_LINE_NUMBER (insn) != NOTE_INSN_BASIC_BLOCK\n+\t      && NOTE_LINE_NUMBER (insn) != NOTE_INSN_BLOCK_END)\n+\t    continue;\n+\t  \n+\t  break;\n+\t}\n+    }\n+\n+  else\n+    {\n+      last_insn = bb->end;\n+\n+      if (bb == EXIT_BLOCK_PTR)\n+\treturn 0;\n+\n+      for (insn = NEXT_INSN (bb->end); \n+\t   insn;\n+\t   last_insn = insn, insn = NEXT_INSN (insn))\n+\t{\n+\t  if (bb->index + 1 != n_basic_blocks\n+\t      && insn == BASIC_BLOCK (bb->index + 1)->head)\n+\t    break;\n+\n+\t  if (GET_CODE (insn) == BARRIER\n+\t      || GET_CODE (insn) == JUMP_INSN\n+\t      || (GET_CODE (insn) == NOTE\n+\t\t  && (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_END\n+\t\t      || NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_END)))\n+\t    continue;\n+\n+\t  if (GET_CODE (insn) == CODE_LABEL\n+\t      && GET_CODE (NEXT_INSN (insn)) == JUMP_INSN\n+\t      && (GET_CODE (PATTERN (NEXT_INSN (insn))) == ADDR_VEC\n+\t\t  || GET_CODE (PATTERN\n+\t\t\t       (NEXT_INSN (insn))) == ADDR_DIFF_VEC))\n+\t    {\n+\t      insn = NEXT_INSN (insn);\n+\t      continue;\n+\t    }\n+\t  break;\n+\t}\n+\n+      if (skip_type == REORDER_SKIP_BLOCK_END)\n+\t{\n+\t  int found_block_end = 0;\n+\n+\t  for (; insn; last_insn = insn, insn = NEXT_INSN (insn))\n+\t    {\n+\t      if (bb->index + 1 != n_basic_blocks\n+\t\t  && insn == BASIC_BLOCK (bb->index + 1)->head)\n+\t\tbreak;\n+\n+\t      if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_END)\n+\t\t{\n+\t\t  found_block_end = 1;\n+\t\t  continue;\n+\t\t}\n+\n+\t      if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_DELETED)\n+\t\tcontinue;\n+\n+\t      if (GET_CODE (insn) == NOTE\n+\t\t  && NOTE_LINE_NUMBER (insn) >= 0\n+\t\t  && NEXT_INSN (insn)\n+\t\t  && (NOTE_LINE_NUMBER (NEXT_INSN (insn))\n+\t\t      == NOTE_INSN_BLOCK_END))\n+\t\tcontinue;\n+\t      break;\n+\t    }\n+\n+\t  if (! found_block_end)\n+\t    last_insn = 0;\n+\t}\n+    }\n+\n+  return last_insn;\n+}\n+\n+\n+/* Return common destination for blocks BB0 and BB1.  */\n+\n+static basic_block\n+get_common_dest (bb0, bb1)\n+     basic_block bb0, bb1;\n+{\n+  edge e0, e1;\n+\n+  for (e0 = bb0->succ; e0; e0 = e0->succ_next)\n+    {\n+      for (e1 = bb1->succ; e1; e1 = e1->succ_next)\n+\t{\n+\t  if (e0->dest == e1->dest)\n+\t    {\n+\t      return e0->dest;\n+\t    }\n+\t}\n+    }\n+  return 0;\n+}\n+\n+\n+/* Move the destination block for edge E after chain end block CEB\n+   Adding jumps and labels is deferred until fixup_reorder_chain.  */\n+\n+static basic_block\n+chain_reorder_blocks (e, ceb)\n+     edge e;\n+     basic_block ceb;\n+{\n+  basic_block sb = e->src;\n+  basic_block db = e->dest;\n+  rtx cebe_insn, cebbe_insn, dbh_insn, dbe_insn;\n+  edge ee, last_edge;\n+\n+  enum cond_types {NO_COND, PREDICT_THEN_WITH_ELSE, PREDICT_ELSE,\n+\t\t   PREDICT_THEN_NO_ELSE, PREDICT_NOT_THEN_NO_ELSE};\n+  enum cond_types cond_type;\n+  enum cond_block_types {NO_COND_BLOCK, THEN_BLOCK, ELSE_BLOCK,\n+\t\t\t NO_ELSE_BLOCK};\n+  enum cond_block_types cond_block_type;\n+\n+  if (rtl_dump_file)\n+    fprintf (rtl_dump_file,\n+\t     \"Edge from basic block %d to basic block %d last visited %d\\n\",\n+\t     sb->index, db->index, ceb->index);\n+\n+  dbh_insn = skip_insns_between_block (db, REORDER_SKIP_BEFORE);\n+  cebe_insn = skip_insns_between_block (ceb, REORDER_SKIP_AFTER);\n+  cebbe_insn = skip_insns_between_block (ceb, REORDER_SKIP_BLOCK_END);\n+\n+  {\n+    int block_begins = 0;\n+    rtx insn;\n+\n+    for (insn = dbh_insn; insn && insn != db->end; insn = NEXT_INSN (insn))\n+      {\n+\tif (NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_BEG)\n+\t  {\n+\t    block_begins += 1;\n+\t    break;\n+\t  }\n+      }\n+    REORDER_BLOCK_BEGIN (sb) = block_begins;\n+  }\n+\n+  if (cebbe_insn)\n+    {\n+      int block_ends = 0;\n+      rtx insn;\n+\n+      for (insn = cebe_insn; insn; insn = NEXT_INSN (insn))\n+\t{\n+\t  if (PREV_INSN (insn) == cebbe_insn)\n+\t    break;\n+\t  if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_END)\n+\t    {\n+\t      block_ends += 1;\n+\t      continue;\n+\t    }\n+\t}\n+      REORDER_BLOCK_END (ceb) = block_ends;\n+    }\n+\n+  /* Blocks are in original order.  */\n+  if (sb->index == ceb->index\n+      && ceb->index + 1 == db->index && NEXT_INSN (cebe_insn))\n+    return db;\n+\n+  /* Get the type of block and type of condition.  */\n+  cond_type = NO_COND;\n+  cond_block_type = NO_COND_BLOCK;\n+  if (GET_CODE (sb->end) == JUMP_INSN && ! simplejump_p (sb->end)\n+      && condjump_p (sb->end))\n+    {\n+      if (e->flags & EDGE_FALLTHRU)\n+\tcond_block_type = THEN_BLOCK;\n+      else if (get_common_dest (sb->succ->dest, sb))\n+\tcond_block_type = NO_ELSE_BLOCK;\n+      else \n+\tcond_block_type = ELSE_BLOCK;\n+\n+      if (sb->succ->succ_next\n+\t  && get_common_dest (sb->succ->dest, sb))\n+\t{\n+\t  if (cond_block_type == THEN_BLOCK)\n+\t    {\n+\t      if (! (REORDER_BLOCK_FLAGS (sb->succ->succ_next->dest)\n+\t\t     & REORDER_BLOCK_VISITED))\n+\t\tcond_type = PREDICT_THEN_NO_ELSE;\n+\t      else\n+\t\tcond_type = PREDICT_NOT_THEN_NO_ELSE;\n+\t    }\n+\t  else if (cond_block_type == NO_ELSE_BLOCK)\n+\t    {\n+\t      if (! (REORDER_BLOCK_FLAGS (sb->succ->dest)\n+\t\t     & REORDER_BLOCK_VISITED))\n+\t\tcond_type = PREDICT_NOT_THEN_NO_ELSE;\n+\t      else\n+\t\tcond_type = PREDICT_THEN_NO_ELSE;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  if (cond_block_type == THEN_BLOCK)\n+\t    {\n+\t      if (! (REORDER_BLOCK_FLAGS (sb->succ->succ_next->dest)\n+\t\t     & REORDER_BLOCK_VISITED))\n+\t\tcond_type = PREDICT_THEN_WITH_ELSE;\n+\t      else\n+\t\tcond_type = PREDICT_ELSE;\n+\t    }\n+\t  else if (cond_block_type == ELSE_BLOCK\n+\t\t   && sb->succ->dest != EXIT_BLOCK_PTR)\n+\t    {\n+\t      if (! (REORDER_BLOCK_FLAGS (sb->succ->dest)\n+\t\t     & REORDER_BLOCK_VISITED))\n+\t\tcond_type = PREDICT_ELSE;\n+\t      else\n+\t\tcond_type = PREDICT_THEN_WITH_ELSE;\n+\t    }\n+\t}\n+    }\n+  \n+  if (rtl_dump_file)\n+    {\n+      static const char * cond_type_str [] = {\"not cond jump\", \"predict then\",\n+\t\t\t\t\t      \"predict else\",\n+\t\t\t\t\t      \"predict then w/o else\",\n+\t\t\t\t\t      \"predict not then w/o else\"};\n+      static const char * cond_block_type_str [] = {\"not then or else block\",\n+\t\t\t\t\t\t    \"then block\",\n+\t\t\t\t\t\t    \"else block\",\n+\t\t\t\t\t\t    \"then w/o else block\"};\n+\n+      fprintf (rtl_dump_file, \"     %s (looking at %s)\\n\",\n+\t       cond_type_str[(int)cond_type],\n+\t       cond_block_type_str[(int)cond_block_type]);\n+    }\n+\n+  /* Reflect that then block will move and we'll jump to it.  */\n+  if (cond_block_type != THEN_BLOCK\n+      && (cond_type == PREDICT_ELSE\n+\t  || cond_type == PREDICT_NOT_THEN_NO_ELSE))\n+    {\n+      if (rtl_dump_file)\n+\tfprintf (rtl_dump_file,\n+\t\t \"    then jump from block %d to block %d\\n\",\n+\t\t sb->index, sb->succ->dest->index);\n+\n+      /* Jump to reordered then block.  */\n+      REORDER_BLOCK_ADD_JUMP (sb) = sb->succ->dest;\n+    }\n+  \n+  /* Reflect that then block will jump back when we have no else.  */\n+  if (cond_block_type != THEN_BLOCK\n+      && cond_type == PREDICT_NOT_THEN_NO_ELSE)\n+    {\n+      for (ee = sb->succ->dest->succ;\n+\t   ee && ! (ee->flags & EDGE_FALLTHRU);\n+\t   ee = ee->succ_next)\n+\tcontinue;\n+\n+      if (ee && ! (GET_CODE (sb->succ->dest->end) == JUMP_INSN\n+\t\t   && ! simplejump_p (sb->succ->dest->end)))\n+\t{\n+\t  REORDER_BLOCK_ADD_JUMP (sb->succ->dest) = ee->dest;\n+\t}\n+    }\n+\n+  /* Reflect that else block will jump back.  */\n+  if (cond_block_type == ELSE_BLOCK\n+      && (cond_type == PREDICT_THEN_WITH_ELSE || cond_type == PREDICT_ELSE))\n+    {\n+      last_edge=db->succ;\n+\n+      if (last_edge\n+\t  && last_edge->dest != EXIT_BLOCK_PTR\n+\t  && GET_CODE (last_edge->dest->head) == CODE_LABEL\n+\t  && ! (GET_CODE (db->end) == JUMP_INSN))\n+\t{\n+\t  if (rtl_dump_file)\n+\t    fprintf (rtl_dump_file,\n+\t\t     \"     else jump from block %d to block %d\\n\",\n+\t\t     db->index, last_edge->dest->index);\n+\n+\t  REORDER_BLOCK_ADD_JUMP (db) = last_edge->dest;\n+\t}\n+    }\n+\n+  /* This block's successor has already been reordered. This can happen\n+     when we reorder a chain starting at a then or else.  */\n+  for (last_edge = db->succ;\n+       last_edge && ! (last_edge->flags & EDGE_FALLTHRU);\n+       last_edge = last_edge->succ_next)\n+    continue;\n+\n+  if (last_edge\n+      && last_edge->dest != EXIT_BLOCK_PTR\n+      && (REORDER_BLOCK_FLAGS (last_edge->dest)\n+\t  & REORDER_BLOCK_VISITED))\n+    {\n+      if (rtl_dump_file)\n+\tfprintf (rtl_dump_file,\n+\t\t \"     end of chain jump from block %d to block %d\\n\",\n+\t\t db->index, last_edge->dest->index);\n+\n+      REORDER_BLOCK_ADD_JUMP (db) = last_edge->dest;\n+    }\n+\n+  dbh_insn = skip_insns_between_block (db, REORDER_SKIP_BEFORE);\n+  cebe_insn = skip_insns_between_block (ceb, REORDER_SKIP_AFTER);\n+  dbe_insn = skip_insns_between_block (db, REORDER_SKIP_AFTER);\n+\n+  /* Leave behind any lexical block markers.  */\n+  if (debug_info_level > DINFO_LEVEL_TERSE\n+      && ceb->index + 1 < db->index)\n+    {\n+      rtx insn, last_insn = get_last_insn ();\n+      insn = NEXT_INSN (ceb->end);\n+      if (! insn)\n+\tinsn = REORDER_BLOCK_OLD_END (ceb);\n+\n+      if (NEXT_INSN (cebe_insn) == 0)\n+\t  set_last_insn (cebe_insn);\n+      for (; insn && insn != db->head/*dbh_insn*/;\n+\t   insn = NEXT_INSN (insn))\n+\t{\n+\t  if (GET_CODE (insn) == NOTE\n+\t      && (NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_BEG))\n+\t    {\n+\t      cebe_insn = emit_note_after (NOTE_INSN_BLOCK_BEG, cebe_insn);\n+\t      delete_insn (insn);\n+\t    }\n+\t  if (GET_CODE (insn) == NOTE\n+\t      && (NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_END))\n+\t    {\n+\t      cebe_insn = emit_note_after (NOTE_INSN_BLOCK_END, cebe_insn);\n+\t      delete_insn (insn);\n+\t    }      \n+\t}\n+      set_last_insn (last_insn);\n+    }\n+\n+  /* Rechain predicted block.  */\n+  NEXT_INSN (cebe_insn) = dbh_insn;\n+  PREV_INSN (dbh_insn) = cebe_insn;\n+\n+  REORDER_BLOCK_OLD_END (db) = NEXT_INSN (dbe_insn);\n+  if (db->index != n_basic_blocks - 1)\n+    NEXT_INSN (dbe_insn) = 0;\n+\n+  return db;\n+}\n+\n+\n+/* Reorder blocks starting at block B.  */\n+\n+static void\n+make_reorder_chain (bb)\n+     basic_block bb;\n+{\n+  edge e;\n+  basic_block visited_edge = NULL;\n+  rtx block_end;\n+  int probability;\n+\n+  if (bb == EXIT_BLOCK_PTR)\n+    return;\n+\n+  /* Find the most probable block.  */\n+  e = bb->succ;\n+  block_end = bb->end;\n+  if (GET_CODE (block_end) == JUMP_INSN && condjump_p (block_end))\n+    {\n+      rtx note = find_reg_note (block_end, REG_BR_PROB, 0);\n+\n+      if (note) \n+\tprobability = XINT (XEXP (note, 0), 0);\n+      else\n+\tprobability = 0;\n+\n+      if (probability >= REG_BR_PROB_BASE / 2)\n+\te = bb->succ->succ_next;\n+    }\n+\n+  /* Add chosen successor to chain and recurse on it.  */\n+  if (e && e->dest != EXIT_BLOCK_PTR\n+      && e->dest != e->src\n+      && (! (REORDER_BLOCK_FLAGS (e->dest) & REORDER_BLOCK_VISITED)\n+\t  || (REORDER_BLOCK_FLAGS (e->dest) == REORDER_BLOCK_HEAD)))\n+    {\n+      if (! (REORDER_BLOCK_FLAGS (bb) & REORDER_BLOCK_VISITED))\n+\t{\n+\t  REORDER_BLOCK_FLAGS (bb) |= REORDER_BLOCK_HEAD;\n+\t  REORDER_BLOCK_INDEX (bb) = reorder_index++;\n+\t  REORDER_BLOCK_FLAGS (bb) |= REORDER_BLOCK_VISITED;\n+\t}\n+\n+      if (REORDER_BLOCK_FLAGS (e->dest) & REORDER_BLOCK_VISITED)\n+\tREORDER_BLOCK_FLAGS (e->dest) &= ~REORDER_BLOCK_HEAD;\n+\t\n+      REORDER_BLOCK_SUCC (bb) = e;\n+\n+      visited_edge = e->dest;\n+\n+      reorder_last_visited = chain_reorder_blocks (e, bb);\n+\n+      if (e->dest\n+\t  && ! (REORDER_BLOCK_FLAGS (e->dest)\n+\t\t& REORDER_BLOCK_VISITED))\n+\tmake_reorder_chain (e->dest);\n+    }\n+  else\n+    {\n+      if (! (REORDER_BLOCK_FLAGS (bb) & REORDER_BLOCK_VISITED))\n+\t{\n+\t  REORDER_BLOCK_INDEX (bb) = reorder_index++;\n+\t  REORDER_BLOCK_FLAGS (bb) |= REORDER_BLOCK_VISITED;\n+\t}\n+    }\n+\n+  /* Recurse on the successors.  */\n+  for (e = bb->succ; e; e = e->succ_next)\n+    {\n+      if (e->dest && e->dest == EXIT_BLOCK_PTR)\n+\tcontinue;\n+\n+      if (e->dest\n+\t  && e->dest != e->src\n+\t  && e->dest != visited_edge\n+\t  && ! (REORDER_BLOCK_FLAGS (e->dest)\n+\t\t& REORDER_BLOCK_VISITED))\n+\t{\n+\t  reorder_last_visited\n+\t    = chain_reorder_blocks (e, reorder_last_visited);\n+\t  make_reorder_chain (e->dest);\n+\t}\n+    }\n+}\n+\n+\n+/* Fixup jumps and labels after reordering basic blocks.  */ \n+\n+static void\n+fixup_reorder_chain ()\n+{\n+  int i, j;\n+  rtx insn;\n+\n+  /* Set the new last insn.  */\n+  for (i = 0;\n+       i < n_basic_blocks - 1\n+\t && REORDER_BLOCK_INDEX (BASIC_BLOCK (i)) != n_basic_blocks;\n+       i++)\n+    continue;\n+\n+  for (insn = BASIC_BLOCK (i)->head;\n+       NEXT_INSN (insn) != 0;\n+       insn = NEXT_INSN (insn))\n+    continue;\n+\n+  set_last_insn (insn);\n+\n+  /* Add jumps and labels to fixup blocks.  */\n+  for (i = 0; i < n_basic_blocks - 1; i++)\n+    {\n+      basic_block bbi = BASIC_BLOCK (i);\n+      if (REORDER_BLOCK_ADD_JUMP (bbi))\n+\t{\n+\t  rtx label_insn, jump_insn, barrier_insn;\n+\n+\t  if (GET_CODE (REORDER_BLOCK_ADD_JUMP (bbi)->head)\n+\t      == CODE_LABEL)\n+\t    label_insn  = REORDER_BLOCK_ADD_JUMP (bbi)->head;\n+\t  else\n+\t    {\n+\t      rtx new_label = gen_label_rtx ();\n+\t      label_insn = emit_label_before (new_label,\n+\t\t\t      REORDER_BLOCK_ADD_JUMP (bbi)->head);\n+\t    }\n+\t  REORDER_BLOCK_ADD_JUMP (bbi)->head = label_insn;\t \n+\n+\t  jump_insn = emit_jump_insn_after (gen_jump (label_insn),\n+\t\t\t\t\t    bbi->end);\n+\t  JUMP_LABEL (jump_insn) = label_insn;\n+\t  ++LABEL_NUSES (label_insn);\n+\t  barrier_insn = emit_barrier_after (jump_insn);\n+\t  if (GET_CODE (bbi->end) != JUMP_INSN)\n+\t    bbi->end = jump_insn;\n+\t  /* Add block for jump.  Typically this is when a then is not\n+\t     predicted and we are jumping to the moved then block.  */\n+\t  else\t\n+\t    {\n+\t      basic_block nb;\n+\n+\t      VARRAY_GROW (basic_block_info, ++n_basic_blocks);\n+\t      create_basic_block (n_basic_blocks - 1, jump_insn,\n+\t\t\t\t  jump_insn, NULL);\n+\t      nb = BASIC_BLOCK (n_basic_blocks - 1);\n+\t      nb->global_live_at_start\n+\t\t= OBSTACK_ALLOC_REG_SET (function_obstack);\n+\t      nb->global_live_at_end\n+\t\t= OBSTACK_ALLOC_REG_SET (function_obstack);\n+\n+\t      COPY_REG_SET (nb->global_live_at_start,\n+\t\t\t    bbi->global_live_at_start);\n+\t      COPY_REG_SET (nb->global_live_at_end,\n+\t\t\t    bbi->global_live_at_start);\n+\t      BASIC_BLOCK (nb->index)->local_set = 0;\n+\n+\t      nb->aux = xcalloc (1, sizeof (struct reorder_block_def));\n+\t      REORDER_BLOCK_INDEX (BASIC_BLOCK (n_basic_blocks - 1))\n+\t\t= REORDER_BLOCK_INDEX (bbi) + 1;\n+\t      /* Relink to new block.  */\n+\t      nb->succ = bbi->succ;\n+\t      nb->succ->src = nb;\n+\n+\t      make_edge (NULL, bbi, nb, 0);\n+\t      bbi->succ->succ_next\n+\t\t= bbi->succ->succ_next->succ_next;\n+\t      nb->succ->succ_next = 0;\n+\t      /* Fix reorder block index to reflect new block.  */\n+\t      for (j = 0; j < n_basic_blocks - 1; j++)\n+\t\t{\n+\t\t  basic_block bbj = BASIC_BLOCK (j);\n+\t\t  if (REORDER_BLOCK_INDEX (bbj)\n+\t\t      >= REORDER_BLOCK_INDEX (bbi) + 1)\n+\t\t    REORDER_BLOCK_INDEX (bbj)++;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+/* Reorder basic blocks.  */\n+\n+void\n+reorder_basic_blocks ()\n+{\n+  int i, j;\n+  struct loops loops_info;\n+  int num_loops;\n+  rtx last_insn;\n+\n+  if (profile_arc_flag)\n+    return;\n+\n+  if (n_basic_blocks <= 1)\n+    return;\n+\n+  /* Exception edges are not currently handled.  */\n+  for (i = 0; i < n_basic_blocks; i++)\n+    {\n+      edge e;\n+\n+      for (e = BASIC_BLOCK (i)->succ; e && ! (e->flags & EDGE_EH);\n+\t   e = e->succ_next)\n+\tcontinue;\n+\n+      if (e && (e->flags & EDGE_EH))\n+\treturn;\n+    }\n+\n+  reorder_index = 0;\n+\n+  /* Find natural loops using the CFG.  */\n+  num_loops = flow_loops_find (&loops_info);\n+\n+  /* Dump loop information.  */\n+  flow_loops_dump (&loops_info, rtl_dump_file, 0);\n+\n+  /* Estimate using heuristics if no profiling info is available.  */\n+  if (! flag_branch_probabilities)\n+    estimate_probability (&loops_info);\n+\n+  reorder_last_visited = BASIC_BLOCK (0);\n+\n+  for (i = 0; i < n_basic_blocks; i++)\n+    BASIC_BLOCK (i)->aux = xcalloc (1, sizeof (struct reorder_block_def));\n+      \n+  last_insn\n+    = NEXT_INSN (skip_insns_between_block (BASIC_BLOCK (n_basic_blocks - 1),\n+\t\t\t\t\t   REORDER_SKIP_AFTER));\n+\n+  make_reorder_chain (BASIC_BLOCK (0));\n+\n+  fixup_reorder_chain ();\n+\n+#ifdef ENABLE_CHECKING\n+    {\n+      rtx insn, last_insn;\n+      last_insn = get_insns ();\n+      for (insn = NEXT_INSN (get_insns ());\n+\t   insn && PREV_INSN (insn) == last_insn\n+\t     && NEXT_INSN (PREV_INSN (insn)) == insn;\n+\t   last_insn = insn,\n+\t     insn = NEXT_INSN (insn))\n+\tcontinue;\n+\n+      if (insn)\n+\t{\n+\t  if (rtl_dump_file)\n+\t    fprintf (rtl_dump_file, \"insn chaining error at %d\\n\",\n+\t\t     INSN_UID (last_insn));\n+\t  abort();\n+\t}\n+    }\n+#endif\n+\n+  /* Put basic_block_info in new order.  */\n+  for (i = 0; i < n_basic_blocks - 1; i++)\n+    {\n+      for (j = i; i != REORDER_BLOCK_INDEX (BASIC_BLOCK (j)); j++)\n+\tcontinue;\n+\n+      if (REORDER_BLOCK_INDEX (BASIC_BLOCK (j)) == i\n+\t  && i != j)\n+\t{\n+\t  basic_block tempbb;\n+\t  int temprbi;\n+\t  int rbi = REORDER_BLOCK_INDEX (BASIC_BLOCK (j));\n+\n+\t  temprbi = BASIC_BLOCK (rbi)->index;\n+\t  BASIC_BLOCK (rbi)->index = BASIC_BLOCK (j)->index;\n+\t  BASIC_BLOCK (j)->index = temprbi;\n+\t  tempbb = BASIC_BLOCK (rbi);\n+\t  BASIC_BLOCK (rbi) = BASIC_BLOCK (j);\n+\t  BASIC_BLOCK (j) = tempbb;\n+\t}\n+    }\n+     \n+    {\n+      rtx xafter = skip_insns_between_block (BASIC_BLOCK (n_basic_blocks - 1),\n+\t\t\t\t\t     REORDER_SKIP_AFTER);\n+      if (xafter)\n+\tNEXT_INSN (xafter) = last_insn;\n+      else\n+\tabort();\n+    }\n+\n+#ifdef ENABLE_CHECKING\n+  verify_flow_info ();\n+#endif\n+\n+  for (i = 0; i < n_basic_blocks; i++)\n+    free (BASIC_BLOCK (i)->aux);\n+\n+  /* Free loop information.  */\n+  flow_loops_free (&loops_info);\n+}\n+"}, {"sha": "7030c1100622f0d7774b353b81e3e7e2dbf24d53", "filename": "gcc/flow.c", "status": "modified", "additions": 1, "deletions": 733, "changes": 734, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/295ae8170c37fec29e0c385b1ab0f2e8dab4dc17/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/295ae8170c37fec29e0c385b1ab0f2e8dab4dc17/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=295ae8170c37fec29e0c385b1ab0f2e8dab4dc17", "patch": "@@ -278,7 +278,6 @@ static rtx label_value_list;\n /* Forward declarations */\n static int count_basic_blocks\t\tPARAMS ((rtx));\n static rtx find_basic_blocks_1\t\tPARAMS ((rtx));\n-static void create_basic_block\t\tPARAMS ((int, rtx, rtx, rtx));\n static void clear_edges\t\t\tPARAMS ((void));\n static void make_edges\t\t\tPARAMS ((rtx));\n static void make_label_edge\t\tPARAMS ((sbitmap *, basic_block,\n@@ -352,10 +351,6 @@ static void flow_loop_tree_node_add\tPARAMS ((struct loop *, struct loop *));\n static void flow_loops_tree_build\tPARAMS ((struct loops *));\n static int flow_loop_level_compute\tPARAMS ((struct loop *, int));\n static int flow_loops_level_compute\tPARAMS ((struct loops *));\n-static basic_block get_common_dest\tPARAMS ((basic_block, basic_block));\n-static basic_block chain_reorder_blocks\tPARAMS ((edge, basic_block));\n-static void make_reorder_chain\t\tPARAMS ((basic_block));\n-static void fixup_reorder_chain\t\tPARAMS ((void));\n \n /* This function is always defined so it can be called from the\n    debugger, and it is declared extern so we don't get warnings about\n@@ -745,7 +740,7 @@ cleanup_cfg (f)\n    HEAD and END inclusive.  Reuses the note and basic block struct\n    in BB_NOTE, if any.  */\n \n-static void\n+void\n create_basic_block (index, head, end, bb_note)\n      int index;\n      rtx head, end, bb_note;\n@@ -7056,733 +7051,6 @@ flow_loop_outside_edge_p (loop, e)\n }\n \n \n-typedef struct reorder_block_def {\n-  int flags;\n-  int index;\n-  basic_block add_jump;\n-  edge succ;\n-  rtx end;\n-  int block_begin;\n-  int block_end;\n-} *reorder_block_def;\n-\n-#define REORDER_BLOCK_HEAD\t0x1\n-#define REORDER_BLOCK_VISITED\t0x2\n-#define REORDER_MOVED_BLOCK_END 0x3\n-  \n-#define REORDER_BLOCK_FLAGS(bb) \\\n-  ((reorder_block_def) (bb)->aux)->flags\n-\n-#define REORDER_BLOCK_INDEX(bb) \\\n-  ((reorder_block_def) (bb)->aux)->index\n-\n-#define REORDER_BLOCK_ADD_JUMP(bb) \\\n-  ((reorder_block_def) (bb)->aux)->add_jump\n-\n-#define REORDER_BLOCK_SUCC(bb) \\\n-  ((reorder_block_def) (bb)->aux)->succ\n-\n-#define REORDER_BLOCK_OLD_END(bb) \\\n-  ((reorder_block_def) (bb)->aux)->end\n-\n-#define REORDER_BLOCK_BEGIN(bb) \\\n-  ((reorder_block_def) (bb)->aux)->block_begin\n-\n-#define REORDER_BLOCK_END(bb) \\\n-  ((reorder_block_def) (bb)->aux)->block_end\n-\n-\n-static int reorder_index;\n-static basic_block reorder_last_visited;\n-\n-enum reorder_skip_type {REORDER_SKIP_BEFORE, REORDER_SKIP_AFTER,\n-\t\t\tREORDER_SKIP_BLOCK_END};\n-\n-static rtx skip_insns_between_block\tPARAMS ((basic_block,\n-\t\t\t\t\t\t enum reorder_skip_type));\n-\n-/* Skip over insns BEFORE or AFTER BB which are typically associated with\n-   basic block BB.  */\n-\n-static rtx\n-skip_insns_between_block (bb, skip_type)\n-     basic_block bb;\n-     enum reorder_skip_type skip_type;\n-{\n-  rtx insn, last_insn;\n-\n-  if (skip_type == REORDER_SKIP_BEFORE)\n-    {\n-      if (bb == ENTRY_BLOCK_PTR)\n-\treturn 0;\n-\n-      last_insn = bb->head;\n-      for (insn = PREV_INSN (bb->head);\n-\t   insn && insn != BASIC_BLOCK (bb->index - 1)->end;\n-\t   last_insn = insn, insn = PREV_INSN (insn))\n-\t{\n-\t  if (NEXT_INSN (insn) != last_insn)\n-\t    break;\n-\n-\t  if (GET_CODE (insn) == NOTE\n-\t      && NOTE_LINE_NUMBER (insn) != NOTE_INSN_LOOP_END\n-\t      && NOTE_LINE_NUMBER (insn) != NOTE_INSN_BASIC_BLOCK\n-\t      && NOTE_LINE_NUMBER (insn) != NOTE_INSN_BLOCK_END)\n-\t    continue;\n-\t  \n-\t  break;\n-\t}\n-    }\n-\n-  else\n-    {\n-      last_insn = bb->end;\n-\n-      if (bb == EXIT_BLOCK_PTR)\n-\treturn 0;\n-\n-      for (insn = NEXT_INSN (bb->end); \n-\t   insn;\n-\t   last_insn = insn, insn = NEXT_INSN (insn))\n-\t{\n-\t  if (bb->index + 1 != n_basic_blocks\n-\t      && insn == BASIC_BLOCK (bb->index + 1)->head)\n-\t    break;\n-\n-\t  if (GET_CODE (insn) == BARRIER\n-\t      || GET_CODE (insn) == JUMP_INSN\n-\t      || (GET_CODE (insn) == NOTE\n-\t\t  && (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_END\n-\t\t      || NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_END)))\n-\t    continue;\n-\n-\t  if (GET_CODE (insn) == CODE_LABEL\n-\t      && GET_CODE (NEXT_INSN (insn)) == JUMP_INSN\n-\t      && (GET_CODE (PATTERN (NEXT_INSN (insn))) == ADDR_VEC\n-\t\t  || GET_CODE (PATTERN\n-\t\t\t       (NEXT_INSN (insn))) == ADDR_DIFF_VEC))\n-\t    {\n-\t      insn = NEXT_INSN (insn);\n-\t      continue;\n-\t    }\n-\t  break;\n-\t}\n-\n-      if (skip_type == REORDER_SKIP_BLOCK_END)\n-\t{\n-\t  int found_block_end = 0;\n-\n-\t  for (; insn; last_insn = insn, insn = NEXT_INSN (insn))\n-\t    {\n-\t      if (bb->index + 1 != n_basic_blocks\n-\t\t  && insn == BASIC_BLOCK (bb->index + 1)->head)\n-\t\tbreak;\n-\n-\t      if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_END)\n-\t\t{\n-\t\t  found_block_end = 1;\n-\t\t  continue;\n-\t\t}\n-\n-\t      if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_DELETED)\n-\t\tcontinue;\n-\n-\t      if (GET_CODE (insn) == NOTE\n-\t\t  && NOTE_LINE_NUMBER (insn) >= 0\n-\t\t  && NEXT_INSN (insn)\n-\t\t  && (NOTE_LINE_NUMBER (NEXT_INSN (insn))\n-\t\t      == NOTE_INSN_BLOCK_END))\n-\t\tcontinue;\n-\t      break;\n-\t    }\n-\n-\t  if (! found_block_end)\n-\t    last_insn = 0;\n-\t}\n-    }\n-\n-  return last_insn;\n-}\n-\n-\n-/* Return common destination for blocks BB0 and BB1.  */\n-\n-static basic_block\n-get_common_dest (bb0, bb1)\n-     basic_block bb0, bb1;\n-{\n-  edge e0, e1;\n-\n-  for (e0 = bb0->succ; e0; e0 = e0->succ_next)\n-    {\n-      for (e1 = bb1->succ; e1; e1 = e1->succ_next)\n-\t{\n-\t  if (e0->dest == e1->dest)\n-\t    {\n-\t      return e0->dest;\n-\t    }\n-\t}\n-    }\n-  return 0;\n-}\n-\n-\n-/* Move the destination block for edge E after chain end block CEB\n-   Adding jumps and labels is deferred until fixup_reorder_chain.  */\n-\n-static basic_block\n-chain_reorder_blocks (e, ceb)\n-     edge e;\n-     basic_block ceb;\n-{\n-  basic_block sb = e->src;\n-  basic_block db = e->dest;\n-  rtx cebe_insn, cebbe_insn, dbh_insn, dbe_insn;\n-  edge ee, last_edge;\n-\n-  enum cond_types {NO_COND, PREDICT_THEN_WITH_ELSE, PREDICT_ELSE,\n-\t\t   PREDICT_THEN_NO_ELSE, PREDICT_NOT_THEN_NO_ELSE};\n-  enum cond_types cond_type;\n-  enum cond_block_types {NO_COND_BLOCK, THEN_BLOCK, ELSE_BLOCK,\n-\t\t\t NO_ELSE_BLOCK};\n-  enum cond_block_types cond_block_type;\n-\n-  if (rtl_dump_file)\n-    fprintf (rtl_dump_file,\n-\t     \"Edge from basic block %d to basic block %d last visited %d\\n\",\n-\t     sb->index, db->index, ceb->index);\n-\n-  dbh_insn = skip_insns_between_block (db, REORDER_SKIP_BEFORE);\n-  cebe_insn = skip_insns_between_block (ceb, REORDER_SKIP_AFTER);\n-  cebbe_insn = skip_insns_between_block (ceb, REORDER_SKIP_BLOCK_END);\n-\n-  {\n-    int block_begins = 0;\n-    rtx insn;\n-\n-    for (insn = dbh_insn; insn && insn != db->end; insn = NEXT_INSN (insn))\n-      {\n-\tif (NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_BEG)\n-\t  {\n-\t    block_begins += 1;\n-\t    break;\n-\t  }\n-      }\n-    REORDER_BLOCK_BEGIN (sb) = block_begins;\n-  }\n-\n-  if (cebbe_insn)\n-    {\n-      int block_ends = 0;\n-      rtx insn;\n-\n-      for (insn = cebe_insn; insn; insn = NEXT_INSN (insn))\n-\t{\n-\t  if (PREV_INSN (insn) == cebbe_insn)\n-\t    break;\n-\t  if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_END)\n-\t    {\n-\t      block_ends += 1;\n-\t      continue;\n-\t    }\n-\t}\n-      REORDER_BLOCK_END (ceb) = block_ends;\n-    }\n-\n-  /* Blocks are in original order.  */\n-  if (sb->index == ceb->index\n-      && ceb->index + 1 == db->index && NEXT_INSN (cebe_insn))\n-    return db;\n-\n-  /* Get the type of block and type of condition.  */\n-  cond_type = NO_COND;\n-  cond_block_type = NO_COND_BLOCK;\n-  if (GET_CODE (sb->end) == JUMP_INSN && ! simplejump_p (sb->end)\n-      && condjump_p (sb->end))\n-    {\n-      if (e->flags & EDGE_FALLTHRU)\n-\tcond_block_type = THEN_BLOCK;\n-      else if (get_common_dest (sb->succ->dest, sb))\n-\tcond_block_type = NO_ELSE_BLOCK;\n-      else \n-\tcond_block_type = ELSE_BLOCK;\n-\n-      if (sb->succ->succ_next\n-\t  && get_common_dest (sb->succ->dest, sb))\n-\t{\n-\t  if (cond_block_type == THEN_BLOCK)\n-\t    {\n-\t      if (! (REORDER_BLOCK_FLAGS (sb->succ->succ_next->dest)\n-\t\t     & REORDER_BLOCK_VISITED))\n-\t\tcond_type = PREDICT_THEN_NO_ELSE;\n-\t      else\n-\t\tcond_type = PREDICT_NOT_THEN_NO_ELSE;\n-\t    }\n-\t  else if (cond_block_type == NO_ELSE_BLOCK)\n-\t    {\n-\t      if (! (REORDER_BLOCK_FLAGS (sb->succ->dest)\n-\t\t     & REORDER_BLOCK_VISITED))\n-\t\tcond_type = PREDICT_NOT_THEN_NO_ELSE;\n-\t      else\n-\t\tcond_type = PREDICT_THEN_NO_ELSE;\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  if (cond_block_type == THEN_BLOCK)\n-\t    {\n-\t      if (! (REORDER_BLOCK_FLAGS (sb->succ->succ_next->dest)\n-\t\t     & REORDER_BLOCK_VISITED))\n-\t\tcond_type = PREDICT_THEN_WITH_ELSE;\n-\t      else\n-\t\tcond_type = PREDICT_ELSE;\n-\t    }\n-\t  else if (cond_block_type == ELSE_BLOCK\n-\t\t   && sb->succ->dest != EXIT_BLOCK_PTR)\n-\t    {\n-\t      if (! (REORDER_BLOCK_FLAGS (sb->succ->dest)\n-\t\t     & REORDER_BLOCK_VISITED))\n-\t\tcond_type = PREDICT_ELSE;\n-\t      else\n-\t\tcond_type = PREDICT_THEN_WITH_ELSE;\n-\t    }\n-\t}\n-    }\n-  \n-  if (rtl_dump_file)\n-    {\n-      static const char * cond_type_str [] = {\"not cond jump\", \"predict then\",\n-\t\t\t\t\t      \"predict else\",\n-\t\t\t\t\t      \"predict then w/o else\",\n-\t\t\t\t\t      \"predict not then w/o else\"};\n-      static const char * cond_block_type_str [] = {\"not then or else block\",\n-\t\t\t\t\t\t    \"then block\",\n-\t\t\t\t\t\t    \"else block\",\n-\t\t\t\t\t\t    \"then w/o else block\"};\n-\n-      fprintf (rtl_dump_file, \"     %s (looking at %s)\\n\",\n-\t       cond_type_str[(int)cond_type],\n-\t       cond_block_type_str[(int)cond_block_type]);\n-    }\n-\n-  /* Reflect that then block will move and we'll jump to it.  */\n-  if (cond_block_type != THEN_BLOCK\n-      && (cond_type == PREDICT_ELSE\n-\t  || cond_type == PREDICT_NOT_THEN_NO_ELSE))\n-    {\n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file,\n-\t\t \"    then jump from block %d to block %d\\n\",\n-\t\t sb->index, sb->succ->dest->index);\n-\n-      /* Jump to reordered then block.  */\n-      REORDER_BLOCK_ADD_JUMP (sb) = sb->succ->dest;\n-    }\n-  \n-  /* Reflect that then block will jump back when we have no else.  */\n-  if (cond_block_type != THEN_BLOCK\n-      && cond_type == PREDICT_NOT_THEN_NO_ELSE)\n-    {\n-      for (ee = sb->succ->dest->succ;\n-\t   ee && ! (ee->flags & EDGE_FALLTHRU);\n-\t   ee = ee->succ_next)\n-\tcontinue;\n-\n-      if (ee && ! (GET_CODE (sb->succ->dest->end) == JUMP_INSN\n-\t\t   && ! simplejump_p (sb->succ->dest->end)))\n-\t{\n-\t  REORDER_BLOCK_ADD_JUMP (sb->succ->dest) = ee->dest;\n-\t}\n-    }\n-\n-  /* Reflect that else block will jump back.  */\n-  if (cond_block_type == ELSE_BLOCK\n-      && (cond_type == PREDICT_THEN_WITH_ELSE || cond_type == PREDICT_ELSE))\n-    {\n-      last_edge=db->succ;\n-\n-      if (last_edge\n-\t  && last_edge->dest != EXIT_BLOCK_PTR\n-\t  && GET_CODE (last_edge->dest->head) == CODE_LABEL\n-\t  && ! (GET_CODE (db->end) == JUMP_INSN))\n-\t{\n-\t  if (rtl_dump_file)\n-\t    fprintf (rtl_dump_file,\n-\t\t     \"     else jump from block %d to block %d\\n\",\n-\t\t     db->index, last_edge->dest->index);\n-\n-\t  REORDER_BLOCK_ADD_JUMP (db) = last_edge->dest;\n-\t}\n-    }\n-\n-  /* This block's successor has already been reordered. This can happen\n-     when we reorder a chain starting at a then or else.  */\n-  for (last_edge = db->succ;\n-       last_edge && ! (last_edge->flags & EDGE_FALLTHRU);\n-       last_edge = last_edge->succ_next)\n-    continue;\n-\n-  if (last_edge\n-      && last_edge->dest != EXIT_BLOCK_PTR\n-      && (REORDER_BLOCK_FLAGS (last_edge->dest)\n-\t  & REORDER_BLOCK_VISITED))\n-    {\n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file,\n-\t\t \"     end of chain jump from block %d to block %d\\n\",\n-\t\t db->index, last_edge->dest->index);\n-\n-      REORDER_BLOCK_ADD_JUMP (db) = last_edge->dest;\n-    }\n-\n-  dbh_insn = skip_insns_between_block (db, REORDER_SKIP_BEFORE);\n-  cebe_insn = skip_insns_between_block (ceb, REORDER_SKIP_AFTER);\n-  dbe_insn = skip_insns_between_block (db, REORDER_SKIP_AFTER);\n-\n-  /* Leave behind any lexical block markers.  */\n-  if (debug_info_level > DINFO_LEVEL_TERSE\n-      && ceb->index + 1 < db->index)\n-    {\n-      rtx insn, last_insn = get_last_insn ();\n-      insn = NEXT_INSN (ceb->end);\n-      if (! insn)\n-\tinsn = REORDER_BLOCK_OLD_END (ceb);\n-\n-      if (NEXT_INSN (cebe_insn) == 0)\n-\t  set_last_insn (cebe_insn);\n-      for (; insn && insn != db->head/*dbh_insn*/;\n-\t   insn = NEXT_INSN (insn))\n-\t{\n-\t  if (GET_CODE (insn) == NOTE\n-\t      && (NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_BEG))\n-\t    {\n-\t      cebe_insn = emit_note_after (NOTE_INSN_BLOCK_BEG, cebe_insn);\n-\t      delete_insn (insn);\n-\t    }\n-\t  if (GET_CODE (insn) == NOTE\n-\t      && (NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_END))\n-\t    {\n-\t      cebe_insn = emit_note_after (NOTE_INSN_BLOCK_END, cebe_insn);\n-\t      delete_insn (insn);\n-\t    }      \n-\t}\n-      set_last_insn (last_insn);\n-    }\n-\n-  /* Rechain predicted block.  */\n-  NEXT_INSN (cebe_insn) = dbh_insn;\n-  PREV_INSN (dbh_insn) = cebe_insn;\n-\n-  REORDER_BLOCK_OLD_END (db) = NEXT_INSN (dbe_insn);\n-  if (db->index != n_basic_blocks - 1)\n-    NEXT_INSN (dbe_insn) = 0;\n-\n-  return db;\n-}\n-\n-\n-/* Reorder blocks starting at block B.  */\n-\n-static void\n-make_reorder_chain (bb)\n-     basic_block bb;\n-{\n-  edge e;\n-  basic_block visited_edge = NULL;\n-  rtx block_end;\n-  int probability;\n-\n-  if (bb == EXIT_BLOCK_PTR)\n-    return;\n-\n-  /* Find the most probable block.  */\n-  e = bb->succ;\n-  block_end = bb->end;\n-  if (GET_CODE (block_end) == JUMP_INSN && condjump_p (block_end))\n-    {\n-      rtx note = find_reg_note (block_end, REG_BR_PROB, 0);\n-\n-      if (note) \n-\tprobability = XINT (XEXP (note, 0), 0);\n-      else\n-\tprobability = 0;\n-\n-      if (probability >= REG_BR_PROB_BASE / 2)\n-\te = bb->succ->succ_next;\n-    }\n-\n-  /* Add chosen successor to chain and recurse on it.  */\n-  if (e && e->dest != EXIT_BLOCK_PTR\n-      && e->dest != e->src\n-      && (! (REORDER_BLOCK_FLAGS (e->dest) & REORDER_BLOCK_VISITED)\n-\t  || (REORDER_BLOCK_FLAGS (e->dest) == REORDER_BLOCK_HEAD)))\n-    {\n-      if (! (REORDER_BLOCK_FLAGS (bb) & REORDER_BLOCK_VISITED))\n-\t{\n-\t  REORDER_BLOCK_FLAGS (bb) |= REORDER_BLOCK_HEAD;\n-\t  REORDER_BLOCK_INDEX (bb) = reorder_index++;\n-\t  REORDER_BLOCK_FLAGS (bb) |= REORDER_BLOCK_VISITED;\n-\t}\n-\n-      if (REORDER_BLOCK_FLAGS (e->dest) & REORDER_BLOCK_VISITED)\n-\tREORDER_BLOCK_FLAGS (e->dest) &= ~REORDER_BLOCK_HEAD;\n-\t\n-      REORDER_BLOCK_SUCC (bb) = e;\n-\n-      visited_edge = e->dest;\n-\n-      reorder_last_visited = chain_reorder_blocks (e, bb);\n-\n-      if (e->dest\n-\t  && ! (REORDER_BLOCK_FLAGS (e->dest)\n-\t\t& REORDER_BLOCK_VISITED))\n-\tmake_reorder_chain (e->dest);\n-    }\n-  else\n-    {\n-      if (! (REORDER_BLOCK_FLAGS (bb) & REORDER_BLOCK_VISITED))\n-\t{\n-\t  REORDER_BLOCK_INDEX (bb) = reorder_index++;\n-\t  REORDER_BLOCK_FLAGS (bb) |= REORDER_BLOCK_VISITED;\n-\t}\n-    }\n-\n-  /* Recurse on the successors.  */\n-  for (e = bb->succ; e; e = e->succ_next)\n-    {\n-      if (e->dest && e->dest == EXIT_BLOCK_PTR)\n-\tcontinue;\n-\n-      if (e->dest\n-\t  && e->dest != e->src\n-\t  && e->dest != visited_edge\n-\t  && ! (REORDER_BLOCK_FLAGS (e->dest)\n-\t\t& REORDER_BLOCK_VISITED))\n-\t{\n-\t  reorder_last_visited\n-\t    = chain_reorder_blocks (e, reorder_last_visited);\n-\t  make_reorder_chain (e->dest);\n-\t}\n-    }\n-}\n-\n-\n-/* Fixup jumps and labels after reordering basic blocks.  */ \n-\n-static void\n-fixup_reorder_chain ()\n-{\n-  int i, j;\n-  rtx insn;\n-\n-  /* Set the new last insn.  */\n-  for (i = 0;\n-       i < n_basic_blocks - 1\n-\t && REORDER_BLOCK_INDEX (BASIC_BLOCK (i)) != n_basic_blocks;\n-       i++)\n-    continue;\n-\n-  for (insn = BASIC_BLOCK (i)->head;\n-       NEXT_INSN (insn) != 0;\n-       insn = NEXT_INSN (insn))\n-    continue;\n-\n-  set_last_insn (insn);\n-\n-  /* Add jumps and labels to fixup blocks.  */\n-  for (i = 0; i < n_basic_blocks - 1; i++)\n-    {\n-      basic_block bbi = BASIC_BLOCK (i);\n-      if (REORDER_BLOCK_ADD_JUMP (bbi))\n-\t{\n-\t  rtx label_insn, jump_insn, barrier_insn;\n-\n-\t  if (GET_CODE (REORDER_BLOCK_ADD_JUMP (bbi)->head)\n-\t      == CODE_LABEL)\n-\t    label_insn  = REORDER_BLOCK_ADD_JUMP (bbi)->head;\n-\t  else\n-\t    {\n-\t      rtx new_label = gen_label_rtx ();\n-\t      label_insn = emit_label_before (new_label,\n-\t\t\t      REORDER_BLOCK_ADD_JUMP (bbi)->head);\n-\t    }\n-\t  REORDER_BLOCK_ADD_JUMP (bbi)->head = label_insn;\t \n-\n-\t  jump_insn = emit_jump_insn_after (gen_jump (label_insn),\n-\t\t\t\t\t    bbi->end);\n-\t  JUMP_LABEL (jump_insn) = label_insn;\n-\t  ++LABEL_NUSES (label_insn);\n-\t  barrier_insn = emit_barrier_after (jump_insn);\n-\t  if (GET_CODE (bbi->end) != JUMP_INSN)\n-\t    bbi->end = jump_insn;\n-\t  /* Add block for jump.  Typically this is when a then is not\n-\t     predicted and we are jumping to the moved then block.  */\n-\t  else\t\n-\t    {\n-\t      basic_block nb;\n-\n-\t      VARRAY_GROW (basic_block_info, ++n_basic_blocks);\n-\t      create_basic_block (n_basic_blocks - 1, jump_insn,\n-\t\t\t\t  jump_insn, NULL);\n-\t      nb = BASIC_BLOCK (n_basic_blocks - 1);\n-\t      nb->global_live_at_start\n-\t\t= OBSTACK_ALLOC_REG_SET (function_obstack);\n-\t      nb->global_live_at_end\n-\t\t= OBSTACK_ALLOC_REG_SET (function_obstack);\n-\n-\t      COPY_REG_SET (nb->global_live_at_start,\n-\t\t\t    bbi->global_live_at_start);\n-\t      COPY_REG_SET (nb->global_live_at_end,\n-\t\t\t    bbi->global_live_at_start);\n-\t      BASIC_BLOCK (nb->index)->local_set = 0;\n-\n-\t      nb->aux = xcalloc (1, sizeof (struct reorder_block_def));\n-\t      REORDER_BLOCK_INDEX (BASIC_BLOCK (n_basic_blocks - 1))\n-\t\t= REORDER_BLOCK_INDEX (bbi) + 1;\n-\t      /* Relink to new block.  */\n-\t      nb->succ = bbi->succ;\n-\t      nb->succ->src = nb;\n-\n-\t      make_edge (NULL, bbi, nb, 0);\n-\t      bbi->succ->succ_next\n-\t\t= bbi->succ->succ_next->succ_next;\n-\t      nb->succ->succ_next = 0;\n-\t      /* Fix reorder block index to reflect new block.  */\n-\t      for (j = 0; j < n_basic_blocks - 1; j++)\n-\t\t{\n-\t\t  basic_block bbj = BASIC_BLOCK (j);\n-\t\t  if (REORDER_BLOCK_INDEX (bbj)\n-\t\t      >= REORDER_BLOCK_INDEX (bbi) + 1)\n-\t\t    REORDER_BLOCK_INDEX (bbj)++;\n-\t\t}\n-\t    }\n-\t}\n-    }\n-}\n-\n-\n-/* Reorder basic blocks.  */\n-\n-void\n-reorder_basic_blocks ()\n-{\n-  int i, j;\n-  struct loops loops_info;\n-  int num_loops;\n-  rtx last_insn;\n-\n-  if (profile_arc_flag)\n-    return;\n-\n-  if (n_basic_blocks <= 1)\n-    return;\n-\n-  /* Exception edges are not currently handled.  */\n-  for (i = 0; i < n_basic_blocks; i++)\n-    {\n-      edge e;\n-\n-      for (e = BASIC_BLOCK (i)->succ; e && ! (e->flags & EDGE_EH);\n-\t   e = e->succ_next)\n-\tcontinue;\n-\n-      if (e && (e->flags & EDGE_EH))\n-\treturn;\n-    }\n-\n-  reorder_index = 0;\n-\n-  /* Find natural loops using the CFG.  */\n-  num_loops = flow_loops_find (&loops_info);\n-\n-  /* Dump loop information.  */\n-  flow_loops_dump (&loops_info, rtl_dump_file, 0);\n-\n-  /* Estimate using heuristics if no profiling info is available.  */\n-  if (! flag_branch_probabilities)\n-    estimate_probability (&loops_info);\n-\n-  reorder_last_visited = BASIC_BLOCK (0);\n-\n-  for (i = 0; i < n_basic_blocks; i++)\n-    {\n-      BASIC_BLOCK (i)->aux = xcalloc (1, sizeof (struct reorder_block_def));\n-    }\n-      \n-  last_insn\n-    = NEXT_INSN (skip_insns_between_block (BASIC_BLOCK (n_basic_blocks - 1),\n-\t\t\t\t\t   REORDER_SKIP_AFTER));\n-\n-  make_reorder_chain (BASIC_BLOCK (0));\n-\n-  fixup_reorder_chain ();\n-\n-#ifdef ENABLE_CHECKING\n-    {\n-      rtx insn, last_insn;\n-      last_insn = get_insns ();\n-      for (insn = NEXT_INSN (get_insns ());\n-\t   insn && PREV_INSN (insn) == last_insn\n-\t     && NEXT_INSN (PREV_INSN (insn)) == insn;\n-\t   last_insn = insn,\n-\t     insn = NEXT_INSN (insn))\n-\tcontinue;\n-\n-      if (insn)\n-\t{\n-\t  if (rtl_dump_file)\n-\t    fprintf (rtl_dump_file, \"insn chaining error at %d\\n\",\n-\t\t     INSN_UID (last_insn));\n-\t  abort();\n-\t}\n-    }\n-#endif\n-\n-  /* Put basic_block_info in new order.  */\n-  for (i = 0; i < n_basic_blocks - 1; i++)\n-    {\n-      for (j = i; i != REORDER_BLOCK_INDEX (BASIC_BLOCK (j)); j++)\n-\tcontinue;\n-\n-      if (REORDER_BLOCK_INDEX (BASIC_BLOCK (j)) == i\n-\t  && i != j)\n-\t{\n-\t  basic_block tempbb;\n-\t  int temprbi;\n-\t  int rbi = REORDER_BLOCK_INDEX (BASIC_BLOCK (j));\n-\n-\t  temprbi = BASIC_BLOCK (rbi)->index;\n-\t  BASIC_BLOCK (rbi)->index = BASIC_BLOCK (j)->index;\n-\t  BASIC_BLOCK (j)->index = temprbi;\n-\t  tempbb = BASIC_BLOCK (rbi);\n-\t  BASIC_BLOCK (rbi) = BASIC_BLOCK (j);\n-\t  BASIC_BLOCK (j) = tempbb;\n-\t}\n-    }\n-     \n-    {\n-      rtx xafter = skip_insns_between_block (BASIC_BLOCK (n_basic_blocks - 1),\n-\t\t\t\t\t     REORDER_SKIP_AFTER);\n-      if (xafter)\n-\tNEXT_INSN (xafter) = last_insn;\n-      else\n-\tabort();\n-    }\n-\n-#ifdef ENABLE_CHECKING\n-  verify_flow_info ();\n-#endif\n-\n-  for (i = 0; i < n_basic_blocks - 1; i++)\n-    {\n-      free (BASIC_BLOCK (i)->aux);\n-    }\n-\n-  /* Free loop information.  */\n-  flow_loops_free (&loops_info);\n-}\n-\n-\n /* Clear LOG_LINKS fields of insns in a chain.  */\n void\n clear_log_links (insns)"}]}