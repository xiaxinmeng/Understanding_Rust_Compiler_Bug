{"sha": "ac7d724dc0ecc1ea34daae88f41f9b3870cfbc0f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWM3ZDcyNGRjMGVjYzFlYTM0ZGFhZTg4ZjQxZjliMzg3MGNmYmMwZg==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2013-04-11T09:35:46Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-11T09:35:46Z"}, "message": "sem_ch5.adb: remove spurious warning from non-empty loop.\n\n2013-04-11  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch5.adb: remove spurious warning from non-empty loop.\n\t* sem_ch8.adb (Enclosing_Instance): Make public to other routines\n\tin the package, in order to suppress redundant semantic checks\n\ton subprogram renamings in nested instantiations.\n\nFrom-SVN: r197746", "tree": {"sha": "f77fb6f1133b605a7edcd019d55978c659a88032", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f77fb6f1133b605a7edcd019d55978c659a88032"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ac7d724dc0ecc1ea34daae88f41f9b3870cfbc0f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac7d724dc0ecc1ea34daae88f41f9b3870cfbc0f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac7d724dc0ecc1ea34daae88f41f9b3870cfbc0f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac7d724dc0ecc1ea34daae88f41f9b3870cfbc0f/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8fde064e1ac2202e45e3259304b718fcfff117fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fde064e1ac2202e45e3259304b718fcfff117fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8fde064e1ac2202e45e3259304b718fcfff117fe"}], "stats": {"total": 522, "additions": 228, "deletions": 294}, "files": [{"sha": "a9c5133eb8f283c75f8ef46c3983db1ccaa71da0", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac7d724dc0ecc1ea34daae88f41f9b3870cfbc0f/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac7d724dc0ecc1ea34daae88f41f9b3870cfbc0f/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=ac7d724dc0ecc1ea34daae88f41f9b3870cfbc0f", "patch": "@@ -1,3 +1,10 @@\n+2013-04-11  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch5.adb: remove spurious warning from non-empty loop.\n+\t* sem_ch8.adb (Enclosing_Instance): Make public to other routines\n+\tin the package, in order to suppress redundant semantic checks\n+\ton subprogram renamings in nested instantiations.\n+\n 2013-04-11  Robert Dewar  <dewar@adacore.com>\n \n \t* errout.ads: Minor reformatting."}, {"sha": "d098609d5c56e8598e4e0711130111e3b896af30", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 57, "deletions": 66, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac7d724dc0ecc1ea34daae88f41f9b3870cfbc0f/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac7d724dc0ecc1ea34daae88f41f9b3870cfbc0f/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=ac7d724dc0ecc1ea34daae88f41f9b3870cfbc0f", "patch": "@@ -141,13 +141,13 @@ package body Sem_Ch5 is\n                --  directly.\n \n                elsif (Is_Prival (Ent)\n-                        and then\n-                          (Ekind (Current_Scope) = E_Function\n-                             or else Ekind (Enclosing_Dynamic_Scope\n-                                             (Current_Scope)) = E_Function))\n+                       and then\n+                         (Ekind (Current_Scope) = E_Function\n+                           or else Ekind (Enclosing_Dynamic_Scope\n+                                            (Current_Scope)) = E_Function))\n                    or else\n                      (Ekind (Ent) = E_Component\n-                        and then Is_Protected_Type (Scope (Ent)))\n+                       and then Is_Protected_Type (Scope (Ent)))\n                then\n                   Error_Msg_N\n                     (\"protected function cannot modify protected object\", N);\n@@ -222,16 +222,15 @@ package body Sem_Ch5 is\n \n          if Is_Entity_Name (Opnd)\n            and then (Ekind (Entity (Opnd)) = E_Out_Parameter\n-                      or else Ekind (Entity (Opnd)) =\n-                           E_In_Out_Parameter\n-                      or else Ekind (Entity (Opnd)) =\n-                           E_Generic_In_Out_Parameter\n+                      or else Ekind_In (Entity (Opnd),\n+                                        E_In_Out_Parameter,\n+                                        E_Generic_In_Out_Parameter)\n                       or else\n                         (Ekind (Entity (Opnd)) = E_Variable\n                           and then Nkind (Parent (Entity (Opnd))) =\n-                             N_Object_Renaming_Declaration\n+                                            N_Object_Renaming_Declaration\n                           and then Nkind (Parent (Parent (Entity (Opnd)))) =\n-                             N_Accept_Statement))\n+                                            N_Accept_Statement))\n          then\n             Opnd_Type := Get_Actual_Subtype (Opnd);\n \n@@ -394,23 +393,23 @@ package body Sem_Ch5 is\n                end loop;\n \n                if (Nkind (Ent) = N_Attribute_Reference\n-                     and then Attribute_Name (Ent) = Name_Priority)\n+                    and then Attribute_Name (Ent) = Name_Priority)\n \n                   --  Renamings of the attribute Priority applied to protected\n                   --  objects have been previously expanded into calls to the\n                   --  Get_Ceiling run-time subprogram.\n \n                  or else\n                   (Nkind (Ent) = N_Function_Call\n-                     and then (Entity (Name (Ent)) = RTE (RE_Get_Ceiling)\n-                                or else\n-                               Entity (Name (Ent)) = RTE (RO_PE_Get_Ceiling)))\n+                    and then (Entity (Name (Ent)) = RTE (RE_Get_Ceiling)\n+                               or else\n+                              Entity (Name (Ent)) = RTE (RO_PE_Get_Ceiling)))\n                then\n                   --  The enclosing subprogram cannot be a protected function\n \n                   S := Current_Scope;\n                   while not (Is_Subprogram (S)\n-                               and then Convention (S) = Convention_Protected)\n+                              and then Convention (S) = Convention_Protected)\n                      and then S /= Standard_Standard\n                   loop\n                      S := Scope (S);\n@@ -583,8 +582,8 @@ package body Sem_Ch5 is\n             Propagate_Tag (Lhs, Rhs);\n \n          elsif Nkind (Rhs) = N_Function_Call\n-              and then Is_Entity_Name (Name (Rhs))\n-              and then Is_Abstract_Subprogram (Entity (Name (Rhs)))\n+           and then Is_Entity_Name (Name (Rhs))\n+           and then Is_Abstract_Subprogram (Entity (Name (Rhs)))\n          then\n             Error_Msg_N\n               (\"call to abstract function must be dispatching\", Name (Rhs));\n@@ -607,9 +606,7 @@ package body Sem_Ch5 is\n       --  as well to anonymous access-to-subprogram types that are component\n       --  subtypes or formal parameters.\n \n-      if Ada_Version >= Ada_2005\n-        and then Is_Access_Type (T1)\n-      then\n+      if Ada_Version >= Ada_2005 and then Is_Access_Type (T1) then\n          if Is_Local_Anonymous_Access (T1)\n            or else Ekind (T2) = E_Anonymous_Access_Subprogram_Type\n \n@@ -665,12 +662,10 @@ package body Sem_Ch5 is\n       --  assignment within the block.\n \n       elsif Is_Array_Type (T1)\n-        and then\n-          (Nkind (Rhs) /= N_Type_Conversion\n-            or else Is_Constrained (Etype (Rhs)))\n-        and then\n-          (Nkind (Rhs) /= N_Function_Call\n-            or else Nkind (N) /= N_Block_Statement)\n+        and then (Nkind (Rhs) /= N_Type_Conversion\n+                   or else Is_Constrained (Etype (Rhs)))\n+        and then (Nkind (Rhs) /= N_Function_Call\n+                   or else Nkind (N) /= N_Block_Statement)\n       then\n          --  Assignment verifies that the length of the Lsh and Rhs are equal,\n          --  but of course the indexes do not have to match. If the right-hand\n@@ -1172,7 +1167,7 @@ package body Sem_Ch5 is\n \n       elsif Ada_Version = Ada_83\n         and then (Is_Generic_Type (Exp_Btype)\n-                    or else Is_Generic_Type (Root_Type (Exp_Btype)))\n+                   or else Is_Generic_Type (Root_Type (Exp_Btype)))\n       then\n          Error_Msg_N\n            (\"(Ada 83) case expression cannot be of a generic type\", Exp);\n@@ -1198,9 +1193,7 @@ package body Sem_Ch5 is\n       --  A case statement with a single OTHERS alternative is not allowed\n       --  in SPARK.\n \n-      if Others_Present\n-        and then List_Length (Alternatives (N)) = 1\n-      then\n+      if Others_Present and then List_Length (Alternatives (N)) = 1 then\n          Check_SPARK_Restriction\n            (\"OTHERS as unique case alternative is not allowed\", N);\n       end if;\n@@ -1297,9 +1290,7 @@ package body Sem_Ch5 is\n          Scope_Id := Scope_Stack.Table (J).Entity;\n          Kind := Ekind (Scope_Id);\n \n-         if Kind = E_Loop\n-           and then (No (Target) or else Scope_Id = U_Name)\n-         then\n+         if Kind = E_Loop and then (No (Target) or else Scope_Id = U_Name) then\n             Set_Has_Exit (Scope_Id);\n             exit;\n \n@@ -1423,9 +1414,7 @@ package body Sem_Ch5 is\n          Scope_Id := Scope_Stack.Table (J).Entity;\n \n          if Label_Scope = Scope_Id\n-           or else (Ekind (Scope_Id) /= E_Block\n-                     and then Ekind (Scope_Id) /= E_Loop\n-                     and then Ekind (Scope_Id) /= E_Return_Statement)\n+           or else not Ekind_In (Scope_Id, E_Block, E_Loop, E_Return_Statement)\n          then\n             if Scope_Id /= Label_Scope then\n                Error_Msg_N\n@@ -1447,9 +1436,9 @@ package body Sem_Ch5 is\n \n    --  The expander has circuitry to completely delete code that it can tell\n    --  will not be executed (as a result of compile time known conditions). In\n-   --  the analyzer, we ensure that code that will be deleted in this manner is\n-   --  analyzed but not expanded. This is obviously more efficient, but more\n-   --  significantly, difficulties arise if code is expanded and then\n+   --  the analyzer, we ensure that code that will be deleted in this manner\n+   --  is analyzed but not expanded. This is obviously more efficient, but\n+   --  more significantly, difficulties arise if code is expanded and then\n    --  eliminated (e.g. exception table entries disappear). Similarly, itypes\n    --  generated in deleted code must be frozen from start, because the nodes\n    --  on which they depend will not be available at the freeze point.\n@@ -2161,15 +2150,11 @@ package body Sem_Ch5 is\n          --  Propagate staticness to loop range itself, in case the\n          --  corresponding subtype is static.\n \n-         if New_Lo /= Lo\n-           and then Is_Static_Expression (New_Lo)\n-         then\n+         if New_Lo /= Lo and then Is_Static_Expression (New_Lo) then\n             Rewrite (Low_Bound (R), New_Copy (New_Lo));\n          end if;\n \n-         if New_Hi /= Hi\n-           and then Is_Static_Expression (New_Hi)\n-         then\n+         if New_Hi /= Hi and then Is_Static_Expression (New_Hi) then\n             Rewrite (High_Bound (R), New_Copy (New_Hi));\n          end if;\n       end Process_Bounds;\n@@ -2238,9 +2223,8 @@ package body Sem_Ch5 is\n          --  new iterator form.\n \n          if Nkind (DS_Copy) = N_Function_Call\n-           or else\n-             (Is_Entity_Name (DS_Copy)\n-               and then not Is_Type (Entity (DS_Copy)))\n+           or else (Is_Entity_Name (DS_Copy)\n+                     and then not Is_Type (Entity (DS_Copy)))\n          then\n             --  This is an iterator specification. Rewrite it as such and\n             --  analyze it to capture function calls that may require\n@@ -2351,7 +2335,7 @@ package body Sem_Ch5 is\n              and then Is_Itype (Etype (Id))\n              and then Nkind (Parent (Loop_Nod)) = N_Expression_With_Actions\n              and then Nkind (Original_Node (Parent (Loop_Nod))) =\n-                        N_Quantified_Expression)\n+                                                   N_Quantified_Expression)\n       then\n          Set_Etype (Id, Etype (DS));\n       end if;\n@@ -2395,9 +2379,8 @@ package body Sem_Ch5 is\n                --  instance, since in practice they tend to be dubious in these\n                --  cases since they can result from intended parametrization.\n \n-               if not Inside_A_Generic\n-                 and then not In_Instance\n-               then\n+               if not Inside_A_Generic and then not In_Instance then\n+\n                   --  Specialize msg if invalid values could make the loop\n                   --  non-null after all.\n \n@@ -2436,7 +2419,7 @@ package body Sem_Ch5 is\n \n                --  The other case for a warning is a reverse loop where the\n                --  upper bound is the integer literal zero or one, and the\n-               --  lower bound can be positive.\n+               --  lower bound may exceed this value.\n \n                --  For example, we have\n \n@@ -2449,10 +2432,23 @@ package body Sem_Ch5 is\n               and then Nkind (Original_Node (H)) = N_Integer_Literal\n               and then\n                 (Intval (Original_Node (H)) = Uint_0\n-                  or else Intval (Original_Node (H)) = Uint_1)\n+                  or else\n+                 Intval (Original_Node (H)) = Uint_1)\n             then\n-               Error_Msg_N (\"??loop range may be null\", DS);\n-               Error_Msg_N (\"\\??bounds may be wrong way round\", DS);\n+               --  Lower bound may in fact be known and known not to exceed\n+               --  upper bound (e.g. reverse 0 .. 1) and that's OK.\n+\n+               if Compile_Time_Known_Value (L)\n+                 and then Expr_Value (L) <= Expr_Value (H)\n+               then\n+                  null;\n+\n+               --  Otherwise warning is warranted\n+\n+               else\n+                  Error_Msg_N (\"??loop range may be null\", DS);\n+                  Error_Msg_N (\"\\??bounds may be wrong way round\", DS);\n+               end if;\n             end if;\n          end;\n       end if;\n@@ -2839,9 +2835,7 @@ package body Sem_Ch5 is\n       P          : Node_Id;\n \n    begin\n-      if Is_List_Member (N)\n-        and then Comes_From_Source (N)\n-      then\n+      if Is_List_Member (N) and then Comes_From_Source (N) then\n          declare\n             Nxt : Node_Id;\n \n@@ -2993,9 +2987,8 @@ package body Sem_Ch5 is\n \n       Analyze (R_Copy);\n \n-      if Nkind (R_Copy) in N_Subexpr\n-        and then Is_Overloaded (R_Copy)\n-      then\n+      if Nkind (R_Copy) in N_Subexpr and then Is_Overloaded (R_Copy) then\n+\n          --  Apply preference rules for range of predefined integer types, or\n          --  diagnose true ambiguity.\n \n@@ -3037,9 +3030,7 @@ package body Sem_Ch5 is\n \n       --  Subtype mark in iteration scheme\n \n-      if Is_Entity_Name (R_Copy)\n-        and then Is_Type (Entity (R_Copy))\n-      then\n+      if Is_Entity_Name (R_Copy) and then Is_Type (Entity (R_Copy)) then\n          null;\n \n       --  Expression in range, or Ada 2012 iterator"}, {"sha": "214fb11800f682e33e7613de09d21e5b86eb9d3e", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 164, "deletions": 228, "changes": 392, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac7d724dc0ecc1ea34daae88f41f9b3870cfbc0f/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac7d724dc0ecc1ea34daae88f41f9b3870cfbc0f/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=ac7d724dc0ecc1ea34daae88f41f9b3870cfbc0f", "patch": "@@ -450,6 +450,25 @@ package body Sem_Ch8 is\n    --  when compiling a subunit or instantiating a generic body on the fly,\n    --  when it is necessary to save and restore full environments.\n \n+   function Enclosing_Instance return Entity_Id;\n+   --  In an instance nested within another one, several semantic checks are\n+   --  unnecessary because the legality of the nested instance has been checked\n+   --  in the enclosing generic unit. This applies in particular to legality\n+   --  checks on actuals for formal subprograms of the inner instance, which\n+   --  are checked as subprogram renamings, and may be complicated by confusion\n+   --  in private/full views. This function returns the instance enclosing the\n+   --  current one if there is such, else it returns Empty.\n+   --\n+   --  If the renaming determines the entity for the default of a formal\n+   --  subprogram nested within another instance, choose the innermost\n+   --  candidate. This is because if the formal has a box, and we are within\n+   --  an enclosing instance where some candidate interpretations are local\n+   --  to this enclosing instance, we know that the default was properly\n+   --  resolved when analyzing the generic, so we prefer the local\n+   --  candidates to those that are external. This is not always the case\n+   --  but is a reasonable heuristic on the use of nested generics. The\n+   --  proper solution requires a full renaming model.\n+\n    function Has_Implicit_Character_Literal (N : Node_Id) return Boolean;\n    --  Find a type derived from Character or Wide_Character in the prefix of N.\n    --  Used to resolved qualified names whose selector is a character literal.\n@@ -1076,9 +1095,7 @@ package body Sem_Ch8 is\n       then\n          null;\n \n-      elsif Ada_Version >= Ada_2005\n-        and then Nkind (Nam) in N_Has_Entity\n-      then\n+      elsif Ada_Version >= Ada_2005 and then Nkind (Nam) in N_Has_Entity then\n          declare\n             Nam_Decl : Node_Id;\n             Nam_Ent  : Entity_Id;\n@@ -1103,7 +1120,7 @@ package body Sem_Ch8 is\n                --  have a null exclusion or a null-excluding subtype.\n \n                if Is_Formal_Object (Nam_Ent)\n-                    and then In_Generic_Scope (Id)\n+                 and then In_Generic_Scope (Id)\n                then\n                   if not Can_Never_Be_Null (Etype (Nam_Ent)) then\n                      Error_Msg_N\n@@ -1132,10 +1149,10 @@ package body Sem_Ch8 is\n \n                elsif Nkind (Nam_Decl) = N_Object_Declaration\n                  and then In_Instance\n-                 and then Present\n-                   (Corresponding_Generic_Association (Nam_Decl))\n-                 and then Nkind (Expression (Nam_Decl))\n-                   = N_Raise_Constraint_Error\n+                 and then\n+                   Present (Corresponding_Generic_Association (Nam_Decl))\n+                 and then Nkind (Expression (Nam_Decl)) =\n+                                            N_Raise_Constraint_Error\n                then\n                   Error_Msg_N\n                     (\"renamed actual does not exclude `NULL` \"\n@@ -1214,7 +1231,7 @@ package body Sem_Ch8 is\n                     Nkind (Original_Node (Nam)) /= N_Attribute_Reference)\n \n         or else (Nkind (Nam) = N_Type_Conversion\n-                    and then Is_Tagged_Type (Entity (Subtype_Mark (Nam))))\n+                  and then Is_Tagged_Type (Entity (Subtype_Mark (Nam))))\n       then\n          null;\n \n@@ -1385,9 +1402,7 @@ package body Sem_Ch8 is\n \n             begin\n                E := First_Entity (Old_P);\n-               while Present (E)\n-                 and then E /= New_P\n-               loop\n+               while Present (E) and then E /= New_P loop\n                   if Is_Type (E)\n                     and then Nkind (Parent (E)) = N_Subtype_Declaration\n                   then\n@@ -1589,8 +1604,7 @@ package body Sem_Ch8 is\n    begin\n       if (Is_Entity_Name (P) and then Ekind (Entity (P)) = E_Entry_Family)\n         or else (Nkind (P) = N_Selected_Component\n-                   and then\n-                 Ekind (Entity (Selector_Name (P))) = E_Entry_Family)\n+                  and then Ekind (Entity (Selector_Name (P))) = E_Entry_Family)\n       then\n          if Is_Entity_Name (P) then\n             Old_S := Entity (P);\n@@ -1982,13 +1996,11 @@ package body Sem_Ch8 is\n \n          Ren_Formal := First_Formal (Ren);\n          Sub_Formal := First_Formal (Sub);\n-         while Present (Ren_Formal)\n-           and then Present (Sub_Formal)\n-         loop\n+         while Present (Ren_Formal) and then Present (Sub_Formal) loop\n             if Has_Null_Exclusion (Parent (Ren_Formal))\n               and then\n                 not (Has_Null_Exclusion (Parent (Sub_Formal))\n-                       or else Can_Never_Be_Null (Etype (Sub_Formal)))\n+                      or else Can_Never_Be_Null (Etype (Sub_Formal)))\n             then\n                Error_Msg_NE\n                  (\"`NOT NULL` required for parameter &\",\n@@ -2004,9 +2016,8 @@ package body Sem_Ch8 is\n          if Nkind (Parent (Ren)) = N_Function_Specification\n            and then Nkind (Parent (Sub)) = N_Function_Specification\n            and then Has_Null_Exclusion (Parent (Ren))\n-           and then\n-             not (Has_Null_Exclusion (Parent (Sub))\n-                    or else Can_Never_Be_Null (Etype (Sub)))\n+           and then not (Has_Null_Exclusion (Parent (Sub))\n+                          or else Can_Never_Be_Null (Etype (Sub)))\n          then\n             Error_Msg_N\n               (\"return must specify `NOT NULL`\",\n@@ -2081,9 +2092,7 @@ package body Sem_Ch8 is\n          then\n             F_Nam  := First_Entity (Entity (Nam));\n             F_Spec := First_Formal (Formal_Spec);\n-            while Present (F_Nam)\n-              and then Present (F_Spec)\n-            loop\n+            while Present (F_Nam) and then Present (F_Spec) loop\n                if Is_Controlling_Formal (F_Nam)\n                  and then Has_Unknown_Discriminants (Etype (F_Spec))\n                  and then not Is_Class_Wide_Type (Etype (F_Spec))\n@@ -2114,10 +2123,8 @@ package body Sem_Ch8 is\n          if Present (Alias (Subp)) then\n             return Alias (Subp);\n \n-         elsif\n-           Nkind (Unit_Declaration_Node (Subp)) = N_Subprogram_Declaration\n-             and then Present\n-              (Corresponding_Body (Unit_Declaration_Node (Subp)))\n+         elsif Nkind (Unit_Declaration_Node (Subp)) = N_Subprogram_Declaration\n+           and then Present (Corresponding_Body (Unit_Declaration_Node (Subp)))\n          then\n             --  Check if renamed entity is a renaming_as_body\n \n@@ -2167,7 +2174,8 @@ package body Sem_Ch8 is\n          --  this must be treated as a normal attribute reference, to be\n          --  expanded in subsequent instantiations.\n \n-         if Is_Actual and then Is_Abstract_Subprogram (Formal_Spec)\n+         if Is_Actual\n+           and then Is_Abstract_Subprogram (Formal_Spec)\n            and then Full_Expander_Active\n          then\n             declare\n@@ -2382,8 +2390,8 @@ package body Sem_Ch8 is\n \n             pragma Assert\n               (Is_Primitive (Entity (Nam))\n-                 and then\n-                   Is_Abstract_Type (Find_Dispatching_Type (Entity (Nam))));\n+                and then\n+                  Is_Abstract_Type (Find_Dispatching_Type (Entity (Nam))));\n             declare\n                Old_Decl : constant Node_Id :=\n                             Unit_Declaration_Node (Rename_Spec);\n@@ -2490,8 +2498,7 @@ package body Sem_Ch8 is\n                 (Is_Tagged_Type (T)\n                   or else\n                     (Is_Access_Type (T)\n-                      and then\n-                        Is_Tagged_Type (Designated_Type (T))))\n+                      and then Is_Tagged_Type (Designated_Type (T))))\n               and then Scope (Entity (Selector_Name (Nam))) /= T\n             then\n                Analyze_Renamed_Primitive_Operation\n@@ -2506,9 +2513,7 @@ package body Sem_Ch8 is\n                --  This is not allowed for renaming as body if the renamed\n                --  spec is already frozen (see RM 8.5.4(5) for details).\n \n-               if Present (Rename_Spec)\n-                 and then Is_Frozen (Rename_Spec)\n-               then\n+               if Present (Rename_Spec) and then Is_Frozen (Rename_Spec) then\n                   Error_Msg_N\n                     (\"renaming-as-body cannot rename entry as subprogram\", N);\n                   Error_Msg_NE\n@@ -2607,9 +2612,7 @@ package body Sem_Ch8 is\n          --  when performing a null exclusion check between a renaming and a\n          --  renamed subprogram that has been found to be illegal.\n \n-         if Ada_Version >= Ada_2005\n-           and then Entity (Nam) /= Any_Id\n-         then\n+         if Ada_Version >= Ada_2005 and then Entity (Nam) /= Any_Id then\n             Check_Null_Exclusion\n               (Ren => New_S,\n                Sub => Entity (Nam));\n@@ -2710,13 +2713,11 @@ package body Sem_Ch8 is\n \n             if CW_Actual then\n                null;\n-            else\n+            elsif not Is_Actual or else No (Enclosing_Instance) then\n                Check_Mode_Conformant (New_S, Old_S);\n             end if;\n \n-            if Is_Actual\n-              and then Error_Posted (New_S)\n-            then\n+            if Is_Actual and then Error_Posted (New_S) then\n                Error_Msg_NE (\"invalid actual subprogram: & #!\", N, Old_S);\n             end if;\n          end if;\n@@ -2750,13 +2751,12 @@ package body Sem_Ch8 is\n \n             Set_Is_Intrinsic_Subprogram\n               (New_S,\n-                Is_Intrinsic_Subprogram (Old_S)\n-                  and then\n-                    (Chars (Old_S) /= Name_Op_Ne\n-                       or else Ekind (Old_S) = E_Operator\n-                       or else\n-                         Is_Intrinsic_Subprogram\n-                            (Corresponding_Equality (Old_S))));\n+               Is_Intrinsic_Subprogram (Old_S)\n+                 and then\n+                   (Chars (Old_S) /= Name_Op_Ne\n+                     or else Ekind (Old_S) = E_Operator\n+                     or else Is_Intrinsic_Subprogram\n+                               (Corresponding_Equality (Old_S))));\n \n             if Ekind (Alias (New_S)) = E_Operator then\n                Set_Has_Delayed_Freeze (New_S, False);\n@@ -2909,7 +2909,6 @@ package body Sem_Ch8 is\n                F1 := First_Formal (Candidate_Renaming);\n                F2 := First_Formal (New_S);\n                T1 := First_Subtype (Etype (F1));\n-\n                while Present (F1) and then Present (F2) loop\n                   Next_Formal (F1);\n                   Next_Formal (F2);\n@@ -2980,9 +2979,8 @@ package body Sem_Ch8 is\n \n       if Comes_From_Source (N)\n         and then Present (Old_S)\n-        and then\n-          (Nkind (Old_S) = N_Defining_Operator_Symbol\n-            or else Ekind (Old_S) = E_Operator)\n+        and then (Nkind (Old_S) = N_Defining_Operator_Symbol\n+                   or else Ekind (Old_S) = E_Operator)\n         and then Nkind (New_S) = N_Defining_Operator_Symbol\n         and then Chars (Old_S) /= Chars (New_S)\n       then\n@@ -3003,9 +3001,8 @@ package body Sem_Ch8 is\n         and then Comes_From_Source (N)\n         and then Scope (Old_S) /= Standard_Standard\n         and then Warn_On_Redundant_Constructs\n-        and then\n-          (Is_Immediately_Visible (Old_S)\n-            or else Is_Potentially_Use_Visible (Old_S))\n+        and then (Is_Immediately_Visible (Old_S)\n+                   or else Is_Potentially_Use_Visible (Old_S))\n         and then Is_Overloadable (Current_Scope)\n         and then Chars (Current_Scope) /= Chars (Old_S)\n       then\n@@ -3102,9 +3099,7 @@ package body Sem_Ch8 is\n          if Is_Entity_Name (Pack_Name) then\n             Pack := Entity (Pack_Name);\n \n-            if Ekind (Pack) /= E_Package\n-              and then Etype (Pack) /= Any_Type\n-            then\n+            if Ekind (Pack) /= E_Package and then Etype (Pack) /= Any_Type then\n                if Ekind (Pack) = E_Generic_Package then\n                   Error_Msg_N  -- CODEFIX\n                    (\"a generic package is not allowed in a use clause\",\n@@ -3224,14 +3219,12 @@ package body Sem_Ch8 is\n                   function Mentioned (Nam : Node_Id) return Boolean is\n                   begin\n                      return Nkind (Name (Item)) = N_Selected_Component\n-                              and then\n-                            Chars (Prefix (Name (Item))) = Chars (Nam);\n+                       and then Chars (Prefix (Name (Item))) = Chars (Nam);\n                   end Mentioned;\n \n                begin\n                   Pref := Prefix (Id);\n                   Item := First (Context_Items (Parent (N)));\n-\n                   while Present (Item) and then Item /= N loop\n                      if Nkind (Item) = N_With_Clause\n                        and then Limited_Present (Item)\n@@ -3260,9 +3253,7 @@ package body Sem_Ch8 is\n \n    begin\n       if In_Open_Scopes (Pack) then\n-         if Warn_On_Redundant_Constructs\n-           and then Pack = Current_Scope\n-         then\n+         if Warn_On_Redundant_Constructs and then Pack = Current_Scope then\n             Error_Msg_NE -- CODEFIX\n               (\"& is already use-visible within itself?r?\", Pack_Name, Pack);\n          end if;\n@@ -3572,9 +3563,7 @@ package body Sem_Ch8 is\n       Old_S  : Entity_Id;\n \n    begin\n-      if Is_Frozen (Subp)\n-        and then not Has_Completion (Subp)\n-      then\n+      if Is_Frozen (Subp) and then not Has_Completion (Subp) then\n          B_Node :=\n            Build_Renamed_Body\n              (Parent (Declaration_Node (Subp)), Defining_Entity (N));\n@@ -3591,12 +3580,10 @@ package body Sem_Ch8 is\n                Analyze (B_Node);\n             end if;\n \n-            if Is_Intrinsic_Subprogram (Old_S)\n-              and then not In_Instance\n-            then\n+            if Is_Intrinsic_Subprogram (Old_S) and then not In_Instance then\n                Error_Msg_N\n                  (\"subprogram used in renaming_as_body cannot be intrinsic\",\n-                    Name (N));\n+                  Name (N));\n             end if;\n \n          else\n@@ -3629,11 +3616,10 @@ package body Sem_Ch8 is\n       --  for details on their handling.\n \n       elsif Is_Concurrent_Type (Scope (E)) then\n-\n          P := Parent (N);\n          while Present (P)\n            and then not Nkind_In (P, N_Parameter_Specification,\n-                                  N_Component_Declaration)\n+                                     N_Component_Declaration)\n          loop\n             P := Parent (P);\n          end loop;\n@@ -3670,13 +3656,10 @@ package body Sem_Ch8 is\n \n    begin\n       Item := First (Context_Items (Parent (N)));\n-\n-      while Present (Item)\n-        and then Item /= N\n-      loop\n+      while Present (Item) and then Item /= N loop\n          if Nkind (Item) = N_With_Clause\n \n-            --  Protect the frontend against previous critical errors\n+           --  Protect the frontend against previous critical errors\n \n            and then Nkind (Name (Item)) /= N_Selected_Component\n            and then Entity (Name (Item)) = Pack\n@@ -3745,9 +3728,9 @@ package body Sem_Ch8 is\n            (\"renamed unit must be a child unit of generic parent\", Name (N));\n \n       elsif Nkind (N) in N_Generic_Renaming_Declaration\n-         and then  Nkind (Name (N)) = N_Expanded_Name\n-         and then Is_Generic_Instance (Entity (Prefix (Name (N))))\n-         and then Is_Generic_Unit (Old_E)\n+        and then  Nkind (Name (N)) = N_Expanded_Name\n+        and then Is_Generic_Instance (Entity (Prefix (Name (N))))\n+        and then Is_Generic_Unit (Old_E)\n       then\n          Error_Msg_N\n            (\"renamed generic unit must be a library unit\", Name (N));\n@@ -3766,6 +3749,30 @@ package body Sem_Ch8 is\n       end if;\n    end Check_Library_Unit_Renaming;\n \n+   ------------------------\n+   -- Enclosing_Instance --\n+   ------------------------\n+\n+   function Enclosing_Instance return Entity_Id is\n+      S : Entity_Id;\n+\n+   begin\n+      if not Is_Generic_Instance (Current_Scope) then\n+         return Empty;\n+      end if;\n+\n+      S := Scope (Current_Scope);\n+      while S /= Standard_Standard loop\n+         if Is_Generic_Instance (S) then\n+            return S;\n+         end if;\n+\n+         S := Scope (S);\n+      end loop;\n+\n+      return Empty;\n+   end Enclosing_Instance;\n+\n    ---------------\n    -- End_Scope --\n    ---------------\n@@ -3952,16 +3959,14 @@ package body Sem_Ch8 is\n \n                   if Nkind (Id) = N_Defining_Operator_Symbol\n                        and then\n-                         (Is_Primitive_Operator_In_Use\n-                           (Id, First_Formal (Id))\n-                            or else\n-                          (Present (Next_Formal (First_Formal (Id)))\n-                             and then\n-                               Is_Primitive_Operator_In_Use\n-                                 (Id, Next_Formal (First_Formal (Id)))))\n+                         (Is_Primitive_Operator_In_Use (Id, First_Formal (Id))\n+                           or else\n+                             (Present (Next_Formal (First_Formal (Id)))\n+                               and then\n+                                 Is_Primitive_Operator_In_Use\n+                                   (Id, Next_Formal (First_Formal (Id)))))\n                   then\n                      null;\n-\n                   else\n                      Set_Is_Potentially_Use_Visible (Id, False);\n                   end if;\n@@ -4222,10 +4227,10 @@ package body Sem_Ch8 is\n            Nkind (N) = N_Identifier\n              and then\n                (Nkind (Parent (N)) = N_Procedure_Call_Statement\n-                  or else\n-                    (Nkind (Parent (N)) = N_Parameter_Association\n-                       and then N = Explicit_Actual_Parameter (Parent (N))\n-                       and then Nkind (Parent (Parent (N))) =\n+                 or else\n+                   (Nkind (Parent (N)) = N_Parameter_Association\n+                     and then N = Explicit_Actual_Parameter (Parent (N))\n+                     and then Nkind (Parent (Parent (N))) =\n                                           N_Procedure_Call_Statement));\n       end Is_Actual_Parameter;\n \n@@ -4802,9 +4807,7 @@ package body Sem_Ch8 is\n                --  Find current instance\n \n                Inst := Current_Scope;\n-               while Present (Inst)\n-                 and then Inst /= Standard_Standard\n-               loop\n+               while Present (Inst) and then Inst /= Standard_Standard loop\n                   if Is_Generic_Instance (Inst) then\n                      exit;\n                   end if;\n@@ -5202,9 +5205,7 @@ package body Sem_Ch8 is\n       end;\n \n       if No (Id)\n-        and then (Ekind (P_Name) = E_Procedure\n-                    or else\n-                  Ekind (P_Name) = E_Function)\n+        and then Ekind_In (P_Name, E_Procedure, E_Function)\n         and then Is_Generic_Instance (P_Name)\n       then\n          --  Expanded name denotes entity in (instance of) generic subprogram.\n@@ -5463,9 +5464,7 @@ package body Sem_Ch8 is\n \n       --  Ada 2005 (AI-50217): Check usage of entities in limited withed units\n \n-      if Ekind (P_Name) = E_Package\n-        and then From_With_Type (P_Name)\n-      then\n+      if Ekind (P_Name) = E_Package and then From_With_Type (P_Name) then\n          if From_With_Type (Id)\n            or else Is_Type (Id)\n            or else Ekind (Id) = E_Package\n@@ -5481,11 +5480,11 @@ package body Sem_Ch8 is\n \n       if Is_Task_Type (P_Name)\n         and then ((Ekind (Id) = E_Entry\n-                     and then Nkind (Parent (N)) /= N_Attribute_Reference)\n+                    and then Nkind (Parent (N)) /= N_Attribute_Reference)\n                    or else\n-                    (Ekind (Id) = E_Entry_Family\n-                      and then\n-                        Nkind (Parent (Parent (N))) /= N_Attribute_Reference))\n+                     (Ekind (Id) = E_Entry_Family\n+                       and then\n+                         Nkind (Parent (Parent (N))) /= N_Attribute_Reference))\n       then\n          --  If both the task type and the entry are in scope, this may still\n          --  be the expanded name of an entry formal.\n@@ -5538,18 +5537,15 @@ package body Sem_Ch8 is\n       if Ekind (Id) = E_Void then\n          Premature_Usage (N);\n \n-      elsif Is_Overloadable (Id)\n-        and then Present (Homonym (Id))\n-      then\n+      elsif Is_Overloadable (Id) and then Present (Homonym (Id)) then\n          declare\n             H : Entity_Id := Homonym (Id);\n \n          begin\n             while Present (H) loop\n                if Scope (H) = Scope (Id)\n-                 and then\n-                   (not Is_Hidden (H)\n-                      or else Is_Immediately_Visible (H))\n+                 and then (not Is_Hidden (H)\n+                            or else Is_Immediately_Visible (H))\n                then\n                   Collect_Interps (N);\n                   exit;\n@@ -5618,17 +5614,6 @@ package body Sem_Ch8 is\n       Old_S : Entity_Id;\n       Inst  : Entity_Id;\n \n-      function Enclosing_Instance return Entity_Id;\n-      --  If the renaming determines the entity for the default of a formal\n-      --  subprogram nested within another instance, choose the innermost\n-      --  candidate. This is because if the formal has a box, and we are within\n-      --  an enclosing instance where some candidate interpretations are local\n-      --  to this enclosing instance, we know that the default was properly\n-      --  resolved when analyzing the generic, so we prefer the local\n-      --  candidates to those that are external. This is not always the case\n-      --  but is a reasonable heuristic on the use of nested generics. The\n-      --  proper solution requires a full renaming model.\n-\n       function Is_Visible_Operation (Op : Entity_Id) return Boolean;\n       --  If the renamed entity is an implicit operator, check whether it is\n       --  visible because its operand type is properly visible. This check\n@@ -5644,32 +5629,6 @@ package body Sem_Ch8 is\n       --  Determine whether a candidate subprogram is defined within the\n       --  enclosing instance. If yes, it has precedence over outer candidates.\n \n-      ------------------------\n-      -- Enclosing_Instance --\n-      ------------------------\n-\n-      function Enclosing_Instance return Entity_Id is\n-         S : Entity_Id;\n-\n-      begin\n-         if not Is_Generic_Instance (Current_Scope)\n-           and then not Is_Actual\n-         then\n-            return Empty;\n-         end if;\n-\n-         S := Scope (Current_Scope);\n-         while S /= Standard_Standard loop\n-            if Is_Generic_Instance (S) then\n-               return S;\n-            end if;\n-\n-            S := Scope (S);\n-         end loop;\n-\n-         return Empty;\n-      end Enclosing_Instance;\n-\n       --------------------------\n       -- Is_Visible_Operation --\n       --------------------------\n@@ -5683,9 +5642,8 @@ package body Sem_Ch8 is\n          if Ekind (Op) /= E_Operator\n            or else Scope (Op) /= Standard_Standard\n            or else (In_Instance\n-                      and then\n-                        (not Is_Actual\n-                           or else Present (Enclosing_Instance)))\n+                     and then (not Is_Actual\n+                                or else Present (Enclosing_Instance)))\n          then\n             return True;\n \n@@ -5776,7 +5734,10 @@ package body Sem_Ch8 is\n       Candidate_Renaming := Empty;\n \n       if not Is_Overloaded (Nam) then\n-         if Entity_Matches_Spec (Entity (Nam), New_S) then\n+         if Is_Actual and then Present (Enclosing_Instance) then\n+            Old_S := Entity (Nam);\n+\n+         elsif Entity_Matches_Spec (Entity (Nam), New_S) then\n             Candidate_Renaming := New_S;\n \n             if Is_Visible_Operation (Entity (Nam)) then\n@@ -5786,8 +5747,8 @@ package body Sem_Ch8 is\n          elsif\n            Present (First_Formal (Entity (Nam)))\n              and then Present (First_Formal (New_S))\n-             and then (Base_Type (Etype (First_Formal (Entity (Nam))))\n-                        = Base_Type (Etype (First_Formal (New_S))))\n+             and then (Base_Type (Etype (First_Formal (Entity (Nam)))) =\n+                       Base_Type (Etype (First_Formal (New_S))))\n          then\n             Candidate_Renaming := Entity (Nam);\n          end if;\n@@ -5851,8 +5812,8 @@ package body Sem_Ch8 is\n             elsif\n               Present (First_Formal (It.Nam))\n                 and then Present (First_Formal (New_S))\n-                and then  (Base_Type (Etype (First_Formal (It.Nam)))\n-                            = Base_Type (Etype (First_Formal (New_S))))\n+                and then (Base_Type (Etype (First_Formal (It.Nam))) =\n+                          Base_Type (Etype (First_Formal (New_S))))\n             then\n                Candidate_Renaming := It.Nam;\n             end if;\n@@ -5964,10 +5925,10 @@ package body Sem_Ch8 is\n                       ((RTE_Available (RE_Dispatch_Table_Wrapper)\n                          and then Scope (Selector) =\n                                      RTE (RE_Dispatch_Table_Wrapper))\n-                          or else\n-                       (RTE_Available (RE_No_Dispatch_Table_Wrapper)\n-                         and then Scope (Selector) =\n-                                     RTE (RE_No_Dispatch_Table_Wrapper)))\n+                         or else\n+                           (RTE_Available (RE_No_Dispatch_Table_Wrapper)\n+                             and then Scope (Selector) =\n+                                        RTE (RE_No_Dispatch_Table_Wrapper)))\n                   then\n                      C_Etype := Empty;\n \n@@ -6071,7 +6032,7 @@ package body Sem_Ch8 is\n          elsif Is_Appropriate_For_Entry_Prefix (P_Type)\n            and then not In_Open_Scopes (P_Name)\n            and then (not Is_Concurrent_Type (Etype (P_Name))\n-                       or else not In_Open_Scopes (Etype (P_Name)))\n+                      or else not In_Open_Scopes (Etype (P_Name)))\n          then\n             --  Call to protected operation or entry. Type checking is\n             --  needed on the prefix.\n@@ -6148,9 +6109,9 @@ package body Sem_Ch8 is\n                --  entry, as is P.X; this is an error.\n \n                if Ekind (P_Name) /= E_Function\n-                 and then (not Is_Overloaded (P)\n-                             or else\n-                           Nkind (Parent (N)) = N_Procedure_Call_Statement)\n+                 and then\n+                   (not Is_Overloaded (P)\n+                     or else Nkind (Parent (N)) = N_Procedure_Call_Statement)\n                then\n                   --  Prefix may mention a package that is hidden by a local\n                   --  declaration: let the user know. Scan the full homonym\n@@ -6327,9 +6288,7 @@ package body Sem_Ch8 is\n                      --  Warn_On_Obsolescent_ Feature). Once this issue\n                      --  is cleared in the sources, it can be enabled.\n \n-                     elsif Warn_On_Obsolescent_Feature\n-                       and then False\n-                     then\n+                     elsif Warn_On_Obsolescent_Feature and then False then\n                         Error_Msg_N\n                           (\"applying 'Class to an untagged incomplete type\"\n                            & \" is an obsolescent feature (RM J.11)?r?\", N);\n@@ -6596,9 +6555,7 @@ package body Sem_Ch8 is\n       Priv_Id : Entity_Id := Empty;\n \n    begin\n-      if Ekind (P) = E_Package\n-        and then not In_Open_Scopes (P)\n-      then\n+      if Ekind (P) = E_Package and then not In_Open_Scopes (P) then\n          Priv_Id := First_Private_Entity (P);\n       end if;\n \n@@ -6611,9 +6568,7 @@ package body Sem_Ch8 is\n       end if;\n \n       Id := First_Entity (P);\n-      while Present (Id)\n-        and then Id /= Priv_Id\n-      loop\n+      while Present (Id) and then Id /= Priv_Id loop\n          if Is_Standard_Character_Type (Id) and then Is_Base_Type (Id) then\n \n             --  We replace the node with the literal itself, resolve as a\n@@ -6695,7 +6650,6 @@ package body Sem_Ch8 is\n \n       begin\n          Predef_Op := Current_Entity (Selector_Name (N));\n-\n          while Present (Predef_Op)\n            and then Scope (Predef_Op) /= Standard_Standard\n          loop\n@@ -6760,9 +6714,7 @@ package body Sem_Ch8 is\n    --  Start of processing for Has_Implicit_Operator\n \n    begin\n-      if Ekind (P) = E_Package\n-        and then not In_Open_Scopes (P)\n-      then\n+      if Ekind (P) = E_Package and then not In_Open_Scopes (P) then\n          Priv_Id := First_Private_Entity (P);\n       end if;\n \n@@ -7202,9 +7154,7 @@ package body Sem_Ch8 is\n                   --  of the stack is related to the current compilation.\n \n                   Scop := Current_Scope;\n-                  while Present (Scop)\n-                    and then Scop /= Standard_Standard\n-                  loop\n+                  while Present (Scop) and then Scop /= Standard_Standard loop\n                      if Is_Compilation_Unit (Scop)\n                        and then not Is_Child_Unit (Scop)\n                      then\n@@ -7495,14 +7445,9 @@ package body Sem_Ch8 is\n       --  name resolution on component associations. (see 4717-008). In such a\n       --  case, look for the visible homonym on the chain.\n \n-      if In_Instance\n-        and then Present (Homonym (E))\n-      then\n+      if In_Instance and then Present (Homonym (E)) then\n          E := Homonym (E);\n-\n-         while Present (E)\n-           and then not In_Open_Scopes (Scope (E))\n-         loop\n+         while Present (E) and then not In_Open_Scopes (Scope (E)) loop\n             E := Homonym (E);\n          end loop;\n \n@@ -7609,16 +7554,14 @@ package body Sem_Ch8 is\n          if No (With_Sys)\n            and then\n              (Nkind (The_Unit) = N_Package_Body\n-                or else (Nkind (The_Unit) = N_Subprogram_Body\n-                           and then\n-                             not Acts_As_Spec (Cunit (Current_Sem_Unit))))\n+               or else (Nkind (The_Unit) = N_Subprogram_Body\n+                         and then not Acts_As_Spec (Cunit (Current_Sem_Unit))))\n          then\n             With_Sys := Find_System (Library_Unit (Cunit (Current_Sem_Unit)));\n          end if;\n \n-         if No (With_Sys)\n-           and then Present (N)\n-         then\n+         if No (With_Sys) and then Present (N) then\n+\n             --  If we are compiling a subunit, we need to examine its\n             --  context as well (Current_Sem_Unit is the parent unit);\n \n@@ -7735,8 +7678,9 @@ package body Sem_Ch8 is\n                   else\n                      pragma Assert\n                        (Nkind (Parent (E)) = N_Defining_Program_Unit_Name\n-                          and then\n-                        Nkind (Parent (Parent (E))) = N_Package_Specification);\n+                         and then\n+                           Nkind (Parent (Parent (E))) =\n+                                               N_Package_Specification);\n                      Set_Is_Immediately_Visible (E,\n                        Limited_View_Installed (Parent (Parent (E))));\n                   end if;\n@@ -7746,9 +7690,8 @@ package body Sem_Ch8 is\n \n                Next_Entity (E);\n \n-               if not Full_Vis\n-                 and then Is_Package_Or_Generic_Package (S)\n-               then\n+               if not Full_Vis and then Is_Package_Or_Generic_Package (S) then\n+\n                   --  We are in the visible part of the package scope\n \n                   exit when E = First_Private_Entity (S);\n@@ -7798,8 +7741,7 @@ package body Sem_Ch8 is\n             elsif Is_Hidden_Open_Scope (S) then\n                null;\n \n-            elsif (Ekind (S) = E_Procedure\n-                    or else Ekind (S) = E_Function)\n+            elsif Ekind_In (S, E_Procedure, E_Function)\n               and then Has_Completion (S)\n             then\n                Full_Vis := True;\n@@ -7974,7 +7916,7 @@ package body Sem_Ch8 is\n       Id := First_Entity (P);\n       while Present (Id)\n         and then (Id /= First_Private_Entity (P)\n-                    or else Private_With_OK) -- Ada 2005 (AI-262)\n+                   or else Private_With_OK) -- Ada 2005 (AI-262)\n       loop\n          Prev := Current_Entity (Id);\n          while Present (Prev) loop\n@@ -8042,10 +7984,10 @@ package body Sem_Ch8 is\n             elsif Ekind (Prev) = E_Operator\n               and then Operator_Matches_Spec (Prev, Id)\n               and then In_Open_Scopes\n-               (Scope (Base_Type (Etype (First_Formal (Id)))))\n+                         (Scope (Base_Type (Etype (First_Formal (Id)))))\n               and then (No (Next_Formal (First_Formal (Id)))\n-                         or else Etype (First_Formal (Id))\n-                           = Etype (Next_Formal (First_Formal (Id)))\n+                         or else Etype (First_Formal (Id)) =\n+                                 Etype (Next_Formal (First_Formal (Id)))\n                          or else Chars (Prev) = Name_Op_Expon)\n             then\n                goto Next_Usable_Entity;\n@@ -8074,14 +8016,11 @@ package body Sem_Ch8 is\n          --  On exit, we know entity is not hidden, unless it is private\n \n          if not Is_Hidden (Id)\n-           and then ((not Is_Child_Unit (Id))\n-                       or else Is_Visible_Lib_Unit (Id))\n+           and then ((not Is_Child_Unit (Id)) or else Is_Visible_Lib_Unit (Id))\n          then\n             Set_Is_Potentially_Use_Visible (Id);\n \n-            if Is_Private_Type (Id)\n-              and then Present (Full_View (Id))\n-            then\n+            if Is_Private_Type (Id) and then Present (Full_View (Id)) then\n                Set_Is_Potentially_Use_Visible (Full_View (Id));\n             end if;\n          end if;\n@@ -8252,12 +8191,10 @@ package body Sem_Ch8 is\n       --  a limited view unless we only have a limited view of its enclosing\n       --  package.\n \n-      elsif From_With_Type (T)\n-        and then From_With_Type (Scope (T))\n-      then\n+      elsif From_With_Type (T) and then From_With_Type (Scope (T)) then\n          Error_Msg_N\n            (\"incomplete type from limited view \"\n-             & \"cannot appear in use clause\", Id);\n+            & \"cannot appear in use clause\", Id);\n \n       --  If the subtype mark designates a subtype in a different package,\n       --  we have to check that the parent type is visible, otherwise the\n@@ -8321,18 +8258,18 @@ package body Sem_Ch8 is\n       if Warn_On_Redundant_Constructs\n         and then Is_Known_Used\n \n-         --                     with P;         with P; use P;\n-         --    package P is     package X is    package body X is\n-         --       type T ...       use P.T;\n+        --                     with P;         with P; use P;\n+        --    package P is     package X is    package body X is\n+        --       type T ...       use P.T;\n \n-         --  The compilation unit is the body of X. GNAT first compiles the\n-         --  spec of X, then proceeds to the body. At that point P is marked\n-         --  as use visible. The analysis then reinstalls the spec along with\n-         --  its context. The use clause P.T is now recognized as redundant,\n-         --  but in the wrong context. Do not emit a warning in such cases.\n-         --  Do not emit a warning either if we are in an instance, there is\n-         --  no redundancy between an outer use_clause and one that appears\n-         --  within the generic.\n+        --  The compilation unit is the body of X. GNAT first compiles the\n+        --  spec of X, then proceeds to the body. At that point P is marked\n+        --  as use visible. The analysis then reinstalls the spec along with\n+        --  its context. The use clause P.T is now recognized as redundant,\n+        --  but in the wrong context. Do not emit a warning in such cases.\n+        --  Do not emit a warning either if we are in an instance, there is\n+        --  no redundancy between an outer use_clause and one that appears\n+        --  within the generic.\n \n         and then not Spec_Reloaded_For_Body\n         and then not In_Instance\n@@ -8386,7 +8323,6 @@ package body Sem_Ch8 is\n                        and then\n                      Nkind (Parent (Clause2)) = N_Compilation_Unit\n                   then\n-\n                      --  If the unit is a subprogram body that acts as spec,\n                      --  the context clause is shared with the constructed\n                      --  subprogram spec. Clearly there is no redundancy."}]}