{"sha": "57807c317869610e07a85bf8bf95747638230ed7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTc4MDdjMzE3ODY5NjEwZTA3YTg1YmY4YmY5NTc0NzYzODIzMGVkNw==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2004-05-31T22:16:31Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2004-05-31T22:16:31Z"}, "message": "CollationElementIterator.java, [...]: New versions from GNU classpath.\n\n2004-06-01  Michael Koch  <konqueror@gmx.de>\n\n\t* java/text/CollationElementIterator.java,\n\tjava/text/CollationKey.java,\n\tjava/text/RuleBasedCollator.java: New versions from GNU classpath.\n\t* testsuite/libjava.mauve/xfails: Removed all\n\tjava.text.CollationElementIterator tests.\n\nFrom-SVN: r82510", "tree": {"sha": "84eadd76d1df1c8b46bd05dd00699bc802f78611", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/84eadd76d1df1c8b46bd05dd00699bc802f78611"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/57807c317869610e07a85bf8bf95747638230ed7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57807c317869610e07a85bf8bf95747638230ed7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57807c317869610e07a85bf8bf95747638230ed7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57807c317869610e07a85bf8bf95747638230ed7/comments", "author": null, "committer": null, "parents": [{"sha": "f7dbd56c9a1e2605f54a05c2f613cf086f32634b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7dbd56c9a1e2605f54a05c2f613cf086f32634b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7dbd56c9a1e2605f54a05c2f613cf086f32634b"}], "stats": {"total": 1330, "additions": 943, "deletions": 387}, "files": [{"sha": "35592a70db32602b3aed1ca6fb5cbbaa2ccd2a5f", "filename": "libjava/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57807c317869610e07a85bf8bf95747638230ed7/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57807c317869610e07a85bf8bf95747638230ed7/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=57807c317869610e07a85bf8bf95747638230ed7", "patch": "@@ -1,3 +1,11 @@\n+2004-06-01  Michael Koch  <konqueror@gmx.de>\n+\n+\t* java/text/CollationElementIterator.java,\n+\tjava/text/CollationKey.java,\n+\tjava/text/RuleBasedCollator.java: New versions from GNU classpath.\n+\t* testsuite/libjava.mauve/xfails: Removed all\n+\tjava.text.CollationElementIterator tests.\n+\n 2004-06-01  Michael Koch  <konqueror@gmx.de>\n \n \t* java/util/zip/InflaterInputStream.java: Merged more with Classpath"}, {"sha": "a4c21005211870d918504a3fc82373078e5f1b2c", "filename": "libjava/java/text/CollationElementIterator.java", "status": "modified", "additions": 259, "deletions": 10, "changes": 269, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57807c317869610e07a85bf8bf95747638230ed7/libjava%2Fjava%2Ftext%2FCollationElementIterator.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57807c317869610e07a85bf8bf95747638230ed7/libjava%2Fjava%2Ftext%2FCollationElementIterator.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FCollationElementIterator.java?ref=57807c317869610e07a85bf8bf95747638230ed7", "patch": "@@ -38,6 +38,8 @@\n \n package java.text;\n \n+import java.util.Vector;\n+\n /* Written using \"Java Class Libraries\", 2nd edition, plus online\n  * API docs for JDK 1.2 from http://www.javasoft.com.\n  * Status: Believed complete and correct to JDK 1.1.\n@@ -73,14 +75,26 @@\n    */\n   String text;\n \n+  /**\n+   * This is the index into the collation decomposition where we are currently scanning.\n+   */\n+  int index;\n+\n   /**\n    * This is the index into the String where we are currently scanning.\n    */\n   int textIndex;\n \n-  // A piece of lookahead.\n-  boolean lookahead_set;\n-  int lookahead;\n+  /**\n+   * Array containing the collation decomposition of the\n+   * text given to the constructor.\n+   */\n+  private Object[] text_decomposition;\n+\n+  /**\n+   * Array containing the index of the specified block.\n+   */\n+  private int[] text_indexes;\n \n   /**\n    * This method initializes a new instance of <code>CollationElementIterator</code>\n@@ -97,6 +111,35 @@\n     setText (text);    \n   }\n \n+  RuleBasedCollator.CollationElement nextBlock()\n+  {\n+    if (index >= text_decomposition.length)\n+      return null;\n+    \n+    RuleBasedCollator.CollationElement e =\n+      (RuleBasedCollator.CollationElement) text_decomposition[index];\n+    \n+    textIndex = text_indexes[index+1];\n+\n+    index++;\n+\n+    return e;\n+  }\n+\n+  RuleBasedCollator.CollationElement previousBlock()\n+  {\n+    if (index == 0)\n+      return null;\n+    \n+    index--;\n+    RuleBasedCollator.CollationElement e =\n+      (RuleBasedCollator.CollationElement) text_decomposition[index];\n+\n+    textIndex = text_indexes[index+1];\n+    \n+    return e;\n+  }\n+\n   /**\n    * This method returns the collation ordering value of the next character sequence\n    * in the string (it may be an extended character following collation rules).\n@@ -107,10 +150,29 @@\n    */\n   public int next()\n   {\n-    if (textIndex == text.length())\n+    RuleBasedCollator.CollationElement e = nextBlock();\n+\n+    if (e == null)\n       return NULLORDER;\n+    \n+    return e.getValue();\n+  }\n+\n+  /**\n+   * This method returns the collation ordering value of the previous character\n+   * in the string.  This method will return <code>NULLORDER</code> if the\n+   * beginning of the string was reached.\n+   *\n+   * @return The collation ordering value.\n+   */\n+  public int previous()\n+  {\n+    RuleBasedCollator.CollationElement e = previousBlock();\n \n-    return collator.ceiNext (this);\n+    if (e == null)\n+      return NULLORDER;\n+    \n+    return e.getValue();\n   }\n \n   /**\n@@ -133,9 +195,8 @@ public static final int primaryOrder(int order)\n    */\n   public void reset()\n   {\n+    index = 0;\n     textIndex = 0;\n-    lookahead_set = false;\n-    lookahead = 0;\n   }\n \n   /**\n@@ -176,10 +237,152 @@ public static final short tertiaryOrder(int order)\n    */\n   public void setText(String text)\n   {\n+    int idx = 0;\n+    int idx_idx = 0;\n+    int alreadyExpanded = 0;\n+    int idxToMove = 0;\n+\n     this.text = text;\n-    this.textIndex = 0;\n-    this.lookahead_set = false;\n-    this.lookahead = 0;\n+    this.index = 0;\n+\n+    String work_text = text.intern();\n+\n+    Vector v = new Vector();\n+    Vector vi = new Vector();\n+\n+    // Build element collection ordered as they come in \"text\".\n+    while (idx < work_text.length())\n+      {\n+\tString key, key_old;\n+\n+\tObject object = null;\n+\tint p = 1;\n+\t\n+\t// IMPROVE: use a TreeMap with a prefix-ordering rule.\n+\tkey_old = key = null;\n+\tdo\n+\t  {\n+\t    if (object != null)\n+\t      key_old = key;\n+\t    key = work_text.substring (idx, idx+p);\n+\t    object = collator.prefix_tree.get (key);\n+\t    if (object != null && idx < alreadyExpanded)\n+\t      {\n+\t\tRuleBasedCollator.CollationElement prefix = (RuleBasedCollator.CollationElement)object;\n+\t\tif (prefix.expansion != null && \n+\t\t    prefix.expansion.startsWith(work_text.substring(0, idx)))\n+\t\t{\n+\t\t  object = null;\n+\t\t  key = key_old;\n+\t\t}\n+\t      }\n+\t    p++;\n+\t  }\n+\twhile (idx+p <= work_text.length());\n+\t\n+\tif (object == null)\n+\t  key = key_old;\n+\t\n+\tRuleBasedCollator.CollationElement prefix =\n+\t  (RuleBasedCollator.CollationElement) collator.prefix_tree.get (key);\n+\n+\t/*\n+\t * First case: There is no such sequence in the database.\n+\t * We will have to build one from the context.\n+\t */\n+\tif (prefix == null)\n+\t  {\n+\t    /*\n+\t     * We are dealing with sequences in an expansion. They\n+\t     * are treated as accented characters (tertiary order).\n+\t     */\n+\t    if (alreadyExpanded > 0)\n+\t      {\n+\t\tRuleBasedCollator.CollationElement e =\n+\t\t  collator.getDefaultAccentedElement (work_text.charAt (idx));\n+\t\t\n+\t\tv.add (e);\n+\t\tvi.add (new Integer(idx_idx));\n+\t\tidx++;\n+\t\talreadyExpanded--;\n+\t\tif (alreadyExpanded == 0)\n+\t\t  {\n+\t\t    /* There is not any characters left in the expansion set.\n+\t\t     * We can increase the pointer in the source string.\n+\t\t     */\n+\t\t    idx_idx += idxToMove;\n+\t\t    idxToMove = 0; \n+\t\t  }\n+\t\telse\n+\t\t  idx_idx++;\n+\t      }\n+\t    else\n+\t      {\n+\t\t/* This is a normal character. */\n+\t\tRuleBasedCollator.CollationElement e =\n+\t\t  collator.getDefaultElement (work_text.charAt (idx));\n+\t\tInteger i_ref = new Integer(idx_idx);\n+\n+\t\t/* Don't forget to mark it as a special sequence so the\n+\t\t * string can be ordered.\n+\t\t */\n+\t\tv.add (RuleBasedCollator.SPECIAL_UNKNOWN_SEQ);\n+\t\tvi.add (i_ref);\n+\t\tv.add (e);\n+\t\tvi.add (i_ref);\n+\t\tidx_idx++;\n+\t\tidx++;\n+\t      }\n+\t    continue;\n+\t  }\n+ \n+\t/*\n+\t * Second case: Here we have found a matching sequence.\n+\t * Here we have an expansion string prepend it to the \"work text\" and\n+\t * add the corresponding sorting element. We must also mark \n+\t */\n+\tif (prefix.expansion != null)\n+\t  {\n+\t    work_text = prefix.expansion\n+\t      + work_text.substring (idx+prefix.key.length());\n+\t    idx = 0;\n+\t    v.add (prefix);\n+\t    vi.add (new Integer(idx_idx));\n+\t    if (alreadyExpanded == 0)\n+\t      idxToMove = prefix.key.length();\n+\t    alreadyExpanded += prefix.expansion.length()-prefix.key.length();\n+\t  }\n+\telse\n+\t  {\n+\t    /* Third case: the simplest. We have got the prefix and it\n+\t     * has not to be expanded.\n+\t     */\n+\t    v.add (prefix);\n+\t    vi.add (new Integer(idx_idx));\n+\t    idx += prefix.key.length();\n+\t    /* If the sequence is in an expansion, we must decrease the\n+\t     * counter.\n+\t     */\n+\t    if (alreadyExpanded > 0)\n+\t      {\n+\t\talreadyExpanded -= prefix.key.length();\n+\t\tif (alreadyExpanded == 0)\n+\t\t  {\n+\t\t    idx_idx += idxToMove;\n+\t\t    idxToMove = 0;\n+\t\t  }\n+\t      } else\n+\t\tidx_idx += prefix.key.length();\n+\t  }\n+      }\n+    \n+    text_decomposition = v.toArray();\n+    text_indexes = new int[vi.size()+1];\n+    for (int i = 0; i < vi.size(); i++) \n+      {\n+\ttext_indexes[i] = ((Integer)vi.elementAt(i)).intValue();\n+      }\n+    text_indexes[vi.size()] = text.length();\n   }\n \n   /**\n@@ -215,4 +418,50 @@ public int getOffset()\n   {\n     return textIndex;\n   }\n+\n+  /**\n+   * This method sets the iteration index position into the current\n+   * <code>String</code> to the specified value.  This value must not\n+   * be negative and must not be greater than the last index position\n+   * in the <code>String</code>.\n+   *\n+   * @param offset The new iteration index position.\n+   *\n+   * @exception IllegalArgumentException If the new offset is not valid.\n+   */\n+  public void setOffset(int offset)\n+  {\n+    if (offset < 0)\n+      throw new IllegalArgumentException(\"Negative offset: \" + offset);\n+\n+    if (offset > (text.length() - 1))\n+      throw new IllegalArgumentException(\"Offset too large: \" + offset);\n+    \n+    for (index = 0; index < text_decomposition.length; index++)\n+      {\t\n+\tif (offset <= text_indexes[index])\n+\t  break;\n+      }\n+    /*\n+     * As text_indexes[0] == 0, we should not have to take care whether index is\n+     * greater than 0. It is always.\n+     */\n+    if (text_indexes[index] == offset)\n+      textIndex = offset;\n+    else\n+      textIndex = text_indexes[index-1];\n+  }\n+\n+  /**\n+   * This method returns the maximum length of any expansion sequence that\n+   * ends with the specified collation order value.  (Whatever that means).\n+   *\n+   * @param value The collation order value\n+   *\n+   * @param The maximum length of an expansion sequence.\n+   */\n+  public int getMaxExpansion(int value)\n+  {\n+    return 1;\n+  }\n }"}, {"sha": "4e6aca2635dc74e84b385a8c479c368b4ef11e6f", "filename": "libjava/java/text/CollationKey.java", "status": "modified", "additions": 4, "deletions": 24, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57807c317869610e07a85bf8bf95747638230ed7/libjava%2Fjava%2Ftext%2FCollationKey.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57807c317869610e07a85bf8bf95747638230ed7/libjava%2Fjava%2Ftext%2FCollationKey.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FCollationKey.java?ref=57807c317869610e07a85bf8bf95747638230ed7", "patch": "@@ -78,24 +78,13 @@ public final class CollationKey implements Comparable\n   /**\n    * This is the bit value for this key.\n    */\n-  private int[] key;\n+  private byte[] key;\n \n-  CollationKey(Collator collator, CollationElementIterator iter,\n-\t       String originalText, int strength)\n+  CollationKey (Collator collator, String originalText, byte[] key)\n   {\n     this.collator = collator;\n     this.originalText = originalText;\n-\n-    // Compute size of required array.\n-    int size = 0;\n-    while (RuleBasedCollator.next(iter, strength)\n-\t   != CollationElementIterator.NULLORDER)\n-      ++size;\n-\n-    iter.reset();\n-    key = new int[size];\n-    for (int i = 0; i < size; i++)\n-      key[i] = RuleBasedCollator.next(iter, strength);\n+    this.key = key;\n   }\n \n   /**\n@@ -205,15 +194,6 @@ public int hashCode()\n    */\n   public byte[] toByteArray()\n   {\n-    byte[] r = new byte[4 * key.length];\n-    int off = 0;\n-    for (int i = 0; i < key.length; ++i)\n-      {\n-\tr[off++] = (byte) ((key[i] >>> 24) & 255);\n-\tr[off++] = (byte) ((key[i] >>> 16) & 255);\n-\tr[off++] = (byte) ((key[i] >>>  8) & 255);\n-\tr[off++] = (byte) ((key[i]       ) & 255);\n-      }\n-    return r;\n+    return key;\n   }\n }"}, {"sha": "23f238e69a99460fdf7efea8645e9bfffe29b5f2", "filename": "libjava/java/text/RuleBasedCollator.java", "status": "modified", "additions": 672, "deletions": 253, "changes": 925, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57807c317869610e07a85bf8bf95747638230ed7/libjava%2Fjava%2Ftext%2FRuleBasedCollator.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57807c317869610e07a85bf8bf95747638230ed7/libjava%2Fjava%2Ftext%2FRuleBasedCollator.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FRuleBasedCollator.java?ref=57807c317869610e07a85bf8bf95747638230ed7", "patch": "@@ -38,7 +38,7 @@\n package java.text;\n \n import java.util.Enumeration;\n-import java.util.Hashtable;\n+import java.util.HashMap;\n import java.util.Vector;\n \n /* Written using \"Java Class Libraries\", 2nd edition, plus online\n@@ -147,32 +147,104 @@ public class RuleBasedCollator extends Collator\n    * This class describes what rank has a character (or a sequence of characters) \n    * in the lexicographic order. Each element in a rule has a collation element.\n    */\n-  final class CollationElement\n+  final static class CollationElement\n   {\n     String key;\n-    char relation;\n-\n-    CollationElement(String key, char relation)\n+    int primary;\n+    short secondary;\n+    short tertiary;\n+    short equality;\n+    boolean ignore;\n+    String expansion;\n+\n+    CollationElement(String key, int primary, short secondary, short tertiary,\n+\t\t     short equality, String expansion, boolean ignore)\n     {\n       this.key = key;\n-      this.relation = relation;\n+      this.primary = primary;\n+      this.secondary = secondary;\n+      this.tertiary = tertiary;\n+      this.equality = equality;\n+      this.ignore = ignore;\n+      this.expansion = expansion;\n+    }\n+\n+    final int getValue()\n+    {\n+      return (primary << 16) + (secondary << 8) + tertiary;\n     }\n   }\n \n-  // True if we are using French-style accent ordering.\n-  private boolean frenchAccents;\n+  /**\n+   * Basic collation instruction (internal format) to build the series of\n+   * collation elements. It contains an instruction which specifies the new\n+   * state of the generator. The sequence of instruction should not contain\n+   * RESET (it is used by\n+   * {@link #mergeRules(int,java.lang.String,java.util.Vector,java.util.Vector)})\n+   * as a temporary state while merging two sets of instructions.\n+   */\n+  final static class CollationSorter\n+  {\n+    static final int GREATERP = 0;\n+    static final int GREATERS = 1;\n+    static final int GREATERT = 2;\n+    static final int EQUAL = 3;\n+    static final int RESET = 4;\n+    static final int INVERSE_SECONDARY = 5;\n+    \n+    int comparisonType;\n+    String textElement;\n+    int hashText;\n+    int offset;\n+    boolean ignore;\n+\n+    String expansionOrdering;\n+  }\n \n   /**\n    * This the the original rule string.\n    */\n   private String rules;\n \n-  // This maps strings onto collation values.\n-  private Hashtable map;\n-  \n-  // An entry in this hash means that more lookahead is required for\n-  // the prefix string.\n-  private Hashtable prefixes;\n+  /**\n+   * This is the table of collation element values\n+   */\n+  private Object[] ce_table;\n+\n+  /**\n+   * Quick-prefix finder.\n+   */\n+  HashMap prefix_tree;\n+\n+  /**\n+   * This is the value of the last sequence entered into\n+   * <code>ce_table</code>. It is used to compute the\n+   * ordering value of unspecified character.\n+   */\n+  private int last_primary_value;\n+\n+  /**\n+   * This is the value of the last secondary sequence of the\n+   * primary 0, entered into\n+   * <code>ce_table</code>. It is used to compute the\n+   * ordering value of an unspecified accented character.\n+   */\n+  private int last_tertiary_value;\n+\n+  /**\n+   * This variable is true if accents need to be sorted\n+   * in the other direction.\n+   */\n+  private boolean inverseAccentComparison;\n+\n+  /**\n+   * This collation element is special to unknown sequence.\n+   * The JDK uses it to mark and sort the characters which has\n+   * no collation rules.\n+   */\n+  static final CollationElement SPECIAL_UNKNOWN_SEQ = \n+    new CollationElement(\"\", (short) 32767, (short) 0, (short) 0,\n+\t\t\t (short) 0, null, false);\n   \n   /**\n    * This method initializes a new instance of <code>RuleBasedCollator</code>\n@@ -192,128 +264,313 @@ public RuleBasedCollator(String rules) throws ParseException\n     \n     this.rules = rules;\n \n-    // We keep each rule in order in a vector.  At the end we traverse\n-    // the vector and compute collation values from it.\n-    int insertion_index = 0;\n-    Vector vec = new Vector ();\n+    buildCollationVector(parseString(rules));\n+    buildPrefixAccess();\n+  }\n \n+  /**\n+   * This method returns the number of common characters at the beginning\n+   * of the string of the two parameters.\n+   *\n+   * @param prefix A string considered as a prefix to test against\n+   * the other string.\n+   * @param s A string to test the prefix against.\n+   * @return The number of common characters.\n+   */\n+  static int findPrefixLength(String prefix, String s)\n+  {\n     int index;\n-    StringBuffer argument = new StringBuffer();\n-    int len = rules.length();\n+    int len = prefix.length();\n \n-    for (index = 0; index < len; ++index)\n+    for (index = 0; index < len && index < s.length(); ++index)\n       {\n-\tchar c = rules.charAt(index);\n+\tif (prefix.charAt(index) != s.charAt(index))\n+\t  return index;\n+      }\n \n-\t// Just skip whitespace.\n-\tif (Character.isWhitespace(c))\n-\t  continue;\n \n-\t// Modifier.\n-\tif (c == '@')\n+    return index;\n+  }\n+\n+  /**\n+   * Here we are merging two sets of sorting instructions: 'patch' into 'main'. This methods\n+   * checks whether it is possible to find an anchor point for the rules to be merged and\n+   * then insert them at that precise point.\n+   *\n+   * @param offset Offset in the string containing rules of the beginning of the rules\n+   * being merged in.\n+   * @param starter Text of the rules being merged.\n+   * @param main Repository of all already parsed rules.\n+   * @param patch Rules to be merged into the repository.\n+   * @throws ParseException if it is impossible to find an anchor point for the new rules.\n+   */\n+  private void mergeRules(int offset, String starter, Vector main, Vector patch)\n+    throws ParseException \n+  {\n+    Enumeration elements = main.elements();\n+    int insertion_point = -1;\n+    int max_length = 0;\n+    \n+    /* We must check that no rules conflict with another already present. If it\n+     * is the case delete the old rule. \n+     */\n+    \n+    /* For the moment good old O(N^2) algorithm.\n+     */\n+    for (int i = 0; i < patch.size(); i++)\n+      {\n+\tint j = 0;\n+\t\n+\twhile (j < main.size())\n \t  {\n-\t    frenchAccents = true;\n-\t    continue;\n+\t    CollationSorter rule1 = (CollationSorter) patch.elementAt(i);\n+\t    CollationSorter rule2 = (CollationSorter) main.elementAt(j);\n+\t    \n+\t    if (rule1.textElement.equals(rule2.textElement))\n+\t      main.removeElementAt(j);\n+\t    else\n+\t      j++;\n \t  }\n+      }\n \n-\t// Check for relation or reset operator.\n-\tif (! (c == '<' || c == ';' || c == ',' || c == '=' || c == '&'))\n-\t  throw new ParseException (\"invalid character\", index);\n-\n-\t++index;\n-\twhile (index < len)\n+    // Find the insertion point... O(N)\n+    for (int i = 0; i < main.size(); i++)\n+      {\n+\tCollationSorter sorter = (CollationSorter) main.elementAt(i);\n+\tint length = findPrefixLength(starter, sorter.textElement);\n+\t\t\n+\tif (length > max_length)\n \t  {\n-\t    if (! Character.isWhitespace(rules.charAt(index)))\n-\t      break;\n-\t    ++index;\n+\t    max_length = length;\n+\t    insertion_point = i+1;\n \t  }\n-\tif (index == len)\n-\t  throw new ParseException (\"missing argument\", index);\n-\n-\tint save = index;\n-\tindex = text_argument (rules, index, argument);\n-\tif (argument.length() == 0)\n-\t  throw new ParseException (\"invalid character\", save);\n-\tString arg = argument.toString();\n-\tint item_index = -1;\n-        \n-        for (int j = 0; j < vec.size(); ++j)\n-          {\n-            CollationElement e = (CollationElement) vec.elementAt (j);\n+      }\n \n-            if (arg.equals (e.key))\n-              {\n-                item_index = j;\n-                break;\n-              }\n-          }\n+    if (insertion_point < 0)\n+      throw new ParseException(\"no insertion point found for \" + starter, offset);\n+\n+    if (max_length < starter.length())\n+      {\n+\t/*\n+\t * We need to expand the first entry. It must be sorted\n+\t * like if it was the reference key itself (like the spec\n+\t * said. So the first entry is special: the element is\n+\t * replaced by the specified text element for the sorting.\n+\t * This text replace the old one for comparisons. However\n+\t * to preserve the behaviour we replace the first key (corresponding\n+\t * to the found prefix) by a new code rightly ordered in the\n+\t * sequence. The rest of the subsequence must be appended\n+\t * to the end of the sequence.\n+\t */\n+\tCollationSorter sorter = (CollationSorter) patch.elementAt(0);\n+\tCollationSorter expansionPrefix =\n+\t  (CollationSorter) main.elementAt(insertion_point-1);\n \t\n-\tif (c != '&')\n+\tsorter.expansionOrdering = starter.substring(max_length); // Skip the first good prefix element\n+\t\t\n+\tmain.insertElementAt(sorter, insertion_point);\n+\t\n+\t/*\n+\t * This is a new set of rules. Append to the list.\n+\t */\n+\tpatch.removeElementAt(0);\n+\tinsertion_point++;\n+      }\n+\n+    // Now insert all elements of patch at the insertion point.\n+    for (int i = 0; i < patch.size(); i++)\n+      main.insertElementAt(patch.elementAt(i), i+insertion_point);\n+  }\n+\n+  /**\n+   * This method parses a string and build a set of sorting instructions. The parsing\n+   * may only be partial on the case the rules are to be merged sometime later.\n+   * \n+   * @param stop_on_reset If this parameter is true then the parser stops when it\n+   * encounters a reset instruction. In the other case, it tries to parse the subrules\n+   * and merged it in the same repository.\n+   * @param v Output vector for the set of instructions.\n+   * @param base_offset Offset in the string to begin parsing.\n+   * @param rules Rules to be parsed.\n+   * @return -1 if the parser reached the end of the string, an integer representing the\n+   * offset in the string at which it stopped parsing. \n+   * @throws ParseException if something turned wrong during the parsing. To get details\n+   * decode the message.\n+   */\n+  private int subParseString(boolean stop_on_reset, Vector v,\n+\t\t\t     int base_offset, String rules)\n+    throws ParseException\n+  {\n+    boolean ignoreChars = (base_offset == 0);\n+    int operator = -1;\n+    StringBuffer sb = new StringBuffer();\n+    boolean doubleQuote = false;\n+    boolean eatingChars = false;\n+    boolean nextIsModifier = false;\n+    boolean isModifier = false;\n+    int i;\n+    \n+main_parse_loop:\n+    for (i = 0; i < rules.length(); i++)\n+      {\n+\tchar c = rules.charAt(i);\n+\tint type = -1;\n+\t\n+\tif (!eatingChars &&\n+\t    ((c >= 0x09 && c <= 0x0D) || (c == 0x20)))\n+\t      continue;\n+\n+\tisModifier = nextIsModifier;\n+\tnextIsModifier = false;\n+\n+\tif (eatingChars && c != '\\'')\n \t  {\n-\t    // If the argument already appears in the vector, then we\n-\t    // must remove it in order to re-order.\n-\t    if (item_index != -1)\n-\t      {\n-\t\tvec.removeElementAt(item_index);\n-\t\tif (insertion_index >= item_index)\n-\t\t  --insertion_index;\n-\t      }\n-\t    CollationElement r = new CollationElement (arg, c);\n-\t    vec.insertElementAt(r, insertion_index);\n-\t    ++insertion_index;\n+\t    doubleQuote = false;\n+\t    sb.append(c);\n+\t    continue;\n \t  }\n-\telse\n+\tif (doubleQuote && eatingChars)\n \t  {\n-\t    // Reset.\n-\t    if (item_index == -1)\n-\t      throw\n-\t\tnew ParseException (\"argument to reset not previously seen\",\n-\t\t\t\t    save);\n-\t    insertion_index = item_index + 1;\n+\t    sb.append(c);\n+\t    doubleQuote = false;\n+\t    continue;\n \t  }\n \n-\t// Ugly: in this case the resulting INDEX comes from\n-\t// text_argument, which returns the index of the next\n-\t// character we should examine.\n-\t--index;\n-      }\n+\tswitch (c) {\n+\tcase '!':\n+\t  throw new ParseException\n+\t    (\"Modifier '!' is not yet supported by Classpath\", i+base_offset);\n+\tcase '<':\n+\t  type = CollationSorter.GREATERP;\n+\t  break;\n+\tcase ';':\n+\t  type = CollationSorter.GREATERS;\n+\t  break;\n+\tcase ',':\n+\t  type = CollationSorter.GREATERT;\n+\t  break;\n+\tcase '=':\n+\t  type = CollationSorter.EQUAL;\n+\t  break;\n+\tcase '\\'':\n+\t  eatingChars = !eatingChars;\n+\t  doubleQuote = true;\n+\t  break;\n+\tcase '@':\n+\t  if (ignoreChars)\n+\t    throw new ParseException\n+\t      (\"comparison list has not yet been started. You may only use\"\n+\t       + \"(<,;=&)\", i+base_offset);\n+\t  // Inverse the order of secondaries from now on.\n+\t  nextIsModifier = true;\n+\t  type = CollationSorter.INVERSE_SECONDARY;\n+\t  break;\n+\tcase '&':\n+\t  type = CollationSorter.RESET;\n+\t  if (stop_on_reset)\n+\t    break main_parse_loop;\n+\t  break;\n+\tdefault:\n+\t  if (operator < 0)\n+\t    throw new ParseException\n+\t      (\"operator missing at \" + (i+base_offset), i+base_offset);\n+\t  if (!eatingChars &&\n+\t      ((c >= 0x21 && c <= 0x2F) \n+\t       || (c >= 0x3A && c <= 0x40)\n+\t       || (c >= 0x5B && c <= 0x60)\n+\t       || (c >= 0x7B && c <= 0x7E)))\n+\t    throw new ParseException\n+\t      (\"unquoted punctuation character '\"+c+\"'\", i+base_offset);\n+\n+\t  //type = ignoreChars ? CollationSorter.IGNORE : -1;\n+\t  sb.append(c);\n+\t  break;\n+\t}\n \n-    // Now construct a hash table that maps strings onto their\n-    // collation values.\n-    int primary = 0;\n-    int secondary = 0;\n-    int tertiary = 0;\n-    this.map = new Hashtable ();\n-    this.prefixes = new Hashtable ();\n-    Enumeration e = vec.elements();\n-    while (e.hasMoreElements())\n-      {\n-\tCollationElement r = (CollationElement) e.nextElement();\n-\tswitch (r.relation)\n+\tif (type  < 0)\n+\t  continue;\n+\n+\tif (operator < 0)\n \t  {\n-\t  case '<':\n-\t    ++primary;\n-\t    secondary = 0;\n-\t    tertiary = 0;\n-\t    break;\n-\t  case ';':\n-\t    ++secondary;\n-\t    tertiary = 0;\n-\t    break;\n-\t  case ',':\n-\t    ++tertiary;\n-\t    break;\n-\t  case '=':\n-\t    break;\n+\t    operator = type;\n+\t    continue;\n \t  }\n-\t// This must match CollationElementIterator.\n-\tmap.put(r.key, new Integer (primary << 16\n-\t\t\t\t    | secondary << 8 | tertiary));\n \n-\t// Make a map of all lookaheads we might need.\n-\tfor (int i = r.key.length() - 1; i >= 1; --i)\n-\t  prefixes.put(r.key.substring(0, i), Boolean.TRUE);\n+\tif (sb.length() == 0 && !isModifier)\n+\t  throw new ParseException\n+\t    (\"text element empty at \" + (i+base_offset), i+base_offset);\n+\n+\tif (operator == CollationSorter.RESET)\n+\t  {\n+\t    /* Reposition in the sorting list at the position\n+\t     * indicated by the text element.\n+\t     */\n+\t    String subrules = rules.substring(i);\n+\t    Vector sorted_rules = new Vector();\n+\t    int idx;\n+\n+\t    // Parse the subrules but do not iterate through all\n+\t    // sublist. This is the priviledge of the first call.\n+\t    idx = subParseString(true, sorted_rules, base_offset+i, subrules);\n+    \n+\t    // Merge new parsed rules into the list.\n+\t    mergeRules(base_offset+i, sb.toString(), v, sorted_rules);\n+\t    sb.setLength(0);\n+\t    \n+\t    // Reset state to none.\n+\t    operator = -1;\n+\t    type = -1;\n+\t    // We have found a new subrule at 'idx' but it has not been parsed.\n+\t    if (idx >= 0)\n+\t      {\n+\t\ti += idx-1;\n+\t\tcontinue main_parse_loop;\n+\t      }\n+\t    else\n+\t\t// No more rules.\n+\t\tbreak main_parse_loop;\n+\t  }\n+\n+\tCollationSorter sorter = new CollationSorter();\n+\t\n+\tif (operator == CollationSorter.GREATERP)\n+\t  ignoreChars = false;\n+\n+\tsorter.comparisonType = operator;\n+\tsorter.textElement = sb.toString();\n+\tsorter.hashText = sorter.textElement.hashCode();\n+\tsorter.offset = base_offset+rules.length();\n+\tsorter.ignore = ignoreChars;\n+\tsb.setLength(0);\n+\n+\tv.add(sorter);\n+\toperator = type;\n+      }\n+\n+    if (operator >= 0)\n+      {\n+\tCollationSorter sorter = new CollationSorter();\n+\tint pos = rules.length() + base_offset;\n+\n+\tif ((sb.length() != 0 && nextIsModifier)\n+\t    || (sb.length() == 0 && !nextIsModifier && !eatingChars))\n+\t  throw new ParseException(\"text element empty at \" + pos, pos);\n+\n+\tif (operator == CollationSorter.GREATERP)\n+\t  ignoreChars = false;\n+\n+\tsorter.comparisonType = operator;\n+\tsorter.textElement = sb.toString();\n+ \tsorter.hashText = sorter.textElement.hashCode();\n+\tsorter.offset = base_offset+pos;\n+\tsorter.ignore = ignoreChars;\n+\tv.add(sorter);\n       }\n+\n+    if (i == rules.length())\n+      return -1;\n+    else\n+      return i;\n   }\n \n   /**\n@@ -323,90 +580,130 @@ public RuleBasedCollator(String rules) throws ParseException\n    */\n   public Object clone()\n   {\n-    RuleBasedCollator c = (RuleBasedCollator) super.clone ();\n-    c.map = (Hashtable) map.clone ();\n-    c.prefixes = (Hashtable) map.clone ();\n-    return c;\n+    return super.clone();\n   }\n \n-  // A helper for CollationElementIterator.next().\n-  int ceiNext (CollationElementIterator cei)\n+  /**\n+   * This method completely parses a string 'rules' containing sorting rules.\n+   *\n+   * @param rules String containing the rules to be parsed. \n+   * @return A set of sorting instructions stored in a Vector.\n+   * @throws ParseException if something turned wrong during the parsing. To get details\n+   * decode the message.\n+   */\n+  private Vector parseString(String rules) \n+    throws ParseException\n   {\n-    if (cei.lookahead_set)\n-      {\n-\tcei.lookahead_set = false;\n-\treturn cei.lookahead;\n-      }\n+    Vector v = new Vector();\n \n-    int save = cei.textIndex;\n-    int max = cei.text.length();\n-    String s = null;\n-\n-    // It is possible to have a case where `abc' has a mapping, but\n-    // neither `ab' nor `abd' do.  In this case we must treat `abd' as\n-    // nothing special.\n-    boolean found = false;\n+    // result of the first subParseString is not absolute (may be -1 or a\n+    // positive integer). But we do not care.\n+    subParseString(false, v, 0, rules);\n+    \n+    return v;\n+  }\n \n-    int i;\n-    for (i = save + 1; i <= max; ++i)\n+  /**\n+   * This method uses the sorting instructions built by {@link #parseString}\n+   * to build collation elements which can be directly used to sort strings.\n+   *\n+   * @param parsedElements Parsed instructions stored in a Vector.\n+   * @throws ParseException if the order of the instructions are not valid.\n+   */\n+  private void buildCollationVector(Vector parsedElements)\n+    throws ParseException\n+  {\n+    int primary_seq = 0;\n+    int last_tertiary_seq = 0;\n+    short secondary_seq = 0;\n+    short tertiary_seq = 0;\n+    short equality_seq = 0;\n+    boolean inverseComparisons = false;\n+    final boolean DECREASING = false;\n+    final boolean INCREASING = true;\n+    boolean secondaryType = INCREASING;\n+    Vector v = new Vector();\n+\n+    // elts is completely sorted.\n+element_loop:\n+    for (int i = 0; i < parsedElements.size(); i++)\n       {\n-\ts = cei.text.substring(save, i);\n-\tif (prefixes.get(s) == null)\n-\t  break;\n-\tfound = true;\n-      }\n-    // Assume s != null.\n+\tCollationSorter elt = (CollationSorter) parsedElements.elementAt(i);\n+\tboolean ignoreChar = false;\n \n-    Object obj = map.get(s);\n-    // The special case.\n-    while (found && obj == null && s.length() > 1)\n-      {\n-\t--i;\n-\ts = cei.text.substring(save, i);\n-\tobj = map.get(s);\n+\tswitch (elt.comparisonType)\n+\t  {\n+\t  case CollationSorter.GREATERP:\n+\t    primary_seq++;\n+\t    if (inverseComparisons)\n+\t      {\n+\t\tsecondary_seq = Short.MAX_VALUE;\n+\t\tsecondaryType = DECREASING;\n+\t      }\n+\t    else\n+\t      {\n+\t\tsecondary_seq = 0;\n+\t\tsecondaryType = INCREASING;\n+\t      }\n+\t    tertiary_seq = 0;\n+\t    equality_seq = 0;\n+\t    inverseComparisons = false;\n+\t    break;\n+\t  case CollationSorter.GREATERS:\n+\t    if (secondaryType == DECREASING)\n+\t      secondary_seq--;\n+\t    else\n+\t      secondary_seq++;\n+\t    tertiary_seq = 0;\n+\t    equality_seq = 0;\n+\t    break;\n+\t  case CollationSorter.INVERSE_SECONDARY:\n+\t    inverseComparisons = true;\n+\t    continue element_loop;\n+\t  case CollationSorter.GREATERT:\n+\t    tertiary_seq++;\n+\t    if (primary_seq == 0)\n+\t      last_tertiary_seq = tertiary_seq;\n+\t    equality_seq = 0;\n+\t    break;\n+\t  case CollationSorter.EQUAL:\n+\t    equality_seq++;\n+\t    break;\n+\t  case CollationSorter.RESET:\n+\t    throw new ParseException\n+\t      (\"Invalid reached state 'RESET'. Internal error\", elt.offset);\n+\t  default:\n+\t    throw new ParseException\n+\t      (\"Invalid unknown state '\" + elt.comparisonType + \"'\", elt.offset);\n+\t  }\n+\n+\tv.add(new CollationElement(elt.textElement, primary_seq,\n+\t\t\t\t   secondary_seq, tertiary_seq,\n+\t\t\t\t   equality_seq, elt.expansionOrdering, elt.ignore));\n       }\n \n-    // Update state.\n-    cei.textIndex = i;\n+    this.inverseAccentComparison = inverseComparisons; \n \n-    if (obj == null)\n-      {\n-\t// This idea, and the values, come from JDK.\n-\t// assert (s.length() == 1)\n-\tcei.lookahead_set = true;\n-\tcei.lookahead = s.charAt(0) << 8;\n-\treturn 0x7fff << 16;\n-      }\n+    ce_table = v.toArray();\n \n-    return ((Integer) obj).intValue();\n+    last_primary_value = primary_seq+1;\n+    last_tertiary_value = last_tertiary_seq+1;\n   }\n \n-  // A helper for compareTo() that returns the next character that has\n-  // a nonzero ordering at the indicated strength.  This is also used\n-  // in CollationKey.\n-  static final int next (CollationElementIterator iter, int strength)\n+  /**\n+   * Build a tree where all keys are the texts of collation elements and data is\n+   * the collation element itself. The tree is used when extracting all prefix\n+   * for a given text.\n+   */\n+  private void buildPrefixAccess()\n   {\n-    while (true)\n+    prefix_tree = new HashMap();\n+\n+    for (int i = 0; i < ce_table.length; i++)\n       {\n-\tint os = iter.next();\n-\tif (os == CollationElementIterator.NULLORDER)\n-\t  return os;\n-\tint c = 0;\n-\tswitch (strength)\n-\t  {\n-\t  case PRIMARY:\n-\t    c = os & ~0xffff;\n-\t    break;\n-\t  case SECONDARY:\n-\t    c = os & ~0x00ff;\n-\t    break;\n-\t  case TERTIARY:\n-\t  case IDENTICAL:\n-\t    c = os;\n-\t    break;\n-\t  }\n-\tif (c != 0)\n-\t  return c;\n+\tCollationElement e = (CollationElement) ce_table[i];\n+\n+\tprefix_tree.put(e.key, e);\n       }\n   }\n \n@@ -425,34 +722,115 @@ static final int next (CollationElementIterator iter, int strength)\n   public int compare(String source, String target)\n   {\n     CollationElementIterator cs, ct;\n+    CollationElement ord1block = null;\n+    CollationElement ord2block = null;\n+    boolean advance_block_1 = true;\n+    boolean advance_block_2 = true;\n \n-    cs = new CollationElementIterator(this, source);\n-    ct = new CollationElementIterator(this, target);\n+    cs = getCollationElementIterator(source);\n+    ct = getCollationElementIterator(target);\n \n     for(;;)\n       {\n-\tint os = next (cs, strength);\n-\tint ot = next (ct, strength);\n+\tint ord1;\n+\tint ord2;\n+\n+\t/*\n+\t * We have to check whether the characters are ignorable.\n+\t * If it is the case then forget them. \n+\t */\n+\tif (advance_block_1)\n+\t  {\n+\t    ord1block = cs.nextBlock();\n+\t    if (ord1block != null && ord1block.ignore)\n+\t      continue;\n+\t  }\n+\t\n+\tif (advance_block_2)\n+\t  {\n+\t    ord2block = ct.nextBlock();\n+\t    if (ord2block != null && ord2block.ignore)\n+\t      {\n+\t        advance_block_1 = false;\n+\t        continue;\n+\t      }\n+\t }\n+\telse\n+\t  advance_block_2 = true;\n \n-\tif (os == CollationElementIterator.NULLORDER\n-\t    && ot == CollationElementIterator.NULLORDER)\n-\t  break;\n-\telse if (os == CollationElementIterator.NULLORDER)\n+\tif (!advance_block_1)\n+\t  advance_block_1 = true;\n+\n+\tif (ord1block != null)\n+\t  ord1 = ord1block.getValue();\n+\telse\n \t  {\n-\t    // Source string is shorter, so return \"less than\".\n+\t    if (ord2block == null)\n+\t      return 0;\n \t    return -1;\n \t  }\n-\telse if (ot == CollationElementIterator.NULLORDER)\n+\n+\tif (ord2block == null)\n+\t  return 1;\n+\t\n+\tord2 = ord2block.getValue();\n+\t\n+\t// We know chars are totally equal, so skip\n+        if (ord1 == ord2)\n \t  {\n-\t    // Target string is shorter, so return \"greater than\".\n-\t    return 1;\n+\t    if (getStrength() == IDENTICAL)\n+\t      if (!ord1block.key.equals(ord2block.key))\n+\t\treturn ord1block.key.compareTo(ord2block.key);\n+\t    continue;\n \t  }\n \n-\tif (os != ot)\n-\t  return os - ot;\n-      }\n+        // Check for primary strength differences\n+        int prim1 = CollationElementIterator.primaryOrder(ord1); \n+        int prim2 = CollationElementIterator.primaryOrder(ord2); \n+\t\n+\tif (prim1 == 0 && getStrength() < TERTIARY)\n+\t  {\n+            advance_block_2 = false;\n+\t    continue;\n+\t  }\n+\telse if (prim2 == 0 && getStrength() < TERTIARY)\n+\t  {\n+\t    advance_block_1 = false;\n+\t    continue;\n+\t  }\n+\n+        if (prim1 < prim2)\n+          return -1;\n+        else if (prim1 > prim2)\n+          return 1;\n+        else if (getStrength() == PRIMARY)\n+          continue;\n+\n+        // Check for secondary strength differences\n+        int sec1 = CollationElementIterator.secondaryOrder(ord1);\n+        int sec2 = CollationElementIterator.secondaryOrder(ord2);\n+\n+\tif (sec1 < sec2)\n+          return -1;\n+        else if (sec1 > sec2)\n+          return 1;\n+        else if (getStrength() == SECONDARY)\n+          continue;\n+\n+        // Check for tertiary differences\n+        int tert1 = CollationElementIterator.tertiaryOrder(ord1);\n+        int tert2 = CollationElementIterator.tertiaryOrder(ord2);\n+\n+        if (tert1 < tert2)\n+          return -1;\n+        else if (tert1 > tert2)\n+          return 1;\n+\telse if (getStrength() == TERTIARY)\n+\t  continue;\n \n-    return 0;\n+\t// Apparently JDK does this (at least for my test case).\n+\treturn ord1block.key.compareTo(ord2block.key);    \n+      }\n   }\n \n   /**\n@@ -467,13 +845,54 @@ else if (ot == CollationElementIterator.NULLORDER)\n    */\n   public boolean equals(Object obj)\n   {\n-    if (! (obj instanceof RuleBasedCollator) || ! super.equals(obj))\n+    if (obj == this)\n+      return true;\n+    else\n       return false;\n-    RuleBasedCollator rbc = (RuleBasedCollator) obj;\n-    // FIXME: this is probably wrong.  Instead we should compare maps\n-    // directly.\n-    return (frenchAccents == rbc.frenchAccents\n-\t    && rules.equals(rbc.rules));\n+  }\n+\n+  /**\n+   * This method builds a default collation element without invoking\n+   * the database created from the rules passed to the constructor.\n+   *\n+   * @param c Character which needs a collation element.\n+   * @return A valid brand new CollationElement instance.\n+   */\n+  CollationElement getDefaultElement(char c)\n+  {\n+    int v;\n+\n+    // Preliminary support for generic accent sorting inversion (I don't know if all\n+    // characters in the range should be sorted backward). This is the place\n+    // to fix this if needed.\n+    if (inverseAccentComparison && (c >= 0x02B9 && c <= 0x0361))\n+      v = 0x0361 - ((int) c - 0x02B9);\n+    else\n+      v = (short) c;\n+    return new CollationElement(\"\" + c, last_primary_value + v,\n+\t\t\t\t(short) 0, (short) 0, (short) 0, null, false);\n+  }\n+\n+  /**\n+   * This method builds a default collation element for an accented character\n+   * without invoking the database created from the rules passed to the constructor.\n+   *\n+   * @param c Character which needs a collation element.\n+   * @return A valid brand new CollationElement instance.\n+   */\n+  CollationElement getDefaultAccentedElement(char c)\n+  {\n+    int v;\n+\n+    // Preliminary support for generic accent sorting inversion (I don't know if all\n+    // characters in the range should be sorted backward). This is the place\n+    // to fix this if needed.\n+    if (inverseAccentComparison && (c >= 0x02B9 && c <= 0x0361))\n+      v = 0x0361 - ((int) c - 0x02B9);\n+    else\n+      v = (short) c;\n+    return new CollationElement(\"\" + c, (short) 0,\n+\t\t\t\t(short) 0, (short) (last_tertiary_value + v), (short) 0, null, false);\n   }\n \n   /**\n@@ -489,13 +908,7 @@ public boolean equals(Object obj)\n    */\n   public CollationElementIterator getCollationElementIterator(String source)\n   {\n-    int len = source.length();\n-    StringBuffer expand = new StringBuffer(len);\n-    \n-    for (int index = 0; index < len; ++index)\n-      decomposeCharacter(source.charAt(index), expand);\n-    \n-    return new CollationElementIterator(this, expand.toString());\n+    return new CollationElementIterator(this, source);\n   }\n \n   /**\n@@ -517,7 +930,7 @@ public CollationElementIterator getCollationElementIterator(CharacterIterator so\n \t c = source.next())\n       decomposeCharacter(c, expand);\n \n-    return new CollationElementIterator(this, expand.toString());\n+    return getCollationElementIterator(expand.toString());\n   }\n \n   /**\n@@ -533,8 +946,52 @@ public CollationElementIterator getCollationElementIterator(CharacterIterator so\n    */\n   public CollationKey getCollationKey(String source)\n   {\n-    return new CollationKey(this, getCollationElementIterator(source), source,\n-\t\t\t    strength);\n+    CollationElementIterator cei = getCollationElementIterator(source);\n+    Vector vect = new Vector(25);\n+\n+    int ord = cei.next();\n+    cei.reset(); //set to start of string\n+\n+    while (ord != CollationElementIterator.NULLORDER)\n+      {\n+\t// If the primary order is null, it means this is an ignorable\n+\t// character.\n+\tif (CollationElementIterator.primaryOrder(ord) == 0)\n+\t  {\n+            ord = cei.next();\n+\t    continue;\n+\t  }\n+        switch (getStrength())\n+          {\n+            case PRIMARY:\n+\t      ord = CollationElementIterator.primaryOrder(ord);\n+\t      break;\n+\t      \n+            case SECONDARY:\n+\t      ord = CollationElementIterator.primaryOrder(ord) << 8;\n+\t      ord |= CollationElementIterator.secondaryOrder(ord);\n+\n+            default:\n+               break;\n+          }\n+\n+        vect.add(new Integer(ord)); \n+\tord = cei.next(); //increment to next key\n+      }\n+\n+    Object[] objarr = vect.toArray();\n+    byte[] key = new byte[objarr.length * 4];\n+\n+    for (int i = 0; i < objarr.length; i++)\n+      {\n+        int j = ((Integer) objarr[i]).intValue();\n+        key [i * 4] = (byte) ((j & 0xFF000000) >> 24);\n+        key [i * 4 + 1] = (byte) ((j & 0x00FF0000) >> 16);\n+        key [i * 4 + 2] = (byte) ((j & 0x0000FF00) >> 8);\n+        key [i * 4 + 3] = (byte) (j & 0x000000FF);\n+      }\n+\n+    return new CollationKey(this, source, key);\n   }\n \n   /**\n@@ -555,44 +1012,6 @@ public String getRules()\n    */\n   public int hashCode()\n   {\n-    return (frenchAccents ? 1231 : 1237\n-\t    ^ rules.hashCode()\n-\t    ^ map.hashCode()\n-\t    ^ prefixes.hashCode());\n+    return System.identityHashCode(this);\n   }\n-\n-  private final boolean is_special (char c)\n-  {\n-    // Rules from JCL book.\n-    return ((c >= 0x0021 && c <= 0x002f)\n-\t    || (c >= 0x003a && c <= 0x0040)\n-\t    || (c >= 0x005b && c <= 0x0060)\n-\t    || (c >= 0x007b && c <= 0x007e));\n-  }\n-\n-  private final int text_argument (String rules, int index,\n-\t\t\t\t   StringBuffer result)\n-  {\n-    result.setLength(0);\n-    int len = rules.length();\n-    while (index < len)\n-      {\n-\tchar c = rules.charAt (index);\n-\tif (c == '\\''\n-            && index + 2 < len\n-\t    && rules.charAt (index + 2) == '\\'')\n-          {\n-            result.append (rules.charAt (index + 1));\n-            index += 2;\n-          }\n-\telse if (is_special (c))\n-\t  return index;\n-        else if (!Character.isWhitespace (c))\n-          result.append (c);\n-        \n-        ++index;\n-      }\n-    return index;\n-  }\n-\n }"}, {"sha": "37981bee55229d38fa3e29ac55b1e631d5689c8f", "filename": "libjava/testsuite/libjava.mauve/xfails", "status": "modified", "additions": 0, "deletions": 100, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57807c317869610e07a85bf8bf95747638230ed7/libjava%2Ftestsuite%2Flibjava.mauve%2Fxfails", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57807c317869610e07a85bf8bf95747638230ed7/libjava%2Ftestsuite%2Flibjava.mauve%2Fxfails", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flibjava.mauve%2Fxfails?ref=57807c317869610e07a85bf8bf95747638230ed7", "patch": "@@ -35,106 +35,6 @@ FAIL: gnu.testlet.java.lang.String.getBytes14: String.getBytes(\"UTF-16LE\") (numb\n FAIL: gnu.testlet.java.text.DateFormatSymbols.Test: patterns (number 2)\n FAIL: gnu.testlet.java.text.SimpleDateFormat.getAndSet2DigitYearStart: get2DigitYearStart() initial (number 1)\n FAIL: gnu.testlet.java.text.DateFormatSymbols.Test: invalid locale (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: CollationElementIterator (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: next() 0 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: next() 1 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: next() 10 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: next() 11 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: next() 12 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: next() 13 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: next() 2 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: next() 3 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: next() 4 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: next() 5 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: next() 6 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: next() 7 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: next() 8 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: next() 9 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: primaryOrder() 0 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: primaryOrder() 1 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: primaryOrder() 10 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: primaryOrder() 11 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: primaryOrder() 12 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: primaryOrder() 13 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: primaryOrder() 2 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: primaryOrder() 3 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: primaryOrder() 4 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: primaryOrder() 5 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: primaryOrder() 6 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: primaryOrder() 7 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: primaryOrder() 8 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: secondaryOrder() 12 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: secondaryOrder() 4 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: secondaryOrder() 5 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: secondaryOrder() 7 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: secondaryOrder() 9 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: tertiaryOrder() 10 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: next() 2 test string #4 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: no primary difference 2 test string #4 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: next() 4 test string #4 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: no primary difference 4 test string #4 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: next() 6 test string #4 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: no primary difference 6 test string #4 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: next() 8 test string #4 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: no primary difference 8 test string #4 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: next() 10 test string #4 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: no primary difference 10 test string #4 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: next() 12 test string #4 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: no primary difference 12 test string #4 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: next() 14 test string #4 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: no primary difference 14 test string #4 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: next() 16 test string #4 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: no primary difference 16 test string #4 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: next() 18 test string #4 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: no primary difference 18 test string #4 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: next() 20 test string #4 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: no primary difference 20 test string #4 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: next() 22 test string #4 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: no primary difference 22 test string #4 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: next() 24 test string #4 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: no primary difference 24 test string #4 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: next() 26 test string #4 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: no primary difference 26 test string #4 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: next() 28 test string #4 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: no primary difference 28 test string #4 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: next() 30 test string #4 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: no primary difference 30 test string #4 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: next() 32 test string #4 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: no primary difference 32 test string #4 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: next() 34 test string #4 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: no primary difference 34 test string #4 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: next() 36 test string #4 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: no primary difference 36 test string #4 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: next() 38 test string #4 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: no primary difference 38 test string #4 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: next() 40 test string #4 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: no primary difference 40 test string #4 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: next() 42 test string #4 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: no primary difference 42 test string #4 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: next() 44 test string #4 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: no primary difference 44 test string #4 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: next() 46 test string #4 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: no primary difference 46 test string #4 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: next() 48 test string #4 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: no primary difference 48 test string #4 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: next() 50 test string #4 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: no primary difference 50 test string #4 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: next() 52 test string #4 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: no primary difference 52 test string #4 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: next() 54 test string #4 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: no primary difference 54 test string #4 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: next() 56 test string #4 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: no primary difference 56 test string #4 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: next() 58 test string #4 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: no primary difference 58 test string #4 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: next() 60 test string #4 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: no primary difference 60 test string #4 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: next() 62 test string #4 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: no primary difference 62 test string #4 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: wrong number of keys test string #4 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: next() 2 test string #5 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: no tertiary difference2 test string #5 (number 1)\n-FAIL: gnu.testlet.java.text.CollationElementIterator.jdk11: not tertiary ordered0, 2 test set #0 (number 1)\n FAIL: gnu.testlet.java.net.URLConnection.URLConnectionTest: Error in test_Basics  - 2  should not have raised  Throwable here  (number 1)\n FAIL: gnu.testlet.java.net.URLConnection.URLConnectionTest: Error in test_getHeaderField  - 2  4 header field wrong (number 1)\n FAIL: gnu.testlet.java.net.URL.URLTest: openStream (number 1)"}]}