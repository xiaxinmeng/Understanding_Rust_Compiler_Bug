{"sha": "1914f5da249e2785a8b18d96b026ea9d94a89fe3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTkxNGY1ZGEyNDllMjc4NWE4YjE4ZDk2YjAyNmVhOWQ5NGE4OWZlMw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1997-12-15T17:55:58Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1997-12-15T17:55:58Z"}, "message": "reload.h, [...]: Revert March 15 change.\n\n\t* reload.h, reload1.c (eliminate_regs), caller-save.c, dbxout.c,\n\tdwarfout.c, dwarf2out.c, reload.c, sdbout.c: Revert March 15 change.\n\t* reload.c (push_reload): If WORD_REGISTER_OPERATIONS, reload the\n\tSUBREG_REG if the word count is unchanged.\n\t* reload1.c (eliminate_regs) [case SET]: If W_R_O, preserve\n\tsubregs of identical word size for push_reload.\n\nFrom-SVN: r17105", "tree": {"sha": "83b6fb18e33436103a7c2a0c17e90eae2899f811", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/83b6fb18e33436103a7c2a0c17e90eae2899f811"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1914f5da249e2785a8b18d96b026ea9d94a89fe3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1914f5da249e2785a8b18d96b026ea9d94a89fe3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1914f5da249e2785a8b18d96b026ea9d94a89fe3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1914f5da249e2785a8b18d96b026ea9d94a89fe3/comments", "author": null, "committer": null, "parents": [{"sha": "a701efba7e27b3a5f1a6c11071c30140de97a5b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a701efba7e27b3a5f1a6c11071c30140de97a5b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a701efba7e27b3a5f1a6c11071c30140de97a5b0"}], "stats": {"total": 162, "additions": 83, "deletions": 79}, "files": [{"sha": "d73a175afd19f6508596c0e9b60d8e9e13d1c49e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1914f5da249e2785a8b18d96b026ea9d94a89fe3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1914f5da249e2785a8b18d96b026ea9d94a89fe3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1914f5da249e2785a8b18d96b026ea9d94a89fe3", "patch": "@@ -1,3 +1,13 @@\n+Mon Dec 15 17:48:05 1997  Ricahrd Henderson  <rth@cygnus.com>\n+\n+\t* reload.h, reload1.c (eliminate_regs), caller-save.c, dbxout.c,\n+\tdwarfout.c, dwarf2out.c, reload.c, sdbout.c: Revert March 15 change.\n+\n+\t* reload.c (push_reload): If WORD_REGISTER_OPERATIONS, reload the\n+\tSUBREG_REG if the word count is unchanged.\n+\t* reload1.c (eliminate_regs) [case SET]: If W_R_O, preserve\n+\tsubregs of identical word size for push_reload.\n+\n Mon Dec 15  Mark Mitchell  <mmitchell@usa.net> 11:41:32 1997\n \n \t* toplev.c (rest_of_compilation): Don't call save_for_inline_copy"}, {"sha": "07c7da74f5a321f37b6e4b7131c3e7f565b4e57e", "filename": "gcc/caller-save.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1914f5da249e2785a8b18d96b026ea9d94a89fe3/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1914f5da249e2785a8b18d96b026ea9d94a89fe3/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=1914f5da249e2785a8b18d96b026ea9d94a89fe3", "patch": "@@ -19,6 +19,7 @@ the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n #include \"config.h\"\n+#include <stdio.h>\n #include \"rtl.h\"\n #include \"insn-config.h\"\n #include \"flags.h\"\n@@ -335,7 +336,7 @@ setup_save_areas (pchanged)\n     for (j = 1; j <= MOVE_MAX / UNITS_PER_WORD; j++)\n       if (regno_save_mem[i][j] != 0)\n \tok &= strict_memory_address_p (GET_MODE (regno_save_mem[i][j]),\n-\t\t\t\t       XEXP (eliminate_regs (regno_save_mem[i][j], 0, NULL_RTX, 1), 0));\n+\t\t\t\t       XEXP (eliminate_regs (regno_save_mem[i][j], 0, NULL_RTX), 0));\n \n   return ok;\n }"}, {"sha": "11af421106ef6f33c739ed311bed81520525387a", "filename": "gcc/dbxout.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1914f5da249e2785a8b18d96b026ea9d94a89fe3/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1914f5da249e2785a8b18d96b026ea9d94a89fe3/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=1914f5da249e2785a8b18d96b026ea9d94a89fe3", "patch": "@@ -1863,7 +1863,7 @@ dbxout_symbol (decl, local)\n \t  /* else it is something we handle like a normal variable.  */\n \t}\n \n-      DECL_RTL (decl) = eliminate_regs (DECL_RTL (decl), 0, NULL_RTX, 0);\n+      DECL_RTL (decl) = eliminate_regs (DECL_RTL (decl), 0, NULL_RTX);\n #ifdef LEAF_REG_REMAP\n       if (leaf_function)\n \tleaf_renumber_regs_insn (DECL_RTL (decl));\n@@ -2184,8 +2184,8 @@ dbxout_parms (parms)\n \t/* Perform any necessary register eliminations on the parameter's rtl,\n \t   so that the debugging output will be accurate.  */\n \tDECL_INCOMING_RTL (parms)\n-\t  = eliminate_regs (DECL_INCOMING_RTL (parms), 0, NULL_RTX, 0);\n-\tDECL_RTL (parms) = eliminate_regs (DECL_RTL (parms), 0, NULL_RTX, 0);\n+\t  = eliminate_regs (DECL_INCOMING_RTL (parms), 0, NULL_RTX);\n+\tDECL_RTL (parms) = eliminate_regs (DECL_RTL (parms), 0, NULL_RTX);\n #ifdef LEAF_REG_REMAP\n \tif (leaf_function)\n \t  {"}, {"sha": "d7ddf7612dd482d8259f8c6d2bc6466cc026ed42", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1914f5da249e2785a8b18d96b026ea9d94a89fe3/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1914f5da249e2785a8b18d96b026ea9d94a89fe3/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=1914f5da249e2785a8b18d96b026ea9d94a89fe3", "patch": "@@ -6968,7 +6968,7 @@ add_location_or_const_value_attribute (die, decl)\n   if (rtl == NULL_RTX)\n     return;\n \n-  rtl = eliminate_regs (rtl, 0, NULL_RTX, 0);\n+  rtl = eliminate_regs (rtl, 0, NULL_RTX);\n #ifdef LEAF_REG_REMAP\n   if (leaf_function)\n     leaf_renumber_regs_insn (rtl);"}, {"sha": "a72ccac5c812d64a5de5b20d057b5c1ff600460a", "filename": "gcc/dwarfout.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1914f5da249e2785a8b18d96b026ea9d94a89fe3/gcc%2Fdwarfout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1914f5da249e2785a8b18d96b026ea9d94a89fe3/gcc%2Fdwarfout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarfout.c?ref=1914f5da249e2785a8b18d96b026ea9d94a89fe3", "patch": "@@ -1866,7 +1866,7 @@ output_bound_representation (bound, dim_num, u_or_l)\n \n \t    if (TREE_CODE (bound) == SAVE_EXPR)\n \t      output_loc_descriptor\n-\t\t(eliminate_regs (SAVE_EXPR_RTL (bound), 0, NULL_RTX, 0));\n+\t\t(eliminate_regs (SAVE_EXPR_RTL (bound), 0, NULL_RTX));\n \t  }\n \n \tASM_OUTPUT_LABEL (asm_out_file, end_label);\n@@ -2409,7 +2409,7 @@ location_or_const_value_attribute (decl)\n   if (rtl == NULL_RTX)\n     return;\n \n-  rtl = eliminate_regs (rtl, 0, NULL_RTX, 0);\n+  rtl = eliminate_regs (rtl, 0, NULL_RTX);\n #ifdef LEAF_REG_REMAP\n   if (leaf_function)\n     leaf_renumber_regs_insn (rtl);"}, {"sha": "9f2365fd5745e94ec4fdf231c14f0aa60f9e4de7", "filename": "gcc/reload.c", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1914f5da249e2785a8b18d96b026ea9d94a89fe3/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1914f5da249e2785a8b18d96b026ea9d94a89fe3/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=1914f5da249e2785a8b18d96b026ea9d94a89fe3", "patch": "@@ -670,7 +670,7 @@ get_secondary_mem (x, mode, opnum, type)\n   /* Get a version of the address doing any eliminations needed.  If that\n      didn't give us a new MEM, make a new one if it isn't valid.  */\n \n-  loc = eliminate_regs (secondary_memlocs[(int) mode], VOIDmode, NULL_RTX, 0);\n+  loc = eliminate_regs (secondary_memlocs[(int) mode], VOIDmode, NULL_RTX);\n   mem_valid = strict_memory_address_p (mode, XEXP (loc, 0));\n \n   if (! mem_valid && loc == secondary_memlocs[(int) mode])\n@@ -985,7 +985,13 @@ push_reload (in, out, inloc, outloc, class,\n \t\t&& REGNO (SUBREG_REG (out)) >= FIRST_PSEUDO_REGISTER)\n \t       || GET_CODE (SUBREG_REG (out)) == MEM)\n \t      && ((GET_MODE_SIZE (outmode)\n-\t\t   > GET_MODE_SIZE (GET_MODE (SUBREG_REG (out))))))\n+\t\t   > GET_MODE_SIZE (GET_MODE (SUBREG_REG (out))))\n+#ifdef WORD_REGISTER_OPERATIONS\n+\t\t  || ((GET_MODE_SIZE (outmode) - 1) / UNITS_PER_WORD ==\n+\t\t      ((GET_MODE_SIZE (GET_MODE (SUBREG_REG (out))) - 1)\n+\t\t       / UNITS_PER_WORD))\n+#endif\n+\t          ))\n \t  || (GET_CODE (SUBREG_REG (out)) == REG\n \t      && REGNO (SUBREG_REG (out)) < FIRST_PSEUDO_REGISTER\n \t      && ((GET_MODE_SIZE (outmode) <= UNITS_PER_WORD\n@@ -2599,7 +2605,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t      /* We must rerun eliminate_regs, in case the elimination\n \t\t offsets have changed.  */\n \t      rtx address = XEXP (eliminate_regs (reg_equiv_memory_loc[regno],\n-\t\t\t\t\t\t  0, NULL_RTX, 0),\n+\t\t\t\t\t\t  0, NULL_RTX),\n \t\t\t\t  0);\n \n \t      if (rtx_varies_p (address))\n@@ -4097,7 +4103,7 @@ find_reloads_toplev (x, opnum, type, ind_levels, is_set_dest)\n \t  /* We must rerun eliminate_regs, in case the elimination\n \t     offsets have changed.  */\n \t  rtx addr = XEXP (eliminate_regs (reg_equiv_memory_loc[regno], 0,\n-\t\t\t\t\t   NULL_RTX, 0),\n+\t\t\t\t\t   NULL_RTX),\n \t\t\t   0);\n \n \t  if (rtx_varies_p (addr))\n@@ -4181,7 +4187,7 @@ find_reloads_toplev (x, opnum, type, ind_levels, is_set_dest)\n \t  /* We must rerun eliminate_regs, in case the elimination\n \t     offsets have changed.  */\n \t  rtx addr = XEXP (eliminate_regs (reg_equiv_memory_loc[regno], 0,\n-\t\t\t\t\t   NULL_RTX, 0),\n+\t\t\t\t\t   NULL_RTX),\n \t\t\t   0);\n \t  if (BYTES_BIG_ENDIAN)\n \t    {\n@@ -4221,8 +4227,7 @@ make_memloc (ad, regno)\n   register int i;\n   /* We must rerun eliminate_regs, in case the elimination\n      offsets have changed.  */\n-  rtx tem = XEXP (eliminate_regs (reg_equiv_memory_loc[regno], 0, NULL_RTX, 0),\n-\t\t  0);\n+  rtx tem = XEXP (eliminate_regs (reg_equiv_memory_loc[regno], 0, NULL_RTX), 0);\n \n #if 0 /* We cannot safely reuse a memloc made here;\n \t if the pseudo appears twice, and its mem needs a reload,"}, {"sha": "e69debe33d334997c4751820e7712046a7447dab", "filename": "gcc/reload.h", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1914f5da249e2785a8b18d96b026ea9d94a89fe3/gcc%2Freload.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1914f5da249e2785a8b18d96b026ea9d94a89fe3/gcc%2Freload.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.h?ref=1914f5da249e2785a8b18d96b026ea9d94a89fe3", "patch": "@@ -145,11 +145,6 @@ extern void clear_secondary_mem PROTO((void));\n    reload TO.  */\n extern void transfer_replacements PROTO((int, int));\n \n-/* Return 1 if ADDR is a valid memory address for mode MODE,\n-   and check that each pseudo reg has the proper kind of\n-   hard reg.  */\n-extern int strict_memory_address_p PROTO((enum machine_mode, rtx));\n-\n /* Like rtx_equal_p except that it allows a REG and a SUBREG to match\n    if they are the same hard reg, and has special hacks for\n    autoincrement and autodecrement.  */\n@@ -212,15 +207,15 @@ extern int regno_clobbered_p PROTO((int, rtx));\n extern void init_reload PROTO((void));\n \n /* The reload pass itself.  */\n-extern int reload STDIO_PROTO((rtx, int, FILE *));\n+extern int reload PROTO((rtx, int, FILE *));\n \n /* Mark the slots in regs_ever_live for the hard regs\n    used by pseudo-reg number REGNO.  */\n extern void mark_home_live PROTO((int));\n \n /* Scan X and replace any eliminable registers (such as fp) with a\n    replacement (such as sp), plus an offset.  */\n-extern rtx eliminate_regs PROTO((rtx, enum machine_mode, rtx, int));\n+extern rtx eliminate_regs PROTO((rtx, enum machine_mode, rtx));\n \n /* Emit code to perform a reload from IN (which may be a reload register) to\n    OUT (which may also be a reload register).  IN or OUT is from operand"}, {"sha": "3cfa1f88498a48552e59b9b13d1e33dc6f5e549a", "filename": "gcc/reload1.c", "status": "modified", "additions": 48, "deletions": 55, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1914f5da249e2785a8b18d96b026ea9d94a89fe3/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1914f5da249e2785a8b18d96b026ea9d94a89fe3/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=1914f5da249e2785a8b18d96b026ea9d94a89fe3", "patch": "@@ -980,7 +980,7 @@ reload (first, global, dumpfile)\n       for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n \tif (reg_renumber[i] < 0 && reg_equiv_memory_loc[i])\n \t  {\n-\t    rtx x = eliminate_regs (reg_equiv_memory_loc[i], 0, NULL_RTX, 0);\n+\t    rtx x = eliminate_regs (reg_equiv_memory_loc[i], 0, NULL_RTX);\n \n \t    if (strict_memory_address_p (GET_MODE (regno_reg_rtx[i]),\n \t\t\t\t\t XEXP (x, 0)))\n@@ -2812,11 +2812,10 @@ static struct rtvec_def *old_asm_operands_vec, *new_asm_operands_vec;\n    the proper thing.  */\n \n rtx\n-eliminate_regs (x, mem_mode, insn, storing)\n+eliminate_regs (x, mem_mode, insn)\n      rtx x;\n      enum machine_mode mem_mode;\n      rtx insn;\n-     int storing;\n {\n   enum rtx_code code = GET_CODE (x);\n   struct elim_table *ep;\n@@ -2845,7 +2844,7 @@ eliminate_regs (x, mem_mode, insn, storing)\n       /* This is only for the benefit of the debugging backends, which call\n \t eliminate_regs on DECL_RTL; any ADDRESSOFs in the actual insns are\n \t removed after CSE.  */\n-      new = eliminate_regs (XEXP (x, 0), 0, insn, 0);\n+      new = eliminate_regs (XEXP (x, 0), 0, insn);\n       if (GET_CODE (new) == MEM)\n \treturn XEXP (new, 0);\n       return x;\n@@ -2881,8 +2880,7 @@ eliminate_regs (x, mem_mode, insn, storing)\n \t     elimination) and ignore the fact that this is actually a\n \t     reference to the pseudo.  Ensure we make a copy of the\n \t     address in case it is shared.  */\n-\t  new = eliminate_regs (reg_equiv_memory_loc[regno],\n-\t\t\t\tmem_mode, insn, 0);\n+\t  new = eliminate_regs (reg_equiv_memory_loc[regno], mem_mode, insn);\n \t  if (new != reg_equiv_memory_loc[regno])\n \t    {\n \t      cannot_omit_stores[regno] = 1;\n@@ -2944,8 +2942,8 @@ eliminate_regs (x, mem_mode, insn, storing)\n \t reload.  This is the desired action.  */\n \n       {\n-\trtx new0 = eliminate_regs (XEXP (x, 0), mem_mode, insn, 0);\n-\trtx new1 = eliminate_regs (XEXP (x, 1), mem_mode, insn, 0);\n+\trtx new0 = eliminate_regs (XEXP (x, 0), mem_mode, insn);\n+\trtx new1 = eliminate_regs (XEXP (x, 1), mem_mode, insn);\n \n \tif (new0 != XEXP (x, 0) || new1 != XEXP (x, 1))\n \t  {\n@@ -3016,9 +3014,9 @@ eliminate_regs (x, mem_mode, insn, storing)\n     case GE:       case GT:       case GEU:    case GTU:\n     case LE:       case LT:       case LEU:    case LTU:\n       {\n-\trtx new0 = eliminate_regs (XEXP (x, 0), mem_mode, insn, 0);\n+\trtx new0 = eliminate_regs (XEXP (x, 0), mem_mode, insn);\n \trtx new1\n-\t  = XEXP (x, 1) ? eliminate_regs (XEXP (x, 1), mem_mode, insn, 0) : 0;\n+\t  = XEXP (x, 1) ? eliminate_regs (XEXP (x, 1), mem_mode, insn) : 0;\n \n \tif (new0 != XEXP (x, 0) || new1 != XEXP (x, 1))\n \t  return gen_rtx (code, GET_MODE (x), new0, new1);\n@@ -3029,7 +3027,7 @@ eliminate_regs (x, mem_mode, insn, storing)\n       /* If we have something in XEXP (x, 0), the usual case, eliminate it.  */\n       if (XEXP (x, 0))\n \t{\n-\t  new = eliminate_regs (XEXP (x, 0), mem_mode, insn, 0);\n+\t  new = eliminate_regs (XEXP (x, 0), mem_mode, insn);\n \t  if (new != XEXP (x, 0))\n \t    x = gen_rtx (EXPR_LIST, REG_NOTE_KIND (x), new, XEXP (x, 1));\n \t}\n@@ -3042,7 +3040,7 @@ eliminate_regs (x, mem_mode, insn, storing)\n \t strictly needed, but it simplifies the code.  */\n       if (XEXP (x, 1))\n \t{\n-\t  new = eliminate_regs (XEXP (x, 1), mem_mode, insn, 0);\n+\t  new = eliminate_regs (XEXP (x, 1), mem_mode, insn);\n \t  if (new != XEXP (x, 1))\n \t    return gen_rtx (GET_CODE (x), GET_MODE (x), XEXP (x, 0), new);\n \t}\n@@ -3078,7 +3076,7 @@ eliminate_regs (x, mem_mode, insn, storing)\n     case ABS:\n     case SQRT:\n     case FFS:\n-      new = eliminate_regs (XEXP (x, 0), mem_mode, insn, 0);\n+      new = eliminate_regs (XEXP (x, 0), mem_mode, insn);\n       if (new != XEXP (x, 0))\n \treturn gen_rtx (code, GET_MODE (x), new);\n       return x;\n@@ -3097,7 +3095,7 @@ eliminate_regs (x, mem_mode, insn, storing)\n \t  && reg_equiv_memory_loc[REGNO (SUBREG_REG (x))] != 0)\n \t{\n \t  new = eliminate_regs (reg_equiv_memory_loc[REGNO (SUBREG_REG (x))],\n-\t\t\t\tmem_mode, insn, 0);\n+\t\t\t\tmem_mode, insn);\n \n \t  /* If we didn't change anything, we must retain the pseudo.  */\n \t  if (new == reg_equiv_memory_loc[REGNO (SUBREG_REG (x))])\n@@ -3117,37 +3115,38 @@ eliminate_regs (x, mem_mode, insn, storing)\n \t    }\n \t}\n       else\n-\tnew = eliminate_regs (SUBREG_REG (x), mem_mode, insn, 0);\n+\tnew = eliminate_regs (SUBREG_REG (x), mem_mode, insn);\n \n       if (new != XEXP (x, 0))\n \t{\n \t  int x_size = GET_MODE_SIZE (GET_MODE (x));\n \t  int new_size = GET_MODE_SIZE (GET_MODE (new));\n \n-\t  /* When asked to spill a partial word subreg, we need to go\n-\t     ahead and spill the whole thing against the possibility\n-\t     that we reload the whole reg and find garbage at the top.  */\n-\t  if (storing\n-\t      && GET_CODE (new) == MEM\n-\t      && x_size < new_size\n-\t      && ((x_size + UNITS_PER_WORD-1) / UNITS_PER_WORD\n-\t\t  == (new_size + UNITS_PER_WORD-1) / UNITS_PER_WORD))\n-\t    return new;\n-\t  else if (GET_CODE (new) == MEM\n-\t\t   && x_size <= new_size\n+\t  if (GET_CODE (new) == MEM\n+\t      && x_size <= new_size\n+#ifdef WORD_REGISTER_OPERATIONS\n+\t      /* On these machines, combine can create rtl of the form\n+\t\t   (set (subreg:m1 (reg:m2 R) 0) ...)\n+\t\t where m1 < m2, and expects something interesting to \n+\t\t happen to the entire word.  Moreover, it will use the\n+\t\t (reg:m2 R) later, expecting all bits to be preserved.\n+\t\t So if the number of words is the same, preserve the \n+\t\t subreg so that push_reloads can see it.  */\n+\t      && ! ((x_size-1)/UNITS_PER_WORD == (new_size-1)/UNITS_PER_WORD)\n+#endif\n #ifdef LOAD_EXTEND_OP\n-\t           /* On these machines we will be reloading what is\n-\t\t      inside the SUBREG if it originally was a pseudo and\n-\t\t      the inner and outer modes are both a word or\n-\t\t      smaller.  So leave the SUBREG then.  */\n-\t           && ! (GET_CODE (SUBREG_REG (x)) == REG\n-\t\t         && x_size <= UNITS_PER_WORD\n-\t\t         && new_size <= UNITS_PER_WORD\n-\t\t         && x_size > new_size\n-\t\t         && INTEGRAL_MODE_P (GET_MODE (new))\n-\t\t         && LOAD_EXTEND_OP (GET_MODE (new)) != NIL)\n+\t      /* On these machines we will be reloading what is\n+\t\t inside the SUBREG if it originally was a pseudo and\n+\t\t the inner and outer modes are both a word or\n+\t\t smaller.  So leave the SUBREG then.  */\n+\t      && ! (GET_CODE (SUBREG_REG (x)) == REG\n+\t\t    && x_size <= UNITS_PER_WORD\n+\t\t    && new_size <= UNITS_PER_WORD\n+\t\t    && x_size > new_size\n+\t\t    && INTEGRAL_MODE_P (GET_MODE (new))\n+\t\t    && LOAD_EXTEND_OP (GET_MODE (new)) != NIL)\n #endif\n-\t           )\n+\t      )\n \t    {\n \t      int offset = SUBREG_WORD (x) * UNITS_PER_WORD;\n \t      enum machine_mode mode = GET_MODE (x);\n@@ -3175,7 +3174,7 @@ eliminate_regs (x, mem_mode, insn, storing)\n \tif (ep->from_rtx == XEXP (x, 0))\n \t  ep->can_eliminate = 0;\n \n-      new = eliminate_regs (XEXP (x, 0), mem_mode, insn, 0);\n+      new = eliminate_regs (XEXP (x, 0), mem_mode, insn);\n       if (new != XEXP (x, 0))\n \treturn gen_rtx (code, GET_MODE (x), new);\n       return x;\n@@ -3188,7 +3187,7 @@ eliminate_regs (x, mem_mode, insn, storing)\n \tif (ep->to_rtx == XEXP (x, 0))\n \t  ep->can_eliminate = 0;\n \n-      new = eliminate_regs (XEXP (x, 0), mem_mode, insn, 0);\n+      new = eliminate_regs (XEXP (x, 0), mem_mode, insn);\n       if (new != XEXP (x, 0))\n \treturn gen_rtx (code, GET_MODE (x), new);\n       return x;\n@@ -3206,7 +3205,7 @@ eliminate_regs (x, mem_mode, insn, storing)\n \t    temp_vec = (rtx *) alloca (XVECLEN (x, 3) * sizeof (rtx));\n \t    for (i = 0; i < ASM_OPERANDS_INPUT_LENGTH (x); i++)\n \t      temp_vec[i] = eliminate_regs (ASM_OPERANDS_INPUT (x, i),\n-\t\t\t\t\t    mem_mode, insn, 0);\n+\t\t\t\t\t    mem_mode, insn);\n \n \t    for (i = 0; i < ASM_OPERANDS_INPUT_LENGTH (x); i++)\n \t      if (temp_vec[i] != ASM_OPERANDS_INPUT (x, i))\n@@ -3277,8 +3276,8 @@ eliminate_regs (x, mem_mode, insn, storing)\n \n       /* Now avoid the loop below in this common case.  */\n       {\n-\trtx new0 = eliminate_regs (SET_DEST (x), 0, insn, 1);\n-\trtx new1 = eliminate_regs (SET_SRC (x), 0, insn, 0);\n+\trtx new0 = eliminate_regs (SET_DEST (x), 0, insn);\n+\trtx new1 = eliminate_regs (SET_SRC (x), 0, insn);\n \n \t/* If SET_DEST changed from a REG to a MEM and INSN is an insn,\n \t   write a CLOBBER insn.  */\n@@ -3287,12 +3286,6 @@ eliminate_regs (x, mem_mode, insn, storing)\n \t    && GET_CODE (insn) != INSN_LIST)\n \t  emit_insn_after (gen_rtx (CLOBBER, VOIDmode, SET_DEST (x)), insn);\n \n-\t/* If SET_DEST was a partial-word subreg, NEW0 may have been widened\n-\t   to spill the entire register (see SUBREG case above).  If the \n-\t   widths of SET_DEST and NEW0 no longer match, adjust NEW1.  */\n-\tif (GET_MODE (SET_DEST (x)) != GET_MODE (new0))\n-\t  new1 = gen_rtx (SUBREG, GET_MODE (new0), new1, 0);\n-\n \tif (new0 != SET_DEST (x) || new1 != SET_SRC (x))\n \t  return gen_rtx (SET, VOIDmode, new0, new1);\n       }\n@@ -3304,12 +3297,12 @@ eliminate_regs (x, mem_mode, insn, storing)\n \t eliminate_regs on DECL_RTL; any ADDRESSOFs in the actual insns are\n \t removed after CSE.  */\n       if (GET_CODE (XEXP (x, 0)) == ADDRESSOF)\n-\treturn eliminate_regs (XEXP (XEXP (x, 0), 0), 0, insn, 0);\n+\treturn eliminate_regs (XEXP (XEXP (x, 0), 0), 0, insn);\n \n       /* Our only special processing is to pass the mode of the MEM to our\n \t recursive call and copy the flags.  While we are here, handle this\n \t case more efficiently.  */\n-      new = eliminate_regs (XEXP (x, 0), GET_MODE (x), insn, 0);\n+      new = eliminate_regs (XEXP (x, 0), GET_MODE (x), insn);\n       if (new != XEXP (x, 0))\n \t{\n \t  new = gen_rtx (MEM, GET_MODE (x), new);\n@@ -3332,7 +3325,7 @@ eliminate_regs (x, mem_mode, insn, storing)\n     {\n       if (*fmt == 'e')\n \t{\n-\t  new = eliminate_regs (XEXP (x, i), mem_mode, insn, 0);\n+\t  new = eliminate_regs (XEXP (x, i), mem_mode, insn);\n \t  if (new != XEXP (x, i) && ! copied)\n \t    {\n \t      rtx new_x = rtx_alloc (code);\n@@ -3349,7 +3342,7 @@ eliminate_regs (x, mem_mode, insn, storing)\n \t  int copied_vec = 0;\n \t  for (j = 0; j < XVECLEN (x, i); j++)\n \t    {\n-\t      new = eliminate_regs (XVECEXP (x, i, j), mem_mode, insn, 0);\n+\t      new = eliminate_regs (XVECEXP (x, i, j), mem_mode, insn);\n \t      if (new != XVECEXP (x, i, j) && ! copied_vec)\n \t\t{\n \t\t  rtvec new_v = gen_rtvec_vv (XVECLEN (x, i),\n@@ -3527,7 +3520,7 @@ eliminate_regs_in_insn (insn, replace)\n      but now can do this as a load-address.  This saves an insn in this\n      common case.  */\n \n-  new_body = eliminate_regs (old_body, 0, replace ? insn : NULL_RTX, 0);\n+  new_body = eliminate_regs (old_body, 0, replace ? insn : NULL_RTX);\n   if (new_body != old_body)\n     {\n       /* If we aren't replacing things permanently and we changed something,\n@@ -3616,7 +3609,7 @@ eliminate_regs_in_insn (insn, replace)\n      of spill registers to be needed in the final reload pass than in\n      the pre-passes.  */\n   if (val && REG_NOTES (insn) != 0)\n-    REG_NOTES (insn) = eliminate_regs (REG_NOTES (insn), 0, REG_NOTES (insn), 0);\n+    REG_NOTES (insn) = eliminate_regs (REG_NOTES (insn), 0, REG_NOTES (insn));\n \n   if (! replace)\n     pop_obstacks ();\n@@ -4090,7 +4083,7 @@ reload_as_needed (first, live_known)\n \t    XEXP (XEXP (PATTERN (insn), 0), 0)\n \t      = eliminate_regs (XEXP (XEXP (PATTERN (insn), 0), 0),\n \t\t\t\tGET_MODE (XEXP (PATTERN (insn), 0)),\n-\t\t\t\tNULL_RTX, 0);\n+\t\t\t\tNULL_RTX);\n \n \t  /* If we need to do register elimination processing, do so.\n \t     This might delete the insn, in which case we are done.  */"}, {"sha": "ef1ff29604de46211861aecb0a8f82235b558815", "filename": "gcc/sdbout.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1914f5da249e2785a8b18d96b026ea9d94a89fe3/gcc%2Fsdbout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1914f5da249e2785a8b18d96b026ea9d94a89fe3/gcc%2Fsdbout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsdbout.c?ref=1914f5da249e2785a8b18d96b026ea9d94a89fe3", "patch": "@@ -789,7 +789,7 @@ sdbout_symbol (decl, local)\n       if (DECL_RTL (decl) == 0)\n \treturn;\n \n-      DECL_RTL (decl) = eliminate_regs (DECL_RTL (decl), 0, NULL_RTX, 0);\n+      DECL_RTL (decl) = eliminate_regs (DECL_RTL (decl), 0, NULL_RTX);\n #ifdef LEAF_REG_REMAP\n       if (leaf_function)\n \tleaf_renumber_regs_insn (DECL_RTL (decl));\n@@ -1289,8 +1289,8 @@ sdbout_parms (parms)\n \t/* Perform any necessary register eliminations on the parameter's rtl,\n \t   so that the debugging output will be accurate.  */\n \tDECL_INCOMING_RTL (parms)\n-\t  = eliminate_regs (DECL_INCOMING_RTL (parms), 0, NULL_RTX, 0);\n-\tDECL_RTL (parms) = eliminate_regs (DECL_RTL (parms), 0, NULL_RTX, 0);\n+\t  = eliminate_regs (DECL_INCOMING_RTL (parms), 0, NULL_RTX);\n+\tDECL_RTL (parms) = eliminate_regs (DECL_RTL (parms), 0, NULL_RTX);\n \n \tif (PARM_PASSED_IN_MEMORY (parms))\n \t  {"}]}