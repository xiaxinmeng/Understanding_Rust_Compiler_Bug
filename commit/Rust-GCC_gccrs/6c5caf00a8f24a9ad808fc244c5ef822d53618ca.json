{"sha": "6c5caf00a8f24a9ad808fc244c5ef822d53618ca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmM1Y2FmMDBhOGYyNGE5YWQ4MDhmYzI0NGM1ZWY4MjJkNTM2MThjYQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2004-02-26T23:32:09Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2004-02-26T23:32:09Z"}, "message": "calls.c: Don't reference FINAL_REG_PARM_STACK_SPACE or MAYBE_REG_PARM_STACK_SPACE.\n\n\t* calls.c: Don't reference FINAL_REG_PARM_STACK_SPACE or\n\tMAYBE_REG_PARM_STACK_SPACE.\n\t* function.c: Likewise.\n\t* system.h (FINAL_REG_PARM_STACK_SPACE): Poison.\n\t(MAYBE_REG_PARM_STACK_SPACE): Likewise.\n\t* doc/tm.texi (FINAL_REG_PARM_STACK_SPACE): Remove.\n\t(MAYBE_REG_PARM_STACK_SPACE): Likewise.\n\nFrom-SVN: r78530", "tree": {"sha": "19f79296cc16a5c5a5495f75561d110a31d08c25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/19f79296cc16a5c5a5495f75561d110a31d08c25"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6c5caf00a8f24a9ad808fc244c5ef822d53618ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c5caf00a8f24a9ad808fc244c5ef822d53618ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c5caf00a8f24a9ad808fc244c5ef822d53618ca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c5caf00a8f24a9ad808fc244c5ef822d53618ca/comments", "author": null, "committer": null, "parents": [{"sha": "6d4fb96f24489823ea2c484ef6117dd44881e59c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d4fb96f24489823ea2c484ef6117dd44881e59c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d4fb96f24489823ea2c484ef6117dd44881e59c"}], "stats": {"total": 92, "additions": 16, "deletions": 76}, "files": [{"sha": "5186c2796f6c58c3660b01d5339b2f1f3bbc033b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c5caf00a8f24a9ad808fc244c5ef822d53618ca/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c5caf00a8f24a9ad808fc244c5ef822d53618ca/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6c5caf00a8f24a9ad808fc244c5ef822d53618ca", "patch": "@@ -1,3 +1,13 @@\n+2004-02-26  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* calls.c: Don't reference FINAL_REG_PARM_STACK_SPACE or\n+\tMAYBE_REG_PARM_STACK_SPACE.\n+\t* function.c: Likewise.\n+\t* system.h (FINAL_REG_PARM_STACK_SPACE): Poison.\n+\t(MAYBE_REG_PARM_STACK_SPACE): Likewise.\n+\t* doc/tm.texi (FINAL_REG_PARM_STACK_SPACE): Remove.\n+\t(MAYBE_REG_PARM_STACK_SPACE): Likewise.\n+\n 2004-02-26  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* c-decl.c (c_expand_deferred_function): Remove."}, {"sha": "4bfcde4f6e1bb8d5aa6f783c48cedcbd46553c48", "filename": "gcc/calls.c", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c5caf00a8f24a9ad808fc244c5ef822d53618ca/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c5caf00a8f24a9ad808fc244c5ef822d53618ca/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=6c5caf00a8f24a9ad808fc244c5ef822d53618ca", "patch": "@@ -1349,11 +1349,6 @@ compute_argument_block_size (int reg_parm_stack_space,\n       args_size->constant = MAX (args_size->constant,\n \t\t\t\t reg_parm_stack_space);\n \n-#ifdef MAYBE_REG_PARM_STACK_SPACE\n-      if (reg_parm_stack_space == 0)\n-\targs_size->constant = 0;\n-#endif\n-\n #ifndef OUTGOING_REG_PARM_STACK_SPACE\n       args_size->constant -= reg_parm_stack_space;\n #endif\n@@ -1735,11 +1730,7 @@ try_to_integrate (tree fndecl, tree actparms, rtx target, int ignore,\n   int reg_parm_stack_space = 0;\n \n #ifdef REG_PARM_STACK_SPACE\n-#ifdef MAYBE_REG_PARM_STACK_SPACE\n-  reg_parm_stack_space = MAYBE_REG_PARM_STACK_SPACE;\n-#else\n   reg_parm_stack_space = REG_PARM_STACK_SPACE (fndecl);\n-#endif\n #endif\n \n   before_call = get_last_insn ();\n@@ -2265,12 +2256,8 @@ expand_call (tree exp, rtx target, int ignore)\n     }\n \n #ifdef REG_PARM_STACK_SPACE\n-#ifdef MAYBE_REG_PARM_STACK_SPACE\n-  reg_parm_stack_space = MAYBE_REG_PARM_STACK_SPACE;\n-#else\n   reg_parm_stack_space = REG_PARM_STACK_SPACE (fndecl);\n #endif\n-#endif\n \n #ifndef OUTGOING_REG_PARM_STACK_SPACE\n   if (reg_parm_stack_space > 0 && PUSH_ARGS)\n@@ -2729,10 +2716,6 @@ expand_call (tree exp, rtx target, int ignore)\n       if (pass && (flags & ECF_LIBCALL_BLOCK))\n \tNO_DEFER_POP;\n \n-#ifdef FINAL_REG_PARM_STACK_SPACE\n-      reg_parm_stack_space = FINAL_REG_PARM_STACK_SPACE (args_size.constant,\n-\t\t\t\t\t\t\t args_size.var);\n-#endif\n       /* Precompute any arguments as needed.  */\n       if (pass)\n \tprecompute_arguments (flags, num_actuals, args);\n@@ -3695,11 +3678,7 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n   rtx struct_value = targetm.calls.struct_value_rtx (0, 0);\n \n #ifdef REG_PARM_STACK_SPACE\n-#ifdef MAYBE_REG_PARM_STACK_SPACE\n-  reg_parm_stack_space = MAYBE_REG_PARM_STACK_SPACE;\n-#else\n   reg_parm_stack_space = REG_PARM_STACK_SPACE ((tree) 0);\n-#endif\n #endif\n \n   /* By default, library functions can not throw.  */\n@@ -3951,10 +3930,6 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n       FUNCTION_ARG_ADVANCE (args_so_far, mode, (tree) 0, 1);\n     }\n \n-#ifdef FINAL_REG_PARM_STACK_SPACE\n-  reg_parm_stack_space = FINAL_REG_PARM_STACK_SPACE (args_size.constant,\n-\t\t\t\t\t\t     args_size.var);\n-#endif\n   /* If this machine requires an external definition for library\n      functions, write one out.  */\n   assemble_external_libcall (fun);"}, {"sha": "9bdff469fb013e98876c49bfed6f44f6c2d578b6", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c5caf00a8f24a9ad808fc244c5ef822d53618ca/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c5caf00a8f24a9ad808fc244c5ef822d53618ca/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=6c5caf00a8f24a9ad808fc244c5ef822d53618ca", "patch": "@@ -3455,33 +3455,6 @@ which.\n @c above is overfull.  not sure what to do.  --mew 5feb93  did\n @c something, not sure if it looks good.  --mew 10feb93\n \n-@defmac MAYBE_REG_PARM_STACK_SPACE\n-@defmacx FINAL_REG_PARM_STACK_SPACE (@var{const_size}, @var{var_size})\n-Define these macros in addition to the one above if functions might\n-allocate stack space for arguments even when their values are passed\n-in registers.  These should be used when the stack space allocated\n-for arguments in registers is not a simple constant independent of the\n-function declaration.\n-\n-The value of the first macro is the size, in bytes, of the area that\n-we should initially assume would be reserved for arguments passed in registers.\n-\n-The value of the second macro is the actual size, in bytes, of the area\n-that will be reserved for arguments passed in registers.  This takes two\n-arguments: an integer representing the number of bytes of fixed sized\n-arguments on the stack, and a tree representing the number of bytes of\n-variable sized arguments on the stack.\n-\n-When these macros are defined, @code{REG_PARM_STACK_SPACE} will only be\n-called for libcall functions, the current function, or for a function\n-being called when it is known that such stack space must be allocated.\n-In each case this value can be easily computed.\n-\n-When deciding whether a called function needs such stack space, and how\n-much space to reserve, GCC uses these two macros instead of\n-@code{REG_PARM_STACK_SPACE}.\n-@end defmac\n-\n @defmac OUTGOING_REG_PARM_STACK_SPACE\n Define this if it is the responsibility of the caller to allocate the area\n reserved for arguments passed in registers."}, {"sha": "b811f3d0e18e4ea891ed528fb29e9aad7ca5f30f", "filename": "gcc/function.c", "status": "modified", "additions": 4, "deletions": 23, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c5caf00a8f24a9ad808fc244c5ef822d53618ca/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c5caf00a8f24a9ad808fc244c5ef822d53618ca/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=6c5caf00a8f24a9ad808fc244c5ef822d53618ca", "patch": "@@ -4347,12 +4347,8 @@ assign_parms (tree fndecl)\n     fnargs = split_complex_args (fnargs);\n \n #ifdef REG_PARM_STACK_SPACE\n-#ifdef MAYBE_REG_PARM_STACK_SPACE\n-  reg_parm_stack_space = MAYBE_REG_PARM_STACK_SPACE;\n-#else\n   reg_parm_stack_space = REG_PARM_STACK_SPACE (fndecl);\n #endif\n-#endif\n \n #ifdef INIT_CUMULATIVE_INCOMING_ARGS\n   INIT_CUMULATIVE_INCOMING_ARGS (args_so_far, fntype, NULL_RTX);\n@@ -4554,12 +4550,9 @@ assign_parms (tree fndecl)\n \t  partial = FUNCTION_ARG_PARTIAL_NREGS (args_so_far, promoted_mode,\n \t\t\t\t\t\tpassed_type, named_arg);\n \t  if (partial\n-#ifndef MAYBE_REG_PARM_STACK_SPACE\n \t      /* The caller might already have allocated stack space\n \t\t for the register parameters.  */\n-\t      && reg_parm_stack_space == 0\n-#endif\n-\t      )\n+\t      && reg_parm_stack_space == 0)\n \t    {\n \t      /* Part of this argument is passed in registers and part\n \t\t is passed on the stack.  Ask the prologue code to extend\n@@ -4660,16 +4653,10 @@ assign_parms (tree fndecl)\n       if (entry_parm == stack_parm\n \t  || (GET_CODE (entry_parm) == PARALLEL\n \t      && XEXP (XVECEXP (entry_parm, 0, 0), 0) == NULL_RTX)\n-#if defined (REG_PARM_STACK_SPACE) && ! defined (MAYBE_REG_PARM_STACK_SPACE)\n+#if defined (REG_PARM_STACK_SPACE)\n \t  /* On some machines, even if a parm value arrives in a register\n-\t     there is still an (uninitialized) stack slot allocated for it.\n-\n-\t     ??? When MAYBE_REG_PARM_STACK_SPACE is defined, we can't tell\n-\t     whether this parameter already has a stack slot allocated,\n-\t     because an arg block exists only if current_function_args_size\n-\t     is larger than some threshold, and we haven't calculated that\n-\t     yet.  So, for now, we just assume that stack slots never exist\n-\t     in this case.  */\n+\t     there is still an (uninitialized) stack slot allocated\n+\t     for it.  */\n \t  || REG_PARM_STACK_SPACE (fndecl) > 0\n #endif\n \t  )\n@@ -5292,10 +5279,8 @@ assign_parms (tree fndecl)\n      minimum length.  */\n \n #ifdef REG_PARM_STACK_SPACE\n-#ifndef MAYBE_REG_PARM_STACK_SPACE\n   current_function_args_size = MAX (current_function_args_size,\n \t\t\t\t    REG_PARM_STACK_SPACE (fndecl));\n-#endif\n #endif\n \n   current_function_args_size\n@@ -5490,11 +5475,7 @@ locate_and_pad_parm (enum machine_mode passed_mode, tree type, int in_regs,\n   int part_size_in_regs;\n \n #ifdef REG_PARM_STACK_SPACE\n-#ifdef MAYBE_REG_PARM_STACK_SPACE\n-  reg_parm_stack_space = MAYBE_REG_PARM_STACK_SPACE;\n-#else\n   reg_parm_stack_space = REG_PARM_STACK_SPACE (fndecl);\n-#endif\n \n   /* If we have found a stack parm before we reach the end of the\n      area reserved for registers, skip that area.  */"}, {"sha": "5e8a2cdbaab5b74b04d2fe94a07c76600370bff1", "filename": "gcc/system.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c5caf00a8f24a9ad808fc244c5ef822d53618ca/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c5caf00a8f24a9ad808fc244c5ef822d53618ca/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=6c5caf00a8f24a9ad808fc244c5ef822d53618ca", "patch": "@@ -637,7 +637,8 @@ typedef char _Bool;\n \tPROMOTED_MODE EXPAND_BUILTIN_VA_END\t\t\t\t   \\\n \tLINKER_DOES_NOT_WORK_WITH_DWARF2 FUNCTION_ARG_KEEP_AS_REFERENCE\t   \\\n \tGIV_SORT_CRITERION MAX_LONG_TYPE_SIZE MAX_LONG_DOUBLE_TYPE_SIZE\t   \\\n-\tMAX_WCHAR_TYPE_SIZE GCOV_TYPE_SIZE SHARED_SECTION_ASM_OP\n+\tMAX_WCHAR_TYPE_SIZE GCOV_TYPE_SIZE SHARED_SECTION_ASM_OP\t   \\\n+\tFINAL_REG_PARM_STACK_SPACE MAYBE_REG_PARM_STACK_SPACE\n \n /* Hooks that are no longer used.  */\n  #pragma GCC poison LANG_HOOKS_FUNCTION_MARK LANG_HOOKS_FUNCTION_FREE\t\\"}]}