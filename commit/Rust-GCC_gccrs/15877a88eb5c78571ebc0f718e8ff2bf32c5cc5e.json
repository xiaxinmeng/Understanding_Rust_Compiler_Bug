{"sha": "15877a88eb5c78571ebc0f718e8ff2bf32c5cc5e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTU4NzdhODhlYjVjNzg1NzFlYmMwZjcxOGU4ZmYyYmYzMmM1Y2M1ZQ==", "commit": {"author": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2008-05-15T15:53:34Z"}, "committer": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2008-05-15T15:53:34Z"}, "message": "Part 1 of PR 25561.\n\n2008-05-15  Janne Blomqvist  <jb@gcc.gnu.org>\n\n\tPR libfortran/25561\n\t* Makefile.am: Add fbuf.c to gfor_io_src.\n\t* Makefile.in: Regenerate.\n\t* io/io.h (read_block): Remove.\n\t(struct stream): Remove alloc_r_at function pointer.\n\t(salloc_r): Remove.\n\t(salloc_r_at): Remove.\n\t(salloc_w_at): Remove.\n\t(salloc_w): Remove offset argument.\n\t(struct fbuf): New struct for format buffer.\n\t(struct gfc_unit): Add fbuf.\n\t(read_block_form): New prototype.\n\t(fbuf_init): Likewise.\n\t(fbuf_destroy): Likewise.\n\t(fbuf_reset): Likewise.\n\t(fbuf_alloc): Likewise.\n\t(fbuf_flush): Likewise.\n\t(fbuf_seek): Likewise.\n\t* io/file_pos.c (formatted_backspace): Change to use sread.\n\t(unformatted_backspace): Likewise.\n\t(st_backspace): Flush format buffer.\n\t(st_rewind): Likewise.\n\t* io/list_read.c (next_char): Likewise.\n\t(nml_query): Tidying, flush format buffer.\n\t* io/open.c (new_unit): Init format buffer.\n\t* io/read.c (read_l): Change to use read_block_form.\n\t(read_a): Likewise.\n\t(read_decimal): Likewise.\n\t(read_radix): Likewise.\n\t(read_f): Likewise.\n\t(read_x): Empty reads also for stream I/O.\n\t* io/transfer.c (read_sf): Change to use sread.\n\t(read_block): Rename to read_block_form, change prototype, use sread.\n\t(read_block_direct): Don't seek stream files.\n\t(write_block): Change to use fbuf if external file, don't seek stream\n\tfiles.\n\t(write_buf): Don't seek stream files.\n\t(formatted_transfer_scalar): Use fbuf for external files.\n\t(us_read): Change to use sread.\n\t(pre_position): Do nothing for stream I/O.\n\t(data_transfer_init): Flush fbuf when switching from write to read, if\n\tPOS is specified, seek stream file to correct offset.\n\t(skip_record): Change to use sread.\n\t(min_off): New function.\n\t(next_record_r): Change to use sread.\n\t(next_record_w): Change to use sset/sseek, flush fbuf.\n\t(finalize_transfer): Flush fbuf.\n\t* io/unit.c (init_units): Init fbuf for stdout, stderr.\n\t(close_unit_1): Destroy fbuf.\n\t(finish_last_advance_record): Flush fbuf, no need to seek.\n\t* io/unix.c (fd_alloc_r_at): Remove unused where argument.\n\t(fd_alloc_w_at): Likewise.\n\t(fd_read): Remove third argument to fd_alloc_r_at.\n\t(fd_write): Remove third argument to fd_alloc_w_at.\n\t(fd_sset): Likewise.\n\t(fd_open): Don't set alloc_r_at.\n\t(mem_alloc_r_at): Remove unused where argument.\n\t(mem_alloc_w_at): Likewise.\n\t(mem_read): Don't incorrectly return previous errno, remove unused\n\tthird argument to alloc function.\n\t(mem_write): Likewise.\n\t(mem_set): Likewise.\n\t(open_internal): Don't set alloc_r_at pointer.\n\t* io/fbuf.c: New file.\n\nFrom-SVN: r135373", "tree": {"sha": "92c8aa4fe936ead640e8d996aa90baaf7c81a1a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/92c8aa4fe936ead640e8d996aa90baaf7c81a1a9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/15877a88eb5c78571ebc0f718e8ff2bf32c5cc5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15877a88eb5c78571ebc0f718e8ff2bf32c5cc5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15877a88eb5c78571ebc0f718e8ff2bf32c5cc5e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15877a88eb5c78571ebc0f718e8ff2bf32c5cc5e/comments", "author": null, "committer": null, "parents": [{"sha": "2819ae08d2787c83eb63e8526082a983fe9335c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2819ae08d2787c83eb63e8526082a983fe9335c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2819ae08d2787c83eb63e8526082a983fe9335c9"}], "stats": {"total": 672, "additions": 370, "deletions": 302}, "files": [{"sha": "ed7ad21801ca10d9bfdb43050a05b9514f1b4ceb", "filename": "libgfortran/Makefile.am", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15877a88eb5c78571ebc0f718e8ff2bf32c5cc5e/libgfortran%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15877a88eb5c78571ebc0f718e8ff2bf32c5cc5e/libgfortran%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.am?ref=15877a88eb5c78571ebc0f718e8ff2bf32c5cc5e", "patch": "@@ -47,7 +47,8 @@ io/size_from_kind.c \\\n io/transfer.c \\\n io/unit.c \\\n io/unix.c \\\n-io/write.c\n+io/write.c \\\n+io/fbuf.c\n \n gfor_io_headers= \\\n io/io.h"}, {"sha": "1db39915eab31fa876d69787a9a0741a425a9d23", "filename": "libgfortran/Makefile.in", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15877a88eb5c78571ebc0f718e8ff2bf32c5cc5e/libgfortran%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15877a88eb5c78571ebc0f718e8ff2bf32c5cc5e/libgfortran%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.in?ref=15877a88eb5c78571ebc0f718e8ff2bf32c5cc5e", "patch": "@@ -401,8 +401,8 @@ am__libgfortran_la_SOURCES_DIST = runtime/backtrace.c \\\n \tfpu-target.h io/close.c io/file_pos.c io/format.c io/inquire.c \\\n \tio/intrinsics.c io/list_read.c io/lock.c io/open.c io/read.c \\\n \tio/size_from_kind.c io/transfer.c io/unit.c io/unix.c \\\n-\tio/write.c intrinsics/associated.c intrinsics/abort.c \\\n-\tintrinsics/access.c intrinsics/args.c \\\n+\tio/write.c io/fbuf.c intrinsics/associated.c \\\n+\tintrinsics/abort.c intrinsics/access.c intrinsics/args.c \\\n \tintrinsics/c99_functions.c intrinsics/chdir.c \\\n \tintrinsics/chmod.c intrinsics/clock.c intrinsics/cpu_time.c \\\n \tintrinsics/cshift0.c intrinsics/ctime.c \\\n@@ -691,7 +691,7 @@ am__objects_33 = $(am__objects_2) $(am__objects_3) $(am__objects_4) \\\n \t$(am__objects_32)\n am__objects_34 = close.lo file_pos.lo format.lo inquire.lo \\\n \tintrinsics.lo list_read.lo lock.lo open.lo read.lo \\\n-\tsize_from_kind.lo transfer.lo unit.lo unix.lo write.lo\n+\tsize_from_kind.lo transfer.lo unit.lo unix.lo write.lo fbuf.lo\n am__objects_35 = associated.lo abort.lo access.lo args.lo \\\n \tc99_functions.lo chdir.lo chmod.lo clock.lo cpu_time.lo \\\n \tcshift0.lo ctime.lo date_and_time.lo dtime.lo env.lo \\\n@@ -946,7 +946,8 @@ io/size_from_kind.c \\\n io/transfer.c \\\n io/unit.c \\\n io/unix.c \\\n-io/write.c\n+io/write.c \\\n+io/fbuf.c\n \n gfor_io_headers = \\\n io/io.h\n@@ -1791,6 +1792,7 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/exponent_r16.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/exponent_r4.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/exponent_r8.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/fbuf.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/file_pos.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/fmain.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/fnum.Plo@am__quote@\n@@ -5124,6 +5126,13 @@ write.lo: io/write.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o write.lo `test -f 'io/write.c' || echo '$(srcdir)/'`io/write.c\n \n+fbuf.lo: io/fbuf.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT fbuf.lo -MD -MP -MF \"$(DEPDIR)/fbuf.Tpo\" -c -o fbuf.lo `test -f 'io/fbuf.c' || echo '$(srcdir)/'`io/fbuf.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/fbuf.Tpo\" \"$(DEPDIR)/fbuf.Plo\"; else rm -f \"$(DEPDIR)/fbuf.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='io/fbuf.c' object='fbuf.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o fbuf.lo `test -f 'io/fbuf.c' || echo '$(srcdir)/'`io/fbuf.c\n+\n associated.lo: intrinsics/associated.c\n @am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT associated.lo -MD -MP -MF \"$(DEPDIR)/associated.Tpo\" -c -o associated.lo `test -f 'intrinsics/associated.c' || echo '$(srcdir)/'`intrinsics/associated.c; \\\n @am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/associated.Tpo\" \"$(DEPDIR)/associated.Plo\"; else rm -f \"$(DEPDIR)/associated.Tpo\"; exit 1; fi"}, {"sha": "f4864884f33162ffbae8d26c0ecf3ad9ce36d43f", "filename": "libgfortran/io/file_pos.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15877a88eb5c78571ebc0f718e8ff2bf32c5cc5e/libgfortran%2Fio%2Ffile_pos.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15877a88eb5c78571ebc0f718e8ff2bf32c5cc5e/libgfortran%2Fio%2Ffile_pos.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ffile_pos.c?ref=15877a88eb5c78571ebc0f718e8ff2bf32c5cc5e", "patch": "@@ -39,24 +39,24 @@ Boston, MA 02110-1301, USA.  */\n    record, and we have to sift backwards to find the newline before\n    that or the start of the file, whichever comes first.  */\n \n-#define READ_CHUNK 4096\n+static const unsigned int READ_CHUNK = 4096;\n \n static void\n formatted_backspace (st_parameter_filepos *fpp, gfc_unit *u)\n {\n   gfc_offset base;\n-  char *p;\n-  int n;\n+  char p[READ_CHUNK];\n+  size_t n;\n \n   base = file_position (u->s) - 1;\n \n   do\n     {\n       n = (base < READ_CHUNK) ? base : READ_CHUNK;\n       base -= n;\n-\n-      p = salloc_r_at (u->s, &n, base);\n-      if (p == NULL)\n+      if (sseek (u->s, base) == FAILURE)\n+        goto io_error;\n+      if (sread (u->s, p, &n) != 0)\n \tgoto io_error;\n \n       /* We have moved backwards from the current position, it should\n@@ -66,15 +66,14 @@ formatted_backspace (st_parameter_filepos *fpp, gfc_unit *u)\n       /* There is no memrchr() in the C library, so we have to do it\n          ourselves.  */\n \n-      n--;\n-      while (n >= 0)\n+      while (n > 0)\n \t{\n+          n--;\n \t  if (p[n] == '\\n')\n \t    {\n \t      base += n + 1;\n \t      goto done;\n \t    }\n-\t  n--;\n \t}\n \n     }\n@@ -104,9 +103,9 @@ unformatted_backspace (st_parameter_filepos *fpp, gfc_unit *u)\n   gfc_offset m, new;\n   GFC_INTEGER_4 m4;\n   GFC_INTEGER_8 m8;\n-  int length, length_read;\n+  size_t length;\n   int continued;\n-  char *p;\n+  char p[sizeof (GFC_INTEGER_8)];\n \n   if (compile_options.record_marker == 0)\n     length = sizeof (GFC_INTEGER_4);\n@@ -115,12 +114,10 @@ unformatted_backspace (st_parameter_filepos *fpp, gfc_unit *u)\n \n   do\n     {\n-      length_read = length;\n-\n-      p = salloc_r_at (u->s, &length_read,\n-\t\t       file_position (u->s) - length);\n-      if (p == NULL || length_read != length)\n-\tgoto io_error;\n+      if (sseek (u->s, file_position (u->s) - length) == FAILURE)\n+        goto io_error;\n+      if (sread (u->s, p, &length) != 0)\n+        goto io_error;\n \n       /* Only GFC_CONVERT_NATIVE and GFC_CONVERT_SWAP are valid here.  */\n       if (u->flags.convert == GFC_CONVERT_NATIVE)\n@@ -216,6 +213,9 @@ st_backspace (st_parameter_filepos *fpp)\n \tgoto done;\n       }\n \n+  /* Make sure format buffer is flushed.  */\n+  fbuf_flush (u, 1);\n+  \n   /* Check for special cases involving the ENDFILE record first.  */\n \n   if (u->endfile == AFTER_ENDFILE)"}, {"sha": "e554d8cccbc4b927dbb505edb84790bf77e53119", "filename": "libgfortran/io/io.h", "status": "modified", "additions": 45, "deletions": 9, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15877a88eb5c78571ebc0f718e8ff2bf32c5cc5e/libgfortran%2Fio%2Fio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15877a88eb5c78571ebc0f718e8ff2bf32c5cc5e/libgfortran%2Fio%2Fio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fio.h?ref=15877a88eb5c78571ebc0f718e8ff2bf32c5cc5e", "patch": "@@ -49,8 +49,7 @@ struct st_parameter_dt;\n \n typedef struct stream\n {\n-  char *(*alloc_w_at) (struct stream *, int *, gfc_offset);\n-  char *(*alloc_r_at) (struct stream *, int *, gfc_offset);\n+  char *(*alloc_w_at) (struct stream *, int *);\n   try (*sfree) (struct stream *);\n   try (*close) (struct stream *);\n   try (*seek) (struct stream *, gfc_offset);\n@@ -70,11 +69,7 @@ io_mode;\n #define sfree(s) ((s)->sfree)(s)\n #define sclose(s) ((s)->close)(s)\n \n-#define salloc_r(s, len) ((s)->alloc_r_at)(s, len, -1)\n-#define salloc_w(s, len) ((s)->alloc_w_at)(s, len, -1)\n-\n-#define salloc_r_at(s, len, where) ((s)->alloc_r_at)(s, len, where)\n-#define salloc_w_at(s, len, where) ((s)->alloc_w_at)(s, len, where)\n+#define salloc_w(s, len) ((s)->alloc_w_at)(s, len)\n \n #define sseek(s, pos) ((s)->seek)(s, pos)\n #define struncate(s) ((s)->trunc)(s)\n@@ -528,6 +523,25 @@ typedef struct\n unit_flags;\n \n \n+/* Formatting buffer. This is a temporary scratch buffer. Currently used only\n+   by formatted writes. After every\n+   formatted write statement, this buffer is flushed. This buffer is needed since\n+   not all devices are seekable, and T or TL edit descriptors require \n+   moving backwards in the record.  However, advance='no' complicates the\n+   situation, so the buffer must only be partially flushed from the end of the\n+   last flush until the current position in the record. */\n+\n+typedef struct fbuf\n+{\n+  char *buf;\t\t\t/* Start of buffer.  */\n+  size_t len;\t\t\t/* Length of buffer.  */\n+  size_t act;\t\t\t/* Active bytes in buffer.  */\n+  size_t flushed;\t\t/* Flushed bytes from beginning of buffer.  */\n+  char *ptr;\t\t\t/* Current position in buffer.  */\n+}\n+fbuf;\n+\n+\n typedef struct gfc_unit\n {\n   int unit_number;\n@@ -578,6 +592,9 @@ typedef struct gfc_unit\n \n   int file_len;\n   char *file;\n+  \n+  /* Formatting buffer.  */\n+  struct fbuf *fbuf;\n }\n gfc_unit;\n \n@@ -812,8 +829,8 @@ internal_proto(free_format_data);\n extern const char *type_name (bt);\n internal_proto(type_name);\n \n-extern void *read_block (st_parameter_dt *, int *);\n-internal_proto(read_block);\n+extern try read_block_form (st_parameter_dt *, void *, size_t *);\n+internal_proto(read_block_form);\n \n extern char *read_sf (st_parameter_dt *, int *, int);\n internal_proto(read_sf);\n@@ -931,6 +948,25 @@ internal_proto(size_from_real_kind);\n extern size_t size_from_complex_kind (int);\n internal_proto(size_from_complex_kind);\n \n+/* fbuf.c */\n+extern void fbuf_init (gfc_unit *, size_t);\n+internal_proto(fbuf_init);\n+\n+extern void fbuf_destroy (gfc_unit *);\n+internal_proto(fbuf_destroy);\n+\n+extern void fbuf_reset (gfc_unit *);\n+internal_proto(fbuf_reset);\n+\n+extern char * fbuf_alloc (gfc_unit *, size_t);\n+internal_proto(fbuf_alloc);\n+\n+extern int fbuf_flush (gfc_unit *, int);\n+internal_proto(fbuf_flush);\n+\n+extern int fbuf_seek (gfc_unit *, gfc_offset);\n+internal_proto(fbuf_seek);\n+\n /* lock.c */\n extern void free_ionml (st_parameter_dt *);\n internal_proto(free_ionml);"}, {"sha": "3837f7ecf2e5cdae108793d10986c42b55f6cf57", "filename": "libgfortran/io/list_read.c", "status": "modified", "additions": 34, "deletions": 54, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15877a88eb5c78571ebc0f718e8ff2bf32c5cc5e/libgfortran%2Fio%2Flist_read.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15877a88eb5c78571ebc0f718e8ff2bf32c5cc5e/libgfortran%2Fio%2Flist_read.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Flist_read.c?ref=15877a88eb5c78571ebc0f718e8ff2bf32c5cc5e", "patch": "@@ -140,9 +140,9 @@ free_line (st_parameter_dt *dtp)\n static char\n next_char (st_parameter_dt *dtp)\n {\n-  int length;\n+  size_t length;\n   gfc_offset record;\n-  char c, *p;\n+  char c;\n \n   if (dtp->u.p.last_char != '\\0')\n     {\n@@ -206,43 +206,40 @@ next_char (st_parameter_dt *dtp)\n \n   length = 1;\n \n-  p = salloc_r (dtp->u.p.current_unit->s, &length);\n+  if (sread (dtp->u.p.current_unit->s, &c, &length) != 0)\n+    {\n+\tgenerate_error (&dtp->common, LIBERROR_OS, NULL);\n+\treturn '\\0';\n+    }\n   \n-  if (is_stream_io (dtp))\n+  if (is_stream_io (dtp) && length == 1)\n     dtp->u.p.current_unit->strm_pos++;\n \n   if (is_internal_unit (dtp))\n     {\n       if (is_array_io (dtp))\n \t{\n-\t  /* End of record is handled in the next pass through, above.  The\n-\t     check for NULL here is cautionary.  */\n-\t  if (p == NULL)\n+\t  /* Check whether we hit EOF.  */ \n+\t  if (length == 0)\n \t    {\n \t      generate_error (&dtp->common, LIBERROR_INTERNAL_UNIT, NULL);\n \t      return '\\0';\n-\t    }\n-\n+\t    } \n \t  dtp->u.p.current_unit->bytes_left--;\n-\t  c = *p;\n \t}\n       else\n \t{\n-\t  if (p == NULL)\n+\t  if (dtp->u.p.at_eof) \n \t    longjmp (*dtp->u.p.eof_jump, 1);\n \t  if (length == 0)\n-\t    c = '\\n';\n-\t  else\n-\t    c = *p;\n+\t    {\n+\t      c = '\\n';\n+\t      dtp->u.p.at_eof = 1;\n+\t    }\n \t}\n     }\n   else\n     {\n-      if (p == NULL)\n-\t{\n-\t  generate_error (&dtp->common, LIBERROR_OS, NULL);\n-\t  return '\\0';\n-\t}\n       if (length == 0)\n \t{\n \t  if (dtp->u.p.advance_status == ADVANCE_NO)\n@@ -255,8 +252,6 @@ next_char (st_parameter_dt *dtp)\n \t  else\n \t    longjmp (*dtp->u.p.eof_jump, 1);\n \t}\n-      else\n-\tc = *p;\n     }\n done:\n   dtp->u.p.at_eol = (c == '\\n' || c == '\\r');\n@@ -2226,6 +2221,15 @@ nml_query (st_parameter_dt *dtp, char c)\n   namelist_info * nl;\n   index_type len;\n   char * p;\n+#ifdef HAVE_CRLF\n+  static const index_type endlen = 3;\n+  static const char endl[] = \"\\r\\n\";\n+  static const char nmlend[] = \"&end\\r\\n\";\n+#else\n+  static const index_type endlen = 2;\n+  static const char endl[] = \"\\n\";\n+  static const char nmlend[] = \"&end\\n\";\n+#endif\n \n   if (dtp->u.p.current_unit->unit_number != options.stdin_unit)\n     return;\n@@ -2252,59 +2256,35 @@ nml_query (st_parameter_dt *dtp, char c)\n \t  /* \"&namelist_name\\n\"  */\n \n \t  len = dtp->namelist_name_len;\n-#ifdef HAVE_CRLF\n-\t  p = write_block (dtp, len + 3);\n-#else\n-\t  p = write_block (dtp, len + 2);\n-#endif\n-\t  if (!p)\n-\t    goto query_return;\n+\t  p = write_block (dtp, len + endlen);\n+          if (!p)\n+            goto query_return;\n \t  memcpy (p, \"&\", 1);\n \t  memcpy ((char*)(p + 1), dtp->namelist_name, len);\n-#ifdef HAVE_CRLF\n-\t  memcpy ((char*)(p + len + 1), \"\\r\\n\", 2);\n-#else\n-\t  memcpy ((char*)(p + len + 1), \"\\n\", 1);\n-#endif\n+\t  memcpy ((char*)(p + len + 1), &endl, endlen - 1);\n \t  for (nl = dtp->u.p.ionml; nl; nl = nl->next)\n \t    {\n \t      /* \" var_name\\n\"  */\n \n \t      len = strlen (nl->var_name);\n-#ifdef HAVE_CRLF\n-\t      p = write_block (dtp, len + 3);\n-#else\n-\t      p = write_block (dtp, len + 2);\n-#endif\n+              p = write_block (dtp, len + endlen);\n \t      if (!p)\n \t\tgoto query_return;\n \t      memcpy (p, \" \", 1);\n \t      memcpy ((char*)(p + 1), nl->var_name, len);\n-#ifdef HAVE_CRLF\n-\t      memcpy ((char*)(p + len + 1), \"\\r\\n\", 2);\n-#else\n-\t      memcpy ((char*)(p + len + 1), \"\\n\", 1);\n-#endif\n+\t      memcpy ((char*)(p + len + 1), &endl, endlen - 1);\n \t    }\n \n \t  /* \"&end\\n\"  */\n \n-#ifdef HAVE_CRLF\n-\t  p = write_block (dtp, 6);\n-#else\n-\t  p = write_block (dtp, 5);\n-#endif\n-\t  if (!p)\n+          p = write_block (dtp, endlen + 3);\n \t    goto query_return;\n-#ifdef HAVE_CRLF\n-\t  memcpy (p, \"&end\\r\\n\", 6);\n-#else\n-\t  memcpy (p, \"&end\\n\", 5);\n-#endif\n+          memcpy (p, &nmlend, endlen + 3);\n \t}\n \n       /* Flush the stream to force immediate output.  */\n \n+      fbuf_flush (dtp->u.p.current_unit, 1);\n       flush (dtp->u.p.current_unit->s);\n       unlock_unit (dtp->u.p.current_unit);\n     }"}, {"sha": "e16386cabd783a8c7b814108da62d8c4d58e6bc5", "filename": "libgfortran/io/open.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15877a88eb5c78571ebc0f718e8ff2bf32c5cc5e/libgfortran%2Fio%2Fopen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15877a88eb5c78571ebc0f718e8ff2bf32c5cc5e/libgfortran%2Fio%2Fopen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fopen.c?ref=15877a88eb5c78571ebc0f718e8ff2bf32c5cc5e", "patch": "@@ -626,6 +626,13 @@ new_unit (st_parameter_open *opp, gfc_unit *u, unit_flags * flags)\n \n   if (flags->status == STATUS_SCRATCH && opp->file != NULL)\n     free_mem (opp->file);\n+    \n+  if (flags->form == FORM_FORMATTED && (flags->action != ACTION_READ))\n+    fbuf_init (u, 0);\n+  else\n+    u->fbuf = NULL;\n+    \n+    \n   return u;\n \n  cleanup:"}, {"sha": "a09d663dc1ca67ed7478d9c9b56e08b33bfff6a3", "filename": "libgfortran/io/read.c", "status": "modified", "additions": 60, "deletions": 41, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15877a88eb5c78571ebc0f718e8ff2bf32c5cc5e/libgfortran%2Fio%2Fread.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15877a88eb5c78571ebc0f718e8ff2bf32c5cc5e/libgfortran%2Fio%2Fread.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fread.c?ref=15877a88eb5c78571ebc0f718e8ff2bf32c5cc5e", "patch": "@@ -36,6 +36,7 @@ Boston, MA 02110-1301, USA.  */\n \n /* read.c -- Deal with formatted reads */\n \n+\n /* set_integer()-- All of the integer assignments come here to\n  * actually place the value into memory.  */\n \n@@ -192,11 +193,13 @@ void\n read_l (st_parameter_dt *dtp, const fnode *f, char *dest, int length)\n {\n   char *p;\n-  int w;\n+  size_t w;\n \n   w = f->u.w;\n-  p = read_block (dtp, &w);\n-  if (p == NULL)\n+\n+  p = gfc_alloca (w);\n+\n+  if (read_block_form (dtp, p, &w) == FAILURE)\n     return;\n \n   while (*p == ' ')\n@@ -238,24 +241,29 @@ read_l (st_parameter_dt *dtp, const fnode *f, char *dest, int length)\n void\n read_a (st_parameter_dt *dtp, const fnode *f, char *p, int length)\n {\n-  char *source;\n-  int w, m, n;\n+  char *s;\n+  int m, n, wi, status;\n+  size_t w;\n \n-  w = f->u.w;\n-  if (w == -1) /* '(A)' edit descriptor  */\n-    w = length;\n+  wi = f->u.w;\n+  if (wi == -1) /* '(A)' edit descriptor  */\n+    wi = length;\n+\n+  w = wi;\n+\n+  s = gfc_alloca (w);\n \n   dtp->u.p.sf_read_comma = 0;\n-  source = read_block (dtp, &w);\n+  status = read_block_form (dtp, s, &w);\n   dtp->u.p.sf_read_comma =\n     dtp->u.p.decimal_status == DECIMAL_COMMA ? 0 : 1;\n-  if (source == NULL)\n+  if (status == FAILURE)\n     return;\n-  if (w > length)\n-     source += (w - length);\n+  if (w > (size_t) length)\n+     s += (w - length);\n \n-  m = (w > length) ? length : w;\n-  memcpy (p, source, m);\n+  m = ((int) w > length) ? length : (int) w;\n+  memcpy (p, s, m);\n \n   n = length - w;\n   if (n > 0)\n@@ -323,14 +331,19 @@ read_decimal (st_parameter_dt *dtp, const fnode *f, char *dest, int length)\n {\n   GFC_UINTEGER_LARGEST value, maxv, maxv_10;\n   GFC_INTEGER_LARGEST v;\n-  int w, negative;\n+  int w, negative; \n+  size_t wu;\n   char c, *p;\n \n-  w = f->u.w;\n-  p = read_block (dtp, &w);\n-  if (p == NULL)\n+  wu = f->u.w;\n+\n+  p = gfc_alloca (wu);\n+\n+  if (read_block_form (dtp, p, &wu) == FAILURE)\n     return;\n \n+  w = wu;\n+\n   p = eat_leading_spaces (&w, p);\n   if (w == 0)\n     {\n@@ -406,7 +419,7 @@ read_decimal (st_parameter_dt *dtp, const fnode *f, char *dest, int length)\n   generate_error (&dtp->common, LIBERROR_READ_OVERFLOW,\n \t\t  \"Value overflowed during integer read\");\n   next_record (dtp, 1);\n-  return;\n+\n }\n \n \n@@ -423,12 +436,17 @@ read_radix (st_parameter_dt *dtp, const fnode *f, char *dest, int length,\n   GFC_INTEGER_LARGEST v;\n   int w, negative;\n   char c, *p;\n+  size_t wu;\n \n-  w = f->u.w;\n-  p = read_block (dtp, &w);\n-  if (p == NULL)\n+  wu = f->u.w;\n+\n+  p = gfc_alloca (wu);\n+\n+  if (read_block_form (dtp, p, &wu) == FAILURE)\n     return;\n \n+  w = wu;\n+\n   p = eat_leading_spaces (&w, p);\n   if (w == 0)\n     {\n@@ -552,7 +570,7 @@ read_radix (st_parameter_dt *dtp, const fnode *f, char *dest, int length,\n   generate_error (&dtp->common, LIBERROR_READ_OVERFLOW,\n \t\t  \"Value overflowed during integer read\");\n   next_record (dtp, 1);\n-  return;\n+\n }\n \n \n@@ -565,6 +583,7 @@ read_radix (st_parameter_dt *dtp, const fnode *f, char *dest, int length,\n void\n read_f (st_parameter_dt *dtp, const fnode *f, char *dest, int length)\n {\n+  size_t wu;\n   int w, seen_dp, exponent;\n   int exponent_sign, val_sign;\n   int ndigits;\n@@ -576,11 +595,15 @@ read_f (st_parameter_dt *dtp, const fnode *f, char *dest, int length)\n \n   val_sign = 1;\n   seen_dp = 0;\n-  w = f->u.w;\n-  p = read_block (dtp, &w);\n-  if (p == NULL)\n+  wu = f->u.w;\n+\n+  p = gfc_alloca (wu);\n+\n+  if (read_block_form (dtp, p, &wu) == FAILURE)\n     return;\n \n+  w = wu;\n+\n   p = eat_leading_spaces (&w, p);\n   if (w == 0)\n     goto zero;\n@@ -842,27 +865,23 @@ read_f (st_parameter_dt *dtp, const fnode *f, char *dest, int length)\n   if (buffer != scratch)\n      free_mem (buffer);\n \n-  return;\n }\n \n \n /* read_x()-- Deal with the X/TR descriptor.  We just read some data\n  * and never look at it. */\n \n void\n-read_x (st_parameter_dt *dtp, int n)\n+read_x (st_parameter_dt * dtp, int n)\n {\n-  if (!is_stream_io (dtp))\n-    {\n-      if ((dtp->u.p.pad_status == PAD_NO || is_internal_unit (dtp))\n-\t  && dtp->u.p.current_unit->bytes_left < n)\n-\tn = dtp->u.p.current_unit->bytes_left;\n-\n-      dtp->u.p.sf_read_comma = 0;\n-      if (n > 0)\n-\tread_sf (dtp, &n, 1);\n-      dtp->u.p.sf_read_comma = 1;\n-    }\n-  else\n-    dtp->u.p.current_unit->strm_pos += (gfc_offset) n;\n+  if ((dtp->u.p.pad_status == PAD_NO || is_internal_unit (dtp))\n+      && dtp->u.p.current_unit->bytes_left < n)\n+    n = dtp->u.p.current_unit->bytes_left;\n+\n+  dtp->u.p.sf_read_comma = 0;\n+  if (n > 0)\n+    read_sf (dtp, &n, 1);\n+  dtp->u.p.sf_read_comma = 1;\n+  dtp->u.p.current_unit->strm_pos += (gfc_offset) n;\n }\n+"}, {"sha": "8353f3ddb74c9495f1a5990dea7232fb132b55c8", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 163, "deletions": 141, "changes": 304, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15877a88eb5c78571ebc0f718e8ff2bf32c5cc5e/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15877a88eb5c78571ebc0f718e8ff2bf32c5cc5e/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=15877a88eb5c78571ebc0f718e8ff2bf32c5cc5e", "patch": "@@ -36,6 +36,7 @@ Boston, MA 02110-1301, USA.  */\n #include \"io.h\"\n #include <string.h>\n #include <assert.h>\n+#include <stdlib.h>\n \n \n /* Calling conventions:  Data transfer statements are unlike other\n@@ -180,9 +181,10 @@ current_mode (st_parameter_dt *dtp)\n char *\n read_sf (st_parameter_dt *dtp, int *length, int no_error)\n {\n-  char *base, *p, *q;\n-  int n, readlen, crlf;\n+  char *base, *p, q;\n+  int n, crlf;\n   gfc_offset pos;\n+  size_t readlen;\n \n   if (*length > SCRATCH_SIZE)\n     dtp->u.p.line_buffer = get_mem (*length);\n@@ -199,15 +201,12 @@ read_sf (st_parameter_dt *dtp, int *length, int no_error)\n   if (is_internal_unit (dtp))\n     {\n       readlen = *length;\n-      q = salloc_r (dtp->u.p.current_unit->s, &readlen);\n-      if (readlen < *length)\n+      if (sread (dtp->u.p.current_unit->s, p, &readlen) != 0 || readlen < (size_t) *length)\n \t{\n \t  generate_error (&dtp->common, LIBERROR_END, NULL);\n \t  return NULL;\n \t}\n \t\n-      if (q != NULL)\n-        memcpy (p, q, readlen);\n       goto done;\n     }\n \n@@ -216,9 +215,11 @@ read_sf (st_parameter_dt *dtp, int *length, int no_error)\n \n   do\n     {\n-      q = salloc_r (dtp->u.p.current_unit->s, &readlen);\n-      if (q == NULL)\n-\tbreak;\n+      if (sread (dtp->u.p.current_unit->s, &q, &readlen) != 0)\n+        {\n+\t  generate_error (&dtp->common, LIBERROR_END, NULL);\n+\t  return NULL;\n+\t}\n \n       /* If we have a line without a terminating \\n, drop through to\n \t EOR below.  */\n@@ -230,7 +231,7 @@ read_sf (st_parameter_dt *dtp, int *length, int no_error)\n \t  return NULL;\n \t}\n \n-      if (readlen < 1 || *q == '\\n' || *q == '\\r')\n+      if (readlen < 1 || q == '\\n' || q == '\\r')\n \t{\n \t  /* Unexpected end of line.  */\n \n@@ -241,12 +242,16 @@ read_sf (st_parameter_dt *dtp, int *length, int no_error)\n \n \t  crlf = 0;\n \t  /* If we encounter a CR, it might be a CRLF.  */\n-\t  if (*q == '\\r') /* Probably a CRLF */\n+\t  if (q == '\\r') /* Probably a CRLF */\n \t    {\n \t      readlen = 1;\n \t      pos = stream_offset (dtp->u.p.current_unit->s);\n-\t      q = salloc_r (dtp->u.p.current_unit->s, &readlen);\n-\t      if (*q != '\\n' && readlen == 1) /* Not a CRLF after all.  */\n+\t      if (sread (dtp->u.p.current_unit->s, &q, &readlen) != 0)\n+\t        {\n+\t\t  generate_error (&dtp->common, LIBERROR_END, NULL);\n+\t\t  return NULL;\n+\t\t}\n+\t      if (q != '\\n' && readlen == 1) /* Not a CRLF after all.  */\n \t\tsseek (dtp->u.p.current_unit->s, pos);\n \t      else\n \t\tcrlf = 1;\n@@ -270,7 +275,7 @@ read_sf (st_parameter_dt *dtp, int *length, int no_error)\n       /*  Short circuit the read if a comma is found during numeric input.\n \t  The flag is set to zero during character reads so that commas in\n \t  strings are not ignored  */\n-      if (*q == ',')\n+      if (q == ',')\n \tif (dtp->u.p.sf_read_comma == 1)\n \t  {\n \t    notify_std (&dtp->common, GFC_STD_GNU,\n@@ -280,7 +285,7 @@ read_sf (st_parameter_dt *dtp, int *length, int no_error)\n \t  }\n \n       n++;\n-      *p++ = *q;\n+      *p++ = q;\n       dtp->u.p.sf_seen_eor = 0;\n     }\n   while (n < *length);\n@@ -296,35 +301,25 @@ read_sf (st_parameter_dt *dtp, int *length, int no_error)\n \n \n /* Function for reading the next couple of bytes from the current\n-   file, advancing the current position.  We return a pointer to a\n-   buffer containing the bytes.  We return NULL on end of record or\n-   end of file.\n+   file, advancing the current position. We return FAILURE on end of record or\n+   end of file. This function is only for formatted I/O, unformatted uses\n+   read_block_direct.\n \n    If the read is short, then it is because the current record does not\n    have enough data to satisfy the read request and the file was\n    opened with PAD=YES.  The caller must assume tailing spaces for\n    short reads.  */\n \n-void *\n-read_block (st_parameter_dt *dtp, int *length)\n+try\n+read_block_form (st_parameter_dt *dtp, void *buf, size_t *nbytes)\n {\n   char *source;\n-  int nread;\n+  size_t nread;\n+  int nb;\n \n-  if (is_stream_io (dtp))\n-    {\n-      if (dtp->u.p.current_unit->strm_pos - 1\n-\t  != file_position (dtp->u.p.current_unit->s)\n-\t  && sseek (dtp->u.p.current_unit->s,\n-\t\t    dtp->u.p.current_unit->strm_pos - 1) == FAILURE)\n-\t{\n-\t  generate_error (&dtp->common, LIBERROR_END, NULL);\n-\t  return NULL;\n-\t}\n-    }\n-  else\n+  if (!is_stream_io (dtp))\n     {\n-      if (dtp->u.p.current_unit->bytes_left < (gfc_offset) *length)\n+      if (dtp->u.p.current_unit->bytes_left < (gfc_offset) *nbytes)\n \t{\n \t  /* For preconnected units with default record length, set bytes left\n \t   to unit record length and proceed, otherwise error.  */\n@@ -337,42 +332,51 @@ read_block (st_parameter_dt *dtp, int *length)\n \t\t{\n \t\t  /* Not enough data left.  */\n \t\t  generate_error (&dtp->common, LIBERROR_EOR, NULL);\n-\t\t  return NULL;\n+\t\t  return FAILURE;\n \t\t}\n \t    }\n \n \t  if (dtp->u.p.current_unit->bytes_left == 0)\n \t    {\n \t      dtp->u.p.current_unit->endfile = AT_ENDFILE;\n \t      generate_error (&dtp->common, LIBERROR_END, NULL);\n-\t      return NULL;\n+\t      return FAILURE;\n \t    }\n \n-\t  *length = dtp->u.p.current_unit->bytes_left;\n+\t  *nbytes = dtp->u.p.current_unit->bytes_left;\n \t}\n     }\n \n   if (dtp->u.p.current_unit->flags.form == FORM_FORMATTED &&\n       (dtp->u.p.current_unit->flags.access == ACCESS_SEQUENTIAL ||\n        dtp->u.p.current_unit->flags.access == ACCESS_STREAM))\n     {\n-      source = read_sf (dtp, length, 0);\n+      nb = *nbytes;\n+      source = read_sf (dtp, &nb, 0);\n+      *nbytes = nb;\n       dtp->u.p.current_unit->strm_pos +=\n-\t(gfc_offset) (*length + dtp->u.p.sf_seen_eor);\n-      return source;\n+\t(gfc_offset) (*nbytes + dtp->u.p.sf_seen_eor);\n+      if (source == NULL)\n+\treturn FAILURE;\n+      memcpy (buf, source, *nbytes);\n+      return SUCCESS;\n     }\n-  dtp->u.p.current_unit->bytes_left -= (gfc_offset) *length;\n+  dtp->u.p.current_unit->bytes_left -= (gfc_offset) *nbytes;\n \n-  nread = *length;\n-  source = salloc_r (dtp->u.p.current_unit->s, &nread);\n+  nread = *nbytes;\n+  if (sread (dtp->u.p.current_unit->s, buf, &nread) != 0)\n+    {\n+      generate_error (&dtp->common, LIBERROR_OS, NULL);\n+      return FAILURE;\n+    }\n \n   if ((dtp->common.flags & IOPARM_DT_HAS_SIZE) != 0)\n     dtp->u.p.size_used += (gfc_offset) nread;\n \n-  if (nread != *length)\n+  if (nread != *nbytes)\n     {\t\t\t\t/* Short read, this shouldn't happen.  */\n       if (dtp->u.p.pad_status == PAD_YES)\n-\t*length = nread;\n+\t*nbytes = nread;\n       else\n \t{\n \t  generate_error (&dtp->common, LIBERROR_EOR, NULL);\n@@ -382,7 +386,7 @@ read_block (st_parameter_dt *dtp, int *length)\n \n   dtp->u.p.current_unit->strm_pos += (gfc_offset) nread;\n \n-  return source;\n+  return SUCCESS;\n }\n \n \n@@ -400,15 +404,6 @@ read_block_direct (st_parameter_dt *dtp, void *buf, size_t *nbytes)\n \n   if (is_stream_io (dtp))\n     {\n-      if (dtp->u.p.current_unit->strm_pos - 1\n-\t  != file_position (dtp->u.p.current_unit->s)\n-\t  && sseek (dtp->u.p.current_unit->s,\n-\t\t    dtp->u.p.current_unit->strm_pos - 1) == FAILURE)\n-\t{\n-\t  generate_error (&dtp->common, LIBERROR_END, NULL);\n-\t  return;\n-\t}\n-\n       to_read_record = *nbytes;\n       have_read_record = to_read_record;\n       if (sread (dtp->u.p.current_unit->s, buf, &have_read_record) != 0)\n@@ -576,18 +571,7 @@ write_block (st_parameter_dt *dtp, int length)\n {\n   char *dest;\n \n-  if (is_stream_io (dtp))\n-    {\n-      if (dtp->u.p.current_unit->strm_pos - 1\n-\t  != file_position (dtp->u.p.current_unit->s)\n-\t  && sseek (dtp->u.p.current_unit->s,\n-\t\t    dtp->u.p.current_unit->strm_pos - 1) == FAILURE)\n-\t{\n-\t  generate_error (&dtp->common, LIBERROR_OS, NULL);\n-\t  return NULL;\n-\t}\n-    }\n-  else\n+  if (!is_stream_io (dtp))\n     {\n       if (dtp->u.p.current_unit->bytes_left < (gfc_offset) length)\n \t{\n@@ -607,17 +591,29 @@ write_block (st_parameter_dt *dtp, int length)\n       dtp->u.p.current_unit->bytes_left -= (gfc_offset) length;\n     }\n \n-  dest = salloc_w (dtp->u.p.current_unit->s, &length);\n-\n-  if (dest == NULL)\n+  if (is_internal_unit (dtp))\n     {\n-      generate_error (&dtp->common, LIBERROR_END, NULL);\n-      return NULL;\n-    }\n+    dest = salloc_w (dtp->u.p.current_unit->s, &length);\n \n-  if (is_internal_unit (dtp) && dtp->u.p.current_unit->endfile == AT_ENDFILE)\n-    generate_error (&dtp->common, LIBERROR_END, NULL);\n+    if (dest == NULL)\n+      {\n+        generate_error (&dtp->common, LIBERROR_END, NULL);\n+        return NULL;\n+      }\n \n+    if (dtp->u.p.current_unit->endfile == AT_ENDFILE)\n+      generate_error (&dtp->common, LIBERROR_END, NULL);\n+    }\n+  else\n+    {\n+      dest = fbuf_alloc (dtp->u.p.current_unit, length);\n+      if (dest == NULL)\n+        {\n+          generate_error (&dtp->common, LIBERROR_OS, NULL);\n+          return NULL;\n+        }\n+    }\n+    \n   if ((dtp->common.flags & IOPARM_DT_HAS_SIZE) != 0)\n     dtp->u.p.size_used += (gfc_offset) length;\n \n@@ -642,15 +638,6 @@ write_buf (st_parameter_dt *dtp, void *buf, size_t nbytes)\n \n   if (is_stream_io (dtp))\n     {\n-      if (dtp->u.p.current_unit->strm_pos - 1\n-\t  != file_position (dtp->u.p.current_unit->s)\n-\t  && sseek (dtp->u.p.current_unit->s,\n-\t\t    dtp->u.p.current_unit->strm_pos - 1) == FAILURE)\n-\t{\n-\t  generate_error (&dtp->common, LIBERROR_OS, NULL);\n-\t  return FAILURE;\n-\t}\n-\n       if (swrite (dtp->u.p.current_unit->s, buf, &nbytes) != 0)\n \t{\n \t  generate_error (&dtp->common, LIBERROR_OS, NULL);\n@@ -866,7 +853,7 @@ static void\n write_constant_string (st_parameter_dt *dtp, const fnode *f)\n {\n   char c, delimiter, *p, *q;\n-  int length;\n+  int length; \n \n   length = f->u.string.length;\n   if (length == 0)\n@@ -875,7 +862,7 @@ write_constant_string (st_parameter_dt *dtp, const fnode *f)\n   p = write_block (dtp, length);\n   if (p == NULL)\n     return;\n-\n+    \n   q = f->u.string.p;\n   delimiter = q[-1];\n \n@@ -993,7 +980,10 @@ formatted_transfer_scalar (st_parameter_dt *dtp, bt type, void *p, int len,\n \t    }\n \t  if (dtp->u.p.skips < 0)\n \t    {\n-\t      move_pos_offset (dtp->u.p.current_unit->s, dtp->u.p.skips);\n+              if (is_internal_unit (dtp))  \n+\t        move_pos_offset (dtp->u.p.current_unit->s, dtp->u.p.skips);\n+              else\n+                fbuf_seek (dtp->u.p.current_unit, dtp->u.p.skips);\n \t      dtp->u.p.current_unit->bytes_left -= (gfc_offset) dtp->u.p.skips;\n \t    }\n \t  dtp->u.p.skips = dtp->u.p.pending_spaces = 0;\n@@ -1606,9 +1596,7 @@ transfer_array (st_parameter_dt *dtp, gfc_array_char *desc, int kind,\n static void\n us_read (st_parameter_dt *dtp, int continued)\n {\n-  char *p;\n-  int n;\n-  int nr;\n+  size_t n, nr;\n   GFC_INTEGER_4 i4;\n   GFC_INTEGER_8 i8;\n   gfc_offset i;\n@@ -1623,15 +1611,19 @@ us_read (st_parameter_dt *dtp, int continued)\n \n   nr = n;\n \n-  p = salloc_r (dtp->u.p.current_unit->s, &n);\n+  if (sread (dtp->u.p.current_unit->s, &i, &n) != 0)\n+    {\n+      generate_error (&dtp->common, LIBERROR_BAD_US, NULL);\n+      return;\n+    }\n \n   if (n == 0)\n     {\n       dtp->u.p.current_unit->endfile = AT_ENDFILE;\n       return;  /* end of file */\n     }\n \n-  if (p == NULL || n != nr)\n+  if (n != nr)\n     {\n       generate_error (&dtp->common, LIBERROR_BAD_US, NULL);\n       return;\n@@ -1643,12 +1635,12 @@ us_read (st_parameter_dt *dtp, int continued)\n       switch (nr)\n \t{\n \tcase sizeof(GFC_INTEGER_4):\n-\t  memcpy (&i4, p, sizeof (i4));\n+\t  memcpy (&i4, &i, sizeof (i4));\n \t  i = i4;\n \t  break;\n \n \tcase sizeof(GFC_INTEGER_8):\n-\t  memcpy (&i8, p, sizeof (i8));\n+\t  memcpy (&i8, &i, sizeof (i8));\n \t  i = i8;\n \t  break;\n \n@@ -1661,12 +1653,12 @@ us_read (st_parameter_dt *dtp, int continued)\n       switch (nr)\n \t{\n \tcase sizeof(GFC_INTEGER_4):\n-\t  reverse_memcpy (&i4, p, sizeof (i4));\n+\t  reverse_memcpy (&i4, &i, sizeof (i4));\n \t  i = i4;\n \t  break;\n \n \tcase sizeof(GFC_INTEGER_8):\n-\t  reverse_memcpy (&i8, p, sizeof (i8));\n+\t  reverse_memcpy (&i8, &i, sizeof (i8));\n \t  i = i8;\n \t  break;\n \n@@ -1734,10 +1726,10 @@ pre_position (st_parameter_dt *dtp)\n     {\n     case FORMATTED_STREAM:\n     case UNFORMATTED_STREAM:\n-      /* There are no records with stream I/O.  Set the default position\n-\t to the beginning of the file if no position was specified.  */\n-      if ((dtp->common.flags & IOPARM_DT_HAS_REC) == 0)\n-        dtp->u.p.current_unit->strm_pos = 1;\n+      /* There are no records with stream I/O.  If the position was specified\n+\t data_transfer_init has already positioned the file. If no position\n+\t was specified, we continue from where we last left off.  I.e.\n+\t there is nothing to do here.  */\n       break;\n     \n     case UNFORMATTED_SEQUENTIAL:\n@@ -2070,7 +2062,10 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n       if (dtp->u.p.mode == READING\n \t  && dtp->u.p.current_unit->mode == WRITING\n \t  && !is_internal_unit (dtp))\n-\tflush(dtp->u.p.current_unit->s);\n+        {\n+          fbuf_flush (dtp->u.p.current_unit, 1);      \n+\t  flush(dtp->u.p.current_unit->s);\n+        }\n \n       /* Check whether the record exists to be read.  Only\n \t a partial record needs to exist.  */\n@@ -2094,11 +2089,21 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n \t    }\n \t}\n       else\n-\tdtp->u.p.current_unit->strm_pos = dtp->rec;\n+        {\n+\t  if (dtp->u.p.current_unit->strm_pos != dtp->rec)\n+\t    {\n+\t      fbuf_flush (dtp->u.p.current_unit, 1);\n+\t      flush (dtp->u.p.current_unit->s);\n+\t      if (sseek (dtp->u.p.current_unit->s, dtp->rec - 1) == FAILURE)\n+\t        {\n+\t          generate_error (&dtp->common, LIBERROR_OS, NULL);\n+\t          return;\n+\t        }\n+\t      dtp->u.p.current_unit->strm_pos = dtp->rec;\n+\t    }\n+        }\n \n     }\n-  else\n-    dtp->rec = 0;\n \n   /* Overwriting an existing sequential file ?\n      it is always safe to truncate the file on the first write */\n@@ -2118,6 +2123,7 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n   dtp->u.p.max_pos = dtp->u.p.current_unit->saved_pos;\n \n   pre_position (dtp);\n+  \n \n   /* Set up the subroutine that will handle the transfers.  */\n \n@@ -2256,14 +2262,13 @@ next_array_record (st_parameter_dt *dtp, array_loop_spec *ls, int *finished)\n    read chunks of size MAX_READ until we get to the right\n    position.  */\n \n-#define MAX_READ 4096\n-\n static void\n skip_record (st_parameter_dt *dtp, size_t bytes)\n {\n   gfc_offset new;\n-  int rlength, length;\n-  char *p;\n+  size_t rlength;\n+  static const size_t MAX_READ = 4096;\n+  char p[MAX_READ];\n \n   dtp->u.p.current_unit->bytes_left_subrecord += bytes;\n   if (dtp->u.p.current_unit->bytes_left_subrecord == 0)\n@@ -2283,24 +2288,22 @@ skip_record (st_parameter_dt *dtp, size_t bytes)\n     {\t\t\t/* Seek by reading data.  */\n       while (dtp->u.p.current_unit->bytes_left_subrecord > 0)\n \t{\n-\t  rlength = length =\n-\t    (MAX_READ > dtp->u.p.current_unit->bytes_left_subrecord) ?\n+\t  rlength = \n+\t    (MAX_READ > (size_t) dtp->u.p.current_unit->bytes_left_subrecord) ?\n \t    MAX_READ : dtp->u.p.current_unit->bytes_left_subrecord;\n \n-\t  p = salloc_r (dtp->u.p.current_unit->s, &rlength);\n-\t  if (p == NULL)\n+\t  if (sread (dtp->u.p.current_unit->s, p, &rlength) != 0)\n \t    {\n \t      generate_error (&dtp->common, LIBERROR_OS, NULL);\n \t      return;\n \t    }\n \n-\t  dtp->u.p.current_unit->bytes_left_subrecord -= length;\n+\t  dtp->u.p.current_unit->bytes_left_subrecord -= rlength;\n \t}\n     }\n \n }\n \n-#undef MAX_READ\n \n /* Advance to the next record reading unformatted files, taking\n    care of subrecords.  If complete_record is nonzero, we loop\n@@ -2328,14 +2331,23 @@ next_record_r_unf (st_parameter_dt *dtp, int complete_record)\n     }\n }\n \n+\n+static inline gfc_offset\n+min_off (gfc_offset a, gfc_offset b)\n+{\n+  return (a < b ? a : b);\n+}\n+\n+\n /* Space to the next record for read mode.  */\n \n static void\n next_record_r (st_parameter_dt *dtp)\n {\n   gfc_offset record;\n-  int length, bytes_left;\n-  char *p;\n+  int bytes_left;\n+  size_t length;\n+  char p;\n \n   switch (current_mode (dtp))\n     {\n@@ -2384,18 +2396,24 @@ next_record_r (st_parameter_dt *dtp)\n \t  else  \n \t    {\n \t      bytes_left = (int) dtp->u.p.current_unit->bytes_left;\n-\t      p = salloc_r (dtp->u.p.current_unit->s, &bytes_left);\n-\t      if (p != NULL)\n-\t\tdtp->u.p.current_unit->bytes_left\n-\t\t  = dtp->u.p.current_unit->recl;\n+\t      bytes_left = min_off (bytes_left, \n+\t\t      file_length (dtp->u.p.current_unit->s)\n+\t\t      - file_position (dtp->u.p.current_unit->s));\n+\t      if (sseek (dtp->u.p.current_unit->s, \n+\t\t\t  file_position (dtp->u.p.current_unit->s) \n+\t\t\t  + bytes_left) == FAILURE)\n+\t        {\n+\t\t  generate_error (&dtp->common, LIBERROR_INTERNAL_UNIT, NULL);\n+\t\t  break;\n+\t\t}\n+\t      dtp->u.p.current_unit->bytes_left\n+\t\t= dtp->u.p.current_unit->recl;\n \t    } \n \t  break;\n \t}\n       else do\n \t{\n-\t  p = salloc_r (dtp->u.p.current_unit->s, &length);\n-\n-\t  if (p == NULL)\n+\t  if (sread (dtp->u.p.current_unit->s, &p, &length) != 0) \n \t    {\n \t      generate_error (&dtp->common, LIBERROR_OS, NULL);\n \t      break;\n@@ -2410,7 +2428,7 @@ next_record_r (st_parameter_dt *dtp)\n \t  if (is_stream_io (dtp))\n \t    dtp->u.p.current_unit->strm_pos++;\n \t}\n-      while (*p != '\\n');\n+      while (p != '\\n');\n \n       break;\n     }\n@@ -2550,8 +2568,10 @@ next_record_w (st_parameter_dt *dtp, int done)\n {\n   gfc_offset m, record, max_pos;\n   int length;\n-  char *p;\n \n+  /* Flush and reset the format buffer.  */\n+  fbuf_flush (dtp->u.p.current_unit, 1);\n+  \n   /* Zero counters for X- and T-editing.  */\n   max_pos = dtp->u.p.max_pos;\n   dtp->u.p.max_pos = dtp->u.p.skips = dtp->u.p.pending_spaces = 0;\n@@ -2576,12 +2596,9 @@ next_record_w (st_parameter_dt *dtp, int done)\n       if (dtp->u.p.current_unit->bytes_left > 0)\n \t{\n \t  length = (int) dtp->u.p.current_unit->bytes_left;\n-\t  p = salloc_w (dtp->u.p.current_unit->s, &length);\n-\t  memset (p, 0, length);\n+\t  if (sset (dtp->u.p.current_unit->s, 0, length) == FAILURE)\n+\t    goto io_error;\n \t}\n-\n-      if (sfree (dtp->u.p.current_unit->s) == FAILURE)\n-\tgoto io_error;\n       break;\n \n     case UNFORMATTED_SEQUENTIAL:\n@@ -2609,7 +2626,13 @@ next_record_w (st_parameter_dt *dtp, int done)\n \t      if (max_pos > m)\n \t\t{\n \t\t  length = (int) (max_pos - m);\n-\t\t  p = salloc_w (dtp->u.p.current_unit->s, &length);\n+\t\t  if (sseek (dtp->u.p.current_unit->s, \n+\t\t\t      file_position (dtp->u.p.current_unit->s) \n+\t\t\t      + length) == FAILURE)\n+\t\t    {\n+\t\t      generate_error (&dtp->common, LIBERROR_INTERNAL_UNIT, NULL);\n+\t\t      return;\n+\t\t    }\n \t\t  length = (int) (dtp->u.p.current_unit->recl - max_pos);\n \t\t}\n \n@@ -2651,7 +2674,13 @@ next_record_w (st_parameter_dt *dtp, int done)\n \t\t  if (max_pos > m)\n \t\t    {\n \t\t      length = (int) (max_pos - m);\n-\t\t      p = salloc_w (dtp->u.p.current_unit->s, &length);\n+\t\t      if (sseek (dtp->u.p.current_unit->s, \n+\t\t\t\t  file_position (dtp->u.p.current_unit->s)\n+\t\t\t\t  + length) == FAILURE)\n+\t\t        {\n+\t\t\t  generate_error (&dtp->common, LIBERROR_INTERNAL_UNIT, NULL);\n+\t\t\t  return;\n+\t\t\t}\n \t\t      length = (int) (dtp->u.p.current_unit->recl - max_pos);\n \t\t    }\n \t\t  else\n@@ -2670,15 +2699,6 @@ next_record_w (st_parameter_dt *dtp, int done)\n \t  size_t len;\n \t  const char crlf[] = \"\\r\\n\";\n \n-\t  /* Move to the farthest position reached in preparation for\n-\t  completing the record.  (for file unit) */\n-\t  m = dtp->u.p.current_unit->recl -\n-\t    dtp->u.p.current_unit->bytes_left;\n-\t  if (max_pos > m)\n-\t    {\n-\t      length = (int) (max_pos - m);\n-\t      p = salloc_w (dtp->u.p.current_unit->s, &length);\n-\t    }\n #ifdef HAVE_CRLF\n \t  len = 2;\n #else\n@@ -2818,6 +2838,7 @@ finalize_transfer (st_parameter_dt *dtp)\n   if (!is_internal_unit (dtp) && dtp->u.p.seen_dollar)\n     {\n       dtp->u.p.seen_dollar = 0;\n+      fbuf_flush (dtp->u.p.current_unit, 1);\n       sfree (dtp->u.p.current_unit->s);\n       return;\n     }\n@@ -2830,6 +2851,7 @@ finalize_transfer (st_parameter_dt *dtp)\n \t- dtp->u.p.current_unit->bytes_left);\n       dtp->u.p.current_unit->saved_pos =\n \tdtp->u.p.max_pos > 0 ? dtp->u.p.max_pos - bytes_written : 0;\n+      fbuf_flush (dtp->u.p.current_unit, 0);\n       flush (dtp->u.p.current_unit->s);\n       return;\n     }"}, {"sha": "69563187553348d1b85714647aa10de61c93b0e6", "filename": "libgfortran/io/unit.c", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15877a88eb5c78571ebc0f718e8ff2bf32c5cc5e/libgfortran%2Fio%2Funit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15877a88eb5c78571ebc0f718e8ff2bf32c5cc5e/libgfortran%2Fio%2Funit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Funit.c?ref=15877a88eb5c78571ebc0f718e8ff2bf32c5cc5e", "patch": "@@ -567,6 +567,8 @@ init_units (void)\n       u->file_len = strlen (stdout_name);\n       u->file = get_mem (u->file_len);\n       memmove (u->file, stdout_name, u->file_len);\n+      \n+      fbuf_init (u, 0);\n \n       __gthread_mutex_unlock (&u->lock);\n     }\n@@ -594,6 +596,9 @@ init_units (void)\n       u->file_len = strlen (stderr_name);\n       u->file = get_mem (u->file_len);\n       memmove (u->file, stderr_name, u->file_len);\n+      \n+      fbuf_init (u, 256);  /* 256 bytes should be enough, probably not doing\n+                              any kind of exotic formatting to stderr.  */\n \n       __gthread_mutex_unlock (&u->lock);\n     }\n@@ -613,7 +618,7 @@ static int\n close_unit_1 (gfc_unit *u, int locked)\n {\n   int i, rc;\n-\n+  \n   /* If there are previously written bytes from a write with ADVANCE=\"no\"\n      Reposition the buffer before closing.  */\n   if (u->previous_nonadvancing_write)\n@@ -635,6 +640,8 @@ close_unit_1 (gfc_unit *u, int locked)\n     free_mem (u->file);\n   u->file = NULL;\n   u->file_len = 0;\n+  \n+  fbuf_destroy (u);\n \n   if (!locked)\n     __gthread_mutex_unlock (&u->lock);\n@@ -737,10 +744,11 @@ filename_from_unit (int n)\n void\n finish_last_advance_record (gfc_unit *u)\n {\n-  char *p;\n-\n+  \n   if (u->saved_pos > 0)\n-    p = salloc_w (u->s, &u->saved_pos);\n+    fbuf_seek (u, u->saved_pos);\n+    \n+  fbuf_flush (u, 1);\n \n   if (!(u->unit_number == options.stdout_unit\n \t|| u->unit_number == options.stderr_unit))"}, {"sha": "295838022852f013c85884bcec811b4d8c3953de", "filename": "libgfortran/io/unix.c", "status": "modified", "additions": 17, "deletions": 31, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15877a88eb5c78571ebc0f718e8ff2bf32c5cc5e/libgfortran%2Fio%2Funix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15877a88eb5c78571ebc0f718e8ff2bf32c5cc5e/libgfortran%2Fio%2Funix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Funix.c?ref=15877a88eb5c78571ebc0f718e8ff2bf32c5cc5e", "patch": "@@ -530,12 +530,10 @@ fd_alloc (unix_stream * s, gfc_offset where,\n  * NULL on I/O error. */\n \n static char *\n-fd_alloc_r_at (unix_stream * s, int *len, gfc_offset where)\n+fd_alloc_r_at (unix_stream * s, int *len)\n {\n   gfc_offset m;\n-\n-  if (where == -1)\n-    where = s->logical_offset;\n+  gfc_offset where = s->logical_offset;\n \n   if (s->buffer != NULL && s->buffer_offset <= where &&\n       where + *len <= s->buffer_offset + s->active)\n@@ -593,12 +591,10 @@ fd_alloc_r_at (unix_stream * s, int *len, gfc_offset where)\n  * we've already buffered the data or we need to load it. */\n \n static char *\n-fd_alloc_w_at (unix_stream * s, int *len, gfc_offset where)\n+fd_alloc_w_at (unix_stream * s, int *len)\n {\n   gfc_offset n;\n-\n-  if (where == -1)\n-    where = s->logical_offset;\n+  gfc_offset where = s->logical_offset;\n \n   if (s->buffer == NULL || s->buffer_offset > where ||\n       where + *len > s->buffer_offset + s->len)\n@@ -752,7 +748,7 @@ fd_sset (unix_stream * s, int c, size_t n)\n       /* memset() in chunks of BUFFER_SIZE.  */\n       trans = (bytes_left < BUFFER_SIZE) ? bytes_left : BUFFER_SIZE;\n \n-      p = fd_alloc_w_at (s, &trans, -1);\n+      p = fd_alloc_w_at (s, &trans);\n       if (p)\n \t  memset (p, c, trans);\n       else\n@@ -779,7 +775,7 @@ fd_read (unix_stream * s, void * buf, size_t * nbytes)\n   if (*nbytes < BUFFER_SIZE && s->method == SYNC_BUFFERED)\n     {\n       tmp = *nbytes;\n-      p = fd_alloc_r_at (s, &tmp, -1);\n+      p = fd_alloc_r_at (s, &tmp);\n       if (p)\n \t{\n \t  *nbytes = tmp;\n@@ -827,7 +823,7 @@ fd_write (unix_stream * s, const void * buf, size_t * nbytes)\n   if (*nbytes < BUFFER_SIZE && s->method == SYNC_BUFFERED)\n     {\n       tmp = *nbytes;\n-      p = fd_alloc_w_at (s, &tmp, -1);\n+      p = fd_alloc_w_at (s, &tmp);\n       if (p)\n \t{\n \t  *nbytes = tmp;\n@@ -890,7 +886,6 @@ fd_open (unix_stream * s)\n   else\n     s->method = SYNC_BUFFERED;\n \n-  s->st.alloc_r_at = (void *) fd_alloc_r_at;\n   s->st.alloc_w_at = (void *) fd_alloc_w_at;\n   s->st.sfree = (void *) fd_sfree;\n   s->st.close = (void *) fd_close;\n@@ -918,12 +913,10 @@ fd_open (unix_stream * s)\n \n \n static char *\n-mem_alloc_r_at (int_stream * s, int *len, gfc_offset where)\n+mem_alloc_r_at (int_stream * s, int *len)\n {\n   gfc_offset n;\n-\n-  if (where == -1)\n-    where = s->logical_offset;\n+  gfc_offset where = s->logical_offset;\n \n   if (where < s->buffer_offset || where > s->buffer_offset + s->active)\n     return NULL;\n@@ -939,15 +932,13 @@ mem_alloc_r_at (int_stream * s, int *len, gfc_offset where)\n \n \n static char *\n-mem_alloc_w_at (int_stream * s, int *len, gfc_offset where)\n+mem_alloc_w_at (int_stream * s, int *len)\n {\n   gfc_offset m;\n+  gfc_offset where = s->logical_offset;\n \n   assert (*len >= 0);  /* Negative values not allowed. */\n   \n-  if (where == -1)\n-    where = s->logical_offset;\n-\n   m = where + *len;\n \n   if (where < s->buffer_offset)\n@@ -962,9 +953,7 @@ mem_alloc_w_at (int_stream * s, int *len, gfc_offset where)\n }\n \n \n-/* Stream read function for internal units. This is not actually used\n-   at the moment, as all internal IO is formatted and the formatted IO\n-   routines use mem_alloc_r_at.  */\n+/* Stream read function for internal units.  */\n \n static int\n mem_read (int_stream * s, void * buf, size_t * nbytes)\n@@ -973,7 +962,7 @@ mem_read (int_stream * s, void * buf, size_t * nbytes)\n   int tmp;\n \n   tmp = *nbytes;\n-  p = mem_alloc_r_at (s, &tmp, -1);\n+  p = mem_alloc_r_at (s, &tmp);\n   if (p)\n     {\n       *nbytes = tmp;\n@@ -983,7 +972,7 @@ mem_read (int_stream * s, void * buf, size_t * nbytes)\n   else\n     {\n       *nbytes = 0;\n-      return errno;\n+      return 0;\n     }\n }\n \n@@ -998,10 +987,8 @@ mem_write (int_stream * s, const void * buf, size_t * nbytes)\n   void *p;\n   int tmp;\n \n-  errno = 0;\n-\n   tmp = *nbytes;\n-  p = mem_alloc_w_at (s, &tmp, -1);\n+  p = mem_alloc_w_at (s, &tmp);\n   if (p)\n     {\n       *nbytes = tmp;\n@@ -1011,7 +998,7 @@ mem_write (int_stream * s, const void * buf, size_t * nbytes)\n   else\n     {\n       *nbytes = 0;\n-      return errno;\n+      return 0;\n     }\n }\n \n@@ -1038,7 +1025,7 @@ mem_set (int_stream * s, int c, size_t n)\n \n   len = n;\n   \n-  p = mem_alloc_w_at (s, &len, -1);\n+  p = mem_alloc_w_at (s, &len);\n   if (p)\n     {\n       memset (p, c, len);\n@@ -1104,7 +1091,6 @@ open_internal (char *base, int length, gfc_offset offset)\n   s->logical_offset = 0;\n   s->active = s->file_length = length;\n \n-  s->st.alloc_r_at = (void *) mem_alloc_r_at;\n   s->st.alloc_w_at = (void *) mem_alloc_w_at;\n   s->st.sfree = (void *) mem_sfree;\n   s->st.close = (void *) mem_close;"}]}