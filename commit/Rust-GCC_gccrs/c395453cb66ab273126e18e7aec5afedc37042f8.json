{"sha": "c395453cb66ab273126e18e7aec5afedc37042f8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzM5NTQ1M2NiNjZhYjI3MzEyNmUxOGU3YWVjNWFmZWRjMzcwNDJmOA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-06-30T07:16:35Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-06-30T07:16:35Z"}, "message": "cp-tree.h (struct language_function): Remove temp_name_counter.\n\n\t* cp-tree.h (struct language_function): Remove temp_name_counter.\n\t(temp_name_counter): Remove.\n\t(get_temp_name): Change prototype.\n\t(get_guard): New function.\n\t(get_guard_cond): Likewise.\n\t(set_guard): Likewise.\n\t* cvt.c (build_up_reference): Adjust call to get_temp_name.\n\t* decl.c (expand_static_init): Use get_guard and friends to\n\timplement guard variables.\n\t* decl2.c (get_temp_name): Assume that the variables created are\n\talways static.\n\t(get_sentry): Rename to ...\n\t(get_guard): ... this.  Implement new ABI guard\tvariables.\n\t(get_guard_bits): New function.\n\t(get_guard_cond): Likewise.\n\t(set_guard): Likewise.\n\t(start_static_initialization_or_destruction): Use them.\n\t(do_static_initialization): Replace sentry with guard throughout.\n\t(do_static_destruction): Likewise.\n\t* init.c (create_temporary_var): Add comment.\n\nFrom-SVN: r34803", "tree": {"sha": "02782e15a7890f06a14c2de21649dec03a5d3c13", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/02782e15a7890f06a14c2de21649dec03a5d3c13"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c395453cb66ab273126e18e7aec5afedc37042f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c395453cb66ab273126e18e7aec5afedc37042f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c395453cb66ab273126e18e7aec5afedc37042f8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c395453cb66ab273126e18e7aec5afedc37042f8/comments", "author": null, "committer": null, "parents": [{"sha": "c1c8f8cc4f1ece37f1f9a3d415fce73f6b5172ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1c8f8cc4f1ece37f1f9a3d415fce73f6b5172ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1c8f8cc4f1ece37f1f9a3d415fce73f6b5172ee"}], "stats": {"total": 279, "additions": 191, "deletions": 88}, "files": [{"sha": "46544015e803b93f295343f5270b418effefe555", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c395453cb66ab273126e18e7aec5afedc37042f8/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c395453cb66ab273126e18e7aec5afedc37042f8/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=c395453cb66ab273126e18e7aec5afedc37042f8", "patch": "@@ -1,3 +1,26 @@\n+2000-06-30  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.h (struct language_function): Remove temp_name_counter.\n+\t(temp_name_counter): Remove.\n+\t(get_temp_name): Change prototype.\n+\t(get_guard): New function.\n+\t(get_guard_cond): Likewise.\n+\t(set_guard): Likewise.\n+\t* cvt.c (build_up_reference): Adjust call to get_temp_name.\n+\t* decl.c (expand_static_init): Use get_guard and friends to\n+\timplement guard variables.\n+\t* decl2.c (get_temp_name): Assume that the variables created are\n+\talways static.\n+\t(get_sentry): Rename to ...\n+\t(get_guard): ... this.  Implement new ABI guard\tvariables.\n+\t(get_guard_bits): New function.\n+\t(get_guard_cond): Likewise.\n+\t(set_guard): Likewise.\n+\t(start_static_initialization_or_destruction): Use them.\n+\t(do_static_initialization): Replace sentry with guard throughout.\n+\t(do_static_destruction): Likewise.\n+\t* init.c (create_temporary_var): Add comment.\n+\t\n 2000-06-29  Mark Mitchell  <mark@codesourcery.com>\n \n \t* cp-tree.h (flag_const_strings): Remove."}, {"sha": "fb37a3d39ca7a25a585cf15f8dc1774f7f1c377c", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c395453cb66ab273126e18e7aec5afedc37042f8/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c395453cb66ab273126e18e7aec5afedc37042f8/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=c395453cb66ab273126e18e7aec5afedc37042f8", "patch": "@@ -900,7 +900,6 @@ struct language_function\n   int returns_value;\n   int returns_null;\n   int parms_stored;\n-  int temp_name_counter;\n   int in_function_try_handler;\n   int x_expanding_p;\n   int name_declared;\n@@ -1004,11 +1003,6 @@ struct language_function\n \n #define vtbls_set_up_p cp_function_chain->vtbls_set_up_p\n \n-/* Used to help generate temporary names which are unique within\n-   a function.  Reset to 0 by start_function.  */\n-\n-#define temp_name_counter cp_function_chain->temp_name_counter\n-\n /* Non-zero if we should generate RTL for functions that we process.\n    When this is zero, we just accumulate tree structure, without\n    interacting with the back end.  */\n@@ -4075,7 +4069,7 @@ extern tree constructor_name_full\t\tPARAMS ((tree));\n extern tree constructor_name\t\t\tPARAMS ((tree));\n extern void setup_vtbl_ptr\t\t\tPARAMS ((tree, tree));\n extern void defer_fn             \t\tPARAMS ((tree));\n-extern tree get_temp_name\t\t\tPARAMS ((tree, int));\n+extern tree get_temp_name\t\t\tPARAMS ((tree));\n extern void finish_anon_union\t\t\tPARAMS ((tree));\n extern tree finish_table\t\t\tPARAMS ((tree, tree, tree, int));\n extern void finish_builtin_type\t\t\tPARAMS ((tree, const char *,\n@@ -4110,6 +4104,9 @@ extern tree handle_class_head\t\t\tPARAMS ((tree, tree, tree));\n extern tree lookup_arg_dependent                PARAMS ((tree, tree, tree));\n extern void finish_static_data_member_decl      PARAMS ((tree, tree, tree, int));\n extern tree build_artificial_parm               PARAMS ((tree, tree));\n+extern tree get_guard                           PARAMS ((tree));\n+extern tree get_guard_cond                      PARAMS ((tree));\n+extern tree set_guard                           PARAMS ((tree));\n \n /* in parse.y */\n extern void cp_parse_init\t\t\tPARAMS ((void));"}, {"sha": "2cbbd59d47680316a33c494c407e900e0ac00966", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c395453cb66ab273126e18e7aec5afedc37042f8/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c395453cb66ab273126e18e7aec5afedc37042f8/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=c395453cb66ab273126e18e7aec5afedc37042f8", "patch": "@@ -356,7 +356,7 @@ build_up_reference (type, arg, flags)\n       /* Create a new temporary variable.  */\n       tree targ = arg;\n       if (toplevel_bindings_p ())\n-\targ = get_temp_name (argtype, 1);\n+\targ = get_temp_name (argtype);\n       else\n \t{\n \t  arg = pushdecl (build_decl (VAR_DECL, NULL_TREE, argtype));"}, {"sha": "ae933abfc4470991d5a4b9f18595c53e3876b1e3", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c395453cb66ab273126e18e7aec5afedc37042f8/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c395453cb66ab273126e18e7aec5afedc37042f8/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=c395453cb66ab273126e18e7aec5afedc37042f8", "patch": "@@ -8572,19 +8572,19 @@ expand_static_init (decl, init)\n   else if (! toplevel_bindings_p ())\n     {\n       /* Emit code to perform this initialization but once.  */\n-      tree temp;\n       tree if_stmt;\n       tree then_clause;\n       tree assignment;\n-      tree temp_init;\n+      tree guard;\n+      tree guard_init;\n \n       /* Emit code to perform this initialization but once.  This code\n \t looks like:\n \n-           static int temp = 0;\n-           if (!temp) {\n+           static int guard = 0;\n+           if (!guard) {\n              // Do initialization.\n-\t     temp = 1;\n+\t     guard = 1;\n \t     // Register variable for destruction at end of program.\n \t   }\n \n@@ -8602,14 +8602,13 @@ expand_static_init (decl, init)\n          In theory, this process should be thread-safe, too; multiple\n \t threads should not be able to initialize the variable more\n \t than once.  We don't yet attempt to ensure thread-safety.  */\n-      temp = get_temp_name (integer_type_node, 1);\n-      rest_of_decl_compilation (temp, NULL_PTR, 0, 0);\n+\n+      /* Create the guard variable.  */\n+      guard = get_guard (decl);\n \n       /* Begin the conditional initialization.  */\n       if_stmt = begin_if_stmt ();\n-      finish_if_stmt_cond (cp_build_binary_op (EQ_EXPR, temp,\n-\t\t\t\t\t       integer_zero_node),\n-\t\t\t   if_stmt);\n+      finish_if_stmt_cond (get_guard_cond (guard), if_stmt);\n       then_clause = begin_compound_stmt (/*has_no_scope=*/0);\n \n       /* Do the initialization itself.  */\n@@ -8631,16 +8630,16 @@ expand_static_init (decl, init)\n \t the assignment to TEMP into a single expression, ensuring\n \t that when we call finish_expr_stmt the cleanups will not be\n \t run until after TEMP is set to 1.  */\n-      temp_init = build_modify_expr (temp, NOP_EXPR, integer_one_node);\n+      guard_init = set_guard (guard);\n       if (assignment)\n \t{\n \t  assignment = tree_cons (NULL_TREE, assignment,\n \t\t\t\t  build_tree_list (NULL_TREE,\n-\t\t\t\t\t\t   temp_init));\n+\t\t\t\t\t\t   guard_init));\n \t  assignment = build_compound_expr (assignment);\n \t}\n       else\n-\tassignment = temp_init;\n+\tassignment = guard_init;\n       finish_expr_stmt (assignment);\n \n       /* Use atexit to register a function for destroying this static"}, {"sha": "c172d50dd22dc338bbc9ad7f33247a4e8b521ef5", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 149, "deletions": 67, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c395453cb66ab273126e18e7aec5afedc37042f8/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c395453cb66ab273126e18e7aec5afedc37042f8/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=c395453cb66ab273126e18e7aec5afedc37042f8", "patch": "@@ -62,7 +62,6 @@ typedef struct priority_info_s {\n   int destructions_p;\n } *priority_info;\n \n-static tree get_sentry PARAMS ((tree));\n static void mark_vtable_entries PARAMS ((tree));\n static void grok_function_init PARAMS ((tree, tree));\n static int finish_vtable_vardecl PARAMS ((tree *, void *));\n@@ -95,6 +94,7 @@ static void write_out_vars PARAMS ((tree));\n static void import_export_class\tPARAMS ((tree));\n static tree key_method PARAMS ((tree));\n static int compare_options PARAMS ((const PTR, const PTR));\n+static tree get_guard_bits PARAMS ((tree));\n \n extern int current_class_depth;\n \n@@ -2098,32 +2098,24 @@ defer_fn (fn)\n /* Hand off a unique name which can be used for variable we don't really\n    want to know about anyway, for example, the anonymous variables which\n    are needed to make references work.  Declare this thing so we can use it.\n-   The variable created will be of type TYPE.\n-\n-   STATICP is nonzero if this variable should be static.  */\n+   The variable created will be of type TYPE, and will have internal\n+   linkage.  */\n \n tree\n-get_temp_name (type, staticp)\n+get_temp_name (type)\n      tree type;\n-     int staticp;\n {\n   char buf[sizeof (AUTO_TEMP_FORMAT) + 20];\n   tree decl;\n   int toplev = toplevel_bindings_p ();\n \n-  if (toplev || staticp)\n-    {\n-      sprintf (buf, AUTO_TEMP_FORMAT, global_temp_name_counter++);\n-      decl = pushdecl_top_level (build_decl (VAR_DECL, get_identifier (buf), type));\n-    }\n-  else\n-    {\n-      sprintf (buf, AUTO_TEMP_FORMAT, temp_name_counter++);\n-      decl = pushdecl (build_decl (VAR_DECL, get_identifier (buf), type));\n-    }\n-  TREE_USED (decl) = 1;\n-  TREE_STATIC (decl) = staticp;\n+  sprintf (buf, AUTO_TEMP_FORMAT, global_temp_name_counter++);\n+  decl = build_decl (VAR_DECL, get_identifier (buf), type);\n   DECL_ARTIFICIAL (decl) = 1;\n+  TREE_USED (decl) = 1;\n+  TREE_STATIC (decl) = 1;\n+  \n+  decl = pushdecl_top_level (decl);\n \n   /* If this is a local variable, then lay out its rtl now.\n      Otherwise, callers of this function are responsible for dealing\n@@ -2866,37 +2858,111 @@ build_cleanup (decl)\n   return temp;\n }\n \n-/* Returns the initialization guard variable for the non-local\n-   variable DECL.  */\n+/* Returns the initialization guard variable for the variable DECL,\n+   which has static storage duration.  */\n \n-static tree\n-get_sentry (decl)\n+tree\n+get_guard (decl)\n      tree decl;\n {\n   tree sname;\n-  tree sentry;\n+  tree guard;\n+\n+  /* For a local variable, under the old ABI, we do not try to get a\n+     unique mangled name for the DECL.  */\n+  if (!flag_new_abi && !DECL_NAMESPACE_SCOPE_P (decl))\n+    {\n+      guard = get_temp_name (integer_type_node);\n+      rest_of_decl_compilation (guard, NULL_PTR, 0, 0);\n+    }\n \n   if (!flag_new_abi)\n+    /* For struct X foo __attribute__((weak)), there is a counter\n+       __snfoo. Since base is already an assembler name, sname should\n+       be globally unique */\n     sname = get_id_2 (\"__sn\", DECL_ASSEMBLER_NAME (decl));\n   else\n     sname = mangle_guard_variable (decl);\n \n-  /* For struct X foo __attribute__((weak)), there is a counter\n-     __snfoo. Since base is already an assembler name, sname should\n-     be globally unique */\n-  sentry = IDENTIFIER_GLOBAL_VALUE (sname);\n-  if (! sentry)\n+  guard = IDENTIFIER_GLOBAL_VALUE (sname);\n+  if (! guard)\n     {\n-      sentry = build_decl (VAR_DECL, sname, integer_type_node);\n-      TREE_PUBLIC (sentry) = 1;\n-      DECL_ARTIFICIAL (sentry) = 1;\n-      TREE_STATIC (sentry) = 1;\n-      TREE_USED (sentry) = 1;\n-      DECL_COMMON (sentry) = 1;\n-      pushdecl_top_level (sentry);\n-      cp_finish_decl (sentry, NULL_TREE, NULL_TREE, 0);\n+      tree guard_type;\n+\n+      /* Under the new ABI, we use a type that is big enough to\n+\t contain a mutex as well as an integer counter.  */\n+      if (flag_new_abi)\n+\tguard_type = long_long_integer_type_node;\n+      else\n+\tguard_type = integer_type_node;\n+\n+      guard = build_decl (VAR_DECL, sname, guard_type);\n+      TREE_PUBLIC (guard) = 1;\n+      DECL_ARTIFICIAL (guard) = 1;\n+      TREE_STATIC (guard) = 1;\n+      TREE_USED (guard) = 1;\n+      DECL_COMMON (guard) = 1;\n+      pushdecl_top_level (guard);\n+      cp_finish_decl (guard, NULL_TREE, NULL_TREE, 0);\n     }\n-  return sentry;\n+  return guard;\n+}\n+\n+/* Return those bits of the GUARD variable that should be set when the\n+   guarded entity is actually initialized.  */\n+\n+static tree\n+get_guard_bits (guard)\n+     tree guard;\n+{\n+  if (!flag_new_abi)\n+    return guard;\n+\n+  /* Under the new ABI, we only set the first byte of the guard,\n+     in order to leave room for a mutex in the high-order bits.  */\n+  guard = build1 (ADDR_EXPR, \n+\t\t  build_pointer_type (TREE_TYPE (guard)),\n+\t\t  guard);\n+  guard = build1 (NOP_EXPR, \n+\t\t  build_pointer_type (char_type_node), \n+\t\t  guard);\n+  guard = build1 (INDIRECT_REF, char_type_node, guard);\n+\n+  return guard;\n+}\n+\n+/* Return an expression which determines whether or not the GUARD\n+   variable has already been initialized.  */\n+\n+tree\n+get_guard_cond (guard)\n+     tree guard;\n+{\n+  tree guard_value;\n+\n+  /* Check to see if the GUARD is zero.  */\n+  guard = get_guard_bits (guard);\n+  guard_value = integer_zero_node;\n+  if (!same_type_p (TREE_TYPE (guard_value), TREE_TYPE (guard)))\n+    guard_value = convert (TREE_TYPE (guard), guard_value);\n+  return cp_build_binary_op (EQ_EXPR, guard, guard_value);\n+}\n+\n+/* Return an expression which sets the GUARD variable, indicating that\n+   the variable being guarded has been initialized.  */\n+\n+tree\n+set_guard (guard)\n+     tree guard;\n+{\n+  tree guard_init;\n+\n+  /* Set the GUARD to one.  */\n+  guard = get_guard_bits (guard);\n+  guard_init = integer_one_node;\n+  if (!same_type_p (TREE_TYPE (guard_init), TREE_TYPE (guard)))\n+    guard_init = convert (TREE_TYPE (guard), guard_init);\n+  return build_modify_expr (guard, NOP_EXPR, guard_init);\n }\n \n /* Start the process of running a particular set of global constructors\n@@ -3201,9 +3267,10 @@ start_static_initialization_or_destruction (decl, initp)\n      tree decl;\n      int initp;\n {\n-  tree sentry_if_stmt = NULL_TREE;\n+  tree guard_if_stmt = NULL_TREE;\n   int priority;\n   tree cond;\n+  tree guard;\n   tree init_cond;\n   priority_info pi;\n \n@@ -3247,7 +3314,7 @@ start_static_initialization_or_destruction (decl, initp)\n   \n   /* Conditionalize this initialization on being in the right priority\n      and being initializing/finalizing appropriately.  */\n-  sentry_if_stmt = begin_if_stmt ();\n+  guard_if_stmt = begin_if_stmt ();\n   cond = cp_build_binary_op (EQ_EXPR,\n \t\t\t     priority_decl,\n \t\t\t     build_int_2 (priority, 0));\n@@ -3257,55 +3324,70 @@ start_static_initialization_or_destruction (decl, initp)\n \t\t\t\t  init_cond);\n   cond = cp_build_binary_op (TRUTH_ANDIF_EXPR, cond, init_cond);\n \n-  /* We need a sentry if this is an object with external linkage that\n+  /* Assume we don't need a guard.  */\n+  guard = NULL_TREE;\n+  /* We need a guard if this is an object with external linkage that\n      might be initialized in more than one place.  (For example, a\n      static data member of a template, when the data member requires\n      construction.)  */\n   if (TREE_PUBLIC (decl) && (DECL_COMMON (decl) \n \t\t\t     || DECL_ONE_ONLY (decl)\n \t\t\t     || DECL_WEAK (decl)))\n     {\n-      tree sentry;\n-      tree sentry_cond;\n+      tree guard_cond;\n \n-      sentry = get_sentry (decl);\n+      guard = get_guard (decl);\n \n-      /* We do initializations only if the SENTRY is zero, i.e., if we\n-\t are the first to initialize the variable.  We do destructions\n-\t only if the SENTRY is one, i.e., if we are the last to\n-\t destroy the variable.  */\n-      if (initp)\n-\tsentry_cond \n+      /* When using __cxa_atexit, we just check the GUARD as we would\n+\t for a local static.  */\n+      if (flag_use_cxa_atexit)\n+\t{\n+\t  /* When using __cxa_atexit, we never try to destroy\n+\t     anything from a static destructor.  */\n+\t  my_friendly_assert (initp, 20000629);\n+\t  guard_cond = get_guard_cond (guard);\n+\t}\n+      /* Under the old ABI, e do initializations only if the GUARD is\n+\t zero, i.e., if we are the first to initialize the variable.\n+\t We do destructions only if the GUARD is one, i.e., if we are\n+\t the last to destroy the variable.  */\n+      else if (initp)\n+\tguard_cond \n \t  = cp_build_binary_op (EQ_EXPR,\n \t\t\t\tbuild_unary_op (PREINCREMENT_EXPR,\n-\t\t\t\t\t\tsentry,\n+\t\t\t\t\t\tguard,\n \t\t\t\t\t\t/*noconvert=*/1),\n \t\t\t\tinteger_one_node);\n       else\n-\tsentry_cond \n+\tguard_cond \n \t  = cp_build_binary_op (EQ_EXPR,\n \t\t\t\tbuild_unary_op (PREDECREMENT_EXPR,\n-\t\t\t\t\t\tsentry,\n+\t\t\t\t\t\tguard,\n \t\t\t\t\t\t/*noconvert=*/1),\n \t\t\t\tinteger_zero_node);\n \n-      cond = cp_build_binary_op (TRUTH_ANDIF_EXPR, cond, sentry_cond);\n+      cond = cp_build_binary_op (TRUTH_ANDIF_EXPR, cond, guard_cond);\n     }\n \n-  finish_if_stmt_cond (cond, sentry_if_stmt);\n+  finish_if_stmt_cond (cond, guard_if_stmt);\n+\n+  /* Under the new ABI, we have not already set the GUARD, so we must\n+     do so now.  */\n+  if (guard && initp && flag_new_abi)\n+    finish_expr_stmt (set_guard (guard));\n \n-  return sentry_if_stmt;\n+  return guard_if_stmt;\n }\n \n /* We've just finished generating code to do an initialization or\n-   finalization.  SENTRY_IF_STMT is the if-statement we used to guard\n+   finalization.  GUARD_IF_STMT is the if-statement we used to guard\n    the initialization.  */\n \n static void\n-finish_static_initialization_or_destruction (sentry_if_stmt)\n-     tree sentry_if_stmt;\n+finish_static_initialization_or_destruction (guard_if_stmt)\n+     tree guard_if_stmt;\n {\n-  finish_then_clause (sentry_if_stmt);\n+  finish_then_clause (guard_if_stmt);\n   finish_if_stmt ();\n \n   /* Now that we're done with DECL we don't need to pretend to be a\n@@ -3316,7 +3398,7 @@ finish_static_initialization_or_destruction (sentry_if_stmt)\n \n /* Generate code to do the static initialization of DECL.  The\n    initialization is INIT.  If DECL may be initialized more than once\n-   in different object files, SENTRY is the guard variable to \n+   in different object files, GUARD is the guard variable to \n    check.  PRIORITY is the priority for the initialization.  */\n \n static void\n@@ -3325,10 +3407,10 @@ do_static_initialization (decl, init)\n      tree init;\n {\n   tree expr;\n-  tree sentry_if_stmt;\n+  tree guard_if_stmt;\n \n   /* Set up for the initialization.  */\n-  sentry_if_stmt\n+  guard_if_stmt\n     = start_static_initialization_or_destruction (decl,\n \t\t\t\t\t\t  /*initp=*/1);\n   \n@@ -3353,19 +3435,19 @@ do_static_initialization (decl, init)\n     register_dtor_fn (decl);\n \n   /* Finsh up.  */\n-  finish_static_initialization_or_destruction (sentry_if_stmt);\n+  finish_static_initialization_or_destruction (guard_if_stmt);\n }\n \n /* Generate code to do the static destruction of DECL.  If DECL may be\n-   initialized more than once in different object files, SENTRY is the\n+   initialized more than once in different object files, GUARD is the\n    guard variable to check.  PRIORITY is the priority for the\n    destruction.  */\n \n static void\n do_static_destruction (decl)\n      tree decl;\n {\n-  tree sentry_if_stmt;\n+  tree guard_if_stmt;\n \n   /* If we're using __cxa_atexit, then destructors are registered\n      immediately after objects are initialized.  */\n@@ -3376,10 +3458,10 @@ do_static_destruction (decl)\n     return;\n \n   /* Actually do the destruction.  */\n-  sentry_if_stmt = start_static_initialization_or_destruction (decl,\n+  guard_if_stmt = start_static_initialization_or_destruction (decl,\n \t\t\t\t\t\t\t       /*initp=*/0);\n   finish_expr_stmt (build_cleanup (decl));\n-  finish_static_initialization_or_destruction (sentry_if_stmt);\n+  finish_static_initialization_or_destruction (guard_if_stmt);\n }\n \n /* VARS is a list of variables with static storage duration which may"}, {"sha": "089559f1f86688689d23ef28b5dc09dd2abfd8c2", "filename": "gcc/cp/init.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c395453cb66ab273126e18e7aec5afedc37042f8/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c395453cb66ab273126e18e7aec5afedc37042f8/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=c395453cb66ab273126e18e7aec5afedc37042f8", "patch": "@@ -2729,6 +2729,8 @@ build_vec_delete_1 (base, maxindex, type, auto_delete_vec, use_global_delete)\n     return cp_convert (void_type_node, body);\n }\n \n+/* Create an unnamed variable of the indicated TYPE.  */ \n+\n tree\n create_temporary_var (type)\n      tree type;"}]}