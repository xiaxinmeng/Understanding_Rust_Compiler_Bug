{"sha": "cbb4feb38e39bac728d1a0d053f14d9868d99e8d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2JiNGZlYjM4ZTM5YmFjNzI4ZDFhMGQwNTNmMTRkOTg2OGQ5OWU4ZA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2010-05-03T21:16:40Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2010-05-03T21:16:40Z"}, "message": "re PR c++/43680 ([DR 1022] G++ is too aggressive in optimizing away bounds checking with enums)\n\n\tPR c++/43680\ngcc:\n\t* c.opt (-fstrict-enums): New.\n\t* doc/invoke.texi (C++ Dialect Options): Document -fstrict-enums.\ngcc/cp:\n\t* decl.c (finish_enum): Use the TYPE_MIN_VALUE and TYPE_MAX_VALUE\n\tfrom the selected underlying type unless -fstrict-enums.  Set\n\tENUM_UNDERLYING_TYPE to\thave the restricted range.\n\t* cvt.c (type_promotes_to): Use ENUM_UNDERLYING_TYPE.\n\t* class.c (check_bitfield_decl): Likewise.\n\nFrom-SVN: r159006", "tree": {"sha": "f66f3527bad37dd8ad2f5c0b5d0966b9ca678f5b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f66f3527bad37dd8ad2f5c0b5d0966b9ca678f5b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cbb4feb38e39bac728d1a0d053f14d9868d99e8d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbb4feb38e39bac728d1a0d053f14d9868d99e8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cbb4feb38e39bac728d1a0d053f14d9868d99e8d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbb4feb38e39bac728d1a0d053f14d9868d99e8d/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e492f63ba96ba25a74ebbfab09cb12d403c0bc1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e492f63ba96ba25a74ebbfab09cb12d403c0bc1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e492f63ba96ba25a74ebbfab09cb12d403c0bc1d"}], "stats": {"total": 157, "additions": 107, "deletions": 50}, "files": [{"sha": "30f3ea13fd9d06a4c85fd06531bc28f7c7f82be8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb4feb38e39bac728d1a0d053f14d9868d99e8d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb4feb38e39bac728d1a0d053f14d9868d99e8d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cbb4feb38e39bac728d1a0d053f14d9868d99e8d", "patch": "@@ -1,3 +1,8 @@\n+2010-04-26  Jason Merrill  <jason@redhat.com>\n+\n+\t* c.opt (-fstrict-enums): New.\n+\t* doc/invoke.texi (C++ Dialect Options): Document -fstrict-enums.\n+\n 2010-05-03  David Ung <davidu@mips.com>\n \t    James E. Wilson  <wilson@codesourcery.com>\n "}, {"sha": "3ab29830886a38327830dac9b36737ca63f770cc", "filename": "gcc/c.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb4feb38e39bac728d1a0d053f14d9868d99e8d/gcc%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb4feb38e39bac728d1a0d053f14d9868d99e8d/gcc%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc.opt?ref=cbb4feb38e39bac728d1a0d053f14d9868d99e8d", "patch": "@@ -783,6 +783,10 @@ fstats\n C++ ObjC++\n Display statistics accumulated during compilation\n \n+fstrict-enums\n+C++ ObjC++ Optimization Var(flag_strict_enums)\n+Assume that values of enumeration type are always within the minimum range of that type\n+\n fstrict-prototype\n C++ ObjC++\n "}, {"sha": "8175f146aa1eb40eafa5e950d0a30e7dab2eafc8", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb4feb38e39bac728d1a0d053f14d9868d99e8d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb4feb38e39bac728d1a0d053f14d9868d99e8d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=cbb4feb38e39bac728d1a0d053f14d9868d99e8d", "patch": "@@ -1,3 +1,13 @@\n+2010-05-03  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/42810\n+\tPR c++/43680\n+\t* decl.c (finish_enum): Use the TYPE_MIN_VALUE and TYPE_MAX_VALUE\n+\tfrom the selected underlying type unless -fstrict-enums.  Set\n+\tENUM_UNDERLYING_TYPE to\thave the restricted range.\n+\t* cvt.c (type_promotes_to): Use ENUM_UNDERLYING_TYPE.\n+\t* class.c (check_bitfield_decl): Likewise.\n+\n 2010-05-01  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR c++/43951"}, {"sha": "87f8111f15fece47d6cf46819ef21fb50584a108", "filename": "gcc/cp/class.c", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb4feb38e39bac728d1a0d053f14d9868d99e8d/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb4feb38e39bac728d1a0d053f14d9868d99e8d/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=cbb4feb38e39bac728d1a0d053f14d9868d99e8d", "patch": "@@ -2786,14 +2786,8 @@ check_bitfield_decl (tree field)\n \t       && TREE_CODE (type) != BOOLEAN_TYPE)\n \twarning (0, \"width of %q+D exceeds its type\", field);\n       else if (TREE_CODE (type) == ENUMERAL_TYPE\n-\t       && (0 > compare_tree_int (w,\n-\t\t\t\t\t tree_int_cst_min_precision\n-\t\t\t\t\t (TYPE_MIN_VALUE (type),\n-\t\t\t\t\t  TYPE_UNSIGNED (type)))\n-\t\t   ||  0 > compare_tree_int (w,\n-\t\t\t\t\t     tree_int_cst_min_precision\n-\t\t\t\t\t     (TYPE_MAX_VALUE (type),\n-\t\t\t\t\t      TYPE_UNSIGNED (type)))))\n+\t       && (0 > (compare_tree_int\n+\t\t\t(w, TYPE_PRECISION (ENUM_UNDERLYING_TYPE (type))))))\n \twarning (0, \"%q+D is too small to hold all values of %q#T\", field, type);\n     }\n "}, {"sha": "5be0b8d8f305641772d4f9f433a194110dc4dbb9", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb4feb38e39bac728d1a0d053f14d9868d99e8d/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb4feb38e39bac728d1a0d053f14d9868d99e8d/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=cbb4feb38e39bac728d1a0d053f14d9868d99e8d", "patch": "@@ -682,7 +682,8 @@ ocp_convert (tree type, tree expr, int convtype, int flags)\n \t     the original value is within the range of the enumeration\n \t     values. Otherwise, the resulting enumeration value is\n \t     unspecified.  */\n-\t  if (TREE_CODE (expr) == INTEGER_CST && !int_fits_type_p (expr, type))\n+\t  if (TREE_CODE (expr) == INTEGER_CST\n+\t      && !int_fits_type_p (expr, ENUM_UNDERLYING_TYPE (type)))\n \t    warning (OPT_Wconversion, \n \t\t     \"the result of the conversion is unspecified because \"\n \t\t     \"%qE is outside the range of type %qT\",\n@@ -1311,6 +1312,8 @@ type_promotes_to (tree type)\n       int precision = MAX (TYPE_PRECISION (type),\n \t\t\t   TYPE_PRECISION (integer_type_node));\n       tree totype = c_common_type_for_size (precision, 0);\n+      if (TREE_CODE (type) == ENUMERAL_TYPE)\n+\ttype = ENUM_UNDERLYING_TYPE (type);\n       if (TYPE_UNSIGNED (type)\n \t  && ! int_fits_type_p (TYPE_MAX_VALUE (type), totype))\n \ttype = c_common_type_for_size (precision, 1);"}, {"sha": "563628287174374a40f0829813de664cd5746f8e", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 42, "deletions": 38, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb4feb38e39bac728d1a0d053f14d9868d99e8d/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb4feb38e39bac728d1a0d053f14d9868d99e8d/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=cbb4feb38e39bac728d1a0d053f14d9868d99e8d", "patch": "@@ -11255,12 +11255,6 @@ finish_enum (tree enumtype)\n   tree maxnode;\n   tree value;\n   tree t;\n-  bool unsignedp;\n-  bool use_short_enum;\n-  int lowprec;\n-  int highprec;\n-  int precision;\n-  unsigned int itk;\n   tree underlying_type = NULL_TREE;\n   bool fixed_underlying_type_p \n     = ENUM_UNDERLYING_TYPE (enumtype) != NULL_TREE;\n@@ -11323,17 +11317,19 @@ finish_enum (tree enumtype)\n        the enumeration had a single enumerator with value 0.  */\n     minnode = maxnode = integer_zero_node;\n \n-  /* Compute the number of bits require to represent all values of the\n-     enumeration.  We must do this before the type of MINNODE and\n-     MAXNODE are transformed, since tree_int_cst_min_precision relies\n-     on the TREE_TYPE of the value it is passed.  */\n-  unsignedp = tree_int_cst_sgn (minnode) >= 0;\n-  lowprec = tree_int_cst_min_precision (minnode, unsignedp);\n-  highprec = tree_int_cst_min_precision (maxnode, unsignedp);\n-  precision = MAX (lowprec, highprec);\n-\n   if (!fixed_underlying_type_p)\n     {\n+      /* Compute the number of bits require to represent all values of the\n+\t enumeration.  We must do this before the type of MINNODE and\n+\t MAXNODE are transformed, since tree_int_cst_min_precision relies\n+\t on the TREE_TYPE of the value it is passed.  */\n+      bool unsignedp = tree_int_cst_sgn (minnode) >= 0;\n+      int lowprec = tree_int_cst_min_precision (minnode, unsignedp);\n+      int highprec = tree_int_cst_min_precision (maxnode, unsignedp);\n+      int precision = MAX (lowprec, highprec);\n+      unsigned int itk;\n+      bool use_short_enum;\n+\n       /* Determine the underlying type of the enumeration.\n \n          [dcl.enum]\n@@ -11380,43 +11376,51 @@ finish_enum (tree enumtype)\n          The value of sizeof() applied to an enumeration type, an object\n          of an enumeration type, or an enumerator, is the value of sizeof()\n          applied to the underlying type.  */\n+      TYPE_MIN_VALUE (enumtype) = TYPE_MIN_VALUE (underlying_type);\n+      TYPE_MAX_VALUE (enumtype) = TYPE_MAX_VALUE (underlying_type);\n       TYPE_SIZE (enumtype) = TYPE_SIZE (underlying_type);\n       TYPE_SIZE_UNIT (enumtype) = TYPE_SIZE_UNIT (underlying_type);\n       SET_TYPE_MODE (enumtype, TYPE_MODE (underlying_type));\n+      TYPE_PRECISION (enumtype) = TYPE_PRECISION (underlying_type);\n       TYPE_ALIGN (enumtype) = TYPE_ALIGN (underlying_type);\n       TYPE_USER_ALIGN (enumtype) = TYPE_USER_ALIGN (underlying_type);\n       TYPE_UNSIGNED (enumtype) = TYPE_UNSIGNED (underlying_type);\n \n-      /* Set the underlying type of the enumeration type to the\n-         computed enumeration type, restricted to the enumerator\n-         values. */\n+      /* Compute the minimum and maximum values for the type.\n+\n+\t [dcl.enum]\n+\n+\t For an enumeration where emin is the smallest enumerator and emax\n+\t is the largest, the values of the enumeration are the values of the\n+\t underlying type in the range bmin to bmax, where bmin and bmax are,\n+\t respectively, the smallest and largest values of the smallest bit-\n+\t field that can store emin and emax.  */\n+\n+      /* The middle-end currently assumes that types with TYPE_PRECISION\n+\t narrower than their underlying type are suitably zero or sign\n+\t extended to fill their mode.  Similarly, it assumes that the front\n+\t end assures that a value of a particular type must be within\n+\t TYPE_MIN_VALUE and TYPE_MAX_VALUE.\n+\n+\t We used to set these fields based on bmin and bmax, but that led\n+\t to invalid assumptions like optimizing away bounds checking.  So\n+\t now we just set the TYPE_PRECISION, TYPE_MIN_VALUE, and\n+\t TYPE_MAX_VALUE to the values for the mode above and only restrict\n+\t the ENUM_UNDERLYING_TYPE for the benefit of diagnostics.  */\n       ENUM_UNDERLYING_TYPE (enumtype)\n \t= build_distinct_type_copy (underlying_type);\n-      set_min_and_max_values_for_integral_type \n+      TYPE_PRECISION (ENUM_UNDERLYING_TYPE (enumtype)) = precision;\n+      set_min_and_max_values_for_integral_type\n         (ENUM_UNDERLYING_TYPE (enumtype), precision, unsignedp);\n+\n+      /* If -fstrict-enums, still constrain TYPE_MIN/MAX_VALUE.  */\n+      if (flag_strict_enums)\n+\tset_min_and_max_values_for_integral_type (enumtype, precision,\n+\t\t\t\t\t\t  unsignedp);\n     }\n   else\n     underlying_type = ENUM_UNDERLYING_TYPE (enumtype);\n \n-  /* Compute the minimum and maximum values for the type.\n-\n-     [dcl.enum]\n-\n-     For an enumeration where emin is the smallest enumerator and emax\n-     is the largest, the values of the enumeration are the values of the\n-     underlying type in the range bmin to bmax, where bmin and bmax are,\n-     respectively, the smallest and largest values of the smallest bit-\n-     field that can store emin and emax.  */\n-  \n-  /* The middle-end currently assumes that types with TYPE_PRECISION\n-     narrower than their underlying type are suitably zero or sign\n-     extended to fill their mode.  g++ doesn't make these guarantees.\n-     Until the middle-end can represent such paradoxical types, we\n-     set the TYPE_PRECISION to the width of the underlying type.  */\n-  TYPE_PRECISION (enumtype) = TYPE_PRECISION (underlying_type);\n-  \n-  set_min_and_max_values_for_integral_type (enumtype, precision, unsignedp);\n-  \n   /* Convert each of the enumerators to the type of the underlying\n      type of the enumeration.  */\n   for (values = TYPE_VALUES (enumtype); values; values = TREE_CHAIN (values))"}, {"sha": "b2fbd48becdfd854aaa4632d68fa024ed4265519", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb4feb38e39bac728d1a0d053f14d9868d99e8d/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb4feb38e39bac728d1a0d053f14d9868d99e8d/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=cbb4feb38e39bac728d1a0d053f14d9868d99e8d", "patch": "@@ -1982,6 +1982,15 @@ unambiguous base classes.\n Emit statistics about front-end processing at the end of the compilation.\n This information is generally only useful to the G++ development team.\n \n+@item -fstrict-enums\n+@opindex fstrict-enums\n+Allow the compiler to optimize using the assumption that a value of\n+enumeration type can only be one of the values of the enumeration (as\n+defined in the C++ standard; basically, a value which can be\n+represented in the minimum number of bits needed to represent all the\n+enumerators).  This assumption may not be valid if the program uses a\n+cast to convert an arbitrary integer value to the enumeration type.\n+\n @item -ftemplate-depth=@var{n}\n @opindex ftemplate-depth\n Set the maximum instantiation depth for template classes to @var{n}."}, {"sha": "722ee1e46a9837115b4855f75aad0002b02f5687", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb4feb38e39bac728d1a0d053f14d9868d99e8d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb4feb38e39bac728d1a0d053f14d9868d99e8d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=cbb4feb38e39bac728d1a0d053f14d9868d99e8d", "patch": "@@ -1,3 +1,10 @@\n+2010-05-03  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/43680\n+\t* g++.dg/opt/enum2.C: New.\n+\t* g++.dg/warn/pr33738.C: Use -fstrict-enums.\n+\t* g++.dg/warn/Wswitch-1.C: Adjust message.\n+\n 2010-05-03  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* g++.dg/cdce3.C: Skip on alpha*-dec-osf5*."}, {"sha": "6300896cff933516e13b7ed1db93a6c4d4b433f8", "filename": "gcc/testsuite/g++.dg/opt/enum2.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb4feb38e39bac728d1a0d053f14d9868d99e8d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fenum2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb4feb38e39bac728d1a0d053f14d9868d99e8d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fenum2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fenum2.C?ref=cbb4feb38e39bac728d1a0d053f14d9868d99e8d", "patch": "@@ -0,0 +1,21 @@\n+// PR c++/43680\n+// Test that we don't make excessively aggressive assumptions about what\n+// values an enum variable can have.\n+// { dg-options \"-O2 -fPIC\" }\n+// { dg-do run }\n+\n+extern \"C\" void abort ();\n+\n+enum E { A, B, C, D };\n+\n+void\n+CheckE(const E value)\n+{\n+  long v = value;\n+  if (v <= D)\n+    abort ();\n+}\n+\n+int main() {\n+  CheckE(static_cast<E>(5));\n+}"}, {"sha": "1da7180ec79c068aef2d35d5205be188b31eb0c9", "filename": "gcc/testsuite/g++.dg/warn/Wswitch-1.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb4feb38e39bac728d1a0d053f14d9868d99e8d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWswitch-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb4feb38e39bac728d1a0d053f14d9868d99e8d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWswitch-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWswitch-1.C?ref=cbb4feb38e39bac728d1a0d053f14d9868d99e8d", "patch": "@@ -50,13 +50,13 @@ foo (int i, int j, enum e ei, enum e ej, enum e ek, enum e el,\n     {\n     case e1: return 1;\n     case e2: return 2;\n-    case 3: return 3; /* { dg-warning \"exceeds maximum value\" } */\n+    case 3: return 3; /* { dg-warning \"case value\" } */\n     }\n   switch (ep)\n     {\n     case e1: return 1;\n     case e2: return 2;\n-    case 3: return 3; /* { dg-warning \"exceeds maximum value\" } */\n+    case 3: return 3; /* { dg-warning \"case value\" } */\n     default: break;\n     }\n   return 0;"}, {"sha": "e84fece13f669bb2e9e16a876892b3a9af4f6a5a", "filename": "gcc/testsuite/g++.dg/warn/pr33738.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbb4feb38e39bac728d1a0d053f14d9868d99e8d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fpr33738.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbb4feb38e39bac728d1a0d053f14d9868d99e8d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fpr33738.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fpr33738.C?ref=cbb4feb38e39bac728d1a0d053f14d9868d99e8d", "patch": "@@ -1,5 +1,5 @@\n // { dg-do run }\n-// { dg-options \"-O2 -Wtype-limits\" }\n+// { dg-options \"-O2 -Wtype-limits -fstrict-enums\" }\n extern void link_error (void);\n \n enum Alpha {"}]}