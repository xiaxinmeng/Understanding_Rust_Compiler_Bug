{"sha": "3a1f863f50d8b632272aef9a16c1f3e38157fa60", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2ExZjg2M2Y1MGQ4YjYzMjI3MmFlZjlhMTZjMWYzZTM4MTU3ZmE2MA==", "commit": {"author": {"name": "David Edelsohn", "email": "edelsohn@gnu.org", "date": "2003-09-23T02:03:55Z"}, "committer": {"name": "David Edelsohn", "email": "dje@gcc.gnu.org", "date": "2003-09-23T02:03:55Z"}, "message": "rs6000.c (altivec_in_gprs_p): Rename to ...\n\n        * config/rs6000/rs6000.c (altivec_in_gprs_p): Rename to ...\n        (gpr_or_gpr_p): Change to bool.\n        (rs6000_split_altivec_in_gprs): Rename to ...\n        (rs6000_split_multireg_move): Add support for update addressing.\n        * config/rs6000/rs6000-protos.h: Same.\n        * config/rs6000/altivec.md: Same.\n        * config/rs6000/rs6000.md (movdi_internal32): Use new splitter for\n        multiple GPRs.\n        (movti): Remove TARGET_STRING || TARGET_POWERPC64 final condition.\n        (movti_power): Use new splitter for multiple GPRs.\n        (movti_string): Same.\n        (movti_ppc64): Same.\n\nCo-Authored-By: Hartmut Penner <hpenner@de.ibm.com>\n\nFrom-SVN: r71673", "tree": {"sha": "4b306dbc3ddd86c980ece870d016ec288ee54a86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4b306dbc3ddd86c980ece870d016ec288ee54a86"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3a1f863f50d8b632272aef9a16c1f3e38157fa60", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a1f863f50d8b632272aef9a16c1f3e38157fa60", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a1f863f50d8b632272aef9a16c1f3e38157fa60", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a1f863f50d8b632272aef9a16c1f3e38157fa60/comments", "author": null, "committer": null, "parents": [{"sha": "2f2846abe71fca95f16cb1fa53d4f76f624a964f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f2846abe71fca95f16cb1fa53d4f76f624a964f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f2846abe71fca95f16cb1fa53d4f76f624a964f"}], "stats": {"total": 358, "additions": 194, "deletions": 164}, "files": [{"sha": "a7b8b49bd62025899d3b028108525586a5df9ad1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a1f863f50d8b632272aef9a16c1f3e38157fa60/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a1f863f50d8b632272aef9a16c1f3e38157fa60/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3a1f863f50d8b632272aef9a16c1f3e38157fa60", "patch": "@@ -1,3 +1,19 @@\n+2003-09-22  David Edelsohn  <edelsohn@gnu.org>\n+\t    Hartmut Penner  <hpenner@de.ibm.com>\n+\n+\t* config/rs6000/rs6000.c (altivec_in_gprs_p): Rename to ...\n+\t(gpr_or_gpr_p): Change to bool.\n+\t(rs6000_split_altivec_in_gprs): Rename to ...\n+\t(rs6000_split_multireg_move): Add support for update addressing.\n+\t* config/rs6000/rs6000-protos.h: Same.\n+\t* config/rs6000/altivec.md: Same.\n+\t* config/rs6000/rs6000.md (movdi_internal32): Use new splitter for\n+\tmultiple GPRs.\n+\t(movti): Remove TARGET_STRING || TARGET_POWERPC64 final condition.\n+\t(movti_power): Use new splitter for multiple GPRs.\n+\t(movti_string): Same.\n+\t(movti_ppc64): Same.\n+\n 2003-09-22  Bob Wilson  <bob.wilson@acm.org>\n \n \t* config/xtensa/xtensa-protos.h: Convert to ISO C90."}, {"sha": "2b58d60ab84c47e6f7068316a40c9bc694028fe3", "filename": "gcc/config/rs6000/altivec.md", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a1f863f50d8b632272aef9a16c1f3e38157fa60/gcc%2Fconfig%2Frs6000%2Faltivec.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a1f863f50d8b632272aef9a16c1f3e38157fa60/gcc%2Fconfig%2Frs6000%2Faltivec.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faltivec.md?ref=3a1f863f50d8b632272aef9a16c1f3e38157fa60", "patch": "@@ -114,24 +114,24 @@\n   [(set (match_operand:V4SI 0 \"nonimmediate_operand\" \"\")\n         (match_operand:V4SI 1 \"input_operand\" \"\"))]\n   \"TARGET_ALTIVEC && reload_completed && TARGET_POWERPC64 \n-   && altivec_in_gprs_p (operands[0], operands[1])\"\n+   && gpr_or_gpr_p (operands[0], operands[1])\"\n   [(set (match_dup 2) (match_dup 4))\n    (set (match_dup 3) (match_dup 5))]\n \"{\n-     rs6000_split_altivec_in_gprs (operands);\n+     rs6000_split_multireg_move (operands);\n }\")\n \n (define_split\n   [(set (match_operand:V4SI 0 \"nonimmediate_operand\" \"\")\n         (match_operand:V4SI 1 \"input_operand\" \"\"))]\n   \"TARGET_ALTIVEC && reload_completed && !TARGET_POWERPC64 \n-   && altivec_in_gprs_p (operands[0], operands[1])\"\n+   && gpr_or_gpr_p (operands[0], operands[1])\"\n   [(set (match_dup 2) (match_dup 6))\n    (set (match_dup 3) (match_dup 7))\n    (set (match_dup 4) (match_dup 8))\n    (set (match_dup 5) (match_dup 9))]\n \"{\n-     rs6000_split_altivec_in_gprs (operands);\n+     rs6000_split_multireg_move (operands);\n }\")\n \n (define_split\n@@ -176,24 +176,24 @@\n   [(set (match_operand:V8HI 0 \"nonimmediate_operand\" \"\")\n         (match_operand:V8HI 1 \"input_operand\" \"\"))]\n   \"TARGET_ALTIVEC && reload_completed && TARGET_POWERPC64 \n-   && altivec_in_gprs_p (operands[0], operands[1])\"\n+   && gpr_or_gpr_p (operands[0], operands[1])\"\n   [(set (match_dup 2) (match_dup 4))\n    (set (match_dup 3) (match_dup 5))]\n \"{\n-     rs6000_split_altivec_in_gprs (operands);\n+     rs6000_split_multireg_move (operands);\n }\")\n \n (define_split\n   [(set (match_operand:V8HI 0 \"nonimmediate_operand\" \"\")\n         (match_operand:V8HI 1 \"input_operand\" \"\"))]\n   \"TARGET_ALTIVEC && reload_completed && !TARGET_POWERPC64 \n-   && altivec_in_gprs_p (operands[0], operands[1])\"\n+   && gpr_or_gpr_p (operands[0], operands[1])\"\n   [(set (match_dup 2) (match_dup 6))\n    (set (match_dup 3) (match_dup 7))\n    (set (match_dup 4) (match_dup 8))\n    (set (match_dup 5) (match_dup 9))]\n \"{\n-     rs6000_split_altivec_in_gprs (operands);\n+     rs6000_split_multireg_move (operands);\n }\")\n \n (define_split\n@@ -238,24 +238,24 @@\n   [(set (match_operand:V16QI 0 \"nonimmediate_operand\" \"\")\n         (match_operand:V16QI 1 \"input_operand\" \"\"))]\n   \"TARGET_ALTIVEC && reload_completed && TARGET_POWERPC64 \n-   && altivec_in_gprs_p (operands[0], operands[1])\"\n+   && gpr_or_gpr_p (operands[0], operands[1])\"\n   [(set (match_dup 2) (match_dup 4))\n    (set (match_dup 3) (match_dup 5))]\n \"{\n-     rs6000_split_altivec_in_gprs (operands);\n+     rs6000_split_multireg_move (operands);\n }\")\n \n (define_split\n   [(set (match_operand:V16QI 0 \"nonimmediate_operand\" \"\")\n         (match_operand:V16QI 1 \"input_operand\" \"\"))]\n   \"TARGET_ALTIVEC && reload_completed && !TARGET_POWERPC64 \n-   && altivec_in_gprs_p (operands[0], operands[1])\"\n+   && gpr_or_gpr_p (operands[0], operands[1])\"\n   [(set (match_dup 2) (match_dup 6))\n    (set (match_dup 3) (match_dup 7))\n    (set (match_dup 4) (match_dup 8))\n    (set (match_dup 5) (match_dup 9))]\n \"{\n-     rs6000_split_altivec_in_gprs (operands);\n+     rs6000_split_multireg_move (operands);\n }\")\n \n (define_split\n@@ -300,24 +300,24 @@\n   [(set (match_operand:V4SF 0 \"nonimmediate_operand\" \"\")\n         (match_operand:V4SF 1 \"input_operand\" \"\"))]\n   \"TARGET_ALTIVEC && reload_completed && TARGET_POWERPC64 \n-   && altivec_in_gprs_p (operands[0], operands[1])\"\n+   && gpr_or_gpr_p (operands[0], operands[1])\"\n   [(set (match_dup 2) (match_dup 4))\n    (set (match_dup 3) (match_dup 5))]\n \"{\n-     rs6000_split_altivec_in_gprs (operands);\n+     rs6000_split_multireg_move (operands);\n }\")\n \n (define_split\n   [(set (match_operand:V4SF 0 \"nonimmediate_operand\" \"\")\n         (match_operand:V4SF 1 \"input_operand\" \"\"))]\n   \"TARGET_ALTIVEC && reload_completed && !TARGET_POWERPC64 \n-   && altivec_in_gprs_p (operands[0], operands[1])\"\n+   && gpr_or_gpr_p (operands[0], operands[1])\"\n   [(set (match_dup 2) (match_dup 6))\n    (set (match_dup 3) (match_dup 7))\n    (set (match_dup 4) (match_dup 8))\n    (set (match_dup 5) (match_dup 9))]\n \"{\n-     rs6000_split_altivec_in_gprs (operands);\n+     rs6000_split_multireg_move (operands);\n }\")\n \n (define_insn \"get_vrsave_internal\""}, {"sha": "021c40cc7614d451196ae412c13e8d8dd658c000", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a1f863f50d8b632272aef9a16c1f3e38157fa60/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a1f863f50d8b632272aef9a16c1f3e38157fa60/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=3a1f863f50d8b632272aef9a16c1f3e38157fa60", "patch": "@@ -100,16 +100,16 @@ extern int includes_rldic_lshift_p (rtx, rtx);\n extern int includes_rldicr_lshift_p (rtx, rtx);\n extern int registers_ok_for_quad_peep (rtx, rtx);\n extern int addrs_ok_for_quad_peep (rtx, rtx);\n-extern int altivec_in_gprs_p (rtx, rtx);\n+extern bool gpr_or_gpr_p (rtx, rtx);\n extern enum reg_class secondary_reload_class (enum reg_class,\n-\t\t\t\t\t\t      enum machine_mode, rtx);\n+\t\t\t\t\t      enum machine_mode, rtx);\n extern int ccr_bit (rtx, int);\n extern int extract_MB (rtx);\n extern int extract_ME (rtx);\n extern void print_operand (FILE *, rtx, int);\n extern void print_operand_address (FILE *, rtx);\n extern enum rtx_code rs6000_reverse_condition (enum machine_mode,\n-\t\t\t\t\t\t       enum rtx_code);\n+\t\t\t\t\t       enum rtx_code);\n extern void rs6000_emit_sCOND (enum rtx_code, rtx);\n extern void rs6000_emit_cbranch (enum rtx_code, rtx);\n extern char * output_cbranch (rtx, const char *, int, rtx);\n@@ -125,7 +125,7 @@ extern int mfcr_operation (rtx, enum machine_mode);\n extern int mtcrf_operation (rtx, enum machine_mode);\n extern int lmw_operation (rtx, enum machine_mode);\n extern struct rtx_def *create_TOC_reference (rtx);\n-extern void rs6000_split_altivec_in_gprs (rtx *);\n+extern void rs6000_split_multireg_move (rtx *);\n extern void rs6000_emit_move (rtx, rtx, enum machine_mode);\n extern rtx rs6000_legitimize_address (rtx, rtx, enum machine_mode);\n extern rtx rs6000_legitimize_reload_address (rtx, enum machine_mode,"}, {"sha": "0b7be5ac5e4e93d4bccb9d8a663c1a0faac9e409", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 94, "deletions": 36, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a1f863f50d8b632272aef9a16c1f3e38157fa60/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a1f863f50d8b632272aef9a16c1f3e38157fa60/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=3a1f863f50d8b632272aef9a16c1f3e38157fa60", "patch": "@@ -2200,18 +2200,13 @@ small_data_operand (rtx op ATTRIBUTE_UNUSED,\n #endif\n }\n \n-/* Return 1 for all valid move insn operand combination involving altivec      \n-   vectors in gprs.  */\n+/* Return true if either operand is a general purpose register.  */\n \n-int\n-altivec_in_gprs_p (rtx op0, rtx op1)\n+bool\n+gpr_or_gpr_p (rtx op0, rtx op1)\n {\n-  if (REG_P (op0) && REGNO_REG_CLASS (REGNO (op0)) == GENERAL_REGS)\n-    return 1;\n-\n-  if (REG_P (op1) && REGNO_REG_CLASS (REGNO (op1)) == GENERAL_REGS) \n-    return 1;\n-  return 0;\n+  return ((REG_P (op0) && INT_REGNO_P (REGNO (op0)))\n+\t  || (REG_P (op1) && INT_REGNO_P (REGNO (op1))));\n }\n \n \f\n@@ -9462,14 +9457,16 @@ rs6000_emit_minmax (rtx dest, enum rtx_code code, rtx op0, rtx op1)\n     emit_move_insn (dest, target);\n }\n \n-/* Called by altivec splitter.\n+/* Called by splitter for multireg moves.\n    Input: \n           operands[0] : Destination of move\n           operands[1] : Source of move\n-\t  noperands   : Size of operands vector\n+\n    Output:\n-\t  operands[2-5] ([2-3] in 64 bit) : Destination slots\n-\t  operands[6-9] ([4-5] in 64 bit) : Source slots\n+\t  operands[2-n] : Destination slots\n+\t  operands[n-m] : Source slots\n+   where n = 2 + HARD_REGNO_NREGS (reg, GET_MODE (operands[0]))\n+         m = 2 + 2 * HARD_REGNO_NREGS (reg, GET_MODE (operands[0])) - 1\n \n    Splits the move of operands[1] to operands[0].\n    This is done, if GPRs are one of the operands.  In this case\n@@ -9479,10 +9476,13 @@ rs6000_emit_minmax (rtx dest, enum rtx_code code, rtx op0, rtx op1)\n */\n \t  \n void\n-rs6000_split_altivec_in_gprs (rtx *operands)\n+rs6000_split_multireg_move (rtx *operands)\n {\n-    int nregs, reg, i, j;\n+  int nregs, reg, i, j, used_update = 0;\n   enum machine_mode mode; \n+  rtx dst = operands[0];\n+  rtx src = operands[1];\n+  rtx insn = 0;\n \n   /* Calculate number to move (2/4 for 32/64 bit mode).  */ \n \n@@ -9500,8 +9500,8 @@ rs6000_split_altivec_in_gprs (rtx *operands)\n       for (i = 0; i < nregs; i++)\n         {\n           j--;\n-          operands[i + 2] = operand_subword (operands[0], j, 0, mode);\n-          operands[i + 2 + nregs] = \n+          operands[i+2] = operand_subword (operands[0], j, 0, mode);\n+          operands[i+2+nregs] = \n             operand_subword (operands[1], j, 0, mode);   \n         }\n     }     \n@@ -9512,29 +9512,87 @@ rs6000_split_altivec_in_gprs (rtx *operands)\n       if (GET_CODE (operands[1]) == MEM)\n         {\n           rtx breg;\n-          /* We have offsettable addresses only. If we use one of the\n-             registers to address memory, we have change that register last.  */            \n-          breg = GET_CODE (XEXP (operands[1], 0)) == PLUS ?\n-              XEXP (XEXP (operands[1], 0), 0) :\n-              XEXP (operands[1], 0);\n-\n-          if (REGNO (breg) >= REGNO (operands[0]) \n-              && REGNO (breg) < REGNO (operands[0]) + nregs)\n-              j = REGNO (breg) - REGNO (operands[0]);\n+\n+\t  if (GET_CODE (XEXP (operands[1], 0)) == PRE_INC\n+\t      || GET_CODE (XEXP (operands[1], 0)) == PRE_DEC)\n+\t    {\n+\t      rtx delta_rtx;\n+\t      breg = XEXP (XEXP (operands[1], 0), 0);\n+\t      delta_rtx =  GET_CODE (XEXP (operands[1], 0)) == PRE_INC \n+\t\t  ? GEN_INT (GET_MODE_SIZE (GET_MODE (operands[1]))) \n+\t\t  : GEN_INT (-GET_MODE_SIZE (GET_MODE (operands[1]))); \n+\t      insn = emit_insn (TARGET_32BIT\n+\t\t\t\t? gen_addsi3 (breg, breg, delta_rtx)\n+\t\t\t\t: gen_adddi3 (breg, breg, delta_rtx));\n+\t      src = gen_rtx_MEM (mode, breg);\n+\t    }\n+\n+\t  /* We have now address involving an base register only.\n+\t     If we use one of the registers to address memory, \n+\t     we have change that register last.  */\n+\n+\t  breg = (GET_CODE (XEXP (src, 0)) == PLUS\n+\t\t  ? XEXP (XEXP (src, 0), 0)\n+\t\t  : XEXP (src, 0));\n+\n+\t  if (!REG_P (breg))\n+\t      abort();\n+\n+\t  if (REGNO (breg) >= REGNO (dst) \n+\t      && REGNO (breg) < REGNO (dst) + nregs)\n+\t    j = REGNO (breg) - REGNO (dst);\n         }\n \n+      if (GET_CODE (operands[0]) == MEM)\n+\t{\n+\t  rtx breg;\n+\n+\t  if (GET_CODE (XEXP (operands[0], 0)) == PRE_INC\n+\t      || GET_CODE (XEXP (operands[0], 0)) == PRE_DEC)\n+\t    {\n+\t      rtx delta_rtx;\n+\t      breg = XEXP (XEXP (operands[0], 0), 0);\n+\t      delta_rtx = GET_CODE (XEXP (operands[0], 0)) == PRE_INC \n+\t\t? GEN_INT (GET_MODE_SIZE (GET_MODE (operands[0]))) \n+\t\t: GEN_INT (-GET_MODE_SIZE (GET_MODE (operands[0]))); \n+\n+\t      /* We have to update the breg before doing the store.\n+\t\t Use store with update, if available.  */\n+\n+\t      if (TARGET_UPDATE)\n+\t\t{\n+\t\t  insn = emit_insn (TARGET_32BIT\n+\t\t\t\t    ? gen_movsi_update (breg, breg, delta_rtx, \n+\t\t\t\t\toperand_subword (src, 0, 0, mode))\n+\t\t\t\t    : gen_movdi_update (breg, breg, delta_rtx,\n+\t\t\t\t\toperand_subword (src, 0, 0, mode)));\n+\t\t  used_update = 1;\n+\t\t}\n+\t      else\n+\t\t  insn = emit_insn (TARGET_32BIT\n+\t\t\t\t    ? gen_addsi3 (breg, breg, delta_rtx)\n+\t\t\t\t    : gen_adddi3 (breg, breg, delta_rtx));\n+\t      dst = gen_rtx_MEM (mode, breg);\n+\t    }\n+\t}\n+\n       for (i = 0; i < nregs; i++)\n-        { \n-          /* Calculate index to next subword.  */\n-          j++;\n-          if (j == nregs) \n-            j = 0;\n+\t{  \n+\t  /* Calculate index to next subword.  */\n+\t  ++j;\n+\t  if (j == nregs) \n+\t    j = 0;\n \n-          operands[i + 2] = operand_subword (operands[0], j, 0, mode);\n-          operands[i + 2 + nregs] = \n-            operand_subword (operands[1], j, 0, mode);\n+\t  operands[i+2] = operand_subword (dst, j, 0, mode);\n+\t  operands[i+2+nregs] = operand_subword (src, j, 0, mode);\n \n-        }\n+\t  if (j == 0 && used_update)\n+\t    {\n+\t      /* Already emited move of first word by \n+\t\t store with update -> emit dead insn instead (r := r).  */\n+\t      operands[i+2] = operands[i+2+nregs];\n+\t    }\n+\t}\n     }\n }\n "}, {"sha": "d1264c68fd63e987892b323804ec8688efdef09d", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 64, "deletions": 108, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a1f863f50d8b632272aef9a16c1f3e38157fa60/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a1f863f50d8b632272aef9a16c1f3e38157fa60/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=3a1f863f50d8b632272aef9a16c1f3e38157fa60", "patch": "@@ -8462,25 +8462,9 @@\n     default:\n       abort ();\n     case 0:\n-      /* We normally copy the low-numbered register first.  However, if\n-\t the first register operand 0 is the same as the second register of\n-\t operand 1, we must copy in the opposite order.  */\n-      if (REGNO (operands[0]) == REGNO (operands[1]) + 1)\n-\treturn \\\"mr %L0,%L1\\;mr %0,%1\\\";\n-      else\n-\treturn \\\"mr %0,%1\\;mr %L0,%L1\\\";\n     case 1:\n-      /* If the low-address word is used in the address, we must load it\n-\t last.  Otherwise, load it first.  Note that we cannot have\n-\t auto-increment in that case since the address register is known to be\n-\t dead.  */\n-      if (refers_to_regno_p (REGNO (operands[0]), REGNO (operands[0]) + 1,\n-\t\t\t     operands[1], 0))\n-\treturn \\\"{l|lwz} %L0,%L1\\;{l|lwz} %0,%1\\\";\n-      else\n-\treturn \\\"{l%U1|lwz%U1} %0,%1\\;{l|lwz} %L0,%L1\\\";\n     case 2:\n-      return \\\"{st%U0|stw%U0} %1,%0\\;{st|stw} %L1,%L0\\\";\n+      return \\\"#\\\";\n     case 3:\n       return \\\"fmr %0,%1\\\";\n     case 4:\n@@ -8495,8 +8479,7 @@\n       return \\\"#\\\";\n     }\n }\"\n-  [(set_attr \"type\" \"*,load,store,fp,fpload,fpstore,*,*,*,*,*\")\n-   (set_attr \"length\" \"8,8,8,4,4,4,8,12,8,12,16\")])\n+  [(set_attr \"type\" \"*,load,store,fp,fpload,fpstore,*,*,*,*,*\")])\n \n (define_split\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n@@ -8535,6 +8518,17 @@\n   operands[5] = GEN_INT (CONST_DOUBLE_LOW  (operands[1]));\n }\")\n \n+(define_split\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n+        (match_operand:DI 1 \"input_operand\" \"\"))]\n+  \"reload_completed && !TARGET_POWERPC64 \n+   && gpr_or_gpr_p (operands[0], operands[1])\"\n+  [(set (match_dup 2) (match_dup 4))\n+   (set (match_dup 3) (match_dup 5))]\n+\"{\n+     rs6000_split_multireg_move (operands);\n+}\")\n+\n (define_split\n   [(set (match_operand:TI 0 \"gpc_reg_operand\" \"\")\n \t(match_operand:TI 1 \"const_double_operand\" \"\"))]\n@@ -8677,19 +8671,20 @@\n   [(parallel [(set (match_operand:TI 0 \"general_operand\" \"\")\n \t\t   (match_operand:TI 1 \"general_operand\" \"\"))\n \t      (clobber (scratch:SI))])]\n-  \"TARGET_STRING || TARGET_POWERPC64\"\n+  \"\"\n   \"{ rs6000_emit_move (operands[0], operands[1], TImode); DONE; }\")\n \n ;; We say that MQ is clobbered in the last alternative because the first\n ;; alternative would never get used otherwise since it would need a reload\n ;; while the 2nd alternative would not.  We put memory cases first so they\n ;; are preferred.  Otherwise, we'd try to reload the output instead of\n ;; giving the SCRATCH mq.\n+\n (define_insn \"*movti_power\"\n   [(set (match_operand:TI 0 \"reg_or_mem_operand\" \"=Q,m,????r,????r,????r\")\n \t(match_operand:TI 1 \"reg_or_mem_operand\" \"r,r,r,Q,m\"))\n    (clobber (match_scratch:SI 2 \"=q,q#X,X,X,X\"))]\n-  \"TARGET_STRING && TARGET_POWER && ! TARGET_POWERPC64\n+  \"TARGET_POWER && ! TARGET_POWERPC64\n    && (gpc_reg_operand (operands[0], TImode) || gpc_reg_operand (operands[1], TImode))\"\n   \"*\n {\n@@ -8699,130 +8694,91 @@\n       abort ();\n \n     case 0:\n-      return \\\"{stsi|stswi} %1,%P0,16\\\";\n+      if (TARGET_STRING)\n+        return \\\"{stsi|stswi} %1,%P0,16\\\";\n     case 1:\n-      return \\\"{st%U0|stw%U0} %1,%0\\;{st|stw} %L1,%L0\\;{st|stw} %Y1,%Y0\\;{st|stw} %Z1,%Z0\\\";\n+      return \\\"#\\\";\n     case 2:\n-      /* Normally copy registers with lowest numbered register copied first.\n-\t But copy in the other order if the first register of the output\n-\t is the second, third, or fourth register in the input.  */\n-      if (REGNO (operands[0]) >= REGNO (operands[1]) + 1\n-\t  && REGNO (operands[0]) <= REGNO (operands[1]) + 3)\n-\treturn \\\"mr %Z0,%Z1\\;mr %Y0,%Y1\\;mr %L0,%L1\\;mr %0,%1\\\";\n-      else\n-\treturn \\\"mr %0,%1\\;mr %L0,%L1\\;mr %Y0,%Y1\\;mr %Z0,%Z1\\\";\n+      return \\\"#\\\";\n     case 3:\n       /* If the address is not used in the output, we can use lsi.  Otherwise,\n \t fall through to generating four loads.  */\n       if (! reg_overlap_mentioned_p (operands[0], operands[1]))\n \treturn \\\"{lsi|lswi} %0,%P1,16\\\";\n       /* ... fall through ...  */\n     case 4:\n-      /* If the address register is the same as the register for the lowest-\n-\t addressed word, load it last.  Similarly for the next two words.\n-\t Otherwise load lowest address to highest.  */\n-      if (refers_to_regno_p (REGNO (operands[0]), REGNO (operands[0]) + 1,\n-\t\t\t     operands[1], 0))\n-\treturn \\\"{l|lwz} %L0,%L1\\;{l|lwz} %Y0,%Y1\\;{l|lwz} %Z0,%Z1\\;{l|lwz} %0,%1\\\";\n-      else if (refers_to_regno_p (REGNO (operands[0]) + 1,\n-\t\t\t\t  REGNO (operands[0]) + 2, operands[1], 0))\n-\treturn \\\"{l|lwz} %0,%1\\;{l|lwz} %Y0,%Y1\\;{l|lwz} %Z0,%Z1\\;{l|lwz} %L0,%L1\\\";\n-      else if (refers_to_regno_p (REGNO (operands[0]) + 2,\n-\t\t\t\t  REGNO (operands[0]) + 3, operands[1], 0))\n-\treturn \\\"{l|lwz} %0,%1\\;{l|lwz} %L0,%L1\\;{l|lwz} %Z0,%Z1\\;{l|lwz} %Y0,%Y1\\\";\n-      else\n-\treturn \\\"{l%U1|lwz%U1} %0,%1\\;{l|lwz} %L0,%L1\\;{l|lwz} %Y0,%Y1\\;{l|lwz} %Z0,%Z1\\\";\n+      return \\\"#\\\";\n     }\n }\"\n-  [(set_attr \"type\" \"store,store,*,load,load\")\n-   (set_attr \"length\" \"4,16,16,4,16\")])\n+  [(set_attr \"type\" \"store,store,*,load,load\")])\n \n (define_insn \"*movti_string\"\n   [(set (match_operand:TI 0 \"reg_or_mem_operand\" \"=Q,m,????r,????r,????r\")\n \t(match_operand:TI 1 \"reg_or_mem_operand\" \"r,r,r,Q,m\"))]\n-  \"TARGET_STRING && ! TARGET_POWER && ! TARGET_POWERPC64\n+  \"! TARGET_POWER && ! TARGET_POWERPC64\n    && (gpc_reg_operand (operands[0], TImode) || gpc_reg_operand (operands[1], TImode))\"\n   \"*\n {\n   switch (which_alternative)\n     {\n     default:\n       abort ();\n-\n     case 0:\n-      return \\\"{stsi|stswi} %1,%P0,16\\\";\n+      if (TARGET_STRING)\n+        return \\\"{stsi|stswi} %1,%P0,16\\\";\n     case 1:\n-      return \\\"{st%U0|stw%U0} %1,%0\\;{st|stw} %L1,%L0\\;{st|stw} %Y1,%Y0\\;{st|stw} %Z1,%Z0\\\";\n+      return \\\"#\\\";\n     case 2:\n-      /* Normally copy registers with lowest numbered register copied first.\n-\t But copy in the other order if the first register of the output\n-\t is the second, third, or fourth register in the input.  */\n-      if (REGNO (operands[0]) >= REGNO (operands[1]) + 1\n-\t  && REGNO (operands[0]) <= REGNO (operands[1]) + 3)\n-\treturn \\\"mr %Z0,%Z1\\;mr %Y0,%Y1\\;mr %L0,%L1\\;mr %0,%1\\\";\n-      else\n-\treturn \\\"mr %0,%1\\;mr %L0,%L1\\;mr %Y0,%Y1\\;mr %Z0,%Z1\\\";\n+      return \\\"#\\\";\n     case 3:\n       /* If the address is not used in the output, we can use lsi.  Otherwise,\n \t fall through to generating four loads.  */\n-      if (! reg_overlap_mentioned_p (operands[0], operands[1]))\n+      if (TARGET_STRING  \n+          && ! reg_overlap_mentioned_p (operands[0], operands[1]))\n \treturn \\\"{lsi|lswi} %0,%P1,16\\\";\n       /* ... fall through ...  */\n     case 4:\n-      /* If the address register is the same as the register for the lowest-\n-\t addressed word, load it last.  Similarly for the next two words.\n-\t Otherwise load lowest address to highest.  */\n-      if (refers_to_regno_p (REGNO (operands[0]), REGNO (operands[0]) + 1,\n-\t\t\t     operands[1], 0))\n-\treturn \\\"{l|lwz} %L0,%L1\\;{l|lwz} %Y0,%Y1\\;{l|lwz} %Z0,%Z1\\;{l|lwz} %0,%1\\\";\n-      else if (refers_to_regno_p (REGNO (operands[0]) + 1,\n-\t\t\t\t  REGNO (operands[0]) + 2, operands[1], 0))\n-\treturn \\\"{l|lwz} %0,%1\\;{l|lwz} %Y0,%Y1\\;{l|lwz} %Z0,%Z1\\;{l|lwz} %L0,%L1\\\";\n-      else if (refers_to_regno_p (REGNO (operands[0]) + 2,\n-\t\t\t\t  REGNO (operands[0]) + 3, operands[1], 0))\n-\treturn \\\"{l|lwz} %0,%1\\;{l|lwz} %L0,%L1\\;{l|lwz} %Z0,%Z1\\;{l|lwz} %Y0,%Y1\\\";\n-      else\n-\treturn \\\"{l%U1|lwz%U1} %0,%1\\;{l|lwz} %L0,%L1\\;{l|lwz} %Y0,%Y1\\;{l|lwz} %Z0,%Z1\\\";\n+      return \\\"#\\\";\n     }\n }\"\n-  [(set_attr \"type\" \"store,store,*,load,load\")\n-   (set_attr \"length\" \"4,16,16,4,16\")])\n+  [(set_attr \"type\" \"store,store,*,load,load\")])\n \n (define_insn \"*movti_ppc64\"\n-  [(set (match_operand:TI 0 \"nonimmediate_operand\" \"=r,r,m\")\n-\t(match_operand:TI 1 \"input_operand\" \"r,m,r\"))]\n+  [(set (match_operand:TI 0 \"nonimmediate_operand\" \"=r,m,r\")\n+\t(match_operand:TI 1 \"input_operand\" \"r,r,o\"))]\n   \"TARGET_POWERPC64 && (gpc_reg_operand (operands[0], TImode)\n    || gpc_reg_operand (operands[1], TImode))\"\n-  \"*\n-{\n-  switch (which_alternative)\n-    {\n-    default:\n-      abort ();\n-    case 0:\n-      /* We normally copy the low-numbered register first.  However, if\n-\t the first register operand 0 is the same as the second register of\n-\t operand 1, we must copy in the opposite order.  */\n-      if (REGNO (operands[0]) == REGNO (operands[1]) + 1)\n-\treturn \\\"mr %L0,%L1\\;mr %0,%1\\\";\n-      else\n-\treturn \\\"mr %0,%1\\;mr %L0,%L1\\\";\n-    case 1:\n-      /* If the low-address word is used in the address, we must load it\n-\t last.  Otherwise, load it first.  Note that we cannot have\n-\t auto-increment in that case since the address register is known to be\n-\t dead.  */\n-      if (refers_to_regno_p (REGNO (operands[0]), REGNO (operands[0]) + 1,\n-\t\t\t     operands[1], 0))\n-\treturn \\\"ld %L0,%L1\\;ld %0,%1\\\";\n-      else\n-\treturn \\\"ld%U1 %0,%1\\;ld %L0,%L1\\\";\n-    case 2:\n-      return \\\"std%U0 %1,%0\\;std %L1,%L0\\\";\n-    }\n-}\"\n-  [(set_attr \"type\" \"*,load,store\")\n-   (set_attr \"length\" \"8,8,8\")])\n+  \"@\n+   #\t\n+   #\t\n+   #\"\n+  [(set_attr \"type\" \"*,load,store\")])\n+\n+(define_split\n+  [(set (match_operand:TI 0 \"nonimmediate_operand\" \"\")\n+        (match_operand:TI 1 \"input_operand\" \"\"))]\n+  \"reload_completed && TARGET_POWERPC64 \n+   && gpr_or_gpr_p (operands[0], operands[1])\"\n+  [(set (match_dup 2) (match_dup 4))\n+   (set (match_dup 3) (match_dup 5))]\n+\"{\n+     rs6000_split_multireg_move (operands);\n+}\")\n+\n+(define_split\n+  [(set (match_operand:TI 0 \"nonimmediate_operand\" \"\")\n+        (match_operand:TI 1 \"input_operand\" \"\"))]\n+  \"reload_completed && !TARGET_POWERPC64 \n+   && gpr_or_gpr_p (operands[0], operands[1])\"\n+  [(set (match_dup 2) (match_dup 6))\n+   (set (match_dup 3) (match_dup 7))\n+   (set (match_dup 4) (match_dup 8))\n+   (set (match_dup 5) (match_dup 9))]\n+\"{\n+     rs6000_split_multireg_move (operands);\n+}\")\n+\n+\n \f\n (define_expand \"load_multiple\"\n   [(match_par_dup 3 [(set (match_operand:SI 0 \"\" \"\")"}]}