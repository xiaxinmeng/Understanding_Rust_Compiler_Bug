{"sha": "1efe644834ee533f0ab0d5ab6232ef34cfd80c01", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWVmZTY0NDgzNGVlNTMzZjBhYjBkNWFiNjIzMmVmMzRjZmQ4MGMwMQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-02-07T21:12:57Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-02-07T21:12:57Z"}, "message": "(struct arg_data): New field MODE.\n\n(expand_call, store_one_arg): Use it to ensure that all args get\npromoted if requested, not just those passed in registers.\n\nFrom-SVN: r3436", "tree": {"sha": "e2b77677d592692c80e130bb673277613d5db888", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e2b77677d592692c80e130bb673277613d5db888"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1efe644834ee533f0ab0d5ab6232ef34cfd80c01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1efe644834ee533f0ab0d5ab6232ef34cfd80c01", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1efe644834ee533f0ab0d5ab6232ef34cfd80c01", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1efe644834ee533f0ab0d5ab6232ef34cfd80c01/comments", "author": null, "committer": null, "parents": [{"sha": "2e90c25ade71b1281ce8321237331a5aeebad070", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e90c25ade71b1281ce8321237331a5aeebad070", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e90c25ade71b1281ce8321237331a5aeebad070"}], "stats": {"total": 51, "additions": 30, "deletions": 21}, "files": [{"sha": "5b9c9ca2dcc9f01834c048809f0a1b34b7d7d755", "filename": "gcc/calls.c", "status": "modified", "additions": 30, "deletions": 21, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1efe644834ee533f0ab0d5ab6232ef34cfd80c01/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1efe644834ee533f0ab0d5ab6232ef34cfd80c01/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=1efe644834ee533f0ab0d5ab6232ef34cfd80c01", "patch": "@@ -42,6 +42,8 @@ struct arg_data\n {\n   /* Tree node for this argument.  */\n   tree tree_value;\n+  /* Mode for value; TYPE_MODE unless promoted.  */\n+  enum machine_mode mode;\n   /* Current RTL value for argument, or 0 if it isn't precomputed.  */\n   rtx value;\n   /* Initially-compute RTL value for argument; only for const functions.  */\n@@ -947,6 +949,7 @@ expand_call (exp, target, ignore)\n \t}\n #endif\n \n+      args[i].mode = mode;\n       args[i].reg = FUNCTION_ARG (args_so_far, mode, type,\n \t\t\t\t  argpos < n_named_args);\n #ifdef FUNCTION_ARG_PARTIAL_NREGS\n@@ -985,7 +988,7 @@ expand_call (exp, target, ignore)\n \t  || reg_parm_stack_space > 0\n #endif\n \t  || args[i].pass_on_stack)\n-\tlocate_and_pad_parm (TYPE_MODE (type), type,\n+\tlocate_and_pad_parm (mode, type,\n #ifdef STACK_PARMS_IN_REG_PARM_AREA\n \t\t\t     1,\n #else\n@@ -1176,7 +1179,13 @@ expand_call (exp, target, ignore)\n       {\n \targs[i].initial_value = args[i].value\n \t  = expand_expr (args[i].tree_value, NULL_RTX, VOIDmode, 0);\n+\n+\tif (GET_MODE (args[i].value ) != VOIDmode\n+\t    && GET_MODE (args[i].value) != args[i].mode)\n+\t  args[i].value = convert_to_mode (args[i].mode, args[i].value,\n+\t\t\t\t\t   args[i].unsignedp);\n \tpreserve_temp_slots (args[i].value);\n+\n \tfree_temp_slots ();\n \n \t/* ANSI doesn't require a sequence point here,\n@@ -1367,17 +1376,15 @@ expand_call (exp, target, ignore)\n \t    addr = gen_rtx (PLUS, Pmode, arg_reg, offset);\n \n \t  addr = plus_constant (addr, arg_offset);\n-\t  args[i].stack\n-\t    = gen_rtx (MEM, TYPE_MODE (TREE_TYPE (args[i].tree_value)), addr);\n+\t  args[i].stack = gen_rtx (MEM, args[i].mode, addr);\n \n \t  if (GET_CODE (slot_offset) == CONST_INT)\n \t    addr = plus_constant (arg_reg, INTVAL (slot_offset));\n \t  else\n \t    addr = gen_rtx (PLUS, Pmode, arg_reg, slot_offset);\n \n \t  addr = plus_constant (addr, arg_offset);\n-\t  args[i].stack_slot\n-\t    = gen_rtx (MEM, TYPE_MODE (TREE_TYPE (args[i].tree_value)), addr);\n+\t  args[i].stack_slot = gen_rtx (MEM, args[i].mode, addr);\n \t}\n     }\n \t\t\t\t\t       \n@@ -1426,8 +1433,6 @@ expand_call (exp, target, ignore)\n   for (i = 0; i < num_actuals; i++)\n     if (args[i].reg != 0 && ! args[i].pass_on_stack)\n       {\n-\tenum machine_mode mode;\n-\n \treg_parm_seen = 1;\n \n \tif (args[i].value == 0)\n@@ -1444,11 +1449,10 @@ expand_call (exp, target, ignore)\n \n \t/* If we are to promote the function arg to a wider mode,\n \t   do it now.  */\n-\tmode = (GET_CODE (args[i].reg) == EXPR_LIST \n-\t\t? GET_MODE (XEXP (args[i].reg, 0)) : GET_MODE (args[i].reg));\n \n-\tif (TYPE_MODE (TREE_TYPE (args[i].tree_value)) != mode)\n-\t  args[i].value = convert_to_mode (mode, args[i].value,\n+\tif (GET_MODE (args[i].value) != VOIDmode\n+\t    && GET_MODE (args[i].value) != args[i].mode)\n+\t  args[i].value = convert_to_mode (args[i].mode, args[i].value,\n \t\t\t\t\t   args[i].unsignedp);\n       }\n \n@@ -1608,7 +1612,7 @@ expand_call (exp, target, ignore)\n \t  else if (args[i].partial == 0 || args[i].pass_on_stack)\n \t    move_block_to_reg (REGNO (reg),\n \t\t\t       validize_mem (args[i].value), nregs,\n-\t\t\t       TYPE_MODE (TREE_TYPE (args[i].tree_value)));\n+\t\t\t       args[i].mode);\n \t\n \t  push_to_sequence (use_insns);\n \t  if (nregs == 0)\n@@ -2019,6 +2023,14 @@ store_one_arg (arg, argblock, may_be_alloca, variable_size, fndecl,\n #endif\n       arg->value = expand_expr (pval, partial ? NULL_RTX : arg->stack,\n \t\t\t\tVOIDmode, 0);\n+\n+      /* If we are promoting object (or for any other reason) the mode\n+\t doesn't agree, convert the mode.  */\n+\n+      if (GET_MODE (arg->value) != VOIDmode\n+\t  && GET_MODE (arg->value) != arg->mode)\n+\targ->value = convert_to_mode (arg->mode, arg->value, arg->unsignedp);\n+\n #ifdef ACCUMULATE_OUTGOING_ARGS\n       if (arg->pass_on_stack)\n \tstack_arg_under_construction--;\n@@ -2033,7 +2045,7 @@ store_one_arg (arg, argblock, may_be_alloca, variable_size, fndecl,\n   if (arg->value == arg->stack)\n     /* If the value is already in the stack slot, we are done.  */\n     ;\n-  else if (TYPE_MODE (TREE_TYPE (pval)) != BLKmode)\n+  else if (arg->mode != BLKmode)\n     {\n       register int size;\n \n@@ -2047,7 +2059,7 @@ store_one_arg (arg, argblock, may_be_alloca, variable_size, fndecl,\n \t Note that in C the default argument promotions\n \t will prevent such mismatches.  */\n \n-      size = GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (pval)));\n+      size = GET_MODE_SIZE (arg->mode);\n       /* Compute how much space the push instruction will push.\n \t On many machines, pushing a byte will advance the stack\n \t pointer by a halfword.  */\n@@ -2058,17 +2070,15 @@ store_one_arg (arg, argblock, may_be_alloca, variable_size, fndecl,\n \n       /* Compute how much space the argument should get:\n \t round up to a multiple of the alignment for arguments.  */\n-      if (none != FUNCTION_ARG_PADDING (TYPE_MODE (TREE_TYPE (pval)),\n-\t\t\t\t\tTREE_TYPE (pval)))\n+      if (none != FUNCTION_ARG_PADDING (arg->mode, TREE_TYPE (pval)))\n \tused = (((size + PARM_BOUNDARY / BITS_PER_UNIT - 1)\n \t\t / (PARM_BOUNDARY / BITS_PER_UNIT))\n \t\t* (PARM_BOUNDARY / BITS_PER_UNIT));\n \n       /* This isn't already where we want it on the stack, so put it there.\n \t This can either be done with push or copy insns.  */\n-      emit_push_insn (arg->value, TYPE_MODE (TREE_TYPE (pval)),\n-\t\t      TREE_TYPE (pval), 0, 0, partial, reg,\n-\t\t      used - size, argblock, ARGS_SIZE_RTX (arg->offset));\n+      emit_push_insn (arg->value, arg->mode, TREE_TYPE (pval), 0, 0, partial,\n+\t\t      reg, used - size, argblock, ARGS_SIZE_RTX (arg->offset));\n     }\n   else\n     {\n@@ -2099,8 +2109,7 @@ store_one_arg (arg, argblock, may_be_alloca, variable_size, fndecl,\n \t  size_rtx = expand_expr (size, NULL_RTX, VOIDmode, 0);\n \t}\n \n-      emit_push_insn (arg->value, TYPE_MODE (TREE_TYPE (pval)),\n-\t\t      TREE_TYPE (pval), size_rtx,\n+      emit_push_insn (arg->value, arg->mode, TREE_TYPE (pval), size_rtx,\n \t\t      TYPE_ALIGN (TREE_TYPE (pval)) / BITS_PER_UNIT, partial,\n \t\t      reg, excess, argblock, ARGS_SIZE_RTX (arg->offset));\n     }"}]}