{"sha": "c34fb198320a6a433f5ad4c10b9d0c7e6f280e28", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzM0ZmIxOTgzMjBhNmE0MzNmNWFkNGMxMGI5ZDBjN2U2ZjI4MGUyOA==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2013-11-20T13:55:04Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2013-11-20T13:55:04Z"}, "message": "re PR rtl-optimization/54300 (regcprop incorrectly looks through parallel register swap operation)\n\nPR rtl-optimization/54300\n\ngcc/\n\n\tPR rtl-optimization/54300\n\t* regcprop.c (copyprop_hardreg_forward_1): Ensure any unused\n\toutputs in a single-set are killed from the value chains.\n\ngcc/testsuite:\n\n\tPR rtl-optimization/54300\n\t* gcc.target/arm/pr54300.C: New test.\n\nFrom-SVN: r205117", "tree": {"sha": "5f5a0d090f1d60fe5038e9ff9ccdc5083ce8b87f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5f5a0d090f1d60fe5038e9ff9ccdc5083ce8b87f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c34fb198320a6a433f5ad4c10b9d0c7e6f280e28", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c34fb198320a6a433f5ad4c10b9d0c7e6f280e28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c34fb198320a6a433f5ad4c10b9d0c7e6f280e28", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c34fb198320a6a433f5ad4c10b9d0c7e6f280e28/comments", "author": null, "committer": null, "parents": [{"sha": "eb1d81598d4b4413ec5fe730036c16202afad6b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb1d81598d4b4413ec5fe730036c16202afad6b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb1d81598d4b4413ec5fe730036c16202afad6b6"}], "stats": {"total": 90, "additions": 90, "deletions": 0}, "files": [{"sha": "1064cfe0601b270f652cd27aa4ba250c5af87b0d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c34fb198320a6a433f5ad4c10b9d0c7e6f280e28/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c34fb198320a6a433f5ad4c10b9d0c7e6f280e28/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c34fb198320a6a433f5ad4c10b9d0c7e6f280e28", "patch": "@@ -1,3 +1,9 @@\n+2013-11-20  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\tPR rtl-optimization/54300\n+\t* regcprop.c (copyprop_hardreg_forward_1): Ensure any unused\n+\toutputs in a single-set are killed from the value chains.\n+\n 2013-11-20  Ilya Enkovich  <ilya.enkovich@intel.com>\n \n \t* cgraph.h (varpool_node): Add need_bounds_init field."}, {"sha": "9b52a6301f7caeb9ce526ec4dc885c8402c39787", "filename": "gcc/regcprop.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c34fb198320a6a433f5ad4c10b9d0c7e6f280e28/gcc%2Fregcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c34fb198320a6a433f5ad4c10b9d0c7e6f280e28/gcc%2Fregcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregcprop.c?ref=c34fb198320a6a433f5ad4c10b9d0c7e6f280e28", "patch": "@@ -747,6 +747,7 @@ copyprop_hardreg_forward_1 (basic_block bb, struct value_data *vd)\n       int n_ops, i, alt, predicated;\n       bool is_asm, any_replacements;\n       rtx set;\n+      rtx link;\n       bool replaced[MAX_RECOG_OPERANDS];\n       bool changed = false;\n       struct kill_set_value_data ksvd;\n@@ -815,6 +816,23 @@ copyprop_hardreg_forward_1 (basic_block bb, struct value_data *vd)\n \tif (recog_op_alt[i][alt].earlyclobber)\n \t  kill_value (recog_data.operand[i], vd);\n \n+      /* If we have dead sets in the insn, then we need to note these as we\n+\t would clobbers.  */\n+      for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n+\t{\n+\t  if (REG_NOTE_KIND (link) == REG_UNUSED)\n+\t    {\n+\t      kill_value (XEXP (link, 0), vd);\n+\t      /* Furthermore, if the insn looked like a single-set,\n+\t\t but the dead store kills the source value of that\n+\t\t set, then we can no-longer use the plain move\n+\t\t special case below.  */\n+\t      if (set\n+\t\t  && reg_overlap_mentioned_p (XEXP (link, 0), SET_SRC (set)))\n+\t\tset = NULL;\n+\t    }\n+\t}\n+\n       /* Special-case plain move instructions, since we may well\n \t be able to do the move from a different register class.  */\n       if (set && REG_P (SET_SRC (set)))"}, {"sha": "37e83eae5b2762b1bc23e4d62e26229ff2da100d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c34fb198320a6a433f5ad4c10b9d0c7e6f280e28/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c34fb198320a6a433f5ad4c10b9d0c7e6f280e28/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c34fb198320a6a433f5ad4c10b9d0c7e6f280e28", "patch": "@@ -1,3 +1,8 @@\n+2013-11-20  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\tPR rtl-optimization/54300\n+\t* gcc.target/arm/pr54300.C: New test.\n+\n 2013-11-20  Diego Novillo  <dnovillo@google.com>\n \n \tPR 59212"}, {"sha": "eb1a74e36cff6d57f7444e1ca34b704c80efbf54", "filename": "gcc/testsuite/gcc.target/arm/pr54300.C", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c34fb198320a6a433f5ad4c10b9d0c7e6f280e28/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr54300.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c34fb198320a6a433f5ad4c10b9d0c7e6f280e28/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr54300.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr54300.C?ref=c34fb198320a6a433f5ad4c10b9d0c7e6f280e28", "patch": "@@ -0,0 +1,61 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target arm_neon } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-add-options arm_neon } */\n+\n+#include <arm_neon.h>\n+#include <stdlib.h>\n+\n+struct __attribute__ ((aligned(8))) _v16u8_ {\n+  uint8x16_t val;\n+  _v16u8_( const int16x8_t &src) { val = vreinterpretq_u8_s16(src); }\n+  operator int16x8_t () const { return vreinterpretq_s16_u8(val); }\n+};\n+typedef struct _v16u8_ v16u8;\n+\n+struct __attribute__ ((aligned(4))) _v8u8_ {\n+  uint8x8_t val;\n+  _v8u8_( const uint8x8_t &src) { val = src; }\n+  operator int16x4_t () const { return vreinterpret_s16_u8(val); }\n+};\n+typedef struct _v8u8_ v8u8;\n+\n+typedef v16u8                v8i16;\n+typedef int32x4_t            v4i32;\n+typedef const short         cv1i16;\n+typedef const unsigned char cv1u8;\n+typedef const v8i16         cv8i16;\n+\n+static inline __attribute__((always_inline)) v8u8 zero_64(){ return vdup_n_u8( 0 ); }\n+\n+static inline __attribute__((always_inline)) v8i16 loadlo_8i16( cv8i16* p ){\n+  return vcombine_s16( vld1_s16( (cv1i16 *)p ), zero_64() );\n+}\n+static inline __attribute__((always_inline)) v8i16 _loadlo_8i16( cv8i16* p, int offset ){\n+  return loadlo_8i16( (cv8i16*)(&((cv1u8*)p)[offset]) );\n+}\n+\n+void __attribute__((noinline))\n+test(unsigned short *_Inp, int32_t *_Out,\n+     unsigned int s1v, unsigned int dv0,\n+     unsigned int smask_v)\n+{\n+  int32x4_t c = vdupq_n_s32(0);\n+\n+  for(unsigned int sv=0 ; sv!=dv0 ; sv=(sv+s1v)&smask_v )\n+    {\n+      int32x4_t s;\n+      s = vmovl_s16( vget_low_s16( _loadlo_8i16( (cv8i16*) _Inp, sv ) ) );\n+      c = vaddq_s32( c, s );\n+    }\n+  vst1q_s32( _Out, c );\n+}\n+\n+main()\n+{\n+  unsigned short a[4] = {1, 2, 3, 4};\n+  int32_t b[4] = {0, 0, 0, 0};\n+  test(a, b, 1, 1, ~0);\n+  if (b[0] != 1 || b[1] != 2 || b[2] != 3 || b[3] != 4)\n+    abort();\n+}"}]}