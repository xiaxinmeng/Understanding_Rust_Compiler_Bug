{"sha": "5a32d03841c8db674ef3f6fb7e223b37c4122e46", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWEzMmQwMzg0MWM4ZGI2NzRlZjNmNmZiN2UyMjNiMzdjNDEyMmU0Ng==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-11-16T12:47:58Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-11-16T12:47:58Z"}, "message": "(convert_move): Don't put FROM in a register if it is a SUBREG.\n\n(store_expr): If don't want a value and storing into promoted\nvariable, do conversion at tree level; don't copy volatile MEM unless\nwant value, as comment says.\n\nFrom-SVN: r8466", "tree": {"sha": "4badac418f1ec5bf4278f92c749a07ea5ea0f5e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4badac418f1ec5bf4278f92c749a07ea5ea0f5e3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5a32d03841c8db674ef3f6fb7e223b37c4122e46", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a32d03841c8db674ef3f6fb7e223b37c4122e46", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a32d03841c8db674ef3f6fb7e223b37c4122e46", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a32d03841c8db674ef3f6fb7e223b37c4122e46/comments", "author": null, "committer": null, "parents": [{"sha": "38d42ddbcf98ece1597737ad4c07b5206ce4b6e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38d42ddbcf98ece1597737ad4c07b5206ce4b6e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38d42ddbcf98ece1597737ad4c07b5206ce4b6e2"}], "stats": {"total": 15, "additions": 8, "deletions": 7}, "files": [{"sha": "a1ecf253a1cbfc29f952dc2eeecebd56cd0fe7ed", "filename": "gcc/expr.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a32d03841c8db674ef3f6fb7e223b37c4122e46/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a32d03841c8db674ef3f6fb7e223b37c4122e46/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=5a32d03841c8db674ef3f6fb7e223b37c4122e46", "patch": "@@ -1086,12 +1086,6 @@ convert_move (to, from, unsignedp)\n       if ((code = can_extend_p (to_mode, from_mode, unsignedp))\n \t  != CODE_FOR_nothing)\n \t{\n-\t  /* If FROM is a SUBREG, put it into a register.  Do this\n-\t     so that we always generate the same set of insns for\n-\t     better cse'ing; if an intermediate assignment occurred,\n-\t     we won't be doing the operation directly on the SUBREG.  */\n-\t  if (optimize > 0 && GET_CODE (from) == SUBREG)\n-\t    from = force_reg (from_mode, from);\n \t  emit_unop_insn (code, to, from, equiv_code);\n \t  return;\n \t}\n@@ -2721,11 +2715,18 @@ store_expr (exp, target, want_value)\n        and then convert to the wider mode.  Our value is the computed\n        expression.  */\n     {\n+      /* If we don't want a value, we can do the conversion inside EXP,\n+\t which will often result in some optimizations.  */\n+      if (! want_value)\n+\texp = convert (type_for_mode (GET_MODE (SUBREG_REG (target)),\n+\t\t\t\t      SUBREG_PROMOTED_UNSIGNED_P (target)),\n+\t\t       exp);\n+\t \n       temp = expand_expr (exp, NULL_RTX, VOIDmode, 0);\n \n       /* If TEMP is a volatile MEM and we want a result value, make\n \t the access now so it gets done only once.  */\n-      if (GET_CODE (temp) == MEM && MEM_VOLATILE_P (temp))\n+      if (GET_CODE (temp) == MEM && MEM_VOLATILE_P (temp) && want_value)\n \ttemp = copy_to_reg (temp);\n \n       /* If TEMP is a VOIDmode constant, use convert_modes to make"}]}