{"sha": "a78cfa7fc14a35d4f5592ee177404e8b7c74d1e7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTc4Y2ZhN2ZjMTRhMzVkNGY1NTkyZWUxNzc0MDRlOGI3Yzc0ZDFlNw==", "commit": {"author": {"name": "Roman Gareev", "email": "gareevroman@gmail.com", "date": "2014-07-11T14:18:44Z"}, "committer": {"name": "Roman Gareev", "email": "romangareev@gcc.gnu.org", "date": "2014-07-11T14:18:44Z"}, "message": "graphite-isl-ast-to-gimple.c (gmp_cst_to_tree): New function.\n\n\n\tgcc/\n\t* graphite-isl-ast-to-gimple.c (gmp_cst_to_tree):\n\tNew function.\n\t(graphite_verify): New function.\n\t(ivs_params_clear): New function.\n\t(gcc_expression_from_isl_ast_expr_id): New function.\n\t(gcc_expression_from_isl_expr_int): New function.\n\t(binary_op_to_tree): New function.\n\t(ternary_op_to_tree): New function.\n\t(unary_op_to_tree): New function.\n\t(nary_op_to_tree): New function.\n\t(gcc_expression_from_isl_expr_op): New function.\n\t(gcc_expression_from_isl_expression): New function.\n\t(graphite_create_new_loop): New function.\n\t(translate_isl_ast_for_loop): New function.\n\t(get_upper_bound): New function.\n\t(graphite_create_new_loop_guard): New function.\n\t(translate_isl_ast_node_for): New function.\n\t(translate_isl_ast): New function.\n\t(add_parameters_to_ivs_params): New function.\n\t(scop_to_isl_ast): New parameter ip.\n\t(graphite_regenerate_ast_isl): Add generation of GIMPLE code.\n\nFrom-SVN: r212455", "tree": {"sha": "c16c8fe2e93ad3e0a29b89b70b9bdd36361365d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c16c8fe2e93ad3e0a29b89b70b9bdd36361365d5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a78cfa7fc14a35d4f5592ee177404e8b7c74d1e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a78cfa7fc14a35d4f5592ee177404e8b7c74d1e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a78cfa7fc14a35d4f5592ee177404e8b7c74d1e7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a78cfa7fc14a35d4f5592ee177404e8b7c74d1e7/comments", "author": {"login": "gareevroman", "id": 6114710, "node_id": "MDQ6VXNlcjYxMTQ3MTA=", "avatar_url": "https://avatars.githubusercontent.com/u/6114710?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gareevroman", "html_url": "https://github.com/gareevroman", "followers_url": "https://api.github.com/users/gareevroman/followers", "following_url": "https://api.github.com/users/gareevroman/following{/other_user}", "gists_url": "https://api.github.com/users/gareevroman/gists{/gist_id}", "starred_url": "https://api.github.com/users/gareevroman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gareevroman/subscriptions", "organizations_url": "https://api.github.com/users/gareevroman/orgs", "repos_url": "https://api.github.com/users/gareevroman/repos", "events_url": "https://api.github.com/users/gareevroman/events{/privacy}", "received_events_url": "https://api.github.com/users/gareevroman/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0218574ff5041815ef2c01dcb6d922c20ebf71c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0218574ff5041815ef2c01dcb6d922c20ebf71c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0218574ff5041815ef2c01dcb6d922c20ebf71c0"}], "stats": {"total": 611, "additions": 608, "deletions": 3}, "files": [{"sha": "730ef20ef6339b53d0fba22484ed09b5e8778db4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a78cfa7fc14a35d4f5592ee177404e8b7c74d1e7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a78cfa7fc14a35d4f5592ee177404e8b7c74d1e7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a78cfa7fc14a35d4f5592ee177404e8b7c74d1e7", "patch": "@@ -1,3 +1,27 @@\n+2014-07-11  Roman Gareev  <gareevroman@gmail.com>\n+\n+\t* graphite-isl-ast-to-gimple.c (gmp_cst_to_tree):\n+\tNew function.\n+\t(graphite_verify): New function.\n+\t(ivs_params_clear): New function.\n+\t(gcc_expression_from_isl_ast_expr_id): New function.\n+\t(gcc_expression_from_isl_expr_int): New function.\n+\t(binary_op_to_tree): New function.\n+\t(ternary_op_to_tree): New function.\n+\t(unary_op_to_tree): New function.\n+\t(nary_op_to_tree): New function.\n+\t(gcc_expression_from_isl_expr_op): New function.\n+\t(gcc_expression_from_isl_expression): New function.\n+\t(graphite_create_new_loop): New function.\n+\t(translate_isl_ast_for_loop): New function.\n+\t(get_upper_bound): New function.\n+\t(graphite_create_new_loop_guard): New function.\n+\t(translate_isl_ast_node_for): New function.\n+\t(translate_isl_ast): New function.\n+\t(add_parameters_to_ivs_params): New function.\n+\t(scop_to_isl_ast): New parameter ip.\n+\t(graphite_regenerate_ast_isl): Add generation of GIMPLE code.\n+\n 2014-07-11  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* config/xtensa/predicates.md (call expander): Update for"}, {"sha": "a8dfe7b62f11f9a3fe8114c3f3e317f9bdbea158", "filename": "gcc/graphite-isl-ast-to-gimple.c", "status": "modified", "additions": 584, "deletions": 3, "changes": 587, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a78cfa7fc14a35d4f5592ee177404e8b7c74d1e7/gcc%2Fgraphite-isl-ast-to-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a78cfa7fc14a35d4f5592ee177404e8b7c74d1e7/gcc%2Fgraphite-isl-ast-to-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-isl-ast-to-gimple.c?ref=a78cfa7fc14a35d4f5592ee177404e8b7c74d1e7", "patch": "@@ -25,6 +25,13 @@ along with GCC; see the file COPYING3.  If not see\n #include <isl/map.h>\n #include <isl/union_map.h>\n #include <isl/ast_build.h>\n+#if defined(__cplusplus)\n+extern \"C\" {\n+#endif\n+#include <isl/val_gmp.h>\n+#if defined(__cplusplus)\n+}\n+#endif\n #endif\n \n #include \"system.h\"\n@@ -42,6 +49,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cfgloop.h\"\n #include \"tree-data-ref.h\"\n #include \"sese.h\"\n+#include \"tree-ssa-loop-manip.h\"\n+#include \"tree-scalar-evolution.h\"\n+#include <map>\n \n #ifdef HAVE_cloog\n #include \"graphite-poly.h\"\n@@ -52,6 +62,515 @@ along with GCC; see the file COPYING3.  If not see\n \n static bool graphite_regenerate_error;\n \n+/* We always use signed 128, until isl is able to give information about\n+types  */\n+\n+static tree *graphite_expression_size_type = &int128_integer_type_node;\n+\n+/* Converts a GMP constant VAL to a tree and returns it.  */\n+\n+static tree\n+gmp_cst_to_tree (tree type, mpz_t val)\n+{\n+  tree t = type ? type : integer_type_node;\n+  mpz_t tmp;\n+\n+  mpz_init (tmp);\n+  mpz_set (tmp, val);\n+  wide_int wi = wi::from_mpz (t, tmp, true);\n+  mpz_clear (tmp);\n+\n+  return wide_int_to_tree (t, wi);\n+}\n+\n+/* Verifies properties that GRAPHITE should maintain during translation.  */\n+\n+static inline void\n+graphite_verify (void)\n+{\n+#ifdef ENABLE_CHECKING\n+  verify_loop_structure ();\n+  verify_loop_closed_ssa (true);\n+#endif\n+}\n+\n+/* IVS_PARAMS maps ISL's scattering and parameter identifiers\n+   to corresponding trees.  */\n+\n+typedef std::map<isl_id *, tree> ivs_params;\n+\n+/* Free all memory allocated for ISL's identifiers.  */\n+\n+void ivs_params_clear (ivs_params &ip)\n+{\n+  std::map<isl_id *, tree>::iterator it;\n+  for (it = ip.begin ();\n+       it != ip.end (); it++)\n+    {\n+      isl_id_free (it->first);\n+    }\n+}\n+\n+static tree\n+gcc_expression_from_isl_expression (tree type, __isl_take isl_ast_expr *,\n+\t\t\t\t    ivs_params &ip);\n+\n+/* Return the tree variable that corresponds to the given isl ast identifier\n+ expression (an isl_ast_expr of type isl_ast_expr_id).  */\n+\n+static tree\n+gcc_expression_from_isl_ast_expr_id (__isl_keep isl_ast_expr *expr_id,\n+\t\t\t\t     ivs_params &ip)\n+{\n+  gcc_assert (isl_ast_expr_get_type (expr_id) == isl_ast_expr_id);\n+  isl_id *tmp_isl_id = isl_ast_expr_get_id (expr_id);\n+  std::map<isl_id *, tree>::iterator res;\n+  res = ip.find (tmp_isl_id);\n+  isl_id_free (tmp_isl_id);\n+  gcc_assert (res != ip.end () &&\n+              \"Could not map isl_id to tree expression\");\n+  isl_ast_expr_free (expr_id);\n+  return res->second;\n+}\n+\n+/* Converts an isl_ast_expr_int expression E to a GCC expression tree of\n+   type TYPE.  */\n+\n+static tree\n+gcc_expression_from_isl_expr_int (tree type, __isl_take isl_ast_expr *expr)\n+{\n+  gcc_assert (isl_ast_expr_get_type (expr) == isl_ast_expr_int);\n+  isl_val *val = isl_ast_expr_get_val (expr);\n+  mpz_t val_mpz_t;\n+  mpz_init (val_mpz_t);\n+  tree res;\n+  if (isl_val_get_num_gmp (val, val_mpz_t) == -1)\n+    res = NULL_TREE;\n+  else\n+    res = gmp_cst_to_tree (type, val_mpz_t);\n+  isl_val_free (val);\n+  isl_ast_expr_free (expr);\n+  mpz_clear (val_mpz_t);\n+  return res;\n+}\n+\n+/* Converts a binary isl_ast_expr_op expression E to a GCC expression tree of\n+   type TYPE.  */\n+\n+static tree\n+binary_op_to_tree (tree type, __isl_take isl_ast_expr *expr, ivs_params &ip)\n+{\n+  isl_ast_expr *arg_expr = isl_ast_expr_get_op_arg (expr, 0);\n+  tree tree_lhs_expr = gcc_expression_from_isl_expression (type, arg_expr, ip);\n+  arg_expr = isl_ast_expr_get_op_arg (expr, 1);\n+  tree tree_rhs_expr = gcc_expression_from_isl_expression (type, arg_expr, ip);\n+  enum isl_ast_op_type expr_type = isl_ast_expr_get_op_type (expr);\n+  isl_ast_expr_free (expr);\n+  switch (expr_type)\n+    {\n+    case isl_ast_op_add:\n+      return fold_build2 (PLUS_EXPR, type, tree_lhs_expr, tree_rhs_expr);\n+\n+    case isl_ast_op_sub:\n+      return fold_build2 (MINUS_EXPR, type, tree_lhs_expr, tree_rhs_expr);\n+\n+    case isl_ast_op_mul:\n+      return fold_build2 (MULT_EXPR, type, tree_lhs_expr, tree_rhs_expr);\n+\n+    case isl_ast_op_div:\n+      return fold_build2 (EXACT_DIV_EXPR, type, tree_lhs_expr, tree_rhs_expr);\n+\n+    case isl_ast_op_fdiv_q:\n+      return fold_build2 (FLOOR_DIV_EXPR, type, tree_lhs_expr, tree_rhs_expr);\n+\n+    case isl_ast_op_and:\n+      return fold_build2 (TRUTH_ANDIF_EXPR, type,\n+\t\t\t  tree_lhs_expr, tree_rhs_expr);\n+\n+    case isl_ast_op_or:\n+      return fold_build2 (TRUTH_ORIF_EXPR, type, tree_lhs_expr, tree_rhs_expr);\n+\n+    case isl_ast_op_eq:\n+      return fold_build2 (EQ_EXPR, type, tree_lhs_expr, tree_rhs_expr);\n+\n+    case isl_ast_op_le:\n+      return fold_build2 (LE_EXPR, type, tree_lhs_expr, tree_rhs_expr);\n+\n+    case isl_ast_op_lt:\n+      return fold_build2 (LT_EXPR, type, tree_lhs_expr, tree_rhs_expr);\n+\n+    case isl_ast_op_ge:\n+      return fold_build2 (GE_EXPR, type, tree_lhs_expr, tree_rhs_expr);\n+\n+    case isl_ast_op_gt:\n+      return fold_build2 (GT_EXPR, type, tree_lhs_expr, tree_rhs_expr);\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* Converts a ternary isl_ast_expr_op expression E to a GCC expression tree of\n+   type TYPE.  */\n+\n+static tree\n+ternary_op_to_tree (tree type, __isl_take isl_ast_expr *expr, ivs_params &ip)\n+{\n+  gcc_assert (isl_ast_expr_get_op_type (expr) == isl_ast_op_minus);\n+  isl_ast_expr *arg_expr = isl_ast_expr_get_op_arg (expr, 0);\n+  tree tree_first_expr\n+    = gcc_expression_from_isl_expression (type, arg_expr, ip);\n+  arg_expr = isl_ast_expr_get_op_arg (expr, 1);\n+  tree tree_second_expr\n+    = gcc_expression_from_isl_expression (type, arg_expr, ip);\n+  arg_expr = isl_ast_expr_get_op_arg (expr, 2);\n+  tree tree_third_expr\n+    = gcc_expression_from_isl_expression (type, arg_expr, ip);\n+  isl_ast_expr_free (expr);\n+  return fold_build3 (COND_EXPR, type, tree_first_expr,\n+\t\t      tree_second_expr, tree_third_expr);\n+}\n+\n+/* Converts a unary isl_ast_expr_op expression E to a GCC expression tree of\n+   type TYPE.  */\n+\n+static tree\n+unary_op_to_tree (tree type, __isl_take isl_ast_expr *expr, ivs_params &ip)\n+{\n+  gcc_assert (isl_ast_expr_get_op_type (expr) == isl_ast_op_minus);\n+  isl_ast_expr *arg_expr = isl_ast_expr_get_op_arg (expr, 0);\n+  tree tree_expr = gcc_expression_from_isl_expression (type, arg_expr, ip);\n+  isl_ast_expr_free (expr);\n+  return fold_build1 (NEGATE_EXPR, type, tree_expr);\n+}\n+\n+/* Converts an isl_ast_expr_op expression E with unknown number of arguments\n+   to a GCC expression tree of type TYPE.  */\n+\n+static tree\n+nary_op_to_tree (tree type, __isl_take isl_ast_expr *expr, ivs_params &ip)\n+{\n+  enum tree_code op_code;\n+  switch (isl_ast_expr_get_op_type (expr))\n+    {\n+    case isl_ast_op_max:\n+      op_code = MAX_EXPR;\n+      break;\n+\n+    case isl_ast_op_min:\n+      op_code = MIN_EXPR;\n+      break;\n+\n+    default:\n+      gcc_unreachable ();    \n+    }\n+  isl_ast_expr *arg_expr = isl_ast_expr_get_op_arg (expr, 0);\n+  tree res = gcc_expression_from_isl_expression (type, arg_expr, ip);\n+  int i;\n+  for (i = 1; i < isl_ast_expr_get_op_n_arg (expr); i++)\n+    {\n+      arg_expr = isl_ast_expr_get_op_arg (expr, i);\n+      tree t = gcc_expression_from_isl_expression (type, arg_expr, ip);\n+      res = fold_build2 (op_code, type, res, t);\n+    }\n+  isl_ast_expr_free (expr);\n+  return res;\n+}\n+\n+\n+/* Converts an isl_ast_expr_op expression E to a GCC expression tree of\n+   type TYPE.  */\n+\n+static tree\n+gcc_expression_from_isl_expr_op (tree type, __isl_take isl_ast_expr *expr,\n+\t\t\t\t ivs_params &ip)\n+{\n+  gcc_assert (isl_ast_expr_get_type (expr) == isl_ast_expr_op);\n+  switch (isl_ast_expr_get_op_type (expr))\n+    {\n+    /* These isl ast expressions are not supported yet.  */\n+    case isl_ast_op_error:\n+    case isl_ast_op_call:\n+    case isl_ast_op_and_then:\n+    case isl_ast_op_or_else:\n+    case isl_ast_op_pdiv_q:\n+    case isl_ast_op_pdiv_r:\n+    case isl_ast_op_select:\n+      gcc_unreachable ();\n+\n+    case isl_ast_op_max:\n+    case isl_ast_op_min:\n+      return nary_op_to_tree (type, expr, ip);\n+\n+    case isl_ast_op_add:\n+    case isl_ast_op_sub:\n+    case isl_ast_op_mul:\n+    case isl_ast_op_div:\n+    case isl_ast_op_fdiv_q:\n+    case isl_ast_op_and:\n+    case isl_ast_op_or:\n+    case isl_ast_op_eq:\n+    case isl_ast_op_le:\n+    case isl_ast_op_lt:\n+    case isl_ast_op_ge:\n+    case isl_ast_op_gt:\n+      return binary_op_to_tree (type, expr, ip);\n+\n+    case isl_ast_op_minus:\n+      return unary_op_to_tree (type, expr, ip);\n+\n+    case isl_ast_op_cond:\n+      return ternary_op_to_tree (type, expr, ip);\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Converts an ISL AST expression E back to a GCC expression tree of\n+   type TYPE.  */\n+\n+static tree\n+gcc_expression_from_isl_expression (tree type, __isl_take isl_ast_expr *expr,\n+\t\t\t\t    ivs_params &ip)\n+{\n+  switch (isl_ast_expr_get_type (expr))\n+    {\n+    case isl_ast_expr_id:\n+      return gcc_expression_from_isl_ast_expr_id (expr, ip);\n+\n+    case isl_ast_expr_int:\n+      return gcc_expression_from_isl_expr_int (type, expr);\n+\n+    case isl_ast_expr_op:\n+      return gcc_expression_from_isl_expr_op (type, expr, ip);\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Creates a new LOOP corresponding to isl_ast_node_for.  Inserts an\n+   induction variable for the new LOOP.  New LOOP is attached to CFG\n+   starting at ENTRY_EDGE.  LOOP is inserted into the loop tree and\n+   becomes the child loop of the OUTER_LOOP.  NEWIVS_INDEX binds\n+   ISL's scattering name to the induction variable created for the\n+   loop of STMT.  The new induction variable is inserted in the NEWIVS\n+   vector and is of type TYPE.  */\n+\n+static struct loop *\n+graphite_create_new_loop (edge entry_edge, __isl_keep isl_ast_node *node_for,\n+\t\t\t  loop_p outer, tree type, tree lb, tree ub,\n+\t\t\t  ivs_params &ip)\n+{\n+  isl_ast_expr *for_inc = isl_ast_node_for_get_inc (node_for);\n+  tree stride = gcc_expression_from_isl_expression (type, for_inc, ip);\n+  tree ivvar = create_tmp_var (type, \"graphite_IV\");\n+  tree iv, iv_after_increment;\n+  loop_p loop = create_empty_loop_on_edge\n+    (entry_edge, lb, stride, ub, ivvar, &iv, &iv_after_increment,\n+     outer ? outer : entry_edge->src->loop_father);\n+\n+  isl_ast_expr *for_iterator = isl_ast_node_for_get_iterator (node_for);\n+  isl_id *id = isl_ast_expr_get_id (for_iterator);\n+  ip[id] = iv;\n+  isl_ast_expr_free (for_iterator);\n+  return loop;\n+}\n+\n+static edge\n+translate_isl_ast (loop_p context_loop, __isl_keep isl_ast_node *node,\n+\t\t   edge next_e, ivs_params &ip);\n+\n+/* Create the loop for a isl_ast_node_for.\n+\n+   - NEXT_E is the edge where new generated code should be attached.  */\n+\n+static edge\n+translate_isl_ast_for_loop (loop_p context_loop,\n+\t\t\t    __isl_keep isl_ast_node *node_for, edge next_e,\n+\t\t\t    tree type, tree lb, tree ub,\n+\t\t\t    ivs_params &ip)\n+{\n+  gcc_assert (isl_ast_node_get_type (node_for) == isl_ast_node_for);\n+  struct loop *loop = graphite_create_new_loop (next_e, node_for, context_loop,\n+\t\t\t\t\t\ttype, lb, ub, ip);\n+  edge last_e = single_exit (loop);\n+  edge to_body = single_succ_edge (loop->header);\n+  basic_block after = to_body->dest;\n+\n+  /* Create a basic block for loop close phi nodes.  */\n+  last_e = single_succ_edge (split_edge (last_e));\n+\n+  /* Translate the body of the loop.  */\n+  isl_ast_node *for_body = isl_ast_node_for_get_body (node_for);\n+  next_e = translate_isl_ast (loop, for_body, to_body, ip);\n+  isl_ast_node_free (for_body);\n+  redirect_edge_succ_nodup (next_e, after);\n+  set_immediate_dominator (CDI_DOMINATORS, next_e->dest, next_e->src);\n+\n+  /* TODO: Add checking for the loop parallelism.  */\n+\n+  return last_e;\n+}\n+\n+/* We use this function to get the upper bound because of the form,\n+   which is used by isl to represent loops:\n+\n+   for (iterator = init; cond; iterator += inc)\n+\n+   {\n+\n+     ...\n+\n+   }\n+\n+   The loop condition is an arbitrary expression, which contains the\n+   current loop iterator.\n+\n+   (e.g. iterator + 3 < B && C > iterator + A)\n+\n+   We have to know the upper bound of the iterator to generate a loop\n+   in Gimple form. It can be obtained from the special representation\n+   of the loop condition, which is generated by isl,\n+   if the ast_build_atomic_upper_bound option is set. In this case,\n+   isl generates a loop condition that consists of the current loop\n+   iterator, + an operator (< or <=) and an expression not involving\n+   the iterator, which is processed and returned by this function.\n+\n+   (e.g iterator <= upper-bound-expression-without-iterator)  */\n+\n+static __isl_give isl_ast_expr *\n+get_upper_bound (__isl_keep isl_ast_node *node_for)\n+{\n+  gcc_assert (isl_ast_node_get_type (node_for) == isl_ast_node_for);\n+  isl_ast_expr *for_cond = isl_ast_node_for_get_cond (node_for);\n+  gcc_assert (isl_ast_expr_get_type (for_cond) == isl_ast_expr_op);\n+  isl_ast_expr *res;\n+  switch (isl_ast_expr_get_op_type (for_cond))\n+    {\n+    case isl_ast_op_le:\n+      res = isl_ast_expr_get_op_arg (for_cond, 1);\n+      break;\n+\n+    case isl_ast_op_lt:\n+      {\n+        // (iterator < ub) => (iterator <= ub - 1)\n+        isl_val *one = isl_val_int_from_si (isl_ast_expr_get_ctx (for_cond), 1);\n+        isl_ast_expr *ub = isl_ast_expr_get_op_arg (for_cond, 1);\n+        res = isl_ast_expr_sub (ub, isl_ast_expr_from_val (one));\n+        break;\n+      }\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+  isl_ast_expr_free (for_cond);\n+  return res;\n+}\n+\n+/* All loops generated by create_empty_loop_on_edge have the form of\n+   a post-test loop:\n+\n+   do\n+\n+   {\n+     body of the loop;\n+   } while (lower bound < upper bound);\n+\n+   We create a new if region protecting the loop to be executed, if\n+   the execution count is zero (lower bound > upper bound).  */\n+\n+static edge\n+graphite_create_new_loop_guard (edge entry_edge,\n+\t\t\t\t__isl_keep isl_ast_node *node_for, tree *type,\n+\t\t\t\ttree *lb, tree *ub, ivs_params &ip)\n+{\n+  gcc_assert (isl_ast_node_get_type (node_for) == isl_ast_node_for);\n+  tree cond_expr;\n+  edge exit_edge;\n+\n+  *type = *graphite_expression_size_type;\n+  isl_ast_expr *for_init = isl_ast_node_for_get_init (node_for);\n+  *lb = gcc_expression_from_isl_expression (*type, for_init, ip);\n+  isl_ast_expr *upper_bound = get_upper_bound (node_for);\n+  *ub = gcc_expression_from_isl_expression (*type, upper_bound, ip);\n+  \n+  /* When ub is simply a constant or a parameter, use lb <= ub.  */\n+  if (TREE_CODE (*ub) == INTEGER_CST || TREE_CODE (*ub) == SSA_NAME)\n+    cond_expr = fold_build2 (LE_EXPR, boolean_type_node, *lb, *ub);\n+  else\n+    {\n+      tree one = (POINTER_TYPE_P (*type)\n+\t\t  ? convert_to_ptrofftype (integer_one_node)\n+\t\t  : fold_convert (*type, integer_one_node));\n+      /* Adding +1 and using LT_EXPR helps with loop latches that have a\n+\t loop iteration count of \"PARAMETER - 1\".  For PARAMETER == 0 this\n+\t becomes 2^k-1 due to integer overflow, and the condition lb <= ub\n+\t is true, even if we do not want this.  However lb < ub + 1 is false,\n+\t as expected.  */\n+      tree ub_one = fold_build2 (POINTER_TYPE_P (*type) ? POINTER_PLUS_EXPR\n+\t\t\t\t : PLUS_EXPR, *type, *ub, one);\n+\n+      cond_expr = fold_build2 (LT_EXPR, boolean_type_node, *lb, ub_one);\n+    }\n+\n+  exit_edge = create_empty_if_region_on_edge (entry_edge, cond_expr);\n+\n+  return exit_edge;\n+}\n+\n+/* Translates an isl_ast_node_for to Gimple. */\n+\n+static edge\n+translate_isl_ast_node_for (loop_p context_loop, __isl_keep isl_ast_node *node,\n+\t\t\t    edge next_e, ivs_params &ip)\n+{\n+  gcc_assert (isl_ast_node_get_type (node) == isl_ast_node_for);\n+  tree type, lb, ub;\n+  edge last_e = graphite_create_new_loop_guard (next_e, node, &type,\n+\t\t\t\t\t\t&lb, &ub, ip);\n+  edge true_e = get_true_edge_from_guard_bb (next_e->dest);\n+\n+  translate_isl_ast_for_loop (context_loop, node, true_e,\n+\t\t\t      type, lb, ub, ip);\n+  return last_e;\n+}\n+\n+/* Translates an ISL AST node NODE to GCC representation in the\n+   context of a SESE.  */\n+\n+static edge\n+translate_isl_ast (loop_p context_loop, __isl_keep isl_ast_node *node,\n+\t\t   edge next_e, ivs_params &ip)\n+{\n+  switch (isl_ast_node_get_type (node))\n+    {\n+    case isl_ast_node_error:\n+      gcc_unreachable ();\n+\n+    case isl_ast_node_for:\n+      return translate_isl_ast_node_for (context_loop, node,\n+\t\t\t\t\t next_e, ip);\n+\n+    case isl_ast_node_if:\n+      return next_e;\n+\n+    case isl_ast_node_user:\n+      return next_e;\n+\n+    case isl_ast_node_block:\n+      return next_e;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n /* Prints NODE to FILE.  */\n \n void\n@@ -65,6 +584,23 @@ print_isl_ast_node (FILE *file, __isl_keep isl_ast_node *node,\n   isl_printer_free (prn);\n }\n \n+/* Add ISL's parameter identifiers and corresponding.trees to ivs_params  */\n+\n+static void\n+add_parameters_to_ivs_params (scop_p scop, ivs_params &ip)\n+{\n+  sese region = SCOP_REGION (scop);\n+  unsigned nb_parameters = isl_set_dim (scop->context, isl_dim_param);\n+  gcc_assert (nb_parameters == SESE_PARAMS (region).length ());\n+  unsigned i;\n+  for (i = 0; i < nb_parameters; i++)\n+    {\n+      isl_id *tmp_id = isl_set_get_dim_id (scop->context, isl_dim_param, i);\n+      ip[tmp_id] = SESE_PARAMS (region)[i];\n+    }\n+}\n+\n+\n /* Generates a build, which specifies the constraints on the parameters.  */\n \n static __isl_give isl_ast_build *\n@@ -103,8 +639,15 @@ generate_isl_schedule (scop_p scop)\n }\n \n static __isl_give isl_ast_node *\n-scop_to_isl_ast (scop_p scop)\n+scop_to_isl_ast (scop_p scop, ivs_params &ip)\n {\n+  /* Generate loop upper bounds that consist of the current loop iterator,\n+  an operator (< or <=) and an expression not involving the iterator.\n+  If this option is not set, then the current loop iterator may appear several\n+  times in the upper bound. See the isl manual for more details.  */\n+  isl_options_set_ast_build_atomic_upper_bound (scop->ctx, true);\n+\n+  add_parameters_to_ivs_params (scop, ip);\n   isl_union_map *schedule_isl = generate_isl_schedule (scop);\n   isl_ast_build *context_isl = generate_isl_context (scop);\n   isl_ast_node *ast_isl = isl_ast_build_ast_from_schedule (context_isl,\n@@ -117,21 +660,59 @@ scop_to_isl_ast (scop_p scop)\n    the given SCOP.  Return true if code generation succeeded.\n \n    FIXME: This is not yet a full implementation of the code generator\n-          with ISL ASTs. Generation of GIMPLE code is have to be added.  */\n+          with ISL ASTs. Generation of GIMPLE code has to be completed.  */\n \n bool\n graphite_regenerate_ast_isl (scop_p scop)\n {\n+  loop_p context_loop;\n+  sese region = SCOP_REGION (scop);\n+  ifsese if_region = NULL;\n+  isl_ast_node *root_node;\n+  ivs_params ip;\n+\n   timevar_push (TV_GRAPHITE_CODE_GEN);\n   graphite_regenerate_error = false;\n-  isl_ast_node *root_node = scop_to_isl_ast (scop);\n+  root_node = scop_to_isl_ast (scop, ip);\n+\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       fprintf (dump_file, \"\\nISL AST generated by ISL: \\n\");\n       print_isl_ast_node (dump_file, root_node, scop->ctx);\n+      fprintf (dump_file, \"\\n\");\n     }\n+\n+  recompute_all_dominators ();\n+  graphite_verify ();\n+\n+  if_region = move_sese_in_condition (region);\n+  sese_insert_phis_for_liveouts (region,\n+\t\t\t\t if_region->region->exit->src,\n+\t\t\t\t if_region->false_region->exit,\n+\t\t\t\t if_region->true_region->exit);\n+  recompute_all_dominators ();\n+  graphite_verify ();\n+\n+  context_loop = SESE_ENTRY (region)->src->loop_father;\n+\n+  translate_isl_ast (context_loop, root_node, if_region->true_region->entry,\n+\t\t     ip);\n+  graphite_verify ();\n+  scev_reset ();\n+  recompute_all_dominators ();\n+  graphite_verify ();\n+\n+  if (graphite_regenerate_error)\n+    set_ifsese_condition (if_region, integer_zero_node);\n+\n+  free (if_region->true_region);\n+  free (if_region->region);\n+  free (if_region);\n+\n+  ivs_params_clear (ip);\n   isl_ast_node_free (root_node);\n   timevar_pop (TV_GRAPHITE_CODE_GEN);\n+  /* TODO: Add dump  */\n   return !graphite_regenerate_error;\n }\n #endif"}]}