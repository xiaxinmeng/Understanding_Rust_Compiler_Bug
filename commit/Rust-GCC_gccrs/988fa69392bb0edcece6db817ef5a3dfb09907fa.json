{"sha": "988fa69392bb0edcece6db817ef5a3dfb09907fa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTg4ZmE2OTM5MmJiMGVkY2VjZTZkYjgxN2VmNWEzZGZiMDk5MDdmYQ==", "commit": {"author": {"name": "James Greenhalgh", "email": "james.greenhalgh@arm.com", "date": "2014-07-31T15:31:24Z"}, "committer": {"name": "James Greenhalgh", "email": "jgreenhalgh@gcc.gnu.org", "date": "2014-07-31T15:31:24Z"}, "message": "[AArch64_be] Fix vec_select hi/lo mask confusions.\n\ngcc/\n\n\t* config/aarch64/aarch64.c (aarch64_simd_vect_par_cnst_half): Vary\n\tthe generated mask based on BYTES_BIG_ENDIAN.\n\t(aarch64_simd_check_vect_par_cnst_half): New.\n\t* config/aarch64/aarch64-protos.h\n\t(aarch64_simd_check_vect_par_cnst_half): New.\n\t* config/aarch64/predicates.md (vect_par_cnst_hi_half): Refactor\n\tthe check out to aarch64_simd_check_vect_par_cnst_half.\n\t(vect_par_cnst_lo_half): Likewise.\n\t* config/aarch64/aarch64-simd.md\n\t(aarch64_simd_move_hi_quad_<mode>): Always use vec_par_cnst_lo_half.\n\t(move_hi_quad_<mode>): Always generate a low mask.\n\nFrom-SVN: r213378", "tree": {"sha": "c06f413cb718bc0d68ffa6007f06a2d0c7f11744", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c06f413cb718bc0d68ffa6007f06a2d0c7f11744"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/988fa69392bb0edcece6db817ef5a3dfb09907fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/988fa69392bb0edcece6db817ef5a3dfb09907fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/988fa69392bb0edcece6db817ef5a3dfb09907fa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/988fa69392bb0edcece6db817ef5a3dfb09907fa/comments", "author": {"login": "jgreenhalgh-arm", "id": 6104025, "node_id": "MDQ6VXNlcjYxMDQwMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6104025?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jgreenhalgh-arm", "html_url": "https://github.com/jgreenhalgh-arm", "followers_url": "https://api.github.com/users/jgreenhalgh-arm/followers", "following_url": "https://api.github.com/users/jgreenhalgh-arm/following{/other_user}", "gists_url": "https://api.github.com/users/jgreenhalgh-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jgreenhalgh-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jgreenhalgh-arm/subscriptions", "organizations_url": "https://api.github.com/users/jgreenhalgh-arm/orgs", "repos_url": "https://api.github.com/users/jgreenhalgh-arm/repos", "events_url": "https://api.github.com/users/jgreenhalgh-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/jgreenhalgh-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "08938c896fd1a409bd70218154b7073e81de398e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08938c896fd1a409bd70218154b7073e81de398e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08938c896fd1a409bd70218154b7073e81de398e"}], "stats": {"total": 135, "additions": 81, "deletions": 54}, "files": [{"sha": "b0ebfbac70e4208f08ffcb7c5e51c34fafd96cb6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/988fa69392bb0edcece6db817ef5a3dfb09907fa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/988fa69392bb0edcece6db817ef5a3dfb09907fa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=988fa69392bb0edcece6db817ef5a3dfb09907fa", "patch": "@@ -1,3 +1,17 @@\n+2014-07-31  James Greenhalgh  <james.greenhalgh@arm.com>\n+\n+\t* config/aarch64/aarch64.c (aarch64_simd_vect_par_cnst_half): Vary\n+\tthe generated mask based on BYTES_BIG_ENDIAN.\n+\t(aarch64_simd_check_vect_par_cnst_half): New.\n+\t* config/aarch64/aarch64-protos.h\n+\t(aarch64_simd_check_vect_par_cnst_half): New.\n+\t* config/aarch64/predicates.md (vect_par_cnst_hi_half): Refactor\n+\tthe check out to aarch64_simd_check_vect_par_cnst_half.\n+\t(vect_par_cnst_lo_half): Likewise.\n+\t* config/aarch64/aarch64-simd.md\n+\t(aarch64_simd_move_hi_quad_<mode>): Always use vec_par_cnst_lo_half.\n+\t(move_hi_quad_<mode>): Always generate a low mask.\n+\n 2014-07-30  Senthil Kumar Selvaraj  <senthil_kumar.selvaraj@atmel.com>\n \n \t* doc/invoke.texi (AVR Options): Add documentation about"}, {"sha": "927a20e4bf7621e72e0b0a01ce1a70cf8d83edfa", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/988fa69392bb0edcece6db817ef5a3dfb09907fa/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/988fa69392bb0edcece6db817ef5a3dfb09907fa/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=988fa69392bb0edcece6db817ef5a3dfb09907fa", "patch": "@@ -200,6 +200,8 @@ bool aarch64_pad_arg_upward (enum machine_mode, const_tree);\n bool aarch64_pad_reg_upward (enum machine_mode, const_tree, bool);\n bool aarch64_regno_ok_for_base_p (int, bool);\n bool aarch64_regno_ok_for_index_p (int, bool);\n+bool aarch64_simd_check_vect_par_cnst_half (rtx op, enum machine_mode mode,\n+\t\t\t\t\t    bool high);\n bool aarch64_simd_imm_scalar_p (rtx x, enum machine_mode mode);\n bool aarch64_simd_imm_zero_p (rtx, enum machine_mode);\n bool aarch64_simd_scalar_immediate_valid_for_move (rtx, enum machine_mode);"}, {"sha": "0d4b37e53b758919aea382c22d1c600f113a8b54", "filename": "gcc/config/aarch64/aarch64-simd.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/988fa69392bb0edcece6db817ef5a3dfb09907fa/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/988fa69392bb0edcece6db817ef5a3dfb09907fa/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md?ref=988fa69392bb0edcece6db817ef5a3dfb09907fa", "patch": "@@ -1022,7 +1022,7 @@\n \t  (match_operand:<VHALF> 1 \"register_operand\" \"w,r\")\n           (vec_select:<VHALF>\n                 (match_dup 0)\n-                (match_operand:VQ 2 \"vect_par_cnst_hi_half\" \"\"))))]\n+                (match_operand:VQ 2 \"vect_par_cnst_lo_half\" \"\"))))]\n   \"TARGET_SIMD && BYTES_BIG_ENDIAN\"\n   \"@\n    ins\\\\t%0.d[1], %1.d[0]\n@@ -1035,7 +1035,7 @@\n   (match_operand:<VHALF> 1 \"register_operand\" \"\")]\n  \"TARGET_SIMD\"\n {\n-  rtx p = aarch64_simd_vect_par_cnst_half (<MODE>mode, BYTES_BIG_ENDIAN);\n+  rtx p = aarch64_simd_vect_par_cnst_half (<MODE>mode, false);\n   if (BYTES_BIG_ENDIAN)\n     emit_insn (gen_aarch64_simd_move_hi_quad_be_<mode> (operands[0],\n \t\t    operands[1], p));"}, {"sha": "2ea55e8a29d837d04c2bb6ff042fc16370790f17", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 61, "deletions": 3, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/988fa69392bb0edcece6db817ef5a3dfb09907fa/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/988fa69392bb0edcece6db817ef5a3dfb09907fa/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=988fa69392bb0edcece6db817ef5a3dfb09907fa", "patch": "@@ -7900,23 +7900,81 @@ aarch64_simd_scalar_immediate_valid_for_move (rtx op, enum machine_mode mode)\n   return aarch64_simd_valid_immediate (op_v, vmode, false, NULL);\n }\n \n-/* Construct and return a PARALLEL RTX vector.  */\n+/* Construct and return a PARALLEL RTX vector with elements numbering the\n+   lanes of either the high (HIGH == TRUE) or low (HIGH == FALSE) half of\n+   the vector - from the perspective of the architecture.  This does not\n+   line up with GCC's perspective on lane numbers, so we end up with\n+   different masks depending on our target endian-ness.  The diagram\n+   below may help.  We must draw the distinction when building masks\n+   which select one half of the vector.  An instruction selecting\n+   architectural low-lanes for a big-endian target, must be described using\n+   a mask selecting GCC high-lanes.\n+\n+                 Big-Endian             Little-Endian\n+\n+GCC             0   1   2   3           3   2   1   0\n+              | x | x | x | x |       | x | x | x | x |\n+Architecture    3   2   1   0           3   2   1   0\n+\n+Low Mask:         { 2, 3 }                { 0, 1 }\n+High Mask:        { 0, 1 }                { 2, 3 }\n+*/\n+\n rtx\n aarch64_simd_vect_par_cnst_half (enum machine_mode mode, bool high)\n {\n   int nunits = GET_MODE_NUNITS (mode);\n   rtvec v = rtvec_alloc (nunits / 2);\n-  int base = high ? nunits / 2 : 0;\n+  int high_base = nunits / 2;\n+  int low_base = 0;\n+  int base;\n   rtx t1;\n   int i;\n \n-  for (i=0; i < nunits / 2; i++)\n+  if (BYTES_BIG_ENDIAN)\n+    base = high ? low_base : high_base;\n+  else\n+    base = high ? high_base : low_base;\n+\n+  for (i = 0; i < nunits / 2; i++)\n     RTVEC_ELT (v, i) = GEN_INT (base + i);\n \n   t1 = gen_rtx_PARALLEL (mode, v);\n   return t1;\n }\n \n+/* Check OP for validity as a PARALLEL RTX vector with elements\n+   numbering the lanes of either the high (HIGH == TRUE) or low lanes,\n+   from the perspective of the architecture.  See the diagram above\n+   aarch64_simd_vect_par_cnst_half for more details.  */\n+\n+bool\n+aarch64_simd_check_vect_par_cnst_half (rtx op, enum machine_mode mode,\n+\t\t\t\t       bool high)\n+{\n+  rtx ideal = aarch64_simd_vect_par_cnst_half (mode, high);\n+  HOST_WIDE_INT count_op = XVECLEN (op, 0);\n+  HOST_WIDE_INT count_ideal = XVECLEN (ideal, 0);\n+  int i = 0;\n+\n+  if (!VECTOR_MODE_P (mode))\n+    return false;\n+\n+  if (count_op != count_ideal)\n+    return false;\n+\n+  for (i = 0; i < count_ideal; i++)\n+    {\n+      rtx elt_op = XVECEXP (op, 0, i);\n+      rtx elt_ideal = XVECEXP (ideal, 0, i);\n+\n+      if (GET_CODE (elt_op) != CONST_INT\n+\t  || INTVAL (elt_ideal) != INTVAL (elt_op))\n+\treturn false;\n+    }\n+  return true;\n+}\n+\n /* Bounds-check lanes.  Ensure OPERAND lies between LOW (inclusive) and\n    HIGH (exclusive).  */\n void"}, {"sha": "95d1910ccece59fcc1c0a56d27ed084362710d10", "filename": "gcc/config/aarch64/predicates.md", "status": "modified", "additions": 2, "deletions": 49, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/988fa69392bb0edcece6db817ef5a3dfb09907fa/gcc%2Fconfig%2Faarch64%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/988fa69392bb0edcece6db817ef5a3dfb09907fa/gcc%2Fconfig%2Faarch64%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fpredicates.md?ref=988fa69392bb0edcece6db817ef5a3dfb09907fa", "patch": "@@ -207,62 +207,15 @@\n (define_special_predicate \"vect_par_cnst_hi_half\"\n   (match_code \"parallel\")\n {\n-  HOST_WIDE_INT count = XVECLEN (op, 0);\n-  int nunits = GET_MODE_NUNITS (mode);\n-  int i;\n-\n-  if (count < 1\n-      || count != nunits / 2)\n-    return false;\n- \n-  if (!VECTOR_MODE_P (mode))\n-    return false;\n-\n-  for (i = 0; i < count; i++)\n-   {\n-     rtx elt = XVECEXP (op, 0, i);\n-     int val;\n-\n-     if (GET_CODE (elt) != CONST_INT)\n-       return false;\n-\n-     val = INTVAL (elt);\n-     if (val != (nunits / 2) + i)\n-       return false;\n-   }\n-  return true;\n+  return aarch64_simd_check_vect_par_cnst_half (op, mode, true);\n })\n \n (define_special_predicate \"vect_par_cnst_lo_half\"\n   (match_code \"parallel\")\n {\n-  HOST_WIDE_INT count = XVECLEN (op, 0);\n-  int nunits = GET_MODE_NUNITS (mode);\n-  int i;\n-\n-  if (count < 1\n-      || count != nunits / 2)\n-    return false;\n-\n-  if (!VECTOR_MODE_P (mode))\n-    return false;\n-\n-  for (i = 0; i < count; i++)\n-   {\n-     rtx elt = XVECEXP (op, 0, i);\n-     int val;\n-\n-     if (GET_CODE (elt) != CONST_INT)\n-       return false;\n-\n-     val = INTVAL (elt);\n-     if (val != i)\n-       return false;\n-   }\n-  return true;\n+  return aarch64_simd_check_vect_par_cnst_half (op, mode, false);\n })\n \n-\n (define_special_predicate \"aarch64_simd_lshift_imm\"\n   (match_code \"const_vector\")\n {"}]}