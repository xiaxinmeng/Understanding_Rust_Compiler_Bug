{"sha": "c31500c27ec5d01968d24779683074f0002723b3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzMxNTAwYzI3ZWM1ZDAxOTY4ZDI0Nzc5NjgzMDc0ZjAwMDI3MjNiMw==", "commit": {"author": {"name": "Hans-Peter Nilsson", "email": "hp@gcc.gnu.org", "date": "2007-12-15T21:36:30Z"}, "committer": {"name": "Hans-Peter Nilsson", "email": "hp@gcc.gnu.org", "date": "2007-12-15T21:36:30Z"}, "message": "cris.c (ASSERT_PLT_UNSPEC): Remove unused macro.\n\n\t* config/cris/cris.c (ASSERT_PLT_UNSPEC): Remove unused macro.\n\t(cris_movem_load_rest_p, cris_store_multiple_op_p): Remove FIXME.\n\tChange regno_dir and regno only if !TARGET_V32.\n\t(cris_conditional_register_usage): If TARGET_V32, set\n\treg_alloc_order as per REG_ALLOC_ORDER_V32 and make\n\tCRIS_ACR_REGNUM non-fixed.\n\t(cris_print_base): Add gcc_assert for post_inc on CRIS_ACR_REGNUM.\n\t(cris_print_operand) <case 'Z', case 'u'>: New cases.\n\t<case REG of case 'H'>: Allow for CRIS_SRP_REGNUM.\n\t(cris_reload_address_legitimized): Always return false for\n\tTARGET_V32.\n\t(cris_register_move_cost): New function, guts from\n\tREGISTER_MOVE_COST adjusted for CRIS v32.\n\t(cris_normal_notice_update_cc): New function split out from...\n\t(cris_notice_update_cc): Set cc_status.flags CC_REVERSED for\n\tTARGET_CCINIT.  Call cris_normal_notice_update_cc for CC_REV,\n\tCC_NOOV32 and CC_NORMAL, but set cc_status.flags CC_NO_OVERFLOW\n\tfor CC_NOOV32 and TARGET_V32.\n\t(cris_simple_epilogue): Always return false for TARGET_V32 if\n\tcris_return_address_on_stack yields true.\n\t(cris_cc0_user_requires_cmp): New function.\n\t(cris_valid_pic_const): Add argument ANY_OPERAND.  All callers\n\tchanged.  Handle CRIS_UNSPEC_PLT_PCREL and CRIS_UNSPEC_PCREL.\n\t(cris_asm_output_case_end): New function, guts from\n\tASM_OUTPUT_CASE_END adjusted for CRIS v32.\n\t(cris_override_options): Adjust for CRIS v32.  Mask out\n\tTARGET_SIDE_EFFECT_PREFIXES and TARGET_MUL_BUG if v32.\n\t(cris_asm_output_mi_thunk, cris_expand_epilogue)\n\t(cris_gen_movem_load, cris_emit_movem_store)\n\t(cris_expand_pic_call_address, cris_asm_output_symbol_ref)\n\t(cris_asm_output_label_ref, cris_output_addr_const_extra): Adjust\n\tfor CRIS v32.\n\t(cris_split_movdx): Copy re-used MEM.\n\nFrom-SVN: r130966", "tree": {"sha": "3a4eab235597c5129c244d7cdbf13cf8f513e07c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3a4eab235597c5129c244d7cdbf13cf8f513e07c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c31500c27ec5d01968d24779683074f0002723b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c31500c27ec5d01968d24779683074f0002723b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c31500c27ec5d01968d24779683074f0002723b3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c31500c27ec5d01968d24779683074f0002723b3/comments", "author": null, "committer": null, "parents": [{"sha": "99c5227a6402ad3a9e88360758aa2a3b1352f6fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99c5227a6402ad3a9e88360758aa2a3b1352f6fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99c5227a6402ad3a9e88360758aa2a3b1352f6fc"}], "stats": {"total": 814, "additions": 557, "deletions": 257}, "files": [{"sha": "ba572eb82db864a2872fb9ef519b8954e4431598", "filename": "gcc/config/cris/cris.c", "status": "modified", "additions": 557, "deletions": 257, "changes": 814, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c31500c27ec5d01968d24779683074f0002723b3/gcc%2Fconfig%2Fcris%2Fcris.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c31500c27ec5d01968d24779683074f0002723b3/gcc%2Fconfig%2Fcris%2Fcris.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.c?ref=c31500c27ec5d01968d24779683074f0002723b3", "patch": "@@ -52,11 +52,6 @@ along with GCC; see the file COPYING3.  If not see\n #define ADDITIVE_SIZE_MODIFIER(size) \\\n  ((size) <= 63 ? \"q\" : (size) <= 255 ? \"u.b\" : (size) <= 65535 ? \"u.w\" : \".d\")\n \n-#define ASSERT_PLT_UNSPEC(x)\t\t\t\t\t\t\\\n-  CRIS_ASSERT (XINT (x, 1) == CRIS_UNSPEC_PLT\t\t\t\t\\\n-\t       && ((GET_CODE (XVECEXP (x, 0, 0)) == SYMBOL_REF)\t\t\\\n-\t\t   || GET_CODE (XVECEXP (x, 0, 0)) == LABEL_REF))\n-\n #define LOSE_AND_RETURN(msgid, x)\t\t\t\\\n   do\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\\\n@@ -229,9 +224,11 @@ cris_movem_load_rest_p (rtx op, int offs)\n   else\n     i = offs + 1;\n \n-  /* FIXME: These two only for pre-v32.  */\n-  regno_dir = -1;\n-  regno = reg_count - 1;\n+  if (!TARGET_V32)\n+    {\n+      regno_dir = -1;\n+      regno = reg_count - 1;\n+    }\n \n   elt = XVECEXP (op, 0, offs);\n   src_addr = XEXP (SET_SRC (elt), 0);\n@@ -331,9 +328,11 @@ cris_store_multiple_op_p (rtx op)\n   else\n     i = 1;\n \n-  /* FIXME: These two only for pre-v32.  */\n-  regno_dir = -1;\n-  regno = reg_count - 1;\n+  if (!TARGET_V32)\n+    {\n+      regno_dir = -1;\n+      regno = reg_count - 1;\n+    }\n \n   if (GET_CODE (elt) != SET\n       || !REG_P (SET_SRC (elt))\n@@ -390,6 +389,20 @@ cris_conditional_register_usage (void)\n     fixed_regs[PIC_OFFSET_TABLE_REGNUM]\n       = call_used_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\n \n+  /* Allow use of ACR (PC in pre-V32) and tweak order.  */\n+  if (TARGET_V32)\n+    {\n+      static const int reg_alloc_order_v32[] = REG_ALLOC_ORDER_V32;\n+      unsigned int i;\n+\n+      fixed_regs[CRIS_ACR_REGNUM] = 0;\n+\n+      for (i = 0;\n+          i < sizeof (reg_alloc_order_v32)/sizeof (reg_alloc_order_v32[0]);\n+          i++)\n+       reg_alloc_order[i] = reg_alloc_order_v32[i];\n+    }\n+\n   if (TARGET_HAS_MUL_INSNS)\n     fixed_regs[CRIS_MOF_REGNUM] = 0;\n \n@@ -551,7 +564,10 @@ cris_print_base (rtx base, FILE *file)\n   if (REG_P (base))\n     fprintf (file, \"$%s\", reg_names[REGNO (base)]);\n   else if (GET_CODE (base) == POST_INC)\n-    fprintf (file, \"$%s+\", reg_names[REGNO (XEXP (base, 0))]);\n+    {\n+      gcc_assert (REGNO (XEXP (base, 0)) != CRIS_ACR_REGNUM);\n+      fprintf (file, \"$%s+\", reg_names[REGNO (XEXP (base, 0))]);\n+    }\n   else\n     cris_operand_lossage (\"unexpected base-type in cris_print_base\",\n \t\t\t  base);\n@@ -781,6 +797,16 @@ cris_print_operand (FILE *file, rtx x, int code)\n       putc (INTVAL (x) >= -128 && INTVAL (x) <= 255 ? 'b' : 'w', file);\n       return;\n \n+    case 'Z':\n+      /* If this is a GOT-symbol, print the size-letter corresponding to\n+\t -fpic/-fPIC.  For everything else, print \"d\".  */\n+      putc ((flag_pic == 1\n+\t     && GET_CODE (x) == CONST\n+\t     && GET_CODE (XEXP (x, 0)) == UNSPEC\n+\t     && XINT (XEXP (x, 0), 1) == CRIS_UNSPEC_GOTREAD)\n+\t    ? 'w' : 'd', file);\n+      return;\n+\n     case '#':\n       /* Output a 'nop' if there's nothing for the delay slot.\n \t This method stolen from the sparc files.  */\n@@ -835,8 +861,12 @@ cris_print_operand (FILE *file, rtx x, int code)\n \n \tcase REG:\n \t  /* Print reg + 1.  Check that there's not an attempt to print\n-\t     high-parts of registers like stack-pointer or higher.  */\n-\t  if (REGNO (operand) > STACK_POINTER_REGNUM - 2)\n+\t     high-parts of registers like stack-pointer or higher, except\n+\t     for SRP (where the \"high part\" is MOF).  */\n+\t  if (REGNO (operand) > STACK_POINTER_REGNUM - 2\n+\t      && (REGNO (operand) != CRIS_SRP_REGNUM\n+\t\t  || CRIS_SRP_REGNUM + 1 != CRIS_MOF_REGNUM\n+\t\t  || fixed_regs[CRIS_MOF_REGNUM] != 0))\n \t    LOSE_AND_RETURN (\"bad register\", operand);\n \t  fprintf (file, \"$%s\", reg_names[REGNO (operand) + 1]);\n \t  return;\n@@ -964,6 +994,17 @@ cris_print_operand (FILE *file, rtx x, int code)\n       fprintf (file, \"%s\", mults[INTVAL (operand)]);\n       return;\n \n+    case 'u':\n+      /* Print \"u.w\" if a GOT symbol and flag_pic == 1, else \".d\".  */\n+      if (flag_pic == 1\n+\t  && GET_CODE (operand) == CONST\n+\t  && GET_CODE (XEXP (operand, 0)) == UNSPEC\n+\t  && XINT (XEXP (operand, 0), 1) == CRIS_UNSPEC_GOTREAD)\n+\tfprintf (file, \"u.w\");\n+      else\n+\tfprintf (file, \".d\");\n+      return;\n+\n     case 0:\n       /* No code, print as usual.  */\n       break;\n@@ -1227,6 +1268,9 @@ cris_reload_address_legitimized (rtx x,\n   if (GET_CODE (x) != PLUS)\n     return false;\n \n+  if (TARGET_V32)\n+    return false;\n+\n   op0 = XEXP (x, 0);\n   op0p = &XEXP (x, 0);\n   op1 = XEXP (x, 1);\n@@ -1284,211 +1328,186 @@ cris_reload_address_legitimized (rtx x,\n   return false;\n }\n \n-/*  This function looks into the pattern to see how this insn affects\n-    condition codes.\n-\n-    Used when to eliminate test insns before a condition-code user,\n-    such as a \"scc\" insn or a conditional branch.  This includes\n-    checking if the entities that cc was updated by, are changed by the\n-    operation.\n-\n-    Currently a jumble of the old peek-inside-the-insn and the newer\n-    check-cc-attribute methods.  */\n+/* Worker function for REGISTER_MOVE_COST.  */\n \n-void\n-cris_notice_update_cc (rtx exp, rtx insn)\n+int\n+cris_register_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t enum reg_class from, enum reg_class to) \n {\n-  /* Check if user specified \"-mcc-init\" as a bug-workaround.  FIXME:\n-     TARGET_CCINIT does not work; we must set CC_REVERSED as below.\n-     Several testcases will otherwise fail, for example\n-     gcc.c-torture/execute/20000217-1.c -O0 and -O1.  */\n-  if (TARGET_CCINIT)\n-    {\n-      CC_STATUS_INIT;\n-      return;\n-    }\n-\n-  /* Slowly, we're converting to using attributes to control the setting\n-     of condition-code status.  */\n-  switch (get_attr_cc (insn))\n-    {\n-    case CC_NONE:\n-      /* Even if it is \"none\", a setting may clobber a previous\n-\t cc-value, so check.  */\n-      if (GET_CODE (exp) == SET)\n-\t{\n-\t  if (cc_status.value1\n-\t      && modified_in_p (cc_status.value1, insn))\n-\t    cc_status.value1 = 0;\n+  if (!TARGET_V32)\n+    {\n+      /* Pretend that classes that we don't support are ALL_REGS, so\n+\t we give them the highest cost.  */\n+      if (from != SPECIAL_REGS && from != MOF_REGS\n+\t  && from != GENERAL_REGS && from != GENNONACR_REGS)\n+\tfrom = ALL_REGS;\n+\n+      if (to != SPECIAL_REGS && to != MOF_REGS\n+\t  && to != GENERAL_REGS && to != GENNONACR_REGS)\n+\tto = ALL_REGS;\n+    }\n+\n+  /* Can't move to and from a SPECIAL_REGS register, so we have to say\n+     their move cost within that class is higher.  How about 7?  That's 3\n+     for a move to a GENERAL_REGS register, 3 for the move from the\n+     GENERAL_REGS register, and 1 for the increased register pressure.\n+     Also, it's higher than the memory move cost, which is in order.  \n+     We also do this for ALL_REGS, since we don't want that class to be\n+     preferred (even to memory) at all where GENERAL_REGS doesn't fit.\n+     Whenever it's about to be used, it's for SPECIAL_REGS.  If we don't\n+     present a higher cost for ALL_REGS than memory, a SPECIAL_REGS may be\n+     used when a GENERAL_REGS should be used, even if there are call-saved\n+     GENERAL_REGS left to allocate.  This is because the fall-back when\n+     the most preferred register class isn't available, isn't the next\n+     (or next good) wider register class, but the *most widest* register\n+     class.  */\n+\n+  if ((reg_classes_intersect_p (from, SPECIAL_REGS)\n+       && reg_classes_intersect_p (to, SPECIAL_REGS))\n+      || from == ALL_REGS || to == ALL_REGS)\n+    return 7;\n+\n+  if (reg_classes_intersect_p (from, SPECIAL_REGS)\n+      || reg_classes_intersect_p (to, SPECIAL_REGS))\n+    return 3;\n+\n+  return 2;\n+}\n \n-\t  if (cc_status.value2\n-\t      && modified_in_p (cc_status.value2, insn))\n-\t    cc_status.value2 = 0;\n-\t}\n-      return;\n+/* Worker for cris_notice_update_cc; handles the \"normal\" cases.\n+   FIXME: this code is historical; its functionality should be\n+   refactored to look at insn attributes and moved to\n+   cris_notice_update_cc.  Except, we better lose cc0 entirely.  */\n \n-    case CC_CLOBBER:\n-      CC_STATUS_INIT;\n-      break;\n+static void\n+cris_normal_notice_update_cc (rtx exp, rtx insn)\n+{\n+  /* \"Normal\" means, for:\n+     (set (cc0) (...)):\n+     CC is (...).\n \n-    case CC_NORMAL:\n-      /* Which means, for:\n-\t (set (cc0) (...)):\n-\t CC is (...).\n+     (set (reg) (...)):\n+     CC is (reg) and (...) - unless (...) is 0 or reg is a special\n+        register or (v32 and (...) is -32..-1), then CC does not change.\n+     CC_NO_OVERFLOW unless (...) is reg or mem.\n \n-\t (set (reg) (...)):\n-\t CC is (reg) and (...) - unless (...) is 0, then CC does not change.\n-\t CC_NO_OVERFLOW unless (...) is reg or mem.\n+     (set (mem) (...)):\n+     CC does not change.\n \n-\t (set (mem) (...)):\n-\t CC does not change.\n+     (set (pc) (...)):\n+     CC does not change.\n \n-\t (set (pc) (...)):\n-\t CC does not change.\n+     (parallel\n+      (set (reg1) (mem (bdap/biap)))\n+      (set (reg2) (bdap/biap))):\n+     CC is (reg1) and (mem (reg2))\n \n-\t (parallel\n-\t  (set (reg1) (mem (bdap/biap)))\n-\t  (set (reg2) (bdap/biap))):\n-\t CC is (reg1) and (mem (reg2))\n+     (parallel\n+      (set (mem (bdap/biap)) (reg1)) [or 0]\n+      (set (reg2) (bdap/biap))):\n+     CC does not change.\n \n-\t (parallel\n-\t  (set (mem (bdap/biap)) (reg1)) [or 0]\n-\t  (set (reg2) (bdap/biap))):\n-\t CC does not change.\n+     (where reg and mem includes strict_low_parts variants thereof)\n \n-\t (where reg and mem includes strict_low_parts variants thereof)\n+     For all others, assume CC is clobbered.\n+     Note that we do not have to care about setting CC_NO_OVERFLOW,\n+     since the overflow flag is set to 0 (i.e. right) for\n+     instructions where it does not have any sane sense, but where\n+     other flags have meanings.  (This includes shifts; the carry is\n+     not set by them).\n \n-\t For all others, assume CC is clobbered.\n-\t Note that we do not have to care about setting CC_NO_OVERFLOW,\n-\t since the overflow flag is set to 0 (i.e. right) for\n-\t instructions where it does not have any sane sense, but where\n-\t other flags have meanings.  (This includes shifts; the carry is\n-\t not set by them).\n+     Note that there are other parallel constructs we could match,\n+     but we don't do that yet.  */\n \n-\t Note that there are other parallel constructs we could match,\n-\t but we don't do that yet.  */\n+  if (GET_CODE (exp) == SET)\n+    {\n+      /* FIXME: Check when this happens.  It looks like we should\n+\t actually do a CC_STATUS_INIT here to be safe.  */\n+      if (SET_DEST (exp) == pc_rtx)\n+\treturn;\n \n-      if (GET_CODE (exp) == SET)\n+      /* Record CC0 changes, so we do not have to output multiple\n+\t test insns.  */\n+      if (SET_DEST (exp) == cc0_rtx)\n \t{\n-\t  /* FIXME: Check when this happens.  It looks like we should\n-\t     actually do a CC_STATUS_INIT here to be safe.  */\n-\t  if (SET_DEST (exp) == pc_rtx)\n-\t    return;\n+\t  CC_STATUS_INIT;\n+\t  cc_status.value1 = SET_SRC (exp);\n \n-\t  /* Record CC0 changes, so we do not have to output multiple\n-\t     test insns.  */\n-\t  if (SET_DEST (exp) == cc0_rtx)\n+\t  /* Handle flags for the special btstq on one bit.  */\n+\t  if (GET_CODE (SET_SRC (exp)) == ZERO_EXTRACT\n+\t      && XEXP (SET_SRC (exp), 1) == const1_rtx)\n \t    {\n-\t      cc_status.value1 = SET_SRC (exp);\n-\t      cc_status.value2 = 0;\n-\n-\t      /* Handle flags for the special btstq on one bit.  */\n-\t      if (GET_CODE (SET_SRC (exp)) == ZERO_EXTRACT\n-\t\t  && XEXP (SET_SRC (exp), 1) == const1_rtx)\n-\t\t{\n-\t\t  if (CONST_INT_P (XEXP (SET_SRC (exp), 0)))\n-\t\t    /* Using cmpq.  */\n-\t\t    cc_status.flags = CC_INVERTED;\n-\t\t  else\n-\t\t    /* A one-bit btstq.  */\n-\t\t    cc_status.flags = CC_Z_IN_NOT_N;\n-\t\t}\n+\t      if (CONST_INT_P (XEXP (SET_SRC (exp), 0)))\n+\t\t/* Using cmpq.  */\n+\t\tcc_status.flags = CC_INVERTED;\n \t      else\n-\t\tcc_status.flags = 0;\n-\n-\t      if (GET_CODE (SET_SRC (exp)) == COMPARE)\n-\t\t{\n-\t\t  if (!REG_P (XEXP (SET_SRC (exp), 0))\n-\t\t      && XEXP (SET_SRC (exp), 1) != const0_rtx)\n-\t\t    /* For some reason gcc will not canonicalize compare\n-\t\t       operations, reversing the sign by itself if\n-\t\t       operands are in wrong order.  */\n-\t\t    /* (But NOT inverted; eq is still eq.) */\n-\t\t    cc_status.flags = CC_REVERSED;\n-\n-\t\t  /* This seems to be overlooked by gcc.  FIXME: Check again.\n-\t\t     FIXME:  Is it really safe?  */\n-\t\t  cc_status.value2\n-\t\t    = gen_rtx_MINUS (GET_MODE (SET_SRC (exp)),\n-\t\t\t\t     XEXP (SET_SRC (exp), 0),\n-\t\t\t\t     XEXP (SET_SRC (exp), 1));\n-\t\t}\n-\t      return;\n+\t\t/* A one-bit btstq.  */\n+\t\tcc_status.flags = CC_Z_IN_NOT_N;\n \t    }\n-\t  else if (REG_P (SET_DEST (exp))\n-\t\t   || (GET_CODE (SET_DEST (exp)) == STRICT_LOW_PART\n-\t\t       && REG_P (XEXP (SET_DEST (exp), 0))))\n-\t    {\n-\t      /* A register is set; normally CC is set to show that no\n-\t\t test insn is needed.  Catch the exceptions.  */\n-\n-\t      /* If not to cc0, then no \"set\"s in non-natural mode give\n-\t\t ok cc0...  */\n-\t      if (GET_MODE_SIZE (GET_MODE (SET_DEST (exp))) > UNITS_PER_WORD\n-\t\t  || GET_MODE_CLASS (GET_MODE (SET_DEST (exp))) == MODE_FLOAT)\n-\t\t{\n-\t\t  /* ... except add:s and sub:s in DImode.  */\n-\t\t  if (GET_MODE (SET_DEST (exp)) == DImode\n-\t\t      && (GET_CODE (SET_SRC (exp)) == PLUS\n-\t\t\t  || GET_CODE (SET_SRC (exp)) == MINUS))\n-\t\t    {\n-\t\t      cc_status.flags = 0;\n-\t\t      cc_status.value1 = SET_DEST (exp);\n-\t\t      cc_status.value2 = SET_SRC (exp);\n-\n-\t\t      if (cris_reg_overlap_mentioned_p (cc_status.value1,\n-\t\t\t\t\t\t\tcc_status.value2))\n-\t\t\tcc_status.value2 = 0;\n-\n-\t\t      /* Add and sub may set V, which gets us\n-\t\t\t unoptimizable results in \"gt\" and \"le\" condition\n-\t\t\t codes.  */\n-\t\t      cc_status.flags |= CC_NO_OVERFLOW;\n \n-\t\t      return;\n-\t\t    }\n-\t\t}\n-\t      else if (SET_SRC (exp) == const0_rtx)\n-\t\t{\n-\t\t  /* There's no CC0 change when clearing a register or\n-\t\t     memory.  Just check for overlap.  */\n-\t\t  if (cc_status.value1\n-\t\t      && modified_in_p (cc_status.value1, insn))\n-\t\t    cc_status.value1 = 0;\n-\n-\t\t  if (cc_status.value2\n-\t\t      && modified_in_p (cc_status.value2, insn))\n-\t\t    cc_status.value2 = 0;\n+\t  if (GET_CODE (SET_SRC (exp)) == COMPARE)\n+\t    {\n+\t      if (!REG_P (XEXP (SET_SRC (exp), 0))\n+\t\t  && XEXP (SET_SRC (exp), 1) != const0_rtx)\n+\t\t/* For some reason gcc will not canonicalize compare\n+\t\t   operations, reversing the sign by itself if\n+\t\t   operands are in wrong order.  */\n+\t\t/* (But NOT inverted; eq is still eq.) */\n+\t\tcc_status.flags = CC_REVERSED;\n+\n+\t      /* This seems to be overlooked by gcc.  FIXME: Check again.\n+\t\t FIXME:  Is it really safe?  */\n+\t      cc_status.value2\n+\t\t= gen_rtx_MINUS (GET_MODE (SET_SRC (exp)),\n+\t\t\t\t XEXP (SET_SRC (exp), 0),\n+\t\t\t\t XEXP (SET_SRC (exp), 1));\n+\t    }\n+\t  return;\n+\t}\n+      else if (REG_P (SET_DEST (exp))\n+\t       || (GET_CODE (SET_DEST (exp)) == STRICT_LOW_PART\n+\t\t   && REG_P (XEXP (SET_DEST (exp), 0))))\n+\t{\n+\t  /* A register is set; normally CC is set to show that no\n+\t     test insn is needed.  Catch the exceptions.  */\n \n-\t\t  return;\n-\t\t}\n-\t      else\n+\t  /* If not to cc0, then no \"set\"s in non-natural mode give\n+\t     ok cc0...  */\n+\t  if (GET_MODE_SIZE (GET_MODE (SET_DEST (exp))) > UNITS_PER_WORD\n+\t      || GET_MODE_CLASS (GET_MODE (SET_DEST (exp))) == MODE_FLOAT)\n+\t    {\n+\t      /* ... except add:s and sub:s in DImode.  */\n+\t      if (GET_MODE (SET_DEST (exp)) == DImode\n+\t\t  && (GET_CODE (SET_SRC (exp)) == PLUS\n+\t\t      || GET_CODE (SET_SRC (exp)) == MINUS))\n \t\t{\n-\t\t  cc_status.flags = 0;\n+\t\t  CC_STATUS_INIT;\n \t\t  cc_status.value1 = SET_DEST (exp);\n \t\t  cc_status.value2 = SET_SRC (exp);\n \n \t\t  if (cris_reg_overlap_mentioned_p (cc_status.value1,\n \t\t\t\t\t\t    cc_status.value2))\n \t\t    cc_status.value2 = 0;\n \n-\t\t  /* Some operations may set V, which gets us\n+\t\t  /* Add and sub may set V, which gets us\n \t\t     unoptimizable results in \"gt\" and \"le\" condition\n \t\t     codes.  */\n-\t\t  if (GET_CODE (SET_SRC (exp)) == PLUS\n-\t\t      || GET_CODE (SET_SRC (exp)) == MINUS\n-\t\t      || GET_CODE (SET_SRC (exp)) == NEG)\n-\t\t    cc_status.flags |= CC_NO_OVERFLOW;\n+\t\t  cc_status.flags |= CC_NO_OVERFLOW;\n \n \t\t  return;\n \t\t}\n \t    }\n-\t  else if (MEM_P (SET_DEST (exp))\n-\t\t   || (GET_CODE (SET_DEST (exp)) == STRICT_LOW_PART\n-\t\t       && MEM_P (XEXP (SET_DEST (exp), 0))))\n+\t  else if (SET_SRC (exp) == const0_rtx\n+\t\t   || (REG_P (SET_SRC (exp))\n+\t\t       && (REGNO (SET_SRC (exp))\n+\t\t\t   > CRIS_LAST_GENERAL_REGISTER))\n+\t\t   || (TARGET_V32\n+\t\t       && GET_CODE (SET_SRC (exp)) == CONST_INT\n+\t\t       && CONST_OK_FOR_LETTER_P (INTVAL (SET_SRC (exp)),\n+\t\t\t\t\t\t 'I')))\n \t    {\n-\t      /* When SET to MEM, then CC is not changed (except for\n-\t\t overlap).  */\n+\t      /* There's no CC0 change for this case.  Just check\n+\t\t for overlap.  */\n \t      if (cc_status.value1\n \t\t  && modified_in_p (cc_status.value1, insn))\n \t\tcc_status.value1 = 0;\n@@ -1499,50 +1518,166 @@ cris_notice_update_cc (rtx exp, rtx insn)\n \n \t      return;\n \t    }\n+\t  else\n+\t    {\n+\t      CC_STATUS_INIT;\n+\t      cc_status.value1 = SET_DEST (exp);\n+\t      cc_status.value2 = SET_SRC (exp);\n+\n+\t      if (cris_reg_overlap_mentioned_p (cc_status.value1,\n+\t\t\t\t\t\tcc_status.value2))\n+\t\tcc_status.value2 = 0;\n+\n+\t      /* Some operations may set V, which gets us\n+\t\t unoptimizable results in \"gt\" and \"le\" condition\n+\t\t codes.  */\n+\t      if (GET_CODE (SET_SRC (exp)) == PLUS\n+\t\t  || GET_CODE (SET_SRC (exp)) == MINUS\n+\t\t  || GET_CODE (SET_SRC (exp)) == NEG)\n+\t\tcc_status.flags |= CC_NO_OVERFLOW;\n+\n+\t      /* For V32, nothing with a register destination sets\n+\t\t C and V usefully.  */\n+\t      if (TARGET_V32)\n+\t\tcc_status.flags |= CC_NO_OVERFLOW;\n+\n+\t      return;\n+\t    }\n+\t}\n+      else if (MEM_P (SET_DEST (exp))\n+\t       || (GET_CODE (SET_DEST (exp)) == STRICT_LOW_PART\n+\t\t   && MEM_P (XEXP (SET_DEST (exp), 0))))\n+\t{\n+\t  /* When SET to MEM, then CC is not changed (except for\n+\t     overlap).  */\n+\t  if (cc_status.value1\n+\t      && modified_in_p (cc_status.value1, insn))\n+\t    cc_status.value1 = 0;\n+\n+\t  if (cc_status.value2\n+\t      && modified_in_p (cc_status.value2, insn))\n+\t    cc_status.value2 = 0;\n+\n+\t  return;\n \t}\n-      else if (GET_CODE (exp) == PARALLEL)\n+    }\n+  else if (GET_CODE (exp) == PARALLEL)\n+    {\n+      if (GET_CODE (XVECEXP (exp, 0, 0)) == SET\n+\t  && GET_CODE (XVECEXP (exp, 0, 1)) == SET\n+\t  && REG_P (XEXP (XVECEXP (exp, 0, 1), 0)))\n \t{\n-\t  if (GET_CODE (XVECEXP (exp, 0, 0)) == SET\n-\t      && GET_CODE (XVECEXP (exp, 0, 1)) == SET\n-\t      && REG_P (XEXP (XVECEXP (exp, 0, 1), 0)))\n+\t  if (REG_P (XEXP (XVECEXP (exp, 0, 0), 0))\n+\t      && MEM_P (XEXP (XVECEXP (exp, 0, 0), 1)))\n \t    {\n-\t      if (REG_P (XEXP (XVECEXP (exp, 0, 0), 0))\n-\t\t  && MEM_P (XEXP (XVECEXP (exp, 0, 0), 1)))\n-\t\t{\n-\t\t  /* For \"move.S [rx=ry+o],rz\", say CC reflects\n-\t\t     value1=rz and value2=[rx] */\n-\t\t  cc_status.value1 = XEXP (XVECEXP (exp, 0, 0), 0);\n-\t\t  cc_status.value2\n-\t\t    = replace_equiv_address (XEXP (XVECEXP (exp, 0, 0), 1),\n-\t\t\t\t\t     XEXP (XVECEXP (exp, 0, 1), 0));\n-\t\t  cc_status.flags = 0;\n-\n-\t\t  /* Huh?  A side-effect cannot change the destination\n-\t\t     register.  */\n-\t\t  if (cris_reg_overlap_mentioned_p (cc_status.value1,\n-\t\t\t\t\t\t    cc_status.value2))\n-\t\t    internal_error (\"internal error: sideeffect-insn affecting main effect\");\n-\t\t  return;\n-\t\t}\n-\t      else if ((REG_P (XEXP (XVECEXP (exp, 0, 0), 1))\n-\t\t\t|| XEXP (XVECEXP (exp, 0, 0), 1) == const0_rtx)\n-\t\t       && MEM_P (XEXP (XVECEXP (exp, 0, 0), 0)))\n-\t\t{\n-\t\t  /* For \"move.S rz,[rx=ry+o]\" and \"clear.S [rx=ry+o]\",\n-\t\t     say flags are not changed, except for overlap.  */\n-\t\t  if (cc_status.value1\n-\t\t      && modified_in_p (cc_status.value1, insn))\n-\t\t    cc_status.value1 = 0;\n-\n-\t\t  if (cc_status.value2\n-\t\t      && modified_in_p (cc_status.value2, insn))\n-\t\t    cc_status.value2 = 0;\n+\t      CC_STATUS_INIT;\n+\n+\t      /* For \"move.S [rx=ry+o],rz\", say CC reflects\n+\t\t value1=rz and value2=[rx] */\n+\t      cc_status.value1 = XEXP (XVECEXP (exp, 0, 0), 0);\n+\t      cc_status.value2\n+\t\t= replace_equiv_address (XEXP (XVECEXP (exp, 0, 0), 1),\n+\t\t\t\t\t XEXP (XVECEXP (exp, 0, 1), 0));\n+\n+\t      /* Huh?  A side-effect cannot change the destination\n+\t\t register.  */\n+\t      if (cris_reg_overlap_mentioned_p (cc_status.value1,\n+\t\t\t\t\t\tcc_status.value2))\n+\t\tinternal_error (\"internal error: sideeffect-insn affecting main effect\");\n+\n+\t      /* For V32, moves to registers don't set C and V.  */\n+\t      if (TARGET_V32)\n+\t\tcc_status.flags |= CC_NO_OVERFLOW;\n+\t      return;\n+\t    }\n+\t  else if ((REG_P (XEXP (XVECEXP (exp, 0, 0), 1))\n+\t\t    || XEXP (XVECEXP (exp, 0, 0), 1) == const0_rtx)\n+\t\t   && MEM_P (XEXP (XVECEXP (exp, 0, 0), 0)))\n+\t    {\n+\t      /* For \"move.S rz,[rx=ry+o]\" and \"clear.S [rx=ry+o]\",\n+\t\t say flags are not changed, except for overlap.  */\n+\t      if (cc_status.value1\n+\t\t  && modified_in_p (cc_status.value1, insn))\n+\t\tcc_status.value1 = 0;\n \n-\t\t  return;\n-\t\t}\n+\t      if (cc_status.value2\n+\t\t  && modified_in_p (cc_status.value2, insn))\n+\t\tcc_status.value2 = 0;\n+\n+\t      return;\n \t    }\n \t}\n-      break;\n+    }\n+\n+  /* If we got here, the case wasn't covered by the code above.  */\n+  CC_STATUS_INIT;\n+}\n+\n+/*  This function looks into the pattern to see how this insn affects\n+    condition codes.\n+\n+    Used when to eliminate test insns before a condition-code user,\n+    such as a \"scc\" insn or a conditional branch.  This includes\n+    checking if the entities that cc was updated by, are changed by the\n+    operation.\n+\n+    Currently a jumble of the old peek-inside-the-insn and the newer\n+    check-cc-attribute methods.  */\n+\n+void\n+cris_notice_update_cc (rtx exp, rtx insn)\n+{\n+  enum attr_cc attrval = get_attr_cc (insn);\n+\n+  /* Check if user specified \"-mcc-init\" as a bug-workaround.  Remember\n+     to still set CC_REVERSED as below, since that's required by some\n+     compare insn alternatives.  (FIXME: GCC should do this virtual\n+     operand swap by itself.)  A test-case that may otherwise fail is\n+     gcc.c-torture/execute/20000217-1.c -O0 and -O1.  */\n+  if (TARGET_CCINIT)\n+    {\n+      CC_STATUS_INIT;\n+\n+      if (attrval == CC_REV)\n+\tcc_status.flags = CC_REVERSED;\n+      return;\n+    }\n+\n+  /* Slowly, we're converting to using attributes to control the setting\n+     of condition-code status.  */\n+  switch (attrval)\n+    {\n+    case CC_NONE:\n+      /* Even if it is \"none\", a setting may clobber a previous\n+\t cc-value, so check.  */\n+      if (GET_CODE (exp) == SET)\n+\t{\n+\t  if (cc_status.value1\n+\t      && modified_in_p (cc_status.value1, insn))\n+\t    cc_status.value1 = 0;\n+\n+\t  if (cc_status.value2\n+\t      && modified_in_p (cc_status.value2, insn))\n+\t    cc_status.value2 = 0;\n+\t}\n+      return;\n+\n+    case CC_CLOBBER:\n+      CC_STATUS_INIT;\n+      return;\n+\n+    case CC_REV:\n+    case CC_NOOV32:\n+    case CC_NORMAL:\n+      cris_normal_notice_update_cc (exp, insn);\n+\n+      /* The \"test\" insn doesn't clear (carry and) overflow on V32.  We\n+        can change bge => bpl and blt => bmi by passing on to the cc0\n+        user that V should not be considered; bgt and ble are taken\n+        care of by other methods (see {tst,cmp}{si,hi,qi}).  */\n+      if (attrval == CC_NOOV32 && TARGET_V32)\n+\tcc_status.flags |= CC_NO_OVERFLOW;\n+      return;\n \n     default:\n       internal_error (\"unknown cc_attr value\");\n@@ -1575,6 +1710,10 @@ cris_simple_epilogue (void)\n       || !TARGET_PROLOGUE_EPILOGUE)\n     return false;\n \n+  /* Can't return from stacked return address with v32.  */\n+  if (TARGET_V32 && cris_return_address_on_stack ())\n+    return false;\n+\n   if (current_function_uses_pic_offset_table)\n     {\n       push_topmost_sequence ();\n@@ -1901,6 +2040,49 @@ cris_side_effect_mode_ok (enum rtx_code code, rtx *ops,\n   internal_error (\"internal error: cris_side_effect_mode_ok with bad operands\");\n }\n \n+/* Whether next_cc0_user of insn is LE or GT or requires a real compare\n+   insn for other reasons.  */\n+\n+bool\n+cris_cc0_user_requires_cmp (rtx insn)\n+{\n+  rtx cc0_user = NULL;\n+  rtx body;\n+  rtx set;\n+\n+  gcc_assert (insn != NULL);\n+\n+  if (!TARGET_V32)\n+    return false;\n+\n+  cc0_user = next_cc0_user (insn);\n+  if (cc0_user == NULL)\n+    return false;\n+\n+  body = PATTERN (cc0_user);\n+  set = single_set (cc0_user);\n+\n+  /* Users can be sCC and bCC.  */\n+  if (JUMP_P (cc0_user)\n+      && GET_CODE (body) == SET\n+      && SET_DEST (body) == pc_rtx\n+      && GET_CODE (SET_SRC (body)) == IF_THEN_ELSE\n+      && XEXP (XEXP (SET_SRC (body), 0), 0) == cc0_rtx)\n+    {\n+      return\n+\tGET_CODE (XEXP (SET_SRC (body), 0)) == GT\n+\t|| GET_CODE (XEXP (SET_SRC (body), 0)) == LE;\n+    }\n+  else if (set)\n+    {\n+      return\n+\tGET_CODE (SET_SRC (body)) == GT\n+\t|| GET_CODE (SET_SRC (body)) == LE;\n+    }\n+\n+  gcc_unreachable ();\n+}\n+\n /* The function reg_overlap_mentioned_p in CVS (still as of 2001-05-16)\n    does not handle the case where the IN operand is strict_low_part; it\n    does handle it for X.  Test-case in Axis-20010516.  This function takes\n@@ -1931,10 +2113,12 @@ cris_target_asm_named_section (const char *name, unsigned int flags,\n     default_elf_asm_named_section (name, flags, decl);\n }\n \n-/* Return TRUE iff X is a CONST valid for e.g. indexing.  */\n+/* Return TRUE iff X is a CONST valid for e.g. indexing.\n+   ANY_OPERAND is 0 if X is in a CALL_P insn or movsi, 1\n+   elsewhere.  */\n \n bool\n-cris_valid_pic_const (rtx x)\n+cris_valid_pic_const (rtx x, bool any_operand)\n {\n   gcc_assert (flag_pic);\n \n@@ -1955,14 +2139,20 @@ cris_valid_pic_const (rtx x)\n   /* Handle (const (plus (unspec .. UNSPEC_GOTREL) (const_int ...))).  */\n   if (GET_CODE (x) == PLUS\n       && GET_CODE (XEXP (x, 0)) == UNSPEC\n-      && XINT (XEXP (x, 0), 1) == CRIS_UNSPEC_GOTREL\n+      && (XINT (XEXP (x, 0), 1) == CRIS_UNSPEC_GOTREL\n+\t  || XINT (XEXP (x, 0), 1) == CRIS_UNSPEC_PCREL)\n       && CONST_INT_P (XEXP (x, 1)))\n     x = XEXP (x, 0);\n \n   if (GET_CODE (x) == UNSPEC)\n     switch (XINT (x, 1))\n       {\n-      case CRIS_UNSPEC_PLT:\n+\t/* A PCREL operand is only valid for call and movsi.  */\n+      case CRIS_UNSPEC_PLT_PCREL:\n+      case CRIS_UNSPEC_PCREL:\n+\treturn !any_operand;\n+\n+      case CRIS_UNSPEC_PLT_GOTREL:\n       case CRIS_UNSPEC_PLTGOTREAD:\n       case CRIS_UNSPEC_GOTREAD:\n       case CRIS_UNSPEC_GOTREL:\n@@ -1984,10 +2174,10 @@ cris_pic_symbol_type_of (rtx x)\n     {\n     case SYMBOL_REF:\n       return SYMBOL_REF_LOCAL_P (x)\n-\t? cris_gotrel_symbol : cris_got_symbol;\n+\t? cris_rel_symbol : cris_got_symbol;\n \n     case LABEL_REF:\n-      return cris_gotrel_symbol;\n+      return cris_rel_symbol;\n \n     case CONST:\n       return cris_pic_symbol_type_of (XEXP (x, 0));\n@@ -2028,7 +2218,45 @@ int\n cris_legitimate_pic_operand (rtx x)\n {\n   /* Symbols are not valid PIC operands as-is; just constants.  */\n-  return cris_valid_pic_const (x);\n+  return cris_valid_pic_const (x, true);\n+}\n+\n+/* The ASM_OUTPUT_CASE_END worker.  */\n+\n+void\n+cris_asm_output_case_end (FILE *stream, int num, rtx table)\n+{\n+  if (TARGET_V32)\n+    {\n+      rtx whole_jump_insn = PATTERN (PREV_INSN (PREV_INSN (table)));\n+\n+      /* This can be a SEQUENCE, meaning the delay-slot of the jump is\n+\t filled.  */\n+      rtx parallel_jump\n+\t= (GET_CODE (whole_jump_insn) == SEQUENCE\n+\t   ? PATTERN (XVECEXP (whole_jump_insn, 0, 0)) : whole_jump_insn);\n+\n+      asm_fprintf (stream,\n+\t\t   \"\\t.word %LL%d-.%s\\n\",\n+\t\t   CODE_LABEL_NUMBER (XEXP (XEXP (XEXP (XVECEXP\n+\t\t\t\t\t\t\t(parallel_jump, 0, 0),\n+\t\t\t\t\t\t\t1), 2), 0)),\n+\t\t   (TARGET_PDEBUG ? \"; default\" : \"\"));\n+      return;\n+    }\n+\n+  asm_fprintf (stream,\n+\t       \"\\t.word %LL%d-%LL%d%s\\n\",\n+\t       CODE_LABEL_NUMBER (XEXP\n+\t\t\t\t  (XEXP\n+\t\t\t\t   (XEXP\n+\t\t\t\t    (XVECEXP\n+\t\t\t\t     (PATTERN\n+\t\t\t\t      (PREV_INSN\n+\t\t\t\t       (PREV_INSN (table))), 0, 0), 1),\n+\t\t\t\t    2), 0)),\n+\t       num,\n+\t       (TARGET_PDEBUG ? \"; default\" : \"\"));\n }\n \n /* TARGET_HANDLE_OPTION worker.  We just store the values into local\n@@ -2128,7 +2356,7 @@ cris_override_options (void)\n \t  || strcmp (\"etrax100lx\", cris_cpu_str) == 0)\n \tcris_cpu_version = 10;\n \n-      if (cris_cpu_version < 0 || cris_cpu_version > 10)\n+      if (cris_cpu_version < 0 || cris_cpu_version > 32)\n \terror (\"unknown CRIS version specification in -march= or -mcpu= : %s\",\n \t       cris_cpu_str);\n \n@@ -2164,7 +2392,7 @@ cris_override_options (void)\n \t  || strcmp (\"etrax100lx\", cris_tune_str) == 0)\n \tcris_tune = 10;\n \n-      if (cris_tune < 0 || cris_tune > 10)\n+      if (cris_tune < 0 || cris_tune > 32)\n \terror (\"unknown CRIS cpu version specification in -mtune= : %s\",\n \t       cris_tune_str);\n \n@@ -2176,6 +2404,9 @@ cris_override_options (void)\n \t      | MASK_DATA_ALIGN | MASK_ALIGN_BY_32);\n     }\n \n+  if (cris_cpu_version >= CRIS_CPU_V32)\n+    target_flags &= ~(MASK_SIDE_EFFECT_PREFIXES|MASK_MUL_BUG);\n+\n   if (flag_pic)\n     {\n       /* Use error rather than warning, so invalid use is easily\n@@ -2229,15 +2460,28 @@ cris_asm_output_mi_thunk (FILE *stream,\n       const char *name = XSTR (XEXP (DECL_RTL (funcdecl), 0), 0);\n \n       name = (* targetm.strip_name_encoding) (name);\n-      fprintf (stream, \"add.d \");\n-      assemble_name (stream, name);\n-      fprintf (stream, \"%s,$pc\\n\", CRIS_PLT_PCOFFSET_SUFFIX);\n+\n+      if (TARGET_V32)\n+\t{\n+\t  fprintf (stream, \"\\tba \");\n+\t  assemble_name (stream, name);\n+\t  fprintf (stream, \"%s\\n\", CRIS_PLT_PCOFFSET_SUFFIX);\n+\t}\n+      else\n+\t{\n+\t  fprintf (stream, \"add.d \");\n+\t  assemble_name (stream, name);\n+\t  fprintf (stream, \"%s,$pc\\n\", CRIS_PLT_PCOFFSET_SUFFIX);\n+\t}\n     }\n   else\n     {\n       fprintf (stream, \"jump \");\n       assemble_name (stream, XSTR (XEXP (DECL_RTL (funcdecl), 0), 0));\n       fprintf (stream, \"\\n\");\n+\n+      if (TARGET_V32)\n+\tfprintf (stream, \"\\tnop\\n\");\n     }\n }\n \n@@ -2374,7 +2618,7 @@ cris_split_movdx (rtx *operands)\n \t\t  = alloc_EXPR_LIST (REG_INC, XEXP (XEXP (mem, 0), 0),\n \t\t\t\t     REG_NOTES (insn));\n \n-\t      mem = change_address (src, SImode, addr);\n+\t      mem = copy_rtx (mem);\n \t      insn\n \t\t= gen_rtx_SET (VOIDmode,\n \t\t\t       operand_subword (dest, 1, TRUE, mode), mem);\n@@ -2438,7 +2682,7 @@ cris_split_movdx (rtx *operands)\n \t      = alloc_EXPR_LIST (REG_INC, XEXP (XEXP (mem, 0), 0),\n \t\t\t\t REG_NOTES (insn));\n \n-\t  mem = change_address (dest, SImode, addr);\n+\t  mem = copy_rtx (mem);\n \t  insn\n \t    = gen_rtx_SET (VOIDmode,\n \t\t\t   mem,\n@@ -2924,7 +3168,7 @@ cris_expand_epilogue (void)\n      the return address on the stack.  */\n   if (return_address_on_stack && pretend == 0)\n     {\n-      if (current_function_calls_eh_return)\n+      if (TARGET_V32 || current_function_calls_eh_return)\n \t{\n \t  rtx mem;\n \t  rtx insn;\n@@ -2940,10 +3184,11 @@ cris_expand_epilogue (void)\n \t  REG_NOTES (insn)\n \t    = alloc_EXPR_LIST (REG_INC, stack_pointer_rtx, REG_NOTES (insn));\n \n-\t  emit_insn (gen_addsi3 (stack_pointer_rtx,\n-\t\t\t\t stack_pointer_rtx,\n-\t\t\t\t gen_rtx_raw_REG (SImode,\n-\t\t\t\t\t\t  CRIS_STACKADJ_REG)));\n+\t  if (current_function_calls_eh_return)\n+\t    emit_insn (gen_addsi3 (stack_pointer_rtx,\n+\t\t\t\t   stack_pointer_rtx,\n+\t\t\t\t   gen_rtx_raw_REG (SImode,\n+\t\t\t\t\t\t    CRIS_STACKADJ_REG)));\n \t  cris_expand_return (false);\n \t}\n       else\n@@ -3002,6 +3247,12 @@ cris_gen_movem_load (rtx src, rtx nregs_rtx, int nprefix)\n   unsigned int regno = nregs - 1;\n   int regno_inc = -1;\n \n+  if (TARGET_V32)\n+    {\n+      regno = 0;\n+      regno_inc = 1;\n+    }\n+\n   if (GET_CODE (srcreg) == POST_INC)\n     srcreg = XEXP (srcreg, 0);\n \n@@ -3055,6 +3306,12 @@ cris_emit_movem_store (rtx dest, rtx nregs_rtx, int increment,\n   unsigned int regno = nregs - 1;\n   int regno_inc = -1;\n \n+  if (TARGET_V32)\n+    {\n+      regno = 0;\n+      regno_inc = 1;\n+    }\n+\n   if (GET_CODE (destreg) == POST_INC)\n     increment += nregs * 4;\n \n@@ -3191,32 +3448,61 @@ cris_expand_pic_call_address (rtx *opp)\n       /* For local symbols (non-PLT), just get the plain symbol\n \t reference into a register.  For symbols that can be PLT, make\n \t them PLT.  */\n-      if (t == cris_gotrel_symbol)\n-\top = force_reg (Pmode, op);\n+      if (t == cris_rel_symbol)\n+\t{\n+\t  /* For v32, we're fine as-is; just PICify the symbol.  Forcing\n+\t     into a register caused performance regression for 3.2.1,\n+\t     observable in __floatdidf and elsewhere in libgcc.  */\n+\t  if (TARGET_V32)\n+\t    {\n+\t      rtx sym = GET_CODE (op) != CONST ? op : get_related_value (op);\n+\t      HOST_WIDE_INT offs = get_integer_term (op);\n+\n+\t      /* We can't get calls to sym+N, N integer, can we?  */\n+\t      gcc_assert (offs == 0);\n+\n+\t      op = gen_rtx_CONST (Pmode,\n+\t\t\t\t  gen_rtx_UNSPEC (Pmode, gen_rtvec (1, sym),\n+\t\t\t\t\t\t  CRIS_UNSPEC_PCREL));\n+\t    }\n+\t  else\n+\t    op = force_reg (Pmode, op);\n+\t}\n       else if (t == cris_got_symbol)\n \t{\n \t  if (TARGET_AVOID_GOTPLT)\n \t    {\n \t      /* Change a \"jsr sym\" into (allocate register rM, rO)\n-\t\t \"move.d (const (unspec [sym] CRIS_UNSPEC_PLT)),rM\"\n-\t\t \"add.d rPIC,rM,rO\", \"jsr rO\".  */\n+\t\t \"move.d (const (unspec [sym rPIC] CRIS_UNSPEC_PLT_GOTREL)),rM\"\n+\t\t \"add.d rPIC,rM,rO\", \"jsr rO\" for pre-v32 and\n+\t\t \"jsr (const (unspec [sym rPIC] CRIS_UNSPEC_PLT_PCREL))\"\n+\t\t for v32.  */\n \t      rtx tem, rm, ro;\n \t      gcc_assert (can_create_pseudo_p ());\n \t      current_function_uses_pic_offset_table = 1;\n-\t      tem = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, op), CRIS_UNSPEC_PLT);\n-\t      rm = gen_reg_rtx (Pmode);\n-\t      emit_move_insn (rm, gen_rtx_CONST (Pmode, tem));\n-\t      ro = gen_reg_rtx (Pmode);\n-\t      if (expand_binop (Pmode, add_optab, rm,\n-\t\t\t\tpic_offset_table_rtx,\n-\t\t\t\tro, 0, OPTAB_LIB_WIDEN) != ro)\n-\t\tinternal_error (\"expand_binop failed in movsi got\");\n-\t      op = ro;\n+\t      tem = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, op),\n+\t\t\t\t    TARGET_V32\n+\t\t\t\t    ? CRIS_UNSPEC_PLT_PCREL\n+\t\t\t\t    : CRIS_UNSPEC_PLT_GOTREL);\n+\t      tem = gen_rtx_CONST (Pmode, tem);\n+\t      if (TARGET_V32)\n+\t\top = tem;\n+\t      else\n+\t\t{\n+\t\t  rm = gen_reg_rtx (Pmode);\n+\t\t  emit_move_insn (rm, tem);\n+\t\t  ro = gen_reg_rtx (Pmode);\n+\t\t  if (expand_binop (Pmode, add_optab, rm,\n+\t\t\t\t    pic_offset_table_rtx,\n+\t\t\t\t    ro, 0, OPTAB_LIB_WIDEN) != ro)\n+\t\t    internal_error (\"expand_binop failed in movsi got\");\n+\t\t  op = ro;\n+\t\t}\n \t    }\n \t  else\n \t    {\n \t      /* Change a \"jsr sym\" into (allocate register rM, rO)\n-\t\t \"move.d (const (unspec [sym] CRIS_UNSPEC_PLTGOT)),rM\"\n+\t\t \"move.d (const (unspec [sym] CRIS_UNSPEC_PLTGOTREAD)),rM\"\n \t\t \"add.d rPIC,rM,rO\" \"jsr [rO]\" with the memory access\n \t\t marked as not trapping and not aliasing.  No \"move.d\n \t\t [rO],rP\" as that would invite to re-use of a value\n@@ -3300,7 +3586,7 @@ cris_asm_output_symbol_ref (FILE *file, rtx x)\n      assemble_name (file, str);\n \n      /* Sanity check.  */\n-     if (! current_function_uses_pic_offset_table)\n+     if (!TARGET_V32 && !current_function_uses_pic_offset_table)\n        output_operand_lossage (\"PIC register isn't set up\");\n     }\n   else\n@@ -3317,7 +3603,7 @@ cris_asm_output_label_ref (FILE *file, char *buf)\n       assemble_name (file, buf);\n \n       /* Sanity check.  */\n-      if (! current_function_uses_pic_offset_table)\n+      if (!TARGET_V32 && !current_function_uses_pic_offset_table)\n \tinternal_error (\"emitting PIC operand, but PIC register isn't set up\");\n     }\n   else\n@@ -3341,11 +3627,25 @@ cris_output_addr_const_extra (FILE *file, rtx xconst)\n       output_addr_const (file, x);\n       switch (XINT (xconst, 1))\n \t{\n-\tcase CRIS_UNSPEC_PLT:\n+\tcase CRIS_UNSPEC_PCREL:\n+\t  /* We only get this with -fpic/PIC to tell it apart from an\n+\t     invalid symbol.  We can't tell here, but it should only\n+\t     be the operand of a call or movsi.  */\n+\t  gcc_assert (TARGET_V32 && flag_pic);\n+\t  break;\n+\n+\tcase CRIS_UNSPEC_PLT_PCREL:\n+\t  gcc_assert (TARGET_V32);\n+\t  fprintf (file, \":PLT\");\n+\t  break;\n+\n+\tcase CRIS_UNSPEC_PLT_GOTREL:\n+\t  gcc_assert (!TARGET_V32);\n \t  fprintf (file, \":PLTG\");\n \t  break;\n \n \tcase CRIS_UNSPEC_GOTREL:\n+\t  gcc_assert (!TARGET_V32);\n \t  fprintf (file, \":GOTOFF\");\n \t  break;\n "}]}