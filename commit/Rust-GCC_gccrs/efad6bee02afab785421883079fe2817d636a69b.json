{"sha": "efad6bee02afab785421883079fe2817d636a69b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWZhZDZiZWUwMmFmYWI3ODU0MjE4ODMwNzlmZTI4MTdkNjM2YTY5Yg==", "commit": {"author": {"name": "Nicola Pero", "email": "nicola.pero@meta-innovation.com", "date": "2011-06-03T00:43:14Z"}, "committer": {"name": "Nicola Pero", "email": "nicola@gcc.gnu.org", "date": "2011-06-03T00:43:14Z"}, "message": "In libobjc/: 2011-06-03 Nicola Pero <nicola.pero@meta-innovation.com>\n\nIn libobjc/:\n2011-06-03  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n\t* Makefile.in (OBJC_H): Removed typedstream.h.\n\t(OBJC_DEPRECATED_H): Removed typedstream.h.\n\t(C_SOURCE_FILES): Removed archive.c.\n\t(Object.lo): Rule removed.\n\t(Object_gc.lo): Likewise.\n\t(archive.lo): Likewise.\n\t(archive_gc.lo): Likewise.\n\t* objc/deprecated/Object.h ([+streamVersion:], [-read], [-write],\n\t[-awake]): Removed.\n\tDo not include deprecated/typedstream.h.\n\t* Object.m: Removed the same methods.\n\t* archive.c: File removed.\n\t* objc/typedstream.h: File removed.\n\t* objc/deprecated/typedstream.h: File removed.\n\t* libobjc.def (__objc_read_nbyte_uint, __objc_read_nbyte_ulong,\n\t__objc_write_class, __objc_write_object, __objc_write_selector,\n\tobjc_close_typed_stream, objc_end_of_typed_stream,\n\tobjc_flush_typed_stream, objc_get_stream_class_version,\n\tobjc_open_typed_stream, objc_open_typed_stream_for_file,\n\tobjc_read_array, objc_read_char, objc_read_int, objc_read_long,\n\tobjc_read_object, objc_read_selector, objc_read_short,\n\tobjc_read_string, objc_read_type, objc_read_types,\n\tobjc_read_unsigned_char, objc_read_unsigned_int,\n\tobjc_read_unsigned_long, objc_read_unsigned_short,\n\tobjc_write_array, objc_write_char, objc_write_int,\n\tobjc_write_long, objc_write_object, objc_write_object_reference,\n\tobjc_write_root_object, objc_write_selector, objc_write_short,\n\tobjc_write_string, objc_write_string_atomic, objc_write_type,\n\tobjc_write_types, objc_write_unsigned_char,\n\tobjc_write_unsigned_int, objc_write_unsigned_long,\n\tobjc_write_unsigned_short): Removed.\n\t\nIn gcc/testsuite/:\n2011-06-03  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n\t* objc.dg/type-stream-1.m: Test removed.\n\t* objc.dg/headers.m: Do not include typedstream.h.\n\nFrom-SVN: r174593", "tree": {"sha": "020d2e554ecf64a23304f479a6cd272094d0fd06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/020d2e554ecf64a23304f479a6cd272094d0fd06"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/efad6bee02afab785421883079fe2817d636a69b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efad6bee02afab785421883079fe2817d636a69b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/efad6bee02afab785421883079fe2817d636a69b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efad6bee02afab785421883079fe2817d636a69b/comments", "author": {"login": "Nico-31415", "id": 94470564, "node_id": "U_kgDOBaGBpA", "avatar_url": "https://avatars.githubusercontent.com/u/94470564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nico-31415", "html_url": "https://github.com/Nico-31415", "followers_url": "https://api.github.com/users/Nico-31415/followers", "following_url": "https://api.github.com/users/Nico-31415/following{/other_user}", "gists_url": "https://api.github.com/users/Nico-31415/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nico-31415/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nico-31415/subscriptions", "organizations_url": "https://api.github.com/users/Nico-31415/orgs", "repos_url": "https://api.github.com/users/Nico-31415/repos", "events_url": "https://api.github.com/users/Nico-31415/events{/privacy}", "received_events_url": "https://api.github.com/users/Nico-31415/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ba4a8e3fd478292ebd3527dc232d64e65ab870e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba4a8e3fd478292ebd3527dc232d64e65ab870e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba4a8e3fd478292ebd3527dc232d64e65ab870e4"}], "stats": {"total": 1969, "additions": 41, "deletions": 1928}, "files": [{"sha": "acbd7809fb75995d741643a149ffcd5d7d9c4e8a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efad6bee02afab785421883079fe2817d636a69b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efad6bee02afab785421883079fe2817d636a69b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=efad6bee02afab785421883079fe2817d636a69b", "patch": "@@ -1,3 +1,8 @@\n+2011-06-03  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* objc.dg/type-stream-1.m: Test removed.\n+\t* objc.dg/headers.m: Do not include typedstream.h.\n+\t\n 2011-06-02  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* objc.dg/torture/forward-1.m (main): Updated testcase."}, {"sha": "20c32d4992802f1e94587fe8a6a7bfe908cd1e4e", "filename": "gcc/testsuite/objc.dg/headers.m", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efad6bee02afab785421883079fe2817d636a69b/gcc%2Ftestsuite%2Fobjc.dg%2Fheaders.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efad6bee02afab785421883079fe2817d636a69b/gcc%2Ftestsuite%2Fobjc.dg%2Fheaders.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fheaders.m?ref=efad6bee02afab785421883079fe2817d636a69b", "patch": "@@ -27,5 +27,4 @@\n #ifndef __NEXT_RUNTIME__\n #include <objc/sarray.h>\n #include <objc/thr.h>\n-#include <objc/typedstream.h>\n #endif"}, {"sha": "9f2d509fbf787443e63017d4266983a4d46100d9", "filename": "gcc/testsuite/objc.dg/type-stream-1.m", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4a8e3fd478292ebd3527dc232d64e65ab870e4/gcc%2Ftestsuite%2Fobjc.dg%2Ftype-stream-1.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4a8e3fd478292ebd3527dc232d64e65ab870e4/gcc%2Ftestsuite%2Fobjc.dg%2Ftype-stream-1.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Ftype-stream-1.m?ref=ba4a8e3fd478292ebd3527dc232d64e65ab870e4", "patch": "@@ -1,17 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-skip-if \"\" { *-*-* } { \"-fnext-runtime\" } { \"\" } } */\n-\n-/* Test warning for deprecated typedstream functions.  These functions\n-   will be removed in the release after 4.6.0, at which point this\n-   testcase can be removed too.\n- */\n-\n-#include <objc/typedstream.h>\n-\n-void dummy (void)\n-{\n-  TypedStream* t = objc_open_typed_stream_for_file (\"dummy\", 0); /* { dg-warning \"deprecated\" } */\n-\n-  objc_write_object (t, nil); /* { dg-warning \"deprecated\" } */\n-  objc_read_object (t, NULL);  /* { dg-warning \"deprecated\" } */\n-}"}, {"sha": "bd4fcf52946e5dfe894b9bb72efb0238ee78e957", "filename": "libobjc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efad6bee02afab785421883079fe2817d636a69b/libobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efad6bee02afab785421883079fe2817d636a69b/libobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2FChangeLog?ref=efad6bee02afab785421883079fe2817d636a69b", "patch": "@@ -1,3 +1,37 @@\n+2011-06-03  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* Makefile.in (OBJC_H): Removed typedstream.h.\n+\t(OBJC_DEPRECATED_H): Removed typedstream.h.\n+\t(C_SOURCE_FILES): Removed archive.c.\n+\t(Object.lo): Rule removed.\n+\t(Object_gc.lo): Likewise.\n+\t(archive.lo): Likewise.\n+\t(archive_gc.lo): Likewise.\n+\t* objc/deprecated/Object.h ([+streamVersion:], [-read], [-write],\n+\t[-awake]): Removed.\n+\tDo not include deprecated/typedstream.h.\n+\t* Object.m: Removed the same methods.\n+\t* archive.c: File removed.\n+\t* objc/typedstream.h: File removed.\n+\t* objc/deprecated/typedstream.h: File removed.\n+\t* libobjc.def (__objc_read_nbyte_uint, __objc_read_nbyte_ulong,\n+\t__objc_write_class, __objc_write_object, __objc_write_selector,\n+\tobjc_close_typed_stream, objc_end_of_typed_stream,\n+\tobjc_flush_typed_stream, objc_get_stream_class_version,\n+\tobjc_open_typed_stream, objc_open_typed_stream_for_file,\n+\tobjc_read_array, objc_read_char, objc_read_int, objc_read_long,\n+\tobjc_read_object, objc_read_selector, objc_read_short,\n+\tobjc_read_string, objc_read_type, objc_read_types,\n+\tobjc_read_unsigned_char, objc_read_unsigned_int,\n+\tobjc_read_unsigned_long, objc_read_unsigned_short,\n+\tobjc_write_array, objc_write_char, objc_write_int,\n+\tobjc_write_long, objc_write_object, objc_write_object_reference,\n+\tobjc_write_root_object, objc_write_selector, objc_write_short,\n+\tobjc_write_string, objc_write_string_atomic, objc_write_type,\n+\tobjc_write_types, objc_write_unsigned_char,\n+\tobjc_write_unsigned_int, objc_write_unsigned_long,\n+\tobjc_write_unsigned_short): Removed.\n+\t\n 2011-06-02  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* Makefile.in (OBJC_DEPRECATED_H): Removed objc_error.h."}, {"sha": "90190465dd5c8c7328dc66e02a0d21e7b1535d88", "filename": "libobjc/Makefile.in", "status": "modified", "additions": 2, "deletions": 26, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efad6bee02afab785421883079fe2817d636a69b/libobjc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efad6bee02afab785421883079fe2817d636a69b/libobjc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2FMakefile.in?ref=efad6bee02afab785421883079fe2817d636a69b", "patch": "@@ -126,8 +126,7 @@ OBJC_H = \\\n   \\\n   hash.h \\\n   objc-list.h \\\n-  sarray.h \\\n-  typedstream.h\n+  sarray.h\n \n # User-visible header files containing deprecated APIs, from the\n # objc/deprecated directory\n@@ -157,8 +156,7 @@ OBJC_DEPRECATED_H = \\\n   struct_objc_protocol_list.h \\\n   struct_objc_selector.h \\\n   struct_objc_static_instances.h \\\n-  struct_objc_symtab.h \\\n-  typedstream.h \n+  struct_objc_symtab.h\n \n # Objective-C source files to compile\n OBJC_SOURCE_FILES = \\\n@@ -170,7 +168,6 @@ OBJC_SOURCE_FILES = \\\n \n # C source files to compile\n C_SOURCE_FILES = \\\n-   archive.c \\\n    class.c \\\n    encoding.c \\\n    error.c \\\n@@ -278,27 +275,6 @@ sendmsg_gc.lo: sendmsg.c runtime-info.h\n \n # These files have separate rules because they require special\n # compiler flags.\n-archive.lo: archive.c\n-\t$(LIBTOOL_COMPILE) $(CC) $< -c \\\n-\t   $(ALL_CFLAGS) $(INCLUDES) -Wno-deprecated-declarations \\\n-\t   -o $@\n-\n-archive_gc.lo: archive.c\n-\t$(LIBTOOL_COMPILE) $(CC) $< -c \\\n-\t   $(ALL_CFLAGS) $(INCLUDES) $(OBJC_GCFLAGS) -Wno-deprecated-declarations \\\n-\t   -o $@\n-\n-# -Wno-deprecated-declarations is for the objc/typedstream.h functions.\n-Object.lo: Object.m\n-\t$(LIBTOOL_COMPILE) $(CC) $< -c \\\n-\t   $(ALL_CFLAGS) $(INCLUDES) -fgnu-runtime -Wno-deprecated-declarations \\\n-\t   -o $@\n-\n-# -Wno-deprecated-declarations is for the objc/typedstream.h functions.\n-Object_gc.lo: Object.m\n-\t$(LIBTOOL_COMPILE) $(CC) $< -c \\\n-\t   $(ALL_CFLAGS) $(INCLUDES) $(OBJC_GCFLAGS) -fgnu-runtime -Wno-deprecated-declarations \\\n-\t   -o $@\n \n # -Wno-deprecated-declarations is to silence warnings from using \n # _objc_unexpected_exception."}, {"sha": "7e414c4014d1f70fe2ff2606ab762483353b2075", "filename": "libobjc/Object.m", "status": "modified", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efad6bee02afab785421883079fe2817d636a69b/libobjc%2FObject.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efad6bee02afab785421883079fe2817d636a69b/libobjc%2FObject.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2FObject.m?ref=efad6bee02afab785421883079fe2817d636a69b", "patch": "@@ -289,38 +289,4 @@ + (int)version\n   return self;\n }\n \n-+ (int)streamVersion: (TypedStream*)aStream\n-{\n-  if (aStream->mode == OBJC_READONLY)\n-    return objc_get_stream_class_version (aStream, self);\n-  else\n-    return class_get_version (self);\n-}\n-\n-// These are used to write or read the instance variables \n-// declared in this particular part of the object.  Subclasses\n-// should extend these, by calling [super read/write: aStream]\n-// before doing their own archiving.  These methods are private, in\n-// the sense that they should only be called from subclasses.\n-\n-- read: (TypedStream*)aStream\n-{\n-  (void) aStream; /* UNUSED */\n-  // [super read: aStream];  \n-  return self;\n-}\n-\n-- write: (TypedStream*)aStream\n-{\n-  (void) aStream; /* UNUSED */\n-  // [super write: aStream];\n-  return self;\n-}\n-\n-- awake\n-{\n-  // [super awake];\n-  return self;\n-}\n-\n @end"}, {"sha": "f691b13b601f893a624247cdc6c0e578b592f4c2", "filename": "libobjc/archive.c", "status": "removed", "additions": 0, "deletions": 1656, "changes": 1656, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4a8e3fd478292ebd3527dc232d64e65ab870e4/libobjc%2Farchive.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4a8e3fd478292ebd3527dc232d64e65ab870e4/libobjc%2Farchive.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Farchive.c?ref=ba4a8e3fd478292ebd3527dc232d64e65ab870e4", "patch": "@@ -1,1656 +0,0 @@\n- /* GNU Objective C Runtime archiving\n-   Copyright (C) 1993, 1995, 1996, 1997, 2002, 2004, 2009,\n-   2010 Free Software Foundation, Inc.\n-   Contributed by Kresten Krab Thorup\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under the\n-terms of the GNU General Public License as published by the Free Software\n-Foundation; either version 3, or (at your option) any later version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n-FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n-details.\n-\n-Under Section 7 of GPL version 3, you are granted additional\n-permissions described in the GCC Runtime Library Exception, version\n-3.1, as published by the Free Software Foundation.\n-\n-You should have received a copy of the GNU General Public License and\n-a copy of the GCC Runtime Library Exception along with this program;\n-see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-<http://www.gnu.org/licenses/>.  */\n-\n-/* This file is entirely deprecated and will be removed.  */\n-\n-#include \"objc-private/common.h\"\n-#include \"objc-private/error.h\"\n-#include \"tconfig.h\"\n-#include \"objc/objc-api.h\"\n-#include \"objc/hash.h\"\n-#include \"objc/objc-list.h\" \n-#include \"objc-private/runtime.h\"\n-#include \"objc/typedstream.h\"\n-#include \"objc/encoding.h\"\n-#include <stdlib.h>\n-\n-extern int fflush (FILE *);\n-\n-#define ROUND(V, A) \\\n-  ({ typeof (V) __v = (V); typeof (A) __a = (A);  \\\n-     __a * ((__v + __a - 1)/__a); })\n-\n-#define PTR2LONG(P) (((char *) (P))-(char *) 0)\n-#define LONG2PTR(L) (((char *) 0) + (L))\n-\n-/* Declare some functions... */\n-\n-static int\n-objc_read_class (struct objc_typed_stream *stream, Class *class);\n-\n-int objc_sizeof_type (const char *type);\n-\n-static int\n-objc_write_use_common (struct objc_typed_stream *stream, unsigned long key);\n-\n-static int\n-objc_write_register_common (struct objc_typed_stream *stream,\n-\t\t\t    unsigned long key);\n-\n-static int \n-objc_write_class (struct objc_typed_stream *stream,\n-\t\t\t struct objc_class *class);\n-\n-const char *objc_skip_type (const char *type);\n-\n-static void __objc_finish_write_root_object (struct objc_typed_stream *);\n-static void __objc_finish_read_root_object (struct objc_typed_stream *);\n-\n-static inline int\n-__objc_code_unsigned_char (unsigned char *buf, unsigned char val)\n-{\n-  if ((val&_B_VALUE) == val)\n-    {\n-      buf[0] = val|_B_SINT;\n-      return 1;\n-    }\n-  else\n-    {\n-      buf[0] = _B_NINT|0x01;\n-      buf[1] = val;\n-      return 2;\n-    }\n-}\n-\n-int\n-objc_write_unsigned_char (struct objc_typed_stream *stream,\n-\t\t\t  unsigned char value)\n-{\n-  unsigned char buf[sizeof (unsigned char) + 1];\n-  int len = __objc_code_unsigned_char (buf, value);\n-  return (*stream->write) (stream->physical, (char*)buf, len);\n-}\n-\n-static inline int\n-__objc_code_char (unsigned char *buf, signed char val)\n-{\n-  if (val >= 0)\n-    return __objc_code_unsigned_char (buf, val);\n-  else\n-    {\n-      buf[0] = _B_NINT|_B_SIGN|0x01;\n-      buf[1] = -val;\n-      return 2;\n-    }\n-}\n-\n-int\n-objc_write_char (struct objc_typed_stream *stream, signed char value)\n-{\n-  unsigned char buf[sizeof (char) + 1];\n-  int len = __objc_code_char (buf, value);\n-  return (*stream->write) (stream->physical, (char*)buf, len);\n-}\n-\n-static inline int\n-__objc_code_unsigned_short (unsigned char *buf, unsigned short val)\n-{\n-  if ((val&_B_VALUE) == val)\n-    {\n-      buf[0] = val|_B_SINT;\n-      return 1;\n-    }\n-  else \n-    {\n-      int c, b;\n-\n-      buf[0] = _B_NINT;\n-\n-      for (c = sizeof (short); c != 0; c -= 1)\n-\tif (((val >> (8*(c - 1)))%0x100) != 0)\n-\t  break;\n-\n-      buf[0] |= c;\n-\n-      for (b = 1; c != 0; c--, b++)\n-\t{\n-\t  buf[b] = (val >> (8*(c - 1)))%0x100;\n-\t}\n-\n-      return b;\n-    }\n-}\n-\n-int\n-objc_write_unsigned_short (struct objc_typed_stream *stream, \n-\t\t\t   unsigned short value)\n-{\n-  unsigned char buf[sizeof (unsigned short) + 1];\n-  int len = __objc_code_unsigned_short (buf, value);\n-  return (*stream->write) (stream->physical, (char*)buf, len);\n-}\n-      \n-static inline int\n-__objc_code_short (unsigned char *buf, short val)\n-{\n-  int sign = (val < 0);\n-  int size = __objc_code_unsigned_short (buf, sign ? -val : val);\n-  if (sign)\n-    buf[0] |= _B_SIGN;\n-  return size;\n-}\n-\n-int\n-objc_write_short (struct objc_typed_stream *stream, short value)\n-{\n-  unsigned char buf[sizeof (short) + 1];\n-  int len = __objc_code_short (buf, value);\n-  return (*stream->write) (stream->physical, (char*)buf, len);\n-}\n-      \n-\n-static inline int\n-__objc_code_unsigned_int (unsigned char *buf, unsigned int val)\n-{\n-  if ((val&_B_VALUE) == val)\n-    {\n-      buf[0] = val|_B_SINT;\n-      return 1;\n-    }\n-  else \n-    {\n-      int c, b;\n-\n-      buf[0] = _B_NINT;\n-\n-      for (c = sizeof (int); c != 0; c -= 1)\n-\tif (((val >> (8*(c - 1)))%0x100) != 0)\n-\t  break;\n-\n-      buf[0] |= c;\n-\n-      for (b = 1; c != 0; c--, b++)\n-\t{\n-\t  buf[b] = (val >> (8*(c-1)))%0x100;\n-\t}\n-\n-      return b;\n-    }\n-}\n-\n-int\n-objc_write_unsigned_int (struct objc_typed_stream *stream, unsigned int value)\n-{\n-  unsigned char buf[sizeof (unsigned int) + 1];\n-  int len = __objc_code_unsigned_int (buf, value);\n-  return (*stream->write) (stream->physical, (char*)buf, len);\n-}\n-\n-static inline int\n-__objc_code_int (unsigned char *buf, int val)\n-{\n-  int sign = (val < 0);\n-  int size = __objc_code_unsigned_int (buf, sign ? -val : val);\n-  if (sign)\n-    buf[0] |= _B_SIGN;\n-  return size;\n-}\n-\n-int\n-objc_write_int (struct objc_typed_stream *stream, int value)\n-{\n-  unsigned char buf[sizeof (int) + 1];\n-  int len = __objc_code_int (buf, value);\n-  return (*stream->write) (stream->physical, (char*)buf, len);\n-}\n-\n-static inline int\n-__objc_code_unsigned_long (unsigned char *buf, unsigned long val)\n-{\n-  if ((val&_B_VALUE) == val)\n-    {\n-      buf[0] = val|_B_SINT;\n-      return 1;\n-    }\n-  else \n-    {\n-      int c, b;\n-\n-      buf[0] = _B_NINT;\n-\n-      for (c = sizeof (long); c != 0; c -= 1)\n-\tif (((val >> (8*(c - 1)))%0x100) != 0)\n-\t  break;\n-\n-      buf[0] |= c;\n-\n-      for (b = 1; c != 0; c--, b++)\n-\t{\n-\t  buf[b] = (val >> (8*(c - 1)))%0x100;\n-\t}\n-\n-      return b;\n-    }\n-}\n-\n-int\n-objc_write_unsigned_long (struct objc_typed_stream *stream, \n-\t\t\t  unsigned long value)\n-{\n-  unsigned char buf[sizeof (unsigned long) + 1];\n-  int len = __objc_code_unsigned_long (buf, value);\n-  return (*stream->write) (stream->physical, (char*)buf, len);\n-}\n-\n-static inline int\n-__objc_code_long (unsigned char *buf, long val)\n-{\n-  int sign = (val < 0);\n-  int size = __objc_code_unsigned_long (buf, sign ? -val : val);\n-  if (sign)\n-    buf[0] |= _B_SIGN;\n-  return size;\n-}\n-\n-int\n-objc_write_long (struct objc_typed_stream *stream, long value)\n-{\n-  unsigned char buf[sizeof (long) + 1];\n-  int len = __objc_code_long (buf, value);\n-  return (*stream->write) (stream->physical, (char*)buf, len);\n-}\n-\n-\n-int\n-objc_write_string (struct objc_typed_stream *stream,\n-\t\t   const unsigned char *string, unsigned int nbytes)\n-{\n-  unsigned char buf[sizeof (unsigned int) + 1];\n-  int len = __objc_code_unsigned_int (buf, nbytes);\n-  \n-  if ((buf[0]&_B_CODE) == _B_SINT)\n-    buf[0] = (buf[0]&_B_VALUE)|_B_SSTR;\n-\n-  else /* _B_NINT */\n-    buf[0] = (buf[0]&_B_VALUE)|_B_NSTR;\n-\n-  if ((*stream->write) (stream->physical, (char*)buf, len) != 0)\n-    return (*stream->write) (stream->physical, (char*)string, nbytes);\n-  else\n-    return 0;\n-}\n-\n-int\n-objc_write_string_atomic (struct objc_typed_stream *stream,\n-\t\t\t  unsigned char *string, unsigned int nbytes)\n-{\n-  unsigned long key;\n-  if ((key = PTR2LONG(objc_hash_value_for_key (stream->stream_table, string))))\n-    return objc_write_use_common (stream, key);\n-  else\n-    {\n-      int length;\n-      objc_hash_add (&stream->stream_table,\n-\t\t     LONG2PTR(key=PTR2LONG(string)), string);\n-      if ((length = objc_write_register_common (stream, key)))\n-\treturn objc_write_string (stream, string, nbytes);\n-      return length;\n-    }\n-}\n-\n-static int\n-objc_write_register_common (struct objc_typed_stream *stream, \n-\t\t\t    unsigned long key)\n-{\n-  unsigned char buf[sizeof (unsigned long)+2];\n-  int len = __objc_code_unsigned_long (buf + 1, key);\n-  if (len == 1)\n-    {\n-      buf[0] = _B_RCOMM|0x01;\n-      buf[1] &= _B_VALUE;\n-      return (*stream->write) (stream->physical, (char*)buf, len + 1);\n-    }\n-  else\n-    {\n-      buf[1] = (buf[1]&_B_VALUE)|_B_RCOMM;\n-      return (*stream->write) (stream->physical, (char*)buf + 1, len);\n-    }\n-}\n-\n-static int\n-objc_write_use_common (struct objc_typed_stream *stream, unsigned long key)\n-{\n-  unsigned char buf[sizeof (unsigned long)+2];\n-  int len = __objc_code_unsigned_long (buf + 1, key);\n-  if (len == 1)\n-    {\n-      buf[0] = _B_UCOMM|0x01;\n-      buf[1] &= _B_VALUE;\n-      return (*stream->write) (stream->physical, (char*)buf, 2);\n-    }\n-  else\n-    {\n-      buf[1] = (buf[1]&_B_VALUE)|_B_UCOMM;\n-      return (*stream->write) (stream->physical, (char*)buf + 1, len);\n-    }\n-}\n-\n-static inline int\n-__objc_write_extension (struct objc_typed_stream *stream, unsigned char code)\n-{\n-  if (code <= _B_VALUE)\n-    {\n-      unsigned char buf = code|_B_EXT;\n-      return (*stream->write) (stream->physical, (char*)&buf, 1);\n-    }\n-  else \n-    {\n-      _objc_abort (\"__objc_write_extension: bad opcode %c\\n\", code);\n-      return -1;\n-    }\n-}\n-\n-int\n-__objc_write_object (struct objc_typed_stream *stream, id object)\n-{\n-  unsigned char buf = '\\0';\n-  SEL write_sel = sel_get_any_uid (\"write:\");\n-  if (object)\n-    {\n-      __objc_write_extension (stream, _BX_OBJECT);\n-      objc_write_class (stream, object->class_pointer);\n-      (*objc_msg_lookup (object, write_sel)) (object, write_sel, stream);\n-      return (*stream->write) (stream->physical, (char*)&buf, 1);\n-    }\n-  else\n-    return objc_write_use_common (stream, 0);\n-}\n-\n-int \n-objc_write_object_reference (struct objc_typed_stream *stream, id object)\n-{\n-  unsigned long key;\n-  if ((key = PTR2LONG(objc_hash_value_for_key (stream->object_table, object))))\n-    return objc_write_use_common (stream, key);\n-\n-  __objc_write_extension (stream, _BX_OBJREF);\n-  return objc_write_unsigned_long (stream, PTR2LONG (object));\n-}\n-\n-int \n-objc_write_root_object (struct objc_typed_stream *stream, id object)\n-{\n-  int len = 0;\n-  if (stream->writing_root_p)\n-    _objc_abort (\"objc_write_root_object called recursively\");\n-  else\n-    {\n-      stream->writing_root_p = 1;\n-      __objc_write_extension (stream, _BX_OBJROOT);\n-      if ((len = objc_write_object (stream, object)))\n-\t__objc_finish_write_root_object (stream);\n-      stream->writing_root_p = 0;\n-    }\n-  return len;\n-}\n-\n-int \n-objc_write_object (struct objc_typed_stream *stream, id object)\n-{\n-  unsigned long key;\n-  if ((key = PTR2LONG(objc_hash_value_for_key (stream->object_table, object))))\n-    return objc_write_use_common (stream, key);\n-\n-  else if (object == nil)\n-    return objc_write_use_common (stream, 0);\n-\n-  else\n-    {\n-      int length;\n-      objc_hash_add (&stream->object_table,\n-\t\t     LONG2PTR(key=PTR2LONG(object)), object);\n-      if ((length = objc_write_register_common (stream, key)))\n-\treturn __objc_write_object (stream, object);\n-      return length;\n-    }\n-}\n-\n-int\n-__objc_write_class (struct objc_typed_stream *stream, struct objc_class *class)\n-{\n-  __objc_write_extension (stream, _BX_CLASS);\n-  objc_write_string_atomic (stream, (unsigned char *) class->name,\n-\t\t\t   strlen ((char *) class->name));\n-  return objc_write_unsigned_long (stream, class->version);\n-}\n-\n-\n-static int \n-objc_write_class (struct objc_typed_stream *stream,\n-\t\t\t struct objc_class *class)\n-{\n-  unsigned long key;\n-  if ((key = PTR2LONG(objc_hash_value_for_key (stream->stream_table, class))))\n-    return objc_write_use_common (stream, key);\n-  else\n-    {\n-      int length;\n-      objc_hash_add (&stream->stream_table,\n-\t\t     LONG2PTR(key = PTR2LONG(class)), class);\n-      if ((length = objc_write_register_common (stream, key)))\n-\treturn __objc_write_class (stream, class);\n-      return length;\n-    }\n-}\n-\n-\n-int \n-__objc_write_selector (struct objc_typed_stream *stream, SEL selector)\n-{\n-  const char *sel_name;\n-  __objc_write_extension (stream, _BX_SEL);\n-  /* to handle NULL selectors */\n-  if ((SEL)0 == selector)\n-    return objc_write_string (stream, (unsigned char*)\"\", 0);\n-  sel_name = sel_get_name (selector);\n-  return objc_write_string (stream, (unsigned char*)sel_name, strlen ((char*)sel_name));\n-}\n-\n-int \n-objc_write_selector (struct objc_typed_stream *stream, SEL selector)\n-{\n-  const char *sel_name;\n-  unsigned long key;\n-\n-  /* to handle NULL selectors */\n-  if ((SEL)0 == selector)\n-    return __objc_write_selector (stream, selector);\n-\n-  sel_name = sel_get_name (selector);\n-  if ((key = PTR2LONG(objc_hash_value_for_key (stream->stream_table,\n-\t\t\t\t\t       sel_name))))\n-    return objc_write_use_common (stream, key);\n-  else\n-    {\n-      int length;\n-      objc_hash_add (&stream->stream_table, \n-\t\tLONG2PTR(key = PTR2LONG(sel_name)), (char *) sel_name);\n-      if ((length = objc_write_register_common (stream, key)))\n-\treturn __objc_write_selector (stream, selector);\n-      return length;\n-    }\n-}\n-\n-\n-\n-/*\n-** Read operations \n-*/\n-\n-int\n-objc_read_char (struct objc_typed_stream *stream, char *val)\n-{\n-  unsigned char buf;\n-  int len;\n-  len = (*stream->read) (stream->physical, (char*)&buf, 1);\n-  if (len != 0)\n-    {\n-      if ((buf & _B_CODE) == _B_SINT)\n-\t(*val) = (buf & _B_VALUE);\n-\n-      else if ((buf & _B_NUMBER) == 1)\n-\t{\n-\t  len = (*stream->read) (stream->physical, val, 1);\n-\t  if (buf&_B_SIGN)\n-\t    (*val) = -1 * (*val);\n-\t}\n-\n-      else\n-\t_objc_abort (\"expected 8bit signed int, got %dbit int\",\n-\t\t     (int) (buf&_B_NUMBER)*8);\n-    }\n-  return len;\n-}\n-\n-\n-int\n-objc_read_unsigned_char (struct objc_typed_stream *stream, unsigned char *val)\n-{\n-  unsigned char buf;\n-  int len;\n-  if ((len = (*stream->read) (stream->physical, (char*)&buf, 1)))\n-    {\n-      if ((buf & _B_CODE) == _B_SINT)\n-\t(*val) = (buf & _B_VALUE);\n-\n-      else if ((buf & _B_NUMBER) == 1)\n-\tlen = (*stream->read) (stream->physical, (char*)val, 1);\n-\n-      else\n-\t_objc_abort (\"expected 8bit unsigned int, got %dbit int\",\n-\t\t     (int) (buf&_B_NUMBER)*8);\n-    }\n-  return len;\n-}\n-\n-int\n-objc_read_short (struct objc_typed_stream *stream, short *value)\n-{\n-  unsigned char buf[sizeof (short) + 1];\n-  int len;\n-  if ((len = (*stream->read) (stream->physical, (char*)buf, 1)))\n-    {\n-      if ((buf[0] & _B_CODE) == _B_SINT)\n-\t(*value) = (buf[0] & _B_VALUE);\n-\n-      else\n-\t{\n-\t  int pos = 1;\n-\t  int nbytes = buf[0] & _B_NUMBER;\n-\t  if (nbytes > (int) sizeof (short))\n-\t    _objc_abort (\"expected short, got bigger (%dbits)\", nbytes*8);\n-\t  len = (*stream->read) (stream->physical, (char*)buf + 1, nbytes);\n-\t  (*value) = 0;\n-\t  while (pos <= nbytes)\n-\t    (*value) = ((*value)*0x100) + buf[pos++];\n-\t  if (buf[0] & _B_SIGN)\n-\t    (*value) = -(*value);\n-\t}\n-    }\n-  return len;\n-}\n-\n-int\n-objc_read_unsigned_short (struct objc_typed_stream *stream,\n-\t\t\t  unsigned short *value)\n-{\n-  unsigned char buf[sizeof (unsigned short) + 1];\n-  int len;\n-  if ((len = (*stream->read) (stream->physical, (char*)buf, 1)))\n-    {\n-      if ((buf[0] & _B_CODE) == _B_SINT)\n-\t(*value) = (buf[0] & _B_VALUE);\n-\n-      else\n-\t{\n-\t  int pos = 1;\n-\t  int nbytes = buf[0] & _B_NUMBER;\n-\t  if (nbytes > (int) sizeof (short))\n-\t    _objc_abort (\"expected short, got int or bigger\");\n-\t  len = (*stream->read) (stream->physical, (char*)buf + 1, nbytes);\n-\t  (*value) = 0;\n-\t  while (pos <= nbytes)\n-\t    (*value) = ((*value)*0x100) + buf[pos++];\n-\t}\n-    }\n-  return len;\n-}\n-\n-\n-int\n-objc_read_int (struct objc_typed_stream *stream, int *value)\n-{\n-  unsigned char buf[sizeof (int) + 1];\n-  int len;\n-  if ((len = (*stream->read) (stream->physical, (char*)buf, 1)))\n-    {\n-      if ((buf[0] & _B_CODE) == _B_SINT)\n-\t(*value) = (buf[0] & _B_VALUE);\n-\n-      else\n-\t{\n-\t  int pos = 1;\n-\t  int nbytes = buf[0] & _B_NUMBER;\n-\t  if (nbytes > (int) sizeof (int))\n-\t    _objc_abort (\"expected int, got bigger\");\n-\t  len = (*stream->read) (stream->physical, (char*)buf + 1, nbytes);\n-\t  (*value) = 0;\n-\t  while (pos <= nbytes)\n-\t    (*value) = ((*value)*0x100) + buf[pos++];\n-\t  if (buf[0] & _B_SIGN)\n-\t    (*value) = -(*value);\n-\t}\n-    }\n-  return len;\n-}\n-\n-int\n-objc_read_long (struct objc_typed_stream *stream, long *value)\n-{\n-  unsigned char buf[sizeof (long) + 1];\n-  int len;\n-  if ((len = (*stream->read) (stream->physical, (char*)buf, 1)))\n-    {\n-      if ((buf[0] & _B_CODE) == _B_SINT)\n-\t(*value) = (buf[0] & _B_VALUE);\n-\n-      else\n-\t{\n-\t  int pos = 1;\n-\t  int nbytes = buf[0] & _B_NUMBER;\n-\t  if (nbytes > (int) sizeof (long))\n-\t    _objc_abort (\"expected long, got bigger\");\n-\t  len = (*stream->read) (stream->physical, (char*)buf + 1, nbytes);\n-\t  (*value) = 0;\n-\t  while (pos <= nbytes)\n-\t    (*value) = ((*value)*0x100) + buf[pos++];\n-\t  if (buf[0] & _B_SIGN)\n-\t    (*value) = -(*value);\n-\t}\n-    }\n-  return len;\n-}\n-\n-int\n-__objc_read_nbyte_uint (struct objc_typed_stream *stream,\n-\t\t\tunsigned int nbytes, unsigned int *val)\n-{\n-  int len;\n-  unsigned int pos = 0;\n-  unsigned char buf[sizeof (unsigned int) + 1];\n-\n-  if (nbytes > sizeof (int))\n-    _objc_abort (\"expected int, got bigger\");\n-\n-  len = (*stream->read) (stream->physical, (char*)buf, nbytes);\n-  (*val) = 0;\n-  while (pos < nbytes)\n-    (*val) = ((*val)*0x100) + buf[pos++];\n-  return len;\n-}\n-  \n-\n-int\n-objc_read_unsigned_int (struct objc_typed_stream *stream,\n-\t\t\tunsigned int *value)\n-{\n-  unsigned char buf[sizeof (unsigned int) + 1];\n-  int len;\n-  if ((len = (*stream->read) (stream->physical, (char*)buf, 1)))\n-    {\n-      if ((buf[0] & _B_CODE) == _B_SINT)\n-\t(*value) = (buf[0] & _B_VALUE);\n-\n-      else\n-\tlen = __objc_read_nbyte_uint (stream, (buf[0] & _B_VALUE), value);\n-\n-    }\n-  return len;\n-}\n-\n-int\n-__objc_read_nbyte_ulong (struct objc_typed_stream *stream,\n-\t\t       unsigned int nbytes, unsigned long *val)\n-{\n-  int len;\n-  unsigned int pos = 0;\n-  unsigned char buf[sizeof (unsigned long) + 1];\n-\n-  if (nbytes > sizeof (long))\n-    _objc_abort (\"expected long, got bigger\");\n-\n-  len = (*stream->read) (stream->physical, (char*)buf, nbytes);\n-  (*val) = 0;\n-  while (pos < nbytes)\n-    (*val) = ((*val)*0x100) + buf[pos++];\n-  return len;\n-}\n-  \n-\n-int\n-objc_read_unsigned_long (struct objc_typed_stream *stream,\n-\t\t\t unsigned long *value)\n-{\n-  unsigned char buf[sizeof (unsigned long) + 1];\n-  int len;\n-  if ((len = (*stream->read) (stream->physical, (char*)buf, 1)))\n-    {\n-      if ((buf[0] & _B_CODE) == _B_SINT)\n-\t(*value) = (buf[0] & _B_VALUE);\n-\n-      else\n-\tlen = __objc_read_nbyte_ulong (stream, (buf[0] & _B_VALUE), value);\n-\n-    }\n-  return len;\n-}\n-\n-int\n-objc_read_string (struct objc_typed_stream *stream,\n-\t\t  char **string)\n-{\n-  unsigned char buf[sizeof (unsigned int) + 1];\n-  int len;\n-  if ((len = (*stream->read) (stream->physical, (char*)buf, 1)))\n-    {\n-      unsigned long key = 0;\n-\n-      if ((buf[0]&_B_CODE) == _B_RCOMM)\t/* register following */\n-\t{\n-\t  len = __objc_read_nbyte_ulong (stream, (buf[0] & _B_VALUE), &key);\n-\t  len = (*stream->read) (stream->physical, (char*)buf, 1);\n-\t}\n-\n-      switch (buf[0]&_B_CODE) {\n-      case _B_SSTR:\n-\t{\n-\t  int length = buf[0]&_B_VALUE;\n-\t  (*string) = (char*)objc_malloc (length + 1);\n-\t  if (key)\n-\t    objc_hash_add (&stream->stream_table, LONG2PTR(key), *string);\n-\t  len = (*stream->read) (stream->physical, *string, length);\n-\t  (*string)[length] = '\\0';\n-\t}\n-\tbreak;\n-\n-      case _B_UCOMM:\n-\t{\n-\t  char *tmp;\n-\t  len = __objc_read_nbyte_ulong (stream, (buf[0] & _B_VALUE), &key);\n-\t  tmp = objc_hash_value_for_key (stream->stream_table, LONG2PTR (key));\n-\t  *string = objc_malloc (strlen (tmp) + 1);\n-\t  strcpy (*string, tmp);\n-\t}\n-\tbreak;\n-\n-      case _B_NSTR:\n-\t{\n-\t  unsigned int nbytes = buf[0]&_B_VALUE;\n-\t  len = __objc_read_nbyte_uint (stream, nbytes, &nbytes);\n-\t  if (len) {\n-\t    (*string) = (char*)objc_malloc (nbytes + 1);\n-\t    if (key)\n-\t      objc_hash_add (&stream->stream_table, LONG2PTR(key), *string);\n-\t    len = (*stream->read) (stream->physical, *string, nbytes);\n-\t    (*string)[nbytes] = '\\0';\n-\t  }\n-\t}\n-\tbreak;\n-\t\n-      default:\n-\t_objc_abort (\"expected string, got opcode %c\\n\", (buf[0]&_B_CODE));\n-      }\n-    }\n-\n-  return len;\n-}\n-\n-\n-int\n-objc_read_object (struct objc_typed_stream *stream, id *object)\n-{\n-  unsigned char buf[sizeof (unsigned int)];\n-  int len;\n-  if ((len = (*stream->read) (stream->physical, (char*)buf, 1)))\n-    {\n-      SEL read_sel = sel_get_any_uid (\"read:\");\n-      unsigned long key = 0;\n-\n-      if ((buf[0]&_B_CODE) == _B_RCOMM)\t/* register common */\n-\t{\n-\t  len = __objc_read_nbyte_ulong (stream, (buf[0] & _B_VALUE), &key);\n-\t  len = (*stream->read) (stream->physical, (char*)buf, 1);\n-\t}\n-\n-      if (buf[0] == (_B_EXT | _BX_OBJECT))\n-\t{\n-\t  Class class;\n-\n-\t  /* get class */\n-\t  len = objc_read_class (stream, &class);\n-\n-\t  /* create instance */\n-\t  (*object) = class_create_instance (class);\n-\n-\t  /* register? */\n-\t  if (key)\n-\t    objc_hash_add (&stream->object_table, LONG2PTR(key), *object);\n-\n-\t  /* send -read: */\n-\t  if (__objc_responds_to (*object, read_sel))\n-\t    (*get_imp (class, read_sel)) (*object, read_sel, stream);\n-\n-\t  /* check null-byte */\n-\t  len = (*stream->read) (stream->physical, (char*)buf, 1);\n-\t  if (buf[0] != '\\0')\n-\t    _objc_abort (\"expected null-byte, got opcode %c\", buf[0]);\n-\t}\n-\n-      else if ((buf[0]&_B_CODE) == _B_UCOMM)\n-\t{\n-\t  if (key)\n-\t    _objc_abort (\"cannot register use upcode...\");\n-\t  len = __objc_read_nbyte_ulong (stream, (buf[0] & _B_VALUE), &key);\n-\t  (*object) = objc_hash_value_for_key (stream->object_table,\n-\t\t\t\t\t       LONG2PTR(key));\n-\t}\n-\n-      else if (buf[0] == (_B_EXT | _BX_OBJREF))\t/* a forward reference */\n-\t{\n-\t  struct objc_list *other;\n-\t  len = objc_read_unsigned_long (stream, &key);\n-\t  other \n-\t    = (struct objc_list *) objc_hash_value_for_key (stream->object_refs, \n-\t\t\t\t\t\t\t   LONG2PTR(key));\n-\t  objc_hash_add (&stream->object_refs, LONG2PTR(key), \n-\t\t\t (void *)list_cons (object, other));\n-\t}\n-\n-      else if (buf[0] == (_B_EXT | _BX_OBJROOT)) /* a root object */\n-\t{\n-\t  if (key)\n-\t    _objc_abort (\"cannot register root object...\");\n-\t  len = objc_read_object (stream, object);\n-\t  __objc_finish_read_root_object (stream);\n-\t}\n-\n-      else\n-\t_objc_abort (\"expected object, got opcode %c\", buf[0]);\n-    }\n-  return len;\n-}\n-\n-static int\n-objc_read_class (struct objc_typed_stream *stream, Class *class)\n-{\n-  unsigned char buf[sizeof (unsigned int)];\n-  int len;\n-  if ((len = (*stream->read) (stream->physical, (char*)buf, 1)))\n-    {\n-      unsigned long key = 0;\n-\n-      if ((buf[0]&_B_CODE) == _B_RCOMM)\t/* register following */\n-\t{\n-\t  len = __objc_read_nbyte_ulong (stream, (buf[0] & _B_VALUE), &key);\n-\t  len = (*stream->read) (stream->physical, (char*)buf, 1);\n-\t}\n-\n-      if (buf[0] == (_B_EXT | _BX_CLASS))\n-\t{\n-\t  char temp[1] = \"\";\n-\t  char *class_name = temp;\n-\t  unsigned long version;\n-\n-\t  /* get class */\n-\t  len = objc_read_string (stream, &class_name);\n-\t  (*class) = objc_get_class (class_name);\n-\t  objc_free (class_name);\n-\n-\t  /* register */\n-\t  if (key)\n-\t    objc_hash_add (&stream->stream_table, LONG2PTR(key), *class);\n-\n-\t  objc_read_unsigned_long (stream, &version);\n-\t  objc_hash_add (&stream->class_table,\n-\t\t\t (*class)->name, (void *) ((size_t) version));\n-\t}\n-\n-      else if ((buf[0]&_B_CODE) == _B_UCOMM)\n-\t{\n-\t  if (key)\n-\t    _objc_abort (\"cannot register use upcode...\");\n-\t  len = __objc_read_nbyte_ulong (stream, (buf[0] & _B_VALUE), &key);\n-\t  *class = objc_hash_value_for_key (stream->stream_table,\n-\t\t\t\t\t    LONG2PTR(key));\n-\t  if (! *class)\n-\t    _objc_abort (\"cannot find class for key %lu\", key);\n-\t}\n-\n-      else\n-\t_objc_abort (\"expected class, got opcode %c\", buf[0]);\n-    }\n-  return len;\n-}\n-\n-int\n-objc_read_selector (struct objc_typed_stream *stream, SEL* selector)\n-{\n-  unsigned char buf[sizeof (unsigned int)];\n-  int len;\n-  if ((len = (*stream->read) (stream->physical, (char*)buf, 1)))\n-    {\n-      unsigned long key = 0;\n-\n-      if ((buf[0]&_B_CODE) == _B_RCOMM)\t/* register following */\n-\t{\n-\t  len = __objc_read_nbyte_ulong (stream, (buf[0] & _B_VALUE), &key);\n-\t  len = (*stream->read) (stream->physical, (char*)buf, 1);\n-\t}\n-\n-      if (buf[0] == (_B_EXT|_BX_SEL)) /* selector! */\n-\t{\n-\t  char temp[1] = \"\";\n-\t  char *selector_name = temp;\n-\n-\t  /* get selector */\n-\t  len = objc_read_string (stream, &selector_name);\n-\t  /* To handle NULL selectors */\n-\t  if (0 == strlen (selector_name))\n-\t    {\n-\t      (*selector) = (SEL)0;\n-\t      return 0;\n-\t    }\n-\t  else \n-\t    (*selector) = sel_get_any_uid (selector_name);\n-\t  objc_free (selector_name);\n-\n-\t  /* register */\n-\t  if (key)\n-\t    objc_hash_add (&stream->stream_table,\n-\t\t\t   LONG2PTR(key), (void *) *selector);\n-\t}\n-\n-      else if ((buf[0]&_B_CODE) == _B_UCOMM)\n-\t{\n-\t  if (key)\n-\t    _objc_abort (\"cannot register use upcode...\");\n-\t  len = __objc_read_nbyte_ulong (stream, (buf[0] & _B_VALUE), &key);\n-\t  (*selector) = objc_hash_value_for_key (stream->stream_table, \n-\t\t\t\t\t\t LONG2PTR(key));\n-\t}\n-\n-      else\n-\t_objc_abort (\"expected selector, got opcode %c\", buf[0]);\n-    }\n-  return len;\n-}\n-\n-/*\n-** USER LEVEL FUNCTIONS\n-*/\n-\n-/*\n-** Write one object, encoded in TYPE and pointed to by DATA to the\n-** typed stream STREAM.  \n-*/\n-\n-int\n-objc_write_type (TypedStream *stream, const char *type, const void *data)\n-{\n-  switch (*type) {\n-  case _C_ID:\n-    return objc_write_object (stream, *(id *) data);\n-    break;\n-\n-  case _C_CLASS:\n-    return objc_write_class (stream, *(Class *) data);\n-    break;\n-\n-  case _C_SEL:\n-    return objc_write_selector (stream, *(SEL *) data);\n-    break;\n-\n-  case _C_CHR:\n-    return objc_write_char (stream, *(signed char *) data);\n-    break;\n-    \n-  case _C_UCHR:\n-    return objc_write_unsigned_char (stream, *(unsigned char *) data);\n-    break;\n-\n-  case _C_SHT:\n-    return objc_write_short (stream, *(short *) data);\n-    break;\n-\n-  case _C_USHT:\n-    return objc_write_unsigned_short (stream, *(unsigned short *) data);\n-    break;\n-\n-  case _C_INT:\n-    return objc_write_int (stream, *(int *) data);\n-    break;\n-\n-  case _C_UINT:\n-    return objc_write_unsigned_int (stream, *(unsigned int *) data);\n-    break;\n-\n-  case _C_LNG:\n-    return objc_write_long (stream, *(long *) data);\n-    break;\n-\n-  case _C_ULNG:\n-    return objc_write_unsigned_long (stream, *(unsigned long *) data);\n-    break;\n-\n-  case _C_CHARPTR:\n-    return objc_write_string (stream,\n-\t\t\t      *(unsigned char **) data, strlen (*(char **) data));\n-    break;\n-\n-  case _C_ATOM:\n-    return objc_write_string_atomic (stream, *(unsigned char **) data, \n-\t\t\t\t     strlen (*(char **) data));\n-    break;\n-\n-  case _C_ARY_B:\n-    {\n-      int len = atoi (type + 1);\n-      while (isdigit ((unsigned char) *++type))\n-\t;\n-      return objc_write_array (stream, type, len, data);\n-    }\n-    break; \n-\n-  case _C_STRUCT_B:\n-    {\n-      int acc_size = 0;\n-      int align;\n-      while (*type != _C_STRUCT_E && *type++ != '=')\n-\t; /* skip \"<name>=\" */\n-      while (*type != _C_STRUCT_E)\n-\t{\n-\t  align = objc_alignof_type (type);       /* padd to alignment */\n-\t  acc_size = ROUND (acc_size, align);\n-\t  objc_write_type (stream, type, ((char *) data) + acc_size);\n-\t  acc_size += objc_sizeof_type (type);   /* add component size */\n-\t  type = objc_skip_typespec (type);\t /* skip component */\n-\t}\n-      return 1;\n-    }\n-\n-  default:\n-    {\n-      _objc_abort (\"objc_write_type: cannot parse typespec: %s\\n\", type);\n-      return 0;\n-    }\n-  }\n-}\n-\n-/*\n-** Read one object, encoded in TYPE and pointed to by DATA to the\n-** typed stream STREAM.  DATA specifies the address of the types to\n-** read.  Expected type is checked against the type actually present\n-** on the stream. \n-*/\n-\n-int\n-objc_read_type(TypedStream *stream, const char *type, void *data)\n-{\n-  char c;\n-  switch (c = *type) {\n-  case _C_ID:\n-    return objc_read_object (stream, (id*)data);\n-    break;\n-\n-  case _C_CLASS:\n-    return objc_read_class (stream, (Class*)data);\n-    break;\n-\n-  case _C_SEL:\n-    return objc_read_selector (stream, (SEL*)data);\n-    break;\n-\n-  case _C_CHR:\n-    return objc_read_char (stream, (char*)data);\n-    break;\n-    \n-  case _C_UCHR:\n-    return objc_read_unsigned_char (stream, (unsigned char*)data);\n-    break;\n-\n-  case _C_SHT:\n-    return objc_read_short (stream, (short*)data);\n-    break;\n-\n-  case _C_USHT:\n-    return objc_read_unsigned_short (stream, (unsigned short*)data);\n-    break;\n-\n-  case _C_INT:\n-    return objc_read_int (stream, (int*)data);\n-    break;\n-\n-  case _C_UINT:\n-    return objc_read_unsigned_int (stream, (unsigned int*)data);\n-    break;\n-\n-  case _C_LNG:\n-    return objc_read_long (stream, (long*)data);\n-    break;\n-\n-  case _C_ULNG:\n-    return objc_read_unsigned_long (stream, (unsigned long*)data);\n-    break;\n-\n-  case _C_CHARPTR:\n-  case _C_ATOM:\n-    return objc_read_string (stream, (char**)data);\n-    break;\n-\n-  case _C_ARY_B:\n-    {\n-      int len = atoi (type + 1);\n-      while (isdigit ((unsigned char) *++type))\n-\t;\n-      return objc_read_array (stream, type, len, data);\n-    }\n-    break; \n-\n-  case _C_STRUCT_B:\n-    {\n-      int acc_size = 0;\n-      int align;\n-      while (*type != _C_STRUCT_E && *type++ != '=')\n-\t; /* skip \"<name>=\" */\n-      while (*type != _C_STRUCT_E)\n-\t{\n-\t  align = objc_alignof_type (type);       /* padd to alignment */\n-\t  acc_size = ROUND (acc_size, align);\n-\t  objc_read_type (stream, type, ((char*)data)+acc_size);\n-\t  acc_size += objc_sizeof_type (type);   /* add component size */\n-\t  type = objc_skip_typespec (type);\t /* skip component */\n-\t}\n-      return 1;\n-    }\n-\n-  default:\n-    {\n-      _objc_abort (\"objc_read_type: cannot parse typespec: %s\\n\", type);\n-      return 0;\n-    }\n-  }\n-}\n-\n-/*\n-** Write the object specified by the template TYPE to STREAM.  Last\n-** arguments specify addresses of values to be written.  It might \n-** seem surprising to specify values by address, but this is extremely\n-** convenient for copy-paste with objc_read_types calls.  A more\n-** down-to-the-earth cause for this passing of addresses is that values\n-** of arbitrary size is not well supported in ANSI C for functions with\n-** variable number of arguments.\n-*/\n-\n-int \n-objc_write_types (TypedStream *stream, const char *type, ...)\n-{\n-  va_list args;\n-  const char *c;\n-  int res = 0;\n-\n-  va_start(args, type);\n-\n-  for (c = type; *c; c = objc_skip_typespec (c))\n-    {\n-      switch (*c) {\n-      case _C_ID:\n-\tres = objc_write_object (stream, *va_arg (args, id*));\n-\tbreak;\n-\n-      case _C_CLASS:\n-\tres = objc_write_class (stream, *va_arg (args, Class*));\n-\tbreak;\n-\n-      case _C_SEL:\n-\tres = objc_write_selector (stream, *va_arg (args, SEL*));\n-\tbreak;\n-\t\n-      case _C_CHR:\n-\tres = objc_write_char (stream, *va_arg (args, char*));\n-\tbreak;\n-\t\n-      case _C_UCHR:\n-\tres = objc_write_unsigned_char (stream,\n-\t\t\t\t\t*va_arg (args, unsigned char*));\n-\tbreak;\n-\t\n-      case _C_SHT:\n-\tres = objc_write_short (stream, *va_arg (args, short*));\n-\tbreak;\n-\n-      case _C_USHT:\n-\tres = objc_write_unsigned_short (stream,\n-\t\t\t\t\t *va_arg (args, unsigned short*));\n-\tbreak;\n-\n-      case _C_INT:\n-\tres = objc_write_int(stream, *va_arg (args, int*));\n-\tbreak;\n-\t\n-      case _C_UINT:\n-\tres = objc_write_unsigned_int(stream, *va_arg (args, unsigned int*));\n-\tbreak;\n-\n-      case _C_LNG:\n-\tres = objc_write_long(stream, *va_arg (args, long*));\n-\tbreak;\n-\t\n-      case _C_ULNG:\n-\tres = objc_write_unsigned_long(stream, *va_arg (args, unsigned long*));\n-\tbreak;\n-\n-      case _C_CHARPTR:\n-\t{\n-\t  unsigned char **str = va_arg (args, unsigned char **);\n-\t  res = objc_write_string (stream, *str, strlen ((char*)*str));\n-\t}\n-\tbreak;\n-\n-      case _C_ATOM:\n-\t{\n-\t  unsigned char **str = va_arg (args, unsigned char **);\n-\t  res = objc_write_string_atomic (stream, *str, strlen ((char*)*str));\n-\t}\n-\tbreak;\n-\n-      case _C_ARY_B:\n-\t{\n-\t  int len = atoi (c + 1);\n-\t  const char *t = c;\n-\t  while (isdigit ((unsigned char) *++t))\n-\t    ;\n-\t  res = objc_write_array (stream, t, len, va_arg (args, void *));\n-\t  t = objc_skip_typespec (t);\n-\t  if (*t != _C_ARY_E)\n-\t    _objc_abort (\"expected `]', got: %s\", t);\n-\t}\n-\tbreak; \n-\t\n-      default:\n-\t_objc_abort (\"objc_write_types: cannot parse typespec: %s\\n\", type);\n-      }\n-    }\n-  va_end(args);\n-  return res;\n-}\n-\n-\n-/* \n-** Last arguments specify addresses of values to be read.  Expected\n-** type is checked against the type actually present on the stream. \n-*/\n-\n-int \n-objc_read_types(TypedStream *stream, const char *type, ...)\n-{\n-  va_list args;\n-  const char *c;\n-  int res = 0;\n-\n-  va_start (args, type);\n-\n-  for (c = type; *c; c = objc_skip_typespec(c))\n-    {\n-      switch (*c) {\n-      case _C_ID:\n-\tres = objc_read_object(stream, va_arg (args, id*));\n-\tbreak;\n-\n-      case _C_CLASS:\n-\tres = objc_read_class(stream, va_arg (args, Class*));\n-\tbreak;\n-\n-      case _C_SEL:\n-\tres = objc_read_selector(stream, va_arg (args, SEL*));\n-\tbreak;\n-\t\n-      case _C_CHR:\n-\tres = objc_read_char(stream, va_arg (args, char*));\n-\tbreak;\n-\t\n-      case _C_UCHR:\n-\tres = objc_read_unsigned_char(stream, va_arg (args, unsigned char*));\n-\tbreak;\n-\t\n-      case _C_SHT:\n-\tres = objc_read_short(stream, va_arg (args, short*));\n-\tbreak;\n-\n-      case _C_USHT:\n-\tres = objc_read_unsigned_short(stream, va_arg (args, unsigned short*));\n-\tbreak;\n-\n-      case _C_INT:\n-\tres = objc_read_int(stream, va_arg (args, int*));\n-\tbreak;\n-\t\n-      case _C_UINT:\n-\tres = objc_read_unsigned_int(stream, va_arg (args, unsigned int*));\n-\tbreak;\n-\n-      case _C_LNG:\n-\tres = objc_read_long(stream, va_arg (args, long*));\n-\tbreak;\n-\t\n-      case _C_ULNG:\n-\tres = objc_read_unsigned_long(stream, va_arg (args, unsigned long*));\n-\tbreak;\n-\n-      case _C_CHARPTR:\n-      case _C_ATOM:\n-\t{\n-\t  char **str = va_arg (args, char **);\n-\t  res = objc_read_string (stream, str);\n-\t}\n-\tbreak;\n-\n-      case _C_ARY_B:\n-\t{\n-\t  int len = atoi (c + 1);\n-\t  const char *t = c;\n-\t  while (isdigit ((unsigned char) *++t))\n-\t    ;\n-\t  res = objc_read_array (stream, t, len, va_arg (args, void *));\n-\t  t = objc_skip_typespec (t);\n-\t  if (*t != _C_ARY_E)\n-\t    _objc_abort (\"expected `]', got: %s\", t);\n-\t}\n-\tbreak; \n-\t\n-      default:\n-\t_objc_abort (\"objc_read_types: cannot parse typespec: %s\\n\", type);\n-      }\n-    }\n-  va_end (args);\n-  return res;\n-}\n-\n-/*\n-** Write an array of COUNT elements of TYPE from the memory address DATA.\n-** This is equivalent of objc_write_type (stream, \"[N<type>]\", data)\n-*/\n-\n-int\n-objc_write_array (TypedStream *stream, const char *type,\n-\t\t  int count, const void *data)\n-{\n-  int off = objc_sizeof_type(type);\n-  const char *where = data;\n-\n-  while (count-- > 0)\n-    {\n-      objc_write_type(stream, type, where);\n-      where += off;\n-    }\n-  return 1;\n-}\n-\n-/*\n-** Read an array of COUNT elements of TYPE into the memory address\n-** DATA.  The memory pointed to by data is supposed to be allocated\n-** by the callee.  This is equivalent of \n-**   objc_read_type (stream, \"[N<type>]\", data)\n-*/\n-\n-int\n-objc_read_array (TypedStream *stream, const char *type,\n-\t\t int count, void *data)\n-{\n-  int off = objc_sizeof_type(type);\n-  char *where = (char*)data;\n-\n-  while (count-- > 0)\n-    {\n-      objc_read_type(stream, type, where);\n-      where += off;\n-    }\n-  return 1;\n-}\n-\n-static int \n-__objc_fread (FILE *file, char *data, int len)\n-{\n-  return fread(data, len, 1, file);\n-}\n-\n-static int \n-__objc_fwrite (FILE *file, char *data, int len)\n-{\n-  return fwrite(data, len, 1, file);\n-}\n-\n-static int\n-__objc_feof (FILE *file)\n-{\n-  return feof(file);\n-}\n-\n-static int \n-__objc_no_write (FILE *file __attribute__ ((__unused__)),\n-\t\t const char *data __attribute__ ((__unused__)),\n-\t\t int len __attribute__ ((__unused__)))\n-{\n-  _objc_abort (\"TypedStream not open for writing\");\n-  return 0;\n-}\n-\n-static int \n-__objc_no_read (FILE *file __attribute__ ((__unused__)),\n-\t\tconst char *data __attribute__ ((__unused__)),\n-\t\tint len __attribute__ ((__unused__)))\n-{\n-  _objc_abort (\"TypedStream not open for reading\");\n-  return 0;\n-}\n-\n-static int\n-__objc_read_typed_stream_signature (TypedStream *stream)\n-{\n-  char buffer[80];\n-  int pos = 0;\n-  do\n-    (*stream->read) (stream->physical, buffer+pos, 1);\n-  while (buffer[pos++] != '\\0')\n-    ;\n-  sscanf (buffer, \"GNU TypedStream %d\", &stream->version);\n-  if (stream->version != OBJC_TYPED_STREAM_VERSION)\n-    _objc_abort (\"cannot handle TypedStream version %d\", stream->version);\n-  return 1;\n-}\n-\n-static int\n-__objc_write_typed_stream_signature (TypedStream *stream)\n-{\n-  char buffer[80];\n-  sprintf(buffer, \"GNU TypedStream %d\", OBJC_TYPED_STREAM_VERSION);\n-  stream->version = OBJC_TYPED_STREAM_VERSION;\n-  (*stream->write) (stream->physical, buffer, strlen (buffer) + 1);\n-  return 1;\n-}\n-\n-static void __objc_finish_write_root_object(struct objc_typed_stream *stream)\n-{\n-  objc_hash_delete (stream->object_table);\n-  stream->object_table = objc_hash_new (64,\n-\t\t\t\t\t(hash_func_type) objc_hash_ptr,\n-\t\t\t\t\t(compare_func_type) objc_compare_ptrs);\n-}\n-\n-static void __objc_finish_read_root_object(struct objc_typed_stream *stream)\n-{\n-  node_ptr node;\n-  SEL awake_sel = sel_get_any_uid (\"awake\");\n-  cache_ptr free_list = objc_hash_new (64,\n-\t\t\t\t       (hash_func_type) objc_hash_ptr,\n-\t\t\t\t       (compare_func_type) objc_compare_ptrs);\n-\n-  /* resolve object forward references */\n-  for (node = objc_hash_next (stream->object_refs, NULL); node;\n-       node = objc_hash_next (stream->object_refs, node))\n-    {\n-      struct objc_list *reflist = node->value;\n-      const void *key = node->key;\n-      id object = objc_hash_value_for_key (stream->object_table, key);\n-      while (reflist)\n-\t{\n-\t  *((id*) reflist->head) = object;\n-\t  if (objc_hash_value_for_key (free_list,reflist) == NULL)\n-\t    objc_hash_add (&free_list,reflist,reflist);\n-\n-\t  reflist = reflist->tail;\n-\t}\n-    }\n-    \n-  /* apply __objc_free to all objects stored in free_list */\n-  for (node = objc_hash_next (free_list, NULL); node;\n-       node = objc_hash_next (free_list, node))\n-    objc_free ((void *) node->key);\n-\n-  objc_hash_delete (free_list);\n-\n-  /* empty object reference table */\n-  objc_hash_delete (stream->object_refs);\n-  stream->object_refs = objc_hash_new (8, (hash_func_type) objc_hash_ptr,\n-\t\t\t\t       (compare_func_type) objc_compare_ptrs);\n-  \n-  /* call -awake for all objects read  */\n-  if (awake_sel)\n-    {\n-      for (node = objc_hash_next (stream->object_table, NULL); node;\n-\t   node = objc_hash_next (stream->object_table, node))\n-\t{\n-\t  id object = node->value;\n-\t  if (__objc_responds_to (object, awake_sel))\n-\t    (*objc_msg_lookup (object, awake_sel)) (object, awake_sel);\n-\t}\n-    }\n-\n-  /* empty object table */\n-  objc_hash_delete (stream->object_table);\n-  stream->object_table = objc_hash_new(64,\n-\t\t\t\t       (hash_func_type)objc_hash_ptr,\n-\t\t\t\t       (compare_func_type)objc_compare_ptrs);\n-}\n-\n-/*\n-** Open the stream PHYSICAL in MODE\n-*/\n-\n-TypedStream *\n-objc_open_typed_stream (FILE *physical, int mode)\n-{\n-  TypedStream *s = (TypedStream *) objc_malloc (sizeof (TypedStream));\n-\n-  s->mode = mode;\n-  s->physical = physical;\n-  s->stream_table = objc_hash_new (64,\n-\t\t\t\t   (hash_func_type) objc_hash_ptr,\n-\t\t\t\t   (compare_func_type) objc_compare_ptrs);\n-  s->object_table = objc_hash_new (64,\n-\t\t\t\t   (hash_func_type) objc_hash_ptr,\n-\t\t\t\t   (compare_func_type) objc_compare_ptrs);\n-  s->eof = (objc_typed_eof_func) __objc_feof;\n-  s->flush = (objc_typed_flush_func) fflush;\n-  s->writing_root_p = 0;\n-  if (mode == OBJC_READONLY)\n-    {\n-      s->class_table \n-\t= objc_hash_new (8, (hash_func_type) objc_hash_string,\n-\t\t\t (compare_func_type) objc_compare_strings);\n-      s->object_refs = objc_hash_new (8, (hash_func_type) objc_hash_ptr,\n-\t\t\t\t      (compare_func_type) objc_compare_ptrs);\n-      s->read = (objc_typed_read_func) __objc_fread;\n-      s->write = (objc_typed_write_func) __objc_no_write;\n-      __objc_read_typed_stream_signature (s);\n-    }\n-  else if (mode == OBJC_WRITEONLY)\n-    {\n-      s->class_table = 0;\n-      s->object_refs = 0;\n-      s->read = (objc_typed_read_func) __objc_no_read;\n-      s->write = (objc_typed_write_func) __objc_fwrite;\n-      __objc_write_typed_stream_signature (s);\n-    }      \n-  else\n-    {\n-      objc_close_typed_stream (s);\n-      return NULL;\n-    }\n-  s->type = OBJC_FILE_STREAM;\n-  return s;\n-}\n-\n-/*\n-** Open the file named by FILE_NAME in MODE\n-*/\n-\n-TypedStream*\n-objc_open_typed_stream_for_file (const char *file_name, int mode)\n-{\n-  FILE *file = NULL;\n-  TypedStream *s;\n-\n-  if (mode == OBJC_READONLY)\n-    file = fopen (file_name, \"r\");\n-  else\n-    file = fopen (file_name, \"w\");\n-\n-  if (file)\n-    {\n-      s = objc_open_typed_stream (file, mode);\n-      if (s)\n-\ts->type |= OBJC_MANAGED_STREAM;\n-      return s;\n-    }\n-  else\n-    return NULL;\n-}\n-\n-/*\n-** Close STREAM freeing the structure it self.  If it was opened with \n-** objc_open_typed_stream_for_file, the file will also be closed.\n-*/\n-\n-void\n-objc_close_typed_stream (TypedStream *stream)\n-{\n-  if (stream->mode == OBJC_READONLY)\n-    {\n-      __objc_finish_read_root_object (stream); /* Just in case... */\n-      objc_hash_delete (stream->class_table);\n-      objc_hash_delete (stream->object_refs);\n-    }\n-\n-  objc_hash_delete (stream->stream_table);\n-  objc_hash_delete (stream->object_table);\n-\n-  if (stream->type == (OBJC_MANAGED_STREAM | OBJC_FILE_STREAM))\n-    fclose ((FILE *)stream->physical);\n-\n-  objc_free(stream);\n-}\n-\n-BOOL\n-objc_end_of_typed_stream (TypedStream *stream)\n-{\n-  return (*stream->eof) (stream->physical);\n-}\n-\n-void\n-objc_flush_typed_stream (TypedStream *stream)\n-{\n-  (*stream->flush) (stream->physical);\n-}\n-\n-long\n-objc_get_stream_class_version (TypedStream *stream, Class class)\n-{\n-  if (stream->class_table)\n-    return PTR2LONG(objc_hash_value_for_key (stream->class_table,\n-\t\t\t\t\t     class->name));\n-  else\n-    return class_get_version (class);\n-}\n-"}, {"sha": "f66d366b156e9354c6a1c98b42ce56d53f835053", "filename": "libobjc/libobjc.def", "status": "modified", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efad6bee02afab785421883079fe2817d636a69b/libobjc%2Flibobjc.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efad6bee02afab785421883079fe2817d636a69b/libobjc%2Flibobjc.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Flibobjc.def?ref=efad6bee02afab785421883079fe2817d636a69b", "patch": "@@ -85,48 +85,6 @@ objc_skip_argspec\n objc_skip_offset\n objc_skip_type_qualifiers\n objc_skip_typespec\n-__objc_read_nbyte_uint\n-__objc_read_nbyte_ulong\n-__objc_write_class\n-__objc_write_object\n-__objc_write_selector\n-objc_close_typed_stream\n-objc_end_of_typed_stream\n-objc_flush_typed_stream\n-objc_get_stream_class_version\n-objc_open_typed_stream\n-objc_open_typed_stream_for_file\n-objc_read_array\n-objc_read_char\n-objc_read_int\n-objc_read_long\n-objc_read_object\n-objc_read_selector\n-objc_read_short\n-objc_read_string\n-objc_read_type\n-objc_read_types\n-objc_read_unsigned_char\n-objc_read_unsigned_int\n-objc_read_unsigned_long\n-objc_read_unsigned_short\n-objc_write_array\n-objc_write_char\n-objc_write_int\n-objc_write_long\n-objc_write_object\n-objc_write_object_reference\n-objc_write_root_object\n-objc_write_selector\n-objc_write_short\n-objc_write_string\n-objc_write_string_atomic\n-objc_write_type\n-objc_write_types\n-objc_write_unsigned_char\n-objc_write_unsigned_int\n-objc_write_unsigned_long\n-objc_write_unsigned_short\n __objc_exec_class\n __objc_init_dispatch_tables\n __objc_install_premature_dtable"}, {"sha": "684a008643dceb6d49a8c7c1db94e79cc876e338", "filename": "libobjc/objc/Object.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efad6bee02afab785421883079fe2817d636a69b/libobjc%2Fobjc%2FObject.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efad6bee02afab785421883079fe2817d636a69b/libobjc%2Fobjc%2FObject.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fobjc%2FObject.h?ref=efad6bee02afab785421883079fe2817d636a69b", "patch": "@@ -58,7 +58,6 @@ extern \"C\" {\n /* All of the following includes were deprecated in GCC 4.6 and will\n    be removed in the next release.  */\n #include \"deprecated/hash.h\"\n-#include \"deprecated/typedstream.h\"\n #include \"deprecated/Object.h\"\n \n #ifdef __cplusplus"}, {"sha": "91b9a86d06ef084bc827e963f4cfb6ca0fb93ad4", "filename": "libobjc/objc/deprecated/Object.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efad6bee02afab785421883079fe2817d636a69b/libobjc%2Fobjc%2Fdeprecated%2FObject.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efad6bee02afab785421883079fe2817d636a69b/libobjc%2Fobjc%2Fdeprecated%2FObject.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fobjc%2Fdeprecated%2FObject.h?ref=efad6bee02afab785421883079fe2817d636a69b", "patch": "@@ -60,11 +60,5 @@\n + (int)version;\n + setVersion:(int)aVersion;\n \n-+ (int)streamVersion: (TypedStream*)aStream; /* __attribute__ ((deprecated)) */\n-\n-- read: (TypedStream*)aStream; /* __attribute__ ((deprecated)) */\n-- write: (TypedStream*)aStream; /* __attribute__ ((deprecated)) */\n-- awake; /* __attribute__ ((deprecated)) */\n-\n @end\n "}, {"sha": "4d948d5fb27971478b1423068f171b834cebc81e", "filename": "libobjc/objc/deprecated/typedstream.h", "status": "removed", "additions": 0, "deletions": 141, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4a8e3fd478292ebd3527dc232d64e65ab870e4/libobjc%2Fobjc%2Fdeprecated%2Ftypedstream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4a8e3fd478292ebd3527dc232d64e65ab870e4/libobjc%2Fobjc%2Fdeprecated%2Ftypedstream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fobjc%2Fdeprecated%2Ftypedstream.h?ref=ba4a8e3fd478292ebd3527dc232d64e65ab870e4", "patch": "@@ -1,141 +0,0 @@\n-/* GNU Objective-C Typed Streams interface.\n-   Copyright (C) 1993, 1995, 2004, 2009 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it\n-under the terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 3, or (at your option) any\n-later version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT\n-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-License for more details.\n-\n-Under Section 7 of GPL version 3, you are granted additional\n-permissions described in the GCC Runtime Library Exception, version\n-3.1, as published by the Free Software Foundation.\n-\n-You should have received a copy of the GNU General Public License and\n-a copy of the GCC Runtime Library Exception along with this program;\n-see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-<http://www.gnu.org/licenses/>.  */\n-\n-\n-#ifndef __typedstream_INCLUDE_GNU\n-#define __typedstream_INCLUDE_GNU\n-\n-/* The API in this file was entirely deprecated in GCC 4.6.0 and will\n-   be removed in the following GCC release.\n-*/\n-\n-#include <stdio.h>\n-\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif /* __cplusplus */\n-\n-typedef int (*objc_typed_read_func)(void*, char*, int);\n-typedef int (*objc_typed_write_func)(void*, const char*, int);\n-typedef int (*objc_typed_flush_func)(void*);\n-typedef int (*objc_typed_eof_func)(void*);\n-\n-#define OBJC_READONLY   0x01\n-#define OBJC_WRITEONLY  0x02\n-\n-#define OBJC_MANAGED_STREAM  0x01\n-#define OBJC_FILE_STREAM     0x02\n-#define OBJC_MEMORY_STREAM   0x04\n-\n-#define OBJC_TYPED_STREAM_VERSION 0x01\n-\n-typedef struct objc_typed_stream {\n-  void* physical;\n-  cache_ptr object_table;\t/* read/written objects */\n-  cache_ptr stream_table;\t/* other read/written but shared things.. */\n-  cache_ptr class_table;\t/* class version mapping */\n-  cache_ptr object_refs;\t/* forward references */\n-  int mode;\t\t\t/* OBJC_READONLY or OBJC_WRITEONLY */\n-  int type;\t\t\t/* MANAGED, FILE, MEMORY etc bit string */\n-  int version;\t\t\t/* version used when writing */\n-  int writing_root_p;\n-  objc_typed_read_func read;\n-  objc_typed_write_func write;\n-  objc_typed_eof_func eof;\n-  objc_typed_flush_func flush;\n-} TypedStream;\n-\n-/* opcode masks */\n-#define _B_VALUE   0x1fU\n-#define _B_CODE    0xe0U\n-#define _B_SIGN    0x10U\n-#define _B_NUMBER  0x0fU\n-\n-/* standard opcodes */\n-#define _B_INVALID 0x00U\n-#define _B_SINT    0x20U\n-#define _B_NINT    0x40U\n-#define _B_SSTR    0x60U\n-#define _B_NSTR    0x80U\n-#define _B_RCOMM   0xa0U\n-#define _B_UCOMM   0xc0U\n-#define _B_EXT     0xe0U\n-\n-/* eXtension opcodes */\n-#define _BX_OBJECT  0x00U\n-#define _BX_CLASS   0x01U\n-#define _BX_SEL     0x02U\n-#define _BX_OBJREF  0x03U\n-#define _BX_OBJROOT 0x04U\n-#define _BX_EXT     0x1fU\n-\n-/*\n-** Read and write objects as specified by TYPE.  All the `last'\n-** arguments are pointers to the objects to read/write.  \n-*/\n-\n-int objc_write_type (TypedStream* stream, const char* type, const void* data) __attribute__ ((deprecated));\n-int objc_read_type (TypedStream* stream, const char* type, void* data) __attribute__ ((deprecated));\n-\n-int objc_write_types (TypedStream* stream, const char* type, ...) __attribute__ ((deprecated));\n-int objc_read_types (TypedStream* stream, const char* type, ...) __attribute__ ((deprecated));\n-\n-int objc_write_object_reference (TypedStream* stream, id object) __attribute__ ((deprecated));\n-int objc_write_root_object (TypedStream* stream, id object) __attribute__ ((deprecated));\n-\n-long objc_get_stream_class_version (TypedStream* stream, Class class_type) __attribute__ ((deprecated));\n-\n-\n-/*\n-** Convenience functions\n-*/\n-\n-int objc_write_array (TypedStream* stream, const char* type,\n-\t\t      int count, const void* data) __attribute__ ((deprecated));\n-int objc_read_array (TypedStream* stream, const char* type,\n-\t\t     int count, void* data) __attribute__ ((deprecated));\n-\n-int objc_write_object (TypedStream* stream, id object) __attribute__ ((deprecated));\n-int objc_read_object (TypedStream* stream, id* object) __attribute__ ((deprecated));\n-\n-\n-\n-/*\n-** Open a typed stream for reading or writing.  MODE may be either of\n-** OBJC_READONLY or OBJC_WRITEONLY.  \n-*/\n-\n-TypedStream* objc_open_typed_stream (FILE* physical, int mode) __attribute__ ((deprecated));\n-TypedStream* objc_open_typed_stream_for_file (const char* file_name, int mode) __attribute__ ((deprecated));\n-\n-void objc_close_typed_stream (TypedStream* stream) __attribute__ ((deprecated));\n-\n-BOOL objc_end_of_typed_stream (TypedStream* stream) __attribute__ ((deprecated));\n-void objc_flush_typed_stream (TypedStream* stream) __attribute__ ((deprecated));\n-\n-#ifdef __cplusplus\n-}\n-#endif /* __cplusplus */\n-\n-#endif /* not __typedstream_INCLUDE_GNU */"}, {"sha": "a39c51b29dc5bd9efb6004a3dae5df9cae0154cc", "filename": "libobjc/objc/typedstream.h", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba4a8e3fd478292ebd3527dc232d64e65ab870e4/libobjc%2Fobjc%2Ftypedstream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba4a8e3fd478292ebd3527dc232d64e65ab870e4/libobjc%2Fobjc%2Ftypedstream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fobjc%2Ftypedstream.h?ref=ba4a8e3fd478292ebd3527dc232d64e65ab870e4", "patch": "@@ -1,4 +0,0 @@\n-#include \"objc.h\"\n-#include \"deprecated/hash.h\"\n-#include \"deprecated/typedstream.h\"\n-"}]}