{"sha": "165ca58dc37d9c10443e5cf1daa836edb355a0f0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTY1Y2E1OGRjMzdkOWMxMDQ0M2U1Y2YxZGFhODM2ZWRiMzU1YTBmMA==", "commit": {"author": {"name": "Dodji Seketeli", "email": "dodji@redhat.com", "date": "2012-05-24T19:37:45Z"}, "committer": {"name": "Dodji Seketeli", "email": "dodji@gcc.gnu.org", "date": "2012-05-24T19:37:45Z"}, "message": "Make unwound macro expansion trace less redundant\n\nAs discussed previously, the unwinder for macro expansion is quite\nverbose [1].  This patch proposes to address that shortcoming.\n\nConsider this test case:\n\n    $ cat -n test.c\n\t 1\t#define MYMAX(A,B) __extension__ ({ __typeof__(A) __a = (A); \\\n\t 2\t __typeof__(B) __b = (B); __a < __b ? __b : __a; })\n\t 3\n\t 4\tstruct mystruct {};\n\t 5\tvoid\n\t 6\tfoo()\n\t 7\t{\n\t 8\t  struct mystruct p;\n\t 9\t  float f = 0.0;\n\t10\t  MYMAX (p, f);\n\t11\t}\n    $\n\nThe output of the compiler from trunk yields:\n\n    $ cc1 -quiet ./test.c\n    ./test.c: In function \u2018foo\u2019:\n    ./test.c:2:31: error: invalid operands to binary < (have \u2018struct mystruct\u2019 and \u2018float\u2019)\n      __typeof__(B) __b = (B); __a < __b ? __b : __a; })\n\t\t\t\t   ^\n    ./test.c:2:31: note: in expansion of macro 'MYMAX'\n      __typeof__(B) __b = (B); __a < __b ? __b : __a; })\n\t\t\t\t   ^\n    ./test.c:10:3: note: expanded from here\n       MYMAX (p, f);\n       ^\n    $\n\nAfter this patch, the compiler yields:\n\n    $ ./cc1 -quiet ./test.c\n    ./test.c: In function \u2018foo\u2019:\n    ./test.c:2:31: error: invalid operands to binary < (have \u2018struct mystruct\u2019 and \u2018float\u2019)\n      __typeof__(B) __b = (B); __a < __b ? __b : __a; })\n\t\t\t\t   ^\n    ./test.c:10:3: note: in expansion of macro 'MYMAX'\n       MYMAX (p, f);\n       ^\n    $\n\nThe gotcha is, in the general case, we cannot simply eliminate the\ncontext of the macro definition.  That is, the line from the first\noutput that is redundant with the first diagnostic line that has\nline/column number:\n\n    ./test.c:2:31: note: in expansion of macro 'MYMAX'\n      __typeof__(B) __b = (B); __a < __b ? __b : __a; })\n                                   ^\n\nWe cannot simply eliminate that context of macro definition because\nthere are cases where the first diagnostic that has a line/column\nnumber doesn't point to a location inside the definition of the macro\nwhere the relevant token is used.  For instance:\n\n    $ cat -n test2.c\n\t 1\t#define OPERATE(OPRD1, OPRT, OPRD2) \\\n\t 2\t  OPRD1 OPRT OPRD2;\n\t 3\n\t 4\t#define SHIFTL(A,B) \\\n\t 5\t  OPERATE (A,<<,B)\n\t 6\n\t 7\t#define MULT(A) \\\n\t 8\t  SHIFTL (A,1)\n\t 9\n\t10\tvoid\n\t11\tg ()\n\t12\t{\n\t13\t  MULT (1.0);// 1.0 << 1; <-- so this is an error.\n\t14\t}\n    $\n\nWhich yields without the patch:\n\n    $ cc1 -quiet ./test2.c\n    ./test2.c: In function \u2018g\u2019:\n    ./test2.c:5:14: error: invalid operands to binary << (have \u2018double\u2019 and \u2018int\u2019)\n       OPERATE (A,<<,B)\n\t\t  ^\n    ./test2.c:2:9: note: in expansion of macro 'OPERATE'\n       OPRD1 OPRT OPRD2;\n\t     ^\n    ./test2.c:5:3: note: expanded from here\n       OPERATE (A,<<,B)\n       ^\n    ./test2.c:5:14: note: in expansion of macro 'SHIFTL'\n       OPERATE (A,<<,B)\n\t\t  ^\n    ./test2.c:8:3: note: expanded from here\n       SHIFTL (A,1)\n       ^\n    ./test2.c:8:3: note: in expansion of macro 'MULT'\n       SHIFTL (A,1)\n       ^\n    ./test2.c:13:3: note: expanded from here\n       MULT (1.0);// 1.0 << 1; <-- so this is an error.\n       ^\n    $\n\nHere, the line that has the context of macro definition:\n\n    ./test2.c:2:9: note: in expansion of macro 'OPERATE'\n       OPRD1 OPRT OPRD2;\n\t     ^\nis useful, because the first diagnostic that has line/column number\nwasn't pointing into the definition of the macro OPERATE, where the\ntoken '<<' is used.\n\n    ./test2.c:5:14: error: invalid operands to binary << (have \u2018double\u2019 and \u2018int\u2019)\n       OPERATE (A,<<,B)\n\t\t  ^\nSo in this this case, displaying the macro definition context is not\nredundant.  I think it is even desirable.\n\nThe patch changes the output in that case to be:\n\n    ./test2.c: In function \u2018g\u2019:\n    ./test2.c:5:14: erreur: invalid operands to binary << (have \u2018double\u2019 and \u2018int\u2019)\n       OPERATE (A,<<,B)\n\t\t  ^\n    ./test2.c:2:9: note: in definition of macro 'OPERATE'\n       OPRD1 OPRT OPRD2;\n\t     ^\n    ./test2.c:8:3: note: in expansion of macro 'SHIFTL'\n       SHIFTL (A,1)\n       ^\n    ./test2.c:13:3: note: in expansion of macro 'MULT'\n       MULT (1.0);// 1.0 << 1; <-- so this is an error.\n       ^\n    $\n\nIt's shorter, but I believe it has all the information that was\npresent before the patch.\n\n[1]: http://gcc.gnu.org/ml/gcc-patches/2012-05/msg00321.html\n\nBootstrapped and tested on x86_64-unknown-linux-gnu against trunk.\n\ngcc/\n\n\tMake unwound macro expansion trace less redundant\n\t* tree-diagnostic.c (maybe_unwind_expanded_macro_loc): Don't print\n\tcontext of macro definition in the trace, when it's redundant.\n\tUpdate comments.\n\ngcc/testsuite/\n\n\tMake unwound macro expansion trace less redundant\n\t* gcc.dg/cpp/macro-exp-tracking-1.c: Adjust.\n\t* gcc.dg/cpp/macro-exp-tracking-2.c: Likewise.\n\t* gcc.dg/cpp/macro-exp-tracking-3.c: Likewise.\n\t* gcc.dg/cpp/macro-exp-tracking-4.c: Likewise.\n\t* gcc.dg/cpp/macro-exp-tracking-5.c: Likewise.\n\t* gcc.dg/cpp/pragma-diagnostic-2.c: Likewise.\n\nFrom-SVN: r187845", "tree": {"sha": "9447b3399ccf2b1a74d55172202e0c240c861cdf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9447b3399ccf2b1a74d55172202e0c240c861cdf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/165ca58dc37d9c10443e5cf1daa836edb355a0f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/165ca58dc37d9c10443e5cf1daa836edb355a0f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/165ca58dc37d9c10443e5cf1daa836edb355a0f0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/165ca58dc37d9c10443e5cf1daa836edb355a0f0/comments", "author": null, "committer": null, "parents": [{"sha": "a5dedb5e59b72167bcc501f28a8a8c08b9465070", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5dedb5e59b72167bcc501f28a8a8c08b9465070", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5dedb5e59b72167bcc501f28a8a8c08b9465070"}], "stats": {"total": 150, "additions": 103, "deletions": 47}, "files": [{"sha": "e6e67cc33f1749d564bd6a0bc2b9bb1a25ff9793", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/165ca58dc37d9c10443e5cf1daa836edb355a0f0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/165ca58dc37d9c10443e5cf1daa836edb355a0f0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=165ca58dc37d9c10443e5cf1daa836edb355a0f0", "patch": "@@ -1,3 +1,10 @@\n+2012-05-24  Dodji Seketeli  <dodji@redhat.com>\n+\n+\tMake unwound macro expansion trace less redundant\n+\t* tree-diagnostic.c (maybe_unwind_expanded_macro_loc): Don't print\n+\tcontext of macro definition in the trace, when it's redundant.\n+\tUpdate comments.\n+\n 2012-05-24  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/53460"}, {"sha": "706d7f54030a786e99ffa3cbcd64aef74849d84a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/165ca58dc37d9c10443e5cf1daa836edb355a0f0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/165ca58dc37d9c10443e5cf1daa836edb355a0f0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=165ca58dc37d9c10443e5cf1daa836edb355a0f0", "patch": "@@ -1,3 +1,13 @@\n+2012-05-24  Dodji Seketeli  <dodji@redhat.com>\n+\n+\tMake unwound macro expansion trace less redundant\n+\t* gcc.dg/cpp/macro-exp-tracking-1.c: Adjust.\n+\t* gcc.dg/cpp/macro-exp-tracking-2.c: Likewise.\n+\t* gcc.dg/cpp/macro-exp-tracking-3.c: Likewise.\n+\t* gcc.dg/cpp/macro-exp-tracking-4.c: Likewise.\n+\t* gcc.dg/cpp/macro-exp-tracking-5.c: Likewise.\n+\t* gcc.dg/cpp/pragma-diagnostic-2.c: Likewise.\n+\n 2012-05-24  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/53464"}, {"sha": "6a95b0e3a8c2c3aca10c6dec9c6615cac2d95f26", "filename": "gcc/testsuite/g++.dg/warn/Wconversion-real-integer2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/165ca58dc37d9c10443e5cf1daa836edb355a0f0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWconversion-real-integer2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/165ca58dc37d9c10443e5cf1daa836edb355a0f0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWconversion-real-integer2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWconversion-real-integer2.C?ref=165ca58dc37d9c10443e5cf1daa836edb355a0f0", "patch": "@@ -29,5 +29,5 @@ float  vfloat;\n \n void h (void)\n {\n-    vfloat = INT_MAX; // { dg-message \"expanded from here\" }\n+    vfloat = INT_MAX; // { dg-message \"in expansion of macro 'INT_MAX'\" }\n }"}, {"sha": "afd9a20147e28a3c24a94b61a64924e65d207105", "filename": "gcc/testsuite/g++.dg/warn/Wdouble-promotion.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/165ca58dc37d9c10443e5cf1daa836edb355a0f0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWdouble-promotion.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/165ca58dc37d9c10443e5cf1daa836edb355a0f0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWdouble-promotion.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWdouble-promotion.C?ref=165ca58dc37d9c10443e5cf1daa836edb355a0f0", "patch": "@@ -36,7 +36,7 @@ usual_arithmetic_conversions(void)\n \n   local_cf = cf + 1.0;       /* { dg-warning \"implicit\" } */\n   local_cf = cf - d;         /* { dg-warning \"implicit\" } */\n-  local_cf = cf + 1.0 * ID;  /* { dg-message \"expanded from here\" } */\n+  local_cf = cf + 1.0 * ID;  /* { dg-message \"in expansion of macro 'ID'\" } */\n   local_cf = cf - cd;        /* { dg-warning \"implicit\" } */\n   \n   local_f = i ? f : d;       /* { dg-warning \"implicit\" } */"}, {"sha": "28ef7955c9bc8a9cf66c3d3e91a30c755ee4fa85", "filename": "gcc/testsuite/gcc.dg/cpp/macro-exp-tracking-1.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/165ca58dc37d9c10443e5cf1daa836edb355a0f0/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fmacro-exp-tracking-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/165ca58dc37d9c10443e5cf1daa836edb355a0f0/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fmacro-exp-tracking-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fmacro-exp-tracking-1.c?ref=165ca58dc37d9c10443e5cf1daa836edb355a0f0", "patch": "@@ -6,16 +6,14 @@\n #define OPERATE(OPRD1, OPRT, OPRD2) \\\n do \\\n { \\\n-  OPRD1 OPRT OPRD2; /* { dg-message \"expansion\" }*/ \t   \\\n+  OPRD1 OPRT OPRD2; /* { dg-message \"definition\" }*/ \t   \\\n } while (0)\n \n #define SHIFTL(A,B) \\\n-  OPERATE (A,<<,B) /* { dg-message \"expanded|expansion\" } */\n+  OPERATE (A,<<,B) /* { dg-error \"invalid operands\" } */\n \n void\n foo ()\n {\n-  SHIFTL (0.1,0.2); /* { dg-message \"expanded\" } */\n+  SHIFTL (0.1,0.2); /* { dg-message \"in expansion of macro \\[^\\n\\r\\]SHIFTL\" } */\n }\n-\n-/* { dg-error \"invalid operands\" \"\" { target *-*-* } 13 } */"}, {"sha": "2367765ccef8723b4ac7faed59162310b85028de", "filename": "gcc/testsuite/gcc.dg/cpp/macro-exp-tracking-2.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/165ca58dc37d9c10443e5cf1daa836edb355a0f0/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fmacro-exp-tracking-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/165ca58dc37d9c10443e5cf1daa836edb355a0f0/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fmacro-exp-tracking-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fmacro-exp-tracking-2.c?ref=165ca58dc37d9c10443e5cf1daa836edb355a0f0", "patch": "@@ -4,18 +4,17 @@\n */\n \n #define OPERATE(OPRD1, OPRT, OPRD2) \\\n- OPRD1 OPRT OPRD2;\t\t/* { dg-message \"expansion\" } */\n+ OPRD1 OPRT OPRD2;\t  /* { dg-message \"in definition of macro 'OPERATE'\" } */\n \n #define SHIFTL(A,B) \\\n-  OPERATE (A,<<,B) /* { dg-message \"expanded|expansion\" } */\n+  OPERATE (A,<<,B) /* { dg-message \"invalid operands to binary <<\" } */\n \n #define MULT(A) \\\n-  SHIFTL (A,1)\t\t\t/* { dg-message \"expanded|expansion\" } */\n+  SHIFTL (A,1)\t   /* { dg-message \"in expansion of macro 'SHIFTL'\" } */\n \n void\n foo ()\n {\n-  MULT (1.0);\t\t\t/* { dg-message \"expanded\" } */\n+  MULT (1.0);\t   /* { dg-message \"in expansion of macro 'MULT'\" } */\n }\n \n-/* { dg-error \"invalid operands to binary <<\" \"\" { target *-*-* } { 10 } } */"}, {"sha": "b47726d6b4b768a9b74ae779c78ddc143de277bf", "filename": "gcc/testsuite/gcc.dg/cpp/macro-exp-tracking-3.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/165ca58dc37d9c10443e5cf1daa836edb355a0f0/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fmacro-exp-tracking-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/165ca58dc37d9c10443e5cf1daa836edb355a0f0/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fmacro-exp-tracking-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fmacro-exp-tracking-3.c?ref=165ca58dc37d9c10443e5cf1daa836edb355a0f0", "patch": "@@ -3,12 +3,10 @@\n   { dg-do compile }\n  */\n \n-#define SQUARE(A) A * A\t\t/* { dg-message \"expansion\" } */\n+#define SQUARE(A) A * A\t /* { dg-message \"in definition of macro 'SQUARE'\" } */\n \n void\n foo()\n {\n-  SQUARE (1 << 0.1);\t\t/* { dg-message \"expanded\" } */\n+  SQUARE (1 << 0.1); /* { dg-error \"16:invalid operands to binary <<\" } */\n }\n-\n-/* { dg-error \"16:invalid operands to binary <<\" \"\" {target *-*-* } { 11 } } */"}, {"sha": "401b846cc3ede1912a3c2c6b6bd90c02d1a5f690", "filename": "gcc/testsuite/gcc.dg/cpp/macro-exp-tracking-4.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/165ca58dc37d9c10443e5cf1daa836edb355a0f0/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fmacro-exp-tracking-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/165ca58dc37d9c10443e5cf1daa836edb355a0f0/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fmacro-exp-tracking-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fmacro-exp-tracking-4.c?ref=165ca58dc37d9c10443e5cf1daa836edb355a0f0", "patch": "@@ -3,12 +3,11 @@\n   { dg-do compile }\n  */\n \n-#define SQUARE(A) A * A\t\t/* { dg-message \"expansion\" } */\n+#define SQUARE(A) A * A\t /* { dg-message \"in definition of macro 'SQUARE'\" } */\n \n void\n foo()\n {\n-  SQUARE (1 << 0.1);\t\t/* { dg-message \"expanded\" } */\n+  SQUARE (1 << 0.1);  /* { dg-message \"13:invalid operands to binary <<\" } */\n }\n \n-/* { dg-error \"13:invalid operands to binary <<\" \"\" { target *-*-* } { 11 } } */"}, {"sha": "abe456ceb6c6585add117add7018178f9b22ee4d", "filename": "gcc/testsuite/gcc.dg/cpp/macro-exp-tracking-5.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/165ca58dc37d9c10443e5cf1daa836edb355a0f0/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fmacro-exp-tracking-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/165ca58dc37d9c10443e5cf1daa836edb355a0f0/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fmacro-exp-tracking-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fmacro-exp-tracking-5.c?ref=165ca58dc37d9c10443e5cf1daa836edb355a0f0", "patch": "@@ -3,16 +3,16 @@\n   { dg-do compile }\n  */\n \n-#define PASTED var ## iable /* { dg-error \"undeclared\" } */\n+#define PASTED var ## iable /* { dg-error \"'variable' undeclared\" } */\n #define call_foo(p1, p2) \\\n   foo (p1,\t\t \\\n-       p2);  /*  { dg-message \"in expansion of macro\" } */\n+       p2);  /*  { dg-message \"in definition of macro 'call_foo'\" } */\n \n void foo(int, char);\n \n void\n bar()\n {\n-  call_foo(1,PASTED); /* { dg-message \"expanded from here\" } */\n+  call_foo(1,PASTED); /* { dg-message \"in expansion of macro 'PASTED'\" } */\n }\n "}, {"sha": "38fc77c47baaaa4031ede54d28561c7b1446d621", "filename": "gcc/testsuite/gcc.dg/cpp/pragma-diagnostic-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/165ca58dc37d9c10443e5cf1daa836edb355a0f0/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpragma-diagnostic-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/165ca58dc37d9c10443e5cf1daa836edb355a0f0/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpragma-diagnostic-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpragma-diagnostic-2.c?ref=165ca58dc37d9c10443e5cf1daa836edb355a0f0", "patch": "@@ -24,5 +24,5 @@ g (void)\n void\n h (void)\n {\n-  CODE_WITH_WARNING;\t\t/* { dg-message \"expanded\" } */\n+  CODE_WITH_WARNING; /* { dg-message \"in expansion of macro 'CODE_WITH_WARNING'\" } */\n }"}, {"sha": "774b6c44dd09a6e2adafc6b4157891ee19c05e16", "filename": "gcc/tree-diagnostic.c", "status": "modified", "additions": 69, "deletions": 24, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/165ca58dc37d9c10443e5cf1daa836edb355a0f0/gcc%2Ftree-diagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/165ca58dc37d9c10443e5cf1daa836edb355a0f0/gcc%2Ftree-diagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-diagnostic.c?ref=165ca58dc37d9c10443e5cf1daa836edb355a0f0", "patch": "@@ -89,16 +89,13 @@ DEF_VEC_ALLOC_O (loc_map_pair, heap);\n \n    Here is the diagnostic that we want the compiler to generate:\n \n-    test.c: In function 'g':\n-    test.c:5:14: error: invalid operands to binary << (have 'double' and 'int')\n-    test.c:2:9: note: in expansion of macro 'OPERATE'\n-    test.c:5:3: note: expanded from here\n-    test.c:5:14: note: in expansion of macro 'SHIFTL'\n-    test.c:8:3: note: expanded from here\n-    test.c:8:3: note: in expansion of macro 'MULT'\n-    test.c:13:3: note: expanded from here\n-\n-   The part that goes from the third to the eighth line of this\n+    test.c: In function \u2018g\u2019:\n+    test.c:5:14: error: invalid operands to binary << (have \u2018double\u2019 and \u2018int\u2019)\n+    test.c:2:9: note: in definition of macro 'OPERATE'\n+    test.c:8:3: note: in expansion of macro 'SHIFTL'\n+    test.c:13:3: note: in expansion of macro 'MULT'\n+\n+   The part that goes from the third to the fifth line of this\n    diagnostic (the lines containing the 'note:' string) is called the\n    unwound macro expansion trace.  That's the part generated by this\n    function.  */\n@@ -150,10 +147,38 @@ maybe_unwind_expanded_macro_loc (diagnostic_context *context,\n   if (!LINEMAP_SYSP (map))\n     FOR_EACH_VEC_ELT (loc_map_pair, loc_vec, ix, iter)\n       {\n-        source_location resolved_def_loc = 0, resolved_exp_loc = 0;\n+        source_location resolved_def_loc = 0, resolved_exp_loc = 0,\n+\t  saved_location = 0;\n+\tint resolved_def_loc_line = 0, saved_location_line = 0;\n         diagnostic_t saved_kind;\n         const char *saved_prefix;\n-        source_location saved_location;\n+\t/* Sometimes, in the unwound macro expansion trace, we want to\n+\t   print a part of the context that shows where, in the\n+\t   definition of the relevant macro, is the token (we are\n+\t   looking at) used.  That is the case in the introductory\n+\t   comment of this function, where we print:\n+\n+\t       test.c:2:9: note: in definition of macro 'OPERATE'.\n+\n+\t   We print that \"macro definition context\" because the\n+\t   diagnostic line (emitted by the call to\n+\t   pp_ouput_formatted_text in diagnostic_report_diagnostic):\n+\n+\t       test.c:5:14: error: invalid operands to binary << (have \u2018double\u2019 and \u2018int\u2019)\n+\n+\t   does not point into the definition of the macro where the\n+\t   token '<<' (that is an argument to the function-like macro\n+\t   OPERATE) is used.  So we must \"display\" the line of that\n+\t   macro definition context to the user somehow.\n+\n+\t   A contrario, when the first interesting diagnostic line\n+\t   points into the definition of the macro, we don't need to\n+\t   display any line for that macro definition in the trace\n+\t   anymore, otherwise it'd be redundant.\n+\n+\t   This flag is true when we need to display the context of\n+\t   the macro definition.  */\n+\tbool print_definition_context_p = false;\n \n         /* Okay, now here is what we want.  For each token resulting\n            from macro expansion we want to show: 1/ where in the\n@@ -176,6 +201,8 @@ maybe_unwind_expanded_macro_loc (diagnostic_context *context,\n \t  if (l < RESERVED_LOCATION_COUNT\n \t      || LINEMAP_SYSP (m))\n \t    continue;\n+\n+\t  resolved_def_loc_line = SOURCE_LINE (m, l);\n \t}\n \n         /* Resolve the location of the expansion point of the macro\n@@ -189,22 +216,40 @@ maybe_unwind_expanded_macro_loc (diagnostic_context *context,\n         saved_kind = diagnostic->kind;\n         saved_prefix = pp_get_prefix (context->printer);\n         saved_location = diagnostic->location;\n+\tsaved_location_line =\n+\t  expand_location_to_spelling_point (saved_location).line;\n \n         diagnostic->kind = DK_NOTE;\n-        diagnostic->location = resolved_def_loc;\n-        pp_set_prefix (context->printer,\n-                       diagnostic_build_prefix (context, diagnostic));\n-        pp_newline (context->printer);\n-        pp_printf (context->printer, \"in expansion of macro '%s'\",\n-                   linemap_map_get_macro_name (iter->map));\n-        pp_destroy_prefix (context->printer);\n-        diagnostic_show_locus (context, diagnostic);\n \n-        diagnostic->location = resolved_exp_loc;\n-        pp_set_prefix (context->printer,\n+\t/* We need to print the context of the macro definition only\n+\t   when the locus of the first displayed diagnostic (displayed\n+\t   before this trace) was inside the definition of the\n+\t   macro.  */\n+\tprint_definition_context_p =\n+\t  (ix == 0 && (saved_location_line != resolved_def_loc_line));\n+\n+\tif (print_definition_context_p)\n+\t  {\n+\t    diagnostic->location = resolved_def_loc;\n+\t    pp_set_prefix (context->printer,\n+\t\t\t   diagnostic_build_prefix (context, diagnostic));\n+\t    pp_newline (context->printer);\n+\t    pp_printf (context->printer, \"in definition of macro '%s'\",\n+\t\t       linemap_map_get_macro_name (iter->map));\n+\t    pp_destroy_prefix (context->printer);\n+\t    diagnostic_show_locus (context, diagnostic);\n+\t    /* At this step, as we've printed the context of the macro\n+\t       definition, we don't want to print the context of its\n+\t       expansion, otherwise, it'd be redundant.  */\n+\t    continue;\n+\t  }\n+\n+\tdiagnostic->location = resolved_exp_loc;\n+\tpp_set_prefix (context->printer,\n                        diagnostic_build_prefix (context, diagnostic));\n-        pp_newline (context->printer);\n-        pp_string (context->printer, \"expanded from here\");\n+\tpp_newline (context->printer);\n+\tpp_printf (context->printer, \"in expansion of macro '%s'\",\n+\t\t   linemap_map_get_macro_name (iter->map));\n         pp_destroy_prefix (context->printer);\n         diagnostic_show_locus (context, diagnostic);\n "}]}