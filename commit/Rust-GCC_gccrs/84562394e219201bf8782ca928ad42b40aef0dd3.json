{"sha": "84562394e219201bf8782ca928ad42b40aef0dd3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODQ1NjIzOTRlMjE5MjAxYmY4NzgyY2E5MjhhZDQyYjQwYWVmMGRkMw==", "commit": {"author": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2013-12-10T16:48:44Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2013-12-10T16:48:44Z"}, "message": "cgraph.h (cgraph_node_set_iterator, [...]): Remove typedef.\n\n\t* gcc/cgraph.h (cgraph_node_set_iterator, varpool_node_set_iterator):\n\tRemove typedef.\n\t(cgraph_inline_failed_enum, cgraph_inline_failed_t): Remove typedef and\n\trename to cgraph_inline_failed_t.\n\t* gcc/tree-ssa-alias.h (ao_ref_s, ao_ref): Remove typedef and rename\n\tto ao_ref.\n\t* gcc/reload.h (reg_equivs_s, reg_equivs_t): Remove typedef and rename\n\tto reg_equivs_t.\n\t* gcc/conditions.h (CC_STATUS): Remove typedef.\n\t* gcc/bitmap.h (bitmap_obstack): Remove typedef.\n\t(bitmap_element_def, bitmap_element): Remove typedef and rename to\n\tbitmap_element.\n\t(bitmap_head_def, bitmap_head): Remove typedef and rename to\n\tbitmap_head.\n\t(bitmap_iterator): Remove typedef.\n\t* gcc/target.h (cumulative_args_t, print_switch_type,\n\tsecondary_reload_info): Remove typedef.\n\t* gcc/dwarf2out.h (dw_cfi_oprnd_struct, dw_cfi_oprnd): Remove\n\tdw_cfi_oprnd_struct alias.\n\t(dw_cfi_struct, dw_cfi_node): Remove typedef and rename to dw_cfi_node.\n\t(dw_fde_struct, dw_fde_node): Remove typedef and rename to dw_fde_node.\n\t(cfa_loc, dw_cfa_location): Remove typedef and rename to\n\tdw_cfa_location.\n\t(dw_vec_struct, dw_vec_const): Remove typedef and rename to\n\tdw_vec_const.\n\t(dw_val_struct, dw_val_node): Remove typedef and rename to dw_val_node.\n\t(dw_loc_descr_struct, dw_loc_descr_node): Remove typedef and rename to\n\tdw_loc_descr_node.\n\t* gcc/params.h (param_info, compiler_param): Remove typedef.\n\t* gcc/opts.h (cl_deferred_param): Remove typedef.\n\t* gcc/sreal.h (sreal): Remove typedef.\n\t* gcc/ddg.h (dep_type, dep_data_type): Remove typedef.\n\t* gcc/graphite-clast-to-gimple.h (cloog_prog_clast, bb_pbb_def): Remove\n\ttypedef.\n\t* gcc/lto-streamer.h (lto_decl_stream_e_t, lto_encoder_entry,\n\tlto_symtab_encoder_iterator, res_pair): Remove typedef.\n\t* gcc/tree-affine.h (affine_tree_combination, aff_tree): Remove typedef\n\tand rename to aff_tree.\n\t* gcc/sched-int.h (region): Remove typedef.\n\t* gcc/diagnostic.h (diagnostic_info,\n\tdiagnostic_classification_change_t): Remove typedef.\n\t* gcc/tree-ssa-loop.h (affine_iv_d): Remove typedef and rename to\n\taffine_iv.\n\t* gcc/sbitmap.h (sbitmap_iterator): Remove typedef.\n\t* gcc/ssa-iterators.h (immediate_use_iterator_d, imm_use_iterator):\n\tRemove typedef and rename to imm_use_iterator.\n\t(ssa_operand_iterator_d, ssa_op_iter): Remove typedef and rename to\n\tssa_op_iter.\n\t* gcc/ggc-internal.h (ggc_statistics): Remove typedef.\n\t* gcc/cselib.h (cselib_val_struct, cselib_val): Remove typedef and\n\trename to cselib_val.\n\t* gcc/tree-core.h (alias_pair): Remove typedef.\n\t(constructor_elt_d, constructor_elt): Remove typedef and rename to\n\tconstructor_elt.\n\t(ssa_use_operand_d, ssa_use_operand_t): Remove typedef and rename to\n\tssa_use_operand_t.\n\t* gcc/graphite-sese-to-poly.h (base_alias_pair): Remove typedef.\n\t* gcc/tree-data-ref.h (conflict_function): Remove typedef.\n\t* gcc/tree-inline.h (copy_body_data): Remove typedef.\n\t* gcc/ipa-inline.h (condition, size_time_entry, inline_param_summary_t,\n\tedge_growth_cache_entry): Remove typedef.\n\t* gcc/regrename.h (operand_rr_info, insn_rr_info): Remove typedef.\n\t* gcc/gimple-iterator.h (gimple_stmt_iterator_d, gimple_stmt_iterator):\n\tRemove typedef and rename to gimple_stmt_iterator.\n\t* gcc/basic-block.h (ce_if_block, ce_if_block_t): Remove typedef and\n\trename to ce_if_block.\n\t(edge_iterator): Remove typedef.\n\t* gcc/ipa-prop.h (ipa_agg_jf_item, ipa_agg_jf_item_t): Remove typedef\n\tand rename to ipa_agg_jf_item.\n\t(ipa_agg_jump_function_t, ipa_param_descriptor_t, ipa_node_params_t,\n\tipa_parm_adjustment_t): Remove typedef.\n\t(ipa_jump_func, ipa_jump_func_t): Remove typedef and rename to\n\tipa_jump_func.\n\t(ipa_edge_args, ipa_edge_args_t): Remove typedef and rename to\n\tipa_edge_args.\n\t* gcc/gcov-io.h (gcov_bucket_type): Remove typedef.\n\t(gcov_working_set_info, gcov_working_set_t): Remove typedef and rename\n\tto gcov_working_set_t.\n\t* gcc/ira-int.h (minmax_set_iterator, ira_allocno_iterator,\n\tira_object_iterator, ira_allocno_object_iterator, ira_pref_iterator,\n\tira_copy_iterator, ira_object_conflict_iterator): Remove typedef.\n\t* gcc/tree-iterator.h (tree_stmt_iterator): Remove typedef.\n\t* gcc/rtl.h (addr_diff_vec_flags, mem_attrs, reg_attrs,\n\treplace_label_data): Remove typedef.\n\t(rtunion_def, rtunion): Remove typedef and rename to rtunion.\n\t* gcc/hard-reg-set.h (hard_reg_set_iterator): Remove typedef.\n\t* gcc/sel-sched-ir.h (_list_iterator, sel_global_bb_info_def,\n\tsel_region_bb_info_def, succ_iterator): Remove typedef.\n\t(deps_where_def, deps_where_t): Remove typedef and rename to\n\tdeps_where_t.\n\t* gcc/coretypes.h: Adapt forward declarations.\n\t* gcc/tree-scalar-evolution.h: Likewise.\n\t* gcc/tree-ssa-address.h: Likewise.\n\t* gcc/tree-ssa-operands.h: Likewise.\n\t* gcc/function.h: Likewise.\n\t* gcc/config/frv/frv-protos.h: Likewise.\n\t* gcc/targhooks.h: Likewise.\n\t* gcc/basic_block.h: Likewise.\n\t* gcc/rtl.def: Adapt documentation.\n\t* gcc/doc/tm.texi: Likewise.\n\t* gcc/ipa-cp.c: Adapt uses.\n\t* gcc/bitmap.c: Likewise.\n\t* gcc/dwarf2out.c: Likewise.\n\t* gcc/target.def: Likewise.\n\t* gcc/ipa-inline-analysis.c: Likewise.\n\t* gcc/dwarf2cfi.c: Likewise.\n\t* gcc/tree-ssa-loop-ivopts.c: Likewise.\n\t* gcc/lto-cgraph.c: Likewise.\n\t* gcc/config/frv/frv.c: Likewise.\n\t* gcc/ifcvt.c: Likewise.\n\t* gcc/ipa-prop.c: Likewise.\n\nFrom-SVN: r205863", "tree": {"sha": "46df024621e90306181aba8a7770f9b752c0defa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/46df024621e90306181aba8a7770f9b752c0defa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/84562394e219201bf8782ca928ad42b40aef0dd3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84562394e219201bf8782ca928ad42b40aef0dd3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84562394e219201bf8782ca928ad42b40aef0dd3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84562394e219201bf8782ca928ad42b40aef0dd3/comments", "author": null, "committer": null, "parents": [{"sha": "a4cf752c5107be07eb60d0f4c9c14ba6f0c8c028", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4cf752c5107be07eb60d0f4c9c14ba6f0c8c028", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4cf752c5107be07eb60d0f4c9c14ba6f0c8c028"}], "stats": {"total": 705, "additions": 400, "deletions": 305}, "files": [{"sha": "59e9fd2404218dba18942a0407669a2a6281ae9d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=84562394e219201bf8782ca928ad42b40aef0dd3", "patch": "@@ -1,3 +1,117 @@\n+2013-12-10  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\t* gcc/cgraph.h (cgraph_node_set_iterator, varpool_node_set_iterator):\n+\tRemove typedef.\n+\t(cgraph_inline_failed_enum, cgraph_inline_failed_t): Remove typedef and\n+\trename to cgraph_inline_failed_t.\n+\t* gcc/tree-ssa-alias.h (ao_ref_s, ao_ref): Remove typedef and rename\n+\tto ao_ref.\n+\t* gcc/reload.h (reg_equivs_s, reg_equivs_t): Remove typedef and rename\n+\tto reg_equivs_t.\n+\t* gcc/conditions.h (CC_STATUS): Remove typedef.\n+\t* gcc/bitmap.h (bitmap_obstack): Remove typedef.\n+\t(bitmap_element_def, bitmap_element): Remove typedef and rename to\n+\tbitmap_element.\n+\t(bitmap_head_def, bitmap_head): Remove typedef and rename to\n+\tbitmap_head.\n+\t(bitmap_iterator): Remove typedef.\n+\t* gcc/target.h (cumulative_args_t, print_switch_type,\n+\tsecondary_reload_info): Remove typedef.\n+\t* gcc/dwarf2out.h (dw_cfi_oprnd_struct, dw_cfi_oprnd): Remove\n+\tdw_cfi_oprnd_struct alias.\n+\t(dw_cfi_struct, dw_cfi_node): Remove typedef and rename to dw_cfi_node.\n+\t(dw_fde_struct, dw_fde_node): Remove typedef and rename to dw_fde_node.\n+\t(cfa_loc, dw_cfa_location): Remove typedef and rename to\n+\tdw_cfa_location.\n+\t(dw_vec_struct, dw_vec_const): Remove typedef and rename to\n+\tdw_vec_const.\n+\t(dw_val_struct, dw_val_node): Remove typedef and rename to dw_val_node.\n+\t(dw_loc_descr_struct, dw_loc_descr_node): Remove typedef and rename to\n+\tdw_loc_descr_node.\n+\t* gcc/params.h (param_info, compiler_param): Remove typedef.\n+\t* gcc/opts.h (cl_deferred_param): Remove typedef.\n+\t* gcc/sreal.h (sreal): Remove typedef.\n+\t* gcc/ddg.h (dep_type, dep_data_type): Remove typedef.\n+\t* gcc/graphite-clast-to-gimple.h (cloog_prog_clast, bb_pbb_def): Remove\n+\ttypedef.\n+\t* gcc/lto-streamer.h (lto_decl_stream_e_t, lto_encoder_entry,\n+\tlto_symtab_encoder_iterator, res_pair): Remove typedef.\n+\t* gcc/tree-affine.h (affine_tree_combination, aff_tree): Remove typedef\n+\tand rename to aff_tree.\n+\t* gcc/sched-int.h (region): Remove typedef.\n+\t* gcc/diagnostic.h (diagnostic_info,\n+\tdiagnostic_classification_change_t): Remove typedef.\n+\t* gcc/tree-ssa-loop.h (affine_iv_d): Remove typedef and rename to\n+\taffine_iv.\n+\t* gcc/sbitmap.h (sbitmap_iterator): Remove typedef.\n+\t* gcc/ssa-iterators.h (immediate_use_iterator_d, imm_use_iterator):\n+\tRemove typedef and rename to imm_use_iterator.\n+\t(ssa_operand_iterator_d, ssa_op_iter): Remove typedef and rename to\n+\tssa_op_iter.\n+\t* gcc/ggc-internal.h (ggc_statistics): Remove typedef.\n+\t* gcc/cselib.h (cselib_val_struct, cselib_val): Remove typedef and\n+\trename to cselib_val.\n+\t* gcc/tree-core.h (alias_pair): Remove typedef.\n+\t(constructor_elt_d, constructor_elt): Remove typedef and rename to\n+\tconstructor_elt.\n+\t(ssa_use_operand_d, ssa_use_operand_t): Remove typedef and rename to\n+\tssa_use_operand_t.\n+\t* gcc/graphite-sese-to-poly.h (base_alias_pair): Remove typedef.\n+\t* gcc/tree-data-ref.h (conflict_function): Remove typedef.\n+\t* gcc/tree-inline.h (copy_body_data): Remove typedef.\n+\t* gcc/ipa-inline.h (condition, size_time_entry, inline_param_summary_t,\n+\tedge_growth_cache_entry): Remove typedef.\n+\t* gcc/regrename.h (operand_rr_info, insn_rr_info): Remove typedef.\n+\t* gcc/gimple-iterator.h (gimple_stmt_iterator_d, gimple_stmt_iterator):\n+\tRemove typedef and rename to gimple_stmt_iterator.\n+\t* gcc/basic-block.h (ce_if_block, ce_if_block_t): Remove typedef and\n+\trename to ce_if_block.\n+\t(edge_iterator): Remove typedef.\n+\t* gcc/ipa-prop.h (ipa_agg_jf_item, ipa_agg_jf_item_t): Remove typedef\n+\tand rename to ipa_agg_jf_item.\n+\t(ipa_agg_jump_function_t, ipa_param_descriptor_t, ipa_node_params_t,\n+\tipa_parm_adjustment_t): Remove typedef.\n+\t(ipa_jump_func, ipa_jump_func_t): Remove typedef and rename to\n+\tipa_jump_func.\n+\t(ipa_edge_args, ipa_edge_args_t): Remove typedef and rename to\n+\tipa_edge_args.\n+\t* gcc/gcov-io.h (gcov_bucket_type): Remove typedef.\n+\t(gcov_working_set_info, gcov_working_set_t): Remove typedef and rename\n+\tto gcov_working_set_t.\n+\t* gcc/ira-int.h (minmax_set_iterator, ira_allocno_iterator,\n+\tira_object_iterator, ira_allocno_object_iterator, ira_pref_iterator,\n+\tira_copy_iterator, ira_object_conflict_iterator): Remove typedef.\n+\t* gcc/tree-iterator.h (tree_stmt_iterator): Remove typedef.\n+\t* gcc/rtl.h (addr_diff_vec_flags, mem_attrs, reg_attrs,\n+\treplace_label_data): Remove typedef.\n+\t(rtunion_def, rtunion): Remove typedef and rename to rtunion.\n+\t* gcc/hard-reg-set.h (hard_reg_set_iterator): Remove typedef.\n+\t* gcc/sel-sched-ir.h (_list_iterator, sel_global_bb_info_def,\n+\tsel_region_bb_info_def, succ_iterator): Remove typedef.\n+\t(deps_where_def, deps_where_t): Remove typedef and rename to\n+\tdeps_where_t.\n+\t* gcc/coretypes.h: Adapt forward declarations.\n+\t* gcc/tree-scalar-evolution.h: Likewise.\n+\t* gcc/tree-ssa-address.h: Likewise.\n+\t* gcc/tree-ssa-operands.h: Likewise.\n+\t* gcc/function.h: Likewise.\n+\t* gcc/config/frv/frv-protos.h: Likewise.\n+\t* gcc/targhooks.h: Likewise.\n+\t* gcc/basic_block.h: Likewise.\n+\t* gcc/rtl.def: Adapt documentation.\n+\t* gcc/doc/tm.texi: Likewise.\n+\t* gcc/ipa-cp.c: Adapt uses.\n+\t* gcc/bitmap.c: Likewise.\n+\t* gcc/dwarf2out.c: Likewise.\n+\t* gcc/target.def: Likewise.\n+\t* gcc/ipa-inline-analysis.c: Likewise.\n+\t* gcc/dwarf2cfi.c: Likewise.\n+\t* gcc/tree-ssa-loop-ivopts.c: Likewise.\n+\t* gcc/lto-cgraph.c: Likewise.\n+\t* gcc/config/frv/frv.c: Likewise.\n+\t* gcc/ifcvt.c: Likewise.\n+\t* gcc/ipa-prop.c: Likewise.\n+\n 2013-12-10  Kai Tietz  <ktietz@redhat.com>\n \n \tPR target/56807"}, {"sha": "bcd1a6ea2211a756e937ba1568c26a85a457b1a5", "filename": "gcc/basic-block.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=84562394e219201bf8782ca928ad42b40aef0dd3", "patch": "@@ -418,7 +418,7 @@ extern void scale_bbs_frequencies_gcov_type (basic_block *, int, gcov_type,\n    needs to be in a public file in case the IFCVT macros call\n    functions passing the ce_if_block data structure.  */\n \n-typedef struct ce_if_block\n+struct ce_if_block\n {\n   basic_block test_bb;\t\t\t/* First test block.  */\n   basic_block then_bb;\t\t\t/* THEN block.  */\n@@ -433,7 +433,7 @@ typedef struct ce_if_block\n   int num_then_insns;\t\t\t/* # of insns in THEN block.  */\n   int num_else_insns;\t\t\t/* # of insns in ELSE block.  */\n   int pass;\t\t\t\t/* Pass number.  */\n-} ce_if_block_t;\n+};\n \n /* This structure maintains an edge list vector.  */\n /* FIXME: Make this a vec<edge>.  */\n@@ -564,10 +564,10 @@ single_pred (const_basic_block bb)\n \n /* Iterator object for edges.  */\n \n-typedef struct {\n+struct edge_iterator {\n   unsigned index;\n   vec<edge, va_gc> **container;\n-} edge_iterator;\n+};\n \n static inline vec<edge, va_gc> *\n ei_container (edge_iterator i)\n@@ -781,8 +781,8 @@ extern int pre_and_rev_post_order_compute (int *, int *, bool);\n extern int dfs_enumerate_from (basic_block, int,\n \t\t\t       bool (*)(const_basic_block, const void *),\n \t\t\t       basic_block *, int, const void *);\n-extern void compute_dominance_frontiers (struct bitmap_head_def *);\n-extern bitmap compute_idf (bitmap, struct bitmap_head_def *);\n+extern void compute_dominance_frontiers (struct bitmap_head *);\n+extern bitmap compute_idf (bitmap, struct bitmap_head *);\n extern basic_block * single_pred_before_succ_order (void);\n \n /* In cfgrtl.c  */\n@@ -939,7 +939,7 @@ extern void rtl_profile_for_edge (edge);\n extern void default_rtl_profile (void);\n \n /* In profile.c.  */\n-typedef struct gcov_working_set_info gcov_working_set_t;\n+struct gcov_working_set_t;\n extern gcov_working_set_t *find_working_set (unsigned pct_times_10);\n \n /* Check tha probability is sane.  */"}, {"sha": "f1a845915f9cdfe2c455283f939f640288f704d7", "filename": "gcc/bitmap.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.c?ref=84562394e219201bf8782ca928ad42b40aef0dd3", "patch": "@@ -244,7 +244,7 @@ bitmap_element_allocate (bitmap head)\n \t  /*  Inner list was just a singleton.  */\n \t  bitmap_ggc_free = element->prev;\n       else\n-\telement = ggc_alloc_bitmap_element_def ();\n+\telement = ggc_alloc_bitmap_element ();\n     }\n \n   if (GATHER_STATISTICS)\n@@ -370,7 +370,7 @@ bitmap_obstack_alloc_stat (bitmap_obstack *bit_obstack MEM_STAT_DECL)\n     bit_obstack = &bitmap_default_obstack;\n   map = bit_obstack->heads;\n   if (map)\n-    bit_obstack->heads = (struct bitmap_head_def *) map->first;\n+    bit_obstack->heads = (struct bitmap_head *) map->first;\n   else\n     map = XOBNEW (&bit_obstack->obstack, bitmap_head);\n   bitmap_initialize_stat (map, bit_obstack PASS_MEM_STAT);\n@@ -388,7 +388,7 @@ bitmap_gc_alloc_stat (ALONE_MEM_STAT_DECL)\n {\n   bitmap map;\n \n-  map = ggc_alloc_bitmap_head_def ();\n+  map = ggc_alloc_bitmap_head ();\n   bitmap_initialize_stat (map, NULL PASS_MEM_STAT);\n \n   if (GATHER_STATISTICS)\n@@ -2207,13 +2207,13 @@ dump_bitmap_statistics (void)\n }\n \n DEBUG_FUNCTION void\n-debug (const bitmap_head_def &ref)\n+debug (const bitmap_head &ref)\n {\n   dump_bitmap (stderr, &ref);\n }\n \n DEBUG_FUNCTION void\n-debug (const bitmap_head_def *ptr)\n+debug (const bitmap_head *ptr)\n {\n   if (ptr)\n     debug (*ptr);"}, {"sha": "2c14080e0890830811d863a0bc4a74ac752800e4", "filename": "gcc/bitmap.h", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fbitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fbitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.h?ref=84562394e219201bf8782ca928ad42b40aef0dd3", "patch": "@@ -24,7 +24,7 @@ along with GCC; see the file COPYING3.  If not see\n \n    This sparse set representation is suitable for sparse sets with an\n    unknown (a priori) universe.  The set is represented as a double-linked\n-   list of container nodes (struct bitmap_element_def).  Each node consists\n+   list of container nodes (struct bitmap_element).  Each node consists\n    of an index for the first member that could be held in the container,\n    a small array of integers that represent the members in the container,\n    and pointers to the next and previous element in the linked list.  The\n@@ -149,11 +149,11 @@ typedef unsigned long BITMAP_WORD;\n #define BITMAP_ELEMENT_ALL_BITS (BITMAP_ELEMENT_WORDS * BITMAP_WORD_BITS)\n \n /* Obstack for allocating bitmaps and elements from.  */\n-typedef struct GTY (()) bitmap_obstack {\n-  struct bitmap_element_def *elements;\n-  struct bitmap_head_def *heads;\n+struct GTY (()) bitmap_obstack {\n+  struct bitmap_element *elements;\n+  struct bitmap_head *heads;\n   struct obstack GTY ((skip)) obstack;\n-} bitmap_obstack;\n+};\n \n /* Bitmap set element.  We use a linked list to hold only the bits that\n    are set.  This allows for use to grow the bitset dynamically without\n@@ -167,17 +167,17 @@ typedef struct GTY (()) bitmap_obstack {\n    bitmap_elt_clear_from to be implemented in unit time rather than\n    linear in the number of elements to be freed.  */\n \n-typedef struct GTY((chain_next (\"%h.next\"), chain_prev (\"%h.prev\"))) bitmap_element_def {\n-  struct bitmap_element_def *next;\t/* Next element.  */\n-  struct bitmap_element_def *prev;\t/* Previous element.  */\n+struct GTY((chain_next (\"%h.next\"), chain_prev (\"%h.prev\"))) bitmap_element {\n+  struct bitmap_element *next;\t/* Next element.  */\n+  struct bitmap_element *prev;\t/* Previous element.  */\n   unsigned int indx;\t\t\t/* regno/BITMAP_ELEMENT_ALL_BITS.  */\n   BITMAP_WORD bits[BITMAP_ELEMENT_WORDS]; /* Bits that are set.  */\n-} bitmap_element;\n+};\n \n /* Head of bitmap linked list.  The 'current' member points to something\n    already pointed to by the chain started by first, so GTY((skip)) it.  */\n \n-typedef struct GTY(()) bitmap_head_def {\n+struct GTY(()) bitmap_head {\n   unsigned int indx;\t\t\t/* Index of last element looked at.  */\n   unsigned int descriptor_id;\t\t/* Unique identifier for the allocation\n \t\t\t\t\t   site of this bitmap, for detailed\n@@ -186,7 +186,7 @@ typedef struct GTY(()) bitmap_head_def {\n   bitmap_element * GTY((skip(\"\"))) current; /* Last element looked at.  */\n   bitmap_obstack *obstack;\t\t/* Obstack to allocate elements from.\n \t\t\t\t\t   If NULL, then use GGC allocation.  */\n-} bitmap_head;\n+};\n \n /* Global data */\n extern bitmap_element bitmap_zero_bits;\t/* Zero bitmap element */\n@@ -293,8 +293,8 @@ inline void dump_bitmap (FILE *file, const_bitmap map)\n {\n   bitmap_print (file, map, \"\", \"\\n\");\n }\n-extern void debug (const bitmap_head_def &ref);\n-extern void debug (const bitmap_head_def *ptr);\n+extern void debug (const bitmap_head &ref);\n+extern void debug (const bitmap_head *ptr);\n \n extern unsigned bitmap_first_set_bit (const_bitmap);\n extern unsigned bitmap_last_set_bit (const_bitmap);\n@@ -314,7 +314,7 @@ extern hashval_t bitmap_hash (const_bitmap);\n \n /* Iterator for bitmaps.  */\n \n-typedef struct\n+struct bitmap_iterator\n {\n   /* Pointer to the current bitmap element.  */\n   bitmap_element *elt1;\n@@ -329,7 +329,7 @@ typedef struct\n      it is shifted right, so that the actual bit is always the least\n      significant bit of ACTUAL.  */\n   BITMAP_WORD bits;\n-} bitmap_iterator;\n+};\n \n /* Initialize a single bitmap iterator.  START_BIT is the first bit to\n    iterate from.  */"}, {"sha": "0a88da3889e3faece9fd248aa491a8901a429539", "filename": "gcc/cgraph.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=84562394e219201bf8782ca928ad42b40aef0dd3", "patch": "@@ -502,25 +502,25 @@ typedef struct varpool_node_set_def *varpool_node_set;\n \n \n /* Iterator structure for cgraph node sets.  */\n-typedef struct\n+struct cgraph_node_set_iterator\n {\n   cgraph_node_set set;\n   unsigned index;\n-} cgraph_node_set_iterator;\n+};\n \n /* Iterator structure for varpool node sets.  */\n-typedef struct\n+struct varpool_node_set_iterator\n {\n   varpool_node_set set;\n   unsigned index;\n-} varpool_node_set_iterator;\n+};\n \n #define DEFCIFCODE(code, string)\tCIF_ ## code,\n /* Reasons for inlining failures.  */\n-typedef enum cgraph_inline_failed_enum {\n+enum cgraph_inline_failed_t {\n #include \"cif-code.def\"\n   CIF_N_REASONS\n-} cgraph_inline_failed_t;\n+};\n \n /* Structure containing additional information about an indirect call.  */\n \n@@ -575,7 +575,7 @@ struct GTY((chain_next (\"%h.next_caller\"), chain_prev (\"%h.prev_caller\"))) cgrap\n   PTR GTY ((skip (\"\"))) aux;\n   /* When equal to CIF_OK, inline this call.  Otherwise, points to the\n      explanation why function was not inlined.  */\n-  cgraph_inline_failed_t inline_failed;\n+  enum cgraph_inline_failed_t inline_failed;\n   /* The stmt_uid of call_stmt.  This is used by LTO to recover the call_stmt\n      when the function is serialized in.  */\n   unsigned int lto_stmt_uid;"}, {"sha": "0798bc62a5e36375074e51a3b6dd848bbd457827", "filename": "gcc/conditions.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fconditions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fconditions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconditions.h?ref=84562394e219201bf8782ca928ad42b40aef0dd3", "patch": "@@ -51,7 +51,7 @@ along with GCC; see the file COPYING3.  If not see\n #define CC_STATUS_MDEP_INIT 0\n #endif\n \n-typedef struct {int flags; rtx value1, value2; CC_STATUS_MDEP mdep;} CC_STATUS;\n+struct CC_STATUS {int flags; rtx value1, value2; CC_STATUS_MDEP mdep;};\n \n /* While outputting an insn as assembler code,\n    this is the status BEFORE that insn.  */"}, {"sha": "03033e91528b84a2bc08a669401140115b6d0057", "filename": "gcc/config/frv/frv-protos.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fconfig%2Ffrv%2Ffrv-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fconfig%2Ffrv%2Ffrv-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv-protos.h?ref=84562394e219201bf8782ca928ad42b40aef0dd3", "patch": "@@ -62,14 +62,14 @@ extern rtx frv_split_abs\t\t(rtx *);\n extern void frv_split_double_load\t(rtx, rtx);\n extern void frv_split_double_store\t(rtx, rtx);\n #ifdef BB_HEAD\n-extern void frv_ifcvt_init_extra_fields\t(ce_if_block_t *);\n-extern void frv_ifcvt_modify_tests\t(ce_if_block_t *, rtx *, rtx *);\n+extern void frv_ifcvt_init_extra_fields\t(ce_if_block *);\n+extern void frv_ifcvt_modify_tests\t(ce_if_block *, rtx *, rtx *);\n extern void frv_ifcvt_modify_multiple_tests\n-\t\t\t\t\t(ce_if_block_t *, basic_block,\n+\t\t\t\t\t(ce_if_block *, basic_block,\n \t\t\t\t\t rtx *, rtx *);\n-extern rtx frv_ifcvt_modify_insn\t(ce_if_block_t *, rtx, rtx);\n-extern void frv_ifcvt_modify_final\t(ce_if_block_t *);\n-extern void frv_ifcvt_modify_cancel\t(ce_if_block_t *);\n+extern rtx frv_ifcvt_modify_insn\t(ce_if_block *, rtx, rtx);\n+extern void frv_ifcvt_modify_final\t(ce_if_block *);\n+extern void frv_ifcvt_modify_cancel\t(ce_if_block *);\n #endif\n extern enum reg_class frv_secondary_reload_class\n \t\t\t\t\t(enum reg_class,"}, {"sha": "8d659fe05c2bcdbddcfebcb7ff0b13ae21f7ac89", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=84562394e219201bf8782ca928ad42b40aef0dd3", "patch": "@@ -5272,7 +5272,7 @@ frv_ifcvt_add_insn (rtx pattern, rtx insn, int before_p)\n    tests cannot be converted.  */\n \n void\n-frv_ifcvt_modify_tests (ce_if_block_t *ce_info, rtx *p_true, rtx *p_false)\n+frv_ifcvt_modify_tests (ce_if_block *ce_info, rtx *p_true, rtx *p_false)\n {\n   basic_block test_bb = ce_info->test_bb;\t/* test basic block */\n   basic_block then_bb = ce_info->then_bb;\t/* THEN */\n@@ -5629,7 +5629,7 @@ frv_ifcvt_modify_tests (ce_if_block_t *ce_info, rtx *p_true, rtx *p_false)\n \t\t    (const_int 0))) */\n \n void\n-frv_ifcvt_modify_multiple_tests (ce_if_block_t *ce_info,\n+frv_ifcvt_modify_multiple_tests (ce_if_block *ce_info,\n                                  basic_block bb,\n                                  rtx *p_true,\n                                  rtx *p_false)\n@@ -5923,7 +5923,7 @@ single_set_pattern (rtx pattern)\n    insn cannot be converted to be executed conditionally.  */\n \n rtx\n-frv_ifcvt_modify_insn (ce_if_block_t *ce_info,\n+frv_ifcvt_modify_insn (ce_if_block *ce_info,\n                        rtx pattern,\n                        rtx insn)\n {\n@@ -6188,7 +6188,7 @@ frv_ifcvt_modify_insn (ce_if_block_t *ce_info,\n    conditional if information CE_INFO.  */\n \n void\n-frv_ifcvt_modify_final (ce_if_block_t *ce_info ATTRIBUTE_UNUSED)\n+frv_ifcvt_modify_final (ce_if_block *ce_info ATTRIBUTE_UNUSED)\n {\n   rtx existing_insn;\n   rtx check_insn;\n@@ -6243,7 +6243,7 @@ frv_ifcvt_modify_final (ce_if_block_t *ce_info ATTRIBUTE_UNUSED)\n    information CE_INFO.  */\n \n void\n-frv_ifcvt_modify_cancel (ce_if_block_t *ce_info ATTRIBUTE_UNUSED)\n+frv_ifcvt_modify_cancel (ce_if_block *ce_info ATTRIBUTE_UNUSED)\n {\n   int i;\n   rtx p = frv_ifcvt.added_insns_list;"}, {"sha": "dddaa46e7814239c12f709cc28445f6cbba4dfdf", "filename": "gcc/coretypes.h", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fcoretypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fcoretypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoretypes.h?ref=84562394e219201bf8782ca928ad42b40aef0dd3", "patch": "@@ -46,9 +46,9 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n typedef HOST_WIDEST_INT gcov_type;\n typedef unsigned HOST_WIDEST_INT gcov_type_unsigned;\n \n-struct bitmap_head_def;\n-typedef struct bitmap_head_def *bitmap;\n-typedef const struct bitmap_head_def *const_bitmap;\n+struct bitmap_head;\n+typedef struct bitmap_head *bitmap;\n+typedef const struct bitmap_head *const_bitmap;\n struct simple_bitmap_def;\n typedef struct simple_bitmap_def *sbitmap;\n typedef const struct simple_bitmap_def *const_sbitmap;\n@@ -64,8 +64,7 @@ typedef const union tree_node *const_tree;\n typedef struct gimple_statement_base *gimple;\n typedef const struct gimple_statement_base *const_gimple;\n typedef gimple gimple_seq;\n-struct gimple_stmt_iterator_d;\n-typedef struct gimple_stmt_iterator_d gimple_stmt_iterator;\n+struct gimple_stmt_iterator;\n union section;\n typedef union section section;\n struct gcc_options;"}, {"sha": "541db8eaba489e94eaf9403d8305358a2df2e941", "filename": "gcc/cselib.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fcselib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fcselib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.h?ref=84562394e219201bf8782ca928ad42b40aef0dd3", "patch": "@@ -18,7 +18,7 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n /* Describe a value.  */\n-typedef struct cselib_val_struct {\n+struct cselib_val {\n   /* The hash value.  */\n   unsigned int hash;\n \n@@ -36,8 +36,8 @@ typedef struct cselib_val_struct {\n      use it as an address in a MEM.  */\n   struct elt_list *addr_list;\n \n-  struct cselib_val_struct *next_containing_mem;\n-} cselib_val;\n+  struct cselib_val *next_containing_mem;\n+};\n \n /* A list of rtl expressions that hold the same value.  */\n struct elt_loc_list {"}, {"sha": "739ff030d2778babc35411269ef16f550d16b260", "filename": "gcc/ddg.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fddg.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fddg.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fddg.h?ref=84562394e219201bf8782ca928ad42b40aef0dd3", "patch": "@@ -33,9 +33,8 @@ typedef struct ddg *ddg_ptr;\n typedef struct ddg_scc *ddg_scc_ptr;\n typedef struct ddg_all_sccs *ddg_all_sccs_ptr;\n \n-typedef enum {TRUE_DEP, OUTPUT_DEP, ANTI_DEP} dep_type;\n-typedef enum {REG_OR_MEM_DEP, REG_DEP, MEM_DEP, REG_AND_MEM_DEP}\n-\t     dep_data_type;\n+enum dep_type {TRUE_DEP, OUTPUT_DEP, ANTI_DEP};\n+enum dep_data_type {REG_OR_MEM_DEP, REG_DEP, MEM_DEP, REG_AND_MEM_DEP};\n \n /* The following two macros enables direct access to the successors and\n    predecessors bitmaps held in each ddg_node.  Do not make changes to"}, {"sha": "49cb8c00b0e46d4f3132d3b1c00f1a47eecbbb91", "filename": "gcc/diagnostic.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fdiagnostic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fdiagnostic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.h?ref=84562394e219201bf8782ca928ad42b40aef0dd3", "patch": "@@ -27,7 +27,7 @@ along with GCC; see the file COPYING3.  If not see\n /* A diagnostic is described by the MESSAGE to send, the FILE and LINE of\n    its context and its KIND (ice, error, warning, note, ...)  See complete\n    list in diagnostic.def.  */\n-typedef struct diagnostic_info\n+struct diagnostic_info\n {\n   text_info message;\n   location_t location;\n@@ -38,17 +38,17 @@ typedef struct diagnostic_info\n   diagnostic_t kind;\n   /* Which OPT_* directly controls this diagnostic.  */\n   int option_index;\n-} diagnostic_info;\n+};\n \n /* Each time a diagnostic's classification is changed with a pragma,\n    we record the change and the location of the change in an array of\n    these structs.  */\n-typedef struct diagnostic_classification_change_t\n+struct diagnostic_classification_change_t\n {\n   location_t location;\n   int option;\n   diagnostic_t kind;\n-} diagnostic_classification_change_t;\n+};\n \n /*  Forward declarations.  */\n typedef void (*diagnostic_starter_fn) (diagnostic_context *,"}, {"sha": "c4ecd998ddb61ccf66fa65d5d2f77160f2e3c3e4", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=84562394e219201bf8782ca928ad42b40aef0dd3", "patch": "@@ -4357,7 +4357,7 @@ with machine mode @var{mode}.  The default version of this\n hook returns true for both @code{ptr_mode} and @code{Pmode}.\n @end deftypefn\n \n-@deftypefn {Target Hook} bool TARGET_REF_MAY_ALIAS_ERRNO (struct ao_ref_s *@var{ref})\n+@deftypefn {Target Hook} bool TARGET_REF_MAY_ALIAS_ERRNO (struct ao_ref *@var{ref})\n Define this to return nonzero if the memory reference @var{ref}  may alias with the system C library errno location.  The default  version of this hook assumes the system C library errno location  is either a declaration of type int or accessed by dereferencing  a pointer to int.\n @end deftypefn\n "}, {"sha": "330836b66e88f550fc47ec8662159c3f5f13566a", "filename": "gcc/dwarf2cfi.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fdwarf2cfi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fdwarf2cfi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2cfi.c?ref=84562394e219201bf8782ca928ad42b40aef0dd3", "patch": "@@ -460,9 +460,9 @@ update_row_reg_save (dw_cfi_row *row, unsigned column, dw_cfi_ref cfi)\n    descriptor sequence.  */\n \n static void\n-get_cfa_from_loc_descr (dw_cfa_location *cfa, struct dw_loc_descr_struct *loc)\n+get_cfa_from_loc_descr (dw_cfa_location *cfa, struct dw_loc_descr_node *loc)\n {\n-  struct dw_loc_descr_struct *ptr;\n+  struct dw_loc_descr_node *ptr;\n   cfa->offset = 0;\n   cfa->base_offset = 0;\n   cfa->indirect = 0;\n@@ -755,7 +755,7 @@ def_cfa_0 (dw_cfa_location *old_cfa, dw_cfa_location *new_cfa)\n       /* Construct a DW_CFA_def_cfa_expression instruction to\n \t calculate the CFA using a full location expression since no\n \t register-offset pair is available.  */\n-      struct dw_loc_descr_struct *loc_list;\n+      struct dw_loc_descr_node *loc_list;\n \n       cfi->dw_cfi_opc = DW_CFA_def_cfa_expression;\n       loc_list = build_cfa_loc (new_cfa, 0);"}, {"sha": "86263a518d3bd34817c7d7e0a1318ac169bf0209", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=84562394e219201bf8782ca928ad42b40aef0dd3", "patch": "@@ -2308,10 +2308,10 @@ output_loc_sequence_raw (dw_loc_descr_ref loc)\n    dw_cfa_location, adding the given OFFSET to the result of the\n    expression.  */\n \n-struct dw_loc_descr_struct *\n+struct dw_loc_descr_node *\n build_cfa_loc (dw_cfa_location *cfa, HOST_WIDE_INT offset)\n {\n-  struct dw_loc_descr_struct *head, *tmp;\n+  struct dw_loc_descr_node *head, *tmp;\n \n   offset += cfa->offset;\n \n@@ -2338,11 +2338,11 @@ build_cfa_loc (dw_cfa_location *cfa, HOST_WIDE_INT offset)\n    the address at OFFSET from the CFA when stack is aligned to\n    ALIGNMENT byte.  */\n \n-struct dw_loc_descr_struct *\n+struct dw_loc_descr_node *\n build_cfa_aligned_loc (dw_cfa_location *cfa,\n \t\t       HOST_WIDE_INT offset, HOST_WIDE_INT alignment)\n {\n-  struct dw_loc_descr_struct *head;\n+  struct dw_loc_descr_node *head;\n   unsigned int dwarf_fp\n     = DWARF_FRAME_REGNUM (HARD_FRAME_POINTER_REGNUM);\n "}, {"sha": "28c4105affd13293e1427a16bd231f34695ffff7", "filename": "gcc/dwarf2out.h", "status": "modified", "additions": 23, "deletions": 29, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fdwarf2out.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fdwarf2out.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.h?ref=84562394e219201bf8782ca928ad42b40aef0dd3", "patch": "@@ -25,9 +25,9 @@ along with GCC; see the file COPYING3.  If not see\n typedef struct die_struct *dw_die_ref;\n typedef const struct die_struct *const_dw_die_ref;\n \n-typedef struct dw_val_struct *dw_val_ref;\n-typedef struct dw_cfi_struct *dw_cfi_ref;\n-typedef struct dw_loc_descr_struct *dw_loc_descr_ref;\n+typedef struct dw_val_node *dw_val_ref;\n+typedef struct dw_cfi_node *dw_cfi_ref;\n+typedef struct dw_loc_descr_node *dw_loc_descr_ref;\n typedef struct dw_loc_list_struct *dw_loc_list_ref;\n \n \n@@ -44,35 +44,33 @@ enum dw_cfi_oprnd_type {\n   dw_cfi_oprnd_loc\n };\n \n-typedef union GTY(()) dw_cfi_oprnd_struct {\n+typedef union GTY(()) {\n   unsigned int GTY ((tag (\"dw_cfi_oprnd_reg_num\"))) dw_cfi_reg_num;\n   HOST_WIDE_INT GTY ((tag (\"dw_cfi_oprnd_offset\"))) dw_cfi_offset;\n   const char * GTY ((tag (\"dw_cfi_oprnd_addr\"))) dw_cfi_addr;\n-  struct dw_loc_descr_struct * GTY ((tag (\"dw_cfi_oprnd_loc\"))) dw_cfi_loc;\n-}\n-dw_cfi_oprnd;\n+  struct dw_loc_descr_node * GTY ((tag (\"dw_cfi_oprnd_loc\"))) dw_cfi_loc;\n+} dw_cfi_oprnd;\n \n-typedef struct GTY(()) dw_cfi_struct {\n+struct GTY(()) dw_cfi_node {\n   enum dwarf_call_frame_info dw_cfi_opc;\n   dw_cfi_oprnd GTY ((desc (\"dw_cfi_oprnd1_desc (%1.dw_cfi_opc)\")))\n     dw_cfi_oprnd1;\n   dw_cfi_oprnd GTY ((desc (\"dw_cfi_oprnd2_desc (%1.dw_cfi_opc)\")))\n     dw_cfi_oprnd2;\n-}\n-dw_cfi_node;\n+};\n \n \n typedef vec<dw_cfi_ref, va_gc> *cfi_vec;\n \n-typedef struct dw_fde_struct *dw_fde_ref;\n+typedef struct dw_fde_node *dw_fde_ref;\n \n /* All call frame descriptions (FDE's) in the GCC generated DWARF\n    refer to a single Common Information Entry (CIE), defined at\n    the beginning of the .debug_frame section.  This use of a single\n    CIE obviates the need to keep track of multiple CIE's\n    in the DWARF generation routines below.  */\n \n-typedef struct GTY(()) dw_fde_struct {\n+struct GTY(()) dw_fde_node {\n   tree decl;\n   const char *dw_fde_begin;\n   const char *dw_fde_current_label;\n@@ -105,23 +103,22 @@ typedef struct GTY(()) dw_fde_struct {\n   /* True iff dw_fde_second_begin label is in text_section or\n      cold_text_section.  */\n   unsigned second_in_std_section : 1;\n-}\n-dw_fde_node;\n+};\n \n \n /* This is how we define the location of the CFA. We use to handle it\n    as REG + OFFSET all the time,  but now it can be more complex.\n    It can now be either REG + CFA_OFFSET or *(REG + BASE_OFFSET) + CFA_OFFSET.\n    Instead of passing around REG and OFFSET, we pass a copy\n    of this structure.  */\n-typedef struct GTY(()) cfa_loc {\n+struct GTY(()) dw_cfa_location {\n   HOST_WIDE_INT offset;\n   HOST_WIDE_INT base_offset;\n   /* REG is in DWARF_FRAME_REGNUM space, *not* normal REGNO space.  */\n   unsigned int reg;\n   BOOL_BITFIELD indirect : 1;  /* 1 if CFA is accessed via a dereference.  */\n   BOOL_BITFIELD in_use : 1;    /* 1 if a saved cfa is stored here.  */\n-} dw_cfa_location;\n+};\n \n \n /* Each DIE may have a series of attribute/value pairs.  Values\n@@ -156,19 +153,18 @@ enum dw_val_class\n \n /* Describe a floating point constant value, or a vector constant value.  */\n \n-typedef struct GTY(()) dw_vec_struct {\n+struct GTY(()) dw_vec_const {\n   unsigned char * GTY((atomic)) array;\n   unsigned length;\n   unsigned elt_size;\n-}\n-dw_vec_const;\n+};\n \n struct addr_table_entry_struct;\n \n /* The dw_val_node describes an attribute's value, as it is\n    represented internally.  */\n \n-typedef struct GTY(()) dw_val_struct {\n+struct GTY(()) dw_val_node {\n   enum dw_val_class val_class;\n   struct addr_table_entry_struct * GTY(()) val_entry;\n   union dw_val_struct_union\n@@ -200,13 +196,12 @@ typedef struct GTY(()) dw_val_struct {\n \t} GTY ((tag (\"dw_val_class_vms_delta\"))) val_vms_delta;\n     }\n   GTY ((desc (\"%1.val_class\"))) v;\n-}\n-dw_val_node;\n+};\n \n /* Locations in memory are described using a sequence of stack machine\n    operations.  */\n \n-typedef struct GTY(()) dw_loc_descr_struct {\n+struct GTY(()) dw_loc_descr_node {\n   dw_loc_descr_ref dw_loc_next;\n   ENUM_BITFIELD (dwarf_location_atom) dw_loc_opc : 8;\n   /* Used to distinguish DW_OP_addr with a direct symbol relocation\n@@ -215,16 +210,15 @@ typedef struct GTY(()) dw_loc_descr_struct {\n   int dw_loc_addr;\n   dw_val_node dw_loc_oprnd1;\n   dw_val_node dw_loc_oprnd2;\n-}\n-dw_loc_descr_node;\n+};\n \n \n /* Interface from dwarf2out.c to dwarf2cfi.c.  */\n-extern struct dw_loc_descr_struct *build_cfa_loc\n+extern struct dw_loc_descr_node *build_cfa_loc\n   (dw_cfa_location *, HOST_WIDE_INT);\n-extern struct dw_loc_descr_struct *build_cfa_aligned_loc\n+extern struct dw_loc_descr_node *build_cfa_aligned_loc\n   (dw_cfa_location *, HOST_WIDE_INT offset, HOST_WIDE_INT alignment);\n-extern struct dw_loc_descr_struct *mem_loc_descriptor\n+extern struct dw_loc_descr_node *mem_loc_descriptor\n   (rtx, enum machine_mode mode, enum machine_mode mem_mode,\n    enum var_init_status);\n extern bool loc_descr_equal_p (dw_loc_descr_ref, dw_loc_descr_ref);\n@@ -249,7 +243,7 @@ extern enum dw_cfi_oprnd_type dw_cfi_oprnd1_desc\n extern enum dw_cfi_oprnd_type dw_cfi_oprnd2_desc\n   (enum dwarf_call_frame_info cfi);\n \n-extern void output_cfi_directive (FILE *f, struct dw_cfi_struct *cfi);\n+extern void output_cfi_directive (FILE *f, struct dw_cfi_node *cfi);\n \n extern void dwarf2out_decl (tree);\n extern void dwarf2out_emit_cfi (dw_cfi_ref cfi);"}, {"sha": "c84285d75faadbe9cbb67b50d4f5437c958c51ac", "filename": "gcc/function.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=84562394e219201bf8782ca928ad42b40aef0dd3", "patch": "@@ -165,7 +165,7 @@ struct gimple_df;\n struct temp_slot;\n typedef struct temp_slot *temp_slot_p;\n struct call_site_record_d;\n-struct dw_fde_struct;\n+struct dw_fde_node;\n \n class ipa_opt_pass_d;\n typedef ipa_opt_pass_d *ipa_opt_pass;\n@@ -569,7 +569,7 @@ struct GTY(()) function {\n   /* Dwarf2 Frame Description Entry, containing the Call Frame Instructions\n      used for unwinding.  Only set when either dwarf2 unwinding or dwarf2\n      debugging is enabled.  */\n-  struct dw_fde_struct *fde;\n+  struct dw_fde_node *fde;\n \n   /* Last statement uid.  */\n   int last_stmt_uid;"}, {"sha": "93b2d4d1cdeee728482826c9301d81f65e329a99", "filename": "gcc/gcov-io.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fgcov-io.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fgcov-io.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.h?ref=84562394e219201bf8782ca928ad42b40aef0dd3", "patch": "@@ -401,15 +401,15 @@ typedef unsigned HOST_WIDEST_INT gcov_type_unsigned;\n /* Structured records.  */\n \n /* Structure used for each bucket of the log2 histogram of counter values.  */\n-typedef struct\n+struct gcov_bucket_type\n {\n   /* Number of counters whose profile count falls within the bucket.  */\n   gcov_unsigned_t num_counters;\n   /* Smallest profile count included in this bucket.  */\n   gcov_type min_value;\n   /* Cumulative value of the profile counts in this bucket.  */\n   gcov_type cum_value;\n-} gcov_bucket_type;\n+};\n \n /* For a log2 scale histogram with each range split into 4\n    linear sub-ranges, there will be at most 64 (max gcov_type bit size) - 1 log2\n@@ -634,13 +634,13 @@ GCOV_LINKAGE void gcov_write_length (gcov_position_t /*position*/);\n \n /* Working set size statistics for a given percentage of the entire\n    profile (sum_all from the counter summary).  */\n-typedef struct gcov_working_set_info\n+struct gcov_working_set_t\n {\n   /* Number of hot counters included in this working set.  */\n   unsigned num_counters;\n   /* Smallest counter included in this working set.  */\n   gcov_type min_counter;\n-} gcov_working_set_t;\n+};\n \n GCOV_LINKAGE void compute_working_sets (const struct gcov_ctr_summary *summary,\n                                         gcov_working_set_t *gcov_working_sets);"}, {"sha": "3d1f3ddd1d2c72b6badf0a6f8bae775d7520359a", "filename": "gcc/ggc-internal.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fggc-internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fggc-internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-internal.h?ref=84562394e219201bf8782ca928ad42b40aef0dd3", "patch": "@@ -106,11 +106,11 @@ extern size_t ggc_get_size (const void *);\n \n /* This structure contains the statistics common to all collectors.\n    Particular collectors can extend this structure.  */\n-typedef struct ggc_statistics\n+struct ggc_statistics\n {\n   /* At present, we don't really gather any interesting statistics.  */\n   int unused;\n-} ggc_statistics;\n+};\n \n /* Used by the various collectors to gather and print statistics that\n    do not depend on the collector in use.  */"}, {"sha": "7c801e32b4e0f2d5ec9eb31c0410df63bc61c1f6", "filename": "gcc/gimple-iterator.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fgimple-iterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fgimple-iterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-iterator.h?ref=84562394e219201bf8782ca928ad42b40aef0dd3", "patch": "@@ -22,7 +22,7 @@ along with GCC; see the file COPYING3.  If not see\n \n /* Iterator object for GIMPLE statement sequences.  */\n \n-typedef struct gimple_stmt_iterator_d\n+struct gimple_stmt_iterator\n {\n   /* Sequence node holding the current statement.  */\n   gimple_seq_node ptr;\n@@ -33,7 +33,7 @@ typedef struct gimple_stmt_iterator_d\n      block/sequence is removed.  */\n   gimple_seq *seq;\n   basic_block bb;\n-} gimple_stmt_iterator;\n+};\n  \n enum gsi_iterator_update\n {"}, {"sha": "e3db1e89132ca2c034dd60186320b5b5d83f2927", "filename": "gcc/graphite-clast-to-gimple.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fgraphite-clast-to-gimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fgraphite-clast-to-gimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-clast-to-gimple.h?ref=84562394e219201bf8782ca928ad42b40aef0dd3", "patch": "@@ -25,18 +25,18 @@ extern CloogState *cloog_state;\n \n /* Data structure for CLooG program representation.  */\n \n-typedef struct cloog_prog_clast {\n+struct cloog_prog_clast {\n   CloogProgram *prog;\n   struct clast_stmt *stmt;\n-} cloog_prog_clast;\n+};\n \n /* Stores BB's related PBB.  */\n \n-typedef struct bb_pbb_def\n+struct bb_pbb_def\n {\n   basic_block bb;\n   poly_bb_p pbb;\n-} bb_pbb_def;\n+};\n \n extern void debug_clast_stmt (struct clast_stmt *);\n extern void print_clast_stmt (FILE *, struct clast_stmt *);"}, {"sha": "008e86b9bd875d0f14c0ca52057f7e1536d72050", "filename": "gcc/graphite-sese-to-poly.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fgraphite-sese-to-poly.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fgraphite-sese-to-poly.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-sese-to-poly.h?ref=84562394e219201bf8782ca928ad42b40aef0dd3", "patch": "@@ -21,7 +21,6 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_GRAPHITE_SESE_TO_POLY_H\n #define GCC_GRAPHITE_SESE_TO_POLY_H\n \n-typedef struct base_alias_pair base_alias_pair;\n struct base_alias_pair\n {\n   int base_obj_set;"}, {"sha": "ad987f9b35467e5137416e9e8bb463756c80c7c0", "filename": "gcc/hard-reg-set.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fhard-reg-set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fhard-reg-set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhard-reg-set.h?ref=84562394e219201bf8782ca928ad42b40aef0dd3", "patch": "@@ -488,7 +488,7 @@ hard_reg_set_empty_p (const HARD_REG_SET x)\n \n /* Iterator for hard register sets.  */\n \n-typedef struct\n+struct hard_reg_set_iterator\n {\n   /* Pointer to the current element.  */\n   HARD_REG_ELT_TYPE *pelt;\n@@ -503,7 +503,7 @@ typedef struct\n      it is shifted right, so that the actual bit is always the least\n      significant bit of ACTUAL.  */\n   HARD_REG_ELT_TYPE bits;\n-} hard_reg_set_iterator;\n+};\n \n #define HARD_REG_ELT_BITS UHOST_BITS_PER_WIDE_INT\n "}, {"sha": "569b9bf46c4fbdac9914f9cf5084b5dc75b84543", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=84562394e219201bf8782ca928ad42b40aef0dd3", "patch": "@@ -91,16 +91,16 @@ static rtx last_active_insn (basic_block, int);\n static rtx find_active_insn_before (basic_block, rtx);\n static rtx find_active_insn_after (basic_block, rtx);\n static basic_block block_fallthru (basic_block);\n-static int cond_exec_process_insns (ce_if_block_t *, rtx, rtx, rtx, int, int);\n+static int cond_exec_process_insns (ce_if_block *, rtx, rtx, rtx, int, int);\n static rtx cond_exec_get_condition (rtx);\n static rtx noce_get_condition (rtx, rtx *, bool);\n static int noce_operand_ok (const_rtx);\n-static void merge_if_block (ce_if_block_t *);\n+static void merge_if_block (ce_if_block *);\n static int find_cond_trap (basic_block, edge, edge);\n static basic_block find_if_header (basic_block, int);\n static int block_jumps_and_fallthru_p (basic_block, basic_block);\n static int noce_find_if_block (basic_block, edge, edge, int);\n-static int cond_exec_find_if_block (ce_if_block_t *);\n+static int cond_exec_find_if_block (ce_if_block *);\n static int find_if_case_1 (basic_block, edge, edge);\n static int find_if_case_2 (basic_block, edge, edge);\n static int dead_or_predicable (basic_block, basic_block, basic_block,\n@@ -312,7 +312,7 @@ block_fallthru (basic_block bb)\n    insns were processed.  */\n \n static int\n-cond_exec_process_insns (ce_if_block_t *ce_info ATTRIBUTE_UNUSED,\n+cond_exec_process_insns (ce_if_block *ce_info ATTRIBUTE_UNUSED,\n \t\t\t /* if block information */rtx start,\n \t\t\t /* first insn to look at */rtx end,\n \t\t\t /* last insn to look at */rtx test,\n@@ -434,7 +434,7 @@ cond_exec_get_condition (rtx jump)\n    converting the block.  */\n \n static int\n-cond_exec_process_if_block (ce_if_block_t * ce_info,\n+cond_exec_process_if_block (ce_if_block * ce_info,\n \t\t\t    /* if block information */int do_multiple_p)\n {\n   basic_block test_bb = ce_info->test_bb;\t/* last test block */\n@@ -3232,7 +3232,7 @@ merge_if_block (struct ce_if_block * ce_info)\n static basic_block\n find_if_header (basic_block test_bb, int pass)\n {\n-  ce_if_block_t ce_info;\n+  ce_if_block ce_info;\n   edge then_edge;\n   edge else_edge;\n "}, {"sha": "305ad2d72dbd8860d1463fb55d53b8eee397eaa6", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=84562394e219201bf8782ca928ad42b40aef0dd3", "patch": "@@ -1688,10 +1688,10 @@ good_cloning_opportunity_p (struct cgraph_node *node, int time_benefit,\n /* Return all context independent values from aggregate lattices in PLATS in a\n    vector.  Return NULL if there are none.  */\n \n-static vec<ipa_agg_jf_item_t, va_gc> *\n+static vec<ipa_agg_jf_item, va_gc> *\n context_independent_aggregate_values (struct ipcp_param_lattices *plats)\n {\n-  vec<ipa_agg_jf_item_t, va_gc> *res = NULL;\n+  vec<ipa_agg_jf_item, va_gc> *res = NULL;\n \n   if (plats->aggs_bottom\n       || plats->aggs_contain_variable\n@@ -1720,7 +1720,7 @@ static bool\n gather_context_independent_values (struct ipa_node_params *info,\n \t\t\t       vec<tree> *known_csts,\n \t\t\t       vec<tree> *known_binfos,\n-\t\t\t       vec<ipa_agg_jump_function_t> *known_aggs,\n+\t\t\t       vec<ipa_agg_jump_function> *known_aggs,\n \t\t\t       int *removable_params_cost)\n {\n   int i, count = ipa_get_param_count (info);\n@@ -1771,7 +1771,7 @@ gather_context_independent_values (struct ipa_node_params *info,\n \n       if (known_aggs)\n \t{\n-\t  vec<ipa_agg_jf_item_t, va_gc> *agg_items;\n+\t  vec<ipa_agg_jf_item, va_gc> *agg_items;\n \t  struct ipa_agg_jump_function *ajf;\n \n \t  agg_items = context_independent_aggregate_values (plats);\n@@ -1793,7 +1793,7 @@ gather_context_independent_values (struct ipa_node_params *info,\n    issue.  */\n \n static vec<ipa_agg_jump_function_p>\n-agg_jmp_p_vec_for_t_vec (vec<ipa_agg_jump_function_t> known_aggs)\n+agg_jmp_p_vec_for_t_vec (vec<ipa_agg_jump_function> known_aggs)\n {\n   vec<ipa_agg_jump_function_p> ret;\n   struct ipa_agg_jump_function *ajf;\n@@ -1814,7 +1814,7 @@ estimate_local_effects (struct cgraph_node *node)\n   struct ipa_node_params *info = IPA_NODE_REF (node);\n   int i, count = ipa_get_param_count (info);\n   vec<tree> known_csts, known_binfos;\n-  vec<ipa_agg_jump_function_t> known_aggs;\n+  vec<ipa_agg_jump_function> known_aggs;\n   vec<ipa_agg_jump_function_p> known_aggs_ptrs;\n   bool always_const;\n   int base_time = inline_summary (node)->time;\n@@ -2772,10 +2772,10 @@ find_more_scalar_values_for_callers_subset (struct cgraph_node *node,\n /* Go through PLATS and create a vector of values consisting of values and\n    offsets (minus OFFSET) of lattices that contain only a single value.  */\n \n-static vec<ipa_agg_jf_item_t>\n+static vec<ipa_agg_jf_item>\n copy_plats_to_inter (struct ipcp_param_lattices *plats, HOST_WIDE_INT offset)\n {\n-  vec<ipa_agg_jf_item_t> res = vNULL;\n+  vec<ipa_agg_jf_item> res = vNULL;\n \n   if (!plats->aggs || plats->aggs_contain_variable || plats->aggs_bottom)\n     return vNULL;\n@@ -2796,7 +2796,7 @@ copy_plats_to_inter (struct ipcp_param_lattices *plats, HOST_WIDE_INT offset)\n \n static void\n intersect_with_plats (struct ipcp_param_lattices *plats,\n-\t\t      vec<ipa_agg_jf_item_t> *inter,\n+\t\t      vec<ipa_agg_jf_item> *inter,\n \t\t      HOST_WIDE_INT offset)\n {\n   struct ipcp_agg_lattice *aglat;\n@@ -2836,12 +2836,12 @@ intersect_with_plats (struct ipcp_param_lattices *plats,\n /* Copy agggregate replacement values of NODE (which is an IPA-CP clone) to the\n    vector result while subtracting OFFSET from the individual value offsets.  */\n \n-static vec<ipa_agg_jf_item_t>\n+static vec<ipa_agg_jf_item>\n agg_replacements_to_vector (struct cgraph_node *node, int index,\n \t\t\t    HOST_WIDE_INT offset)\n {\n   struct ipa_agg_replacement_value *av;\n-  vec<ipa_agg_jf_item_t> res = vNULL;\n+  vec<ipa_agg_jf_item> res = vNULL;\n \n   for (av = ipa_get_agg_replacements_for_node (node); av; av = av->next)\n     if (av->index == index\n@@ -2863,7 +2863,7 @@ agg_replacements_to_vector (struct cgraph_node *node, int index,\n \n static void\n intersect_with_agg_replacements (struct cgraph_node *node, int index,\n-\t\t\t\t vec<ipa_agg_jf_item_t> *inter,\n+\t\t\t\t vec<ipa_agg_jf_item> *inter,\n \t\t\t\t HOST_WIDE_INT offset)\n {\n   struct ipa_agg_replacement_value *srcvals;\n@@ -2904,9 +2904,9 @@ intersect_with_agg_replacements (struct cgraph_node *node, int index,\n    copy all incoming values to it.  If we determine we ended up with no values\n    whatsoever, return a released vector.  */\n \n-static vec<ipa_agg_jf_item_t>\n+static vec<ipa_agg_jf_item>\n intersect_aggregates_with_edge (struct cgraph_edge *cs, int index,\n-\t\t\t\tvec<ipa_agg_jf_item_t> inter)\n+\t\t\t\tvec<ipa_agg_jf_item> inter)\n {\n   struct ipa_jump_func *jfunc;\n   jfunc = ipa_get_ith_jump_func (IPA_EDGE_REF (cs), index);\n@@ -3015,7 +3015,7 @@ intersect_aggregates_with_edge (struct cgraph_edge *cs, int index,\n   else\n     {\n       inter.release ();\n-      return vec<ipa_agg_jf_item_t>();\n+      return vec<ipa_agg_jf_item>();\n     }\n   return inter;\n }\n@@ -3042,7 +3042,7 @@ find_aggregate_values_for_callers_subset (struct cgraph_node *node,\n   for (i = 0; i < count ; i++)\n     {\n       struct cgraph_edge *cs;\n-      vec<ipa_agg_jf_item_t> inter = vNULL;\n+      vec<ipa_agg_jf_item> inter = vNULL;\n       struct ipa_agg_jf_item *item;\n       struct ipcp_param_lattices *plats = ipa_get_parm_lattices (dest_info, i);\n       int j;\n@@ -3086,7 +3086,7 @@ find_aggregate_values_for_callers_subset (struct cgraph_node *node,\n /* Turn KNOWN_AGGS into a list of aggreate replacement values.  */\n \n static struct ipa_agg_replacement_value *\n-known_aggs_to_agg_replacement_list (vec<ipa_agg_jump_function_t> known_aggs)\n+known_aggs_to_agg_replacement_list (vec<ipa_agg_jump_function> known_aggs)\n {\n   struct ipa_agg_replacement_value *res = NULL;\n   struct ipa_agg_jump_function *aggjf;\n@@ -3168,7 +3168,7 @@ cgraph_edge_brings_all_agg_vals_for_node (struct cgraph_edge *cs,\n \n   for (i = 0; i < count; i++)\n     {\n-      static vec<ipa_agg_jf_item_t> values = vec<ipa_agg_jf_item_t>();\n+      static vec<ipa_agg_jf_item> values = vec<ipa_agg_jf_item>();\n       struct ipcp_param_lattices *plats;\n       bool interesting = false;\n       for (struct ipa_agg_replacement_value *av = aggval; av; av = av->next)\n@@ -3379,7 +3379,7 @@ decide_whether_version_node (struct cgraph_node *node)\n   struct ipa_node_params *info = IPA_NODE_REF (node);\n   int i, count = ipa_get_param_count (info);\n   vec<tree> known_csts, known_binfos;\n-  vec<ipa_agg_jump_function_t> known_aggs = vNULL;\n+  vec<ipa_agg_jump_function> known_aggs = vNULL;\n   bool ret = false;\n \n   if (count == 0)"}, {"sha": "9e9087f30db1fc982ddee33fec5a832f1f78b9ac", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=84562394e219201bf8782ca928ad42b40aef0dd3", "patch": "@@ -494,7 +494,7 @@ evaluate_predicate (struct predicate *p, clause_t possible_truths)\n static int\n predicate_probability (conditions conds,\n \t\t       struct predicate *p, clause_t possible_truths,\n-\t\t       vec<inline_param_summary_t> inline_param_summary)\n+\t\t       vec<inline_param_summary> inline_param_summary)\n {\n   int i;\n   int combined_prob = REG_BR_PROB_BASE;\n@@ -2983,7 +2983,7 @@ estimate_node_size_and_time (struct cgraph_node *node,\n \t\t\t     vec<ipa_agg_jump_function_p> known_aggs,\n \t\t\t     int *ret_size, int *ret_time,\n \t\t\t     inline_hints *ret_hints,\n-\t\t\t     vec<inline_param_summary_t>\n+\t\t\t     vec<inline_param_summary>\n \t\t\t     inline_param_summary)\n {\n   struct inline_summary *info = inline_summary (node);"}, {"sha": "14ee4bf73354749a5df7b0f95fce185a320fa784", "filename": "gcc/ipa-inline.h", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fipa-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fipa-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.h?ref=84562394e219201bf8782ca928ad42b40aef0dd3", "patch": "@@ -27,21 +27,21 @@ along with GCC; see the file COPYING3.  If not see\n    vector.  They are of simple for  function_param OP VAL, where VAL is\n    IPA invariant.  The conditions are then referred by predicates.  */\n \n-typedef struct GTY(()) condition\n-  {\n-    /* If agg_contents is set, this is the offset from which the used data was\n-       loaded.  */\n-    HOST_WIDE_INT offset;\n-    tree val;\n-    int operand_num;\n-    ENUM_BITFIELD(tree_code) code : 16;\n-    /* Set if the used data were loaded from an aggregate parameter or from\n-       data received by reference.  */\n-    unsigned agg_contents : 1;\n-    /* If agg_contents is set, this differentiates between loads from data\n-       passed by reference and by value.  */\n-    unsigned by_ref : 1;\n-  } condition;\n+struct GTY(()) condition\n+{\n+  /* If agg_contents is set, this is the offset from which the used data was\n+     loaded.  */\n+  HOST_WIDE_INT offset;\n+  tree val;\n+  int operand_num;\n+  ENUM_BITFIELD(tree_code) code : 16;\n+  /* Set if the used data were loaded from an aggregate parameter or from\n+     data received by reference.  */\n+  unsigned agg_contents : 1;\n+  /* If agg_contents is set, this differentiates between loads from data\n+     passed by reference and by value.  */\n+  unsigned by_ref : 1;\n+};\n \n /* Inline hints are reasons why inline heuristics should preffer inlining given\n    function.  They are represtented as bitmap of the following values.  */\n@@ -99,12 +99,12 @@ struct GTY(()) predicate\n    accounted.  */\n #define INLINE_SIZE_SCALE 2\n #define INLINE_TIME_SCALE (CGRAPH_FREQ_BASE * 2)\n-typedef struct GTY(()) size_time_entry\n+struct GTY(()) size_time_entry\n {\n   struct predicate predicate;\n   int size;\n   int time;\n-} size_time_entry;\n+};\n \n /* Function inlining information.  */\n struct GTY(()) inline_summary\n@@ -156,7 +156,8 @@ struct GTY(()) inline_summary\n   int scc_no;\n };\n \n-\n+/* Need a typedef for inline_summary because of inline function\n+   'inline_summary' below.  */\n typedef struct inline_summary inline_summary_t;\n extern GTY(()) vec<inline_summary_t, va_gc> *inline_summary_vec;\n \n@@ -172,7 +173,6 @@ struct inline_param_summary\n      Value 0 is reserved for compile time invariants. */\n   int change_prob;\n };\n-typedef struct inline_param_summary inline_param_summary_t;\n \n /* Information kept about callgraph edges.  */\n struct inline_edge_summary\n@@ -186,17 +186,19 @@ struct inline_edge_summary\n   /* Array indexed by parameters.\n      0 means that parameter change all the time, REG_BR_PROB_BASE means\n      that parameter is constant.  */\n-  vec<inline_param_summary_t> param;\n+  vec<inline_param_summary> param;\n };\n \n+/* Need a typedef for inline_edge_summary because of inline function\n+   'inline_edge_summary' below.  */\n typedef struct inline_edge_summary inline_edge_summary_t;\n extern vec<inline_edge_summary_t> inline_edge_summary_vec;\n \n-typedef struct edge_growth_cache_entry\n+struct edge_growth_cache_entry\n {\n   int time, size;\n   inline_hints hints;\n-} edge_growth_cache_entry;\n+};\n \n extern vec<int> node_growth_cache;\n extern vec<edge_growth_cache_entry> edge_growth_cache;"}, {"sha": "94266c0ec3e185fc919f80b44396390299fb2e19", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=84562394e219201bf8782ca928ad42b40aef0dd3", "patch": "@@ -68,11 +68,11 @@ struct param_analysis_info\n };\n \n /* Vector where the parameter infos are actually stored. */\n-vec<ipa_node_params_t> ipa_node_params_vector;\n+vec<ipa_node_params> ipa_node_params_vector;\n /* Vector of known aggregate values in cloned nodes.  */\n vec<ipa_agg_replacement_value_p, va_gc> *ipa_node_agg_replacements;\n /* Vector where the parameter infos are actually stored. */\n-vec<ipa_edge_args_t, va_gc> *ipa_edge_args_vector;\n+vec<ipa_edge_args, va_gc> *ipa_edge_args_vector;\n \n /* Holders of ipa cgraph hooks: */\n static struct cgraph_edge_hook_list *edge_removal_hook_holder;\n@@ -116,7 +116,7 @@ ipa_func_spec_opts_forbid_analysis_p (struct cgraph_node *node)\n    to INFO.  */\n \n static int\n-ipa_get_param_decl_index_1 (vec<ipa_param_descriptor_t> descriptors, tree ptree)\n+ipa_get_param_decl_index_1 (vec<ipa_param_descriptor> descriptors, tree ptree)\n {\n   int i, count;\n \n@@ -142,7 +142,7 @@ ipa_get_param_decl_index (struct ipa_node_params *info, tree ptree)\n \n static void\n ipa_populate_param_decls (struct cgraph_node *node,\n-\t\t\t  vec<ipa_param_descriptor_t> &descriptors)\n+\t\t\t  vec<ipa_param_descriptor> &descriptors)\n {\n   tree fndecl;\n   tree fnargs;\n@@ -775,7 +775,7 @@ parm_preserved_before_stmt_p (struct param_analysis_info *parm_ainfo,\n    modified.  Otherwise return -1.  */\n \n static int\n-load_from_unmodified_param (vec<ipa_param_descriptor_t> descriptors,\n+load_from_unmodified_param (vec<ipa_param_descriptor> descriptors,\n \t\t\t    struct param_analysis_info *parms_ainfo,\n \t\t\t    gimple stmt)\n {\n@@ -863,7 +863,7 @@ parm_ref_data_pass_through_p (struct param_analysis_info *parm_ainfo,\n    reference respectively.  */\n \n static bool\n-ipa_load_from_parm_agg_1 (vec<ipa_param_descriptor_t> descriptors,\n+ipa_load_from_parm_agg_1 (vec<ipa_param_descriptor> descriptors,\n \t\t\t  struct param_analysis_info *parms_ainfo, gimple stmt,\n \t\t\t  tree op, int *index_p, HOST_WIDE_INT *offset_p,\n \t\t\t  HOST_WIDE_INT *size_p, bool *by_ref_p)\n@@ -4697,7 +4697,7 @@ adjust_agg_replacement_values (struct cgraph_node *node,\n unsigned int\n ipcp_transform_function (struct cgraph_node *node)\n {\n-  vec<ipa_param_descriptor_t> descriptors = vNULL;\n+  vec<ipa_param_descriptor> descriptors = vNULL;\n   struct param_analysis_info *parms_ainfo;\n   struct ipa_agg_replacement_value *aggval;\n   gimple_stmt_iterator gsi;"}, {"sha": "9a987d78a047e863a4aa954b82cf1c8bb089fc81", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 12, "deletions": 19, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=84562394e219201bf8782ca928ad42b40aef0dd3", "patch": "@@ -152,14 +152,14 @@ struct GTY(()) ipa_ancestor_jf_data\n    different, all unlisted parts are assumed to be unknown and all values must\n    fulfill is_gimple_ip_invariant.  */\n \n-typedef struct GTY(()) ipa_agg_jf_item\n+struct GTY(()) ipa_agg_jf_item\n {\n   /* The offset at which the known value is located within the aggregate.  */\n   HOST_WIDE_INT offset;\n \n   /* The known constant or type if this is a clobber.  */\n   tree value;\n-} ipa_agg_jf_item_t;\n+};\n \n \n /* Aggregate jump function - i.e. description of contents of aggregates passed\n@@ -168,18 +168,17 @@ typedef struct GTY(()) ipa_agg_jf_item\n struct GTY(()) ipa_agg_jump_function\n {\n   /* Description of the individual items.  */\n-  vec<ipa_agg_jf_item_t, va_gc> *items;\n+  vec<ipa_agg_jf_item, va_gc> *items;\n   /* True if the data was passed by reference (as opposed to by value). */\n   bool by_ref;\n };\n \n typedef struct ipa_agg_jump_function *ipa_agg_jump_function_p;\n-typedef struct ipa_agg_jump_function ipa_agg_jump_function_t;\n \n /* A jump function for a callsite represents the values passed as actual\n    arguments of the callsite. See enum jump_func_type for the various\n    types of jump functions supported.  */\n-typedef struct GTY (()) ipa_jump_func\n+struct GTY (()) ipa_jump_func\n {\n   /* Aggregate contants description.  See struct ipa_agg_jump_function and its\n      description.  */\n@@ -196,7 +195,7 @@ typedef struct GTY (()) ipa_jump_func\n     struct ipa_pass_through_data GTY ((tag (\"IPA_JF_PASS_THROUGH\"))) pass_through;\n     struct ipa_ancestor_jf_data GTY ((tag (\"IPA_JF_ANCESTOR\"))) ancestor;\n   } GTY ((desc (\"%1.type\"))) value;\n-} ipa_jump_func_t;\n+};\n \n \n /* Return the offset of the component that is described by a known type jump\n@@ -350,7 +349,6 @@ struct ipa_param_descriptor\n   unsigned used : 1;\n };\n \n-typedef struct ipa_param_descriptor ipa_param_descriptor_t;\n struct ipcp_lattice;\n \n /* ipa_node_params stores information related to formal parameters of functions\n@@ -361,7 +359,7 @@ struct ipa_node_params\n {\n   /* Information about individual formal parameters that are gathered when\n      summaries are generated. */\n-  vec<ipa_param_descriptor_t> descriptors;\n+  vec<ipa_param_descriptor> descriptors;\n   /* Pointer to an array of structures describing individual formal\n      parameters.  */\n   struct ipcp_param_lattices *lattices;\n@@ -474,11 +472,11 @@ void ipa_set_node_agg_value_chain (struct cgraph_node *node,\n \n /* ipa_edge_args stores information related to a callsite and particularly its\n    arguments.  It can be accessed by the IPA_EDGE_REF macro.  */\n-typedef struct GTY(()) ipa_edge_args\n+struct GTY(()) ipa_edge_args\n {\n   /* Vector of the callsite's jump function of each parameter.  */\n-  vec<ipa_jump_func_t, va_gc> *jump_functions;\n-} ipa_edge_args_t;\n+  vec<ipa_jump_func, va_gc> *jump_functions;\n+};\n \n /* ipa_edge_args access functions.  Please use these to access fields that\n    are or will be shared among various passes.  */\n@@ -501,17 +499,14 @@ ipa_get_ith_jump_func (struct ipa_edge_args *args, int i)\n   return &(*args->jump_functions)[i];\n }\n \n-/* Vectors need to have typedefs of structures.  */\n-typedef struct ipa_node_params ipa_node_params_t;\n-\n /* Types of vectors holding the infos.  */\n \n /* Vector where the parameter infos are actually stored. */\n-extern vec<ipa_node_params_t> ipa_node_params_vector;\n+extern vec<ipa_node_params> ipa_node_params_vector;\n /* Vector of known aggregate values in cloned nodes.  */\n extern GTY(()) vec<ipa_agg_replacement_value_p, va_gc> *ipa_node_agg_replacements;\n /* Vector where the parameter infos are actually stored. */\n-extern GTY(()) vec<ipa_edge_args_t, va_gc> *ipa_edge_args_vector;\n+extern GTY(()) vec<ipa_edge_args, va_gc> *ipa_edge_args_vector;\n \n /* Return the associated parameter/argument info corresponding to the given\n    node/edge.  */\n@@ -685,9 +680,7 @@ struct ipa_parm_adjustment\n   unsigned by_ref : 1;\n };\n \n-typedef struct ipa_parm_adjustment ipa_parm_adjustment_t;\n-\n-typedef vec<ipa_parm_adjustment_t> ipa_parm_adjustment_vec;\n+typedef vec<ipa_parm_adjustment> ipa_parm_adjustment_vec;\n \n vec<tree> ipa_get_vector_of_formal_parms (tree fndecl);\n vec<tree> ipa_get_vector_of_formal_parm_types (tree fntype);"}, {"sha": "690763c9810b2f137172d3354e86f50f0502c9b8", "filename": "gcc/ira-int.h", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fira-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fira-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-int.h?ref=84562394e219201bf8782ca928ad42b40aef0dd3", "patch": "@@ -688,7 +688,7 @@ extern int ira_move_loops_num, ira_additional_jumps_num;\n #endif\n \n /* The iterator for min/max sets.  */\n-typedef struct {\n+struct minmax_set_iterator {\n \n   /* Array containing the bit vector.  */\n   IRA_INT_TYPE *vec;\n@@ -707,7 +707,7 @@ typedef struct {\n \n   /* The word of the bit vector currently visited.  */\n   unsigned IRA_INT_TYPE word;\n-} minmax_set_iterator;\n+};\n \n /* Initialize the iterator I for bit vector VEC containing minimal and\n    maximal values MIN and MAX.  */\n@@ -1081,10 +1081,10 @@ ira_init_register_move_cost_if_necessary (enum machine_mode mode)\n \f\n \n /* The iterator for all allocnos.  */\n-typedef struct {\n+struct ira_allocno_iterator {\n   /* The number of the current element in IRA_ALLOCNOS.  */\n   int n;\n-} ira_allocno_iterator;\n+};\n \n /* Initialize the iterator I.  */\n static inline void\n@@ -1118,10 +1118,10 @@ ira_allocno_iter_cond (ira_allocno_iterator *i, ira_allocno_t *a)\n        ira_allocno_iter_cond (&(ITER), &(A));)\n \f\n /* The iterator for all objects.  */\n-typedef struct {\n+struct ira_object_iterator {\n   /* The number of the current element in ira_object_id_map.  */\n   int n;\n-} ira_object_iterator;\n+};\n \n /* Initialize the iterator I.  */\n static inline void\n@@ -1155,10 +1155,10 @@ ira_object_iter_cond (ira_object_iterator *i, ira_object_t *obj)\n        ira_object_iter_cond (&(ITER), &(OBJ));)\n \f\n /* The iterator for objects associated with an allocno.  */\n-typedef struct {\n+struct ira_allocno_object_iterator {\n   /* The number of the element the allocno's object array.  */\n   int n;\n-} ira_allocno_object_iterator;\n+};\n \n /* Initialize the iterator I.  */\n static inline void\n@@ -1192,10 +1192,10 @@ ira_allocno_object_iter_cond (ira_allocno_object_iterator *i, ira_allocno_t a,\n \f\n \n /* The iterator for prefs.  */\n-typedef struct {\n+struct ira_pref_iterator {\n   /* The number of the current element in IRA_PREFS.  */\n   int n;\n-} ira_pref_iterator;\n+};\n \n /* Initialize the iterator I.  */\n static inline void\n@@ -1230,10 +1230,10 @@ ira_pref_iter_cond (ira_pref_iterator *i, ira_pref_t *pref)\n \f\n \n /* The iterator for copies.  */\n-typedef struct {\n+struct ira_copy_iterator {\n   /* The number of the current element in IRA_COPIES.  */\n   int n;\n-} ira_copy_iterator;\n+};\n \n /* Initialize the iterator I.  */\n static inline void\n@@ -1267,7 +1267,7 @@ ira_copy_iter_cond (ira_copy_iterator *i, ira_copy_t *cp)\n        ira_copy_iter_cond (&(ITER), &(C));)\n \f\n /* The iterator for object conflicts.  */\n-typedef struct {\n+struct ira_object_conflict_iterator {\n \n   /* TRUE if the conflicts are represented by vector of allocnos.  */\n   bool conflict_vec_p;\n@@ -1294,7 +1294,7 @@ typedef struct {\n   /* The word of bit vector currently visited.  It is defined only if\n      OBJECT_CONFLICT_VEC_P is FALSE.  */\n   unsigned IRA_INT_TYPE word;\n-} ira_object_conflict_iterator;\n+};\n \n /* Initialize the iterator I with ALLOCNO conflicts.  */\n static inline void"}, {"sha": "44cfa286fad93199d0a879813b0b4e637eec2d30", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=84562394e219201bf8782ca928ad42b40aef0dd3", "patch": "@@ -277,7 +277,7 @@ lto_output_edge (struct lto_simple_output_block *ob, struct cgraph_edge *edge,\n   bp = bitpack_create (ob->main_stream);\n   uid = (!gimple_has_body_p (edge->caller->decl)\n \t ? edge->lto_stmt_uid : gimple_uid (edge->call_stmt) + 1);\n-  bp_pack_enum (&bp, cgraph_inline_failed_enum,\n+  bp_pack_enum (&bp, cgraph_inline_failed_t,\n \t        CIF_N_REASONS, edge->inline_failed);\n   bp_pack_var_len_unsigned (&bp, uid);\n   bp_pack_var_len_unsigned (&bp, edge->frequency);\n@@ -1225,7 +1225,7 @@ input_edge (struct lto_input_block *ib, vec<symtab_node *> nodes,\n   count = streamer_read_gcov_count (ib);\n \n   bp = streamer_read_bitpack (ib);\n-  inline_failed = bp_unpack_enum (&bp, cgraph_inline_failed_enum, CIF_N_REASONS);\n+  inline_failed = bp_unpack_enum (&bp, cgraph_inline_failed_t, CIF_N_REASONS);\n   stmt_id = bp_unpack_var_len_unsigned (&bp);\n   freq = (int) bp_unpack_var_len_unsigned (&bp);\n "}, {"sha": "701748ce4d41f895a02dffd81f2c90e69a5fd3b0", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=84562394e219201bf8782ca928ad42b40aef0dd3", "patch": "@@ -257,7 +257,7 @@ enum lto_section_type\n };\n \n /* Indices to the various function, type and symbol streams. */\n-typedef enum\n+enum lto_decl_stream_e_t\n {\n   LTO_DECL_STREAM_TYPE = 0,\t\t/* Must be first. */\n   LTO_DECL_STREAM_FIELD_DECL,\n@@ -267,7 +267,7 @@ typedef enum\n   LTO_DECL_STREAM_NAMESPACE_DECL,\n   LTO_DECL_STREAM_LABEL_DECL,\n   LTO_N_DECL_STREAMS\n-} lto_decl_stream_e_t;\n+};\n \n typedef enum ld_plugin_symbol_resolution ld_plugin_symbol_resolution_t;\n \n@@ -429,7 +429,7 @@ struct lto_stats_d\n };\n \n /* Entry of LTO symtab encoder.  */\n-typedef struct\n+struct lto_encoder_entry\n {\n   symtab_node *node;\n   /* Is the node in this partition (i.e. ltrans of this partition will\n@@ -441,7 +441,7 @@ typedef struct\n      For example the readonly variable initializers are encoded to aid\n      constant folding even if they are not in the partition.  */\n   unsigned int initializer:1;\n-} lto_encoder_entry;\n+};\n \n \n /* Encoder data structure used to stream callgraph nodes.  */\n@@ -454,11 +454,11 @@ struct lto_symtab_encoder_d\n typedef struct lto_symtab_encoder_d *lto_symtab_encoder_t;\n \n /* Iterator structure for cgraph node sets.  */\n-typedef struct\n+struct lto_symtab_encoder_iterator\n {\n   lto_symtab_encoder_t encoder;\n   unsigned index;\n-} lto_symtab_encoder_iterator;\n+};\n \n \n \n@@ -523,7 +523,6 @@ struct res_pair\n   ld_plugin_symbol_resolution_t res;\n   unsigned index;\n };\n-typedef struct res_pair res_pair;\n \n \n /* One of these is allocated for each object file that being compiled"}, {"sha": "7477647bf6701f2f25b3b1d13aa901812c2c73e0", "filename": "gcc/opts.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fopts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fopts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.h?ref=84562394e219201bf8782ca928ad42b40aef0dd3", "patch": "@@ -249,14 +249,14 @@ struct cl_decoded_option\n /* Structure describing an option deferred for handling after the main\n    option handlers.  */\n \n-typedef struct\n+struct cl_deferred_option\n {\n   /* Elements from struct cl_decoded_option used for deferred\n      options.  */\n   size_t opt_index;\n   const char *arg;\n   int value;\n-} cl_deferred_option;\n+};\n \n /* Structure describing a single option-handling callback.  */\n "}, {"sha": "f137e9eb5e6391c241899eff851c43f56a5470f0", "filename": "gcc/params.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fparams.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fparams.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.h?ref=84562394e219201bf8782ca928ad42b40aef0dd3", "patch": "@@ -38,7 +38,7 @@ along with GCC; see the file COPYING3.  If not see\n \n /* The information associated with each parameter.  */\n \n-typedef struct param_info\n+struct param_info\n {\n   /* The name used with the `--param <name>=<value>' switch to set this\n      value.  */\n@@ -55,7 +55,7 @@ typedef struct param_info\n \n   /* A short description of the option.  */\n   const char *const help;\n-} param_info;\n+};\n \n /* An array containing the compiler parameters and their current\n    values.  */\n@@ -79,14 +79,14 @@ extern void set_param_value (const char *name, int value,\n \f\n /* The parameters in use by language-independent code.  */\n \n-typedef enum compiler_param\n+enum compiler_param\n {\n #define DEFPARAM(enumerator, option, msgid, default, min, max) \\\n   enumerator,\n #include \"params.def\"\n #undef DEFPARAM\n   LAST_PARAM\n-} compiler_param;\n+};\n \n /* The value of the parameter given by ENUM.  Not an lvalue.  */\n #define PARAM_VALUE(ENUM) \\"}, {"sha": "f2ceccf2b8ed440a5f4668defcd97e832ed69b1f", "filename": "gcc/regrename.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fregrename.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fregrename.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.h?ref=84562394e219201bf8782ca928ad42b40aef0dd3", "patch": "@@ -65,22 +65,22 @@ struct du_chain\n \n /* This struct describes data gathered during regrename_analyze about\n    a single operand of an insn.  */\n-typedef struct\n+struct operand_rr_info\n {\n   /* The number of chains recorded for this operand.  */\n   int n_chains;\n   /* Holds either the chain for the operand itself, or for the registers in\n      a memory operand.  */\n   struct du_chain *chains[MAX_REGS_PER_ADDRESS];\n   struct du_head *heads[MAX_REGS_PER_ADDRESS];\n-} operand_rr_info;\n+};\n \n /* A struct to hold a vector of operand_rr_info structures describing the\n    operands of an insn.  */\n-typedef struct\n+struct insn_rr_info\n {\n   operand_rr_info *op_info;\n-} insn_rr_info;\n+};\n \n \n extern vec<insn_rr_info> insn_rr;"}, {"sha": "d7b28422f64231ad8a199a781eef30f8ce39b731", "filename": "gcc/reload.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Freload.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Freload.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.h?ref=84562394e219201bf8782ca928ad42b40aef0dd3", "patch": "@@ -203,7 +203,7 @@ extern struct target_reload *this_target_reload;\n   (this_target_reload->x_caller_save_initialized_p)\n \n /* Register equivalences.  Indexed by register number.  */\n-typedef struct reg_equivs_s\n+struct reg_equivs_t\n {\n   /* The constant value to which pseudo reg N is equivalent,\n      or zero if pseudo reg N is not equivalent to a constant.\n@@ -238,7 +238,7 @@ typedef struct reg_equivs_s\n   /* The list of insns that initialized reg N from its equivalent\n      constant or memory slot.  */\n   rtx init;\n-} reg_equivs_t;\n+};\n \n #define reg_equiv_constant(ELT) \\\n   (*reg_equivs)[(ELT)].constant"}, {"sha": "71d1ab0375e571da6c9e65e0d45bd0b2642f72e5", "filename": "gcc/rtl.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=84562394e219201bf8782ca928ad42b40aef0dd3", "patch": "@@ -82,7 +82,7 @@ DEF_RTL_EXPR(UNKNOWN, \"UnKnown\", \"*\", RTX_EXTRA)\n \n /* Used in the cselib routines to describe a value.  Objects of this\n    kind are only allocated in cselib.c, in an alloc pool instead of in\n-   GC memory.  The only operand of a VALUE is a cselib_val_struct.\n+   GC memory.  The only operand of a VALUE is a cselib_val.\n    var-tracking requires this to have a distinct integral value from\n    DECL codes in trees.  */\n DEF_RTL_EXPR(VALUE, \"value\", \"0\", RTX_OBJ)"}, {"sha": "e69bd37dc72f5a7afdf0097ee8d41bd006072490", "filename": "gcc/rtl.h", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=84562394e219201bf8782ca928ad42b40aef0dd3", "patch": "@@ -112,7 +112,7 @@ extern const unsigned char rtx_next[NUM_RTX_CODE];\n \f\n /* The flags and bitfields of an ADDR_DIFF_VEC.  BASE is the base label\n    relative to which the offsets are calculated, as explained in rtl.def.  */\n-typedef struct\n+struct addr_diff_vec_flags\n {\n   /* Set at the start of shorten_branches - ONLY WHEN OPTIMIZING - : */\n   unsigned min_align: 8;\n@@ -130,12 +130,12 @@ typedef struct\n   unsigned offset_unsigned: 1; /* offsets have to be treated as unsigned.  */\n   unsigned : 2;\n   unsigned scale : 8;\n-} addr_diff_vec_flags;\n+};\n \n /* Structure used to describe the attributes of a MEM.  These are hashed\n    so MEMs that the same attributes share a data structure.  This means\n    they cannot be modified in place.  */\n-typedef struct GTY(()) mem_attrs\n+struct GTY(()) mem_attrs\n {\n   /* The expression that the MEM accesses, or null if not known.\n      This expression might be larger than the memory reference itself.\n@@ -166,7 +166,7 @@ typedef struct GTY(()) mem_attrs\n \n   /* True if SIZE is known.  */\n   bool size_known_p;\n-} mem_attrs;\n+};\n \n /* Structure used to describe the attributes of a REG in similar way as\n    mem_attrs does for MEM above.  Note that the OFFSET field is calculated\n@@ -175,14 +175,14 @@ typedef struct GTY(()) mem_attrs\n    object in the low part of a 4-byte register, the OFFSET field\n    will be -3 rather than 0.  */\n \n-typedef struct GTY(()) reg_attrs {\n+struct GTY(()) reg_attrs {\n   tree decl;\t\t\t/* decl corresponding to REG.  */\n   HOST_WIDE_INT offset;\t\t/* Offset from start of DECL.  */\n-} reg_attrs;\n+};\n \n /* Common union for an element of an rtx.  */\n \n-union rtunion_def\n+union rtunion\n {\n   int rt_int;\n   unsigned int rt_uint;\n@@ -191,15 +191,14 @@ union rtunion_def\n   rtvec rt_rtvec;\n   enum machine_mode rt_type;\n   addr_diff_vec_flags rt_addr_diff_vec_flags;\n-  struct cselib_val_struct *rt_cselib;\n+  struct cselib_val *rt_cselib;\n   tree rt_tree;\n   basic_block rt_bb;\n   mem_attrs *rt_mem;\n   reg_attrs *rt_reg;\n   struct constant_descriptor_rtx *rt_constant;\n-  struct dw_cfi_struct *rt_cfi;\n+  struct dw_cfi_node *rt_cfi;\n };\n-typedef union rtunion_def rtunion;\n \n /* This structure remembers the position of a SYMBOL_REF within an\n    object_block structure.  A SYMBOL_REF only provides this information\n@@ -893,7 +892,7 @@ extern void rtl_check_failed_flag (const char *, const_rtx, const char *,\n #define ADDR_DIFF_VEC_FLAGS(RTX) X0ADVFLAGS (RTX, 4)\n \n /* In a VALUE, the value cselib has assigned to RTX.\n-   This is a \"struct cselib_val_struct\", see cselib.h.  */\n+   This is a \"struct cselib_val\", see cselib.h.  */\n #define CSELIB_VAL_PTR(RTX) X0CSELIB (RTX, 0)\n \n /* Holds a list of notes on what this insn does to various REGs.\n@@ -2002,12 +2001,12 @@ extern void set_insn_deleted (rtx);\n #define single_set_1(I) single_set_2 (I, PATTERN (I))\n \n /* Structure used for passing data to REPLACE_LABEL.  */\n-typedef struct replace_label_data\n+struct replace_label_data\n {\n   rtx r1;\n   rtx r2;\n   bool update_label_nuses;\n-} replace_label_data;\n+};\n \n extern enum machine_mode get_address_mode (rtx mem);\n extern int rtx_addr_can_trap_p (const_rtx);"}, {"sha": "0dc9567f580a42ebaf5151ad0608686193f9cbb8", "filename": "gcc/sbitmap.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fsbitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fsbitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsbitmap.h?ref=84562394e219201bf8782ca928ad42b40aef0dd3", "patch": "@@ -126,7 +126,7 @@ bitmap_clear_bit (sbitmap map, int bitno)\n }\n \n /* The iterator for sbitmap.  */\n-typedef struct {\n+struct sbitmap_iterator {\n   /* The pointer to the first word of the bitmap.  */\n   const SBITMAP_ELT_TYPE *ptr;\n \n@@ -141,7 +141,7 @@ typedef struct {\n \n   /* The words currently visited.  */\n   SBITMAP_ELT_TYPE word;\n-} sbitmap_iterator;\n+};\n \n /* Initialize the iterator I with sbitmap BMP and the initial index\n    MIN.  */"}, {"sha": "b2c772402984ec4cc2ad75993ea43718c3f07ed9", "filename": "gcc/sched-int.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=84562394e219201bf8782ca928ad42b40aef0dd3", "patch": "@@ -1381,7 +1381,7 @@ extern void schedule_ebbs_finish (void);\n /* A region is the main entity for interblock scheduling: insns\n    are allowed to move between blocks in the same region, along\n    control flow graph edges, in the 'up' direction.  */\n-typedef struct\n+struct region\n {\n   /* Number of extended basic blocks in region.  */\n   int rgn_nr_blocks;\n@@ -1392,8 +1392,7 @@ typedef struct\n   unsigned int dont_calc_deps : 1;\n   /* This region has at least one non-trivial ebb.  */\n   unsigned int has_real_ebb : 1;\n-}\n-region;\n+};\n \n extern int nr_regions;\n extern region *rgn_table;"}, {"sha": "d194740b4f2adbf2d1fb3ab21cdbc7b7820a5e53", "filename": "gcc/sel-sched-ir.h", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fsel-sched-ir.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fsel-sched-ir.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-ir.h?ref=84562394e219201bf8782ca928ad42b40aef0dd3", "patch": "@@ -407,7 +407,7 @@ _list_clear (_list_t *l)\n \f\n \n /* List iterator backend.  */\n-typedef struct\n+struct _list_iterator\n {\n   /* The list we're iterating.  */\n   _list_t *lp;\n@@ -417,7 +417,7 @@ typedef struct\n \n   /* True when we've actually removed something.  */\n   bool removed_p;\n-} _list_iterator;\n+};\n \n static inline void\n _list_iter_start (_list_iterator *ip, _list_t *lp, bool can_remove_p)\n@@ -850,18 +850,17 @@ extern bitmap blocks_to_reschedule;\n \n /* A variable to track which part of rtx we are scanning in\n    sched-deps.c: sched_analyze_insn ().  */\n-enum deps_where_def\n-  {\n-    DEPS_IN_INSN,\n-    DEPS_IN_LHS,\n-    DEPS_IN_RHS,\n-    DEPS_IN_NOWHERE\n-  };\n-typedef enum deps_where_def deps_where_t;\n+enum deps_where_t\n+{\n+  DEPS_IN_INSN,\n+  DEPS_IN_LHS,\n+  DEPS_IN_RHS,\n+  DEPS_IN_NOWHERE\n+};\n \f\n \n /* Per basic block data for the whole CFG.  */\n-typedef struct\n+struct sel_global_bb_info_def\n {\n   /* For each bb header this field contains a set of live registers.\n      For all other insns this field has a NULL.\n@@ -873,7 +872,7 @@ typedef struct\n      true - block has usable LV_SET.\n      false - block's LV_SET should be recomputed.  */\n   bool lv_set_valid_p;\n-} sel_global_bb_info_def;\n+};\n \n typedef sel_global_bb_info_def *sel_global_bb_info_t;\n \n@@ -893,7 +892,7 @@ extern void sel_finish_global_bb_info (void);\n #define BB_LV_SET_VALID_P(BB) (SEL_GLOBAL_BB_INFO (BB)->lv_set_valid_p)\n \n /* Per basic block data for the region.  */\n-typedef struct\n+struct sel_region_bb_info_def\n {\n   /* This insn stream is constructed in such a way that it should be\n      traversed by PREV_INSN field - (*not* NEXT_INSN).  */\n@@ -905,7 +904,7 @@ typedef struct\n \n   /* If (AV_LEVEL == GLOBAL_LEVEL) then AV is valid.  */\n   int av_level;\n-} sel_region_bb_info_def;\n+};\n \n typedef sel_region_bb_info_def *sel_region_bb_info_t;\n \n@@ -951,7 +950,7 @@ extern regset sel_all_regs;\n \f\n \n /* Successor iterator backend.  */\n-typedef struct\n+struct succ_iterator\n {\n   /* True if we're at BB end.  */\n   bool bb_end;\n@@ -979,7 +978,7 @@ typedef struct\n   /* If skip to loop exits, save here information about loop exits.  */\n   int current_exit;\n   vec<edge> loop_exits;\n-} succ_iterator;\n+};\n \n /* A structure returning all successor's information.  */\n struct succs_info"}, {"sha": "ac7de573b9d8fdbc61668306a2135b817e4ed08e", "filename": "gcc/sreal.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fsreal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fsreal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsreal.h?ref=84562394e219201bf8782ca928ad42b40aef0dd3", "patch": "@@ -41,7 +41,7 @@ along with GCC; see the file COPYING3.  If not see\n #endif\n \n /* Structure for holding a simple real number.  */\n-typedef struct sreal\n+struct sreal\n {\n #if SREAL_PART_BITS < 32\n   unsigned HOST_WIDE_INT sig_lo;\t/* Significant (lower part).  */\n@@ -50,7 +50,7 @@ typedef struct sreal\n   unsigned HOST_WIDE_INT sig;\t\t/* Significant.  */\n #endif\n   signed int exp;\t\t\t/* Exponent.  */\n-} sreal;\n+};\n \n extern void dump_sreal (FILE *, sreal *);\n extern void debug (sreal &ref);"}, {"sha": "eceddbce21469e305569d5769958b89ff3ef5a6e", "filename": "gcc/ssa-iterators.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fssa-iterators.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Fssa-iterators.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fssa-iterators.h?ref=84562394e219201bf8782ca928ad42b40aef0dd3", "patch": "@@ -23,7 +23,7 @@ along with GCC; see the file COPYING3.  If not see\n /* Immediate use lists are used to directly access all uses for an SSA\n    name and get pointers to the statement for each use.\n \n-   The structure ssa_use_operand_d consists of PREV and NEXT pointers\n+   The structure ssa_use_operand_t consists of PREV and NEXT pointers\n    to maintain the list.  A USE pointer, which points to address where\n    the use is located and a LOC pointer which can point to the\n    statement where the use is located, or, in the case of the root\n@@ -55,7 +55,7 @@ along with GCC; see the file COPYING3.  If not see\n \n    If iteration is halted early, the marker node must be removed from\n    the list before continuing.  */\n-typedef struct immediate_use_iterator_d\n+struct imm_use_iterator\n {\n   /* This is the current use the iterator is processing.  */\n   ssa_use_operand_t *imm_use;\n@@ -66,7 +66,7 @@ typedef struct immediate_use_iterator_d\n   /* This is the next ssa_name to visit.  IMM_USE may get removed before\n      the next one is traversed to, so it must be cached early.  */\n   ssa_use_operand_t *next_imm_name;\n-} imm_use_iterator;\n+};\n \n \n /* Use this iterator when simply looking at stmts.  Adding, deleting or\n@@ -131,7 +131,7 @@ enum ssa_op_iter_type {\n    optimization, this structure is scalarized, and any unused fields are\n    optimized away, resulting in little overhead.  */\n \n-typedef struct ssa_operand_iterator_d\n+struct ssa_op_iter\n {\n   enum ssa_op_iter_type iter_type;\n   bool done;\n@@ -140,7 +140,7 @@ typedef struct ssa_operand_iterator_d\n   unsigned numops;\n   use_optype_p uses;\n   gimple stmt;\n-} ssa_op_iter;\n+};\n \n /* These flags are used to determine which operands are returned during\n    execution of the loop.  */"}, {"sha": "36039660f3e244e76287bbb993e1c02f67f7149c", "filename": "gcc/target.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=84562394e219201bf8782ca928ad42b40aef0dd3", "patch": "@@ -2819,7 +2819,7 @@ DEFHOOK\n   version of this hook assumes the system C library errno location\\\n   is either a declaration of type int or accessed by dereferencing\\\n   a pointer to int.\",\n- bool, (struct ao_ref_s *ref),\n+ bool, (struct ao_ref *ref),\n  default_ref_may_alias_errno)\n \n /* Support for named address spaces.  */"}, {"sha": "5e6e68e5b32d85d454f1c7ea6cd02fd85eae0ec4", "filename": "gcc/target.h", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=84562394e219201bf8782ca928ad42b40aef0dd3", "patch": "@@ -54,7 +54,7 @@\n \n #ifdef ENABLE_CHECKING\n \n-typedef struct { void *magic; void *p; } cumulative_args_t;\n+struct cumulative_args_t { void *magic; void *p; };\n \n #else /* !ENABLE_CHECKING */\n \n@@ -64,20 +64,19 @@ typedef struct { void *magic; void *p; } cumulative_args_t;\n    efficient way of argument passing otherwise.  However, that would come\n    at the cost of less type-safe !ENABLE_CHECKING compilation.  */\n \n-typedef union { void *p; } cumulative_args_t;\n+union cumulative_args_t { void *p; };\n \n #endif /* !ENABLE_CHECKING */\n \n /* Types used by the record_gcc_switches() target function.  */\n-typedef enum\n+enum print_switch_type\n {\n   SWITCH_TYPE_PASSED,\t\t/* A switch passed on the command line.  */\n   SWITCH_TYPE_ENABLED,\t\t/* An option that is currently enabled.  */\n   SWITCH_TYPE_DESCRIPTIVE,\t/* Descriptive text, not a switch or option.  */\n   SWITCH_TYPE_LINE_START,\t/* Please emit any necessary text at the start of a line.  */\n   SWITCH_TYPE_LINE_END\t\t/* Please emit a line terminator.  */\n-}\n-print_switch_type;\n+};\n \n typedef int (* print_switch_fn_type) (print_switch_type, const char *);\n \n@@ -97,7 +96,7 @@ struct cgraph_node;\n struct cgraph_simd_clone;\n \n /* The struct used by the secondary_reload target hook.  */\n-typedef struct secondary_reload_info\n+struct secondary_reload_info\n {\n   /* icode is actually an enum insn_code, but we don't want to force every\n      file that includes target.h to include optabs.h .  */\n@@ -108,7 +107,7 @@ typedef struct secondary_reload_info\n      compatibility hook.  */\n   struct secondary_reload_info *prev_sri;\n   int t_icode; /* Actually an enum insn_code - see above.  */\n-} secondary_reload_info;\n+};\n \n /* This is defined in sched-int.h .  */\n struct _dep;\n@@ -120,7 +119,7 @@ struct ddg;\n struct loop;\n \n /* This is defined in tree-ssa-alias.h.  */\n-struct ao_ref_s;\n+struct ao_ref;\n \n /* This is defined in tree-vectorizer.h.  */\n struct _stmt_vec_info;"}, {"sha": "43600275c1b187cd32098755ece072bb9dfd89b8", "filename": "gcc/targhooks.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=84562394e219201bf8782ca928ad42b40aef0dd3", "patch": "@@ -153,7 +153,7 @@ extern bool default_target_option_valid_attribute_p (tree, tree, tree, int);\n extern bool default_target_option_pragma_parse (tree, tree);\n extern bool default_target_can_inline_p (tree, tree);\n extern bool default_valid_pointer_mode (enum machine_mode);\n-extern bool default_ref_may_alias_errno (struct ao_ref_s *);\n+extern bool default_ref_may_alias_errno (struct ao_ref *);\n extern enum machine_mode default_addr_space_pointer_mode (addr_space_t);\n extern enum machine_mode default_addr_space_address_mode (addr_space_t);\n extern bool default_addr_space_valid_pointer_mode (enum machine_mode,"}, {"sha": "be64ede18fa3e384f9bc775d442b2d501e0621e7", "filename": "gcc/tree-affine.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Ftree-affine.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Ftree-affine.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-affine.h?ref=84562394e219201bf8782ca928ad42b40aef0dd3", "patch": "@@ -33,7 +33,7 @@ struct aff_comb_elt\n   double_int coef;\n };\n \n-typedef struct affine_tree_combination\n+struct aff_tree\n {\n   /* Type of the result of the combination.  */\n   tree type;\n@@ -56,7 +56,7 @@ typedef struct affine_tree_combination\n      than MAX_AFF_ELTS elements.  Type of REST will be either sizetype for\n      TYPE of POINTER_TYPEs or TYPE.  */\n   tree rest;\n-} aff_tree;\n+};\n \n double_int double_int_ext_for_comb (double_int, aff_tree *);\n void aff_combination_const (aff_tree *, tree, double_int);"}, {"sha": "0822d35702472f2509a19179309765de9a3f9fad", "filename": "gcc/tree-core.h", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Ftree-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Ftree-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-core.h?ref=84562394e219201bf8782ca928ad42b40aef0dd3", "patch": "@@ -667,10 +667,10 @@ enum annot_expr_kind {\n /* When processing aliases at the symbol table level, we need the\n    declaration of target. For this reason we need to queue aliases and\n    process them after all declarations has been produced.  */\n-typedef struct GTY(()) alias_pair {\n+struct GTY(()) alias_pair {\n   tree decl;\n   tree target;\n-} alias_pair;\n+};\n \n /* An initialization priority.  */\n typedef unsigned short priority_type;\n@@ -1096,10 +1096,10 @@ struct GTY(()) tree_vec {\n    element. INDEX can optionally design the position of VALUE: in arrays,\n    it is the index where VALUE has to be placed; in structures, it is the\n    FIELD_DECL of the member.  */\n-typedef struct GTY(()) constructor_elt_d {\n+struct GTY(()) constructor_elt {\n   tree index;\n   tree value;\n-} constructor_elt;\n+};\n \n struct GTY(()) tree_constructor {\n   struct tree_typed typed;\n@@ -1148,17 +1148,17 @@ struct GTY(()) tree_exp {\n \n /* Immediate use linking structure.  This structure is used for maintaining\n    a doubly linked list of uses of an SSA_NAME.  */\n-typedef struct GTY(()) ssa_use_operand_d {\n-  struct ssa_use_operand_d* GTY((skip(\"\"))) prev;\n-  struct ssa_use_operand_d* GTY((skip(\"\"))) next;\n+struct GTY(()) ssa_use_operand_t {\n+  struct ssa_use_operand_t* GTY((skip(\"\"))) prev;\n+  struct ssa_use_operand_t* GTY((skip(\"\"))) next;\n   /* Immediate uses for a given SSA name are maintained as a cyclic\n      list.  To recognize the root of this list, the location field\n      needs to point to the original SSA name.  Since statements and\n      SSA names are of different data types, we need this union.  See\n-     the explanation in struct immediate_use_iterator_d.  */\n+     the explanation in struct imm_use_iterator.  */\n   union { gimple stmt; tree ssa_name; } GTY((skip(\"\"))) loc;\n   tree *GTY((skip(\"\"))) use;\n-} ssa_use_operand_t;\n+};\n \n struct GTY(()) tree_ssa_name {\n   struct tree_typed typed;\n@@ -1179,13 +1179,13 @@ struct GTY(()) tree_ssa_name {\n \t\t\"!POINTER_TYPE_P (TREE_TYPE ((tree)&%1)) : 2\"))) info;\n \n   /* Immediate uses list for this SSA_NAME.  */\n-  struct ssa_use_operand_d imm_uses;\n+  struct ssa_use_operand_t imm_uses;\n };\n \n struct GTY(()) phi_arg_d {\n   /* imm_use MUST be the first element in struct because we do some\n      pointer arithmetic with it.  See phi_arg_index_from_use.  */\n-  struct ssa_use_operand_d imm_use;\n+  struct ssa_use_operand_t imm_use;\n   tree def;\n   location_t locus;\n };"}, {"sha": "76e1b8208018832ce2a6e0298f4b00ecfb660ed0", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=84562394e219201bf8782ca928ad42b40aef0dd3", "patch": "@@ -239,11 +239,11 @@ enum data_dependence_direction {\n \n typedef vec<tree> affine_fn;\n \n-typedef struct\n+struct conflict_function\n {\n   unsigned n;\n   affine_fn fns[MAX_DIM];\n-} conflict_function;\n+};\n \n /* What is a subscript?  Given two array accesses a subscript is the\n    tuple composed of the access functions for a given dimension."}, {"sha": "00c0b0cf7380c5c6aae6478bcb53e246458473a3", "filename": "gcc/tree-inline.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Ftree-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Ftree-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.h?ref=84562394e219201bf8782ca928ad42b40aef0dd3", "patch": "@@ -36,7 +36,7 @@ enum copy_body_cge_which\n \n /* Data required for function body duplication.  */\n \n-typedef struct copy_body_data\n+struct copy_body_data\n {\n   /* FUNCTION_DECL for function being inlined, or in general the\n      source function providing the original trees.  */\n@@ -135,7 +135,7 @@ typedef struct copy_body_data\n   /* Cilk keywords currently need to replace some variables that\n      ordinary nested functions do not.  */ \n   bool remap_var_for_cilk;\n-} copy_body_data;\n+};\n \n /* Weights of constructions for estimate_num_insns.  */\n "}, {"sha": "105f371feb50aea203fd42697fd4feb780b8da05", "filename": "gcc/tree-iterator.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Ftree-iterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Ftree-iterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-iterator.h?ref=84562394e219201bf8782ca928ad42b40aef0dd3", "patch": "@@ -29,10 +29,10 @@ along with GCC; see the file COPYING3.  If not see\n \n /* Iterator object for GENERIC or GIMPLE TREE statements.  */\n \n-typedef struct {\n+struct tree_stmt_iterator {\n   struct tree_statement_list_node *ptr;\n   tree container;\n-} tree_stmt_iterator;\n+};\n \n static inline tree_stmt_iterator\n tsi_start (tree t)"}, {"sha": "d2ef4b16879758c1206155f88accbfdaf8ae6572", "filename": "gcc/tree-scalar-evolution.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Ftree-scalar-evolution.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Ftree-scalar-evolution.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.h?ref=84562394e219201bf8782ca928ad42b40aef0dd3", "patch": "@@ -35,7 +35,7 @@ extern tree resolve_mixers (struct loop *, tree);\n extern void gather_stats_on_scev_database (void);\n extern unsigned int scev_const_prop (void);\n extern bool expression_expensive_p (tree);\n-extern bool simple_iv (struct loop *, struct loop *, tree, struct affine_iv_d *,\n+extern bool simple_iv (struct loop *, struct loop *, tree, struct affine_iv *,\n \t\t       bool);\n extern tree compute_overall_effect_of_inner_loop (struct loop *, tree);\n "}, {"sha": "a5a67c43bb2125396fa82ba98d8c3c29d30613a8", "filename": "gcc/tree-ssa-address.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Ftree-ssa-address.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Ftree-ssa-address.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-address.h?ref=84562394e219201bf8782ca928ad42b40aef0dd3", "patch": "@@ -25,7 +25,7 @@ extern rtx addr_for_mem_ref (tree exp, addr_space_t as, bool really_expand);\n extern void get_address_description (tree, struct mem_address *);\n extern tree tree_mem_ref_addr (tree, tree);\n tree create_mem_ref (gimple_stmt_iterator *, tree,\n-\t\t     struct affine_tree_combination *, tree, tree, tree, bool);\n+\t\t     struct aff_tree *, tree, tree, tree, bool);\n extern void copy_ref_info (tree, tree);\n tree maybe_fold_tmr (tree);\n "}, {"sha": "6c54ad90162c724aa99b809738055a131f29d965", "filename": "gcc/tree-ssa-alias.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Ftree-ssa-alias.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Ftree-ssa-alias.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.h?ref=84562394e219201bf8782ca928ad42b40aef0dd3", "patch": "@@ -64,7 +64,7 @@ struct GTY(()) pt_solution\n /* Simplified and cached information about a memory reference tree.\n    Used by the alias-oracle internally and externally in alternate\n    interfaces.  */\n-typedef struct ao_ref_s\n+struct ao_ref\n {\n   /* The original full memory reference tree or NULL_TREE if that is\n      not available.  */\n@@ -90,7 +90,7 @@ typedef struct ao_ref_s\n \n   /* Whether the memory is considered a volatile access.  */\n   bool volatile_p;\n-} ao_ref;\n+};\n \n \n /* In tree-ssa-alias.c  */"}, {"sha": "8d2dfc504a2fd1b17ee6fc3f74489683a645be16", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=84562394e219201bf8782ca928ad42b40aef0dd3", "patch": "@@ -3021,7 +3021,7 @@ determine_common_wider_type (tree *a, tree *b)\n static bool\n get_computation_aff (struct loop *loop,\n \t\t     struct iv_use *use, struct iv_cand *cand, gimple at,\n-\t\t     struct affine_tree_combination *aff)\n+\t\t     struct aff_tree *aff)\n {\n   tree ubase = use->iv->base;\n   tree ustep = use->iv->step;\n@@ -4589,7 +4589,7 @@ iv_elimination_compare_lt (struct ivopts_data *data,\n \t\t\t   struct tree_niter_desc *niter)\n {\n   tree cand_type, a, b, mbz, nit_type = TREE_TYPE (niter->niter), offset;\n-  struct affine_tree_combination nit, tmpa, tmpb;\n+  struct aff_tree nit, tmpa, tmpb;\n   enum tree_code comp;\n   HOST_WIDE_INT step;\n "}, {"sha": "dd8397d0662f445c7649a85b6bc829ae072e23cb", "filename": "gcc/tree-ssa-loop.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Ftree-ssa-loop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Ftree-ssa-loop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop.h?ref=84562394e219201bf8782ca928ad42b40aef0dd3", "patch": "@@ -22,14 +22,14 @@ along with GCC; see the file COPYING3.  If not see\n \n /* Affine iv.  */\n \n-typedef struct affine_iv_d\n+struct affine_iv\n {\n   /* Iv = BASE + STEP * i.  */\n   tree base, step;\n \n   /* True if this iv does not overflow.  */\n   bool no_overflow;\n-} affine_iv;\n+};\n \n /* Description of number of iterations of a loop.  All the expressions inside\n    the structure can be evaluated at the end of the loop's preheader"}, {"sha": "f5a779c94e4e9c845c9741ef562c550afc1bc443", "filename": "gcc/tree-ssa-operands.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Ftree-ssa-operands.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84562394e219201bf8782ca928ad42b40aef0dd3/gcc%2Ftree-ssa-operands.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.h?ref=84562394e219201bf8782ca928ad42b40aef0dd3", "patch": "@@ -37,7 +37,7 @@ typedef ssa_use_operand_t *use_operand_p;\n struct use_optype_d\n {\n   struct use_optype_d *next;\n-  struct ssa_use_operand_d use_ptr;\n+  struct ssa_use_operand_t use_ptr;\n };\n typedef struct use_optype_d *use_optype_p;\n "}]}