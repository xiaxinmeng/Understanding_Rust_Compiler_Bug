{"sha": "c96d01ab97046e1094188478d9f7585374305c8e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzk2ZDAxYWI5NzA0NmUxMDk0MTg4NDc4ZDlmNzU4NTM3NDMwNWM4ZQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-11-05T16:22:54Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-11-05T16:22:54Z"}, "message": "(push_reload): Delete abort for RELOAD_OTHER case added in last\nchange.\n\nFrom-SVN: r10561", "tree": {"sha": "85acc6cb2e7ffdb2dbf3d83863eed025e4ee9be9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/85acc6cb2e7ffdb2dbf3d83863eed025e4ee9be9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c96d01ab97046e1094188478d9f7585374305c8e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c96d01ab97046e1094188478d9f7585374305c8e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c96d01ab97046e1094188478d9f7585374305c8e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c96d01ab97046e1094188478d9f7585374305c8e/comments", "author": null, "committer": null, "parents": [{"sha": "09f6940d6112163c758f3a3c81ebd0acb19e3ba6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09f6940d6112163c758f3a3c81ebd0acb19e3ba6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09f6940d6112163c758f3a3c81ebd0acb19e3ba6"}], "stats": {"total": 14, "additions": 10, "deletions": 4}, "files": [{"sha": "30719fb56ffbb2586baf898f81ef6f0de2a3bd19", "filename": "gcc/reload.c", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c96d01ab97046e1094188478d9f7585374305c8e/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c96d01ab97046e1094188478d9f7585374305c8e/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=c96d01ab97046e1094188478d9f7585374305c8e", "patch": "@@ -901,6 +901,11 @@ push_reload (in, out, inloc, outloc, class,\n \t\t  != HARD_REGNO_NREGS (REGNO (SUBREG_REG (in)),\n \t\t\t\t       GET_MODE (SUBREG_REG (in)))))))\n     {\n+      /* This relies on the fact that emit_reload_insns outputs the\n+\t instructions for input reloads of type RELOAD_OTHER in the same\n+\t order as the reloads.  Thus if the outer reload is also of type\n+\t RELOAD_OTHER, we are guaranteed that this inner reload will be\n+\t output before the outer reload.  */\n       push_reload (SUBREG_REG (in), NULL_RTX, &SUBREG_REG (in), NULL_PTR,\n \t\t   GENERAL_REGS, VOIDmode, VOIDmode, 0, 0, opnum, type);\n       dont_remove_subreg = 1;\n@@ -984,16 +989,17 @@ push_reload (in, out, inloc, outloc, class,\n \t\t  != HARD_REGNO_NREGS (REGNO (SUBREG_REG (out)),\n \t\t\t\t       GET_MODE (SUBREG_REG (out)))))))\n     {\n-      if (type == RELOAD_OTHER)\n-\tabort ();\n-\n+      /* This relies on the fact that emit_reload_insns outputs the\n+\t instructions for output reloads of type RELOAD_OTHER in reverse\n+\t order of the reloads.  Thus if the outer reload is also of type\n+\t RELOAD_OTHER, we are guaranteed that this inner reload will be\n+\t output after the outer reload.  */\n       dont_remove_subreg = 1;\n       push_reload (SUBREG_REG (out), SUBREG_REG (out), &SUBREG_REG (out),\n \t\t   &SUBREG_REG (out), ALL_REGS, VOIDmode, VOIDmode, 0, 0,\n \t\t   opnum, RELOAD_OTHER);\n     }\n \n-\n   /* If IN appears in OUT, we can't share any input-only reload for IN.  */\n   if (in != 0 && out != 0 && GET_CODE (out) == MEM\n       && (GET_CODE (in) == REG || GET_CODE (in) == MEM)"}]}