{"sha": "9b96e234f8e646b43bafda4670770276f94b07bc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWI5NmUyMzRmOGU2NDZiNDNiYWZkYTQ2NzA3NzAyNzZmOTRiMDdiYw==", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2006-02-15T09:43:43Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-02-15T09:43:43Z"}, "message": "sem_aggr.adb (Resolve_Record_Aggregate): Restructure the code that handles default-initialized components to keep...\n\n2006-02-13  Javier Miranda  <miranda@adacore.com>\n\n\t* sem_aggr.adb (Resolve_Record_Aggregate): Restructure the code that\n\thandles default-initialized components to keep separate the management\n\tof this feature but also avoid the unrequired resolution and\n\texpansion of components that do not have partially initialized\n\tvalues.\n\t(Collect_Aggr_Bounds): Add '\\' in 2-line warning message.\n\t(Check_Bounds): Likewise.\n\t(Check_Length): Likewise.\n\nFrom-SVN: r111088", "tree": {"sha": "4ce6a4cc006b442fdc6cb86cd81f1ec9d020035f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4ce6a4cc006b442fdc6cb86cd81f1ec9d020035f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9b96e234f8e646b43bafda4670770276f94b07bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b96e234f8e646b43bafda4670770276f94b07bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b96e234f8e646b43bafda4670770276f94b07bc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b96e234f8e646b43bafda4670770276f94b07bc/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "851cfa6f0085f05b4833ada5ffb74b05d57a1ff0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/851cfa6f0085f05b4833ada5ffb74b05d57a1ff0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/851cfa6f0085f05b4833ada5ffb74b05d57a1ff0"}], "stats": {"total": 228, "additions": 135, "deletions": 93}, "files": [{"sha": "580dc29af450652c2d49316f8da75fa80b416924", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 135, "deletions": 93, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b96e234f8e646b43bafda4670770276f94b07bc/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b96e234f8e646b43bafda4670770276f94b07bc/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=9b96e234f8e646b43bafda4670770276f94b07bc", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -78,8 +78,17 @@ package body Sem_Aggr is\n    --  statement of variant part will usually be small and probably in near\n    --  sorted order.\n \n-   procedure Check_Can_Never_Be_Null (Typ : Node_Id; Expr : Node_Id);\n-   --  Ada 2005 (AI-231): Check bad usage of the null-exclusion issue\n+   procedure Check_Can_Never_Be_Null (Typ : Entity_Id; Expr : Node_Id);\n+   --  Ada 2005 (AI-231): Check bad usage of null for a component for which\n+   --  null exclusion (NOT NULL) is specified. Typ can be an E_Array_Type for\n+   --  the array case (the component type of the array will be used) or an\n+   --  E_Component/E_Discriminant entity in the record case, in which case the\n+   --  type of the component will be used for the test. If Typ is any other\n+   --  kind of entity, the call is ignored. Expr is the component node in the\n+   --  aggregate which is an explicit occurrence of NULL. An error will be\n+   --  issued if the component is null excluding.\n+   --\n+   --  It would be better to pass the proper type for Typ ???\n \n    ------------------------------------------------------\n    -- Subprograms used for RECORD AGGREGATE Processing --\n@@ -94,28 +103,28 @@ package body Sem_Aggr is\n    --    N is the N_Aggregate node.\n    --    Typ is the record type for the aggregate resolution\n    --\n-   --  While performing the semantic checks, this procedure\n-   --  builds a new Component_Association_List where each record field\n-   --  appears alone in a Component_Choice_List along with its corresponding\n-   --  expression. The record fields in the Component_Association_List\n-   --  appear in the same order in which they appear in the record type Typ.\n+   --  While performing the semantic checks, this procedure builds a new\n+   --  Component_Association_List where each record field appears alone in a\n+   --  Component_Choice_List along with its corresponding expression. The\n+   --  record fields in the Component_Association_List appear in the same order\n+   --  in which they appear in the record type Typ.\n    --\n-   --  Once this new Component_Association_List is built and all the\n-   --  semantic checks performed, the original aggregate subtree is replaced\n-   --  with the new named record aggregate just built. Note that the subtree\n-   --  substitution is performed with Rewrite so as to be\n-   --  able to retrieve the original aggregate.\n+   --  Once this new Component_Association_List is built and all the semantic\n+   --  checks performed, the original aggregate subtree is replaced with the\n+   --  new named record aggregate just built. Note that subtree substitution is\n+   --  performed with Rewrite so as to be able to retrieve the original\n+   --  aggregate.\n    --\n    --  The aggregate subtree manipulation performed by Resolve_Record_Aggregate\n    --  yields the aggregate format expected by Gigi. Typically, this kind of\n    --  tree manipulations are done in the expander. However, because the\n-   --  semantic checks that need to be performed on record aggregates really\n-   --  go hand in hand with the record aggregate normalization, the aggregate\n+   --  semantic checks that need to be performed on record aggregates really go\n+   --  hand in hand with the record aggregate normalization, the aggregate\n    --  subtree transformation is performed during resolution rather than\n-   --  expansion. Had we decided otherwise we would have had to duplicate\n-   --  most of the code in the expansion procedure Expand_Record_Aggregate.\n-   --  Note, however, that all the expansion concerning aggegates for tagged\n-   --  records is done in Expand_Record_Aggregate.\n+   --  expansion. Had we decided otherwise we would have had to duplicate most\n+   --  of the code in the expansion procedure Expand_Record_Aggregate. Note,\n+   --  however, that all the expansion concerning aggegates for tagged records\n+   --  is done in Expand_Record_Aggregate.\n    --\n    --  The algorithm of Resolve_Record_Aggregate proceeds as follows:\n    --\n@@ -550,8 +559,8 @@ package body Sem_Aggr is\n                elsif Expr_Value (This_Low) /= Expr_Value (Aggr_Low (Dim)) then\n                   Set_Raises_Constraint_Error (N);\n                   Error_Msg_N (\"sub-aggregate low bound mismatch?\", N);\n-                  Error_Msg_N (\"Constraint_Error will be raised at run-time?\",\n-                               N);\n+                  Error_Msg_N\n+                     (\"\\Constraint_Error will be raised at run-time?\", N);\n                end if;\n             end if;\n \n@@ -564,8 +573,8 @@ package body Sem_Aggr is\n                then\n                   Set_Raises_Constraint_Error (N);\n                   Error_Msg_N (\"sub-aggregate high bound mismatch?\", N);\n-                  Error_Msg_N (\"Constraint_Error will be raised at run-time?\",\n-                               N);\n+                  Error_Msg_N\n+                     (\"\\Constraint_Error will be raised at run-time?\", N);\n                end if;\n             end if;\n          end if;\n@@ -1238,7 +1247,7 @@ package body Sem_Aggr is\n          if OK_BH and then OK_AH and then Val_BH < Val_AH then\n             Set_Raises_Constraint_Error (N);\n             Error_Msg_N (\"upper bound out of range?\", AH);\n-            Error_Msg_N (\"Constraint_Error will be raised at run-time?\", AH);\n+            Error_Msg_N (\"\\Constraint_Error will be raised at run-time?\", AH);\n \n             --  You need to set AH to BH or else in the case of enumerations\n             --  indices we will not be able to resolve the aggregate bounds.\n@@ -1324,7 +1333,7 @@ package body Sem_Aggr is\n          if Range_Len < Len then\n             Set_Raises_Constraint_Error (N);\n             Error_Msg_N (\"too many elements?\", N);\n-            Error_Msg_N (\"Constraint_Error will be raised at run-time?\", N);\n+            Error_Msg_N (\"\\Constraint_Error will be raised at run-time?\", N);\n          end if;\n       end Check_Length;\n \n@@ -1686,6 +1695,7 @@ package body Sem_Aggr is\n                   Next (Choice);\n \n                   if No (Choice) then\n+\n                      --  Check if we have a single discrete choice and whether\n                      --  this discrete choice specifies a single value.\n \n@@ -1850,10 +1860,9 @@ package body Sem_Aggr is\n             --  Ada 2005 (AI-231)\n \n             if Ada_Version >= Ada_05\n-              and then Nkind (Expression (Assoc)) = N_Null\n+              and then Nkind (Assoc) = N_Null\n             then\n-               Check_Can_Never_Be_Null\n-                 (Etype (N), Expression (Assoc));\n+               Check_Can_Never_Be_Null (Etype (N), Expression (Assoc));\n             end if;\n \n             --  Ada 2005 (AI-287): In case of default initialized component\n@@ -1926,8 +1935,7 @@ package body Sem_Aggr is\n       --  Do not duplicate Aggr_High if Aggr_High = Aggr_Low + Nb_Elements\n       --  since the addition node returned by Add is not yet analyzed. Attach\n       --  to tree and analyze first. Reset analyzed flag to insure it will get\n-      --  analyzed when it is a literal bound whose type must be properly\n-      --  set.\n+      --  analyzed when it is a literal bound whose type must be properly set.\n \n       if Others_Present or else Nb_Discrete_Choices > 0 then\n          Aggr_High := Duplicate_Subexpr (Aggr_High);\n@@ -2112,6 +2120,18 @@ package body Sem_Aggr is\n    ------------------------------\n \n    procedure Resolve_Record_Aggregate (N : Node_Id; Typ : Entity_Id) is\n+      Assoc : Node_Id;\n+      --  N_Component_Association node belonging to the input aggregate N\n+\n+      Expr            : Node_Id;\n+      Positional_Expr : Node_Id;\n+      Component       : Entity_Id;\n+      Component_Elmt  : Elmt_Id;\n+\n+      Components : constant Elist_Id := New_Elmt_List;\n+      --  Components is the list of the record components whose value must\n+      --  be provided in the aggregate. This list does include discriminants.\n+\n       New_Assoc_List : constant List_Id := New_List;\n       New_Assoc      : Node_Id;\n       --  New_Assoc_List is the newly built list of N_Component_Association\n@@ -2131,19 +2151,19 @@ package body Sem_Aggr is\n       --\n       --  This variable is updated as a side effect of function Get_Value\n \n-      Mbox_Present : Boolean := False;\n-      Others_Mbox  : Boolean := False;\n+      Is_Box_Present : Boolean := False;\n+      Others_Box     : Boolean := False;\n       --  Ada 2005 (AI-287): Variables used in case of default initialization\n-      --  to provide a functionality similar to Others_Etype. Mbox_Present\n+      --  to provide a functionality similar to Others_Etype. Box_Present\n       --  indicates that the component takes its default initialization;\n-      --  Others_Mbox indicates that at least one component takes its default\n+      --  Others_Box indicates that at least one component takes its default\n       --  initialization. Similar to Others_Etype, they are also updated as a\n       --  side effect of function Get_Value.\n \n       procedure Add_Association\n-        (Component   : Entity_Id;\n-         Expr        : Node_Id;\n-         Box_Present : Boolean := False);\n+        (Component      : Entity_Id;\n+         Expr           : Node_Id;\n+         Is_Box_Present : Boolean := False);\n       --  Builds a new N_Component_Association node which associates\n       --  Component to expression Expr and adds it to the new association\n       --  list New_Assoc_List being built.\n@@ -2191,9 +2211,9 @@ package body Sem_Aggr is\n       ---------------------\n \n       procedure Add_Association\n-        (Component   : Entity_Id;\n-         Expr        : Node_Id;\n-         Box_Present : Boolean := False)\n+        (Component      : Entity_Id;\n+         Expr           : Node_Id;\n+         Is_Box_Present : Boolean := False)\n       is\n          Choice_List : constant List_Id := New_List;\n          New_Assoc   : Node_Id;\n@@ -2204,7 +2224,7 @@ package body Sem_Aggr is\n            Make_Component_Association (Sloc (Expr),\n              Choices     => Choice_List,\n              Expression  => Expr,\n-             Box_Present => Box_Present);\n+             Box_Present => Is_Box_Present);\n          Append (New_Assoc, New_Assoc_List);\n       end Add_Association;\n \n@@ -2341,7 +2361,7 @@ package body Sem_Aggr is\n       --  Start of processing for Get_Value\n \n       begin\n-         Mbox_Present := False;\n+         Is_Box_Present := False;\n \n          if Present (From) then\n             Assoc := First (From);\n@@ -2367,8 +2387,8 @@ package body Sem_Aggr is\n                      --  expression (from the record type declaration).\n \n                      if Box_Present (Assoc) then\n-                        Others_Mbox  := True;\n-                        Mbox_Present := True;\n+                        Others_Box     := True;\n+                        Is_Box_Present := True;\n \n                         if Expander_Active then\n                            return New_Copy_Tree (Expression (Parent (Compon)));\n@@ -2415,7 +2435,7 @@ package body Sem_Aggr is\n                      --  Ada 2005 (AI-287)\n \n                      if Box_Present (Assoc) then\n-                        Mbox_Present := True;\n+                        Is_Box_Present := True;\n \n                         --  Duplicate the default expression of the component\n                         --  from the record type declaration\n@@ -2596,20 +2616,6 @@ package body Sem_Aggr is\n          end if;\n       end Resolve_Aggr_Expr;\n \n-      --  Resolve_Record_Aggregate local variables\n-\n-      Assoc : Node_Id;\n-      --  N_Component_Association node belonging to the input aggregate N\n-\n-      Expr            : Node_Id;\n-      Positional_Expr : Node_Id;\n-      Component       : Entity_Id;\n-      Component_Elmt  : Elmt_Id;\n-\n-      Components : constant Elist_Id := New_Elmt_List;\n-      --  Components is the list of the record components whose value must\n-      --  be provided in the aggregate. This list does include discriminants.\n-\n    --  Start of processing for Resolve_Record_Aggregate\n \n    begin\n@@ -2985,24 +2991,53 @@ package body Sem_Aggr is\n          Component := Node (Component_Elmt);\n          Expr := Get_Value (Component, Component_Associations (N), True);\n \n-         --  Ada 2005 (AI-287): Although the default initialization by means\n-         --  of the mbox was initially added to Ada 2005 for limited types, it\n-         --  is not constrained to limited types. Therefore if the component\n-         --  has some initialization procedure (IP) we pass the component to\n-         --  the expander, which will generate the call to such IP.\n+         --  Note: The previous call to Get_Value sets the value of the\n+         --  variable Is_Box_Present\n \n-         if Mbox_Present\n-           and then Has_Non_Null_Base_Init_Proc (Etype (Component))\n-         then\n-            Add_Association\n-              (Component   => Component,\n-               Expr        => Empty,\n-               Box_Present => True);\n+         --  Ada 2005 (AI-287): Handle components with default initialization.\n+         --  Note: This feature was originally added to Ada 2005 for limited\n+         --  but it was finally allowed with any type.\n \n-         --  Ada 2005 (AI-287): No value supplied for component\n+         if Is_Box_Present then\n+            declare\n+               Is_Array_Subtype : constant Boolean :=\n+                                    Ekind (Etype (Component)) =\n+                                                           E_Array_Subtype;\n \n-         elsif Mbox_Present and No (Expr) then\n-            null;\n+               Ctyp : Entity_Id;\n+\n+            begin\n+               if Is_Array_Subtype then\n+                  Ctyp := Component_Type (Base_Type (Etype (Component)));\n+               else\n+                  Ctyp := Etype (Component);\n+               end if;\n+\n+               --  If the component has an initialization procedure (IP) we\n+               --  pass the component to the expander, which will generate\n+               --  the call to such IP.\n+\n+               if Has_Non_Null_Base_Init_Proc (Ctyp) then\n+                  Add_Association\n+                    (Component      => Component,\n+                     Expr           => Empty,\n+                     Is_Box_Present => True);\n+\n+               --  Otherwise we only need to resolve the expression if the\n+               --  component has partially initialized values (required to\n+               --  expand the corresponding assignments and run-time checks).\n+\n+               elsif Present (Expr)\n+                 and then\n+                   ((not Is_Array_Subtype\n+                       and then Is_Partially_Initialized_Type (Component))\n+                      or else\n+                        (Is_Array_Subtype\n+                           and then Is_Partially_Initialized_Type (Ctyp)))\n+               then\n+                  Resolve_Aggr_Expr (Expr, Component);\n+               end if;\n+            end;\n \n          elsif No (Expr) then\n             Error_Msg_NE (\"no value supplied for component &!\", N, Component);\n@@ -3020,7 +3055,7 @@ package body Sem_Aggr is\n          Selectr : Node_Id;\n          --  Selector name\n \n-         Typech  : Entity_Id;\n+         Typech : Entity_Id;\n          --  Type of first component in choice list\n \n       begin\n@@ -3036,10 +3071,10 @@ package body Sem_Aggr is\n \n             if Nkind (Selectr) = N_Others_Choice then\n \n-               --  Ada 2005 (AI-287): others choice may have expression or mbox\n+               --  Ada 2005 (AI-287): others choice may have expression or box\n \n                if No (Others_Etype)\n-                  and then not Others_Mbox\n+                  and then not Others_Box\n                then\n                   Error_Msg_N\n                     (\"OTHERS must represent at least one component\", Selectr);\n@@ -3118,13 +3153,14 @@ package body Sem_Aggr is\n    -- Check_Can_Never_Be_Null --\n    -----------------------------\n \n-   procedure Check_Can_Never_Be_Null (Typ : Node_Id; Expr : Node_Id) is\n+   procedure Check_Can_Never_Be_Null (Typ : Entity_Id; Expr : Node_Id) is\n       Comp_Typ : Entity_Id;\n \n    begin\n-      pragma Assert (Ada_Version >= Ada_05\n-        and then Present (Expr)\n-        and then Nkind (Expr) = N_Null);\n+      pragma Assert\n+        (Ada_Version >= Ada_05\n+          and then Present (Expr)\n+          and then Nkind (Expr) = N_Null);\n \n       case Ekind (Typ) is\n          when E_Array_Type  =>\n@@ -3138,18 +3174,24 @@ package body Sem_Aggr is\n             return;\n       end case;\n \n-      if Present (Expr)\n-        and then Can_Never_Be_Null (Comp_Typ)\n-      then\n-         Error_Msg_N\n-           (\"(Ada 2005) NULL not allowed in null-excluding components?\", Expr);\n-         Error_Msg_NEL\n-           (\"\\& will be raised at run time!?\",\n-            Expr, Standard_Constraint_Error, Sloc (Expr));\n-\n-         Set_Etype                    (Expr, Comp_Typ);\n-         Set_Analyzed                 (Expr);\n-         Install_Null_Excluding_Check (Expr);\n+      if Can_Never_Be_Null (Comp_Typ) then\n+\n+         --  Here we know we have a constraint error. Note that we do not use\n+         --  Apply_Compile_Time_Constraint_Error here to the Expr, which might\n+         --  seem the more natural approach. That's because in some cases the\n+         --  components are rewritten, and the replacement would be missed.\n+\n+         Insert_Action\n+           (Compile_Time_Constraint_Error\n+              (Expr,\n+               \"(Ada 2005) NULL not allowed in null-excluding components?\"),\n+            Make_Raise_Constraint_Error (Sloc (Expr),\n+              Reason => CE_Access_Check_Failed));\n+\n+         --  Set proper type for bogus component (why is this needed???)\n+\n+         Set_Etype    (Expr, Comp_Typ);\n+         Set_Analyzed (Expr);\n       end if;\n    end Check_Can_Never_Be_Null;\n "}]}