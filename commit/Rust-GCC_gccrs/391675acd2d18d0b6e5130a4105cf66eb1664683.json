{"sha": "391675acd2d18d0b6e5130a4105cf66eb1664683", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzkxNjc1YWNkMmQxOGQwYjZlNTEzMGE0MTA1Y2Y2NmViMTY2NDY4Mw==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2017-02-06T21:07:37Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2017-02-06T21:07:37Z"}, "message": "re PR target/66144 (vector element operator produces very bad code)\n\n[gcc]\n2017-02-06  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\tPR target/66144\n\t* config/rs6000/vector.md (vcond<mode><mode>): Allow the true and\n\tfalse values to be constant vectors with all 0 or all 1 bits set.\n\t(vcondu<mode><mode>): Likewise.\n\t* config/rs6000/predicates.md (vector_int_reg_or_same_bit): New\n\tpredicate.\n\t(fpmask_comparison_operator): Update comment.\n\t(vecint_comparison_operator): New predicate.\n\t* config/rs6000/rs6000.c (rs6000_emit_vector_cond_expr): Optimize\n\tvector conditionals when the true and false values are constant\n\tvectors with all 0 bits or all 1 bits set.\n\n[gcc/testsuite]\n2017-02-06  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\tPR target/66144\n\t* gcc.target/powerpc/pr66144-1.c: New test.\n\t* gcc.target/powerpc/pr66144-2.c: Likewise.\n\t* gcc.target/powerpc/pr66144-3.c: Likewise.\n\nFrom-SVN: r245222", "tree": {"sha": "d78a3445d015e0af4a13622f9fbbbdf7dd8c5568", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d78a3445d015e0af4a13622f9fbbbdf7dd8c5568"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/391675acd2d18d0b6e5130a4105cf66eb1664683", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/391675acd2d18d0b6e5130a4105cf66eb1664683", "html_url": "https://github.com/Rust-GCC/gccrs/commit/391675acd2d18d0b6e5130a4105cf66eb1664683", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/391675acd2d18d0b6e5130a4105cf66eb1664683/comments", "author": null, "committer": null, "parents": [{"sha": "e495e31a20d8193166945c7417176da2535e6366", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e495e31a20d8193166945c7417176da2535e6366", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e495e31a20d8193166945c7417176da2535e6366"}], "stats": {"total": 172, "additions": 156, "deletions": 16}, "files": [{"sha": "eba99e140f7607178a40a77c7603020a4917df0d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/391675acd2d18d0b6e5130a4105cf66eb1664683/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/391675acd2d18d0b6e5130a4105cf66eb1664683/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=391675acd2d18d0b6e5130a4105cf66eb1664683", "patch": "@@ -1,3 +1,17 @@\n+2017-02-06  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/66144\n+\t* config/rs6000/vector.md (vcond<mode><mode>): Allow the true and\n+\tfalse values to be constant vectors with all 0 or all 1 bits set.\n+\t(vcondu<mode><mode>): Likewise.\n+\t* config/rs6000/predicates.md (vector_int_reg_or_same_bit): New\n+\tpredicate.\n+\t(fpmask_comparison_operator): Update comment.\n+\t(vecint_comparison_operator): New predicate.\n+\t* config/rs6000/rs6000.c (rs6000_emit_vector_cond_expr): Optimize\n+\tvector conditionals when the true and false values are constant\n+\tvectors with all 0 bits or all 1 bits set.\n+\n 2017-02-06  Martin Sebor  <msebor@redhat.com>\n \n \tPR  tree-optimization/79376"}, {"sha": "43e7a1ce605f99f458d4d4bbacb19bf9768d488b", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/391675acd2d18d0b6e5130a4105cf66eb1664683/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/391675acd2d18d0b6e5130a4105cf66eb1664683/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=391675acd2d18d0b6e5130a4105cf66eb1664683", "patch": "@@ -808,6 +808,21 @@\n   (and (match_code \"const_int,const_double,const_wide_int,const_vector\")\n        (match_test \"op == CONSTM1_RTX (mode) && !FLOAT_MODE_P (mode)\")))\n \n+;; Return 1 if operand is a vector int register or is either a vector constant\n+;; of all 0 bits of a vector constant of all 1 bits.\n+(define_predicate \"vector_int_reg_or_same_bit\"\n+  (match_code \"reg,subreg,const_vector\")\n+{\n+  if (GET_MODE_CLASS (mode) != MODE_VECTOR_INT)\n+    return 0;\n+\n+  else if (REG_P (op) || SUBREG_P (op))\n+    return vint_operand (op, mode);\n+\n+  else\n+    return op == CONST0_RTX (mode) || op == CONSTM1_RTX (mode);\n+})\n+\n ;; Return 1 if operand is 0.0.\n (define_predicate \"zero_fp_constant\"\n   (and (match_code \"const_double\")\n@@ -1260,8 +1275,8 @@\n   (and (match_operand 0 \"branch_comparison_operator\")\n        (match_code \"ne,le,ge,leu,geu,ordered\")))\n \n-;; Return 1 if OP is a comparison operator suitable for vector/scalar\n-;; comparisons that generate a -1/0 mask.\n+;; Return 1 if OP is a comparison operator suitable for floating point\n+;; vector/scalar comparisons that generate a -1/0 mask.\n (define_predicate \"fpmask_comparison_operator\"\n   (match_code \"eq,gt,ge\"))\n \n@@ -1271,6 +1286,11 @@\n (define_predicate \"invert_fpmask_comparison_operator\"\n   (match_code \"ne,unlt,unle\"))\n \n+;; Return 1 if OP is a comparison operation suitable for integer vector/scalar\n+;; comparisons that generate a -1/0 mask.\n+(define_predicate \"vecint_comparison_operator\"\n+  (match_code \"eq,gt,gtu\"))\n+\n ;; Return 1 if OP is a comparison operation that is valid for a branch\n ;; insn, which is true if the corresponding bit in the CC register is set.\n (define_predicate \"branch_positive_comparison_operator\""}, {"sha": "37e5458f30dd43f8da3dbeae6061e82bb5779ad1", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 35, "deletions": 4, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/391675acd2d18d0b6e5130a4105cf66eb1664683/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/391675acd2d18d0b6e5130a4105cf66eb1664683/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=391675acd2d18d0b6e5130a4105cf66eb1664683", "patch": "@@ -25125,7 +25125,6 @@ rs6000_emit_vector_cond_expr (rtx dest, rtx op_true, rtx op_false,\n   machine_mode cc_mode = CCmode;\n   rtx mask;\n   rtx cond2;\n-  rtx tmp;\n   bool invert_move = false;\n \n   if (VECTOR_UNIT_NONE_P (dest_mode))\n@@ -25170,12 +25169,44 @@ rs6000_emit_vector_cond_expr (rtx dest, rtx op_true, rtx op_false,\n     return 0;\n \n   if (invert_move)\n+    std::swap (op_true, op_false);\n+\n+  /* Optimize vec1 == vec2, to know the mask generates -1/0.  */\n+  if (GET_MODE_CLASS (dest_mode) == MODE_VECTOR_INT\n+      && (GET_CODE (op_true) == CONST_VECTOR\n+\t  || GET_CODE (op_false) == CONST_VECTOR))\n     {\n-      tmp = op_true;\n-      op_true = op_false;\n-      op_false = tmp;\n+      rtx constant_0 = CONST0_RTX (dest_mode);\n+      rtx constant_m1 = CONSTM1_RTX (dest_mode);\n+\n+      if (op_true == constant_m1 && op_false == constant_0)\n+\t{\n+\t  emit_move_insn (dest, mask);\n+\t  return 1;\n+\t}\n+\n+      else if (op_true == constant_0 && op_false == constant_m1)\n+\t{\n+\t  emit_insn (gen_rtx_SET (dest, gen_rtx_NOT (dest_mode, mask)));\n+\t  return 1;\n+\t}\n+\n+      /* If we can't use the vector comparison directly, perhaps we can use\n+\t the mask for the true or false fields, instead of loading up a\n+\t constant.  */\n+      if (op_true == constant_m1)\n+\top_true = mask;\n+\n+      if (op_false == constant_0)\n+\top_false = mask;\n     }\n \n+  if (!REG_P (op_true) && !SUBREG_P (op_true))\n+    op_true = force_reg (dest_mode, op_true);\n+\n+  if (!REG_P (op_false) && !SUBREG_P (op_false))\n+    op_false = force_reg (dest_mode, op_false);\n+\n   cond2 = gen_rtx_fmt_ee (NE, cc_mode, gen_lowpart (dest_mode, mask),\n \t\t\t  CONST0_RTX (dest_mode));\n   emit_insn (gen_rtx_SET (dest,"}, {"sha": "8f571739d30794e5c106e3bb39aa1355494d6523", "filename": "gcc/config/rs6000/vector.md", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/391675acd2d18d0b6e5130a4105cf66eb1664683/gcc%2Fconfig%2Frs6000%2Fvector.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/391675acd2d18d0b6e5130a4105cf66eb1664683/gcc%2Fconfig%2Frs6000%2Fvector.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvector.md?ref=391675acd2d18d0b6e5130a4105cf66eb1664683", "patch": "@@ -390,13 +390,13 @@\n }\")\n \n (define_expand \"vcond<mode><mode>\"\n-  [(set (match_operand:VEC_I 0 \"vint_operand\" \"\")\n+  [(set (match_operand:VEC_I 0 \"vint_operand\")\n \t(if_then_else:VEC_I\n \t (match_operator 3 \"comparison_operator\"\n-\t\t\t [(match_operand:VEC_I 4 \"vint_operand\" \"\")\n-\t\t\t  (match_operand:VEC_I 5 \"vint_operand\" \"\")])\n-\t (match_operand:VEC_I 1 \"vint_operand\" \"\")\n-\t (match_operand:VEC_I 2 \"vint_operand\" \"\")))]\n+\t\t\t [(match_operand:VEC_I 4 \"vint_operand\")\n+\t\t\t  (match_operand:VEC_I 5 \"vint_operand\")])\n+\t (match_operand:VEC_I 1 \"vector_int_reg_or_same_bit\")\n+\t (match_operand:VEC_I 2 \"vector_int_reg_or_same_bit\")))]\n   \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n   \"\n {\n@@ -446,13 +446,13 @@\n }\")\n \n (define_expand \"vcondu<mode><mode>\"\n-  [(set (match_operand:VEC_I 0 \"vint_operand\" \"\")\n+  [(set (match_operand:VEC_I 0 \"vint_operand\")\n \t(if_then_else:VEC_I\n \t (match_operator 3 \"comparison_operator\"\n-\t\t\t [(match_operand:VEC_I 4 \"vint_operand\" \"\")\n-\t\t\t  (match_operand:VEC_I 5 \"vint_operand\" \"\")])\n-\t (match_operand:VEC_I 1 \"vint_operand\" \"\")\n-\t (match_operand:VEC_I 2 \"vint_operand\" \"\")))]\n+\t\t\t [(match_operand:VEC_I 4 \"vint_operand\")\n+\t\t\t  (match_operand:VEC_I 5 \"vint_operand\")])\n+\t (match_operand:VEC_I 1 \"vector_int_reg_or_same_bit\")\n+\t (match_operand:VEC_I 2 \"vector_int_reg_or_same_bit\")))]\n   \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n   \"\n {"}, {"sha": "95c80a0d7adeda25d8e62814340033e920ec9855", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/391675acd2d18d0b6e5130a4105cf66eb1664683/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/391675acd2d18d0b6e5130a4105cf66eb1664683/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=391675acd2d18d0b6e5130a4105cf66eb1664683", "patch": "@@ -1,3 +1,10 @@\n+2017-02-06  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/66144\n+\t* gcc.target/powerpc/pr66144-1.c: New test.\n+\t* gcc.target/powerpc/pr66144-2.c: Likewise.\n+\t* gcc.target/powerpc/pr66144-3.c: Likewise.\n+\n 2017-02-06  Martin Sebor  <msebor@redhat.com>\n \n \tPR tree-optimization/79376"}, {"sha": "1755de4779ce0c6e302e0ec09cc5fcaacc024915", "filename": "gcc/testsuite/gcc.target/powerpc/pr66144-1.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/391675acd2d18d0b6e5130a4105cf66eb1664683/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr66144-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/391675acd2d18d0b6e5130a4105cf66eb1664683/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr66144-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr66144-1.c?ref=391675acd2d18d0b6e5130a4105cf66eb1664683", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile { target { powerpc64*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power9 -O2\" } */\n+\n+/* Verify that we optimize vector1 = (vector2 == vector3) by not loading up\n+   0/-1.  */\n+\n+vector int\n+test (vector int a, vector int b)\n+{\n+  return a == b;\n+}\n+\n+/* { dg-final { scan-assembler     {\\mvcmpequw\\M} } } */\n+/* { dg-final { scan-assembler-not {\\mxxspltib\\M} } } */\n+/* { dg-final { scan-assembler-not {\\mvspltisw\\M} } } */\n+/* { dg-final { scan-assembler-not {\\mxxlxor\\M}   } } */\n+/* { dg-final { scan-assembler-not {\\mxxlxorc\\M}  } } */\n+/* { dg-final { scan-assembler-not {\\mxxsel\\M}    } } */"}, {"sha": "13099a60383305de5c859105491703c9da340c9f", "filename": "gcc/testsuite/gcc.target/powerpc/pr66144-2.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/391675acd2d18d0b6e5130a4105cf66eb1664683/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr66144-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/391675acd2d18d0b6e5130a4105cf66eb1664683/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr66144-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr66144-2.c?ref=391675acd2d18d0b6e5130a4105cf66eb1664683", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile { target { powerpc64*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-options \"-mcpu=power8 -O2\" } */\n+\n+/* Verify that we optimize vector1 = (vector2 != vector3) by not loading up\n+   0/-1.  */\n+\n+vector unsigned char\n+test (vector unsigned char a, vector unsigned char b)\n+{\n+  return a != b;\n+}\n+\n+/* { dg-final { scan-assembler     {\\mvcmpequb\\M} } } */\n+/* { dg-final { scan-assembler     {\\mxxlnor\\M}   } } */\n+/* { dg-final { scan-assembler-not {\\mxxspltib\\M} } } */\n+/* { dg-final { scan-assembler-not {\\mvspltisw\\M} } } */\n+/* { dg-final { scan-assembler-not {\\mxxlxor\\M}   } } */\n+/* { dg-final { scan-assembler-not {\\mxxlxorc\\M}  } } */\n+/* { dg-final { scan-assembler-not {\\mxxsel\\M}    } } */"}, {"sha": "a9f63c2ef50fa1630a5c89f72dd978d7bdb93607", "filename": "gcc/testsuite/gcc.target/powerpc/pr66144-3.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/391675acd2d18d0b6e5130a4105cf66eb1664683/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr66144-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/391675acd2d18d0b6e5130a4105cf66eb1664683/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr66144-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr66144-3.c?ref=391675acd2d18d0b6e5130a4105cf66eb1664683", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile { target { powerpc64*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-options \"-mcpu=power8 -O2 -ftree-vectorize\" } */\n+\n+/* Verify that we can optimize a vector conditional move, where one of the arms\n+   is all 1's into using the mask as one of the inputs to XXSEL.  */\n+\n+#include <altivec.h>\n+\n+static int a[1024], b[1024], c[1024];\n+\n+int *p_a = a, *p_b = b, *p_c = c;\n+\n+void\n+test (void)\n+{\n+  unsigned long i;\n+\n+  for (i = 0; i < 1024; i++)\n+    a[i] = (b[i] == c[i]) ? -1 : a[i];\n+}\n+\n+/* { dg-final { scan-assembler     {\\mvcmpequw\\M} } } */\n+/* { dg-final { scan-assembler     {\\mxxsel\\M}    } } */\n+/* { dg-final { scan-assembler-not {\\mvspltisw\\M} } } */\n+/* { dg-final { scan-assembler-not {\\mxxlorc\\M}   } } */"}]}