{"sha": "f387d86265958024451b95f52253123fdb829edc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjM4N2Q4NjI2NTk1ODAyNDQ1MWI5NWY1MjI1MzEyM2ZkYjgyOWVkYw==", "commit": {"author": {"name": "Bryce McKinlay", "email": "bryce@albatross.co.nz", "date": "2000-12-21T02:00:15Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2000-12-21T02:00:15Z"}, "message": "BasicMapEntry.java: Re-added.\n\n\t* java/util/BasicMapEntry.java: Re-added.\n\t* java/util/HashMap.java (Entry): Extend BasicMapEntry.\n\t(putAll): Test for BasicMapEntry.\n\t* java/util/Hashtable.java (Entry): Extend BasicMapEntry.\n\t(putAll): Test for BasicMapEntry.\n\tChange references from `HashMap.Entry' to `Entry' in various places.\n\t* Makefile.am: Add BasicMapEntry.java.\n\t* Makefile.in: Rebuilt.\n\nFrom-SVN: r38410", "tree": {"sha": "150b778219ba57eefde0f3fab0eda27eb0e43f4d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/150b778219ba57eefde0f3fab0eda27eb0e43f4d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f387d86265958024451b95f52253123fdb829edc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f387d86265958024451b95f52253123fdb829edc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f387d86265958024451b95f52253123fdb829edc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f387d86265958024451b95f52253123fdb829edc/comments", "author": null, "committer": null, "parents": [{"sha": "1228c7b6bde4a1504e2eb57626e58db322132805", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1228c7b6bde4a1504e2eb57626e58db322132805", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1228c7b6bde4a1504e2eb57626e58db322132805"}], "stats": {"total": 298, "additions": 173, "deletions": 125}, "files": [{"sha": "ceffba55ac01f73cb226b0b32ec185549d15f3a2", "filename": "libjava/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f387d86265958024451b95f52253123fdb829edc/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f387d86265958024451b95f52253123fdb829edc/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=f387d86265958024451b95f52253123fdb829edc", "patch": "@@ -1,3 +1,14 @@\n+2000-12-21  Bryce McKinlay  <bryce@albatross.co.nz>\n+\n+\t* java/util/BasicMapEntry.java: Re-added.\n+\t* java/util/HashMap.java (Entry): Extend BasicMapEntry.\n+\t(putAll): Test for BasicMapEntry.\n+\t* java/util/Hashtable.java (Entry): Extend BasicMapEntry.\n+\t(putAll): Test for BasicMapEntry.\n+\tChange references from `HashMap.Entry' to `Entry' in various places.\n+\t* Makefile.am: Add BasicMapEntry.java.\n+\t* Makefile.in: Rebuilt.\n+\n 2000-12-18  Warren Levy  <warrenl@redhat.com>\n \n \t* java/util/GregorianCalendar.java (GregorianCalendar): Constructors"}, {"sha": "acfccb86208f78926f92705f717e1e38478dfbaf", "filename": "libjava/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f387d86265958024451b95f52253123fdb829edc/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f387d86265958024451b95f52253123fdb829edc/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=f387d86265958024451b95f52253123fdb829edc", "patch": "@@ -929,6 +929,7 @@ java/util/AbstractSequentialList.java \\\n java/util/AbstractSet.java \\\n java/util/ArrayList.java \\\n java/util/Arrays.java \\\n+java/util/BasicMapEntry.java \\\n java/util/BitSet.java \\\n java/util/Calendar.java\t\\\n java/util/Collection.java \\"}, {"sha": "390c6ef60c86ad0b086522dd0e84facdcbddea52", "filename": "libjava/Makefile.in", "status": "modified", "additions": 25, "deletions": 40, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f387d86265958024451b95f52253123fdb829edc/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f387d86265958024451b95f52253123fdb829edc/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=f387d86265958024451b95f52253123fdb829edc", "patch": "@@ -120,43 +120,29 @@ here = @here@\n libgcj_basedir = @libgcj_basedir@\n \n AUTOMAKE_OPTIONS = foreign no-installinfo\n-@TESTSUBDIR_TRUE@SUBDIRS = \\\n-@TESTSUBDIR_TRUE@$(DIRLTDL) testsuite gcj include\n-@TESTSUBDIR_FALSE@SUBDIRS = \\\n-@TESTSUBDIR_FALSE@$(DIRLTDL) gcj include\n-@USE_LIBDIR_TRUE@toolexeclibdir = \\\n-@USE_LIBDIR_TRUE@$(libdir)$(MULTISUBDIR)\n-@USE_LIBDIR_FALSE@toolexeclibdir = \\\n-@USE_LIBDIR_FALSE@$(toolexecdir)/lib$(MULTISUBDIR)\n-@USE_LIBDIR_FALSE@toolexecdir = \\\n-@USE_LIBDIR_FALSE@$(exec_prefix)/$(target_alias)\n-@NO_X_TRUE@cond_x_ltlibrary = \\\n-@NO_X_FALSE@cond_x_ltlibrary = \\\n-@NO_X_FALSE@libgcjx.la\n+@TESTSUBDIR_TRUE@SUBDIRS = @TESTSUBDIR_TRUE@$(DIRLTDL) testsuite gcj include\n+@TESTSUBDIR_FALSE@SUBDIRS = @TESTSUBDIR_FALSE@$(DIRLTDL) gcj include\n+@USE_LIBDIR_TRUE@toolexeclibdir = @USE_LIBDIR_TRUE@$(libdir)$(MULTISUBDIR)\n+@USE_LIBDIR_FALSE@toolexeclibdir = @USE_LIBDIR_FALSE@$(toolexecdir)/lib$(MULTISUBDIR)\n+@USE_LIBDIR_FALSE@toolexecdir = @USE_LIBDIR_FALSE@$(exec_prefix)/$(target_alias)\n+@NO_X_TRUE@cond_x_ltlibrary = \n+@NO_X_FALSE@cond_x_ltlibrary = @NO_X_FALSE@libgcjx.la\n \n toolexeclib_LTLIBRARIES = libgcj.la $(cond_x_ltlibrary)\n toolexeclib_DATA = libgcj.spec\n data_DATA = libgcj.jar\n \n-@NEEDS_DATA_START_TRUE@toolexeclib_LIBRARIES = \\\n-@NEEDS_DATA_START_TRUE@libgcjdata.a\n-@NEEDS_DATA_START_TRUE@libgcjdata_a_SOURCES = \\\n-@NEEDS_DATA_START_TRUE@libgcjdata.c\n+@NEEDS_DATA_START_TRUE@toolexeclib_LIBRARIES = @NEEDS_DATA_START_TRUE@libgcjdata.a\n+@NEEDS_DATA_START_TRUE@libgcjdata_a_SOURCES = @NEEDS_DATA_START_TRUE@libgcjdata.c\n \n-@NATIVE_TRUE@bin_PROGRAMS = \\\n-@NATIVE_TRUE@jv-convert gij\n+@NATIVE_TRUE@bin_PROGRAMS = @NATIVE_TRUE@jv-convert gij\n \n bin_SCRIPTS = addr2name.awk\n-@CANADIAN_TRUE@@NULL_TARGET_TRUE@ZIP = \\\n-@CANADIAN_TRUE@@NULL_TARGET_TRUE@$(MULTIBUILDTOP)../$(COMPPATH)/fastjar/fastjar$(EXEEXT)\n-@CANADIAN_TRUE@@NULL_TARGET_FALSE@ZIP = \\\n-@CANADIAN_TRUE@@NULL_TARGET_FALSE@fastjar\n-@CANADIAN_FALSE@ZIP = \\\n-@CANADIAN_FALSE@$(MULTIBUILDTOP)../$(COMPPATH)/fastjar/fastjar$(EXEEXT)\n-@CANADIAN_TRUE@GCJH = \\\n-@CANADIAN_TRUE@gcjh\n-@CANADIAN_FALSE@GCJH = \\\n-@CANADIAN_FALSE@$(MULTIBUILDTOP)../$(COMPPATH)/gcc/gcjh$(EXEEXT)\n+@CANADIAN_TRUE@@NULL_TARGET_TRUE@ZIP = @CANADIAN_TRUE@@NULL_TARGET_TRUE@$(MULTIBUILDTOP)../$(COMPPATH)/fastjar/fastjar$(EXEEXT)\n+@CANADIAN_TRUE@@NULL_TARGET_FALSE@ZIP = @CANADIAN_TRUE@@NULL_TARGET_FALSE@fastjar\n+@CANADIAN_FALSE@ZIP = @CANADIAN_FALSE@$(MULTIBUILDTOP)../$(COMPPATH)/fastjar/fastjar$(EXEEXT)\n+@CANADIAN_TRUE@GCJH = @CANADIAN_TRUE@gcjh\n+@CANADIAN_FALSE@GCJH = @CANADIAN_FALSE@$(MULTIBUILDTOP)../$(COMPPATH)/gcc/gcjh$(EXEEXT)\n \n GCJ_WITH_FLAGS = $(GCJ) --encoding=UTF-8\n \n@@ -173,10 +159,8 @@ AM_CXXFLAGS = -fno-rtti -fvtable-thunks -fasynchronous-exceptions \\\n \t-fdollars-in-identifiers \\\n \t@LIBGCJ_CXXFLAGS@ @EXCEPTIONSPEC@ @X_CFLAGS@ $(WARNINGS) -D_GNU_SOURCE\n \n-@USING_GCC_TRUE@AM_CFLAGS = \\\n-@USING_GCC_TRUE@@LIBGCJ_CFLAGS@ $(WARNINGS)\n-@USING_GCC_FALSE@AM_CFLAGS = \\\n-@USING_GCC_FALSE@@LIBGCJ_CFLAGS@\n+@USING_GCC_TRUE@AM_CFLAGS = @USING_GCC_TRUE@@LIBGCJ_CFLAGS@ $(WARNINGS)\n+@USING_GCC_FALSE@AM_CFLAGS = @USING_GCC_FALSE@@LIBGCJ_CFLAGS@\n \n JCFLAGS = -g\n JC1FLAGS = -g @LIBGCJ_JAVAFLAGS@\n@@ -245,8 +229,7 @@ extra_headers = java/lang/Object.h java/lang/Class.h\n \n NM = nm\n \n-@NATIVE_TRUE@@MAINTAINER_MODE_TRUE@noinst_PROGRAMS = \\\n-@NATIVE_TRUE@@MAINTAINER_MODE_TRUE@gen-from-JIS\n+@NATIVE_TRUE@@MAINTAINER_MODE_TRUE@noinst_PROGRAMS = @NATIVE_TRUE@@MAINTAINER_MODE_TRUE@gen-from-JIS\n \n CONVERT_DIR = gnu/gcj/convert\n \n@@ -695,6 +678,7 @@ java/util/AbstractSequentialList.java \\\n java/util/AbstractSet.java \\\n java/util/ArrayList.java \\\n java/util/Arrays.java \\\n+java/util/BasicMapEntry.java \\\n java/util/BitSet.java \\\n java/util/Calendar.java\t\\\n java/util/Collection.java \\\n@@ -1210,7 +1194,7 @@ libgcj-test.spec.in libgcj.spec.in\n \n DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) $(TEXINFOS) $(EXTRA_DIST)\n \n-TAR = tar\n+TAR = gtar\n GZIP_ENV = --best\n DIST_SUBDIRS =  @DIRLTDL@ testsuite gcj include @DIRLTDL@ gcj include\n DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n@@ -1691,9 +1675,10 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/util/AbstractCollection.P .deps/java/util/AbstractList.P \\\n .deps/java/util/AbstractMap.P .deps/java/util/AbstractSequentialList.P \\\n .deps/java/util/AbstractSet.P .deps/java/util/ArrayList.P \\\n-.deps/java/util/Arrays.P .deps/java/util/BitSet.P \\\n-.deps/java/util/Calendar.P .deps/java/util/Collection.P \\\n-.deps/java/util/Collections.P .deps/java/util/Comparator.P \\\n+.deps/java/util/Arrays.P .deps/java/util/BasicMapEntry.P \\\n+.deps/java/util/BitSet.P .deps/java/util/Calendar.P \\\n+.deps/java/util/Collection.P .deps/java/util/Collections.P \\\n+.deps/java/util/Comparator.P \\\n .deps/java/util/ConcurrentModificationException.P \\\n .deps/java/util/Date.P .deps/java/util/Dictionary.P \\\n .deps/java/util/EmptyStackException.P .deps/java/util/Enumeration.P \\\n@@ -2111,7 +2096,7 @@ distdir: $(DISTFILES)\n \t@for file in $(DISTFILES); do \\\n \t  d=$(srcdir); \\\n \t  if test -d $$d/$$file; then \\\n-\t    cp -pr $$/$$file $(distdir)/$$file; \\\n+\t    cp -pr $$d/$$file $(distdir)/$$file; \\\n \t  else \\\n \t    test -f $(distdir)/$$file \\\n \t    || ln $$d/$$file $(distdir)/$$file 2> /dev/null \\"}, {"sha": "373015edca93210d6bd49db754285206a63cfef7", "filename": "libjava/java/util/BasicMapEntry.java", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f387d86265958024451b95f52253123fdb829edc/libjava%2Fjava%2Futil%2FBasicMapEntry.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f387d86265958024451b95f52253123fdb829edc/libjava%2Fjava%2Futil%2FBasicMapEntry.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FBasicMapEntry.java?ref=f387d86265958024451b95f52253123fdb829edc", "patch": "@@ -0,0 +1,92 @@\n+/* BasicMapEntry.java -- a class providing a plain-vanilla implementation of\n+   the Map.Entry interface; could be used anywhere in java.util\n+   Copyright (C) 1998, 2000 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n+package java.util;\n+\n+/**\n+ * A class which implements Map.Entry. It is shared by HashMap, TreeMap, and\n+ * Hashtable.\n+ *\n+ * @author      Jon Zeppieri\n+ * @version     $Revision: 1.5 $\n+ * @modified    $Id: BasicMapEntry.java,v 1.5 2000/10/26 10:19:00 bryce Exp $\n+ */\n+class BasicMapEntry implements Map.Entry\n+{\n+  Object key;\n+  Object value;\n+\n+  BasicMapEntry(Object newKey, Object newValue)\n+  {\n+    key = newKey;\n+    value = newValue;\n+  }\n+\n+  public final boolean equals(Object o)\n+  {\n+    if (!(o instanceof Map.Entry))\n+      return false;\n+    Map.Entry e = (Map.Entry) o;\n+    return (key == null ? e.getKey() == null : key.equals(e.getKey())\n+            && value == null ? e.getValue() == null \n+\t\t\t     : value.equals(e.getValue()));\n+  }\n+\n+  public final Object getKey()\n+  {\n+    return key;\n+  }\n+\n+  public final Object getValue()\n+  {\n+    return value;\n+  }\n+\n+  public final int hashCode()\n+  {\n+    int kc = (key == null ? 0 : key.hashCode());\n+    int vc = (value == null ? 0 : value.hashCode());\n+    return kc ^ vc;\n+  }\n+\n+  /** \n+   * sets the value of this Map.Entry. Note that this is overriden by \n+   * Hashtable.Entry, which does not permit a null value.\n+   */\n+  public Object setValue(Object newVal)\n+  {\n+    Object r = value;\n+    value = newVal;\n+    return r;\n+  }\n+\n+  public final String toString()\n+  {\n+    return key + \"=\" + value;\n+  }\n+}"}, {"sha": "b7ec3b49f4d16947ac92665d6214872093d48e27", "filename": "libjava/java/util/HashMap.java", "status": "modified", "additions": 9, "deletions": 51, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f387d86265958024451b95f52253123fdb829edc/libjava%2Fjava%2Futil%2FHashMap.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f387d86265958024451b95f52253123fdb829edc/libjava%2Fjava%2Futil%2FHashMap.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FHashMap.java?ref=f387d86265958024451b95f52253123fdb829edc", "patch": "@@ -60,16 +60,16 @@\n  * @author         Jon Zeppieri\n  * @author         Jochen Hoenicke\n  * @author\t   Bryce McKinlay\n- * @version        $Revision: 1.2 $\n- * @modified       $Id: HashMap.java,v 1.2 2000/12/11 03:47:47 bryce Exp $\n+ * @version        $Revision: 1.3 $\n+ * @modified       $Id: HashMap.java,v 1.3 2000/12/17 09:15:51 bryce Exp $\n  */\n public class HashMap extends AbstractMap\n   implements Map, Cloneable, Serializable\n {\n   /** Default number of buckets. This is the value the JDK 1.3 uses. Some \n     * early documentation specified this value as 101. That is incorrect. */\n   private static final int DEFAULT_CAPACITY = 11;  \n-  /** The defaulty load factor; this is explicitly specified by Sun */\n+  /** The defaulty load factor; this is explicitly specified by the spec. */\n   private static final float DEFAULT_LOAD_FACTOR = 0.75f;\n \n   private static final long serialVersionUID = 362498820763181265L;\n@@ -104,56 +104,14 @@ public class HashMap extends AbstractMap\n    * Class to represent an entry in the hash table. Holds a single key-value\n    * pair.\n    */\n-  static class Entry implements Map.Entry\n+  static class Entry extends BasicMapEntry\n   {\n-    Object key;\n-    Object value;\n     Entry next;\n     \n     Entry(Object key, Object value)\n     {\n-      this.key = key;\n-      this.value = value;\n+      super(key, value);\n     }\n-\n-    public boolean equals(Object o)\n-    {\n-      if (!(o instanceof Map.Entry))\n-        return false;\n-      Map.Entry e = (Map.Entry) o;\n-      return (key == null ? e.getKey() == null : key.equals(e.getKey())\n-              && value == null ? e.getValue() == null : \n-\t         value.equals(e.getValue()));\n-    }\n-    \n-    public Object getKey()\n-    {\n-      return key;\n-    }\n-    \n-    public Object getValue()\n-    {\n-      return value;\n-    }\n-    \n-    public int hashCode()\n-    {\n-      int kc = (key == null ? 0 : key.hashCode());\n-      int vc = (value == null ? 0 : value.hashCode());\n-      return kc ^ vc;\n-    }\n-    \n-    public Object setValue(Object newVal)\n-    {\n-      Object r = value;\n-      value = newVal;\n-      return r;\n-    }\n-    \n-    public String toString()\n-    {\n-      return key + \"=\" + value;\n-    }    \n   }\n \n   /**\n@@ -368,9 +326,9 @@ public void putAll(Map m)\n       {\n         Map.Entry e = (Map.Entry) itr.next();\n \t// Optimize in case the Entry is one of our own.\n-\tif (e instanceof Entry)\n+\tif (e instanceof BasicMapEntry)\n \t  {\n-\t    Entry entry = (Entry) e;\n+\t    BasicMapEntry entry = (BasicMapEntry) e;\n \t    put(entry.key, entry.value);\n \t  }\n \telse\n@@ -660,8 +618,8 @@ private void readObject(ObjectInputStream s)\n    * as per the Javasoft spec.\n    *\n    * @author       Jon Zeppieri\n-   * @version      $Revision: 1.2 $\n-   * @modified     $Id: HashMap.java,v 1.2 2000/12/11 03:47:47 bryce Exp $\n+   * @version      $Revision: 1.3 $\n+   * @modified     $Id: HashMap.java,v 1.3 2000/12/17 09:15:51 bryce Exp $\n    */\n   class HashIterator implements Iterator\n   {"}, {"sha": "9585872fffec968ec31fad9c9b10e4d5aa799bb2", "filename": "libjava/java/util/Hashtable.java", "status": "modified", "additions": 35, "deletions": 34, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f387d86265958024451b95f52253123fdb829edc/libjava%2Fjava%2Futil%2FHashtable.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f387d86265958024451b95f52253123fdb829edc/libjava%2Fjava%2Futil%2FHashtable.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FHashtable.java?ref=f387d86265958024451b95f52253123fdb829edc", "patch": "@@ -64,16 +64,16 @@\n  * @author      Jon Zeppieri\n  * @author\tWarren Levy\n  * @author      Bryce McKinlay\n- * @version     $Revision: 1.8 $\n- * @modified    $Id: Hashtable.java,v 1.8 2000/12/11 04:54:55 bryce Exp $\n+ * @version     $Revision: 1.9 $\n+ * @modified    $Id: Hashtable.java,v 1.9 2000/12/17 09:15:51 bryce Exp $\n  */\n public class Hashtable extends Dictionary \n   implements Map, Cloneable, Serializable\n {\n   /** Default number of buckets. This is the value the JDK 1.3 uses. Some \n     * early documentation specified this value as 101. That is incorrect. */\n   private static final int DEFAULT_CAPACITY = 11;  \n-  /** The defaulty load factor; this is explicitly specified by Sun */\n+  /** The defaulty load factor; this is explicitly specified by the spec. */\n   private static final float DEFAULT_LOAD_FACTOR = 0.75f;\n \n   private static final long serialVersionUID = 1421746759512286392L;\n@@ -93,7 +93,7 @@ public class Hashtable extends Dictionary\n   /** \n    * Array containing the actual key-value mappings\n    */\n-  transient HashMap.Entry[] buckets;\n+  transient Entry[] buckets;\n \n   /** \n    * counts the number of modifications this Hashtable has undergone, used \n@@ -109,14 +109,16 @@ public class Hashtable extends Dictionary\n    * pair. A Hashtable Entry is identical to a HashMap Entry, except that\n    * `null' is not allowed for keys and values. \n    */\n-  static class Entry extends HashMap.Entry\n+  static class Entry extends BasicMapEntry\n   {\n+    Entry next;\n+      \n     Entry(Object key, Object value)\n     {\n       super(key, value);\n     }\n \n-    public Object setValue(Object newVal)\n+    public final Object setValue(Object newVal)\n     {\n       if (newVal == null)\n         throw new NullPointerException();\n@@ -195,7 +197,6 @@ public boolean isEmpty()\n     return size == 0;\n   }\n \n-  /** */\n   public synchronized Enumeration keys()\n   {\n     return new Enumerator(Enumerator.KEYS);\n@@ -222,7 +223,7 @@ public synchronized boolean contains(Object value)\n   {\n     for (int i = 0; i < buckets.length; i++)\n       {\n-\tHashMap.Entry e = buckets[i];\n+\tEntry e = buckets[i];\n \twhile (e != null)\n \t  {\n \t    if (value.equals(e.value))\n@@ -255,7 +256,7 @@ public boolean containsValue(Object value)\n   public synchronized boolean containsKey(Object key)\n   {\n     int idx = hash(key);\n-    HashMap.Entry e = buckets[idx];\n+    Entry e = buckets[idx];\n     while (e != null)\n       {\n         if (key.equals(e.key))\n@@ -274,7 +275,7 @@ public synchronized boolean containsKey(Object key)\n   public synchronized Object get(Object key)\n   {\n     int idx = hash(key);\n-    HashMap.Entry e = buckets[idx];\n+    Entry e = buckets[idx];\n     while (e != null)\n       {\n         if (key.equals(e.key))\n@@ -294,7 +295,7 @@ public synchronized Object put(Object key, Object value)\n   {\n     modCount++;\n     int idx = hash(key);\n-    HashMap.Entry e = buckets[idx];\n+    Entry e = buckets[idx];\n     \n     // Hashtable does not accept null values. This method doesn't dereference \n     // `value' anywhere, so check for it explicitly.\n@@ -342,8 +343,8 @@ public synchronized Object remove(Object key)\n   {\n     modCount++;\n     int idx = hash(key);\n-    HashMap.Entry e = buckets[idx];\n-    HashMap.Entry last = null;\n+    Entry e = buckets[idx];\n+    Entry last = null;\n \n     while (e != null)\n       {\n@@ -371,9 +372,9 @@ public synchronized void putAll(Map m)\n       {\n         Map.Entry e = (Map.Entry) itr.next();\n \t// Optimize in case the Entry is one of our own.\n-\tif (e instanceof Entry)\n+\tif (e instanceof BasicMapEntry)\n \t  {\n-\t    Entry entry = (Entry) e;\n+\t    BasicMapEntry entry = (BasicMapEntry) e;\n \t    put(entry.key, entry.value);\n \t  }\n \telse\n@@ -411,8 +412,8 @@ public synchronized Object clone()\n     \n     for (int i=0; i < buckets.length; i++)\n       {\n-        HashMap.Entry e = buckets[i];\n-\tHashMap.Entry last = null;\n+        Entry e = buckets[i];\n+\tEntry last = null;\n \t\n \twhile (e != null)\n \t  {\n@@ -536,7 +537,7 @@ public boolean contains(Object o)\n         if (!(o instanceof Map.Entry))\n \t  return false;\n \tMap.Entry me = (Map.Entry) o;\n-\tHashMap.Entry e = getEntry(me);\n+\tEntry e = getEntry(me);\n \treturn (e != null);\n       }\n       \n@@ -545,7 +546,7 @@ public boolean remove(Object o)\n         if (!(o instanceof Map.Entry))\n \t  return false;\n \tMap.Entry me = (Map.Entry) o;\n-\tHashMap.Entry e = getEntry(me);\n+\tEntry e = getEntry(me);\n \tif (e != null)\n \t  {\n \t    Hashtable.this.remove(e.key);\n@@ -609,10 +610,10 @@ private int hash(Object key)\n     return Math.abs(key.hashCode() % buckets.length);\n   }\n \n-  private HashMap.Entry getEntry(Map.Entry me)\n+  private Entry getEntry(Map.Entry me)\n   {\n     int idx = hash(me.getKey());\n-    HashMap.Entry e = buckets[idx];\n+    Entry e = buckets[idx];\n     while (e != null)\n       {\n         if (e.equals(me))\n@@ -630,19 +631,19 @@ private HashMap.Entry getEntry(Map.Entry me)\n    */\n   protected void rehash()\n   {\n-    HashMap.Entry[] oldBuckets = buckets;\n+    Entry[] oldBuckets = buckets;\n     \n     int newcapacity = (buckets.length * 2) + 1;\n     threshold = (int) (newcapacity * loadFactor);\n     buckets = new Entry[newcapacity];\n     \n     for (int i = 0; i < oldBuckets.length; i++)\n       {\n-\tHashMap.Entry e = oldBuckets[i];\n+\tEntry e = oldBuckets[i];\n         while (e != null)\n \t  {\n \t    int idx = hash(e.key);\n-\t    HashMap.Entry dest = buckets[idx];\n+\t    Entry dest = buckets[idx];\n \n \t    if (dest != null)\n \t      {\n@@ -655,7 +656,7 @@ protected void rehash()\n         \tbuckets[idx] = e;\n \t      }\n \n-\t    HashMap.Entry next = e.next;\n+\t    Entry next = e.next;\n \t    e.next = null;\n \t    e = next;\n \t  }\n@@ -720,8 +721,8 @@ private void readObject(ObjectInputStream s)\n    * as per the Javasoft spec.\n    *\n    * @author       Jon Zeppieri\n-   * @version      $Revision: 1.8 $\n-   * @modified     $Id: Hashtable.java,v 1.8 2000/12/11 04:54:55 bryce Exp $\n+   * @version      $Revision: 1.9 $\n+   * @modified     $Id: Hashtable.java,v 1.9 2000/12/17 09:15:51 bryce Exp $\n    */\n   class HashIterator implements Iterator\n   {\n@@ -739,11 +740,11 @@ class HashIterator implements Iterator\n     // Current index in the physical hash table.\n     int idx;\n     // The last Entry returned by a next() call.\n-    HashMap.Entry last;\n+    Entry last;\n     // The next entry that should be returned by next(). It is set to something\n     // if we're iterating through a bucket that contains multiple linked \n     // entries. It is null if next() needs to find a new bucket.\n-    HashMap.Entry next;\n+    Entry next;\n \n     /* Construct a new HashIterator with the supplied type: \n        KEYS, VALUES, or ENTRIES */\n@@ -771,7 +772,7 @@ public Object next()\n       if (count == size)\n         throw new NoSuchElementException();\n       count++;\n-      HashMap.Entry e = null;\n+      Entry e = null;\n       if (next != null)\n         e = next;\n \n@@ -825,8 +826,8 @@ public void remove()\n    * hashtable during enumeration causes indeterminate results.  Don't do it!\n    *\n    * @author       Jon Zeppieri\n-   * @version      $Revision: 1.8 $\n-   * @modified $Id: Hashtable.java,v 1.8 2000/12/11 04:54:55 bryce Exp $ */\n+   * @version      $Revision: 1.9 $\n+   * @modified $Id: Hashtable.java,v 1.9 2000/12/17 09:15:51 bryce Exp $ */\n   class Enumerator implements Enumeration\n   {\n     static final int KEYS = 0;\n@@ -839,7 +840,7 @@ class Enumerator implements Enumeration\n     // current index in the physical hash table.\n     int idx;\n     // the last Entry returned.\n-    HashMap.Entry last;\n+    Entry last;\n     \n     Enumerator(int type)\n     {\n@@ -858,7 +859,7 @@ public Object nextElement()\n       if (count >= size)\n         throw new NoSuchElementException();\n       count++;\n-      HashMap.Entry e = null;\n+      Entry e = null;\n       if (last != null)\n         e = last.next;\n "}]}