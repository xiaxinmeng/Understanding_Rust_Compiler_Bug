{"sha": "e7c6980e55d974035a4d85b3551eca47181d1bfc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTdjNjk4MGU1NWQ5NzQwMzVhNGQ4NWIzNTUxZWNhNDcxODFkMWJmYw==", "commit": {"author": {"name": "Anatoly Sokolov", "email": "aesok@post.ru", "date": "2015-10-29T22:00:06Z"}, "committer": {"name": "Anatoly Sokolov", "email": "aesok@gcc.gnu.org", "date": "2015-10-29T22:00:06Z"}, "message": "[MCORE] Hookize GO_IF_LEGITIMATE_ADDRESS\n\nFrom-SVN: r229561", "tree": {"sha": "c5c7979bc16430337b16a155e706197dd14f79d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c5c7979bc16430337b16a155e706197dd14f79d9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e7c6980e55d974035a4d85b3551eca47181d1bfc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7c6980e55d974035a4d85b3551eca47181d1bfc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7c6980e55d974035a4d85b3551eca47181d1bfc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7c6980e55d974035a4d85b3551eca47181d1bfc/comments", "author": null, "committer": null, "parents": [{"sha": "334b4842a280bf7fde59f1c844099678a0fe219d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/334b4842a280bf7fde59f1c844099678a0fe219d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/334b4842a280bf7fde59f1c844099678a0fe219d"}], "stats": {"total": 170, "additions": 85, "deletions": 85}, "files": [{"sha": "70895a604fd6e702a7ae01ca3dc904a9034eb1f3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7c6980e55d974035a4d85b3551eca47181d1bfc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7c6980e55d974035a4d85b3551eca47181d1bfc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e7c6980e55d974035a4d85b3551eca47181d1bfc", "patch": "@@ -1,3 +1,13 @@\n+2015-08-29  Anatoly Sokolov  <aesok@post.ru>\n+\n+\t* config/mcore/mcore.h (REG_OK_FOR_BASE_P, REG_OK_FOR_INDEX_P,\n+\tBASE_REGISTER_RTX_P, INDEX_REGISTER_RTX_P,\n+\tGO_IF_LEGITIMATE_ADDRESS): Remove macros.\n+\t* config/mcore/mcore.c (mcore_reg_ok_for_base_p,\n+\tmcore_base_register_rtx_p, mcore_legitimate_index_p,\n+\tmcore_legitimate_address_p): New functions.\n+\t(TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P): Define. \n+\n 2015-10-29  Jeff Law  <law@redhat.com>\n \n \t* tree-ssa-scopedtables.h (const_and_copies): Remove invalidate"}, {"sha": "b42f633f696e038a8c320393741f174dd6ac029a", "filename": "gcc/config/mcore/mcore.c", "status": "modified", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7c6980e55d974035a4d85b3551eca47181d1bfc/gcc%2Fconfig%2Fmcore%2Fmcore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7c6980e55d974035a4d85b3551eca47181d1bfc/gcc%2Fconfig%2Fmcore%2Fmcore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.c?ref=e7c6980e55d974035a4d85b3551eca47181d1bfc", "patch": "@@ -139,6 +139,8 @@ static void       mcore_trampoline_init\t\t(rtx, tree, rtx);\n static bool       mcore_warn_func_return        (tree);\n static void       mcore_option_override\t\t(void);\n static bool       mcore_legitimate_constant_p   (machine_mode, rtx);\n+static bool\t  mcore_legitimate_address_p\t(machine_mode, rtx, bool,\n+\t\t\t\t\t\t addr_space_t);\n \f\n /* MCore specific attributes.  */\n \n@@ -226,6 +228,8 @@ static const struct attribute_spec mcore_attribute_table[] =\n \n #undef TARGET_LEGITIMATE_CONSTANT_P\n #define TARGET_LEGITIMATE_CONSTANT_P mcore_legitimate_constant_p\n+#undef TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P\n+#define TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P mcore_legitimate_address_p\n \n #undef TARGET_WARN_FUNC_RETURN\n #define TARGET_WARN_FUNC_RETURN mcore_warn_func_return\n@@ -3179,3 +3183,74 @@ mcore_legitimate_constant_p (machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n {\n   return GET_CODE (x) != CONST_DOUBLE;\n }\n+\n+/* Helper function for `mcore_legitimate_address_p'.  */\n+\n+static bool\n+mcore_reg_ok_for_base_p (const_rtx reg, bool strict_p)\n+{\n+  if (strict_p)\n+    return REGNO_OK_FOR_BASE_P (REGNO (reg));\n+  else\n+    return (REGNO (reg) <= 16 || !HARD_REGISTER_P (reg));\n+}\n+\n+static bool\n+mcore_base_register_rtx_p (const_rtx x, bool strict_p)\n+{\n+  return REG_P(x) && mcore_reg_ok_for_base_p (x, strict_p); \n+}\n+\n+/*  A legitimate index for a QI is 0..15, for HI is 0..30, for SI is 0..60,\n+    and for DI is 0..56 because we use two SI loads, etc.  */\n+\n+static bool   \n+mcore_legitimate_index_p (machine_mode mode, const_rtx op)\n+{\n+  if (CONST_INT_P (op))\n+    {\n+      if (GET_MODE_SIZE (mode) >= 4\n+\t  && (((unsigned HOST_WIDE_INT) INTVAL (op)) % 4) == 0\n+\t  &&  ((unsigned HOST_WIDE_INT) INTVAL (op))\n+\t      <= (unsigned HOST_WIDE_INT) 64 - GET_MODE_SIZE (mode))\n+\treturn true;\n+      if (GET_MODE_SIZE (mode) == 2\n+\t  && (((unsigned HOST_WIDE_INT) INTVAL (op)) % 2) == 0\n+\t  &&  ((unsigned HOST_WIDE_INT) INTVAL (op)) <= 30)\n+\treturn true;\n+      if (GET_MODE_SIZE (mode) == 1\n+\t  && ((unsigned HOST_WIDE_INT) INTVAL (op)) <= 15)\n+\treturn true;\n+  }\t\t\t\t\t\t\t\t\n+  return false;\n+}\n+\n+ \n+/* Worker function for TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P.\n+\n+   Allow  REG\n+\t  REG + disp  */\n+\n+static bool\n+mcore_legitimate_address_p (machine_mode mode, rtx x, bool strict_p,\n+\t\t\t    addr_space_t as)\n+{\n+  gcc_assert (ADDR_SPACE_GENERIC_P (as));\n+\n+  if (mcore_base_register_rtx_p (x, strict_p))\n+    return true;\n+  else if (GET_CODE (x) == PLUS || GET_CODE (x) == LO_SUM)\n+    {\n+      rtx xop0 = XEXP (x, 0);\n+      rtx xop1 = XEXP (x, 1);\n+      if (mcore_base_register_rtx_p (xop0, strict_p)\n+\t  && mcore_legitimate_index_p (mode, xop1))\n+\treturn true;\n+      if (mcore_base_register_rtx_p (xop1, strict_p)\n+ \t  && mcore_legitimate_index_p (mode, xop0))\n+\treturn true;\n+    }\n+\n+  return false;\n+}\n+"}, {"sha": "21952d1bcfb9433a2f43451908ab6b550f761b4a", "filename": "gcc/config/mcore/mcore.h", "status": "modified", "additions": 0, "deletions": 85, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7c6980e55d974035a4d85b3551eca47181d1bfc/gcc%2Fconfig%2Fmcore%2Fmcore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7c6980e55d974035a4d85b3551eca47181d1bfc/gcc%2Fconfig%2Fmcore%2Fmcore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.h?ref=e7c6980e55d974035a4d85b3551eca47181d1bfc", "patch": "@@ -529,91 +529,6 @@ extern const enum reg_class regno_reg_class[FIRST_PSEUDO_REGISTER];\n /* Recognize any constant value that is a valid address.  */\n #define CONSTANT_ADDRESS_P(X) \t (GET_CODE (X) == LABEL_REF)\n \n-/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n-   and check its validity for a certain class.\n-   We have two alternate definitions for each of them.\n-   The usual definition accepts all pseudo regs; the other rejects\n-   them unless they have been allocated suitable hard regs.\n-   The symbol REG_OK_STRICT causes the latter definition to be used.  */\n-#ifndef REG_OK_STRICT\n-\n-/* Nonzero if X is a hard reg that can be used as a base reg\n-   or if it is a pseudo reg.  */\n-#define REG_OK_FOR_BASE_P(X) \\\n-    \t(REGNO (X) <= 16 || REGNO (X) >= FIRST_PSEUDO_REGISTER)\n-\n-/* Nonzero if X is a hard reg that can be used as an index\n-   or if it is a pseudo reg.  */\n-#define REG_OK_FOR_INDEX_P(X)\t0\n-\n-#else\n-\n-/* Nonzero if X is a hard reg that can be used as a base reg.  */\n-#define REG_OK_FOR_BASE_P(X)\t\\\n-\tREGNO_OK_FOR_BASE_P (REGNO (X))\n-\n-/* Nonzero if X is a hard reg that can be used as an index.  */\n-#define REG_OK_FOR_INDEX_P(X)\t0\n-\n-#endif\n-/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n-   that is a valid memory address for an instruction.\n-   The MODE argument is the machine mode for the MEM expression\n-   that wants to use this address.\n-\n-   The other macros defined here are used only in GO_IF_LEGITIMATE_ADDRESS.  */\n-#define BASE_REGISTER_RTX_P(X)  \\\n-  (GET_CODE (X) == REG && REG_OK_FOR_BASE_P (X))\n-\n-#define INDEX_REGISTER_RTX_P(X)  \\\n-  (GET_CODE (X) == REG && REG_OK_FOR_INDEX_P (X))\n-\n-\n-/* Jump to LABEL if X is a valid address RTX.  This must also take\n-   REG_OK_STRICT into account when deciding about valid registers, but it uses\n-   the above macros so we are in luck.  \n- \n-   Allow  REG\n-\t  REG+disp \n-\n-   A legitimate index for a QI is 0..15, for HI is 0..30, for SI is 0..60,\n-   and for DI is 0..56 because we use two SI loads, etc.  */\n-#define GO_IF_LEGITIMATE_INDEX(MODE, REGNO, OP, LABEL)\t\t\t\\\n-  do\t\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      if (GET_CODE (OP) == CONST_INT) \t\t\t\t\t\\\n-        {\t\t\t\t\t\t\t\t\\\n-\t  if (GET_MODE_SIZE (MODE) >= 4\t\t\t\t\t\\\n-\t      && (((unsigned HOST_WIDE_INT) INTVAL (OP)) % 4) == 0\t\\\n-\t      &&  ((unsigned HOST_WIDE_INT) INTVAL (OP))\t\t\\\n-\t      <= (unsigned HOST_WIDE_INT) 64 - GET_MODE_SIZE (MODE))\t\\\n-\t    goto LABEL;\t\t\t\t\t\t\t\\\n-\t  if (GET_MODE_SIZE (MODE) == 2 \t\t\t\t\\\n-\t      && (((unsigned HOST_WIDE_INT) INTVAL (OP)) % 2) == 0\t\\\n-\t      &&  ((unsigned HOST_WIDE_INT) INTVAL (OP)) <= 30)\t\t\\\n-\t    goto LABEL;\t\t\t\t\t\t\t\\\n-\t  if (GET_MODE_SIZE (MODE) == 1 \t\t\t\t\\\n-\t      && ((unsigned HOST_WIDE_INT) INTVAL (OP)) <= 15)\t\t\\\n-\t    goto LABEL;\t\t\t\t\t\t\t\\\n-        }\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  while (0)\n-\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, LABEL)                  \\\n-{ \t\t\t\t\t\t\t\t  \\\n-  if (BASE_REGISTER_RTX_P (X))\t\t\t\t\t  \\\n-    goto LABEL;\t\t\t\t\t\t\t  \\\n-  else if (GET_CODE (X) == PLUS || GET_CODE (X) == LO_SUM) \t  \\\n-    {\t\t\t\t\t\t\t\t  \\\n-      rtx xop0 = XEXP (X,0);\t\t\t\t\t  \\\n-      rtx xop1 = XEXP (X,1);\t\t\t\t\t  \\\n-      if (BASE_REGISTER_RTX_P (xop0))\t\t\t\t  \\\n-\tGO_IF_LEGITIMATE_INDEX (MODE, REGNO (xop0), xop1, LABEL); \\\n-      if (BASE_REGISTER_RTX_P (xop1))\t\t\t\t  \\\n-\tGO_IF_LEGITIMATE_INDEX (MODE, REGNO (xop1), xop0, LABEL); \\\n-    }\t\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t   \n-\n /* Specify the machine mode that this machine uses\n    for the index in the tablejump instruction.  */\n #define CASE_VECTOR_MODE SImode"}]}