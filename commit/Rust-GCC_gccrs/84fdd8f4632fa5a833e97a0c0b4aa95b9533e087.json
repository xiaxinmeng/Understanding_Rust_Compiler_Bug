{"sha": "84fdd8f4632fa5a833e97a0c0b4aa95b9533e087", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODRmZGQ4ZjQ2MzJmYTVhODMzZTk3YTBjMGI0YWE5NWI5NTMzZTA4Nw==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2019-02-18T18:37:55Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2019-02-18T18:37:55Z"}, "message": "cpp.texi (Conditional syntax): Add __has_attribute, __has_cpp_attribute, and __has_include.\n\n\ngcc/ChangeLog:\n\n\t* doc/cpp.texi (Conditional syntax): Add __has_attribute,\n\t__has_cpp_attribute, and __has_include.\n\nFrom-SVN: r268993", "tree": {"sha": "8ed78374e133ed574d988c4591225977d47004f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8ed78374e133ed574d988c4591225977d47004f5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/84fdd8f4632fa5a833e97a0c0b4aa95b9533e087", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84fdd8f4632fa5a833e97a0c0b4aa95b9533e087", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84fdd8f4632fa5a833e97a0c0b4aa95b9533e087", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84fdd8f4632fa5a833e97a0c0b4aa95b9533e087/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "378f53c75232416c9171bcfb42a551371321bffe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/378f53c75232416c9171bcfb42a551371321bffe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/378f53c75232416c9171bcfb42a551371321bffe"}], "stats": {"total": 101, "additions": 101, "deletions": 0}, "files": [{"sha": "dba151b12ae4ece99f1ea19fb19410d305a58864", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84fdd8f4632fa5a833e97a0c0b4aa95b9533e087/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84fdd8f4632fa5a833e97a0c0b4aa95b9533e087/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=84fdd8f4632fa5a833e97a0c0b4aa95b9533e087", "patch": "@@ -1,3 +1,8 @@\n+2019-02-18  Martin Sebor  <msebor@redhat.com>\n+\n+\t* doc/cpp.texi (Conditional syntax): Add __has_attribute,\n+\t__has_cpp_attribute, and __has_include.\n+\n 2019-02-18  Martin Sebor  <msebor@redhat.com>\n \n \t* doc/invoke.texi (-Wreturn-type): Correct and expand."}, {"sha": "e271f5180d87bed28850673297261a0cf410af82", "filename": "gcc/doc/cpp.texi", "status": "modified", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84fdd8f4632fa5a833e97a0c0b4aa95b9533e087/gcc%2Fdoc%2Fcpp.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84fdd8f4632fa5a833e97a0c0b4aa95b9533e087/gcc%2Fdoc%2Fcpp.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fcpp.texi?ref=84fdd8f4632fa5a833e97a0c0b4aa95b9533e087", "patch": "@@ -3158,6 +3158,9 @@ directive}: @samp{#if}, @samp{#ifdef} or @samp{#ifndef}.\n * Defined::\n * Else::\n * Elif::\n+* @code{__has_attribute}::\n+* @code{__has_cpp_attribute}::\n+* @code{__has_include}::\n @end menu\n \n @node Ifdef\n@@ -3422,6 +3425,99 @@ condition succeeds after the original @samp{#if} and all previous\n @samp{#else} is allowed after any number of @samp{#elif} directives, but\n @samp{#elif} may not follow @samp{#else}.\n \n+@node @code{__has_attribute}\n+@subsection @code{__has_attribute}\n+@cindex @code{__has_attribute}\n+\n+The special operator @code{__has_attribute (@var{operand})} may be used\n+in @samp{#if} and @samp{#elif} expressions to test whether the attribute\n+referenced by its @var{operand} is recognized by GCC.  Using the operator\n+in other contexts is not valid.  In C code, @var{operand} must be\n+a valid identifier.  In C++ code, @var{operand} may be optionally\n+introduced by the @code{@var{attribute-scope}::} prefix.\n+The @var{attribute-scope} prefix identifies the ``namespace'' within\n+which the attribute is recognized.  The scope of GCC attributes is\n+@samp{gnu} or @samp{__gnu__}.  The @code{__has_attribute} operator by\n+itself, without any @var{operand} or parentheses, acts as a predefined\n+macro so that support for it can be tested in portable code.  Thus,\n+the recommended use of the operator is as follows:\n+\n+@smallexample\n+#if defined __has_attribute\n+#  if __has_attribute (nonnull)\n+#    define ATTR_NONNULL __attribute__ ((nonnull))\n+#  endif\n+#endif\n+@end smallexample\n+\n+The first @samp{#if} test succeeds only when the operator is supported\n+by the version of GCC (or another compiler) being used.  Only when that\n+test succeeds is it valid to use @code{__has_attribute} as a preprocessor\n+operator.  As a result, combining the two tests into a single expression as\n+shown below would only be valid with a compiler that supports the operator\n+but not with others that don't.\n+\n+@smallexample\n+#if defined __has_attribute && __has_attribute (nonnull)   /* not portable */\n+@dots{}\n+#endif\n+@end smallexample\n+\n+@node @code{__has_cpp_attribute}\n+@subsection @code{__has_cpp_attribute}\n+@cindex @code{__has_cpp_attribute}\n+\n+The special operator @code{__has_cpp_attribute (@var{operand})} may be used\n+in @samp{#if} and @samp{#elif} expressions in C++ code to test whether\n+the attribute referenced by its @var{operand} is recognized by GCC.\n+@code{__has_cpp_attribute (@var{operand})} is equivalent to\n+@code{__has_attribute (@var{operand})} except that when @var{operand}\n+designates a supported standard attribute it evaluates to an integer\n+constant of the form @code{YYYYMM} indicating the year and month when\n+the attribute was first introduced into the C++ standard.  For additional\n+information including the dates of the introduction of current standard\n+attributes, see @w{@uref{https://isocpp.org/std/standing-documents/sd-6-sg10-feature-test-recommendations/,\n+SD-6: SG10 Feature Test Recommendations}}.\n+\n+@node @code{__has_include}\n+@subsection @code{__has_include}\n+@cindex @code{__has_include}\n+\n+The special operator @code{__has_include (@var{operand})} may be used in\n+@samp{#if} and @samp{#elif} expressions to test whether the header referenced\n+by its @var{operand} can be included using the @samp{#include} directive.  Using\n+the operator in other contexts is not valid.  The @var{operand} takes\n+the same form as the file in the @samp{#include} directive (@pxref{Include\n+Syntax}) and evaluates to a nonzero value if the header can be included and\n+to zero otherwise.  Note that that the ability to include a header doesn't\n+imply that the header doesn't contain invalid constructs or @samp{#error}\n+directives that would cause the preprocessor to fail.\n+\n+The @code{__has_include} operator by itself, without any @var{operand} or\n+parentheses, acts as a predefined macro so that support for it can be tested\n+in portable code.  Thus, the recommended use of the operator is as follows:\n+\n+@smallexample\n+#if defined __has_include\n+#  if __has_include (<stdatomic.h>)\n+#    include <stdatomic.h>\n+#  endif\n+#endif\n+@end smallexample\n+\n+The first @samp{#if} test succeeds only when the operator is supported\n+by the version of GCC (or another compiler) being used.  Only when that\n+test succeeds is it valid to use @code{__has_include} as a preprocessor\n+operator.  As a result, combining the two tests into a single expression\n+as shown below would only be valid with a compiler that supports the operator\n+but not with others that don't.\n+\n+@smallexample\n+#if defined __has_include && __has_include (\"header.h\")   /* not portable */\n+@dots{}\n+#endif\n+@end smallexample\n+\n @node Deleted Code\n @section Deleted Code\n @cindex commenting out code"}]}