{"sha": "22421b79c8da16dd6dccb2232c1da6096590e525", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjI0MjFiNzljOGRhMTZkZDZkY2NiMjIzMmMxZGE2MDk2NTkwZTUyNQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2004-03-23T20:43:44Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2004-03-23T20:43:44Z"}, "message": "alias.c (get_alias_set): Add support for TYPE_REF_CAN_ALIAS_ALL.\n\n\t* alias.c (get_alias_set): Add support for TYPE_REF_CAN_ALIAS_ALL.\n\t* c-common.c (handle_mode_attribute): Add extra arg to\n\tbuild_pointer_type_for_mode and build_reference_type_for_mode.\n\t* c-typeck.c (build_c_cast): Only look at TREE_CONSTANT_OVERFLOW\n\tfor INTEGER_CST.\n\t* tree.c (build_pointer_type_for_mode): Add arg CAN_ALIAS_ALL.\n\tChain pointers via TYPE_NEXT_PTR_TO.\n\t(build_reference_type_for_mode): Similarly.\n\t(build_type_no_quals): Add extra arg to build_pointer_type_for_mode\n\tand build_reference_type_for_mode.\n\t(tree_check4_failed): New function.\n\t* tree.h (TREE_CHECK4, PTR_OR_REF_CHECK): New macros.\n\t(TYPE_REF_CAN_ALIAS_ALL, TYPE_NEXT_PTR_TO, TYPE_NEXT_REF_TO): Likewise.\n\t(TREE_NO_UNSUED_WARNING, TREE_VIA_VIRTUAL, TREE_CONSTANT_OVERFLOW):\n\tAdd check.\n\n\t* cp/typeck.c (build_c_cast): Only look at TREE_CONSTANT_OVERFLOW\n\tfor INTEGER_CST.\n\n\t* ada/decl.c (gnat_to_gnu_entity, case E_Access_Type): Pass value\n\tof No_Strict_Aliasing to build_pointer_type_for_mode.\n\t* ada/utils.c (update_pointer_to): Walk pointer and ref chains.\n\nFrom-SVN: r79873", "tree": {"sha": "78c56d654a5d59c1b915116b930d92efc18f678e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/78c56d654a5d59c1b915116b930d92efc18f678e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/22421b79c8da16dd6dccb2232c1da6096590e525", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22421b79c8da16dd6dccb2232c1da6096590e525", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22421b79c8da16dd6dccb2232c1da6096590e525", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22421b79c8da16dd6dccb2232c1da6096590e525/comments", "author": null, "committer": null, "parents": [{"sha": "95e59f1ada8f85e0aff9bff2748e5c8a763daae3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95e59f1ada8f85e0aff9bff2748e5c8a763daae3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95e59f1ada8f85e0aff9bff2748e5c8a763daae3"}], "stats": {"total": 250, "additions": 188, "deletions": 62}, "files": [{"sha": "82b3453b72c42a58aee75517f3c8ddc22576cbdd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22421b79c8da16dd6dccb2232c1da6096590e525/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22421b79c8da16dd6dccb2232c1da6096590e525/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=22421b79c8da16dd6dccb2232c1da6096590e525", "patch": "@@ -1,3 +1,21 @@\n+2004-03-23  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* alias.c (get_alias_set): Add support for TYPE_REF_CAN_ALIAS_ALL.\n+\t* c-common.c (handle_mode_attribute): Add extra arg to\n+\tbuild_pointer_type_for_mode and build_reference_type_for_mode.\n+\t* c-typeck.c (build_c_cast): Only look at TREE_CONSTANT_OVERFLOW\n+\tfor INTEGER_CST.\n+\t* tree.c (build_pointer_type_for_mode): Add arg CAN_ALIAS_ALL.\n+\tChain pointers via TYPE_NEXT_PTR_TO.\n+\t(build_reference_type_for_mode): Similarly.\n+\t(build_type_no_quals): Add extra arg to build_pointer_type_for_mode\n+\tand build_reference_type_for_mode.\n+\t(tree_check4_failed): New function.\n+\t* tree.h (TREE_CHECK4, PTR_OR_REF_CHECK): New macros.\n+\t(TYPE_REF_CAN_ALIAS_ALL, TYPE_NEXT_PTR_TO, TYPE_NEXT_REF_TO): Likewise.\n+\t(TREE_NO_UNSUED_WARNING, TREE_VIA_VIRTUAL, TREE_CONSTANT_OVERFLOW):\n+\tAdd check.\n+\n 2004-03-23  Roger Sayle  <roger@eyesopen.com>\n \n \t* fold-const.c (tree_expr_nonnegative_p): A&B is nonnegative when"}, {"sha": "edb3e7b0a489c0d0697d361b1cb9b3220dba1cf5", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22421b79c8da16dd6dccb2232c1da6096590e525/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22421b79c8da16dd6dccb2232c1da6096590e525/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=22421b79c8da16dd6dccb2232c1da6096590e525", "patch": "@@ -1,3 +1,9 @@\n+2004-03-23  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* decl.c (gnat_to_gnu_entity, case E_Access_Type): Pass value\n+\tof No_Strict_Aliasing to build_pointer_type_for_mode.\n+\t* utils.c (update_pointer_to): Walk pointer and ref chains.\n+\n 2004-03-22  Cyrille Comar  <comar@act-europe.fr>\n \n \t* ali.ads: Fix Comment about Dynamic_Elab."}, {"sha": "bb79af73be46f5a5a8700235f3634b85925a748c", "filename": "gcc/ada/decl.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22421b79c8da16dd6dccb2232c1da6096590e525/gcc%2Fada%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22421b79c8da16dd6dccb2232c1da6096590e525/gcc%2Fada%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdecl.c?ref=22421b79c8da16dd6dccb2232c1da6096590e525", "patch": "@@ -2929,8 +2929,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  }\n \telse if (gnat_desig_type == gnat_entity)\n \t  {\n-\t    gnu_type = build_pointer_type_for_mode (make_node (VOID_TYPE),\n-\t\t\t\t\t\t    p_mode);\n+\t    gnu_type\n+\t      = build_pointer_type_for_mode (make_node (VOID_TYPE),\n+\t\t\t\t\t     p_mode,\n+\t\t\t\t\t     No_Strict_Aliasing (gnat_entity));\n \t    TREE_TYPE (gnu_type) = TYPE_POINTER_TO (gnu_type) = gnu_type;\n \t  }\n \telse\n@@ -2982,7 +2984,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t  }\n \t      }\n \n-\t    gnu_type = build_pointer_type_for_mode (gnu_desig_type, p_mode);\n+\t    gnu_type\n+\t      = build_pointer_type_for_mode (gnu_desig_type, p_mode,\n+\t\t\t\t\t     No_Strict_Aliasing (gnat_entity));\n \t  }\n \n \t/* If we are not defining this object and we made a dummy pointer,"}, {"sha": "1c012fe9f3bd80c6ae2628f9978a094cf1e381d2", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22421b79c8da16dd6dccb2232c1da6096590e525/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22421b79c8da16dd6dccb2232c1da6096590e525/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=22421b79c8da16dd6dccb2232c1da6096590e525", "patch": "@@ -2665,24 +2665,30 @@ update_pointer_to (tree old_type, tree new_type)\n   /* Otherwise, first handle the simple case.  */\n   if (TREE_CODE (new_type) != UNCONSTRAINED_ARRAY_TYPE)\n     {\n-      if (ptr != 0)\n-\tTREE_TYPE (ptr) = new_type;\n       TYPE_POINTER_TO (new_type) = ptr;\n-\n-      if (ref != 0)\n-\tTREE_TYPE (ref) = new_type;\n       TYPE_REFERENCE_TO (new_type) = ref;\n \n-      if (ptr != 0 && TYPE_NAME (ptr) != 0\n-\t  && TREE_CODE (TYPE_NAME (ptr)) == TYPE_DECL\n-\t  && TREE_CODE (new_type) != ENUMERAL_TYPE)\n-\trest_of_decl_compilation (TYPE_NAME (ptr), NULL,\n-\t\t\t\t  global_bindings_p (), 0);\n-      if (ref != 0 && TYPE_NAME (ref) != 0\n-\t  && TREE_CODE (TYPE_NAME (ref)) == TYPE_DECL\n-\t  && TREE_CODE (new_type) != ENUMERAL_TYPE)\n-\trest_of_decl_compilation (TYPE_NAME (ref), NULL,\n-\t\t\t\t  global_bindings_p (), 0);\n+      for (; ptr; ptr = TYPE_NEXT_PTR_TO (ptr))\n+\t{\n+\t  TREE_TYPE (ptr) = new_type;\n+\n+\t  if (TYPE_NAME (ptr) != 0\n+\t      && TREE_CODE (TYPE_NAME (ptr)) == TYPE_DECL\n+\t      && TREE_CODE (new_type) != ENUMERAL_TYPE)\n+\t    rest_of_decl_compilation (TYPE_NAME (ptr), NULL,\n+\t\t\t\t      global_bindings_p (), 0);\n+\t}\n+\n+      for (; ref; ref = TYPE_NEXT_PTR_TO (ref))\n+\t{\n+\t  TREE_TYPE (ref) = new_type;\n+\n+\t  if (TYPE_NAME (ref) != 0\n+\t      && TREE_CODE (TYPE_NAME (ref)) == TYPE_DECL\n+\t      && TREE_CODE (new_type) != ENUMERAL_TYPE)\n+\t    rest_of_decl_compilation (TYPE_NAME (ref), NULL,\n+\t\t\t\t      global_bindings_p (), 0);\n+\t}\n     }\n \n   /* Now deal with the unconstrained array case. In this case the \"pointer\""}, {"sha": "22e1e70ade4f152b3c015efbd812e2d769d58b2a", "filename": "gcc/alias.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22421b79c8da16dd6dccb2232c1da6096590e525/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22421b79c8da16dd6dccb2232c1da6096590e525/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=22421b79c8da16dd6dccb2232c1da6096590e525", "patch": "@@ -533,8 +533,11 @@ get_alias_set (tree t)\n \t    }\n \n \t  /* If we have an INDIRECT_REF via a void pointer, we don't\n-\t     know anything about what that might alias.  */\n-\t  else if (TREE_CODE (TREE_TYPE (inner)) == VOID_TYPE)\n+\t     know anything about what that might alias.  Likewise if the\n+\t     pointer is marked that way.  */\n+\t  else if (TREE_CODE (TREE_TYPE (inner)) == VOID_TYPE\n+\t\t   || (TYPE_REF_CAN_ALIAS_ALL\n+\t\t       (TREE_TYPE (TREE_OPERAND (inner, 0)))))\n \t    return 0;\n \t}\n "}, {"sha": "c7b73ccd69a26f7a93e0f49fe748c8b009f57437", "filename": "gcc/c-common.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22421b79c8da16dd6dccb2232c1da6096590e525/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22421b79c8da16dd6dccb2232c1da6096590e525/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=22421b79c8da16dd6dccb2232c1da6096590e525", "patch": "@@ -4629,13 +4629,13 @@ handle_mode_attribute (tree *node, tree name, tree args ATTRIBUTE_UNUSED,\n \t  if (TREE_CODE (type) == POINTER_TYPE)\n \t    {\n \t      ptr_type = build_pointer_type_for_mode (TREE_TYPE (type),\n-\t\t\t\t\t\t      mode);\n+\t\t\t\t\t\t      mode, false);\n \t      *node = ptr_type;\n \t    }\n \t  else if (TREE_CODE (type) == REFERENCE_TYPE)\n \t    {\n \t      ptr_type = build_reference_type_for_mode (TREE_TYPE (type),\n-\t\t\t\t\t\t\tmode);\n+\t\t\t\t\t\t\tmode, false);\n \t      *node = ptr_type;\n \t    }\n \t  else"}, {"sha": "189ec0f580d8902e8d93fb234fe892caf92a1a5a", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22421b79c8da16dd6dccb2232c1da6096590e525/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22421b79c8da16dd6dccb2232c1da6096590e525/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=22421b79c8da16dd6dccb2232c1da6096590e525", "patch": "@@ -3074,7 +3074,9 @@ build_c_cast (tree type, tree expr)\n       if (TREE_CODE (value) == INTEGER_CST)\n \t{\n \t  TREE_OVERFLOW (value) = TREE_OVERFLOW (ovalue);\n-\t  TREE_CONSTANT_OVERFLOW (value) = TREE_CONSTANT_OVERFLOW (ovalue);\n+\n+\t  if (TREE_CODE_CLASS (TREE_CODE (ovalue)) == 'c')\n+\t    TREE_CONSTANT_OVERFLOW (value) = TREE_CONSTANT_OVERFLOW (ovalue);\n \t}\n     }\n "}, {"sha": "0f900f53f84282e02b0bbcdacacce1e61ba9c3a0", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22421b79c8da16dd6dccb2232c1da6096590e525/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22421b79c8da16dd6dccb2232c1da6096590e525/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=22421b79c8da16dd6dccb2232c1da6096590e525", "patch": "@@ -1,3 +1,8 @@\n+2004-03-23  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* typeck.c (build_c_cast): Only look at TREE_CONSTANT_OVERFLOW\n+\tfor INTEGER_CST.\n+\n 2004-03-22  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n \n \t* cxx-pretty-print.c (pp_cxx_parameter_declaration_clause): Declare."}, {"sha": "edd86ea99262a198ce929653c57257329b4d7ffb", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22421b79c8da16dd6dccb2232c1da6096590e525/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22421b79c8da16dd6dccb2232c1da6096590e525/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=22421b79c8da16dd6dccb2232c1da6096590e525", "patch": "@@ -4919,7 +4919,9 @@ build_c_cast (tree type, tree expr)\n       if (TREE_CODE (value) == INTEGER_CST)\n \t{\n \t  TREE_OVERFLOW (value) = TREE_OVERFLOW (ovalue);\n-\t  TREE_CONSTANT_OVERFLOW (value) = TREE_CONSTANT_OVERFLOW (ovalue);\n+\n+\t  if (TREE_CODE_CLASS (TREE_CODE (ovalue)) == 'c')\n+\t    TREE_CONSTANT_OVERFLOW (value) = TREE_CONSTANT_OVERFLOW (ovalue);\n \t}\n     }\n "}, {"sha": "bca58f04c0156929750b48e43527ebe92573e147", "filename": "gcc/tree.c", "status": "modified", "additions": 69, "deletions": 27, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22421b79c8da16dd6dccb2232c1da6096590e525/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22421b79c8da16dd6dccb2232c1da6096590e525/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=22421b79c8da16dd6dccb2232c1da6096590e525", "patch": "@@ -3878,29 +3878,42 @@ iterative_hash_expr (tree t, hashval_t val)\n    (RECORD_TYPE, UNION_TYPE and ENUMERAL_TYPE nodes are\n    constructed by language-dependent code, not here.)  */\n \n-/* Construct, lay out and return the type of pointers to TO_TYPE\n-   with mode MODE. If such a type has already been constructed,\n-   reuse it.  */\n+/* Construct, lay out and return the type of pointers to TO_TYPE with\n+   mode MODE.  If CAN_ALIAS_ALL is TRUE, indicate this type can\n+   reference all of memory. If such a type has already been\n+   constructed, reuse it.  */\n \n tree\n-build_pointer_type_for_mode (tree to_type, enum machine_mode mode)\n+build_pointer_type_for_mode (tree to_type, enum machine_mode mode,\n+\t\t\t     bool can_alias_all)\n {\n-  tree t = TYPE_POINTER_TO (to_type);\n+  tree t;\n+\n+  /* In some cases, languages will have things that aren't a POINTER_TYPE\n+     (such as a RECORD_TYPE for fat pointers in Ada) as TYPE_POINTER_TO.\n+     In that case, return that type without regard to the rest of our\n+     operands.\n+\n+     ??? This is a kludge, but consistent with the way this function has\n+     always operated and there doesn't seem to be a good way to avoid this\n+     at the moment.  */\n+  if (TYPE_POINTER_TO (to_type) != 0\n+      && TREE_CODE (TYPE_POINTER_TO (to_type)) != POINTER_TYPE)\n+    return TYPE_POINTER_TO (to_type);\n \n   /* First, if we already have a type for pointers to TO_TYPE and it's\n      the proper mode, use it.  */\n-  if (t != 0 && mode == ptr_mode)\n-    return t;\n+  for (t = TYPE_POINTER_TO (to_type); t; t = TYPE_NEXT_PTR_TO (t))\n+    if (TYPE_MODE (t) == mode && TYPE_REF_CAN_ALIAS_ALL (t) == can_alias_all)\n+      return t;\n \n   t = make_node (POINTER_TYPE);\n \n   TREE_TYPE (t) = to_type;\n   TYPE_MODE (t) = mode;\n-\n-  /* We can only record one type as \"the\" pointer to TO_TYPE.  We choose to\n-     record the pointer whose mode is ptr_mode.  */\n-  if (mode == ptr_mode)\n-    TYPE_POINTER_TO (to_type) = t;\n+  TYPE_REF_CAN_ALIAS_ALL (t) = can_alias_all;\n+  TYPE_NEXT_PTR_TO (t) = TYPE_POINTER_TO (to_type);\n+  TYPE_POINTER_TO (to_type) = t;\n \n   /* Lay out the type.  This function has many callers that are concerned\n      with expression-construction, and this simplifies them all.  */\n@@ -3914,29 +3927,41 @@ build_pointer_type_for_mode (tree to_type, enum machine_mode mode)\n tree\n build_pointer_type (tree to_type)\n {\n-  return build_pointer_type_for_mode (to_type, ptr_mode);\n+  return build_pointer_type_for_mode (to_type, ptr_mode, false);\n }\n \n-/* Construct, lay out and return the type of references to TO_TYPE\n-   with mode MODE. If such a type has already been constructed,\n-   reuse it.  */\n+/* Same as build_pointer_type_for_mode, but for REFERENCE_TYPE.  */\n \n tree\n-build_reference_type_for_mode (tree to_type, enum machine_mode mode)\n+build_reference_type_for_mode (tree to_type, enum machine_mode mode,\n+\t\t\t       bool can_alias_all)\n {\n-  tree t = TYPE_REFERENCE_TO (to_type);\n+  tree t;\n \n-  /* First, if we already have a type for pointers to TO_TYPE, use it.  */\n-  if (t != 0 && mode == ptr_mode)\n-    return t;\n+  /* In some cases, languages will have things that aren't a REFERENCE_TYPE\n+     (such as a RECORD_TYPE for fat pointers in Ada) as TYPE_REFERENCE_TO.\n+     In that case, return that type without regard to the rest of our\n+     operands.\n+\n+     ??? This is a kludge, but consistent with the way this function has\n+     always operated and there doesn't seem to be a good way to avoid this\n+     at the moment.  */\n+  if (TYPE_REFERENCE_TO (to_type) != 0\n+      && TREE_CODE (TYPE_REFERENCE_TO (to_type)) != REFERENCE_TYPE)\n+    return TYPE_REFERENCE_TO (to_type);\n+\n+  /* First, if we already have a type for pointers to TO_TYPE and it's\n+     the proper mode, use it.  */\n+  for (t = TYPE_REFERENCE_TO (to_type); t; t = TYPE_NEXT_REF_TO (t))\n+    if (TYPE_MODE (t) == mode && TYPE_REF_CAN_ALIAS_ALL (t) == can_alias_all)\n+      return t;\n \n   t = make_node (REFERENCE_TYPE);\n \n   TREE_TYPE (t) = to_type;\n   TYPE_MODE (t) = mode;\n-\n-  /* Record this type as the pointer to TO_TYPE.  */\n-  if (mode == ptr_mode)\n+  TYPE_REF_CAN_ALIAS_ALL (t) = can_alias_all;\n+  TYPE_NEXT_REF_TO (t) = TYPE_REFERENCE_TO (to_type);\n   TYPE_REFERENCE_TO (to_type) = t;\n \n   layout_type (t);\n@@ -3951,7 +3976,7 @@ build_reference_type_for_mode (tree to_type, enum machine_mode mode)\n tree\n build_reference_type (tree to_type)\n {\n-  return build_reference_type_for_mode (to_type, ptr_mode);\n+  return build_reference_type_for_mode (to_type, ptr_mode, false);\n }\n \n /* Build a type that is compatible with t but has no cv quals anywhere\n@@ -3966,11 +3991,13 @@ build_type_no_quals (tree t)\n     {\n     case POINTER_TYPE:\n       return build_pointer_type_for_mode (build_type_no_quals (TREE_TYPE (t)),\n-\t\t\t\t\t  TYPE_MODE (t));\n+\t\t\t\t\t  TYPE_MODE (t),\n+\t\t\t\t\t  TYPE_REF_CAN_ALIAS_ALL (t));\n     case REFERENCE_TYPE:\n       return\n \tbuild_reference_type_for_mode (build_type_no_quals (TREE_TYPE (t)),\n-\t\t\t\t       TYPE_MODE (t));\n+\t\t\t\t       TYPE_MODE (t),\n+\t\t\t\t       TYPE_REF_CAN_ALIAS_ALL (t));\n     default:\n       return TYPE_MAIN_VARIANT (t);\n     }\n@@ -5022,6 +5049,21 @@ tree_check3_failed (const tree node, enum tree_code code1,\n \t\t  function, trim_filename (file), line);\n }\n \n+/* ... and for four different codes.  */\n+\n+void\n+tree_check4_failed (const tree node, enum tree_code code1,\n+\t\t    enum tree_code code2, enum tree_code code3,\n+\t\t    enum tree_code code4, const char *file, int line,\n+\t\t    const char *function)\n+{\n+  internal_error\n+    (\"tree check: expected %s, %s, %s or %s; have %s in %s, at %s:%d\",\n+     tree_code_name[code1], tree_code_name[code2], tree_code_name[code3],\n+     tree_code_name[code4], tree_code_name[TREE_CODE (node)], function,\n+     trim_filename (file), line);\n+}\n+\n /* ... and for five different codes.  */\n \n void"}, {"sha": "6d0813f621efa08646905b8db8c910e6d2e46066", "filename": "gcc/tree.h", "status": "modified", "additions": 49, "deletions": 11, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22421b79c8da16dd6dccb2232c1da6096590e525/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22421b79c8da16dd6dccb2232c1da6096590e525/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=22421b79c8da16dd6dccb2232c1da6096590e525", "patch": "@@ -197,7 +197,8 @@ struct tree_common GTY(())\n        TREE_STATIC in\n            VAR_DECL, FUNCTION_DECL, CONSTRUCTOR, ADDR_EXPR\n        TREE_NO_UNUSED_WARNING in\n-           CONVERT_EXPR, NOP_EXPR, COMPOUND_EXPR\n+           CONVERT_EXPR, NOP_EXPR, COMPOUND_EXPR, NON_LVALUE_EXPR\n+\t   ??? plus other expressions, apparently (e.g. MODIFY_EXPR).\n        TREE_VIA_VIRTUAL in\n            TREE_LIST or TREE_VEC\n        TREE_CONSTANT_OVERFLOW in\n@@ -207,11 +208,14 @@ struct tree_common GTY(())\n        CLEANUP_EH_ONLY in\n            TARGET_EXPR, WITH_CLEANUP_EXPR, CLEANUP_STMT,\n \t   TREE_LIST elements of a block's cleanup list.\n+       TYPE_REF_CAN_ALIAS_ALL in\n+           POINTER_TYPE, REFERENCE_TYPE\n \n    public_flag:\n \n        TREE_OVERFLOW in\n            INTEGER_CST, REAL_CST, COMPLEX_CST, VECTOR_CST\n+\t   ??? and other expressions?\n        TREE_PUBLIC in\n            VAR_DECL or FUNCTION_DECL or IDENTIFIER_NODE\n        EXPR_WFL_EMIT_LINE_NOTE in\n@@ -324,6 +328,16 @@ struct tree_common GTY(())\n \t\t\t  __LINE__, __FUNCTION__);\t\t\t\\\n     __t; })\n \n+#define TREE_CHECK4(T, CODE1, CODE2, CODE3, CODE4) __extension__\t\\\n+({  const tree __t = (T);\t\t\t\t\t\t\\\n+    if (TREE_CODE (__t) != (CODE1)\t\t\t\t\t\\\n+\t&& TREE_CODE (__t) != (CODE2)\t\t\t\t\t\\\n+\t&& TREE_CODE (__t) != (CODE3)\t\t\t\t\t\\\n+\t&& TREE_CODE (__t) != (CODE4))\t\t\t\t\t\\\n+      tree_check4_failed (__t, (CODE1), (CODE2), (CODE3), (CODE4),\t\\\n+\t\t\t   __FILE__, __LINE__, __FUNCTION__);\t\t\\\n+    __t; })\n+\n #define TREE_CHECK5(T, CODE1, CODE2, CODE3, CODE4, CODE5) __extension__\t\\\n ({  const tree __t = (T);\t\t\t\t\t\t\\\n     if (TREE_CODE (__t) != (CODE1)\t\t\t\t\t\\\n@@ -402,6 +416,10 @@ extern void tree_check3_failed (const tree, enum tree_code, enum tree_code,\n \t\t\t\tenum tree_code, const char *, int,\n \t\t\t\tconst char *)\n     ATTRIBUTE_NORETURN;\n+extern void tree_check4_failed (const tree, enum tree_code, enum tree_code,\n+\t\t\t\tenum tree_code, enum tree_code,\n+\t\t\t\tconst char *, int, const char *)\n+    ATTRIBUTE_NORETURN;\n extern void tree_check5_failed (const tree, enum tree_code, enum tree_code,\n \t\t\t\tenum tree_code, enum tree_code, enum tree_code,\n \t\t\t\tconst char *, int, const char *)\n@@ -422,6 +440,7 @@ extern void tree_operand_check_failed (int, enum tree_code,\n #define TREE_CHECK(T, CODE)\t\t\t(T)\n #define TREE_CHECK2(T, CODE1, CODE2)\t\t(T)\n #define TREE_CHECK3(T, CODE1, CODE2, CODE3)\t(T)\n+#define TREE_CHECK4(T, CODE1, CODE2, CODE3, CODE4) (T)\n #define TREE_CHECK5(T, CODE1, CODE2, CODE3, CODE4, CODE5) (T)\n #define TREE_CLASS_CHECK(T, CODE)\t\t(T)\n #define EXPR_CHECK(T)\t\t\t\t(T)\n@@ -439,6 +458,7 @@ extern void tree_operand_check_failed (int, enum tree_code,\n #define CST_CHECK(T)\t\tTREE_CLASS_CHECK (T, 'c')\n #define STMT_CHECK(T)\t\tTREE_CLASS_CHECK (T, 's')\n #define FUNC_OR_METHOD_CHECK(T)\tTREE_CHECK2 (T, FUNCTION_TYPE, METHOD_TYPE)\n+#define PTR_OR_REF_CHECK(T)\tTREE_CHECK2 (T, POINTER_TYPE, REFERENCE_TYPE)\n \n #define SET_ARRAY_OR_VECTOR_CHECK(T) \\\n   TREE_CHECK3 (T, ARRAY_TYPE, SET_TYPE, VECTOR_TYPE)\n@@ -597,37 +617,53 @@ extern void tree_operand_check_failed (int, enum tree_code,\n \n /* In a VAR_DECL, nonzero means allocate static storage.\n    In a FUNCTION_DECL, nonzero if function has been defined.\n-   In a CONSTRUCTOR, nonzero means allocate static storage.  */\n+   In a CONSTRUCTOR, nonzero means allocate static storage.\n+\n+   ??? This is also used in lots of other nodes in unclear ways which\n+   should be cleaned up some day.  */\n #define TREE_STATIC(NODE) ((NODE)->common.static_flag)\n \n /* In a TARGET_EXPR, WITH_CLEANUP_EXPR, CLEANUP_STMT, or element of a\n    block's cleanup list, means that the pertinent cleanup should only be\n    executed if an exception is thrown, not on normal exit of its scope.  */\n #define CLEANUP_EH_ONLY(NODE) ((NODE)->common.static_flag)\n \n-/* In a CONVERT_EXPR, NOP_EXPR or COMPOUND_EXPR, this means the node was\n-   made implicitly and should not lead to an \"unused value\" warning.  */\n-#define TREE_NO_UNUSED_WARNING(NODE) ((NODE)->common.static_flag)\n+/* In a CONVERT_EXPR, NOP_EXPR, NON_LVALUE_EXPR or COMPOUND_EXPR, this means\n+   the node was made implicitly and should not lead to an \"unused value\"\n+   warning. \n+\n+   ??? Apparently this is also used on other expression types (such as\n+   MODIFY_EXPR.  This needs to be cleaned up sometime.  */\n+#define TREE_NO_UNUSED_WARNING(NODE) (EXPR_CHECK (NODE)->common.static_flag)\n \n /* Nonzero for a TREE_LIST or TREE_VEC node means that the derivation\n    chain is via a `virtual' declaration.  */\n-#define TREE_VIA_VIRTUAL(NODE) ((NODE)->common.static_flag)\n+#define TREE_VIA_VIRTUAL(NODE) \\\n+  (TREE_CHECK2 (NODE, TREE_LIST, TREE_VEC)->common.static_flag)\n \n /* In an INTEGER_CST, REAL_CST, COMPLEX_CST, or VECTOR_CST this means\n    there was an overflow in folding.  This is distinct from\n    TREE_OVERFLOW because ANSI C requires a diagnostic when overflows\n    occur in constant expressions.  */\n-#define TREE_CONSTANT_OVERFLOW(NODE) ((NODE)->common.static_flag)\n+#define TREE_CONSTANT_OVERFLOW(NODE) (CST_CHECK (NODE)->common.static_flag)\n \n /* In an IDENTIFIER_NODE, this means that assemble_name was called with\n    this string as an argument.  */\n #define TREE_SYMBOL_REFERENCED(NODE) \\\n   (IDENTIFIER_NODE_CHECK (NODE)->common.static_flag)\n \n+/* Nonzero in a pointer or reference type means the data pointed to\n+   by this type can alias anything.  */\n+#define TYPE_REF_CAN_ALIAS_ALL(NODE) \\\n+  (PTR_OR_REF_CHECK (NODE)->common.static_flag)\n+\n /* In an INTEGER_CST, REAL_CST, COMPLEX_CST, or VECTOR_CST, this means\n    there was an overflow in folding, and no warning has been issued\n-   for this subexpression.  TREE_OVERFLOW implies\n-   TREE_CONSTANT_OVERFLOW, but not vice versa.  */\n+   for this subexpression.  TREE_OVERFLOW implies TREE_CONSTANT_OVERFLOW,\n+   but not vice versa. \n+\n+   ??? Apparently, lots of code assumes this is defined in all\n+   expressions.  */\n #define TREE_OVERFLOW(NODE) ((NODE)->common.public_flag)\n \n /* In a VAR_DECL or FUNCTION_DECL,\n@@ -1021,6 +1057,8 @@ struct tree_block GTY(())\n #define TYPE_OFFSET_BASETYPE(NODE) (OFFSET_TYPE_CHECK (NODE)->type.maxval)\n #define TYPE_POINTER_TO(NODE) (TYPE_CHECK (NODE)->type.pointer_to)\n #define TYPE_REFERENCE_TO(NODE) (TYPE_CHECK (NODE)->type.reference_to)\n+#define TYPE_NEXT_PTR_TO(NODE) (POINTER_TYPE_CHECK (NODE)->type.minval)\n+#define TYPE_NEXT_REF_TO(NODE) (REFERENCE_TYPE_CHECK (NODE)->type.minval)\n #define TYPE_MIN_VALUE(NODE) (NUMERICAL_TYPE_CHECK (NODE)->type.minval)\n #define TYPE_MAX_VALUE(NODE) (NUMERICAL_TYPE_CHECK (NODE)->type.maxval)\n #define TYPE_PRECISION(NODE) (TYPE_CHECK (NODE)->type.precision)\n@@ -2190,9 +2228,9 @@ extern tree make_unsigned_type (int);\n extern void initialize_sizetypes (void);\n extern void set_sizetype (tree);\n extern void fixup_unsigned_type (tree);\n-extern tree build_pointer_type_for_mode (tree, enum machine_mode);\n+extern tree build_pointer_type_for_mode (tree, enum machine_mode, bool);\n extern tree build_pointer_type (tree);\n-extern tree build_reference_type_for_mode (tree, enum machine_mode);\n+extern tree build_reference_type_for_mode (tree, enum machine_mode, bool);\n extern tree build_reference_type (tree);\n extern tree build_vector_type_for_mode (tree, enum machine_mode);\n extern tree build_vector_type (tree innertype, int nunits);"}]}