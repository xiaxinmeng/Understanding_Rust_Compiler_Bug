{"sha": "2016034718e8074a6c222c71fd528846a32cfcd6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjAxNjAzNDcxOGU4MDc0YTZjMjIyYzcxZmQ1Mjg4NDZhMzJjZmNkNg==", "commit": {"author": {"name": "Maxim Kuvyrkov", "email": "maxim@codesourcery.com", "date": "2010-07-27T19:29:48Z"}, "committer": {"name": "Maxim Kuvyrkov", "email": "mkuvyrkov@gcc.gnu.org", "date": "2010-07-27T19:29:48Z"}, "message": "gcse.c (struct expr:max_distance): New field.\n\n\t* gcse.c (struct expr:max_distance): New field.\n\t(doing_code_hoisting_p): New static variable.\n\t(want_to_gcse_p): Change signature.  Allow constrained hoisting of\n\tsimple expressions, don't change behavior for PRE.  Set max_distance.\n\t(insert_expr_in_table): Set new max_distance field.\n\t(hash_scan_set): Update.\n\t(hoist_expr_reaches_here_p): Stop search after max_distance\n\tinstructions.\n\t(find_occr_in_bb): New static function.  Use it in ...\n\t(hoist_code): Calculate sizes of basic block before any changes are\n\tdone.  Pass max_distance to hoist_expr_reaches_here_p.\n\t(one_code_hoisting_pass): Set doing_code_hoisting_p.\n\n\t* params.def (PARAM_GCSE_COST_DISTANCE_RATIO,)\n\t(PARAM_GCSE_UNRESTRICTED_COST): New parameters.\n\t* params.h (GCSE_COST_DISTANCE_RATIO, GCSE_UNRESTRICTED_COST): New\n\tmacros.\n\t* doc/invoke.texi (gcse-cost-distance-ratio, gcse-unrestricted-cost):\n\tDocument.\n\nFrom-SVN: r162589", "tree": {"sha": "5230a8924f60a6f3b8ae64ec9b7f69f6d703a3db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5230a8924f60a6f3b8ae64ec9b7f69f6d703a3db"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2016034718e8074a6c222c71fd528846a32cfcd6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2016034718e8074a6c222c71fd528846a32cfcd6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2016034718e8074a6c222c71fd528846a32cfcd6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2016034718e8074a6c222c71fd528846a32cfcd6/comments", "author": null, "committer": null, "parents": [{"sha": "9b77478248366c7165ea89c8051677ea35333369", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b77478248366c7165ea89c8051677ea35333369", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b77478248366c7165ea89c8051677ea35333369"}], "stats": {"total": 289, "additions": 262, "deletions": 27}, "files": [{"sha": "0861109ab2d2f099866435e1793c5b8b9ba36f3a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2016034718e8074a6c222c71fd528846a32cfcd6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2016034718e8074a6c222c71fd528846a32cfcd6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2016034718e8074a6c222c71fd528846a32cfcd6", "patch": "@@ -1,3 +1,25 @@\n+2010-07-27  Maxim Kuvyrkov  <maxim@codesourcery.com>\n+\n+\t* gcse.c (struct expr:max_distance): New field.\n+\t(doing_code_hoisting_p): New static variable.\n+\t(want_to_gcse_p): Change signature.  Allow constrained hoisting of\n+\tsimple expressions, don't change behavior for PRE.  Set max_distance.\n+\t(insert_expr_in_table): Set new max_distance field.\n+\t(hash_scan_set): Update.\n+\t(hoist_expr_reaches_here_p): Stop search after max_distance\n+\tinstructions.\n+\t(find_occr_in_bb): New static function.  Use it in ...\n+\t(hoist_code): Calculate sizes of basic block before any changes are\n+\tdone.  Pass max_distance to hoist_expr_reaches_here_p.\n+\t(one_code_hoisting_pass): Set doing_code_hoisting_p.\n+\n+\t* params.def (PARAM_GCSE_COST_DISTANCE_RATIO,)\n+\t(PARAM_GCSE_UNRESTRICTED_COST): New parameters.\n+\t* params.h (GCSE_COST_DISTANCE_RATIO, GCSE_UNRESTRICTED_COST): New\n+\tmacros.\n+\t* doc/invoke.texi (gcse-cost-distance-ratio, gcse-unrestricted-cost):\n+\tDocument.\n+\n 2010-07-27  Jeff Law  <law@redhat.com>\n \t    Maxim Kuvyrkov  <maxim@codesourcery.com>\n "}, {"sha": "0db0f5958283d33541e1aa042590ca7291aa95a6", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2016034718e8074a6c222c71fd528846a32cfcd6/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2016034718e8074a6c222c71fd528846a32cfcd6/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=2016034718e8074a6c222c71fd528846a32cfcd6", "patch": "@@ -8243,6 +8243,23 @@ when @option{-ftree-vectorize} is used.  The number of iterations after\n vectorization needs to be greater than the value specified by this option\n to allow vectorization.  The default value is 0.\n \n+@item gcse-cost-distance-ratio\n+Scaling factor in calculation of maximum distance an expression\n+can be moved by GCSE optimizations.  This is currently supported only in\n+code hoisting pass.  The bigger the ratio, the more agressive code hoisting\n+will be with simple expressions, i.e., the expressions which have cost\n+less than @option{gcse-unrestricted-cost}.  Specifying 0 will disable\n+hoisting of simple expressions.  The default value is 10.\n+\n+@item gcse-unrestricted-cost\n+Cost, roughly measured as the cost of a single typical machine\n+instruction, at which GCSE optimizations will not constrain\n+the distance an expression can travel.  This is currently\n+supported only in code hoisting pass.  The lesser the cost,\n+the more aggressive code hoisting will be.  Specifying 0 will\n+allow all expressions to travel unrestricted distances.\n+The default value is 3.\n+\n @item max-unrolled-insns\n The maximum number of instructions that a loop should have if that loop\n is unrolled, and if the loop is unrolled, it determines how many times"}, {"sha": "9b44083fccd57ab9df954aa16cd0554eebbd419d", "filename": "gcc/gcse.c", "status": "modified", "additions": 204, "deletions": 27, "changes": 231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2016034718e8074a6c222c71fd528846a32cfcd6/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2016034718e8074a6c222c71fd528846a32cfcd6/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=2016034718e8074a6c222c71fd528846a32cfcd6", "patch": "@@ -302,6 +302,12 @@ struct expr\n      The value is the newly created pseudo-reg to record a copy of the\n      expression in all the places that reach the redundant copy.  */\n   rtx reaching_reg;\n+  /* Maximum distance in instructions this expression can travel.\n+     We avoid moving simple expressions for more than a few instructions\n+     to keep register pressure under control.\n+     A value of \"0\" removes restrictions on how far the expression can\n+     travel.  */\n+  int max_distance;\n };\n \n /* Occurrence of an expression.\n@@ -425,6 +431,9 @@ static int global_const_prop_count;\n /* Number of global copies propagated.  */\n static int global_copy_prop_count;\n \f\n+/* Doing code hoisting.  */\n+static bool doing_code_hoisting_p = false;\n+\f\n /* For available exprs */\n static sbitmap *ae_kill;\n \f\n@@ -438,12 +447,12 @@ static void hash_scan_insn (rtx, struct hash_table_d *);\n static void hash_scan_set (rtx, rtx, struct hash_table_d *);\n static void hash_scan_clobber (rtx, rtx, struct hash_table_d *);\n static void hash_scan_call (rtx, rtx, struct hash_table_d *);\n-static int want_to_gcse_p (rtx);\n+static int want_to_gcse_p (rtx, int *);\n static bool gcse_constant_p (const_rtx);\n static int oprs_unchanged_p (const_rtx, const_rtx, int);\n static int oprs_anticipatable_p (const_rtx, const_rtx);\n static int oprs_available_p (const_rtx, const_rtx);\n-static void insert_expr_in_table (rtx, enum machine_mode, rtx, int, int,\n+static void insert_expr_in_table (rtx, enum machine_mode, rtx, int, int, int,\n \t\t\t\t  struct hash_table_d *);\n static void insert_set_in_table (rtx, rtx, struct hash_table_d *);\n static unsigned int hash_expr (const_rtx, enum machine_mode, int *, int);\n@@ -502,7 +511,8 @@ static void alloc_code_hoist_mem (int, int);\n static void free_code_hoist_mem (void);\n static void compute_code_hoist_vbeinout (void);\n static void compute_code_hoist_data (void);\n-static int hoist_expr_reaches_here_p (basic_block, int, basic_block, char *);\n+static int hoist_expr_reaches_here_p (basic_block, int, basic_block, char *,\n+\t\t\t\t      int, int *);\n static int hoist_code (void);\n static int one_code_hoisting_pass (void);\n static rtx process_insert_insn (struct expr *);\n@@ -758,7 +768,7 @@ static basic_block current_bb;\n    GCSE.  */\n \n static int\n-want_to_gcse_p (rtx x)\n+want_to_gcse_p (rtx x, int *max_distance_ptr)\n {\n #ifdef STACK_REGS\n   /* On register stack architectures, don't GCSE constants from the\n@@ -768,18 +778,67 @@ want_to_gcse_p (rtx x)\n     x = avoid_constant_pool_reference (x);\n #endif\n \n+  /* GCSE'ing constants:\n+\n+     We do not specifically distinguish between constant and non-constant\n+     expressions in PRE and Hoist.  We use rtx_cost below to limit\n+     the maximum distance simple expressions can travel.\n+\n+     Nevertheless, constants are much easier to GCSE, and, hence,\n+     it is easy to overdo the optimizations.  Usually, excessive PRE and\n+     Hoisting of constant leads to increased register pressure.\n+\n+     RA can deal with this by rematerialing some of the constants.\n+     Therefore, it is important that the back-end generates sets of constants\n+     in a way that allows reload rematerialize them under high register\n+     pressure, i.e., a pseudo register with REG_EQUAL to constant\n+     is set only once.  Failing to do so will result in IRA/reload\n+     spilling such constants under high register pressure instead of\n+     rematerializing them.  */\n+\n   switch (GET_CODE (x))\n     {\n     case REG:\n     case SUBREG:\n+    case CALL:\n+      return 0;\n+\n     case CONST_INT:\n     case CONST_DOUBLE:\n     case CONST_FIXED:\n     case CONST_VECTOR:\n-    case CALL:\n-      return 0;\n+      if (!doing_code_hoisting_p)\n+\t/* Do not PRE constants.  */\n+\treturn 0;\n+\n+      /* FALLTHRU */\n \n     default:\n+      if (doing_code_hoisting_p)\n+\t/* PRE doesn't implement max_distance restriction.  */\n+\t{\n+\t  int cost;\n+\t  int max_distance;\n+\n+\t  gcc_assert (!optimize_function_for_speed_p (cfun)\n+\t\t      && optimize_function_for_size_p (cfun));\n+\t  cost = rtx_cost (x, SET, 0);\n+\n+\t  if (cost < COSTS_N_INSNS (GCSE_UNRESTRICTED_COST))\n+\t    {\n+\t      max_distance = (GCSE_COST_DISTANCE_RATIO * cost) / 10;\n+\t      if (max_distance == 0)\n+\t\treturn 0;\n+\n+\t      gcc_assert (max_distance > 0);\n+\t    }\n+\t  else\n+\t    max_distance = 0;\n+\n+\t  if (max_distance_ptr)\n+\t    *max_distance_ptr = max_distance;\n+\t}\n+\n       return can_assign_to_reg_without_clobbers_p (x);\n     }\n }\n@@ -1093,11 +1152,14 @@ expr_equiv_p (const_rtx x, const_rtx y)\n    It is only used if X is a CONST_INT.\n \n    ANTIC_P is nonzero if X is an anticipatable expression.\n-   AVAIL_P is nonzero if X is an available expression.  */\n+   AVAIL_P is nonzero if X is an available expression.\n+\n+   MAX_DISTANCE is the maximum distance in instructions this expression can\n+   be moved.  */\n \n static void\n insert_expr_in_table (rtx x, enum machine_mode mode, rtx insn, int antic_p,\n-\t\t      int avail_p, struct hash_table_d *table)\n+\t\t      int avail_p, int max_distance, struct hash_table_d *table)\n {\n   int found, do_not_record_p;\n   unsigned int hash;\n@@ -1140,7 +1202,11 @@ insert_expr_in_table (rtx x, enum machine_mode mode, rtx insn, int antic_p,\n       cur_expr->next_same_hash = NULL;\n       cur_expr->antic_occr = NULL;\n       cur_expr->avail_occr = NULL;\n+      gcc_assert (max_distance >= 0);\n+      cur_expr->max_distance = max_distance;\n     }\n+  else\n+    gcc_assert (cur_expr->max_distance == max_distance);\n \n   /* Now record the occurrence(s).  */\n   if (antic_p)\n@@ -1241,6 +1307,8 @@ insert_set_in_table (rtx x, rtx insn, struct hash_table_d *table)\n       cur_expr->next_same_hash = NULL;\n       cur_expr->antic_occr = NULL;\n       cur_expr->avail_occr = NULL;\n+      /* Not used for set_p tables.  */\n+      cur_expr->max_distance = 0;\n     }\n \n   /* Now record the occurrence.  */\n@@ -1310,6 +1378,7 @@ hash_scan_set (rtx pat, rtx insn, struct hash_table_d *table)\n     {\n       unsigned int regno = REGNO (dest);\n       rtx tmp;\n+      int max_distance = 0;\n \n       /* See if a REG_EQUAL note shows this equivalent to a simpler expression.\n \n@@ -1332,7 +1401,7 @@ hash_scan_set (rtx pat, rtx insn, struct hash_table_d *table)\n \t  && !REG_P (src)\n \t  && (table->set_p\n \t      ? gcse_constant_p (XEXP (note, 0))\n-\t      : want_to_gcse_p (XEXP (note, 0))))\n+\t      : want_to_gcse_p (XEXP (note, 0), NULL)))\n \tsrc = XEXP (note, 0), pat = gen_rtx_SET (VOIDmode, dest, src);\n \n       /* Only record sets of pseudo-regs in the hash table.  */\n@@ -1347,7 +1416,7 @@ hash_scan_set (rtx pat, rtx insn, struct hash_table_d *table)\n \t     can't do the same thing at the rtl level.  */\n \t  && !can_throw_internal (insn)\n \t  /* Is SET_SRC something we want to gcse?  */\n-\t  && want_to_gcse_p (src)\n+\t  && want_to_gcse_p (src, &max_distance)\n \t  /* Don't CSE a nop.  */\n \t  && ! set_noop_p (pat)\n \t  /* Don't GCSE if it has attached REG_EQUIV note.\n@@ -1371,7 +1440,8 @@ hash_scan_set (rtx pat, rtx insn, struct hash_table_d *table)\n \t  int avail_p = (oprs_available_p (src, insn)\n \t\t\t && ! JUMP_P (insn));\n \n-\t  insert_expr_in_table (src, GET_MODE (dest), insn, antic_p, avail_p, table);\n+\t  insert_expr_in_table (src, GET_MODE (dest), insn, antic_p, avail_p,\n+\t\t\t\tmax_distance, table);\n \t}\n \n       /* Record sets for constant/copy propagation.  */\n@@ -1408,7 +1478,7 @@ hash_scan_set (rtx pat, rtx insn, struct hash_table_d *table)\n \t      do that easily for EH edges so disable GCSE on these for now.  */\n \t   && !can_throw_internal (insn)\n \t   /* Is SET_DEST something we want to gcse?  */\n-\t   && want_to_gcse_p (dest)\n+\t   && want_to_gcse_p (dest, NULL)\n \t   /* Don't CSE a nop.  */\n \t   && ! set_noop_p (pat)\n \t   /* Don't GCSE if it has attached REG_EQUIV note.\n@@ -1429,7 +1499,7 @@ hash_scan_set (rtx pat, rtx insn, struct hash_table_d *table)\n \t\t\t     && ! JUMP_P (insn);\n \n \t       /* Record the memory expression (DEST) in the hash table.  */\n-\t       insert_expr_in_table (dest, GET_MODE (dest), insn,\n+\t       insert_expr_in_table (dest, GET_MODE (dest), insn, 0,\n \t\t\t\t     antic_p, avail_p, table);\n              }\n       }\n@@ -1516,8 +1586,8 @@ dump_hash_table (FILE *file, const char *name, struct hash_table_d *table)\n     if (flat_table[i] != 0)\n       {\n \texpr = flat_table[i];\n-\tfprintf (file, \"Index %d (hash value %d)\\n  \",\n-\t\t expr->bitmap_index, hash_val[i]);\n+\tfprintf (file, \"Index %d (hash value %d; max distance %d)\\n  \",\n+\t\t expr->bitmap_index, hash_val[i], expr->max_distance);\n \tprint_rtl (file, expr->expr);\n \tfprintf (file, \"\\n\");\n       }\n@@ -4208,6 +4278,8 @@ compute_code_hoist_data (void)\n \n /* Determine if the expression identified by EXPR_INDEX would\n    reach BB unimpared if it was placed at the end of EXPR_BB.\n+   Stop the search if the expression would need to be moved more\n+   than DISTANCE instructions.\n \n    It's unclear exactly what Muchnick meant by \"unimpared\".  It seems\n    to me that the expression must either be computed or transparent in\n@@ -4220,12 +4292,24 @@ compute_code_hoist_data (void)\n    paths.  */\n \n static int\n-hoist_expr_reaches_here_p (basic_block expr_bb, int expr_index, basic_block bb, char *visited)\n+hoist_expr_reaches_here_p (basic_block expr_bb, int expr_index, basic_block bb,\n+\t\t\t   char *visited, int distance, int *bb_size)\n {\n   edge pred;\n   edge_iterator ei;\n   int visited_allocated_locally = 0;\n \n+  /* Terminate the search if distance, for which EXPR is allowed to move,\n+     is exhausted.  */\n+  if (distance > 0)\n+    {\n+      distance -= bb_size[bb->index];\n+\n+      if (distance <= 0)\n+\treturn 0;\n+    }\n+  else\n+    gcc_assert (distance == 0);\n \n   if (visited == NULL)\n     {\n@@ -4254,8 +4338,8 @@ hoist_expr_reaches_here_p (basic_block expr_bb, int expr_index, basic_block bb,\n       else\n \t{\n \t  visited[pred_bb->index] = 1;\n-\t  if (! hoist_expr_reaches_here_p (expr_bb, expr_index,\n-\t\t\t\t\t   pred_bb, visited))\n+\t  if (! hoist_expr_reaches_here_p (expr_bb, expr_index, pred_bb,\n+\t\t\t\t\t   visited, distance, bb_size))\n \t    break;\n \t}\n     }\n@@ -4265,6 +4349,17 @@ hoist_expr_reaches_here_p (basic_block expr_bb, int expr_index, basic_block bb,\n   return (pred == NULL);\n }\n \f\n+/* Find occurence in BB.  */\n+static struct occr *\n+find_occr_in_bb (struct occr *occr, basic_block bb)\n+{\n+  /* Find the right occurrence of this expression.  */\n+  while (occr && BLOCK_FOR_INSN (occr->insn) != bb)\n+    occr = occr->next;\n+\n+  return occr;\n+}\n+\n /* Actually perform code hoisting.  */\n \n static int\n@@ -4275,6 +4370,8 @@ hoist_code (void)\n   unsigned int i,j;\n   struct expr **index_map;\n   struct expr *expr;\n+  int *to_bb_head;\n+  int *bb_size;\n   int changed = 0;\n \n   sbitmap_vector_zero (hoist_exprs, last_basic_block);\n@@ -4287,6 +4384,36 @@ hoist_code (void)\n     for (expr = expr_hash_table.table[i]; expr != NULL; expr = expr->next_same_hash)\n       index_map[expr->bitmap_index] = expr;\n \n+  /* Calculate sizes of basic blocks and note how far\n+     each instruction is from the start of its block.  We then use this\n+     data to restrict distance an expression can travel.  */\n+\n+  to_bb_head = XCNEWVEC (int, get_max_uid ());\n+  bb_size = XCNEWVEC (int, last_basic_block);\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      rtx insn;\n+      rtx bb_end;\n+      int to_head;\n+\n+      insn = BB_HEAD (bb);\n+      bb_end = BB_END (bb);\n+      to_head = 0;\n+\n+      while (insn != bb_end)\n+\t{\n+\t  /* Don't count debug instructions to avoid them affecting\n+\t     decision choices.  */\n+\t  if (NONDEBUG_INSN_P (insn))\n+\t    to_bb_head[INSN_UID (insn)] = to_head++;\n+\n+\t  insn = NEXT_INSN (insn);\n+\t}\n+\n+      bb_size[bb->index] = to_head;\n+    }\n+\n   /* Walk over each basic block looking for potentially hoistable\n      expressions, nothing gets hoisted from the entry block.  */\n   FOR_EACH_BB (bb)\n@@ -4308,6 +4435,10 @@ hoist_code (void)\n \t\t computes the expression.  */\n \t      for (j = 0; VEC_iterate (basic_block, domby, j, dominated); j++)\n \t\t{\n+\t\t  struct expr *expr = index_map[i];\n+\t\t  struct occr *occr = NULL;\n+\t\t  int max_distance;\n+\n \t\t  /* Ignore self dominance.  */\n \t\t  if (bb == dominated)\n \t\t    continue;\n@@ -4317,12 +4448,30 @@ hoist_code (void)\n \t\t  if (!TEST_BIT (antloc[dominated->index], i))\n \t\t    continue;\n \n+\t\t  max_distance = expr->max_distance;\n+\t\t  if (max_distance > 0)\n+\t\t    {\n+\t\t      struct occr *occr;\n+\n+\t\t      occr = find_occr_in_bb (expr->antic_occr, dominated);\n+\t\t      gcc_assert (occr);\n+\n+\t\t      gcc_assert (NONDEBUG_INSN_P (occr->insn));\n+\n+\t\t      /* Adjust MAX_DISTANCE to account for the fact that\n+\t\t\t OCCR won't have to travel all of DOMINATED, but\n+\t\t\t only part of it.  */\n+\t\t      max_distance += (bb_size[dominated->index]\n+\t\t\t\t       - to_bb_head[INSN_UID (occr->insn)]);\n+\t\t    }\n+\n \t\t  /* Note if the expression would reach the dominated block\n \t\t     unimpared if it was placed at the end of BB.\n \n \t\t     Keep track of how many times this expression is hoistable\n \t\t     from a dominated block into BB.  */\n-\t\t  if (hoist_expr_reaches_here_p (bb, i, dominated, NULL))\n+\t\t  if (hoist_expr_reaches_here_p (bb, i, dominated, NULL,\n+\t\t\t\t\t\t max_distance, bb_size))\n \t\t    hoistable++;\n \t\t}\n \n@@ -4365,6 +4514,9 @@ hoist_code (void)\n \t\t computes the expression.  */\n \t      for (j = 0; VEC_iterate (basic_block, domby, j, dominated); j++)\n \t\t{\n+\t\t  struct expr *expr = index_map[i];\n+\t\t  int max_distance;\n+\n \t\t  /* Ignore self dominance.  */\n \t\t  if (bb == dominated)\n \t\t    continue;\n@@ -4375,23 +4527,42 @@ hoist_code (void)\n \t\t  if (!TEST_BIT (antloc[dominated->index], i))\n \t\t    continue;\n \n+\t\t  max_distance = expr->max_distance;\n+\t\t  if (max_distance > 0)\n+\t\t    {\n+\t\t      occr = find_occr_in_bb (expr->antic_occr, dominated);\n+\t\t      gcc_assert (occr);\n+\n+\t\t      gcc_assert (NONDEBUG_INSN_P (occr->insn));\n+\n+\t\t      /* Adjust MAX_DISTANCE to account for the fact that\n+\t\t\t OCCR won't have to travel all of DOMINATED, but\n+\t\t\t only part of it.  */\n+\t\t      max_distance += (bb_size[dominated->index]\n+\t\t\t\t       - to_bb_head[INSN_UID (occr->insn)]);\n+\t\t    }\n+\n \t\t  /* The expression is computed in the dominated block and\n \t\t     it would be safe to compute it at the start of the\n \t\t     dominated block.  Now we have to determine if the\n \t\t     expression would reach the dominated block if it was\n-\t\t     placed at the end of BB.  */\n-\t\t  if (hoist_expr_reaches_here_p (bb, i, dominated, NULL))\n+\t\t     placed at the end of BB.\n+\t\t     Note: the fact that hoist_exprs has i-th bit set means\n+\t\t     that /some/, not necesserilly all, occurences from\n+\t\t     the dominated blocks can be hoisted to BB.  Here we check\n+\t\t     if a specific occurence can be hoisted to BB.  */\n+\t\t  if (hoist_expr_reaches_here_p (bb, i, dominated, NULL,\n+\t\t\t\t\t\t max_distance, bb_size))\n \t\t    {\n-\t\t      struct expr *expr = index_map[i];\n-\t\t      struct occr *occr = expr->antic_occr;\n \t\t      rtx insn;\n \t\t      rtx set;\n \n-\t\t      /* Find the right occurrence of this expression.  */\n-\t\t      while (BLOCK_FOR_INSN (occr->insn) != dominated && occr)\n-\t\t\toccr = occr->next;\n+\t\t      if (!occr)\n+\t\t\t{\n+\t\t\t  occr = find_occr_in_bb (expr->antic_occr, dominated);\n+\t\t\t  gcc_assert (occr);\n+\t\t\t}\n \n-\t\t      gcc_assert (occr);\n \t\t      insn = occr->insn;\n \t\t      set = single_set (insn);\n \t\t      gcc_assert (set);\n@@ -4421,6 +4592,8 @@ hoist_code (void)\n       VEC_free (basic_block, heap, domby);\n     }\n \n+  free (bb_size);\n+  free (to_bb_head);\n   free (index_map);\n \n   return changed;\n@@ -4443,6 +4616,8 @@ one_code_hoisting_pass (void)\n       || is_too_expensive (_(\"GCSE disabled\")))\n     return 0;\n \n+  doing_code_hoisting_p = true;\n+\n   /* We need alias.  */\n   init_alias_analysis ();\n \n@@ -4478,6 +4653,8 @@ one_code_hoisting_pass (void)\n \t       gcse_subst_count, gcse_create_count);\n     }\n \n+  doing_code_hoisting_p = false;\n+\n   return changed;\n }\n \f"}, {"sha": "ada50f67093a0002057f48ee7402c068d4051e83", "filename": "gcc/params.def", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2016034718e8074a6c222c71fd528846a32cfcd6/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2016034718e8074a6c222c71fd528846a32cfcd6/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=2016034718e8074a6c222c71fd528846a32cfcd6", "patch": "@@ -225,6 +225,21 @@ DEFPARAM(PARAM_GCSE_AFTER_RELOAD_CRITICAL_FRACTION,\n \t\"gcse-after-reload-critical-fraction\",\n \t\"The threshold ratio of critical edges execution count that permit performing redundancy elimination after reload\",\n         10, 0, 0)\n+\n+/* GCSE will use GCSE_COST_DISTANCE_RATION as a scaling factor\n+   to calculate maximum distance for which an expression is allowed to move\n+   from its rtx_cost.  */\n+DEFPARAM(PARAM_GCSE_COST_DISTANCE_RATIO,\n+\t \"gcse-cost-distance-ratio\",\n+\t \"Scaling factor in calculation of maximum distance an expression can be moved by GCSE optimizations\",\n+\t 10, 0, 0)\n+/* GCSE won't restrict distance for which an expression with rtx_cost greater\n+   than COSTS_N_INSN(GCSE_UNRESTRICTED_COST) is allowed to move.  */\n+DEFPARAM(PARAM_GCSE_UNRESTRICTED_COST,\n+\t \"gcse-unrestricted-cost\",\n+\t \"Cost at which GCSE optimizations will not constraint the distance an expression can travel\",\n+\t 3, 0, 0)\n+\n /* This parameter limits the number of insns in a loop that will be unrolled,\n    and by how much the loop is unrolled.\n "}, {"sha": "174edc13f427eef92706d87e1c81ddd0debe44a9", "filename": "gcc/params.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2016034718e8074a6c222c71fd528846a32cfcd6/gcc%2Fparams.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2016034718e8074a6c222c71fd528846a32cfcd6/gcc%2Fparams.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.h?ref=2016034718e8074a6c222c71fd528846a32cfcd6", "patch": "@@ -125,6 +125,10 @@ typedef enum compiler_param\n   PARAM_VALUE (PARAM_GCSE_AFTER_RELOAD_PARTIAL_FRACTION)\n #define GCSE_AFTER_RELOAD_CRITICAL_FRACTION \\\n   PARAM_VALUE (PARAM_GCSE_AFTER_RELOAD_CRITICAL_FRACTION)\n+#define GCSE_COST_DISTANCE_RATIO \\\n+  PARAM_VALUE (PARAM_GCSE_COST_DISTANCE_RATIO)\n+#define GCSE_UNRESTRICTED_COST \\\n+  PARAM_VALUE (PARAM_GCSE_UNRESTRICTED_COST)\n #define MAX_UNROLLED_INSNS \\\n   PARAM_VALUE (PARAM_MAX_UNROLLED_INSNS)\n #define MAX_SMS_LOOP_NUMBER \\"}]}