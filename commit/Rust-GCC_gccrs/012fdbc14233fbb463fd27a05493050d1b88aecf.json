{"sha": "012fdbc14233fbb463fd27a05493050d1b88aecf", "node_id": "C_kwDOANBUbNoAKDAxMmZkYmMxNDIzM2ZiYjQ2M2ZkMjdhMDU0OTMwNTBkMWI4OGFlY2Y", "commit": {"author": {"name": "Alexandre Oliva", "email": "oliva@adacore.com", "date": "2022-12-30T16:44:50Z"}, "committer": {"name": "Alexandre Oliva", "email": "oliva@gnu.org", "date": "2022-12-30T16:44:50Z"}, "message": "check hash table insertions\n\nI've noticed a number of potential problems in hash tables, of three\nkinds: insertion of entries that seem empty, dangling insertions, and\nlookups during insertions.\n\nThese problems may all have the effect of replacing a deleted entry\nwith one that seems empty, which may disconnect double-hashing chains\ninvolving that entry, and thus cause entries to go missing.\n\nThis patch detects such problems by recording a pending insertion and\nchecking that it's completed before other potentially-conflicting\noperations.  The additional field is only introduced when checking is\nenabled.\n\n\nfor  gcc/ChnageLog\n\n\t* hash-table.h (check_complete_insertion, check_insert_slot):\n\tNew hash_table methods.\n\t(m_inserting_slot): New hash_table field.\n\t(begin, hash_table ctors, ~hash_table): Check previous insert.\n\t(expand, empty_slow, clear_slot, find_with_hash): Likewise.\n\t(remote_elt_with_hash, traverse_noresize): Likewise.\n\t(gt_pch_nx): Likewise.\n\t(find_slot_with_hash): Likewise.  Record requested insert.", "tree": {"sha": "9bdce03edf34e0a5679d4af059b1e818f3a2521e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9bdce03edf34e0a5679d4af059b1e818f3a2521e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/012fdbc14233fbb463fd27a05493050d1b88aecf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/012fdbc14233fbb463fd27a05493050d1b88aecf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/012fdbc14233fbb463fd27a05493050d1b88aecf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/012fdbc14233fbb463fd27a05493050d1b88aecf/comments", "author": null, "committer": null, "parents": [{"sha": "ebf7dd754a95bf9680bc53331a6b70f0cf83c045", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebf7dd754a95bf9680bc53331a6b70f0cf83c045", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebf7dd754a95bf9680bc53331a6b70f0cf83c045"}], "stats": {"total": 63, "additions": 60, "deletions": 3}, "files": [{"sha": "c09d91f2abbb832455452db83603d2fbdf710fb7", "filename": "gcc/hash-table.h", "status": "modified", "additions": 60, "deletions": 3, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/012fdbc14233fbb463fd27a05493050d1b88aecf/gcc%2Fhash-table.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/012fdbc14233fbb463fd27a05493050d1b88aecf/gcc%2Fhash-table.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash-table.h?ref=012fdbc14233fbb463fd27a05493050d1b88aecf", "patch": "@@ -495,6 +495,7 @@ class hash_table\n     {\n       if (Lazy && m_entries == NULL)\n \treturn iterator ();\n+      check_complete_insertion ();\n       iterator iter (m_entries, m_entries + m_size);\n       iter.slide ();\n       return iter;\n@@ -551,8 +552,39 @@ class hash_table\n     Descriptor::mark_empty (v);\n   }\n \n+public:\n+  void check_complete_insertion () const\n+  {\n+#if CHECKING_P\n+    if (!m_inserting_slot)\n+      return;\n+\n+    gcc_checking_assert (m_inserting_slot >= &m_entries[0]\n+\t\t\t && m_inserting_slot < &m_entries[m_size]);\n+\n+    if (!is_empty (*m_inserting_slot))\n+      m_inserting_slot = NULL;\n+    else\n+      gcc_unreachable ();\n+#endif\n+  }\n+\n+private:\n+  value_type *check_insert_slot (value_type *ret)\n+  {\n+#if CHECKING_P\n+    gcc_checking_assert (is_empty (*ret));\n+    m_inserting_slot = ret;\n+#endif\n+    return ret;\n+  }\n+\n+#if CHECKING_P\n+  mutable value_type *m_inserting_slot;\n+#endif\n+\n   /* Table itself.  */\n-  typename Descriptor::value_type *m_entries;\n+  value_type *m_entries;\n \n   size_t m_size;\n \n@@ -607,6 +639,9 @@ hash_table<Descriptor, Lazy, Allocator>::hash_table (size_t size, bool ggc,\n \t\t\t\t\t\t     ATTRIBUTE_UNUSED,\n \t\t\t\t\t\t     mem_alloc_origin origin\n \t\t\t\t\t\t     MEM_STAT_DECL) :\n+#if CHECKING_P\n+  m_inserting_slot (0),\n+#endif\n   m_n_elements (0), m_n_deleted (0), m_searches (0), m_collisions (0),\n   m_ggc (ggc), m_sanitize_eq_and_hash (sanitize_eq_and_hash)\n #if GATHER_STATISTICS\n@@ -639,13 +674,18 @@ hash_table<Descriptor, Lazy, Allocator>::hash_table (const hash_table &h,\n \t\t\t\t\t\t     ATTRIBUTE_UNUSED,\n \t\t\t\t\t\t     mem_alloc_origin origin\n \t\t\t\t\t\t     MEM_STAT_DECL) :\n+#if CHECKING_P\n+  m_inserting_slot (0),\n+#endif\n   m_n_elements (h.m_n_elements), m_n_deleted (h.m_n_deleted),\n   m_searches (0), m_collisions (0), m_ggc (ggc),\n   m_sanitize_eq_and_hash (sanitize_eq_and_hash)\n #if GATHER_STATISTICS\n   , m_gather_mem_stats (gather_mem_stats)\n #endif\n {\n+  h.check_complete_insertion ();\n+\n   size_t size = h.m_size;\n \n   if (m_gather_mem_stats)\n@@ -675,6 +715,8 @@ template<typename Descriptor, bool Lazy,\n \t template<typename Type> class Allocator>\n hash_table<Descriptor, Lazy, Allocator>::~hash_table ()\n {\n+  check_complete_insertion ();\n+\n   if (!Lazy || m_entries)\n     {\n       for (size_t i = m_size - 1; i < m_size; i--)\n@@ -778,6 +820,8 @@ template<typename Descriptor, bool Lazy,\n void\n hash_table<Descriptor, Lazy, Allocator>::expand ()\n {\n+  check_complete_insertion ();\n+\n   value_type *oentries = m_entries;\n   unsigned int oindex = m_size_prime_index;\n   size_t osize = size ();\n@@ -842,6 +886,8 @@ template<typename Descriptor, bool Lazy,\n void\n hash_table<Descriptor, Lazy, Allocator>::empty_slow ()\n {\n+  check_complete_insertion ();\n+\n   size_t size = m_size;\n   size_t nsize = size;\n   value_type *entries = m_entries;\n@@ -890,6 +936,8 @@ template<typename Descriptor, bool Lazy,\n void\n hash_table<Descriptor, Lazy, Allocator>::clear_slot (value_type *slot)\n {\n+  check_complete_insertion ();\n+\n   gcc_checking_assert (!(slot < m_entries || slot >= m_entries + size ()\n \t\t         || is_empty (*slot) || is_deleted (*slot)));\n \n@@ -916,6 +964,8 @@ ::find_with_hash (const compare_type &comparable, hashval_t hash)\n   if (Lazy && m_entries == NULL)\n     m_entries = alloc_entries (size);\n \n+  check_complete_insertion ();\n+\n #if CHECKING_P\n   if (m_sanitize_eq_and_hash)\n     verify (comparable, hash);\n@@ -965,6 +1015,8 @@ ::find_slot_with_hash (const compare_type &comparable, hashval_t hash,\n     }\n   if (insert == INSERT && m_size * 3 <= m_n_elements * 4)\n     expand ();\n+  else\n+    check_complete_insertion ();\n \n #if CHECKING_P\n   if (m_sanitize_eq_and_hash)\n@@ -1011,11 +1063,11 @@ ::find_slot_with_hash (const compare_type &comparable, hashval_t hash,\n     {\n       m_n_deleted--;\n       mark_empty (*first_deleted_slot);\n-      return first_deleted_slot;\n+      return check_insert_slot (first_deleted_slot);\n     }\n \n   m_n_elements++;\n-  return &m_entries[index];\n+  return check_insert_slot (&m_entries[index]);\n }\n \n /* Verify that all existing elements in th hash table which are\n@@ -1047,6 +1099,8 @@ void\n hash_table<Descriptor, Lazy, Allocator>\n ::remove_elt_with_hash (const compare_type &comparable, hashval_t hash)\n {\n+  check_complete_insertion ();\n+\n   value_type *slot = find_slot_with_hash (comparable, hash, NO_INSERT);\n   if (slot == NULL)\n     return;\n@@ -1073,6 +1127,8 @@ hash_table<Descriptor, Lazy, Allocator>::traverse_noresize (Argument argument)\n   if (Lazy && m_entries == NULL)\n     return;\n \n+  check_complete_insertion ();\n+\n   value_type *slot = m_entries;\n   value_type *limit = slot + size ();\n \n@@ -1189,6 +1245,7 @@ template<typename D>\n static void\n gt_pch_nx (hash_table<D> *h)\n {\n+  h->check_complete_insertion ();\n   bool success\n     = gt_pch_note_object (h->m_entries, h, hashtab_entry_note_pointers<D>);\n   gcc_checking_assert (success);"}]}