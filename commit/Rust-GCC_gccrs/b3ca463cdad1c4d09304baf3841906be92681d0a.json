{"sha": "b3ca463cdad1c4d09304baf3841906be92681d0a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjNjYTQ2M2NkYWQxYzRkMDkzMDRiYWYzODQxOTA2YmU5MjY4MWQwYQ==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1995-04-05T21:16:26Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1995-04-05T21:16:26Z"}, "message": "Re-write fixproto/fix-header/etc to use cpplib.\n\nFrom-SVN: r9316", "tree": {"sha": "444e0bc9b38ad6819d87db5007348f663acf5e60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/444e0bc9b38ad6819d87db5007348f663acf5e60"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b3ca463cdad1c4d09304baf3841906be92681d0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3ca463cdad1c4d09304baf3841906be92681d0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3ca463cdad1c4d09304baf3841906be92681d0a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3ca463cdad1c4d09304baf3841906be92681d0a/comments", "author": null, "committer": null, "parents": [{"sha": "355142da80432e9a21bc56a8f796636967ea5622", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/355142da80432e9a21bc56a8f796636967ea5622", "html_url": "https://github.com/Rust-GCC/gccrs/commit/355142da80432e9a21bc56a8f796636967ea5622"}], "stats": {"total": 844, "additions": 543, "deletions": 301}, "files": [{"sha": "49eb98795eccaff5ab19a8a7c9e6ec7fdd5fb609", "filename": "gcc/Makefile.in", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ca463cdad1c4d09304baf3841906be92681d0a/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ca463cdad1c4d09304baf3841906be92681d0a/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=b3ca463cdad1c4d09304baf3841906be92681d0a", "patch": "@@ -1736,9 +1736,9 @@ deduced.h: $(GCC_PASSES) $(srcdir)/scan-types.sh stmp-int-hdrs\n \t  $(SHELL) $(srcdir)/scan-types.sh \"$(srcdir)\" >tmp-deduced.h\n \tmv tmp-deduced.h deduced.h\n \n-gen-protos: gen-protos.o scan.o $(HOST_LIBDEPS)\n+gen-protos: gen-protos.o scan.o cppalloc.o $(HOST_LIBDEPS)\n \t${HOST_CC} $(HOST_CFLAGS) $(HOST_LDFLAGS) -o gen-protos \\\n-\t  gen-protos.o scan.o $(HOST_LIBS)\n+\t  gen-protos.o scan.o cppalloc.o $(HOST_LIBS)\n \n gen-protos.o: gen-protos.c scan.h hconfig.h\n \t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) $(srcdir)/gen-protos.c\n@@ -1755,9 +1755,9 @@ xsys-protos.h: $(GCC_PASSES) $(srcdir)/sys-protos.h deduced.h gen-protos Makefil\n \tmv xsys-protos.hT xsys-protos.h\n \trm -rf fixtmp.c\n \n-fix-header: fix-header.o scan-decls.o scan.o xsys-protos.h $(HOST_LIBDEPS)\n+fix-header: fix-header.o scan-decls.o scan.o xsys-protos.h $(HOST_LIBDEPS) cpplib.o cpphash.o cppalloc.o cppexp.o cpperror.o version.o\n \t$(HOST_CC) $(HOST_CFLAGS) $(HOST_LDFLAGS) -o fix-header \\\n-\t  fix-header.o scan-decls.o scan.o $(HOST_LIBS)\n+\t  fix-header.o scan-decls.o scan.o cpplib.o cpphash.o cppalloc.o version.o cppexp.o $(HOST_LIBS)\n \n fix-header.o: fix-header.c obstack.h scan.h xsys-protos.h hconfig.h\n \t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) $(srcdir)/fix-header.c\n@@ -1785,9 +1785,8 @@ stmp-fixproto: fixhdr.ready fixproto stmp-headers\n \t-if [ -f include/fixed ] ; then true; \\\n \telse \\\n \t  : This line works around a 'make' bug in BSDI 1.1.; \\\n-\t  CPP=\"$(GCC_FOR_TARGET) -E\"; export CPP; \\\n-\t    FIXPROTO_DEFINES=\"$(FIXPROTO_DEFINES)\"; export FIXPROTO_DEFINES; \\\n-\t    $(SHELL) ${srcdir}/fixproto include include $(SYSTEM_HEADER_DIR); \\\n+\t  FIXPROTO_DEFINES=\"$(FIXPROTO_DEFINES)\"; export FIXPROTO_DEFINES; \\\n+\t  $(SHELL) ${srcdir}/fixproto include include $(SYSTEM_HEADER_DIR); \\\n \t  touch include/fixed; \\\n \tfi\n \ttouch stmp-fixproto"}, {"sha": "4056605b8b7931acbeeaf444c609bc099576699d", "filename": "gcc/fix-header.c", "status": "modified", "additions": 418, "deletions": 79, "changes": 497, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ca463cdad1c4d09304baf3841906be92681d0a/gcc%2Ffix-header.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ca463cdad1c4d09304baf3841906be92681d0a/gcc%2Ffix-header.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffix-header.c?ref=b3ca463cdad1c4d09304baf3841906be92681d0a", "patch": "@@ -1,5 +1,5 @@\n /* fix-header.c - Make C header file suitable for C++.\n-   Copyright (C) 1993, 1994 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 1994, 1995 Free Software Foundation, Inc.\n \n This program is free software; you can redistribute it and/or modify it\n under the terms of the GNU General Public License as published by the\n@@ -59,15 +59,14 @@ Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n    b) it would be nice to allow update in place.\n \n    Usage:\n-\tfix-header FOO.H INFILE.H OUTFILE.H REQUIRED_FUNCS <SCAN-FILE\n+\tfix-header FOO.H INFILE.H OUTFILE.H [OPTIONS]\n    where:\n    * FOO.H is the relative file name of the include file,\n    as it would be #include'd by a C file.  (E.g. stdio.h)\n    * INFILE.H is a full pathname for the input file (e.g. /usr/include/stdio.h)\n    * OUTFILE.H is the full pathname for where to write the output file,\n    if anything needs to be done.  (e.g. ./include/stdio.h)\n-   * SCAN-FILE is the output of the scan-decls program.\n-   * REQUIRED_FUNCS is a list of required function (e.g. fclose for stdio.h).\n+   * OPTIONS are such as you would pass to cpp.\n \n    Written by Per Bothner <bothner@cygnus.com>, July 1993. */\n \n@@ -81,22 +80,44 @@ Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"hconfig.h\"\n #include \"obstack.h\"\n #include \"scan.h\"\n+#include \"cpplib.h\"\n \n-extern sstring buf;\n+#if !__STDC__\n+#define const /* nothing */\n+#endif\n+\n+sstring buf;\n \n int verbose = 0;\n int partial_count = 0;\n-#if 0\n-/* All uses of this are ifdefed out.  This is no longer needed, because\n-   cccp.c implicitly forces the standard include files to be treated as C.\n-   Adding an explicit extern \"C\" is undesireable as it breaks the SunOS 4.x\n-   sun4c/romvec.h file.  */\n+int warnings = 0;\n+\n+/* We no longer need to add extern \"C\", because cpp implicitly\n+   forces the standard include files to be treated as C.  */\n+/*#define ADD_MISSING_EXTERN_C 1 */\n+\n+#if ADD_MISSING_EXTERN_C\n int missing_extern_C_count = 0;\n #endif\n int missing_errno = 0;\n \n #include \"xsys-protos.h\"\n \n+#ifdef FIXPROTO_IGNORE_LIST\n+/* This is a currently unused feature. */\n+\n+/* List of files and directories to ignore.\n+   A directory name (ending in '/') means ignore anything in that\n+   directory.  (It might be more efficient to do directory pruning\n+   earlier in fixproto, but this is simpler and easier to customize.) */\n+\n+static char *files_to_ignore[] = {\n+  \"X11/\",\n+  FIXPROTO_IGNORE_LIST\n+  0\n+};\n+#endif\n+\n char *inf_buffer;\n char *inf_limit;\n char *inf_ptr;\n@@ -106,8 +127,134 @@ char *inf_ptr;\n enum special_file\n {\n   no_special,\n-  errno_special,\n-  sys_stat_special\n+  errno_h,\n+  stdio_h,\n+  sys_stat_h\n+};\n+\n+/* A NAMELIST is a sequence of names, separated by '\\0', and terminated\n+   by an empty name (i.e. by \"\\0\\0\"). */\n+\n+typedef const char* namelist;\n+\n+struct std_include_entry {\n+  const char *name;\n+  namelist required;\n+  namelist extra;\n+  int special;\n+};\n+\n+/* End of namelist NAMES. */\n+\n+namelist\n+namelist_end (names)\n+     namelist names;\n+{\n+  register namelist ptr;\n+  for (ptr = names; ; ptr++)\n+    {\n+      if (*ptr == '\\0')\n+\t{\n+\t  ptr++;\n+\t  if (*ptr == '\\0')\n+\t    return ptr;\n+\t}\n+    }\n+}\n+\n+const char NONE[] = \"\";\n+\n+struct std_include_entry *include_entry;\n+\n+struct std_include_entry std_include_table [] = {\n+  { \"ctype.h\",\n+      \"isalnum\\0isalpha\\0iscntrl\\0isdigit\\0isgraph\\0islower\\0\\\n+isprint\\0ispunct\\0isspace\\0isupper\\0isxdigit\\0tolower\\0toupper\\0\", NONE },\n+\n+  { \"dirent.h\", \"closedir\\0opendir\\0readdir\\0rewinddir\\0\", NONE},\n+\n+  { \"errno.h\", NONE, \"errno\\0\" },\n+\n+  { \"curses.h\", \"box\\0delwin\\0endwin\\0getcurx\\0getcury\\0initscr\\0\\\n+mvcur\\0mvwprintw\\0mvwscanw\\0newwin\\0overlay\\0overwrite\\0\\\n+scroll\\0subwin\\0touchwin\\0waddstr\\0wclear\\0wclrtobot\\0wclrtoeol\\0\\\n+waddch\\0wdelch\\0wdeleteln\\0werase\\0wgetch\\0wgetstr\\0winsch\\0winsertln\\0\\\n+wmove\\0wprintw\\0wrefresh\\0wscanw\\0wstandend\\0wstandout\\0\", NONE },\n+\n+  { \"fcntl.h\", \"creat\\0fcntl\\0open\\0\", NONE },\n+\n+  /* Maybe also \"getgrent fgetgrent setgrent endgrent\" */\n+  { \"grp.h\", \"getgrgid\\0getgrnam\\0\", NONE },\n+\n+/*{ \"limit.h\", ... provided by gcc }, */\n+\n+  { \"locale.h\", \"localeconv\\0setlocale\\0\", NONE },\n+\n+  { \"math.h\", \"acos\\0asin\\0atan\\0atan2\\0ceil\\0cos\\0cosh\\0exp\\0\\\n+fabs\\0floor\\0fmod\\0frexp\\0ldexp\\0log10\\0log\\0modf\\0pow\\0sin\\0sinh\\0sqrt\\0\\\n+tan\\0tanh\\0\", \"HUGE_VAL\\0\" },\n+\n+  { \"pwd.h\", \"getpwnam\\0getpwuid\\0\", NONE },\n+\n+  /* Left out siglongjmp sigsetjmp - these depend on sigjmp_buf. */\n+  { \"setjmp.h\", \"longjmp\\0setjmp\\0\", NONE },\n+\n+  /* Left out signal() - its prototype is too complex for us!\n+     Also left out \"sigaction sigaddset sigdelset sigemptyset\n+     sigfillset sigismember sigpending sigprocmask sigsuspend\"\n+     because these need sigset_t or struct sigaction.\n+     Most systems that provide them will also declare them. */\n+  { \"signal.h\", \"kill\\0raise\\0\", NONE },\n+\n+  { \"stdio.h\", \"clearerr\\0fclose\\0feof\\0ferror\\0fflush\\0fgetc\\0fgetpos\\0\\\n+fgets\\0fopen\\0fprintf\\0fputc\\0fputs\\0fread\\0freopen\\0fscanf\\0fseek\\0\\\n+fsetpos\\0ftell\\0fwrite\\0getc\\0getchar\\0gets\\0pclose\\0perror\\0popen\\0\\\n+printf\\0putc\\0putchar\\0puts\\0remove\\0rename\\0rewind\\0scanf\\0setbuf\\0\\\n+setvbuf\\0sprintf\\0sscanf\\0vprintf\\0vsprintf\\0vfprintf\\0tmpfile\\0\\\n+tmpnam\\0ungetc\\0\", NONE },\n+/* Should perhaps also handle NULL, EOF, ... ? */\n+\n+  /* \"div ldiv\", - ignored because these depend on div_t, ldiv_t\n+     ignore these: \"mblen mbstowcs mbstowc wcstombs wctomb\"\n+     Left out getgroups, because SunOS4 has incompatible BSD and SVR4 versions.\n+     Should perhaps also add NULL */\n+  { \"stdlib.h\", \"abort\\0abs\\0atexit\\0atof\\0atoi\\0atol\\0bsearch\\0calloc\\0\\\n+exit\\0free\\0getenv\\0labs\\0malloc\\0putenv\\0qsort\\0rand\\0realloc\\0\\\n+srand\\0strtod\\0strtol\\0strtoul\\0system\\0\", NONE },\n+\n+  { \"string.h\", \"memchr\\0memcmp\\0memcpy\\0memmove\\0memset\\0\\\n+strcat\\0strchr\\0strcmp\\0strcoll\\0strcpy\\0strcspn\\0strerror\\0\\\n+strlen\\0strncat\\0strncmp\\0strncpy\\0strpbrk\\0strrchr\\0strspn\\0strstr\\0\\\n+strtok\\0strxfrm\\0\", NONE },\n+/* Should perhaps also add NULL and size_t */\n+\n+  { \"sys/stat.h\", \"chmod\\0fstat\\0mkdir\\0mkfifo\\0stat\\0lstat\\0umask\\0\",\n+      \"S_ISDIR\\0S_ISBLK\\0S_ISCHR\\0S_ISFIFO\\0S_ISREG\\0S_ISLNK\\0S_IFDIR\\0\\\n+S_IFBLK\\0S_IFCHR\\0S_IFIFO\\0S_IFREG\\0S_IFLNK\\0\" },\n+\n+  { \"sys/times.h\", \"times\\0\", NONE },\n+  /* \"sys/types.h\" add types (not in old g++-include) */\n+\n+  { \"sys/utsname.h\", \"uname\\0\", NONE },\n+\n+  { \"sys/wait.h\", \"wait\\0waitpid\\0\",\n+      \"WEXITSTATUS\\0WIFEXITED\\0WIFSIGNALED\\0WIFSTOPPED\\0WSTOPSIG\\0\\\n+WTERMSIG\\0WNOHANG\\0WNOTRACED\\0\" },\n+\n+  { \"tar.h\", NONE, NONE },\n+\n+  { \"termios.h\", \"cfgetispeed\\0cfgetospeed\\0cfsetispeed\\0cfsetospeed\\0tcdrain\\0tcflow\\0tcflush\\0tcgetattr\\0tcsendbreak\\0tcsetattr\\0\", NONE },\n+\n+  { \"time.h\", \"asctime\\0clock\\0ctime\\0difftime\\0gmtime\\0localtime\\0mktime\\0strftime\\0time\\0tzset\\0\", NONE },\n+\n+  { \"unistd.h\", \"_exit\\0access\\0alarm\\0chdir\\0chown\\0close\\0ctermid\\0cuserid\\0\\\n+dup\\0dup2\\0execl\\0execle\\0execlp\\0execv\\0execve\\0execvp\\0fork\\0fpathconf\\0\\\n+getcwd\\0getegid\\0geteuid\\0getgid\\0getlogin\\0getopt\\0getpgrp\\0getpid\\0\\\n+getppid\\0getuid\\0isatty\\0link\\0lseek\\0pathconf\\0pause\\0pipe\\0read\\0rmdir\\0\\\n+setgid\\0setpgid\\0setsid\\0setuid\\0sleep\\0sysconf\\0tcgetpgrp\\0tcsetpgrp\\0\\\n+ttyname\\0unlink\\0write\\0\", NONE },\n+\n+  { 0, NONE, NONE }\n };\n \n enum special_file special_file_handling = no_special;\n@@ -146,18 +293,20 @@ struct obstack scan_file_obstack;\n \n /* NOTE:  If you edit this, also edit gen-protos.c !! */\n struct fn_decl *\n-lookup_std_proto (name)\n-     char *name;\n+lookup_std_proto (name, name_length)\n+     const char *name;\n+     int name_length;\n {\n-  int i = hash (name) % HASH_SIZE;\n+  int i = hashf (name, name_length, HASH_SIZE);\n   int i0 = i;\n   for (;;)\n     {\n       struct fn_decl *fn;\n       if (hash_tab[i] == 0)\n \treturn NULL;\n       fn = &std_protos[hash_tab[i]];\n-      if (strcmp (fn->fname, name) == 0)\n+      if (strlen (fn->fname) == name_length\n+\t  && strncmp (fn->fname, name, name_length) == 0)\n \treturn fn;\n       i = (i+1) % HASH_SIZE;\n       if (i == i0)\n@@ -173,14 +322,14 @@ sstring line;\n \n int lbrac_line, rbrac_line;\n \n-char **required_functions;\n-int required_unseen_count;\n+namelist required_functions_list;\n+int required_unseen_count = 0;\n \n void \n write_lbrac ()\n {\n   \n-#if 0\n+#if ADD_MISSING_EXTERN_C\n   if (missing_extern_C_count + required_unseen_count > 0)\n     fprintf (outf, \"#ifdef __cplusplus\\nextern \\\"C\\\" {\\n#endif\\n\");\n #endif\n@@ -207,31 +356,33 @@ struct partial_proto\n \n struct partial_proto *partial_proto_list = NULL;\n \n-struct partial_proto required_dummy_proto;\n+struct partial_proto required_dummy_proto, seen_dummy_proto;\n #define REQUIRED(FN) ((FN)->partial == &required_dummy_proto)\n #define SET_REQUIRED(FN) ((FN)->partial = &required_dummy_proto)\n-#define CLEAR_REQUIRED(FN) ((FN)->partial = 0)\n+#define SET_SEEN(FN) ((FN)->partial = &seen_dummy_proto)\n+#define SEEN(FN) ((FN)->partial == &seen_dummy_proto)\n \n void\n recognized_macro (fname)\n      char *fname;\n {\n   /* The original include file defines fname as a macro. */\n-  struct fn_decl *fn = lookup_std_proto (fname);\n+  struct fn_decl *fn = lookup_std_proto (fname, strlen (fname));\n \n   /* Since fname is a macro, don't require a prototype for it. */\n-  if (fn && REQUIRED (fn))\n+  if (fn)\n     {\n-      CLEAR_REQUIRED (fn);\n-      required_unseen_count--;\n+      if (REQUIRED (fn))\n+\trequired_unseen_count--;\n+      SET_SEEN (fn);\n     }\n \n   switch (special_file_handling)\n     {\n-    case errno_special:\n+    case errno_h:\n       if (strcmp (fname, \"errno\") == 0) missing_errno = 0;\n       break;\n-    case sys_stat_special:\n+    case sys_stat_h:\n       if (fname[0] == 'S' && fname[1] == '_')\n \t{\n \t  if (strcmp (fname, \"S_IFBLK\") == 0) seen_S_IFBLK++;\n@@ -251,14 +402,15 @@ recognized_macro (fname)\n }\n \n void\n-recognized_extern (name, type)\n+recognized_extern (name, name_length, type, type_length)\n      char *name;\n      char *type;\n+     int name_length, type_length;\n {\n   switch (special_file_handling)\n     {\n-    case errno_special:\n-      if (strcmp (name, \"errno\") == 0) missing_errno = 0;\n+    case errno_h:\n+      if (strncmp (name, \"errno\", name_length) == 0) missing_errno = 0;\n       break;\n     }\n }\n@@ -272,33 +424,38 @@ recognized_extern (name, type)\n    'f' for other function declarations. */\n \n void\n-recognized_function (fname, kind, rtype, args, file_seen, line_seen)\n+recognized_function (fname, fname_length,\n+\t\t     kind, rtype, rtype_length,\n+\t\t     have_arg_list, file_seen, line_seen)\n      char *fname;\n+     int fname_length;\n      int kind; /* One of 'f' 'F' or 'I' */\n      char *rtype;\n-     char *args;\n+     int rtype_length;\n+     int have_arg_list;\n      char *file_seen;\n      int line_seen;\n {\n   struct partial_proto *partial;\n   int i;\n   struct fn_decl *fn;\n-#if 0\n+#if ADD_MISSING_EXTERN_C\n   if (kind == 'f')\n     missing_extern_C_count++;\n #endif\n \n-  fn = lookup_std_proto (fname);\n+  fn = lookup_std_proto (fname, fname_length);\n \n   /* Remove the function from the list of required function. */\n-  if (fn && REQUIRED (fn))\n+  if (fn)\n     {\n-      CLEAR_REQUIRED (fn);\n-      required_unseen_count--;\n+      if (REQUIRED (fn))\n+\trequired_unseen_count--;\n+      SET_SEEN (fn);\n     }\n \n   /* If we have a full prototype, we're done. */\n-  if (args[0] != '\\0')\n+  if (have_arg_list)\n     return;\n       \n   if (kind == 'I')  /* don't edit inline function */\n@@ -321,10 +478,11 @@ recognized_function (fname, kind, rtype, args, file_seen, line_seen)\n   partial_count++;\n   partial = (struct partial_proto*)\n     obstack_alloc (&scan_file_obstack, sizeof (struct partial_proto));\n-  partial->fname = obstack_alloc (&scan_file_obstack, strlen (fname) + 1);\n-  strcpy (partial->fname, fname);\n-  partial->rtype = obstack_alloc (&scan_file_obstack, strlen (rtype) + 1);\n-  strcpy (partial->rtype, rtype);\n+  partial->fname = obstack_alloc (&scan_file_obstack, fname_length + 1);\n+  bcopy (fname, partial->fname, fname_length);\n+  partial->fname[fname_length] = 0;\n+  partial->rtype = obstack_alloc (&scan_file_obstack, rtype_length + 1);\n+  sprintf (partial->rtype, \"%.*s\", rtype_length, rtype);\n   partial->line_seen = line_seen;\n   partial->fn = fn;\n   fn->partial = partial;\n@@ -333,20 +491,122 @@ recognized_function (fname, kind, rtype, args, file_seen, line_seen)\n   if (verbose)\n     {\n       fprintf (stderr, \"(%s: %s non-prototype function declaration.)\\n\",\n-\t       inc_filename, fname);\n+\t       inc_filename, partial->fname);\n+    }\n+}\n+\n+/* For any name in NAMES that is defined as a macro,\n+   call recognized_macro on it. */\n+\n+void\n+check_macro_names (pfile, names)\n+     struct parse_file *pfile;\n+     namelist names;\n+{\n+  while (*names)\n+    {\n+      if (cpp_lookup (pfile, names, -1, -1))\n+\trecognized_macro (names);\n+      names += strlen (names) + 1;\n     }\n }\n \n void\n-read_scan_file (scan_file)\n-     FILE *scan_file;\n+read_scan_file (in_fname, argc, argv)\n+     char *in_fname;\n+     int argc;\n+     char **argv;\n {\n+  cpp_reader scan_in;\n+  cpp_options scan_options;\n+  struct fn_decl *fn;\n+  int i;\n+\n   obstack_init (&scan_file_obstack); \n \n-  scan_decls (scan_file);\n+  init_parse_file (&scan_in);\n+  scan_in.data = &scan_options;\n+  init_parse_options (&scan_options);\n+  i = cpp_handle_options (&scan_in, argc, argv);\n+  if (i < argc)\n+    fatal (\"Invalid option `%s'\", argv[i]);\n+  push_parse_file (&scan_in, in_fname);\n+  CPP_OPTIONS (&scan_in)->no_line_commands = 1;\n+\n+  scan_decls (&scan_in, argc, argv);\n+  check_macro_names (&scan_in, include_entry->required);\n+  check_macro_names (&scan_in, include_entry->extra);\n+\n+  if (verbose && (scan_in.errors + warnings) > 0)\n+    fprintf (stderr, \"(%s: %d errors and %d warnings from cpp)\\n\",\n+\t     inc_filename, scan_in.errors, warnings);\n+  if (scan_in.errors)\n+    exit (0);\n+\n+  /* Traditionally, getc and putc are defined in terms of _filbuf and _flsbuf.\n+     If so, those functions are also required. */\n+  if (special_file_handling == stdio_h\n+      && (fn = lookup_std_proto (\"_filbuf\", 7)) != NULL)\n+    {\n+      static char getchar_call[] = \"getchar();\";\n+      cpp_buffer *buf =\n+\tcpp_push_buffer (&scan_in, getchar_call, sizeof(getchar_call) - 1);\n+      int old_written = CPP_WRITTEN (&scan_in);\n+      int seen_filbuf = 0;\n+\n+      /* Scan the macro expansion of \"getchar();\". */\n+      for (;;)\n+\t{\n+\t  enum cpp_token token = cpp_get_token (&scan_in);\n+\t  int length = CPP_WRITTEN (&scan_in) - old_written;\n+\t  CPP_SET_WRITTEN (&scan_in, old_written);\n+\t  if (token == CPP_EOF) /* Should not happen ... */\n+\t    break;\n+\t  if (token == CPP_POP && CPP_BUFFER (&scan_in) == buf)\n+\t    {\n+\t      cpp_pop_buffer (&scan_in);\n+\t      break;\n+\t    }\n+\t  if (token == CPP_NAME && length == 7\n+\t      && strcmp (\"_filbuf\", scan_in.token_buffer + old_written) == 0)\n+\t    seen_filbuf++;\n+\t}\n+      if (seen_filbuf)\n+\t{\n+\t  int need_filbuf = !SEEN (fn) && !REQUIRED (fn);\n+\t  struct fn_decl *flsbuf_fn = lookup_std_proto (\"_flsbuf\", 7);\n+\t  int need_flsbuf\n+\t    = flsbuf_fn && !SEEN (flsbuf_fn) && !REQUIRED (flsbuf_fn);\n+\n+\t  /* Append \"_filbuf\" and/or \"_flsbuf\" to end of\n+\t     required_functions_list. */\n+\t  if (need_filbuf + need_flsbuf)\n+\t    {\n+\t      int old_len = namelist_end (required_functions_list)\n+\t\t- required_functions_list;\n+\t      char *new_list = (char*) xmalloc (old_len + 20);\n+\t      bcopy (required_functions_list, new_list, old_len);\n+\t      if (need_filbuf)\n+\t\t{\n+\t\t  strcpy (new_list + old_len, \"_filbuf\");\n+\t\t  old_len += 8;\n+\t\t  SET_REQUIRED (fn);\n+\t\t}\n+\t      if (need_flsbuf)\n+\t\t{\n+\t\t  strcpy (new_list + old_len, \"_flsbuf\");\n+\t\t  old_len += 8;\n+\t\t  SET_REQUIRED (flsbuf_fn);\n+\t\t}\n+\t      new_list[old_len] = '\\0';\n+\t      required_functions_list = (namelist)new_list;\n+\t      required_unseen_count += need_filbuf + need_flsbuf;\n+\t    }\n+\t}\n+    }\n \n   if (required_unseen_count + partial_count + missing_errno\n-#if 0\n+#if ADD_MISSING_EXTERN_C\n       + missing_extern_C_count\n #endif      \n       == 0)\n@@ -365,7 +625,7 @@ read_scan_file (scan_file)\n       if (partial_count)\n \tfprintf (stderr, \"%s: %d non-prototype function declarations.\\n\",\n \t\t inc_filename, partial_count);\n-#if 0\n+#if ADD_MISSING_EXTERN_C\n       if (missing_extern_C_count)\n \tfprintf (stderr,\n \t\t \"%s: %d declarations not protected by extern \\\"C\\\".\\n\",\n@@ -378,7 +638,7 @@ void\n write_rbrac ()\n {\n   struct fn_decl *fn;\n-  char **rptr;\n+  const char *cptr;\n \n   if (required_unseen_count)\n     {\n@@ -390,11 +650,13 @@ write_rbrac ()\n     }\n \n   /* Now we print out prototypes for those functions that we haven't seen. */\n-  for (rptr = required_functions; *rptr; rptr++)\n+  for (cptr = required_functions_list; *cptr!= '\\0'; )\n     {\n       int macro_protect = 0;\n+      int name_len = strlen (cptr);\n \n-      fn = lookup_std_proto (*rptr);\n+      fn = lookup_std_proto (cptr, name_len);\n+      cptr+= name_len + 1;\n       if (fn == NULL || !REQUIRED (fn))\n \tcontinue;\n \n@@ -425,11 +687,11 @@ write_rbrac ()\n \n   switch (special_file_handling)\n     {\n-    case errno_special:\n+    case errno_h:\n       if (missing_errno)\n \tfprintf (outf, \"extern int errno;\\n\");\n       break;\n-    case sys_stat_special:\n+    case sys_stat_h:\n       if (!seen_S_ISBLK && seen_S_IFBLK)\n \tfprintf (outf,\n \t\t \"#define S_ISBLK(mode) (((mode) & S_IFMT) == S_IFBLK)\\n\");\n@@ -452,7 +714,7 @@ write_rbrac ()\n     }\n \n \n-#if 0\n+#if ADD_MISSING_EXTERN_C\n   if (missing_extern_C_count + required_unseen_count > 0)\n     fprintf (outf, \"#ifdef __cplusplus\\n}\\n#endif\\n\");\n #endif\n@@ -674,7 +936,7 @@ main (argc, argv)\n   struct stat sbuf;\n   int c;\n   int i, done;\n-  char *cptr, *cptr0, **pptr;\n+  const char *cptr0, *cptr, **pptr;\n   int ifndef_line;\n   int endif_line;\n   long to_read;\n@@ -693,34 +955,58 @@ main (argc, argv)\n \n   if (argc < 4)\n     {\n-      fprintf (stderr, \"%s: Usage: foo.h infile.h outfile.h req_funcs <scan-file-name\\n\",\n+      fprintf (stderr, \"%s: Usage: foo.h infile.h outfile.h options\\n\",\n \t       progname);\n       exit (-1);\n     }\n \n   inc_filename = argv[1];\n   inc_filename_length = strlen (inc_filename);\n+\n+#ifdef FIXPROTO_IGNORE_LIST\n+  for (i = 0; files_to_ignore[i] != NULL; i++)\n+    {\n+      char *ignore_name = files_to_ignore[i];\n+      int ignore_len = strlen (ignore_name);\n+      if (strncmp (inc_filename, ignore_name, ignore_len) == 0)\n+\t{\n+\t  if (ignore_name[ignore_len-1] == '/'\n+\t      || inc_filename[ignore_len] == '\\0')\n+\t    {\n+\t      if (verbose)\n+\t\tfprintf (stderr, \"%s: ignoring %s\\n\", progname, inc_filename);\n+\t      exit (0);\n+\t    }\n+\t}\n+\t  \n+    }\n+#endif\n+\n   if (strcmp (inc_filename, \"sys/stat.h\") == 0)\n-    special_file_handling = sys_stat_special;\n+    special_file_handling = sys_stat_h;\n   else if (strcmp (inc_filename, \"errno.h\") == 0)\n-    special_file_handling = errno_special, missing_errno = 1;\n-\n-  /* Calculate an upper bound of the number of function names in argv[4] */\n-  for (i = 1, cptr = argv[4]; *cptr; cptr++)\n-    if (*cptr == ' ') i++;\n-  /* Find the list of prototypes required for this include file. */ \n-  required_functions = (char**)xmalloc ((i+1) * sizeof (char*));\n-  for (cptr = argv[4], cptr0 = cptr, pptr = required_functions, done = 0; \n+    special_file_handling = errno_h, missing_errno = 1;\n+  else if (strcmp (inc_filename, \"stdio.h\") == 0)\n+    special_file_handling = stdio_h;\n+  include_entry = std_include_table;\n+  while (include_entry->name != NULL\n+\t && strcmp (inc_filename, include_entry->name) != 0)\n+    include_entry++;\n+\n+  required_functions_list = include_entry->required;\n+\n+  /* Count and mark the prototypes required for this include file. */ \n+  for (cptr = required_functions_list, cptr0 = cptr, done = 0;\n        !done; cptr++)\n     {\n-      done = *cptr == '\\0';\n-      if (*cptr == ' ' || done)\n+      if (*cptr == '\\0')\n \t{\n-\t  *cptr = '\\0';\n-\t  if (cptr > cptr0)\n+\t  if (cptr[1] == 0)\n+\t    break;\n+\t  else\n \t    {\n-\t      struct fn_decl *fn = lookup_std_proto (cptr0);\n-\t      *pptr++ = cptr0;\n+\t      struct fn_decl *fn = lookup_std_proto (cptr0, strlen (cptr0));\n+\t      required_unseen_count++;\n \t      if (fn == NULL)\n \t\tfprintf (stderr, \"Internal error:  No prototype for %s\\n\",\n \t\t\t cptr0);\n@@ -730,10 +1016,8 @@ main (argc, argv)\n \t  cptr0 = cptr + 1;\n \t}\n     }\n-  required_unseen_count = pptr - required_functions;\n-  *pptr = 0;\n \n-  read_scan_file (stdin);\n+  read_scan_file (argv[2], argc - 4, argv + 4);\n \n   inf_fd = open (argv[2], O_RDONLY, 0666);\n   if (inf_fd < 0)\n@@ -794,10 +1078,6 @@ main (argc, argv)\n \n   if (check_protection (&ifndef_line, &endif_line))\n     {\n-#if 0\n-      fprintf (stderr, \"#ifndef %s on line %d; #endif on line %d\\n\",\n-\t       protect_name, ifndef_line, endif_line);\n-#endif\n       lbrac_line = ifndef_line+1;\n       rbrac_line = endif_line;\n     }\n@@ -828,7 +1108,7 @@ main (argc, argv)\n \t      c = inf_scan_ident (&buf, c);\n \t      INF_UNGET (c);\n \t      fputs (buf.base, outf);\n-\t      fn = lookup_std_proto (buf.base);\n+\t      fn = lookup_std_proto (buf.base, strlen (buf.base));\n \t      /* We only want to edit the declaration matching the one\n \t\t seen by scan-decls, as there can be multiple\n \t\t declarations, selected by #ifdef __STDC__ or whatever. */\n@@ -872,3 +1152,62 @@ main (argc, argv)\n \n   return 0;\n }\n+\f\n+/* Stub error functions.  These replace cpperror.c,\n+   because we want to suppress error messages. */\n+\n+void\n+cpp_file_line_for_message (pfile, filename, line, column)\n+     cpp_reader *pfile;\n+     char *filename;\n+     int line, column;\n+{\n+  if (!verbose)\n+    return;\n+  if (column > 0)\n+    fprintf (stderr, \"%s:%d:%d: \", filename, line, column);\n+  else\n+    fprintf (stderr, \"%s:%d: \", filename, line);\n+}\n+\n+void\n+cpp_print_containing_files (pfile)\n+     cpp_reader *pfile;\n+{\n+}\n+\n+/* IS_ERROR is 1 for error, 0 for warning */\n+void cpp_message (pfile, is_error, msg, arg1, arg2, arg3)\n+     int is_error;\n+     cpp_reader *pfile;\n+     char *msg;\n+     char *arg1, *arg2, *arg3;\n+{\n+  if (is_error)\n+    pfile->errors++;\n+  if (!verbose)\n+    return;\n+  if (!is_error)\n+    fprintf (stderr, \"warning: \");\n+  fprintf (stderr, msg, arg1, arg2, arg3);\n+  fprintf (stderr, \"\\n\");\n+}\n+\n+void\n+fatal (str, arg)\n+     char *str, *arg;\n+{\n+  fprintf (stderr, \"%s: \", progname);\n+  fprintf (stderr, str, arg);\n+  fprintf (stderr, \"\\n\");\n+  exit (FAILURE_EXIT_CODE);\n+}\n+\n+void\n+cpp_pfatal_with_name (pfile, name)\n+     cpp_reader *pfile;\n+     char *name;\n+{\n+  cpp_perror_with_name (pfile, name);\n+  exit (FAILURE_EXIT_CODE);\n+}"}, {"sha": "bfa8419d99e90a241069faf4072df206d8cdbcee", "filename": "gcc/fixproto", "status": "modified", "additions": 2, "deletions": 85, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ca463cdad1c4d09304baf3841906be92681d0a/gcc%2Ffixproto", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ca463cdad1c4d09304baf3841906be92681d0a/gcc%2Ffixproto", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixproto?ref=b3ca463cdad1c4d09304baf3841906be92681d0a", "patch": "@@ -56,7 +56,6 @@\n progname=$0\n progname=`basename $progname`\n original_dir=`pwd`\n-CPP=${CPP-./cpp}\n FIX_HEADER=${FIX_HEADER-$original_dir/fix-header}\n DEFINES=\"-D__STDC__=0 -D__cplusplus ${FIXPROTO_DEFINES}\"\n \n@@ -243,92 +242,10 @@ for code in ALL STD ; do\n \t  && grep \"$rel_source_file\" fixproto.list >/dev/null\n \tthen true\n \telse\n-\t  # echo doing $rel_source_file from $abs_source_dir\n-\t  required_list=\n-\t  extra_check_list=\n-\t  case $rel_source_file in\n-\t    ctype.h)\n-\t      required_list=\"isalnum isalpha iscntrl isdigit isgraph islower isprint ispunct isspace isupper isxdigit tolower toupper\" ;;\n-\t    dirent.h)\n-\t      required_list=\"closedir opendir readdir rewinddir\" ;;\n-\t    errno.h)\n-\t      extra_check_list=\"errno\" ;;\n-\t    curses.h)\n-\t      required_list=\"box delwin endwin getcurx getcury initscr mvcur mvwprintw mvwscanw newwin overlay overwrite scroll subwin touchwin waddstr wclear wclrtobot wclrtoeol waddch wdelch wdeleteln werase wgetch wgetstr winsch winsertln wmove wprintw wrefresh wscanw wstandend wstandout\" ;;\n-\t    fcntl.h)\n-\t      required_list=\"creat fcntl open\" ;;\n-\t    grp.h)\n-\t      #Maybe also \"getgrent fgetgrent setgrent endgrent\" */\n-\t      required_list=\"getgrgid getgrnam\" ;;\n-\t    limit.h)\n-\t      required_list= /* Lots of macros */ ;;\n-\t    locale.h)\n-\t      required_list=\"localeconv setlocale\" ;;\n-\t    math.h)\n-\t      required_list=\"acos asin atan atan2 ceil cos cosh exp fabs floor fmod frexp ldexp log10 log modf pow sin sinh sqrt tan tanh\"\n-\t      extra_check_list=\"HUGE_VAL\" ;;\n-\t    pwd.h)\n-\t      required_list=\"getpwnam getpwuid\" ;;\n-\t    setjmp.h)\n-\t      # Left out siglongjmp sigsetjmp - these depend on sigjmp_buf.\n-\t      required_list=\"longjmp setjmp\" ;;\n-\t    signal.h)\n-\t      # Left out signal() - its prototype is too complex for us!\n-\t      # Also left out \"sigaction sigaddset sigdelset sigemptyset\n-\t      # sigfillset sigismember sigpending sigprocmask sigsuspend\"\n-\t      # because these need sigset_t or struct sigaction.\n-\t      # Most systems that provide them will also declare them.\n-\t      required_list=\"kill raise\" ;;\n-\t    stdio.h)\n-\t      required_list=\"clearerr fclose feof ferror fflush fgetc fgetpos fgets fopen fprintf fputc fputs fread freopen fscanf fseek fsetpos ftell fwrite getc getchar gets pclose perror popen printf putc putchar puts remove rename rewind scanf setbuf setvbuf sprintf sscanf vprintf vsprintf vfprintf tmpfile tmpnam ungetc\"\n-\t      if grep '[^_a-zA-Z0-9]_flsbuf' <$abs_source_file >/dev/null; then\n-\t\trequired_list=\"$required_list _flsbuf _filbuf\"\n-\t      fi\n-\t      # Should perhaps also handle NULL, EOF, ... ?\n-\t      ;;\n-\t    stdlib.h)\n-\t      required_list=\"$required_stdlib_h\" ;;\n-\t    string.h)\n-\t      required_list=\"memchr memcmp memcpy memmove memset strcat strchr strcmp strcoll strcpy strcspn strerror strlen strncat strncmp strncpy strpbrk strrchr strspn strstr strtok strxfrm\" ;;\n-# Should perhaps also add NULL and size_t\n-\t    sys/stat.h)\n-\t      required_list=\"chmod fstat mkdir mkfifo stat lstat umask\"\n-\t      extra_check_list=\"S_ISDIR S_ISBLK S_ISCHR S_ISFIFO S_ISREG S_ISLNK S_IFDIR S_IFBLK S_IFCHR S_IFIFO S_IFREG S_IFLNK\" ;;\n-\t    sys/times.h)\n-\t      required_list=\"times\" ;;\n-# \"sys/types.h\" add types (not in old g++-include)\n-\t    sys/utsname.h)\n-\t      required_list=\"uname\" ;;\n-\t    sys/wait.h)\n-\t      required_list=\"wait waitpid\"\n-\t      extra_check_list=\"WEXITSTATUS WIFEXITED WIFSIGNALED WIFSTOPPED WSTOPSIG WTERMSIG WNOHANG WNOTRACED\" ;;\n-\t    tar.h)\n-\t      required_list=  ;;\n-\t    termios.h)\n-\t      required_list=\"cfgetispeed cfgetospeed cfsetispeed cfsetospeed tcdrain tcflow tcflush tcgetattr tcsendbreak tcsetattr\" ;;\n-\t    time.h)\n-\t      required_list=\"asctime clock ctime difftime gmtime localtime mktime strftime time tzset\" ;;\n-\t    unistd.h)\n-\t      required_list=\"$required_unistd_h\" ;;\n-\t  esac\n-\t  rm -f fixtmp.c fixtmp.i\n-\t  echo \"#include <${rel_source_file}>\" >fixtmp.c\n-\t  for macro in ${required_list} ${extra_check_list}\n-\t  do\n-\t    echo \"#ifdef ${macro}\" >>fixtmp.c\n-\t    echo \"__DEFINED_MACRO_${macro};\" >>fixtmp.c\n-\t    echo \"#endif\" >>fixtmp.c\n-\t  done\n-\t  if ${CPP} ${DEFINES} $include_path fixtmp.c >fixtmp.i 2>/dev/null\n-\t  then\n-\t   $FIX_HEADER $rel_source_file $abs_source_file $abs_target_file \"$required_list\" <fixtmp.i\n-\t  else\n-\t    echo \"${progname}: cpp could not parse ${abs_source_file} (ignored)\"\n-\t  fi\n+\t  $FIX_HEADER $rel_source_file $abs_source_file $abs_target_file ${DEFINES} $include_path\n \t  echo \"${rel_source_file}\" >>fixproto.list\n \tfi\n       done\n-      rm -f fixtmp.c fixtmp.i\n     done\n     done_dirs=\"$done_dir $rel_source_dir\"\n done\n@@ -348,7 +265,7 @@ do\n #define ${rel_source_ident}\n #endif\n EOF\n-    ${FIX_HEADER} $rel_source_file tmp.h $abs_target_dir/$rel_source_file \"$required_list\" </dev/null\n+    ${FIX_HEADER} $rel_source_file tmp.h $abs_target_dir/$rel_source_file ${DEFINES} $include_path\n     rm tmp.h\n   fi\n done"}, {"sha": "3b5c6108bfb49582a2aaa126424038c67563233c", "filename": "gcc/gen-protos.c", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ca463cdad1c4d09304baf3841906be92681d0a/gcc%2Fgen-protos.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ca463cdad1c4d09304baf3841906be92681d0a/gcc%2Fgen-protos.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgen-protos.c?ref=b3ca463cdad1c4d09304baf3841906be92681d0a", "patch": "@@ -19,9 +19,25 @@ Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include <ctype.h>\n #include \"hconfig.h\"\n #include \"scan.h\"\n+#include \"cpplib.h\"\n+#include \"cpphash.h\"\n \n #define HASH_SIZE 2503 /* a prime */\n \n+int\n+hashf (name, len, hashsize)\n+     register U_CHAR *name;\n+     register int len;\n+     int hashsize;\n+{\n+  register int r = 0;\n+\n+  while (len--)\n+    r = HASHSTEP (r, *name++);\n+\n+  return MAKE_POS (r) % hashsize;\n+}\n+\n int hash_tab[HASH_SIZE];\n int verbose = 0;\n \n@@ -119,7 +135,7 @@ main (argc, argv)\n \n       /* NOTE:  If you edit this,\n \t also edit lookup_std_proto in fix-header.c !! */\n-      i = hash (name_start) % HASH_SIZE;\n+      i = hashf (name_start, name_end - name_start, HASH_SIZE);\n       i0 = i;\n       if (hash_tab[i] != 0)\n \t{\n@@ -153,3 +169,14 @@ main (argc, argv)\n \n   return 0;\n }\n+\n+void\n+fatal (s)\n+     char *s;\n+{\n+  fprintf (stderr, \"%s: %s\\n\", \"gen-protos\", s);\n+#ifndef FAILURE_EXIT_CODE\n+#define FAILURE_EXIT_CODE 33\t/* gnu cc command understands this */\n+#endif\n+  exit (FAILURE_EXIT_CODE);\n+}"}, {"sha": "602082d8c3db858a161928fee70e377270cea6c6", "filename": "gcc/scan-decls.c", "status": "modified", "additions": 88, "deletions": 89, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ca463cdad1c4d09304baf3841906be92681d0a/gcc%2Fscan-decls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ca463cdad1c4d09304baf3841906be92681d0a/gcc%2Fscan-decls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fscan-decls.c?ref=b3ca463cdad1c4d09304baf3841906be92681d0a", "patch": "@@ -20,11 +20,7 @@ Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n #include <stdio.h>\n #include <ctype.h>\n #include \"hconfig.h\"\n-#include \"scan.h\"\n-\n-sstring buf;\n-sstring rtype;\n-sstring arg_list;\n+#include \"cpplib.h\"\n \n int brace_nesting = 0;\n \n@@ -40,18 +36,18 @@ char extern_C_braces[20];\n int current_extern_C = 0;\n \n static void\n-skip_to_closing_brace (fp)\n-     FILE *fp;\n+skip_to_closing_brace (pfile)\n+     cpp_reader *pfile;\n {\n   int nesting = 1;\n   for (;;)\n     {\n-      int c = get_token (fp, &buf);\n-      if (c == EOF)\n+      enum cpp_token token = cpp_get_token (pfile);\n+      if (token == CPP_EOF)\n \tbreak;\n-      if (c == '{')\n+      if (token == CPP_LBRACE)\n \tnesting++;\n-      if (c == '}' && --nesting == 0)\n+      if (token == CPP_RBRACE && --nesting == 0)\n \tbreak;\n     }\n }\n@@ -61,19 +57,26 @@ skip_to_closing_brace (fp)\n    other interesting sequences (external variables and macros).  */\n \n int\n-scan_decls (fp)\n-     FILE *fp;\n+scan_decls (pfile, argc, argv)\n+     cpp_reader *pfile;\n+     int argc;\n+     char**argv;\n {\n-  int c;\n   int saw_extern, saw_inline;\n+  int old_written;\n+  int prev_id_start, prev_id_end;\n+  enum cpp_token token;\n+\n \n  new_statement:\n-  c = get_token (fp, &buf);\n+  CPP_SET_WRITTEN (pfile, 0);\n+  token = cpp_get_token (pfile);\n+\n  handle_statement:\n   current_extern_C = 0;\n   saw_extern = 0;\n   saw_inline = 0;\n-  if (c == '}')\n+  if (token == CPP_RBRACE)\n     {\n       /* Pop an 'extern \"C\"' nesting level, if appropriate.  */\n       if (extern_C_braces_length\n@@ -82,121 +85,117 @@ scan_decls (fp)\n       brace_nesting--;\n       goto new_statement;\n     }\n-  if (c == '{')\n+  if (token == CPP_LBRACE)\n     {\n       brace_nesting++;\n       goto new_statement;\n     }\n-  if (c == EOF)\n+  if (token == CPP_EOF)\n     return 0;\n-  if (c == ';')\n+  if (token == CPP_SEMICOLON)\n     goto new_statement;\n-  if (c != IDENTIFIER_TOKEN)\n+  if (token != CPP_NAME)\n     goto new_statement;\n-  rtype.ptr = rtype.base;\n-  if (SSTRING_LENGTH (&buf) > 16\n-      && strncmp (buf.base, \"__DEFINED_MACRO_\", 16) == 0)\n-    {\n-      /* For certain interesting macro names, fixproto puts\n-\t #ifdef FOO\n-\t __DEFINED_MACRO_FOO\n-\t #endif\n-\t into the file to be pre-processed.  So if we see __DEFINED_MACRO_FOO,\n-\t it means FOO was defined, which we may want to make a note of.  */\n-      recognized_macro (buf.base+16);\n-      goto new_statement;\n-    }\n-  if (strcmp (buf.base, \"inline\") == 0)\n-    {\n+  if (strcmp (pfile->token_buffer, \"inline\") == 0)\n+     {\n       saw_inline = 1;\n-      c = get_token (fp, &buf);\n+      CPP_SET_WRITTEN (pfile, 0);\n+      token = cpp_get_non_space_token (pfile);\n     }\n-  if (strcmp (buf.base, \"extern\") == 0)\n+  if (strcmp (pfile->token_buffer, \"extern\") == 0)\n     {\n       saw_extern = 1;\n-      c = get_token (fp, &buf);\n-      if (c == STRING_TOKEN && strcmp (buf.base, \"C\") == 0)\n+      CPP_SET_WRITTEN (pfile, 0);\n+      token = cpp_get_non_space_token (pfile);\n+      if (token == CPP_STRING\n+\t  && strcmp (pfile->token_buffer, \"\\\"C\\\"\") == 0)\n \t{\n+\t  CPP_SET_WRITTEN (pfile, 0);\n \t  current_extern_C = 1;\n-\t  c = get_token (fp, &buf);\n-\t  if (c == '{')\n+\t  token = cpp_get_non_space_token (pfile);\n+\t  if (token == CPP_LPAREN)\n \t    {\n \t      brace_nesting++;\n \t      extern_C_braces[extern_C_braces_length++] = brace_nesting;\n \t      goto new_statement;\n \t    }\n-\t  c = get_token (fp, &buf);\n+\t  token = cpp_get_non_space_token (pfile);\n \t}\n     }\n+  prev_id_start = NULL;\n   for (;;)\n     {\n-      int followingc = getc (fp); /* char following token in buf */\n-\n-      MAKE_SSTRING_SPACE (&rtype, 1);\n-      *rtype.ptr = 0;\n-\n-      if (c == IDENTIFIER_TOKEN)\n+      int start_written = CPP_WRITTEN (pfile);\n+      token = cpp_get_token (pfile);\n+      switch (token)\n \t{\n-\t  int nextc = skip_spaces (fp, followingc);\n-\t  if (nextc == '(')\n+\tcase CPP_LPAREN:\n+\t  if (prev_id_start)\n \t    {\n \t      int nesting = 1;\n-\t      int func_lineno = source_lineno;\n-\t      char *args;\n-\n-\t      arg_list.ptr = arg_list.base;\n+\t      int have_arg_list = 0;\n+\t      cpp_buffer *fbuf = cpp_file_buffer (pfile);\n+\t      long func_lineno;\n+\t      cpp_buf_line_and_col (fbuf, &func_lineno, NULL);\n \t      for (;;)\n \t\t{\n-\t\t  c = getc (fp);\n-\t\t  if (c == '(')\n+\t\t  token = cpp_get_token (pfile);\n+\t\t  if (token == CPP_LPAREN)\n \t\t    nesting++;\n-\t\t  else if (c == ')')\n-\t\t    if (--nesting == 0)\n-\t\t      break;\n-\t\t  if (c == EOF)\n-\t\t    break;\n-\t\t  if (c == '\\n')\n+\t\t  else if (token == CPP_RPAREN)\n \t\t    {\n-\t\t      c = ' ';\n-\t\t      source_lineno++;\n-\t\t      lineno++;\n+\t\t      nesting--;\n+\t\t      if (nesting == 0)\n+\t\t\tbreak;\n \t\t    }\n-\t\t  SSTRING_PUT (&arg_list, c);\n+\t\t  else if (token == CPP_EOF)\n+\t\t    break;\n+\t\t  else if (token == CPP_NAME || token == CPP_3DOTS)\n+\t\t    have_arg_list = 1;\n \t\t}\n-\t      SSTRING_PUT (&arg_list, '\\0');\n-\t      args = arg_list.base;\n-\t      while (*args == ' ')\n-\t\targs++;\n-\t      recognized_function (buf.base,\n+\t      recognized_function (pfile->token_buffer + prev_id_start,\n+\t\t\t\t   prev_id_end - prev_id_start,\n \t\t\t\t   (saw_inline ? 'I'\n \t\t\t\t    : in_extern_C_brace || current_extern_C\n \t\t\t\t    ? 'F' : 'f'),\n-\t\t\t\t   rtype.base, args,\n-\t\t\t\t   source_filename.base, func_lineno);\n-\t      c = get_token (fp, &buf);\n-\t      if (c == '{')\n+\t\t\t\t   pfile->token_buffer, prev_id_start,\n+\t\t\t\t   have_arg_list,\n+\t\t\t\t   fbuf->nominal_fname, func_lineno);\n+\t      token = cpp_get_non_space_token (pfile);\n+\t      if (token == CPP_LBRACE)\n \t\t{\n \t\t  /* skip body of (normally) inline function */\n-\t\t  skip_to_closing_brace (fp);\n+\t\t  skip_to_closing_brace (pfile);\n \t\t  goto new_statement;\n \t\t}\n \t      goto handle_statement;\n \t    }\n-\t  else if (nextc == ';' && saw_extern)\n+\t  break;\n+\tcase CPP_SEMICOLON:\n+\t  if (prev_id_start && saw_extern)\n \t    {\n-\t      recognized_extern (buf.base, rtype.base);\n-\t      goto new_statement;\n+\t      recognized_extern (pfile->token_buffer + prev_id_start,\n+\t\t\t\t prev_id_end - prev_id_start,\n+\t\t\t\t pfile->token_buffer,\n+\t\t\t\t prev_id_start);\n \t    }\n-\t  else\n-\t    ungetc (nextc, fp);\n+\t  goto new_statement;\n+\tcase CPP_NAME:\n+\t  prev_id_start = start_written;\n+\t  prev_id_end = CPP_WRITTEN (pfile);\n+\t  break;\n+\n+\tcase CPP_EOF:\n+\t  return;  /* ??? FIXME */\n+\n+\tcase CPP_LBRACE:  case CPP_RBRACE:  case CPP_DIRECTIVE:\n+\t  goto new_statement;  /* handle_statement? */\n+\t  \n+\tcase CPP_HSPACE:  case CPP_VSPACE:  case CPP_COMMENT:  case CPP_POP:\n+\t  break;\n+\n+\t default:\n+\t  prev_id_start = NULL;\n \t}\n-      else if (followingc != EOF)\n-\tungetc (followingc, fp);\n-      if (c == ';' || c == '{' || c == '}' || c == EOF)\n-\tgoto handle_statement;\n-      sstring_append (&rtype, &buf);\n-      if (followingc == ' ' || followingc == '\\t' || followingc == '\\n')\n-\tSSTRING_PUT (&rtype, ' ');\n-      c = get_token (fp, &buf);\n     }\n }"}, {"sha": "ff4b5696d7cadfe82d41f061ba23d91aef4a0c7d", "filename": "gcc/scan.c", "status": "modified", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ca463cdad1c4d09304baf3841906be92681d0a/gcc%2Fscan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ca463cdad1c4d09304baf3841906be92681d0a/gcc%2Fscan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fscan.c?ref=b3ca463cdad1c4d09304baf3841906be92681d0a", "patch": "@@ -58,35 +58,6 @@ sstring_append (dst, src)\n   *d = 0;  \n }\n \n-memory_full ()\n-{\n-  abort();\n-}\n-\n-char *\n-xmalloc (size)\n-     unsigned size;\n-{\n-  register char *ptr = (char *) malloc (size);\n-  if (ptr != 0) return (ptr);\n-  memory_full ();\n-  /*NOTREACHED*/\n-  return 0;\n-}\n-\n-\n-char *\n-xrealloc (old, size)\n-     char *old;\n-     unsigned size;\n-{\n-  register char *ptr = (char *) realloc (old, size);\n-  if (ptr != 0) return (ptr);\n-  memory_full ();\n-  /*NOTREACHED*/\n-  return 0;\n-}\n-\n int\n scan_ident (fp, s, c)\n      register FILE *fp;\n@@ -267,13 +238,3 @@ get_token (fp, s)\n   *s->ptr = 0;\n   return c;\n }\n-\n-unsigned long\n-hash (str)\n-     char *str;\n-{\n-  int h = 0;\n-  /* Replace this with something faster/better! FIXME! */\n-  while (*str) h = (h << 3) + *str++;\n-  return h & 0x7FFFFFFF;\n-}"}, {"sha": "ff666185b9f79d7b5f828b8f83395b72d29818ba", "filename": "gcc/scan.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ca463cdad1c4d09304baf3841906be92681d0a/gcc%2Fscan.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ca463cdad1c4d09304baf3841906be92681d0a/gcc%2Fscan.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fscan.h?ref=b3ca463cdad1c4d09304baf3841906be92681d0a", "patch": "@@ -59,7 +59,7 @@ extern int scan_string _PARAMS((FILE*, sstring *, int));\n extern int read_upto _PARAMS((FILE*, sstring*, int));\n extern char *xmalloc _PARAMS((unsigned));\n extern char *xrealloc _PARAMS((char *, unsigned));\n-extern unsigned long hash _PARAMS((char*));\n+extern unsigned long hash _PARAMS((const char*));\n \n /* get_token is a simple C lexer. */\n #define IDENTIFIER_TOKEN 300"}]}