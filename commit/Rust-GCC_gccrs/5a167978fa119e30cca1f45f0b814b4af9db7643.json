{"sha": "5a167978fa119e30cca1f45f0b814b4af9db7643", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWExNjc5NzhmYTExOWUzMGNjYTFmNDVmMGI4MTRiNGFmOWRiNzY0Mw==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@integrable-solutions.net", "date": "2003-10-14T08:19:06Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2003-10-14T08:19:06Z"}, "message": "name-lookup.h (cxx_scope_find_binding_for_name): Don't export.\n\n\t* name-lookup.h (cxx_scope_find_binding_for_name): Don't export.\n\t(binding_for_name): Likewise.\n\t(cxx_binding_clear): Move to name-lookup.c.\n\t* name-lookup.c (cxx_scope_find_binding_for_name): Now static.\n\t(binding_for_name): Likewise.\n\t* decl2.c (is_ancestor): Move to name-lookup.c\n\t(namespace_ancestor): Likewise.\n\t(add_using_namespace): Likewise.\n\t(ambiguous_decl): Likewise.\n\t(lookup_using_namespace): Likewise.\n\t(qualified_lookup_using_namespace): Likewise.\n\t(set_decl_namespace): Likewise.\n\t(decl_namespace): Likewise.\n\t(current_decl_namespace): Likewise.\n\t(push_decl_namespace): Likewise.\n\t(pop_decl_namespace): Likewise.\n\t(push_scope): Likewise.\n\t(pop_scope): Likewise.\n\t(struct arg_lookup): Likewise.\n\t(arg_assoc): Likewise.\n\t(arg_assoc_args): Likewise.\n\t(arg_assoc_type): Likewise.\n\t(add_function): Likewise.\n\t(arg_assoc_namespace): Likewise.\n\t(arg_assoc_class): Likewise.\n\t(arg_assoc_template_arg): Likewise.\n\t(do_namespace_alias): Likewise.\n\t(validate_nonmember_using_decl): Likewise.\n\t(do_nonmember_using_decl): Likewise.\n\t(do_toplevel_using_decl): Likewise.\n\t(do_local_using_decl): Likewise.\n\t(do_class_using_decl): Likewise.\n\t(do_using_directive): Likewise.\n\t(constructor_name_full): Likewise.\n\t(constructor_name): Likewise.\n\t(constructor_name_p): Likewise.\n\nFrom-SVN: r72462", "tree": {"sha": "d15a398b81bf7fbe354ee42f168c8c775a7df7ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d15a398b81bf7fbe354ee42f168c8c775a7df7ea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5a167978fa119e30cca1f45f0b814b4af9db7643", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a167978fa119e30cca1f45f0b814b4af9db7643", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a167978fa119e30cca1f45f0b814b4af9db7643", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a167978fa119e30cca1f45f0b814b4af9db7643/comments", "author": {"login": "cxx-undef", "id": 5528103, "node_id": "MDQ6VXNlcjU1MjgxMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/5528103?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cxx-undef", "html_url": "https://github.com/cxx-undef", "followers_url": "https://api.github.com/users/cxx-undef/followers", "following_url": "https://api.github.com/users/cxx-undef/following{/other_user}", "gists_url": "https://api.github.com/users/cxx-undef/gists{/gist_id}", "starred_url": "https://api.github.com/users/cxx-undef/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cxx-undef/subscriptions", "organizations_url": "https://api.github.com/users/cxx-undef/orgs", "repos_url": "https://api.github.com/users/cxx-undef/repos", "events_url": "https://api.github.com/users/cxx-undef/events{/privacy}", "received_events_url": "https://api.github.com/users/cxx-undef/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9dccaa6bb6721b80b4c0d51833ba1593799ee867", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9dccaa6bb6721b80b4c0d51833ba1593799ee867", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9dccaa6bb6721b80b4c0d51833ba1593799ee867"}], "stats": {"total": 2422, "additions": 1227, "deletions": 1195}, "files": [{"sha": "dd25ea37ad807893461de740cda04f2a1afbe2e5", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a167978fa119e30cca1f45f0b814b4af9db7643/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a167978fa119e30cca1f45f0b814b4af9db7643/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=5a167978fa119e30cca1f45f0b814b4af9db7643", "patch": "@@ -2,6 +2,45 @@\n \n \t* ChangeLog: Add PR number to patch for PR c++/12370.\n \n+2003-10-13  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n+\n+\t* name-lookup.h (cxx_scope_find_binding_for_name): Don't export.\n+\t(binding_for_name): Likewise.\n+\t(cxx_binding_clear): Move to name-lookup.c.\n+\t* name-lookup.c (cxx_scope_find_binding_for_name): Now static.\n+\t(binding_for_name): Likewise.\n+\t* decl2.c (is_ancestor): Move to name-lookup.c\n+\t(namespace_ancestor): Likewise.\n+\t(add_using_namespace): Likewise.\n+\t(ambiguous_decl): Likewise.\n+\t(lookup_using_namespace): Likewise.\n+\t(qualified_lookup_using_namespace): Likewise.\n+\t(set_decl_namespace): Likewise.\n+\t(decl_namespace): Likewise.\n+\t(current_decl_namespace): Likewise.\n+\t(push_decl_namespace): Likewise.\n+\t(pop_decl_namespace): Likewise.\n+\t(push_scope): Likewise.\n+\t(pop_scope): Likewise.\n+\t(struct arg_lookup): Likewise.\n+\t(arg_assoc): Likewise.\n+\t(arg_assoc_args): Likewise.\n+\t(arg_assoc_type): Likewise.\n+\t(add_function): Likewise.\n+\t(arg_assoc_namespace): Likewise.\n+\t(arg_assoc_class): Likewise.\n+\t(arg_assoc_template_arg): Likewise.\n+\t(do_namespace_alias): Likewise.\n+\t(validate_nonmember_using_decl): Likewise.\n+\t(do_nonmember_using_decl): Likewise.\n+\t(do_toplevel_using_decl): Likewise.\n+\t(do_local_using_decl): Likewise.\n+\t(do_class_using_decl): Likewise.\n+\t(do_using_directive): Likewise.\n+\t(constructor_name_full): Likewise.\n+\t(constructor_name): Likewise.\n+\t(constructor_name_p): Likewise.\n+\n 2003-10-13  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n \n \tBreak out decl.c (2/n) "}, {"sha": "1d0e288c215cee17237b44e038ba0f0ae3cf3d9b", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a167978fa119e30cca1f45f0b814b4af9db7643/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a167978fa119e30cca1f45f0b814b4af9db7643/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=5a167978fa119e30cca1f45f0b814b4af9db7643", "patch": "@@ -3615,11 +3615,7 @@ extern void check_goto\t\t\t\t(tree);\n extern void define_case_label\t\t\t(void);\n extern tree make_typename_type\t\t\t(tree, tree, tsubst_flags_t);\n extern tree make_unbound_class_template\t\t(tree, tree, tsubst_flags_t);\n-extern tree namespace_ancestor\t\t\t(tree, tree);\n-extern bool is_ancestor                         (tree, tree);\n extern tree check_for_out_of_scope_variable     (tree);\n-extern bool lookup_using_namespace (tree, cxx_binding *, tree, tree, int, tree *);\n-extern bool qualified_lookup_using_namespace (tree, tree, cxx_binding *, int);\n extern tree build_library_fn\t\t\t(tree, tree);\n extern tree build_library_fn_ptr\t\t(const char *, tree);\n extern tree build_cp_library_fn_ptr\t\t(const char *, tree);\n@@ -3709,9 +3705,6 @@ extern tree grokfield (tree, tree, tree, tree, tree);\n extern tree grokbitfield (tree, tree, tree);\n extern tree groktypefield\t\t\t(tree, tree);\n extern void cplus_decl_attributes (tree *, tree, int);\n-extern tree constructor_name_full\t\t(tree);\n-extern tree constructor_name (tree);\n-extern bool constructor_name_p                  (tree, tree);\n extern void defer_fn (tree);\n extern void finish_anon_union (tree);\n extern tree finish_table (tree, tree, tree, int);\n@@ -3723,20 +3716,8 @@ extern void import_export_decl (tree);\n extern void import_export_tinfo\t(tree, tree, bool);\n extern tree build_cleanup\t\t\t(tree);\n extern tree build_offset_ref_call_from_tree     (tree, tree);\n-extern void set_decl_namespace (tree, tree, bool);\n-extern tree current_decl_namespace              (void);\n-extern void push_decl_namespace                 (tree);\n-extern void pop_decl_namespace                  (void);\n-extern void push_scope\t\t\t\t(tree);\n-extern void pop_scope\t\t\t\t(tree);\n-extern void do_namespace_alias (tree, tree);\n-extern void do_toplevel_using_decl (tree);\n-extern void do_local_using_decl (tree);\n-extern tree do_class_using_decl (tree);\n-extern void do_using_directive (tree);\n extern void check_default_args (tree);\n extern void mark_used (tree);\n-extern tree lookup_arg_dependent (tree, tree, tree);\n extern void finish_static_data_member_decl (tree, tree, tree, int);\n extern tree cp_build_parm_decl (tree, tree);\n extern tree build_artificial_parm (tree, tree);"}, {"sha": "b51e365eefd68afa7fd19fce919f59e6292a4d42", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 0, "deletions": 1169, "changes": 1169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a167978fa119e30cca1f45f0b814b4af9db7643/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a167978fa119e30cca1f45f0b814b4af9db7643/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=5a167978fa119e30cca1f45f0b814b4af9db7643", "patch": "@@ -64,16 +64,10 @@ typedef struct priority_info_s {\n static void mark_vtable_entries (tree);\n static void grok_function_init (tree, tree);\n static bool maybe_emit_vtables (tree);\n-static void add_using_namespace (tree, tree, bool);\n-static cxx_binding *ambiguous_decl (tree, cxx_binding *, cxx_binding *, int);\n static tree build_anon_union_vars (tree);\n static bool acceptable_java_type (tree);\n static tree start_objects (int, int);\n static void finish_objects (int, int, tree);\n-static tree merge_functions (tree, tree);\n-static tree decl_namespace (tree);\n-static tree validate_nonmember_using_decl (tree, tree *, tree *);\n-static void do_nonmember_using_decl (tree, tree, tree, tree, tree *, tree *);\n static tree start_static_storage_duration_function (unsigned);\n static void finish_static_storage_duration_function (tree);\n static priority_info get_priority_info (int);\n@@ -115,9 +109,6 @@ int at_eof;\n tree static_ctors;\n tree static_dtors;\n \n-/* The :: namespace.  */\n-\n-tree global_namespace;\n \f\n /* Incorporate `const' and `volatile' qualifiers for member functions.\n    FUNCTION is a TYPE_DECL or a FUNCTION_DECL.\n@@ -1149,58 +1140,6 @@ cplus_decl_attributes (tree *decl, tree attributes, int flags)\n   if (TREE_CODE (*decl) == TYPE_DECL)\n     SET_IDENTIFIER_TYPE_VALUE (DECL_NAME (*decl), TREE_TYPE (*decl));\n }\n-\f\n-/* Return the name for the constructor (or destructor) for the\n-   specified class TYPE.  When given a template, this routine doesn't\n-   lose the specialization.  */\n-\n-tree\n-constructor_name_full (tree type)\n-{\n-  type = TYPE_MAIN_VARIANT (type);\n-  if (CLASS_TYPE_P (type) && TYPE_WAS_ANONYMOUS (type) \n-      && TYPE_HAS_CONSTRUCTOR (type))\n-    return DECL_NAME (OVL_CURRENT (CLASSTYPE_CONSTRUCTORS (type)));\n-  else\n-    return TYPE_IDENTIFIER (type);\n-}\n-\n-/* Return the name for the constructor (or destructor) for the\n-   specified class.  When given a template, return the plain\n-   unspecialized name.  */\n-\n-tree\n-constructor_name (tree type)\n-{\n-  tree name;\n-  name = constructor_name_full (type);\n-  if (IDENTIFIER_TEMPLATE (name))\n-    name = IDENTIFIER_TEMPLATE (name);\n-  return name;\n-}\n-\n-/* Returns TRUE if NAME is the name for the constructor for TYPE.  */\n-\n-bool\n-constructor_name_p (tree name, tree type)\n-{\n-  tree ctor_name;\n-\n-  if (!name)\n-    return false;\n-  \n-  if (TREE_CODE (name) != IDENTIFIER_NODE)\n-    return false;\n-  \n-  ctor_name = constructor_name_full (type);\n-  if (name == ctor_name)\n-    return true;\n-  if (IDENTIFIER_TEMPLATE (ctor_name)\n-      && name == IDENTIFIER_TEMPLATE (ctor_name))\n-    return true;\n-  return false;\n-}\n-\n \f\n /* Defer the compilation of the FN until the end of compilation.  */\n \n@@ -3013,1115 +2952,7 @@ build_offset_ref_call_from_tree (tree fn, tree args)\n     return build_min_non_dep (CALL_EXPR, expr, orig_fn, orig_args);\n   return expr;\n }\n-\n-/* Returns true if ROOT (a namespace, class, or function) encloses\n-   CHILD.  CHILD may be either a class type or a namespace.  */\n-\n-bool\n-is_ancestor (tree root, tree child)\n-{\n-  my_friendly_assert ((TREE_CODE (root) == NAMESPACE_DECL\n-\t\t       || TREE_CODE (root) == FUNCTION_DECL\n-\t\t       || CLASS_TYPE_P (root)), 20030307);\n-  my_friendly_assert ((TREE_CODE (child) == NAMESPACE_DECL\n-\t\t       || CLASS_TYPE_P (child)),\n-\t\t      20030307);\n-  \n-  /* The global namespace encloses everything.  */\n-  if (root == global_namespace)\n-    return true;\n-\n-  while (true)\n-    {\n-      /* If we've run out of scopes, stop.  */\n-      if (!child)\n-\treturn false;\n-      /* If we've reached the ROOT, it encloses CHILD.  */\n-      if (root == child)\n-\treturn true;\n-      /* Go out one level.  */\n-      if (TYPE_P (child))\n-\tchild = TYPE_NAME (child);\n-      child = DECL_CONTEXT (child);\n-    }\n-}\n-  \n-\n-/* Return the namespace that is the common ancestor \n-   of two given namespaces.  */\n-\n-tree\n-namespace_ancestor (tree ns1, tree ns2)\n-{\n-  timevar_push (TV_NAME_LOOKUP);\n-  if (is_ancestor (ns1, ns2))\n-    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, ns1);\n-  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP,\n-                          namespace_ancestor (CP_DECL_CONTEXT (ns1), ns2));\n-}\n-\n-/* Insert USED into the using list of USER. Set INDIRECT_flag if this\n-   directive is not directly from the source. Also find the common\n-   ancestor and let our users know about the new namespace */\n-static void \n-add_using_namespace (tree user, tree used, bool indirect)\n-{\n-  tree t;\n-  timevar_push (TV_NAME_LOOKUP);\n-  /* Using oneself is a no-op.  */\n-  if (user == used)\n-    {\n-      timevar_pop (TV_NAME_LOOKUP);\n-      return;\n-    }\n-  my_friendly_assert (TREE_CODE (user) == NAMESPACE_DECL, 380);\n-  my_friendly_assert (TREE_CODE (used) == NAMESPACE_DECL, 380);\n-  /* Check if we already have this.  */\n-  t = purpose_member (used, DECL_NAMESPACE_USING (user));\n-  if (t != NULL_TREE)\n-    {\n-      if (!indirect)\n-\t/* Promote to direct usage.  */\n-\tTREE_INDIRECT_USING (t) = 0;\n-      timevar_pop (TV_NAME_LOOKUP);\n-      return;\n-    }\n-\n-  /* Add used to the user's using list.  */\n-  DECL_NAMESPACE_USING (user) \n-    = tree_cons (used, namespace_ancestor (user, used), \n-\t\t DECL_NAMESPACE_USING (user));\n-\n-  TREE_INDIRECT_USING (DECL_NAMESPACE_USING (user)) = indirect;\n-\n-  /* Add user to the used's users list.  */\n-  DECL_NAMESPACE_USERS (used)\n-    = tree_cons (user, 0, DECL_NAMESPACE_USERS (used));\n-\n-  /* Recursively add all namespaces used.  */\n-  for (t = DECL_NAMESPACE_USING (used); t; t = TREE_CHAIN (t))\n-    /* indirect usage */\n-    add_using_namespace (user, TREE_PURPOSE (t), 1);\n-\n-  /* Tell everyone using us about the new used namespaces.  */\n-  for (t = DECL_NAMESPACE_USERS (user); t; t = TREE_CHAIN (t))\n-    add_using_namespace (TREE_PURPOSE (t), used, 1);\n-  timevar_pop (TV_NAME_LOOKUP);\n-}\n-\n-/* Combines two sets of overloaded functions into an OVERLOAD chain, removing\n-   duplicates.  The first list becomes the tail of the result.\n-\n-   The algorithm is O(n^2).  We could get this down to O(n log n) by\n-   doing a sort on the addresses of the functions, if that becomes\n-   necessary.  */\n-\n-static tree\n-merge_functions (tree s1, tree s2)\n-{\n-  for (; s2; s2 = OVL_NEXT (s2))\n-    {\n-      tree fn2 = OVL_CURRENT (s2);\n-      tree fns1;\n-\n-      for (fns1 = s1; fns1; fns1 = OVL_NEXT (fns1))\n-\t{\n-\t  tree fn1 = OVL_CURRENT (fns1);\n-\n-\t  /* If the function from S2 is already in S1, there is no\n-\t     need to add it again.  For `extern \"C\"' functions, we\n-\t     might have two FUNCTION_DECLs for the same function, in\n-\t     different namespaces; again, we only need one of them.  */\n-\t  if (fn1 == fn2 \n-\t      || (DECL_EXTERN_C_P (fn1) && DECL_EXTERN_C_P (fn2)\n-\t\t  && DECL_NAME (fn1) == DECL_NAME (fn2)))\n-\t    break;\n-\t}\n-      \n-      /* If we exhausted all of the functions in S1, FN2 is new.  */\n-      if (!fns1)\n-\ts1 = build_overload (fn2, s1);\n-    }\n-  return s1;\n-}\n-\n-/* This should return an error not all definitions define functions.\n-   It is not an error if we find two functions with exactly the\n-   same signature, only if these are selected in overload resolution.\n-   old is the current set of bindings, new the freshly-found binding.\n-   XXX Do we want to give *all* candidates in case of ambiguity?\n-   XXX In what way should I treat extern declarations?\n-   XXX I don't want to repeat the entire duplicate_decls here */\n-\n-static cxx_binding *\n-ambiguous_decl (tree name, cxx_binding *old, cxx_binding *new, int flags)\n-{\n-  tree val, type;\n-  my_friendly_assert (old != NULL, 393);\n-  /* Copy the value.  */\n-  val = new->value;\n-  if (val)\n-    switch (TREE_CODE (val))\n-      {\n-      case TEMPLATE_DECL:\n-        /* If we expect types or namespaces, and not templates,\n-           or this is not a template class.  */\n-        if (LOOKUP_QUALIFIERS_ONLY (flags)\n-            && !DECL_CLASS_TEMPLATE_P (val))\n-          val = NULL_TREE;\n-        break;\n-      case TYPE_DECL:\n-        if (LOOKUP_NAMESPACES_ONLY (flags))\n-          val = NULL_TREE;\n-        break;\n-      case NAMESPACE_DECL:\n-        if (LOOKUP_TYPES_ONLY (flags))\n-          val = NULL_TREE;\n-        break;\n-      case FUNCTION_DECL:\n-        /* Ignore built-in functions that are still anticipated.  */\n-        if (LOOKUP_QUALIFIERS_ONLY (flags) || DECL_ANTICIPATED (val))\n-          val = NULL_TREE;\n-        break;\n-      default:\n-        if (LOOKUP_QUALIFIERS_ONLY (flags))\n-          val = NULL_TREE;\n-      }\n-        \n-  if (!old->value)\n-    old->value = val;\n-  else if (val && val != old->value)\n-    {\n-      if (is_overloaded_fn (old->value) && is_overloaded_fn (val))\n-        old->value = merge_functions (old->value, val);\n-      else\n-\t{\n-\t  /* Some declarations are functions, some are not.  */\n-          if (flags & LOOKUP_COMPLAIN)\n-            {\n-\t      /* If we've already given this error for this lookup,\n-\t\t old->value is error_mark_node, so let's not\n-\t\t repeat ourselves.  */\n-\t      if (old->value != error_mark_node)\n-\t\t{\n-\t\t  error (\"use of `%D' is ambiguous\", name);\n-\t\t  cp_error_at (\"  first declared as `%#D' here\",\n-\t\t\t       old->value);\n-\t\t}\n-              cp_error_at (\"  also declared as `%#D' here\", val);\n-            }\n-\t  old->value = error_mark_node;\n-\t}\n-    }\n-  /* ... and copy the type.  */\n-  type = new->type;\n-  if (LOOKUP_NAMESPACES_ONLY (flags))\n-    type = NULL_TREE;\n-  if (!old->type)\n-    old->type = type;\n-  else if (type && old->type != type)\n-    {\n-      if (flags & LOOKUP_COMPLAIN)\n-        {\n-          error (\"`%D' denotes an ambiguous type\",name);\n-          error (\"%J  first type here\", TYPE_MAIN_DECL (old->type));\n-          error (\"%J  other type here\", TYPE_MAIN_DECL (type));\n-        }\n-    }\n-  return old;\n-}\n-\n-/* Subroutine of unualified_namespace_lookup:\n-   Add the bindings of NAME in used namespaces to VAL.\n-   We are currently looking for names in namespace SCOPE, so we\n-   look through USINGS for using-directives of namespaces\n-   which have SCOPE as a common ancestor with the current scope.\n-   Returns false on errors.  */\n-\n-bool\n-lookup_using_namespace (tree name, cxx_binding *val, tree usings, tree scope,\n-                        int flags, tree *spacesp)\n-{\n-  tree iter;\n-  timevar_push (TV_NAME_LOOKUP);\n-  /* Iterate over all used namespaces in current, searching for using\n-     directives of scope.  */\n-  for (iter = usings; iter; iter = TREE_CHAIN (iter))\n-    if (TREE_VALUE (iter) == scope)\n-      {\n-        tree used = ORIGINAL_NAMESPACE (TREE_PURPOSE (iter));\n-        cxx_binding *val1 =\n-          cxx_scope_find_binding_for_name (NAMESPACE_LEVEL (used), name);\n-        if (spacesp)\n-          *spacesp = tree_cons (used, NULL_TREE, *spacesp);\n-        /* Resolve ambiguities.  */\n-        if (val1)\n-          val = ambiguous_decl (name, val, val1, flags);\n-      }\n-  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, val->value != error_mark_node);\n-}\n-\n-/* [namespace.qual]\n-   Accepts the NAME to lookup and its qualifying SCOPE.\n-   Returns the name/type pair found into the cxx_binding *RESULT,\n-   or false on error.  */\n-\n-bool\n-qualified_lookup_using_namespace (tree name, tree scope, cxx_binding *result,\n-                                  int flags)\n-{\n-  /* Maintain a list of namespaces visited...  */\n-  tree seen = NULL_TREE;\n-  /* ... and a list of namespace yet to see.  */\n-  tree todo = NULL_TREE;\n-  tree usings;\n-  timevar_push (TV_NAME_LOOKUP);\n-  /* Look through namespace aliases.  */\n-  scope = ORIGINAL_NAMESPACE (scope);\n-  while (scope && result->value != error_mark_node)\n-    {\n-      cxx_binding *binding =\n-        cxx_scope_find_binding_for_name (NAMESPACE_LEVEL (scope), name);\n-      seen = tree_cons (scope, NULL_TREE, seen);\n-      if (binding)\n-        result = ambiguous_decl (name, result, binding, flags);\n-      if (!result->value && !result->type)\n-\t/* Consider using directives.  */\n-\tfor (usings = DECL_NAMESPACE_USING (scope); usings;\n-\t     usings = TREE_CHAIN (usings))\n-\t  /* If this was a real directive, and we have not seen it.  */\n-\t  if (!TREE_INDIRECT_USING (usings)\n-\t      && !purpose_member (TREE_PURPOSE (usings), seen))\n-\t    todo = tree_cons (TREE_PURPOSE (usings), NULL_TREE, todo);\n-      if (todo)\n-\t{\n-\t  scope = TREE_PURPOSE (todo);\n-\t  todo = TREE_CHAIN (todo);\n-\t}\n-      else\n-\tscope = NULL_TREE; /* If there never was a todo list.  */\n-    }\n-  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, result->value != error_mark_node);\n-}\n-\n-/* [namespace.memdef]/2 */\n-\n-/* Set the context of a declaration to scope. Complain if we are not\n-   outside scope.  */\n-\n-void\n-set_decl_namespace (tree decl, tree scope, bool friendp)\n-{\n-  tree old;\n-  \n-  /* Get rid of namespace aliases.  */\n-  scope = ORIGINAL_NAMESPACE (scope);\n-  \n-  /* It is ok for friends to be qualified in parallel space.  */\n-  if (!friendp && !is_ancestor (current_namespace, scope))\n-    error (\"declaration of `%D' not in a namespace surrounding `%D'\",\n-\t      decl, scope);\n-  DECL_CONTEXT (decl) = FROB_CONTEXT (scope);\n-  if (scope != current_namespace)\n-    {\n-      /* See whether this has been declared in the namespace.  */\n-      old = namespace_binding (DECL_NAME (decl), scope);\n-      if (!old)\n-\t/* No old declaration at all.  */\n-\tgoto complain;\n-      /* A template can be explicitly specialized in any namespace.  */\n-      if (processing_explicit_instantiation)\n-\treturn;\n-      if (!is_overloaded_fn (decl))\n-\t/* Don't compare non-function decls with decls_match here,\n-\t   since it can't check for the correct constness at this\n-\t   point. pushdecl will find those errors later.  */\n-\treturn;\n-      /* Since decl is a function, old should contain a function decl.  */\n-      if (!is_overloaded_fn (old))\n-\tgoto complain;\n-      if (processing_template_decl || processing_specialization)\n-\t/* We have not yet called push_template_decl to turn a\n-\t   FUNCTION_DECL into a TEMPLATE_DECL, so the declarations\n-\t   won't match.  But, we'll check later, when we construct the\n-\t   template.  */\n-\treturn;\n-      if (is_overloaded_fn (old))\n-\t{\n-\t  for (; old; old = OVL_NEXT (old))\n-\t    if (decls_match (decl, OVL_CURRENT (old)))\n-\t      return;\n-\t}\n-      else\n-\tif (decls_match (decl, old))\n-\t  return;\n-    }\n-  else\n-    return;\n- complain:\n-  error (\"`%D' should have been declared inside `%D'\",\n-\t    decl, scope);\n-} \n-\n-/* Compute the namespace where a declaration is defined.  */\n-\n-static tree\n-decl_namespace (tree decl)\n-{\n-  timevar_push (TV_NAME_LOOKUP);\n-  if (TYPE_P (decl))\n-    decl = TYPE_STUB_DECL (decl);\n-  while (DECL_CONTEXT (decl))\n-    {\n-      decl = DECL_CONTEXT (decl);\n-      if (TREE_CODE (decl) == NAMESPACE_DECL)\n-\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, decl);\n-      if (TYPE_P (decl))\n-\tdecl = TYPE_STUB_DECL (decl);\n-      my_friendly_assert (DECL_P (decl), 390);\n-    }\n-\n-  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, global_namespace);\n-}\n-\n-/* Return the namespace where the current declaration is declared.  */\n-\n-tree\n-current_decl_namespace (void)\n-{\n-  tree result;\n-  /* If we have been pushed into a different namespace, use it.  */\n-  if (decl_namespace_list)\n-    return TREE_PURPOSE (decl_namespace_list);\n-\n-  if (current_class_type)\n-    result = decl_namespace (TYPE_STUB_DECL (current_class_type));\n-  else if (current_function_decl)\n-    result = decl_namespace (current_function_decl);\n-  else \n-    result = current_namespace;\n-  return result;\n-}\n-\n-/* Temporarily set the namespace for the current declaration.  */\n-\n-void\n-push_decl_namespace (tree decl)\n-{\n-  if (TREE_CODE (decl) != NAMESPACE_DECL)\n-    decl = decl_namespace (decl);\n-  decl_namespace_list = tree_cons (ORIGINAL_NAMESPACE (decl),\n-                                   NULL_TREE, decl_namespace_list);\n-}\n-\n-void\n-pop_decl_namespace (void)\n-{\n-  decl_namespace_list = TREE_CHAIN (decl_namespace_list);\n-}\n-\n-/* Enter a class or namespace scope.  */\n-\n-void\n-push_scope (tree t)\n-{\n-  if (TREE_CODE (t) == NAMESPACE_DECL)\n-    push_decl_namespace (t);\n-  else if CLASS_TYPE_P (t)\n-    push_nested_class (t);\n-}\n-\n-/* Leave scope pushed by push_scope.  */\n-\n-void\n-pop_scope (tree t)\n-{\n-  if (TREE_CODE (t) == NAMESPACE_DECL)\n-    pop_decl_namespace ();\n-  else if CLASS_TYPE_P (t)\n-    pop_nested_class ();\n-}\n-\n-/* [basic.lookup.koenig] */\n-/* A nonzero return value in the functions below indicates an error.  */\n-\n-struct arg_lookup\n-{\n-  tree name;\n-  tree namespaces;\n-  tree classes;\n-  tree functions;\n-};\n-\n-static bool arg_assoc (struct arg_lookup*, tree);\n-static bool arg_assoc_args (struct arg_lookup*, tree);\n-static bool arg_assoc_type (struct arg_lookup*, tree);\n-static bool add_function (struct arg_lookup *, tree);\n-static bool arg_assoc_namespace (struct arg_lookup *, tree);\n-static bool arg_assoc_class (struct arg_lookup *, tree);\n-static bool arg_assoc_template_arg (struct arg_lookup*, tree);\n-\n-/* Add a function to the lookup structure.\n-   Returns true on error.  */\n-\n-static bool\n-add_function (struct arg_lookup *k, tree fn)\n-{\n-  /* We used to check here to see if the function was already in the list,\n-     but that's O(n^2), which is just too expensive for function lookup.\n-     Now we deal with the occasional duplicate in joust.  In doing this, we\n-     assume that the number of duplicates will be small compared to the\n-     total number of functions being compared, which should usually be the\n-     case.  */\n-\n-  /* We must find only functions, or exactly one non-function.  */\n-  if (!k->functions) \n-    k->functions = fn;\n-  else if (fn == k->functions)\n-    ;\n-  else if (is_overloaded_fn (k->functions) && is_overloaded_fn (fn))\n-    k->functions = build_overload (fn, k->functions);\n-  else\n-    {\n-      tree f1 = OVL_CURRENT (k->functions);\n-      tree f2 = fn;\n-      if (is_overloaded_fn (f1))\n-\t{\n-\t  fn = f1; f1 = f2; f2 = fn;\n-\t}\n-      cp_error_at (\"`%D' is not a function,\", f1);\n-      cp_error_at (\"  conflict with `%D'\", f2);\n-      error (\"  in call to `%D'\", k->name);\n-      return true;\n-    }\n-\n-  return false;\n-}\n-\n-/* Add functions of a namespace to the lookup structure.\n-   Returns true on error.  */\n-\n-static bool\n-arg_assoc_namespace (struct arg_lookup *k, tree scope)\n-{\n-  tree value;\n-\n-  if (purpose_member (scope, k->namespaces))\n-    return 0;\n-  k->namespaces = tree_cons (scope, NULL_TREE, k->namespaces);\n-  \n-  value = namespace_binding (k->name, scope);\n-  if (!value)\n-    return false;\n-\n-  for (; value; value = OVL_NEXT (value))\n-    if (add_function (k, OVL_CURRENT (value)))\n-      return true;\n-  \n-  return false;\n-}\n-\n-/* Adds everything associated with a template argument to the lookup\n-   structure.  Returns true on error.  */\n-\n-static bool\n-arg_assoc_template_arg (struct arg_lookup *k, tree arg)\n-{\n-  /* [basic.lookup.koenig]\n-\n-     If T is a template-id, its associated namespaces and classes are\n-     ... the namespaces and classes associated with the types of the\n-     template arguments provided for template type parameters\n-     (excluding template template parameters); the namespaces in which\n-     any template template arguments are defined; and the classes in\n-     which any member templates used as template template arguments\n-     are defined.  [Note: non-type template arguments do not\n-     contribute to the set of associated namespaces.  ]  */\n-\n-  /* Consider first template template arguments.  */\n-  if (TREE_CODE (arg) == TEMPLATE_TEMPLATE_PARM\n-      || TREE_CODE (arg) == UNBOUND_CLASS_TEMPLATE)\n-    return false;\n-  else if (TREE_CODE (arg) == TEMPLATE_DECL)\n-    {\n-      tree ctx = CP_DECL_CONTEXT (arg);\n-\n-      /* It's not a member template.  */\n-      if (TREE_CODE (ctx) == NAMESPACE_DECL)\n-        return arg_assoc_namespace (k, ctx);\n-      /* Otherwise, it must be member template.  */\n-      else \n-        return arg_assoc_class (k, ctx);\n-    }\n-  /* It's not a template template argument, but it is a type template\n-     argument.  */\n-  else if (TYPE_P (arg))\n-    return arg_assoc_type (k, arg);\n-  /* It's a non-type template argument.  */\n-  else\n-    return false;\n-}\n-\n-/* Adds everything associated with class to the lookup structure.\n-   Returns true on error.  */\n-\n-static bool\n-arg_assoc_class (struct arg_lookup *k, tree type)\n-{\n-  tree list, friends, context;\n-  int i;\n-  \n-  /* Backend build structures, such as __builtin_va_list, aren't\n-     affected by all this.  */\n-  if (!CLASS_TYPE_P (type))\n-    return false;\n-\n-  if (purpose_member (type, k->classes))\n-    return false;\n-  k->classes = tree_cons (type, NULL_TREE, k->classes);\n-  \n-  context = decl_namespace (TYPE_MAIN_DECL (type));\n-  if (arg_assoc_namespace (k, context))\n-    return true;\n-  \n-  /* Process baseclasses.  */\n-  for (i = 0; i < CLASSTYPE_N_BASECLASSES (type); i++)\n-    if (arg_assoc_class (k, TYPE_BINFO_BASETYPE (type, i)))\n-      return true;\n-  \n-  /* Process friends.  */\n-  for (list = DECL_FRIENDLIST (TYPE_MAIN_DECL (type)); list; \n-       list = TREE_CHAIN (list))\n-    if (k->name == FRIEND_NAME (list))\n-      for (friends = FRIEND_DECLS (list); friends; \n-\t   friends = TREE_CHAIN (friends))\n-\t/* Only interested in global functions with potentially hidden\n-           (i.e. unqualified) declarations.  */\n-\tif (CP_DECL_CONTEXT (TREE_VALUE (friends)) == context)\n-\t  if (add_function (k, TREE_VALUE (friends)))\n-\t    return true;\n-\n-  /* Process template arguments.  */\n-  if (CLASSTYPE_TEMPLATE_INFO (type))\n-    {\n-      list = INNERMOST_TEMPLATE_ARGS (CLASSTYPE_TI_ARGS (type));\n-      for (i = 0; i < TREE_VEC_LENGTH (list); ++i) \n-        arg_assoc_template_arg (k, TREE_VEC_ELT (list, i));\n-    }\n-\n-  return false;\n-}\n-\n-/* Adds everything associated with a given type.\n-   Returns 1 on error.  */\n-\n-static bool\n-arg_assoc_type (struct arg_lookup *k, tree type)\n-{\n-  /* As we do not get the type of non-type dependent expressions\n-     right, we can end up with such things without a type.  */\n-  if (!type)\n-    return false;\n-\n-  if (TYPE_PTRMEM_P (type))\n-    {\n-      /* Pointer to member: associate class type and value type.  */\n-      if (arg_assoc_type (k, TYPE_PTRMEM_CLASS_TYPE (type)))\n-\treturn true;\n-      return arg_assoc_type (k, TYPE_PTRMEM_POINTED_TO_TYPE (type));\n-    }\n-  else switch (TREE_CODE (type))\n-    {\n-    case ERROR_MARK:\n-      return false;\n-    case VOID_TYPE:\n-    case INTEGER_TYPE:\n-    case REAL_TYPE:\n-    case COMPLEX_TYPE:\n-    case VECTOR_TYPE:\n-    case CHAR_TYPE:\n-    case BOOLEAN_TYPE:\n-      return false;\n-    case RECORD_TYPE:\n-      if (TYPE_PTRMEMFUNC_P (type))\n-\treturn arg_assoc_type (k, TYPE_PTRMEMFUNC_FN_TYPE (type));\n-      return arg_assoc_class (k, type);\n-    case POINTER_TYPE:\n-    case REFERENCE_TYPE:\n-    case ARRAY_TYPE:\n-      return arg_assoc_type (k, TREE_TYPE (type));\n-    case UNION_TYPE:\n-    case ENUMERAL_TYPE:\n-      return arg_assoc_namespace (k, decl_namespace (TYPE_MAIN_DECL (type)));\n-    case METHOD_TYPE:\n-      /* The basetype is referenced in the first arg type, so just\n-\t fall through.  */\n-    case FUNCTION_TYPE:\n-      /* Associate the parameter types.  */\n-      if (arg_assoc_args (k, TYPE_ARG_TYPES (type)))\n-\treturn true;\n-      /* Associate the return type.  */\n-      return arg_assoc_type (k, TREE_TYPE (type));\n-    case TEMPLATE_TYPE_PARM:\n-    case BOUND_TEMPLATE_TEMPLATE_PARM:\n-      return false;\n-    case TYPENAME_TYPE:\n-      return false;\n-    case LANG_TYPE:\n-      if (type == unknown_type_node)\n-\treturn false;\n-      /* else fall through */\n-    default:\n-      abort ();\n-    }\n-  return false;\n-}\n-\n-/* Adds everything associated with arguments.  Returns true on error.  */\n-\n-static bool\n-arg_assoc_args (struct arg_lookup *k, tree args)\n-{\n-  for (; args; args = TREE_CHAIN (args))\n-    if (arg_assoc (k, TREE_VALUE (args)))\n-      return true;\n-  return false;\n-}\n-\n-/* Adds everything associated with a given tree_node.  Returns 1 on error.  */\n-\n-static bool\n-arg_assoc (struct arg_lookup *k, tree n)\n-{\n-  if (n == error_mark_node)\n-    return false;\n-\n-  if (TYPE_P (n))\n-    return arg_assoc_type (k, n);\n-\n-  if (! type_unknown_p (n))\n-    return arg_assoc_type (k, TREE_TYPE (n));\n-\n-  if (TREE_CODE (n) == ADDR_EXPR)\n-    n = TREE_OPERAND (n, 0);\n-  if (TREE_CODE (n) == COMPONENT_REF)\n-    n = TREE_OPERAND (n, 1);\n-  if (TREE_CODE (n) == OFFSET_REF)\n-    n = TREE_OPERAND (n, 1);\n-  while (TREE_CODE (n) == TREE_LIST)\n-    n = TREE_VALUE (n);\n-  if (TREE_CODE (n) == BASELINK)\n-    n = BASELINK_FUNCTIONS (n);\n-\n-  if (TREE_CODE (n) == FUNCTION_DECL)\n-    return arg_assoc_type (k, TREE_TYPE (n));\n-  if (TREE_CODE (n) == TEMPLATE_ID_EXPR)\n-    {\n-      /* [basic.lookup.koenig]\n-\n-\t If T is a template-id, its associated namespaces and classes\n-\t are the namespace in which the template is defined; for\n-\t member templates, the member template's class...  */\n-      tree template = TREE_OPERAND (n, 0);\n-      tree args = TREE_OPERAND (n, 1);\n-      tree ctx;\n-      int ix;\n-\n-      if (TREE_CODE (template) == COMPONENT_REF)\n-        template = TREE_OPERAND (template, 1);\n-      \n-      /* First, the template.  There may actually be more than one if\n-\t this is an overloaded function template.  But, in that case,\n-\t we only need the first; all the functions will be in the same\n-\t namespace.  */\n-      template = OVL_CURRENT (template);\n-\n-      ctx = CP_DECL_CONTEXT (template);\n-       \n-      if (TREE_CODE (ctx) == NAMESPACE_DECL)\n-\t{\n-\t  if (arg_assoc_namespace (k, ctx) == 1)\n-\t    return true;\n-\t}\n-      /* It must be a member template.  */\n-      else if (arg_assoc_class (k, ctx) == 1)\n-\treturn true;\n-\n-      /* Now the arguments.  */\n-      for (ix = TREE_VEC_LENGTH (args); ix--;)\n-\tif (arg_assoc_template_arg (k, TREE_VEC_ELT (args, ix)) == 1)\n-\t  return true;\n-    }\n-  else\n-    {\n-      my_friendly_assert (TREE_CODE (n) == OVERLOAD, 980715);\n-      \n-      for (; n; n = OVL_CHAIN (n))\n-\tif (arg_assoc_type (k, TREE_TYPE (OVL_FUNCTION (n))))\n-\t  return true;\n-    }\n-\n-  return false;\n-}\n-\n-/* Performs Koenig lookup depending on arguments, where fns\n-   are the functions found in normal lookup.  */\n-\n-tree\n-lookup_arg_dependent (tree name, tree fns, tree args)\n-{\n-  struct arg_lookup k;\n-  tree fn = NULL_TREE;\n-\n-  timevar_push (TV_NAME_LOOKUP);\n-  k.name = name;\n-  k.functions = fns;\n-  k.classes = NULL_TREE;\n-\n-  /* Note that we've already looked at some namespaces during normal\n-     unqualified lookup, unless we found a decl in function scope.  */\n-  if (fns)\n-    fn = OVL_CURRENT (fns);\n-  if (fn && TREE_CODE (fn) == FUNCTION_DECL && DECL_LOCAL_FUNCTION_P (fn))\n-    k.namespaces = NULL_TREE;\n-  else\n-    unqualified_namespace_lookup (name, 0, &k.namespaces);\n-\n-  arg_assoc_args (&k, args);\n-  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, k.functions);\n-}\n-\n-/* Process a namespace-alias declaration.  */\n-\n-void\n-do_namespace_alias (tree alias, tree namespace)\n-{\n-  if (TREE_CODE (namespace) != NAMESPACE_DECL)\n-    {\n-      /* The parser did not find it, so it's not there.  */\n-      error (\"unknown namespace `%D'\", namespace);\n-      return;\n-    }\n-\n-  namespace = ORIGINAL_NAMESPACE (namespace);\n-\n-  /* Build the alias.  */\n-  alias = build_lang_decl (NAMESPACE_DECL, alias, void_type_node);     \n-  DECL_NAMESPACE_ALIAS (alias) = namespace;\n-  DECL_EXTERNAL (alias) = 1;\n-  pushdecl (alias);\n-}\n-\n-/* Check a non-member using-declaration. Return the name and scope\n-   being used, and the USING_DECL, or NULL_TREE on failure.  */\n-\n-static tree\n-validate_nonmember_using_decl (tree decl, tree *scope, tree *name)\n-{\n-  *scope = global_namespace;\n-  *name = NULL_TREE;\n-\n-  if (TREE_CODE (decl) == TEMPLATE_ID_EXPR)\n-    {\n-      *name = TREE_OPERAND (decl, 0);\n-      /* 7.3.3/5\n-\t   A using-declaration shall not name a template-id.  */\n-      error (\"a using-declaration cannot specify a template-id.  Try `using %D'\", *name);\n-      return NULL_TREE;\n-    }\n-\n-  if (TREE_CODE (decl) == NAMESPACE_DECL)\n-    {\n-      error (\"namespace `%D' not allowed in using-declaration\", decl);\n-      return NULL_TREE;\n-    }\n-\n-  if (TREE_CODE (decl) == SCOPE_REF)\n-    {\n-      /* It's a nested name with template parameter dependent scope.\n-\t This can only be using-declaration for class member.  */\n-      error (\"`%T' is not a namespace\", TREE_OPERAND (decl, 0));\n-      return NULL_TREE;\n-    }\n-\n-  if (is_overloaded_fn (decl))\n-    decl = get_first_fn (decl);\n-\n-  my_friendly_assert (DECL_P (decl), 20020908);\n-\n-  if (TREE_CODE (decl) == CONST_DECL)\n-    /* Enumeration constants to not have DECL_CONTEXT set.  */\n-    *scope = TYPE_CONTEXT (TREE_TYPE (decl));\n-  else\n-    *scope = DECL_CONTEXT (decl);\n-  if (!*scope)\n-    *scope = global_namespace;\n-\n-  /* [namespace.udecl]\n-       A using-declaration for a class member shall be a\n-       member-declaration.  */\n-  if (TYPE_P (*scope))\n-    {\n-      error (\"`%T' is not a namespace\", *scope);\n-      return NULL_TREE;\n-    }\n-  *name = DECL_NAME (decl);\n-  /* Make a USING_DECL.  */\n-  return push_using_decl (*scope, *name);\n-}\n-\n-/* Process local and global using-declarations.  */\n-\n-static void\n-do_nonmember_using_decl (tree scope, tree name, tree oldval, tree oldtype,\n-                         tree *newval, tree *newtype)\n-{\n-  cxx_binding decls;\n-\n-  *newval = *newtype = NULL_TREE;\n-  cxx_binding_clear (&decls);\n-  if (!qualified_lookup_using_namespace (name, scope, &decls, 0))\n-    /* Lookup error */\n-    return;\n-\n-  if (!decls.value && !decls.type)\n-    {\n-      error (\"`%D' not declared\", name);\n-      return;\n-    }\n-\n-  /* Check for using functions.  */\n-  if (decls.value && is_overloaded_fn (decls.value))\n-    {\n-      tree tmp, tmp1;\n-\n-      if (oldval && !is_overloaded_fn (oldval))\n-\t{\n-\t  if (!DECL_IMPLICIT_TYPEDEF_P (oldval))\n-\t    error (\"`%D' is already declared in this scope\", name);\n-\t  oldval = NULL_TREE;\n-\t}\n-\n-      *newval = oldval;\n-      for (tmp = decls.value; tmp; tmp = OVL_NEXT (tmp))\n-\t{\n-\t  tree new_fn = OVL_CURRENT (tmp);\n-\n-\t  /* [namespace.udecl]\n-\n-\t     If a function declaration in namespace scope or block\n-\t     scope has the same name and the same parameter types as a\n-\t     function introduced by a using declaration the program is\n-\t     ill-formed.  */\n-\t  for (tmp1 = oldval; tmp1; tmp1 = OVL_NEXT (tmp1))\n-\t    {\n-\t      tree old_fn = OVL_CURRENT (tmp1);\n-\n-              if (new_fn == old_fn)\n-                /* The function already exists in the current namespace.  */\n-                break;\n-\t      else if (OVL_USED (tmp1))\n-\t        continue; /* this is a using decl */\n-\t      else if (compparms (TYPE_ARG_TYPES (TREE_TYPE (new_fn)),\n-\t\t  \t\t  TYPE_ARG_TYPES (TREE_TYPE (old_fn))))\n-\t\t{\n-\t          /* There was already a non-using declaration in\n-\t\t     this scope with the same parameter types. If both\n-\t             are the same extern \"C\" functions, that's ok.  */\n-                  if (decls_match (new_fn, old_fn))\n-\t\t    {\n-\t\t      /* If the OLD_FN was a builtin, there is now a\n-\t\t\t real declaration.  */\n-\t\t      if (DECL_ANTICIPATED (old_fn))\n-\t\t\tDECL_ANTICIPATED (old_fn) = 0;\n-\t\t      break;\n-\t\t    }\n-\t\t  else if (!DECL_ANTICIPATED (old_fn))\n-\t\t    {\n-\t\t      /* If the OLD_FN was really declared, the\n-\t\t\t declarations don't match.  */\n-\t\t      error (\"`%D' is already declared in this scope\", name);\n-\t\t      break;\n-\t\t    }\n-\n-\t\t  /* If the OLD_FN was not really there, just ignore\n-\t\t     it and keep going.  */\n-\t\t}\n-\t    }\n-\n-\t  /* If we broke out of the loop, there's no reason to add\n-\t     this function to the using declarations for this\n-\t     scope.  */\n-\t  if (tmp1)\n-\t    continue;\n-\t    \n-\t  *newval = build_overload (OVL_CURRENT (tmp), *newval);\n-\t  if (TREE_CODE (*newval) != OVERLOAD)\n-\t    *newval = ovl_cons (*newval, NULL_TREE);\n-\t  OVL_USED (*newval) = 1;\n-\t}\n-    }\n-  else \n-    {\n-      *newval = decls.value;\n-      if (oldval && !decls_match (*newval, oldval))\n-\terror (\"`%D' is already declared in this scope\", name);\n-    }\n-\n-  *newtype = decls.type;\n-  if (oldtype && *newtype && !same_type_p (oldtype, *newtype))\n-    {\n-      error (\"using declaration `%D' introduced ambiguous type `%T'\",\n-\t\tname, oldtype);\n-      return;\n-    }\n-}\n-\n-/* Process a using-declaration not appearing in class or local scope.  */\n-\n-void\n-do_toplevel_using_decl (tree decl)\n-{\n-  tree scope, name;\n-  tree oldval, oldtype, newval, newtype;\n-  cxx_binding *binding;\n-\n-  decl = validate_nonmember_using_decl (decl, &scope, &name);\n-  if (decl == NULL_TREE)\n-    return;\n-  \n-  binding = binding_for_name (NAMESPACE_LEVEL (current_namespace), name);\n-\n-  oldval = binding->value;\n-  oldtype = binding->type;\n-\n-  do_nonmember_using_decl (scope, name, oldval, oldtype, &newval, &newtype);\n-\n-  /* Copy declarations found.  */\n-  if (newval)\n-    binding->value = newval;\n-  if (newtype)\n-    binding->type = newtype;\n-  return;\n-}\n-\n-/* Process a using-declaration at function scope.  */\n-\n-void\n-do_local_using_decl (tree decl)\n-{\n-  tree scope, name;\n-  tree oldval, oldtype, newval, newtype;\n-\n-  decl = validate_nonmember_using_decl (decl, &scope, &name);\n-  if (decl == NULL_TREE)\n-    return;\n-\n-  if (building_stmt_tree ()\n-      && at_function_scope_p ())\n-    add_decl_stmt (decl);\n-\n-  oldval = lookup_name_current_level (name);\n-  oldtype = lookup_type_current_level (name);\n-\n-  do_nonmember_using_decl (scope, name, oldval, oldtype, &newval, &newtype);\n-\n-  if (newval)\n-    {\n-      if (is_overloaded_fn (newval))\n-\t{\n-\t  tree fn, term;\n-\n-\t  /* We only need to push declarations for those functions\n-\t     that were not already bound in the current level.\n-\t     The old value might be NULL_TREE, it might be a single\n-\t     function, or an OVERLOAD.  */\n-\t  if (oldval && TREE_CODE (oldval) == OVERLOAD)\n-\t    term = OVL_FUNCTION (oldval);\n-\t  else\n-\t    term = oldval;\n-\t  for (fn = newval; fn && OVL_CURRENT (fn) != term; \n-\t       fn = OVL_NEXT (fn))\n-\t    push_overloaded_decl (OVL_CURRENT (fn), \n-\t\t\t\t  PUSH_LOCAL | PUSH_USING);\n-\t}\n-      else\n-\tpush_local_binding (name, newval, PUSH_USING);\n-    }\n-  if (newtype)\n-    set_identifier_type_value (name, newtype);\n-}\n-\n-tree\n-do_class_using_decl (tree decl)\n-{\n-  tree name, value, scope, type;\n-  \n-  if (TREE_CODE (decl) != SCOPE_REF\n-      || !TREE_OPERAND (decl, 0)\n-      || !TYPE_P (TREE_OPERAND (decl, 0)))\n-    {\n-      error (\"using-declaration for non-member at class scope\");\n-      return NULL_TREE;\n-    }\n-  scope = TREE_OPERAND (decl, 0);\n-  name = TREE_OPERAND (decl, 1);\n-  if (TREE_CODE (name) == BIT_NOT_EXPR)\n-    {\n-      error (\"using-declaration cannot name destructor\");\n-      return NULL_TREE;\n-    }\n-  if (TREE_CODE (name) == TYPE_DECL)\n-    name = DECL_NAME (name);\n-  else if (TREE_CODE (name) == TEMPLATE_DECL)\n-     name = DECL_NAME (name);\n-  else if (BASELINK_P (name))\n-    {\n-      tree fns = BASELINK_FUNCTIONS (name);\n-      name = DECL_NAME (get_first_fn (fns));\n-    }\n-\n-  my_friendly_assert (TREE_CODE (name) == IDENTIFIER_NODE, 980716);\n-\n-  /* Dependent using decls have a NULL type, non-dependent ones have a\n-     void type.  */\n-  type = dependent_type_p (scope) ? NULL_TREE : void_type_node;\n-  value = build_lang_decl (USING_DECL, name, type);\n-  DECL_INITIAL (value) = scope;\n-  return value;\n-}\n-\n-/* Process a using-directive.  */\n-\n-void\n-do_using_directive (tree namespace)\n-{\n-  if (building_stmt_tree ())\n-    add_stmt (build_stmt (USING_STMT, namespace));\n   \n-  /* using namespace A::B::C; */\n-  if (TREE_CODE (namespace) == SCOPE_REF)\n-      namespace = TREE_OPERAND (namespace, 1);\n-  if (TREE_CODE (namespace) == IDENTIFIER_NODE)\n-    {\n-      /* Lookup in lexer did not find a namespace.  */\n-      if (!processing_template_decl)\n-\terror (\"namespace `%T' undeclared\", namespace);\n-      return;\n-    }\n-  if (TREE_CODE (namespace) != NAMESPACE_DECL)\n-    {\n-      if (!processing_template_decl)\n-\terror (\"`%T' is not a namespace\", namespace);\n-      return;\n-    }\n-  namespace = ORIGINAL_NAMESPACE (namespace);\n-  if (!toplevel_bindings_p ())\n-    push_using_directive (namespace);\n-  else\n-    /* direct usage */\n-    add_using_namespace (current_namespace, namespace, 0);\n-}\n \n void\n check_default_args (tree x)"}, {"sha": "9f4cb78e1058f3edb5d6ae1ea59043fd3ba97d77", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 1169, "deletions": 2, "changes": 1171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a167978fa119e30cca1f45f0b814b4af9db7643/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a167978fa119e30cca1f45f0b814b4af9db7643/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=5a167978fa119e30cca1f45f0b814b4af9db7643", "patch": "@@ -32,6 +32,11 @@ Boston, MA 02111-1307, USA.  */\n \n static cxx_scope *innermost_nonclass_level (void);\n static tree select_decl (cxx_binding *, int);\n+static cxx_binding *binding_for_name (cxx_scope *, tree);\n+\n+/* The :: namespace.  */\n+\n+tree global_namespace;\n \n \n /* Compute the chain index of a binding_entry given the HASH value of its\n@@ -300,6 +305,9 @@ binding_table_foreach (binding_table table, bt_foreach_proc proc, void *data)\n \n static GTY((deletable (\"\"))) cxx_binding *free_bindings;\n \n+/* Zero out a cxx_binding pointed to by B.  */\n+#define cxx_binding_clear(B) memset ((B), 0, sizeof (cxx_binding))\n+\n /* (GC)-allocate a binding object with VALUE and TYPE member initialized.  */\n \n static cxx_binding *\n@@ -1118,6 +1126,57 @@ set_identifier_type_value (tree id, tree decl)\n   set_identifier_type_value_with_scope (id, decl, current_binding_level);\n }\n \n+/* Return the name for the constructor (or destructor) for the\n+   specified class TYPE.  When given a template, this routine doesn't\n+   lose the specialization.  */\n+\n+tree\n+constructor_name_full (tree type)\n+{\n+  type = TYPE_MAIN_VARIANT (type);\n+  if (CLASS_TYPE_P (type) && TYPE_WAS_ANONYMOUS (type) \n+      && TYPE_HAS_CONSTRUCTOR (type))\n+    return DECL_NAME (OVL_CURRENT (CLASSTYPE_CONSTRUCTORS (type)));\n+  else\n+    return TYPE_IDENTIFIER (type);\n+}\n+\n+/* Return the name for the constructor (or destructor) for the\n+   specified class.  When given a template, return the plain\n+   unspecialized name.  */\n+\n+tree\n+constructor_name (tree type)\n+{\n+  tree name;\n+  name = constructor_name_full (type);\n+  if (IDENTIFIER_TEMPLATE (name))\n+    name = IDENTIFIER_TEMPLATE (name);\n+  return name;\n+}\n+\n+/* Returns TRUE if NAME is the name for the constructor for TYPE.  */\n+\n+bool\n+constructor_name_p (tree name, tree type)\n+{\n+  tree ctor_name;\n+\n+  if (!name)\n+    return false;\n+  \n+  if (TREE_CODE (name) != IDENTIFIER_NODE)\n+    return false;\n+  \n+  ctor_name = constructor_name_full (type);\n+  if (name == ctor_name)\n+    return true;\n+  if (IDENTIFIER_TEMPLATE (ctor_name)\n+      && name == IDENTIFIER_TEMPLATE (ctor_name))\n+    return true;\n+  return false;\n+}\n+\n /* Return (from the stack of) the BINDING, if any, establihsed at SCOPE.  */ \n \n static inline cxx_binding *\n@@ -1134,7 +1193,7 @@ find_binding (cxx_scope *scope, cxx_binding *binding)\n \n /* Return the binding for NAME in SCOPE, if any.  Otherwise, return NULL.  */\n \n-cxx_binding *\n+static inline cxx_binding *\n cxx_scope_find_binding_for_name (cxx_scope *scope, tree name)\n {\n   cxx_binding *b = IDENTIFIER_NAMESPACE_BINDINGS (name);\n@@ -1151,7 +1210,7 @@ cxx_scope_find_binding_for_name (cxx_scope *scope, tree name)\n /* Always returns a binding for name in scope.  If no binding is\n    found, make a new one.  */\n \n-cxx_binding *\n+static cxx_binding *\n binding_for_name (cxx_scope *scope, tree name)\n {\n   cxx_binding *result;\n@@ -1198,6 +1257,218 @@ pushdecl_with_scope (tree x, cxx_scope *level)\n   POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, x);\n }\n \n+/* Check a non-member using-declaration. Return the name and scope\n+   being used, and the USING_DECL, or NULL_TREE on failure.  */\n+\n+static tree\n+validate_nonmember_using_decl (tree decl, tree *scope, tree *name)\n+{\n+  *scope = global_namespace;\n+  *name = NULL_TREE;\n+\n+  if (TREE_CODE (decl) == TEMPLATE_ID_EXPR)\n+    {\n+      *name = TREE_OPERAND (decl, 0);\n+      /* 7.3.3/5\n+\t   A using-declaration shall not name a template-id.  */\n+      error (\"a using-declaration cannot specify a template-id.  Try `using %D'\", *name);\n+      return NULL_TREE;\n+    }\n+\n+  if (TREE_CODE (decl) == NAMESPACE_DECL)\n+    {\n+      error (\"namespace `%D' not allowed in using-declaration\", decl);\n+      return NULL_TREE;\n+    }\n+\n+  if (TREE_CODE (decl) == SCOPE_REF)\n+    {\n+      /* It's a nested name with template parameter dependent scope.\n+\t This can only be using-declaration for class member.  */\n+      error (\"`%T' is not a namespace\", TREE_OPERAND (decl, 0));\n+      return NULL_TREE;\n+    }\n+\n+  if (is_overloaded_fn (decl))\n+    decl = get_first_fn (decl);\n+\n+  my_friendly_assert (DECL_P (decl), 20020908);\n+\n+  if (TREE_CODE (decl) == CONST_DECL)\n+    /* Enumeration constants to not have DECL_CONTEXT set.  */\n+    *scope = TYPE_CONTEXT (TREE_TYPE (decl));\n+  else\n+    *scope = DECL_CONTEXT (decl);\n+  if (!*scope)\n+    *scope = global_namespace;\n+\n+  /* [namespace.udecl]\n+       A using-declaration for a class member shall be a\n+       member-declaration.  */\n+  if (TYPE_P (*scope))\n+    {\n+      error (\"`%T' is not a namespace\", *scope);\n+      return NULL_TREE;\n+    }\n+  *name = DECL_NAME (decl);\n+  /* Make a USING_DECL.  */\n+  return push_using_decl (*scope, *name);\n+}\n+\n+/* Process local and global using-declarations.  */\n+\n+static void\n+do_nonmember_using_decl (tree scope, tree name, tree oldval, tree oldtype,\n+                         tree *newval, tree *newtype)\n+{\n+  cxx_binding decls;\n+\n+  *newval = *newtype = NULL_TREE;\n+  cxx_binding_clear (&decls);\n+  if (!qualified_lookup_using_namespace (name, scope, &decls, 0))\n+    /* Lookup error */\n+    return;\n+\n+  if (!decls.value && !decls.type)\n+    {\n+      error (\"`%D' not declared\", name);\n+      return;\n+    }\n+\n+  /* Check for using functions.  */\n+  if (decls.value && is_overloaded_fn (decls.value))\n+    {\n+      tree tmp, tmp1;\n+\n+      if (oldval && !is_overloaded_fn (oldval))\n+\t{\n+\t  if (!DECL_IMPLICIT_TYPEDEF_P (oldval))\n+\t    error (\"`%D' is already declared in this scope\", name);\n+\t  oldval = NULL_TREE;\n+\t}\n+\n+      *newval = oldval;\n+      for (tmp = decls.value; tmp; tmp = OVL_NEXT (tmp))\n+\t{\n+\t  tree new_fn = OVL_CURRENT (tmp);\n+\n+\t  /* [namespace.udecl]\n+\n+\t     If a function declaration in namespace scope or block\n+\t     scope has the same name and the same parameter types as a\n+\t     function introduced by a using declaration the program is\n+\t     ill-formed.  */\n+\t  for (tmp1 = oldval; tmp1; tmp1 = OVL_NEXT (tmp1))\n+\t    {\n+\t      tree old_fn = OVL_CURRENT (tmp1);\n+\n+              if (new_fn == old_fn)\n+                /* The function already exists in the current namespace.  */\n+                break;\n+\t      else if (OVL_USED (tmp1))\n+\t        continue; /* this is a using decl */\n+\t      else if (compparms (TYPE_ARG_TYPES (TREE_TYPE (new_fn)),\n+\t\t  \t\t  TYPE_ARG_TYPES (TREE_TYPE (old_fn))))\n+\t\t{\n+\t          /* There was already a non-using declaration in\n+\t\t     this scope with the same parameter types. If both\n+\t             are the same extern \"C\" functions, that's ok.  */\n+                  if (decls_match (new_fn, old_fn))\n+\t\t    {\n+\t\t      /* If the OLD_FN was a builtin, there is now a\n+\t\t\t real declaration.  */\n+\t\t      if (DECL_ANTICIPATED (old_fn))\n+\t\t\tDECL_ANTICIPATED (old_fn) = 0;\n+\t\t      break;\n+\t\t    }\n+\t\t  else if (!DECL_ANTICIPATED (old_fn))\n+\t\t    {\n+\t\t      /* If the OLD_FN was really declared, the\n+\t\t\t declarations don't match.  */\n+\t\t      error (\"`%D' is already declared in this scope\", name);\n+\t\t      break;\n+\t\t    }\n+\n+\t\t  /* If the OLD_FN was not really there, just ignore\n+\t\t     it and keep going.  */\n+\t\t}\n+\t    }\n+\n+\t  /* If we broke out of the loop, there's no reason to add\n+\t     this function to the using declarations for this\n+\t     scope.  */\n+\t  if (tmp1)\n+\t    continue;\n+\t    \n+\t  *newval = build_overload (OVL_CURRENT (tmp), *newval);\n+\t  if (TREE_CODE (*newval) != OVERLOAD)\n+\t    *newval = ovl_cons (*newval, NULL_TREE);\n+\t  OVL_USED (*newval) = 1;\n+\t}\n+    }\n+  else \n+    {\n+      *newval = decls.value;\n+      if (oldval && !decls_match (*newval, oldval))\n+\terror (\"`%D' is already declared in this scope\", name);\n+    }\n+\n+  *newtype = decls.type;\n+  if (oldtype && *newtype && !same_type_p (oldtype, *newtype))\n+    {\n+      error (\"using declaration `%D' introduced ambiguous type `%T'\",\n+\t\tname, oldtype);\n+      return;\n+    }\n+}\n+\n+/* Process a using-declaration at function scope.  */\n+\n+void\n+do_local_using_decl (tree decl)\n+{\n+  tree scope, name;\n+  tree oldval, oldtype, newval, newtype;\n+\n+  decl = validate_nonmember_using_decl (decl, &scope, &name);\n+  if (decl == NULL_TREE)\n+    return;\n+\n+  if (building_stmt_tree ()\n+      && at_function_scope_p ())\n+    add_decl_stmt (decl);\n+\n+  oldval = lookup_name_current_level (name);\n+  oldtype = lookup_type_current_level (name);\n+\n+  do_nonmember_using_decl (scope, name, oldval, oldtype, &newval, &newtype);\n+\n+  if (newval)\n+    {\n+      if (is_overloaded_fn (newval))\n+\t{\n+\t  tree fn, term;\n+\n+\t  /* We only need to push declarations for those functions\n+\t     that were not already bound in the current level.\n+\t     The old value might be NULL_TREE, it might be a single\n+\t     function, or an OVERLOAD.  */\n+\t  if (oldval && TREE_CODE (oldval) == OVERLOAD)\n+\t    term = OVL_FUNCTION (oldval);\n+\t  else\n+\t    term = oldval;\n+\t  for (fn = newval; fn && OVL_CURRENT (fn) != term; \n+\t       fn = OVL_NEXT (fn))\n+\t    push_overloaded_decl (OVL_CURRENT (fn), \n+\t\t\t\t  PUSH_LOCAL | PUSH_USING);\n+\t}\n+      else\n+\tpush_local_binding (name, newval, PUSH_USING);\n+    }\n+  if (newtype)\n+    set_identifier_type_value (name, newtype);\n+}\n+\n /* Return the type that should be used when TYPE's name is preceded\n    by a tag such as 'struct' or 'union', or null if the name cannot\n    be used in this way.\n@@ -1378,6 +1649,60 @@ lookup_tag_reverse (tree type, tree name)\n     }\n   POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n }\n+\n+/* Returns true if ROOT (a namespace, class, or function) encloses\n+   CHILD.  CHILD may be either a class type or a namespace.  */\n+\n+bool\n+is_ancestor (tree root, tree child)\n+{\n+  my_friendly_assert ((TREE_CODE (root) == NAMESPACE_DECL\n+\t\t       || TREE_CODE (root) == FUNCTION_DECL\n+\t\t       || CLASS_TYPE_P (root)), 20030307);\n+  my_friendly_assert ((TREE_CODE (child) == NAMESPACE_DECL\n+\t\t       || CLASS_TYPE_P (child)),\n+\t\t      20030307);\n+  \n+  /* The global namespace encloses everything.  */\n+  if (root == global_namespace)\n+    return true;\n+\n+  while (true)\n+    {\n+      /* If we've run out of scopes, stop.  */\n+      if (!child)\n+\treturn false;\n+      /* If we've reached the ROOT, it encloses CHILD.  */\n+      if (root == child)\n+\treturn true;\n+      /* Go out one level.  */\n+      if (TYPE_P (child))\n+\tchild = TYPE_NAME (child);\n+      child = DECL_CONTEXT (child);\n+    }\n+}\n+\n+/* Enter a class or namespace scope.  */\n+\n+void\n+push_scope (tree t)\n+{\n+  if (TREE_CODE (t) == NAMESPACE_DECL)\n+    push_decl_namespace (t);\n+  else if CLASS_TYPE_P (t)\n+    push_nested_class (t);\n+}\n+\n+/* Leave scope pushed by push_scope.  */\n+\n+void\n+pop_scope (tree t)\n+{\n+  if (TREE_CODE (t) == NAMESPACE_DECL)\n+    pop_decl_namespace ();\n+  else if CLASS_TYPE_P (t)\n+    pop_nested_class ();\n+}\n \f\n /* Do a pushlevel for class declarations.  */\n \n@@ -1671,6 +1996,45 @@ push_class_level_binding (tree name, tree x)\n   POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, false);\n }\n \n+tree\n+do_class_using_decl (tree decl)\n+{\n+  tree name, value, scope, type;\n+  \n+  if (TREE_CODE (decl) != SCOPE_REF\n+      || !TREE_OPERAND (decl, 0)\n+      || !TYPE_P (TREE_OPERAND (decl, 0)))\n+    {\n+      error (\"using-declaration for non-member at class scope\");\n+      return NULL_TREE;\n+    }\n+  scope = TREE_OPERAND (decl, 0);\n+  name = TREE_OPERAND (decl, 1);\n+  if (TREE_CODE (name) == BIT_NOT_EXPR)\n+    {\n+      error (\"using-declaration cannot name destructor\");\n+      return NULL_TREE;\n+    }\n+  if (TREE_CODE (name) == TYPE_DECL)\n+    name = DECL_NAME (name);\n+  else if (TREE_CODE (name) == TEMPLATE_DECL)\n+     name = DECL_NAME (name);\n+  else if (BASELINK_P (name))\n+    {\n+      tree fns = BASELINK_FUNCTIONS (name);\n+      name = DECL_NAME (get_first_fn (fns));\n+    }\n+\n+  my_friendly_assert (TREE_CODE (name) == IDENTIFIER_NODE, 980716);\n+\n+  /* Dependent using decls have a NULL type, non-dependent ones have a\n+     void type.  */\n+  type = dependent_type_p (scope) ? NULL_TREE : void_type_node;\n+  value = build_lang_decl (USING_DECL, name, type);\n+  DECL_INITIAL (value) = scope;\n+  return value;\n+}\n+\n void\n set_class_shadows (tree shadows)\n {\n@@ -1710,6 +2074,103 @@ set_namespace_binding (tree name, tree scope, tree val)\n   timevar_pop (TV_NAME_LOOKUP);\n }\n \n+/* Compute the namespace where a declaration is defined.  */\n+\n+static tree\n+decl_namespace (tree decl)\n+{\n+  timevar_push (TV_NAME_LOOKUP);\n+  if (TYPE_P (decl))\n+    decl = TYPE_STUB_DECL (decl);\n+  while (DECL_CONTEXT (decl))\n+    {\n+      decl = DECL_CONTEXT (decl);\n+      if (TREE_CODE (decl) == NAMESPACE_DECL)\n+\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, decl);\n+      if (TYPE_P (decl))\n+\tdecl = TYPE_STUB_DECL (decl);\n+      my_friendly_assert (DECL_P (decl), 390);\n+    }\n+\n+  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, global_namespace);\n+}\n+\n+/* Set the context of a declaration to scope. Complain if we are not\n+   outside scope.  */\n+\n+void\n+set_decl_namespace (tree decl, tree scope, bool friendp)\n+{\n+  tree old;\n+  \n+  /* Get rid of namespace aliases.  */\n+  scope = ORIGINAL_NAMESPACE (scope);\n+  \n+  /* It is ok for friends to be qualified in parallel space.  */\n+  if (!friendp && !is_ancestor (current_namespace, scope))\n+    error (\"declaration of `%D' not in a namespace surrounding `%D'\",\n+\t      decl, scope);\n+  DECL_CONTEXT (decl) = FROB_CONTEXT (scope);\n+  if (scope != current_namespace)\n+    {\n+      /* See whether this has been declared in the namespace.  */\n+      old = namespace_binding (DECL_NAME (decl), scope);\n+      if (!old)\n+\t/* No old declaration at all.  */\n+\tgoto complain;\n+      /* A template can be explicitly specialized in any namespace.  */\n+      if (processing_explicit_instantiation)\n+\treturn;\n+      if (!is_overloaded_fn (decl))\n+\t/* Don't compare non-function decls with decls_match here,\n+\t   since it can't check for the correct constness at this\n+\t   point. pushdecl will find those errors later.  */\n+\treturn;\n+      /* Since decl is a function, old should contain a function decl.  */\n+      if (!is_overloaded_fn (old))\n+\tgoto complain;\n+      if (processing_template_decl || processing_specialization)\n+\t/* We have not yet called push_template_decl to turn a\n+\t   FUNCTION_DECL into a TEMPLATE_DECL, so the declarations\n+\t   won't match.  But, we'll check later, when we construct the\n+\t   template.  */\n+\treturn;\n+      if (is_overloaded_fn (old))\n+\t{\n+\t  for (; old; old = OVL_NEXT (old))\n+\t    if (decls_match (decl, OVL_CURRENT (old)))\n+\t      return;\n+\t}\n+      else\n+\tif (decls_match (decl, old))\n+\t  return;\n+    }\n+  else\n+    return;\n+ complain:\n+  error (\"`%D' should have been declared inside `%D'\",\n+\t    decl, scope);\n+} \n+\n+/* Return the namespace where the current declaration is declared.  */\n+\n+tree\n+current_decl_namespace (void)\n+{\n+  tree result;\n+  /* If we have been pushed into a different namespace, use it.  */\n+  if (decl_namespace_list)\n+    return TREE_PURPOSE (decl_namespace_list);\n+\n+  if (current_class_type)\n+    result = decl_namespace (TYPE_STUB_DECL (current_class_type));\n+  else if (current_function_decl)\n+    result = decl_namespace (current_function_decl);\n+  else \n+    result = current_namespace;\n+  return result;\n+}\n+\n /* Push into the scope of the NAME namespace.  If NAME is NULL_TREE, then we\n    select a name that is unique to this compilation unit.  */\n \n@@ -1819,6 +2280,59 @@ pop_nested_namespace (tree ns)\n   timevar_pop (TV_NAME_LOOKUP);\n }\n \n+/* Temporarily set the namespace for the current declaration.  */\n+\n+void\n+push_decl_namespace (tree decl)\n+{\n+  if (TREE_CODE (decl) != NAMESPACE_DECL)\n+    decl = decl_namespace (decl);\n+  decl_namespace_list = tree_cons (ORIGINAL_NAMESPACE (decl),\n+                                   NULL_TREE, decl_namespace_list);\n+}\n+\n+/* [namespace.memdef]/2 */\n+\n+void\n+pop_decl_namespace (void)\n+{\n+  decl_namespace_list = TREE_CHAIN (decl_namespace_list);\n+}\n+\n+/* Return the namespace that is the common ancestor \n+   of two given namespaces.  */\n+\n+tree\n+namespace_ancestor (tree ns1, tree ns2)\n+{\n+  timevar_push (TV_NAME_LOOKUP);\n+  if (is_ancestor (ns1, ns2))\n+    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, ns1);\n+  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP,\n+                          namespace_ancestor (CP_DECL_CONTEXT (ns1), ns2));\n+}\n+\n+/* Process a namespace-alias declaration.  */\n+\n+void\n+do_namespace_alias (tree alias, tree namespace)\n+{\n+  if (TREE_CODE (namespace) != NAMESPACE_DECL)\n+    {\n+      /* The parser did not find it, so it's not there.  */\n+      error (\"unknown namespace `%D'\", namespace);\n+      return;\n+    }\n+\n+  namespace = ORIGINAL_NAMESPACE (namespace);\n+\n+  /* Build the alias.  */\n+  alias = build_lang_decl (NAMESPACE_DECL, alias, void_type_node);     \n+  DECL_NAMESPACE_ALIAS (alias) = namespace;\n+  DECL_EXTERNAL (alias) = 1;\n+  pushdecl (alias);\n+}\n+\n /* Like pushdecl, only it places X in the current namespace,\n    if appropriate.  */\n \n@@ -1865,6 +2379,237 @@ pushdecl_namespace_level (tree x)\n   POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, t);\n }\n \n+/* Insert USED into the using list of USER. Set INDIRECT_flag if this\n+   directive is not directly from the source. Also find the common\n+   ancestor and let our users know about the new namespace */\n+static void \n+add_using_namespace (tree user, tree used, bool indirect)\n+{\n+  tree t;\n+  timevar_push (TV_NAME_LOOKUP);\n+  /* Using oneself is a no-op.  */\n+  if (user == used)\n+    {\n+      timevar_pop (TV_NAME_LOOKUP);\n+      return;\n+    }\n+  my_friendly_assert (TREE_CODE (user) == NAMESPACE_DECL, 380);\n+  my_friendly_assert (TREE_CODE (used) == NAMESPACE_DECL, 380);\n+  /* Check if we already have this.  */\n+  t = purpose_member (used, DECL_NAMESPACE_USING (user));\n+  if (t != NULL_TREE)\n+    {\n+      if (!indirect)\n+\t/* Promote to direct usage.  */\n+\tTREE_INDIRECT_USING (t) = 0;\n+      timevar_pop (TV_NAME_LOOKUP);\n+      return;\n+    }\n+\n+  /* Add used to the user's using list.  */\n+  DECL_NAMESPACE_USING (user) \n+    = tree_cons (used, namespace_ancestor (user, used), \n+\t\t DECL_NAMESPACE_USING (user));\n+\n+  TREE_INDIRECT_USING (DECL_NAMESPACE_USING (user)) = indirect;\n+\n+  /* Add user to the used's users list.  */\n+  DECL_NAMESPACE_USERS (used)\n+    = tree_cons (user, 0, DECL_NAMESPACE_USERS (used));\n+\n+  /* Recursively add all namespaces used.  */\n+  for (t = DECL_NAMESPACE_USING (used); t; t = TREE_CHAIN (t))\n+    /* indirect usage */\n+    add_using_namespace (user, TREE_PURPOSE (t), 1);\n+\n+  /* Tell everyone using us about the new used namespaces.  */\n+  for (t = DECL_NAMESPACE_USERS (user); t; t = TREE_CHAIN (t))\n+    add_using_namespace (TREE_PURPOSE (t), used, 1);\n+  timevar_pop (TV_NAME_LOOKUP);\n+}\n+\n+/* Process a using-declaration not appearing in class or local scope.  */\n+\n+void\n+do_toplevel_using_decl (tree decl)\n+{\n+  tree scope, name;\n+  tree oldval, oldtype, newval, newtype;\n+  cxx_binding *binding;\n+\n+  decl = validate_nonmember_using_decl (decl, &scope, &name);\n+  if (decl == NULL_TREE)\n+    return;\n+  \n+  binding = binding_for_name (NAMESPACE_LEVEL (current_namespace), name);\n+\n+  oldval = binding->value;\n+  oldtype = binding->type;\n+\n+  do_nonmember_using_decl (scope, name, oldval, oldtype, &newval, &newtype);\n+\n+  /* Copy declarations found.  */\n+  if (newval)\n+    binding->value = newval;\n+  if (newtype)\n+    binding->type = newtype;\n+  return;\n+}\n+\n+/* Process a using-directive.  */\n+\n+void\n+do_using_directive (tree namespace)\n+{\n+  if (building_stmt_tree ())\n+    add_stmt (build_stmt (USING_STMT, namespace));\n+  \n+  /* using namespace A::B::C; */\n+  if (TREE_CODE (namespace) == SCOPE_REF)\n+      namespace = TREE_OPERAND (namespace, 1);\n+  if (TREE_CODE (namespace) == IDENTIFIER_NODE)\n+    {\n+      /* Lookup in lexer did not find a namespace.  */\n+      if (!processing_template_decl)\n+\terror (\"namespace `%T' undeclared\", namespace);\n+      return;\n+    }\n+  if (TREE_CODE (namespace) != NAMESPACE_DECL)\n+    {\n+      if (!processing_template_decl)\n+\terror (\"`%T' is not a namespace\", namespace);\n+      return;\n+    }\n+  namespace = ORIGINAL_NAMESPACE (namespace);\n+  if (!toplevel_bindings_p ())\n+    push_using_directive (namespace);\n+  else\n+    /* direct usage */\n+    add_using_namespace (current_namespace, namespace, 0);\n+}\n+\n+/* Combines two sets of overloaded functions into an OVERLOAD chain, removing\n+   duplicates.  The first list becomes the tail of the result.\n+\n+   The algorithm is O(n^2).  We could get this down to O(n log n) by\n+   doing a sort on the addresses of the functions, if that becomes\n+   necessary.  */\n+\n+static tree\n+merge_functions (tree s1, tree s2)\n+{\n+  for (; s2; s2 = OVL_NEXT (s2))\n+    {\n+      tree fn2 = OVL_CURRENT (s2);\n+      tree fns1;\n+\n+      for (fns1 = s1; fns1; fns1 = OVL_NEXT (fns1))\n+\t{\n+\t  tree fn1 = OVL_CURRENT (fns1);\n+\n+\t  /* If the function from S2 is already in S1, there is no\n+\t     need to add it again.  For `extern \"C\"' functions, we\n+\t     might have two FUNCTION_DECLs for the same function, in\n+\t     different namespaces; again, we only need one of them.  */\n+\t  if (fn1 == fn2 \n+\t      || (DECL_EXTERN_C_P (fn1) && DECL_EXTERN_C_P (fn2)\n+\t\t  && DECL_NAME (fn1) == DECL_NAME (fn2)))\n+\t    break;\n+\t}\n+      \n+      /* If we exhausted all of the functions in S1, FN2 is new.  */\n+      if (!fns1)\n+\ts1 = build_overload (fn2, s1);\n+    }\n+  return s1;\n+}\n+\n+/* This should return an error not all definitions define functions.\n+   It is not an error if we find two functions with exactly the\n+   same signature, only if these are selected in overload resolution.\n+   old is the current set of bindings, new the freshly-found binding.\n+   XXX Do we want to give *all* candidates in case of ambiguity?\n+   XXX In what way should I treat extern declarations?\n+   XXX I don't want to repeat the entire duplicate_decls here */\n+\n+static cxx_binding *\n+ambiguous_decl (tree name, cxx_binding *old, cxx_binding *new, int flags)\n+{\n+  tree val, type;\n+  my_friendly_assert (old != NULL, 393);\n+  /* Copy the value.  */\n+  val = new->value;\n+  if (val)\n+    switch (TREE_CODE (val))\n+      {\n+      case TEMPLATE_DECL:\n+        /* If we expect types or namespaces, and not templates,\n+           or this is not a template class.  */\n+        if (LOOKUP_QUALIFIERS_ONLY (flags)\n+            && !DECL_CLASS_TEMPLATE_P (val))\n+          val = NULL_TREE;\n+        break;\n+      case TYPE_DECL:\n+        if (LOOKUP_NAMESPACES_ONLY (flags))\n+          val = NULL_TREE;\n+        break;\n+      case NAMESPACE_DECL:\n+        if (LOOKUP_TYPES_ONLY (flags))\n+          val = NULL_TREE;\n+        break;\n+      case FUNCTION_DECL:\n+        /* Ignore built-in functions that are still anticipated.  */\n+        if (LOOKUP_QUALIFIERS_ONLY (flags) || DECL_ANTICIPATED (val))\n+          val = NULL_TREE;\n+        break;\n+      default:\n+        if (LOOKUP_QUALIFIERS_ONLY (flags))\n+          val = NULL_TREE;\n+      }\n+        \n+  if (!old->value)\n+    old->value = val;\n+  else if (val && val != old->value)\n+    {\n+      if (is_overloaded_fn (old->value) && is_overloaded_fn (val))\n+        old->value = merge_functions (old->value, val);\n+      else\n+\t{\n+\t  /* Some declarations are functions, some are not.  */\n+          if (flags & LOOKUP_COMPLAIN)\n+            {\n+\t      /* If we've already given this error for this lookup,\n+\t\t old->value is error_mark_node, so let's not\n+\t\t repeat ourselves.  */\n+\t      if (old->value != error_mark_node)\n+\t\t{\n+\t\t  error (\"use of `%D' is ambiguous\", name);\n+\t\t  cp_error_at (\"  first declared as `%#D' here\",\n+\t\t\t       old->value);\n+\t\t}\n+              cp_error_at (\"  also declared as `%#D' here\", val);\n+            }\n+\t  old->value = error_mark_node;\n+\t}\n+    }\n+  /* ... and copy the type.  */\n+  type = new->type;\n+  if (LOOKUP_NAMESPACES_ONLY (flags))\n+    type = NULL_TREE;\n+  if (!old->type)\n+    old->type = type;\n+  else if (type && old->type != type)\n+    {\n+      if (flags & LOOKUP_COMPLAIN)\n+        {\n+          error (\"`%D' denotes an ambiguous type\",name);\n+          error (\"%J  first type here\", TYPE_MAIN_DECL (old->type));\n+          error (\"%J  other type here\", TYPE_MAIN_DECL (type));\n+        }\n+    }\n+  return old;\n+}\n+\n /* Return the declarations that are members of the namespace NS.  */\n \n tree\n@@ -2120,6 +2865,79 @@ lookup_qualified_name (tree scope, tree name, bool is_type_p, bool complain)\n   return error_mark_node;\n }\n \n+/* Subroutine of unualified_namespace_lookup:\n+   Add the bindings of NAME in used namespaces to VAL.\n+   We are currently looking for names in namespace SCOPE, so we\n+   look through USINGS for using-directives of namespaces\n+   which have SCOPE as a common ancestor with the current scope.\n+   Returns false on errors.  */\n+\n+bool\n+lookup_using_namespace (tree name, cxx_binding *val, tree usings, tree scope,\n+                        int flags, tree *spacesp)\n+{\n+  tree iter;\n+  timevar_push (TV_NAME_LOOKUP);\n+  /* Iterate over all used namespaces in current, searching for using\n+     directives of scope.  */\n+  for (iter = usings; iter; iter = TREE_CHAIN (iter))\n+    if (TREE_VALUE (iter) == scope)\n+      {\n+        tree used = ORIGINAL_NAMESPACE (TREE_PURPOSE (iter));\n+        cxx_binding *val1 =\n+          cxx_scope_find_binding_for_name (NAMESPACE_LEVEL (used), name);\n+        if (spacesp)\n+          *spacesp = tree_cons (used, NULL_TREE, *spacesp);\n+        /* Resolve ambiguities.  */\n+        if (val1)\n+          val = ambiguous_decl (name, val, val1, flags);\n+      }\n+  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, val->value != error_mark_node);\n+}\n+\n+/* [namespace.qual]\n+   Accepts the NAME to lookup and its qualifying SCOPE.\n+   Returns the name/type pair found into the cxx_binding *RESULT,\n+   or false on error.  */\n+\n+bool\n+qualified_lookup_using_namespace (tree name, tree scope, cxx_binding *result,\n+                                  int flags)\n+{\n+  /* Maintain a list of namespaces visited...  */\n+  tree seen = NULL_TREE;\n+  /* ... and a list of namespace yet to see.  */\n+  tree todo = NULL_TREE;\n+  tree usings;\n+  timevar_push (TV_NAME_LOOKUP);\n+  /* Look through namespace aliases.  */\n+  scope = ORIGINAL_NAMESPACE (scope);\n+  while (scope && result->value != error_mark_node)\n+    {\n+      cxx_binding *binding =\n+        cxx_scope_find_binding_for_name (NAMESPACE_LEVEL (scope), name);\n+      seen = tree_cons (scope, NULL_TREE, seen);\n+      if (binding)\n+        result = ambiguous_decl (name, result, binding, flags);\n+      if (!result->value && !result->type)\n+\t/* Consider using directives.  */\n+\tfor (usings = DECL_NAMESPACE_USING (scope); usings;\n+\t     usings = TREE_CHAIN (usings))\n+\t  /* If this was a real directive, and we have not seen it.  */\n+\t  if (!TREE_INDIRECT_USING (usings)\n+\t      && !purpose_member (TREE_PURPOSE (usings), seen))\n+\t    todo = tree_cons (TREE_PURPOSE (usings), NULL_TREE, todo);\n+      if (todo)\n+\t{\n+\t  scope = TREE_PURPOSE (todo);\n+\t  todo = TREE_CHAIN (todo);\n+\t}\n+      else\n+\tscope = NULL_TREE; /* If there never was a todo list.  */\n+    }\n+  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, result->value != error_mark_node);\n+}\n+\n /* Look up NAME in the current binding level and its superiors in the\n    namespace of variables, functions and typedefs.  Return a ..._DECL\n    node of some kind representing its definition if there is only one\n@@ -2305,6 +3123,355 @@ lookup_type_current_level (tree name)\n   POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, t);\n }\n \n+/* [basic.lookup.koenig] */\n+/* A nonzero return value in the functions below indicates an error.  */\n+\n+struct arg_lookup\n+{\n+  tree name;\n+  tree namespaces;\n+  tree classes;\n+  tree functions;\n+};\n+\n+static bool arg_assoc (struct arg_lookup*, tree);\n+static bool arg_assoc_args (struct arg_lookup*, tree);\n+static bool arg_assoc_type (struct arg_lookup*, tree);\n+static bool add_function (struct arg_lookup *, tree);\n+static bool arg_assoc_namespace (struct arg_lookup *, tree);\n+static bool arg_assoc_class (struct arg_lookup *, tree);\n+static bool arg_assoc_template_arg (struct arg_lookup*, tree);\n+\n+/* Add a function to the lookup structure.\n+   Returns true on error.  */\n+\n+static bool\n+add_function (struct arg_lookup *k, tree fn)\n+{\n+  /* We used to check here to see if the function was already in the list,\n+     but that's O(n^2), which is just too expensive for function lookup.\n+     Now we deal with the occasional duplicate in joust.  In doing this, we\n+     assume that the number of duplicates will be small compared to the\n+     total number of functions being compared, which should usually be the\n+     case.  */\n+\n+  /* We must find only functions, or exactly one non-function.  */\n+  if (!k->functions) \n+    k->functions = fn;\n+  else if (fn == k->functions)\n+    ;\n+  else if (is_overloaded_fn (k->functions) && is_overloaded_fn (fn))\n+    k->functions = build_overload (fn, k->functions);\n+  else\n+    {\n+      tree f1 = OVL_CURRENT (k->functions);\n+      tree f2 = fn;\n+      if (is_overloaded_fn (f1))\n+\t{\n+\t  fn = f1; f1 = f2; f2 = fn;\n+\t}\n+      cp_error_at (\"`%D' is not a function,\", f1);\n+      cp_error_at (\"  conflict with `%D'\", f2);\n+      error (\"  in call to `%D'\", k->name);\n+      return true;\n+    }\n+\n+  return false;\n+}\n+\n+/* Add functions of a namespace to the lookup structure.\n+   Returns true on error.  */\n+\n+static bool\n+arg_assoc_namespace (struct arg_lookup *k, tree scope)\n+{\n+  tree value;\n+\n+  if (purpose_member (scope, k->namespaces))\n+    return 0;\n+  k->namespaces = tree_cons (scope, NULL_TREE, k->namespaces);\n+  \n+  value = namespace_binding (k->name, scope);\n+  if (!value)\n+    return false;\n+\n+  for (; value; value = OVL_NEXT (value))\n+    if (add_function (k, OVL_CURRENT (value)))\n+      return true;\n+  \n+  return false;\n+}\n+\n+/* Adds everything associated with a template argument to the lookup\n+   structure.  Returns true on error.  */\n+\n+static bool\n+arg_assoc_template_arg (struct arg_lookup *k, tree arg)\n+{\n+  /* [basic.lookup.koenig]\n+\n+     If T is a template-id, its associated namespaces and classes are\n+     ... the namespaces and classes associated with the types of the\n+     template arguments provided for template type parameters\n+     (excluding template template parameters); the namespaces in which\n+     any template template arguments are defined; and the classes in\n+     which any member templates used as template template arguments\n+     are defined.  [Note: non-type template arguments do not\n+     contribute to the set of associated namespaces.  ]  */\n+\n+  /* Consider first template template arguments.  */\n+  if (TREE_CODE (arg) == TEMPLATE_TEMPLATE_PARM\n+      || TREE_CODE (arg) == UNBOUND_CLASS_TEMPLATE)\n+    return false;\n+  else if (TREE_CODE (arg) == TEMPLATE_DECL)\n+    {\n+      tree ctx = CP_DECL_CONTEXT (arg);\n+\n+      /* It's not a member template.  */\n+      if (TREE_CODE (ctx) == NAMESPACE_DECL)\n+        return arg_assoc_namespace (k, ctx);\n+      /* Otherwise, it must be member template.  */\n+      else \n+        return arg_assoc_class (k, ctx);\n+    }\n+  /* It's not a template template argument, but it is a type template\n+     argument.  */\n+  else if (TYPE_P (arg))\n+    return arg_assoc_type (k, arg);\n+  /* It's a non-type template argument.  */\n+  else\n+    return false;\n+}\n+\n+/* Adds everything associated with class to the lookup structure.\n+   Returns true on error.  */\n+\n+static bool\n+arg_assoc_class (struct arg_lookup *k, tree type)\n+{\n+  tree list, friends, context;\n+  int i;\n+  \n+  /* Backend build structures, such as __builtin_va_list, aren't\n+     affected by all this.  */\n+  if (!CLASS_TYPE_P (type))\n+    return false;\n+\n+  if (purpose_member (type, k->classes))\n+    return false;\n+  k->classes = tree_cons (type, NULL_TREE, k->classes);\n+  \n+  context = decl_namespace (TYPE_MAIN_DECL (type));\n+  if (arg_assoc_namespace (k, context))\n+    return true;\n+  \n+  /* Process baseclasses.  */\n+  for (i = 0; i < CLASSTYPE_N_BASECLASSES (type); i++)\n+    if (arg_assoc_class (k, TYPE_BINFO_BASETYPE (type, i)))\n+      return true;\n+  \n+  /* Process friends.  */\n+  for (list = DECL_FRIENDLIST (TYPE_MAIN_DECL (type)); list; \n+       list = TREE_CHAIN (list))\n+    if (k->name == FRIEND_NAME (list))\n+      for (friends = FRIEND_DECLS (list); friends; \n+\t   friends = TREE_CHAIN (friends))\n+\t/* Only interested in global functions with potentially hidden\n+           (i.e. unqualified) declarations.  */\n+\tif (CP_DECL_CONTEXT (TREE_VALUE (friends)) == context)\n+\t  if (add_function (k, TREE_VALUE (friends)))\n+\t    return true;\n+\n+  /* Process template arguments.  */\n+  if (CLASSTYPE_TEMPLATE_INFO (type))\n+    {\n+      list = INNERMOST_TEMPLATE_ARGS (CLASSTYPE_TI_ARGS (type));\n+      for (i = 0; i < TREE_VEC_LENGTH (list); ++i) \n+        arg_assoc_template_arg (k, TREE_VEC_ELT (list, i));\n+    }\n+\n+  return false;\n+}\n+\n+/* Adds everything associated with a given type.\n+   Returns 1 on error.  */\n+\n+static bool\n+arg_assoc_type (struct arg_lookup *k, tree type)\n+{\n+  /* As we do not get the type of non-type dependent expressions\n+     right, we can end up with such things without a type.  */\n+  if (!type)\n+    return false;\n+\n+  if (TYPE_PTRMEM_P (type))\n+    {\n+      /* Pointer to member: associate class type and value type.  */\n+      if (arg_assoc_type (k, TYPE_PTRMEM_CLASS_TYPE (type)))\n+\treturn true;\n+      return arg_assoc_type (k, TYPE_PTRMEM_POINTED_TO_TYPE (type));\n+    }\n+  else switch (TREE_CODE (type))\n+    {\n+    case ERROR_MARK:\n+      return false;\n+    case VOID_TYPE:\n+    case INTEGER_TYPE:\n+    case REAL_TYPE:\n+    case COMPLEX_TYPE:\n+    case VECTOR_TYPE:\n+    case CHAR_TYPE:\n+    case BOOLEAN_TYPE:\n+      return false;\n+    case RECORD_TYPE:\n+      if (TYPE_PTRMEMFUNC_P (type))\n+\treturn arg_assoc_type (k, TYPE_PTRMEMFUNC_FN_TYPE (type));\n+      return arg_assoc_class (k, type);\n+    case POINTER_TYPE:\n+    case REFERENCE_TYPE:\n+    case ARRAY_TYPE:\n+      return arg_assoc_type (k, TREE_TYPE (type));\n+    case UNION_TYPE:\n+    case ENUMERAL_TYPE:\n+      return arg_assoc_namespace (k, decl_namespace (TYPE_MAIN_DECL (type)));\n+    case METHOD_TYPE:\n+      /* The basetype is referenced in the first arg type, so just\n+\t fall through.  */\n+    case FUNCTION_TYPE:\n+      /* Associate the parameter types.  */\n+      if (arg_assoc_args (k, TYPE_ARG_TYPES (type)))\n+\treturn true;\n+      /* Associate the return type.  */\n+      return arg_assoc_type (k, TREE_TYPE (type));\n+    case TEMPLATE_TYPE_PARM:\n+    case BOUND_TEMPLATE_TEMPLATE_PARM:\n+      return false;\n+    case TYPENAME_TYPE:\n+      return false;\n+    case LANG_TYPE:\n+      if (type == unknown_type_node)\n+\treturn false;\n+      /* else fall through */\n+    default:\n+      abort ();\n+    }\n+  return false;\n+}\n+\n+/* Adds everything associated with arguments.  Returns true on error.  */\n+\n+static bool\n+arg_assoc_args (struct arg_lookup *k, tree args)\n+{\n+  for (; args; args = TREE_CHAIN (args))\n+    if (arg_assoc (k, TREE_VALUE (args)))\n+      return true;\n+  return false;\n+}\n+\n+/* Adds everything associated with a given tree_node.  Returns 1 on error.  */\n+\n+static bool\n+arg_assoc (struct arg_lookup *k, tree n)\n+{\n+  if (n == error_mark_node)\n+    return false;\n+\n+  if (TYPE_P (n))\n+    return arg_assoc_type (k, n);\n+\n+  if (! type_unknown_p (n))\n+    return arg_assoc_type (k, TREE_TYPE (n));\n+\n+  if (TREE_CODE (n) == ADDR_EXPR)\n+    n = TREE_OPERAND (n, 0);\n+  if (TREE_CODE (n) == COMPONENT_REF)\n+    n = TREE_OPERAND (n, 1);\n+  if (TREE_CODE (n) == OFFSET_REF)\n+    n = TREE_OPERAND (n, 1);\n+  while (TREE_CODE (n) == TREE_LIST)\n+    n = TREE_VALUE (n);\n+  if (TREE_CODE (n) == BASELINK)\n+    n = BASELINK_FUNCTIONS (n);\n+\n+  if (TREE_CODE (n) == FUNCTION_DECL)\n+    return arg_assoc_type (k, TREE_TYPE (n));\n+  if (TREE_CODE (n) == TEMPLATE_ID_EXPR)\n+    {\n+      /* [basic.lookup.koenig]\n+\n+\t If T is a template-id, its associated namespaces and classes\n+\t are the namespace in which the template is defined; for\n+\t member templates, the member template's class...  */\n+      tree template = TREE_OPERAND (n, 0);\n+      tree args = TREE_OPERAND (n, 1);\n+      tree ctx;\n+      int ix;\n+\n+      if (TREE_CODE (template) == COMPONENT_REF)\n+        template = TREE_OPERAND (template, 1);\n+      \n+      /* First, the template.  There may actually be more than one if\n+\t this is an overloaded function template.  But, in that case,\n+\t we only need the first; all the functions will be in the same\n+\t namespace.  */\n+      template = OVL_CURRENT (template);\n+\n+      ctx = CP_DECL_CONTEXT (template);\n+       \n+      if (TREE_CODE (ctx) == NAMESPACE_DECL)\n+\t{\n+\t  if (arg_assoc_namespace (k, ctx) == 1)\n+\t    return true;\n+\t}\n+      /* It must be a member template.  */\n+      else if (arg_assoc_class (k, ctx) == 1)\n+\treturn true;\n+\n+      /* Now the arguments.  */\n+      for (ix = TREE_VEC_LENGTH (args); ix--;)\n+\tif (arg_assoc_template_arg (k, TREE_VEC_ELT (args, ix)) == 1)\n+\t  return true;\n+    }\n+  else\n+    {\n+      my_friendly_assert (TREE_CODE (n) == OVERLOAD, 980715);\n+      \n+      for (; n; n = OVL_CHAIN (n))\n+\tif (arg_assoc_type (k, TREE_TYPE (OVL_FUNCTION (n))))\n+\t  return true;\n+    }\n+\n+  return false;\n+}\n+\n+/* Performs Koenig lookup depending on arguments, where fns\n+   are the functions found in normal lookup.  */\n+\n+tree\n+lookup_arg_dependent (tree name, tree fns, tree args)\n+{\n+  struct arg_lookup k;\n+  tree fn = NULL_TREE;\n+\n+  timevar_push (TV_NAME_LOOKUP);\n+  k.name = name;\n+  k.functions = fns;\n+  k.classes = NULL_TREE;\n+\n+  /* Note that we've already looked at some namespaces during normal\n+     unqualified lookup, unless we found a decl in function scope.  */\n+  if (fns)\n+    fn = OVL_CURRENT (fns);\n+  if (fn && TREE_CODE (fn) == FUNCTION_DECL && DECL_LOCAL_FUNCTION_P (fn))\n+    k.namespaces = NULL_TREE;\n+  else\n+    unqualified_namespace_lookup (name, 0, &k.namespaces);\n+\n+  arg_assoc_args (&k, args);\n+  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, k.functions);\n+}\n+\n /* Add namespace to using_directives. Return NULL_TREE if nothing was\n    changed (i.e. there was already a directive), or the fresh\n    TREE_LIST otherwise.  */"}, {"sha": "09ad59a76938e1f96c8b1fc46ba1858f154a5d47", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a167978fa119e30cca1f45f0b814b4af9db7643/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a167978fa119e30cca1f45f0b814b4af9db7643/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=5a167978fa119e30cca1f45f0b814b4af9db7643", "patch": "@@ -70,9 +70,6 @@ typedef struct cp_binding_level cxx_scope;\n    currently being defined.  */\n #define INHERITED_VALUE_BINDING_P(NODE) ((NODE)->value_is_inherited)\n \n-/* Zero out a cxx_binding pointed to by B.  */\n-#define cxx_binding_clear(B) memset ((B), 0, sizeof (cxx_binding))\n-\n struct cxx_binding GTY(())\n {\n   /* Link to chain together various bindings for this name.  */\n@@ -91,6 +88,9 @@ extern tree identifier_type_value (tree);\n extern void set_identifier_type_value (tree, tree);\n extern void pop_binding (tree, tree);\n extern void clear_identifier_class_values (void);\n+extern tree constructor_name_full (tree);\n+extern tree constructor_name (tree);\n+extern bool constructor_name_p (tree, tree);\n \f\n /* The kinds of scopes we recognize.  */\n typedef enum scope_kind {\n@@ -267,23 +267,27 @@ extern void pop_from_top_level (void);\n extern void maybe_push_to_top_level (int);\n extern void pop_everything (void);\n extern void keep_next_level (bool);\n+extern bool is_ancestor (tree, tree);\n+extern void push_scope (tree);\n+extern void pop_scope (tree);\n \f\n extern void push_namespace (tree);\n extern void pop_namespace (void);\n extern void push_nested_namespace (tree);\n extern void pop_nested_namespace (tree);\n+extern tree namespace_ancestor (tree, tree);\n extern tree push_using_directive (tree);\n extern void pushlevel_class (void);\n extern void poplevel_class (void);\n-extern cxx_binding *cxx_scope_find_binding_for_name (cxx_scope *, tree);\n-extern cxx_binding *binding_for_name (cxx_scope *, tree);\n extern tree pushdecl_with_scope (tree, cxx_scope *);\n extern tree lookup_tag (enum tree_code, tree, cxx_scope *, int);\n extern tree lookup_tag_reverse (tree, tree);\n extern tree lookup_name\t(tree, int);\n extern tree lookup_name_real (tree, int, int, int, int);\n extern tree lookup_name_current_level (tree);\n extern tree lookup_type_current_level (tree);\n+extern bool lookup_using_namespace (tree, cxx_binding *, tree, tree, int, tree *);\n+extern bool qualified_lookup_using_namespace (tree, tree, cxx_binding *, int);\n extern tree namespace_binding (tree, tree);\n extern void add_decl_to_level (tree, cxx_scope *);\n extern void set_namespace_binding (tree, tree, tree);\n@@ -301,6 +305,16 @@ extern void storetags (tree);\n extern tree getdecls (void);\n extern tree cp_namespace_decls (tree);\n extern void set_class_shadows (tree);\n+extern void set_decl_namespace (tree, tree, bool);\n+extern tree current_decl_namespace (void);\n+extern void push_decl_namespace (tree);\n+extern void pop_decl_namespace (void);\n+extern void do_namespace_alias (tree, tree);\n+extern void do_toplevel_using_decl (tree);\n+extern void do_local_using_decl (tree);\n+extern tree do_class_using_decl (tree);\n+extern void do_using_directive (tree);\n+extern tree lookup_arg_dependent (tree, tree, tree);\n \n \n /* Set *DECL to the (non-hidden) declaration for ID at global scope,"}]}