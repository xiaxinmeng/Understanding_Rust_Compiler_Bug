{"sha": "a603c4aa001a2620029526f8dca77b3e53dcb54c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTYwM2M0YWEwMDFhMjYyMDAyOTUyNmY4ZGNhNzdiM2U1M2RjYjU0Yw==", "commit": {"author": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1992-12-08T15:33:14Z"}, "committer": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1992-12-08T15:33:14Z"}, "message": "(AS_BUG_FLOATING_CONSTANT, AS_BUG_TRAILING_LABEL): New.\n\n\t(TEXT_SECTION_ASM_OP, DATA_SECTION_ASM_OP): Output align 1 to\n\taccomodate the \"trailing label\" bug.\n\t(ASM_OUTPUT_DOUBLE_OPERAND, ASM_OUTPUT_FLOAT_OPERAND): Define to\n\toutput values in hex to accomodate the \"floating constant\" bug.\n\t(PRINT_OPERAND_FLOAT, PRINT_OPERAND): Ditto.\n\nFrom-SVN: r2849", "tree": {"sha": "42be9e3dbd40c7cc9186e0c7c7c4c118bec006b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/42be9e3dbd40c7cc9186e0c7c7c4c118bec006b4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a603c4aa001a2620029526f8dca77b3e53dcb54c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a603c4aa001a2620029526f8dca77b3e53dcb54c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a603c4aa001a2620029526f8dca77b3e53dcb54c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a603c4aa001a2620029526f8dca77b3e53dcb54c/comments", "author": null, "committer": null, "parents": [{"sha": "1d7a9c94f2c102ad4da9cafaf440a9b7ee071cf4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d7a9c94f2c102ad4da9cafaf440a9b7ee071cf4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d7a9c94f2c102ad4da9cafaf440a9b7ee071cf4"}], "stats": {"total": 51, "additions": 46, "deletions": 5}, "files": [{"sha": "315a2e9336f0effbff303ec088509fece77d8c50", "filename": "gcc/config/m68k/hp320.h", "status": "modified", "additions": 46, "deletions": 5, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a603c4aa001a2620029526f8dca77b3e53dcb54c/gcc%2Fconfig%2Fm68k%2Fhp320.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a603c4aa001a2620029526f8dca77b3e53dcb54c/gcc%2Fconfig%2Fm68k%2Fhp320.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fhp320.h?ref=a603c4aa001a2620029526f8dca77b3e53dcb54c", "patch": "@@ -32,6 +32,17 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #define SGS_CMP_ORDER\t\t/* Takes cmp operands in reverse order */\n #define HPUX_ASM\n \n+#if !defined (CROSS_COMPILE) && !defined (NO_BUGS)\n+/* The assembler on HP 9k3xx machines running HPUX 8.0 doesn't translate\n+   floating point constants behind some operands.  The workaround is to\n+   use hex constants.  Reported by Thomas Nau (nau@medizin.uni-ulm.de).  */\n+#define AS_BUG_FLOATING_CONSTANT\n+/* The assembler on HP 9k3xx machines running HPUX 8.0 doesn't accept\n+   labels followed by a text, data, or other section directive.  Reported\n+   by Thomas Nau (nau@medizin.uni-ulm.de).  */\n+#define AS_BUG_TRAILING_LABEL\n+#endif\n+\n /* gcc.c should find libgcc.a itself rather than expecting linker to.  */\n #define LINK_LIBGCC_SPECIAL\n /* The arguments of -L must be a separate argv element.  */\n@@ -288,9 +299,13 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n #define ASM_APP_OFF \"\"\n \n+#ifdef AS_BUG_TRAILING_LABEL\n+#define TEXT_SECTION_ASM_OP \"\\tlalign\\t1\\ntext\"\n+#define DATA_SECTION_ASM_OP \"\\tlalign\\t1\\ndata\"\n+#else\n #define TEXT_SECTION_ASM_OP \"text\"\n-\n #define DATA_SECTION_ASM_OP \"data\"\n+#endif\n \n #define\tASCII_DATA_ASM_OP \"byte\"\n  \n@@ -336,6 +351,24 @@ do{  if (PREFIX[0] == 'L' && PREFIX[1] == 'I')\t\t\\\n #define ASM_OUTPUT_FLOAT(FILE, VALUE)\t\t\t\t\t\\\n   fprintf (FILE, \"\\tfloat 0f%.9g\\n\", (VALUE))\n \n+#ifdef AS_BUG_FLOATING_CONSTANT\n+#undef  ASM_OUTPUT_DOUBLE_OPERAND\n+#define ASM_OUTPUT_DOUBLE_OPERAND(FILE, VALUE)                  \\\n+  do {\t\t\t\t\t\t\t\t\\\n+    union { double d; int i[2]; } dummy_u;\t\t\t\\\n+    dummy_u.d = (VALUE);\t\t\t\t\t\\\n+    asm_fprintf (FILE, \"%I0x%x%08x\", dummy_u.i[0], dummy_u.i[1]); \\ \n+  } while (0)\n+\n+#undef  ASM_OUTPUT_FLOAT_OPERAND\n+#define ASM_OUTPUT_FLOAT_OPERAND(FILE, VALUE)                   \\\n+  do {\t\t\t\t\t\t\t\t\\\n+    union { float f; int i; } dummy_u;\t\t\t\t\\\n+    dummy_u.f = (VALUE);\t\t\t\t\t\\\n+    asm_fprintf (FILE, \"%I0x%08x\", dummy_u.i);\t\t\t\\\n+  } while (0)\n+#endif /* AS_BUG_FLOATING_CONSTANT */\n+\n /* This is how to output an assembler line defining an `int' constant.  */\n \n #define ASM_OUTPUT_INT(FILE,VALUE)  \\\n@@ -378,6 +411,17 @@ do{  if (PREFIX[0] == 'L' && PREFIX[1] == 'I')\t\t\\\n #define ASM_OUTPUT_SOURCE_FILENAME(FILE, FILENAME)\n #define ASM_OUTPUT_SOURCE_LINE(FILE, LINENO)\n \n+#ifdef AS_BUG_FLOATING_CONSTANT\n+#define PRINT_OPERAND_FLOAT(FILE,CODE,FLOAT,INT)\t\\\n+  fprintf (FILE, \"&0x%x\", (INT))\n+#else\n+#define PRINT_OPERAND_FLOAT(FILE,CODE,FLOAT,INT)\t\\\n+  if (CODE == 'f')\t\t\t\t\t\\\n+    fprintf (FILE, \"&0f%.9g\", (FLOAT));\t\t\t\\\n+  else\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \"&0x%x\", (INT))\n+#endif /* AS_BUG_FLOATING_CONSTANT */\n+\n #define PRINT_OPERAND(FILE, X, CODE)  \\\n { if (CODE == '.') fprintf (FILE, \".\");\t\t\t\t\t\\\n   else if (CODE == '#') fprintf (FILE, \"&\");\t\t\t\t\\\n@@ -396,10 +440,7 @@ do{  if (PREFIX[0] == 'L' && PREFIX[1] == 'I')\t\t\\\n       union { float f; int i; } u1;\t\t\t\t\t\\\n       u.i[0] = CONST_DOUBLE_LOW (X); u.i[1] = CONST_DOUBLE_HIGH (X);\t\\\n       u1.f = u.d;\t\t\t\t\t\t\t\\\n-      if (CODE == 'f')\t\t\t\t\t\t\t\\\n-        fprintf (FILE, \"&0f%.9g\", u1.f);\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\t\\\n-        fprintf (FILE, \"&0x%x\", u1.i); }\t\t\t\t\\\n+      PRINT_OPERAND_FLOAT (FILE,CODE, u1.f, u1.i); }\t\t\t\\\n   else if (GET_CODE (X) == CONST_DOUBLE && GET_MODE (X) == DFmode)\t\\\n     { union { double d; int i[2]; } u;\t\t\t\t\t\\\n       u.i[0] = CONST_DOUBLE_LOW (X); u.i[1] = CONST_DOUBLE_HIGH (X);\t\\"}]}