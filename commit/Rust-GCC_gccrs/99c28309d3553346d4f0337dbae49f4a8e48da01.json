{"sha": "99c28309d3553346d4f0337dbae49f4a8e48da01", "node_id": "C_kwDOANBUbNoAKDk5YzI4MzA5ZDM1NTMzNDZkNGYwMzM3ZGJhZTQ5ZjRhOGU0OGRhMDE", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-10-04T09:26:20Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-10-04T09:26:20Z"}, "message": "Merge #698 #701\n\n698: Implement Byte Strings r=philberty a=philberty\n\nByte strings are not str's they are arrays of [u8; capacity], this\r\npreserves their type guarantees as a byte string.\r\n\r\nThis patch merges work from Mark to implement the correct typing, the\r\nmissing piece was that each implicit type needed its own implicit id, other\r\nwise their is a loop in looking up the covariant types.\r\n\r\nFixes #697\r\n\r\nCo-authored-by: Mark Wielaard <mark@klomp.org>\r\n\n\n701: Fix lexer to not produce bad unicode escape values r=philberty a=CohenArthur\n\nThere were a couple of issues in the lexer unicode escape code.\r\nUnicode escape sequences must always start with an opening curly\r\nbracket (and end with a closing one). Underscores are not allowed as\r\nstarting character. And the produced values must be unicode scalar\r\nvalues, which excludes surrogate values (D800 to DFFF) or values\r\nlarger than 10FFFF.\r\n\r\nAlso try to recover more gracefully from errors by trying to skip past\r\nany bad characters to the end of the escape sequence.\r\n\r\nTest all of the above in a new testcase unicode_escape.rs.\r\n\r\nPatch: https://git.sr.ht/~mjw/gccrs/commit/unicode_escape\r\nMail: https://gcc.gnu.org/pipermail/gcc-rust/2021-October/000231.html\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\nCo-authored-by: Mark Wielaard <mark@klomp.org>", "tree": {"sha": "6eec1dda4eccc0f90d6c5bf00158db8a3763661b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6eec1dda4eccc0f90d6c5bf00158db8a3763661b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/99c28309d3553346d4f0337dbae49f4a8e48da01", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhWsi8CRBK7hj4Ov3rIwAAmPwIAFbDmerICCl1noh1O9SLPdNP\nGFPAEwcNr0mcIzNvM7nWUaPatKNeRwRHH1D8dV7AK5sU/PxDJmNuHQopwc02Qmem\n/q5SSOwc17EcO1XBWcuQ3GV6UgvnLwyZ+4zrZ/YAgX2cWP3+2vgVdh8l0RcTuxmn\ne/mW3A2dBnEZoc5+HddW39Ce8Mq2M++zVRDsULZ8tvVoao5qD5ljvJb56ieAp3dB\nT3Unlu4YEIP03RB7YmmJ2ZnravxrFi6+PiZwjdGhrh6Tw6VfKY4xNXsjkndaeAz/\nQ1qvyJpkelbzX3CGYNQulH1i0UKUXRR6zjaLknIMRJVcZIB02eBG3dChfRGkqoU=\n=xCrD\n-----END PGP SIGNATURE-----\n", "payload": "tree 6eec1dda4eccc0f90d6c5bf00158db8a3763661b\nparent e0b9673a7ccad74706ed744bb882786b2fbaddf0\nparent 65d06d56e8201e365e60adeef9121386a626a203\nparent 23475a8131d2bd284758bcab85fa1c5bb98f1010\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1633339580 +0000\ncommitter GitHub <noreply@github.com> 1633339580 +0000\n\nMerge #698 #701\n\n698: Implement Byte Strings r=philberty a=philberty\n\nByte strings are not str's they are arrays of [u8; capacity], this\r\npreserves their type guarantees as a byte string.\r\n\r\nThis patch merges work from Mark to implement the correct typing, the\r\nmissing piece was that each implicit type needed its own implicit id, other\r\nwise their is a loop in looking up the covariant types.\r\n\r\nFixes #697\r\n\r\nCo-authored-by: Mark Wielaard <mark@klomp.org>\r\n\n\n701: Fix lexer to not produce bad unicode escape values r=philberty a=CohenArthur\n\nThere were a couple of issues in the lexer unicode escape code.\r\nUnicode escape sequences must always start with an opening curly\r\nbracket (and end with a closing one). Underscores are not allowed as\r\nstarting character. And the produced values must be unicode scalar\r\nvalues, which excludes surrogate values (D800 to DFFF) or values\r\nlarger than 10FFFF.\r\n\r\nAlso try to recover more gracefully from errors by trying to skip past\r\nany bad characters to the end of the escape sequence.\r\n\r\nTest all of the above in a new testcase unicode_escape.rs.\r\n\r\nPatch: https://git.sr.ht/~mjw/gccrs/commit/unicode_escape\r\nMail: https://gcc.gnu.org/pipermail/gcc-rust/2021-October/000231.html\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\nCo-authored-by: Mark Wielaard <mark@klomp.org>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99c28309d3553346d4f0337dbae49f4a8e48da01", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99c28309d3553346d4f0337dbae49f4a8e48da01", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99c28309d3553346d4f0337dbae49f4a8e48da01/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e0b9673a7ccad74706ed744bb882786b2fbaddf0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0b9673a7ccad74706ed744bb882786b2fbaddf0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0b9673a7ccad74706ed744bb882786b2fbaddf0"}, {"sha": "65d06d56e8201e365e60adeef9121386a626a203", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65d06d56e8201e365e60adeef9121386a626a203", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65d06d56e8201e365e60adeef9121386a626a203"}, {"sha": "23475a8131d2bd284758bcab85fa1c5bb98f1010", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23475a8131d2bd284758bcab85fa1c5bb98f1010", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23475a8131d2bd284758bcab85fa1c5bb98f1010"}], "stats": {"total": 239, "additions": 216, "deletions": 23}, "files": [{"sha": "eb245dce5be7a949139ae2649023327a7d28174d", "filename": "gcc/rust/backend/rust-compile-expr.h", "status": "modified", "additions": 41, "deletions": 2, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99c28309d3553346d4f0337dbae49f4a8e48da01/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99c28309d3553346d4f0337dbae49f4a8e48da01/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.h?ref=99c28309d3553346d4f0337dbae49f4a8e48da01", "patch": "@@ -304,15 +304,54 @@ class CompileExpr : public HIRCompileBase\n \t}\n \treturn;\n \n-      case HIR::Literal::STRING:\n-\tcase HIR::Literal::BYTE_STRING: {\n+\tcase HIR::Literal::STRING: {\n \t  auto base = ctx->get_backend ()->string_constant_expression (\n \t    literal_value->as_string ());\n \t  translated\n \t    = ctx->get_backend ()->address_expression (base, expr.get_locus ());\n \t}\n \treturn;\n \n+\tcase HIR::Literal::BYTE_STRING: {\n+\t  TyTy::BaseType *tyty = nullptr;\n+\t  if (!ctx->get_tyctx ()->lookup_type (\n+\t\texpr.get_mappings ().get_hirid (), &tyty))\n+\t    {\n+\t      rust_fatal_error (expr.get_locus (),\n+\t\t\t\t\"did not resolve type for this array expr\");\n+\t      return;\n+\t    }\n+\n+\t  // the type here is &[ty; capacity]\n+\t  rust_assert (tyty->get_kind () == TyTy::TypeKind::REF);\n+\t  auto ref_tyty = static_cast<TyTy::ReferenceType *> (tyty);\n+\t  auto base_tyty = ref_tyty->get_base ();\n+\t  rust_assert (base_tyty->get_kind () == TyTy::TypeKind::ARRAY);\n+\t  auto array_tyty = static_cast<TyTy::ArrayType *> (base_tyty);\n+\n+\t  std::string value_str = expr.get_literal ()->as_string ();\n+\t  std::vector<Bexpression *> vals;\n+\t  std::vector<unsigned long> indexes;\n+\t  for (size_t i = 0; i < value_str.size (); i++)\n+\t    {\n+\t      char b = value_str.at (i);\n+\t      Bexpression *bb\n+\t\t= ctx->get_backend ()->char_constant_expression (b);\n+\t      vals.push_back (bb);\n+\t      indexes.push_back (i);\n+\t    }\n+\n+\t  Btype *array_type = TyTyResolveCompile::compile (ctx, array_tyty);\n+\t  Bexpression *constructed\n+\t    = ctx->get_backend ()->array_constructor_expression (\n+\t      array_type, indexes, vals, expr.get_locus ());\n+\n+\t  translated\n+\t    = ctx->get_backend ()->address_expression (constructed,\n+\t\t\t\t\t\t       expr.get_locus ());\n+\t}\n+\treturn;\n+\n       default:\n \trust_fatal_error (expr.get_locus (), \"unknown literal\");\n \treturn;"}, {"sha": "2b3c89b48be82bc7d2246e12f782b019c2299887", "filename": "gcc/rust/lex/rust-lex.cc", "status": "modified", "additions": 72, "deletions": 16, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99c28309d3553346d4f0337dbae49f4a8e48da01/gcc%2Frust%2Flex%2Frust-lex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99c28309d3553346d4f0337dbae49f4a8e48da01/gcc%2Frust%2Flex%2Frust-lex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flex%2Frust-lex.cc?ref=99c28309d3553346d4f0337dbae49f4a8e48da01", "patch": "@@ -1273,6 +1273,8 @@ Lexer::parse_escape (char opening_char)\n       rust_error_at (get_current_location (),\n \t\t     \"cannot have a unicode escape \\\\u in a byte %s\",\n \t\t     opening_char == '\\'' ? \"character\" : \"string\");\n+      // Try to parse it anyway, just to skip it\n+      parse_partial_unicode_escape ();\n       return std::make_tuple (output_char, additional_length_offset, false);\n     case '\\r':\n     case '\\n':\n@@ -1461,16 +1463,34 @@ Lexer::parse_partial_unicode_escape ()\n {\n   skip_input ();\n   current_char = peek_input ();\n-  int additional_length_offset = 1;\n+  int additional_length_offset = 0;\n \n-  bool need_close_brace = false;\n-  if (current_char == '{')\n+  if (current_char != '{')\n     {\n-      need_close_brace = true;\n+      rust_error_at (get_current_location (),\n+\t\t     \"unicode escape should start with %<{%>\");\n+      /* Skip what should probaby have been between brackets.  */\n+      while (is_x_digit (current_char) || current_char == '_')\n+\t{\n+\t  skip_input ();\n+\t  current_char = peek_input ();\n+\t  additional_length_offset++;\n+\t}\n+      return std::make_pair (Codepoint (0), additional_length_offset);\n+    }\n \n+  skip_input ();\n+  current_char = peek_input ();\n+  additional_length_offset++;\n+\n+  if (current_char == '_')\n+    {\n+      rust_error_at (get_current_location (),\n+\t\t     \"unicode escape cannot start with %<_%>\");\n       skip_input ();\n       current_char = peek_input ();\n       additional_length_offset++;\n+      // fallthrough and try to parse the rest anyway\n     }\n \n   // parse unicode escape - 1-6 hex digits\n@@ -1500,21 +1520,45 @@ Lexer::parse_partial_unicode_escape ()\n       current_char = peek_input ();\n     }\n \n-  // ensure closing brace if required\n-  if (need_close_brace)\n+  if (current_char == '}')\n     {\n-      if (current_char == '}')\n+      skip_input ();\n+      current_char = peek_input ();\n+      additional_length_offset++;\n+    }\n+  else\n+    {\n+      // actually an error, but allow propagation anyway Assume that\n+      // wrong bracketm whitespace or single/double quotes are wrong\n+      // termination, otherwise it is a wrong character, then skip to the actual\n+      // terminator.\n+      if (current_char == '{' || is_whitespace (current_char)\n+\t  || current_char == '\\'' || current_char == '\"')\n \t{\n-\t  skip_input ();\n-\t  current_char = peek_input ();\n-\t  additional_length_offset++;\n+\t  rust_error_at (get_current_location (),\n+\t\t\t \"expected terminating %<}%> in unicode escape\");\n+\t  return std::make_pair (Codepoint (0), additional_length_offset);\n \t}\n       else\n \t{\n-\t  // actually an error, but allow propagation anyway\n \t  rust_error_at (get_current_location (),\n-\t\t\t \"expected terminating %<}%> in unicode escape\");\n-\t  // return false;\n+\t\t\t \"invalid character %<%c%> in unicode escape\",\n+\t\t\t current_char);\n+\t  while (current_char != '}' && current_char != '{'\n+\t\t && !is_whitespace (current_char) && current_char != '\\''\n+\t\t && current_char != '\"')\n+\t    {\n+\t      skip_input ();\n+\t      current_char = peek_input ();\n+\t      additional_length_offset++;\n+\t    }\n+\t  // Consume the actual closing bracket if found\n+\t  if (current_char == '}')\n+\t    {\n+\t      skip_input ();\n+\t      current_char = peek_input ();\n+\t      additional_length_offset++;\n+\t    }\n \t  return std::make_pair (Codepoint (0), additional_length_offset);\n \t}\n     }\n@@ -1530,10 +1574,22 @@ Lexer::parse_partial_unicode_escape ()\n       return std::make_pair (Codepoint (0), additional_length_offset);\n     }\n \n-  long hex_num = std::strtol (num_str.c_str (), nullptr, 16);\n+  unsigned long hex_num = std::strtoul (num_str.c_str (), nullptr, 16);\n \n-  // assert fits a uint32_t\n-  gcc_assert (hex_num < 4294967296);\n+  if (hex_num > 0xd7ff && hex_num < 0xe000)\n+    {\n+      rust_error_at (\n+\tget_current_location (),\n+\t\"unicode escape cannot be a surrogate value (D800 to DFFF)\");\n+      return std::make_pair (Codepoint (0), additional_length_offset);\n+    }\n+\n+  if (hex_num > 0x10ffff)\n+    {\n+      rust_error_at (get_current_location (),\n+\t\t     \"unicode escape cannot be larger than 10FFFF\");\n+      return std::make_pair (Codepoint (0), additional_length_offset);\n+    }\n \n   // return true;\n   return std::make_pair (Codepoint (static_cast<uint32_t> (hex_num)),"}, {"sha": "28b985108cf1b3512194db3af13729adf0f4a94e", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 39, "deletions": 5, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99c28309d3553346d4f0337dbae49f4a8e48da01/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99c28309d3553346d4f0337dbae49f4a8e48da01/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=99c28309d3553346d4f0337dbae49f4a8e48da01", "patch": "@@ -609,15 +609,49 @@ class TypeCheckExpr : public TypeCheckBase\n \tbreak;\n \n \tcase HIR::Literal::LitType::BYTE_STRING: {\n-\t  /* We just treat this as a string, but it really is an arraytype of\n-\t     u8. It isn't in UTF-8, but really just a byte array.  */\n-\t  TyTy::BaseType *base = nullptr;\n-\t  auto ok = context->lookup_builtin (\"str\", &base);\n+\t  /* This is an arraytype of u8 reference (&[u8;size]). It isn't in\n+\t     UTF-8, but really just a byte array. Code to construct the array\n+\t     reference copied from ArrayElemsValues and ArrayType. */\n+\t  TyTy::BaseType *u8;\n+\t  auto ok = context->lookup_builtin (\"u8\", &u8);\n \t  rust_assert (ok);\n \n+\t  auto crate_num = mappings->get_current_crate ();\n+\t  Analysis::NodeMapping capacity_mapping (crate_num, UNKNOWN_NODEID,\n+\t\t\t\t\t\t  mappings->get_next_hir_id (\n+\t\t\t\t\t\t    crate_num),\n+\t\t\t\t\t\t  UNKNOWN_LOCAL_DEFID);\n+\n+\t  /* Capacity is the size of the string (number of chars).\n+\t     It is a constant, but for fold it to get a Bexpression.  */\n+\t  std::string capacity_str\n+\t    = std::to_string (expr.get_literal ()->as_string ().size ());\n+\t  HIR::LiteralExpr literal_capacity (capacity_mapping, capacity_str,\n+\t\t\t\t\t     HIR::Literal::LitType::INT,\n+\t\t\t\t\t     PrimitiveCoreType::CORETYPE_USIZE,\n+\t\t\t\t\t     expr.get_locus ());\n+\n+\t  // mark the type for this implicit node\n+\t  context->insert_type (capacity_mapping,\n+\t\t\t\tnew TyTy::USizeType (\n+\t\t\t\t  capacity_mapping.get_hirid ()));\n+\n+\t  Bexpression *capacity\n+\t    = ConstFold::ConstFoldExpr::fold (&literal_capacity);\n+\n+\t  Analysis::NodeMapping array_mapping (crate_num, UNKNOWN_NODEID,\n+\t\t\t\t\t       mappings->get_next_hir_id (\n+\t\t\t\t\t\t crate_num),\n+\t\t\t\t\t       UNKNOWN_LOCAL_DEFID);\n+\n+\t  TyTy::ArrayType *array\n+\t    = new TyTy::ArrayType (array_mapping.get_hirid (), capacity,\n+\t\t\t\t   TyTy::TyVar (u8->get_ref ()));\n+\t  context->insert_type (array_mapping, array);\n+\n \t  infered\n \t    = new TyTy::ReferenceType (expr.get_mappings ().get_hirid (),\n-\t\t\t\t       TyTy::TyVar (base->get_ref ()), false);\n+\t\t\t\t       TyTy::TyVar (array->get_ref ()), false);\n \t}\n \tbreak;\n "}, {"sha": "28934d2581d95b8d3f8a27c9ef2a523e1d8bfb68", "filename": "gcc/testsuite/rust/compile/torture/byte_str.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99c28309d3553346d4f0337dbae49f4a8e48da01/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fbyte_str.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99c28309d3553346d4f0337dbae49f4a8e48da01/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fbyte_str.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fbyte_str.rs?ref=99c28309d3553346d4f0337dbae49f4a8e48da01", "patch": "@@ -0,0 +1,4 @@\n+pub fn main() {\n+    let a: &[u8; 4];\n+    a = b\"test\";\n+}"}, {"sha": "39b91d8a95c3cb6a6b24fbfa6dfa06ab14105e48", "filename": "gcc/testsuite/rust/compile/unicode_escape.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99c28309d3553346d4f0337dbae49f4a8e48da01/gcc%2Ftestsuite%2Frust%2Fcompile%2Funicode_escape.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99c28309d3553346d4f0337dbae49f4a8e48da01/gcc%2Ftestsuite%2Frust%2Fcompile%2Funicode_escape.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Funicode_escape.rs?ref=99c28309d3553346d4f0337dbae49f4a8e48da01", "patch": "@@ -0,0 +1,60 @@\n+fn main ()\n+{\n+  // Braces are required\n+  let _cbl = '\\u013'; // { dg-error \"unicode escape\" }\n+  let _sbl = \"\\u013\"; //{ dg-error \"unicode escape\" }\n+\n+  // One to six hex digits\n+  let _c0 = '\\u{}'; // { dg-error \"unicode escape\" }\n+  let _c1 = '\\u{0}';\n+  let _c2 = '\\u{00}';\n+  let _c3 = '\\u{000}';\n+  let _c4 = '\\u{0000}';\n+  let _c5 = '\\u{00000}';\n+  let _c6 = '\\u{000000}';\n+  let _c7 = '\\u{0000000}'; // { dg-error \"unicode escape\" }\n+\n+  let _s0 = \"\\u{}\"; // { dg-error \"unicode escape\" }\n+  let _s1 = \"\\u{0}\";\n+  let _s2 = \"\\u{00}\";\n+  let _s3 = \"\\u{000}\";\n+  let _s4 = \"\\u{0000}\";\n+  let _s5 = \"\\u{00000}\";\n+  let _s6 = \"\\u{000000}\";\n+  let _s7 = \"\\u{0000000}\"; // { dg-error \"unicode escape\" }\n+\n+  // Underscores OK except for start\n+  let _c_ = '\\u{00___01__0_1_}';\n+  let _s_ = \"\\u{00___01__0_1_}\";\n+  let _c__ = '\\u{_00__01__0_}'; // { dg-error \"unicode escape\" }\n+  let _s__ = \"\\u{_00__01__0_}\"; // { dg-error \"unicode escape\" }\n+\n+  // Must be hex chars\n+  let _chex = '\\u{hex}';  // { dg-error \"unicode escape\" }\n+  let _shex = '\\u{hex}';  // { dg-error \"unicode escape\" }\n+\n+  // Only valid from 0x0 to 0xD7FF and from 0xE000 to 0x10FFF\n+  let _cd7ff = '\\u{D7FF}';\n+  let _sd7ff = \"\\u{D7FF}\";\n+  let _cd800 = '\\u{D800}'; // { dg-error \"unicode escape\" }\n+  let _sd800 = \"\\u{D800}\"; // { dg-error \"unicode escape\" }\n+\n+  let _cdfff = '\\u{DFFF}'; // { dg-error \"unicode escape\" }\n+  let _sdfff = \"\\u{DFFF}\"; // { dg-error \"unicode escape\" }\n+  let _ce000 = '\\u{E000}';\n+  let _se000 = \"\\u{E000}\";\n+\n+  let _clast = '\\u{10FFFF}';\n+  let _slast = \"\\u{10FFFF}\";\n+  let _clast1 = '\\u{110000}'; // { dg-error \"unicode escape\" }\n+  let _slast1 = \"\\u{110000}\"; // { dg-error \"unicode escape\" }\n+\n+  let _cffffff = '\\u{FFFFFF}'; // { dg-error \"unicode escape\" }\n+  let _sffffff = \"\\u{FFFFFF}\"; // { dg-error \"unicode escape\" }\n+\n+  // unicode escapes cannot be used in bytes or byte strings.\n+  // Except in raw byte strings (where they aren't escapes).\n+  let _bc = b'\\u{000A}'; // { dg-error \"unicode escape\" }\n+  let _bs = b\"\\u{000A}\"; // { dg-error \"unicode escape\" }\n+  let _rbs = br\"\\u{000A}\";\n+}"}]}