{"sha": "7a1aca9c426e2723c731f1f3e006e8b03265616a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2ExYWNhOWM0MjZlMjcyM2M3MzFmMWYzZTAwNmU4YjAzMjY1NjE2YQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2012-04-26T15:49:30Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2012-04-26T15:49:30Z"}, "message": "sched-int.h (_haifa_insn_data): Move priority_status.\n\ngcc/\n\t* sched-int.h (_haifa_insn_data): Move priority_status.\n\tAdd model_index.\n\t(INSN_MODEL_INDEX): New macro.\n\t* haifa-sched.c (insn_delay): New function.\n\t(sched_regno_pressure_class): Update commentary.\n\t(mark_regno_birth_or_death): Pass the liveness bitmap and\n\tpressure array as arguments, instead of using curr_reg_live and\n\tcurr_reg_pressure.  Only update the pressure if the bit in the\n\tliveness set has changed.\n\t(initiate_reg_pressure_info): Always trust the live-in set for\n\tSCHED_PRESSURE_MODEL.\n\t(initiate_bb_reg_pressure_info): Update call to\n\tmark_regno_birth_or_death.\n\t(dep_list_size): Take the list as argument.\n\t(calculate_reg_deaths): New function, extracted from...\n\t(setup_insn_reg_pressure_info): ...here.\n\t(MODEL_BAR): New macro.\n\t(model_pressure_data, model_insn_info, model_pressure_limit)\n\t(model_pressure_group): New structures.\n\t(model_schedule, model_worklist, model_insns, model_num_insns)\n\t(model_curr_point, model_before_pressure, model_next_priority):\n\tNew variables.\n\t(MODEL_PRESSURE_DATA, MODEL_MAX_PRESSURE, MODEL_REF_PRESSURE)\n\t(MODEL_INSN_INFO, MODEL_INSN): New macros.\n\t(model_index, model_update_limit_points_in_group): New functions.\n\t(model_update_limit_points, model_last_use_except): Likewise.\n\t(model_start_update_pressure, model_update_pressure): Likewise.\n\t(model_recompute, model_spill_cost, model_excess_group_cost): Likewise.\n\t(model_excess_cost, model_dump_pressure_points): Likewise.\n\t(model_set_excess_costs): Likewise.\n\t(rank_for_schedule): Extend SCHED_PRIORITY_WEIGHTED ordering to\n\tSCHED_PRIORITY_MODEL.  Use insn_delay.  Use the order in the model\n\tschedule as an alternative tie-breaker.  Update the call to\n\tdep_list_size.\n\t(ready_sort): Call model_set_excess_costs.\n\t(update_register_pressure): Update call to mark_regno_birth_or_death.\n\tRely on that function to check liveness rather than doing it here.\n\t(model_classify_pressure, model_order_p, model_add_to_worklist_at)\n\t(model_remove_from_worklist, model_add_to_worklist, model_promote_insn)\n\t(model_add_to_schedule, model_analyze_insns, model_init_pressure_group)\n\t(model_record_pressure, model_record_pressures): New functions.\n\t(model_record_final_pressures, model_add_successors_to_worklist)\n\t(model_promote_predecessors, model_choose_insn): Likewise.\n\t(model_reset_queue_indices, model_dump_pressure_summary): Likewise.\n\t(model_start_schedule, model_finalize_pressure_group): Likewise.\n\t(model_end_schedule): Likewise.\n\t(schedule_insn): Say when we're scheduling the next instruction\n\tin the model schedule.\n\t(schedule_insn): Handle SCHED_PRESSURE_MODEL.\n\t(queue_to_ready): Do not add instructions that are\n\tMAX_SCHED_READY_INSNS beyond the current point of the model schedule.\n\tAlways allow the next instruction in the model schedule to be added.\n\t(debug_ready_list): Print the INSN_REG_PRESSURE_EXCESS_COST_CHANGE\n\tand delay for SCHED_PRESSURE_MODEL too.\n\t(prune_ready_list): Extend SCHED_PRIORITY_WEIGHTED handling to\n\tSCHED_PRIORITY_MODEL, but also take the DFA into account.\n\t(schedule_block): Call model_start_schedule and model_end_schedule.\n\tExtend SCHED_PRIORITY_WEIGHTED stall handling to SCHED_PRIORITY_MODEL.\n\t(sched_init): Extend INSN_REG_PRESSURE_EXCESS_COST_CHANGE handling\n\tto SCHED_PRESSURE_MODEL, but don't allocate saved_reg_live or\n\tregion_ref_regs.\n\t(sched_finish): Update accordingly.\n\t(fix_tick_ready): Extend INSN_REG_PRESSURE_EXCESS_COST_CHANGE handling\n\tto SCHED_PRESSURE_MODEL.\n\t(add_jump_dependencies): Update call to dep_list_size.\n\t(haifa_finish_h_i_d): Fix leak of max_reg_pressure.\n\t(haifa_init_insn): Extend INSN_REG_PRESSURE_EXCESS_COST_CHANGE handling\n\tto SCHED_PRESSURE_MODEL.\n\t* sched-deps.c (init_insn_reg_pressure_info): Likewise, but don't\n\tallocate INSN_MAX_REG_PRESSURE for SCHED_PRESSURE_MODEL.\n\t(sched_analyze_insn): Extend INSN_REG_PRESSURE_EXCESS_COST_CHANGE\n\thandling to SCHED_PRESSURE_MODEL.\n\nFrom-SVN: r186882", "tree": {"sha": "e56ccaafc3cad4864a20e07e80010ba4569da004", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e56ccaafc3cad4864a20e07e80010ba4569da004"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7a1aca9c426e2723c731f1f3e006e8b03265616a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a1aca9c426e2723c731f1f3e006e8b03265616a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a1aca9c426e2723c731f1f3e006e8b03265616a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a1aca9c426e2723c731f1f3e006e8b03265616a/comments", "author": null, "committer": null, "parents": [{"sha": "60867e8c63a99fe6df24d0a0a7f53b6545a92cad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60867e8c63a99fe6df24d0a0a7f53b6545a92cad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60867e8c63a99fe6df24d0a0a7f53b6545a92cad"}], "stats": {"total": 1678, "additions": 1602, "deletions": 76}, "files": [{"sha": "865cfd60544c24eebae9b4e8b65a4aaf7159c953", "filename": "gcc/ChangeLog", "status": "modified", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a1aca9c426e2723c731f1f3e006e8b03265616a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a1aca9c426e2723c731f1f3e006e8b03265616a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7a1aca9c426e2723c731f1f3e006e8b03265616a", "patch": "@@ -1,3 +1,78 @@\n+2012-04-26  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* sched-int.h (_haifa_insn_data): Move priority_status.\n+\tAdd model_index.\n+\t(INSN_MODEL_INDEX): New macro.\n+\t* haifa-sched.c (insn_delay): New function.\n+\t(sched_regno_pressure_class): Update commentary.\n+\t(mark_regno_birth_or_death): Pass the liveness bitmap and\n+\tpressure array as arguments, instead of using curr_reg_live and\n+\tcurr_reg_pressure.  Only update the pressure if the bit in the\n+\tliveness set has changed.\n+\t(initiate_reg_pressure_info): Always trust the live-in set for\n+\tSCHED_PRESSURE_MODEL.\n+\t(initiate_bb_reg_pressure_info): Update call to\n+\tmark_regno_birth_or_death.\n+\t(dep_list_size): Take the list as argument.\n+\t(calculate_reg_deaths): New function, extracted from...\n+\t(setup_insn_reg_pressure_info): ...here.\n+\t(MODEL_BAR): New macro.\n+\t(model_pressure_data, model_insn_info, model_pressure_limit)\n+\t(model_pressure_group): New structures.\n+\t(model_schedule, model_worklist, model_insns, model_num_insns)\n+\t(model_curr_point, model_before_pressure, model_next_priority):\n+\tNew variables.\n+\t(MODEL_PRESSURE_DATA, MODEL_MAX_PRESSURE, MODEL_REF_PRESSURE)\n+\t(MODEL_INSN_INFO, MODEL_INSN): New macros.\n+\t(model_index, model_update_limit_points_in_group): New functions.\n+\t(model_update_limit_points, model_last_use_except): Likewise.\n+\t(model_start_update_pressure, model_update_pressure): Likewise.\n+\t(model_recompute, model_spill_cost, model_excess_group_cost): Likewise.\n+\t(model_excess_cost, model_dump_pressure_points): Likewise.\n+\t(model_set_excess_costs): Likewise.\n+\t(rank_for_schedule): Extend SCHED_PRIORITY_WEIGHTED ordering to\n+\tSCHED_PRIORITY_MODEL.  Use insn_delay.  Use the order in the model\n+\tschedule as an alternative tie-breaker.  Update the call to\n+\tdep_list_size.\n+\t(ready_sort): Call model_set_excess_costs.\n+\t(update_register_pressure): Update call to mark_regno_birth_or_death.\n+\tRely on that function to check liveness rather than doing it here.\n+\t(model_classify_pressure, model_order_p, model_add_to_worklist_at)\n+\t(model_remove_from_worklist, model_add_to_worklist, model_promote_insn)\n+\t(model_add_to_schedule, model_analyze_insns, model_init_pressure_group)\n+\t(model_record_pressure, model_record_pressures): New functions.\n+\t(model_record_final_pressures, model_add_successors_to_worklist)\n+\t(model_promote_predecessors, model_choose_insn): Likewise.\n+\t(model_reset_queue_indices, model_dump_pressure_summary): Likewise.\n+\t(model_start_schedule, model_finalize_pressure_group): Likewise.\n+\t(model_end_schedule): Likewise.\n+\t(schedule_insn): Say when we're scheduling the next instruction\n+\tin the model schedule.\n+\t(schedule_insn): Handle SCHED_PRESSURE_MODEL.\n+\t(queue_to_ready): Do not add instructions that are\n+\tMAX_SCHED_READY_INSNS beyond the current point of the model schedule.\n+\tAlways allow the next instruction in the model schedule to be added.\n+\t(debug_ready_list): Print the INSN_REG_PRESSURE_EXCESS_COST_CHANGE\n+\tand delay for SCHED_PRESSURE_MODEL too.\n+\t(prune_ready_list): Extend SCHED_PRIORITY_WEIGHTED handling to\n+\tSCHED_PRIORITY_MODEL, but also take the DFA into account.\n+\t(schedule_block): Call model_start_schedule and model_end_schedule.\n+\tExtend SCHED_PRIORITY_WEIGHTED stall handling to SCHED_PRIORITY_MODEL.\n+\t(sched_init): Extend INSN_REG_PRESSURE_EXCESS_COST_CHANGE handling\n+\tto SCHED_PRESSURE_MODEL, but don't allocate saved_reg_live or\n+\tregion_ref_regs.\n+\t(sched_finish): Update accordingly.\n+\t(fix_tick_ready): Extend INSN_REG_PRESSURE_EXCESS_COST_CHANGE handling\n+\tto SCHED_PRESSURE_MODEL.\n+\t(add_jump_dependencies): Update call to dep_list_size.\n+\t(haifa_finish_h_i_d): Fix leak of max_reg_pressure.\n+\t(haifa_init_insn): Extend INSN_REG_PRESSURE_EXCESS_COST_CHANGE handling\n+\tto SCHED_PRESSURE_MODEL.\n+\t* sched-deps.c (init_insn_reg_pressure_info): Likewise, but don't\n+\tallocate INSN_MAX_REG_PRESSURE for SCHED_PRESSURE_MODEL.\n+\t(sched_analyze_insn): Extend INSN_REG_PRESSURE_EXCESS_COST_CHANGE\n+\thandling to SCHED_PRESSURE_MODEL.\n+\n 2012-04-26  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* common.opt (fsched-pressure-algorithm=): New option."}, {"sha": "869159c036fad3fefdb025594b7e3196f7b1ffc0", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 1515, "deletions": 67, "changes": 1582, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a1aca9c426e2723c731f1f3e006e8b03265616a/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a1aca9c426e2723c731f1f3e006e8b03265616a/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=7a1aca9c426e2723c731f1f3e006e8b03265616a", "patch": "@@ -398,6 +398,14 @@ basic_block (* sched_split_block) (basic_block, rtx);\n /* Create empty basic block after the specified block.  */\n basic_block (* sched_create_empty_bb) (basic_block);\n \n+/* Return the number of cycles until INSN is expected to be ready.\n+   Return zero if it already is.  */\n+static int\n+insn_delay (rtx insn)\n+{\n+  return MAX (INSN_TICK (insn) - clock_var, 0);\n+}\n+\n static int\n may_trap_exp (const_rtx x, int is_store)\n {\n@@ -875,7 +883,7 @@ schedule_insns (void)\n enum sched_pressure_algorithm sched_pressure;\n \n /* Map regno -> its pressure class.  The map defined only when\n-   SCHED_PRESSURE is SCHED_PRESSURE_WEIGHTED.  */\n+   SCHED_PRESSURE != SCHED_PRESSURE_NONE.  */\n enum reg_class *sched_regno_pressure_class;\n \n /* The current register pressure.  Only elements corresponding pressure\n@@ -903,10 +911,12 @@ sched_init_region_reg_pressure_info (void)\n   bitmap_clear (region_ref_regs);\n }\n \n-/* Update current register pressure related info after birth (if\n-   BIRTH_P) or death of register REGNO.  */\n-static void\n-mark_regno_birth_or_death (int regno, bool birth_p)\n+/* PRESSURE[CL] describes the pressure on register class CL.  Update it\n+   for the birth (if BIRTH_P) or death (if !BIRTH_P) of register REGNO.\n+   LIVE tracks the set of live registers; if it is null, assume that\n+   every birth or death is genuine.  */\n+static inline void\n+mark_regno_birth_or_death (bitmap live, int *pressure, int regno, bool birth_p)\n {\n   enum reg_class pressure_class;\n \n@@ -917,17 +927,17 @@ mark_regno_birth_or_death (int regno, bool birth_p)\n \t{\n \t  if (birth_p)\n \t    {\n-\t      bitmap_set_bit (curr_reg_live, regno);\n-\t      curr_reg_pressure[pressure_class]\n-\t\t+= (ira_reg_class_max_nregs\n-\t\t    [pressure_class][PSEUDO_REGNO_MODE (regno)]);\n+\t      if (!live || bitmap_set_bit (live, regno))\n+\t\tpressure[pressure_class]\n+\t\t  += (ira_reg_class_max_nregs\n+\t\t      [pressure_class][PSEUDO_REGNO_MODE (regno)]);\n \t    }\n \t  else\n \t    {\n-\t      bitmap_clear_bit (curr_reg_live, regno);\n-\t      curr_reg_pressure[pressure_class]\n-\t\t-= (ira_reg_class_max_nregs\n-\t\t    [pressure_class][PSEUDO_REGNO_MODE (regno)]);\n+\t      if (!live || bitmap_clear_bit (live, regno))\n+\t\tpressure[pressure_class]\n+\t\t  -= (ira_reg_class_max_nregs\n+\t\t      [pressure_class][PSEUDO_REGNO_MODE (regno)]);\n \t    }\n \t}\n     }\n@@ -936,13 +946,13 @@ mark_regno_birth_or_death (int regno, bool birth_p)\n     {\n       if (birth_p)\n \t{\n-\t  bitmap_set_bit (curr_reg_live, regno);\n-\t  curr_reg_pressure[pressure_class]++;\n+\t  if (!live || bitmap_set_bit (live, regno))\n+\t    pressure[pressure_class]++;\n \t}\n       else\n \t{\n-\t  bitmap_clear_bit (curr_reg_live, regno);\n-\t  curr_reg_pressure[pressure_class]--;\n+\t  if (!live || bitmap_clear_bit (live, regno))\n+\t    pressure[pressure_class]--;\n \t}\n     }\n }\n@@ -960,8 +970,10 @@ initiate_reg_pressure_info (bitmap live)\n     curr_reg_pressure[ira_pressure_classes[i]] = 0;\n   bitmap_clear (curr_reg_live);\n   EXECUTE_IF_SET_IN_BITMAP (live, 0, j, bi)\n-    if (current_nr_blocks == 1 || bitmap_bit_p (region_ref_regs, j))\n-      mark_regno_birth_or_death (j, true);\n+    if (sched_pressure == SCHED_PRESSURE_MODEL\n+\t|| current_nr_blocks == 1\n+\t|| bitmap_bit_p (region_ref_regs, j))\n+      mark_regno_birth_or_death (curr_reg_live, curr_reg_pressure, j, true);\n }\n \n /* Mark registers in X as mentioned in the current region.  */\n@@ -1015,7 +1027,8 @@ initiate_bb_reg_pressure_info (basic_block bb)\n \tif (regno == INVALID_REGNUM)\n \t  break;\n \tif (! bitmap_bit_p (df_get_live_in (bb), regno))\n-\t  mark_regno_birth_or_death (regno, true);\n+\t  mark_regno_birth_or_death (curr_reg_live, curr_reg_pressure,\n+\t\t\t\t     regno, true);\n       }\n #endif\n }\n@@ -1445,27 +1458,27 @@ contributes_to_priority_p (dep_t dep)\n   return true;\n }\n \n-/* Compute the number of nondebug forward deps of an insn.  */\n+/* Compute the number of nondebug deps in list LIST for INSN.  */\n \n static int\n-dep_list_size (rtx insn)\n+dep_list_size (rtx insn, sd_list_types_def list)\n {\n   sd_iterator_def sd_it;\n   dep_t dep;\n   int dbgcount = 0, nodbgcount = 0;\n \n   if (!MAY_HAVE_DEBUG_INSNS)\n-    return sd_lists_size (insn, SD_LIST_FORW);\n+    return sd_lists_size (insn, list);\n \n-  FOR_EACH_DEP (insn, SD_LIST_FORW, sd_it, dep)\n+  FOR_EACH_DEP (insn, list, sd_it, dep)\n     {\n       if (DEBUG_INSN_P (DEP_CON (dep)))\n \tdbgcount++;\n       else if (!DEBUG_INSN_P (DEP_PRO (dep)))\n \tnodbgcount++;\n     }\n \n-  gcc_assert (dbgcount + nodbgcount == sd_lists_size (insn, SD_LIST_FORW));\n+  gcc_assert (dbgcount + nodbgcount == sd_lists_size (insn, list));\n \n   return nodbgcount;\n }\n@@ -1484,7 +1497,7 @@ priority (rtx insn)\n     {\n       int this_priority = -1;\n \n-      if (dep_list_size (insn) == 0)\n+      if (dep_list_size (insn, SD_LIST_FORW) == 0)\n \t/* ??? We should set INSN_PRIORITY to insn_cost when and insn has\n \t   some forward deps but all of them are ignored by\n \t   contributes_to_priority hook.  At the moment we set priority of\n@@ -1580,6 +1593,22 @@ do { if ((N_READY) == 2)\t\t\t\t             \\\n          qsort (READY, N_READY, sizeof (rtx), rank_for_schedule); }  \\\n while (0)\n \n+/* For each pressure class CL, set DEATH[CL] to the number of registers\n+   in that class that die in INSN.  */\n+\n+static void\n+calculate_reg_deaths (rtx insn, int *death)\n+{\n+  int i;\n+  struct reg_use_data *use;\n+\n+  for (i = 0; i < ira_pressure_classes_num; i++)\n+    death[ira_pressure_classes[i]] = 0;\n+  for (use = INSN_REG_USE_LIST (insn); use != NULL; use = use->next_insn_use)\n+    if (dying_use_p (use))\n+      mark_regno_birth_or_death (0, death, use->regno, true);\n+}\n+\n /* Setup info about the current register pressure impact of scheduling\n    INSN at the current scheduling point.  */\n static void\n@@ -1591,24 +1620,12 @@ setup_insn_reg_pressure_info (rtx insn)\n   enum reg_class cl;\n   struct reg_pressure_data *pressure_info;\n   int *max_reg_pressure;\n-  struct reg_use_data *use;\n   static int death[N_REG_CLASSES];\n \n   gcc_checking_assert (!DEBUG_INSN_P (insn));\n \n   excess_cost_change = 0;\n-  for (i = 0; i < ira_pressure_classes_num; i++)\n-    death[ira_pressure_classes[i]] = 0;\n-  for (use = INSN_REG_USE_LIST (insn); use != NULL; use = use->next_insn_use)\n-    if (dying_use_p (use))\n-      {\n-\tcl = sched_regno_pressure_class[use->regno];\n-\tif (use->regno < FIRST_PSEUDO_REGISTER)\n-\t  death[cl]++;\n-\telse\n-\t  death[cl]\n-\t    += ira_reg_class_max_nregs[cl][PSEUDO_REGNO_MODE (use->regno)];\n-      }\n+  calculate_reg_deaths (insn, death);\n   pressure_info = INSN_REG_PRESSURE (insn);\n   max_reg_pressure = INSN_MAX_REG_PRESSURE (insn);\n   gcc_assert (pressure_info != NULL && max_reg_pressure != NULL);\n@@ -1629,7 +1646,765 @@ setup_insn_reg_pressure_info (rtx insn)\n     }\n   INSN_REG_PRESSURE_EXCESS_COST_CHANGE (insn) = excess_cost_change;\n }\n+\f\n+/* This is the first page of code related to SCHED_PRESSURE_MODEL.\n+   It tries to make the scheduler take register pressure into account\n+   without introducing too many unnecessary stalls.  It hooks into the\n+   main scheduling algorithm at several points:\n+\n+    - Before scheduling starts, model_start_schedule constructs a\n+      \"model schedule\" for the current block.  This model schedule is\n+      chosen solely to keep register pressure down.  It does not take the\n+      target's pipeline or the original instruction order into account,\n+      except as a tie-breaker.  It also doesn't work to a particular\n+      pressure limit.\n+\n+      This model schedule gives us an idea of what pressure can be\n+      achieved for the block and gives us an example of a schedule that\n+      keeps to that pressure.  It also makes the final schedule less\n+      dependent on the original instruction order.  This is important\n+      because the original order can either be \"wide\" (many values live\n+      at once, such as in user-scheduled code) or \"narrow\" (few values\n+      live at once, such as after loop unrolling, where several\n+      iterations are executed sequentially).\n+\n+      We do not apply this model schedule to the rtx stream.  We simply\n+      record it in model_schedule.  We also compute the maximum pressure,\n+      MP, that was seen during this schedule.\n+\n+    - Instructions are added to the ready queue even if they require\n+      a stall.  The length of the stall is instead computed as:\n+\n+\t MAX (INSN_TICK (INSN) - clock_var, 0)\n+\n+      (= insn_delay).  This allows rank_for_schedule to choose between\n+      introducing a deliberate stall or increasing pressure.\n+\n+    - Before sorting the ready queue, model_set_excess_costs assigns\n+      a pressure-based cost to each ready instruction in the queue.\n+      This is the instruction's INSN_REG_PRESSURE_EXCESS_COST_CHANGE\n+      (ECC for short) and is effectively measured in cycles.\n+\n+    - rank_for_schedule ranks instructions based on:\n+\n+\tECC (insn) + insn_delay (insn)\n+\n+      then as:\n+\n+\tinsn_delay (insn)\n+\n+      So, for example, an instruction X1 with an ECC of 1 that can issue\n+      now will win over an instruction X0 with an ECC of zero that would\n+      introduce a stall of one cycle.  However, an instruction X2 with an\n+      ECC of 2 that can issue now will lose to both X0 and X1.\n+\n+    - When an instruction is scheduled, model_recompute updates the model\n+      schedule with the new pressures (some of which might now exceed the\n+      original maximum pressure MP).  model_update_limit_points then searches\n+      for the new point of maximum pressure, if not already known.  */\n+\n+/* Used to separate high-verbosity debug information for SCHED_PRESSURE_MODEL\n+   from surrounding debug information.  */\n+#define MODEL_BAR \\\n+  \";;\\t\\t+------------------------------------------------------\\n\"\n+\n+/* Information about the pressure on a particular register class at a\n+   particular point of the model schedule.  */\n+struct model_pressure_data {\n+  /* The pressure at this point of the model schedule, or -1 if the\n+     point is associated with an instruction that has already been\n+     scheduled.  */\n+  int ref_pressure;\n+\n+  /* The maximum pressure during or after this point of the model schedule.  */\n+  int max_pressure;\n+};\n+\n+/* Per-instruction information that is used while building the model\n+   schedule.  Here, \"schedule\" refers to the model schedule rather\n+   than the main schedule.  */\n+struct model_insn_info {\n+  /* The instruction itself.  */\n+  rtx insn;\n+\n+  /* If this instruction is in model_worklist, these fields link to the\n+     previous (higher-priority) and next (lower-priority) instructions\n+     in the list.  */\n+  struct model_insn_info *prev;\n+  struct model_insn_info *next;\n+\n+  /* While constructing the schedule, QUEUE_INDEX describes whether an\n+     instruction has already been added to the schedule (QUEUE_SCHEDULED),\n+     is in model_worklist (QUEUE_READY), or neither (QUEUE_NOWHERE).\n+     old_queue records the value that QUEUE_INDEX had before scheduling\n+     started, so that we can restore it once the schedule is complete.  */\n+  int old_queue;\n+\n+  /* The relative importance of an unscheduled instruction.  Higher\n+     values indicate greater importance.  */\n+  unsigned int model_priority;\n+\n+  /* The length of the longest path of satisfied true dependencies\n+     that leads to this instruction.  */\n+  unsigned int depth;\n+\n+  /* The length of the longest path of dependencies of any kind\n+     that leads from this instruction.  */\n+  unsigned int alap;\n+\n+  /* The number of predecessor nodes that must still be scheduled.  */\n+  int unscheduled_preds;\n+};\n+\n+/* Information about the pressure limit for a particular register class.\n+   This structure is used when applying a model schedule to the main\n+   schedule.  */\n+struct model_pressure_limit {\n+  /* The maximum register pressure seen in the original model schedule.  */\n+  int orig_pressure;\n+\n+  /* The maximum register pressure seen in the current model schedule\n+     (which excludes instructions that have already been scheduled).  */\n+  int pressure;\n+\n+  /* The point of the current model schedule at which PRESSURE is first\n+     reached.  It is set to -1 if the value needs to be recomputed.  */\n+  int point;\n+};\n+\n+/* Describes a particular way of measuring register pressure.  */\n+struct model_pressure_group {\n+  /* Index PCI describes the maximum pressure on ira_pressure_classes[PCI].  */\n+  struct model_pressure_limit limits[N_REG_CLASSES];\n+\n+  /* Index (POINT * ira_num_pressure_classes + PCI) describes the pressure\n+     on register class ira_pressure_classes[PCI] at point POINT of the\n+     current model schedule.  A POINT of model_num_insns describes the\n+     pressure at the end of the schedule.  */\n+  struct model_pressure_data *model;\n+};\n+\n+/* Index POINT gives the instruction at point POINT of the model schedule.\n+   This array doesn't change during main scheduling.  */\n+static VEC (rtx, heap) *model_schedule;\n+\n+/* The list of instructions in the model worklist, sorted in order of\n+   decreasing priority.  */\n+static struct model_insn_info *model_worklist;\n+\n+/* Index I describes the instruction with INSN_LUID I.  */\n+static struct model_insn_info *model_insns;\n+\n+/* The number of instructions in the model schedule.  */\n+static int model_num_insns;\n+\n+/* The index of the first instruction in model_schedule that hasn't yet been\n+   added to the main schedule, or model_num_insns if all of them have.  */\n+static int model_curr_point;\n+\n+/* Describes the pressure before each instruction in the model schedule.  */\n+static struct model_pressure_group model_before_pressure;\n+\n+/* The first unused model_priority value (as used in model_insn_info).  */\n+static unsigned int model_next_priority;\n+\n+\n+/* The model_pressure_data for ira_pressure_classes[PCI] in GROUP\n+   at point POINT of the model schedule.  */\n+#define MODEL_PRESSURE_DATA(GROUP, POINT, PCI) \\\n+  (&(GROUP)->model[(POINT) * ira_pressure_classes_num + (PCI)])\n+\n+/* The maximum pressure on ira_pressure_classes[PCI] in GROUP at or\n+   after point POINT of the model schedule.  */\n+#define MODEL_MAX_PRESSURE(GROUP, POINT, PCI) \\\n+  (MODEL_PRESSURE_DATA (GROUP, POINT, PCI)->max_pressure)\n+\n+/* The pressure on ira_pressure_classes[PCI] in GROUP at point POINT\n+   of the model schedule.  */\n+#define MODEL_REF_PRESSURE(GROUP, POINT, PCI) \\\n+  (MODEL_PRESSURE_DATA (GROUP, POINT, PCI)->ref_pressure)\n+\n+/* Information about INSN that is used when creating the model schedule.  */\n+#define MODEL_INSN_INFO(INSN) \\\n+  (&model_insns[INSN_LUID (INSN)])\n+\n+/* The instruction at point POINT of the model schedule.  */\n+#define MODEL_INSN(POINT) \\\n+  (VEC_index (rtx, model_schedule, POINT))\n+\n+\n+/* Return INSN's index in the model schedule, or model_num_insns if it\n+   doesn't belong to that schedule.  */\n+\n+static int\n+model_index (rtx insn)\n+{\n+  if (INSN_MODEL_INDEX (insn) == 0)\n+    return model_num_insns;\n+  return INSN_MODEL_INDEX (insn) - 1;\n+}\n+\n+/* Make sure that GROUP->limits is up-to-date for the current point\n+   of the model schedule.  */\n+\n+static void\n+model_update_limit_points_in_group (struct model_pressure_group *group)\n+{\n+  int pci, max_pressure, point;\n+\n+  for (pci = 0; pci < ira_pressure_classes_num; pci++)\n+    {\n+      /* We may have passed the final point at which the pressure in\n+\t group->limits[pci].pressure was reached.  Update the limit if so.  */\n+      max_pressure = MODEL_MAX_PRESSURE (group, model_curr_point, pci);\n+      group->limits[pci].pressure = max_pressure;\n+\n+      /* Find the point at which MAX_PRESSURE is first reached.  We need\n+\t to search in three cases:\n+\n+\t - We've already moved past the previous pressure point.\n+\t   In this case we search forward from model_curr_point.\n+\n+\t - We scheduled the previous point of maximum pressure ahead of\n+\t   its position in the model schedule, but doing so didn't bring\n+\t   the pressure point earlier.  In this case we search forward\n+\t   from that previous pressure point.\n+\n+\t - Scheduling an instruction early caused the maximum pressure\n+\t   to decrease.  In this case we will have set the pressure\n+\t   point to -1, and we search forward from model_curr_point.  */\n+      point = MAX (group->limits[pci].point, model_curr_point);\n+      while (point < model_num_insns\n+\t     && MODEL_REF_PRESSURE (group, point, pci) < max_pressure)\n+\tpoint++;\n+      group->limits[pci].point = point;\n+\n+      gcc_assert (MODEL_REF_PRESSURE (group, point, pci) == max_pressure);\n+      gcc_assert (MODEL_MAX_PRESSURE (group, point, pci) == max_pressure);\n+    }\n+}\n+\n+/* Make sure that all register-pressure limits are up-to-date for the\n+   current position in the model schedule.  */\n+\n+static void\n+model_update_limit_points (void)\n+{\n+  model_update_limit_points_in_group (&model_before_pressure);\n+}\n+\n+/* Return the model_index of the last unscheduled use in chain USE\n+   outside of USE's instruction.  Return -1 if there are no other uses,\n+   or model_num_insns if the register is live at the end of the block.  */\n+\n+static int\n+model_last_use_except (struct reg_use_data *use)\n+{\n+  struct reg_use_data *next;\n+  int last, index;\n+\n+  last = -1;\n+  for (next = use->next_regno_use; next != use; next = next->next_regno_use)\n+    if (NONDEBUG_INSN_P (next->insn)\n+\t&& QUEUE_INDEX (next->insn) != QUEUE_SCHEDULED)\n+      {\n+\tindex = model_index (next->insn);\n+\tif (index == model_num_insns)\n+\t  return model_num_insns;\n+\tif (last < index)\n+\t  last = index;\n+      }\n+  return last;\n+}\n+\n+/* An instruction with model_index POINT has just been scheduled, and it\n+   adds DELTA to the pressure on ira_pressure_classes[PCI] after POINT - 1.\n+   Update MODEL_REF_PRESSURE (GROUP, POINT, PCI) and\n+   MODEL_MAX_PRESSURE (GROUP, POINT, PCI) accordingly.  */\n+\n+static void\n+model_start_update_pressure (struct model_pressure_group *group,\n+\t\t\t     int point, int pci, int delta)\n+{\n+  int next_max_pressure;\n+\n+  if (point == model_num_insns)\n+    {\n+      /* The instruction wasn't part of the model schedule; it was moved\n+\t from a different block.  Update the pressure for the end of\n+\t the model schedule.  */\n+      MODEL_REF_PRESSURE (group, point, pci) += delta;\n+      MODEL_MAX_PRESSURE (group, point, pci) += delta;\n+    }\n+  else\n+    {\n+      /* Record that this instruction has been scheduled.  Nothing now\n+\t changes between POINT and POINT + 1, so get the maximum pressure\n+\t from the latter.  If the maximum pressure decreases, the new\n+\t pressure point may be before POINT.  */\n+      MODEL_REF_PRESSURE (group, point, pci) = -1;\n+      next_max_pressure = MODEL_MAX_PRESSURE (group, point + 1, pci);\n+      if (MODEL_MAX_PRESSURE (group, point, pci) > next_max_pressure)\n+\t{\n+\t  MODEL_MAX_PRESSURE (group, point, pci) = next_max_pressure;\n+\t  if (group->limits[pci].point == point)\n+\t    group->limits[pci].point = -1;\n+\t}\n+    }\n+}\n+\n+/* Record that scheduling a later instruction has changed the pressure\n+   at point POINT of the model schedule by DELTA (which might be 0).\n+   Update GROUP accordingly.  Return nonzero if these changes might\n+   trigger changes to previous points as well.  */\n+\n+static int\n+model_update_pressure (struct model_pressure_group *group,\n+\t\t       int point, int pci, int delta)\n+{\n+  int ref_pressure, max_pressure, next_max_pressure;\n+\n+  /* If POINT hasn't yet been scheduled, update its pressure.  */\n+  ref_pressure = MODEL_REF_PRESSURE (group, point, pci);\n+  if (ref_pressure >= 0 && delta != 0)\n+    {\n+      ref_pressure += delta;\n+      MODEL_REF_PRESSURE (group, point, pci) = ref_pressure;\n+\n+      /* Check whether the maximum pressure in the overall schedule\n+\t has increased.  (This means that the MODEL_MAX_PRESSURE of\n+\t every point <= POINT will need to increae too; see below.)  */\n+      if (group->limits[pci].pressure < ref_pressure)\n+\tgroup->limits[pci].pressure = ref_pressure;\n+\n+      /* If we are at maximum pressure, and the maximum pressure\n+\t point was previously unknown or later than POINT,\n+\t bring it forward.  */\n+      if (group->limits[pci].pressure == ref_pressure\n+\t  && !IN_RANGE (group->limits[pci].point, 0, point))\n+\tgroup->limits[pci].point = point;\n+\n+      /* If POINT used to be the point of maximum pressure, but isn't\n+\t any longer, we need to recalculate it using a forward walk.  */\n+      if (group->limits[pci].pressure > ref_pressure\n+\t  && group->limits[pci].point == point)\n+\tgroup->limits[pci].point = -1;\n+    }\n+\n+  /* Update the maximum pressure at POINT.  Changes here might also\n+     affect the maximum pressure at POINT - 1.  */\n+  next_max_pressure = MODEL_MAX_PRESSURE (group, point + 1, pci);\n+  max_pressure = MAX (ref_pressure, next_max_pressure);\n+  if (MODEL_MAX_PRESSURE (group, point, pci) != max_pressure)\n+    {\n+      MODEL_MAX_PRESSURE (group, point, pci) = max_pressure;\n+      return 1;\n+    }\n+  return 0;\n+}\n+\n+/* INSN has just been scheduled.  Update the model schedule accordingly.  */\n+\n+static void\n+model_recompute (rtx insn)\n+{\n+  struct {\n+    int last_use;\n+    int regno;\n+  } uses[FIRST_PSEUDO_REGISTER + MAX_RECOG_OPERANDS];\n+  struct reg_use_data *use;\n+  struct reg_pressure_data *reg_pressure;\n+  int delta[N_REG_CLASSES];\n+  int pci, point, mix, new_last, cl, ref_pressure, queue;\n+  unsigned int i, num_uses, num_pending_births;\n+  bool print_p;\n+\n+  /* The destinations of INSN were previously live from POINT onwards, but are\n+     now live from model_curr_point onwards.  Set up DELTA accordingly.  */\n+  point = model_index (insn);\n+  reg_pressure = INSN_REG_PRESSURE (insn);\n+  for (pci = 0; pci < ira_pressure_classes_num; pci++)\n+    {\n+      cl = ira_pressure_classes[pci];\n+      delta[cl] = reg_pressure[pci].set_increase;\n+    }\n+\n+  /* Record which registers previously died at POINT, but which now die\n+     before POINT.  Adjust DELTA so that it represents the effect of\n+     this change after POINT - 1.  Set NUM_PENDING_BIRTHS to the number of\n+     registers that will be born in the range [model_curr_point, POINT).  */\n+  num_uses = 0;\n+  num_pending_births = 0;\n+  for (use = INSN_REG_USE_LIST (insn); use != NULL; use = use->next_insn_use)\n+    {\n+      new_last = model_last_use_except (use);\n+      if (new_last < point)\n+\t{\n+\t  gcc_assert (num_uses < ARRAY_SIZE (uses));\n+\t  uses[num_uses].last_use = new_last;\n+\t  uses[num_uses].regno = use->regno;\n+\t  /* This register is no longer live after POINT - 1.  */\n+\t  mark_regno_birth_or_death (NULL, delta, use->regno, false);\n+\t  num_uses++;\n+\t  if (new_last >= 0)\n+\t    num_pending_births++;\n+\t}\n+    }\n+\n+  /* Update the MODEL_REF_PRESSURE and MODEL_MAX_PRESSURE for POINT.\n+     Also set each group pressure limit for POINT.  */\n+  for (pci = 0; pci < ira_pressure_classes_num; pci++)\n+    {\n+      cl = ira_pressure_classes[pci];\n+      model_start_update_pressure (&model_before_pressure,\n+\t\t\t\t   point, pci, delta[cl]);\n+    }\n+\n+  /* Walk the model schedule backwards, starting immediately before POINT.  */\n+  print_p = false;\n+  if (point != model_curr_point)\n+    do\n+      {\n+\tpoint--;\n+\tinsn = MODEL_INSN (point);\n+\tqueue = QUEUE_INDEX (insn);\n+\n+\tif (queue != QUEUE_SCHEDULED)\n+\t  {\n+\t    /* DELTA describes the effect of the move on the register pressure\n+\t       after POINT.  Make it describe the effect on the pressure\n+\t       before POINT.  */\n+\t    i = 0;\n+\t    while (i < num_uses)\n+\t      {\n+\t\tif (uses[i].last_use == point)\n+\t\t  {\n+\t\t    /* This register is now live again.  */\n+\t\t    mark_regno_birth_or_death (NULL, delta,\n+\t\t\t\t\t       uses[i].regno, true);\n+\n+\t\t    /* Remove this use from the array.  */\n+\t\t    uses[i] = uses[num_uses - 1];\n+\t\t    num_uses--;\n+\t\t    num_pending_births--;\n+\t\t  }\n+\t\telse\n+\t\t  i++;\n+\t      }\n+\n+\t    if (sched_verbose >= 5)\n+\t      {\n+\t\tchar buf[2048];\n+\n+\t\tif (!print_p)\n+\t\t  {\n+\t\t    fprintf (sched_dump, MODEL_BAR);\n+\t\t    fprintf (sched_dump, \";;\\t\\t| New pressure for model\"\n+\t\t\t     \" schedule\\n\");\n+\t\t    fprintf (sched_dump, MODEL_BAR);\n+\t\t    print_p = true;\n+\t\t  }\n+\n+\t\tprint_pattern (buf, PATTERN (insn), 0);\n+\t\tfprintf (sched_dump, \";;\\t\\t| %3d %4d %-30s \",\n+\t\t\t point, INSN_UID (insn), buf);\n+\t\tfor (pci = 0; pci < ira_pressure_classes_num; pci++)\n+\t\t  {\n+\t\t    cl = ira_pressure_classes[pci];\n+\t\t    ref_pressure = MODEL_REF_PRESSURE (&model_before_pressure,\n+\t\t\t\t\t\t       point, pci);\n+\t\t    fprintf (sched_dump, \" %s:[%d->%d]\",\n+\t\t\t     reg_class_names[ira_pressure_classes[pci]],\n+\t\t\t     ref_pressure, ref_pressure + delta[cl]);\n+\t\t  }\n+\t\tfprintf (sched_dump, \"\\n\");\n+\t      }\n+\t  }\n+\n+\t/* Adjust the pressure at POINT.  Set MIX to nonzero if POINT - 1\n+\t   might have changed as well.  */\n+\tmix = num_pending_births;\n+\tfor (pci = 0; pci < ira_pressure_classes_num; pci++)\n+\t  {\n+\t    cl = ira_pressure_classes[pci];\n+\t    mix |= delta[cl];\n+\t    mix |= model_update_pressure (&model_before_pressure,\n+\t\t\t\t\t  point, pci, delta[cl]);\n+\t  }\n+      }\n+    while (mix && point > model_curr_point);\n+\n+  if (print_p)\n+    fprintf (sched_dump, MODEL_BAR);\n+}\n+\f\n+/* model_spill_cost (CL, P, P') returns the cost of increasing the\n+   pressure on CL from P to P'.  We use this to calculate a \"base ECC\",\n+   baseECC (CL, X), for each pressure class CL and each instruction X.\n+   Supposing X changes the pressure on CL from P to P', and that the\n+   maximum pressure on CL in the current model schedule is MP', then:\n+\n+   * if X occurs before or at the next point of maximum pressure in\n+     the model schedule and P' > MP', then:\n+\n+       baseECC (CL, X) = model_spill_cost (CL, MP, P')\n+\n+     The idea is that the pressure after scheduling a fixed set of\n+     instructions -- in this case, the set up to and including the\n+     next maximum pressure point -- is going to be the same regardless\n+     of the order; we simply want to keep the intermediate pressure\n+     under control.  Thus X has a cost of zero unless scheduling it\n+     now would exceed MP'.\n+\n+     If all increases in the set are by the same amount, no zero-cost\n+     instruction will ever cause the pressure to exceed MP'.  However,\n+     if X is instead moved past an instruction X' with pressure in the\n+     range (MP' - (P' - P), MP'), the pressure at X' will increase\n+     beyond MP'.  Since baseECC is very much a heuristic anyway,\n+     it doesn't seem worth the overhead of tracking cases like these.\n+\n+     The cost of exceeding MP' is always based on the original maximum\n+     pressure MP.  This is so that going 2 registers over the original\n+     limit has the same cost regardless of whether it comes from two\n+     separate +1 deltas or from a single +2 delta.\n+\n+   * if X occurs after the next point of maximum pressure in the model\n+     schedule and P' > P, then:\n+\n+       baseECC (CL, X) = model_spill_cost (CL, MP, MP' + (P' - P))\n+\n+     That is, if we move X forward across a point of maximum pressure,\n+     and if X increases the pressure by P' - P, then we conservatively\n+     assume that scheduling X next would increase the maximum pressure\n+     by P' - P.  Again, the cost of doing this is based on the original\n+     maximum pressure MP, for the same reason as above.\n+\n+   * if P' < P, P > MP, and X occurs at or after the next point of\n+     maximum pressure, then:\n+\n+       baseECC (CL, X) = -model_spill_cost (CL, MAX (MP, P'), P)\n \n+     That is, if we have already exceeded the original maximum pressure MP,\n+     and if X might reduce the maximum pressure again -- or at least push\n+     it further back, and thus allow more scheduling freedom -- it is given\n+     a negative cost to reflect the improvement.\n+\n+   * otherwise,\n+\n+       baseECC (CL, X) = 0\n+\n+     In this case, X is not expected to affect the maximum pressure MP',\n+     so it has zero cost.\n+\n+   We then create a combined value baseECC (X) that is the sum of\n+   baseECC (CL, X) for each pressure class CL.\n+\n+   baseECC (X) could itself be used as the ECC value described above.\n+   However, this is often too conservative, in the sense that it\n+   tends to make high-priority instructions that increase pressure\n+   wait too long in cases where introducing a spill would be better.\n+   For this reason the final ECC is a priority-adjusted form of\n+   baseECC (X).  Specifically, we calculate:\n+\n+     P (X) = INSN_PRIORITY (X) - insn_delay (X) - baseECC (X)\n+     baseP = MAX { P (X) | baseECC (X) <= 0 }\n+\n+   Then:\n+\n+     ECC (X) = MAX (MIN (baseP - P (X), baseECC (X)), 0)\n+\n+   Thus an instruction's effect on pressure is ignored if it has a high\n+   enough priority relative to the ones that don't increase pressure.\n+   Negative values of baseECC (X) do not increase the priority of X\n+   itself, but they do make it harder for other instructions to\n+   increase the pressure further.\n+\n+   This pressure cost is deliberately timid.  The intention has been\n+   to choose a heuristic that rarely interferes with the normal list\n+   scheduler in cases where that scheduler would produce good code.\n+   We simply want to curb some of its worst excesses.  */\n+\n+/* Return the cost of increasing the pressure in class CL from FROM to TO.\n+\n+   Here we use the very simplistic cost model that every register above\n+   ira_available_class_regs[CL] has a spill cost of 1.  We could use other\n+   measures instead, such as one based on MEMORY_MOVE_COST.  However:\n+\n+      (1) In order for an instruction to be scheduled, the higher cost\n+\t  would need to be justified in a single saving of that many stalls.\n+\t  This is overly pessimistic, because the benefit of spilling is\n+\t  often to avoid a sequence of several short stalls rather than\n+\t  a single long one.\n+\n+      (2) The cost is still arbitrary.  Because we are not allocating\n+\t  registers during scheduling, we have no way of knowing for\n+\t  sure how many memory accesses will be required by each spill,\n+\t  where the spills will be placed within the block, or even\n+\t  which block(s) will contain the spills.\n+\n+   So a higher cost than 1 is often too conservative in practice,\n+   forcing blocks to contain unnecessary stalls instead of spill code.\n+   The simple cost below seems to be the best compromise.  It reduces\n+   the interference with the normal list scheduler, which helps make\n+   it more suitable for a default-on option.  */\n+\n+static int\n+model_spill_cost (int cl, int from, int to)\n+{\n+  from = MAX (from, ira_available_class_regs[cl]);\n+  return MAX (to, from) - from;\n+}\n+\n+/* Return baseECC (ira_pressure_classes[PCI], POINT), given that\n+   P = curr_reg_pressure[ira_pressure_classes[PCI]] and that\n+   P' = P + DELTA.  */\n+\n+static int\n+model_excess_group_cost (struct model_pressure_group *group,\n+\t\t\t int point, int pci, int delta)\n+{\n+  int pressure, cl;\n+\n+  cl = ira_pressure_classes[pci];\n+  if (delta < 0 && point >= group->limits[pci].point)\n+    {\n+      pressure = MAX (group->limits[pci].orig_pressure,\n+\t\t      curr_reg_pressure[cl] + delta);\n+      return -model_spill_cost (cl, pressure, curr_reg_pressure[cl]);\n+    }\n+\n+  if (delta > 0)\n+    {\n+      if (point > group->limits[pci].point)\n+\tpressure = group->limits[pci].pressure + delta;\n+      else\n+\tpressure = curr_reg_pressure[cl] + delta;\n+\n+      if (pressure > group->limits[pci].pressure)\n+\treturn model_spill_cost (cl, group->limits[pci].orig_pressure,\n+\t\t\t\t pressure);\n+    }\n+\n+  return 0;\n+}\n+\n+/* Return baseECC (MODEL_INSN (INSN)).  Dump the costs to sched_dump\n+   if PRINT_P.  */\n+\n+static int\n+model_excess_cost (rtx insn, bool print_p)\n+{\n+  int point, pci, cl, cost, this_cost, delta;\n+  struct reg_pressure_data *insn_reg_pressure;\n+  int insn_death[N_REG_CLASSES];\n+\n+  calculate_reg_deaths (insn, insn_death);\n+  point = model_index (insn);\n+  insn_reg_pressure = INSN_REG_PRESSURE (insn);\n+  cost = 0;\n+\n+  if (print_p)\n+    fprintf (sched_dump, \";;\\t\\t| %3d %4d | %4d %+3d |\", point,\n+\t     INSN_UID (insn), INSN_PRIORITY (insn), insn_delay (insn));\n+\n+  /* Sum up the individual costs for each register class.  */\n+  for (pci = 0; pci < ira_pressure_classes_num; pci++)\n+    {\n+      cl = ira_pressure_classes[pci];\n+      delta = insn_reg_pressure[pci].set_increase - insn_death[cl];\n+      this_cost = model_excess_group_cost (&model_before_pressure,\n+\t\t\t\t\t   point, pci, delta);\n+      cost += this_cost;\n+      if (print_p)\n+\tfprintf (sched_dump, \" %s:[%d base cost %d]\",\n+\t\t reg_class_names[cl], delta, this_cost);\n+    }\n+\n+  if (print_p)\n+    fprintf (sched_dump, \"\\n\");\n+\n+  return cost;\n+}\n+\n+/* Dump the next points of maximum pressure for GROUP.  */\n+\n+static void\n+model_dump_pressure_points (struct model_pressure_group *group)\n+{\n+  int pci, cl;\n+\n+  fprintf (sched_dump, \";;\\t\\t|  pressure points\");\n+  for (pci = 0; pci < ira_pressure_classes_num; pci++)\n+    {\n+      cl = ira_pressure_classes[pci];\n+      fprintf (sched_dump, \" %s:[%d->%d at \", reg_class_names[cl],\n+\t       curr_reg_pressure[cl], group->limits[pci].pressure);\n+      if (group->limits[pci].point < model_num_insns)\n+\tfprintf (sched_dump, \"%d:%d]\", group->limits[pci].point,\n+\t\t INSN_UID (MODEL_INSN (group->limits[pci].point)));\n+      else\n+\tfprintf (sched_dump, \"end]\");\n+    }\n+  fprintf (sched_dump, \"\\n\");\n+}\n+\n+/* Set INSN_REG_PRESSURE_EXCESS_COST_CHANGE for INSNS[0...COUNT-1].  */\n+\n+static void\n+model_set_excess_costs (rtx *insns, int count)\n+{\n+  int i, cost, priority_base, priority;\n+  bool print_p;\n+\n+  /* Record the baseECC value for each instruction in the model schedule,\n+     except that negative costs are converted to zero ones now rather thatn\n+     later.  Do not assign a cost to debug instructions, since they must\n+     not change code-generation decisions.  Experiments suggest we also\n+     get better results by not assigning a cost to instructions from\n+     a different block.\n+\n+     Set PRIORITY_BASE to baseP in the block comment above.  This is the\n+     maximum priority of the \"cheap\" instructions, which should always\n+     include the next model instruction.  */\n+  priority_base = 0;\n+  print_p = false;\n+  for (i = 0; i < count; i++)\n+    if (INSN_MODEL_INDEX (insns[i]))\n+      {\n+\tif (sched_verbose >= 6 && !print_p)\n+\t  {\n+\t    fprintf (sched_dump, MODEL_BAR);\n+\t    fprintf (sched_dump, \";;\\t\\t| Pressure costs for ready queue\\n\");\n+\t    model_dump_pressure_points (&model_before_pressure);\n+\t    fprintf (sched_dump, MODEL_BAR);\n+\t    print_p = true;\n+\t  }\n+\tcost = model_excess_cost (insns[i], print_p);\n+\tif (cost <= 0)\n+\t  {\n+\t    priority = INSN_PRIORITY (insns[i]) - insn_delay (insns[i]) - cost;\n+\t    priority_base = MAX (priority_base, priority);\n+\t    cost = 0;\n+\t  }\n+\tINSN_REG_PRESSURE_EXCESS_COST_CHANGE (insns[i]) = cost;\n+      }\n+  if (print_p)\n+    fprintf (sched_dump, MODEL_BAR);\n+\n+  /* Use MAX (baseECC, 0) and baseP to calculcate ECC for each\n+     instruction.  */\n+  for (i = 0; i < count; i++)\n+    {\n+      cost = INSN_REG_PRESSURE_EXCESS_COST_CHANGE (insns[i]);\n+      priority = INSN_PRIORITY (insns[i]) - insn_delay (insns[i]);\n+      if (cost > 0 && priority > priority_base)\n+\t{\n+\t  cost += priority_base - priority;\n+\t  INSN_REG_PRESSURE_EXCESS_COST_CHANGE (insns[i]) = MAX (cost, 0);\n+\t}\n+    }\n+}\n+\f\n /* Returns a positive value if x is preferred; returns a negative value if\n    y is preferred.  Should never return 0, since that will make the sort\n    unstable.  */\n@@ -1661,23 +2436,20 @@ rank_for_schedule (const void *x, const void *y)\n   /* Make sure that priority of TMP and TMP2 are initialized.  */\n   gcc_assert (INSN_PRIORITY_KNOWN (tmp) && INSN_PRIORITY_KNOWN (tmp2));\n \n-  if (sched_pressure == SCHED_PRESSURE_WEIGHTED)\n+  if (sched_pressure != SCHED_PRESSURE_NONE)\n     {\n       int diff;\n \n       /* Prefer insn whose scheduling results in the smallest register\n \t pressure excess.  */\n       if ((diff = (INSN_REG_PRESSURE_EXCESS_COST_CHANGE (tmp)\n-\t\t   + (INSN_TICK (tmp) > clock_var\n-\t\t      ? INSN_TICK (tmp) - clock_var : 0)\n+\t\t   + insn_delay (tmp)\n \t\t   - INSN_REG_PRESSURE_EXCESS_COST_CHANGE (tmp2)\n-\t\t   - (INSN_TICK (tmp2) > clock_var\n-\t\t      ? INSN_TICK (tmp2) - clock_var : 0))) != 0)\n+\t\t   - insn_delay (tmp2))))\n \treturn diff;\n     }\n \n-\n-  if (sched_pressure == SCHED_PRESSURE_WEIGHTED\n+  if (sched_pressure != SCHED_PRESSURE_NONE\n       && (INSN_TICK (tmp2) > clock_var || INSN_TICK (tmp) > clock_var))\n     {\n       if (INSN_TICK (tmp) <= clock_var)\n@@ -1769,11 +2541,22 @@ rank_for_schedule (const void *x, const void *y)\n \treturn val;\n     }\n \n+  /* Prefer instructions that occur earlier in the model schedule.  */\n+  if (sched_pressure == SCHED_PRESSURE_MODEL)\n+    {\n+      int diff;\n+\n+      diff = model_index (tmp) - model_index (tmp2);\n+      if (diff != 0)\n+\treturn diff;\n+    }\n+\n   /* Prefer the insn which has more later insns that depend on it.\n      This gives the scheduler more freedom when scheduling later\n      instructions at the expense of added register pressure.  */\n \n-  val = (dep_list_size (tmp2) - dep_list_size (tmp));\n+  val = (dep_list_size (tmp2, SD_LIST_FORW)\n+\t - dep_list_size (tmp, SD_LIST_FORW));\n \n   if (flag_sched_dep_count_heuristic && val != 0)\n     return val;\n@@ -2001,6 +2784,9 @@ ready_sort (struct ready_list *ready)\n \tif (!DEBUG_INSN_P (first[i]))\n \t  setup_insn_reg_pressure_info (first[i]);\n     }\n+  if (sched_pressure == SCHED_PRESSURE_MODEL\n+      && model_curr_point < model_num_insns)\n+    model_set_excess_costs (first, ready->n_ready);\n   SCHED_SORT (first, ready->n_ready);\n }\n \n@@ -2063,10 +2849,12 @@ update_register_pressure (rtx insn)\n   gcc_checking_assert (!DEBUG_INSN_P (insn));\n \n   for (use = INSN_REG_USE_LIST (insn); use != NULL; use = use->next_insn_use)\n-    if (dying_use_p (use) && bitmap_bit_p (curr_reg_live, use->regno))\n-      mark_regno_birth_or_death (use->regno, false);\n+    if (dying_use_p (use))\n+      mark_regno_birth_or_death (curr_reg_live, curr_reg_pressure,\n+\t\t\t\t use->regno, false);\n   for (set = INSN_REG_SET_LIST (insn); set != NULL; set = set->next_insn_set)\n-    mark_regno_birth_or_death (set->regno, true);\n+    mark_regno_birth_or_death (curr_reg_live, curr_reg_pressure,\n+\t\t\t       set->regno, true);\n }\n \n /* Set up or update (if UPDATE_P) max register pressure (see its\n@@ -2188,6 +2976,613 @@ check_clobbered_conditions (rtx insn)\n     }\n }\n \f\n+/* Return (in order):\n+\n+   - positive if INSN adversely affects the pressure on one\n+     register class\n+\n+   - negative if INSN reduces the pressure on one register class\n+\n+   - 0 if INSN doesn't affect the pressure on any register class.  */\n+\n+static int\n+model_classify_pressure (struct model_insn_info *insn)\n+{\n+  struct reg_pressure_data *reg_pressure;\n+  int death[N_REG_CLASSES];\n+  int pci, cl, sum;\n+\n+  calculate_reg_deaths (insn->insn, death);\n+  reg_pressure = INSN_REG_PRESSURE (insn->insn);\n+  sum = 0;\n+  for (pci = 0; pci < ira_pressure_classes_num; pci++)\n+    {\n+      cl = ira_pressure_classes[pci];\n+      if (death[cl] < reg_pressure[pci].set_increase)\n+\treturn 1;\n+      sum += reg_pressure[pci].set_increase - death[cl];\n+    }\n+  return sum;\n+}\n+\n+/* Return true if INSN1 should come before INSN2 in the model schedule.  */\n+\n+static int\n+model_order_p (struct model_insn_info *insn1, struct model_insn_info *insn2)\n+{\n+  unsigned int height1, height2;\n+  unsigned int priority1, priority2;\n+\n+  /* Prefer instructions with a higher model priority.  */\n+  if (insn1->model_priority != insn2->model_priority)\n+    return insn1->model_priority > insn2->model_priority;\n+\n+  /* Combine the length of the longest path of satisfied true dependencies\n+     that leads to each instruction (depth) with the length of the longest\n+     path of any dependencies that leads from the instruction (alap).\n+     Prefer instructions with the greatest combined length.  If the combined\n+     lengths are equal, prefer instructions with the greatest depth.\n+\n+     The idea is that, if we have a set S of \"equal\" instructions that each\n+     have ALAP value X, and we pick one such instruction I, any true-dependent\n+     successors of I that have ALAP value X - 1 should be preferred over S.\n+     This encourages the schedule to be \"narrow\" rather than \"wide\".\n+     However, if I is a low-priority instruction that we decided to\n+     schedule because of its model_classify_pressure, and if there\n+     is a set of higher-priority instructions T, the aforementioned\n+     successors of I should not have the edge over T.  */\n+  height1 = insn1->depth + insn1->alap;\n+  height2 = insn2->depth + insn2->alap;\n+  if (height1 != height2)\n+    return height1 > height2;\n+  if (insn1->depth != insn2->depth)\n+    return insn1->depth > insn2->depth;\n+\n+  /* We have no real preference between INSN1 an INSN2 as far as attempts\n+     to reduce pressure go.  Prefer instructions with higher priorities.  */\n+  priority1 = INSN_PRIORITY (insn1->insn);\n+  priority2 = INSN_PRIORITY (insn2->insn);\n+  if (priority1 != priority2)\n+    return priority1 > priority2;\n+\n+  /* Use the original rtl sequence as a tie-breaker.  */\n+  return insn1 < insn2;\n+}\n+\n+/* Add INSN to the model worklist immediately after PREV.  Add it to the\n+   beginning of the list if PREV is null.  */\n+\n+static void\n+model_add_to_worklist_at (struct model_insn_info *insn,\n+\t\t\t  struct model_insn_info *prev)\n+{\n+  gcc_assert (QUEUE_INDEX (insn->insn) == QUEUE_NOWHERE);\n+  QUEUE_INDEX (insn->insn) = QUEUE_READY;\n+\n+  insn->prev = prev;\n+  if (prev)\n+    {\n+      insn->next = prev->next;\n+      prev->next = insn;\n+    }\n+  else\n+    {\n+      insn->next = model_worklist;\n+      model_worklist = insn;\n+    }\n+  if (insn->next)\n+    insn->next->prev = insn;\n+}\n+\n+/* Remove INSN from the model worklist.  */\n+\n+static void\n+model_remove_from_worklist (struct model_insn_info *insn)\n+{\n+  gcc_assert (QUEUE_INDEX (insn->insn) == QUEUE_READY);\n+  QUEUE_INDEX (insn->insn) = QUEUE_NOWHERE;\n+\n+  if (insn->prev)\n+    insn->prev->next = insn->next;\n+  else\n+    model_worklist = insn->next;\n+  if (insn->next)\n+    insn->next->prev = insn->prev;\n+}\n+\n+/* Add INSN to the model worklist.  Start looking for a suitable position\n+   between neighbors PREV and NEXT, testing at most MAX_SCHED_READY_INSNS\n+   insns either side.  A null PREV indicates the beginning of the list and\n+   a null NEXT indicates the end.  */\n+\n+static void\n+model_add_to_worklist (struct model_insn_info *insn,\n+\t\t       struct model_insn_info *prev,\n+\t\t       struct model_insn_info *next)\n+{\n+  int count;\n+\n+  count = MAX_SCHED_READY_INSNS;\n+  if (count > 0 && prev && model_order_p (insn, prev))\n+    do\n+      {\n+\tcount--;\n+\tprev = prev->prev;\n+      }\n+    while (count > 0 && prev && model_order_p (insn, prev));\n+  else\n+    while (count > 0 && next && model_order_p (next, insn))\n+      {\n+\tcount--;\n+\tprev = next;\n+\tnext = next->next;\n+      }\n+  model_add_to_worklist_at (insn, prev);\n+}\n+\n+/* INSN may now have a higher priority (in the model_order_p sense)\n+   than before.  Move it up the worklist if necessary.  */\n+\n+static void\n+model_promote_insn (struct model_insn_info *insn)\n+{\n+  struct model_insn_info *prev;\n+  int count;\n+\n+  prev = insn->prev;\n+  count = MAX_SCHED_READY_INSNS;\n+  while (count > 0 && prev && model_order_p (insn, prev))\n+    {\n+      count--;\n+      prev = prev->prev;\n+    }\n+  if (prev != insn->prev)\n+    {\n+      model_remove_from_worklist (insn);\n+      model_add_to_worklist_at (insn, prev);\n+    }\n+}\n+\n+/* Add INSN to the end of the model schedule.  */\n+\n+static void\n+model_add_to_schedule (rtx insn)\n+{\n+  unsigned int point;\n+\n+  gcc_assert (QUEUE_INDEX (insn) == QUEUE_NOWHERE);\n+  QUEUE_INDEX (insn) = QUEUE_SCHEDULED;\n+\n+  point = VEC_length (rtx, model_schedule);\n+  VEC_quick_push (rtx, model_schedule, insn);\n+  INSN_MODEL_INDEX (insn) = point + 1;\n+}\n+\n+/* Analyze the instructions that are to be scheduled, setting up\n+   MODEL_INSN_INFO (...) and model_num_insns accordingly.  Add ready\n+   instructions to model_worklist.  */\n+\n+static void\n+model_analyze_insns (void)\n+{\n+  rtx start, end, iter;\n+  sd_iterator_def sd_it;\n+  dep_t dep;\n+  struct model_insn_info *insn, *con;\n+\n+  model_num_insns = 0;\n+  start = PREV_INSN (current_sched_info->next_tail);\n+  end = current_sched_info->prev_head;\n+  for (iter = start; iter != end; iter = PREV_INSN (iter))\n+    if (NONDEBUG_INSN_P (iter))\n+      {\n+\tinsn = MODEL_INSN_INFO (iter);\n+\tinsn->insn = iter;\n+\tFOR_EACH_DEP (iter, SD_LIST_FORW, sd_it, dep)\n+\t  {\n+\t    con = MODEL_INSN_INFO (DEP_CON (dep));\n+\t    if (con->insn && insn->alap < con->alap + 1)\n+\t      insn->alap = con->alap + 1;\n+\t  }\n+\n+\tinsn->old_queue = QUEUE_INDEX (iter);\n+\tQUEUE_INDEX (iter) = QUEUE_NOWHERE;\n+\n+\tinsn->unscheduled_preds = dep_list_size (iter, SD_LIST_HARD_BACK);\n+\tif (insn->unscheduled_preds == 0)\n+\t  model_add_to_worklist (insn, NULL, model_worklist);\n+\n+\tmodel_num_insns++;\n+      }\n+}\n+\n+/* The global state describes the register pressure at the start of the\n+   model schedule.  Initialize GROUP accordingly.  */\n+\n+static void\n+model_init_pressure_group (struct model_pressure_group *group)\n+{\n+  int pci, cl;\n+\n+  for (pci = 0; pci < ira_pressure_classes_num; pci++)\n+    {\n+      cl = ira_pressure_classes[pci];\n+      group->limits[pci].pressure = curr_reg_pressure[cl];\n+      group->limits[pci].point = 0;\n+    }\n+  /* Use index model_num_insns to record the state after the last\n+     instruction in the model schedule.  */\n+  group->model = XNEWVEC (struct model_pressure_data,\n+\t\t\t  (model_num_insns + 1) * ira_pressure_classes_num);\n+}\n+\n+/* Record that MODEL_REF_PRESSURE (GROUP, POINT, PCI) is PRESSURE.\n+   Update the maximum pressure for the whole schedule.  */\n+\n+static void\n+model_record_pressure (struct model_pressure_group *group,\n+\t\t       int point, int pci, int pressure)\n+{\n+  MODEL_REF_PRESSURE (group, point, pci) = pressure;\n+  if (group->limits[pci].pressure < pressure)\n+    {\n+      group->limits[pci].pressure = pressure;\n+      group->limits[pci].point = point;\n+    }\n+}\n+\n+/* INSN has just been added to the end of the model schedule.  Record its\n+   register-pressure information.  */\n+\n+static void\n+model_record_pressures (struct model_insn_info *insn)\n+{\n+  struct reg_pressure_data *reg_pressure;\n+  int point, pci, cl, delta;\n+  int death[N_REG_CLASSES];\n+\n+  point = model_index (insn->insn);\n+  if (sched_verbose >= 2)\n+    {\n+      char buf[2048];\n+\n+      if (point == 0)\n+\t{\n+\t  fprintf (sched_dump, \"\\n;;\\tModel schedule:\\n;;\\n\");\n+\t  fprintf (sched_dump, \";;\\t| idx insn | mpri hght dpth prio |\\n\");\n+\t}\n+      print_pattern (buf, PATTERN (insn->insn), 0);\n+      fprintf (sched_dump, \";;\\t| %3d %4d | %4d %4d %4d %4d | %-30s \",\n+\t       point, INSN_UID (insn->insn), insn->model_priority,\n+\t       insn->depth + insn->alap, insn->depth,\n+\t       INSN_PRIORITY (insn->insn), buf);\n+    }\n+  calculate_reg_deaths (insn->insn, death);\n+  reg_pressure = INSN_REG_PRESSURE (insn->insn);\n+  for (pci = 0; pci < ira_pressure_classes_num; pci++)\n+    {\n+      cl = ira_pressure_classes[pci];\n+      delta = reg_pressure[pci].set_increase - death[cl];\n+      if (sched_verbose >= 2)\n+\tfprintf (sched_dump, \" %s:[%d,%+d]\", reg_class_names[cl],\n+\t\t curr_reg_pressure[cl], delta);\n+      model_record_pressure (&model_before_pressure, point, pci,\n+\t\t\t     curr_reg_pressure[cl]);\n+    }\n+  if (sched_verbose >= 2)\n+    fprintf (sched_dump, \"\\n\");\n+}\n+\n+/* All instructions have been added to the model schedule.  Record the\n+   final register pressure in GROUP and set up all MODEL_MAX_PRESSUREs.  */\n+\n+static void\n+model_record_final_pressures (struct model_pressure_group *group)\n+{\n+  int point, pci, max_pressure, ref_pressure, cl;\n+\n+  for (pci = 0; pci < ira_pressure_classes_num; pci++)\n+    {\n+      /* Record the final pressure for this class.  */\n+      cl = ira_pressure_classes[pci];\n+      point = model_num_insns;\n+      ref_pressure = curr_reg_pressure[cl];\n+      model_record_pressure (group, point, pci, ref_pressure);\n+\n+      /* Record the original maximum pressure.  */\n+      group->limits[pci].orig_pressure = group->limits[pci].pressure;\n+\n+      /* Update the MODEL_MAX_PRESSURE for every point of the schedule.  */\n+      max_pressure = ref_pressure;\n+      MODEL_MAX_PRESSURE (group, point, pci) = max_pressure;\n+      while (point > 0)\n+\t{\n+\t  point--;\n+\t  ref_pressure = MODEL_REF_PRESSURE (group, point, pci);\n+\t  max_pressure = MAX (max_pressure, ref_pressure);\n+\t  MODEL_MAX_PRESSURE (group, point, pci) = max_pressure;\n+\t}\n+    }\n+}\n+\n+/* Update all successors of INSN, given that INSN has just been scheduled.  */\n+\n+static void\n+model_add_successors_to_worklist (struct model_insn_info *insn)\n+{\n+  sd_iterator_def sd_it;\n+  struct model_insn_info *con;\n+  dep_t dep;\n+\n+  FOR_EACH_DEP (insn->insn, SD_LIST_FORW, sd_it, dep)\n+    {\n+      con = MODEL_INSN_INFO (DEP_CON (dep));\n+      /* Ignore debug instructions, and instructions from other blocks.  */\n+      if (con->insn)\n+\t{\n+\t  con->unscheduled_preds--;\n+\n+\t  /* Update the depth field of each true-dependent successor.\n+\t     Increasing the depth gives them a higher priority than\n+\t     before.  */\n+\t  if (DEP_TYPE (dep) == REG_DEP_TRUE && con->depth < insn->depth + 1)\n+\t    {\n+\t      con->depth = insn->depth + 1;\n+\t      if (QUEUE_INDEX (con->insn) == QUEUE_READY)\n+\t\tmodel_promote_insn (con);\n+\t    }\n+\n+\t  /* If this is a true dependency, or if there are no remaining\n+\t     dependencies for CON (meaning that CON only had non-true\n+\t     dependencies), make sure that CON is on the worklist.\n+\t     We don't bother otherwise because it would tend to fill the\n+\t     worklist with a lot of low-priority instructions that are not\n+\t     yet ready to issue.  */\n+\t  if ((con->depth > 0 || con->unscheduled_preds == 0)\n+\t      && QUEUE_INDEX (con->insn) == QUEUE_NOWHERE)\n+\t    model_add_to_worklist (con, insn, insn->next);\n+\t}\n+    }\n+}\n+\n+/* Give INSN a higher priority than any current instruction, then give\n+   unscheduled predecessors of INSN a higher priority still.  If any of\n+   those predecessors are not on the model worklist, do the same for its\n+   predecessors, and so on.  */\n+\n+static void\n+model_promote_predecessors (struct model_insn_info *insn)\n+{\n+  struct model_insn_info *pro, *first;\n+  sd_iterator_def sd_it;\n+  dep_t dep;\n+\n+  if (sched_verbose >= 7)\n+    fprintf (sched_dump, \";;\\t+--- priority of %d = %d, priority of\",\n+\t     INSN_UID (insn->insn), model_next_priority);\n+  insn->model_priority = model_next_priority++;\n+  model_remove_from_worklist (insn);\n+  model_add_to_worklist_at (insn, NULL);\n+\n+  first = NULL;\n+  for (;;)\n+    {\n+      FOR_EACH_DEP (insn->insn, SD_LIST_HARD_BACK, sd_it, dep)\n+\t{\n+\t  pro = MODEL_INSN_INFO (DEP_PRO (dep));\n+\t  /* The first test is to ignore debug instructions, and instructions\n+\t     from other blocks.  */\n+\t  if (pro->insn\n+\t      && pro->model_priority != model_next_priority\n+\t      && QUEUE_INDEX (pro->insn) != QUEUE_SCHEDULED)\n+\t    {\n+\t      pro->model_priority = model_next_priority;\n+\t      if (sched_verbose >= 7)\n+\t\tfprintf (sched_dump, \" %d\", INSN_UID (pro->insn));\n+\t      if (QUEUE_INDEX (pro->insn) == QUEUE_READY)\n+\t\t{\n+\t\t  /* PRO is already in the worklist, but it now has\n+\t\t     a higher priority than before.  Move it at the\n+\t\t     appropriate place.  */\n+\t\t  model_remove_from_worklist (pro);\n+\t\t  model_add_to_worklist (pro, NULL, model_worklist);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* PRO isn't in the worklist.  Recursively process\n+\t\t     its predecessors until we find one that is.  */\n+\t\t  pro->next = first;\n+\t\t  first = pro;\n+\t\t}\n+\t    }\n+\t}\n+      if (!first)\n+\tbreak;\n+      insn = first;\n+      first = insn->next;\n+    }\n+  if (sched_verbose >= 7)\n+    fprintf (sched_dump, \" = %d\\n\", model_next_priority);\n+  model_next_priority++;\n+}\n+\n+/* Pick one instruction from model_worklist and process it.  */\n+\n+static void\n+model_choose_insn (void)\n+{\n+  struct model_insn_info *insn, *fallback;\n+  int count;\n+\n+  if (sched_verbose >= 7)\n+    {\n+      fprintf (sched_dump, \";;\\t+--- worklist:\\n\");\n+      insn = model_worklist;\n+      count = MAX_SCHED_READY_INSNS;\n+      while (count > 0 && insn)\n+\t{\n+\t  fprintf (sched_dump, \";;\\t+---   %d [%d, %d, %d, %d]\\n\",\n+\t\t   INSN_UID (insn->insn), insn->model_priority,\n+\t\t   insn->depth + insn->alap, insn->depth,\n+\t\t   INSN_PRIORITY (insn->insn));\n+\t  count--;\n+\t  insn = insn->next;\n+\t}\n+    }\n+\n+  /* Look for a ready instruction whose model_classify_priority is zero\n+     or negative, picking the highest-priority one.  Adding such an\n+     instruction to the schedule now should do no harm, and may actually\n+     do some good.\n+\n+     Failing that, see whether there is an instruction with the highest\n+     extant model_priority that is not yet ready, but which would reduce\n+     pressure if it became ready.  This is designed to catch cases like:\n+\n+       (set (mem (reg R1)) (reg R2))\n+\n+     where the instruction is the last remaining use of R1 and where the\n+     value of R2 is not yet available (or vice versa).  The death of R1\n+     means that this instruction already reduces pressure.  It is of\n+     course possible that the computation of R2 involves other registers\n+     that are hard to kill, but such cases are rare enough for this\n+     heuristic to be a win in general.\n+\n+     Failing that, just pick the highest-priority instruction in the\n+     worklist.  */\n+  count = MAX_SCHED_READY_INSNS;\n+  insn = model_worklist;\n+  fallback = 0;\n+  for (;;)\n+    {\n+      if (count == 0 || !insn)\n+\t{\n+\t  insn = fallback ? fallback : model_worklist;\n+\t  break;\n+\t}\n+      if (insn->unscheduled_preds)\n+\t{\n+\t  if (model_worklist->model_priority == insn->model_priority\n+\t      && !fallback\n+\t      && model_classify_pressure (insn) < 0)\n+\t    fallback = insn;\n+\t}\n+      else\n+\t{\n+\t  if (model_classify_pressure (insn) <= 0)\n+\t    break;\n+\t}\n+      count--;\n+      insn = insn->next;\n+    }\n+\n+  if (sched_verbose >= 7 && insn != model_worklist)\n+    {\n+      if (insn->unscheduled_preds)\n+\tfprintf (sched_dump, \";;\\t+--- promoting insn %d, with dependencies\\n\",\n+\t\t INSN_UID (insn->insn));\n+      else\n+\tfprintf (sched_dump, \";;\\t+--- promoting insn %d, which is ready\\n\",\n+\t\t INSN_UID (insn->insn));\n+    }\n+  if (insn->unscheduled_preds)\n+    /* INSN isn't yet ready to issue.  Give all its predecessors the\n+       highest priority.  */\n+    model_promote_predecessors (insn);\n+  else\n+    {\n+      /* INSN is ready.  Add it to the end of model_schedule and\n+\t process its successors.  */\n+      model_add_successors_to_worklist (insn);\n+      model_remove_from_worklist (insn);\n+      model_add_to_schedule (insn->insn);\n+      model_record_pressures (insn);\n+      update_register_pressure (insn->insn);\n+    }\n+}\n+\n+/* Restore all QUEUE_INDEXs to the values that they had before\n+   model_start_schedule was called.  */\n+\n+static void\n+model_reset_queue_indices (void)\n+{\n+  unsigned int i;\n+  rtx insn;\n+\n+  FOR_EACH_VEC_ELT (rtx, model_schedule, i, insn)\n+    QUEUE_INDEX (insn) = MODEL_INSN_INFO (insn)->old_queue;\n+}\n+\n+/* We have calculated the model schedule and spill costs.  Print a summary\n+   to sched_dump.  */\n+\n+static void\n+model_dump_pressure_summary (void)\n+{\n+  int pci, cl;\n+\n+  fprintf (sched_dump, \";; Pressure summary:\");\n+  for (pci = 0; pci < ira_pressure_classes_num; pci++)\n+    {\n+      cl = ira_pressure_classes[pci];\n+      fprintf (sched_dump, \" %s:%d\", reg_class_names[cl],\n+\t       model_before_pressure.limits[pci].pressure);\n+    }\n+  fprintf (sched_dump, \"\\n\\n\");\n+}\n+\n+/* Initialize the SCHED_PRESSURE_MODEL information for the current\n+   scheduling region.  */\n+\n+static void\n+model_start_schedule (void)\n+{\n+  basic_block bb;\n+\n+  model_next_priority = 1;\n+  model_schedule = VEC_alloc (rtx, heap, sched_max_luid);\n+  model_insns = XCNEWVEC (struct model_insn_info, sched_max_luid);\n+\n+  bb = BLOCK_FOR_INSN (NEXT_INSN (current_sched_info->prev_head));\n+  initiate_reg_pressure_info (df_get_live_in (bb));\n+\n+  model_analyze_insns ();\n+  model_init_pressure_group (&model_before_pressure);\n+  while (model_worklist)\n+    model_choose_insn ();\n+  gcc_assert (model_num_insns == (int) VEC_length (rtx, model_schedule));\n+  if (sched_verbose >= 2)\n+    fprintf (sched_dump, \"\\n\");\n+\n+  model_record_final_pressures (&model_before_pressure);\n+  model_reset_queue_indices ();\n+\n+  XDELETEVEC (model_insns);\n+\n+  model_curr_point = 0;\n+  initiate_reg_pressure_info (df_get_live_in (bb));\n+  if (sched_verbose >= 1)\n+    model_dump_pressure_summary ();\n+}\n+\n+/* Free the information associated with GROUP.  */\n+\n+static void\n+model_finalize_pressure_group (struct model_pressure_group *group)\n+{\n+  XDELETEVEC (group->model);\n+}\n+\n+/* Free the information created by model_start_schedule.  */\n+\n+static void\n+model_end_schedule (void)\n+{\n+  model_finalize_pressure_group (&model_before_pressure);\n+  VEC_free (rtx, heap, model_schedule);\n+}\n+\f\n /* A structure that holds local state for the loop in schedule_block.  */\n struct sched_block_state\n {\n@@ -2240,6 +3635,10 @@ schedule_insn (rtx insn)\n \t\t     reg_class_names[ira_pressure_classes[i]],\n \t\t     pressure_info[i].set_increase, pressure_info[i].change);\n \t}\n+      if (sched_pressure == SCHED_PRESSURE_MODEL\n+\t  && model_curr_point < model_num_insns\n+\t  && model_index (insn) == model_curr_point)\n+\tfprintf (sched_dump, \":model %d\", model_curr_point);\n       fputc ('\\n', sched_dump);\n     }\n \n@@ -2307,6 +3706,24 @@ schedule_insn (rtx insn)\n   gcc_assert (QUEUE_INDEX (insn) == QUEUE_NOWHERE);\n   QUEUE_INDEX (insn) = QUEUE_SCHEDULED;\n \n+  if (sched_pressure == SCHED_PRESSURE_MODEL\n+      && model_curr_point < model_num_insns\n+      && NONDEBUG_INSN_P (insn))\n+    {\n+      if (model_index (insn) == model_curr_point)\n+\tdo\n+\t  model_curr_point++;\n+\twhile (model_curr_point < model_num_insns\n+\t       && (QUEUE_INDEX (MODEL_INSN (model_curr_point))\n+\t\t   == QUEUE_SCHEDULED));\n+      else\n+\tmodel_recompute (insn);\n+      model_update_limit_points ();\n+      update_register_pressure (insn);\n+      if (sched_verbose >= 2)\n+\tprint_curr_reg_pressure ();\n+    }\n+\n   gcc_assert (INSN_TICK (insn) >= MIN_TICK);\n   if (INSN_TICK (insn) > clock_var)\n     /* INSN has been prematurely moved from the queue to the ready list.\n@@ -3138,7 +4555,16 @@ queue_to_ready (struct ready_list *ready)\n       /* If the ready list is full, delay the insn for 1 cycle.\n \t See the comment in schedule_block for the rationale.  */\n       if (!reload_completed\n-\t  && ready->n_ready - ready->n_debug > MAX_SCHED_READY_INSNS\n+\t  && (ready->n_ready - ready->n_debug > MAX_SCHED_READY_INSNS\n+\t      || (sched_pressure == SCHED_PRESSURE_MODEL\n+\t\t  /* Limit pressure recalculations to MAX_SCHED_READY_INSNS\n+\t\t     instructions too.  */\n+\t\t  && model_index (insn) > (model_curr_point\n+\t\t\t\t\t   + MAX_SCHED_READY_INSNS)))\n+\t  && !(sched_pressure == SCHED_PRESSURE_MODEL\n+\t       && model_curr_point < model_num_insns\n+\t       /* Always allow the next model instruction to issue.  */\n+\t       && model_index (insn) == model_curr_point)\n \t  && !SCHED_GROUP_P (insn)\n \t  && insn != skip_insn)\n \tqueue_insn (insn, 1, \"ready full\");\n@@ -3366,12 +4792,12 @@ debug_ready_list (struct ready_list *ready)\n       fprintf (sched_dump, \"  %s:%d\",\n \t       (*current_sched_info->print_insn) (p[i], 0),\n \t       INSN_LUID (p[i]));\n-      if (sched_pressure == SCHED_PRESSURE_WEIGHTED)\n+      if (sched_pressure != SCHED_PRESSURE_NONE)\n \tfprintf (sched_dump, \"(cost=%d\",\n \t\t INSN_REG_PRESSURE_EXCESS_COST_CHANGE (p[i]));\n       if (INSN_TICK (p[i]) > clock_var)\n \tfprintf (sched_dump, \":delay=%d\", INSN_TICK (p[i]) - clock_var);\n-      if (sched_pressure == SCHED_PRESSURE_WEIGHTED)\n+      if (sched_pressure != SCHED_PRESSURE_NONE)\n \tfprintf (sched_dump, \")\");\n     }\n   fprintf (sched_dump, \"\\n\");\n@@ -4001,8 +5427,17 @@ prune_ready_list (state_t temp_state, bool first_cycle_insn_p,\n \t\tcost = 1;\n \t      reason = \"asm\";\n \t    }\n-          else if (sched_pressure == SCHED_PRESSURE_WEIGHTED)\n-\t    cost = 0;\n+\t  else if (sched_pressure != SCHED_PRESSURE_NONE)\n+\t    {\n+\t      if (sched_pressure == SCHED_PRESSURE_MODEL\n+\t\t  && INSN_TICK (insn) <= clock_var)\n+\t\t{\n+\t\t  memcpy (temp_state, curr_state, dfa_state_size);\n+\t\t  if (state_transition (temp_state, insn) >= 0)\n+\t\t    INSN_TICK (insn) = clock_var + 1;\n+\t\t}\n+\t      cost = 0;\n+\t    }\n \t  else\n \t    {\n \t      int delay_cost = 0;\n@@ -4175,6 +5610,9 @@ schedule_block (basic_block *target_bb)\n      in try_ready () (which is called through init_ready_list ()).  */\n   (*current_sched_info->init_ready_list) ();\n \n+  if (sched_pressure == SCHED_PRESSURE_MODEL)\n+    model_start_schedule ();\n+\n   /* The algorithm is O(n^2) in the number of ready insns at any given\n      time in the worst case.  Before reload we are more likely to have\n      big lists so truncate them to a reasonable size.  */\n@@ -4420,7 +5858,7 @@ schedule_block (basic_block *target_bb)\n \t  else\n \t    insn = ready_remove_first (&ready);\n \n-\t  if (sched_pressure == SCHED_PRESSURE_WEIGHTED\n+\t  if (sched_pressure != SCHED_PRESSURE_NONE\n \t      && INSN_TICK (insn) > clock_var)\n \t    {\n \t      ready_add (&ready, insn, true);\n@@ -4671,6 +6109,9 @@ schedule_block (basic_block *target_bb)\n \t  }\n     }\n \n+  if (sched_pressure == SCHED_PRESSURE_MODEL)\n+    model_end_schedule ();\n+\n   if (success)\n     {\n       commit_schedule (prev_head, tail, target_bb);\n@@ -4793,7 +6234,7 @@ sched_init (void)\n   else\n     sched_pressure = SCHED_PRESSURE_NONE;\n \n-  if (sched_pressure == SCHED_PRESSURE_WEIGHTED)\n+  if (sched_pressure != SCHED_PRESSURE_NONE)\n     ira_setup_eliminable_regset ();\n \n   /* Initialize SPEC_INFO.  */\n@@ -4871,7 +6312,7 @@ sched_init (void)\n   if (targetm.sched.init_global)\n     targetm.sched.init_global (sched_dump, sched_verbose, get_max_uid () + 1);\n \n-  if (sched_pressure == SCHED_PRESSURE_WEIGHTED)\n+  if (sched_pressure != SCHED_PRESSURE_NONE)\n     {\n       int i, max_regno = max_reg_num ();\n \n@@ -4888,8 +6329,11 @@ sched_init (void)\n \t     ? ira_pressure_class_translate[REGNO_REG_CLASS (i)]\n \t     : ira_pressure_class_translate[reg_allocno_class (i)]);\n       curr_reg_live = BITMAP_ALLOC (NULL);\n-      saved_reg_live = BITMAP_ALLOC (NULL);\n-      region_ref_regs = BITMAP_ALLOC (NULL);\n+      if (sched_pressure == SCHED_PRESSURE_WEIGHTED)\n+\t{\n+\t  saved_reg_live = BITMAP_ALLOC (NULL);\n+\t  region_ref_regs = BITMAP_ALLOC (NULL);\n+\t}\n     }\n \n   curr_state = xmalloc (dfa_state_size);\n@@ -4988,14 +6432,17 @@ void\n sched_finish (void)\n {\n   haifa_finish_h_i_d ();\n-  if (sched_pressure == SCHED_PRESSURE_WEIGHTED)\n+  if (sched_pressure != SCHED_PRESSURE_NONE)\n     {\n       if (regstat_n_sets_and_refs != NULL)\n \tregstat_free_n_sets_and_refs ();\n-      free (sched_regno_pressure_class);\n-      BITMAP_FREE (region_ref_regs);\n-      BITMAP_FREE (saved_reg_live);\n+      if (sched_pressure == SCHED_PRESSURE_WEIGHTED)\n+\t{\n+\t  BITMAP_FREE (region_ref_regs);\n+\t  BITMAP_FREE (saved_reg_live);\n+\t}\n       BITMAP_FREE (curr_reg_live);\n+      free (sched_regno_pressure_class);\n     }\n   free (curr_state);\n \n@@ -5267,7 +6714,7 @@ fix_tick_ready (rtx next)\n   INSN_TICK (next) = tick;\n \n   delay = tick - clock_var;\n-  if (delay <= 0 || sched_pressure == SCHED_PRESSURE_WEIGHTED)\n+  if (delay <= 0 || sched_pressure != SCHED_PRESSURE_NONE)\n     delay = QUEUE_READY;\n \n   change_queue_index (next, delay);\n@@ -6522,7 +7969,7 @@ add_jump_dependencies (rtx insn, rtx jump)\n       if (insn == jump)\n \tbreak;\n \n-      if (dep_list_size (insn) == 0)\n+      if (dep_list_size (insn, SD_LIST_FORW) == 0)\n \t{\n \t  dep_def _new_dep, *new_dep = &_new_dep;\n \n@@ -6663,6 +8110,7 @@ haifa_finish_h_i_d (void)\n \n   FOR_EACH_VEC_ELT (haifa_insn_data_def, h_i_d, i, data)\n     {\n+      free (data->max_reg_pressure);\n       free (data->reg_pressure);\n       for (use = data->reg_use_list; use != NULL; use = next)\n \t{\n@@ -6693,7 +8141,7 @@ haifa_init_insn (rtx insn)\n       /* Extend dependency caches by one element.  */\n       extend_dependency_caches (1, false);\n     }\n-  if (sched_pressure == SCHED_PRESSURE_WEIGHTED)\n+  if (sched_pressure != SCHED_PRESSURE_NONE)\n     init_insn_reg_pressure_info (insn);\n }\n "}, {"sha": "12ed38a59c4ee04057efec6b020c2b5497cc55af", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a1aca9c426e2723c731f1f3e006e8b03265616a/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a1aca9c426e2723c731f1f3e006e8b03265616a/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=7a1aca9c426e2723c731f1f3e006e8b03265616a", "patch": "@@ -2168,7 +2168,7 @@ init_insn_reg_pressure_info (rtx insn)\n   static struct reg_pressure_data *pressure_info;\n   rtx link;\n \n-  gcc_assert (sched_pressure == SCHED_PRESSURE_WEIGHTED);\n+  gcc_assert (sched_pressure != SCHED_PRESSURE_NONE);\n \n   if (! INSN_P (insn))\n     return;\n@@ -2199,8 +2199,9 @@ init_insn_reg_pressure_info (rtx insn)\n   len = sizeof (struct reg_pressure_data) * ira_pressure_classes_num;\n   pressure_info\n     = INSN_REG_PRESSURE (insn) = (struct reg_pressure_data *) xmalloc (len);\n-  INSN_MAX_REG_PRESSURE (insn) = (int *) xcalloc (ira_pressure_classes_num\n-\t\t\t\t\t\t  * sizeof (int), 1);\n+  if (sched_pressure == SCHED_PRESSURE_WEIGHTED)\n+    INSN_MAX_REG_PRESSURE (insn) = (int *) xcalloc (ira_pressure_classes_num\n+\t\t\t\t\t\t    * sizeof (int), 1);\n   for (i = 0; i < ira_pressure_classes_num; i++)\n     {\n       cl = ira_pressure_classes[i];\n@@ -2951,7 +2952,7 @@ sched_analyze_insn (struct deps_desc *deps, rtx x, rtx insn)\n       || (NONJUMP_INSN_P (insn) && control_flow_insn_p (insn)))\n     reg_pending_barrier = MOVE_BARRIER;\n \n-  if (sched_pressure == SCHED_PRESSURE_WEIGHTED)\n+  if (sched_pressure != SCHED_PRESSURE_NONE)\n     {\n       setup_insn_reg_uses (deps, insn);\n       init_insn_reg_pressure_info (insn);"}, {"sha": "06e21ace69850d610b1c2727a9045c10fb89560d", "filename": "gcc/sched-int.h", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a1aca9c426e2723c731f1f3e006e8b03265616a/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a1aca9c426e2723c731f1f3e006e8b03265616a/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=7a1aca9c426e2723c731f1f3e006e8b03265616a", "patch": "@@ -794,6 +794,11 @@ struct _haifa_insn_data\n \n   short cost;\n \n+  /* '> 0' if priority is valid,\n+     '== 0' if priority was not yet computed,\n+     '< 0' if priority in invalid and should be recomputed.  */\n+  signed char priority_status;\n+\n   /* Set if there's DEF-USE dependence between some speculatively\n      moved load insn and this one.  */\n   unsigned int fed_by_spec_load : 1;\n@@ -811,11 +816,6 @@ struct _haifa_insn_data\n      their TODO_SPEC recomputed.  */\n   unsigned int must_recompute_spec : 1;\n \n-  /* '> 0' if priority is valid,\n-     '== 0' if priority was not yet computed,\n-     '< 0' if priority in invalid and should be recomputed.  */\n-  signed char priority_status;\n-\n   /* What speculations are necessary to apply to schedule the instruction.  */\n   ds_t todo_spec;\n \n@@ -854,6 +854,7 @@ struct _haifa_insn_data\n   /* Info about how scheduling the insn changes cost of register\n      pressure excess (between source and target).  */\n   int reg_pressure_excess_cost_change;\n+  int model_index;\n };\n \n typedef struct _haifa_insn_data haifa_insn_data_def;\n@@ -876,6 +877,7 @@ extern VEC(haifa_insn_data_def, heap) *h_i_d;\n #define INSN_REG_PRESSURE_EXCESS_COST_CHANGE(INSN) \\\n   (HID (INSN)->reg_pressure_excess_cost_change)\n #define INSN_PRIORITY_STATUS(INSN) (HID (INSN)->priority_status)\n+#define INSN_MODEL_INDEX(INSN) (HID (INSN)->model_index)\n \n typedef struct _haifa_deps_insn_data haifa_deps_insn_data_def;\n typedef haifa_deps_insn_data_def *haifa_deps_insn_data_t;"}]}