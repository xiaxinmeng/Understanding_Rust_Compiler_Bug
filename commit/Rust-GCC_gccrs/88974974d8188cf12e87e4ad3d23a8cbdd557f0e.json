{"sha": "88974974d8188cf12e87e4ad3d23a8cbdd557f0e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODg5NzQ5NzRkODE4OGNmMTJlODdlNGFkM2QyM2E4Y2JkZDU1N2YwZQ==", "commit": {"author": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2021-06-23T07:19:13Z"}, "committer": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2021-09-03T18:42:09Z"}, "message": "coroutines: Use DECL_VALUE_EXPR instead of rewriting vars.\n\nVariables that need to persist over suspension expressions\nmust be preserved by being copied into the coroutine frame.\n\nThe initial implementations do this manually in the transform\ncode.  However, that has various disadvantages - including\nthat the debug connections are lost between the original var\nand the frame copy.\n\nThe revised implementation makes use of DECL_VALUE_EXPRs to\ncontain the frame offset expressions, so that the original\nvar names are preserved in the code.\n\nThis process is also applied to the function parms which are\nalways copied to the frame.  In this case the decls need to be\ncopied since they are used in two different contexts during\nthe re-write (in the building of the ramp function, and in\nthe actor function itself).\n\nThis will assist in improvement of debugging (PR 99215).\n\nSigned-off-by: Iain Sandoe <iain@sandoe.co.uk>\n\ngcc/cp/ChangeLog:\n\n\t* coroutines.cc (transform_local_var_uses): Record\n\tframe offset expressions as DECL_VALUE_EXPRs instead of\n\trewriting them.", "tree": {"sha": "3887961d0efd86b465daa4bb5c45b08e64a08ba6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3887961d0efd86b465daa4bb5c45b08e64a08ba6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/88974974d8188cf12e87e4ad3d23a8cbdd557f0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88974974d8188cf12e87e4ad3d23a8cbdd557f0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88974974d8188cf12e87e4ad3d23a8cbdd557f0e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88974974d8188cf12e87e4ad3d23a8cbdd557f0e/comments", "author": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b69bf5729852d0510abbe8e04078ddecef0cf17", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b69bf5729852d0510abbe8e04078ddecef0cf17", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b69bf5729852d0510abbe8e04078ddecef0cf17"}], "stats": {"total": 105, "additions": 5, "deletions": 100}, "files": [{"sha": "2d68098f24231b2883404a695ce7f213ebd8132d", "filename": "gcc/cp/coroutines.cc", "status": "modified", "additions": 5, "deletions": 100, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88974974d8188cf12e87e4ad3d23a8cbdd557f0e/gcc%2Fcp%2Fcoroutines.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88974974d8188cf12e87e4ad3d23a8cbdd557f0e/gcc%2Fcp%2Fcoroutines.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcoroutines.cc?ref=88974974d8188cf12e87e4ad3d23a8cbdd557f0e", "patch": "@@ -1974,8 +1974,7 @@ transform_local_var_uses (tree *stmt, int *do_subtree, void *d)\n   local_vars_transform *lvd = (local_vars_transform *) d;\n \n   /* For each var in this bind expr (that has a frame id, which means it was\n-     accessed), build a frame reference for each and then walk the bind expr\n-     statements, substituting the frame ref for the original var.  */\n+     accessed), build a frame reference and add it as the DECL_VALUE_EXPR.  */\n \n   if (TREE_CODE (*stmt) == BIND_EXPR)\n     {\n@@ -1991,13 +1990,9 @@ transform_local_var_uses (tree *stmt, int *do_subtree, void *d)\n \t  /* Re-write the variable's context to be in the actor func.  */\n \t  DECL_CONTEXT (lvar) = lvd->context;\n \n-\t/* For capture proxies, this could include the decl value expr.  */\n-\tif (local_var.is_lambda_capture || local_var.has_value_expr_p)\n-\t  {\n-\t    tree ve = DECL_VALUE_EXPR (lvar);\n-\t    cp_walk_tree (&ve, transform_local_var_uses, d, NULL);\n+\t  /* For capture proxies, this could include the decl value expr.  */\n+\t  if (local_var.is_lambda_capture || local_var.has_value_expr_p)\n \t    continue; /* No frame entry for this.  */\n-\t  }\n \n \t  /* TODO: implement selective generation of fields when vars are\n \t     known not-used.  */\n@@ -2011,103 +2006,13 @@ transform_local_var_uses (tree *stmt, int *do_subtree, void *d)\n \t  tree fld_idx = build3_loc (lvd->loc, COMPONENT_REF, TREE_TYPE (lvar),\n \t\t\t\t     lvd->actor_frame, fld_ref, NULL_TREE);\n \t  local_var.field_idx = fld_idx;\n-\t}\n-      /* FIXME: we should be able to do this in the loop above, but (at least\n-\t for range for) there are cases where the DECL_INITIAL contains\n-\t forward references.\n-\t So, now we've built the revised var in the frame, substitute uses of\n-\t it in initializers and the bind expr body.  */\n-      for (lvar = BIND_EXPR_VARS (*stmt); lvar != NULL;\n-\t   lvar = DECL_CHAIN (lvar))\n-\t{\n-\t  /* we need to walk some of the decl trees, which might contain\n-\t     references to vars replaced at a higher level.  */\n-\t  cp_walk_tree (&DECL_INITIAL (lvar), transform_local_var_uses, d,\n-\t\t\tNULL);\n-\t  cp_walk_tree (&DECL_SIZE (lvar), transform_local_var_uses, d, NULL);\n-\t  cp_walk_tree (&DECL_SIZE_UNIT (lvar), transform_local_var_uses, d,\n-\t\t\tNULL);\n+\t  SET_DECL_VALUE_EXPR (lvar, fld_idx);\n+\t  DECL_HAS_VALUE_EXPR_P (lvar) = true;\n \t}\n       cp_walk_tree (&BIND_EXPR_BODY (*stmt), transform_local_var_uses, d, NULL);\n-\n-      /* Now we have processed and removed references to the original vars,\n-\t we can drop those from the bind - leaving capture proxies alone.  */\n-      for (tree *pvar = &BIND_EXPR_VARS (*stmt); *pvar != NULL;)\n-\t{\n-\t  bool existed;\n-\t  local_var_info &local_var\n-\t    = lvd->local_var_uses->get_or_insert (*pvar, &existed);\n-\t  gcc_checking_assert (existed);\n-\n-\t  /* Leave lambda closure captures alone, we replace the *this\n-\t     pointer with the frame version and let the normal process\n-\t     deal with the rest.\n-\t     Likewise, variables with their value found elsewhere.\n-\t     Skip past unused ones too.  */\n-\t  if (local_var.is_lambda_capture\n-\t     || local_var.has_value_expr_p\n-\t     || local_var.field_id == NULL_TREE)\n-\t    {\n-\t      pvar = &DECL_CHAIN (*pvar);\n-\t      continue;\n-\t    }\n-\n-\t  /* Discard this one, we replaced it.  */\n-\t  *pvar = DECL_CHAIN (*pvar);\n-\t}\n-\n       *do_subtree = 0; /* We've done the body already.  */\n       return NULL_TREE;\n     }\n-\n-  tree var_decl = *stmt;\n-  /* Look inside cleanups, we don't want to wrap a statement list in a\n-     cleanup.  */\n-  bool needs_cleanup = true;\n-  if (TREE_CODE (var_decl) == CLEANUP_POINT_EXPR)\n-    var_decl = TREE_OPERAND (var_decl, 0);\n-  else\n-    needs_cleanup = false;\n-\n-  /* Look inside the decl_expr for the actual var.  */\n-  bool decl_expr_p = TREE_CODE (var_decl) == DECL_EXPR;\n-  if (decl_expr_p && TREE_CODE (DECL_EXPR_DECL (var_decl)) == VAR_DECL)\n-    var_decl = DECL_EXPR_DECL (var_decl);\n-  else if (TREE_CODE (var_decl) != VAR_DECL)\n-    return NULL_TREE;\n-\n-  /* VAR_DECLs that are not recorded can belong to the proxies we've placed\n-     for the promise and coroutine handle(s), to global vars or to compiler\n-     temporaries.  Skip past these, we will handle them later.  */\n-  local_var_info *local_var_i = lvd->local_var_uses->get (var_decl);\n-\n-  if (local_var_i == NULL)\n-    return NULL_TREE;\n-\n-  if (local_var_i->is_lambda_capture\n-      || local_var_i->is_static\n-      || local_var_i->has_value_expr_p)\n-    return NULL_TREE;\n-\n-  /* This is our revised 'local' i.e. a frame slot.  */\n-  tree revised = local_var_i->field_idx;\n-  gcc_checking_assert (DECL_CONTEXT (var_decl) == lvd->context);\n-\n-  if (decl_expr_p && DECL_INITIAL (var_decl))\n-    {\n-      location_t loc = DECL_SOURCE_LOCATION (var_decl);\n-      tree r\n-\t= cp_build_modify_expr (loc, revised, INIT_EXPR,\n-\t\t\t\tDECL_INITIAL (var_decl), tf_warning_or_error);\n-      if (needs_cleanup)\n-\tr = coro_build_cvt_void_expr_stmt (r, EXPR_LOCATION (*stmt));\n-      *stmt = r;\n-    }\n-  else\n-    *stmt = revised;\n-\n-  if (decl_expr_p)\n-    *do_subtree = 0; /* We've accounted for the nested use.  */\n   return NULL_TREE;\n }\n "}]}