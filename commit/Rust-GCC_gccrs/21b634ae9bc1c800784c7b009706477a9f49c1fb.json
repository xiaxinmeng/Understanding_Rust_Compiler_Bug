{"sha": "21b634ae9bc1c800784c7b009706477a9f49c1fb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjFiNjM0YWU5YmMxYzgwMDc4NGM3YjAwOTcwNjQ3N2E5ZjQ5YzFmYg==", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2015-05-20T10:10:07Z"}, "committer": {"name": "Marek Polacek", "email": "mpolacek@gcc.gnu.org", "date": "2015-05-20T10:10:07Z"}, "message": "c-pragma.c: Use VAR_OR_FUNCTION_DECL_P throughout.\n\n\t* c-pragma.c: Use VAR_OR_FUNCTION_DECL_P throughout.\n\t* c-common.c: Likewise.\n\n\t* c-decl.c: Use VAR_OR_FUNCTION_DECL_P throughout.\n\t* c-typeck.c: Likewise.\n\nFrom-SVN: r223437", "tree": {"sha": "ab37dc96be2c4a9dc3538a81822d6d0a42cdd9b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ab37dc96be2c4a9dc3538a81822d6d0a42cdd9b3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/21b634ae9bc1c800784c7b009706477a9f49c1fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21b634ae9bc1c800784c7b009706477a9f49c1fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21b634ae9bc1c800784c7b009706477a9f49c1fb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21b634ae9bc1c800784c7b009706477a9f49c1fb/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "42242005dcaeda1b553cd877358abeae032c5b2d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42242005dcaeda1b553cd877358abeae032c5b2d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42242005dcaeda1b553cd877358abeae032c5b2d"}], "stats": {"total": 64, "additions": 32, "deletions": 32}, "files": [{"sha": "fba79aabdaee359a6ab538b19496d9459606ad1e", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21b634ae9bc1c800784c7b009706477a9f49c1fb/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21b634ae9bc1c800784c7b009706477a9f49c1fb/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=21b634ae9bc1c800784c7b009706477a9f49c1fb", "patch": "@@ -1,3 +1,8 @@\n+2015-05-20  Marek Polacek  <polacek@redhat.com>\n+\n+\t* c-pragma.c: Use VAR_OR_FUNCTION_DECL_P throughout.\n+\t* c-common.c: Likewise.\n+\n 2015-05-19  David Malcolm  <dmalcolm@redhat.com>\n \n \t* c-common.h (fe_file_change): Strengthen param from"}, {"sha": "a2b37931911c0516f9be3cf03a6c269dcbb07fcc", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21b634ae9bc1c800784c7b009706477a9f49c1fb/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21b634ae9bc1c800784c7b009706477a9f49c1fb/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=21b634ae9bc1c800784c7b009706477a9f49c1fb", "patch": "@@ -7406,7 +7406,7 @@ handle_externally_visible_attribute (tree *pnode, tree name,\n {\n   tree node = *pnode;\n \n-  if (TREE_CODE (node) == FUNCTION_DECL || TREE_CODE (node) == VAR_DECL)\n+  if (VAR_OR_FUNCTION_DECL_P (node))\n     {\n       if ((!TREE_STATIC (node) && TREE_CODE (node) != FUNCTION_DECL\n \t   && !DECL_EXTERNAL (node)) || !TREE_PUBLIC (node))\n@@ -7437,7 +7437,7 @@ handle_no_reorder_attribute (tree *pnode,\n {\n   tree node = *pnode;\n \n-  if ((TREE_CODE (node) != FUNCTION_DECL && TREE_CODE (node) != VAR_DECL)\n+  if (!VAR_OR_FUNCTION_DECL_P (node)\n \t&& !(TREE_STATIC (node) || DECL_EXTERNAL (node)))\n     {\n       warning (OPT_Wattributes,\n@@ -7893,7 +7893,7 @@ handle_section_attribute (tree *node, tree ARG_UNUSED (name), tree args,\n \n   user_defined_section_attribute = true;\n \n-  if (TREE_CODE (decl) != FUNCTION_DECL && TREE_CODE (decl) != VAR_DECL)\n+  if (!VAR_OR_FUNCTION_DECL_P (decl))\n     {\n       error (\"section attribute not allowed for %q+D\", *node);\n       goto fail;\n@@ -8172,8 +8172,7 @@ handle_weak_attribute (tree *node, tree name,\n       *no_add_attrs = true;\n       return NULL_TREE;\n     }\n-  else if (TREE_CODE (*node) == FUNCTION_DECL\n-\t   || TREE_CODE (*node) == VAR_DECL)\n+  else if (VAR_OR_FUNCTION_DECL_P (*node))\n     {\n       struct symtab_node *n = symtab_node::get (*node);\n       if (n && n->refuse_visibility_changes)\n@@ -8309,7 +8308,7 @@ handle_weakref_attribute (tree *node, tree ARG_UNUSED (name), tree args,\n      such symbols do not even have a DECL_WEAK field.  */\n   if (decl_function_context (*node)\n       || current_function_decl\n-      || (TREE_CODE (*node) != VAR_DECL && TREE_CODE (*node) != FUNCTION_DECL))\n+      || !VAR_OR_FUNCTION_DECL_P (*node))\n     {\n       warning (OPT_Wattributes, \"%qE attribute ignored\", name);\n       *no_add_attrs = true;\n@@ -8466,8 +8465,7 @@ handle_visibility_attribute (tree *node, tree name, tree args,\n bool\n c_determine_visibility (tree decl)\n {\n-  gcc_assert (TREE_CODE (decl) == VAR_DECL\n-\t      || TREE_CODE (decl) == FUNCTION_DECL);\n+  gcc_assert (VAR_OR_FUNCTION_DECL_P (decl));\n \n   /* If the user explicitly specified the visibility with an\n      attribute, honor that.  DECL_VISIBILITY will have been set during\n@@ -9014,8 +9012,7 @@ handle_tm_wrap_attribute (tree *node, tree name, tree args,\n       if (error_operand_p (wrap_decl))\n         ;\n       else if (TREE_CODE (wrap_decl) != IDENTIFIER_NODE\n-\t       && TREE_CODE (wrap_decl) != VAR_DECL\n-\t       && TREE_CODE (wrap_decl) != FUNCTION_DECL)\n+\t       && !VAR_OR_FUNCTION_DECL_P (wrap_decl))\n \terror (\"%qE argument not an identifier\", name);\n       else\n \t{\n@@ -9089,8 +9086,7 @@ handle_deprecated_attribute (tree *node, tree name,\n \n       if (TREE_CODE (decl) == TYPE_DECL\n \t  || TREE_CODE (decl) == PARM_DECL\n-\t  || TREE_CODE (decl) == VAR_DECL\n-\t  || TREE_CODE (decl) == FUNCTION_DECL\n+\t  || VAR_OR_FUNCTION_DECL_P (decl)\n \t  || TREE_CODE (decl) == FIELD_DECL\n \t  || objc_method_decl (TREE_CODE (decl)))\n \tTREE_DEPRECATED (decl) = 1;"}, {"sha": "b82ca9f4f04a27af1934eb77a6fe7786bc785498", "filename": "gcc/c-family/c-pragma.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21b634ae9bc1c800784c7b009706477a9f49c1fb/gcc%2Fc-family%2Fc-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21b634ae9bc1c800784c7b009706477a9f49c1fb/gcc%2Fc-family%2Fc-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pragma.c?ref=21b634ae9bc1c800784c7b009706477a9f49c1fb", "patch": "@@ -306,7 +306,7 @@ maybe_apply_pragma_weak (tree decl)\n   /* If it's not a function or a variable, it can't be weak.\n      FIXME: what kinds of things are visible outside this file but\n      aren't functions or variables?   Should this be an assert instead?  */\n-  if (TREE_CODE (decl) != FUNCTION_DECL && TREE_CODE (decl) != VAR_DECL)\n+  if (!VAR_OR_FUNCTION_DECL_P (decl))\n     return;\n \n   if (DECL_ASSEMBLER_NAME_SET_P (decl))\n@@ -486,8 +486,7 @@ handle_pragma_redefine_extname (cpp_reader * ARG_UNUSED (dummy))\n \t}\n \n       if ((TREE_PUBLIC (decl) || DECL_EXTERNAL (decl))\n-\t  && (TREE_CODE (decl) == FUNCTION_DECL\n-\t      || TREE_CODE (decl) == VAR_DECL))\n+\t  && VAR_OR_FUNCTION_DECL_P (decl))\n \t{\n \t  found = true;\n \t  if (DECL_ASSEMBLER_NAME_SET_P (decl))\n@@ -547,7 +546,7 @@ maybe_apply_renaming_pragma (tree decl, tree asmname)\n \n   /* The renaming pragmas are only applied to declarations with\n      external linkage.  */\n-  if ((TREE_CODE (decl) != FUNCTION_DECL && TREE_CODE (decl) != VAR_DECL)\n+  if (!VAR_OR_FUNCTION_DECL_P (decl)\n       || (!TREE_PUBLIC (decl) && !DECL_EXTERNAL (decl))\n       || !has_c_linkage (decl))\n     return asmname;"}, {"sha": "170f0675544ecd647bff8265b9764dc34787259a", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21b634ae9bc1c800784c7b009706477a9f49c1fb/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21b634ae9bc1c800784c7b009706477a9f49c1fb/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=21b634ae9bc1c800784c7b009706477a9f49c1fb", "patch": "@@ -1,3 +1,8 @@\n+2015-05-20  Marek Polacek  <polacek@redhat.com>\n+\n+\t* c-decl.c: Use VAR_OR_FUNCTION_DECL_P throughout.\n+\t* c-typeck.c: Likewise.\n+\n 2015-05-19  Marek Polacek  <polacek@redhat.com>\n \n \t* c-typeck.c (start_init): Use AGGREGATE_TYPE_P."}, {"sha": "a2edefc5f340422a8d187cdb5495c64cbe251649", "filename": "gcc/c/c-decl.c", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21b634ae9bc1c800784c7b009706477a9f49c1fb/gcc%2Fc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21b634ae9bc1c800784c7b009706477a9f49c1fb/gcc%2Fc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.c?ref=21b634ae9bc1c800784c7b009706477a9f49c1fb", "patch": "@@ -2735,8 +2735,7 @@ duplicate_decls (tree newdecl, tree olddecl)\n      structure is shared in between NEWDECL and OLDECL.  */\n   if (TREE_CODE (newdecl) == FUNCTION_DECL)\n     DECL_STRUCT_FUNCTION (newdecl) = NULL;\n-  if (TREE_CODE (newdecl) == FUNCTION_DECL\n-      || TREE_CODE (newdecl) == VAR_DECL)\n+  if (VAR_OR_FUNCTION_DECL_P (newdecl))\n     {\n       struct symtab_node *snode = symtab_node::get (newdecl);\n       if (snode)\n@@ -2835,7 +2834,7 @@ pushdecl (tree x)\n      DECL_FILE_SCOPE_P won't work.  Local externs don't count\n      unless they have initializers (which generate code).  */\n   if (current_function_decl\n-      && ((TREE_CODE (x) != FUNCTION_DECL && TREE_CODE (x) != VAR_DECL)\n+      && (!VAR_OR_FUNCTION_DECL_P (x)\n \t  || DECL_INITIAL (x) || !DECL_EXTERNAL (x)))\n     DECL_CONTEXT (x) = current_function_decl;\n \n@@ -2926,8 +2925,7 @@ pushdecl (tree x)\n       tree visdecl = 0;\n       bool type_saved = false;\n       if (b && !B_IN_EXTERNAL_SCOPE (b)\n-\t  && (TREE_CODE (b->decl) == FUNCTION_DECL\n-\t      || TREE_CODE (b->decl) == VAR_DECL)\n+\t  && VAR_OR_FUNCTION_DECL_P (b->decl)\n \t  && DECL_FILE_SCOPE_P (b->decl))\n \t{\n \t  visdecl = b->decl;\n@@ -4613,9 +4611,8 @@ start_decl (struct c_declarator *declarator, struct c_declspecs *declspecs,\n     record_inline_static (input_location, current_function_decl,\n \t\t\t  decl, csi_modifiable);\n \n-  if (c_dialect_objc () \n-      && (TREE_CODE (decl) == VAR_DECL\n-          || TREE_CODE (decl) == FUNCTION_DECL))\n+  if (c_dialect_objc ()\n+      && VAR_OR_FUNCTION_DECL_P (decl))\n       objc_check_global_decl (decl);\n \n   /* Add this decl to the current scope.\n@@ -4670,14 +4667,14 @@ diagnose_uninitialized_cst_member (tree decl, tree type)\n \n void\n finish_decl (tree decl, location_t init_loc, tree init,\n-    \t     tree origtype, tree asmspec_tree)\n+\t     tree origtype, tree asmspec_tree)\n {\n   tree type;\n   bool was_incomplete = (DECL_SIZE (decl) == 0);\n   const char *asmspec = 0;\n \n   /* If a name was specified, get the string.  */\n-  if ((TREE_CODE (decl) == FUNCTION_DECL || TREE_CODE (decl) == VAR_DECL)\n+  if (VAR_OR_FUNCTION_DECL_P (decl)\n       && DECL_FILE_SCOPE_P (decl))\n     asmspec_tree = maybe_apply_renaming_pragma (decl, asmspec_tree);\n   if (asmspec_tree)\n@@ -4701,8 +4698,7 @@ finish_decl (tree decl, location_t init_loc, tree init,\n   if (init)\n     store_init_value (init_loc, decl, init, origtype);\n \n-  if (c_dialect_objc () && (TREE_CODE (decl) == VAR_DECL\n-\t\t\t    || TREE_CODE (decl) == FUNCTION_DECL\n+  if (c_dialect_objc () && (VAR_OR_FUNCTION_DECL_P (decl)\n \t\t\t    || TREE_CODE (decl) == FIELD_DECL))\n     objc_check_decl (decl);\n \n@@ -4841,7 +4837,7 @@ finish_decl (tree decl, location_t init_loc, tree init,\n      unless the type is an undefined structure or union.\n      If not, it will get done when the type is completed.  */\n \n-  if (TREE_CODE (decl) == VAR_DECL || TREE_CODE (decl) == FUNCTION_DECL)\n+  if (VAR_OR_FUNCTION_DECL_P (decl))\n     {\n       /* Determine the ELF visibility.  */\n       if (TREE_PUBLIC (decl))"}, {"sha": "ba8797bb8d4e2b20581b777f2af8ff08fea66f26", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21b634ae9bc1c800784c7b009706477a9f49c1fb/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21b634ae9bc1c800784c7b009706477a9f49c1fb/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=21b634ae9bc1c800784c7b009706477a9f49c1fb", "patch": "@@ -2672,9 +2672,8 @@ build_external_ref (location_t loc, tree id, int fun, tree *type)\n     }\n   else if (current_function_decl != 0\n \t   && !DECL_FILE_SCOPE_P (current_function_decl)\n-\t   && (TREE_CODE (ref) == VAR_DECL\n-\t       || TREE_CODE (ref) == PARM_DECL\n-\t       || TREE_CODE (ref) == FUNCTION_DECL))\n+\t   && (VAR_OR_FUNCTION_DECL_P (ref)\n+\t       || TREE_CODE (ref) == PARM_DECL))\n     {\n       tree context = decl_function_context (ref);\n "}]}