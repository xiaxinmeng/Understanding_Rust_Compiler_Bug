{"sha": "5980c0dcc6b3c2bb2f01f2140f48beb3fe3ffee6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTk4MGMwZGNjNmIzYzJiYjJmMDFmMjE0MGY0OGJlYjNmZTNmZmVlNg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-07-22T14:52:31Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-07-22T15:43:24Z"}, "message": "c++: mangling cleanups\n\nI noticed the mangler's handling of templates could be simplified.\nWe know template_info is non-null, which is sufficiently boolean --\nno need for an explicit bool return.  also some of the internals of\ntemplate_args_equal had crept into find_substitution.  Let's not do\nthat.\n\n\tgcc/cp/\n\t* mangle.c (decl_is_template_id): Rename to ...\n\t(maybe_template_info): ... here.  Return the template info,\n\trather than use a pointer.  Adjust all callers.\n\t(find_substitution): Use template_args_equal, rather than\n\tlocal check.", "tree": {"sha": "025af8b0125ae8528833746bd714485d51fdb8c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/025af8b0125ae8528833746bd714485d51fdb8c7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5980c0dcc6b3c2bb2f01f2140f48beb3fe3ffee6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5980c0dcc6b3c2bb2f01f2140f48beb3fe3ffee6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5980c0dcc6b3c2bb2f01f2140f48beb3fe3ffee6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5980c0dcc6b3c2bb2f01f2140f48beb3fe3ffee6/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "748ada0acb6fd746207aaff23a468717eee06555", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/748ada0acb6fd746207aaff23a468717eee06555", "html_url": "https://github.com/Rust-GCC/gccrs/commit/748ada0acb6fd746207aaff23a468717eee06555"}], "stats": {"total": 75, "additions": 26, "deletions": 49}, "files": [{"sha": "9fd30011288600a87e486d5f2d3d55b0a71ae528", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 26, "deletions": 49, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5980c0dcc6b3c2bb2f01f2140f48beb3fe3ffee6/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5980c0dcc6b3c2bb2f01f2140f48beb3fe3ffee6/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=5980c0dcc6b3c2bb2f01f2140f48beb3fe3ffee6", "patch": "@@ -170,7 +170,7 @@ integer_type_codes[itk_none] =\n   '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0', '\\0'\n };\n \n-static int decl_is_template_id (const tree, tree* const);\n+static tree maybe_template_info (const tree);\n \n /* Functions for handling substitutions.  */\n \n@@ -272,11 +272,10 @@ static tree mangle_special_for_type (const tree, const char *);\n   write_number ((NUMBER), /*unsigned_p=*/1, 10)\n \n /* If DECL is a template instance (including the uninstantiated template\n-   itself), return nonzero and, if TEMPLATE_INFO is non-NULL, set\n-   *TEMPLATE_INFO to its template info.  Otherwise return zero.  */\n+   itself), return its TEMPLATE_INFO.  Otherwise return NULL.  */\n \n-static int\n-decl_is_template_id (const tree decl, tree* const template_info)\n+static tree\n+maybe_template_info (const tree decl)\n {\n   if (TREE_CODE (decl) == TYPE_DECL)\n     {\n@@ -285,33 +284,20 @@ decl_is_template_id (const tree decl, tree* const template_info)\n       const tree type = TREE_TYPE (decl);\n \n       if (CLASS_TYPE_P (type) && CLASSTYPE_TEMPLATE_ID_P (type))\n-\t{\n-\t  if (template_info != NULL)\n-\t    /* For a templated TYPE_DECL, the template info is hanging\n-\t       off the type.  */\n-\t    *template_info = TYPE_TEMPLATE_INFO (type);\n-\t  return 1;\n-\t}\n+\treturn TYPE_TEMPLATE_INFO (type);\n     }\n   else\n     {\n-      /* Check if this is a primary template.  */\n+      /* Check if the template is a primary template.  */\n       if (DECL_LANG_SPECIFIC (decl) != NULL\n \t  && VAR_OR_FUNCTION_DECL_P (decl)\n \t  && DECL_TEMPLATE_INFO (decl)\n-\t  && PRIMARY_TEMPLATE_P (DECL_TI_TEMPLATE (decl))\n-\t  && TREE_CODE (decl) != TEMPLATE_DECL)\n-\t{\n-\t  if (template_info != NULL)\n-\t    /* For most templated decls, the template info is hanging\n-\t       off the decl.  */\n-\t    *template_info = DECL_TEMPLATE_INFO (decl);\n-\t  return 1;\n-\t}\n+\t  && PRIMARY_TEMPLATE_P (DECL_TI_TEMPLATE (decl)))\n+\treturn DECL_TEMPLATE_INFO (decl);\n     }\n \n   /* It's not a template id.  */\n-  return 0;\n+  return NULL_TREE;\n }\n \n /* Produce debugging output of current substitution candidates.  */\n@@ -628,9 +614,7 @@ find_substitution (tree node)\n \t    {\n \t      tree args = CLASSTYPE_TI_ARGS (type);\n \t      if (TREE_VEC_LENGTH (args) == 3\n-\t\t  && (TREE_CODE (TREE_VEC_ELT (args, 0))\n-\t\t      == TREE_CODE (char_type_node))\n-\t\t  && same_type_p (TREE_VEC_ELT (args, 0), char_type_node)\n+\t\t  && template_args_equal (TREE_VEC_ELT (args, 0), char_type_node)\n \t\t  && is_std_substitution_char (TREE_VEC_ELT (args, 1),\n \t\t\t\t\t       SUBID_CHAR_TRAITS)\n \t\t  && is_std_substitution_char (TREE_VEC_ELT (args, 2),\n@@ -654,8 +638,7 @@ find_substitution (tree node)\n \t args <char, std::char_traits<char> > .  */\n       tree args = CLASSTYPE_TI_ARGS (type);\n       if (TREE_VEC_LENGTH (args) == 2\n-\t  && TREE_CODE (TREE_VEC_ELT (args, 0)) == TREE_CODE (char_type_node)\n-\t  && same_type_p (TREE_VEC_ELT (args, 0), char_type_node)\n+\t  && template_args_equal (TREE_VEC_ELT (args, 0), char_type_node)\n \t  && is_std_substitution_char (TREE_VEC_ELT (args, 1),\n \t\t\t\t       SUBID_CHAR_TRAITS))\n \t{\n@@ -800,7 +783,7 @@ mangle_return_type_p (tree decl)\n   return (!DECL_CONSTRUCTOR_P (decl)\n \t  && !DECL_DESTRUCTOR_P (decl)\n \t  && !DECL_CONV_FN_P (decl)\n-\t  && decl_is_template_id (decl, NULL));\n+\t  && maybe_template_info (decl));\n }\n \n /*   <encoding>\t\t::= <function name> <bare-function-type>\n@@ -827,9 +810,8 @@ write_encoding (const tree decl)\n     {\n       tree fn_type;\n       tree d;\n-      bool tmpl = decl_is_template_id (decl, NULL);\n \n-      if (tmpl)\n+      if (maybe_template_info (decl))\n \t{\n \t  fn_type = get_mostly_instantiated_function_type (decl);\n \t  /* FN_TYPE will not have parameter types for in-charge or\n@@ -933,13 +915,12 @@ write_name (tree decl, const int ignore_local_scope)\n \t      || (abi_version_at_least (7)\n \t\t  && TREE_CODE (context) == PARM_DECL))))\n     {\n-      tree template_info;\n       /* Is this a template instance?  */\n-      if (decl_is_template_id (decl, &template_info))\n+      if (tree info = maybe_template_info (decl))\n \t{\n \t  /* Yes: use <unscoped-template-name>.  */\n-\t  write_unscoped_template_name (TI_TEMPLATE (template_info));\n-\t  write_template_args (TI_ARGS (template_info));\n+\t  write_unscoped_template_name (TI_TEMPLATE (info));\n+\t  write_template_args (TI_ARGS (info));\n \t}\n       else\n \t/* Everything else gets an <unqualified-name>.  */\n@@ -1041,8 +1022,6 @@ write_unscoped_template_name (const tree decl)\n static void\n write_nested_name (const tree decl)\n {\n-  tree template_info;\n-\n   MANGLE_TRACE_TREE (\"nested-name\", decl);\n \n   write_char ('N');\n@@ -1065,11 +1044,11 @@ write_nested_name (const tree decl)\n     }\n \n   /* Is this a template instance?  */\n-  if (decl_is_template_id (decl, &template_info))\n+  if (tree info = maybe_template_info (decl))\n     {\n       /* Yes, use <template-prefix>.  */\n       write_template_prefix (decl);\n-      write_template_args (TI_ARGS (template_info));\n+      write_template_args (TI_ARGS (info));\n     }\n   else if ((!abi_version_at_least (10) || TREE_CODE (decl) == TYPE_DECL)\n \t   && TREE_CODE (TREE_TYPE (decl)) == TYPENAME_TYPE)\n@@ -1106,8 +1085,6 @@ static void\n write_prefix (const tree node)\n {\n   tree decl;\n-  /* Non-NULL if NODE represents a template-id.  */\n-  tree template_info = NULL;\n \n   if (node == NULL\n       || node == global_namespace)\n@@ -1124,6 +1101,7 @@ write_prefix (const tree node)\n   if (find_substitution (node))\n     return;\n \n+  tree template_info = NULL_TREE;\n   if (DECL_P (node))\n     {\n       /* If this is a function or parm decl, that means we've hit function\n@@ -1136,19 +1114,20 @@ write_prefix (const tree node)\n \treturn;\n \n       decl = node;\n-      decl_is_template_id (decl, &template_info);\n+      template_info = maybe_template_info (decl);\n     }\n   else\n     {\n       /* Node is a type.  */\n       decl = TYPE_NAME (node);\n+      /* The DECL might not point at the node.  */\n       if (CLASSTYPE_TEMPLATE_ID_P (node))\n \ttemplate_info = TYPE_TEMPLATE_INFO (node);\n     }\n \n   if (TREE_CODE (node) == TEMPLATE_TYPE_PARM)\n     write_template_param (node);\n-  else if (template_info != NULL)\n+  else if (template_info)\n     /* Templated.  */\n     {\n       write_template_prefix (decl);\n@@ -1195,15 +1174,14 @@ write_template_prefix (const tree node)\n   tree decl = DECL_P (node) ? node : TYPE_NAME (node);\n   tree type = DECL_P (node) ? TREE_TYPE (node) : node;\n   tree context = decl_mangling_context (decl);\n-  tree template_info;\n   tree templ;\n   tree substitution;\n \n   MANGLE_TRACE_TREE (\"template-prefix\", node);\n \n   /* Find the template decl.  */\n-  if (decl_is_template_id (decl, &template_info))\n-    templ = TI_TEMPLATE (template_info);\n+  if (tree info = maybe_template_info (decl))\n+    templ = TI_TEMPLATE (info);\n   else if (TREE_CODE (type) == TYPENAME_TYPE)\n     /* For a typename type, all we have is the name.  */\n     templ = DECL_NAME (decl);\n@@ -1369,7 +1347,7 @@ write_unqualified_name (tree decl)\n \t  /* Conversion operator. Handle it right here.\n \t     <operator> ::= cv <type>  */\n \t  tree type;\n-\t  if (decl_is_template_id (decl, NULL))\n+\t  if (maybe_template_info (decl))\n \t    {\n \t      tree fn_type;\n \t      fn_type = get_mostly_instantiated_function_type (decl);\n@@ -1413,8 +1391,7 @@ write_unqualified_name (tree decl)\n       if (TREE_CODE (decl) == TYPE_DECL\n           && TYPE_UNNAMED_P (type))\n         write_unnamed_type_name (type);\n-      else if (TREE_CODE (decl) == TYPE_DECL\n-               && LAMBDA_TYPE_P (type))\n+      else if (TREE_CODE (decl) == TYPE_DECL && LAMBDA_TYPE_P (type))\n         write_closure_type_name (type);\n       else\n         write_source_name (DECL_NAME (decl));"}]}