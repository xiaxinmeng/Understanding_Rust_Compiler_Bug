{"sha": "cfe8dbd9c08a5bce497646467c9d30942ec3efe0", "node_id": "C_kwDOANBUbNoAKGNmZThkYmQ5YzA4YTViY2U0OTc2NDY0NjdjOWQzMDk0MmVjM2VmZTA", "commit": {"author": {"name": "Antoni Boucher", "email": "bouanto@zoho.com", "date": "2021-11-20T01:44:34Z"}, "committer": {"name": "Antoni Boucher", "email": "bouanto@zoho.com", "date": "2021-11-20T01:45:12Z"}, "message": "libgccjit: Add some reflection functions [PR96889]\n\n2021-11-19  Antoni Boucher  <bouanto@zoho.com>\n\ngcc/jit/\n\tPR target/96889\n\t* docs/topics/compatibility.rst (LIBGCCJIT_ABI_16): New ABI tag.\n\t* docs/topics/functions.rst: Add documentation for the\n\tfunctions gcc_jit_function_get_return_type and\n\tgcc_jit_function_get_param_count\n\t* docs/topics/types.rst: Add documentation for the functions\n\tgcc_jit_function_type_get_return_type,\n\tgcc_jit_function_type_get_param_count,\n\tgcc_jit_function_type_get_param_type,\n\tgcc_jit_type_unqualified, gcc_jit_type_dyncast_array,\n\tgcc_jit_type_is_bool,\n\tgcc_jit_type_dyncast_function_ptr_type,\n\tgcc_jit_type_is_integral, gcc_jit_type_is_pointer,\n\tgcc_jit_type_dyncast_vector,\n\tgcc_jit_vector_type_get_element_type,\n\tgcc_jit_vector_type_get_num_units,\n\tgcc_jit_struct_get_field, gcc_jit_type_is_struct,\n\tand gcc_jit_struct_get_field_count\n\t* libgccjit.c:\n\t(gcc_jit_function_get_return_type, gcc_jit_function_get_param_count,\n\tgcc_jit_function_type_get_return_type,\n\tgcc_jit_function_type_get_param_count,\n\tgcc_jit_function_type_get_param_type, gcc_jit_type_unqualified,\n\tgcc_jit_type_dyncast_array, gcc_jit_type_is_bool,\n\tgcc_jit_type_dyncast_function_ptr_type, gcc_jit_type_is_integral,\n\tgcc_jit_type_is_pointer, gcc_jit_type_dyncast_vector,\n\tgcc_jit_vector_type_get_element_type,\n\tgcc_jit_vector_type_get_num_units, gcc_jit_struct_get_field,\n\tgcc_jit_type_is_struct, gcc_jit_struct_get_field_count): New\n\tfunctions.\n\t(struct gcc_jit_function_type, struct gcc_jit_vector_type):\n\tNew types.\n\t* libgccjit.h:\n\t(gcc_jit_function_get_return_type, gcc_jit_function_get_param_count,\n\tgcc_jit_function_type_get_return_type,\n\tgcc_jit_function_type_get_param_count,\n\tgcc_jit_function_type_get_param_type, gcc_jit_type_unqualified,\n\tgcc_jit_type_dyncast_array, gcc_jit_type_is_bool,\n\tgcc_jit_type_dyncast_function_ptr_type, gcc_jit_type_is_integral,\n\tgcc_jit_type_is_pointer, gcc_jit_type_dyncast_vector,\n\tgcc_jit_vector_type_get_element_type,\n\tgcc_jit_vector_type_get_num_units, gcc_jit_struct_get_field,\n\tgcc_jit_type_is_struct, gcc_jit_struct_get_field_count): New\n\tfunction declarations.\n\t(struct gcc_jit_function_type, struct gcc_jit_vector_type):\n\tNew types.\n\t* jit-recording.h: New functions (is_struct and is_vector)\n\t* libgccjit.map (LIBGCCJIT_ABI_16): New ABI tag.\n\ngcc/testsuite/\n\tPR target/96889\n\t* jit.dg/all-non-failing-tests.h: Add test-reflection.c.\n\t* jit.dg/test-reflection.c: New test.", "tree": {"sha": "cb2e214e560dfefffe386c811b5882b6db2ef651", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cb2e214e560dfefffe386c811b5882b6db2ef651"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cfe8dbd9c08a5bce497646467c9d30942ec3efe0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfe8dbd9c08a5bce497646467c9d30942ec3efe0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cfe8dbd9c08a5bce497646467c9d30942ec3efe0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfe8dbd9c08a5bce497646467c9d30942ec3efe0/comments", "author": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c0773984c8ec6dc1838f94177b4594b74650765", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c0773984c8ec6dc1838f94177b4594b74650765", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c0773984c8ec6dc1838f94177b4594b74650765"}], "stats": {"total": 677, "additions": 676, "deletions": 1}, "files": [{"sha": "52ee3f860a77b1818513a62ed72e4d2d90f9a3df", "filename": "gcc/jit/docs/topics/compatibility.rst", "status": "modified", "additions": 42, "deletions": 1, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfe8dbd9c08a5bce497646467c9d30942ec3efe0/gcc%2Fjit%2Fdocs%2Ftopics%2Fcompatibility.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfe8dbd9c08a5bce497646467c9d30942ec3efe0/gcc%2Fjit%2Fdocs%2Ftopics%2Fcompatibility.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Ftopics%2Fcompatibility.rst?ref=cfe8dbd9c08a5bce497646467c9d30942ec3efe0", "patch": "@@ -230,7 +230,7 @@ entrypoints:\n .. _LIBGCCJIT_ABI_15:\n \n ``LIBGCCJIT_ABI_15``\n------------------------\n+--------------------\n ``LIBGCCJIT_ABI_15`` covers the addition of API entrypoints for directly\n embedding assembler instructions:\n \n@@ -243,3 +243,44 @@ embedding assembler instructions:\n   * :func:`gcc_jit_extended_asm_add_input_operand`\n   * :func:`gcc_jit_extended_asm_add_clobber`\n   * :func:`gcc_jit_context_add_top_level_asm`\n+\n+.. _LIBGCCJIT_ABI_16:\n+\n+``LIBGCCJIT_ABI_16``\n+--------------------\n+``LIBGCCJIT_ABI_16`` covers the addition of reflection functions via API\n+entrypoints:\n+\n+  * :func:`gcc_jit_function_get_return_type`\n+\n+  * :func:`gcc_jit_function_get_param_count`\n+\n+  * :func:`gcc_jit_type_dyncast_array`\n+\n+  * :func:`gcc_jit_type_is_bool`\n+\n+  * :func:`gcc_jit_type_is_integral`\n+\n+  * :func:`gcc_jit_type_is_pointer`\n+\n+  * :func:`gcc_jit_type_is_struct`\n+\n+  * :func:`gcc_jit_type_dyncast_vector`\n+\n+  * :func:`gcc_jit_type_unqualified`\n+\n+  * :func:`gcc_jit_type_dyncast_function_ptr_type`\n+\n+  * :func:`gcc_jit_function_type_get_return_type`\n+\n+  * :func:`gcc_jit_function_type_get_param_count`\n+\n+  * :func:`gcc_jit_function_type_get_param_type`\n+\n+  * :func:`gcc_jit_vector_type_get_num_units`\n+\n+  * :func:`gcc_jit_vector_type_get_element_type`\n+\n+  * :func:`gcc_jit_struct_get_field`\n+\n+  * :func:`gcc_jit_struct_get_field_count`"}, {"sha": "839934588da39346b82fdb3d1b524b5fa5931671", "filename": "gcc/jit/docs/topics/functions.rst", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfe8dbd9c08a5bce497646467c9d30942ec3efe0/gcc%2Fjit%2Fdocs%2Ftopics%2Ffunctions.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfe8dbd9c08a5bce497646467c9d30942ec3efe0/gcc%2Fjit%2Fdocs%2Ftopics%2Ffunctions.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Ftopics%2Ffunctions.rst?ref=cfe8dbd9c08a5bce497646467c9d30942ec3efe0", "patch": "@@ -171,6 +171,32 @@ Functions\n    underlying string, so it is valid to pass in a pointer to an on-stack\n    buffer.\n \n+.. function::  size_t \\\n+               gcc_jit_function_get_param_count (gcc_jit_function *func)\n+\n+   Get the number of parameters of the function.\n+\n+.. function::  gcc_jit_type *\\\n+               gcc_jit_function_get_return_type (gcc_jit_function *func)\n+\n+   Get the return type of the function.\n+\n+   The API entrypoints relating to getting info about parameters and return\n+   types:\n+\n+      * :c:func:`gcc_jit_function_get_return_type`\n+\n+      * :c:func:`gcc_jit_function_get_param_count`\n+\n+   were added in :ref:`LIBGCCJIT_ABI_16`; you can test for their presence\n+   using\n+\n+   .. code-block:: c\n+\n+      #ifdef LIBGCCJIT_HAVE_REFLECTION\n+\n+   .. type:: gcc_jit_case\n+\n Blocks\n ------\n .. type:: gcc_jit_block"}, {"sha": "6260e9afba4ac2763c0d11c5239d0813c89b39b8", "filename": "gcc/jit/docs/topics/types.rst", "status": "modified", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfe8dbd9c08a5bce497646467c9d30942ec3efe0/gcc%2Fjit%2Fdocs%2Ftopics%2Ftypes.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfe8dbd9c08a5bce497646467c9d30942ec3efe0/gcc%2Fjit%2Fdocs%2Ftopics%2Ftypes.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Ftopics%2Ftypes.rst?ref=cfe8dbd9c08a5bce497646467c9d30942ec3efe0", "patch": "@@ -345,3 +345,125 @@ Function pointer types\n \n Function pointer types can be created using\n :c:func:`gcc_jit_context_new_function_ptr_type`.\n+\n+Reflection API\n+--------------\n+\n+.. function::  gcc_jit_type *\\\n+               gcc_jit_type_dyncast_array (gcc_jit_type *type)\n+\n+     Get the element type of an array type or NULL if it's not an array.\n+\n+.. function::  int\\\n+               gcc_jit_type_is_bool (gcc_jit_type *type)\n+\n+     Return non-zero if the type is a bool.\n+\n+.. function::  gcc_jit_function_type *\\\n+               gcc_jit_type_dyncast_function_ptr_type (gcc_jit_type *type)\n+\n+     Return the function type if it is one or NULL.\n+\n+.. function::  gcc_jit_type *\\\n+               gcc_jit_function_type_get_return_type (gcc_jit_function_type *function_type)\n+\n+     Given a function type, return its return type.\n+\n+.. function::  size_t\\\n+               gcc_jit_function_type_get_param_count (gcc_jit_function_type *function_type)\n+\n+     Given a function type, return its number of parameters.\n+\n+.. function::  gcc_jit_type *\\\n+               gcc_jit_function_type_get_param_type (gcc_jit_function_type *function_type,\n+                                                     size_t index)\n+\n+     Given a function type, return the type of the specified parameter.\n+\n+.. function::  int\\\n+               gcc_jit_type_is_integral (gcc_jit_type *type)\n+\n+     Return non-zero if the type is an integral.\n+\n+.. function::  gcc_jit_type *\\\n+               gcc_jit_type_is_pointer (gcc_jit_type *type)\n+\n+     Return the type pointed by the pointer type or NULL if it's not a pointer.\n+\n+.. function::  gcc_jit_vector_type *\\\n+               gcc_jit_type_dyncast_vector (gcc_jit_type *type)\n+\n+     Given a type, return a dynamic cast to a vector type or NULL.\n+\n+.. function::  gcc_jit_struct *\\\n+               gcc_jit_type_is_struct (gcc_jit_type *type)\n+\n+     Given a type, return a dynamic cast to a struct type or NULL.\n+\n+.. function::  size_t\\\n+               gcc_jit_vector_type_get_num_units (gcc_jit_vector_type *vector_type)\n+\n+     Given a vector type, return the number of units it contains.\n+\n+.. function::  gcc_jit_type *\\\n+               gcc_jit_vector_type_get_element_type (gcc_jit_vector_type * vector_type)\n+\n+     Given a vector type, return the type of its elements.\n+\n+.. function::  gcc_jit_type *\\\n+               gcc_jit_type_unqualified (gcc_jit_type *type)\n+\n+     Given a type, return the unqualified type, removing \"const\", \"volatile\" and\n+     alignment qualifiers.\n+\n+.. function::  gcc_jit_field *\\\n+               gcc_jit_struct_get_field (gcc_jit_struct *struct_type,\n+                                         size_t index)\n+\n+     Get a struct field by index.\n+\n+.. function::  size_t\\\n+               gcc_jit_struct_get_field_count (gcc_jit_struct *struct_type)\n+\n+     Get the number of fields in the struct.\n+\n+   The API entrypoints related to the reflection API:\n+\n+      * :c:func:`gcc_jit_function_type_get_return_type`\n+\n+      * :c:func:`gcc_jit_function_type_get_param_count`\n+\n+      * :c:func:`gcc_jit_function_type_get_param_type`\n+\n+      * :c:func:`gcc_jit_type_unqualified`\n+\n+      * :c:func:`gcc_jit_type_dyncast_array`\n+\n+      * :c:func:`gcc_jit_type_is_bool`\n+\n+      * :c:func:`gcc_jit_type_dyncast_function_ptr_type`\n+\n+      * :c:func:`gcc_jit_type_is_integral`\n+\n+      * :c:func:`gcc_jit_type_is_pointer`\n+\n+      * :c:func:`gcc_jit_type_dyncast_vector`\n+\n+      * :c:func:`gcc_jit_vector_type_get_element_type`\n+\n+      * :c:func:`gcc_jit_vector_type_get_num_units`\n+\n+      * :c:func:`gcc_jit_struct_get_field`\n+\n+      * :c:func:`gcc_jit_type_is_struct`\n+\n+      * :c:func:`gcc_jit_struct_get_field_count`\n+\n+   were added in :ref:`LIBGCCJIT_ABI_16`; you can test for their presence\n+   using\n+\n+   .. code-block:: c\n+\n+      #ifdef LIBGCCJIT_HAVE_REFLECTION\n+\n+   .. type:: gcc_jit_case"}, {"sha": "4a994fe7094f5f9160d6ca16dc8ac6dfdddee4df", "filename": "gcc/jit/jit-recording.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfe8dbd9c08a5bce497646467c9d30942ec3efe0/gcc%2Fjit%2Fjit-recording.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfe8dbd9c08a5bce497646467c9d30942ec3efe0/gcc%2Fjit%2Fjit-recording.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fjit-recording.h?ref=cfe8dbd9c08a5bce497646467c9d30942ec3efe0", "patch": "@@ -546,7 +546,9 @@ class type : public memento\n   virtual bool is_bool () const = 0;\n   virtual type *is_pointer () = 0;\n   virtual type *is_array () = 0;\n+  virtual struct_ *is_struct () { return NULL; }\n   virtual bool is_void () const { return false; }\n+  virtual vector_type *is_vector () { return NULL; }\n   virtual bool has_known_size () const { return true; }\n \n   bool is_numeric () const\n@@ -663,6 +665,7 @@ class decorated_type : public type\n   bool is_bool () const FINAL OVERRIDE { return m_other_type->is_bool (); }\n   type *is_pointer () FINAL OVERRIDE { return m_other_type->is_pointer (); }\n   type *is_array () FINAL OVERRIDE { return m_other_type->is_array (); }\n+  struct_ *is_struct () FINAL OVERRIDE { return m_other_type->is_struct (); }\n \n protected:\n   type *m_other_type;\n@@ -745,6 +748,8 @@ class vector_type : public decorated_type\n \n   void replay_into (replayer *) FINAL OVERRIDE;\n \n+  vector_type *is_vector () FINAL OVERRIDE { return this; }\n+\n private:\n   string * make_debug_string () FINAL OVERRIDE;\n   void write_reproducer (reproducer &r) FINAL OVERRIDE;\n@@ -951,6 +956,8 @@ class struct_ : public compound_type\n \n   const char *access_as_type (reproducer &r) FINAL OVERRIDE;\n \n+  struct_ *is_struct () FINAL OVERRIDE { return this; }\n+\n private:\n   string * make_debug_string () FINAL OVERRIDE;\n   void write_reproducer (reproducer &r) FINAL OVERRIDE;"}, {"sha": "c744b634f4b99f76cc5c0a217f6fd4722e6a29c8", "filename": "gcc/jit/libgccjit.c", "status": "modified", "additions": 264, "deletions": 0, "changes": 264, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfe8dbd9c08a5bce497646467c9d30942ec3efe0/gcc%2Fjit%2Flibgccjit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfe8dbd9c08a5bce497646467c9d30942ec3efe0/gcc%2Fjit%2Flibgccjit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Flibgccjit.c?ref=cfe8dbd9c08a5bce497646467c9d30942ec3efe0", "patch": "@@ -60,6 +60,14 @@ struct gcc_jit_struct : public gcc::jit::recording::struct_\n {\n };\n \n+struct gcc_jit_function_type : public gcc::jit::recording::function_type\n+{\n+};\n+\n+struct gcc_jit_vector_type : public gcc::jit::recording::vector_type\n+{\n+};\n+\n struct gcc_jit_field : public gcc::jit::recording::field\n {\n };\n@@ -515,6 +523,197 @@ gcc_jit_type_get_volatile (gcc_jit_type *type)\n   return (gcc_jit_type *)type->get_volatile ();\n }\n \n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::type::is_array method, in\n+   jit-recording.c.  */\n+\n+gcc_jit_type *\n+gcc_jit_type_dyncast_array (gcc_jit_type *type)\n+{\n+  RETURN_NULL_IF_FAIL (type, NULL, NULL, \"NULL type\");\n+\n+  return (gcc_jit_type *)type->is_array ();\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::type::is_bool method, in\n+   jit-recording.c.  */\n+\n+int\n+gcc_jit_type_is_bool (gcc_jit_type *type)\n+{\n+  RETURN_VAL_IF_FAIL (type, FALSE, NULL, NULL, \"NULL type\");\n+\n+  return type->is_bool ();\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::type::is_pointer method, in\n+   jit-recording.c.  */\n+\n+gcc_jit_type *\n+gcc_jit_type_is_pointer (gcc_jit_type *type)\n+{\n+  RETURN_NULL_IF_FAIL (type, NULL, NULL, \"NULL type\");\n+\n+  return (gcc_jit_type *)type->is_pointer ();\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::type::is_int method, in\n+   jit-recording.c.  */\n+\n+int\n+gcc_jit_type_is_integral (gcc_jit_type *type)\n+{\n+  RETURN_VAL_IF_FAIL (type, FALSE, NULL, NULL, \"NULL type\");\n+\n+  return type->is_int ();\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::type::is_vector method, in\n+   jit-recording.c.  */\n+\n+gcc_jit_vector_type *\n+gcc_jit_type_dyncast_vector (gcc_jit_type *type)\n+{\n+  RETURN_NULL_IF_FAIL (type, NULL, NULL, \"NULL type\");\n+  gcc::jit::recording::vector_type *vector_type = type->is_vector ();\n+  return (gcc_jit_vector_type *)vector_type;\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::type::is_struct method, in\n+   jit-recording.c.  */\n+\n+gcc_jit_struct *\n+gcc_jit_type_is_struct (gcc_jit_type *type)\n+{\n+  RETURN_NULL_IF_FAIL (type, NULL, NULL, \"NULL type\");\n+  gcc::jit::recording::struct_ *struct_type = type->is_struct ();\n+  return (gcc_jit_struct *)struct_type;\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::vector_type::get_num_units method, in\n+   jit-recording.c.  */\n+\n+size_t\n+gcc_jit_vector_type_get_num_units (gcc_jit_vector_type *vector_type)\n+{\n+  RETURN_VAL_IF_FAIL (vector_type, 0, NULL, NULL, \"NULL vector_type\");\n+  return vector_type->get_num_units ();\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::vector_type::get_element_type method, in\n+   jit-recording.c.  */\n+\n+gcc_jit_type *\n+gcc_jit_vector_type_get_element_type (gcc_jit_vector_type *vector_type)\n+{\n+  RETURN_NULL_IF_FAIL (vector_type, NULL, NULL, \"NULL vector_type\");\n+  return (gcc_jit_type *)vector_type->get_element_type ();\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::type::unqualified method, in\n+   jit-recording.c.  */\n+\n+gcc_jit_type *\n+gcc_jit_type_unqualified (gcc_jit_type *type)\n+{\n+  RETURN_NULL_IF_FAIL (type, NULL, NULL, \"NULL type\");\n+\n+  return (gcc_jit_type *)type->unqualified ();\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::type::dyn_cast_function_type method, in\n+   jit-recording.c.  */\n+\n+gcc_jit_function_type *\n+gcc_jit_type_dyncast_function_ptr_type (gcc_jit_type *type)\n+{\n+  RETURN_NULL_IF_FAIL (type, NULL, NULL, \"NULL type\");\n+  gcc::jit::recording::type *func_ptr_type = type->dereference ();\n+  if (!func_ptr_type)\n+  {\n+    return NULL;\n+  }\n+\n+  return (gcc_jit_function_type *)func_ptr_type->dyn_cast_function_type ();\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::function_type::get_return_type method, in\n+   jit-recording.c.  */\n+\n+gcc_jit_type *\n+gcc_jit_function_type_get_return_type (gcc_jit_function_type *function_type)\n+{\n+  RETURN_NULL_IF_FAIL (function_type, NULL, NULL, \"NULL function_type\");\n+  return (gcc_jit_type *)function_type->get_return_type ();\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::function_type::get_param_types method, in\n+   jit-recording.c.  */\n+\n+size_t\n+gcc_jit_function_type_get_param_count (gcc_jit_function_type *function_type)\n+{\n+  RETURN_VAL_IF_FAIL (function_type, 0, NULL, NULL, \"NULL function_type\");\n+  return function_type->get_param_types ().length ();\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::function_type::get_param_types method, in\n+   jit-recording.c.  */\n+\n+gcc_jit_type *\n+gcc_jit_function_type_get_param_type (gcc_jit_function_type *function_type,\n+\t\t\t\tsize_t index)\n+{\n+  RETURN_NULL_IF_FAIL (function_type, NULL, NULL, \"NULL function_type\");\n+  size_t num_params = function_type->get_param_types ().length ();\n+  gcc::jit::recording::context *ctxt = function_type->m_ctxt;\n+  RETURN_NULL_IF_FAIL_PRINTF3 (index < num_params,\n+\t\t\t       ctxt, NULL,\n+\t\t\t       \"index of %ld is too large (%s has %ld params)\",\n+\t\t\t       index,\n+\t\t\t       function_type->get_debug_string (),\n+\t\t\t       num_params);\n+  return (gcc_jit_type *)function_type->get_param_types ()[index];\n+}\n+\n /* Public entrypoint.  See description in libgccjit.h.\n \n    After error-checking, the real work is done by the\n@@ -736,6 +935,42 @@ gcc_jit_struct_set_fields (gcc_jit_struct *struct_type,\n \t\t\t   (gcc::jit::recording::field **)fields);\n }\n \n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::fields::get_field method in\n+   jit-recording.c.  */\n+extern gcc_jit_field *\n+gcc_jit_struct_get_field (gcc_jit_struct *struct_type,\n+\t\t\t   size_t index)\n+{\n+  RETURN_NULL_IF_FAIL (struct_type, NULL, NULL, \"NULL struct type\");\n+  RETURN_NULL_IF_FAIL (struct_type->get_fields (), NULL, NULL,\n+\t\t\t\t\"NULL struct fields\");\n+  size_t num_fields = struct_type->get_fields ()->length ();\n+  RETURN_NULL_IF_FAIL_PRINTF3 (index < num_fields,\n+\t\t\t       NULL, NULL,\n+\t\t\t       \"index of %ld is too large (%s has %ld fields)\",\n+\t\t\t       index,\n+\t\t\t       struct_type->get_debug_string (),\n+\t\t\t       num_fields);\n+  return (gcc_jit_field *)struct_type->get_fields ()->get_field (index);\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, this calls the trivial\n+   gcc::jit::recording::struct_::get_fields method in\n+   jit-recording.h.  */\n+\n+size_t\n+gcc_jit_struct_get_field_count (gcc_jit_struct *struct_type)\n+{\n+  RETURN_VAL_IF_FAIL (struct_type, 0, NULL, NULL, \"NULL struct type\");\n+  return struct_type->get_fields ()->length ();\n+}\n+\n /* Public entrypoint.  See description in libgccjit.h.\n \n    After error-checking, the real work is done by the\n@@ -1017,6 +1252,35 @@ gcc_jit_function_get_param (gcc_jit_function *func, int index)\n   return static_cast <gcc_jit_param *> (func->get_param (index));\n }\n \n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::function::get_params method, in\n+   jit-recording.h.\n+  */\n+\n+size_t\n+gcc_jit_function_get_param_count (gcc_jit_function *func)\n+{\n+  RETURN_VAL_IF_FAIL (func, 0, NULL, NULL, \"NULL function\");\n+  gcc::jit::recording::context *ctxt = func->m_ctxt;\n+  JIT_LOG_FUNC (ctxt->get_logger ());\n+  return func->get_params ().length ();\n+}\n+\n+/* Public entrypoint.  See description in libgccjit.h.\n+\n+   After error-checking, the real work is done by the\n+   gcc::jit::recording::function::get_return_type method, in\n+   jit-recording.h.  */\n+\n+gcc_jit_type *\n+gcc_jit_function_get_return_type (gcc_jit_function *func)\n+{\n+    RETURN_NULL_IF_FAIL (func, NULL, NULL, \"NULL function_type\");\n+    return (gcc_jit_type *)func->get_return_type ();\n+}\n+\n /* Public entrypoint.  See description in libgccjit.h.\n \n    After error-checking, the real work is done by the"}, {"sha": "a1c9436c545a8b1721acd4944766c129a4f4740a", "filename": "gcc/jit/libgccjit.h", "status": "modified", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfe8dbd9c08a5bce497646467c9d30942ec3efe0/gcc%2Fjit%2Flibgccjit.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfe8dbd9c08a5bce497646467c9d30942ec3efe0/gcc%2Fjit%2Flibgccjit.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Flibgccjit.h?ref=cfe8dbd9c08a5bce497646467c9d30942ec3efe0", "patch": "@@ -61,6 +61,8 @@ typedef struct gcc_jit_result gcc_jit_result;\n \t +- gcc_jit_location\n \t +- gcc_jit_type\n \t    +- gcc_jit_struct\n+\t    +- gcc_jit_function_type\n+\t    +- gcc_jit_vector_type\n \t +- gcc_jit_field\n \t +- gcc_jit_function\n \t +- gcc_jit_block\n@@ -97,6 +99,12 @@ typedef struct gcc_jit_field gcc_jit_field;\n    the layout for, or an opaque type.  */\n typedef struct gcc_jit_struct gcc_jit_struct;\n \n+/* A gcc_jit_function_type encapsulates a function type.  */\n+typedef struct gcc_jit_function_type gcc_jit_function_type;\n+\n+/* A gcc_jit_vector_type encapsulates a vector type.  */\n+typedef struct gcc_jit_vector_type gcc_jit_vector_type;\n+\n /* A gcc_jit_function encapsulates a function: either one that you're\n    creating yourself, or a reference to one that you're dynamically\n    linking to within the rest of the process.  */\n@@ -654,6 +662,15 @@ gcc_jit_struct_set_fields (gcc_jit_struct *struct_type,\n \t\t\t   int num_fields,\n \t\t\t   gcc_jit_field **fields);\n \n+/* Get a field by index.  */\n+extern gcc_jit_field *\n+gcc_jit_struct_get_field (gcc_jit_struct *struct_type,\n+\t\t\t   size_t index);\n+\n+/* Get the number of fields.  */\n+extern size_t\n+gcc_jit_struct_get_field_count (gcc_jit_struct *struct_type);\n+\n /* Unions work similarly to structs.  */\n extern gcc_jit_type *\n gcc_jit_context_new_union_type (gcc_jit_context *ctxt,\n@@ -1621,6 +1638,78 @@ gcc_jit_context_add_top_level_asm (gcc_jit_context *ctxt,\n \t\t\t\t   gcc_jit_location *loc,\n \t\t\t\t   const char *asm_stmts);\n \n+#define LIBGCCJIT_HAVE_REFLECTION\n+\n+/* Reflection functions to get the number of parameters, return type of\n+   a function and whether a type is a bool from the C API.\n+\n+   This API entrypoint was added in LIBGCCJIT_ABI_16; you can test for its\n+   presence using\n+     #ifdef LIBGCCJIT_HAVE_REFLECTION\n+*/\n+/* Get the return type of a function.  */\n+extern gcc_jit_type *\n+gcc_jit_function_get_return_type (gcc_jit_function *func);\n+\n+/* Get the number of params of a function.  */\n+extern size_t\n+gcc_jit_function_get_param_count (gcc_jit_function *func);\n+\n+/* Get the element type of an array type or NULL if it's not an array.  */\n+extern gcc_jit_type *\n+gcc_jit_type_dyncast_array (gcc_jit_type *type);\n+\n+/* Return non-zero if the type is a bool.  */\n+extern int\n+gcc_jit_type_is_bool (gcc_jit_type *type);\n+\n+/* Return the function type if it is one or NULL.  */\n+extern gcc_jit_function_type *\n+gcc_jit_type_dyncast_function_ptr_type (gcc_jit_type *type);\n+\n+/* Given a function type, return its return type.  */\n+extern gcc_jit_type *\n+gcc_jit_function_type_get_return_type (gcc_jit_function_type *function_type);\n+\n+/* Given a function type, return its number of parameters.  */\n+extern size_t\n+gcc_jit_function_type_get_param_count (gcc_jit_function_type *function_type);\n+\n+/* Given a function type, return the type of the specified parameter.  */\n+extern gcc_jit_type *\n+gcc_jit_function_type_get_param_type (gcc_jit_function_type *function_type,\n+\t\t\t\tsize_t index);\n+\n+/* Return non-zero if the type is an integral.  */\n+extern int\n+gcc_jit_type_is_integral (gcc_jit_type *type);\n+\n+/* Return the type pointed by the pointer type or NULL if it's not a\n+ * pointer.  */\n+extern gcc_jit_type *\n+gcc_jit_type_is_pointer (gcc_jit_type *type);\n+\n+/* Given a type, return a dynamic cast to a vector type or NULL.  */\n+extern gcc_jit_vector_type *\n+gcc_jit_type_dyncast_vector (gcc_jit_type *type);\n+\n+/* Given a type, return a dynamic cast to a struct type or NULL.  */\n+extern gcc_jit_struct *\n+gcc_jit_type_is_struct (gcc_jit_type *type);\n+\n+/* Given a vector type, return the number of units it contains.  */\n+extern size_t\n+gcc_jit_vector_type_get_num_units (gcc_jit_vector_type *vector_type);\n+\n+/* Given a vector type, return the type of its elements.  */\n+extern gcc_jit_type *\n+gcc_jit_vector_type_get_element_type (gcc_jit_vector_type *vector_type);\n+\n+/* Given a type, return the unqualified type, removing \"const\", \"volatile\"\n+ * and alignment qualifiers.  */\n+extern gcc_jit_type *\n+gcc_jit_type_unqualified (gcc_jit_type *type);\n+\n #ifdef __cplusplus\n }\n #endif /* __cplusplus */"}, {"sha": "64e790949e845e49eb79b339e25a0d4fb6de4550", "filename": "gcc/jit/libgccjit.map", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfe8dbd9c08a5bce497646467c9d30942ec3efe0/gcc%2Fjit%2Flibgccjit.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfe8dbd9c08a5bce497646467c9d30942ec3efe0/gcc%2Fjit%2Flibgccjit.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Flibgccjit.map?ref=cfe8dbd9c08a5bce497646467c9d30942ec3efe0", "patch": "@@ -205,3 +205,24 @@ LIBGCCJIT_ABI_15 {\n     gcc_jit_extended_asm_add_clobber;\n     gcc_jit_context_add_top_level_asm;\n } LIBGCCJIT_ABI_14;\n+\n+LIBGCCJIT_ABI_16 {\n+  global:\n+    gcc_jit_function_get_return_type;\n+    gcc_jit_function_get_param_count;\n+    gcc_jit_function_type_get_return_type;\n+    gcc_jit_function_type_get_param_count;\n+    gcc_jit_function_type_get_param_type;\n+    gcc_jit_type_unqualified;\n+    gcc_jit_type_dyncast_array;\n+    gcc_jit_type_is_bool;\n+    gcc_jit_type_dyncast_function_ptr_type;\n+    gcc_jit_type_is_integral;\n+    gcc_jit_type_is_pointer;\n+    gcc_jit_type_dyncast_vector;\n+    gcc_jit_vector_type_get_element_type;\n+    gcc_jit_vector_type_get_num_units;\n+    gcc_jit_struct_get_field;\n+    gcc_jit_type_is_struct;\n+    gcc_jit_struct_get_field_count;\n+} LIBGCCJIT_ABI_15;"}, {"sha": "a7fddf96db8bff3d6659d119344919912973e513", "filename": "gcc/testsuite/jit.dg/all-non-failing-tests.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfe8dbd9c08a5bce497646467c9d30942ec3efe0/gcc%2Ftestsuite%2Fjit.dg%2Fall-non-failing-tests.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfe8dbd9c08a5bce497646467c9d30942ec3efe0/gcc%2Ftestsuite%2Fjit.dg%2Fall-non-failing-tests.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Fall-non-failing-tests.h?ref=cfe8dbd9c08a5bce497646467c9d30942ec3efe0", "patch": "@@ -265,6 +265,13 @@\n #undef create_code\n #undef verify_code\n \n+/* test-reflection.c */\n+#define create_code create_code_reflection\n+#define verify_code verify_code_reflection\n+#include \"test-reflection.c\"\n+#undef create_code\n+#undef verify_code\n+\n /* test-string-literal.c */\n #define create_code create_code_string_literal\n #define verify_code verify_code_string_literal\n@@ -434,6 +441,9 @@ const struct testcase testcases[] = {\n   {\"reading_struct \",\n    create_code_reading_struct ,\n    verify_code_reading_struct },\n+  {\"reflection\",\n+   create_code_reflection ,\n+   verify_code_reflection },\n   {\"string_literal\",\n    create_code_string_literal,\n    verify_code_string_literal},"}, {"sha": "112a2455c072c1ba9ca278d1fb58c78e731dcff0", "filename": "gcc/testsuite/jit.dg/test-reflection.c", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfe8dbd9c08a5bce497646467c9d30942ec3efe0/gcc%2Ftestsuite%2Fjit.dg%2Ftest-reflection.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfe8dbd9c08a5bce497646467c9d30942ec3efe0/gcc%2Ftestsuite%2Fjit.dg%2Ftest-reflection.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fjit.dg%2Ftest-reflection.c?ref=cfe8dbd9c08a5bce497646467c9d30942ec3efe0", "patch": "@@ -0,0 +1,95 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include \"libgccjit.h\"\n+\n+#include \"harness.h\"\n+\n+void\n+create_code (gcc_jit_context *ctxt, void *user_data)\n+{\n+  /* Do nothing.  */\n+}\n+\n+void\n+verify_code (gcc_jit_context *ctxt, gcc_jit_result *result)\n+{\n+  /* Get the built-in functions.  */\n+  gcc_jit_function *builtin_sin =\n+    gcc_jit_context_get_builtin_function (ctxt, \"sin\");\n+\n+  CHECK_VALUE (gcc_jit_function_get_param_count(builtin_sin), 1);\n+\n+  gcc_jit_type *double_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_DOUBLE);\n+  CHECK_VALUE (gcc_jit_function_get_return_type(builtin_sin), double_type);\n+  CHECK (!gcc_jit_type_is_integral(double_type));\n+\n+  gcc_jit_type *bool_type =\n+    gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_BOOL);\n+  CHECK (gcc_jit_type_is_bool(bool_type));\n+  CHECK (!gcc_jit_type_is_integral(bool_type));\n+\n+  gcc_jit_type *aligned_bool_type =\n+    gcc_jit_type_get_aligned(gcc_jit_context_get_type (ctxt, GCC_JIT_TYPE_BOOL), 8);\n+  CHECK (gcc_jit_type_is_bool(aligned_bool_type));\n+  CHECK (bool_type != aligned_bool_type);\n+  CHECK_VALUE (gcc_jit_type_unqualified(aligned_bool_type), bool_type);\n+\n+  CHECK_VALUE (gcc_jit_type_unqualified(gcc_jit_type_get_const(bool_type)), bool_type);\n+  CHECK_VALUE (gcc_jit_type_unqualified(gcc_jit_type_get_volatile(bool_type)), bool_type);\n+\n+  gcc_jit_type *int64 =\n+    gcc_jit_context_get_int_type(ctxt, 8, 1);\n+  CHECK (gcc_jit_type_is_integral(int64));\n+  gcc_jit_type *uint64 =\n+    gcc_jit_context_get_int_type(ctxt, 8, 0);\n+  CHECK (gcc_jit_type_is_integral(uint64));\n+  gcc_jit_type *int8 =\n+    gcc_jit_context_get_int_type(ctxt, 1, 1);\n+  CHECK (gcc_jit_type_is_integral(int8));\n+  gcc_jit_type *uint8 =\n+    gcc_jit_context_get_int_type(ctxt, 1, 0);\n+  CHECK (gcc_jit_type_is_integral(uint8));\n+\n+  CHECK (!gcc_jit_type_dyncast_vector(double_type));\n+  gcc_jit_type *vec_type = gcc_jit_type_get_vector (double_type, 4);\n+  gcc_jit_vector_type *vector_type = gcc_jit_type_dyncast_vector(vec_type);\n+  CHECK (vector_type);\n+  CHECK (vec_type != double_type);\n+  CHECK_VALUE (gcc_jit_vector_type_get_element_type(vector_type), double_type);\n+  CHECK_VALUE (gcc_jit_vector_type_get_num_units(vector_type), 4);\n+\n+  CHECK (!gcc_jit_type_is_pointer(double_type));\n+  CHECK_VALUE (gcc_jit_type_is_pointer(gcc_jit_type_get_pointer(double_type)), double_type);\n+\n+  gcc_jit_type* params[2] = {int8, uint64};\n+  gcc_jit_type *function_ptr_type = gcc_jit_context_new_function_ptr_type(ctxt, NULL, int64, 2, params, 0);\n+  CHECK (!gcc_jit_type_dyncast_function_ptr_type (int64));\n+  gcc_jit_function_type *function_type = gcc_jit_type_dyncast_function_ptr_type (function_ptr_type);\n+  CHECK (function_type);\n+  int param_count = gcc_jit_function_type_get_param_count(function_type);\n+  CHECK_VALUE (param_count, 2);\n+  gcc_jit_type *return_type = gcc_jit_function_type_get_return_type(function_type);\n+  CHECK_VALUE (return_type, int64);\n+  gcc_jit_type *param1 = gcc_jit_function_type_get_param_type(function_type, 0);\n+  CHECK_VALUE (param1, int8);\n+  gcc_jit_type *param2 = gcc_jit_function_type_get_param_type(function_type, 1);\n+  CHECK_VALUE (param2, uint64);\n+\n+  gcc_jit_field *field1 = gcc_jit_context_new_field (ctxt, NULL, uint64, \"field1\");\n+  gcc_jit_field *field2 = gcc_jit_context_new_field (ctxt, NULL, double_type, \"field2\");\n+  gcc_jit_field *fields[2] = { field1, field2 };\n+  gcc_jit_struct *struct_type = gcc_jit_context_new_struct_type (ctxt, NULL, \"testStruct\", 2, fields);\n+  CHECK_VALUE (gcc_jit_struct_get_field_count(struct_type), 2);\n+  CHECK_VALUE (gcc_jit_struct_get_field(struct_type, 0), field1);\n+  CHECK_VALUE (gcc_jit_struct_get_field(struct_type, 1), field2);\n+  CHECK (!gcc_jit_type_is_struct(double_type));\n+  gcc_jit_struct *struct_ty = gcc_jit_type_is_struct(gcc_jit_struct_as_type(struct_type));\n+  CHECK_VALUE (struct_ty, struct_type);\n+\n+  CHECK (!gcc_jit_type_dyncast_array(double_type));\n+  gcc_jit_type* array_type = gcc_jit_context_new_array_type(ctxt, NULL, double_type, 1);\n+  CHECK_VALUE (gcc_jit_type_dyncast_array(array_type), double_type);\n+}\n+"}]}