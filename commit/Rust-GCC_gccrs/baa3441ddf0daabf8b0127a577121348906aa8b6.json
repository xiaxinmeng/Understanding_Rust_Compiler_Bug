{"sha": "baa3441ddf0daabf8b0127a577121348906aa8b6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmFhMzQ0MWRkZjBkYWFiZjhiMDEyN2E1NzcxMjEzNDg5MDZhYThiNg==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2007-04-06T09:14:55Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-04-06T09:14:55Z"}, "message": "2007-04-06  Robert Dewar  <dewar@adacore.com>\n\n\t* a-except.adb, a-except.ads, a-except-2005.ads, a-except-2005.adb\n\t(Local_Raise): New dummy procedure called when a raise is converted\n\tto a local goto. Used for debugger to detect that the exception\n\tis raised.\n\n\t* debug.adb: Document new d.g flag (expand local raise statements to\n\tgotos even if pragma Restriction (No_Exception_Propagation) is not set)\n\n\t* exp_sel.adb: Use Make_Implicit_Exception_Handler\n\n\t* exp_ch11.adb (Expand_Exception_Handlers): Use new flag -gnatw.x to\n\tsuppress warnings for unused handlers.\n\t(Warn_If_No_Propagation):  Use new flag -gnatw.x to suppress\n\twarnings for raise statements not handled locally.\n\t(Get_RT_Exception_Entity): New function\n\t(Get_Local_Call_Entity): New function\n\t(Find_Local_Handler): New function\n\t(Warn_If_No_Propagation): New procedure\n\t(Expand_At_End_Handler): Call Make_Implicit_Handler\n\t(Expand_Exception_Handlers): Major additions to deal with local handlers\n\t(Expand_N_Raise_Constraint_Error, Expand_N_Raise_Program_Error,\n\tExpand_N_Raise_Storage_Error, (Expand_N_Raise_Statement): Add handling\n\tfor local raise\n\n\t* exp_ch11.ads (Get_RT_Exception_Entity): New function\n\t(Get_Local_Call_Entity): New function\n\n\t* gnatbind.adb (Restriction_List): Add No_Exception_Propagation to list\n\tof restrictions that the binder will never suggest adding.\n\n\t* par-ch11.adb (P_Exception_Handler): Set Local_Raise_Statements field\n\tto No_Elist.\n\n\t* restrict.adb (Check_Restricted_Unit): GNAT.Current_Exception may not\n\tbe with'ed in the presence of pragma Restriction\n\t(No_Exception_Propagation).\n\n\t* sem.adb (Analyze): Add entries for N_Push and N_Pop nodes\n\n\t* sem_ch11.adb (Analyze_Exception_Handler): If there is a choice\n\tparameter, then the handler is not a suitable target for a local raise,\n\tand this is a violation of restriction No_Exception_Propagation.\n\t(Analyze_Handled_Statements): Analyze choice parameters in exception\n\thandlers before analyzing statement sequence (needed for proper\n\tdetection of local raise statements).\n\t(Analyze_Raise_Statement): Reraise statement is a violation of the\n\tNo_Exception_Propagation restriction.\n\n\t* s-rident.ads: Add new restriction No_Exception_Propagation\n\n\t* tbuild.ads, tbuild.adb (Make_Implicit_Exception_Handler): New\n\tfunction, like Make_Exception_Handler but sets Local_Raise_Statements\n\tto No_List.\n\t(Add_Unique_Serial_Number): Deal with case where this is called during\n\tprocessing of configuration pragmas.\n\nFrom-SVN: r123541", "tree": {"sha": "cba8eae2edc131dbad1e78e6ab2c7326e84a7ed9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cba8eae2edc131dbad1e78e6ab2c7326e84a7ed9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/baa3441ddf0daabf8b0127a577121348906aa8b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/baa3441ddf0daabf8b0127a577121348906aa8b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/baa3441ddf0daabf8b0127a577121348906aa8b6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/baa3441ddf0daabf8b0127a577121348906aa8b6/comments", "author": null, "committer": null, "parents": [{"sha": "c5173b1ab367b28977368972a2aa9a04ef53da2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5173b1ab367b28977368972a2aa9a04ef53da2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5173b1ab367b28977368972a2aa9a04ef53da2e"}], "stats": {"total": 1525, "additions": 1315, "deletions": 210}, "files": [{"sha": "48633214f64daf8a1e1c8b2fe15681c871013d7e", "filename": "gcc/ada/a-except-2005.adb", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baa3441ddf0daabf8b0127a577121348906aa8b6/gcc%2Fada%2Fa-except-2005.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baa3441ddf0daabf8b0127a577121348906aa8b6/gcc%2Fada%2Fa-except-2005.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-except-2005.adb?ref=baa3441ddf0daabf8b0127a577121348906aa8b6", "patch": "@@ -760,6 +760,16 @@ package body Ada.Exceptions is\n    --  in case we do not want any exception tracing support. This is\n    --  why this package is separated.\n \n+   -----------------\n+   -- Local_Raise --\n+   -----------------\n+\n+   procedure Local_Raise (Excep : Exception_Id) is\n+      pragma Warnings (Off, Excep);\n+   begin\n+      return;\n+   end Local_Raise;\n+\n    -----------------------\n    -- Stream Attributes --\n    -----------------------"}, {"sha": "f42d094ae0536ec21a9b57b6497cf72338c37b6f", "filename": "gcc/ada/a-except-2005.ads", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baa3441ddf0daabf8b0127a577121348906aa8b6/gcc%2Fada%2Fa-except-2005.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baa3441ddf0daabf8b0127a577121348906aa8b6/gcc%2Fada%2Fa-except-2005.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-except-2005.ads?ref=baa3441ddf0daabf8b0127a577121348906aa8b6", "patch": "@@ -139,6 +139,23 @@ package Ada.Exceptions is\n      (Source : Exception_Occurrence)\n       return   Exception_Occurrence_Access;\n \n+   --  Ada 2005 (AI-438): The language revision introduces the\n+   --  following subprograms and attribute definitions. We do not\n+   --  provide them explicitly; instead, the corresponding stream\n+   --  attributes are made available through a pragma Stream_Convert\n+   --  in the private part of this package.\n+\n+   --  procedure Read_Exception_Occurrence\n+   --    (Stream : not null access Ada.Streams.Root_Stream_Type'Class;\n+   --     Item   : out Exception_Occurrence);\n+\n+   --  procedure Write_Exception_Occurrence\n+   --    (Stream : not null access Ada.Streams.Root_Stream_Type'Class;\n+   --     Item   : Exception_Occurrence);\n+\n+   --  for Exception_Occurrence'Read use Read_Exception_Occurrence;\n+   --  for Exception_Occurrence'Write use Write_Exception_Occurrence;\n+\n private\n    package SSL renames System.Standard_Library;\n    package SP renames System.Parameters;\n@@ -192,6 +209,15 @@ private\n    --  private barrier, so we can place this function in the private part\n    --  where the compiler can find it, but the spec is unchanged.)\n \n+   procedure Local_Raise (Excep : Exception_Id);\n+   pragma Export (Ada, Local_Raise);\n+   --  This is a dummy routine, used only by the debugger for the purpose of\n+   --  logging local raise statements that were transformed into a direct goto\n+   --  to the handler code. The compiler in this case generates:\n+   --\n+   --    Local_Raise (exception_id);\n+   --    goto Handler\n+\n    procedure Raise_Exception_Always (E : Exception_Id; Message : String := \"\");\n    pragma No_Return (Raise_Exception_Always);\n    pragma Export (Ada, Raise_Exception_Always, \"__gnat_raise_exception\");"}, {"sha": "41d7e026689a61ab13870f37d8bd4d39625f31d6", "filename": "gcc/ada/a-except.adb", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baa3441ddf0daabf8b0127a577121348906aa8b6/gcc%2Fada%2Fa-except.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baa3441ddf0daabf8b0127a577121348906aa8b6/gcc%2Fada%2Fa-except.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-except.adb?ref=baa3441ddf0daabf8b0127a577121348906aa8b6", "patch": "@@ -690,6 +690,16 @@ package body Ada.Exceptions is\n    --  in case we do not want any exception tracing support. This is\n    --  why this package is separated.\n \n+   -----------------\n+   -- Local_Raise --\n+   -----------------\n+\n+   procedure Local_Raise (Excep : Exception_Id) is\n+      pragma Warnings (Off, Excep);\n+   begin\n+      return;\n+   end Local_Raise;\n+\n    -----------------------\n    -- Stream Attributes --\n    -----------------------"}, {"sha": "0c1f2246c002b5a877ec618f2414591c2b6df0b9", "filename": "gcc/ada/a-except.ads", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baa3441ddf0daabf8b0127a577121348906aa8b6/gcc%2Fada%2Fa-except.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baa3441ddf0daabf8b0127a577121348906aa8b6/gcc%2Fada%2Fa-except.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-except.ads?ref=baa3441ddf0daabf8b0127a577121348906aa8b6", "patch": "@@ -35,7 +35,10 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This version of Ada.Exceptions is a full Ada 95 version.\n+--  This version of Ada.Exceptions is a full Ada 95 version. It omits Ada 2005\n+--  features such as the additional definitions of Exception_Name returning\n+--  Wide_[Wide_]String.\n+\n --  It is used for building the compiler and the basic tools, since these\n --  builds may be done with bootstrap compilers that cannot handle these\n --  additions. The full version of Ada.Exceptions can be found in the files\n@@ -172,6 +175,15 @@ private\n    --  private barrier, so we can place this function in the private part\n    --  where the compiler can find it, but the spec is unchanged.)\n \n+   procedure Local_Raise (Excep : Exception_Id);\n+   pragma Export (Ada, Local_Raise);\n+   --  This is a dummy routine, used only by the debugger for the purpose of\n+   --  logging local raise statements that were transformed into a direct goto\n+   --  to the handler code. The compiler in this case generates:\n+   --\n+   --    Local_Raise (exception_id);\n+   --    goto Handler\n+\n    procedure Raise_Exception_Always (E : Exception_Id; Message : String := \"\");\n    pragma No_Return (Raise_Exception_Always);\n    pragma Export (Ada, Raise_Exception_Always, \"__gnat_raise_exception\");"}, {"sha": "e0823fa70c54e33ffb6b13c2b37550ca22744d2e", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baa3441ddf0daabf8b0127a577121348906aa8b6/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baa3441ddf0daabf8b0127a577121348906aa8b6/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=baa3441ddf0daabf8b0127a577121348906aa8b6", "patch": "@@ -99,7 +99,7 @@ package body Debug is\n    --  d.d\n    --  d.e\n    --  d.f  Inhibit folding of static expressions\n-   --  d.g\n+   --  d.g  Enable conversion of raise into goto\n    --  d.h\n    --  d.i\n    --  d.j\n@@ -474,6 +474,11 @@ package body Debug is\n    --       in seriously non-conforming behavior, but is useful sometimes\n    --       when tracking down handling of complex expressions.\n \n+   --  d.g  Enables conversion of a raise statement into a goto when the\n+   --       relevant handler is statically determinable. For now we only try\n+   --       this if this debug flag is set. Later we will enable this more\n+   --       generally by default.\n+\n    --  d.l  Use Ada 95 semantics for limited function returns. This may be\n    --       used to work around the incompatibility introduced by AI-318-2.\n    --       It is useful only in -gnat05 mode."}, {"sha": "61013c2016cf0b08d26e69dba137075a2bd2e2bd", "filename": "gcc/ada/exp_ch11.adb", "status": "modified", "additions": 1027, "deletions": 133, "changes": 1160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baa3441ddf0daabf8b0127a577121348906aa8b6/gcc%2Fada%2Fexp_ch11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baa3441ddf0daabf8b0127a577121348906aa8b6/gcc%2Fada%2Fexp_ch11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch11.adb?ref=baa3441ddf0daabf8b0127a577121348906aa8b6", "patch": "@@ -28,6 +28,7 @@ with Atree;    use Atree;\n with Casing;   use Casing;\n with Debug;    use Debug;\n with Einfo;    use Einfo;\n+with Elists;   use Elists;\n with Errout;   use Errout;\n with Exp_Ch7;  use Exp_Ch7;\n with Exp_Util; use Exp_Util;\n@@ -54,6 +55,26 @@ with Uintp;    use Uintp;\n \n package body Exp_Ch11 is\n \n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   function Find_Local_Handler\n+     (Ename : Entity_Id;\n+      Nod   : Node_Id) return Node_Id;\n+   pragma Warnings (Off, Find_Local_Handler);\n+   --  This function searches for a local exception handler that will handle\n+   --  the exception named by Ename. If such a local hander exists, then the\n+   --  corresponding N_Exception_Handler is returned. If no such handler is\n+   --  found then Empty is returned. In order to match and return True, the\n+   --  handler may not have a choice parameter specification. N is the raise\n+   --  node that references the handler.\n+\n+   procedure Warn_If_No_Propagation (N : Node_Id);\n+   --  Called for an exception raise that is not a local raise (and thus can\n+   --  not be optimized to a goto. Issues warning if No_Exception_Propagation\n+   --  restriction is set. N is the node for the raise or equivalent call.\n+\n    ---------------------------\n    -- Expand_At_End_Handler --\n    ---------------------------\n@@ -128,7 +149,7 @@ package body Exp_Ch11 is\n         Make_Raise_Statement (Loc));\n \n       Set_Exception_Handlers (HSS, New_List (\n-        Make_Exception_Handler (Loc,\n+        Make_Implicit_Exception_Handler (Loc,\n           Exception_Choices => New_List (Ohandle),\n           Statements        => Stmnts)));\n \n@@ -145,18 +166,590 @@ package body Exp_Ch11 is\n    -------------------------------\n \n    procedure Expand_Exception_Handlers (HSS : Node_Id) is\n-      Handlrs       : constant List_Id := Exception_Handlers (HSS);\n-      Loc           : Source_Ptr;\n+      Handlrs       : constant List_Id    := Exception_Handlers (HSS);\n+      Loc           : constant Source_Ptr := Sloc (HSS);\n       Handler       : Node_Id;\n       Others_Choice : Boolean;\n       Obj_Decl      : Node_Id;\n+      Next_Handler  : Node_Id;\n+\n+      procedure Expand_Local_Exception_Handlers;\n+      --  This procedure handles the expansion of exception handlers for the\n+      --  optimization of local raise statements into goto statements.\n \n       procedure Prepend_Call_To_Handler\n         (Proc : RE_Id;\n          Args : List_Id := No_List);\n       --  Routine to prepend a call to the procedure referenced by Proc at\n       --  the start of the handler code for the current Handler.\n \n+      procedure Replace_Raise_By_Goto (Raise_S : Node_Id; Goto_L1 : Node_Id);\n+      --  Raise_S is a raise statement (possibly expanded, and possibly of the\n+      --  form of a Raise_xxx_Error node with a condition. This procedure is\n+      --  called to replace the raise action with the (already analyzed) goto\n+      --  statement passed as Goto_L1. This procedure also takes care of the\n+      --  requirement of inserting a Local_Raise call where possible.\n+\n+      -------------------------------------\n+      -- Expand_Local_Exception_Handlers --\n+      -------------------------------------\n+\n+      --  There are two cases for this transformation. First the case of\n+      --  explicit raise statements. For this case, the transformation we do\n+      --  looks like this. Right now we have for example (where L1,L2 are\n+      --  exception labels)\n+\n+      --  begin\n+      --     ...\n+      --     raise_exception (excep1'identity);  -- was raise excep1\n+      --     ...\n+      --     raise_exception (excep2'identity);  -- was raise excep2\n+      --     ...\n+      --  exception\n+      --     when excep1 =>\n+      --        estmts1\n+      --     when excep2 =>\n+      --        estmts2\n+      --  end;\n+\n+      --  This gets transformed into:\n+\n+      --  begin\n+      --     L1 : label;\n+      --     L2 : label;\n+      --     L3 : label;\n+\n+      --     begin\n+      --        ...\n+      --        local_raise (excep1'Identity);   -- was raise excep1\n+      --        goto L1;\n+      --        ...\n+      --        local_raise (excep2'Identity);   -- was raise excep2\n+      --        goto L2;\n+      --        ...\n+      --     exception\n+      --        when excep1 =>\n+      --           goto L1;\n+      --        when excep2 =>\n+      --           goto L2;\n+      --     end;\n+\n+      --     goto L3;   -- skip handler when exception not raised\n+\n+      --     <<L1>>     -- target label for local exception\n+      --        estmts1\n+      --        goto L3;\n+\n+      --     <<L2>>\n+      --        estmts2\n+      --        goto L3;\n+      --     <<L3>>\n+      --  end;\n+\n+      --  Note: the reason we wrap the original statement sequence in an\n+      --  inner block is that there may be raise statements within the\n+      --  sequence of statements in the handlers, and we must ensure that\n+      --  these are properly handled, and in particular, such raise statements\n+      --  must not reenter the same exception handlers.\n+\n+      --  If the restriction No_Exception_Propagation is in effect, then we\n+      --  can omit the exception handlers, and we do not need the inner block.\n+\n+      --  begin\n+      --     L1 : label;\n+      --     L2 : label;\n+      --     L3 : label;\n+\n+      --     ...\n+      --     local_raise (excep1'Identity);   -- was raise excep1\n+      --     goto L1;\n+      --     ...\n+      --     local_raise (excep2'Identity);   -- was raise excep2\n+      --     goto L2;\n+      --     ...\n+\n+      --     goto L3;   -- skip handler when exception not raised\n+\n+      --     <<L1>>     -- target label for local exception\n+      --        estmts1\n+      --        goto L3;\n+\n+      --     <<L2>>\n+      --        estmts2\n+      --        goto L3;\n+      --     <<L3>>\n+      --  end;\n+\n+      --  The second case is for exceptions generated by the back end in one\n+      --  of three situations:\n+\n+      --    1. Front end generates N_Raise_xxx_Error node\n+      --    2. Front end sets Do_xxx_Check flag in subexpression node\n+      --    3. Back end detects a situation where an exception is appropriate\n+\n+      --  In all these cases, the current processing in gigi is to generate a\n+      --  call to the appropriate Rcheck_xx routine (where xx encodes both the\n+      --  exception message and the exception to be raised, Constraint_Error,\n+      --  Program_Error, or Storage_Error.\n+\n+      --  We could handle some subcases of 1 using the same front end expansion\n+      --  into gotos, but even for case 1, we can't handle all cases, since\n+      --  generating gotos in the middle of expressions is not possible (it's\n+      --  possible at the gigi/gcc level, but not at the level of the GNAT\n+      --  tree).\n+\n+      --  In any case, it seems easier to have a scheme which handles all three\n+      --  cases in a uniform manner. So here is how we proceed in this case.\n+\n+      --  This procedure detects all handlers for these three exceptions,\n+      --  Constraint_Error, Program_Error and Storage_Error (including WHEN\n+      --  OTHERS handlers that cover one or more of these cases).\n+\n+      --  If the handler meets the requirements for being the target of a local\n+      --  raise, then the front end does the expansion described previously,\n+      --  creating a label to be used as a goto target to raise the exception.\n+      --  However, no attempt is made in the front end to convert any related\n+      --  raise statements into gotos, e.g. all Raise_xxx_Error nodes are left\n+      --  unchanged and passed to the back end.\n+\n+      --  Instead, the front end generates two nodes\n+\n+      --     N_Push_Constraint_Error_Label\n+      --     N_Push_Program_Error_Label\n+      --     N_Push_Storage_Error_Label\n+\n+      --       The Push node is generated at the start of the statements\n+      --       covered by the handler, and has as a parameter the label to be\n+      --       used as the raise target.\n+\n+      --     N_Pop_Constraint_Error_Label\n+      --     N_Pop_Program_Error_Label\n+      --     N_Pop_Storage_Error_Label\n+\n+      --       The Pop node is generated at the end of the covered statements\n+      --       and undoes the effect of the preceding corresponding Push node.\n+\n+      --  In the case where the handler does NOT meet the requirements, the\n+      --  front end will still generate the Push and Pop nodes, but the label\n+      --  field in the Push node will be empty signifying that for this region\n+      --  of code, no optimization is possible.\n+\n+      --  The back end must maintain three stacks, one for each exception case,\n+      --  the Push node pushes an entry onto the corresponding stack, and pop\n+      --  node pops off the entry. Then instead of calling Rcheck_nn, if the\n+      --  corresponding top stack entry has an non-empty label, a goto is\n+      --  generated instead of the call. This goto should be preceded by a\n+      --  call to Local_Raise as described above.\n+\n+      --  An example of this transformation is as follows, given:\n+\n+      --  declare\n+      --    A : Integer range 1 .. 10;\n+      --  begin\n+      --    A := B + C;\n+      --  exception\n+      --    when Constraint_Error =>\n+      --       estmts\n+      --  end;\n+\n+      --  gets transformed to:\n+\n+      --  declare\n+      --    A : Integer range 1 .. 10;\n+\n+      --  begin\n+      --     L1 : label;\n+      --     L2 : label;\n+\n+      --     begin\n+      --       %push_constraint_error_label (L1)\n+      --       R1b : constant long_long_integer := long_long_integer?(b) +\n+      --         long_long_integer?(c);\n+      --       [constraint_error when\n+      --         not (R1b in -16#8000_0000# .. 16#7FFF_FFFF#)\n+      --         \"overflow check failed\"]\n+      --        a := integer?(R1b);\n+      --        %pop_constraint_error_Label\n+\n+      --     exception\n+      --        ...\n+      --        when constraint_error =>\n+      --           goto L1;\n+      --     end;\n+\n+      --     goto L2;       -- skip handler when exception not raised\n+      --     <<L1>>         -- target label for local exception\n+      --     estmts\n+      --     <<L2>>\n+      --  end;\n+\n+      CE_Locally_Handled : Boolean := False;\n+      SE_Locally_Handled : Boolean := False;\n+      PE_Locally_Handled : Boolean := False;\n+      --  These three flags indicate whether a handler for the corresponding\n+      --  exception (CE=Constraint_Error, SE=Storage_Error, PE=Program_Error)\n+      --  is present. If so the switch is set to True, the Exception_Label\n+      --  field of the corresponding handler is set, and appropriate Push\n+      --  and Pop nodes are inserted into the code.\n+\n+      Local_Expansion_Required : Boolean := False;\n+      --  Set True if we have at least one handler requiring local raise\n+      --  expansion as described above.\n+\n+      procedure Expand_Local_Exception_Handlers is\n+\n+         procedure Add_Exception_Label (H : Node_Id);\n+         --  H is an exception handler. First check for an Exception_Label\n+         --  already allocated for H. If not, allocate one, set the field in\n+         --  the handler node, add the label declaration, and set the flag\n+         --  Local_Expansion_Required. Note: if Local_Handlers_Not_OK is set\n+         --  the call has no effect and Exception_Label is left empty.\n+\n+         procedure Add_Label_Declaration (L : Entity_Id);\n+         --  Add an implicit declaration of the given label to the declaration\n+         --  list in the parent of the current sequence of handled statements.\n+\n+         generic\n+            Exc_Locally_Handled : in out Boolean;\n+            --  Flag indicating whether a local handler for this exception\n+            --  has already been generated.\n+\n+            with function Make_Push_Label (Loc : Source_Ptr) return Node_Id;\n+            --  Function to create a Push_xxx_Label node\n+\n+            with function Make_Pop_Label (Loc : Source_Ptr) return Node_Id;\n+            --  Function to create a Pop_xxx_Label node\n+\n+         procedure Generate_Push_Pop (H : Node_Id);\n+         --  Common code for Generate_Push_Pop_xxx below, used to generate an\n+         --  exception label and Push/Pop nodes for Constraint_Error,\n+         --  Program_Error, or Storage_Error.\n+\n+         -------------------------\n+         -- Add_Exception_Label --\n+         -------------------------\n+\n+         procedure Add_Exception_Label (H : Node_Id) is\n+         begin\n+            if No (Exception_Label (H))\n+              and then not Local_Raise_Not_OK (H)\n+            then\n+               Local_Expansion_Required := True;\n+\n+               declare\n+                  L : constant Entity_Id :=\n+                        Make_Defining_Identifier (Sloc (H),\n+                          Chars => New_Internal_Name ('L'));\n+               begin\n+                  Set_Exception_Label (H, L);\n+                  Add_Label_Declaration (L);\n+               end;\n+            end if;\n+         end Add_Exception_Label;\n+\n+         ---------------------------\n+         -- Add_Label_Declaration --\n+         ---------------------------\n+\n+         procedure Add_Label_Declaration (L : Entity_Id) is\n+            P : constant Node_Id := Parent (HSS);\n+\n+            Decl_L : constant Node_Id :=\n+                       Make_Implicit_Label_Declaration (Loc,\n+                         Defining_Identifier => L);\n+\n+         begin\n+            if Declarations (P) = No_List then\n+               Set_Declarations (P, Empty_List);\n+            end if;\n+\n+            Append (Decl_L, Declarations (P));\n+            Analyze (Decl_L);\n+         end Add_Label_Declaration;\n+\n+         -----------------------\n+         -- Generate_Push_Pop --\n+         -----------------------\n+\n+         procedure Generate_Push_Pop (H : Node_Id) is\n+         begin\n+            if Exc_Locally_Handled then\n+               return;\n+            else\n+               Exc_Locally_Handled := True;\n+            end if;\n+\n+            Add_Exception_Label (H);\n+\n+            declare\n+               F : constant Node_Id := First (Statements (HSS));\n+               L : constant Node_Id := Last  (Statements (HSS));\n+\n+               Push : constant Node_Id := Make_Push_Label (Sloc (F));\n+               Pop  : constant Node_Id := Make_Pop_Label  (Sloc (L));\n+\n+            begin\n+               Set_Exception_Label (Push, Exception_Label (H));\n+\n+               Insert_Before (F, Push);\n+               Set_Analyzed (Push);\n+\n+               Insert_After (L, Pop);\n+               Set_Analyzed (Pop);\n+            end;\n+         end Generate_Push_Pop;\n+\n+         --  Local declarations\n+\n+         Loc    : constant Source_Ptr := Sloc (HSS);\n+         Stmts  : List_Id;\n+         Choice : Node_Id;\n+\n+         procedure Generate_Push_Pop_For_Constraint_Error is\n+           new Generate_Push_Pop\n+             (Exc_Locally_Handled => CE_Locally_Handled,\n+              Make_Push_Label     => Make_Push_Constraint_Error_Label,\n+              Make_Pop_Label      => Make_Pop_Constraint_Error_Label);\n+         --  If no Push/Pop has been generated for CE yet, then set the flag\n+         --  CE_Locally_Handled, allocate an Exception_Label for handler H (if\n+         --  not already done), and generate Push/Pop nodes for the exception\n+         --  label at the start and end of the statements of HSS.\n+\n+         procedure Generate_Push_Pop_For_Program_Error is\n+           new Generate_Push_Pop\n+             (Exc_Locally_Handled => PE_Locally_Handled,\n+              Make_Push_Label     => Make_Push_Program_Error_Label,\n+              Make_Pop_Label      => Make_Pop_Program_Error_Label);\n+         --  If no Push/Pop has been generated for PE yet, then set the flag\n+         --  PE_Locally_Handled, allocate an Exception_Label for handler H (if\n+         --  not already done), and generate Push/Pop nodes for the exception\n+         --  label at the start and end of the statements of HSS.\n+\n+         procedure Generate_Push_Pop_For_Storage_Error is\n+           new Generate_Push_Pop\n+             (Exc_Locally_Handled => SE_Locally_Handled,\n+              Make_Push_Label     => Make_Push_Storage_Error_Label,\n+              Make_Pop_Label      => Make_Pop_Storage_Error_Label);\n+         --  If no Push/Pop has been generated for SE yet, then set the flag\n+         --  SE_Locally_Handled, allocate an Exception_Label for handler H (if\n+         --  not already done), and generate Push/Pop nodes for the exception\n+         --  label at the start and end of the statements of HSS.\n+\n+      begin\n+         --  See if we have any potential local raises to expand\n+\n+         Handler := First_Non_Pragma (Handlrs);\n+         while Present (Handler) loop\n+\n+            --  Note, we do not test Local_Raise_Not_OK here, because in the\n+            --  case of Push/Pop generation we want to generate push with a\n+            --  null label. The Add_Exception_Label routine has no effect if\n+            --  Local_Raise_Not_OK is set, so this works as required.\n+\n+            if Present (Local_Raise_Statements (Handler)) then\n+               Add_Exception_Label (Handler);\n+            end if;\n+\n+            --  If we are doing local raise to goto optimization (restriction\n+            --  No_Exception_Propagation set or debug flag .g set), then check\n+            --  to see if handler handles CE,PE,SE and if so generate the\n+            --  appropriate push/pop sequences for the back end\n+\n+            if Debug_Flag_Dot_G\n+              or else Restriction_Active (No_Exception_Propagation)\n+            then\n+               Choice := First (Exception_Choices (Handler));\n+               while Present (Choice) loop\n+                  if Nkind (Choice) = N_Others_Choice then\n+                     Generate_Push_Pop_For_Constraint_Error (Handler);\n+                     Generate_Push_Pop_For_Program_Error    (Handler);\n+                     Generate_Push_Pop_For_Storage_Error    (Handler);\n+\n+                  elsif Is_Entity_Name (Choice) then\n+                     if Entity (Choice) = Standard_Constraint_Error then\n+                        Generate_Push_Pop_For_Constraint_Error (Handler);\n+                     elsif Entity (Choice) = Standard_Program_Error then\n+                        Generate_Push_Pop_For_Program_Error (Handler);\n+                     elsif Entity (Choice) = Standard_Storage_Error then\n+                        Generate_Push_Pop_For_Storage_Error (Handler);\n+                     end if;\n+                  end if;\n+\n+                  Next (Choice);\n+               end loop;\n+            end if;\n+\n+            Next_Non_Pragma (Handler);\n+         end loop;\n+\n+         --  Nothing to do if no handlers requiring the goto transformation\n+\n+         if not (Local_Expansion_Required) then\n+            return;\n+         end if;\n+\n+         --  Prepare to do the transformation\n+\n+         declare\n+            L3_Dent : constant Entity_Id :=\n+                        Make_Defining_Identifier (Loc,\n+                          Chars => New_Internal_Name ('L'));\n+\n+            Labl_L3 : constant Node_Id :=\n+                        Make_Label (Loc,\n+                          Identifier => New_Occurrence_Of (L3_Dent, Loc));\n+\n+            Old_HSS : Node_Id;\n+            Blk_Stm : Node_Id;\n+            Relmt   : Elmt_Id;\n+\n+         begin\n+            Add_Label_Declaration (L3_Dent);\n+\n+            --  If the No_Exception_Propagation restriction is not active,\n+            --  then we must wrap the existing statements and exception\n+            --  handlers in an inner block.\n+\n+            if not Restriction_Active (No_Exception_Propagation) then\n+               Old_HSS := Relocate_Node (HSS);\n+\n+               --  Construct and analyze the block with a dummy HSS inside it\n+               --  for now (if we do the analyze call with the real HSS in\n+               --  place we have nasty recursion problems).\n+\n+               Blk_Stm :=\n+                 Make_Block_Statement (Loc,\n+                   Handled_Statement_Sequence =>\n+                     Make_Handled_Sequence_Of_Statements (Loc,\n+                       Statements => Empty_List));\n+\n+               Rewrite (HSS,\n+                 Make_Handled_Sequence_Of_Statements (Loc,\n+                   Statements => New_List (Blk_Stm)));\n+               Analyze (HSS);\n+\n+               --  Now we can set the real statement sequence in place\n+\n+               Set_Handled_Statement_Sequence (Blk_Stm, Old_HSS);\n+            end if;\n+\n+            --  Now loop through the exception handlers to deal with those that\n+            --  are targets of local raise statements.\n+\n+            Handler := First_Non_Pragma (Handlrs);\n+            while Present (Handler) loop\n+               if Present (Exception_Label (Handler)) then\n+\n+                  --  This handler needs the goto expansion\n+\n+                  declare\n+                     Loc : constant Source_Ptr := Sloc (Handler);\n+\n+                     L1_Dent : constant Entity_Id := Exception_Label (Handler);\n+\n+                     Labl_L1 : constant Node_Id :=\n+                                 Make_Label (Loc,\n+                                   Identifier =>\n+                                     New_Occurrence_Of (L1_Dent, Loc));\n+\n+                     Name_L1 : constant Node_Id :=\n+                                 New_Occurrence_Of (L1_Dent, Loc);\n+\n+                     Goto_L1 : constant Node_Id :=\n+                                 Make_Goto_Statement (Loc,\n+                                   Name => Name_L1);\n+\n+                     Name_L3 : constant Node_Id :=\n+                                 New_Occurrence_Of (L3_Dent, Loc);\n+\n+                     Goto_L3 : constant Node_Id :=\n+                                 Make_Goto_Statement (Loc,\n+                                   Name => Name_L3);\n+\n+                     H_Stmts : constant List_Id := Statements (Handler);\n+\n+                  begin\n+                     --  Replace handler by a goto L1. We can mark this as\n+                     --  analyzed since it is fully formed, and we don't\n+                     --  want it going through any further checks.\n+\n+                     Set_Statements (Handler, New_List (Goto_L1));\n+                     Set_Analyzed (Goto_L1);\n+                     Set_Etype (Name_L1, Standard_Void_Type);\n+\n+                     --  Now replace all the raise statements by goto L1\n+\n+                     if Present (Local_Raise_Statements (Handler)) then\n+                        Relmt := First_Elmt (Local_Raise_Statements (Handler));\n+                        while Present (Relmt) loop\n+                           declare\n+                              Raise_S : constant Node_Id := Node (Relmt);\n+\n+                              Name_L1 : constant Node_Id :=\n+                                          New_Occurrence_Of (L1_Dent, Loc);\n+\n+                              Goto_L1 : constant Node_Id :=\n+                                          Make_Goto_Statement (Loc,\n+                                            Name => Name_L1);\n+\n+                           begin\n+                              --  Replace raise by goto L1\n+\n+                              Set_Analyzed (Goto_L1);\n+                              Set_Etype (Name_L1, Standard_Void_Type);\n+                              Replace_Raise_By_Goto (Raise_S, Goto_L1);\n+                           end;\n+\n+                           Next_Elmt (Relmt);\n+                        end loop;\n+                     end if;\n+\n+                     --  Add goto L3 at end of statement list in block. The\n+                     --  first time, this is what skips over the exception\n+                     --  handlers in the normal case. Subsequent times, it\n+                     --  terminates the execution of the handler code, and\n+                     --  skips subsequent handlers.\n+\n+                     Stmts := Statements (HSS);\n+\n+                     Insert_After (Last (Stmts), Goto_L3);\n+                     Set_Analyzed (Goto_L3);\n+                     Set_Etype (Name_L3, Standard_Void_Type);\n+\n+                     --  Now we drop the label that marks the handler start,\n+                     --  followed by the statements of the handler.\n+\n+                     Set_Etype (Identifier (Labl_L1), Standard_Void_Type);\n+\n+                     Insert_After_And_Analyze (Last (Stmts), Labl_L1);\n+                     Insert_List_After        (Last (Stmts), H_Stmts);\n+                  end;\n+\n+                  --  Here if we have local raise statements but the handler is\n+                  --  not suitable for processing with a local raise. In this\n+                  --  case we have to delete the Local_Raise call and also\n+                  --  generate possible diagnostics.\n+\n+               else\n+                  Relmt := First_Elmt (Local_Raise_Statements (Handler));\n+                  while Present (Relmt) loop\n+                     Warn_If_No_Propagation (Node (Relmt));\n+                     Remove (Prev (Node (Relmt)));\n+                     Next_Elmt (Relmt);\n+                  end loop;\n+               end if;\n+\n+               Next (Handler);\n+            end loop;\n+\n+            --  Only remaining step is to drop the L3 label and we are done\n+\n+            Set_Etype (Identifier (Labl_L3), Standard_Void_Type);\n+            Insert_After_And_Analyze (Last (Stmts), Labl_L3);\n+            return;\n+         end;\n+      end Expand_Local_Exception_Handlers;\n+\n       -----------------------------\n       -- Prepend_Call_To_Handler --\n       -----------------------------\n@@ -185,145 +778,254 @@ package body Exp_Ch11 is\n          end if;\n       end Prepend_Call_To_Handler;\n \n+      ---------------------------\n+      -- Replace_Raise_By_Goto --\n+      ---------------------------\n+\n+      procedure Replace_Raise_By_Goto (Raise_S : Node_Id; Goto_L1 : Node_Id) is\n+         Loc   : constant Source_Ptr := Sloc (Raise_S);\n+         Excep : Entity_Id;\n+         LR    : Node_Id;\n+         Cond  : Node_Id;\n+         Orig  : Node_Id;\n+\n+      begin\n+         --  If we have a null statement, it means that there is no replacement\n+         --  needed (typically this results from a suppressed check).\n+\n+         if Nkind (Raise_S) = N_Null_Statement then\n+            return;\n+\n+         --  Test for Raise_xxx_Error\n+\n+         elsif Nkind (Raise_S) = N_Raise_Constraint_Error then\n+            Excep := Standard_Constraint_Error;\n+            Cond  := Condition (Raise_S);\n+\n+         elsif Nkind (Raise_S) = N_Raise_Storage_Error then\n+            Excep := Standard_Storage_Error;\n+            Cond := Condition (Raise_S);\n+\n+         elsif Nkind (Raise_S) = N_Raise_Program_Error then\n+            Excep := Standard_Program_Error;\n+            Cond := Condition (Raise_S);\n+\n+            --  The only other possibility is a node that is or used to be\n+            --  a simple raise statement.\n+\n+         else\n+            Orig := Original_Node (Raise_S);\n+            pragma Assert (Nkind (Orig) = N_Raise_Statement\n+                             and then Present (Name (Orig))\n+                             and then No (Expression (Orig)));\n+            Excep := Entity (Name (Orig));\n+            Cond := Empty;\n+         end if;\n+\n+         --  Here Excep is the exception to raise, and Cond is the condition\n+         --  First prepare the call to Local_Raise (excep'Identity).\n+\n+         if RTE_Available (RE_Local_Raise) then\n+            LR :=\n+              Make_Procedure_Call_Statement (Loc,\n+                Name => New_Occurrence_Of (RTE (RE_Local_Raise), Loc),\n+                Parameter_Associations => New_List (\n+                  Make_Attribute_Reference (Loc,\n+                    Prefix         => New_Occurrence_Of (Excep, Loc),\n+                    Attribute_Name => Name_Identity)));\n+\n+            --  Use null statement if Local_Raise not available\n+\n+         else\n+            LR :=\n+              Make_Null_Statement (Loc);\n+         end if;\n+\n+         --  If there is no condition, we rewrite as\n+\n+         --    begin\n+         --       Local_Raise (excep'Identity);\n+         --       goto L1;\n+         --    end;\n+\n+         if No (Cond) then\n+            Rewrite (Raise_S,\n+              Make_Block_Statement (Loc,\n+                Handled_Statement_Sequence =>\n+                  Make_Handled_Sequence_Of_Statements (Loc,\n+                    Statements => New_List (LR, Goto_L1))));\n+\n+         --  If there is a condition, we rewrite as\n+\n+         --    if condition then\n+         --       Local_Raise (excep'Identity);\n+         --       goto L1;\n+         --    end if;\n+\n+         else\n+            Rewrite (Raise_S,\n+              Make_If_Statement (Loc,\n+                Condition       => Cond,\n+                Then_Statements => New_List (LR, Goto_L1)));\n+         end if;\n+\n+         Analyze (Raise_S);\n+      end Replace_Raise_By_Goto;\n+\n    --  Start of processing for Expand_Exception_Handlers\n \n    begin\n+      Expand_Local_Exception_Handlers;\n+\n       --  Loop through handlers\n \n       Handler := First_Non_Pragma (Handlrs);\n       Handler_Loop : while Present (Handler) loop\n-         Loc := Sloc (Handler);\n+         Next_Handler := Next_Non_Pragma (Handler);\n \n          --  Remove source handler if gnat debug flag N is set\n \n          if Debug_Flag_Dot_X and then Comes_From_Source (Handler) then\n-            declare\n-               H : constant Node_Id := Handler;\n-            begin\n-               Next_Non_Pragma (Handler);\n-               Remove (H);\n-               goto Continue_Handler_Loop;\n-            end;\n-         end if;\n-\n-         --  If an exception occurrence is present, then we must declare it\n-         --  and initialize it from the value stored in the TSD\n-\n-         --     declare\n-         --        name : Exception_Occurrence;\n-         --\n-         --     begin\n-         --        Save_Occurrence (name, Get_Current_Excep.all)\n-         --        ...\n-         --     end;\n+            Remove (Handler);\n \n-         if Present (Choice_Parameter (Handler)) then\n-            declare\n-               Cparm : constant Entity_Id  := Choice_Parameter (Handler);\n-               Clc   : constant Source_Ptr := Sloc (Cparm);\n-               Save  : Node_Id;\n+         --  Remove handler if no exception propagation, generating a warning\n+         --  if a source generated handler was not the target of a local raise.\n \n-            begin\n-               Save :=\n-                 Make_Procedure_Call_Statement (Loc,\n-                   Name =>\n-                     New_Occurrence_Of (RTE (RE_Save_Occurrence), Loc),\n-                   Parameter_Associations => New_List (\n-                     New_Occurrence_Of (Cparm, Clc),\n-                     Make_Explicit_Dereference (Loc,\n-                       Make_Function_Call (Loc,\n-                         Name => Make_Explicit_Dereference (Loc,\n-                           New_Occurrence_Of\n-                             (RTE (RE_Get_Current_Excep), Loc))))));\n-\n-               Mark_Rewrite_Insertion (Save);\n-               Prepend (Save, Statements (Handler));\n-\n-               Obj_Decl :=\n-                 Make_Object_Declaration (Clc,\n-                   Defining_Identifier => Cparm,\n-                   Object_Definition   =>\n-                     New_Occurrence_Of\n-                       (RTE (RE_Exception_Occurrence), Clc));\n-               Set_No_Initialization (Obj_Decl, True);\n-\n-               Rewrite (Handler,\n-                 Make_Exception_Handler (Loc,\n-                   Exception_Choices => Exception_Choices (Handler),\n-\n-                   Statements => New_List (\n-                     Make_Block_Statement (Loc,\n-                       Declarations => New_List (Obj_Decl),\n-                       Handled_Statement_Sequence =>\n-                         Make_Handled_Sequence_Of_Statements (Loc,\n-                           Statements => Statements (Handler))))));\n-\n-               Analyze_List (Statements (Handler), Suppress => All_Checks);\n-            end;\n-         end if;\n+         elsif Restriction_Active (No_Exception_Propagation) then\n+            if No (Local_Raise_Statements (Handler))\n+              and then Comes_From_Source (Handler)\n+              and then Warn_On_Non_Local_Exception\n+            then\n+               Error_Msg_N\n+                 (\"?pragma Restrictions (No_Exception_Propagation) in effect\",\n+                  Handler);\n+               Error_Msg_N\n+                 (\"\\?this handler can never be entered, and has been removed\",\n+                  Handler);\n+            end if;\n \n-         --  The processing at this point is rather different for the\n-         --  JVM case, so we completely separate the processing.\n+            Remove (Handler);\n \n-         --  For the JVM case, we unconditionally call Update_Exception,\n-         --  passing a call to the intrinsic function Current_Target_Exception\n-         --  (see JVM version of Ada.Exceptions in 4jexcept.adb for details).\n+         --  Exception handler is active and retained and must be processed\n \n-         if Hostparm.Java_VM then\n-            declare\n-               Arg : constant Node_Id :=\n-                       Make_Function_Call (Loc,\n-                         Name => New_Occurrence_Of\n-                                   (RTE (RE_Current_Target_Exception), Loc));\n-            begin\n-               Prepend_Call_To_Handler (RE_Update_Exception, New_List (Arg));\n-            end;\n+         else\n+            --  If an exception occurrence is present, then we must declare it\n+            --  and initialize it from the value stored in the TSD\n \n-         --  For the normal case, we have to worry about the state of abort\n-         --  deferral. Generally, we defer abort during runtime handling of\n-         --  exceptions. When control is passed to the handler, then in the\n-         --  normal case we undefer aborts. In any case this entire handling\n-         --  is relevant only if aborts are allowed!\n+            --     declare\n+            --        name : Exception_Occurrence;\n+            --     begin\n+            --        Save_Occurrence (name, Get_Current_Excep.all)\n+            --        ...\n+            --     end;\n \n-         elsif Abort_Allowed then\n+            if Present (Choice_Parameter (Handler)) then\n+               declare\n+                  Cparm : constant Entity_Id  := Choice_Parameter (Handler);\n+                  Clc   : constant Source_Ptr := Sloc (Cparm);\n+                  Save  : Node_Id;\n \n-            --  There are some special cases in which we do not do the\n-            --  undefer. In particular a finalization (AT END) handler\n-            --  wants to operate with aborts still deferred.\n+               begin\n+                  Save :=\n+                    Make_Procedure_Call_Statement (Loc,\n+                      Name =>\n+                        New_Occurrence_Of (RTE (RE_Save_Occurrence), Loc),\n+                      Parameter_Associations => New_List (\n+                        New_Occurrence_Of (Cparm, Clc),\n+                        Make_Explicit_Dereference (Loc,\n+                          Make_Function_Call (Loc,\n+                            Name => Make_Explicit_Dereference (Loc,\n+                              New_Occurrence_Of\n+                                (RTE (RE_Get_Current_Excep), Loc))))));\n+\n+                  Mark_Rewrite_Insertion (Save);\n+                  Prepend (Save, Statements (Handler));\n+\n+                  Obj_Decl :=\n+                    Make_Object_Declaration\n+                      (Clc,\n+                       Defining_Identifier => Cparm,\n+                       Object_Definition   =>\n+                         New_Occurrence_Of\n+                           (RTE (RE_Exception_Occurrence), Clc));\n+                  Set_No_Initialization (Obj_Decl, True);\n+\n+                  Rewrite (Handler,\n+                    Make_Implicit_Exception_Handler (Loc,\n+                      Exception_Choices => Exception_Choices (Handler),\n+\n+                      Statements => New_List (\n+                        Make_Block_Statement (Loc,\n+                          Declarations => New_List (Obj_Decl),\n+                          Handled_Statement_Sequence =>\n+                            Make_Handled_Sequence_Of_Statements (Loc,\n+                              Statements => Statements (Handler))))));\n+\n+                  Analyze_List (Statements (Handler), Suppress => All_Checks);\n+               end;\n+            end if;\n \n-            --  We also suppress the call if this is the special handler\n-            --  for Abort_Signal, since if we are aborting, we want to keep\n-            --  aborts deferred (one abort is enough thank you very much :-)\n+            --  The processing at this point is rather different for the JVM\n+            --  case, so we completely separate the processing.\n \n-            --  If abort really needs to be deferred the expander must add\n-            --  this call explicitly, see Exp_Ch9.Expand_N_Asynchronous_Select.\n+            --  For the JVM case, we unconditionally call Update_Exception,\n+            --  passing a call to the intrinsic Current_Target_Exception (see\n+            --  JVM version of Ada.Exceptions in 4jexcept.adb for details).\n \n-            Others_Choice :=\n-              Nkind (First (Exception_Choices (Handler))) = N_Others_Choice;\n+            if Hostparm.Java_VM then\n+               declare\n+                  Arg : constant Node_Id :=\n+                          Make_Function_Call (Loc,\n+                            Name =>\n+                              New_Occurrence_Of\n+                                (RTE (RE_Current_Target_Exception), Loc));\n+               begin\n+                  Prepend_Call_To_Handler\n+                    (RE_Update_Exception, New_List (Arg));\n+               end;\n \n-            if (Others_Choice\n-                 or else Entity (First (Exception_Choices (Handler))) /=\n-                                                      Stand.Abort_Signal)\n-              and then not\n-                (Others_Choice\n-                   and then All_Others (First (Exception_Choices (Handler))))\n-              and then Abort_Allowed\n-            then\n-               Prepend_Call_To_Handler (RE_Abort_Undefer);\n+               --  For the normal case, we have to worry about the state of\n+               --  abort deferral. Generally, we defer abort during runtime\n+               --  handling of exceptions. When control is passed to the\n+               --  handler, then in the normal case we undefer aborts. In any\n+               --  case this entire handling is relevant only if aborts are\n+               --  allowed!\n+\n+            elsif Abort_Allowed then\n+\n+               --  There are some special cases in which we do not do the\n+               --  undefer. In particular a finalization (AT END) handler\n+               --  wants to operate with aborts still deferred.\n+\n+               --  We also suppress the call if this is the special handler\n+               --  for Abort_Signal, since if we are aborting, we want to keep\n+               --  aborts deferred (one abort is enough thank you very much :-)\n+\n+               --  If abort really needs to be deferred the expander must add\n+               --  this call explicitly, see Expand_N_Asynchronous_Select.\n+\n+               Others_Choice :=\n+                 Nkind (First (Exception_Choices (Handler))) = N_Others_Choice;\n+\n+               if (Others_Choice\n+                   or else Entity (First (Exception_Choices (Handler))) /=\n+                     Stand.Abort_Signal)\n+                 and then not\n+                   (Others_Choice\n+                    and then All_Others (First (Exception_Choices (Handler))))\n+                 and then Abort_Allowed\n+               then\n+                  Prepend_Call_To_Handler (RE_Abort_Undefer);\n+               end if;\n             end if;\n          end if;\n \n-         Next_Non_Pragma (Handler);\n-\n-      <<Continue_Handler_Loop>>\n-         null;\n+         Handler := Next_Handler;\n       end loop Handler_Loop;\n \n-      --  If all handlers got removed by gnatdN, then remove the list\n+      --  If all handlers got removed, then remove the list\n \n-      if Debug_Flag_Dot_X\n-        and then Is_Empty_List (Exception_Handlers (HSS))\n-      then\n+      if Is_Empty_List (Exception_Handlers (HSS)) then\n          Set_Exception_Handlers (HSS, No_List);\n       end if;\n    end Expand_Exception_Handlers;\n@@ -492,36 +1194,33 @@ package body Exp_Ch11 is\n       else\n          Set_First_Real_Statement (N, First (Statements (N)));\n       end if;\n-\n    end Expand_N_Handled_Sequence_Of_Statements;\n \n    -------------------------------------\n    -- Expand_N_Raise_Constraint_Error --\n    -------------------------------------\n \n-   --  The only processing required is to adjust the condition to deal\n-   --  with the C/Fortran boolean case. This may well not be necessary,\n-   --  as all such conditions are generated by the expander and probably\n-   --  are all standard boolean, but who knows what strange optimization\n-   --  in future may require this adjustment!\n-\n    procedure Expand_N_Raise_Constraint_Error (N : Node_Id) is\n    begin\n+      --  We adjust the condition to deal with the C/Fortran boolean case. This\n+      --  may well not be necessary, as all such conditions are generated by\n+      --  the expander and probably are all standard boolean, but who knows\n+      --  what strange optimization in future may require this adjustment!\n+\n       Adjust_Condition (Condition (N));\n    end Expand_N_Raise_Constraint_Error;\n \n    ----------------------------------\n    -- Expand_N_Raise_Program_Error --\n    ----------------------------------\n \n-   --  The only processing required is to adjust the condition to deal\n-   --  with the C/Fortran boolean case. This may well not be necessary,\n-   --  as all such conditions are generated by the expander and probably\n-   --  are all standard boolean, but who knows what strange optimization\n-   --  in future may require this adjustment!\n-\n    procedure Expand_N_Raise_Program_Error (N : Node_Id) is\n    begin\n+      --  We adjust the condition to deal with the C/Fortran boolean case. This\n+      --  may well not be necessary, as all such conditions are generated by\n+      --  the expander and probably are all standard boolean, but who knows\n+      --  what strange optimization in future may require this adjustment!\n+\n       Adjust_Condition (Condition (N));\n    end Expand_N_Raise_Program_Error;\n \n@@ -534,8 +1233,39 @@ package body Exp_Ch11 is\n       Ehand : Node_Id;\n       E     : Entity_Id;\n       Str   : String_Id;\n+      H     : Node_Id;\n \n    begin\n+      --  Debug_Flag_Dot_G := True;\n+\n+      --  Processing for locally handled exception (exclude reraise case)\n+\n+      if Present (Name (N)) and then Nkind (Name (N)) = N_Identifier then\n+         if Debug_Flag_Dot_G\n+           or else Restriction_Active (No_Exception_Propagation)\n+         then\n+            --  If we have a local handler, then note that this is potentially\n+            --  able to be transformed into a goto statement.\n+\n+            H := Find_Local_Handler (Entity (Name (N)), N);\n+\n+            if Present (H) then\n+               if Local_Raise_Statements (H) = No_Elist then\n+                  Set_Local_Raise_Statements (H, New_Elmt_List);\n+               end if;\n+\n+               --  Append the new entry if it is not there already. Sometimes\n+               --  we have situations where due to reexpansion, the same node\n+               --  is analyzed twice and would otherwise be added twice.\n+\n+               Append_Unique_Elmt (N, Local_Raise_Statements (H));\n+            end if;\n+\n+         else\n+            Warn_If_No_Propagation (N);\n+         end if;\n+      end if;\n+\n       --  If a string expression is present, then the raise statement is\n       --  converted to a call:\n \n@@ -561,7 +1291,7 @@ package body Exp_Ch11 is\n \n       --  There is no expansion needed for statement \"raise <exception>;\" when\n       --  compiling for the JVM since the JVM has a built-in exception\n-      --  mechanism. However we need the keep the expansion for \"raise;\"\n+      --  mechanism. However we need to keep the expansion for \"raise;\"\n       --  statements. See 4jexcept.ads for details.\n \n       if Present (Name (N)) and then Hostparm.Java_VM then\n@@ -769,14 +1499,13 @@ package body Exp_Ch11 is\n    -- Expand_N_Raise_Storage_Error --\n    ----------------------------------\n \n-   --  The only processing required is to adjust the condition to deal\n-   --  with the C/Fortran boolean case. This may well not be necessary,\n-   --  as all such conditions are generated by the expander and probably\n-   --  are all standard boolean, but who knows what strange optimization\n-   --  in future may require this adjustment!\n-\n    procedure Expand_N_Raise_Storage_Error (N : Node_Id) is\n    begin\n+      --  We adjust the condition to deal with the C/Fortran boolean case. This\n+      --  may well not be necessary, as all such conditions are generated by\n+      --  the expander and probably are all standard boolean, but who knows\n+      --  what strange optimization in future may require this adjustment!\n+\n       Adjust_Condition (Condition (N));\n    end Expand_N_Raise_Storage_Error;\n \n@@ -801,6 +1530,149 @@ package body Exp_Ch11 is\n       Analyze_And_Resolve (N, RTE (RE_Code_Loc));\n    end Expand_N_Subprogram_Info;\n \n+   ------------------------\n+   -- Find_Local_Handler --\n+   ------------------------\n+\n+   function Find_Local_Handler\n+     (Ename : Entity_Id;\n+      Nod   : Node_Id) return Node_Id\n+   is\n+      N : Node_Id;\n+      P : Node_Id;\n+      H : Node_Id;\n+      C : Node_Id;\n+\n+      ERaise  : Entity_Id;\n+      EHandle : Entity_Id;\n+      --  The entity Id's for the exception we are raising and handling, using\n+      --  the renamed exception if a Renamed_Entity is present.\n+\n+   begin\n+      --  Get the exception we are raising, allowing for renaming\n+\n+      ERaise := Ename;\n+      while Present (Renamed_Entity (ERaise)) loop\n+         ERaise := Renamed_Entity (ERaise);\n+      end loop;\n+\n+      --  Loop to search up the tree\n+\n+      N := Nod;\n+      loop\n+         P := Parent (N);\n+\n+         --  If we get to the top of the tree, or to a subprogram, task, entry,\n+         --  or protected body without having found a matching handler, then\n+         --  there is no local handler.\n+\n+         if No (P)\n+           or else Nkind (P) = N_Subprogram_Body\n+           or else Nkind (P) = N_Task_Body\n+           or else Nkind (P) = N_Protected_Body\n+           or else Nkind (P) = N_Entry_Body\n+         then\n+            return Empty;\n+\n+            --  Test for handled sequence of statements, where we are in the\n+            --  statement section (the exception handlers of a handled sequence\n+            --  of statements do not cover themselves!)\n+\n+         elsif Nkind (P) = N_Handled_Sequence_Of_Statements\n+           and then Is_List_Member (N)\n+           and then List_Containing (N) = Statements (P)\n+         then\n+            --  If we have exception handlers, look at them\n+\n+            if Present (Exception_Handlers (P)) then\n+\n+               --  Loop through exception handlers\n+\n+               H := First (Exception_Handlers (P));\n+               while Present (H) loop\n+\n+                  --  Loop through choices in one handler\n+\n+                  C := First (Exception_Choices (H));\n+                  while Present (C) loop\n+\n+                     --  Deal with others case\n+\n+                     if Nkind (C) = N_Others_Choice then\n+\n+                        --  Matching others handler, but we need to ensure\n+                        --  there is no choice parameter. If there is, then we\n+                        --  don't have a local handler after all (since we do\n+                        --  not allow choice parameters for local handlers).\n+\n+                        if No (Choice_Parameter (H)) then\n+                           return H;\n+                        else\n+                           return Empty;\n+                        end if;\n+\n+                     --  If not others must be entity name\n+\n+                     elsif Nkind (C) /= N_Others_Choice then\n+                        pragma Assert (Is_Entity_Name (C));\n+                        pragma Assert (Present (Entity (C)));\n+\n+                        --  Get exception being handled, dealing with renaming\n+\n+                        EHandle := Entity (C);\n+                        while Present (Renamed_Entity (EHandle)) loop\n+                           EHandle := Renamed_Entity (EHandle);\n+                        end loop;\n+\n+                        --  If match, then check choice parameter\n+\n+                        if ERaise = EHandle then\n+                           if No (Choice_Parameter (H)) then\n+                              return H;\n+                           else\n+                              return Empty;\n+                           end if;\n+                        end if;\n+                     end if;\n+\n+                     Next (C);\n+                  end loop;\n+\n+                  Next (H);\n+               end loop;\n+            end if;\n+         end if;\n+\n+         N := P;\n+      end loop;\n+   end Find_Local_Handler;\n+\n+   ---------------------------------\n+   -- Get_Local_Raise_Call_Entity --\n+   ---------------------------------\n+\n+   function Get_Local_Raise_Call_Entity return Entity_Id is\n+   begin\n+      if RTE_Available (RE_Local_Raise) then\n+         return RTE (RE_Local_Raise);\n+      else\n+         return Empty;\n+      end if;\n+   end Get_Local_Raise_Call_Entity;\n+\n+   -----------------------------\n+   -- Get_RT_Exception_Entity --\n+   -----------------------------\n+\n+   function Get_RT_Exception_Entity (R : RT_Exception_Code) return Entity_Id is\n+   begin\n+      case R is\n+         when RT_CE_Exceptions => return Standard_Constraint_Error;\n+         when RT_PE_Exceptions => return Standard_Program_Error;\n+         when RT_SE_Exceptions => return Standard_Storage_Error;\n+      end case;\n+   end Get_RT_Exception_Entity;\n+\n    ----------------------\n    -- Is_Non_Ada_Error --\n    ----------------------\n@@ -824,4 +1696,26 @@ package body Exp_Ch11 is\n       return True;\n    end Is_Non_Ada_Error;\n \n+   ----------------------------\n+   -- Warn_If_No_Propagation --\n+   ----------------------------\n+\n+   procedure Warn_If_No_Propagation (N : Node_Id) is\n+   begin\n+      if Restriction_Active (No_Exception_Propagation)\n+        and then Warn_On_Non_Local_Exception\n+      then\n+         Error_Msg_N\n+           (\"?No_Exception_Propagation restriction is active\", N);\n+\n+         if Configurable_Run_Time_Mode then\n+            Error_Msg_N\n+              (\"?Last_Chance_Handler will be called on exception\", N);\n+         else\n+            Error_Msg_N\n+              (\"?program may terminate with unhandled exception\", N);\n+         end if;\n+      end if;\n+   end Warn_If_No_Propagation;\n+\n end Exp_Ch11;"}, {"sha": "354dcff1f104ea467d08a35a04853b59878ca6b0", "filename": "gcc/ada/exp_ch11.ads", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baa3441ddf0daabf8b0127a577121348906aa8b6/gcc%2Fada%2Fexp_ch11.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baa3441ddf0daabf8b0127a577121348906aa8b6/gcc%2Fada%2Fexp_ch11.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch11.ads?ref=baa3441ddf0daabf8b0127a577121348906aa8b6", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -56,6 +56,19 @@ package Exp_Ch11 is\n    --  is also called to expand the special exception handler built for\n    --  accept bodies (see Exp_Ch9.Build_Accept_Body).\n \n+   function Get_Local_Raise_Call_Entity return Entity_Id;\n+   --  This function is provided for use by the back end in conjunction with\n+   --  generation of Local_Raise calls when an exception raise is converted to\n+   --  a goto statement. If Local_Raise is defined, its entity is returned,\n+   --  if not, Empty is returned (in which case the call is silently skipped).\n+\n+   function Get_RT_Exception_Entity (R : RT_Exception_Code) return Entity_Id;\n+   --  This function is provided for use by the back end in conjunction with\n+   --  generation of Local_Raise calls when an exception raise is converted to\n+   --  a goto statement. The argument is the reason code which would be used\n+   --  to determine which Rcheck_nn procedure to call. The returned result is\n+   --  the exception entity to be passed to Local_Raise.\n+\n    function Is_Non_Ada_Error (E : Entity_Id) return Boolean;\n    --  This function is provided for Gigi use. It returns True if operating on\n    --  VMS, and the argument E is the entity for System.Aux_Dec.Non_Ada_Error."}, {"sha": "d080a327cd2f6e4203e9225237dfecd36c969110", "filename": "gcc/ada/exp_sel.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baa3441ddf0daabf8b0127a577121348906aa8b6/gcc%2Fada%2Fexp_sel.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baa3441ddf0daabf8b0127a577121348906aa8b6/gcc%2Fada%2Fexp_sel.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_sel.adb?ref=baa3441ddf0daabf8b0127a577121348906aa8b6", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -63,7 +63,7 @@ package body Exp_Sel is\n \n               Exception_Handlers =>\n                 New_List (\n-                  Make_Exception_Handler (Loc,\n+                  Make_Implicit_Exception_Handler (Loc,\n                     Exception_Choices =>\n                       New_List (\n                         New_Reference_To (Stand.Abort_Signal, Loc)),"}, {"sha": "02f20e693d47289cdb3e07bb27e22deb3f32eef9", "filename": "gcc/ada/gnatbind.adb", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baa3441ddf0daabf8b0127a577121348906aa8b6/gcc%2Fada%2Fgnatbind.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baa3441ddf0daabf8b0127a577121348906aa8b6/gcc%2Fada%2Fgnatbind.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatbind.adb?ref=baa3441ddf0daabf8b0127a577121348906aa8b6", "patch": "@@ -121,12 +121,15 @@ procedure Gnatbind is\n \n       --  Define those restrictions that should be output if the gnatbind\n       --  -r switch is used. Not all restrictions are output for the reasons\n-      --  given above in the list, and this array is used to test whether\n+      --  given below in the list, and this array is used to test whether\n       --  the corresponding pragma should be listed. True means that it\n       --  should not be listed.\n \n       No_Restriction_List : constant array (All_Restrictions) of Boolean :=\n-        (No_Exceptions            => True,\n+        (No_Exception_Propagation => True,\n+         --  Modifies code resulting in different exception semantics\n+\n+         No_Exceptions            => True,\n          --  Has unexpected Suppress (All_Checks) effect\n \n          No_Implicit_Conditionals => True,\n@@ -268,7 +271,7 @@ procedure Gnatbind is\n                   \"procedure names missing in -L\");\n             end if;\n \n-         --  -Sin -Slo -Shi -Sxx\n+         --  -Sin -Slo -Shi -Sxx -Sev\n \n          elsif Argv'Length = 4\n            and then Argv (2) = 'S'"}, {"sha": "ee8c72e8112bafe32153bb5e107ed8d6721c621e", "filename": "gcc/ada/par-ch11.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baa3441ddf0daabf8b0127a577121348906aa8b6/gcc%2Fada%2Fpar-ch11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baa3441ddf0daabf8b0127a577121348906aa8b6/gcc%2Fada%2Fpar-ch11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch11.adb?ref=baa3441ddf0daabf8b0127a577121348906aa8b6", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -94,6 +94,7 @@ package body Ch11 is\n \n    begin\n       Handler_Node := New_Node (N_Exception_Handler, Token_Ptr);\n+      Set_Local_Raise_Statements (Handler_Node, No_Elist);\n       T_When;\n \n       --  Test for possible choice parameter present"}, {"sha": "c13537da39f9e76dd94dfea78a98c0a4704ebe54", "filename": "gcc/ada/restrict.adb", "status": "modified", "additions": 30, "deletions": 11, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baa3441ddf0daabf8b0127a577121348906aa8b6/gcc%2Fada%2Frestrict.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baa3441ddf0daabf8b0127a577121348906aa8b6/gcc%2Fada%2Frestrict.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frestrict.adb?ref=baa3441ddf0daabf8b0127a577121348906aa8b6", "patch": "@@ -129,29 +129,48 @@ package body Restrict is\n                      Get_File_Name (U, Subunit => False);\n \n          begin\n-            if not Is_Predefined_File_Name (Fnam) then\n-               return;\n+            --  Get file name\n \n-            --  Predefined spec, needs checking against list\n+            Get_Name_String (Fnam);\n \n-            else\n-               --  Pad name to 8 characters with blanks\n+            --  Nothing to do if name not at least 5 characters long ending\n+            --  in .ads or .adb extension, which we strip.\n+\n+            if Name_Len < 5\n+              or else (Name_Buffer (Name_Len - 3 .. Name_Len) /= \".ads\"\n+                         and then\n+                       Name_Buffer (Name_Len - 4 .. Name_Len) /= \".adb\")\n+            then\n+               return;\n+            end if;\n \n-               Get_Name_String (Fnam);\n-               Name_Len := Name_Len - 4;\n+            --  Strip extension and pad to eight characters\n \n-               while Name_Len < 8 loop\n-                  Name_Len := Name_Len + 1;\n-                  Name_Buffer (Name_Len) := ' ';\n-               end loop;\n+            Name_Len := Name_Len - 4;\n+            while Name_Len < 8 loop\n+               Name_Len := Name_Len + 1;\n+               Name_Buffer (Name_Len) := ' ';\n+            end loop;\n+\n+            --  If predefined unit, check the list of restricted units\n \n+            if Is_Predefined_File_Name (Fnam) then\n                for J in Unit_Array'Range loop\n                   if Name_Len = 8\n                     and then Name_Buffer (1 .. 8) = Unit_Array (J).Filenm\n                   then\n                      Check_Restriction (Unit_Array (J).Res_Id, N);\n                   end if;\n                end loop;\n+\n+               --  If not predefied unit, then one special check still remains.\n+               --  GNAT.Current_Exception is not allowed if we have restriction\n+               --  No_Exception_Propagation active.\n+\n+            else\n+               if Name_Buffer (1 .. 8) = \"g-curexc\" then\n+                  Check_Restriction (No_Exception_Propagation, N);\n+               end if;\n             end if;\n          end;\n       end if;"}, {"sha": "b88e3691cba4efd001fa65b2478ac58bfc7c556b", "filename": "gcc/ada/s-rident.ads", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baa3441ddf0daabf8b0127a577121348906aa8b6/gcc%2Fada%2Fs-rident.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baa3441ddf0daabf8b0127a577121348906aa8b6/gcc%2Fada%2Fs-rident.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-rident.ads?ref=baa3441ddf0daabf8b0127a577121348906aa8b6", "patch": "@@ -74,6 +74,7 @@ package System.Rident is\n       No_Entry_Calls_In_Elaboration_Code,      -- GNAT\n       No_Entry_Queue,                          -- GNAT (Ravenscar)\n       No_Exception_Handlers,                   -- GNAT\n+      No_Exception_Propagation,                -- GNAT\n       No_Exception_Registration,               -- GNAT\n       No_Exceptions,                           -- (RM H.4(12))\n       No_Finalization,                         -- GNAT"}, {"sha": "7967c364162b06f12a272bc6f30a620e1851c6bf", "filename": "gcc/ada/sem.adb", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baa3441ddf0daabf8b0127a577121348906aa8b6/gcc%2Fada%2Fsem.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baa3441ddf0daabf8b0127a577121348906aa8b6/gcc%2Fada%2Fsem.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem.adb?ref=baa3441ddf0daabf8b0127a577121348906aa8b6", "patch": "@@ -610,6 +610,12 @@ package body Sem is\n            N_Mod_Clause                             |\n            N_Modular_Type_Definition                |\n            N_Ordinary_Fixed_Point_Definition        |\n+           N_Pop_Constraint_Error_Label             |\n+           N_Pop_Program_Error_Label                |\n+           N_Pop_Storage_Error_Label                |\n+           N_Push_Constraint_Error_Label            |\n+           N_Push_Program_Error_Label               |\n+           N_Push_Storage_Error_Label               |\n            N_Parameter_Specification                |\n            N_Pragma_Argument_Association            |\n            N_Procedure_Specification                |\n@@ -626,18 +632,24 @@ package body Sem is\n \n       Debug_A_Exit (\"analyzing  \", N, \"  (done)\");\n \n-      --  Now that we have analyzed the node, we call the expander to\n-      --  perform possible expansion. This is done only for nodes that\n-      --  are not subexpressions, because in the case of subexpressions,\n-      --  we don't have the type yet, and the expander will need to know\n-      --  the type before it can do its job. For subexpression nodes, the\n-      --  call to the expander happens in the Sem_Res.Resolve.\n+      --  Now that we have analyzed the node, we call the expander to perform\n+      --  possible expansion. We skip this for subexpressions, because we don't\n+      --  have the type yet, and the expander will need to know the type before\n+      --  it can do its job. For subexpression nodes, the call to the expander\n+      --  happens in Sem_Res.Resolve. A special exception is Raise_xxx_Error,\n+      --  which can appear in a statement context, and needs expanding now in\n+      --  the case (distinguished by Etype, as documented in Sinfo).\n \n       --  The Analyzed flag is also set at this point for non-subexpression\n-      --  nodes (in the case of subexpression nodes, we can't set the flag\n-      --  yet, since resolution and expansion have not yet been completed)\n-\n-      if Nkind (N) not in N_Subexpr then\n+      --  nodes (in the case of subexpression nodes, we can't set the flag yet,\n+      --  since resolution and expansion have not yet been completed). Note\n+      --  that for N_Raise_xxx_Error we have to distinguish the expression\n+      --  case from the statement case.\n+\n+      if Nkind (N) not in N_Subexpr\n+        or else (Nkind (N) in N_Raise_xxx_Error\n+                  and then Etype (N) = Standard_Void_Type)\n+      then\n          Expand (N);\n       end if;\n    end Analyze;"}, {"sha": "0f2245e33f8e0dc109716bb87dd166218ef6f176", "filename": "gcc/ada/sem_ch11.adb", "status": "modified", "additions": 81, "deletions": 32, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baa3441ddf0daabf8b0127a577121348906aa8b6/gcc%2Fada%2Fsem_ch11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baa3441ddf0daabf8b0127a577121348906aa8b6/gcc%2Fada%2Fsem_ch11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch11.adb?ref=baa3441ddf0daabf8b0127a577121348906aa8b6", "patch": "@@ -55,16 +55,14 @@ package body Sem_Ch11 is\n    procedure Analyze_Exception_Declaration (N : Node_Id) is\n       Id : constant Entity_Id := Defining_Identifier (N);\n       PF : constant Boolean   := Is_Pure (Current_Scope);\n-\n    begin\n-      Generate_Definition (Id);\n-      Enter_Name          (Id);\n-      Set_Ekind           (Id, E_Exception);\n-      Set_Exception_Code  (Id, Uint_0);\n-      Set_Etype           (Id, Standard_Exception_Type);\n-\n+      Generate_Definition         (Id);\n+      Enter_Name                  (Id);\n+      Set_Ekind                   (Id, E_Exception);\n+      Set_Exception_Code          (Id, Uint_0);\n+      Set_Etype                   (Id, Standard_Exception_Type);\n       Set_Is_Statically_Allocated (Id);\n-      Set_Is_Pure (Id, PF);\n+      Set_Is_Pure                 (Id, PF);\n    end Analyze_Exception_Declaration;\n \n    --------------------------------\n@@ -182,28 +180,35 @@ package body Sem_Ch11 is\n          --  Otherwise we have a real exception handler\n \n          else\n-            --  Deal with choice parameter. The exception handler is\n-            --  a declarative part for it, so it constitutes a scope\n-            --  for visibility purposes. We create an entity to denote\n-            --  the whole exception part, and use it as the scope of all\n-            --  the choices, which may even have the same name without\n-            --  conflict. This scope plays no other role in expansion or\n-            --  or code generation.\n+            --  Deal with choice parameter. The exception handler is a\n+            --  declarative part for the choice parameter, so it constitutes a\n+            --  scope for visibility purposes. We create an entity to denote\n+            --  the whole exception part, and use it as the scope of all the\n+            --  choices, which may even have the same name without conflict.\n+            --  This scope plays no other role in expansion or or code\n+            --  generation.\n \n             Choice := Choice_Parameter (Handler);\n \n             if Present (Choice) then\n+               Set_Local_Raise_Not_OK (Handler);\n+\n+               if Comes_From_Source (Choice) then\n+                  Check_Restriction (No_Exception_Propagation, Choice);\n+               end if;\n+\n                if No (H_Scope) then\n-                  H_Scope := New_Internal_Entity\n-                    (E_Block, Current_Scope, Sloc (Choice), 'E');\n+                  H_Scope :=\n+                    New_Internal_Entity\n+                     (E_Block, Current_Scope, Sloc (Choice), 'E');\n                end if;\n \n                New_Scope (H_Scope);\n                Set_Etype (H_Scope, Standard_Void_Type);\n \n                --  Set the Finalization Chain entity to Error means that it\n-               --  should not be used at that level but the parent one\n-               --  should be used instead.\n+               --  should not be used at that level but the parent one should\n+               --  be used instead.\n \n                --  ??? this usage needs documenting in Einfo/Exp_Ch7 ???\n                --  ??? using Error for this non-error condition is nasty ???\n@@ -215,8 +220,8 @@ package body Sem_Ch11 is\n                Set_Etype (Choice, RTE (RE_Exception_Occurrence));\n                Generate_Definition (Choice);\n \n-               --  Set source assigned flag, since in effect this field\n-               --  is always assigned an initial value by the exception.\n+               --  Set source assigned flag, since in effect this field is\n+               --  always assigned an initial value by the exception.\n \n                Set_Never_Set_In_Source (Choice, False);\n             end if;\n@@ -234,8 +239,20 @@ package body Sem_Ch11 is\n                else\n                   Analyze (Id);\n \n+                  --  In most cases the choice has already been analyzed in\n+                  --  Analyze_Handled_Statement_Sequence, in order to expand\n+                  --  local handlers. This advance analysis does not take into\n+                  --  account the case in which a choice has the same name as\n+                  --  the choice parameter of the handler, which may hide an\n+                  --  outer exception. This pathological case appears in ACATS\n+                  --  B80001_3.adb, and requires an explicit check to verify\n+                  --  that the id is not hidden.\n+\n                   if not Is_Entity_Name (Id)\n                     or else Ekind (Entity (Id)) /= E_Exception\n+                    or else\n+                      (Nkind (Id) = N_Identifier\n+                        and then Chars (Id) = Chars (Choice))\n                   then\n                      Error_Msg_N (\"exception name expected\", Id);\n \n@@ -303,9 +320,9 @@ package body Sem_Ch11 is\n                Next (Id);\n             end loop;\n \n-            --  Check for redundant handler (has only raise statement) and\n-            --  is either an others handler, or is a specific handler when\n-            --  no others handler is present.\n+            --  Check for redundant handler (has only raise statement) and is\n+            --  either an others handler, or is a specific handler when no\n+            --  others handler is present.\n \n             if Warn_On_Redundant_Constructs\n               and then List_Length (Statements (Handler)) = 1\n@@ -342,20 +359,45 @@ package body Sem_Ch11 is\n \n    procedure Analyze_Handled_Statements (N : Node_Id) is\n       Handlers : constant List_Id := Exception_Handlers (N);\n+      Handler  : Node_Id;\n+      Choice   : Node_Id;\n \n    begin\n       if Present (Handlers) then\n          Kill_All_Checks;\n       end if;\n \n+      --  We are now going to analyze the statements and then the exception\n+      --  handlers. We certainly need to do things in this order to get the\n+      --  proper sequential semantics for various warnings.\n+\n+      --  However, there is a glitch. When we process raise statements, an\n+      --  optimization is to look for local handlers and specialize the code\n+      --  in this case.\n+\n+      --  In order to detect if a handler is matching, we must have at least\n+      --  analyzed the choices in the proper scope so that proper visibility\n+      --  analysis is performed. Hence we analyze just the choices first,\n+      --  before we analyze the statement sequence.\n+\n+      Handler := First_Non_Pragma (Handlers);\n+      while Present (Handler) loop\n+         Choice := First_Non_Pragma (Exception_Choices (Handler));\n+         while Present (Choice) loop\n+            Analyze (Choice);\n+            Next_Non_Pragma (Choice);\n+         end loop;\n+\n+         Next_Non_Pragma (Handler);\n+      end loop;\n+\n       --  Analyze statements in sequence\n \n       Analyze_Statements (Statements (N));\n \n-      --  If the current scope is a subprogram, and there are no explicit\n-      --  exception handlers, then this is the right place to check for\n-      --  hanging useless assignments from the statement sequence of the\n-      --  subprogram body.\n+      --  If the current scope is a subprogram, then this is the right place to\n+      --  check for hanging useless assignments from the statement sequence of\n+      --  the subprogram body.\n \n       if Is_Subprogram (Current_Scope) then\n          Warn_On_Useless_Assignments (Current_Scope);\n@@ -389,9 +431,9 @@ package body Sem_Ch11 is\n          Check_Restriction (No_Exceptions, N);\n       end if;\n \n-      --  Check for useless assignment to OUT or IN OUT scalar\n-      --  immediately preceding the raise. Right now we only look\n-      --  at assignment statements, we could do more.\n+      --  Check for useless assignment to OUT or IN OUT scalar immediately\n+      --  preceding the raise. Right now we only look at assignment statements,\n+      --  we could do more.\n \n       if Is_List_Member (N) then\n          declare\n@@ -424,7 +466,6 @@ package body Sem_Ch11 is\n       --  Reraise statement\n \n       if No (Exception_Id) then\n-\n          P := Parent (N);\n          Nkind_P := Nkind (P);\n \n@@ -441,6 +482,14 @@ package body Sem_Ch11 is\n          if Nkind (P) /= N_Exception_Handler then\n             Error_Msg_N\n               (\"reraise statement must appear directly in a handler\", N);\n+\n+         --  If a handler has a reraise, it cannot be the target of a local\n+         --  raise (goto optimization is impossible), and if the no exception\n+         --  propagation restriction is set, this is a violation.\n+\n+         else\n+            Set_Local_Raise_Not_OK (P);\n+            Check_Restriction (No_Exception_Propagation, N);\n          end if;\n \n       --  Normal case with exception id present"}, {"sha": "543379079d122ce6cf40cda240c9078e264c4a4b", "filename": "gcc/ada/tbuild.adb", "status": "modified", "additions": 53, "deletions": 14, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baa3441ddf0daabf8b0127a577121348906aa8b6/gcc%2Fada%2Ftbuild.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baa3441ddf0daabf8b0127a577121348906aa8b6/gcc%2Fada%2Ftbuild.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftbuild.adb?ref=baa3441ddf0daabf8b0127a577121348906aa8b6", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.        --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.        --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -53,25 +53,46 @@ package body Tbuild is\n    -- Add_Unique_Serial_Number --\n    ------------------------------\n \n-   procedure Add_Unique_Serial_Number is\n-      Unit_Node : constant Node_Id := Unit (Cunit (Current_Sem_Unit));\n+   Config_Serial_Number : Nat := 0;\n+   --  Counter for use in config pragmas, see comment below\n \n+   procedure Add_Unique_Serial_Number is\n    begin\n-      Add_Nat_To_Name_Buffer (Increment_Serial_Number);\n+      --  If we are analyzing configuration pragmas, Cunit (Main_Unit) will\n+      --  not be set yet. This happens for example when analyzing static\n+      --  string expressions in configuration pragmas. For this case, we\n+      --  just maintain a local counter, defined above and we do not need\n+      --  to add a b or s indication in this case.\n \n-      --  Add either b or s, depending on whether current unit is a spec\n-      --  or a body. This is needed because we may generate the same name\n-      --  in a spec and a body otherwise.\n+      if No (Cunit (Current_Sem_Unit)) then\n+         Config_Serial_Number := Config_Serial_Number + 1;\n+         Add_Nat_To_Name_Buffer (Config_Serial_Number);\n+         return;\n \n-      Name_Len := Name_Len + 1;\n+      --  Normal case, within a unit\n \n-      if Nkind (Unit_Node) = N_Package_Declaration\n-        or else Nkind (Unit_Node) = N_Subprogram_Declaration\n-        or else Nkind (Unit_Node) in N_Generic_Declaration\n-      then\n-         Name_Buffer (Name_Len) := 's';\n       else\n-         Name_Buffer (Name_Len) := 'b';\n+         declare\n+            Unit_Node : constant Node_Id := Unit (Cunit (Current_Sem_Unit));\n+\n+         begin\n+            Add_Nat_To_Name_Buffer (Increment_Serial_Number);\n+\n+            --  Add either b or s, depending on whether current unit is a spec\n+            --  or a body. This is needed because we may generate the same name\n+            --  in a spec and a body otherwise.\n+\n+            Name_Len := Name_Len + 1;\n+\n+            if Nkind (Unit_Node) = N_Package_Declaration\n+              or else Nkind (Unit_Node) = N_Subprogram_Declaration\n+              or else Nkind (Unit_Node) in N_Generic_Declaration\n+            then\n+               Name_Buffer (Name_Len) := 's';\n+            else\n+               Name_Buffer (Name_Len) := 'b';\n+            end if;\n+         end;\n       end if;\n    end Add_Unique_Serial_Number;\n \n@@ -178,6 +199,24 @@ package body Tbuild is\n               New_Reference_To (First_Tag_Component (Full_Type), Loc)));\n    end Make_DT_Access;\n \n+   -------------------------------------\n+   -- Make_Implicit_Exception_Handler --\n+   -------------------------------------\n+\n+   function Make_Implicit_Exception_Handler\n+     (Sloc              : Source_Ptr;\n+      Choice_Parameter  : Node_Id := Empty;\n+      Exception_Choices : List_Id;\n+      Statements        : List_Id) return Node_Id\n+   is\n+      Handler : constant Node_Id :=\n+                  Make_Exception_Handler\n+                    (Sloc, Choice_Parameter, Exception_Choices, Statements);\n+   begin\n+      Set_Local_Raise_Statements (Handler, No_Elist);\n+      return Handler;\n+   end Make_Implicit_Exception_Handler;\n+\n    --------------------------------\n    -- Make_Implicit_If_Statement --\n    --------------------------------"}, {"sha": "67fe5a1d153f58920161639a066c8467c115916e", "filename": "gcc/ada/tbuild.ads", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baa3441ddf0daabf8b0127a577121348906aa8b6/gcc%2Fada%2Ftbuild.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baa3441ddf0daabf8b0127a577121348906aa8b6/gcc%2Fada%2Ftbuild.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftbuild.ads?ref=baa3441ddf0daabf8b0127a577121348906aa8b6", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -74,6 +74,17 @@ package Tbuild is\n    --  Create an access to the Dispatch Table by using the Tag field\n    --  of a tagged record : Acc_Dt (Rec.tag).all\n \n+   function Make_Implicit_Exception_Handler\n+     (Sloc              : Source_Ptr;\n+      Choice_Parameter  : Node_Id := Empty;\n+      Exception_Choices : List_Id;\n+      Statements        : List_Id) return Node_Id;\n+   pragma Inline (Make_Implicit_Exception_Handler);\n+   --  This is just like Make_Exception_Handler, except that it also sets the\n+   --  Local_Raise_Statements field to No_Elist, ensuring that it is properly\n+   --  initialized. This should always be used when creating exception handlers\n+   --  as part of the expansion.\n+\n    function Make_Implicit_If_Statement\n      (Node            : Node_Id;\n       Condition       : Node_Id;"}]}