{"sha": "458f7a5459a8907fa55a84248ba137281ac675c4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDU4ZjdhNTQ1OWE4OTA3ZmE1NWE4NDI0OGJhMTM3MjgxYWM2NzVjNA==", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-07-01T16:22:57Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-07-01T16:22:57Z"}, "message": "Merge #540\n\n540: Add trait-impl support for methods r=philberty a=philberty\n\nThis PR strips HIR::Method and reuses the HIR::Function with a HIR::SelfParam.\r\nIt reduces complexity in type checking and GENERIC generation.\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "e3df7cf10a523c2f9320d152b0d799c0693131e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e3df7cf10a523c2f9320d152b0d799c0693131e7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/458f7a5459a8907fa55a84248ba137281ac675c4", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJg3evhCRBK7hj4Ov3rIwAAbAUIAAEQXUddmER1OaFoNyGk0PiP\nXHELR7MP4Z6325cKvQ9HmXQdRQV67jhaBr4WzKNyAbwWlKW9k9stF8qjURYxfIlX\n4TlCgvUSm5nrtO3vacehuKu3vKITfecKxQTv7KHIZwCnwh5IldHVNQQZmFFq2TjL\nZy4We722qDCxA9jP6IEycAhnDrIFO8/tI6bFmFxe3RW7zTJk3YROnjA1HF039uvU\n+TGy7qi79CXRpjulu1V8GPI4Kqsuy3M4AR0Tngf4FzSVeSf457pzIyfAO2nlQXw3\nZVvVk/rsv7V5/JUPBKTPeLOoZKdMks/S9tOmsUnX8jzc+OL2iEzEgJNHinzerBg=\n=o63V\n-----END PGP SIGNATURE-----\n", "payload": "tree e3df7cf10a523c2f9320d152b0d799c0693131e7\nparent 0163ca4b6f2248103d416405b6758f7abb5e18ab\nparent 5e4505e162d069ca58ce43d62770b81cb36137c0\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1625156577 +0000\ncommitter GitHub <noreply@github.com> 1625156577 +0000\n\nMerge #540\n\n540: Add trait-impl support for methods r=philberty a=philberty\n\nThis PR strips HIR::Method and reuses the HIR::Function with a HIR::SelfParam.\r\nIt reduces complexity in type checking and GENERIC generation.\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/458f7a5459a8907fa55a84248ba137281ac675c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/458f7a5459a8907fa55a84248ba137281ac675c4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/458f7a5459a8907fa55a84248ba137281ac675c4/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0163ca4b6f2248103d416405b6758f7abb5e18ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0163ca4b6f2248103d416405b6758f7abb5e18ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0163ca4b6f2248103d416405b6758f7abb5e18ab"}, {"sha": "5e4505e162d069ca58ce43d62770b81cb36137c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e4505e162d069ca58ce43d62770b81cb36137c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e4505e162d069ca58ce43d62770b81cb36137c0"}], "stats": {"total": 1022, "additions": 280, "deletions": 742}, "files": [{"sha": "7865a44cae1f89f2365c3b52d323d2b0ccc81e33", "filename": "gcc/rust/ast/rust-item.h", "status": "modified", "additions": 7, "deletions": 17, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/458f7a5459a8907fa55a84248ba137281ac675c4/gcc%2Frust%2Fast%2Frust-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/458f7a5459a8907fa55a84248ba137281ac675c4/gcc%2Frust%2Fast%2Frust-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-item.h?ref=458f7a5459a8907fa55a84248ba137281ac675c4", "patch": "@@ -3382,24 +3382,11 @@ class Trait : public VisItem\n {\n   bool has_unsafe;\n   Identifier name;\n-\n-  // bool has_generics;\n-  // Generics generic_params;\n-  std::vector<std::unique_ptr<GenericParam> > generic_params; // inlined\n-\n-  // bool has_type_param_bounds;\n-  // TypeParamBounds type_param_bounds;\n-  std::vector<std::unique_ptr<TypeParamBound> >\n-    type_param_bounds; // inlined form\n-\n-  // bool has_where_clause;\n+  std::vector<std::unique_ptr<GenericParam> > generic_params;\n+  std::vector<std::unique_ptr<TypeParamBound> > type_param_bounds;\n   WhereClause where_clause;\n-\n   std::vector<Attribute> inner_attrs;\n-\n-  // bool has_trait_items;\n   std::vector<std::unique_ptr<TraitItem> > trait_items;\n-\n   Location locus;\n \n public:\n@@ -3432,7 +3419,6 @@ class Trait : public VisItem\n \t std::vector<std::unique_ptr<TraitItem> > trait_items, Visibility vis,\n \t std::vector<Attribute> outer_attrs, std::vector<Attribute> inner_attrs,\n \t Location locus)\n-\n     : VisItem (std::move (vis), std::move (outer_attrs)),\n       has_unsafe (is_unsafe), name (std::move (name)),\n       generic_params (std::move (generic_params)),\n@@ -3530,13 +3516,17 @@ class Trait : public VisItem\n     return type_param_bounds;\n   }\n \n-  // TODO: is this better? Or is a \"vis_block\" better?\n   WhereClause &get_where_clause ()\n   {\n     rust_assert (has_where_clause ());\n     return where_clause;\n   }\n \n+  void insert_implict_self (std::unique_ptr<AST::GenericParam> &&param)\n+  {\n+    generic_params.push_back (std::move (param));\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */"}, {"sha": "6a05c1cf42450d072c02b18579d4d1615642e197", "filename": "gcc/rust/backend/rust-compile-base.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/458f7a5459a8907fa55a84248ba137281ac675c4/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/458f7a5459a8907fa55a84248ba137281ac675c4/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-base.h?ref=458f7a5459a8907fa55a84248ba137281ac675c4", "patch": "@@ -121,7 +121,6 @@ class HIRCompileBase : public HIR::HIRVisitor\n   // virtual void visit(WhereClauseItem& item) {}\n   virtual void visit (HIR::LifetimeWhereClauseItem &item) {}\n   virtual void visit (HIR::TypeBoundWhereClauseItem &item) {}\n-  virtual void visit (HIR::Method &method) {}\n   virtual void visit (HIR::ModuleBodied &module) {}\n   virtual void visit (HIR::ModuleNoBody &module) {}\n   virtual void visit (HIR::ExternCrate &crate) {}"}, {"sha": "83af5deab178a646fc0ccde6fa6ef0ff7b121f54", "filename": "gcc/rust/backend/rust-compile-implitem.h", "status": "modified", "additions": 38, "deletions": 202, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/458f7a5459a8907fa55a84248ba137281ac675c4/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/458f7a5459a8907fa55a84248ba137281ac675c4/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h?ref=458f7a5459a8907fa55a84248ba137281ac675c4", "patch": "@@ -135,212 +135,48 @@ class CompileInherentImplItem : public HIRCompileBase\n     TyTy::BaseType *tyret = fntype->get_return_type ();\n     std::vector<Bvariable *> param_vars;\n \n-    size_t i = 0;\n-    for (auto &it : fntype->get_params ())\n+    if (function.is_method ())\n       {\n-\tHIR::FunctionParam &referenced_param\n-\t  = function.get_function_params ().at (i);\n-\tauto param_tyty = it.second;\n-\tauto compiled_param_type\n-\t  = TyTyResolveCompile::compile (ctx, param_tyty);\n-\n-\tLocation param_locus\n-\t  = ctx->get_mappings ()->lookup_location (param_tyty->get_ref ());\n-\tBvariable *compiled_param_var\n-\t  = CompileFnParam::compile (ctx, fndecl, &referenced_param,\n-\t\t\t\t     compiled_param_type, param_locus);\n-\tif (compiled_param_var == nullptr)\n+\t// insert self\n+\tTyTy::BaseType *self_tyty_lookup = nullptr;\n+\tif (!ctx->get_tyctx ()->lookup_type (\n+\t      function.get_self_param ().get_mappings ().get_hirid (),\n+\t      &self_tyty_lookup))\n \t  {\n-\t    rust_error_at (param_locus, \"failed to compile parameter variable\");\n+\t    rust_error_at (function.get_self_param ().get_locus (),\n+\t\t\t   \"failed to lookup self param type\");\n \t    return;\n \t  }\n \n-\tparam_vars.push_back (compiled_param_var);\n-\n-\tctx->insert_var_decl (referenced_param.get_mappings ().get_hirid (),\n-\t\t\t      compiled_param_var);\n-\ti++;\n-      }\n-\n-    if (!ctx->get_backend ()->function_set_parameters (fndecl, param_vars))\n-      {\n-\trust_fatal_error (function.get_locus (),\n-\t\t\t  \"failed to setup parameter variables\");\n-\treturn;\n-      }\n-\n-    // lookup locals\n-    auto block_expr = function.get_definition ().get ();\n-    auto body_mappings = block_expr->get_mappings ();\n-\n-    Resolver::Rib *rib = nullptr;\n-    if (!ctx->get_resolver ()->find_name_rib (body_mappings.get_nodeid (),\n-\t\t\t\t\t      &rib))\n-      {\n-\trust_fatal_error (function.get_locus (),\n-\t\t\t  \"failed to setup locals per block\");\n-\treturn;\n-      }\n-\n-    std::vector<Bvariable *> locals;\n-    bool ok = compile_locals_for_block (*rib, fndecl, locals);\n-    rust_assert (ok);\n-\n-    Bblock *enclosing_scope = NULL;\n-    HIR::BlockExpr *function_body = function.get_definition ().get ();\n-    Location start_location = function_body->get_locus ();\n-    Location end_location = function_body->get_closing_locus ();\n-\n-    Bblock *code_block\n-      = ctx->get_backend ()->block (fndecl, enclosing_scope, locals,\n-\t\t\t\t    start_location, end_location);\n-    ctx->push_block (code_block);\n-\n-    Bvariable *return_address = nullptr;\n-    if (function.has_function_return_type ())\n-      {\n-\tBtype *return_type = TyTyResolveCompile::compile (ctx, tyret);\n-\n-\tbool address_is_taken = false;\n-\tBstatement *ret_var_stmt = nullptr;\n-\n-\treturn_address = ctx->get_backend ()->temporary_variable (\n-\t  fndecl, code_block, return_type, NULL, address_is_taken,\n-\t  function.get_locus (), &ret_var_stmt);\n-\n-\tctx->add_statement (ret_var_stmt);\n-      }\n-\n-    ctx->push_fn (fndecl, return_address);\n-\n-    compile_function_body (fndecl, function.get_definition (),\n-\t\t\t   function.has_function_return_type ());\n-\n-    ctx->pop_block ();\n-    auto body = ctx->get_backend ()->block_statement (code_block);\n-    if (!ctx->get_backend ()->function_set_body (fndecl, body))\n-      {\n-\trust_error_at (function.get_locus (), \"failed to set body to function\");\n-\treturn;\n-      }\n-\n-    ctx->pop_fn ();\n-\n-    ctx->push_function (fndecl);\n-  }\n-\n-  void visit (HIR::Method &method) override\n-  {\n-    if (!compile_fns)\n-      return;\n-\n-    TyTy::BaseType *fntype_tyty;\n-    if (!ctx->get_tyctx ()->lookup_type (method.get_mappings ().get_hirid (),\n-\t\t\t\t\t &fntype_tyty))\n-      {\n-\trust_fatal_error (method.get_locus (),\n-\t\t\t  \"failed to lookup function type\");\n-\treturn;\n-      }\n-\n-    rust_assert (fntype_tyty->get_kind () == TyTy::TypeKind::FNDEF);\n-    TyTy::FnType *fntype = static_cast<TyTy::FnType *> (fntype_tyty);\n-    if (fntype->has_subsititions_defined ())\n-      {\n-\t// we cant do anything for this only when it is used and a concrete type\n-\t// is given\n-\tif (concrete == nullptr)\n-\t  return;\n-\telse\n+\tBtype *self_type = TyTyResolveCompile::compile (ctx, self_tyty_lookup);\n+\tif (self_type == nullptr)\n \t  {\n-\t    rust_assert (concrete->get_kind () == TyTy::TypeKind::FNDEF);\n-\t    fntype = static_cast<TyTy::FnType *> (concrete);\n+\t    rust_error_at (function.get_self_param ().get_locus (),\n+\t\t\t   \"failed to compile self param type\");\n+\t    return;\n \t  }\n-      }\n \n-    // items can be forward compiled which means we may not need to invoke this\n-    // code. We might also have already compiled this generic function as well.\n-    Bfunction *lookup = nullptr;\n-    if (ctx->lookup_function_decl (fntype->get_ty_ref (), &lookup, fntype))\n-      {\n-\t// has this been added to the list then it must be finished\n-\tif (ctx->function_completed (lookup))\n+\tBvariable *compiled_self_param\n+\t  = CompileSelfParam::compile (ctx, fndecl, function.get_self_param (),\n+\t\t\t\t       self_type,\n+\t\t\t\t       function.get_self_param ().get_locus ());\n+\tif (compiled_self_param == nullptr)\n \t  {\n-\t    Bfunction *dummy = nullptr;\n-\t    if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &dummy))\n-\t      ctx->insert_function_decl (fntype->get_ty_ref (), lookup, fntype);\n-\n+\t    rust_error_at (function.get_self_param ().get_locus (),\n+\t\t\t   \"failed to compile self param variable\");\n \t    return;\n \t  }\n-      }\n-\n-    if (fntype->has_subsititions_defined ())\n-      {\n-\t// override the Hir Lookups for the substituions in this context\n-\tfntype->override_context ();\n-      }\n-\n-    // convert to the actual function type\n-    ::Btype *compiled_fn_type = TyTyResolveCompile::compile (ctx, fntype);\n-\n-    unsigned int flags = 0;\n-\n-    // if its the main fn or pub visibility mark its as DECL_PUBLIC\n-    // please see https://github.com/Rust-GCC/gccrs/pull/137\n-    if (method.has_visibility ())\n-      flags |= Backend::function_is_visible;\n-\n-    std::string fn_identifier\n-      = self->get_name () + \"_\" + method.get_method_name ();\n-    std::string asm_name\n-      = ctx->mangle_impl_item (self, fntype, method.get_method_name ());\n-\n-    Bfunction *fndecl\n-      = ctx->get_backend ()->function (compiled_fn_type, fn_identifier,\n-\t\t\t\t       asm_name, flags, method.get_locus ());\n-    ctx->insert_function_decl (fntype->get_ty_ref (), fndecl, fntype);\n-\n-    // setup the params\n-    TyTy::BaseType *tyret = fntype->get_return_type ();\n-    std::vector<Bvariable *> param_vars;\n \n-    // insert self\n-    TyTy::BaseType *self_tyty_lookup = nullptr;\n-    if (!ctx->get_tyctx ()->lookup_type (\n-\t  method.get_self_param ().get_mappings ().get_hirid (),\n-\t  &self_tyty_lookup))\n-      {\n-\trust_error_at (method.get_self_param ().get_locus (),\n-\t\t       \"failed to lookup self param type\");\n-\treturn;\n-      }\n-\n-    Btype *self_type = TyTyResolveCompile::compile (ctx, self_tyty_lookup);\n-    if (self_type == nullptr)\n-      {\n-\trust_error_at (method.get_self_param ().get_locus (),\n-\t\t       \"failed to compile self param type\");\n-\treturn;\n-      }\n-\n-    Bvariable *compiled_self_param\n-      = CompileSelfParam::compile (ctx, fndecl, method.get_self_param (),\n-\t\t\t\t   self_type,\n-\t\t\t\t   method.get_self_param ().get_locus ());\n-    if (compiled_self_param == nullptr)\n-      {\n-\trust_error_at (method.get_self_param ().get_locus (),\n-\t\t       \"failed to compile self param variable\");\n-\treturn;\n+\tparam_vars.push_back (compiled_self_param);\n+\tctx->insert_var_decl (\n+\t  function.get_self_param ().get_mappings ().get_hirid (),\n+\t  compiled_self_param);\n       }\n \n-    param_vars.push_back (compiled_self_param);\n-    ctx->insert_var_decl (method.get_self_param ().get_mappings ().get_hirid (),\n-\t\t\t  compiled_self_param);\n-\n-    // offset from + 1 for the TyTy::FnType being used\n-    size_t i = 1;\n-    for (auto referenced_param : method.get_function_params ())\n+    // offset from + 1 for the TyTy::FnType being used when this is a method to\n+    // skip over Self on the FnType\n+    size_t i = function.is_method () ? 1 : 0;\n+    for (auto referenced_param : function.get_function_params ())\n       {\n \tauto tyty_param = fntype->param_at (i);\n \tauto param_tyty = tyty_param.second;\n@@ -361,7 +197,7 @@ class CompileInherentImplItem : public HIRCompileBase\n \t\t\t\t     compiled_param_type, param_locus);\n \tif (compiled_param_var == nullptr)\n \t  {\n-\t    rust_error_at (param_locus, \"failed to compile parameter variable\");\n+\t    rust_error_at (param_locus, \"Failed to compile parameter variable\");\n \t    return;\n \t  }\n \n@@ -374,20 +210,20 @@ class CompileInherentImplItem : public HIRCompileBase\n \n     if (!ctx->get_backend ()->function_set_parameters (fndecl, param_vars))\n       {\n-\trust_fatal_error (method.get_locus (),\n+\trust_fatal_error (function.get_locus (),\n \t\t\t  \"failed to setup parameter variables\");\n \treturn;\n       }\n \n     // lookup locals\n-    auto block_expr = method.get_function_body ().get ();\n+    auto block_expr = function.get_definition ().get ();\n     auto body_mappings = block_expr->get_mappings ();\n \n     Resolver::Rib *rib = nullptr;\n     if (!ctx->get_resolver ()->find_name_rib (body_mappings.get_nodeid (),\n \t\t\t\t\t      &rib))\n       {\n-\trust_fatal_error (method.get_locus (),\n+\trust_fatal_error (function.get_locus (),\n \t\t\t  \"failed to setup locals per block\");\n \treturn;\n       }\n@@ -397,7 +233,7 @@ class CompileInherentImplItem : public HIRCompileBase\n     rust_assert (ok);\n \n     Bblock *enclosing_scope = NULL;\n-    HIR::BlockExpr *function_body = method.get_function_body ().get ();\n+    HIR::BlockExpr *function_body = function.get_definition ().get ();\n     Location start_location = function_body->get_locus ();\n     Location end_location = function_body->get_closing_locus ();\n \n@@ -407,7 +243,7 @@ class CompileInherentImplItem : public HIRCompileBase\n     ctx->push_block (code_block);\n \n     Bvariable *return_address = nullptr;\n-    if (method.has_function_return_type ())\n+    if (function.has_function_return_type ())\n       {\n \tBtype *return_type = TyTyResolveCompile::compile (ctx, tyret);\n \n@@ -416,21 +252,21 @@ class CompileInherentImplItem : public HIRCompileBase\n \n \treturn_address = ctx->get_backend ()->temporary_variable (\n \t  fndecl, code_block, return_type, NULL, address_is_taken,\n-\t  method.get_locus (), &ret_var_stmt);\n+\t  function.get_locus (), &ret_var_stmt);\n \n \tctx->add_statement (ret_var_stmt);\n       }\n \n     ctx->push_fn (fndecl, return_address);\n \n-    compile_function_body (fndecl, method.get_function_body (),\n-\t\t\t   method.has_function_return_type ());\n+    compile_function_body (fndecl, function.get_definition (),\n+\t\t\t   function.has_function_return_type ());\n \n     ctx->pop_block ();\n     auto body = ctx->get_backend ()->block_statement (code_block);\n     if (!ctx->get_backend ()->function_set_body (fndecl, body))\n       {\n-\trust_error_at (method.get_locus (), \"failed to set body to function\");\n+\trust_error_at (function.get_locus (), \"failed to set body to function\");\n \treturn;\n       }\n "}, {"sha": "16c5aa043b4d326209f9d8c47cadea76b97dc6c9", "filename": "gcc/rust/hir/rust-ast-lower-implitem.h", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/458f7a5459a8907fa55a84248ba137281ac675c4/gcc%2Frust%2Fhir%2Frust-ast-lower-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/458f7a5459a8907fa55a84248ba137281ac675c4/gcc%2Frust%2Fhir%2Frust-ast-lower-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-implitem.h?ref=458f7a5459a8907fa55a84248ba137281ac675c4", "patch": "@@ -142,7 +142,8 @@ class ASTLowerImplItem : public ASTLoweringBase\n \t\t\t   std::move (qualifiers), std::move (generic_params),\n \t\t\t   std::move (function_params), std::move (return_type),\n \t\t\t   std::move (where_clause), std::move (function_body),\n-\t\t\t   std::move (vis), function.get_outer_attrs (), locus);\n+\t\t\t   std::move (vis), function.get_outer_attrs (),\n+\t\t\t   HIR::SelfParam::error (), locus);\n \n     mappings->insert_hir_implitem (mapping.get_crate_num (),\n \t\t\t\t   mapping.get_hirid (), parent_impl_id, fn);\n@@ -217,12 +218,12 @@ class ASTLowerImplItem : public ASTLoweringBase\n \t\t\t\t   mappings->get_next_hir_id (crate_num),\n \t\t\t\t   mappings->get_next_localdef_id (crate_num));\n     auto mth\n-      = new HIR::Method (mapping, std::move (method_name),\n-\t\t\t std::move (qualifiers), std::move (generic_params),\n-\t\t\t std::move (self_param), std::move (function_params),\n-\t\t\t std::move (return_type), std::move (where_clause),\n-\t\t\t std::move (method_body), std::move (vis),\n-\t\t\t method.get_outer_attrs (), locus);\n+      = new HIR::Function (mapping, std::move (method_name),\n+\t\t\t   std::move (qualifiers), std::move (generic_params),\n+\t\t\t   std::move (function_params), std::move (return_type),\n+\t\t\t   std::move (where_clause), std::move (method_body),\n+\t\t\t   std::move (vis), method.get_outer_attrs (),\n+\t\t\t   std::move (self_param), locus);\n \n     mappings->insert_hir_implitem (mapping.get_crate_num (),\n \t\t\t\t   mapping.get_hirid (), parent_impl_id, mth);"}, {"sha": "b2a4d5fa9c814c87320e845121890a0a61d2e59b", "filename": "gcc/rust/hir/rust-ast-lower-item.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/458f7a5459a8907fa55a84248ba137281ac675c4/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/458f7a5459a8907fa55a84248ba137281ac675c4/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h?ref=458f7a5459a8907fa55a84248ba137281ac675c4", "patch": "@@ -308,7 +308,8 @@ class ASTLoweringItem : public ASTLoweringBase\n \t\t\t   std::move (qualifiers), std::move (generic_params),\n \t\t\t   std::move (function_params), std::move (return_type),\n \t\t\t   std::move (where_clause), std::move (function_body),\n-\t\t\t   std::move (vis), function.get_outer_attrs (), locus);\n+\t\t\t   std::move (vis), function.get_outer_attrs (),\n+\t\t\t   HIR::SelfParam::error (), locus);\n \n     mappings->insert_defid_mapping (mapping.get_defid (), translated);\n     mappings->insert_hir_item (mapping.get_crate_num (), mapping.get_hirid (),"}, {"sha": "771c3adcf1f86e3ebe7ae995c5496e2e4911212e", "filename": "gcc/rust/hir/rust-ast-lower-stmt.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/458f7a5459a8907fa55a84248ba137281ac675c4/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/458f7a5459a8907fa55a84248ba137281ac675c4/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.h?ref=458f7a5459a8907fa55a84248ba137281ac675c4", "patch": "@@ -294,7 +294,8 @@ class ASTLoweringStmt : public ASTLoweringBase\n \t\t\t   std::move (qualifiers), std::move (generic_params),\n \t\t\t   std::move (function_params), std::move (return_type),\n \t\t\t   std::move (where_clause), std::move (function_body),\n-\t\t\t   std::move (vis), function.get_outer_attrs (), locus);\n+\t\t\t   std::move (vis), function.get_outer_attrs (),\n+\t\t\t   HIR::SelfParam::error (), locus);\n \n     mappings->insert_hir_item (mapping.get_crate_num (), mapping.get_hirid (),\n \t\t\t       fn);"}, {"sha": "58a110e6359a909981bcd85d45ce6da6ab5036e5", "filename": "gcc/rust/hir/tree/rust-hir-full-decls.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/458f7a5459a8907fa55a84248ba137281ac675c4/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-decls.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/458f7a5459a8907fa55a84248ba137281ac675c4/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-decls.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-decls.h?ref=458f7a5459a8907fa55a84248ba137281ac675c4", "patch": "@@ -160,7 +160,6 @@ struct SelfParam;\n struct FunctionQualifiers;\n struct FunctionParam;\n struct Visibility;\n-class Method;\n class VisItem;\n class Module;\n class ModuleBodied;"}, {"sha": "261b3af672aa5860d56b39e9622ffb4374c0a9e5", "filename": "gcc/rust/hir/tree/rust-hir-full-test.cc", "status": "modified", "additions": 0, "deletions": 79, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/458f7a5459a8907fa55a84248ba137281ac675c4/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/458f7a5459a8907fa55a84248ba137281ac675c4/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc?ref=458f7a5459a8907fa55a84248ba137281ac675c4", "patch": "@@ -450,79 +450,6 @@ ImplBlock::as_string () const\n   return str;\n }\n \n-std::string\n-Method::as_string () const\n-{\n-  std::string str (\"Method: \\n \");\n-\n-  str += vis.as_string () + \" \" + qualifiers.as_string ();\n-\n-  str += \" fn \" + method_name;\n-\n-  // generic params\n-  str += \"\\n Generic params: \";\n-  if (generic_params.empty ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      for (const auto &param : generic_params)\n-\t{\n-\t  // DEBUG: null pointer check\n-\t  if (param == nullptr)\n-\t    {\n-\t      rust_debug (\n-\t\t\"something really terrible has gone wrong - null pointer \"\n-\t\t\"generic param in method.\");\n-\t      return \"nullptr_POINTER_MARK\";\n-\t    }\n-\n-\t  str += \"\\n  \" + param->as_string ();\n-\t}\n-    }\n-\n-  str += \"\\n Self param: \" + self_param.as_string ();\n-\n-  str += \"\\n Function params: \";\n-  if (function_params.empty ())\n-    {\n-      str += \"none\";\n-    }\n-  else\n-    {\n-      for (const auto &param : function_params)\n-\t{\n-\t  str += \"\\n  \" + param.as_string ();\n-\t}\n-    }\n-\n-  str += \"\\n Return type: \";\n-  if (has_return_type ())\n-    {\n-      str += return_type->as_string ();\n-    }\n-  else\n-    {\n-      str += \"none (void)\";\n-    }\n-\n-  str += \"\\n Where clause: \";\n-  if (has_where_clause ())\n-    {\n-      str += where_clause.as_string ();\n-    }\n-  else\n-    {\n-      str += \"none\";\n-    }\n-\n-  str += \"\\n Block expr (body): \\n  \";\n-  str += function_body->as_string ();\n-\n-  return str;\n-}\n-\n std::string\n StructStruct::as_string () const\n {\n@@ -4360,12 +4287,6 @@ TypeBoundWhereClauseItem::accept_vis (HIRVisitor &vis)\n   vis.visit (*this);\n }\n \n-void\n-Method::accept_vis (HIRVisitor &vis)\n-{\n-  vis.visit (*this);\n-}\n-\n void\n ModuleBodied::accept_vis (HIRVisitor &vis)\n {"}, {"sha": "a5069b7f044a8d3674a8b688a33f6b44c421fd34", "filename": "gcc/rust/hir/tree/rust-hir-item.h", "status": "modified", "additions": 30, "deletions": 230, "changes": 260, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/458f7a5459a8907fa55a84248ba137281ac675c4/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/458f7a5459a8907fa55a84248ba137281ac675c4/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h?ref=458f7a5459a8907fa55a84248ba137281ac675c4", "patch": "@@ -385,7 +385,7 @@ struct SelfParam\n   bool has_lifetime () const { return !lifetime.is_error (); }\n \n   // Returns whether the self-param is in an error state.\n-  bool is_error () const { return self_kind != ImplicitSelfKind::NONE; }\n+  bool is_error () const { return self_kind == ImplicitSelfKind::NONE; }\n \n   std::string as_string () const;\n \n@@ -592,192 +592,6 @@ struct Visibility\n   }\n };\n \n-// A method (function belonging to a type)\n-class Method : public ImplItem\n-{\n-  Analysis::NodeMapping mappings;\n-\n-  // moved from impl items for consistency\n-  AST::AttrVec outer_attrs;\n-  Visibility vis;\n-\n-  FunctionQualifiers qualifiers;\n-  Identifier method_name;\n-\n-  // bool has_generics;\n-  // Generics generic_params;\n-  std::vector<std::unique_ptr<GenericParam> > generic_params; // inlined\n-\n-  SelfParam self_param;\n-\n-  // bool has_params;\n-  // FunctionParams function_params;\n-  std::vector<FunctionParam> function_params; // inlined\n-\n-  // bool has_return_type;\n-  // FunctionReturnType return_type;\n-  std::unique_ptr<Type> return_type; // inlined\n-\n-  // bool has_where_clause;\n-  WhereClause where_clause;\n-\n-  std::unique_ptr<BlockExpr> function_body;\n-\n-  Location locus;\n-\n-public:\n-  // Returns whether the method has generic parameters.\n-  bool has_generics () const { return !generic_params.empty (); }\n-\n-  // Returns whether the method has parameters.\n-  bool has_params () const { return !function_params.empty (); }\n-\n-  // Returns whether the method has a return type (void otherwise).\n-  bool has_return_type () const { return return_type != nullptr; }\n-\n-  // Returns whether the where clause exists (i.e. has items)\n-  bool has_where_clause () const { return !where_clause.is_empty (); }\n-\n-  // Returns whether method has a non-default visibility.\n-  bool has_visibility () const { return !vis.is_error (); }\n-\n-  // Mega-constructor with all possible fields\n-  Method (Analysis::NodeMapping mappings, Identifier method_name,\n-\t  FunctionQualifiers qualifiers,\n-\t  std::vector<std::unique_ptr<GenericParam> > generic_params,\n-\t  SelfParam self_param, std::vector<FunctionParam> function_params,\n-\t  std::unique_ptr<Type> return_type, WhereClause where_clause,\n-\t  std::unique_ptr<BlockExpr> function_body, Visibility vis,\n-\t  AST::AttrVec outer_attrs, Location locus = Location ())\n-    : mappings (mappings), outer_attrs (std::move (outer_attrs)),\n-      vis (std::move (vis)), qualifiers (std::move (qualifiers)),\n-      method_name (std::move (method_name)),\n-      generic_params (std::move (generic_params)),\n-      self_param (std::move (self_param)),\n-      function_params (std::move (function_params)),\n-      return_type (std::move (return_type)),\n-      where_clause (std::move (where_clause)),\n-      function_body (std::move (function_body)), locus (locus)\n-  {}\n-\n-  // TODO: add constructor with less fields\n-\n-  // Copy constructor with clone\n-  Method (Method const &other)\n-    : mappings (other.mappings), outer_attrs (other.outer_attrs),\n-      vis (other.vis), qualifiers (other.qualifiers),\n-      method_name (other.method_name), self_param (other.self_param),\n-      function_params (other.function_params),\n-      return_type (other.return_type->clone_type ()),\n-      where_clause (other.where_clause),\n-      function_body (other.function_body->clone_block_expr ()),\n-      locus (other.locus)\n-  {\n-    generic_params.reserve (other.generic_params.size ());\n-    for (const auto &e : other.generic_params)\n-      generic_params.push_back (e->clone_generic_param ());\n-  }\n-\n-  // Overloaded assignment operator to clone\n-  Method &operator= (Method const &other)\n-  {\n-    mappings = other.mappings;\n-    method_name = other.method_name;\n-    outer_attrs = other.outer_attrs;\n-    vis = other.vis;\n-    qualifiers = other.qualifiers;\n-    self_param = other.self_param;\n-    function_params = other.function_params;\n-    return_type = other.return_type->clone_type ();\n-    where_clause = other.where_clause;\n-    function_body = other.function_body->clone_block_expr ();\n-    locus = other.locus;\n-\n-    generic_params.reserve (other.generic_params.size ());\n-    for (const auto &e : other.generic_params)\n-      generic_params.push_back (e->clone_generic_param ());\n-\n-    return *this;\n-  }\n-\n-  // move constructors\n-  Method (Method &&other) = default;\n-  Method &operator= (Method &&other) = default;\n-\n-  std::string as_string () const override;\n-\n-  void accept_vis (HIRVisitor &vis) override;\n-\n-  Analysis::NodeMapping get_mappings () const { return mappings; };\n-\n-  Analysis::NodeMapping get_impl_mappings () const override\n-  {\n-    return get_mappings ();\n-  };\n-\n-  // Returns whether function has return type - if not, it is void.\n-  bool has_function_return_type () const { return return_type != nullptr; }\n-\n-  std::vector<FunctionParam> &get_function_params () { return function_params; }\n-  const std::vector<FunctionParam> &get_function_params () const\n-  {\n-    return function_params;\n-  }\n-\n-  std::vector<std::unique_ptr<GenericParam> > &get_generic_params ()\n-  {\n-    return generic_params;\n-  }\n-  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const\n-  {\n-    return generic_params;\n-  }\n-\n-  // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<BlockExpr> &get_definition ()\n-  {\n-    rust_assert (function_body != nullptr);\n-    return function_body;\n-  }\n-\n-  SelfParam &get_self_param () { return self_param; }\n-  const SelfParam &get_self_param () const { return self_param; }\n-\n-  // TODO: is this better? Or is a \"vis_block\" better?\n-  std::unique_ptr<Type> &get_return_type ()\n-  {\n-    rust_assert (has_return_type ());\n-    return return_type;\n-  }\n-\n-  // TODO: is this better? Or is a \"vis_block\" better?\n-  WhereClause &get_where_clause ()\n-  {\n-    rust_assert (has_where_clause ());\n-    return where_clause;\n-  }\n-\n-  Identifier get_method_name () const { return method_name; }\n-\n-  Location get_locus () const { return locus; }\n-\n-  Location get_impl_locus () const final { return get_locus (); }\n-\n-  std::unique_ptr<BlockExpr> &get_function_body () { return function_body; }\n-  const std::unique_ptr<BlockExpr> &get_function_body () const\n-  {\n-    return function_body;\n-  }\n-\n-protected:\n-  /* Use covariance to implement clone function as returning this object\n-   * rather than base */\n-  Method *clone_inherent_impl_item_impl () const override\n-  {\n-    return new Method (*this);\n-  }\n-};\n-\n // Item that supports visibility - abstract base class\n class VisItem : public Item\n {\n@@ -1267,35 +1081,19 @@ class UseDeclaration : public VisItem\n   }*/\n };\n \n-// Parameters used in a function - TODO inline?\n-/*struct FunctionParams {\n-    std::vector<FunctionParam> function_params;\n-};*/\n-\n class LetStmt;\n \n // Rust function declaration HIR node\n class Function : public VisItem, public ImplItem\n {\n   FunctionQualifiers qualifiers;\n   Identifier function_name;\n-\n-  // bool has_generics;\n-  // Generics generic_params;\n-  std::vector<std::unique_ptr<GenericParam> > generic_params; // inlined\n-\n-  // bool has_function_params;\n-  // FunctionParams function_params;\n-  std::vector<FunctionParam> function_params; // inlined\n-\n-  // bool has_function_return_type;\n+  std::vector<std::unique_ptr<GenericParam> > generic_params;\n+  std::vector<FunctionParam> function_params;\n   std::unique_ptr<Type> return_type;\n-\n-  // bool has_where_clause;\n   WhereClause where_clause;\n-\n   std::unique_ptr<BlockExpr> function_body;\n-\n+  SelfParam self;\n   Location locus;\n \n public:\n@@ -1320,19 +1118,18 @@ class Function : public VisItem, public ImplItem\n \t    std::vector<FunctionParam> function_params,\n \t    std::unique_ptr<Type> return_type, WhereClause where_clause,\n \t    std::unique_ptr<BlockExpr> function_body, Visibility vis,\n-\t    AST::AttrVec outer_attrs, Location locus)\n+\t    AST::AttrVec outer_attrs, SelfParam self, Location locus)\n     : VisItem (std::move (mappings), std::move (vis), std::move (outer_attrs)),\n       qualifiers (std::move (qualifiers)),\n       function_name (std::move (function_name)),\n       generic_params (std::move (generic_params)),\n       function_params (std::move (function_params)),\n       return_type (std::move (return_type)),\n       where_clause (std::move (where_clause)),\n-      function_body (std::move (function_body)), locus (locus)\n+      function_body (std::move (function_body)), self (std::move (self)),\n+      locus (locus)\n   {}\n \n-  // TODO: add constructor with less fields\n-\n   // Copy constructor with clone\n   Function (Function const &other)\n     : VisItem (other), qualifiers (other.qualifiers),\n@@ -1341,7 +1138,7 @@ class Function : public VisItem, public ImplItem\n       return_type (other.return_type->clone_type ()),\n       where_clause (other.where_clause),\n       function_body (other.function_body->clone_block_expr ()),\n-      locus (other.locus)\n+      self (other.self), locus (other.locus)\n   {\n     generic_params.reserve (other.generic_params.size ());\n     for (const auto &e : other.generic_params)\n@@ -1354,14 +1151,12 @@ class Function : public VisItem, public ImplItem\n     VisItem::operator= (other);\n     function_name = other.function_name;\n     qualifiers = other.qualifiers;\n-    // generic_params = other.generic_params;\n     function_params = other.function_params;\n     return_type = other.return_type->clone_type ();\n     where_clause = other.where_clause;\n     function_body = other.function_body->clone_block_expr ();\n-    // visibility = other.visibility->clone_visibility();\n-    // outer_attrs = other.outer_attrs;\n     locus = other.locus;\n+    self = other.self;\n \n     generic_params.reserve (other.generic_params.size ());\n     for (const auto &e : other.generic_params)\n@@ -1427,6 +1222,14 @@ class Function : public VisItem, public ImplItem\n     return return_type;\n   }\n \n+  bool is_method () const { return !self.is_error (); }\n+\n+  SelfParam &get_self_param ()\n+  {\n+    rust_assert (is_method ());\n+    return self;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n@@ -2364,7 +2167,7 @@ struct TraitFunctionDecl\n       generic_params (std::move (generic_params)),\n       function_params (std::move (function_params)),\n       return_type (std::move (return_type)),\n-      where_clause (std::move (where_clause)), self (self)\n+      where_clause (std::move (where_clause)), self (std::move (self))\n   {}\n \n   // Copy constructor with clone\n@@ -2661,24 +2464,11 @@ class TraitItemType : public TraitItem\n class Trait : public VisItem\n {\n   bool has_unsafe;\n-\n   Identifier name;\n-\n-  // bool has_generics;\n-  // Generics generic_params;\n-  std::vector<std::unique_ptr<GenericParam> > generic_params; // inlined\n-\n-  // bool has_type_param_bounds;\n-  // TypeParamBounds type_param_bounds;\n-  std::vector<std::unique_ptr<TypeParamBound> >\n-    type_param_bounds; // inlined form\n-\n-  // bool has_where_clause;\n+  std::vector<std::unique_ptr<GenericParam> > generic_params;\n+  std::vector<std::unique_ptr<TypeParamBound> > type_param_bounds;\n   WhereClause where_clause;\n-\n-  // bool has_trait_items;\n   std::vector<std::unique_ptr<TraitItem> > trait_items;\n-\n   Location locus;\n \n public:\n@@ -2768,6 +2558,16 @@ class Trait : public VisItem\n \n   void accept_vis (HIRVisitor &vis) override;\n \n+  std::vector<std::unique_ptr<GenericParam> > &get_generic_params ()\n+  {\n+    return generic_params;\n+  }\n+\n+  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const\n+  {\n+    return generic_params;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */"}, {"sha": "8204a4196fd095dc781562846afc08e02ea7767c", "filename": "gcc/rust/hir/tree/rust-hir-visitor.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/458f7a5459a8907fa55a84248ba137281ac675c4/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-visitor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/458f7a5459a8907fa55a84248ba137281ac675c4/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-visitor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-visitor.h?ref=458f7a5459a8907fa55a84248ba137281ac675c4", "patch": "@@ -102,7 +102,6 @@ class HIRVisitor\n   virtual void visit (TypeParam &param) = 0;\n   virtual void visit (LifetimeWhereClauseItem &item) = 0;\n   virtual void visit (TypeBoundWhereClauseItem &item) = 0;\n-  virtual void visit (Method &method) = 0;\n   virtual void visit (ModuleBodied &module) = 0;\n   virtual void visit (ModuleNoBody &module) = 0;\n   virtual void visit (ExternCrate &crate) = 0;"}, {"sha": "661dfe9e5e8d0b56659f883e3e70f2ba08ec78f7", "filename": "gcc/rust/lint/rust-lint-marklive-base.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/458f7a5459a8907fa55a84248ba137281ac675c4/gcc%2Frust%2Flint%2Frust-lint-marklive-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/458f7a5459a8907fa55a84248ba137281ac675c4/gcc%2Frust%2Flint%2Frust-lint-marklive-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flint%2Frust-lint-marklive-base.h?ref=458f7a5459a8907fa55a84248ba137281ac675c4", "patch": "@@ -117,7 +117,6 @@ class MarkLiveBase : public HIR::HIRVisitor\n \n   virtual void visit (HIR::LifetimeWhereClauseItem &) override {}\n   virtual void visit (HIR::TypeBoundWhereClauseItem &) override {}\n-  virtual void visit (HIR::Method &) override {}\n   virtual void visit (HIR::ModuleBodied &) override {}\n   virtual void visit (HIR::ModuleNoBody &) override {}\n   virtual void visit (HIR::ExternCrate &) override {}"}, {"sha": "2db52940b589a2ec5854d84040b1ea595f09e257", "filename": "gcc/rust/lint/rust-lint-marklive.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/458f7a5459a8907fa55a84248ba137281ac675c4/gcc%2Frust%2Flint%2Frust-lint-marklive.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/458f7a5459a8907fa55a84248ba137281ac675c4/gcc%2Frust%2Flint%2Frust-lint-marklive.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flint%2Frust-lint-marklive.h?ref=458f7a5459a8907fa55a84248ba137281ac675c4", "patch": "@@ -175,11 +175,6 @@ class MarkLive : public MarkLiveBase\n     expr.visit_rhs (*this);\n   }\n \n-  void visit (HIR::Method &method) override\n-  {\n-    method.get_definition ().get ()->accept_vis (*this);\n-  }\n-\n   void visit (HIR::TraitItemFunc &item) override\n   {\n     item.get_block_expr ()->accept_vis (*this);"}, {"sha": "fafd27ea21714f9704e3a9a9394a72c019244fb5", "filename": "gcc/rust/resolve/rust-ast-resolve-item.h", "status": "modified", "additions": 69, "deletions": 17, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/458f7a5459a8907fa55a84248ba137281ac675c4/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/458f7a5459a8907fa55a84248ba137281ac675c4/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h?ref=458f7a5459a8907fa55a84248ba137281ac675c4", "patch": "@@ -310,16 +310,15 @@ class ResolveItem : public ResolverBase\n     NodeId scope_node_id = trait.get_node_id ();\n     resolver->get_type_scope ().push (scope_node_id);\n \n-    // TODO\n     // we need to inject an implicit self TypeParam here\n-    // see: https://doc.rust-lang.org/reference/items/traits.html\n+    AST::TypeParam *implicit_self\n+      = new AST::TypeParam (\"Self\", trait.get_locus ());\n+    trait.insert_implict_self (\n+      std::unique_ptr<AST::GenericParam> (implicit_self));\n \n-    if (trait.has_generics ())\n+    for (auto &generic : trait.get_generic_params ())\n       {\n-\tfor (auto &generic : trait.get_generic_params ())\n-\t  {\n-\t    ResolveGenericParam::go (generic.get (), trait.get_node_id ());\n-\t  }\n+\tResolveGenericParam::go (generic.get (), trait.get_node_id ());\n       }\n \n     for (auto &item : trait.get_trait_items ())\n@@ -371,21 +370,74 @@ class ResolveItem : public ResolverBase\n     resolver->get_label_scope ().pop ();\n   }\n \n-  void visit (AST::TraitItemMethod &) override\n+  void visit (AST::TraitItemMethod &func) override\n   {\n-    // TODO\n-  }\n+    NodeId scope_node_id = func.get_node_id ();\n+    resolver->get_name_scope ().push (scope_node_id);\n+    resolver->get_type_scope ().push (scope_node_id);\n+    resolver->get_label_scope ().push (scope_node_id);\n+    resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n+    resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n+    resolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n \n-  void visit (AST::TraitItemConst &) override\n-  {\n-    // TODO\n-  }\n+    AST::TraitMethodDecl &function = func.get_trait_method_decl ();\n+    if (function.has_generics ())\n+      {\n+\tfor (auto &generic : function.get_generic_params ())\n+\t  ResolveGenericParam::go (generic.get (), func.get_node_id ());\n+      }\n \n-  void visit (AST::TraitItemType &) override\n-  {\n-    // TODO\n+    if (function.has_return_type ())\n+      ResolveType::go (function.get_return_type ().get (), func.get_node_id ());\n+\n+    // self turns into (self: Self) as a function param\n+    AST::SelfParam &self_param = function.get_self_param ();\n+    AST::IdentifierPattern self_pattern (\n+      self_param.get_node_id (), \"self\", self_param.get_locus (),\n+      self_param.get_has_ref (), self_param.get_is_mut (),\n+      std::unique_ptr<AST::Pattern> (nullptr));\n+\n+    std::vector<std::unique_ptr<AST::TypePathSegment> > segments;\n+    segments.push_back (std::unique_ptr<AST::TypePathSegment> (\n+      new AST::TypePathSegment (\"Self\", false, self_param.get_locus ())));\n+\n+    AST::TypePath self_type_path (std::move (segments),\n+\t\t\t\t  self_param.get_locus ());\n+\n+    ResolveType::go (&self_type_path, self_param.get_node_id ());\n+    PatternDeclaration::go (&self_pattern, self_param.get_node_id ());\n+\n+    resolver->mark_assignment_to_decl (self_pattern.get_node_id (),\n+\t\t\t\t       self_pattern.get_node_id ());\n+\n+    // we make a new scope so the names of parameters are resolved and shadowed\n+    // correctly\n+    for (auto &param : function.get_function_params ())\n+      {\n+\tResolveType::go (param.get_type ().get (), param.get_node_id ());\n+\tPatternDeclaration::go (param.get_pattern ().get (),\n+\t\t\t\tparam.get_node_id ());\n+\n+\t// the mutability checker needs to verify for immutable decls the number\n+\t// of assignments are <1. This marks an implicit assignment\n+\tresolver->mark_assignment_to_decl (param.get_pattern ()->get_node_id (),\n+\t\t\t\t\t   param.get_node_id ());\n+      }\n+\n+    // trait items have an optional body\n+    if (func.has_definition ())\n+      ResolveExpr::go (func.get_definition ().get (), func.get_node_id ());\n+\n+    resolver->get_name_scope ().pop ();\n+    resolver->get_type_scope ().pop ();\n+    resolver->get_label_scope ().pop ();\n   }\n \n+  // TODO\n+  void visit (AST::TraitItemConst &) override { gcc_unreachable (); }\n+\n+  void visit (AST::TraitItemType &) override { gcc_unreachable (); }\n+\n private:\n   ResolveItem () : ResolverBase (UNKNOWN_NODEID) {}\n };"}, {"sha": "19e732494e51d87d0b775ebe07be96e65d3ea0bf", "filename": "gcc/rust/resolve/rust-ast-resolve-type.h", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/458f7a5459a8907fa55a84248ba137281ac675c4/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/458f7a5459a8907fa55a84248ba137281ac675c4/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h?ref=458f7a5459a8907fa55a84248ba137281ac675c4", "patch": "@@ -312,9 +312,7 @@ class ResolveGenericParam : public ResolverBase\n \n     // if it has a type lets resolve it\n     if (param.has_type ())\n-      {\n-\tResolveType::go (param.get_type ().get (), param.get_node_id ());\n-      }\n+      ResolveType::go (param.get_type ().get (), param.get_node_id ());\n \n     // for now lets focus on handling the basics: like struct<T> { a:T, ....}\n     resolver->get_type_scope ().insert (\n@@ -328,11 +326,7 @@ class ResolveGenericParam : public ResolverBase\n   }\n \n private:\n-  ResolveGenericParam (NodeId parent)\n-    : ResolverBase (parent),\n-\n-      ok (false)\n-  {}\n+  ResolveGenericParam (NodeId parent) : ResolverBase (parent), ok (false) {}\n \n   bool ok;\n };"}, {"sha": "5a59e706ec42b64bc8b7b4bf3fe835f6c04fa531", "filename": "gcc/rust/typecheck/rust-hir-const-fold-base.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/458f7a5459a8907fa55a84248ba137281ac675c4/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/458f7a5459a8907fa55a84248ba137281ac675c4/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold-base.h?ref=458f7a5459a8907fa55a84248ba137281ac675c4", "patch": "@@ -120,7 +120,6 @@ class ConstFoldBase : public HIR::HIRVisitor\n \n   virtual void visit (HIR::LifetimeWhereClauseItem &) override {}\n   virtual void visit (HIR::TypeBoundWhereClauseItem &) override {}\n-  virtual void visit (HIR::Method &) override {}\n   virtual void visit (HIR::ModuleBodied &) override {}\n   virtual void visit (HIR::ModuleNoBody &) override {}\n   virtual void visit (HIR::ExternCrate &) override {}"}, {"sha": "47894b1b3542d138332c77667e98fdec4f16e1e5", "filename": "gcc/rust/typecheck/rust-hir-inherent-impl-overlap.h", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/458f7a5459a8907fa55a84248ba137281ac675c4/gcc%2Frust%2Ftypecheck%2Frust-hir-inherent-impl-overlap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/458f7a5459a8907fa55a84248ba137281ac675c4/gcc%2Frust%2Ftypecheck%2Frust-hir-inherent-impl-overlap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-inherent-impl-overlap.h?ref=458f7a5459a8907fa55a84248ba137281ac675c4", "patch": "@@ -37,12 +37,6 @@ class ImplItemToName : public TypeCheckBase\n     return resolver.ok;\n   }\n \n-  void visit (HIR::Method &method) override\n-  {\n-    ok = true;\n-    result.assign (method.get_method_name ());\n-  }\n-\n   void visit (HIR::Function &function) override\n   {\n     ok = true;\n@@ -88,12 +82,6 @@ class GetLocusFromImplItem : public TypeCheckBase\n     locus = function.get_locus ();\n   }\n \n-  void visit (HIR::Method &method) override\n-  {\n-    ok = true;\n-    locus = method.get_locus ();\n-  }\n-\n private:\n   GetLocusFromImplItem (Location &locus)\n     : TypeCheckBase (), ok (false), locus (locus)"}, {"sha": "0e26778d64c17a9f3390199d3dcc886ed528bbe6", "filename": "gcc/rust/typecheck/rust-hir-path-probe.h", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/458f7a5459a8907fa55a84248ba137281ac675c4/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/458f7a5459a8907fa55a84248ba137281ac675c4/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h?ref=458f7a5459a8907fa55a84248ba137281ac675c4", "patch": "@@ -95,21 +95,6 @@ class PathProbeType : public TypeCheckBase\n       }\n   }\n \n-  void visit (HIR::Method &method) override\n-  {\n-    Identifier name = method.get_method_name ();\n-    if (search.as_string ().compare (name) == 0)\n-      {\n-\tHirId tyid = method.get_mappings ().get_hirid ();\n-\tTyTy::BaseType *ty = nullptr;\n-\tbool ok = context->lookup_type (tyid, &ty);\n-\trust_assert (ok);\n-\n-\tPathProbeCandidate candidate{&method, ty};\n-\tcandidates.push_back (std::move (candidate));\n-      }\n-  }\n-\n private:\n   PathProbeType (TyTy::BaseType *receiver, const HIR::PathIdentSegment &query)\n     : TypeCheckBase (), receiver (receiver), search (query)\n@@ -147,11 +132,6 @@ class ReportMultipleCandidateError : private TypeCheckBase\n     r.add_range (function.get_locus ());\n   }\n \n-  void visit (HIR::Method &method) override\n-  {\n-    r.add_range (method.get_locus ());\n-  }\n-\n private:\n   ReportMultipleCandidateError (RichLocation &r) : TypeCheckBase (), r (r) {}\n "}, {"sha": "6d926f7ca03112c9dab66ff495e0b5fdc8af93a6", "filename": "gcc/rust/typecheck/rust-hir-trait-resolve.h", "status": "modified", "additions": 60, "deletions": 9, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/458f7a5459a8907fa55a84248ba137281ac675c4/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/458f7a5459a8907fa55a84248ba137281ac675c4/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h?ref=458f7a5459a8907fa55a84248ba137281ac675c4", "patch": "@@ -33,9 +33,11 @@ class ResolveTraitItemToRef : public TypeCheckBase\n   using Rust::Resolver::TypeCheckBase::visit;\n \n public:\n-  static TraitItemReference Resolve (HIR::TraitItem &item)\n+  static TraitItemReference\n+  Resolve (HIR::TraitItem &item, TyTy::BaseType *self,\n+\t   std::vector<TyTy::SubstitutionParamMapping> substitutions)\n   {\n-    ResolveTraitItemToRef resolver;\n+    ResolveTraitItemToRef resolver (self, substitutions);\n     item.accept_vis (resolver);\n     return resolver.resolved;\n   }\n@@ -89,7 +91,6 @@ class ResolveTraitItemToRef : public TypeCheckBase\n     if (!context->lookup_type (fn.get_mappings ().get_hirid (), &ty))\n       {\n \tHIR::TraitFunctionDecl &function = fn.get_decl ();\n-\tstd::vector<TyTy::SubstitutionParamMapping> substitutions;\n \tif (function.has_generics ())\n \t  {\n \t    for (auto &generic_param : function.get_generic_params ())\n@@ -135,6 +136,21 @@ class ResolveTraitItemToRef : public TypeCheckBase\n \t  }\n \n \tstd::vector<std::pair<HIR::Pattern *, TyTy::BaseType *> > params;\n+\tif (function.is_method ())\n+\t  {\n+\t    // add the synthetic self param at the front, this is a placeholder\n+\t    // for compilation to know parameter names. The types are ignored\n+\t    // but we reuse the HIR identifier pattern which requires it\n+\t    HIR::SelfParam &self_param = function.get_self ();\n+\t    HIR::IdentifierPattern *self_pattern = new HIR::IdentifierPattern (\n+\t      \"self\", self_param.get_locus (), self_param.is_ref (),\n+\t      self_param.is_mut (), std::unique_ptr<HIR::Pattern> (nullptr));\n+\t    context->insert_type (self_param.get_mappings (), self->clone ());\n+\t    params.push_back (\n+\t      std::pair<HIR::Pattern *, TyTy::BaseType *> (self_pattern,\n+\t\t\t\t\t\t\t   self->clone ()));\n+\t  }\n+\n \tfor (auto &param : function.get_function_params ())\n \t  {\n \t    // get the name as well required for later on\n@@ -146,9 +162,9 @@ class ResolveTraitItemToRef : public TypeCheckBase\n \t  }\n \n \tty = new TyTy::FnType (fn.get_mappings ().get_hirid (),\n-\t\t\t       function.get_function_name (), false,\n-\t\t\t       std::move (params), ret_type,\n-\t\t\t       std::move (substitutions));\n+\t\t\t       function.get_function_name (),\n+\t\t\t       function.is_method (), std::move (params),\n+\t\t\t       ret_type, std::move (substitutions));\n \tcontext->insert_type (fn.get_mappings (), ty);\n       }\n \n@@ -163,11 +179,16 @@ class ResolveTraitItemToRef : public TypeCheckBase\n   }\n \n private:\n-  ResolveTraitItemToRef ()\n-    : TypeCheckBase (), resolved (TraitItemReference::error ())\n+  ResolveTraitItemToRef (\n+    TyTy::BaseType *self,\n+    std::vector<TyTy::SubstitutionParamMapping> substitutions)\n+    : TypeCheckBase (), resolved (TraitItemReference::error ()), self (self),\n+      substitutions (substitutions)\n   {}\n \n   TraitItemReference resolved;\n+  TyTy::BaseType *self;\n+  std::vector<TyTy::SubstitutionParamMapping> substitutions;\n };\n \n class TraitResolver : public TypeCheckBase\n@@ -224,11 +245,41 @@ class TraitResolver : public TypeCheckBase\n \treturn tref;\n       }\n \n+    TyTy::BaseType *self = nullptr;\n+    std::vector<TyTy::SubstitutionParamMapping> substitutions;\n+    for (auto &generic_param : trait_reference->get_generic_params ())\n+      {\n+\tswitch (generic_param.get ()->get_kind ())\n+\t  {\n+\t  case HIR::GenericParam::GenericKind::LIFETIME:\n+\t    // Skipping Lifetime completely until better handling.\n+\t    break;\n+\n+\t    case HIR::GenericParam::GenericKind::TYPE: {\n+\t      auto param_type\n+\t\t= TypeResolveGenericParam::Resolve (generic_param.get ());\n+\t      context->insert_type (generic_param->get_mappings (), param_type);\n+\n+\t      auto &typaram = static_cast<HIR::TypeParam &> (*generic_param);\n+\t      substitutions.push_back (\n+\t\tTyTy::SubstitutionParamMapping (typaram, param_type));\n+\n+\t      if (typaram.get_type_representation ().compare (\"Self\") == 0)\n+\t\t{\n+\t\t  self = param_type;\n+\t\t}\n+\t    }\n+\t    break;\n+\t  }\n+      }\n+\n+    rust_assert (self != nullptr);\n+\n     std::vector<TraitItemReference> item_refs;\n     for (auto &item : trait_reference->get_trait_items ())\n       {\n \tTraitItemReference trait_item_ref\n-\t  = ResolveTraitItemToRef::Resolve (*item.get ());\n+\t  = ResolveTraitItemToRef::Resolve (*item.get (), self, substitutions);\n \titem_refs.push_back (std::move (trait_item_ref));\n       }\n "}, {"sha": "ae71611d9535b64daf7ded5969144e7ab8ce892e", "filename": "gcc/rust/typecheck/rust-hir-type-check-base.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/458f7a5459a8907fa55a84248ba137281ac675c4/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/458f7a5459a8907fa55a84248ba137281ac675c4/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h?ref=458f7a5459a8907fa55a84248ba137281ac675c4", "patch": "@@ -119,7 +119,6 @@ class TypeCheckBase : public HIR::HIRVisitor\n \n   virtual void visit (HIR::LifetimeWhereClauseItem &) override {}\n   virtual void visit (HIR::TypeBoundWhereClauseItem &) override {}\n-  virtual void visit (HIR::Method &) override {}\n   virtual void visit (HIR::ModuleBodied &) override {}\n   virtual void visit (HIR::ModuleNoBody &) override {}\n   virtual void visit (HIR::ExternCrate &) override {}"}, {"sha": "d16158654b8acca3ca31ec81b4edefaa1748af74", "filename": "gcc/rust/typecheck/rust-hir-type-check-implitem.h", "status": "modified", "additions": 44, "deletions": 115, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/458f7a5459a8907fa55a84248ba137281ac675c4/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/458f7a5459a8907fa55a84248ba137281ac675c4/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h?ref=458f7a5459a8907fa55a84248ba137281ac675c4", "patch": "@@ -100,87 +100,22 @@ class TypeCheckTopLevelImplItem : public TypeCheckBase\n       }\n \n     std::vector<std::pair<HIR::Pattern *, TyTy::BaseType *> > params;\n-    for (auto &param : function.get_function_params ())\n+    if (function.is_method ())\n       {\n-\t// get the name as well required for later on\n-\tauto param_tyty = TypeCheckType::Resolve (param.get_type ());\n+\t// add the synthetic self param at the front, this is a placeholder for\n+\t// compilation to know parameter names. The types are ignored but we\n+\t// reuse the HIR identifier pattern which requires it\n+\tHIR::SelfParam &self_param = function.get_self_param ();\n+\tHIR::IdentifierPattern *self_pattern = new HIR::IdentifierPattern (\n+\t  \"self\", self_param.get_locus (), self_param.is_ref (),\n+\t  self_param.is_mut (), std::unique_ptr<HIR::Pattern> (nullptr));\n+\tcontext->insert_type (self_param.get_mappings (), self->clone ());\n \tparams.push_back (\n-\t  std::pair<HIR::Pattern *, TyTy::BaseType *> (param.get_param_name (),\n-\t\t\t\t\t\t       param_tyty));\n-\n-\tcontext->insert_type (param.get_mappings (), param_tyty);\n-      }\n-\n-    auto fnType = new TyTy::FnType (function.get_mappings ().get_hirid (),\n-\t\t\t\t    function.get_function_name (), false,\n-\t\t\t\t    std::move (params), ret_type,\n-\t\t\t\t    std::move (substitutions));\n-    context->insert_type (function.get_mappings (), fnType);\n-  }\n-\n-  void visit (HIR::Method &method) override\n-  {\n-    if (method.has_generics ())\n-      {\n-\tfor (auto &generic_param : method.get_generic_params ())\n-\t  {\n-\t    switch (generic_param.get ()->get_kind ())\n-\t      {\n-\t      case HIR::GenericParam::GenericKind::LIFETIME:\n-\t\t// Skipping Lifetime completely until better handling.\n-\t\tbreak;\n-\n-\t\tcase HIR::GenericParam::GenericKind::TYPE: {\n-\t\t  auto param_type\n-\t\t    = TypeResolveGenericParam::Resolve (generic_param.get ());\n-\t\t  context->insert_type (generic_param->get_mappings (),\n-\t\t\t\t\tparam_type);\n-\n-\t\t  substitutions.push_back (TyTy::SubstitutionParamMapping (\n-\t\t    static_cast<HIR::TypeParam &> (*generic_param),\n-\t\t    param_type));\n-\t\t}\n-\t\tbreak;\n-\t      }\n-\t  }\n+\t  std::pair<HIR::Pattern *, TyTy::BaseType *> (self_pattern,\n+\t\t\t\t\t\t       self->clone ()));\n       }\n \n-    TyTy::BaseType *ret_type = nullptr;\n-    if (!method.has_function_return_type ())\n-      ret_type = new TyTy::TupleType (method.get_mappings ().get_hirid ());\n-    else\n-      {\n-\tauto resolved\n-\t  = TypeCheckType::Resolve (method.get_return_type ().get ());\n-\tif (resolved == nullptr)\n-\t  {\n-\t    rust_error_at (method.get_locus (),\n-\t\t\t   \"failed to resolve return type\");\n-\t    return;\n-\t  }\n-\n-\tret_type = resolved->clone ();\n-\tret_type->set_ref (\n-\t  method.get_return_type ()->get_mappings ().get_hirid ());\n-      }\n-\n-    // hold all the params to the fndef\n-    std::vector<std::pair<HIR::Pattern *, TyTy::BaseType *> > params;\n-\n-    // add the synthetic self param at the front, this is a placeholder for\n-    // compilation to know parameter names. The types are ignored but we reuse\n-    // the HIR identifier pattern which requires it\n-    HIR::SelfParam &self_param = method.get_self_param ();\n-    HIR::IdentifierPattern *self_pattern\n-      = new HIR::IdentifierPattern (\"self\", self_param.get_locus (),\n-\t\t\t\t    self_param.is_ref (), self_param.is_mut (),\n-\t\t\t\t    std::unique_ptr<HIR::Pattern> (nullptr));\n-    context->insert_type (self_param.get_mappings (), self->clone ());\n-    params.push_back (\n-      std::pair<HIR::Pattern *, TyTy::BaseType *> (self_pattern,\n-\t\t\t\t\t\t   self->clone ()));\n-\n-    for (auto &param : method.get_function_params ())\n+    for (auto &param : function.get_function_params ())\n       {\n \t// get the name as well required for later on\n \tauto param_tyty = TypeCheckType::Resolve (param.get_type ());\n@@ -191,11 +126,11 @@ class TypeCheckTopLevelImplItem : public TypeCheckBase\n \tcontext->insert_type (param.get_mappings (), param_tyty);\n       }\n \n-    auto fnType\n-      = new TyTy::FnType (method.get_mappings ().get_hirid (),\n-\t\t\t  method.get_method_name (), true, std::move (params),\n-\t\t\t  ret_type, std::move (substitutions));\n-    context->insert_type (method.get_mappings (), fnType);\n+    auto fnType = new TyTy::FnType (function.get_mappings ().get_hirid (),\n+\t\t\t\t    function.get_function_name (),\n+\t\t\t\t    function.is_method (), std::move (params),\n+\t\t\t\t    ret_type, std::move (substitutions));\n+    context->insert_type (function.get_mappings (), fnType);\n   }\n \n private:\n@@ -249,36 +184,6 @@ class TypeCheckImplItem : public TypeCheckBase\n     expected_ret_tyty->unify (block_expr_ty);\n   }\n \n-  void visit (HIR::Method &method) override\n-  {\n-    TyTy::BaseType *lookup;\n-    if (!context->lookup_type (method.get_mappings ().get_hirid (), &lookup))\n-      {\n-\trust_error_at (method.get_locus (), \"failed to lookup function type\");\n-\treturn;\n-      }\n-\n-    if (lookup->get_kind () != TyTy::TypeKind::FNDEF)\n-      {\n-\trust_error_at (method.get_locus (),\n-\t\t       \"found invalid type for function [%s]\",\n-\t\t       lookup->as_string ().c_str ());\n-\treturn;\n-      }\n-\n-    // need to get the return type from this\n-    TyTy::FnType *resolve_fn_type = (TyTy::FnType *) lookup;\n-    auto expected_ret_tyty = resolve_fn_type->get_return_type ();\n-    context->push_return_type (expected_ret_tyty);\n-\n-    auto block_expr_ty\n-      = TypeCheckExpr::Resolve (method.get_definition ().get (), false);\n-\n-    context->pop_return_type ();\n-\n-    expected_ret_tyty->unify (block_expr_ty);\n-  }\n-\n protected:\n   TypeCheckImplItem (TyTy::BaseType *self) : TypeCheckBase (), self (self) {}\n \n@@ -303,8 +208,6 @@ class TypeCheckImplItemWithTrait : public TypeCheckImplItem\n \n   void visit (HIR::TypeAlias &type) override { gcc_unreachable (); }\n \n-  void visit (HIR::Method &method) override { gcc_unreachable (); }\n-\n   void visit (HIR::Function &function) override\n   {\n     TypeCheckImplItem::visit (function);\n@@ -333,8 +236,34 @@ class TypeCheckImplItemWithTrait : public TypeCheckImplItem\n \treturn;\n       }\n \n+    rust_assert (trait_item_ref.get_tyty ()->get_kind ()\n+\t\t == TyTy::TypeKind::FNDEF);\n+    TyTy::FnType *trait_item_fntype\n+      = static_cast<TyTy::FnType *> (trait_item_ref.get_tyty ());\n+\n+    // sets substitute self into the trait_item_ref->tyty\n+    TyTy::SubstitutionParamMapping *self_mapping = nullptr;\n+    for (auto &param_mapping : trait_item_fntype->get_substs ())\n+      {\n+\tconst HIR::TypeParam &type_param = param_mapping.get_generic_param ();\n+\tif (type_param.get_type_representation ().compare (\"Self\") == 0)\n+\t  {\n+\t    self_mapping = &param_mapping;\n+\t    break;\n+\t  }\n+      }\n+    rust_assert (self_mapping != nullptr);\n+\n+    std::vector<TyTy::SubstitutionArg> mappings;\n+    mappings.push_back (TyTy::SubstitutionArg (self_mapping, self));\n+\n+    TyTy::SubstitutionArgumentMappings implicit_self_substs (\n+      mappings, function.get_locus ());\n+    trait_item_fntype\n+      = trait_item_fntype->handle_substitions (implicit_self_substs);\n+\n     // check the types are compatible\n-    if (!trait_item_ref.get_tyty ()->can_eq (fntype))\n+    if (!trait_item_fntype->can_eq (fntype))\n       {\n \tRichLocation r (function.get_locus ());\n \tr.add_range (trait_item_ref.get_locus ());"}, {"sha": "b80372b2a9c1d4a7b82bea06a515f7bc9ed0eb23", "filename": "gcc/rust/typecheck/rust-tycheck-dump.h", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/458f7a5459a8907fa55a84248ba137281ac675c4/gcc%2Frust%2Ftypecheck%2Frust-tycheck-dump.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/458f7a5459a8907fa55a84248ba137281ac675c4/gcc%2Frust%2Ftypecheck%2Frust-tycheck-dump.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tycheck-dump.h?ref=458f7a5459a8907fa55a84248ba137281ac675c4", "patch": "@@ -84,18 +84,6 @@ class TypeResolverDump : public TypeCheckBase\n     dump += indent () + \"}\\n\";\n   }\n \n-  void visit (HIR::Method &method) override\n-  {\n-    dump += indent () + \"fn \" + method.get_method_name () + \" \"\n-\t    + type_string (method.get_mappings ()) + \"\\n\";\n-    dump += indent () + \"{\\n\";\n-\n-    HIR::BlockExpr *function_body = method.get_function_body ().get ();\n-    function_body->accept_vis (*this);\n-\n-    dump += indent () + \"}\\n\";\n-  }\n-\n   void visit (HIR::BlockExpr &expr) override\n   {\n     indentation_level++;"}, {"sha": "438c52b4e8c025cb775d03b45ea0d759d5ccc8e4", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/458f7a5459a8907fa55a84248ba137281ac675c4/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/458f7a5459a8907fa55a84248ba137281ac675c4/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=458f7a5459a8907fa55a84248ba137281ac675c4", "patch": "@@ -468,7 +468,6 @@ class SubstitutionParamMapping\n {\n public:\n   SubstitutionParamMapping (const HIR::TypeParam &generic, ParamType *param)\n-\n     : generic (generic), param (param)\n   {}\n "}, {"sha": "621fcde8745a37877ef87ed579a77014845cbf4c", "filename": "gcc/testsuite/rust/compile/torture/traits3.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/458f7a5459a8907fa55a84248ba137281ac675c4/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits3.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/458f7a5459a8907fa55a84248ba137281ac675c4/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits3.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits3.rs?ref=458f7a5459a8907fa55a84248ba137281ac675c4", "patch": "@@ -0,0 +1,18 @@\n+pub trait Foo {\n+    fn Bar(self) -> i32;\n+    // { dg-warning \"unused name .self.\" \"\" { target *-*-* } .-1 }\n+    // { dg-warning \"unused name .Bar.\" \"\" { target *-*-* } .-2 }\n+}\n+\n+struct Baz;\n+// { dg-warning \"struct is never constructed: .Baz.\" \"\" { target *-*-* } .-1 }\n+\n+impl Foo for Baz {\n+    fn Bar(self) -> i32 {\n+        // { dg-warning \"unused name .self.\" \"\" { target *-*-* } .-1 }\n+        // { dg-warning \"unused name .<Baz as Foo>::Bar.\" \"\" { target *-*-* } .-2 }\n+        123\n+    }\n+}\n+\n+fn main() {}"}]}