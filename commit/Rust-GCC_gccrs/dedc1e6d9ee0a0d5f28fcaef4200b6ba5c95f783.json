{"sha": "dedc1e6d9ee0a0d5f28fcaef4200b6ba5c95f783", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGVkYzFlNmQ5ZWUwYTBkNWYyOGZjYWVmNDIwMGI2YmE1Yzk1Zjc4Mw==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2006-05-23T05:35:21Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2006-05-23T05:35:21Z"}, "message": "simplify-rtx.c (simplify_subreg): Adjust REG_OFFSET for big-endian paradoxical subregs.\n\n* simplify-rtx.c (simplify_subreg): Adjust REG_OFFSET for\nbig-endian paradoxical subregs.\n* var-tracking.c (struct micro_operation_def): Document that,\nfor modify micro operations, insn is the subsequent instruction.\n(var_reg_delete_and_set, var_mem_delete_and_set): Split into...\n(var_reg_set, var_mem_set): ... new functions.\n(add_stores): Record subsequent insn.\n(compute_bb_dataflow): Use new functions for MO_USE.\n(emit_notes_in_bb): Use new functions for MO_USE.  Emit use\nnotes after the insn, and modify notes before the insn known\nto be the subsequent one.\n(vt_initialize): Invert sorting of MO_CLOBBERs and MO_SETs.\n\nFrom-SVN: r114013", "tree": {"sha": "75833789f320d2e562420bdc9a087314652e72bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/75833789f320d2e562420bdc9a087314652e72bd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dedc1e6d9ee0a0d5f28fcaef4200b6ba5c95f783", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dedc1e6d9ee0a0d5f28fcaef4200b6ba5c95f783", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dedc1e6d9ee0a0d5f28fcaef4200b6ba5c95f783", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dedc1e6d9ee0a0d5f28fcaef4200b6ba5c95f783/comments", "author": null, "committer": null, "parents": [{"sha": "546be53558e5305b16b6239c6014d776a3d7a742", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/546be53558e5305b16b6239c6014d776a3d7a742", "html_url": "https://github.com/Rust-GCC/gccrs/commit/546be53558e5305b16b6239c6014d776a3d7a742"}], "stats": {"total": 117, "additions": 98, "deletions": 19}, "files": [{"sha": "18c97a9dd5331054dbd3eb947be8b6a7665b6728", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dedc1e6d9ee0a0d5f28fcaef4200b6ba5c95f783/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dedc1e6d9ee0a0d5f28fcaef4200b6ba5c95f783/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dedc1e6d9ee0a0d5f28fcaef4200b6ba5c95f783", "patch": "@@ -1,3 +1,18 @@\n+2006-05-23  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\t* simplify-rtx.c (simplify_subreg): Adjust REG_OFFSET for\n+\tbig-endian paradoxical subregs.\n+\t* var-tracking.c (struct micro_operation_def): Document that,\n+\tfor modify micro operations, insn is the subsequent instruction.\n+\t(var_reg_delete_and_set, var_mem_delete_and_set): Split into...\n+\t(var_reg_set, var_mem_set): ... new functions.\n+\t(add_stores): Record subsequent insn.\n+\t(compute_bb_dataflow): Use new functions for MO_USE.\n+\t(emit_notes_in_bb): Use new functions for MO_USE.  Emit use\n+\tnotes after the insn, and modify notes before the insn known\n+\tto be the subsequent one.\n+\t(vt_initialize): Invert sorting of MO_CLOBBERs and MO_SETs.\n+\n 2006-05-23  Kazu Hirata  <kazu@codesourcery.com>\n \n \tPR target/27696"}, {"sha": "71993164fb83d80ba92eca622a9d5edbaddfc6a7", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dedc1e6d9ee0a0d5f28fcaef4200b6ba5c95f783/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dedc1e6d9ee0a0d5f28fcaef4200b6ba5c95f783/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=dedc1e6d9ee0a0d5f28fcaef4200b6ba5c95f783", "patch": "@@ -4552,7 +4552,22 @@ simplify_subreg (enum machine_mode outermode, rtx op,\n       if (HARD_REGNO_MODE_OK (final_regno, outermode)\n \t  || ! HARD_REGNO_MODE_OK (regno, innermode))\n \t{\n-\t  rtx x = gen_rtx_REG_offset (op, outermode, final_regno, byte);\n+\t  rtx x;\n+\t  int final_offset = byte;\n+\n+\t  /* Adjust offset for paradoxical subregs.  */\n+\t  if (byte == 0\n+\t      && GET_MODE_SIZE (innermode) < GET_MODE_SIZE (outermode))\n+\t    {\n+\t      int difference = (GET_MODE_SIZE (innermode)\n+\t\t\t\t- GET_MODE_SIZE (outermode));\n+\t      if (WORDS_BIG_ENDIAN)\n+\t\tfinal_offset += (difference / UNITS_PER_WORD) * UNITS_PER_WORD;\n+\t      if (BYTES_BIG_ENDIAN)\n+\t\tfinal_offset += difference % UNITS_PER_WORD;\n+\t    }\n+\n+\t  x = gen_rtx_REG_offset (op, outermode, final_regno, final_offset);\n \n \t  /* Propagate original regno.  We don't have any way to specify\n \t     the offset inside original regno, so do so only for lowpart."}, {"sha": "704d2f5e3cf8444b7349ed9f0b1d3ec7875ab86f", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 67, "deletions": 18, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dedc1e6d9ee0a0d5f28fcaef4200b6ba5c95f783/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dedc1e6d9ee0a0d5f28fcaef4200b6ba5c95f783/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=dedc1e6d9ee0a0d5f28fcaef4200b6ba5c95f783", "patch": "@@ -140,7 +140,11 @@ typedef struct micro_operation_def\n     HOST_WIDE_INT adjust;\n   } u;\n \n-  /* The instruction which the micro operation is in.  */\n+  /* The instruction which the micro operation is in, for MO_USE,\n+     MO_USE_NO_VAR, MO_CALL and MO_ADJUST, or the subsequent\n+     instruction or note in the original flow (before any var-tracking\n+     notes are inserted, to simplify emission of notes), for MO_SET\n+     and MO_CLOBBER.  */\n   rtx insn;\n } micro_operation;\n \n@@ -291,9 +295,11 @@ static void vars_clear (htab_t);\n static variable unshare_variable (dataflow_set *set, variable var);\n static int vars_copy_1 (void **, void *);\n static void vars_copy (htab_t, htab_t);\n+static void var_reg_set (dataflow_set *, rtx);\n static void var_reg_delete_and_set (dataflow_set *, rtx);\n static void var_reg_delete (dataflow_set *, rtx);\n static void var_regno_delete (dataflow_set *, int);\n+static void var_mem_set (dataflow_set *, rtx);\n static void var_mem_delete_and_set (dataflow_set *, rtx);\n static void var_mem_delete (dataflow_set *, rtx);\n \n@@ -792,6 +798,19 @@ vars_copy (htab_t dst, htab_t src)\n   htab_traverse (src, vars_copy_1, dst);\n }\n \n+/* Set the register to contain REG_EXPR (LOC), REG_OFFSET (LOC).  */\n+\n+static void\n+var_reg_set (dataflow_set *set, rtx loc)\n+{\n+  tree decl = REG_EXPR (loc);\n+  HOST_WIDE_INT offset = REG_OFFSET (loc);\n+\n+  if (set->regs[REGNO (loc)] == NULL)\n+    attrs_list_insert (&set->regs[REGNO (loc)], decl, offset, loc);\n+  set_variable_part (set, loc, decl, offset);\n+}\n+\n /* Delete current content of register LOC in dataflow set SET\n    and set the register to contain REG_EXPR (LOC), REG_OFFSET (LOC).  */\n \n@@ -819,9 +838,7 @@ var_reg_delete_and_set (dataflow_set *set, rtx loc)\n \t  nextp = &node->next;\n \t}\n     }\n-  if (set->regs[REGNO (loc)] == NULL)\n-    attrs_list_insert (&set->regs[REGNO (loc)], decl, offset, loc);\n-  set_variable_part (set, loc, decl, offset);\n+  var_reg_set (set, loc);\n }\n \n /* Delete current content of register LOC in dataflow set SET.  */\n@@ -858,19 +875,29 @@ var_regno_delete (dataflow_set *set, int regno)\n   *reg = NULL;\n }\n \n-/* Delete and set the location part of variable MEM_EXPR (LOC)\n-   in dataflow set SET to LOC.\n+/* Set the location part of variable MEM_EXPR (LOC) in dataflow set\n+   SET to LOC.\n    Adjust the address first if it is stack pointer based.  */\n \n static void\n-var_mem_delete_and_set (dataflow_set *set, rtx loc)\n+var_mem_set (dataflow_set *set, rtx loc)\n {\n   tree decl = MEM_EXPR (loc);\n   HOST_WIDE_INT offset = MEM_OFFSET (loc) ? INTVAL (MEM_OFFSET (loc)) : 0;\n \n   set_variable_part (set, loc, decl, offset);\n }\n \n+/* Delete and set the location part of variable MEM_EXPR (LOC)\n+   in dataflow set SET to LOC.\n+   Adjust the address first if it is stack pointer based.  */\n+\n+static void\n+var_mem_delete_and_set (dataflow_set *set, rtx loc)\n+{\n+  var_mem_set (set, loc);\n+}\n+\n /* Delete the location part LOC from dataflow set SET.\n    Adjust the address first if it is stack pointer based.  */\n \n@@ -1547,7 +1574,7 @@ add_stores (rtx loc, rtx expr, void *insn)\n \t\t   && track_expr_p (REG_EXPR (loc)))\n \t\t  ? MO_SET : MO_CLOBBER);\n       mo->u.loc = loc;\n-      mo->insn = (rtx) insn;\n+      mo->insn = NEXT_INSN ((rtx) insn);\n     }\n   else if (MEM_P (loc)\n \t   && MEM_EXPR (loc)\n@@ -1558,7 +1585,7 @@ add_stores (rtx loc, rtx expr, void *insn)\n \n       mo->type = GET_CODE (expr) == CLOBBER ? MO_CLOBBER : MO_SET;\n       mo->u.loc = loc;\n-      mo->insn = (rtx) insn;\n+      mo->insn = NEXT_INSN ((rtx) insn);\n     }\n }\n \n@@ -1589,6 +1616,16 @@ compute_bb_dataflow (basic_block bb)\n \t    break;\n \n \t  case MO_USE:\n+\t    {\n+\t      rtx loc = VTI (bb)->mos[i].u.loc;\n+\n+\t      if (GET_CODE (loc) == REG)\n+\t\tvar_reg_set (out, loc);\n+\t      else if (GET_CODE (loc) == MEM)\n+\t\tvar_mem_set (out, loc);\n+\t    }\n+\t    break;\n+\n \t  case MO_SET:\n \t    {\n \t      rtx loc = VTI (bb)->mos[i].u.loc;\n@@ -2356,6 +2393,18 @@ emit_notes_in_bb (basic_block bb)\n \t    break;\n \n \t  case MO_USE:\n+\t    {\n+\t      rtx loc = VTI (bb)->mos[i].u.loc;\n+\n+\t      if (GET_CODE (loc) == REG)\n+\t\tvar_reg_set (&set, loc);\n+\t      else\n+\t\tvar_mem_set (&set, loc);\n+\n+\t      emit_notes_for_changes (insn, EMIT_NOTE_AFTER_INSN);\n+\t    }\n+\t    break;\n+\n \t  case MO_SET:\n \t    {\n \t      rtx loc = VTI (bb)->mos[i].u.loc;\n@@ -2365,10 +2414,7 @@ emit_notes_in_bb (basic_block bb)\n \t      else\n \t\tvar_mem_delete_and_set (&set, loc);\n \n-\t      if (VTI (bb)->mos[i].type == MO_USE)\n-\t\temit_notes_for_changes (insn, EMIT_NOTE_BEFORE_INSN);\n-\t      else\n-\t\temit_notes_for_changes (insn, EMIT_NOTE_AFTER_INSN);\n+\t      emit_notes_for_changes (insn, EMIT_NOTE_BEFORE_INSN);\n \t    }\n \t    break;\n \n@@ -2383,9 +2429,9 @@ emit_notes_in_bb (basic_block bb)\n \t\tvar_mem_delete (&set, loc);\n \n \t      if (VTI (bb)->mos[i].type == MO_USE_NO_VAR)\n-\t\temit_notes_for_changes (insn, EMIT_NOTE_BEFORE_INSN);\n-\t      else\n \t\temit_notes_for_changes (insn, EMIT_NOTE_AFTER_INSN);\n+\t      else\n+\t\temit_notes_for_changes (insn, EMIT_NOTE_BEFORE_INSN);\n \t    }\n \t    break;\n \n@@ -2598,15 +2644,18 @@ vt_initialize (void)\n \t\t}\n \n \t      n1 = VTI (bb)->n_mos;\n+\t      /* This will record NEXT_INSN (insn), such that we can\n+\t\t insert notes before it without worrying about any\n+\t\t notes that MO_USEs might emit after the insn.  */\n \t      note_stores (PATTERN (insn), add_stores, insn);\n \t      n2 = VTI (bb)->n_mos - 1;\n \n-\t      /* Order the MO_SETs to be before MO_CLOBBERs.  */\n+\t      /* Order the MO_CLOBBERs to be before MO_SETs.  */\n \t      while (n1 < n2)\n \t\t{\n-\t\t  while (n1 < n2 && VTI (bb)->mos[n1].type == MO_SET)\n+\t\t  while (n1 < n2 && VTI (bb)->mos[n1].type == MO_CLOBBER)\n \t\t    n1++;\n-\t\t  while (n1 < n2 && VTI (bb)->mos[n2].type == MO_CLOBBER)\n+\t\t  while (n1 < n2 && VTI (bb)->mos[n2].type == MO_SET)\n \t\t    n2--;\n \t\t  if (n1 < n2)\n \t\t    {"}]}