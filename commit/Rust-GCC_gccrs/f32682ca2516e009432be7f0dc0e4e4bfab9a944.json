{"sha": "f32682ca2516e009432be7f0dc0e4e4bfab9a944", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjMyNjgyY2EyNTE2ZTAwOTQzMmJlN2YwZGMwZTRlNGJmYWI5YTk0NA==", "commit": {"author": {"name": "Diego Novillo", "email": "dnovillo@google.com", "date": "2012-09-11T00:04:13Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2012-09-11T00:04:13Z"}, "message": "Remove unnecessary VEC function overloads.\n\nSeveral VEC member functions that accept an element 'T' used to have\ntwo overloads: one taking 'T', the second taking 'T *'.\n\nThis used to be needed because of the interface dichotomy between\nvectors of objects and vectors of pointers.  In the past, vectors of\npointers would use pass-by-value semantics, but vectors of objects\nwould use pass-by-reference semantics.  This is no longer necessary,\nbut the distinction had remained.\n\nThe main side-effect of this change is some code reduction in code\nthat manipulates vectors of objects.  For instance,\n\n-  struct iterator_use *iuse;\n-\n-  iuse = VEC_safe_push (iterator_use, heap, iterator_uses, NULL);\n-  iuse->iterator = iterator;\n-  iuse->ptr = ptr;\n+  struct iterator_use iuse = {iterator, ptr};\n+  VEC_safe_push (iterator_use, heap, iterator_uses, iuse);\n\nCompile time performance was not affected.\n\nTested on x86_64 and ppc64.\n\nAlso built all-gcc on all targets using VEC routines: arm, bfin, c6x,\nepiphany, ia64, mips, sh, spu, and vms.\n\n2012-09-10  Diego Novillo  <dnovillo@google.com>\n\n\t* vec.h (vec_t::quick_push): Remove overload that accepts 'T *'.\n\tUpdate all users.\n\t(vec_t::safe_push): Likewise.\n\t(vec_t::quick_insert): Likewise.\n\t(vec_t::lower_bound): Likewise.\n\t(vec_t::safe_insert): Likewise.\n\t(vec_t::replace): Change second argument to 'T &'.\n\nFrom-SVN: r191165", "tree": {"sha": "3030f0ec079f1a93f960208e432eb6f275d10a28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3030f0ec079f1a93f960208e432eb6f275d10a28"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f32682ca2516e009432be7f0dc0e4e4bfab9a944", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f32682ca2516e009432be7f0dc0e4e4bfab9a944", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f32682ca2516e009432be7f0dc0e4e4bfab9a944", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f32682ca2516e009432be7f0dc0e4e4bfab9a944/comments", "author": {"login": "dnovillo", "id": 7295335, "node_id": "MDQ6VXNlcjcyOTUzMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/7295335?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dnovillo", "html_url": "https://github.com/dnovillo", "followers_url": "https://api.github.com/users/dnovillo/followers", "following_url": "https://api.github.com/users/dnovillo/following{/other_user}", "gists_url": "https://api.github.com/users/dnovillo/gists{/gist_id}", "starred_url": "https://api.github.com/users/dnovillo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dnovillo/subscriptions", "organizations_url": "https://api.github.com/users/dnovillo/orgs", "repos_url": "https://api.github.com/users/dnovillo/repos", "events_url": "https://api.github.com/users/dnovillo/events{/privacy}", "received_events_url": "https://api.github.com/users/dnovillo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "da4c5b2465322894e6d53cd14128ba21d0ff911b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da4c5b2465322894e6d53cd14128ba21d0ff911b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da4c5b2465322894e6d53cd14128ba21d0ff911b"}], "stats": {"total": 990, "additions": 410, "deletions": 580}, "files": [{"sha": "0bfbcaab39ee72fe4f7bb99ab0bb0e0e5e3725f0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -1,3 +1,13 @@\n+2012-09-10  Diego Novillo  <dnovillo@google.com>\n+\n+\t* vec.h (vec_t::quick_push): Remove overload that accepts 'T *'.\n+\tUpdate all users.\n+\t(vec_t::safe_push): Likewise.\n+\t(vec_t::quick_insert): Likewise.\n+\t(vec_t::lower_bound): Likewise.\n+\t(vec_t::safe_insert): Likewise.\n+\t(vec_t::replace): Change second argument to 'T &'.\n+\n 2012-09-10  Maciej W. Rozycki  <macro@codesourcery.com>\n \n \t* config/rs6000/rs6000.md: Move a splitter next to its insn."}, {"sha": "9e14d8af1bf87be585c726cb2b7455f65311ec29", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -7507,9 +7507,8 @@ build_subst_list (Entity_Id gnat_subtype, Entity_Id gnat_type, bool definition)\n \t\t\t\t    (Node (gnat_value), gnat_subtype,\n \t\t\t\t     get_entity_name (gnat_discrim),\n \t\t\t\t     definition, true, false));\n-\tsubst_pair *s = VEC_safe_push (subst_pair, heap, gnu_list, NULL);\n-\ts->discriminant = gnu_field;\n-\ts->replacement = replacement;\n+\tsubst_pair s = {gnu_field, replacement};\n+\tVEC_safe_push (subst_pair, heap, gnu_list, s);\n       }\n \n   return gnu_list;\n@@ -7541,14 +7540,10 @@ build_variant_list (tree qual_union_type, VEC(subst_pair,heap) *subst_list,\n \t still be accessed.  */\n       if (!integer_zerop (qual))\n \t{\n-\t  variant_desc *v;\n \t  tree variant_type = TREE_TYPE (gnu_field), variant_subpart;\n+\t  variant_desc v = {variant_type, gnu_field, qual, NULL_TREE};\n \n-\t  v = VEC_safe_push (variant_desc, heap, gnu_list, NULL);\n-\t  v->type = variant_type;\n-\t  v->field = gnu_field;\n-\t  v->qual = qual;\n-\t  v->new_type = NULL_TREE;\n+\t  VEC_safe_push (variant_desc, heap, gnu_list, v);\n \n \t  /* Recurse on the variant subpart of the variant, if any.  */\n \t  variant_subpart = get_variant_part (variant_type);"}, {"sha": "d9121c1931e004e5a94bd9895d6120d7631c1002", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -4615,16 +4615,14 @@ convert (tree type, tree expr)\n \n \t  FOR_EACH_CONSTRUCTOR_ELT(e, idx, index, value)\n \t    {\n-\t      constructor_elt *elt;\n \t      /* We expect only simple constructors.  */\n \t      if (!SAME_FIELD_P (index, efield))\n \t\tbreak;\n \t      /* The field must be the same.  */\n \t      if (!SAME_FIELD_P (efield, field))\n \t\tbreak;\n-\t      elt = VEC_quick_push (constructor_elt, v, NULL);\n-\t      elt->index = field;\n-\t      elt->value = convert (TREE_TYPE (field), value);\n+\t      constructor_elt elt = {field, convert (TREE_TYPE (field), value)};\n+\t      VEC_quick_push (constructor_elt, v, elt);\n \n \t      /* If packing has made this field a bitfield and the input\n \t\t value couldn't be emitted statically any more, we need to\n@@ -4690,9 +4688,8 @@ convert (tree type, tree expr)\n \t  v = VEC_alloc (constructor_elt, gc, len);\n \t  FOR_EACH_CONSTRUCTOR_VALUE (e, ix, value)\n \t    {\n-\t      constructor_elt *elt = VEC_quick_push (constructor_elt, v, NULL);\n-\t      elt->index = NULL_TREE;\n-\t      elt->value = value;\n+\t      constructor_elt elt = {NULL_TREE, value};\n+\t      VEC_quick_push (constructor_elt, v, elt);\n \t    }\n \t  expr = copy_node (expr);\n \t  TREE_TYPE (expr) = type;"}, {"sha": "0c6a7442b84735e214adff79574ca721133a4709", "filename": "gcc/alias.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -855,8 +855,8 @@ new_alias_set (void)\n   if (flag_strict_aliasing)\n     {\n       if (alias_sets == 0)\n-\tVEC_safe_push (alias_set_entry, gc, alias_sets, (alias_set_entry) 0);\n-      VEC_safe_push (alias_set_entry, gc, alias_sets, (alias_set_entry) 0);\n+\tVEC_safe_push (alias_set_entry, gc, alias_sets, 0);\n+      VEC_safe_push (alias_set_entry, gc, alias_sets, 0);\n       return VEC_length (alias_set_entry, alias_sets) - 1;\n     }\n   else"}, {"sha": "6de2f1c81fdd4f100b4e331d55b5f9216e5e834a", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -8535,7 +8535,7 @@ parse_optimize_options (tree args, bool attr_p)\n   /* Build up argv vector.  Just in case the string is stored away, use garbage\n      collected strings.  */\n   VEC_truncate (const_char_p, optimize_args, 0);\n-  VEC_safe_push (const_char_p, gc, optimize_args, (const_char_p)NULL);\n+  VEC_safe_push (const_char_p, gc, optimize_args, NULL);\n \n   for (ap = args; ap != NULL_TREE; ap = TREE_CHAIN (ap))\n     {"}, {"sha": "70d8748ece93f0688279c8fbaf9b4c64c3017fdc", "filename": "gcc/c-family/c-pragma.c", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fc-family%2Fc-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fc-family%2Fc-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pragma.c?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -372,10 +372,8 @@ handle_pragma_weak (cpp_reader * ARG_UNUSED (dummy))\n     }\n   else\n     {\n-      pending_weak *pe;\n-      pe = VEC_safe_push (pending_weak, gc, pending_weaks, NULL);\n-      pe->name = name;\n-      pe->value = value;\n+      pending_weak pe = {name, value};\n+      VEC_safe_push (pending_weak, gc, pending_weaks, pe);\n     }\n }\n \n@@ -499,9 +497,8 @@ add_to_renaming_pragma_list (tree oldname, tree newname)\n \treturn;\n       }\n \n-  p = VEC_safe_push (pending_redefinition, gc, pending_redefine_extname, NULL);\n-  p->oldname = oldname;\n-  p->newname = newname;\n+  pending_redefinition e = {oldname, newname};\n+  VEC_safe_push (pending_redefinition, gc, pending_redefine_extname, e);\n }\n \n /* The current prefix set by #pragma extern_prefix.  */\n@@ -1236,14 +1233,14 @@ c_register_pragma_1 (const char *space, const char *name,\n \n       ns_name.space = space;\n       ns_name.name = name;\n-      VEC_safe_push (pragma_ns_name, heap, registered_pp_pragmas, &ns_name);\n+      VEC_safe_push (pragma_ns_name, heap, registered_pp_pragmas, ns_name);\n       id = VEC_length (pragma_ns_name, registered_pp_pragmas);\n       id += PRAGMA_FIRST_EXTERNAL - 1;\n     }\n   else\n     {\n       VEC_safe_push (internal_pragma_handler, heap, registered_pragmas,\n-                     &ihandler);\n+                     ihandler);\n       id = VEC_length (internal_pragma_handler, registered_pragmas);\n       id += PRAGMA_FIRST_EXTERNAL - 1;\n "}, {"sha": "d4c7b1f872e181d52cdc11b6774f8f3e64a1e111", "filename": "gcc/c/c-decl.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.c?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -6437,7 +6437,7 @@ get_parm_info (bool ellipsis, tree expr)\n     {\n       tree decl = b->decl;\n       tree type = TREE_TYPE (decl);\n-      c_arg_tag *tag;\n+      c_arg_tag tag;\n       const char *keyword;\n \n       switch (TREE_CODE (decl))\n@@ -6511,9 +6511,9 @@ get_parm_info (bool ellipsis, tree expr)\n \t\t}\n \t    }\n \n-\t  tag = VEC_safe_push (c_arg_tag, gc, tags, NULL);\n-\t  tag->id = b->id;\n-\t  tag->type = decl;\n+\t  tag.id = b->id;\n+\t  tag.type = decl;\n+\t  VEC_safe_push (c_arg_tag, gc, tags, tag);\n \t  break;\n \n \tcase CONST_DECL:"}, {"sha": "17fc719b49d2ad98b1d1a899ff57fb816f46be52", "filename": "gcc/c/c-tree.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-tree.h?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -142,8 +142,8 @@ DEF_VEC_ALLOC_O (c_expr_t, heap);\n /* Append a new c_expr_t element to V.  */\n #define C_EXPR_APPEND(V, ELEM) \\\n   do { \\\n-    c_expr_t *__elem_p = VEC_safe_push (c_expr_t, gc, V, NULL); \\\n-    *__elem_p = (ELEM); \\\n+    c_expr_t __elem = (ELEM); \\\n+    VEC_safe_push (c_expr_t, gc, V, __elem); \\\n   } while (0)\n \n /* A kind of type specifier.  Note that this information is currently"}, {"sha": "b5fb9c984eec4fa284428c482d2024a5373310e0", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -7709,7 +7709,6 @@ output_init_element (tree value, tree origtype, bool strict_string, tree type,\n \t\t     struct obstack * braced_init_obstack)\n {\n   tree semantic_type = NULL_TREE;\n-  constructor_elt *celt;\n   bool maybe_const = true;\n   bool npc;\n \n@@ -7876,9 +7875,8 @@ output_init_element (tree value, tree origtype, bool strict_string, tree type,\n   /* Otherwise, output this element either to\n      constructor_elements or to the assembler file.  */\n \n-  celt = VEC_safe_push (constructor_elt, gc, constructor_elements, NULL);\n-  celt->index = field;\n-  celt->value = value;\n+  constructor_elt celt = {field, value};\n+  VEC_safe_push (constructor_elt, gc, constructor_elements, celt);\n \n   /* Advance the variable that indicates sequential elements output.  */\n   if (TREE_CODE (constructor_type) == ARRAY_TYPE)"}, {"sha": "7f9df4c161b1946da29c9266be3e9dfde04b8c0f", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -3989,8 +3989,8 @@ mips_multi_start (void)\n static struct mips_multi_member *\n mips_multi_add (void)\n {\n-  return VEC_safe_push (mips_multi_member, heap, mips_multi_members,\n-\t\t\t(struct mips_multi_member *) 0);\n+  mips_multi_member empty;\n+  return VEC_safe_push (mips_multi_member, heap, mips_multi_members, empty);\n }\n \n /* Add a normal insn with the given asm format to the current multi-insn"}, {"sha": "6c8f8278d58c90b94de9c3d6c00069a8747e8dd9", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -9948,11 +9948,9 @@ static GTY(()) VEC(extern_symbol,gc) *extern_symbols;\n void\n pa_hpux_asm_output_external (FILE *file, tree decl, const char *name)\n {\n-  extern_symbol * p = VEC_safe_push (extern_symbol, gc, extern_symbols, NULL);\n-\n   gcc_assert (file == asm_out_file);\n-  p->decl = decl;\n-  p->name = name;\n+  extern_symbol p = {decl, name};\n+  VEC_safe_push (extern_symbol, gc, extern_symbols, p);\n }\n \n /* Output text required at the end of an assembler file."}, {"sha": "58101ab4bfff45e16f7d347ad23b31229725d8f8", "filename": "gcc/config/rs6000/rs6000-c.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-c.c?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -3582,11 +3582,8 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n       vec = VEC_alloc (constructor_elt, gc, size);\n       for(i = 0; i < size; i++)\n \t{\n-\t  constructor_elt *elt;\n-\n-\t  elt = VEC_quick_push (constructor_elt, vec, NULL);\n-\t  elt->index = NULL_TREE;\n-\t  elt->value = arg;\n+\t  constructor_elt elt = {NULL_TREE, arg};\n+\t  VEC_quick_push (constructor_elt, vec, elt);\n \t}\n \treturn build_constructor (type, vec);\n     }"}, {"sha": "a5a3848e58565c0dac6c42bdbb0baed095c478e9", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -24901,11 +24901,8 @@ static void\n add_compiler_branch_island (tree label_name, tree function_name,\n \t\t\t    int line_number)\n {\n-  branch_island *bi = VEC_safe_push (branch_island, gc, branch_islands, NULL);\n-\n-  bi->function_name = function_name;\n-  bi->label_name = label_name;\n-  bi->line_number = line_number;\n+  branch_island bi = {function_name, label_name, line_number};\n+  VEC_safe_push (branch_island, gc, branch_islands, bi);\n }\n \n /* Generate far-jump branch islands for everything recorded in"}, {"sha": "7abcc7e0da857703dc2ac4db1fca85059a0b25c3", "filename": "gcc/cp/class.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -8835,11 +8835,9 @@ add_vcall_offset (tree orig_fn, tree binfo, vtbl_init_data *vid)\n      offset.  */\n   if (vid->binfo == TYPE_BINFO (vid->derived))\n     {\n-      tree_pair_p elt = VEC_safe_push (tree_pair_s, gc,\n-\t\t\t\t       CLASSTYPE_VCALL_INDICES (vid->derived),\n-\t\t\t\t       NULL);\n-      elt->purpose = orig_fn;\n-      elt->value = vid->index;\n+      tree_pair_s elt = {orig_fn, vid->index};\n+      VEC_safe_push (tree_pair_s, gc, CLASSTYPE_VCALL_INDICES (vid->derived),\n+\t\t     elt);\n     }\n \n   /* The next vcall offset will be found at a more negative"}, {"sha": "1f33bf9116f5dbf9e31467f5ee292ad40b8eac11", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -2639,16 +2639,16 @@ tree\n declare_local_label (tree id)\n {\n   tree decl;\n-  cp_label_binding *bind;\n+  cp_label_binding bind;\n \n   /* Add a new entry to the SHADOWED_LABELS list so that when we leave\n      this scope we can restore the old value of IDENTIFIER_TYPE_VALUE.  */\n-  bind = VEC_safe_push (cp_label_binding, gc,\n-\t\t\tcurrent_binding_level->shadowed_labels, NULL);\n-  bind->prev_value = IDENTIFIER_LABEL_VALUE (id);\n+  bind.prev_value = IDENTIFIER_LABEL_VALUE (id);\n \n   decl = make_label_decl (id, /*local_p=*/1);\n-  bind->label = decl;\n+  bind.label = decl;\n+  VEC_safe_push (cp_label_binding, gc, current_binding_level->shadowed_labels,\n+\t\t bind);\n \n   return decl;\n }\n@@ -13782,10 +13782,8 @@ maybe_register_incomplete_var (tree var)\n \t  || (TYPE_LANG_SPECIFIC (inner_type)\n \t      && TYPE_BEING_DEFINED (inner_type)))\n \t{\n-\t  incomplete_var *iv\n-\t    = VEC_safe_push (incomplete_var, gc, incomplete_vars, NULL);\n-\t  iv->decl = var;\n-\t  iv->incomplete_type = inner_type;\n+\t  incomplete_var iv = {var, inner_type};\n+\t  VEC_safe_push (incomplete_var, gc, incomplete_vars, iv);\n \t}\n     }\n }"}, {"sha": "da3441856e28bf9e2e387c9087052d7cea704539", "filename": "gcc/cp/except.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -1249,11 +1249,8 @@ expr_noexcept_p (tree expr, tsubst_flags_t complain)\n \t  if (!DECL_INITIAL (fn))\n \t    {\n \t      /* Not defined yet; check again at EOF.  */\n-\t      pending_noexcept *p\n-\t\t= VEC_safe_push (pending_noexcept, gc,\n-\t\t\t\t pending_noexcept_checks, NULL);\n-\t      p->fn = fn;\n-\t      p->loc = input_location;\n+\t      pending_noexcept p = {fn, input_location};\n+\t      VEC_safe_push (pending_noexcept, gc, pending_noexcept_checks, p);\n \t    }\n \t  else\n \t    maybe_noexcept_warning (fn);"}, {"sha": "23d86d5b1476b502d3b1fdd2aeaed7776de706e4", "filename": "gcc/cp/init.c", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -253,21 +253,21 @@ build_zero_init_1 (tree type, tree nelts, bool static_storage_p,\n \t have an upper bound of -1.  */\n       if (!tree_int_cst_equal (max_index, integer_minus_one_node))\n \t{\n-\t  constructor_elt *ce;\n+\t  constructor_elt ce;\n \n \t  v = VEC_alloc (constructor_elt, gc, 1);\n-\t  ce = VEC_quick_push (constructor_elt, v, NULL);\n \n \t  /* If this is a one element array, we just use a regular init.  */\n \t  if (tree_int_cst_equal (size_zero_node, max_index))\n-\t    ce->index = size_zero_node;\n+\t    ce.index = size_zero_node;\n \t  else\n-\t    ce->index = build2 (RANGE_EXPR, sizetype, size_zero_node,\n+\t    ce.index = build2 (RANGE_EXPR, sizetype, size_zero_node,\n \t\t\t\tmax_index);\n \n-\t  ce->value = build_zero_init_1 (TREE_TYPE (type),\n+\t  ce.value = build_zero_init_1 (TREE_TYPE (type),\n \t\t\t\t\t /*nelts=*/NULL_TREE,\n \t\t\t\t\t static_storage_p, NULL_TREE);\n+\t  VEC_quick_push (constructor_elt, v, ce);\n \t}\n \n       /* Build a constructor to contain the initializations.  */\n@@ -448,28 +448,27 @@ build_value_init_noctor (tree type, tsubst_flags_t complain)\n \t have an upper bound of -1.  */\n       if (!tree_int_cst_equal (max_index, integer_minus_one_node))\n \t{\n-\t  constructor_elt *ce;\n+\t  constructor_elt ce;\n \n \t  v = VEC_alloc (constructor_elt, gc, 1);\n-\t  ce = VEC_quick_push (constructor_elt, v, NULL);\n \n \t  /* If this is a one element array, we just use a regular init.  */\n \t  if (tree_int_cst_equal (size_zero_node, max_index))\n-\t    ce->index = size_zero_node;\n+\t    ce.index = size_zero_node;\n \t  else\n-\t    ce->index = build2 (RANGE_EXPR, sizetype, size_zero_node,\n-\t\t\t\tmax_index);\n+\t    ce.index = build2 (RANGE_EXPR, sizetype, size_zero_node, max_index);\n \n-\t  ce->value = build_value_init (TREE_TYPE (type), complain);\n+\t  ce.value = build_value_init (TREE_TYPE (type), complain);\n+\t  VEC_quick_push (constructor_elt, v, ce);\n \n-\t  if (ce->value == error_mark_node)\n+\t  if (ce.value == error_mark_node)\n \t    return error_mark_node;\n \n \t  /* We shouldn't have gotten here for anything that would need\n \t     non-trivial initialization, and gimplify_init_ctor_preeval\n \t     would need to be fixed to allow it.  */\n-\t  gcc_assert (TREE_CODE (ce->value) != TARGET_EXPR\n-\t\t      && TREE_CODE (ce->value) != AGGR_INIT_EXPR);\n+\t  gcc_assert (TREE_CODE (ce.value) != TARGET_EXPR\n+\t\t      && TREE_CODE (ce.value) != AGGR_INIT_EXPR);\n \t}\n \n       /* Build a constructor to contain the initializations.  */"}, {"sha": "e4e982764c389029eb7b26e068158de4a9a6cd04", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -318,13 +318,9 @@ cxx_binding_free (cxx_binding *binding)\n static cxx_binding *\n new_class_binding (tree name, tree value, tree type, cp_binding_level *scope)\n {\n-  cp_class_binding *cb;\n-  cxx_binding *binding;\n-\n-    cb = VEC_safe_push (cp_class_binding, gc, scope->class_shadowed, NULL);\n-\n-  cb->identifier = name;\n-  cb->base = binding = cxx_binding_make (value, type);\n+  cp_class_binding cb = {cxx_binding_make (value, type), name};\n+  cxx_binding *binding = cb.base;\n+  VEC_safe_push (cp_class_binding, gc, scope->class_shadowed, cb);\n   binding->scope = scope;\n   return binding;\n }\n@@ -5884,16 +5880,16 @@ store_binding_p (tree id)\n static void\n store_binding (tree id, VEC(cxx_saved_binding,gc) **old_bindings)\n {\n-  cxx_saved_binding *saved;\n+  cxx_saved_binding saved;\n \n   gcc_checking_assert (store_binding_p (id));\n \n   IDENTIFIER_MARKED (id) = 1;\n \n-  saved = VEC_quick_push (cxx_saved_binding, *old_bindings, NULL);\n-  saved->identifier = id;\n-  saved->binding = IDENTIFIER_BINDING (id);\n-  saved->real_type_value = REAL_IDENTIFIER_TYPE_VALUE (id);\n+  saved.identifier = id;\n+  saved.binding = IDENTIFIER_BINDING (id);\n+  saved.real_type_value = REAL_IDENTIFIER_TYPE_VALUE (id);\n+  VEC_quick_push (cxx_saved_binding, *old_bindings, saved);\n   IDENTIFIER_BINDING (id) = NULL;\n }\n "}, {"sha": "b641e08353372b761ab9f8266c21d4904331cd4d", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -590,13 +590,13 @@ cp_lexer_new_main (void)\n   lexer = cp_lexer_alloc ();\n \n   /* Put the first token in the buffer.  */\n-  VEC_quick_push (cp_token, lexer->buffer, &token);\n+  VEC_quick_push (cp_token, lexer->buffer, token);\n \n   /* Get the remaining tokens from the preprocessor.  */\n   while (token.type != CPP_EOF)\n     {\n       cp_lexer_get_preprocessor_token (lexer, &token);\n-      VEC_safe_push (cp_token, gc, lexer->buffer, &token);\n+      VEC_safe_push (cp_token, gc, lexer->buffer, token);\n     }\n \n   lexer->last_token = VEC_address (cp_token, lexer->buffer)\n@@ -1731,11 +1731,8 @@ cp_parser_context_new (cp_parser_context* next)\n static void\n push_unparsed_function_queues (cp_parser *parser)\n {\n-  VEC_safe_push (cp_unparsed_functions_entry, gc,\n-\t\t parser->unparsed_queues, NULL);\n-  unparsed_funs_with_default_args = NULL;\n-  unparsed_funs_with_definitions = make_tree_vector ();\n-  unparsed_nsdmis = NULL;\n+  cp_unparsed_functions_entry e = {NULL, make_tree_vector (), NULL};\n+  VEC_safe_push (cp_unparsed_functions_entry, gc, parser->unparsed_queues, e);\n }\n \n static void\n@@ -8028,7 +8025,7 @@ start_lambda_scope (tree decl)\n     decl = current_function_decl;\n   ti.t = lambda_scope;\n   ti.i = lambda_count;\n-  VEC_safe_push (tree_int, gc, lambda_scope_stack, &ti);\n+  VEC_safe_push (tree_int, gc, lambda_scope_stack, ti);\n   if (lambda_scope != decl)\n     {\n       /* Don't reset the count if we're still in the same function.  */\n@@ -21758,11 +21755,9 @@ cp_parser_save_default_args (cp_parser* parser, tree decl)\n        probe = TREE_CHAIN (probe))\n     if (TREE_PURPOSE (probe))\n       {\n-\tcp_default_arg_entry *entry\n-\t  = VEC_safe_push (cp_default_arg_entry, gc,\n-\t\t\t   unparsed_funs_with_default_args, NULL);\n-\tentry->class_type = current_class_type;\n-\tentry->decl = decl;\n+\tcp_default_arg_entry entry = {current_class_type, decl};\n+\tVEC_safe_push (cp_default_arg_entry, gc,\n+\t\t       unparsed_funs_with_default_args, entry);\n \tbreak;\n       }\n }"}, {"sha": "768f141accf05605d2a6d969a787d66fc9b8f70d", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -20390,7 +20390,7 @@ append_type_to_template_for_access_check_1 (tree t,\n \n   VEC_safe_push (qualified_typedef_usage_t, gc,\n \t\t TI_TYPEDEFS_NEEDING_ACCESS_CHECKING (ti),\n-\t\t &typedef_usage);\n+\t\t typedef_usage);\n }\n \n /* Append TYPE_DECL to the template TEMPL."}, {"sha": "a6cdfb5688900fd05ec268574671dd800a05c1a4", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -145,11 +145,8 @@ push_deferring_access_checks (deferring_kind deferring)\n     deferred_access_no_check++;\n   else\n     {\n-      deferred_access *ptr;\n-\n-      ptr = VEC_safe_push (deferred_access, gc, deferred_access_stack, NULL);\n-      ptr->deferred_access_checks = NULL;\n-      ptr->deferring_access_checks_kind = deferring;\n+      deferred_access e = {NULL, deferring};\n+      VEC_safe_push (deferred_access, gc, deferred_access_stack, e);\n     }\n }\n \n@@ -243,7 +240,7 @@ pop_to_parent_deferring_access_checks (void)\n \t\t}\n \t      /* Insert into parent's checks.  */\n \t      VEC_safe_push (deferred_access_check, gc,\n-\t\t\t     ptr->deferred_access_checks, chk);\n+\t\t\t     ptr->deferred_access_checks, *chk);\n \t    found:;\n \t    }\n \t}\n@@ -311,7 +308,6 @@ perform_or_defer_access_check (tree binfo, tree decl, tree diag_decl,\n   int i;\n   deferred_access *ptr;\n   deferred_access_check *chk;\n-  deferred_access_check *new_access;\n \n \n   /* Exit if we are in a context that no access checking is performed.\n@@ -341,13 +337,9 @@ perform_or_defer_access_check (tree binfo, tree decl, tree diag_decl,\n \t}\n     }\n   /* If not, record the check.  */\n-  new_access =\n-    VEC_safe_push (deferred_access_check, gc,\n-\t\t   ptr->deferred_access_checks, 0);\n-  new_access->binfo = binfo;\n-  new_access->decl = decl;\n-  new_access->diag_decl = diag_decl;\n-  new_access->loc = input_location;\n+  deferred_access_check new_access = {binfo, decl, diag_decl, input_location};\n+  VEC_safe_push (deferred_access_check, gc, ptr->deferred_access_checks,\n+\t\t new_access);\n \n   return true;\n }"}, {"sha": "355c74698aa39f76a23f43482c109365655209aa", "filename": "gcc/dwarf2cfi.c", "status": "modified", "additions": 28, "deletions": 30, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fdwarf2cfi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fdwarf2cfi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2cfi.c?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -941,10 +941,8 @@ record_reg_saved_in_reg (rtx dest, rtx src)\n   if (dest == NULL)\n     return;\n \n-  elt = VEC_safe_push (reg_saved_in_data, heap,\n-\t\t       cur_trace->regs_saved_in_regs, NULL);\n-  elt->orig_reg = src;\n-  elt->saved_in_reg = dest;\n+  reg_saved_in_data e = {src, dest};\n+  VEC_safe_push (reg_saved_in_data, heap, cur_trace->regs_saved_in_regs, e);\n }\n \n /* Add an entry to QUEUED_REG_SAVES saying that REG is now saved at\n@@ -954,20 +952,19 @@ static void\n queue_reg_save (rtx reg, rtx sreg, HOST_WIDE_INT offset)\n {\n   queued_reg_save *q;\n+  queued_reg_save e = {reg, sreg, offset};\n   size_t i;\n \n   /* Duplicates waste space, but it's also necessary to remove them\n      for correctness, since the queue gets output in reverse order.  */\n   FOR_EACH_VEC_ELT (queued_reg_save, queued_reg_saves, i, q)\n     if (compare_reg_or_pc (q->reg, reg))\n-      goto found;\n-\n-  q = VEC_safe_push (queued_reg_save, heap, queued_reg_saves, NULL);\n+      {\n+\t*q = e;\n+\treturn;\n+      }\n \n- found:\n-  q->reg = reg;\n-  q->saved_reg = sreg;\n-  q->cfa_offset = offset;\n+  VEC_safe_push (queued_reg_save, heap, queued_reg_saves, e);\n }\n \n /* Output all the entries in QUEUED_REG_SAVES.  */\n@@ -2713,23 +2710,23 @@ static void\n create_pseudo_cfg (void)\n {\n   bool saw_barrier, switch_sections;\n-  dw_trace_info *ti;\n+  dw_trace_info ti;\n   rtx insn;\n   unsigned i;\n \n   /* The first trace begins at the start of the function,\n      and begins with the CIE row state.  */\n   trace_info = VEC_alloc (dw_trace_info, heap, 16);\n-  ti = VEC_quick_push (dw_trace_info, trace_info, NULL);\n+  memset (&ti, 0, sizeof (ti));\n+  ti.head = get_insns ();\n+  ti.beg_row = cie_cfi_row;\n+  ti.cfa_store = cie_cfi_row->cfa;\n+  ti.cfa_temp.reg = INVALID_REGNUM;\n+  VEC_quick_push (dw_trace_info, trace_info, ti);\n \n-  memset (ti, 0, sizeof (*ti));\n-  ti->head = get_insns ();\n-  ti->beg_row = cie_cfi_row;\n-  ti->cfa_store = cie_cfi_row->cfa;\n-  ti->cfa_temp.reg = INVALID_REGNUM;\n   if (cie_return_save)\n     VEC_safe_push (reg_saved_in_data, heap,\n-\t\t   ti->regs_saved_in_regs, cie_return_save);\n+\t\t   ti.regs_saved_in_regs, *cie_return_save);\n \n   /* Walk all the insns, collecting start of trace locations.  */\n   saw_barrier = false;\n@@ -2751,11 +2748,11 @@ create_pseudo_cfg (void)\n       else if (save_point_p (insn)\n \t       && (LABEL_P (insn) || !saw_barrier))\n \t{\n-\t  ti = VEC_safe_push (dw_trace_info, heap, trace_info, NULL);\n-\t  memset (ti, 0, sizeof (*ti));\n-\t  ti->head = insn;\n-\t  ti->switch_sections = switch_sections;\n-\t  ti->id = VEC_length (dw_trace_info, trace_info) - 1;\n+\t  memset (&ti, 0, sizeof (ti));\n+\t  ti.head = insn;\n+\t  ti.switch_sections = switch_sections;\n+\t  ti.id = VEC_length (dw_trace_info, trace_info) - 1;\n+\t  VEC_safe_push (dw_trace_info, heap, trace_info, ti);\n \n \t  saw_barrier = false;\n \t  switch_sections = false;\n@@ -2766,19 +2763,20 @@ create_pseudo_cfg (void)\n      avoiding stale pointer problems due to reallocation.  */\n   trace_index = htab_create (VEC_length (dw_trace_info, trace_info),\n \t\t\t     dw_trace_info_hash, dw_trace_info_eq, NULL);\n-  FOR_EACH_VEC_ELT (dw_trace_info, trace_info, i, ti)\n+  dw_trace_info *tp;\n+  FOR_EACH_VEC_ELT (dw_trace_info, trace_info, i, tp)\n     {\n       void **slot;\n \n       if (dump_file)\n \tfprintf (dump_file, \"Creating trace %u : start at %s %d%s\\n\", i,\n-\t\t rtx_name[(int) GET_CODE (ti->head)], INSN_UID (ti->head),\n-\t\t ti->switch_sections ? \" (section switch)\" : \"\");\n+\t\t rtx_name[(int) GET_CODE (tp->head)], INSN_UID (tp->head),\n+\t\t tp->switch_sections ? \" (section switch)\" : \"\");\n \n-      slot = htab_find_slot_with_hash (trace_index, ti,\n-\t\t\t\t       INSN_UID (ti->head), INSERT);\n+      slot = htab_find_slot_with_hash (trace_index, tp,\n+\t\t\t\t       INSN_UID (tp->head), INSERT);\n       gcc_assert (*slot == NULL);\n-      *slot = (void *) ti;\n+      *slot = (void *) tp;\n     }\n }\n "}, {"sha": "61ea948cbb78cbba6fb84352c2f43523ba421a19", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -3484,7 +3484,7 @@ add_dwarf_attr (dw_die_ref die, dw_attr_ref attr)\n \n   if (die->die_attr == NULL)\n     die->die_attr = VEC_alloc (dw_attr_node, gc, 1);\n-  VEC_safe_push (dw_attr_node, gc, die->die_attr, attr);\n+  VEC_safe_push (dw_attr_node, gc, die->die_attr, *attr);\n }\n \n static inline enum dw_val_class\n@@ -8218,7 +8218,7 @@ add_pubname_string (const char *str, dw_die_ref die)\n \n   e.die = die;\n   e.name = xstrdup (str);\n-  VEC_safe_push (pubname_entry, gc, pubname_table, &e);\n+  VEC_safe_push (pubname_entry, gc, pubname_table, e);\n }\n \n static void\n@@ -8252,7 +8252,7 @@ add_enumerator_pubname (const char *scope_name, dw_die_ref die)\n   gcc_assert (scope_name);\n   e.name = concat (scope_name, get_AT_string (die, DW_AT_name), NULL);\n   e.die = die;\n-  VEC_safe_push (pubname_entry, gc, pubname_table, &e);\n+  VEC_safe_push (pubname_entry, gc, pubname_table, e);\n }\n \n /* Add a new entry to .debug_pubtypes if appropriate.  */\n@@ -8295,7 +8295,7 @@ add_pubtype (tree decl, dw_die_ref die)\n         {\n           e.die = die;\n           e.name = concat (scope_name, name, NULL);\n-          VEC_safe_push (pubname_entry, gc, pubtype_table, &e);\n+          VEC_safe_push (pubname_entry, gc, pubtype_table, e);\n         }\n \n       /* Although it might be more consistent to add the pubinfo for the\n@@ -14671,7 +14671,7 @@ defer_location (tree variable, dw_die_ref die)\n   deferred_locations entry;\n   entry.variable = variable;\n   entry.die = die;\n-  VEC_safe_push (deferred_locations, gc, deferred_locations_list, &entry);\n+  VEC_safe_push (deferred_locations, gc, deferred_locations_list, entry);\n }\n \n /* Helper function for tree_add_const_value_attribute.  Natively encode\n@@ -19870,7 +19870,7 @@ append_entry_to_tmpl_value_parm_die_table (dw_die_ref die, tree arg)\n   entry.arg = arg;\n   VEC_safe_push (die_arg_entry, gc,\n \t\t tmpl_value_parm_die_table,\n-\t\t &entry);\n+\t\t entry);\n }\n \n /* Return TRUE if T is an instance of generic type, FALSE\n@@ -20256,7 +20256,7 @@ push_dw_line_info_entry (dw_line_info_table *table,\n   dw_line_info_entry e;\n   e.opcode = opcode;\n   e.val = val;\n-  VEC_safe_push (dw_line_info_entry, gc, table->entries, &e);\n+  VEC_safe_push (dw_line_info_entry, gc, table->entries, e);\n }\n \n /* Output a label to mark the beginning of a source code line entry\n@@ -20376,7 +20376,7 @@ dwarf2out_start_source_file (unsigned int lineno, const char *filename)\n       e.code = DW_MACINFO_start_file;\n       e.lineno = lineno;\n       e.info = ggc_strdup (filename);\n-      VEC_safe_push (macinfo_entry, gc, macinfo_table, &e);\n+      VEC_safe_push (macinfo_entry, gc, macinfo_table, e);\n     }\n }\n \n@@ -20395,7 +20395,7 @@ dwarf2out_end_source_file (unsigned int lineno ATTRIBUTE_UNUSED)\n       e.code = DW_MACINFO_end_file;\n       e.lineno = lineno;\n       e.info = NULL;\n-      VEC_safe_push (macinfo_entry, gc, macinfo_table, &e);\n+      VEC_safe_push (macinfo_entry, gc, macinfo_table, e);\n     }\n }\n \n@@ -20417,12 +20417,12 @@ dwarf2out_define (unsigned int lineno ATTRIBUTE_UNUSED,\n \t  e.code = 0;\n \t  e.lineno = 0;\n \t  e.info = NULL;\n-\t  VEC_safe_push (macinfo_entry, gc, macinfo_table, &e);\n+\t  VEC_safe_push (macinfo_entry, gc, macinfo_table, e);\n \t}\n       e.code = DW_MACINFO_define;\n       e.lineno = lineno;\n       e.info = ggc_strdup (buffer);\n-      VEC_safe_push (macinfo_entry, gc, macinfo_table, &e);\n+      VEC_safe_push (macinfo_entry, gc, macinfo_table, e);\n     }\n }\n \n@@ -20444,12 +20444,12 @@ dwarf2out_undef (unsigned int lineno ATTRIBUTE_UNUSED,\n \t  e.code = 0;\n \t  e.lineno = 0;\n \t  e.info = NULL;\n-\t  VEC_safe_push (macinfo_entry, gc, macinfo_table, &e);\n+\t  VEC_safe_push (macinfo_entry, gc, macinfo_table, e);\n \t}\n       e.code = DW_MACINFO_undef;\n       e.lineno = lineno;\n       e.info = ggc_strdup (buffer);\n-      VEC_safe_push (macinfo_entry, gc, macinfo_table, &e);\n+      VEC_safe_push (macinfo_entry, gc, macinfo_table, e);\n     }\n }\n \n@@ -20725,7 +20725,7 @@ output_macinfo (void)\n       switch (ref->code)\n \t{\n \tcase DW_MACINFO_start_file:\n-\t  VEC_safe_push (macinfo_entry, gc, files, ref);\n+\t  VEC_safe_push (macinfo_entry, gc, files, *ref);\n \t  break;\n \tcase DW_MACINFO_end_file:\n \t  if (!VEC_empty (macinfo_entry, files))\n@@ -21364,7 +21364,7 @@ move_linkage_attr (dw_die_ref die)\n   if (ix != VEC_length (dw_attr_node, die->die_attr) - 1)\n     {\n       VEC_pop (dw_attr_node, die->die_attr);\n-      VEC_quick_insert (dw_attr_node, die->die_attr, ix, &linkage);\n+      VEC_quick_insert (dw_attr_node, die->die_attr, ix, linkage);\n     }\n }\n "}, {"sha": "074e89ea534a4897cb6ed3a4c26a37e8c4d7b6a2", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -6004,7 +6004,7 @@ curr_insn_locator (void)\n     {\n       curr_rtl_loc++;\n       VEC_safe_push (int, heap, locations_locators_locs, curr_rtl_loc);\n-      VEC_safe_push (location_t, heap, locations_locators_vals, &curr_location);\n+      VEC_safe_push (location_t, heap, locations_locators_vals, curr_location);\n       last_location = curr_location;\n     }\n   return curr_rtl_loc;"}, {"sha": "9ba7aa8f6c974a0465cd5295fdecf2d9c26da825", "filename": "gcc/except.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -304,8 +304,8 @@ init_eh_for_function (void)\n   cfun->eh = ggc_alloc_cleared_eh_status ();\n \n   /* Make sure zero'th entries are used.  */\n-  VEC_safe_push (eh_region, gc, cfun->eh->region_array, (eh_region) NULL);\n-  VEC_safe_push (eh_landing_pad, gc, cfun->eh->lp_array, (eh_landing_pad) NULL);\n+  VEC_safe_push (eh_region, gc, cfun->eh->region_array, NULL);\n+  VEC_safe_push (eh_landing_pad, gc, cfun->eh->lp_array, NULL);\n }\n \f\n /* Routines to generate the exception tree somewhat directly.\n@@ -806,7 +806,7 @@ add_ehspec_entry (htab_t ehspec_hash, htab_t ttypes_hash, tree list)\n       if (targetm.arm_eabi_unwinder)\n \tVEC_safe_push (tree, gc, cfun->eh->ehspec_data.arm_eabi, NULL_TREE);\n       else\n-\tVEC_safe_push (uchar, gc, cfun->eh->ehspec_data.other, (uchar) 0);\n+\tVEC_safe_push (uchar, gc, cfun->eh->ehspec_data.other, 0);\n     }\n \n   return n->filter;"}, {"sha": "e843692e0200963043a86fe890e754a7c01c81fd", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -1434,9 +1434,8 @@ gfc_trans_omp_do (gfc_code *code, stmtblock_t *pblock,\n \t  /* Initialize DOVAR.  */\n \t  tmp = fold_build2_loc (input_location, MULT_EXPR, type, count, step);\n \t  tmp = fold_build2_loc (input_location, PLUS_EXPR, type, from, tmp);\n-\t  di = VEC_safe_push (dovar_init, heap, inits, NULL);\n-\t  di->var = dovar;\n-\t  di->init = tmp;\n+\t  dovar_init e = {dovar, tmp};\n+\t  VEC_safe_push (dovar_init, heap, inits, e);\n \t}\n \n       if (!dovar_found)"}, {"sha": "cb571cd6d97397807780e2fe03a8f9bc9dbd49ae", "filename": "gcc/fwprop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Ffwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Ffwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffwprop.c?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -223,7 +223,7 @@ single_def_use_enter_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n   bitmap_copy (local_lr, &lr_bb_info->in);\n \n   /* Push a marker for the leave_block callback.  */\n-  VEC_safe_push (df_ref, heap, reg_defs_stack, (df_ref) NULL);\n+  VEC_safe_push (df_ref, heap, reg_defs_stack, NULL);\n \n   process_uses (df_get_artificial_uses (bb_index), DF_REF_AT_TOP);\n   process_defs (df_get_artificial_defs (bb_index), DF_REF_AT_TOP);"}, {"sha": "af3c34acfebb8ae0e36223cd598239c875c32021", "filename": "gcc/gcc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -2520,7 +2520,7 @@ execute (void)\n      and record info about each one.\n      Also search for the programs that are to be run.  */\n \n-  VEC_safe_push (const_char_p, heap, argbuf, (const_char_p)0);\n+  VEC_safe_push (const_char_p, heap, argbuf, 0);\n \n   commands[0].prog = VEC_index (const_char_p, argbuf, 0); /* first command.  */\n   commands[0].argv = VEC_address (const_char_p, argbuf);"}, {"sha": "a066b36c642abb3bab1a7e7bbae72f533334fb76", "filename": "gcc/gcse.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -1417,7 +1417,7 @@ canon_list_insert (rtx dest ATTRIBUTE_UNUSED, const_rtx x ATTRIBUTE_UNUSED,\n {\n   rtx dest_addr, insn;\n   int bb;\n-  modify_pair *pair;\n+  modify_pair pair;\n \n   while (GET_CODE (dest) == SUBREG\n       || GET_CODE (dest) == ZERO_EXTRACT\n@@ -1436,9 +1436,9 @@ canon_list_insert (rtx dest ATTRIBUTE_UNUSED, const_rtx x ATTRIBUTE_UNUSED,\n   insn = (rtx) v_insn;\n   bb = BLOCK_FOR_INSN (insn)->index;\n \n-  pair = VEC_safe_push (modify_pair, heap, canon_modify_mem_list[bb], NULL);\n-  pair->dest = dest;\n-  pair->dest_addr = dest_addr;\n+  pair.dest = dest;\n+  pair.dest_addr = dest_addr;\n+  VEC_safe_push (modify_pair, heap, canon_modify_mem_list[bb], pair);\n }\n \n /* Record memory modification information for INSN.  We do not actually care"}, {"sha": "46a398d1a6ec64a69758f75279551aec4ed1803a", "filename": "gcc/genautomata.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fgenautomata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fgenautomata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenautomata.c?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -7752,8 +7752,7 @@ output_min_issue_delay_table (automaton_t automaton)\n     = VEC_alloc (vect_el_t, heap, compressed_min_issue_delay_len);\n \n   for (i = 0; i < compressed_min_issue_delay_len; i++)\n-    VEC_quick_push (vect_el_t, compressed_min_issue_delay_vect,\n-\t\t    (vect_el_t) 0);\n+    VEC_quick_push (vect_el_t, compressed_min_issue_delay_vect, 0);\n \n   for (i = 0; i < min_issue_delay_len; i++)\n     {\n@@ -7845,7 +7844,7 @@ output_reserved_units_table (automaton_t automaton)\n   reserved_units_table = VEC_alloc (vect_el_t, heap, reserved_units_size);\n \n   for (i = 0; i < reserved_units_size; i++)\n-    VEC_quick_push (vect_el_t, reserved_units_table, (vect_el_t) 0);\n+    VEC_quick_push (vect_el_t, reserved_units_table, 0);\n   for (n = 0; n < VEC_length (state_t, output_states_vect); n++)\n     {\n       state_t s = VEC_index (state_t, output_states_vect, n);"}, {"sha": "fb1428687cafe2efe84aeeac99842ed3d1f8af73", "filename": "gcc/genextract.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fgenextract.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fgenextract.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenextract.c?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -201,7 +201,7 @@ VEC_safe_set_locstr (VEC(locstr,heap) **vp, unsigned int ix, char *str)\n   else\n     {\n       while (ix > VEC_length (locstr, *vp))\n-\tVEC_safe_push (locstr, heap, *vp, (locstr) NULL);\n+\tVEC_safe_push (locstr, heap, *vp, NULL);\n       VEC_safe_push (locstr, heap, *vp, str);\n     }\n }"}, {"sha": "e0ffc8f286cb17fb915a25f51097eec6e65f4cac", "filename": "gcc/genopinit.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fgenopinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fgenopinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenopinit.c?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -265,7 +265,7 @@ gen_insn (rtx insn)\n \t{\n \t  p.op = optabs[pindex].op;\n \t  p.sort_num = (p.op << 16) | (p.m2 << 8) | p.m1;\n-\t  VEC_safe_push (pattern, heap, patterns, &p);\n+\t  VEC_safe_push (pattern, heap, patterns, p);\n \t  return;\n \t}\n     }"}, {"sha": "c5a16ac52d370003519fb4b0bddd1e82f4963db0", "filename": "gcc/gimple-low.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fgimple-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fgimple-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-low.c?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -851,7 +851,7 @@ lower_gimple_return (gimple_stmt_iterator *gsi, struct lower_data *data)\n   /* Not found.  Create a new label and record the return statement.  */\n   tmp_rs.label = create_artificial_label (cfun->function_end_locus);\n   tmp_rs.stmt = stmt;\n-  VEC_safe_push (return_statements_t, heap, data->return_statements, &tmp_rs);\n+  VEC_safe_push (return_statements_t, heap, data->return_statements, tmp_rs);\n \n   /* Generate a goto statement and remove the return statement.  */\n  found:"}, {"sha": "892c561d6a32c9d149d993827751bb7de24dc066", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 28, "deletions": 19, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -182,21 +182,22 @@ Expression::convert_for_assignment(Translate_context* context, Type* lhs_type,\n \n       VEC(constructor_elt,gc)* init = VEC_alloc(constructor_elt, gc, 3);\n \n-      constructor_elt* elt = VEC_quick_push(constructor_elt, init, NULL);\n+      constructor_elt empty = {NULL, NULL};\n+      constructor_elt* elt = VEC_quick_push(constructor_elt, init, empty);\n       tree field = TYPE_FIELDS(lhs_type_tree);\n       go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)),\n \t\t\t\"__values\") == 0);\n       elt->index = field;\n       elt->value = fold_convert(TREE_TYPE(field), null_pointer_node);\n \n-      elt = VEC_quick_push(constructor_elt, init, NULL);\n+      elt = VEC_quick_push(constructor_elt, init, empty);\n       field = DECL_CHAIN(field);\n       go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)),\n \t\t\t\"__count\") == 0);\n       elt->index = field;\n       elt->value = fold_convert(TREE_TYPE(field), integer_zero_node);\n \n-      elt = VEC_quick_push(constructor_elt, init, NULL);\n+      elt = VEC_quick_push(constructor_elt, init, empty);\n       field = DECL_CHAIN(field);\n       go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)),\n \t\t\t\"__capacity\") == 0);\n@@ -315,15 +316,16 @@ Expression::convert_type_to_interface(Translate_context* context,\n \n   VEC(constructor_elt,gc)* init = VEC_alloc(constructor_elt, gc, 2);\n \n-  constructor_elt* elt = VEC_quick_push(constructor_elt, init, NULL);\n+  constructor_elt empty = {NULL, NULL};\n+  constructor_elt* elt = VEC_quick_push(constructor_elt, init, empty);\n   tree field = TYPE_FIELDS(lhs_type_tree);\n   go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)),\n \t\t    (lhs_is_empty ? \"__type_descriptor\" : \"__methods\")) == 0);\n   elt->index = field;\n   elt->value = fold_convert_loc(location.gcc_location(), TREE_TYPE(field),\n                                 first_field_value);\n \n-  elt = VEC_quick_push(constructor_elt, init, NULL);\n+  elt = VEC_quick_push(constructor_elt, init, empty);\n   field = DECL_CHAIN(field);\n   go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__object\") == 0);\n   elt->index = field;\n@@ -439,7 +441,8 @@ Expression::convert_interface_to_interface(Translate_context* context,\n \n   VEC(constructor_elt,gc)* init = VEC_alloc(constructor_elt, gc, 2);\n \n-  constructor_elt* elt = VEC_quick_push(constructor_elt, init, NULL);\n+  constructor_elt empty = {NULL, NULL};\n+  constructor_elt* elt = VEC_quick_push(constructor_elt, init, empty);\n   tree field = TYPE_FIELDS(lhs_type_tree);\n   elt->index = field;\n \n@@ -502,7 +505,7 @@ Expression::convert_interface_to_interface(Translate_context* context,\n \n   // The second field is simply the object pointer.\n \n-  elt = VEC_quick_push(constructor_elt, init, NULL);\n+  elt = VEC_quick_push(constructor_elt, init, empty);\n   field = DECL_CHAIN(field);\n   go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__object\") == 0);\n   elt->index = field;\n@@ -9959,20 +9962,21 @@ Array_index_expression::do_get_tree(Translate_context* context)\n \n   VEC(constructor_elt,gc)* init = VEC_alloc(constructor_elt, gc, 3);\n \n-  constructor_elt* elt = VEC_quick_push(constructor_elt, init, NULL);\n+  constructor_elt empty = {NULL, NULL};\n+  constructor_elt* elt = VEC_quick_push(constructor_elt, init, empty);\n   tree field = TYPE_FIELDS(struct_tree);\n   go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__values\") == 0);\n   elt->index = field;\n   elt->value = value_pointer;\n \n-  elt = VEC_quick_push(constructor_elt, init, NULL);\n+  elt = VEC_quick_push(constructor_elt, init, empty);\n   field = DECL_CHAIN(field);\n   go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__count\") == 0);\n   elt->index = field;\n   elt->value = fold_convert_loc(loc.gcc_location(), TREE_TYPE(field),\n                                 result_length_tree);\n \n-  elt = VEC_quick_push(constructor_elt, init, NULL);\n+  elt = VEC_quick_push(constructor_elt, init, empty);\n   field = DECL_CHAIN(field);\n   go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__capacity\") == 0);\n   elt->index = field;\n@@ -11355,7 +11359,8 @@ Struct_construction_expression::do_get_tree(Translate_context* context)\n       if (val == error_mark_node || TREE_TYPE(val) == error_mark_node)\n \treturn error_mark_node;\n \n-      constructor_elt* elt = VEC_quick_push(constructor_elt, elts, NULL);\n+      constructor_elt empty = {NULL, NULL};\n+      constructor_elt* elt = VEC_quick_push(constructor_elt, elts, empty);\n       elt->index = field;\n       elt->value = val;\n       if (!TREE_CONSTANT(val))\n@@ -11583,7 +11588,8 @@ Array_construction_expression::get_constructor_tree(Translate_context* context,\n \t{\n \t  if (this->indexes_ != NULL)\n \t    go_assert(pi != this->indexes_->end());\n-\t  constructor_elt* elt = VEC_quick_push(constructor_elt, values, NULL);\n+\t  constructor_elt empty = {NULL, NULL};\n+\t  constructor_elt* elt = VEC_quick_push(constructor_elt, values, empty);\n \n \t  if (this->indexes_ == NULL)\n \t    elt->index = size_int(i);\n@@ -11793,7 +11799,8 @@ Open_array_construction_expression::do_get_tree(Translate_context* context)\n       if (constructor_type == error_mark_node)\n \treturn error_mark_node;\n       VEC(constructor_elt,gc)* vec = VEC_alloc(constructor_elt, gc, 1);\n-      constructor_elt* elt = VEC_quick_push(constructor_elt, vec, NULL);\n+      constructor_elt empty = {NULL, NULL};\n+      constructor_elt* elt = VEC_quick_push(constructor_elt, vec, empty);\n       elt->index = size_int(0);\n       Gogo* gogo = context->gogo();\n       Btype* btype = element_type->get_backend(gogo);\n@@ -11886,19 +11893,20 @@ Open_array_construction_expression::do_get_tree(Translate_context* context)\n \n   VEC(constructor_elt,gc)* init = VEC_alloc(constructor_elt, gc, 3);\n \n-  constructor_elt* elt = VEC_quick_push(constructor_elt, init, NULL);\n+  constructor_elt empty = {NULL, NULL};\n+  constructor_elt* elt = VEC_quick_push(constructor_elt, init, empty);\n   tree field = TYPE_FIELDS(type_tree);\n   go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__values\") == 0);\n   elt->index = field;\n   elt->value = fold_convert(TREE_TYPE(field), space);\n \n-  elt = VEC_quick_push(constructor_elt, init, NULL);\n+  elt = VEC_quick_push(constructor_elt, init, empty);\n   field = DECL_CHAIN(field);\n   go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__count\") == 0);\n   elt->index = field;\n   elt->value = fold_convert(TREE_TYPE(field), length_tree);\n \n-  elt = VEC_quick_push(constructor_elt, init, NULL);\n+  elt = VEC_quick_push(constructor_elt, init, empty);\n   field = DECL_CHAIN(field);\n   go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)),\"__capacity\") == 0);\n   elt->index = field;\n@@ -12102,7 +12110,8 @@ Map_construction_expression::do_get_tree(Translate_context* context)\n \n \t  VEC(constructor_elt,gc)* one = VEC_alloc(constructor_elt, gc, 2);\n \n-\t  constructor_elt* elt = VEC_quick_push(constructor_elt, one, NULL);\n+\t  constructor_elt empty = {NULL, NULL};\n+\t  constructor_elt* elt = VEC_quick_push(constructor_elt, one, empty);\n \t  elt->index = key_field;\n \t  tree val_tree = (*pv)->get_tree(context);\n \t  elt->value = Expression::convert_for_assignment(context, key_type,\n@@ -12115,7 +12124,7 @@ Map_construction_expression::do_get_tree(Translate_context* context)\n \n \t  ++pv;\n \n-\t  elt = VEC_quick_push(constructor_elt, one, NULL);\n+\t  elt = VEC_quick_push(constructor_elt, one, empty);\n \t  elt->index = val_field;\n \t  val_tree = (*pv)->get_tree(context);\n \t  elt->value = Expression::convert_for_assignment(context, val_type,\n@@ -12126,7 +12135,7 @@ Map_construction_expression::do_get_tree(Translate_context* context)\n \t  if (!TREE_CONSTANT(elt->value))\n \t    one_is_constant = false;\n \n-\t  elt = VEC_quick_push(constructor_elt, values, NULL);\n+\t  elt = VEC_quick_push(constructor_elt, values, empty);\n \t  elt->index = size_int(i);\n \t  elt->value = build_constructor(struct_type, one);\n \t  if (one_is_constant)"}, {"sha": "9a181a344aded1439ef0af2b811290379c3a49c1", "filename": "gcc/go/gofrontend/gogo-tree.cc", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -354,20 +354,21 @@ Gogo::register_gc_vars(const std::vector<Named_object*>& var_gc,\n     {\n       VEC(constructor_elt,gc)* init = VEC_alloc(constructor_elt, gc, 2);\n \n-      constructor_elt* elt = VEC_quick_push(constructor_elt, init, NULL);\n+      constructor_elt empty = {NULL, NULL};\n+      constructor_elt* elt = VEC_quick_push(constructor_elt, init, empty);\n       tree field = TYPE_FIELDS(root_type);\n       elt->index = field;\n       Bvariable* bvar = (*p)->get_backend_variable(this, NULL);\n       tree decl = var_to_tree(bvar);\n       go_assert(TREE_CODE(decl) == VAR_DECL);\n       elt->value = build_fold_addr_expr(decl);\n \n-      elt = VEC_quick_push(constructor_elt, init, NULL);\n+      elt = VEC_quick_push(constructor_elt, init, empty);\n       field = DECL_CHAIN(field);\n       elt->index = field;\n       elt->value = DECL_SIZE_UNIT(decl);\n \n-      elt = VEC_quick_push(constructor_elt, roots_init, NULL);\n+      elt = VEC_quick_push(constructor_elt, roots_init, empty);\n       elt->index = size_int(i);\n       elt->value = build_constructor(root_type, init);\n     }\n@@ -376,30 +377,31 @@ Gogo::register_gc_vars(const std::vector<Named_object*>& var_gc,\n \n   VEC(constructor_elt,gc)* init = VEC_alloc(constructor_elt, gc, 2);\n \n-  constructor_elt* elt = VEC_quick_push(constructor_elt, init, NULL);\n+  constructor_elt empty = {NULL, NULL};\n+  constructor_elt* elt = VEC_quick_push(constructor_elt, init, empty);\n   tree field = TYPE_FIELDS(root_type);\n   elt->index = field;\n   elt->value = fold_convert(TREE_TYPE(field), null_pointer_node);\n \n-  elt = VEC_quick_push(constructor_elt, init, NULL);\n+  elt = VEC_quick_push(constructor_elt, init, empty);\n   field = DECL_CHAIN(field);\n   elt->index = field;\n   elt->value = size_zero_node;\n \n-  elt = VEC_quick_push(constructor_elt, roots_init, NULL);\n+  elt = VEC_quick_push(constructor_elt, roots_init, empty);\n   elt->index = size_int(i);\n   elt->value = build_constructor(root_type, init);\n \n   // Build a constructor for the struct.\n \n   VEC(constructor_elt,gc)* root_list_init = VEC_alloc(constructor_elt, gc, 2);\n \n-  elt = VEC_quick_push(constructor_elt, root_list_init, NULL);\n+  elt = VEC_quick_push(constructor_elt, root_list_init, empty);\n   field = TYPE_FIELDS(root_list_type);\n   elt->index = field;\n   elt->value = fold_convert(TREE_TYPE(field), null_pointer_node);\n \n-  elt = VEC_quick_push(constructor_elt, root_list_init, NULL);\n+  elt = VEC_quick_push(constructor_elt, root_list_init, empty);\n   field = DECL_CHAIN(field);\n   elt->index = field;\n   elt->value = build_constructor(array_type, roots_init);\n@@ -2029,15 +2031,16 @@ Gogo::go_string_constant_tree(const std::string& val)\n \n   VEC(constructor_elt, gc)* init = VEC_alloc(constructor_elt, gc, 2);\n \n-  constructor_elt* elt = VEC_quick_push(constructor_elt, init, NULL);\n+  constructor_elt empty = {NULL, NULL};\n+  constructor_elt* elt = VEC_quick_push(constructor_elt, init, empty);\n   tree field = TYPE_FIELDS(string_type);\n   go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__data\") == 0);\n   elt->index = field;\n   tree str = Gogo::string_constant_tree(val);\n   elt->value = fold_convert(TREE_TYPE(field),\n \t\t\t    build_fold_addr_expr(str));\n \n-  elt = VEC_quick_push(constructor_elt, init, NULL);\n+  elt = VEC_quick_push(constructor_elt, init, empty);\n   field = DECL_CHAIN(field);\n   go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__length\") == 0);\n   elt->index = field;\n@@ -2089,7 +2092,8 @@ Gogo::slice_constructor(tree slice_type_tree, tree values, tree count,\n \n   tree field = TYPE_FIELDS(slice_type_tree);\n   go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__values\") == 0);\n-  constructor_elt* elt = VEC_quick_push(constructor_elt, init, NULL);\n+  constructor_elt empty = {NULL, NULL};\n+  constructor_elt* elt = VEC_quick_push(constructor_elt, init, empty);\n   elt->index = field;\n   go_assert(TYPE_MAIN_VARIANT(TREE_TYPE(field))\n \t     == TYPE_MAIN_VARIANT(TREE_TYPE(values)));\n@@ -2104,13 +2108,13 @@ Gogo::slice_constructor(tree slice_type_tree, tree values, tree count,\n \n   field = DECL_CHAIN(field);\n   go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__count\") == 0);\n-  elt = VEC_quick_push(constructor_elt, init, NULL);\n+  elt = VEC_quick_push(constructor_elt, init, empty);\n   elt->index = field;\n   elt->value = fold_convert(TREE_TYPE(field), count);\n \n   field = DECL_CHAIN(field);\n   go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__capacity\") == 0);\n-  elt = VEC_quick_push(constructor_elt, init, NULL);\n+  elt = VEC_quick_push(constructor_elt, init, empty);\n   elt->index = field;\n   elt->value = fold_convert(TREE_TYPE(field), capacity);\n \n@@ -2170,7 +2174,8 @@ Gogo::interface_method_table_for_type(const Interface_type* interface,\n \t\t\t\t\t\t count + 1);\n \n   // The first element is the type descriptor.\n-  constructor_elt* elt = VEC_quick_push(constructor_elt, pointers, NULL);\n+  constructor_elt empty = {NULL, NULL};\n+  constructor_elt* elt = VEC_quick_push(constructor_elt, pointers, empty);\n   elt->index = size_zero_node;\n   Type* td_type;\n   if (!is_pointer)\n@@ -2204,7 +2209,7 @@ Gogo::interface_method_table_for_type(const Interface_type* interface,\n \tgo_unreachable();\n       fndecl = build_fold_addr_expr(fndecl);\n \n-      elt = VEC_quick_push(constructor_elt, pointers, NULL);\n+      elt = VEC_quick_push(constructor_elt, pointers, empty);\n       elt->index = size_int(i);\n       elt->value = fold_convert(const_ptr_type_node, fndecl);\n     }"}, {"sha": "3a7b9101db90d3233bdef92353fe5586577c4c58", "filename": "gcc/graphite-sese-to-poly.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fgraphite-sese-to-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fgraphite-sese-to-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-sese-to-poly.c?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -1249,7 +1249,7 @@ build_sese_conditions_before (struct dom_walk_data *dw_data,\n       if (e->flags & EDGE_TRUE_VALUE)\n \tVEC_safe_push (gimple, heap, *cases, stmt);\n       else\n-\tVEC_safe_push (gimple, heap, *cases, (gimple) NULL);\n+\tVEC_safe_push (gimple, heap, *cases, NULL);\n     }\n \n   gbb = gbb_from_bb (bb);"}, {"sha": "613b606d1db7e228a52dc2c5aa72b5b5376cf2d0", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -266,7 +266,7 @@ add_condition (struct inline_summary *summary, int operand_num,\n   new_cond.agg_contents = agg_contents;\n   new_cond.by_ref = by_ref;\n   new_cond.offset = offset;\n-  VEC_safe_push (condition, gc, summary->conds, &new_cond);\n+  VEC_safe_push (condition, gc, summary->conds, new_cond);\n   return single_cond_predicate (i + predicate_first_dynamic_condition);\n }\n \n@@ -688,7 +688,7 @@ account_size_time (struct inline_summary *summary, int size, int time,\n       new_entry.size = size;\n       new_entry.time = time;\n       new_entry.predicate = *pred;\n-      VEC_safe_push (size_time_entry, gc, summary->entry, &new_entry);\n+      VEC_safe_push (size_time_entry, gc, summary->entry, new_entry);\n     }\n   else\n     {\n@@ -3579,7 +3579,7 @@ inline_read_section (struct lto_file_decl_data *file_data, const char *data,\n \t  c.by_ref = bp_unpack_value (&bp, 1);\n \t  if (c.agg_contents)\n \t    c.offset = streamer_read_uhwi (&ib);\n-\t  VEC_safe_push (condition, gc, info->conds, &c);\n+\t  VEC_safe_push (condition, gc, info->conds, c);\n \t}\n       count2 = streamer_read_uhwi (&ib);\n       gcc_assert (!info->entry);\n@@ -3591,7 +3591,7 @@ inline_read_section (struct lto_file_decl_data *file_data, const char *data,\n \t  e.time = streamer_read_uhwi (&ib);\n \t  e.predicate = read_predicate (&ib);\n \n-\t  VEC_safe_push (size_time_entry, gc, info->entry, &e);\n+\t  VEC_safe_push (size_time_entry, gc, info->entry, e);\n \t}\n      \n       p = read_predicate (&ib);"}, {"sha": "9729145b7a184d09ef775026f0eefe584151ffc6", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 21, "deletions": 24, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -1342,11 +1342,10 @@ determine_known_aggregate_parts (gimple call, tree arg,\n \t{\n \t  if (list->constant)\n \t    {\n-\t      struct ipa_agg_jf_item *item;\n-\t      item = VEC_quick_push (ipa_agg_jf_item_t,\n-\t\t\t\t     jfunc->agg.items, NULL);\n-\t      item->offset = list->offset - arg_offset;\n-\t      item->value = list->constant;\n+\t      struct ipa_agg_jf_item item;\n+\t      item.offset = list->offset - arg_offset;\n+\t      item.value = list->constant;\n+\t      VEC_quick_push (ipa_agg_jf_item_t, jfunc->agg.items, item);\n \t    }\n \t  list = list->next;\n \t}\n@@ -3023,45 +3022,44 @@ ipa_combine_adjustments (ipa_parm_adjustment_vec inner,\n       if (n->remove_param)\n \tremovals++;\n       else\n-\tVEC_quick_push (ipa_parm_adjustment_t, tmp, n);\n+\tVEC_quick_push (ipa_parm_adjustment_t, tmp, *n);\n     }\n \n   adjustments = VEC_alloc (ipa_parm_adjustment_t, heap, outlen + removals);\n   for (i = 0; i < outlen; i++)\n     {\n-      struct ipa_parm_adjustment *r;\n+      struct ipa_parm_adjustment r;\n       struct ipa_parm_adjustment *out = &VEC_index (ipa_parm_adjustment_t,\n \t\t\t\t\t\t    outer, i);\n       struct ipa_parm_adjustment *in = &VEC_index (ipa_parm_adjustment_t, tmp,\n \t\t\t\t\t\t   out->base_index);\n \n+      memset (&r, 0, sizeof (r));\n       gcc_assert (!in->remove_param);\n       if (out->remove_param)\n \t{\n \t  if (!index_in_adjustments_multiple_times_p (in->base_index, tmp))\n \t    {\n-\t      r = VEC_quick_push (ipa_parm_adjustment_t, adjustments, NULL);\n-\t      memset (r, 0, sizeof (*r));\n-\t      r->remove_param = true;\n+\t      r.remove_param = true;\n+\t      VEC_quick_push (ipa_parm_adjustment_t, adjustments, r);\n \t    }\n \t  continue;\n \t}\n \n-      r = VEC_quick_push (ipa_parm_adjustment_t, adjustments, NULL);\n-      memset (r, 0, sizeof (*r));\n-      r->base_index = in->base_index;\n-      r->type = out->type;\n+      r.base_index = in->base_index;\n+      r.type = out->type;\n \n       /* FIXME:  Create nonlocal value too.  */\n \n       if (in->copy_param && out->copy_param)\n-\tr->copy_param = true;\n+\tr.copy_param = true;\n       else if (in->copy_param)\n-\tr->offset = out->offset;\n+\tr.offset = out->offset;\n       else if (out->copy_param)\n-\tr->offset = in->offset;\n+\tr.offset = in->offset;\n       else\n-\tr->offset = in->offset + out->offset;\n+\tr.offset = in->offset + out->offset;\n+      VEC_quick_push (ipa_parm_adjustment_t, adjustments, r);\n     }\n \n   for (i = 0; i < inlen; i++)\n@@ -3070,7 +3068,7 @@ ipa_combine_adjustments (ipa_parm_adjustment_vec inner,\n \t\t\t\t\t\t  inner, i);\n \n       if (n->remove_param)\n-\tVEC_quick_push (ipa_parm_adjustment_t, adjustments, n);\n+\tVEC_quick_push (ipa_parm_adjustment_t, adjustments, *n);\n     }\n \n   VEC_free (ipa_parm_adjustment_t, heap, tmp);\n@@ -3238,11 +3236,10 @@ ipa_read_jump_function (struct lto_input_block *ib,\n     }\n   for (i = 0; i < count; i++)\n     {\n-      struct ipa_agg_jf_item *item = VEC_quick_push (ipa_agg_jf_item_t,\n-\t\t\t\t       jump_func->agg.items, NULL);\n-\n-      item->offset = streamer_read_uhwi (ib);\n-      item->value = stream_read_tree (ib, data_in);\n+      struct ipa_agg_jf_item item;\n+      item.offset = streamer_read_uhwi (ib);\n+      item.value = stream_read_tree (ib, data_in);\n+      VEC_quick_push (ipa_agg_jf_item_t, jump_func->agg.items, item);\n     }\n }\n "}, {"sha": "e1d1c4928e67d729211189ebaf3748a4fcfaa2de", "filename": "gcc/ipa-split.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fipa-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fipa-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-split.c?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -912,7 +912,7 @@ find_split_points (int overall_time, int overall_size)\n   first.set_ssa_names = 0;\n   first.used_ssa_names = 0;\n   first.bbs_visited = 0;\n-  VEC_safe_push (stack_entry, heap, stack, &first);\n+  VEC_safe_push (stack_entry, heap, stack, first);\n   ENTRY_BLOCK_PTR->aux = (void *)(intptr_t)-1;\n \n   while (!VEC_empty (stack_entry, stack))\n@@ -994,7 +994,7 @@ find_split_points (int overall_time, int overall_size)\n \t      new_entry.non_ssa_vars = BITMAP_ALLOC (NULL);\n \t      new_entry.can_split = true;\n \t      bitmap_set_bit (new_entry.bbs_visited, dest->index);\n-\t      VEC_safe_push (stack_entry, heap, stack, &new_entry);\n+\t      VEC_safe_push (stack_entry, heap, stack, new_entry);\n \t      dest->aux = (void *)(intptr_t)VEC_length (stack_entry, stack);\n \t    }\n \t  /* Back edge found, record the earliest point.  */"}, {"sha": "a89b83183b62622feac1e0c5c90cdc38f5969aa9", "filename": "gcc/java/class.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -2198,9 +2198,10 @@ make_class_data (tree type)\n \n       for (i = 0; i < count; i++)\n \t{\n-\t  constructor_elt *elt = VEC_quick_push (constructor_elt, v, NULL);\n- \t  elt->index = build_int_cst (sizetype, i);\n-\t  elt->value = build_int_cstu (byte_type_node, data[i]);\n+\t  constructor_elt elt;\n+ \t  elt.index = build_int_cst (sizetype, i);\n+\t  elt.value = build_int_cstu (byte_type_node, data[i]);\n+\t  VEC_quick_push (constructor_elt, v, elt);\n \t}\n \n       DECL_INITIAL (array) = build_constructor (type, v);"}, {"sha": "8041cdd99c417f528a985c2466c281916600ad4e", "filename": "gcc/java/expr.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -2296,14 +2296,13 @@ get_symbol_table_index (tree t, tree special,\n {\n   method_entry *e;\n   unsigned i;\n+  method_entry elem = {t, special};\n \n   FOR_EACH_VEC_ELT (method_entry, *symbol_table, i, e)\n     if (t == e->method && special == e->special)\n       goto done;\n \n-  e = VEC_safe_push (method_entry, gc, *symbol_table, NULL);\n-  e->method = t;\n-  e->special = special;\n+  VEC_safe_push (method_entry, gc, *symbol_table, elem);\n \n  done:\n   return i + 1;"}, {"sha": "24222883da4e7f44c1dca8c551f9401f0fe2c094", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -114,7 +114,7 @@ lto_symtab_encoder_encode (lto_symtab_encoder_t encoder,\n       if (!slot)\n         slot = pointer_map_insert (encoder->map, node);\n       *slot = (void *) (intptr_t) (ref + 1);\n-      VEC_safe_push (lto_encoder_entry, heap, encoder->nodes, &entry);\n+      VEC_safe_push (lto_encoder_entry, heap, encoder->nodes, entry);\n     }\n   else\n     ref = (size_t) *slot - 1;"}, {"sha": "cf899d379bd14082878a637cc5d66089f395b089", "filename": "gcc/objc/objc-next-runtime-abi-02.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fobjc%2Fobjc-next-runtime-abi-02.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fobjc%2Fobjc-next-runtime-abi-02.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-next-runtime-abi-02.c?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -1068,7 +1068,7 @@ objc_v2_get_class_reference (tree ident)\n   decl = build_v2_class_reference_decl (ident);\n   e.ident = ident;\n   e.data = decl;\n-  VEC_safe_push (ident_data_tuple, gc, classrefs, &e);\n+  VEC_safe_push (ident_data_tuple, gc, classrefs, e);\n   return decl;\n }\n \n@@ -1233,7 +1233,7 @@ build_v2_selector_messenger_reference (tree sel_name, tree message_func_decl)\n   e.func = message_func_decl;\n   e.selname = sel_name;\n   e.refdecl = decl;\n-  VEC_safe_push (msgref_entry, gc, msgrefs, &e);\n+  VEC_safe_push (msgref_entry, gc, msgrefs, e);\n   return decl;\n }\n \n@@ -1290,7 +1290,7 @@ objc_v2_get_protocol_reference (tree ident)\n   decl = build_v2_protocollist_ref_decl (ident);\n   e.id = ident;\n   e.refdecl = decl;\n-  VEC_safe_push (prot_list_entry, gc, protrefs, &e);\n+  VEC_safe_push (prot_list_entry, gc, protrefs, e);\n   return decl;\n }\n \n@@ -1476,7 +1476,7 @@ next_runtime_abi_02_get_class_super_ref (location_t loc ATTRIBUTE_UNUSED,\n   decl = build_v2_superclass_ref_decl (id, inst_meth);\n   e.ident = id;\n   e.data = decl;\n-  VEC_safe_push (ident_data_tuple, gc, list, &e);\n+  VEC_safe_push (ident_data_tuple, gc, list, e);\n   return decl;\n }\n \n@@ -2126,7 +2126,7 @@ objc_add_to_protocol_list (tree protocol_interface_decl, tree protocol_decl)\n     protlist = VEC_alloc (prot_list_entry, gc, 32);\n   e.id = protocol_interface_decl;\n   e.refdecl = protocol_decl;\n-  VEC_safe_push (prot_list_entry, gc, protlist, &e);\n+  VEC_safe_push (prot_list_entry, gc, protlist, e);\n }\n \n /* Build the __protocol_list section table containing address of all\n@@ -2806,7 +2806,7 @@ ivar_offset_ref (tree class_name, tree field_decl)\n \n   e.decl = decl;\n   e.offset = byte_position (field_decl);\n-  VEC_safe_push (ivarref_entry, gc, ivar_offset_refs, &e);\n+  VEC_safe_push (ivarref_entry, gc, ivar_offset_refs, e);\n   return decl;\n }\n \n@@ -3082,7 +3082,7 @@ objc_v2_add_to_ehtype_list (tree name)\n   /* Not found, or new list.  */\n   e.ident = name;\n   e.data = NULL_TREE;\n-  VEC_safe_push (ident_data_tuple, gc, ehtype_list, &e);\n+  VEC_safe_push (ident_data_tuple, gc, ehtype_list, e);\n }\n \n static void"}, {"sha": "e024537fa0fc332d49917c973d40da7c7fcba149", "filename": "gcc/opts-common.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fopts-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fopts-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts-common.c?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -1144,12 +1144,8 @@ set_option (struct gcc_options *opts, struct gcc_options *opts_set,\n \t{\n \t  VEC(cl_deferred_option,heap) *vec\n \t    = (VEC(cl_deferred_option,heap) *) *(void **) flag_var;\n-\t  cl_deferred_option *p;\n-\n-\t  p = VEC_safe_push (cl_deferred_option, heap, vec, NULL);\n-\t  p->opt_index = opt_index;\n-\t  p->arg = arg;\n-\t  p->value = value;\n+\t  cl_deferred_option p = {opt_index, arg, value};\n+\t  VEC_safe_push (cl_deferred_option, heap, vec, p);\n \t  *(void **) flag_var = vec;\n \t  if (set_flag_var)\n \t    *(void **) set_flag_var = vec;"}, {"sha": "30c2fb69484eaf5f42016d8e21fbd07dd1ef415a", "filename": "gcc/read-rtl.c", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fread-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fread-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-rtl.c?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -684,11 +684,8 @@ validate_const_int (const char *string)\n static void\n record_iterator_use (struct mapping *iterator, void *ptr)\n {\n-  struct iterator_use *iuse;\n-\n-  iuse = VEC_safe_push (iterator_use, heap, iterator_uses, NULL);\n-  iuse->iterator = iterator;\n-  iuse->ptr = ptr;\n+  struct iterator_use iuse = {iterator, ptr};\n+  VEC_safe_push (iterator_use, heap, iterator_uses, iuse);\n }\n \n /* Record that PTR uses attribute VALUE, which must match a built-in\n@@ -698,12 +695,8 @@ static void\n record_attribute_use (struct iterator_group *group, void *ptr,\n \t\t      const char *value)\n {\n-  struct attribute_use *ause;\n-\n-  ause = VEC_safe_push (attribute_use, heap, attribute_uses, NULL);\n-  ause->group = group;\n-  ause->value = value;\n-  ause->ptr = ptr;\n+  struct attribute_use ause = {group, value, ptr};\n+  VEC_safe_push (attribute_use, heap, attribute_uses, ause);\n }\n \n /* Interpret NAME as either a built-in value, iterator or attribute"}, {"sha": "99ecd578097318ec095d53ccb658845ce17e02e0", "filename": "gcc/ree.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Free.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Free.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Free.c?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -816,11 +816,8 @@ add_removable_extension (const_rtx expr, rtx insn,\n \n       /* Then add the candidate to the list and insert the reaching definitions\n          into the definition map.  */\n-      cand = VEC_safe_push (ext_cand, heap, *insn_list, NULL);\n-      cand->expr = expr;\n-      cand->code = code;\n-      cand->mode = mode;\n-      cand->insn = insn;\n+      ext_cand e = {expr, code, mode, insn};\n+      VEC_safe_push (ext_cand, heap, *insn_list, e);\n       idx = VEC_length (ext_cand, *insn_list);\n \n       for (def = defs; def; def = def->next)"}, {"sha": "1bcdfad9377e6bb0602b9cac5953c75938628d75", "filename": "gcc/reload1.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -659,15 +659,12 @@ grow_reg_equivs (void)\n   int old_size = VEC_length (reg_equivs_t, reg_equivs);\n   int max_regno = max_reg_num ();\n   int i;\n+  reg_equivs_t ze;\n \n+  memset (&ze, 0, sizeof (reg_equivs_t));\n   VEC_reserve (reg_equivs_t, gc, reg_equivs, max_regno);\n   for (i = old_size; i < max_regno; i++)\n-    {\n-      VEC_quick_insert (reg_equivs_t, reg_equivs, i, 0);\n-      memset (&VEC_index (reg_equivs_t, reg_equivs, i), 0,\n-\t      sizeof (reg_equivs_t));\n-    }\n-    \n+    VEC_quick_insert (reg_equivs_t, reg_equivs, i, ze);\n }\n \n \f"}, {"sha": "2a7a17066f623a701180b94a9ece1adc814339db", "filename": "gcc/sel-sched-ir.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fsel-sched-ir.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fsel-sched-ir.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-ir.c?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -1542,7 +1542,7 @@ insert_in_history_vect (VEC (expr_history_def, heap) **pvect,\n \n   vinsn_attach (old_expr_vinsn);\n   vinsn_attach (new_expr_vinsn);\n-  VEC_safe_insert (expr_history_def, heap, vect, ind, &temp);\n+  VEC_safe_insert (expr_history_def, heap, vect, ind, temp);\n   *pvect = vect;\n }\n "}, {"sha": "c879548483b7729e52bab4ad9e743c857ad2ec57", "filename": "gcc/tree-call-cdce.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Ftree-call-cdce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Ftree-call-cdce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-call-cdce.c?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -374,7 +374,7 @@ gen_conditions_for_domain (tree arg, inp_domain domain,\n     {\n       /* Now push a separator.  */\n       if (domain.has_lb)\n-        VEC_quick_push (gimple, conds, (gimple)NULL);\n+        VEC_quick_push (gimple, conds, NULL);\n \n       gen_one_condition (arg, domain.ub,\n                          (domain.is_ub_inclusive\n@@ -496,7 +496,7 @@ gen_conditions_for_pow_int_base (tree base, tree expn,\n      type is integer.  */\n \n   /* Push a separator.  */\n-  VEC_quick_push (gimple, conds, (gimple)NULL);\n+  VEC_quick_push (gimple, conds, NULL);\n \n   temp = create_tmp_var (int_type, \"DCE_COND1\");\n   cst0 = build_int_cst (int_type, 0);"}, {"sha": "0f68fdf4020a2887e64f92ff8afbdacccb5a6260", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -4300,7 +4300,7 @@ static bool\n get_references_in_stmt (gimple stmt, VEC (data_ref_loc, heap) **references)\n {\n   bool clobbers_memory = false;\n-  data_ref_loc *ref;\n+  data_ref_loc ref;\n   tree *op0, *op1;\n   enum gimple_code stmt_code = gimple_code (stmt);\n \n@@ -4329,9 +4329,9 @@ get_references_in_stmt (gimple stmt, VEC (data_ref_loc, heap) **references)\n \t      && (base = get_base_address (*op1))\n \t      && TREE_CODE (base) != SSA_NAME))\n \t{\n-\t  ref = VEC_safe_push (data_ref_loc, heap, *references, NULL);\n-\t  ref->pos = op1;\n-\t  ref->is_read = true;\n+\t  ref.pos = op1;\n+\t  ref.is_read = true;\n+\t  VEC_safe_push (data_ref_loc, heap, *references, ref);\n \t}\n     }\n   else if (stmt_code == GIMPLE_CALL)\n@@ -4347,9 +4347,9 @@ get_references_in_stmt (gimple stmt, VEC (data_ref_loc, heap) **references)\n \t  if (DECL_P (*op1)\n \t      || (REFERENCE_CLASS_P (*op1) && get_base_address (*op1)))\n \t    {\n-\t      ref = VEC_safe_push (data_ref_loc, heap, *references, NULL);\n-\t      ref->pos = op1;\n-\t      ref->is_read = true;\n+\t      ref.pos = op1;\n+\t      ref.is_read = true;\n+\t      VEC_safe_push (data_ref_loc, heap, *references, ref);\n \t    }\n \t}\n     }\n@@ -4360,9 +4360,9 @@ get_references_in_stmt (gimple stmt, VEC (data_ref_loc, heap) **references)\n       && (DECL_P (*op0)\n \t  || (REFERENCE_CLASS_P (*op0) && get_base_address (*op0))))\n     {\n-      ref = VEC_safe_push (data_ref_loc, heap, *references, NULL);\n-      ref->pos = op0;\n-      ref->is_read = false;\n+      ref.pos = op0;\n+      ref.is_read = false;\n+      VEC_safe_push (data_ref_loc, heap, *references, ref);\n     }\n   return clobbers_memory;\n }"}, {"sha": "423923fb66ad7f7239cfeec4646947cbc174f417", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -729,7 +729,7 @@ dump_enumerated_decls_push (tree *tp, int *walk_subtrees, void *data)\n     return NULL_TREE;\n   nt.t = *tp;\n   nt.num = VEC_length (numbered_tree, *list);\n-  VEC_safe_push (numbered_tree, heap, *list, &nt);\n+  VEC_safe_push (numbered_tree, heap, *list, nt);\n   *walk_subtrees = 0;\n   return NULL_TREE;\n }"}, {"sha": "2756ed21374d254fb4006e6e4261c81f1505c057", "filename": "gcc/tree-diagnostic.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Ftree-diagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Ftree-diagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-diagnostic.c?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -127,7 +127,7 @@ maybe_unwind_expanded_macro_loc (diagnostic_context *context,\n       loc.where = where;\n       loc.map = map;\n \n-      VEC_safe_push (loc_map_pair, heap, loc_vec, &loc);\n+      VEC_safe_push (loc_map_pair, heap, loc_vec, loc);\n \n       /* WHERE is the location of a token inside the expansion of a\n          macro.  MAP is the map holding the locations of that macro"}, {"sha": "88e77dace601a253f734166803da9a7146eba5bc", "filename": "gcc/tree-emutls.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Ftree-emutls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Ftree-emutls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-emutls.c?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -149,29 +149,29 @@ tree\n default_emutls_var_init (tree to, tree decl, tree proxy)\n {\n   VEC(constructor_elt,gc) *v = VEC_alloc (constructor_elt, gc, 4);\n-  constructor_elt *elt;\n+  constructor_elt elt;\n   tree type = TREE_TYPE (to);\n   tree field = TYPE_FIELDS (type);\n \n-  elt = VEC_quick_push (constructor_elt, v, NULL);\n-  elt->index = field;\n-  elt->value = fold_convert (TREE_TYPE (field), DECL_SIZE_UNIT (decl));\n+  elt.index = field;\n+  elt.value = fold_convert (TREE_TYPE (field), DECL_SIZE_UNIT (decl));\n+  VEC_quick_push (constructor_elt, v, elt);\n \n-  elt = VEC_quick_push (constructor_elt, v, NULL);\n   field = DECL_CHAIN (field);\n-  elt->index = field;\n-  elt->value = build_int_cst (TREE_TYPE (field),\n-\t\t\t      DECL_ALIGN_UNIT (decl));\n+  elt.index = field;\n+  elt.value = build_int_cst (TREE_TYPE (field),\n+\t\t\t     DECL_ALIGN_UNIT (decl));\n+  VEC_quick_push (constructor_elt, v, elt);\n \n-  elt = VEC_quick_push (constructor_elt, v, NULL);\n   field = DECL_CHAIN (field);\n-  elt->index = field;\n-  elt->value = null_pointer_node;\n+  elt.index = field;\n+  elt.value = null_pointer_node;\n+  VEC_quick_push (constructor_elt, v, elt);\n \n-  elt = VEC_quick_push (constructor_elt, v, NULL);\n   field = DECL_CHAIN (field);\n-  elt->index = field;\n-  elt->value = proxy;\n+  elt.index = field;\n+  elt.value = proxy;\n+  VEC_quick_push (constructor_elt, v, elt);\n \n   return build_constructor (type, v);\n }"}, {"sha": "ef3f5f99ed6bc79ff42d6539a1a60793d5bf8b48", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -3999,7 +3999,7 @@ splice_all_param_accesses (VEC (access_p, heap) **representatives)\n \t    result = UNUSED_PARAMS;\n \t}\n       else\n-\tVEC_quick_push (access_p, *representatives, (access_p) NULL);\n+\tVEC_quick_push (access_p, *representatives, NULL);\n     }\n \n   if (result == NO_GOOD_ACCESS)\n@@ -4050,36 +4050,35 @@ turn_representatives_into_adjustments (VEC (access_p, heap) *representatives,\n \n       if (!repr || no_accesses_p (repr))\n \t{\n-\t  struct ipa_parm_adjustment *adj;\n+\t  struct ipa_parm_adjustment adj;\n \n-\t  adj = VEC_quick_push (ipa_parm_adjustment_t, adjustments, NULL);\n-\t  memset (adj, 0, sizeof (*adj));\n-\t  adj->base_index = get_param_index (parm, parms);\n-\t  adj->base = parm;\n+\t  memset (&adj, 0, sizeof (adj));\n+\t  adj.base_index = get_param_index (parm, parms);\n+\t  adj.base = parm;\n \t  if (!repr)\n-\t    adj->copy_param = 1;\n+\t    adj.copy_param = 1;\n \t  else\n-\t    adj->remove_param = 1;\n+\t    adj.remove_param = 1;\n+\t  VEC_quick_push (ipa_parm_adjustment_t, adjustments, adj);\n \t}\n       else\n \t{\n-\t  struct ipa_parm_adjustment *adj;\n+\t  struct ipa_parm_adjustment adj;\n \t  int index = get_param_index (parm, parms);\n \n \t  for (; repr; repr = repr->next_grp)\n \t    {\n-\t      adj = VEC_quick_push (ipa_parm_adjustment_t, adjustments, NULL);\n-\t      memset (adj, 0, sizeof (*adj));\n+\t      memset (&adj, 0, sizeof (adj));\n \t      gcc_assert (repr->base == parm);\n-\t      adj->base_index = index;\n-\t      adj->base = repr->base;\n-\t      adj->type = repr->type;\n-\t      adj->alias_ptr_type = reference_alias_ptr_type (repr->expr);\n-\t      adj->offset = repr->offset;\n-\t      adj->by_ref = (POINTER_TYPE_P (TREE_TYPE (repr->base))\n-\t\t\t     && (repr->grp_maybe_modified\n-\t\t\t\t || repr->grp_not_necessarilly_dereferenced));\n-\n+\t      adj.base_index = index;\n+\t      adj.base = repr->base;\n+\t      adj.type = repr->type;\n+\t      adj.alias_ptr_type = reference_alias_ptr_type (repr->expr);\n+\t      adj.offset = repr->offset;\n+\t      adj.by_ref = (POINTER_TYPE_P (TREE_TYPE (repr->base))\n+\t\t\t    && (repr->grp_maybe_modified\n+\t\t\t\t|| repr->grp_not_necessarilly_dereferenced));\n+\t      VEC_quick_push (ipa_parm_adjustment_t, adjustments, adj);\n \t    }\n \t}\n     }"}, {"sha": "9065006c55ed5cbbb5eaebd5c5980f516a4cd19a", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -1231,7 +1231,7 @@ build_and_record_new_cond (enum tree_code code,\n   cond->ops.binary.opnd1 = op1;\n \n   c.value = boolean_true_node;\n-  VEC_safe_push (cond_equivalence, heap, *p, &c);\n+  VEC_safe_push (cond_equivalence, heap, *p, c);\n }\n \n /* Record that COND is true and INVERTED is false into the edge information\n@@ -1338,7 +1338,7 @@ record_conditions (struct edge_info *edge_info, tree cond, tree inverted)\n      two slots.  */\n   initialize_expr_from_cond (cond, &c.cond);\n   c.value = boolean_true_node;\n-  VEC_safe_push (cond_equivalence, heap, edge_info->cond_equivalences, &c);\n+  VEC_safe_push (cond_equivalence, heap, edge_info->cond_equivalences, c);\n \n   /* It is possible for INVERTED to be the negation of a comparison,\n      and not a valid RHS or GIMPLE_COND condition.  This happens because\n@@ -1347,7 +1347,7 @@ record_conditions (struct edge_info *edge_info, tree cond, tree inverted)\n      obey the trichotomy law.  */\n   initialize_expr_from_cond (inverted, &c.cond);\n   c.value = boolean_false_node;\n-  VEC_safe_push (cond_equivalence, heap, edge_info->cond_equivalences, &c);\n+  VEC_safe_push (cond_equivalence, heap, edge_info->cond_equivalences, c);\n }\n \n /* A helper function for record_const_or_copy and record_equality."}, {"sha": "64f538e344f43b20c73f6c189e2e999081272200", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -4773,7 +4773,7 @@ init_pre (bool do_fre)\n \n   next_expression_id = 1;\n   expressions = NULL;\n-  VEC_safe_push (pre_expr, heap, expressions, (pre_expr)NULL);\n+  VEC_safe_push (pre_expr, heap, expressions, NULL);\n   value_expressions = VEC_alloc (bitmap, heap, get_max_value_id () + 1);\n   VEC_safe_grow_cleared (bitmap, heap, value_expressions,\n \t\t\t get_max_value_id() + 1);"}, {"sha": "960e2c3c38962507728dfa2136f730072785d425", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -1344,7 +1344,7 @@ undistribute_ops_list (enum tree_code opcode,\n \t  c.cnt = 1;\n \t  c.id = next_oecount_id++;\n \t  c.op = oe1->op;\n-\t  VEC_safe_push (oecount, heap, cvec, &c);\n+\t  VEC_safe_push (oecount, heap, cvec, c);\n \t  idx = VEC_length (oecount, cvec) + 41;\n \t  slot = htab_find_slot (ctable, (void *)idx, INSERT);\n \t  if (!*slot)\n@@ -3118,7 +3118,7 @@ attempt_builtin_powi (gimple stmt, VEC(operand_entry_t, heap) **ops)\n \t      rfnew.rank = oe->rank;\n \t      rfnew.count = oe->count;\n \t      rfnew.repr = NULL_TREE;\n-\t      VEC_safe_push (repeat_factor, heap, repeat_factor_vec, &rfnew);\n+\t      VEC_safe_push (repeat_factor, heap, repeat_factor_vec, rfnew);\n \t    }\n \t}\n     }"}, {"sha": "9a370e8ab3cb174bf91beac2d44d367b8b6454bb", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -591,21 +591,21 @@ copy_reference_ops_from_ref (tree ref, VEC(vn_reference_op_s, heap) **result)\n       temp.op1 = TMR_STEP (ref);\n       temp.op2 = TMR_OFFSET (ref);\n       temp.off = -1;\n-      VEC_safe_push (vn_reference_op_s, heap, *result, &temp);\n+      VEC_safe_push (vn_reference_op_s, heap, *result, temp);\n \n       memset (&temp, 0, sizeof (temp));\n       temp.type = NULL_TREE;\n       temp.opcode = ERROR_MARK;\n       temp.op0 = TMR_INDEX2 (ref);\n       temp.off = -1;\n-      VEC_safe_push (vn_reference_op_s, heap, *result, &temp);\n+      VEC_safe_push (vn_reference_op_s, heap, *result, temp);\n \n       memset (&temp, 0, sizeof (temp));\n       temp.type = NULL_TREE;\n       temp.opcode = TREE_CODE (TMR_BASE (ref));\n       temp.op0 = TMR_BASE (ref);\n       temp.off = -1;\n-      VEC_safe_push (vn_reference_op_s, heap, *result, &temp);\n+      VEC_safe_push (vn_reference_op_s, heap, *result, temp);\n       return;\n     }\n \n@@ -700,7 +700,7 @@ copy_reference_ops_from_ref (tree ref, VEC(vn_reference_op_s, heap) **result)\n \t  temp.opcode = MEM_REF;\n \t  temp.op0 = build_int_cst (build_pointer_type (TREE_TYPE (ref)), 0);\n \t  temp.off = 0;\n-\t  VEC_safe_push (vn_reference_op_s, heap, *result, &temp);\n+\t  VEC_safe_push (vn_reference_op_s, heap, *result, temp);\n \t  temp.opcode = ADDR_EXPR;\n \t  temp.op0 = build_fold_addr_expr (ref);\n \t  temp.type = TREE_TYPE (temp.op0);\n@@ -739,7 +739,7 @@ copy_reference_ops_from_ref (tree ref, VEC(vn_reference_op_s, heap) **result)\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n-      VEC_safe_push (vn_reference_op_s, heap, *result, &temp);\n+      VEC_safe_push (vn_reference_op_s, heap, *result, temp);\n \n       if (REFERENCE_CLASS_P (ref)\n \t  || TREE_CODE (ref) == MODIFY_EXPR\n@@ -949,7 +949,7 @@ copy_reference_ops_from_call (gimple call,\n       temp.type = TREE_TYPE (lhs);\n       temp.op0 = lhs;\n       temp.off = -1;\n-      VEC_safe_push (vn_reference_op_s, heap, *result, &temp);\n+      VEC_safe_push (vn_reference_op_s, heap, *result, temp);\n     }\n \n   /* Copy the type, opcode, function being called and static chain.  */\n@@ -959,7 +959,7 @@ copy_reference_ops_from_call (gimple call,\n   temp.op0 = gimple_call_fn (call);\n   temp.op1 = gimple_call_chain (call);\n   temp.off = -1;\n-  VEC_safe_push (vn_reference_op_s, heap, *result, &temp);\n+  VEC_safe_push (vn_reference_op_s, heap, *result, temp);\n \n   /* Copy the call arguments.  As they can be references as well,\n      just chain them together.  */\n@@ -3766,7 +3766,7 @@ DFS (tree name)\n \t    {\n \t      /* Recurse by pushing the current use walking state on\n \t\t the stack and starting over.  */\n-\t      VEC_safe_push(ssa_op_iter, heap, itervec, &iter);\n+\t      VEC_safe_push(ssa_op_iter, heap, itervec, iter);\n \t      VEC_safe_push(tree, heap, namevec, name);\n \t      name = use;\n \t      goto start_over;"}, {"sha": "688b0688b82831fd04b0b8e8f046eb6dc586b3e7", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 39, "deletions": 43, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -826,7 +826,7 @@ constraint_expr_less (struct constraint_expr a, struct constraint_expr b)\n    arbitrary, but consistent, in order to give them an ordering.  */\n \n static bool\n-constraint_less (const constraint_t a, const constraint_t b)\n+constraint_less (const constraint_t &a, const constraint_t &b)\n {\n   if (constraint_expr_less (a->lhs, b->lhs))\n     return true;\n@@ -2793,12 +2793,12 @@ get_constraint_for_ssa_var (tree t, VEC(ce_s, heap) **results, bool address_p)\n       for (; vi; vi = vi->next)\n \t{\n \t  cexpr.var = vi->id;\n-\t  VEC_safe_push (ce_s, heap, *results, &cexpr);\n+\t  VEC_safe_push (ce_s, heap, *results, cexpr);\n \t}\n       return;\n     }\n \n-  VEC_safe_push (ce_s, heap, *results, &cexpr);\n+  VEC_safe_push (ce_s, heap, *results, cexpr);\n }\n \n /* Process constraint T, performing various simplifications and then\n@@ -2945,7 +2945,7 @@ get_constraint_for_ptr_offset (tree ptr, tree offset,\n \t      c2.type = ADDRESSOF;\n \t      c2.offset = 0;\n \t      if (c2.var != c.var)\n-\t\tVEC_safe_push (ce_s, heap, *results, &c2);\n+\t\tVEC_safe_push (ce_s, heap, *results, c2);\n \t      temp = temp->next;\n \t    }\n \t  while (temp);\n@@ -2980,7 +2980,7 @@ get_constraint_for_ptr_offset (tree ptr, tree offset,\n \t      c2.var = temp->next->id;\n \t      c2.type = ADDRESSOF;\n \t      c2.offset = 0;\n-\t      VEC_safe_push (ce_s, heap, *results, &c2);\n+\t      VEC_safe_push (ce_s, heap, *results, c2);\n \t    }\n \t  c.var = temp->id;\n \t  c.offset = 0;\n@@ -3024,7 +3024,7 @@ get_constraint_for_component_ref (tree t, VEC(ce_s, heap) **results,\n       temp.offset = 0;\n       temp.var = integer_id;\n       temp.type = SCALAR;\n-      VEC_safe_push (ce_s, heap, *results, &temp);\n+      VEC_safe_push (ce_s, heap, *results, temp);\n       return;\n     }\n \n@@ -3046,7 +3046,7 @@ get_constraint_for_component_ref (tree t, VEC(ce_s, heap) **results,\n \t    temp.offset = 0;\n \t    temp.var = anything_id;\n \t    temp.type = ADDRESSOF;\n-\t    VEC_safe_push (ce_s, heap, *results, &temp);\n+\t    VEC_safe_push (ce_s, heap, *results, temp);\n \t    return;\n \t  }\n     }\n@@ -3087,7 +3087,7 @@ get_constraint_for_component_ref (tree t, VEC(ce_s, heap) **results,\n \t\t\t\t    bitpos, bitmaxsize))\n \t\t{\n \t\t  cexpr.var = curr->id;\n-\t\t  VEC_safe_push (ce_s, heap, *results, &cexpr);\n+\t\t  VEC_safe_push (ce_s, heap, *results, cexpr);\n \t\t  if (address_p)\n \t\t    break;\n \t\t}\n@@ -3102,7 +3102,7 @@ get_constraint_for_component_ref (tree t, VEC(ce_s, heap) **results,\n \t      while (curr->next != NULL)\n \t\tcurr = curr->next;\n \t      cexpr.var = curr->id;\n-\t      VEC_safe_push (ce_s, heap, *results, &cexpr);\n+\t      VEC_safe_push (ce_s, heap, *results, cexpr);\n \t    }\n \t  else if (VEC_length (ce_s, *results) == 0)\n \t    /* Assert that we found *some* field there. The user couldn't be\n@@ -3115,7 +3115,7 @@ get_constraint_for_component_ref (tree t, VEC(ce_s, heap) **results,\n \t      cexpr.type = SCALAR;\n \t      cexpr.var = anything_id;\n \t      cexpr.offset = 0;\n-\t      VEC_safe_push (ce_s, heap, *results, &cexpr);\n+\t      VEC_safe_push (ce_s, heap, *results, cexpr);\n \t    }\n \t}\n       else if (bitmaxsize == 0)\n@@ -3239,7 +3239,7 @@ get_constraint_for_1 (tree t, VEC (ce_s, heap) **results, bool address_p,\n \ttemp.var = nonlocal_id;\n       temp.type = ADDRESSOF;\n       temp.offset = 0;\n-      VEC_safe_push (ce_s, heap, *results, &temp);\n+      VEC_safe_push (ce_s, heap, *results, temp);\n       return;\n     }\n \n@@ -3249,7 +3249,7 @@ get_constraint_for_1 (tree t, VEC (ce_s, heap) **results, bool address_p,\n       temp.var = readonly_id;\n       temp.type = SCALAR;\n       temp.offset = 0;\n-      VEC_safe_push (ce_s, heap, *results, &temp);\n+      VEC_safe_push (ce_s, heap, *results, temp);\n       return;\n     }\n \n@@ -3310,7 +3310,7 @@ get_constraint_for_1 (tree t, VEC (ce_s, heap) **results, bool address_p,\n \t\t      if (curr->offset - vi->offset < size)\n \t\t\t{\n \t\t\t  cs.var = curr->id;\n-\t\t\t  VEC_safe_push (ce_s, heap, *results, &cs);\n+\t\t\t  VEC_safe_push (ce_s, heap, *results, cs);\n \t\t\t}\n \t\t      else\n \t\t\tbreak;\n@@ -3352,7 +3352,7 @@ get_constraint_for_1 (tree t, VEC (ce_s, heap) **results, bool address_p,\n \t\t  unsigned j;\n \t\t  get_constraint_for_1 (val, &tmp, address_p, lhs_p);\n \t\t  FOR_EACH_VEC_ELT (ce_s, tmp, j, rhsp)\n-\t\t    VEC_safe_push (ce_s, heap, *results, rhsp);\n+\t\t    VEC_safe_push (ce_s, heap, *results, *rhsp);\n \t\t  VEC_truncate (ce_s, tmp, 0);\n \t\t}\n \t      VEC_free (ce_s, heap, tmp);\n@@ -3376,7 +3376,7 @@ get_constraint_for_1 (tree t, VEC (ce_s, heap) **results, bool address_p,\n \ttemp.type = ADDRESSOF;\n \ttemp.var = nonlocal_id;\n \ttemp.offset = 0;\n-\tVEC_safe_push (ce_s, heap, *results, &temp);\n+\tVEC_safe_push (ce_s, heap, *results, temp);\n \treturn;\n       }\n     default:;\n@@ -3386,7 +3386,7 @@ get_constraint_for_1 (tree t, VEC (ce_s, heap) **results, bool address_p,\n   temp.type = ADDRESSOF;\n   temp.var = anything_id;\n   temp.offset = 0;\n-  VEC_safe_push (ce_s, heap, *results, &temp);\n+  VEC_safe_push (ce_s, heap, *results, temp);\n }\n \n /* Given a gimple tree T, return the constraint expression vector for it.  */\n@@ -3793,7 +3793,7 @@ handle_rhs_call (gimple stmt, VEC(ce_s, heap) **results)\n       rhsc.var = get_call_use_vi (stmt)->id;\n       rhsc.offset = 0;\n       rhsc.type = SCALAR;\n-      VEC_safe_push (ce_s, heap, *results, &rhsc);\n+      VEC_safe_push (ce_s, heap, *results, rhsc);\n     }\n \n   /* The static chain escapes as well.  */\n@@ -3820,7 +3820,7 @@ handle_rhs_call (gimple stmt, VEC(ce_s, heap) **results)\n   rhsc.var = nonlocal_id;\n   rhsc.offset = 0;\n   rhsc.type = SCALAR;\n-  VEC_safe_push (ce_s, heap, *results, &rhsc);\n+  VEC_safe_push (ce_s, heap, *results, rhsc);\n }\n \n /* For non-IPA mode, generate constraints necessary for a call\n@@ -3845,7 +3845,7 @@ handle_lhs_call (gimple stmt, tree lhs, int flags, VEC(ce_s, heap) *rhsc,\n       tmpc.var = escaped_id;\n       tmpc.offset = 0;\n       tmpc.type = SCALAR;\n-      VEC_safe_push (ce_s, heap, lhsc, &tmpc);\n+      VEC_safe_push (ce_s, heap, lhsc, tmpc);\n     }\n \n   /* If the call returns an argument unmodified override the rhs\n@@ -3880,7 +3880,7 @@ handle_lhs_call (gimple stmt, tree lhs, int flags, VEC(ce_s, heap) *rhsc,\n       tmpc.var = vi->id;\n       tmpc.offset = 0;\n       tmpc.type = ADDRESSOF;\n-      VEC_safe_push (ce_s, heap, rhsc, &tmpc);\n+      VEC_safe_push (ce_s, heap, rhsc, tmpc);\n       process_all_all_constraints (lhsc, rhsc);\n       VEC_free (ce_s, heap, rhsc);\n     }\n@@ -3909,7 +3909,7 @@ handle_const_call (gimple stmt, VEC(ce_s, heap) **results)\n       rhsc.var = uses->id;\n       rhsc.offset = 0;\n       rhsc.type = SCALAR;\n-      VEC_safe_push (ce_s, heap, *results, &rhsc);\n+      VEC_safe_push (ce_s, heap, *results, rhsc);\n     }\n \n   /* May return arguments.  */\n@@ -3921,15 +3921,15 @@ handle_const_call (gimple stmt, VEC(ce_s, heap) **results)\n       struct constraint_expr *argp;\n       get_constraint_for_rhs (arg, &argc);\n       FOR_EACH_VEC_ELT (ce_s, argc, i, argp)\n-\tVEC_safe_push (ce_s, heap, *results, argp);\n+\tVEC_safe_push (ce_s, heap, *results, *argp);\n       VEC_free(ce_s, heap, argc);\n     }\n \n   /* May return addresses of globals.  */\n   rhsc.var = nonlocal_id;\n   rhsc.offset = 0;\n   rhsc.type = ADDRESSOF;\n-  VEC_safe_push (ce_s, heap, *results, &rhsc);\n+  VEC_safe_push (ce_s, heap, *results, rhsc);\n }\n \n /* For non-IPA mode, generate constraints necessary for a call to a\n@@ -3971,12 +3971,12 @@ handle_pure_call (gimple stmt, VEC(ce_s, heap) **results)\n       rhsc.var = uses->id;\n       rhsc.offset = 0;\n       rhsc.type = SCALAR;\n-      VEC_safe_push (ce_s, heap, *results, &rhsc);\n+      VEC_safe_push (ce_s, heap, *results, rhsc);\n     }\n   rhsc.var = nonlocal_id;\n   rhsc.offset = 0;\n   rhsc.type = SCALAR;\n-  VEC_safe_push (ce_s, heap, *results, &rhsc);\n+  VEC_safe_push (ce_s, heap, *results, rhsc);\n }\n \n \n@@ -4412,7 +4412,7 @@ find_func_aliases_for_call (gimple t)\n \t      && DECL_BY_REFERENCE (DECL_RESULT (fndecl)))\n \t    {\n \t      VEC(ce_s, heap) *tem = NULL;\n-\t      VEC_safe_push (ce_s, heap, tem, &rhs);\n+\t      VEC_safe_push (ce_s, heap, tem, rhs);\n \t      do_deref (&tem);\n \t      rhs = VEC_index (ce_s, tem, 0);\n \t      VEC_free(ce_s, heap, tem);\n@@ -4549,7 +4549,7 @@ find_func_aliases (gimple origt)\n \t      get_constraint_for_rhs (gimple_assign_rhs2 (t), &rhsc);\n \t      get_constraint_for_rhs (gimple_assign_rhs3 (t), &tmp);\n \t      FOR_EACH_VEC_ELT (ce_s, tmp, i, rhsp)\n-\t\tVEC_safe_push (ce_s, heap, rhsc, rhsp);\n+\t\tVEC_safe_push (ce_s, heap, rhsc, *rhsp);\n \t      VEC_free (ce_s, heap, tmp);\n \t    }\n \t  else if (truth_value_p (code))\n@@ -4567,7 +4567,7 @@ find_func_aliases (gimple origt)\n \t\t{\n \t\t  get_constraint_for_rhs (gimple_op (t, i), &tmp);\n \t\t  FOR_EACH_VEC_ELT (ce_s, tmp, j, rhsp)\n-\t\t    VEC_safe_push (ce_s, heap, rhsc, rhsp);\n+\t\t    VEC_safe_push (ce_s, heap, rhsc, *rhsp);\n \t\t  VEC_truncate (ce_s, tmp, 0);\n \t\t}\n \t      VEC_free (ce_s, heap, tmp);\n@@ -5191,13 +5191,8 @@ push_fields_onto_fieldstack (tree type, VEC(fieldoff_s,heap) **fieldstack,\n \t    if (!pair\n \t\t&& offset + foff != 0)\n \t      {\n-\t\tpair = VEC_safe_push (fieldoff_s, heap, *fieldstack, NULL);\n-\t\tpair->offset = 0;\n-\t\tpair->size = offset + foff;\n-\t\tpair->has_unknown_size = false;\n-\t\tpair->must_have_pointers = false;\n-\t\tpair->may_have_pointers = false;\n-\t\tpair->only_restrict_pointers = false;\n+\t\tfieldoff_s e = {0, offset + foff, false, false, false, false};\n+\t\tpair = VEC_safe_push (fieldoff_s, heap, *fieldstack, e);\n \t      }\n \n \t    if (!DECL_SIZE (field)\n@@ -5217,19 +5212,20 @@ push_fields_onto_fieldstack (tree type, VEC(fieldoff_s,heap) **fieldstack,\n \t      }\n \t    else\n \t      {\n-\t\tpair = VEC_safe_push (fieldoff_s, heap, *fieldstack, NULL);\n-\t\tpair->offset = offset + foff;\n-\t\tpair->has_unknown_size = has_unknown_size;\n+\t\tfieldoff_s e;\n+\t\te.offset = offset + foff;\n+\t\te.has_unknown_size = has_unknown_size;\n \t\tif (!has_unknown_size)\n-\t\t  pair->size = TREE_INT_CST_LOW (DECL_SIZE (field));\n+\t\t  e.size = TREE_INT_CST_LOW (DECL_SIZE (field));\n \t\telse\n-\t\t  pair->size = -1;\n-\t\tpair->must_have_pointers = must_have_pointers_p;\n-\t\tpair->may_have_pointers = true;\n-\t\tpair->only_restrict_pointers\n+\t\t  e.size = -1;\n+\t\te.must_have_pointers = must_have_pointers_p;\n+\t\te.may_have_pointers = true;\n+\t\te.only_restrict_pointers\n \t\t  = (!has_unknown_size\n \t\t     && POINTER_TYPE_P (TREE_TYPE (field))\n \t\t     && TYPE_RESTRICT (TREE_TYPE (field)));\n+\t\tVEC_safe_push (fieldoff_s, heap, *fieldstack, e);\n \t      }\n \t  }\n "}, {"sha": "7ba11e193d6f3d959dc3e98f3431032d5dce53a1", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -68,7 +68,7 @@ redirect_edge_var_map_add (edge e, tree result, tree def, source_location locus)\n   new_node.result = result;\n   new_node.locus = locus;\n \n-  VEC_safe_push (edge_var_map, heap, head, &new_node);\n+  VEC_safe_push (edge_var_map, heap, head, new_node);\n   if (old_head != head)\n     {\n       /* The push did some reallocation.  Update the pointer map.  */"}, {"sha": "bbbd3caca021be86476c40f2b82b09a875ec4efc", "filename": "gcc/tree-switch-conversion.c", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Ftree-switch-conversion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Ftree-switch-conversion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-switch-conversion.c?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -868,13 +868,11 @@ build_constructors (gimple swtch, struct switch_conv_info *info)\n \t  int k;\n \t  for (k = 0; k < info->phi_count; k++)\n \t    {\n-\t      constructor_elt *elt;\n+\t      constructor_elt elt;\n \n-\t      elt = VEC_quick_push (constructor_elt,\n-\t\t\t\t    info->constructors[k], NULL);\n-\t      elt->index = int_const_binop (MINUS_EXPR, pos,\n-\t\t\t\t\t    info->range_min);\n-\t      elt->value = info->default_values[k];\n+\t      elt.index = int_const_binop (MINUS_EXPR, pos, info->range_min);\n+\t      elt.value = info->default_values[k];\n+\t      VEC_quick_push (constructor_elt, info->constructors[k], elt);\n \t    }\n \n \t  pos = int_const_binop (PLUS_EXPR, pos, integer_one_node);\n@@ -896,12 +894,11 @@ build_constructors (gimple swtch, struct switch_conv_info *info)\n \n \t  do\n \t    {\n-\t      constructor_elt *elt;\n+\t      constructor_elt elt;\n \n-\t      elt = VEC_quick_push (constructor_elt,\n-\t\t\t\t    info->constructors[j], NULL);\n-\t      elt->index = int_const_binop (MINUS_EXPR, pos, info->range_min);\n-\t      elt->value = val;\n+\t      elt.index = int_const_binop (MINUS_EXPR, pos, info->range_min);\n+\t      elt.value = val;\n+\t      VEC_quick_push (constructor_elt, info->constructors[j], elt);\n \n \t      pos = int_const_binop (PLUS_EXPR, pos, integer_one_node);\n \t    } while (!tree_int_cst_lt (high, pos)"}, {"sha": "b217b1123e97087af70fc2f07822f834087aafbd", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -252,9 +252,8 @@ expand_vector_piecewise (gimple_stmt_iterator *gsi, elem_op_func f,\n        i += delta, index = int_const_binop (PLUS_EXPR, index, part_width))\n     {\n       tree result = f (gsi, inner_type, a, b, index, part_width, code);\n-      constructor_elt *ce = VEC_quick_push (constructor_elt, v, NULL);\n-      ce->index = NULL_TREE;\n-      ce->value = result;\n+      constructor_elt ce = {NULL_TREE, result};\n+      VEC_quick_push (constructor_elt, v, ce);\n     }\n \n   return build_constructor (type, v);"}, {"sha": "508dff0f714a51c7b5f3be12dbf48850c3d263a7", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -214,7 +214,7 @@ adjust_debug_stmts (tree from, tree to, basic_block bb)\n       ai.bb = bb;\n \n       if (adjust_vec)\n-\tVEC_safe_push (adjust_info, stack, adjust_vec, &ai);\n+\tVEC_safe_push (adjust_info, stack, adjust_vec, ai);\n       else\n \tadjust_debug_stmts_now (&ai);\n     }"}, {"sha": "11dbdfb5a02436f3c1f513beeb0eccc5ee6be8d4", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -1099,7 +1099,7 @@ vect_slp_rearrange_stmts (slp_tree node, unsigned int group_size,\n   tmp_stmts = VEC_alloc (gimple, heap, group_size);\n \n   for (i = 0; i < group_size; i++)\n-    VEC_safe_push (gimple, heap, tmp_stmts, (gimple)NULL);\n+    VEC_safe_push (gimple, heap, tmp_stmts, NULL);\n \n   FOR_EACH_VEC_ELT (gimple, SLP_TREE_SCALAR_STMTS (node), i, stmt)\n     {\n@@ -2663,7 +2663,7 @@ vect_create_mask_and_perm (gimple stmt, gimple next_scalar_stmt,\n      stmts later.  */\n   for (i = VEC_length (gimple, SLP_TREE_VEC_STMTS (node));\n        i < (int) SLP_TREE_NUMBER_OF_VEC_STMTS (node); i++)\n-    VEC_quick_push (gimple, SLP_TREE_VEC_STMTS (node), (gimple)NULL);\n+    VEC_quick_push (gimple, SLP_TREE_VEC_STMTS (node), NULL);\n \n   perm_dest = vect_create_destination_var (gimple_assign_lhs (stmt), vectype);\n   for (i = 0; i < ncopies; i++)"}, {"sha": "bad0fa24191606923e2a2829009a5ea3579591e0", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -94,7 +94,7 @@ add_stmt_info_to_vec (stmt_vector_for_cost *stmt_cost_vec, int count,\n   si.kind = kind;\n   si.stmt = stmt;\n   si.misalign = misalign;\n-  VEC_safe_push (stmt_info_for_cost, heap, *stmt_cost_vec, &si);\n+  VEC_safe_push (stmt_info_for_cost, heap, *stmt_cost_vec, si);\n }\n \n /************************************************************************"}, {"sha": "c0a4050a812f099e8ea83afb0e308dfdadec4337", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -8493,7 +8493,7 @@ simplify_switch_using_ranges (gimple stmt)\n   /* And queue an update for the stmt.  */\n   su.stmt = stmt;\n   su.vec = vec2;\n-  VEC_safe_push (switch_update, heap, to_update_switch_stmts, &su);\n+  VEC_safe_push (switch_update, heap, to_update_switch_stmts, su);\n   return false;\n }\n "}, {"sha": "a7492de8a92bc3d990c5eb2756e856e89f663e2c", "filename": "gcc/tree.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -1443,12 +1443,10 @@ tree\n build_constructor_single (tree type, tree index, tree value)\n {\n   VEC(constructor_elt,gc) *v;\n-  constructor_elt *elt;\n+  constructor_elt elt = {index, value};\n \n   v = VEC_alloc (constructor_elt, gc, 1);\n-  elt = VEC_quick_push (constructor_elt, v, NULL);\n-  elt->index = index;\n-  elt->value = value;\n+  VEC_quick_push (constructor_elt, v, elt);\n \n   return build_constructor (type, v);\n }"}, {"sha": "ab5dd1e3f594e2afef4e5fe4d8c6fa3231f3d578", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -1546,9 +1546,8 @@ struct GTY(()) tree_vec {\n /* Append a new constructor element to V, with the specified INDEX and VAL.  */\n #define CONSTRUCTOR_APPEND_ELT(V, INDEX, VALUE) \\\n   do { \\\n-    constructor_elt *_ce___ = VEC_safe_push (constructor_elt, gc, V, NULL); \\\n-    _ce___->index = INDEX; \\\n-    _ce___->value = VALUE; \\\n+    constructor_elt _ce___ = {INDEX, VALUE}; \\\n+    VEC_safe_push (constructor_elt, gc, V, _ce___); \\\n   } while (0)\n \n /* True if NODE, a FIELD_DECL, is to be processed as a bitfield for"}, {"sha": "8c9ec48c2408cb6972c588772e05aa2f5d1c92ff", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -5510,7 +5510,7 @@ add_uses (rtx *ploc, void *data)\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tlog_op_type (mo.u.loc, cui->bb, cui->insn, mo.type, dump_file);\n-      VEC_safe_push (micro_operation, heap, VTI (bb)->mos, &mo);\n+      VEC_safe_push (micro_operation, heap, VTI (bb)->mos, mo);\n     }\n \n   return 0;\n@@ -5794,7 +5794,7 @@ add_stores (rtx loc, const_rtx expr, void *cuip)\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    log_op_type (moa.u.loc, cui->bb, cui->insn,\n \t\t\t moa.type, dump_file);\n-\t  VEC_safe_push (micro_operation, heap, VTI (bb)->mos, &moa);\n+\t  VEC_safe_push (micro_operation, heap, VTI (bb)->mos, moa);\n \t}\n \n       resolve = false;\n@@ -5881,7 +5881,7 @@ add_stores (rtx loc, const_rtx expr, void *cuip)\n  log_and_return:\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     log_op_type (mo.u.loc, cui->bb, cui->insn, mo.type, dump_file);\n-  VEC_safe_push (micro_operation, heap, VTI (bb)->mos, &mo);\n+  VEC_safe_push (micro_operation, heap, VTI (bb)->mos, mo);\n }\n \n /* Arguments to the call.  */\n@@ -6300,7 +6300,7 @@ add_with_sets (rtx insn, struct cselib_set *sets, int n_sets)\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tlog_op_type (PATTERN (insn), bb, insn, mo.type, dump_file);\n-      VEC_safe_push (micro_operation, heap, VTI (bb)->mos, &mo);\n+      VEC_safe_push (micro_operation, heap, VTI (bb)->mos, mo);\n     }\n \n   n1 = VEC_length (micro_operation, VTI (bb)->mos);\n@@ -7864,7 +7864,9 @@ loc_exp_insert_dep (variable var, rtx x, htab_t vars)\n     led = (loc_exp_dep *) pool_alloc (loc_exp_dep_pool);\n   else\n     {\n-      VEC_quick_push (loc_exp_dep, VAR_LOC_DEP_VEC (var), NULL);\n+      loc_exp_dep empty;\n+      memset (&empty, 0, sizeof (empty));\n+      VEC_quick_push (loc_exp_dep, VAR_LOC_DEP_VEC (var), empty);\n       led = &VEC_last (loc_exp_dep, VAR_LOC_DEP_VEC (var));\n     }\n   led->dv = var->dv;\n@@ -9815,7 +9817,7 @@ vt_initialize (void)\n \t\t\t    log_op_type (PATTERN (insn), bb, insn,\n \t\t\t\t\t MO_ADJUST, dump_file);\n \t\t\t  VEC_safe_push (micro_operation, heap, VTI (bb)->mos,\n-\t\t\t\t\t &mo);\n+\t\t\t\t\t mo);\n \t\t\t  VTI (bb)->out.stack_adjust += pre;\n \t\t\t}\n \t\t    }\n@@ -9847,7 +9849,7 @@ vt_initialize (void)\n \t\t\tlog_op_type (PATTERN (insn), bb, insn,\n \t\t\t\t     MO_ADJUST, dump_file);\n \t\t      VEC_safe_push (micro_operation, heap, VTI (bb)->mos,\n-\t\t\t\t     &mo);\n+\t\t\t\t     mo);\n \t\t      VTI (bb)->out.stack_adjust += post;\n \t\t    }\n "}, {"sha": "a587c80fd34271b4a713bebe087b07e2644f4a61", "filename": "gcc/varasm.c", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -2999,9 +2999,8 @@ copy_constant (tree exp)\n \t\t\t\t\t\t      CONSTRUCTOR_ELTS (exp)));\n \tFOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (exp), idx, purpose, value)\n \t  {\n-\t    constructor_elt *ce = VEC_quick_push (constructor_elt, v, NULL);\n-\t    ce->index = purpose;\n-\t    ce->value = copy_constant (value);\n+\t    constructor_elt ce = {purpose, copy_constant (value)};\n+\t    VEC_quick_push (constructor_elt, v, ce);\n \t  }\n \tCONSTRUCTOR_ELTS (copy) = v;\n \treturn copy;\n@@ -5563,9 +5562,8 @@ assemble_alias (tree decl, tree target)\n     do_assemble_alias (decl, target);\n   else\n     {\n-      alias_pair *p = VEC_safe_push (alias_pair, gc, alias_pairs, NULL);\n-      p->decl = decl;\n-      p->target = target;\n+      alias_pair p = {decl, target};\n+      VEC_safe_push (alias_pair, gc, alias_pairs, p);\n     }\n }\n \n@@ -5628,14 +5626,9 @@ static int\n dump_tm_clone_to_vec (void **slot, void *info)\n {\n   struct tree_map *map = (struct tree_map *) *slot;\n-  VEC(tm_alias_pair,heap) **tm_alias_pairs\n-    = (VEC(tm_alias_pair, heap) **) info;\n-  tm_alias_pair *p;\n-\n-  p = VEC_safe_push (tm_alias_pair, heap, *tm_alias_pairs, NULL);\n-  p->from = map->base.from;\n-  p->to = map->to;\n-  p->uid = DECL_UID (p->from);\n+  VEC(tm_alias_pair,heap) **tm_alias_pairs = (VEC(tm_alias_pair, heap) **) info;\n+  tm_alias_pair p = {DECL_UID (map->base.from), map->base.from, map->to};\n+  VEC_safe_push (tm_alias_pair, heap, *tm_alias_pairs, p);\n   return 1;\n }\n "}, {"sha": "88891d74d7fad43aa131dffa4ce88be9b01aed32", "filename": "gcc/vec.h", "status": "modified", "additions": 21, "deletions": 128, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fvec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f32682ca2516e009432be7f0dc0e4e4bfab9a944/gcc%2Fvec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.h?ref=f32682ca2516e009432be7f0dc0e4e4bfab9a944", "patch": "@@ -178,19 +178,15 @@ struct GTY(()) vec_t\n \n   bool space (int VEC_CHECK_DECL);\n   void splice (vec_t<T> * VEC_CHECK_DECL);\n-  T &quick_push (T VEC_CHECK_DECL);\n-  T *quick_push (const T * VEC_CHECK_DECL);\n+  T *quick_push (const T & VEC_CHECK_DECL);\n   T &pop (ALONE_VEC_CHECK_DECL);\n   void truncate (unsigned VEC_CHECK_DECL);\n-  void replace (unsigned, T VEC_CHECK_DECL);\n-  void quick_insert (unsigned, T VEC_CHECK_DECL);\n-  void quick_insert (unsigned, const T * VEC_CHECK_DECL);\n+  void replace (unsigned, const T & VEC_CHECK_DECL);\n+  void quick_insert (unsigned, const T & VEC_CHECK_DECL);\n   void ordered_remove (unsigned VEC_CHECK_DECL);\n   void unordered_remove (unsigned VEC_CHECK_DECL);\n   void block_remove (unsigned, unsigned VEC_CHECK_DECL);\n-\n-  unsigned lower_bound (T, bool (*)(T, T)) const;\n-  unsigned lower_bound (const T *, bool (*)(const T *, const T *)) const;\n+  unsigned lower_bound (T, bool (*)(const T &, const T &)) const;\n \n   /* Class-static member functions.  Some of these will become member\n      functions of a future handler class wrapping vec_t.  */\n@@ -221,10 +217,7 @@ struct GTY(()) vec_t\n \t\t\t   MEM_STAT_DECL);\n \n   template<enum vec_allocation_t A>\n-  static T &safe_push (vec_t<T> **, T VEC_CHECK_DECL MEM_STAT_DECL);\n-\n-  template<enum vec_allocation_t A>\n-  static T *safe_push (vec_t<T> **, const T * VEC_CHECK_DECL MEM_STAT_DECL);\n+  static T *safe_push (vec_t<T> **, const T & VEC_CHECK_DECL MEM_STAT_DECL);\n \n   template<enum vec_allocation_t A>\n   static void safe_grow (vec_t<T> **, int VEC_CHECK_DECL MEM_STAT_DECL);\n@@ -233,11 +226,7 @@ struct GTY(()) vec_t\n   static void safe_grow_cleared (vec_t<T> **, int VEC_CHECK_DECL MEM_STAT_DECL);\n \n   template<enum vec_allocation_t A>\n-  static void safe_insert (vec_t<T> **, unsigned, T * VEC_CHECK_DECL\n-\t\t\t   MEM_STAT_DECL);\n-\n-  template<enum vec_allocation_t A>\n-  static void safe_insert (vec_t<T> **, unsigned, T obj VEC_CHECK_DECL\n+  static void safe_insert (vec_t<T> **, unsigned, const T & VEC_CHECK_DECL\n \t\t\t   MEM_STAT_DECL);\n \n   static bool iterate (const vec_t<T> *, unsigned, T *);\n@@ -802,63 +791,32 @@ vec_t<T>::safe_splice (vec_t<T> **dst, vec_t<T> *src VEC_CHECK_DECL\n }\n \n   \n-/* Push OBJ (a new element) onto the end, returns a reference to the slot\n-   filled in.  There must be sufficient space in the vector.  */\n-\n-template<typename T>\n-T &\n-vec_t<T>::quick_push (T obj VEC_CHECK_DECL)\n-{\n-  VEC_ASSERT (prefix_.num_ < prefix_.alloc_, \"push\", T, base);\n-  vec_[prefix_.num_] = obj;\n-  T &val = vec_[prefix_.num_];\n-  prefix_.num_++;\n-  return val;\n-}\n+/* Push OBJ (a new element) onto the end of the vector.  There must be\n+   sufficient space in the vector.  Return a pointer to the slot\n+   where OBJ was inserted.  */\n \n \n-/* Push PTR (a new pointer to an element) onto the end, returns a\n-   pointer to the slot filled in. The new value can be NULL, in which\n-   case NO initialization is performed.  There must be sufficient\n-   space in the vector.  */\n-\n template<typename T>\n T *\n-vec_t<T>::quick_push (const T *ptr VEC_CHECK_DECL)\n+vec_t<T>::quick_push (const T &obj VEC_CHECK_DECL)\n {\n   VEC_ASSERT (prefix_.num_ < prefix_.alloc_, \"push\", T, base);\n   T *slot = &vec_[prefix_.num_++];\n-  if (ptr)\n-    *slot = *ptr;\n+  *slot = obj;\n   return slot;\n }\n \n \n-/* Push a new element OBJ onto the end of VEC.  Returns a reference to\n-   the slot filled in.  Reallocates V, if needed.  */\n-\n-template<typename T>\n-template<enum vec_allocation_t A>\n-T &\n-vec_t<T>::safe_push (vec_t<T> **vec, T obj VEC_CHECK_DECL MEM_STAT_DECL)\n-{\n-  reserve<A> (vec, 1 VEC_CHECK_PASS PASS_MEM_STAT);\n-  return (*vec)->quick_push (obj VEC_CHECK_PASS);\n-}\n-\n-\n-/* Push a pointer PTR to a new element onto the end of VEC.  Returns a\n-   pointer to the slot filled in. For object vectors, the new value\n-   can be NULL, in which case NO initialization is performed.\n-   Reallocates VEC, if needed.  */\n+/* Push a new element OBJ onto the end of VEC.  Reallocates VEC, if\n+   needed.  Return a pointer to the slot where OBJ was inserted.  */\n \n template<typename T>\n template<enum vec_allocation_t A>\n T *\n-vec_t<T>::safe_push (vec_t<T> **vec, const T *ptr VEC_CHECK_DECL MEM_STAT_DECL)\n+vec_t<T>::safe_push (vec_t<T> **vec, const T &obj VEC_CHECK_DECL MEM_STAT_DECL)\n {\n   reserve<A> (vec, 1 VEC_CHECK_PASS PASS_MEM_STAT);\n-  return (*vec)->quick_push (ptr VEC_CHECK_PASS);\n+  return (*vec)->quick_push (obj VEC_CHECK_PASS);\n }\n \n \n@@ -923,7 +881,7 @@ vec_t<T>::safe_grow_cleared (vec_t<T> **vec, int size VEC_CHECK_DECL\n \n template<typename T>\n void\n-vec_t<T>::replace (unsigned ix, T obj VEC_CHECK_DECL)\n+vec_t<T>::replace (unsigned ix, const T &obj VEC_CHECK_DECL)\n {\n   VEC_ASSERT (ix < prefix_.num_, \"replace\", T, base);\n   vec_[ix] = obj;\n@@ -935,7 +893,7 @@ vec_t<T>::replace (unsigned ix, T obj VEC_CHECK_DECL)\n \n template<typename T>\n void\n-vec_t<T>::quick_insert (unsigned ix, T obj VEC_CHECK_DECL)\n+vec_t<T>::quick_insert (unsigned ix, const T &obj VEC_CHECK_DECL)\n {\n   VEC_ASSERT (prefix_.num_ < prefix_.alloc_, \"insert\", T, base);\n   VEC_ASSERT (ix <= prefix_.num_, \"insert\", T, base);\n@@ -945,53 +903,20 @@ vec_t<T>::quick_insert (unsigned ix, T obj VEC_CHECK_DECL)\n }\n \n \n-/* Insert an element, *PTR, at the IXth position of V.  The new value\n-   can be NULL, in which case no initialization of the inserted slot\n-   takes place. There must be sufficient space.  */\n-\n-template<typename T>\n-void\n-vec_t<T>::quick_insert (unsigned ix, const T *ptr VEC_CHECK_DECL)\n-{\n-  VEC_ASSERT (prefix_.num_ < prefix_.alloc_, \"insert\", T, base);\n-  VEC_ASSERT (ix <= prefix_.num_, \"insert\", T, base);\n-  T *slot = &vec_[ix];\n-  memmove (slot + 1, slot, (prefix_.num_++ - ix) * sizeof (T));\n-  if (ptr)\n-    *slot = *ptr;\n-}\n-\n-\n-/* Insert an element, VAL, at the IXth position of VEC. Reallocate\n+/* Insert an element, OBJ, at the IXth position of VEC. Reallocate\n    VEC, if necessary.  */\n \n template<typename T>\n template<enum vec_allocation_t A>\n void\n-vec_t<T>::safe_insert (vec_t<T> **vec, unsigned ix, T obj VEC_CHECK_DECL\n+vec_t<T>::safe_insert (vec_t<T> **vec, unsigned ix, const T &obj VEC_CHECK_DECL\n \t\t       MEM_STAT_DECL)\n {\n   reserve<A> (vec, 1 VEC_CHECK_PASS PASS_MEM_STAT);\n   (*vec)->quick_insert (ix, obj VEC_CHECK_PASS);\n }\n \n \n-/* Insert an element, *PTR, at the IXth position of VEC. Return a pointer\n-   to the slot created.  For vectors of object, the new value can be\n-   NULL, in which case no initialization of the inserted slot takes\n-   place. Reallocate V, if necessary.  */\n-\n-template<typename T>\n-template<enum vec_allocation_t A>\n-void\n-vec_t<T>::safe_insert (vec_t<T> **vec, unsigned ix, T *ptr VEC_CHECK_DECL\n-\t\t       MEM_STAT_DECL)\n-{\n-  reserve<A> (vec, 1 VEC_CHECK_PASS PASS_MEM_STAT);\n-  (*vec)->quick_insert (ix, ptr VEC_CHECK_PASS);\n-}\n-\n-\n /* Remove an element from the IXth position of this vector.  Ordering of\n    remaining elements is preserved.  This is an O(N) operation due to\n    a memmove.  */\n@@ -1043,14 +968,14 @@ vec_t<T>::block_remove (unsigned ix, unsigned len VEC_CHECK_DECL)\n \n template<typename T>\n unsigned\n-vec_t<T>::lower_bound (T obj, bool (*lessthan)(T, T)) const\n+vec_t<T>::lower_bound (T obj, bool (*lessthan)(const T &, const T &)) const\n {\n   unsigned int len = VEC_length (T, this);\n   unsigned int half, middle;\n   unsigned int first = 0;\n   while (len > 0)\n     {\n-      half = len >> 1;\n+      half = len / 2;\n       middle = first;\n       middle += half;\n       T middle_elem = (*this)[middle];\n@@ -1067,38 +992,6 @@ vec_t<T>::lower_bound (T obj, bool (*lessthan)(T, T)) const\n }\n \n \n-/* Find and return the first position in which *PTR could be inserted\n-   without changing the ordering of this vector.  LESSTHAN is a\n-   function that returns true if the first argument is strictly less\n-   than the second.  */\n-\n-template<typename T>\n-unsigned\n-vec_t<T>::lower_bound (const T *ptr,\n-\t\t       bool (*lessthan)(const T *, const T *)) const\n-{\n-  unsigned int len = VEC_length (T, this);\n-  unsigned int half, middle;\n-  unsigned int first = 0;\n-  while (len > 0)\n-    {\n-      half = len >> 1;\n-      middle = first;\n-      middle += half;\n-      const T *middle_elem = &(*this)[middle];\n-      if (lessthan (middle_elem, ptr))\n-\t{\n-\t  first = middle;\n-\t  ++first;\n-\t  len = len - half - 1;\n-\t}\n-      else\n-\tlen = half;\n-    }\n-  return first;\n-}\n-\n-\n void *vec_heap_o_reserve_1 (void *, int, size_t, size_t, bool MEM_STAT_DECL);\n void *vec_gc_o_reserve_1 (void *, int, size_t, size_t, bool MEM_STAT_DECL);\n "}]}