{"sha": "6c553b76067729cc6e10712104746d4c3e79b9d9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmM1NTNiNzYwNjc3MjljYzZlMTA3MTIxMDQ3NDZkNGMzZTc5YjlkOQ==", "commit": {"author": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2016-08-10T15:34:23Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2016-08-10T15:34:23Z"}, "message": "iterators.md (V_cmp_mixed, [...]): New.\n\n\t* config/aarch64/iterators.md (V_cmp_mixed, v_cmp_mixed): New.\n\t* config/aarch64/aarch64-simd.md (<su><maxmin>v2di3): Call\n\tgen_vcondv2div2di instead of gen_aarch64_vcond_internalv2div2di.\n\t(aarch64_vcond_internal<mode><mode>): Delete pattern.\n\t(aarch64_vcond_internal<VDQF_COND:mode><VDQF:mode>): Ditto.\n\t(vcond<v_cmp_result><mode>): Ditto.\n\t(vcond<mode><mode>): Re-implement using vec_cmp and vcond_mask.\n\t(vcondu<mode><mode>): Ditto.\n\t(vcond<v_cmp_mixed><mode>): New pattern.\n\t(vcondu<mode><v_cmp_mixed>): New pattern.\n\t(aarch64_cmtst<mode>): Revise comment using aarch64_vcond instead\n\tof aarch64_vcond_internal.\n\n\tgcc/testsuite\n\t* gcc.target/aarch64/simd/vcond-ne.c: New test.\n\nFrom-SVN: r239328", "tree": {"sha": "fea2cc512e46730fc0e49431841842c1fb083910", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fea2cc512e46730fc0e49431841842c1fb083910"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6c553b76067729cc6e10712104746d4c3e79b9d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c553b76067729cc6e10712104746d4c3e79b9d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c553b76067729cc6e10712104746d4c3e79b9d9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c553b76067729cc6e10712104746d4c3e79b9d9/comments", "author": null, "committer": null, "parents": [{"sha": "45d569f37f13d11b6ad566dfa4c1989d7419d0df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45d569f37f13d11b6ad566dfa4c1989d7419d0df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45d569f37f13d11b6ad566dfa4c1989d7419d0df"}], "stats": {"total": 433, "additions": 107, "deletions": 326}, "files": [{"sha": "0e8148b23b3b038b8bab9f34372ec9dc0fb506f3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c553b76067729cc6e10712104746d4c3e79b9d9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c553b76067729cc6e10712104746d4c3e79b9d9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6c553b76067729cc6e10712104746d4c3e79b9d9", "patch": "@@ -1,3 +1,20 @@\n+2016-08-10  Alan Lawrence  <alan.lawrence@arm.com>\n+\t    Renlin Li  <renlin.li@arm.com>\n+\t    Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* config/aarch64/iterators.md (V_cmp_mixed, v_cmp_mixed): New.\n+\t* config/aarch64/aarch64-simd.md (<su><maxmin>v2di3): Call\n+\tgen_vcondv2div2di instead of gen_aarch64_vcond_internalv2div2di.\n+\t(aarch64_vcond_internal<mode><mode>): Delete pattern.\n+\t(aarch64_vcond_internal<VDQF_COND:mode><VDQF:mode>): Ditto.\n+\t(vcond<v_cmp_result><mode>): Ditto.\n+\t(vcond<mode><mode>): Re-implement using vec_cmp and vcond_mask.\n+\t(vcondu<mode><mode>): Ditto.\n+\t(vcond<v_cmp_mixed><mode>): New pattern.\n+\t(vcondu<mode><v_cmp_mixed>): New pattern.\n+\t(aarch64_cmtst<mode>): Revise comment using aarch64_vcond instead\n+\tof aarch64_vcond_internal.\n+\n 2016-08-10  Alan Lawrence  <alan.lawrence@arm.com>\n \t    Renlin Li  <renlin.li@arm.com>\n \t    Bin Cheng  <bin.cheng@arm.com>"}, {"sha": "37d397c33d6353de5ed8aba6184e3d26b83c9ea6", "filename": "gcc/config/aarch64/aarch64-simd.md", "status": "modified", "additions": 53, "deletions": 326, "changes": 379, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c553b76067729cc6e10712104746d4c3e79b9d9/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c553b76067729cc6e10712104746d4c3e79b9d9/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md?ref=6c553b76067729cc6e10712104746d4c3e79b9d9", "patch": "@@ -1087,7 +1087,7 @@\n     }\n \n   cmp_fmt = gen_rtx_fmt_ee (cmp_operator, V2DImode, operands[1], operands[2]);\n-  emit_insn (gen_aarch64_vcond_internalv2div2di (operands[0], operands[1],\n+  emit_insn (gen_vcondv2div2di (operands[0], operands[1],\n               operands[2], cmp_fmt, operands[1], operands[2]));\n   DONE;\n })\n@@ -2560,314 +2560,6 @@\n   DONE;\n })\n \n-(define_expand \"aarch64_vcond_internal<mode><mode>\"\n-  [(set (match_operand:VSDQ_I_DI 0 \"register_operand\")\n-\t(if_then_else:VSDQ_I_DI\n-\t  (match_operator 3 \"comparison_operator\"\n-\t    [(match_operand:VSDQ_I_DI 4 \"register_operand\")\n-\t     (match_operand:VSDQ_I_DI 5 \"nonmemory_operand\")])\n-\t  (match_operand:VSDQ_I_DI 1 \"nonmemory_operand\")\n-\t  (match_operand:VSDQ_I_DI 2 \"nonmemory_operand\")))]\n-  \"TARGET_SIMD\"\n-{\n-  rtx op1 = operands[1];\n-  rtx op2 = operands[2];\n-  rtx mask = gen_reg_rtx (<MODE>mode);\n-  enum rtx_code code = GET_CODE (operands[3]);\n-\n-  /* Switching OP1 and OP2 is necessary for NE (to output a cmeq insn),\n-     and desirable for other comparisons if it results in FOO ? -1 : 0\n-     (this allows direct use of the comparison result without a bsl).  */\n-  if (code == NE\n-      || (code != EQ\n-\t  && op1 == CONST0_RTX (<V_cmp_result>mode)\n-\t  && op2 == CONSTM1_RTX (<V_cmp_result>mode)))\n-    {\n-      op1 = operands[2];\n-      op2 = operands[1];\n-      switch (code)\n-        {\n-        case LE: code = GT; break;\n-        case LT: code = GE; break;\n-        case GE: code = LT; break;\n-        case GT: code = LE; break;\n-        /* No case EQ.  */\n-        case NE: code = EQ; break;\n-        case LTU: code = GEU; break;\n-        case LEU: code = GTU; break;\n-        case GTU: code = LEU; break;\n-        case GEU: code = LTU; break;\n-        default: gcc_unreachable ();\n-        }\n-    }\n-\n-  /* Make sure we can handle the last operand.  */\n-  switch (code)\n-    {\n-    case NE:\n-      /* Normalized to EQ above.  */\n-      gcc_unreachable ();\n-\n-    case LE:\n-    case LT:\n-    case GE:\n-    case GT:\n-    case EQ:\n-      /* These instructions have a form taking an immediate zero.  */\n-      if (operands[5] == CONST0_RTX (<MODE>mode))\n-        break;\n-      /* Fall through, as may need to load into register.  */\n-    default:\n-      if (!REG_P (operands[5]))\n-        operands[5] = force_reg (<MODE>mode, operands[5]);\n-      break;\n-    }\n-\n-  switch (code)\n-    {\n-    case LT:\n-      emit_insn (gen_aarch64_cmlt<mode> (mask, operands[4], operands[5]));\n-      break;\n-\n-    case GE:\n-      emit_insn (gen_aarch64_cmge<mode> (mask, operands[4], operands[5]));\n-      break;\n-\n-    case LE:\n-      emit_insn (gen_aarch64_cmle<mode> (mask, operands[4], operands[5]));\n-      break;\n-\n-    case GT:\n-      emit_insn (gen_aarch64_cmgt<mode> (mask, operands[4], operands[5]));\n-      break;\n-\n-    case LTU:\n-      emit_insn (gen_aarch64_cmgtu<mode> (mask, operands[5], operands[4]));\n-      break;\n-\n-    case GEU:\n-      emit_insn (gen_aarch64_cmgeu<mode> (mask, operands[4], operands[5]));\n-      break;\n-\n-    case LEU:\n-      emit_insn (gen_aarch64_cmgeu<mode> (mask, operands[5], operands[4]));\n-      break;\n-\n-    case GTU:\n-      emit_insn (gen_aarch64_cmgtu<mode> (mask, operands[4], operands[5]));\n-      break;\n-\n-    /* NE has been normalized to EQ above.  */\n-    case EQ:\n-      emit_insn (gen_aarch64_cmeq<mode> (mask, operands[4], operands[5]));\n-      break;\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-    /* If we have (a = (b CMP c) ? -1 : 0);\n-       Then we can simply move the generated mask.  */\n-\n-    if (op1 == CONSTM1_RTX (<V_cmp_result>mode)\n-\t&& op2 == CONST0_RTX (<V_cmp_result>mode))\n-      emit_move_insn (operands[0], mask);\n-    else\n-      {\n-\tif (!REG_P (op1))\n-\t  op1 = force_reg (<MODE>mode, op1);\n-\tif (!REG_P (op2))\n-\t  op2 = force_reg (<MODE>mode, op2);\n-\temit_insn (gen_aarch64_simd_bsl<mode> (operands[0], mask,\n-\t\t\t\t\t       op1, op2));\n-      }\n-\n-  DONE;\n-})\n-\n-(define_expand \"aarch64_vcond_internal<VDQF_COND:mode><VDQF:mode>\"\n-  [(set (match_operand:VDQF_COND 0 \"register_operand\")\n-\t(if_then_else:VDQF\n-\t  (match_operator 3 \"comparison_operator\"\n-\t    [(match_operand:VDQF 4 \"register_operand\")\n-\t     (match_operand:VDQF 5 \"nonmemory_operand\")])\n-\t  (match_operand:VDQF_COND 1 \"nonmemory_operand\")\n-\t  (match_operand:VDQF_COND 2 \"nonmemory_operand\")))]\n-  \"TARGET_SIMD\"\n-{\n-  int inverse = 0;\n-  int use_zero_form = 0;\n-  int swap_bsl_operands = 0;\n-  rtx op1 = operands[1];\n-  rtx op2 = operands[2];\n-  rtx mask = gen_reg_rtx (<VDQF_COND:V_cmp_result>mode);\n-  rtx tmp = gen_reg_rtx (<VDQF_COND:V_cmp_result>mode);\n-\n-  rtx (*base_comparison) (rtx, rtx, rtx);\n-  rtx (*complimentary_comparison) (rtx, rtx, rtx);\n-\n-  switch (GET_CODE (operands[3]))\n-    {\n-    case GE:\n-    case GT:\n-    case LE:\n-    case LT:\n-    case EQ:\n-      if (operands[5] == CONST0_RTX (<MODE>mode))\n-\t{\n-\t  use_zero_form = 1;\n-\t  break;\n-\t}\n-      /* Fall through.  */\n-    default:\n-      if (!REG_P (operands[5]))\n-\toperands[5] = force_reg (<VDQF:MODE>mode, operands[5]);\n-    }\n-\n-  switch (GET_CODE (operands[3]))\n-    {\n-    case LT:\n-    case UNLT:\n-      inverse = 1;\n-      /* Fall through.  */\n-    case GE:\n-    case UNGE:\n-    case ORDERED:\n-    case UNORDERED:\n-      base_comparison = gen_aarch64_cmge<VDQF:mode>;\n-      complimentary_comparison = gen_aarch64_cmgt<VDQF:mode>;\n-      break;\n-    case LE:\n-    case UNLE:\n-      inverse = 1;\n-      /* Fall through.  */\n-    case GT:\n-    case UNGT:\n-      base_comparison = gen_aarch64_cmgt<VDQF:mode>;\n-      complimentary_comparison = gen_aarch64_cmge<VDQF:mode>;\n-      break;\n-    case EQ:\n-    case NE:\n-    case UNEQ:\n-      base_comparison = gen_aarch64_cmeq<VDQF:mode>;\n-      complimentary_comparison = gen_aarch64_cmeq<VDQF:mode>;\n-      break;\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  switch (GET_CODE (operands[3]))\n-    {\n-    case LT:\n-    case LE:\n-    case GT:\n-    case GE:\n-    case EQ:\n-      /* The easy case.  Here we emit one of FCMGE, FCMGT or FCMEQ.\n-\t As a LT b <=> b GE a && a LE b <=> b GT a.  Our transformations are:\n-\t a GE b -> a GE b\n-\t a GT b -> a GT b\n-\t a LE b -> b GE a\n-\t a LT b -> b GT a\n-\t a EQ b -> a EQ b\n-\t Note that there also exist direct comparison against 0 forms,\n-\t so catch those as a special case.  */\n-      if (use_zero_form)\n-\t{\n-\t  inverse = 0;\n-\t  switch (GET_CODE (operands[3]))\n-\t    {\n-\t    case LT:\n-\t      base_comparison = gen_aarch64_cmlt<VDQF:mode>;\n-\t      break;\n-\t    case LE:\n-\t      base_comparison = gen_aarch64_cmle<VDQF:mode>;\n-\t      break;\n-\t    default:\n-\t      /* Do nothing, other zero form cases already have the correct\n-\t\t base_comparison.  */\n-\t      break;\n-\t    }\n-\t}\n-\n-      if (!inverse)\n-\temit_insn (base_comparison (mask, operands[4], operands[5]));\n-      else\n-\temit_insn (complimentary_comparison (mask, operands[5], operands[4]));\n-      break;\n-    case UNLT:\n-    case UNLE:\n-    case UNGT:\n-    case UNGE:\n-    case NE:\n-      /* FCM returns false for lanes which are unordered, so if we use\n-\t the inverse of the comparison we actually want to emit, then\n-\t swap the operands to BSL, we will end up with the correct result.\n-\t Note that a NE NaN and NaN NE b are true for all a, b.\n-\n-\t Our transformations are:\n-\t a GE b -> !(b GT a)\n-\t a GT b -> !(b GE a)\n-\t a LE b -> !(a GT b)\n-\t a LT b -> !(a GE b)\n-\t a NE b -> !(a EQ b)  */\n-\n-      if (inverse)\n-\temit_insn (base_comparison (mask, operands[4], operands[5]));\n-      else\n-\temit_insn (complimentary_comparison (mask, operands[5], operands[4]));\n-\n-      swap_bsl_operands = 1;\n-      break;\n-    case UNEQ:\n-      /* We check (a > b ||  b > a).  combining these comparisons give us\n-\t true iff !(a != b && a ORDERED b), swapping the operands to BSL\n-\t will then give us (a == b ||  a UNORDERED b) as intended.  */\n-\n-      emit_insn (gen_aarch64_cmgt<VDQF:mode> (mask, operands[4], operands[5]));\n-      emit_insn (gen_aarch64_cmgt<VDQF:mode> (tmp, operands[5], operands[4]));\n-      emit_insn (gen_ior<VDQF_COND:v_cmp_result>3 (mask, mask, tmp));\n-      swap_bsl_operands = 1;\n-      break;\n-    case UNORDERED:\n-       /* Operands are ORDERED iff (a > b || b >= a).\n-\t Swapping the operands to BSL will give the UNORDERED case.  */\n-     swap_bsl_operands = 1;\n-     /* Fall through.  */\n-    case ORDERED:\n-      emit_insn (gen_aarch64_cmgt<VDQF:mode> (tmp, operands[4], operands[5]));\n-      emit_insn (gen_aarch64_cmge<VDQF:mode> (mask, operands[5], operands[4]));\n-      emit_insn (gen_ior<VDQF_COND:v_cmp_result>3 (mask, mask, tmp));\n-      break;\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  if (swap_bsl_operands)\n-    {\n-      op1 = operands[2];\n-      op2 = operands[1];\n-    }\n-\n-    /* If we have (a = (b CMP c) ? -1 : 0);\n-       Then we can simply move the generated mask.  */\n-\n-    if (op1 == CONSTM1_RTX (<VDQF_COND:V_cmp_result>mode)\n-\t&& op2 == CONST0_RTX (<VDQF_COND:V_cmp_result>mode))\n-      emit_move_insn (operands[0], mask);\n-    else\n-      {\n-\tif (!REG_P (op1))\n-\t  op1 = force_reg (<VDQF_COND:MODE>mode, op1);\n-\tif (!REG_P (op2))\n-\t  op2 = force_reg (<VDQF_COND:MODE>mode, op2);\n-\temit_insn (gen_aarch64_simd_bsl<VDQF_COND:mode> (operands[0], mask,\n-\t\t\t\t\t       op1, op2));\n-      }\n-\n-  DONE;\n-})\n-\n (define_expand \"vcond<mode><mode>\"\n   [(set (match_operand:VALLDI 0 \"register_operand\")\n \t(if_then_else:VALLDI\n@@ -2878,26 +2570,36 @@\n \t  (match_operand:VALLDI 2 \"nonmemory_operand\")))]\n   \"TARGET_SIMD\"\n {\n-  emit_insn (gen_aarch64_vcond_internal<mode><mode> (operands[0], operands[1],\n-\t\t\t\t\t       operands[2], operands[3],\n-\t\t\t\t\t       operands[4], operands[5]));\n+  rtx mask = gen_reg_rtx (<V_cmp_result>mode);\n+  enum rtx_code code = GET_CODE (operands[3]);\n+\n+  emit_insn (gen_vec_cmp<mode><v_cmp_result> (mask, operands[3],\n+\t\t\t\t\t      operands[4], operands[5]));\n+  emit_insn (gen_vcond_mask_<mode><v_cmp_result> (operands[0], operands[1],\n+\t\t\t\t\t\t  operands[2], mask));\n+\n   DONE;\n })\n \n-(define_expand \"vcond<v_cmp_result><mode>\"\n-  [(set (match_operand:<V_cmp_result> 0 \"register_operand\")\n-\t(if_then_else:<V_cmp_result>\n+(define_expand \"vcond<v_cmp_mixed><mode>\"\n+  [(set (match_operand:<V_cmp_mixed> 0 \"register_operand\")\n+\t(if_then_else:<V_cmp_mixed>\n \t  (match_operator 3 \"comparison_operator\"\n-\t    [(match_operand:VDQF 4 \"register_operand\")\n-\t     (match_operand:VDQF 5 \"nonmemory_operand\")])\n-\t  (match_operand:<V_cmp_result> 1 \"nonmemory_operand\")\n-\t  (match_operand:<V_cmp_result> 2 \"nonmemory_operand\")))]\n+\t    [(match_operand:VDQF_COND 4 \"register_operand\")\n+\t     (match_operand:VDQF_COND 5 \"nonmemory_operand\")])\n+\t  (match_operand:<V_cmp_mixed> 1 \"nonmemory_operand\")\n+\t  (match_operand:<V_cmp_mixed> 2 \"nonmemory_operand\")))]\n   \"TARGET_SIMD\"\n {\n-  emit_insn (gen_aarch64_vcond_internal<v_cmp_result><mode> (\n+  rtx mask = gen_reg_rtx (<V_cmp_result>mode);\n+  enum rtx_code code = GET_CODE (operands[3]);\n+\n+  emit_insn (gen_vec_cmp<mode><v_cmp_result> (mask, operands[3],\n+\t\t\t\t\t      operands[4], operands[5]));\n+  emit_insn (gen_vcond_mask_<v_cmp_mixed><v_cmp_result> (\n \t\t\t\t\t\toperands[0], operands[1],\n-\t\t\t\t\t\toperands[2], operands[3],\n-\t\t\t\t\t\toperands[4], operands[5]));\n+\t\t\t\t\t\toperands[2], mask));\n+\n   DONE;\n })\n \n@@ -2911,9 +2613,34 @@\n \t  (match_operand:VSDQ_I_DI 2 \"nonmemory_operand\")))]\n   \"TARGET_SIMD\"\n {\n-  emit_insn (gen_aarch64_vcond_internal<mode><mode> (operands[0], operands[1],\n-\t\t\t\t\t       operands[2], operands[3],\n-\t\t\t\t\t       operands[4], operands[5]));\n+  rtx mask = gen_reg_rtx (<MODE>mode);\n+  enum rtx_code code = GET_CODE (operands[3]);\n+\n+  emit_insn (gen_vec_cmp<mode><mode> (mask, operands[3],\n+\t\t\t\t      operands[4], operands[5]));\n+  emit_insn (gen_vcond_mask_<mode><v_cmp_result> (operands[0], operands[1],\n+\t\t\t\t\t\t  operands[2], mask));\n+  DONE;\n+})\n+\n+(define_expand \"vcondu<mode><v_cmp_mixed>\"\n+  [(set (match_operand:VDQF 0 \"register_operand\")\n+\t(if_then_else:VDQF\n+\t  (match_operator 3 \"comparison_operator\"\n+\t    [(match_operand:<V_cmp_mixed> 4 \"register_operand\")\n+\t     (match_operand:<V_cmp_mixed> 5 \"nonmemory_operand\")])\n+\t  (match_operand:VDQF 1 \"nonmemory_operand\")\n+\t  (match_operand:VDQF 2 \"nonmemory_operand\")))]\n+  \"TARGET_SIMD\"\n+{\n+  rtx mask = gen_reg_rtx (<V_cmp_result>mode);\n+  enum rtx_code code = GET_CODE (operands[3]);\n+\n+  emit_insn (gen_vec_cmp<v_cmp_mixed><v_cmp_mixed> (\n+\t\t\t\t\t\t  mask, operands[3],\n+\t\t\t\t\t\t  operands[4], operands[5]));\n+  emit_insn (gen_vcond_mask_<mode><v_cmp_result> (operands[0], operands[1],\n+\t\t\t\t\t\t  operands[2], mask));\n   DONE;\n })\n \n@@ -4507,7 +4234,7 @@\n ;; cmtst\n \n ;; Although neg (ne (and x y) 0) is the natural way of expressing a cmtst,\n-;; we don't have any insns using ne, and aarch64_vcond_internal outputs\n+;; we don't have any insns using ne, and aarch64_vcond outputs\n ;; not (neg (eq (and x y) 0))\n ;; which is rewritten by simplify_rtx as\n ;; plus (eq (and x y) 0) -1."}, {"sha": "52f645aceddef163516910657e03da6551edf084", "filename": "gcc/config/aarch64/iterators.md", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c553b76067729cc6e10712104746d4c3e79b9d9/gcc%2Fconfig%2Faarch64%2Fiterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c553b76067729cc6e10712104746d4c3e79b9d9/gcc%2Fconfig%2Faarch64%2Fiterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fiterators.md?ref=6c553b76067729cc6e10712104746d4c3e79b9d9", "patch": "@@ -662,6 +662,16 @@\n \t\t\t\t(V2DF \"v2di\") (DF    \"di\")\n \t\t\t\t(SF   \"si\")])\n \n+;; Mode for vector conditional operations where the comparison has\n+;; different type from the lhs.\n+(define_mode_attr V_cmp_mixed [(V2SI \"V2SF\") (V4SI \"V4SF\")\n+\t\t\t       (V2DI \"V2DF\") (V2SF \"V2SI\")\n+\t\t\t       (V4SF \"V4SI\") (V2DF \"V2DI\")])\n+\n+(define_mode_attr v_cmp_mixed [(V2SI \"v2sf\") (V4SI \"v4sf\")\n+\t\t\t       (V2DI \"v2df\") (V2SF \"v2si\")\n+\t\t\t       (V4SF \"v4si\") (V2DF \"v2di\")])\n+\n ;; Lower case element modes (as used in shift immediate patterns).\n (define_mode_attr ve_mode [(V8QI \"qi\") (V16QI \"qi\")\n \t\t\t   (V4HI \"hi\") (V8HI  \"hi\")"}, {"sha": "9249cc4f100a45c68e0415782981ea46647017f4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c553b76067729cc6e10712104746d4c3e79b9d9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c553b76067729cc6e10712104746d4c3e79b9d9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6c553b76067729cc6e10712104746d4c3e79b9d9", "patch": "@@ -1,3 +1,7 @@\n+2016-08-10  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* gcc.target/aarch64/simd/vcond-ne.c: New test.\n+\n 2016-08-10  Michael Meissner  <meissner@linux.vnet.ibm.com>\n \n \tPR target/72853"}, {"sha": "823228198a9aa4849ab8253132f640101657a774", "filename": "gcc/testsuite/gcc.target/aarch64/simd/vcond-ne.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c553b76067729cc6e10712104746d4c3e79b9d9/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsimd%2Fvcond-ne.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c553b76067729cc6e10712104746d4c3e79b9d9/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsimd%2Fvcond-ne.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsimd%2Fvcond-ne.c?ref=6c553b76067729cc6e10712104746d4c3e79b9d9", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_int } */\n+/* { dg-require-effective-target vect_float } */\n+/* { dg-require-effective-target vect_condition } */\n+\n+float a,b,c;\n+\n+float z[1024]; int ok[1024];\n+\n+void foo()\n+{\n+  int i;\n+\n+  for (i=0; i!=1024; ++i)\n+    {\n+      float rR = a*z[i];\n+      float rL = b*z[i];\n+      float rMin = (rR!=rL) ? rR : 0.0;\n+      ok[i] = rMin-c;\n+    }\n+}\n+\n+/* { dg-final { scan-assembler-not \"\\[ \\t\\]not\\[ \\t\\]\" } } */"}]}