{"sha": "df80fc5328ebafa5c33a783a32dd819271a49312", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGY4MGZjNTMyOGViYWZhNWMzM2E3ODNhMzJkZDgxOTI3MWE0OTMxMg==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2017-12-12T22:46:46Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2017-12-12T22:46:46Z"}, "message": "re PR tree-optimization/83298 (wrong code at -O1, -O2 and -O3 on x86_64-linux-gnu)\n\n\tPR tree-optimization/83298\n\tPR tree-optimization/83362\n\tPR tree-optimization/83383\n\t* gimple-ssa-evrp-analyze.h (class evrp_range_analyzer): Make\n\tpush_value_range a public interface.  Add new argument to\n\trecord_ranges_from_stmt.\n\t* gimple-ssa-evrp-analyze.c\n\t(evrp_range_analyzer::record_ranges_from_stmt): Add new argument.\n\tUpdate comments.  Handle recording temporary equivalences.\n\t* tree-ssa-dom.c (dom_opt_opt_walker::before_dom_children): Add\n\tnew argument to call to evrp_range_analyzer::record_ranges_from_stmt.\n\t* gimple-ssa-evrp.c (evrp_dom_walker::before_dom_children): Likewise.\n\t* tree-ssa-threadedge.c: Include alloc-pool.h, vr-values.h and\n\tgimple-ssa-evrp-analyze.h.\n\t(record_temporary_equivalences_from_phis): Add new argument.  When\n\tthe PHI arg is an SSA_NAME, set the result's range to the range\n\tof the PHI arg.\n\t(record_temporary_equivalences_from_stmts_at_dest): Record ranges\n\tfrom statements too.\n\t(thread_through_normal_block): Accept new argument, evrp_range_analyzer.\n\tPass it down to children as needed.\n\t(thread_outgoing_edges): Likewise.\n\t(thread_across_edge): Likewise.   Push/pop range state as needed.\n\t* tree-ssa-threadedge.h (thread_outgoing_edges): Update prototype.\n\n\tPR tree-optimization/83298\n\tPR tree-optimization/83362\n\tPR tree-optimization/83383\n\t* gcc.c-torture/execute/pr83298.c: New test.\n\t* gcc.c-torture/execute/pr83362.c New test.\n\t* gcc.c-torture/execute/pr83383.c New test.\n\nFrom-SVN: r255593", "tree": {"sha": "e41c0f11f99141ab8639d901936689c17b09a152", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e41c0f11f99141ab8639d901936689c17b09a152"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/df80fc5328ebafa5c33a783a32dd819271a49312", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df80fc5328ebafa5c33a783a32dd819271a49312", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df80fc5328ebafa5c33a783a32dd819271a49312", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df80fc5328ebafa5c33a783a32dd819271a49312/comments", "author": null, "committer": null, "parents": [{"sha": "708eab9b5bfdb5be44253dbac5f58cea5c652c55", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/708eab9b5bfdb5be44253dbac5f58cea5c652c55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/708eab9b5bfdb5be44253dbac5f58cea5c652c55"}], "stats": {"total": 247, "additions": 223, "deletions": 24}, "files": [{"sha": "9b4829d670af114675a1307ea898e0d4ec004a01", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df80fc5328ebafa5c33a783a32dd819271a49312/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df80fc5328ebafa5c33a783a32dd819271a49312/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=df80fc5328ebafa5c33a783a32dd819271a49312", "patch": "@@ -1,3 +1,30 @@\n+2017-12-12  Jeff Law  <law@redhat.com>\n+\n+\tPR tree-optimization/83298\n+\tPR tree-optimization/83362\n+\tPR tree-optimization/83383\n+\t* gimple-ssa-evrp-analyze.h (class evrp_range_analyzer): Make\n+\tpush_value_range a public interface.  Add new argument to\n+\trecord_ranges_from_stmt.\n+\t* gimple-ssa-evrp-analyze.c\n+\t(evrp_range_analyzer::record_ranges_from_stmt): Add new argument.\n+\tUpdate comments.  Handle recording temporary equivalences.\n+\t* tree-ssa-dom.c (dom_opt_opt_walker::before_dom_children): Add\n+\tnew argument to call to evrp_range_analyzer::record_ranges_from_stmt.\n+\t* gimple-ssa-evrp.c (evrp_dom_walker::before_dom_children): Likewise.\n+\t* tree-ssa-threadedge.c: Include alloc-pool.h, vr-values.h and\n+\tgimple-ssa-evrp-analyze.h.\n+\t(record_temporary_equivalences_from_phis): Add new argument.  When\n+\tthe PHI arg is an SSA_NAME, set the result's range to the range\n+\tof the PHI arg.\n+\t(record_temporary_equivalences_from_stmts_at_dest): Record ranges\n+\tfrom statements too.\n+\t(thread_through_normal_block): Accept new argument, evrp_range_analyzer.\n+\tPass it down to children as needed.\n+\t(thread_outgoing_edges): Likewise.\n+\t(thread_across_edge): Likewise.   Push/pop range state as needed.\n+\t* tree-ssa-threadedge.h (thread_outgoing_edges): Update prototype.\n+\n 2017-12-12  Julia Koval  <julia.koval@intel.com>\n \n \t* config/i386/i386.c (PTA_SKYLAKE_AVX512): Add PTA_CLWB."}, {"sha": "8e9881b6964db0d5a4e822b196f562da60fab5c9", "filename": "gcc/gimple-ssa-evrp-analyze.c", "status": "modified", "additions": 58, "deletions": 8, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df80fc5328ebafa5c33a783a32dd819271a49312/gcc%2Fgimple-ssa-evrp-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df80fc5328ebafa5c33a783a32dd819271a49312/gcc%2Fgimple-ssa-evrp-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-evrp-analyze.c?ref=df80fc5328ebafa5c33a783a32dd819271a49312", "patch": "@@ -56,10 +56,20 @@ evrp_range_analyzer::evrp_range_analyzer () : stack (10)\n   vr_values = new class vr_values;\n }\n \n+/* Push an unwinding marker onto the unwinding stack.  */\n+\n void\n-evrp_range_analyzer::enter (basic_block bb)\n+evrp_range_analyzer::push_marker ()\n {\n   stack.safe_push (std::make_pair (NULL_TREE, (value_range *)NULL));\n+}\n+\n+/* Analyze ranges as we enter basic block BB.  */\n+\n+void\n+evrp_range_analyzer::enter (basic_block bb)\n+{\n+  push_marker ();\n   record_ranges_from_incoming_edge (bb);\n   record_ranges_from_phis (bb);\n   bb->flags |= BB_VISITED;\n@@ -259,8 +269,13 @@ evrp_range_analyzer::record_ranges_from_phis (basic_block bb)\n     }\n }\n \n+/* Record ranges from STMT into our VR_VALUES class.  If TEMPORARY is\n+   true, then this is a temporary equivalence and should be recorded\n+   into the unwind table.  Othewise record the equivalence into the\n+   global table.  */\n+\n void\n-evrp_range_analyzer::record_ranges_from_stmt (gimple *stmt)\n+evrp_range_analyzer::record_ranges_from_stmt (gimple *stmt, bool temporary)\n {\n   tree output = NULL_TREE;\n \n@@ -273,10 +288,36 @@ evrp_range_analyzer::record_ranges_from_stmt (gimple *stmt)\n       vr_values->extract_range_from_stmt (stmt, &taken_edge, &output, &vr);\n       if (output)\n \t{\n-\t  vr_values->update_value_range (output, &vr);\n-\n-\t  /* Set the SSA with the value range.  */\n-\t  set_ssa_range_info (output, &vr);\n+\t  /* Set the SSA with the value range.  There are two cases to\n+\t     consider.  First (the the most common) is we are processing\n+\t     STMT in a context where its resulting range globally holds\n+\t     and thus it can be reflected into the global ranges and need\n+\t     not be unwound as we leave scope.\n+\n+\t     The second case occurs if we are processing a statement in\n+\t     a context where the resulting range must not be reflected\n+\t     into the global tables and must be unwound as we leave\n+\t     the current context.  This happens in jump threading for\n+\t     example.  */\n+\t  if (!temporary)\n+\t    {\n+\t      /* Case one.  We can just update the underlying range\n+\t\t information as well as the global information.  */\n+\t      vr_values->update_value_range (output, &vr);\n+\t      set_ssa_range_info (output, &vr);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* We're going to need to unwind this range.  We can\n+\t\t not use VR as that's a stack object.  We have to allocate\n+\t\t a new range and push the old range onto the stack.  We\n+\t\t also have to be very careful about sharing the underlying\n+\t\t bitmaps.  Ugh.  */\n+\t      value_range *new_vr = vr_values->allocate_value_range ();\n+\t      *new_vr = vr;\n+\t      new_vr->equiv = NULL;\n+\t      push_value_range (output, new_vr);\n+\t    }\n \t}\n       else\n \tvr_values->set_defs_to_varying (stmt);\n@@ -333,17 +374,26 @@ evrp_range_analyzer::record_ranges_from_stmt (gimple *stmt)\n     }\n }\n \n-/* Restore/pop VRs valid only for BB when we leave BB.  */\n+/* Unwind recorded ranges to their most recent state.  */\n \n void\n-evrp_range_analyzer::leave (basic_block bb ATTRIBUTE_UNUSED)\n+evrp_range_analyzer::pop_to_marker (void)\n {\n   gcc_checking_assert (!stack.is_empty ());\n   while (stack.last ().first != NULL_TREE)\n     pop_value_range (stack.last ().first);\n   stack.pop ();\n }\n \n+/* Restore/pop VRs valid only for BB when we leave BB.  */\n+\n+void\n+evrp_range_analyzer::leave (basic_block bb ATTRIBUTE_UNUSED)\n+{\n+  pop_to_marker ();\n+}\n+\n+\n /* Push the Value Range of VAR to the stack and update it with new VR.  */\n \n void"}, {"sha": "3968cfd805a4f902341c6e557c9a68c64cf76e63", "filename": "gcc/gimple-ssa-evrp-analyze.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df80fc5328ebafa5c33a783a32dd819271a49312/gcc%2Fgimple-ssa-evrp-analyze.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df80fc5328ebafa5c33a783a32dd819271a49312/gcc%2Fgimple-ssa-evrp-analyze.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-evrp-analyze.h?ref=df80fc5328ebafa5c33a783a32dd819271a49312", "patch": "@@ -31,13 +31,18 @@ class evrp_range_analyzer\n   }\n \n   void enter (basic_block);\n+  void push_marker (void);\n+  void pop_to_marker (void);\n   void leave (basic_block);\n-  void record_ranges_from_stmt (gimple *);\n+  void record_ranges_from_stmt (gimple *, bool);\n \n   /* Main interface to retrieve range information.  */\n   value_range *get_value_range (const_tree op)\n     { return vr_values->get_value_range (op); }\n \n+  /* Record a new unwindable range.  */\n+  void push_value_range (tree var, value_range *vr);\n+\n   /* Dump all the current value ranges.  This is primarily\n      a debugging interface.  */\n   void dump_all_value_ranges (FILE *fp)\n@@ -57,7 +62,6 @@ class evrp_range_analyzer\n   DISABLE_COPY_AND_ASSIGN (evrp_range_analyzer);\n   class vr_values *vr_values;\n \n-  void push_value_range (tree var, value_range *vr);\n   value_range *pop_value_range (tree var);\n   value_range *try_find_new_range (tree, tree op, tree_code code, tree limit);\n   void record_ranges_from_incoming_edge (basic_block);"}, {"sha": "112a43f4e8ea6b3c1ed5293eb1b80f173c3a77f0", "filename": "gcc/gimple-ssa-evrp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df80fc5328ebafa5c33a783a32dd819271a49312/gcc%2Fgimple-ssa-evrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df80fc5328ebafa5c33a783a32dd819271a49312/gcc%2Fgimple-ssa-evrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-evrp.c?ref=df80fc5328ebafa5c33a783a32dd819271a49312", "patch": "@@ -134,7 +134,7 @@ evrp_dom_walker::before_dom_children (basic_block bb)\n \t  print_gimple_stmt (dump_file, stmt, 0);\n \t}\n \n-      evrp_range_analyzer.record_ranges_from_stmt (stmt);\n+      evrp_range_analyzer.record_ranges_from_stmt (stmt, false);\n \n       if (gcond *cond = dyn_cast <gcond *> (stmt))\n \t{"}, {"sha": "2a863db30fa0f09cce3e5d70e6abfd5df9f2a7a0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df80fc5328ebafa5c33a783a32dd819271a49312/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df80fc5328ebafa5c33a783a32dd819271a49312/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=df80fc5328ebafa5c33a783a32dd819271a49312", "patch": "@@ -1,3 +1,12 @@\n+2017-12-12  Jeff Law  <law@redhat.com>\n+\n+\tPR tree-optimization/83298\n+\tPR tree-optimization/83362\n+\tPR tree-optimization/83383\n+\t* gcc.c-torture/execute/pr83298.c: New test.\n+\t* gcc.c-torture/execute/pr83362.c New test.\n+\t* gcc.c-torture/execute/pr83383.c New test.\n+\n 2017-12-12  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* lib/gcc-dg.exp (process-message): Avoid additional whitespace in"}, {"sha": "0e51ababf5c723384c52533609f0726aedc4e13d", "filename": "gcc/testsuite/gcc.c-torture/execute/pr83298.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df80fc5328ebafa5c33a783a32dd819271a49312/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr83298.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df80fc5328ebafa5c33a783a32dd819271a49312/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr83298.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr83298.c?ref=df80fc5328ebafa5c33a783a32dd819271a49312", "patch": "@@ -0,0 +1,11 @@\n+\n+int a, b, c = 1;\n+\n+int main ()\n+{\n+  for (; b < 1; b++)\n+    ;\n+  if (!(c * (a < 1))) \n+    __builtin_abort ();\n+  return 0; \n+}"}, {"sha": "54350819c56dc43deb557c9aac38fd146226624f", "filename": "gcc/testsuite/gcc.c-torture/execute/pr83362.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df80fc5328ebafa5c33a783a32dd819271a49312/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr83362.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df80fc5328ebafa5c33a783a32dd819271a49312/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr83362.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr83362.c?ref=df80fc5328ebafa5c33a783a32dd819271a49312", "patch": "@@ -0,0 +1,31 @@\n+typedef unsigned char u8;\n+typedef unsigned int u32;\n+\n+u32 a, b, d, e;\n+u8 c;\n+\n+static u32 __attribute__ ((noinline, noclone))\n+foo (u32 p)\n+{\n+  do\n+    {\n+      e /= 0xfff;\n+      if (p > c)\n+\td = 0;\n+      e -= 3;\n+      e *= b <= a;\n+    }\n+  while (e >= 88030);\n+  return e;\n+}\n+\n+int\n+main (void)\n+{\n+  u32 x = foo (1164);\n+  if (x != 0xfd)\n+    __builtin_abort ();\n+  return 0;\n+}\n+\n+"}, {"sha": "e803bea565bd9596c26066ac1f22829bf60451d7", "filename": "gcc/testsuite/gcc.c-torture/execute/pr83383.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df80fc5328ebafa5c33a783a32dd819271a49312/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr83383.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df80fc5328ebafa5c33a783a32dd819271a49312/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr83383.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr83383.c?ref=df80fc5328ebafa5c33a783a32dd819271a49312", "patch": "@@ -0,0 +1,25 @@\n+/* PR tree-optimization/83383 */\n+\n+unsigned long long int a = 16ULL;\n+unsigned char b = 195;\n+unsigned long long int c = ~0ULL;\n+unsigned char d = 1;\n+unsigned long long int e[2] = { 3625445792498952486ULL, 0 };\n+unsigned long long int f[2] = { 0, 8985037393681294663ULL };\n+unsigned long long int g = 5052410635626804928ULL;\n+\n+void\n+foo ()\n+{\n+  a = ((signed char) a) < b;\n+  c = (d ? e[0] : 0) - (f[1] * a ? 1 : g);\n+}\n+\n+int\n+main()\n+{\n+  foo ();\n+  if (a != 1 || c != 3625445792498952485ULL)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "93c992a921566921b97f659dcf671c91f83c7f97", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df80fc5328ebafa5c33a783a32dd819271a49312/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df80fc5328ebafa5c33a783a32dd819271a49312/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=df80fc5328ebafa5c33a783a32dd819271a49312", "patch": "@@ -1433,7 +1433,7 @@ dom_opt_dom_walker::before_dom_children (basic_block bb)\n   edge taken_edge = NULL;\n   for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n-      evrp_range_analyzer.record_ranges_from_stmt (gsi_stmt (gsi));\n+      evrp_range_analyzer.record_ranges_from_stmt (gsi_stmt (gsi), false);\n       taken_edge = this->optimize_stmt (bb, gsi);\n     }\n \n@@ -1456,6 +1456,7 @@ dom_opt_dom_walker::after_dom_children (basic_block bb)\n   x_vr_values = evrp_range_analyzer.get_vr_values ();\n   thread_outgoing_edges (bb, m_dummy_cond, m_const_and_copies,\n \t\t\t m_avail_exprs_stack,\n+\t\t\t &evrp_range_analyzer,\n \t\t\t simplify_stmt_for_jump_threading);\n   x_vr_values = NULL;\n "}, {"sha": "b7781dc7d608636d759d29e18e875a856d733400", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 50, "deletions": 11, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df80fc5328ebafa5c33a783a32dd819271a49312/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df80fc5328ebafa5c33a783a32dd819271a49312/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=df80fc5328ebafa5c33a783a32dd819271a49312", "patch": "@@ -37,6 +37,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-ssa-dom.h\"\n #include \"gimple-fold.h\"\n #include \"cfganal.h\"\n+#include \"alloc-pool.h\"\n+#include \"vr-values.h\"\n+#include \"gimple-ssa-evrp-analyze.h\"\n \n /* To avoid code explosion due to jump threading, we limit the\n    number of statements we are going to copy.  This variable\n@@ -114,17 +117,16 @@ potentially_threadable_block (basic_block bb)\n }\n \n /* Record temporary equivalences created by PHIs at the target of the\n-   edge E.  Record unwind information for the equivalences onto STACK.\n+   edge E.  Record unwind information for the equivalences into\n+   CONST_AND_COPIES and EVRP_RANGE_DATA.\n \n    If a PHI which prevents threading is encountered, then return FALSE\n-   indicating we should not thread this edge, else return TRUE.\n-\n-   If SRC_MAP/DST_MAP exist, then mark the source and destination SSA_NAMEs\n-   of any equivalences recorded.  We use this to make invalidation after\n-   traversing back edges less painful.  */\n+   indicating we should not thread this edge, else return TRUE.  */\n \n static bool\n-record_temporary_equivalences_from_phis (edge e, const_and_copies *const_and_copies)\n+record_temporary_equivalences_from_phis (edge e,\n+    const_and_copies *const_and_copies,\n+    evrp_range_analyzer *evrp_range_analyzer)\n {\n   gphi_iterator gsi;\n \n@@ -152,6 +154,14 @@ record_temporary_equivalences_from_phis (edge e, const_and_copies *const_and_cop\n \tstmt_count++;\n \n       const_and_copies->record_const_or_copy (dst, src);\n+\n+      /* Also update the value range associated with DST, using\n+\t the range from SRC.  */\n+      if (evrp_range_analyzer && TREE_CODE (src) == SSA_NAME)\n+\t{\n+\t  value_range *vr = evrp_range_analyzer->get_value_range (src);\n+\t  evrp_range_analyzer->push_value_range (dst, vr);\n+\t}\n     }\n   return true;\n }\n@@ -191,6 +201,7 @@ static gimple *\n record_temporary_equivalences_from_stmts_at_dest (edge e,\n     const_and_copies *const_and_copies,\n     avail_exprs_stack *avail_exprs_stack,\n+    evrp_range_analyzer *evrp_range_analyzer,\n     pfn_simplify simplify)\n {\n   gimple *stmt = NULL;\n@@ -235,6 +246,11 @@ record_temporary_equivalences_from_stmts_at_dest (edge e,\n       if (stmt_count > max_stmt_count)\n \treturn NULL;\n \n+      /* These are temporary ranges, do nto reflect them back into\n+\t the global range data.  */\n+      if (evrp_range_analyzer)\n+\tevrp_range_analyzer->record_ranges_from_stmt (stmt, true);\n+\n       /* If this is not a statement that sets an SSA_NAME to a new\n \t value, then do not try to simplify this statement as it will\n \t not simplify in any way that is helpful for jump threading.  */\n@@ -981,6 +997,7 @@ thread_through_normal_block (edge e,\n \t\t\t     gcond *dummy_cond,\n \t\t\t     const_and_copies *const_and_copies,\n \t\t\t     avail_exprs_stack *avail_exprs_stack,\n+\t\t\t     evrp_range_analyzer *evrp_range_analyzer,\n \t\t\t     pfn_simplify simplify,\n \t\t\t     vec<jump_thread_edge *> *path,\n \t\t\t     bitmap visited)\n@@ -992,14 +1009,16 @@ thread_through_normal_block (edge e,\n      Note that if we found a PHI that made the block non-threadable, then\n      we need to bubble that up to our caller in the same manner we do\n      when we prematurely stop processing statements below.  */\n-  if (!record_temporary_equivalences_from_phis (e, const_and_copies))\n+  if (!record_temporary_equivalences_from_phis (e, const_and_copies,\n+\t\t\t\t\t        evrp_range_analyzer))\n     return -1;\n \n   /* Now walk each statement recording any context sensitive\n      temporary equivalences we can detect.  */\n   gimple *stmt\n     = record_temporary_equivalences_from_stmts_at_dest (e, const_and_copies,\n \t\t\t\t\t\t\tavail_exprs_stack,\n+\t\t\t\t\t\t\tevrp_range_analyzer,\n \t\t\t\t\t\t\tsimplify);\n \n   /* There's two reasons STMT might be null, and distinguishing\n@@ -1114,12 +1133,15 @@ thread_across_edge (gcond *dummy_cond,\n \t\t    edge e,\n \t\t    class const_and_copies *const_and_copies,\n \t\t    class avail_exprs_stack *avail_exprs_stack,\n+\t\t    class evrp_range_analyzer *evrp_range_analyzer,\n \t\t    pfn_simplify simplify)\n {\n   bitmap visited = BITMAP_ALLOC (NULL);\n \n   const_and_copies->push_marker ();\n   avail_exprs_stack->push_marker ();\n+  if (evrp_range_analyzer)\n+    evrp_range_analyzer->push_marker ();\n \n   stmt_count = 0;\n \n@@ -1133,6 +1155,7 @@ thread_across_edge (gcond *dummy_cond,\n     threaded = thread_through_normal_block (e, dummy_cond,\n \t\t\t\t\t    const_and_copies,\n \t\t\t\t\t    avail_exprs_stack,\n+\t\t\t\t\t    evrp_range_analyzer,\n \t\t\t\t\t    simplify, path,\n \t\t\t\t\t    visited);\n   else\n@@ -1144,6 +1167,8 @@ thread_across_edge (gcond *dummy_cond,\n \t\t\t\t\t   e->dest);\n       const_and_copies->pop_to_marker ();\n       avail_exprs_stack->pop_to_marker ();\n+      if (evrp_range_analyzer)\n+\tevrp_range_analyzer->pop_to_marker ();\n       BITMAP_FREE (visited);\n       register_jump_thread (path);\n       return;\n@@ -1169,6 +1194,8 @@ thread_across_edge (gcond *dummy_cond,\n \t  BITMAP_FREE (visited);\n \t  const_and_copies->pop_to_marker ();\n           avail_exprs_stack->pop_to_marker ();\n+\t  if (evrp_range_analyzer)\n+\t    evrp_range_analyzer->pop_to_marker ();\n \t  return;\n \t}\n     }\n@@ -1196,6 +1223,8 @@ thread_across_edge (gcond *dummy_cond,\n \t{\n \t  const_and_copies->pop_to_marker ();\n           avail_exprs_stack->pop_to_marker ();\n+\t  if (evrp_range_analyzer)\n+\t    evrp_range_analyzer->pop_to_marker ();\n \t  BITMAP_FREE (visited);\n \t  return;\n \t}\n@@ -1211,6 +1240,8 @@ thread_across_edge (gcond *dummy_cond,\n \t   for each of E->dest's successors.  */\n \tconst_and_copies->push_marker ();\n \tavail_exprs_stack->push_marker ();\n+\tif (evrp_range_analyzer)\n+\t  evrp_range_analyzer->push_marker ();\n \n \t/* Avoid threading to any block we have already visited.  */\n \tbitmap_clear (visited);\n@@ -1238,6 +1269,7 @@ thread_across_edge (gcond *dummy_cond,\n \t  found = thread_through_normal_block (path->last ()->e, dummy_cond,\n \t\t\t\t\t       const_and_copies,\n \t\t\t\t\t       avail_exprs_stack,\n+\t\t\t\t\t       evrp_range_analyzer,\n \t\t\t\t\t       simplify, path,\n \t\t\t\t\t       visited) > 0;\n \n@@ -1253,12 +1285,16 @@ thread_across_edge (gcond *dummy_cond,\n \t  delete_jump_thread_path (path);\n \n \t/* And unwind the equivalence table.  */\n+\tif (evrp_range_analyzer)\n+\t  evrp_range_analyzer->pop_to_marker ();\n \tavail_exprs_stack->pop_to_marker ();\n \tconst_and_copies->pop_to_marker ();\n       }\n     BITMAP_FREE (visited);\n   }\n \n+  if (evrp_range_analyzer)\n+    evrp_range_analyzer->pop_to_marker ();\n   const_and_copies->pop_to_marker ();\n   avail_exprs_stack->pop_to_marker ();\n }\n@@ -1280,6 +1316,7 @@ void\n thread_outgoing_edges (basic_block bb, gcond *dummy_cond,\n \t\t       class const_and_copies *const_and_copies,\n \t\t       class avail_exprs_stack *avail_exprs_stack,\n+\t\t       class evrp_range_analyzer *evrp_range_analyzer,\n \t\t       tree (*simplify) (gimple *, gimple *,\n \t\t\t\t\t class avail_exprs_stack *,\n \t\t\t\t\t basic_block))\n@@ -1297,7 +1334,7 @@ thread_outgoing_edges (basic_block bb, gcond *dummy_cond,\n     {\n       thread_across_edge (dummy_cond, single_succ_edge (bb),\n \t\t\t  const_and_copies, avail_exprs_stack,\n-\t\t\t  simplify);\n+\t\t\t  evrp_range_analyzer, simplify);\n     }\n   else if ((last = last_stmt (bb))\n \t   && gimple_code (last) == GIMPLE_COND\n@@ -1313,11 +1350,13 @@ thread_outgoing_edges (basic_block bb, gcond *dummy_cond,\n \t more than one predecessor and more than one successor.  */\n       if (potentially_threadable_block (true_edge->dest))\n \tthread_across_edge (dummy_cond, true_edge,\n-\t\t\t    const_and_copies, avail_exprs_stack, simplify);\n+\t\t\t    const_and_copies, avail_exprs_stack,\n+\t\t\t    evrp_range_analyzer, simplify);\n \n       /* Similarly for the ELSE arm.  */\n       if (potentially_threadable_block (false_edge->dest))\n \tthread_across_edge (dummy_cond, false_edge,\n-\t\t\t    const_and_copies, avail_exprs_stack, simplify);\n+\t\t\t    const_and_copies, avail_exprs_stack,\n+\t\t\t    evrp_range_analyzer, simplify);\n     }\n }"}, {"sha": "0f2e39f72e39eb83b88dc0b0a37d0685ded3f2f7", "filename": "gcc/tree-ssa-threadedge.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df80fc5328ebafa5c33a783a32dd819271a49312/gcc%2Ftree-ssa-threadedge.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df80fc5328ebafa5c33a783a32dd819271a49312/gcc%2Ftree-ssa-threadedge.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.h?ref=df80fc5328ebafa5c33a783a32dd819271a49312", "patch": "@@ -30,9 +30,11 @@ extern void threadedge_initialize_values (void);\n extern void threadedge_finalize_values (void);\n extern bool potentially_threadable_block (basic_block);\n extern void propagate_threaded_block_debug_into (basic_block, basic_block);\n+class evrp_range_analyzer;\n extern void thread_outgoing_edges (basic_block, gcond *,\n \t\t\t\t   const_and_copies *,\n \t\t\t\t   avail_exprs_stack *,\n+\t\t\t\t   evrp_range_analyzer *,\n \t\t\t\t   tree (*) (gimple *, gimple *,\n \t\t\t\t\t     avail_exprs_stack *, basic_block));\n "}, {"sha": "7df6f244657d03bfa4557568747c6cee3a33bcd9", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df80fc5328ebafa5c33a783a32dd819271a49312/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df80fc5328ebafa5c33a783a32dd819271a49312/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=df80fc5328ebafa5c33a783a32dd819271a49312", "patch": "@@ -6677,7 +6677,7 @@ vrp_dom_walker::after_dom_children (basic_block bb)\n \n   x_vr_values = vr_values;\n   thread_outgoing_edges (bb, m_dummy_cond, m_const_and_copies,\n-\t\t\t m_avail_exprs_stack,\n+\t\t\t m_avail_exprs_stack, NULL,\n \t\t\t simplify_stmt_for_jump_threading);\n   x_vr_values = NULL;\n "}]}