{"sha": "44b8152b881c0d4e8583ecfffdc41d7a3b1d7a0b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDRiODE1MmI4ODFjMGQ0ZTg1ODNlY2ZmZmRjNDFkN2EzYjFkN2EwYg==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2002-01-16T14:15:25Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2002-01-16T14:15:25Z"}, "message": "s390.c (s390_emit_prologue): Do not emit USE insn for GOT register; add REG_MAYBE_DEAD notes instead.\n\n\t* config/s390/s390.c (s390_emit_prologue): Do not emit USE\n\tinsn for GOT register; add REG_MAYBE_DEAD notes instead.\n\tconfig/s390/s390.md (call, call_value): Add GOT register to\n\tCALL_INSN_FUNCTION_USAGE where needed.\n\t(call_exp, call_value_exp): New.\n\nFrom-SVN: r48908", "tree": {"sha": "2a8f379c4f813b665e011f940c9d562e40f61f00", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2a8f379c4f813b665e011f940c9d562e40f61f00"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/44b8152b881c0d4e8583ecfffdc41d7a3b1d7a0b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44b8152b881c0d4e8583ecfffdc41d7a3b1d7a0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44b8152b881c0d4e8583ecfffdc41d7a3b1d7a0b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44b8152b881c0d4e8583ecfffdc41d7a3b1d7a0b/comments", "author": null, "committer": null, "parents": [{"sha": "1d6e90ac10263b976699d6c039dc9a49c0598aaa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d6e90ac10263b976699d6c039dc9a49c0598aaa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d6e90ac10263b976699d6c039dc9a49c0598aaa"}], "stats": {"total": 104, "additions": 76, "deletions": 28}, "files": [{"sha": "5c262ab4a80b7af120f13d3c0957439ab4450181", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44b8152b881c0d4e8583ecfffdc41d7a3b1d7a0b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44b8152b881c0d4e8583ecfffdc41d7a3b1d7a0b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=44b8152b881c0d4e8583ecfffdc41d7a3b1d7a0b", "patch": "@@ -1,3 +1,11 @@\n+2002-01-16  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* config/s390/s390.c (s390_emit_prologue): Do not emit USE\n+\tinsn for GOT register; add REG_MAYBE_DEAD notes instead.\n+\tconfig/s390/s390.md (call, call_value): Add GOT register to\n+\tCALL_INSN_FUNCTION_USAGE where needed.\n+\t(call_exp, call_value_exp): New.\n+\n 2002-01-16  Nick Clifton  <nickc@cambridge.redhat.com>\n \n \t* config/arm/arm.c: General formatting tidy up."}, {"sha": "2cf2e41fd1f078e04a5a9989d48488aee768dd74", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44b8152b881c0d4e8583ecfffdc41d7a3b1d7a0b/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44b8152b881c0d4e8583ecfffdc41d7a3b1d7a0b/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=44b8152b881c0d4e8583ecfffdc41d7a3b1d7a0b", "patch": "@@ -2989,11 +2989,13 @@ s390_emit_prologue ()\n \t  got_symbol = force_const_mem (Pmode, got_symbol);\n \t  insn = emit_move_insn (pic_offset_table_rtx,\n \t\t\t\t got_symbol);\t\t \n+          REG_NOTES(insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD, NULL_RTX,\n+                                               REG_NOTES (insn));\n+\n \t  insn = emit_insn (gen_add2_insn (pic_offset_table_rtx,\n \t\t\t\t\t   gen_rtx_REG (Pmode, BASE_REGISTER)));\n-\n-\t  /* We need the GOT pointer even if we don't know it ...  */\n-\t  emit_insn (gen_rtx_USE (VOIDmode, pic_offset_table_rtx));\n+          REG_NOTES(insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD, NULL_RTX,\n+                                               REG_NOTES (insn));\n \t}\n     }      \n }"}, {"sha": "9a50992f95364909f8a7f3a8e6ddf04acede96a5", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 63, "deletions": 25, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44b8152b881c0d4e8583ecfffdc41d7a3b1d7a0b/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44b8152b881c0d4e8583ecfffdc41d7a3b1d7a0b/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=44b8152b881c0d4e8583ecfffdc41d7a3b1d7a0b", "patch": "@@ -5965,20 +5965,14 @@\n ;\n \n (define_expand \"call\"\n-  [(parallel [(call (match_operand 0 \"\" \"\")\n-                    (match_operand 1 \"\" \"\"))\n-              (clobber (match_operand 2 \"\" \"\"))])]\n+  [(call (match_operand 0 \"\" \"\")\n+         (match_operand 1 \"\" \"\"))\n+   (use (match_operand 2 \"\" \"\"))]\n   \"\"\n   \"\n {\n-  /* Abuse operand 2 to hold the return register.  */\n-  operands[2] = gen_rtx_REG (Pmode, RETURN_REGNUM);\n-\n-  /* In 31-bit, we must load the GOT register even if the \n-     compiler doesn't know about it, because the PLT glue \n-     code uses it.  In 64-bit, this is not necessary.  */\n-  if (flag_pic && !TARGET_64BIT)\n-    current_function_uses_pic_offset_table = 1;\n+  int plt_call = 0;\n+  rtx insn;\n \n   /* Direct function calls need special treatment.  */\n   if (GET_CODE (XEXP (operands[0], 0)) == SYMBOL_REF)\n@@ -5987,10 +5981,12 @@\n \n       /* When calling a global routine in PIC mode, we must\n          replace the symbol itself with the PLT stub.  */\n-      if (flag_pic && !SYMBOL_REF_FLAG(sym))\n+      if (flag_pic && !SYMBOL_REF_FLAG (sym))\n         {\n           sym = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, sym), 113);\n           sym = gen_rtx_CONST (Pmode, sym);\n+\n+\t  plt_call = 1;\n         }\n \n       /* Unless we can use the bras(l) insn, force the \n@@ -6004,8 +6000,30 @@\n \n       operands[0] = gen_rtx_MEM (QImode, sym);\n     }\n+\n+  /* Emit insn.  */\n+  insn = emit_call_insn (gen_call_exp (operands[0], operands[1],\n+  \t\t\t\t       gen_rtx_REG (Pmode, RETURN_REGNUM)));\n+\n+  /* In 31-bit, we must load the GOT register even if the \n+     compiler doesn't know about it, because the PLT glue \n+     code uses it.  In 64-bit, this is not necessary.  */\n+  if (plt_call && !TARGET_64BIT)\n+    {\n+      current_function_uses_pic_offset_table = 1;\n+      use_reg (&CALL_INSN_FUNCTION_USAGE (insn), pic_offset_table_rtx);\n+    }\n+\n+  DONE;\n }\")\n \n+(define_expand \"call_exp\"\n+  [(parallel [(call (match_operand 0 \"\" \"\")\n+                    (match_operand 1 \"\" \"\"))\n+              (clobber (match_operand 2 \"\" \"\"))])]\n+  \"\"\n+  \"\")\n+\n (define_insn \"brasl\"\n   [(call (mem:QI (match_operand:DI 0 \"bras_sym_operand\" \"X\"))\n          (match_operand:SI 1 \"const_int_operand\" \"n\"))\n@@ -6070,21 +6088,15 @@\n ;\n \n (define_expand \"call_value\"\n-  [(parallel [(set (match_operand 0 \"\" \"\")\n-                   (call (match_operand 1 \"\" \"\")\n-                         (match_operand 2 \"\" \"\")))\n-              (clobber (match_operand 3 \"\" \"\"))])]\n+  [(set (match_operand 0 \"\" \"\")\n+        (call (match_operand 1 \"\" \"\")\n+              (match_operand 2 \"\" \"\")))\n+   (use (match_operand 3 \"\" \"\"))]\n   \"\"\n   \"\n {\n-  /* Abuse operand 3 to hold the return register.  */\n-  operands[3] = gen_rtx_REG (Pmode, RETURN_REGNUM);\n-\n-  /* In 31-bit, we must load the GOT register even if the \n-     compiler doesn't know about it, because the PLT glue \n-     code uses it.  In 64-bit, this is not necessary.  */\n-  if (flag_pic && !TARGET_64BIT)\n-    current_function_uses_pic_offset_table = 1;\n+  int plt_call = 0;\n+  rtx insn;\n \n   /* Direct function calls need special treatment.  */\n   if (GET_CODE (XEXP (operands[1], 0)) == SYMBOL_REF)\n@@ -6093,10 +6105,12 @@\n \n       /* When calling a global routine in PIC mode, we must\n          replace the symbol itself with the PLT stub.  */\n-      if (flag_pic && !SYMBOL_REF_FLAG(sym))\n+      if (flag_pic && !SYMBOL_REF_FLAG (sym))\n         {\n           sym = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, sym), 113);\n           sym = gen_rtx_CONST (Pmode, sym);\n+\n+\t  plt_call = 1;\n         }\n \n       /* Unless we can use the bras(l) insn, force the \n@@ -6110,8 +6124,32 @@\n \n       operands[1] = gen_rtx_MEM (QImode, sym);\n     }\n+\n+  /* Emit insn.  */\n+  insn = emit_call_insn (\n+\t    gen_call_value_exp (operands[0], operands[1], operands[2],\n+  \t\t\t\tgen_rtx_REG (Pmode, RETURN_REGNUM)));\n+\n+  /* In 31-bit, we must load the GOT register even if the \n+     compiler doesn't know about it, because the PLT glue \n+     code uses it.  In 64-bit, this is not necessary.  */\n+  if (plt_call && !TARGET_64BIT)\n+    {\n+      current_function_uses_pic_offset_table = 1;\n+      use_reg (&CALL_INSN_FUNCTION_USAGE (insn), pic_offset_table_rtx);\n+    }\n+\n+  DONE;\n }\")\n \n+(define_expand \"call_value_exp\"\n+  [(parallel [(set (match_operand 0 \"\" \"\")\n+                   (call (match_operand 1 \"\" \"\")\n+                         (match_operand 2 \"\" \"\")))\n+              (clobber (match_operand 3 \"\" \"\"))])]\n+  \"\"\n+  \"\")\n+\n (define_insn \"brasl_r\"\n   [(set (match_operand 0 \"register_operand\" \"=df\")\n         (call (mem:QI (match_operand:DI 1 \"bras_sym_operand\" \"X\"))"}]}