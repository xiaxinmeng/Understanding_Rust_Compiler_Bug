{"sha": "6790d1abcc421fd943633f68a4fed28e5fb474b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njc5MGQxYWJjYzQyMWZkOTQzNjMzZjY4YTRmZWQyOGU1ZmI0NzRiNA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2004-03-03T14:02:43Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2004-03-03T14:02:43Z"}, "message": "cselib.c (hash_table): Remove GTY marker.\n\n\t* cselib.c (hash_table):  Remove GTY marker.\n\t(reg_values): Turn into array.\n\t(used_regs): Likewise.\n\t(n_used_regs): New static variable.\n\t(reg_values_old): Kill.\n\t(clear_table): Update uses of arrays.\n\t(cselib_lookup): Likewise.\n\t(cselib_record_set): Likewise.\n\t(cselib_init): Likewise.\n\t(cselib_finish): Likewise.\n\t(cselib_udpate_varray_sizes): Kill.\n\t* cselib.h (cselib_update_varray_sizes): Kill.\n\nFrom-SVN: r78830", "tree": {"sha": "e832c10c82481cecce5049923168b1fed238e76a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e832c10c82481cecce5049923168b1fed238e76a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6790d1abcc421fd943633f68a4fed28e5fb474b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6790d1abcc421fd943633f68a4fed28e5fb474b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6790d1abcc421fd943633f68a4fed28e5fb474b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6790d1abcc421fd943633f68a4fed28e5fb474b4/comments", "author": null, "committer": null, "parents": [{"sha": "33e6a97ae7a689cf044d2c26370ae305f178d05b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33e6a97ae7a689cf044d2c26370ae305f178d05b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33e6a97ae7a689cf044d2c26370ae305f178d05b"}], "stats": {"total": 83, "additions": 43, "deletions": 40}, "files": [{"sha": "ee3bc41a1e2c45466fec4c5b5cd4517d658caf41", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6790d1abcc421fd943633f68a4fed28e5fb474b4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6790d1abcc421fd943633f68a4fed28e5fb474b4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6790d1abcc421fd943633f68a4fed28e5fb474b4", "patch": "@@ -1,3 +1,18 @@\n+2004-03-03  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cselib.c (hash_table):  Remove GTY marker.\n+\t(reg_values): Turn into array.\n+\t(used_regs): Likewise.\n+\t(n_used_regs): New static variable.\n+\t(reg_values_old): Kill.\n+\t(clear_table): Update uses of arrays.\n+\t(cselib_lookup): Likewise.\n+\t(cselib_record_set): Likewise.\n+\t(cselib_init): Likewise.\n+\t(cselib_finish): Likewise.\n+\t(cselib_udpate_varray_sizes): Kill.\n+\t* cselib.h (cselib_update_varray_sizes): Kill.\n+\n 2004-03-03  Paul Brook  <paul@codesourcery.com>\n \n \t* flow.c (ior_reg_cond, and_reg_cond): Remove stray \")\"."}, {"sha": "169b92706b6182c6fd05bfefa4271cffa19cdb68", "filename": "gcc/cselib.c", "status": "modified", "additions": 28, "deletions": 39, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6790d1abcc421fd943633f68a4fed28e5fb474b4/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6790d1abcc421fd943633f68a4fed28e5fb474b4/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=6790d1abcc421fd943633f68a4fed28e5fb474b4", "patch": "@@ -74,7 +74,7 @@ static void cselib_record_sets (rtx);\n      the locations of the entries with the rtx we are looking up.  */\n \n /* A table that enables us to look up elts by their value.  */\n-static GTY((param_is (cselib_val))) htab_t hash_table;\n+static htab_t hash_table;\n \n /* This is a global so we don't have to pass this through every function.\n    It is used in new_elt_loc_list to set SETTING_INSN.  */\n@@ -101,18 +101,18 @@ static int n_useless_values;\n    which the register was set; if the mode is unknown or the value is\n    no longer valid in that mode, ELT will be NULL for the first\n    element.  */\n-static GTY(()) varray_type reg_values;\n-static GTY((deletable (\"\"))) varray_type reg_values_old;\n-#define REG_VALUES(I) VARRAY_ELT_LIST (reg_values, (I))\n+struct elt_list **reg_values;\n+unsigned int reg_values_size;\n+#define REG_VALUES(i) reg_values[i]\n \n /* The largest number of hard regs used by any entry added to the\n    REG_VALUES table.  Cleared on each clear_table() invocation.  */\n static unsigned int max_value_regs;\n \n /* Here the set of indices I with REG_VALUES(I) != 0 is saved.  This is used\n    in clear_table() for fast emptying.  */\n-static GTY(()) varray_type used_regs;\n-static GTY((deletable (\"\"))) varray_type used_regs_old;\n+static unsigned int *used_regs;\n+static unsigned int n_used_regs;\n \n /* We pass this to cselib_invalidate_mem to invalidate all of\n    memory for a non-const call instruction.  */\n@@ -206,12 +206,12 @@ clear_table (void)\n {\n   unsigned int i;\n \n-  for (i = 0; i < VARRAY_ACTIVE_SIZE (used_regs); i++)\n-    REG_VALUES (VARRAY_UINT (used_regs, i)) = 0;\n+  for (i = 0; i < n_used_regs; i++)\n+    REG_VALUES (used_regs[i]) = 0;\n \n   max_value_regs = 0;\n \n-  VARRAY_POP_ALL (used_regs);\n+  n_used_regs = 0;\n \n   htab_empty (hash_table);\n \n@@ -913,7 +913,7 @@ cselib_lookup (rtx x, enum machine_mode mode, int create)\n \t  /* Maintain the invariant that the first entry of\n \t     REG_VALUES, if present, must be the value used to set the\n \t     register, or NULL.  */\n-\t  VARRAY_PUSH_UINT (used_regs, i);\n+\t  used_regs[n_used_regs++] = i;\n \t  REG_VALUES (i) = new_elt_list (REG_VALUES (i), NULL);\n \t}\n       REG_VALUES (i)->next = new_elt_list (REG_VALUES (i)->next, e);\n@@ -1185,7 +1185,7 @@ cselib_record_set (rtx dest, cselib_val *src_elt, cselib_val *dest_addr_elt)\n \n       if (REG_VALUES (dreg) == 0)\n \t{\n-\t  VARRAY_PUSH_UINT (used_regs, dreg);\n+\t  used_regs[n_used_regs++] = dreg;\n \t  REG_VALUES (dreg) = new_elt_list (REG_VALUES (dreg), src_elt);\n \t}\n       else\n@@ -1371,22 +1371,6 @@ cselib_process_insn (rtx insn)\n     remove_useless_values ();\n }\n \n-/* Make sure our varrays are big enough.  Not called from any cselib routines;\n-   it must be called by the user if it allocated new registers.  */\n-\n-void\n-cselib_update_varray_sizes (void)\n-{\n-  unsigned int nregs = max_reg_num ();\n-\n-  if (nregs == cselib_nregs)\n-    return;\n-\n-  cselib_nregs = nregs;\n-  VARRAY_GROW (reg_values, nregs);\n-  VARRAY_GROW (used_regs, nregs);\n-}\n-\n /* Initialize cselib for one pass.  The caller must also call\n    init_alias_analysis.  */\n \n@@ -1406,18 +1390,22 @@ cselib_init (void)\n     callmem = gen_rtx_MEM (BLKmode, const0_rtx);\n \n   cselib_nregs = max_reg_num ();\n-  if (reg_values_old != NULL && VARRAY_SIZE (reg_values_old) >= cselib_nregs)\n-    {\n-      reg_values = reg_values_old;\n-      used_regs = used_regs_old;\n-    }\n-  else\n+\n+  /* We preserve reg_values to allow expensive clearing of the whole thing.\n+     Reallocate it however if it happens to be too large.  */\n+  if (!reg_values || reg_values_size < cselib_nregs\n+      || (reg_values_size > 10 && reg_values_size > cselib_nregs * 4))\n     {\n-      VARRAY_ELT_LIST_INIT (reg_values, cselib_nregs, \"reg_values\");\n-      VARRAY_UINT_INIT (used_regs, cselib_nregs, \"used_regs\");\n+      if (reg_values)\n+\tfree (reg_values);\n+      /* Some space for newly emit instructions so we don't end up\n+\t reallocating in between passes.  */\n+      reg_values_size = cselib_nregs + (63 + cselib_nregs) / 16;\n+      reg_values = xcalloc (reg_values_size, sizeof (reg_values));\n     }\n-  hash_table = htab_create_ggc (31, get_value_hash, entry_and_rtx_equal_p,\n-\t\t\t\tNULL);\n+  used_regs = xmalloc (sizeof (*used_regs) * cselib_nregs);\n+  n_used_regs = 0;\n+  hash_table = htab_create (31, get_value_hash, entry_and_rtx_equal_p, NULL);\n   cselib_current_insn_in_libcall = false;\n }\n \n@@ -1431,13 +1419,14 @@ cselib_finish (void)\n   free_alloc_pool (cselib_val_pool);\n   free_alloc_pool (value_pool);\n   clear_table ();\n-  reg_values_old = reg_values;\n+  htab_delete (hash_table);\n   reg_values = 0;\n-  used_regs_old = used_regs;\n   used_regs = 0;\n   hash_table = 0;\n   n_useless_values = 0;\n   next_unknown_value = 0;\n+  free (used_regs);\n+  used_regs = 0;\n }\n \n #include \"gt-cselib.h\""}, {"sha": "2060a81c0411f7e2cfc183f2b60e37cfb9dc1a57", "filename": "gcc/cselib.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6790d1abcc421fd943633f68a4fed28e5fb474b4/gcc%2Fcselib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6790d1abcc421fd943633f68a4fed28e5fb474b4/gcc%2Fcselib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.h?ref=6790d1abcc421fd943633f68a4fed28e5fb474b4", "patch": "@@ -64,7 +64,6 @@ struct elt_list GTY(())\n };\n \n extern cselib_val *cselib_lookup (rtx, enum machine_mode, int);\n-extern void cselib_update_varray_sizes (void);\n extern void cselib_init (void);\n extern void cselib_finish (void);\n extern void cselib_process_insn (rtx);"}]}